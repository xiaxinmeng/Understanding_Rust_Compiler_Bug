{"sha": "1ea8653d0116365e09dca7b22c7264d0fc877433", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFlYTg2NTNkMDExNjM2NWUwOWRjYTdiMjJjNzI2NGQwZmM4Nzc0MzM=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2020-04-03T20:55:05Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-04-03T20:55:05Z"}, "message": "Rollup merge of #70597 - vakaras:thread_new_double_free_bug_fix, r=Amanieu\n\nFix double-free and undefined behaviour in libstd::syn::unix::Thread::new\n\nWhile working on concurrency support for Miri, I found that the `libstd::syn::unix::Thread::new` method has two potential problems: double-free and undefined behaviour.\n\n**Double-free** could occur if the following events happened (credit for pointing this out goes to @RalfJung):\n\n1.  The call to `pthread_create` successfully launched a new thread that executed to completion and deallocated `p`.\n2.  The call to `pthread_attr_destroy` returned a non-zero value causing the `assert_eq!` to panic.\n3.  Since `mem::forget(p)` was not yet executed, the destructor of `p` would be executed and cause a double-free.\n\nAs far as I understand, this code also violates the stacked-borrows aliasing rules and thus would result in **undefined behaviour** if these rules were adopted.  The problem is that the ownership of `p` is passed to the newly created thread before the call to `mem::forget`. Since the call to `mem::forget` is still a call, it counts as a use of `p` and triggers UB.\n\nThis pull request changes the code to use `mem::ManuallyDrop` instead of `mem::forget`. As a consequence, in case of a panic, `p` would be potentially leaked, which while undesirable is probably better than double-free or undefined behaviour.", "tree": {"sha": "b91bbda605869e3958d0b1fbd2ee346ba0de092e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b91bbda605869e3958d0b1fbd2ee346ba0de092e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1ea8653d0116365e09dca7b22c7264d0fc877433", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJeh6KpCRBK7hj4Ov3rIwAAdHIIALG2UTzL7bTL4uyPiZiHbSSm\n+tM9z0gatWRMi2q8JdWvQwI/rSe4fiCtTeE3DV8cm5aHriL7c/ljxyfZOsgvvqjo\n288vGH2VYBxLWLnyrPlQTyS51rTO1M4MjKOSDG78o9Yf/vYCyaLSH779QeDmYoMe\n3s4zlKw6EFzTItAqA8Qa7SN1xtDtefDHlfHSEYx5wx1dgmb9uZcuAIkDgmiJX1zL\ncL/ra9wc4OeniMRB5FNLe9XefTfcjqb17c1DBEb23+WNGMhOkQ6HkFk8rJfB/5MN\nRKlbC2LjMvzdjOvwSXx5grlDD4Ehy+G2anwYES9dzD+V8IU9Bebiw83StQxdJiM=\n=UZZw\n-----END PGP SIGNATURE-----\n", "payload": "tree b91bbda605869e3958d0b1fbd2ee346ba0de092e\nparent 17a59fb29cc2b2144a61b475375695190f08ffae\nparent d512b22f8bbe50ab944cf59a423ca72ccf8538db\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1585947305 +0200\ncommitter GitHub <noreply@github.com> 1585947305 +0200\n\nRollup merge of #70597 - vakaras:thread_new_double_free_bug_fix, r=Amanieu\n\nFix double-free and undefined behaviour in libstd::syn::unix::Thread::new\n\nWhile working on concurrency support for Miri, I found that the `libstd::syn::unix::Thread::new` method has two potential problems: double-free and undefined behaviour.\n\n**Double-free** could occur if the following events happened (credit for pointing this out goes to @RalfJung):\n\n1.  The call to `pthread_create` successfully launched a new thread that executed to completion and deallocated `p`.\n2.  The call to `pthread_attr_destroy` returned a non-zero value causing the `assert_eq!` to panic.\n3.  Since `mem::forget(p)` was not yet executed, the destructor of `p` would be executed and cause a double-free.\n\nAs far as I understand, this code also violates the stacked-borrows aliasing rules and thus would result in **undefined behaviour** if these rules were adopted.  The problem is that the ownership of `p` is passed to the newly created thread before the call to `mem::forget`. Since the call to `mem::forget` is still a call, it counts as a use of `p` and triggers UB.\n\nThis pull request changes the code to use `mem::ManuallyDrop` instead of `mem::forget`. As a consequence, in case of a panic, `p` would be potentially leaked, which while undesirable is probably better than double-free or undefined behaviour.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1ea8653d0116365e09dca7b22c7264d0fc877433", "html_url": "https://github.com/rust-lang/rust/commit/1ea8653d0116365e09dca7b22c7264d0fc877433", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1ea8653d0116365e09dca7b22c7264d0fc877433/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "17a59fb29cc2b2144a61b475375695190f08ffae", "url": "https://api.github.com/repos/rust-lang/rust/commits/17a59fb29cc2b2144a61b475375695190f08ffae", "html_url": "https://github.com/rust-lang/rust/commit/17a59fb29cc2b2144a61b475375695190f08ffae"}, {"sha": "d512b22f8bbe50ab944cf59a423ca72ccf8538db", "url": "https://api.github.com/repos/rust-lang/rust/commits/d512b22f8bbe50ab944cf59a423ca72ccf8538db", "html_url": "https://github.com/rust-lang/rust/commit/d512b22f8bbe50ab944cf59a423ca72ccf8538db"}], "stats": {"total": 136, "additions": 59, "deletions": 77}, "files": [{"sha": "9339b143731052799342e021d6bc1b37624e876f", "filename": "src/libstd/sys/cloudabi/stack_overflow.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1ea8653d0116365e09dca7b22c7264d0fc877433/src%2Flibstd%2Fsys%2Fcloudabi%2Fstack_overflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ea8653d0116365e09dca7b22c7264d0fc877433/src%2Flibstd%2Fsys%2Fcloudabi%2Fstack_overflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcloudabi%2Fstack_overflow.rs?ref=1ea8653d0116365e09dca7b22c7264d0fc877433", "patch": "@@ -1,13 +1,5 @@\n #![cfg_attr(test, allow(dead_code))]\n \n-pub struct Handler;\n-\n-impl Handler {\n-    pub unsafe fn new() -> Handler {\n-        Handler\n-    }\n-}\n-\n pub unsafe fn init() {}\n \n pub unsafe fn cleanup() {}"}, {"sha": "a15dc8653e83a256d01ba17618caedd905e3b473", "filename": "src/libstd/sys/cloudabi/thread.rs", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/1ea8653d0116365e09dca7b22c7264d0fc877433/src%2Flibstd%2Fsys%2Fcloudabi%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ea8653d0116365e09dca7b22c7264d0fc877433/src%2Flibstd%2Fsys%2Fcloudabi%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcloudabi%2Fthread.rs?ref=1ea8653d0116365e09dca7b22c7264d0fc877433", "patch": "@@ -5,7 +5,6 @@ use crate::mem;\n use crate::ptr;\n use crate::sys::cloudabi::abi;\n use crate::sys::time::checked_dur2intervals;\n-use crate::sys_common::thread::*;\n use crate::time::Duration;\n \n pub const DEFAULT_MIN_STACK_SIZE: usize = 2 * 1024 * 1024;\n@@ -22,27 +21,33 @@ unsafe impl Sync for Thread {}\n impl Thread {\n     // unsafe: see thread::Builder::spawn_unchecked for safety requirements\n     pub unsafe fn new(stack: usize, p: Box<dyn FnOnce()>) -> io::Result<Thread> {\n-        let p = box p;\n+        let p = Box::into_raw(box p);\n         let mut native: libc::pthread_t = mem::zeroed();\n         let mut attr: libc::pthread_attr_t = mem::zeroed();\n         assert_eq!(libc::pthread_attr_init(&mut attr), 0);\n \n         let stack_size = cmp::max(stack, min_stack_size(&attr));\n         assert_eq!(libc::pthread_attr_setstacksize(&mut attr, stack_size), 0);\n \n-        let ret = libc::pthread_create(&mut native, &attr, thread_start, &*p as *const _ as *mut _);\n+        let ret = libc::pthread_create(&mut native, &attr, thread_start, p as *mut _);\n+        // Note: if the thread creation fails and this assert fails, then p will\n+        // be leaked. However, an alternative design could cause double-free\n+        // which is clearly worse.\n         assert_eq!(libc::pthread_attr_destroy(&mut attr), 0);\n \n         return if ret != 0 {\n+            // The thread failed to start and as a result p was not consumed. Therefore, it is\n+            // safe to reconstruct the box so that it gets deallocated.\n+            drop(Box::from_raw(p));\n             Err(io::Error::from_raw_os_error(ret))\n         } else {\n-            mem::forget(p); // ownership passed to pthread_create\n             Ok(Thread { id: native })\n         };\n \n         extern \"C\" fn thread_start(main: *mut libc::c_void) -> *mut libc::c_void {\n             unsafe {\n-                start_thread(main as *mut u8);\n+                // Let's run some code.\n+                Box::from_raw(main as *mut Box<dyn FnOnce()>)();\n             }\n             ptr::null_mut()\n         }"}, {"sha": "121fe42011da5ac355e4e507d06455cea1e3280d", "filename": "src/libstd/sys/hermit/stack_overflow.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1ea8653d0116365e09dca7b22c7264d0fc877433/src%2Flibstd%2Fsys%2Fhermit%2Fstack_overflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ea8653d0116365e09dca7b22c7264d0fc877433/src%2Flibstd%2Fsys%2Fhermit%2Fstack_overflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fhermit%2Fstack_overflow.rs?ref=1ea8653d0116365e09dca7b22c7264d0fc877433", "patch": "@@ -1,11 +1,3 @@\n-pub struct Handler;\n-\n-impl Handler {\n-    pub unsafe fn new() -> Handler {\n-        Handler\n-    }\n-}\n-\n #[inline]\n pub unsafe fn init() {}\n "}, {"sha": "c7bea168f34d846c7b62b613aa11c84940c71ae7", "filename": "src/libstd/sys/hermit/thread.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/1ea8653d0116365e09dca7b22c7264d0fc877433/src%2Flibstd%2Fsys%2Fhermit%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ea8653d0116365e09dca7b22c7264d0fc877433/src%2Flibstd%2Fsys%2Fhermit%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fhermit%2Fthread.rs?ref=1ea8653d0116365e09dca7b22c7264d0fc877433", "patch": "@@ -8,8 +8,6 @@ use crate::sys::hermit::abi;\n use crate::time::Duration;\n use core::u32;\n \n-use crate::sys_common::thread::*;\n-\n pub type Tid = abi::Tid;\n \n /// Priority of a task\n@@ -49,26 +47,29 @@ impl Thread {\n         p: Box<dyn FnOnce()>,\n         core_id: isize,\n     ) -> io::Result<Thread> {\n-        let p = box p;\n+        let p = Box::into_raw(box p);\n         let mut tid: Tid = u32::MAX;\n         let ret = abi::spawn(\n             &mut tid as *mut Tid,\n             thread_start,\n-            &*p as *const _ as *const u8 as usize,\n+            p as usize,\n             Priority::into(NORMAL_PRIO),\n             core_id,\n         );\n \n-        return if ret == 0 {\n-            mem::forget(p); // ownership passed to pthread_create\n-            Ok(Thread { tid: tid })\n-        } else {\n+        return if ret != 0 {\n+            // The thread failed to start and as a result p was not consumed. Therefore, it is\n+            // safe to reconstruct the box so that it gets deallocated.\n+            drop(Box::from_raw(p));\n             Err(io::Error::new(io::ErrorKind::Other, \"Unable to create thread!\"))\n+        } else {\n+            Ok(Thread { tid: tid })\n         };\n \n         extern \"C\" fn thread_start(main: usize) {\n             unsafe {\n-                start_thread(main as *mut u8);\n+                // Finally, let's run some code.\n+                Box::from_raw(main as *mut Box<dyn FnOnce()>)();\n             }\n         }\n     }"}, {"sha": "b96652a8330e9f490465ccd6dc4837de74fedb42", "filename": "src/libstd/sys/sgx/stack_overflow.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1ea8653d0116365e09dca7b22c7264d0fc877433/src%2Flibstd%2Fsys%2Fsgx%2Fstack_overflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ea8653d0116365e09dca7b22c7264d0fc877433/src%2Flibstd%2Fsys%2Fsgx%2Fstack_overflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fstack_overflow.rs?ref=1ea8653d0116365e09dca7b22c7264d0fc877433", "patch": "@@ -1,11 +1,3 @@\n-pub struct Handler;\n-\n-impl Handler {\n-    pub unsafe fn new() -> Handler {\n-        Handler\n-    }\n-}\n-\n #[cfg_attr(test, allow(dead_code))]\n pub unsafe fn init() {}\n "}, {"sha": "aab5a92a7ad2a481b89d77f231a1276f1ff72218", "filename": "src/libstd/sys/unix/thread.rs", "status": "modified", "additions": 14, "deletions": 7, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/1ea8653d0116365e09dca7b22c7264d0fc877433/src%2Flibstd%2Fsys%2Funix%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ea8653d0116365e09dca7b22c7264d0fc877433/src%2Flibstd%2Fsys%2Funix%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fthread.rs?ref=1ea8653d0116365e09dca7b22c7264d0fc877433", "patch": "@@ -3,11 +3,9 @@ use crate::ffi::CStr;\n use crate::io;\n use crate::mem;\n use crate::ptr;\n-use crate::sys::os;\n+use crate::sys::{os, stack_overflow};\n use crate::time::Duration;\n \n-use crate::sys_common::thread::*;\n-\n #[cfg(not(target_os = \"l4re\"))]\n pub const DEFAULT_MIN_STACK_SIZE: usize = 2 * 1024 * 1024;\n #[cfg(target_os = \"l4re\")]\n@@ -43,7 +41,7 @@ unsafe fn pthread_attr_setstacksize(\n impl Thread {\n     // unsafe: see thread::Builder::spawn_unchecked for safety requirements\n     pub unsafe fn new(stack: usize, p: Box<dyn FnOnce()>) -> io::Result<Thread> {\n-        let p = box p;\n+        let p = Box::into_raw(box p);\n         let mut native: libc::pthread_t = mem::zeroed();\n         let mut attr: libc::pthread_attr_t = mem::zeroed();\n         assert_eq!(libc::pthread_attr_init(&mut attr), 0);\n@@ -65,19 +63,28 @@ impl Thread {\n             }\n         };\n \n-        let ret = libc::pthread_create(&mut native, &attr, thread_start, &*p as *const _ as *mut _);\n+        let ret = libc::pthread_create(&mut native, &attr, thread_start, p as *mut _);\n+        // Note: if the thread creation fails and this assert fails, then p will\n+        // be leaked. However, an alternative design could cause double-free\n+        // which is clearly worse.\n         assert_eq!(libc::pthread_attr_destroy(&mut attr), 0);\n \n         return if ret != 0 {\n+            // The thread failed to start and as a result p was not consumed. Therefore, it is\n+            // safe to reconstruct the box so that it gets deallocated.\n+            drop(Box::from_raw(p));\n             Err(io::Error::from_raw_os_error(ret))\n         } else {\n-            mem::forget(p); // ownership passed to pthread_create\n             Ok(Thread { id: native })\n         };\n \n         extern \"C\" fn thread_start(main: *mut libc::c_void) -> *mut libc::c_void {\n             unsafe {\n-                start_thread(main as *mut u8);\n+                // Next, set up our stack overflow handler which may get triggered if we run\n+                // out of stack.\n+                let _handler = stack_overflow::Handler::new();\n+                // Finally, let's run some code.\n+                Box::from_raw(main as *mut Box<dyn FnOnce()>)();\n             }\n             ptr::null_mut()\n         }"}, {"sha": "4d0196e4b4de5877faeab1110102b3233c7adc68", "filename": "src/libstd/sys/vxworks/thread.rs", "status": "modified", "additions": 14, "deletions": 7, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/1ea8653d0116365e09dca7b22c7264d0fc877433/src%2Flibstd%2Fsys%2Fvxworks%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ea8653d0116365e09dca7b22c7264d0fc877433/src%2Flibstd%2Fsys%2Fvxworks%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fvxworks%2Fthread.rs?ref=1ea8653d0116365e09dca7b22c7264d0fc877433", "patch": "@@ -3,11 +3,9 @@ use crate::ffi::CStr;\n use crate::io;\n use crate::mem;\n use crate::ptr;\n-use crate::sys::os;\n+use crate::sys::{os, stack_overflow};\n use crate::time::Duration;\n \n-use crate::sys_common::thread::*;\n-\n pub const DEFAULT_MIN_STACK_SIZE: usize = 0x40000; // 256K\n \n pub struct Thread {\n@@ -31,7 +29,7 @@ unsafe fn pthread_attr_setstacksize(\n impl Thread {\n     // unsafe: see thread::Builder::spawn_unchecked for safety requirements\n     pub unsafe fn new(stack: usize, p: Box<dyn FnOnce()>) -> io::Result<Thread> {\n-        let p = box p;\n+        let p = Box::into_raw(box p);\n         let mut native: libc::pthread_t = mem::zeroed();\n         let mut attr: libc::pthread_attr_t = mem::zeroed();\n         assert_eq!(libc::pthread_attr_init(&mut attr), 0);\n@@ -53,19 +51,28 @@ impl Thread {\n             }\n         };\n \n-        let ret = libc::pthread_create(&mut native, &attr, thread_start, &*p as *const _ as *mut _);\n+        let ret = libc::pthread_create(&mut native, &attr, thread_start, p as *mut _);\n+        // Note: if the thread creation fails and this assert fails, then p will\n+        // be leaked. However, an alternative design could cause double-free\n+        // which is clearly worse.\n         assert_eq!(libc::pthread_attr_destroy(&mut attr), 0);\n \n         return if ret != 0 {\n+            // The thread failed to start and as a result p was not consumed. Therefore, it is\n+            // safe to reconstruct the box so that it gets deallocated.\n+            drop(Box::from_raw(p));\n             Err(io::Error::from_raw_os_error(ret))\n         } else {\n-            mem::forget(p); // ownership passed to pthread_create\n             Ok(Thread { id: native })\n         };\n \n         extern \"C\" fn thread_start(main: *mut libc::c_void) -> *mut libc::c_void {\n             unsafe {\n-                start_thread(main as *mut u8);\n+                // Next, set up our stack overflow handler which may get triggered if we run\n+                // out of stack.\n+                let _handler = stack_overflow::Handler::new();\n+                // Finally, let's run some code.\n+                Box::from_raw(main as *mut Box<dyn FnOnce()>)();\n             }\n             ptr::null_mut()\n         }"}, {"sha": "32555394cd5a58fa3f5347bafd85af5f91350aab", "filename": "src/libstd/sys/wasm/stack_overflow.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1ea8653d0116365e09dca7b22c7264d0fc877433/src%2Flibstd%2Fsys%2Fwasm%2Fstack_overflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ea8653d0116365e09dca7b22c7264d0fc877433/src%2Flibstd%2Fsys%2Fwasm%2Fstack_overflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasm%2Fstack_overflow.rs?ref=1ea8653d0116365e09dca7b22c7264d0fc877433", "patch": "@@ -1,11 +1,3 @@\n-pub struct Handler;\n-\n-impl Handler {\n-    pub unsafe fn new() -> Handler {\n-        Handler\n-    }\n-}\n-\n pub unsafe fn init() {}\n \n pub unsafe fn cleanup() {}"}, {"sha": "38839ea5e90ed3a729d1830dbe19a5f8c3ebe830", "filename": "src/libstd/sys/windows/thread.rs", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/1ea8653d0116365e09dca7b22c7264d0fc877433/src%2Flibstd%2Fsys%2Fwindows%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ea8653d0116365e09dca7b22c7264d0fc877433/src%2Flibstd%2Fsys%2Fwindows%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fthread.rs?ref=1ea8653d0116365e09dca7b22c7264d0fc877433", "patch": "@@ -1,10 +1,9 @@\n use crate::ffi::CStr;\n use crate::io;\n-use crate::mem;\n use crate::ptr;\n use crate::sys::c;\n use crate::sys::handle::Handle;\n-use crate::sys_common::thread::*;\n+use crate::sys::stack_overflow;\n use crate::time::Duration;\n \n use libc::c_void;\n@@ -20,7 +19,7 @@ pub struct Thread {\n impl Thread {\n     // unsafe: see thread::Builder::spawn_unchecked for safety requirements\n     pub unsafe fn new(stack: usize, p: Box<dyn FnOnce()>) -> io::Result<Thread> {\n-        let p = box p;\n+        let p = Box::into_raw(box p);\n \n         // FIXME On UNIX, we guard against stack sizes that are too small but\n         // that's because pthreads enforces that stacks are at least\n@@ -34,21 +33,27 @@ impl Thread {\n             ptr::null_mut(),\n             stack_size,\n             thread_start,\n-            &*p as *const _ as *mut _,\n+            p as *mut _,\n             c::STACK_SIZE_PARAM_IS_A_RESERVATION,\n             ptr::null_mut(),\n         );\n \n         return if ret as usize == 0 {\n+            // The thread failed to start and as a result p was not consumed. Therefore, it is\n+            // safe to reconstruct the box so that it gets deallocated.\n+            drop(Box::from_raw(p));\n             Err(io::Error::last_os_error())\n         } else {\n-            mem::forget(p); // ownership passed to CreateThread\n             Ok(Thread { handle: Handle::new(ret) })\n         };\n \n         extern \"system\" fn thread_start(main: *mut c_void) -> c::DWORD {\n             unsafe {\n-                start_thread(main as *mut u8);\n+                // Next, set up our stack overflow handler which may get triggered if we run\n+                // out of stack.\n+                let _handler = stack_overflow::Handler::new();\n+                // Finally, let's run some code.\n+                Box::from_raw(main as *mut Box<dyn FnOnce()>)();\n             }\n             0\n         }"}, {"sha": "f3a8bef8f718f3079384c8039a25174526de1d39", "filename": "src/libstd/sys_common/thread.rs", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/1ea8653d0116365e09dca7b22c7264d0fc877433/src%2Flibstd%2Fsys_common%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ea8653d0116365e09dca7b22c7264d0fc877433/src%2Flibstd%2Fsys_common%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys_common%2Fthread.rs?ref=1ea8653d0116365e09dca7b22c7264d0fc877433", "patch": "@@ -1,18 +1,7 @@\n use crate::env;\n use crate::sync::atomic::{self, Ordering};\n-use crate::sys::stack_overflow;\n use crate::sys::thread as imp;\n \n-#[allow(dead_code)]\n-pub unsafe fn start_thread(main: *mut u8) {\n-    // Next, set up our stack overflow handler which may get triggered if we run\n-    // out of stack.\n-    let _handler = stack_overflow::Handler::new();\n-\n-    // Finally, let's run some code.\n-    Box::from_raw(main as *mut Box<dyn FnOnce()>)()\n-}\n-\n pub fn min_stack() -> usize {\n     static MIN: atomic::AtomicUsize = atomic::AtomicUsize::new(0);\n     match MIN.load(Ordering::SeqCst) {"}]}