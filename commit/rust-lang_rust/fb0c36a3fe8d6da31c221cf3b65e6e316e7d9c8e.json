{"sha": "fb0c36a3fe8d6da31c221cf3b65e6e316e7d9c8e", "node_id": "C_kwDOAAsO6NoAKGZiMGMzNmEzZmU4ZDZkYTMxYzIyMWNmM2I2NWU2ZTMxNmU3ZDljOGU", "commit": {"author": {"name": "Joshua Nelson", "email": "jnelson@cloudflare.com", "date": "2022-09-02T02:17:35Z"}, "committer": {"name": "Joshua Nelson", "email": "jnelson@cloudflare.com", "date": "2022-09-10T01:16:47Z"}, "message": "Make the `storage` query modifier less general\n\nIn practice, it was only ever used with `ArenaCacheSelector`. Change it to a single boolean\n`arena_cache` rather than allowing queries to specify an arbitrary type.", "tree": {"sha": "aa861d769db932b9ad7609b751bfdf6ec156e6b6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/aa861d769db932b9ad7609b751bfdf6ec156e6b6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fb0c36a3fe8d6da31c221cf3b65e6e316e7d9c8e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fb0c36a3fe8d6da31c221cf3b65e6e316e7d9c8e", "html_url": "https://github.com/rust-lang/rust/commit/fb0c36a3fe8d6da31c221cf3b65e6e316e7d9c8e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fb0c36a3fe8d6da31c221cf3b65e6e316e7d9c8e/comments", "author": {"login": "jyn514", "id": 23638587, "node_id": "MDQ6VXNlcjIzNjM4NTg3", "avatar_url": "https://avatars.githubusercontent.com/u/23638587?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jyn514", "html_url": "https://github.com/jyn514", "followers_url": "https://api.github.com/users/jyn514/followers", "following_url": "https://api.github.com/users/jyn514/following{/other_user}", "gists_url": "https://api.github.com/users/jyn514/gists{/gist_id}", "starred_url": "https://api.github.com/users/jyn514/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jyn514/subscriptions", "organizations_url": "https://api.github.com/users/jyn514/orgs", "repos_url": "https://api.github.com/users/jyn514/repos", "events_url": "https://api.github.com/users/jyn514/events{/privacy}", "received_events_url": "https://api.github.com/users/jyn514/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jyn514", "id": 23638587, "node_id": "MDQ6VXNlcjIzNjM4NTg3", "avatar_url": "https://avatars.githubusercontent.com/u/23638587?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jyn514", "html_url": "https://github.com/jyn514", "followers_url": "https://api.github.com/users/jyn514/followers", "following_url": "https://api.github.com/users/jyn514/following{/other_user}", "gists_url": "https://api.github.com/users/jyn514/gists{/gist_id}", "starred_url": "https://api.github.com/users/jyn514/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jyn514/subscriptions", "organizations_url": "https://api.github.com/users/jyn514/orgs", "repos_url": "https://api.github.com/users/jyn514/repos", "events_url": "https://api.github.com/users/jyn514/events{/privacy}", "received_events_url": "https://api.github.com/users/jyn514/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1d37ed661a6922e7a167609b8cd7eb31e972b19b", "url": "https://api.github.com/repos/rust-lang/rust/commits/1d37ed661a6922e7a167609b8cd7eb31e972b19b", "html_url": "https://github.com/rust-lang/rust/commit/1d37ed661a6922e7a167609b8cd7eb31e972b19b"}], "stats": {"total": 122, "additions": 59, "deletions": 63}, "files": [{"sha": "a99cba817d96e9a747569184d3cd7594f5e39571", "filename": "compiler/rustc_macros/src/query.rs", "status": "modified", "additions": 8, "deletions": 12, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/fb0c36a3fe8d6da31c221cf3b65e6e316e7d9c8e/compiler%2Frustc_macros%2Fsrc%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb0c36a3fe8d6da31c221cf3b65e6e316e7d9c8e/compiler%2Frustc_macros%2Fsrc%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fquery.rs?ref=fb0c36a3fe8d6da31c221cf3b65e6e316e7d9c8e", "patch": "@@ -86,7 +86,7 @@ struct QueryModifiers {\n     desc: (Option<Ident>, Punctuated<Expr, Token![,]>),\n \n     /// Use this type for the in-memory cache.\n-    storage: Option<Type>,\n+    arena_cache: Option<Ident>,\n \n     /// Cache the query to disk if the `Block` returns true.\n     cache: Option<(Option<Pat>, Block)>,\n@@ -121,7 +121,7 @@ struct QueryModifiers {\n \n fn parse_query_modifiers(input: ParseStream<'_>) -> Result<QueryModifiers> {\n     let mut load_cached = None;\n-    let mut storage = None;\n+    let mut arena_cache = None;\n     let mut cache = None;\n     let mut desc = None;\n     let mut fatal_cycle = None;\n@@ -183,11 +183,8 @@ fn parse_query_modifiers(input: ParseStream<'_>) -> Result<QueryModifiers> {\n             let id = args.parse()?;\n             let block = input.parse()?;\n             try_insert!(load_cached = (tcx, id, block));\n-        } else if modifier == \"storage\" {\n-            let args;\n-            parenthesized!(args in input);\n-            let ty = args.parse()?;\n-            try_insert!(storage = ty);\n+        } else if modifier == \"arena_cache\" {\n+            try_insert!(arena_cache = modifier);\n         } else if modifier == \"fatal_cycle\" {\n             try_insert!(fatal_cycle = modifier);\n         } else if modifier == \"cycle_delay_bug\" {\n@@ -213,7 +210,7 @@ fn parse_query_modifiers(input: ParseStream<'_>) -> Result<QueryModifiers> {\n     };\n     Ok(QueryModifiers {\n         load_cached,\n-        storage,\n+        arena_cache,\n         cache,\n         desc,\n         fatal_cycle,\n@@ -351,10 +348,9 @@ pub fn rustc_queries(input: TokenStream) -> TokenStream {\n         if let Some(fatal_cycle) = &modifiers.fatal_cycle {\n             attributes.push(quote! { (#fatal_cycle) });\n         };\n-        // Pass on the storage modifier\n-        if let Some(ref ty) = modifiers.storage {\n-            let span = ty.span();\n-            attributes.push(quote_spanned! {span=> (storage #ty) });\n+        // Pass on the arena modifier\n+        if let Some(ref arena_cache) = modifiers.arena_cache {\n+            attributes.push(quote! {span=> (#arena_cache) });\n         };\n         // Pass on the cycle_delay_bug modifier\n         if let Some(cycle_delay_bug) = &modifiers.cycle_delay_bug {"}, {"sha": "8e62b05d5f69f5cfa008ffc847080f32b572a339", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 49, "deletions": 49, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/fb0c36a3fe8d6da31c221cf3b65e6e316e7d9c8e/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb0c36a3fe8d6da31c221cf3b65e6e316e7d9c8e/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=fb0c36a3fe8d6da31c221cf3b65e6e316e7d9c8e", "patch": "@@ -47,14 +47,14 @@ rustc_queries! {\n     /// To avoid this fate, do not call `tcx.hir().krate()`; instead,\n     /// prefer wrappers like `tcx.visit_all_items_in_krate()`.\n     query hir_crate(key: ()) -> Crate<'tcx> {\n-        storage(ArenaCacheSelector<'tcx>)\n+        arena_cache\n         eval_always\n         desc { \"get the crate HIR\" }\n     }\n \n     /// All items in the crate.\n     query hir_crate_items(_: ()) -> rustc_middle::hir::ModuleItems {\n-        storage(ArenaCacheSelector<'tcx>)\n+        arena_cache\n         eval_always\n         desc { \"get HIR crate items\" }\n     }\n@@ -64,7 +64,7 @@ rustc_queries! {\n     /// This can be conveniently accessed by `tcx.hir().visit_item_likes_in_module`.\n     /// Avoid calling this query directly.\n     query hir_module_items(key: LocalDefId) -> rustc_middle::hir::ModuleItems {\n-        storage(ArenaCacheSelector<'tcx>)\n+        arena_cache\n         desc { |tcx| \"HIR module items in `{}`\", tcx.def_path_str(key.to_def_id()) }\n         cache_on_disk_if { true }\n     }\n@@ -196,7 +196,7 @@ rustc_queries! {\n     /// associated generics.\n     query generics_of(key: DefId) -> ty::Generics {\n         desc { |tcx| \"computing generics of `{}`\", tcx.def_path_str(key) }\n-        storage(ArenaCacheSelector<'tcx>)\n+        arena_cache\n         cache_on_disk_if { key.is_local() }\n         separate_provide_extern\n     }\n@@ -268,13 +268,13 @@ rustc_queries! {\n     }\n \n     query native_libraries(_: CrateNum) -> Vec<NativeLib> {\n-        storage(ArenaCacheSelector<'tcx>)\n+        arena_cache\n         desc { \"looking up the native libraries of a linked crate\" }\n         separate_provide_extern\n     }\n \n     query lint_levels(_: ()) -> LintLevelMap {\n-        storage(ArenaCacheSelector<'tcx>)\n+        arena_cache\n         eval_always\n         desc { \"computing the lint levels for items in this crate\" }\n     }\n@@ -307,15 +307,15 @@ rustc_queries! {\n     /// Create a THIR tree for debugging.\n     query thir_tree(key: ty::WithOptConstParam<LocalDefId>) -> String {\n         no_hash\n-        storage(ArenaCacheSelector<'tcx>)\n+        arena_cache\n         desc { |tcx| \"constructing THIR tree for `{}`\", tcx.def_path_str(key.did.to_def_id()) }\n     }\n \n     /// Set of all the `DefId`s in this crate that have MIR associated with\n     /// them. This includes all the body owners, but also things like struct\n     /// constructors.\n     query mir_keys(_: ()) -> rustc_data_structures::fx::FxIndexSet<LocalDefId> {\n-        storage(ArenaCacheSelector<'tcx>)\n+        arena_cache\n         desc { \"getting a list of all mir_keys\" }\n     }\n \n@@ -422,7 +422,7 @@ rustc_queries! {\n     query symbols_for_closure_captures(\n         key: (LocalDefId, LocalDefId)\n     ) -> Vec<rustc_span::Symbol> {\n-        storage(ArenaCacheSelector<'tcx>)\n+        arena_cache\n         desc {\n             |tcx| \"symbols for captures of closure `{}` in `{}`\",\n             tcx.def_path_str(key.1.to_def_id()),\n@@ -442,7 +442,7 @@ rustc_queries! {\n     /// MIR pass (assuming the -Cinstrument-coverage option is enabled).\n     query coverageinfo(key: ty::InstanceDef<'tcx>) -> mir::CoverageInfo {\n         desc { |tcx| \"retrieving coverage info from MIR for `{}`\", tcx.def_path_str(key.def_id()) }\n-        storage(ArenaCacheSelector<'tcx>)\n+        arena_cache\n     }\n \n     /// Returns the `CodeRegions` for a function that has instrumented coverage, in case the\n@@ -452,7 +452,7 @@ rustc_queries! {\n             |tcx| \"retrieving the covered `CodeRegion`s, if instrumented, for `{}`\",\n             tcx.def_path_str(key)\n         }\n-        storage(ArenaCacheSelector<'tcx>)\n+        arena_cache\n         cache_on_disk_if { key.is_local() }\n     }\n \n@@ -490,7 +490,7 @@ rustc_queries! {\n     }\n \n     query wasm_import_module_map(_: CrateNum) -> FxHashMap<DefId, String> {\n-        storage(ArenaCacheSelector<'tcx>)\n+        arena_cache\n         desc { \"wasm import module map\" }\n     }\n \n@@ -566,7 +566,7 @@ rustc_queries! {\n \n     query trait_def(key: DefId) -> ty::TraitDef {\n         desc { |tcx| \"computing trait definition for `{}`\", tcx.def_path_str(key) }\n-        storage(ArenaCacheSelector<'tcx>)\n+        arena_cache\n         cache_on_disk_if { key.is_local() }\n         separate_provide_extern\n     }\n@@ -644,7 +644,7 @@ rustc_queries! {\n \n     /// Gets a map with the variance of every item; use `item_variance` instead.\n     query crate_variances(_: ()) -> ty::CrateVariancesMap<'tcx> {\n-        storage(ArenaCacheSelector<'tcx>)\n+        arena_cache\n         desc { \"computing the variances for items in this crate\" }\n     }\n \n@@ -657,7 +657,7 @@ rustc_queries! {\n \n     /// Maps from thee `DefId` of a type to its (inferred) outlives.\n     query inferred_outlives_crate(_: ()) -> ty::CratePredicatesMap<'tcx> {\n-        storage(ArenaCacheSelector<'tcx>)\n+        arena_cache\n         desc { \"computing the inferred outlives predicates for items in this crate\" }\n     }\n \n@@ -671,14 +671,14 @@ rustc_queries! {\n     /// Maps from a trait item to the trait item \"descriptor\".\n     query associated_item(key: DefId) -> ty::AssocItem {\n         desc { |tcx| \"computing associated item data for `{}`\", tcx.def_path_str(key) }\n-        storage(ArenaCacheSelector<'tcx>)\n+        arena_cache\n         cache_on_disk_if { key.is_local() }\n         separate_provide_extern\n     }\n \n     /// Collects the associated items defined on a trait or impl.\n     query associated_items(key: DefId) -> ty::AssocItems<'tcx> {\n-        storage(ArenaCacheSelector<'tcx>)\n+        arena_cache\n         desc { |tcx| \"collecting associated items of {}\", tcx.def_path_str(key) }\n     }\n \n@@ -704,7 +704,7 @@ rustc_queries! {\n     /// The map returned for `tcx.impl_item_implementor_ids(impl_id)` would be\n     ///`{ trait_f: impl_f, trait_g: impl_g }`\n     query impl_item_implementor_ids(impl_id: DefId) -> FxHashMap<DefId, DefId> {\n-        storage(ArenaCacheSelector<'tcx>)\n+        arena_cache\n         desc { |tcx| \"comparing impl items against trait for {}\", tcx.def_path_str(impl_id) }\n     }\n \n@@ -837,7 +837,7 @@ rustc_queries! {\n         FxHashSet<LocalDefId>,\n         FxHashMap<LocalDefId, Vec<(DefId, DefId)>>\n     ) {\n-        storage(ArenaCacheSelector<'tcx>)\n+        arena_cache\n         desc { \"find live symbols in crate\" }\n     }\n \n@@ -921,7 +921,7 @@ rustc_queries! {\n     /// Gets a complete map from all types to their inherent impls.\n     /// Not meant to be used directly outside of coherence.\n     query crate_inherent_impls(k: ()) -> CrateInherentImpls {\n-        storage(ArenaCacheSelector<'tcx>)\n+        arena_cache\n         desc { \"all inherent impls defined in crate\" }\n     }\n \n@@ -1054,7 +1054,7 @@ rustc_queries! {\n     }\n \n     query reachable_set(_: ()) -> FxHashSet<LocalDefId> {\n-        storage(ArenaCacheSelector<'tcx>)\n+        arena_cache\n         desc { \"reachability\" }\n     }\n \n@@ -1066,7 +1066,7 @@ rustc_queries! {\n \n     /// Generates a MIR body for the shim.\n     query mir_shims(key: ty::InstanceDef<'tcx>) -> mir::Body<'tcx> {\n-        storage(ArenaCacheSelector<'tcx>)\n+        arena_cache\n         desc { |tcx| \"generating MIR shim for `{}`\", tcx.def_path_str(key.def_id()) }\n     }\n \n@@ -1140,7 +1140,7 @@ rustc_queries! {\n \n     query codegen_fn_attrs(def_id: DefId) -> CodegenFnAttrs {\n         desc { |tcx| \"computing codegen attributes of `{}`\", tcx.def_path_str(def_id) }\n-        storage(ArenaCacheSelector<'tcx>)\n+        arena_cache\n         cache_on_disk_if { def_id.is_local() }\n         separate_provide_extern\n     }\n@@ -1157,7 +1157,7 @@ rustc_queries! {\n     /// Gets the rendered value of the specified constant or associated constant.\n     /// Used by rustdoc.\n     query rendered_const(def_id: DefId) -> String {\n-        storage(ArenaCacheSelector<'tcx>)\n+        arena_cache\n         desc { |tcx| \"rendering constant initializer of `{}`\", tcx.def_path_str(def_id) }\n         cache_on_disk_if { def_id.is_local() }\n         separate_provide_extern\n@@ -1219,12 +1219,12 @@ rustc_queries! {\n \n     /// Given a trait `trait_id`, return all known `impl` blocks.\n     query trait_impls_of(trait_id: DefId) -> ty::trait_def::TraitImpls {\n-        storage(ArenaCacheSelector<'tcx>)\n+        arena_cache\n         desc { |tcx| \"trait impls of `{}`\", tcx.def_path_str(trait_id) }\n     }\n \n     query specialization_graph_of(trait_id: DefId) -> specialization_graph::Graph {\n-        storage(ArenaCacheSelector<'tcx>)\n+        arena_cache\n         desc { |tcx| \"building specialization graph of trait `{}`\", tcx.def_path_str(trait_id) }\n         cache_on_disk_if { true }\n     }\n@@ -1351,7 +1351,7 @@ rustc_queries! {\n     }\n \n     query dependency_formats(_: ()) -> Lrc<crate::middle::dependency_format::Dependencies> {\n-        storage(ArenaCacheSelector<'tcx>)\n+        arena_cache\n         desc { \"get the linkage format of all dependencies\" }\n     }\n \n@@ -1444,7 +1444,7 @@ rustc_queries! {\n     // like the compiler-generated `main` function and so on.\n     query reachable_non_generics(_: CrateNum)\n         -> DefIdMap<SymbolExportInfo> {\n-        storage(ArenaCacheSelector<'tcx>)\n+        arena_cache\n         desc { \"looking up the exported symbols of a crate\" }\n         separate_provide_extern\n     }\n@@ -1467,7 +1467,7 @@ rustc_queries! {\n     /// `upstream_monomorphizations_for`, `upstream_drop_glue_for`, or, even\n     /// better, `Instance::upstream_monomorphization()`.\n     query upstream_monomorphizations(_: ()) -> DefIdMap<FxHashMap<SubstsRef<'tcx>, CrateNum>> {\n-        storage(ArenaCacheSelector<'tcx>)\n+        arena_cache\n         desc { \"collecting available upstream monomorphizations\" }\n     }\n \n@@ -1481,7 +1481,7 @@ rustc_queries! {\n     query upstream_monomorphizations_for(def_id: DefId)\n         -> Option<&'tcx FxHashMap<SubstsRef<'tcx>, CrateNum>>\n     {\n-        storage(ArenaCacheSelector<'tcx>)\n+        arena_cache\n         desc { |tcx|\n             \"collecting available upstream monomorphizations for `{}`\",\n             tcx.def_path_str(def_id),\n@@ -1509,7 +1509,7 @@ rustc_queries! {\n     }\n \n     query foreign_modules(_: CrateNum) -> FxHashMap<DefId, ForeignModule> {\n-        storage(ArenaCacheSelector<'tcx>)\n+        arena_cache\n         desc { \"looking up the foreign modules of a linked crate\" }\n         separate_provide_extern\n     }\n@@ -1535,13 +1535,13 @@ rustc_queries! {\n         separate_provide_extern\n     }\n     query extra_filename(_: CrateNum) -> String {\n-        storage(ArenaCacheSelector<'tcx>)\n+        arena_cache\n         eval_always\n         desc { \"looking up the extra filename for a crate\" }\n         separate_provide_extern\n     }\n     query crate_extern_paths(_: CrateNum) -> Vec<PathBuf> {\n-        storage(ArenaCacheSelector<'tcx>)\n+        arena_cache\n         eval_always\n         desc { \"looking up the paths for extern crates\" }\n         separate_provide_extern\n@@ -1583,14 +1583,14 @@ rustc_queries! {\n     /// the same lifetimes and is responsible for diagnostics.\n     /// See `rustc_resolve::late::lifetimes for details.\n     query resolve_lifetimes_trait_definition(_: LocalDefId) -> ResolveLifetimes {\n-        storage(ArenaCacheSelector<'tcx>)\n+        arena_cache\n         desc { \"resolving lifetimes for a trait definition\" }\n     }\n     /// Does lifetime resolution on items. Importantly, we can't resolve\n     /// lifetimes directly on things like trait methods, because of trait params.\n     /// See `rustc_resolve::late::lifetimes for details.\n     query resolve_lifetimes(_: LocalDefId) -> ResolveLifetimes {\n-        storage(ArenaCacheSelector<'tcx>)\n+        arena_cache\n         desc { \"resolving lifetimes\" }\n     }\n     query named_region_map(_: LocalDefId) ->\n@@ -1650,15 +1650,15 @@ rustc_queries! {\n     }\n \n     query lib_features(_: ()) -> LibFeatures {\n-        storage(ArenaCacheSelector<'tcx>)\n+        arena_cache\n         desc { \"calculating the lib features map\" }\n     }\n     query defined_lib_features(_: CrateNum) -> &'tcx [(Symbol, Option<Symbol>)] {\n         desc { \"calculating the lib features defined in a crate\" }\n         separate_provide_extern\n     }\n     query stability_implications(_: CrateNum) -> FxHashMap<Symbol, Symbol> {\n-        storage(ArenaCacheSelector<'tcx>)\n+        arena_cache\n         desc { \"calculating the implications between `#[unstable]` features defined in a crate\" }\n         separate_provide_extern\n     }\n@@ -1669,14 +1669,14 @@ rustc_queries! {\n     }\n     /// Returns the lang items defined in another crate by loading it from metadata.\n     query get_lang_items(_: ()) -> LanguageItems {\n-        storage(ArenaCacheSelector<'tcx>)\n+        arena_cache\n         eval_always\n         desc { \"calculating the lang items map\" }\n     }\n \n     /// Returns all diagnostic items defined in all crates.\n     query all_diagnostic_items(_: ()) -> rustc_hir::diagnostic_items::DiagnosticItems {\n-        storage(ArenaCacheSelector<'tcx>)\n+        arena_cache\n         eval_always\n         desc { \"calculating the diagnostic items map\" }\n     }\n@@ -1689,7 +1689,7 @@ rustc_queries! {\n \n     /// Returns the diagnostic items defined in a crate.\n     query diagnostic_items(_: CrateNum) -> rustc_hir::diagnostic_items::DiagnosticItems {\n-        storage(ArenaCacheSelector<'tcx>)\n+        arena_cache\n         desc { \"calculating the diagnostic items map in a crate\" }\n         separate_provide_extern\n     }\n@@ -1699,11 +1699,11 @@ rustc_queries! {\n         separate_provide_extern\n     }\n     query visible_parent_map(_: ()) -> DefIdMap<DefId> {\n-        storage(ArenaCacheSelector<'tcx>)\n+        arena_cache\n         desc { \"calculating the visible parent map\" }\n     }\n     query trimmed_def_paths(_: ()) -> FxHashMap<DefId, Symbol> {\n-        storage(ArenaCacheSelector<'tcx>)\n+        arena_cache\n         desc { \"calculating trimmed def paths\" }\n     }\n     query missing_extern_crate_item(_: CrateNum) -> bool {\n@@ -1712,14 +1712,14 @@ rustc_queries! {\n         separate_provide_extern\n     }\n     query used_crate_source(_: CrateNum) -> Lrc<CrateSource> {\n-        storage(ArenaCacheSelector<'tcx>)\n+        arena_cache\n         eval_always\n         desc { \"looking at the source for a crate\" }\n         separate_provide_extern\n     }\n     /// Returns the debugger visualizers defined for this crate.\n     query debugger_visualizers(_: CrateNum) -> Vec<rustc_span::DebuggerVisualizerFile> {\n-        storage(ArenaCacheSelector<'tcx>)\n+        arena_cache\n         desc { \"looking up the debugger visualizers for this crate\" }\n         separate_provide_extern\n     }\n@@ -1753,7 +1753,7 @@ rustc_queries! {\n     }\n \n     query stability_index(_: ()) -> stability::Index {\n-        storage(ArenaCacheSelector<'tcx>)\n+        arena_cache\n         eval_always\n         desc { \"calculating the stability index for the local crate\" }\n     }\n@@ -1994,7 +1994,7 @@ rustc_queries! {\n     }\n \n     query supported_target_features(_: CrateNum) -> FxHashMap<String, Option<Symbol>> {\n-        storage(ArenaCacheSelector<'tcx>)\n+        arena_cache\n         eval_always\n         desc { \"looking up supported target features\" }\n     }\n@@ -2064,7 +2064,7 @@ rustc_queries! {\n     /// all of the cases that the normal `ty::Ty`-based wfcheck does. This is fine,\n     /// because the `ty::Ty`-based wfcheck is always run.\n     query diagnostic_hir_wf_check(key: (ty::Predicate<'tcx>, traits::WellFormedLoc)) -> Option<traits::ObligationCause<'tcx>> {\n-        storage(ArenaCacheSelector<'tcx>)\n+        arena_cache\n         eval_always\n         no_hash\n         desc { \"performing HIR wf-checking for predicate {:?} at item {:?}\", key.0, key.1 }\n@@ -2074,13 +2074,13 @@ rustc_queries! {\n     /// The list of backend features computed from CLI flags (`-Ctarget-cpu`, `-Ctarget-feature`,\n     /// `--target` and similar).\n     query global_backend_features(_: ()) -> Vec<String> {\n-        storage(ArenaCacheSelector<'tcx>)\n+        arena_cache\n         eval_always\n         desc { \"computing the backend features for CLI flags\" }\n     }\n \n     query generator_diagnostic_data(key: DefId) -> Option<GeneratorDiagnosticData<'tcx>> {\n-        storage(ArenaCacheSelector<'tcx>)\n+        arena_cache\n         desc { |tcx| \"looking up generator diagnostic data of `{}`\", tcx.def_path_str(key) }\n         separate_provide_extern\n     }"}, {"sha": "a300a8df23d286117fe067cadee360696d3af92c", "filename": "compiler/rustc_middle/src/ty/query.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fb0c36a3fe8d6da31c221cf3b65e6e316e7d9c8e/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb0c36a3fe8d6da31c221cf3b65e6e316e7d9c8e/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery.rs?ref=fb0c36a3fe8d6da31c221cf3b65e6e316e7d9c8e", "patch": "@@ -121,8 +121,8 @@ macro_rules! query_storage {\n     ([][$K:ty, $V:ty]) => {\n         <DefaultCacheSelector as CacheSelector<$K, $V>>::Cache\n     };\n-    ([(storage $ty:ty) $($rest:tt)*][$K:ty, $V:ty]) => {\n-        <$ty as CacheSelector<$K, $V>>::Cache\n+    ([(arena_cache) $($rest:tt)*][$K:ty, $V:ty]) => {\n+        <ArenaCacheSelector<'tcx> as CacheSelector<$K, $V>>::Cache\n     };\n     ([$other:tt $($modifiers:tt)*][$($args:tt)*]) => {\n         query_storage!([$($modifiers)*][$($args)*])"}]}