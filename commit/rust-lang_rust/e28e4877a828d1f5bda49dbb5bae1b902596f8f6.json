{"sha": "e28e4877a828d1f5bda49dbb5bae1b902596f8f6", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUyOGU0ODc3YTgyOGQxZjViZGE0OWRiYjViYWUxYjkwMjU5NmY4ZjY=", "commit": {"author": {"name": "ljedrz", "email": "ljedrz@gmail.com", "date": "2018-07-10T19:06:26Z"}, "committer": {"name": "ljedrz", "email": "ljedrz@gmail.com", "date": "2018-07-10T19:06:26Z"}, "message": "Deny bare trait objects in in src/libsyntax", "tree": {"sha": "a0b6146b70b44b7b46d563c3fc1634e84642f78b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a0b6146b70b44b7b46d563c3fc1634e84642f78b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e28e4877a828d1f5bda49dbb5bae1b902596f8f6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e28e4877a828d1f5bda49dbb5bae1b902596f8f6", "html_url": "https://github.com/rust-lang/rust/commit/e28e4877a828d1f5bda49dbb5bae1b902596f8f6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e28e4877a828d1f5bda49dbb5bae1b902596f8f6/comments", "author": {"login": "ljedrz", "id": 3750347, "node_id": "MDQ6VXNlcjM3NTAzNDc=", "avatar_url": "https://avatars.githubusercontent.com/u/3750347?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ljedrz", "html_url": "https://github.com/ljedrz", "followers_url": "https://api.github.com/users/ljedrz/followers", "following_url": "https://api.github.com/users/ljedrz/following{/other_user}", "gists_url": "https://api.github.com/users/ljedrz/gists{/gist_id}", "starred_url": "https://api.github.com/users/ljedrz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ljedrz/subscriptions", "organizations_url": "https://api.github.com/users/ljedrz/orgs", "repos_url": "https://api.github.com/users/ljedrz/repos", "events_url": "https://api.github.com/users/ljedrz/events{/privacy}", "received_events_url": "https://api.github.com/users/ljedrz/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ljedrz", "id": 3750347, "node_id": "MDQ6VXNlcjM3NTAzNDc=", "avatar_url": "https://avatars.githubusercontent.com/u/3750347?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ljedrz", "html_url": "https://github.com/ljedrz", "followers_url": "https://api.github.com/users/ljedrz/followers", "following_url": "https://api.github.com/users/ljedrz/following{/other_user}", "gists_url": "https://api.github.com/users/ljedrz/gists{/gist_id}", "starred_url": "https://api.github.com/users/ljedrz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ljedrz/subscriptions", "organizations_url": "https://api.github.com/users/ljedrz/orgs", "repos_url": "https://api.github.com/users/ljedrz/repos", "events_url": "https://api.github.com/users/ljedrz/events{/privacy}", "received_events_url": "https://api.github.com/users/ljedrz/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "77117e383676176116851d7d3ec04b5e0cf0c456", "url": "https://api.github.com/repos/rust-lang/rust/commits/77117e383676176116851d7d3ec04b5e0cf0c456", "html_url": "https://github.com/rust-lang/rust/commit/77117e383676176116851d7d3ec04b5e0cf0c456"}], "stats": {"total": 148, "additions": 75, "deletions": 73}, "files": [{"sha": "2e0eb5e9c0469c14a9fe3ddff329691e1dd34355", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e28e4877a828d1f5bda49dbb5bae1b902596f8f6/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e28e4877a828d1f5bda49dbb5bae1b902596f8f6/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=e28e4877a828d1f5bda49dbb5bae1b902596f8f6", "patch": "@@ -131,7 +131,7 @@ pub(super) struct CodeMapFiles {\n \n pub struct CodeMap {\n     pub(super) files: Lock<CodeMapFiles>,\n-    file_loader: Box<FileLoader + Sync + Send>,\n+    file_loader: Box<dyn FileLoader + Sync + Send>,\n     // This is used to apply the file path remapping as specified via\n     // --remap-path-prefix to all FileMaps allocated within this CodeMap.\n     path_mapping: FilePathMapping,\n@@ -162,7 +162,7 @@ impl CodeMap {\n \n     }\n \n-    pub fn with_file_loader(file_loader: Box<FileLoader + Sync + Send>,\n+    pub fn with_file_loader(file_loader: Box<dyn FileLoader + Sync + Send>,\n                             path_mapping: FilePathMapping)\n                             -> CodeMap {\n         CodeMap {"}, {"sha": "61b0579a3e76bc137722c31eb1072242fbc9c325", "filename": "src/libsyntax/diagnostics/metadata.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e28e4877a828d1f5bda49dbb5bae1b902596f8f6/src%2Flibsyntax%2Fdiagnostics%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e28e4877a828d1f5bda49dbb5bae1b902596f8f6/src%2Flibsyntax%2Fdiagnostics%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostics%2Fmetadata.rs?ref=e28e4877a828d1f5bda49dbb5bae1b902596f8f6", "patch": "@@ -73,7 +73,7 @@ fn get_metadata_path(directory: PathBuf, name: &str) -> PathBuf {\n /// For our current purposes the prefix is the target architecture and the name is a crate name.\n /// If an error occurs steps will be taken to ensure that no file is created.\n pub fn output_metadata(ecx: &ExtCtxt, prefix: &str, name: &str, err_map: &ErrorMap)\n-    -> Result<(), Box<Error>>\n+    -> Result<(), Box<dyn Error>>\n {\n     // Create the directory to place the file in.\n     let metadata_dir = get_metadata_dir(prefix);"}, {"sha": "72ce2740190d421ba4d2c1c25adb43b1604ed2d7", "filename": "src/libsyntax/diagnostics/plugin.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e28e4877a828d1f5bda49dbb5bae1b902596f8f6/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e28e4877a828d1f5bda49dbb5bae1b902596f8f6/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs?ref=e28e4877a828d1f5bda49dbb5bae1b902596f8f6", "patch": "@@ -42,7 +42,7 @@ pub type ErrorMap = BTreeMap<Name, ErrorInfo>;\n pub fn expand_diagnostic_used<'cx>(ecx: &'cx mut ExtCtxt,\n                                    span: Span,\n                                    token_tree: &[TokenTree])\n-                                   -> Box<MacResult+'cx> {\n+                                   -> Box<dyn MacResult+'cx> {\n     let code = match (token_tree.len(), token_tree.get(0)) {\n         (1, Some(&TokenTree::Token(_, token::Ident(code, _)))) => code,\n         _ => unreachable!()\n@@ -75,7 +75,7 @@ pub fn expand_diagnostic_used<'cx>(ecx: &'cx mut ExtCtxt,\n pub fn expand_register_diagnostic<'cx>(ecx: &'cx mut ExtCtxt,\n                                        span: Span,\n                                        token_tree: &[TokenTree])\n-                                       -> Box<MacResult+'cx> {\n+                                       -> Box<dyn MacResult+'cx> {\n     let (code, description) = match (\n         token_tree.len(),\n         token_tree.get(0),\n@@ -145,7 +145,7 @@ pub fn expand_register_diagnostic<'cx>(ecx: &'cx mut ExtCtxt,\n pub fn expand_build_diagnostic_array<'cx>(ecx: &'cx mut ExtCtxt,\n                                           span: Span,\n                                           token_tree: &[TokenTree])\n-                                          -> Box<MacResult+'cx> {\n+                                          -> Box<dyn MacResult+'cx> {\n     assert_eq!(token_tree.len(), 3);\n     let (crate_name, name) = match (&token_tree[0], &token_tree[2]) {\n         ("}, {"sha": "331ab2dc08dd10a3b6c4945b741e8694f707d4e2", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/e28e4877a828d1f5bda49dbb5bae1b902596f8f6/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e28e4877a828d1f5bda49dbb5bae1b902596f8f6/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=e28e4877a828d1f5bda49dbb5bae1b902596f8f6", "patch": "@@ -153,18 +153,18 @@ pub trait MultiItemDecorator {\n               sp: Span,\n               meta_item: &ast::MetaItem,\n               item: &Annotatable,\n-              push: &mut FnMut(Annotatable));\n+              push: &mut dyn FnMut(Annotatable));\n }\n \n impl<F> MultiItemDecorator for F\n-    where F : Fn(&mut ExtCtxt, Span, &ast::MetaItem, &Annotatable, &mut FnMut(Annotatable))\n+    where F : Fn(&mut ExtCtxt, Span, &ast::MetaItem, &Annotatable, &mut dyn FnMut(Annotatable))\n {\n     fn expand(&self,\n               ecx: &mut ExtCtxt,\n               sp: Span,\n               meta_item: &ast::MetaItem,\n               item: &Annotatable,\n-              push: &mut FnMut(Annotatable)) {\n+              push: &mut dyn FnMut(Annotatable)) {\n         (*self)(ecx, sp, meta_item, item, push)\n     }\n }\n@@ -247,18 +247,18 @@ impl<F> AttrProcMacro for F\n /// Represents a thing that maps token trees to Macro Results\n pub trait TTMacroExpander {\n     fn expand<'cx>(&self, ecx: &'cx mut ExtCtxt, span: Span, input: TokenStream)\n-                   -> Box<MacResult+'cx>;\n+                   -> Box<dyn MacResult+'cx>;\n }\n \n pub type MacroExpanderFn =\n     for<'cx> fn(&'cx mut ExtCtxt, Span, &[tokenstream::TokenTree])\n-                -> Box<MacResult+'cx>;\n+                -> Box<dyn MacResult+'cx>;\n \n impl<F> TTMacroExpander for F\n-    where F: for<'cx> Fn(&'cx mut ExtCtxt, Span, &[tokenstream::TokenTree]) -> Box<MacResult+'cx>\n+    where F: for<'cx> Fn(&'cx mut ExtCtxt, Span, &[tokenstream::TokenTree]) -> Box<dyn MacResult+'cx>\n {\n     fn expand<'cx>(&self, ecx: &'cx mut ExtCtxt, span: Span, input: TokenStream)\n-                   -> Box<MacResult+'cx> {\n+                   -> Box<dyn MacResult+'cx> {\n         struct AvoidInterpolatedIdents;\n \n         impl Folder for AvoidInterpolatedIdents {\n@@ -289,23 +289,23 @@ pub trait IdentMacroExpander {\n                    sp: Span,\n                    ident: ast::Ident,\n                    token_tree: Vec<tokenstream::TokenTree>)\n-                   -> Box<MacResult+'cx>;\n+                   -> Box<dyn MacResult+'cx>;\n }\n \n pub type IdentMacroExpanderFn =\n     for<'cx> fn(&'cx mut ExtCtxt, Span, ast::Ident, Vec<tokenstream::TokenTree>)\n-                -> Box<MacResult+'cx>;\n+                -> Box<dyn MacResult+'cx>;\n \n impl<F> IdentMacroExpander for F\n     where F : for<'cx> Fn(&'cx mut ExtCtxt, Span, ast::Ident,\n-                          Vec<tokenstream::TokenTree>) -> Box<MacResult+'cx>\n+                          Vec<tokenstream::TokenTree>) -> Box<dyn MacResult+'cx>\n {\n     fn expand<'cx>(&self,\n                    cx: &'cx mut ExtCtxt,\n                    sp: Span,\n                    ident: ast::Ident,\n                    token_tree: Vec<tokenstream::TokenTree>)\n-                   -> Box<MacResult+'cx>\n+                   -> Box<dyn MacResult+'cx>\n     {\n         (*self)(cx, sp, ident, token_tree)\n     }\n@@ -378,7 +378,7 @@ macro_rules! make_MacEager {\n \n         impl MacEager {\n             $(\n-                pub fn $fld(v: $t) -> Box<MacResult> {\n+                pub fn $fld(v: $t) -> Box<dyn MacResult> {\n                     Box::new(MacEager {\n                         $fld: Some(v),\n                         ..Default::default()\n@@ -462,7 +462,7 @@ impl DummyResult {\n     ///\n     /// Use this as a return value after hitting any errors and\n     /// calling `span_err`.\n-    pub fn any(sp: Span) -> Box<MacResult+'static> {\n+    pub fn any(sp: Span) -> Box<dyn MacResult+'static> {\n         Box::new(DummyResult { expr_only: false, span: sp })\n     }\n \n@@ -471,7 +471,7 @@ impl DummyResult {\n     /// Use this for macros that must expand to an expression, so even\n     /// if an error is encountered internally, the user will receive\n     /// an error that they also used it in the wrong place.\n-    pub fn expr(sp: Span) -> Box<MacResult+'static> {\n+    pub fn expr(sp: Span) -> Box<dyn MacResult+'static> {\n         Box::new(DummyResult { expr_only: true, span: sp })\n     }\n \n@@ -559,7 +559,7 @@ impl MacResult for DummyResult {\n }\n \n pub type BuiltinDeriveFn =\n-    for<'cx> fn(&'cx mut ExtCtxt, Span, &MetaItem, &Annotatable, &mut FnMut(Annotatable));\n+    for<'cx> fn(&'cx mut ExtCtxt, Span, &MetaItem, &Annotatable, &mut dyn FnMut(Annotatable));\n \n /// Represents different kinds of macro invocations that can be resolved.\n #[derive(Clone, Copy, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n@@ -590,15 +590,15 @@ pub enum SyntaxExtension {\n     /// `#[derive(...)]` is a `MultiItemDecorator`.\n     ///\n     /// Prefer ProcMacro or MultiModifier since they are more flexible.\n-    MultiDecorator(Box<MultiItemDecorator + sync::Sync + sync::Send>),\n+    MultiDecorator(Box<dyn MultiItemDecorator + sync::Sync + sync::Send>),\n \n     /// A syntax extension that is attached to an item and modifies it\n     /// in-place. Also allows decoration, i.e., creating new items.\n-    MultiModifier(Box<MultiItemModifier + sync::Sync + sync::Send>),\n+    MultiModifier(Box<dyn MultiItemModifier + sync::Sync + sync::Send>),\n \n     /// A function-like procedural macro. TokenStream -> TokenStream.\n     ProcMacro {\n-        expander: Box<ProcMacro + sync::Sync + sync::Send>,\n+        expander: Box<dyn ProcMacro + sync::Sync + sync::Send>,\n         allow_internal_unstable: bool,\n         edition: Edition,\n     },\n@@ -607,13 +607,13 @@ pub enum SyntaxExtension {\n     /// The first TokenSteam is the attribute, the second is the annotated item.\n     /// Allows modification of the input items and adding new items, similar to\n     /// MultiModifier, but uses TokenStreams, rather than AST nodes.\n-    AttrProcMacro(Box<AttrProcMacro + sync::Sync + sync::Send>, Edition),\n+    AttrProcMacro(Box<dyn AttrProcMacro + sync::Sync + sync::Send>, Edition),\n \n     /// A normal, function-like syntax extension.\n     ///\n     /// `bytes!` is a `NormalTT`.\n     NormalTT {\n-        expander: Box<TTMacroExpander + sync::Sync + sync::Send>,\n+        expander: Box<dyn TTMacroExpander + sync::Sync + sync::Send>,\n         def_info: Option<(ast::NodeId, Span)>,\n         /// Whether the contents of the macro can\n         /// directly use `#[unstable]` things (true == yes).\n@@ -633,21 +633,21 @@ pub enum SyntaxExtension {\n     /// A function-like syntax extension that has an extra ident before\n     /// the block.\n     ///\n-    IdentTT(Box<IdentMacroExpander + sync::Sync + sync::Send>, Option<Span>, bool),\n+    IdentTT(Box<dyn IdentMacroExpander + sync::Sync + sync::Send>, Option<Span>, bool),\n \n     /// An attribute-like procedural macro. TokenStream -> TokenStream.\n     /// The input is the annotated item.\n     /// Allows generating code to implement a Trait for a given struct\n     /// or enum item.\n-    ProcMacroDerive(Box<MultiItemModifier + sync::Sync + sync::Send>,\n+    ProcMacroDerive(Box<dyn MultiItemModifier + sync::Sync + sync::Send>,\n                     Vec<Symbol> /* inert attribute names */, Edition),\n \n     /// An attribute-like procedural macro that derives a builtin trait.\n     BuiltinDerive(BuiltinDeriveFn),\n \n     /// A declarative macro, e.g. `macro m() {}`.\n     DeclMacro {\n-        expander: Box<TTMacroExpander + sync::Sync + sync::Send>,\n+        expander: Box<dyn TTMacroExpander + sync::Sync + sync::Send>,\n         def_info: Option<(ast::NodeId, Span)>,\n         is_transparent: bool,\n         edition: Edition,\n@@ -784,7 +784,7 @@ pub struct ExtCtxt<'a> {\n     pub parse_sess: &'a parse::ParseSess,\n     pub ecfg: expand::ExpansionConfig<'a>,\n     pub root_path: PathBuf,\n-    pub resolver: &'a mut Resolver,\n+    pub resolver: &'a mut dyn Resolver,\n     pub resolve_err_count: usize,\n     pub current_expansion: ExpansionData,\n     pub expansions: HashMap<Span, Vec<String>>,\n@@ -793,7 +793,7 @@ pub struct ExtCtxt<'a> {\n impl<'a> ExtCtxt<'a> {\n     pub fn new(parse_sess: &'a parse::ParseSess,\n                ecfg: expand::ExpansionConfig<'a>,\n-               resolver: &'a mut Resolver)\n+               resolver: &'a mut dyn Resolver)\n                -> ExtCtxt<'a> {\n         ExtCtxt {\n             parse_sess,"}, {"sha": "865cb3d0d45783d65580cd93f4f8f5ed1fa2e3f8", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e28e4877a828d1f5bda49dbb5bae1b902596f8f6/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e28e4877a828d1f5bda49dbb5bae1b902596f8f6/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=e28e4877a828d1f5bda49dbb5bae1b902596f8f6", "patch": "@@ -71,7 +71,7 @@ macro_rules! ast_fragments {\n                 }\n             }\n \n-            fn make_from<'a>(self, result: Box<MacResult + 'a>) -> Option<AstFragment> {\n+            fn make_from<'a>(self, result: Box<dyn MacResult + 'a>) -> Option<AstFragment> {\n                 match self {\n                     AstFragmentKind::OptExpr =>\n                         result.make_expr().map(Some).map(AstFragment::OptExpr),"}, {"sha": "1ace4d4a880e212f9e75b6bd26954bb8d2f4e918", "filename": "src/libsyntax/ext/quote.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/e28e4877a828d1f5bda49dbb5bae1b902596f8f6/src%2Flibsyntax%2Fext%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e28e4877a828d1f5bda49dbb5bae1b902596f8f6/src%2Flibsyntax%2Fext%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fquote.rs?ref=e28e4877a828d1f5bda49dbb5bae1b902596f8f6", "patch": "@@ -452,7 +452,7 @@ pub fn parse_path_panic(parser: &mut Parser, mode: PathStyle) -> ast::Path {\n pub fn expand_quote_tokens<'cx>(cx: &'cx mut ExtCtxt,\n                                 sp: Span,\n                                 tts: &[TokenTree])\n-                                -> Box<base::MacResult+'cx> {\n+                                -> Box<dyn base::MacResult+'cx> {\n     let (cx_expr, expr) = expand_tts(cx, sp, tts);\n     let expanded = expand_wrapper(cx, sp, cx_expr, expr, &[&[\"syntax\", \"ext\", \"quote\", \"rt\"]]);\n     base::MacEager::expr(expanded)\n@@ -461,55 +461,55 @@ pub fn expand_quote_tokens<'cx>(cx: &'cx mut ExtCtxt,\n pub fn expand_quote_expr<'cx>(cx: &'cx mut ExtCtxt,\n                               sp: Span,\n                               tts: &[TokenTree])\n-                              -> Box<base::MacResult+'cx> {\n+                              -> Box<dyn base::MacResult+'cx> {\n     let expanded = expand_parse_call(cx, sp, \"parse_expr_panic\", vec![], tts);\n     base::MacEager::expr(expanded)\n }\n \n pub fn expand_quote_item<'cx>(cx: &'cx mut ExtCtxt,\n                               sp: Span,\n                               tts: &[TokenTree])\n-                              -> Box<base::MacResult+'cx> {\n+                              -> Box<dyn base::MacResult+'cx> {\n     let expanded = expand_parse_call(cx, sp, \"parse_item_panic\", vec![], tts);\n     base::MacEager::expr(expanded)\n }\n \n pub fn expand_quote_pat<'cx>(cx: &'cx mut ExtCtxt,\n                              sp: Span,\n                              tts: &[TokenTree])\n-                             -> Box<base::MacResult+'cx> {\n+                             -> Box<dyn base::MacResult+'cx> {\n     let expanded = expand_parse_call(cx, sp, \"parse_pat_panic\", vec![], tts);\n     base::MacEager::expr(expanded)\n }\n \n pub fn expand_quote_arm(cx: &mut ExtCtxt,\n                         sp: Span,\n                         tts: &[TokenTree])\n-                        -> Box<base::MacResult+'static> {\n+                        -> Box<dyn base::MacResult+'static> {\n     let expanded = expand_parse_call(cx, sp, \"parse_arm_panic\", vec![], tts);\n     base::MacEager::expr(expanded)\n }\n \n pub fn expand_quote_ty(cx: &mut ExtCtxt,\n                        sp: Span,\n                        tts: &[TokenTree])\n-                       -> Box<base::MacResult+'static> {\n+                       -> Box<dyn base::MacResult+'static> {\n     let expanded = expand_parse_call(cx, sp, \"parse_ty_panic\", vec![], tts);\n     base::MacEager::expr(expanded)\n }\n \n pub fn expand_quote_stmt(cx: &mut ExtCtxt,\n                          sp: Span,\n                          tts: &[TokenTree])\n-                         -> Box<base::MacResult+'static> {\n+                         -> Box<dyn base::MacResult+'static> {\n     let expanded = expand_parse_call(cx, sp, \"parse_stmt_panic\", vec![], tts);\n     base::MacEager::expr(expanded)\n }\n \n pub fn expand_quote_attr(cx: &mut ExtCtxt,\n                          sp: Span,\n                          tts: &[TokenTree])\n-                         -> Box<base::MacResult+'static> {\n+                         -> Box<dyn base::MacResult+'static> {\n     let expanded = expand_parse_call(cx, sp, \"parse_attribute_panic\",\n                                     vec![cx.expr_bool(sp, true)], tts);\n \n@@ -519,31 +519,31 @@ pub fn expand_quote_attr(cx: &mut ExtCtxt,\n pub fn expand_quote_arg(cx: &mut ExtCtxt,\n                         sp: Span,\n                         tts: &[TokenTree])\n-                        -> Box<base::MacResult+'static> {\n+                        -> Box<dyn base::MacResult+'static> {\n     let expanded = expand_parse_call(cx, sp, \"parse_arg_panic\", vec![], tts);\n     base::MacEager::expr(expanded)\n }\n \n pub fn expand_quote_block(cx: &mut ExtCtxt,\n                         sp: Span,\n                         tts: &[TokenTree])\n-                        -> Box<base::MacResult+'static> {\n+                        -> Box<dyn base::MacResult+'static> {\n     let expanded = expand_parse_call(cx, sp, \"parse_block_panic\", vec![], tts);\n     base::MacEager::expr(expanded)\n }\n \n pub fn expand_quote_meta_item(cx: &mut ExtCtxt,\n                         sp: Span,\n                         tts: &[TokenTree])\n-                        -> Box<base::MacResult+'static> {\n+                        -> Box<dyn base::MacResult+'static> {\n     let expanded = expand_parse_call(cx, sp, \"parse_meta_item_panic\", vec![], tts);\n     base::MacEager::expr(expanded)\n }\n \n pub fn expand_quote_path(cx: &mut ExtCtxt,\n                         sp: Span,\n                         tts: &[TokenTree])\n-                        -> Box<base::MacResult+'static> {\n+                        -> Box<dyn base::MacResult+'static> {\n     let mode = mk_parser_path(cx, sp, &[\"PathStyle\", \"Type\"]);\n     let expanded = expand_parse_call(cx, sp, \"parse_path_panic\", vec![mode], tts);\n     base::MacEager::expr(expanded)"}, {"sha": "0c36c072a03023a4304d3c3f3656f72d215f4674", "filename": "src/libsyntax/ext/source_util.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/e28e4877a828d1f5bda49dbb5bae1b902596f8f6/src%2Flibsyntax%2Fext%2Fsource_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e28e4877a828d1f5bda49dbb5bae1b902596f8f6/src%2Flibsyntax%2Fext%2Fsource_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fsource_util.rs?ref=e28e4877a828d1f5bda49dbb5bae1b902596f8f6", "patch": "@@ -32,7 +32,7 @@ use rustc_data_structures::sync::Lrc;\n \n /// line!(): expands to the current line number\n pub fn expand_line(cx: &mut ExtCtxt, sp: Span, tts: &[tokenstream::TokenTree])\n-                   -> Box<base::MacResult+'static> {\n+                   -> Box<dyn base::MacResult+'static> {\n     base::check_zero_tts(cx, sp, tts, \"line!\");\n \n     let topmost = cx.expansion_cause().unwrap_or(sp);\n@@ -43,7 +43,7 @@ pub fn expand_line(cx: &mut ExtCtxt, sp: Span, tts: &[tokenstream::TokenTree])\n \n /* column!(): expands to the current column number */\n pub fn expand_column(cx: &mut ExtCtxt, sp: Span, tts: &[tokenstream::TokenTree])\n-                  -> Box<base::MacResult+'static> {\n+                  -> Box<dyn base::MacResult+'static> {\n     base::check_zero_tts(cx, sp, tts, \"column!\");\n \n     let topmost = cx.expansion_cause().unwrap_or(sp);\n@@ -54,7 +54,7 @@ pub fn expand_column(cx: &mut ExtCtxt, sp: Span, tts: &[tokenstream::TokenTree])\n \n /* __rust_unstable_column!(): expands to the current column number */\n pub fn expand_column_gated(cx: &mut ExtCtxt, sp: Span, tts: &[tokenstream::TokenTree])\n-                  -> Box<base::MacResult+'static> {\n+                  -> Box<dyn base::MacResult+'static> {\n     if sp.allows_unstable() {\n         expand_column(cx, sp, tts)\n     } else {\n@@ -66,7 +66,7 @@ pub fn expand_column_gated(cx: &mut ExtCtxt, sp: Span, tts: &[tokenstream::Token\n /// The filemap (`loc.file`) contains a bunch more information we could spit\n /// out if we wanted.\n pub fn expand_file(cx: &mut ExtCtxt, sp: Span, tts: &[tokenstream::TokenTree])\n-                   -> Box<base::MacResult+'static> {\n+                   -> Box<dyn base::MacResult+'static> {\n     base::check_zero_tts(cx, sp, tts, \"file!\");\n \n     let topmost = cx.expansion_cause().unwrap_or(sp);\n@@ -75,13 +75,13 @@ pub fn expand_file(cx: &mut ExtCtxt, sp: Span, tts: &[tokenstream::TokenTree])\n }\n \n pub fn expand_stringify(cx: &mut ExtCtxt, sp: Span, tts: &[tokenstream::TokenTree])\n-                        -> Box<base::MacResult+'static> {\n+                        -> Box<dyn base::MacResult+'static> {\n     let s = pprust::tts_to_string(tts);\n     base::MacEager::expr(cx.expr_str(sp, Symbol::intern(&s)))\n }\n \n pub fn expand_mod(cx: &mut ExtCtxt, sp: Span, tts: &[tokenstream::TokenTree])\n-                  -> Box<base::MacResult+'static> {\n+                  -> Box<dyn base::MacResult+'static> {\n     base::check_zero_tts(cx, sp, tts, \"module_path!\");\n     let mod_path = &cx.current_expansion.module.mod_path;\n     let string = mod_path.iter().map(|x| x.to_string()).collect::<Vec<String>>().join(\"::\");\n@@ -93,7 +93,7 @@ pub fn expand_mod(cx: &mut ExtCtxt, sp: Span, tts: &[tokenstream::TokenTree])\n /// This is generally a bad idea because it's going to behave\n /// unhygienically.\n pub fn expand_include<'cx>(cx: &'cx mut ExtCtxt, sp: Span, tts: &[tokenstream::TokenTree])\n-                           -> Box<base::MacResult+'cx> {\n+                           -> Box<dyn base::MacResult+'cx> {\n     let file = match get_single_str_from_tts(cx, sp, tts, \"include!\") {\n         Some(f) => f,\n         None => return DummyResult::expr(sp),\n@@ -131,7 +131,7 @@ pub fn expand_include<'cx>(cx: &'cx mut ExtCtxt, sp: Span, tts: &[tokenstream::T\n \n // include_str! : read the given file, insert it as a literal string expr\n pub fn expand_include_str(cx: &mut ExtCtxt, sp: Span, tts: &[tokenstream::TokenTree])\n-                          -> Box<base::MacResult+'static> {\n+                          -> Box<dyn base::MacResult+'static> {\n     let file = match get_single_str_from_tts(cx, sp, tts, \"include_str!\") {\n         Some(f) => f,\n         None => return DummyResult::expr(sp)\n@@ -168,7 +168,7 @@ pub fn expand_include_str(cx: &mut ExtCtxt, sp: Span, tts: &[tokenstream::TokenT\n }\n \n pub fn expand_include_bytes(cx: &mut ExtCtxt, sp: Span, tts: &[tokenstream::TokenTree])\n-                            -> Box<base::MacResult+'static> {\n+                            -> Box<dyn base::MacResult+'static> {\n     let file = match get_single_str_from_tts(cx, sp, tts, \"include_bytes!\") {\n         Some(f) => f,\n         None => return DummyResult::expr(sp)"}, {"sha": "9ebead1062ebcfc3c6b1bb5ea3915e1833f7ecc7", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e28e4877a828d1f5bda49dbb5bae1b902596f8f6/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e28e4877a828d1f5bda49dbb5bae1b902596f8f6/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=e28e4877a828d1f5bda49dbb5bae1b902596f8f6", "patch": "@@ -73,7 +73,7 @@ impl TTMacroExpander for MacroRulesMacroExpander {\n                    cx: &'cx mut ExtCtxt,\n                    sp: Span,\n                    input: TokenStream)\n-                   -> Box<MacResult+'cx> {\n+                   -> Box<dyn MacResult+'cx> {\n         if !self.valid {\n             return DummyResult::any(sp);\n         }\n@@ -99,7 +99,7 @@ fn generic_extension<'cx>(cx: &'cx mut ExtCtxt,\n                           arg: TokenStream,\n                           lhses: &[quoted::TokenTree],\n                           rhses: &[quoted::TokenTree])\n-                          -> Box<MacResult+'cx> {\n+                          -> Box<dyn MacResult+'cx> {\n     if cx.trace_macros() {\n         trace_macros_note(cx, sp, format!(\"expanding `{}! {{ {} }}`\", name, arg));\n     }"}, {"sha": "65de1503966bfdc2020aa1aceecc64be687e2a66", "filename": "src/libsyntax/json.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e28e4877a828d1f5bda49dbb5bae1b902596f8f6/src%2Flibsyntax%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e28e4877a828d1f5bda49dbb5bae1b902596f8f6/src%2Flibsyntax%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fjson.rs?ref=e28e4877a828d1f5bda49dbb5bae1b902596f8f6", "patch": "@@ -34,9 +34,9 @@ use std::sync::{Arc, Mutex};\n use rustc_serialize::json::{as_json, as_pretty_json};\n \n pub struct JsonEmitter {\n-    dst: Box<Write + Send>,\n+    dst: Box<dyn Write + Send>,\n     registry: Option<Registry>,\n-    cm: Lrc<CodeMapper + sync::Send + sync::Sync>,\n+    cm: Lrc<dyn CodeMapper + sync::Send + sync::Sync>,\n     pretty: bool,\n     ui_testing: bool,\n }\n@@ -60,7 +60,7 @@ impl JsonEmitter {\n                             pretty)\n     }\n \n-    pub fn new(dst: Box<Write + Send>,\n+    pub fn new(dst: Box<dyn Write + Send>,\n                registry: Option<Registry>,\n                code_map: Lrc<CodeMap>,\n                pretty: bool) -> JsonEmitter {"}, {"sha": "ffaad9bf94c187313f7abfbea487d2a8981a9356", "filename": "src/libsyntax/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e28e4877a828d1f5bda49dbb5bae1b902596f8f6/src%2Flibsyntax%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e28e4877a828d1f5bda49dbb5bae1b902596f8f6/src%2Flibsyntax%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Flib.rs?ref=e28e4877a828d1f5bda49dbb5bae1b902596f8f6", "patch": "@@ -14,6 +14,8 @@\n //!\n //! This API is completely unstable and subject to change.\n \n+#![deny(bare_trait_objects)]\n+\n #![doc(html_logo_url = \"https://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n        html_favicon_url = \"https://doc.rust-lang.org/favicon.ico\",\n        html_root_url = \"https://doc.rust-lang.org/nightly/\","}, {"sha": "20a585b6601a51da4b3cf4f273991efc37958200", "filename": "src/libsyntax/parse/lexer/comments.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e28e4877a828d1f5bda49dbb5bae1b902596f8f6/src%2Flibsyntax%2Fparse%2Flexer%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e28e4877a828d1f5bda49dbb5bae1b902596f8f6/src%2Flibsyntax%2Fparse%2Flexer%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fcomments.rs?ref=e28e4877a828d1f5bda49dbb5bae1b902596f8f6", "patch": "@@ -357,7 +357,7 @@ pub struct Literal {\n \n // it appears this function is called only from pprust... that's\n // probably not a good thing.\n-pub fn gather_comments_and_literals(sess: &ParseSess, path: FileName, srdr: &mut Read)\n+pub fn gather_comments_and_literals(sess: &ParseSess, path: FileName, srdr: &mut dyn Read)\n                                     -> (Vec<Comment>, Vec<Literal>) {\n     let mut src = Vec::new();\n     srdr.read_to_end(&mut src).unwrap();"}, {"sha": "086de35d531c7f8db1d6b49e25749ba55c6b9ce2", "filename": "src/libsyntax/print/pp.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e28e4877a828d1f5bda49dbb5bae1b902596f8f6/src%2Flibsyntax%2Fprint%2Fpp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e28e4877a828d1f5bda49dbb5bae1b902596f8f6/src%2Flibsyntax%2Fprint%2Fpp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpp.rs?ref=e28e4877a828d1f5bda49dbb5bae1b902596f8f6", "patch": "@@ -241,7 +241,7 @@ pub struct PrintStackElem {\n \n const SIZE_INFINITY: isize = 0xffff;\n \n-pub fn mk_printer<'a>(out: Box<io::Write+'a>, linewidth: usize) -> Printer<'a> {\n+pub fn mk_printer<'a>(out: Box<dyn io::Write+'a>, linewidth: usize) -> Printer<'a> {\n     // Yes 55, it makes the ring buffers big enough to never fall behind.\n     let n: usize = 55 * linewidth;\n     debug!(\"mk_printer {}\", linewidth);\n@@ -264,7 +264,7 @@ pub fn mk_printer<'a>(out: Box<io::Write+'a>, linewidth: usize) -> Printer<'a> {\n }\n \n pub struct Printer<'a> {\n-    out: Box<io::Write+'a>,\n+    out: Box<dyn io::Write+'a>,\n     buf_max_len: usize,\n     /// Width of lines we're constrained to\n     margin: isize,"}, {"sha": "c5ba7daaeb8f687753c849e9c03c12d289bde4fb", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/e28e4877a828d1f5bda49dbb5bae1b902596f8f6/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e28e4877a828d1f5bda49dbb5bae1b902596f8f6/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=e28e4877a828d1f5bda49dbb5bae1b902596f8f6", "patch": "@@ -62,10 +62,10 @@ pub struct State<'a> {\n     literals: Peekable<vec::IntoIter<comments::Literal>>,\n     cur_cmnt: usize,\n     boxes: Vec<pp::Breaks>,\n-    ann: &'a (PpAnn+'a),\n+    ann: &'a (dyn PpAnn+'a),\n }\n \n-fn rust_printer<'a>(writer: Box<Write+'a>, ann: &'a PpAnn) -> State<'a> {\n+fn rust_printer<'a>(writer: Box<dyn Write+'a>, ann: &'a dyn PpAnn) -> State<'a> {\n     State {\n         s: pp::mk_printer(writer, DEFAULT_COLUMNS),\n         cm: None,\n@@ -88,9 +88,9 @@ pub fn print_crate<'a>(cm: &'a CodeMap,\n                        sess: &ParseSess,\n                        krate: &ast::Crate,\n                        filename: FileName,\n-                       input: &mut Read,\n-                       out: Box<Write+'a>,\n-                       ann: &'a PpAnn,\n+                       input: &mut dyn Read,\n+                       out: Box<dyn Write+'a>,\n+                       ann: &'a dyn PpAnn,\n                        is_expanded: bool) -> io::Result<()> {\n     let mut s = State::new_from_input(cm, sess, filename, input, out, ann, is_expanded);\n \n@@ -121,9 +121,9 @@ impl<'a> State<'a> {\n     pub fn new_from_input(cm: &'a CodeMap,\n                           sess: &ParseSess,\n                           filename: FileName,\n-                          input: &mut Read,\n-                          out: Box<Write+'a>,\n-                          ann: &'a PpAnn,\n+                          input: &mut dyn Read,\n+                          out: Box<dyn Write+'a>,\n+                          ann: &'a dyn PpAnn,\n                           is_expanded: bool) -> State<'a> {\n         let (cmnts, lits) = comments::gather_comments_and_literals(sess, filename, input);\n \n@@ -139,8 +139,8 @@ impl<'a> State<'a> {\n     }\n \n     pub fn new(cm: &'a CodeMap,\n-               out: Box<Write+'a>,\n-               ann: &'a PpAnn,\n+               out: Box<dyn Write+'a>,\n+               ann: &'a dyn PpAnn,\n                comments: Option<Vec<comments::Comment>>,\n                literals: Option<Vec<comments::Literal>>) -> State<'a> {\n         State {"}, {"sha": "4d5b0b327dd2e32784fd602c53279ee15bea2b2d", "filename": "src/libsyntax/test.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e28e4877a828d1f5bda49dbb5bae1b902596f8f6/src%2Flibsyntax%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e28e4877a828d1f5bda49dbb5bae1b902596f8f6/src%2Flibsyntax%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftest.rs?ref=e28e4877a828d1f5bda49dbb5bae1b902596f8f6", "patch": "@@ -72,7 +72,7 @@ struct TestCtxt<'a> {\n // Traverse the crate, collecting all the test functions, eliding any\n // existing main functions, and synthesizing a main test harness\n pub fn modify_for_testing(sess: &ParseSess,\n-                          resolver: &mut Resolver,\n+                          resolver: &mut dyn Resolver,\n                           should_test: bool,\n                           krate: ast::Crate,\n                           span_diagnostic: &errors::Handler,\n@@ -278,7 +278,7 @@ fn mk_reexport_mod(cx: &mut TestCtxt,\n }\n \n fn generate_test_harness(sess: &ParseSess,\n-                         resolver: &mut Resolver,\n+                         resolver: &mut dyn Resolver,\n                          reexport_test_harness_main: Option<Symbol>,\n                          krate: ast::Crate,\n                          sd: &errors::Handler,"}]}