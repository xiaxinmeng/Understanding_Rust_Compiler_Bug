{"sha": "4721b6518ce9c8e3a452af07c6dd178fbb83ab16", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ3MjFiNjUxOGNlOWM4ZTNhNDUyYWYwN2M2ZGQxNzhmYmI4M2FiMTY=", "commit": {"author": {"name": "Arlie Davis", "email": "ardavis@microsoft.com", "date": "2020-12-14T23:45:19Z"}, "committer": {"name": "Arlie Davis", "email": "ardavis@microsoft.com", "date": "2021-01-05T20:52:34Z"}, "message": "Split a func into cold/hot parts, reducing binary size\n\nI noticed that the Size::bits function is called in many places,\nand is inlined into them. On x86_64-pc-windows-msvc, this function\nis inlined 527 times, and compiled separately (non-inlined) 3 times.\n\nEach of those inlined calls contains code that panics. This commit\nmoves the `panic!` call into a separate function and marks that\nfunction with `#[cold]`.\n\nThis reduces binary size by 24 KB. By itself, that's not a substantial\nreduction. However, changes like this often reduce pressure on\ninstruction-caches, since it reduces the amount of code that is inlined\ninto hot code paths. Or more precisely, it removes cold code from hot\ncache lines. It also removes all conditionals from Size::bits(),\nwhich is called in many places.", "tree": {"sha": "becbe37ac46d3888a9011381dee87207018bedc3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/becbe37ac46d3888a9011381dee87207018bedc3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4721b6518ce9c8e3a452af07c6dd178fbb83ab16", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4721b6518ce9c8e3a452af07c6dd178fbb83ab16", "html_url": "https://github.com/rust-lang/rust/commit/4721b6518ce9c8e3a452af07c6dd178fbb83ab16", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4721b6518ce9c8e3a452af07c6dd178fbb83ab16/comments", "author": null, "committer": null, "parents": [{"sha": "3b63e16552bbc3bfdddad67ba219455a2a3ac03c", "url": "https://api.github.com/repos/rust-lang/rust/commits/3b63e16552bbc3bfdddad67ba219455a2a3ac03c", "html_url": "https://github.com/rust-lang/rust/commit/3b63e16552bbc3bfdddad67ba219455a2a3ac03c"}], "stats": {"total": 26, "additions": 20, "deletions": 6}, "files": [{"sha": "31ceb0a389076dfa27387d2ae18f1f402e602653", "filename": "compiler/rustc_target/src/abi/mod.rs", "status": "modified", "additions": 20, "deletions": 6, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/4721b6518ce9c8e3a452af07c6dd178fbb83ab16/compiler%2Frustc_target%2Fsrc%2Fabi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4721b6518ce9c8e3a452af07c6dd178fbb83ab16/compiler%2Frustc_target%2Fsrc%2Fabi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fabi%2Fmod.rs?ref=4721b6518ce9c8e3a452af07c6dd178fbb83ab16", "patch": "@@ -238,22 +238,38 @@ pub enum Endian {\n #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Debug, Encodable, Decodable)]\n #[derive(HashStable_Generic)]\n pub struct Size {\n+    // The top 3 bits are ALWAYS zero.\n     raw: u64,\n }\n \n impl Size {\n     pub const ZERO: Size = Size { raw: 0 };\n \n-    #[inline]\n+    /// Rounds `bits` up to the next-higher byte boundary, if `bits` is\n+    /// is not aligned.\n     pub fn from_bits(bits: impl TryInto<u64>) -> Size {\n         let bits = bits.try_into().ok().unwrap();\n+\n+        #[cold]\n+        fn overflow(bits: u64) -> ! {\n+            panic!(\"Size::from_bits({}) has overflowed\", bits);\n+        }\n+\n+        // This is the largest value of `bits` that does not cause overflow\n+        // during rounding, and guarantees that the resulting number of bytes\n+        // cannot cause overflow when multiplied by 8.\n+        if bits > 0xffff_ffff_ffff_fff8 {\n+            overflow(bits);\n+        }\n+\n         // Avoid potential overflow from `bits + 7`.\n-        Size::from_bytes(bits / 8 + ((bits % 8) + 7) / 8)\n+        Size { raw: bits / 8 + ((bits % 8) + 7) / 8 }\n     }\n \n     #[inline]\n     pub fn from_bytes(bytes: impl TryInto<u64>) -> Size {\n-        Size { raw: bytes.try_into().ok().unwrap() }\n+        let bytes: u64 = bytes.try_into().ok().unwrap();\n+        Size { raw: bytes }\n     }\n \n     #[inline]\n@@ -268,9 +284,7 @@ impl Size {\n \n     #[inline]\n     pub fn bits(self) -> u64 {\n-        self.bytes().checked_mul(8).unwrap_or_else(|| {\n-            panic!(\"Size::bits: {} bytes in bits doesn't fit in u64\", self.bytes())\n-        })\n+        self.raw << 3\n     }\n \n     #[inline]"}]}