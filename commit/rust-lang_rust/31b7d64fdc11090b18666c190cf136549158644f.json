{"sha": "31b7d64fdc11090b18666c190cf136549158644f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMxYjdkNjRmZGMxMTA5MGIxODY2NmMxOTBjZjEzNjU0OTE1ODY0NGY=", "commit": {"author": {"name": "Aaron Turon", "email": "aturon@mozilla.com", "date": "2014-10-14T18:32:31Z"}, "committer": {"name": "Aaron Turon", "email": "aturon@mozilla.com", "date": "2014-10-14T23:04:06Z"}, "message": "rustc: Add deprecation/renaming support for lints\n\nSince a large number of lints are being renamed for RFC 344, this commit\nadds some basic deprecation/renaming functionality to the pluggable lint\nsystem. It allows a simple mapping of old to new names, and can warn\nwhen old names are being used.\n\nThis change needs to be rolled out in stages. In this commit, the\ndeprecation warning is commented out, but the old name is forwarded to\nthe new one.\n\nOnce the commit lands and we have generated a new snapshot of the\ncompiler, we can add the deprecation warning and rename all uses of the\nlints in the rust codebase.", "tree": {"sha": "462da778fc239022c92ca2ec6e196f1c91fdb71d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/462da778fc239022c92ca2ec6e196f1c91fdb71d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/31b7d64fdc11090b18666c190cf136549158644f", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/31b7d64fdc11090b18666c190cf136549158644f", "html_url": "https://github.com/rust-lang/rust/commit/31b7d64fdc11090b18666c190cf136549158644f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/31b7d64fdc11090b18666c190cf136549158644f/comments", "author": {"login": "aturon", "id": 709807, "node_id": "MDQ6VXNlcjcwOTgwNw==", "avatar_url": "https://avatars.githubusercontent.com/u/709807?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aturon", "html_url": "https://github.com/aturon", "followers_url": "https://api.github.com/users/aturon/followers", "following_url": "https://api.github.com/users/aturon/following{/other_user}", "gists_url": "https://api.github.com/users/aturon/gists{/gist_id}", "starred_url": "https://api.github.com/users/aturon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aturon/subscriptions", "organizations_url": "https://api.github.com/users/aturon/orgs", "repos_url": "https://api.github.com/users/aturon/repos", "events_url": "https://api.github.com/users/aturon/events{/privacy}", "received_events_url": "https://api.github.com/users/aturon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aturon", "id": 709807, "node_id": "MDQ6VXNlcjcwOTgwNw==", "avatar_url": "https://avatars.githubusercontent.com/u/709807?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aturon", "html_url": "https://github.com/aturon", "followers_url": "https://api.github.com/users/aturon/followers", "following_url": "https://api.github.com/users/aturon/following{/other_user}", "gists_url": "https://api.github.com/users/aturon/gists{/gist_id}", "starred_url": "https://api.github.com/users/aturon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aturon/subscriptions", "organizations_url": "https://api.github.com/users/aturon/orgs", "repos_url": "https://api.github.com/users/aturon/repos", "events_url": "https://api.github.com/users/aturon/events{/privacy}", "received_events_url": "https://api.github.com/users/aturon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3c0d2a7c90a381fa0df977300f267bb96760b566", "url": "https://api.github.com/repos/rust-lang/rust/commits/3c0d2a7c90a381fa0df977300f267bb96760b566", "html_url": "https://github.com/rust-lang/rust/commit/3c0d2a7c90a381fa0df977300f267bb96760b566"}], "stats": {"total": 76, "additions": 70, "deletions": 6}, "files": [{"sha": "0f63000bff113b9bb038851ed193888e5f6399ea", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 70, "deletions": 6, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/31b7d64fdc11090b18666c190cf136549158644f/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31b7d64fdc11090b18666c190cf136549158644f/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=31b7d64fdc11090b18666c190cf136549158644f", "patch": "@@ -63,7 +63,7 @@ pub struct LintStore {\n     passes: Option<Vec<LintPassObject>>,\n \n     /// Lints indexed by name.\n-    by_name: HashMap<String, LintId>,\n+    by_name: HashMap<String, TargetLint>,\n \n     /// Current levels of each lint, and where they were set.\n     levels: HashMap<LintId, LevelSource>,\n@@ -73,6 +73,15 @@ pub struct LintStore {\n     lint_groups: HashMap<&'static str, (Vec<LintId>, bool)>,\n }\n \n+/// The targed of the `by_name` map, which accounts for renaming/deprecation.\n+enum TargetLint {\n+    /// A direct lint target\n+    Id(LintId),\n+\n+    /// Temporary renaming, used for easing migration pain; see #16545\n+    Renamed(String, LintId),\n+}\n+\n impl LintStore {\n     fn get_level_source(&self, lint: LintId) -> LevelSource {\n         match self.levels.find(&lint) {\n@@ -115,7 +124,7 @@ impl LintStore {\n             self.lints.push((*lint, from_plugin));\n \n             let id = LintId::of(*lint);\n-            if !self.by_name.insert(lint.name_lower(), id) {\n+            if !self.by_name.insert(lint.name_lower(), Id(id)) {\n                 let msg = format!(\"duplicate specification of lint {}\", lint.name_lower());\n                 match (sess, from_plugin) {\n                     // We load builtin lints first, so a duplicate is a compiler bug.\n@@ -154,6 +163,14 @@ impl LintStore {\n         }\n     }\n \n+    fn register_renamed(&mut self, old_name: &str, new_name: &str) {\n+        let target = match self.by_name.find_equiv(&new_name) {\n+            Some(&Id(lint_id)) => lint_id.clone(),\n+            _ => fail!(\"invalid lint renaming of {} to {}\", old_name, new_name)\n+        };\n+        self.by_name.insert(old_name.to_string(), Renamed(new_name.to_string(), target));\n+    }\n+\n     pub fn register_builtin(&mut self, sess: Option<&Session>) {\n         macro_rules! add_builtin ( ( $sess:ident, $($name:ident),*, ) => (\n             {$(\n@@ -208,12 +225,59 @@ impl LintStore {\n \n         // We have one lint pass defined in this module.\n         self.register_pass(sess, false, box GatherNodeLevels as LintPassObject);\n+\n+        // Insert temporary renamings for a one-time deprecation (#16545)\n+        self.register_renamed(\"unnecessary_typecast\", \"unused_typecasts\");\n+        self.register_renamed(\"unsigned_negate\", \"unsigned_negation\");\n+        self.register_renamed(\"type_limits\", \"unused_comparisons\");\n+        self.register_renamed(\"type_overflow\", \"overflowing_literals\");\n+        self.register_renamed(\"ctypes\", \"improper_ctypes\");\n+        self.register_renamed(\"owned_heap_memory\", \"box_pointers\");\n+        self.register_renamed(\"unused_attribute\", \"unused_attributes\");\n+        self.register_renamed(\"path_statement\", \"path_statements\");\n+        self.register_renamed(\"unused_result\", \"unused_results\");\n+        self.register_renamed(\"non_uppercase_statics\", \"non_upper_case_globals\");\n+        self.register_renamed(\"unnecessary_parens\", \"unused_parens\");\n+        self.register_renamed(\"unnecessary_import_braces\", \"unused_import_braces\");\n+        self.register_renamed(\"unsafe_block\", \"unsafe_blocks\");\n+        self.register_renamed(\"unnecessary_allocation\", \"unused_allocation\");\n+        self.register_renamed(\"missing_doc\", \"missing_docs\");\n+        self.register_renamed(\"unused_extern_crate\", \"unused_extern_crates\");\n+        self.register_renamed(\"unnecessary_qualification\", \"unused_qualifications\");\n+        self.register_renamed(\"unrecognized_lint\", \"unknown_lints\");\n+        self.register_renamed(\"unused_variable\", \"unused_variables\");\n+        self.register_renamed(\"dead_assignment\", \"unused_assignments\");\n+        self.register_renamed(\"unknown_crate_type\", \"unknown_crate_types\");\n+        self.register_renamed(\"variant_size_difference\", \"variant_size_differences\");\n+        self.register_renamed(\"transmute_fat_ptr\", \"fat_ptr_transmutes\");\n+\n+    }\n+\n+    #[allow(unused_variable)]\n+    fn find_lint(&self, lint_name: &str, sess: &Session, span: Option<Span>)\n+                 -> Option<LintId>\n+    {\n+        match self.by_name.find_equiv(&lint_name) {\n+            Some(&Id(lint_id)) => Some(lint_id),\n+            Some(&Renamed(ref new_name, lint_id)) => {\n+                // NOTE(stage0): add the following code after the next snapshot\n+\n+                // let warning = format!(\"lint {} has been renamed to {}\",\n+                //                       lint_name, new_name);\n+                // match span {\n+                //     Some(span) => sess.span_warn(span, warning.as_slice()),\n+                //     None => sess.warn(warning.as_slice()),\n+                // };\n+                Some(lint_id)\n+            }\n+            None => None\n+        }\n     }\n \n     pub fn process_command_line(&mut self, sess: &Session) {\n         for &(ref lint_name, level) in sess.opts.lint_opts.iter() {\n-            match self.by_name.find_equiv(&lint_name.as_slice()) {\n-                Some(&lint_id) => self.set_level(lint_id, (level, CommandLine)),\n+            match self.find_lint(lint_name.as_slice(), sess, None) {\n+                Some(lint_id) => self.set_level(lint_id, (level, CommandLine)),\n                 None => {\n                     match self.lint_groups.iter().map(|(&x, pair)| (x, pair.ref0().clone()))\n                                                  .collect::<HashMap<&'static str, Vec<LintId>>>()\n@@ -421,8 +485,8 @@ impl<'a, 'tcx> Context<'a, 'tcx> {\n                     continue;\n                 }\n                 Ok((lint_name, level, span)) => {\n-                    match self.lints.by_name.find_equiv(&lint_name.get()) {\n-                        Some(&lint_id) => vec![(lint_id, level, span)],\n+                    match self.lints.find_lint(lint_name.get(), &self.tcx.sess, Some(span)) {\n+                        Some(lint_id) => vec![(lint_id, level, span)],\n                         None => {\n                             match self.lints.lint_groups.find_equiv(&lint_name.get()) {\n                                 Some(&(ref v, _)) => v.iter()"}]}