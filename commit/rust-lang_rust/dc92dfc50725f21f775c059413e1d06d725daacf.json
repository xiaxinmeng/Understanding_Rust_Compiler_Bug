{"sha": "dc92dfc50725f21f775c059413e1d06d725daacf", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRjOTJkZmM1MDcyNWYyMWY3NzVjMDU5NDEzZTFkMDZkNzI1ZGFhY2Y=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-01-29T23:09:58Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-01-29T23:09:58Z"}, "message": "Auto merge of #67688 - cjgillot:passes, r=Zoxc\n\nMove some code to librustc_passes.\n\nPer instructions by @Zoxc, some code from `librustc::middle` is moved to `librustc_passes`.\n\ncc #65031\nr? @Zoxc", "tree": {"sha": "3d1fbb6f2c0455c3918e840dc740de1166b49446", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3d1fbb6f2c0455c3918e840dc740de1166b49446"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dc92dfc50725f21f775c059413e1d06d725daacf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dc92dfc50725f21f775c059413e1d06d725daacf", "html_url": "https://github.com/rust-lang/rust/commit/dc92dfc50725f21f775c059413e1d06d725daacf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dc92dfc50725f21f775c059413e1d06d725daacf/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9ed29b6ff6aa2e048b09c27af8f62ee3040bdb37", "url": "https://api.github.com/repos/rust-lang/rust/commits/9ed29b6ff6aa2e048b09c27af8f62ee3040bdb37", "html_url": "https://github.com/rust-lang/rust/commit/9ed29b6ff6aa2e048b09c27af8f62ee3040bdb37"}, {"sha": "f9335e990897b9ad1f072eb0a8e7385d720538f2", "url": "https://api.github.com/repos/rust-lang/rust/commits/f9335e990897b9ad1f072eb0a8e7385d720538f2", "html_url": "https://github.com/rust-lang/rust/commit/f9335e990897b9ad1f072eb0a8e7385d720538f2"}], "stats": {"total": 958, "additions": 484, "deletions": 474}, "files": [{"sha": "db5e31981c08f13232491f38378ef4ebec310b3c", "filename": "src/librustc/hir/check_attr.rs", "status": "modified", "additions": 6, "deletions": 468, "changes": 474, "blob_url": "https://github.com/rust-lang/rust/blob/dc92dfc50725f21f775c059413e1d06d725daacf/src%2Flibrustc%2Fhir%2Fcheck_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc92dfc50725f21f775c059413e1d06d725daacf/src%2Flibrustc%2Fhir%2Fcheck_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fcheck_attr.rs?ref=dc92dfc50725f21f775c059413e1d06d725daacf", "patch": "@@ -4,32 +4,19 @@\n //! conflicts between multiple such attributes attached to the same\n //! item.\n \n-use crate::hir::map::Map;\n-use crate::ty::query::Providers;\n-use crate::ty::TyCtxt;\n-\n-use rustc_errors::struct_span_err;\n use rustc_hir as hir;\n-use rustc_hir::def_id::DefId;\n-use rustc_hir::intravisit::{self, NestedVisitorMap, Visitor};\n-use rustc_hir::DUMMY_HIR_ID;\n-use rustc_hir::{self, HirId, Item, ItemKind, TraitItem, TraitItemKind};\n-use rustc_session::lint::builtin::{CONFLICTING_REPR_HINTS, UNUSED_ATTRIBUTES};\n-use rustc_span::symbol::sym;\n-use rustc_span::Span;\n-use syntax::ast::Attribute;\n-use syntax::attr;\n+use rustc_hir::{Item, ItemKind, TraitItem, TraitItemKind};\n \n use std::fmt::{self, Display};\n \n #[derive(Copy, Clone, PartialEq)]\n-pub(crate) enum MethodKind {\n+pub enum MethodKind {\n     Trait { body: bool },\n     Inherent,\n }\n \n #[derive(Copy, Clone, PartialEq)]\n-pub(crate) enum Target {\n+pub enum Target {\n     ExternCrate,\n     Use,\n     Static,\n@@ -94,7 +81,7 @@ impl Display for Target {\n }\n \n impl Target {\n-    pub(crate) fn from_item(item: &Item<'_>) -> Target {\n+    pub fn from_item(item: &Item<'_>) -> Target {\n         match item.kind {\n             ItemKind::ExternCrate(..) => Target::ExternCrate,\n             ItemKind::Use(..) => Target::Use,\n@@ -115,7 +102,7 @@ impl Target {\n         }\n     }\n \n-    fn from_trait_item(trait_item: &TraitItem<'_>) -> Target {\n+    pub fn from_trait_item(trait_item: &TraitItem<'_>) -> Target {\n         match trait_item.kind {\n             TraitItemKind::Const(..) => Target::AssocConst,\n             TraitItemKind::Method(_, hir::TraitMethod::Required(_)) => {\n@@ -128,460 +115,11 @@ impl Target {\n         }\n     }\n \n-    fn from_foreign_item(foreign_item: &hir::ForeignItem<'_>) -> Target {\n+    pub fn from_foreign_item(foreign_item: &hir::ForeignItem<'_>) -> Target {\n         match foreign_item.kind {\n             hir::ForeignItemKind::Fn(..) => Target::ForeignFn,\n             hir::ForeignItemKind::Static(..) => Target::ForeignStatic,\n             hir::ForeignItemKind::Type => Target::ForeignTy,\n         }\n     }\n-\n-    fn from_impl_item<'tcx>(tcx: TyCtxt<'tcx>, impl_item: &hir::ImplItem<'_>) -> Target {\n-        match impl_item.kind {\n-            hir::ImplItemKind::Const(..) => Target::AssocConst,\n-            hir::ImplItemKind::Method(..) => {\n-                let parent_hir_id = tcx.hir().get_parent_item(impl_item.hir_id);\n-                let containing_item = tcx.hir().expect_item(parent_hir_id);\n-                let containing_impl_is_for_trait = match &containing_item.kind {\n-                    hir::ItemKind::Impl { ref of_trait, .. } => of_trait.is_some(),\n-                    _ => bug!(\"parent of an ImplItem must be an Impl\"),\n-                };\n-                if containing_impl_is_for_trait {\n-                    Target::Method(MethodKind::Trait { body: true })\n-                } else {\n-                    Target::Method(MethodKind::Inherent)\n-                }\n-            }\n-            hir::ImplItemKind::TyAlias(..) | hir::ImplItemKind::OpaqueTy(..) => Target::AssocTy,\n-        }\n-    }\n-}\n-\n-struct CheckAttrVisitor<'tcx> {\n-    tcx: TyCtxt<'tcx>,\n-}\n-\n-impl CheckAttrVisitor<'tcx> {\n-    /// Checks any attribute.\n-    fn check_attributes(\n-        &self,\n-        hir_id: HirId,\n-        attrs: &'hir [Attribute],\n-        span: &Span,\n-        target: Target,\n-        item: Option<&Item<'_>>,\n-    ) {\n-        let mut is_valid = true;\n-        for attr in attrs {\n-            is_valid &= if attr.check_name(sym::inline) {\n-                self.check_inline(hir_id, attr, span, target)\n-            } else if attr.check_name(sym::non_exhaustive) {\n-                self.check_non_exhaustive(attr, span, target)\n-            } else if attr.check_name(sym::marker) {\n-                self.check_marker(attr, span, target)\n-            } else if attr.check_name(sym::target_feature) {\n-                self.check_target_feature(attr, span, target)\n-            } else if attr.check_name(sym::track_caller) {\n-                self.check_track_caller(&attr.span, attrs, span, target)\n-            } else {\n-                true\n-            };\n-        }\n-\n-        if !is_valid {\n-            return;\n-        }\n-\n-        if target == Target::Fn {\n-            self.tcx.codegen_fn_attrs(self.tcx.hir().local_def_id(hir_id));\n-        }\n-\n-        self.check_repr(attrs, span, target, item, hir_id);\n-        self.check_used(attrs, target);\n-    }\n-\n-    /// Checks if an `#[inline]` is applied to a function or a closure. Returns `true` if valid.\n-    fn check_inline(&self, hir_id: HirId, attr: &Attribute, span: &Span, target: Target) -> bool {\n-        match target {\n-            Target::Fn\n-            | Target::Closure\n-            | Target::Method(MethodKind::Trait { body: true })\n-            | Target::Method(MethodKind::Inherent) => true,\n-            Target::Method(MethodKind::Trait { body: false }) | Target::ForeignFn => {\n-                self.tcx\n-                    .struct_span_lint_hir(\n-                        UNUSED_ATTRIBUTES,\n-                        hir_id,\n-                        attr.span,\n-                        \"`#[inline]` is ignored on function prototypes\",\n-                    )\n-                    .emit();\n-                true\n-            }\n-            // FIXME(#65833): We permit associated consts to have an `#[inline]` attribute with\n-            // just a lint, because we previously erroneously allowed it and some crates used it\n-            // accidentally, to to be compatible with crates depending on them, we can't throw an\n-            // error here.\n-            Target::AssocConst => {\n-                self.tcx\n-                    .struct_span_lint_hir(\n-                        UNUSED_ATTRIBUTES,\n-                        hir_id,\n-                        attr.span,\n-                        \"`#[inline]` is ignored on constants\",\n-                    )\n-                    .warn(\n-                        \"this was previously accepted by the compiler but is \\\n-                       being phased out; it will become a hard error in \\\n-                       a future release!\",\n-                    )\n-                    .note(\n-                        \"for more information, see issue #65833 \\\n-                       <https://github.com/rust-lang/rust/issues/65833>\",\n-                    )\n-                    .emit();\n-                true\n-            }\n-            _ => {\n-                struct_span_err!(\n-                    self.tcx.sess,\n-                    attr.span,\n-                    E0518,\n-                    \"attribute should be applied to function or closure\",\n-                )\n-                .span_label(*span, \"not a function or closure\")\n-                .emit();\n-                false\n-            }\n-        }\n-    }\n-\n-    /// Checks if a `#[track_caller]` is applied to a non-naked function. Returns `true` if valid.\n-    fn check_track_caller(\n-        &self,\n-        attr_span: &Span,\n-        attrs: &'hir [Attribute],\n-        span: &Span,\n-        target: Target,\n-    ) -> bool {\n-        match target {\n-            Target::Fn if attr::contains_name(attrs, sym::naked) => {\n-                struct_span_err!(\n-                    self.tcx.sess,\n-                    *attr_span,\n-                    E0736,\n-                    \"cannot use `#[track_caller]` with `#[naked]`\",\n-                )\n-                .emit();\n-                false\n-            }\n-            Target::Fn | Target::Method(MethodKind::Inherent) => true,\n-            Target::Method(_) => {\n-                struct_span_err!(\n-                    self.tcx.sess,\n-                    *attr_span,\n-                    E0738,\n-                    \"`#[track_caller]` may not be used on trait methods\",\n-                )\n-                .emit();\n-                false\n-            }\n-            _ => {\n-                struct_span_err!(\n-                    self.tcx.sess,\n-                    *attr_span,\n-                    E0739,\n-                    \"attribute should be applied to function\"\n-                )\n-                .span_label(*span, \"not a function\")\n-                .emit();\n-                false\n-            }\n-        }\n-    }\n-\n-    /// Checks if the `#[non_exhaustive]` attribute on an `item` is valid. Returns `true` if valid.\n-    fn check_non_exhaustive(&self, attr: &Attribute, span: &Span, target: Target) -> bool {\n-        match target {\n-            Target::Struct | Target::Enum => true,\n-            _ => {\n-                struct_span_err!(\n-                    self.tcx.sess,\n-                    attr.span,\n-                    E0701,\n-                    \"attribute can only be applied to a struct or enum\"\n-                )\n-                .span_label(*span, \"not a struct or enum\")\n-                .emit();\n-                false\n-            }\n-        }\n-    }\n-\n-    /// Checks if the `#[marker]` attribute on an `item` is valid. Returns `true` if valid.\n-    fn check_marker(&self, attr: &Attribute, span: &Span, target: Target) -> bool {\n-        match target {\n-            Target::Trait => true,\n-            _ => {\n-                self.tcx\n-                    .sess\n-                    .struct_span_err(attr.span, \"attribute can only be applied to a trait\")\n-                    .span_label(*span, \"not a trait\")\n-                    .emit();\n-                false\n-            }\n-        }\n-    }\n-\n-    /// Checks if the `#[target_feature]` attribute on `item` is valid. Returns `true` if valid.\n-    fn check_target_feature(&self, attr: &Attribute, span: &Span, target: Target) -> bool {\n-        match target {\n-            Target::Fn\n-            | Target::Method(MethodKind::Trait { body: true })\n-            | Target::Method(MethodKind::Inherent) => true,\n-            _ => {\n-                self.tcx\n-                    .sess\n-                    .struct_span_err(attr.span, \"attribute should be applied to a function\")\n-                    .span_label(*span, \"not a function\")\n-                    .emit();\n-                false\n-            }\n-        }\n-    }\n-\n-    /// Checks if the `#[repr]` attributes on `item` are valid.\n-    fn check_repr(\n-        &self,\n-        attrs: &'hir [Attribute],\n-        span: &Span,\n-        target: Target,\n-        item: Option<&Item<'_>>,\n-        hir_id: HirId,\n-    ) {\n-        // Extract the names of all repr hints, e.g., [foo, bar, align] for:\n-        // ```\n-        // #[repr(foo)]\n-        // #[repr(bar, align(8))]\n-        // ```\n-        let hints: Vec<_> = attrs\n-            .iter()\n-            .filter(|attr| attr.check_name(sym::repr))\n-            .filter_map(|attr| attr.meta_item_list())\n-            .flatten()\n-            .collect();\n-\n-        let mut int_reprs = 0;\n-        let mut is_c = false;\n-        let mut is_simd = false;\n-        let mut is_transparent = false;\n-\n-        for hint in &hints {\n-            let (article, allowed_targets) = match hint.name_or_empty() {\n-                name @ sym::C | name @ sym::align => {\n-                    is_c |= name == sym::C;\n-                    match target {\n-                        Target::Struct | Target::Union | Target::Enum => continue,\n-                        _ => (\"a\", \"struct, enum, or union\"),\n-                    }\n-                }\n-                sym::packed => {\n-                    if target != Target::Struct && target != Target::Union {\n-                        (\"a\", \"struct or union\")\n-                    } else {\n-                        continue;\n-                    }\n-                }\n-                sym::simd => {\n-                    is_simd = true;\n-                    if target != Target::Struct { (\"a\", \"struct\") } else { continue }\n-                }\n-                sym::transparent => {\n-                    is_transparent = true;\n-                    match target {\n-                        Target::Struct | Target::Union | Target::Enum => continue,\n-                        _ => (\"a\", \"struct, enum, or union\"),\n-                    }\n-                }\n-                sym::i8\n-                | sym::u8\n-                | sym::i16\n-                | sym::u16\n-                | sym::i32\n-                | sym::u32\n-                | sym::i64\n-                | sym::u64\n-                | sym::isize\n-                | sym::usize => {\n-                    int_reprs += 1;\n-                    if target != Target::Enum { (\"an\", \"enum\") } else { continue }\n-                }\n-                _ => continue,\n-            };\n-            self.emit_repr_error(\n-                hint.span(),\n-                *span,\n-                &format!(\"attribute should be applied to {}\", allowed_targets),\n-                &format!(\"not {} {}\", article, allowed_targets),\n-            )\n-        }\n-\n-        // Just point at all repr hints if there are any incompatibilities.\n-        // This is not ideal, but tracking precisely which ones are at fault is a huge hassle.\n-        let hint_spans = hints.iter().map(|hint| hint.span());\n-\n-        // Error on repr(transparent, <anything else>).\n-        if is_transparent && hints.len() > 1 {\n-            let hint_spans: Vec<_> = hint_spans.clone().collect();\n-            struct_span_err!(\n-                self.tcx.sess,\n-                hint_spans,\n-                E0692,\n-                \"transparent {} cannot have other repr hints\",\n-                target\n-            )\n-            .emit();\n-        }\n-        // Warn on repr(u8, u16), repr(C, simd), and c-like-enum-repr(C, u8)\n-        if (int_reprs > 1)\n-            || (is_simd && is_c)\n-            || (int_reprs == 1 && is_c && item.map_or(false, |item| is_c_like_enum(item)))\n-        {\n-            self.tcx\n-                .struct_span_lint_hir(\n-                    CONFLICTING_REPR_HINTS,\n-                    hir_id,\n-                    hint_spans.collect::<Vec<Span>>(),\n-                    \"conflicting representation hints\",\n-                )\n-                .code(rustc_errors::error_code!(E0566))\n-                .emit();\n-        }\n-    }\n-\n-    fn emit_repr_error(\n-        &self,\n-        hint_span: Span,\n-        label_span: Span,\n-        hint_message: &str,\n-        label_message: &str,\n-    ) {\n-        struct_span_err!(self.tcx.sess, hint_span, E0517, \"{}\", hint_message)\n-            .span_label(label_span, label_message)\n-            .emit();\n-    }\n-\n-    fn check_stmt_attributes(&self, stmt: &hir::Stmt<'_>) {\n-        // When checking statements ignore expressions, they will be checked later\n-        if let hir::StmtKind::Local(ref l) = stmt.kind {\n-            for attr in l.attrs.iter() {\n-                if attr.check_name(sym::inline) {\n-                    self.check_inline(DUMMY_HIR_ID, attr, &stmt.span, Target::Statement);\n-                }\n-                if attr.check_name(sym::repr) {\n-                    self.emit_repr_error(\n-                        attr.span,\n-                        stmt.span,\n-                        \"attribute should not be applied to a statement\",\n-                        \"not a struct, enum, or union\",\n-                    );\n-                }\n-            }\n-        }\n-    }\n-\n-    fn check_expr_attributes(&self, expr: &hir::Expr<'_>) {\n-        let target = match expr.kind {\n-            hir::ExprKind::Closure(..) => Target::Closure,\n-            _ => Target::Expression,\n-        };\n-        for attr in expr.attrs.iter() {\n-            if attr.check_name(sym::inline) {\n-                self.check_inline(DUMMY_HIR_ID, attr, &expr.span, target);\n-            }\n-            if attr.check_name(sym::repr) {\n-                self.emit_repr_error(\n-                    attr.span,\n-                    expr.span,\n-                    \"attribute should not be applied to an expression\",\n-                    \"not defining a struct, enum, or union\",\n-                );\n-            }\n-        }\n-    }\n-\n-    fn check_used(&self, attrs: &'hir [Attribute], target: Target) {\n-        for attr in attrs {\n-            if attr.check_name(sym::used) && target != Target::Static {\n-                self.tcx\n-                    .sess\n-                    .span_err(attr.span, \"attribute must be applied to a `static` variable\");\n-            }\n-        }\n-    }\n-}\n-\n-impl Visitor<'tcx> for CheckAttrVisitor<'tcx> {\n-    type Map = Map<'tcx>;\n-\n-    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, Self::Map> {\n-        NestedVisitorMap::OnlyBodies(&self.tcx.hir())\n-    }\n-\n-    fn visit_item(&mut self, item: &'tcx Item<'tcx>) {\n-        let target = Target::from_item(item);\n-        self.check_attributes(item.hir_id, item.attrs, &item.span, target, Some(item));\n-        intravisit::walk_item(self, item)\n-    }\n-\n-    fn visit_trait_item(&mut self, trait_item: &'tcx TraitItem<'tcx>) {\n-        let target = Target::from_trait_item(trait_item);\n-        self.check_attributes(trait_item.hir_id, &trait_item.attrs, &trait_item.span, target, None);\n-        intravisit::walk_trait_item(self, trait_item)\n-    }\n-\n-    fn visit_foreign_item(&mut self, f_item: &'tcx hir::ForeignItem<'tcx>) {\n-        let target = Target::from_foreign_item(f_item);\n-        self.check_attributes(f_item.hir_id, &f_item.attrs, &f_item.span, target, None);\n-        intravisit::walk_foreign_item(self, f_item)\n-    }\n-\n-    fn visit_impl_item(&mut self, impl_item: &'tcx hir::ImplItem<'tcx>) {\n-        let target = Target::from_impl_item(self.tcx, impl_item);\n-        self.check_attributes(impl_item.hir_id, &impl_item.attrs, &impl_item.span, target, None);\n-        intravisit::walk_impl_item(self, impl_item)\n-    }\n-\n-    fn visit_stmt(&mut self, stmt: &'tcx hir::Stmt<'tcx>) {\n-        self.check_stmt_attributes(stmt);\n-        intravisit::walk_stmt(self, stmt)\n-    }\n-\n-    fn visit_expr(&mut self, expr: &'tcx hir::Expr<'tcx>) {\n-        self.check_expr_attributes(expr);\n-        intravisit::walk_expr(self, expr)\n-    }\n-}\n-\n-fn is_c_like_enum(item: &Item<'_>) -> bool {\n-    if let ItemKind::Enum(ref def, _) = item.kind {\n-        for variant in def.variants {\n-            match variant.data {\n-                hir::VariantData::Unit(..) => { /* continue */ }\n-                _ => return false,\n-            }\n-        }\n-        true\n-    } else {\n-        false\n-    }\n-}\n-\n-fn check_mod_attrs(tcx: TyCtxt<'_>, module_def_id: DefId) {\n-    tcx.hir()\n-        .visit_item_likes_in_module(module_def_id, &mut CheckAttrVisitor { tcx }.as_deep_visitor());\n-}\n-\n-pub(crate) fn provide(providers: &mut Providers<'_>) {\n-    *providers = Providers { check_mod_attrs, ..*providers };\n }"}, {"sha": "6275c0aabe896829883c90d467a78a4fad10f717", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/dc92dfc50725f21f775c059413e1d06d725daacf/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc92dfc50725f21f775c059413e1d06d725daacf/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=dc92dfc50725f21f775c059413e1d06d725daacf", "patch": "@@ -5,12 +5,9 @@\n pub mod check_attr;\n pub mod exports;\n pub mod map;\n-pub mod upvars;\n \n use crate::ty::query::Providers;\n \n pub fn provide(providers: &mut Providers<'_>) {\n-    check_attr::provide(providers);\n     map::provide(providers);\n-    upvars::provide(providers);\n }"}, {"sha": "3ff1ba3bbfc8c201ff49c22cf511acc04003ec59", "filename": "src/librustc_passes/check_attr.rs", "status": "added", "additions": 471, "deletions": 0, "changes": 471, "blob_url": "https://github.com/rust-lang/rust/blob/dc92dfc50725f21f775c059413e1d06d725daacf/src%2Flibrustc_passes%2Fcheck_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc92dfc50725f21f775c059413e1d06d725daacf/src%2Flibrustc_passes%2Fcheck_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fcheck_attr.rs?ref=dc92dfc50725f21f775c059413e1d06d725daacf", "patch": "@@ -0,0 +1,471 @@\n+//! This module implements some validity checks for attributes.\n+//! In particular it verifies that `#[inline]` and `#[repr]` attributes are\n+//! attached to items that actually support them and if there are\n+//! conflicts between multiple such attributes attached to the same\n+//! item.\n+\n+use rustc::hir::check_attr::{MethodKind, Target};\n+use rustc::hir::map::Map;\n+use rustc::ty::query::Providers;\n+use rustc::ty::TyCtxt;\n+\n+use rustc_errors::struct_span_err;\n+use rustc_hir as hir;\n+use rustc_hir::def_id::DefId;\n+use rustc_hir::intravisit::{self, NestedVisitorMap, Visitor};\n+use rustc_hir::DUMMY_HIR_ID;\n+use rustc_hir::{self, HirId, Item, ItemKind, TraitItem};\n+use rustc_session::lint::builtin::{CONFLICTING_REPR_HINTS, UNUSED_ATTRIBUTES};\n+use rustc_span::symbol::sym;\n+use rustc_span::Span;\n+use syntax::ast::Attribute;\n+use syntax::attr;\n+\n+fn target_from_impl_item<'tcx>(tcx: TyCtxt<'tcx>, impl_item: &hir::ImplItem<'_>) -> Target {\n+    match impl_item.kind {\n+        hir::ImplItemKind::Const(..) => Target::AssocConst,\n+        hir::ImplItemKind::Method(..) => {\n+            let parent_hir_id = tcx.hir().get_parent_item(impl_item.hir_id);\n+            let containing_item = tcx.hir().expect_item(parent_hir_id);\n+            let containing_impl_is_for_trait = match &containing_item.kind {\n+                hir::ItemKind::Impl { ref of_trait, .. } => of_trait.is_some(),\n+                _ => bug!(\"parent of an ImplItem must be an Impl\"),\n+            };\n+            if containing_impl_is_for_trait {\n+                Target::Method(MethodKind::Trait { body: true })\n+            } else {\n+                Target::Method(MethodKind::Inherent)\n+            }\n+        }\n+        hir::ImplItemKind::TyAlias(..) | hir::ImplItemKind::OpaqueTy(..) => Target::AssocTy,\n+    }\n+}\n+\n+struct CheckAttrVisitor<'tcx> {\n+    tcx: TyCtxt<'tcx>,\n+}\n+\n+impl CheckAttrVisitor<'tcx> {\n+    /// Checks any attribute.\n+    fn check_attributes(\n+        &self,\n+        hir_id: HirId,\n+        attrs: &'hir [Attribute],\n+        span: &Span,\n+        target: Target,\n+        item: Option<&Item<'_>>,\n+    ) {\n+        let mut is_valid = true;\n+        for attr in attrs {\n+            is_valid &= if attr.check_name(sym::inline) {\n+                self.check_inline(hir_id, attr, span, target)\n+            } else if attr.check_name(sym::non_exhaustive) {\n+                self.check_non_exhaustive(attr, span, target)\n+            } else if attr.check_name(sym::marker) {\n+                self.check_marker(attr, span, target)\n+            } else if attr.check_name(sym::target_feature) {\n+                self.check_target_feature(attr, span, target)\n+            } else if attr.check_name(sym::track_caller) {\n+                self.check_track_caller(&attr.span, attrs, span, target)\n+            } else {\n+                true\n+            };\n+        }\n+\n+        if !is_valid {\n+            return;\n+        }\n+\n+        if target == Target::Fn {\n+            self.tcx.codegen_fn_attrs(self.tcx.hir().local_def_id(hir_id));\n+        }\n+\n+        self.check_repr(attrs, span, target, item, hir_id);\n+        self.check_used(attrs, target);\n+    }\n+\n+    /// Checks if an `#[inline]` is applied to a function or a closure. Returns `true` if valid.\n+    fn check_inline(&self, hir_id: HirId, attr: &Attribute, span: &Span, target: Target) -> bool {\n+        match target {\n+            Target::Fn\n+            | Target::Closure\n+            | Target::Method(MethodKind::Trait { body: true })\n+            | Target::Method(MethodKind::Inherent) => true,\n+            Target::Method(MethodKind::Trait { body: false }) | Target::ForeignFn => {\n+                self.tcx\n+                    .struct_span_lint_hir(\n+                        UNUSED_ATTRIBUTES,\n+                        hir_id,\n+                        attr.span,\n+                        \"`#[inline]` is ignored on function prototypes\",\n+                    )\n+                    .emit();\n+                true\n+            }\n+            // FIXME(#65833): We permit associated consts to have an `#[inline]` attribute with\n+            // just a lint, because we previously erroneously allowed it and some crates used it\n+            // accidentally, to to be compatible with crates depending on them, we can't throw an\n+            // error here.\n+            Target::AssocConst => {\n+                self.tcx\n+                    .struct_span_lint_hir(\n+                        UNUSED_ATTRIBUTES,\n+                        hir_id,\n+                        attr.span,\n+                        \"`#[inline]` is ignored on constants\",\n+                    )\n+                    .warn(\n+                        \"this was previously accepted by the compiler but is \\\n+                       being phased out; it will become a hard error in \\\n+                       a future release!\",\n+                    )\n+                    .note(\n+                        \"for more information, see issue #65833 \\\n+                       <https://github.com/rust-lang/rust/issues/65833>\",\n+                    )\n+                    .emit();\n+                true\n+            }\n+            _ => {\n+                struct_span_err!(\n+                    self.tcx.sess,\n+                    attr.span,\n+                    E0518,\n+                    \"attribute should be applied to function or closure\",\n+                )\n+                .span_label(*span, \"not a function or closure\")\n+                .emit();\n+                false\n+            }\n+        }\n+    }\n+\n+    /// Checks if a `#[track_caller]` is applied to a non-naked function. Returns `true` if valid.\n+    fn check_track_caller(\n+        &self,\n+        attr_span: &Span,\n+        attrs: &'hir [Attribute],\n+        span: &Span,\n+        target: Target,\n+    ) -> bool {\n+        match target {\n+            Target::Fn if attr::contains_name(attrs, sym::naked) => {\n+                struct_span_err!(\n+                    self.tcx.sess,\n+                    *attr_span,\n+                    E0736,\n+                    \"cannot use `#[track_caller]` with `#[naked]`\",\n+                )\n+                .emit();\n+                false\n+            }\n+            Target::Fn | Target::Method(MethodKind::Inherent) => true,\n+            Target::Method(_) => {\n+                struct_span_err!(\n+                    self.tcx.sess,\n+                    *attr_span,\n+                    E0738,\n+                    \"`#[track_caller]` may not be used on trait methods\",\n+                )\n+                .emit();\n+                false\n+            }\n+            _ => {\n+                struct_span_err!(\n+                    self.tcx.sess,\n+                    *attr_span,\n+                    E0739,\n+                    \"attribute should be applied to function\"\n+                )\n+                .span_label(*span, \"not a function\")\n+                .emit();\n+                false\n+            }\n+        }\n+    }\n+\n+    /// Checks if the `#[non_exhaustive]` attribute on an `item` is valid. Returns `true` if valid.\n+    fn check_non_exhaustive(&self, attr: &Attribute, span: &Span, target: Target) -> bool {\n+        match target {\n+            Target::Struct | Target::Enum => true,\n+            _ => {\n+                struct_span_err!(\n+                    self.tcx.sess,\n+                    attr.span,\n+                    E0701,\n+                    \"attribute can only be applied to a struct or enum\"\n+                )\n+                .span_label(*span, \"not a struct or enum\")\n+                .emit();\n+                false\n+            }\n+        }\n+    }\n+\n+    /// Checks if the `#[marker]` attribute on an `item` is valid. Returns `true` if valid.\n+    fn check_marker(&self, attr: &Attribute, span: &Span, target: Target) -> bool {\n+        match target {\n+            Target::Trait => true,\n+            _ => {\n+                self.tcx\n+                    .sess\n+                    .struct_span_err(attr.span, \"attribute can only be applied to a trait\")\n+                    .span_label(*span, \"not a trait\")\n+                    .emit();\n+                false\n+            }\n+        }\n+    }\n+\n+    /// Checks if the `#[target_feature]` attribute on `item` is valid. Returns `true` if valid.\n+    fn check_target_feature(&self, attr: &Attribute, span: &Span, target: Target) -> bool {\n+        match target {\n+            Target::Fn\n+            | Target::Method(MethodKind::Trait { body: true })\n+            | Target::Method(MethodKind::Inherent) => true,\n+            _ => {\n+                self.tcx\n+                    .sess\n+                    .struct_span_err(attr.span, \"attribute should be applied to a function\")\n+                    .span_label(*span, \"not a function\")\n+                    .emit();\n+                false\n+            }\n+        }\n+    }\n+\n+    /// Checks if the `#[repr]` attributes on `item` are valid.\n+    fn check_repr(\n+        &self,\n+        attrs: &'hir [Attribute],\n+        span: &Span,\n+        target: Target,\n+        item: Option<&Item<'_>>,\n+        hir_id: HirId,\n+    ) {\n+        // Extract the names of all repr hints, e.g., [foo, bar, align] for:\n+        // ```\n+        // #[repr(foo)]\n+        // #[repr(bar, align(8))]\n+        // ```\n+        let hints: Vec<_> = attrs\n+            .iter()\n+            .filter(|attr| attr.check_name(sym::repr))\n+            .filter_map(|attr| attr.meta_item_list())\n+            .flatten()\n+            .collect();\n+\n+        let mut int_reprs = 0;\n+        let mut is_c = false;\n+        let mut is_simd = false;\n+        let mut is_transparent = false;\n+\n+        for hint in &hints {\n+            let (article, allowed_targets) = match hint.name_or_empty() {\n+                name @ sym::C | name @ sym::align => {\n+                    is_c |= name == sym::C;\n+                    match target {\n+                        Target::Struct | Target::Union | Target::Enum => continue,\n+                        _ => (\"a\", \"struct, enum, or union\"),\n+                    }\n+                }\n+                sym::packed => {\n+                    if target != Target::Struct && target != Target::Union {\n+                        (\"a\", \"struct or union\")\n+                    } else {\n+                        continue;\n+                    }\n+                }\n+                sym::simd => {\n+                    is_simd = true;\n+                    if target != Target::Struct { (\"a\", \"struct\") } else { continue }\n+                }\n+                sym::transparent => {\n+                    is_transparent = true;\n+                    match target {\n+                        Target::Struct | Target::Union | Target::Enum => continue,\n+                        _ => (\"a\", \"struct, enum, or union\"),\n+                    }\n+                }\n+                sym::i8\n+                | sym::u8\n+                | sym::i16\n+                | sym::u16\n+                | sym::i32\n+                | sym::u32\n+                | sym::i64\n+                | sym::u64\n+                | sym::isize\n+                | sym::usize => {\n+                    int_reprs += 1;\n+                    if target != Target::Enum { (\"an\", \"enum\") } else { continue }\n+                }\n+                _ => continue,\n+            };\n+            self.emit_repr_error(\n+                hint.span(),\n+                *span,\n+                &format!(\"attribute should be applied to {}\", allowed_targets),\n+                &format!(\"not {} {}\", article, allowed_targets),\n+            )\n+        }\n+\n+        // Just point at all repr hints if there are any incompatibilities.\n+        // This is not ideal, but tracking precisely which ones are at fault is a huge hassle.\n+        let hint_spans = hints.iter().map(|hint| hint.span());\n+\n+        // Error on repr(transparent, <anything else>).\n+        if is_transparent && hints.len() > 1 {\n+            let hint_spans: Vec<_> = hint_spans.clone().collect();\n+            struct_span_err!(\n+                self.tcx.sess,\n+                hint_spans,\n+                E0692,\n+                \"transparent {} cannot have other repr hints\",\n+                target\n+            )\n+            .emit();\n+        }\n+        // Warn on repr(u8, u16), repr(C, simd), and c-like-enum-repr(C, u8)\n+        if (int_reprs > 1)\n+            || (is_simd && is_c)\n+            || (int_reprs == 1 && is_c && item.map_or(false, |item| is_c_like_enum(item)))\n+        {\n+            self.tcx\n+                .struct_span_lint_hir(\n+                    CONFLICTING_REPR_HINTS,\n+                    hir_id,\n+                    hint_spans.collect::<Vec<Span>>(),\n+                    \"conflicting representation hints\",\n+                )\n+                .code(rustc_errors::error_code!(E0566))\n+                .emit();\n+        }\n+    }\n+\n+    fn emit_repr_error(\n+        &self,\n+        hint_span: Span,\n+        label_span: Span,\n+        hint_message: &str,\n+        label_message: &str,\n+    ) {\n+        struct_span_err!(self.tcx.sess, hint_span, E0517, \"{}\", hint_message)\n+            .span_label(label_span, label_message)\n+            .emit();\n+    }\n+\n+    fn check_stmt_attributes(&self, stmt: &hir::Stmt<'_>) {\n+        // When checking statements ignore expressions, they will be checked later\n+        if let hir::StmtKind::Local(ref l) = stmt.kind {\n+            for attr in l.attrs.iter() {\n+                if attr.check_name(sym::inline) {\n+                    self.check_inline(DUMMY_HIR_ID, attr, &stmt.span, Target::Statement);\n+                }\n+                if attr.check_name(sym::repr) {\n+                    self.emit_repr_error(\n+                        attr.span,\n+                        stmt.span,\n+                        \"attribute should not be applied to a statement\",\n+                        \"not a struct, enum, or union\",\n+                    );\n+                }\n+            }\n+        }\n+    }\n+\n+    fn check_expr_attributes(&self, expr: &hir::Expr<'_>) {\n+        let target = match expr.kind {\n+            hir::ExprKind::Closure(..) => Target::Closure,\n+            _ => Target::Expression,\n+        };\n+        for attr in expr.attrs.iter() {\n+            if attr.check_name(sym::inline) {\n+                self.check_inline(DUMMY_HIR_ID, attr, &expr.span, target);\n+            }\n+            if attr.check_name(sym::repr) {\n+                self.emit_repr_error(\n+                    attr.span,\n+                    expr.span,\n+                    \"attribute should not be applied to an expression\",\n+                    \"not defining a struct, enum, or union\",\n+                );\n+            }\n+        }\n+    }\n+\n+    fn check_used(&self, attrs: &'hir [Attribute], target: Target) {\n+        for attr in attrs {\n+            if attr.check_name(sym::used) && target != Target::Static {\n+                self.tcx\n+                    .sess\n+                    .span_err(attr.span, \"attribute must be applied to a `static` variable\");\n+            }\n+        }\n+    }\n+}\n+\n+impl Visitor<'tcx> for CheckAttrVisitor<'tcx> {\n+    type Map = Map<'tcx>;\n+\n+    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, Self::Map> {\n+        NestedVisitorMap::OnlyBodies(&self.tcx.hir())\n+    }\n+\n+    fn visit_item(&mut self, item: &'tcx Item<'tcx>) {\n+        let target = Target::from_item(item);\n+        self.check_attributes(item.hir_id, item.attrs, &item.span, target, Some(item));\n+        intravisit::walk_item(self, item)\n+    }\n+\n+    fn visit_trait_item(&mut self, trait_item: &'tcx TraitItem<'tcx>) {\n+        let target = Target::from_trait_item(trait_item);\n+        self.check_attributes(trait_item.hir_id, &trait_item.attrs, &trait_item.span, target, None);\n+        intravisit::walk_trait_item(self, trait_item)\n+    }\n+\n+    fn visit_foreign_item(&mut self, f_item: &'tcx hir::ForeignItem<'tcx>) {\n+        let target = Target::from_foreign_item(f_item);\n+        self.check_attributes(f_item.hir_id, &f_item.attrs, &f_item.span, target, None);\n+        intravisit::walk_foreign_item(self, f_item)\n+    }\n+\n+    fn visit_impl_item(&mut self, impl_item: &'tcx hir::ImplItem<'tcx>) {\n+        let target = target_from_impl_item(self.tcx, impl_item);\n+        self.check_attributes(impl_item.hir_id, &impl_item.attrs, &impl_item.span, target, None);\n+        intravisit::walk_impl_item(self, impl_item)\n+    }\n+\n+    fn visit_stmt(&mut self, stmt: &'tcx hir::Stmt<'tcx>) {\n+        self.check_stmt_attributes(stmt);\n+        intravisit::walk_stmt(self, stmt)\n+    }\n+\n+    fn visit_expr(&mut self, expr: &'tcx hir::Expr<'tcx>) {\n+        self.check_expr_attributes(expr);\n+        intravisit::walk_expr(self, expr)\n+    }\n+}\n+\n+fn is_c_like_enum(item: &Item<'_>) -> bool {\n+    if let ItemKind::Enum(ref def, _) = item.kind {\n+        for variant in def.variants {\n+            match variant.data {\n+                hir::VariantData::Unit(..) => { /* continue */ }\n+                _ => return false,\n+            }\n+        }\n+        true\n+    } else {\n+        false\n+    }\n+}\n+\n+fn check_mod_attrs(tcx: TyCtxt<'_>, module_def_id: DefId) {\n+    tcx.hir()\n+        .visit_item_likes_in_module(module_def_id, &mut CheckAttrVisitor { tcx }.as_deep_visitor());\n+}\n+\n+pub(crate) fn provide(providers: &mut Providers<'_>) {\n+    *providers = Providers { check_mod_attrs, ..*providers };\n+}"}, {"sha": "4c0fd903db098bc16643f4e2fc39ef5a5fa8b046", "filename": "src/librustc_passes/lib.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dc92dfc50725f21f775c059413e1d06d725daacf/src%2Flibrustc_passes%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc92dfc50725f21f775c059413e1d06d725daacf/src%2Flibrustc_passes%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Flib.rs?ref=dc92dfc50725f21f775c059413e1d06d725daacf", "patch": "@@ -17,6 +17,7 @@ extern crate log;\n \n use rustc::ty::query::Providers;\n \n+mod check_attr;\n mod check_const;\n pub mod dead;\n mod diagnostic_items;\n@@ -30,8 +31,10 @@ pub mod loops;\n mod reachable;\n mod region;\n pub mod stability;\n+mod upvars;\n \n pub fn provide(providers: &mut Providers<'_>) {\n+    check_attr::provide(providers);\n     check_const::provide(providers);\n     diagnostic_items::provide(providers);\n     entry::provide(providers);\n@@ -42,4 +45,5 @@ pub fn provide(providers: &mut Providers<'_>) {\n     reachable::provide(providers);\n     region::provide(providers);\n     stability::provide(providers);\n+    upvars::provide(providers);\n }"}, {"sha": "a2397f273385a531e9c109880a65716da7c09dbb", "filename": "src/librustc_passes/upvars.rs", "status": "renamed", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dc92dfc50725f21f775c059413e1d06d725daacf/src%2Flibrustc_passes%2Fupvars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc92dfc50725f21f775c059413e1d06d725daacf/src%2Flibrustc_passes%2Fupvars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fupvars.rs?ref=dc92dfc50725f21f775c059413e1d06d725daacf", "patch": "@@ -1,8 +1,8 @@\n //! Upvar (closure capture) collection from cross-body HIR uses of `Res::Local`s.\n \n-use crate::hir::map::Map;\n-use crate::ty::query::Providers;\n-use crate::ty::TyCtxt;\n+use rustc::hir::map::Map;\n+use rustc::ty::query::Providers;\n+use rustc::ty::TyCtxt;\n use rustc_data_structures::fx::{FxHashSet, FxIndexMap};\n use rustc_hir as hir;\n use rustc_hir::def::Res;", "previous_filename": "src/librustc/hir/upvars.rs"}]}