{"sha": "0be4e0ec504c02b21f92c257b5de3658962373fe", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBiZTRlMGVjNTA0YzAyYjIxZjkyYzI1N2I1ZGUzNjU4OTYyMzczZmU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-04-11T08:07:34Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-04-11T08:07:34Z"}, "message": "Auto merge of #24155 - chris-chambers:stmt_macros, r=sfackler\n\nStatement macros are now treated somewhat like item macros, in that a statement macro can now expand into a series of statements, rather than just a single statement.\r\n\r\nThis allows statement macros to be nested inside other kinds of macros and expand properly, where previously the expansion would only work when no nesting was present.\r\n\r\nSee:\r\n- `src/test/run-pass/macro-stmt_macro_in_expr_macro.rs`\r\n- `src/test/run-pass/macro-nested_stmt_macro.rs`\r\n\r\nThis changes the interface of the MacResult trait.  make_stmt has become make_stmts and now returns a vector, rather than a single item.  Plugin writers who were implementing MacResult will have breakage, as well as anyone using MacEager::stmt.\r\n\r\nSee:\r\n- `src/libsyntax/ext/base.rs`\r\n\r\nThis also causes a minor difference in behavior to the diagnostics produced by certain malformed macros.\r\n\r\nSee:\r\n- `src/test/compile-fail/macro-incomplete-parse.rs`", "tree": {"sha": "124a9ad41d46449236039893c9e5fe6254bda707", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/124a9ad41d46449236039893c9e5fe6254bda707"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0be4e0ec504c02b21f92c257b5de3658962373fe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0be4e0ec504c02b21f92c257b5de3658962373fe", "html_url": "https://github.com/rust-lang/rust/commit/0be4e0ec504c02b21f92c257b5de3658962373fe", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0be4e0ec504c02b21f92c257b5de3658962373fe/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3a8275397a156b17331e16393e5e1ba89ab4de3f", "url": "https://api.github.com/repos/rust-lang/rust/commits/3a8275397a156b17331e16393e5e1ba89ab4de3f", "html_url": "https://github.com/rust-lang/rust/commit/3a8275397a156b17331e16393e5e1ba89ab4de3f"}, {"sha": "77627ea8dd3b310d02138647363e72fdd024bb6c", "url": "https://api.github.com/repos/rust-lang/rust/commits/77627ea8dd3b310d02138647363e72fdd024bb6c", "html_url": "https://github.com/rust-lang/rust/commit/77627ea8dd3b310d02138647363e72fdd024bb6c"}], "stats": {"total": 196, "additions": 150, "deletions": 46}, "files": [{"sha": "346fb3580e134811f699baf7dfbd50a11c97871d", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 16, "deletions": 14, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/0be4e0ec504c02b21f92c257b5de3658962373fe/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0be4e0ec504c02b21f92c257b5de3658962373fe/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=0be4e0ec504c02b21f92c257b5de3658962373fe", "patch": "@@ -208,10 +208,11 @@ impl<F> IdentMacroExpander for F\n }\n \n // Use a macro because forwarding to a simple function has type system issues\n-macro_rules! make_stmt_default {\n+macro_rules! make_stmts_default {\n     ($me:expr) => {\n         $me.make_expr().map(|e| {\n-            P(codemap::respan(e.span, ast::StmtExpr(e, ast::DUMMY_NODE_ID)))\n+            SmallVector::one(P(codemap::respan(\n+                e.span, ast::StmtExpr(e, ast::DUMMY_NODE_ID))))\n         })\n     }\n }\n@@ -238,12 +239,12 @@ pub trait MacResult {\n         None\n     }\n \n-    /// Create a statement.\n+    /// Create zero or more statements.\n     ///\n     /// By default this attempts to create an expression statement,\n     /// returning None if that fails.\n-    fn make_stmt(self: Box<Self>) -> Option<P<ast::Stmt>> {\n-        make_stmt_default!(self)\n+    fn make_stmts(self: Box<Self>) -> Option<SmallVector<P<ast::Stmt>>> {\n+        make_stmts_default!(self)\n     }\n }\n \n@@ -276,7 +277,7 @@ make_MacEager! {\n     pat: P<ast::Pat>,\n     items: SmallVector<P<ast::Item>>,\n     impl_items: SmallVector<P<ast::ImplItem>>,\n-    stmt: P<ast::Stmt>,\n+    stmts: SmallVector<P<ast::Stmt>>,\n }\n \n impl MacResult for MacEager {\n@@ -292,10 +293,10 @@ impl MacResult for MacEager {\n         self.impl_items\n     }\n \n-    fn make_stmt(self: Box<Self>) -> Option<P<ast::Stmt>> {\n-        match self.stmt {\n-            None => make_stmt_default!(self),\n-            s => s,\n+    fn make_stmts(self: Box<Self>) -> Option<SmallVector<P<ast::Stmt>>> {\n+        match self.stmts.as_ref().map_or(0, |s| s.len()) {\n+            0 => make_stmts_default!(self),\n+            _ => self.stmts,\n         }\n     }\n \n@@ -384,10 +385,11 @@ impl MacResult for DummyResult {\n             Some(SmallVector::zero())\n         }\n     }\n-    fn make_stmt(self: Box<DummyResult>) -> Option<P<ast::Stmt>> {\n-        Some(P(codemap::respan(self.span,\n-                               ast::StmtExpr(DummyResult::raw_expr(self.span),\n-                                             ast::DUMMY_NODE_ID))))\n+    fn make_stmts(self: Box<DummyResult>) -> Option<SmallVector<P<ast::Stmt>>> {\n+        Some(SmallVector::one(P(\n+            codemap::respan(self.span,\n+                            ast::StmtExpr(DummyResult::raw_expr(self.span),\n+                                          ast::DUMMY_NODE_ID)))))\n     }\n }\n "}, {"sha": "5f4ec01791c88506ec04ec3c6167761cc9a77294", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 39, "deletions": 27, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/0be4e0ec504c02b21f92c257b5de3658962373fe/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0be4e0ec504c02b21f92c257b5de3658962373fe/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=0be4e0ec504c02b21f92c257b5de3658962373fe", "patch": "@@ -720,37 +720,49 @@ pub fn expand_item_mac(it: P<ast::Item>,\n }\n \n /// Expand a stmt\n-fn expand_stmt(s: Stmt, fld: &mut MacroExpander) -> SmallVector<P<Stmt>> {\n-    let (mac, style) = match s.node {\n+fn expand_stmt(stmt: P<Stmt>, fld: &mut MacroExpander) -> SmallVector<P<Stmt>> {\n+    let stmt = stmt.and_then(|stmt| stmt);\n+    let (mac, style) = match stmt.node {\n         StmtMac(mac, style) => (mac, style),\n-        _ => return expand_non_macro_stmt(s, fld)\n+        _ => return expand_non_macro_stmt(stmt, fld)\n     };\n-    let expanded_stmt = match expand_mac_invoc(mac.and_then(|m| m), s.span,\n-                                                |r| r.make_stmt(),\n-                                                mark_stmt, fld) {\n-        Some(stmt) => stmt,\n-        None => {\n-            return SmallVector::zero();\n+\n+    let maybe_new_items =\n+        expand_mac_invoc(mac.and_then(|m| m), stmt.span,\n+                         |r| r.make_stmts(),\n+                         |stmts, mark| stmts.move_map(|m| mark_stmt(m, mark)),\n+                         fld);\n+\n+    let mut fully_expanded = match maybe_new_items {\n+        Some(stmts) => {\n+            // Keep going, outside-in.\n+            let new_items = stmts.into_iter().flat_map(|s| {\n+                fld.fold_stmt(s).into_iter()\n+            }).collect();\n+            fld.cx.bt_pop();\n+            new_items\n         }\n+        None => SmallVector::zero()\n     };\n \n-    // Keep going, outside-in.\n-    let fully_expanded = fld.fold_stmt(expanded_stmt);\n-    fld.cx.bt_pop();\n-\n+    // If this is a macro invocation with a semicolon, then apply that\n+    // semicolon to the final statement produced by expansion.\n     if style == MacStmtWithSemicolon {\n-        fully_expanded.into_iter().map(|s| s.map(|Spanned {node, span}| {\n-            Spanned {\n-                node: match node {\n-                    StmtExpr(e, stmt_id) => StmtSemi(e, stmt_id),\n-                    _ => node /* might already have a semi */\n-                },\n-                span: span\n-            }\n-        })).collect()\n-    } else {\n-        fully_expanded\n+        if let Some(stmt) = fully_expanded.pop() {\n+            let new_stmt = stmt.map(|Spanned {node, span}| {\n+                Spanned {\n+                    node: match node {\n+                        StmtExpr(e, stmt_id) => StmtSemi(e, stmt_id),\n+                        _ => node /* might already have a semi */\n+                    },\n+                    span: span\n+                }\n+            });\n+            fully_expanded.push(new_stmt);\n+        }\n     }\n+\n+    fully_expanded\n }\n \n // expand a non-macro stmt. this is essentially the fallthrough for\n@@ -1355,7 +1367,7 @@ impl<'a, 'b> Folder for MacroExpander<'a, 'b> {\n     }\n \n     fn fold_stmt(&mut self, stmt: P<ast::Stmt>) -> SmallVector<P<ast::Stmt>> {\n-        stmt.and_then(|stmt| expand_stmt(stmt, self))\n+        expand_stmt(stmt, self)\n     }\n \n     fn fold_block(&mut self, block: P<Block>) -> P<Block> {\n@@ -1502,8 +1514,8 @@ fn mark_pat(pat: P<ast::Pat>, m: Mrk) -> P<ast::Pat> {\n }\n \n // apply a given mark to the given stmt. Used following the expansion of a macro.\n-fn mark_stmt(expr: P<ast::Stmt>, m: Mrk) -> P<ast::Stmt> {\n-    Marker{mark:m}.fold_stmt(expr)\n+fn mark_stmt(stmt: P<ast::Stmt>, m: Mrk) -> P<ast::Stmt> {\n+    Marker{mark:m}.fold_stmt(stmt)\n         .expect_one(\"marking a stmt didn't return exactly one stmt\")\n }\n "}, {"sha": "730da6cc59419f3ea71566d1edf2b36fe9ecb711", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 18, "deletions": 4, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/0be4e0ec504c02b21f92c257b5de3658962373fe/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0be4e0ec504c02b21f92c257b5de3658962373fe/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=0be4e0ec504c02b21f92c257b5de3658962373fe", "patch": "@@ -99,10 +99,24 @@ impl<'a> MacResult for ParserAnyMacro<'a> {\n         Some(ret)\n     }\n \n-    fn make_stmt(self: Box<ParserAnyMacro<'a>>) -> Option<P<ast::Stmt>> {\n-        let ret = self.parser.borrow_mut().parse_stmt();\n-        self.ensure_complete_parse(true);\n-        ret\n+    fn make_stmts(self: Box<ParserAnyMacro<'a>>)\n+                 -> Option<SmallVector<P<ast::Stmt>>> {\n+        let mut ret = SmallVector::zero();\n+        loop {\n+            let mut parser = self.parser.borrow_mut();\n+            match parser.token {\n+                token::Eof => break,\n+                _ => match parser.parse_stmt_nopanic() {\n+                    Ok(maybe_stmt) => match maybe_stmt {\n+                        Some(stmt) => ret.push(stmt),\n+                        None => (),\n+                    },\n+                    Err(_) => break,\n+                }\n+            }\n+        }\n+        self.ensure_complete_parse(false);\n+        Some(ret)\n     }\n }\n "}, {"sha": "6b864d5294766fabffa4448c4440f997c32d6d22", "filename": "src/libsyntax/util/small_vector.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0be4e0ec504c02b21f92c257b5de3658962373fe/src%2Flibsyntax%2Futil%2Fsmall_vector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0be4e0ec504c02b21f92c257b5de3658962373fe/src%2Flibsyntax%2Futil%2Fsmall_vector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Fsmall_vector.rs?ref=0be4e0ec504c02b21f92c257b5de3658962373fe", "patch": "@@ -69,6 +69,20 @@ impl<T> SmallVector<T> {\n         }\n     }\n \n+    pub fn pop(&mut self) -> Option<T> {\n+        match self.repr {\n+            Zero => None,\n+            One(..) => {\n+                let one = mem::replace(&mut self.repr, Zero);\n+                match one {\n+                    One(v1) => Some(v1),\n+                    _ => unreachable!()\n+                }\n+            }\n+            Many(ref mut vs) => vs.pop(),\n+        }\n+    }\n+\n     pub fn push(&mut self, v: T) {\n         match self.repr {\n             Zero => self.repr = One(v),"}, {"sha": "32770d9018938b96da18a91a61abc5beeb0e8330", "filename": "src/test/compile-fail/macro-incomplete-parse.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0be4e0ec504c02b21f92c257b5de3658962373fe/src%2Ftest%2Fcompile-fail%2Fmacro-incomplete-parse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0be4e0ec504c02b21f92c257b5de3658962373fe/src%2Ftest%2Fcompile-fail%2Fmacro-incomplete-parse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmacro-incomplete-parse.rs?ref=0be4e0ec504c02b21f92c257b5de3658962373fe", "patch": "@@ -17,7 +17,8 @@ macro_rules! ignored_item {\n }\n \n macro_rules! ignored_expr {\n-    () => ( 1, 2 ) //~ ERROR macro expansion ignores token `,`\n+    () => ( 1,  //~ ERROR unexpected token: `,`\n+            2 ) //~ ERROR macro expansion ignores token `2`\n }\n \n macro_rules! ignored_pat {"}, {"sha": "5997a4f18e760c9253c7eaa8332812899a8ecb48", "filename": "src/test/run-pass/macro-nested_stmt_macros.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/0be4e0ec504c02b21f92c257b5de3658962373fe/src%2Ftest%2Frun-pass%2Fmacro-nested_stmt_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0be4e0ec504c02b21f92c257b5de3658962373fe/src%2Ftest%2Frun-pass%2Fmacro-nested_stmt_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmacro-nested_stmt_macros.rs?ref=0be4e0ec504c02b21f92c257b5de3658962373fe", "patch": "@@ -0,0 +1,32 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+macro_rules! foo {\n+    () => {\n+        struct Bar;\n+        struct Baz;\n+    }\n+}\n+\n+macro_rules! grault {\n+    () => {\n+        foo!();\n+        struct Xyzzy;\n+    }\n+}\n+\n+fn static_assert_exists<T>() { }\n+\n+fn main() {\n+    grault!();\n+    static_assert_exists::<Bar>();\n+    static_assert_exists::<Baz>();\n+    static_assert_exists::<Xyzzy>();\n+}"}, {"sha": "c5badd78a6371ca9a3b6644c71d4be8a07e6408e", "filename": "src/test/run-pass/macro-stmt_macro_in_expr_macro.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/0be4e0ec504c02b21f92c257b5de3658962373fe/src%2Ftest%2Frun-pass%2Fmacro-stmt_macro_in_expr_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0be4e0ec504c02b21f92c257b5de3658962373fe/src%2Ftest%2Frun-pass%2Fmacro-stmt_macro_in_expr_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmacro-stmt_macro_in_expr_macro.rs?ref=0be4e0ec504c02b21f92c257b5de3658962373fe", "patch": "@@ -0,0 +1,29 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+macro_rules! foo {\n+    () => {\n+        struct Bar;\n+        struct Baz;\n+    }\n+}\n+\n+macro_rules! grault {\n+    () => {{\n+        foo!();\n+        struct Xyzzy;\n+        0\n+    }}\n+}\n+\n+fn main() {\n+    let x = grault!();\n+    assert_eq!(x, 0);\n+}"}]}