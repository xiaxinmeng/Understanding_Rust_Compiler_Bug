{"sha": "a63e0e47f0d4fa6b79365c645d6c284de234e2d0", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE2M2UwZTQ3ZjBkNGZhNmI3OTM2NWM2NDVkNmMyODRkZTIzNGUyZDA=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2012-07-24T19:35:34Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2012-07-24T19:35:52Z"}, "message": "Update some str functions to slices, merge as_buf and unpack_slice.", "tree": {"sha": "e897ee8d81a8524fc75e82871b7aee7ab748e144", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e897ee8d81a8524fc75e82871b7aee7ab748e144"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a63e0e47f0d4fa6b79365c645d6c284de234e2d0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a63e0e47f0d4fa6b79365c645d6c284de234e2d0", "html_url": "https://github.com/rust-lang/rust/commit/a63e0e47f0d4fa6b79365c645d6c284de234e2d0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a63e0e47f0d4fa6b79365c645d6c284de234e2d0/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ae094a7adc8e0f166ea2b137c2940afdb9396bcd", "url": "https://api.github.com/repos/rust-lang/rust/commits/ae094a7adc8e0f166ea2b137c2940afdb9396bcd", "html_url": "https://github.com/rust-lang/rust/commit/ae094a7adc8e0f166ea2b137c2940afdb9396bcd"}], "stats": {"total": 289, "additions": 135, "deletions": 154}, "files": [{"sha": "a4bd25e5b9d686b8ee62021e4991c60197afb61b", "filename": "src/libcore/comm.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a63e0e47f0d4fa6b79365c645d6c284de234e2d0/src%2Flibcore%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a63e0e47f0d4fa6b79365c645d6c284de234e2d0/src%2Flibcore%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcomm.rs?ref=a63e0e47f0d4fa6b79365c645d6c284de234e2d0", "patch": "@@ -221,14 +221,13 @@ fn peek_(p: *rust_port) -> bool {\n fn select2<A: send, B: send>(p_a: port<A>, p_b: port<B>)\n     -> either<A, B> {\n     let ports = ~[(**p_a).po, (**p_b).po];\n-    let n_ports = 2 as libc::size_t;\n     let yield = 0u, yieldp = ptr::addr_of(yield);\n \n     let mut resport: *rust_port;\n     resport = rusti::init::<*rust_port>();\n-    do vec::as_buf(ports) |ports| {\n-        rustrt::rust_port_select(ptr::addr_of(resport), ports, n_ports,\n-                                 yieldp);\n+    do vec::as_buf(ports) |ports, n_ports| {\n+        rustrt::rust_port_select(ptr::addr_of(resport), ports,\n+                                 n_ports as size_t, yieldp);\n     }\n \n     if yield != 0u {"}, {"sha": "02ce125e35cfeab12daa243e382aa9f89300c9fa", "filename": "src/libcore/int-template.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a63e0e47f0d4fa6b79365c645d6c284de234e2d0/src%2Flibcore%2Fint-template.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a63e0e47f0d4fa6b79365c645d6c284de234e2d0/src%2Flibcore%2Fint-template.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fint-template.rs?ref=a63e0e47f0d4fa6b79365c645d6c284de234e2d0", "patch": "@@ -94,7 +94,7 @@ fn from_str(s: ~str) -> option<T> { parse_buf(str::bytes(s), 10u) }\n /// Convert to a string in a given base\n fn to_str(n: T, radix: uint) -> ~str {\n     do to_str_bytes(n, radix) |slice| {\n-        do vec::unpack_slice(slice) |p, len| {\n+        do vec::as_buf(slice) |p, len| {\n             unsafe { str::unsafe::from_buf_len(p, len) }\n         }\n     }"}, {"sha": "25d1b5e66805a6ee86b60ec72973a621a96847e2", "filename": "src/libcore/io.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a63e0e47f0d4fa6b79365c645d6c284de234e2d0/src%2Flibcore%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a63e0e47f0d4fa6b79365c645d6c284de234e2d0/src%2Flibcore%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fio.rs?ref=a63e0e47f0d4fa6b79365c645d6c284de234e2d0", "patch": "@@ -205,7 +205,7 @@ fn convert_whence(whence: seek_style) -> i32 {\n \n impl of reader for *libc::FILE {\n     fn read(buf: &[mut u8], len: uint) -> uint {\n-        do vec::unpack_slice(buf) |buf_p, buf_len| {\n+        do vec::as_buf(buf) |buf_p, buf_len| {\n             assert buf_len <= len;\n \n             let count = libc::fread(buf_p as *mut c_void, 1u as size_t,\n@@ -348,7 +348,7 @@ impl <T: writer, C> of writer for {base: T, cleanup: C} {\n \n impl of writer for *libc::FILE {\n     fn write(v: &[const u8]) {\n-        do vec::unpack_const_slice(v) |vbuf, len| {\n+        do vec::as_const_buf(v) |vbuf, len| {\n             let nout = libc::fwrite(vbuf as *c_void, len as size_t,\n                                     1u as size_t, self);\n             if nout < 1 as size_t {\n@@ -377,7 +377,7 @@ fn FILE_writer(f: *libc::FILE, cleanup: bool) -> writer {\n impl of writer for fd_t {\n     fn write(v: &[const u8]) {\n         let mut count = 0u;\n-        do vec::unpack_const_slice(v) |vbuf, len| {\n+        do vec::as_const_buf(v) |vbuf, len| {\n             while count < len {\n                 let vb = ptr::const_offset(vbuf, count) as *c_void;\n                 let nout = libc::write(self, vb, len as size_t);"}, {"sha": "6cfb18dc644cc72cbf04fb92ab740908e197b27e", "filename": "src/libcore/option.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a63e0e47f0d4fa6b79365c645d6c284de234e2d0/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a63e0e47f0d4fa6b79365c645d6c284de234e2d0/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=a63e0e47f0d4fa6b79365c645d6c284de234e2d0", "patch": "@@ -175,10 +175,10 @@ fn test_unwrap_ptr() {\n #[test]\n fn test_unwrap_str() {\n     let x = ~\"test\";\n-    let addr_x = str::as_buf(x, |buf| ptr::addr_of(buf));\n+    let addr_x = str::as_buf(x, |buf, _len| ptr::addr_of(buf));\n     let opt = some(x);\n     let y = unwrap(opt);\n-    let addr_y = str::as_buf(y, |buf| ptr::addr_of(buf));\n+    let addr_y = str::as_buf(y, |buf, _len| ptr::addr_of(buf));\n     assert addr_x == addr_y;\n }\n "}, {"sha": "d068841bc53136d5b5732fd7db657f7356b83fb4", "filename": "src/libcore/os.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a63e0e47f0d4fa6b79365c645d6c284de234e2d0/src%2Flibcore%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a63e0e47f0d4fa6b79365c645d6c284de234e2d0/src%2Flibcore%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fos.rs?ref=a63e0e47f0d4fa6b79365c645d6c284de234e2d0", "patch": "@@ -71,8 +71,8 @@ fn as_c_charp<T>(s: ~str, f: fn(*c_char) -> T) -> T {\n fn fill_charp_buf(f: fn(*mut c_char, size_t) -> bool)\n     -> option<~str> {\n     let buf = vec::to_mut(vec::from_elem(tmpbuf_sz, 0u8 as c_char));\n-    do vec::as_mut_buf(buf) |b| {\n-        if f(b, tmpbuf_sz as size_t) unsafe {\n+    do vec::as_mut_buf(buf) |b, sz| {\n+        if f(b, sz as size_t) unsafe {\n             some(str::unsafe::from_buf(b as *u8))\n         } else {\n             none\n@@ -667,7 +667,7 @@ fn copy_file(from: path, to: path) -> bool {\n         let mut done = false;\n         let mut ok = true;\n         while !done {\n-            do vec::as_mut_buf(buf) |b| {\n+            do vec::as_mut_buf(buf) |b, _sz| {\n               let nread = libc::fread(b as *mut c_void, 1u as size_t,\n                                       bufsize as size_t,\n                                       istream);\n@@ -970,7 +970,7 @@ mod tests {\n       assert (ostream as uint != 0u);\n       let s = ~\"hello\";\n       let mut buf = vec::to_mut(str::bytes(s) + ~[0 as u8]);\n-      do vec::as_mut_buf(buf) |b| {\n+      do vec::as_mut_buf(buf) |b, _len| {\n           assert (libc::fwrite(b as *c_void, 1u as size_t,\n                                (str::len(s) + 1u) as size_t, ostream)\n                   == buf.len() as size_t)};"}, {"sha": "e1d21b826a542838e3be745d847b389742143df7", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a63e0e47f0d4fa6b79365c645d6c284de234e2d0/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a63e0e47f0d4fa6b79365c645d6c284de234e2d0/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=a63e0e47f0d4fa6b79365c645d6c284de234e2d0", "patch": "@@ -192,8 +192,9 @@ fn test_buf_len() {\n         do str::as_c_str(s1) |p1| {\n             do str::as_c_str(s2) |p2| {\n                 let v = ~[p0, p1, p2, null()];\n-                do vec::as_buf(v) |vp| {\n+                do vec::as_buf(v) |vp, len| {\n                     assert unsafe { buf_len(vp) } == 3u;\n+                    assert len == 4u;\n                 }\n             }\n         }"}, {"sha": "9f3da067253678d4362b3f4115e1650206bc12c1", "filename": "src/libcore/run.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a63e0e47f0d4fa6b79365c645d6c284de234e2d0/src%2Flibcore%2Frun.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a63e0e47f0d4fa6b79365c645d6c284de234e2d0/src%2Flibcore%2Frun.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frun.rs?ref=a63e0e47f0d4fa6b79365c645d6c284de234e2d0", "patch": "@@ -88,7 +88,7 @@ fn with_argv<T>(prog: ~str, args: ~[~str],\n         vec::push_all(argptrs, str::as_c_str(*t, |b| ~[b]));\n     }\n     vec::push(argptrs, ptr::null());\n-    vec::as_buf(argptrs, cb)\n+    vec::as_buf(argptrs, |buf, _len| cb(buf))\n }\n \n #[cfg(unix)]\n@@ -108,7 +108,7 @@ fn with_envp<T>(env: option<~[(~str,~str)]>,\n             vec::push_all(ptrs, str::as_c_str(*t, |b| ~[b]));\n         }\n         vec::push(ptrs, ptr::null());\n-        vec::as_buf(ptrs, |p|\n+        vec::as_buf(ptrs, |p, _len|\n             unsafe { cb(::unsafe::reinterpret_cast(p)) }\n         )\n       }"}, {"sha": "0cf0b4fbbf93bbf67b513d77247d005777dd1340", "filename": "src/libcore/str.rs", "status": "modified", "additions": 70, "deletions": 77, "changes": 147, "blob_url": "https://github.com/rust-lang/rust/blob/a63e0e47f0d4fa6b79365c645d6c284de234e2d0/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a63e0e47f0d4fa6b79365c645d6c284de234e2d0/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=a63e0e47f0d4fa6b79365c645d6c284de234e2d0", "patch": "@@ -23,7 +23,6 @@ export\n    as_bytes,\n    as_buf,\n    as_c_str,\n-   unpack_slice,\n \n    // Adding things to and removing things from a string\n    push_str_no_overallocate,\n@@ -127,11 +126,16 @@ Section: Creating a string\n  *\n  * Fails if invalid UTF-8\n  */\n-pure fn from_bytes(+vv: ~[u8]) -> ~str {\n+pure fn from_bytes(vv: &[const u8]) -> ~str {\n     assert is_utf8(vv);\n     ret unsafe { unsafe::from_bytes(vv) };\n }\n \n+/// Copy a slice into a new unique str\n+pure fn from_slice(s: &str) -> ~str {\n+    unsafe { unsafe::slice_bytes(s, 0, len(s)) }\n+}\n+\n /**\n  * Convert a byte to a UTF-8 string\n  *\n@@ -159,7 +163,7 @@ fn push_char(&s: ~str, ch: char) {\n         let new_len = len + nb;\n         reserve_at_least(s, new_len);\n         let off = len;\n-        do as_buf(s) |buf| {\n+        do as_buf(s) |buf, _len| {\n             let buf: *mut u8 = ::unsafe::reinterpret_cast(buf);\n             if nb == 1u {\n                 *ptr::mut_offset(buf, off) =\n@@ -245,8 +249,8 @@ fn push_str_no_overallocate(&lhs: ~str, rhs: &str) {\n         let llen = lhs.len();\n         let rlen = rhs.len();\n         reserve(lhs, llen + rlen);\n-        do as_buf(lhs) |lbuf| {\n-            do unpack_slice(rhs) |rbuf, _rlen| {\n+        do as_buf(lhs) |lbuf, _llen| {\n+            do as_buf(rhs) |rbuf, _rlen| {\n                 let dst = ptr::offset(lbuf, llen);\n                 ptr::memcpy(dst, rbuf, rlen);\n             }\n@@ -261,8 +265,8 @@ fn push_str(&lhs: ~str, rhs: &str) {\n         let llen = lhs.len();\n         let rlen = rhs.len();\n         reserve_at_least(lhs, llen + rlen);\n-        do as_buf(lhs) |lbuf| {\n-            do unpack_slice(rhs) |rbuf, _rlen| {\n+        do as_buf(lhs) |lbuf, _llen| {\n+            do as_buf(rhs) |rbuf, _rlen| {\n                 let dst = ptr::offset(lbuf, llen);\n                 ptr::memcpy(dst, rbuf, rlen);\n             }\n@@ -290,7 +294,7 @@ pure fn concat(v: &[~str]) -> ~str {\n }\n \n /// Concatenate a vector of strings, placing a given separator between each\n-pure fn connect(v: &[~str], sep: ~str) -> ~str {\n+pure fn connect(v: &[~str], sep: &str) -> ~str {\n     let mut s = ~\"\", first = true;\n     for vec::each(v) |ss| {\n         if first { first = false; } else { unchecked { push_str(s, sep); } }\n@@ -335,30 +339,28 @@ fn shift_char(&s: ~str) -> char {\n fn unshift_char(&s: ~str, ch: char) { s = from_char(ch) + s; }\n \n /// Returns a string with leading whitespace removed\n-pure fn trim_left(+s: ~str) -> ~str {\n+pure fn trim_left(s: &str) -> ~str {\n     alt find(s, |c| !char::is_whitespace(c)) {\n       none { ~\"\" }\n       some(first) {\n-        if first == 0u { s }\n-        else unsafe { unsafe::slice_bytes(s, first, len(s)) }\n+        unsafe { unsafe::slice_bytes(s, first, len(s)) }\n       }\n     }\n }\n \n /// Returns a string with trailing whitespace removed\n-pure fn trim_right(+s: ~str) -> ~str {\n+pure fn trim_right(s: &str) -> ~str {\n     alt rfind(s, |c| !char::is_whitespace(c)) {\n       none { ~\"\" }\n       some(last) {\n         let {next, _} = char_range_at(s, last);\n-        if next == len(s) { s }\n-        else unsafe { unsafe::slice_bytes(s, 0u, next) }\n+        unsafe { unsafe::slice_bytes(s, 0u, next) }\n       }\n     }\n }\n \n /// Returns a string with leading and trailing whitespace removed\n-pure fn trim(+s: ~str) -> ~str { trim_left(trim_right(s)) }\n+pure fn trim(s: &str) -> ~str { trim_left(trim_right(s)) }\n \n /*\n Section: Transforming strings\n@@ -369,9 +371,9 @@ Section: Transforming strings\n  *\n  * The result vector is not null-terminated.\n  */\n-pure fn bytes(s: ~str) -> ~[u8] {\n+pure fn bytes(s: &str) -> ~[u8] {\n     unsafe {\n-        let mut s_copy = s;\n+        let mut s_copy = from_slice(s);\n         let mut v: ~[u8] = ::unsafe::transmute(s_copy);\n         vec::unsafe::set_len(v, len(s));\n         ret v;\n@@ -381,7 +383,7 @@ pure fn bytes(s: ~str) -> ~[u8] {\n /// Work with the string as a byte slice, not including trailing null.\n #[inline(always)]\n pure fn byte_slice<T>(s: &str, f: fn(v: &[u8]) -> T) -> T {\n-    do unpack_slice(s) |p,n| {\n+    do as_buf(s) |p,n| {\n         unsafe { vec::unsafe::form_slice(p, n-1u, f) }\n     }\n }\n@@ -622,7 +624,7 @@ pure fn to_upper(s: &str) -> ~str {\n  *\n  * The original string with all occurances of `from` replaced with `to`\n  */\n-pure fn replace(s: ~str, from: ~str, to: ~str) -> ~str {\n+pure fn replace(s: &str, from: &str, to: &str) -> ~str {\n     let mut result = ~\"\", first = true;\n     do iter_between_matches(s, from) |start, end| {\n         if first { first = false; } else { unchecked {push_str(result, to); }}\n@@ -1277,7 +1279,7 @@ fn is_alphanumeric(s: &str) -> bool {\n \n /// Returns the string length/size in bytes not counting the null terminator\n pure fn len(s: &str) -> uint {\n-    do unpack_slice(s) |_p, n| { n - 1u }\n+    do as_buf(s) |_p, n| { n - 1u }\n }\n \n /// Returns the number of characters that a string holds\n@@ -1288,7 +1290,7 @@ Section: Misc\n */\n \n /// Determines if a vector of bytes contains valid UTF-8\n-pure fn is_utf8(v: &[u8]) -> bool {\n+pure fn is_utf8(v: &[const u8]) -> bool {\n     let mut i = 0u;\n     let total = vec::len::<u8>(v);\n     while i < total {\n@@ -1636,43 +1638,44 @@ pure fn as_bytes<T>(s: ~str, f: fn(~[u8]) -> T) -> T {\n     }\n }\n \n-/**\n- * Work with the byte buffer of a string.\n- *\n- * Allows for unsafe manipulation of strings, which is useful for foreign\n- * interop.\n- */\n-pure fn as_buf<T>(s: ~str, f: fn(*u8) -> T) -> T {\n-    as_bytes(s, |v| unsafe { vec::as_buf(v, f) })\n-}\n-\n /**\n  * Work with the byte buffer of a string as a null-terminated C string.\n  *\n  * Allows for unsafe manipulation of strings, which is useful for foreign\n- * interop, without copying the original string.\n+ * interop. This is similar to `str::as_buf`, but guarantees null-termination.\n+ * If the given slice is not already null-terminated, this function will\n+ * allocate a temporary, copy the slice, null terminate it, and pass\n+ * that instead.\n  *\n  * # Example\n  *\n  * ~~~\n- * let s = str::as_buf(\"PATH\", { |path_buf| libc::getenv(path_buf) });\n+ * let s = str::as_c_str(\"PATH\", { |path| libc::getenv(path) });\n  * ~~~\n  */\n-pure fn as_c_str<T>(s: ~str, f: fn(*libc::c_char) -> T) -> T {\n-    as_buf(s, |buf| f(buf as *libc::c_char))\n+pure fn as_c_str<T>(s: &str, f: fn(*libc::c_char) -> T) -> T {\n+    do as_buf(s) |buf, len| {\n+        // NB: len includes the trailing null.\n+        assert len > 0;\n+        if unsafe { *(ptr::offset(buf,len-1)) != 0 } {\n+            as_c_str(from_slice(s), f)\n+        } else {\n+            f(buf as *libc::c_char)\n+        }\n+    }\n }\n \n \n /**\n  * Work with the byte buffer and length of a slice.\n  *\n- * The unpacked length is one byte longer than the 'official' indexable\n+ * The given length is one byte longer than the 'official' indexable\n  * length of the string. This is to permit probing the byte past the\n  * indexable area for a null byte, as is the case in slices pointing\n  * to full strings, or suffixes of them.\n  */\n #[inline(always)]\n-pure fn unpack_slice<T>(s: &str, f: fn(*u8, uint) -> T) -> T {\n+pure fn as_buf<T>(s: &str, f: fn(*u8, uint) -> T) -> T {\n     unsafe {\n         let v : *(*u8,uint) = ::unsafe::reinterpret_cast(ptr::addr_of(s));\n         let (buf,len) = *v;\n@@ -1783,10 +1786,10 @@ mod unsafe {\n     }\n \n     /// Create a Rust string from a *u8 buffer of the given length\n-    unsafe fn from_buf_len(buf: *u8, len: uint) -> ~str {\n-        let mut v: ~[u8] = ~[];\n+    unsafe fn from_buf_len(buf: *const u8, len: uint) -> ~str {\n+        let mut v: ~[mut u8] = ~[mut];\n         vec::reserve(v, len + 1u);\n-        vec::as_buf(v, |b| ptr::memcpy(b, buf, len));\n+        vec::as_buf(v, |b, _len| ptr::memcpy(b, buf as *u8, len));\n         vec::unsafe::set_len(v, len);\n         vec::push(v, 0u8);\n \n@@ -1804,25 +1807,15 @@ mod unsafe {\n         from_buf_len(::unsafe::reinterpret_cast(c_str), len)\n     }\n \n-   /**\n-    * Converts a vector of bytes to a string.\n-    *\n-    * Does not verify that the vector contains valid UTF-8.\n-    */\n-   unsafe fn from_bytes(+v: ~[const u8]) -> ~str {\n-       unsafe {\n-           let mut vcopy = ::unsafe::transmute(v);\n-           vec::push(vcopy, 0u8);\n-           ::unsafe::transmute(vcopy)\n-       }\n-   }\n+    /// Converts a vector of bytes to a string.\n+    unsafe fn from_bytes(v: &[const u8]) -> ~str {\n+        do vec::as_const_buf(v) |buf, len| {\n+            from_buf_len(buf, len)\n+        }\n+    }\n \n-   /**\n-    * Converts a byte to a string.\n-    *\n-    * Does not verify that the byte is valid UTF-8.\n-    */\n-   unsafe fn from_byte(u: u8) -> ~str { unsafe::from_bytes(~[u]) }\n+    /// Converts a byte to a string.\n+    unsafe fn from_byte(u: u8) -> ~str { unsafe::from_bytes([u]) }\n \n    /**\n     * Takes a bytewise (not UTF-8) slice from a string.\n@@ -1835,14 +1828,14 @@ mod unsafe {\n     * If end is greater than the length of the string.\n     */\n    unsafe fn slice_bytes(s: &str, begin: uint, end: uint) -> ~str {\n-       do unpack_slice(s) |sbuf, n| {\n+       do as_buf(s) |sbuf, n| {\n            assert (begin <= end);\n            assert (end <= n);\n \n            let mut v = ~[];\n            vec::reserve(v, end - begin + 1u);\n            unsafe {\n-               do vec::as_buf(v) |vbuf| {\n+               do vec::as_buf(v) |vbuf, _vlen| {\n                    let src = ptr::offset(sbuf, begin);\n                    ptr::memcpy(vbuf, src, end - begin);\n                }\n@@ -2683,7 +2676,7 @@ mod tests {\n     #[test]\n     fn test_as_buf() {\n         let a = ~\"Abcdefg\";\n-        let b = as_buf(a, |buf| {\n+        let b = as_buf(a, |buf, _l| {\n             assert unsafe { *buf } == 65u8;\n             100\n         });\n@@ -2693,7 +2686,7 @@ mod tests {\n     #[test]\n     fn test_as_buf_small() {\n         let a = ~\"A\";\n-        let b = as_buf(a, |buf| {\n+        let b = as_buf(a, |buf, _l| {\n             assert unsafe { *buf } == 65u8;\n             100\n         });\n@@ -2704,12 +2697,26 @@ mod tests {\n     fn test_as_buf2() {\n         unsafe {\n             let s = ~\"hello\";\n-            let sb = as_buf(s, |b| b);\n+            let sb = as_buf(s, |b, _l| b);\n             let s_cstr = unsafe::from_buf(sb);\n             assert (eq(s_cstr, s));\n         }\n     }\n \n+    #[test]\n+    fn test_as_buf_3() {\n+        let a = ~\"hello\";\n+        do as_buf(a) |buf, len| {\n+            unsafe {\n+                assert a[0] == 'h' as u8;\n+                assert *buf == 'h' as u8;\n+                assert len == 6u;\n+                assert *ptr::offset(buf,4u) == 'o' as u8;\n+                assert *ptr::offset(buf,5u) == 0u8;\n+            }\n+        }\n+    }\n+\n     #[test]\n     fn vec_str_conversions() {\n         let s1: ~str = ~\"All mimsy were the borogoves\";\n@@ -2952,20 +2959,6 @@ mod tests {\n         assert found_b;\n     }\n \n-    #[test]\n-    fn test_unpack_slice() {\n-        let a = ~\"hello\";\n-        do unpack_slice(a) |buf, len| {\n-            unsafe {\n-                assert a[0] == 'h' as u8;\n-                assert *buf == 'h' as u8;\n-                assert len == 6u;\n-                assert *ptr::offset(buf,4u) == 'o' as u8;\n-                assert *ptr::offset(buf,5u) == 0u8;\n-            }\n-        }\n-    }\n-\n     #[test]\n     fn test_escape_unicode() {\n         assert escape_unicode(~\"abc\") == ~\"\\\\x61\\\\x62\\\\x63\";"}, {"sha": "d3c042fb05dc1e05a73c0ce47c786d47080a1eb3", "filename": "src/libcore/uint-template.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a63e0e47f0d4fa6b79365c645d6c284de234e2d0/src%2Flibcore%2Fuint-template.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a63e0e47f0d4fa6b79365c645d6c284de234e2d0/src%2Flibcore%2Fuint-template.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fuint-template.rs?ref=a63e0e47f0d4fa6b79365c645d6c284de234e2d0", "patch": "@@ -161,7 +161,7 @@ fn from_str_radix(buf: ~str, radix: u64) -> option<u64> {\n  */\n fn to_str(num: T, radix: uint) -> ~str {\n     do to_str_bytes(false, num, radix) |slice| {\n-        do vec::unpack_slice(slice) |p, len| {\n+        do vec::as_buf(slice) |p, len| {\n             unsafe { str::unsafe::from_buf_len(p, len) }\n         }\n     }\n@@ -206,7 +206,7 @@ fn to_str_bytes<U>(neg: bool, num: T, radix: uint,\n     // in-bounds, no extra cost.\n \n     unsafe {\n-        do vec::unpack_slice(buf) |p, len| {\n+        do vec::as_buf(buf) |p, len| {\n             let mp = p as *mut u8;\n             let mut i = len;\n             let mut n = num;"}, {"sha": "2950b791f983f615b214df6adf62c45a21323a87", "filename": "src/libcore/vec.rs", "status": "modified", "additions": 38, "deletions": 48, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/a63e0e47f0d4fa6b79365c645d6c284de234e2d0/src%2Flibcore%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a63e0e47f0d4fa6b79365c645d6c284de234e2d0/src%2Flibcore%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fvec.rs?ref=a63e0e47f0d4fa6b79365c645d6c284de234e2d0", "patch": "@@ -81,8 +81,7 @@ export permute;\n export windowed;\n export as_buf;\n export as_mut_buf;\n-export unpack_slice;\n-export unpack_const_slice;\n+export as_const_buf;\n export unsafe;\n export u8;\n export extensions;\n@@ -113,12 +112,12 @@ type init_op<T> = fn(uint) -> T;\n \n /// Returns true if a vector contains no elements\n pure fn is_empty<T>(v: &[const T]) -> bool {\n-    unpack_const_slice(v, |_p, len| len == 0u)\n+    as_const_buf(v, |_p, len| len == 0u)\n }\n \n /// Returns true if a vector contains some elements\n pure fn is_not_empty<T>(v: &[const T]) -> bool {\n-    unpack_const_slice(v, |_p, len| len > 0u)\n+    as_const_buf(v, |_p, len| len > 0u)\n }\n \n /// Returns true if two vectors have the same length\n@@ -177,7 +176,7 @@ pure fn capacity<T>(&&v: ~[const T]) -> uint {\n /// Returns the length of a vector\n #[inline(always)]\n pure fn len<T>(&&v: &[const T]) -> uint {\n-    unpack_const_slice(v, |_p, len| len)\n+    as_const_buf(v, |_p, len| len)\n }\n \n /**\n@@ -317,7 +316,7 @@ pure fn slice<T: copy>(v: &[const T], start: uint, end: uint) -> ~[T] {\n pure fn view<T>(v: &[T], start: uint, end: uint) -> &[T] {\n     assert (start <= end);\n     assert (end <= len(v));\n-    do unpack_slice(v) |p, _len| {\n+    do as_buf(v) |p, _len| {\n         unsafe {\n             ::unsafe::reinterpret_cast(\n                 (ptr::offset(p, start), (end - start) * sys::size_of::<T>()))\n@@ -329,7 +328,7 @@ pure fn view<T>(v: &[T], start: uint, end: uint) -> &[T] {\n pure fn mut_view<T>(v: &[mut T], start: uint, end: uint) -> &[mut T] {\n     assert (start <= end);\n     assert (end <= len(v));\n-    do unpack_slice(v) |p, _len| {\n+    do as_buf(v) |p, _len| {\n         unsafe {\n             ::unsafe::reinterpret_cast(\n                 (ptr::offset(p, start), (end - start) * sys::size_of::<T>()))\n@@ -341,7 +340,7 @@ pure fn mut_view<T>(v: &[mut T], start: uint, end: uint) -> &[mut T] {\n pure fn const_view<T>(v: &[const T], start: uint, end: uint) -> &[const T] {\n     assert (start <= end);\n     assert (end <= len(v));\n-    do unpack_slice(v) |p, _len| {\n+    do as_buf(v) |p, _len| {\n         unsafe {\n             ::unsafe::reinterpret_cast(\n                 (ptr::offset(p, start), (end - start) * sys::size_of::<T>()))\n@@ -481,7 +480,7 @@ fn unshift<T>(&v: ~[T], +x: T) {\n }\n \n fn consume<T>(+v: ~[T], f: fn(uint, +T)) unsafe {\n-    do unpack_slice(v) |p, ln| {\n+    do as_buf(v) |p, ln| {\n         for uint::range(0, ln) |i| {\n             let x <- *ptr::offset(p, i);\n             f(i, x);\n@@ -529,13 +528,13 @@ fn push_slow<T>(&v: ~[const T], +initval: T) {\n // Unchecked vector indexing\n #[inline(always)]\n unsafe fn ref<T: copy>(v: &[const T], i: uint) -> T {\n-    unpack_slice(v, |p, _len| *ptr::offset(p, i))\n+    as_buf(v, |p, _len| *ptr::offset(p, i))\n }\n \n #[inline(always)]\n unsafe fn ref_set<T: copy>(v: &[mut T], i: uint, +val: T) {\n     let mut box = some(val);\n-    do unpack_mut_slice(v) |p, _len| {\n+    do as_mut_buf(v) |p, _len| {\n         let mut box2 = none;\n         box2 <-> box;\n         rusti::move_val_init(*ptr::mut_offset(p, i), option::unwrap(box2));\n@@ -555,7 +554,7 @@ fn push_all<T: copy>(&v: ~[const T], rhs: &[const T]) {\n fn push_all_move<T>(&v: ~[const T], -rhs: ~[const T]) {\n     reserve(v, v.len() + rhs.len());\n     unsafe {\n-        do unpack_slice(rhs) |p, len| {\n+        do as_buf(rhs) |p, len| {\n             for uint::range(0, len) |i| {\n                 let x <- *ptr::offset(p, i);\n                 push(v, x);\n@@ -1056,7 +1055,7 @@ element's value.\n */\n #[inline(always)]\n pure fn iter_between<T>(v: &[T], start: uint, end: uint, f: fn(T)) {\n-    do unpack_slice(v) |base_ptr, len| {\n+    do as_buf(v) |base_ptr, len| {\n         assert start <= end;\n         assert end <= len;\n         unsafe {\n@@ -1078,7 +1077,7 @@ pure fn iter_between<T>(v: &[T], start: uint, end: uint, f: fn(T)) {\n  */\n #[inline(always)]\n pure fn each<T>(v: &[T], f: fn(T) -> bool) {\n-    do vec::unpack_slice(v) |p, n| {\n+    do vec::as_buf(v) |p, n| {\n         let mut n = n;\n         let mut p = p;\n         while n > 0u {\n@@ -1098,7 +1097,7 @@ pure fn each<T>(v: &[T], f: fn(T) -> bool) {\n  */\n #[inline(always)]\n pure fn eachi<T>(v: &[T], f: fn(uint, T) -> bool) {\n-    do vec::unpack_slice(v) |p, n| {\n+    do vec::as_buf(v) |p, n| {\n         let mut i = 0u;\n         let mut p = p;\n         while i < n {\n@@ -1118,7 +1117,7 @@ pure fn eachi<T>(v: &[T], f: fn(uint, T) -> bool) {\n  */\n #[inline(always)]\n pure fn reach<T>(v: &[T], blk: fn(T) -> bool) {\n-    do vec::unpack_slice(v) |p, n| {\n+    do vec::as_buf(v) |p, n| {\n         let mut i = 1;\n         while i <= n {\n             unsafe {\n@@ -1136,7 +1135,7 @@ pure fn reach<T>(v: &[T], blk: fn(T) -> bool) {\n  */\n #[inline(always)]\n pure fn reachi<T>(v: &[T], blk: fn(uint, T) -> bool) {\n-    do vec::unpack_slice(v) |p, n| {\n+    do vec::as_buf(v) |p, n| {\n         let mut i = 1;\n         while i <= n {\n             unsafe {\n@@ -1247,46 +1246,37 @@ pure fn windowed<TT: copy>(nn: uint, xx: &[TT]) -> ~[~[TT]] {\n  * Allows for unsafe manipulation of vector contents, which is useful for\n  * foreign interop.\n  */\n-fn as_buf<E,T>(v: &[E], f: fn(*E) -> T) -> T {\n-    unpack_slice(v, |buf, _len| f(buf))\n-}\n-\n-fn as_mut_buf<E,T>(v: &[mut E], f: fn(*mut E) -> T) -> T {\n-    unpack_mut_slice(v, |buf, _len| f(buf))\n-}\n-\n-/// Work with the buffer and length of a slice.\n #[inline(always)]\n-pure fn unpack_slice<T,U>(s: &[const T],\n-                          f: fn(*T, uint) -> U) -> U {\n+pure fn as_buf<T,U>(s: &[const T],\n+                    f: fn(*T, uint) -> U) -> U {\n     unsafe {\n         let v : *(*T,uint) = ::unsafe::reinterpret_cast(ptr::addr_of(s));\n         let (buf,len) = *v;\n         f(buf, len / sys::size_of::<T>())\n     }\n }\n \n-/// Work with the buffer and length of a slice.\n+/// Similar to `as_buf` but passing a `*const T`\n #[inline(always)]\n-pure fn unpack_const_slice<T,U>(s: &[const T],\n-                                f: fn(*const T, uint) -> U) -> U {\n-    unsafe {\n-        let v : *(*const T,uint) =\n-            ::unsafe::reinterpret_cast(ptr::addr_of(s));\n-        let (buf,len) = *v;\n-        f(buf, len / sys::size_of::<T>())\n+pure fn as_const_buf<T,U>(s: &[const T],\n+                          f: fn(*const T, uint) -> U) -> U {\n+    do as_buf(s) |p, len| {\n+        unsafe {\n+            let pp : *const T = ::unsafe::reinterpret_cast(p);\n+            f(pp, len)\n+        }\n     }\n }\n \n-/// Work with the buffer and length of a slice.\n+/// Similar to `as_buf` but passing a `*mut T`\n #[inline(always)]\n-pure fn unpack_mut_slice<T,U>(s: &[mut T],\n-                              f: fn(*mut T, uint) -> U) -> U {\n-    unsafe {\n-        let v : *(*const T,uint) =\n-            ::unsafe::reinterpret_cast(ptr::addr_of(s));\n-        let (buf,len) = *v;\n-        f(buf, len / sys::size_of::<T>())\n+pure fn as_mut_buf<T,U>(s: &[mut T],\n+                        f: fn(*mut T, uint) -> U) -> U {\n+    do as_buf(s) |p, len| {\n+        unsafe {\n+            let pp : *mut T = ::unsafe::reinterpret_cast(p);\n+            f(pp, len)\n+        }\n     }\n }\n \n@@ -1605,8 +1595,8 @@ mod unsafe {\n       * may overlap.\n       */\n     unsafe fn memcpy<T>(dst: &[mut T], src: &[const T], count: uint) {\n-        do unpack_slice(dst) |p_dst, _len_dst| {\n-            do unpack_slice(src) |p_src, _len_src| {\n+        do as_buf(dst) |p_dst, _len_dst| {\n+            do as_buf(src) |p_src, _len_src| {\n                 ptr::memcpy(p_dst, p_src, count)\n             }\n         }\n@@ -1619,8 +1609,8 @@ mod unsafe {\n       * may overlap.\n       */\n     unsafe fn memmove<T>(dst: &[mut T], src: &[const T], count: uint) {\n-        do unpack_slice(dst) |p_dst, _len_dst| {\n-            do unpack_slice(src) |p_src, _len_src| {\n+        do as_buf(dst) |p_dst, _len_dst| {\n+            do as_buf(src) |p_src, _len_src| {\n                 ptr::memmove(p_dst, p_src, count)\n             }\n         }"}, {"sha": "6fb4b3c1b33509341bdb8c2c244e754d08f47e65", "filename": "src/libstd/net_ip.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a63e0e47f0d4fa6b79365c645d6c284de234e2d0/src%2Flibstd%2Fnet_ip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a63e0e47f0d4fa6b79365c645d6c284de234e2d0/src%2Flibstd%2Fnet_ip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_ip.rs?ref=a63e0e47f0d4fa6b79365c645d6c284de234e2d0", "patch": "@@ -91,7 +91,7 @@ enum ip_get_addr_err {\n fn get_addr(++node: ~str, iotask: iotask)\n         -> result::result<~[ip_addr], ip_get_addr_err> unsafe {\n     do comm::listen |output_ch| {\n-        do str::unpack_slice(node) |node_ptr, len| {\n+        do str::as_buf(node) |node_ptr, len| {\n             log(debug, #fmt(\"slice len %?\", len));\n             let handle = create_uv_getaddrinfo_t();\n             let handle_ptr = ptr::addr_of(handle);"}, {"sha": "3c05a0b5574a8b2c38e3014942353c88b741b536", "filename": "src/libstd/par.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a63e0e47f0d4fa6b79365c645d6c284de234e2d0/src%2Flibstd%2Fpar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a63e0e47f0d4fa6b79365c645d6c284de234e2d0/src%2Flibstd%2Fpar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpar.rs?ref=a63e0e47f0d4fa6b79365c645d6c284de234e2d0", "patch": "@@ -46,7 +46,7 @@ fn map_slices<A: copy send, B: copy send>(\n         while base < len {\n             let end = uint::min(len, base + items_per_task);\n             // FIXME: why is the ::<A, ()> annotation required here? (#2617)\n-            do vec::unpack_slice::<A, ()>(xs) |p, _len| {\n+            do vec::as_buf::<A, ()>(xs) |p, _len| {\n                 let f = f();\n                 let f = do future_spawn() |copy base| {\n                     unsafe {"}, {"sha": "cb1f5321f780c3ad49effb6cf36ed33e9fef130f", "filename": "src/libstd/uv_ll.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a63e0e47f0d4fa6b79365c645d6c284de234e2d0/src%2Flibstd%2Fuv_ll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a63e0e47f0d4fa6b79365c645d6c284de234e2d0/src%2Flibstd%2Fuv_ll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fuv_ll.rs?ref=a63e0e47f0d4fa6b79365c645d6c284de234e2d0", "patch": "@@ -821,10 +821,9 @@ unsafe fn ip4_name(src: &sockaddr_in) -> ~str {\n     // ipv4 addr max size: 15 + 1 trailing null byte\n     let dst: ~[u8] = ~[0u8,0u8,0u8,0u8,0u8,0u8,0u8,0u8,\n                      0u8,0u8,0u8,0u8,0u8,0u8,0u8,0u8];\n-    let size = 16 as libc::size_t;\n-    do vec::as_buf(dst) |dst_buf| {\n+    do vec::as_buf(dst) |dst_buf, size| {\n         rustrt::rust_uv_ip4_name(src as *sockaddr_in,\n-                                              dst_buf, size);\n+                                 dst_buf, size as libc::size_t);\n         // seems that checking the result of uv_ip4_name\n         // doesn't work too well..\n         // you're stuck looking at the value of dst_buf\n@@ -842,13 +841,12 @@ unsafe fn ip6_name(src: &sockaddr_in6) -> ~str {\n                        0u8,0u8,0u8,0u8,0u8,0u8,0u8,0u8,\n                        0u8,0u8,0u8,0u8,0u8,0u8,0u8,0u8,\n                        0u8,0u8,0u8,0u8,0u8,0u8];\n-    let size = 46 as libc::size_t;\n-    do vec::as_buf(dst) |dst_buf| {\n+    do vec::as_buf(dst) |dst_buf, size| {\n         let src_unsafe_ptr = src as *sockaddr_in6;\n         log(debug, #fmt(\"val of src *sockaddr_in6: %? sockaddr_in6: %?\",\n                         src_unsafe_ptr, src));\n         let result = rustrt::rust_uv_ip6_name(src_unsafe_ptr,\n-                                              dst_buf, size);\n+                                              dst_buf, size as libc::size_t);\n         alt result {\n           0i32 {\n             str::unsafe::from_buf(dst_buf)"}, {"sha": "855f9134dd7cb67f21d3d552b3444e817eb5606d", "filename": "src/rustc/middle/trans/foreign.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a63e0e47f0d4fa6b79365c645d6c284de234e2d0/src%2Frustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a63e0e47f0d4fa6b79365c645d6c284de234e2d0/src%2Frustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=a63e0e47f0d4fa6b79365c645d6c284de234e2d0", "patch": "@@ -66,7 +66,7 @@ fn classify_ty(ty: TypeRef) -> ~[x86_64_reg_class] {\n     fn struct_tys(ty: TypeRef) -> ~[TypeRef] {\n         let n = llvm::LLVMCountStructElementTypes(ty);\n         let elts = vec::from_elem(n as uint, ptr::null());\n-        do vec::as_buf(elts) |buf| {\n+        do vec::as_buf(elts) |buf, _len| {\n             llvm::LLVMGetStructElementTypes(ty, buf);\n         }\n         ret elts;"}, {"sha": "abf1bc5d6c809b29d88dc6cea7d2f3647f1afcf5", "filename": "src/test/run-fail/bug-2470-bounds-check-overflow.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a63e0e47f0d4fa6b79365c645d6c284de234e2d0/src%2Ftest%2Frun-fail%2Fbug-2470-bounds-check-overflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a63e0e47f0d4fa6b79365c645d6c284de234e2d0/src%2Ftest%2Frun-fail%2Fbug-2470-bounds-check-overflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fbug-2470-bounds-check-overflow.rs?ref=a63e0e47f0d4fa6b79365c645d6c284de234e2d0", "patch": "@@ -9,7 +9,7 @@ fn main() {\n     // huge).\n \n     let x = ~[1u,2u,3u];\n-    do vec::unpack_slice(x) |p, _len| {\n+    do vec::as_buf(x) |p, _len| {\n         let base = p as uint;                     // base = 0x1230 say\n         let idx = base / sys::size_of::<uint>();  // idx  = 0x0246 say\n         #error(\"ov1 base = 0x%x\", base);"}]}