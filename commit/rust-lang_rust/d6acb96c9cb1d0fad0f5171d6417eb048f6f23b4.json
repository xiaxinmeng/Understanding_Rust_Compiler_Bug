{"sha": "d6acb96c9cb1d0fad0f5171d6417eb048f6f23b4", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ2YWNiOTZjOWNiMWQwZmFkMGY1MTcxZDY0MTdlYjA0OGY2ZjIzYjQ=", "commit": {"author": {"name": "Jed Davis", "email": "jld@panix.com", "date": "2013-02-28T07:08:52Z"}, "committer": {"name": "Jed Davis", "email": "jld@panix.com", "date": "2013-03-07T04:41:58Z"}, "message": "Add lots of comments to adt.rs, and some minor cleanup.", "tree": {"sha": "bdc4050f94c2e38bc3fe4356d4d69738cf235ec6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bdc4050f94c2e38bc3fe4356d4d69738cf235ec6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d6acb96c9cb1d0fad0f5171d6417eb048f6f23b4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d6acb96c9cb1d0fad0f5171d6417eb048f6f23b4", "html_url": "https://github.com/rust-lang/rust/commit/d6acb96c9cb1d0fad0f5171d6417eb048f6f23b4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d6acb96c9cb1d0fad0f5171d6417eb048f6f23b4/comments", "author": {"login": "jld", "id": 254973, "node_id": "MDQ6VXNlcjI1NDk3Mw==", "avatar_url": "https://avatars.githubusercontent.com/u/254973?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jld", "html_url": "https://github.com/jld", "followers_url": "https://api.github.com/users/jld/followers", "following_url": "https://api.github.com/users/jld/following{/other_user}", "gists_url": "https://api.github.com/users/jld/gists{/gist_id}", "starred_url": "https://api.github.com/users/jld/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jld/subscriptions", "organizations_url": "https://api.github.com/users/jld/orgs", "repos_url": "https://api.github.com/users/jld/repos", "events_url": "https://api.github.com/users/jld/events{/privacy}", "received_events_url": "https://api.github.com/users/jld/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jld", "id": 254973, "node_id": "MDQ6VXNlcjI1NDk3Mw==", "avatar_url": "https://avatars.githubusercontent.com/u/254973?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jld", "html_url": "https://github.com/jld", "followers_url": "https://api.github.com/users/jld/followers", "following_url": "https://api.github.com/users/jld/following{/other_user}", "gists_url": "https://api.github.com/users/jld/gists{/gist_id}", "starred_url": "https://api.github.com/users/jld/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jld/subscriptions", "organizations_url": "https://api.github.com/users/jld/orgs", "repos_url": "https://api.github.com/users/jld/repos", "events_url": "https://api.github.com/users/jld/events{/privacy}", "received_events_url": "https://api.github.com/users/jld/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a9026c7f19d0418c8c0d4d401640bdd15b2e1d7e", "url": "https://api.github.com/repos/rust-lang/rust/commits/a9026c7f19d0418c8c0d4d401640bdd15b2e1d7e", "html_url": "https://github.com/rust-lang/rust/commit/a9026c7f19d0418c8c0d4d401640bdd15b2e1d7e"}], "stats": {"total": 182, "additions": 152, "deletions": 30}, "files": [{"sha": "c080481b92b5ab31a87a93c2562243449121b9fe", "filename": "src/librustc/middle/trans/adt.rs", "status": "modified", "additions": 152, "deletions": 30, "changes": 182, "blob_url": "https://github.com/rust-lang/rust/blob/d6acb96c9cb1d0fad0f5171d6417eb048f6f23b4/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6acb96c9cb1d0fad0f5171d6417eb048f6f23b4/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs?ref=d6acb96c9cb1d0fad0f5171d6417eb048f6f23b4", "patch": "@@ -8,10 +8,56 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+/*!\n+ * # Representation of Algebraic Data Types\n+ *\n+ * This module determines how to represent enums, structs, tuples, and\n+ * (deprecated) structural records based on their monomorphized types;\n+ * it is responsible both for choosing a representation and\n+ * translating basic operations on values of those types.\n+ *\n+ * Note that the interface treats everything as a general case of an\n+ * enum, so structs/tuples/etc. have one pseudo-variant with\n+ * discriminant 0; i.e., as if they were a univariant enum.\n+ *\n+ * Having everything in one place will enable improvements to data\n+ * structure representation; possibilities include:\n+ *\n+ * - Aligning enum bodies correctly, which in turn makes possible SIMD\n+ *   vector types (which are strict-alignment even on x86) and ports\n+ *   to strict-alignment architectures (PowerPC, SPARC, etc.).\n+ *\n+ * - User-specified alignment (e.g., cacheline-aligning parts of\n+ *   concurrently accessed data structures); LLVM can't represent this\n+ *   directly, so we'd have to insert padding fields in any structure\n+ *   that might contain one and adjust GEP indices accordingly.  See\n+ *   issue #4578.\n+ *\n+ * - Rendering `Option<&T>` as a possibly-null `*T` instead of using\n+ *   an extra word (and likewise for `@T` and `~T`).  Can and probably\n+ *   should also apply to any enum with one empty case and one case\n+ *   starting with a non-null pointer (e.g., `Result<(), ~str>`).\n+ *\n+ * - Using smaller integer types for discriminants.\n+ *\n+ * - Store nested enums' discriminants in the same word.  Rather, if\n+ *   some variants start with enums, and those enums representations\n+ *   have unused alignment padding between discriminant and body, the\n+ *   outer enum's discriminant can be stored there and those variants\n+ *   can start at offset 0.  Kind of fancy, and might need work to\n+ *   make copies of the inner enum type cooperate, but it could help\n+ *   with `Option` or `Result` wrapped around another enum.\n+ *\n+ * - Tagged pointers would be neat, but given that any type can be\n+ *   used unboxed and any field can have pointers (including mutable)\n+ *   taken to it, implementing them for Rust seems difficult.\n+ */\n+\n use core::container::Map;\n use core::libc::c_ulonglong;\n use core::option::{Option, Some, None};\n use core::vec;\n+\n use lib::llvm::{ValueRef, TypeRef, True, False};\n use middle::trans::_match;\n use middle::trans::build::*;\n@@ -23,31 +69,58 @@ use syntax::ast;\n use util::ppaux::ty_to_str;\n \n \n-// XXX: should this be done with boxed traits instead of ML-style?\n+/// Representations.\n pub enum Repr {\n+    /**\n+     * `Unit` exists only so that an enum with a single C-like variant\n+     * can occupy no space, for ABI compatibility with rustc from\n+     * before (and during) the creation of this module.  It may not be\n+     * worth keeping around; `CEnum` and `Univariant` cover it\n+     * overwise.\n+     */\n     Unit(int),\n-    CEnum(int, int), /* discriminant range */\n+    /// C-like enums; basically an int.\n+    CEnum(int, int), // discriminant range\n+    /// Single-case variants, and structs/tuples/records.\n     Univariant(Struct, Destructor),\n+    /**\n+     * General-case enums: discriminant as int, followed by fields.\n+     * The fields start immediately after the discriminant, meaning\n+     * that they may not be correctly aligned for the platform's ABI;\n+     * see above.\n+     */\n     General(~[Struct])\n }\n \n+/**\n+ * Structs without destructors have historically had an extra layer of\n+ * LLVM-struct to make accessing them work the same as structs with\n+ * destructors.  This could probably be flattened to a boolean now\n+ * that this module exists.\n+ */\n enum Destructor {\n-    DtorPresent,\n-    DtorAbsent,\n-    NoDtor\n+    StructWithDtor,\n+    StructWithoutDtor,\n+    NonStruct\n }\n \n+/// For structs, and struct-like parts of anything fancier.\n struct Struct {\n     size: u64,\n     align: u64,\n     fields: ~[ty::t]\n }\n \n-\n+/**\n+ * Convenience for `represent_type`.  There should probably be more or\n+ * these, for places in trans where the `ty::t` isn't directly\n+ * available.\n+ */\n pub fn represent_node(bcx: block, node: ast::node_id) -> @Repr {\n     represent_type(bcx.ccx(), node_id_type(bcx, node))\n }\n \n+/// Decides how to represent a given type.\n pub fn represent_type(cx: @CrateContext, t: ty::t) -> @Repr {\n     debug!(\"Representing: %s\", ty_to_str(cx.tcx, t));\n     match cx.adt_reprs.find(&t) {\n@@ -56,18 +129,19 @@ pub fn represent_type(cx: @CrateContext, t: ty::t) -> @Repr {\n     }\n     let repr = @match ty::get(t).sty {\n         ty::ty_tup(ref elems) => {\n-            Univariant(mk_struct(cx, *elems), NoDtor)\n+            Univariant(mk_struct(cx, *elems), NonStruct)\n         }\n         ty::ty_rec(ref fields) => {\n             // XXX: Are these in the right order?\n-            Univariant(mk_struct(cx, fields.map(|f| f.mt.ty)), DtorAbsent)\n+            Univariant(mk_struct(cx, fields.map(|f| f.mt.ty)),\n+                       StructWithoutDtor)\n         }\n         ty::ty_struct(def_id, ref substs) => {\n             let fields = ty::lookup_struct_fields(cx.tcx, def_id);\n             let dt = ty::ty_dtor(cx.tcx, def_id).is_present();\n             Univariant(mk_struct(cx, fields.map(|field| {\n                 ty::lookup_field_type(cx.tcx, def_id, field.id, substs)\n-            })), if dt { DtorPresent } else { DtorAbsent })\n+            })), if dt { StructWithDtor } else { StructWithoutDtor })\n         }\n         ty::ty_enum(def_id, ref substs) => {\n             struct Case { discr: int, tys: ~[ty::t] };\n@@ -80,17 +154,22 @@ pub fn represent_type(cx: @CrateContext, t: ty::t) -> @Repr {\n             };\n             if cases.len() == 0 {\n                 // Uninhabitable; represent as unit\n-                Univariant(mk_struct(cx, ~[]), NoDtor)\n+                Unit(0)\n             } else if cases.len() == 1 && cases[0].tys.len() == 0 {\n+                // `()`-like; see comment on definition of `Unit`.\n                 Unit(cases[0].discr)\n             } else if cases.len() == 1 {\n-                // struct, tuple, newtype, etc.\n+                // Equivalent to a struct/tuple/newtype.\n                 assert cases[0].discr == 0;\n-                Univariant(mk_struct(cx, cases[0].tys), NoDtor)\n+                Univariant(mk_struct(cx, cases[0].tys), NonStruct)\n             } else if cases.all(|c| c.tys.len() == 0) {\n+                // All bodies empty -> intlike\n                 let discrs = cases.map(|c| c.discr);\n                 CEnum(discrs.min(), discrs.max())\n             } else {\n+                // The general case.  Since there's at least one\n+                // non-empty body, explicit discriminants should have\n+                // been rejected by a checker before this point.\n                 if !cases.alli(|i,c| c.discr == (i as int)) {\n                     cx.sess.bug(fmt!(\"non-C-like enum %s with specified \\\n                                       discriminants\",\n@@ -115,13 +194,18 @@ fn mk_struct(cx: @CrateContext, tys: &[ty::t]) -> Struct {\n     }\n }\n \n-\n-pub fn sizing_fields_of(cx: @CrateContext, r: &Repr) -> ~[TypeRef] {\n-    generic_fields_of(cx, r, true)\n-}\n+/**\n+ * Returns the fields of a struct for the given representation.\n+ * All nominal types are LLVM structs, in order to be able to use\n+ * forward-declared opaque types to prevent circularity in `type_of`.\n+ */\n pub fn fields_of(cx: @CrateContext, r: &Repr) -> ~[TypeRef] {\n     generic_fields_of(cx, r, false)\n }\n+/// Like `fields_of`, but for `type_of::sizing_type_of` (q.v.).\n+pub fn sizing_fields_of(cx: @CrateContext, r: &Repr) -> ~[TypeRef] {\n+    generic_fields_of(cx, r, true)\n+}\n fn generic_fields_of(cx: @CrateContext, r: &Repr, sizing: bool)\n     -> ~[TypeRef] {\n     match *r {\n@@ -134,9 +218,9 @@ fn generic_fields_of(cx: @CrateContext, r: &Repr, sizing: bool)\n                 st.fields.map(|&ty| type_of::type_of(cx, ty))\n             };\n             match dt {\n-                NoDtor => f,\n-                DtorAbsent => ~[T_struct(f)],\n-                DtorPresent => ~[T_struct(f), T_i8()]\n+                NonStruct => f,\n+                StructWithoutDtor => ~[T_struct(f)],\n+                StructWithDtor => ~[T_struct(f), T_i8()]\n             }\n         }\n         General(ref sts) => {\n@@ -164,6 +248,10 @@ fn load_discr(bcx: block, scrutinee: ValueRef, min: int, max: int)\n     }\n }\n \n+/**\n+ * Obtain as much of a \"discriminant\" as this representation has.\n+ * This should ideally be less tightly tied to `_match`.\n+ */\n pub fn trans_switch(bcx: block, r: &Repr, scrutinee: ValueRef)\n     -> (_match::branch_kind, Option<ValueRef>) {\n     match *r {\n@@ -176,18 +264,29 @@ pub fn trans_switch(bcx: block, r: &Repr, scrutinee: ValueRef)\n     }\n }\n \n+/**\n+ * If the representation is potentially of a C-like enum, implement\n+ * coercion to numeric types.\n+ */\n pub fn trans_cast_to_int(bcx: block, r: &Repr, scrutinee: ValueRef)\n     -> ValueRef {\n     match *r {\n         Unit(the_disc) => C_int(bcx.ccx(), the_disc),\n         CEnum(min, max) => load_discr(bcx, scrutinee, min, max),\n         Univariant(*) => bcx.ccx().sess.bug(~\"type has no explicit \\\n                                               discriminant\"),\n+        // Note: this case is used internally by trans_switch,\n+        // even though it shouldn't be reached by an external caller.\n         General(ref cases) => load_discr(bcx, scrutinee, 0,\n                                          (cases.len() - 1) as int)\n     }\n }\n \n+/**\n+ * Yield information about how to dispatch a case of the\n+ * discriminant-like value returned by `trans_switch`.\n+ * This should ideally be less tightly tied to `_match`.\n+ */\n pub fn trans_case(bcx: block, r: &Repr, discr: int) -> _match::opt_result {\n     match *r {\n         CEnum(*) => {\n@@ -202,6 +301,11 @@ pub fn trans_case(bcx: block, r: &Repr, discr: int) -> _match::opt_result {\n     }\n }\n \n+/**\n+ * Begin initializing a new value of the given case of the given\n+ * representation.  The fields should then be initialized with\n+ * `trans_GEP` and stores.\n+ */\n pub fn trans_set_discr(bcx: block, r: &Repr, val: ValueRef, discr: int) {\n     match *r {\n         Unit(the_discr) => {\n@@ -211,7 +315,7 @@ pub fn trans_set_discr(bcx: block, r: &Repr, val: ValueRef, discr: int) {\n             assert min <= discr && discr <= max;\n             Store(bcx, C_int(bcx.ccx(), discr), GEPi(bcx, val, [0, 0]))\n         }\n-        Univariant(_, DtorPresent) => {\n+        Univariant(_, StructWithDtor) => {\n             assert discr == 0;\n             Store(bcx, C_u8(1), GEPi(bcx, val, [0, 1]))\n         }\n@@ -224,6 +328,10 @@ pub fn trans_set_discr(bcx: block, r: &Repr, val: ValueRef, discr: int) {\n     }\n }\n \n+/**\n+ * The number of fields in a given case; for use when obtaining this\n+ * information from the type or definition is less convenient.\n+ */\n pub fn num_args(r: &Repr, discr: int) -> uint {\n     match *r {\n         Unit(*) | CEnum(*) => 0,\n@@ -232,20 +340,21 @@ pub fn num_args(r: &Repr, discr: int) -> uint {\n     }\n }\n \n+/// Access a field, at a point when the value's case is known.\n pub fn trans_GEP(bcx: block, r: &Repr, val: ValueRef, discr: int, ix: uint)\n     -> ValueRef {\n     // Note: if this ever needs to generate conditionals (e.g., if we\n     // decide to do some kind of cdr-coding-like non-unique repr\n-    // someday), it'll need to return a possibly-new bcx as well.\n+    // someday), it will need to return a possibly-new bcx as well.\n     match *r {\n         Unit(*) | CEnum(*) => {\n             bcx.ccx().sess.bug(~\"element access in C-like enum\")\n         }\n         Univariant(ref st, dt) => {\n             assert discr == 0;\n             let val = match dt {\n-                NoDtor => val,\n-                DtorPresent | DtorAbsent => GEPi(bcx, val, [0, 0])\n+                NonStruct => val,\n+                StructWithDtor | StructWithoutDtor => GEPi(bcx, val, [0, 0])\n             };\n             struct_GEP(bcx, st, val, ix, false)\n         }\n@@ -271,14 +380,26 @@ fn struct_GEP(bcx: block, st: &Struct, val: ValueRef, ix: uint,\n     GEPi(bcx, val, [0, ix])\n }\n \n+/// Access the struct drop flag, if present.\n pub fn trans_drop_flag_ptr(bcx: block, r: &Repr, val: ValueRef) -> ValueRef {\n     match *r {\n-        Univariant(_, DtorPresent) => GEPi(bcx, val, [0, 1]),\n+        Univariant(_, StructWithDtor) => GEPi(bcx, val, [0, 1]),\n         _ => bcx.ccx().sess.bug(~\"tried to get drop flag of non-droppable \\\n                                   type\")\n     }\n }\n \n+/**\n+ * Construct a constant value, suitable for initializing a\n+ * GlobalVariable, given a case and constant values for its fields.\n+ * Note that this may have a different LLVM type (and different\n+ * alignment!) from the representation's `type_of`, so it needs a\n+ * pointer cast before use.\n+ *\n+ * Currently it has the same size as the type, but this may be changed\n+ * in the future to avoid allocating unnecessary space after values of\n+ * shorter-than-maximum cases.\n+ */\n pub fn trans_const(ccx: @CrateContext, r: &Repr, discr: int,\n                    vals: &[ValueRef]) -> ValueRef {\n     match *r {\n@@ -294,10 +415,10 @@ pub fn trans_const(ccx: @CrateContext, r: &Repr, discr: int,\n             assert discr == 0;\n             let s = C_struct(build_const_struct(ccx, st, vals));\n             match dt {\n-                NoDtor => s,\n+                NonStruct => s,\n                 // The actual destructor flag doesn't need to be present.\n                 // But add an extra struct layer for compatibility.\n-                DtorPresent | DtorAbsent => C_struct(~[s])\n+                StructWithDtor | StructWithoutDtor => C_struct(~[s])\n             }\n         }\n         General(ref cases) => {\n@@ -345,7 +466,7 @@ fn build_const_struct(ccx: @CrateContext, st: &Struct, vals: &[ValueRef])\n #[always_inline]\n fn roundup(x: u64, a: u64) -> u64 { ((x + (a - 1)) / a) * a }\n \n-\n+/// Get the discriminant of a constant value.  (Not currently used.)\n pub fn const_get_discrim(ccx: @CrateContext, r: &Repr, val: ValueRef)\n     -> int {\n     match *r {\n@@ -356,13 +477,14 @@ pub fn const_get_discrim(ccx: @CrateContext, r: &Repr, val: ValueRef)\n     }\n }\n \n+/// Access a field of a constant value.\n pub fn const_get_element(ccx: @CrateContext, r: &Repr, val: ValueRef,\n                          _discr: int, ix: uint) -> ValueRef {\n     // Not to be confused with common::const_get_elt.\n     match *r {\n         Unit(*) | CEnum(*) => ccx.sess.bug(~\"element access in C-like enum \\\n                                              const\"),\n-        Univariant(_, NoDtor) => const_struct_field(ccx, val, ix),\n+        Univariant(_, NonStruct) => const_struct_field(ccx, val, ix),\n         Univariant(*) => const_struct_field(ccx, const_get_elt(ccx, val,\n                                                                [0]), ix),\n         General(*) => const_struct_field(ccx, const_get_elt(ccx, val,\n@@ -395,8 +517,8 @@ fn const_struct_field(ccx: @CrateContext, val: ValueRef, ix: uint)\n /// Is it safe to bitcast a value to the one field of its one variant?\n pub fn is_newtypeish(r: &Repr) -> bool {\n     match *r {\n-        Univariant(ref st, DtorAbsent)\n-        | Univariant(ref st, NoDtor) => st.fields.len() == 1,\n+        Univariant(ref st, StructWithoutDtor)\n+        | Univariant(ref st, NonStruct) => st.fields.len() == 1,\n         _ => false\n     }\n }"}]}