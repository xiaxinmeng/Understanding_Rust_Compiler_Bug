{"sha": "97d6342bf08e55f8d2b4f8df5c4b5a099df0191c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk3ZDYzNDJiZjA4ZTU1ZjhkMmI0ZjhkZjVjNGI1YTA5OWRmMDE5MWM=", "commit": {"author": {"name": "Michael Bebenita", "email": "mbebenita@mozilla.com", "date": "2010-08-09T15:15:34Z"}, "committer": {"name": "Michael Bebenita", "email": "mbebenita@mozilla.com", "date": "2010-08-09T15:15:34Z"}, "message": "Synthesize a flush_chan upcall right before a channel's ref_count drops to zero. This should only happen in the Rust code and not in the drop glue, or on the unwind path. This change allows the task owning the channel to block on a flush and delete its own channel. This change also cleans up some code around rust_port and rust_chan.", "tree": {"sha": "bfed15fefbc032deba1c34908f25c1562d88aa6b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bfed15fefbc032deba1c34908f25c1562d88aa6b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/97d6342bf08e55f8d2b4f8df5c4b5a099df0191c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/97d6342bf08e55f8d2b4f8df5c4b5a099df0191c", "html_url": "https://github.com/rust-lang/rust/commit/97d6342bf08e55f8d2b4f8df5c4b5a099df0191c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/97d6342bf08e55f8d2b4f8df5c4b5a099df0191c/comments", "author": {"login": "mbebenita", "id": 311082, "node_id": "MDQ6VXNlcjMxMTA4Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/311082?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mbebenita", "html_url": "https://github.com/mbebenita", "followers_url": "https://api.github.com/users/mbebenita/followers", "following_url": "https://api.github.com/users/mbebenita/following{/other_user}", "gists_url": "https://api.github.com/users/mbebenita/gists{/gist_id}", "starred_url": "https://api.github.com/users/mbebenita/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mbebenita/subscriptions", "organizations_url": "https://api.github.com/users/mbebenita/orgs", "repos_url": "https://api.github.com/users/mbebenita/repos", "events_url": "https://api.github.com/users/mbebenita/events{/privacy}", "received_events_url": "https://api.github.com/users/mbebenita/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mbebenita", "id": 311082, "node_id": "MDQ6VXNlcjMxMTA4Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/311082?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mbebenita", "html_url": "https://github.com/mbebenita", "followers_url": "https://api.github.com/users/mbebenita/followers", "following_url": "https://api.github.com/users/mbebenita/following{/other_user}", "gists_url": "https://api.github.com/users/mbebenita/gists{/gist_id}", "starred_url": "https://api.github.com/users/mbebenita/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mbebenita/subscriptions", "organizations_url": "https://api.github.com/users/mbebenita/orgs", "repos_url": "https://api.github.com/users/mbebenita/repos", "events_url": "https://api.github.com/users/mbebenita/events{/privacy}", "received_events_url": "https://api.github.com/users/mbebenita/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5917ca35190b526b65b4d26ad0b98024ce9e0b09", "url": "https://api.github.com/repos/rust-lang/rust/commits/5917ca35190b526b65b4d26ad0b98024ce9e0b09", "html_url": "https://github.com/rust-lang/rust/commit/5917ca35190b526b65b4d26ad0b98024ce9e0b09"}], "stats": {"total": 168, "additions": 113, "deletions": 55}, "files": [{"sha": "97dce2b2c584a3bfe05ad046b9780009e0faff0d", "filename": "src/boot/me/trans.ml", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/97d6342bf08e55f8d2b4f8df5c4b5a099df0191c/src%2Fboot%2Fme%2Ftrans.ml", "raw_url": "https://github.com/rust-lang/rust/raw/97d6342bf08e55f8d2b4f8df5c4b5a099df0191c/src%2Fboot%2Fme%2Ftrans.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Fme%2Ftrans.ml?ref=97d6342bf08e55f8d2b4f8df5c4b5a099df0191c", "patch": "@@ -2932,6 +2932,7 @@ let trans_visitor\n       (slot:Ast.slot)\n       (curr_iso:Ast.ty_iso option)\n       : unit =\n+      check_and_flush_chan cell slot;\n       drop_slot (get_ty_params_of_current_frame()) cell slot curr_iso\n \n   and drop_ty_in_current_frame\n@@ -4188,6 +4189,25 @@ let trans_visitor\n     let last_jumps = Array.map trans_arm at.Ast.alt_tag_arms in\n       Array.iter patch last_jumps\n \n+  (* If we're about to drop a channel, synthesize an upcall_flush_chan.\n+   * TODO: This should rather appear in a chan dtor when chans become\n+   * objects. *)\n+  and check_and_flush_chan\n+    (cell:Il.cell)\n+    (slot:Ast.slot)\n+      : unit =\n+      let ty = strip_mutable_or_constrained_ty (slot_ty slot) in\n+      match simplified_ty ty with\n+          Ast.TY_chan _ ->\n+                annotate \"check_and_flush_chan, flush_chan\";\n+                let rc = box_rc_cell cell in\n+                  emit (Il.cmp (Il.Cell rc) one);\n+                let jump = mark () in\n+                  emit (Il.jmp Il.JNE Il.CodeNone);\n+                  trans_void_upcall \"upcall_flush_chan\" [| Il.Cell cell |];\n+                  patch jump;\n+        | _ -> ()\n+\n   and drop_slots_at_curr_stmt _ : unit =\n     let stmt = Stack.top curr_stmt in\n       match htab_search cx.ctxt_post_stmt_slot_drops stmt with"}, {"sha": "2a0a61db7f19892eef6acd43e95e051d1725603a", "filename": "src/rt/rust_chan.cpp", "status": "modified", "additions": 20, "deletions": 7, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/97d6342bf08e55f8d2b4f8df5c4b5a099df0191c/src%2Frt%2Frust_chan.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/97d6342bf08e55f8d2b4f8df5c4b5a099df0191c/src%2Frt%2Frust_chan.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_chan.cpp?ref=97d6342bf08e55f8d2b4f8df5c4b5a099df0191c", "patch": "@@ -18,17 +18,22 @@ rust_chan::rust_chan(rust_task *task, maybe_proxy<rust_port> *port) :\n }\n \n rust_chan::~rust_chan() {\n-    if (port && !port->is_proxy()) {\n-        port->delegate()->chans.swap_delete(this);\n-    }\n+    task->log(rust_log::MEM | rust_log::COMM,\n+              \"del rust_chan(task=0x%\" PRIxPTR \")\", (uintptr_t) this);\n+\n+    A(task->dom, is_associated() == false,\n+      \"Channel must be disassociated before being freed.\");\n }\n \n /**\n  * Link this channel with the specified port.\n  */\n void rust_chan::associate(maybe_proxy<rust_port> *port) {\n     this->port = port;\n-    if (!port->is_proxy()) {\n+    if (port->is_proxy() == false) {\n+        task->log(rust_log::TASK,\n+            \"associating chan: 0x%\" PRIxPTR \" with port: 0x%\" PRIxPTR,\n+            this, port);\n         this->port->delegate()->chans.push(this);\n     }\n }\n@@ -43,14 +48,23 @@ bool rust_chan::is_associated() {\n void rust_chan::disassociate() {\n     A(task->dom, is_associated(), \"Channel must be associated with a port.\");\n \n+    if (port->is_proxy() == false) {\n+        task->log(rust_log::TASK,\n+            \"disassociating chan: 0x%\" PRIxPTR \" from port: 0x%\" PRIxPTR,\n+            this, port->delegate());\n+        port->delegate()->chans.swap_delete(this);\n+    }\n+\n     // Delete reference to the port.\n     port = NULL;\n }\n \n /**\n- * Attempt to transmit channel data to the associated port.\n+ * Attempt to send data to the associated port.\n  */\n-void rust_chan::transmit() {\n+void rust_chan::send(void *sptr) {\n+    buffer.enqueue(sptr);\n+\n     rust_dom *dom = task->dom;\n     if (!is_associated()) {\n         W(dom, is_associated(),\n@@ -81,7 +95,6 @@ void rust_chan::transmit() {\n \n     return;\n }\n-\n //\n // Local Variables:\n // mode: C++"}, {"sha": "6aa9824786d36362da881d2dd7677ca607059a95", "filename": "src/rt/rust_chan.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/97d6342bf08e55f8d2b4f8df5c4b5a099df0191c/src%2Frt%2Frust_chan.h", "raw_url": "https://github.com/rust-lang/rust/raw/97d6342bf08e55f8d2b4f8df5c4b5a099df0191c/src%2Frt%2Frust_chan.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_chan.h?ref=97d6342bf08e55f8d2b4f8df5c4b5a099df0191c", "patch": "@@ -17,7 +17,7 @@ class rust_chan : public rc_base<rust_chan>,\n     void disassociate();\n     bool is_associated();\n \n-    void transmit();\n+    void send(void *sptr);\n };\n \n //"}, {"sha": "af1472520ba20c26e63972788a763cc6a705e3de", "filename": "src/rt/rust_dom.cpp", "status": "modified", "additions": 2, "deletions": 16, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/97d6342bf08e55f8d2b4f8df5c4b5a099df0191c/src%2Frt%2Frust_dom.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/97d6342bf08e55f8d2b4f8df5c4b5a099df0191c/src%2Frt%2Frust_dom.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_dom.cpp?ref=97d6342bf08e55f8d2b4f8df5c4b5a099df0191c", "patch": "@@ -237,7 +237,6 @@ rust_dom::reap_dead_tasks() {\n         rust_task *task = dead_tasks[i];\n         if (task->ref_count == 0) {\n             I(this, task->tasks_waiting_to_join.is_empty());\n-\n             dead_tasks.swap_delete(task);\n             log(rust_log::TASK,\n                 \"deleting unreferenced dead task 0x%\" PRIxPTR, task);\n@@ -392,10 +391,9 @@ rust_dom::start_main_loop()\n         // if progress is made in other domains.\n \n         if (scheduled_task == NULL) {\n-            log(rust_log::TASK,\n-                \"all tasks are blocked, waiting for progress ...\");\n-            if (_log.is_tracing(rust_log::TASK))\n+            if (_log.is_tracing(rust_log::TASK)) {\n                 log_state();\n+            }\n             log(rust_log::TASK,\n                 \"all tasks are blocked, scheduler yielding ...\");\n             sync::yield();\n@@ -437,18 +435,6 @@ rust_dom::start_main_loop()\n     log(rust_log::DOM, \"terminated scheduler loop, reaping dead tasks ...\");\n \n     while (dead_tasks.length() > 0) {\n-        log(rust_log::DOM,\n-            \"waiting for %d dead tasks to become dereferenced ...\",\n-            dead_tasks.length());\n-\n-        if (_log.is_tracing(rust_log::DOM)) {\n-            for (size_t i = 0; i < dead_tasks.length(); i++) {\n-                log(rust_log::DOM,\n-                    \"task: 0x%\" PRIxPTR \", index: %d, ref_count: %d\",\n-                    dead_tasks[i], i, dead_tasks[i]->ref_count);\n-            }\n-        }\n-\n         if (_incoming_message_queue.is_empty()) {\n             log(rust_log::DOM,\n                 \"waiting for %d dead tasks to become dereferenced, \""}, {"sha": "1de804c9decb273a4e73020fdb2dac5c6239b186", "filename": "src/rt/rust_message.cpp", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/97d6342bf08e55f8d2b4f8df5c4b5a099df0191c/src%2Frt%2Frust_message.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/97d6342bf08e55f8d2b4f8df5c4b5a099df0191c/src%2Frt%2Frust_message.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_message.cpp?ref=97d6342bf08e55f8d2b4f8df5c4b5a099df0191c", "patch": "@@ -90,8 +90,7 @@ send(uint8_t *buffer, size_t buffer_sz, const char* label, rust_task *source,\n }\n \n void data_message::process() {\n-    _port->remote_channel->buffer.enqueue(_buffer);\n-    _port->remote_channel->transmit();\n+    _port->remote_channel->send(_buffer);\n     _target->log(rust_log::COMM, \"<=== received data via message ===\");\n }\n "}, {"sha": "c97b5d4170ad31480479675d4cb517003b9f2ed1", "filename": "src/rt/rust_port.cpp", "status": "modified", "additions": 21, "deletions": 3, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/97d6342bf08e55f8d2b4f8df5c4b5a099df0191c/src%2Frt%2Frust_port.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/97d6342bf08e55f8d2b4f8df5c4b5a099df0191c/src%2Frt%2Frust_port.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_port.cpp?ref=97d6342bf08e55f8d2b4f8df5c4b5a099df0191c", "patch": "@@ -21,14 +21,32 @@ rust_port::~rust_port() {\n \n     // Disassociate channels from this port.\n     while (chans.is_empty() == false) {\n-        chans.pop()->disassociate();\n+        rust_chan *chan = chans.peek();\n+        chan->disassociate();\n     }\n \n-    // We're the only ones holding a reference to the remote channel, so\n-    // clean it up.\n     delete remote_channel;\n }\n \n+bool rust_port::receive(void *dptr) {\n+    for (uint32_t i = 0; i < chans.length(); i++) {\n+        rust_chan *chan = chans[i];\n+        if (chan->buffer.is_empty() == false) {\n+            chan->buffer.dequeue(dptr);\n+            if (chan->buffer.is_empty() && chan->task->blocked()) {\n+                task->log(rust_log::COMM,\n+                          \"chan: 0x%\" PRIxPTR\n+                          \" is flushing, wakeup task: 0x%\" PRIxPTR,\n+                          chan, chan->task);\n+                chan->task->wakeup(this);\n+            }\n+            task->log(rust_log::COMM, \"<=== read data ===\");\n+            return true;\n+        }\n+    }\n+    return false;\n+}\n+\n void rust_port::log_state() {\n     task->log(rust_log::COMM,\n               \"rust_port: 0x%\" PRIxPTR \", associated channel(s): %d\","}, {"sha": "7a58f839c44f0e01bf0b2ba62f4d5b429dbbf706", "filename": "src/rt/rust_port.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/97d6342bf08e55f8d2b4f8df5c4b5a099df0191c/src%2Frt%2Frust_port.h", "raw_url": "https://github.com/rust-lang/rust/raw/97d6342bf08e55f8d2b4f8df5c4b5a099df0191c/src%2Frt%2Frust_port.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_port.h?ref=97d6342bf08e55f8d2b4f8df5c4b5a099df0191c", "patch": "@@ -16,6 +16,7 @@ class rust_port : public maybe_proxy<rust_port>,\n     rust_port(rust_task *task, size_t unit_sz);\n     ~rust_port();\n     void log_state();\n+    bool receive(void *dptr);\n };\n \n //"}, {"sha": "f52db868e02603bd50f7f871aa0f8781268d5405", "filename": "src/rt/rust_task.cpp", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/97d6342bf08e55f8d2b4f8df5c4b5a099df0191c/src%2Frt%2Frust_task.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/97d6342bf08e55f8d2b4f8df5c4b5a099df0191c/src%2Frt%2Frust_task.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_task.cpp?ref=97d6342bf08e55f8d2b4f8df5c4b5a099df0191c", "patch": "@@ -323,6 +323,11 @@ get_callee_save_fp(uintptr_t *top_of_callee_saves)\n \n void\n rust_task::kill() {\n+    if (dead()) {\n+        // Task is already dead, can't kill what's already dead.\n+        return;\n+    }\n+\n     // Note the distinction here: kill() is when you're in an upcall\n     // from task A and want to force-fail task B, you do B->kill().\n     // If you want to fail yourself you do self->fail(upcall_nargs)."}, {"sha": "039aa2fd972af31e63e0f85aa35033743cc53027", "filename": "src/rt/rust_upcall.cpp", "status": "modified", "additions": 42, "deletions": 26, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/97d6342bf08e55f8d2b4f8df5c4b5a099df0191c/src%2Frt%2Frust_upcall.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/97d6342bf08e55f8d2b4f8df5c4b5a099df0191c/src%2Frt%2Frust_upcall.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_upcall.cpp?ref=97d6342bf08e55f8d2b4f8df5c4b5a099df0191c", "patch": "@@ -97,27 +97,51 @@ upcall_new_chan(rust_task *task, rust_port *port) {\n     return new (dom) rust_chan(task, port);\n }\n \n+/**\n+ * Called whenever this channel needs to be flushed. This can happen due to a\n+ * flush statement, or automatically whenever a channel's ref count is\n+ * about to drop to zero.\n+ */\n+extern \"C\" CDECL void\n+upcall_flush_chan(rust_task *task, rust_chan *chan) {\n+    LOG_UPCALL_ENTRY(task);\n+    rust_dom *dom = task->dom;\n+    task->log(rust_log::UPCALL | rust_log::COMM,\n+              \"flush chan: 0x%\" PRIxPTR, chan);\n+\n+    if (chan->buffer.is_empty()) {\n+        return;\n+    }\n+\n+    A(dom, chan->port->is_proxy() == false,\n+      \"Channels to remote ports should be flushed automatically.\");\n+\n+    // Block on the port until this channel has been completely drained\n+    // by the port.\n+    task->block(chan->port);\n+    task->yield(2);\n+}\n+\n /**\n  * Called whenever the channel's ref count drops to zero.\n+ *\n+ * Cannot Yield: If the task were to unwind, the dropped ref would still\n+ * appear to be live, causing modify-after-free errors.\n  */\n extern \"C\" CDECL void upcall_del_chan(rust_task *task, rust_chan *chan) {\n     LOG_UPCALL_ENTRY(task);\n-    rust_dom *dom = task->dom;\n+\n     task->log(rust_log::UPCALL | rust_log::MEM | rust_log::COMM,\n               \"upcall del_chan(0x%\" PRIxPTR \")\", (uintptr_t) chan);\n-    I(dom, !chan->ref_count);\n-\n-    if (!chan->buffer.is_empty() && chan->is_associated()) {\n-        A(dom, !chan->port->is_proxy(),\n-          \"Channels to remote ports should be flushed automatically.\");\n-        // A target port may still be reading from this channel.\n-        // Block on this channel until it has been completely drained\n-        // by the port.\n-        task->block(chan);\n-        task->yield(2);\n-        return;\n-    }\n \n+    A(task->dom, chan->ref_count == 0,\n+      \"Channel's ref count should be zero.\");\n+\n+    if (chan->is_associated()) {\n+        A(task->dom, chan->buffer.is_empty(),\n+          \"Channel's buffer should be empty.\");\n+        chan->disassociate();\n+    }\n     delete chan;\n }\n \n@@ -183,8 +207,7 @@ upcall_send(rust_task *task, rust_chan *chan, void *sptr) {\n               \"chan: 0x%\" PRIxPTR \", sptr: 0x%\" PRIxPTR \", size: %d\",\n               (uintptr_t) chan, (uintptr_t) sptr,\n               chan->port->delegate()->unit_sz);\n-    chan->buffer.enqueue(sptr);\n-    chan->transmit();\n+    chan->send(sptr);\n     task->log(rust_log::COMM, \"=== sent data ===>\");\n }\n \n@@ -197,17 +220,8 @@ upcall_recv(rust_task *task, uintptr_t *dptr, rust_port *port) {\n               (uintptr_t) port, (uintptr_t) dptr, port->unit_sz,\n               port->chans.length());\n \n-    for (uint32_t i = 0; i < port->chans.length(); i++) {\n-        rust_chan *chan = port->chans[i];\n-        if (chan->buffer.is_empty() == false) {\n-            chan->buffer.dequeue(dptr);\n-            if (chan->buffer.is_empty() && chan->task->blocked()) {\n-                chan->task->wakeup(chan);\n-                delete chan;\n-            }\n-            task->log(rust_log::COMM, \"<=== read data ===\");\n-            return;\n-        }\n+    if (port->receive(dptr)) {\n+        return;\n     }\n \n     // No data was buffered on any incoming channel, so block this task\n@@ -260,6 +274,8 @@ upcall_exit(rust_task *task) {\n     LOG_UPCALL_ENTRY(task);\n     task->log(rust_log::UPCALL | rust_log::TASK,\n               \"task ref_count: %d\", task->ref_count);\n+    A(task->dom, task->ref_count >= 0,\n+      \"Task ref_count should not be negative on exit!\");\n     task->die();\n     task->notify_tasks_waiting_to_join();\n     task->yield(1);"}]}