{"sha": "45c1e0ae07b9581d8c2d2b39315ac7cc79475d75", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ1YzFlMGFlMDdiOTU4MWQ4YzJkMmIzOTMxNWFjN2NjNzk0NzVkNzU=", "commit": {"author": {"name": "Eric Huss", "email": "eric@huss.org", "date": "2020-09-08T22:09:57Z"}, "committer": {"name": "Eric Huss", "email": "eric@huss.org", "date": "2020-09-13T15:48:03Z"}, "message": "Auto-generate lint documentation.", "tree": {"sha": "bffba54de1eeb0b5dc313e3497b68aead9b9cc97", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bffba54de1eeb0b5dc313e3497b68aead9b9cc97"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/45c1e0ae07b9581d8c2d2b39315ac7cc79475d75", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/45c1e0ae07b9581d8c2d2b39315ac7cc79475d75", "html_url": "https://github.com/rust-lang/rust/commit/45c1e0ae07b9581d8c2d2b39315ac7cc79475d75", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/45c1e0ae07b9581d8c2d2b39315ac7cc79475d75/comments", "author": {"login": "ehuss", "id": 43198, "node_id": "MDQ6VXNlcjQzMTk4", "avatar_url": "https://avatars.githubusercontent.com/u/43198?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ehuss", "html_url": "https://github.com/ehuss", "followers_url": "https://api.github.com/users/ehuss/followers", "following_url": "https://api.github.com/users/ehuss/following{/other_user}", "gists_url": "https://api.github.com/users/ehuss/gists{/gist_id}", "starred_url": "https://api.github.com/users/ehuss/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ehuss/subscriptions", "organizations_url": "https://api.github.com/users/ehuss/orgs", "repos_url": "https://api.github.com/users/ehuss/repos", "events_url": "https://api.github.com/users/ehuss/events{/privacy}", "received_events_url": "https://api.github.com/users/ehuss/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ehuss", "id": 43198, "node_id": "MDQ6VXNlcjQzMTk4", "avatar_url": "https://avatars.githubusercontent.com/u/43198?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ehuss", "html_url": "https://github.com/ehuss", "followers_url": "https://api.github.com/users/ehuss/followers", "following_url": "https://api.github.com/users/ehuss/following{/other_user}", "gists_url": "https://api.github.com/users/ehuss/gists{/gist_id}", "starred_url": "https://api.github.com/users/ehuss/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ehuss/subscriptions", "organizations_url": "https://api.github.com/users/ehuss/orgs", "repos_url": "https://api.github.com/users/ehuss/repos", "events_url": "https://api.github.com/users/ehuss/events{/privacy}", "received_events_url": "https://api.github.com/users/ehuss/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a055c5a1bd95e029e9b31891db63b6dc8258b472", "url": "https://api.github.com/repos/rust-lang/rust/commits/a055c5a1bd95e029e9b31891db63b6dc8258b472", "html_url": "https://github.com/rust-lang/rust/commit/a055c5a1bd95e029e9b31891db63b6dc8258b472"}], "stats": {"total": 5481, "additions": 3914, "deletions": 1567}, "files": [{"sha": "1a67deacbfe039ba16a0f73a39db6f944edf1446", "filename": "Cargo.lock", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/45c1e0ae07b9581d8c2d2b39315ac7cc79475d75/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/45c1e0ae07b9581d8c2d2b39315ac7cc79475d75/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=45c1e0ae07b9581d8c2d2b39315ac7cc79475d75", "patch": "@@ -1677,6 +1677,15 @@ version = \"0.5.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"8dd5a6d5999d9907cda8ed67bbd137d3af8085216c2ac62de5be860bd41f304a\"\n \n+[[package]]\n+name = \"lint-docs\"\n+version = \"0.1.0\"\n+dependencies = [\n+ \"serde_json\",\n+ \"tempfile\",\n+ \"walkdir\",\n+]\n+\n [[package]]\n name = \"lock_api\"\n version = \"0.3.4\""}, {"sha": "02794d1028b506b4510a71e140de62a4fb210d31", "filename": "Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/45c1e0ae07b9581d8c2d2b39315ac7cc79475d75/Cargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/45c1e0ae07b9581d8c2d2b39315ac7cc79475d75/Cargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.toml?ref=45c1e0ae07b9581d8c2d2b39315ac7cc79475d75", "patch": "@@ -9,6 +9,7 @@ members = [\n   \"src/tools/compiletest\",\n   \"src/tools/error_index_generator\",\n   \"src/tools/linkchecker\",\n+  \"src/tools/lint-docs\",\n   \"src/tools/rustbook\",\n   \"src/tools/unstable-book-gen\",\n   \"src/tools/tidy\","}, {"sha": "e6be082da0e9967aba913bddbe6aacd70ff99de3", "filename": "compiler/rustc_lint/src/array_into_iter.rs", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/45c1e0ae07b9581d8c2d2b39315ac7cc79475d75/compiler%2Frustc_lint%2Fsrc%2Farray_into_iter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45c1e0ae07b9581d8c2d2b39315ac7cc79475d75/compiler%2Frustc_lint%2Fsrc%2Farray_into_iter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Farray_into_iter.rs?ref=45c1e0ae07b9581d8c2d2b39315ac7cc79475d75", "patch": "@@ -7,6 +7,31 @@ use rustc_session::lint::FutureIncompatibleInfo;\n use rustc_span::symbol::sym;\n \n declare_lint! {\n+    /// The `array_into_iter` lint detects calling `into_iter` on arrays.\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```rust\n+    /// # #![allow(unused)]\n+    /// [1, 2, 3].into_iter().for_each(|n| { *n; });\n+    /// ```\n+    ///\n+    /// {{produces}}\n+    ///\n+    /// ### Explanation\n+    ///\n+    /// In the future, it is planned to add an `IntoIter` implementation for\n+    /// arrays such that it will iterate over *values* of the array instead of\n+    /// references. Due to how method resolution works, this will change\n+    /// existing code that uses `into_iter` on arrays. The solution to avoid\n+    /// this warning is to use `iter()` instead of `into_iter()`.\n+    ///\n+    /// This is a [future-incompatible] lint to transition this to a hard error\n+    /// in the future. See [issue #66145] for more details and a more thorough\n+    /// description of the lint.\n+    ///\n+    /// [issue #66145]: https://github.com/rust-lang/rust/issues/66145\n+    /// [future-incompatible]: ../index.md#future-incompatible-lints\n     pub ARRAY_INTO_ITER,\n     Warn,\n     \"detects calling `into_iter` on arrays\","}, {"sha": "e785ba03d220187120b40226753961206b3bcc66", "filename": "compiler/rustc_lint/src/builtin.rs", "status": "modified", "additions": 504, "deletions": 0, "changes": 504, "blob_url": "https://github.com/rust-lang/rust/blob/45c1e0ae07b9581d8c2d2b39315ac7cc79475d75/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45c1e0ae07b9581d8c2d2b39315ac7cc79475d75/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs?ref=45c1e0ae07b9581d8c2d2b39315ac7cc79475d75", "patch": "@@ -61,6 +61,23 @@ use tracing::{debug, trace};\n pub use rustc_session::lint::builtin::*;\n \n declare_lint! {\n+    /// The `while_true` lint detects `while true { }`.\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```rust,no_run\n+    /// while true {\n+    ///\n+    /// }\n+    /// ```\n+    ///\n+    /// {{produces}}\n+    ///\n+    /// ### Explanation\n+    ///\n+    /// `while true` should be replaced with `loop`. A `loop` expression is\n+    /// the preferred way to write an infinite loop because it more directly\n+    /// expresses the intent of the loop.\n     WHILE_TRUE,\n     Warn,\n     \"suggest using `loop { }` instead of `while true { }`\"\n@@ -102,6 +119,24 @@ impl EarlyLintPass for WhileTrue {\n }\n \n declare_lint! {\n+    /// The `box_pointers` lints use of the Box type.\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```rust,compile_fail\n+    /// #![deny(box_pointers)]\n+    /// struct Foo {\n+    ///     x: Box<isize>,\n+    /// }\n+    /// ```\n+    ///\n+    /// {{produces}}\n+    ///\n+    /// ### Explanation\n+    ///\n+    /// This lint is mostly historical, and not particularly useful. `Box<T>`\n+    /// used to be built into the language, and the only way to do heap\n+    /// allocation. Today's Rust can call into other allocators, etc.\n     BOX_POINTERS,\n     Allow,\n     \"use of owned (Box type) heap memory\"\n@@ -156,6 +191,36 @@ impl<'tcx> LateLintPass<'tcx> for BoxPointers {\n }\n \n declare_lint! {\n+    /// The `non_shorthand_field_patterns` lint detects using `Struct { x: x }`\n+    /// instead of `Struct { x }` in a pattern.\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```rust\n+    /// struct Point {\n+    ///     x: i32,\n+    ///     y: i32,\n+    /// }\n+    ///\n+    ///\n+    /// fn main() {\n+    ///     let p = Point {\n+    ///         x: 5,\n+    ///         y: 5,\n+    ///     };\n+    ///\n+    ///     match p {\n+    ///         Point { x: x, y: y } => (),\n+    ///     }\n+    /// }\n+    /// ```\n+    ///\n+    /// {{produces}}\n+    ///\n+    /// ### Explanation\n+    ///\n+    /// The preferred style is to avoid the repetition of specifying both the\n+    /// field name and the binding name if both identifiers are the same.\n     NON_SHORTHAND_FIELD_PATTERNS,\n     Warn,\n     \"using `Struct { x: x }` instead of `Struct { x }` in a pattern\"\n@@ -216,6 +281,25 @@ impl<'tcx> LateLintPass<'tcx> for NonShorthandFieldPatterns {\n }\n \n declare_lint! {\n+    /// The `unsafe_code` lint catches usage of `unsafe` code.\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```rust,compile_fail\n+    /// #![deny(unsafe_code)]\n+    /// fn main() {\n+    ///     unsafe {\n+    ///\n+    ///     }\n+    /// }\n+    /// ```\n+    ///\n+    /// {{produces}}\n+    ///\n+    /// ### Explanation\n+    ///\n+    /// This lint is intended to restrict the usage of `unsafe`, which can be\n+    /// difficult to use correctly.\n     UNSAFE_CODE,\n     Allow,\n     \"usage of `unsafe` code\"\n@@ -303,6 +387,25 @@ impl EarlyLintPass for UnsafeCode {\n }\n \n declare_lint! {\n+    /// The `missing_docs` lint detects missing documentation for public items.\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```rust,compile_fail\n+    /// #![deny(missing_docs)]\n+    /// pub fn foo() {}\n+    /// ```\n+    ///\n+    /// {{produces}}\n+    ///\n+    /// ### Explanation\n+    ///\n+    /// This lint is intended to ensure that a library is well-documented.\n+    /// Items without documentation can be difficult for users to understand\n+    /// how to use properly.\n+    ///\n+    /// This lint is \"allow\" by default because it can be noisy, and not all\n+    /// projects may want to enforce everything to be documented.\n     pub MISSING_DOCS,\n     Allow,\n     \"detects missing documentation for public members\",\n@@ -528,6 +631,34 @@ impl<'tcx> LateLintPass<'tcx> for MissingDoc {\n }\n \n declare_lint! {\n+    /// The `missing_copy_implementations` lint detects potentially-forgotten\n+    /// implementations of [`Copy`].\n+    ///\n+    /// [`Copy`]: https://doc.rust-lang.org/std/marker/trait.Copy.html\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```rust,compile_fail\n+    /// #![deny(missing_copy_implementations)]\n+    /// pub struct Foo {\n+    ///     pub field: i32\n+    /// }\n+    /// # fn main() {}\n+    /// ```\n+    ///\n+    /// {{produces}}\n+    ///\n+    /// ### Explanation\n+    ///\n+    /// Historically (before 1.0), types were automatically marked as `Copy`\n+    /// if possible. This was changed so that it required an explicit opt-in\n+    /// by implementing the `Copy` trait. As part of this change, a lint was\n+    /// added to alert if a copyable type was not marked `Copy`.\n+    ///\n+    /// This lint is \"allow\" by default because this code isn't bad; it is\n+    /// common to write newtypes like this specifically so that a `Copy` type\n+    /// is no longer `Copy`. `Copy` types can result in unintended copies of\n+    /// large data which can impact performance.\n     pub MISSING_COPY_IMPLEMENTATIONS,\n     Allow,\n     \"detects potentially-forgotten implementations of `Copy`\"\n@@ -584,6 +715,32 @@ impl<'tcx> LateLintPass<'tcx> for MissingCopyImplementations {\n }\n \n declare_lint! {\n+    /// The `missing_debug_implementations` lint detects missing\n+    /// implementations of [`fmt::Debug`].\n+    ///\n+    /// [`fmt::Debug`]: https://doc.rust-lang.org/std/fmt/trait.Debug.html\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```rust,compile_fail\n+    /// #![deny(missing_debug_implementations)]\n+    /// pub struct Foo;\n+    /// # fn main() {}\n+    /// ```\n+    ///\n+    /// {{produces}}\n+    ///\n+    /// ### Explanation\n+    ///\n+    /// Having a `Debug` implementation on all types can assist with\n+    /// debugging, as it provides a convenient way to format and display a\n+    /// value. Using the `#[derive(Debug)]` attribute will automatically\n+    /// generate a typical implementation, or a custom implementation can be\n+    /// added by manually implementing the `Debug` trait.\n+    ///\n+    /// This lint is \"allow\" by default because adding `Debug` to all types can\n+    /// have a negative impact on compile time and code size. It also requires\n+    /// boilerplate to be added to every type, which can be an impediment.\n     MISSING_DEBUG_IMPLEMENTATIONS,\n     Allow,\n     \"detects missing implementations of Debug\"\n@@ -640,6 +797,45 @@ impl<'tcx> LateLintPass<'tcx> for MissingDebugImplementations {\n }\n \n declare_lint! {\n+    /// The `anonymous_parameters` lint detects anonymous parameters in trait\n+    /// definitions.\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```rust,edition2015,compile_fail\n+    /// #![deny(anonymous_parameters)]\n+    /// // edition 2015\n+    /// pub trait Foo {\n+    ///     fn foo(usize);\n+    /// }\n+    /// fn main() {}\n+    /// ```\n+    ///\n+    /// {{produces}}\n+    ///\n+    /// ### Explanation\n+    ///\n+    /// This syntax is mostly a historical accident, and can be worked around\n+    /// quite easily by adding an `_` pattern or a descriptive identifier:\n+    ///\n+    /// ```rust\n+    /// trait Foo {\n+    ///     fn foo(_: usize);\n+    /// }\n+    /// ```\n+    ///\n+    /// This syntax is now a hard error in the 2018 edition. In the 2015\n+    /// edition, this lint is \"allow\" by default, because the old code is\n+    /// still valid, and warning for all old code can be noisy. This lint\n+    /// enables the [`cargo fix`] tool with the `--edition` flag to\n+    /// automatically transition old code from the 2015 edition to 2018. The\n+    /// tool will switch this lint to \"warn\" and will automatically apply the\n+    /// suggested fix from the compiler (which is to add `_` to each\n+    /// parameter). This provides a completely automated way to update old\n+    /// code for a new edition. See [issue #41686] for more details.\n+    ///\n+    /// [issue #41686]: https://github.com/rust-lang/rust/issues/41686\n+    /// [`cargo fix`]: https://doc.rust-lang.org/cargo/commands/cargo-fix.html\n     pub ANONYMOUS_PARAMETERS,\n     Allow,\n     \"detects anonymous parameters\",\n@@ -806,12 +1002,54 @@ impl EarlyLintPass for UnusedDocComment {\n }\n \n declare_lint! {\n+    /// The `no_mangle_const_items` lint detects any `const` items with the\n+    /// [`no_mangle` attribute].\n+    ///\n+    /// [`no_mangle` attribute]: https://doc.rust-lang.org/reference/abi.html#the-no_mangle-attribute\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```rust,compile_fail\n+    /// #[no_mangle]\n+    /// const FOO: i32 = 5;\n+    /// ```\n+    ///\n+    /// {{produces}}\n+    ///\n+    /// ### Explanation\n+    ///\n+    /// Constants do not have their symbols exported, and therefore, this\n+    /// probably means you meant to use a [`static`], not a [`const`].\n+    ///\n+    /// [`static`]: https://doc.rust-lang.org/reference/items/static-items.html\n+    /// [`const`]: https://doc.rust-lang.org/reference/items/constant-items.html\n     NO_MANGLE_CONST_ITEMS,\n     Deny,\n     \"const items will not have their symbols exported\"\n }\n \n declare_lint! {\n+    /// The `no_mangle_generic_items` lint detects generic items that must be\n+    /// mangled.\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```rust\n+    /// #[no_mangle]\n+    /// fn foo<T>(t: T) {\n+    ///\n+    /// }\n+    /// ```\n+    ///\n+    /// {{produces}}\n+    ///\n+    /// ### Explanation\n+    ///\n+    /// An function with generics must have its symbol mangled to accommodate\n+    /// the generic parameter. The [`no_mangle` attribute] has no effect in\n+    /// this situation, and should be removed.\n+    ///\n+    /// [`no_mangle` attribute]: https://doc.rust-lang.org/reference/abi.html#the-no_mangle-attribute\n     NO_MANGLE_GENERIC_ITEMS,\n     Warn,\n     \"generic items must be mangled\"\n@@ -882,6 +1120,27 @@ impl<'tcx> LateLintPass<'tcx> for InvalidNoMangleItems {\n }\n \n declare_lint! {\n+    /// The `mutable_transmutes` lint catches transmuting from `&T` to `&mut\n+    /// T` because it is [undefined behavior].\n+    ///\n+    /// [undefined behavior]: https://doc.rust-lang.org/reference/behavior-considered-undefined.html\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```rust,compile_fail\n+    /// unsafe {\n+    ///     let y = std::mem::transmute::<&i32, &mut i32>(&5);\n+    /// }\n+    /// ```\n+    ///\n+    /// {{produces}}\n+    ///\n+    /// ### Explanation\n+    ///\n+    /// Certain assumptions are made about aliasing of data, and this transmute\n+    /// violates those assumptions. Consider using [`UnsafeCell`] instead.\n+    ///\n+    /// [`UnsafeCell`]: https://doc.rust-lang.org/std/cell/struct.UnsafeCell.html\n     MUTABLE_TRANSMUTES,\n     Deny,\n     \"mutating transmuted &mut T from &T may cause undefined behavior\"\n@@ -931,6 +1190,7 @@ impl<'tcx> LateLintPass<'tcx> for MutableTransmutes {\n }\n \n declare_lint! {\n+    /// The `unstable_features` is deprecated and should no longer be used.\n     UNSTABLE_FEATURES,\n     Allow,\n     \"enabling unstable features (deprecated. do not use)\"\n@@ -956,6 +1216,32 @@ impl<'tcx> LateLintPass<'tcx> for UnstableFeatures {\n }\n \n declare_lint! {\n+    /// The `unreachable_pub` lint triggers for `pub` items not reachable from\n+    /// the crate root.\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```rust,compile_fail\n+    /// #![deny(unreachable_pub)]\n+    /// mod foo {\n+    ///     pub mod bar {\n+    ///\n+    ///     }\n+    /// }\n+    /// ```\n+    ///\n+    /// {{produces}}\n+    ///\n+    /// ### Explanation\n+    ///\n+    /// A bare `pub` visibility may be misleading if the item is not actually\n+    /// publicly exported from the crate. The `pub(crate)` visibility is\n+    /// recommended to be used instead, which more clearly expresses the intent\n+    /// that the item is only visible within its own crate.\n+    ///\n+    /// This lint is \"allow\" by default because it will trigger for a large\n+    /// amount existing Rust code, and has some false-positives. Eventually it\n+    /// is desired for this to become warn-by-default.\n     pub UNREACHABLE_PUB,\n     Allow,\n     \"`pub` items not reachable from crate root\"\n@@ -1035,6 +1321,21 @@ impl<'tcx> LateLintPass<'tcx> for UnreachablePub {\n }\n \n declare_lint! {\n+    /// The `type_alias_bounds` lint detects bounds in type aliases.\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```rust\n+    /// type SendVec<T: Send> = Vec<T>;\n+    /// ```\n+    ///\n+    /// {{produces}}\n+    ///\n+    /// ### Explanation\n+    ///\n+    /// The trait bounds in a type alias are currently ignored, and should not\n+    /// be included to avoid confusion. This was previously allowed\n+    /// unintentionally; this may become a hard error in the future.\n     TYPE_ALIAS_BOUNDS,\n     Warn,\n     \"bounds in type aliases are not enforced\"\n@@ -1194,6 +1495,35 @@ impl<'tcx> LateLintPass<'tcx> for UnusedBrokenConst {\n }\n \n declare_lint! {\n+    /// The `trivial_bounds` lint detects trait bounds that don't depend on\n+    /// any type parameters.\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```rust\n+    /// #![feature(trivial_bounds)]\n+    /// pub struct A where i32: Copy;\n+    /// ```\n+    ///\n+    /// {{produces}}\n+    ///\n+    /// ### Explanation\n+    ///\n+    /// Usually you would not write a trait bound that you know is always\n+    /// true, or never true. However, when using macros, the macro may not\n+    /// know whether or not the constraint would hold or not at the time when\n+    /// generating the code. Currently, the compiler does not alert you if the\n+    /// constraint is always true, and generates an error if it is never true.\n+    /// The `trivial_bounds` feature changes this to be a warning in both\n+    /// cases, giving macros more freedom and flexibility to generate code,\n+    /// while still providing a signal when writing non-macro code that\n+    /// something is amiss.\n+    ///\n+    /// See [RFC 2056] for more details. This feature is currently only\n+    /// available on the nightly channel, see [tracking issue #48214].\n+    ///\n+    /// [RFC 2056]: https://github.com/rust-lang/rfcs/blob/master/text/2056-allow-trivial-where-clause-constraints.md\n+    /// [tracking issue #48214]: https://github.com/rust-lang/rust/issues/48214\n     TRIVIAL_BOUNDS,\n     Warn,\n     \"these bounds don't depend on an type parameters\"\n@@ -1269,6 +1599,29 @@ declare_lint_pass!(\n );\n \n declare_lint! {\n+    /// The `ellipsis_inclusive_range_patterns` lint detects the [`...` range\n+    /// pattern], which is deprecated.\n+    ///\n+    /// [`...` range pattern]: https://doc.rust-lang.org/reference/patterns.html#range-patterns\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```rust\n+    /// let x = 123;\n+    /// match x {\n+    ///     0...100 => {}\n+    ///     _ => {}\n+    /// }\n+    /// ```\n+    ///\n+    /// {{produces}}\n+    ///\n+    /// ### Explanation\n+    ///\n+    /// The `...` range pattern syntax was changed to `..=` to avoid potential\n+    /// confusion with the [`..` range expression]. Use the new form instead.\n+    ///\n+    /// [`..` range expression]: https://doc.rust-lang.org/reference/expressions/range-expr.html\n     pub ELLIPSIS_INCLUSIVE_RANGE_PATTERNS,\n     Warn,\n     \"`...` range patterns are deprecated\"\n@@ -1355,6 +1708,38 @@ impl EarlyLintPass for EllipsisInclusiveRangePatterns {\n }\n \n declare_lint! {\n+    /// The `unnameable_test_items` lint detects [`#[test]`][test] functions\n+    /// that are not able to be run by the test harness because they are in a\n+    /// position where they are not nameable.\n+    ///\n+    /// [test]: https://doc.rust-lang.org/reference/attributes/testing.html#the-test-attribute\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```rust,test\n+    /// fn main() {\n+    ///     #[test]\n+    ///     fn foo() {\n+    ///         // This test will not fail because it does not run.\n+    ///         assert_eq!(1, 2);\n+    ///     }\n+    /// }\n+    /// ```\n+    ///\n+    /// {{produces}}\n+    ///\n+    /// ### Explanation\n+    ///\n+    /// In order for the test harness to run a test, the test function must be\n+    /// located in a position where it can be accessed from the crate root.\n+    /// This generally means it must be defined in a module, and not anywhere\n+    /// else such as inside another function. The compiler previously allowed\n+    /// this without an error, so a lint was added as an alert that a test is\n+    /// not being used. Whether or not this should be allowed has not yet been\n+    /// decided, see [RFC 2471] and [issue #36629].\n+    ///\n+    /// [RFC 2471]: https://github.com/rust-lang/rfcs/pull/2471#issuecomment-397414443\n+    /// [issue #36629]: https://github.com/rust-lang/rust/issues/36629\n     UNNAMEABLE_TEST_ITEMS,\n     Warn,\n     \"detects an item that cannot be named being marked as `#[test_case]`\",\n@@ -1400,6 +1785,41 @@ impl<'tcx> LateLintPass<'tcx> for UnnameableTestItems {\n }\n \n declare_lint! {\n+    /// The `keyword_idents` lint detects edition keywords being used as an\n+    /// identifier.\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```rust,edition2015,compile_fail\n+    /// #![deny(keyword_idents)]\n+    /// // edition 2015\n+    /// fn dyn() {}\n+    /// ```\n+    ///\n+    /// {{produces}}\n+    ///\n+    /// ### Explanation\n+    ///\n+    /// Rust [editions] allow the language to evolve without breaking\n+    /// backwards compatibility. This lint catches code that uses new keywords\n+    /// that are added to the language that are used as identifiers (such as a\n+    /// variable name, function name, etc.). If you switch the compiler to a\n+    /// new edition without updating the code, then it will fail to compile if\n+    /// you are using a new keyword as an identifier.\n+    ///\n+    /// You can manually change the identifiers to a non-keyword, or use a\n+    /// [raw identifier], for example `r#dyn`, to transition to a new edition.\n+    ///\n+    /// This lint solves the problem automatically. It is \"allow\" by default\n+    /// because the code is perfectly valid in older editions. The [`cargo\n+    /// fix`] tool with the `--edition` flag will switch this lint to \"warn\"\n+    /// and automatically apply the suggested fix from the compiler (which is\n+    /// to use a raw identifier). This provides a completely automated way to\n+    /// update old code for a new edition.\n+    ///\n+    /// [editions]: https://doc.rust-lang.org/edition-guide/\n+    /// [raw identifier]: https://doc.rust-lang.org/reference/identifiers.html\n+    /// [`cargo fix`]: https://doc.rust-lang.org/cargo/commands/cargo-fix.html\n     pub KEYWORD_IDENTS,\n     Allow,\n     \"detects edition keywords being used as an identifier\",\n@@ -1801,6 +2221,26 @@ impl<'tcx> LateLintPass<'tcx> for ExplicitOutlivesRequirements {\n }\n \n declare_lint! {\n+    /// The `incomplete_features` lint detects unstable features enabled with\n+    /// the [`feature` attribute] that may function improperly in some or all\n+    /// cases.\n+    ///\n+    /// [`feature` attribute]: https://doc.rust-lang.org/nightly/unstable-book/\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```rust\n+    /// #![feature(generic_associated_types)]\n+    /// ```\n+    ///\n+    /// {{produces}}\n+    ///\n+    /// ### Explanation\n+    ///\n+    /// Although it is encouraged for people to experiment with unstable\n+    /// features, some of them are known to be incomplete or faulty. This lint\n+    /// is a signal that the feature has not yet been finished, and you may\n+    /// experience problems with it.\n     pub INCOMPLETE_FEATURES,\n     Warn,\n     \"incomplete features that may function improperly in some or all cases\"\n@@ -1841,6 +2281,36 @@ impl EarlyLintPass for IncompleteFeatures {\n }\n \n declare_lint! {\n+    /// The `invalid_value` lint detects creating a value that is not valid,\n+    /// such as a NULL reference.\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```rust,no_run\n+    /// # #![allow(unused)]\n+    /// unsafe {\n+    ///     let x: &'static i32 = std::mem::zeroed();\n+    /// }\n+    /// ```\n+    ///\n+    /// {{produces}}\n+    ///\n+    /// ### Explanation\n+    ///\n+    /// In some situations the compiler can detect that the code is creating\n+    /// an invalid value, which should be avoided.\n+    ///\n+    /// In particular, this lint will check for improper use of\n+    /// [`mem::zeroed`], [`mem::uninitialized`], [`mem::transmute`], and\n+    /// [`MaybeUninit::assume_init`] that can cause [undefined behavior]. The\n+    /// lint should provide extra information to indicate what the problem is\n+    /// and a possible solution.\n+    ///\n+    /// [`mem::zeroed`]: https://doc.rust-lang.org/std/mem/fn.zeroed.html\n+    /// [`mem::uninitialized`]: https://doc.rust-lang.org/std/mem/fn.uninitialized.html\n+    /// [`mem::transmute`]: https://doc.rust-lang.org/std/mem/fn.transmute.html\n+    /// [`MaybeUninit::assume_init`]: https://doc.rust-lang.org/std/mem/union.MaybeUninit.html#method.assume_init\n+    /// [undefined behavior]: https://doc.rust-lang.org/reference/behavior-considered-undefined.html\n     pub INVALID_VALUE,\n     Warn,\n     \"an invalid value is being created (such as a NULL reference)\"\n@@ -2072,6 +2542,40 @@ impl<'tcx> LateLintPass<'tcx> for InvalidValue {\n }\n \n declare_lint! {\n+    /// The `clashing_extern_declarations` lint detects when an `extern fn`\n+    /// has been declared with the same name but different types.\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```rust\n+    /// mod m {\n+    ///     extern \"C\" {\n+    ///         fn foo();\n+    ///     }\n+    /// }\n+    ///\n+    /// extern \"C\" {\n+    ///     fn foo(_: u32);\n+    /// }\n+    /// ```\n+    ///\n+    /// {{produces}}\n+    ///\n+    /// ### Explanation\n+    ///\n+    /// Because two symbols of the same name cannot be resolved to two\n+    /// different functions at link time, and one function cannot possibly\n+    /// have two types, a clashing extern declaration is almost certainly a\n+    /// mistake. Check to make sure that the `extern` definitions are correct\n+    /// and equivalent, and possibly consider unifying them in one location.\n+    ///\n+    /// This lint does not run between crates because a project may have\n+    /// dependencies which both rely on the same extern function, but declare\n+    /// it in a different (but valid) way. For example, they may both declare\n+    /// an opaque type for one or more of the arguments (which would end up\n+    /// distinct types), or use types that are valid conversions in the\n+    /// language the `extern fn` is defined in. In these cases, the compiler\n+    /// can't say that the clashing declaration is incorrect.\n     pub CLASHING_EXTERN_DECLARATIONS,\n     Warn,\n     \"detects when an extern fn has been declared with the same name but different types\""}, {"sha": "ecacdcde49f884163db22de403bc5e21e472ae73", "filename": "compiler/rustc_lint/src/non_ascii_idents.rs", "status": "modified", "additions": 129, "deletions": 0, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/45c1e0ae07b9581d8c2d2b39315ac7cc79475d75/compiler%2Frustc_lint%2Fsrc%2Fnon_ascii_idents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45c1e0ae07b9581d8c2d2b39315ac7cc79475d75/compiler%2Frustc_lint%2Fsrc%2Fnon_ascii_idents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fnon_ascii_idents.rs?ref=45c1e0ae07b9581d8c2d2b39315ac7cc79475d75", "patch": "@@ -4,27 +4,156 @@ use rustc_data_structures::fx::FxHashMap;\n use rustc_span::symbol::Symbol;\n \n declare_lint! {\n+    /// The `non_ascii_idents` lint detects non-ASCII identifiers.\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```rust,compile_fail\n+    /// # #![allow(unused)]\n+    /// #![feature(non_ascii_idents)]\n+    /// #![deny(non_ascii_idents)]\n+    /// fn main() {\n+    ///     let f\u00f6\u00f6 = 1;\n+    /// }\n+    /// ```\n+    ///\n+    /// {{produces}}\n+    ///\n+    /// ### Explanation\n+    ///\n+    /// Currently on stable Rust, identifiers must contain ASCII characters.\n+    /// The [`non_ascii_idents`] nightly-only feature allows identifiers to\n+    /// contain non-ASCII characters. This lint allows projects that wish to\n+    /// retain the limit of only using ASCII characters to switch this lint to\n+    /// \"forbid\" (for example to ease collaboration or for security reasons).\n+    /// See [RFC 2457] for more details.\n+    ///\n+    /// [`non_ascii_idents`]: https://doc.rust-lang.org/nightly/unstable-book/language-features/non-ascii-idents.html\n+    /// [RFC 2457]: https://github.com/rust-lang/rfcs/blob/master/text/2457-non-ascii-idents.md\n     pub NON_ASCII_IDENTS,\n     Allow,\n     \"detects non-ASCII identifiers\",\n     crate_level_only\n }\n \n declare_lint! {\n+    /// The `uncommon_codepoints` lint detects uncommon Unicode codepoints in\n+    /// identifiers.\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```rust\n+    /// # #![allow(unused)]\n+    /// #![feature(non_ascii_idents)]\n+    /// const \u00b5: f64 = 0.000001;\n+    /// ```\n+    ///\n+    /// {{produces}}\n+    ///\n+    /// ### Explanation\n+    ///\n+    /// With the [`non_ascii_idents`] nightly-only feature enabled,\n+    /// identifiers are allowed to use non-ASCII characters. This lint warns\n+    /// about using characters which are not commonly used, and may cause\n+    /// visual confusion.\n+    ///\n+    /// This lint is triggered by identifiers that contain a codepoint that is\n+    /// not part of the set of \"Allowed\" codepoints as described by [Unicode\u00ae\n+    /// Technical Standard #39 Unicode Security Mechanisms Section 3.1 General\n+    /// Security Profile for Identifiers][TR39Allowed].\n+    ///\n+    /// Note that the set of uncommon codepoints may change over time. Beware\n+    /// that if you \"forbid\" this lint that existing code may fail in the\n+    /// future.\n+    ///\n+    /// [`non_ascii_idents`]: https://doc.rust-lang.org/nightly/unstable-book/language-features/non-ascii-idents.html\n+    /// [TR39Allowed]: https://www.unicode.org/reports/tr39/#General_Security_Profile\n     pub UNCOMMON_CODEPOINTS,\n     Warn,\n     \"detects uncommon Unicode codepoints in identifiers\",\n     crate_level_only\n }\n \n declare_lint! {\n+    /// The `confusable_idents` lint detects visually confusable pairs between\n+    /// identifiers.\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```rust\n+    /// #![feature(non_ascii_idents)]\n+    ///\n+    /// // Latin Capital Letter E With Caron\n+    /// pub const \u011a: i32 = 1;\n+    /// // Latin Capital Letter E With Breve\n+    /// pub const \u0114: i32 = 2;\n+    /// ```\n+    ///\n+    /// {{produces}}\n+    ///\n+    /// ### Explanation\n+    ///\n+    /// With the [`non_ascii_idents`] nightly-only feature enabled,\n+    /// identifiers are allowed to use non-ASCII characters. This lint warns\n+    /// when different identifiers may appear visually similar, which can\n+    /// cause confusion.\n+    ///\n+    /// The confusable detection algorithm is based on [Unicode\u00ae Technical\n+    /// Standard #39 Unicode Security Mechanisms Section 4 Confusable\n+    /// Detection][TR39Confusable]. For every distinct identifier X execute\n+    /// the function `skeleton(X)`. If there exist two distinct identifiers X\n+    /// and Y in the same crate where `skeleton(X) = skeleton(Y)` report it.\n+    /// The compiler uses the same mechanism to check if an identifier is too\n+    /// similar to a keyword.\n+    ///\n+    /// Note that the set of confusable characters may change over time.\n+    /// Beware that if you \"forbid\" this lint that existing code may fail in\n+    /// the future.\n+    ///\n+    /// [`non_ascii_idents`]: https://doc.rust-lang.org/nightly/unstable-book/language-features/non-ascii-idents.html\n+    /// [TR39Confusable]: https://www.unicode.org/reports/tr39/#Confusable_Detection\n     pub CONFUSABLE_IDENTS,\n     Warn,\n     \"detects visually confusable pairs between identifiers\",\n     crate_level_only\n }\n \n declare_lint! {\n+    /// The `mixed_script_confusables` lint detects visually confusable\n+    /// characters in identifiers between different [scripts].\n+    ///\n+    /// [scripts]: https://en.wikipedia.org/wiki/Script_(Unicode)\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```rust\n+    /// #![feature(non_ascii_idents)]\n+    ///\n+    /// // The Japanese katakana character \u30a8 can be confused with the Han character \u5de5.\n+    /// const \u30a8: &'static str = \"\u30a2\u30a4\u30a6\";\n+    /// ```\n+    ///\n+    /// {{produces}}\n+    ///\n+    /// ### Explanation\n+    ///\n+    /// With the [`non_ascii_idents`] nightly-only feature enabled,\n+    /// identifiers are allowed to use non-ASCII characters. This lint warns\n+    /// when characters between different scripts may appear visually similar,\n+    /// which can cause confusion.\n+    ///\n+    /// If the crate contains other identifiers in the same script that have\n+    /// non-confusable characters, then this lint will *not* be issued. For\n+    /// example, if the example given above has another identifier with\n+    /// katakana characters (such as `let \u30ab\u30bf\u30ab\u30ca = 123;`), then this indicates\n+    /// that you are intentionally using katakana, and it will not warn about\n+    /// it.\n+    ///\n+    /// Note that the set of confusable characters may change over time.\n+    /// Beware that if you \"forbid\" this lint that existing code may fail in\n+    /// the future.\n+    ///\n+    /// [`non_ascii_idents`]: https://doc.rust-lang.org/nightly/unstable-book/language-features/non-ascii-idents.html\n     pub MIXED_SCRIPT_CONFUSABLES,\n     Warn,\n     \"detects Unicode scripts whose mixed script confusables codepoints are solely used\","}, {"sha": "24467f811726abcce9dd5f7bb6c1d4ef69aa9eb3", "filename": "compiler/rustc_lint/src/nonstandard_style.rs", "status": "modified", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/45c1e0ae07b9581d8c2d2b39315ac7cc79475d75/compiler%2Frustc_lint%2Fsrc%2Fnonstandard_style.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45c1e0ae07b9581d8c2d2b39315ac7cc79475d75/compiler%2Frustc_lint%2Fsrc%2Fnonstandard_style.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fnonstandard_style.rs?ref=45c1e0ae07b9581d8c2d2b39315ac7cc79475d75", "patch": "@@ -31,6 +31,24 @@ pub fn method_context(cx: &LateContext<'_>, id: hir::HirId) -> MethodLateContext\n }\n \n declare_lint! {\n+    /// The `non_camel_case_types` lint detects types, variants, traits and\n+    /// type parameters that don't have camel case names.\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```rust\n+    /// struct my_struct;\n+    /// ```\n+    ///\n+    /// {{produces}}\n+    ///\n+    /// ### Explanation\n+    ///\n+    /// The preferred style for these identifiers is to use \"camel case\", such\n+    /// as `MyStruct`, where the first letter should not be lowercase, and\n+    /// should not use underscores between letters. Underscores are allowed at\n+    /// the beginning and end of the identifier, as well as between\n+    /// non-letters (such as `X86_64`).\n     pub NON_CAMEL_CASE_TYPES,\n     Warn,\n     \"types, variants, traits and type parameters should have camel case names\"\n@@ -161,6 +179,22 @@ impl EarlyLintPass for NonCamelCaseTypes {\n }\n \n declare_lint! {\n+    /// The `non_snake_case` lint detects variables, methods, functions,\n+    /// lifetime parameters and modules that don't have snake case names.\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```rust\n+    /// let MY_VALUE = 5;\n+    /// ```\n+    ///\n+    /// {{produces}}\n+    ///\n+    /// ### Explanation\n+    ///\n+    /// The preferred style for these identifiers is to use \"snake case\",\n+    /// where all the characters are in lowercase, with words separated with a\n+    /// single underscore, such as `my_value`.\n     pub NON_SNAKE_CASE,\n     Warn,\n     \"variables, methods, functions, lifetime parameters and modules should have snake case names\"\n@@ -379,6 +413,21 @@ impl<'tcx> LateLintPass<'tcx> for NonSnakeCase {\n }\n \n declare_lint! {\n+    /// The `non_upper_case_globals` lint detects static items that don't have\n+    /// uppercase identifiers.\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```rust\n+    /// static max_points: i32 = 5;\n+    /// ```\n+    ///\n+    /// {{produces}}\n+    ///\n+    /// ### Explanation\n+    ///\n+    /// The preferred style is for static item names to use all uppercase\n+    /// letters such as `MAX_POINTS`.\n     pub NON_UPPER_CASE_GLOBALS,\n     Warn,\n     \"static constants should have uppercase identifiers\""}, {"sha": "a31deb87ff0d062fd37d7503a80570074642195b", "filename": "compiler/rustc_lint/src/redundant_semicolon.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/45c1e0ae07b9581d8c2d2b39315ac7cc79475d75/compiler%2Frustc_lint%2Fsrc%2Fredundant_semicolon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45c1e0ae07b9581d8c2d2b39315ac7cc79475d75/compiler%2Frustc_lint%2Fsrc%2Fredundant_semicolon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fredundant_semicolon.rs?ref=45c1e0ae07b9581d8c2d2b39315ac7cc79475d75", "patch": "@@ -4,6 +4,21 @@ use rustc_errors::Applicability;\n use rustc_span::Span;\n \n declare_lint! {\n+    /// The `redundant_semicolons` lint detects unnecessary trailing\n+    /// semicolons.\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```rust\n+    /// let _ = 123;;\n+    /// ```\n+    ///\n+    /// {{produces}}\n+    ///\n+    /// ### Explanation\n+    ///\n+    /// Extra semicolons are not needed, and may be removed to avoid confusion\n+    /// and visual clutter.\n     pub REDUNDANT_SEMICOLONS,\n     Warn,\n     \"detects unnecessary trailing semicolons\""}, {"sha": "a202efa6edadd927f370bc1a6a90c40d8b439f37", "filename": "compiler/rustc_lint/src/types.rs", "status": "modified", "additions": 106, "deletions": 0, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/45c1e0ae07b9581d8c2d2b39315ac7cc79475d75/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45c1e0ae07b9581d8c2d2b39315ac7cc79475d75/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs?ref=45c1e0ae07b9581d8c2d2b39315ac7cc79475d75", "patch": "@@ -23,18 +23,82 @@ use std::cmp;\n use tracing::debug;\n \n declare_lint! {\n+    /// The `unused_comparisons` lint detects comparisons made useless by\n+    /// limits of the types involved.\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```rust\n+    /// fn foo(x: u8) {\n+    ///     x >= 0;\n+    /// }\n+    /// ```\n+    ///\n+    /// {{produces}}\n+    ///\n+    /// ### Explanation\n+    ///\n+    /// A useless comparison may indicate a mistake, and should be fixed or\n+    /// removed.\n     UNUSED_COMPARISONS,\n     Warn,\n     \"comparisons made useless by limits of the types involved\"\n }\n \n declare_lint! {\n+    /// The `overflowing_literals` lint detects literal out of range for its\n+    /// type.\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```rust,compile_fail\n+    /// let x: u8 = 1000;\n+    /// ```\n+    ///\n+    /// {{produces}}\n+    ///\n+    /// ### Explanation\n+    ///\n+    /// It is usually a mistake to use a literal that overflows the type where\n+    /// it is used. Either use a literal that is within range, or change the\n+    /// type to be within the range of the literal.\n     OVERFLOWING_LITERALS,\n     Deny,\n     \"literal out of range for its type\"\n }\n \n declare_lint! {\n+    /// The `variant_size_differences` lint detects enums with widely varying\n+    /// variant sizes.\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```rust,compile_fail\n+    /// #![deny(variant_size_differences)]\n+    /// enum En {\n+    ///     V0(u8),\n+    ///     VBig([u8; 1024]),\n+    /// }\n+    /// ```\n+    ///\n+    /// {{produces}}\n+    ///\n+    /// ### Explanation\n+    ///\n+    /// It can be a mistake to add a variant to an enum that is much larger\n+    /// than the other variants, bloating the overall size required for all\n+    /// variants. This can impact performance and memory usage. This is\n+    /// triggered if one variant is more than 3 times larger than the\n+    /// second-largest variant.\n+    ///\n+    /// Consider placing the large variant's contents on the heap (for example\n+    /// via [`Box`]) to keep the overall size of the enum itself down.\n+    ///\n+    /// This lint is \"allow\" by default because it can be noisy, and may not be\n+    /// an actual problem. Decisions about this should be guided with\n+    /// profiling and benchmarking.\n+    ///\n+    /// [`Box`]: https://doc.rust-lang.org/std/boxed/index.html\n     VARIANT_SIZE_DIFFERENCES,\n     Allow,\n     \"detects enums with widely varying variant sizes\"\n@@ -495,6 +559,27 @@ impl<'tcx> LateLintPass<'tcx> for TypeLimits {\n }\n \n declare_lint! {\n+    /// The `improper_ctypes` lint detects incorrect use of types in foreign\n+    /// modules.\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```rust\n+    /// extern \"C\" {\n+    ///     static STATIC: String;\n+    /// }\n+    /// ```\n+    ///\n+    /// {{produces}}\n+    ///\n+    /// ### Explanation\n+    ///\n+    /// The compiler has several checks to verify that types used in `extern`\n+    /// blocks are safe and follow certain rules to ensure proper\n+    /// compatibility with the foreign interfaces. This lint is issued when it\n+    /// detects a probable mistake in a definition. The lint usually should\n+    /// provide a description of the issue, along with possibly a hint on how\n+    /// to resolve it.\n     IMPROPER_CTYPES,\n     Warn,\n     \"proper use of libc types in foreign modules\"\n@@ -503,6 +588,27 @@ declare_lint! {\n declare_lint_pass!(ImproperCTypesDeclarations => [IMPROPER_CTYPES]);\n \n declare_lint! {\n+    /// The `improper_ctypes_definitions` lint detects incorrect use of\n+    /// [`extern` function] definitions.\n+    ///\n+    /// [`extern` function]: https://doc.rust-lang.org/reference/items/functions.html#extern-function-qualifier\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```rust\n+    /// # #![allow(unused)]\n+    /// pub extern \"C\" fn str_type(p: &str) { }\n+    /// ```\n+    ///\n+    /// {{produces}}\n+    ///\n+    /// ### Explanation\n+    ///\n+    /// There are many parameter and return types that may be specified in an\n+    /// `extern` function that are not compatible with the given ABI. This\n+    /// lint is an alert that these types should not be used. The lint usually\n+    /// should provide a description of the issue, along with possibly a hint\n+    /// on how to resolve it.\n     IMPROPER_CTYPES_DEFINITIONS,\n     Warn,\n     \"proper use of libc types in foreign item definitions\""}, {"sha": "1e8c30071e762aecb5f1c06fb1c120498d58c422", "filename": "compiler/rustc_lint/src/unused.rs", "status": "modified", "additions": 146, "deletions": 0, "changes": 146, "blob_url": "https://github.com/rust-lang/rust/blob/45c1e0ae07b9581d8c2d2b39315ac7cc79475d75/compiler%2Frustc_lint%2Fsrc%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45c1e0ae07b9581d8c2d2b39315ac7cc79475d75/compiler%2Frustc_lint%2Fsrc%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Funused.rs?ref=45c1e0ae07b9581d8c2d2b39315ac7cc79475d75", "patch": "@@ -20,13 +20,69 @@ use rustc_span::{BytePos, Span, DUMMY_SP};\n use tracing::debug;\n \n declare_lint! {\n+    /// The `unused_must_use` lint detects unused result of a type flagged as\n+    /// `#[must_use]`.\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```rust\n+    /// fn returns_result() -> Result<(), ()> {\n+    ///     Ok(())\n+    /// }\n+    ///\n+    /// fn main() {\n+    ///     returns_result();\n+    /// }\n+    /// ```\n+    ///\n+    /// {{produces}}\n+    ///\n+    /// ### Explanation\n+    ///\n+    /// The `#[must_use]` attribute is an indicator that it is a mistake to\n+    /// ignore the value. See [the reference] for more details.\n+    ///\n+    /// [the reference]: https://doc.rust-lang.org/reference/attributes/diagnostics.html#the-must_use-attribute\n     pub UNUSED_MUST_USE,\n     Warn,\n     \"unused result of a type flagged as `#[must_use]`\",\n     report_in_external_macro\n }\n \n declare_lint! {\n+    /// The `unused_results` lint checks for the unused result of an\n+    /// expression in a statement.\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```rust,compile_fail\n+    /// #![deny(unused_results)]\n+    /// fn foo<T>() -> T { panic!() }\n+    ///\n+    /// fn main() {\n+    ///     foo::<usize>();\n+    /// }\n+    /// ```\n+    ///\n+    /// {{produces}}\n+    ///\n+    /// ### Explanation\n+    ///\n+    /// Ignoring the return value of a function may indicate a mistake. In\n+    /// cases were it is almost certain that the result should be used, it is\n+    /// recommended to annotate the function with the [`must_use` attribute].\n+    /// Failure to use such a return value will trigger the [`unused_must_use`\n+    /// lint] which is warn-by-default. The `unused_results` lint is\n+    /// essentially the same, but triggers for *all* return values.\n+    ///\n+    /// This lint is \"allow\" by default because it can be noisy, and may not be\n+    /// an actual problem. For example, calling the `remove` method of a `Vec`\n+    /// or `HashMap` returns the previous value, which you may not care about.\n+    /// Using this lint would require explicitly ignoring or discarding such\n+    /// values.\n+    ///\n+    /// [`must_use` attribute]: https://doc.rust-lang.org/reference/attributes/diagnostics.html#the-must_use-attribute\n+    /// [`unused_must_use` lint]: warn-by-default.html#unused-must-use\n     pub UNUSED_RESULTS,\n     Allow,\n     \"unused result of an expression in a statement\"\n@@ -265,6 +321,21 @@ impl<'tcx> LateLintPass<'tcx> for UnusedResults {\n }\n \n declare_lint! {\n+    /// The `path_statements` lint detects path statements with no effect.\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```rust\n+    /// let x = 42;\n+    ///\n+    /// x;\n+    /// ```\n+    ///\n+    /// {{produces}}\n+    ///\n+    /// ### Explanation\n+    ///\n+    /// It is usually a mistake to have a statement that has no effect.\n     pub PATH_STATEMENTS,\n     Warn,\n     \"path statements with no effect\"\n@@ -635,6 +706,21 @@ trait UnusedDelimLint {\n }\n \n declare_lint! {\n+    /// The `unused_parens` lint detects `if`, `match`, `while` and `return`\n+    /// with parentheses; they do not need them.\n+    ///\n+    /// ### Examples\n+    ///\n+    /// ```rust\n+    /// if(true) {}\n+    /// ```\n+    ///\n+    /// {{produces}}\n+    ///\n+    /// ### Explanation\n+    ///\n+    /// The parenthesis are not needed, and should be removed. This is the\n+    /// preferred style for writing these expressions.\n     pub(super) UNUSED_PARENS,\n     Warn,\n     \"`if`, `match`, `while` and `return` do not need parentheses\"\n@@ -808,6 +894,23 @@ impl EarlyLintPass for UnusedParens {\n }\n \n declare_lint! {\n+    /// The `unused_braces` lint detects unnecessary braces around an\n+    /// expression.\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```rust\n+    /// if { true } {\n+    ///     // ...\n+    /// }\n+    /// ```\n+    ///\n+    /// {{produces}}\n+    ///\n+    /// ### Explanation\n+    ///\n+    /// The braces are not needed, and should be removed. This is the\n+    /// preferred style for writing these expressions.\n     pub(super) UNUSED_BRACES,\n     Warn,\n     \"unnecessary braces around an expression\"\n@@ -929,6 +1032,30 @@ impl EarlyLintPass for UnusedBraces {\n }\n \n declare_lint! {\n+    /// The `unused_import_braces` lint catches unnecessary braces around an\n+    /// imported item.\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```rust,compile_fail\n+    /// #![deny(unused_import_braces)]\n+    /// use test::{A};\n+    ///\n+    /// pub mod test {\n+    ///     pub struct A;\n+    /// }\n+    /// # fn main() {}\n+    /// ```\n+    ///\n+    /// {{produces}}\n+    ///\n+    /// ### Explanation\n+    ///\n+    /// If there is only a single item, then remove the braces (`use test::A;`\n+    /// for example).\n+    ///\n+    /// This lint is \"allow\" by default because it is only enforcing a\n+    /// stylistic choice.\n     UNUSED_IMPORT_BRACES,\n     Allow,\n     \"unnecessary braces around an imported item\"\n@@ -978,6 +1105,25 @@ impl EarlyLintPass for UnusedImportBraces {\n }\n \n declare_lint! {\n+    /// The `unused_allocation` lint detects unnecessary allocations that can\n+    /// be eliminated.\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```rust\n+    /// #![feature(box_syntax)]\n+    /// fn main() {\n+    ///     let a = (box [1,2,3]).len();\n+    /// }\n+    /// ```\n+    ///\n+    /// {{produces}}\n+    ///\n+    /// ### Explanation\n+    ///\n+    /// When a `box` expression is immediately coerced to a reference, then\n+    /// the allocation is unnecessary, and a reference (using `&` or `&mut`)\n+    /// should be used instead to avoid the allocation.\n     pub(super) UNUSED_ALLOCATION,\n     Warn,\n     \"detects unnecessary allocations that can be eliminated\""}, {"sha": "4a3e59f18e5c0ff303083a5f9c97ac2b41c3efd0", "filename": "compiler/rustc_session/src/lint.rs", "status": "modified", "additions": 52, "deletions": 4, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/45c1e0ae07b9581d8c2d2b39315ac7cc79475d75/compiler%2Frustc_session%2Fsrc%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45c1e0ae07b9581d8c2d2b39315ac7cc79475d75/compiler%2Frustc_session%2Fsrc%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Flint.rs?ref=45c1e0ae07b9581d8c2d2b39315ac7cc79475d75", "patch": "@@ -65,9 +65,15 @@ pub struct Lint {\n     ///\n     /// The name is written with underscores, e.g., \"unused_imports\".\n     /// On the command line, underscores become dashes.\n+    ///\n+    /// See https://rustc-dev-guide.rust-lang.org/diagnostics.html#lint-naming\n+    /// for naming guidelines.\n     pub name: &'static str,\n \n     /// Default level for the lint.\n+    ///\n+    /// See https://rustc-dev-guide.rust-lang.org/diagnostics.html#diagnostic-levels\n+    /// for guidelines on choosing a default level.\n     pub default_level: Level,\n \n     /// Description of the lint or the issue it detects.\n@@ -275,17 +281,58 @@ impl LintBuffer {\n }\n \n /// Declares a static item of type `&'static Lint`.\n+///\n+/// See https://rustc-dev-guide.rust-lang.org/diagnostics.html for documentation\n+/// and guidelines on writing lints.\n+///\n+/// The macro call should start with a doc comment explaining the lint\n+/// which will be embedded in the rustc user documentation book. It should\n+/// be written in markdown and have a format that looks like this:\n+///\n+/// ```rust,ignore (doc-example)\n+/// /// The `my_lint_name` lint detects [short explanation here].\n+/// ///\n+/// /// ### Example\n+/// ///\n+/// /// ```rust\n+/// /// [insert a concise example that triggers the lint]\n+/// /// ```\n+/// ///\n+/// /// {{produces}}\n+/// ///\n+/// /// ### Explanation\n+/// ///\n+/// /// This should be a detailed explanation of *why* the lint exists,\n+/// /// and also include suggestions on how the user should fix the problem.\n+/// /// Try to keep the text simple enough that a beginner can understand,\n+/// /// and include links to other documentation for terminology that a\n+/// /// beginner may not be familiar with. If this is \"allow\" by default,\n+/// /// it should explain why (are there false positives or other issues?). If\n+/// /// this is a future-incompatible lint, it should say so, with text that\n+/// /// looks roughly like this:\n+/// ///\n+/// /// This is a [future-incompatible] lint to transition this to a hard\n+/// /// error in the future. See [issue #xxxxx] for more details.\n+/// ///\n+/// /// [issue #xxxxx]: https://github.com/rust-lang/rust/issues/xxxxx\n+/// ```\n+///\n+/// The `{{produces}}` tag will be automatically replaced with the output from\n+/// the example by the build system. You can build and view the rustc book\n+/// with `x.py doc --stage=1 src/doc/rustc --open` (use --stage=0 if just\n+/// changing the wording of an existing lint).\n #[macro_export]\n macro_rules! declare_lint {\n-    ($vis: vis $NAME: ident, $Level: ident, $desc: expr) => (\n+    ($(#[$attr:meta])* $vis: vis $NAME: ident, $Level: ident, $desc: expr) => (\n         $crate::declare_lint!(\n-            $vis $NAME, $Level, $desc,\n+            $(#[$attr])* $vis $NAME, $Level, $desc,\n         );\n     );\n-    ($vis: vis $NAME: ident, $Level: ident, $desc: expr,\n+    ($(#[$attr:meta])* $vis: vis $NAME: ident, $Level: ident, $desc: expr,\n      $(@future_incompatible = $fi:expr;)?\n      $(@feature_gate = $gate:expr;)?\n      $($v:ident),*) => (\n+        $(#[$attr])*\n         $vis static $NAME: &$crate::lint::Lint = &$crate::lint::Lint {\n             name: stringify!($NAME),\n             default_level: $crate::lint::$Level,\n@@ -298,9 +345,10 @@ macro_rules! declare_lint {\n             ..$crate::lint::Lint::default_fields_for_macro()\n         };\n     );\n-    ($vis: vis $NAME: ident, $Level: ident, $desc: expr,\n+    ($(#[$attr:meta])* $vis: vis $NAME: ident, $Level: ident, $desc: expr,\n      $lint_edition: expr => $edition_level: ident\n     ) => (\n+        $(#[$attr])*\n         $vis static $NAME: &$crate::lint::Lint = &$crate::lint::Lint {\n             name: stringify!($NAME),\n             default_level: $crate::lint::$Level,"}, {"sha": "4c0c7fae29b29012069c74ac593806a08d1a158b", "filename": "compiler/rustc_session/src/lint/builtin.rs", "status": "modified", "additions": 2118, "deletions": 0, "changes": 2118, "blob_url": "https://github.com/rust-lang/rust/blob/45c1e0ae07b9581d8c2d2b39315ac7cc79475d75/compiler%2Frustc_session%2Fsrc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45c1e0ae07b9581d8c2d2b39315ac7cc79475d75/compiler%2Frustc_session%2Fsrc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Flint%2Fbuiltin.rs?ref=45c1e0ae07b9581d8c2d2b39315ac7cc79475d75", "patch": "@@ -10,6 +10,32 @@ use rustc_span::edition::Edition;\n use rustc_span::symbol::sym;\n \n declare_lint! {\n+    /// The `ill_formed_attribute_input` lint detects ill-formed attribute\n+    /// inputs that were previously accepted and used in practice.\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```rust,compile_fail\n+    /// #[inline = \"this is not valid\"]\n+    /// fn foo() {}\n+    /// ```\n+    ///\n+    /// {{produces}}\n+    ///\n+    /// ### Explanation\n+    ///\n+    /// Previously, inputs for many built-in attributes weren't validated and\n+    /// nonsensical attribute inputs were accepted. After validation was\n+    /// added, it was determined that some existing projects made use of these\n+    /// invalid forms. This is a [future-incompatible] lint to transition this\n+    /// to a hard error in the future. See [issue #57571] for more details.\n+    ///\n+    /// Check the [attribute reference] for details on the valid inputs for\n+    /// attributes.\n+    ///\n+    /// [issue #57571]: https://github.com/rust-lang/rust/issues/57571\n+    /// [attribute reference]: https://doc.rust-lang.org/nightly/reference/attributes.html\n+    /// [future-incompatible]: ../index.md#future-incompatible-lints\n     pub ILL_FORMED_ATTRIBUTE_INPUT,\n     Deny,\n     \"ill-formed attribute inputs that were previously accepted and used in practice\",\n@@ -21,6 +47,32 @@ declare_lint! {\n }\n \n declare_lint! {\n+    /// The `conflicting_repr_hints` lint detects [`repr` attributes] with\n+    /// conflicting hints.\n+    ///\n+    /// [`repr` attributes]: https://doc.rust-lang.org/reference/type-layout.html#representations\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```rust,compile_fail\n+    /// #[repr(u32, u64)]\n+    /// enum Foo {\n+    ///     Variant1,\n+    /// }\n+    /// ```\n+    ///\n+    /// {{produces}}\n+    ///\n+    /// ### Explanation\n+    ///\n+    /// The compiler incorrectly accepted these conflicting representations in\n+    /// the past. This is a [future-incompatible] lint to transition this to a\n+    /// hard error in the future. See [issue #68585] for more details.\n+    ///\n+    /// To correct the issue, remove one of the conflicting hints.\n+    ///\n+    /// [issue #68585]: https://github.com/rust-lang/rust/issues/68585\n+    /// [future-incompatible]: ../index.md#future-incompatible-lints\n     pub CONFLICTING_REPR_HINTS,\n     Deny,\n     \"conflicts between `#[repr(..)]` hints that were previously accepted and used in practice\",\n@@ -31,160 +83,802 @@ declare_lint! {\n }\n \n declare_lint! {\n+    /// The `meta_variable_misuse` lint detects possible meta-variable misuse\n+    /// in macro definitions.\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```rust,compile_fail\n+    /// #![deny(meta_variable_misuse)]\n+    ///\n+    /// macro_rules! foo {\n+    ///     () => {};\n+    ///     ($( $i:ident = $($j:ident),+ );*) => { $( $( $i = $k; )+ )* };\n+    /// }\n+    ///\n+    /// fn main() {\n+    ///     foo!();\n+    /// }\n+    /// ```\n+    ///\n+    /// {{produces}}\n+    ///\n+    /// ### Explanation\n+    ///\n+    /// There are quite a few different ways a [`macro_rules`] macro can be\n+    /// improperly defined. Many of these errors were previously only detected\n+    /// when the macro was expanded or not at all. This lint is an attempt to\n+    /// catch some of these problems when the macro is *defined*.\n+    ///\n+    /// This lint is \"allow\" by default because it may have false positives\n+    /// and other issues. See [issue #61053] for more details.\n+    ///\n+    /// [`macro_rules`]: https://doc.rust-lang.org/reference/macros-by-example.html\n+    /// [issue #61053]: https://github.com/rust-lang/rust/issues/61053\n     pub META_VARIABLE_MISUSE,\n     Allow,\n     \"possible meta-variable misuse at macro definition\"\n }\n \n declare_lint! {\n+    /// The `incomplete_include` lint detects the use of the [`include!`]\n+    /// macro with a file that contains more than one expression.\n+    ///\n+    /// [`include!`]: https://doc.rust-lang.org/std/macro.include.html\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```rust,compile_fail\n+    /// fn main() {\n+    ///     include!(\"foo.txt\");\n+    /// }\n+    /// ```\n+    ///\n+    /// where the file `foo.txt` contains:\n+    ///\n+    /// ```text\n+    /// println!(\"hi!\");\n+    /// ```\n+    ///\n+    /// produces:\n+    ///\n+    /// ```text\n+    /// error: include macro expected single expression in source\n+    ///  --> foo.txt:1:14\n+    ///   |\n+    /// 1 | println!(\"1\");\n+    ///   |              ^\n+    ///   |\n+    ///   = note: `#[deny(incomplete_include)]` on by default\n+    /// ```\n+    ///\n+    /// ### Explanation\n+    ///\n+    /// The [`include!`] macro is currently only intended to be used to\n+    /// include a single [expression] or multiple [items]. Historically it\n+    /// would ignore any contents after the first expression, but that can be\n+    /// confusing. In the example above, the `println!` expression ends just\n+    /// before the semicolon, making the semicolon \"extra\" information that is\n+    /// ignored. Perhaps even more surprising, if the included file had\n+    /// multiple print statements, the subsequent ones would be ignored!\n+    ///\n+    /// One workaround is to place the contents in braces to create a [block\n+    /// expression]. Also consider alternatives, like using functions to\n+    /// encapsulate the expressions, or use [proc-macros].\n+    ///\n+    /// This is a lint instead of a hard error because existing projects were\n+    /// found to hit this error. To be cautious, it is a lint for now. The\n+    /// future semantics of the `include!` macro are also uncertain, see\n+    /// [issue #35560].\n+    ///\n+    /// [items]: https://doc.rust-lang.org/reference/items.html\n+    /// [expression]: https://doc.rust-lang.org/reference/expressions.html\n+    /// [block expression]: https://doc.rust-lang.org/reference/expressions/block-expr.html\n+    /// [proc-macros]: https://doc.rust-lang.org/reference/procedural-macros.html\n+    /// [issue #35560]: https://github.com/rust-lang/rust/issues/35560\n     pub INCOMPLETE_INCLUDE,\n     Deny,\n     \"trailing content in included file\"\n }\n \n declare_lint! {\n+    /// The `arithmetic_overflow` lint detects that an arithmetic operation\n+    /// will [overflow].\n+    ///\n+    /// [overflow]: https://doc.rust-lang.org/reference/expressions/operator-expr.html#overflow\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```rust,compile_fail\n+    /// 1_i32 << 32;\n+    /// ```\n+    ///\n+    /// {{produces}}\n+    ///\n+    /// ### Explanation\n+    ///\n+    /// It is very likely a mistake to perform an arithmetic operation that\n+    /// overflows its value. If the compiler is able to detect these kinds of\n+    /// overflows at compile-time, it will trigger this lint. Consider\n+    /// adjusting the expression to avoid overflow, or use a data type that\n+    /// will not overflow.\n     pub ARITHMETIC_OVERFLOW,\n     Deny,\n     \"arithmetic operation overflows\"\n }\n \n declare_lint! {\n+    /// The `unconditional_panic` lint detects an operation that will cause a\n+    /// panic at runtime.\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```rust,compile_fail\n+    /// # #![allow(unused)]\n+    /// let x = 1 / 0;\n+    /// ```\n+    ///\n+    /// {{produces}}\n+    ///\n+    /// ### Explanation\n+    ///\n+    /// This lint detects code that is very likely incorrect. When possible,\n+    /// the compiler will attempt to detect situations where code can be\n+    /// evaluated at compile-time to generate more efficient code. While\n+    /// evaluating such code, if it detects that the code will unconditionally\n+    /// panic, this usually indicates that it is doing something incorrectly.\n+    /// If this lint is allowed, then the code will not be evaluated at\n+    /// compile-time, and instead continue to generate code to evaluate at\n+    /// runtime, which may panic during runtime.\n     pub UNCONDITIONAL_PANIC,\n     Deny,\n     \"operation will cause a panic at runtime\"\n }\n \n declare_lint! {\n+    /// The `const_err` lint detects an erroneous expression while doing\n+    /// constant evaluation.\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```rust,compile_fail\n+    /// #![allow(unconditional_panic)]\n+    /// let x: &'static i32 = &(1 / 0);\n+    /// ```\n+    ///\n+    /// {{produces}}\n+    ///\n+    /// ### Explanation\n+    ///\n+    /// This lint detects code that is very likely incorrect. If this lint is\n+    /// allowed, then the code will not be evaluated at compile-time, and\n+    /// instead continue to generate code to evaluate at runtime, which may\n+    /// panic during runtime.\n+    ///\n+    /// Note that this lint may trigger in either inside or outside of a\n+    /// [const context]. Outside of a [const context], the compiler can\n+    /// sometimes evaluate an expression at compile-time in order to generate\n+    /// more efficient code. As the compiler becomes better at doing this, it\n+    /// needs to decide what to do when it encounters code that it knows for\n+    /// certain will panic or is otherwise incorrect. Making this a hard error\n+    /// would prevent existing code that exhibited this behavior from\n+    /// compiling, breaking backwards-compatibility. However, this is almost\n+    /// certainly incorrect code, so this is a deny-by-default lint. For more\n+    /// details, see [RFC 1229] and [issue #28238].\n+    ///\n+    /// Note that there are several other more specific lints associated with\n+    /// compile-time evaluation, such as [`arithmetic_overflow`],\n+    /// [`unconditional_panic`].\n+    ///\n+    /// [const context]: https://doc.rust-lang.org/reference/const_eval.html#const-context\n+    /// [RFC 1229]: https://github.com/rust-lang/rfcs/blob/master/text/1229-compile-time-asserts.md\n+    /// [issue #28238]: https://github.com/rust-lang/rust/issues/28238\n+    /// [`arithmetic_overflow`]: deny-by-default.html#arithmetic-overflow\n+    /// [`unconditional_panic`]: deny-by-default.html#unconditional-panic\n     pub CONST_ERR,\n     Deny,\n     \"constant evaluation detected erroneous expression\",\n     report_in_external_macro\n }\n \n declare_lint! {\n+    /// The `unused_imports` lint detects imports that are never used.\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```rust\n+    /// use std::collections::HashMap;\n+    /// ```\n+    ///\n+    /// {{produces}}\n+    ///\n+    /// ### Explanation\n+    ///\n+    /// Unused imports may signal a mistake or unfinished code, and clutter\n+    /// the code, and should be removed. If you intended to re-export the item\n+    /// to make it available outside of the module, add a visibility modifier\n+    /// like `pub`.\n     pub UNUSED_IMPORTS,\n     Warn,\n     \"imports that are never used\"\n }\n \n declare_lint! {\n+    /// The `unused_extern_crates` lint guards against `extern crate` items\n+    /// that are never used.\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```rust,compile_fail\n+    /// #![deny(unused_extern_crates)]\n+    /// extern crate proc_macro;\n+    /// ```\n+    ///\n+    /// {{produces}}\n+    ///\n+    /// ### Explanation\n+    ///\n+    /// `extern crate` items that are unused have no effect and should be\n+    /// removed. Note that there are some cases where specifying an `extern\n+    /// crate` is desired for the side effect of ensuring the given crate is\n+    /// linked, even though it is not otherwise directly referenced. The lint\n+    /// can be silenced by aliasing the crate to an underscore, such as\n+    /// `extern crate foo as _`. Also note that it is no longer idiomatic to\n+    /// use `extern crate` in the [2018 edition], as extern crates are now\n+    /// automatically added in scope.\n+    ///\n+    /// This lint is \"allow\" by default because it can be noisy, and produce\n+    /// false-positives. If a dependency is being removed from a project, it\n+    /// is recommended to remove it from the build configuration (such as\n+    /// `Cargo.toml`) to ensure stale build entries aren't left behind.\n+    ///\n+    /// [2018 edition]: https://doc.rust-lang.org/edition-guide/rust-2018/module-system/path-clarity.html#no-more-extern-crate\n     pub UNUSED_EXTERN_CRATES,\n     Allow,\n     \"extern crates that are never used\"\n }\n \n declare_lint! {\n+    /// The `unused_crate_dependencies` lint detects crate dependencies that\n+    /// are never used.\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```rust,compile_fail\n+    /// #![deny(unused_crate_dependencies)]\n+    /// ```\n+    ///\n+    /// This will produce:\n+    ///\n+    /// ```text\n+    /// error: external crate `regex` unused in `lint_example`: remove the dependency or add `use regex as _;`\n+    ///   |\n+    /// note: the lint level is defined here\n+    ///  --> src/lib.rs:1:9\n+    ///   |\n+    /// 1 | #![deny(unused_crate_dependencies)]\n+    ///   |         ^^^^^^^^^^^^^^^^^^^^^^^^^\n+    /// ```\n+    ///\n+    /// ### Explanation\n+    ///\n+    /// After removing the code that uses a dependency, this usually also\n+    /// requires removing the dependency from the build configuration.\n+    /// However, sometimes that step can be missed, which leads to time wasted\n+    /// building dependencies that are no longer used. This lint can be\n+    /// enabled to detect dependencies that are never used (more specifically,\n+    /// any dependency passed with the `--extern` command-line flag that is\n+    /// never referenced via [`use`], [`extern crate`], or in any [path]).\n+    ///\n+    /// This lint is \"allow\" by default because it can provide false positives\n+    /// depending on how the build system is configured. For example, when\n+    /// using Cargo, a \"package\" consists of multiple crates (such as a\n+    /// library and a binary), but the dependencies are defined for the\n+    /// package as a whole. If there is a dependency that is only used in the\n+    /// binary, but not the library, then the lint will be incorrectly issued\n+    /// in the library.\n+    ///\n+    /// [path]: https://doc.rust-lang.org/reference/paths.html\n+    /// [`use`]: https://doc.rust-lang.org/reference/items/use-declarations.html\n+    /// [`extern crate`]: https://doc.rust-lang.org/reference/items/extern-crates.html\n     pub UNUSED_CRATE_DEPENDENCIES,\n     Allow,\n     \"crate dependencies that are never used\",\n     crate_level_only\n }\n \n declare_lint! {\n+    /// The `unused_qualifications` lint detects unnecessarily qualified\n+    /// names.\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```rust,compile_fail\n+    /// #![deny(unused_qualifications)]\n+    /// mod foo {\n+    ///     pub fn bar() {}\n+    /// }\n+    ///\n+    /// fn main() {\n+    ///     use foo::bar;\n+    ///     foo::bar();\n+    /// }\n+    /// ```\n+    ///\n+    /// {{produces}}\n+    ///\n+    /// ### Explanation\n+    ///\n+    /// If an item from another module is already brought into scope, then\n+    /// there is no need to qualify it in this case. You can call `bar()`\n+    /// directly, without the `foo::`.\n+    ///\n+    /// This lint is \"allow\" by default because it is somewhat pedantic, and\n+    /// doesn't indicate an actual problem, but rather a stylistic choice, and\n+    /// can be noisy when refactoring or moving around code.\n     pub UNUSED_QUALIFICATIONS,\n     Allow,\n     \"detects unnecessarily qualified names\"\n }\n \n declare_lint! {\n+    /// The `unknown_lints` lint detects unrecognized lint attribute.\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```rust\n+    /// #![allow(not_a_real_lint)]\n+    /// ```\n+    ///\n+    /// {{produces}}\n+    ///\n+    /// ### Explanation\n+    ///\n+    /// It is usually a mistake to specify a lint that does not exist. Check\n+    /// the spelling, and check the lint listing for the correct name. Also\n+    /// consider if you are using an old version of the compiler, and the lint\n+    /// is only available in a newer version.\n     pub UNKNOWN_LINTS,\n     Warn,\n     \"unrecognized lint attribute\"\n }\n \n declare_lint! {\n+    /// The `unused_variables` lint detects variables which are not used in\n+    /// any way.\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```rust\n+    /// let x = 5;\n+    /// ```\n+    ///\n+    /// {{produces}}\n+    ///\n+    /// ### Explanation\n+    ///\n+    /// Unused variables may signal a mistake or unfinished code. To silence\n+    /// the warning for the individual variable, prefix it with an underscore\n+    /// such as `_x`.\n     pub UNUSED_VARIABLES,\n     Warn,\n     \"detect variables which are not used in any way\"\n }\n \n declare_lint! {\n+    /// The `unused_assignments` lint detects assignments that will never be read.\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```rust\n+    /// let mut x = 5;\n+    /// x = 6;\n+    /// ```\n+    ///\n+    /// {{produces}}\n+    ///\n+    /// ### Explanation\n+    ///\n+    /// Unused assignments may signal a mistake or unfinished code. If the\n+    /// variable is never used after being assigned, then the assignment can\n+    /// be removed. Variables with an underscore prefix such as `_x` will not\n+    /// trigger this lint.\n     pub UNUSED_ASSIGNMENTS,\n     Warn,\n     \"detect assignments that will never be read\"\n }\n \n declare_lint! {\n+    /// The `dead_code` lint detects unused, unexported items.\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```rust\n+    /// fn foo() {}\n+    /// ```\n+    ///\n+    /// {{produces}}\n+    ///\n+    /// ### Explanation\n+    ///\n+    /// Dead code may signal a mistake or unfinished code. To silence the\n+    /// warning for individual items, prefix the name with an underscore such\n+    /// as `_foo`. If it was intended to expose the item outside of the crate,\n+    /// consider adding a visibility modifier like `pub`. Otherwise consider\n+    /// removing the unused code.\n     pub DEAD_CODE,\n     Warn,\n     \"detect unused, unexported items\"\n }\n \n declare_lint! {\n+    /// The `unused_attributes` lint detects attributes that were not used by\n+    /// the compiler.\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```rust\n+    /// #![macro_export]\n+    /// ```\n+    ///\n+    /// {{produces}}\n+    ///\n+    /// ### Explanation\n+    ///\n+    /// Unused [attributes] may indicate the attribute is placed in the wrong\n+    /// position. Consider removing it, or placing it in the correct position.\n+    /// Also consider if you intended to use an _inner attribute_ (with a `!`\n+    /// such as `#![allow(unused)]`) which applies to the item the attribute\n+    /// is within, or an _outer attribute_ (without a `!` such as\n+    /// `#[allow(unsued)]`) which applies to the item *following* the\n+    /// attribute.\n+    ///\n+    /// [attributes]: https://doc.rust-lang.org/reference/attributes.html\n     pub UNUSED_ATTRIBUTES,\n     Warn,\n     \"detects attributes that were not used by the compiler\"\n }\n \n declare_lint! {\n+    /// The `unreachable_code` lint detects unreachable code paths.\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```rust,no_run\n+    /// panic!(\"we never go past here!\");\n+    ///\n+    /// let x = 5;\n+    /// ```\n+    ///\n+    /// {{produces}}\n+    ///\n+    /// ### Explanation\n+    ///\n+    /// Unreachable code may signal a mistake or unfinished code. If the code\n+    /// is no longer in use, consider removing it.\n     pub UNREACHABLE_CODE,\n     Warn,\n     \"detects unreachable code paths\",\n     report_in_external_macro\n }\n \n declare_lint! {\n+    /// The `unreachable_patterns` lint detects unreachable patterns.\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```rust\n+    /// let x = 5;\n+    /// match x {\n+    ///     y => (),\n+    ///     5 => (),\n+    /// }\n+    /// ```\n+    ///\n+    /// {{produces}}\n+    ///\n+    /// ### Explanation\n+    ///\n+    /// This usually indicates a mistake in how the patterns are specified or\n+    /// ordered. In this example, the `y` pattern will always match, so the\n+    /// five is impossible to reach. Remember, match arms match in order, you\n+    /// probably wanted to put the `5` case above the `y` case.\n     pub UNREACHABLE_PATTERNS,\n     Warn,\n     \"detects unreachable patterns\"\n }\n \n declare_lint! {\n+    /// The `overlapping_patterns` lint detects `match` arms that have\n+    /// [range patterns] that overlap.\n+    ///\n+    /// [range patterns]: https://doc.rust-lang.org/nightly/reference/patterns.html#range-patterns\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```rust\n+    /// let x = 123u8;\n+    /// match x {\n+    ///     0..=100 => { println!(\"small\"); }\n+    ///     100..=255 => { println!(\"large\"); }\n+    /// }\n+    /// ```\n+    ///\n+    /// {{produces}}\n+    ///\n+    /// ### Explanation\n+    ///\n+    /// It is likely a mistake to have range patterns in a match expression\n+    /// that overlap. Check that the beginning and end values are what you\n+    /// expect, and keep in mind that with `..=` the left and right bounds are\n+    /// inclusive.\n     pub OVERLAPPING_PATTERNS,\n     Warn,\n     \"detects overlapping patterns\"\n }\n \n declare_lint! {\n+    /// The `bindings_with_variant_name` lint detects pattern bindings with\n+    /// the same name as one of the matched variants.\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```rust\n+    /// pub enum Enum {\n+    ///     Foo,\n+    ///     Bar,\n+    /// }\n+    ///\n+    /// pub fn foo(x: Enum) {\n+    ///     match x {\n+    ///         Foo => {}\n+    ///         Bar => {}\n+    ///     }\n+    /// }\n+    /// ```\n+    ///\n+    /// {{produces}}\n+    ///\n+    /// ### Explanation\n+    ///\n+    /// It is usually a mistake to specify an enum variant name as an\n+    /// [identifier pattern]. In the example above, the `match` arms are\n+    /// specifying a variable name to bind the value of `x` to. The second arm\n+    /// is ignored because the first one matches *all* values. The likely\n+    /// intent is that the arm was intended to match on the enum variant.\n+    ///\n+    /// Two possible solutions are:\n+    ///\n+    /// * Specify the enum variant using a [path pattern], such as\n+    ///   `Enum::Foo`.\n+    /// * Bring the enum variants into local scope, such as adding `use\n+    ///   Enum::*;` to the beginning of the `foo` function in the example\n+    ///   above.\n+    ///\n+    /// [identifier pattern]: https://doc.rust-lang.org/reference/patterns.html#identifier-patterns\n+    /// [path pattern]: https://doc.rust-lang.org/reference/patterns.html#path-patterns\n     pub BINDINGS_WITH_VARIANT_NAME,\n     Warn,\n     \"detects pattern bindings with the same name as one of the matched variants\"\n }\n \n declare_lint! {\n+    /// The `unused_macros` lint detects macros that were not used.\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```rust\n+    /// macro_rules! unused {\n+    ///     () => {};\n+    /// }\n+    ///\n+    /// fn main() {\n+    /// }\n+    /// ```\n+    ///\n+    /// {{produces}}\n+    ///\n+    /// ### Explanation\n+    ///\n+    /// Unused macros may signal a mistake or unfinished code. To silence the\n+    /// warning for the individual macro, prefix the name with an underscore\n+    /// such as `_my_macro`. If you intended to export the macro to make it\n+    /// available outside of the crate, use the [`macro_export` attribute].\n+    ///\n+    /// [`macro_export` attribute]: https://doc.rust-lang.org/reference/macros-by-example.html#path-based-scope\n     pub UNUSED_MACROS,\n     Warn,\n     \"detects macros that were not used\"\n }\n \n declare_lint! {\n+    /// The `warnings` lint allows you to change the level of other\n+    /// lints which produce warnings.\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```rust\n+    /// #![deny(warnings)]\n+    /// fn foo() {}\n+    /// ```\n+    ///\n+    /// {{produces}}\n+    ///\n+    /// ### Explanation\n+    ///\n+    /// The `warnings` lint is a bit special; by changing its level, you\n+    /// change every other warning that would produce a warning to whatever\n+    /// value you'd like. As such, you won't ever trigger this lint in your\n+    /// code directly.\n     pub WARNINGS,\n     Warn,\n     \"mass-change the level for lints which produce warnings\"\n }\n \n declare_lint! {\n+    /// The `unused_features` lint detects unused or unknown features found in\n+    /// crate-level [`feature` attributes].\n+    ///\n+    /// [`feature` attributes]: https://doc.rust-lang.org/nightly/unstable-book/\n+    ///\n+    /// Note: This lint is currently not functional, see [issue #44232] for\n+    /// more details.\n+    ///\n+    /// [issue #44232]: https://github.com/rust-lang/rust/issues/44232\n     pub UNUSED_FEATURES,\n     Warn,\n     \"unused features found in crate-level `#[feature]` directives\"\n }\n \n declare_lint! {\n+    /// The `stable_features` lint detects a [`feature` attribute] that\n+    /// has since been made stable.\n+    ///\n+    /// [`feature` attribute]: https://doc.rust-lang.org/nightly/unstable-book/\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```rust\n+    /// #![feature(test_accepted_feature)]\n+    /// fn main() {}\n+    /// ```\n+    ///\n+    /// {{produces}}\n+    ///\n+    /// ### Explanation\n+    ///\n+    /// When a feature is stabilized, it is no longer necessary to include a\n+    /// `#![feature]` attribute for it. To fix, simply remove the\n+    /// `#![feature]` attribute.\n     pub STABLE_FEATURES,\n     Warn,\n     \"stable features found in `#[feature]` directive\"\n }\n \n declare_lint! {\n+    /// The `unknown_crate_types` lint detects an unknown crate type found in\n+    /// a [`crate_type` attribute].\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```rust,compile_fail\n+    /// #![crate_type=\"lol\"]\n+    /// fn main() {}\n+    /// ```\n+    ///\n+    /// {{produces}}\n+    ///\n+    /// ### Explanation\n+    ///\n+    /// An unknown value give to the `crate_type` attribute is almost\n+    /// certainly a mistake.\n+    ///\n+    /// [`crate_type` attribute]: https://doc.rust-lang.org/reference/linkage.html\n     pub UNKNOWN_CRATE_TYPES,\n     Deny,\n     \"unknown crate type found in `#[crate_type]` directive\",\n     crate_level_only\n }\n \n declare_lint! {\n+    /// The `trivial_casts` lint detects trivial casts which could be replaced\n+    /// with coercion, which may require [type ascription] or a temporary\n+    /// variable.\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```rust,compile_fail\n+    /// #![deny(trivial_casts)]\n+    /// let x: &u32 = &42;\n+    /// let y = x as *const u32;\n+    /// ```\n+    ///\n+    /// {{produces}}\n+    ///\n+    /// ### Explanation\n+    ///\n+    /// A trivial cast is a cast `e as T` where `e` has type `U` and `U` is a\n+    /// subtype of `T`. This type of cast is usually unnecessary, as it can be\n+    /// usually be inferred.\n+    ///\n+    /// This lint is \"allow\" by default because there are situations, such as\n+    /// with FFI interfaces or complex type aliases, where it triggers\n+    /// incorrectly, or in situations where it will be more difficult to\n+    /// clearly express the intent. It may be possible that this will become a\n+    /// warning in the future, possibly with [type ascription] providing a\n+    /// convenient way to work around the current issues. See [RFC 401] for\n+    /// historical context.\n+    ///\n+    /// [type ascription]: https://github.com/rust-lang/rust/issues/23416\n+    /// [RFC 401]: https://github.com/rust-lang/rfcs/blob/master/text/0401-coercions.md\n     pub TRIVIAL_CASTS,\n     Allow,\n     \"detects trivial casts which could be removed\"\n }\n \n declare_lint! {\n+    /// The `trivial_numeric_casts` lint detects trivial numeric casts of types\n+    /// which could be removed.\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```rust,compile_fail\n+    /// #![deny(trivial_numeric_casts)]\n+    /// let x = 42_i32 as i32;\n+    /// ```\n+    ///\n+    /// {{produces}}\n+    ///\n+    /// ### Explanation\n+    ///\n+    /// A trivial numeric cast is a cast of a numeric type to the same numeric\n+    /// type. This type of cast is usually unnecessary.\n+    ///\n+    /// This lint is \"allow\" by default because there are situations, such as\n+    /// with FFI interfaces or complex type aliases, where it triggers\n+    /// incorrectly, or in situations where it will be more difficult to\n+    /// clearly express the intent. It may be possible that this will become a\n+    /// warning in the future, possibly with [type ascription] providing a\n+    /// convenient way to work around the current issues. See [RFC 401] for\n+    /// historical context.\n+    ///\n+    /// [type ascription]: https://github.com/rust-lang/rust/issues/23416\n+    /// [RFC 401]: https://github.com/rust-lang/rfcs/blob/master/text/0401-coercions.md\n     pub TRIVIAL_NUMERIC_CASTS,\n     Allow,\n     \"detects trivial casts of numeric types which could be removed\"\n }\n \n declare_lint! {\n+    /// The `private_in_public` lint detects private items in public\n+    /// interfaces not caught by the old implementation.\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```rust\n+    /// # #![allow(unused)]\n+    /// struct SemiPriv;\n+    ///\n+    /// mod m1 {\n+    ///     struct Priv;\n+    ///     impl super::SemiPriv {\n+    ///         pub fn f(_: Priv) {}\n+    ///     }\n+    /// }\n+    /// # fn main() {}\n+    /// ```\n+    ///\n+    /// {{produces}}\n+    ///\n+    /// ### Explanation\n+    ///\n+    /// The visibility rules are intended to prevent exposing private items in\n+    /// public interfaces. This is a [future-incompatible] lint to transition\n+    /// this to a hard error in the future. See [issue #34537] for more\n+    /// details.\n+    ///\n+    /// [issue #34537]: https://github.com/rust-lang/rust/issues/34537\n+    /// [future-incompatible]: ../index.md#future-incompatible-lints\n     pub PRIVATE_IN_PUBLIC,\n     Warn,\n     \"detect private items in public interfaces not caught by the old implementation\",\n@@ -195,12 +889,76 @@ declare_lint! {\n }\n \n declare_lint! {\n+    /// The `exported_private_dependencies` lint detects private dependencies\n+    /// that are exposed in a public interface.\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```rust,ignore (needs-dependency)\n+    /// pub fn foo() -> Option<some_private_dependency::Thing> {\n+    ///     None\n+    /// }\n+    /// ```\n+    ///\n+    /// This will produce:\n+    ///\n+    /// ```text\n+    /// warning: type `bar::Thing` from private dependency 'bar' in public interface\n+    ///  --> src/lib.rs:3:1\n+    ///   |\n+    /// 3 | pub fn foo() -> Option<bar::Thing> {\n+    ///   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+    ///   |\n+    ///   = note: `#[warn(exported_private_dependencies)]` on by default\n+    /// ```\n+    ///\n+    /// ### Explanation\n+    ///\n+    /// Dependencies can be marked as \"private\" to indicate that they are not\n+    /// exposed in the public interface of a crate. This can be used by Cargo\n+    /// to independently resolve those dependencies because it can assume it\n+    /// does not need to unify them with other packages using that same\n+    /// dependency. This lint is an indication of a violation of that\n+    /// contract.\n+    ///\n+    /// To fix this, avoid exposing the dependency in your public interface.\n+    /// Or, switch the dependency to a public dependency.\n+    ///\n+    /// Note that support for this is only available on the nightly channel.\n+    /// See [RFC 1977] for more details, as well as the [Cargo documentation].\n+    ///\n+    /// [RFC 1977]: https://github.com/rust-lang/rfcs/blob/master/text/1977-public-private-dependencies.md\n+    /// [Cargo documentation]: https://doc.rust-lang.org/nightly/cargo/reference/unstable.html#public-dependency\n     pub EXPORTED_PRIVATE_DEPENDENCIES,\n     Warn,\n     \"public interface leaks type from a private dependency\"\n }\n \n declare_lint! {\n+    /// The `pub_use_of_private_extern_crate` lint detects a specific\n+    /// situation of re-exporting a private `extern crate`.\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```rust,compile_fail\n+    /// extern crate core;\n+    /// pub use core as reexported_core;\n+    /// ```\n+    ///\n+    /// {{produces}}\n+    ///\n+    /// ### Explanation\n+    ///\n+    /// A public `use` declaration should not be used to publicly re-export a\n+    /// private `extern crate`. `pub extern crate` should be used instead.\n+    ///\n+    /// This was historically allowed, but is not the intended behavior\n+    /// according to the visibility rules. This is a [future-incompatible]\n+    /// lint to transition this to a hard error in the future. See [issue\n+    /// #34537] for more details.\n+    ///\n+    /// [issue #34537]: https://github.com/rust-lang/rust/issues/34537\n+    /// [future-incompatible]: ../index.md#future-incompatible-lints\n     pub PUB_USE_OF_PRIVATE_EXTERN_CRATE,\n     Deny,\n     \"detect public re-exports of private extern crates\",\n@@ -211,6 +969,26 @@ declare_lint! {\n }\n \n declare_lint! {\n+    /// The `invalid_type_param_default` lint detects type parameter defaults\n+    /// erroneously allowed in an invalid location.\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```rust,compile_fail\n+    /// fn foo<T=i32>(t: T) {}\n+    /// ```\n+    ///\n+    /// {{produces}}\n+    ///\n+    /// ### Explanation\n+    ///\n+    /// Default type parameters were only intended to be allowed in certain\n+    /// situations, but historically the compiler allowed them everywhere.\n+    /// This is a [future-incompatible] lint to transition this to a hard\n+    /// error in the future. See [issue #36887] for more details.\n+    ///\n+    /// [issue #36887]: https://github.com/rust-lang/rust/issues/36887\n+    /// [future-incompatible]: ../index.md#future-incompatible-lints\n     pub INVALID_TYPE_PARAM_DEFAULT,\n     Deny,\n     \"type parameter default erroneously allowed in invalid location\",\n@@ -221,24 +999,174 @@ declare_lint! {\n }\n \n declare_lint! {\n+    /// The `renamed_and_removed_lints` lint detects lints that have been\n+    /// renamed or removed.\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```rust\n+    /// #![deny(raw_pointer_derive)]\n+    /// ```\n+    ///\n+    /// {{produces}}\n+    ///\n+    /// ### Explanation\n+    ///\n+    /// To fix this, either remove the lint or use the new name. This can help\n+    /// avoid confusion about lints that are no longer valid, and help\n+    /// maintain consistency for renamed lints.\n     pub RENAMED_AND_REMOVED_LINTS,\n     Warn,\n     \"lints that have been renamed or removed\"\n }\n \n declare_lint! {\n+    /// The `unaligned_references` lint detects unaligned references to fields\n+    /// of [packed] structs.\n+    ///\n+    /// [packed]: https://doc.rust-lang.org/reference/type-layout.html#the-alignment-modifiers\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```rust,compile_fail\n+    /// #![deny(unaligned_references)]\n+    ///\n+    /// #[repr(packed)]\n+    /// pub struct Foo {\n+    ///     field1: u64,\n+    ///     field2: u8,\n+    /// }\n+    ///\n+    /// fn main() {\n+    ///     unsafe {\n+    ///         let foo = Foo { field1: 0, field2: 0 };\n+    ///         let _ = &foo.field1;\n+    ///     }\n+    /// }\n+    /// ```\n+    ///\n+    /// {{produces}}\n+    ///\n+    /// ### Explanation\n+    ///\n+    /// Creating a reference to an insufficiently aligned packed field is\n+    /// [undefined behavior] and should be disallowed.\n+    ///\n+    /// This lint is \"allow\" by default because there is no stable\n+    /// alternative, and it is not yet certain how widespread existing code\n+    /// will trigger this lint.\n+    ///\n+    /// See [issue #27060] for more discussion.\n+    ///\n+    /// [undefined behavior]: https://doc.rust-lang.org/reference/behavior-considered-undefined.html\n+    /// [issue #27060]: https://github.com/rust-lang/rust/issues/27060\n     pub UNALIGNED_REFERENCES,\n     Allow,\n     \"detects unaligned references to fields of packed structs\",\n }\n \n declare_lint! {\n+    /// The `const_item_mutation` lint detects attempts to mutate a `const`\n+    /// item.\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```rust\n+    /// const FOO: [i32; 1] = [0];\n+    ///\n+    /// fn main() {\n+    ///     FOO[0] = 1;\n+    ///     // This will print \"[0]\".\n+    ///     println!(\"{:?}\", FOO);\n+    /// }\n+    /// ```\n+    ///\n+    /// {{produces}}\n+    ///\n+    /// ### Explanation\n+    ///\n+    /// Trying to directly mutate a `const` item is almost always a mistake.\n+    /// What is happening in the example above is that a temporary copy of the\n+    /// `const` is mutated, but the original `const` is not. Each time you\n+    /// refer to the `const` by name (such as `FOO` in the example above), a\n+    /// separate copy of the value is inlined at that location.\n+    ///\n+    /// This lint checks for writing directly to a field (`FOO.field =\n+    /// some_value`) or array entry (`FOO[0] = val`), or taking a mutable\n+    /// reference to the const item (`&mut FOO`), including through an\n+    /// autoderef (`FOO.some_mut_self_method()`).\n+    ///\n+    /// There are various alternatives depending on what you are trying to\n+    /// accomplish:\n+    ///\n+    /// * First, always reconsider using mutable globals, as they can be\n+    ///   difficult to use correctly, and can make the code more difficult to\n+    ///   use or understand.\n+    /// * If you are trying to perform a one-time initialization of a global:\n+    ///     * If the value can be computed at compile-time, consider using\n+    ///       const-compatible values (see [Constant Evaluation]).\n+    ///     * For more complex single-initialization cases, consider using a\n+    ///       third-party crate, such as [`lazy_static`] or [`once_cell`].\n+    ///     * If you are using the [nightly channel], consider the new\n+    ///       [`lazy`] module in the standard library.\n+    /// * If you truly need a mutable global, consider using a [`static`],\n+    ///   which has a variety of options:\n+    ///   * Simple data types can be directly defined and mutated with an\n+    ///     [`atomic`] type.\n+    ///   * More complex types can be placed in a synchronization primitive\n+    ///     like a [`Mutex`], which can be initialized with one of the options\n+    ///     listed above.\n+    ///   * A [mutable `static`] is a low-level primitive, requiring unsafe.\n+    ///     Typically This should be avoided in preference of something\n+    ///     higher-level like one of the above.\n+    ///\n+    /// [Constant Evaluation]: https://doc.rust-lang.org/reference/const_eval.html\n+    /// [`static`]: https://doc.rust-lang.org/reference/items/static-items.html\n+    /// [mutable `static`]: https://doc.rust-lang.org/reference/items/static-items.html#mutable-statics\n+    /// [`lazy`]: https://doc.rust-lang.org/nightly/std/lazy/index.html\n+    /// [`lazy_static`]: https://crates.io/crates/lazy_static\n+    /// [`once_cell`]: https://crates.io/crates/once_cell\n+    /// [`atomic`]: https://doc.rust-lang.org/std/sync/atomic/index.html\n+    /// [`Mutex`]: https://doc.rust-lang.org/std/sync/struct.Mutex.html\n     pub CONST_ITEM_MUTATION,\n     Warn,\n     \"detects attempts to mutate a `const` item\",\n }\n \n declare_lint! {\n+    /// The `safe_packed_borrows` lint detects borrowing a field in the\n+    /// interior of a packed structure with alignment other than 1.\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```rust\n+    /// #[repr(packed)]\n+    /// pub struct Unaligned<T>(pub T);\n+    ///\n+    /// pub struct Foo {\n+    ///     start: u8,\n+    ///     data: Unaligned<u32>,\n+    /// }\n+    ///\n+    /// fn main() {\n+    ///     let x = Foo { start: 0, data: Unaligned(1) };\n+    ///     let y = &x.data.0;\n+    /// }\n+    /// ```\n+    ///\n+    /// {{produces}}\n+    ///\n+    /// ### Explanation\n+    ///\n+    /// This type of borrow is unsafe and can cause errors on some platforms\n+    /// and violates some assumptions made by the compiler. This was\n+    /// previously allowed unintentionally. This is a [future-incompatible]\n+    /// lint to transition this to a hard error in the future. See [issue\n+    /// #46043] for more details, including guidance on how to solve the\n+    /// problem.\n+    ///\n+    /// [issue #46043]: https://github.com/rust-lang/rust/issues/46043\n+    /// [future-incompatible]: ../index.md#future-incompatible-lints\n     pub SAFE_PACKED_BORROWS,\n     Warn,\n     \"safe borrows of fields of packed structs were erroneously allowed\",\n@@ -249,6 +1177,49 @@ declare_lint! {\n }\n \n declare_lint! {\n+    /// The `patterns_in_fns_without_body` lint detects `mut` identifier\n+    /// patterns as a parameter in functions without a body.\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```rust,compile_fail\n+    /// trait Trait {\n+    ///     fn foo(mut arg: u8);\n+    /// }\n+    /// ```\n+    ///\n+    /// {{produces}}\n+    ///\n+    /// ### Explanation\n+    ///\n+    /// To fix this, remove `mut` from the parameter in the trait definition;\n+    /// it can be used in the implementation. That is, the following is OK:\n+    ///\n+    /// ```rust\n+    /// trait Trait {\n+    ///     fn foo(arg: u8); // Removed `mut` here\n+    /// }\n+    ///\n+    /// impl Trait for i32 {\n+    ///     fn foo(mut arg: u8) { // `mut` here is OK\n+    ///\n+    ///     }\n+    /// }\n+    /// ```\n+    ///\n+    /// Trait definitions can define functions without a body to specify a\n+    /// function that implementors must define. The parameter names in the\n+    /// body-less functions are only allowed to be `_` or an [identifier] for\n+    /// documentation purposes (only the type is relevant). Previous versions\n+    /// of the compiler erroneously allowed [identifier patterns] with the\n+    /// `mut` keyword, but this was not intended to be allowed. This is a\n+    /// [future-incompatible] lint to transition this to a hard error in the\n+    /// future. See [issue #35203] for more details.\n+    ///\n+    /// [identifier]: https://doc.rust-lang.org/reference/identifiers.html\n+    /// [identifier patterns]: https://doc.rust-lang.org/reference/patterns.html#identifier-patterns\n+    /// [issue #35203]: https://github.com/rust-lang/rust/issues/35203\n+    /// [future-incompatible]: ../index.md#future-incompatible-lints\n     pub PATTERNS_IN_FNS_WITHOUT_BODY,\n     Deny,\n     \"patterns in functions without body were erroneously allowed\",\n@@ -259,6 +1230,38 @@ declare_lint! {\n }\n \n declare_lint! {\n+    /// The `late_bound_lifetime_arguments` lint detects generic lifetime\n+    /// arguments in path segments with late bound lifetime parameters.\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```rust\n+    /// struct S;\n+    ///\n+    /// impl S {\n+    ///     fn late<'a, 'b>(self, _: &'a u8, _: &'b u8) {}\n+    /// }\n+    ///\n+    /// fn main() {\n+    ///     S.late::<'static>(&0, &0);\n+    /// }\n+    /// ```\n+    ///\n+    /// {{produces}}\n+    ///\n+    /// ### Explanation\n+    ///\n+    /// It is not clear how to provide arguments for early-bound lifetime\n+    /// parameters if they are intermixed with late-bound parameters in the\n+    /// same list. For now, providing any explicit arguments will trigger this\n+    /// lint if late-bound parameters are present, so in the future a solution\n+    /// can be adopted without hitting backward compatibility issues. This is\n+    /// a [future-incompatible] lint to transition this to a hard error in the\n+    /// future. See [issue #42868] for more details, along with a description\n+    /// of the difference between early and late-bound parameters.\n+    ///\n+    /// [issue #42868]: https://github.com/rust-lang/rust/issues/42868\n+    /// [future-incompatible]: ../index.md#future-incompatible-lints\n     pub LATE_BOUND_LIFETIME_ARGUMENTS,\n     Warn,\n     \"detects generic lifetime arguments in path segments with late bound lifetime parameters\",\n@@ -269,6 +1272,32 @@ declare_lint! {\n }\n \n declare_lint! {\n+    /// The `order_dependent_trait_objects` lint detects a trait coherency\n+    /// violation that would allow creating two trait impls for the same\n+    /// dynamic trait object involving marker traits.\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```rust,compile_fail\n+    /// pub trait Trait {}\n+    ///\n+    /// impl Trait for dyn Send + Sync { }\n+    /// impl Trait for dyn Sync + Send { }\n+    /// ```\n+    ///\n+    /// {{produces}}\n+    ///\n+    /// ### Explanation\n+    ///\n+    /// A previous bug caused the compiler to interpret traits with different\n+    /// orders (such as `Send + Sync` and `Sync + Send`) as distinct types\n+    /// when they were intended to be treated the same. This allowed code to\n+    /// define separate trait implementations when there should be a coherence\n+    /// error. This is a [future-incompatible] lint to transition this to a\n+    /// hard error in the future. See [issue #56484] for more details.\n+    ///\n+    /// [issue #56484]: https://github.com/rust-lang/rust/issues/56484\n+    /// [future-incompatible]: ../index.md#future-incompatible-lints\n     pub ORDER_DEPENDENT_TRAIT_OBJECTS,\n     Deny,\n     \"trait-object types were treated as different depending on marker-trait order\",\n@@ -279,6 +1308,36 @@ declare_lint! {\n }\n \n declare_lint! {\n+    /// The `coherence_leak_check` lint detects conflicting implementations of\n+    /// a trait that are only distinguished by the old leak-check code.\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```rust\n+    /// trait SomeTrait { }\n+    /// impl SomeTrait for for<'a> fn(&'a u8) { }\n+    /// impl<'a> SomeTrait for fn(&'a u8) { }\n+    /// ```\n+    ///\n+    /// {{produces}}\n+    ///\n+    /// ### Explanation\n+    ///\n+    /// In the past, the compiler would accept trait implementations for\n+    /// identical functions that differed only in where the lifetime binder\n+    /// appeared. Due to a change in the borrow checker implementation to fix\n+    /// several bugs, this is no longer allowed. However, since this affects\n+    /// existing code, this is a [future-incompatible] lint to transition this\n+    /// to a hard error in the future.\n+    ///\n+    /// Code relying on this pattern should introduce \"[newtypes]\",\n+    /// like `struct Foo(for<'a> fn(&'a u8))`.\n+    ///\n+    /// See [issue #56105] for more details.\n+    ///\n+    /// [issue #56105]: https://github.com/rust-lang/rust/issues/56105\n+    /// [newtypes]: https://doc.rust-lang.org/book/ch19-04-advanced-types.html#using-the-newtype-pattern-for-type-safety-and-abstraction\n+    /// [future-incompatible]: ../index.md#future-incompatible-lints\n     pub COHERENCE_LEAK_CHECK,\n     Warn,\n     \"distinct impls distinguished only by the leak-check code\",\n@@ -289,43 +1348,188 @@ declare_lint! {\n }\n \n declare_lint! {\n+    /// The `deprecated` lint detects use of deprecated items.\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```rust\n+    /// #[deprecated]\n+    /// fn foo() {}\n+    ///\n+    /// fn bar() {\n+    ///     foo();\n+    /// }\n+    /// ```\n+    ///\n+    /// {{produces}}\n+    ///\n+    /// ### Explanation\n+    ///\n+    /// Items may be marked \"deprecated\" with the [`deprecated` attribute] to\n+    /// indicate that they should no longer be used. Usually the attribute\n+    /// should include a note on what to use instead, or check the\n+    /// documentation.\n+    ///\n+    /// [`deprecated` attribute]: https://doc.rust-lang.org/reference/attributes/diagnostics.html#the-deprecated-attribute\n     pub DEPRECATED,\n     Warn,\n     \"detects use of deprecated items\",\n     report_in_external_macro\n }\n \n declare_lint! {\n+    /// The `unused_unsafe` lint detects unnecessary use of an `unsafe` block.\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```rust\n+    /// unsafe {}\n+    /// ```\n+    ///\n+    /// {{produces}}\n+    ///\n+    /// ### Explanation\n+    ///\n+    /// If nothing within the block requires `unsafe`, then remove the\n+    /// `unsafe` marker because it is not required and may cause confusion.\n     pub UNUSED_UNSAFE,\n     Warn,\n     \"unnecessary use of an `unsafe` block\"\n }\n \n declare_lint! {\n+    /// The `unused_mut` lint detects mut variables which don't need to be\n+    /// mutable.\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```rust\n+    /// let mut x = 5;\n+    /// ```\n+    ///\n+    /// {{produces}}\n+    ///\n+    /// ### Explanation\n+    ///\n+    /// The preferred style is to only mark variables as `mut` if it is\n+    /// required.\n     pub UNUSED_MUT,\n     Warn,\n     \"detect mut variables which don't need to be mutable\"\n }\n \n declare_lint! {\n+    /// The `unconditional_recursion` lint detects functions that cannot\n+    /// return without calling themselves.\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```rust\n+    /// fn foo() {\n+    ///     foo();\n+    /// }\n+    /// ```\n+    ///\n+    /// {{produces}}\n+    ///\n+    /// ### Explanation\n+    ///\n+    /// It is usually a mistake to have a recursive call that does not have\n+    /// some condition to cause it to terminate. If you really intend to have\n+    /// an infinite loop, using a `loop` expression is recommended.\n     pub UNCONDITIONAL_RECURSION,\n     Warn,\n     \"functions that cannot return without calling themselves\"\n }\n \n declare_lint! {\n+    /// The `single_use_lifetimes` lint detects lifetimes that are only used\n+    /// once.\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```rust,compile_fail\n+    /// #![deny(single_use_lifetimes)]\n+    ///\n+    /// fn foo<'a>(x: &'a u32) {}\n+    /// ```\n+    ///\n+    /// {{produces}}\n+    ///\n+    /// ### Explanation\n+    ///\n+    /// Specifying an explicit lifetime like `'a` in a function or `impl`\n+    /// should only be used to link together two things. Otherwise, you should\n+    /// just use `'_` to indicate that the lifetime is not linked to anything,\n+    /// or elide the lifetime altogether if possible.\n+    ///\n+    /// This lint is \"allow\" by default because it was introduced at a time\n+    /// when `'_` and elided lifetimes were first being introduced, and this\n+    /// lint would be too noisy. Also, there are some known false positives\n+    /// that it produces. See [RFC 2115] for historical context, and [issue\n+    /// #44752] for more details.\n+    ///\n+    /// [RFC 2115]: https://github.com/rust-lang/rfcs/blob/master/text/2115-argument-lifetimes.md\n+    /// [issue #44752]: https://github.com/rust-lang/rust/issues/44752\n     pub SINGLE_USE_LIFETIMES,\n     Allow,\n     \"detects lifetime parameters that are only used once\"\n }\n \n declare_lint! {\n+    /// The `unused_lifetimes` lint detects lifetime parameters that are never\n+    /// used.\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```rust,compile_fail\n+    /// #[deny(unused_lifetimes)]\n+    ///\n+    /// pub fn foo<'a>() {}\n+    /// ```\n+    ///\n+    /// {{produces}}\n+    ///\n+    /// ### Explanation\n+    ///\n+    /// Unused lifetime parameters may signal a mistake or unfinished code.\n+    /// Consider removing the parameter.\n     pub UNUSED_LIFETIMES,\n     Allow,\n     \"detects lifetime parameters that are never used\"\n }\n \n declare_lint! {\n+    /// The `tyvar_behind_raw_pointer` lint detects raw pointer to an\n+    /// inference variable.\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```rust,edition2015\n+    /// // edition 2015\n+    /// let data = std::ptr::null();\n+    /// let _ = &data as *const *const ();\n+    ///\n+    /// if data.is_null() {}\n+    /// ```\n+    ///\n+    /// {{produces}}\n+    ///\n+    /// ### Explanation\n+    ///\n+    /// This kind of inference was previously allowed, but with the future\n+    /// arrival of [arbitrary self types], this can introduce ambiguity. To\n+    /// resolve this, use an explicit type instead of relying on type\n+    /// inference.\n+    ///\n+    /// This is a [future-incompatible] lint to transition this to a hard\n+    /// error in the 2018 edition. See [issue #46906] for more details. This\n+    /// is currently a hard-error on the 2018 edition, and is \"warn\" by\n+    /// default in the 2015 edition.\n+    ///\n+    /// [arbitrary self types]: https://github.com/rust-lang/rust/issues/44874\n+    /// [issue #46906]: https://github.com/rust-lang/rust/issues/46906\n+    /// [future-incompatible]: ../index.md#future-incompatible-lints\n     pub TYVAR_BEHIND_RAW_POINTER,\n     Warn,\n     \"raw pointer to an inference variable\",\n@@ -336,19 +1540,113 @@ declare_lint! {\n }\n \n declare_lint! {\n+    /// The `elided_lifetimes_in_paths` lint detects the use of hidden\n+    /// lifetime parameters.\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```rust,compile_fail\n+    /// #![deny(elided_lifetimes_in_paths)]\n+    /// struct Foo<'a> {\n+    ///     x: &'a u32\n+    /// }\n+    ///\n+    /// fn foo(x: &Foo) {\n+    /// }\n+    /// ```\n+    ///\n+    /// {{produces}}\n+    ///\n+    /// ### Explanation\n+    ///\n+    /// Elided lifetime parameters can make it difficult to see at a glance\n+    /// that borrowing is occurring. This lint ensures that lifetime\n+    /// parameters are always explicitly stated, even if it is the `'_`\n+    /// [placeholder lifetime].\n+    ///\n+    /// This lint is \"allow\" by default because it has some known issues, and\n+    /// may require a significant transition for old code.\n+    ///\n+    /// [placeholder lifetime]: https://doc.rust-lang.org/reference/lifetime-elision.html#lifetime-elision-in-functions\n     pub ELIDED_LIFETIMES_IN_PATHS,\n     Allow,\n     \"hidden lifetime parameters in types are deprecated\",\n     crate_level_only\n }\n \n declare_lint! {\n+    /// The `bare_trait_objects` lint suggests using `dyn Trait` for trait\n+    /// objects.\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```rust\n+    /// trait Trait { }\n+    ///\n+    /// fn takes_trait_object(_: Box<Trait>) {\n+    /// }\n+    /// ```\n+    ///\n+    /// {{produces}}\n+    ///\n+    /// ### Explanation\n+    ///\n+    /// Without the `dyn` indicator, it can be ambiguous or confusing when\n+    /// reading code as to whether or not you are looking at a trait object.\n+    /// The `dyn` keyword makes it explicit, and adds a symmetry to contrast\n+    /// with [`impl Trait`].\n+    ///\n+    /// [`impl Trait`]: https://doc.rust-lang.org/book/ch10-02-traits.html#traits-as-parameters\n     pub BARE_TRAIT_OBJECTS,\n     Warn,\n     \"suggest using `dyn Trait` for trait objects\"\n }\n \n declare_lint! {\n+    /// The `absolute_paths_not_starting_with_crate` lint detects fully\n+    /// qualified paths that start with a module name instead of `crate`,\n+    /// `self`, or an extern crate name\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```rust,edition2015,compile_fail\n+    /// #![deny(absolute_paths_not_starting_with_crate)]\n+    ///\n+    /// mod foo {\n+    ///     pub fn bar() {}\n+    /// }\n+    ///\n+    /// fn main() {\n+    ///     ::foo::bar();\n+    /// }\n+    /// ```\n+    ///\n+    /// {{produces}}\n+    ///\n+    /// ### Explanation\n+    ///\n+    /// Rust [editions] allow the language to evolve without breaking\n+    /// backwards compatibility. This lint catches code that uses absolute\n+    /// paths in the style of the 2015 edition. In the 2015 edition, absolute\n+    /// paths (those starting with `::`) refer to either the crate root or an\n+    /// external crate. In the 2018 edition it was changed so that they only\n+    /// refer to external crates. The path prefix `crate::` should be used\n+    /// instead to reference items from the crate root.\n+    ///\n+    /// If you switch the compiler from the 2015 to 2018 edition without\n+    /// updating the code, then it will fail to compile if the old style paths\n+    /// are used. You can manually change the paths to use the `crate::`\n+    /// prefix to transition to the 2018 edition.\n+    ///\n+    /// This lint solves the problem automatically. It is \"allow\" by default\n+    /// because the code is perfectly valid in the 2015 edition. The [`cargo\n+    /// fix`] tool with the `--edition` flag will switch this lint to \"warn\"\n+    /// and automatically apply the suggested fix from the compiler. This\n+    /// provides a completely automated way to update old code to the 2018\n+    /// edition.\n+    ///\n+    /// [editions]: https://doc.rust-lang.org/edition-guide/\n+    /// [`cargo fix`]: https://doc.rust-lang.org/cargo/commands/cargo-fix.html\n     pub ABSOLUTE_PATHS_NOT_STARTING_WITH_CRATE,\n     Allow,\n     \"fully qualified paths that start with a module name \\\n@@ -360,6 +1658,45 @@ declare_lint! {\n }\n \n declare_lint! {\n+    /// The `illegal_floating_point_literal_pattern` lint detects\n+    /// floating-point literals used in patterns.\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```rust\n+    /// let x = 42.0;\n+    ///\n+    /// match x {\n+    ///     5.0 => {}\n+    ///     _ => {}\n+    /// }\n+    /// ```\n+    ///\n+    /// {{produces}}\n+    ///\n+    /// ### Explanation\n+    ///\n+    /// Previous versions of the compiler accepted floating-point literals in\n+    /// patterns, but it was later determined this was a mistake. The\n+    /// semantics of comparing floating-point values may not be clear in a\n+    /// pattern when contrasted with \"structural equality\". Typically you can\n+    /// work around this by using a [match guard], such as:\n+    ///\n+    /// ```rust\n+    /// # let x = 42.0;\n+    ///\n+    /// match x {\n+    ///     y if y == 5.0 => {}\n+    ///     _ => {}\n+    /// }\n+    /// ```\n+    ///\n+    /// This is a [future-incompatible] lint to transition this to a hard\n+    /// error in the future. See [issue #41620] for more details.\n+    ///\n+    /// [issue #41620]: https://github.com/rust-lang/rust/issues/41620\n+    /// [match guard]: https://doc.rust-lang.org/reference/expressions/match-expr.html#match-guards\n+    /// [future-incompatible]: ../index.md#future-incompatible-lints\n     pub ILLEGAL_FLOATING_POINT_LITERAL_PATTERN,\n     Warn,\n     \"floating-point literals cannot be used in patterns\",\n@@ -370,6 +1707,40 @@ declare_lint! {\n }\n \n declare_lint! {\n+    /// The `unstable_name_collisions` lint detects that you have used a name\n+    /// that the standard library plans to add in the future.\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```rust\n+    /// trait MyIterator : Iterator {\n+    ///     // is_sorted is an unstable method that already exists on the Iterator trait\n+    ///     fn is_sorted(self) -> bool where Self: Sized {true}\n+    /// }\n+    ///\n+    /// impl<T: ?Sized> MyIterator for T where T: Iterator { }\n+    ///\n+    /// let x = vec![1,2,3];\n+    /// let _ = x.iter().is_sorted();\n+    /// ```\n+    ///\n+    /// {{produces}}\n+    ///\n+    /// ### Explanation\n+    ///\n+    /// When new methods are added to traits in the standard library, they are\n+    /// usually added in an \"unstable\" form which is only available on the\n+    /// [nightly channel] with a [`feature` attribute]. If there is any\n+    /// pre-existing code which extends a trait to have a method with the same\n+    /// name, then the names will collide. In the future, when the method is\n+    /// stabilized, this will cause an error due to the ambiguity. This lint\n+    /// is an early-warning to let you know that there may be a collision in\n+    /// the future. This can be avoided by adding type annotations to\n+    /// disambiguate which trait method you intend to call, such as\n+    /// `MyIterator::is_sorted(my_iter)` or renaming or removing the method.\n+    ///\n+    /// [nightly channel]: https://doc.rust-lang.org/book/appendix-07-nightly-rust.html\n+    /// [`feature` attribute]: https://doc.rust-lang.org/nightly/unstable-book/\n     pub UNSTABLE_NAME_COLLISIONS,\n     Warn,\n     \"detects name collision with an existing but unstable method\",\n@@ -382,48 +1753,267 @@ declare_lint! {\n }\n \n declare_lint! {\n+    /// The `irrefutable_let_patterns` lint detects detects [irrefutable\n+    /// patterns] in [if-let] and [while-let] statements.\n+    ///\n+    ///\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```rust\n+    /// if let _ = 123 {\n+    ///     println!(\"always runs!\");\n+    /// }\n+    /// ```\n+    ///\n+    /// {{produces}}\n+    ///\n+    /// ### Explanation\n+    ///\n+    /// There usually isn't a reason to have an irrefutable pattern in an\n+    /// if-let or while-let statement, because the pattern will always match\n+    /// successfully. A [`let`] or [`loop`] statement will suffice. However,\n+    /// when generating code with a macro, forbidding irrefutable patterns\n+    /// would require awkward workarounds in situations where the macro\n+    /// doesn't know if the pattern is refutable or not. This lint allows\n+    /// macros to accept this form, while alerting for a possibly incorrect\n+    /// use in normal code.\n+    ///\n+    /// See [RFC 2086] for more details.\n+    ///\n+    /// [irrefutable patterns]: https://doc.rust-lang.org/reference/patterns.html#refutability\n+    /// [if-let]: https://doc.rust-lang.org/reference/expressions/if-expr.html#if-let-expressions\n+    /// [while-let]: https://doc.rust-lang.org/reference/expressions/loop-expr.html#predicate-pattern-loops\n+    /// [`let`]: https://doc.rust-lang.org/reference/statements.html#let-statements\n+    /// [`loop`]: https://doc.rust-lang.org/reference/expressions/loop-expr.html#infinite-loops\n+    /// [RFC 2086]: https://github.com/rust-lang/rfcs/blob/master/text/2086-allow-if-let-irrefutables.md\n     pub IRREFUTABLE_LET_PATTERNS,\n     Warn,\n     \"detects irrefutable patterns in if-let and while-let statements\"\n }\n \n declare_lint! {\n+    /// The `unused_labels` lint detects [labels] that are never used.\n+    ///\n+    /// [labels]: https://doc.rust-lang.org/reference/expressions/loop-expr.html#loop-labels\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```rust,no_run\n+    /// 'unused_label: loop {}\n+    /// ```\n+    ///\n+    /// {{produces}}\n+    ///\n+    /// ### Explanation\n+    ///\n+    /// Unused labels may signal a mistake or unfinished code. To silence the\n+    /// warning for the individual label, prefix it with an underscore such as\n+    /// `'_my_label:`.\n     pub UNUSED_LABELS,\n     Warn,\n     \"detects labels that are never used\"\n }\n \n declare_lint! {\n+    /// The `broken_intra_doc_links` lint detects failures in resolving\n+    /// intra-doc link targets. This is a `rustdoc` only lint, and only works\n+    /// on the [**nightly channel**].\n+    ///\n+    /// [**nightly channel**]: https://doc.rust-lang.org/book/appendix-07-nightly-rust.html\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```rust,rustdoc\n+    /// /// This is a doc comment.\n+    /// ///\n+    /// /// See also [`bar`].\n+    /// pub fn foo() {\n+    /// }\n+    /// ```\n+    ///\n+    /// {{produces}}\n+    ///\n+    /// ### Explanation\n+    ///\n+    /// `rustdoc` allows [linking to items by name][intra] which will\n+    /// automatically generate links in the documentation to the item. This\n+    /// lint is issued when `rustdoc` is unable to find the named item. Check\n+    /// that the name is correct, that it is in scope, or if you need to\n+    /// qualify it with a path. If you intended to have square brackets appear\n+    /// literally in the text, surround the brackets with backticks such as ``\n+    /// `[example]` `` to indicate a code span, or prefix it with a backslash\n+    /// such as `\\[example]`.\n+    ///\n+    /// [intra]: https://doc.rust-lang.org/nightly/rustdoc/unstable-features.html#linking-to-items-by-name\n     pub BROKEN_INTRA_DOC_LINKS,\n     Warn,\n     \"failures in resolving intra-doc link targets\"\n }\n \n declare_lint! {\n+    /// The `invalid_codeblock_attributes` lint detects code block attributes\n+    /// in documentation examples that have potentially mis-typed values. This\n+    /// is a `rustdoc` only lint.\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```rust,rustdoc\n+    /// /// Example.\n+    /// ///\n+    /// /// ```should-panic\n+    /// /// assert_eq!(1, 2);\n+    /// /// ```\n+    /// pub fn foo() {}\n+    /// ```\n+    ///\n+    /// {{produces}}\n+    ///\n+    /// ### Explanation\n+    ///\n+    /// This lint is issued when `rustdoc` detects an example code block\n+    /// attribute that appears similar to a valid one. In the example above,\n+    /// the correct form is `should_panic`. This helps detect typo mistakes\n+    /// for some common attributes.\n     pub INVALID_CODEBLOCK_ATTRIBUTES,\n     Warn,\n     \"codeblock attribute looks a lot like a known one\"\n }\n \n declare_lint! {\n+    /// The `missing_crate_level_docs` lint detects if documentation is\n+    /// missing at the crate root. This is a `rustdoc` only lint. This is a\n+    /// `rustdoc` only lint.\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```rust,rustdoc\n+    /// #![deny(missing_crate_level_docs)]\n+    /// ```\n+    ///\n+    /// {{produces}}\n+    ///\n+    /// ### Explanation\n+    ///\n+    /// This lint causes `rustdoc` to check if the crate root is missing\n+    /// documentation. This is currently \"allow\" by default, but it is\n+    /// intended to make this a warning in the future. This is intended as a\n+    /// means to introduce new users on *how* to document their crate by\n+    /// pointing them to some instructions on how to get started.\n     pub MISSING_CRATE_LEVEL_DOCS,\n     Allow,\n     \"detects crates with no crate-level documentation\"\n }\n \n declare_lint! {\n+    /// The `missing_doc_code_examples` lint detects publicly-exported items\n+    /// without code samples in their documentation. This is a `rustdoc` only\n+    /// lint, and only works on the [**nightly channel**].\n+    ///\n+    /// [**nightly channel**]: https://doc.rust-lang.org/book/appendix-07-nightly-rust.html\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```rust,rustdoc\n+    /// #![warn(missing_doc_code_examples)]\n+    ///\n+    /// /// There is no code example!\n+    /// pub fn no_code_example() {}\n+    /// ```\n+    ///\n+    /// {{produces}}\n+    ///\n+    /// ### Explanation\n+    ///\n+    /// This lint is to ensure a high level of quality for documentation. Code\n+    /// examples can be very useful to see how to use an API. To add an\n+    /// example, include a markdown code block with an example of how to use\n+    /// the item, such as:\n+    ///\n+    /// ```rust\n+    /// /// Adds one to the number given.\n+    /// ///\n+    /// /// # Examples\n+    /// ///\n+    /// /// ```\n+    /// /// let arg = 5;\n+    /// /// let answer = my_crate::add_one(arg);\n+    /// ///\n+    /// /// assert_eq!(6, answer);\n+    /// /// ```\n+    /// pub fn add_one(x: i32) -> i32 {\n+    ///     x + 1\n+    /// }\n+    /// ```\n     pub MISSING_DOC_CODE_EXAMPLES,\n     Allow,\n     \"detects publicly-exported items without code samples in their documentation\"\n }\n \n declare_lint! {\n+    /// The `private_doc_tests` lint detects code samples in docs of private\n+    /// items not documented by `rustdoc`. This is a `rustdoc` only lint.\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```rust,rustdoc\n+    /// #![deny(private_doc_tests)]\n+    ///\n+    /// mod foo {\n+    ///     /// private doc test\n+    ///     ///\n+    ///     /// ```\n+    ///     /// assert!(false);\n+    ///     /// ```\n+    ///     fn bar() {}\n+    /// }\n+    /// ```\n+    ///\n+    /// {{produces}}\n+    ///\n+    /// ### Explanation\n+    ///\n+    /// Because documentation examples link against the public API of the\n+    /// crate, it is not possible for an example to access a private item.\n+    /// This means it was likely a mistake to add a code example to a private\n+    /// item.\n     pub PRIVATE_DOC_TESTS,\n     Allow,\n     \"detects code samples in docs of private items not documented by rustdoc\"\n }\n \n declare_lint! {\n+    /// The `where_clauses_object_safety` lint detects for [object safety] of\n+    /// [where clauses].\n+    ///\n+    /// [object safety]: https://doc.rust-lang.org/reference/items/traits.html#object-safety\n+    /// [where clauses]: https://doc.rust-lang.org/reference/items/generics.html#where-clauses\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```rust,no_run\n+    /// trait Trait {}\n+    ///\n+    /// trait X { fn foo(&self) where Self: Trait; }\n+    ///\n+    /// impl X for () { fn foo(&self) {} }\n+    ///\n+    /// impl Trait for dyn X {}\n+    ///\n+    /// // Segfault at opt-level 0, SIGILL otherwise.\n+    /// pub fn main() { <dyn X as X>::foo(&()); }\n+    /// ```\n+    ///\n+    /// {{produces}}\n+    ///\n+    /// ### Explanation\n+    ///\n+    /// The compiler previously allowed these object-unsafe bounds, which was\n+    /// incorrect. This is a [future-incompatible] lint to transition this to\n+    /// a hard error in the future. See [issue #51443] for more details.\n+    ///\n+    /// [issue #51443]: https://github.com/rust-lang/rust/issues/51443\n+    /// [future-incompatible]: ../index.md#future-incompatible-lints\n     pub WHERE_CLAUSES_OBJECT_SAFETY,\n     Warn,\n     \"checks the object safety of where clauses\",\n@@ -434,6 +2024,63 @@ declare_lint! {\n }\n \n declare_lint! {\n+    /// The `proc_macro_derive_resolution_fallback` lint detects proc macro\n+    /// derives using inaccessible names from parent modules.\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```rust,ignore (proc-macro)\n+    /// // foo.rs\n+    /// #![crate_type = \"proc-macro\"]\n+    ///\n+    /// extern crate proc_macro;\n+    ///\n+    /// use proc_macro::*;\n+    ///\n+    /// #[proc_macro_derive(Foo)]\n+    /// pub fn foo1(a: TokenStream) -> TokenStream {\n+    ///     drop(a);\n+    ///     \"mod __bar { static mut BAR: Option<Something> = None; }\".parse().unwrap()\n+    /// }\n+    /// ```\n+    ///\n+    /// ```rust,ignore (needs-dependency)\n+    /// // bar.rs\n+    /// #[macro_use]\n+    /// extern crate foo;\n+    ///\n+    /// struct Something;\n+    ///\n+    /// #[derive(Foo)]\n+    /// struct Another;\n+    ///\n+    /// fn main() {}\n+    /// ```\n+    ///\n+    /// This will produce:\n+    ///\n+    /// ```text\n+    /// warning: cannot find type `Something` in this scope\n+    ///  --> src/main.rs:8:10\n+    ///   |\n+    /// 8 | #[derive(Foo)]\n+    ///   |          ^^^ names from parent modules are not accessible without an explicit import\n+    ///   |\n+    ///   = note: `#[warn(proc_macro_derive_resolution_fallback)]` on by default\n+    ///   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+    ///   = note: for more information, see issue #50504 <https://github.com/rust-lang/rust/issues/50504>\n+    /// ```\n+    ///\n+    /// ### Explanation\n+    ///\n+    /// If a proc-macro generates a module, the compiler unintentionally\n+    /// allowed items in that module to refer to items in the crate root\n+    /// without importing them. This is a [future-incompatible] lint to\n+    /// transition this to a hard error in the future. See [issue #50504] for\n+    /// more details.\n+    ///\n+    /// [issue #50504]: https://github.com/rust-lang/rust/issues/50504\n+    /// [future-incompatible]: ../index.md#future-incompatible-lints\n     pub PROC_MACRO_DERIVE_RESOLUTION_FALLBACK,\n     Warn,\n     \"detects proc macro derives using inaccessible names from parent modules\",\n@@ -444,13 +2091,98 @@ declare_lint! {\n }\n \n declare_lint! {\n+    /// The `macro_use_extern_crate` lint detects the use of the\n+    /// [`macro_use` attribute].\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```rust,compile_fail\n+    /// #![deny(macro_use_extern_crate)]\n+    ///\n+    /// #[macro_use]\n+    /// extern crate serde_json;\n+    ///\n+    /// fn main() {\n+    ///     let _ = json!{{}};\n+    /// }\n+    /// ```\n+    ///\n+    /// This will produce:\n+    ///\n+    /// ```text\n+    /// error: deprecated `#[macro_use]` attribute used to import macros should be replaced at use sites with a `use` item to import the macro instead\n+    ///  --> src/main.rs:3:1\n+    ///   |\n+    /// 3 | #[macro_use]\n+    ///   | ^^^^^^^^^^^^\n+    ///   |\n+    /// note: the lint level is defined here\n+    ///  --> src/main.rs:1:9\n+    ///   |\n+    /// 1 | #![deny(macro_use_extern_crate)]\n+    ///   |         ^^^^^^^^^^^^^^^^^^^^^^\n+    /// ```\n+    ///\n+    /// ### Explanation\n+    ///\n+    /// The [`macro_use` attribute] on an [`extern crate`] item causes\n+    /// macros in that external crate to be brought into the prelude of the\n+    /// crate, making the macros in scope everywhere. As part of the efforts\n+    /// to simplify handling of dependencies in the [2018 edition], the use of\n+    /// `extern crate` is being phased out. To bring macros from extern crates\n+    /// into scope, it is recommended to use a [`use` import].\n+    ///\n+    /// This lint is \"allow\" by default because this is a stylistic choice\n+    /// that has not been settled, see [issue #52043] for more information.\n+    ///\n+    /// [`macro_use` attribute]: https://doc.rust-lang.org/reference/macros-by-example.html#the-macro_use-attribute\n+    /// [`use` import]: https://doc.rust-lang.org/reference/items/use-declarations.html\n+    /// [issue #52043]: https://github.com/rust-lang/rust/issues/52043\n     pub MACRO_USE_EXTERN_CRATE,\n     Allow,\n     \"the `#[macro_use]` attribute is now deprecated in favor of using macros \\\n      via the module system\"\n }\n \n declare_lint! {\n+    /// The `macro_expanded_macro_exports_accessed_by_absolute_paths` lint\n+    /// detects macro-expanded [`macro_export`] macros from the current crate\n+    /// that cannot be referred to by absolute paths.\n+    ///\n+    /// [`macro_export`]: https://doc.rust-lang.org/reference/macros-by-example.html#path-based-scope\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```rust,compile_fail\n+    /// macro_rules! define_exported {\n+    ///     () => {\n+    ///         #[macro_export]\n+    ///         macro_rules! exported {\n+    ///             () => {};\n+    ///         }\n+    ///     };\n+    /// }\n+    ///\n+    /// define_exported!();\n+    ///\n+    /// fn main() {\n+    ///     crate::exported!();\n+    /// }\n+    /// ```\n+    ///\n+    /// {{produces}}\n+    ///\n+    /// ### Explanation\n+    ///\n+    /// The intent is that all macros marked with the `#[macro_export]`\n+    /// attribute are made available in the root of the crate. However, when a\n+    /// `macro_rules!` definition is generated by another macro, the macro\n+    /// expansion is unable to uphold this rule. This is a\n+    /// [future-incompatible] lint to transition this to a hard error in the\n+    /// future. See [issue #53495] for more details.\n+    ///\n+    /// [issue #53495]: https://github.com/rust-lang/rust/issues/53495\n+    /// [future-incompatible]: ../index.md#future-incompatible-lints\n     pub MACRO_EXPANDED_MACRO_EXPORTS_ACCESSED_BY_ABSOLUTE_PATHS,\n     Deny,\n     \"macro-expanded `macro_export` macros from the current crate \\\n@@ -463,12 +2195,92 @@ declare_lint! {\n }\n \n declare_lint! {\n+    /// The `explicit_outlives_requirements` lint detects unnecessary\n+    /// lifetime bounds that can be inferred.\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```rust,compile_fail\n+    /// # #![allow(unused)]\n+    /// #![deny(explicit_outlives_requirements)]\n+    ///\n+    /// struct SharedRef<'a, T>\n+    /// where\n+    ///     T: 'a,\n+    /// {\n+    ///     data: &'a T,\n+    /// }\n+    /// ```\n+    ///\n+    /// {{produces}}\n+    ///\n+    /// ### Explanation\n+    ///\n+    /// If a `struct` contains a reference, such as `&'a T`, the compiler\n+    /// requires that `T` outlives the lifetime `'a`. This historically\n+    /// required writing an explicit lifetime bound to indicate this\n+    /// requirement. However, this can be overly explicit, causing clutter and\n+    /// unnecessary complexity. The language was changed to automatically\n+    /// infer the bound if it is not specified. Specifically, if the struct\n+    /// contains a reference, directly or indirectly, to `T` with lifetime\n+    /// `'x`, then it will infer that `T: 'x` is a requirement.\n+    ///\n+    /// This lint is \"allow\" by default because it can be noisy for existing\n+    /// code that already had these requirements. This is a stylistic choice,\n+    /// as it is still valid to explicitly state the bound. It also has some\n+    /// false positives that can cause confusion.\n+    ///\n+    /// See [RFC 2093] for more details.\n+    ///\n+    /// [RFC 2093]: https://github.com/rust-lang/rfcs/blob/master/text/2093-infer-outlives.md\n     pub EXPLICIT_OUTLIVES_REQUIREMENTS,\n     Allow,\n     \"outlives requirements can be inferred\"\n }\n \n declare_lint! {\n+    /// The `indirect_structural_match` lint detects a `const` in a pattern\n+    /// that manually implements [`PartialEq`] and [`Eq`].\n+    ///\n+    /// [`PartialEq`]: https://doc.rust-lang.org/std/cmp/trait.PartialEq.html\n+    /// [`Eq`]: https://doc.rust-lang.org/std/cmp/trait.Eq.html\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```rust,compile_fail\n+    /// #![deny(indirect_structural_match)]\n+    ///\n+    /// struct Plus(i32, i32);\n+    /// const ONE_PLUS_TWO: &&Plus = &&Plus(1, 2);\n+    ///\n+    /// impl PartialEq for Plus {\n+    ///     fn eq(&self, other: &Self) -> bool {\n+    ///         self.0 + self.1 == other.0 + other.1\n+    ///     }\n+    /// }\n+    ///\n+    /// impl Eq for Plus {}\n+    ///\n+    /// fn main() {\n+    ///     if let ONE_PLUS_TWO = &&Plus(3, 0) {\n+    ///         println!(\"semantic!\");\n+    ///     } else {\n+    ///         println!(\"structural!\");\n+    ///     }\n+    /// }\n+    /// ```\n+    ///\n+    /// {{produces}}\n+    ///\n+    /// ### Explanation\n+    ///\n+    /// The compiler unintentionally accepted this form in the past. This is a\n+    /// [future-incompatible] lint to transition this to a hard error in the\n+    /// future. See [issue #62411] for a complete description of the problem,\n+    /// and some possible solutions.\n+    ///\n+    /// [issue #62411]: https://github.com/rust-lang/rust/issues/62411\n+    /// [future-incompatible]: ../index.md#future-incompatible-lints\n     pub INDIRECT_STRUCTURAL_MATCH,\n     // defaulting to allow until rust-lang/rust#62614 is fixed.\n     Allow,\n@@ -480,13 +2292,72 @@ declare_lint! {\n }\n \n declare_lint! {\n+    /// The `deprecated_in_future` lint is internal to rustc and should not be\n+    /// used by user code.\n+    ///\n+    /// This lint is only enabled in the standard library. It works with the\n+    /// use of `#[rustc_deprecated]` with a `since` field of a version in the\n+    /// future. This allows something to be marked as deprecated in a future\n+    /// version, and then this lint will ensure that the item is no longer\n+    /// used in the standard library. See the [stability documentation] for\n+    /// more details.\n+    ///\n+    /// [stability documentation]: https://rustc-dev-guide.rust-lang.org/stability.html#rustc_deprecated\n     pub DEPRECATED_IN_FUTURE,\n     Allow,\n     \"detects use of items that will be deprecated in a future version\",\n     report_in_external_macro\n }\n \n declare_lint! {\n+    /// The `ambiguous_associated_items` lint detects ambiguity between\n+    /// [associated items] and [enum variants].\n+    ///\n+    /// [associated items]: https://doc.rust-lang.org/reference/items/associated-items.html\n+    /// [enum variants]: https://doc.rust-lang.org/reference/items/enumerations.html\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```rust,compile_fail\n+    /// enum E {\n+    ///     V\n+    /// }\n+    ///\n+    /// trait Tr {\n+    ///     type V;\n+    ///     fn foo() -> Self::V;\n+    /// }\n+    ///\n+    /// impl Tr for E {\n+    ///     type V = u8;\n+    ///     // `Self::V` is ambiguous because it may refer to the associated type or\n+    ///     // the enum variant.\n+    ///     fn foo() -> Self::V { 0 }\n+    /// }\n+    /// ```\n+    ///\n+    /// {{produces}}\n+    ///\n+    /// ### Explanation\n+    ///\n+    /// Previous versions of Rust did not allow accessing enum variants\n+    /// through [type aliases]. When this ability was added (see [RFC 2338]), this\n+    /// introduced some situations where it can be ambiguous what a type\n+    /// was referring to.\n+    ///\n+    /// To fix this ambiguity, you should use a [qualified path] to explicitly\n+    /// state which type to use. For example, in the above example the\n+    /// function can be written as `fn f() -> <Self as Tr>::V { 0 }` to\n+    /// specifically refer to the associated type.\n+    ///\n+    /// This is a [future-incompatible] lint to transition this to a hard\n+    /// error in the future. See [issue #57644] for more details.\n+    ///\n+    /// [issue #57644]: https://github.com/rust-lang/rust/issues/57644\n+    /// [type aliases]: https://doc.rust-lang.org/reference/items/type-aliases.html#type-aliases\n+    /// [RFC 2338]: https://github.com/rust-lang/rfcs/blob/master/text/2338-type-alias-enum-variants.md\n+    /// [qualified path]: https://doc.rust-lang.org/reference/paths.html#qualified-paths\n+    /// [future-incompatible]: ../index.md#future-incompatible-lints\n     pub AMBIGUOUS_ASSOCIATED_ITEMS,\n     Deny,\n     \"ambiguous associated items\",\n@@ -497,6 +2368,27 @@ declare_lint! {\n }\n \n declare_lint! {\n+    /// The `mutable_borrow_reservation_conflict` lint detects the reservation\n+    /// of a two-phased borrow that conflicts with other shared borrows.\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```rust\n+    /// let mut v = vec![0, 1, 2];\n+    /// let shared = &v;\n+    /// v.push(shared.len());\n+    /// ```\n+    ///\n+    /// {{produces}}\n+    ///\n+    /// ### Explanation\n+    ///\n+    /// This is a [future-incompatible] lint to transition this to a hard error\n+    /// in the future. See [issue #59159] for a complete description of the\n+    /// problem, and some possible solutions.\n+    ///\n+    /// [issue #59159]: https://github.com/rust-lang/rust/issues/59159\n+    /// [future-incompatible]: ../index.md#future-incompatible-lints\n     pub MUTABLE_BORROW_RESERVATION_CONFLICT,\n     Warn,\n     \"reservation of a two-phased borrow conflicts with other shared borrows\",\n@@ -507,6 +2399,38 @@ declare_lint! {\n }\n \n declare_lint! {\n+    /// The `soft_unstable` lint detects unstable features that were\n+    /// unintentionally allowed on stable.\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```rust,compile_fail\n+    /// #[cfg(test)]\n+    /// extern crate test;\n+    ///\n+    /// #[bench]\n+    /// fn name(b: &mut test::Bencher) {\n+    ///     b.iter(|| 123)\n+    /// }\n+    /// ```\n+    ///\n+    /// {{produces}}\n+    ///\n+    /// ### Explanation\n+    ///\n+    /// The [`bench` attribute] was accidentally allowed to be specified on\n+    /// the [stable release channel]. Turning this to a hard error would have\n+    /// broken some projects. This lint allows those projects to continue to\n+    /// build correctly when [`--cap-lints`] is used, but otherwise signal an\n+    /// error that `#[bench]` should not be used on the stable channel. This\n+    /// is a [future-incompatible] lint to transition this to a hard error in\n+    /// the future. See [issue #64266] for more details.\n+    ///\n+    /// [issue #64266]: https://github.com/rust-lang/rust/issues/64266\n+    /// [`bench` attribute]: https://doc.rust-lang.org/nightly/unstable-book/library-features/test.html\n+    /// [stable release channel]: https://doc.rust-lang.org/book/appendix-07-nightly-rust.html\n+    /// [`--cap-lints`]: https://doc.rust-lang.org/rustc/lints/levels.html#capping-lints\n+    /// [future-incompatible]: ../index.md#future-incompatible-lints\n     pub SOFT_UNSTABLE,\n     Deny,\n     \"a feature gate that doesn't break dependent crates\",\n@@ -517,25 +2441,172 @@ declare_lint! {\n }\n \n declare_lint! {\n+    /// The `inline_no_sanitize` lint detects incompatible use of\n+    /// [`#[inline(always)]`][inline] and [`#[no_sanitize(...)]`][no_sanitize].\n+    ///\n+    /// [inline]: https://doc.rust-lang.org/reference/attributes/codegen.html#the-inline-attribute\n+    /// [no_sanitize]: https://doc.rust-lang.org/nightly/unstable-book/language-features/no-sanitize.html\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```rust\n+    /// #![feature(no_sanitize)]\n+    ///\n+    /// #[inline(always)]\n+    /// #[no_sanitize(address)]\n+    /// fn x() {}\n+    ///\n+    /// fn main() {\n+    ///     x()\n+    /// }\n+    /// ```\n+    ///\n+    /// {{produces}}\n+    ///\n+    /// ### Explanation\n+    ///\n+    /// The use of the [`#[inline(always)]`][inline] attribute prevents the\n+    /// the [`#[no_sanitize(...)]`][no_sanitize] attribute from working.\n+    /// Consider temporarily removing `inline` attribute.\n     pub INLINE_NO_SANITIZE,\n     Warn,\n     \"detects incompatible use of `#[inline(always)]` and `#[no_sanitize(...)]`\",\n }\n \n declare_lint! {\n+    /// The `asm_sub_register` lint detects using only a subset of a register\n+    /// for inline asm inputs.\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```rust,ignore (fails on system llvm)\n+    /// #![feature(asm)]\n+    ///\n+    /// fn main() {\n+    ///     #[cfg(target_arch=\"x86_64\")]\n+    ///     unsafe {\n+    ///         asm!(\"mov {0}, {0}\", in(reg) 0i16);\n+    ///     }\n+    /// }\n+    /// ```\n+    ///\n+    /// {{produces}}\n+    ///\n+    /// ### Explanation\n+    ///\n+    /// Registers on some architectures can use different names to refer to a\n+    /// subset of the register. By default, the compiler will use the name for\n+    /// the full register size. To explicitly use a subset of the register,\n+    /// you can override the default by using a modifier on the template\n+    /// string operand to specify when subregister to use. This lint is issued\n+    /// if you pass in a value with a smaller data type than the default\n+    /// register size, to alert you of possibly using the incorrect width. To\n+    /// fix this, add the suggested modifier to the template, or cast the\n+    /// value to the correct size.\n+    ///\n+    /// See [register template modifiers] for more details.\n+    ///\n+    /// [register template modifiers]: https://doc.rust-lang.org/nightly/unstable-book/library-features/asm.html#register-template-modifiers\n     pub ASM_SUB_REGISTER,\n     Warn,\n     \"using only a subset of a register for inline asm inputs\",\n }\n \n declare_lint! {\n+    /// The `unsafe_op_in_unsafe_fn` lint detects unsafe operations in unsafe\n+    /// functions without an explicit unsafe block. This lint only works on\n+    /// the [**nightly channel**] with the\n+    /// `#![feature(unsafe_block_in_unsafe_fn)]` feature.\n+    ///\n+    /// [**nightly channel**]: https://doc.rust-lang.org/book/appendix-07-nightly-rust.html\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```rust,compile_fail\n+    /// #![feature(unsafe_block_in_unsafe_fn)]\n+    /// #![deny(unsafe_op_in_unsafe_fn)]\n+    ///\n+    /// unsafe fn foo() {}\n+    ///\n+    /// unsafe fn bar() {\n+    ///     foo();\n+    /// }\n+    ///\n+    /// fn main() {}\n+    /// ```\n+    ///\n+    /// {{produces}}\n+    ///\n+    /// ### Explanation\n+    ///\n+    /// Currently, an [`unsafe fn`] allows any [unsafe] operation within its\n+    /// body. However, this can increase the surface area of code that needs\n+    /// to be scrutinized for proper behavior. The [`unsafe` block] provides a\n+    /// convenient way to make it clear exactly which parts of the code are\n+    /// performing unsafe operations. In the future, it is desired to change\n+    /// it so that unsafe operations cannot be performed in an `unsafe fn`\n+    /// without an `unsafe` block.\n+    ///\n+    /// The fix to this is to wrap the unsafe code in an `unsafe` block.\n+    ///\n+    /// This lint is \"allow\" by default because it has not yet been\n+    /// stabilized, and is not yet complete. See [RFC #2585] and [issue\n+    /// #71668] for more details\n+    ///\n+    /// [`unsafe fn`]: https://doc.rust-lang.org/reference/unsafe-functions.html\n+    /// [`unsafe` block]: https://doc.rust-lang.org/reference/expressions/block-expr.html#unsafe-blocks\n+    /// [unsafe]: https://doc.rust-lang.org/reference/unsafety.html\n+    /// [RFC #2585]: https://github.com/rust-lang/rfcs/blob/master/text/2585-unsafe-block-in-unsafe-fn.md\n+    /// [issue #71668]: https://github.com/rust-lang/rust/issues/71668\n     pub UNSAFE_OP_IN_UNSAFE_FN,\n     Allow,\n     \"unsafe operations in unsafe functions without an explicit unsafe block are deprecated\",\n     @feature_gate = sym::unsafe_block_in_unsafe_fn;\n }\n \n declare_lint! {\n+    /// The `cenum_impl_drop_cast` lint detects an `as` cast of a field-less\n+    /// `enum` that implements [`Drop`].\n+    ///\n+    /// [`Drop`]: https://doc.rust-lang.org/std/ops/trait.Drop.html\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```rust\n+    /// # #![allow(unused)]\n+    /// enum E {\n+    ///     A,\n+    /// }\n+    ///\n+    /// impl Drop for E {\n+    ///     fn drop(&mut self) {\n+    ///         println!(\"Drop\");\n+    ///     }\n+    /// }\n+    ///\n+    /// fn main() {\n+    ///     let e = E::A;\n+    ///     let i = e as u32;\n+    /// }\n+    /// ```\n+    ///\n+    /// {{produces}}\n+    ///\n+    /// ### Explanation\n+    ///\n+    /// Casting a field-less `enum` that does not implement [`Copy`] to an\n+    /// integer moves the value without calling `drop`. This can result in\n+    /// surprising behavior if it was expected that `drop` should be called.\n+    /// Calling `drop` automatically would be inconsistent with other move\n+    /// operations. Since neither behavior is clear or consistent, it was\n+    /// decided that a cast of this nature will no longer be allowed.\n+    ///\n+    /// This is a [future-incompatible] lint to transition this to a hard error\n+    /// in the future. See [issue #73333] for more details.\n+    ///\n+    /// [future-incompatible]: ../index.md#future-incompatible-lints\n+    /// [issue #73333]: https://github.com/rust-lang/rust/issues/73333\n+    /// [`Copy`]: https://doc.rust-lang.org/std/marker/trait.Copy.html\n     pub CENUM_IMPL_DROP_CAST,\n     Warn,\n     \"a C-like enum implementing Drop is cast\",\n@@ -546,6 +2617,36 @@ declare_lint! {\n }\n \n declare_lint! {\n+    /// The `const_evaluatable_unchecked` lint detects a generic constant used\n+    /// in a type.\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```rust\n+    /// const fn foo<T>() -> usize {\n+    ///     if std::mem::size_of::<*mut T>() < 8 { // size of *mut T does not depend on T\n+    ///         std::mem::size_of::<T>()\n+    ///     } else {\n+    ///         8\n+    ///     }\n+    /// }\n+    ///\n+    /// fn test<T>() {\n+    ///     let _ = [0; foo::<T>()];\n+    /// }\n+    /// ```\n+    ///\n+    /// {{produces}}\n+    ///\n+    /// ### Explanation\n+    ///\n+    /// In the 1.43 release, some uses of generic parameters in array repeat\n+    /// expressions were accidentally allowed. This is a [future-incompatible]\n+    /// lint to transition this to a hard error in the future. See [issue\n+    /// #76200] for a more detailed description and possible fixes.\n+    ///\n+    /// [future-incompatible]: ../index.md#future-incompatible-lints\n+    /// [issue #76200]: https://github.com/rust-lang/rust/issues/76200\n     pub CONST_EVALUATABLE_UNCHECKED,\n     Warn,\n     \"detects a generic constant is used in a type without a emitting a warning\",\n@@ -641,6 +2742,23 @@ declare_lint_pass! {\n }\n \n declare_lint! {\n+    /// The `unused_doc_comments` lint detects doc comments that aren't used\n+    /// by `rustdoc`.\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```rust\n+    /// /// docs for x\n+    /// let x = 12;\n+    /// ```\n+    ///\n+    /// {{produces}}\n+    ///\n+    /// ### Explanation\n+    ///\n+    /// `rustdoc` does not use doc comments in all positions, and so the doc\n+    /// comment will be ignored. Try changing it to a normal comment with `//`\n+    /// to avoid the warning.\n     pub UNUSED_DOC_COMMENTS,\n     Warn,\n     \"detects doc comments that aren't used by rustdoc\""}, {"sha": "be5182b939dde32f5b72078745dca0dbb08c2807", "filename": "src/bootstrap/doc.rs", "status": "modified", "additions": 66, "deletions": 1, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/45c1e0ae07b9581d8c2d2b39315ac7cc79475d75/src%2Fbootstrap%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45c1e0ae07b9581d8c2d2b39315ac7cc79475d75/src%2Fbootstrap%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdoc.rs?ref=45c1e0ae07b9581d8c2d2b39315ac7cc79475d75", "patch": "@@ -66,7 +66,6 @@ book!(\n     Nomicon, \"src/doc/nomicon\", \"nomicon\";\n     Reference, \"src/doc/reference\", \"reference\";\n     RustByExample, \"src/doc/rust-by-example\", \"rust-by-example\";\n-    RustcBook, \"src/doc/rustc\", \"rustc\";\n     RustdocBook, \"src/doc/rustdoc\", \"rustdoc\";\n );\n \n@@ -718,3 +717,69 @@ fn symlink_dir_force(config: &Config, src: &Path, dst: &Path) -> io::Result<()>\n \n     symlink_dir(config, src, dst)\n }\n+\n+#[derive(Ord, PartialOrd, Debug, Copy, Clone, Hash, PartialEq, Eq)]\n+pub struct RustcBook {\n+    pub compiler: Compiler,\n+    pub target: TargetSelection,\n+}\n+\n+impl Step for RustcBook {\n+    type Output = ();\n+    const DEFAULT: bool = true;\n+    const ONLY_HOSTS: bool = true;\n+\n+    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n+        let builder = run.builder;\n+        run.path(\"src/doc/rustc\").default_condition(builder.config.docs)\n+    }\n+\n+    fn make_run(run: RunConfig<'_>) {\n+        run.builder.ensure(RustcBook {\n+            compiler: run.builder.compiler(run.builder.top_stage, run.builder.config.build),\n+            target: run.target,\n+        });\n+    }\n+\n+    /// Builds the rustc book.\n+    ///\n+    /// The lints are auto-generated by a tool, and then merged into the book\n+    /// in the \"md-doc\" directory in the build output directory. Then\n+    /// \"rustbook\" is used to convert it to HTML.\n+    fn run(self, builder: &Builder<'_>) {\n+        let out_base = builder.md_doc_out(self.target).join(\"rustc\");\n+        t!(fs::create_dir_all(&out_base));\n+        let out_listing = out_base.join(\"src/lints\");\n+        builder.cp_r(&builder.src.join(\"src/doc/rustc\"), &out_base);\n+        builder.info(&format!(\"Generating lint docs ({})\", self.target));\n+        let rustc = builder.rustc(self.compiler);\n+        // The tool runs `rustc` for extracting output examples, so it needs a\n+        // functional sysroot.\n+        builder.ensure(compile::Std { compiler: self.compiler, target: self.target });\n+        let rustdoc = builder.rustdoc(self.compiler);\n+        let mut cmd = builder.tool_cmd(Tool::LintDocs);\n+        cmd.arg(\"--src\");\n+        cmd.arg(builder.src.join(\"compiler\"));\n+        cmd.arg(\"--out\");\n+        cmd.arg(&out_listing);\n+        cmd.arg(\"--rustc\");\n+        cmd.arg(rustc);\n+        cmd.arg(\"--rustdoc\");\n+        cmd.arg(rustdoc);\n+        if builder.config.verbose() {\n+            cmd.arg(\"--verbose\");\n+        }\n+        builder.run(&mut cmd);\n+        // Run rustbook/mdbook to generate the HTML pages.\n+        builder.ensure(RustbookSrc {\n+            target: self.target,\n+            name: INTERNER.intern_str(\"rustc\"),\n+            src: INTERNER.intern_path(out_base),\n+        });\n+        if is_explicit_request(builder, \"src/doc/rustc\") {\n+            let out = builder.doc_out(self.target);\n+            let index = out.join(\"rustc\").join(\"index.html\");\n+            open(builder, &index);\n+        }\n+    }\n+}"}, {"sha": "99e33e3b006fe89a2d2d02f41875ca10d0a31030", "filename": "src/bootstrap/tool.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/45c1e0ae07b9581d8c2d2b39315ac7cc79475d75/src%2Fbootstrap%2Ftool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45c1e0ae07b9581d8c2d2b39315ac7cc79475d75/src%2Fbootstrap%2Ftool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftool.rs?ref=45c1e0ae07b9581d8c2d2b39315ac7cc79475d75", "patch": "@@ -367,6 +367,7 @@ bootstrap_tool!(\n     RustInstaller, \"src/tools/rust-installer\", \"fabricate\", is_external_tool = true;\n     RustdocTheme, \"src/tools/rustdoc-themes\", \"rustdoc-themes\";\n     ExpandYamlAnchors, \"src/tools/expand-yaml-anchors\", \"expand-yaml-anchors\";\n+    LintDocs, \"src/tools/lint-docs\", \"lint-docs\";\n );\n \n #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq, Ord, PartialOrd)]"}, {"sha": "44cf42ff0d71b3dcc3e73289e6099292992685f7", "filename": "src/doc/rustc/src/lints/groups.md", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/45c1e0ae07b9581d8c2d2b39315ac7cc79475d75/src%2Fdoc%2Frustc%2Fsrc%2Flints%2Fgroups.md", "raw_url": "https://github.com/rust-lang/rust/raw/45c1e0ae07b9581d8c2d2b39315ac7cc79475d75/src%2Fdoc%2Frustc%2Fsrc%2Flints%2Fgroups.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Flints%2Fgroups.md?ref=45c1e0ae07b9581d8c2d2b39315ac7cc79475d75", "patch": "@@ -14,14 +14,7 @@ $ rustc -D non-camel-case-types -D non-snake-case -D non-upper-case-globals\n \n Here's a list of each lint group, and the lints that they are made up of:\n \n-| group               | description                                                   | lints                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |\n-|---------------------|---------------------------------------------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n-| nonstandard-style   | Violation of standard naming conventions                      | non-camel-case-types, non-snake-case, non-upper-case-globals                                                                                                                                                                                                                                                                                                                                                                                                                           |\n-| warnings            | all lints that would be issuing warnings                      | all lints that would be issuing warnings                                                                                                                                                                                                                                                                                                                                                                                                                                               |\n-| edition-2018        | Lints that will be turned into errors in Rust 2018            | tyvar-behind-raw-pointer                                                                                                                                                                                                                                                                                                                                                                                                                                                               |\n-| rust-2018-idioms    | Lints to nudge you toward idiomatic features of Rust 2018     | bare-trait-object, unreachable-pub                                                                                                                                                                                                                                                                                                                                                                                                                                                     |\n-| unused              | These lints detect things being declared but not used         | unused-imports, unused-variables, unused-assignments, dead-code, unused-mut, unreachable-code, unreachable-patterns, unused-must-use, unused-unsafe, path-statements, unused-attributes, unused-macros, unused-allocation, unused-doc-comment, unused-extern-crates, unused-features, unused-parens                                                                                                                                                                                    |\n-| future-incompatible | Lints that detect code that has future-compatibility problems | private-in-public, pub-use-of-private-extern-crate, patterns-in-fns-without-body, safe-extern-statics, invalid-type-param-default, legacy-directory-ownership, legacy-imports, legacy-constructor-visibility, missing-fragment-specifier, illegal-floating-point-literal-pattern, anonymous-parameters, parenthesized-params-in-types-and-modules, late-bound-lifetime-arguments, safe-packed-borrows, tyvar-behind-raw-pointer, unstable-name-collision |\n+{{groups-table}}\n \n Additionally, there's a `bad-style` lint group that's a deprecated alias for `nonstandard-style`.\n "}, {"sha": "029c9edc1b5feacd086b118a981d8a30c4ec46d5", "filename": "src/doc/rustc/src/lints/index.md", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/45c1e0ae07b9581d8c2d2b39315ac7cc79475d75/src%2Fdoc%2Frustc%2Fsrc%2Flints%2Findex.md", "raw_url": "https://github.com/rust-lang/rust/raw/45c1e0ae07b9581d8c2d2b39315ac7cc79475d75/src%2Fdoc%2Frustc%2Fsrc%2Flints%2Findex.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Flints%2Findex.md?ref=45c1e0ae07b9581d8c2d2b39315ac7cc79475d75", "patch": "@@ -26,3 +26,35 @@ warning: unused variable: `x`\n This is the `unused_variables` lint, and it tells you that you've introduced\n a variable that you don't use in your code. That's not *wrong*, so it's not\n an error, but it might be a bug, so you get a warning.\n+\n+## Future-incompatible lints\n+\n+Sometimes the compiler needs to be changed to fix an issue that can cause\n+existing code to stop compiling. \"Future-incompatible\" lints are issued in\n+these cases to give users of Rust a smooth transition to the new behavior.\n+Initially, the compiler will continue to accept the problematic code and issue\n+a warning. The warning has a description of the problem, a notice that this\n+will become an error in the future, and a link to a tracking issue that\n+provides detailed information and an opportunity for feedback. This gives\n+users some time to fix the code to accommodate the change. After some time,\n+the warning may become an error.\n+\n+The following is an example of what a future-incompatible looks like:\n+\n+```text\n+warning: borrow of packed field is unsafe and requires unsafe function or block (error E0133)\n+  --> lint_example.rs:11:13\n+   |\n+11 |     let y = &x.data.0;\n+   |             ^^^^^^^^^\n+   |\n+   = note: `#[warn(safe_packed_borrows)]` on by default\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #46043 <https://github.com/rust-lang/rust/issues/46043>\n+   = note: fields of packed structs might be misaligned: dereferencing a misaligned pointer or even just creating a misaligned reference is undefined behavior\n+```\n+\n+For more information about the process and policy of future-incompatible\n+changes, see [RFC 1589].\n+\n+[RFC 1589]: https://github.com/rust-lang/rfcs/blob/master/text/1589-rustc-bug-fix-procedure.md"}, {"sha": "95dd60bebfbad5a0b05703ca465e3730082d503d", "filename": "src/doc/rustc/src/lints/listing/allowed-by-default.md", "status": "modified", "additions": 1, "deletions": 452, "changes": 453, "blob_url": "https://github.com/rust-lang/rust/blob/45c1e0ae07b9581d8c2d2b39315ac7cc79475d75/src%2Fdoc%2Frustc%2Fsrc%2Flints%2Flisting%2Fallowed-by-default.md", "raw_url": "https://github.com/rust-lang/rust/raw/45c1e0ae07b9581d8c2d2b39315ac7cc79475d75/src%2Fdoc%2Frustc%2Fsrc%2Flints%2Flisting%2Fallowed-by-default.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Flints%2Flisting%2Fallowed-by-default.md?ref=45c1e0ae07b9581d8c2d2b39315ac7cc79475d75", "patch": "@@ -1,454 +1,3 @@\n # Allowed-by-default lints\n \n-These lints are all set to the 'allow' level by default. As such, they won't show up\n-unless you set them to a higher lint level with a flag or attribute.\n-\n-## anonymous-parameters\n-\n-This lint detects anonymous parameters. Some example code that triggers this lint:\n-\n-```rust\n-trait Foo {\n-    fn foo(usize);\n-}\n-```\n-\n-When set to 'deny', this will produce:\n-\n-```text\n-error: use of deprecated anonymous parameter\n- --> src/lib.rs:5:11\n-  |\n-5 |     fn foo(usize);\n-  |           ^\n-  |\n-  = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n-  = note: for more information, see issue #41686 <https://github.com/rust-lang/rust/issues/41686>\n-```\n-\n-This syntax is mostly a historical accident, and can be worked around quite\n-easily:\n-\n-```rust\n-trait Foo {\n-    fn foo(_: usize);\n-}\n-```\n-\n-## bare-trait-object\n-\n-This lint suggests using `dyn Trait` for trait objects. Some example code\n-that triggers this lint:\n-\n-```rust\n-#![feature(dyn_trait)]\n-\n-trait Trait { }\n-\n-fn takes_trait_object(_: Box<Trait>) {\n-}\n-```\n-\n-When set to 'deny', this will produce:\n-\n-```text\n-error: trait objects without an explicit `dyn` are deprecated\n- --> src/lib.rs:7:30\n-  |\n-7 | fn takes_trait_object(_: Box<Trait>) {\n-  |                              ^^^^^ help: use `dyn`: `dyn Trait`\n-  |\n-```\n-\n-To fix it, do as the help message suggests:\n-\n-```rust\n-#![feature(dyn_trait)]\n-#![deny(bare_trait_objects)]\n-\n-trait Trait { }\n-\n-fn takes_trait_object(_: Box<dyn Trait>) {\n-}\n-```\n-\n-## box-pointers\n-\n-This lints use of the Box type. Some example code that triggers this lint:\n-\n-```rust\n-struct Foo {\n-    x: Box<isize>,\n-}\n-```\n-\n-When set to 'deny', this will produce:\n-\n-```text\n-error: type uses owned (Box type) pointers: std::boxed::Box<isize>\n- --> src/lib.rs:6:5\n-  |\n-6 |     x: Box<isize> //~ ERROR type uses owned\n-  |     ^^^^^^^^^^^^^\n-  |\n-```\n-\n-This lint is mostly historical, and not particularly useful. `Box<T>` used to\n-be built into the language, and the only way to do heap allocation. Today's\n-Rust can call into other allocators, etc.\n-\n-## elided-lifetime-in-path\n-\n-This lint detects the use of hidden lifetime parameters. Some example code\n-that triggers this lint:\n-\n-```rust\n-struct Foo<'a> {\n-    x: &'a u32\n-}\n-\n-fn foo(x: &Foo) {\n-}\n-```\n-\n-When set to 'deny', this will produce:\n-\n-```text\n-error: hidden lifetime parameters are deprecated, try `Foo<'_>`\n- --> src/lib.rs:5:12\n-  |\n-5 | fn foo(x: &Foo) {\n-  |            ^^^\n-  |\n-```\n-\n-Lifetime elision elides this lifetime, but that is being deprecated.\n-\n-## missing-copy-implementations\n-\n-This lint detects potentially-forgotten implementations of `Copy`. Some\n-example code that triggers this lint:\n-\n-```rust\n-pub struct Foo {\n-    pub field: i32\n-}\n-```\n-\n-When set to 'deny', this will produce:\n-\n-```text\n-error: type could implement `Copy`; consider adding `impl Copy`\n- --> src/main.rs:3:1\n-  |\n-3 | / pub struct Foo { //~ ERROR type could implement `Copy`; consider adding `impl Copy`\n-4 | |     pub field: i32\n-5 | | }\n-  | |_^\n-  |\n-```\n-\n-You can fix the lint by deriving `Copy`.\n-\n-This lint is set to 'allow' because this code isn't bad; it's common to write\n-newtypes like this specifically so that a `Copy` type is no longer `Copy`.\n-\n-## missing-debug-implementations\n-\n-This lint detects missing implementations of `fmt::Debug`. Some example code\n-that triggers this lint:\n-\n-```rust\n-pub struct Foo;\n-```\n-\n-When set to 'deny', this will produce:\n-\n-```text\n-error: type does not implement `fmt::Debug`; consider adding `#[derive(Debug)]` or a manual implementation\n- --> src/main.rs:3:1\n-  |\n-3 | pub struct Foo;\n-  | ^^^^^^^^^^^^^^^\n-  |\n-```\n-\n-You can fix the lint by deriving `Debug`.\n-\n-## missing-docs\n-\n-This lint detects missing documentation for public items. Some example code\n-that triggers this lint:\n-\n-```rust\n-pub fn foo() {}\n-```\n-\n-When set to 'deny', this will produce:\n-\n-```text\n-error: missing documentation for crate\n- --> src/main.rs:1:1\n-  |\n-1 | / #![deny(missing_docs)]\n-2 | |\n-3 | | pub fn foo() {}\n-4 | |\n-5 | | fn main() {}\n-  | |____________^\n-  |\n-\n-error: missing documentation for a function\n- --> src/main.rs:3:1\n-  |\n-3 | pub fn foo() {}\n-  | ^^^^^^^^^^^^\n-\n-```\n-\n-To fix the lint, add documentation to all items.\n-\n-## single-use-lifetimes\n-\n-This lint detects lifetimes that are only used once. Some example code that\n-triggers this lint:\n-\n-```rust\n-struct Foo<'x> {\n-    x: &'x u32\n-}\n-```\n-\n-When set to 'deny', this will produce:\n-\n-```text\n-error: lifetime name `'x` only used once\n- --> src/main.rs:3:12\n-  |\n-3 | struct Foo<'x> {\n-  |            ^^\n-  |\n-```\n-\n-## trivial-casts\n-\n-This lint detects trivial casts which could be replaced with coercion, which may require\n-type ascription or a temporary variable. Some example code\n-that triggers this lint:\n-\n-```rust\n-let x: &u32 = &42;\n-let _ = x as *const u32;\n-```\n-\n-When set to 'deny', this will produce:\n-\n-```text\n-error: trivial cast: `&u32` as `*const u32`. Cast can be replaced by coercion, this might require type ascription or a temporary variable\n- --> src/main.rs:5:13\n-  |\n-5 |     let _ = x as *const u32;\n-  |             ^^^^^^^^^^^^^^^\n-  |\n-note: lint level defined here\n- --> src/main.rs:1:9\n-  |\n-1 | #![deny(trivial_casts)]\n-  |         ^^^^^^^^^^^^^\n-```\n-\n-## trivial-numeric-casts\n-\n-This lint detects trivial casts of numeric types which could be removed. Some\n-example code that triggers this lint:\n-\n-```rust\n-let x = 42i32 as i32;\n-```\n-\n-When set to 'deny', this will produce:\n-\n-```text\n-error: trivial numeric cast: `i32` as `i32`. Cast can be replaced by coercion, this might require type ascription or a temporary variable\n- --> src/main.rs:4:13\n-  |\n-4 |     let x = 42i32 as i32;\n-  |             ^^^^^^^^^^^^\n-  |\n-```\n-\n-## unreachable-pub\n-\n-This lint triggers for `pub` items not reachable from the crate root. Some\n-example code that triggers this lint:\n-\n-```rust\n-mod foo {\n-    pub mod bar {\n-        \n-    }\n-}\n-```\n-\n-When set to 'deny', this will produce:\n-\n-```text\n-error: unreachable `pub` item\n- --> src/main.rs:4:5\n-  |\n-4 |     pub mod bar {\n-  |     ---^^^^^^^^\n-  |     |\n-  |     help: consider restricting its visibility: `pub(crate)`\n-  |\n-```\n-\n-## unsafe-code\n-\n-This lint catches usage of `unsafe` code. Some example code that triggers this lint:\n-\n-```rust\n-fn main() {\n-    unsafe {\n-\n-    }\n-}\n-```\n-\n-When set to 'deny', this will produce:\n-\n-```text\n-error: usage of an `unsafe` block\n- --> src/main.rs:4:5\n-  |\n-4 | /     unsafe {\n-5 | |         \n-6 | |     }\n-  | |_____^\n-  |\n-```\n-\n-## unstable-features\n-\n-This lint is deprecated and no longer used.\n-\n-## unused-extern-crates\n-\n-This lint guards against `extern crate` items that are never used. Some\n-example code that triggers this lint:\n-\n-```rust,ignore\n-extern crate semver;\n-```\n-\n-When set to 'deny', this will produce:\n-\n-```text\n-error: unused extern crate\n- --> src/main.rs:3:1\n-  |\n-3 | extern crate semver;\n-  | ^^^^^^^^^^^^^^^^^^^^\n-  |\n-```\n-\n-## unused-import-braces\n-\n-This lint catches unnecessary braces around an imported item. Some example\n-code that triggers this lint:\n-\n-```rust\n-use test::{A};\n-\n-pub mod test {\n-    pub struct A;\n-}\n-# fn main() {}\n-```\n-\n-When set to 'deny', this will produce:\n-\n-```text\n-error: braces around A is unnecessary\n- --> src/main.rs:3:1\n-  |\n-3 | use test::{A};\n-  | ^^^^^^^^^^^^^^\n-  |\n-```\n-\n-To fix it, `use test::A;`\n-\n-## unused-qualifications\n-\n-This lint detects unnecessarily qualified names. Some example code that triggers this lint:\n-\n-```rust\n-mod foo {\n-    pub fn bar() {}\n-}\n-\n-fn main() {\n-    use foo::bar;\n-    foo::bar();\n-}\n-```\n-\n-When set to 'deny', this will produce:\n-\n-```text\n-error: unnecessary qualification\n- --> src/main.rs:9:5\n-  |\n-9 |     foo::bar();\n-  |     ^^^^^^^^\n-  |\n-```\n-\n-You can call `bar()` directly, without the `foo::`.\n-\n-## unused-results\n-\n-This lint checks for the unused result of an expression in a statement. Some\n-example code that triggers this lint:\n-\n-```rust,no_run\n-fn foo<T>() -> T { panic!() }\n-\n-fn main() {\n-    foo::<usize>();\n-}\n-```\n-\n-When set to 'deny', this will produce:\n-\n-```text\n-error: unused result\n- --> src/main.rs:6:5\n-  |\n-6 |     foo::<usize>();\n-  |     ^^^^^^^^^^^^^^^\n-  |\n-```\n-\n-## variant-size-differences\n-\n-This lint detects enums with widely varying variant sizes. Some example code that triggers this lint:\n-\n-```rust\n-enum En {\n-    V0(u8),\n-    VBig([u8; 1024]),\n-}\n-```\n-\n-When set to 'deny', this will produce:\n-\n-```text\n-error: enum variant is more than three times larger (1024 bytes) than the next largest\n- --> src/main.rs:5:5\n-  |\n-5 |     VBig([u8; 1024]),   //~ ERROR variant is more than three times larger\n-  |     ^^^^^^^^^^^^^^^^\n-  |\n-```\n+This file is auto-generated by the lint-docs script."}, {"sha": "3c1452d64676c68936711da2ed3b2e550c22123f", "filename": "src/doc/rustc/src/lints/listing/deny-by-default.md", "status": "modified", "additions": 1, "deletions": 201, "changes": 202, "blob_url": "https://github.com/rust-lang/rust/blob/45c1e0ae07b9581d8c2d2b39315ac7cc79475d75/src%2Fdoc%2Frustc%2Fsrc%2Flints%2Flisting%2Fdeny-by-default.md", "raw_url": "https://github.com/rust-lang/rust/raw/45c1e0ae07b9581d8c2d2b39315ac7cc79475d75/src%2Fdoc%2Frustc%2Fsrc%2Flints%2Flisting%2Fdeny-by-default.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Flints%2Flisting%2Fdeny-by-default.md?ref=45c1e0ae07b9581d8c2d2b39315ac7cc79475d75", "patch": "@@ -1,203 +1,3 @@\n # Deny-by-default lints\n \n-These lints are all set to the 'deny' level by default.\n-\n-## exceeding-bitshifts\n-\n-This lint detects that a shift exceeds the type's number of bits. Some\n-example code that triggers this lint:\n-\n-```rust,ignore\n-1_i32 << 32;\n-```\n-\n-This will produce:\n-\n-```text\n-error: bitshift exceeds the type's number of bits\n- --> src/main.rs:2:5\n-  |\n-2 |     1_i32 << 32;\n-  |     ^^^^^^^^^^^\n-  |\n-```\n-\n-## invalid-type-param-default\n-\n-This lint detects type parameter default erroneously allowed in invalid location. Some\n-example code that triggers this lint:\n-\n-```rust,ignore\n-fn foo<T=i32>(t: T) {}\n-```\n-\n-This will produce:\n-\n-```text\n-error: defaults for type parameters are only allowed in `struct`, `enum`, `type`, or `trait` definitions.\n- --> src/main.rs:4:8\n-  |\n-4 | fn foo<T=i32>(t: T) {}\n-  |        ^\n-  |\n-  = note: `#[deny(invalid_type_param_default)]` on by default\n-  = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n-  = note: for more information, see issue #36887 <https://github.com/rust-lang/rust/issues/36887>\n-```\n-\n-## mutable-transmutes\n-\n-This lint catches transmuting from `&T` to `&mut T` because it is undefined\n-behavior. Some example code that triggers this lint:\n-\n-```rust,ignore\n-unsafe {\n-    let y = std::mem::transmute::<&i32, &mut i32>(&5);\n-}\n-```\n-\n-This will produce:\n-\n-```text\n-error: mutating transmuted &mut T from &T may cause undefined behavior, consider instead using an UnsafeCell\n- --> src/main.rs:3:17\n-  |\n-3 |         let y = std::mem::transmute::<&i32, &mut i32>(&5);\n-  |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-  |\n-```\n-\n-\n-## no-mangle-const-items\n-\n-This lint detects any `const` items with the `#[no_mangle]` attribute.\n-Constants do not have their symbols exported, and therefore, this probably\n-means you meant to use a `static`, not a `const`. Some example code that\n-triggers this lint:\n-\n-```rust,ignore\n-#[no_mangle]\n-const FOO: i32 = 5;\n-```\n-\n-This will produce:\n-\n-```text\n-error: const items should never be `#[no_mangle]`\n- --> src/main.rs:3:1\n-  |\n-3 | const FOO: i32 = 5;\n-  | -----^^^^^^^^^^^^^^\n-  | |\n-  | help: try a static value: `pub static`\n-  |\n-```\n-\n-## overflowing-literals\n-\n-This lint detects literal out of range for its type. Some\n-example code that triggers this lint:\n-\n-```rust,compile_fail\n-let x: u8 = 1000;\n-```\n-\n-This will produce:\n-\n-```text\n-error: literal out of range for u8\n- --> src/main.rs:2:17\n-  |\n-2 |     let x: u8 = 1000;\n-  |                 ^^^^\n-  |\n-```\n-\n-## patterns-in-fns-without-body\n-\n-This lint detects patterns in functions without body were that were\n-previously erroneously allowed. Some example code that triggers this lint:\n-\n-```rust,compile_fail\n-trait Trait {\n-    fn foo(mut arg: u8);\n-}\n-```\n-\n-This will produce:\n-\n-```text\n-warning: patterns aren't allowed in methods without bodies\n- --> src/main.rs:2:12\n-  |\n-2 |     fn foo(mut arg: u8);\n-  |            ^^^^^^^\n-  |\n-  = note: `#[warn(patterns_in_fns_without_body)]` on by default\n-  = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n-  = note: for more information, see issue #35203 <https://github.com/rust-lang/rust/issues/35203>\n-```\n-\n-To fix this, remove the pattern; it can be used in the implementation without\n-being used in the definition. That is:\n-\n-```rust\n-trait Trait {\n-    fn foo(arg: u8);\n-}\n-\n-impl Trait for i32 {\n-    fn foo(mut arg: u8) {\n-\n-    }\n-}\n-```\n-\n-## pub-use-of-private-extern-crate\n-\n-This lint detects a specific situation of re-exporting a private `extern crate`;\n-\n-## unknown-crate-types\n-\n-This lint detects an unknown crate type found in a `#[crate_type]` directive. Some\n-example code that triggers this lint:\n-\n-```rust,ignore\n-#![crate_type=\"lol\"]\n-```\n-\n-This will produce:\n-\n-```text\n-error: invalid `crate_type` value\n- --> src/lib.rs:1:1\n-  |\n-1 | #![crate_type=\"lol\"]\n-  | ^^^^^^^^^^^^^^^^^^^^\n-  |\n-```\n-\n-## const-err\n-\n-This lint detects expressions that will always panic at runtime and would be an\n-error in a `const` context.\n-\n-```rust,ignore\n-let _ = [0; 4][4];\n-```\n-\n-This will produce:\n-\n-```text\n-error: index out of bounds: the len is 4 but the index is 4\n- --> src/lib.rs:1:9\n-  |\n-1 | let _ = [0; 4][4];\n-  |         ^^^^^^^^^\n-  |\n-```\n-\n-## order-dependent-trait-objects\n-\n-This lint detects a trait coherency violation that would allow creating two\n-trait impls for the same dynamic trait object involving marker traits.\n+This file is auto-generated by the lint-docs script."}, {"sha": "eebc022a82bf8298c0cf1459a9e4c675751d5027", "filename": "src/doc/rustc/src/lints/listing/warn-by-default.md", "status": "modified", "additions": 1, "deletions": 901, "changes": 902, "blob_url": "https://github.com/rust-lang/rust/blob/45c1e0ae07b9581d8c2d2b39315ac7cc79475d75/src%2Fdoc%2Frustc%2Fsrc%2Flints%2Flisting%2Fwarn-by-default.md", "raw_url": "https://github.com/rust-lang/rust/raw/45c1e0ae07b9581d8c2d2b39315ac7cc79475d75/src%2Fdoc%2Frustc%2Fsrc%2Flints%2Flisting%2Fwarn-by-default.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Flints%2Flisting%2Fwarn-by-default.md?ref=45c1e0ae07b9581d8c2d2b39315ac7cc79475d75", "patch": "@@ -1,903 +1,3 @@\n # Warn-by-default lints\n \n-These lints are all set to the 'warn' level by default.\n-\n-## const-err\n-\n-This lint detects an erroneous expression while doing constant evaluation. Some\n-example code that triggers this lint:\n-\n-```rust,ignore\n-let b = 200u8 + 200u8;\n-```\n-\n-This will produce:\n-\n-```text\n-warning: attempt to add with overflow\n- --> src/main.rs:2:9\n-  |\n-2 | let b = 200u8 + 200u8;\n-  |         ^^^^^^^^^^^^^\n-  |\n-```\n-\n-## dead-code\n-\n-This lint detects unused, unexported items. Some\n-example code that triggers this lint:\n-\n-```rust\n-fn foo() {}\n-```\n-\n-This will produce:\n-\n-```text\n-warning: function is never used: `foo`\n- --> src/lib.rs:2:1\n-  |\n-2 | fn foo() {}\n-  | ^^^^^^^^\n-  |\n-```\n-\n-## deprecated\n-\n-This lint detects use of deprecated items. Some\n-example code that triggers this lint:\n-\n-```rust\n-#[deprecated]\n-fn foo() {}\n-\n-fn bar() {\n-    foo();\n-}\n-```\n-\n-This will produce:\n-\n-```text\n-warning: use of deprecated item 'foo'\n- --> src/lib.rs:7:5\n-  |\n-7 |     foo();\n-  |     ^^^\n-  |\n-```\n-\n-## illegal-floating-point-literal-pattern\n-\n-This lint detects floating-point literals used in patterns. Some example code\n-that triggers this lint:\n-\n-```rust\n-let x = 42.0;\n-\n-match x {\n-    5.0 => {},\n-    _ => {},\n-}\n-```\n-\n-This will produce:\n-\n-```text\n-warning: floating-point literals cannot be used in patterns\n- --> src/main.rs:4:9\n-  |\n-4 |         5.0 => {},\n-  |         ^^^\n-  |\n-  = note: `#[warn(illegal_floating_point_literal_pattern)]` on by default\n-  = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n-  = note: for more information, see issue #41620 <https://github.com/rust-lang/rust/issues/41620>\n-```\n-\n-## improper-ctypes\n-\n-This lint detects proper use of libc types in foreign modules. Some\n-example code that triggers this lint:\n-\n-```rust\n-extern \"C\" {\n-    static STATIC: String;\n-}\n-```\n-\n-This will produce:\n-\n-```text\n-warning: found struct without foreign-function-safe representation annotation in foreign module, consider adding a `#[repr(C)]` attribute to the type\n- --> src/main.rs:2:20\n-  |\n-2 |     static STATIC: String;\n-  |                    ^^^^^^\n-  |\n-```\n-\n-## late-bound-lifetime-arguments\n-\n-This lint detects generic lifetime arguments in path segments with\n-late bound lifetime parameters. Some example code that triggers this lint:\n-\n-```rust\n-struct S;\n-\n-impl S {\n-    fn late<'a, 'b>(self, _: &'a u8, _: &'b u8) {}\n-}\n-\n-fn main() {\n-    S.late::<'static>(&0, &0);\n-}\n-```\n-\n-This will produce:\n-\n-```text\n-warning: cannot specify lifetime arguments explicitly if late bound lifetime parameters are present\n- --> src/main.rs:8:14\n-  |\n-4 |     fn late<'a, 'b>(self, _: &'a u8, _: &'b u8) {}\n-  |             -- the late bound lifetime parameter is introduced here\n-...\n-8 |     S.late::<'static>(&0, &0);\n-  |              ^^^^^^^\n-  |\n-  = note: `#[warn(late_bound_lifetime_arguments)]` on by default\n-  = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n-  = note: for more information, see issue #42868 <https://github.com/rust-lang/rust/issues/42868>\n-```\n-\n-## non-camel-case-types\n-\n-This lint detects types, variants, traits and type parameters that don't have\n-camel case names. Some example code that triggers this lint:\n-\n-```rust\n-struct s;\n-```\n-\n-This will produce:\n-\n-```text\n-warning: type `s` should have a camel case name such as `S`\n- --> src/main.rs:1:1\n-  |\n-1 | struct s;\n-  | ^^^^^^^^^\n-  |\n-```\n-\n-## non-shorthand-field-patterns\n-\n-This lint detects using `Struct { x: x }` instead of `Struct { x }` in a pattern. Some\n-example code that triggers this lint:\n-\n-```rust\n-struct Point {\n-    x: i32,\n-    y: i32,\n-}\n-\n-\n-fn main() {\n-    let p = Point {\n-        x: 5,\n-        y: 5,\n-    };\n-\n-    match p {\n-        Point { x: x, y: y } => (),\n-    }\n-}\n-```\n-\n-This will produce:\n-\n-```text\n-warning: the `x:` in this pattern is redundant\n-  --> src/main.rs:14:17\n-   |\n-14 |         Point { x: x, y: y } => (),\n-   |                 --^^\n-   |                 |\n-   |                 help: remove this\n-   |\n-\n-warning: the `y:` in this pattern is redundant\n-  --> src/main.rs:14:23\n-   |\n-14 |         Point { x: x, y: y } => (),\n-   |                       --^^\n-   |                       |\n-   |                       help: remove this\n-\n-```\n-\n-## non-snake-case\n-\n-This lint detects variables, methods, functions, lifetime parameters and\n-modules that don't have snake case names. Some example code that triggers\n-this lint:\n-\n-```rust\n-let X = 5;\n-```\n-\n-This will produce:\n-\n-```text\n-warning: variable `X` should have a snake case name such as `x`\n- --> src/main.rs:2:9\n-  |\n-2 |     let X = 5;\n-  |         ^\n-  |\n-```\n-\n-## non-upper-case-globals\n-\n-This lint detects static constants that don't have uppercase identifiers.\n-Some example code that triggers this lint:\n-\n-```rust\n-static x: i32 = 5;\n-```\n-\n-This will produce:\n-\n-```text\n-warning: static variable `x` should have an upper case name such as `X`\n- --> src/main.rs:1:1\n-  |\n-1 | static x: i32 = 5;\n-  | ^^^^^^^^^^^^^^^^^^\n-  |\n-```\n-\n-## no-mangle-generic-items\n-\n-This lint detects generic items must be mangled. Some\n-example code that triggers this lint:\n-\n-```rust\n-#[no_mangle]\n-fn foo<T>(t: T) {\n-\n-}\n-```\n-\n-This will produce:\n-\n-```text\n-warning: functions generic over types must be mangled\n- --> src/main.rs:2:1\n-  |\n-1 |   #[no_mangle]\n-  |   ------------ help: remove this attribute\n-2 | / fn foo<T>(t: T) {\n-3 | |\n-4 | | }\n-  | |_^\n-  |\n-```\n-\n-## path-statements\n-\n-This lint detects path statements with no effect. Some example code that\n-triggers this lint:\n-\n-```rust\n-let x = 42;\n-\n-x;\n-```\n-\n-This will produce:\n-\n-```text\n-warning: path statement with no effect\n- --> src/main.rs:3:5\n-  |\n-3 |     x;\n-  |     ^^\n-  |\n-```\n-\n-## private-in-public\n-\n-This lint detects private items in public interfaces not caught by the old implementation. Some\n-example code that triggers this lint:\n-\n-```rust,ignore\n-pub trait Trait {\n-    type A;\n-}\n-\n-pub struct S;\n-\n-mod foo {\n-    struct Z;\n-\n-    impl ::Trait for ::S {\n-        type A = Z;\n-    }\n-}\n-# fn main() {}\n-```\n-\n-This will produce:\n-\n-```text\n-error[E0446]: private type `foo::Z` in public interface\n-  --> src/main.rs:11:9\n-   |\n-11 |         type A = Z;\n-   |         ^^^^^^^^^^^ can't leak private type\n-```\n-\n-## private-no-mangle-fns\n-\n-This lint detects functions marked `#[no_mangle]` that are also private.\n-Given that private functions aren't exposed publicly, and `#[no_mangle]`\n-controls the public symbol, this combination is erroneous. Some example code\n-that triggers this lint:\n-\n-```rust\n-#[no_mangle]\n-fn foo() {}\n-```\n-\n-This will produce:\n-\n-```text\n-warning: function is marked `#[no_mangle]`, but not exported\n- --> src/main.rs:2:1\n-  |\n-2 | fn foo() {}\n-  | -^^^^^^^^^^\n-  | |\n-  | help: try making it public: `pub`\n-  |\n-```\n-\n-To fix this, either make it public or remove the `#[no_mangle]`.\n-\n-## private-no-mangle-statics\n-\n-This lint detects any statics marked `#[no_mangle]` that are private.\n-Given that private statics aren't exposed publicly, and `#[no_mangle]`\n-controls the public symbol, this combination is erroneous. Some example code\n-that triggers this lint:\n-\n-```rust\n-#[no_mangle]\n-static X: i32 = 4;\n-```\n-\n-This will produce:\n-\n-```text\n-warning: static is marked `#[no_mangle]`, but not exported\n- --> src/main.rs:2:1\n-  |\n-2 | static X: i32 = 4;\n-  | -^^^^^^^^^^^^^^^^^\n-  | |\n-  | help: try making it public: `pub`\n-  |\n-```\n-\n-To fix this, either make it public or remove the `#[no_mangle]`.\n-\n-## renamed-and-removed-lints\n-\n-This lint detects lints that have been renamed or removed. Some\n-example code that triggers this lint:\n-\n-```rust\n-#![deny(raw_pointer_derive)]\n-```\n-\n-This will produce:\n-\n-```text\n-warning: lint raw_pointer_derive has been removed: using derive with raw pointers is ok\n- --> src/main.rs:1:9\n-  |\n-1 | #![deny(raw_pointer_derive)]\n-  |         ^^^^^^^^^^^^^^^^^^\n-  |\n-```\n-\n-To fix this, either remove the lint or use the new name.\n-\n-## safe-packed-borrows\n-\n-This lint detects borrowing a field in the interior of a packed structure\n-with alignment other than 1. Some example code that triggers this lint:\n-\n-```rust\n-#[repr(packed)]\n-pub struct Unaligned<T>(pub T);\n-\n-pub struct Foo {\n-    start: u8,\n-    data: Unaligned<u32>,\n-}\n-\n-fn main() {\n-    let x = Foo { start: 0, data: Unaligned(1) };\n-    let y = &x.data.0;\n-}\n-```\n-\n-This will produce:\n-\n-```text\n-warning: borrow of packed field requires unsafe function or block (error E0133)\n-  --> src/main.rs:11:13\n-   |\n-11 |     let y = &x.data.0;\n-   |             ^^^^^^^^^\n-   |\n-   = note: `#[warn(safe_packed_borrows)]` on by default\n-   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n-   = note: for more information, see issue #46043 <https://github.com/rust-lang/rust/issues/46043>\n-```\n-\n-## stable-features\n-\n-This lint detects a `#[feature]` attribute that's since been made stable. Some\n-example code that triggers this lint:\n-\n-```rust\n-#![feature(test_accepted_feature)]\n-```\n-\n-This will produce:\n-\n-```text\n-warning: this feature has been stable since 1.0.0. Attribute no longer needed\n- --> src/main.rs:1:12\n-  |\n-1 | #![feature(test_accepted_feature)]\n-  |            ^^^^^^^^^^^^^^^^^^^^^\n-  |\n-```\n-\n-To fix, simply remove the `#![feature]` attribute, as it's no longer needed.\n-\n-## type-alias-bounds\n-\n-This lint detects bounds in type aliases. These are not currently enforced.\n-Some example code that triggers this lint:\n-\n-```rust\n-#[allow(dead_code)]\n-type SendVec<T: Send> = Vec<T>;\n-```\n-\n-This will produce:\n-\n-```text\n-warning: bounds on generic parameters are not enforced in type aliases\n- --> src/lib.rs:2:17\n-  |\n-2 | type SendVec<T: Send> = Vec<T>;\n-  |                 ^^^^\n-  |\n-  = note: `#[warn(type_alias_bounds)]` on by default\n-  = help: the bound will not be checked when the type alias is used, and should be removed\n-```\n-\n-## tyvar-behind-raw-pointer\n-\n-This lint detects raw pointer to an inference variable. Some\n-example code that triggers this lint:\n-\n-```rust\n-let data = std::ptr::null();\n-let _ = &data as *const *const ();\n-\n-if data.is_null() {}\n-```\n-\n-This will produce:\n-\n-```text\n-warning: type annotations needed\n- --> src/main.rs:4:13\n-  |\n-4 |     if data.is_null() {}\n-  |             ^^^^^^^\n-  |\n-  = note: `#[warn(tyvar_behind_raw_pointer)]` on by default\n-  = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in the 2018 edition!\n-  = note: for more information, see issue #46906 <https://github.com/rust-lang/rust/issues/46906>\n-```\n-\n-## unconditional-recursion\n-\n-This lint detects functions that cannot return without calling themselves.\n-Some example code that triggers this lint:\n-\n-```rust\n-fn foo() {\n-    foo();\n-}\n-```\n-\n-This will produce:\n-\n-```text\n-warning: function cannot return without recursing\n- --> src/main.rs:1:1\n-  |\n-1 | fn foo() {\n-  | ^^^^^^^^ cannot return without recursing\n-2 |     foo();\n-  |     ----- recursive call site\n-  |\n-```\n-\n-## unknown-lints\n-\n-This lint detects unrecognized lint attribute. Some\n-example code that triggers this lint:\n-\n-```rust,ignore\n-#[allow(not_a_real_lint)]\n-```\n-\n-This will produce:\n-\n-```text\n-warning: unknown lint: `not_a_real_lint`\n- --> src/main.rs:1:10\n-  |\n-1 | #![allow(not_a_real_lint)]\n-  |          ^^^^^^^^^^^^^^^\n-  |\n-```\n-\n-## unreachable-code\n-\n-This lint detects unreachable code paths. Some example code that\n-triggers this lint:\n-\n-```rust,no_run\n-panic!(\"we never go past here!\");\n-\n-let x = 5;\n-```\n-\n-This will produce:\n-\n-```text\n-warning: unreachable statement\n- --> src/main.rs:4:5\n-  |\n-4 |     let x = 5;\n-  |     ^^^^^^^^^^\n-  |\n-```\n-\n-## unreachable-patterns\n-\n-This lint detects unreachable patterns. Some\n-example code that triggers this lint:\n-\n-```rust\n-let x = 5;\n-match x {\n-    y => (),\n-    5 => (),\n-}\n-```\n-\n-This will produce:\n-\n-```text\n-warning: unreachable pattern\n- --> src/main.rs:5:5\n-  |\n-5 |     5 => (),\n-  |     ^\n-  |\n-```\n-\n-The `y` pattern will always match, so the five is impossible to reach.\n-Remember, match arms match in order, you probably wanted to put the `5` case\n-above the `y` case.\n-\n-## unstable-name-collision\n-\n-This lint detects that you've used a name that the standard library plans to\n-add in the future, which means that your code may fail to compile without\n-additional type annotations in the future. Either rename, or add those\n-annotations now.\n-\n-## unused-allocation\n-\n-This lint detects unnecessary allocations that can be eliminated.\n-\n-## unused-assignments\n-\n-This lint detects assignments that will never be read. Some\n-example code that triggers this lint:\n-\n-```rust\n-let mut x = 5;\n-x = 6;\n-```\n-\n-This will produce:\n-\n-```text\n-warning: value assigned to `x` is never read\n- --> src/main.rs:4:5\n-  |\n-4 |     x = 6;\n-  |     ^\n-  |\n-```\n-\n-## unused-attributes\n-\n-This lint detects attributes that were not used by the compiler. Some\n-example code that triggers this lint:\n-\n-```rust\n-#![macro_export]\n-```\n-\n-This will produce:\n-\n-```text\n-warning: unused attribute\n- --> src/main.rs:1:1\n-  |\n-1 | #![macro_export]\n-  | ^^^^^^^^^^^^^^^^\n-  |\n-```\n-\n-## unused-comparisons\n-\n-This lint detects comparisons made useless by limits of the types involved. Some\n-example code that triggers this lint:\n-\n-```rust\n-fn foo(x: u8) {\n-    x >= 0;\n-}\n-```\n-\n-This will produce:\n-\n-```text\n-warning: comparison is useless due to type limits\n- --> src/main.rs:6:5\n-  |\n-6 |     x >= 0;\n-  |     ^^^^^^\n-  |\n-```\n-\n-## unused-doc-comment\n-\n-This lint detects doc comments that aren't used by rustdoc. Some\n-example code that triggers this lint:\n-\n-```rust\n-/// docs for x\n-let x = 12;\n-```\n-\n-This will produce:\n-\n-```text\n-warning: doc comment not used by rustdoc\n- --> src/main.rs:2:5\n-  |\n-2 |     /// docs for x\n-  |     ^^^^^^^^^^^^^^\n-  |\n-```\n-\n-## unused-features\n-\n-This lint detects unused or unknown features found in crate-level `#[feature]` directives.\n-To fix this, simply remove the feature flag.\n-\n-## unused-imports\n-\n-This lint detects imports that are never used. Some\n-example code that triggers this lint:\n-\n-```rust\n-use std::collections::HashMap;\n-```\n-\n-This will produce:\n-\n-```text\n-warning: unused import: `std::collections::HashMap`\n- --> src/main.rs:1:5\n-  |\n-1 | use std::collections::HashMap;\n-  |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n-  |\n-```\n-\n-## unused-macros\n-\n-This lint detects macros that were not used. Some example code that\n-triggers this lint:\n-\n-```rust\n-macro_rules! unused {\n-    () => {};\n-}\n-\n-fn main() {\n-}\n-```\n-\n-This will produce:\n-\n-```text\n-warning: unused macro definition\n- --> src/main.rs:1:1\n-  |\n-1 | / macro_rules! unused {\n-2 | |     () => {};\n-3 | | }\n-  | |_^\n-  |\n-```\n-\n-## unused-must-use\n-\n-This lint detects unused result of a type flagged as `#[must_use]`. Some\n-example code that triggers this lint:\n-\n-```rust\n-fn returns_result() -> Result<(), ()> {\n-    Ok(())\n-}\n-\n-fn main() {\n-    returns_result();\n-}\n-```\n-\n-This will produce:\n-\n-```text\n-warning: unused `std::result::Result` that must be used\n- --> src/main.rs:6:5\n-  |\n-6 |     returns_result();\n-  |     ^^^^^^^^^^^^^^^^^\n-  |\n-```\n-\n-## unused-mut\n-\n-This lint detects mut variables which don't need to be mutable. Some\n-example code that triggers this lint:\n-\n-```rust\n-let mut x = 5;\n-```\n-\n-This will produce:\n-\n-```text\n-warning: variable does not need to be mutable\n- --> src/main.rs:2:9\n-  |\n-2 |     let mut x = 5;\n-  |         ----^\n-  |         |\n-  |         help: remove this `mut`\n-  |\n-```\n-\n-## unused-parens\n-\n-This lint detects `if`, `match`, `while` and `return` with parentheses; they\n-do not need them. Some example code that triggers this lint:\n-\n-```rust\n-if(true) {}\n-```\n-\n-This will produce:\n-\n-```text\n-warning: unnecessary parentheses around `if` condition\n- --> src/main.rs:2:7\n-  |\n-2 |     if(true) {}\n-  |       ^^^^^^ help: remove these parentheses\n-  |\n-```\n-\n-## unused-unsafe\n-\n-This lint detects unnecessary use of an `unsafe` block. Some\n-example code that triggers this lint:\n-\n-```rust\n-unsafe {}\n-```\n-\n-This will produce:\n-\n-```text\n-warning: unnecessary `unsafe` block\n- --> src/main.rs:2:5\n-  |\n-2 |     unsafe {}\n-  |     ^^^^^^ unnecessary `unsafe` block\n-  |\n-```\n-\n-## unused-variables\n-\n-This lint detects variables which are not used in any way. Some\n-example code that triggers this lint:\n-\n-```rust\n-let x = 5;\n-```\n-\n-This will produce:\n-\n-```text\n-warning: unused variable: `x`\n- --> src/main.rs:2:9\n-  |\n-2 |     let x = 5;\n-  |         ^ help: consider using `_x` instead\n-  |\n-```\n-\n-## warnings\n-\n-This lint is a bit special; by changing its level, you change every other warning\n-that would produce a warning to whatever value you'd like:\n-\n-```rust\n-#![deny(warnings)]\n-```\n-\n-As such, you won't ever trigger this lint in your code directly.\n-\n-## while-true\n-\n-This lint detects `while true { }`. Some example code that triggers this\n-lint:\n-\n-```rust,no_run\n-while true {\n-\n-}\n-```\n-\n-This will produce:\n-\n-```text\n-warning: denote infinite loops with `loop { ... }`\n- --> src/main.rs:2:5\n-  |\n-2 |     while true {\n-  |     ^^^^^^^^^^ help: use `loop`\n-  |\n-```\n+This file is auto-generated by the lint-docs script."}, {"sha": "657b115671e340e06c84c843d5a7682445aee60b", "filename": "src/tools/lint-docs/Cargo.toml", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/45c1e0ae07b9581d8c2d2b39315ac7cc79475d75/src%2Ftools%2Flint-docs%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/45c1e0ae07b9581d8c2d2b39315ac7cc79475d75/src%2Ftools%2Flint-docs%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Flint-docs%2FCargo.toml?ref=45c1e0ae07b9581d8c2d2b39315ac7cc79475d75", "patch": "@@ -0,0 +1,13 @@\n+[package]\n+name = \"lint-docs\"\n+version = \"0.1.0\"\n+authors = [\"The Rust Project Developers\"]\n+edition = \"2018\"\n+description = \"A script to extract the lint documentation for the rustc book.\"\n+\n+# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\n+\n+[dependencies]\n+serde_json = \"1.0.57\"\n+tempfile = \"3.1.0\"\n+walkdir = \"2.3.1\""}, {"sha": "a212459bb4dc607967a2d0d7fd98c135b84fde15", "filename": "src/tools/lint-docs/src/groups.rs", "status": "added", "additions": 114, "deletions": 0, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/45c1e0ae07b9581d8c2d2b39315ac7cc79475d75/src%2Ftools%2Flint-docs%2Fsrc%2Fgroups.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45c1e0ae07b9581d8c2d2b39315ac7cc79475d75/src%2Ftools%2Flint-docs%2Fsrc%2Fgroups.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Flint-docs%2Fsrc%2Fgroups.rs?ref=45c1e0ae07b9581d8c2d2b39315ac7cc79475d75", "patch": "@@ -0,0 +1,114 @@\n+use crate::Lint;\n+use std::collections::{BTreeMap, BTreeSet};\n+use std::error::Error;\n+use std::fmt::Write;\n+use std::fs;\n+use std::path::Path;\n+use std::process::Command;\n+\n+static GROUP_DESCRIPTIONS: &[(&str, &str)] = &[\n+    (\"unused\", \"Lints that detect things being declared but not used, or excess syntax\"),\n+    (\"rustdoc\", \"Rustdoc-specific lints\"),\n+    (\"rust-2018-idioms\", \"Lints to nudge you toward idiomatic features of Rust 2018\"),\n+    (\"nonstandard-style\", \"Violation of standard naming conventions\"),\n+    (\"future-incompatible\", \"Lints that detect code that has future-compatibility problems\"),\n+    (\"rust-2018-compatibility\", \"Lints used to transition code from the 2015 edition to 2018\"),\n+];\n+\n+/// Updates the documentation of lint groups.\n+pub(crate) fn generate_group_docs(\n+    lints: &[Lint],\n+    rustc_path: &Path,\n+    out_path: &Path,\n+) -> Result<(), Box<dyn Error>> {\n+    let groups = collect_groups(rustc_path)?;\n+    let groups_path = out_path.join(\"groups.md\");\n+    let contents = fs::read_to_string(&groups_path)\n+        .map_err(|e| format!(\"could not read {}: {}\", groups_path.display(), e))?;\n+    let new_contents = contents.replace(\"{{groups-table}}\", &make_groups_table(lints, &groups)?);\n+    // Delete the output because rustbuild uses hard links in its copies.\n+    let _ = fs::remove_file(&groups_path);\n+    fs::write(&groups_path, new_contents)\n+        .map_err(|e| format!(\"could not write to {}: {}\", groups_path.display(), e))?;\n+    Ok(())\n+}\n+\n+type LintGroups = BTreeMap<String, BTreeSet<String>>;\n+\n+/// Collects the group names from rustc.\n+fn collect_groups(rustc: &Path) -> Result<LintGroups, Box<dyn Error>> {\n+    let mut result = BTreeMap::new();\n+    let mut cmd = Command::new(rustc);\n+    cmd.arg(\"-Whelp\");\n+    let output = cmd.output().map_err(|e| format!(\"failed to run command {:?}\\n{}\", cmd, e))?;\n+    if !output.status.success() {\n+        return Err(format!(\n+            \"failed to collect lint info: {:?}\\n--- stderr\\n{}--- stdout\\n{}\\n\",\n+            output.status,\n+            std::str::from_utf8(&output.stderr).unwrap(),\n+            std::str::from_utf8(&output.stdout).unwrap(),\n+        )\n+        .into());\n+    }\n+    let stdout = std::str::from_utf8(&output.stdout).unwrap();\n+    let lines = stdout.lines();\n+    let group_start = lines.skip_while(|line| !line.contains(\"groups provided\")).skip(1);\n+    let table_start = group_start.skip_while(|line| !line.contains(\"----\")).skip(1);\n+    for line in table_start {\n+        if line.is_empty() {\n+            break;\n+        }\n+        let mut parts = line.trim().splitn(2, ' ');\n+        let name = parts.next().expect(\"name in group\");\n+        if name == \"warnings\" {\n+            // This is special.\n+            continue;\n+        }\n+        let lints =\n+            parts.next().ok_or_else(|| format!(\"expected lints following name, got `{}`\", line))?;\n+        let lints = lints.split(',').map(|l| l.trim().to_string()).collect();\n+        assert!(result.insert(name.to_string(), lints).is_none());\n+    }\n+    if result.is_empty() {\n+        return Err(\n+            format!(\"expected at least one group in -Whelp output, got:\\n{}\", stdout).into()\n+        );\n+    }\n+    Ok(result)\n+}\n+\n+fn make_groups_table(lints: &[Lint], groups: &LintGroups) -> Result<String, Box<dyn Error>> {\n+    let mut result = String::new();\n+    let mut to_link = Vec::new();\n+    result.push_str(\"| Group | Description | Lints |\\n\");\n+    result.push_str(\"|-------|-------------|-------|\\n\");\n+    result.push_str(\"| warnings | All lints that are set to issue warnings | See [warn-by-default] for the default set of warnings |\\n\");\n+    for (group_name, group_lints) in groups {\n+        let description = GROUP_DESCRIPTIONS.iter().find(|(n, _)| n == group_name)\n+            .ok_or_else(|| format!(\"lint group `{}` does not have a description, please update the GROUP_DESCRIPTIONS list\", group_name))?\n+            .1;\n+        to_link.extend(group_lints);\n+        let brackets: Vec<_> = group_lints.iter().map(|l| format!(\"[{}]\", l)).collect();\n+        write!(result, \"| {} | {} | {} |\\n\", group_name, description, brackets.join(\", \")).unwrap();\n+    }\n+    result.push('\\n');\n+    result.push_str(\"[warn-by-default]: listing/warn-by-default.md\\n\");\n+    for lint_name in to_link {\n+        let lint_def =\n+            lints.iter().find(|l| l.name == lint_name.replace(\"-\", \"_\")).ok_or_else(|| {\n+                format!(\n+                    \"`rustc -W help` defined lint `{}` but that lint does not appear to exist\",\n+                    lint_name\n+                )\n+            })?;\n+        write!(\n+            result,\n+            \"[{}]: listing/{}#{}\\n\",\n+            lint_name,\n+            lint_def.level.doc_filename(),\n+            lint_name\n+        )\n+        .unwrap();\n+    }\n+    Ok(result)\n+}"}, {"sha": "b1e14ea6c466bc2a2335488bb27a4a7dc034d4d0", "filename": "src/tools/lint-docs/src/lib.rs", "status": "added", "additions": 463, "deletions": 0, "changes": 463, "blob_url": "https://github.com/rust-lang/rust/blob/45c1e0ae07b9581d8c2d2b39315ac7cc79475d75/src%2Ftools%2Flint-docs%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45c1e0ae07b9581d8c2d2b39315ac7cc79475d75/src%2Ftools%2Flint-docs%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Flint-docs%2Fsrc%2Flib.rs?ref=45c1e0ae07b9581d8c2d2b39315ac7cc79475d75", "patch": "@@ -0,0 +1,463 @@\n+use std::error::Error;\n+use std::fmt::Write;\n+use std::fs;\n+use std::path::{Path, PathBuf};\n+use std::process::Command;\n+use walkdir::WalkDir;\n+\n+mod groups;\n+\n+struct Lint {\n+    name: String,\n+    doc: Vec<String>,\n+    level: Level,\n+    path: PathBuf,\n+    lineno: usize,\n+}\n+\n+#[derive(Clone, Copy, PartialEq)]\n+enum Level {\n+    Allow,\n+    Warn,\n+    Deny,\n+}\n+\n+impl Level {\n+    fn doc_filename(&self) -> &str {\n+        match self {\n+            Level::Allow => \"allowed-by-default.md\",\n+            Level::Warn => \"warn-by-default.md\",\n+            Level::Deny => \"deny-by-default.md\",\n+        }\n+    }\n+}\n+\n+/// Collects all lints, and writes the markdown documentation at the given directory.\n+pub fn extract_lint_docs(\n+    src_path: &Path,\n+    out_path: &Path,\n+    rustc_path: &Path,\n+    rustdoc_path: &Path,\n+    verbose: bool,\n+) -> Result<(), Box<dyn Error>> {\n+    let mut lints = gather_lints(src_path)?;\n+    for lint in &mut lints {\n+        generate_output_example(lint, rustc_path, rustdoc_path, verbose).map_err(|e| {\n+            format!(\n+                \"failed to test example in lint docs for `{}` in {}:{}: {}\",\n+                lint.name,\n+                lint.path.display(),\n+                lint.lineno,\n+                e\n+            )\n+        })?;\n+    }\n+    save_lints_markdown(&lints, &out_path.join(\"listing\"))?;\n+    groups::generate_group_docs(&lints, rustc_path, out_path)?;\n+    Ok(())\n+}\n+\n+/// Collects all lints from all files in the given directory.\n+fn gather_lints(src_path: &Path) -> Result<Vec<Lint>, Box<dyn Error>> {\n+    let mut lints = Vec::new();\n+    for entry in WalkDir::new(src_path).into_iter().filter_map(|e| e.ok()) {\n+        if !entry.path().extension().map_or(false, |ext| ext == \"rs\") {\n+            continue;\n+        }\n+        lints.extend(lints_from_file(entry.path())?);\n+    }\n+    if lints.is_empty() {\n+        return Err(\"no lints were found!\".into());\n+    }\n+    Ok(lints)\n+}\n+\n+/// Collects all lints from the given file.\n+fn lints_from_file(path: &Path) -> Result<Vec<Lint>, Box<dyn Error>> {\n+    let mut lints = Vec::new();\n+    let contents = fs::read_to_string(path)\n+        .map_err(|e| format!(\"could not read {}: {}\", path.display(), e))?;\n+    let mut lines = contents.lines().enumerate();\n+    loop {\n+        // Find a lint declaration.\n+        let lint_start = loop {\n+            match lines.next() {\n+                Some((lineno, line)) => {\n+                    if line.trim().starts_with(\"declare_lint!\") {\n+                        break lineno + 1;\n+                    }\n+                }\n+                None => return Ok(lints),\n+            }\n+        };\n+        // Read the lint.\n+        let mut doc_lines = Vec::new();\n+        let (doc, name) = loop {\n+            match lines.next() {\n+                Some((lineno, line)) => {\n+                    let line = line.trim();\n+                    if line.starts_with(\"/// \") {\n+                        doc_lines.push(line.trim()[4..].to_string());\n+                    } else if line.starts_with(\"///\") {\n+                        doc_lines.push(\"\".to_string());\n+                    } else if line.starts_with(\"// \") {\n+                        // Ignore comments.\n+                        continue;\n+                    } else {\n+                        let name = lint_name(line).map_err(|e| {\n+                            format!(\n+                                \"could not determine lint name in {}:{}: {}, line was `{}`\",\n+                                path.display(),\n+                                lineno,\n+                                e,\n+                                line\n+                            )\n+                        })?;\n+                        if doc_lines.is_empty() {\n+                            return Err(format!(\n+                                \"did not find doc lines for lint `{}` in {}\",\n+                                name,\n+                                path.display()\n+                            )\n+                            .into());\n+                        }\n+                        break (doc_lines, name);\n+                    }\n+                }\n+                None => {\n+                    return Err(format!(\n+                        \"unexpected EOF for lint definition at {}:{}\",\n+                        path.display(),\n+                        lint_start\n+                    )\n+                    .into());\n+                }\n+            }\n+        };\n+        // These lints are specifically undocumented. This should be reserved\n+        // for internal rustc-lints only.\n+        if name == \"deprecated_in_future\" {\n+            continue;\n+        }\n+        // Read the level.\n+        let level = loop {\n+            match lines.next() {\n+                // Ignore comments.\n+                Some((_, line)) if line.trim().starts_with(\"// \") => {}\n+                Some((lineno, line)) => match line.trim() {\n+                    \"Allow,\" => break Level::Allow,\n+                    \"Warn,\" => break Level::Warn,\n+                    \"Deny,\" => break Level::Deny,\n+                    _ => {\n+                        return Err(format!(\n+                            \"unexpected lint level `{}` in {}:{}\",\n+                            line,\n+                            path.display(),\n+                            lineno\n+                        )\n+                        .into());\n+                    }\n+                },\n+                None => {\n+                    return Err(format!(\n+                        \"expected lint level in {}:{}, got EOF\",\n+                        path.display(),\n+                        lint_start\n+                    )\n+                    .into());\n+                }\n+            }\n+        };\n+        // The rest of the lint definition is ignored.\n+        assert!(!doc.is_empty());\n+        lints.push(Lint { name, doc, level, path: PathBuf::from(path), lineno: lint_start });\n+    }\n+}\n+\n+/// Extracts the lint name (removing the visibility modifier, and checking validity).\n+fn lint_name(line: &str) -> Result<String, &'static str> {\n+    // Skip over any potential `pub` visibility.\n+    match line.trim().split(' ').next_back() {\n+        Some(name) => {\n+            if !name.ends_with(',') {\n+                return Err(\"lint name should end with comma\");\n+            }\n+            let name = &name[..name.len() - 1];\n+            if !name.chars().all(|ch| ch.is_uppercase() || ch == '_') || name.is_empty() {\n+                return Err(\"lint name did not have expected format\");\n+            }\n+            Ok(name.to_lowercase().to_string())\n+        }\n+        None => Err(\"could not find lint name\"),\n+    }\n+}\n+\n+/// Mutates the lint definition to replace the `{{produces}}` marker with the\n+/// actual output from the compiler.\n+fn generate_output_example(\n+    lint: &mut Lint,\n+    rustc_path: &Path,\n+    rustdoc_path: &Path,\n+    verbose: bool,\n+) -> Result<(), Box<dyn Error>> {\n+    // Explicit list of lints that are allowed to not have an example. Please\n+    // try to avoid adding to this list.\n+    if matches!(\n+        lint.name.as_str(),\n+        \"unused_features\"\n+            | \"unstable_features\"\n+            | \"incomplete_include\"\n+            | \"unused_crate_dependencies\"\n+            | \"exported_private_dependencies\"\n+            | \"proc_macro_derive_resolution_fallback\"\n+            | \"macro_use_extern_crate\"\n+    ) {\n+        return Ok(());\n+    }\n+    check_style(lint)?;\n+    replace_produces(lint, rustc_path, rustdoc_path, verbose)?;\n+    Ok(())\n+}\n+\n+/// Checks the doc style of the lint.\n+fn check_style(lint: &Lint) -> Result<(), Box<dyn Error>> {\n+    for expected in &[\"### Example\", \"### Explanation\", \"{{produces}}\"] {\n+        if !lint.doc.iter().any(|line| line.contains(expected)) {\n+            return Err(format!(\"lint docs should contain the line `{}`\", expected).into());\n+        }\n+    }\n+    if let Some(first) = lint.doc.first() {\n+        if !first.starts_with(&format!(\"The `{}` lint\", lint.name)) {\n+            return Err(format!(\n+                \"lint docs should start with the text \\\"The `{}` lint\\\" to introduce the lint\",\n+                lint.name\n+            )\n+            .into());\n+        }\n+    }\n+    Ok(())\n+}\n+\n+/// Mutates the lint docs to replace the `{{produces}}` marker with the actual\n+/// output from the compiler.\n+fn replace_produces(\n+    lint: &mut Lint,\n+    rustc_path: &Path,\n+    rustdoc_path: &Path,\n+    verbose: bool,\n+) -> Result<(), Box<dyn Error>> {\n+    let mut lines = lint.doc.iter_mut();\n+    loop {\n+        // Find start of example.\n+        let options = loop {\n+            match lines.next() {\n+                Some(line) if line.starts_with(\"```rust\") => {\n+                    break line[7..].split(',').collect::<Vec<_>>();\n+                }\n+                Some(line) if line.contains(\"{{produces}}\") => {\n+                    return Err(\"lint marker {{{{produces}}}} found, \\\n+                        but expected to immediately follow a rust code block\"\n+                        .into());\n+                }\n+                Some(_) => {}\n+                None => return Ok(()),\n+            }\n+        };\n+        // Find the end of example.\n+        let mut example = Vec::new();\n+        loop {\n+            match lines.next() {\n+                Some(line) if line == \"```\" => break,\n+                Some(line) => example.push(line),\n+                None => {\n+                    return Err(format!(\n+                        \"did not find end of example triple ticks ```, docs were:\\n{:?}\",\n+                        lint.doc\n+                    )\n+                    .into());\n+                }\n+            }\n+        }\n+        // Find the {{produces}} line.\n+        loop {\n+            match lines.next() {\n+                Some(line) if line.is_empty() => {}\n+                Some(line) if line == \"{{produces}}\" => {\n+                    let output = generate_lint_output(\n+                        &lint.name,\n+                        &example,\n+                        &options,\n+                        rustc_path,\n+                        rustdoc_path,\n+                        verbose,\n+                    )?;\n+                    line.replace_range(\n+                        ..,\n+                        &format!(\n+                            \"This will produce:\\n\\\n+                        \\n\\\n+                        ```text\\n\\\n+                        {}\\\n+                        ```\",\n+                            output\n+                        ),\n+                    );\n+                    break;\n+                }\n+                // No {{produces}} after example, find next example.\n+                Some(_line) => break,\n+                None => return Ok(()),\n+            }\n+        }\n+    }\n+}\n+\n+/// Runs the compiler against the example, and extracts the output.\n+fn generate_lint_output(\n+    name: &str,\n+    example: &[&mut String],\n+    options: &[&str],\n+    rustc_path: &Path,\n+    rustdoc_path: &Path,\n+    verbose: bool,\n+) -> Result<String, Box<dyn Error>> {\n+    if verbose {\n+        eprintln!(\"compiling lint {}\", name);\n+    }\n+    let tempdir = tempfile::TempDir::new()?;\n+    let tempfile = tempdir.path().join(\"lint_example.rs\");\n+    let mut source = String::new();\n+    let is_rustdoc = options.contains(&\"rustdoc\");\n+    let needs_main = !example.iter().any(|line| line.contains(\"fn main\")) && !is_rustdoc;\n+    // Remove `# ` prefix for hidden lines.\n+    let unhidden =\n+        example.iter().map(|line| if line.starts_with(\"# \") { &line[2..] } else { line });\n+    let mut lines = unhidden.peekable();\n+    while let Some(line) = lines.peek() {\n+        if line.starts_with(\"#!\") {\n+            source.push_str(line);\n+            source.push('\\n');\n+            lines.next();\n+        } else {\n+            break;\n+        }\n+    }\n+    if needs_main {\n+        source.push_str(\"fn main() {\\n\");\n+    }\n+    for line in lines {\n+        source.push_str(line);\n+        source.push('\\n')\n+    }\n+    if needs_main {\n+        source.push_str(\"}\\n\");\n+    }\n+    fs::write(&tempfile, source)\n+        .map_err(|e| format!(\"failed to write {}: {}\", tempfile.display(), e))?;\n+    let program = if is_rustdoc { rustdoc_path } else { rustc_path };\n+    let mut cmd = Command::new(program);\n+    if options.contains(&\"edition2015\") {\n+        cmd.arg(\"--edition=2015\");\n+    } else {\n+        cmd.arg(\"--edition=2018\");\n+    }\n+    cmd.arg(\"--error-format=json\");\n+    if options.contains(&\"test\") {\n+        cmd.arg(\"--test\");\n+    }\n+    cmd.arg(\"lint_example.rs\");\n+    cmd.current_dir(tempdir.path());\n+    let output = cmd.output().map_err(|e| format!(\"failed to run command {:?}\\n{}\", cmd, e))?;\n+    let stderr = std::str::from_utf8(&output.stderr).unwrap();\n+    let msgs = stderr\n+        .lines()\n+        .filter(|line| line.starts_with('{'))\n+        .map(serde_json::from_str)\n+        .collect::<Result<Vec<serde_json::Value>, _>>()?;\n+    match msgs\n+        .iter()\n+        .find(|msg| matches!(&msg[\"code\"][\"code\"], serde_json::Value::String(s) if s==name))\n+    {\n+        Some(msg) => {\n+            let rendered = msg[\"rendered\"].as_str().expect(\"rendered field should exist\");\n+            Ok(rendered.to_string())\n+        }\n+        None => {\n+            match msgs.iter().find(\n+                |msg| matches!(&msg[\"rendered\"], serde_json::Value::String(s) if s.contains(name)),\n+            ) {\n+                Some(msg) => {\n+                    let rendered = msg[\"rendered\"].as_str().expect(\"rendered field should exist\");\n+                    Ok(rendered.to_string())\n+                }\n+                None => {\n+                    let rendered: Vec<&str> =\n+                        msgs.iter().filter_map(|msg| msg[\"rendered\"].as_str()).collect();\n+                    Err(format!(\n+                        \"did not find lint `{}` in output of example, got:\\n{}\",\n+                        name,\n+                        rendered.join(\"\\n\")\n+                    )\n+                    .into())\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+static ALLOWED_MD: &str = r#\"# Allowed-by-default lints\n+\n+These lints are all set to the 'allow' level by default. As such, they won't show up\n+unless you set them to a higher lint level with a flag or attribute.\n+\n+\"#;\n+\n+static WARN_MD: &str = r#\"# Warn-by-default lints\n+\n+These lints are all set to the 'warn' level by default.\n+\n+\"#;\n+\n+static DENY_MD: &str = r#\"# Deny-by-default lints\n+\n+These lints are all set to the 'deny' level by default.\n+\n+\"#;\n+\n+/// Saves the mdbook lint chapters at the given path.\n+fn save_lints_markdown(lints: &[Lint], out_dir: &Path) -> Result<(), Box<dyn Error>> {\n+    save_level(lints, Level::Allow, out_dir, ALLOWED_MD)?;\n+    save_level(lints, Level::Warn, out_dir, WARN_MD)?;\n+    save_level(lints, Level::Deny, out_dir, DENY_MD)?;\n+    Ok(())\n+}\n+\n+fn save_level(\n+    lints: &[Lint],\n+    level: Level,\n+    out_dir: &Path,\n+    header: &str,\n+) -> Result<(), Box<dyn Error>> {\n+    let mut result = String::new();\n+    result.push_str(header);\n+    let mut these_lints: Vec<_> = lints.iter().filter(|lint| lint.level == level).collect();\n+    these_lints.sort_unstable_by_key(|lint| &lint.name);\n+    for lint in &these_lints {\n+        write!(result, \"* [`{}`](#{})\\n\", lint.name, lint.name.replace(\"_\", \"-\")).unwrap();\n+    }\n+    result.push('\\n');\n+    for lint in &these_lints {\n+        write!(result, \"## {}\\n\\n\", lint.name.replace(\"_\", \"-\")).unwrap();\n+        for line in &lint.doc {\n+            result.push_str(line);\n+            result.push('\\n');\n+        }\n+        result.push('\\n');\n+    }\n+    let out_path = out_dir.join(level.doc_filename());\n+    // Delete the output because rustbuild uses hard links in its copies.\n+    let _ = fs::remove_file(&out_path);\n+    fs::write(&out_path, result)\n+        .map_err(|e| format!(\"could not write to {}: {}\", out_path.display(), e))?;\n+    Ok(())\n+}"}, {"sha": "4b824596b467378b38751af574cf1c19ef27fbde", "filename": "src/tools/lint-docs/src/main.rs", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/45c1e0ae07b9581d8c2d2b39315ac7cc79475d75/src%2Ftools%2Flint-docs%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45c1e0ae07b9581d8c2d2b39315ac7cc79475d75/src%2Ftools%2Flint-docs%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Flint-docs%2Fsrc%2Fmain.rs?ref=45c1e0ae07b9581d8c2d2b39315ac7cc79475d75", "patch": "@@ -0,0 +1,67 @@\n+use std::error::Error;\n+use std::path::PathBuf;\n+\n+fn main() {\n+    if let Err(e) = doit() {\n+        println!(\"error: {}\", e);\n+        std::process::exit(1);\n+    }\n+}\n+\n+fn doit() -> Result<(), Box<dyn Error>> {\n+    let mut args = std::env::args().skip(1);\n+    let mut src_path = None;\n+    let mut out_path = None;\n+    let mut rustc_path = None;\n+    let mut rustdoc_path = None;\n+    let mut verbose = false;\n+    while let Some(arg) = args.next() {\n+        match arg.as_str() {\n+            \"--src\" => {\n+                src_path = match args.next() {\n+                    Some(s) => Some(PathBuf::from(s)),\n+                    None => return Err(\"--src requires a value\".into()),\n+                };\n+            }\n+            \"--out\" => {\n+                out_path = match args.next() {\n+                    Some(s) => Some(PathBuf::from(s)),\n+                    None => return Err(\"--out requires a value\".into()),\n+                };\n+            }\n+            \"--rustc\" => {\n+                rustc_path = match args.next() {\n+                    Some(s) => Some(PathBuf::from(s)),\n+                    None => return Err(\"--rustc requires a value\".into()),\n+                };\n+            }\n+            \"--rustdoc\" => {\n+                rustdoc_path = match args.next() {\n+                    Some(s) => Some(PathBuf::from(s)),\n+                    None => return Err(\"--rustdoc requires a value\".into()),\n+                };\n+            }\n+            \"-v\" | \"--verbose\" => verbose = true,\n+            s => return Err(format!(\"unexpected argument `{}`\", s).into()),\n+        }\n+    }\n+    if src_path.is_none() {\n+        return Err(\"--src must be specified to the directory with the compiler source\".into());\n+    }\n+    if out_path.is_none() {\n+        return Err(\"--out must be specified to the directory with the lint listing docs\".into());\n+    }\n+    if rustc_path.is_none() {\n+        return Err(\"--rustc must be specified to the path of rustc\".into());\n+    }\n+    if rustdoc_path.is_none() {\n+        return Err(\"--rustdoc must be specified to the path of rustdoc\".into());\n+    }\n+    lint_docs::extract_lint_docs(\n+        &src_path.unwrap(),\n+        &out_path.unwrap(),\n+        &rustc_path.unwrap(),\n+        &rustdoc_path.unwrap(),\n+        verbose,\n+    )\n+}"}]}