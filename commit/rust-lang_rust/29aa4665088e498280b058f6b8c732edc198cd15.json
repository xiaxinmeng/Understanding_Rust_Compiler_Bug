{"sha": "29aa4665088e498280b058f6b8c732edc198cd15", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI5YWE0NjY1MDg4ZTQ5ODI4MGIwNThmNmI4YzczMmVkYzE5OGNkMTU=", "commit": {"author": {"name": "Pietro Albini", "email": "pietro@pietroalbini.org", "date": "2018-12-19T10:47:09Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2018-12-19T10:47:09Z"}, "message": "Rollup merge of #56820 - ljedrz:format_tweaks, r=alexcrichton\n\nformat-related tweaks\n\n- remove an unreachable condition\n- inline one-liners related to `parse_expr` (called in succession)\n- refactor `report_invalid_references`\n- refactor `verify_arg_type`\n- minor stylistic improvements", "tree": {"sha": "6805e6d3d4fc38f4a86d083e2e1a2749f174007d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6805e6d3d4fc38f4a86d083e2e1a2749f174007d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/29aa4665088e498280b058f6b8c732edc198cd15", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJcGiGtCRBK7hj4Ov3rIwAAdHIIACuhkUKOazRnxJPZviKlqnYL\nvJDcV0E7mCjy51AyT4DscwIOnphKVAftrngtlHChNqBJaVWOZkySk4hrZlYYj6Ef\nGU3pqsv45TlgvknFPqGkpTHoDvf7PZIqxagfdQSEWN/lhtzlGanoOh9o61Yx6K7i\nszFn74lShUxz7iMZ4MMuQ4Wt3dt/goOwB+xaMn0WjG1SAi1yBjw9eX52OKu2Ctth\n4UWOxD5qCuW/litZade0xTHAPmV7dfySYxmsmmTklLxlk+x4iiRuKJjt4rKJ4+Be\n54c8U97ZVpIMO+5q9sTxq2cGICNsg7WYyp6or+MiCBQLFbz7+d4/icWT6iB3kSY=\n=c73N\n-----END PGP SIGNATURE-----\n", "payload": "tree 6805e6d3d4fc38f4a86d083e2e1a2749f174007d\nparent 6e1cc227611b70a8691757034a9b206a35d2bfc2\nparent 959313aad0a7d2eb68bd15894b5e6f94580f4582\nauthor Pietro Albini <pietro@pietroalbini.org> 1545216429 +0100\ncommitter GitHub <noreply@github.com> 1545216429 +0100\n\nRollup merge of #56820 - ljedrz:format_tweaks, r=alexcrichton\n\nformat-related tweaks\n\n- remove an unreachable condition\n- inline one-liners related to `parse_expr` (called in succession)\n- refactor `report_invalid_references`\n- refactor `verify_arg_type`\n- minor stylistic improvements\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/29aa4665088e498280b058f6b8c732edc198cd15", "html_url": "https://github.com/rust-lang/rust/commit/29aa4665088e498280b058f6b8c732edc198cd15", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/29aa4665088e498280b058f6b8c732edc198cd15/comments", "author": {"login": "pietroalbini", "id": 2299951, "node_id": "MDQ6VXNlcjIyOTk5NTE=", "avatar_url": "https://avatars.githubusercontent.com/u/2299951?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pietroalbini", "html_url": "https://github.com/pietroalbini", "followers_url": "https://api.github.com/users/pietroalbini/followers", "following_url": "https://api.github.com/users/pietroalbini/following{/other_user}", "gists_url": "https://api.github.com/users/pietroalbini/gists{/gist_id}", "starred_url": "https://api.github.com/users/pietroalbini/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pietroalbini/subscriptions", "organizations_url": "https://api.github.com/users/pietroalbini/orgs", "repos_url": "https://api.github.com/users/pietroalbini/repos", "events_url": "https://api.github.com/users/pietroalbini/events{/privacy}", "received_events_url": "https://api.github.com/users/pietroalbini/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6e1cc227611b70a8691757034a9b206a35d2bfc2", "url": "https://api.github.com/repos/rust-lang/rust/commits/6e1cc227611b70a8691757034a9b206a35d2bfc2", "html_url": "https://github.com/rust-lang/rust/commit/6e1cc227611b70a8691757034a9b206a35d2bfc2"}, {"sha": "959313aad0a7d2eb68bd15894b5e6f94580f4582", "url": "https://api.github.com/repos/rust-lang/rust/commits/959313aad0a7d2eb68bd15894b5e6f94580f4582", "html_url": "https://github.com/rust-lang/rust/commit/959313aad0a7d2eb68bd15894b5e6f94580f4582"}], "stats": {"total": 136, "additions": 55, "deletions": 81}, "files": [{"sha": "5a51b629826ddb60809633841f59313aea4533c2", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/29aa4665088e498280b058f6b8c732edc198cd15/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29aa4665088e498280b058f6b8c732edc198cd15/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=29aa4665088e498280b058f6b8c732edc198cd15", "patch": "@@ -3062,6 +3062,7 @@ impl<'a> Parser<'a> {\n     ///\n     /// This parses an expression accounting for associativity and precedence of the operators in\n     /// the expression.\n+    #[inline]\n     fn parse_assoc_expr(&mut self,\n                             already_parsed_attrs: Option<ThinVec<Attribute>>)\n                             -> PResult<'a, P<Expr>> {\n@@ -3722,6 +3723,7 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parse an expression\n+    #[inline]\n     pub fn parse_expr(&mut self) -> PResult<'a, P<Expr>> {\n         self.parse_expr_res(Restrictions::empty(), None)\n     }\n@@ -3741,6 +3743,7 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parse an expression, subject to the given restrictions\n+    #[inline]\n     fn parse_expr_res(&mut self, r: Restrictions,\n                           already_parsed_attrs: Option<ThinVec<Attribute>>)\n                           -> PResult<'a, P<Expr>> {"}, {"sha": "41799eede9e86d9a7a4405752db3029c5dbaf727", "filename": "src/libsyntax_ext/format.rs", "status": "modified", "additions": 52, "deletions": 81, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/29aa4665088e498280b058f6b8c732edc198cd15/src%2Flibsyntax_ext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29aa4665088e498280b058f6b8c732edc198cd15/src%2Flibsyntax_ext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fformat.rs?ref=29aa4665088e498280b058f6b8c732edc198cd15", "patch": "@@ -158,28 +158,15 @@ fn parse_args(ecx: &mut ExtCtxt,\n         } // accept trailing commas\n         if named || (p.token.is_ident() && p.look_ahead(1, |t| *t == token::Eq)) {\n             named = true;\n-            let ident = match p.token {\n-                token::Ident(i, _) => {\n-                    p.bump();\n-                    i\n-                }\n-                _ if named => {\n-                    ecx.span_err(\n-                        p.span,\n-                        \"expected ident, positional arguments cannot follow named arguments\",\n-                    );\n-                    return None;\n-                }\n-                _ => {\n-                    ecx.span_err(\n-                        p.span,\n-                        &format!(\n-                            \"expected ident for named argument, found `{}`\",\n-                            p.this_token_to_string()\n-                        ),\n-                    );\n-                    return None;\n-                }\n+            let ident = if let token::Ident(i, _) = p.token {\n+                p.bump();\n+                i\n+            } else {\n+                ecx.span_err(\n+                    p.span,\n+                    \"expected ident, positional arguments cannot follow named arguments\",\n+                );\n+                return None;\n             };\n             let name: &str = &ident.as_str();\n \n@@ -286,11 +273,11 @@ impl<'a, 'b> Context<'a, 'b> {\n         } else {\n             MultiSpan::from_span(self.fmtsp)\n         };\n-        let mut refs: Vec<_> = self\n+        let refs_len = self.invalid_refs.len();\n+        let mut refs = self\n             .invalid_refs\n             .iter()\n-            .map(|(r, pos)| (r.to_string(), self.arg_spans.get(*pos)))\n-            .collect();\n+            .map(|(r, pos)| (r.to_string(), self.arg_spans.get(*pos)));\n \n         if self.names.is_empty() && !numbered_position_args {\n             e = self.ecx.mut_span_err(\n@@ -303,28 +290,24 @@ impl<'a, 'b> Context<'a, 'b> {\n                 ),\n             );\n         } else {\n-            let (arg_list, mut sp) = match refs.len() {\n-                1 => {\n-                    let (reg, pos) = refs.pop().unwrap();\n-                    (\n-                        format!(\"argument {}\", reg),\n-                        MultiSpan::from_span(*pos.unwrap_or(&self.fmtsp)),\n-                    )\n-                }\n-                _ => {\n-                    let pos =\n-                        MultiSpan::from_spans(refs.iter().map(|(_, p)| *p.unwrap()).collect());\n-                    let mut refs: Vec<String> = refs.iter().map(|(s, _)| s.to_owned()).collect();\n-                    let reg = refs.pop().unwrap();\n-                    (\n-                        format!(\n-                            \"arguments {head} and {tail}\",\n-                            tail = reg,\n-                            head = refs.join(\", \")\n-                        ),\n-                        pos,\n-                    )\n-                }\n+            let (arg_list, mut sp) = if refs_len == 1 {\n+                let (reg, pos) = refs.next().unwrap();\n+                (\n+                    format!(\"argument {}\", reg),\n+                    MultiSpan::from_span(*pos.unwrap_or(&self.fmtsp)),\n+                )\n+            } else {\n+                let (mut refs, spans): (Vec<_>, Vec<_>) = refs.unzip();\n+                let pos = MultiSpan::from_spans(spans.into_iter().map(|s| *s.unwrap()).collect());\n+                let reg = refs.pop().unwrap();\n+                (\n+                    format!(\n+                        \"arguments {head} and {tail}\",\n+                        head = refs.join(\", \"),\n+                        tail = reg,\n+                    ),\n+                    pos,\n+                )\n             };\n             if !self.is_literal {\n                 sp = MultiSpan::from_span(self.fmtsp);\n@@ -353,33 +336,30 @@ impl<'a, 'b> Context<'a, 'b> {\n                     Placeholder(_) => {\n                         // record every (position, type) combination only once\n                         let ref mut seen_ty = self.arg_unique_types[arg];\n-                        let i = match seen_ty.iter().position(|x| *x == ty) {\n-                            Some(i) => i,\n-                            None => {\n-                                let i = seen_ty.len();\n-                                seen_ty.push(ty);\n-                                i\n-                            }\n-                        };\n+                        let i = seen_ty.iter().position(|x| *x == ty).unwrap_or_else(|| {\n+                            let i = seen_ty.len();\n+                            seen_ty.push(ty);\n+                            i\n+                        });\n                         self.arg_types[arg].push(i);\n                     }\n                     Count => {\n-                        match self.count_positions.entry(arg) {\n-                            Entry::Vacant(e) => {\n-                                let i = self.count_positions_count;\n-                                e.insert(i);\n-                                self.count_args.push(Exact(arg));\n-                                self.count_positions_count += 1;\n-                            }\n-                            Entry::Occupied(_) => {}\n+                        if let Entry::Vacant(e) = self.count_positions.entry(arg) {\n+                            let i = self.count_positions_count;\n+                            e.insert(i);\n+                            self.count_args.push(Exact(arg));\n+                            self.count_positions_count += 1;\n                         }\n                     }\n                 }\n             }\n \n             Named(name) => {\n-                let idx = match self.names.get(&name) {\n-                    Some(e) => *e,\n+                match self.names.get(&name) {\n+                    Some(idx) => {\n+                        // Treat as positional arg.\n+                        self.verify_arg_type(Exact(*idx), ty)\n+                    }\n                     None => {\n                         let msg = format!(\"there is no argument named `{}`\", name);\n                         let sp = if self.is_literal {\n@@ -389,11 +369,8 @@ impl<'a, 'b> Context<'a, 'b> {\n                         };\n                         let mut err = self.ecx.struct_span_err(sp, &msg[..]);\n                         err.emit();\n-                        return;\n                     }\n-                };\n-                // Treat as positional arg.\n-                self.verify_arg_type(Exact(idx), ty)\n+                }\n             }\n         }\n     }\n@@ -436,12 +413,10 @@ impl<'a, 'b> Context<'a, 'b> {\n             parse::CountIs(i) => count(\"Is\", Some(self.ecx.expr_usize(sp, i))),\n             parse::CountIsParam(i) => {\n                 // This needs mapping too, as `i` is referring to a macro\n-                // argument.\n-                let i = match self.count_positions.get(&i) {\n-                    Some(&i) => i,\n-                    None => 0, // error already emitted elsewhere\n-                };\n-                let i = i + self.count_args_index_offset;\n+                // argument. If `i` is not found in `count_positions` then\n+                // the error had already been emitted elsewhere.\n+                let i = self.count_positions.get(&i).cloned().unwrap_or(0)\n+                      + self.count_args_index_offset;\n                 count(\"Param\", Some(self.ecx.expr_usize(sp, i)))\n             }\n             parse::CountImplied => count(\"Implied\", None),\n@@ -526,10 +501,7 @@ impl<'a, 'b> Context<'a, 'b> {\n                     },\n                 };\n \n-                let fill = match arg.format.fill {\n-                    Some(c) => c,\n-                    None => ' ',\n-                };\n+                let fill = arg.format.fill.unwrap_or(' ');\n \n                 if *arg != simple_arg || fill != ' ' {\n                     self.all_pieces_simple = false;\n@@ -828,8 +800,7 @@ pub fn expand_preparsed_format_args(ecx: &mut ExtCtxt,\n     if !parser.errors.is_empty() {\n         let err = parser.errors.remove(0);\n         let sp = fmt.span.from_inner_byte_pos(err.start, err.end);\n-        let mut e = ecx.struct_span_err(sp, &format!(\"invalid format string: {}\",\n-                                                        err.description));\n+        let mut e = ecx.struct_span_err(sp, &format!(\"invalid format string: {}\", err.description));\n         e.span_label(sp, err.label + \" in format string\");\n         if let Some(note) = err.note {\n             e.note(&note);"}]}