{"sha": "c5754f3971b4bb6ea1c9527863189792ab5ee336", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM1NzU0ZjM5NzFiNGJiNmVhMWM5NTI3ODYzMTg5NzkyYWI1ZWUzMzY=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2014-09-12T14:53:35Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2014-09-15T18:58:49Z"}, "message": "Guts of the new trait matching algorithm, not yet in use", "tree": {"sha": "1dba7c041362ebf0e29d0283b24e5454dc22748b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1dba7c041362ebf0e29d0283b24e5454dc22748b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c5754f3971b4bb6ea1c9527863189792ab5ee336", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c5754f3971b4bb6ea1c9527863189792ab5ee336", "html_url": "https://github.com/rust-lang/rust/commit/c5754f3971b4bb6ea1c9527863189792ab5ee336", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c5754f3971b4bb6ea1c9527863189792ab5ee336/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "713cf373c118517ec2638c4af1b73deceae4d4e0", "url": "https://api.github.com/repos/rust-lang/rust/commits/713cf373c118517ec2638c4af1b73deceae4d4e0", "html_url": "https://github.com/rust-lang/rust/commit/713cf373c118517ec2638c4af1b73deceae4d4e0"}], "stats": {"total": 2962, "additions": 2856, "deletions": 106}, "files": [{"sha": "af3d19c4d2d4004b3ccbaac7fdd0c2dc76963644", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c5754f3971b4bb6ea1c9527863189792ab5ee336/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5754f3971b4bb6ea1c9527863189792ab5ee336/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=c5754f3971b4bb6ea1c9527863189792ab5ee336", "patch": "@@ -108,6 +108,7 @@ pub mod middle {\n     pub mod save;\n     pub mod stability;\n     pub mod subst;\n+    pub mod traits;\n     pub mod trans;\n     pub mod ty;\n     pub mod ty_fold;"}, {"sha": "1ea0681085b1a5ef53aa871d88e2fe28580dc665", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/c5754f3971b4bb6ea1c9527863189792ab5ee336/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5754f3971b4bb6ea1c9527863189792ab5ee336/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=c5754f3971b4bb6ea1c9527863189792ab5ee336", "patch": "@@ -85,6 +85,17 @@ impl LanguageItems {\n         }\n     }\n \n+    pub fn from_builtin_kind(&self, bound: ty::BuiltinBound)\n+                             -> Result<ast::DefId, String>\n+    {\n+        match bound {\n+            ty::BoundSend => self.require(SendTraitLangItem),\n+            ty::BoundSized => self.require(SizedTraitLangItem),\n+            ty::BoundCopy => self.require(CopyTraitLangItem),\n+            ty::BoundSync => self.require(SyncTraitLangItem),\n+        }\n+    }\n+\n     pub fn to_builtin_kind(&self, id: ast::DefId) -> Option<ty::BuiltinBound> {\n         if Some(id) == self.send_trait() {\n             Some(ty::BoundSend)"}, {"sha": "23f53d9b4ab80c094aa8408ef4d7d126e9263e88", "filename": "src/librustc/middle/subst.rs", "status": "modified", "additions": 21, "deletions": 7, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/c5754f3971b4bb6ea1c9527863189792ab5ee336/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5754f3971b4bb6ea1c9527863189792ab5ee336/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fsubst.rs?ref=c5754f3971b4bb6ea1c9527863189792ab5ee336", "patch": "@@ -333,6 +333,16 @@ impl<T> VecPerParamSpace<T> {\n         }\n     }\n \n+    fn new_internal(content: Vec<T>, type_limit: uint, self_limit: uint)\n+                    -> VecPerParamSpace<T>\n+    {\n+        VecPerParamSpace {\n+            type_limit: type_limit,\n+            self_limit: self_limit,\n+            content: content,\n+        }\n+    }\n+\n     pub fn sort(t: Vec<T>, space: |&T| -> ParamSpace) -> VecPerParamSpace<T> {\n         let mut result = VecPerParamSpace::empty();\n         for t in t.move_iter() {\n@@ -448,13 +458,17 @@ impl<T> VecPerParamSpace<T> {\n     }\n \n     pub fn map<U>(&self, pred: |&T| -> U) -> VecPerParamSpace<U> {\n-        // FIXME (#15418): this could avoid allocating the intermediate\n-        // Vec's, but note that the values of type_limit and self_limit\n-        // also need to be kept in sync during construction.\n-        VecPerParamSpace::new(\n-            self.get_slice(TypeSpace).iter().map(|p| pred(p)).collect(),\n-            self.get_slice(SelfSpace).iter().map(|p| pred(p)).collect(),\n-            self.get_slice(FnSpace).iter().map(|p| pred(p)).collect())\n+        let result = self.iter().map(pred).collect();\n+        VecPerParamSpace::new_internal(result,\n+                                       self.type_limit,\n+                                       self.self_limit)\n+    }\n+\n+    pub fn map_move<U>(self, pred: |T| -> U) -> VecPerParamSpace<U> {\n+        let (t, s, f) = self.split();\n+        VecPerParamSpace::new(t.move_iter().map(|p| pred(p)).collect(),\n+                              s.move_iter().map(|p| pred(p)).collect(),\n+                              f.move_iter().map(|p| pred(p)).collect())\n     }\n \n     pub fn map_rev<U>(&self, pred: |&T| -> U) -> VecPerParamSpace<U> {"}, {"sha": "98db2263874537262e9b73a9c0de5a6539acee7e", "filename": "src/librustc/middle/traits/doc.rs", "status": "added", "additions": 268, "deletions": 0, "changes": 268, "blob_url": "https://github.com/rust-lang/rust/blob/c5754f3971b4bb6ea1c9527863189792ab5ee336/src%2Flibrustc%2Fmiddle%2Ftraits%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5754f3971b4bb6ea1c9527863189792ab5ee336/src%2Flibrustc%2Fmiddle%2Ftraits%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fdoc.rs?ref=c5754f3971b4bb6ea1c9527863189792ab5ee336", "patch": "@@ -0,0 +1,268 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+/*!\n+\n+# TRAIT RESOLUTION\n+\n+This document describes the general process and points out some non-obvious\n+things.\n+\n+## Major concepts\n+\n+Trait resolution is the process of pairing up an impl with each\n+reference to a trait. So, for example, if there is a generic function like:\n+\n+    fn clone_slice<T:Clone>(x: &[T]) -> Vec<T> { ... }\n+\n+and then a call to that function:\n+\n+    let v: Vec<int> = clone_slice([1, 2, 3].as_slice())\n+\n+it is the job of trait resolution to figure out (in which case)\n+whether there exists an impl of `int : Clone`\n+\n+Note that in some cases, like generic functions, we may not be able to\n+find a specific impl, but we can figure out that the caller must\n+provide an impl. To see what I mean, consider the body of `clone_slice`:\n+\n+    fn clone_slice<T:Clone>(x: &[T]) -> Vec<T> {\n+        let mut v = Vec::new();\n+        for e in x.iter() {\n+            v.push((*e).clone()); // (*)\n+        }\n+    }\n+\n+The line marked `(*)` is only legal if `T` (the type of `*e`)\n+implements the `Clone` trait. Naturally, since we don't know what `T`\n+is, we can't find the specific impl; but based on the bound `T:Clone`,\n+we can say that there exists an impl which the caller must provide.\n+\n+We use the term *obligation* to refer to a trait reference in need of\n+an impl.\n+\n+## Overview\n+\n+Trait resolution consists of three major parts:\n+\n+- SELECTION: Deciding how to resolve a specific obligation. For\n+  example, selection might decide that a specific obligation can be\n+  resolved by employing an impl which matches the self type, or by\n+  using a parameter bound. In the case of an impl, Selecting one\n+  obligation can create *nested obligations* because of where clauses\n+  on the impl itself.\n+\n+- FULFILLMENT: The fulfillment code is what tracks that obligations\n+  are completely fulfilled. Basically it is a worklist of obligations\n+  to be selected: once selection is successful, the obligation is\n+  removed from the worklist and any nested obligations are enqueued.\n+\n+- COHERENCE: The coherence checks are intended to ensure that there\n+  are never overlapping impls, where two impls could be used with\n+  equal precedence.\n+\n+## Selection\n+\n+Selection is the process of deciding whether an obligation can be\n+resolved and, if so, how it is to be resolved (via impl, where clause, etc).\n+The main interface is the `select()` function, which takes an obligation\n+and returns a `SelectionResult`. There are three possible outcomes:\n+\n+- `Ok(Some(selection))` -- yes, the obligation can be resolved, and\n+  `selection` indicates how. If the impl was resolved via an impl,\n+  then `selection` may also indicate nested obligations that are required\n+  by the impl.\n+\n+- `Ok(None)` -- we are not yet sure whether the obligation can be\n+  resolved or not. This happens most commonly when the obligation\n+  contains unbound type variables.\n+\n+- `Err(err)` -- the obligation definitely cannot be resolved due to a\n+  type error, or because there are no impls that could possibly apply,\n+  etc.\n+\n+The basic algorithm for selection is broken into two big phases:\n+candidate assembly and confirmation.\n+\n+### Candidate assembly\n+\n+Searches for impls/where-clauses/etc that might\n+possibly be used to satisfy the obligation. Each of those is called\n+a candidate. To avoid ambiguity, we want to find exactly one\n+candidate that is definitively applicable. In some cases, we may not\n+know whether an impl/where-clause applies or not -- this occurs when\n+the obligation contains unbound inference variables.\n+\n+One important point is that candidate assembly considers *only the\n+input types* of the obligation when deciding whether an impl applies\n+or not. Consider the following example:\n+\n+    trait Convert<T> { // T is output, Self is input\n+        fn convert(&self) -> T;\n+    }\n+\n+    impl Convert<uint> for int { ... }\n+\n+Now assume we have an obligation `int : Convert<char>`. During\n+candidate assembly, the impl above would be considered a definitively\n+applicable candidate, because it has the same self type (`int`). The\n+fact that the output type parameter `T` is `uint` on the impl and\n+`char` in the obligation is not considered.\n+\n+#### Skolemization\n+\n+We (at least currently) wish to guarantee \"crate concatenability\" --\n+which basically means that you could take two crates, concatenate\n+them textually, and the combined crate would continue to compile. The\n+only real way that this relates to trait matching is with\n+inference. We have to be careful not to influence unbound type\n+variables during the selection process, basically.\n+\n+Here is an example:\n+\n+    trait Foo { fn method() { ... }}\n+    impl Foo for int { ... }\n+\n+    fn something() {\n+        let mut x = None; // `x` has type `Option<?>`\n+        loop {\n+            match x {\n+                Some(ref y) => { // `y` has type ?\n+                    y.method();  // (*)\n+                    ...\n+        }}}\n+    }\n+\n+The question is, can we resolve the call to `y.method()`? We don't yet\n+know what type `y` has. However, there is only one impl in scope, and\n+it is for `int`, so perhaps we could deduce that `y` *must* have type\n+`int` (and hence the type of `x` is `Option<int>`)? This is actually\n+sound reasoning: `int` is the only type in scope that could possibly\n+make this program type check. However, this deduction is a bit\n+\"unstable\", though, because if we concatenated with another crate that\n+defined a newtype and implemented `Foo` for this newtype, then the\n+inference would fail, because there would be two potential impls, not\n+one.\n+\n+It is unclear how important this property is. It might be nice to drop it.\n+But for the time being we maintain it.\n+\n+The way we do this is by *skolemizing* the obligation self type during\n+the selection process -- skolemizing means, basically, replacing all\n+unbound type variables with a new \"skolemized\" type. Each skolemized\n+type is basically considered \"as if\" it were some fresh type that is\n+distinct from all other types. The skolemization process also replaces\n+lifetimes with `'static`, see the section on lifetimes below for an\n+explanation.\n+\n+In the example above, this means that when matching `y.method()` we\n+would convert the type of `y` from a type variable `?` to a skolemized\n+type `X`. Then, since `X` cannot unify with `int`, the match would\n+fail.  Special code exists to check that the match failed because a\n+skolemized type could not be unified with another kind of type -- this is\n+not considered a definitive failure, but rather an ambiguous result,\n+since if the type variable were later to be unified with int, then this\n+obligation could be resolved then.\n+\n+*Note:* Currently, method matching does not use the trait resolution\n+code, so if you in fact type in the example above, it may\n+compile. Hopefully this will be fixed in later patches.\n+\n+#### Matching\n+\n+The subroutines that decide whether a particular impl/where-clause/etc\n+applies to a particular obligation. At the moment, this amounts to\n+unifying the self types, but in the future we may also recursively\n+consider some of the nested obligations, in the case of an impl.\n+\n+#### Lifetimes and selection\n+\n+Because of how that lifetime inference works, it is not possible to\n+give back immediate feedback as to whether a unification or subtype\n+relationship between lifetimes holds or not. Therefore, lifetime\n+matching is *not* considered during selection. This is achieved by\n+having the skolemization process just replace *ALL* lifetimes with\n+`'static`. Later, during confirmation, the non-skolemized self-type\n+will be unified with the type from the impl (or whatever). This may\n+yield lifetime constraints that will later be found to be in error (in\n+contrast, the non-lifetime-constraints have already been checked\n+during selection and can never cause an error, though naturally they\n+may lead to other errors downstream).\n+\n+#### Where clauses\n+\n+Besides an impl, the other major way to resolve an obligation is via a\n+where clause. The selection process is always given a *parameter\n+environment* which contains a list of where clauses, which are\n+basically obligations that can assume are satisfiable. We will iterate\n+over that list and check whether our current obligation can be found\n+in that list, and if so it is considered satisfied. More precisely, we\n+want to check whether there is a where-clause obligation that is for\n+the same trait (or some subtrait) and for which the self types match,\n+using the definition of *matching* given above.\n+\n+Consider this simple example:\n+\n+     trait A1 { ... }\n+     trait A2 : A1 { ... }\n+\n+     trait B { ... }\n+\n+     fn foo<X:A2+B> { ... }\n+\n+Clearly we can use methods offered by `A1`, `A2`, or `B` within the\n+body of `foo`. In each case, that will incur an obligation like `X :\n+A1` or `X : A2`. The parameter environment will contain two\n+where-clauses, `X : A2` and `X : B`. For each obligation, then, we\n+search this list of where-clauses.  To resolve an obligation `X:A1`,\n+we would note that `X:A2` implies that `X:A1`.\n+\n+### Confirmation\n+\n+Confirmation unifies the output type parameters of the trait with the\n+values found in the obligation, possibly yielding a type error.  If we\n+return to our example of the `Convert` trait from the previous\n+section, confirmation is where an error would be reported, because the\n+impl specified that `T` would be `uint`, but the obligation reported\n+`char`. Hence the result of selection would be an error.\n+\n+### Selection during translation\n+\n+During type checking, we do not store the results of trait selection.\n+We simply wish to verify that trait selection will succeed. Then\n+later, at trans time, when we have all concrete types available, we\n+can repeat the trait selection.  In this case, we do not consider any\n+where-clauses to be in scope. We know that therefore each resolution\n+will resolve to a particular impl.\n+\n+One interesting twist has to do with nested obligations. In general, in trans,\n+we only need to do a \"shallow\" selection for an obligation. That is, we wish to\n+identify which impl applies, but we do not (yet) need to decide how to select\n+any nested obligations. Nonetheless, we *do* currently do a complete resolution,\n+and that is because it can sometimes inform the results of type inference. That is,\n+we do not have the full substitutions in terms of the type varibales of the impl available\n+to us, so we must run trait selection to figure everything out.\n+\n+Here is an example:\n+\n+    trait Foo { ... }\n+    impl<U,T:Bar<U>> Foo for Vec<T> { ... }\n+\n+    impl Bar<uint> for int { ... }\n+\n+After one shallow round of selection for an obligation like `Vec<int>\n+: Foo`, we would know which impl we want, and we would know that\n+`T=int`, but we do not know the type of `U`.  We must select the\n+nested obligation `int : Bar<U>` to find out that `U=uint`.\n+\n+It would be good to only do *just as much* nested resolution as\n+necessary. Currently, though, we just do a full resolution.\n+\n+*/"}, {"sha": "78d105c251edb09128a7e736e66d1cd2521a4e93", "filename": "src/librustc/middle/traits/fulfill.rs", "status": "added", "additions": 250, "deletions": 0, "changes": 250, "blob_url": "https://github.com/rust-lang/rust/blob/c5754f3971b4bb6ea1c9527863189792ab5ee336/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5754f3971b4bb6ea1c9527863189792ab5ee336/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs?ref=c5754f3971b4bb6ea1c9527863189792ab5ee336", "patch": "@@ -0,0 +1,250 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use middle::ty;\n+use middle::typeck::infer::{InferCtxt, skolemize};\n+use util::nodemap::DefIdMap;\n+use util::ppaux::Repr;\n+\n+use super::Ambiguity;\n+use super::Obligation;\n+use super::FulfillmentError;\n+use super::SelectionError;\n+use super::select::SelectionContext;\n+use super::Unimplemented;\n+\n+/**\n+ * The fulfillment context is used to drive trait resolution.  It\n+ * consists of a list of obligations that must be (eventually)\n+ * satisfied. The job is to track which are satisfied, which yielded\n+ * errors, and which are still pending. At any point, users can call\n+ * `select_where_possible`, and the fulfilment context will try to do\n+ * selection, retaining only those obligations that remain\n+ * ambiguous. This may be helpful in pushing type inference\n+ * along. Once all type inference constraints have been generated, the\n+ * method `select_all_or_error` can be used to report any remaining\n+ * ambiguous cases as errors.\n+ */\n+pub struct FulfillmentContext {\n+    // A list of all obligations that have been registered with this\n+    // fulfillment context.\n+    trait_obligations: Vec<Obligation>,\n+\n+    // For semi-hacky reasons (see FIXME below) we keep the builtin\n+    // trait obligations segregated.\n+    builtin_obligations: Vec<Obligation>,\n+}\n+\n+impl FulfillmentContext {\n+    pub fn new() -> FulfillmentContext {\n+        FulfillmentContext {\n+            trait_obligations: Vec::new(),\n+            builtin_obligations: Vec::new()\n+        }\n+    }\n+\n+    pub fn register_obligation(&mut self,\n+                               tcx: &ty::ctxt,\n+                               obligation: Obligation)\n+    {\n+        debug!(\"register_obligation({})\", obligation.repr(tcx));\n+        match tcx.lang_items.to_builtin_kind(obligation.trait_ref.def_id) {\n+            Some(_) => {\n+                self.builtin_obligations.push(obligation);\n+            }\n+            None => {\n+                self.trait_obligations.push(obligation);\n+            }\n+        }\n+    }\n+\n+    pub fn select_all_or_error(&mut self,\n+                               infcx: &InferCtxt,\n+                               param_env: &ty::ParameterEnvironment,\n+                               unboxed_closures: &DefIdMap<ty::UnboxedClosure>)\n+                               -> Result<(),Vec<FulfillmentError>>\n+    {\n+        try!(self.select_where_possible(infcx, param_env,\n+                                        unboxed_closures));\n+\n+        // Anything left is ambiguous.\n+        let errors: Vec<FulfillmentError> =\n+            self.trait_obligations\n+            .iter()\n+            .map(|o| FulfillmentError::new((*o).clone(), Ambiguity))\n+            .collect();\n+\n+        if errors.is_empty() {\n+            Ok(())\n+        } else {\n+            Err(errors)\n+        }\n+    }\n+\n+    pub fn select_where_possible(&mut self,\n+                                 infcx: &InferCtxt,\n+                                 param_env: &ty::ParameterEnvironment,\n+                                 unboxed_closures: &DefIdMap<ty::UnboxedClosure>)\n+                                 -> Result<(),Vec<FulfillmentError>>\n+    {\n+        let tcx = infcx.tcx;\n+        let selcx = SelectionContext::new(infcx, param_env,\n+                                          unboxed_closures);\n+\n+        debug!(\"select_where_possible({} obligations) start\",\n+               self.trait_obligations.len());\n+\n+        let mut errors = Vec::new();\n+\n+        loop {\n+            let count = self.trait_obligations.len();\n+\n+            debug!(\"select_where_possible({} obligations) iteration\",\n+                   count);\n+\n+            let mut selections = Vec::new();\n+\n+            // First pass: walk each obligation, retaining\n+            // only those that we cannot yet process.\n+            self.trait_obligations.retain(|obligation| {\n+                match selcx.select(obligation) {\n+                    Ok(None) => {\n+                        true\n+                    }\n+                    Ok(Some(s)) => {\n+                        selections.push(s);\n+                        false\n+                    }\n+                    Err(selection_err) => {\n+                        debug!(\"obligation: {} error: {}\",\n+                               obligation.repr(tcx),\n+                               selection_err.repr(tcx));\n+\n+                        errors.push(FulfillmentError::new(\n+                            (*obligation).clone(),\n+                            SelectionError(selection_err)));\n+                        false\n+                    }\n+                }\n+            });\n+\n+            if self.trait_obligations.len() == count {\n+                // Nothing changed.\n+                break;\n+            }\n+\n+            // Now go through all the successful ones,\n+            // registering any nested obligations for the future.\n+            for selection in selections.move_iter() {\n+                selection.map_move_nested(\n+                    |o| self.register_obligation(tcx, o));\n+            }\n+        }\n+\n+        debug!(\"select_where_possible({} obligations, {} errors) done\",\n+               self.trait_obligations.len(),\n+               errors.len());\n+\n+        if errors.len() == 0 {\n+            Ok(())\n+        } else {\n+            Err(errors)\n+        }\n+    }\n+\n+    pub fn check_builtin_bound_obligations(\n+        &self,\n+        infcx: &InferCtxt)\n+        -> Result<(),Vec<FulfillmentError>>\n+    {\n+        let tcx = infcx.tcx;\n+        let mut errors = Vec::new();\n+        debug!(\"check_builtin_bound_obligations\");\n+        for obligation in self.builtin_obligations.iter() {\n+            debug!(\"obligation={}\", obligation.repr(tcx));\n+\n+            let def_id = obligation.trait_ref.def_id;\n+            let bound = match tcx.lang_items.to_builtin_kind(def_id) {\n+                Some(bound) => { bound }\n+                None => { continue; }\n+            };\n+\n+            let unskol_self_ty = obligation.self_ty();\n+\n+            // Skolemize the self-type so that it no longer contains\n+            // inference variables. Note that this also replaces\n+            // regions with 'static. You might think that this is not\n+            // ok, because checking whether something is `Send`\n+            // implies checking whether it is 'static: that's true,\n+            // but in fact the region bound is fed into region\n+            // inference separately and enforced there (and that has\n+            // even already been done before this code executes,\n+            // generally speaking).\n+            let self_ty = skolemize(infcx, unskol_self_ty);\n+\n+            debug!(\"bound={} self_ty={}\", bound, self_ty.repr(tcx));\n+            if ty::type_is_error(self_ty) {\n+                // Indicates an error that was/will-be\n+                // reported elsewhere.\n+                continue;\n+            }\n+\n+            // Determine if builtin bound is met.\n+            let tc = ty::type_contents(tcx, self_ty);\n+            debug!(\"tc={}\", tc);\n+            let met = match bound {\n+                ty::BoundSend   => tc.is_sendable(tcx),\n+                ty::BoundSized  => tc.is_sized(tcx),\n+                ty::BoundCopy   => tc.is_copy(tcx),\n+                ty::BoundSync   => tc.is_sync(tcx),\n+            };\n+\n+            if met {\n+                continue;\n+            }\n+\n+            // FIXME -- This is kind of a hack: it requently happens\n+            // that some earlier error prevents types from being fully\n+            // inferred, and then we get a bunch of uninteresting\n+            // errors saying something like \"<generic #0> doesn't\n+            // implement Sized\".  It may even be true that we could\n+            // just skip over all checks where the self-ty is an\n+            // inference variable, but I was afraid that there might\n+            // be an inference variable created, registered as an\n+            // obligation, and then never forced by writeback, and\n+            // hence by skipping here we'd be ignoring the fact that\n+            // we don't KNOW the type works out. Though even that\n+            // would probably be harmless, given that we're only\n+            // talking about builtin traits, which are known to be\n+            // inhabited. But in any case I just threw in this check\n+            // for has_errors() to be sure that compilation isn't\n+            // happening anyway. In that case, why inundate the user.\n+            if ty::type_needs_infer(self_ty) &&\n+                tcx.sess.has_errors()\n+            {\n+                debug!(\"skipping printout because self_ty={}\",\n+                       self_ty.repr(tcx));\n+                continue;\n+            }\n+\n+            errors.push(\n+                FulfillmentError::new(\n+                    (*obligation).clone(),\n+                    SelectionError(Unimplemented)));\n+        }\n+\n+        if errors.is_empty() {\n+            Ok(())\n+        } else {\n+            Err(errors)\n+        }\n+    }\n+}\n+"}, {"sha": "62b3c982ccd0a4ceed7f5d849e434e7a67e03c6c", "filename": "src/librustc/middle/traits/mod.rs", "status": "added", "additions": 438, "deletions": 0, "changes": 438, "blob_url": "https://github.com/rust-lang/rust/blob/c5754f3971b4bb6ea1c9527863189792ab5ee336/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5754f3971b4bb6ea1c9527863189792ab5ee336/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs?ref=c5754f3971b4bb6ea1c9527863189792ab5ee336", "patch": "@@ -0,0 +1,438 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+/*!\n+ * Trait Resolution. See doc.rs.\n+ */\n+\n+use middle::subst;\n+use middle::ty;\n+use middle::typeck::infer::InferCtxt;\n+use std::rc::Rc;\n+use syntax::ast;\n+use syntax::codemap::{Span, DUMMY_SP};\n+use util::nodemap::DefIdMap;\n+\n+pub use self::fulfill::FulfillmentContext;\n+pub use self::select::SelectionContext;\n+pub use self::util::supertraits;\n+pub use self::util::transitive_bounds;\n+pub use self::util::Supertraits;\n+pub use self::util::search_trait_and_supertraits_from_bound;\n+\n+mod coherence;\n+mod fulfill;\n+mod select;\n+mod util;\n+\n+/**\n+ * An `Obligation` represents some trait reference (e.g. `int:Eq`) for\n+ * which the vtable must be found.  The process of finding a vtable is\n+ * called \"resolving\" the `Obligation`. This process consists of\n+ * either identifying an `impl` (e.g., `impl Eq for int`) that\n+ * provides the required vtable, or else finding a bound that is in\n+ * scope. The eventual result is usually a `Selection` (defined below).\n+ */\n+#[deriving(Clone)]\n+pub struct Obligation {\n+    pub cause: ObligationCause,\n+    pub recursion_depth: uint,\n+    pub trait_ref: Rc<ty::TraitRef>,\n+}\n+\n+/**\n+ * Why did we incur this obligation? Used for error reporting.\n+ */\n+#[deriving(Clone)]\n+pub struct ObligationCause {\n+    pub span: Span,\n+    pub code: ObligationCauseCode\n+}\n+\n+#[deriving(Clone)]\n+pub enum ObligationCauseCode {\n+    /// Not well classified or should be obvious from span.\n+    MiscObligation,\n+\n+    /// In an impl of trait X for type Y, type Y must\n+    /// also implement all supertraits of X.\n+    ItemObligation(ast::DefId),\n+\n+    /// Obligation incurred due to an object cast.\n+    ObjectCastObligation(/* Object type */ ty::t),\n+\n+    /// Various cases where expressions must be sized/copy/etc:\n+    AssignmentLhsSized,        // L = X implies that L is Sized\n+    StructInitializerSized,    // S { ... } must be Sized\n+    VariableType(ast::NodeId), // Type of each variable must be Sized\n+    RepeatVec,                 // [T,..n] --> T must be Copy\n+}\n+\n+pub static DUMMY_CAUSE: ObligationCause =\n+    ObligationCause { span: DUMMY_SP,\n+                      code: MiscObligation };\n+\n+pub type Obligations = subst::VecPerParamSpace<Obligation>;\n+\n+pub type Selection = Vtable<Obligation>;\n+\n+#[deriving(Clone,Show)]\n+pub enum SelectionError {\n+    Unimplemented,\n+    Overflow,\n+    OutputTypeParameterMismatch(Rc<ty::TraitRef>, ty::type_err)\n+}\n+\n+pub struct FulfillmentError {\n+    pub obligation: Obligation,\n+    pub code: FulfillmentErrorCode\n+}\n+\n+#[deriving(Clone)]\n+pub enum FulfillmentErrorCode {\n+    SelectionError(SelectionError),\n+    Ambiguity,\n+}\n+\n+/**\n+ * When performing resolution, it is typically the case that there\n+ * can be one of three outcomes:\n+ *\n+ * - `Ok(Some(r))`: success occurred with result `r`\n+ * - `Ok(None)`: could not definitely determine anything, usually due\n+ *   to inconclusive type inference.\n+ * - `Err(e)`: error `e` occurred\n+ */\n+pub type SelectionResult<T> = Result<Option<T>,SelectionError>;\n+\n+#[deriving(PartialEq,Eq,Show)]\n+pub enum EvaluationResult {\n+    EvaluatedToMatch,\n+    EvaluatedToAmbiguity,\n+    EvaluatedToUnmatch\n+}\n+\n+/**\n+ * Given the successful resolution of an obligation, the `Vtable`\n+ * indicates where the vtable comes from. Note that while we call this\n+ * a \"vtable\", it does not necessarily indicate dynamic dispatch at\n+ * runtime. `Vtable` instances just tell the compiler where to find\n+ * methods, but in generic code those methods are typically statically\n+ * dispatched -- only when an object is constructed is a `Vtable`\n+ * instance reified into an actual vtable.\n+ *\n+ * For example, the vtable may be tied to a specific impl (case A),\n+ * or it may be relative to some bound that is in scope (case B).\n+ *\n+ *\n+ * ```\n+ * impl<T:Clone> Clone<T> for Option<T> { ... } // Impl_1\n+ * impl<T:Clone> Clone<T> for Box<T> { ... }    // Impl_2\n+ * impl Clone for int { ... }             // Impl_3\n+ *\n+ * fn foo<T:Clone>(concrete: Option<Box<int>>,\n+ *                 param: T,\n+ *                 mixed: Option<T>) {\n+ *\n+ *    // Case A: Vtable points at a specific impl. Only possible when\n+ *    // type is concretely known. If the impl itself has bounded\n+ *    // type parameters, Vtable will carry resolutions for those as well:\n+ *    concrete.clone(); // Vtable(Impl_1, [Vtable(Impl_2, [Vtable(Impl_3)])])\n+ *\n+ *    // Case B: Vtable must be provided by caller. This applies when\n+ *    // type is a type parameter.\n+ *    param.clone();    // VtableParam(Oblig_1)\n+ *\n+ *    // Case C: A mix of cases A and B.\n+ *    mixed.clone();    // Vtable(Impl_1, [VtableParam(Oblig_1)])\n+ * }\n+ * ```\n+ *\n+ * ### The type parameter `N`\n+ *\n+ * See explanation on `VtableImpl`.\n+ */\n+#[deriving(Show,Clone)]\n+pub enum Vtable<N> {\n+    /// Vtable identifying a particular impl.\n+    VtableImpl(VtableImpl<N>),\n+\n+    /// Vtable automatically generated for an unboxed closure. The def\n+    /// ID is the ID of the closure expression. This is a `VtableImpl`\n+    /// in spirit, but the impl is generated by the compiler and does\n+    /// not appear in the source.\n+    VtableUnboxedClosure(ast::DefId),\n+\n+    /// Successful resolution to an obligation provided by the caller\n+    /// for some type parameter.\n+    VtableParam(VtableParam),\n+\n+    /// Successful resolution for a builtin trait.\n+    VtableBuiltin,\n+}\n+\n+/**\n+ * Identifies a particular impl in the source, along with a set of\n+ * substitutions from the impl's type/lifetime parameters. The\n+ * `nested` vector corresponds to the nested obligations attached to\n+ * the impl's type parameters.\n+ *\n+ * The type parameter `N` indicates the type used for \"nested\n+ * obligations\" that are required by the impl. During type check, this\n+ * is `Obligation`, as one might expect. During trans, however, this\n+ * is `()`, because trans only requires a shallow resolution of an\n+ * impl, and nested obligations are satisfied later.\n+ */\n+#[deriving(Clone)]\n+pub struct VtableImpl<N> {\n+    pub impl_def_id: ast::DefId,\n+    pub substs: subst::Substs,\n+    pub nested: subst::VecPerParamSpace<N>\n+}\n+\n+/**\n+ * A vtable provided as a parameter by the caller. For example, in a\n+ * function like `fn foo<T:Eq>(...)`, if the `eq()` method is invoked\n+ * on an instance of `T`, the vtable would be of type `VtableParam`.\n+ */\n+#[deriving(Clone)]\n+pub struct VtableParam {\n+    // In the above example, this would `Eq`\n+    pub bound: Rc<ty::TraitRef>,\n+}\n+\n+pub fn try_select_obligation(infcx: &InferCtxt,\n+                             param_env: &ty::ParameterEnvironment,\n+                             unboxed_closures: &DefIdMap<ty::UnboxedClosure>,\n+                             obligation: &Obligation)\n+                             -> SelectionResult<Selection>\n+{\n+    /*!\n+     * Attempts to select the impl/bound/etc for the obligation\n+     * given. Returns `None` if we are unable to resolve, either\n+     * because of ambiguity or due to insufficient inference.  Note\n+     * that selection is a shallow process and hence the result may\n+     * contain nested obligations that must be resolved. The caller is\n+     * responsible for ensuring that those get resolved. (But see\n+     * `try_select_obligation_deep` below.)\n+     */\n+\n+    let selcx = select::SelectionContext::new(infcx, param_env, unboxed_closures);\n+    selcx.select(obligation)\n+}\n+\n+pub fn evaluate_obligation(infcx: &InferCtxt,\n+                           param_env: &ty::ParameterEnvironment,\n+                           obligation: &Obligation,\n+                           unboxed_closures: &DefIdMap<ty::UnboxedClosure>)\n+                           -> EvaluationResult\n+{\n+    /*!\n+     * Attempts to resolve the obligation given. Returns `None` if\n+     * we are unable to resolve, either because of ambiguity or\n+     * due to insufficient inference.\n+     */\n+\n+    let selcx = select::SelectionContext::new(infcx, param_env,\n+                                              unboxed_closures);\n+    selcx.evaluate_obligation(obligation)\n+}\n+\n+pub fn evaluate_impl(infcx: &InferCtxt,\n+                     param_env: &ty::ParameterEnvironment,\n+                     unboxed_closures: &DefIdMap<ty::UnboxedClosure>,\n+                     cause: ObligationCause,\n+                     impl_def_id: ast::DefId,\n+                     self_ty: ty::t)\n+                     -> EvaluationResult\n+{\n+    /*!\n+     * Tests whether the impl `impl_def_id` can be applied to the self\n+     * type `self_ty`. This is similar to \"selection\", but simpler:\n+     *\n+     * - It does not take a full trait-ref as input, so it skips over\n+     *   the \"confirmation\" step which would reconcile output type\n+     *   parameters.\n+     * - It returns an `EvaluationResult`, which is a tri-value return\n+     *   (yes/no/unknown).\n+     */\n+\n+    let selcx = select::SelectionContext::new(infcx, param_env, unboxed_closures);\n+    selcx.evaluate_impl(impl_def_id, cause, self_ty)\n+}\n+\n+pub fn select_inherent_impl(infcx: &InferCtxt,\n+                            param_env: &ty::ParameterEnvironment,\n+                            unboxed_closures: &DefIdMap<ty::UnboxedClosure>,\n+                            cause: ObligationCause,\n+                            impl_def_id: ast::DefId,\n+                            self_ty: ty::t)\n+                            -> SelectionResult<VtableImpl<Obligation>>\n+{\n+    /*!\n+     * Matches the self type of the inherent impl `impl_def_id`\n+     * against `self_ty` and returns the resulting resolution.  This\n+     * routine may modify the surrounding type context (for example,\n+     * it may unify variables).\n+     */\n+\n+    // This routine is only suitable for inherent impls. This is\n+    // because it does not attempt to unify the output type parameters\n+    // from the trait ref against the values from the obligation.\n+    // (These things do not apply to inherent impls, for which there\n+    // is no trait ref nor obligation.)\n+    //\n+    // Matching against non-inherent impls should be done with\n+    // `try_resolve_obligation()`.\n+    assert!(ty::impl_trait_ref(infcx.tcx, impl_def_id).is_none());\n+\n+    let selcx = select::SelectionContext::new(infcx, param_env,\n+                                              unboxed_closures);\n+    selcx.select_inherent_impl(impl_def_id, cause, self_ty)\n+}\n+\n+pub fn is_orphan_impl(tcx: &ty::ctxt,\n+                      impl_def_id: ast::DefId)\n+                      -> bool\n+{\n+    /*!\n+     * True if neither the trait nor self type is local. Note that\n+     * `impl_def_id` must refer to an impl of a trait, not an inherent\n+     * impl.\n+     */\n+\n+    !coherence::impl_is_local(tcx, impl_def_id)\n+}\n+\n+pub fn overlapping_impls(infcx: &InferCtxt,\n+                         impl1_def_id: ast::DefId,\n+                         impl2_def_id: ast::DefId)\n+                         -> bool\n+{\n+    /*!\n+     * True if there exist types that satisfy both of the two given impls.\n+     */\n+\n+    coherence::impl_can_satisfy(infcx, impl1_def_id, impl2_def_id) &&\n+    coherence::impl_can_satisfy(infcx, impl2_def_id, impl1_def_id)\n+}\n+\n+pub fn obligations_for_generics(tcx: &ty::ctxt,\n+                                cause: ObligationCause,\n+                                generics: &ty::Generics,\n+                                substs: &subst::Substs)\n+                                -> subst::VecPerParamSpace<Obligation>\n+{\n+    /*!\n+     * Given generics for an impl like:\n+     *\n+     *    impl<A:Foo, B:Bar+Qux> ...\n+     *\n+     * and a substs vector like `<A=A0, B=B0>`, yields a result like\n+     *\n+     *    [[Foo for A0, Bar for B0, Qux for B0], [], []]\n+     */\n+\n+    util::obligations_for_generics(tcx, cause, 0, generics, substs)\n+}\n+\n+pub fn obligation_for_builtin_bound(tcx: &ty::ctxt,\n+                                    cause: ObligationCause,\n+                                    source_ty: ty::t,\n+                                    builtin_bound: ty::BuiltinBound)\n+                                    -> Obligation\n+{\n+    util::obligation_for_builtin_bound(tcx, cause, builtin_bound, 0, source_ty)\n+}\n+\n+impl Obligation {\n+    pub fn new(cause: ObligationCause, trait_ref: Rc<ty::TraitRef>) -> Obligation {\n+        Obligation { cause: cause,\n+                     recursion_depth: 0,\n+                     trait_ref: trait_ref }\n+    }\n+\n+    pub fn misc(span: Span, trait_ref: Rc<ty::TraitRef>) -> Obligation {\n+        Obligation::new(ObligationCause::misc(span), trait_ref)\n+    }\n+\n+    pub fn self_ty(&self) -> ty::t {\n+        self.trait_ref.self_ty()\n+    }\n+}\n+\n+impl ObligationCause {\n+    pub fn new(span: Span, code: ObligationCauseCode) -> ObligationCause {\n+        ObligationCause { span: span, code: code }\n+    }\n+\n+    pub fn misc(span: Span) -> ObligationCause {\n+        ObligationCause { span: span, code: MiscObligation }\n+    }\n+}\n+\n+impl<N> Vtable<N> {\n+    pub fn map_nested<M>(&self, op: |&N| -> M) -> Vtable<M> {\n+        match *self {\n+            VtableImpl(ref i) => VtableImpl(i.map_nested(op)),\n+            VtableUnboxedClosure(d) => VtableUnboxedClosure(d),\n+            VtableParam(ref p) => VtableParam((*p).clone()),\n+            VtableBuiltin => VtableBuiltin,\n+        }\n+    }\n+\n+    pub fn map_move_nested<M>(self, op: |N| -> M) -> Vtable<M> {\n+        match self {\n+            VtableImpl(i) => VtableImpl(i.map_move_nested(op)),\n+            VtableUnboxedClosure(d) => VtableUnboxedClosure(d),\n+            VtableParam(p) => VtableParam(p),\n+            VtableBuiltin => VtableBuiltin,\n+        }\n+    }\n+}\n+\n+impl<N> VtableImpl<N> {\n+    pub fn map_nested<M>(&self,\n+                         op: |&N| -> M)\n+                         -> VtableImpl<M>\n+    {\n+        VtableImpl {\n+            impl_def_id: self.impl_def_id,\n+            substs: self.substs.clone(),\n+            nested: self.nested.map(op)\n+        }\n+    }\n+\n+    pub fn map_move_nested<M>(self, op: |N| -> M) -> VtableImpl<M> {\n+        let VtableImpl { impl_def_id, substs, nested } = self;\n+        VtableImpl {\n+            impl_def_id: impl_def_id,\n+            substs: substs,\n+            nested: nested.map_move(op)\n+        }\n+    }\n+}\n+\n+impl EvaluationResult {\n+    pub fn potentially_applicable(&self) -> bool {\n+        match *self {\n+            EvaluatedToMatch | EvaluatedToAmbiguity => true,\n+            EvaluatedToUnmatch => false\n+        }\n+    }\n+}\n+\n+impl FulfillmentError {\n+    fn new(obligation: Obligation, code: FulfillmentErrorCode)\n+           -> FulfillmentError\n+    {\n+        FulfillmentError { obligation: obligation, code: code }\n+    }\n+}"}, {"sha": "681e2650f39fa4c31bcb92e41b5633f419a7428c", "filename": "src/librustc/middle/traits/select.rs", "status": "added", "additions": 1024, "deletions": 0, "changes": 1024, "blob_url": "https://github.com/rust-lang/rust/blob/c5754f3971b4bb6ea1c9527863189792ab5ee336/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5754f3971b4bb6ea1c9527863189792ab5ee336/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=c5754f3971b4bb6ea1c9527863189792ab5ee336", "patch": "@@ -0,0 +1,1024 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+/*! See `doc.rs` for high-level documentation */\n+\n+use super::{Obligation, ObligationCause};\n+use super::{EvaluationResult, EvaluatedToMatch,\n+            EvaluatedToAmbiguity, EvaluatedToUnmatch};\n+use super::{SelectionError, Unimplemented, Overflow,\n+            OutputTypeParameterMismatch};\n+use super::{Selection};\n+use super::{SelectionResult};\n+use super::{VtableBuiltin, VtableImpl, VtableParam, VtableUnboxedClosure};\n+use super::{util};\n+\n+use middle::subst::{Subst, Substs, VecPerParamSpace};\n+use middle::ty;\n+use middle::typeck::check::regionmanip;\n+use middle::typeck::infer;\n+use middle::typeck::infer::InferCtxt;\n+use std::rc::Rc;\n+use syntax::ast;\n+use util::nodemap::DefIdMap;\n+use util::ppaux::Repr;\n+\n+pub struct SelectionContext<'cx, 'tcx:'cx> {\n+    infcx: &'cx InferCtxt<'cx, 'tcx>,\n+    param_env: &'cx ty::ParameterEnvironment,\n+    unboxed_closures: &'cx DefIdMap<ty::UnboxedClosure>,\n+}\n+\n+// pub struct SelectionCache {\n+//     hashmap: RefCell<HashMap<CacheKey, Candidate>>,\n+// }\n+\n+// #[deriving(Hash,Eq,PartialEq)]\n+// struct CacheKey {\n+//     trait_def_id: ast::DefId,\n+//     skol_obligation_self_ty: ty::t,\n+// }\n+\n+enum MatchResult<T> {\n+    Matched(T),\n+    AmbiguousMatch,\n+    NoMatch\n+}\n+\n+/**\n+ * The selection process begins by considering all impls, where\n+ * clauses, and so forth that might resolve an obligation.  Sometimes\n+ * we'll be able to say definitively that (e.g.) an impl does not\n+ * apply to the obligation: perhaps it is defined for `uint` but the\n+ * obligation is for `int`. In that case, we drop the impl out of the\n+ * list.  But the other cases are considered *candidates*.\n+ *\n+ * Candidates can either be definitive or ambiguous. An ambiguous\n+ * candidate is one that might match or might not, depending on how\n+ * type variables wind up being resolved. This only occurs during inference.\n+ *\n+ * For selection to suceed, there must be exactly one non-ambiguous\n+ * candidate.  Usually, it is not possible to have more than one\n+ * definitive candidate, due to the coherence rules. However, there is\n+ * one case where it could occur: if there is a blanket impl for a\n+ * trait (that is, an impl applied to all T), and a type parameter\n+ * with a where clause. In that case, we can have a candidate from the\n+ * where clause and a second candidate from the impl. This is not a\n+ * problem because coherence guarantees us that the impl which would\n+ * be used to satisfy the where clause is the same one that we see\n+ * now. To resolve this issue, therefore, we ignore impls if we find a\n+ * matching where clause. Part of the reason for this is that where\n+ * clauses can give additional information (like, the types of output\n+ * parameters) that would have to be inferred from the impl.\n+ */\n+#[deriving(Clone)]\n+enum Candidate {\n+    MatchedBuiltinCandidate,\n+    AmbiguousBuiltinCandidate,\n+    MatchedParamCandidate(VtableParam),\n+    AmbiguousParamCandidate,\n+    Impl(ImplCandidate),\n+    MatchedUnboxedClosureCandidate(/* closure */ ast::DefId)\n+}\n+\n+#[deriving(Clone)]\n+enum ImplCandidate {\n+    MatchedImplCandidate(ast::DefId),\n+    AmbiguousImplCandidate(ast::DefId),\n+}\n+\n+impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n+    pub fn new(infcx: &'cx InferCtxt<'cx, 'tcx>,\n+               param_env: &'cx ty::ParameterEnvironment,\n+               unboxed_closures: &'cx DefIdMap<ty::UnboxedClosure>)\n+               -> SelectionContext<'cx, 'tcx> {\n+        SelectionContext { infcx: infcx, param_env: param_env,\n+                           unboxed_closures: unboxed_closures }\n+    }\n+\n+    pub fn tcx(&self) -> &'cx ty::ctxt<'tcx> {\n+        self.infcx.tcx\n+    }\n+\n+    ///////////////////////////////////////////////////////////////////////////\n+    // Selection\n+    //\n+    // The selection phase tries to identify *how* an obligation will\n+    // be resolved. For example, it will identify which impl or\n+    // parameter bound is to be used. The process can be inconclusive\n+    // if the self type in the obligation is not fully inferred. Selection\n+    // can result in an error in one of two ways:\n+    //\n+    // 1. If no applicable impl or parameter bound can be found.\n+    // 2. If the output type parameters in the obligation do not match\n+    //    those specified by the impl/bound. For example, if the obligation\n+    //    is `Vec<Foo>:Iterable<Bar>`, but the impl specifies\n+    //    `impl<T> Iterable<T> for Vec<T>`, than an error would result.\n+\n+    pub fn select(&self, obligation: &Obligation) -> SelectionResult<Selection> {\n+        /*!\n+         * Evaluates whether the obligation can be satisfied. Returns\n+         * an indication of whether the obligation can be satisfied\n+         * and, if so, by what means. Never affects surrounding typing\n+         * environment.\n+         */\n+\n+        debug!(\"select({})\", obligation.repr(self.tcx()));\n+\n+        match try!(self.candidate_from_obligation(obligation)) {\n+            None => Ok(None),\n+            Some(candidate) => self.confirm_candidate(obligation, candidate),\n+        }\n+    }\n+\n+    pub fn select_inherent_impl(&self,\n+                                impl_def_id: ast::DefId,\n+                                obligation_cause: ObligationCause,\n+                                obligation_self_ty: ty::t)\n+                                -> SelectionResult<VtableImpl<Obligation>>\n+    {\n+        debug!(\"select_inherent_impl(impl_def_id={}, obligation_self_ty={})\",\n+               impl_def_id.repr(self.tcx()),\n+               obligation_self_ty.repr(self.tcx()));\n+\n+        match self.candidate_from_impl(impl_def_id,\n+                                       obligation_cause,\n+                                       obligation_self_ty) {\n+            Some(MatchedImplCandidate(impl_def_id)) => {\n+                let vtable_impl =\n+                    try!(self.confirm_inherent_impl_candidate(\n+                        impl_def_id,\n+                        obligation_cause,\n+                        obligation_self_ty,\n+                        0));\n+                Ok(Some(vtable_impl))\n+            }\n+            Some(AmbiguousImplCandidate(_)) => {\n+                Ok(None)\n+            }\n+            None => {\n+                Err(Unimplemented)\n+            }\n+        }\n+    }\n+\n+    ///////////////////////////////////////////////////////////////////////////\n+    // EVALUATION\n+    //\n+    // Tests whether an obligation can be selected or whether an impl can be\n+    // applied to particular types. It skips the \"confirmation\" step and\n+    // hence completely ignores output type parameters.\n+\n+    pub fn evaluate_obligation(&self,\n+                               obligation: &Obligation)\n+                               -> EvaluationResult\n+    {\n+        /*!\n+         * Evaluates whether the obligation `obligation` can be\n+         * satisfied (by any means).\n+         */\n+\n+        debug!(\"evaluate_obligation({})\",\n+               obligation.repr(self.tcx()));\n+\n+        match self.candidate_from_obligation(obligation) {\n+            Ok(Some(c)) => c.to_evaluation_result(),\n+            Ok(None) => EvaluatedToAmbiguity,\n+            Err(_) => EvaluatedToUnmatch,\n+        }\n+    }\n+\n+    pub fn evaluate_impl(&self,\n+                         impl_def_id: ast::DefId,\n+                         obligation_cause: ObligationCause,\n+                         obligation_self_ty: ty::t)\n+                         -> EvaluationResult\n+    {\n+        /*!\n+         * Evaluates whether the impl with id `impl_def_id` could be\n+         * applied to the self type `obligation_self_ty`. This can be\n+         * used either for trait or inherent impls.\n+         */\n+\n+        debug!(\"evaluate_impl(impl_def_id={}, obligation_self_ty={})\",\n+               impl_def_id.repr(self.tcx()),\n+               obligation_self_ty.repr(self.tcx()));\n+\n+        match self.candidate_from_impl(impl_def_id,\n+                                       obligation_cause,\n+                                       obligation_self_ty) {\n+            Some(c) => c.to_evaluation_result(),\n+            None => EvaluatedToUnmatch,\n+        }\n+    }\n+\n+    ///////////////////////////////////////////////////////////////////////////\n+    // CANDIDATE ASSEMBLY\n+    //\n+    // The selection process begins by examining all in-scope impls,\n+    // caller obligations, and so forth and assembling a list of\n+    // candidates. See `doc.rs` and the `Candidate` type for more details.\n+\n+    fn candidate_from_obligation(&self, obligation: &Obligation)\n+                                 -> SelectionResult<Candidate>\n+    {\n+        debug!(\"candidate_from_obligation({}, self_ty={})\",\n+               obligation.repr(self.tcx()),\n+               self.infcx.ty_to_string(obligation.self_ty()));\n+\n+        let skol_obligation_self_ty =\n+            infer::skolemize(self.infcx, obligation.self_ty());\n+\n+        // First, check the cache.\n+        match self.check_candidate_cache(obligation, skol_obligation_self_ty) {\n+            Some(c) => {\n+                return Ok(Some(c));\n+            }\n+            None => { }\n+        }\n+\n+        let mut candidates =\n+            try!(self.assemble_candidates(obligation,\n+                                          skol_obligation_self_ty));\n+\n+        debug!(\"candidate_from_obligation: {} candidates for {}\",\n+               candidates.len(), obligation.repr(self.tcx()));\n+\n+        // Examine candidates to determine outcome. Ideally we will\n+        // have exactly one candidate that is definitively applicable.\n+\n+        if candidates.len() == 0 {\n+            // Annoying edge case: if there are no impls, then there\n+            // is no way that this trait reference is implemented,\n+            // *unless* it contains unbound variables. In that case,\n+            // it is possible that one of those unbound variables will\n+            // be bound to a new type from some other crate which will\n+            // also contain impls.\n+            let trait_ref = &*obligation.trait_ref;\n+            return if !self.trait_ref_unconstrained(trait_ref) {\n+                debug!(\"candidate_from_obligation({}) -> 0 matches, unimpl\",\n+                       obligation.repr(self.tcx()));\n+                Err(Unimplemented)\n+            } else {\n+                debug!(\"candidate_from_obligation({}) -> 0 matches, ambig\",\n+                       obligation.repr(self.tcx()));\n+                Ok(None)\n+            };\n+        }\n+\n+        if candidates.len() > 1 {\n+            // Ambiguity. Possibly we should report back more\n+            // information on the potential candidates so we can give\n+            // a better error message.\n+            debug!(\"candidate_from_obligation({}) -> multiple matches, ambig\",\n+                   obligation.repr(self.tcx()));\n+\n+            return Ok(None);\n+        }\n+\n+        let candidate = candidates.pop().unwrap();\n+        self.insert_candidate_cache(obligation, skol_obligation_self_ty,\n+                                    candidate.clone());\n+        Ok(Some(candidate))\n+    }\n+\n+    fn check_candidate_cache(&self,\n+                             _obligation: &Obligation,\n+                             _skol_obligation_self_ty: ty::t)\n+                             -> Option<Candidate>\n+    {\n+        // let cache_key = CacheKey::new(obligation.trait_ref.def_id,\n+        //                               skol_obligation_self_ty);\n+        // let hashmap = self.tcx().selection_cache.hashmap.borrow();\n+        // hashmap.find(&cache_key).map(|c| (*c).clone())\n+        None\n+    }\n+\n+    fn insert_candidate_cache(&self,\n+                              _obligation: &Obligation,\n+                              _skol_obligation_self_ty: ty::t,\n+                              _candidate: Candidate)\n+    {\n+        // FIXME -- Enable caching. I think the right place to put the cache\n+        // is in the ParameterEnvironment, not the tcx, because otherwise\n+        // when there are distinct where clauses in scope the cache can get\n+        // confused.\n+        //\n+        //let cache_key = CacheKey::new(obligation.trait_ref.def_id,\n+        //                              skol_obligation_self_ty);\n+        //let mut hashmap = self.tcx().selection_cache.hashmap.borrow_mut();\n+        //hashmap.insert(cache_key, candidate);\n+    }\n+\n+    fn assemble_candidates(&self,\n+                           obligation: &Obligation,\n+                           skol_obligation_self_ty: ty::t)\n+                           -> Result<Vec<Candidate>, SelectionError>\n+    {\n+        // Check for overflow.\n+\n+        let recursion_limit = self.infcx.tcx.sess.recursion_limit.get();\n+        if obligation.recursion_depth >= recursion_limit {\n+            debug!(\"{} --> overflow\", obligation.repr(self.tcx()));\n+            return Err(Overflow);\n+        }\n+\n+        let mut candidates = Vec::new();\n+\n+        match self.tcx().lang_items.to_builtin_kind(obligation.trait_ref.def_id) {\n+            Some(_) => {\n+                // FIXME -- The treatment of builtin bounds is a bit\n+                // hacky right now. Eventually, the idea is to move\n+                // the logic for selection out of type_contents and\n+                // into this module (And make it based on the generic\n+                // mechanisms of OIBTT2).  However, I want to land\n+                // some code today, so we're going to cut a few\n+                // corners. What we do now is that the trait selection\n+                // code always considers builtin obligations to\n+                // match. The fulfillment code (which also has the job\n+                // of tracking all the traits that must hold) will\n+                // then just accumulate the various\n+                // builtin-bound-related obligations that must be met.\n+                // Later, at the end of typeck, after writeback etc,\n+                // we will rewalk this list and extract all the\n+                // builtin-bound-related obligations and test them\n+                // again using type contents. Part of the motivation\n+                // for this is that the type contents code requires\n+                // that writeback has been completed in some cases.\n+\n+                candidates.push(AmbiguousBuiltinCandidate);\n+            }\n+\n+            None => {\n+                // Other bounds. Consider both in-scope bounds from fn decl\n+                // and applicable impls.\n+\n+                try!(self.assemble_candidates_from_caller_bounds(\n+                    obligation,\n+                    skol_obligation_self_ty,\n+                    &mut candidates));\n+\n+                try!(self.assemble_unboxed_candidates(\n+                    obligation,\n+                    skol_obligation_self_ty,\n+                    &mut candidates));\n+\n+                // If there is a fn bound that applies, forego the\n+                // impl search. It can only generate conflicts.\n+\n+                if candidates.len() == 0 {\n+                    try!(self.assemble_candidates_from_impls(\n+                        obligation,\n+                        skol_obligation_self_ty,\n+                        &mut candidates));\n+                }\n+            }\n+        }\n+\n+        Ok(candidates)\n+    }\n+\n+    fn assemble_candidates_from_caller_bounds(&self,\n+                                              obligation: &Obligation,\n+                                              skol_obligation_self_ty: ty::t,\n+                                              candidates: &mut Vec<Candidate>)\n+                                              -> Result<(),SelectionError>\n+    {\n+        /*!\n+         * Given an obligation like `<SomeTrait for T>`, search the obligations\n+         * that the caller supplied to find out whether it is listed among\n+         * them.\n+         *\n+         * Never affects inference environment.\n+v         */\n+\n+        debug!(\"assemble_candidates_from_caller_bounds({})\",\n+               obligation.repr(self.tcx()));\n+\n+        for caller_obligation in self.param_env.caller_obligations.iter() {\n+            debug!(\"caller_obligation={}\",\n+                   caller_obligation.repr(self.tcx()));\n+\n+            // Skip over obligations that don't apply to\n+            // `self_ty`.\n+            let caller_bound = &caller_obligation.trait_ref;\n+            let caller_self_ty = caller_bound.substs.self_ty().unwrap();\n+            match self.match_self_types(obligation.cause,\n+                                        caller_self_ty,\n+                                        skol_obligation_self_ty) {\n+                AmbiguousMatch => {\n+                    debug!(\"-> AmbiguousParamCandidate\");\n+                    candidates.push(AmbiguousParamCandidate);\n+                    return Ok(());\n+                }\n+                NoMatch => {\n+                    continue;\n+                }\n+                Matched(()) => { }\n+            }\n+\n+            // Search through the trait (and its supertraits) to\n+            // see if it matches the def-id we are looking for.\n+            let caller_bound = (*caller_bound).clone();\n+            match util::search_trait_and_supertraits_from_bound(\n+                self.infcx.tcx, caller_bound,\n+                |d| d == obligation.trait_ref.def_id)\n+            {\n+                Some(vtable_param) => {\n+                    // If so, we're done!\n+                    debug!(\"-> MatchedParamCandidate({})\", vtable_param);\n+                    candidates.push(MatchedParamCandidate(vtable_param));\n+                    return Ok(());\n+                }\n+\n+                None => {\n+                }\n+            }\n+        }\n+\n+        Ok(())\n+    }\n+\n+    fn assemble_unboxed_candidates(&self,\n+                                   obligation: &Obligation,\n+                                   skol_obligation_self_ty: ty::t,\n+                                   candidates: &mut Vec<Candidate>)\n+                                   -> Result<(),SelectionError>\n+    {\n+        /*!\n+         * Check for the artificial impl that the compiler will create\n+         * for an obligation like `X : FnMut<..>` where `X` is an\n+         * unboxed closure type.\n+         */\n+\n+        let closure_def_id = match ty::get(skol_obligation_self_ty).sty {\n+            ty::ty_unboxed_closure(id, _) => id,\n+            _ => { return Ok(()); }\n+        };\n+\n+        let tcx = self.tcx();\n+        let fn_traits = [\n+            (ty::FnUnboxedClosureKind, tcx.lang_items.fn_trait()),\n+            (ty::FnMutUnboxedClosureKind, tcx.lang_items.fn_mut_trait()),\n+            (ty::FnOnceUnboxedClosureKind, tcx.lang_items.fn_once_trait()),\n+            ];\n+        for tuple in fn_traits.iter() {\n+            let kind = match tuple {\n+                &(kind, Some(ref fn_trait))\n+                    if *fn_trait == obligation.trait_ref.def_id =>\n+                {\n+                    kind\n+                }\n+                _ => continue,\n+            };\n+\n+            // Check to see whether the argument and return types match.\n+            let closure_kind = match self.unboxed_closures.find(&closure_def_id) {\n+                Some(closure) => closure.kind,\n+                None => {\n+                    self.tcx().sess.span_bug(\n+                        obligation.cause.span,\n+                        format!(\"No entry for unboxed closure: {}\",\n+                                closure_def_id.repr(self.tcx())).as_slice());\n+                }\n+            };\n+\n+            if closure_kind != kind {\n+                continue;\n+            }\n+\n+            candidates.push(MatchedUnboxedClosureCandidate(closure_def_id));\n+        }\n+\n+        Ok(())\n+    }\n+\n+    fn assemble_candidates_from_impls(&self,\n+                                      obligation: &Obligation,\n+                                      skol_obligation_self_ty: ty::t,\n+                                      candidates: &mut Vec<Candidate>)\n+                                      -> Result<(), SelectionError>\n+    {\n+        /*!\n+         * Search for impls that might apply to `obligation`.\n+         */\n+\n+        let all_impls = self.all_impls(obligation.trait_ref.def_id);\n+        for &impl_def_id in all_impls.iter() {\n+            self.infcx.probe(|| {\n+                match self.candidate_from_impl(impl_def_id,\n+                                               obligation.cause,\n+                                               skol_obligation_self_ty) {\n+                    Some(c) => {\n+                        candidates.push(Impl(c));\n+                    }\n+\n+                    None => { }\n+                }\n+            });\n+        }\n+        Ok(())\n+    }\n+\n+    fn candidate_from_impl(&self,\n+                           impl_def_id: ast::DefId,\n+                           obligation_cause: ObligationCause,\n+                           skol_obligation_self_ty: ty::t)\n+                           -> Option<ImplCandidate>\n+    {\n+        match self.match_impl_self_types(impl_def_id,\n+                                         obligation_cause,\n+                                         skol_obligation_self_ty) {\n+            Matched(_) => {\n+                Some(MatchedImplCandidate(impl_def_id))\n+            }\n+\n+            AmbiguousMatch => {\n+                Some(AmbiguousImplCandidate(impl_def_id))\n+            }\n+\n+            NoMatch => {\n+                None\n+            }\n+        }\n+    }\n+\n+    ///////////////////////////////////////////////////////////////////////////\n+    // CONFIRMATION\n+    //\n+    // Confirmation unifies the output type parameters of the trait\n+    // with the values found in the obligation, possibly yielding a\n+    // type error.  See `doc.rs` for more details.\n+\n+    fn confirm_candidate(&self,\n+                         obligation: &Obligation,\n+                         candidate: Candidate)\n+                         -> SelectionResult<Selection>\n+    {\n+        debug!(\"confirm_candidate({}, {})\",\n+               obligation.repr(self.tcx()),\n+               candidate.repr(self.tcx()));\n+\n+        match candidate {\n+            AmbiguousBuiltinCandidate |\n+            AmbiguousParamCandidate |\n+            Impl(AmbiguousImplCandidate(_)) => {\n+                Ok(None)\n+            }\n+\n+            MatchedBuiltinCandidate => {\n+                Ok(Some(VtableBuiltin))\n+            }\n+\n+            MatchedParamCandidate(param) => {\n+                Ok(Some(VtableParam(\n+                    try!(self.confirm_param_candidate(obligation, param)))))\n+            }\n+\n+            Impl(MatchedImplCandidate(impl_def_id)) => {\n+                let vtable_impl = try!(self.confirm_impl_candidate(obligation,\n+                                                                   impl_def_id));\n+                Ok(Some(VtableImpl(vtable_impl)))\n+            }\n+\n+            MatchedUnboxedClosureCandidate(closure_def_id) => {\n+                try!(self.confirm_unboxed_closure_candidate(obligation, closure_def_id));\n+                Ok(Some(VtableUnboxedClosure(closure_def_id)))\n+            }\n+        }\n+    }\n+\n+    fn confirm_param_candidate(&self,\n+                               obligation: &Obligation,\n+                               param: VtableParam)\n+                               -> Result<VtableParam,SelectionError>\n+    {\n+        debug!(\"confirm_param_candidate({},{})\",\n+               obligation.repr(self.tcx()),\n+               param.repr(self.tcx()));\n+\n+        let () = try!(self.confirm(obligation.cause,\n+                                   obligation.trait_ref.clone(),\n+                                   param.bound.clone()));\n+        Ok(param)\n+    }\n+\n+    fn confirm_impl_candidate(&self,\n+                              obligation: &Obligation,\n+                              impl_def_id: ast::DefId)\n+                              -> Result<VtableImpl<Obligation>,SelectionError>\n+    {\n+        debug!(\"confirm_impl_candidate({},{})\",\n+               obligation.repr(self.tcx()),\n+               impl_def_id.repr(self.tcx()));\n+\n+        // For a non-inhernet impl, we begin the same way as an\n+        // inherent impl, by matching the self-type and assembling\n+        // list of nested obligations.\n+        let vtable_impl =\n+            try!(self.confirm_inherent_impl_candidate(\n+                impl_def_id,\n+                obligation.cause,\n+                obligation.trait_ref.self_ty(),\n+                obligation.recursion_depth));\n+\n+        // But then we must also match the output types.\n+        let () = try!(self.confirm_impl_vtable(impl_def_id,\n+                                               obligation.cause,\n+                                               obligation.trait_ref.clone(),\n+                                               &vtable_impl.substs));\n+        Ok(vtable_impl)\n+    }\n+\n+    fn confirm_inherent_impl_candidate(&self,\n+                                       impl_def_id: ast::DefId,\n+                                       obligation_cause: ObligationCause,\n+                                       obligation_self_ty: ty::t,\n+                                       obligation_recursion_depth: uint)\n+                                       -> Result<VtableImpl<Obligation>,\n+                                                 SelectionError>\n+    {\n+        let substs = match self.match_impl_self_types(impl_def_id,\n+                                                      obligation_cause,\n+                                                      obligation_self_ty) {\n+            Matched(substs) => substs,\n+            AmbiguousMatch | NoMatch => {\n+                self.tcx().sess.bug(\n+                    format!(\"Impl {} was matchable against {} but now is not\",\n+                            impl_def_id.repr(self.tcx()),\n+                            obligation_self_ty.repr(self.tcx()))\n+                        .as_slice());\n+            }\n+        };\n+\n+        let impl_obligations =\n+            self.impl_obligations(obligation_cause,\n+                                  obligation_recursion_depth,\n+                                  impl_def_id,\n+                                  &substs);\n+        let vtable_impl = VtableImpl { impl_def_id: impl_def_id,\n+                                       substs: substs,\n+                                       nested: impl_obligations };\n+\n+        Ok(vtable_impl)\n+    }\n+\n+    fn confirm_unboxed_closure_candidate(&self,\n+                                         obligation: &Obligation,\n+                                         closure_def_id: ast::DefId)\n+                                         -> Result<(),SelectionError>\n+    {\n+        debug!(\"confirm_unboxed_closure_candidate({},{})\",\n+               obligation.repr(self.tcx()),\n+               closure_def_id.repr(self.tcx()));\n+\n+        let closure_type = match self.unboxed_closures.find(&closure_def_id) {\n+            Some(closure) => closure.closure_type.clone(),\n+            None => {\n+                self.tcx().sess.span_bug(\n+                    obligation.cause.span,\n+                    format!(\"No entry for unboxed closure: {}\",\n+                            closure_def_id.repr(self.tcx())).as_slice());\n+            }\n+        };\n+\n+        // FIXME(pcwalton): This is a bogus thing to do, but\n+        // it'll do for now until we get the new trait-bound\n+        // region skolemization working.\n+        let (_, new_signature) =\n+            regionmanip::replace_late_bound_regions_in_fn_sig(\n+                self.tcx(),\n+                &closure_type.sig,\n+                |br| self.infcx.next_region_var(\n+                         infer::LateBoundRegion(obligation.cause.span, br)));\n+\n+        let arguments_tuple = *new_signature.inputs.get(0);\n+        let trait_ref = Rc::new(ty::TraitRef {\n+            def_id: obligation.trait_ref.def_id,\n+            substs: Substs::new_trait(\n+                vec![arguments_tuple, new_signature.output],\n+                vec![],\n+                obligation.self_ty())\n+        });\n+\n+        self.confirm(obligation.cause,\n+                     obligation.trait_ref.clone(),\n+                     trait_ref)\n+    }\n+\n+    ///////////////////////////////////////////////////////////////////////////\n+    // Matching\n+    //\n+    // Matching is a common path used for both evaluation and\n+    // confirmation.  It basically unifies types that appear in impls\n+    // and traits. This does affect the surrounding environment;\n+    // therefore, when used during evaluation, match routines must be\n+    // run inside of a `probe()` so that their side-effects are\n+    // contained.\n+\n+    fn match_impl_self_types(&self,\n+                             impl_def_id: ast::DefId,\n+                             obligation_cause: ObligationCause,\n+                             obligation_self_ty: ty::t)\n+                             -> MatchResult<Substs>\n+    {\n+        /*!\n+         * Determines whether the self type declared against\n+         * `impl_def_id` matches `obligation_self_ty`. If successful,\n+         * returns the substitutions used to make them match. See\n+         * `match_impl()`.  For example, if `impl_def_id` is declared\n+         * as:\n+         *\n+         *    impl<T:Copy> Foo for ~T { ... }\n+         *\n+         * and `obligation_self_ty` is `int`, we'd back an `Err(_)`\n+         * result. But if `obligation_self_ty` were `~int`, we'd get\n+         * back `Ok(T=int)`.\n+         */\n+\n+        // Create fresh type variables for each type parameter declared\n+        // on the impl etc.\n+        let impl_substs = util::fresh_substs_for_impl(self.infcx,\n+                                                      obligation_cause.span,\n+                                                      impl_def_id);\n+\n+        // Find the self type for the impl.\n+        let impl_self_ty = ty::lookup_item_type(self.tcx(), impl_def_id).ty;\n+        let impl_self_ty = impl_self_ty.subst(self.tcx(), &impl_substs);\n+\n+        debug!(\"match_impl_self_types(obligation_self_ty={}, impl_self_ty={})\",\n+               obligation_self_ty.repr(self.tcx()),\n+               impl_self_ty.repr(self.tcx()));\n+\n+        match self.match_self_types(obligation_cause,\n+                                    impl_self_ty,\n+                                    obligation_self_ty) {\n+            Matched(()) => {\n+                debug!(\"Matched impl_substs={}\", impl_substs.repr(self.tcx()));\n+                Matched(impl_substs)\n+            }\n+            AmbiguousMatch => {\n+                debug!(\"AmbiguousMatch\");\n+                AmbiguousMatch\n+            }\n+            NoMatch => {\n+                debug!(\"NoMatch\");\n+                NoMatch\n+            }\n+        }\n+    }\n+\n+    fn match_self_types(&self,\n+                        cause: ObligationCause,\n+\n+                        // The self type provided by the impl/caller-obligation:\n+                        provided_self_ty: ty::t,\n+\n+                        // The self type the obligation is for:\n+                        required_self_ty: ty::t)\n+                        -> MatchResult<()>\n+    {\n+        // FIXME(#5781) -- equating the types is stronger than\n+        // necessary. Should consider variance of trait w/r/t Self.\n+\n+        let origin = infer::RelateSelfType(cause.span);\n+        match self.infcx.eq_types(false,\n+                                  origin,\n+                                  provided_self_ty,\n+                                  required_self_ty) {\n+            Ok(()) => Matched(()),\n+            Err(ty::terr_sorts(ty::expected_found{expected: t1, found: t2})) => {\n+                // This error occurs when there is an unresolved type\n+                // variable in the `required_self_ty` that was forced\n+                // to unify with a non-type-variable. That basically\n+                // means we don't know enough to say with certainty\n+                // whether there is a match or not -- it depends on\n+                // how that type variable is ultimately resolved.\n+                if ty::type_is_skolemized(t1) || ty::type_is_skolemized(t2) {\n+                    AmbiguousMatch\n+                } else {\n+                    NoMatch\n+                }\n+            }\n+            Err(_) => NoMatch,\n+        }\n+    }\n+\n+    ///////////////////////////////////////////////////////////////////////////\n+    // Confirmation\n+    //\n+    // The final step of selection: once we know how an obligation is\n+    // is resolved, we confirm that selection in order to have\n+    // side-effects on the typing environment. This step also unifies\n+    // the output type parameters from the obligation with those found\n+    // on the impl/bound, which may yield type errors.\n+\n+    fn confirm_impl_vtable(&self,\n+                           impl_def_id: ast::DefId,\n+                           obligation_cause: ObligationCause,\n+                           obligation_trait_ref: Rc<ty::TraitRef>,\n+                           substs: &Substs)\n+                           -> Result<(), SelectionError>\n+    {\n+        /*!\n+         * Relates the output type parameters from an impl to the\n+         * trait.  This may lead to type errors. The confirmation step\n+         * is separated from the main match procedure because these\n+         * type errors do not cause us to select another impl.\n+         *\n+         * As an example, consider matching the obligation\n+         * `Iterator<char> for Elems<int>` using the following impl:\n+         *\n+         *    impl<T> Iterator<T> for Elems<T> { ... }\n+         *\n+         * The match phase will succeed with substitution `T=int`.\n+         * The confirm step will then try to unify `int` and `char`\n+         * and yield an error.\n+         */\n+\n+        let impl_trait_ref = ty::impl_trait_ref(self.tcx(),\n+                                                impl_def_id).unwrap();\n+        let impl_trait_ref = impl_trait_ref.subst(self.tcx(),\n+                                                  substs);\n+        self.confirm(obligation_cause, obligation_trait_ref, impl_trait_ref)\n+    }\n+\n+    fn confirm(&self,\n+               obligation_cause: ObligationCause,\n+               obligation_trait_ref: Rc<ty::TraitRef>,\n+               expected_trait_ref: Rc<ty::TraitRef>)\n+               -> Result<(), SelectionError>\n+    {\n+        /*!\n+         * After we have determined which impl applies, and with what\n+         * substitutions, there is one last step. We have to go back\n+         * and relate the \"output\" type parameters from the obligation\n+         * to the types that are specified in the impl.\n+         *\n+         * For example, imagine we have:\n+         *\n+         *     impl<T> Iterator<T> for Vec<T> { ... }\n+         *\n+         * and our obligation is `Iterator<Foo> for Vec<int>` (note\n+         * the mismatch in the obligation types). Up until this step,\n+         * no error would be reported: the self type is `Vec<int>`,\n+         * and that matches `Vec<T>` with the substitution `T=int`.\n+         * At this stage, we could then go and check that the type\n+         * parameters to the `Iterator` trait match.\n+         * (In terms of the parameters, the `expected_trait_ref`\n+         * here would be `Iterator<int> for Vec<int>`, and the\n+         * `obligation_trait_ref` would be `Iterator<Foo> for Vec<int>`.\n+         *\n+         * Note that this checking occurs *after* the impl has\n+         * selected, because these output type parameters should not\n+         * affect the selection of the impl. Therefore, if there is a\n+         * mismatch, we report an error to the user.\n+         */\n+\n+        let origin = infer::RelateOutputImplTypes(obligation_cause.span);\n+\n+        let obligation_trait_ref = obligation_trait_ref.clone();\n+        match self.infcx.sub_trait_refs(false,\n+                                        origin,\n+                                        expected_trait_ref.clone(),\n+                                        obligation_trait_ref) {\n+            Ok(()) => Ok(()),\n+            Err(e) => Err(OutputTypeParameterMismatch(expected_trait_ref, e))\n+        }\n+    }\n+\n+    ///////////////////////////////////////////////////////////////////////////\n+    // Miscellany\n+\n+    fn all_impls(&self, trait_def_id: ast::DefId) -> Vec<ast::DefId> {\n+        /*!\n+         * Returns se tof all impls for a given trait.\n+         */\n+\n+        ty::populate_implementations_for_trait_if_necessary(self.tcx(),\n+                                                            trait_def_id);\n+        match self.tcx().trait_impls.borrow().find(&trait_def_id) {\n+            None => Vec::new(),\n+            Some(impls) => impls.borrow().clone()\n+        }\n+    }\n+\n+    fn impl_obligations(&self,\n+                        cause: ObligationCause,\n+                        recursion_depth: uint,\n+                        impl_def_id: ast::DefId,\n+                        impl_substs: &Substs)\n+                        -> VecPerParamSpace<Obligation>\n+    {\n+        let impl_generics = ty::lookup_item_type(self.tcx(),\n+                                                 impl_def_id).generics;\n+        util::obligations_for_generics(self.tcx(), cause, recursion_depth,\n+                                       &impl_generics, impl_substs)\n+    }\n+\n+    fn trait_ref_unconstrained(&self,\n+                               trait_ref: &ty::TraitRef)\n+                               -> bool\n+    {\n+        /*!\n+         * True if the self type of the trait-ref contains\n+         * unconstrained type variables.\n+         */\n+\n+        let mut found_skol = false;\n+\n+        // Skolemization replaces all unconstrained type vars with\n+        // a SkolemizedTy instance. Then we search to see if we\n+        // found any.\n+        let skol_ty = infer::skolemize(self.infcx, trait_ref.self_ty());\n+        ty::walk_ty(skol_ty, |t| {\n+            match ty::get(t).sty {\n+                ty::ty_infer(ty::SkolemizedTy(_)) => { found_skol = true; }\n+                _ => { }\n+            }\n+        });\n+\n+        found_skol\n+    }\n+}\n+\n+impl Candidate {\n+    fn to_evaluation_result(&self) -> EvaluationResult {\n+        match *self {\n+            Impl(ref i) => i.to_evaluation_result(),\n+\n+            MatchedUnboxedClosureCandidate(..) |\n+            MatchedBuiltinCandidate |\n+            MatchedParamCandidate(..) => {\n+                EvaluatedToMatch\n+            }\n+\n+            AmbiguousBuiltinCandidate |\n+            AmbiguousParamCandidate => {\n+                EvaluatedToAmbiguity\n+            }\n+        }\n+    }\n+}\n+\n+impl ImplCandidate {\n+    fn to_evaluation_result(&self) -> EvaluationResult {\n+        match *self {\n+            MatchedImplCandidate(..) => EvaluatedToMatch,\n+            AmbiguousImplCandidate(..) => EvaluatedToAmbiguity\n+        }\n+    }\n+}\n+\n+impl Repr for Candidate {\n+    fn repr(&self, tcx: &ty::ctxt) -> String {\n+        match *self {\n+            MatchedBuiltinCandidate => format!(\"MatchedBuiltinCandidate\"),\n+            AmbiguousBuiltinCandidate => format!(\"AmbiguousBuiltinCandidate\"),\n+            MatchedUnboxedClosureCandidate(c) => format!(\"MatchedUnboxedClosureCandidate({})\", c),\n+            MatchedParamCandidate(ref r) => format!(\"MatchedParamCandidate({})\",\n+                                                    r.repr(tcx)),\n+            AmbiguousParamCandidate => format!(\"AmbiguousParamCandidate\"),\n+            Impl(ref i) => i.repr(tcx)\n+        }\n+    }\n+}\n+\n+impl Repr for ImplCandidate {\n+    fn repr(&self, tcx: &ty::ctxt) -> String {\n+        match *self {\n+            MatchedImplCandidate(ref d) => format!(\"MatchedImplCandidate({})\",\n+                                                   d.repr(tcx)),\n+            AmbiguousImplCandidate(ref d) => format!(\"AmbiguousImplCandidate({})\",\n+                                                     d.repr(tcx)),\n+        }\n+    }\n+}\n+\n+\n+// impl SelectionCache {\n+//     pub fn new() -> SelectionCache {\n+//         SelectionCache {\n+//             hashmap: RefCell::new(HashMap::new())\n+//         }\n+//     }\n+// }\n+\n+// impl CacheKey {\n+//     pub fn new(trait_def_id: ast::DefId,\n+//                skol_obligation_self_ty: ty::t)\n+//                -> CacheKey\n+//     {\n+//         CacheKey {\n+//             trait_def_id: trait_def_id,\n+//             skol_obligation_self_ty: skol_obligation_self_ty\n+//         }\n+//     }\n+// }"}, {"sha": "11b954f2ba6af68198b61b575f6b64290c261e6d", "filename": "src/librustc/middle/traits/util.rs", "status": "added", "additions": 356, "deletions": 0, "changes": 356, "blob_url": "https://github.com/rust-lang/rust/blob/c5754f3971b4bb6ea1c9527863189792ab5ee336/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5754f3971b4bb6ea1c9527863189792ab5ee336/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs?ref=c5754f3971b4bb6ea1c9527863189792ab5ee336", "patch": "@@ -0,0 +1,356 @@\n+\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use middle::subst;\n+use middle::subst::{ParamSpace, Subst, Substs, VecPerParamSpace};\n+use middle::typeck::infer::InferCtxt;\n+use middle::ty;\n+use std::fmt;\n+use std::rc::Rc;\n+use syntax::ast;\n+use syntax::codemap::Span;\n+use util::ppaux::Repr;\n+\n+use super::{Obligation, ObligationCause, VtableImpl, VtableParam};\n+\n+///////////////////////////////////////////////////////////////////////////\n+// Supertrait iterator\n+\n+pub struct Supertraits<'cx, 'tcx:'cx> {\n+    tcx: &'cx ty::ctxt<'tcx>,\n+    stack: Vec<SupertraitEntry>,\n+}\n+\n+struct SupertraitEntry {\n+    position: uint,\n+    supertraits: Vec<Rc<ty::TraitRef>>,\n+}\n+\n+pub fn supertraits<'cx, 'tcx>(tcx: &'cx ty::ctxt<'tcx>,\n+                              trait_ref: Rc<ty::TraitRef>)\n+                              -> Supertraits<'cx, 'tcx>\n+{\n+    /*!\n+     * Returns an iterator over the trait reference `T` and all of its\n+     * supertrait references. May contain duplicates. In general\n+     * the ordering is not defined.\n+     *\n+     * Example:\n+     *\n+     * ```\n+     * trait Foo { ... }\n+     * trait Bar : Foo { ... }\n+     * trait Baz : Bar+Foo { ... }\n+     * ```\n+     *\n+     * `supertraits(Baz)` yields `[Baz, Bar, Foo, Foo]` in some order.\n+     */\n+\n+    transitive_bounds(tcx, [trait_ref])\n+}\n+\n+pub fn transitive_bounds<'cx, 'tcx>(tcx: &'cx ty::ctxt<'tcx>,\n+                                    bounds: &[Rc<ty::TraitRef>])\n+                                    -> Supertraits<'cx, 'tcx>\n+{\n+    let bounds = Vec::from_fn(bounds.len(), |i| bounds[i].clone());\n+    let entry = SupertraitEntry { position: 0, supertraits: bounds };\n+    Supertraits { tcx: tcx, stack: vec![entry] }\n+}\n+\n+impl<'cx, 'tcx> Supertraits<'cx, 'tcx> {\n+    fn push(&mut self, trait_ref: &ty::TraitRef) {\n+        let bounds = ty::bounds_for_trait_ref(self.tcx, trait_ref);\n+        let entry = SupertraitEntry { position: 0,\n+                                      supertraits: bounds.trait_bounds };\n+        self.stack.push(entry);\n+    }\n+\n+    pub fn indices(&self) -> Vec<uint> {\n+        /*!\n+         * Returns the path taken through the trait supertraits to\n+         * reach the current point.\n+         */\n+\n+        self.stack.iter().map(|e| e.position).collect()\n+    }\n+}\n+\n+impl<'cx, 'tcx> Iterator<Rc<ty::TraitRef>> for Supertraits<'cx, 'tcx> {\n+    fn next(&mut self) -> Option<Rc<ty::TraitRef>> {\n+        loop {\n+            // Extract next item from top-most stack frame, if any.\n+            let next_trait = match self.stack.mut_last() {\n+                None => {\n+                    // No more stack frames. Done.\n+                    return None;\n+                }\n+                Some(entry) => {\n+                    let p = entry.position;\n+                    if p < entry.supertraits.len() {\n+                        // Still more supertraits left in the top stack frame.\n+                        entry.position += 1;\n+\n+                        let next_trait =\n+                            (*entry.supertraits.get(p)).clone();\n+                        Some(next_trait)\n+                    } else {\n+                        None\n+                    }\n+                }\n+            };\n+\n+            match next_trait {\n+                Some(next_trait) => {\n+                    self.push(&*next_trait);\n+                    return Some(next_trait);\n+                }\n+\n+                None => {\n+                    // Top stack frame is exhausted, pop it.\n+                    self.stack.pop();\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+// determine the `self` type, using fresh variables for all variables\n+// declared on the impl declaration e.g., `impl<A,B> for ~[(A,B)]`\n+// would return ($0, $1) where $0 and $1 are freshly instantiated type\n+// variables.\n+pub fn fresh_substs_for_impl(infcx: &InferCtxt,\n+                             span: Span,\n+                             impl_def_id: ast::DefId)\n+                             -> Substs\n+{\n+    let tcx = infcx.tcx;\n+    let impl_generics = ty::lookup_item_type(tcx, impl_def_id).generics;\n+    infcx.fresh_substs_for_generics(span, &impl_generics)\n+}\n+\n+impl<N> fmt::Show for VtableImpl<N> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"VtableImpl({})\", self.impl_def_id)\n+    }\n+}\n+\n+impl fmt::Show for VtableParam {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"VtableParam(...)\")\n+    }\n+}\n+\n+pub fn obligations_for_generics(tcx: &ty::ctxt,\n+                                cause: ObligationCause,\n+                                recursion_depth: uint,\n+                                generics: &ty::Generics,\n+                                substs: &Substs)\n+                                -> VecPerParamSpace<Obligation>\n+{\n+    /*! See `super::obligations_for_generics` */\n+\n+    debug!(\"obligations_for_generics(generics={}, substs={})\",\n+           generics.repr(tcx), substs.repr(tcx));\n+\n+    let mut obligations = VecPerParamSpace::empty();\n+\n+    for def in generics.types.iter() {\n+        push_obligations_for_param_bounds(tcx,\n+                                          cause,\n+                                          recursion_depth,\n+                                          def.space,\n+                                          def.index,\n+                                          &def.bounds,\n+                                          substs,\n+                                          &mut obligations);\n+    }\n+\n+    debug!(\"obligations() ==> {}\", obligations.repr(tcx));\n+\n+    return obligations;\n+}\n+\n+fn push_obligations_for_param_bounds(\n+    tcx: &ty::ctxt,\n+    cause: ObligationCause,\n+    recursion_depth: uint,\n+    space: subst::ParamSpace,\n+    index: uint,\n+    param_bounds: &ty::ParamBounds,\n+    param_substs: &Substs,\n+    obligations: &mut VecPerParamSpace<Obligation>)\n+{\n+    let param_ty = *param_substs.types.get(space, index);\n+\n+    for builtin_bound in param_bounds.builtin_bounds.iter() {\n+        obligations.push(\n+            space,\n+            obligation_for_builtin_bound(tcx,\n+                                         cause,\n+                                         builtin_bound,\n+                                         recursion_depth,\n+                                         param_ty));\n+    }\n+\n+    for bound_trait_ref in param_bounds.trait_bounds.iter() {\n+        let bound_trait_ref = bound_trait_ref.subst(tcx, param_substs);\n+        obligations.push(\n+            space,\n+            Obligation { cause: cause,\n+                         recursion_depth: recursion_depth,\n+                         trait_ref: bound_trait_ref });\n+    }\n+}\n+\n+pub fn obligation_for_builtin_bound(\n+    tcx: &ty::ctxt,\n+    cause: ObligationCause,\n+    builtin_bound: ty::BuiltinBound,\n+    recursion_depth: uint,\n+    param_ty: ty::t)\n+    -> Obligation\n+{\n+    match tcx.lang_items.from_builtin_kind(builtin_bound) {\n+        Ok(def_id) => {\n+            Obligation {\n+                cause: cause,\n+                recursion_depth: recursion_depth,\n+                trait_ref: Rc::new(ty::TraitRef {\n+                    def_id: def_id,\n+                    substs: Substs::empty().with_self_ty(param_ty),\n+                }),\n+            }\n+        }\n+        Err(e) => {\n+            tcx.sess.span_bug(cause.span, e.as_slice());\n+        }\n+    }\n+}\n+\n+pub fn search_trait_and_supertraits_from_bound(tcx: &ty::ctxt,\n+                                               caller_bound: Rc<ty::TraitRef>,\n+                                               test: |ast::DefId| -> bool)\n+                                               -> Option<VtableParam>\n+{\n+    /*!\n+     * Starting from a caller obligation `caller_bound` (which has\n+     * coordinates `space`/`i` in the list of caller obligations),\n+     * search through the trait and supertraits to find one where\n+     * `test(d)` is true, where `d` is the def-id of the\n+     * trait/supertrait.  If any is found, return `Some(p)` where `p`\n+     * is the path to that trait/supertrait. Else `None`.\n+     */\n+\n+    for (bound_index, bound) in\n+        transitive_bounds(tcx, &[caller_bound]).enumerate()\n+    {\n+        if test(bound.def_id) {\n+            let vtable_param = VtableParam { bound: bound };\n+            return Some(vtable_param);\n+        }\n+    }\n+\n+    return None;\n+}\n+\n+impl Repr for super::Obligation {\n+    fn repr(&self, tcx: &ty::ctxt) -> String {\n+        format!(\"Obligation(trait_ref={},depth={})\",\n+                self.trait_ref.repr(tcx),\n+                self.recursion_depth)\n+    }\n+}\n+\n+impl<N:Repr> Repr for super::Vtable<N> {\n+    fn repr(&self, tcx: &ty::ctxt) -> String {\n+        match *self {\n+            super::VtableImpl(ref v) =>\n+                v.repr(tcx),\n+\n+            super::VtableUnboxedClosure(ref d) =>\n+                format!(\"VtableUnboxedClosure({})\",\n+                        d.repr(tcx)),\n+\n+            super::VtableParam(ref v) =>\n+                format!(\"VtableParam({})\", v.repr(tcx)),\n+\n+            super::VtableBuiltin =>\n+                format!(\"Builtin\"),\n+        }\n+    }\n+}\n+\n+impl<N:Repr> Repr for super::VtableImpl<N> {\n+    fn repr(&self, tcx: &ty::ctxt) -> String {\n+        format!(\"VtableImpl(impl_def_id={}, substs={}, nested={})\",\n+                self.impl_def_id.repr(tcx),\n+                self.substs.repr(tcx),\n+                self.nested.repr(tcx))\n+    }\n+}\n+\n+impl Repr for super::VtableParam {\n+    fn repr(&self, tcx: &ty::ctxt) -> String {\n+        format!(\"VtableParam(bound={})\",\n+                self.bound.repr(tcx))\n+    }\n+}\n+\n+impl Repr for super::SelectionError {\n+    fn repr(&self, tcx: &ty::ctxt) -> String {\n+        match *self {\n+            super::Unimplemented =>\n+                format!(\"Unimplemented\"),\n+\n+            super::Overflow =>\n+                format!(\"Overflow\"),\n+\n+            super::OutputTypeParameterMismatch(ref t, ref e) =>\n+                format!(\"OutputTypeParameterMismatch({}, {})\",\n+                        t.repr(tcx),\n+                        e.repr(tcx)),\n+        }\n+    }\n+}\n+\n+impl Repr for super::FulfillmentError {\n+    fn repr(&self, tcx: &ty::ctxt) -> String {\n+        format!(\"FulfillmentError({},{})\",\n+                self.obligation.repr(tcx),\n+                self.code.repr(tcx))\n+    }\n+}\n+\n+impl Repr for super::FulfillmentErrorCode {\n+    fn repr(&self, tcx: &ty::ctxt) -> String {\n+        match *self {\n+            super::SelectionError(ref o) => o.repr(tcx),\n+            super::Ambiguity => format!(\"Ambiguity\")\n+        }\n+    }\n+}\n+\n+impl fmt::Show for super::FulfillmentErrorCode {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        match *self {\n+            super::SelectionError(ref e) => write!(f, \"{}\", e),\n+            super::Ambiguity => write!(f, \"Ambiguity\")\n+        }\n+    }\n+}\n+\n+impl Repr for ty::type_err {\n+    fn repr(&self, tcx: &ty::ctxt) -> String {\n+        ty::type_err_to_str(tcx, self)\n+    }\n+}\n+"}, {"sha": "643c52e5d52ba6839ab3b72d4a4cf04b58415d4d", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 74, "deletions": 42, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/c5754f3971b4bb6ea1c9527863189792ab5ee336/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5754f3971b4bb6ea1c9527863189792ab5ee336/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=c5754f3971b4bb6ea1c9527863189792ab5ee336", "patch": "@@ -1089,7 +1089,13 @@ pub struct RegionVid {\n pub enum InferTy {\n     TyVar(TyVid),\n     IntVar(IntVid),\n-    FloatVar(FloatVid)\n+    FloatVar(FloatVid),\n+    SkolemizedTy(uint),\n+\n+    // FIXME -- once integral fallback is impl'd, we should remove\n+    // this type. It's only needed to prevent spurious errors for\n+    // integers whose type winds up never being constrained.\n+    SkolemizedIntTy(uint),\n }\n \n #[deriving(Clone, Encodable, Decodable, Eq, Hash, Show)]\n@@ -1152,6 +1158,8 @@ impl fmt::Show for InferTy {\n             TyVar(ref v) => v.fmt(f),\n             IntVar(ref v) => v.fmt(f),\n             FloatVar(ref v) => v.fmt(f),\n+            SkolemizedTy(v) => write!(f, \"SkolemizedTy({})\", v),\n+            SkolemizedIntTy(v) => write!(f, \"SkolemizedIntTy({})\", v),\n         }\n     }\n }\n@@ -1207,6 +1215,12 @@ impl Generics {\n     }\n }\n \n+impl TraitRef {\n+    pub fn self_ty(&self) -> ty::t {\n+        self.substs.self_ty().unwrap()\n+    }\n+}\n+\n /// When type checking, we use the `ParameterEnvironment` to track\n /// details about the type/lifetime parameters that are in scope.\n /// It primarily stores the bounds information.\n@@ -1235,6 +1249,14 @@ pub struct ParameterEnvironment {\n     /// may specify stronger requirements). This field indicates the\n     /// region of the callee.\n     pub implicit_region_bound: ty::Region,\n+\n+    /// Obligations that the caller must satisfy. This is basically\n+    /// the set of bounds on the in-scope type parameters, translated\n+    /// into Obligations.\n+    ///\n+    /// Note: This effectively *duplicates* the `bounds` array for\n+    /// now.\n+    pub caller_obligations: VecPerParamSpace<traits::Obligation>,\n }\n \n impl ParameterEnvironment {\n@@ -1249,6 +1271,7 @@ impl ParameterEnvironment {\n                                 let method_generics = &method_ty.generics;\n                                 construct_parameter_environment(\n                                     cx,\n+                                    method.span,\n                                     method_generics,\n                                     method.pe_body().id)\n                             }\n@@ -1272,6 +1295,7 @@ impl ParameterEnvironment {\n                                 let method_generics = &method_ty.generics;\n                                 construct_parameter_environment(\n                                     cx,\n+                                    method.span,\n                                     method_generics,\n                                     method.pe_body().id)\n                             }\n@@ -1287,6 +1311,7 @@ impl ParameterEnvironment {\n                         let fn_pty = ty::lookup_item_type(cx, fn_def_id);\n \n                         construct_parameter_environment(cx,\n+                                                        item.span,\n                                                         &fn_pty.generics,\n                                                         body.id)\n                     }\n@@ -1296,7 +1321,8 @@ impl ParameterEnvironment {\n                     ast::ItemStatic(..) => {\n                         let def_id = ast_util::local_def(id);\n                         let pty = ty::lookup_item_type(cx, def_id);\n-                        construct_parameter_environment(cx, &pty.generics, id)\n+                        construct_parameter_environment(cx, item.span,\n+                                                        &pty.generics, id)\n                     }\n                     _ => {\n                         cx.sess.span_bug(item.span,\n@@ -1328,7 +1354,14 @@ pub struct Polytype {\n \n /// As `Polytype` but for a trait ref.\n pub struct TraitDef {\n+    /// Generic type definitions. Note that `Self` is listed in here\n+    /// as having a single bound, the trait itself (e.g., in the trait\n+    /// `Eq`, there is a single bound `Self : Eq`). This is so that\n+    /// default methods get to assume that the `Self` parameters\n+    /// implements the trait.\n     pub generics: Generics,\n+\n+    /// The \"supertrait\" bounds.\n     pub bounds: ParamBounds,\n     pub trait_ref: Rc<ty::TraitRef>,\n }\n@@ -1345,14 +1378,15 @@ pub type type_cache = RefCell<DefIdMap<Polytype>>;\n pub type node_type_table = RefCell<HashMap<uint,t>>;\n \n /// Records information about each unboxed closure.\n+#[deriving(Clone)]\n pub struct UnboxedClosure {\n     /// The type of the unboxed closure.\n     pub closure_type: ClosureTy,\n     /// The kind of unboxed closure this is.\n     pub kind: UnboxedClosureKind,\n }\n \n-#[deriving(PartialEq, Eq)]\n+#[deriving(Clone, PartialEq, Eq)]\n pub enum UnboxedClosureKind {\n     FnUnboxedClosureKind,\n     FnMutUnboxedClosureKind,\n@@ -1523,7 +1557,7 @@ pub fn mk_t(cx: &ctxt, st: sty) -> t {\n       &ty_enum(_, ref substs) | &ty_struct(_, ref substs) => {\n           flags |= sflags(substs);\n       }\n-      &ty_trait(box ty::TyTrait { ref substs, ref bounds, .. }) => {\n+      &ty_trait(box TyTrait { ref substs, ref bounds, .. }) => {\n           flags |= sflags(substs);\n           flags |= flags_for_bounds(bounds);\n       }\n@@ -2394,6 +2428,7 @@ pub fn type_contents(cx: &ctxt, ty: t) -> TypeContents {\n             }\n \n             // Scalar and unique types are sendable, and durable\n+            ty_infer(ty::SkolemizedIntTy(_)) |\n             ty_nil | ty_bot | ty_bool | ty_int(_) | ty_uint(_) | ty_float(_) |\n             ty_bare_fn(_) | ty::ty_char => {\n                 TC::None\n@@ -2414,7 +2449,7 @@ pub fn type_contents(cx: &ctxt, ty: t) -> TypeContents {\n                 }\n             }\n \n-            ty_trait(box ty::TyTrait { bounds, .. }) => {\n+            ty_trait(box TyTrait { bounds, .. }) => {\n                 object_contents(cx, bounds) | TC::ReachesFfiUnsafe | TC::Nonsized\n             }\n \n@@ -2926,6 +2961,14 @@ pub fn type_is_integral(ty: t) -> bool {\n     }\n }\n \n+pub fn type_is_skolemized(ty: t) -> bool {\n+    match get(ty).sty {\n+      ty_infer(SkolemizedTy(_)) => true,\n+      ty_infer(SkolemizedIntTy(_)) => true,\n+      _ => false\n+    }\n+}\n+\n pub fn type_is_uint(ty: t) -> bool {\n     match get(ty).sty {\n       ty_infer(IntVar(_)) | ty_uint(ast::TyU) => true,\n@@ -3760,6 +3803,8 @@ pub fn ty_sort_string(cx: &ctxt, t: t) -> String {\n         ty_infer(TyVar(_)) => \"inferred type\".to_string(),\n         ty_infer(IntVar(_)) => \"integral variable\".to_string(),\n         ty_infer(FloatVar(_)) => \"floating-point variable\".to_string(),\n+        ty_infer(SkolemizedTy(_)) => \"skolemized type\".to_string(),\n+        ty_infer(SkolemizedIntTy(_)) => \"skolemized integral type\".to_string(),\n         ty_param(ref p) => {\n             if p.space == subst::SelfSpace {\n                 \"Self\".to_string()\n@@ -4683,7 +4728,7 @@ pub fn normalize_ty(cx: &ctxt, t: t) -> t {\n     struct TypeNormalizer<'a, 'tcx: 'a>(&'a ctxt<'tcx>);\n \n     impl<'a, 'tcx> TypeFolder<'tcx> for TypeNormalizer<'a, 'tcx> {\n-        fn tcx<'a>(&'a self) -> &'a ctxt<'tcx> { let TypeNormalizer(c) = *self; c }\n+        fn tcx(&self) -> &ctxt<'tcx> { let TypeNormalizer(c) = *self; c }\n \n         fn fold_ty(&mut self, t: ty::t) -> ty::t {\n             match self.tcx().normalized_cache.borrow().find_copy(&t) {\n@@ -4783,42 +4828,11 @@ pub fn eval_repeat_count(tcx: &ctxt, count_expr: &ast::Expr) -> uint {\n pub fn each_bound_trait_and_supertraits(tcx: &ctxt,\n                                         bounds: &[Rc<TraitRef>],\n                                         f: |Rc<TraitRef>| -> bool)\n-                                        -> bool {\n-    for bound_trait_ref in bounds.iter() {\n-        let mut supertrait_set = HashMap::new();\n-        let mut trait_refs = Vec::new();\n-        let mut i = 0;\n-\n-        // Seed the worklist with the trait from the bound\n-        supertrait_set.insert(bound_trait_ref.def_id, ());\n-        trait_refs.push(bound_trait_ref.clone());\n-\n-        // Add the given trait ty to the hash map\n-        while i < trait_refs.len() {\n-            debug!(\"each_bound_trait_and_supertraits(i={:?}, trait_ref={})\",\n-                   i, trait_refs.get(i).repr(tcx));\n-\n-            if !f(trait_refs.get(i).clone()) {\n-                return false;\n-            }\n-\n-            // Add supertraits to supertrait_set\n-            let trait_ref = trait_refs.get(i).clone();\n-            let trait_def = lookup_trait_def(tcx, trait_ref.def_id);\n-            for supertrait_ref in trait_def.bounds.trait_bounds.iter() {\n-                let supertrait_ref = supertrait_ref.subst(tcx, &trait_ref.substs);\n-                debug!(\"each_bound_trait_and_supertraits(supertrait_ref={})\",\n-                       supertrait_ref.repr(tcx));\n-\n-                let d_id = supertrait_ref.def_id;\n-                if !supertrait_set.contains_key(&d_id) {\n-                    // FIXME(#5527) Could have same trait multiple times\n-                    supertrait_set.insert(d_id, ());\n-                    trait_refs.push(supertrait_ref.clone());\n-                }\n-            }\n-\n-            i += 1;\n+                                        -> bool\n+{\n+    for bound_trait_ref in traits::transitive_bounds(tcx, bounds) {\n+        if !f(bound_trait_ref) {\n+            return false;\n         }\n     }\n     return true;\n@@ -5261,8 +5275,22 @@ impl Variance {\n     }\n }\n \n+pub fn empty_parameter_environment() -> ParameterEnvironment {\n+    /*!\n+     * Construct a parameter environment suitable for static contexts\n+     * or other contexts where there are no free type/lifetime\n+     * parameters in scope.\n+     */\n+\n+    ty::ParameterEnvironment { free_substs: Substs::empty(),\n+                               bounds: VecPerParamSpace::empty(),\n+                               caller_obligations: VecPerParamSpace::empty(),\n+                               implicit_region_bound: ty::ReEmpty }\n+}\n+\n pub fn construct_parameter_environment(\n     tcx: &ctxt,\n+    span: Span,\n     generics: &ty::Generics,\n     free_id: ast::NodeId)\n     -> ParameterEnvironment\n@@ -5321,10 +5349,14 @@ pub fn construct_parameter_environment(\n            free_substs.repr(tcx),\n            bounds.repr(tcx));\n \n+    let obligations = traits::obligations_for_generics(tcx, traits::ObligationCause::misc(span),\n+                                                       generics, &free_substs);\n+\n     return ty::ParameterEnvironment {\n         free_substs: free_substs,\n         bounds: bounds,\n         implicit_region_bound: ty::ReScope(free_id),\n+        caller_obligations: obligations,\n     };\n \n     fn push_region_params(regions: &mut VecPerParamSpace<ty::Region>,"}, {"sha": "861afee06049b23b1d90511d86bc395dd9c3d60a", "filename": "src/librustc/middle/ty_fold.rs", "status": "modified", "additions": 92, "deletions": 3, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/c5754f3971b4bb6ea1c9527863189792ab5ee336/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5754f3971b4bb6ea1c9527863189792ab5ee336/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty_fold.rs?ref=c5754f3971b4bb6ea1c9527863189792ab5ee336", "patch": "@@ -8,11 +8,38 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// Generalized type folding mechanism.\n+/*!\n+ * Generalized type folding mechanism. The setup is a bit convoluted\n+ * but allows for convenient usage. Let T be an instance of some\n+ * \"foldable type\" (one which implements `TypeFoldable`) and F be an\n+ * instance of a \"folder\" (a type which implements `TypeFolder`). Then\n+ * the setup is intended to be:\n+ *\n+ *     T.fold_with(F) --calls--> F.fold_T(T) --calls--> super_fold_T(F, T)\n+ *\n+ * This way, when you define a new folder F, you can override\n+ * `fold_T()` to customize the behavior, and invoke `super_fold_T()`\n+ * to get the original behavior. Meanwhile, to actually fold\n+ * something, you can just write `T.fold_with(F)`, which is\n+ * convenient. (Note that `fold_with` will also transparently handle\n+ * things like a `Vec<T>` where T is foldable and so on.)\n+ *\n+ * In this ideal setup, the only function that actually *does*\n+ * anything is `super_fold_T`, which traverses the type `T`. Moreover,\n+ * `super_fold_T` should only ever call `T.fold_with()`.\n+ *\n+ * In some cases, we follow a degenerate pattern where we do not have\n+ * a `fold_T` nor `super_fold_T` method. Instead, `T.fold_with`\n+ * traverses the structure directly. This is suboptimal because the\n+ * behavior cannot be overriden, but it's much less work to implement.\n+ * If you ever *do* need an override that doesn't exist, it's not hard\n+ * to convert the degenerate pattern into the proper thing.\n+ */\n \n use middle::subst;\n use middle::subst::VecPerParamSpace;\n use middle::ty;\n+use middle::traits;\n use middle::typeck;\n use std::rc::Rc;\n use syntax::ast;\n@@ -97,6 +124,10 @@ pub trait TypeFolder<'tcx> {\n     fn fold_item_substs(&mut self, i: ty::ItemSubsts) -> ty::ItemSubsts {\n         super_fold_item_substs(self, i)\n     }\n+\n+    fn fold_obligation(&mut self, o: &traits::Obligation) -> traits::Obligation {\n+        super_fold_obligation(self, o)\n+    }\n }\n \n ///////////////////////////////////////////////////////////////////////////\n@@ -110,6 +141,12 @@ pub trait TypeFolder<'tcx> {\n // can easily refactor the folding into the TypeFolder trait as\n // needed.\n \n+impl TypeFoldable for () {\n+    fn fold_with<'tcx, F:TypeFolder<'tcx>>(&self, _: &mut F) -> () {\n+        ()\n+    }\n+}\n+\n impl<T:TypeFoldable> TypeFoldable for Option<T> {\n     fn fold_with<'tcx, F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Option<T> {\n         self.as_ref().map(|t| t.fold_with(folder))\n@@ -296,13 +333,54 @@ impl TypeFoldable for ty::UnsizeKind {\n         match *self {\n             ty::UnsizeLength(len) => ty::UnsizeLength(len),\n             ty::UnsizeStruct(box ref k, n) => ty::UnsizeStruct(box k.fold_with(folder), n),\n-            ty::UnsizeVtable(bounds, def_id, ref substs) => {\n-                ty::UnsizeVtable(bounds.fold_with(folder), def_id, substs.fold_with(folder))\n+            ty::UnsizeVtable(ty::TyTrait{bounds, def_id, substs: ref substs}, self_ty) => {\n+                ty::UnsizeVtable(\n+                    ty::TyTrait {\n+                        bounds: bounds.fold_with(folder),\n+                        def_id: def_id,\n+                        substs: substs.fold_with(folder)\n+                    },\n+                    self_ty.fold_with(folder))\n             }\n         }\n     }\n }\n \n+impl TypeFoldable for traits::Obligation {\n+    fn fold_with<'tcx, F:TypeFolder<'tcx>>(&self, folder: &mut F) -> traits::Obligation {\n+        folder.fold_obligation(self)\n+    }\n+}\n+\n+impl<N:TypeFoldable> TypeFoldable for traits::VtableImpl<N> {\n+    fn fold_with<'tcx, F:TypeFolder<'tcx>>(&self, folder: &mut F) -> traits::VtableImpl<N> {\n+        traits::VtableImpl {\n+            impl_def_id: self.impl_def_id,\n+            substs: self.substs.fold_with(folder),\n+            nested: self.nested.fold_with(folder),\n+        }\n+    }\n+}\n+\n+impl<N:TypeFoldable> TypeFoldable for traits::Vtable<N> {\n+    fn fold_with<'tcx, F:TypeFolder<'tcx>>(&self, folder: &mut F) -> traits::Vtable<N> {\n+        match *self {\n+            traits::VtableImpl(ref v) => traits::VtableImpl(v.fold_with(folder)),\n+            traits::VtableUnboxedClosure(d) => traits::VtableUnboxedClosure(d),\n+            traits::VtableParam(ref p) => traits::VtableParam(p.fold_with(folder)),\n+            traits::VtableBuiltin => traits::VtableBuiltin,\n+        }\n+    }\n+}\n+\n+impl TypeFoldable for traits::VtableParam {\n+    fn fold_with<'tcx, F:TypeFolder<'tcx>>(&self, folder: &mut F) -> traits::VtableParam {\n+        traits::VtableParam {\n+            bound: self.bound.fold_with(folder),\n+        }\n+    }\n+}\n+\n ///////////////////////////////////////////////////////////////////////////\n // \"super\" routines: these are the default implementations for TypeFolder.\n //\n@@ -482,6 +560,17 @@ pub fn super_fold_item_substs<'tcx, T: TypeFolder<'tcx>>(this: &mut T,\n     }\n }\n \n+pub fn super_fold_obligation<'tcx, T:TypeFolder<'tcx>>(this: &mut T,\n+                                                       obligation: &traits::Obligation)\n+                                                       -> traits::Obligation\n+{\n+    traits::Obligation {\n+        cause: obligation.cause,\n+        recursion_depth: obligation.recursion_depth,\n+        trait_ref: obligation.trait_ref.fold_with(this),\n+    }\n+}\n+\n ///////////////////////////////////////////////////////////////////////////\n // Some sample folders\n "}, {"sha": "4f663df58824a14abb9e8ae072f4b2f436c65dae", "filename": "src/librustc/middle/typeck/infer/error_reporting.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c5754f3971b4bb6ea1c9527863189792ab5ee336/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5754f3971b4bb6ea1c9527863189792ab5ee336/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs?ref=c5754f3971b4bb6ea1c9527863189792ab5ee336", "patch": "@@ -363,6 +363,7 @@ impl<'a, 'tcx> ErrorReporting for InferCtxt<'a, 'tcx> {\n             infer::ExprAssignable(_) => \"mismatched types\",\n             infer::RelateTraitRefs(_) => \"mismatched traits\",\n             infer::RelateSelfType(_) => \"mismatched types\",\n+            infer::RelateOutputImplTypes(_) => \"mismatched types\",\n             infer::MatchExpressionArm(_, _) => \"match arms have incompatible types\",\n             infer::IfExpression(_) => \"if and else have incompatible types\",\n         };\n@@ -1465,7 +1466,11 @@ impl<'a, 'tcx> ErrorReportingHelpers for InferCtxt<'a, 'tcx> {\n                         format!(\"traits are compatible\")\n                     }\n                     infer::RelateSelfType(_) => {\n-                        format!(\"type matches impl\")\n+                        format!(\"self type matches impl self type\")\n+                    }\n+                    infer::RelateOutputImplTypes(_) => {\n+                        format!(\"trait type parameters matches those \\\n+                                 specified on the impl\")\n                     }\n                     infer::MatchExpressionArm(_, _) => {\n                         format!(\"match arms have compatible types\")"}, {"sha": "db90593b5b36bc2a5c44791be752a5238ce92e57", "filename": "src/librustc/middle/typeck/infer/mod.rs", "status": "modified", "additions": 121, "deletions": 40, "changes": 161, "blob_url": "https://github.com/rust-lang/rust/blob/c5754f3971b4bb6ea1c9527863189792ab5ee336/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5754f3971b4bb6ea1c9527863189792ab5ee336/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs?ref=c5754f3971b4bb6ea1c9527863189792ab5ee336", "patch": "@@ -26,6 +26,7 @@ use middle::subst::Substs;\n use middle::ty::{TyVid, IntVid, FloatVid, RegionVid};\n use middle::ty;\n use middle::ty_fold;\n+use middle::ty_fold::TypeFoldable;\n use middle::ty_fold::TypeFolder;\n use middle::typeck::check::regionmanip::replace_late_bound_regions_in_fn_sig;\n use middle::typeck::infer::coercion::Coerce;\n@@ -57,6 +58,7 @@ pub mod lattice;\n pub mod lub;\n pub mod region_inference;\n pub mod resolve;\n+mod skolemize;\n pub mod sub;\n pub mod test;\n pub mod type_variable;\n@@ -114,9 +116,12 @@ pub enum TypeOrigin {\n     // Relating trait refs when resolving vtables\n     RelateTraitRefs(Span),\n \n-    // Relating trait refs when resolving vtables\n+    // Relating self types when resolving vtables\n     RelateSelfType(Span),\n \n+    // Relating trait type parameters to those found in impl etc\n+    RelateOutputImplTypes(Span),\n+\n     // Computing common supertype in the arms of a match expression\n     MatchExpressionArm(Span, Span),\n \n@@ -262,6 +267,7 @@ pub enum RegionVariableOrigin {\n     BoundRegionInCoherence(ast::Name),\n }\n \n+#[deriving(Show)]\n pub enum fixup_err {\n     unresolved_int_ty(IntVid),\n     unresolved_float_ty(FloatVid),\n@@ -336,17 +342,12 @@ pub fn mk_subty(cx: &InferCtxt,\n                 origin: TypeOrigin,\n                 a: ty::t,\n                 b: ty::t)\n-             -> ures {\n+                -> ures\n+{\n     debug!(\"mk_subty({} <: {})\", a.repr(cx.tcx), b.repr(cx.tcx));\n-    indent(|| {\n-        cx.commit_if_ok(|| {\n-            let trace = TypeTrace {\n-                origin: origin,\n-                values: Types(expected_found(a_is_expected, a, b))\n-            };\n-            cx.sub(a_is_expected, trace).tys(a, b)\n-        })\n-    }).to_ures()\n+    cx.commit_if_ok(|| {\n+        cx.sub_types(a_is_expected, origin, a, b)\n+    })\n }\n \n pub fn can_mk_subty(cx: &InferCtxt, a: ty::t, b: ty::t) -> ures {\n@@ -356,8 +357,8 @@ pub fn can_mk_subty(cx: &InferCtxt, a: ty::t, b: ty::t) -> ures {\n             origin: Misc(codemap::DUMMY_SP),\n             values: Types(expected_found(true, a, b))\n         };\n-        cx.sub(true, trace).tys(a, b)\n-    }).to_ures()\n+        cx.sub(true, trace).tys(a, b).to_ures()\n+    })\n }\n \n pub fn can_mk_eqty(cx: &InferCtxt, a: ty::t, b: ty::t) -> ures {\n@@ -393,6 +394,14 @@ pub fn verify_param_bound(cx: &InferCtxt,\n \n     cx.region_vars.verify_param_bound(origin, param_ty, a, bs);\n }\n+\n+pub fn skolemize<T:TypeFoldable+Repr>(cx: &InferCtxt, a: T) -> T {\n+    let mut skol = skolemize::TypeSkolemizer::new(cx);\n+    let b = a.fold_with(&mut skol);\n+    debug!(\"skol(a={}) -> {}\", a.repr(cx.tcx), b.repr(cx.tcx));\n+    b\n+}\n+\n pub fn mk_eqty(cx: &InferCtxt,\n                a_is_expected: bool,\n                origin: TypeOrigin,\n@@ -401,40 +410,28 @@ pub fn mk_eqty(cx: &InferCtxt,\n             -> ures\n {\n     debug!(\"mk_eqty({} <: {})\", a.repr(cx.tcx), b.repr(cx.tcx));\n-    cx.commit_if_ok(|| {\n-        let trace = TypeTrace {\n-            origin: origin,\n-            values: Types(expected_found(a_is_expected, a, b))\n-        };\n-        try!(cx.equate(a_is_expected, trace).tys(a, b));\n-        Ok(())\n-    })\n+    cx.commit_if_ok(\n+        || cx.eq_types(a_is_expected, origin, a, b))\n }\n \n pub fn mk_sub_trait_refs(cx: &InferCtxt,\n                          a_is_expected: bool,\n                          origin: TypeOrigin,\n                          a: Rc<ty::TraitRef>,\n                          b: Rc<ty::TraitRef>)\n-    -> ures\n+                         -> ures\n {\n     debug!(\"mk_sub_trait_refs({} <: {})\",\n            a.repr(cx.tcx), b.repr(cx.tcx));\n-    indent(|| {\n-        cx.commit_if_ok(|| {\n-            let trace = TypeTrace {\n-                origin: origin,\n-                values: TraitRefs(expected_found(a_is_expected, a.clone(), b.clone()))\n-            };\n-            let suber = cx.sub(a_is_expected, trace);\n-            suber.trait_refs(&*a, &*b)\n-        })\n-    }).to_ures()\n+    cx.commit_if_ok(\n+        || cx.sub_trait_refs(a_is_expected, origin, a.clone(), b.clone()))\n }\n \n fn expected_found<T>(a_is_expected: bool,\n                      a: T,\n-                     b: T) -> ty::expected_found<T> {\n+                     b: T)\n+                     -> ty::expected_found<T>\n+{\n     if a_is_expected {\n         ty::expected_found {expected: a, found: b}\n     } else {\n@@ -629,7 +626,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     }\n \n     /// Execute `f` then unroll any bindings it creates\n-    pub fn probe<T,E>(&self, f: || -> Result<T,E>) -> Result<T,E> {\n+    pub fn probe<R>(&self, f: || -> R) -> R {\n         debug!(\"probe()\");\n         let snapshot = self.start_snapshot();\n         let r = f();\n@@ -643,6 +640,54 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     {\n         self.region_vars.add_given(sub, sup);\n     }\n+\n+    pub fn sub_types(&self,\n+                     a_is_expected: bool,\n+                     origin: TypeOrigin,\n+                     a: ty::t,\n+                     b: ty::t)\n+                     -> ures\n+    {\n+        debug!(\"sub_types({} <: {})\", a.repr(self.tcx), b.repr(self.tcx));\n+        let trace = TypeTrace {\n+            origin: origin,\n+            values: Types(expected_found(a_is_expected, a, b))\n+        };\n+        self.sub(a_is_expected, trace).tys(a, b).to_ures()\n+    }\n+\n+    pub fn eq_types(&self,\n+                    a_is_expected: bool,\n+                    origin: TypeOrigin,\n+                    a: ty::t,\n+                    b: ty::t)\n+                    -> ures\n+    {\n+        let trace = TypeTrace {\n+            origin: origin,\n+            values: Types(expected_found(a_is_expected, a, b))\n+        };\n+        self.equate(a_is_expected, trace).tys(a, b).to_ures()\n+    }\n+\n+    pub fn sub_trait_refs(&self,\n+                          a_is_expected: bool,\n+                          origin: TypeOrigin,\n+                          a: Rc<ty::TraitRef>,\n+                          b: Rc<ty::TraitRef>)\n+                          -> ures\n+    {\n+        debug!(\"sub_trait_refs({} <: {})\",\n+               a.repr(self.tcx),\n+               b.repr(self.tcx));\n+        let trace = TypeTrace {\n+            origin: origin,\n+            values: TraitRefs(expected_found(a_is_expected,\n+                                             a.clone(), b.clone()))\n+        };\n+        let suber = self.sub(a_is_expected, trace);\n+        suber.trait_refs(&*a, &*b).to_ures()\n+    }\n }\n \n impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n@@ -685,17 +730,40 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             .collect()\n     }\n \n-    pub fn fresh_substs_for_type(&self,\n-                                 span: Span,\n-                                 generics: &ty::Generics)\n-                                 -> subst::Substs\n+    pub fn fresh_substs_for_generics(&self,\n+                                     span: Span,\n+                                     generics: &ty::Generics)\n+                                     -> subst::Substs\n     {\n         /*!\n          * Given a set of generics defined on a type or impl, returns\n          * a substitution mapping each type/region parameter to a\n          * fresh inference variable.\n          */\n-        assert!(generics.types.len(subst::SelfSpace) == 0);\n+\n+        let type_params =\n+            generics.types.map(\n+                |_| self.next_ty_var());\n+        let region_params =\n+            generics.regions.map(\n+                |d| self.next_region_var(EarlyBoundRegion(span, d.name)));\n+        subst::Substs::new(type_params, region_params)\n+    }\n+\n+    pub fn fresh_substs_for_trait(&self,\n+                                  span: Span,\n+                                  generics: &ty::Generics,\n+                                  self_ty: ty::t)\n+                                  -> subst::Substs\n+    {\n+        /*!\n+         * Given a set of generics defined on a trait, returns a\n+         * substitution mapping each output type/region parameter to a\n+         * fresh inference variable, and mapping the self type to\n+         * `self_ty`.\n+         */\n+\n+        assert!(generics.types.len(subst::SelfSpace) == 1);\n         assert!(generics.types.len(subst::FnSpace) == 0);\n         assert!(generics.regions.len(subst::SelfSpace) == 0);\n         assert!(generics.regions.len(subst::FnSpace) == 0);\n@@ -704,7 +772,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         let region_param_defs = generics.regions.get_slice(subst::TypeSpace);\n         let regions = self.region_vars_for_defs(span, region_param_defs);\n         let type_parameters = self.next_ty_vars(type_parameter_count);\n-        subst::Substs::new_type(type_parameters, regions)\n+        subst::Substs::new_trait(type_parameters, regions, self_ty)\n     }\n \n     pub fn fresh_bound_region(&self, binder_id: ast::NodeId) -> ty::Region {\n@@ -731,6 +799,15 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         trait_ref_to_string(self.tcx, &t)\n     }\n \n+    pub fn contains_unbound_type_variables(&self, typ: ty::t) -> ty::t {\n+        match resolve_type(self,\n+                           None,\n+                           typ, resolve_nested_tvar | resolve_ivar) {\n+          Ok(new_type) => new_type,\n+          Err(_) => typ\n+        }\n+    }\n+\n     pub fn resolve_type_vars_if_possible(&self, typ: ty::t) -> ty::t {\n         match resolve_type(self,\n                            None,\n@@ -907,6 +984,7 @@ impl TypeOrigin {\n             Misc(span) => span,\n             RelateTraitRefs(span) => span,\n             RelateSelfType(span) => span,\n+            RelateOutputImplTypes(span) => span,\n             MatchExpressionArm(match_span, _) => match_span,\n             IfExpression(span) => span,\n         }\n@@ -929,6 +1007,9 @@ impl Repr for TypeOrigin {\n             RelateSelfType(a) => {\n                 format!(\"RelateSelfType({})\", a.repr(tcx))\n             }\n+            RelateOutputImplTypes(a) => {\n+                format!(\"RelateOutputImplTypes({})\", a.repr(tcx))\n+            }\n             MatchExpressionArm(a, b) => {\n                 format!(\"MatchExpressionArm({}, {})\", a.repr(tcx), b.repr(tcx))\n             }"}, {"sha": "2c0b2dbe2ba79d880f51e5479316d27e98410cfc", "filename": "src/librustc/middle/typeck/infer/resolve.rs", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/c5754f3971b4bb6ea1c9527863189792ab5ee336/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5754f3971b4bb6ea1c9527863189792ab5ee336/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fresolve.rs?ref=c5754f3971b4bb6ea1c9527863189792ab5ee336", "patch": "@@ -46,15 +46,13 @@\n // future).  If you want to resolve everything but one type, you are\n // probably better off writing `resolve_all - resolve_ivar`.\n \n-\n use middle::ty::{FloatVar, FloatVid, IntVar, IntVid, RegionVid, TyVar, TyVid};\n use middle::ty::{IntType, UintType};\n use middle::ty;\n use middle::ty_fold;\n use middle::typeck::infer::{fixup_err, fres, InferCtxt};\n use middle::typeck::infer::{unresolved_int_ty,unresolved_float_ty,unresolved_ty};\n use syntax::codemap::Span;\n-use util::common::indent;\n use util::ppaux::{Repr, ty_to_string};\n \n pub static resolve_nested_tvar: uint = 0b0000000001;\n@@ -94,7 +92,7 @@ pub fn resolver<'a, 'tcx>(infcx: &'a InferCtxt<'a, 'tcx>,\n }\n \n impl<'a, 'tcx> ty_fold::TypeFolder<'tcx> for ResolveState<'a, 'tcx> {\n-    fn tcx<'a>(&'a self) -> &'a ty::ctxt<'tcx> {\n+    fn tcx(&self) -> &ty::ctxt<'tcx> {\n         self.infcx.tcx\n     }\n \n@@ -114,7 +112,8 @@ impl<'a, 'tcx> ResolveState<'a, 'tcx> {\n \n     pub fn resolve_type_chk(&mut self,\n                             typ: ty::t)\n-                            -> fres<ty::t> {\n+                            -> fres<ty::t>\n+    {\n         self.err = None;\n \n         debug!(\"Resolving {} (modes={:x})\",\n@@ -126,22 +125,24 @@ impl<'a, 'tcx> ResolveState<'a, 'tcx> {\n \n         let rty = self.resolve_type(typ);\n         match self.err {\n-          None => {\n-            debug!(\"Resolved {} to {} (modes={:x})\",\n-                   ty_to_string(self.infcx.tcx, typ),\n-                   ty_to_string(self.infcx.tcx, rty),\n-                   self.modes);\n-            return Ok(rty);\n-          }\n-          Some(e) => return Err(e)\n+            None => {\n+                debug!(\"Resolved {} to {} (modes={:x})\",\n+                       ty_to_string(self.infcx.tcx, typ),\n+                       ty_to_string(self.infcx.tcx, rty),\n+                       self.modes);\n+                return Ok(rty);\n+            }\n+            Some(e) => {\n+                return Err(e);\n+            }\n         }\n     }\n \n     pub fn resolve_region_chk(&mut self,\n                               orig: ty::Region)\n                               -> fres<ty::Region> {\n         self.err = None;\n-        let resolved = indent(|| self.resolve_region(orig) );\n+        let resolved = self.resolve_region(orig);\n         match self.err {\n           None => Ok(resolved),\n           Some(e) => Err(e)"}, {"sha": "e1d48407f2e437ae8bf3a6af0d8a06ed743ddf18", "filename": "src/librustc/middle/typeck/infer/skolemize.rs", "status": "added", "additions": 157, "deletions": 0, "changes": 157, "blob_url": "https://github.com/rust-lang/rust/blob/c5754f3971b4bb6ea1c9527863189792ab5ee336/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fskolemize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5754f3971b4bb6ea1c9527863189792ab5ee336/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fskolemize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fskolemize.rs?ref=c5754f3971b4bb6ea1c9527863189792ab5ee336", "patch": "@@ -0,0 +1,157 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+/*!\n+ * Skolemization is the process of replacing unknown variables with\n+ * fresh types. The idea is that the type, after skolemization,\n+ * contains no inference variables but instead contains either a value\n+ * for each variable (if the variable had already fresh \"arbitrary\"\n+ * types wherever a variable would have been.\n+ *\n+ * Skolemization is used wherever we want to test what the type\n+ * inferencer knows \"so far\". The primary place it is used right now\n+ * is in the trait matching algorithm, which needs to be able to test\n+ * whether an `impl` self type matches some other type X -- *without*\n+ * affecting `X`. That means if that if the type `X` is in fact an\n+ * unbound type variable, we want the match to be regarded as\n+ * ambiguous, because depending on what type that type variable is\n+ * ultimately assigned, the match may or may not succeed.\n+ *\n+ * Note that you should be careful not to allow the output of\n+ * skolemization to leak to the user in error messages or in any other\n+ * form. Skolemization is only really useful as an internal detail.\n+ *\n+ * __An important detail concerning regions.__ The skolemizer also\n+ * replaces *all* regions with 'static. The reason behind this is\n+ * that, in general, we do not take region relationships into account\n+ * when making type-overloaded decisions. This is important because of\n+ * the design of the region inferencer, which is not based on\n+ * unification but rather on accumulating and then solving a set of\n+ * constraints. In contrast, the type inferencer assigns a value to\n+ * each type variable only once, and it does so as soon as it can, so\n+ * it is reasonable to ask what the type inferencer knows \"so far\".\n+ */\n+\n+use middle::ty;\n+use middle::ty_fold;\n+use middle::ty_fold::TypeFoldable;\n+use middle::ty_fold::TypeFolder;\n+\n+use super::InferCtxt;\n+use super::unify::InferCtxtMethodsForSimplyUnifiableTypes;\n+use super::unify::SimplyUnifiable;\n+use super::unify::UnifyKey;\n+\n+pub struct TypeSkolemizer<'a, 'tcx:'a> {\n+    infcx: &'a InferCtxt<'a, 'tcx>,\n+    skolemization_count: uint\n+}\n+\n+impl<'a, 'tcx> TypeSkolemizer<'a, 'tcx> {\n+    pub fn new<'tcx>(infcx: &'a InferCtxt<'a, 'tcx>) -> TypeSkolemizer<'a, 'tcx> {\n+        TypeSkolemizer { infcx: infcx, skolemization_count: 0 }\n+    }\n+\n+    fn probe_ty(&mut self, v: ty::TyVid) -> ty::t {\n+        self.skolemize_if_none(self.infcx.type_variables.borrow().probe(v), ty::SkolemizedTy)\n+    }\n+\n+    fn probe_unifiable<V:SimplyUnifiable,K:UnifyKey<Option<V>>>(&mut self, k: K) -> ty::t {\n+        self.skolemize_if_none(self.infcx.probe_var(k), ty::SkolemizedIntTy)\n+    }\n+\n+    fn skolemize_if_none(&mut self, o: Option<ty::t>,\n+                         skolemizer: |uint| -> ty::InferTy)\n+                         -> ty::t {\n+        match o {\n+            Some(t) => t.fold_with(self),\n+            None => {\n+                let index = self.skolemization_count;\n+                self.skolemization_count += 1;\n+                ty::mk_infer(self.tcx(), skolemizer(index))\n+            }\n+        }\n+    }\n+}\n+\n+impl<'a, 'tcx> TypeFolder<'tcx> for TypeSkolemizer<'a, 'tcx> {\n+    fn tcx<'b>(&'b self) -> &'b ty::ctxt<'tcx> {\n+        self.infcx.tcx\n+    }\n+\n+    fn fold_region(&mut self, r: ty::Region) -> ty::Region {\n+        match r {\n+            ty::ReEarlyBound(..) |\n+            ty::ReLateBound(..) => {\n+                // leave bound regions alone\n+                r\n+            }\n+\n+            ty::ReStatic |\n+            ty::ReFree(_) |\n+            ty::ReScope(_) |\n+            ty::ReInfer(_) |\n+            ty::ReEmpty => {\n+                // replace all free regions with 'static\n+                ty::ReStatic\n+            }\n+        }\n+    }\n+\n+    fn fold_ty(&mut self, t: ty::t) -> ty::t {\n+        match ty::get(t).sty {\n+            ty::ty_infer(ty::TyVar(v)) => {\n+                self.probe_ty(v)\n+            }\n+\n+            ty::ty_infer(ty::IntVar(v)) => {\n+                self.probe_unifiable(v)\n+            }\n+\n+            ty::ty_infer(ty::FloatVar(v)) => {\n+                self.probe_unifiable(v)\n+            }\n+\n+            ty::ty_infer(ty::SkolemizedTy(_)) |\n+            ty::ty_infer(ty::SkolemizedIntTy(_)) => {\n+                self.tcx().sess.bug(\"Cannot skolemize a skolemized type\");\n+            }\n+\n+            ty::ty_open(..) => {\n+                self.tcx().sess.bug(\"Cannot skolemize an open existential type\");\n+            }\n+\n+            ty::ty_nil |\n+            ty::ty_bot |\n+            ty::ty_bool |\n+            ty::ty_char |\n+            ty::ty_int(..) |\n+            ty::ty_uint(..) |\n+            ty::ty_float(..) |\n+            ty::ty_enum(..) |\n+            ty::ty_box(..) |\n+            ty::ty_uniq(..) |\n+            ty::ty_str |\n+            ty::ty_err |\n+            ty::ty_vec(..) |\n+            ty::ty_ptr(..) |\n+            ty::ty_rptr(..) |\n+            ty::ty_bare_fn(..) |\n+            ty::ty_closure(..) |\n+            ty::ty_trait(..) |\n+            ty::ty_struct(..) |\n+            ty::ty_unboxed_closure(..) |\n+            ty::ty_tup(..) |\n+            ty::ty_param(..) => {\n+                ty_fold::super_fold_ty(self, t)\n+            }\n+        }\n+    }\n+}"}, {"sha": "301582d55d6eb0bbfc6fca57126e468bbe6bf485", "filename": "src/librustc/middle/typeck/infer/unify.rs", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/c5754f3971b4bb6ea1c9527863189792ab5ee336/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Funify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5754f3971b4bb6ea1c9527863189792ab5ee336/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Funify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Funify.rs?ref=c5754f3971b4bb6ea1c9527863189792ab5ee336", "patch": "@@ -258,6 +258,7 @@ impl<K,V> sv::SnapshotVecDelegate<VarValue<K,V>,()> for Delegate {\n  * relationship.\n  */\n pub trait SimplyUnifiable : Clone + PartialEq + Repr {\n+    fn to_type(&self) -> ty::t;\n     fn to_type_err(expected_found<Self>) -> ty::type_err;\n }\n \n@@ -286,6 +287,7 @@ pub trait InferCtxtMethodsForSimplyUnifiableTypes<V:SimplyUnifiable,\n                     a_id: K,\n                     b: V)\n                     -> ures;\n+    fn probe_var(&self, a_id: K) -> Option<ty::t>;\n }\n \n impl<'a,'tcx,V:SimplyUnifiable,K:UnifyKey<Option<V>>>\n@@ -370,6 +372,16 @@ impl<'a,'tcx,V:SimplyUnifiable,K:UnifyKey<Option<V>>>\n             }\n         }\n     }\n+\n+    fn probe_var(&self, a_id: K) -> Option<ty::t> {\n+        let tcx = self.tcx;\n+        let table = UnifyKey::unification_table(self);\n+        let node_a = table.borrow_mut().get(tcx, a_id);\n+        match node_a.value {\n+            None => None,\n+            Some(ref a_t) => Some(a_t.to_type())\n+        }\n+    }\n }\n \n ///////////////////////////////////////////////////////////////////////////\n@@ -393,6 +405,13 @@ impl UnifyKey<Option<IntVarValue>> for ty::IntVid {\n }\n \n impl SimplyUnifiable for IntVarValue {\n+    fn to_type(&self) -> ty::t {\n+        match *self {\n+            ty::IntType(i) => ty::mk_mach_int(i),\n+            ty::UintType(i) => ty::mk_mach_uint(i),\n+        }\n+    }\n+\n     fn to_type_err(err: expected_found<IntVarValue>) -> ty::type_err {\n         return ty::terr_int_mismatch(err);\n     }\n@@ -422,6 +441,10 @@ impl UnifyValue for Option<ast::FloatTy> {\n }\n \n impl SimplyUnifiable for ast::FloatTy {\n+    fn to_type(&self) -> ty::t {\n+        ty::mk_mach_float(*self)\n+    }\n+\n     fn to_type_err(err: expected_found<ast::FloatTy>) -> ty::type_err {\n         return ty::terr_float_mismatch(err);\n     }"}]}