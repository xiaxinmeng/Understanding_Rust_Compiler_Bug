{"sha": "ca9bb2d9ace2bf085dc276e241f6707e0402093f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNhOWJiMmQ5YWNlMmJmMDg1ZGMyNzZlMjQxZjY3MDdlMDQwMjA5M2Y=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-05-13T23:13:20Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-05-23T04:57:02Z"}, "message": "librustc: Disallow `use` from reaching into impls or traits.\n\nThis can perhaps be restored in the future. For now this is a precursor to\nmaking typedefs work as expected.", "tree": {"sha": "1b000b169c7c93bd43b56cd31dd4c5c496223b90", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1b000b169c7c93bd43b56cd31dd4c5c496223b90"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ca9bb2d9ace2bf085dc276e241f6707e0402093f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ca9bb2d9ace2bf085dc276e241f6707e0402093f", "html_url": "https://github.com/rust-lang/rust/commit/ca9bb2d9ace2bf085dc276e241f6707e0402093f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ca9bb2d9ace2bf085dc276e241f6707e0402093f/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "291518712fd6c77717614a86450eec58e3f80df2", "url": "https://api.github.com/repos/rust-lang/rust/commits/291518712fd6c77717614a86450eec58e3f80df2", "html_url": "https://github.com/rust-lang/rust/commit/291518712fd6c77717614a86450eec58e3f80df2"}], "stats": {"total": 252, "additions": 187, "deletions": 65}, "files": [{"sha": "bfa4862e0548e18593436c4f5353a3a65e48a246", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 136, "deletions": 56, "changes": 192, "blob_url": "https://github.com/rust-lang/rust/blob/ca9bb2d9ace2bf085dc276e241f6707e0402093f/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca9bb2d9ace2bf085dc276e241f6707e0402093f/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=ca9bb2d9ace2bf085dc276e241f6707e0402093f", "patch": "@@ -255,8 +255,20 @@ pub enum AllowCapturingSelfFlag {\n \n #[deriving(Eq)]\n enum NameSearchType {\n-    SearchItemsAndPublicImports,    //< Search items and public imports.\n-    SearchItemsAndAllImports,       //< Search items and all imports.\n+    /// We're doing a name search in order to resolve a `use` directive.\n+    ImportSearch,\n+\n+    /// We're doing a name search in order to resolve a path type, a path\n+    /// expression, or a path pattern. We can select public or private\n+    /// names.\n+    ///\n+    /// XXX: This should be ripped out of resolve and handled later, in\n+    /// the privacy checking phase.\n+    PathPublicOrPrivateSearch,\n+\n+    /// We're doing a name search in order to resolve a path type, a path\n+    /// expression, or a path pattern. Allow only public names to be selected.\n+    PathPublicOnlySearch,\n }\n \n pub enum BareIdentifierPatternResolution {\n@@ -394,6 +406,7 @@ pub enum ModuleKind {\n     NormalModuleKind,\n     ExternModuleKind,\n     TraitModuleKind,\n+    ImplModuleKind,\n     AnonymousModuleKind,\n }\n \n@@ -424,7 +437,6 @@ pub struct Module {\n     //\n     // There will be an anonymous module created around `g` with the ID of the\n     // entry block for `f`.\n-\n     anonymous_children: @mut HashMap<node_id,@mut Module>,\n \n     // The status of resolving each import in this module.\n@@ -514,6 +526,38 @@ pub impl NameBindings {\n         }\n     }\n \n+    /// Sets the kind of the module, creating a new one if necessary.\n+    fn set_module_kind(@mut self,\n+                       privacy: Privacy,\n+                       parent_link: ParentLink,\n+                       def_id: Option<def_id>,\n+                       kind: ModuleKind,\n+                       sp: span) {\n+        match self.type_def {\n+            None => {\n+                let module = @mut Module(parent_link, def_id, kind);\n+                self.type_def = Some(TypeNsDef {\n+                    privacy: privacy,\n+                    module_def: Some(module),\n+                    type_def: None\n+                })\n+            }\n+            Some(type_def) => {\n+                match type_def.module_def {\n+                    None => {\n+                        let module = @mut Module(parent_link, def_id, kind);\n+                        self.type_def = Some(TypeNsDef {\n+                            privacy: privacy,\n+                            module_def: Some(module),\n+                            type_def: type_def.type_def\n+                        })\n+                    }\n+                    Some(module_def) => module_def.kind = kind,\n+                }\n+            }\n+        }\n+    }\n+\n     /// Records a type definition.\n     fn define_type(@mut self, privacy: Privacy, def: def, sp: span) {\n         // Merges the type with the existing type def or creates a new one.\n@@ -1191,7 +1235,7 @@ pub impl Resolver {\n                         name_bindings.define_module(Public,\n                                                     parent_link,\n                                                     Some(def_id),\n-                                                    TraitModuleKind,\n+                                                    ImplModuleKind,\n                                                     sp);\n \n                         let new_parent = ModuleReducedGraphParent(\n@@ -1579,8 +1623,8 @@ pub impl Resolver {\n               // If this is a trait, add all the method names\n               // to the trait info.\n \n-              let method_def_ids = get_trait_method_def_ids(self.session.cstore,\n-                                                            def_id);\n+              let method_def_ids =\n+                get_trait_method_def_ids(self.session.cstore, def_id);\n               let mut interned_method_names = HashSet::new();\n               for method_def_ids.each |&method_def_id| {\n                   let (method_name, explicit_self) =\n@@ -1608,6 +1652,14 @@ pub impl Resolver {\n               }\n \n               child_name_bindings.define_type(Public, def, dummy_sp());\n+\n+              // Define a module if necessary.\n+              let parent_link = self.get_parent_link(new_parent, ident);\n+              child_name_bindings.set_module_kind(Public,\n+                                                  parent_link,\n+                                                  Some(def_id),\n+                                                  TraitModuleKind,\n+                                                  dummy_sp())\n           }\n           def_ty(_) => {\n               debug!(\"(building reduced graph for external \\\n@@ -1750,6 +1802,10 @@ pub impl Resolver {\n                                             // We already have a module. This\n                                             // is OK.\n                                             type_module = module_def;\n+\n+                                            // Mark it as an impl module if\n+                                            // necessary.\n+                                            type_module.kind = ImplModuleKind;\n                                         }\n                                         Some(_) | None => {\n                                             let parent_link =\n@@ -1759,7 +1815,7 @@ pub impl Resolver {\n                                                 Public,\n                                                 parent_link,\n                                                 Some(def),\n-                                                NormalModuleKind,\n+                                                ImplModuleKind,\n                                                 dummy_sp());\n                                             type_module =\n                                                 child_name_bindings.\n@@ -1866,10 +1922,8 @@ pub impl Resolver {\n     // remain or unsuccessfully when no forward progress in resolving imports\n     // is made.\n \n-    /**\n-     * Resolves all imports for the crate. This method performs the fixed-\n-     * point iteration.\n-     */\n+    /// Resolves all imports for the crate. This method performs the fixed-\n+    /// point iteration.\n     fn resolve_imports(@mut self) {\n         let mut i = 0;\n         let mut prev_unresolved_imports = 0;\n@@ -1991,9 +2045,10 @@ pub impl Resolver {\n     /// don't know whether the name exists at the moment due to other\n     /// currently-unresolved imports, or success if we know the name exists.\n     /// If successful, the resolved bindings are written into the module.\n-    fn resolve_import_for_module(@mut self, module_: @mut Module,\n+    fn resolve_import_for_module(@mut self,\n+                                 module_: @mut Module,\n                                  import_directive: @ImportDirective)\n-                              -> ResolveResult<()> {\n+                                 -> ResolveResult<()> {\n         let mut resolution_result = Failed;\n         let module_path = &import_directive.module_path;\n \n@@ -2007,10 +2062,11 @@ pub impl Resolver {\n             // Use the crate root.\n             Some(self.graph_root.get_module())\n         } else {\n-            match self.resolve_module_path_for_import(module_,\n-                                                      *module_path,\n-                                                      DontUseLexicalScope,\n-                                                      import_directive.span) {\n+            match self.resolve_module_path(module_,\n+                                           *module_path,\n+                                           DontUseLexicalScope,\n+                                           import_directive.span,\n+                                           ImportSearch) {\n \n                 Failed => None,\n                 Indeterminate => {\n@@ -2097,7 +2153,7 @@ pub impl Resolver {\n                              target: ident,\n                              source: ident,\n                              span: span)\n-                          -> ResolveResult<()> {\n+                             -> ResolveResult<()> {\n         debug!(\"(resolving single import) resolving `%s` = `%s::%s` from \\\n                 `%s`\",\n                *self.session.str_of(target),\n@@ -2134,9 +2190,7 @@ pub impl Resolver {\n         // Unless we managed to find a result in both namespaces (unlikely),\n         // search imports as well.\n         match (value_result, type_result) {\n-            (BoundResult(*), BoundResult(*)) => {\n-                // Continue.\n-            }\n+            (BoundResult(*), BoundResult(*)) => {} // Continue.\n             _ => {\n                 // If there is an unresolved glob at this point in the\n                 // containing module, bail out. We don't know enough to be\n@@ -2460,7 +2514,6 @@ pub impl Resolver {\n         // Resolve the module part of the path. This does not involve looking\n         // upward though scope chains; we simply resolve names directly in\n         // modules as we go.\n-\n         while index < module_path_len {\n             let name = module_path[index];\n             match self.resolve_name_in_module(search_module,\n@@ -2470,12 +2523,17 @@ pub impl Resolver {\n                 Failed => {\n                     let segment_name = self.session.str_of(name);\n                     let module_name = self.module_to_str(search_module);\n-                    if module_name == ~\"???\" {\n-                        self.session.span_err(span {lo: span.lo, hi: span.lo +\n-                                              BytePos(str::len(*segment_name)), expn_info:\n-                                              span.expn_info}, fmt!(\"unresolved import. maybe \\\n-                                                                    a missing `extern mod %s`?\",\n-                                                                    *segment_name));\n+                    if \"???\" == module_name {\n+                        let span = span {\n+                            lo: span.lo,\n+                            hi: span.lo + BytePos(str::len(*segment_name)),\n+                            expn_info: span.expn_info,\n+                        };\n+                        self.session.span_err(span,\n+                                              fmt!(\"unresolved import. maybe \\\n+                                                    a missing `extern mod \\\n+                                                    %s`?\",\n+                                                    *segment_name));\n                         return Failed;\n                     }\n                     self.session.span_err(span, fmt!(\"unresolved import: could not find `%s` in \\\n@@ -2504,8 +2562,22 @@ pub impl Resolver {\n                                                                     name)));\n                                     return Failed;\n                                 }\n-                                Some(copy module_def) => {\n-                                    search_module = module_def;\n+                                Some(module_def) => {\n+                                    // If we're doing the search for an\n+                                    // import, do not allow traits and impls\n+                                    // to be selected.\n+                                    match (name_search_type,\n+                                           module_def.kind) {\n+                                        (ImportSearch, TraitModuleKind) |\n+                                        (ImportSearch, ImplModuleKind) => {\n+                                            self.session.span_err(\n+                                                span,\n+                                                ~\"cannot import from a trait \\\n+                                                  or type implementation\");\n+                                            return Failed;\n+                                        }\n+                                        (_, _) => search_module = module_def,\n+                                    }\n                                 }\n                             }\n                         }\n@@ -2523,31 +2595,27 @@ pub impl Resolver {\n \n             index += 1;\n \n-            // After the first element of the path, allow searching through\n-            // items and imports unconditionally. This allows things like:\n-            //\n-            // pub mod core {\n-            //     pub use vec;\n-            // }\n+            // After the first element of the path, allow searching only\n+            // through public identifiers.\n             //\n-            // pub mod something_else {\n-            //     use core::vec;\n-            // }\n-\n-            name_search_type = SearchItemsAndPublicImports;\n+            // XXX: Rip this out and move it to the privacy checker.\n+            if name_search_type == PathPublicOrPrivateSearch {\n+                name_search_type = PathPublicOnlySearch\n+            }\n         }\n \n         return Success(search_module);\n     }\n \n     /// Attempts to resolve the module part of an import directive or path\n     /// rooted at the given module.\n-    fn resolve_module_path_for_import(@mut self,\n-                                      module_: @mut Module,\n-                                      module_path: &[ident],\n-                                      use_lexical_scope: UseLexicalScopeFlag,\n-                                      span: span)\n-                                   -> ResolveResult<@mut Module> {\n+    fn resolve_module_path(@mut self,\n+                           module_: @mut Module,\n+                           module_path: &[ident],\n+                           use_lexical_scope: UseLexicalScopeFlag,\n+                           span: span,\n+                           name_search_type: NameSearchType)\n+                           -> ResolveResult<@mut Module> {\n         let module_path_len = module_path.len();\n         assert!(module_path_len > 0);\n \n@@ -2630,7 +2698,7 @@ pub impl Resolver {\n                                            module_path,\n                                            start_index,\n                                            span,\n-                                           SearchItemsAndPublicImports)\n+                                           name_search_type)\n     }\n \n     /// Invariant: This must only be called during main resolution, not during\n@@ -2722,6 +2790,7 @@ pub impl Resolver {\n                                 }\n                                 ExternModuleKind |\n                                 TraitModuleKind |\n+                                ImplModuleKind |\n                                 AnonymousModuleKind => {\n                                     search_module = parent_module_node;\n                                 }\n@@ -2741,7 +2810,7 @@ pub impl Resolver {\n             match self.resolve_name_in_module(search_module,\n                                               name,\n                                               namespace,\n-                                              SearchItemsAndAllImports) {\n+                                              PathPublicOrPrivateSearch) {\n                 Failed => {\n                     // Continue up the search chain.\n                 }\n@@ -2822,6 +2891,7 @@ pub impl Resolver {\n                         NormalModuleKind => return Some(new_module),\n                         ExternModuleKind |\n                         TraitModuleKind |\n+                        ImplModuleKind |\n                         AnonymousModuleKind => module_ = new_module,\n                     }\n                 }\n@@ -2838,7 +2908,10 @@ pub impl Resolver {\n                                              -> @mut Module {\n         match module_.kind {\n             NormalModuleKind => return module_,\n-            ExternModuleKind | TraitModuleKind | AnonymousModuleKind => {\n+            ExternModuleKind |\n+            TraitModuleKind |\n+            ImplModuleKind |\n+            AnonymousModuleKind => {\n                 match self.get_nearest_normal_module_parent(module_) {\n                     None => module_,\n                     Some(new_module) => new_module\n@@ -2922,8 +2995,14 @@ pub impl Resolver {\n \n         // If this is a search of all imports, we should be done with glob\n         // resolution at this point.\n+<<<<<<< HEAD\n         if name_search_type == SearchItemsAndAllImports {\n             assert_eq!(module_.glob_count, 0);\n+=======\n+        if name_search_type == PathPublicOrPrivateSearch ||\n+                name_search_type == PathPublicOnlySearch {\n+            assert!(module_.glob_count == 0);\n+>>>>>>> librustc: Disallow `use` from reaching into impls or traits.\n         }\n \n         // Check the list of resolved imports.\n@@ -2944,7 +3023,7 @@ pub impl Resolver {\n                     }\n                     Some(target)\n                             if name_search_type ==\n-                                SearchItemsAndAllImports ||\n+                                PathPublicOrPrivateSearch ||\n                             import_resolution.privacy == Public => {\n                         debug!(\"(resolving name in module) resolved to \\\n                                 import\");\n@@ -4483,10 +4562,11 @@ pub impl Resolver {\n         let module_path_idents = self.intern_module_part_of_path(path);\n \n         let containing_module;\n-        match self.resolve_module_path_for_import(self.current_module,\n-                                                  module_path_idents,\n-                                                  UseLexicalScope,\n-                                                  path.span) {\n+        match self.resolve_module_path(self.current_module,\n+                                       module_path_idents,\n+                                       UseLexicalScope,\n+                                       path.span,\n+                                       PathPublicOnlySearch) {\n             Failed => {\n                 self.session.span_err(path.span,\n                                       fmt!(\"use of undeclared module `%s`\",\n@@ -4535,7 +4615,7 @@ pub impl Resolver {\n                                                  module_path_idents,\n                                                  0,\n                                                  path.span,\n-                                                 SearchItemsAndAllImports) {\n+                                                 PathPublicOrPrivateSearch) {\n             Failed => {\n                 self.session.span_err(path.span,\n                                       fmt!(\"use of undeclared module `::%s`\","}, {"sha": "19dc973a4a150b983c71ea2ef65064743edfa85c", "filename": "src/librustpkg/rustpkg.rc", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/ca9bb2d9ace2bf085dc276e241f6707e0402093f/src%2Flibrustpkg%2Frustpkg.rc", "raw_url": "https://github.com/rust-lang/rust/raw/ca9bb2d9ace2bf085dc276e241f6707e0402093f/src%2Flibrustpkg%2Frustpkg.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Frustpkg.rc?ref=ca9bb2d9ace2bf085dc276e241f6707e0402093f", "patch": "@@ -602,22 +602,25 @@ impl PkgSrc {\n     /// Infers crates to build. Called only in the case where there\n     /// is no custom build logic\n     fn find_crates(&mut self) {\n-        use PkgSrc::push_crate;\n         use conditions::missing_pkg_files::cond;\n \n         let dir = self.check_dir();\n         let prefix = dir.components.len();\n         debug!(\"Matching against %?\", self.id.local_path.filestem());\n         for os::walk_dir(&dir) |pth| {\n             match pth.filename() {\n-                Some(~\"lib.rs\") => push_crate(&mut self.libs,\n-                                              prefix, pth),\n-                Some(~\"main.rs\") => push_crate(&mut self.mains,\n-                                               prefix, pth),\n-                Some(~\"test.rs\") => push_crate(&mut self.tests,\n-                                               prefix, pth),\n-                Some(~\"bench.rs\") => push_crate(&mut self.benchs,\n-                                                prefix, pth),\n+                Some(~\"lib.rs\") => PkgSrc::push_crate(&mut self.libs,\n+                                                      prefix,\n+                                                      pth),\n+                Some(~\"main.rs\") => PkgSrc::push_crate(&mut self.mains,\n+                                                       prefix,\n+                                                       pth),\n+                Some(~\"test.rs\") => PkgSrc::push_crate(&mut self.tests,\n+                                                       prefix,\n+                                                       pth),\n+                Some(~\"bench.rs\") => PkgSrc::push_crate(&mut self.benchs,\n+                                                        prefix,\n+                                                        pth),\n                 _ => ()\n             }\n         }"}, {"sha": "2ab95c271aec7de825967a08d445d5974cdc16e9", "filename": "src/test/auxiliary/use_from_trait_xc.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ca9bb2d9ace2bf085dc276e241f6707e0402093f/src%2Ftest%2Fauxiliary%2Fuse_from_trait_xc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca9bb2d9ace2bf085dc276e241f6707e0402093f/src%2Ftest%2Fauxiliary%2Fuse_from_trait_xc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fuse_from_trait_xc.rs?ref=ca9bb2d9ace2bf085dc276e241f6707e0402093f", "patch": "@@ -0,0 +1,10 @@\n+pub trait Trait {\n+    fn foo();\n+}\n+\n+struct Foo;\n+\n+impl Foo {\n+    pub fn new() {}\n+}\n+"}, {"sha": "56805f58ad29ac36b43d611b7e9f5c0488700cbe", "filename": "src/test/compile-fail/use-from-trait-xc.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ca9bb2d9ace2bf085dc276e241f6707e0402093f/src%2Ftest%2Fcompile-fail%2Fuse-from-trait-xc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca9bb2d9ace2bf085dc276e241f6707e0402093f/src%2Ftest%2Fcompile-fail%2Fuse-from-trait-xc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fuse-from-trait-xc.rs?ref=ca9bb2d9ace2bf085dc276e241f6707e0402093f", "patch": "@@ -0,0 +1,12 @@\n+// aux-build:use_from_trait_xc.rs\n+\n+extern mod use_from_trait_xc;\n+\n+use use_from_trait_xc::Trait::foo;  //~ ERROR cannot import from a trait or type implementation\n+//~^ ERROR failed to resolve import\n+use use_from_trait_xc::Foo::new;    //~ ERROR cannot import from a trait or type implementation\n+//~^ ERROR failed to resolve import\n+\n+fn main() {\n+}\n+"}, {"sha": "10a30f0a266b3734aabe5a43fc064c5d2a8e8bf7", "filename": "src/test/compile-fail/use-from-trait.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/ca9bb2d9ace2bf085dc276e241f6707e0402093f/src%2Ftest%2Fcompile-fail%2Fuse-from-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca9bb2d9ace2bf085dc276e241f6707e0402093f/src%2Ftest%2Fcompile-fail%2Fuse-from-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fuse-from-trait.rs?ref=ca9bb2d9ace2bf085dc276e241f6707e0402093f", "patch": "@@ -0,0 +1,17 @@\n+use Trait::foo;  //~ ERROR cannot import from a trait or type implementation\n+//~^ ERROR failed to resolve import\n+use Foo::new;    //~ ERROR cannot import from a trait or type implementation\n+//~^ ERROR failed to resolve import\n+\n+pub trait Trait {\n+    fn foo();\n+}\n+\n+struct Foo;\n+\n+impl Foo {\n+    fn new() {}\n+}\n+\n+fn main() {}\n+"}]}