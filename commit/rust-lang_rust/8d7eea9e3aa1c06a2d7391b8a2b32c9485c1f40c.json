{"sha": "8d7eea9e3aa1c06a2d7391b8a2b32c9485c1f40c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhkN2VlYTllM2FhMWMwNmEyZDczOTFiOGEyYjMyYzk0ODVjMWY0MGM=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-08-17T13:25:08Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-08-17T13:25:08Z"}, "message": "Merge #9929\n\n9929: fix: Handle all rename special cases for record pattern fields r=Veykril a=Veykril\n\n\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>", "tree": {"sha": "4589687d89770495a63eadc194fa6f399857f9b9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4589687d89770495a63eadc194fa6f399857f9b9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8d7eea9e3aa1c06a2d7391b8a2b32c9485c1f40c", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJhG7i0CRBK7hj4Ov3rIwAAqw4IAGPM1nlYNyTTr/ZrgTJ2BFZG\nrYnFMJF9tvSvlAqfG6UumZhz2FR7h2/fKCpr23TUXQmMhBZ3pC5xZgrsNWsApBBH\ndaZ13PEAZ1u0MiGGbU8zrsGgUoEefETrQIqR4zwY4bOUL9jhQWEmC2scfX3TSLOU\nLOjiGdDnBq0F/8lbTtr0bgG13nvyLTqDppydyCJo98PGDQ8xy2CtB35SCjjNfXKr\nMjCF5HxmUbCjJrIlWTydQuTeX0NF/cHSpO+f/HsNfPPV9vymRAMrKOaTj9HVh5dV\nhdDWTe8vdu/HdOw09u48FNaNomXnEa6a+pYmqbidzWVOAw1HZfLL8zgT41DviMw=\n=5Ncs\n-----END PGP SIGNATURE-----\n", "payload": "tree 4589687d89770495a63eadc194fa6f399857f9b9\nparent dcbaa75bc14c69ab060bffe9b108cb55b325b121\nparent daf3094958cbf69b0e179a0c7320ad8ef63fe347\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1629206708 +0000\ncommitter GitHub <noreply@github.com> 1629206708 +0000\n\nMerge #9929\n\n9929: fix: Handle all rename special cases for record pattern fields r=Veykril a=Veykril\n\n\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8d7eea9e3aa1c06a2d7391b8a2b32c9485c1f40c", "html_url": "https://github.com/rust-lang/rust/commit/8d7eea9e3aa1c06a2d7391b8a2b32c9485c1f40c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8d7eea9e3aa1c06a2d7391b8a2b32c9485c1f40c/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dcbaa75bc14c69ab060bffe9b108cb55b325b121", "url": "https://api.github.com/repos/rust-lang/rust/commits/dcbaa75bc14c69ab060bffe9b108cb55b325b121", "html_url": "https://github.com/rust-lang/rust/commit/dcbaa75bc14c69ab060bffe9b108cb55b325b121"}, {"sha": "daf3094958cbf69b0e179a0c7320ad8ef63fe347", "url": "https://api.github.com/repos/rust-lang/rust/commits/daf3094958cbf69b0e179a0c7320ad8ef63fe347", "html_url": "https://github.com/rust-lang/rust/commit/daf3094958cbf69b0e179a0c7320ad8ef63fe347"}], "stats": {"total": 243, "additions": 178, "deletions": 65}, "files": [{"sha": "9d452f40baee509588932e0183ea24041cca03f4", "filename": "crates/ide/src/rename.rs", "status": "modified", "additions": 67, "deletions": 3, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/8d7eea9e3aa1c06a2d7391b8a2b32c9485c1f40c/crates%2Fide%2Fsrc%2Frename.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d7eea9e3aa1c06a2d7391b8a2b32c9485c1f40c/crates%2Fide%2Fsrc%2Frename.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Frename.rs?ref=8d7eea9e3aa1c06a2d7391b8a2b32c9485c1f40c", "patch": "@@ -274,6 +274,7 @@ mod tests {\n \n     use super::{RangeInfo, RenameError};\n \n+    #[track_caller]\n     fn check(new_name: &str, ra_fixture_before: &str, ra_fixture_after: &str) {\n         let ra_fixture_after = &trim_indent(ra_fixture_after);\n         let (analysis, position) = fixture::position(ra_fixture_before);\n@@ -1332,9 +1333,71 @@ fn foo(foo: Foo) {\n struct Foo { baz: i32 }\n \n fn foo(foo: Foo) {\n-    let Foo { ref baz @ qux } = foo;\n+    let Foo { baz: ref baz @ qux } = foo;\n     let _ = qux;\n }\n+\"#,\n+        );\n+        check(\n+            \"baz\",\n+            r#\"\n+struct Foo { i$0: i32 }\n+\n+fn foo(foo: Foo) {\n+    let Foo { i: ref baz } = foo;\n+    let _ = qux;\n+}\n+\"#,\n+            r#\"\n+struct Foo { baz: i32 }\n+\n+fn foo(foo: Foo) {\n+    let Foo { ref baz } = foo;\n+    let _ = qux;\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_struct_local_pat_into_shorthand() {\n+        cov_mark::check!(test_rename_local_put_init_shorthand_pat);\n+        check(\n+            \"field\",\n+            r#\"\n+struct Foo { field: i32 }\n+\n+fn foo(foo: Foo) {\n+    let Foo { field: qux$0 } = foo;\n+    let _ = qux;\n+}\n+\"#,\n+            r#\"\n+struct Foo { field: i32 }\n+\n+fn foo(foo: Foo) {\n+    let Foo { field } = foo;\n+    let _ = field;\n+}\n+\"#,\n+        );\n+        check(\n+            \"field\",\n+            r#\"\n+struct Foo { field: i32 }\n+\n+fn foo(foo: Foo) {\n+    let Foo { field: x @ qux$0 } = foo;\n+    let _ = qux;\n+}\n+\"#,\n+            r#\"\n+struct Foo { field: i32 }\n+\n+fn foo(foo: Foo) {\n+    let Foo { field: x @ field } = foo;\n+    let _ = field;\n+}\n \"#,\n         );\n     }\n@@ -1390,7 +1453,7 @@ struct Foo {\n     i: i32\n }\n \n-fn foo(Foo { i }: foo) -> i32 {\n+fn foo(Foo { i }: Foo) -> i32 {\n     i$0\n }\n \"#,\n@@ -1399,7 +1462,7 @@ struct Foo {\n     i: i32\n }\n \n-fn foo(Foo { i: bar }: foo) -> i32 {\n+fn foo(Foo { i: bar }: Foo) -> i32 {\n     bar\n }\n \"#,\n@@ -1408,6 +1471,7 @@ fn foo(Foo { i: bar }: foo) -> i32 {\n \n     #[test]\n     fn test_struct_field_complex_ident_pat() {\n+        cov_mark::check!(rename_record_pat_field_name_split);\n         check(\n             \"baz\",\n             r#\""}, {"sha": "a672c1091740eda50db145d38fb7c0491ef30887", "filename": "crates/ide_db/src/helpers/import_assets.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8d7eea9e3aa1c06a2d7391b8a2b32c9485c1f40c/crates%2Fide_db%2Fsrc%2Fhelpers%2Fimport_assets.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d7eea9e3aa1c06a2d7391b8a2b32c9485c1f40c/crates%2Fide_db%2Fsrc%2Fhelpers%2Fimport_assets.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fhelpers%2Fimport_assets.rs?ref=8d7eea9e3aa1c06a2d7391b8a2b32c9485c1f40c", "patch": "@@ -120,11 +120,11 @@ impl ImportAssets {\n     }\n \n     pub fn for_ident_pat(pat: &ast::IdentPat, sema: &Semantics<RootDatabase>) -> Option<Self> {\n-        let name = pat.name()?;\n-        let candidate_node = pat.syntax().clone();\n         if !pat.is_simple_ident() {\n             return None;\n         }\n+        let name = pat.name()?;\n+        let candidate_node = pat.syntax().clone();\n         Some(Self {\n             import_candidate: ImportCandidate::for_name(sema, &name)?,\n             module_with_candidate: sema.scope(&candidate_node).module()?,"}, {"sha": "ef8b31ba5fa78c2bedfeaa9f000c3e9b2c892deb", "filename": "crates/ide_db/src/rename.rs", "status": "modified", "additions": 106, "deletions": 60, "changes": 166, "blob_url": "https://github.com/rust-lang/rust/blob/8d7eea9e3aa1c06a2d7391b8a2b32c9485c1f40c/crates%2Fide_db%2Fsrc%2Frename.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d7eea9e3aa1c06a2d7391b8a2b32c9485c1f40c/crates%2Fide_db%2Fsrc%2Frename.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Frename.rs?ref=8d7eea9e3aa1c06a2d7391b8a2b32c9485c1f40c", "patch": "@@ -30,7 +30,7 @@ use syntax::{\n     ast::{self, NameOwner},\n     lex_single_syntax_kind, AstNode, SyntaxKind, TextRange, T,\n };\n-use text_edit::TextEdit;\n+use text_edit::{TextEdit, TextEditBuilder};\n \n use crate::{\n     defs::Definition,\n@@ -303,141 +303,187 @@ pub fn source_edit_from_references(\n ) -> TextEdit {\n     let mut edit = TextEdit::builder();\n     for reference in references {\n-        let (range, replacement) = match &reference.name {\n+        let has_emitted_edit = match &reference.name {\n             // if the ranges differ then the node is inside a macro call, we can't really attempt\n             // to make special rewrites like shorthand syntax and such, so just rename the node in\n             // the macro input\n             ast::NameLike::NameRef(name_ref)\n                 if name_ref.syntax().text_range() == reference.range =>\n             {\n-                source_edit_from_name_ref(name_ref, new_name, def)\n+                source_edit_from_name_ref(&mut edit, name_ref, new_name, def)\n             }\n             ast::NameLike::Name(name) if name.syntax().text_range() == reference.range => {\n-                source_edit_from_name(name, new_name)\n+                source_edit_from_name(&mut edit, name, new_name)\n             }\n-            _ => None,\n+            _ => false,\n+        };\n+        if !has_emitted_edit {\n+            edit.replace(reference.range, new_name.to_string());\n         }\n-        .unwrap_or_else(|| (reference.range, new_name.to_string()));\n-        edit.replace(range, replacement);\n     }\n+\n     edit.finish()\n }\n \n-fn source_edit_from_name(name: &ast::Name, new_name: &str) -> Option<(TextRange, String)> {\n+fn source_edit_from_name(edit: &mut TextEditBuilder, name: &ast::Name, new_name: &str) -> bool {\n     if let Some(_) = ast::RecordPatField::for_field_name(name) {\n-        // FIXME: instead of splitting the shorthand, recursively trigger a rename of the\n-        // other name https://github.com/rust-analyzer/rust-analyzer/issues/6547\n         if let Some(ident_pat) = name.syntax().parent().and_then(ast::IdentPat::cast) {\n-            return Some((\n-                TextRange::empty(ident_pat.syntax().text_range().start()),\n-                [new_name, \": \"].concat(),\n-            ));\n+            cov_mark::hit!(rename_record_pat_field_name_split);\n+            // Foo { ref mut field } -> Foo { new_name: ref mut field }\n+            //      ^ insert `new_name: `\n+\n+            // FIXME: instead of splitting the shorthand, recursively trigger a rename of the\n+            // other name https://github.com/rust-analyzer/rust-analyzer/issues/6547\n+            edit.insert(ident_pat.syntax().text_range().start(), format!(\"{}: \", new_name));\n+            return true;\n         }\n     }\n-    None\n+\n+    false\n }\n \n fn source_edit_from_name_ref(\n+    edit: &mut TextEditBuilder,\n     name_ref: &ast::NameRef,\n     new_name: &str,\n     def: Definition,\n-) -> Option<(TextRange, String)> {\n+) -> bool {\n     if let Some(record_field) = ast::RecordExprField::for_name_ref(name_ref) {\n         let rcf_name_ref = record_field.name_ref();\n         let rcf_expr = record_field.expr();\n-        match (rcf_name_ref, rcf_expr.and_then(|it| it.name_ref())) {\n+        match &(rcf_name_ref, rcf_expr.and_then(|it| it.name_ref())) {\n             // field: init-expr, check if we can use a field init shorthand\n             (Some(field_name), Some(init)) => {\n-                if field_name == *name_ref {\n+                if field_name == name_ref {\n                     if init.text() == new_name {\n                         cov_mark::hit!(test_rename_field_put_init_shorthand);\n+                        // Foo { field: local } -> Foo { local }\n+                        //       ^^^^^^^ delete this\n+\n                         // same names, we can use a shorthand here instead.\n                         // we do not want to erase attributes hence this range start\n                         let s = field_name.syntax().text_range().start();\n-                        let e = record_field.syntax().text_range().end();\n-                        return Some((TextRange::new(s, e), new_name.to_owned()));\n+                        let e = init.syntax().text_range().start();\n+                        edit.delete(TextRange::new(s, e));\n+                        return true;\n                     }\n-                } else if init == *name_ref {\n+                } else if init == name_ref {\n                     if field_name.text() == new_name {\n                         cov_mark::hit!(test_rename_local_put_init_shorthand);\n+                        // Foo { field: local } -> Foo { field }\n+                        //            ^^^^^^^ delete this\n+\n                         // same names, we can use a shorthand here instead.\n                         // we do not want to erase attributes hence this range start\n-                        let s = field_name.syntax().text_range().start();\n-                        let e = record_field.syntax().text_range().end();\n-                        return Some((TextRange::new(s, e), new_name.to_owned()));\n+                        let s = field_name.syntax().text_range().end();\n+                        let e = init.syntax().text_range().end();\n+                        edit.delete(TextRange::new(s, e));\n+                        return true;\n                     }\n                 }\n-                None\n             }\n             // init shorthand\n             (None, Some(_)) if matches!(def, Definition::Field(_)) => {\n                 cov_mark::hit!(test_rename_field_in_field_shorthand);\n-                let s = name_ref.syntax().text_range().start();\n-                Some((TextRange::empty(s), format!(\"{}: \", new_name)))\n+                // Foo { field } -> Foo { new_name: field }\n+                //       ^ insert `new_name: `\n+                let offset = name_ref.syntax().text_range().start();\n+                edit.insert(offset, format!(\"{}: \", new_name));\n+                return true;\n             }\n             (None, Some(_)) if matches!(def, Definition::Local(_)) => {\n                 cov_mark::hit!(test_rename_local_in_field_shorthand);\n-                let s = name_ref.syntax().text_range().end();\n-                Some((TextRange::empty(s), format!(\": {}\", new_name)))\n+                // Foo { field } -> Foo { field: new_name }\n+                //            ^ insert `: new_name`\n+                let offset = name_ref.syntax().text_range().end();\n+                edit.insert(offset, format!(\": {}\", new_name));\n+                return true;\n             }\n-            _ => None,\n+            _ => (),\n         }\n     } else if let Some(record_field) = ast::RecordPatField::for_field_name_ref(name_ref) {\n         let rcf_name_ref = record_field.name_ref();\n         let rcf_pat = record_field.pat();\n         match (rcf_name_ref, rcf_pat) {\n             // field: rename\n-            (Some(field_name), Some(ast::Pat::IdentPat(pat))) if field_name == *name_ref => {\n+            (Some(field_name), Some(ast::Pat::IdentPat(pat)))\n+                if field_name == *name_ref && pat.at_token().is_none() =>\n+            {\n                 // field name is being renamed\n-                if pat.name().map_or(false, |it| it.text() == new_name) {\n-                    cov_mark::hit!(test_rename_field_put_init_shorthand_pat);\n-                    // same names, we can use a shorthand here instead/\n-                    // we do not want to erase attributes hence this range start\n-                    let s = field_name.syntax().text_range().start();\n-                    let e = record_field.syntax().text_range().end();\n-                    Some((TextRange::new(s, e), pat.to_string()))\n-                } else {\n-                    None\n+                if let Some(name) = pat.name() {\n+                    if name.text() == new_name {\n+                        cov_mark::hit!(test_rename_field_put_init_shorthand_pat);\n+                        // Foo { field: ref mut local } -> Foo { ref mut field }\n+                        //       ^^^^^^^ delete this\n+                        //                      ^^^^^ replace this with `field`\n+\n+                        // same names, we can use a shorthand here instead/\n+                        // we do not want to erase attributes hence this range start\n+                        let s = field_name.syntax().text_range().start();\n+                        let e = pat.syntax().text_range().start();\n+                        edit.delete(TextRange::new(s, e));\n+                        edit.replace(name.syntax().text_range(), new_name.to_string());\n+                        return true;\n+                    }\n                 }\n             }\n-            _ => None,\n+            _ => (),\n         }\n-    } else {\n-        None\n     }\n+    false\n }\n \n fn source_edit_from_def(\n     sema: &Semantics<RootDatabase>,\n     def: Definition,\n     new_name: &str,\n ) -> Result<(FileId, TextEdit)> {\n-    let frange = def\n+    let FileRange { file_id, range } = def\n         .range_for_rename(sema)\n         .ok_or_else(|| format_err!(\"No identifier available to rename\"))?;\n \n-    let mut replacement_text = String::new();\n-    let mut repl_range = frange.range;\n+    let mut edit = TextEdit::builder();\n     if let Definition::Local(local) = def {\n         if let Either::Left(pat) = local.source(sema.db).value {\n-            if matches!(\n-                pat.syntax().parent().and_then(ast::RecordPatField::cast),\n-                Some(pat_field) if pat_field.name_ref().is_none()\n-            ) {\n-                replacement_text.push_str(\": \");\n-                replacement_text.push_str(new_name);\n-                repl_range = TextRange::new(\n-                    pat.syntax().text_range().end(),\n-                    pat.syntax().text_range().end(),\n-                );\n+            // special cases required for renaming fields/locals in Record patterns\n+            if let Some(pat_field) = pat.syntax().parent().and_then(ast::RecordPatField::cast) {\n+                let name_range = pat.name().unwrap().syntax().text_range();\n+                if let Some(name_ref) = pat_field.name_ref() {\n+                    if new_name == name_ref.text() && pat.at_token().is_none() {\n+                        // Foo { field: ref mut local } -> Foo { ref mut field }\n+                        //       ^^^^^^ delete this\n+                        //                      ^^^^^ replace this with `field`\n+                        cov_mark::hit!(test_rename_local_put_init_shorthand_pat);\n+                        edit.delete(\n+                            name_ref\n+                                .syntax()\n+                                .text_range()\n+                                .cover_offset(pat.syntax().text_range().start()),\n+                        );\n+                        edit.replace(name_range, name_ref.text().to_string());\n+                    } else {\n+                        // Foo { field: ref mut local @ local 2} -> Foo { field: ref mut new_name @ local2 }\n+                        // Foo { field: ref mut local } -> Foo { field: ref mut new_name }\n+                        //                      ^^^^^ replace this with `new_name`\n+                        edit.replace(name_range, new_name.to_string());\n+                    }\n+                } else {\n+                    // Foo { ref mut field } -> Foo { field: ref mut new_name }\n+                    //      ^ insert `field: `\n+                    //               ^^^^^ replace this with `new_name`\n+                    edit.insert(\n+                        pat.syntax().text_range().start(),\n+                        format!(\"{}: \", pat_field.field_name().unwrap()),\n+                    );\n+                    edit.replace(name_range, new_name.to_string());\n+                }\n             }\n         }\n     }\n-    if replacement_text.is_empty() {\n-        replacement_text.push_str(new_name);\n+    if edit.is_empty() {\n+        edit.replace(range, new_name.to_string());\n     }\n-    let edit = TextEdit::replace(repl_range, replacement_text);\n-    Ok((frange.file_id, edit))\n+    Ok((file_id, edit.finish()))\n }\n \n #[derive(Copy, Clone, Debug, PartialEq)]"}, {"sha": "a43ffe202ffcc753c837223b2fd3f6780ff89808", "filename": "crates/text_edit/src/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8d7eea9e3aa1c06a2d7391b8a2b32c9485c1f40c/crates%2Ftext_edit%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d7eea9e3aa1c06a2d7391b8a2b32c9485c1f40c/crates%2Ftext_edit%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Ftext_edit%2Fsrc%2Flib.rs?ref=8d7eea9e3aa1c06a2d7391b8a2b32c9485c1f40c", "patch": "@@ -159,6 +159,9 @@ impl<'a> IntoIterator for &'a TextEdit {\n }\n \n impl TextEditBuilder {\n+    pub fn is_empty(&self) -> bool {\n+        self.indels.is_empty()\n+    }\n     pub fn replace(&mut self, range: TextRange, replace_with: String) {\n         self.indel(Indel::replace(range, replace_with))\n     }"}]}