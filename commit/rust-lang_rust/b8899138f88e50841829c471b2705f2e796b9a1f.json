{"sha": "b8899138f88e50841829c471b2705f2e796b9a1f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI4ODk5MTM4Zjg4ZTUwODQxODI5YzQ3MWIyNzA1ZjJlNzk2YjlhMWY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-03-21T14:06:54Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-03-21T14:06:54Z"}, "message": "auto merge of #5466 : Kimundi/rust/view-slice-rename, r=bstrie\n\nA slice now always refers to something that returns an borrowed pointer, views don't exist anymore. If you want to have an explictit copy of a slice, use `to_owned()`", "tree": {"sha": "5997e6dc0d2eebe56179771e1a58f0acd7895f1a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5997e6dc0d2eebe56179771e1a58f0acd7895f1a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b8899138f88e50841829c471b2705f2e796b9a1f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b8899138f88e50841829c471b2705f2e796b9a1f", "html_url": "https://github.com/rust-lang/rust/commit/b8899138f88e50841829c471b2705f2e796b9a1f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b8899138f88e50841829c471b2705f2e796b9a1f/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0b4f2687cec898e52c47d1d93fb6317f2f4b468b", "url": "https://api.github.com/repos/rust-lang/rust/commits/0b4f2687cec898e52c47d1d93fb6317f2f4b468b", "html_url": "https://github.com/rust-lang/rust/commit/0b4f2687cec898e52c47d1d93fb6317f2f4b468b"}, {"sha": "9d9a209e9a61414cdf9c8065d445ce353d6ed45f", "url": "https://api.github.com/repos/rust-lang/rust/commits/9d9a209e9a61414cdf9c8065d445ce353d6ed45f", "html_url": "https://github.com/rust-lang/rust/commit/9d9a209e9a61414cdf9c8065d445ce353d6ed45f"}], "stats": {"total": 312, "additions": 151, "deletions": 161}, "files": [{"sha": "63b5c64c6d4a62dda6608c5107d76795162cb56e", "filename": "src/compiletest/errors.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b8899138f88e50841829c471b2705f2e796b9a1f/src%2Fcompiletest%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8899138f88e50841829c471b2705f2e796b9a1f/src%2Fcompiletest%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Ferrors.rs?ref=b8899138f88e50841829c471b2705f2e796b9a1f", "patch": "@@ -51,11 +51,11 @@ fn parse_expected(line_num: uint, line: ~str) -> ~[ExpectedError] {\n         while idx < len && line[idx] == (' ' as u8) { idx += 1u; }\n         let start_kind = idx;\n         while idx < len && line[idx] != (' ' as u8) { idx += 1u; }\n-        let kind = str::to_lower(str::slice(line, start_kind, idx));\n+        let kind = str::to_lower(str::slice(line, start_kind, idx).to_owned());\n \n         // Extract msg:\n         while idx < len && line[idx] == (' ' as u8) { idx += 1u; }\n-        let msg = str::slice(line, idx, len);\n+        let msg = str::slice(line, idx, len).to_owned();\n \n         debug!(\"line=%u kind=%s msg=%s\", line_num - adjust_line, kind, msg);\n "}, {"sha": "a039aaf56835a9511805dbe28983f56c6d2e1105", "filename": "src/compiletest/header.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b8899138f88e50841829c471b2705f2e796b9a1f/src%2Fcompiletest%2Fheader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8899138f88e50841829c471b2705f2e796b9a1f/src%2Fcompiletest%2Fheader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fheader.rs?ref=b8899138f88e50841829c471b2705f2e796b9a1f", "patch": "@@ -175,7 +175,7 @@ fn parse_name_value_directive(line: ~str,\n         match str::find_str(line, keycolon) {\n             Some(colon) => {\n                 let value = str::slice(line, colon + str::len(keycolon),\n-                                       str::len(line));\n+                                       str::len(line)).to_owned();\n                 debug!(\"%s: %s\", directive,  value);\n                 Some(value)\n             }"}, {"sha": "28e57a354c8beb9b98e8831c7ec6174044420f6c", "filename": "src/libcore/num/strconv.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b8899138f88e50841829c471b2705f2e796b9a1f/src%2Flibcore%2Fnum%2Fstrconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8899138f88e50841829c471b2705f2e796b9a1f/src%2Flibcore%2Fnum%2Fstrconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fstrconv.rs?ref=b8899138f88e50841829c471b2705f2e796b9a1f", "patch": "@@ -364,14 +364,14 @@ pub pure fn to_str_bytes_common<T:NumCast+Zero+One+Eq+Ord+NumStrConv+Copy+\n \n             // only resize buf if we actually remove digits\n             if i < buf_max_i {\n-                buf = buf.slice(0, i + 1);\n+                buf = buf.slice(0, i + 1).to_owned();\n             }\n         }\n     } // If exact and trailing '.', just cut that\n     else {\n         let max_i = buf.len() - 1;\n         if buf[max_i] == '.' as u8 {\n-            buf = buf.slice(0, max_i);\n+            buf = buf.slice(0, max_i).to_owned();\n         }\n     }\n \n@@ -606,7 +606,7 @@ pub pure fn from_str_bytes_common<T:NumCast+Zero+One+Ord+Copy+Div<T,T>+\n         // parse remaining bytes as decimal integer,\n         // skipping the exponent char\n         let exp: Option<int> = from_str_bytes_common(\n-            buf.view(i+1, len), 10, true, false, false, ExpNone, false);\n+            buf.slice(i+1, len), 10, true, false, false, ExpNone, false);\n \n         match exp {\n             Some(exp_pow) => {"}, {"sha": "bc6d6b507b202b64095457a57e9d18187b309bd4", "filename": "src/libcore/path.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b8899138f88e50841829c471b2705f2e796b9a1f/src%2Flibcore%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8899138f88e50841829c471b2705f2e796b9a1f/src%2Flibcore%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpath.rs?ref=b8899138f88e50841829c471b2705f2e796b9a1f", "patch": "@@ -410,7 +410,7 @@ impl GenericPath for PosixPath {\n           None => None,\n           Some(ref f) => {\n             match str::rfind_char(*f, '.') {\n-              Some(p) => Some(f.slice(0, p)),\n+              Some(p) => Some(f.slice(0, p).to_owned()),\n               None => Some(copy *f)\n             }\n           }\n@@ -422,7 +422,7 @@ impl GenericPath for PosixPath {\n           None => None,\n           Some(ref f) => {\n             match str::rfind_char(*f, '.') {\n-              Some(p) if p < f.len() => Some(f.slice(p, f.len())),\n+              Some(p) if p < f.len() => Some(f.slice(p, f.len()).to_owned()),\n               _ => None\n             }\n           }\n@@ -622,7 +622,7 @@ impl GenericPath for WindowsPath {\n           None => None,\n           Some(ref f) => {\n             match str::rfind_char(*f, '.') {\n-              Some(p) => Some(f.slice(0, p)),\n+              Some(p) => Some(f.slice(0, p).to_owned()),\n               None => Some(copy *f)\n             }\n           }\n@@ -634,7 +634,7 @@ impl GenericPath for WindowsPath {\n           None => None,\n           Some(ref f) => {\n             match str::rfind_char(*f, '.') {\n-              Some(p) if p < f.len() => Some(f.slice(p, f.len())),\n+              Some(p) if p < f.len() => Some(f.slice(p, f.len()).to_owned()),\n               _ => None\n             }\n           }\n@@ -842,8 +842,8 @@ pub mod windows {\n             let mut i = 2;\n             while i < s.len() {\n                 if is_sep(s[i]) {\n-                    let pre = s.slice(2, i);\n-                    let mut rest = s.slice(i, s.len());\n+                    let pre = s.slice(2, i).to_owned();\n+                    let mut rest = s.slice(i, s.len()).to_owned();\n                     return Some((pre, rest));\n                 }\n                 i += 1;\n@@ -860,9 +860,9 @@ pub mod windows {\n                 let rest = if s.len() == 2 {\n                     ~\"\"\n                 } else {\n-                    s.slice(2, s.len())\n+                    s.slice(2, s.len()).to_owned()\n                 };\n-                return Some((s.slice(0,1), rest));\n+                return Some((s.slice(0,1).to_owned(), rest));\n             }\n             None\n         }"}, {"sha": "e57d0f51870efe3b6854f72e25168fb69f561984", "filename": "src/libcore/rt/uv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b8899138f88e50841829c471b2705f2e796b9a1f/src%2Flibcore%2Frt%2Fuv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8899138f88e50841829c471b2705f2e796b9a1f/src%2Flibcore%2Frt%2Fuv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fuv.rs?ref=b8899138f88e50841829c471b2705f2e796b9a1f", "patch": "@@ -878,7 +878,7 @@ fn listen() {\n                 if status.is_none() {\n                     rtdebug!(\"got %d bytes\", nread);\n                     let buf = buf.unwrap();\n-                    for buf.view(0, nread as uint).each |byte| {\n+                    for buf.slice(0, nread as uint).each |byte| {\n                         fail_unless!(*byte == count as u8);\n                         rtdebug!(\"%u\", *byte as uint);\n                         count += 1;"}, {"sha": "5fbb5e3c2236126faf0d73993f49fb1adbdf5977", "filename": "src/libcore/run.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b8899138f88e50841829c471b2705f2e796b9a1f/src%2Flibcore%2Frun.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8899138f88e50841829c471b2705f2e796b9a1f/src%2Flibcore%2Frun.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frun.rs?ref=b8899138f88e50841829c471b2705f2e796b9a1f", "patch": "@@ -303,7 +303,7 @@ fn read_all(rd: io::Reader) -> ~str {\n         let mut bytes = [0, ..4096];\n         while !rd.eof() {\n             let nread = rd.read(bytes, bytes.len());\n-            wr.write(bytes.view(0, nread));\n+            wr.write(bytes.slice(0, nread));\n         }\n     });\n     str::from_bytes(buf)\n@@ -404,7 +404,7 @@ pub fn readclose(fd: c_int) -> ~str {\n             let mut bytes = [0, ..4096];\n             while !reader.eof() {\n                 let nread = reader.read(bytes, bytes.len());\n-                writer.write(bytes.view(0, nread));\n+                writer.write(bytes.slice(0, nread));\n             }\n         });\n         os::fclose(file);"}, {"sha": "3d704b42a0e07eb55565caf99986f5e82975ab72", "filename": "src/libcore/str.rs", "status": "modified", "additions": 68, "deletions": 80, "changes": 148, "blob_url": "https://github.com/rust-lang/rust/blob/b8899138f88e50841829c471b2705f2e796b9a1f/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8899138f88e50841829c471b2705f2e796b9a1f/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=b8899138f88e50841829c471b2705f2e796b9a1f", "patch": "@@ -50,7 +50,7 @@ pub pure fn from_bytes(vv: &[const u8]) -> ~str {\n \n /// Copy a slice into a new unique str\n pub pure fn from_slice(s: &str) -> ~str {\n-    unsafe { raw::slice_bytes(s, 0, len(s)) }\n+    unsafe { raw::slice_bytes_unique(s, 0, len(s)) }\n }\n \n /**\n@@ -265,7 +265,7 @@ pub fn pop_char(s: &mut ~str) -> char {\n  */\n pub fn shift_char(s: &mut ~str) -> char {\n     let CharRange {ch, next} = char_range_at(*s, 0u);\n-    *s = unsafe { raw::slice_bytes(*s, next, len(*s)) };\n+    *s = unsafe { raw::slice_bytes_unique(*s, next, len(*s)) };\n     return ch;\n }\n \n@@ -279,9 +279,9 @@ pub fn shift_char(s: &mut ~str) -> char {\n  * If the string does not contain any characters\n  */\n #[inline]\n-pub fn view_shift_char(s: &'a str) -> (char, &'a str) {\n+pub fn slice_shift_char(s: &'a str) -> (char, &'a str) {\n     let CharRange {ch, next} = char_range_at(s, 0u);\n-    let next_s = unsafe { raw::view_bytes(s, next, len(s)) };\n+    let next_s = unsafe { raw::slice_bytes(s, next, len(s)) };\n     return (ch, next_s);\n }\n \n@@ -304,7 +304,7 @@ pub pure fn trim_left_chars(s: &str, chars_to_trim: &[char]) -> ~str {\n \n     match find(s, |c| !chars_to_trim.contains(&c)) {\n       None => ~\"\",\n-      Some(first) => unsafe { raw::slice_bytes(s, first, s.len()) }\n+      Some(first) => unsafe { raw::slice_bytes_unique(s, first, s.len()) }\n     }\n }\n \n@@ -324,7 +324,7 @@ pub pure fn trim_right_chars(s: &str, chars_to_trim: &[char]) -> ~str {\n       None => ~\"\",\n       Some(last) => {\n         let next = char_range_at(s, last).next;\n-        unsafe { raw::slice_bytes(s, 0u, next) }\n+        unsafe { raw::slice_bytes_unique(s, 0u, next) }\n       }\n     }\n }\n@@ -346,7 +346,7 @@ pub pure fn trim_chars(s: &str, chars_to_trim: &[char]) -> ~str {\n pub pure fn trim_left(s: &str) -> ~str {\n     match find(s, |c| !char::is_whitespace(c)) {\n       None => ~\"\",\n-      Some(first) => unsafe { raw::slice_bytes(s, first, len(s)) }\n+      Some(first) => unsafe { raw::slice_bytes_unique(s, first, len(s)) }\n     }\n }\n \n@@ -356,7 +356,7 @@ pub pure fn trim_right(s: &str) -> ~str {\n       None => ~\"\",\n       Some(last) => {\n         let next = char_range_at(s, last).next;\n-        unsafe { raw::slice_bytes(s, 0u, next) }\n+        unsafe { raw::slice_bytes_unique(s, 0u, next) }\n       }\n     }\n }\n@@ -408,31 +408,19 @@ pub pure fn chars(s: &str) -> ~[char] {\n  * `begin`.\n  */\n pub pure fn substr(s: &str, begin: uint, n: uint) -> ~str {\n-    slice(s, begin, begin + count_bytes(s, begin, n))\n+    slice(s, begin, begin + count_bytes(s, begin, n)).to_owned()\n }\n \n /**\n  * Returns a slice of the given string from the byte range [`begin`..`end`)\n  *\n- * Fails when `begin` and `end` do not point to valid characters or\n- * beyond the last character of the string\n- */\n-pub pure fn slice(s: &str, begin: uint, end: uint) -> ~str {\n-    fail_unless!(is_char_boundary(s, begin));\n-    fail_unless!(is_char_boundary(s, end));\n-    unsafe { raw::slice_bytes(s, begin, end) }\n-}\n-\n-/**\n- * Returns a view of the given string from the byte range [`begin`..`end`)\n- *\n  * Fails when `begin` and `end` do not point to valid characters or beyond\n  * the last character of the string\n  */\n-pub pure fn view(s: &'a str, begin: uint, end: uint) -> &'a str {\n+pub pure fn slice(s: &'a str, begin: uint, end: uint) -> &'a str {\n     fail_unless!(is_char_boundary(s, begin));\n     fail_unless!(is_char_boundary(s, end));\n-    unsafe { raw::view_bytes(s, begin, end) }\n+    unsafe { raw::slice_bytes(s, begin, end) }\n }\n \n /// Splits a string into substrings at each occurrence of a given character\n@@ -465,7 +453,7 @@ pure fn split_char_inner(s: &str, sep: char, count: uint, allow_empty: bool)\n             if s[i] == b {\n                 if allow_empty || start < i {\n                     unsafe {\n-                        result.push(raw::slice_bytes(s, start, i));\n+                        result.push(raw::slice_bytes_unique(s, start, i));\n                     }\n                 }\n                 start = i + 1u;\n@@ -474,7 +462,7 @@ pure fn split_char_inner(s: &str, sep: char, count: uint, allow_empty: bool)\n             i += 1u;\n         }\n         if allow_empty || start < l {\n-            unsafe { result.push(raw::slice_bytes(s, start, l) ) };\n+            unsafe { result.push(raw::slice_bytes_unique(s, start, l) ) };\n         }\n         result\n     } else {\n@@ -513,7 +501,7 @@ pure fn split_inner(s: &str, sepfn: &fn(cc: char) -> bool, count: uint,\n         if sepfn(ch) {\n             if allow_empty || start < i {\n                 unsafe {\n-                    result.push(raw::slice_bytes(s, start, i));\n+                    result.push(raw::slice_bytes_unique(s, start, i));\n                 }\n             }\n             start = next;\n@@ -523,7 +511,7 @@ pure fn split_inner(s: &str, sepfn: &fn(cc: char) -> bool, count: uint,\n     }\n     if allow_empty || start < l {\n         unsafe {\n-            result.push(raw::slice_bytes(s, start, l));\n+            result.push(raw::slice_bytes_unique(s, start, l));\n         }\n     }\n     result\n@@ -578,7 +566,7 @@ pure fn iter_between_matches(s: &'a str, sep: &'b str, f: &fn(uint, uint)) {\n pub pure fn split_str(s: &'a str, sep: &'b str) -> ~[~str] {\n     let mut result = ~[];\n     do iter_between_matches(s, sep) |from, to| {\n-        unsafe { result.push(raw::slice_bytes(s, from, to)); }\n+        unsafe { result.push(raw::slice_bytes_unique(s, from, to)); }\n     }\n     result\n }\n@@ -587,7 +575,7 @@ pub pure fn split_str_nonempty(s: &'a str, sep: &'b str) -> ~[~str] {\n     let mut result = ~[];\n     do iter_between_matches(s, sep) |from, to| {\n         if to > from {\n-            unsafe { result.push(raw::slice_bytes(s, from, to)); }\n+            unsafe { result.push(raw::slice_bytes_unique(s, from, to)); }\n         }\n     }\n     result\n@@ -721,7 +709,7 @@ pub pure fn replace(s: &str, from: &str, to: &str) -> ~str {\n         } else {\n             unsafe { push_str(&mut result, to); }\n         }\n-        unsafe { push_str(&mut result, raw::slice_bytes(s, start, end)); }\n+        unsafe { push_str(&mut result, raw::slice_bytes_unique(s, start, end)); }\n     }\n     result\n }\n@@ -2135,7 +2123,7 @@ pub mod raw {\n      * If begin is greater than end.\n      * If end is greater than the length of the string.\n      */\n-    pub unsafe fn slice_bytes(s: &str, begin: uint, end: uint) -> ~str {\n+    pub unsafe fn slice_bytes_unique(s: &str, begin: uint, end: uint) -> ~str {\n         do as_buf(s) |sbuf, n| {\n             fail_unless!((begin <= end));\n             fail_unless!((end <= n));\n@@ -2155,7 +2143,7 @@ pub mod raw {\n     }\n \n     /**\n-     * Takes a bytewise (not UTF-8) view from a string.\n+     * Takes a bytewise (not UTF-8) slice from a string.\n      *\n      * Returns the substring from [`begin`..`end`).\n      *\n@@ -2165,7 +2153,7 @@ pub mod raw {\n      * If end is greater than the length of the string.\n      */\n     #[inline]\n-    pub unsafe fn view_bytes(s: &str, begin: uint, end: uint) -> &str {\n+    pub unsafe fn slice_bytes(s: &str, begin: uint, end: uint) -> &str {\n         do as_buf(s) |sbuf, n| {\n              fail_unless!((begin <= end));\n              fail_unless!((end <= n));\n@@ -2207,7 +2195,7 @@ pub mod raw {\n         let len = len(*s);\n         fail_unless!((len > 0u));\n         let b = s[0];\n-        *s = unsafe { raw::slice_bytes(*s, 1u, len) };\n+        *s = unsafe { raw::slice_bytes_unique(*s, 1u, len) };\n         return b;\n     }\n \n@@ -2287,7 +2275,7 @@ pub trait StrSlice {\n     pure fn is_alphanumeric(&self) -> bool;\n     pure fn len(&self) -> uint;\n     pure fn char_len(&self) -> uint;\n-    pure fn slice(&self, begin: uint, end: uint) -> ~str;\n+    pure fn slice(&self, begin: uint, end: uint) -> &'self str;\n     pure fn split(&self, sepfn: &fn(char) -> bool) -> ~[~str];\n     pure fn split_char(&self, sep: char) -> ~[~str];\n     pure fn split_str(&self, sep: &'a str) -> ~[~str];\n@@ -2402,7 +2390,7 @@ impl StrSlice for &'self str {\n      * beyond the last character of the string\n      */\n     #[inline]\n-    pure fn slice(&self, begin: uint, end: uint) -> ~str {\n+    pure fn slice(&self, begin: uint, end: uint) -> &'self str {\n         slice(*self, begin, end)\n     }\n     /// Splits a string into substrings using a character function\n@@ -2460,7 +2448,7 @@ impl StrSlice for &'self str {\n     pure fn trim_right(&self) -> ~str { trim_right(*self) }\n \n     #[inline]\n-    pure fn to_owned(&self) -> ~str { self.slice(0, self.len()) }\n+    pure fn to_owned(&self) -> ~str { from_slice(*self) }\n \n     #[inline]\n     pure fn to_managed(&self) -> @str {\n@@ -2523,8 +2511,8 @@ mod tests {\n \n     #[test]\n     fn test_eq_slice() {\n-        fail_unless!((eq_slice(view(\"foobar\", 0, 3), \"foo\")));\n-        fail_unless!((eq_slice(view(\"barfoo\", 3, 6), \"foo\")));\n+        fail_unless!((eq_slice(slice(\"foobar\", 0, 3), \"foo\")));\n+        fail_unless!((eq_slice(slice(\"barfoo\", 3, 6), \"foo\")));\n         fail_unless!((!eq_slice(\"foo1\", \"foo2\")));\n     }\n \n@@ -2891,25 +2879,24 @@ mod tests {\n \n     #[test]\n     fn test_unsafe_slice() {\n-        unsafe {\n-            fail_unless!(~\"ab\" == raw::slice_bytes(~\"abc\", 0, 2));\n-            fail_unless!(~\"bc\" == raw::slice_bytes(~\"abc\", 1, 3));\n-            fail_unless!(~\"\" == raw::slice_bytes(~\"abc\", 1, 1));\n-            fn a_million_letter_a() -> ~str {\n-                let mut i = 0;\n-                let mut rs = ~\"\";\n-                while i < 100000 { push_str(&mut rs, ~\"aaaaaaaaaa\"); i += 1; }\n-                rs\n-            }\n-            fn half_a_million_letter_a() -> ~str {\n-                let mut i = 0;\n-                let mut rs = ~\"\";\n-                while i < 100000 { push_str(&mut rs, ~\"aaaaa\"); i += 1; }\n-                rs\n-            }\n-            fail_unless!(half_a_million_letter_a() ==\n-                raw::slice_bytes(a_million_letter_a(), 0u, 500000));\n+        fail_unless!(\"ab\" == unsafe {raw::slice_bytes(\"abc\", 0, 2)});\n+        fail_unless!(\"bc\" == unsafe {raw::slice_bytes(\"abc\", 1, 3)});\n+        fail_unless!(\"\" == unsafe {raw::slice_bytes(\"abc\", 1, 1)});\n+        fn a_million_letter_a() -> ~str {\n+            let mut i = 0;\n+            let mut rs = ~\"\";\n+            while i < 100000 { push_str(&mut rs, \"aaaaaaaaaa\"); i += 1; }\n+            rs\n         }\n+        fn half_a_million_letter_a() -> ~str {\n+            let mut i = 0;\n+            let mut rs = ~\"\";\n+            while i < 100000 { push_str(&mut rs, \"aaaaa\"); i += 1; }\n+            rs\n+        }\n+        let letters = a_million_letter_a();\n+        fail_unless!(half_a_million_letter_a() ==\n+            unsafe {raw::slice_bytes(letters, 0u, 500000)}.to_owned());\n     }\n \n     #[test]\n@@ -2989,50 +2976,51 @@ mod tests {\n \n     #[test]\n     fn test_slice() {\n-        fail_unless!(~\"ab\" == slice(~\"abc\", 0, 2));\n-        fail_unless!(~\"bc\" == slice(~\"abc\", 1, 3));\n-        fail_unless!(~\"\" == slice(~\"abc\", 1, 1));\n-        fail_unless!(~\"\\u65e5\" == slice(~\"\\u65e5\\u672c\", 0, 3));\n+        fail_unless!(\"ab\" == slice(\"abc\", 0, 2));\n+        fail_unless!(\"bc\" == slice(\"abc\", 1, 3));\n+        fail_unless!(\"\" == slice(\"abc\", 1, 1));\n+        fail_unless!(\"\\u65e5\" == slice(\"\\u65e5\\u672c\", 0, 3));\n \n-        let data = ~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534e\";\n-        fail_unless!(~\"\u0e1b\" == slice(data, 0, 3));\n-        fail_unless!(~\"\u0e23\" == slice(data, 3, 6));\n-        fail_unless!(~\"\" == slice(data, 3, 3));\n-        fail_unless!(~\"\u534e\" == slice(data, 30, 33));\n+        let data = \"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534e\";\n+        fail_unless!(\"\u0e1b\" == slice(data, 0, 3));\n+        fail_unless!(\"\u0e23\" == slice(data, 3, 6));\n+        fail_unless!(\"\" == slice(data, 3, 3));\n+        fail_unless!(\"\u534e\" == slice(data, 30, 33));\n \n         fn a_million_letter_X() -> ~str {\n             let mut i = 0;\n             let mut rs = ~\"\";\n             while i < 100000 {\n-                push_str(&mut rs, ~\"\u534e\u534e\u534e\u534e\u534e\u534e\u534e\u534e\u534e\u534e\");\n+                push_str(&mut rs, \"\u534e\u534e\u534e\u534e\u534e\u534e\u534e\u534e\u534e\u534e\");\n                 i += 1;\n             }\n             rs\n         }\n         fn half_a_million_letter_X() -> ~str {\n             let mut i = 0;\n             let mut rs = ~\"\";\n-            while i < 100000 { push_str(&mut rs, ~\"\u534e\u534e\u534e\u534e\u534e\"); i += 1; }\n+            while i < 100000 { push_str(&mut rs, \"\u534e\u534e\u534e\u534e\u534e\"); i += 1; }\n             rs\n         }\n+        let letters = a_million_letter_X();\n         fail_unless!(half_a_million_letter_X() ==\n-            slice(a_million_letter_X(), 0u, 3u * 500000u));\n+            slice(letters, 0u, 3u * 500000u).to_owned());\n     }\n \n     #[test]\n     fn test_slice_2() {\n-        let ss = ~\"\u4e2d\u534eVi\u1ec7t Nam\";\n+        let ss = \"\u4e2d\u534eVi\u1ec7t Nam\";\n \n-        fail_unless!(~\"\u534e\" == slice(ss, 3u, 6u));\n-        fail_unless!(~\"Vi\u1ec7t Nam\" == slice(ss, 6u, 16u));\n+        fail_unless!(\"\u534e\" == slice(ss, 3u, 6u));\n+        fail_unless!(\"Vi\u1ec7t Nam\" == slice(ss, 6u, 16u));\n \n-        fail_unless!(~\"ab\" == slice(~\"abc\", 0u, 2u));\n-        fail_unless!(~\"bc\" == slice(~\"abc\", 1u, 3u));\n-        fail_unless!(~\"\" == slice(~\"abc\", 1u, 1u));\n+        fail_unless!(\"ab\" == slice(\"abc\", 0u, 2u));\n+        fail_unless!(\"bc\" == slice(\"abc\", 1u, 3u));\n+        fail_unless!(\"\" == slice(\"abc\", 1u, 1u));\n \n-        fail_unless!(~\"\u4e2d\" == slice(ss, 0u, 3u));\n-        fail_unless!(~\"\u534eV\" == slice(ss, 3u, 7u));\n-        fail_unless!(~\"\" == slice(ss, 3u, 3u));\n+        fail_unless!(\"\u4e2d\" == slice(ss, 0u, 3u));\n+        fail_unless!(\"\u534eV\" == slice(ss, 3u, 7u));\n+        fail_unless!(\"\" == slice(ss, 3u, 3u));\n         /*0: \u4e2d\n           3: \u534e\n           6: V\n@@ -3049,7 +3037,7 @@ mod tests {\n     #[should_fail]\n     #[ignore(cfg(windows))]\n     fn test_slice_fail() {\n-        slice(~\"\u4e2d\u534eVi\u1ec7t Nam\", 0u, 2u);\n+        slice(\"\u4e2d\u534eVi\u1ec7t Nam\", 0u, 2u);\n     }\n \n     #[test]\n@@ -3645,7 +3633,7 @@ mod tests {\n     #[test]\n     fn test_to_managed() {\n         fail_unless!((~\"abc\").to_managed() == @\"abc\");\n-        fail_unless!(view(\"abcdef\", 1, 5).to_managed() == @\"bcde\");\n+        fail_unless!(slice(\"abcdef\", 1, 5).to_managed() == @\"bcde\");\n     }\n \n     #[test]"}, {"sha": "0f41ca8c41afdea32bcd2dfbd8843cb7fdef579c", "filename": "src/libcore/unstable/extfmt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b8899138f88e50841829c471b2705f2e796b9a1f/src%2Flibcore%2Funstable%2Fextfmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8899138f88e50841829c471b2705f2e796b9a1f/src%2Flibcore%2Funstable%2Fextfmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funstable%2Fextfmt.rs?ref=b8899138f88e50841829c471b2705f2e796b9a1f", "patch": "@@ -164,7 +164,7 @@ pub mod ct {\n     pub fn parse_fmt_string(s: &str, err: ErrorFn) -> ~[Piece] {\n         fn push_slice(ps: &mut ~[Piece], s: &str, from: uint, to: uint) {\n             if to > from {\n-                ps.push(PieceString(s.slice(from, to)));\n+                ps.push(PieceString(s.slice(from, to).to_owned()));\n             }\n         }\n "}, {"sha": "2e20e859d5562044a70bec66a4399f789c6428d4", "filename": "src/libcore/vec.rs", "status": "modified", "additions": 14, "deletions": 12, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/b8899138f88e50841829c471b2705f2e796b9a1f/src%2Flibcore%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8899138f88e50841829c471b2705f2e796b9a1f/src%2Flibcore%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fvec.rs?ref=b8899138f88e50841829c471b2705f2e796b9a1f", "patch": "@@ -1707,27 +1707,29 @@ impl<T> Container for &'self [const T] {\n }\n \n pub trait CopyableVector<T> {\n-    pure fn slice(&self, start: uint, end: uint) -> ~[T];\n+    pure fn to_owned(&self) -> ~[T];\n }\n \n /// Extension methods for vectors\n impl<T: Copy> CopyableVector<T> for &'self [const T] {\n-    /// Returns a copy of the elements from [`start`..`end`) from `v`.\n+    /// Returns a copy of `v`.\n     #[inline]\n-    pure fn slice(&self, start: uint, end: uint) -> ~[T] {\n-        // XXX: Purity workaround for stage0.\n+    pure fn to_owned(&self) -> ~[T] {\n+        let mut result = ~[];\n+        // FIXME: #4568\n         unsafe {\n-            let mut result = ~[];\n-            for uint::range(start, end) |i| {\n-                result.push(copy self[i]);\n+            reserve(&mut result, self.len());\n+            for self.each |e| {\n+                result.push(copy *e);\n             }\n-            result\n         }\n+        result\n+\n     }\n }\n \n pub trait ImmutableVector<T> {\n-    pure fn view(&self, start: uint, end: uint) -> &'self [T];\n+    pure fn slice(&self, start: uint, end: uint) -> &'self [T];\n     pure fn head(&self) -> &'self T;\n     pure fn head_opt(&self) -> Option<&'self T>;\n     pure fn tail(&self) -> &'self [T];\n@@ -1751,7 +1753,7 @@ pub trait ImmutableVector<T> {\n impl<T> ImmutableVector<T> for &'self [T] {\n     /// Return a slice that points into another slice.\n     #[inline]\n-    pure fn view(&self, start: uint, end: uint) -> &'self [T] {\n+    pure fn slice(&self, start: uint, end: uint) -> &'self [T] {\n         slice(*self, start, end)\n     }\n \n@@ -3613,9 +3615,9 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_view() {\n+    fn test_slice_2() {\n         let v = ~[1, 2, 3, 4, 5];\n-        let v = v.view(1u, 3u);\n+        let v = v.slice(1u, 3u);\n         fail_unless!(v.len() == 2u);\n         fail_unless!(v[0] == 2);\n         fail_unless!(v[1] == 3);"}, {"sha": "3a2bbcee4b0a606327ec1b16564aee35f8c7f376", "filename": "src/libfuzzer/fuzzer.rc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b8899138f88e50841829c471b2705f2e796b9a1f/src%2Flibfuzzer%2Ffuzzer.rc", "raw_url": "https://github.com/rust-lang/rust/raw/b8899138f88e50841829c471b2705f2e796b9a1f/src%2Flibfuzzer%2Ffuzzer.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibfuzzer%2Ffuzzer.rc?ref=b8899138f88e50841829c471b2705f2e796b9a1f", "patch": "@@ -336,7 +336,7 @@ pub fn check_variants_T<T: Copy>(\n \n pub fn last_part(filename: ~str) -> ~str {\n   let ix = option::get(str::rfind_char(filename, '/'));\n-  str::slice(filename, ix + 1u, str::len(filename) - 3u)\n+  str::slice(filename, ix + 1u, str::len(filename) - 3u).to_owned()\n }\n \n pub enum happiness {"}, {"sha": "4c8f27167816e49e88006014e232c3bd2c291a1b", "filename": "src/librustc/back/link.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b8899138f88e50841829c471b2705f2e796b9a1f/src%2Flibrustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8899138f88e50841829c471b2705f2e796b9a1f/src%2Flibrustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flink.rs?ref=b8899138f88e50841829c471b2705f2e796b9a1f", "patch": "@@ -771,7 +771,7 @@ pub fn link_binary(sess: Session,\n     fn unlib(config: @session::config, +stem: ~str) -> ~str {\n         if stem.starts_with(\"lib\") &&\n             config.os != session::os_win32 {\n-            stem.slice(3, stem.len())\n+            stem.slice(3, stem.len()).to_owned()\n         } else {\n             stem\n         }"}, {"sha": "6bb10a42f3e457fa5db5e579f4e89cbaff192d8d", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b8899138f88e50841829c471b2705f2e796b9a1f/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8899138f88e50841829c471b2705f2e796b9a1f/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=b8899138f88e50841829c471b2705f2e796b9a1f", "patch": "@@ -1239,7 +1239,7 @@ fn encode_crate_deps(ecx: @EncodeContext,\n         }\n \n         // mut -> immutable hack for vec::map\n-        deps.slice(0, deps.len())\n+        deps.slice(0, deps.len()).to_owned()\n     }\n \n     // We're just going to write a list of crate 'name-hash-version's, with"}, {"sha": "3edceebba0cc021568d3eb5bcc87cb07370e1b6f", "filename": "src/librustc/middle/lint.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b8899138f88e50841829c471b2705f2e796b9a1f/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8899138f88e50841829c471b2705f2e796b9a1f/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=b8899138f88e50841829c471b2705f2e796b9a1f", "patch": "@@ -888,14 +888,14 @@ fn check_item_non_camel_case_types(cx: ty::ctxt, it: @ast::item) {\n \n     fn ident_without_trailing_underscores(ident: &'r str) -> &'r str {\n         match str::rfind(ident, |c| c != '_') {\n-            Some(idx) => str::view(ident, 0, idx + 1),\n+            Some(idx) => str::slice(ident, 0, idx + 1),\n             None => ident, // all underscores\n         }\n     }\n \n     fn ident_without_leading_underscores(ident: &'r str) -> &'r str {\n         match str::find(ident, |c| c != '_') {\n-            Some(idx) => str::view(ident, idx, ident.len()),\n+            Some(idx) => str::slice(ident, idx, ident.len()),\n             None => ident // all underscores\n         }\n     }"}, {"sha": "8ffccff54b8d81136cc16ddfbfe8551e67f10713", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b8899138f88e50841829c471b2705f2e796b9a1f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8899138f88e50841829c471b2705f2e796b9a1f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=b8899138f88e50841829c471b2705f2e796b9a1f", "patch": "@@ -1430,7 +1430,7 @@ pub fn find_vtable(tcx: ty::ctxt, ps: &param_substs,\n \n     // Vtables are stored in a flat array, finding the right one is\n     // somewhat awkward\n-    let first_n_bounds = ps.bounds.view(0, n_param);\n+    let first_n_bounds = ps.bounds.slice(0, n_param);\n     let vtables_to_skip =\n         ty::count_traits_and_supertraits(tcx, first_n_bounds);\n     let vtable_off = vtables_to_skip + n_bound;"}, {"sha": "c575465ddf7846d72aef8d23523deb807cbde0b5", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b8899138f88e50841829c471b2705f2e796b9a1f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8899138f88e50841829c471b2705f2e796b9a1f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=b8899138f88e50841829c471b2705f2e796b9a1f", "patch": "@@ -251,10 +251,10 @@ fn get_cache(cx: @CrateContext) -> metadata_cache {\n fn get_file_path_and_dir(work_dir: &str, full_path: &str) -> (~str, ~str) {\n     (if str::starts_with(full_path, work_dir) {\n         str::slice(full_path, str::len(work_dir) + 1u,\n-                   str::len(full_path))\n+                   str::len(full_path)).to_owned()\n     } else {\n-        str::from_slice(full_path)\n-    }, str::from_slice(work_dir))\n+        full_path.to_owned()\n+    }, work_dir.to_owned())\n }\n \n fn create_file(cx: @CrateContext, +full_path: ~str)"}, {"sha": "eb63d675d80af440c9397c097c915ac9bc00356e", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b8899138f88e50841829c471b2705f2e796b9a1f/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8899138f88e50841829c471b2705f2e796b9a1f/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=b8899138f88e50841829c471b2705f2e796b9a1f", "patch": "@@ -488,7 +488,7 @@ pub fn parameterized(cx: ctxt,\n \n pub fn ty_to_short_str(cx: ctxt, typ: t) -> ~str {\n     let mut s = encoder::encoded_ty(cx, typ);\n-    if str::len(s) >= 32u { s = str::slice(s, 0u, 32u); }\n+    if str::len(s) >= 32u { s = str::slice(s, 0u, 32u).to_owned(); }\n     return s;\n }\n "}, {"sha": "281c318eb152cc8b5a0aeb931d31a1c930b8a8ef", "filename": "src/librustdoc/desc_to_brief_pass.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b8899138f88e50841829c471b2705f2e796b9a1f/src%2Flibrustdoc%2Fdesc_to_brief_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8899138f88e50841829c471b2705f2e796b9a1f/src%2Flibrustdoc%2Fdesc_to_brief_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdesc_to_brief_pass.rs?ref=b8899138f88e50841829c471b2705f2e796b9a1f", "patch": "@@ -171,7 +171,7 @@ fn first_sentence_(s: &str) -> ~str {\n     };\n     match idx {\n         Some(idx) if idx > 2u => {\n-            str::from_slice(str::view(s, 0, idx - 1))\n+            str::from_slice(str::slice(s, 0, idx - 1))\n         }\n         _ => {\n             if str::ends_with(s, ~\".\") {"}, {"sha": "4c68e632f83ebd560b116dc1ce79afc1ec92400e", "filename": "src/librustdoc/markdown_writer.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b8899138f88e50841829c471b2705f2e796b9a1f/src%2Flibrustdoc%2Fmarkdown_writer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8899138f88e50841829c471b2705f2e796b9a1f/src%2Flibrustdoc%2Fmarkdown_writer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fmarkdown_writer.rs?ref=b8899138f88e50841829c471b2705f2e796b9a1f", "patch": "@@ -157,7 +157,7 @@ fn readclose(fd: libc::c_int) -> ~str {\n             let mut bytes = [0, ..4096];\n             while !reader.eof() {\n                 let nread = reader.read(bytes, bytes.len());\n-                writer.write(bytes.view(0, nread));\n+                writer.write(bytes.slice(0, nread).to_owned());\n             }\n         });\n         os::fclose(file);"}, {"sha": "8b058048ff4ac6dd5dd5dcd2d8334aab569e387b", "filename": "src/librustdoc/sectionalize_pass.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b8899138f88e50841829c471b2705f2e796b9a1f/src%2Flibrustdoc%2Fsectionalize_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8899138f88e50841829c471b2705f2e796b9a1f/src%2Flibrustdoc%2Fsectionalize_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fsectionalize_pass.rs?ref=b8899138f88e50841829c471b2705f2e796b9a1f", "patch": "@@ -154,7 +154,7 @@ fn sectionalize(desc: Option<~str>) -> (Option<~str>, ~[doc::Section]) {\n \n fn parse_header(line: ~str) -> Option<~str> {\n     if str::starts_with(line, ~\"# \") {\n-        Some(str::slice(line, 2u, str::len(line)))\n+        Some(str::slice(line, 2u, str::len(line)).to_owned())\n     } else {\n         None\n     }"}, {"sha": "506dfafa24715fc58d229e2766cee5017a96ee63", "filename": "src/librustdoc/unindent_pass.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b8899138f88e50841829c471b2705f2e796b9a1f/src%2Flibrustdoc%2Funindent_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8899138f88e50841829c471b2705f2e796b9a1f/src%2Flibrustdoc%2Funindent_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Funindent_pass.rs?ref=b8899138f88e50841829c471b2705f2e796b9a1f", "patch": "@@ -84,7 +84,7 @@ fn unindent(s: &str) -> ~str {\n                 copy *line\n             } else {\n                 fail_unless!(str::len(*line) >= min_indent);\n-                str::slice(*line, min_indent, str::len(*line))\n+                str::slice(*line, min_indent, str::len(*line)).to_owned()\n             }\n         };\n         str::connect(unindented, ~\"\\n\")"}, {"sha": "d4b4c7b097c1c4fa5c5c4cb2079cdf6bb99b1ffa", "filename": "src/libstd/bitv.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b8899138f88e50841829c471b2705f2e796b9a1f/src%2Flibstd%2Fbitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8899138f88e50841829c471b2705f2e796b9a1f/src%2Flibstd%2Fbitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbitv.rs?ref=b8899138f88e50841829c471b2705f2e796b9a1f", "patch": "@@ -831,7 +831,7 @@ priv impl BitvSet {\n                         f: &fn(uint, uint, uint) -> bool) {\n         let min = uint::min(self.bitv.storage.len(),\n                             other.bitv.storage.len());\n-        for self.bitv.storage.view(0, min).eachi |i, &w| {\n+        for self.bitv.storage.slice(0, min).eachi |i, &w| {\n             if !f(i * uint::bits, w, other.bitv.storage[i]) {\n                 return;\n             }\n@@ -852,12 +852,12 @@ priv impl BitvSet {\n         let min = uint::min(len1, len2);\n \n         /* only one of these loops will execute and that's the point */\n-        for self.bitv.storage.view(min, len1).eachi |i, &w| {\n+        for self.bitv.storage.slice(min, len1).eachi |i, &w| {\n             if !f(true, (i + min) * uint::bits, w) {\n                 return;\n             }\n         }\n-        for other.bitv.storage.view(min, len2).eachi |i, &w| {\n+        for other.bitv.storage.slice(min, len2).eachi |i, &w| {\n             if !f(false, (i + min) * uint::bits, w) {\n                 return;\n             }"}, {"sha": "105e34761a8edec73f047248a7c047fac1717db1", "filename": "src/libstd/flatpipes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b8899138f88e50841829c471b2705f2e796b9a1f/src%2Flibstd%2Fflatpipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8899138f88e50841829c471b2705f2e796b9a1f/src%2Flibstd%2Fflatpipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fflatpipes.rs?ref=b8899138f88e50841829c471b2705f2e796b9a1f", "patch": "@@ -571,7 +571,7 @@ pub mod bytepipes {\n         fn try_recv(&self, count: uint) -> Option<~[u8]> {\n             if vec::uniq_len(&const self.buf) >= count {\n                 let mut bytes = ::core::util::replace(&mut self.buf, ~[]);\n-                self.buf = bytes.slice(count, bytes.len());\n+                self.buf = bytes.slice(count, bytes.len()).to_owned();\n                 bytes.truncate(count);\n                 return Some(bytes);\n             } else if vec::uniq_len(&const self.buf) > 0 {"}, {"sha": "e2702b7d566c55fec503d570d3507e7c1059776c", "filename": "src/libstd/getopts.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b8899138f88e50841829c471b2705f2e796b9a1f/src%2Flibstd%2Fgetopts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8899138f88e50841829c471b2705f2e796b9a1f/src%2Flibstd%2Fgetopts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fgetopts.rs?ref=b8899138f88e50841829c471b2705f2e796b9a1f", "patch": "@@ -243,7 +243,7 @@ pub fn getopts(args: &[~str], opts: &[Opt]) -> Result {\n                 let mut names;\n                 let mut i_arg = None;\n                 if cur[1] == '-' as u8 {\n-                    let tail = str::slice(cur, 2, curlen);\n+                    let tail = str::slice(cur, 2, curlen).to_owned();\n                     let tail_eq = str::splitn_char(tail, '=', 1);\n                     if tail_eq.len() <= 1 {\n                         names = ~[Long(tail)];\n@@ -279,7 +279,7 @@ pub fn getopts(args: &[~str], opts: &[Opt]) -> Result {\n                                   No => false\n                                 };\n                             if arg_follows && j < curlen {\n-                                i_arg = Some(cur.slice(j, curlen));\n+                                i_arg = Some(cur.slice(j, curlen).to_owned());\n                                 break;\n                             } else {\n                                 last_valid_opt_id = None;"}, {"sha": "4943b374980a9d6f6e1ab88b85ead7cfd06c802a", "filename": "src/libstd/net_url.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/b8899138f88e50841829c471b2705f2e796b9a1f/src%2Flibstd%2Fnet_url.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8899138f88e50841829c471b2705f2e796b9a1f/src%2Flibstd%2Fnet_url.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_url.rs?ref=b8899138f88e50841829c471b2705f2e796b9a1f", "patch": "@@ -317,10 +317,10 @@ pure fn split_char_first(s: &str, c: char) -> (~str, ~str) {\n         }\n     }\n     if index+mat == len {\n-        return (str::slice(s, 0, index), ~\"\");\n+        return (str::slice(s, 0, index).to_owned(), ~\"\");\n     } else {\n-        return (str::slice(s, 0, index),\n-             str::slice(s, index + mat, str::len(s)));\n+        return (str::slice(s, 0, index).to_owned(),\n+             str::slice(s, index + mat, str::len(s)).to_owned());\n     }\n }\n \n@@ -386,8 +386,8 @@ pub pure fn get_scheme(rawurl: &str) -> Result<(~str, ~str), ~str> {\n             if i == 0 {\n                 return Err(~\"url: Scheme cannot be empty.\");\n             } else {\n-                return Ok((rawurl.slice(0,i),\n-                                rawurl.slice(i+1,str::len(rawurl))));\n+                return Ok((rawurl.slice(0,i).to_owned(),\n+                                rawurl.slice(i+1,str::len(rawurl)).to_owned()));\n             }\n           }\n           _ => {\n@@ -489,7 +489,7 @@ pure fn get_authority(rawurl: &str) ->\n               }\n               Ip6Host => {\n                 if colon_count > 7 {\n-                    host = str::slice(rawurl, begin, i);\n+                    host = str::slice(rawurl, begin, i).to_owned();\n                     pos = i;\n                     st = InPort;\n                 }\n@@ -506,13 +506,13 @@ pure fn get_authority(rawurl: &str) ->\n             colon_count = 0; // reset count\n             match st {\n               Start => {\n-                let user = str::slice(rawurl, begin, i);\n+                let user = str::slice(rawurl, begin, i).to_owned();\n                 userinfo = Some(UserInfo::new(user, None));\n                 st = InHost;\n               }\n               PassHostPort => {\n-                let user = str::slice(rawurl, begin, pos);\n-                let pass = str::slice(rawurl, pos+1, i);\n+                let user = str::slice(rawurl, begin, pos).to_owned();\n+                let pass = str::slice(rawurl, pos+1, i).to_owned();\n                 userinfo = Some(UserInfo::new(user, Some(pass)));\n                 st = InHost;\n               }\n@@ -543,31 +543,31 @@ pure fn get_authority(rawurl: &str) ->\n     match st {\n       Start => {\n         if host_is_end_plus_one() {\n-            host = str::slice(rawurl, begin, end+1);\n+            host = str::slice(rawurl, begin, end+1).to_owned();\n         } else {\n-            host = str::slice(rawurl, begin, end);\n+            host = str::slice(rawurl, begin, end).to_owned();\n         }\n       }\n       PassHostPort | Ip6Port => {\n         if in != Digit {\n             return Err(~\"Non-digit characters in port.\");\n         }\n-        host = str::slice(rawurl, begin, pos);\n-        port = Some(str::slice(rawurl, pos+1, end));\n+        host = str::slice(rawurl, begin, pos).to_owned();\n+        port = Some(str::slice(rawurl, pos+1, end).to_owned());\n       }\n       Ip6Host | InHost => {\n-        host = str::slice(rawurl, begin, end);\n+        host = str::slice(rawurl, begin, end).to_owned();\n       }\n       InPort => {\n         if in != Digit {\n             return Err(~\"Non-digit characters in port.\");\n         }\n-        port = Some(str::slice(rawurl, pos+1, end));\n+        port = Some(str::slice(rawurl, pos+1, end).to_owned());\n       }\n     }\n \n     let rest = if host_is_end_plus_one() { ~\"\" }\n-    else { str::slice(rawurl, end, len) };\n+    else { str::slice(rawurl, end, len).to_owned() };\n     return Ok((userinfo, host, port, rest));\n }\n \n@@ -599,8 +599,8 @@ pure fn get_path(rawurl: &str, authority: bool) ->\n         }\n     }\n \n-    return Ok((decode_component(str::slice(rawurl, 0, end)),\n-                    str::slice(rawurl, end, len)));\n+    return Ok((decode_component(str::slice(rawurl, 0, end).to_owned()),\n+                    str::slice(rawurl, end, len).to_owned()));\n }\n \n // returns the parsed query and the fragment, if present\n@@ -610,14 +610,14 @@ pure fn get_query_fragment(rawurl: &str) ->\n         if str::starts_with(rawurl, ~\"#\") {\n             let f = decode_component(str::slice(rawurl,\n                                                 1,\n-                                                str::len(rawurl)));\n+                                                str::len(rawurl)).to_owned());\n             return Ok((~[], Some(f)));\n         } else {\n             return Ok((~[], None));\n         }\n     }\n     let (q, r) = split_char_first(str::slice(rawurl, 1,\n-                                             str::len(rawurl)), '#');\n+                                             str::len(rawurl)).to_owned(), '#');\n     let f = if str::len(r) != 0 {\n         Some(decode_component(r)) } else { None };\n     return Ok((query_from_str(q), f));"}, {"sha": "ff7d4ec3b1cfac336b9aaeab308fd2922285a74c", "filename": "src/libstd/rope.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b8899138f88e50841829c471b2705f2e796b9a1f/src%2Flibstd%2Frope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8899138f88e50841829c471b2705f2e796b9a1f/src%2Flibstd%2Frope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frope.rs?ref=b8899138f88e50841829c471b2705f2e796b9a1f", "patch": "@@ -1295,7 +1295,7 @@ mod tests {\n                       node::Leaf(x) => {\n                         *str += str::slice(\n                             *x.content, x.byte_offset,\n-                            x.byte_offset + x.byte_len);\n+                            x.byte_offset + x.byte_len).to_owned();\n                       }\n                       node::Concat(ref x) => {\n                         aux(str, x.left);"}, {"sha": "077ab191e69e3708b00cf053791f84cc14e0a363", "filename": "src/libstd/sha1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b8899138f88e50841829c471b2705f2e796b9a1f/src%2Flibstd%2Fsha1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8899138f88e50841829c471b2705f2e796b9a1f/src%2Flibstd%2Fsha1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsha1.rs?ref=b8899138f88e50841829c471b2705f2e796b9a1f", "patch": "@@ -399,7 +399,7 @@ mod tests {\n                 while left > 0u {\n                     let take = (left + 1u) / 2u;\n                     sh.input_str(str::slice(t.input, len - left,\n-                                 take + len - left));\n+                                 take + len - left).to_owned());\n                     left = left - take;\n                 }\n                 let out = sh.result();"}, {"sha": "727d386f277f92046b14c204b5f319ccb3f48535", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b8899138f88e50841829c471b2705f2e796b9a1f/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8899138f88e50841829c471b2705f2e796b9a1f/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=b8899138f88e50841829c471b2705f2e796b9a1f", "patch": "@@ -266,7 +266,7 @@ pub impl FileMap {\n                 Some(e) => e,\n                 None => str::len(*self.src)\n             };\n-            str::slice(*self.src, begin, end)\n+            str::slice(*self.src, begin, end).to_owned()\n         }\n     }\n \n@@ -396,7 +396,7 @@ pub impl CodeMap {\n         let end = self.lookup_byte_offset(sp.hi);\n         fail_unless!(begin.fm.start_pos == end.fm.start_pos);\n         return str::slice(*begin.fm.src,\n-                          begin.pos.to_uint(), end.pos.to_uint());\n+                          begin.pos.to_uint(), end.pos.to_uint()).to_owned();\n     }\n \n     pub fn get_filemap(&self, filename: ~str) -> @FileMap {"}, {"sha": "5a6fd6fec5894f914adf55cf6953bd12cc4b14cd", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b8899138f88e50841829c471b2705f2e796b9a1f/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8899138f88e50841829c471b2705f2e796b9a1f/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=b8899138f88e50841829c471b2705f2e796b9a1f", "patch": "@@ -112,7 +112,7 @@ pub fn add_new_extension(cx: @ext_ctxt,\n                             match (*tt) {\n                                 // cut off delimiters; don't parse 'em\n                                 tt_delim(ref tts) => {\n-                                    (*tts).slice(1u,(*tts).len()-1u)\n+                                    (*tts).slice(1u,(*tts).len()-1u).to_owned()\n                                 }\n                                 _ => cx.span_fatal(\n                                     sp, ~\"macro rhs must be delimited\")"}, {"sha": "b5072e8c2b54d18dcf4da6e67a4ddd1e18cf2b1a", "filename": "src/libsyntax/parse/comments.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b8899138f88e50841829c471b2705f2e796b9a1f/src%2Flibsyntax%2Fparse%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8899138f88e50841829c471b2705f2e796b9a1f/src%2Flibsyntax%2Fparse%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fcomments.rs?ref=b8899138f88e50841829c471b2705f2e796b9a1f", "patch": "@@ -76,7 +76,7 @@ pub fn strip_doc_comment_decoration(comment: &str) -> ~str {\n         while j > i && lines[j - 1u].trim().is_empty() {\n             j -= 1u;\n         }\n-        return lines.slice(i, j);\n+        return lines.slice(i, j).to_owned();\n     }\n \n     // drop leftmost columns that contain only values in chars\n@@ -103,7 +103,7 @@ pub fn strip_doc_comment_decoration(comment: &str) -> ~str {\n             if i > chars.len() {\n                 ~\"\"\n             } else {\n-                str::from_chars(chars.slice(i, chars.len()))\n+                str::from_chars(chars.slice(i, chars.len()).to_owned())\n             }\n         };\n     }\n@@ -113,7 +113,7 @@ pub fn strip_doc_comment_decoration(comment: &str) -> ~str {\n     }\n \n     if comment.starts_with(~\"/*\") {\n-        let lines = str::lines_any(comment.slice(3u, comment.len() - 2u));\n+        let lines = str::lines_any(comment.slice(3u, comment.len() - 2u).to_owned());\n         let lines = vertical_trim(lines);\n         let lines = block_trim(lines, ~\"\\t \", None);\n         let lines = block_trim(lines, ~\"*\", Some(1u));\n@@ -218,7 +218,7 @@ fn trim_whitespace_prefix_and_push_line(lines: &mut ~[~str],\n     let col = col.to_uint();\n     if all_whitespace(s, 0u, uint::min(len, col)) {\n         if col < len {\n-            s1 = str::slice(s, col, len);\n+            s1 = str::slice(s, col, len).to_owned();\n         } else { s1 = ~\"\"; }\n     } else { s1 = s; }\n     debug!(\"pushing line: %s\", s1);"}, {"sha": "6cb4065935c6e52e2cd18e8abcfd307a258546a1", "filename": "src/libsyntax/parse/lexer.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b8899138f88e50841829c471b2705f2e796b9a1f/src%2Flibsyntax%2Fparse%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8899138f88e50841829c471b2705f2e796b9a1f/src%2Flibsyntax%2Fparse%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer.rs?ref=b8899138f88e50841829c471b2705f2e796b9a1f", "patch": "@@ -177,7 +177,7 @@ pub fn get_str_from(rdr: @mut StringReader, start: BytePos) -> ~str {\n         // I'm pretty skeptical about this subtraction. What if there's a\n         // multi-byte character before the mark?\n         return str::slice(*rdr.src, start.to_uint() - 1u,\n-                          byte_offset(rdr).to_uint() - 1u);\n+                          byte_offset(rdr).to_uint() - 1u).to_owned();\n     }\n }\n "}, {"sha": "c9a5507f8de0fb5a0f7bf9de92143ced1ec775af", "filename": "src/test/compile-fail/issue-3888.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b8899138f88e50841829c471b2705f2e796b9a1f/src%2Ftest%2Fcompile-fail%2Fissue-3888.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8899138f88e50841829c471b2705f2e796b9a1f/src%2Ftest%2Fcompile-fail%2Fissue-3888.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3888.rs?ref=b8899138f88e50841829c471b2705f2e796b9a1f", "patch": "@@ -17,7 +17,7 @@ fn vec_peek<T>(v: &'r [T]) -> Option< (&'r T, &'r [T]) > {\n         let vec_len = v.len();\n         let head = &v[0];\n         // note: this *shouldn't* be an illegal borrow! See #3888\n-        let tail = v.view(1, vec_len); //~ ERROR illegal borrow: borrowed value does not live long enough\n+        let tail = v.slice(1, vec_len); //~ ERROR illegal borrow: borrowed value does not live long enough\n         Some( (head, tail) )\n     }\n }"}]}