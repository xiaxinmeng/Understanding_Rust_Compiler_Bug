{"sha": "53d19b37c514246acab020eaba9527cb97c421cf", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUzZDE5YjM3YzUxNDI0NmFjYWIwMjBlYWJhOTUyN2NiOTdjNDIxY2Y=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-11-24T12:27:30Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-11-24T12:27:30Z"}, "message": "Auto merge of #79377 - jonas-schievink:rollup-ye81i66, r=jonas-schievink\n\nRollup of 10 pull requests\n\nSuccessful merges:\n\n - #76858 (Add exploit mitigations chapter to the rustc book)\n - #79310 (Make `fold_item_recur` non-nullable)\n - #79312 (Get rid of `doctree::Impl`)\n - #79321 (Accept '!' in intra-doc links)\n - #79346 (Allow using `-Z fewer-names=no` to retain value names)\n - #79351 (Fix typo in `keyword` docs for traits)\n - #79354 (BTreeMap: cut out the ceremony around BoxedNode)\n - #79358 (BTreeMap/BTreeSet: make public doc more consistent)\n - #79367 (Allow disabling TrapUnreachable via -Ztrap-unreachable=no)\n - #79374 (Add note to use nightly when using expr in const generics)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "657b3ff7ff74baa3b855bfee35724114b9fb2364", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/657b3ff7ff74baa3b855bfee35724114b9fb2364"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/53d19b37c514246acab020eaba9527cb97c421cf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/53d19b37c514246acab020eaba9527cb97c421cf", "html_url": "https://github.com/rust-lang/rust/commit/53d19b37c514246acab020eaba9527cb97c421cf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/53d19b37c514246acab020eaba9527cb97c421cf/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6331023708aabef7fbd4ca502feb48c3afc83b41", "url": "https://api.github.com/repos/rust-lang/rust/commits/6331023708aabef7fbd4ca502feb48c3afc83b41", "html_url": "https://github.com/rust-lang/rust/commit/6331023708aabef7fbd4ca502feb48c3afc83b41"}, {"sha": "f049b0be9695cc87938436b50b982fc6013f8344", "url": "https://api.github.com/repos/rust-lang/rust/commits/f049b0be9695cc87938436b50b982fc6013f8344", "html_url": "https://github.com/rust-lang/rust/commit/f049b0be9695cc87938436b50b982fc6013f8344"}], "stats": {"total": 1311, "additions": 999, "deletions": 312}, "files": [{"sha": "7407dfc455d84b5c19f28c3abd2aa1d24ccf58de", "filename": "compiler/rustc_codegen_llvm/src/back/write.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/53d19b37c514246acab020eaba9527cb97c421cf/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53d19b37c514246acab020eaba9527cb97c421cf/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Fwrite.rs?ref=53d19b37c514246acab020eaba9527cb97c421cf", "patch": "@@ -152,7 +152,8 @@ pub fn target_machine_factory(\n     let features = features.join(\",\");\n     let features = CString::new(features).unwrap();\n     let abi = SmallCStr::new(&sess.target.llvm_abiname);\n-    let trap_unreachable = sess.target.trap_unreachable;\n+    let trap_unreachable =\n+        sess.opts.debugging_opts.trap_unreachable.unwrap_or(sess.target.trap_unreachable);\n     let emit_stack_size_section = sess.opts.debugging_opts.emit_stack_sizes;\n \n     let asm_comments = sess.asm_comments();"}, {"sha": "92262050b8c1b14004a24a29f63768ce244d9c36", "filename": "compiler/rustc_interface/src/tests.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/53d19b37c514246acab020eaba9527cb97c421cf/compiler%2Frustc_interface%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53d19b37c514246acab020eaba9527cb97c421cf/compiler%2Frustc_interface%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Ftests.rs?ref=53d19b37c514246acab020eaba9527cb97c421cf", "patch": "@@ -547,7 +547,7 @@ fn test_debugging_options_tracking_hash() {\n     tracked!(debug_macros, true);\n     tracked!(dep_info_omit_d_target, true);\n     tracked!(dual_proc_macros, true);\n-    tracked!(fewer_names, true);\n+    tracked!(fewer_names, Some(true));\n     tracked!(force_overflow_checks, Some(true));\n     tracked!(force_unstable_if_unmarked, true);\n     tracked!(fuel, Some((\"abc\".to_string(), 99)));\n@@ -592,6 +592,7 @@ fn test_debugging_options_tracking_hash() {\n     tracked!(thinlto, Some(true));\n     tracked!(tune_cpu, Some(String::from(\"abc\")));\n     tracked!(tls_model, Some(TlsModel::GeneralDynamic));\n+    tracked!(trap_unreachable, Some(false));\n     tracked!(treat_err_as_bug, Some(1));\n     tracked!(unleash_the_miri_inside_of_you, true);\n     tracked!(use_ctors_section, Some(true));"}, {"sha": "a0d5b61e8bd1b590f2d9b529df705a860fc13424", "filename": "compiler/rustc_resolve/src/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/53d19b37c514246acab020eaba9527cb97c421cf/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53d19b37c514246acab020eaba9527cb97c421cf/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs?ref=53d19b37c514246acab020eaba9527cb97c421cf", "patch": "@@ -481,6 +481,7 @@ impl<'a> Resolver<'a> {\n                         name\n                     ));\n                 }\n+                err.help(\"use `#![feature(const_generics)]` and `#![feature(const_evaluatable_checked)]` to allow generic const expressions\");\n \n                 err\n             }"}, {"sha": "731bbf029fa3146482a7fd5b12548a09927a1820", "filename": "compiler/rustc_session/src/options.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/53d19b37c514246acab020eaba9527cb97c421cf/compiler%2Frustc_session%2Fsrc%2Foptions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53d19b37c514246acab020eaba9527cb97c421cf/compiler%2Frustc_session%2Fsrc%2Foptions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Foptions.rs?ref=53d19b37c514246acab020eaba9527cb97c421cf", "patch": "@@ -900,7 +900,7 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n         \"emits a future-incompatibility report for lints (RFC 2834)\"),\n     emit_stack_sizes: bool = (false, parse_bool, [UNTRACKED],\n         \"emit a section containing stack size metadata (default: no)\"),\n-    fewer_names: bool = (false, parse_bool, [TRACKED],\n+    fewer_names: Option<bool> = (None, parse_opt_bool, [TRACKED],\n         \"reduce memory use by retaining fewer names within compilation artifacts (LLVM-IR) \\\n         (default: no)\"),\n     force_overflow_checks: Option<bool> = (None, parse_opt_bool, [TRACKED],\n@@ -1113,6 +1113,8 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n         \"choose the TLS model to use (`rustc --print tls-models` for details)\"),\n     trace_macros: bool = (false, parse_bool, [UNTRACKED],\n         \"for every macro invocation, print its name and arguments (default: no)\"),\n+    trap_unreachable: Option<bool> = (None, parse_opt_bool, [TRACKED],\n+        \"generate trap instructions for unreachable intrinsics (default: use target setting, usually yes)\"),\n     treat_err_as_bug: Option<usize> = (None, parse_treat_err_as_bug, [TRACKED],\n         \"treat error number `val` that occurs as bug\"),\n     trim_diagnostic_paths: bool = (true, parse_bool, [UNTRACKED],"}, {"sha": "5dddf0eb72ea641dfebe7913798f11d65baacb4e", "filename": "compiler/rustc_session/src/session.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/53d19b37c514246acab020eaba9527cb97c421cf/compiler%2Frustc_session%2Fsrc%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53d19b37c514246acab020eaba9527cb97c421cf/compiler%2Frustc_session%2Fsrc%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fsession.rs?ref=53d19b37c514246acab020eaba9527cb97c421cf", "patch": "@@ -734,12 +734,15 @@ impl Session {\n         self.opts.cg.panic.unwrap_or(self.target.panic_strategy)\n     }\n     pub fn fewer_names(&self) -> bool {\n-        let more_names = self.opts.output_types.contains_key(&OutputType::LlvmAssembly)\n-            || self.opts.output_types.contains_key(&OutputType::Bitcode)\n-            // AddressSanitizer and MemorySanitizer use alloca name when reporting an issue.\n-            || self.opts.debugging_opts.sanitizer.intersects(SanitizerSet::ADDRESS | SanitizerSet::MEMORY);\n-\n-        self.opts.debugging_opts.fewer_names || !more_names\n+        if let Some(fewer_names) = self.opts.debugging_opts.fewer_names {\n+            fewer_names\n+        } else {\n+            let more_names = self.opts.output_types.contains_key(&OutputType::LlvmAssembly)\n+                || self.opts.output_types.contains_key(&OutputType::Bitcode)\n+                // AddressSanitizer and MemorySanitizer use alloca name when reporting an issue.\n+                || self.opts.debugging_opts.sanitizer.intersects(SanitizerSet::ADDRESS | SanitizerSet::MEMORY);\n+            !more_names\n+        }\n     }\n \n     pub fn unstable_options(&self) -> bool {"}, {"sha": "aeca801a4ee00a88ad152cd333889f364610a670", "filename": "compiler/rustc_typeck/src/check/wfcheck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/53d19b37c514246acab020eaba9527cb97c421cf/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53d19b37c514246acab020eaba9527cb97c421cf/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs?ref=53d19b37c514246acab020eaba9527cb97c421cf", "patch": "@@ -329,7 +329,7 @@ fn check_param_wf(tcx: TyCtxt<'_>, param: &hir::GenericParam<'_>) {\n                             ),\n                         )\n                         .note(\"the only supported types are integers, `bool` and `char`\")\n-                        .note(\"more complex types are supported with `#[feature(const_generics)]`\")\n+                        .help(\"more complex types are supported with `#[feature(const_generics)]`\")\n                         .emit()\n                 }\n             };"}, {"sha": "bd2ad257402fa6511069015fe56382ab72ff7b33", "filename": "library/alloc/src/collections/btree/map.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/53d19b37c514246acab020eaba9527cb97c421cf/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53d19b37c514246acab020eaba9527cb97c421cf/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs?ref=53d19b37c514246acab020eaba9527cb97c421cf", "patch": "@@ -458,7 +458,7 @@ impl<K: fmt::Debug, V: fmt::Debug> fmt::Debug for RangeMut<'_, K, V> {\n }\n \n impl<K: Ord, V> BTreeMap<K, V> {\n-    /// Makes a new empty BTreeMap.\n+    /// Makes a new, empty `BTreeMap`.\n     ///\n     /// Does not allocate anything on its own.\n     ///\n@@ -1924,7 +1924,7 @@ impl<K: Hash, V: Hash> Hash for BTreeMap<K, V> {\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<K: Ord, V> Default for BTreeMap<K, V> {\n-    /// Creates an empty `BTreeMap<K, V>`.\n+    /// Creates an empty `BTreeMap`.\n     fn default() -> BTreeMap<K, V> {\n         BTreeMap::new()\n     }"}, {"sha": "6a8be441513a0b7b7b4fa7a43ba9a56a386b947f", "filename": "library/alloc/src/collections/btree/node.rs", "status": "modified", "additions": 12, "deletions": 38, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/53d19b37c514246acab020eaba9527cb97c421cf/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53d19b37c514246acab020eaba9527cb97c421cf/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode.rs?ref=53d19b37c514246acab020eaba9527cb97c421cf", "patch": "@@ -112,20 +112,8 @@ impl<K, V> InternalNode<K, V> {\n ///\n /// However, `BoxedNode` contains no information as to which of the two types\n /// of nodes it actually contains, and, partially due to this lack of information,\n-/// has no destructor.\n-struct BoxedNode<K, V> {\n-    ptr: NonNull<LeafNode<K, V>>,\n-}\n-\n-impl<K, V> BoxedNode<K, V> {\n-    fn from_owned(ptr: NonNull<LeafNode<K, V>>) -> Self {\n-        BoxedNode { ptr }\n-    }\n-\n-    fn as_ptr(&self) -> NonNull<LeafNode<K, V>> {\n-        self.ptr\n-    }\n-}\n+/// is not a separate type and has no destructor.\n+type BoxedNode<K, V> = NonNull<LeafNode<K, V>>;\n \n /// An owned tree.\n ///\n@@ -168,11 +156,6 @@ impl<K, V, Type> NodeRef<marker::Owned, K, V, Type> {\n     pub fn borrow_valmut(&mut self) -> NodeRef<marker::ValMut<'_>, K, V, Type> {\n         NodeRef { height: self.height, node: self.node, _marker: PhantomData }\n     }\n-\n-    /// Packs the reference, aware of type and height, into a type-agnostic pointer.\n-    fn into_boxed_node(self) -> BoxedNode<K, V> {\n-        BoxedNode::from_owned(self.node)\n-    }\n }\n \n impl<K, V> NodeRef<marker::Owned, K, V, marker::LeafOrInternal> {\n@@ -181,7 +164,7 @@ impl<K, V> NodeRef<marker::Owned, K, V, marker::LeafOrInternal> {\n     /// and is the opposite of `pop_internal_level`.\n     pub fn push_internal_level(&mut self) -> NodeRef<marker::Mut<'_>, K, V, marker::Internal> {\n         let mut new_node = Box::new(unsafe { InternalNode::new() });\n-        new_node.edges[0].write(BoxedNode::from_owned(self.node));\n+        new_node.edges[0].write(self.node);\n         let mut new_root = NodeRef::from_new_internal(new_node, self.height + 1);\n         new_root.borrow_mut().first_edge().correct_parent_link();\n         *self = new_root.forget_type();\n@@ -288,13 +271,6 @@ unsafe impl<'a, K: Send + 'a, V: Send + 'a, Type> Send for NodeRef<marker::Mut<'\n unsafe impl<'a, K: Send + 'a, V: Send + 'a, Type> Send for NodeRef<marker::ValMut<'a>, K, V, Type> {}\n unsafe impl<K: Send, V: Send, Type> Send for NodeRef<marker::Owned, K, V, Type> {}\n \n-impl<BorrowType, K, V> NodeRef<BorrowType, K, V, marker::LeafOrInternal> {\n-    /// Unpack a node reference that was packed by `Root::into_boxed_node`.\n-    fn from_boxed_node(boxed_node: BoxedNode<K, V>, height: usize) -> Self {\n-        NodeRef { height, node: boxed_node.as_ptr(), _marker: PhantomData }\n-    }\n-}\n-\n impl<BorrowType, K, V> NodeRef<BorrowType, K, V, marker::Internal> {\n     /// Unpack a node reference that was packed as `NodeRef::parent`.\n     fn from_internal(node: NonNull<InternalNode<K, V>>, height: usize) -> Self {\n@@ -695,7 +671,7 @@ impl<'a, K: 'a, V: 'a> NodeRef<marker::Mut<'a>, K, V, marker::Internal> {\n         unsafe {\n             self.reborrow_mut().into_key_area_mut_at(idx).write(key);\n             self.reborrow_mut().into_val_area_mut_at(idx).write(val);\n-            self.reborrow_mut().into_edge_area_mut_at(idx + 1).write(edge.into_boxed_node());\n+            self.reborrow_mut().into_edge_area_mut_at(idx + 1).write(edge.node);\n             Handle::new_edge(self.reborrow_mut(), idx + 1).correct_parent_link();\n         }\n     }\n@@ -710,7 +686,7 @@ impl<'a, K: 'a, V: 'a> NodeRef<marker::Mut<'a>, K, V, marker::Internal> {\n             *self.reborrow_mut().into_len_mut() += 1;\n             slice_insert(self.reborrow_mut().into_key_area_slice(), 0, key);\n             slice_insert(self.reborrow_mut().into_val_area_slice(), 0, val);\n-            slice_insert(self.reborrow_mut().into_edge_area_slice(), 0, edge.into_boxed_node());\n+            slice_insert(self.reborrow_mut().into_edge_area_slice(), 0, edge.node);\n         }\n \n         self.correct_all_childrens_parent_links();\n@@ -732,8 +708,8 @@ impl<'a, K: 'a, V: 'a> NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal> {\n             let edge = match self.reborrow_mut().force() {\n                 ForceResult::Leaf(_) => None,\n                 ForceResult::Internal(internal) => {\n-                    let boxed_node = ptr::read(internal.reborrow().edge_at(idx + 1));\n-                    let mut edge = Root::from_boxed_node(boxed_node, internal.height - 1);\n+                    let node = ptr::read(internal.reborrow().edge_at(idx + 1));\n+                    let mut edge = Root { node, height: internal.height - 1, _marker: PhantomData };\n                     // In practice, clearing the parent is a waste of time, because we will\n                     // insert the node elsewhere and set its parent link again.\n                     edge.borrow_mut().clear_parent_link();\n@@ -760,9 +736,8 @@ impl<'a, K: 'a, V: 'a> NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal> {\n             let edge = match self.reborrow_mut().force() {\n                 ForceResult::Leaf(_) => None,\n                 ForceResult::Internal(mut internal) => {\n-                    let boxed_node =\n-                        slice_remove(internal.reborrow_mut().into_edge_area_slice(), 0);\n-                    let mut edge = Root::from_boxed_node(boxed_node, internal.height - 1);\n+                    let node = slice_remove(internal.reborrow_mut().into_edge_area_slice(), 0);\n+                    let mut edge = Root { node, height: internal.height - 1, _marker: PhantomData };\n                     // In practice, clearing the parent is a waste of time, because we will\n                     // insert the node elsewhere and set its parent link again.\n                     edge.borrow_mut().clear_parent_link();\n@@ -1041,12 +1016,11 @@ impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>,\n         debug_assert!(self.node.len() < CAPACITY);\n         debug_assert!(edge.height == self.node.height - 1);\n \n-        let boxed_node = edge.into_boxed_node();\n         unsafe {\n             *self.node.reborrow_mut().into_len_mut() += 1;\n             slice_insert(self.node.reborrow_mut().into_key_area_slice(), self.idx, key);\n             slice_insert(self.node.reborrow_mut().into_val_area_slice(), self.idx, val);\n-            slice_insert(self.node.reborrow_mut().into_edge_area_slice(), self.idx + 1, boxed_node);\n+            slice_insert(self.node.reborrow_mut().into_edge_area_slice(), self.idx + 1, edge.node);\n \n             self.node.correct_childrens_parent_links((self.idx + 1)..=self.node.len());\n         }\n@@ -1135,8 +1109,8 @@ impl<BorrowType, K, V> Handle<NodeRef<BorrowType, K, V, marker::Internal>, marke\n         // reference (Rust issue #73987) and invalidate any other references\n         // to or inside the array, should any be around.\n         let parent_ptr = NodeRef::as_internal_ptr(&self.node);\n-        let boxed_node = unsafe { (*parent_ptr).edges.get_unchecked(self.idx).assume_init_read() };\n-        NodeRef::from_boxed_node(boxed_node, self.node.height - 1)\n+        let node = unsafe { (*parent_ptr).edges.get_unchecked(self.idx).assume_init_read() };\n+        NodeRef { node, height: self.node.height - 1, _marker: PhantomData }\n     }\n }\n "}, {"sha": "f4046e87b99a85779ac74cd6a55e526a9d544213", "filename": "library/alloc/src/collections/btree/set.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/53d19b37c514246acab020eaba9527cb97c421cf/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53d19b37c514246acab020eaba9527cb97c421cf/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fset.rs?ref=53d19b37c514246acab020eaba9527cb97c421cf", "patch": "@@ -220,7 +220,9 @@ impl<T: fmt::Debug> fmt::Debug for Union<'_, T> {\n const ITER_PERFORMANCE_TIPPING_SIZE_DIFF: usize = 16;\n \n impl<T: Ord> BTreeSet<T> {\n-    /// Makes a new `BTreeSet` with a reasonable choice of B.\n+    /// Makes a new, empty `BTreeSet`.\n+    ///\n+    /// Does not allocate anything on its own.\n     ///\n     /// # Examples\n     ///\n@@ -1121,7 +1123,7 @@ impl<'a, T: 'a + Ord + Copy> Extend<&'a T> for BTreeSet<T> {\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: Ord> Default for BTreeSet<T> {\n-    /// Makes an empty `BTreeSet<T>` with a reasonable choice of B.\n+    /// Creates an empty `BTreeSet`.\n     fn default() -> BTreeSet<T> {\n         BTreeSet::new()\n     }"}, {"sha": "80b74a9ba9b09229a9629c5e6bb90f750bcb630d", "filename": "library/std/src/keyword_docs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/53d19b37c514246acab020eaba9527cb97c421cf/library%2Fstd%2Fsrc%2Fkeyword_docs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53d19b37c514246acab020eaba9527cb97c421cf/library%2Fstd%2Fsrc%2Fkeyword_docs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fkeyword_docs.rs?ref=53d19b37c514246acab020eaba9527cb97c421cf", "patch": "@@ -1739,7 +1739,7 @@ mod super_keyword {}\n ///\n /// # Differences between the 2015 and 2018 editions\n ///\n-/// In the 2015 edition parameters pattern where not needed for traits:\n+/// In the 2015 edition the parameters pattern was not needed for traits:\n ///\n /// ```rust,edition2015\n /// trait Tr {"}, {"sha": "dd1986157366761f28b60fce17dfa48d20f07bb3", "filename": "src/doc/rustc/src/SUMMARY.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/53d19b37c514246acab020eaba9527cb97c421cf/src%2Fdoc%2Frustc%2Fsrc%2FSUMMARY.md", "raw_url": "https://github.com/rust-lang/rust/raw/53d19b37c514246acab020eaba9527cb97c421cf/src%2Fdoc%2Frustc%2Fsrc%2FSUMMARY.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2FSUMMARY.md?ref=53d19b37c514246acab020eaba9527cb97c421cf", "patch": "@@ -18,4 +18,5 @@\n     - [Known Issues](targets/known-issues.md)\n - [Profile-guided Optimization](profile-guided-optimization.md)\n - [Linker-plugin based LTO](linker-plugin-lto.md)\n+- [Exploit Mitigations](exploit-mitigations.md)\n - [Contributing to `rustc`](contributing.md)"}, {"sha": "44d5d9564f267a7c6f666209f41684cb48bc0534", "filename": "src/doc/rustc/src/exploit-mitigations.md", "status": "added", "additions": 693, "deletions": 0, "changes": 693, "blob_url": "https://github.com/rust-lang/rust/blob/53d19b37c514246acab020eaba9527cb97c421cf/src%2Fdoc%2Frustc%2Fsrc%2Fexploit-mitigations.md", "raw_url": "https://github.com/rust-lang/rust/raw/53d19b37c514246acab020eaba9527cb97c421cf/src%2Fdoc%2Frustc%2Fsrc%2Fexploit-mitigations.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Fexploit-mitigations.md?ref=53d19b37c514246acab020eaba9527cb97c421cf", "patch": "@@ -0,0 +1,693 @@\n+# Exploit Mitigations\n+\n+This chapter documents the exploit mitigations supported by the Rust\n+compiler, and is by no means an extensive survey of the Rust programming\n+language\u2019s security features.\n+\n+This chapter is for software engineers working with the Rust programming\n+language, and assumes prior knowledge of the Rust programming language and\n+its toolchain.\n+\n+\n+## Introduction\n+\n+The Rust programming language provides memory[1] and thread[2] safety\n+guarantees via its ownership[3], references and borrowing[4], and slice\n+types[5] features. However, Unsafe Rust[6] introduces unsafe blocks, unsafe\n+functions and methods, unsafe traits, and new types that are not subject to\n+the borrowing rules.\n+\n+Parts of the Rust standard library are implemented as safe abstractions over\n+unsafe code (and historically have been vulnerable to memory corruption[7]).\n+Furthermore, the Rust code and documentation encourage creating safe\n+abstractions over unsafe code. This can cause a false sense of security if\n+unsafe code is not properly reviewed and tested.\n+\n+Unsafe Rust introduces features that do not provide the same memory and\n+thread safety guarantees. This causes programs or libraries to be\n+susceptible to memory corruption (CWE-119)[8] and concurrency issues\n+(CWE-557)[9]. Modern C and C++ compilers provide exploit mitigations to\n+increase the difficulty to exploit vulnerabilities resulting from these\n+issues. Therefore, the Rust compiler must also support these exploit\n+mitigations in order to mitigate vulnerabilities resulting from the use of\n+Unsafe Rust. This chapter documents these exploit mitigations and how they\n+apply to Rust.\n+\n+This chapter does not discuss the effectiveness of these exploit mitigations\n+as they vary greatly depending on several factors besides their design and\n+implementation, but rather describe what they do, so their effectiveness can\n+be understood within a given context.\n+\n+\n+## Exploit mitigations\n+\n+This section documents the exploit mitigations applicable to the Rust\n+compiler when building programs for the Linux operating system on the AMD64\n+architecture and equivalent.<sup id=\"fnref:1\" role=\"doc-noteref\"><a\n+href=\"#fn:1\" class=\"footnote\">1</a></sup>\n+\n+The Rust Programming Language currently has no specification. The Rust\n+compiler (i.e., rustc) is the language reference implementation. All\n+references to \u201cthe Rust compiler\u201d in this chapter refer to the language\n+reference implementation.\n+\n+Table I \\\n+Summary of exploit mitigations supported by the Rust compiler when building\n+programs for the Linux operating system on the AMD64 architecture and\n+equivalent.\n+<table class=\"table\">\n+  <tr>\n+   <td><strong>Exploit mitigation</strong>\n+   </td>\n+   <td><strong>Supported and enabled by default</strong>\n+   </td>\n+   <td><strong>Since</strong>\n+   </td>\n+  </tr>\n+  <tr>\n+   <td>Position-independent executable\n+   </td>\n+   <td>Yes\n+   </td>\n+   <td>0.12.0 (2014-10-09)\n+   </td>\n+  </tr>\n+  <tr>\n+   <td>Integer overflow checks\n+   </td>\n+   <td>Yes (enabled when debug assertions are enabled, and disabled when debug assertions are disabled)\n+   </td>\n+   <td>1.1.0 (2015-06-25)\n+   </td>\n+  </tr>\n+  <tr>\n+   <td>Non-executable memory regions\n+   </td>\n+   <td>Yes\n+   </td>\n+   <td>1.8.0 (2016-04-14)\n+   </td>\n+  </tr>\n+  <tr>\n+   <td>Stack clashing protection\n+   </td>\n+   <td>Yes\n+   </td>\n+   <td>1.20.0 (2017-08-31)\n+   </td>\n+  </tr>\n+  <tr>\n+   <td>Read-only relocations and immediate binding\n+   </td>\n+   <td>Yes\n+   </td>\n+   <td>1.21.0 (2017-10-12)\n+   </td>\n+  </tr>\n+  <tr>\n+   <td>Heap corruption protection\n+   </td>\n+   <td>Yes\n+   </td>\n+   <td>1.32.0 (2019-01-17) (via operating system default or specified allocator)\n+   </td>\n+  </tr>\n+  <tr>\n+   <td>Stack smashing protection\n+   </td>\n+   <td>No\n+   </td>\n+   <td>\n+   </td>\n+  </tr>\n+  <tr>\n+   <td>Forward-edge control flow protection\n+   </td>\n+   <td>No\n+   </td>\n+   <td>\n+   </td>\n+  </tr>\n+  <tr>\n+   <td>Backward-edge control flow protection (e.g., shadow and safe stack)\n+   </td>\n+   <td>No\n+   </td>\n+   <td>\n+   </td>\n+  </tr>\n+</table>\n+\n+<small id=\"fn:1\">1\\. See\n+<https://github.com/rust-lang/rust/tree/master/compiler/rustc_target/src/spec>\n+for a list of targets and their default options. <a href=\"#fnref:1\"\n+class=\"reversefootnote\" role=\"doc-backlink\">\u21a9</a></small>\n+\n+\n+### Position-independent executable\n+\n+Position-independent executable increases the difficulty of the use of code\n+reuse exploitation techniques, such as return-oriented programming (ROP) and\n+variants, by generating position-independent code for the executable, and\n+instructing the dynamic linker to load it similarly to a shared object at a\n+random load address, thus also benefiting from address-space layout\n+randomization (ASLR). This is also referred to as \u201cfull ASLR\u201d.\n+\n+The Rust compiler supports position-independent executable, and enables it\n+by default since version 0.12.0 (2014-10-09)[10]\u2013[13].\n+\n+```text\n+$ readelf -h target/release/hello-rust | grep Type:\n+  Type:                              DYN (Shared object file)\n+```\n+Fig. 1.\u2003Checking if an executable is a position-independent executable.\n+\n+An executable with an object type of `ET_DYN` (i.e., shared object) and not\n+`ET_EXEC` (i.e., executable) is a position-independent executable (see Fig.\n+1).\n+\n+\n+### Integer overflow checks\n+\n+Integer overflow checks protects programs from undefined and unintended\n+behavior (which may cause vulnerabilities) by checking for results of signed\n+and unsigned integer computations that cannot be represented in their type,\n+resulting in an overflow or wraparound.\n+\n+The Rust compiler supports integer overflow checks, and enables it when\n+debug assertions are enabled since version 1.1.0 (2015-06-25)[14]\u2013[20].\n+\n+```compile_fail\n+fn main() {\n+    let u: u8 = 255;\n+    println!(\"u: {}\", u + 1);\n+}\n+```\n+Fig. 2.\u2003hello-rust-integer program.\n+\n+```text\n+$ cargo run\n+   Compiling hello-rust-integer v0.1.0 (/home/rcvalle/hello-rust-integer)\n+    Finished dev [unoptimized + debuginfo] target(s) in 0.23s\n+     Running `target/debug/hello-rust-integer`\n+thread 'main' panicked at 'attempt to add with overflow', src/main.rs:3:23\n+note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace.\n+```\n+Fig. 3.\u2003Build and execution of hello-rust-integer with debug assertions\n+enabled.\n+\n+```text\n+$ cargo run --release\n+   Compiling hello-rust-integer v0.1.0 (/home/rcvalle/hello-rust-integer)\n+    Finished release [optimized] target(s) in 0.23s\n+     Running `target/release/hello-rust-integer`\n+u: 0\n+```\n+Fig. 4.\u2003Build and execution of hello-rust-integer with debug assertions\n+disabled.\n+\n+Integer overflow checks are enabled when debug assertions are enabled (see\n+Fig. 3), and disabled when debug assertions are disabled (see Fig. 4). To\n+enable integer overflow checks independently, use the option to control\n+integer overflow checks, scoped attributes, or explicit checking methods\n+such as `checked_add`<sup id=\"fnref:2\" role=\"doc-noteref\"><a href=\"#fn:2\"\n+class=\"footnote\">2</a></sup>.\n+\n+It is recommended that explicit wrapping methods such as `wrapping_add` be\n+used when wrapping semantics are intended, and that explicit checking and\n+wrapping methods always be used when using Unsafe Rust.\n+\n+<small id=\"fn:2\">2\\. See <https://doc.rust-lang.org/std/primitive.u32.html>\n+for more information on the checked, overflowing, saturating, and wrapping\n+methods (using u32 as an example). <a href=\"#fnref:2\"\n+class=\"reversefootnote\" role=\"doc-backlink\">\u21a9</a></small>\n+\n+\n+### Non-executable memory regions\n+\n+Non-executable memory regions increase the difficulty of exploitation by\n+limiting the memory regions that can be used to execute arbitrary code. Most\n+modern processors provide support for the operating system to mark memory\n+regions as non executable, but it was previously emulated by software, such\n+as in grsecurity/PaX's\n+[PAGEEXEC](https://pax.grsecurity.net/docs/pageexec.txt) and\n+[SEGMEXEC](https://pax.grsecurity.net/docs/segmexec.txt), on processors that\n+did not provide support for it. This is also known as \u201cNo Execute (NX) Bit\u201d,\n+\u201cExecute Disable (XD) Bit\u201d, \u201cExecute Never (XN) Bit\u201d, and others.\n+\n+The Rust compiler supports non-executable memory regions, and enables it by\n+default since its initial release, version 0.1 (2012-01-20)[21], [22], but\n+has regressed since then[23]\u2013[25], and enforced by default since version\n+1.8.0 (2016-04-14)[25].\n+\n+```text\n+$ readelf -l target/release/hello-rust | grep -A 1 GNU_STACK\n+  GNU_STACK      0x0000000000000000 0x0000000000000000 0x0000000000000000\n+                 0x0000000000000000 0x0000000000000000  RW     0x10\n+```\n+Fig. 5.\u2003Checking if non-executable memory regions are enabled for a given\n+binary.\n+\n+The presence of an element of type `PT_GNU_STACK` in the program header\n+table with the `PF_X` (i.e., executable) flag unset indicates non-executable\n+memory regions<sup id=\"fnref:3\" role=\"doc-noteref\"><a href=\"#fn:3\"\n+class=\"footnote\">3</a></sup> are enabled for a given binary (see Fig. 5).\n+Conversely, the presence of an element of type `PT_GNU_STACK` in the program\n+header table with the `PF_X` flag set or the absence of an element of type\n+`PT_GNU_STACK` in the program header table indicates non-executable memory\n+regions are not enabled for a given binary.\n+\n+<small id=\"fn:3\">3\\. See the Appendix section for more information on why it\n+affects other memory regions besides the stack. <a href=\"#fnref:3\"\n+class=\"reversefootnote\" role=\"doc-backlink\">\u21a9</a></small>\n+\n+\n+### Stack clashing protection\n+\n+Stack clashing protection protects the stack from overlapping with another\n+memory region\u2014allowing arbitrary data in both to be overwritten using each\n+other\u2014by reading from the stack pages as the stack grows to cause a page\n+fault when attempting to read from the guard page/region. This is also\n+referred to as \u201cstack probes\u201d or \u201cstack probing\u201d.\n+\n+The Rust compiler supports stack clashing protection via stack probing, and\n+enables it by default since version 1.20.0 (2017-08-31)[26]\u2013[29].\n+\n+![Screenshot of IDA Pro listing cross references to __rust_probestack in hello-rust.](images/image1.png \"Cross references to __rust_probestack in hello-rust.\")\n+Fig. 6. IDA Pro listing cross references to `__rust_probestack` in\n+hello-rust.\n+\n+```rust\n+fn hello() {\n+    println!(\"Hello, world!\");\n+}\n+\n+fn main() {\n+    let _: [u64; 1024] = [0; 1024];\n+    hello();\n+}\n+```\n+Fig 7. Modified hello-rust.\n+\n+![Screenshot of IDA Pro listing cross references to __rust_probestack in modified hello-rust.](images/image2.png \"Cross references to __rust_probestack in modified hello-rust.\")\n+Fig. 8. IDA Pro listing cross references to `__rust_probestack` in modified\n+hello-rust.\n+\n+To check if stack clashing protection is enabled for a given binary, search\n+for cross references to `__rust_probestack`. The `__rust_probestack` is\n+called in the prologue of functions whose stack size is larger than a page\n+size (see Fig. 6), and can be forced for illustration purposes by modifying\n+the hello-rust example as seen in Fig. 7 and Fig. 8.\n+\n+\n+### Read-only relocations and immediate binding\n+\n+**Read-only relocations** protect segments containing relocations and\n+relocation information (i.e., `.init_array`, `.fini_array`, `.dynamic`, and\n+`.got`) from being overwritten by marking these segments read only. This is\n+also referred to as \u201cpartial RELRO\u201d.\n+\n+The Rust compiler supports read-only relocations, and enables it by default\n+since version 1.21.0 (2017-10-12)[30], [31].\n+\n+```text\n+$ readelf -l target/release/hello-rust | grep GNU_RELRO\n+  GNU_RELRO      0x000000000002ee00 0x000000000002fe00 0x000000000002fe00\n+```\n+Fig. 9.\u2003Checking if read-only relocations is enabled for a given binary.\n+\n+The presence of an element of type `PT_GNU_RELRO` in the program header\n+table indicates read-only relocations are enabled for a given binary (see\n+Fig. 9). Conversely, the absence of an element of type `PT_GNU_RELRO` in the\n+program header table indicates read-only relocations are not enabled for a\n+given binary.\n+\n+**Immediate binding** protects additional segments containing relocations\n+(i.e., `.got.plt`) from being overwritten by instructing the dynamic linker\n+to perform all relocations before transferring control to the program during\n+startup, so all segments containing relocations can be marked read only\n+(when combined with read-only relocations). This is also referred to as\n+\u201cfull RELRO\u201d.\n+\n+The Rust compiler supports immediate binding, and enables it by default\n+since version 1.21.0 (2017-10-12)[30], [31].\n+\n+```text\n+$ readelf -d target/release/hello-rust | grep BIND_NOW\n+ 0x000000000000001e (FLAGS)              BIND_NOW\n+```\n+Fig. 10.\u2003Checking if immediate binding is enabled for a given binary.\n+\n+The presence of an element with the `DT_BIND_NOW` tag and the `DF_BIND_NOW`\n+flag<sup id=\"fnref:4\" role=\"doc-noteref\"><a href=\"#fn:4\"\n+class=\"footnote\">4</a></sup> in the dynamic section indicates immediate\n+binding is enabled for a given binary (see Fig. 10). Conversely, the absence\n+of an element with the `DT_BIND_NOW` tag and the `DF_BIND_NOW` flag in the\n+dynamic section indicates immediate binding is not enabled for a given\n+binary.\n+\n+The presence of both an element of type `PT_GNU_RELRO` in the program header\n+table and of an element with the `DT_BIND_NOW` tag and the `DF_BIND_NOW`\n+flag in the dynamic section indicates full RELRO is enabled for a given\n+binary (see Fig. 9 and Fig. 10).\n+\n+<small id=\"fn:4\">4\\. And the `DF_1_NOW` flag for some link editors. <a\n+href=\"#fnref:4\" class=\"reversefootnote\" role=\"doc-backlink\">\u21a9</a></small>\n+\n+\n+### Heap corruption protection\n+\n+Heap corruption protection protects memory allocated dynamically by\n+performing several checks, such as checks for corrupted links between list\n+elements, invalid pointers, invalid sizes, double/multiple \u201cfrees\u201d of the\n+same memory allocated, and many corner cases of these. These checks are\n+implementation specific, and vary per allocator.\n+\n+[ARM Memory Tagging Extension\n+(MTE)](https://community.arm.com/developer/ip-products/processors/b/processors-ip-blog/posts/enhancing-memory-safety),\n+when available, will provide hardware assistance for a probabilistic\n+mitigation to detect memory safety violations by tagging memory allocations,\n+and automatically checking that the correct tag is used on every memory\n+access.\n+\n+Rust\u2019s default allocator has historically been\n+[jemalloc](http://jemalloc.net/), and it has long been the cause of issues\n+and the subject of much discussion[32]\u2013[38]. Consequently, it has been\n+removed as the default allocator in favor of the operating system\u2019s standard\n+C library default allocator<sup id=\"fnref:5\" role=\"doc-noteref\"><a\n+href=\"#fn:5\" class=\"footnote\">5</a></sup> since version 1.32.0\n+(2019-01-17)[39].\n+\n+```ignore\n+fn main() {\n+    let mut x = Box::new([0; 1024]);\n+\n+    for i in 0..1026 {\n+        unsafe {\n+            let elem = x.get_unchecked_mut(i);\n+            *elem = 0x4141414141414141u64;\n+        }\n+    }\n+}\n+```\n+Fig. 11.\u2003hello-rust-heap program.\n+\n+```text\n+$ cargo run\n+   Compiling hello-rust-heap v0.1.0 (/home/rcvalle/hello-rust-heap)\n+    Finished dev [unoptimized + debuginfo] target(s) in 0.25s\n+     Running `target/debug/hello-rust-heap`\n+free(): invalid next size (normal)\n+Aborted\n+```\n+Fig. 12.\u2003Build and execution of hello-rust-heap with debug assertions\n+enabled.\n+\n+```text\n+$ cargo run --release\n+   Compiling hello-rust-heap v0.1.0 (/home/rcvalle/hello-rust-heap)\n+    Finished release [optimized] target(s) in 0.25s\n+     Running `target/release/hello-rust-heap`\n+free(): invalid next size (normal)\n+Aborted\n+```\n+Fig. 13.\u2003Build and execution of hello-rust-heap with debug assertions\n+disabled.\n+\n+Heap corruption checks are being performed when using the default allocator\n+(i.e., the GNU Allocator) as seen in Fig. 12 and Fig. 13.\n+\n+<small id=\"fn:5\">5\\. Linux's standard C library default allocator is the GNU\n+Allocator, which is derived from ptmalloc (pthreads malloc) by Wolfram\n+Gloger, which in turn is derived from dlmalloc (Doug Lea malloc) by Doug\n+Lea. <a href=\"#fnref:5\" class=\"reversefootnote\"\n+role=\"doc-backlink\">\u21a9</a></small>\n+\n+\n+### Stack smashing protection\n+\n+Stack smashing protection protects programs from stack-based buffer\n+overflows by inserting a random guard value between local variables and the\n+saved return instruction pointer, and checking if this value has changed\n+when returning from a function. This is also known as \u201cStack Protector\u201d or\n+\u201cStack Smashing Protector (SSP)\u201d.\n+\n+The Rust compiler does not support stack smashing protection. However, more\n+comprehensive alternatives to stack smashing protection exist, such as\n+shadow and safe stack (see backward-edge control flow protection).\n+\n+![Screenshot of IDA Pro listing cross references to __stack_chk_fail in hello-rust.](images/image3.png \"Cross references to __stack_chk_fail in hello-rust.\")\n+Fig. 14. IDA Pro listing cross references to `__stack_chk_fail` in\n+hello-rust.\n+\n+To check if stack smashing protection is enabled for a given binary, search\n+for cross references to `__stack_chk_fail`. The only cross references to\n+`__stack_chk_fail` in hello-rust are from the statically-linked libbacktrace\n+library (see Fig. 14).\n+\n+\n+### Forward-edge control flow protection\n+\n+Forward-edge control flow protection protects programs from having its\n+control flow changed/hijacked by performing checks to ensure that\n+destinations of indirect branches are one of their valid destinations in the\n+control flow graph. The comprehensiveness of these checks vary per\n+implementation. This is also known as \u201cforward-edge control flow integrity\n+(CFI)\u201d.\n+\n+Newer processors provide hardware assistance for forward-edge control flow\n+protection, such as ARM Branch Target Identification (BTI), ARM Pointer\n+Authentication, and Intel Indirect Branch Tracking (IBT) as part of Intel\n+Control-flow Enforcement Technology (CET). However, ARM BTI and Intel IBT\n+-based implementations are less comprehensive than software-based\n+implementations such as [LLVM ControlFlowIntegrity\n+(CFI)](https://clang.llvm.org/docs/ControlFlowIntegrity.html), and the\n+commercially available [grsecurity/PaX Reuse Attack Protector\n+(RAP)](https://grsecurity.net/rap_faq).\n+\n+The Rust compiler does not support forward-edge control flow protection on\n+Linux<sup id=\"fnref:6\" role=\"doc-noteref\"><a href=\"#fn:6\"\n+class=\"footnote\">6</a></sup>. There is work currently ongoing to add support\n+for the [sanitizers](https://github.com/google/sanitizers)[40], which may or\n+may not include support for LLVM CFI.\n+\n+```text\n+$ readelf -s target/release/hello-rust | grep __cfi_init\n+```\n+Fig. 15.\u2003Checking if LLVM CFI is enabled for a given binary.\n+\n+The presence of the `__cfi_init` symbol (and references to `__cfi_check`)\n+indicates that LLVM CFI (i.e., forward-edge control flow protection) is\n+enabled for a given binary. Conversely, the absence of the `__cfi_init`\n+symbol (and references to `__cfi_check`) indicates that LLVM CFI is not\n+enabled for a given binary (see Fig. 15).\n+\n+<small id=\"fn:6\">6\\. It supports Control Flow Guard (CFG) on Windows (see\n+<https://github.com/rust-lang/rust/issues/68793>). <a href=\"#fnref:6\"\n+class=\"reversefootnote\" role=\"doc-backlink\">\u21a9</a></small>\n+\n+\n+### Backward-edge control flow protection\n+\n+**Shadow stack** protects saved return instruction pointers from being\n+overwritten by storing a copy of them on a separate (shadow) stack, and\n+using these copies as authoritative values when returning from functions.\n+This is also known as \u201cShadowCallStack\u201d and \u201cReturn Flow Guard\u201d, and is\n+considered an implementation of backward-edge control flow protection (or\n+\u201cbackward-edge CFI\u201d).\n+\n+**Safe stack** protects not only the saved return instruction pointers, but\n+also register spills and some local variables from being overwritten by\n+storing unsafe variables, such as large arrays, on a separate (unsafe)\n+stack, and using these unsafe variables on the separate stack instead. This\n+is also known as \u201cSafeStack\u201d, and is also considered an implementation of\n+backward-edge control flow protection.\n+\n+Both shadow and safe stack are intended to be a more comprehensive\n+alternatives to stack smashing protection as they protect the saved return\n+instruction pointers (and other data in the case of safe stack) from\n+arbitrary writes and non-linear out-of-bounds writes.\n+\n+Newer processors provide hardware assistance for backward-edge control flow\n+protection, such as ARM Pointer Authentication, and Intel Shadow Stack as\n+part of Intel CET.\n+\n+The Rust compiler does not support shadow or safe stack. There is work\n+currently ongoing to add support for the sanitizers[40], which may or may\n+not include support for safe stack<sup id=\"fnref:7\" role=\"doc-noteref\"><a\n+href=\"#fn:7\" class=\"footnote\">7</a></sup>.\n+\n+```text\n+$ readelf -s target/release/hello-rust | grep __safestack_init\n+```\n+Fig. 16.\u2003Checking if LLVM SafeStack is enabled for a given binary.\n+\n+The presence of the `__safestack_init` symbol indicates that LLVM SafeStack\n+is enabled for a given binary. Conversely, the absence of the\n+`__safestack_init` symbol indicates that LLVM SafeStack is not enabled for a\n+given binary (see Fig. 16).\n+\n+<small id=\"fn:7\">7\\. The shadow stack implementation for the AMD64\n+architecture and equivalent in LLVM was removed due to performance and\n+security issues. <a href=\"#fnref:7\" class=\"reversefootnote\"\n+role=\"doc-backlink\">\u21a9</a></small>\n+\n+\n+## Appendix\n+\n+As of the latest version of the [Linux Standard Base (LSB) Core\n+Specification](https://refspecs.linuxfoundation.org/LSB_5.0.0/LSB-Core-generic/LSB-Core-generic/progheader.html),\n+the `PT_GNU_STACK` program header indicates whether the stack should be\n+executable, and the absence of this header indicates that the stack should\n+be executable. However, the Linux kernel currently sets the\n+`READ_IMPLIES_EXEC` personality upon loading any executable with the\n+`PT_GNU_STACK` program header and the `PF_X `flag set or with the absence of\n+this header, resulting in not only the stack, but also all readable virtual\n+memory mappings being executable.\n+\n+An attempt to fix this [was made in\n+2012](https://lore.kernel.org/lkml/f298f914-2239-44e4-8aa1-a51282e7fac0@zmail15.collab.prod.int.phx2.redhat.com/),\n+and another [was made in\n+2020](https://lore.kernel.org/kernel-hardening/20200327064820.12602-1-keescook@chromium.org/).\n+The former never landed, and the latter partially fixed it, but introduced\n+other issues\u2014the absence of the `PT_GNU_STACK` program header still causes\n+not only the stack, but also all readable virtual memory mappings to be\n+executable in some architectures, such as IA-32 and equivalent (or causes\n+the stack to be non-executable in some architectures, such as AMD64 and\n+equivalent, contradicting the LSB).\n+\n+The `READ_IMPLIES_EXEC` personality needs to be completely separated from\n+the `PT_GNU_STACK` program header by having a separate option for it (or\n+setarch -X could just be used whenever `READ_IMPLIES_EXEC` is needed), and\n+the absence of the `PT_GNU_STACK` program header needs to have more secure\n+defaults (unrelated to `READ_IMPLIES_EXEC`).\n+\n+\n+## References\n+\n+1. D. Hosfelt. \u201cFearless security: memory safety.\u201d Mozilla Hacks.\n+   <https://hacks.mozilla.org/2019/01/fearless-security-memory-safety/>.\n+\n+2. D. Hosfelt. \u201cFearless security: thread safety.\u201d Mozilla Hacks.\n+   <https://hacks.mozilla.org/2019/02/fearless-security-thread-safety/>.\n+\n+3. S. Klabnik and C. Nichols. \u201cWhat Is Ownership?.\u201d The Rust Programming\n+   Language. <https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html>.\n+\n+4. S. Klabnik and C. Nichols. \u201cReferences and Borrowing.\u201d The Rust\n+   Programming Language.\n+   <https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html>.\n+\n+5. S. Klabnik and C. Nichols. \u201cThe Slice Type.\u201d The Rust Programming\n+   Language. <https://doc.rust-lang.org/book/ch04-03-slices.html>.\n+\n+6. S. Klabnik and C. Nichols. \u201cUnsafe Rust.\u201d The Rust Programming Language.\n+   <https://doc.rust-lang.org/book/ch19-01-unsafe-rust.html>.\n+\n+7. S. Davidoff. \u201cHow Rust\u2019s standard library was vulnerable for years and\n+   nobody noticed.\u201d Medium.\n+   <https://medium.com/@shnatsel/how-rusts-standard-library-was-vulnerable-for-years-and-nobody-noticed-aebf0503c3d6>.\n+\n+8. \u201cImproper restriction of operations within the bounds of a memory buffer\n+   (CWE-119).\u201d MITRE CWE List.\n+   <https://cwe.mitre.org/data/definitions/119.html>.\n+\n+9. \u201cConcurrency issues (CWE-557).\u201d MITRE CWE List.\n+   <https://cwe.mitre.org/data/definitions/557.html>.\n+\n+10. K. McAllister. \u201cMemory exploit mitigations #15179.\u201d GitHub.\n+    <https://github.com/rust-lang/rust/issues/15179>.\n+\n+11. K. McAllister. \u201cRFC: Memory exploit mitigation #145.\u201d GitHub.\n+    <https://github.com/rust-lang/rfcs/pull/145>.\n+\n+12. K. McAllister. \u201cRFC: Memory exploit mitigation.\u201d GitHub.\n+    <https://github.com/kmcallister/rfcs/blob/hardening/active/0000-memory-exploit-mitigation.md>.\n+\n+13. D. Micay. \u201cEnable PIE by default on Linux for full ASLR #16340.\u201d GitHub.\n+    <https://github.com/rust-lang/rust/pull/16340>.\n+\n+14. N. Matsakis. \u201cInteger overflow #560.\u201d GitHub.\n+    <https://github.com/rust-lang/rfcs/pull/560>.\n+\n+15. G. Lehel and N. Matsakis. \u201cInteger overflow.\u201d GitHub.\n+    <https://rust-lang.github.io/rfcs/0560-integer-overflow.html>.\n+\n+16. A. Turon. \u201cTracking issue for integer overflow (RFC 560) #22020.\u201d\n+    GitHub. <https://github.com/rust-lang/rust/issues/22020>.\n+\n+17. H. Wilson. \u201cMyths and legends about integer overflow in Rust.\u201d Huon on\n+    the Internet.\n+    <http://huonw.github.io/blog/2016/04/myths-and-legends-about-integer-overflow-in-rust/>.\n+\n+18. B. Anderson. \u201cStabilize -C overflow-checks #1535.\u201d GitHub.\n+    <https://github.com/rust-lang/rfcs/pull/1535>.\n+\n+19. B. Anderson. \u201cStable overflow checks.\u201d GitHub.\n+    <https://github.com/brson/rfcs/blob/overflow/text/0000-stable-overflow-checks.md>.\n+\n+20. N. Froyd. \u201cAdd -C overflow-checks option #40037.\u201d GitHub.\n+    <https://github.com/rust-lang/rust/pull/40037>.\n+\n+21. R. \u00c1. de Esp\u00edndola. \u201crustc requires executable stack #798.\u201d GitHub.\n+    <https://github.com/rust-lang/rust/issues/798>.\n+\n+22. A. Seipp. \u201cMake sure librustrt.so is linked with a non-executable stack.\n+    #1066.\u201d GitHub. <https://github.com/rust-lang/rust/pull/1066>.\n+\n+23. D. Micay. \u201cRust binaries should not have an executable stack #5643.\u201d\n+    GitHub. <https://github.com/rust-lang/rust/issues/5643>.\n+\n+24. D. Micay. \u201cMark the assembly object stacks as non-executable #5647.\u201d\n+    GitHub. <https://github.com/rust-lang/rust/pull/5647>.\n+\n+25. A. Clark. \u201cExplicitly disable stack execution on linux and bsd #30859.\u201d\n+    GitHub. <https://github.com/rust-lang/rust/pull/30859>.\n+\n+26. \u201cReplace stack overflow checking with stack probes #16012.\u201d GitHub.\n+    <https://github.com/rust-lang/rust/issues/16012>.\n+\n+27. B. Striegel. \u201cExtend stack probe support to non-tier-1 platforms, and\n+    clarify policy for mitigating LLVM-dependent unsafety #43241.\u201d GitHub.\n+    <https://github.com/rust-lang/rust/issues/43241>.\n+\n+28. A. Crichton. \u201crustc: Implement stack probes for x86 #42816.\u201d GitHub.\n+    <https://github.com/rust-lang/rust/pull/42816>.\n+\n+29. A. Crichton. \u201cAdd \\_\\_rust\\_probestack intrinsic #175.\u201d GitHub.\n+    <https://github.com/rust-lang/compiler-builtins/pull/175>.\n+\n+30. B. Anderson. \u201cConsider applying -Wl,-z,relro or -Wl,-z,relro,-z,now by\n+    default #29877.\u201d GitHub. <https://github.com/rust-lang/rust/issues/29877>.\n+\n+31. J. L\u00f6thberg. \u201cAdd support for full RELRO #43170.\u201d GitHub.\n+    <https://github.com/rust-lang/rust/pull/43170>.\n+\n+32. N. Matsakis. \u201cAllocators in Rust.\u201d Baby Steps.\n+    <http://smallcultfollowing.com/babysteps/blog/2014/11/14/allocators-in-rust/>.\n+\n+33. A. Crichton. \u201cRFC: Allow changing the default allocator #1183.\u201d GitHub.\n+    <https://github.com/rust-lang/rfcs/pull/1183>.\n+\n+34. A. Crichton. \u201cRFC: Swap out jemalloc.\u201d GitHub.\n+    <https://rust-lang.github.io/rfcs/1183-swap-out-jemalloc.html>.\n+\n+35. A. Crichton. \u201cTracking issue for changing the global, default allocator\n+    (RFC 1974) #27389.\u201d GitHub.\n+    <https://github.com/rust-lang/rust/issues/27389>.\n+\n+36. S. Fackler. \u201cPrepare global allocators for stabilization #1974.\u201d GitHub.\n+    <https://github.com/rust-lang/rfcs/pull/1974>.\n+\n+37. A. Crichton. \u201cRFC: Global allocators.\u201d GitHub.\n+    <https://rust-lang.github.io/rfcs/1974-global-allocators.html>.\n+\n+38. B. Anderson. \u201cSwitch the default global allocator to System, remove\n+    alloc\\_jemalloc, use jemallocator in rustc #36963.\u201d GitHub.\n+    <https://github.com/rust-lang/rust/issues/36963>.\n+\n+39. A. Crichton. \u201cRemove the alloc\\_jemalloc crate #55238.\u201d GitHub.\n+    <https://github.com/rust-lang/rust/pull/55238>.\n+\n+40. J. Aparicio. 2017. \u201cTracking issue for sanitizer support #39699.\u201d\n+    <https://github.com/rust-lang/rust/issues/39699>."}, {"sha": "ee2d3fd4f43c6727b5042114519e12917242c3c6", "filename": "src/doc/rustc/src/images/image1.png", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/53d19b37c514246acab020eaba9527cb97c421cf/src%2Fdoc%2Frustc%2Fsrc%2Fimages%2Fimage1.png", "raw_url": "https://github.com/rust-lang/rust/raw/53d19b37c514246acab020eaba9527cb97c421cf/src%2Fdoc%2Frustc%2Fsrc%2Fimages%2Fimage1.png", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Fimages%2Fimage1.png?ref=53d19b37c514246acab020eaba9527cb97c421cf"}, {"sha": "03061e1f0b12dced3a87d9e4e913c1d47559f578", "filename": "src/doc/rustc/src/images/image2.png", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/53d19b37c514246acab020eaba9527cb97c421cf/src%2Fdoc%2Frustc%2Fsrc%2Fimages%2Fimage2.png", "raw_url": "https://github.com/rust-lang/rust/raw/53d19b37c514246acab020eaba9527cb97c421cf/src%2Fdoc%2Frustc%2Fsrc%2Fimages%2Fimage2.png", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Fimages%2Fimage2.png?ref=53d19b37c514246acab020eaba9527cb97c421cf"}, {"sha": "a49e14b5ed22298a41d2e7bdd4b56a396b42fb94", "filename": "src/doc/rustc/src/images/image3.png", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/53d19b37c514246acab020eaba9527cb97c421cf/src%2Fdoc%2Frustc%2Fsrc%2Fimages%2Fimage3.png", "raw_url": "https://github.com/rust-lang/rust/raw/53d19b37c514246acab020eaba9527cb97c421cf/src%2Fdoc%2Frustc%2Fsrc%2Fimages%2Fimage3.png", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Fimages%2Fimage3.png?ref=53d19b37c514246acab020eaba9527cb97c421cf"}, {"sha": "b74d47a80027ad5dc455f29a94d402a1a9e12be5", "filename": "src/etc/gdb_providers.py", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/53d19b37c514246acab020eaba9527cb97c421cf/src%2Fetc%2Fgdb_providers.py", "raw_url": "https://github.com/rust-lang/rust/raw/53d19b37c514246acab020eaba9527cb97c421cf/src%2Fetc%2Fgdb_providers.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fgdb_providers.py?ref=53d19b37c514246acab020eaba9527cb97c421cf", "patch": "@@ -216,6 +216,10 @@ def cast_to_internal(node):\n             internal_type = lookup_type(internal_type_name)\n             return node.cast(internal_type.pointer())\n \n+        if node_ptr.type.name.startswith(\"alloc::collections::btree::node::BoxedNode<\"):\n+            # BACKCOMPAT: rust 1.49\n+            node_ptr = node_ptr[\"ptr\"]\n+        node_ptr = unwrap_unique_or_non_null(node_ptr)\n         leaf = node_ptr.dereference()\n         keys = leaf[\"keys\"]\n         vals = leaf[\"vals\"]\n@@ -224,9 +228,8 @@ def cast_to_internal(node):\n \n         for i in xrange(0, length + 1):\n             if height > 0:\n-                boxed_child_node = edges[i][\"value\"][\"value\"]\n-                child_node = unwrap_unique_or_non_null(boxed_child_node[\"ptr\"])\n-                for child in children_of_node(child_node, height - 1):\n+                child_ptr = edges[i][\"value\"][\"value\"]\n+                for child in children_of_node(child_ptr, height - 1):\n                     yield child\n             if i < length:\n                 # Avoid \"Cannot perform pointer math on incomplete type\" on zero-sized arrays.\n@@ -239,9 +242,6 @@ def cast_to_internal(node):\n         if root.type.name.startswith(\"core::option::Option<\"):\n             root = root.cast(gdb.lookup_type(root.type.name[21:-1]))\n         node_ptr = root[\"node\"]\n-        if node_ptr.type.name.startswith(\"alloc::collections::btree::node::BoxedNode<\"):\n-            node_ptr = node_ptr[\"ptr\"]\n-        node_ptr = unwrap_unique_or_non_null(node_ptr)\n         height = root[\"height\"]\n         for child in children_of_node(node_ptr, height):\n             yield child"}, {"sha": "e76ca1022a943f147af72b19564c5ec5232a33d4", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 49, "deletions": 53, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/53d19b37c514246acab020eaba9527cb97c421cf/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53d19b37c514246acab020eaba9527cb97c421cf/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=53d19b37c514246acab020eaba9527cb97c421cf", "patch": "@@ -234,9 +234,8 @@ impl Clean<Item> for doctree::Module<'_> {\n         items.extend(self.fns.iter().map(|x| x.clean(cx)));\n         items.extend(self.foreigns.iter().map(|x| x.clean(cx)));\n         items.extend(self.mods.iter().map(|x| x.clean(cx)));\n-        items.extend(self.items.iter().map(|x| x.clean(cx)));\n+        items.extend(self.items.iter().map(|x| x.clean(cx)).flatten());\n         items.extend(self.traits.iter().map(|x| x.clean(cx)));\n-        items.extend(self.impls.iter().flat_map(|x| x.clean(cx)));\n         items.extend(self.macros.iter().map(|x| x.clean(cx)));\n         items.extend(self.proc_macros.iter().map(|x| x.clean(cx)));\n \n@@ -1922,8 +1921,8 @@ impl Clean<BareFunctionDecl> for hir::BareFnTy<'_> {\n     }\n }\n \n-impl Clean<Item> for (&hir::Item<'_>, Option<Ident>) {\n-    fn clean(&self, cx: &DocContext<'_>) -> Item {\n+impl Clean<Vec<Item>> for (&hir::Item<'_>, Option<Ident>) {\n+    fn clean(&self, cx: &DocContext<'_>) -> Vec<Item> {\n         use hir::ItemKind;\n \n         let (item, renamed) = self;\n@@ -1977,10 +1976,11 @@ impl Clean<Item> for (&hir::Item<'_>, Option<Ident>) {\n                 fields: variant_data.fields().clean(cx),\n                 fields_stripped: false,\n             }),\n+            ItemKind::Impl { .. } => return clean_impl(item, cx),\n             _ => unreachable!(\"not yet converted\"),\n         };\n \n-        Item::from_def_id_and_parts(def_id, Some(name), kind, cx)\n+        vec![Item::from_def_id_and_parts(def_id, Some(name), kind, cx)]\n     }\n }\n \n@@ -2005,57 +2005,53 @@ impl Clean<ImplPolarity> for ty::ImplPolarity {\n     }\n }\n \n-impl Clean<Vec<Item>> for doctree::Impl<'_> {\n-    fn clean(&self, cx: &DocContext<'_>) -> Vec<Item> {\n-        let mut ret = Vec::new();\n-        let trait_ = self.trait_.clean(cx);\n-        let items = self.items.iter().map(|ii| ii.clean(cx)).collect::<Vec<_>>();\n-        let def_id = cx.tcx.hir().local_def_id(self.id);\n-\n-        // If this impl block is an implementation of the Deref trait, then we\n-        // need to try inlining the target's inherent impl blocks as well.\n-        if trait_.def_id() == cx.tcx.lang_items().deref_trait() {\n-            build_deref_target_impls(cx, &items, &mut ret);\n+fn clean_impl(impl_: &hir::Item<'_>, cx: &DocContext<'_>) -> Vec<Item> {\n+    let mut ret = Vec::new();\n+    let (trait_, items, for_, unsafety, generics) = match &impl_.kind {\n+        hir::ItemKind::Impl { of_trait, items, self_ty, unsafety, generics, .. } => {\n+            (of_trait, items, self_ty, *unsafety, generics)\n         }\n-\n-        let provided: FxHashSet<String> = trait_\n-            .def_id()\n-            .map(|did| {\n-                cx.tcx.provided_trait_methods(did).map(|meth| meth.ident.to_string()).collect()\n-            })\n-            .unwrap_or_default();\n-\n-        let for_ = self.for_.clean(cx);\n-        let type_alias = for_.def_id().and_then(|did| match cx.tcx.def_kind(did) {\n-            DefKind::TyAlias => Some(cx.tcx.type_of(did).clean(cx)),\n-            _ => None,\n+        _ => unreachable!(),\n+    };\n+    let trait_ = trait_.clean(cx);\n+    let items = items.iter().map(|ii| cx.tcx.hir().impl_item(ii.id).clean(cx)).collect::<Vec<_>>();\n+    let def_id = cx.tcx.hir().local_def_id(impl_.hir_id);\n+\n+    // If this impl block is an implementation of the Deref trait, then we\n+    // need to try inlining the target's inherent impl blocks as well.\n+    if trait_.def_id() == cx.tcx.lang_items().deref_trait() {\n+        build_deref_target_impls(cx, &items, &mut ret);\n+    }\n+\n+    let provided: FxHashSet<String> = trait_\n+        .def_id()\n+        .map(|did| cx.tcx.provided_trait_methods(did).map(|meth| meth.ident.to_string()).collect())\n+        .unwrap_or_default();\n+\n+    let for_ = for_.clean(cx);\n+    let type_alias = for_.def_id().and_then(|did| match cx.tcx.def_kind(did) {\n+        DefKind::TyAlias => Some(cx.tcx.type_of(did).clean(cx)),\n+        _ => None,\n+    });\n+    let make_item = |trait_: Option<Type>, for_: Type, items: Vec<Item>| {\n+        let kind = ImplItem(Impl {\n+            unsafety,\n+            generics: generics.clean(cx),\n+            provided_trait_methods: provided.clone(),\n+            trait_,\n+            for_,\n+            items,\n+            polarity: Some(cx.tcx.impl_polarity(def_id).clean(cx)),\n+            synthetic: false,\n+            blanket_impl: None,\n         });\n-        let make_item = |trait_: Option<Type>, for_: Type, items: Vec<Item>| Item {\n-            name: None,\n-            attrs: self.attrs.clean(cx),\n-            source: self.span.clean(cx),\n-            def_id: def_id.to_def_id(),\n-            visibility: self.vis.clean(cx),\n-            stability: cx.stability(self.id),\n-            deprecation: cx.deprecation(self.id).clean(cx),\n-            kind: ImplItem(Impl {\n-                unsafety: self.unsafety,\n-                generics: self.generics.clean(cx),\n-                provided_trait_methods: provided.clone(),\n-                trait_,\n-                for_,\n-                items,\n-                polarity: Some(cx.tcx.impl_polarity(def_id).clean(cx)),\n-                synthetic: false,\n-                blanket_impl: None,\n-            }),\n-        };\n-        if let Some(type_alias) = type_alias {\n-            ret.push(make_item(trait_.clone(), type_alias, items.clone()));\n-        }\n-        ret.push(make_item(trait_, for_, items));\n-        ret\n+        Item::from_hir_id_and_parts(impl_.hir_id, None, kind, cx)\n+    };\n+    if let Some(type_alias) = type_alias {\n+        ret.push(make_item(trait_.clone(), type_alias, items.clone()));\n     }\n+    ret.push(make_item(trait_, for_, items));\n+    ret\n }\n \n impl Clean<Vec<Item>> for doctree::ExternCrate<'_> {"}, {"sha": "b7cc0f1945911bf909c08e09ceda54b2ba034fe2", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/53d19b37c514246acab020eaba9527cb97c421cf/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53d19b37c514246acab020eaba9527cb97c421cf/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=53d19b37c514246acab020eaba9527cb97c421cf", "patch": "@@ -1,4 +1,3 @@\n-use rustc_attr as attr;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::sync::{self, Lrc};\n use rustc_driver::abort_on_err;\n@@ -156,21 +155,6 @@ impl<'tcx> DocContext<'tcx> {\n             def_id.as_local().map(|def_id| self.tcx.hir().local_def_id_to_hir_id(def_id))\n         }\n     }\n-\n-    crate fn stability(&self, id: HirId) -> Option<attr::Stability> {\n-        self.tcx\n-            .hir()\n-            .opt_local_def_id(id)\n-            .and_then(|def_id| self.tcx.lookup_stability(def_id.to_def_id()))\n-            .cloned()\n-    }\n-\n-    crate fn deprecation(&self, id: HirId) -> Option<attr::Deprecation> {\n-        self.tcx\n-            .hir()\n-            .opt_local_def_id(id)\n-            .and_then(|def_id| self.tcx.lookup_deprecation(def_id.to_def_id()))\n-    }\n }\n \n /// Creates a new diagnostic `Handler` that can be used to emit warnings and errors."}, {"sha": "4d2fe04123bc2489c982d8d4da0c2af3ac5f2052", "filename": "src/librustdoc/doctree.rs", "status": "modified", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/53d19b37c514246acab020eaba9527cb97c421cf/src%2Flibrustdoc%2Fdoctree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53d19b37c514246acab020eaba9527cb97c421cf/src%2Flibrustdoc%2Fdoctree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdoctree.rs?ref=53d19b37c514246acab020eaba9527cb97c421cf", "patch": "@@ -23,7 +23,6 @@ crate struct Module<'hir> {\n     // (item, renamed)\n     crate items: Vec<(&'hir hir::Item<'hir>, Option<Ident>)>,\n     crate traits: Vec<Trait<'hir>>,\n-    crate impls: Vec<Impl<'hir>>,\n     crate foreigns: Vec<ForeignItem<'hir>>,\n     crate macros: Vec<Macro>,\n     crate proc_macros: Vec<ProcMacro>,\n@@ -44,7 +43,6 @@ impl Module<'hir> {\n             mods: Vec::new(),\n             items: Vec::new(),\n             traits: Vec::new(),\n-            impls: Vec::new(),\n             foreigns: Vec::new(),\n             macros: Vec::new(),\n             proc_macros: Vec::new(),\n@@ -89,22 +87,6 @@ crate struct Trait<'hir> {\n     crate id: hir::HirId,\n }\n \n-#[derive(Debug)]\n-crate struct Impl<'hir> {\n-    crate unsafety: hir::Unsafety,\n-    crate polarity: hir::ImplPolarity,\n-    crate defaultness: hir::Defaultness,\n-    crate constness: hir::Constness,\n-    crate generics: &'hir hir::Generics<'hir>,\n-    crate trait_: &'hir Option<hir::TraitRef<'hir>>,\n-    crate for_: &'hir hir::Ty<'hir>,\n-    crate items: Vec<&'hir hir::ImplItem<'hir>>,\n-    crate attrs: &'hir [ast::Attribute],\n-    crate span: Span,\n-    crate vis: &'hir hir::Visibility<'hir>,\n-    crate id: hir::HirId,\n-}\n-\n crate struct ForeignItem<'hir> {\n     crate id: hir::HirId,\n     crate name: Symbol,"}, {"sha": "285fabdc3723040d86124f21c78f7e00d13d2ade", "filename": "src/librustdoc/fold.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/53d19b37c514246acab020eaba9527cb97c421cf/src%2Flibrustdoc%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53d19b37c514246acab020eaba9527cb97c421cf/src%2Flibrustdoc%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ffold.rs?ref=53d19b37c514246acab020eaba9527cb97c421cf", "patch": "@@ -16,7 +16,7 @@ impl StripItem {\n \n crate trait DocFolder: Sized {\n     fn fold_item(&mut self, item: Item) -> Option<Item> {\n-        self.fold_item_recur(item)\n+        Some(self.fold_item_recur(item))\n     }\n \n     /// don't override!\n@@ -71,15 +71,12 @@ crate trait DocFolder: Sized {\n     }\n \n     /// don't override!\n-    fn fold_item_recur(&mut self, item: Item) -> Option<Item> {\n-        let Item { attrs, name, source, visibility, def_id, kind, stability, deprecation } = item;\n-\n-        let kind = match kind {\n+    fn fold_item_recur(&mut self, mut item: Item) -> Item {\n+        item.kind = match item.kind {\n             StrippedItem(box i) => StrippedItem(box self.fold_inner_recur(i)),\n-            _ => self.fold_inner_recur(kind),\n+            _ => self.fold_inner_recur(item.kind),\n         };\n-\n-        Some(Item { attrs, name, source, kind, visibility, stability, deprecation, def_id })\n+        item\n     }\n \n     fn fold_mod(&mut self, m: Module) -> Module {"}, {"sha": "39b750279ac5bc22a9ada679b7086bea10e5ed2e", "filename": "src/librustdoc/formats/cache.rs", "status": "modified", "additions": 37, "deletions": 40, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/53d19b37c514246acab020eaba9527cb97c421cf/src%2Flibrustdoc%2Fformats%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53d19b37c514246acab020eaba9527cb97c421cf/src%2Flibrustdoc%2Fformats%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fformats%2Fcache.rs?ref=53d19b37c514246acab020eaba9527cb97c421cf", "patch": "@@ -421,55 +421,52 @@ impl DocFolder for Cache {\n \n         // Once we've recursively found all the generics, hoard off all the\n         // implementations elsewhere.\n-        let ret = self.fold_item_recur(item).and_then(|item| {\n-            if let clean::Item { kind: clean::ImplItem(_), .. } = item {\n-                // Figure out the id of this impl. This may map to a\n-                // primitive rather than always to a struct/enum.\n-                // Note: matching twice to restrict the lifetime of the `i` borrow.\n-                let mut dids = FxHashSet::default();\n-                if let clean::Item { kind: clean::ImplItem(ref i), .. } = item {\n-                    match i.for_ {\n-                        clean::ResolvedPath { did, .. }\n-                        | clean::BorrowedRef {\n-                            type_: box clean::ResolvedPath { did, .. }, ..\n-                        } => {\n-                            dids.insert(did);\n-                        }\n-                        ref t => {\n-                            let did = t\n-                                .primitive_type()\n-                                .and_then(|t| self.primitive_locations.get(&t).cloned());\n+        let item = self.fold_item_recur(item);\n+        let ret = if let clean::Item { kind: clean::ImplItem(_), .. } = item {\n+            // Figure out the id of this impl. This may map to a\n+            // primitive rather than always to a struct/enum.\n+            // Note: matching twice to restrict the lifetime of the `i` borrow.\n+            let mut dids = FxHashSet::default();\n+            if let clean::Item { kind: clean::ImplItem(ref i), .. } = item {\n+                match i.for_ {\n+                    clean::ResolvedPath { did, .. }\n+                    | clean::BorrowedRef { type_: box clean::ResolvedPath { did, .. }, .. } => {\n+                        dids.insert(did);\n+                    }\n+                    ref t => {\n+                        let did = t\n+                            .primitive_type()\n+                            .and_then(|t| self.primitive_locations.get(&t).cloned());\n \n-                            if let Some(did) = did {\n-                                dids.insert(did);\n-                            }\n+                        if let Some(did) = did {\n+                            dids.insert(did);\n                         }\n                     }\n+                }\n \n-                    if let Some(generics) = i.trait_.as_ref().and_then(|t| t.generics()) {\n-                        for bound in generics {\n-                            if let Some(did) = bound.def_id() {\n-                                dids.insert(did);\n-                            }\n+                if let Some(generics) = i.trait_.as_ref().and_then(|t| t.generics()) {\n+                    for bound in generics {\n+                        if let Some(did) = bound.def_id() {\n+                            dids.insert(did);\n                         }\n                     }\n-                } else {\n-                    unreachable!()\n-                };\n-                let impl_item = Impl { impl_item: item };\n-                if impl_item.trait_did().map_or(true, |d| self.traits.contains_key(&d)) {\n-                    for did in dids {\n-                        self.impls.entry(did).or_insert(vec![]).push(impl_item.clone());\n-                    }\n-                } else {\n-                    let trait_did = impl_item.trait_did().expect(\"no trait did\");\n-                    self.orphan_trait_impls.push((trait_did, dids, impl_item));\n                 }\n-                None\n             } else {\n-                Some(item)\n+                unreachable!()\n+            };\n+            let impl_item = Impl { impl_item: item };\n+            if impl_item.trait_did().map_or(true, |d| self.traits.contains_key(&d)) {\n+                for did in dids {\n+                    self.impls.entry(did).or_insert(vec![]).push(impl_item.clone());\n+                }\n+            } else {\n+                let trait_did = impl_item.trait_did().expect(\"no trait did\");\n+                self.orphan_trait_impls.push((trait_did, dids, impl_item));\n             }\n-        });\n+            None\n+        } else {\n+            Some(item)\n+        };\n \n         if pushed {\n             self.stack.pop().expect(\"stack already empty\");"}, {"sha": "e7b5a90d84df0c311be9973f911dfb95e154b714", "filename": "src/librustdoc/html/sources.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/53d19b37c514246acab020eaba9527cb97c421cf/src%2Flibrustdoc%2Fhtml%2Fsources.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53d19b37c514246acab020eaba9527cb97c421cf/src%2Flibrustdoc%2Fhtml%2Fsources.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fsources.rs?ref=53d19b37c514246acab020eaba9527cb97c421cf", "patch": "@@ -60,7 +60,7 @@ impl<'a> DocFolder for SourceCollector<'a> {\n                 }\n             };\n         }\n-        self.fold_item_recur(item)\n+        Some(self.fold_item_recur(item))\n     }\n }\n "}, {"sha": "3f9978c8fca84ef1df1c33b34aaf4d7b944595e4", "filename": "src/librustdoc/passes/calculate_doc_coverage.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/53d19b37c514246acab020eaba9527cb97c421cf/src%2Flibrustdoc%2Fpasses%2Fcalculate_doc_coverage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53d19b37c514246acab020eaba9527cb97c421cf/src%2Flibrustdoc%2Fpasses%2Fcalculate_doc_coverage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcalculate_doc_coverage.rs?ref=53d19b37c514246acab020eaba9527cb97c421cf", "patch": "@@ -268,6 +268,6 @@ impl<'a, 'b> fold::DocFolder for CoverageCalculator<'a, 'b> {\n             }\n         }\n \n-        self.fold_item_recur(i)\n+        Some(self.fold_item_recur(i))\n     }\n }"}, {"sha": "0c76dc571beee1406cbdf25cad38f0587c358d6c", "filename": "src/librustdoc/passes/check_code_block_syntax.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/53d19b37c514246acab020eaba9527cb97c421cf/src%2Flibrustdoc%2Fpasses%2Fcheck_code_block_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53d19b37c514246acab020eaba9527cb97c421cf/src%2Flibrustdoc%2Fpasses%2Fcheck_code_block_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcheck_code_block_syntax.rs?ref=53d19b37c514246acab020eaba9527cb97c421cf", "patch": "@@ -105,7 +105,7 @@ impl<'a, 'tcx> DocFolder for SyntaxChecker<'a, 'tcx> {\n             }\n         }\n \n-        self.fold_item_recur(item)\n+        Some(self.fold_item_recur(item))\n     }\n }\n "}, {"sha": "e1ba75baa0fa48ac47e6e9355716a436921a7e1e", "filename": "src/librustdoc/passes/collapse_docs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/53d19b37c514246acab020eaba9527cb97c421cf/src%2Flibrustdoc%2Fpasses%2Fcollapse_docs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53d19b37c514246acab020eaba9527cb97c421cf/src%2Flibrustdoc%2Fpasses%2Fcollapse_docs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollapse_docs.rs?ref=53d19b37c514246acab020eaba9527cb97c421cf", "patch": "@@ -23,7 +23,7 @@ struct Collapser;\n impl fold::DocFolder for Collapser {\n     fn fold_item(&mut self, mut i: Item) -> Option<Item> {\n         i.attrs.collapse_doc_comments();\n-        self.fold_item_recur(i)\n+        Some(self.fold_item_recur(i))\n     }\n }\n "}, {"sha": "6aa46b24a0e96df442f56ca1689f922eea05c737", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/53d19b37c514246acab020eaba9527cb97c421cf/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53d19b37c514246acab020eaba9527cb97c421cf/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=53d19b37c514246acab020eaba9527cb97c421cf", "patch": "@@ -858,7 +858,7 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n             // we don't display docs on `extern crate` items anyway, so don't process them.\n             clean::ExternCrateItem(..) => {\n                 debug!(\"ignoring extern crate item {:?}\", item.def_id);\n-                return self.fold_item_recur(item);\n+                return Some(self.fold_item_recur(item));\n             }\n             clean::ImportItem(Import { kind: clean::ImportKind::Simple(ref name, ..), .. }) => {\n                 Some(name.clone())\n@@ -958,7 +958,7 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n             }\n         }\n \n-        if item.is_mod() {\n+        Some(if item.is_mod() {\n             if !item.attrs.inner_docs {\n                 self.mod_ids.push(item.def_id);\n             }\n@@ -968,7 +968,7 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n             ret\n         } else {\n             self.fold_item_recur(item)\n-        }\n+        })\n     }\n }\n \n@@ -1022,7 +1022,7 @@ impl LinkCollector<'_, '_> {\n             (link.trim(), None)\n         };\n \n-        if path_str.contains(|ch: char| !(ch.is_alphanumeric() || \":_<>, \".contains(ch))) {\n+        if path_str.contains(|ch: char| !(ch.is_alphanumeric() || \":_<>, !\".contains(ch))) {\n             return None;\n         }\n "}, {"sha": "4c3defabc3294bb8f95bda70fcf8bca9635c2721", "filename": "src/librustdoc/passes/collect_trait_impls.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/53d19b37c514246acab020eaba9527cb97c421cf/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53d19b37c514246acab020eaba9527cb97c421cf/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs?ref=53d19b37c514246acab020eaba9527cb97c421cf", "patch": "@@ -133,7 +133,7 @@ impl<'a, 'tcx> DocFolder for SyntheticImplCollector<'a, 'tcx> {\n             }\n         }\n \n-        self.fold_item_recur(i)\n+        Some(self.fold_item_recur(i))\n     }\n }\n \n@@ -152,7 +152,7 @@ impl DocFolder for ItemCollector {\n     fn fold_item(&mut self, i: Item) -> Option<Item> {\n         self.items.insert(i.def_id);\n \n-        self.fold_item_recur(i)\n+        Some(self.fold_item_recur(i))\n     }\n }\n "}, {"sha": "299a73c8a0112453f6d1f87f3c62607c35125b5c", "filename": "src/librustdoc/passes/doc_test_lints.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/53d19b37c514246acab020eaba9527cb97c421cf/src%2Flibrustdoc%2Fpasses%2Fdoc_test_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53d19b37c514246acab020eaba9527cb97c421cf/src%2Flibrustdoc%2Fpasses%2Fdoc_test_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fdoc_test_lints.rs?ref=53d19b37c514246acab020eaba9527cb97c421cf", "patch": "@@ -41,7 +41,7 @@ impl<'a, 'tcx> DocFolder for PrivateItemDocTestLinter<'a, 'tcx> {\n \n         look_for_tests(&cx, &dox, &item);\n \n-        self.fold_item_recur(item)\n+        Some(self.fold_item_recur(item))\n     }\n }\n "}, {"sha": "a7a1ba1118d1fdca65a325bdfe1be69709719c24", "filename": "src/librustdoc/passes/html_tags.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/53d19b37c514246acab020eaba9527cb97c421cf/src%2Flibrustdoc%2Fpasses%2Fhtml_tags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53d19b37c514246acab020eaba9527cb97c421cf/src%2Flibrustdoc%2Fpasses%2Fhtml_tags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fhtml_tags.rs?ref=53d19b37c514246acab020eaba9527cb97c421cf", "patch": "@@ -178,7 +178,7 @@ impl<'a, 'tcx> DocFolder for InvalidHtmlTagsLinter<'a, 'tcx> {\n             Some(hir_id) => hir_id,\n             None => {\n                 // If non-local, no need to check anything.\n-                return self.fold_item_recur(item);\n+                return Some(self.fold_item_recur(item));\n             }\n         };\n         let dox = item.attrs.collapsed_doc_value().unwrap_or_default();\n@@ -223,6 +223,6 @@ impl<'a, 'tcx> DocFolder for InvalidHtmlTagsLinter<'a, 'tcx> {\n             }\n         }\n \n-        self.fold_item_recur(item)\n+        Some(self.fold_item_recur(item))\n     }\n }"}, {"sha": "1f411b997f80250e5734e55f8151091f0d7674bc", "filename": "src/librustdoc/passes/non_autolinks.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/53d19b37c514246acab020eaba9527cb97c421cf/src%2Flibrustdoc%2Fpasses%2Fnon_autolinks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53d19b37c514246acab020eaba9527cb97c421cf/src%2Flibrustdoc%2Fpasses%2Fnon_autolinks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fnon_autolinks.rs?ref=53d19b37c514246acab020eaba9527cb97c421cf", "patch": "@@ -68,7 +68,7 @@ impl<'a, 'tcx> DocFolder for NonAutolinksLinter<'a, 'tcx> {\n             Some(hir_id) => hir_id,\n             None => {\n                 // If non-local, no need to check anything.\n-                return self.fold_item_recur(item);\n+                return Some(self.fold_item_recur(item));\n             }\n         };\n         let dox = item.attrs.collapsed_doc_value().unwrap_or_default();\n@@ -133,6 +133,6 @@ impl<'a, 'tcx> DocFolder for NonAutolinksLinter<'a, 'tcx> {\n             }\n         }\n \n-        self.fold_item_recur(item)\n+        Some(self.fold_item_recur(item))\n     }\n }"}, {"sha": "6722d7c2fc9feaa998c9e3857b9e17ba6a5b3725", "filename": "src/librustdoc/passes/propagate_doc_cfg.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/53d19b37c514246acab020eaba9527cb97c421cf/src%2Flibrustdoc%2Fpasses%2Fpropagate_doc_cfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53d19b37c514246acab020eaba9527cb97c421cf/src%2Flibrustdoc%2Fpasses%2Fpropagate_doc_cfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fpropagate_doc_cfg.rs?ref=53d19b37c514246acab020eaba9527cb97c421cf", "patch": "@@ -39,6 +39,6 @@ impl DocFolder for CfgPropagator {\n         let result = self.fold_item_recur(item);\n         self.parent_cfg = old_parent_cfg;\n \n-        result\n+        Some(result)\n     }\n }"}, {"sha": "6b59eb8cf288a8246ad06462d92e1c9e93fc41d2", "filename": "src/librustdoc/passes/strip_hidden.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/53d19b37c514246acab020eaba9527cb97c421cf/src%2Flibrustdoc%2Fpasses%2Fstrip_hidden.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53d19b37c514246acab020eaba9527cb97c421cf/src%2Flibrustdoc%2Fpasses%2Fstrip_hidden.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fstrip_hidden.rs?ref=53d19b37c514246acab020eaba9527cb97c421cf", "patch": "@@ -47,7 +47,7 @@ impl<'a> DocFolder for Stripper<'a> {\n                     // strip things like impl methods but when doing so\n                     // we must not add any items to the `retained` set.\n                     let old = mem::replace(&mut self.update_retained, false);\n-                    let ret = StripItem(self.fold_item_recur(i).unwrap()).strip();\n+                    let ret = StripItem(self.fold_item_recur(i)).strip();\n                     self.update_retained = old;\n                     return ret;\n                 }\n@@ -58,6 +58,6 @@ impl<'a> DocFolder for Stripper<'a> {\n                 self.retained.insert(i.def_id);\n             }\n         }\n-        self.fold_item_recur(i)\n+        Some(self.fold_item_recur(i))\n     }\n }"}, {"sha": "444fd593ec9c9856bef17f84fca3cfe3fdbb4f7d", "filename": "src/librustdoc/passes/stripper.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/53d19b37c514246acab020eaba9527cb97c421cf/src%2Flibrustdoc%2Fpasses%2Fstripper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53d19b37c514246acab020eaba9527cb97c421cf/src%2Flibrustdoc%2Fpasses%2Fstripper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fstripper.rs?ref=53d19b37c514246acab020eaba9527cb97c421cf", "patch": "@@ -22,7 +22,7 @@ impl<'a> DocFolder for Stripper<'a> {\n                 let old = mem::replace(&mut self.update_retained, false);\n                 let ret = self.fold_item_recur(i);\n                 self.update_retained = old;\n-                return ret;\n+                return Some(ret);\n             }\n             // These items can all get re-exported\n             clean::OpaqueTyItem(..)\n@@ -59,7 +59,7 @@ impl<'a> DocFolder for Stripper<'a> {\n                 if i.def_id.is_local() && !i.visibility.is_public() {\n                     debug!(\"Stripper: stripping module {:?}\", i.name);\n                     let old = mem::replace(&mut self.update_retained, false);\n-                    let ret = StripItem(self.fold_item_recur(i).unwrap()).strip();\n+                    let ret = StripItem(self.fold_item_recur(i)).strip();\n                     self.update_retained = old;\n                     return ret;\n                 }\n@@ -107,12 +107,10 @@ impl<'a> DocFolder for Stripper<'a> {\n             self.fold_item_recur(i)\n         };\n \n-        if let Some(ref i) = i {\n-            if self.update_retained {\n-                self.retained.insert(i.def_id);\n-            }\n+        if self.update_retained {\n+            self.retained.insert(i.def_id);\n         }\n-        i\n+        Some(i)\n     }\n }\n \n@@ -153,7 +151,7 @@ impl<'a> DocFolder for ImplStripper<'a> {\n                 }\n             }\n         }\n-        self.fold_item_recur(i)\n+        Some(self.fold_item_recur(i))\n     }\n }\n \n@@ -164,7 +162,7 @@ impl DocFolder for ImportStripper {\n     fn fold_item(&mut self, i: Item) -> Option<Item> {\n         match i.kind {\n             clean::ExternCrateItem(..) | clean::ImportItem(..) if !i.visibility.is_public() => None,\n-            _ => self.fold_item_recur(i),\n+            _ => Some(self.fold_item_recur(i)),\n         }\n     }\n }"}, {"sha": "d0345d1e48cb5958726d3cbcecb182bd58aa5be8", "filename": "src/librustdoc/passes/unindent_comments.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/53d19b37c514246acab020eaba9527cb97c421cf/src%2Flibrustdoc%2Fpasses%2Funindent_comments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53d19b37c514246acab020eaba9527cb97c421cf/src%2Flibrustdoc%2Fpasses%2Funindent_comments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Funindent_comments.rs?ref=53d19b37c514246acab020eaba9527cb97c421cf", "patch": "@@ -23,7 +23,7 @@ struct CommentCleaner;\n impl fold::DocFolder for CommentCleaner {\n     fn fold_item(&mut self, mut i: Item) -> Option<Item> {\n         i.attrs.unindent_doc_comments();\n-        self.fold_item_recur(i)\n+        Some(self.fold_item_recur(i))\n     }\n }\n "}, {"sha": "37050a57ca0173c6c0b0b756ce4fc0b68a34f680", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 2, "deletions": 28, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/53d19b37c514246acab020eaba9527cb97c421cf/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53d19b37c514246acab020eaba9527cb97c421cf/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=53d19b37c514246acab020eaba9527cb97c421cf", "patch": "@@ -401,37 +401,11 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                 };\n                 om.traits.push(t);\n             }\n-            hir::ItemKind::Impl {\n-                unsafety,\n-                polarity,\n-                defaultness,\n-                constness,\n-                defaultness_span: _,\n-                ref generics,\n-                ref of_trait,\n-                self_ty,\n-                ref items,\n-            } => {\n+            hir::ItemKind::Impl { ref of_trait, .. } => {\n                 // Don't duplicate impls when inlining or if it's implementing a trait, we'll pick\n                 // them up regardless of where they're located.\n                 if !self.inlining && of_trait.is_none() {\n-                    let items =\n-                        items.iter().map(|item| self.cx.tcx.hir().impl_item(item.id)).collect();\n-                    let i = Impl {\n-                        unsafety,\n-                        polarity,\n-                        defaultness,\n-                        constness,\n-                        generics,\n-                        trait_: of_trait,\n-                        for_: self_ty,\n-                        items,\n-                        attrs: &item.attrs,\n-                        id: item.hir_id,\n-                        span: item.span,\n-                        vis: &item.vis,\n-                    };\n-                    om.impls.push(i);\n+                    om.items.push((item, None));\n                 }\n             }\n         }"}, {"sha": "53a926d49efe742eb193549275905209dac349bb", "filename": "src/test/codegen/fewer-names.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/53d19b37c514246acab020eaba9527cb97c421cf/src%2Ftest%2Fcodegen%2Ffewer-names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53d19b37c514246acab020eaba9527cb97c421cf/src%2Ftest%2Fcodegen%2Ffewer-names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Ffewer-names.rs?ref=53d19b37c514246acab020eaba9527cb97c421cf", "patch": "@@ -0,0 +1,20 @@\n+// no-system-llvm\n+// compile-flags: -Coverflow-checks=no -O\n+// revisions: YES NO\n+// [YES]compile-flags: -Zfewer-names=yes\n+// [NO] compile-flags: -Zfewer-names=no\n+#![crate_type = \"lib\"]\n+\n+#[no_mangle]\n+pub fn sum(x: u32, y: u32) -> u32 {\n+// YES-LABEL: define i32 @sum(i32 %0, i32 %1)\n+// YES-NEXT:    %3 = add i32 %1, %0\n+// YES-NEXT:    ret i32 %3\n+\n+// NO-LABEL: define i32 @sum(i32 %x, i32 %y)\n+// NO-NEXT:  start:\n+// NO-NEXT:    %z = add i32 %y, %x\n+// NO-NEXT:    ret i32 %z\n+    let z = x + y;\n+    z\n+}"}, {"sha": "be98cac94ece71e522fd97a923b02b48e12c238f", "filename": "src/test/rustdoc-ui/intra-link-errors.stderr", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/53d19b37c514246acab020eaba9527cb97c421cf/src%2Ftest%2Frustdoc-ui%2Fintra-link-errors.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/53d19b37c514246acab020eaba9527cb97c421cf/src%2Ftest%2Frustdoc-ui%2Fintra-link-errors.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fintra-link-errors.stderr?ref=53d19b37c514246acab020eaba9527cb97c421cf", "patch": "@@ -106,6 +106,15 @@ LL | /// [S!]\n    |      this link resolves to the struct `S`, which is not in the macro namespace\n    |      help: to link to the struct, prefix with `struct@`: `struct@S`\n \n+error: unresolved link to `S::h`\n+  --> $DIR/intra-link-errors.rs:78:6\n+   |\n+LL | /// [type@S::h]\n+   |      ^^^^^^^^^\n+   |      |\n+   |      this link resolves to the associated function `h`, which is not in the type namespace\n+   |      help: to link to the associated function, add parentheses: `S::h()`\n+\n error: unresolved link to `T::g`\n   --> $DIR/intra-link-errors.rs:86:6\n    |\n@@ -121,15 +130,6 @@ error: unresolved link to `T::h`\n LL | /// [T::h!]\n    |      ^^^^^ the trait `T` has no macro named `h`\n \n-error: unresolved link to `S::h`\n-  --> $DIR/intra-link-errors.rs:78:6\n-   |\n-LL | /// [type@S::h]\n-   |      ^^^^^^^^^\n-   |      |\n-   |      this link resolves to the associated function `h`, which is not in the type namespace\n-   |      help: to link to the associated function, add parentheses: `S::h()`\n-\n error: unresolved link to `m`\n   --> $DIR/intra-link-errors.rs:98:6\n    |"}, {"sha": "1de6410f10c430c2c4520d639349230a7f22112d", "filename": "src/test/rustdoc/intra-doc-link-generic-params.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/53d19b37c514246acab020eaba9527cb97c421cf/src%2Ftest%2Frustdoc%2Fintra-doc-link-generic-params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53d19b37c514246acab020eaba9527cb97c421cf/src%2Ftest%2Frustdoc%2Fintra-doc-link-generic-params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fintra-doc-link-generic-params.rs?ref=53d19b37c514246acab020eaba9527cb97c421cf", "patch": "@@ -15,8 +15,11 @@\n // @has foo/index.html '//a[@href=\"https://doc.rust-lang.org/nightly/core/option/enum.Option.html\"]' 'with the generic, Option<T>'\n \n //! We should also try linking to [`Result<T, E>`]; it has *two* generics!\n+//! And [`Result<T, !>`] and [`Result<!, E>`].\n //!\n // @has foo/index.html '//a[@href=\"https://doc.rust-lang.org/nightly/core/result/enum.Result.html\"]' 'Result<T, E>'\n+// @has foo/index.html '//a[@href=\"https://doc.rust-lang.org/nightly/core/result/enum.Result.html\"]' 'Result<T, !>'\n+// @has foo/index.html '//a[@href=\"https://doc.rust-lang.org/nightly/core/result/enum.Result.html\"]' 'Result<!, E>'\n \n //! Now let's test a trickier case: [`Vec::<T>::new`], or you could write it\n //! [with parentheses as `Vec::<T>::new()`][Vec::<T>::new()]."}, {"sha": "73c9ea59c955bddc4f9f1c4005afc148899f0f7f", "filename": "src/test/ui/const-generics/array-size-in-generic-struct-param.min.stderr", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/53d19b37c514246acab020eaba9527cb97c421cf/src%2Ftest%2Fui%2Fconst-generics%2Farray-size-in-generic-struct-param.min.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/53d19b37c514246acab020eaba9527cb97c421cf/src%2Ftest%2Fui%2Fconst-generics%2Farray-size-in-generic-struct-param.min.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Farray-size-in-generic-struct-param.min.stderr?ref=53d19b37c514246acab020eaba9527cb97c421cf", "patch": "@@ -5,6 +5,7 @@ LL | struct ArithArrayLen<const N: usize>([u32; 0 + N]);\n    |                                                ^ cannot perform const operation using `N`\n    |\n    = help: const parameters may only be used as standalone arguments, i.e. `N`\n+   = help: use `#![feature(const_generics)]` and `#![feature(const_evaluatable_checked)]` to allow generic const expressions\n \n error: generic parameters may not be used in const operations\n   --> $DIR/array-size-in-generic-struct-param.rs:20:15\n@@ -13,6 +14,7 @@ LL |     arr: [u8; CFG.arr_size],\n    |               ^^^ cannot perform const operation using `CFG`\n    |\n    = help: const parameters may only be used as standalone arguments, i.e. `CFG`\n+   = help: use `#![feature(const_generics)]` and `#![feature(const_evaluatable_checked)]` to allow generic const expressions\n \n error: `Config` is forbidden as the type of a const generic parameter\n   --> $DIR/array-size-in-generic-struct-param.rs:18:21\n@@ -21,7 +23,7 @@ LL | struct B<const CFG: Config> {\n    |                     ^^^^^^\n    |\n    = note: the only supported types are integers, `bool` and `char`\n-   = note: more complex types are supported with `#[feature(const_generics)]`\n+   = help: more complex types are supported with `#[feature(const_generics)]`\n \n error: aborting due to 3 previous errors\n "}, {"sha": "042fa9ad958b18d4bf22026d20a774c949c867d9", "filename": "src/test/ui/const-generics/const-arg-in-const-arg.min.stderr", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/53d19b37c514246acab020eaba9527cb97c421cf/src%2Ftest%2Fui%2Fconst-generics%2Fconst-arg-in-const-arg.min.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/53d19b37c514246acab020eaba9527cb97c421cf/src%2Ftest%2Fui%2Fconst-generics%2Fconst-arg-in-const-arg.min.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fconst-arg-in-const-arg.min.stderr?ref=53d19b37c514246acab020eaba9527cb97c421cf", "patch": "@@ -5,6 +5,7 @@ LL |     let _: [u8; foo::<T>()];\n    |                       ^ cannot perform const operation using `T`\n    |\n    = note: type parameters may not be used in const expressions\n+   = help: use `#![feature(const_generics)]` and `#![feature(const_evaluatable_checked)]` to allow generic const expressions\n \n error: generic parameters may not be used in const operations\n   --> $DIR/const-arg-in-const-arg.rs:15:23\n@@ -13,6 +14,7 @@ LL |     let _: [u8; bar::<N>()];\n    |                       ^ cannot perform const operation using `N`\n    |\n    = help: const parameters may only be used as standalone arguments, i.e. `N`\n+   = help: use `#![feature(const_generics)]` and `#![feature(const_evaluatable_checked)]` to allow generic const expressions\n \n error: generic parameters may not be used in const operations\n   --> $DIR/const-arg-in-const-arg.rs:25:23\n@@ -21,6 +23,7 @@ LL |     let _ = [0; bar::<N>()];\n    |                       ^ cannot perform const operation using `N`\n    |\n    = help: const parameters may only be used as standalone arguments, i.e. `N`\n+   = help: use `#![feature(const_generics)]` and `#![feature(const_evaluatable_checked)]` to allow generic const expressions\n \n error: generic parameters may not be used in const operations\n   --> $DIR/const-arg-in-const-arg.rs:30:24\n@@ -29,6 +32,7 @@ LL |     let _: Foo<{ foo::<T>() }>;\n    |                        ^ cannot perform const operation using `T`\n    |\n    = note: type parameters may not be used in const expressions\n+   = help: use `#![feature(const_generics)]` and `#![feature(const_evaluatable_checked)]` to allow generic const expressions\n \n error: generic parameters may not be used in const operations\n   --> $DIR/const-arg-in-const-arg.rs:31:24\n@@ -37,6 +41,7 @@ LL |     let _: Foo<{ bar::<N>() }>;\n    |                        ^ cannot perform const operation using `N`\n    |\n    = help: const parameters may only be used as standalone arguments, i.e. `N`\n+   = help: use `#![feature(const_generics)]` and `#![feature(const_evaluatable_checked)]` to allow generic const expressions\n \n error: generic parameters may not be used in const operations\n   --> $DIR/const-arg-in-const-arg.rs:36:27\n@@ -45,6 +50,7 @@ LL |     let _ = Foo::<{ foo::<T>() }>;\n    |                           ^ cannot perform const operation using `T`\n    |\n    = note: type parameters may not be used in const expressions\n+   = help: use `#![feature(const_generics)]` and `#![feature(const_evaluatable_checked)]` to allow generic const expressions\n \n error: generic parameters may not be used in const operations\n   --> $DIR/const-arg-in-const-arg.rs:37:27\n@@ -53,6 +59,7 @@ LL |     let _ = Foo::<{ bar::<N>() }>;\n    |                           ^ cannot perform const operation using `N`\n    |\n    = help: const parameters may only be used as standalone arguments, i.e. `N`\n+   = help: use `#![feature(const_generics)]` and `#![feature(const_evaluatable_checked)]` to allow generic const expressions\n \n error[E0658]: a non-static lifetime is not allowed in a `const`\n   --> $DIR/const-arg-in-const-arg.rs:16:23"}, {"sha": "8a1074392a5cbd09bf65f568cda92eb9a791a432", "filename": "src/test/ui/const-generics/const-argument-if-length.min.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/53d19b37c514246acab020eaba9527cb97c421cf/src%2Ftest%2Fui%2Fconst-generics%2Fconst-argument-if-length.min.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/53d19b37c514246acab020eaba9527cb97c421cf/src%2Ftest%2Fui%2Fconst-generics%2Fconst-argument-if-length.min.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fconst-argument-if-length.min.stderr?ref=53d19b37c514246acab020eaba9527cb97c421cf", "patch": "@@ -5,6 +5,7 @@ LL |     pad: [u8; is_zst::<T>()],\n    |                        ^ cannot perform const operation using `T`\n    |\n    = note: type parameters may not be used in const expressions\n+   = help: use `#![feature(const_generics)]` and `#![feature(const_evaluatable_checked)]` to allow generic const expressions\n \n error[E0277]: the size for values of type `T` cannot be known at compilation time\n   --> $DIR/const-argument-if-length.rs:17:12"}, {"sha": "354c6d0615f1b5947db9ce8c41be1cb3050224b5", "filename": "src/test/ui/const-generics/const-param-before-other-params.min.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/53d19b37c514246acab020eaba9527cb97c421cf/src%2Ftest%2Fui%2Fconst-generics%2Fconst-param-before-other-params.min.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/53d19b37c514246acab020eaba9527cb97c421cf/src%2Ftest%2Fui%2Fconst-generics%2Fconst-param-before-other-params.min.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fconst-param-before-other-params.min.stderr?ref=53d19b37c514246acab020eaba9527cb97c421cf", "patch": "@@ -17,7 +17,7 @@ LL | fn bar<const X: (), 'a>(_: &'a ()) {\n    |                 ^^\n    |\n    = note: the only supported types are integers, `bool` and `char`\n-   = note: more complex types are supported with `#[feature(const_generics)]`\n+   = help: more complex types are supported with `#[feature(const_generics)]`\n \n error: `()` is forbidden as the type of a const generic parameter\n   --> $DIR/const-param-before-other-params.rs:11:17\n@@ -26,7 +26,7 @@ LL | fn foo<const X: (), T>(_: &T) {}\n    |                 ^^\n    |\n    = note: the only supported types are integers, `bool` and `char`\n-   = note: more complex types are supported with `#[feature(const_generics)]`\n+   = help: more complex types are supported with `#[feature(const_generics)]`\n \n error: aborting due to 4 previous errors\n "}, {"sha": "ed30182690a7abb2f1113e9a071a9658136b6bb3", "filename": "src/test/ui/const-generics/const-param-elided-lifetime.min.stderr", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/53d19b37c514246acab020eaba9527cb97c421cf/src%2Ftest%2Fui%2Fconst-generics%2Fconst-param-elided-lifetime.min.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/53d19b37c514246acab020eaba9527cb97c421cf/src%2Ftest%2Fui%2Fconst-generics%2Fconst-param-elided-lifetime.min.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fconst-param-elided-lifetime.min.stderr?ref=53d19b37c514246acab020eaba9527cb97c421cf", "patch": "@@ -35,7 +35,7 @@ LL | struct A<const N: &u8>;\n    |                   ^^^\n    |\n    = note: the only supported types are integers, `bool` and `char`\n-   = note: more complex types are supported with `#[feature(const_generics)]`\n+   = help: more complex types are supported with `#[feature(const_generics)]`\n \n error: `&'static u8` is forbidden as the type of a const generic parameter\n   --> $DIR/const-param-elided-lifetime.rs:16:15\n@@ -44,7 +44,7 @@ LL | impl<const N: &u8> A<N> {\n    |               ^^^\n    |\n    = note: the only supported types are integers, `bool` and `char`\n-   = note: more complex types are supported with `#[feature(const_generics)]`\n+   = help: more complex types are supported with `#[feature(const_generics)]`\n \n error: `&'static u8` is forbidden as the type of a const generic parameter\n   --> $DIR/const-param-elided-lifetime.rs:24:15\n@@ -53,7 +53,7 @@ LL | impl<const N: &u8> B for A<N> {}\n    |               ^^^\n    |\n    = note: the only supported types are integers, `bool` and `char`\n-   = note: more complex types are supported with `#[feature(const_generics)]`\n+   = help: more complex types are supported with `#[feature(const_generics)]`\n \n error: `&'static u8` is forbidden as the type of a const generic parameter\n   --> $DIR/const-param-elided-lifetime.rs:28:17\n@@ -62,7 +62,7 @@ LL | fn bar<const N: &u8>() {}\n    |                 ^^^\n    |\n    = note: the only supported types are integers, `bool` and `char`\n-   = note: more complex types are supported with `#[feature(const_generics)]`\n+   = help: more complex types are supported with `#[feature(const_generics)]`\n \n error: `&'static u8` is forbidden as the type of a const generic parameter\n   --> $DIR/const-param-elided-lifetime.rs:19:21\n@@ -71,7 +71,7 @@ LL |     fn foo<const M: &u8>(&self) {}\n    |                     ^^^\n    |\n    = note: the only supported types are integers, `bool` and `char`\n-   = note: more complex types are supported with `#[feature(const_generics)]`\n+   = help: more complex types are supported with `#[feature(const_generics)]`\n \n error: aborting due to 10 previous errors\n "}, {"sha": "6b7a218ada5ddef7b805b7e354056f63ac8f40d7", "filename": "src/test/ui/const-generics/const-param-type-depends-on-const-param.min.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/53d19b37c514246acab020eaba9527cb97c421cf/src%2Ftest%2Fui%2Fconst-generics%2Fconst-param-type-depends-on-const-param.min.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/53d19b37c514246acab020eaba9527cb97c421cf/src%2Ftest%2Fui%2Fconst-generics%2Fconst-param-type-depends-on-const-param.min.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fconst-param-type-depends-on-const-param.min.stderr?ref=53d19b37c514246acab020eaba9527cb97c421cf", "patch": "@@ -17,7 +17,7 @@ LL | pub struct Dependent<const N: usize, const X: [u8; N]>([(); N]);\n    |                                               ^^^^^^^\n    |\n    = note: the only supported types are integers, `bool` and `char`\n-   = note: more complex types are supported with `#[feature(const_generics)]`\n+   = help: more complex types are supported with `#[feature(const_generics)]`\n \n error: `[u8; _]` is forbidden as the type of a const generic parameter\n   --> $DIR/const-param-type-depends-on-const-param.rs:16:35\n@@ -26,7 +26,7 @@ LL | pub struct SelfDependent<const N: [u8; N]>;\n    |                                   ^^^^^^^\n    |\n    = note: the only supported types are integers, `bool` and `char`\n-   = note: more complex types are supported with `#[feature(const_generics)]`\n+   = help: more complex types are supported with `#[feature(const_generics)]`\n \n error: aborting due to 4 previous errors\n "}, {"sha": "573bc66b7c7e86afa88c1e272e76aad6806b4d73", "filename": "src/test/ui/const-generics/const_evaluatable_checked/feature-gate-const_evaluatable_checked.min.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/53d19b37c514246acab020eaba9527cb97c421cf/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Ffeature-gate-const_evaluatable_checked.min.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/53d19b37c514246acab020eaba9527cb97c421cf/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Ffeature-gate-const_evaluatable_checked.min.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Ffeature-gate-const_evaluatable_checked.min.stderr?ref=53d19b37c514246acab020eaba9527cb97c421cf", "patch": "@@ -5,6 +5,7 @@ LL | type Arr<const N: usize> = [u8; N - 1];\n    |                                 ^ cannot perform const operation using `N`\n    |\n    = help: const parameters may only be used as standalone arguments, i.e. `N`\n+   = help: use `#![feature(const_generics)]` and `#![feature(const_evaluatable_checked)]` to allow generic const expressions\n \n error: aborting due to previous error\n "}, {"sha": "d476a7eb6455cb95882da003faf9c2724d0f480a", "filename": "src/test/ui/const-generics/const_evaluatable_checked/simple.min.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/53d19b37c514246acab020eaba9527cb97c421cf/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Fsimple.min.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/53d19b37c514246acab020eaba9527cb97c421cf/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Fsimple.min.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Fsimple.min.stderr?ref=53d19b37c514246acab020eaba9527cb97c421cf", "patch": "@@ -5,6 +5,7 @@ LL | fn test<const N: usize>() -> [u8; N - 1] where [u8; N - 1]: Default {\n    |                                                     ^ cannot perform const operation using `N`\n    |\n    = help: const parameters may only be used as standalone arguments, i.e. `N`\n+   = help: use `#![feature(const_generics)]` and `#![feature(const_evaluatable_checked)]` to allow generic const expressions\n \n error: generic parameters may not be used in const operations\n   --> $DIR/simple.rs:8:35\n@@ -13,6 +14,7 @@ LL | fn test<const N: usize>() -> [u8; N - 1] where [u8; N - 1]: Default {\n    |                                   ^ cannot perform const operation using `N`\n    |\n    = help: const parameters may only be used as standalone arguments, i.e. `N`\n+   = help: use `#![feature(const_generics)]` and `#![feature(const_evaluatable_checked)]` to allow generic const expressions\n \n error: aborting due to 2 previous errors\n "}, {"sha": "bd81e0bc5a8cfa6d46ba33db138e346df1668d20", "filename": "src/test/ui/const-generics/const_evaluatable_checked/simple_fail.min.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/53d19b37c514246acab020eaba9527cb97c421cf/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Fsimple_fail.min.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/53d19b37c514246acab020eaba9527cb97c421cf/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Fsimple_fail.min.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Fsimple_fail.min.stderr?ref=53d19b37c514246acab020eaba9527cb97c421cf", "patch": "@@ -5,6 +5,7 @@ LL | type Arr<const N: usize> = [u8; N - 1];\n    |                                 ^ cannot perform const operation using `N`\n    |\n    = help: const parameters may only be used as standalone arguments, i.e. `N`\n+   = help: use `#![feature(const_generics)]` and `#![feature(const_evaluatable_checked)]` to allow generic const expressions\n \n error: aborting due to previous error\n "}, {"sha": "e5b393ffe99ebb5c152685fd456973ecf77fcb95", "filename": "src/test/ui/const-generics/different_byref.min.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/53d19b37c514246acab020eaba9527cb97c421cf/src%2Ftest%2Fui%2Fconst-generics%2Fdifferent_byref.min.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/53d19b37c514246acab020eaba9527cb97c421cf/src%2Ftest%2Fui%2Fconst-generics%2Fdifferent_byref.min.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fdifferent_byref.min.stderr?ref=53d19b37c514246acab020eaba9527cb97c421cf", "patch": "@@ -5,7 +5,7 @@ LL | struct Const<const V: [usize; 1]> {}\n    |                       ^^^^^^^^^^\n    |\n    = note: the only supported types are integers, `bool` and `char`\n-   = note: more complex types are supported with `#[feature(const_generics)]`\n+   = help: more complex types are supported with `#[feature(const_generics)]`\n \n error: aborting due to previous error\n "}, {"sha": "014200178b9ca5ad8a37bac466a364d2d33c8f9b", "filename": "src/test/ui/const-generics/forbid-non-structural_match-types.min.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/53d19b37c514246acab020eaba9527cb97c421cf/src%2Ftest%2Fui%2Fconst-generics%2Fforbid-non-structural_match-types.min.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/53d19b37c514246acab020eaba9527cb97c421cf/src%2Ftest%2Fui%2Fconst-generics%2Fforbid-non-structural_match-types.min.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fforbid-non-structural_match-types.min.stderr?ref=53d19b37c514246acab020eaba9527cb97c421cf", "patch": "@@ -5,7 +5,7 @@ LL | struct B<const X: A>; // ok\n    |                   ^\n    |\n    = note: the only supported types are integers, `bool` and `char`\n-   = note: more complex types are supported with `#[feature(const_generics)]`\n+   = help: more complex types are supported with `#[feature(const_generics)]`\n \n error: `C` is forbidden as the type of a const generic parameter\n   --> $DIR/forbid-non-structural_match-types.rs:15:19\n@@ -14,7 +14,7 @@ LL | struct D<const X: C>;\n    |                   ^\n    |\n    = note: the only supported types are integers, `bool` and `char`\n-   = note: more complex types are supported with `#[feature(const_generics)]`\n+   = help: more complex types are supported with `#[feature(const_generics)]`\n \n error[E0741]: `C` must be annotated with `#[derive(PartialEq, Eq)]` to be used as the type of a const parameter\n   --> $DIR/forbid-non-structural_match-types.rs:15:19"}, {"sha": "526f98fe8cd4f3e182b13c636c606df744797baf", "filename": "src/test/ui/const-generics/generic-function-call-in-array-length.min.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/53d19b37c514246acab020eaba9527cb97c421cf/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric-function-call-in-array-length.min.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/53d19b37c514246acab020eaba9527cb97c421cf/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric-function-call-in-array-length.min.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric-function-call-in-array-length.min.stderr?ref=53d19b37c514246acab020eaba9527cb97c421cf", "patch": "@@ -5,6 +5,7 @@ LL | fn bar<const N: usize>() -> [u32; foo(N)] {\n    |                                       ^ cannot perform const operation using `N`\n    |\n    = help: const parameters may only be used as standalone arguments, i.e. `N`\n+   = help: use `#![feature(const_generics)]` and `#![feature(const_evaluatable_checked)]` to allow generic const expressions\n \n error: generic parameters may not be used in const operations\n   --> $DIR/generic-function-call-in-array-length.rs:12:13\n@@ -13,6 +14,7 @@ LL |     [0; foo(N)]\n    |             ^ cannot perform const operation using `N`\n    |\n    = help: const parameters may only be used as standalone arguments, i.e. `N`\n+   = help: use `#![feature(const_generics)]` and `#![feature(const_evaluatable_checked)]` to allow generic const expressions\n \n error: aborting due to 2 previous errors\n "}, {"sha": "e531b612b5609d5dfe7d5215c578ad7701edd3e1", "filename": "src/test/ui/const-generics/generic-sum-in-array-length.min.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/53d19b37c514246acab020eaba9527cb97c421cf/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric-sum-in-array-length.min.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/53d19b37c514246acab020eaba9527cb97c421cf/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric-sum-in-array-length.min.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric-sum-in-array-length.min.stderr?ref=53d19b37c514246acab020eaba9527cb97c421cf", "patch": "@@ -5,6 +5,7 @@ LL | fn foo<const A: usize, const B: usize>(bar: [usize; A + B]) {}\n    |                                                     ^ cannot perform const operation using `A`\n    |\n    = help: const parameters may only be used as standalone arguments, i.e. `A`\n+   = help: use `#![feature(const_generics)]` and `#![feature(const_evaluatable_checked)]` to allow generic const expressions\n \n error: generic parameters may not be used in const operations\n   --> $DIR/generic-sum-in-array-length.rs:7:57\n@@ -13,6 +14,7 @@ LL | fn foo<const A: usize, const B: usize>(bar: [usize; A + B]) {}\n    |                                                         ^ cannot perform const operation using `B`\n    |\n    = help: const parameters may only be used as standalone arguments, i.e. `B`\n+   = help: use `#![feature(const_generics)]` and `#![feature(const_evaluatable_checked)]` to allow generic const expressions\n \n error: aborting due to 2 previous errors\n "}, {"sha": "02467df193c39d380ffb3d952dff3959edac3339", "filename": "src/test/ui/const-generics/intrinsics-type_name-as-const-argument.min.stderr", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/53d19b37c514246acab020eaba9527cb97c421cf/src%2Ftest%2Fui%2Fconst-generics%2Fintrinsics-type_name-as-const-argument.min.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/53d19b37c514246acab020eaba9527cb97c421cf/src%2Ftest%2Fui%2Fconst-generics%2Fintrinsics-type_name-as-const-argument.min.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fintrinsics-type_name-as-const-argument.min.stderr?ref=53d19b37c514246acab020eaba9527cb97c421cf", "patch": "@@ -5,6 +5,7 @@ LL |     T: Trait<{std::intrinsics::type_name::<T>()}>\n    |                                            ^ cannot perform const operation using `T`\n    |\n    = note: type parameters may not be used in const expressions\n+   = help: use `#![feature(const_generics)]` and `#![feature(const_evaluatable_checked)]` to allow generic const expressions\n \n error: `&'static str` is forbidden as the type of a const generic parameter\n   --> $DIR/intrinsics-type_name-as-const-argument.rs:10:22\n@@ -13,7 +14,7 @@ LL | trait Trait<const S: &'static str> {}\n    |                      ^^^^^^^^^^^^\n    |\n    = note: the only supported types are integers, `bool` and `char`\n-   = note: more complex types are supported with `#[feature(const_generics)]`\n+   = help: more complex types are supported with `#[feature(const_generics)]`\n \n error: aborting due to 2 previous errors\n "}, {"sha": "2eaef95c2321607a80a97921dd641b6cec3cdfcc", "filename": "src/test/ui/const-generics/issue-61522-array-len-succ.min.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/53d19b37c514246acab020eaba9527cb97c421cf/src%2Ftest%2Fui%2Fconst-generics%2Fissue-61522-array-len-succ.min.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/53d19b37c514246acab020eaba9527cb97c421cf/src%2Ftest%2Fui%2Fconst-generics%2Fissue-61522-array-len-succ.min.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissue-61522-array-len-succ.min.stderr?ref=53d19b37c514246acab020eaba9527cb97c421cf", "patch": "@@ -5,6 +5,7 @@ LL | pub struct MyArray<const COUNT: usize>([u8; COUNT + 1]);\n    |                                             ^^^^^ cannot perform const operation using `COUNT`\n    |\n    = help: const parameters may only be used as standalone arguments, i.e. `COUNT`\n+   = help: use `#![feature(const_generics)]` and `#![feature(const_evaluatable_checked)]` to allow generic const expressions\n \n error: generic parameters may not be used in const operations\n   --> $DIR/issue-61522-array-len-succ.rs:12:30\n@@ -13,6 +14,7 @@ LL |     fn inner(&self) -> &[u8; COUNT + 1] {\n    |                              ^^^^^ cannot perform const operation using `COUNT`\n    |\n    = help: const parameters may only be used as standalone arguments, i.e. `COUNT`\n+   = help: use `#![feature(const_generics)]` and `#![feature(const_evaluatable_checked)]` to allow generic const expressions\n \n error: aborting due to 2 previous errors\n "}, {"sha": "1c2e7e069a1819948f57a09462b876647c6a8f16", "filename": "src/test/ui/const-generics/issue-66596-impl-trait-for-str-const-arg.min.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/53d19b37c514246acab020eaba9527cb97c421cf/src%2Ftest%2Fui%2Fconst-generics%2Fissue-66596-impl-trait-for-str-const-arg.min.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/53d19b37c514246acab020eaba9527cb97c421cf/src%2Ftest%2Fui%2Fconst-generics%2Fissue-66596-impl-trait-for-str-const-arg.min.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissue-66596-impl-trait-for-str-const-arg.min.stderr?ref=53d19b37c514246acab020eaba9527cb97c421cf", "patch": "@@ -5,7 +5,7 @@ LL | trait Trait<const NAME: &'static str> {\n    |                         ^^^^^^^^^^^^\n    |\n    = note: the only supported types are integers, `bool` and `char`\n-   = note: more complex types are supported with `#[feature(const_generics)]`\n+   = help: more complex types are supported with `#[feature(const_generics)]`\n \n error: aborting due to previous error\n "}, {"sha": "da96b5374a57dfd8acad7e85417099d6cf14dcbf", "filename": "src/test/ui/const-generics/issue-67375.min.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/53d19b37c514246acab020eaba9527cb97c421cf/src%2Ftest%2Fui%2Fconst-generics%2Fissue-67375.min.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/53d19b37c514246acab020eaba9527cb97c421cf/src%2Ftest%2Fui%2Fconst-generics%2Fissue-67375.min.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissue-67375.min.stderr?ref=53d19b37c514246acab020eaba9527cb97c421cf", "patch": "@@ -5,6 +5,7 @@ LL |     inner: [(); { [|_: &T| {}; 0].len() }],\n    |                         ^ cannot perform const operation using `T`\n    |\n    = note: type parameters may not be used in const expressions\n+   = help: use `#![feature(const_generics)]` and `#![feature(const_evaluatable_checked)]` to allow generic const expressions\n \n error[E0392]: parameter `T` is never used\n   --> $DIR/issue-67375.rs:7:12"}, {"sha": "8fea130baa57c50afe47fbfded37c471f46c6f1d", "filename": "src/test/ui/const-generics/issue-67945-1.min.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/53d19b37c514246acab020eaba9527cb97c421cf/src%2Ftest%2Fui%2Fconst-generics%2Fissue-67945-1.min.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/53d19b37c514246acab020eaba9527cb97c421cf/src%2Ftest%2Fui%2Fconst-generics%2Fissue-67945-1.min.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissue-67945-1.min.stderr?ref=53d19b37c514246acab020eaba9527cb97c421cf", "patch": "@@ -5,6 +5,7 @@ LL |         let x: S = MaybeUninit::uninit();\n    |                ^ cannot perform const operation using `S`\n    |\n    = note: type parameters may not be used in const expressions\n+   = help: use `#![feature(const_generics)]` and `#![feature(const_evaluatable_checked)]` to allow generic const expressions\n \n error: generic parameters may not be used in const operations\n   --> $DIR/issue-67945-1.rs:17:45\n@@ -13,6 +14,7 @@ LL |         let b = &*(&x as *const _ as *const S);\n    |                                             ^ cannot perform const operation using `S`\n    |\n    = note: type parameters may not be used in const expressions\n+   = help: use `#![feature(const_generics)]` and `#![feature(const_evaluatable_checked)]` to allow generic const expressions\n \n error[E0392]: parameter `S` is never used\n   --> $DIR/issue-67945-1.rs:11:12"}, {"sha": "50633772b75a91c3062cb9207176f21240c8a5d3", "filename": "src/test/ui/const-generics/issue-67945-2.min.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/53d19b37c514246acab020eaba9527cb97c421cf/src%2Ftest%2Fui%2Fconst-generics%2Fissue-67945-2.min.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/53d19b37c514246acab020eaba9527cb97c421cf/src%2Ftest%2Fui%2Fconst-generics%2Fissue-67945-2.min.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissue-67945-2.min.stderr?ref=53d19b37c514246acab020eaba9527cb97c421cf", "patch": "@@ -5,6 +5,7 @@ LL |         let x: S = MaybeUninit::uninit();\n    |                ^ cannot perform const operation using `S`\n    |\n    = note: type parameters may not be used in const expressions\n+   = help: use `#![feature(const_generics)]` and `#![feature(const_evaluatable_checked)]` to allow generic const expressions\n \n error: generic parameters may not be used in const operations\n   --> $DIR/issue-67945-2.rs:15:45\n@@ -13,6 +14,7 @@ LL |         let b = &*(&x as *const _ as *const S);\n    |                                             ^ cannot perform const operation using `S`\n    |\n    = note: type parameters may not be used in const expressions\n+   = help: use `#![feature(const_generics)]` and `#![feature(const_evaluatable_checked)]` to allow generic const expressions\n \n error[E0392]: parameter `S` is never used\n   --> $DIR/issue-67945-2.rs:9:12"}, {"sha": "1de9e71b6eb008021eda8525827033770a8f6907", "filename": "src/test/ui/const-generics/issues/issue-61747.min.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/53d19b37c514246acab020eaba9527cb97c421cf/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-61747.min.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/53d19b37c514246acab020eaba9527cb97c421cf/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-61747.min.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-61747.min.stderr?ref=53d19b37c514246acab020eaba9527cb97c421cf", "patch": "@@ -5,6 +5,7 @@ LL |     fn successor() -> Const<{C + 1}> {\n    |                              ^ cannot perform const operation using `C`\n    |\n    = help: const parameters may only be used as standalone arguments, i.e. `C`\n+   = help: use `#![feature(const_generics)]` and `#![feature(const_evaluatable_checked)]` to allow generic const expressions\n \n error: aborting due to previous error\n "}, {"sha": "b1d92056a544c259b0438dd606047f924142386d", "filename": "src/test/ui/const-generics/issues/issue-61935.min.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/53d19b37c514246acab020eaba9527cb97c421cf/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-61935.min.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/53d19b37c514246acab020eaba9527cb97c421cf/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-61935.min.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-61935.min.stderr?ref=53d19b37c514246acab020eaba9527cb97c421cf", "patch": "@@ -5,6 +5,7 @@ LL |         Self:FooImpl<{N==0}>\n    |                       ^ cannot perform const operation using `N`\n    |\n    = help: const parameters may only be used as standalone arguments, i.e. `N`\n+   = help: use `#![feature(const_generics)]` and `#![feature(const_evaluatable_checked)]` to allow generic const expressions\n \n error: aborting due to previous error\n "}, {"sha": "b338cdb87e1e5ee03e868329e36c3e5adc68dd11", "filename": "src/test/ui/const-generics/issues/issue-62220.min.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/53d19b37c514246acab020eaba9527cb97c421cf/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-62220.min.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/53d19b37c514246acab020eaba9527cb97c421cf/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-62220.min.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-62220.min.stderr?ref=53d19b37c514246acab020eaba9527cb97c421cf", "patch": "@@ -5,6 +5,7 @@ LL | pub type TruncatedVector<T, const N: usize> = Vector<T, { N - 1 }>;\n    |                                                           ^ cannot perform const operation using `N`\n    |\n    = help: const parameters may only be used as standalone arguments, i.e. `N`\n+   = help: use `#![feature(const_generics)]` and `#![feature(const_evaluatable_checked)]` to allow generic const expressions\n \n error: aborting due to previous error\n "}, {"sha": "a4b501a7bb109f343a1965b020ec9af07f768cea", "filename": "src/test/ui/const-generics/issues/issue-62456.min.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/53d19b37c514246acab020eaba9527cb97c421cf/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-62456.min.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/53d19b37c514246acab020eaba9527cb97c421cf/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-62456.min.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-62456.min.stderr?ref=53d19b37c514246acab020eaba9527cb97c421cf", "patch": "@@ -5,6 +5,7 @@ LL |     let _ = [0u64; N + 1];\n    |                    ^ cannot perform const operation using `N`\n    |\n    = help: const parameters may only be used as standalone arguments, i.e. `N`\n+   = help: use `#![feature(const_generics)]` and `#![feature(const_evaluatable_checked)]` to allow generic const expressions\n \n error: aborting due to previous error\n "}, {"sha": "5117e20d6266b5a26dc0ed999d6a6c876fa942d8", "filename": "src/test/ui/const-generics/issues/issue-62579-no-match.min.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/53d19b37c514246acab020eaba9527cb97c421cf/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-62579-no-match.min.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/53d19b37c514246acab020eaba9527cb97c421cf/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-62579-no-match.min.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-62579-no-match.min.stderr?ref=53d19b37c514246acab020eaba9527cb97c421cf", "patch": "@@ -5,7 +5,7 @@ LL | fn foo<const T: NoMatch>() -> bool {\n    |                 ^^^^^^^\n    |\n    = note: the only supported types are integers, `bool` and `char`\n-   = note: more complex types are supported with `#[feature(const_generics)]`\n+   = help: more complex types are supported with `#[feature(const_generics)]`\n \n error: aborting due to previous error\n "}, {"sha": "9f95e5d88623e13bd21e0d3661a302a30fafa5b5", "filename": "src/test/ui/const-generics/issues/issue-62878.min.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/53d19b37c514246acab020eaba9527cb97c421cf/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-62878.min.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/53d19b37c514246acab020eaba9527cb97c421cf/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-62878.min.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-62878.min.stderr?ref=53d19b37c514246acab020eaba9527cb97c421cf", "patch": "@@ -11,7 +11,7 @@ LL | fn foo<const N: usize, const A: [u8; N]>() {}\n    |                                 ^^^^^^^\n    |\n    = note: the only supported types are integers, `bool` and `char`\n-   = note: more complex types are supported with `#[feature(const_generics)]`\n+   = help: more complex types are supported with `#[feature(const_generics)]`\n \n error: aborting due to 2 previous errors\n "}, {"sha": "5dbfdc6d652b6708f817ddc15f9890c4d498f0f1", "filename": "src/test/ui/const-generics/issues/issue-63322-forbid-dyn.min.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/53d19b37c514246acab020eaba9527cb97c421cf/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-63322-forbid-dyn.min.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/53d19b37c514246acab020eaba9527cb97c421cf/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-63322-forbid-dyn.min.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-63322-forbid-dyn.min.stderr?ref=53d19b37c514246acab020eaba9527cb97c421cf", "patch": "@@ -5,7 +5,7 @@ LL | fn test<const T: &'static dyn A>() {\n    |                  ^^^^^^^^^^^^^^\n    |\n    = note: the only supported types are integers, `bool` and `char`\n-   = note: more complex types are supported with `#[feature(const_generics)]`\n+   = help: more complex types are supported with `#[feature(const_generics)]`\n \n error[E0741]: `&'static (dyn A + 'static)` must be annotated with `#[derive(PartialEq, Eq)]` to be used as the type of a const parameter\n   --> $DIR/issue-63322-forbid-dyn.rs:10:18"}, {"sha": "681166b1d2b94b7d270dfc9c361913bba2896d83", "filename": "src/test/ui/const-generics/issues/issue-64494.min.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/53d19b37c514246acab020eaba9527cb97c421cf/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-64494.min.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/53d19b37c514246acab020eaba9527cb97c421cf/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-64494.min.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-64494.min.stderr?ref=53d19b37c514246acab020eaba9527cb97c421cf", "patch": "@@ -5,6 +5,7 @@ LL | impl<T: Foo> MyTrait for T where Is<{T::VAL == 5}>: True {}\n    |                                      ^^^^^^ cannot perform const operation using `T`\n    |\n    = note: type parameters may not be used in const expressions\n+   = help: use `#![feature(const_generics)]` and `#![feature(const_evaluatable_checked)]` to allow generic const expressions\n \n error: generic parameters may not be used in const operations\n   --> $DIR/issue-64494.rs:19:38\n@@ -13,6 +14,7 @@ LL | impl<T: Foo> MyTrait for T where Is<{T::VAL == 6}>: True {}\n    |                                      ^^^^^^ cannot perform const operation using `T`\n    |\n    = note: type parameters may not be used in const expressions\n+   = help: use `#![feature(const_generics)]` and `#![feature(const_evaluatable_checked)]` to allow generic const expressions\n \n error[E0119]: conflicting implementations of trait `MyTrait`:\n   --> $DIR/issue-64494.rs:19:1"}, {"sha": "ecd96ac37e404c059329b91d632ff0023a91d563", "filename": "src/test/ui/const-generics/issues/issue-66205.min.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/53d19b37c514246acab020eaba9527cb97c421cf/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-66205.min.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/53d19b37c514246acab020eaba9527cb97c421cf/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-66205.min.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-66205.min.stderr?ref=53d19b37c514246acab020eaba9527cb97c421cf", "patch": "@@ -5,6 +5,7 @@ LL |     fact::<{ N - 1 }>();\n    |              ^ cannot perform const operation using `N`\n    |\n    = help: const parameters may only be used as standalone arguments, i.e. `N`\n+   = help: use `#![feature(const_generics)]` and `#![feature(const_evaluatable_checked)]` to allow generic const expressions\n \n error: aborting due to previous error\n "}, {"sha": "acaf4a33ee0a88548c34a6fd72e23f9d0e4009e9", "filename": "src/test/ui/const-generics/issues/issue-68366.min.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/53d19b37c514246acab020eaba9527cb97c421cf/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-68366.min.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/53d19b37c514246acab020eaba9527cb97c421cf/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-68366.min.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-68366.min.stderr?ref=53d19b37c514246acab020eaba9527cb97c421cf", "patch": "@@ -5,6 +5,7 @@ LL | impl <const N: usize> Collatz<{Some(N)}> {}\n    |                                     ^ cannot perform const operation using `N`\n    |\n    = help: const parameters may only be used as standalone arguments, i.e. `N`\n+   = help: use `#![feature(const_generics)]` and `#![feature(const_evaluatable_checked)]` to allow generic const expressions\n \n error[E0207]: the const parameter `N` is not constrained by the impl trait, self type, or predicates\n   --> $DIR/issue-68366.rs:12:13"}, {"sha": "59653114a6b61f81582fc39526532c5de1b629ab", "filename": "src/test/ui/const-generics/issues/issue-68615-adt.min.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/53d19b37c514246acab020eaba9527cb97c421cf/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-68615-adt.min.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/53d19b37c514246acab020eaba9527cb97c421cf/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-68615-adt.min.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-68615-adt.min.stderr?ref=53d19b37c514246acab020eaba9527cb97c421cf", "patch": "@@ -5,7 +5,7 @@ LL | struct Const<const V: [usize; 0]> {}\n    |                       ^^^^^^^^^^\n    |\n    = note: the only supported types are integers, `bool` and `char`\n-   = note: more complex types are supported with `#[feature(const_generics)]`\n+   = help: more complex types are supported with `#[feature(const_generics)]`\n \n error: aborting due to previous error\n "}, {"sha": "1ee881b96ec6037185bae03f24373e21f3ccd244", "filename": "src/test/ui/const-generics/issues/issue-68615-array.min.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/53d19b37c514246acab020eaba9527cb97c421cf/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-68615-array.min.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/53d19b37c514246acab020eaba9527cb97c421cf/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-68615-array.min.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-68615-array.min.stderr?ref=53d19b37c514246acab020eaba9527cb97c421cf", "patch": "@@ -5,7 +5,7 @@ LL | struct Foo<const V: [usize; 0] > {}\n    |                     ^^^^^^^^^^\n    |\n    = note: the only supported types are integers, `bool` and `char`\n-   = note: more complex types are supported with `#[feature(const_generics)]`\n+   = help: more complex types are supported with `#[feature(const_generics)]`\n \n error: aborting due to previous error\n "}, {"sha": "ea91df1e0bf4db0c171bcf4a80a4a240188d4eee", "filename": "src/test/ui/const-generics/issues/issue-68977.min.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/53d19b37c514246acab020eaba9527cb97c421cf/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-68977.min.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/53d19b37c514246acab020eaba9527cb97c421cf/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-68977.min.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-68977.min.stderr?ref=53d19b37c514246acab020eaba9527cb97c421cf", "patch": "@@ -5,6 +5,7 @@ LL |     PhantomU8<{(INT_BITS + FRAC_BITS + 7) / 8}>;\n    |                 ^^^^^^^^ cannot perform const operation using `INT_BITS`\n    |\n    = help: const parameters may only be used as standalone arguments, i.e. `INT_BITS`\n+   = help: use `#![feature(const_generics)]` and `#![feature(const_evaluatable_checked)]` to allow generic const expressions\n \n error: generic parameters may not be used in const operations\n   --> $DIR/issue-68977.rs:29:28\n@@ -13,6 +14,7 @@ LL |     PhantomU8<{(INT_BITS + FRAC_BITS + 7) / 8}>;\n    |                            ^^^^^^^^^ cannot perform const operation using `FRAC_BITS`\n    |\n    = help: const parameters may only be used as standalone arguments, i.e. `FRAC_BITS`\n+   = help: use `#![feature(const_generics)]` and `#![feature(const_evaluatable_checked)]` to allow generic const expressions\n \n error: aborting due to 2 previous errors\n "}, {"sha": "9b0a2946ca6cfa14dff6f1593f1d8fd2cb81e2d9", "filename": "src/test/ui/const-generics/issues/issue-71169.min.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/53d19b37c514246acab020eaba9527cb97c421cf/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-71169.min.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/53d19b37c514246acab020eaba9527cb97c421cf/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-71169.min.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-71169.min.stderr?ref=53d19b37c514246acab020eaba9527cb97c421cf", "patch": "@@ -11,7 +11,7 @@ LL | fn foo<const LEN: usize, const DATA: [u8; LEN]>() {}\n    |                                      ^^^^^^^^^\n    |\n    = note: the only supported types are integers, `bool` and `char`\n-   = note: more complex types are supported with `#[feature(const_generics)]`\n+   = help: more complex types are supported with `#[feature(const_generics)]`\n \n error: aborting due to 2 previous errors\n "}, {"sha": "27bbc28011f2e5c9e84fcb69b216d41577dbdfb1", "filename": "src/test/ui/const-generics/issues/issue-72787.min.stderr", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/53d19b37c514246acab020eaba9527cb97c421cf/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-72787.min.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/53d19b37c514246acab020eaba9527cb97c421cf/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-72787.min.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-72787.min.stderr?ref=53d19b37c514246acab020eaba9527cb97c421cf", "patch": "@@ -5,6 +5,7 @@ LL |     Condition<{ LHS <= RHS }>: True\n    |                 ^^^ cannot perform const operation using `LHS`\n    |\n    = help: const parameters may only be used as standalone arguments, i.e. `LHS`\n+   = help: use `#![feature(const_generics)]` and `#![feature(const_evaluatable_checked)]` to allow generic const expressions\n \n error: generic parameters may not be used in const operations\n   --> $DIR/issue-72787.rs:11:24\n@@ -13,6 +14,7 @@ LL |     Condition<{ LHS <= RHS }>: True\n    |                        ^^^ cannot perform const operation using `RHS`\n    |\n    = help: const parameters may only be used as standalone arguments, i.e. `RHS`\n+   = help: use `#![feature(const_generics)]` and `#![feature(const_evaluatable_checked)]` to allow generic const expressions\n \n error: generic parameters may not be used in const operations\n   --> $DIR/issue-72787.rs:26:25\n@@ -21,6 +23,7 @@ LL |     IsLessOrEqual<{ 8 - I }, { 8 - J }>: True,\n    |                         ^ cannot perform const operation using `I`\n    |\n    = help: const parameters may only be used as standalone arguments, i.e. `I`\n+   = help: use `#![feature(const_generics)]` and `#![feature(const_evaluatable_checked)]` to allow generic const expressions\n \n error: generic parameters may not be used in const operations\n   --> $DIR/issue-72787.rs:26:36\n@@ -29,6 +32,7 @@ LL |     IsLessOrEqual<{ 8 - I }, { 8 - J }>: True,\n    |                                    ^ cannot perform const operation using `J`\n    |\n    = help: const parameters may only be used as standalone arguments, i.e. `J`\n+   = help: use `#![feature(const_generics)]` and `#![feature(const_evaluatable_checked)]` to allow generic const expressions\n \n error[E0283]: type annotations needed\n   --> $DIR/issue-72787.rs:22:26"}, {"sha": "2394b23d7995be7ed55ed882353dbc1c1229c3a0", "filename": "src/test/ui/const-generics/issues/issue-72819-generic-in-const-eval.min.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/53d19b37c514246acab020eaba9527cb97c421cf/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-72819-generic-in-const-eval.min.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/53d19b37c514246acab020eaba9527cb97c421cf/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-72819-generic-in-const-eval.min.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-72819-generic-in-const-eval.min.stderr?ref=53d19b37c514246acab020eaba9527cb97c421cf", "patch": "@@ -5,6 +5,7 @@ LL | where Assert::<{N < usize::max_value() / 2}>: IsTrue,\n    |                 ^ cannot perform const operation using `N`\n    |\n    = help: const parameters may only be used as standalone arguments, i.e. `N`\n+   = help: use `#![feature(const_generics)]` and `#![feature(const_evaluatable_checked)]` to allow generic const expressions\n \n error: aborting due to previous error\n "}, {"sha": "3ff0563acc77d0281e3be0cd128ff5a33b0cb8f9", "filename": "src/test/ui/const-generics/issues/issue-73491.min.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/53d19b37c514246acab020eaba9527cb97c421cf/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-73491.min.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/53d19b37c514246acab020eaba9527cb97c421cf/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-73491.min.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-73491.min.stderr?ref=53d19b37c514246acab020eaba9527cb97c421cf", "patch": "@@ -5,7 +5,7 @@ LL | fn hoge<const IN: [u32; LEN]>() {}\n    |                   ^^^^^^^^^^\n    |\n    = note: the only supported types are integers, `bool` and `char`\n-   = note: more complex types are supported with `#[feature(const_generics)]`\n+   = help: more complex types are supported with `#[feature(const_generics)]`\n \n error: aborting due to previous error\n "}, {"sha": "1351246667e9bb9802b24898fb1454c243799d46", "filename": "src/test/ui/const-generics/issues/issue-74101.min.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/53d19b37c514246acab020eaba9527cb97c421cf/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-74101.min.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/53d19b37c514246acab020eaba9527cb97c421cf/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-74101.min.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-74101.min.stderr?ref=53d19b37c514246acab020eaba9527cb97c421cf", "patch": "@@ -5,7 +5,7 @@ LL | fn test<const N: [u8; 1 + 2]>() {}\n    |                  ^^^^^^^^^^^\n    |\n    = note: the only supported types are integers, `bool` and `char`\n-   = note: more complex types are supported with `#[feature(const_generics)]`\n+   = help: more complex types are supported with `#[feature(const_generics)]`\n \n error: `[u8; _]` is forbidden as the type of a const generic parameter\n   --> $DIR/issue-74101.rs:10:21\n@@ -14,7 +14,7 @@ LL | struct Foo<const N: [u8; 1 + 2]>;\n    |                     ^^^^^^^^^^^\n    |\n    = note: the only supported types are integers, `bool` and `char`\n-   = note: more complex types are supported with `#[feature(const_generics)]`\n+   = help: more complex types are supported with `#[feature(const_generics)]`\n \n error: aborting due to 2 previous errors\n "}, {"sha": "e3e8502ae6349312f0528b86ec1cc2c19f48733b", "filename": "src/test/ui/const-generics/issues/issue-74255.min.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/53d19b37c514246acab020eaba9527cb97c421cf/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-74255.min.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/53d19b37c514246acab020eaba9527cb97c421cf/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-74255.min.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-74255.min.stderr?ref=53d19b37c514246acab020eaba9527cb97c421cf", "patch": "@@ -5,7 +5,7 @@ LL |     fn ice_struct_fn<const I: IceEnum>() {}\n    |                               ^^^^^^^\n    |\n    = note: the only supported types are integers, `bool` and `char`\n-   = note: more complex types are supported with `#[feature(const_generics)]`\n+   = help: more complex types are supported with `#[feature(const_generics)]`\n \n error: aborting due to previous error\n "}, {"sha": "12947a2ab37583497d7dd27645b14a6c206be47c", "filename": "src/test/ui/const-generics/issues/issue-74950.min.stderr", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/53d19b37c514246acab020eaba9527cb97c421cf/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-74950.min.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/53d19b37c514246acab020eaba9527cb97c421cf/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-74950.min.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-74950.min.stderr?ref=53d19b37c514246acab020eaba9527cb97c421cf", "patch": "@@ -5,7 +5,7 @@ LL | struct Outer<const I: Inner>;\n    |                       ^^^^^\n    |\n    = note: the only supported types are integers, `bool` and `char`\n-   = note: more complex types are supported with `#[feature(const_generics)]`\n+   = help: more complex types are supported with `#[feature(const_generics)]`\n \n error: `Inner` is forbidden as the type of a const generic parameter\n   --> $DIR/issue-74950.rs:18:23\n@@ -14,7 +14,7 @@ LL | struct Outer<const I: Inner>;\n    |                       ^^^^^\n    |\n    = note: the only supported types are integers, `bool` and `char`\n-   = note: more complex types are supported with `#[feature(const_generics)]`\n+   = help: more complex types are supported with `#[feature(const_generics)]`\n \n error: `Inner` is forbidden as the type of a const generic parameter\n   --> $DIR/issue-74950.rs:18:23\n@@ -23,7 +23,7 @@ LL | struct Outer<const I: Inner>;\n    |                       ^^^^^\n    |\n    = note: the only supported types are integers, `bool` and `char`\n-   = note: more complex types are supported with `#[feature(const_generics)]`\n+   = help: more complex types are supported with `#[feature(const_generics)]`\n \n error: `Inner` is forbidden as the type of a const generic parameter\n   --> $DIR/issue-74950.rs:18:23\n@@ -32,7 +32,7 @@ LL | struct Outer<const I: Inner>;\n    |                       ^^^^^\n    |\n    = note: the only supported types are integers, `bool` and `char`\n-   = note: more complex types are supported with `#[feature(const_generics)]`\n+   = help: more complex types are supported with `#[feature(const_generics)]`\n \n error: `Inner` is forbidden as the type of a const generic parameter\n   --> $DIR/issue-74950.rs:18:23\n@@ -41,7 +41,7 @@ LL | struct Outer<const I: Inner>;\n    |                       ^^^^^\n    |\n    = note: the only supported types are integers, `bool` and `char`\n-   = note: more complex types are supported with `#[feature(const_generics)]`\n+   = help: more complex types are supported with `#[feature(const_generics)]`\n \n error: aborting due to 5 previous errors\n "}, {"sha": "b87bb18a5a6830cdd8d1e904700d02187b25e8ab", "filename": "src/test/ui/const-generics/issues/issue-75047.min.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/53d19b37c514246acab020eaba9527cb97c421cf/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-75047.min.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/53d19b37c514246acab020eaba9527cb97c421cf/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-75047.min.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-75047.min.stderr?ref=53d19b37c514246acab020eaba9527cb97c421cf", "patch": "@@ -5,7 +5,7 @@ LL | struct Foo<const N: [u8; Bar::<u32>::value()]>;\n    |                     ^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: the only supported types are integers, `bool` and `char`\n-   = note: more complex types are supported with `#[feature(const_generics)]`\n+   = help: more complex types are supported with `#[feature(const_generics)]`\n \n error: aborting due to previous error\n "}, {"sha": "551b8e43e1d4c00298f8f733f4ad74320400a615", "filename": "src/test/ui/const-generics/issues/issue-76701-ty-param-in-const.min.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/53d19b37c514246acab020eaba9527cb97c421cf/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-76701-ty-param-in-const.min.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/53d19b37c514246acab020eaba9527cb97c421cf/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-76701-ty-param-in-const.min.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-76701-ty-param-in-const.min.stderr?ref=53d19b37c514246acab020eaba9527cb97c421cf", "patch": "@@ -5,6 +5,7 @@ LL | fn ty_param<T>() -> [u8; std::mem::size_of::<T>()] {\n    |                                              ^ cannot perform const operation using `T`\n    |\n    = note: type parameters may not be used in const expressions\n+   = help: use `#![feature(const_generics)]` and `#![feature(const_evaluatable_checked)]` to allow generic const expressions\n \n error: generic parameters may not be used in const operations\n   --> $DIR/issue-76701-ty-param-in-const.rs:12:42\n@@ -13,6 +14,7 @@ LL | fn const_param<const N: usize>() -> [u8; N + 1] {\n    |                                          ^ cannot perform const operation using `N`\n    |\n    = help: const parameters may only be used as standalone arguments, i.e. `N`\n+   = help: use `#![feature(const_generics)]` and `#![feature(const_evaluatable_checked)]` to allow generic const expressions\n \n error: aborting due to 2 previous errors\n "}, {"sha": "c400e2c814dd70a872ec58e3a18dff04eff140ce", "filename": "src/test/ui/const-generics/macro_rules-braces.min.stderr", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/53d19b37c514246acab020eaba9527cb97c421cf/src%2Ftest%2Fui%2Fconst-generics%2Fmacro_rules-braces.min.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/53d19b37c514246acab020eaba9527cb97c421cf/src%2Ftest%2Fui%2Fconst-generics%2Fmacro_rules-braces.min.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fmacro_rules-braces.min.stderr?ref=53d19b37c514246acab020eaba9527cb97c421cf", "patch": "@@ -27,6 +27,7 @@ LL |     let _: foo!({{ N }});\n    |                    ^ cannot perform const operation using `N`\n    |\n    = help: const parameters may only be used as standalone arguments, i.e. `N`\n+   = help: use `#![feature(const_generics)]` and `#![feature(const_evaluatable_checked)]` to allow generic const expressions\n \n error: generic parameters may not be used in const operations\n   --> $DIR/macro_rules-braces.rs:41:19\n@@ -35,6 +36,7 @@ LL |     let _: bar!({ N });\n    |                   ^ cannot perform const operation using `N`\n    |\n    = help: const parameters may only be used as standalone arguments, i.e. `N`\n+   = help: use `#![feature(const_generics)]` and `#![feature(const_evaluatable_checked)]` to allow generic const expressions\n \n error: generic parameters may not be used in const operations\n   --> $DIR/macro_rules-braces.rs:46:20\n@@ -43,6 +45,7 @@ LL |     let _: baz!({{ N }});\n    |                    ^ cannot perform const operation using `N`\n    |\n    = help: const parameters may only be used as standalone arguments, i.e. `N`\n+   = help: use `#![feature(const_generics)]` and `#![feature(const_evaluatable_checked)]` to allow generic const expressions\n \n error: generic parameters may not be used in const operations\n   --> $DIR/macro_rules-braces.rs:51:19\n@@ -51,6 +54,7 @@ LL |     let _: biz!({ N });\n    |                   ^ cannot perform const operation using `N`\n    |\n    = help: const parameters may only be used as standalone arguments, i.e. `N`\n+   = help: use `#![feature(const_generics)]` and `#![feature(const_evaluatable_checked)]` to allow generic const expressions\n \n error: aborting due to 6 previous errors\n "}, {"sha": "2ea66279d460881ed3c97f73bb90d01f91269a96", "filename": "src/test/ui/const-generics/min_const_generics/complex-expression.stderr", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/53d19b37c514246acab020eaba9527cb97c421cf/src%2Ftest%2Fui%2Fconst-generics%2Fmin_const_generics%2Fcomplex-expression.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/53d19b37c514246acab020eaba9527cb97c421cf/src%2Ftest%2Fui%2Fconst-generics%2Fmin_const_generics%2Fcomplex-expression.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fmin_const_generics%2Fcomplex-expression.stderr?ref=53d19b37c514246acab020eaba9527cb97c421cf", "patch": "@@ -5,6 +5,7 @@ LL | struct Break0<const N: usize>([u8; { N + 1 }]);\n    |                                      ^ cannot perform const operation using `N`\n    |\n    = help: const parameters may only be used as standalone arguments, i.e. `N`\n+   = help: use `#![feature(const_generics)]` and `#![feature(const_evaluatable_checked)]` to allow generic const expressions\n \n error: generic parameters may not be used in const operations\n   --> $DIR/complex-expression.rs:14:40\n@@ -13,6 +14,7 @@ LL | struct Break1<const N: usize>([u8; { { N } }]);\n    |                                        ^ cannot perform const operation using `N`\n    |\n    = help: const parameters may only be used as standalone arguments, i.e. `N`\n+   = help: use `#![feature(const_generics)]` and `#![feature(const_evaluatable_checked)]` to allow generic const expressions\n \n error: generic parameters may not be used in const operations\n   --> $DIR/complex-expression.rs:18:17\n@@ -21,6 +23,7 @@ LL |     let _: [u8; N + 1];\n    |                 ^ cannot perform const operation using `N`\n    |\n    = help: const parameters may only be used as standalone arguments, i.e. `N`\n+   = help: use `#![feature(const_generics)]` and `#![feature(const_evaluatable_checked)]` to allow generic const expressions\n \n error: generic parameters may not be used in const operations\n   --> $DIR/complex-expression.rs:23:17\n@@ -29,6 +32,7 @@ LL |     let _ = [0; N + 1];\n    |                 ^ cannot perform const operation using `N`\n    |\n    = help: const parameters may only be used as standalone arguments, i.e. `N`\n+   = help: use `#![feature(const_generics)]` and `#![feature(const_evaluatable_checked)]` to allow generic const expressions\n \n error: generic parameters may not be used in const operations\n   --> $DIR/complex-expression.rs:27:45\n@@ -37,6 +41,7 @@ LL | struct BreakTy0<T>(T, [u8; { size_of::<*mut T>() }]);\n    |                                             ^ cannot perform const operation using `T`\n    |\n    = note: type parameters may not be used in const expressions\n+   = help: use `#![feature(const_generics)]` and `#![feature(const_evaluatable_checked)]` to allow generic const expressions\n \n error: generic parameters may not be used in const operations\n   --> $DIR/complex-expression.rs:30:47\n@@ -45,6 +50,7 @@ LL | struct BreakTy1<T>(T, [u8; { { size_of::<*mut T>() } }]);\n    |                                               ^ cannot perform const operation using `T`\n    |\n    = note: type parameters may not be used in const expressions\n+   = help: use `#![feature(const_generics)]` and `#![feature(const_evaluatable_checked)]` to allow generic const expressions\n \n error: generic parameters may not be used in const operations\n   --> $DIR/complex-expression.rs:34:32\n@@ -53,6 +59,7 @@ LL |     let _: [u8; size_of::<*mut T>() + 1];\n    |                                ^ cannot perform const operation using `T`\n    |\n    = note: type parameters may not be used in const expressions\n+   = help: use `#![feature(const_generics)]` and `#![feature(const_evaluatable_checked)]` to allow generic const expressions\n \n warning: cannot use constants which depend on generic parameters in types\n   --> $DIR/complex-expression.rs:39:17"}, {"sha": "5d473f1f8769fa8d477fd7770b888a3a57296d9b", "filename": "src/test/ui/const-generics/min_const_generics/complex-types.stderr", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/53d19b37c514246acab020eaba9527cb97c421cf/src%2Ftest%2Fui%2Fconst-generics%2Fmin_const_generics%2Fcomplex-types.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/53d19b37c514246acab020eaba9527cb97c421cf/src%2Ftest%2Fui%2Fconst-generics%2Fmin_const_generics%2Fcomplex-types.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fmin_const_generics%2Fcomplex-types.stderr?ref=53d19b37c514246acab020eaba9527cb97c421cf", "patch": "@@ -5,7 +5,7 @@ LL | struct Foo<const N: [u8; 0]>;\n    |                     ^^^^^^^\n    |\n    = note: the only supported types are integers, `bool` and `char`\n-   = note: more complex types are supported with `#[feature(const_generics)]`\n+   = help: more complex types are supported with `#[feature(const_generics)]`\n \n error: `()` is forbidden as the type of a const generic parameter\n   --> $DIR/complex-types.rs:7:21\n@@ -14,7 +14,7 @@ LL | struct Bar<const N: ()>;\n    |                     ^^\n    |\n    = note: the only supported types are integers, `bool` and `char`\n-   = note: more complex types are supported with `#[feature(const_generics)]`\n+   = help: more complex types are supported with `#[feature(const_generics)]`\n \n error: `No` is forbidden as the type of a const generic parameter\n   --> $DIR/complex-types.rs:12:21\n@@ -23,7 +23,7 @@ LL | struct Fez<const N: No>;\n    |                     ^^\n    |\n    = note: the only supported types are integers, `bool` and `char`\n-   = note: more complex types are supported with `#[feature(const_generics)]`\n+   = help: more complex types are supported with `#[feature(const_generics)]`\n \n error: `&'static u8` is forbidden as the type of a const generic parameter\n   --> $DIR/complex-types.rs:15:21\n@@ -32,7 +32,7 @@ LL | struct Faz<const N: &'static u8>;\n    |                     ^^^^^^^^^^^\n    |\n    = note: the only supported types are integers, `bool` and `char`\n-   = note: more complex types are supported with `#[feature(const_generics)]`\n+   = help: more complex types are supported with `#[feature(const_generics)]`\n \n error: `!` is forbidden as the type of a const generic parameter\n   --> $DIR/complex-types.rs:18:21\n@@ -41,7 +41,7 @@ LL | struct Fiz<const N: !>;\n    |                     ^\n    |\n    = note: the only supported types are integers, `bool` and `char`\n-   = note: more complex types are supported with `#[feature(const_generics)]`\n+   = help: more complex types are supported with `#[feature(const_generics)]`\n \n error: `()` is forbidden as the type of a const generic parameter\n   --> $DIR/complex-types.rs:21:19\n@@ -50,7 +50,7 @@ LL | enum Goo<const N: ()> { A, B }\n    |                   ^^\n    |\n    = note: the only supported types are integers, `bool` and `char`\n-   = note: more complex types are supported with `#[feature(const_generics)]`\n+   = help: more complex types are supported with `#[feature(const_generics)]`\n \n error: `()` is forbidden as the type of a const generic parameter\n   --> $DIR/complex-types.rs:24:20\n@@ -59,7 +59,7 @@ LL | union Boo<const N: ()> { a: () }\n    |                    ^^\n    |\n    = note: the only supported types are integers, `bool` and `char`\n-   = note: more complex types are supported with `#[feature(const_generics)]`\n+   = help: more complex types are supported with `#[feature(const_generics)]`\n \n error: aborting due to 7 previous errors\n "}, {"sha": "40c73f0b95136bdb9114fa69939eef0c5591afe5", "filename": "src/test/ui/const-generics/min_const_generics/self-ty-in-const-1.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/53d19b37c514246acab020eaba9527cb97c421cf/src%2Ftest%2Fui%2Fconst-generics%2Fmin_const_generics%2Fself-ty-in-const-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/53d19b37c514246acab020eaba9527cb97c421cf/src%2Ftest%2Fui%2Fconst-generics%2Fmin_const_generics%2Fself-ty-in-const-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fmin_const_generics%2Fself-ty-in-const-1.stderr?ref=53d19b37c514246acab020eaba9527cb97c421cf", "patch": "@@ -5,6 +5,7 @@ LL |     fn t1() -> [u8; std::mem::size_of::<Self>()];\n    |                                         ^^^^ cannot perform const operation using `Self`\n    |\n    = note: type parameters may not be used in const expressions\n+   = help: use `#![feature(const_generics)]` and `#![feature(const_evaluatable_checked)]` to allow generic const expressions\n \n error: generic `Self` types are currently not permitted in anonymous constants\n   --> $DIR/self-ty-in-const-1.rs:14:41"}, {"sha": "6c39f6b4c1dc3b8c9f623f0bc3a400fb20e4a480", "filename": "src/test/ui/const-generics/min_const_generics/static-reference-array-const-param.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/53d19b37c514246acab020eaba9527cb97c421cf/src%2Ftest%2Fui%2Fconst-generics%2Fmin_const_generics%2Fstatic-reference-array-const-param.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/53d19b37c514246acab020eaba9527cb97c421cf/src%2Ftest%2Fui%2Fconst-generics%2Fmin_const_generics%2Fstatic-reference-array-const-param.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fmin_const_generics%2Fstatic-reference-array-const-param.stderr?ref=53d19b37c514246acab020eaba9527cb97c421cf", "patch": "@@ -5,7 +5,7 @@ LL | fn a<const X: &'static [u32]>() {}\n    |               ^^^^^^^^^^^^^^\n    |\n    = note: the only supported types are integers, `bool` and `char`\n-   = note: more complex types are supported with `#[feature(const_generics)]`\n+   = help: more complex types are supported with `#[feature(const_generics)]`\n \n error: aborting due to previous error\n "}, {"sha": "6b90329b72cee19b193cfe3ea3e0776ecd96119d", "filename": "src/test/ui/const-generics/min_const_generics/transmute-const-param-static-reference.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/53d19b37c514246acab020eaba9527cb97c421cf/src%2Ftest%2Fui%2Fconst-generics%2Fmin_const_generics%2Ftransmute-const-param-static-reference.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/53d19b37c514246acab020eaba9527cb97c421cf/src%2Ftest%2Fui%2Fconst-generics%2Fmin_const_generics%2Ftransmute-const-param-static-reference.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fmin_const_generics%2Ftransmute-const-param-static-reference.stderr?ref=53d19b37c514246acab020eaba9527cb97c421cf", "patch": "@@ -5,7 +5,7 @@ LL | struct Const<const P: &'static ()>;\n    |                       ^^^^^^^^^^^\n    |\n    = note: the only supported types are integers, `bool` and `char`\n-   = note: more complex types are supported with `#[feature(const_generics)]`\n+   = help: more complex types are supported with `#[feature(const_generics)]`\n \n error: aborting due to previous error\n "}, {"sha": "369e387508e9fc46275fa292dd4362a582f4182d", "filename": "src/test/ui/const-generics/nested-type.min.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/53d19b37c514246acab020eaba9527cb97c421cf/src%2Ftest%2Fui%2Fconst-generics%2Fnested-type.min.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/53d19b37c514246acab020eaba9527cb97c421cf/src%2Ftest%2Fui%2Fconst-generics%2Fnested-type.min.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fnested-type.min.stderr?ref=53d19b37c514246acab020eaba9527cb97c421cf", "patch": "@@ -12,7 +12,7 @@ LL | | }]>;\n    | |__^\n    |\n    = note: the only supported types are integers, `bool` and `char`\n-   = note: more complex types are supported with `#[feature(const_generics)]`\n+   = help: more complex types are supported with `#[feature(const_generics)]`\n \n error[E0015]: calls in constants are limited to constant functions, tuple structs and tuple variants\n   --> $DIR/nested-type.rs:16:5"}, {"sha": "9e0837a0a620c656254809b597f0d020f4f260b7", "filename": "src/test/ui/const-generics/params-in-ct-in-ty-param-lazy-norm.min.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/53d19b37c514246acab020eaba9527cb97c421cf/src%2Ftest%2Fui%2Fconst-generics%2Fparams-in-ct-in-ty-param-lazy-norm.min.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/53d19b37c514246acab020eaba9527cb97c421cf/src%2Ftest%2Fui%2Fconst-generics%2Fparams-in-ct-in-ty-param-lazy-norm.min.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fparams-in-ct-in-ty-param-lazy-norm.min.stderr?ref=53d19b37c514246acab020eaba9527cb97c421cf", "patch": "@@ -13,6 +13,7 @@ LL | struct Foo<T, U = [u8; std::mem::size_of::<T>()]>(T, U);\n    |                                            ^ cannot perform const operation using `T`\n    |\n    = note: type parameters may not be used in const expressions\n+   = help: use `#![feature(const_generics)]` and `#![feature(const_evaluatable_checked)]` to allow generic const expressions\n \n error: constant values inside of type parameter defaults must not depend on generic parameters\n   --> $DIR/params-in-ct-in-ty-param-lazy-norm.rs:12:21"}, {"sha": "46997fed770ac34fb0390fc647d9df383eb337ad", "filename": "src/test/ui/const-generics/slice-const-param-mismatch.min.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/53d19b37c514246acab020eaba9527cb97c421cf/src%2Ftest%2Fui%2Fconst-generics%2Fslice-const-param-mismatch.min.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/53d19b37c514246acab020eaba9527cb97c421cf/src%2Ftest%2Fui%2Fconst-generics%2Fslice-const-param-mismatch.min.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fslice-const-param-mismatch.min.stderr?ref=53d19b37c514246acab020eaba9527cb97c421cf", "patch": "@@ -5,7 +5,7 @@ LL | struct ConstString<const T: &'static str>;\n    |                             ^^^^^^^^^^^^\n    |\n    = note: the only supported types are integers, `bool` and `char`\n-   = note: more complex types are supported with `#[feature(const_generics)]`\n+   = help: more complex types are supported with `#[feature(const_generics)]`\n \n error: `&'static [u8]` is forbidden as the type of a const generic parameter\n   --> $DIR/slice-const-param-mismatch.rs:10:28\n@@ -14,7 +14,7 @@ LL | struct ConstBytes<const T: &'static [u8]>;\n    |                            ^^^^^^^^^^^^^\n    |\n    = note: the only supported types are integers, `bool` and `char`\n-   = note: more complex types are supported with `#[feature(const_generics)]`\n+   = help: more complex types are supported with `#[feature(const_generics)]`\n \n error: aborting due to 2 previous errors\n "}, {"sha": "7a9f65233e7937d3b82858313dca05bb0cd4a513", "filename": "src/test/ui/const-generics/slice-const-param.min.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/53d19b37c514246acab020eaba9527cb97c421cf/src%2Ftest%2Fui%2Fconst-generics%2Fslice-const-param.min.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/53d19b37c514246acab020eaba9527cb97c421cf/src%2Ftest%2Fui%2Fconst-generics%2Fslice-const-param.min.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fslice-const-param.min.stderr?ref=53d19b37c514246acab020eaba9527cb97c421cf", "patch": "@@ -5,7 +5,7 @@ LL | pub fn function_with_str<const STRING: &'static str>() -> &'static str {\n    |                                        ^^^^^^^^^^^^\n    |\n    = note: the only supported types are integers, `bool` and `char`\n-   = note: more complex types are supported with `#[feature(const_generics)]`\n+   = help: more complex types are supported with `#[feature(const_generics)]`\n \n error: `&'static [u8]` is forbidden as the type of a const generic parameter\n   --> $DIR/slice-const-param.rs:13:41\n@@ -14,7 +14,7 @@ LL | pub fn function_with_bytes<const BYTES: &'static [u8]>() -> &'static [u8] {\n    |                                         ^^^^^^^^^^^^^\n    |\n    = note: the only supported types are integers, `bool` and `char`\n-   = note: more complex types are supported with `#[feature(const_generics)]`\n+   = help: more complex types are supported with `#[feature(const_generics)]`\n \n error: aborting due to 2 previous errors\n "}, {"sha": "9274ccd2b921a9965a621ee0676168c58f6bf4a3", "filename": "src/test/ui/const-generics/std/const-generics-range.min.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/53d19b37c514246acab020eaba9527cb97c421cf/src%2Ftest%2Fui%2Fconst-generics%2Fstd%2Fconst-generics-range.min.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/53d19b37c514246acab020eaba9527cb97c421cf/src%2Ftest%2Fui%2Fconst-generics%2Fstd%2Fconst-generics-range.min.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fstd%2Fconst-generics-range.min.stderr?ref=53d19b37c514246acab020eaba9527cb97c421cf", "patch": "@@ -5,7 +5,7 @@ LL | struct _Range<const R: std::ops::Range<usize>>;\n    |                        ^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: the only supported types are integers, `bool` and `char`\n-   = note: more complex types are supported with `#[feature(const_generics)]`\n+   = help: more complex types are supported with `#[feature(const_generics)]`\n \n error: `RangeFrom<usize>` is forbidden as the type of a const generic parameter\n   --> $DIR/const-generics-range.rs:13:28\n@@ -14,7 +14,7 @@ LL | struct _RangeFrom<const R: std::ops::RangeFrom<usize>>;\n    |                            ^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: the only supported types are integers, `bool` and `char`\n-   = note: more complex types are supported with `#[feature(const_generics)]`\n+   = help: more complex types are supported with `#[feature(const_generics)]`\n \n error: `RangeFull` is forbidden as the type of a const generic parameter\n   --> $DIR/const-generics-range.rs:18:28\n@@ -23,7 +23,7 @@ LL | struct _RangeFull<const R: std::ops::RangeFull>;\n    |                            ^^^^^^^^^^^^^^^^^^^\n    |\n    = note: the only supported types are integers, `bool` and `char`\n-   = note: more complex types are supported with `#[feature(const_generics)]`\n+   = help: more complex types are supported with `#[feature(const_generics)]`\n \n error: `RangeInclusive<usize>` is forbidden as the type of a const generic parameter\n   --> $DIR/const-generics-range.rs:24:33\n@@ -32,7 +32,7 @@ LL | struct _RangeInclusive<const R: std::ops::RangeInclusive<usize>>;\n    |                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: the only supported types are integers, `bool` and `char`\n-   = note: more complex types are supported with `#[feature(const_generics)]`\n+   = help: more complex types are supported with `#[feature(const_generics)]`\n \n error: `RangeTo<usize>` is forbidden as the type of a const generic parameter\n   --> $DIR/const-generics-range.rs:29:26\n@@ -41,7 +41,7 @@ LL | struct _RangeTo<const R: std::ops::RangeTo<usize>>;\n    |                          ^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: the only supported types are integers, `bool` and `char`\n-   = note: more complex types are supported with `#[feature(const_generics)]`\n+   = help: more complex types are supported with `#[feature(const_generics)]`\n \n error: `RangeToInclusive<usize>` is forbidden as the type of a const generic parameter\n   --> $DIR/const-generics-range.rs:34:35\n@@ -50,7 +50,7 @@ LL | struct _RangeToInclusive<const R: std::ops::RangeToInclusive<usize>>;\n    |                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: the only supported types are integers, `bool` and `char`\n-   = note: more complex types are supported with `#[feature(const_generics)]`\n+   = help: more complex types are supported with `#[feature(const_generics)]`\n \n error: aborting due to 6 previous errors\n "}, {"sha": "8f240f0d930a4ba7d2bcb04e58b02c91f5f59018", "filename": "src/test/ui/const-generics/type-dependent/issue-71348.min.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/53d19b37c514246acab020eaba9527cb97c421cf/src%2Ftest%2Fui%2Fconst-generics%2Ftype-dependent%2Fissue-71348.min.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/53d19b37c514246acab020eaba9527cb97c421cf/src%2Ftest%2Fui%2Fconst-generics%2Ftype-dependent%2Fissue-71348.min.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Ftype-dependent%2Fissue-71348.min.stderr?ref=53d19b37c514246acab020eaba9527cb97c421cf", "patch": "@@ -5,7 +5,7 @@ LL | trait Get<'a, const N: &'static str> {\n    |                        ^^^^^^^^^^^^\n    |\n    = note: the only supported types are integers, `bool` and `char`\n-   = note: more complex types are supported with `#[feature(const_generics)]`\n+   = help: more complex types are supported with `#[feature(const_generics)]`\n \n error: `&'static str` is forbidden as the type of a const generic parameter\n   --> $DIR/issue-71348.rs:19:25\n@@ -14,7 +14,7 @@ LL |     fn ask<'a, const N: &'static str>(&'a self) -> &'a <Self as Get<N>>::Ta\n    |                         ^^^^^^^^^^^^\n    |\n    = note: the only supported types are integers, `bool` and `char`\n-   = note: more complex types are supported with `#[feature(const_generics)]`\n+   = help: more complex types are supported with `#[feature(const_generics)]`\n \n error: aborting due to 2 previous errors\n "}, {"sha": "99142cb6ce7a585d959109023fb87942596d6796", "filename": "src/test/ui/const-generics/wf-misc.min.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/53d19b37c514246acab020eaba9527cb97c421cf/src%2Ftest%2Fui%2Fconst-generics%2Fwf-misc.min.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/53d19b37c514246acab020eaba9527cb97c421cf/src%2Ftest%2Fui%2Fconst-generics%2Fwf-misc.min.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fwf-misc.min.stderr?ref=53d19b37c514246acab020eaba9527cb97c421cf", "patch": "@@ -5,6 +5,7 @@ LL |     let _: [u8; N + 1];\n    |                 ^ cannot perform const operation using `N`\n    |\n    = help: const parameters may only be used as standalone arguments, i.e. `N`\n+   = help: use `#![feature(const_generics)]` and `#![feature(const_evaluatable_checked)]` to allow generic const expressions\n \n error: generic parameters may not be used in const operations\n   --> $DIR/wf-misc.rs:17:21\n@@ -13,6 +14,7 @@ LL |     let _: Const::<{N + 1}>;\n    |                     ^ cannot perform const operation using `N`\n    |\n    = help: const parameters may only be used as standalone arguments, i.e. `N`\n+   = help: use `#![feature(const_generics)]` and `#![feature(const_evaluatable_checked)]` to allow generic const expressions\n \n error: aborting due to 2 previous errors\n "}]}