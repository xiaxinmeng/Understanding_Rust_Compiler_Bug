{"sha": "ea6fe08751d8794f70d0eb6692c123d611ab3542", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVhNmZlMDg3NTFkODc5NGY3MGQwZWI2NjkyYzEyM2Q2MTFhYjM1NDI=", "commit": {"author": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2018-09-09T18:43:10Z"}, "committer": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2018-09-09T18:43:10Z"}, "message": "Split explain_why_borrow_contains_point into two functions\n\nAllows callers to change other parts of their message based on the\nexplanation", "tree": {"sha": "cbad1f379a91ef8907128309121fda27b6d414e1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cbad1f379a91ef8907128309121fda27b6d414e1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ea6fe08751d8794f70d0eb6692c123d611ab3542", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ea6fe08751d8794f70d0eb6692c123d611ab3542", "html_url": "https://github.com/rust-lang/rust/commit/ea6fe08751d8794f70d0eb6692c123d611ab3542", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ea6fe08751d8794f70d0eb6692c123d611ab3542/comments", "author": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "df6ba0c4acceb5f63090bb20bd23f29c4f439376", "url": "https://api.github.com/repos/rust-lang/rust/commits/df6ba0c4acceb5f63090bb20bd23f29c4f439376", "html_url": "https://github.com/rust-lang/rust/commit/df6ba0c4acceb5f63090bb20bd23f29c4f439376"}], "stats": {"total": 108, "additions": 86, "deletions": 22}, "files": [{"sha": "414cb1d6f05c2589f88a1f093fd2010c81590067", "filename": "src/librustc_mir/borrow_check/nll/explain_borrow/mod.rs", "status": "modified", "additions": 86, "deletions": 22, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/ea6fe08751d8794f70d0eb6692c123d611ab3542/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea6fe08751d8794f70d0eb6692c123d611ab3542/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Fmod.rs?ref=ea6fe08751d8794f70d0eb6692c123d611ab3542", "patch": "@@ -11,11 +11,28 @@\n use borrow_check::borrow_set::BorrowData;\n use borrow_check::nll::region_infer::Cause;\n use borrow_check::{Context, MirBorrowckCtxt, WriteKind};\n-use rustc::mir::{Location, Place, TerminatorKind};\n+use rustc::mir::{Local, Location, Place, TerminatorKind};\n use rustc_errors::DiagnosticBuilder;\n+use rustc::ty::Region;\n \n mod find_use;\n \n+#[derive(Copy, Clone, Debug)]\n+pub enum BorrowContainsPointReason<'tcx> {\n+    Liveness {\n+        local: Local,\n+        location: Location,\n+        in_loop: bool,\n+    },\n+    DropLiveness {\n+        local: Local,\n+        location: Location,\n+    },\n+    OutlivesFreeRegion {\n+        outlived_region: Option<Region<'tcx>>,\n+    },\n+}\n+\n impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n     /// Adds annotations to `err` explaining *why* the borrow contains the\n     /// point from `context`. This is key for the \"3-point errors\"\n@@ -32,15 +49,30 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n     ///\n     /// [d]: https://rust-lang.github.io/rfcs/2094-nll.html#leveraging-intuition-framing-errors-in-terms-of-points\n     pub(in borrow_check) fn explain_why_borrow_contains_point(\n-        &mut self,\n+        &self,\n         context: Context,\n         borrow: &BorrowData<'tcx>,\n         kind_place: Option<(WriteKind, &Place<'tcx>)>,\n         err: &mut DiagnosticBuilder<'_>,\n     ) {\n+        let reason = self.find_why_borrow_contains_point(context, borrow);\n+        self.report_why_borrow_contains_point(err, reason, kind_place);\n+    }\n+\n+    /// Finds the reason that [explain_why_borrow_contains_point] will report\n+    /// but doesn't add it to any message. This is a separate function in case\n+    /// the caller wants to change the error they report based on the reason\n+    /// that will be reported.\n+    pub(in borrow_check) fn find_why_borrow_contains_point(\n+        &self,\n+        context: Context,\n+        borrow: &BorrowData<'tcx>\n+    ) -> BorrowContainsPointReason<'tcx> {\n+        use self::BorrowContainsPointReason::*;\n+\n         debug!(\n-            \"explain_why_borrow_contains_point(context={:?}, borrow={:?}, kind_place={:?})\",\n-            context, borrow, kind_place,\n+            \"find_why_borrow_contains_point(context={:?}, borrow={:?})\",\n+            context, borrow,\n         );\n \n         let regioncx = &self.nonlexical_regioncx;\n@@ -62,11 +94,45 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         );\n \n         match find_use::find(mir, regioncx, tcx, region_sub, context.loc) {\n-            Some(Cause::LiveVar(local, location)) => {\n+            Some(Cause::LiveVar(local, location)) => Liveness {\n+                local,\n+                location,\n+                in_loop: self.is_borrow_location_in_loop(context.loc),\n+            },\n+            Some(Cause::DropVar(local, location)) => DropLiveness {\n+                local,\n+                location,\n+            },\n+            None => OutlivesFreeRegion {\n+                outlived_region: regioncx.to_error_region(region_sub),\n+            },\n+        }\n+    }\n+\n+    /// Adds annotations to `err` for the explanation `reason`. This is a\n+    /// separate method so that the caller can change their error message based\n+    /// on the reason that is going to be reported.\n+    pub (in borrow_check) fn report_why_borrow_contains_point(\n+        &self,\n+        err: &mut DiagnosticBuilder,\n+        reason: BorrowContainsPointReason<'tcx>,\n+        kind_place: Option<(WriteKind, &Place<'tcx>)>,\n+    ) {\n+        use self::BorrowContainsPointReason::*;\n+\n+        debug!(\n+            \"find_why_borrow_contains_point(reason={:?}, kind_place={:?})\",\n+            reason, kind_place,\n+        );\n+\n+        let mir = self.mir;\n+\n+        match reason {\n+            Liveness { local, location, in_loop } => {\n                 let span = mir.source_info(location).span;\n                 let spans = self.move_spans(&Place::Local(local), location)\n                     .or_else(|| self.borrow_spans(span, location));\n-                let message = if self.is_borrow_location_in_loop(context.loc) {\n+                let message = if in_loop {\n                     if spans.for_closure() {\n                         \"borrow captured here by closure in later iteration of loop\"\n                     } else {\n@@ -81,8 +147,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 };\n                 err.span_label(spans.var_or_use(), message);\n             }\n-\n-            Some(Cause::DropVar(local, location)) => match &mir.local_decls[local].name {\n+            DropLiveness { local, location } => match &mir.local_decls[local].name {\n                 Some(local_name) => {\n                     err.span_label(\n                         mir.source_info(location).span,\n@@ -93,31 +158,29 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                         if let Place::Local(borrowed_local) = place {\n                             let dropped_local_scope = mir.local_decls[local].visibility_scope;\n                             let borrowed_local_scope =\n-                                mir.local_decls[*borrowed_local].visibility_scope;\n+                            mir.local_decls[*borrowed_local].visibility_scope;\n \n                             if mir.is_sub_scope(borrowed_local_scope, dropped_local_scope) {\n                                 err.note(\n-                                    \"values in a scope are dropped \\\n-                                     in the opposite order they are defined\",\n+                                \"values in a scope are dropped \\\n+                                                     in the opposite order they are defined\",\n                                 );\n                             }\n                         }\n                     }\n                 }\n \n                 None => {}\n-            },\n-\n-            None => {\n-                if let Some(region) = regioncx.to_error_region(region_sub) {\n-                    self.tcx.note_and_explain_free_region(\n-                        err,\n-                        \"borrowed value must be valid for \",\n-                        region,\n-                        \"...\",\n-                    );\n-                }\n             }\n+            OutlivesFreeRegion { outlived_region: Some(region) } => {\n+                self.tcx.note_and_explain_free_region(\n+                    err,\n+                    \"borrowed value must be valid for \",\n+                    region,\n+                    \"...\",\n+                );\n+            }\n+            OutlivesFreeRegion { outlived_region: None } => (),\n         }\n     }\n \n@@ -193,3 +256,4 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         false\n     }\n }\n+"}]}