{"sha": "03b055b0b4dcf304cd3c5e7a1c6e68fea91584a9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAzYjA1NWIwYjRkY2YzMDRjZDNjNWU3YTFjNmU2OGZlYTkxNTg0YTk=", "commit": {"author": {"name": "Tim Diekmann", "email": "tim.diekmann@3dvision.de", "date": "2020-03-25T20:12:12Z"}, "committer": {"name": "Tim Diekmann", "email": "tim.diekmann@3dvision.de", "date": "2020-03-26T16:14:12Z"}, "message": "Remove alignment from `MemoryBlock`", "tree": {"sha": "756da5c6b9cc313eae56f2e6c1af896597f7facf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/756da5c6b9cc313eae56f2e6c1af896597f7facf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/03b055b0b4dcf304cd3c5e7a1c6e68fea91584a9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/03b055b0b4dcf304cd3c5e7a1c6e68fea91584a9", "html_url": "https://github.com/rust-lang/rust/commit/03b055b0b4dcf304cd3c5e7a1c6e68fea91584a9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/03b055b0b4dcf304cd3c5e7a1c6e68fea91584a9/comments", "author": {"login": "TimDiekmann", "id": 21277928, "node_id": "MDQ6VXNlcjIxMjc3OTI4", "avatar_url": "https://avatars.githubusercontent.com/u/21277928?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TimDiekmann", "html_url": "https://github.com/TimDiekmann", "followers_url": "https://api.github.com/users/TimDiekmann/followers", "following_url": "https://api.github.com/users/TimDiekmann/following{/other_user}", "gists_url": "https://api.github.com/users/TimDiekmann/gists{/gist_id}", "starred_url": "https://api.github.com/users/TimDiekmann/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TimDiekmann/subscriptions", "organizations_url": "https://api.github.com/users/TimDiekmann/orgs", "repos_url": "https://api.github.com/users/TimDiekmann/repos", "events_url": "https://api.github.com/users/TimDiekmann/events{/privacy}", "received_events_url": "https://api.github.com/users/TimDiekmann/received_events", "type": "User", "site_admin": false}, "committer": {"login": "TimDiekmann", "id": 21277928, "node_id": "MDQ6VXNlcjIxMjc3OTI4", "avatar_url": "https://avatars.githubusercontent.com/u/21277928?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TimDiekmann", "html_url": "https://github.com/TimDiekmann", "followers_url": "https://api.github.com/users/TimDiekmann/followers", "following_url": "https://api.github.com/users/TimDiekmann/following{/other_user}", "gists_url": "https://api.github.com/users/TimDiekmann/gists{/gist_id}", "starred_url": "https://api.github.com/users/TimDiekmann/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TimDiekmann/subscriptions", "organizations_url": "https://api.github.com/users/TimDiekmann/orgs", "repos_url": "https://api.github.com/users/TimDiekmann/repos", "events_url": "https://api.github.com/users/TimDiekmann/events{/privacy}", "received_events_url": "https://api.github.com/users/TimDiekmann/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bfbdb5f06fcff7939825c33ce573b8f92b362c40", "url": "https://api.github.com/repos/rust-lang/rust/commits/bfbdb5f06fcff7939825c33ce573b8f92b362c40", "html_url": "https://github.com/rust-lang/rust/commit/bfbdb5f06fcff7939825c33ce573b8f92b362c40"}], "stats": {"total": 413, "additions": 211, "deletions": 202}, "files": [{"sha": "b0442026866456a64e88a70d30450a6a3ca25ea4", "filename": "src/liballoc/alloc.rs", "status": "modified", "additions": 31, "deletions": 31, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/03b055b0b4dcf304cd3c5e7a1c6e68fea91584a9/src%2Fliballoc%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03b055b0b4dcf304cd3c5e7a1c6e68fea91584a9/src%2Fliballoc%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Falloc.rs?ref=03b055b0b4dcf304cd3c5e7a1c6e68fea91584a9", "patch": "@@ -4,7 +4,7 @@\n \n use core::intrinsics::{self, min_align_of_val, size_of_val};\n use core::ptr::{NonNull, Unique};\n-use core::{mem, usize};\n+use core::usize;\n \n #[stable(feature = \"alloc_module\", since = \"1.28.0\")]\n #[doc(inline)]\n@@ -167,94 +167,94 @@ unsafe impl AllocRef for Global {\n     #[inline]\n     fn alloc(&mut self, layout: Layout, init: AllocInit) -> Result<MemoryBlock, AllocErr> {\n         unsafe {\n-            if layout.size() == 0 {\n-                Ok(MemoryBlock::new(layout.dangling(), layout))\n+            let size = layout.size();\n+            if size == 0 {\n+                Ok(MemoryBlock::new(layout.dangling(), 0))\n             } else {\n                 let raw_ptr = match init {\n                     AllocInit::Uninitialized => alloc(layout),\n                     AllocInit::Zeroed => alloc_zeroed(layout),\n                 };\n                 let ptr = NonNull::new(raw_ptr).ok_or(AllocErr)?;\n-                Ok(MemoryBlock::new(ptr, layout))\n+                Ok(MemoryBlock::new(ptr, size))\n             }\n         }\n     }\n \n     #[inline]\n-    unsafe fn dealloc(&mut self, memory: MemoryBlock) {\n-        if memory.size() != 0 {\n-            dealloc(memory.ptr().as_ptr(), memory.layout())\n+    unsafe fn dealloc(&mut self, ptr: NonNull<u8>, layout: Layout) {\n+        if layout.size() != 0 {\n+            dealloc(ptr.as_ptr(), layout)\n         }\n     }\n \n     #[inline]\n     unsafe fn grow(\n         &mut self,\n-        memory: &mut MemoryBlock,\n+        ptr: NonNull<u8>,\n+        layout: Layout,\n         new_size: usize,\n         placement: ReallocPlacement,\n         init: AllocInit,\n-    ) -> Result<(), AllocErr> {\n-        let old_size = memory.size();\n+    ) -> Result<MemoryBlock, AllocErr> {\n+        let old_size = layout.size();\n         debug_assert!(\n             new_size >= old_size,\n             \"`new_size` must be greater than or equal to `memory.size()`\"\n         );\n \n         if old_size == new_size {\n-            return Ok(());\n+            return Ok(MemoryBlock::new(ptr, old_size));\n         }\n \n-        let new_layout = Layout::from_size_align_unchecked(new_size, memory.align());\n         match placement {\n-            ReallocPlacement::InPlace => return Err(AllocErr),\n-            ReallocPlacement::MayMove if memory.size() == 0 => {\n-                *memory = self.alloc(new_layout, init)?\n+            ReallocPlacement::InPlace => Err(AllocErr),\n+            ReallocPlacement::MayMove if layout.size() == 0 => {\n+                let new_layout = Layout::from_size_align_unchecked(new_size, layout.align());\n+                self.alloc(new_layout, init)\n             }\n             ReallocPlacement::MayMove => {\n                 // `realloc` probably checks for `new_size > old_size` or something similar.\n                 intrinsics::assume(new_size > old_size);\n-                let ptr = realloc(memory.ptr().as_ptr(), memory.layout(), new_size);\n-                *memory = MemoryBlock::new(NonNull::new(ptr).ok_or(AllocErr)?, new_layout);\n+                let ptr = realloc(ptr.as_ptr(), layout, new_size);\n+                let mut memory = MemoryBlock::new(NonNull::new(ptr).ok_or(AllocErr)?, new_size);\n                 memory.init_offset(init, old_size);\n+                Ok(memory)\n             }\n         }\n-        Ok(())\n     }\n \n     #[inline]\n     unsafe fn shrink(\n         &mut self,\n-        memory: &mut MemoryBlock,\n+        ptr: NonNull<u8>,\n+        layout: Layout,\n         new_size: usize,\n         placement: ReallocPlacement,\n-    ) -> Result<(), AllocErr> {\n-        let old_size = memory.size();\n+    ) -> Result<MemoryBlock, AllocErr> {\n+        let old_size = layout.size();\n         debug_assert!(\n             new_size <= old_size,\n             \"`new_size` must be smaller than or equal to `memory.size()`\"\n         );\n \n         if old_size == new_size {\n-            return Ok(());\n+            return Ok(MemoryBlock::new(ptr, old_size));\n         }\n \n-        let new_layout = Layout::from_size_align_unchecked(new_size, memory.align());\n         match placement {\n-            ReallocPlacement::InPlace => return Err(AllocErr),\n+            ReallocPlacement::InPlace => Err(AllocErr),\n             ReallocPlacement::MayMove if new_size == 0 => {\n-                let new_memory = MemoryBlock::new(new_layout.dangling(), new_layout);\n-                let old_memory = mem::replace(memory, new_memory);\n-                self.dealloc(old_memory)\n+                self.dealloc(ptr, layout);\n+                Ok(MemoryBlock::new(layout.dangling(), 0))\n             }\n             ReallocPlacement::MayMove => {\n                 // `realloc` probably checks for `new_size < old_size` or something similar.\n                 intrinsics::assume(new_size < old_size);\n-                let ptr = realloc(memory.ptr().as_ptr(), memory.layout(), new_size);\n-                *memory = MemoryBlock::new(NonNull::new(ptr).ok_or(AllocErr)?, new_layout);\n+                let ptr = realloc(ptr.as_ptr(), layout, new_size);\n+                Ok(MemoryBlock::new(NonNull::new(ptr).ok_or(AllocErr)?, new_size))\n             }\n         }\n-        Ok(())\n     }\n }\n \n@@ -282,7 +282,7 @@ pub(crate) unsafe fn box_free<T: ?Sized>(ptr: Unique<T>) {\n     let size = size_of_val(ptr.as_ref());\n     let align = min_align_of_val(ptr.as_ref());\n     let layout = Layout::from_size_align_unchecked(size, align);\n-    Global.dealloc(MemoryBlock::new(ptr.cast().into(), layout))\n+    Global.dealloc(ptr.cast().into(), layout)\n }\n \n /// Abort on memory allocation error or failure."}, {"sha": "7fa71f72ee779998eb075101f95b04ada292e171", "filename": "src/liballoc/alloc/tests.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/03b055b0b4dcf304cd3c5e7a1c6e68fea91584a9/src%2Fliballoc%2Falloc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03b055b0b4dcf304cd3c5e7a1c6e68fea91584a9/src%2Fliballoc%2Falloc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Falloc%2Ftests.rs?ref=03b055b0b4dcf304cd3c5e7a1c6e68fea91584a9", "patch": "@@ -18,7 +18,7 @@ fn allocate_zeroed() {\n             assert_eq!(*i, 0);\n             i = i.offset(1);\n         }\n-        Global.dealloc(memory);\n+        Global.dealloc(memory.ptr(), layout);\n     }\n }\n "}, {"sha": "11c1429957326345ec5bb25215184583a6183359", "filename": "src/liballoc/collections/btree/node.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/03b055b0b4dcf304cd3c5e7a1c6e68fea91584a9/src%2Fliballoc%2Fcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03b055b0b4dcf304cd3c5e7a1c6e68fea91584a9/src%2Fliballoc%2Fcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fnode.rs?ref=03b055b0b4dcf304cd3c5e7a1c6e68fea91584a9", "patch": "@@ -31,7 +31,6 @@\n // - A node of length `n` has `n` keys, `n` values, and (in an internal node) `n + 1` edges.\n //   This implies that even an empty internal node has at least one edge.\n \n-use core::alloc::MemoryBlock;\n use core::cmp::Ordering;\n use core::marker::PhantomData;\n use core::mem::{self, MaybeUninit};\n@@ -228,10 +227,7 @@ impl<K, V> Root<K, V> {\n         }\n \n         unsafe {\n-            Global.dealloc(MemoryBlock::new(\n-                NonNull::from(top).cast(),\n-                Layout::new::<InternalNode<K, V>>(),\n-            ));\n+            Global.dealloc(NonNull::from(top).cast(), Layout::new::<InternalNode<K, V>>());\n         }\n     }\n }\n@@ -396,14 +392,14 @@ impl<K, V> NodeRef<marker::Owned, K, V, marker::LeafOrInternal> {\n         let height = self.height;\n         let node = self.node;\n         let ret = self.ascend().ok();\n-        Global.dealloc(MemoryBlock::new(\n+        Global.dealloc(\n             node.cast(),\n             if height > 0 {\n                 Layout::new::<InternalNode<K, V>>()\n             } else {\n                 Layout::new::<LeafNode<K, V>>()\n             },\n-        ));\n+        );\n         ret\n     }\n }\n@@ -1167,7 +1163,7 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>, marker::\n             } else {\n                 Layout::new::<LeafNode<K, V>>()\n             };\n-            Global.dealloc(MemoryBlock::new(right_node.node.cast(), layout));\n+            Global.dealloc(right_node.node.cast(), layout);\n \n             Handle::new_edge(self.node, self.idx)\n         }"}, {"sha": "a1f9a9291af4aff737700abd7caca2afaf882c9b", "filename": "src/liballoc/raw_vec.rs", "status": "modified", "additions": 19, "deletions": 23, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/03b055b0b4dcf304cd3c5e7a1c6e68fea91584a9/src%2Fliballoc%2Fraw_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03b055b0b4dcf304cd3c5e7a1c6e68fea91584a9/src%2Fliballoc%2Fraw_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fraw_vec.rs?ref=03b055b0b4dcf304cd3c5e7a1c6e68fea91584a9", "patch": "@@ -5,7 +5,7 @@ use core::alloc::MemoryBlock;\n use core::cmp;\n use core::mem::{self, MaybeUninit};\n use core::ops::Drop;\n-use core::ptr::Unique;\n+use core::ptr::{NonNull, Unique};\n use core::slice;\n \n use crate::alloc::{\n@@ -197,7 +197,7 @@ impl<T, A: AllocRef> RawVec<T, A> {\n         &mut self.alloc\n     }\n \n-    fn current_memory(&self) -> Option<MemoryBlock> {\n+    fn current_memory(&self) -> Option<(NonNull<u8>, Layout)> {\n         if mem::size_of::<T>() == 0 || self.cap == 0 {\n             None\n         } else {\n@@ -207,7 +207,7 @@ impl<T, A: AllocRef> RawVec<T, A> {\n                 let align = mem::align_of::<T>();\n                 let size = mem::size_of::<T>() * self.cap;\n                 let layout = Layout::from_size_align_unchecked(size, align);\n-                Some(MemoryBlock::new(self.ptr.cast().into(), layout))\n+                Some((self.ptr.cast().into(), layout))\n             }\n         }\n     }\n@@ -472,7 +472,6 @@ impl<T, A: AllocRef> RawVec<T, A> {\n     fn set_memory(&mut self, memory: MemoryBlock) {\n         self.ptr = memory.ptr().cast().into();\n         self.cap = Self::capacity_from_bytes(memory.size());\n-        drop(memory);\n     }\n \n     /// Single method to handle all possibilities of growing the buffer.\n@@ -488,7 +487,7 @@ impl<T, A: AllocRef> RawVec<T, A> {\n             // 0, getting to here necessarily means the `RawVec` is overfull.\n             return Err(CapacityOverflow);\n         }\n-        let layout = match strategy {\n+        let new_layout = match strategy {\n             Double => unsafe {\n                 // Since we guarantee that we never allocate more than `isize::MAX` bytes,\n                 // `elem_size * self.cap <= isize::MAX` as a precondition, so this can't overflow.\n@@ -522,22 +521,20 @@ impl<T, A: AllocRef> RawVec<T, A> {\n             }\n         };\n \n-        let memory = if let Some(mut memory) = self.current_memory() {\n-            debug_assert_eq!(memory.align(), layout.align());\n+        let memory = if let Some((ptr, old_layout)) = self.current_memory() {\n+            debug_assert_eq!(old_layout.align(), new_layout.align());\n             unsafe {\n                 self.alloc\n-                    .grow(&mut memory, layout.size(), placement, init)\n-                    .map_err(|_| AllocError { layout, non_exhaustive: () })?\n-            };\n-            memory\n+                    .grow(ptr, old_layout, new_layout.size(), placement, init)\n+                    .map_err(|_| AllocError { layout: new_layout, non_exhaustive: () })?\n+            }\n         } else {\n             match placement {\n-                MayMove => self.alloc.alloc(layout, init),\n+                MayMove => self.alloc.alloc(new_layout, init),\n                 InPlace => Err(AllocErr),\n             }\n-            .map_err(|_| AllocError { layout, non_exhaustive: () })?\n+            .map_err(|_| AllocError { layout: new_layout, non_exhaustive: () })?\n         };\n-\n         self.set_memory(memory);\n         Ok(())\n     }\n@@ -549,18 +546,17 @@ impl<T, A: AllocRef> RawVec<T, A> {\n     ) -> Result<(), TryReserveError> {\n         assert!(amount <= self.capacity(), \"Tried to shrink to a larger capacity\");\n \n-        let mut memory = if let Some(mem) = self.current_memory() { mem } else { return Ok(()) };\n+        let (ptr, layout) = if let Some(mem) = self.current_memory() { mem } else { return Ok(()) };\n         let new_size = amount * mem::size_of::<T>();\n \n-        unsafe {\n-            self.alloc.shrink(&mut memory, new_size, placement).map_err(|_| {\n+        let memory = unsafe {\n+            self.alloc.shrink(ptr, layout, new_size, placement).map_err(|_| {\n                 TryReserveError::AllocError {\n-                    layout: Layout::from_size_align_unchecked(new_size, memory.align()),\n+                    layout: Layout::from_size_align_unchecked(new_size, layout.align()),\n                     non_exhaustive: (),\n                 }\n-            })?;\n-        }\n-\n+            })?\n+        };\n         self.set_memory(memory);\n         Ok(())\n     }\n@@ -593,8 +589,8 @@ impl<T> RawVec<T, Global> {\n unsafe impl<#[may_dangle] T, A: AllocRef> Drop for RawVec<T, A> {\n     /// Frees the memory owned by the `RawVec` *without* trying to drop its contents.\n     fn drop(&mut self) {\n-        if let Some(memory) = self.current_memory() {\n-            unsafe { self.alloc.dealloc(memory) }\n+        if let Some((ptr, layout)) = self.current_memory() {\n+            unsafe { self.alloc.dealloc(ptr, layout) }\n         }\n     }\n }"}, {"sha": "e7ab8a305d2797c83e5cf399dfc007bf581565b5", "filename": "src/liballoc/raw_vec/tests.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/03b055b0b4dcf304cd3c5e7a1c6e68fea91584a9/src%2Fliballoc%2Fraw_vec%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03b055b0b4dcf304cd3c5e7a1c6e68fea91584a9/src%2Fliballoc%2Fraw_vec%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fraw_vec%2Ftests.rs?ref=03b055b0b4dcf304cd3c5e7a1c6e68fea91584a9", "patch": "@@ -34,8 +34,8 @@ fn allocator_param() {\n                 err @ Err(_) => err,\n             }\n         }\n-        unsafe fn dealloc(&mut self, memory: MemoryBlock) {\n-            Global.dealloc(memory)\n+        unsafe fn dealloc(&mut self, ptr: NonNull<u8>, layout: Layout) {\n+            Global.dealloc(ptr, layout)\n         }\n     }\n "}, {"sha": "ab344be12de1bf0bae650ecc1d39ccd4070b8100", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 3, "deletions": 10, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/03b055b0b4dcf304cd3c5e7a1c6e68fea91584a9/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03b055b0b4dcf304cd3c5e7a1c6e68fea91584a9/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=03b055b0b4dcf304cd3c5e7a1c6e68fea91584a9", "patch": "@@ -234,7 +234,6 @@ use crate::boxed::Box;\n #[cfg(test)]\n use std::boxed::Box;\n \n-use core::alloc::MemoryBlock;\n use core::any::Any;\n use core::array::LengthAtMost32;\n use core::borrow;\n@@ -1032,7 +1031,7 @@ impl<T> Rc<[T]> {\n                     let slice = from_raw_parts_mut(self.elems, self.n_elems);\n                     ptr::drop_in_place(slice);\n \n-                    Global.dealloc(MemoryBlock::new(self.mem, self.layout));\n+                    Global.dealloc(self.mem, self.layout);\n                 }\n             }\n         }\n@@ -1132,10 +1131,7 @@ unsafe impl<#[may_dangle] T: ?Sized> Drop for Rc<T> {\n                 self.dec_weak();\n \n                 if self.weak() == 0 {\n-                    Global.dealloc(MemoryBlock::new(\n-                        self.ptr.cast(),\n-                        Layout::for_value(self.ptr.as_ref()),\n-                    ));\n+                    Global.dealloc(self.ptr.cast(), Layout::for_value(self.ptr.as_ref()));\n                 }\n             }\n         }\n@@ -1943,10 +1939,7 @@ impl<T: ?Sized> Drop for Weak<T> {\n             // the strong pointers have disappeared.\n             if inner.weak() == 0 {\n                 unsafe {\n-                    Global.dealloc(MemoryBlock::new(\n-                        self.ptr.cast(),\n-                        Layout::for_value(self.ptr.as_ref()),\n-                    ));\n+                    Global.dealloc(self.ptr.cast(), Layout::for_value(self.ptr.as_ref()));\n                 }\n             }\n         }"}, {"sha": "1adc7fa3040b3f3754edc21c830068f3c968bbc3", "filename": "src/liballoc/sync.rs", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/03b055b0b4dcf304cd3c5e7a1c6e68fea91584a9/src%2Fliballoc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03b055b0b4dcf304cd3c5e7a1c6e68fea91584a9/src%2Fliballoc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fsync.rs?ref=03b055b0b4dcf304cd3c5e7a1c6e68fea91584a9", "patch": "@@ -6,7 +6,6 @@\n //!\n //! [arc]: struct.Arc.html\n \n-use core::alloc::MemoryBlock;\n use core::any::Any;\n use core::array::LengthAtMost32;\n use core::borrow;\n@@ -771,7 +770,7 @@ impl<T: ?Sized> Arc<T> {\n \n         if self.inner().weak.fetch_sub(1, Release) == 1 {\n             acquire!(self.inner().weak);\n-            Global.dealloc(MemoryBlock::new(self.ptr.cast(), Layout::for_value(self.ptr.as_ref())))\n+            Global.dealloc(self.ptr.cast(), Layout::for_value(self.ptr.as_ref()))\n         }\n     }\n \n@@ -910,7 +909,7 @@ impl<T> Arc<[T]> {\n                     let slice = from_raw_parts_mut(self.elems, self.n_elems);\n                     ptr::drop_in_place(slice);\n \n-                    Global.dealloc(MemoryBlock::new(self.mem.cast(), self.layout));\n+                    Global.dealloc(self.mem.cast(), self.layout);\n                 }\n             }\n         }\n@@ -1735,12 +1734,7 @@ impl<T: ?Sized> Drop for Weak<T> {\n \n         if inner.weak.fetch_sub(1, Release) == 1 {\n             acquire!(inner.weak);\n-            unsafe {\n-                Global.dealloc(MemoryBlock::new(\n-                    self.ptr.cast(),\n-                    Layout::for_value(self.ptr.as_ref()),\n-                ))\n-            }\n+            unsafe { Global.dealloc(self.ptr.cast(), Layout::for_value(self.ptr.as_ref())) }\n         }\n     }\n }"}, {"sha": "709e8c148d506a9fac7d923d4bf916178313c577", "filename": "src/liballoc/tests/heap.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/03b055b0b4dcf304cd3c5e7a1c6e68fea91584a9/src%2Fliballoc%2Ftests%2Fheap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03b055b0b4dcf304cd3c5e7a1c6e68fea91584a9/src%2Fliballoc%2Ftests%2Fheap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fheap.rs?ref=03b055b0b4dcf304cd3c5e7a1c6e68fea91584a9", "patch": "@@ -1,4 +1,4 @@\n-use std::alloc::{AllocInit, AllocRef, Global, Layout, MemoryBlock, System};\n+use std::alloc::{AllocInit, AllocRef, Global, Layout, System};\n \n /// Issue #45955 and #62251.\n #[test]\n@@ -39,10 +39,7 @@ fn check_overalign_requests<T: AllocRef>(mut allocator: T) {\n \n                 // Clean up\n                 for &ptr in &pointers {\n-                    allocator.dealloc(MemoryBlock::new(\n-                        ptr,\n-                        Layout::from_size_align(size, align).unwrap(),\n-                    ))\n+                    allocator.dealloc(ptr, Layout::from_size_align(size, align).unwrap())\n                 }\n             }\n         }"}, {"sha": "cdb213fe10448f18cb6ebd9295afd78063997c63", "filename": "src/libcore/alloc/mod.rs", "status": "modified", "additions": 104, "deletions": 61, "changes": 165, "blob_url": "https://github.com/rust-lang/rust/blob/03b055b0b4dcf304cd3c5e7a1c6e68fea91584a9/src%2Flibcore%2Falloc%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03b055b0b4dcf304cd3c5e7a1c6e68fea91584a9/src%2Flibcore%2Falloc%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Falloc%2Fmod.rs?ref=03b055b0b4dcf304cd3c5e7a1c6e68fea91584a9", "patch": "@@ -11,7 +11,6 @@ pub use self::global::GlobalAlloc;\n pub use self::layout::{Layout, LayoutErr};\n \n use crate::fmt;\n-use crate::mem;\n use crate::ptr::{self, NonNull};\n \n /// The `AllocErr` error indicates an allocation failure\n@@ -45,25 +44,17 @@ pub enum AllocInit {\n /// Represents a block of allocated memory returned by an allocator.\n #[derive(Debug)]\n #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n-#[must_use = \"`MemoryBlock` should be passed to `AllocRef::dealloc`\"]\n pub struct MemoryBlock {\n     ptr: NonNull<u8>,\n-    layout: Layout,\n+    size: usize,\n }\n \n impl MemoryBlock {\n-    /// Creates a new `MemoryBlock`.\n-    ///\n-    /// # Safety\n-    ///\n-    /// * The block must be allocated with the same alignment as [`layout.align()`], and\n-    /// * The provided [`layout.size()`] must fall in the range `min ..= max`, where:\n-    ///   - `min` is the size requested size when allocating the block, and\n-    ///   - `max` is the size of the memory block.\n+    /// Creates a new `MemoryBlock` from the specified `ptr` and `size`.\n     #[inline]\n     #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n-    pub const unsafe fn new(ptr: NonNull<u8>, layout: Layout) -> Self {\n-        Self { ptr, layout }\n+    pub const fn new(ptr: NonNull<u8>, size: usize) -> Self {\n+        Self { ptr, size }\n     }\n \n     /// Acquires the underlying `NonNull<u8>` pointer.\n@@ -73,25 +64,11 @@ impl MemoryBlock {\n         self.ptr\n     }\n \n-    /// Returns the layout describing the memory block.\n-    #[inline]\n-    #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n-    pub const fn layout(&self) -> Layout {\n-        self.layout\n-    }\n-\n     /// Returns the size of the memory block.\n     #[inline]\n     #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n     pub const fn size(&self) -> usize {\n-        self.layout().size()\n-    }\n-\n-    /// Returns the minimum alignment of the memory block.\n-    #[inline]\n-    #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n-    pub const fn align(&self) -> usize {\n-        self.layout().align()\n+        self.size\n     }\n \n     /// Initialize the memory block like specified by `init`.\n@@ -160,6 +137,39 @@ pub enum ReallocPlacement {\n /// allocator does not support this (like jemalloc) or return a null pointer (such as\n /// `libc::malloc`), this case must be caught.\n ///\n+/// ### Currently allocated memory\n+///\n+/// Some of the methods require that a memory block be *currently allocated* via an allocator. This\n+/// means that:\n+///\n+/// * the starting address for that memory block was previously returned by [`alloc`], [`grow`], or\n+///   [`shrink`], and\n+///\n+/// * the memory block has not been subsequently deallocated, where blocks are either deallocated\n+///   directly by being passed to [`dealloc`] or were changed by being passed to [`grow`] or\n+///   [`shrink`] that returns `Ok`. If `grow` or `shrink` have returned `Err`, the passed pointer\n+///   remains valid.\n+///\n+/// [`alloc`]: AllocRef::alloc\n+/// [`grow`]: AllocRef::grow\n+/// [`shrink`]: AllocRef::shrink\n+/// [`dealloc`]: AllocRef::dealloc\n+///\n+/// ### Memory fitting\n+///\n+/// Some of the methods require that a layout *fit* a memory block. What it means for a layout to\n+/// \"fit\" a memory block means (or equivalently, for a memory block to \"fit\" a layout) is that the\n+/// following conditions must hold:\n+///\n+/// * The block must be allocated with the same alignment as [`layout.align()`], and\n+///\n+/// * The provided [`layout.size()`] must fall in the range `min ..= max`, where:\n+///   - `min` is the size of the layout most recently used to allocate the block, and\n+///   - `max` is the latest actual size returned from [`alloc`], [`grow`], or [`shrink`].\n+///\n+/// [`layout.align()`]: Layout::align\n+/// [`layout.size()`]: Layout::size\n+///\n /// # Safety\n ///\n /// * Memory blocks returned from an allocator must point to valid memory and retain their validity\n@@ -168,6 +178,9 @@ pub enum ReallocPlacement {\n /// * cloning or moving the allocator must not invalidate memory blocks returned from this\n ///   allocator. A cloned allocator must behave like the same allocator.\n ///\n+/// * any pointer to a memory block which is [*currently allocated*] may be passed to any other\n+///   method of the allocator.\n+///\n /// [*currently allocated*]: #currently-allocated-memory\n #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n pub unsafe trait AllocRef {\n@@ -198,25 +211,45 @@ pub unsafe trait AllocRef {\n     /// # Safety\n     ///\n     /// `memory` must be a memory block returned by this allocator.\n-    unsafe fn dealloc(&mut self, memory: MemoryBlock);\n+    unsafe fn dealloc(&mut self, ptr: NonNull<u8>, layout: Layout);\n \n     /// Attempts to extend the memory block.\n     ///\n-    /// The behavior of how the allocator tries to grow the memory is specified by [`placement`].\n-    /// The first `memory.size()` bytes are preserved or copied as appropriate from `ptr`, and the\n-    /// remaining bytes up to the new `memory.size()` are initialized according to [`init`].\n+    /// Returns a new memory block containing a pointer and the actual size of the allocated\n+    /// block. The pointer is suitable for holding data described by a new layout with `layout`\u2019s\n+    /// alignment and a size given by `new_size`. To accomplish this, the allocator may extend the\n+    /// allocation referenced by `ptr` to fit the new layout. If the [`placement`] is\n+    /// [`InPlace`], the returned pointer is guaranteed to be the same as the passed `ptr`.\n+    ///\n+    /// If this returns `Ok`, then ownership of the memory block referenced by `ptr` has been\n+    /// transferred to this allocator. The memory may or may not have been freed, and should be\n+    /// considered unusable (unless of course it was transferred back to the caller again via the\n+    /// return value of this method).\n     ///\n+    /// If this method returns `Err`, then ownership of the memory block has not been transferred to\n+    /// this allocator, and the contents of the memory block are unaltered.\n+    ///\n+    /// The behavior of how the allocator tries to grow the memory is specified by [`placement`].\n+    /// After growing a memory block, the new memory can be separated into three regions:\n+    ///   1. `0..layout.size()`. This region is preserved or copied as appropriate from `ptr`.\n+    ///   2. `layout.size()..allocated_size` where `allocated_size` is the latest returned\n+    ///       size of the allocator. The new content is implementation defined. Allocators may\n+    ///       initialize it according to [`init`] or leave them as is.\n+    ///   3. `allocated_size..returned_size` is initialized according to [`init`].\n+    ///\n+    /// [`InPlace`]: ReallocPlacement::InPlace\n     /// [`placement`]: ReallocPlacement\n     /// [`init`]: AllocInit\n     ///\n     /// # Safety\n     ///\n-    /// * `memory` must be a memory block returned by this allocator.\n+    /// * `ptr` must be [*currently allocated*] via this allocator,\n+    /// * `layout` must [*fit*] the `ptr`. (The `new_size` argument need not fit it.)\n     // We can't require that `new_size` is strictly greater than `memory.size()` because of ZSTs.\n     // An alternative would be\n     // * `new_size must be strictly greater than `memory.size()` or both are zero\n-    /// * `new_size` must be greater than or equal to `memory.size()`\n-    /// * `new_size`, when rounded up to the nearest multiple of `memory.align()`, must not overflow\n+    /// * `new_size` must be greater than or equal to `layout.size()`\n+    /// * `new_size`, when rounded up to the nearest multiple of `layout.align()`, must not overflow\n     ///   (i.e., the rounded value must be less than `usize::MAX`).\n     ///\n     /// [*currently allocated*]: #currently-allocated-memory\n@@ -237,46 +270,59 @@ pub unsafe trait AllocRef {\n     /// [`handle_alloc_error`]: ../../alloc/alloc/fn.handle_alloc_error.html\n     unsafe fn grow(\n         &mut self,\n-        memory: &mut MemoryBlock,\n+        ptr: NonNull<u8>,\n+        layout: Layout,\n         new_size: usize,\n         placement: ReallocPlacement,\n         init: AllocInit,\n-    ) -> Result<(), AllocErr> {\n+    ) -> Result<MemoryBlock, AllocErr> {\n         match placement {\n             ReallocPlacement::InPlace => Err(AllocErr),\n             ReallocPlacement::MayMove => {\n-                let old_size = memory.size();\n+                let old_size = layout.size();\n                 debug_assert!(\n                     new_size >= old_size,\n-                    \"`new_size` must be greater than or equal to `memory.size()`\"\n+                    \"`new_size` must be greater than or equal to `layout.size()`\"\n                 );\n \n                 if new_size == old_size {\n-                    return Ok(());\n+                    return Ok(MemoryBlock::new(ptr, old_size));\n                 }\n \n-                let new_layout = Layout::from_size_align_unchecked(new_size, memory.align());\n+                let new_layout = Layout::from_size_align_unchecked(new_size, layout.align());\n                 let new_memory = self.alloc(new_layout, init)?;\n-                ptr::copy_nonoverlapping(\n-                    memory.ptr().as_ptr(),\n-                    new_memory.ptr().as_ptr(),\n-                    old_size,\n-                );\n-                self.dealloc(mem::replace(memory, new_memory));\n-                Ok(())\n+                ptr::copy_nonoverlapping(ptr.as_ptr(), new_memory.ptr().as_ptr(), old_size);\n+                self.dealloc(ptr, layout);\n+                Ok(new_memory)\n             }\n         }\n     }\n \n     /// Attempts to shrink the memory block.\n     ///\n+    /// Returns a new memory block containing a pointer and the actual size of the allocated\n+    /// block. The pointer is suitable for holding data described by a new layout with `layout`\u2019s\n+    /// alignment and a size given by `new_size`. To accomplish this, the allocator may shrink the\n+    /// allocation referenced by `ptr` to fit the new layout. If the [`placement`] is\n+    /// [`InPlace`], the returned pointer is guaranteed to be the same as the passed `ptr`.\n+    ///\n+    /// If this returns `Ok`, then ownership of the memory block referenced by `ptr` has been\n+    /// transferred to this allocator. The memory may or may not have been freed, and should be\n+    /// considered unusable unless it was transferred back to the caller again via the\n+    /// return value of this method.\n+    ///\n+    /// If this method returns `Err`, then ownership of the memory block has not been transferred to\n+    /// this allocator, and the contents of the memory block are unaltered.\n+    ///\n     /// The behavior of how the allocator tries to shrink the memory is specified by [`placement`].\n     ///\n+    /// [`InPlace`]: ReallocPlacement::InPlace\n     /// [`placement`]: ReallocPlacement\n     ///\n     /// # Safety\n     ///\n-    /// * `memory` must be a memory block returned by this allocator.\n+    /// * `ptr` must be [*currently allocated*] via this allocator,\n+    /// * `layout` must [*fit*] the `ptr`. (The `new_size` argument need not fit it.)\n     // We can't require that `new_size` is strictly smaller than `memory.size()` because of ZSTs.\n     // An alternative would be\n     // * `new_size must be strictly smaller than `memory.size()` or both are zero\n@@ -300,32 +346,29 @@ pub unsafe trait AllocRef {\n     /// [`handle_alloc_error`]: ../../alloc/alloc/fn.handle_alloc_error.html\n     unsafe fn shrink(\n         &mut self,\n-        memory: &mut MemoryBlock,\n+        ptr: NonNull<u8>,\n+        layout: Layout,\n         new_size: usize,\n         placement: ReallocPlacement,\n-    ) -> Result<(), AllocErr> {\n+    ) -> Result<MemoryBlock, AllocErr> {\n         match placement {\n             ReallocPlacement::InPlace => Err(AllocErr),\n             ReallocPlacement::MayMove => {\n-                let old_size = memory.size();\n+                let old_size = layout.size();\n                 debug_assert!(\n                     new_size <= old_size,\n                     \"`new_size` must be smaller than or equal to `layout.size()`\"\n                 );\n \n                 if new_size == old_size {\n-                    return Ok(());\n+                    return Ok(MemoryBlock::new(ptr, old_size));\n                 }\n \n-                let new_layout = Layout::from_size_align_unchecked(new_size, memory.align());\n+                let new_layout = Layout::from_size_align_unchecked(new_size, layout.align());\n                 let new_memory = self.alloc(new_layout, AllocInit::Uninitialized)?;\n-                ptr::copy_nonoverlapping(\n-                    memory.ptr().as_ptr(),\n-                    new_memory.ptr().as_ptr(),\n-                    new_size,\n-                );\n-                self.dealloc(mem::replace(memory, new_memory));\n-                Ok(())\n+                ptr::copy_nonoverlapping(ptr.as_ptr(), new_memory.ptr().as_ptr(), new_size);\n+                self.dealloc(ptr, layout);\n+                Ok(new_memory)\n             }\n         }\n     }"}, {"sha": "7f3a5d2849bd70b253a174c26b68b4a8a9f35f99", "filename": "src/libstd/alloc.rs", "status": "modified", "additions": 29, "deletions": 32, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/03b055b0b4dcf304cd3c5e7a1c6e68fea91584a9/src%2Flibstd%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03b055b0b4dcf304cd3c5e7a1c6e68fea91584a9/src%2Flibstd%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Falloc.rs?ref=03b055b0b4dcf304cd3c5e7a1c6e68fea91584a9", "patch": "@@ -141,99 +141,96 @@ unsafe impl AllocRef for System {\n     #[inline]\n     fn alloc(&mut self, layout: Layout, init: AllocInit) -> Result<MemoryBlock, AllocErr> {\n         unsafe {\n-            if layout.size() == 0 {\n-                Ok(MemoryBlock::new(layout.dangling(), layout))\n+            let size = layout.size();\n+            if size == 0 {\n+                Ok(MemoryBlock::new(layout.dangling(), 0))\n             } else {\n                 let raw_ptr = match init {\n                     AllocInit::Uninitialized => GlobalAlloc::alloc(self, layout),\n                     AllocInit::Zeroed => GlobalAlloc::alloc_zeroed(self, layout),\n                 };\n                 let ptr = NonNull::new(raw_ptr).ok_or(AllocErr)?;\n-                Ok(MemoryBlock::new(ptr, layout))\n+                Ok(MemoryBlock::new(ptr, size))\n             }\n         }\n     }\n \n     #[inline]\n-    unsafe fn dealloc(&mut self, memory: MemoryBlock) {\n-        if memory.size() != 0 {\n-            GlobalAlloc::dealloc(self, memory.ptr().as_ptr(), memory.layout())\n+    unsafe fn dealloc(&mut self, ptr: NonNull<u8>, layout: Layout) {\n+        if layout.size() != 0 {\n+            GlobalAlloc::dealloc(self, ptr.as_ptr(), layout)\n         }\n     }\n \n     #[inline]\n     unsafe fn grow(\n         &mut self,\n-        memory: &mut MemoryBlock,\n+        ptr: NonNull<u8>,\n+        layout: Layout,\n         new_size: usize,\n         placement: ReallocPlacement,\n         init: AllocInit,\n-    ) -> Result<(), AllocErr> {\n-        let old_size = memory.size();\n+    ) -> Result<MemoryBlock, AllocErr> {\n+        let old_size = layout.size();\n         debug_assert!(\n             new_size >= old_size,\n             \"`new_size` must be greater than or equal to `memory.size()`\"\n         );\n \n         if old_size == new_size {\n-            return Ok(());\n+            return Ok(MemoryBlock::new(ptr, old_size));\n         }\n \n-        let new_layout = Layout::from_size_align_unchecked(new_size, memory.align());\n         match placement {\n-            ReallocPlacement::InPlace => return Err(AllocErr),\n-            ReallocPlacement::MayMove if memory.size() == 0 => {\n-                *memory = self.alloc(new_layout, init)?\n+            ReallocPlacement::InPlace => Err(AllocErr),\n+            ReallocPlacement::MayMove if layout.size() == 0 => {\n+                let new_layout = Layout::from_size_align_unchecked(new_size, layout.align());\n+                self.alloc(new_layout, init)\n             }\n             ReallocPlacement::MayMove => {\n                 // `realloc` probably checks for `new_size > old_size` or something similar.\n                 intrinsics::assume(new_size > old_size);\n-                let ptr =\n-                    GlobalAlloc::realloc(self, memory.ptr().as_ptr(), memory.layout(), new_size);\n-                *memory = MemoryBlock::new(NonNull::new(ptr).ok_or(AllocErr)?, new_layout);\n+                let ptr = GlobalAlloc::realloc(self, ptr.as_ptr(), layout, new_size);\n+                let mut memory = MemoryBlock::new(NonNull::new(ptr).ok_or(AllocErr)?, new_size);\n                 memory.init_offset(init, old_size);\n+                Ok(memory)\n             }\n         }\n-        Ok(())\n     }\n \n     #[inline]\n     unsafe fn shrink(\n         &mut self,\n-        memory: &mut MemoryBlock,\n+        ptr: NonNull<u8>,\n+        layout: Layout,\n         new_size: usize,\n         placement: ReallocPlacement,\n-    ) -> Result<(), AllocErr> {\n-        let old_size = memory.size();\n+    ) -> Result<MemoryBlock, AllocErr> {\n+        let old_size = layout.size();\n         debug_assert!(\n             new_size <= old_size,\n             \"`new_size` must be smaller than or equal to `memory.size()`\"\n         );\n \n         if old_size == new_size {\n-            return Ok(());\n+            return Ok(MemoryBlock::new(ptr, old_size));\n         }\n \n-        let new_layout = Layout::from_size_align_unchecked(new_size, memory.align());\n         match placement {\n-            ReallocPlacement::InPlace => return Err(AllocErr),\n+            ReallocPlacement::InPlace => Err(AllocErr),\n             ReallocPlacement::MayMove if new_size == 0 => {\n-                let new_memory = MemoryBlock::new(new_layout.dangling(), new_layout);\n-                let old_memory = mem::replace(memory, new_memory);\n-                self.dealloc(old_memory)\n+                self.dealloc(ptr, layout);\n+                Ok(MemoryBlock::new(layout.dangling(), 0))\n             }\n             ReallocPlacement::MayMove => {\n                 // `realloc` probably checks for `new_size < old_size` or something similar.\n                 intrinsics::assume(new_size < old_size);\n-                let ptr =\n-                    GlobalAlloc::realloc(self, memory.ptr().as_ptr(), memory.layout(), new_size);\n-                *memory = MemoryBlock::new(NonNull::new(ptr).ok_or(AllocErr)?, new_layout);\n+                let ptr = GlobalAlloc::realloc(self, ptr.as_ptr(), layout, new_size);\n+                Ok(MemoryBlock::new(NonNull::new(ptr).ok_or(AllocErr)?, new_size))\n             }\n         }\n-        Ok(())\n     }\n }\n-\n static HOOK: AtomicPtr<()> = AtomicPtr::new(ptr::null_mut());\n \n /// Registers a custom allocation error hook, replacing any that was previously registered."}, {"sha": "8f894c5db5d9f18cb867dd06aee4c9940823fab1", "filename": "src/test/ui/allocator/custom.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/03b055b0b4dcf304cd3c5e7a1c6e68fea91584a9/src%2Ftest%2Fui%2Fallocator%2Fcustom.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03b055b0b4dcf304cd3c5e7a1c6e68fea91584a9/src%2Ftest%2Fui%2Fallocator%2Fcustom.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fallocator%2Fcustom.rs?ref=03b055b0b4dcf304cd3c5e7a1c6e68fea91584a9", "patch": "@@ -40,7 +40,7 @@ fn main() {\n         let memory = Global.alloc(layout.clone(), AllocInit::Uninitialized).unwrap();\n         helper::work_with(&memory.ptr());\n         assert_eq!(HITS.load(Ordering::SeqCst), n + 1);\n-        Global.dealloc(memory);\n+        Global.dealloc(memory.ptr(), layout);\n         assert_eq!(HITS.load(Ordering::SeqCst), n + 2);\n \n         let s = String::with_capacity(10);\n@@ -52,7 +52,7 @@ fn main() {\n         let memory = System.alloc(layout.clone(), AllocInit::Uninitialized).unwrap();\n         assert_eq!(HITS.load(Ordering::SeqCst), n + 4);\n         helper::work_with(&memory.ptr());\n-        System.dealloc(memory);\n+        System.dealloc(memory.ptr(), layout);\n         assert_eq!(HITS.load(Ordering::SeqCst), n + 4);\n     }\n }"}, {"sha": "689804bde86fd5ac32011791456f2974e958666c", "filename": "src/test/ui/allocator/xcrate-use.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/03b055b0b4dcf304cd3c5e7a1c6e68fea91584a9/src%2Ftest%2Fui%2Fallocator%2Fxcrate-use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03b055b0b4dcf304cd3c5e7a1c6e68fea91584a9/src%2Ftest%2Fui%2Fallocator%2Fxcrate-use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fallocator%2Fxcrate-use.rs?ref=03b055b0b4dcf304cd3c5e7a1c6e68fea91584a9", "patch": "@@ -23,13 +23,13 @@ fn main() {\n         let memory = Global.alloc(layout.clone(), AllocInit::Uninitialized).unwrap();\n         helper::work_with(&memory.ptr());\n         assert_eq!(GLOBAL.0.load(Ordering::SeqCst), n + 1);\n-        Global.dealloc(memory);\n+        Global.dealloc(memory.ptr(), layout);\n         assert_eq!(GLOBAL.0.load(Ordering::SeqCst), n + 2);\n \n         let memory = System.alloc(layout.clone(), AllocInit::Uninitialized).unwrap();\n         assert_eq!(GLOBAL.0.load(Ordering::SeqCst), n + 2);\n         helper::work_with(&memory.ptr());\n-        System.dealloc(memory);\n+        System.dealloc(memory.ptr(), layout);\n         assert_eq!(GLOBAL.0.load(Ordering::SeqCst), n + 2);\n     }\n }"}, {"sha": "8c419185f5101ad30a997ff975cfd6ea6d563401", "filename": "src/test/ui/realloc-16687.rs", "status": "modified", "additions": 7, "deletions": 11, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/03b055b0b4dcf304cd3c5e7a1c6e68fea91584a9/src%2Ftest%2Fui%2Frealloc-16687.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03b055b0b4dcf304cd3c5e7a1c6e68fea91584a9/src%2Ftest%2Fui%2Frealloc-16687.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frealloc-16687.rs?ref=03b055b0b4dcf304cd3c5e7a1c6e68fea91584a9", "patch": "@@ -6,9 +6,7 @@\n \n #![feature(allocator_api)]\n \n-use std::alloc::{\n-    handle_alloc_error, AllocInit, AllocRef, Global, Layout, MemoryBlock, ReallocPlacement,\n-};\n+use std::alloc::{handle_alloc_error, AllocInit, AllocRef, Global, Layout, ReallocPlacement};\n use std::ptr::{self, NonNull};\n \n fn main() {\n@@ -59,29 +57,27 @@ unsafe fn test_triangle() -> bool {\n             println!(\"deallocate({:?}, {:?}\", ptr, layout);\n         }\n \n-        Global.dealloc(MemoryBlock::new(NonNull::new_unchecked(ptr), layout));\n+        Global.dealloc(NonNull::new_unchecked(ptr), layout);\n     }\n \n     unsafe fn reallocate(ptr: *mut u8, old: Layout, new: Layout) -> *mut u8 {\n         if PRINT {\n             println!(\"reallocate({:?}, old={:?}, new={:?})\", ptr, old, new);\n         }\n \n-        let mut memory = MemoryBlock::new(NonNull::new_unchecked(ptr), old);\n-        let result = if new.size() > old.size() {\n+        let memory = if new.size() > old.size() {\n             Global.grow(\n-                &mut memory,\n+                NonNull::new_unchecked(ptr),\n+                old,\n                 new.size(),\n                 ReallocPlacement::MayMove,\n                 AllocInit::Uninitialized,\n             )\n-        } else if new.size() < old.size() {\n-            Global.shrink(&mut memory, new.size(), ReallocPlacement::MayMove)\n         } else {\n-            return ptr;\n+            Global.shrink(NonNull::new_unchecked(ptr), old, new.size(), ReallocPlacement::MayMove)\n         };\n \n-        result.unwrap_or_else(|_| {\n+        let memory = memory.unwrap_or_else(|_| {\n             handle_alloc_error(Layout::from_size_align_unchecked(new.size(), old.align()))\n         });\n "}, {"sha": "148b0a86a05890e16f8940c764a3ac7576375d49", "filename": "src/test/ui/regions/regions-mock-codegen.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/03b055b0b4dcf304cd3c5e7a1c6e68fea91584a9/src%2Ftest%2Fui%2Fregions%2Fregions-mock-codegen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03b055b0b4dcf304cd3c5e7a1c6e68fea91584a9/src%2Ftest%2Fui%2Fregions%2Fregions-mock-codegen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-mock-codegen.rs?ref=03b055b0b4dcf304cd3c5e7a1c6e68fea91584a9", "patch": "@@ -4,7 +4,7 @@\n // pretty-expanded FIXME #23616\n #![feature(allocator_api)]\n \n-use std::alloc::{handle_alloc_error, AllocInit, AllocRef, Global, Layout, MemoryBlock};\n+use std::alloc::{handle_alloc_error, AllocInit, AllocRef, Global, Layout};\n use std::ptr::NonNull;\n \n struct arena(());\n@@ -40,10 +40,7 @@ fn g(fcx: &Fcx) {\n     let bcx = Bcx { fcx };\n     let bcx2 = h(&bcx);\n     unsafe {\n-        Global.dealloc(MemoryBlock::new(\n-            NonNull::new_unchecked(bcx2 as *const _ as *mut _),\n-            Layout::new::<Bcx>(),\n-        ));\n+        Global.dealloc(NonNull::new_unchecked(bcx2 as *const _ as *mut _), Layout::new::<Bcx>());\n     }\n }\n "}]}