{"sha": "492b3deba7527ca4e0b5fbed2551891b905507b8", "node_id": "C_kwDOAAsO6NoAKDQ5MmIzZGViYTc1MjdjYTRlMGI1ZmJlZDI1NTE4OTFiOTA1NTA3Yjg", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-01-17T12:39:53Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-01-17T12:39:53Z"}, "message": "Auto merge of #13971 - lowr:fix/more-precise-builtin-binop-types, r=Veykril\n\nfix: more precise binop inference\n\nWhile inferring binary operator expressions, Rust puts some extra constraints on the types of the operands for better inference. Relevant part in rustc is [this](https://github.com/rust-lang/rust/blob/159ba8a92c9e2fa4121f106176309521f4af87e9/compiler/rustc_hir_typeck/src/op.rs#L128-L152).\n\nThere are two things we currently fail to consider:\n- we should enforce them only when both lhs and rhs type are builtin types that are applicable to the binop\n- lhs and rhs types may be single reference to applicable builtin types\n\nThis PR basically ports [`enforce_builtin_binop_types()`](https://github.com/rust-lang/rust/blob/159ba8a92c9e2fa4121f106176309521f4af87e9/compiler/rustc_hir_typeck/src/op.rs#L159) and [`is_builtin_binop()`](https://github.com/rust-lang/rust/blob/159ba8a92c9e2fa4121f106176309521f4af87e9/compiler/rustc_hir_typeck/src/op.rs#LL927) to our inference context.", "tree": {"sha": "244719c55d4d4cdbe11941264632b836d45cd021", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/244719c55d4d4cdbe11941264632b836d45cd021"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/492b3deba7527ca4e0b5fbed2551891b905507b8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/492b3deba7527ca4e0b5fbed2551891b905507b8", "html_url": "https://github.com/rust-lang/rust/commit/492b3deba7527ca4e0b5fbed2551891b905507b8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/492b3deba7527ca4e0b5fbed2551891b905507b8/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fa874627f0adcd5a834b116c7a475b56611317c6", "url": "https://api.github.com/repos/rust-lang/rust/commits/fa874627f0adcd5a834b116c7a475b56611317c6", "html_url": "https://github.com/rust-lang/rust/commit/fa874627f0adcd5a834b116c7a475b56611317c6"}, {"sha": "c53064fb58ac170dbd93b9529d78fc324c1dae9f", "url": "https://api.github.com/repos/rust-lang/rust/commits/c53064fb58ac170dbd93b9529d78fc324c1dae9f", "html_url": "https://github.com/rust-lang/rust/commit/c53064fb58ac170dbd93b9529d78fc324c1dae9f"}], "stats": {"total": 370, "additions": 247, "deletions": 123}, "files": [{"sha": "0244b6c653e2dbaa88c7fc718d3d78f6e6dd6c99", "filename": "crates/hir-ty/src/chalk_ext.rs", "status": "modified", "additions": 18, "deletions": 1, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/492b3deba7527ca4e0b5fbed2551891b905507b8/crates%2Fhir-ty%2Fsrc%2Fchalk_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/492b3deba7527ca4e0b5fbed2551891b905507b8/crates%2Fhir-ty%2Fsrc%2Fchalk_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fchalk_ext.rs?ref=492b3deba7527ca4e0b5fbed2551891b905507b8", "patch": "@@ -1,6 +1,6 @@\n //! Various extensions traits for Chalk types.\n \n-use chalk_ir::{FloatTy, IntTy, Mutability, Scalar, UintTy};\n+use chalk_ir::{FloatTy, IntTy, Mutability, Scalar, TyVariableKind, UintTy};\n use hir_def::{\n     builtin_type::{BuiltinFloat, BuiltinInt, BuiltinType, BuiltinUint},\n     generics::TypeOrConstParamData,\n@@ -18,6 +18,8 @@ use crate::{\n \n pub trait TyExt {\n     fn is_unit(&self) -> bool;\n+    fn is_integral(&self) -> bool;\n+    fn is_floating_point(&self) -> bool;\n     fn is_never(&self) -> bool;\n     fn is_unknown(&self) -> bool;\n     fn is_ty_var(&self) -> bool;\n@@ -51,6 +53,21 @@ impl TyExt for Ty {\n         matches!(self.kind(Interner), TyKind::Tuple(0, _))\n     }\n \n+    fn is_integral(&self) -> bool {\n+        matches!(\n+            self.kind(Interner),\n+            TyKind::Scalar(Scalar::Int(_) | Scalar::Uint(_))\n+                | TyKind::InferenceVar(_, TyVariableKind::Integer)\n+        )\n+    }\n+\n+    fn is_floating_point(&self) -> bool {\n+        matches!(\n+            self.kind(Interner),\n+            TyKind::Scalar(Scalar::Float(_)) | TyKind::InferenceVar(_, TyVariableKind::Float)\n+        )\n+    }\n+\n     fn is_never(&self) -> bool {\n         matches!(self.kind(Interner), TyKind::Never)\n     }"}, {"sha": "0e177db7726a47b4242aa2681e3ae4030e644d16", "filename": "crates/hir-ty/src/infer.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/492b3deba7527ca4e0b5fbed2551891b905507b8/crates%2Fhir-ty%2Fsrc%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/492b3deba7527ca4e0b5fbed2551891b905507b8/crates%2Fhir-ty%2Fsrc%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer.rs?ref=492b3deba7527ca4e0b5fbed2551891b905507b8", "patch": "@@ -1041,10 +1041,6 @@ impl Expectation {\n         }\n     }\n \n-    fn from_option(ty: Option<Ty>) -> Self {\n-        ty.map_or(Expectation::None, Expectation::HasType)\n-    }\n-\n     /// The following explanation is copied straight from rustc:\n     /// Provides an expectation for an rvalue expression given an *optional*\n     /// hint, which is not required for type safety (the resulting type might"}, {"sha": "6f347f6757b001e39a77dbe6e9ee687b4099f88e", "filename": "crates/hir-ty/src/infer/expr.rs", "status": "modified", "additions": 131, "deletions": 92, "changes": 223, "blob_url": "https://github.com/rust-lang/rust/blob/492b3deba7527ca4e0b5fbed2551891b905507b8/crates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/492b3deba7527ca4e0b5fbed2551891b905507b8/crates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs?ref=492b3deba7527ca4e0b5fbed2551891b905507b8", "patch": "@@ -10,8 +10,7 @@ use chalk_ir::{\n };\n use hir_def::{\n     expr::{\n-        ArithOp, Array, BinaryOp, ClosureKind, CmpOp, Expr, ExprId, LabelId, Literal, Statement,\n-        UnaryOp,\n+        ArithOp, Array, BinaryOp, ClosureKind, Expr, ExprId, LabelId, Literal, Statement, UnaryOp,\n     },\n     generics::TypeOrConstParamData,\n     path::{GenericArg, GenericArgs},\n@@ -1017,11 +1016,21 @@ impl<'a> InferenceContext<'a> {\n         let (trait_, func) = match trait_func {\n             Some(it) => it,\n             None => {\n-                let rhs_ty = self.builtin_binary_op_rhs_expectation(op, lhs_ty.clone());\n-                let rhs_ty = self.infer_expr_coerce(rhs, &Expectation::from_option(rhs_ty));\n-                return self\n-                    .builtin_binary_op_return_ty(op, lhs_ty, rhs_ty)\n-                    .unwrap_or_else(|| self.err_ty());\n+                // HACK: `rhs_ty` is a general inference variable with no clue at all at this\n+                // point. Passing `lhs_ty` as both operands just to check if `lhs_ty` is a builtin\n+                // type applicable to `op`.\n+                let ret_ty = if self.is_builtin_binop(&lhs_ty, &lhs_ty, op) {\n+                    // Assume both operands are builtin so we can continue inference. No guarantee\n+                    // on the correctness, rustc would complain as necessary lang items don't seem\n+                    // to exist anyway.\n+                    self.enforce_builtin_binop_types(&lhs_ty, &rhs_ty, op)\n+                } else {\n+                    self.err_ty()\n+                };\n+\n+                self.infer_expr_coerce(rhs, &Expectation::has_type(rhs_ty));\n+\n+                return ret_ty;\n             }\n         };\n \n@@ -1071,11 +1080,9 @@ impl<'a> InferenceContext<'a> {\n \n         let ret_ty = self.normalize_associated_types_in(ret_ty);\n \n-        // use knowledge of built-in binary ops, which can sometimes help inference\n-        if let Some(builtin_rhs) = self.builtin_binary_op_rhs_expectation(op, lhs_ty.clone()) {\n-            self.unify(&builtin_rhs, &rhs_ty);\n-        }\n-        if let Some(builtin_ret) = self.builtin_binary_op_return_ty(op, lhs_ty, rhs_ty) {\n+        if self.is_builtin_binop(&lhs_ty, &rhs_ty, op) {\n+            // use knowledge of built-in binary ops, which can sometimes help inference\n+            let builtin_ret = self.enforce_builtin_binop_types(&lhs_ty, &rhs_ty, op);\n             self.unify(&builtin_ret, &ret_ty);\n         }\n \n@@ -1477,92 +1484,124 @@ impl<'a> InferenceContext<'a> {\n         indices\n     }\n \n-    fn builtin_binary_op_return_ty(&mut self, op: BinaryOp, lhs_ty: Ty, rhs_ty: Ty) -> Option<Ty> {\n-        let lhs_ty = self.resolve_ty_shallow(&lhs_ty);\n-        let rhs_ty = self.resolve_ty_shallow(&rhs_ty);\n-        match op {\n-            BinaryOp::LogicOp(_) | BinaryOp::CmpOp(_) => {\n-                Some(TyKind::Scalar(Scalar::Bool).intern(Interner))\n+    /// Dereferences a single level of immutable referencing.\n+    fn deref_ty_if_possible(&mut self, ty: &Ty) -> Ty {\n+        let ty = self.resolve_ty_shallow(ty);\n+        match ty.kind(Interner) {\n+            TyKind::Ref(Mutability::Not, _, inner) => self.resolve_ty_shallow(inner),\n+            _ => ty,\n+        }\n+    }\n+\n+    /// Enforces expectations on lhs type and rhs type depending on the operator and returns the\n+    /// output type of the binary op.\n+    fn enforce_builtin_binop_types(&mut self, lhs: &Ty, rhs: &Ty, op: BinaryOp) -> Ty {\n+        // Special-case a single layer of referencing, so that things like `5.0 + &6.0f32` work (See rust-lang/rust#57447).\n+        let lhs = self.deref_ty_if_possible(lhs);\n+        let rhs = self.deref_ty_if_possible(rhs);\n+\n+        let (op, is_assign) = match op {\n+            BinaryOp::Assignment { op: Some(inner) } => (BinaryOp::ArithOp(inner), true),\n+            _ => (op, false),\n+        };\n+\n+        let output_ty = match op {\n+            BinaryOp::LogicOp(_) => {\n+                let bool_ = self.result.standard_types.bool_.clone();\n+                self.unify(&lhs, &bool_);\n+                self.unify(&rhs, &bool_);\n+                bool_\n             }\n-            BinaryOp::Assignment { .. } => Some(TyBuilder::unit()),\n+\n             BinaryOp::ArithOp(ArithOp::Shl | ArithOp::Shr) => {\n-                // all integer combinations are valid here\n-                if matches!(\n-                    lhs_ty.kind(Interner),\n-                    TyKind::Scalar(Scalar::Int(_) | Scalar::Uint(_))\n-                        | TyKind::InferenceVar(_, TyVariableKind::Integer)\n-                ) && matches!(\n-                    rhs_ty.kind(Interner),\n-                    TyKind::Scalar(Scalar::Int(_) | Scalar::Uint(_))\n-                        | TyKind::InferenceVar(_, TyVariableKind::Integer)\n-                ) {\n-                    Some(lhs_ty)\n-                } else {\n-                    None\n-                }\n+                // result type is same as LHS always\n+                lhs\n             }\n-            BinaryOp::ArithOp(_) => match (lhs_ty.kind(Interner), rhs_ty.kind(Interner)) {\n-                // (int, int) | (uint, uint) | (float, float)\n-                (TyKind::Scalar(Scalar::Int(_)), TyKind::Scalar(Scalar::Int(_)))\n-                | (TyKind::Scalar(Scalar::Uint(_)), TyKind::Scalar(Scalar::Uint(_)))\n-                | (TyKind::Scalar(Scalar::Float(_)), TyKind::Scalar(Scalar::Float(_))) => {\n-                    Some(rhs_ty)\n-                }\n-                // ({int}, int) | ({int}, uint)\n-                (\n-                    TyKind::InferenceVar(_, TyVariableKind::Integer),\n-                    TyKind::Scalar(Scalar::Int(_) | Scalar::Uint(_)),\n-                ) => Some(rhs_ty),\n-                // (int, {int}) | (uint, {int})\n-                (\n-                    TyKind::Scalar(Scalar::Int(_) | Scalar::Uint(_)),\n-                    TyKind::InferenceVar(_, TyVariableKind::Integer),\n-                ) => Some(lhs_ty),\n-                // ({float} | float)\n-                (\n-                    TyKind::InferenceVar(_, TyVariableKind::Float),\n-                    TyKind::Scalar(Scalar::Float(_)),\n-                ) => Some(rhs_ty),\n-                // (float, {float})\n-                (\n-                    TyKind::Scalar(Scalar::Float(_)),\n-                    TyKind::InferenceVar(_, TyVariableKind::Float),\n-                ) => Some(lhs_ty),\n-                // ({int}, {int}) | ({float}, {float})\n-                (\n-                    TyKind::InferenceVar(_, TyVariableKind::Integer),\n-                    TyKind::InferenceVar(_, TyVariableKind::Integer),\n-                )\n-                | (\n-                    TyKind::InferenceVar(_, TyVariableKind::Float),\n-                    TyKind::InferenceVar(_, TyVariableKind::Float),\n-                ) => Some(rhs_ty),\n-                _ => None,\n-            },\n+\n+            BinaryOp::ArithOp(_) => {\n+                // LHS, RHS, and result will have the same type\n+                self.unify(&lhs, &rhs);\n+                lhs\n+            }\n+\n+            BinaryOp::CmpOp(_) => {\n+                // LHS and RHS will have the same type\n+                self.unify(&lhs, &rhs);\n+                self.result.standard_types.bool_.clone()\n+            }\n+\n+            BinaryOp::Assignment { op: None } => {\n+                stdx::never!(\"Simple assignment operator is not binary op.\");\n+                lhs\n+            }\n+\n+            BinaryOp::Assignment { .. } => unreachable!(\"handled above\"),\n+        };\n+\n+        if is_assign {\n+            self.result.standard_types.unit.clone()\n+        } else {\n+            output_ty\n         }\n     }\n \n-    fn builtin_binary_op_rhs_expectation(&mut self, op: BinaryOp, lhs_ty: Ty) -> Option<Ty> {\n-        Some(match op {\n-            BinaryOp::LogicOp(..) => TyKind::Scalar(Scalar::Bool).intern(Interner),\n-            BinaryOp::Assignment { op: None } => lhs_ty,\n-            BinaryOp::CmpOp(CmpOp::Eq { .. }) => match self\n-                .resolve_ty_shallow(&lhs_ty)\n-                .kind(Interner)\n-            {\n-                TyKind::Scalar(_) | TyKind::Str => lhs_ty,\n-                TyKind::InferenceVar(_, TyVariableKind::Integer | TyVariableKind::Float) => lhs_ty,\n-                _ => return None,\n-            },\n-            BinaryOp::ArithOp(ArithOp::Shl | ArithOp::Shr) => return None,\n-            BinaryOp::CmpOp(CmpOp::Ord { .. })\n-            | BinaryOp::Assignment { op: Some(_) }\n-            | BinaryOp::ArithOp(_) => match self.resolve_ty_shallow(&lhs_ty).kind(Interner) {\n-                TyKind::Scalar(Scalar::Int(_) | Scalar::Uint(_) | Scalar::Float(_)) => lhs_ty,\n-                TyKind::InferenceVar(_, TyVariableKind::Integer | TyVariableKind::Float) => lhs_ty,\n-                _ => return None,\n-            },\n-        })\n+    fn is_builtin_binop(&mut self, lhs: &Ty, rhs: &Ty, op: BinaryOp) -> bool {\n+        // Special-case a single layer of referencing, so that things like `5.0 + &6.0f32` work (See rust-lang/rust#57447).\n+        let lhs = self.deref_ty_if_possible(lhs);\n+        let rhs = self.deref_ty_if_possible(rhs);\n+\n+        let op = match op {\n+            BinaryOp::Assignment { op: Some(inner) } => BinaryOp::ArithOp(inner),\n+            _ => op,\n+        };\n+\n+        match op {\n+            BinaryOp::LogicOp(_) => true,\n+\n+            BinaryOp::ArithOp(ArithOp::Shl | ArithOp::Shr) => {\n+                lhs.is_integral() && rhs.is_integral()\n+            }\n+\n+            BinaryOp::ArithOp(\n+                ArithOp::Add | ArithOp::Sub | ArithOp::Mul | ArithOp::Div | ArithOp::Rem,\n+            ) => {\n+                lhs.is_integral() && rhs.is_integral()\n+                    || lhs.is_floating_point() && rhs.is_floating_point()\n+            }\n+\n+            BinaryOp::ArithOp(ArithOp::BitAnd | ArithOp::BitOr | ArithOp::BitXor) => {\n+                lhs.is_integral() && rhs.is_integral()\n+                    || lhs.is_floating_point() && rhs.is_floating_point()\n+                    || matches!(\n+                        (lhs.kind(Interner), rhs.kind(Interner)),\n+                        (TyKind::Scalar(Scalar::Bool), TyKind::Scalar(Scalar::Bool))\n+                    )\n+            }\n+\n+            BinaryOp::CmpOp(_) => {\n+                let is_scalar = |kind| {\n+                    matches!(\n+                        kind,\n+                        &TyKind::Scalar(_)\n+                            | TyKind::FnDef(..)\n+                            | TyKind::Function(_)\n+                            | TyKind::Raw(..)\n+                            | TyKind::InferenceVar(\n+                                _,\n+                                TyVariableKind::Integer | TyVariableKind::Float\n+                            )\n+                    )\n+                };\n+                is_scalar(lhs.kind(Interner)) && is_scalar(rhs.kind(Interner))\n+            }\n+\n+            BinaryOp::Assignment { op: None } => {\n+                stdx::never!(\"Simple assignment operator is not binary op.\");\n+                false\n+            }\n+\n+            BinaryOp::Assignment { .. } => unreachable!(\"handled above\"),\n+        }\n     }\n \n     fn with_breakable_ctx<T>("}, {"sha": "4c560702a1b4568301d229e7e7d05a6d5fe16281", "filename": "crates/hir-ty/src/tests/traits.rs", "status": "modified", "additions": 98, "deletions": 26, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/492b3deba7527ca4e0b5fbed2551891b905507b8/crates%2Fhir-ty%2Fsrc%2Ftests%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/492b3deba7527ca4e0b5fbed2551891b905507b8/crates%2Fhir-ty%2Fsrc%2Ftests%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Ftests%2Ftraits.rs?ref=492b3deba7527ca4e0b5fbed2551891b905507b8", "patch": "@@ -3507,14 +3507,9 @@ trait Request {\n fn bin_op_adt_with_rhs_primitive() {\n     check_infer_with_mismatches(\n         r#\"\n-#[lang = \"add\"]\n-pub trait Add<Rhs = Self> {\n-    type Output;\n-    fn add(self, rhs: Rhs) -> Self::Output;\n-}\n-\n+//- minicore: add\n struct Wrapper(u32);\n-impl Add<u32> for Wrapper {\n+impl core::ops::Add<u32> for Wrapper {\n     type Output = Self;\n     fn add(self, rhs: u32) -> Wrapper {\n         Wrapper(rhs)\n@@ -3527,29 +3522,106 @@ fn main(){\n \n }\"#,\n         expect![[r#\"\n-            72..76 'self': Self\n-            78..81 'rhs': Rhs\n-            192..196 'self': Wrapper\n-            198..201 'rhs': u32\n-            219..247 '{     ...     }': Wrapper\n-            229..236 'Wrapper': Wrapper(u32) -> Wrapper\n-            229..241 'Wrapper(rhs)': Wrapper\n-            237..240 'rhs': u32\n-            259..345 '{     ...um;  }': ()\n-            269..276 'wrapped': Wrapper\n-            279..286 'Wrapper': Wrapper(u32) -> Wrapper\n-            279..290 'Wrapper(10)': Wrapper\n-            287..289 '10': u32\n-            300..303 'num': u32\n-            311..312 '2': u32\n-            322..325 'res': Wrapper\n-            328..335 'wrapped': Wrapper\n-            328..341 'wrapped + num': Wrapper\n-            338..341 'num': u32\n+            95..99 'self': Wrapper\n+            101..104 'rhs': u32\n+            122..150 '{     ...     }': Wrapper\n+            132..139 'Wrapper': Wrapper(u32) -> Wrapper\n+            132..144 'Wrapper(rhs)': Wrapper\n+            140..143 'rhs': u32\n+            162..248 '{     ...um;  }': ()\n+            172..179 'wrapped': Wrapper\n+            182..189 'Wrapper': Wrapper(u32) -> Wrapper\n+            182..193 'Wrapper(10)': Wrapper\n+            190..192 '10': u32\n+            203..206 'num': u32\n+            214..215 '2': u32\n+            225..228 'res': Wrapper\n+            231..238 'wrapped': Wrapper\n+            231..244 'wrapped + num': Wrapper\n+            241..244 'num': u32\n         \"#]],\n     )\n }\n \n+#[test]\n+fn builtin_binop_expectation_works_on_single_reference() {\n+    check_types(\n+        r#\"\n+//- minicore: add\n+use core::ops::Add;\n+impl Add<i32> for i32 { type Output = i32 }\n+impl Add<&i32> for i32 { type Output = i32 }\n+impl Add<u32> for u32 { type Output = u32 }\n+impl Add<&u32> for u32 { type Output = u32 }\n+\n+struct V<T>;\n+impl<T> V<T> {\n+    fn default() -> Self { loop {} }\n+    fn get(&self, _: &T) -> &T { loop {} }\n+}\n+\n+fn take_u32(_: u32) {}\n+fn minimized() {\n+    let v = V::default();\n+    let p = v.get(&0);\n+      //^ &u32\n+    take_u32(42 + p);\n+}\n+\"#,\n+    );\n+}\n+\n+#[test]\n+fn no_builtin_binop_expectation_for_general_ty_var() {\n+    // FIXME: Ideally type mismatch should be reported on `take_u32(42 - p)`.\n+    check_types(\n+        r#\"\n+//- minicore: add\n+use core::ops::Add;\n+impl Add<i32> for i32 { type Output = i32; }\n+impl Add<&i32> for i32 { type Output = i32; }\n+// This is needed to prevent chalk from giving unique solution to `i32: Add<&?0>` after applying\n+// fallback to integer type variable for `42`.\n+impl Add<&()> for i32 { type Output = (); }\n+\n+struct V<T>;\n+impl<T> V<T> {\n+    fn default() -> Self { loop {} }\n+    fn get(&self) -> &T { loop {} }\n+}\n+\n+fn take_u32(_: u32) {}\n+fn minimized() {\n+    let v = V::default();\n+    let p = v.get();\n+      //^ &{unknown}\n+    take_u32(42 + p);\n+}\n+\"#,\n+    );\n+}\n+\n+#[test]\n+fn no_builtin_binop_expectation_for_non_builtin_types() {\n+    check_no_mismatches(\n+        r#\"\n+//- minicore: default, eq\n+struct S;\n+impl Default for S { fn default() -> Self { S } }\n+impl Default for i32 { fn default() -> Self { 0 } }\n+impl PartialEq<S> for i32 { fn eq(&self, _: &S) -> bool { true } }\n+impl PartialEq<i32> for i32 { fn eq(&self, _: &S) -> bool { true } }\n+\n+fn take_s(_: S) {}\n+fn test() {\n+    let s = Default::default();\n+    let _eq = 0 == s;\n+    take_s(s);\n+}\n+\"#,\n+    )\n+}\n+\n #[test]\n fn array_length() {\n     check_infer("}]}