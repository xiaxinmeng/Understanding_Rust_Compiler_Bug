{"sha": "24ebae870e11ed60a83ca0acccc202387f95f25f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI0ZWJhZTg3MGUxMWVkNjBhODNjYTBhY2NjYzIwMjM4N2Y5NWYyNWY=", "commit": {"author": {"name": "Jubilee", "email": "46493976+workingjubilee@users.noreply.github.com", "date": "2021-04-22T23:44:41Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-04-22T23:44:41Z"}, "message": "Merge pull request #83 from rust-lang/feature/reductions\n\nAdd reductions", "tree": {"sha": "20c0067e7ed6ff8f8f8134e23c80c563eed870c6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/20c0067e7ed6ff8f8f8134e23c80c563eed870c6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/24ebae870e11ed60a83ca0acccc202387f95f25f", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgggppCRBK7hj4Ov3rIwAAL+MIAJjXpyM2rLk+SRNHZXYmVtOS\nM991cb6F0vGltmw6IJVc3YXTzgsISX1hhxFOwS5R7bV8gPLKkCuk991j8/+PtBJi\nAavSL/GJF3QlMQ+cAx8cTMGRgmZAiG7uWMdvQw48YS0a6eCg2f97IrMgFZXvdsWX\nhusGoYVaCUx7nJ93eh38gszqdQx6kfalKEWQERo7OHILj6wNacjhOyekR+6pxomN\nAXJ4c88uQ8xpG0RsIupdtS8Gk+5IoowC3UGLeWMP2LtyYwOkysi2X4YQOQ43ExIR\nCh5djALip1DrO4tSpfwPG7KqTbI3lQk+P7PfDD9u8EoAoWGHYy0Fp+9JbQNXDjk=\n=xTkK\n-----END PGP SIGNATURE-----\n", "payload": "tree 20c0067e7ed6ff8f8f8134e23c80c563eed870c6\nparent 2fa62b91c81b10064bb298befa1f539d1ea28a08\nparent 04ee1073237dc77b3742e7a1c0d3740c1df499c4\nauthor Jubilee <46493976+workingjubilee@users.noreply.github.com> 1619135081 -0700\ncommitter GitHub <noreply@github.com> 1619135081 -0700\n\nMerge pull request #83 from rust-lang/feature/reductions\n\nAdd reductions"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/24ebae870e11ed60a83ca0acccc202387f95f25f", "html_url": "https://github.com/rust-lang/rust/commit/24ebae870e11ed60a83ca0acccc202387f95f25f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/24ebae870e11ed60a83ca0acccc202387f95f25f/comments", "author": {"login": "workingjubilee", "id": 46493976, "node_id": "MDQ6VXNlcjQ2NDkzOTc2", "avatar_url": "https://avatars.githubusercontent.com/u/46493976?v=4", "gravatar_id": "", "url": "https://api.github.com/users/workingjubilee", "html_url": "https://github.com/workingjubilee", "followers_url": "https://api.github.com/users/workingjubilee/followers", "following_url": "https://api.github.com/users/workingjubilee/following{/other_user}", "gists_url": "https://api.github.com/users/workingjubilee/gists{/gist_id}", "starred_url": "https://api.github.com/users/workingjubilee/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/workingjubilee/subscriptions", "organizations_url": "https://api.github.com/users/workingjubilee/orgs", "repos_url": "https://api.github.com/users/workingjubilee/repos", "events_url": "https://api.github.com/users/workingjubilee/events{/privacy}", "received_events_url": "https://api.github.com/users/workingjubilee/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2fa62b91c81b10064bb298befa1f539d1ea28a08", "url": "https://api.github.com/repos/rust-lang/rust/commits/2fa62b91c81b10064bb298befa1f539d1ea28a08", "html_url": "https://github.com/rust-lang/rust/commit/2fa62b91c81b10064bb298befa1f539d1ea28a08"}, {"sha": "04ee1073237dc77b3742e7a1c0d3740c1df499c4", "url": "https://api.github.com/repos/rust-lang/rust/commits/04ee1073237dc77b3742e7a1c0d3740c1df499c4", "html_url": "https://github.com/rust-lang/rust/commit/04ee1073237dc77b3742e7a1c0d3740c1df499c4"}], "stats": {"total": 583, "additions": 464, "deletions": 119}, "files": [{"sha": "57e666873c1bb55998262e4d9d128dcab245df12", "filename": "crates/core_simd/src/intrinsics.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/24ebae870e11ed60a83ca0acccc202387f95f25f/crates%2Fcore_simd%2Fsrc%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ebae870e11ed60a83ca0acccc202387f95f25f/crates%2Fcore_simd%2Fsrc%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fintrinsics.rs?ref=24ebae870e11ed60a83ca0acccc202387f95f25f", "patch": "@@ -73,4 +73,15 @@ extern \"platform-intrinsic\" {\n \n     // {s,u}sub.sat\n     pub(crate) fn simd_saturating_sub<T>(x: T, y: T) -> T;\n+\n+    // reductions\n+    pub(crate) fn simd_reduce_add_ordered<T, U>(x: T, y: U) -> U;\n+    pub(crate) fn simd_reduce_mul_ordered<T, U>(x: T, y: U) -> U;\n+    pub(crate) fn simd_reduce_all<T>(x: T) -> bool;\n+    pub(crate) fn simd_reduce_any<T>(x: T) -> bool;\n+    pub(crate) fn simd_reduce_max<T, U>(x: T) -> U;\n+    pub(crate) fn simd_reduce_min<T, U>(x: T) -> U;\n+    pub(crate) fn simd_reduce_and<T, U>(x: T) -> U;\n+    pub(crate) fn simd_reduce_or<T, U>(x: T) -> U;\n+    pub(crate) fn simd_reduce_xor<T, U>(x: T) -> U;\n }"}, {"sha": "0fc2641516dd66dacf0e69b2dc113d3b77ace7d4", "filename": "crates/core_simd/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24ebae870e11ed60a83ca0acccc202387f95f25f/crates%2Fcore_simd%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ebae870e11ed60a83ca0acccc202387f95f25f/crates%2Fcore_simd%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Flib.rs?ref=24ebae870e11ed60a83ca0acccc202387f95f25f", "patch": "@@ -11,6 +11,8 @@ mod first;\n mod permute;\n #[macro_use]\n mod transmute;\n+#[macro_use]\n+mod reduction;\n \n mod comparisons;\n mod fmt;"}, {"sha": "b4d1b6d9557d302c51d166aacdddc8100a022c3b", "filename": "crates/core_simd/src/masks/bitmask.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/24ebae870e11ed60a83ca0acccc202387f95f25f/crates%2Fcore_simd%2Fsrc%2Fmasks%2Fbitmask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ebae870e11ed60a83ca0acccc202387f95f25f/crates%2Fcore_simd%2Fsrc%2Fmasks%2Fbitmask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fmasks%2Fbitmask.rs?ref=24ebae870e11ed60a83ca0acccc202387f95f25f", "patch": "@@ -1,7 +1,7 @@\n use crate::LanesAtMost32;\n \n /// A mask where each lane is represented by a single bit.\n-#[derive(Copy, Clone, Debug)]\n+#[derive(Copy, Clone, Debug, PartialOrd, PartialEq, Ord, Eq, Hash)]\n #[repr(transparent)]\n pub struct BitMask<const LANES: usize>(u64)\n where\n@@ -14,7 +14,7 @@ where\n     /// Construct a mask by setting all lanes to the given value.\n     pub fn splat(value: bool) -> Self {\n         if value {\n-            Self(u64::MAX)\n+            Self(u64::MAX >> (64 - LANES))\n         } else {\n             Self(u64::MIN)\n         }"}, {"sha": "a6689ce48c665668375ce74ffb44aa2c52ba9f66", "filename": "crates/core_simd/src/masks/full_masks.rs", "status": "modified", "additions": 72, "deletions": 56, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/24ebae870e11ed60a83ca0acccc202387f95f25f/crates%2Fcore_simd%2Fsrc%2Fmasks%2Ffull_masks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ebae870e11ed60a83ca0acccc202387f95f25f/crates%2Fcore_simd%2Fsrc%2Fmasks%2Ffull_masks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fmasks%2Ffull_masks.rs?ref=24ebae870e11ed60a83ca0acccc202387f95f25f", "patch": "@@ -14,36 +14,41 @@ impl core::fmt::Display for TryFromMaskError {\n }\n \n macro_rules! define_mask {\n-    { $(#[$attr:meta])* struct $name:ident<const $lanes:ident: usize>($type:ty); } => {\n+    {\n+        $(#[$attr:meta])*\n+        struct $name:ident<const $lanes:ident: usize>(\n+            crate::$type:ident<$lanes2:ident>\n+        );\n+    } => {\n         $(#[$attr])*\n         #[derive(Default, PartialEq, PartialOrd, Eq, Ord, Hash)]\n         #[repr(transparent)]\n-        pub struct $name<const $lanes: usize>($type)\n+        pub struct $name<const $lanes: usize>(crate::$type<$lanes2>)\n         where\n-            $type: crate::LanesAtMost32;\n+            crate::$type<LANES>: crate::LanesAtMost32;\n \n         impl<const LANES: usize> Copy for $name<LANES>\n         where\n-            $type: crate::LanesAtMost32,\n+            crate::$type<LANES>: crate::LanesAtMost32,\n         {}\n \n         impl<const LANES: usize> Clone for $name<LANES>\n         where\n-            $type: crate::LanesAtMost32,\n+            crate::$type<LANES>: crate::LanesAtMost32,\n         {\n             #[inline]\n             fn clone(&self) -> Self {\n                 *self\n             }\n         }\n \n-        impl<const $lanes: usize> $name<$lanes>\n+        impl<const LANES: usize> $name<LANES>\n         where\n-            $type: crate::LanesAtMost32,\n+            crate::$type<LANES>: crate::LanesAtMost32,\n         {\n             /// Construct a mask by setting all lanes to the given value.\n             pub fn splat(value: bool) -> Self {\n-                Self(<$type>::splat(\n+                Self(<crate::$type<LANES>>::splat(\n                     if value {\n                         -1\n                     } else {\n@@ -76,64 +81,73 @@ macro_rules! define_mask {\n                 }\n             }\n \n-            /// Creates a mask from an integer vector.\n+            /// Converts the mask to the equivalent integer representation, where -1 represents\n+            /// \"set\" and 0 represents \"unset\".\n+            #[inline]\n+            pub fn to_int(self) -> crate::$type<LANES> {\n+                self.0\n+            }\n+\n+            /// Creates a  mask from the equivalent integer representation, where -1 represents\n+            /// \"set\" and 0 represents \"unset\".\n             ///\n-            /// # Safety\n-            /// All lanes must be either 0 or -1.\n+            /// Each provided lane must be either 0 or -1.\n             #[inline]\n-            pub unsafe fn from_int_unchecked(value: $type) -> Self {\n+            pub unsafe fn from_int_unchecked(value: crate::$type<LANES>) -> Self {\n                 Self(value)\n             }\n \n-            /// Creates a mask from an integer vector.\n+            /// Creates a mask from the equivalent integer representation, where -1 represents\n+            /// \"set\" and 0 represents \"unset\".\n             ///\n             /// # Panics\n             /// Panics if any lane is not 0 or -1.\n             #[inline]\n-            pub fn from_int(value: $type) -> Self {\n+            pub fn from_int(value: crate::$type<LANES>) -> Self {\n                 use core::convert::TryInto;\n                 value.try_into().unwrap()\n             }\n         }\n \n-        impl<const $lanes: usize> core::convert::From<bool> for $name<$lanes>\n+        impl<const LANES: usize> core::convert::From<bool> for $name<LANES>\n         where\n-            $type: crate::LanesAtMost32,\n+            crate::$type<LANES>: crate::LanesAtMost32,\n         {\n             fn from(value: bool) -> Self {\n                 Self::splat(value)\n             }\n         }\n \n-        impl<const $lanes: usize> core::convert::TryFrom<$type> for $name<$lanes>\n+        impl<const LANES: usize> core::convert::TryFrom<crate::$type<LANES>> for $name<LANES>\n         where\n-            $type: crate::LanesAtMost32,\n+            crate::$type<LANES>: crate::LanesAtMost32,\n         {\n             type Error = TryFromMaskError;\n-            fn try_from(value: $type) -> Result<Self, Self::Error> {\n-                if value.as_slice().iter().all(|x| *x == 0 || *x == -1) {\n+            fn try_from(value: crate::$type<LANES>) -> Result<Self, Self::Error> {\n+                let valid = (value.lanes_eq(crate::$type::<LANES>::splat(0)) | value.lanes_eq(crate::$type::<LANES>::splat(-1))).all();\n+                if valid {\n                     Ok(Self(value))\n                 } else {\n                     Err(TryFromMaskError(()))\n                 }\n             }\n         }\n \n-        impl<const $lanes: usize> core::convert::From<$name<$lanes>> for $type\n+        impl<const LANES: usize> core::convert::From<$name<LANES>> for crate::$type<LANES>\n         where\n-            $type: crate::LanesAtMost32,\n+            crate::$type<LANES>: crate::LanesAtMost32,\n         {\n-            fn from(value: $name<$lanes>) -> Self {\n+            fn from(value: $name<LANES>) -> Self {\n                 value.0\n             }\n         }\n \n-        impl<const $lanes: usize> core::convert::From<crate::BitMask<$lanes>> for $name<$lanes>\n+        impl<const LANES: usize> core::convert::From<crate::BitMask<LANES>> for $name<LANES>\n         where\n-            $type: crate::LanesAtMost32,\n-            crate::BitMask<$lanes>: crate::LanesAtMost32,\n+            crate::$type<LANES>: crate::LanesAtMost32,\n+            crate::BitMask<LANES>: crate::LanesAtMost32,\n         {\n-            fn from(value: crate::BitMask<$lanes>) -> Self {\n+            fn from(value: crate::BitMask<LANES>) -> Self {\n                 // TODO use an intrinsic to do this efficiently (with LLVM's sext instruction)\n                 let mut mask = Self::splat(false);\n                 for lane in 0..LANES {\n@@ -143,10 +157,10 @@ macro_rules! define_mask {\n             }\n         }\n \n-        impl<const $lanes: usize> core::convert::From<$name<$lanes>> for crate::BitMask<$lanes>\n+        impl<const LANES: usize> core::convert::From<$name<LANES>> for crate::BitMask<LANES>\n         where\n-            $type: crate::LanesAtMost32,\n-            crate::BitMask<$lanes>: crate::LanesAtMost32,\n+            crate::$type<LANES>: crate::LanesAtMost32,\n+            crate::BitMask<LANES>: crate::LanesAtMost32,\n         {\n             fn from(value: $name<$lanes>) -> Self {\n                 // TODO use an intrinsic to do this efficiently (with LLVM's trunc instruction)\n@@ -158,9 +172,9 @@ macro_rules! define_mask {\n             }\n         }\n \n-        impl<const $lanes: usize> core::fmt::Debug for $name<$lanes>\n+        impl<const LANES: usize> core::fmt::Debug for $name<LANES>\n         where\n-            $type: crate::LanesAtMost32,\n+            crate::$type<LANES>: crate::LanesAtMost32,\n         {\n             fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {\n                 f.debug_list()\n@@ -169,36 +183,36 @@ macro_rules! define_mask {\n             }\n         }\n \n-        impl<const $lanes: usize> core::fmt::Binary for $name<$lanes>\n+        impl<const LANES: usize> core::fmt::Binary for $name<LANES>\n         where\n-            $type: crate::LanesAtMost32,\n+            crate::$type<LANES>: crate::LanesAtMost32,\n         {\n             fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {\n                 core::fmt::Binary::fmt(&self.0, f)\n             }\n         }\n \n-        impl<const $lanes: usize> core::fmt::Octal for $name<$lanes>\n+        impl<const LANES: usize> core::fmt::Octal for $name<LANES>\n         where\n-            $type: crate::LanesAtMost32,\n+            crate::$type<LANES>: crate::LanesAtMost32,\n         {\n             fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {\n                 core::fmt::Octal::fmt(&self.0, f)\n             }\n         }\n \n-        impl<const $lanes: usize> core::fmt::LowerHex for $name<$lanes>\n+        impl<const LANES: usize> core::fmt::LowerHex for $name<LANES>\n         where\n-            $type: crate::LanesAtMost32,\n+            crate::$type<LANES>: crate::LanesAtMost32,\n         {\n             fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {\n                 core::fmt::LowerHex::fmt(&self.0, f)\n             }\n         }\n \n-        impl<const $lanes: usize> core::fmt::UpperHex for $name<$lanes>\n+        impl<const LANES: usize> core::fmt::UpperHex for $name<LANES>\n         where\n-            $type: crate::LanesAtMost32,\n+            crate::$type<LANES>: crate::LanesAtMost32,\n         {\n             fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {\n                 core::fmt::UpperHex::fmt(&self.0, f)\n@@ -207,7 +221,7 @@ macro_rules! define_mask {\n \n         impl<const LANES: usize> core::ops::BitAnd for $name<LANES>\n         where\n-            $type: crate::LanesAtMost32,\n+            crate::$type<LANES>: crate::LanesAtMost32,\n         {\n             type Output = Self;\n             #[inline]\n@@ -218,7 +232,7 @@ macro_rules! define_mask {\n \n         impl<const LANES: usize> core::ops::BitAnd<bool> for $name<LANES>\n         where\n-            $type: crate::LanesAtMost32,\n+            crate::$type<LANES>: crate::LanesAtMost32,\n         {\n             type Output = Self;\n             #[inline]\n@@ -229,7 +243,7 @@ macro_rules! define_mask {\n \n         impl<const LANES: usize> core::ops::BitAnd<$name<LANES>> for bool\n         where\n-            $type: crate::LanesAtMost32,\n+            crate::$type<LANES>: crate::LanesAtMost32,\n         {\n             type Output = $name<LANES>;\n             #[inline]\n@@ -240,7 +254,7 @@ macro_rules! define_mask {\n \n         impl<const LANES: usize> core::ops::BitOr for $name<LANES>\n         where\n-            $type: crate::LanesAtMost32,\n+            crate::$type<LANES>: crate::LanesAtMost32,\n         {\n             type Output = Self;\n             #[inline]\n@@ -251,7 +265,7 @@ macro_rules! define_mask {\n \n         impl<const LANES: usize> core::ops::BitOr<bool> for $name<LANES>\n         where\n-            $type: crate::LanesAtMost32,\n+            crate::$type<LANES>: crate::LanesAtMost32,\n         {\n             type Output = Self;\n             #[inline]\n@@ -262,7 +276,7 @@ macro_rules! define_mask {\n \n         impl<const LANES: usize> core::ops::BitOr<$name<LANES>> for bool\n         where\n-            $type: crate::LanesAtMost32,\n+            crate::$type<LANES>: crate::LanesAtMost32,\n         {\n             type Output = $name<LANES>;\n             #[inline]\n@@ -273,7 +287,7 @@ macro_rules! define_mask {\n \n         impl<const LANES: usize> core::ops::BitXor for $name<LANES>\n         where\n-            $type: crate::LanesAtMost32,\n+            crate::$type<LANES>: crate::LanesAtMost32,\n         {\n             type Output = Self;\n             #[inline]\n@@ -284,7 +298,7 @@ macro_rules! define_mask {\n \n         impl<const LANES: usize> core::ops::BitXor<bool> for $name<LANES>\n         where\n-            $type: crate::LanesAtMost32,\n+            crate::$type<LANES>: crate::LanesAtMost32,\n         {\n             type Output = Self;\n             #[inline]\n@@ -295,7 +309,7 @@ macro_rules! define_mask {\n \n         impl<const LANES: usize> core::ops::BitXor<$name<LANES>> for bool\n         where\n-            $type: crate::LanesAtMost32,\n+            crate::$type<LANES>: crate::LanesAtMost32,\n         {\n             type Output = $name<LANES>;\n             #[inline]\n@@ -306,7 +320,7 @@ macro_rules! define_mask {\n \n         impl<const LANES: usize> core::ops::Not for $name<LANES>\n         where\n-            $type: crate::LanesAtMost32,\n+            crate::$type<LANES>: crate::LanesAtMost32,\n         {\n             type Output = $name<LANES>;\n             #[inline]\n@@ -317,7 +331,7 @@ macro_rules! define_mask {\n \n         impl<const LANES: usize> core::ops::BitAndAssign for $name<LANES>\n         where\n-            $type: crate::LanesAtMost32,\n+            crate::$type<LANES>: crate::LanesAtMost32,\n         {\n             #[inline]\n             fn bitand_assign(&mut self, rhs: Self) {\n@@ -327,7 +341,7 @@ macro_rules! define_mask {\n \n         impl<const LANES: usize> core::ops::BitAndAssign<bool> for $name<LANES>\n         where\n-            $type: crate::LanesAtMost32,\n+            crate::$type<LANES>: crate::LanesAtMost32,\n         {\n             #[inline]\n             fn bitand_assign(&mut self, rhs: bool) {\n@@ -337,7 +351,7 @@ macro_rules! define_mask {\n \n         impl<const LANES: usize> core::ops::BitOrAssign for $name<LANES>\n         where\n-            $type: crate::LanesAtMost32,\n+            crate::$type<LANES>: crate::LanesAtMost32,\n         {\n             #[inline]\n             fn bitor_assign(&mut self, rhs: Self) {\n@@ -347,7 +361,7 @@ macro_rules! define_mask {\n \n         impl<const LANES: usize> core::ops::BitOrAssign<bool> for $name<LANES>\n         where\n-            $type: crate::LanesAtMost32,\n+            crate::$type<LANES>: crate::LanesAtMost32,\n         {\n             #[inline]\n             fn bitor_assign(&mut self, rhs: bool) {\n@@ -357,7 +371,7 @@ macro_rules! define_mask {\n \n         impl<const LANES: usize> core::ops::BitXorAssign for $name<LANES>\n         where\n-            $type: crate::LanesAtMost32,\n+            crate::$type<LANES>: crate::LanesAtMost32,\n         {\n             #[inline]\n             fn bitxor_assign(&mut self, rhs: Self) {\n@@ -367,13 +381,15 @@ macro_rules! define_mask {\n \n         impl<const LANES: usize> core::ops::BitXorAssign<bool> for $name<LANES>\n         where\n-            $type: crate::LanesAtMost32,\n+            crate::$type<LANES>: crate::LanesAtMost32,\n         {\n             #[inline]\n             fn bitxor_assign(&mut self, rhs: bool) {\n                 *self ^= Self::splat(rhs);\n             }\n         }\n+\n+        impl_full_mask_reductions! { $name, $type }\n     }\n }\n "}, {"sha": "4503187e4b8a857c1cd63ff1358c4a82d5d4d050", "filename": "crates/core_simd/src/masks/mod.rs", "status": "modified", "additions": 68, "deletions": 60, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/24ebae870e11ed60a83ca0acccc202387f95f25f/crates%2Fcore_simd%2Fsrc%2Fmasks%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ebae870e11ed60a83ca0acccc202387f95f25f/crates%2Fcore_simd%2Fsrc%2Fmasks%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fmasks%2Fmod.rs?ref=24ebae870e11ed60a83ca0acccc202387f95f25f", "patch": "@@ -7,25 +7,27 @@ pub use full_masks::*;\n mod bitmask;\n pub use bitmask::*;\n \n-use crate::LanesAtMost32;\n+use crate::{LanesAtMost32, SimdI128, SimdI16, SimdI32, SimdI64, SimdI8, SimdIsize};\n \n macro_rules! define_opaque_mask {\n     {\n         $(#[$attr:meta])*\n-        struct $name:ident<const $lanes:ident: usize>($inner_ty:ty);\n-        @bits $bits_ty:ty\n+        struct $name:ident<const $lanes:ident: usize>($inner_ty:ident<$lanes2:ident>);\n+        @bits $bits_ty:ident\n     } => {\n         $(#[$attr])*\n         #[allow(non_camel_case_types)]\n-        pub struct $name<const $lanes: usize>($inner_ty) where $bits_ty: LanesAtMost32;\n+        pub struct $name<const LANES: usize>($inner_ty<LANES>) where $bits_ty<LANES>: LanesAtMost32;\n \n-        impl<const $lanes: usize> $name<$lanes>\n+        impl_opaque_mask_reductions! { $name, $inner_ty, $bits_ty }\n+\n+        impl<const LANES: usize> $name<LANES>\n         where\n-            $bits_ty: LanesAtMost32\n+            $bits_ty<LANES>: LanesAtMost32\n         {\n             /// Construct a mask by setting all lanes to the given value.\n             pub fn splat(value: bool) -> Self {\n-                Self(<$inner_ty>::splat(value))\n+                Self(<$inner_ty<LANES>>::splat(value))\n             }\n \n             /// Converts an array to a SIMD vector.\n@@ -69,106 +71,112 @@ macro_rules! define_opaque_mask {\n             }\n         }\n \n-        impl<const $lanes: usize> From<BitMask<$lanes>> for $name<$lanes>\n+        impl<const LANES: usize> From<BitMask<LANES>> for $name<LANES>\n         where\n-            $bits_ty: LanesAtMost32,\n-            BitMask<$lanes>: LanesAtMost32,\n+            $bits_ty<LANES>: LanesAtMost32,\n+            BitMask<LANES>: LanesAtMost32,\n         {\n-            fn from(value: BitMask<$lanes>) -> Self {\n+            fn from(value: BitMask<LANES>) -> Self {\n                 Self(value.into())\n             }\n         }\n \n-        impl<const $lanes: usize> From<$name<$lanes>> for crate::BitMask<$lanes>\n+        impl<const LANES: usize> From<$name<LANES>> for crate::BitMask<LANES>\n         where\n-            $bits_ty: LanesAtMost32,\n-            BitMask<$lanes>: LanesAtMost32,\n+            $bits_ty<LANES>: LanesAtMost32,\n+            BitMask<LANES>: LanesAtMost32,\n         {\n-            fn from(value: $name<$lanes>) -> Self {\n+            fn from(value: $name<LANES>) -> Self {\n                 value.0.into()\n             }\n         }\n \n-        impl<const $lanes: usize> From<$inner_ty> for $name<$lanes>\n+        impl<const LANES: usize> From<$inner_ty<LANES>> for $name<LANES>\n         where\n-            $bits_ty: LanesAtMost32,\n+            $bits_ty<LANES>: LanesAtMost32,\n         {\n-            fn from(value: $inner_ty) -> Self {\n+            fn from(value: $inner_ty<LANES>) -> Self {\n                 Self(value)\n             }\n         }\n \n-        impl<const $lanes: usize> From<$name<$lanes>> for $inner_ty\n+        impl<const LANES: usize> From<$name<LANES>> for $inner_ty<LANES>\n         where\n-            $bits_ty: LanesAtMost32,\n+            $bits_ty<LANES>: LanesAtMost32,\n         {\n-            fn from(value: $name<$lanes>) -> Self {\n+            fn from(value: $name<LANES>) -> Self {\n                 value.0\n             }\n         }\n \n         // vector/array conversion\n-        impl<const $lanes: usize> From<[bool; $lanes]> for $name<$lanes> where $bits_ty: crate::LanesAtMost32 {\n-            fn from(array: [bool; $lanes]) -> Self {\n+        impl<const LANES: usize> From<[bool; LANES]> for $name<LANES>\n+        where\n+            $bits_ty<LANES>: crate::LanesAtMost32\n+        {\n+            fn from(array: [bool; LANES]) -> Self {\n                 Self::from_array(array)\n             }\n         }\n \n-        impl <const $lanes: usize> From<$name<$lanes>> for [bool; $lanes] where $bits_ty: crate::LanesAtMost32 {\n-            fn from(vector: $name<$lanes>) -> Self {\n+        impl <const LANES: usize> From<$name<LANES>> for [bool; LANES]\n+        where\n+            $bits_ty<LANES>: crate::LanesAtMost32\n+        {\n+            fn from(vector: $name<LANES>) -> Self {\n                 vector.to_array()\n             }\n         }\n \n-        impl<const $lanes: usize> Copy for $name<$lanes>\n+        impl<const LANES: usize> Copy for $name<LANES>\n         where\n-            $inner_ty: Copy,\n-            $bits_ty: LanesAtMost32,\n+            $inner_ty<LANES>: Copy,\n+            $bits_ty<LANES>: LanesAtMost32,\n         {}\n \n-        impl<const $lanes: usize> Clone for $name<$lanes>\n+        impl<const LANES: usize> Clone for $name<LANES>\n         where\n-            $bits_ty: LanesAtMost32,\n+            $bits_ty<LANES>: LanesAtMost32,\n         {\n             #[inline]\n             fn clone(&self) -> Self {\n                 *self\n             }\n         }\n \n-        impl<const $lanes: usize> Default for $name<$lanes>\n+        impl<const LANES: usize> Default for $name<LANES>\n         where\n-            $bits_ty: LanesAtMost32,\n+            $bits_ty<LANES>: LanesAtMost32,\n         {\n             #[inline]\n             fn default() -> Self {\n                 Self::splat(false)\n             }\n         }\n \n-        impl<const $lanes: usize> PartialEq for $name<$lanes>\n+        impl<const LANES: usize> PartialEq for $name<LANES>\n         where\n-            $bits_ty: LanesAtMost32,\n+            $bits_ty<LANES>: LanesAtMost32,\n         {\n             #[inline]\n             fn eq(&self, other: &Self) -> bool {\n                 self.0 == other.0\n             }\n         }\n \n-        impl<const $lanes: usize> PartialOrd for $name<$lanes>\n+        impl<const LANES: usize> PartialOrd for $name<LANES>\n         where\n-            $bits_ty: LanesAtMost32,\n+            $bits_ty<LANES>: LanesAtMost32,\n         {\n             #[inline]\n             fn partial_cmp(&self, other: &Self) -> Option<core::cmp::Ordering> {\n                 self.0.partial_cmp(&other.0)\n             }\n         }\n \n-        impl<const $lanes: usize> core::fmt::Debug for $name<$lanes>\n+        impl<const LANES: usize> core::fmt::Debug for $name<LANES>\n         where\n-            $bits_ty: LanesAtMost32,\n+            $bits_ty<LANES>: LanesAtMost32,\n         {\n             fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {\n                 core::fmt::Debug::fmt(&self.0, f)\n@@ -177,7 +185,7 @@ macro_rules! define_opaque_mask {\n \n         impl<const LANES: usize> core::ops::BitAnd for $name<LANES>\n         where\n-            $bits_ty: LanesAtMost32,\n+            $bits_ty<LANES>: LanesAtMost32,\n         {\n             type Output = Self;\n             #[inline]\n@@ -188,7 +196,7 @@ macro_rules! define_opaque_mask {\n \n         impl<const LANES: usize> core::ops::BitAnd<bool> for $name<LANES>\n         where\n-            $bits_ty: LanesAtMost32,\n+            $bits_ty<LANES>: LanesAtMost32,\n         {\n             type Output = Self;\n             #[inline]\n@@ -199,7 +207,7 @@ macro_rules! define_opaque_mask {\n \n         impl<const LANES: usize> core::ops::BitAnd<$name<LANES>> for bool\n         where\n-            $bits_ty: LanesAtMost32,\n+            $bits_ty<LANES>: LanesAtMost32,\n         {\n             type Output = $name<LANES>;\n             #[inline]\n@@ -210,7 +218,7 @@ macro_rules! define_opaque_mask {\n \n         impl<const LANES: usize> core::ops::BitOr for $name<LANES>\n         where\n-            $bits_ty: LanesAtMost32,\n+            $bits_ty<LANES>: LanesAtMost32,\n         {\n             type Output = Self;\n             #[inline]\n@@ -221,7 +229,7 @@ macro_rules! define_opaque_mask {\n \n         impl<const LANES: usize> core::ops::BitOr<bool> for $name<LANES>\n         where\n-            $bits_ty: LanesAtMost32,\n+            $bits_ty<LANES>: LanesAtMost32,\n         {\n             type Output = Self;\n             #[inline]\n@@ -232,7 +240,7 @@ macro_rules! define_opaque_mask {\n \n         impl<const LANES: usize> core::ops::BitOr<$name<LANES>> for bool\n         where\n-            $bits_ty: LanesAtMost32,\n+            $bits_ty<LANES>: LanesAtMost32,\n         {\n             type Output = $name<LANES>;\n             #[inline]\n@@ -243,7 +251,7 @@ macro_rules! define_opaque_mask {\n \n         impl<const LANES: usize> core::ops::BitXor for $name<LANES>\n         where\n-            $bits_ty: LanesAtMost32,\n+            $bits_ty<LANES>: LanesAtMost32,\n         {\n             type Output = Self;\n             #[inline]\n@@ -254,7 +262,7 @@ macro_rules! define_opaque_mask {\n \n         impl<const LANES: usize> core::ops::BitXor<bool> for $name<LANES>\n         where\n-            $bits_ty: LanesAtMost32,\n+            $bits_ty<LANES>: LanesAtMost32,\n         {\n             type Output = Self;\n             #[inline]\n@@ -265,7 +273,7 @@ macro_rules! define_opaque_mask {\n \n         impl<const LANES: usize> core::ops::BitXor<$name<LANES>> for bool\n         where\n-            $bits_ty: LanesAtMost32,\n+            $bits_ty<LANES>: LanesAtMost32,\n         {\n             type Output = $name<LANES>;\n             #[inline]\n@@ -276,7 +284,7 @@ macro_rules! define_opaque_mask {\n \n         impl<const LANES: usize> core::ops::Not for $name<LANES>\n         where\n-            $bits_ty: LanesAtMost32,\n+            $bits_ty<LANES>: LanesAtMost32,\n         {\n             type Output = $name<LANES>;\n             #[inline]\n@@ -287,7 +295,7 @@ macro_rules! define_opaque_mask {\n \n         impl<const LANES: usize> core::ops::BitAndAssign for $name<LANES>\n         where\n-            $bits_ty: LanesAtMost32,\n+            $bits_ty<LANES>: LanesAtMost32,\n         {\n             #[inline]\n             fn bitand_assign(&mut self, rhs: Self) {\n@@ -297,7 +305,7 @@ macro_rules! define_opaque_mask {\n \n         impl<const LANES: usize> core::ops::BitAndAssign<bool> for $name<LANES>\n         where\n-            $bits_ty: LanesAtMost32,\n+            $bits_ty<LANES>: LanesAtMost32,\n         {\n             #[inline]\n             fn bitand_assign(&mut self, rhs: bool) {\n@@ -307,7 +315,7 @@ macro_rules! define_opaque_mask {\n \n         impl<const LANES: usize> core::ops::BitOrAssign for $name<LANES>\n         where\n-            $bits_ty: LanesAtMost32,\n+            $bits_ty<LANES>: LanesAtMost32,\n         {\n             #[inline]\n             fn bitor_assign(&mut self, rhs: Self) {\n@@ -317,7 +325,7 @@ macro_rules! define_opaque_mask {\n \n         impl<const LANES: usize> core::ops::BitOrAssign<bool> for $name<LANES>\n         where\n-            $bits_ty: LanesAtMost32,\n+            $bits_ty<LANES>: LanesAtMost32,\n         {\n             #[inline]\n             fn bitor_assign(&mut self, rhs: bool) {\n@@ -327,7 +335,7 @@ macro_rules! define_opaque_mask {\n \n         impl<const LANES: usize> core::ops::BitXorAssign for $name<LANES>\n         where\n-            $bits_ty: LanesAtMost32,\n+            $bits_ty<LANES>: LanesAtMost32,\n         {\n             #[inline]\n             fn bitxor_assign(&mut self, rhs: Self) {\n@@ -337,7 +345,7 @@ macro_rules! define_opaque_mask {\n \n         impl<const LANES: usize> core::ops::BitXorAssign<bool> for $name<LANES>\n         where\n-            $bits_ty: LanesAtMost32,\n+            $bits_ty<LANES>: LanesAtMost32,\n         {\n             #[inline]\n             fn bitxor_assign(&mut self, rhs: bool) {\n@@ -352,47 +360,47 @@ define_opaque_mask! {\n     ///\n     /// The layout of this type is unspecified.\n     struct Mask8<const LANES: usize>(SimdMask8<LANES>);\n-    @bits crate::SimdI8<LANES>\n+    @bits SimdI8\n }\n \n define_opaque_mask! {\n     /// Mask for vectors with `LANES` 16-bit elements.\n     ///\n     /// The layout of this type is unspecified.\n     struct Mask16<const LANES: usize>(SimdMask16<LANES>);\n-    @bits crate::SimdI16<LANES>\n+    @bits SimdI16\n }\n \n define_opaque_mask! {\n     /// Mask for vectors with `LANES` 32-bit elements.\n     ///\n     /// The layout of this type is unspecified.\n     struct Mask32<const LANES: usize>(SimdMask32<LANES>);\n-    @bits crate::SimdI32<LANES>\n+    @bits SimdI32\n }\n \n define_opaque_mask! {\n     /// Mask for vectors with `LANES` 64-bit elements.\n     ///\n     /// The layout of this type is unspecified.\n     struct Mask64<const LANES: usize>(SimdMask64<LANES>);\n-    @bits crate::SimdI64<LANES>\n+    @bits SimdI64\n }\n \n define_opaque_mask! {\n     /// Mask for vectors with `LANES` 128-bit elements.\n     ///\n     /// The layout of this type is unspecified.\n     struct Mask128<const LANES: usize>(SimdMask128<LANES>);\n-    @bits crate::SimdI128<LANES>\n+    @bits SimdI128\n }\n \n define_opaque_mask! {\n     /// Mask for vectors with `LANES` pointer-width elements.\n     ///\n     /// The layout of this type is unspecified.\n     struct MaskSize<const LANES: usize>(SimdMaskSize<LANES>);\n-    @bits crate::SimdIsize<LANES>\n+    @bits SimdIsize\n }\n \n /// Vector of eight 8-bit masks"}, {"sha": "382d366dd3d1494a0e035775d4db4739c6c84470", "filename": "crates/core_simd/src/reduction.rs", "status": "added", "additions": 162, "deletions": 0, "changes": 162, "blob_url": "https://github.com/rust-lang/rust/blob/24ebae870e11ed60a83ca0acccc202387f95f25f/crates%2Fcore_simd%2Fsrc%2Freduction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ebae870e11ed60a83ca0acccc202387f95f25f/crates%2Fcore_simd%2Fsrc%2Freduction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Freduction.rs?ref=24ebae870e11ed60a83ca0acccc202387f95f25f", "patch": "@@ -0,0 +1,162 @@\n+macro_rules! impl_integer_reductions {\n+    { $name:ident, $scalar:ty } => {\n+        impl<const LANES: usize> crate::$name<LANES>\n+        where\n+            Self: crate::LanesAtMost32\n+        {\n+            /// Horizontal wrapping add.  Returns the sum of the lanes of the vector, with wrapping addition.\n+            #[inline]\n+            pub fn horizontal_sum(self) -> $scalar {\n+                unsafe { crate::intrinsics::simd_reduce_add_ordered(self, 0) }\n+            }\n+\n+            /// Horizontal wrapping multiply.  Returns the product of the lanes of the vector, with wrapping multiplication.\n+            #[inline]\n+            pub fn horizontal_product(self) -> $scalar {\n+                unsafe { crate::intrinsics::simd_reduce_mul_ordered(self, 1) }\n+            }\n+\n+            /// Horizontal bitwise \"and\".  Returns the cumulative bitwise \"and\" across the lanes of\n+            /// the vector.\n+            #[inline]\n+            pub fn horizontal_and(self) -> $scalar {\n+                unsafe { crate::intrinsics::simd_reduce_and(self) }\n+            }\n+\n+            /// Horizontal bitwise \"or\".  Returns the cumulative bitwise \"or\" across the lanes of\n+            /// the vector.\n+            #[inline]\n+            pub fn horizontal_or(self) -> $scalar {\n+                unsafe { crate::intrinsics::simd_reduce_or(self) }\n+            }\n+\n+            /// Horizontal bitwise \"xor\".  Returns the cumulative bitwise \"xor\" across the lanes of\n+            /// the vector.\n+            #[inline]\n+            pub fn horizontal_xor(self) -> $scalar {\n+                unsafe { crate::intrinsics::simd_reduce_xor(self) }\n+            }\n+\n+            /// Horizontal maximum.  Returns the maximum lane in the vector.\n+            #[inline]\n+            pub fn horizontal_max(self) -> $scalar {\n+                unsafe { crate::intrinsics::simd_reduce_max(self) }\n+            }\n+\n+            /// Horizontal minimum.  Returns the minimum lane in the vector.\n+            #[inline]\n+            pub fn horizontal_min(self) -> $scalar {\n+                unsafe { crate::intrinsics::simd_reduce_min(self) }\n+            }\n+        }\n+    }\n+}\n+\n+macro_rules! impl_float_reductions {\n+    { $name:ident, $scalar:ty } => {\n+        impl<const LANES: usize> crate::$name<LANES>\n+        where\n+            Self: crate::LanesAtMost32\n+        {\n+\n+            /// Horizontal add.  Returns the sum of the lanes of the vector.\n+            #[inline]\n+            pub fn horizontal_sum(self) -> $scalar {\n+                // LLVM sum is inaccurate on i586\n+                if cfg!(all(target_arch = \"x86\", not(target_feature = \"sse2\"))) {\n+                    self.as_slice().iter().sum()\n+                } else {\n+                    unsafe { crate::intrinsics::simd_reduce_add_ordered(self, 0.) }\n+                }\n+            }\n+\n+            /// Horizontal multiply.  Returns the product of the lanes of the vector.\n+            #[inline]\n+            pub fn horizontal_product(self) -> $scalar {\n+                // LLVM product is inaccurate on i586\n+                if cfg!(all(target_arch = \"x86\", not(target_feature = \"sse2\"))) {\n+                    self.as_slice().iter().product()\n+                } else {\n+                    unsafe { crate::intrinsics::simd_reduce_mul_ordered(self, 1.) }\n+                }\n+            }\n+\n+            /// Horizontal maximum.  Returns the maximum lane in the vector.\n+            ///\n+            /// Returns values based on equality, so a vector containing both `0.` and `-0.` may\n+            /// return either.  This function will not return `NaN` unless all lanes are `NaN`.\n+            #[inline]\n+            pub fn horizontal_max(self) -> $scalar {\n+                unsafe { crate::intrinsics::simd_reduce_max(self) }\n+            }\n+\n+            /// Horizontal minimum.  Returns the minimum lane in the vector.\n+            ///\n+            /// Returns values based on equality, so a vector containing both `0.` and `-0.` may\n+            /// return either.  This function will not return `NaN` unless all lanes are `NaN`.\n+            #[inline]\n+            pub fn horizontal_min(self) -> $scalar {\n+                unsafe { crate::intrinsics::simd_reduce_min(self) }\n+            }\n+        }\n+    }\n+}\n+\n+macro_rules! impl_full_mask_reductions {\n+    { $name:ident, $inner:ident } => {\n+        impl<const LANES: usize> crate::$name<LANES>\n+        where\n+            crate::$inner<LANES>: crate::LanesAtMost32\n+        {\n+            /// Returns true if any lane is set, or false otherwise.\n+            #[inline]\n+            pub fn any(self) -> bool {\n+                unsafe { crate::intrinsics::simd_reduce_any(self.to_int()) }\n+            }\n+\n+            /// Returns true if all lanes are set, or false otherwise.\n+            #[inline]\n+            pub fn all(self) -> bool {\n+                unsafe { crate::intrinsics::simd_reduce_all(self.to_int()) }\n+            }\n+        }\n+    }\n+}\n+\n+macro_rules! impl_opaque_mask_reductions {\n+    { $name:ident, $inner:ident, $bits_ty:ident } => {\n+        impl<const LANES: usize> $name<LANES>\n+        where\n+            $bits_ty<LANES>: crate::LanesAtMost32\n+        {\n+            /// Returns true if any lane is set, or false otherwise.\n+            #[inline]\n+            pub fn any(self) -> bool {\n+                self.0.any()\n+            }\n+\n+            /// Returns true if all lanes are set, or false otherwise.\n+            #[inline]\n+            pub fn all(self) -> bool {\n+                self.0.all()\n+            }\n+        }\n+    }\n+}\n+\n+impl<const LANES: usize> crate::BitMask<LANES>\n+where\n+    crate::BitMask<LANES>: crate::LanesAtMost32,\n+{\n+    /// Returns true if any lane is set, or false otherwise.\n+    #[inline]\n+    pub fn any(self) -> bool {\n+        self != Self::splat(false)\n+    }\n+\n+    /// Returns true if all lanes are set, or false otherwise.\n+    #[inline]\n+    pub fn all(self) -> bool {\n+        self == Self::splat(true)\n+    }\n+}"}, {"sha": "47013053ae15e9cacf8f306a39d013f3090a51b8", "filename": "crates/core_simd/src/vector/float.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/24ebae870e11ed60a83ca0acccc202387f95f25f/crates%2Fcore_simd%2Fsrc%2Fvector%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ebae870e11ed60a83ca0acccc202387f95f25f/crates%2Fcore_simd%2Fsrc%2Fvector%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fvector%2Ffloat.rs?ref=24ebae870e11ed60a83ca0acccc202387f95f25f", "patch": "@@ -6,6 +6,7 @@\n macro_rules! impl_float_vector {\n     { $name:ident, $type:ty, $bits_ty:ident, $mask_ty:ident, $mask_impl_ty:ident } => {\n         impl_vector! { $name, $type }\n+        impl_float_reductions! { $name, $type }\n \n         impl<const LANES: usize> $name<LANES>\n         where"}, {"sha": "24f77cb3e106a357baf90e6fb5f57772158212bb", "filename": "crates/core_simd/src/vector/int.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/24ebae870e11ed60a83ca0acccc202387f95f25f/crates%2Fcore_simd%2Fsrc%2Fvector%2Fint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ebae870e11ed60a83ca0acccc202387f95f25f/crates%2Fcore_simd%2Fsrc%2Fvector%2Fint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fvector%2Fint.rs?ref=24ebae870e11ed60a83ca0acccc202387f95f25f", "patch": "@@ -4,6 +4,7 @@\n macro_rules! impl_integer_vector {\n     { $name:ident, $type:ty, $mask_ty:ident, $mask_impl_ty:ident } => {\n         impl_vector! { $name, $type }\n+        impl_integer_reductions! { $name, $type }\n \n         impl<const LANES: usize> Eq for $name<LANES> where Self: crate::LanesAtMost32 {}\n "}, {"sha": "3866b9ca5c6ef150d2f330baa64d2a23ee92a30e", "filename": "crates/core_simd/src/vector/uint.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/24ebae870e11ed60a83ca0acccc202387f95f25f/crates%2Fcore_simd%2Fsrc%2Fvector%2Fuint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ebae870e11ed60a83ca0acccc202387f95f25f/crates%2Fcore_simd%2Fsrc%2Fvector%2Fuint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fvector%2Fuint.rs?ref=24ebae870e11ed60a83ca0acccc202387f95f25f", "patch": "@@ -5,6 +5,7 @@\n macro_rules! impl_unsigned_vector {\n     { $name:ident, $type:ty } => {\n         impl_vector! { $name, $type }\n+        impl_integer_reductions! { $name, $type }\n \n         impl<const LANES: usize> Eq for $name<LANES> where Self: crate::LanesAtMost32 {}\n "}, {"sha": "59da77de622b9e85198dcf4bd55d7f20c237f802", "filename": "crates/core_simd/tests/masks.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/24ebae870e11ed60a83ca0acccc202387f95f25f/crates%2Fcore_simd%2Ftests%2Fmasks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ebae870e11ed60a83ca0acccc202387f95f25f/crates%2Fcore_simd%2Ftests%2Fmasks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Ftests%2Fmasks.rs?ref=24ebae870e11ed60a83ca0acccc202387f95f25f", "patch": "@@ -59,6 +59,24 @@ macro_rules! test_mask_api {\n                 let mask = core_simd::$name::<8>::splat(false);\n                 let _ = mask.test(8);\n             }\n+\n+            #[test]\n+            fn any() {\n+                assert!(!core_simd::$name::<8>::splat(false).any());\n+                assert!(core_simd::$name::<8>::splat(true).any());\n+                let mut v = core_simd::$name::<8>::splat(false);\n+                v.set(2, true);\n+                assert!(v.any());\n+            }\n+\n+            #[test]\n+            fn all() {\n+                assert!(!core_simd::$name::<8>::splat(false).all());\n+                assert!(core_simd::$name::<8>::splat(true).all());\n+                let mut v = core_simd::$name::<8>::splat(false);\n+                v.set(2, true);\n+                assert!(!v.all());\n+            }\n         }\n     }\n }"}, {"sha": "37f3b49a33061e8bb0d992cfc6ec6e47fb7b28b2", "filename": "crates/core_simd/tests/ops_macros.rs", "status": "modified", "additions": 125, "deletions": 0, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/24ebae870e11ed60a83ca0acccc202387f95f25f/crates%2Fcore_simd%2Ftests%2Fops_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ebae870e11ed60a83ca0acccc202387f95f25f/crates%2Fcore_simd%2Ftests%2Fops_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Ftests%2Fops_macros.rs?ref=24ebae870e11ed60a83ca0acccc202387f95f25f", "patch": "@@ -136,6 +136,83 @@ macro_rules! impl_binary_checked_op_test {\n     };\n }\n \n+#[macro_export]\n+macro_rules! impl_common_integer_tests {\n+    { $vector:ident, $scalar:ident } => {\n+        test_helpers::test_lanes! {\n+            fn horizontal_sum<const LANES: usize>() {\n+                test_helpers::test_1(&|x| {\n+                    test_helpers::prop_assert_biteq! (\n+                        $vector::<LANES>::from_array(x).horizontal_sum(),\n+                        x.iter().copied().fold(0 as $scalar, $scalar::wrapping_add),\n+                    );\n+                    Ok(())\n+                });\n+            }\n+\n+            fn horizontal_product<const LANES: usize>() {\n+                test_helpers::test_1(&|x| {\n+                    test_helpers::prop_assert_biteq! (\n+                        $vector::<LANES>::from_array(x).horizontal_product(),\n+                        x.iter().copied().fold(1 as $scalar, $scalar::wrapping_mul),\n+                    );\n+                    Ok(())\n+                });\n+            }\n+\n+            fn horizontal_and<const LANES: usize>() {\n+                test_helpers::test_1(&|x| {\n+                    test_helpers::prop_assert_biteq! (\n+                        $vector::<LANES>::from_array(x).horizontal_and(),\n+                        x.iter().copied().fold(-1i8 as $scalar, <$scalar as core::ops::BitAnd>::bitand),\n+                    );\n+                    Ok(())\n+                });\n+            }\n+\n+            fn horizontal_or<const LANES: usize>() {\n+                test_helpers::test_1(&|x| {\n+                    test_helpers::prop_assert_biteq! (\n+                        $vector::<LANES>::from_array(x).horizontal_or(),\n+                        x.iter().copied().fold(0 as $scalar, <$scalar as core::ops::BitOr>::bitor),\n+                    );\n+                    Ok(())\n+                });\n+            }\n+\n+            fn horizontal_xor<const LANES: usize>() {\n+                test_helpers::test_1(&|x| {\n+                    test_helpers::prop_assert_biteq! (\n+                        $vector::<LANES>::from_array(x).horizontal_xor(),\n+                        x.iter().copied().fold(0 as $scalar, <$scalar as core::ops::BitXor>::bitxor),\n+                    );\n+                    Ok(())\n+                });\n+            }\n+\n+            fn horizontal_max<const LANES: usize>() {\n+                test_helpers::test_1(&|x| {\n+                    test_helpers::prop_assert_biteq! (\n+                        $vector::<LANES>::from_array(x).horizontal_max(),\n+                        x.iter().copied().max().unwrap(),\n+                    );\n+                    Ok(())\n+                });\n+            }\n+\n+            fn horizontal_min<const LANES: usize>() {\n+                test_helpers::test_1(&|x| {\n+                    test_helpers::prop_assert_biteq! (\n+                        $vector::<LANES>::from_array(x).horizontal_min(),\n+                        x.iter().copied().min().unwrap(),\n+                    );\n+                    Ok(())\n+                });\n+            }\n+        }\n+    }\n+}\n+\n /// Implement tests for signed integers.\n #[macro_export]\n macro_rules! impl_signed_tests {\n@@ -144,6 +221,8 @@ macro_rules! impl_signed_tests {\n             type Vector<const LANES: usize> = core_simd::$vector<LANES>;\n             type Scalar = $scalar;\n \n+            impl_common_integer_tests! { Vector, Scalar }\n+\n             test_helpers::test_lanes! {\n                 fn neg<const LANES: usize>() {\n                     test_helpers::test_unary_elementwise(\n@@ -241,6 +320,8 @@ macro_rules! impl_unsigned_tests {\n             type Vector<const LANES: usize> = core_simd::$vector<LANES>;\n             type Scalar = $scalar;\n \n+            impl_common_integer_tests! { Vector, Scalar }\n+\n             test_helpers::test_lanes_panic! {\n                 fn rem_zero_panic<const LANES: usize>() {\n                     let a = Vector::<LANES>::splat(42);\n@@ -397,6 +478,50 @@ macro_rules! impl_float_tests {\n                         },\n                     ).unwrap();\n                 }\n+\n+                fn horizontal_sum<const LANES: usize>() {\n+                    test_helpers::test_1(&|x| {\n+                        test_helpers::prop_assert_biteq! (\n+                            Vector::<LANES>::from_array(x).horizontal_sum(),\n+                            x.iter().sum(),\n+                        );\n+                        Ok(())\n+                    });\n+                }\n+\n+                fn horizontal_product<const LANES: usize>() {\n+                    test_helpers::test_1(&|x| {\n+                        test_helpers::prop_assert_biteq! (\n+                            Vector::<LANES>::from_array(x).horizontal_product(),\n+                            x.iter().product(),\n+                        );\n+                        Ok(())\n+                    });\n+                }\n+\n+                fn horizontal_max<const LANES: usize>() {\n+                    test_helpers::test_1(&|x| {\n+                        let vmax = Vector::<LANES>::from_array(x).horizontal_max();\n+                        let smax = x.iter().copied().fold(Scalar::NAN, Scalar::max);\n+                        // 0 and -0 are treated the same\n+                        if !(x.contains(&0.) && x.contains(&-0.) && vmax.abs() == 0. && smax.abs() == 0.) {\n+                            test_helpers::prop_assert_biteq!(vmax, smax);\n+                        }\n+                        Ok(())\n+                    });\n+                }\n+\n+                fn horizontal_min<const LANES: usize>() {\n+                    test_helpers::test_1(&|x| {\n+                        let vmax = Vector::<LANES>::from_array(x).horizontal_min();\n+                        let smax = x.iter().copied().fold(Scalar::NAN, Scalar::min);\n+                        // 0 and -0 are treated the same\n+                        if !(x.contains(&0.) && x.contains(&-0.) && vmax.abs() == 0. && smax.abs() == 0.) {\n+                            test_helpers::prop_assert_biteq!(vmax, smax);\n+                        }\n+                        Ok(())\n+                    });\n+                }\n             }\n         }\n     }"}, {"sha": "00350e22418d029a63c9704e82205c14e3dd405f", "filename": "crates/test_helpers/src/biteq.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24ebae870e11ed60a83ca0acccc202387f95f25f/crates%2Ftest_helpers%2Fsrc%2Fbiteq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ebae870e11ed60a83ca0acccc202387f95f25f/crates%2Ftest_helpers%2Fsrc%2Fbiteq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Ftest_helpers%2Fsrc%2Fbiteq.rs?ref=24ebae870e11ed60a83ca0acccc202387f95f25f", "patch": "@@ -95,7 +95,7 @@ impl<T: BitEq> core::fmt::Debug for BitEqWrapper<'_, T> {\n \n #[macro_export]\n macro_rules! prop_assert_biteq {\n-    { $a:expr, $b:expr } => {\n+    { $a:expr, $b:expr $(,)? } => {\n         {\n             use $crate::biteq::BitEqWrapper;\n             let a = $a;"}]}