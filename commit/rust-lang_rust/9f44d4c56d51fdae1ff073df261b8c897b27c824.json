{"sha": "9f44d4c56d51fdae1ff073df261b8c897b27c824", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlmNDRkNGM1NmQ1MWZkYWUxZmYwNzNkZjI2MWI4Yzg5N2IyN2M4MjQ=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-01-05T14:33:31Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-01-05T14:33:31Z"}, "message": "fold doc_comment into hover", "tree": {"sha": "f2b248616c5d31d5d4e48c6fe5969cbd7594b477", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f2b248616c5d31d5d4e48c6fe5969cbd7594b477"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9f44d4c56d51fdae1ff073df261b8c897b27c824", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9f44d4c56d51fdae1ff073df261b8c897b27c824", "html_url": "https://github.com/rust-lang/rust/commit/9f44d4c56d51fdae1ff073df261b8c897b27c824", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9f44d4c56d51fdae1ff073df261b8c897b27c824/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3ad0037f907778d20ce6cfd9bf676a467b5734ad", "url": "https://api.github.com/repos/rust-lang/rust/commits/3ad0037f907778d20ce6cfd9bf676a467b5734ad", "html_url": "https://github.com/rust-lang/rust/commit/3ad0037f907778d20ce6cfd9bf676a467b5734ad"}], "stats": {"total": 219, "additions": 110, "deletions": 109}, "files": [{"sha": "c99d87da63c26d2a19eaca10a2f5473ae73933d9", "filename": "crates/ra_analysis/src/hover.rs", "status": "modified", "additions": 108, "deletions": 3, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/9f44d4c56d51fdae1ff073df261b8c897b27c824/crates%2Fra_analysis%2Fsrc%2Fhover.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f44d4c56d51fdae1ff073df261b8c897b27c824/crates%2Fra_analysis%2Fsrc%2Fhover.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fhover.rs?ref=9f44d4c56d51fdae1ff073df261b8c897b27c824", "patch": "@@ -1,7 +1,11 @@\n use ra_db::{Cancelable, SyntaxDatabase};\n-use ra_syntax::{ast, AstNode};\n+use ra_syntax::{\n+    AstNode, SyntaxNode,\n+    ast::{self, NameOwner},\n+    algo::visit::{visitor, Visitor},\n+};\n \n-use crate::{db::RootDatabase, RangeInfo, FilePosition, FileRange};\n+use crate::{db::RootDatabase, RangeInfo, FilePosition, FileRange, NavigationTarget};\n \n pub(crate) fn hover(\n     db: &RootDatabase,\n@@ -10,7 +14,7 @@ pub(crate) fn hover(\n     let mut res = Vec::new();\n     let range = if let Some(rr) = db.approximately_resolve_symbol(position)? {\n         for nav in rr.resolves_to {\n-            res.extend(db.doc_text_for(nav)?)\n+            res.extend(doc_text_for(db, nav)?)\n         }\n         rr.reference_range\n     } else {\n@@ -33,6 +37,107 @@ pub(crate) fn hover(\n     Ok(Some(res))\n }\n \n+// FIXME: this should not really use navigation target. Rather, approximatelly\n+// resovled symbol should return a `DefId`.\n+fn doc_text_for(db: &RootDatabase, nav: NavigationTarget) -> Cancelable<Option<String>> {\n+    let result = match (nav.description(db), nav.docs(db)) {\n+        (Some(desc), Some(docs)) => Some(\"```rust\\n\".to_string() + &*desc + \"\\n```\\n\\n\" + &*docs),\n+        (Some(desc), None) => Some(\"```rust\\n\".to_string() + &*desc + \"\\n```\"),\n+        (None, Some(docs)) => Some(docs),\n+        _ => None,\n+    };\n+\n+    Ok(result)\n+}\n+\n+impl NavigationTarget {\n+    fn node(&self, db: &RootDatabase) -> Option<SyntaxNode> {\n+        let source_file = db.source_file(self.file_id);\n+        let source_file = source_file.syntax();\n+        let node = source_file\n+            .descendants()\n+            .find(|node| node.kind() == self.kind && node.range() == self.range)?\n+            .owned();\n+        Some(node)\n+    }\n+\n+    fn docs(&self, db: &RootDatabase) -> Option<String> {\n+        let node = self.node(db)?;\n+        let node = node.borrowed();\n+        fn doc_comments<'a, N: ast::DocCommentsOwner<'a>>(node: N) -> Option<String> {\n+            let comments = node.doc_comment_text();\n+            if comments.is_empty() {\n+                None\n+            } else {\n+                Some(comments)\n+            }\n+        }\n+\n+        visitor()\n+            .visit(doc_comments::<ast::FnDef>)\n+            .visit(doc_comments::<ast::StructDef>)\n+            .visit(doc_comments::<ast::EnumDef>)\n+            .visit(doc_comments::<ast::TraitDef>)\n+            .visit(doc_comments::<ast::Module>)\n+            .visit(doc_comments::<ast::TypeDef>)\n+            .visit(doc_comments::<ast::ConstDef>)\n+            .visit(doc_comments::<ast::StaticDef>)\n+            .accept(node)?\n+    }\n+\n+    /// Get a description of this node.\n+    ///\n+    /// e.g. `struct Name`, `enum Name`, `fn Name`\n+    fn description(&self, db: &RootDatabase) -> Option<String> {\n+        // TODO: After type inference is done, add type information to improve the output\n+        let node = self.node(db)?;\n+        let node = node.borrowed();\n+        // TODO: Refactor to be have less repetition\n+        visitor()\n+            .visit(|node: ast::FnDef| {\n+                let mut string = \"fn \".to_string();\n+                node.name()?.syntax().text().push_to(&mut string);\n+                Some(string)\n+            })\n+            .visit(|node: ast::StructDef| {\n+                let mut string = \"struct \".to_string();\n+                node.name()?.syntax().text().push_to(&mut string);\n+                Some(string)\n+            })\n+            .visit(|node: ast::EnumDef| {\n+                let mut string = \"enum \".to_string();\n+                node.name()?.syntax().text().push_to(&mut string);\n+                Some(string)\n+            })\n+            .visit(|node: ast::TraitDef| {\n+                let mut string = \"trait \".to_string();\n+                node.name()?.syntax().text().push_to(&mut string);\n+                Some(string)\n+            })\n+            .visit(|node: ast::Module| {\n+                let mut string = \"mod \".to_string();\n+                node.name()?.syntax().text().push_to(&mut string);\n+                Some(string)\n+            })\n+            .visit(|node: ast::TypeDef| {\n+                let mut string = \"type \".to_string();\n+                node.name()?.syntax().text().push_to(&mut string);\n+                Some(string)\n+            })\n+            .visit(|node: ast::ConstDef| {\n+                let mut string = \"const \".to_string();\n+                node.name()?.syntax().text().push_to(&mut string);\n+                Some(string)\n+            })\n+            .visit(|node: ast::StaticDef| {\n+                let mut string = \"static \".to_string();\n+                node.name()?.syntax().text().push_to(&mut string);\n+                Some(string)\n+            })\n+            .accept(node)?\n+    }\n+}\n+\n #[cfg(test)]\n mod tests {\n     use ra_syntax::TextRange;"}, {"sha": "1e9129c4f7966a009cad7a89fc9d0ab04e2bccbe", "filename": "crates/ra_analysis/src/imp.rs", "status": "modified", "additions": 2, "deletions": 102, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/9f44d4c56d51fdae1ff073df261b8c897b27c824/crates%2Fra_analysis%2Fsrc%2Fimp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f44d4c56d51fdae1ff073df261b8c897b27c824/crates%2Fra_analysis%2Fsrc%2Fimp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fimp.rs?ref=9f44d4c56d51fdae1ff073df261b8c897b27c824", "patch": "@@ -8,11 +8,11 @@ use hir::{\n use ra_db::{FilesDatabase, SourceRoot, SourceRootId, SyntaxDatabase};\n use ra_editor::{self, find_node_at_offset, assists, LocalEdit, Severity};\n use ra_syntax::{\n-    algo::{find_covering_node, visit::{visitor, Visitor}},\n+    algo::find_covering_node,\n     ast::{self, ArgListOwner, Expr, FnDef, NameOwner},\n     AstNode, SourceFileNode,\n     SyntaxKind::*,\n-    SyntaxNode, SyntaxNodeRef, TextRange, TextUnit,\n+    SyntaxNodeRef, TextRange, TextUnit,\n };\n \n use crate::{\n@@ -256,18 +256,6 @@ impl db::RootDatabase {\n             Ok(Some((binding, descr)))\n         }\n     }\n-    pub(crate) fn doc_text_for(&self, nav: NavigationTarget) -> Cancelable<Option<String>> {\n-        let result = match (nav.description(self), nav.docs(self)) {\n-            (Some(desc), Some(docs)) => {\n-                Some(\"```rust\\n\".to_string() + &*desc + \"\\n```\\n\\n\" + &*docs)\n-            }\n-            (Some(desc), None) => Some(\"```rust\\n\".to_string() + &*desc + \"\\n```\"),\n-            (None, Some(docs)) => Some(docs),\n-            _ => None,\n-        };\n-\n-        Ok(result)\n-    }\n \n     pub(crate) fn diagnostics(&self, file_id: FileId) -> Cancelable<Vec<Diagnostic>> {\n         let syntax = self.source_file(file_id);\n@@ -506,91 +494,3 @@ impl<'a> FnCallNode<'a> {\n         }\n     }\n }\n-\n-impl NavigationTarget {\n-    fn node(&self, db: &db::RootDatabase) -> Option<SyntaxNode> {\n-        let source_file = db.source_file(self.file_id);\n-        let source_file = source_file.syntax();\n-        let node = source_file\n-            .descendants()\n-            .find(|node| node.kind() == self.kind && node.range() == self.range)?\n-            .owned();\n-        Some(node)\n-    }\n-\n-    fn docs(&self, db: &db::RootDatabase) -> Option<String> {\n-        let node = self.node(db)?;\n-        let node = node.borrowed();\n-        fn doc_comments<'a, N: ast::DocCommentsOwner<'a>>(node: N) -> Option<String> {\n-            let comments = node.doc_comment_text();\n-            if comments.is_empty() {\n-                None\n-            } else {\n-                Some(comments)\n-            }\n-        }\n-\n-        visitor()\n-            .visit(doc_comments::<ast::FnDef>)\n-            .visit(doc_comments::<ast::StructDef>)\n-            .visit(doc_comments::<ast::EnumDef>)\n-            .visit(doc_comments::<ast::TraitDef>)\n-            .visit(doc_comments::<ast::Module>)\n-            .visit(doc_comments::<ast::TypeDef>)\n-            .visit(doc_comments::<ast::ConstDef>)\n-            .visit(doc_comments::<ast::StaticDef>)\n-            .accept(node)?\n-    }\n-\n-    /// Get a description of this node.\n-    ///\n-    /// e.g. `struct Name`, `enum Name`, `fn Name`\n-    fn description(&self, db: &db::RootDatabase) -> Option<String> {\n-        // TODO: After type inference is done, add type information to improve the output\n-        let node = self.node(db)?;\n-        let node = node.borrowed();\n-        // TODO: Refactor to be have less repetition\n-        visitor()\n-            .visit(|node: ast::FnDef| {\n-                let mut string = \"fn \".to_string();\n-                node.name()?.syntax().text().push_to(&mut string);\n-                Some(string)\n-            })\n-            .visit(|node: ast::StructDef| {\n-                let mut string = \"struct \".to_string();\n-                node.name()?.syntax().text().push_to(&mut string);\n-                Some(string)\n-            })\n-            .visit(|node: ast::EnumDef| {\n-                let mut string = \"enum \".to_string();\n-                node.name()?.syntax().text().push_to(&mut string);\n-                Some(string)\n-            })\n-            .visit(|node: ast::TraitDef| {\n-                let mut string = \"trait \".to_string();\n-                node.name()?.syntax().text().push_to(&mut string);\n-                Some(string)\n-            })\n-            .visit(|node: ast::Module| {\n-                let mut string = \"mod \".to_string();\n-                node.name()?.syntax().text().push_to(&mut string);\n-                Some(string)\n-            })\n-            .visit(|node: ast::TypeDef| {\n-                let mut string = \"type \".to_string();\n-                node.name()?.syntax().text().push_to(&mut string);\n-                Some(string)\n-            })\n-            .visit(|node: ast::ConstDef| {\n-                let mut string = \"const \".to_string();\n-                node.name()?.syntax().text().push_to(&mut string);\n-                Some(string)\n-            })\n-            .visit(|node: ast::StaticDef| {\n-                let mut string = \"static \".to_string();\n-                node.name()?.syntax().text().push_to(&mut string);\n-                Some(string)\n-            })\n-            .accept(node)?\n-    }\n-}"}, {"sha": "0e32a15f807d274e6beb515b6ca62551c84faefa", "filename": "crates/ra_analysis/src/lib.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9f44d4c56d51fdae1ff073df261b8c897b27c824/crates%2Fra_analysis%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f44d4c56d51fdae1ff073df261b8c897b27c824/crates%2Fra_analysis%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Flib.rs?ref=9f44d4c56d51fdae1ff073df261b8c897b27c824", "patch": "@@ -403,10 +403,6 @@ impl Analysis {\n     pub fn find_all_refs(&self, position: FilePosition) -> Cancelable<Vec<(FileId, TextRange)>> {\n         self.db.find_all_refs(position)\n     }\n-    /// Returns documentation string for a given target.\n-    pub fn doc_text_for(&self, nav: NavigationTarget) -> Cancelable<Option<String>> {\n-        self.db.doc_text_for(nav)\n-    }\n     /// Returns a short text descrbing element at position.\n     pub fn hover(&self, position: FilePosition) -> Cancelable<Option<RangeInfo<String>>> {\n         hover::hover(&*self.db, position)"}]}