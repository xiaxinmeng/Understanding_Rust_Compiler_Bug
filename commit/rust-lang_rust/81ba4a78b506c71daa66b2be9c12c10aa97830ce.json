{"sha": "81ba4a78b506c71daa66b2be9c12c10aa97830ce", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgxYmE0YTc4YjUwNmM3MWRhYTY2YjJiZTljMTJjMTBhYTk3ODMwY2U=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2015-11-27T19:44:33Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2016-02-06T20:56:31Z"}, "message": "rustc: Add obj_is_bitcode to TargetOptions\n\nThis tells trans::back::write not to LLVM codegen to create .o\nfiles but to put LLMV bitcode in .o files.\n\nEmscripten's emcc supports .o in this format, and this is,\nI think, slightly easier than making rlibs work without .o\nfiles.", "tree": {"sha": "c99c5a5dd7c27c5f73bca0c27fe3e367a1875e13", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c99c5a5dd7c27c5f73bca0c27fe3e367a1875e13"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/81ba4a78b506c71daa66b2be9c12c10aa97830ce", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/81ba4a78b506c71daa66b2be9c12c10aa97830ce", "html_url": "https://github.com/rust-lang/rust/commit/81ba4a78b506c71daa66b2be9c12c10aa97830ce", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/81ba4a78b506c71daa66b2be9c12c10aa97830ce/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d6c0d859f6d859aa6e418b5ec58246071efbc9de", "url": "https://api.github.com/repos/rust-lang/rust/commits/d6c0d859f6d859aa6e418b5ec58246071efbc9de", "html_url": "https://github.com/rust-lang/rust/commit/d6c0d859f6d859aa6e418b5ec58246071efbc9de"}], "stats": {"total": 54, "additions": 44, "deletions": 10}, "files": [{"sha": "b25640c2791b16a8b5fd8aed252be9b72ff12057", "filename": "src/librustc_back/target/asmjs_unknown_emscripten.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/81ba4a78b506c71daa66b2be9c12c10aa97830ce/src%2Flibrustc_back%2Ftarget%2Fasmjs_unknown_emscripten.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81ba4a78b506c71daa66b2be9c12c10aa97830ce/src%2Flibrustc_back%2Ftarget%2Fasmjs_unknown_emscripten.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fasmjs_unknown_emscripten.rs?ref=81ba4a78b506c71daa66b2be9c12c10aa97830ce", "patch": "@@ -22,6 +22,7 @@ pub fn target() -> Target {\n         linker_is_gnu: true,\n         allow_asm: false,\n         archive_format: \"gnu\".to_string(),\n+        obj_is_bitcode: true,\n         .. Default::default()\n     };\n     Target {"}, {"sha": "de38b473b0bac1e194f1bec85ecc5010500b20d3", "filename": "src/librustc_back/target/mod.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/81ba4a78b506c71daa66b2be9c12c10aa97830ce/src%2Flibrustc_back%2Ftarget%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81ba4a78b506c71daa66b2be9c12c10aa97830ce/src%2Flibrustc_back%2Ftarget%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fmod.rs?ref=81ba4a78b506c71daa66b2be9c12c10aa97830ce", "patch": "@@ -204,6 +204,10 @@ pub struct TargetOptions {\n     /// Flag indicating whether ELF TLS (e.g. #[thread_local]) is available for\n     /// this target.\n     pub has_elf_tls: bool,\n+    // This is mainly for easy compatibility with emscripten.\n+    // If we give emcc .o files that are actually .bc files it\n+    // will 'just work'.\n+    pub obj_is_bitcode: bool,\n }\n \n impl Default for TargetOptions {\n@@ -251,6 +255,7 @@ impl Default for TargetOptions {\n             exe_allocation_crate: \"alloc_system\".to_string(),\n             allow_asm: true,\n             has_elf_tls: false,\n+            obj_is_bitcode: false,\n         }\n     }\n }"}, {"sha": "75d8e44989bf42f40601cb595f68c5d1cc866c29", "filename": "src/librustc_trans/back/write.rs", "status": "modified", "additions": 38, "deletions": 10, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/81ba4a78b506c71daa66b2be9c12c10aa97830ce/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81ba4a78b506c71daa66b2be9c12c10aa97830ce/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fwrite.rs?ref=81ba4a78b506c71daa66b2be9c12c10aa97830ce", "patch": "@@ -244,7 +244,6 @@ pub struct ModuleConfig {\n     emit_ir: bool,\n     emit_asm: bool,\n     emit_obj: bool,\n-\n     // Miscellaneous flags.  These are mostly copied from command-line\n     // options.\n     no_verify: bool,\n@@ -254,7 +253,11 @@ pub struct ModuleConfig {\n     vectorize_loop: bool,\n     vectorize_slp: bool,\n     merge_functions: bool,\n-    inline_threshold: Option<usize>\n+    inline_threshold: Option<usize>,\n+    // Instead of creating an object file by doing LLVM codegen, just\n+    // make the object file bitcode. Provides easy compatibility with\n+    // emscripten's ecc compiler, when used as the linker.\n+    obj_is_bitcode: bool,\n }\n \n unsafe impl Send for ModuleConfig { }\n@@ -272,6 +275,7 @@ impl ModuleConfig {\n             emit_ir: false,\n             emit_asm: false,\n             emit_obj: false,\n+            obj_is_bitcode: false,\n \n             no_verify: false,\n             no_prepopulate_passes: false,\n@@ -290,6 +294,7 @@ impl ModuleConfig {\n         self.no_builtins = trans.no_builtins;\n         self.time_passes = sess.time_passes();\n         self.inline_threshold = sess.opts.cg.inline_threshold;\n+        self.obj_is_bitcode = sess.target.target.options.obj_is_bitcode;\n \n         // Copy what clang does by turning on loop vectorization at O2 and\n         // slp vectorization at O3. Otherwise configure other optimization aspects\n@@ -530,11 +535,21 @@ unsafe fn optimize_and_codegen(cgcx: &CodegenContext,\n         f(cpm);\n     }\n \n-    if config.emit_bc {\n-        let ext = format!(\"{}.bc\", name_extra);\n-        let out = output_names.with_extension(&ext);\n-        let out = path2cstr(&out);\n-        llvm::LLVMWriteBitcodeToFile(llmod, out.as_ptr());\n+    // Change what we write and cleanup based on whether obj files are\n+    // just llvm bitcode. In that case write bitcode, and possibly\n+    // delete the bitcode if it wasn't requested. Don't generate the\n+    // machine code, instead copy the .o file from the .bc\n+    let write_bc = config.emit_bc || config.obj_is_bitcode;\n+    let rm_bc = !config.emit_bc && config.obj_is_bitcode;\n+    let write_obj = config.emit_obj && !config.obj_is_bitcode;\n+    let copy_bc_to_obj = config.emit_obj && config.obj_is_bitcode;\n+\n+    let bc_out = output_names.with_extension(&format!(\"{}.bc\", name_extra));\n+    let obj_out = output_names.with_extension(&format!(\"{}.o\", name_extra));\n+\n+    if write_bc {\n+        let bc_out_c = path2cstr(&bc_out);\n+        llvm::LLVMWriteBitcodeToFile(llmod, bc_out_c.as_ptr());\n     }\n \n     time(config.time_passes, &format!(\"codegen passes [{}]\", cgcx.worker), || {\n@@ -568,14 +583,27 @@ unsafe fn optimize_and_codegen(cgcx: &CodegenContext,\n             }\n         }\n \n-        if config.emit_obj {\n-            let path = output_names.with_extension(&format!(\"{}.o\", name_extra));\n+        if write_obj {\n             with_codegen(tm, llmod, config.no_builtins, |cpm| {\n-                write_output_file(cgcx.handler, tm, cpm, llmod, &path, llvm::ObjectFileType);\n+                write_output_file(cgcx.handler, tm, cpm, llmod, &obj_out, llvm::ObjectFileType);\n             });\n         }\n     });\n \n+    if copy_bc_to_obj {\n+        debug!(\"copying bitcode {:?} to obj {:?}\", bc_out, obj_out);\n+        if let Err(e) = fs::copy(&bc_out, &obj_out) {\n+            cgcx.handler.err(&format!(\"failed to copy bitcode to object file: {}\", e));\n+        }\n+    }\n+\n+    if rm_bc {\n+        debug!(\"removing_bitcode {:?}\", bc_out);\n+        if let Err(e) = fs::remove_file(&bc_out) {\n+            cgcx.handler.err(&format!(\"failed to remove bitcode: {}\", e));\n+        }\n+    }\n+\n     llvm::LLVMDisposeModule(llmod);\n     llvm::LLVMContextDispose(llcx);\n     llvm::LLVMRustDisposeTargetMachine(tm);"}]}