{"sha": "0d53f699eaa7d1fec1e6013a6a42b39992c119d3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBkNTNmNjk5ZWFhN2QxZmVjMWU2MDEzYTZhNDJiMzk5OTJjMTE5ZDM=", "commit": {"author": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2019-08-08T19:32:18Z"}, "committer": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2019-08-09T14:18:05Z"}, "message": "review comments", "tree": {"sha": "cdb670d5ca880b886027714ffd6777d5e61107d1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cdb670d5ca880b886027714ffd6777d5e61107d1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0d53f699eaa7d1fec1e6013a6a42b39992c119d3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0d53f699eaa7d1fec1e6013a6a42b39992c119d3", "html_url": "https://github.com/rust-lang/rust/commit/0d53f699eaa7d1fec1e6013a6a42b39992c119d3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0d53f699eaa7d1fec1e6013a6a42b39992c119d3/comments", "author": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "committer": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b7f7756566c9e10983ee51bc97afe9852838299a", "url": "https://api.github.com/repos/rust-lang/rust/commits/b7f7756566c9e10983ee51bc97afe9852838299a", "html_url": "https://github.com/rust-lang/rust/commit/b7f7756566c9e10983ee51bc97afe9852838299a"}], "stats": {"total": 102, "additions": 56, "deletions": 46}, "files": [{"sha": "9680f61d6990314f9a4424e80c0c543204931074", "filename": "src/librustc_typeck/check/expr.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/0d53f699eaa7d1fec1e6013a6a42b39992c119d3/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d53f699eaa7d1fec1e6013a6a42b39992c119d3/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs?ref=0d53f699eaa7d1fec1e6013a6a42b39992c119d3", "patch": "@@ -550,18 +550,19 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     assert!(e_ty.is_unit());\n                     let ty = coerce.expected_ty();\n                     coerce.coerce_forced_unit(self, &cause, &mut |err| {\n-                        let msg = \"give it a value of the expected type\";\n-                        let label = destination.label\n-                            .map(|l| format!(\" {}\", l.ident))\n-                            .unwrap_or_else(String::new);\n-                        let sugg = format!(\"break{} {}\", label, match ty.sty {\n+                        let val = match ty.sty {\n                             ty::Bool => \"true\",\n                             ty::Char => \"'a'\",\n                             ty::Int(_) | ty::Uint(_) => \"42\",\n                             ty::Float(_) => \"3.14159\",\n                             ty::Error | ty::Never => return,\n                             _ => \"value\",\n-                        });\n+                        };\n+                        let msg = \"give it a value of the expected type\";\n+                        let label = destination.label\n+                            .map(|l| format!(\" {}\", l.ident))\n+                            .unwrap_or_else(String::new);\n+                        let sugg = format!(\"break{} {}\", label, val);\n                         err.span_suggestion(expr.span, msg, sugg, Applicability::HasPlaceholders);\n                     }, false);\n                 }"}, {"sha": "be2af2db66d595aa1d1db91138517c995959206b", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 49, "deletions": 40, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/0d53f699eaa7d1fec1e6013a6a42b39992c119d3/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d53f699eaa7d1fec1e6013a6a42b39992c119d3/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=0d53f699eaa7d1fec1e6013a6a42b39992c119d3", "patch": "@@ -3819,55 +3819,64 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         pointing_at_return_type\n     }\n \n+    /// When encountering an fn-like ctor that needs to unify with a value, check whether calling\n+    /// the ctor would successfully solve the type mismatch and if so, suggest it:\n+    /// ```\n+    /// fn foo(x: usize) -> usize { x }\n+    /// let x: usize = foo;  // suggest calling the `foo` function: `foo(42)`\n+    /// ```\n     fn suggest_fn_call(\n         &self,\n         err: &mut DiagnosticBuilder<'tcx>,\n         expr: &hir::Expr,\n         expected: Ty<'tcx>,\n         found: Ty<'tcx>,\n     ) -> bool {\n-        if let ty::FnDef(..) | ty::FnPtr(_) = &found.sty {\n-            let sig = found.fn_sig(self.tcx);\n-            let sig = self\n-                .replace_bound_vars_with_fresh_vars(expr.span, infer::FnCall, &sig)\n-                .0;\n-            let sig = self.normalize_associated_types_in(expr.span, &sig);\n-            if let Ok(_) = self.try_coerce(expr, sig.output(), expected, AllowTwoPhase::No) {\n-                let (mut sugg_call, applicability) = if sig.inputs().is_empty() {\n-                    (String::new(), Applicability::MachineApplicable)\n-                } else {\n-                    (\"...\".to_owned(), Applicability::HasPlaceholders)\n-                };\n-                let mut msg = \"call this function\";\n-                if let ty::FnDef(def_id, ..) = found.sty {\n-                    match self.tcx.hir().get_if_local(def_id) {\n-                        Some(Node::Item(hir::Item {\n-                            node: ItemKind::Fn(.., body_id),\n-                            ..\n-                        })) => {\n-                            let body = self.tcx.hir().body(*body_id);\n-                            sugg_call = body.arguments.iter()\n-                                .map(|arg| hir::print::to_string(\n-                                    hir::print::NO_ANN,\n-                                    |s| s.print_pat(&arg.pat),\n-                                )).collect::<Vec<_>>().join(\", \");\n-                        }\n-                        Some(Node::Ctor(hir::VariantData::Tuple(field, _))) => {\n-                            sugg_call = field.iter().map(|_| \"_\").collect::<Vec<_>>().join(\", \");\n-                            msg = \"instatiate this tuple struct\";\n-                        }\n-                        _ => {}\n+        match found.sty {\n+            ty::FnDef(..) | ty::FnPtr(_) => {}\n+            _ => return false,\n+        }\n+\n+        let sig = found.fn_sig(self.tcx);\n+        let sig = self\n+            .replace_bound_vars_with_fresh_vars(expr.span, infer::FnCall, &sig)\n+            .0;\n+        let sig = self.normalize_associated_types_in(expr.span, &sig);\n+        if let Ok(_) = self.try_coerce(expr, sig.output(), expected, AllowTwoPhase::No) {\n+            let (mut sugg_call, applicability) = if sig.inputs().is_empty() {\n+                (String::new(), Applicability::MachineApplicable)\n+            } else {\n+                (\"...\".to_owned(), Applicability::HasPlaceholders)\n+            };\n+            let mut msg = \"call this function\";\n+            if let ty::FnDef(def_id, ..) = found.sty {\n+                match self.tcx.hir().get_if_local(def_id) {\n+                    Some(Node::Item(hir::Item {\n+                        node: ItemKind::Fn(.., body_id),\n+                        ..\n+                    })) => {\n+                        let body = self.tcx.hir().body(*body_id);\n+                        sugg_call = body.arguments.iter()\n+                            .map(|arg| hir::print::to_string(\n+                                hir::print::NO_ANN,\n+                                |s| s.print_pat(&arg.pat),\n+                            )).collect::<Vec<_>>().join(\", \");\n                     }\n-                };\n-                if let Ok(code) = self.sess().source_map().span_to_snippet(expr.span) {\n-                    err.span_suggestion(\n-                        expr.span,\n-                        &format!(\"use parentheses to {}\", msg),\n-                        format!(\"{}({})\", code, sugg_call),\n-                        applicability,\n-                    );\n-                    return true;\n+                    Some(Node::Ctor(hir::VariantData::Tuple(field, _))) => {\n+                        sugg_call = field.iter().map(|_| \"_\").collect::<Vec<_>>().join(\", \");\n+                        msg = \"instatiate this tuple struct\";\n+                    }\n+                    _ => {}\n                 }\n+            };\n+            if let Ok(code) = self.sess().source_map().span_to_snippet(expr.span) {\n+                err.span_suggestion(\n+                    expr.span,\n+                    &format!(\"use parentheses to {}\", msg),\n+                    format!(\"{}({})\", code, sugg_call),\n+                    applicability,\n+                );\n+                return true;\n             }\n         }\n         false"}]}