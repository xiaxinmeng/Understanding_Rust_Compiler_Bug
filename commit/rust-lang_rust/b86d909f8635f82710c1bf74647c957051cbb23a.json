{"sha": "b86d909f8635f82710c1bf74647c957051cbb23a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI4NmQ5MDlmODYzNWY4MjcxMGMxYmY3NDY0N2M5NTcwNTFjYmIyM2E=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-05-24T23:10:18Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-05-24T23:10:18Z"}, "message": "Auto merge of #50937 - nikomatsakis:chalkify-engine-2, r=scalexm\n\nimplement the chalk-engine traits\n\nPreliminary implementation for the Chalk traits in rustc. Lots of `panic!()` placeholders to be filled in later.\n\nThis is currently blocked on us landing https://github.com/rust-lang-nursery/chalk/pull/131  in chalk and issuing a new release, which should occur later today.\n\nr? @scalexm\ncc @leodasvacas", "tree": {"sha": "2f1b54487f583610b04d9029be819df0ff76f38d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2f1b54487f583610b04d9029be819df0ff76f38d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b86d909f8635f82710c1bf74647c957051cbb23a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b86d909f8635f82710c1bf74647c957051cbb23a", "html_url": "https://github.com/rust-lang/rust/commit/b86d909f8635f82710c1bf74647c957051cbb23a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b86d909f8635f82710c1bf74647c957051cbb23a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c2d46037fa6617408155dcba6251d7c4e123b4f5", "url": "https://api.github.com/repos/rust-lang/rust/commits/c2d46037fa6617408155dcba6251d7c4e123b4f5", "html_url": "https://github.com/rust-lang/rust/commit/c2d46037fa6617408155dcba6251d7c4e123b4f5"}, {"sha": "8fd316f5b560d926333f0c7cd832c179f430ea27", "url": "https://api.github.com/repos/rust-lang/rust/commits/8fd316f5b560d926333f0c7cd832c179f430ea27", "html_url": "https://github.com/rust-lang/rust/commit/8fd316f5b560d926333f0c7cd832c179f430ea27"}], "stats": {"total": 1174, "additions": 934, "deletions": 240}, "files": [{"sha": "40ec413c90a234b695d8aea88f2c8ee89fbedc4d", "filename": "src/Cargo.lock", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/b86d909f8635f82710c1bf74647c957051cbb23a/src%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/b86d909f8635f82710c1bf74647c957051cbb23a/src%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FCargo.lock?ref=b86d909f8635f82710c1bf74647c957051cbb23a", "patch": "@@ -261,6 +261,23 @@ name = \"cfg-if\"\n version = \"0.1.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n+[[package]]\n+name = \"chalk-engine\"\n+version = \"0.6.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"chalk-macros 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-hash 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n+[[package]]\n+name = \"chalk-macros\"\n+version = \"0.1.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"lazy_static 0.2.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n [[package]]\n name = \"chrono\"\n version = \"0.4.1\"\n@@ -1739,6 +1756,7 @@ dependencies = [\n  \"backtrace 0.3.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"bitflags 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"byteorder 1.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"chalk-engine 0.6.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"flate2 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"fmt_macros 0.0.0\",\n  \"graphviz 0.0.0\",\n@@ -1840,6 +1858,11 @@ name = \"rustc-demangle\"\n version = \"0.1.7\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n+[[package]]\n+name = \"rustc-hash\"\n+version = \"1.0.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+\n [[package]]\n name = \"rustc-main\"\n version = \"0.0.0\"\n@@ -1982,6 +2005,7 @@ dependencies = [\n  \"log 0.4.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"parking_lot 0.5.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"parking_lot_core 0.2.14 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-hash 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc-rayon 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc_cratesio_shim 0.0.0\",\n  \"serialize 0.0.0\",\n@@ -2216,6 +2240,7 @@ name = \"rustc_traits\"\n version = \"0.0.0\"\n dependencies = [\n  \"bitflags 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"chalk-engine 0.6.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"graphviz 0.0.0\",\n  \"log 0.4.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc 0.0.0\",\n@@ -2998,6 +3023,8 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum cargo_metadata 0.5.4 (registry+https://github.com/rust-lang/crates.io-index)\" = \"6ebd6272a2ca4fd39dbabbd6611eb03df45c2259b3b80b39a9ff8fbdcf42a4b3\"\n \"checksum cc 1.0.15 (registry+https://github.com/rust-lang/crates.io-index)\" = \"0ebb87d1116151416c0cf66a0e3fb6430cccd120fd6300794b4dfaa050ac40ba\"\n \"checksum cfg-if 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"d4c819a1287eb618df47cc647173c5c4c66ba19d888a6e50d605672aed3140de\"\n+\"checksum chalk-engine 0.6.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"a146c19172c7eea48ea55a7123ac95da786639bc665097f1e14034ee5f1d8699\"\n+\"checksum chalk-macros 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"295635afd6853aa9f20baeb7f0204862440c0fe994c5a253d5f479dac41d047e\"\n \"checksum chrono 0.4.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ba5f60682a4c264e7f8d77b82e7788938a76befdf949d4a98026d19099c9d873\"\n \"checksum clap 2.31.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"f0f16b89cbb9ee36d87483dc939fe9f1e13c05898d56d7b230a0d4dff033a536\"\n \"checksum clippy_lints 0.0.200 (registry+https://github.com/rust-lang/crates.io-index)\" = \"d2432663f6bdb90255dcf9df5ca504f99b575bb471281591138f62f9d31f863b\"\n@@ -3142,6 +3169,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum rustc-ap-syntax 128.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"dcf9ca2901388714e9ccc7de7281ef06cec55d9f245252ba1d635bc86c730d9a\"\n \"checksum rustc-ap-syntax_pos 128.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"e5217444369a36e98e11f4ac976f03878704893832e2e0b57d49f2f31438139f\"\n \"checksum rustc-demangle 0.1.7 (registry+https://github.com/rust-lang/crates.io-index)\" = \"11fb43a206a04116ffd7cfcf9bcb941f8eb6cc7ff667272246b0a1c74259a3cb\"\n+\"checksum rustc-hash 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"e06ddba37baa245040f932b15403071a46681d7e0e4158e230741943c4718b84\"\n \"checksum rustc-rayon 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"b1aa5cd8c3a706edb19b6ec6aa7b056bdc635b6e99c5cf7014f9af9d92f15e99\"\n \"checksum rustc-rayon-core 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"d69983f8613a9c3ba1a3bbf5e8bdf2fd5c42317b1d8dd8623ca8030173bf8a6b\"\n \"checksum rustc-serialize 0.3.24 (registry+https://github.com/rust-lang/crates.io-index)\" = \"dcf128d1287d2ea9d80910b5f1120d0b8eede3fbf1abe91c40d39ea7d51e6fda\""}, {"sha": "42eccaec9d0820ae02ec30219f2d0968709464c4", "filename": "src/librustc/Cargo.toml", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b86d909f8635f82710c1bf74647c957051cbb23a/src%2Flibrustc%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/b86d909f8635f82710c1bf74647c957051cbb23a/src%2Flibrustc%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2FCargo.toml?ref=b86d909f8635f82710c1bf74647c957051cbb23a", "patch": "@@ -26,6 +26,7 @@ syntax = { path = \"../libsyntax\" }\n syntax_pos = { path = \"../libsyntax_pos\" }\n backtrace = \"0.3.3\"\n byteorder = { version = \"1.1\", features = [\"i128\"]}\n+chalk-engine = { version = \"0.6.0\", default-features=false }\n \n # Note that these dependencies are a lie, they're just here to get linkage to\n # work.\n@@ -56,3 +57,5 @@ byteorder = { version = \"1.1\", features = [\"i128\"]}\n #        compiles, then please feel free to do so!\n flate2 = \"1.0\"\n tempdir = \"0.3\"\n+\n+"}, {"sha": "c67f09c88bdc55554494664807c93be99037597b", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b86d909f8635f82710c1bf74647c957051cbb23a/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b86d909f8635f82710c1bf74647c957051cbb23a/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=b86d909f8635f82710c1bf74647c957051cbb23a", "patch": "@@ -89,6 +89,7 @@ extern crate rustc_errors as errors;\n extern crate syntax_pos;\n extern crate jobserver;\n extern crate proc_macro;\n+extern crate chalk_engine;\n \n extern crate serialize as rustc_serialize; // used by deriving\n "}, {"sha": "4178fdb352d514c87bc01dcae1cf546cd7131f3e", "filename": "src/librustc/macros.rs", "status": "modified", "additions": 36, "deletions": 9, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/b86d909f8635f82710c1bf74647c957051cbb23a/src%2Flibrustc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b86d909f8635f82710c1bf74647c957051cbb23a/src%2Flibrustc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmacros.rs?ref=b86d909f8635f82710c1bf74647c957051cbb23a", "patch": "@@ -250,25 +250,52 @@ macro_rules! BraceStructLiftImpl {\n macro_rules! EnumLiftImpl {\n     (impl<$($p:tt),*> Lift<$tcx:tt> for $s:path {\n         type Lifted = $lifted:ty;\n-        $(\n-            ($variant:path) ( $( $variant_arg:ident),* )\n-        ),*\n-        $(,)*\n+        $($variants:tt)*\n     } $(where $($wc:tt)*)*) => {\n         impl<$($p),*> $crate::ty::Lift<$tcx> for $s\n             $(where $($wc)*)*\n         {\n             type Lifted = $lifted;\n \n             fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<$lifted> {\n-                match self {\n-                    $($variant ( $($variant_arg),* ) => {\n-                        Some($variant ( $(tcx.lift($variant_arg)?),* ))\n-                    })*\n-                }\n+                EnumLiftImpl!(@Variants(self, tcx) input($($variants)*) output())\n             }\n         }\n     };\n+\n+    (@Variants($this:expr, $tcx:expr) input() output($($output:tt)*)) => {\n+        match $this {\n+            $($output)*\n+        }\n+    };\n+\n+    (@Variants($this:expr, $tcx:expr)\n+     input( ($variant:path) ( $($variant_arg:ident),* ) , $($input:tt)*)\n+     output( $($output:tt)*) ) => {\n+        EnumLiftImpl!(\n+            @Variants($this, $tcx)\n+                input($($input)*)\n+                output(\n+                    $variant ( $($variant_arg),* ) => {\n+                        Some($variant ( $($tcx.lift($variant_arg)?),* ))\n+                    }\n+                    $($output)*\n+                )\n+        )\n+    };\n+\n+    (@Variants($this:expr, $tcx:expr)\n+     input( ($variant:path), $($input:tt)*)\n+     output( $($output:tt)*) ) => {\n+        EnumLiftImpl!(\n+            @Variants($this, $tcx)\n+                input($($input)*)\n+                output(\n+                    $variant => { Some($variant) }\n+                    $($output)*\n+                )\n+        )\n+    };\n }\n \n #[macro_export]"}, {"sha": "3bd4e11b0e8b9708abd8324bc970cc3d69c86045", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 61, "deletions": 1, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/b86d909f8635f82710c1bf74647c957051cbb23a/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b86d909f8635f82710c1bf74647c957051cbb23a/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=b86d909f8635f82710c1bf74647c957051cbb23a", "patch": "@@ -17,17 +17,21 @@ pub use self::FulfillmentErrorCode::*;\n pub use self::Vtable::*;\n pub use self::ObligationCauseCode::*;\n \n+use chalk_engine;\n use hir;\n use hir::def_id::DefId;\n use infer::outlives::env::OutlivesEnvironment;\n use middle::region;\n use middle::const_val::ConstEvalErr;\n use ty::subst::Substs;\n-use ty::{self, AdtKind, Slice, Ty, TyCtxt, GenericParamDefKind, TypeFoldable, ToPredicate};\n+use ty::{self, AdtKind, Slice, Ty, TyCtxt, GenericParamDefKind, ToPredicate};\n use ty::error::{ExpectedFound, TypeError};\n+use ty::fold::{TypeFolder, TypeFoldable, TypeVisitor};\n+use infer::canonical::{Canonical, Canonicalize};\n use infer::{InferCtxt};\n \n use rustc_data_structures::sync::Lrc;\n+use std::fmt::Debug;\n use std::rc::Rc;\n use syntax::ast;\n use syntax_pos::{Span, DUMMY_SP};\n@@ -1003,3 +1007,59 @@ pub fn provide(providers: &mut ty::maps::Providers) {\n         ..*providers\n     };\n }\n+\n+impl<'gcx: 'tcx, 'tcx> Canonicalize<'gcx, 'tcx> for ty::ParamEnvAnd<'tcx, Goal<'tcx>> {\n+    // we ought to intern this, but I'm too lazy just now\n+    type Canonicalized = Canonical<'gcx, ty::ParamEnvAnd<'gcx, Goal<'gcx>>>;\n+\n+    fn intern(\n+        _gcx: TyCtxt<'_, 'gcx, 'gcx>,\n+        value: Canonical<'gcx, Self::Lifted>,\n+    ) -> Self::Canonicalized {\n+        value\n+    }\n+}\n+\n+pub trait ExClauseFold<'tcx>\n+where\n+    Self: chalk_engine::context::Context + Clone,\n+{\n+    fn fold_ex_clause_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(\n+        ex_clause: &chalk_engine::ExClause<Self>,\n+        folder: &mut F,\n+    ) -> chalk_engine::ExClause<Self>;\n+\n+    fn visit_ex_clause_with<'gcx: 'tcx, V: TypeVisitor<'tcx>>(\n+        ex_clause: &chalk_engine::ExClause<Self>,\n+        visitor: &mut V,\n+    ) -> bool;\n+}\n+\n+pub trait ExClauseLift<'tcx>\n+where\n+    Self: chalk_engine::context::Context + Clone,\n+{\n+    type LiftedExClause: Debug + 'tcx;\n+\n+    fn lift_ex_clause_to_tcx<'a, 'gcx>(\n+        ex_clause: &chalk_engine::ExClause<Self>,\n+        tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+    ) -> Option<Self::LiftedExClause>;\n+}\n+\n+impl<'gcx: 'tcx, 'tcx, C> Canonicalize<'gcx, 'tcx> for chalk_engine::ExClause<C>\n+where\n+    C: chalk_engine::context::Context + Clone,\n+    C: ExClauseLift<'gcx> + ExClauseFold<'tcx>,\n+    C::Substitution: Clone,\n+    C::RegionConstraint: Clone,\n+{\n+    type Canonicalized = Canonical<'gcx, C::LiftedExClause>;\n+\n+    fn intern(\n+        _gcx: TyCtxt<'_, 'gcx, 'gcx>,\n+        value: Canonical<'gcx, Self::Lifted>,\n+    ) -> Self::Canonicalized {\n+        value\n+    }\n+}"}, {"sha": "d1304a0a3f8871483a6f6c1546a9acd945010a5e", "filename": "src/librustc/traits/structural_impls.rs", "status": "modified", "additions": 214, "deletions": 144, "changes": 358, "blob_url": "https://github.com/rust-lang/rust/blob/b86d909f8635f82710c1bf74647c957051cbb23a/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b86d909f8635f82710c1bf74647c957051cbb23a/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs?ref=b86d909f8635f82710c1bf74647c957051cbb23a", "patch": "@@ -8,11 +8,12 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use chalk_engine;\n use rustc_data_structures::accumulate_vec::AccumulateVec;\n use traits;\n use traits::project::Normalized;\n-use ty::{self, Lift, TyCtxt};\n use ty::fold::{TypeFoldable, TypeFolder, TypeVisitor};\n+use ty::{self, Lift, TyCtxt};\n \n use std::fmt;\n use std::rc::Rc;\n@@ -21,81 +22,77 @@ use std::rc::Rc;\n \n impl<'tcx, T: fmt::Debug> fmt::Debug for Normalized<'tcx, T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"Normalized({:?},{:?})\",\n-               self.value,\n-               self.obligations)\n+        write!(f, \"Normalized({:?},{:?})\", self.value, self.obligations)\n     }\n }\n \n impl<'tcx, O: fmt::Debug> fmt::Debug for traits::Obligation<'tcx, O> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         if ty::tls::with(|tcx| tcx.sess.verbose()) {\n-            write!(f, \"Obligation(predicate={:?},cause={:?},depth={})\",\n-                   self.predicate,\n-                   self.cause,\n-                   self.recursion_depth)\n+            write!(\n+                f,\n+                \"Obligation(predicate={:?},cause={:?},depth={})\",\n+                self.predicate, self.cause, self.recursion_depth\n+            )\n         } else {\n-            write!(f, \"Obligation(predicate={:?},depth={})\",\n-                   self.predicate,\n-                   self.recursion_depth)\n+            write!(\n+                f,\n+                \"Obligation(predicate={:?},depth={})\",\n+                self.predicate, self.recursion_depth\n+            )\n         }\n     }\n }\n \n impl<'tcx, N: fmt::Debug> fmt::Debug for traits::Vtable<'tcx, N> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match *self {\n-            super::VtableImpl(ref v) =>\n-                write!(f, \"{:?}\", v),\n+            super::VtableImpl(ref v) => write!(f, \"{:?}\", v),\n \n-            super::VtableAutoImpl(ref t) =>\n-                write!(f, \"{:?}\", t),\n+            super::VtableAutoImpl(ref t) => write!(f, \"{:?}\", t),\n \n-            super::VtableClosure(ref d) =>\n-                write!(f, \"{:?}\", d),\n+            super::VtableClosure(ref d) => write!(f, \"{:?}\", d),\n \n-            super::VtableGenerator(ref d) =>\n-                write!(f, \"{:?}\", d),\n+            super::VtableGenerator(ref d) => write!(f, \"{:?}\", d),\n \n-            super::VtableFnPointer(ref d) =>\n-                write!(f, \"VtableFnPointer({:?})\", d),\n+            super::VtableFnPointer(ref d) => write!(f, \"VtableFnPointer({:?})\", d),\n \n-            super::VtableObject(ref d) =>\n-                write!(f, \"{:?}\", d),\n+            super::VtableObject(ref d) => write!(f, \"{:?}\", d),\n \n-            super::VtableParam(ref n) =>\n-                write!(f, \"VtableParam({:?})\", n),\n+            super::VtableParam(ref n) => write!(f, \"VtableParam({:?})\", n),\n \n-            super::VtableBuiltin(ref d) =>\n-                write!(f, \"{:?}\", d)\n+            super::VtableBuiltin(ref d) => write!(f, \"{:?}\", d),\n         }\n     }\n }\n \n impl<'tcx, N: fmt::Debug> fmt::Debug for traits::VtableImplData<'tcx, N> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"VtableImpl(impl_def_id={:?}, substs={:?}, nested={:?})\",\n-               self.impl_def_id,\n-               self.substs,\n-               self.nested)\n+        write!(\n+            f,\n+            \"VtableImpl(impl_def_id={:?}, substs={:?}, nested={:?})\",\n+            self.impl_def_id, self.substs, self.nested\n+        )\n     }\n }\n \n impl<'tcx, N: fmt::Debug> fmt::Debug for traits::VtableGeneratorData<'tcx, N> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"VtableGenerator(generator_def_id={:?}, substs={:?}, nested={:?})\",\n-               self.generator_def_id,\n-               self.substs,\n-               self.nested)\n+        write!(\n+            f,\n+            \"VtableGenerator(generator_def_id={:?}, substs={:?}, nested={:?})\",\n+            self.generator_def_id, self.substs, self.nested\n+        )\n     }\n }\n \n impl<'tcx, N: fmt::Debug> fmt::Debug for traits::VtableClosureData<'tcx, N> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"VtableClosure(closure_def_id={:?}, substs={:?}, nested={:?})\",\n-               self.closure_def_id,\n-               self.substs,\n-               self.nested)\n+        write!(\n+            f,\n+            \"VtableClosure(closure_def_id={:?}, substs={:?}, nested={:?})\",\n+            self.closure_def_id, self.substs, self.nested\n+        )\n     }\n }\n \n@@ -107,34 +104,37 @@ impl<'tcx, N: fmt::Debug> fmt::Debug for traits::VtableBuiltinData<N> {\n \n impl<'tcx, N: fmt::Debug> fmt::Debug for traits::VtableAutoImplData<N> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"VtableAutoImplData(trait_def_id={:?}, nested={:?})\",\n-               self.trait_def_id,\n-               self.nested)\n+        write!(\n+            f,\n+            \"VtableAutoImplData(trait_def_id={:?}, nested={:?})\",\n+            self.trait_def_id, self.nested\n+        )\n     }\n }\n \n impl<'tcx, N: fmt::Debug> fmt::Debug for traits::VtableObjectData<'tcx, N> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"VtableObject(upcast={:?}, vtable_base={}, nested={:?})\",\n-               self.upcast_trait_ref,\n-               self.vtable_base,\n-               self.nested)\n+        write!(\n+            f,\n+            \"VtableObject(upcast={:?}, vtable_base={}, nested={:?})\",\n+            self.upcast_trait_ref, self.vtable_base, self.nested\n+        )\n     }\n }\n \n impl<'tcx, N: fmt::Debug> fmt::Debug for traits::VtableFnPointerData<'tcx, N> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"VtableFnPointer(fn_ty={:?}, nested={:?})\",\n-               self.fn_ty,\n-               self.nested)\n+        write!(\n+            f,\n+            \"VtableFnPointer(fn_ty={:?}, nested={:?})\",\n+            self.fn_ty, self.nested\n+        )\n     }\n }\n \n impl<'tcx> fmt::Debug for traits::FulfillmentError<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"FulfillmentError({:?},{:?})\",\n-               self.obligation,\n-               self.code)\n+        write!(f, \"FulfillmentError({:?},{:?})\", self.obligation, self.code)\n     }\n }\n \n@@ -143,9 +143,10 @@ impl<'tcx> fmt::Debug for traits::FulfillmentErrorCode<'tcx> {\n         match *self {\n             super::CodeSelectionError(ref e) => write!(f, \"{:?}\", e),\n             super::CodeProjectionError(ref e) => write!(f, \"{:?}\", e),\n-            super::CodeSubtypeError(ref a, ref b) =>\n-                write!(f, \"CodeSubtypeError({:?}, {:?})\", a, b),\n-            super::CodeAmbiguity => write!(f, \"Ambiguity\")\n+            super::CodeSubtypeError(ref a, ref b) => {\n+                write!(f, \"CodeSubtypeError({:?}, {:?})\", a, b)\n+            }\n+            super::CodeAmbiguity => write!(f, \"Ambiguity\"),\n         }\n     }\n }\n@@ -166,18 +167,13 @@ impl<'a, 'tcx> Lift<'tcx> for traits::SelectionError<'a> {\n             super::Unimplemented => Some(super::Unimplemented),\n             super::OutputTypeParameterMismatch(a, b, ref err) => {\n                 tcx.lift(&(a, b)).and_then(|(a, b)| {\n-                    tcx.lift(err).map(|err| {\n-                        super::OutputTypeParameterMismatch(a, b, err)\n-                    })\n+                    tcx.lift(err)\n+                        .map(|err| super::OutputTypeParameterMismatch(a, b, err))\n                 })\n             }\n-            super::TraitNotObjectSafe(def_id) => {\n-                Some(super::TraitNotObjectSafe(def_id))\n-            }\n-            super::ConstEvalFailure(ref err) => {\n-                tcx.lift(err).map(super::ConstEvalFailure)\n-            }\n-            super::Overflow => bug!() // FIXME: ape ConstEvalFailure?\n+            super::TraitNotObjectSafe(def_id) => Some(super::TraitNotObjectSafe(def_id)),\n+            super::ConstEvalFailure(ref err) => tcx.lift(err).map(super::ConstEvalFailure),\n+            super::Overflow => bug!(), // FIXME: ape ConstEvalFailure?\n         }\n     }\n }\n@@ -195,16 +191,11 @@ impl<'a, 'tcx> Lift<'tcx> for traits::ObligationCauseCode<'a> {\n             super::ReferenceOutlivesReferent(ty) => {\n                 tcx.lift(&ty).map(super::ReferenceOutlivesReferent)\n             }\n-            super::ObjectTypeBound(ty, r) => {\n-                tcx.lift(&ty).and_then(|ty| {\n-                    tcx.lift(&r).and_then(|r| {\n-                        Some(super::ObjectTypeBound(ty, r))\n-                    })\n-                })\n-            }\n-            super::ObjectCastObligation(ty) => {\n-                tcx.lift(&ty).map(super::ObjectCastObligation)\n-            }\n+            super::ObjectTypeBound(ty, r) => tcx.lift(&ty).and_then(|ty| {\n+                tcx.lift(&r)\n+                    .and_then(|r| Some(super::ObjectTypeBound(ty, r)))\n+            }),\n+            super::ObjectCastObligation(ty) => tcx.lift(&ty).map(super::ObjectCastObligation),\n             super::AssignmentLhsSized => Some(super::AssignmentLhsSized),\n             super::TupleInitializerSized => Some(super::TupleInitializerSized),\n             super::StructInitializerSized => Some(super::StructInitializerSized),\n@@ -222,20 +213,20 @@ impl<'a, 'tcx> Lift<'tcx> for traits::ObligationCauseCode<'a> {\n             super::ImplDerivedObligation(ref cause) => {\n                 tcx.lift(cause).map(super::ImplDerivedObligation)\n             }\n-            super::CompareImplMethodObligation { item_name,\n-                                                 impl_item_def_id,\n-                                                 trait_item_def_id } => {\n-                Some(super::CompareImplMethodObligation {\n-                    item_name,\n-                    impl_item_def_id,\n-                    trait_item_def_id,\n-                })\n-            }\n+            super::CompareImplMethodObligation {\n+                item_name,\n+                impl_item_def_id,\n+                trait_item_def_id,\n+            } => Some(super::CompareImplMethodObligation {\n+                item_name,\n+                impl_item_def_id,\n+                trait_item_def_id,\n+            }),\n             super::ExprAssignable => Some(super::ExprAssignable),\n-            super::MatchExpressionArm { arm_span, source } => {\n-                Some(super::MatchExpressionArm { arm_span,\n-                                                 source: source })\n-            }\n+            super::MatchExpressionArm { arm_span, source } => Some(super::MatchExpressionArm {\n+                arm_span,\n+                source: source,\n+            }),\n             super::IfExpression => Some(super::IfExpression),\n             super::IfExpressionWithNoElse => Some(super::IfExpressionWithNoElse),\n             super::MainFunctionType => Some(super::MainFunctionType),\n@@ -252,25 +243,22 @@ impl<'a, 'tcx> Lift<'tcx> for traits::DerivedObligationCause<'a> {\n     type Lifted = traits::DerivedObligationCause<'tcx>;\n     fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n         tcx.lift(&self.parent_trait_ref).and_then(|trait_ref| {\n-            tcx.lift(&*self.parent_code).map(|code| {\n-                traits::DerivedObligationCause {\n+            tcx.lift(&*self.parent_code)\n+                .map(|code| traits::DerivedObligationCause {\n                     parent_trait_ref: trait_ref,\n-                    parent_code: Rc::new(code)\n-                }\n-            })\n+                    parent_code: Rc::new(code),\n+                })\n         })\n     }\n }\n \n impl<'a, 'tcx> Lift<'tcx> for traits::ObligationCause<'a> {\n     type Lifted = traits::ObligationCause<'tcx>;\n     fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n-        tcx.lift(&self.code).map(|code| {\n-            traits::ObligationCause {\n-                span: self.span,\n-                body_id: self.body_id,\n-                code,\n-            }\n+        tcx.lift(&self.code).map(|code| traits::ObligationCause {\n+            span: self.span,\n+            body_id: self.body_id,\n+            code,\n         })\n     }\n }\n@@ -283,75 +271,63 @@ impl<'a, 'tcx> Lift<'tcx> for traits::Vtable<'a, ()> {\n             traits::VtableImpl(traits::VtableImplData {\n                 impl_def_id,\n                 substs,\n-                nested\n-            }) => {\n-                tcx.lift(&substs).map(|substs| {\n-                    traits::VtableImpl(traits::VtableImplData {\n-                        impl_def_id,\n-                        substs,\n-                        nested,\n-                    })\n+                nested,\n+            }) => tcx.lift(&substs).map(|substs| {\n+                traits::VtableImpl(traits::VtableImplData {\n+                    impl_def_id,\n+                    substs,\n+                    nested,\n                 })\n-            }\n+            }),\n             traits::VtableAutoImpl(t) => Some(traits::VtableAutoImpl(t)),\n             traits::VtableGenerator(traits::VtableGeneratorData {\n                 generator_def_id,\n                 substs,\n-                nested\n-            }) => {\n-                tcx.lift(&substs).map(|substs| {\n-                    traits::VtableGenerator(traits::VtableGeneratorData {\n-                        generator_def_id: generator_def_id,\n-                        substs: substs,\n-                        nested: nested\n-                    })\n+                nested,\n+            }) => tcx.lift(&substs).map(|substs| {\n+                traits::VtableGenerator(traits::VtableGeneratorData {\n+                    generator_def_id: generator_def_id,\n+                    substs: substs,\n+                    nested: nested,\n                 })\n-            }\n+            }),\n             traits::VtableClosure(traits::VtableClosureData {\n                 closure_def_id,\n                 substs,\n-                nested\n-            }) => {\n-                tcx.lift(&substs).map(|substs| {\n-                    traits::VtableClosure(traits::VtableClosureData {\n-                        closure_def_id,\n-                        substs,\n-                        nested,\n-                    })\n+                nested,\n+            }) => tcx.lift(&substs).map(|substs| {\n+                traits::VtableClosure(traits::VtableClosureData {\n+                    closure_def_id,\n+                    substs,\n+                    nested,\n                 })\n-            }\n+            }),\n             traits::VtableFnPointer(traits::VtableFnPointerData { fn_ty, nested }) => {\n                 tcx.lift(&fn_ty).map(|fn_ty| {\n-                    traits::VtableFnPointer(traits::VtableFnPointerData {\n-                        fn_ty,\n-                        nested,\n-                    })\n+                    traits::VtableFnPointer(traits::VtableFnPointerData { fn_ty, nested })\n                 })\n             }\n             traits::VtableParam(n) => Some(traits::VtableParam(n)),\n             traits::VtableBuiltin(n) => Some(traits::VtableBuiltin(n)),\n             traits::VtableObject(traits::VtableObjectData {\n                 upcast_trait_ref,\n                 vtable_base,\n-                nested\n-            }) => {\n-                tcx.lift(&upcast_trait_ref).map(|trait_ref| {\n-                    traits::VtableObject(traits::VtableObjectData {\n-                        upcast_trait_ref: trait_ref,\n-                        vtable_base,\n-                        nested,\n-                    })\n+                nested,\n+            }) => tcx.lift(&upcast_trait_ref).map(|trait_ref| {\n+                traits::VtableObject(traits::VtableObjectData {\n+                    upcast_trait_ref: trait_ref,\n+                    vtable_base,\n+                    nested,\n                 })\n-            }\n+            }),\n         }\n     }\n }\n \n ///////////////////////////////////////////////////////////////////////////\n // TypeFoldable implementations.\n \n-impl<'tcx, O: TypeFoldable<'tcx>> TypeFoldable<'tcx> for traits::Obligation<'tcx, O>\n-{\n+impl<'tcx, O: TypeFoldable<'tcx>> TypeFoldable<'tcx> for traits::Obligation<'tcx, O> {\n     fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         traits::Obligation {\n             cause: self.cause.clone(),\n@@ -536,6 +512,14 @@ EnumTypeFoldableImpl! {\n     }\n }\n \n+EnumLiftImpl! {\n+    impl<'a, 'tcx> Lift<'tcx> for traits::WhereClauseAtom<'a> {\n+        type Lifted = traits::WhereClauseAtom<'tcx>;\n+        (traits::WhereClauseAtom::Implemented)(trait_ref),\n+        (traits::WhereClauseAtom::ProjectionEq)(projection),\n+    }\n+}\n+\n EnumTypeFoldableImpl! {\n     impl<'tcx> TypeFoldable<'tcx> for traits::DomainGoal<'tcx> {\n         (traits::DomainGoal::Holds)(wc),\n@@ -549,7 +533,21 @@ EnumTypeFoldableImpl! {\n     }\n }\n \n-CloneTypeFoldableImpls! {\n+EnumLiftImpl! {\n+    impl<'a, 'tcx> Lift<'tcx> for traits::DomainGoal<'a> {\n+        type Lifted = traits::DomainGoal<'tcx>;\n+        (traits::DomainGoal::Holds)(wc),\n+        (traits::DomainGoal::WellFormed)(wc),\n+        (traits::DomainGoal::FromEnv)(wc),\n+        (traits::DomainGoal::WellFormedTy)(ty),\n+        (traits::DomainGoal::Normalize)(projection),\n+        (traits::DomainGoal::FromEnvTy)(ty),\n+        (traits::DomainGoal::RegionOutlives)(predicate),\n+        (traits::DomainGoal::TypeOutlives)(predicate),\n+    }\n+}\n+\n+CloneTypeFoldableAndLiftImpls! {\n     traits::QuantifierKind,\n }\n \n@@ -564,9 +562,23 @@ EnumTypeFoldableImpl! {\n     }\n }\n \n+EnumLiftImpl! {\n+    impl<'a, 'tcx> Lift<'tcx> for traits::Goal<'a> {\n+        type Lifted = traits::Goal<'tcx>;\n+        (traits::Goal::Implies)(hypotheses, goal),\n+        (traits::Goal::And)(goal1, goal2),\n+        (traits::Goal::Not)(goal),\n+        (traits::Goal::DomainGoal)(domain_goal),\n+        (traits::Goal::Quantified)(kind, goal),\n+        (traits::Goal::CannotProve),\n+    }\n+}\n+\n impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::Slice<traits::Goal<'tcx>> {\n     fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n-        let v = self.iter().map(|t| t.fold_with(folder)).collect::<AccumulateVec<[_; 8]>>();\n+        let v = self.iter()\n+            .map(|t| t.fold_with(folder))\n+            .collect::<AccumulateVec<[_; 8]>>();\n         folder.tcx().intern_goals(&v)\n     }\n \n@@ -602,11 +614,69 @@ EnumTypeFoldableImpl! {\n \n impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::Slice<traits::Clause<'tcx>> {\n     fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n-        let v = self.iter().map(|t| t.fold_with(folder)).collect::<AccumulateVec<[_; 8]>>();\n+        let v = self.iter()\n+            .map(|t| t.fold_with(folder))\n+            .collect::<AccumulateVec<[_; 8]>>();\n         folder.tcx().intern_clauses(&v)\n     }\n \n     fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n         self.iter().any(|t| t.visit_with(visitor))\n     }\n }\n+\n+impl<'tcx, C> TypeFoldable<'tcx> for chalk_engine::ExClause<C>\n+where\n+    C: traits::ExClauseFold<'tcx>,\n+    C::Substitution: Clone,\n+    C::RegionConstraint: Clone,\n+{\n+    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n+        <C as traits::ExClauseFold>::fold_ex_clause_with(\n+            self,\n+            folder,\n+        )\n+    }\n+\n+    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+        <C as traits::ExClauseFold>::visit_ex_clause_with(\n+            self,\n+            visitor,\n+        )\n+    }\n+}\n+\n+impl<'tcx, C> Lift<'tcx> for chalk_engine::ExClause<C>\n+where\n+    C: chalk_engine::context::Context + Clone,\n+    C: traits::ExClauseLift<'tcx>,\n+{\n+    type Lifted = C::LiftedExClause;\n+\n+    fn lift_to_tcx<'a, 'gcx>(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n+        <C as traits::ExClauseLift>::lift_ex_clause_to_tcx(self, tcx)\n+    }\n+}\n+\n+EnumTypeFoldableImpl! {\n+    impl<'tcx, C> TypeFoldable<'tcx> for chalk_engine::DelayedLiteral<C> {\n+        (chalk_engine::DelayedLiteral::CannotProve)(a),\n+        (chalk_engine::DelayedLiteral::Negative)(a),\n+        (chalk_engine::DelayedLiteral::Positive)(a, b),\n+    } where\n+        C: chalk_engine::context::Context + Clone,\n+        C::CanonicalConstrainedSubst: TypeFoldable<'tcx>,\n+}\n+\n+EnumTypeFoldableImpl! {\n+    impl<'tcx, C> TypeFoldable<'tcx> for chalk_engine::Literal<C> {\n+        (chalk_engine::Literal::Negative)(a),\n+        (chalk_engine::Literal::Positive)(a),\n+    } where\n+        C: chalk_engine::context::Context + Clone,\n+        C::GoalInEnvironment: Clone + TypeFoldable<'tcx>,\n+}\n+\n+CloneTypeFoldableAndLiftImpls! {\n+    chalk_engine::TableIndex,\n+}"}, {"sha": "8a73219cf7091b2b38d7c70f429d31010ea4c9d4", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/b86d909f8635f82710c1bf74647c957051cbb23a/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b86d909f8635f82710c1bf74647c957051cbb23a/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=b86d909f8635f82710c1bf74647c957051cbb23a", "patch": "@@ -1512,6 +1512,57 @@ impl<'a, 'tcx> Lift<'tcx> for Region<'a> {\n     }\n }\n \n+impl<'a, 'tcx> Lift<'tcx> for &'a Goal<'a> {\n+    type Lifted = &'tcx Goal<'tcx>;\n+    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<&'tcx Goal<'tcx>> {\n+        if tcx.interners.arena.in_arena(*self as *const _) {\n+            return Some(unsafe { mem::transmute(*self) });\n+        }\n+        // Also try in the global tcx if we're not that.\n+        if !tcx.is_global() {\n+            self.lift_to_tcx(tcx.global_tcx())\n+        } else {\n+            None\n+        }\n+    }\n+}\n+\n+impl<'a, 'tcx> Lift<'tcx> for &'a Slice<Goal<'a>> {\n+    type Lifted = &'tcx Slice<Goal<'tcx>>;\n+    fn lift_to_tcx<'b, 'gcx>(\n+        &self,\n+        tcx: TyCtxt<'b, 'gcx, 'tcx>,\n+    ) -> Option<&'tcx Slice<Goal<'tcx>>> {\n+        if tcx.interners.arena.in_arena(*self as *const _) {\n+            return Some(unsafe { mem::transmute(*self) });\n+        }\n+        // Also try in the global tcx if we're not that.\n+        if !tcx.is_global() {\n+            self.lift_to_tcx(tcx.global_tcx())\n+        } else {\n+            None\n+        }\n+    }\n+}\n+\n+impl<'a, 'tcx> Lift<'tcx> for &'a Slice<Clause<'a>> {\n+    type Lifted = &'tcx Slice<Clause<'tcx>>;\n+    fn lift_to_tcx<'b, 'gcx>(\n+        &self,\n+        tcx: TyCtxt<'b, 'gcx, 'tcx>,\n+    ) -> Option<&'tcx Slice<Clause<'tcx>>> {\n+        if tcx.interners.arena.in_arena(*self as *const _) {\n+            return Some(unsafe { mem::transmute(*self) });\n+        }\n+        // Also try in the global tcx if we're not that.\n+        if !tcx.is_global() {\n+            self.lift_to_tcx(tcx.global_tcx())\n+        } else {\n+            None\n+        }\n+    }\n+}\n+\n impl<'a, 'tcx> Lift<'tcx> for &'a Const<'a> {\n     type Lifted = &'tcx Const<'tcx>;\n     fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<&'tcx Const<'tcx>> {"}, {"sha": "c2b1130b75a7ab9f377eb3afd9032ad2bf692849", "filename": "src/librustc_data_structures/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b86d909f8635f82710c1bf74647c957051cbb23a/src%2Flibrustc_data_structures%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/b86d909f8635f82710c1bf74647c957051cbb23a/src%2Flibrustc_data_structures%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2FCargo.toml?ref=b86d909f8635f82710c1bf74647c957051cbb23a", "patch": "@@ -17,6 +17,7 @@ cfg-if = \"0.1.2\"\n stable_deref_trait = \"1.0.0\"\n parking_lot_core = \"0.2.8\"\n rustc-rayon = \"0.1.0\"\n+rustc-hash = \"1.0.0\"\n \n [dependencies.parking_lot]\n version = \"0.5\""}, {"sha": "3bf3170d1df1a648621aafddfb092d8e6f70f87e", "filename": "src/librustc_data_structures/fx.rs", "status": "modified", "additions": 4, "deletions": 85, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/b86d909f8635f82710c1bf74647c957051cbb23a/src%2Flibrustc_data_structures%2Ffx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b86d909f8635f82710c1bf74647c957051cbb23a/src%2Flibrustc_data_structures%2Ffx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Ffx.rs?ref=b86d909f8635f82710c1bf74647c957051cbb23a", "patch": "@@ -10,11 +10,11 @@\n \n use std::collections::{HashMap, HashSet};\n use std::default::Default;\n-use std::hash::{Hasher, Hash, BuildHasherDefault};\n-use std::ops::BitXor;\n+use std::hash::Hash;\n \n-pub type FxHashMap<K, V> = HashMap<K, V, BuildHasherDefault<FxHasher>>;\n-pub type FxHashSet<V> = HashSet<V, BuildHasherDefault<FxHasher>>;\n+pub use rustc_hash::FxHashMap;\n+pub use rustc_hash::FxHashSet;\n+pub use rustc_hash::FxHasher;\n \n #[allow(non_snake_case)]\n pub fn FxHashMap<K: Hash + Eq, V>() -> FxHashMap<K, V> {\n@@ -26,84 +26,3 @@ pub fn FxHashSet<V: Hash + Eq>() -> FxHashSet<V> {\n     HashSet::default()\n }\n \n-/// A speedy hash algorithm for use within rustc. The hashmap in liballoc\n-/// by default uses SipHash which isn't quite as speedy as we want. In the\n-/// compiler we're not really worried about DOS attempts, so we use a fast\n-/// non-cryptographic hash.\n-///\n-/// This is the same as the algorithm used by Firefox -- which is a homespun\n-/// one not based on any widely-known algorithm -- though modified to produce\n-/// 64-bit hash values instead of 32-bit hash values. It consistently\n-/// out-performs an FNV-based hash within rustc itself -- the collision rate is\n-/// similar or slightly worse than FNV, but the speed of the hash function\n-/// itself is much higher because it works on up to 8 bytes at a time.\n-pub struct FxHasher {\n-    hash: usize\n-}\n-\n-#[cfg(target_pointer_width = \"32\")]\n-const K: usize = 0x9e3779b9;\n-#[cfg(target_pointer_width = \"64\")]\n-const K: usize = 0x517cc1b727220a95;\n-\n-impl Default for FxHasher {\n-    #[inline]\n-    fn default() -> FxHasher {\n-        FxHasher { hash: 0 }\n-    }\n-}\n-\n-impl FxHasher {\n-    #[inline]\n-    fn add_to_hash(&mut self, i: usize) {\n-        self.hash = self.hash.rotate_left(5).bitxor(i).wrapping_mul(K);\n-    }\n-}\n-\n-impl Hasher for FxHasher {\n-    #[inline]\n-    fn write(&mut self, bytes: &[u8]) {\n-        for byte in bytes {\n-            let i = *byte;\n-            self.add_to_hash(i as usize);\n-        }\n-    }\n-\n-    #[inline]\n-    fn write_u8(&mut self, i: u8) {\n-        self.add_to_hash(i as usize);\n-    }\n-\n-    #[inline]\n-    fn write_u16(&mut self, i: u16) {\n-        self.add_to_hash(i as usize);\n-    }\n-\n-    #[inline]\n-    fn write_u32(&mut self, i: u32) {\n-        self.add_to_hash(i as usize);\n-    }\n-\n-    #[cfg(target_pointer_width = \"32\")]\n-    #[inline]\n-    fn write_u64(&mut self, i: u64) {\n-        self.add_to_hash(i as usize);\n-        self.add_to_hash((i >> 32) as usize);\n-    }\n-\n-    #[cfg(target_pointer_width = \"64\")]\n-    #[inline]\n-    fn write_u64(&mut self, i: u64) {\n-        self.add_to_hash(i as usize);\n-    }\n-\n-    #[inline]\n-    fn write_usize(&mut self, i: usize) {\n-        self.add_to_hash(i);\n-    }\n-\n-    #[inline]\n-    fn finish(&self) -> u64 {\n-        self.hash as u64\n-    }\n-}"}, {"sha": "e2a80acbd1285509e479fc01346986b4f91776cc", "filename": "src/librustc_data_structures/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b86d909f8635f82710c1bf74647c957051cbb23a/src%2Flibrustc_data_structures%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b86d909f8635f82710c1bf74647c957051cbb23a/src%2Flibrustc_data_structures%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Flib.rs?ref=b86d909f8635f82710c1bf74647c957051cbb23a", "patch": "@@ -44,6 +44,7 @@ extern crate parking_lot;\n extern crate cfg_if;\n extern crate stable_deref_trait;\n extern crate rustc_rayon as rayon;\n+extern crate rustc_hash;\n \n // See librustc_cratesio_shim/Cargo.toml for a comment explaining this.\n #[allow(unused_extern_crates)]"}, {"sha": "134983911100ebaebdf4ab3a4b66d36e55467034", "filename": "src/librustc_traits/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b86d909f8635f82710c1bf74647c957051cbb23a/src%2Flibrustc_traits%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/b86d909f8635f82710c1bf74647c957051cbb23a/src%2Flibrustc_traits%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2FCargo.toml?ref=b86d909f8635f82710c1bf74647c957051cbb23a", "patch": "@@ -16,3 +16,4 @@ rustc = { path = \"../librustc\" }\n rustc_data_structures = { path = \"../librustc_data_structures\" }\n syntax = { path = \"../libsyntax\" }\n syntax_pos = { path = \"../libsyntax_pos\" }\n+chalk-engine = { version = \"0.6.0\", default-features=false }"}, {"sha": "bf26409c3ef5fa858cb932f967eb5e1b8a485347", "filename": "src/librustc_traits/chalk_context.rs", "status": "added", "additions": 524, "deletions": 0, "changes": 524, "blob_url": "https://github.com/rust-lang/rust/blob/b86d909f8635f82710c1bf74647c957051cbb23a/src%2Flibrustc_traits%2Fchalk_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b86d909f8635f82710c1bf74647c957051cbb23a/src%2Flibrustc_traits%2Fchalk_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fchalk_context.rs?ref=b86d909f8635f82710c1bf74647c957051cbb23a", "patch": "@@ -0,0 +1,524 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use chalk_engine::fallible::Fallible as ChalkEngineFallible;\n+use chalk_engine::{context, hh::HhGoal, DelayedLiteral, ExClause};\n+use rustc::infer::canonical::{\n+    Canonical, CanonicalVarValues, Canonicalize, QueryRegionConstraint, QueryResult,\n+};\n+use rustc::infer::{InferCtxt, InferOk, LateBoundRegionConversionTime};\n+use rustc::traits::{DomainGoal, ExClauseFold, ExClauseLift, Goal, ProgramClause, QuantifierKind};\n+use rustc::ty::fold::{TypeFoldable, TypeFolder, TypeVisitor};\n+use rustc::ty::subst::Kind;\n+use rustc::ty::{self, TyCtxt};\n+\n+use std::fmt::{self, Debug};\n+use std::marker::PhantomData;\n+\n+use syntax_pos::DUMMY_SP;\n+\n+#[derive(Copy, Clone, Debug)]\n+crate struct ChalkArenas<'gcx> {\n+    _phantom: PhantomData<&'gcx ()>,\n+}\n+\n+#[derive(Copy, Clone)]\n+crate struct ChalkContext<'cx, 'gcx: 'cx> {\n+    _arenas: ChalkArenas<'gcx>,\n+    _tcx: TyCtxt<'cx, 'gcx, 'gcx>,\n+}\n+\n+#[derive(Copy, Clone)]\n+crate struct ChalkInferenceContext<'cx, 'gcx: 'tcx, 'tcx: 'cx> {\n+    infcx: &'cx InferCtxt<'cx, 'gcx, 'tcx>,\n+}\n+\n+#[derive(Copy, Clone, Debug)]\n+crate struct UniverseMap;\n+\n+#[derive(Clone, Debug, PartialEq, Eq, Hash)]\n+crate struct ConstrainedSubst<'tcx> {\n+    subst: CanonicalVarValues<'tcx>,\n+    constraints: Vec<QueryRegionConstraint<'tcx>>,\n+}\n+\n+BraceStructTypeFoldableImpl! {\n+    impl<'tcx> TypeFoldable<'tcx> for ConstrainedSubst<'tcx> {\n+        subst, constraints\n+    }\n+}\n+\n+impl context::Context for ChalkArenas<'tcx> {\n+    type CanonicalExClause = Canonical<'tcx, ExClause<Self>>;\n+\n+    type CanonicalGoalInEnvironment = Canonical<'tcx, ty::ParamEnvAnd<'tcx, Goal<'tcx>>>;\n+\n+    // u-canonicalization not yet implemented\n+    type UCanonicalGoalInEnvironment = Canonical<'tcx, ty::ParamEnvAnd<'tcx, Goal<'tcx>>>;\n+\n+    type CanonicalConstrainedSubst = Canonical<'tcx, ConstrainedSubst<'tcx>>;\n+\n+    // u-canonicalization not yet implemented\n+    type UniverseMap = UniverseMap;\n+\n+    type Solution = Canonical<'tcx, QueryResult<'tcx, ()>>;\n+\n+    type InferenceNormalizedSubst = CanonicalVarValues<'tcx>;\n+\n+    type GoalInEnvironment = ty::ParamEnvAnd<'tcx, Goal<'tcx>>;\n+\n+    type RegionConstraint = QueryRegionConstraint<'tcx>;\n+\n+    type Substitution = CanonicalVarValues<'tcx>;\n+\n+    type Environment = ty::ParamEnv<'tcx>;\n+\n+    type Goal = Goal<'tcx>;\n+\n+    type DomainGoal = DomainGoal<'tcx>;\n+\n+    type BindersGoal = ty::Binder<&'tcx Goal<'tcx>>;\n+\n+    type Parameter = Kind<'tcx>;\n+\n+    type ProgramClause = ProgramClause<'tcx>;\n+\n+    type ProgramClauses = Vec<ProgramClause<'tcx>>;\n+\n+    type UnificationResult = InferOk<'tcx, ()>;\n+\n+    fn into_goal(domain_goal: DomainGoal<'tcx>) -> Goal<'tcx> {\n+        Goal::DomainGoal(domain_goal)\n+    }\n+\n+    fn cannot_prove() -> Goal<'tcx> {\n+        Goal::CannotProve\n+    }\n+\n+    fn goal_in_environment(\n+        env: &ty::ParamEnv<'tcx>,\n+        goal: Goal<'tcx>,\n+    ) -> ty::ParamEnvAnd<'tcx, Goal<'tcx>> {\n+        env.and(goal)\n+    }\n+}\n+\n+impl context::AggregateOps<ChalkArenas<'gcx>> for ChalkContext<'cx, 'gcx> {\n+    fn make_solution(\n+        &self,\n+        _root_goal: &Canonical<'gcx, ty::ParamEnvAnd<'gcx, Goal<'gcx>>>,\n+        _simplified_answers: impl context::AnswerStream<ChalkArenas<'gcx>>,\n+    ) -> Option<Canonical<'gcx, QueryResult<'gcx, ()>>> {\n+        unimplemented!()\n+    }\n+}\n+\n+impl context::ContextOps<ChalkArenas<'gcx>> for ChalkContext<'cx, 'gcx> {\n+    /// True if this is a coinductive goal -- e.g., proving an auto trait.\n+    fn is_coinductive(&self, _goal: &Canonical<'gcx, ty::ParamEnvAnd<'gcx, Goal<'gcx>>>) -> bool {\n+        unimplemented!()\n+    }\n+\n+    /// Create an inference table for processing a new goal and instantiate that goal\n+    /// in that context, returning \"all the pieces\".\n+    ///\n+    /// More specifically: given a u-canonical goal `arg`, creates a\n+    /// new inference table `T` and populates it with the universes\n+    /// found in `arg`. Then, creates a substitution `S` that maps\n+    /// each bound variable in `arg` to a fresh inference variable\n+    /// from T. Returns:\n+    ///\n+    /// - the table `T`\n+    /// - the substitution `S`\n+    /// - the environment and goal found by substitution `S` into `arg`\n+    fn instantiate_ucanonical_goal<R>(\n+        &self,\n+        _arg: &Canonical<'gcx, ty::ParamEnvAnd<'gcx, Goal<'gcx>>>,\n+        _op: impl context::WithInstantiatedUCanonicalGoal<ChalkArenas<'gcx>, Output = R>,\n+    ) -> R {\n+        unimplemented!()\n+    }\n+\n+    fn instantiate_ex_clause<R>(\n+        &self,\n+        _num_universes: usize,\n+        _canonical_ex_clause: &Canonical<'gcx, ChalkExClause<'gcx>>,\n+        _op: impl context::WithInstantiatedExClause<ChalkArenas<'gcx>, Output = R>,\n+    ) -> R {\n+        unimplemented!()\n+    }\n+\n+    /// True if this solution has no region constraints.\n+    fn empty_constraints(ccs: &Canonical<'gcx, ConstrainedSubst<'gcx>>) -> bool {\n+        ccs.value.constraints.is_empty()\n+    }\n+\n+    fn inference_normalized_subst_from_ex_clause(\n+        canon_ex_clause: &'a Canonical<'gcx, ChalkExClause<'gcx>>,\n+    ) -> &'a CanonicalVarValues<'gcx> {\n+        &canon_ex_clause.value.subst\n+    }\n+\n+    fn inference_normalized_subst_from_subst(\n+        canon_subst: &'a Canonical<'gcx, ConstrainedSubst<'gcx>>,\n+    ) -> &'a CanonicalVarValues<'gcx> {\n+        &canon_subst.value.subst\n+    }\n+\n+    fn canonical(\n+        u_canon: &'a Canonical<'gcx, ty::ParamEnvAnd<'gcx, Goal<'gcx>>>,\n+    ) -> &'a Canonical<'gcx, ty::ParamEnvAnd<'gcx, Goal<'gcx>>> {\n+        u_canon\n+    }\n+\n+    fn is_trivial_substitution(\n+        _u_canon: &Canonical<'gcx, ty::ParamEnvAnd<'gcx, Goal<'gcx>>>,\n+        _canonical_subst: &Canonical<'gcx, ConstrainedSubst<'gcx>>,\n+    ) -> bool {\n+        unimplemented!()\n+    }\n+\n+    fn num_universes(_: &Canonical<'gcx, ty::ParamEnvAnd<'gcx, Goal<'gcx>>>) -> usize {\n+        0 // FIXME\n+    }\n+\n+    /// Convert a goal G *from* the canonical universes *into* our\n+    /// local universes. This will yield a goal G' that is the same\n+    /// but for the universes of universally quantified names.\n+    fn map_goal_from_canonical(\n+        _map: &UniverseMap,\n+        value: &Canonical<'gcx, ty::ParamEnvAnd<'gcx, Goal<'gcx>>>,\n+    ) -> Canonical<'gcx, ty::ParamEnvAnd<'gcx, Goal<'gcx>>> {\n+        *value // FIXME universe maps not implemented yet\n+    }\n+\n+    fn map_subst_from_canonical(\n+        _map: &UniverseMap,\n+        value: &Canonical<'gcx, ConstrainedSubst<'gcx>>,\n+    ) -> Canonical<'gcx, ConstrainedSubst<'gcx>> {\n+        value.clone() // FIXME universe maps not implemented yet\n+    }\n+}\n+\n+//impl context::UCanonicalGoalInEnvironment<ChalkContext<'cx, 'gcx>>\n+//    for Canonical<'gcx, ty::ParamEnvAnd<'gcx, Goal<'gcx>>>\n+//{\n+//    fn canonical(&self) -> &Canonical<'gcx, ty::ParamEnvAnd<'gcx, Goal<'gcx>>> {\n+//        self\n+//    }\n+//\n+//    fn is_trivial_substitution(\n+//        &self,\n+//        canonical_subst: &Canonical<'tcx, ConstrainedSubst<'tcx>>,\n+//    ) -> bool {\n+//        let subst = &canonical_subst.value.subst;\n+//        assert_eq!(self.canonical.variables.len(), subst.var_values.len());\n+//        subst\n+//            .var_values\n+//            .iter_enumerated()\n+//            .all(|(cvar, kind)| match kind.unpack() {\n+//                Kind::Lifetime(r) => match r {\n+//                    ty::ReCanonical(cvar1) => cvar == cvar1,\n+//                    _ => false,\n+//                },\n+//                Kind::Type(ty) => match ty.sty {\n+//                    ty::TyInfer(ty::InferTy::CanonicalTy(cvar1)) => cvar == cvar1,\n+//                    _ => false,\n+//                },\n+//            })\n+//    }\n+//\n+//    fn num_universes(&self) -> usize {\n+//        0 // FIXME\n+//    }\n+//}\n+\n+impl context::InferenceTable<ChalkArenas<'gcx>, ChalkArenas<'tcx>>\n+    for ChalkInferenceContext<'cx, 'gcx, 'tcx>\n+{\n+    fn into_hh_goal(&mut self, goal: Goal<'tcx>) -> ChalkHhGoal<'tcx> {\n+        match goal {\n+            Goal::Implies(..) => panic!(\"FIXME rust-lang-nursery/chalk#94\"),\n+            Goal::And(left, right) => HhGoal::And(*left, *right),\n+            Goal::Not(subgoal) => HhGoal::Not(*subgoal),\n+            Goal::DomainGoal(d) => HhGoal::DomainGoal(d),\n+            Goal::Quantified(QuantifierKind::Universal, binder) => HhGoal::ForAll(binder),\n+            Goal::Quantified(QuantifierKind::Existential, binder) => HhGoal::Exists(binder),\n+            Goal::CannotProve => HhGoal::CannotProve,\n+        }\n+    }\n+\n+    fn add_clauses(\n+        &mut self,\n+        _env: &ty::ParamEnv<'tcx>,\n+        _clauses: Vec<ProgramClause<'tcx>>,\n+    ) -> ty::ParamEnv<'tcx> {\n+        panic!(\"FIXME no method to add clauses to ParamEnv yet\")\n+    }\n+}\n+\n+impl context::ResolventOps<ChalkArenas<'gcx>, ChalkArenas<'tcx>>\n+    for ChalkInferenceContext<'cx, 'gcx, 'tcx>\n+{\n+    fn resolvent_clause(\n+        &mut self,\n+        _environment: &ty::ParamEnv<'tcx>,\n+        _goal: &DomainGoal<'tcx>,\n+        _subst: &CanonicalVarValues<'tcx>,\n+        _clause: &ProgramClause<'tcx>,\n+    ) -> chalk_engine::fallible::Fallible<Canonical<'gcx, ChalkExClause<'gcx>>> {\n+        panic!()\n+    }\n+\n+    fn apply_answer_subst(\n+        &mut self,\n+        _ex_clause: ChalkExClause<'tcx>,\n+        _selected_goal: &ty::ParamEnvAnd<'tcx, Goal<'tcx>>,\n+        _answer_table_goal: &Canonical<'gcx, ty::ParamEnvAnd<'gcx, Goal<'gcx>>>,\n+        _canonical_answer_subst: &Canonical<'gcx, ConstrainedSubst<'gcx>>,\n+    ) -> chalk_engine::fallible::Fallible<ChalkExClause<'tcx>> {\n+        panic!()\n+    }\n+}\n+\n+impl context::TruncateOps<ChalkArenas<'gcx>, ChalkArenas<'tcx>>\n+    for ChalkInferenceContext<'cx, 'gcx, 'tcx>\n+{\n+    fn truncate_goal(\n+        &mut self,\n+        subgoal: &ty::ParamEnvAnd<'tcx, Goal<'tcx>>,\n+    ) -> Option<ty::ParamEnvAnd<'tcx, Goal<'tcx>>> {\n+        Some(*subgoal) // FIXME we should truncate at some point!\n+    }\n+\n+    fn truncate_answer(\n+        &mut self,\n+        subst: &CanonicalVarValues<'tcx>,\n+    ) -> Option<CanonicalVarValues<'tcx>> {\n+        Some(subst.clone()) // FIXME we should truncate at some point!\n+    }\n+}\n+\n+impl context::UnificationOps<ChalkArenas<'gcx>, ChalkArenas<'tcx>>\n+    for ChalkInferenceContext<'cx, 'gcx, 'tcx>\n+{\n+    fn program_clauses(\n+        &self,\n+        _environment: &ty::ParamEnv<'tcx>,\n+        goal: &DomainGoal<'tcx>,\n+    ) -> Vec<ProgramClause<'tcx>> {\n+        use rustc::traits::DomainGoal::*;\n+        use rustc::traits::WhereClauseAtom::*;\n+\n+        match goal {\n+            Holds(Implemented(_trait_predicate)) => {\n+                // These come from:\n+                //\n+                // - Trait definitions (implied bounds)\n+                // - Implementations of the trait itself\n+                panic!()\n+            }\n+\n+            Holds(ProjectionEq(_projection_predicate)) => {\n+                // These come from:\n+                panic!()\n+            }\n+\n+            WellFormed(Implemented(_trait_predicate)) => {\n+                // These come from -- the trait decl.\n+                panic!()\n+            }\n+\n+            WellFormed(ProjectionEq(_projection_predicate)) => panic!(),\n+\n+            FromEnv(Implemented(_trait_predicate)) => panic!(),\n+\n+            FromEnv(ProjectionEq(_projection_predicate)) => panic!(),\n+\n+            WellFormedTy(_ty) => panic!(),\n+\n+            FromEnvTy(_ty) => panic!(),\n+\n+            RegionOutlives(_region_outlives) => panic!(),\n+\n+            TypeOutlives(_type_outlives) => panic!(),\n+\n+            Normalize(_) => panic!(),\n+        }\n+    }\n+\n+    fn instantiate_binders_universally(\n+        &mut self,\n+        _arg: &ty::Binder<&'tcx Goal<'tcx>>,\n+    ) -> Goal<'tcx> {\n+        panic!(\"FIXME -- universal instantiation needs sgrif's branch\")\n+    }\n+\n+    fn instantiate_binders_existentially(\n+        &mut self,\n+        arg: &ty::Binder<&'tcx Goal<'tcx>>,\n+    ) -> Goal<'tcx> {\n+        let (value, _map) = self.infcx.replace_late_bound_regions_with_fresh_var(\n+            DUMMY_SP,\n+            LateBoundRegionConversionTime::HigherRankedType,\n+            arg,\n+        );\n+        *value\n+    }\n+\n+    fn debug_ex_clause(&mut self, value: &'v ChalkExClause<'tcx>) -> Box<dyn Debug + 'v> {\n+        let string = format!(\"{:?}\", self.infcx.resolve_type_vars_if_possible(value));\n+        Box::new(string)\n+    }\n+\n+    fn canonicalize_goal(\n+        &mut self,\n+        value: &ty::ParamEnvAnd<'tcx, Goal<'tcx>>,\n+    ) -> Canonical<'gcx, ty::ParamEnvAnd<'gcx, Goal<'gcx>>> {\n+        self.infcx.canonicalize_query(value).0\n+    }\n+\n+    fn canonicalize_ex_clause(\n+        &mut self,\n+        value: &ChalkExClause<'tcx>,\n+    ) -> Canonical<'gcx, ChalkExClause<'gcx>> {\n+        self.infcx.canonicalize_response(value).0\n+    }\n+\n+    fn canonicalize_constrained_subst(\n+        &mut self,\n+        subst: CanonicalVarValues<'tcx>,\n+        constraints: Vec<QueryRegionConstraint<'tcx>>,\n+    ) -> Canonical<'gcx, ConstrainedSubst<'gcx>> {\n+        self.infcx\n+            .canonicalize_response(&ConstrainedSubst { subst, constraints })\n+            .0\n+    }\n+\n+    fn u_canonicalize_goal(\n+        &mut self,\n+        value: &Canonical<'gcx, ty::ParamEnvAnd<'gcx, Goal<'gcx>>>,\n+    ) -> (\n+        Canonical<'gcx, ty::ParamEnvAnd<'gcx, Goal<'gcx>>>,\n+        UniverseMap,\n+    ) {\n+        (value.clone(), UniverseMap)\n+    }\n+\n+    fn invert_goal(\n+        &mut self,\n+        _value: &ty::ParamEnvAnd<'tcx, Goal<'tcx>>,\n+    ) -> Option<ty::ParamEnvAnd<'tcx, Goal<'tcx>>> {\n+        panic!(\"goal inversion not yet implemented\")\n+    }\n+\n+    fn unify_parameters(\n+        &mut self,\n+        _environment: &ty::ParamEnv<'tcx>,\n+        _a: &Kind<'tcx>,\n+        _b: &Kind<'tcx>,\n+    ) -> ChalkEngineFallible<InferOk<'tcx, ()>> {\n+        panic!()\n+    }\n+\n+    fn sink_answer_subset(\n+        &self,\n+        value: &Canonical<'gcx, ConstrainedSubst<'gcx>>,\n+    ) -> Canonical<'tcx, ConstrainedSubst<'tcx>> {\n+        value.clone()\n+    }\n+\n+    fn lift_delayed_literal(\n+        &self,\n+        _value: DelayedLiteral<ChalkArenas<'tcx>>,\n+    ) -> DelayedLiteral<ChalkArenas<'gcx>> {\n+        panic!(\"lift\")\n+    }\n+\n+    fn into_ex_clause(&mut self, _result: InferOk<'tcx, ()>, _ex_clause: &mut ChalkExClause<'tcx>) {\n+        panic!(\"TBD\")\n+    }\n+}\n+\n+type ChalkHhGoal<'tcx> = HhGoal<ChalkArenas<'tcx>>;\n+\n+type ChalkExClause<'tcx> = ExClause<ChalkArenas<'tcx>>;\n+\n+impl Debug for ChalkContext<'cx, 'gcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"ChalkContext\")\n+    }\n+}\n+\n+impl Debug for ChalkInferenceContext<'cx, 'gcx, 'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"ChalkInferenceContext\")\n+    }\n+}\n+\n+impl ExClauseLift<'gcx> for ChalkArenas<'a> {\n+    type LiftedExClause = ChalkExClause<'gcx>;\n+\n+    fn lift_ex_clause_to_tcx(\n+        _ex_clause: &ChalkExClause<'a>,\n+        _tcx: TyCtxt<'_, '_, 'tcx>,\n+    ) -> Option<Self::LiftedExClause> {\n+        panic!()\n+    }\n+}\n+\n+impl ExClauseFold<'tcx> for ChalkArenas<'tcx> {\n+    fn fold_ex_clause_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(\n+        ex_clause: &ChalkExClause<'tcx>,\n+        folder: &mut F,\n+    ) -> ChalkExClause<'tcx> {\n+        ExClause {\n+            subst: ex_clause.subst.fold_with(folder),\n+            delayed_literals: ex_clause.delayed_literals.fold_with(folder),\n+            constraints: ex_clause.constraints.fold_with(folder),\n+            subgoals: ex_clause.subgoals.fold_with(folder),\n+        }\n+    }\n+\n+    fn visit_ex_clause_with<'gcx: 'tcx, V: TypeVisitor<'tcx>>(\n+        ex_clause: &ExClause<Self>,\n+        visitor: &mut V,\n+    ) -> bool {\n+        let ExClause {\n+            subst,\n+            delayed_literals,\n+            constraints,\n+            subgoals,\n+        } = ex_clause;\n+        subst.visit_with(visitor)\n+            && delayed_literals.visit_with(visitor)\n+            && constraints.visit_with(visitor)\n+            && subgoals.visit_with(visitor)\n+    }\n+}\n+\n+BraceStructLiftImpl! {\n+    impl<'a, 'tcx> Lift<'tcx> for ConstrainedSubst<'a> {\n+        type Lifted = ConstrainedSubst<'tcx>;\n+\n+        subst, constraints\n+    }\n+}\n+\n+impl<'gcx: 'tcx, 'tcx> Canonicalize<'gcx, 'tcx> for ConstrainedSubst<'tcx> {\n+    type Canonicalized = Canonical<'gcx, ConstrainedSubst<'gcx>>;\n+\n+    fn intern(\n+        _gcx: TyCtxt<'_, 'gcx, 'gcx>,\n+        value: Canonical<'gcx, ConstrainedSubst<'gcx>>,\n+    ) -> Self::Canonicalized {\n+        value\n+    }\n+}"}, {"sha": "733d8e1708ec08c2a4bca4ec91a06737cd86813d", "filename": "src/librustc_traits/lib.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b86d909f8635f82710c1bf74647c957051cbb23a/src%2Flibrustc_traits%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b86d909f8635f82710c1bf74647c957051cbb23a/src%2Flibrustc_traits%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Flib.rs?ref=b86d909f8635f82710c1bf74647c957051cbb23a", "patch": "@@ -11,9 +11,13 @@\n //! New recursive solver modeled on Chalk's recursive solver. Most of\n //! the guts are broken up into modules; see the comments in those modules.\n \n+#![feature(crate_in_paths)]\n #![feature(crate_visibility_modifier)]\n+#![feature(extern_prelude)]\n #![feature(iterator_find_map)]\n+#![feature(in_band_lifetimes)]\n \n+extern crate chalk_engine;\n #[macro_use]\n extern crate log;\n #[macro_use]\n@@ -22,6 +26,7 @@ extern crate rustc_data_structures;\n extern crate syntax;\n extern crate syntax_pos;\n \n+mod chalk_context;\n mod dropck_outlives;\n mod evaluate_obligation;\n mod normalize_projection_ty;"}, {"sha": "32f18a62abe596cd83289a169725b25b35516a11", "filename": "src/librustc_traits/lowering.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b86d909f8635f82710c1bf74647c957051cbb23a/src%2Flibrustc_traits%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b86d909f8635f82710c1bf74647c957051cbb23a/src%2Flibrustc_traits%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Flowering.rs?ref=b86d909f8635f82710c1bf74647c957051cbb23a", "patch": "@@ -22,7 +22,7 @@ use syntax::ast;\n \n use std::iter;\n \n-trait Lower<T> {\n+crate trait Lower<T> {\n     /// Lower a rustc construction (e.g. `ty::TraitPredicate`) to a chalk-like type.\n     fn lower(&self) -> T;\n }"}, {"sha": "bcd6f4e67f436873df5440af4701f67f3e56c504", "filename": "src/tools/tidy/src/deps.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b86d909f8635f82710c1bf74647c957051cbb23a/src%2Ftools%2Ftidy%2Fsrc%2Fdeps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b86d909f8635f82710c1bf74647c957051cbb23a/src%2Ftools%2Ftidy%2Fsrc%2Fdeps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Fdeps.rs?ref=b86d909f8635f82710c1bf74647c957051cbb23a", "patch": "@@ -66,6 +66,8 @@ static WHITELIST: &'static [Crate] = &[\n     Crate(\"bitflags\"),\n     Crate(\"byteorder\"),\n     Crate(\"cc\"),\n+    Crate(\"chalk-engine\"),\n+    Crate(\"chalk-macros\"),\n     Crate(\"cfg-if\"),\n     Crate(\"cmake\"),\n     Crate(\"crossbeam-deque\"),\n@@ -102,6 +104,7 @@ static WHITELIST: &'static [Crate] = &[\n     Crate(\"regex-syntax\"),\n     Crate(\"remove_dir_all\"),\n     Crate(\"rustc-demangle\"),\n+    Crate(\"rustc-hash\"),\n     Crate(\"rustc-rayon\"),\n     Crate(\"rustc-rayon-core\"),\n     Crate(\"scoped-tls\"),"}]}