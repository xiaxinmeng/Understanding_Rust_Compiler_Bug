{"sha": "cee5a2dd20a93145026119f46f924c7649e4b21c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNlZTVhMmRkMjBhOTMxNDUwMjYxMTlmNDZmOTI0Yzc2NDllNGIyMWM=", "commit": {"author": {"name": "Clar Charr", "email": "clar@charr.xyz", "date": "2017-06-08T01:44:03Z"}, "committer": {"name": "Clar Charr", "email": "clar@charr.xyz", "date": "2017-06-08T01:53:33Z"}, "message": "Move Range to module.", "tree": {"sha": "d7468bfbfcb41719670eebbd2ff38d49fe7b528e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d7468bfbfcb41719670eebbd2ff38d49fe7b528e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cee5a2dd20a93145026119f46f924c7649e4b21c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cee5a2dd20a93145026119f46f924c7649e4b21c", "html_url": "https://github.com/rust-lang/rust/commit/cee5a2dd20a93145026119f46f924c7649e4b21c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cee5a2dd20a93145026119f46f924c7649e4b21c/comments", "author": {"login": "clarfonthey", "id": 15850505, "node_id": "MDQ6VXNlcjE1ODUwNTA1", "avatar_url": "https://avatars.githubusercontent.com/u/15850505?v=4", "gravatar_id": "", "url": "https://api.github.com/users/clarfonthey", "html_url": "https://github.com/clarfonthey", "followers_url": "https://api.github.com/users/clarfonthey/followers", "following_url": "https://api.github.com/users/clarfonthey/following{/other_user}", "gists_url": "https://api.github.com/users/clarfonthey/gists{/gist_id}", "starred_url": "https://api.github.com/users/clarfonthey/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/clarfonthey/subscriptions", "organizations_url": "https://api.github.com/users/clarfonthey/orgs", "repos_url": "https://api.github.com/users/clarfonthey/repos", "events_url": "https://api.github.com/users/clarfonthey/events{/privacy}", "received_events_url": "https://api.github.com/users/clarfonthey/received_events", "type": "User", "site_admin": false}, "committer": {"login": "clarfonthey", "id": 15850505, "node_id": "MDQ6VXNlcjE1ODUwNTA1", "avatar_url": "https://avatars.githubusercontent.com/u/15850505?v=4", "gravatar_id": "", "url": "https://api.github.com/users/clarfonthey", "html_url": "https://github.com/clarfonthey", "followers_url": "https://api.github.com/users/clarfonthey/followers", "following_url": "https://api.github.com/users/clarfonthey/following{/other_user}", "gists_url": "https://api.github.com/users/clarfonthey/gists{/gist_id}", "starred_url": "https://api.github.com/users/clarfonthey/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/clarfonthey/subscriptions", "organizations_url": "https://api.github.com/users/clarfonthey/orgs", "repos_url": "https://api.github.com/users/clarfonthey/repos", "events_url": "https://api.github.com/users/clarfonthey/events{/privacy}", "received_events_url": "https://api.github.com/users/clarfonthey/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6f5987b05b09d1d19d7debbe466ecaeb6c3e997b", "url": "https://api.github.com/repos/rust-lang/rust/commits/6f5987b05b09d1d19d7debbe466ecaeb6c3e997b", "html_url": "https://github.com/rust-lang/rust/commit/6f5987b05b09d1d19d7debbe466ecaeb6c3e997b"}], "stats": {"total": 730, "additions": 374, "deletions": 356}, "files": [{"sha": "e67add65ab36cca7da442069cd5a3532ccdfdb74", "filename": "src/libcore/ops/mod.rs", "status": "modified", "additions": 8, "deletions": 356, "changes": 364, "blob_url": "https://github.com/rust-lang/rust/blob/cee5a2dd20a93145026119f46f924c7649e4b21c/src%2Flibcore%2Fops%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cee5a2dd20a93145026119f46f924c7649e4b21c/src%2Flibcore%2Fops%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Fmod.rs?ref=cee5a2dd20a93145026119f46f924c7649e4b21c", "patch": "@@ -147,7 +147,14 @@\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n-use fmt;\n+mod range;\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub use self::range::{Range, RangeFrom, RangeFull, RangeTo};\n+\n+#[unstable(feature = \"inclusive_range\", reason = \"recently added, follows RFC\", issue = \"28237\")]\n+pub use self::range::{RangeInclusive, RangeToInclusive};\n+\n use marker::Unsize;\n \n /// The `Drop` trait is used to run some code when a value goes out of scope.\n@@ -2083,361 +2090,6 @@ pub trait IndexMut<Idx: ?Sized>: Index<Idx> {\n     fn index_mut(&mut self, index: Idx) -> &mut Self::Output;\n }\n \n-/// An unbounded range. Use `..` (two dots) for its shorthand.\n-///\n-/// Its primary use case is slicing index. It cannot serve as an iterator\n-/// because it doesn't have a starting point.\n-///\n-/// # Examples\n-///\n-/// The `..` syntax is a `RangeFull`:\n-///\n-/// ```\n-/// assert_eq!((..), std::ops::RangeFull);\n-/// ```\n-///\n-/// It does not have an `IntoIterator` implementation, so you can't use it in a\n-/// `for` loop directly. This won't compile:\n-///\n-/// ```ignore\n-/// for i in .. {\n-///    // ...\n-/// }\n-/// ```\n-///\n-/// Used as a slicing index, `RangeFull` produces the full array as a slice.\n-///\n-/// ```\n-/// let arr = [0, 1, 2, 3];\n-/// assert_eq!(arr[ .. ], [0,1,2,3]);  // RangeFull\n-/// assert_eq!(arr[ ..3], [0,1,2  ]);\n-/// assert_eq!(arr[1.. ], [  1,2,3]);\n-/// assert_eq!(arr[1..3], [  1,2  ]);\n-/// ```\n-#[derive(Copy, Clone, PartialEq, Eq, Hash)]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct RangeFull;\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl fmt::Debug for RangeFull {\n-    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n-        write!(fmt, \"..\")\n-    }\n-}\n-\n-/// A (half-open) range which is bounded at both ends: { x | start <= x < end }.\n-/// Use `start..end` (two dots) for its shorthand.\n-///\n-/// See the [`contains`](#method.contains) method for its characterization.\n-///\n-/// # Examples\n-///\n-/// ```\n-/// fn main() {\n-///     assert_eq!((3..5), std::ops::Range{ start: 3, end: 5 });\n-///     assert_eq!(3+4+5, (3..6).sum());\n-///\n-///     let arr = [0, 1, 2, 3];\n-///     assert_eq!(arr[ .. ], [0,1,2,3]);\n-///     assert_eq!(arr[ ..3], [0,1,2  ]);\n-///     assert_eq!(arr[1.. ], [  1,2,3]);\n-///     assert_eq!(arr[1..3], [  1,2  ]);  // Range\n-/// }\n-/// ```\n-#[derive(Clone, PartialEq, Eq, Hash)]  // not Copy -- see #27186\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct Range<Idx> {\n-    /// The lower bound of the range (inclusive).\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub start: Idx,\n-    /// The upper bound of the range (exclusive).\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub end: Idx,\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<Idx: fmt::Debug> fmt::Debug for Range<Idx> {\n-    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n-        write!(fmt, \"{:?}..{:?}\", self.start, self.end)\n-    }\n-}\n-\n-#[unstable(feature = \"range_contains\", reason = \"recently added as per RFC\", issue = \"32311\")]\n-impl<Idx: PartialOrd<Idx>> Range<Idx> {\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(range_contains)]\n-    /// fn main() {\n-    ///     assert!( ! (3..5).contains(2));\n-    ///     assert!(   (3..5).contains(3));\n-    ///     assert!(   (3..5).contains(4));\n-    ///     assert!( ! (3..5).contains(5));\n-    ///\n-    ///     assert!( ! (3..3).contains(3));\n-    ///     assert!( ! (3..2).contains(3));\n-    /// }\n-    /// ```\n-    pub fn contains(&self, item: Idx) -> bool {\n-        (self.start <= item) && (item < self.end)\n-    }\n-}\n-\n-/// A range which is only bounded below: { x | start <= x }.\n-/// Use `start..` for its shorthand.\n-///\n-/// See the [`contains`](#method.contains) method for its characterization.\n-///\n-/// Note: Currently, no overflow checking is done for the iterator\n-/// implementation; if you use an integer range and the integer overflows, it\n-/// might panic in debug mode or create an endless loop in release mode. This\n-/// overflow behavior might change in the future.\n-///\n-/// # Examples\n-///\n-/// ```\n-/// fn main() {\n-///     assert_eq!((2..), std::ops::RangeFrom{ start: 2 });\n-///     assert_eq!(2+3+4, (2..).take(3).sum());\n-///\n-///     let arr = [0, 1, 2, 3];\n-///     assert_eq!(arr[ .. ], [0,1,2,3]);\n-///     assert_eq!(arr[ ..3], [0,1,2  ]);\n-///     assert_eq!(arr[1.. ], [  1,2,3]);  // RangeFrom\n-///     assert_eq!(arr[1..3], [  1,2  ]);\n-/// }\n-/// ```\n-#[derive(Clone, PartialEq, Eq, Hash)]  // not Copy -- see #27186\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct RangeFrom<Idx> {\n-    /// The lower bound of the range (inclusive).\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub start: Idx,\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<Idx: fmt::Debug> fmt::Debug for RangeFrom<Idx> {\n-    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n-        write!(fmt, \"{:?}..\", self.start)\n-    }\n-}\n-\n-#[unstable(feature = \"range_contains\", reason = \"recently added as per RFC\", issue = \"32311\")]\n-impl<Idx: PartialOrd<Idx>> RangeFrom<Idx> {\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(range_contains)]\n-    /// fn main() {\n-    ///     assert!( ! (3..).contains(2));\n-    ///     assert!(   (3..).contains(3));\n-    ///     assert!(   (3..).contains(1_000_000_000));\n-    /// }\n-    /// ```\n-    pub fn contains(&self, item: Idx) -> bool {\n-        (self.start <= item)\n-    }\n-}\n-\n-/// A range which is only bounded above: { x | x < end }.\n-/// Use `..end` (two dots) for its shorthand.\n-///\n-/// See the [`contains`](#method.contains) method for its characterization.\n-///\n-/// It cannot serve as an iterator because it doesn't have a starting point.\n-///\n-/// # Examples\n-///\n-/// The `..{integer}` syntax is a `RangeTo`:\n-///\n-/// ```\n-/// assert_eq!((..5), std::ops::RangeTo{ end: 5 });\n-/// ```\n-///\n-/// It does not have an `IntoIterator` implementation, so you can't use it in a\n-/// `for` loop directly. This won't compile:\n-///\n-/// ```ignore\n-/// for i in ..5 {\n-///     // ...\n-/// }\n-/// ```\n-///\n-/// When used as a slicing index, `RangeTo` produces a slice of all array\n-/// elements before the index indicated by `end`.\n-///\n-/// ```\n-/// let arr = [0, 1, 2, 3];\n-/// assert_eq!(arr[ .. ], [0,1,2,3]);\n-/// assert_eq!(arr[ ..3], [0,1,2  ]);  // RangeTo\n-/// assert_eq!(arr[1.. ], [  1,2,3]);\n-/// assert_eq!(arr[1..3], [  1,2  ]);\n-/// ```\n-#[derive(Copy, Clone, PartialEq, Eq, Hash)]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct RangeTo<Idx> {\n-    /// The upper bound of the range (exclusive).\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub end: Idx,\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<Idx: fmt::Debug> fmt::Debug for RangeTo<Idx> {\n-    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n-        write!(fmt, \"..{:?}\", self.end)\n-    }\n-}\n-\n-#[unstable(feature = \"range_contains\", reason = \"recently added as per RFC\", issue = \"32311\")]\n-impl<Idx: PartialOrd<Idx>> RangeTo<Idx> {\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(range_contains)]\n-    /// fn main() {\n-    ///     assert!(   (..5).contains(-1_000_000_000));\n-    ///     assert!(   (..5).contains(4));\n-    ///     assert!( ! (..5).contains(5));\n-    /// }\n-    /// ```\n-    pub fn contains(&self, item: Idx) -> bool {\n-        (item < self.end)\n-    }\n-}\n-\n-/// An inclusive range which is bounded at both ends: { x | start <= x <= end }.\n-/// Use `start...end` (three dots) for its shorthand.\n-///\n-/// See the [`contains`](#method.contains) method for its characterization.\n-///\n-/// # Examples\n-///\n-/// ```\n-/// #![feature(inclusive_range,inclusive_range_syntax)]\n-/// fn main() {\n-///     assert_eq!((3...5), std::ops::RangeInclusive{ start: 3, end: 5 });\n-///     assert_eq!(3+4+5, (3...5).sum());\n-///\n-///     let arr = [0, 1, 2, 3];\n-///     assert_eq!(arr[ ...2], [0,1,2  ]);\n-///     assert_eq!(arr[1...2], [  1,2  ]);  // RangeInclusive\n-/// }\n-/// ```\n-#[derive(Clone, PartialEq, Eq, Hash)]  // not Copy -- see #27186\n-#[unstable(feature = \"inclusive_range\", reason = \"recently added, follows RFC\", issue = \"28237\")]\n-pub struct RangeInclusive<Idx> {\n-    /// The lower bound of the range (inclusive).\n-    #[unstable(feature = \"inclusive_range\",\n-               reason = \"recently added, follows RFC\",\n-               issue = \"28237\")]\n-    pub start: Idx,\n-    /// The upper bound of the range (inclusive).\n-    #[unstable(feature = \"inclusive_range\",\n-               reason = \"recently added, follows RFC\",\n-               issue = \"28237\")]\n-    pub end: Idx,\n-}\n-\n-#[unstable(feature = \"inclusive_range\", reason = \"recently added, follows RFC\", issue = \"28237\")]\n-impl<Idx: fmt::Debug> fmt::Debug for RangeInclusive<Idx> {\n-    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n-        write!(fmt, \"{:?}...{:?}\", self.start, self.end)\n-    }\n-}\n-\n-#[unstable(feature = \"range_contains\", reason = \"recently added as per RFC\", issue = \"32311\")]\n-impl<Idx: PartialOrd<Idx>> RangeInclusive<Idx> {\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(range_contains,inclusive_range_syntax)]\n-    /// fn main() {\n-    ///     assert!( ! (3...5).contains(2));\n-    ///     assert!(   (3...5).contains(3));\n-    ///     assert!(   (3...5).contains(4));\n-    ///     assert!(   (3...5).contains(5));\n-    ///     assert!( ! (3...5).contains(6));\n-    ///\n-    ///     assert!(   (3...3).contains(3));\n-    ///     assert!( ! (3...2).contains(3));\n-    /// }\n-    /// ```\n-    pub fn contains(&self, item: Idx) -> bool {\n-        self.start <= item && item <= self.end\n-    }\n-}\n-\n-/// An inclusive range which is only bounded above: { x | x <= end }.\n-/// Use `...end` (three dots) for its shorthand.\n-///\n-/// See the [`contains`](#method.contains) method for its characterization.\n-///\n-/// It cannot serve as an iterator because it doesn't have a starting point.\n-///\n-/// # Examples\n-///\n-/// The `...{integer}` syntax is a `RangeToInclusive`:\n-///\n-/// ```\n-/// #![feature(inclusive_range,inclusive_range_syntax)]\n-/// assert_eq!((...5), std::ops::RangeToInclusive{ end: 5 });\n-/// ```\n-///\n-/// It does not have an `IntoIterator` implementation, so you can't use it in a\n-/// `for` loop directly. This won't compile:\n-///\n-/// ```ignore\n-/// for i in ...5 {\n-///     // ...\n-/// }\n-/// ```\n-///\n-/// When used as a slicing index, `RangeToInclusive` produces a slice of all\n-/// array elements up to and including the index indicated by `end`.\n-///\n-/// ```\n-/// #![feature(inclusive_range_syntax)]\n-/// let arr = [0, 1, 2, 3];\n-/// assert_eq!(arr[ ...2], [0,1,2  ]);  // RangeToInclusive\n-/// assert_eq!(arr[1...2], [  1,2  ]);\n-/// ```\n-#[derive(Copy, Clone, PartialEq, Eq, Hash)]\n-#[unstable(feature = \"inclusive_range\", reason = \"recently added, follows RFC\", issue = \"28237\")]\n-pub struct RangeToInclusive<Idx> {\n-    /// The upper bound of the range (inclusive)\n-    #[unstable(feature = \"inclusive_range\",\n-               reason = \"recently added, follows RFC\",\n-               issue = \"28237\")]\n-    pub end: Idx,\n-}\n-\n-#[unstable(feature = \"inclusive_range\", reason = \"recently added, follows RFC\", issue = \"28237\")]\n-impl<Idx: fmt::Debug> fmt::Debug for RangeToInclusive<Idx> {\n-    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n-        write!(fmt, \"...{:?}\", self.end)\n-    }\n-}\n-\n-#[unstable(feature = \"range_contains\", reason = \"recently added as per RFC\", issue = \"32311\")]\n-impl<Idx: PartialOrd<Idx>> RangeToInclusive<Idx> {\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(range_contains,inclusive_range_syntax)]\n-    /// fn main() {\n-    ///     assert!(   (...5).contains(-1_000_000_000));\n-    ///     assert!(   (...5).contains(5));\n-    ///     assert!( ! (...5).contains(6));\n-    /// }\n-    /// ```\n-    pub fn contains(&self, item: Idx) -> bool {\n-        (item <= self.end)\n-    }\n-}\n-\n-// RangeToInclusive<Idx> cannot impl From<RangeTo<Idx>>\n-// because underflow would be possible with (..0).into()\n-\n /// The `Deref` trait is used to specify the functionality of dereferencing\n /// operations, like `*v`.\n ///"}, {"sha": "70c35df87ddaf8d1aef329b7ff44a783d4a6623b", "filename": "src/libcore/ops/range.rs", "status": "added", "additions": 366, "deletions": 0, "changes": 366, "blob_url": "https://github.com/rust-lang/rust/blob/cee5a2dd20a93145026119f46f924c7649e4b21c/src%2Flibcore%2Fops%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cee5a2dd20a93145026119f46f924c7649e4b21c/src%2Flibcore%2Fops%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Frange.rs?ref=cee5a2dd20a93145026119f46f924c7649e4b21c", "patch": "@@ -0,0 +1,366 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use fmt;\n+\n+/// An unbounded range. Use `..` (two dots) for its shorthand.\n+///\n+/// Its primary use case is slicing index. It cannot serve as an iterator\n+/// because it doesn't have a starting point.\n+///\n+/// # Examples\n+///\n+/// The `..` syntax is a `RangeFull`:\n+///\n+/// ```\n+/// assert_eq!((..), std::ops::RangeFull);\n+/// ```\n+///\n+/// It does not have an `IntoIterator` implementation, so you can't use it in a\n+/// `for` loop directly. This won't compile:\n+///\n+/// ```ignore\n+/// for i in .. {\n+///    // ...\n+/// }\n+/// ```\n+///\n+/// Used as a slicing index, `RangeFull` produces the full array as a slice.\n+///\n+/// ```\n+/// let arr = [0, 1, 2, 3];\n+/// assert_eq!(arr[ .. ], [0,1,2,3]);  // RangeFull\n+/// assert_eq!(arr[ ..3], [0,1,2  ]);\n+/// assert_eq!(arr[1.. ], [  1,2,3]);\n+/// assert_eq!(arr[1..3], [  1,2  ]);\n+/// ```\n+#[derive(Copy, Clone, PartialEq, Eq, Hash)]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub struct RangeFull;\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl fmt::Debug for RangeFull {\n+    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+        write!(fmt, \"..\")\n+    }\n+}\n+\n+/// A (half-open) range which is bounded at both ends: { x | start <= x < end }.\n+/// Use `start..end` (two dots) for its shorthand.\n+///\n+/// See the [`contains`](#method.contains) method for its characterization.\n+///\n+/// # Examples\n+///\n+/// ```\n+/// fn main() {\n+///     assert_eq!((3..5), std::ops::Range{ start: 3, end: 5 });\n+///     assert_eq!(3+4+5, (3..6).sum());\n+///\n+///     let arr = [0, 1, 2, 3];\n+///     assert_eq!(arr[ .. ], [0,1,2,3]);\n+///     assert_eq!(arr[ ..3], [0,1,2  ]);\n+///     assert_eq!(arr[1.. ], [  1,2,3]);\n+///     assert_eq!(arr[1..3], [  1,2  ]);  // Range\n+/// }\n+/// ```\n+#[derive(Clone, PartialEq, Eq, Hash)]  // not Copy -- see #27186\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub struct Range<Idx> {\n+    /// The lower bound of the range (inclusive).\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub start: Idx,\n+    /// The upper bound of the range (exclusive).\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub end: Idx,\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<Idx: fmt::Debug> fmt::Debug for Range<Idx> {\n+    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+        write!(fmt, \"{:?}..{:?}\", self.start, self.end)\n+    }\n+}\n+\n+#[unstable(feature = \"range_contains\", reason = \"recently added as per RFC\", issue = \"32311\")]\n+impl<Idx: PartialOrd<Idx>> Range<Idx> {\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(range_contains)]\n+    /// fn main() {\n+    ///     assert!( ! (3..5).contains(2));\n+    ///     assert!(   (3..5).contains(3));\n+    ///     assert!(   (3..5).contains(4));\n+    ///     assert!( ! (3..5).contains(5));\n+    ///\n+    ///     assert!( ! (3..3).contains(3));\n+    ///     assert!( ! (3..2).contains(3));\n+    /// }\n+    /// ```\n+    pub fn contains(&self, item: Idx) -> bool {\n+        (self.start <= item) && (item < self.end)\n+    }\n+}\n+\n+/// A range which is only bounded below: { x | start <= x }.\n+/// Use `start..` for its shorthand.\n+///\n+/// See the [`contains`](#method.contains) method for its characterization.\n+///\n+/// Note: Currently, no overflow checking is done for the iterator\n+/// implementation; if you use an integer range and the integer overflows, it\n+/// might panic in debug mode or create an endless loop in release mode. This\n+/// overflow behavior might change in the future.\n+///\n+/// # Examples\n+///\n+/// ```\n+/// fn main() {\n+///     assert_eq!((2..), std::ops::RangeFrom{ start: 2 });\n+///     assert_eq!(2+3+4, (2..).take(3).sum());\n+///\n+///     let arr = [0, 1, 2, 3];\n+///     assert_eq!(arr[ .. ], [0,1,2,3]);\n+///     assert_eq!(arr[ ..3], [0,1,2  ]);\n+///     assert_eq!(arr[1.. ], [  1,2,3]);  // RangeFrom\n+///     assert_eq!(arr[1..3], [  1,2  ]);\n+/// }\n+/// ```\n+#[derive(Clone, PartialEq, Eq, Hash)]  // not Copy -- see #27186\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub struct RangeFrom<Idx> {\n+    /// The lower bound of the range (inclusive).\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub start: Idx,\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<Idx: fmt::Debug> fmt::Debug for RangeFrom<Idx> {\n+    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+        write!(fmt, \"{:?}..\", self.start)\n+    }\n+}\n+\n+#[unstable(feature = \"range_contains\", reason = \"recently added as per RFC\", issue = \"32311\")]\n+impl<Idx: PartialOrd<Idx>> RangeFrom<Idx> {\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(range_contains)]\n+    /// fn main() {\n+    ///     assert!( ! (3..).contains(2));\n+    ///     assert!(   (3..).contains(3));\n+    ///     assert!(   (3..).contains(1_000_000_000));\n+    /// }\n+    /// ```\n+    pub fn contains(&self, item: Idx) -> bool {\n+        (self.start <= item)\n+    }\n+}\n+\n+/// A range which is only bounded above: { x | x < end }.\n+/// Use `..end` (two dots) for its shorthand.\n+///\n+/// See the [`contains`](#method.contains) method for its characterization.\n+///\n+/// It cannot serve as an iterator because it doesn't have a starting point.\n+///\n+/// # Examples\n+///\n+/// The `..{integer}` syntax is a `RangeTo`:\n+///\n+/// ```\n+/// assert_eq!((..5), std::ops::RangeTo{ end: 5 });\n+/// ```\n+///\n+/// It does not have an `IntoIterator` implementation, so you can't use it in a\n+/// `for` loop directly. This won't compile:\n+///\n+/// ```ignore\n+/// for i in ..5 {\n+///     // ...\n+/// }\n+/// ```\n+///\n+/// When used as a slicing index, `RangeTo` produces a slice of all array\n+/// elements before the index indicated by `end`.\n+///\n+/// ```\n+/// let arr = [0, 1, 2, 3];\n+/// assert_eq!(arr[ .. ], [0,1,2,3]);\n+/// assert_eq!(arr[ ..3], [0,1,2  ]);  // RangeTo\n+/// assert_eq!(arr[1.. ], [  1,2,3]);\n+/// assert_eq!(arr[1..3], [  1,2  ]);\n+/// ```\n+#[derive(Copy, Clone, PartialEq, Eq, Hash)]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub struct RangeTo<Idx> {\n+    /// The upper bound of the range (exclusive).\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub end: Idx,\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<Idx: fmt::Debug> fmt::Debug for RangeTo<Idx> {\n+    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+        write!(fmt, \"..{:?}\", self.end)\n+    }\n+}\n+\n+#[unstable(feature = \"range_contains\", reason = \"recently added as per RFC\", issue = \"32311\")]\n+impl<Idx: PartialOrd<Idx>> RangeTo<Idx> {\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(range_contains)]\n+    /// fn main() {\n+    ///     assert!(   (..5).contains(-1_000_000_000));\n+    ///     assert!(   (..5).contains(4));\n+    ///     assert!( ! (..5).contains(5));\n+    /// }\n+    /// ```\n+    pub fn contains(&self, item: Idx) -> bool {\n+        (item < self.end)\n+    }\n+}\n+\n+/// An inclusive range which is bounded at both ends: { x | start <= x <= end }.\n+/// Use `start...end` (three dots) for its shorthand.\n+///\n+/// See the [`contains`](#method.contains) method for its characterization.\n+///\n+/// # Examples\n+///\n+/// ```\n+/// #![feature(inclusive_range,inclusive_range_syntax)]\n+/// fn main() {\n+///     assert_eq!((3...5), std::ops::RangeInclusive{ start: 3, end: 5 });\n+///     assert_eq!(3+4+5, (3...5).sum());\n+///\n+///     let arr = [0, 1, 2, 3];\n+///     assert_eq!(arr[ ...2], [0,1,2  ]);\n+///     assert_eq!(arr[1...2], [  1,2  ]);  // RangeInclusive\n+/// }\n+/// ```\n+#[derive(Clone, PartialEq, Eq, Hash)]  // not Copy -- see #27186\n+#[unstable(feature = \"inclusive_range\", reason = \"recently added, follows RFC\", issue = \"28237\")]\n+pub struct RangeInclusive<Idx> {\n+    /// The lower bound of the range (inclusive).\n+    #[unstable(feature = \"inclusive_range\",\n+               reason = \"recently added, follows RFC\",\n+               issue = \"28237\")]\n+    pub start: Idx,\n+    /// The upper bound of the range (inclusive).\n+    #[unstable(feature = \"inclusive_range\",\n+               reason = \"recently added, follows RFC\",\n+               issue = \"28237\")]\n+    pub end: Idx,\n+}\n+\n+#[unstable(feature = \"inclusive_range\", reason = \"recently added, follows RFC\", issue = \"28237\")]\n+impl<Idx: fmt::Debug> fmt::Debug for RangeInclusive<Idx> {\n+    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+        write!(fmt, \"{:?}...{:?}\", self.start, self.end)\n+    }\n+}\n+\n+#[unstable(feature = \"range_contains\", reason = \"recently added as per RFC\", issue = \"32311\")]\n+impl<Idx: PartialOrd<Idx>> RangeInclusive<Idx> {\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(range_contains,inclusive_range_syntax)]\n+    /// fn main() {\n+    ///     assert!( ! (3...5).contains(2));\n+    ///     assert!(   (3...5).contains(3));\n+    ///     assert!(   (3...5).contains(4));\n+    ///     assert!(   (3...5).contains(5));\n+    ///     assert!( ! (3...5).contains(6));\n+    ///\n+    ///     assert!(   (3...3).contains(3));\n+    ///     assert!( ! (3...2).contains(3));\n+    /// }\n+    /// ```\n+    pub fn contains(&self, item: Idx) -> bool {\n+        self.start <= item && item <= self.end\n+    }\n+}\n+\n+/// An inclusive range which is only bounded above: { x | x <= end }.\n+/// Use `...end` (three dots) for its shorthand.\n+///\n+/// See the [`contains`](#method.contains) method for its characterization.\n+///\n+/// It cannot serve as an iterator because it doesn't have a starting point.\n+///\n+/// # Examples\n+///\n+/// The `...{integer}` syntax is a `RangeToInclusive`:\n+///\n+/// ```\n+/// #![feature(inclusive_range,inclusive_range_syntax)]\n+/// assert_eq!((...5), std::ops::RangeToInclusive{ end: 5 });\n+/// ```\n+///\n+/// It does not have an `IntoIterator` implementation, so you can't use it in a\n+/// `for` loop directly. This won't compile:\n+///\n+/// ```ignore\n+/// for i in ...5 {\n+///     // ...\n+/// }\n+/// ```\n+///\n+/// When used as a slicing index, `RangeToInclusive` produces a slice of all\n+/// array elements up to and including the index indicated by `end`.\n+///\n+/// ```\n+/// #![feature(inclusive_range_syntax)]\n+/// let arr = [0, 1, 2, 3];\n+/// assert_eq!(arr[ ...2], [0,1,2  ]);  // RangeToInclusive\n+/// assert_eq!(arr[1...2], [  1,2  ]);\n+/// ```\n+#[derive(Copy, Clone, PartialEq, Eq, Hash)]\n+#[unstable(feature = \"inclusive_range\", reason = \"recently added, follows RFC\", issue = \"28237\")]\n+pub struct RangeToInclusive<Idx> {\n+    /// The upper bound of the range (inclusive)\n+    #[unstable(feature = \"inclusive_range\",\n+               reason = \"recently added, follows RFC\",\n+               issue = \"28237\")]\n+    pub end: Idx,\n+}\n+\n+#[unstable(feature = \"inclusive_range\", reason = \"recently added, follows RFC\", issue = \"28237\")]\n+impl<Idx: fmt::Debug> fmt::Debug for RangeToInclusive<Idx> {\n+    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+        write!(fmt, \"...{:?}\", self.end)\n+    }\n+}\n+\n+#[unstable(feature = \"range_contains\", reason = \"recently added as per RFC\", issue = \"32311\")]\n+impl<Idx: PartialOrd<Idx>> RangeToInclusive<Idx> {\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(range_contains,inclusive_range_syntax)]\n+    /// fn main() {\n+    ///     assert!(   (...5).contains(-1_000_000_000));\n+    ///     assert!(   (...5).contains(5));\n+    ///     assert!( ! (...5).contains(6));\n+    /// }\n+    /// ```\n+    pub fn contains(&self, item: Idx) -> bool {\n+        (item <= self.end)\n+    }\n+}\n+\n+// RangeToInclusive<Idx> cannot impl From<RangeTo<Idx>>\n+// because underflow would be possible with (..0).into()"}]}