{"sha": "852a49fd9cf3860aa018c1a2d66f644c6813d849", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg1MmE0OWZkOWNmMzg2MGFhMDE4YzFhMmQ2NmY2NDRjNjgxM2Q4NDk=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2014-02-07T11:33:11Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2014-02-11T21:55:10Z"}, "message": "std -- replaces uses where const borrows would be required", "tree": {"sha": "c11dccfda4c48c1d58504751406312a5776942ac", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c11dccfda4c48c1d58504751406312a5776942ac"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/852a49fd9cf3860aa018c1a2d66f644c6813d849", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/852a49fd9cf3860aa018c1a2d66f644c6813d849", "html_url": "https://github.com/rust-lang/rust/commit/852a49fd9cf3860aa018c1a2d66f644c6813d849", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/852a49fd9cf3860aa018c1a2d66f644c6813d849/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "be3cbcb4314570cd974d349b92e761eaef5078fb", "url": "https://api.github.com/repos/rust-lang/rust/commits/be3cbcb4314570cd974d349b92e761eaef5078fb", "html_url": "https://github.com/rust-lang/rust/commit/be3cbcb4314570cd974d349b92e761eaef5078fb"}], "stats": {"total": 195, "additions": 125, "deletions": 70}, "files": [{"sha": "54c0d98c79897c1283fe7c195ac31a65b6f343c8", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 25, "deletions": 17, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/852a49fd9cf3860aa018c1a2d66f644c6813d849/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/852a49fd9cf3860aa018c1a2d66f644c6813d849/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=852a49fd9cf3860aa018c1a2d66f644c6813d849", "patch": "@@ -277,7 +277,7 @@ use str::{StrSlice, OwnedStr};\n use str;\n use to_str::ToStr;\n use uint;\n-use unstable::finally::Finally;\n+use unstable::finally::try_finally;\n use vec::{OwnedVector, MutableVector, ImmutableVector, OwnedCloneableVector};\n use vec;\n \n@@ -473,25 +473,33 @@ pub trait Reader {\n     /// pushed on to the vector, otherwise the amount `len` bytes couldn't be\n     /// read (an error was encountered), and the error is returned.\n     fn push_bytes(&mut self, buf: &mut ~[u8], len: uint) -> IoResult<()> {\n+        struct State<'a> {\n+            buf: &'a mut ~[u8],\n+            total_read: uint\n+        }\n+\n         let start_len = buf.len();\n-        let mut total_read = 0;\n-\n-        buf.reserve_additional(len);\n-        unsafe { buf.set_len(start_len + len); }\n-\n-        (|| {\n-            while total_read < len {\n-                let len = buf.len();\n-                let slice = buf.mut_slice(start_len + total_read, len);\n-                match self.read(slice) {\n-                    Ok(nread) => {\n-                        total_read += nread;\n+        let mut s = State { buf: buf, total_read: 0 };\n+\n+        s.buf.reserve_additional(len);\n+        unsafe { s.buf.set_len(start_len + len); }\n+\n+        try_finally(\n+            &mut s, (),\n+            |s, _| {\n+                while s.total_read < len {\n+                    let len = s.buf.len();\n+                    let slice = s.buf.mut_slice(start_len + s.total_read, len);\n+                    match self.read(slice) {\n+                        Ok(nread) => {\n+                            s.total_read += nread;\n+                        }\n+                        Err(e) => return Err(e)\n                     }\n-                    Err(e) => return Err(e)\n                 }\n-            }\n-            Ok(())\n-        }).finally(|| unsafe { buf.set_len(start_len + total_read) })\n+                Ok(())\n+            },\n+            |s| unsafe { s.buf.set_len(start_len + s.total_read) })\n     }\n \n     /// Reads `len` bytes and gives you back a new vector of length `len`"}, {"sha": "433accecdbcfdbff270ee337aa383265ee08403a", "filename": "src/libstd/unstable/finally.rs", "status": "modified", "additions": 79, "deletions": 35, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/852a49fd9cf3860aa018c1a2d66f644c6813d849/src%2Flibstd%2Funstable%2Ffinally.rs", "raw_url": "https://github.com/rust-lang/rust/raw/852a49fd9cf3860aa018c1a2d66f644c6813d849/src%2Flibstd%2Funstable%2Ffinally.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Ffinally.rs?ref=852a49fd9cf3860aa018c1a2d66f644c6813d849", "patch": "@@ -12,6 +12,11 @@\n The Finally trait provides a method, `finally` on\n stack closures that emulates Java-style try/finally blocks.\n \n+Using the `finally` method is sometimes convenient, but the type rules\n+prohibit any shared, mutable state between the \"try\" case and the\n+\"finally\" case. For advanced cases, the `try_finally` function can\n+also be used. See that function for more details.\n+\n # Example\n \n  ```\n@@ -31,67 +36,106 @@ pub trait Finally<T> {\n     fn finally(&self, dtor: ||) -> T;\n }\n \n-macro_rules! finally_fn {\n-    ($fnty:ty) => {\n-        impl<T> Finally<T> for $fnty {\n-            fn finally(&self, dtor: ||) -> T {\n-                let _d = Finallyalizer {\n-                    dtor: dtor\n-                };\n-                (*self)()\n-            }\n-        }\n+impl<'a,T> Finally<T> for 'a || -> T {\n+    fn finally(&self, dtor: ||) -> T {\n+        try_finally(&mut (), (),\n+                    |_, _| (*self)(),\n+                    |_| dtor())\n     }\n }\n \n-impl<'a,T> Finally<T> for 'a || -> T {\n+impl<T> Finally<T> for fn() -> T {\n     fn finally(&self, dtor: ||) -> T {\n-        let _d = Finallyalizer {\n-            dtor: dtor\n-        };\n-\n-        (*self)()\n+        try_finally(&mut (), (),\n+                    |_, _| (*self)(),\n+                    |_| dtor())\n     }\n }\n \n-finally_fn!(extern \"Rust\" fn() -> T)\n+/**\n+ * The most general form of the `finally` functions. The function\n+ * `try_fn` will be invoked first; whether or not it fails, the\n+ * function `finally_fn` will be invoked next. The two parameters\n+ * `mutate` and `drop` are used to thread state through the two\n+ * closures. `mutate` is used for any shared, mutable state that both\n+ * closures require access to; `drop` is used for any state that the\n+ * `try_fn` requires ownership of.\n+ *\n+ * **WARNING:** While shared, mutable state between the try and finally\n+ * function is often necessary, one must be very careful; the `try`\n+ * function could have failed at any point, so the values of the shared\n+ * state may be inconsistent.\n+ *\n+ * # Example\n+ *\n+ * ```\n+ * struct State<'a> { buffer: &'a mut [u8], len: uint }\n+ * let mut state = State { buffer: buf, len: 0 };\n+ * try_finally(\n+ *     &mut state, (),\n+ *     |state, ()| {\n+ *         // use state.buffer, state.len\n+ *     }\n+ *     |state| {\n+ *         // use state.buffer, state.len to cleanup\n+ *     })\n+ * ```\n+ */\n+pub fn try_finally<T,U,R>(mutate: &mut T,\n+                          drop: U,\n+                          try_fn: |&mut T, U| -> R,\n+                          finally_fn: |&mut T|)\n+                          -> R {\n+    let f = Finallyalizer {\n+        mutate: mutate,\n+        dtor: finally_fn,\n+    };\n+    try_fn(&mut *f.mutate, drop)\n+}\n \n-struct Finallyalizer<'a> {\n-    dtor: 'a ||\n+struct Finallyalizer<'a,A> {\n+    mutate: &'a mut A,\n+    dtor: 'a |&mut A|\n }\n \n #[unsafe_destructor]\n-impl<'a> Drop for Finallyalizer<'a> {\n+impl<'a,A> Drop for Finallyalizer<'a,A> {\n     #[inline]\n     fn drop(&mut self) {\n-        (self.dtor)();\n+        (self.dtor)(self.mutate);\n     }\n }\n \n #[test]\n fn test_success() {\n     let mut i = 0;\n-    (|| {\n-        i = 10;\n-    }).finally(|| {\n-        assert!(!failing());\n-        assert_eq!(i, 10);\n-        i = 20;\n-    });\n+    try_finally(\n+        &mut i, (),\n+        |i, ()| {\n+            *i = 10;\n+        },\n+        |i| {\n+            assert!(!failing());\n+            assert_eq!(*i, 10);\n+            *i = 20;\n+        });\n     assert_eq!(i, 20);\n }\n \n #[test]\n #[should_fail]\n fn test_fail() {\n     let mut i = 0;\n-    (|| {\n-        i = 10;\n-        fail!();\n-    }).finally(|| {\n-        assert!(failing());\n-        assert_eq!(i, 10);\n-    })\n+    try_finally(\n+        &mut i, (),\n+        |i, ()| {\n+            *i = 10;\n+            fail!();\n+        },\n+        |i| {\n+            assert!(failing());\n+            assert_eq!(*i, 10);\n+        })\n }\n \n #[test]"}, {"sha": "bbb11d774b09a1bca8a92da7d8747e29596dd779", "filename": "src/libstd/vec.rs", "status": "modified", "additions": 21, "deletions": 18, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/852a49fd9cf3860aa018c1a2d66f644c6813d849/src%2Flibstd%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/852a49fd9cf3860aa018c1a2d66f644c6813d849/src%2Flibstd%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fvec.rs?ref=852a49fd9cf3860aa018c1a2d66f644c6813d849", "patch": "@@ -119,7 +119,8 @@ use mem;\n use mem::size_of;\n use kinds::marker;\n use uint;\n-use unstable::finally::Finally;\n+use unstable::finally::try_finally;\n+use unstable::intrinsics;\n use unstable::raw::{Repr, Slice, Vec};\n \n /**\n@@ -132,15 +133,16 @@ pub fn from_fn<T>(n_elts: uint, op: |uint| -> T) -> ~[T] {\n     unsafe {\n         let mut v = with_capacity(n_elts);\n         let p = v.as_mut_ptr();\n-        let mut i: uint = 0u;\n-        (|| {\n-            while i < n_elts {\n-                mem::move_val_init(&mut(*ptr::mut_offset(p, i as int)), op(i));\n-                i += 1u;\n-            }\n-        }).finally(|| {\n-            v.set_len(i);\n-        });\n+        let mut i = 0;\n+        try_finally(\n+            &mut i, (),\n+            |i, ()| while *i < n_elts {\n+                mem::move_val_init(\n+                    &mut(*ptr::mut_offset(p, *i as int)),\n+                    op(*i));\n+                *i += 1u;\n+            },\n+            |i| v.set_len(*i));\n         v\n     }\n }\n@@ -160,14 +162,15 @@ pub fn from_elem<T:Clone>(n_elts: uint, t: T) -> ~[T] {\n         let mut v = with_capacity(n_elts);\n         let p = v.as_mut_ptr();\n         let mut i = 0u;\n-        (|| {\n-            while i < n_elts {\n-                mem::move_val_init(&mut(*ptr::mut_offset(p, i as int)), t.clone());\n-                i += 1u;\n-            }\n-        }).finally(|| {\n-            v.set_len(i);\n-        });\n+        try_finally(\n+            &mut i, (),\n+            |i, ()| while *i < n_elts {\n+                mem::move_val_init(\n+                    &mut(*ptr::mut_offset(p, *i as int)),\n+                    t.clone());\n+                *i += 1u;\n+            },\n+            |i| v.set_len(*i));\n         v\n     }\n }"}]}