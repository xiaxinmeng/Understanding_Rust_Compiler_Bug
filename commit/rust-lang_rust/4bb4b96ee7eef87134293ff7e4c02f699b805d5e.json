{"sha": "4bb4b96ee7eef87134293ff7e4c02f699b805d5e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRiYjRiOTZlZTdlZWY4NzEzNDI5M2ZmN2U0YzAyZjY5OWI4MDVkNWU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-08-16T23:52:32Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-08-16T23:52:32Z"}, "message": "Auto merge of #74562 - pickfire:is_ascii_branchless, r=nagisa\n\nRemove branch in optimized is_ascii\n\nPerforms slightly better in short or medium bytes by eliminating\nthe last branch check on `byte_pos == len` and always check the\nlast byte as it is always at most one `usize`.\n\nBenchmark, before `libcore`, after `libcore_new`. It improves\nmedium and short by 1ns but regresses unaligned_tail by 2ns,\neither way we can get unaligned_tail have a tiny chance of 1/8\non a 64 bit machine. I don't think we should bet on that, the\nprobability is worse than dice.\n\n```\ntest long::case00_libcore                     ... bench:          38 ns/iter (+/- 1) = 183947 MB/s\ntest long::case00_libcore_new                 ... bench:          38 ns/iter (+/- 1) = 183947 MB/s\ntest long::case01_iter_all                    ... bench:         227 ns/iter (+/- 6) = 30792 MB/s\ntest long::case02_align_to                    ... bench:          40 ns/iter (+/- 1) = 174750 MB/s\ntest long::case03_align_to_unrolled           ... bench:          19 ns/iter (+/- 1) = 367894 MB/s\ntest medium::case00_libcore                   ... bench:           5 ns/iter (+/- 0) = 6400 MB/s\ntest medium::case00_libcore_new               ... bench:           4 ns/iter (+/- 0) = 8000 MB/s\ntest medium::case01_iter_all                  ... bench:          20 ns/iter (+/- 1) = 1600 MB/s\ntest medium::case02_align_to                  ... bench:           6 ns/iter (+/- 0) = 5333 MB/s\ntest medium::case03_align_to_unrolled         ... bench:           5 ns/iter (+/- 0) = 6400 MB/s\ntest short::case00_libcore                    ... bench:           7 ns/iter (+/- 0) = 1000 MB/s\ntest short::case00_libcore_new                ... bench:           6 ns/iter (+/- 0) = 1166 MB/s\ntest short::case01_iter_all                   ... bench:           5 ns/iter (+/- 0) = 1400 MB/s\ntest short::case02_align_to                   ... bench:           5 ns/iter (+/- 0) = 1400 MB/s\ntest short::case03_align_to_unrolled          ... bench:           5 ns/iter (+/- 1) = 1400 MB/s\ntest unaligned_both::case00_libcore           ... bench:           4 ns/iter (+/- 0) = 7500 MB/s\ntest unaligned_both::case00_libcore_new       ... bench:           4 ns/iter (+/- 0) = 7500 MB/s\ntest unaligned_both::case01_iter_all          ... bench:          26 ns/iter (+/- 0) = 1153 MB/s\ntest unaligned_both::case02_align_to          ... bench:          13 ns/iter (+/- 2) = 2307 MB/s\ntest unaligned_both::case03_align_to_unrolled ... bench:          11 ns/iter (+/- 0) = 2727 MB/s\ntest unaligned_head::case00_libcore           ... bench:           5 ns/iter (+/- 0) = 6200 MB/s\ntest unaligned_head::case00_libcore_new       ... bench:           5 ns/iter (+/- 0) = 6200 MB/s\ntest unaligned_head::case01_iter_all          ... bench:          19 ns/iter (+/- 1) = 1631 MB/s\ntest unaligned_head::case02_align_to          ... bench:          10 ns/iter (+/- 0) = 3100 MB/s\ntest unaligned_head::case03_align_to_unrolled ... bench:          14 ns/iter (+/- 0) = 2214 MB/s\ntest unaligned_tail::case00_libcore           ... bench:           3 ns/iter (+/- 0) = 10333 MB/s\ntest unaligned_tail::case00_libcore_new       ... bench:           5 ns/iter (+/- 0) = 6200 MB/s\ntest unaligned_tail::case01_iter_all          ... bench:          19 ns/iter (+/- 0) = 1631 MB/s\ntest unaligned_tail::case02_align_to          ... bench:          10 ns/iter (+/- 0) = 3100 MB/s\ntest unaligned_tail::case03_align_to_unrolled ... bench:          13 ns/iter (+/- 0) = 2384 MB/s\n```\n\nRough (unfair) maths on improvements for fun: 1ns * 7/8 - 2ns * 1/8 = 0.625ns\n\nInspired by fish and zsh clever trick to highlight missing linefeeds (\u23ce)\nand branchless implementation of binary_search in rust.\n\ncc @thomcc https://github.com/rust-lang/rust/pull/74066\nr? @nagisa", "tree": {"sha": "d25054b3f866152c72cd244d51fb88abdffec9ba", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d25054b3f866152c72cd244d51fb88abdffec9ba"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4bb4b96ee7eef87134293ff7e4c02f699b805d5e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4bb4b96ee7eef87134293ff7e4c02f699b805d5e", "html_url": "https://github.com/rust-lang/rust/commit/4bb4b96ee7eef87134293ff7e4c02f699b805d5e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4bb4b96ee7eef87134293ff7e4c02f699b805d5e/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7e6d6e5f535321c2223f044caba16f97b825009c", "url": "https://api.github.com/repos/rust-lang/rust/commits/7e6d6e5f535321c2223f044caba16f97b825009c", "html_url": "https://github.com/rust-lang/rust/commit/7e6d6e5f535321c2223f044caba16f97b825009c"}, {"sha": "8ec348afdd35752677914ba28146d7b82e901817", "url": "https://api.github.com/repos/rust-lang/rust/commits/8ec348afdd35752677914ba28146d7b82e901817", "html_url": "https://github.com/rust-lang/rust/commit/8ec348afdd35752677914ba28146d7b82e901817"}], "stats": {"total": 15, "additions": 6, "deletions": 9}, "files": [{"sha": "59c536bcff95ecc679a383993b0a7eac8b923372", "filename": "library/core/src/slice/mod.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/4bb4b96ee7eef87134293ff7e4c02f699b805d5e/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bb4b96ee7eef87134293ff7e4c02f699b805d5e/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs?ref=4bb4b96ee7eef87134293ff7e4c02f699b805d5e", "patch": "@@ -3029,7 +3029,7 @@ fn contains_nonascii(v: usize) -> bool {\n ///\n /// - Read the first word with an unaligned load.\n /// - Align the pointer, read subsequent words until end with aligned loads.\n-/// - If there's a tail, the last `usize` from `s` with an unaligned load.\n+/// - Read the last `usize` from `s` with an unaligned load.\n ///\n /// If any of these loads produces something for which `contains_nonascii`\n /// (above) returns true, then we know the answer is false.\n@@ -3077,7 +3077,10 @@ fn is_ascii(s: &[u8]) -> bool {\n     // `align_offset` though.\n     debug_assert_eq!((word_ptr as usize) % mem::align_of::<usize>(), 0);\n \n-    while byte_pos <= len - USIZE_SIZE {\n+    // Read subsequent words until the last aligned word, excluding the last\n+    // aligned word by itself to be done in tail check later, to ensure that\n+    // tail is always one `usize` at most to extra branch `byte_pos == len`.\n+    while byte_pos < len - USIZE_SIZE {\n         debug_assert!(\n             // Sanity check that the read is in bounds\n             (word_ptr as usize + USIZE_SIZE) <= (start.wrapping_add(len) as usize) &&\n@@ -3098,15 +3101,9 @@ fn is_ascii(s: &[u8]) -> bool {\n         word_ptr = unsafe { word_ptr.add(1) };\n     }\n \n-    // If we have anything left over, it should be at-most 1 usize worth of bytes,\n-    // which we check with a read_unaligned.\n-    if byte_pos == len {\n-        return true;\n-    }\n-\n     // Sanity check to ensure there really is only one `usize` left. This should\n     // be guaranteed by our loop condition.\n-    debug_assert!(byte_pos < len && len - byte_pos < USIZE_SIZE);\n+    debug_assert!(byte_pos <= len && len - byte_pos <= USIZE_SIZE);\n \n     // SAFETY: This relies on `len >= USIZE_SIZE`, which we check at the start.\n     let last_word = unsafe { (start.add(len - USIZE_SIZE) as *const usize).read_unaligned() };"}]}