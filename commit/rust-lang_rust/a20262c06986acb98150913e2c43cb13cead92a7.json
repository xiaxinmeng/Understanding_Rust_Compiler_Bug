{"sha": "a20262c06986acb98150913e2c43cb13cead92a7", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEyMDI2MmMwNjk4NmFjYjk4MTUwOTEzZTJjNDNjYjEzY2VhZDkyYTc=", "commit": {"author": {"name": "Gabriel Smith", "email": "ga29smith@gmail.com", "date": "2018-07-22T23:30:52Z"}, "committer": {"name": "Gabriel Smith", "email": "ga29smith@gmail.com", "date": "2018-07-25T00:15:06Z"}, "message": "Properly set the linkage type on non-local statics\n\nFixes issue #18804\n\nSigned-off-by: Gabriel Smith <ga29smith@gmail.com>", "tree": {"sha": "0524754207cded61401ae108c106afab4692fcb7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0524754207cded61401ae108c106afab4692fcb7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a20262c06986acb98150913e2c43cb13cead92a7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a20262c06986acb98150913e2c43cb13cead92a7", "html_url": "https://github.com/rust-lang/rust/commit/a20262c06986acb98150913e2c43cb13cead92a7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a20262c06986acb98150913e2c43cb13cead92a7/comments", "author": {"login": "yodaldevoid", "id": 1204409, "node_id": "MDQ6VXNlcjEyMDQ0MDk=", "avatar_url": "https://avatars.githubusercontent.com/u/1204409?v=4", "gravatar_id": "", "url": "https://api.github.com/users/yodaldevoid", "html_url": "https://github.com/yodaldevoid", "followers_url": "https://api.github.com/users/yodaldevoid/followers", "following_url": "https://api.github.com/users/yodaldevoid/following{/other_user}", "gists_url": "https://api.github.com/users/yodaldevoid/gists{/gist_id}", "starred_url": "https://api.github.com/users/yodaldevoid/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/yodaldevoid/subscriptions", "organizations_url": "https://api.github.com/users/yodaldevoid/orgs", "repos_url": "https://api.github.com/users/yodaldevoid/repos", "events_url": "https://api.github.com/users/yodaldevoid/events{/privacy}", "received_events_url": "https://api.github.com/users/yodaldevoid/received_events", "type": "User", "site_admin": false}, "committer": {"login": "yodaldevoid", "id": 1204409, "node_id": "MDQ6VXNlcjEyMDQ0MDk=", "avatar_url": "https://avatars.githubusercontent.com/u/1204409?v=4", "gravatar_id": "", "url": "https://api.github.com/users/yodaldevoid", "html_url": "https://github.com/yodaldevoid", "followers_url": "https://api.github.com/users/yodaldevoid/followers", "following_url": "https://api.github.com/users/yodaldevoid/following{/other_user}", "gists_url": "https://api.github.com/users/yodaldevoid/gists{/gist_id}", "starred_url": "https://api.github.com/users/yodaldevoid/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/yodaldevoid/subscriptions", "organizations_url": "https://api.github.com/users/yodaldevoid/orgs", "repos_url": "https://api.github.com/users/yodaldevoid/repos", "events_url": "https://api.github.com/users/yodaldevoid/events{/privacy}", "received_events_url": "https://api.github.com/users/yodaldevoid/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e8bc064c5ecf7775999beef233e2d82c9a534362", "url": "https://api.github.com/repos/rust-lang/rust/commits/e8bc064c5ecf7775999beef233e2d82c9a534362", "html_url": "https://github.com/rust-lang/rust/commit/e8bc064c5ecf7775999beef233e2d82c9a534362"}], "stats": {"total": 59, "additions": 53, "deletions": 6}, "files": [{"sha": "1d42c84e2befb113691452915aa76e7f87f2bf94", "filename": "src/librustc_codegen_llvm/consts.rs", "status": "modified", "additions": 53, "deletions": 6, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/a20262c06986acb98150913e2c43cb13cead92a7/src%2Flibrustc_codegen_llvm%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a20262c06986acb98150913e2c43cb13cead92a7/src%2Flibrustc_codegen_llvm%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fconsts.rs?ref=a20262c06986acb98150913e2c43cb13cead92a7", "patch": "@@ -119,6 +119,8 @@ pub fn get_static(cx: &CodegenCx, def_id: DefId) -> ValueRef {\n     let ty = instance.ty(cx.tcx);\n     let sym = cx.tcx.symbol_name(instance).as_str();\n \n+    debug!(\"get_static: sym={} instance={:?}\", sym, instance);\n+\n     let g = if let Some(id) = cx.tcx.hir.as_local_node_id(def_id) {\n \n         let llty = cx.layout_of(ty).llvm_type(cx);\n@@ -145,6 +147,8 @@ pub fn get_static(cx: &CodegenCx, def_id: DefId) -> ValueRef {\n                 ref attrs, span, node: hir::ForeignItemKind::Static(..), ..\n             }) => {\n                 let g = if let Some(linkage) = cx.tcx.codegen_fn_attrs(def_id).linkage {\n+                    debug!(\"get_static: sym={} linkage={:?}\", sym, linkage);\n+\n                     // If this is a static with a linkage specified, then we need to handle\n                     // it a little specially. The typesystem prevents things like &T and\n                     // extern \"C\" fn() from being non-null, so we can't just declare a\n@@ -188,6 +192,8 @@ pub fn get_static(cx: &CodegenCx, def_id: DefId) -> ValueRef {\n             item => bug!(\"get_static: expected static, found {:?}\", item)\n         };\n \n+        debug!(\"get_static: sym={} attrs={:?}\", sym, attrs);\n+\n         for attr in attrs {\n             if attr.check_name(\"thread_local\") {\n                 llvm::set_thread_local_mode(g, cx.tls_model);\n@@ -197,19 +203,60 @@ pub fn get_static(cx: &CodegenCx, def_id: DefId) -> ValueRef {\n         g\n     } else {\n         // FIXME(nagisa): perhaps the map of externs could be offloaded to llvm somehow?\n-        // FIXME(nagisa): investigate whether it can be changed into define_global\n-        let g = declare::declare_global(cx, &sym, cx.layout_of(ty).llvm_type(cx));\n+        debug!(\"get_static: sym={} item_attr={:?}\", sym, cx.tcx.item_attrs(def_id));\n+\n+        let codegen_fn_attrs = cx.tcx.codegen_fn_attrs(def_id);\n+        let llty = cx.layout_of(ty).llvm_type(cx);\n+        let g = if let Some(linkage) = codegen_fn_attrs.linkage {\n+            debug!(\"get_static: sym={} linkage={:?}\", sym, linkage);\n+\n+            // If this is a static with a linkage specified, then we need to handle\n+            // it a little specially. The typesystem prevents things like &T and\n+            // extern \"C\" fn() from being non-null, so we can't just declare a\n+            // static and call it a day. Some linkages (like weak) will make it such\n+            // that the static actually has a null value.\n+            let llty2 = match ty.sty {\n+                ty::TyRawPtr(ref mt) => cx.layout_of(mt.ty).llvm_type(cx),\n+                _ => {\n+                    bug!(\"must have type `*const T` or `*mut T`\")\n+                }\n+            };\n+            unsafe {\n+                // Declare a symbol `foo` with the desired linkage.\n+                let g1 = declare::declare_global(cx, &sym, llty2);\n+                llvm::LLVMRustSetLinkage(g1, base::linkage_to_llvm(linkage));\n+\n+                // Declare an internal global `extern_with_linkage_foo` which\n+                // is initialized with the address of `foo`.  If `foo` is\n+                // discarded during linking (for example, if `foo` has weak\n+                // linkage and there are no definitions), then\n+                // `extern_with_linkage_foo` will instead be initialized to\n+                // zero.\n+                let mut real_name = \"_rust_extern_with_linkage_\".to_string();\n+                real_name.push_str(&sym);\n+                let g2 = declare::define_global(cx, &real_name, llty).unwrap_or_else(||{\n+                    bug!(\"symbol `{}` is already defined\", &sym)\n+                });\n+                llvm::LLVMRustSetLinkage(g2, llvm::Linkage::InternalLinkage);\n+                llvm::LLVMSetInitializer(g2, g1);\n+                g2\n+            }\n+        } else {\n+            // Generate an external declaration.\n+            // FIXME(nagisa): investigate whether it can be changed into define_global\n+            declare::declare_global(cx, &sym, llty)\n+        };\n+\n         // Thread-local statics in some other crate need to *always* be linked\n         // against in a thread-local fashion, so we need to be sure to apply the\n         // thread-local attribute locally if it was present remotely. If we\n         // don't do this then linker errors can be generated where the linker\n         // complains that one object files has a thread local version of the\n         // symbol and another one doesn't.\n-        for attr in cx.tcx.get_attrs(def_id).iter() {\n-            if attr.check_name(\"thread_local\") {\n-                llvm::set_thread_local_mode(g, cx.tls_model);\n-            }\n+        if codegen_fn_attrs.flags.contains(CodegenFnAttrFlags::THREAD_LOCAL) {\n+            llvm::set_thread_local_mode(g, cx.tls_model);\n         }\n+\n         if cx.use_dll_storage_attrs && !cx.tcx.is_foreign_item(def_id) {\n             // This item is external but not foreign, i.e. it originates from an external Rust\n             // crate. Since we don't know whether this crate will be linked dynamically or"}]}