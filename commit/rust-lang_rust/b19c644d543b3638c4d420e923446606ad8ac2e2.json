{"sha": "b19c644d543b3638c4d420e923446606ad8ac2e2", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIxOWM2NDRkNTQzYjM2MzhjNGQ0MjBlOTIzNDQ2NjA2YWQ4YWMyZTI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-04-18T21:36:53Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-04-18T21:36:53Z"}, "message": "auto merge of #5921 : brson/rust/pipes, r=brson\n\nThis builds on #5909. I've been combing through the pipes code to understand it and started refactoring a bit.\r\n\r\n* Removes pipes::spawn_* functions. These are not particularly useful since they deal with low-level pipes types.\r\n* Inlines the protocol-compiled definitions of `oneshot` and `streamp`. These are the only two uses of the protocol compiler in core and I'm inlining them so I can understand what they are doing as I work on pipes. I may un-inline them in the future.\r\n* Removes redundant functions from core::comm\r\n* Change the constructors to use the `new` convention", "tree": {"sha": "8dd707b4a620e1b69bb9cc715944e822265483f4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8dd707b4a620e1b69bb9cc715944e822265483f4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b19c644d543b3638c4d420e923446606ad8ac2e2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b19c644d543b3638c4d420e923446606ad8ac2e2", "html_url": "https://github.com/rust-lang/rust/commit/b19c644d543b3638c4d420e923446606ad8ac2e2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b19c644d543b3638c4d420e923446606ad8ac2e2/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2a864852774e924f1f9bb68da34adca736211545", "url": "https://api.github.com/repos/rust-lang/rust/commits/2a864852774e924f1f9bb68da34adca736211545", "html_url": "https://github.com/rust-lang/rust/commit/2a864852774e924f1f9bb68da34adca736211545"}, {"sha": "decd3901d5d63013a98ecc481c441f3f793b5207", "url": "https://api.github.com/repos/rust-lang/rust/commits/decd3901d5d63013a98ecc481c441f3f793b5207", "html_url": "https://github.com/rust-lang/rust/commit/decd3901d5d63013a98ecc481c441f3f793b5207"}], "stats": {"total": 945, "additions": 511, "deletions": 434}, "files": [{"sha": "bed696748306eb43c347797983c3e0e5cca79893", "filename": "doc/tutorial-tasks.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b19c644d543b3638c4d420e923446606ad8ac2e2/doc%2Ftutorial-tasks.md", "raw_url": "https://github.com/rust-lang/rust/raw/b19c644d543b3638c4d420e923446606ad8ac2e2/doc%2Ftutorial-tasks.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial-tasks.md?ref=b19c644d543b3638c4d420e923446606ad8ac2e2", "patch": "@@ -236,7 +236,7 @@ Instead we can use a `SharedChan`, a type that allows a single\n use core::comm::{stream, SharedChan};\n \n let (port, chan) = stream();\n-let chan = SharedChan(chan);\n+let chan = SharedChan::new(chan);\n \n for uint::range(0, 3) |init_val| {\n     // Create a new channel handle to distribute to the child task"}, {"sha": "7d78b84dc80059036d671df9697c260d6a2603bc", "filename": "src/compiletest/procsrv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b19c644d543b3638c4d420e923446606ad8ac2e2/src%2Fcompiletest%2Fprocsrv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b19c644d543b3638c4d420e923446606ad8ac2e2/src%2Fcompiletest%2Fprocsrv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fprocsrv.rs?ref=b19c644d543b3638c4d420e923446606ad8ac2e2", "patch": "@@ -73,7 +73,7 @@ pub fn run(lib_path: ~str,\n \n \n     writeclose(pipe_in.out, input);\n-    let p = comm::PortSet();\n+    let p = comm::PortSet::new();\n     let ch = p.chan();\n     do task::spawn_sched(task::SingleThreaded) || {\n         let errput = readclose(pipe_err.in);"}, {"sha": "fc13463bd1c2af5e3f49fb5b5671282c3abddf77", "filename": "src/libcore/comm.rs", "status": "modified", "additions": 285, "deletions": 209, "changes": 494, "blob_url": "https://github.com/rust-lang/rust/blob/b19c644d543b3638c4d420e923446606ad8ac2e2/src%2Flibcore%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b19c644d543b3638c4d420e923446606ad8ac2e2/src%2Flibcore%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcomm.rs?ref=b19c644d543b3638c4d420e923446606ad8ac2e2", "patch": "@@ -19,6 +19,7 @@ use option::{Option, Some, None};\n use uint;\n use unstable;\n use vec;\n+use unstable::Exclusive;\n \n use pipes::{recv, try_recv, wait_many, peek, PacketHeader};\n \n@@ -56,146 +57,150 @@ pub trait Peekable<T> {\n     fn peek(&self) -> bool;\n }\n \n-/// Returns the index of an endpoint that is ready to receive.\n-pub fn selecti<T: Selectable>(endpoints: &[T]) -> uint {\n-    wait_many(endpoints)\n-}\n-\n-/// Returns 0 or 1 depending on which endpoint is ready to receive\n-pub fn select2i<A: Selectable, B: Selectable>(a: &A, b: &B) ->\n-        Either<(), ()> {\n-    match wait_many([a.header(), b.header()]) {\n-      0 => Left(()),\n-      1 => Right(()),\n-      _ => fail!(~\"wait returned unexpected index\")\n-    }\n-}\n \n // Streams - Make pipes a little easier in general.\n \n-proto! streamp (\n+/*proto! streamp (\n     Open:send<T: Owned> {\n         data(T) -> Open<T>\n     }\n-)\n+)*/\n \n-#[doc(hidden)]\n-struct Chan_<T> {\n-    mut endp: Option<streamp::client::Open<T>>\n-}\n+#[allow(non_camel_case_types)]\n+pub mod streamp {\n+    priv use core::kinds::Owned;\n \n-/// An endpoint that can send many messages.\n-pub enum Chan<T> {\n-    Chan_(Chan_<T>)\n+    pub fn init<T: Owned>() -> (client::Open<T>, server::Open<T>) {\n+        pub use core::pipes::HasBuffer;\n+        ::core::pipes::entangle()\n+    }\n+\n+    #[allow(non_camel_case_types)]\n+    pub enum Open<T> { pub data(T, server::Open<T>), }\n+\n+    #[allow(non_camel_case_types)]\n+    pub mod client {\n+        priv use core::kinds::Owned;\n+\n+        #[allow(non_camel_case_types)]\n+        pub fn try_data<T: Owned>(pipe: Open<T>, x_0: T) ->\n+            ::core::option::Option<Open<T>> {\n+            {\n+                use super::data;\n+                let (c, s) = ::core::pipes::entangle();\n+                let message = data(x_0, s);\n+                if ::core::pipes::send(pipe, message) {\n+                    ::core::pipes::rt::make_some(c)\n+                } else { ::core::pipes::rt::make_none() }\n+            }\n+        }\n+\n+        #[allow(non_camel_case_types)]\n+        pub fn data<T: Owned>(pipe: Open<T>, x_0: T) -> Open<T> {\n+            {\n+                use super::data;\n+                let (c, s) = ::core::pipes::entangle();\n+                let message = data(x_0, s);\n+                ::core::pipes::send(pipe, message);\n+                c\n+            }\n+        }\n+\n+        #[allow(non_camel_case_types)]\n+        pub type Open<T> = ::core::pipes::SendPacket<super::Open<T>>;\n+    }\n+\n+    #[allow(non_camel_case_types)]\n+    pub mod server {\n+        priv use core::kinds::Owned;\n+\n+        #[allow(non_camel_case_types)]\n+        pub type Open<T> = ::core::pipes::RecvPacket<super::Open<T>>;\n+    }\n }\n \n-struct Port_<T> {\n-    mut endp: Option<streamp::server::Open<T>>,\n+/// An endpoint that can send many messages.\n+pub struct Chan<T> {\n+    mut endp: Option<streamp::client::Open<T>>\n }\n \n /// An endpoint that can receive many messages.\n-pub enum Port<T> {\n-    Port_(Port_<T>)\n+pub struct Port<T> {\n+    mut endp: Option<streamp::server::Open<T>>,\n }\n \n-/** Creates a `(chan, port)` pair.\n+/** Creates a `(Port, Chan)` pair.\n \n These allow sending or receiving an unlimited number of messages.\n \n */\n pub fn stream<T:Owned>() -> (Port<T>, Chan<T>) {\n     let (c, s) = streamp::init();\n \n-    (Port_(Port_ { endp: Some(s) }), Chan_(Chan_{ endp: Some(c) }))\n-}\n-\n-// Add an inherent method so that imports of GenericChan are not\n-// required.\n-pub impl<T: Owned> Chan<T> {\n-    fn send(&self, x: T) { chan_send(self, x) }\n-    fn try_send(&self, x: T) -> bool { chan_try_send(self, x) }\n+    (Port { endp: Some(s) }, Chan { endp: Some(c) })\n }\n \n impl<T: Owned> GenericChan<T> for Chan<T> {\n-    fn send(&self, x: T) { chan_send(self, x) }\n-}\n-\n-#[inline(always)]\n-fn chan_send<T:Owned>(self: &Chan<T>, x: T) {\n-    let mut endp = None;\n-    endp <-> self.endp;\n-    self.endp = Some(\n-        streamp::client::data(endp.unwrap(), x))\n+    #[inline(always)]\n+    fn send(&self, x: T) {\n+        let mut endp = None;\n+        endp <-> self.endp;\n+        self.endp = Some(\n+            streamp::client::data(endp.unwrap(), x))\n+    }\n }\n \n impl<T: Owned> GenericSmartChan<T> for Chan<T> {\n+    #[inline(always)]\n     fn try_send(&self, x: T) -> bool {\n-        chan_try_send(self, x)\n-    }\n-}\n-\n-#[inline(always)]\n-fn chan_try_send<T:Owned>(self: &Chan<T>, x: T) -> bool {\n-    let mut endp = None;\n-    endp <-> self.endp;\n-    match streamp::client::try_data(endp.unwrap(), x) {\n-        Some(next) => {\n-            self.endp = Some(next);\n-            true\n+        let mut endp = None;\n+        endp <-> self.endp;\n+        match streamp::client::try_data(endp.unwrap(), x) {\n+            Some(next) => {\n+                self.endp = Some(next);\n+                true\n+            }\n+            None => false\n         }\n-        None => false\n     }\n }\n \n-// Use an inherent impl so that imports are not required:\n-pub impl<T: Owned> Port<T> {\n-    fn recv(&self) -> T { port_recv(self) }\n-    fn try_recv(&self) -> Option<T> { port_try_recv(self) }\n-    fn peek(&self) -> bool { port_peek(self) }\n-}\n-\n impl<T: Owned> GenericPort<T> for Port<T> {\n-    // These two calls will prefer the inherent versions above:\n-    fn recv(&self) -> T { port_recv(self) }\n-    fn try_recv(&self) -> Option<T> { port_try_recv(self) }\n-}\n-\n-#[inline(always)]\n-fn port_recv<T:Owned>(self: &Port<T>) -> T {\n-    let mut endp = None;\n-    endp <-> self.endp;\n-    let streamp::data(x, endp) = recv(endp.unwrap());\n-    self.endp = Some(endp);\n-    x\n-}\n-\n-#[inline(always)]\n-fn port_try_recv<T:Owned>(self: &Port<T>) -> Option<T> {\n-    let mut endp = None;\n-    endp <-> self.endp;\n-    match try_recv(endp.unwrap()) {\n-        Some(streamp::data(x, endp)) => {\n-            self.endp = Some(endp);\n-            Some(x)\n+    #[inline(always)]\n+    fn recv(&self) -> T {\n+        let mut endp = None;\n+        endp <-> self.endp;\n+        let streamp::data(x, endp) = recv(endp.unwrap());\n+        self.endp = Some(endp);\n+        x\n+    }\n+\n+    #[inline(always)]\n+    fn try_recv(&self) -> Option<T> {\n+        let mut endp = None;\n+        endp <-> self.endp;\n+        match try_recv(endp.unwrap()) {\n+            Some(streamp::data(x, endp)) => {\n+                self.endp = Some(endp);\n+                Some(x)\n+            }\n+            None => None\n         }\n-        None => None\n     }\n }\n \n impl<T: Owned> Peekable<T> for Port<T> {\n-    fn peek(&self) -> bool { port_peek(self) }\n-}\n-\n-#[inline(always)]\n-fn port_peek<T:Owned>(self: &Port<T>) -> bool {\n-    let mut endp = None;\n-    endp <-> self.endp;\n-    let peek = match &endp {\n-        &Some(ref endp) => peek(endp),\n-        &None => fail!(~\"peeking empty stream\")\n-    };\n-    self.endp <-> endp;\n-    peek\n+    #[inline(always)]\n+    fn peek(&self) -> bool {\n+        let mut endp = None;\n+        endp <-> self.endp;\n+        let peek = match &endp {\n+            &Some(ref endp) => peek(endp),\n+            &None => fail!(~\"peeking empty stream\")\n+        };\n+        self.endp <-> endp;\n+        peek\n+    }\n }\n \n impl<T: Owned> Selectable for Port<T> {\n@@ -214,20 +219,14 @@ pub struct PortSet<T> {\n     mut ports: ~[Port<T>],\n }\n \n-pub fn PortSet<T: Owned>() -> PortSet<T>{\n-    PortSet {\n-        ports: ~[]\n-    }\n-}\n+pub impl<T: Owned> PortSet<T> {\n \n-// Use an inherent impl so that imports are not required:\n-pub impl<T:Owned> PortSet<T> {\n-    fn recv(&self) -> T { port_set_recv(self) }\n-    fn try_recv(&self) -> Option<T> { port_set_try_recv(self) }\n-    fn peek(&self) -> bool { port_set_peek(self) }\n-}\n+    fn new() -> PortSet<T> {\n+        PortSet {\n+            ports: ~[]\n+        }\n+    }\n \n-pub impl<T: Owned> PortSet<T> {\n     fn add(&self, port: Port<T>) {\n         self.ports.push(port)\n     }\n@@ -240,135 +239,163 @@ pub impl<T: Owned> PortSet<T> {\n }\n \n impl<T:Owned> GenericPort<T> for PortSet<T> {\n-    fn try_recv(&self) -> Option<T> { port_set_try_recv(self) }\n-    fn recv(&self) -> T { port_set_recv(self) }\n-}\n-\n-#[inline(always)]\n-fn port_set_recv<T:Owned>(self: &PortSet<T>) -> T {\n-    port_set_try_recv(self).expect(\"port_set: endpoints closed\")\n-}\n-\n-#[inline(always)]\n-fn port_set_try_recv<T:Owned>(self: &PortSet<T>) -> Option<T> {\n-    let mut result = None;\n-    // we have to swap the ports array so we aren't borrowing\n-    // aliasable mutable memory.\n-    let mut ports = ~[];\n-    ports <-> self.ports;\n-    while result.is_none() && ports.len() > 0 {\n-        let i = wait_many(ports);\n-        match ports[i].try_recv() {\n-            Some(m) => {\n-                result = Some(m);\n-            }\n-            None => {\n-                // Remove this port.\n-                let _ = ports.swap_remove(i);\n+    fn try_recv(&self) -> Option<T> {\n+        let mut result = None;\n+        // we have to swap the ports array so we aren't borrowing\n+        // aliasable mutable memory.\n+        let mut ports = ~[];\n+        ports <-> self.ports;\n+        while result.is_none() && ports.len() > 0 {\n+            let i = wait_many(ports);\n+            match ports[i].try_recv() {\n+                Some(m) => {\n+                    result = Some(m);\n+                }\n+                None => {\n+                    // Remove this port.\n+                    let _ = ports.swap_remove(i);\n+                }\n             }\n         }\n+        ports <-> self.ports;\n+        result\n+    }\n+    fn recv(&self) -> T {\n+        self.try_recv().expect(\"port_set: endpoints closed\")\n     }\n-    ports <-> self.ports;\n-    result\n }\n \n impl<T: Owned> Peekable<T> for PortSet<T> {\n-    fn peek(&self) -> bool { port_set_peek(self) }\n-}\n-\n-#[inline(always)]\n-fn port_set_peek<T:Owned>(self: &PortSet<T>) -> bool {\n-    // It'd be nice to use self.port.each, but that version isn't\n-    // pure.\n-    for uint::range(0, vec::uniq_len(&const self.ports)) |i| {\n-        // XXX: Botch pending demuting.\n-        unsafe {\n-            let port: &Port<T> = cast::transmute(&mut self.ports[i]);\n-            if port.peek() { return true }\n+    fn peek(&self) -> bool {\n+        // It'd be nice to use self.port.each, but that version isn't\n+        // pure.\n+        for uint::range(0, vec::uniq_len(&const self.ports)) |i| {\n+            // XXX: Botch pending demuting.\n+            unsafe {\n+                let port: &Port<T> = cast::transmute(&mut self.ports[i]);\n+                if port.peek() { return true }\n+            }\n         }\n+        false\n     }\n-    false\n }\n \n-\n /// A channel that can be shared between many senders.\n-pub type SharedChan<T> = unstable::Exclusive<Chan<T>>;\n-\n-pub impl<T: Owned> SharedChan<T> {\n-    fn send(&self, x: T) { shared_chan_send(self, x) }\n-    fn try_send(&self, x: T) -> bool { shared_chan_try_send(self, x) }\n+pub struct SharedChan<T> {\n+    ch: Exclusive<Chan<T>>\n }\n \n-impl<T: Owned> GenericChan<T> for SharedChan<T> {\n-    fn send(&self, x: T) { shared_chan_send(self, x) }\n+impl<T: Owned> SharedChan<T> {\n+    /// Converts a `chan` into a `shared_chan`.\n+    pub fn new(c: Chan<T>) -> SharedChan<T> {\n+        SharedChan { ch: unstable::exclusive(c) }\n+    }\n }\n \n-#[inline(always)]\n-fn shared_chan_send<T:Owned>(self: &SharedChan<T>, x: T) {\n-    let mut xx = Some(x);\n-    do self.with_imm |chan| {\n-        let mut x = None;\n-        x <-> xx;\n-        chan.send(x.unwrap())\n+impl<T: Owned> GenericChan<T> for SharedChan<T> {\n+    fn send(&self, x: T) {\n+        let mut xx = Some(x);\n+        do self.ch.with_imm |chan| {\n+            let mut x = None;\n+            x <-> xx;\n+            chan.send(x.unwrap())\n+        }\n     }\n }\n \n impl<T: Owned> GenericSmartChan<T> for SharedChan<T> {\n-    fn try_send(&self, x: T) -> bool { shared_chan_try_send(self, x) }\n+    fn try_send(&self, x: T) -> bool {\n+        let mut xx = Some(x);\n+        do self.ch.with_imm |chan| {\n+            let mut x = None;\n+            x <-> xx;\n+            chan.try_send(x.unwrap())\n+        }\n+    }\n }\n \n-#[inline(always)]\n-fn shared_chan_try_send<T:Owned>(self: &SharedChan<T>, x: T) -> bool {\n-    let mut xx = Some(x);\n-    do self.with_imm |chan| {\n-        let mut x = None;\n-        x <-> xx;\n-        chan.try_send(x.unwrap())\n+impl<T: Owned> ::clone::Clone for SharedChan<T> {\n+    fn clone(&self) -> SharedChan<T> {\n+        SharedChan { ch: self.ch.clone() }\n     }\n }\n \n-/// Converts a `chan` into a `shared_chan`.\n-pub fn SharedChan<T:Owned>(c: Chan<T>) -> SharedChan<T> {\n-    unstable::exclusive(c)\n-}\n+/*proto! oneshot (\n+    Oneshot:send<T:Owned> {\n+        send(T) -> !\n+    }\n+)*/\n+\n+#[allow(non_camel_case_types)]\n+pub mod oneshot {\n+    priv use core::kinds::Owned;\n+\n+    pub fn init<T: Owned>() -> (client::Oneshot<T>, server::Oneshot<T>) {\n+        pub use core::pipes::HasBuffer;\n+\n+        let buffer =\n+            ~::core::pipes::Buffer{\n+            header: ::core::pipes::BufferHeader(),\n+            data: __Buffer{\n+                Oneshot: ::core::pipes::mk_packet::<Oneshot<T>>()\n+            },\n+        };\n+        do ::core::pipes::entangle_buffer(buffer) |buffer, data| {\n+            {\n+                data.Oneshot.set_buffer(buffer);\n+                ::ptr::addr_of(&(data.Oneshot))\n+            }\n+        }\n+    }\n+    #[allow(non_camel_case_types)]\n+    pub enum Oneshot<T> { pub send(T), }\n+    #[allow(non_camel_case_types)]\n+    pub struct __Buffer<T> {\n+        Oneshot: ::core::pipes::Packet<Oneshot<T>>,\n+    }\n \n-/// Receive a message from one of two endpoints.\n-pub trait Select2<T: Owned, U: Owned> {\n-    /// Receive a message or return `None` if a connection closes.\n-    fn try_select(&self) -> Either<Option<T>, Option<U>>;\n-    /// Receive a message or fail if a connection closes.\n-    fn select(&self) -> Either<T, U>;\n-}\n+    #[allow(non_camel_case_types)]\n+    pub mod client {\n \n-impl<T: Owned, U: Owned,\n-     Left: Selectable + GenericPort<T>,\n-     Right: Selectable + GenericPort<U>>\n-    Select2<T, U> for (Left, Right) {\n+        priv use core::kinds::Owned;\n \n-    fn select(&self) -> Either<T, U> {\n-        match *self {\n-          (ref lp, ref rp) => match select2i(lp, rp) {\n-            Left(()) => Left (lp.recv()),\n-            Right(()) => Right(rp.recv())\n-          }\n+        #[allow(non_camel_case_types)]\n+        pub fn try_send<T: Owned>(pipe: Oneshot<T>, x_0: T) ->\n+            ::core::option::Option<()> {\n+            {\n+                use super::send;\n+                let message = send(x_0);\n+                if ::core::pipes::send(pipe, message) {\n+                    ::core::pipes::rt::make_some(())\n+                } else { ::core::pipes::rt::make_none() }\n+            }\n         }\n-    }\n \n-    fn try_select(&self) -> Either<Option<T>, Option<U>> {\n-        match *self {\n-          (ref lp, ref rp) => match select2i(lp, rp) {\n-            Left(()) => Left (lp.try_recv()),\n-            Right(()) => Right(rp.try_recv())\n-          }\n+        #[allow(non_camel_case_types)]\n+        pub fn send<T: Owned>(pipe: Oneshot<T>, x_0: T) {\n+            {\n+                use super::send;\n+                let message = send(x_0);\n+                ::core::pipes::send(pipe, message);\n+            }\n         }\n+\n+        #[allow(non_camel_case_types)]\n+        pub type Oneshot<T> =\n+            ::core::pipes::SendPacketBuffered<super::Oneshot<T>,\n+                                              super::__Buffer<T>>;\n     }\n-}\n \n-proto! oneshot (\n-    Oneshot:send<T:Owned> {\n-        send(T) -> !\n+    #[allow(non_camel_case_types)]\n+    pub mod server {\n+        priv use core::kinds::Owned;\n+\n+        #[allow(non_camel_case_types)]\n+        pub type Oneshot<T> =\n+            ::core::pipes::RecvPacketBuffered<super::Oneshot<T>,\n+                                              super::__Buffer<T>>;\n     }\n-)\n+}\n \n /// The send end of a oneshot pipe.\n pub type ChanOne<T> = oneshot::client::Oneshot<T>;\n@@ -425,6 +452,55 @@ pub fn try_send_one<T: Owned>(chan: ChanOne<T>, data: T)\n     oneshot::client::try_send(chan, data).is_some()\n }\n \n+\n+\n+/// Returns the index of an endpoint that is ready to receive.\n+pub fn selecti<T: Selectable>(endpoints: &[T]) -> uint {\n+    wait_many(endpoints)\n+}\n+\n+/// Returns 0 or 1 depending on which endpoint is ready to receive\n+pub fn select2i<A: Selectable, B: Selectable>(a: &A, b: &B) ->\n+        Either<(), ()> {\n+    match wait_many([a.header(), b.header()]) {\n+      0 => Left(()),\n+      1 => Right(()),\n+      _ => fail!(~\"wait returned unexpected index\")\n+    }\n+}\n+\n+/// Receive a message from one of two endpoints.\n+pub trait Select2<T: Owned, U: Owned> {\n+    /// Receive a message or return `None` if a connection closes.\n+    fn try_select(&self) -> Either<Option<T>, Option<U>>;\n+    /// Receive a message or fail if a connection closes.\n+    fn select(&self) -> Either<T, U>;\n+}\n+\n+impl<T: Owned, U: Owned,\n+     Left: Selectable + GenericPort<T>,\n+     Right: Selectable + GenericPort<U>>\n+    Select2<T, U> for (Left, Right) {\n+\n+    fn select(&self) -> Either<T, U> {\n+        match *self {\n+          (ref lp, ref rp) => match select2i(lp, rp) {\n+            Left(()) => Left (lp.recv()),\n+            Right(()) => Right(rp.recv())\n+          }\n+        }\n+    }\n+\n+    fn try_select(&self) -> Either<Option<T>, Option<U>> {\n+        match *self {\n+          (ref lp, ref rp) => match select2i(lp, rp) {\n+            Left(()) => Left (lp.try_recv()),\n+            Right(()) => Right(rp.try_recv())\n+          }\n+        }\n+    }\n+}\n+\n #[cfg(test)]\n mod test {\n     use either::Right;"}, {"sha": "36cfdbf5617aaff7050276c1985eead4471cf21e", "filename": "src/libcore/pipes.rs", "status": "modified", "additions": 68, "deletions": 160, "changes": 228, "blob_url": "https://github.com/rust-lang/rust/blob/b19c644d543b3638c4d420e923446606ad8ac2e2/src%2Flibcore%2Fpipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b19c644d543b3638c4d420e923446606ad8ac2e2/src%2Flibcore%2Fpipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpipes.rs?ref=b19c644d543b3638c4d420e923446606ad8ac2e2", "patch": "@@ -83,7 +83,6 @@ bounded and unbounded protocols allows for less code duplication.\n */\n \n use cast::{forget, reinterpret_cast, transmute};\n-use cell::Cell;\n use either::{Either, Left, Right};\n use kinds::Owned;\n use libc;\n@@ -93,14 +92,12 @@ use ptr;\n use task;\n use vec;\n \n-#[doc(hidden)]\n static SPIN_COUNT: uint = 0;\n \n macro_rules! move_it (\n     { $x:expr } => ( unsafe { let y = *ptr::addr_of(&($x)); y } )\n )\n \n-#[doc(hidden)]\n #[deriving(Eq)]\n enum State {\n     Empty,\n@@ -125,7 +122,6 @@ pub fn BufferHeader() -> BufferHeader {\n }\n \n // This is for protocols to associate extra data to thread around.\n-#[doc(hidden)]\n pub struct Buffer<T> {\n     header: BufferHeader,\n     data: T,\n@@ -186,13 +182,11 @@ pub impl PacketHeader {\n     }\n }\n \n-#[doc(hidden)]\n pub struct Packet<T> {\n     header: PacketHeader,\n     mut payload: Option<T>,\n }\n \n-#[doc(hidden)]\n pub trait HasBuffer {\n     fn set_buffer(&self, b: *libc::c_void);\n }\n@@ -203,14 +197,12 @@ impl<T:Owned> HasBuffer for Packet<T> {\n     }\n }\n \n-#[doc(hidden)]\n pub fn mk_packet<T:Owned>() -> Packet<T> {\n     Packet {\n         header: PacketHeader(),\n         payload: None,\n     }\n }\n-#[doc(hidden)]\n fn unibuffer<T>() -> ~Buffer<Packet<T>> {\n     let b = ~Buffer {\n         header: BufferHeader(),\n@@ -226,7 +218,6 @@ fn unibuffer<T>() -> ~Buffer<Packet<T>> {\n     b\n }\n \n-#[doc(hidden)]\n pub fn packet<T>() -> *Packet<T> {\n     let b = unibuffer();\n     let p = ptr::addr_of(&(b.data));\n@@ -235,7 +226,6 @@ pub fn packet<T>() -> *Packet<T> {\n     p\n }\n \n-#[doc(hidden)]\n pub fn entangle_buffer<T:Owned,Tstart:Owned>(\n     buffer: ~Buffer<T>,\n     init: &fn(*libc::c_void, x: &T) -> *Packet<Tstart>)\n@@ -246,30 +236,6 @@ pub fn entangle_buffer<T:Owned,Tstart:Owned>(\n     (SendPacketBuffered(p), RecvPacketBuffered(p))\n }\n \n-// If I call the rusti versions directly from a polymorphic function,\n-// I get link errors. This is a bug that needs investigated more.\n-#[doc(hidden)]\n-pub fn atomic_xchng_rel(dst: &mut int, src: int) -> int {\n-    unsafe {\n-        intrinsics::atomic_xchg_rel(dst, src)\n-    }\n-}\n-\n-#[doc(hidden)]\n-pub fn atomic_add_acq(dst: &mut int, src: int) -> int {\n-    unsafe {\n-        intrinsics::atomic_xadd_acq(dst, src)\n-    }\n-}\n-\n-#[doc(hidden)]\n-pub fn atomic_sub_rel(dst: &mut int, src: int) -> int {\n-    unsafe {\n-        intrinsics::atomic_xsub_rel(dst, src)\n-    }\n-}\n-\n-#[doc(hidden)]\n pub fn swap_task(dst: &mut *rust_task, src: *rust_task) -> *rust_task {\n     // It might be worth making both acquire and release versions of\n     // this.\n@@ -278,11 +244,9 @@ pub fn swap_task(dst: &mut *rust_task, src: *rust_task) -> *rust_task {\n     }\n }\n \n-#[doc(hidden)]\n #[allow(non_camel_case_types)]\n pub type rust_task = libc::c_void;\n \n-#[doc(hidden)]\n pub mod rustrt {\n     use libc;\n     use super::rust_task;\n@@ -304,7 +268,6 @@ pub mod rustrt {\n     }\n }\n \n-#[doc(hidden)]\n fn wait_event(this: *rust_task) -> *libc::c_void {\n     unsafe {\n         let mut event = ptr::null();\n@@ -317,21 +280,18 @@ fn wait_event(this: *rust_task) -> *libc::c_void {\n     }\n }\n \n-#[doc(hidden)]\n fn swap_state_acq(dst: &mut State, src: State) -> State {\n     unsafe {\n         transmute(intrinsics::atomic_xchg_acq(transmute(dst), src as int))\n     }\n }\n \n-#[doc(hidden)]\n fn swap_state_rel(dst: &mut State, src: State) -> State {\n     unsafe {\n         transmute(intrinsics::atomic_xchg_rel(transmute(dst), src as int))\n     }\n }\n \n-#[doc(hidden)]\n pub unsafe fn get_buffer<T>(p: *PacketHeader) -> ~Buffer<T> {\n     transmute((*p).buf_header())\n }\n@@ -349,7 +309,7 @@ impl<T> ::ops::Drop for BufferResource<T> {\n             let b = move_it!(self.buffer);\n             //let p = ptr::addr_of(*b);\n             //error!(\"drop %?\", p);\n-            let old_count = atomic_sub_rel(&mut b.header.ref_count, 1);\n+            let old_count = intrinsics::atomic_xsub_rel(&mut b.header.ref_count, 1);\n             //let old_count = atomic_xchng_rel(b.header.ref_count, 0);\n             if old_count == 1 {\n                 // The new count is 0.\n@@ -366,15 +326,14 @@ impl<T> ::ops::Drop for BufferResource<T> {\n fn BufferResource<T>(b: ~Buffer<T>) -> BufferResource<T> {\n     //let p = ptr::addr_of(*b);\n     //error!(\"take %?\", p);\n-    atomic_add_acq(&mut b.header.ref_count, 1);\n+    unsafe { intrinsics::atomic_xadd_acq(&mut b.header.ref_count, 1) };\n \n     BufferResource {\n         // tjc: ????\n         buffer: b\n     }\n }\n \n-#[doc(hidden)]\n pub fn send<T,Tbuffer>(p: SendPacketBuffered<T,Tbuffer>, payload: T) -> bool {\n     let header = p.header();\n     let p_ = p.unwrap();\n@@ -551,7 +510,6 @@ pub fn peek<T:Owned,Tb:Owned>(p: &RecvPacketBuffered<T, Tb>) -> bool {\n     }\n }\n \n-#[doc(hidden)]\n fn sender_terminate<T:Owned>(p: *Packet<T>) {\n     let p = unsafe { &*p };\n     match swap_state_rel(&mut p.header.state, Terminated) {\n@@ -582,7 +540,6 @@ fn sender_terminate<T:Owned>(p: *Packet<T>) {\n     }\n }\n \n-#[doc(hidden)]\n fn receiver_terminate<T:Owned>(p: *Packet<T>) {\n     let p = unsafe { &*p };\n     match swap_state_rel(&mut p.header.state, Terminated) {\n@@ -670,94 +627,12 @@ pub fn wait_many<T: Selectable>(pkts: &[T]) -> uint {\n     ready_packet\n }\n \n-/** Receives a message from one of two endpoints.\n-\n-The return value is `left` if the first endpoint received something,\n-or `right` if the second endpoint receives something. In each case,\n-the result includes the other endpoint as well so it can be used\n-again. Below is an example of using `select2`.\n-\n-~~~\n-match select2(a, b) {\n-  left((none, b)) {\n-    // endpoint a was closed.\n-  }\n-  right((a, none)) {\n-    // endpoint b was closed.\n-  }\n-  left((Some(_), b)) {\n-    // endpoint a received a message\n-  }\n-  right(a, Some(_)) {\n-    // endpoint b received a message.\n-  }\n-}\n-~~~\n-\n-Sometimes messages will be available on both endpoints at once. In\n-this case, `select2` may return either `left` or `right`.\n-\n-*/\n-pub fn select2<A:Owned,Ab:Owned,B:Owned,Bb:Owned>(\n-    a: RecvPacketBuffered<A, Ab>,\n-    b: RecvPacketBuffered<B, Bb>)\n-    -> Either<(Option<A>, RecvPacketBuffered<B, Bb>),\n-              (RecvPacketBuffered<A, Ab>, Option<B>)>\n-{\n-    let i = wait_many([a.header(), b.header()]);\n-\n-    match i {\n-      0 => Left((try_recv(a), b)),\n-      1 => Right((a, try_recv(b))),\n-      _ => fail!(~\"select2 return an invalid packet\")\n-    }\n-}\n-\n-#[doc(hidden)]\n-pub trait Selectable {\n-    fn header(&self) -> *PacketHeader;\n-}\n-\n-impl Selectable for *PacketHeader {\n-    fn header(&self) -> *PacketHeader { *self }\n-}\n-\n-/// Returns the index of an endpoint that is ready to receive.\n-pub fn selecti<T:Selectable>(endpoints: &[T]) -> uint {\n-    wait_many(endpoints)\n-}\n-\n-/// Returns 0 or 1 depending on which endpoint is ready to receive\n-pub fn select2i<A:Selectable,B:Selectable>(a: &A, b: &B) ->\n-        Either<(), ()> {\n-    match wait_many([a.header(), b.header()]) {\n-      0 => Left(()),\n-      1 => Right(()),\n-      _ => fail!(~\"wait returned unexpected index\")\n-    }\n-}\n-\n-/** Waits on a set of endpoints. Returns a message, its index, and a\n- list of the remaining endpoints.\n-\n-*/\n-pub fn select<T:Owned,Tb:Owned>(endpoints: ~[RecvPacketBuffered<T, Tb>])\n-    -> (uint, Option<T>, ~[RecvPacketBuffered<T, Tb>])\n-{\n-    let ready = wait_many(endpoints.map(|p| p.header()));\n-    let mut remaining = endpoints;\n-    let port = remaining.swap_remove(ready);\n-    let result = try_recv(port);\n-    (ready, result, remaining)\n-}\n-\n /** The sending end of a pipe. It can be used to send exactly one\n message.\n \n */\n pub type SendPacket<T> = SendPacketBuffered<T, Packet<T>>;\n \n-#[doc(hidden)]\n pub fn SendPacket<T>(p: *Packet<T>) -> SendPacket<T> {\n     SendPacketBuffered(p)\n }\n@@ -828,7 +703,6 @@ pub impl<T,Tbuffer> SendPacketBuffered<T,Tbuffer> {\n /// message.\n pub type RecvPacket<T> = RecvPacketBuffered<T, Packet<T>>;\n \n-#[doc(hidden)]\n pub fn RecvPacket<T>(p: *Packet<T>) -> RecvPacket<T> {\n     RecvPacketBuffered(p)\n }\n@@ -896,55 +770,89 @@ pub fn RecvPacketBuffered<T,Tbuffer>(p: *Packet<T>)\n     }\n }\n \n-#[doc(hidden)]\n pub fn entangle<T>() -> (SendPacket<T>, RecvPacket<T>) {\n     let p = packet();\n     (SendPacket(p), RecvPacket(p))\n }\n \n-/** Spawn a task to provide a service.\n+/** Receives a message from one of two endpoints.\n+\n+The return value is `left` if the first endpoint received something,\n+or `right` if the second endpoint receives something. In each case,\n+the result includes the other endpoint as well so it can be used\n+again. Below is an example of using `select2`.\n+\n+~~~\n+match select2(a, b) {\n+  left((none, b)) {\n+    // endpoint a was closed.\n+  }\n+  right((a, none)) {\n+    // endpoint b was closed.\n+  }\n+  left((Some(_), b)) {\n+    // endpoint a received a message\n+  }\n+  right(a, Some(_)) {\n+    // endpoint b received a message.\n+  }\n+}\n+~~~\n \n-It takes an initialization function that produces a send and receive\n-endpoint. The send endpoint is returned to the caller and the receive\n-endpoint is passed to the new task.\n+Sometimes messages will be available on both endpoints at once. In\n+this case, `select2` may return either `left` or `right`.\n \n */\n-pub fn spawn_service<T:Owned,Tb:Owned>(\n-            init: extern fn() -> (SendPacketBuffered<T, Tb>,\n-                                  RecvPacketBuffered<T, Tb>),\n-            service: ~fn(v: RecvPacketBuffered<T, Tb>))\n-        -> SendPacketBuffered<T, Tb> {\n-    let (client, server) = init();\n+pub fn select2<A:Owned,Ab:Owned,B:Owned,Bb:Owned>(\n+    a: RecvPacketBuffered<A, Ab>,\n+    b: RecvPacketBuffered<B, Bb>)\n+    -> Either<(Option<A>, RecvPacketBuffered<B, Bb>),\n+              (RecvPacketBuffered<A, Ab>, Option<B>)>\n+{\n+    let i = wait_many([a.header(), b.header()]);\n \n-    // This is some nasty gymnastics required to safely move the pipe\n-    // into a new task.\n-    let server = Cell(server);\n-    do task::spawn {\n-        service(server.take());\n+    match i {\n+      0 => Left((try_recv(a), b)),\n+      1 => Right((a, try_recv(b))),\n+      _ => fail!(~\"select2 return an invalid packet\")\n     }\n+}\n \n-    client\n+pub trait Selectable {\n+    fn header(&self) -> *PacketHeader;\n }\n \n-/** Like `spawn_service_recv`, but for protocols that start in the\n-receive state.\n+impl Selectable for *PacketHeader {\n+    fn header(&self) -> *PacketHeader { *self }\n+}\n \n-*/\n-pub fn spawn_service_recv<T:Owned,Tb:Owned>(\n-        init: extern fn() -> (RecvPacketBuffered<T, Tb>,\n-                              SendPacketBuffered<T, Tb>),\n-        service: ~fn(v: SendPacketBuffered<T, Tb>))\n-        -> RecvPacketBuffered<T, Tb> {\n-    let (client, server) = init();\n+/// Returns the index of an endpoint that is ready to receive.\n+pub fn selecti<T:Selectable>(endpoints: &[T]) -> uint {\n+    wait_many(endpoints)\n+}\n \n-    // This is some nasty gymnastics required to safely move the pipe\n-    // into a new task.\n-    let server = Cell(server);\n-    do task::spawn {\n-        service(server.take())\n+/// Returns 0 or 1 depending on which endpoint is ready to receive\n+pub fn select2i<A:Selectable,B:Selectable>(a: &A, b: &B) ->\n+        Either<(), ()> {\n+    match wait_many([a.header(), b.header()]) {\n+      0 => Left(()),\n+      1 => Right(()),\n+      _ => fail!(~\"wait returned unexpected index\")\n     }\n+}\n+\n+/** Waits on a set of endpoints. Returns a message, its index, and a\n+ list of the remaining endpoints.\n \n-    client\n+*/\n+pub fn select<T:Owned,Tb:Owned>(endpoints: ~[RecvPacketBuffered<T, Tb>])\n+    -> (uint, Option<T>, ~[RecvPacketBuffered<T, Tb>])\n+{\n+    let ready = wait_many(endpoints.map(|p| p.header()));\n+    let mut remaining = endpoints;\n+    let port = remaining.swap_remove(ready);\n+    let result = try_recv(port);\n+    (ready, result, remaining)\n }\n \n pub mod rt {"}, {"sha": "8b18cc3c6968c81ead4be8143652c711a203d640", "filename": "src/libcore/run.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b19c644d543b3638c4d420e923446606ad8ac2e2/src%2Flibcore%2Frun.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b19c644d543b3638c4d420e923446606ad8ac2e2/src%2Flibcore%2Frun.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frun.rs?ref=b19c644d543b3638c4d420e923446606ad8ac2e2", "patch": "@@ -405,7 +405,7 @@ pub fn program_output(prog: &str, args: &[~str]) -> ProgramOutput {\n     // or the other. FIXME (#2625): Surely there's a much more\n     // clever way to do this.\n     let (p, ch) = stream();\n-    let ch = SharedChan(ch);\n+    let ch = SharedChan::new(ch);\n     let ch_clone = ch.clone();\n     do task::spawn_sched(task::SingleThreaded) {\n         let errput = readclose(pipe_err.in);"}, {"sha": "55546514e4fa5fc83a87a80c4b30924be39a1449", "filename": "src/libcore/task/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b19c644d543b3638c4d420e923446606ad8ac2e2/src%2Flibcore%2Ftask%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b19c644d543b3638c4d420e923446606ad8ac2e2/src%2Flibcore%2Ftask%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Fmod.rs?ref=b19c644d543b3638c4d420e923446606ad8ac2e2", "patch": "@@ -657,7 +657,7 @@ fn test_cant_dup_task_builder() {\n #[test] #[ignore(cfg(windows))]\n fn test_spawn_unlinked_unsup_no_fail_down() { // grandchild sends on a port\n     let (po, ch) = stream();\n-    let ch = SharedChan(ch);\n+    let ch = SharedChan::new(ch);\n     do spawn_unlinked {\n         let ch = ch.clone();\n         do spawn_unlinked {\n@@ -881,7 +881,7 @@ fn test_spawn_sched_no_threads() {\n #[test]\n fn test_spawn_sched() {\n     let (po, ch) = stream::<()>();\n-    let ch = SharedChan(ch);\n+    let ch = SharedChan::new(ch);\n \n     fn f(i: int, ch: SharedChan<()>) {\n         let parent_sched_id = unsafe { rt::rust_get_sched_id() };"}, {"sha": "4e2174fd5d24c509eca5b0651d567384920ca681", "filename": "src/libcore/unstable/weak_task.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b19c644d543b3638c4d420e923446606ad8ac2e2/src%2Flibcore%2Funstable%2Fweak_task.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b19c644d543b3638c4d420e923446606ad8ac2e2/src%2Flibcore%2Funstable%2Fweak_task.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funstable%2Fweak_task.rs?ref=b19c644d543b3638c4d420e923446606ad8ac2e2", "patch": "@@ -69,7 +69,7 @@ fn create_global_service() -> ~WeakTaskService {\n     debug!(\"creating global weak task service\");\n     let (port, chan) = stream::<ServiceMsg>();\n     let port = Cell(port);\n-    let chan = SharedChan(chan);\n+    let chan = SharedChan::new(chan);\n     let chan_clone = chan.clone();\n \n     do task().unlinked().spawn {"}, {"sha": "0e242805e13aeccff60ac4bdfddf0ee565c483d4", "filename": "src/librustc/rustc.rc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b19c644d543b3638c4d420e923446606ad8ac2e2/src%2Flibrustc%2Frustc.rc", "raw_url": "https://github.com/rust-lang/rust/raw/b19c644d543b3638c4d420e923446606ad8ac2e2/src%2Flibrustc%2Frustc.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Frustc.rc?ref=b19c644d543b3638c4d420e923446606ad8ac2e2", "patch": "@@ -307,7 +307,7 @@ bug and need to present an error.\n pub fn monitor(+f: ~fn(diagnostic::Emitter)) {\n     use core::comm::*;\n     let (p, ch) = stream();\n-    let ch = SharedChan(ch);\n+    let ch = SharedChan::new(ch);\n     let ch_capture = ch.clone();\n     match do task::try || {\n         let ch = ch_capture.clone();"}, {"sha": "c4c81b5ec2c70ed80ec91d06d25b78e87b28e24e", "filename": "src/librustdoc/astsrv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b19c644d543b3638c4d420e923446606ad8ac2e2/src%2Flibrustdoc%2Fastsrv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b19c644d543b3638c4d420e923446606ad8ac2e2/src%2Flibrustdoc%2Fastsrv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fastsrv.rs?ref=b19c644d543b3638c4d420e923446606ad8ac2e2", "patch": "@@ -69,7 +69,7 @@ fn run<T>(owner: SrvOwner<T>, source: ~str, parse: Parser) -> T {\n     }\n \n     let srv_ = Srv {\n-        ch: SharedChan(ch)\n+        ch: SharedChan::new(ch)\n     };\n \n     let res = owner(srv_.clone());"}, {"sha": "13f598ce707810b4dde6312a11b543831f6db0d3", "filename": "src/librustdoc/markdown_writer.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b19c644d543b3638c4d420e923446606ad8ac2e2/src%2Flibrustdoc%2Fmarkdown_writer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b19c644d543b3638c4d420e923446606ad8ac2e2/src%2Flibrustdoc%2Fmarkdown_writer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fmarkdown_writer.rs?ref=b19c644d543b3638c4d420e923446606ad8ac2e2", "patch": "@@ -232,7 +232,7 @@ fn write_file(path: &Path, s: ~str) {\n pub fn future_writer_factory(\n ) -> (WriterFactory, Port<(doc::Page, ~str)>) {\n     let (markdown_po, markdown_ch) = stream();\n-    let markdown_ch = SharedChan(markdown_ch);\n+    let markdown_ch = SharedChan::new(markdown_ch);\n     let writer_factory: WriterFactory = |page| {\n         let (writer_po, writer_ch) = comm::stream();\n         let markdown_ch = markdown_ch.clone();"}, {"sha": "93e7d8c808cdac087a50bb312c1c1a78ca6a707f", "filename": "src/librustdoc/page_pass.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b19c644d543b3638c4d420e923446606ad8ac2e2/src%2Flibrustdoc%2Fpage_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b19c644d543b3638c4d420e923446606ad8ac2e2/src%2Flibrustdoc%2Fpage_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpage_pass.rs?ref=b19c644d543b3638c4d420e923446606ad8ac2e2", "patch": "@@ -50,7 +50,7 @@ pub fn run(\n \n     let (result_port, result_chan) = stream();\n     let (page_port, page_chan) = stream();\n-    let page_chan = SharedChan(page_chan);\n+    let page_chan = SharedChan::new(page_chan);\n     do task::spawn {\n         result_chan.send(make_doc_from_pages(&page_port));\n     };"}, {"sha": "8abe0262314b5704d37fbea0477d13dce4fc8f00", "filename": "src/libstd/arc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b19c644d543b3638c4d420e923446606ad8ac2e2/src%2Flibstd%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b19c644d543b3638c4d420e923446606ad8ac2e2/src%2Flibstd%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Farc.rs?ref=b19c644d543b3638c4d420e923446606ad8ac2e2", "patch": "@@ -499,7 +499,7 @@ mod tests {\n         let (p, c) = comm::stream();\n \n         do task::spawn() || {\n-            let p = comm::PortSet();\n+            let p = comm::PortSet::new();\n             c.send(p.chan());\n \n             let arc_v = p.recv();"}, {"sha": "e58b17b83218f035dfe56fb058bb8512f9f2343e", "filename": "src/libstd/net_ip.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b19c644d543b3638c4d420e923446606ad8ac2e2/src%2Flibstd%2Fnet_ip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b19c644d543b3638c4d420e923446606ad8ac2e2/src%2Flibstd%2Fnet_ip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_ip.rs?ref=b19c644d543b3638c4d420e923446606ad8ac2e2", "patch": "@@ -113,7 +113,7 @@ enum IpGetAddrErr {\n pub fn get_addr(node: &str, iotask: &iotask)\n     -> result::Result<~[IpAddr], IpGetAddrErr> {\n     let (output_po, output_ch) = stream();\n-    let mut output_ch = Some(SharedChan(output_ch));\n+    let mut output_ch = Some(SharedChan::new(output_ch));\n     do str::as_buf(node) |node_ptr, len| {\n         let output_ch = output_ch.swap_unwrap();\n         debug!(\"slice len %?\", len);"}, {"sha": "6bf97843fa1787cbfb73b406a9d5d12469ce8f6a", "filename": "src/libstd/net_tcp.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/b19c644d543b3638c4d420e923446606ad8ac2e2/src%2Flibstd%2Fnet_tcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b19c644d543b3638c4d420e923446606ad8ac2e2/src%2Flibstd%2Fnet_tcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_tcp.rs?ref=b19c644d543b3638c4d420e923446606ad8ac2e2", "patch": "@@ -150,16 +150,16 @@ pub fn connect(input_ip: ip::IpAddr, port: uint,\n     -> result::Result<TcpSocket, TcpConnectErrData> {\n     unsafe {\n         let (result_po, result_ch) = stream::<ConnAttempt>();\n-        let result_ch = SharedChan(result_ch);\n+        let result_ch = SharedChan::new(result_ch);\n         let (closed_signal_po, closed_signal_ch) = stream::<()>();\n-        let closed_signal_ch = SharedChan(closed_signal_ch);\n+        let closed_signal_ch = SharedChan::new(closed_signal_ch);\n         let conn_data = ConnectReqData {\n             result_ch: result_ch,\n             closed_signal_ch: closed_signal_ch\n         };\n         let conn_data_ptr = ptr::addr_of(&conn_data);\n         let (reader_po, reader_ch) = stream::<Result<~[u8], TcpErrData>>();\n-        let reader_ch = SharedChan(reader_ch);\n+        let reader_ch = SharedChan::new(reader_ch);\n         let stream_handle_ptr = malloc_uv_tcp_t();\n         *(stream_handle_ptr as *mut uv::ll::uv_tcp_t) = uv::ll::tcp_t();\n         let socket_data = @TcpSocketData {\n@@ -517,7 +517,7 @@ pub fn accept(new_conn: TcpNewConnection)\n                     server_handle_ptr) as *TcpListenFcData;\n                 let (reader_po, reader_ch) = stream::<\n                     Result<~[u8], TcpErrData>>();\n-                let reader_ch = SharedChan(reader_ch);\n+                let reader_ch = SharedChan::new(reader_ch);\n                 let iotask = &(*server_data_ptr).iotask;\n                 let stream_handle_ptr = malloc_uv_tcp_t();\n                 *(stream_handle_ptr as *mut uv::ll::uv_tcp_t) =\n@@ -537,7 +537,7 @@ pub fn accept(new_conn: TcpNewConnection)\n                     (*client_socket_data_ptr).stream_handle_ptr;\n \n                 let (result_po, result_ch) = stream::<Option<TcpErrData>>();\n-                let result_ch = SharedChan(result_ch);\n+                let result_ch = SharedChan::new(result_ch);\n \n                 // UNSAFE LIBUV INTERACTION BEGIN\n                 // .. normally this happens within the context of\n@@ -646,9 +646,9 @@ fn listen_common(host_ip: ip::IpAddr,\n                  on_connect_cb: ~fn(*uv::ll::uv_tcp_t))\n               -> result::Result<(), TcpListenErrData> {\n     let (stream_closed_po, stream_closed_ch) = stream::<()>();\n-    let stream_closed_ch = SharedChan(stream_closed_ch);\n+    let stream_closed_ch = SharedChan::new(stream_closed_ch);\n     let (kill_po, kill_ch) = stream::<Option<TcpErrData>>();\n-    let kill_ch = SharedChan(kill_ch);\n+    let kill_ch = SharedChan::new(kill_ch);\n     let server_stream = uv::ll::tcp_t();\n     let server_stream_ptr = ptr::addr_of(&server_stream);\n     let server_data: TcpListenFcData = TcpListenFcData {\n@@ -997,7 +997,7 @@ impl io::Writer for TcpSocketBuf {\n fn tear_down_socket_data(socket_data: @TcpSocketData) {\n     unsafe {\n         let (closed_po, closed_ch) = stream::<()>();\n-        let closed_ch = SharedChan(closed_ch);\n+        let closed_ch = SharedChan::new(closed_ch);\n         let close_data = TcpSocketCloseData {\n             closed_ch: closed_ch\n         };\n@@ -1147,7 +1147,7 @@ fn write_common_impl(socket_data_ptr: *TcpSocketData,\n             vec::len(raw_write_data)) ];\n         let write_buf_vec_ptr = ptr::addr_of(&write_buf_vec);\n         let (result_po, result_ch) = stream::<TcpWriteResult>();\n-        let result_ch = SharedChan(result_ch);\n+        let result_ch = SharedChan::new(result_ch);\n         let write_data = WriteReqData {\n             result_ch: result_ch\n         };\n@@ -1554,7 +1554,7 @@ mod test {\n         let (server_result_po, server_result_ch) = stream::<~str>();\n \n         let (cont_po, cont_ch) = stream::<()>();\n-        let cont_ch = SharedChan(cont_ch);\n+        let cont_ch = SharedChan::new(cont_ch);\n         // server\n         let hl_loop_clone = hl_loop.clone();\n         do task::spawn_sched(task::ManualThreads(1u)) {\n@@ -1592,7 +1592,7 @@ mod test {\n         let expected_resp = ~\"pong\";\n \n         let (cont_po, cont_ch) = stream::<()>();\n-        let cont_ch = SharedChan(cont_ch);\n+        let cont_ch = SharedChan::new(cont_ch);\n         // server\n         let hl_loop_clone = hl_loop.clone();\n         do task::spawn_sched(task::ManualThreads(1u)) {\n@@ -1652,7 +1652,7 @@ mod test {\n         let expected_resp = ~\"pong\";\n \n         let (cont_po, cont_ch) = stream::<()>();\n-        let cont_ch = SharedChan(cont_ch);\n+        let cont_ch = SharedChan::new(cont_ch);\n         // server\n         let hl_loop_clone = hl_loop.clone();\n         do task::spawn_sched(task::ManualThreads(1u)) {\n@@ -1717,7 +1717,7 @@ mod test {\n         let (server_result_po, server_result_ch) = stream::<~str>();\n \n         let (cont_po, cont_ch) = stream::<()>();\n-        let cont_ch = SharedChan(cont_ch);\n+        let cont_ch = SharedChan::new(cont_ch);\n         // server\n         let iotask_clone = iotask.clone();\n         do task::spawn_sched(task::ManualThreads(1u)) {\n@@ -1764,7 +1764,7 @@ mod test {\n         let expected_resp = ~\"A string\\nwith multiple lines\\n\";\n \n         let (cont_po, cont_ch) = stream::<()>();\n-        let cont_ch = SharedChan(cont_ch);\n+        let cont_ch = SharedChan::new(cont_ch);\n         // server\n         let hl_loop_clone = hl_loop.clone();\n         do task::spawn_sched(task::ManualThreads(1u)) {\n@@ -1813,7 +1813,7 @@ mod test {\n                           cont_ch: SharedChan<()>,\n                           iotask: &IoTask) -> ~str {\n         let (server_po, server_ch) = stream::<~str>();\n-        let server_ch = SharedChan(server_ch);\n+        let server_ch = SharedChan::new(server_ch);\n         let server_ip_addr = ip::v4::parse_addr(server_ip);\n         let listen_result = listen(server_ip_addr, server_port, 128,\n                                    iotask,"}, {"sha": "4ccbf207170e9e58ff0d1b658e49ff361f6f0dc0", "filename": "src/libstd/test.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b19c644d543b3638c4d420e923446606ad8ac2e2/src%2Flibstd%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b19c644d543b3638c4d420e923446606ad8ac2e2/src%2Flibstd%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftest.rs?ref=b19c644d543b3638c4d420e923446606ad8ac2e2", "patch": "@@ -446,7 +446,7 @@ fn run_tests(opts: &TestOpts,\n     let mut pending = 0;\n \n     let (p, ch) = stream();\n-    let ch = SharedChan(ch);\n+    let ch = SharedChan::new(ch);\n \n     while pending > 0 || !remaining.is_empty() {\n         while pending < concurrency && !remaining.is_empty() {\n@@ -797,7 +797,7 @@ mod tests {\n             testfn: DynTestFn(|| f()),\n         };\n         let (p, ch) = stream();\n-        let ch = SharedChan(ch);\n+        let ch = SharedChan::new(ch);\n         run_test(false, desc, ch);\n         let (_, res) = p.recv();\n         assert!(res != TrOk);\n@@ -815,7 +815,7 @@ mod tests {\n             testfn: DynTestFn(|| f()),\n         };\n         let (p, ch) = stream();\n-        let ch = SharedChan(ch);\n+        let ch = SharedChan::new(ch);\n         run_test(false, desc, ch);\n         let (_, res) = p.recv();\n         assert!(res == TrIgnored);\n@@ -834,7 +834,7 @@ mod tests {\n             testfn: DynTestFn(|| f()),\n         };\n         let (p, ch) = stream();\n-        let ch = SharedChan(ch);\n+        let ch = SharedChan::new(ch);\n         run_test(false, desc, ch);\n         let (_, res) = p.recv();\n         assert!(res == TrOk);\n@@ -852,7 +852,7 @@ mod tests {\n             testfn: DynTestFn(|| f()),\n         };\n         let (p, ch) = stream();\n-        let ch = SharedChan(ch);\n+        let ch = SharedChan::new(ch);\n         run_test(false, desc, ch);\n         let (_, res) = p.recv();\n         assert!(res == TrFailed);"}, {"sha": "e862fe6077cb69e37101e5cdb8103443dc182c60", "filename": "src/libstd/timer.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b19c644d543b3638c4d420e923446606ad8ac2e2/src%2Flibstd%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b19c644d543b3638c4d420e923446606ad8ac2e2/src%2Flibstd%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftimer.rs?ref=b19c644d543b3638c4d420e923446606ad8ac2e2", "patch": "@@ -43,7 +43,7 @@ pub fn delayed_send<T:Owned>(iotask: &IoTask,\n                               ch: &Chan<T>,\n                               val: T) {\n     let (timer_done_po, timer_done_ch) = stream::<()>();\n-    let timer_done_ch = SharedChan(timer_done_ch);\n+    let timer_done_ch = SharedChan::new(timer_done_ch);\n     let timer = uv::ll::timer_t();\n     let timer_ptr = ptr::addr_of(&timer);\n     do iotask::interact(iotask) |loop_ptr| {\n@@ -199,7 +199,7 @@ mod test {\n     #[test]\n     fn test_gl_timer_sleep_stress2() {\n         let (po, ch) = stream();\n-        let ch = SharedChan(ch);\n+        let ch = SharedChan::new(ch);\n         let hl_loop = &uv::global_loop::get();\n \n         let repeat = 20u;"}, {"sha": "ac762d7d801fe283fe038213d3d053a40c60c6b7", "filename": "src/libstd/uv_global_loop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b19c644d543b3638c4d420e923446606ad8ac2e2/src%2Flibstd%2Fuv_global_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b19c644d543b3638c4d420e923446606ad8ac2e2/src%2Flibstd%2Fuv_global_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fuv_global_loop.rs?ref=b19c644d543b3638c4d420e923446606ad8ac2e2", "patch": "@@ -211,7 +211,7 @@ mod test {\n     #[ignore]\n     fn test_stress_gl_uv_global_loop_high_level_global_timer() {\n         let (exit_po, exit_ch) = stream::<()>();\n-        let exit_ch = SharedChan(exit_ch);\n+        let exit_ch = SharedChan::new(exit_ch);\n         let cycles = 5000u;\n         for iter::repeat(cycles) {\n             let exit_ch_clone = exit_ch.clone();"}, {"sha": "c7a78f38919236218cc8e3ab37f81d31ba1a9b18", "filename": "src/libstd/uv_iotask.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b19c644d543b3638c4d420e923446606ad8ac2e2/src%2Flibstd%2Fuv_iotask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b19c644d543b3638c4d420e923446606ad8ac2e2/src%2Flibstd%2Fuv_iotask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fuv_iotask.rs?ref=b19c644d543b3638c4d420e923446606ad8ac2e2", "patch": "@@ -126,7 +126,7 @@ fn run_loop(iotask_ch: &Chan<IoTask>) {\n         // while we dwell in the I/O loop\n         let iotask = IoTask{\n             async_handle: async_handle,\n-            op_chan: SharedChan(msg_ch)\n+            op_chan: SharedChan::new(msg_ch)\n         };\n         iotask_ch.send(iotask);\n \n@@ -230,7 +230,7 @@ fn impl_uv_iotask_async(iotask: &IoTask) {\n         let (exit_po, exit_ch) = stream::<()>();\n         let ah_data = AhData {\n             iotask: iotask.clone(),\n-            exit_ch: SharedChan(exit_ch)\n+            exit_ch: SharedChan::new(exit_ch)\n         };\n         let ah_data_ptr: *AhData = unsafe {\n             ptr::to_unsafe_ptr(&ah_data)\n@@ -293,7 +293,7 @@ fn test_uv_iotask_async() {\n         // loop lives until, at least, all of the\n         // impl_uv_hl_async() runs have been called, at least.\n         let (work_exit_po, work_exit_ch) = stream::<()>();\n-        let work_exit_ch = SharedChan(work_exit_ch);\n+        let work_exit_ch = SharedChan::new(work_exit_ch);\n         for iter::repeat(7u) {\n             let iotask_clone = iotask.clone();\n             let work_exit_ch_clone = work_exit_ch.clone();"}, {"sha": "ab3074e49dd680ed86d663bae802673a6299712c", "filename": "src/libstd/uv_ll.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b19c644d543b3638c4d420e923446606ad8ac2e2/src%2Flibstd%2Fuv_ll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b19c644d543b3638c4d420e923446606ad8ac2e2/src%2Flibstd%2Fuv_ll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fuv_ll.rs?ref=b19c644d543b3638c4d420e923446606ad8ac2e2", "patch": "@@ -1717,12 +1717,12 @@ mod test {\n             let kill_server_msg = ~\"does a dog have buddha nature?\";\n             let server_resp_msg = ~\"mu!\";\n             let (client_port, client_chan) = stream::<~str>();\n-            let client_chan = SharedChan(client_chan);\n+            let client_chan = SharedChan::new(client_chan);\n             let (server_port, server_chan) = stream::<~str>();\n-            let server_chan = SharedChan(server_chan);\n+            let server_chan = SharedChan::new(server_chan);\n \n             let (continue_port, continue_chan) = stream::<bool>();\n-            let continue_chan = SharedChan(continue_chan);\n+            let continue_chan = SharedChan::new(continue_chan);\n \n             let kill_server_msg_copy = copy kill_server_msg;\n             let server_resp_msg_copy = copy server_resp_msg;"}, {"sha": "dbfd38ccf2624c311e9e7f648dfe5aeb75644745", "filename": "src/test/bench/msgsend-pipes-shared.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b19c644d543b3638c4d420e923446606ad8ac2e2/src%2Ftest%2Fbench%2Fmsgsend-pipes-shared.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b19c644d543b3638c4d420e923446606ad8ac2e2/src%2Ftest%2Fbench%2Fmsgsend-pipes-shared.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-pipes-shared.rs?ref=b19c644d543b3638c4d420e923446606ad8ac2e2", "patch": "@@ -58,7 +58,7 @@ fn run(args: &[~str]) {\n     let (from_child, to_parent) = comm::stream();\n     let (from_parent, to_child) = comm::stream();\n \n-    let to_child = SharedChan(to_child);\n+    let to_child = SharedChan::new(to_child);\n \n     let size = uint::from_str(args[1]).get();\n     let workers = uint::from_str(args[2]).get();"}, {"sha": "492b13f570869d69e3d20a41b44392f9c37ab04b", "filename": "src/test/bench/msgsend-pipes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b19c644d543b3638c4d420e923446606ad8ac2e2/src%2Ftest%2Fbench%2Fmsgsend-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b19c644d543b3638c4d420e923446606ad8ac2e2/src%2Ftest%2Fbench%2Fmsgsend-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-pipes.rs?ref=b19c644d543b3638c4d420e923446606ad8ac2e2", "patch": "@@ -53,7 +53,7 @@ fn server(requests: PortSet<request>, responses: Chan<uint>) {\n fn run(args: &[~str]) {\n     let (from_child, to_parent) = stream();\n     let (from_parent_, to_child) = stream();\n-    let from_parent = PortSet();\n+    let from_parent = PortSet::new();\n     from_parent.add(from_parent_);\n \n     let size = uint::from_str(args[1]).get();"}, {"sha": "64fb9652ceae09b67af2dcb5236417627c9809ef", "filename": "src/test/bench/pingpong.rs", "status": "modified", "additions": 48, "deletions": 1, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/b19c644d543b3638c4d420e923446606ad8ac2e2/src%2Ftest%2Fbench%2Fpingpong.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b19c644d543b3638c4d420e923446606ad8ac2e2/src%2Ftest%2Fbench%2Fpingpong.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fpingpong.rs?ref=b19c644d543b3638c4d420e923446606ad8ac2e2", "patch": "@@ -14,7 +14,8 @@\n  \n extern mod std;\n \n-use core::pipes::{spawn_service, recv};\n+use core::cell::Cell;\n+use core::pipes::*;\n use std::time::precise_time_s;\n \n proto! pingpong (\n@@ -70,6 +71,52 @@ macro_rules! follow (\n     )\n )\n \n+\n+/** Spawn a task to provide a service.\n+\n+It takes an initialization function that produces a send and receive\n+endpoint. The send endpoint is returned to the caller and the receive\n+endpoint is passed to the new task.\n+\n+*/\n+pub fn spawn_service<T:Owned,Tb:Owned>(\n+            init: extern fn() -> (SendPacketBuffered<T, Tb>,\n+                                  RecvPacketBuffered<T, Tb>),\n+            service: ~fn(v: RecvPacketBuffered<T, Tb>))\n+        -> SendPacketBuffered<T, Tb> {\n+    let (client, server) = init();\n+\n+    // This is some nasty gymnastics required to safely move the pipe\n+    // into a new task.\n+    let server = Cell(server);\n+    do task::spawn {\n+        service(server.take());\n+    }\n+\n+    client\n+}\n+\n+/** Like `spawn_service_recv`, but for protocols that start in the\n+receive state.\n+\n+*/\n+pub fn spawn_service_recv<T:Owned,Tb:Owned>(\n+        init: extern fn() -> (RecvPacketBuffered<T, Tb>,\n+                              SendPacketBuffered<T, Tb>),\n+        service: ~fn(v: SendPacketBuffered<T, Tb>))\n+        -> RecvPacketBuffered<T, Tb> {\n+    let (client, server) = init();\n+\n+    // This is some nasty gymnastics required to safely move the pipe\n+    // into a new task.\n+    let server = Cell(server);\n+    do task::spawn {\n+        service(server.take())\n+    }\n+\n+    client\n+}\n+\n fn switch<T:Owned,Tb:Owned,U>(+endp: core::pipes::RecvPacketBuffered<T, Tb>,\n                       f: &fn(+v: Option<T>) -> U) -> U {\n     f(core::pipes::try_recv(endp))"}, {"sha": "9dad24646ded224c02d4bcb14957ca61545c3f3b", "filename": "src/test/bench/shootout-chameneos-redux.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b19c644d543b3638c4d420e923446606ad8ac2e2/src%2Ftest%2Fbench%2Fshootout-chameneos-redux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b19c644d543b3638c4d420e923446606ad8ac2e2/src%2Ftest%2Fbench%2Fshootout-chameneos-redux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-chameneos-redux.rs?ref=b19c644d543b3638c4d420e923446606ad8ac2e2", "patch": "@@ -137,9 +137,9 @@ fn rendezvous(nn: uint, set: ~[color]) {\n \n     // these ports will allow us to hear from the creatures\n     let (from_creatures, to_rendezvous) = stream::<CreatureInfo>();\n-    let to_rendezvous = SharedChan(to_rendezvous);\n+    let to_rendezvous = SharedChan::new(to_rendezvous);\n     let (from_creatures_log, to_rendezvous_log) = stream::<~str>();\n-    let to_rendezvous_log = SharedChan(to_rendezvous_log);\n+    let to_rendezvous_log = SharedChan::new(to_rendezvous_log);\n \n     // these channels will be passed to the creatures so they can talk to us\n "}, {"sha": "4909d05b35b165a58d53a30051fe700e99f749e2", "filename": "src/test/bench/shootout-mandelbrot.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b19c644d543b3638c4d420e923446606ad8ac2e2/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b19c644d543b3638c4d420e923446606ad8ac2e2/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs?ref=b19c644d543b3638c4d420e923446606ad8ac2e2", "patch": "@@ -173,7 +173,7 @@ fn main() {\n     else { uint::from_str(args[1]).get() };\n \n     let (pport, pchan) = comm::stream();\n-    let pchan = comm::SharedChan(pchan);\n+    let pchan = comm::SharedChan::new(pchan);\n     for uint::range(0_u, size) |j| {\n         let cchan = pchan.clone();\n         do task::spawn { cchan.send(chanmb(j, size, depth)) };"}, {"sha": "f7bd779a8d89e7de7d277eec9536449cdb8dee62", "filename": "src/test/bench/shootout-pfib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b19c644d543b3638c4d420e923446606ad8ac2e2/src%2Ftest%2Fbench%2Fshootout-pfib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b19c644d543b3638c4d420e923446606ad8ac2e2/src%2Ftest%2Fbench%2Fshootout-pfib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-pfib.rs?ref=b19c644d543b3638c4d420e923446606ad8ac2e2", "patch": "@@ -38,7 +38,7 @@ fn fib(n: int) -> int {\n         } else if n <= 2 {\n             c.send(1);\n         } else {\n-            let p = PortSet();\n+            let p = PortSet::new();\n             let ch = p.chan();\n             task::spawn(|| pfib(ch, n - 1) );\n             let ch = p.chan();"}, {"sha": "90c9d6b33e4adc657a150501c52a374f9123ee34", "filename": "src/test/bench/task-perf-linked-failure.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b19c644d543b3638c4d420e923446606ad8ac2e2/src%2Ftest%2Fbench%2Ftask-perf-linked-failure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b19c644d543b3638c4d420e923446606ad8ac2e2/src%2Ftest%2Fbench%2Ftask-perf-linked-failure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-linked-failure.rs?ref=b19c644d543b3638c4d420e923446606ad8ac2e2", "patch": "@@ -26,7 +26,7 @@ use core::comm::*;\n \n fn grandchild_group(num_tasks: uint) {\n     let (po, ch) = stream();\n-    let ch = SharedChan(ch);\n+    let ch = SharedChan::new(ch);\n \n     for num_tasks.times {\n         let ch = ch.clone();"}, {"sha": "bca4cbafc6cc4fb3cc31e798c1bcc9484a7f4485", "filename": "src/test/run-pass/hashmap-memory.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b19c644d543b3638c4d420e923446606ad8ac2e2/src%2Ftest%2Frun-pass%2Fhashmap-memory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b19c644d543b3638c4d420e923446606ad8ac2e2/src%2Ftest%2Frun-pass%2Fhashmap-memory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fhashmap-memory.rs?ref=b19c644d543b3638c4d420e923446606ad8ac2e2", "patch": "@@ -60,7 +60,7 @@ mod map_reduce {\n \n     pub fn map_reduce(inputs: ~[~str]) {\n         let (ctrl_port, ctrl_chan) = stream();\n-        let ctrl_chan = SharedChan(ctrl_chan);\n+        let ctrl_chan = SharedChan::new(ctrl_chan);\n \n         // This task becomes the master control task. It spawns others\n         // to do the rest."}, {"sha": "bd0ffa64590673c1024dd31c9010896bb61cbf3f", "filename": "src/test/run-pass/pipe-detect-term.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b19c644d543b3638c4d420e923446606ad8ac2e2/src%2Ftest%2Frun-pass%2Fpipe-detect-term.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b19c644d543b3638c4d420e923446606ad8ac2e2/src%2Ftest%2Frun-pass%2Fpipe-detect-term.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpipe-detect-term.rs?ref=b19c644d543b3638c4d420e923446606ad8ac2e2", "patch": "@@ -18,7 +18,7 @@ extern mod std;\n use std::timer::sleep;\n use std::uv;\n \n-use core::pipes;\n+use core::cell::Cell;\n use core::pipes::{try_recv, recv};\n \n proto! oneshot (\n@@ -30,12 +30,14 @@ proto! oneshot (\n pub fn main() {\n     let iotask = &uv::global_loop::get();\n     \n-    pipes::spawn_service(oneshot::init, |p| { \n-        match try_recv(p) {\n+    let (chan, port) = oneshot::init();\n+    let port = Cell(port);\n+    do spawn {\n+        match try_recv(port.take()) {\n           Some(*) => { fail!() }\n           None => { }\n         }\n-    });\n+    }\n \n     sleep(iotask, 100);\n "}, {"sha": "12d60c9d6ab0133d6f07daada2f5f738786eed67", "filename": "src/test/run-pass/pipe-select.rs", "status": "modified", "additions": 20, "deletions": 2, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/b19c644d543b3638c4d420e923446606ad8ac2e2/src%2Ftest%2Frun-pass%2Fpipe-select.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b19c644d543b3638c4d420e923446606ad8ac2e2/src%2Ftest%2Frun-pass%2Fpipe-select.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpipe-select.rs?ref=b19c644d543b3638c4d420e923446606ad8ac2e2", "patch": "@@ -17,8 +17,9 @@ extern mod std;\n use std::timer::sleep;\n use std::uv;\n \n+use core::cell::Cell;\n use core::pipes;\n-use core::pipes::{recv, select};\n+use core::pipes::*;\n \n proto! oneshot (\n     waiting:send {\n@@ -32,13 +33,30 @@ proto! stream (\n     }\n )\n \n+pub fn spawn_service<T:Owned,Tb:Owned>(\n+            init: extern fn() -> (SendPacketBuffered<T, Tb>,\n+                                  RecvPacketBuffered<T, Tb>),\n+            service: ~fn(v: RecvPacketBuffered<T, Tb>))\n+        -> SendPacketBuffered<T, Tb> {\n+    let (client, server) = init();\n+\n+    // This is some nasty gymnastics required to safely move the pipe\n+    // into a new task.\n+    let server = Cell(server);\n+    do task::spawn {\n+        service(server.take());\n+    }\n+\n+    client\n+}\n+\n pub fn main() {\n     use oneshot::client::*;\n     use stream::client::*;\n \n     let iotask = &uv::global_loop::get();\n     \n-    let c = pipes::spawn_service(stream::init, |p| { \n+    let c = spawn_service(stream::init, |p| { \n         error!(\"waiting for pipes\");\n         let stream::send(x, p) = recv(p);\n         error!(\"got pipes\");"}, {"sha": "86ffc96e89aecff514cec4c1b1fbc4696dea0928", "filename": "src/test/run-pass/pipe-sleep.rs", "status": "modified", "additions": 28, "deletions": 2, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/b19c644d543b3638c4d420e923446606ad8ac2e2/src%2Ftest%2Frun-pass%2Fpipe-sleep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b19c644d543b3638c4d420e923446606ad8ac2e2/src%2Ftest%2Frun-pass%2Fpipe-sleep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpipe-sleep.rs?ref=b19c644d543b3638c4d420e923446606ad8ac2e2", "patch": "@@ -13,19 +13,45 @@\n extern mod std;\n use std::timer::sleep;\n use std::uv;\n+use core::cell::Cell;\n use core::pipes;\n-use core::pipes::recv;\n+use core::pipes::*;\n \n proto! oneshot (\n     waiting:send {\n         signal -> !\n     }\n )\n \n+\n+/** Spawn a task to provide a service.\n+\n+It takes an initialization function that produces a send and receive\n+endpoint. The send endpoint is returned to the caller and the receive\n+endpoint is passed to the new task.\n+\n+*/\n+pub fn spawn_service<T:Owned,Tb:Owned>(\n+            init: extern fn() -> (SendPacketBuffered<T, Tb>,\n+                                  RecvPacketBuffered<T, Tb>),\n+            service: ~fn(v: RecvPacketBuffered<T, Tb>))\n+        -> SendPacketBuffered<T, Tb> {\n+    let (client, server) = init();\n+\n+    // This is some nasty gymnastics required to safely move the pipe\n+    // into a new task.\n+    let server = Cell(server);\n+    do task::spawn {\n+        service(server.take());\n+    }\n+\n+    client\n+}\n+\n pub fn main() {\n     use oneshot::client::*;\n \n-    let c = pipes::spawn_service(oneshot::init, |p| { recv(p); });\n+    let c = spawn_service(oneshot::init, |p| { recv(p); });\n \n     let iotask = &uv::global_loop::get();\n     sleep(iotask, 500);"}, {"sha": "8b4855deaa5631b1ba49bd42204ef067d56e60de", "filename": "src/test/run-pass/task-comm-14.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b19c644d543b3638c4d420e923446606ad8ac2e2/src%2Ftest%2Frun-pass%2Ftask-comm-14.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b19c644d543b3638c4d420e923446606ad8ac2e2/src%2Ftest%2Frun-pass%2Ftask-comm-14.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-14.rs?ref=b19c644d543b3638c4d420e923446606ad8ac2e2", "patch": "@@ -11,7 +11,7 @@\n // xfail-fast\n \n pub fn main() {\n-    let po = comm::PortSet();\n+    let po = comm::PortSet::new();\n \n     // Spawn 10 tasks each sending us back one int.\n     let mut i = 10;"}, {"sha": "cf06deb1923a6432b42ad8456978ac2ba863fada", "filename": "src/test/run-pass/task-comm-3.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b19c644d543b3638c4d420e923446606ad8ac2e2/src%2Ftest%2Frun-pass%2Ftask-comm-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b19c644d543b3638c4d420e923446606ad8ac2e2/src%2Ftest%2Frun-pass%2Ftask-comm-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-3.rs?ref=b19c644d543b3638c4d420e923446606ad8ac2e2", "patch": "@@ -32,7 +32,7 @@ fn test00() {\n \n     debug!(\"Creating tasks\");\n \n-    let po = comm::PortSet();\n+    let po = comm::PortSet::new();\n \n     let mut i: int = 0;\n "}, {"sha": "67ef5fb19052656ac4af8de77eb0e2c12d9fdcc0", "filename": "src/test/run-pass/task-comm-6.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b19c644d543b3638c4d420e923446606ad8ac2e2/src%2Ftest%2Frun-pass%2Ftask-comm-6.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b19c644d543b3638c4d420e923446606ad8ac2e2/src%2Ftest%2Frun-pass%2Ftask-comm-6.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-6.rs?ref=b19c644d543b3638c4d420e923446606ad8ac2e2", "patch": "@@ -15,7 +15,7 @@ pub fn main() { test00(); }\n fn test00() {\n     let mut r: int = 0;\n     let mut sum: int = 0;\n-    let p = comm::PortSet();\n+    let p = comm::PortSet::new();\n     let c0 = p.chan();\n     let c1 = p.chan();\n     let c2 = p.chan();"}, {"sha": "81b498885255979321476fa0816927aea2cce6a1", "filename": "src/test/run-pass/task-comm-7.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b19c644d543b3638c4d420e923446606ad8ac2e2/src%2Ftest%2Frun-pass%2Ftask-comm-7.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b19c644d543b3638c4d420e923446606ad8ac2e2/src%2Ftest%2Frun-pass%2Ftask-comm-7.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-7.rs?ref=b19c644d543b3638c4d420e923446606ad8ac2e2", "patch": "@@ -23,7 +23,7 @@ fn test00_start(c: comm::Chan<int>, start: int, number_of_messages: int) {\n fn test00() {\n     let mut r: int = 0;\n     let mut sum: int = 0;\n-    let p = comm::PortSet();\n+    let p = comm::PortSet::new();\n     let number_of_messages: int = 10;\n \n     let c = p.chan();"}, {"sha": "a3c8dc554a663c0ba6b7cadb201214ba9edffc1a", "filename": "src/test/run-pass/task-comm-9.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b19c644d543b3638c4d420e923446606ad8ac2e2/src%2Ftest%2Frun-pass%2Ftask-comm-9.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b19c644d543b3638c4d420e923446606ad8ac2e2/src%2Ftest%2Frun-pass%2Ftask-comm-9.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-9.rs?ref=b19c644d543b3638c4d420e923446606ad8ac2e2", "patch": "@@ -22,7 +22,7 @@ fn test00_start(c: &comm::Chan<int>, number_of_messages: int) {\n fn test00() {\n     let r: int = 0;\n     let mut sum: int = 0;\n-    let p = comm::PortSet();\n+    let p = comm::PortSet::new();\n     let number_of_messages: int = 10;\n     let ch = p.chan();\n "}, {"sha": "df1c8708acd11426577e6cdcdb37c15cb621dcac", "filename": "src/test/run-pass/unique-send-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b19c644d543b3638c4d420e923446606ad8ac2e2/src%2Ftest%2Frun-pass%2Funique-send-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b19c644d543b3638c4d420e923446606ad8ac2e2/src%2Ftest%2Frun-pass%2Funique-send-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funique-send-2.rs?ref=b19c644d543b3638c4d420e923446606ad8ac2e2", "patch": "@@ -16,7 +16,7 @@ fn child(c: &SharedChan<~uint>, i: uint) {\n \n pub fn main() {\n     let (p, ch) = stream();\n-    let ch = SharedChan(ch);\n+    let ch = SharedChan::new(ch);\n     let n = 100u;\n     let mut expected = 0u;\n     for uint::range(0u, n) |i| {"}, {"sha": "4c7b2e637024226af563d9ef52c42bc44a42c389", "filename": "src/test/run-pass/unwind-resource.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b19c644d543b3638c4d420e923446606ad8ac2e2/src%2Ftest%2Frun-pass%2Funwind-resource.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b19c644d543b3638c4d420e923446606ad8ac2e2/src%2Ftest%2Frun-pass%2Funwind-resource.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funwind-resource.rs?ref=b19c644d543b3638c4d420e923446606ad8ac2e2", "patch": "@@ -39,7 +39,7 @@ fn f(c: SharedChan<bool>) {\n \n pub fn main() {\n     let (p, c) = stream();\n-    let c = SharedChan(c);\n+    let c = SharedChan::new(c);\n     task::spawn_unlinked(|| f(c.clone()) );\n     error!(\"hiiiiiiiii\");\n     assert!(p.recv());"}]}