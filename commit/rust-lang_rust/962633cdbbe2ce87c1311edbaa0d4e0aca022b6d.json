{"sha": "962633cdbbe2ce87c1311edbaa0d4e0aca022b6d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk2MjYzM2NkYmJlMmNlODdjMTMxMWVkYmFhMGQ0ZTBhY2EwMjJiNmQ=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2016-11-25T11:21:19Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2016-11-28T02:18:10Z"}, "message": "rustc: embed path resolutions into the HIR instead of keeping DefMap.", "tree": {"sha": "a878ca26d71df3b679ce9cf775cc7359aef1100d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a878ca26d71df3b679ce9cf775cc7359aef1100d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/962633cdbbe2ce87c1311edbaa0d4e0aca022b6d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/962633cdbbe2ce87c1311edbaa0d4e0aca022b6d", "html_url": "https://github.com/rust-lang/rust/commit/962633cdbbe2ce87c1311edbaa0d4e0aca022b6d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/962633cdbbe2ce87c1311edbaa0d4e0aca022b6d/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bc096549e84d1edbd051f0b42662c038dd935ff6", "url": "https://api.github.com/repos/rust-lang/rust/commits/bc096549e84d1edbd051f0b42662c038dd935ff6", "html_url": "https://github.com/rust-lang/rust/commit/bc096549e84d1edbd051f0b42662c038dd935ff6"}], "stats": {"total": 1852, "additions": 927, "deletions": 925}, "files": [{"sha": "f21d98a0fc7f97a5eedbb2f9fc3d6b353b375517", "filename": "src/librustc/cfg/construct.rs", "status": "modified", "additions": 9, "deletions": 18, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/962633cdbbe2ce87c1311edbaa0d4e0aca022b6d/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962633cdbbe2ce87c1311edbaa0d4e0aca022b6d/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fcfg%2Fconstruct.rs?ref=962633cdbbe2ce87c1311edbaa0d4e0aca022b6d", "patch": "@@ -10,8 +10,6 @@\n \n use rustc_data_structures::graph;\n use cfg::*;\n-use hir::def::Def;\n-use hir::pat_util;\n use ty::{self, TyCtxt};\n use syntax::ast;\n use syntax::ptr::P;\n@@ -284,15 +282,15 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n \n             hir::ExprBreak(label, ref opt_expr) => {\n                 let v = self.opt_expr(opt_expr, pred);\n-                let loop_scope = self.find_scope(expr, label.map(|l| l.node));\n+                let loop_scope = self.find_scope(expr, label);\n                 let b = self.add_ast_node(expr.id, &[v]);\n                 self.add_exiting_edge(expr, b,\n                                       loop_scope, loop_scope.break_index);\n                 self.add_unreachable_node()\n             }\n \n             hir::ExprAgain(label) => {\n-                let loop_scope = self.find_scope(expr, label.map(|l| l.node));\n+                let loop_scope = self.find_scope(expr, label);\n                 let a = self.add_ast_node(expr.id, &[pred]);\n                 self.add_exiting_edge(expr, a,\n                                       loop_scope, loop_scope.continue_index);\n@@ -457,7 +455,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n                     // Visit the guard expression\n                     let guard_exit = self.expr(&guard, guard_start);\n \n-                    let this_has_bindings = pat_util::pat_contains_bindings_or_wild(&pat);\n+                    let this_has_bindings = pat.contains_bindings_or_wild();\n \n                     // If both this pattern and the previous pattern\n                     // were free of bindings, they must consist only\n@@ -570,23 +568,16 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n \n     fn find_scope(&self,\n                   expr: &hir::Expr,\n-                  label: Option<ast::Name>) -> LoopScope {\n-        if label.is_none() {\n-            return *self.loop_scopes.last().unwrap();\n-        }\n-\n-        match self.tcx.expect_def(expr.id) {\n-            Def::Label(loop_id) => {\n+                  label: Option<hir::Label>) -> LoopScope {\n+        match label {\n+            None => *self.loop_scopes.last().unwrap(),\n+            Some(label) => {\n                 for l in &self.loop_scopes {\n-                    if l.loop_id == loop_id {\n+                    if l.loop_id == label.loop_id {\n                         return *l;\n                     }\n                 }\n-                span_bug!(expr.span, \"no loop scope for id {}\", loop_id);\n-            }\n-\n-            r => {\n-                span_bug!(expr.span, \"bad entry `{:?}` in def_map for label\", r);\n+                span_bug!(expr.span, \"no loop scope for id {}\", label.loop_id);\n             }\n         }\n     }"}, {"sha": "b6fce2d6ca0be1d6474c92e0a36ab43b4e04df75", "filename": "src/librustc/hir/def.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/962633cdbbe2ce87c1311edbaa0d4e0aca022b6d/src%2Flibrustc%2Fhir%2Fdef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962633cdbbe2ce87c1311edbaa0d4e0aca022b6d/src%2Flibrustc%2Fhir%2Fdef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fdef.rs?ref=962633cdbbe2ce87c1311edbaa0d4e0aca022b6d", "patch": "@@ -83,14 +83,6 @@ impl PathResolution {\n         PathResolution { base_def: def, depth: 0 }\n     }\n \n-    /// Get the definition, if fully resolved, otherwise panic.\n-    pub fn full_def(&self) -> Def {\n-        if self.depth != 0 {\n-            bug!(\"path not fully resolved: {:?}\", self);\n-        }\n-        self.base_def\n-    }\n-\n     pub fn kind_name(&self) -> &'static str {\n         if self.depth != 0 {\n             \"associated item\""}, {"sha": "94da10d33f8187a11c0dba5f36d22b702420dc74", "filename": "src/librustc/hir/intravisit.rs", "status": "modified", "additions": 17, "deletions": 5, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/962633cdbbe2ce87c1311edbaa0d4e0aca022b6d/src%2Flibrustc%2Fhir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962633cdbbe2ce87c1311edbaa0d4e0aca022b6d/src%2Flibrustc%2Fhir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fintravisit.rs?ref=962633cdbbe2ce87c1311edbaa0d4e0aca022b6d", "patch": "@@ -38,6 +38,7 @@ use syntax::ast::{NodeId, CRATE_NODE_ID, Name, Attribute};\n use syntax::codemap::Spanned;\n use syntax_pos::Span;\n use hir::*;\n+use hir::def::Def;\n use hir::map::Map;\n use super::itemlikevisit::DeepVisitor;\n \n@@ -155,6 +156,9 @@ pub trait Visitor<'v> : Sized {\n     fn visit_id(&mut self, _node_id: NodeId) {\n         // Nothing to do.\n     }\n+    fn visit_def_mention(&mut self, _def: Def) {\n+        // Nothing to do.\n+    }\n     fn visit_name(&mut self, _span: Span, _name: Name) {\n         // Nothing to do.\n     }\n@@ -507,6 +511,7 @@ pub fn walk_qpath<'v, V: Visitor<'v>>(visitor: &mut V, qpath: &'v QPath, id: Nod\n }\n \n pub fn walk_path<'v, V: Visitor<'v>>(visitor: &mut V, path: &'v Path) {\n+    visitor.visit_def_mention(path.def);\n     for segment in &path.segments {\n         visitor.visit_path_segment(path.span, segment);\n     }\n@@ -566,7 +571,8 @@ pub fn walk_pat<'v, V: Visitor<'v>>(visitor: &mut V, pattern: &'v Pat) {\n         PatKind::Ref(ref subpattern, _) => {\n             visitor.visit_pat(subpattern)\n         }\n-        PatKind::Binding(_, ref pth1, ref optional_subpattern) => {\n+        PatKind::Binding(_, def_id, ref pth1, ref optional_subpattern) => {\n+            visitor.visit_def_mention(Def::Local(def_id));\n             visitor.visit_name(pth1.span, pth1.node);\n             walk_list!(visitor, visit_pat, optional_subpattern);\n         }\n@@ -907,12 +913,18 @@ pub fn walk_expr<'v, V: Visitor<'v>>(visitor: &mut V, expression: &'v Expr) {\n         ExprPath(ref qpath) => {\n             visitor.visit_qpath(qpath, expression.id, expression.span);\n         }\n-        ExprBreak(ref opt_sp_name, ref opt_expr) => {\n-            walk_opt_sp_name(visitor, opt_sp_name);\n+        ExprBreak(None, ref opt_expr) => {\n             walk_list!(visitor, visit_expr, opt_expr);\n         }\n-        ExprAgain(ref opt_sp_name) => {\n-            walk_opt_sp_name(visitor, opt_sp_name);\n+        ExprBreak(Some(label), ref opt_expr) => {\n+            visitor.visit_def_mention(Def::Label(label.loop_id));\n+            visitor.visit_name(label.span, label.name);\n+            walk_list!(visitor, visit_expr, opt_expr);\n+        }\n+        ExprAgain(None) => {}\n+        ExprAgain(Some(label)) => {\n+            visitor.visit_def_mention(Def::Label(label.loop_id));\n+            visitor.visit_name(label.span, label.name);\n         }\n         ExprRet(ref optional_expression) => {\n             walk_list!(visitor, visit_expr, optional_expression);"}, {"sha": "aea05357a84884f54eddf1d402900d3ace4b2dae", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 133, "deletions": 127, "changes": 260, "blob_url": "https://github.com/rust-lang/rust/blob/962633cdbbe2ce87c1311edbaa0d4e0aca022b6d/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962633cdbbe2ce87c1311edbaa0d4e0aca022b6d/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=962633cdbbe2ce87c1311edbaa0d4e0aca022b6d", "patch": "@@ -77,7 +77,7 @@ pub struct LoweringContext<'a> {\n \n pub trait Resolver {\n     // Resolve a global hir path generated by the lowerer when expanding `for`, `if let`, etc.\n-    fn resolve_generated_global_path(&mut self, path: &hir::Path, is_value: bool) -> Def;\n+    fn resolve_generated_global_path(&mut self, path: &mut hir::Path, is_value: bool);\n \n     // Obtain the resolution for a node id\n     fn get_resolution(&mut self, id: NodeId) -> Option<PathResolution>;\n@@ -154,6 +154,15 @@ impl<'a> LoweringContext<'a> {\n         self.sess.next_node_id()\n     }\n \n+    fn expect_full_def(&mut self, id: NodeId) -> Def {\n+        self.resolver.get_resolution(id).map_or(Def::Err, |pr| {\n+            if pr.depth != 0 {\n+                bug!(\"path not fully resolved: {:?}\", pr);\n+            }\n+            pr.base_def\n+        })\n+    }\n+\n     fn diagnostic(&self) -> &errors::Handler {\n         self.sess.diagnostic()\n     }\n@@ -181,6 +190,19 @@ impl<'a> LoweringContext<'a> {\n         o_id.map(|sp_ident| respan(sp_ident.span, sp_ident.node.name))\n     }\n \n+    fn lower_label(&mut self, id: NodeId, label: Option<Spanned<Ident>>) -> Option<hir::Label> {\n+        label.map(|sp_ident| {\n+            hir::Label {\n+                span: sp_ident.span,\n+                name: sp_ident.node.name,\n+                loop_id: match self.expect_full_def(id) {\n+                    Def::Label(loop_id) => loop_id,\n+                    _ => DUMMY_NODE_ID\n+                }\n+            }\n+        })\n+    }\n+\n     fn lower_attrs(&mut self, attrs: &Vec<Attribute>) -> hir::HirVec<Attribute> {\n         attrs.clone().into()\n     }\n@@ -286,6 +308,7 @@ impl<'a> LoweringContext<'a> {\n         let proj_start = p.segments.len() - resolution.depth;\n         let path = P(hir::Path {\n             global: p.global,\n+            def: resolution.base_def,\n             segments: p.segments[..proj_start].iter().enumerate().map(|(i, segment)| {\n                 let param_mode = match (qself_position, param_mode) {\n                     (Some(j), ParamMode::Optional) if i < j => {\n@@ -353,12 +376,14 @@ impl<'a> LoweringContext<'a> {\n     }\n \n     fn lower_path_extra(&mut self,\n+                        id: NodeId,\n                         p: &Path,\n                         name: Option<Name>,\n                         param_mode: ParamMode)\n                         -> hir::Path {\n         hir::Path {\n             global: p.global,\n+            def: self.expect_full_def(id),\n             segments: p.segments.iter().map(|segment| {\n                 self.lower_path_segment(segment, param_mode)\n             }).chain(name.map(|name| {\n@@ -372,10 +397,11 @@ impl<'a> LoweringContext<'a> {\n     }\n \n     fn lower_path(&mut self,\n+                  id: NodeId,\n                   p: &Path,\n                   param_mode: ParamMode)\n                   -> hir::Path {\n-        self.lower_path_extra(p, None, param_mode)\n+        self.lower_path_extra(id, p, None, param_mode)\n     }\n \n     fn lower_path_segment(&mut self,\n@@ -569,7 +595,7 @@ impl<'a> LoweringContext<'a> {\n                                                           span}) => {\n                 hir::WherePredicate::EqPredicate(hir::WhereEqPredicate {\n                     id: id,\n-                    path: self.lower_path(path, ParamMode::Explicit),\n+                    path: self.lower_path(id, path, ParamMode::Explicit),\n                     ty: self.lower_ty(ty),\n                     span: span,\n                 })\n@@ -599,7 +625,7 @@ impl<'a> LoweringContext<'a> {\n \n     fn lower_trait_ref(&mut self, p: &TraitRef) -> hir::TraitRef {\n         hir::TraitRef {\n-            path: self.lower_path(&p.path, ParamMode::Explicit),\n+            path: self.lower_path(p.ref_id, &p.path, ParamMode::Explicit),\n             ref_id: p.ref_id,\n         }\n     }\n@@ -665,6 +691,7 @@ impl<'a> LoweringContext<'a> {\n     }\n \n     fn lower_item_kind(&mut self,\n+                       id: NodeId,\n                        name: &mut Name,\n                        attrs: &hir::HirVec<Attribute>,\n                        vis: &mut hir::Visibility,\n@@ -690,7 +717,7 @@ impl<'a> LoweringContext<'a> {\n                                 Some(ident.name)\n                             };\n \n-                            let mut path = self.lower_path_extra(path, suffix,\n+                            let mut path = self.lower_path_extra(import.id, path, suffix,\n                                                                  ParamMode::Explicit);\n                             path.span = span;\n                             self.items.insert(import.id, hir::Item {\n@@ -705,7 +732,7 @@ impl<'a> LoweringContext<'a> {\n                         path\n                     }\n                 };\n-                let path = P(self.lower_path(path, ParamMode::Explicit));\n+                let path = P(self.lower_path(id, path, ParamMode::Explicit));\n                 let kind = match view_path.node {\n                     ViewPathSimple(ident, _) => {\n                         *name = ident.name;\n@@ -901,7 +928,7 @@ impl<'a> LoweringContext<'a> {\n         let attrs = self.lower_attrs(&i.attrs);\n         let mut vis = self.lower_visibility(&i.vis);\n         let node = self.with_parent_def(i.id, |this| {\n-            this.lower_item_kind(&mut name, &attrs, &mut vis, &i.node)\n+            this.lower_item_kind(i.id, &mut name, &attrs, &mut vis, &i.node)\n         });\n \n         hir::Item {\n@@ -1012,14 +1039,24 @@ impl<'a> LoweringContext<'a> {\n                     self.with_parent_def(p.id, |this| {\n                         match this.resolver.get_resolution(p.id).map(|d| d.base_def) {\n                             // `None` can occur in body-less function signatures\n-                            None | Some(Def::Local(..)) => {\n+                            def @ None | def @ Some(Def::Local(_)) => {\n+                                let def_id = def.map(|d| d.def_id()).unwrap_or_else(|| {\n+                                    this.resolver.definitions().local_def_id(p.id)\n+                                });\n                                 hir::PatKind::Binding(this.lower_binding_mode(binding_mode),\n+                                                      def_id,\n                                                       respan(pth1.span, pth1.node.name),\n                                                       sub.as_ref().map(|x| this.lower_pat(x)))\n                             }\n-                            _ => {\n-                                let path = hir::Path::from_name(pth1.span, pth1.node.name);\n-                                hir::PatKind::Path(hir::QPath::Resolved(None, P(path)))\n+                            Some(def) => {\n+                                hir::PatKind::Path(hir::QPath::Resolved(None, P(hir::Path {\n+                                    span: pth1.span,\n+                                    global: false,\n+                                    def: def,\n+                                    segments: hir_vec![\n+                                        hir::PathSegment::from_name(pth1.node.name)\n+                                    ],\n+                                })))\n                             }\n                         }\n                     })\n@@ -1120,8 +1157,7 @@ impl<'a> LoweringContext<'a> {\n                     let inplace_finalize = [\"ops\", \"InPlace\", \"finalize\"];\n \n                     let make_call = |this: &mut LoweringContext, p, args| {\n-                        let path = this.std_path(e.span, p);\n-                        let path = this.expr_path(path, ThinVec::new());\n+                        let path = this.expr_std_path(e.span, p, ThinVec::new());\n                         P(this.expr_call(e.span, path, args))\n                     };\n \n@@ -1315,13 +1351,12 @@ impl<'a> LoweringContext<'a> {\n                                    ast_expr: &Expr,\n                                    path: &[&str],\n                                    fields: &[(&str, &P<Expr>)]) -> hir::Expr {\n-                        let struct_path = this.std_path(ast_expr.span,\n-                                                        &iter::once(&\"ops\").chain(path)\n-                                                                           .map(|s| *s)\n-                                                                           .collect::<Vec<_>>());\n+                        let struct_path = &iter::once(&\"ops\").chain(path).map(|s| *s)\n+                                                             .collect::<Vec<_>>();\n \n                         let hir_expr = if fields.len() == 0 {\n-                            this.expr_path(struct_path, ast_expr.attrs.clone())\n+                            this.expr_std_path(ast_expr.span, struct_path,\n+                                               ast_expr.attrs.clone())\n                         } else {\n                             let fields = fields.into_iter().map(|&(s, e)| {\n                                 let expr = P(this.lower_expr(&e));\n@@ -1334,7 +1369,7 @@ impl<'a> LoweringContext<'a> {\n                             }).collect();\n                             let attrs = ast_expr.attrs.clone();\n \n-                            this.expr_struct(ast_expr.span, struct_path, fields, None, attrs)\n+                            this.expr_std_struct(ast_expr.span, struct_path, fields, None, attrs)\n                         };\n \n                         this.signal_block_expr(hir_vec![],\n@@ -1378,10 +1413,10 @@ impl<'a> LoweringContext<'a> {\n                     hir::ExprPath(self.lower_qpath(e.id, qself, path, ParamMode::Optional))\n                 }\n                 ExprKind::Break(opt_ident, ref opt_expr) => {\n-                    hir::ExprBreak(self.lower_opt_sp_ident(opt_ident),\n+                    hir::ExprBreak(self.lower_label(e.id, opt_ident),\n                                    opt_expr.as_ref().map(|x| P(self.lower_expr(x))))\n                 }\n-                ExprKind::Continue(opt_ident) => hir::ExprAgain(self.lower_opt_sp_ident(opt_ident)),\n+                ExprKind::Continue(opt_ident) => hir::ExprAgain(self.lower_label(e.id, opt_ident)),\n                 ExprKind::Ret(ref e) => hir::ExprRet(e.as_ref().map(|x| P(self.lower_expr(x)))),\n                 ExprKind::InlineAsm(ref asm) => {\n                     let hir_asm = hir::InlineAsm {\n@@ -1608,10 +1643,10 @@ impl<'a> LoweringContext<'a> {\n \n                     // `match ::std::iter::Iterator::next(&mut iter) { ... }`\n                     let match_expr = {\n-                        let next_path = self.std_path(e.span, &[\"iter\", \"Iterator\", \"next\"]);\n                         let iter = P(self.expr_ident(e.span, iter, iter_pat.id));\n                         let ref_mut_iter = self.expr_mut_addr_of(e.span, iter);\n-                        let next_path = self.expr_path(next_path, ThinVec::new());\n+                        let next_path = &[\"iter\", \"Iterator\", \"next\"];\n+                        let next_path = self.expr_std_path(e.span, next_path, ThinVec::new());\n                         let next_expr = P(self.expr_call(e.span, next_path,\n                                           hir_vec![ref_mut_iter]));\n                         let arms = hir_vec![pat_arm, break_arm];\n@@ -1638,10 +1673,8 @@ impl<'a> LoweringContext<'a> {\n \n                     // `match ::std::iter::IntoIterator::into_iter(<head>) { ... }`\n                     let into_iter_expr = {\n-                        let into_iter_path = self.std_path(e.span,\n-                                                           &[\"iter\", \"IntoIterator\", \"into_iter\"]);\n-\n-                        let into_iter = self.expr_path(into_iter_path, ThinVec::new());\n+                        let into_iter_path = &[\"iter\", \"IntoIterator\", \"into_iter\"];\n+                        let into_iter = self.expr_std_path(e.span, into_iter_path, ThinVec::new());\n                         P(self.expr_call(e.span, into_iter, hir_vec![head]))\n                     };\n \n@@ -1684,8 +1717,8 @@ impl<'a> LoweringContext<'a> {\n                                                               hir::PopUnstableBlock,\n                                                               ThinVec::new());\n \n-                        let path = self.std_path(e.span, &[\"ops\", \"Carrier\", \"translate\"]);\n-                        let path = self.expr_path(path, ThinVec::new());\n+                        let path = &[\"ops\", \"Carrier\", \"translate\"];\n+                        let path = self.expr_std_path(e.span,path, ThinVec::new());\n                         let call = P(self.expr_call(e.span, path, hir_vec![sub_expr]));\n \n                         P(self.signal_block_expr(hir_vec![],\n@@ -1710,15 +1743,15 @@ impl<'a> LoweringContext<'a> {\n                         let err_ident = self.str_to_ident(\"err\");\n                         let err_local = self.pat_ident(e.span, err_ident);\n                         let from_expr = {\n-                            let path = self.std_path(e.span, &[\"convert\", \"From\", \"from\"]);\n-                            let from = self.expr_path(path, ThinVec::new());\n+                            let path = &[\"convert\", \"From\", \"from\"];\n+                            let from = self.expr_std_path(e.span, path, ThinVec::new());\n                             let err_expr = self.expr_ident(e.span, err_ident, err_local.id);\n \n                             self.expr_call(e.span, from, hir_vec![err_expr])\n                         };\n                         let from_err_expr = {\n-                            let path = self.std_path(e.span, &[\"ops\", \"Carrier\", \"from_error\"]);\n-                            let from_err = self.expr_path(path, ThinVec::new());\n+                            let path = &[\"ops\", \"Carrier\", \"from_error\"];\n+                            let from_err = self.expr_std_path(e.span, path, ThinVec::new());\n                             P(self.expr_call(e.span, from_err, hir_vec![from_expr]))\n                         };\n \n@@ -1794,7 +1827,7 @@ impl<'a> LoweringContext<'a> {\n             Visibility::Crate(_) => hir::Visibility::Crate,\n             Visibility::Restricted { ref path, id } => {\n                 hir::Visibility::Restricted {\n-                    path: P(self.lower_path(path, ParamMode::Explicit)),\n+                    path: P(self.lower_path(id, path, ParamMode::Explicit)),\n                     id: id\n                 }\n             }\n@@ -1880,14 +1913,18 @@ impl<'a> LoweringContext<'a> {\n     }\n \n     fn expr_ident(&mut self, span: Span, id: Name, binding: NodeId) -> hir::Expr {\n-        let path = self.path_ident(span, id);\n-        let expr_path = hir::ExprPath(hir::QPath::Resolved(None, P(path)));\n-        let expr = self.expr(span, expr_path, ThinVec::new());\n-\n         let def = {\n             let defs = self.resolver.definitions();\n             Def::Local(defs.local_def_id(binding))\n         };\n+\n+        let expr_path = hir::ExprPath(hir::QPath::Resolved(None, P(hir::Path {\n+            span: span,\n+            global: false,\n+            def: def,\n+            segments: hir_vec![hir::PathSegment::from_name(id)],\n+        })));\n+        let expr = self.expr(span, expr_path, ThinVec::new());\n         self.resolver.record_resolution(expr.id, def);\n \n         expr\n@@ -1897,9 +1934,14 @@ impl<'a> LoweringContext<'a> {\n         self.expr(span, hir::ExprAddrOf(hir::MutMutable, e), ThinVec::new())\n     }\n \n-    fn expr_path(&mut self, path: hir::Path, attrs: ThinVec<Attribute>) -> P<hir::Expr> {\n-        let def = self.resolver.resolve_generated_global_path(&path, true);\n-        let expr = self.expr(path.span, hir::ExprPath(hir::QPath::Resolved(None, P(path))), attrs);\n+    fn expr_std_path(&mut self,\n+                     span: Span,\n+                     components: &[&str],\n+                     attrs: ThinVec<Attribute>)\n+                     -> P<hir::Expr> {\n+        let path = self.std_path(span, components, true);\n+        let def = path.def;\n+        let expr = self.expr(span, hir::ExprPath(hir::QPath::Resolved(None, P(path))), attrs);\n         self.resolver.record_resolution(expr.id, def);\n         P(expr)\n     }\n@@ -1921,15 +1963,16 @@ impl<'a> LoweringContext<'a> {\n         P(self.expr(sp, hir::ExprTup(exprs), ThinVec::new()))\n     }\n \n-    fn expr_struct(&mut self,\n-                   sp: Span,\n-                   path: hir::Path,\n-                   fields: hir::HirVec<hir::Field>,\n-                   e: Option<P<hir::Expr>>,\n-                   attrs: ThinVec<Attribute>) -> P<hir::Expr> {\n-        let def = self.resolver.resolve_generated_global_path(&path, false);\n+    fn expr_std_struct(&mut self,\n+                       span: Span,\n+                       components: &[&str],\n+                       fields: hir::HirVec<hir::Field>,\n+                       e: Option<P<hir::Expr>>,\n+                       attrs: ThinVec<Attribute>) -> P<hir::Expr> {\n+        let path = self.std_path(span, components, false);\n+        let def = path.def;\n         let qpath = hir::QPath::Resolved(None, P(path));\n-        let expr = self.expr(sp, hir::ExprStruct(qpath, fields, e), attrs);\n+        let expr = self.expr(span, hir::ExprStruct(qpath, fields, e), attrs);\n         self.resolver.record_resolution(expr.id, def);\n         P(expr)\n     }\n@@ -1988,28 +2031,28 @@ impl<'a> LoweringContext<'a> {\n     }\n \n     fn pat_ok(&mut self, span: Span, pat: P<hir::Pat>) -> P<hir::Pat> {\n-        let path = self.std_path(span, &[\"result\", \"Result\", \"Ok\"]);\n-        self.pat_enum(span, path, hir_vec![pat])\n+        self.pat_std_enum(span, &[\"result\", \"Result\", \"Ok\"], hir_vec![pat])\n     }\n \n     fn pat_err(&mut self, span: Span, pat: P<hir::Pat>) -> P<hir::Pat> {\n-        let path = self.std_path(span, &[\"result\", \"Result\", \"Err\"]);\n-        self.pat_enum(span, path, hir_vec![pat])\n+        self.pat_std_enum(span, &[\"result\", \"Result\", \"Err\"], hir_vec![pat])\n     }\n \n     fn pat_some(&mut self, span: Span, pat: P<hir::Pat>) -> P<hir::Pat> {\n-        let path = self.std_path(span, &[\"option\", \"Option\", \"Some\"]);\n-        self.pat_enum(span, path, hir_vec![pat])\n+        self.pat_std_enum(span, &[\"option\", \"Option\", \"Some\"], hir_vec![pat])\n     }\n \n     fn pat_none(&mut self, span: Span) -> P<hir::Pat> {\n-        let path = self.std_path(span, &[\"option\", \"Option\", \"None\"]);\n-        self.pat_enum(span, path, hir_vec![])\n+        self.pat_std_enum(span, &[\"option\", \"Option\", \"None\"], hir_vec![])\n     }\n \n-    fn pat_enum(&mut self, span: Span, path: hir::Path, subpats: hir::HirVec<P<hir::Pat>>)\n-                -> P<hir::Pat> {\n-        let def = self.resolver.resolve_generated_global_path(&path, true);\n+    fn pat_std_enum(&mut self,\n+                    span: Span,\n+                    components: &[&str],\n+                    subpats: hir::HirVec<P<hir::Pat>>)\n+                    -> P<hir::Pat> {\n+        let path = self.std_path(span, components, true);\n+        let def = path.def;\n         let qpath = hir::QPath::Resolved(None, P(path));\n         let pt = if subpats.is_empty() {\n             hir::PatKind::Path(qpath)\n@@ -2027,25 +2070,27 @@ impl<'a> LoweringContext<'a> {\n \n     fn pat_ident_binding_mode(&mut self, span: Span, name: Name, bm: hir::BindingMode)\n                               -> P<hir::Pat> {\n-        let pat_ident = hir::PatKind::Binding(bm,\n-                                            Spanned {\n-                                                span: span,\n-                                                node: name,\n-                                            },\n-                                            None);\n-\n-        let pat = self.pat(span, pat_ident);\n-\n+        let id = self.next_id();\n         let parent_def = self.parent_def;\n-        let def = {\n+        let def_id = {\n             let defs = self.resolver.definitions();\n             let def_path_data = DefPathData::Binding(name.as_str());\n-            let def_index = defs.create_def_with_parent(parent_def, pat.id, def_path_data);\n-            Def::Local(DefId::local(def_index))\n+            let def_index = defs.create_def_with_parent(parent_def, id, def_path_data);\n+            DefId::local(def_index)\n         };\n-        self.resolver.record_resolution(pat.id, def);\n+        self.resolver.record_resolution(id, Def::Local(def_id));\n \n-        pat\n+        P(hir::Pat {\n+            id: id,\n+            node: hir::PatKind::Binding(bm,\n+                                        def_id,\n+                                        Spanned {\n+                                            span: span,\n+                                            node: name,\n+                                        },\n+                                        None),\n+            span: span,\n+        })\n     }\n \n     fn pat_wild(&mut self, span: Span) -> P<hir::Pat> {\n@@ -2060,64 +2105,25 @@ impl<'a> LoweringContext<'a> {\n         })\n     }\n \n-    fn path_ident(&mut self, span: Span, id: Name) -> hir::Path {\n-        self.path(span, vec![id])\n-    }\n-\n-    fn path(&mut self, span: Span, strs: Vec<Name>) -> hir::Path {\n-        self.path_all(span, false, strs, hir::HirVec::new(), hir::HirVec::new(), hir::HirVec::new())\n-    }\n-\n-    fn path_global(&mut self, span: Span, strs: Vec<Name>) -> hir::Path {\n-        self.path_all(span, true, strs, hir::HirVec::new(), hir::HirVec::new(), hir::HirVec::new())\n-    }\n+    /// Given suffix [\"b\",\"c\",\"d\"], returns path `::std::b::c::d` when\n+    /// `fld.cx.use_std`, and `::core::b::c::d` otherwise.\n+    /// The path is also resolved according to `is_value`.\n+    fn std_path(&mut self, span: Span, components: &[&str], is_value: bool) -> hir::Path {\n+        let idents = self.crate_root.iter().chain(components);\n \n-    fn path_all(&mut self,\n-                sp: Span,\n-                global: bool,\n-                mut names: Vec<Name>,\n-                lifetimes: hir::HirVec<hir::Lifetime>,\n-                types: hir::HirVec<P<hir::Ty>>,\n-                bindings: hir::HirVec<hir::TypeBinding>)\n-                -> hir::Path {\n-        let last_identifier = names.pop().unwrap();\n-        let mut segments: Vec<hir::PathSegment> = names.into_iter().map(|name| {\n-            hir::PathSegment {\n-                name: name,\n-                parameters: hir::PathParameters::none(),\n-           }\n+        let segments: Vec<_> = idents.map(|name| {\n+            hir::PathSegment::from_name(Symbol::intern(name))\n         }).collect();\n \n-        segments.push(hir::PathSegment {\n-            name: last_identifier,\n-            parameters: hir::AngleBracketedParameters(hir::AngleBracketedParameterData {\n-                lifetimes: lifetimes,\n-                types: types,\n-                infer_types: true,\n-                bindings: bindings,\n-            }),\n-        });\n-        hir::Path {\n-            span: sp,\n-            global: global,\n+        let mut path = hir::Path {\n+            span: span,\n+            global: true,\n+            def: Def::Err,\n             segments: segments.into(),\n-        }\n-    }\n-\n-    fn std_path_components(&mut self, components: &[&str]) -> Vec<Name> {\n-        let mut v = Vec::new();\n-        if let Some(s) = self.crate_root {\n-            v.push(Symbol::intern(s));\n-        }\n-        v.extend(components.iter().map(|s| Symbol::intern(s)));\n-        return v;\n-    }\n+        };\n \n-    // Given suffix [\"b\",\"c\",\"d\"], returns path `::std::b::c::d` when\n-    // `fld.cx.use_std`, and `::core::b::c::d` otherwise.\n-    fn std_path(&mut self, span: Span, components: &[&str]) -> hir::Path {\n-        let idents = self.std_path_components(components);\n-        self.path_global(span, idents)\n+        self.resolver.resolve_generated_global_path(&mut path, is_value);\n+        path\n     }\n \n     fn signal_block_expr(&mut self,"}, {"sha": "a08060e792778bf93155b50aca82c7dcbe5b0b3c", "filename": "src/librustc/hir/map/def_collector.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/962633cdbbe2ce87c1311edbaa0d4e0aca022b6d/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962633cdbbe2ce87c1311edbaa0d4e0aca022b6d/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs?ref=962633cdbbe2ce87c1311edbaa0d4e0aca022b6d", "patch": "@@ -436,7 +436,7 @@ impl<'ast> intravisit::Visitor<'ast> for DefCollector<'ast> {\n     fn visit_pat(&mut self, pat: &'ast hir::Pat) {\n         let parent_def = self.parent_def;\n \n-        if let hir::PatKind::Binding(_, name, _) = pat.node {\n+        if let hir::PatKind::Binding(_, _, name, _) = pat.node {\n             let def = self.create_def(pat.id, DefPathData::Binding(name.node.as_str()));\n             self.parent_def = Some(def);\n         }"}, {"sha": "c4ed98ce6e07004ff245653bf01713e58a042cb7", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/962633cdbbe2ce87c1311edbaa0d4e0aca022b6d/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962633cdbbe2ce87c1311edbaa0d4e0aca022b6d/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=962633cdbbe2ce87c1311edbaa0d4e0aca022b6d", "patch": "@@ -658,7 +658,7 @@ impl<'ast> Map<'ast> {\n             NodeVariant(v) => v.node.name,\n             NodeLifetime(lt) => lt.name,\n             NodeTyParam(tp) => tp.name,\n-            NodeLocal(&Pat { node: PatKind::Binding(_,l,_), .. }) => l.node,\n+            NodeLocal(&Pat { node: PatKind::Binding(_,_,l,_), .. }) => l.node,\n             NodeStructCtor(_) => self.name(self.get_parent(id)),\n             _ => bug!(\"no name for {}\", self.node_to_string(id))\n         }"}, {"sha": "1e70ebf585189ae0c6bc150737b3a9ee517b50bf", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 25, "deletions": 20, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/962633cdbbe2ce87c1311edbaa0d4e0aca022b6d/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962633cdbbe2ce87c1311edbaa0d4e0aca022b6d/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=962633cdbbe2ce87c1311edbaa0d4e0aca022b6d", "patch": "@@ -107,6 +107,8 @@ pub struct Path {\n     /// A `::foo` path, is relative to the crate root rather than current\n     /// module (like paths in an import).\n     pub global: bool,\n+    /// The definition that the path resolved to.\n+    pub def: Def,\n     /// The segments in the path: the things separated by `::`.\n     pub segments: HirVec<PathSegment>,\n }\n@@ -123,21 +125,6 @@ impl fmt::Display for Path {\n     }\n }\n \n-impl Path {\n-    /// Convert a span and an identifier to the corresponding\n-    /// 1-segment path.\n-    pub fn from_name(s: Span, name: Name) -> Path {\n-        Path {\n-            span: s,\n-            global: false,\n-            segments: hir_vec![PathSegment {\n-                name: name,\n-                parameters: PathParameters::none()\n-            }],\n-        }\n-    }\n-}\n-\n /// A segment of a path: an identifier, an optional lifetime, and a set of\n /// types.\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n@@ -153,6 +140,16 @@ pub struct PathSegment {\n     pub parameters: PathParameters,\n }\n \n+impl PathSegment {\n+    /// Convert an identifier to the corresponding segment.\n+    pub fn from_name(name: Name) -> PathSegment {\n+        PathSegment {\n+            name: name,\n+            parameters: PathParameters::none()\n+        }\n+    }\n+}\n+\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub enum PathParameters {\n     /// The `<'a, A,B,C>` in `foo::bar::baz::<'a, A,B,C>`\n@@ -571,7 +568,8 @@ pub enum PatKind {\n     Wild,\n \n     /// A fresh binding `ref mut binding @ OPT_SUBPATTERN`.\n-    Binding(BindingMode, Spanned<Name>, Option<P<Pat>>),\n+    /// The `DefId` is for the definition of the variable being bound.\n+    Binding(BindingMode, DefId, Spanned<Name>, Option<P<Pat>>),\n \n     /// A struct or struct variant pattern, e.g. `Variant {x, y, ..}`.\n     /// The `bool` is `true` in the presence of a `..`.\n@@ -944,9 +942,9 @@ pub enum Expr_ {\n     /// A referencing operation (`&a` or `&mut a`)\n     ExprAddrOf(Mutability, P<Expr>),\n     /// A `break`, with an optional label to break\n-    ExprBreak(Option<Spanned<Name>>, Option<P<Expr>>),\n+    ExprBreak(Option<Label>, Option<P<Expr>>),\n     /// A `continue`, with an optional label\n-    ExprAgain(Option<Spanned<Name>>),\n+    ExprAgain(Option<Label>),\n     /// A `return`, with an optional value to be returned\n     ExprRet(Option<P<Expr>>),\n \n@@ -1022,6 +1020,13 @@ pub enum LoopSource {\n }\n \n \n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n+pub struct Label {\n+    pub span: Span,\n+    pub name: Name,\n+    pub loop_id: NodeId\n+}\n+\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n pub enum CaptureClause {\n     CaptureByValue,\n@@ -1225,7 +1230,7 @@ pub type ExplicitSelf = Spanned<SelfKind>;\n \n impl Arg {\n     pub fn to_self(&self) -> Option<ExplicitSelf> {\n-        if let PatKind::Binding(BindByValue(mutbl), name, _) = self.pat.node {\n+        if let PatKind::Binding(BindByValue(mutbl), _, name, _) = self.pat.node {\n             if name.node == keywords::SelfValue.name() {\n                 return match self.ty.node {\n                     TyInfer => Some(respan(self.pat.span, SelfKind::Value(mutbl))),\n@@ -1241,7 +1246,7 @@ impl Arg {\n     }\n \n     pub fn is_self(&self) -> bool {\n-        if let PatKind::Binding(_, name, _) = self.pat.node {\n+        if let PatKind::Binding(_, _, name, _) = self.pat.node {\n             name.node == keywords::SelfValue.name()\n         } else {\n             false"}, {"sha": "0190e74df69533e0be712482fe9fe99a24c1d78e", "filename": "src/librustc/hir/pat_util.rs", "status": "modified", "additions": 122, "deletions": 123, "changes": 245, "blob_url": "https://github.com/rust-lang/rust/blob/962633cdbbe2ce87c1311edbaa0d4e0aca022b6d/src%2Flibrustc%2Fhir%2Fpat_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962633cdbbe2ce87c1311edbaa0d4e0aca022b6d/src%2Flibrustc%2Fhir%2Fpat_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fpat_util.rs?ref=962633cdbbe2ce87c1311edbaa0d4e0aca022b6d", "patch": "@@ -8,13 +8,12 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use hir::def::*;\n+use hir::def::Def;\n use hir::def_id::DefId;\n use hir::{self, PatKind};\n-use ty::TyCtxt;\n use syntax::ast;\n use syntax::codemap::Spanned;\n-use syntax_pos::{Span, DUMMY_SP};\n+use syntax_pos::Span;\n \n use std::iter::{Enumerate, ExactSizeIterator};\n \n@@ -51,144 +50,144 @@ impl<T: ExactSizeIterator> EnumerateAndAdjustIterator for T {\n     }\n }\n \n-pub fn pat_is_refutable(dm: &DefMap, pat: &hir::Pat) -> bool {\n-    match pat.node {\n-        PatKind::Lit(_) |\n-        PatKind::Range(..) |\n-        PatKind::Path(hir::QPath::Resolved(Some(..), _)) |\n-        PatKind::Path(hir::QPath::TypeRelative(..)) => true,\n-\n-        PatKind::TupleStruct(..) |\n-        PatKind::Path(hir::QPath::Resolved(..)) |\n-        PatKind::Struct(..) => {\n-            match dm.get(&pat.id).map(|d| d.full_def()) {\n-                Some(Def::Variant(..)) | Some(Def::VariantCtor(..)) => true,\n-                _ => false\n+impl hir::Pat {\n+    pub fn is_refutable(&self) -> bool {\n+        match self.node {\n+            PatKind::Lit(_) |\n+            PatKind::Range(..) |\n+            PatKind::Path(hir::QPath::Resolved(Some(..), _)) |\n+            PatKind::Path(hir::QPath::TypeRelative(..)) => true,\n+\n+            PatKind::Path(hir::QPath::Resolved(_, ref path)) |\n+            PatKind::TupleStruct(hir::QPath::Resolved(_, ref path), ..) |\n+            PatKind::Struct(hir::QPath::Resolved(_, ref path), ..) => {\n+                match path.def {\n+                    Def::Variant(..) | Def::VariantCtor(..) => true,\n+                    _ => false\n+                }\n             }\n+            PatKind::Slice(..) => true,\n+            _ => false\n         }\n-        PatKind::Slice(..) => true,\n-        _ => false\n     }\n-}\n \n-pub fn pat_is_const(dm: &DefMap, pat: &hir::Pat) -> bool {\n-    match pat.node {\n-        PatKind::Path(hir::QPath::TypeRelative(..)) => true,\n-        PatKind::Path(hir::QPath::Resolved(..)) => {\n-            match dm.get(&pat.id).map(|d| d.full_def()) {\n-                Some(Def::Const(..)) | Some(Def::AssociatedConst(..)) => true,\n-                _ => false\n+    pub fn is_const(&self) -> bool {\n+        match self.node {\n+            PatKind::Path(hir::QPath::TypeRelative(..)) => true,\n+            PatKind::Path(hir::QPath::Resolved(_, ref path)) => {\n+                match path.def {\n+                    Def::Const(..) | Def::AssociatedConst(..) => true,\n+                    _ => false\n+                }\n             }\n+            _ => false\n         }\n-        _ => false\n     }\n-}\n \n-/// Call `f` on every \"binding\" in a pattern, e.g., on `a` in\n-/// `match foo() { Some(a) => (), None => () }`\n-pub fn pat_bindings<F>(pat: &hir::Pat, mut f: F)\n-    where F: FnMut(hir::BindingMode, ast::NodeId, Span, &Spanned<ast::Name>),\n-{\n-    pat.walk(|p| {\n-        if let PatKind::Binding(binding_mode, ref pth, _) = p.node {\n-            f(binding_mode, p.id, p.span, pth);\n-        }\n-        true\n-    });\n-}\n-\n-/// Checks if the pattern contains any patterns that bind something to\n-/// an ident, e.g. `foo`, or `Foo(foo)` or `foo @ Bar(..)`.\n-pub fn pat_contains_bindings(pat: &hir::Pat) -> bool {\n-    let mut contains_bindings = false;\n-    pat.walk(|p| {\n-        if let PatKind::Binding(..) = p.node {\n-            contains_bindings = true;\n-            false // there's at least one binding, can short circuit now.\n-        } else {\n+    /// Call `f` on every \"binding\" in a pattern, e.g., on `a` in\n+    /// `match foo() { Some(a) => (), None => () }`\n+    pub fn each_binding<F>(&self, mut f: F)\n+        where F: FnMut(hir::BindingMode, ast::NodeId, Span, &Spanned<ast::Name>),\n+    {\n+        self.walk(|p| {\n+            if let PatKind::Binding(binding_mode, _, ref pth, _) = p.node {\n+                f(binding_mode, p.id, p.span, pth);\n+            }\n             true\n-        }\n-    });\n-    contains_bindings\n-}\n+        });\n+    }\n \n-/// Checks if the pattern contains any `ref` or `ref mut` bindings,\n-/// and if yes whether its containing mutable ones or just immutables ones.\n-pub fn pat_contains_ref_binding(pat: &hir::Pat) -> Option<hir::Mutability> {\n-    let mut result = None;\n-    pat_bindings(pat, |mode, _, _, _| {\n-        if let hir::BindingMode::BindByRef(m) = mode {\n-            // Pick Mutable as maximum\n-            match result {\n-                None | Some(hir::MutImmutable) => result = Some(m),\n-                _ => (),\n+    /// Checks if the pattern contains any patterns that bind something to\n+    /// an ident, e.g. `foo`, or `Foo(foo)` or `foo @ Bar(..)`.\n+    pub fn contains_bindings(&self) -> bool {\n+        let mut contains_bindings = false;\n+        self.walk(|p| {\n+            if let PatKind::Binding(..) = p.node {\n+                contains_bindings = true;\n+                false // there's at least one binding, can short circuit now.\n+            } else {\n+                true\n             }\n-        }\n-    });\n-    result\n-}\n-\n-/// Checks if the patterns for this arm contain any `ref` or `ref mut`\n-/// bindings, and if yes whether its containing mutable ones or just immutables ones.\n-pub fn arm_contains_ref_binding(arm: &hir::Arm) -> Option<hir::Mutability> {\n-    arm.pats.iter()\n-            .filter_map(|pat| pat_contains_ref_binding(pat))\n-            .max_by_key(|m| match *m {\n-                hir::MutMutable => 1,\n-                hir::MutImmutable => 0,\n-            })\n-}\n+        });\n+        contains_bindings\n+    }\n \n-/// Checks if the pattern contains any patterns that bind something to\n-/// an ident or wildcard, e.g. `foo`, or `Foo(_)`, `foo @ Bar(..)`,\n-pub fn pat_contains_bindings_or_wild(pat: &hir::Pat) -> bool {\n-    let mut contains_bindings = false;\n-    pat.walk(|p| {\n-        match p.node {\n-            PatKind::Binding(..) | PatKind::Wild => {\n-                contains_bindings = true;\n-                false // there's at least one binding/wildcard, can short circuit now.\n+    /// Checks if the pattern contains any patterns that bind something to\n+    /// an ident or wildcard, e.g. `foo`, or `Foo(_)`, `foo @ Bar(..)`,\n+    pub fn contains_bindings_or_wild(&self) -> bool {\n+        let mut contains_bindings = false;\n+        self.walk(|p| {\n+            match p.node {\n+                PatKind::Binding(..) | PatKind::Wild => {\n+                    contains_bindings = true;\n+                    false // there's at least one binding/wildcard, can short circuit now.\n+                }\n+                _ => true\n             }\n-            _ => true\n-        }\n-    });\n-    contains_bindings\n-}\n+        });\n+        contains_bindings\n+    }\n \n-pub fn simple_name<'a>(pat: &'a hir::Pat) -> Option<ast::Name> {\n-    match pat.node {\n-        PatKind::Binding(hir::BindByValue(..), ref path1, None) => {\n-            Some(path1.node)\n-        }\n-        _ => {\n-            None\n+    pub fn simple_name(&self) -> Option<ast::Name> {\n+        match self.node {\n+            PatKind::Binding(hir::BindByValue(..), _, ref path1, None) => {\n+                Some(path1.node)\n+            }\n+            _ => {\n+                None\n+            }\n         }\n     }\n-}\n \n-pub fn def_to_path<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, id: DefId) -> hir::Path {\n-    hir::Path::from_name(DUMMY_SP, tcx.item_name(id))\n-}\n+    /// Return variants that are necessary to exist for the pattern to match.\n+    pub fn necessary_variants(&self) -> Vec<DefId> {\n+        let mut variants = vec![];\n+        self.walk(|p| {\n+            match p.node {\n+                PatKind::Path(hir::QPath::Resolved(_, ref path)) |\n+                PatKind::TupleStruct(hir::QPath::Resolved(_, ref path), ..) |\n+                PatKind::Struct(hir::QPath::Resolved(_, ref path), ..) => {\n+                    match path.def {\n+                        Def::Variant(id) |\n+                        Def::VariantCtor(id, ..) => variants.push(id),\n+                        _ => ()\n+                    }\n+                }\n+                _ => ()\n+            }\n+            true\n+        });\n+        variants.sort();\n+        variants.dedup();\n+        variants\n+    }\n \n-/// Return variants that are necessary to exist for the pattern to match.\n-pub fn necessary_variants(dm: &DefMap, pat: &hir::Pat) -> Vec<DefId> {\n-    let mut variants = vec![];\n-    pat.walk(|p| {\n-        match p.node {\n-            PatKind::TupleStruct(..) |\n-            PatKind::Path(hir::QPath::Resolved(..)) |\n-            PatKind::Struct(..) => {\n-                match dm.get(&p.id).map(|d| d.full_def()) {\n-                    Some(Def::Variant(id)) |\n-                    Some(Def::VariantCtor(id, ..)) => variants.push(id),\n-                    _ => ()\n+    /// Checks if the pattern contains any `ref` or `ref mut` bindings,\n+    /// and if yes whether its containing mutable ones or just immutables ones.\n+    pub fn contains_ref_binding(&self) -> Option<hir::Mutability> {\n+        let mut result = None;\n+        self.each_binding(|mode, _, _, _| {\n+            if let hir::BindingMode::BindByRef(m) = mode {\n+                // Pick Mutable as maximum\n+                match result {\n+                    None | Some(hir::MutImmutable) => result = Some(m),\n+                    _ => (),\n                 }\n             }\n-            _ => ()\n-        }\n-        true\n-    });\n-    variants.sort();\n-    variants.dedup();\n-    variants\n+        });\n+        result\n+    }\n+}\n+\n+impl hir::Arm {\n+    /// Checks if the patterns for this arm contain any `ref` or `ref mut`\n+    /// bindings, and if yes whether its containing mutable ones or just immutables ones.\n+    pub fn contains_ref_binding(&self) -> Option<hir::Mutability> {\n+        self.pats.iter()\n+                 .filter_map(|pat| pat.contains_ref_binding())\n+                 .max_by_key(|m| match *m {\n+                    hir::MutMutable => 1,\n+                    hir::MutImmutable => 0,\n+                 })\n+    }\n }"}, {"sha": "49a1dc92f135cb6574d4a3615974bcf8f1789fff", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/962633cdbbe2ce87c1311edbaa0d4e0aca022b6d/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962633cdbbe2ce87c1311edbaa0d4e0aca022b6d/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=962633cdbbe2ce87c1311edbaa0d4e0aca022b6d", "patch": "@@ -1481,23 +1481,23 @@ impl<'a> State<'a> {\n             hir::ExprPath(ref qpath) => {\n                 self.print_qpath(qpath, true)?\n             }\n-            hir::ExprBreak(opt_name, ref opt_expr) => {\n+            hir::ExprBreak(opt_label, ref opt_expr) => {\n                 word(&mut self.s, \"break\")?;\n                 space(&mut self.s)?;\n-                if let Some(name) = opt_name {\n-                    self.print_name(name.node)?;\n+                if let Some(label) = opt_label {\n+                    self.print_name(label.name)?;\n                     space(&mut self.s)?;\n                 }\n                 if let Some(ref expr) = *opt_expr {\n                     self.print_expr(expr)?;\n                     space(&mut self.s)?;\n                 }\n             }\n-            hir::ExprAgain(opt_name) => {\n+            hir::ExprAgain(opt_label) => {\n                 word(&mut self.s, \"continue\")?;\n                 space(&mut self.s)?;\n-                if let Some(name) = opt_name {\n-                    self.print_name(name.node)?;\n+                if let Some(label) = opt_label {\n+                    self.print_name(label.name)?;\n                     space(&mut self.s)?\n                 }\n             }\n@@ -1782,7 +1782,7 @@ impl<'a> State<'a> {\n         // is that it doesn't matter\n         match pat.node {\n             PatKind::Wild => word(&mut self.s, \"_\")?,\n-            PatKind::Binding(binding_mode, ref path1, ref sub) => {\n+            PatKind::Binding(binding_mode, _, ref path1, ref sub) => {\n                 match binding_mode {\n                     hir::BindByRef(mutbl) => {\n                         self.word_nbsp(\"ref\")?;\n@@ -2185,7 +2185,7 @@ impl<'a> State<'a> {\n                 if let Some(eself) = input.to_self() {\n                     self.print_explicit_self(&eself)?;\n                 } else {\n-                    let invalid = if let PatKind::Binding(_, name, _) = input.pat.node {\n+                    let invalid = if let PatKind::Binding(_, _, name, _) = input.pat.node {\n                         name.node == keywords::Invalid.name()\n                     } else {\n                         false"}, {"sha": "90d752ae6ee297db8100658c6e236c59739d0b4c", "filename": "src/librustc/infer/error_reporting.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/962633cdbbe2ce87c1311edbaa0d4e0aca022b6d/src%2Flibrustc%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962633cdbbe2ce87c1311edbaa0d4e0aca022b6d/src%2Flibrustc%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting.rs?ref=962633cdbbe2ce87c1311edbaa0d4e0aca022b6d", "patch": "@@ -1441,7 +1441,7 @@ impl<'a, 'gcx, 'tcx> Rebuilder<'a, 'gcx, 'tcx> {\n                     ty_queue.push(&mut_ty.ty);\n                 }\n                 hir::TyPath(hir::QPath::Resolved(ref maybe_qself, ref path)) => {\n-                    match self.tcx.expect_def(cur_ty.id) {\n+                    match path.def {\n                         Def::Enum(did) | Def::TyAlias(did) |\n                         Def::Struct(did) | Def::Union(did) => {\n                             let generics = self.tcx.item_generics(did);\n@@ -1621,6 +1621,7 @@ impl<'a, 'gcx, 'tcx> Rebuilder<'a, 'gcx, 'tcx> {\n         hir::Path {\n             span: path.span,\n             global: path.global,\n+            def: path.def,\n             segments: new_segs.into()\n         }\n     }"}, {"sha": "3418034b069d606c7b4f084b0fa6ce5035d6bb17", "filename": "src/librustc/middle/astconv_util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/962633cdbbe2ce87c1311edbaa0d4e0aca022b6d/src%2Flibrustc%2Fmiddle%2Fastconv_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962633cdbbe2ce87c1311edbaa0d4e0aca022b6d/src%2Flibrustc%2Fmiddle%2Fastconv_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastconv_util.rs?ref=962633cdbbe2ce87c1311edbaa0d4e0aca022b6d", "patch": "@@ -71,7 +71,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     /// to it.\n     pub fn ast_ty_to_prim_ty(self, ast_ty: &hir::Ty) -> Option<Ty<'tcx>> {\n         if let hir::TyPath(hir::QPath::Resolved(None, ref path)) = ast_ty.node {\n-            if let Def::PrimTy(nty) = self.expect_def(ast_ty.id) {\n+            if let Def::PrimTy(nty) = path.def {\n                 Some(self.prim_ty_to_ty(&path.segments, nty))\n             } else {\n                 None"}, {"sha": "618e2b05f13b7f61a249b73aefd2b79111c505e2", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 14, "deletions": 19, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/962633cdbbe2ce87c1311edbaa0d4e0aca022b6d/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962633cdbbe2ce87c1311edbaa0d4e0aca022b6d/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=962633cdbbe2ce87c1311edbaa0d4e0aca022b6d", "patch": "@@ -14,7 +14,7 @@\n \n use dep_graph::DepNode;\n use hir::map as ast_map;\n-use hir::{self, pat_util, PatKind};\n+use hir::{self, PatKind};\n use hir::intravisit::{self, Visitor};\n use hir::itemlikevisit::ItemLikeVisitor;\n \n@@ -86,9 +86,7 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n         }\n     }\n \n-    fn lookup_and_handle_definition(&mut self, id: ast::NodeId) {\n-        let def = self.tcx.expect_def(id);\n-\n+    fn handle_definition(&mut self, id: ast::NodeId, def: Def) {\n         // If `bar` is a trait item, make sure to mark Foo as alive in `Foo::bar`\n         match def {\n             Def::AssociatedTy(..) | Def::Method(_) | Def::AssociatedConst(_)\n@@ -147,12 +145,10 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n         }\n     }\n \n-    fn handle_field_pattern_match(&mut self, lhs: &hir::Pat,\n+    fn handle_field_pattern_match(&mut self, lhs: &hir::Pat, def: Def,\n                                   pats: &[codemap::Spanned<hir::FieldPat>]) {\n         let variant = match self.tcx.tables().node_id_to_type(lhs.id).sty {\n-            ty::TyAdt(adt, _) => {\n-                adt.variant_of_def(self.tcx.expect_def(lhs.id))\n-            }\n+            ty::TyAdt(adt, _) => adt.variant_of_def(def),\n             _ => span_bug!(lhs.span, \"non-ADT in struct pattern\")\n         };\n         for pat in pats {\n@@ -240,8 +236,9 @@ impl<'a, 'tcx, 'v> Visitor<'v> for MarkSymbolVisitor<'a, 'tcx> {\n \n     fn visit_expr(&mut self, expr: &hir::Expr) {\n         match expr.node {\n-            hir::ExprPath(hir::QPath::TypeRelative(..)) => {\n-                self.lookup_and_handle_definition(expr.id);\n+            hir::ExprPath(ref qpath @ hir::QPath::TypeRelative(..)) => {\n+                let def = self.tcx.tables().qpath_def(qpath, expr.id);\n+                self.handle_definition(expr.id, def);\n             }\n             hir::ExprMethodCall(..) => {\n                 self.lookup_and_handle_method(expr.id);\n@@ -260,8 +257,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for MarkSymbolVisitor<'a, 'tcx> {\n \n     fn visit_arm(&mut self, arm: &hir::Arm) {\n         if arm.pats.len() == 1 {\n-            let pat = &*arm.pats[0];\n-            let variants = pat_util::necessary_variants(&self.tcx.def_map.borrow(), pat);\n+            let variants = arm.pats[0].necessary_variants();\n \n             // Inside the body, ignore constructions of variants\n             // necessary for the pattern to match. Those construction sites\n@@ -276,14 +272,13 @@ impl<'a, 'tcx, 'v> Visitor<'v> for MarkSymbolVisitor<'a, 'tcx> {\n     }\n \n     fn visit_pat(&mut self, pat: &hir::Pat) {\n-        let def_map = &self.tcx.def_map;\n         match pat.node {\n-            PatKind::Struct(_, ref fields, _) => {\n-                self.handle_field_pattern_match(pat, fields);\n+            PatKind::Struct(hir::QPath::Resolved(_, ref path), ref fields, _) => {\n+                self.handle_field_pattern_match(pat, path.def, fields);\n             }\n-            _ if pat_util::pat_is_const(&def_map.borrow(), pat) => {\n-                // it might be the only use of a const\n-                self.lookup_and_handle_definition(pat.id)\n+            PatKind::Path(ref qpath @ hir::QPath::TypeRelative(..)) => {\n+                let def = self.tcx.tables().qpath_def(qpath, pat.id);\n+                self.handle_definition(pat.id, def);\n             }\n             _ => ()\n         }\n@@ -294,7 +289,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for MarkSymbolVisitor<'a, 'tcx> {\n     }\n \n     fn visit_path(&mut self, path: &hir::Path, id: ast::NodeId) {\n-        self.lookup_and_handle_definition(id);\n+        self.handle_definition(id, path.def);\n         intravisit::walk_path(self, path);\n     }\n }"}, {"sha": "ad3607a5bb85617fee58b4d748fab86178b7aa00", "filename": "src/librustc/middle/effect.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/962633cdbbe2ce87c1311edbaa0d4e0aca022b6d/src%2Flibrustc%2Fmiddle%2Feffect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962633cdbbe2ce87c1311edbaa0d4e0aca022b6d/src%2Flibrustc%2Fmiddle%2Feffect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Feffect.rs?ref=962633cdbbe2ce87c1311edbaa0d4e0aca022b6d", "patch": "@@ -186,8 +186,8 @@ impl<'a, 'tcx, 'v> Visitor<'v> for EffectCheckVisitor<'a, 'tcx> {\n             hir::ExprInlineAsm(..) => {\n                 self.require_unsafe(expr.span, \"use of inline assembly\");\n             }\n-            hir::ExprPath(hir::QPath::Resolved(..)) => {\n-                if let Def::Static(def_id, mutbl) = self.tcx.expect_def(expr.id) {\n+            hir::ExprPath(hir::QPath::Resolved(_, ref path)) => {\n+                if let Def::Static(def_id, mutbl) = path.def {\n                     if mutbl {\n                         self.require_unsafe(expr.span, \"use of mutable static\");\n                     } else if match self.tcx.map.get_if_local(def_id) {"}, {"sha": "01d5792441f82455de973efc4509977151593921", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 17, "deletions": 13, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/962633cdbbe2ce87c1311edbaa0d4e0aca022b6d/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962633cdbbe2ce87c1311edbaa0d4e0aca022b6d/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=962633cdbbe2ce87c1311edbaa0d4e0aca022b6d", "patch": "@@ -19,7 +19,6 @@ pub use self::MatchMode::*;\n use self::TrackMatchMode::*;\n use self::OverloadedCallType::*;\n \n-use hir::pat_util;\n use hir::def::Def;\n use hir::def_id::{DefId};\n use infer::InferCtxt;\n@@ -622,7 +621,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n         match local.init {\n             None => {\n                 let delegate = &mut self.delegate;\n-                pat_util::pat_bindings(&local.pat, |_, id, span, _| {\n+                local.pat.each_binding(|_, id, span, _| {\n                     delegate.decl_without_init(id, span);\n                 })\n             }\n@@ -957,16 +956,16 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n         let infcx = self.mc.infcx;\n         let delegate = &mut self.delegate;\n         return_if_err!(mc.cat_pattern(cmt_discr.clone(), pat, |mc, cmt_pat, pat| {\n-            if let PatKind::Binding(bmode, ..) = pat.node {\n+            if let PatKind::Binding(bmode, def_id, ..) = pat.node {\n                 debug!(\"binding cmt_pat={:?} pat={:?} match_mode={:?}\", cmt_pat, pat, match_mode);\n \n                 // pat_ty: the type of the binding being produced.\n                 let pat_ty = return_if_err!(infcx.node_ty(pat.id));\n \n                 // Each match binding is effectively an assignment to the\n                 // binding being produced.\n-                if let Ok(binding_cmt) = mc.cat_def(pat.id, pat.span, pat_ty,\n-                                                    tcx.expect_def(pat.id)) {\n+                let def = Def::Local(def_id);\n+                if let Ok(binding_cmt) = mc.cat_def(pat.id, pat.span, pat_ty, def) {\n                     delegate.mutate(pat.id, pat.span, binding_cmt, MutateMode::Init);\n                 }\n \n@@ -992,9 +991,16 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n         // to the above loop's visit of than the bindings that form\n         // the leaves of the pattern tree structure.\n         return_if_err!(mc.cat_pattern(cmt_discr, pat, |mc, cmt_pat, pat| {\n-            match tcx.expect_def_or_none(pat.id) {\n-                Some(Def::Variant(variant_did)) |\n-                Some(Def::VariantCtor(variant_did, ..)) => {\n+            let qpath = match pat.node {\n+                PatKind::Path(ref qpath) |\n+                PatKind::TupleStruct(ref qpath, ..) |\n+                PatKind::Struct(ref qpath, ..) => qpath,\n+                _ => return\n+            };\n+            let def = tcx.tables().qpath_def(qpath, pat.id);\n+            match def {\n+                Def::Variant(variant_did) |\n+                Def::VariantCtor(variant_did, ..) => {\n                     let enum_did = tcx.parent_def_id(variant_did).unwrap();\n                     let downcast_cmt = if tcx.lookup_adt_def(enum_did).is_univariant() {\n                         cmt_pat\n@@ -1006,14 +1012,12 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n                     debug!(\"variant downcast_cmt={:?} pat={:?}\", downcast_cmt, pat);\n                     delegate.matched_pat(pat, downcast_cmt, match_mode);\n                 }\n-                Some(Def::Struct(..)) | Some(Def::StructCtor(..)) | Some(Def::Union(..)) |\n-                Some(Def::TyAlias(..)) | Some(Def::AssociatedTy(..)) | Some(Def::SelfTy(..)) => {\n+                Def::Struct(..) | Def::StructCtor(..) | Def::Union(..) |\n+                Def::TyAlias(..) | Def::AssociatedTy(..) | Def::SelfTy(..) => {\n                     debug!(\"struct cmt_pat={:?} pat={:?}\", cmt_pat, pat);\n                     delegate.matched_pat(pat, cmt_pat, match_mode);\n                 }\n-                None | Some(Def::Local(..)) |\n-                Some(Def::Const(..)) | Some(Def::AssociatedConst(..)) => {}\n-                def => bug!(\"unexpected definition: {:?}\", def)\n+                _ => {}\n             }\n         }));\n     }"}, {"sha": "0014d17abb7f27b7717f9aed1b557cff935c7a21", "filename": "src/librustc/middle/intrinsicck.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/962633cdbbe2ce87c1311edbaa0d4e0aca022b6d/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962633cdbbe2ce87c1311edbaa0d4e0aca022b6d/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs?ref=962633cdbbe2ce87c1311edbaa0d4e0aca022b6d", "patch": "@@ -160,11 +160,10 @@ impl<'a, 'tcx, 'v> Visitor<'v> for ItemVisitor<'a, 'tcx> {\n \n impl<'a, 'gcx, 'tcx, 'v> Visitor<'v> for ExprVisitor<'a, 'gcx, 'tcx> {\n     fn visit_expr(&mut self, expr: &hir::Expr) {\n-        let def = match expr.node {\n-            hir::ExprPath(_) => {\n-                self.infcx.tcx.expect_def(expr.id)\n-            }\n-            _ => Def::Err\n+        let def = if let hir::ExprPath(ref qpath) = expr.node {\n+            self.infcx.tcx.tables().qpath_def(qpath, expr.id)\n+        } else {\n+            Def::Err\n         };\n         match def {\n             Def::Fn(did) if self.def_id_is_transmute(did) => {"}, {"sha": "eb00238492ee14dbe4ae4fecd79e791e84d60b16", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 24, "deletions": 35, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/962633cdbbe2ce87c1311edbaa0d4e0aca022b6d/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962633cdbbe2ce87c1311edbaa0d4e0aca022b6d/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=962633cdbbe2ce87c1311edbaa0d4e0aca022b6d", "patch": "@@ -111,7 +111,6 @@ use self::VarKind::*;\n \n use dep_graph::DepNode;\n use hir::def::*;\n-use hir::pat_util;\n use ty::{self, TyCtxt, ParameterEnvironment};\n use traits::{self, Reveal};\n use ty::subst::Subst;\n@@ -379,7 +378,7 @@ fn visit_fn(ir: &mut IrMaps,\n     debug!(\"creating fn_maps: {:?}\", &fn_maps as *const IrMaps);\n \n     for arg in &decl.inputs {\n-        pat_util::pat_bindings(&arg.pat, |_bm, arg_id, _x, path1| {\n+        arg.pat.each_binding(|_bm, arg_id, _x, path1| {\n             debug!(\"adding argument {}\", arg_id);\n             let name = path1.node;\n             fn_maps.add_variable(Arg(arg_id, name));\n@@ -412,7 +411,7 @@ fn visit_fn(ir: &mut IrMaps,\n }\n \n fn visit_local(ir: &mut IrMaps, local: &hir::Local) {\n-    pat_util::pat_bindings(&local.pat, |_, p_id, sp, path1| {\n+    local.pat.each_binding(|_, p_id, sp, path1| {\n         debug!(\"adding local variable {}\", p_id);\n         let name = path1.node;\n         ir.add_live_node_for_node(p_id, VarDefNode(sp));\n@@ -426,7 +425,7 @@ fn visit_local(ir: &mut IrMaps, local: &hir::Local) {\n \n fn visit_arm(ir: &mut IrMaps, arm: &hir::Arm) {\n     for pat in &arm.pats {\n-        pat_util::pat_bindings(&pat, |bm, p_id, sp, path1| {\n+        pat.each_binding(|bm, p_id, sp, path1| {\n             debug!(\"adding local variable {} from match with bm {:?}\",\n                    p_id, bm);\n             let name = path1.node;\n@@ -443,10 +442,9 @@ fn visit_arm(ir: &mut IrMaps, arm: &hir::Arm) {\n fn visit_expr(ir: &mut IrMaps, expr: &Expr) {\n     match expr.node {\n       // live nodes required for uses or definitions of variables:\n-      hir::ExprPath(_) => {\n-        let def = ir.tcx.expect_def(expr.id);\n-        debug!(\"expr {}: path that leads to {:?}\", expr.id, def);\n-        if let Def::Local(..) = def {\n+      hir::ExprPath(hir::QPath::Resolved(_, ref path)) => {\n+        debug!(\"expr {}: path that leads to {:?}\", expr.id, path.def);\n+        if let Def::Local(..) = path.def {\n             ir.add_live_node_for_node(expr.id, ExprNode(expr.span));\n         }\n         intravisit::walk_expr(ir, expr);\n@@ -495,7 +493,7 @@ fn visit_expr(ir: &mut IrMaps, expr: &Expr) {\n       hir::ExprBlock(..) | hir::ExprAssign(..) | hir::ExprAssignOp(..) |\n       hir::ExprStruct(..) | hir::ExprRepeat(..) |\n       hir::ExprInlineAsm(..) | hir::ExprBox(..) |\n-      hir::ExprType(..) => {\n+      hir::ExprType(..) | hir::ExprPath(hir::QPath::TypeRelative(..)) => {\n           intravisit::walk_expr(ir, expr);\n       }\n     }\n@@ -587,7 +585,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n     fn pat_bindings<F>(&mut self, pat: &hir::Pat, mut f: F) where\n         F: FnMut(&mut Liveness<'a, 'tcx>, LiveNode, Variable, Span, NodeId),\n     {\n-        pat_util::pat_bindings(pat, |_bm, p_id, sp, _n| {\n+        pat.each_binding(|_bm, p_id, sp, _n| {\n             let ln = self.live_node(p_id, sp);\n             let var = self.variable(p_id, sp);\n             f(self, ln, var, sp, p_id);\n@@ -684,22 +682,13 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n     }\n \n     fn find_loop_scope(&self,\n-                       opt_label: Option<ast::Name>,\n-                       id: NodeId,\n+                       opt_label: Option<hir::Label>,\n                        sp: Span)\n                        -> NodeId {\n         match opt_label {\n-            Some(_) => {\n-                // Refers to a labeled loop. Use the results of resolve\n-                // to find with one\n-                match self.ir.tcx.expect_def(id) {\n-                    Def::Label(loop_id) => loop_id,\n-                    _ => span_bug!(sp, \"label on break/loop \\\n-                                        doesn't refer to a loop\")\n-                }\n-            }\n+            Some(label) => label.loop_id,\n             None => {\n-                // Vanilla 'break' or 'loop', so use the enclosing\n+                // Vanilla 'break' or 'continue', so use the enclosing\n                 // loop scope\n                 if self.loop_scope.is_empty() {\n                     span_bug!(sp, \"break outside loop\");\n@@ -922,8 +911,8 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n         match expr.node {\n           // Interesting cases with control flow or which gen/kill\n \n-          hir::ExprPath(hir::QPath::Resolved(..)) => {\n-              self.access_path(expr, succ, ACC_READ | ACC_USE)\n+          hir::ExprPath(hir::QPath::Resolved(_, ref path)) => {\n+              self.access_path(expr.id, path, succ, ACC_READ | ACC_USE)\n           }\n \n           hir::ExprField(ref e, _) => {\n@@ -1037,7 +1026,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n \n           hir::ExprBreak(opt_label, ref opt_expr) => {\n               // Find which label this break jumps to\n-              let sc = self.find_loop_scope(opt_label.map(|l| l.node), expr.id, expr.span);\n+              let sc = self.find_loop_scope(opt_label, expr.span);\n \n               // Now that we know the label we're going to,\n               // look it up in the break loop nodes table\n@@ -1050,7 +1039,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n \n           hir::ExprAgain(opt_label) => {\n               // Find which label this expr continues to\n-              let sc = self.find_loop_scope(opt_label.map(|l| l.node), expr.id, expr.span);\n+              let sc = self.find_loop_scope(opt_label, expr.span);\n \n               // Now that we know the label we're going to,\n               // look it up in the continue loop nodes table\n@@ -1246,8 +1235,8 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n     fn write_lvalue(&mut self, expr: &Expr, succ: LiveNode, acc: u32)\n                     -> LiveNode {\n         match expr.node {\n-          hir::ExprPath(hir::QPath::Resolved(..)) => {\n-              self.access_path(expr, succ, acc)\n+          hir::ExprPath(hir::QPath::Resolved(_, ref path)) => {\n+              self.access_path(expr.id, path, succ, acc)\n           }\n \n           // We do not track other lvalues, so just propagate through\n@@ -1258,15 +1247,15 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n         }\n     }\n \n-    fn access_path(&mut self, expr: &Expr, succ: LiveNode, acc: u32)\n+    fn access_path(&mut self, id: NodeId, path: &hir::Path, succ: LiveNode, acc: u32)\n                    -> LiveNode {\n-        match self.ir.tcx.expect_def(expr.id) {\n+        match path.def {\n           Def::Local(def_id) => {\n             let nid = self.ir.tcx.map.as_local_node_id(def_id).unwrap();\n-            let ln = self.live_node(expr.id, expr.span);\n+            let ln = self.live_node(id, path.span);\n             if acc != 0 {\n                 self.init_from_succ(ln, succ);\n-                let var = self.variable(nid, expr.span);\n+                let var = self.variable(nid, path.span);\n                 self.acc(ln, var, acc);\n             }\n             ln\n@@ -1482,8 +1471,8 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n \n     fn check_lvalue(&mut self, expr: &Expr) {\n         match expr.node {\n-            hir::ExprPath(hir::QPath::Resolved(..)) => {\n-                if let Def::Local(def_id) = self.ir.tcx.expect_def(expr.id) {\n+            hir::ExprPath(hir::QPath::Resolved(_, ref path)) => {\n+                if let Def::Local(def_id) = path.def {\n                     // Assignment to an immutable variable or argument: only legal\n                     // if there is no later assignment. If this local is actually\n                     // mutable, then check for a reassignment to flag the mutability\n@@ -1513,7 +1502,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n \n     fn warn_about_unused_args(&self, decl: &hir::FnDecl, entry_ln: LiveNode) {\n         for arg in &decl.inputs {\n-            pat_util::pat_bindings(&arg.pat, |_bm, p_id, sp, path1| {\n+            arg.pat.each_binding(|_bm, p_id, sp, path1| {\n                 let var = self.variable(p_id, sp);\n                 // Ignore unused self.\n                 let name = path1.node;"}, {"sha": "b9542d6fc5c4b81b8e2da496c485d3085e453729", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 23, "deletions": 14, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/962633cdbbe2ce87c1311edbaa0d4e0aca022b6d/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962633cdbbe2ce87c1311edbaa0d4e0aca022b6d/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=962633cdbbe2ce87c1311edbaa0d4e0aca022b6d", "patch": "@@ -488,8 +488,9 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n             }\n           }\n \n-          hir::ExprPath(_) => {\n-            self.cat_def(expr.id, expr.span, expr_ty, self.tcx().expect_def(expr.id))\n+          hir::ExprPath(ref qpath) => {\n+            let def = self.tcx().tables().qpath_def(qpath, expr.id);\n+            self.cat_def(expr.id, expr.span, expr_ty, def)\n           }\n \n           hir::ExprType(ref e, _) => {\n@@ -1062,24 +1063,32 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n \n         // Note: This goes up here (rather than within the PatKind::TupleStruct arm\n         // alone) because PatKind::Struct can also refer to variants.\n-        let cmt = match self.tcx().expect_def_or_none(pat.id) {\n-            Some(Def::Err) => return Err(()),\n-            Some(Def::Variant(variant_did)) |\n-            Some(Def::VariantCtor(variant_did, ..)) => {\n-                // univariant enums do not need downcasts\n-                let enum_did = self.tcx().parent_def_id(variant_did).unwrap();\n-                if !self.tcx().lookup_adt_def(enum_did).is_univariant() {\n-                    self.cat_downcast(pat, cmt.clone(), cmt.ty, variant_did)\n-                } else {\n-                    cmt\n+        let cmt = match pat.node {\n+            PatKind::Path(hir::QPath::Resolved(_, ref path)) |\n+            PatKind::TupleStruct(hir::QPath::Resolved(_, ref path), ..) |\n+            PatKind::Struct(hir::QPath::Resolved(_, ref path), ..) => {\n+                match path.def {\n+                    Def::Err => return Err(()),\n+                    Def::Variant(variant_did) |\n+                    Def::VariantCtor(variant_did, ..) => {\n+                        // univariant enums do not need downcasts\n+                        let enum_did = self.tcx().parent_def_id(variant_did).unwrap();\n+                        if !self.tcx().lookup_adt_def(enum_did).is_univariant() {\n+                            self.cat_downcast(pat, cmt.clone(), cmt.ty, variant_did)\n+                        } else {\n+                            cmt\n+                        }\n+                    }\n+                    _ => cmt\n                 }\n             }\n             _ => cmt\n         };\n \n         match pat.node {\n-          PatKind::TupleStruct(_, ref subpats, ddpos) => {\n-            let expected_len = match self.tcx().expect_def(pat.id) {\n+          PatKind::TupleStruct(ref qpath, ref subpats, ddpos) => {\n+            let def = self.tcx().tables().qpath_def(qpath, pat.id);\n+            let expected_len = match def {\n                 Def::VariantCtor(def_id, CtorKind::Fn) => {\n                     let enum_def = self.tcx().parent_def_id(def_id).unwrap();\n                     self.tcx().lookup_adt_def(enum_def).variant_with_id(def_id).fields.len()"}, {"sha": "e9b731ebaf2b66303067f079aaa5a0f491ac0546", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 27, "deletions": 32, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/962633cdbbe2ce87c1311edbaa0d4e0aca022b6d/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962633cdbbe2ce87c1311edbaa0d4e0aca022b6d/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=962633cdbbe2ce87c1311edbaa0d4e0aca022b6d", "patch": "@@ -90,45 +90,40 @@ struct ReachableContext<'a, 'tcx: 'a> {\n \n impl<'a, 'tcx, 'v> Visitor<'v> for ReachableContext<'a, 'tcx> {\n     fn visit_expr(&mut self, expr: &hir::Expr) {\n-        match expr.node {\n-            hir::ExprPath(_) => {\n-                let def = self.tcx.expect_def(expr.id);\n-                let def_id = def.def_id();\n-                if let Some(node_id) = self.tcx.map.as_local_node_id(def_id) {\n-                    if self.def_id_represents_local_inlined_item(def_id) {\n-                        self.worklist.push(node_id);\n-                    } else {\n-                        match def {\n-                            // If this path leads to a constant, then we need to\n-                            // recurse into the constant to continue finding\n-                            // items that are reachable.\n-                            Def::Const(..) | Def::AssociatedConst(..) => {\n-                                self.worklist.push(node_id);\n-                            }\n-\n-                            // If this wasn't a static, then the destination is\n-                            // surely reachable.\n-                            _ => {\n-                                self.reachable_symbols.insert(node_id);\n-                            }\n-                        }\n-                    }\n-                }\n+        let def = match expr.node {\n+            hir::ExprPath(ref qpath) => {\n+                Some(self.tcx.tables().qpath_def(qpath, expr.id))\n             }\n             hir::ExprMethodCall(..) => {\n                 let method_call = ty::MethodCall::expr(expr.id);\n-                let def_id = self.tcx.tables().method_map[&method_call].def_id;\n+                let def_id = self.tcx.tables.borrow().method_map[&method_call].def_id;\n+                Some(Def::Method(def_id))\n+            }\n+            _ => None\n+        };\n+\n+        if let Some(def) = def {\n+            let def_id = def.def_id();\n+            if let Some(node_id) = self.tcx.map.as_local_node_id(def_id) {\n+                if self.def_id_represents_local_inlined_item(def_id) {\n+                    self.worklist.push(node_id);\n+                } else {\n+                    match def {\n+                        // If this path leads to a constant, then we need to\n+                        // recurse into the constant to continue finding\n+                        // items that are reachable.\n+                        Def::Const(..) | Def::AssociatedConst(..) => {\n+                            self.worklist.push(node_id);\n+                        }\n \n-                // Mark the trait item (and, possibly, its default impl) as reachable\n-                // Or mark inherent impl item as reachable\n-                if let Some(node_id) = self.tcx.map.as_local_node_id(def_id) {\n-                    if self.def_id_represents_local_inlined_item(def_id) {\n-                        self.worklist.push(node_id)\n+                        // If this wasn't a static, then the destination is\n+                        // surely reachable.\n+                        _ => {\n+                            self.reachable_symbols.insert(node_id);\n+                        }\n                     }\n-                    self.reachable_symbols.insert(node_id);\n                 }\n             }\n-            _ => {}\n         }\n \n         intravisit::walk_expr(self, expr)"}, {"sha": "d07062f98a9d14fad85ec64190ca1b92b0ff2bf1", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/962633cdbbe2ce87c1311edbaa0d4e0aca022b6d/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962633cdbbe2ce87c1311edbaa0d4e0aca022b6d/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=962633cdbbe2ce87c1311edbaa0d4e0aca022b6d", "patch": "@@ -21,7 +21,7 @@ use self::ScopeChain::*;\n use dep_graph::DepNode;\n use hir::map::Map;\n use session::Session;\n-use hir::def::{Def, DefMap};\n+use hir::def::Def;\n use hir::def_id::DefId;\n use middle::region;\n use ty;\n@@ -65,7 +65,6 @@ struct LifetimeContext<'a, 'tcx: 'a> {\n     hir_map: &'a Map<'tcx>,\n     map: &'a mut NamedRegionMap,\n     scope: Scope<'a>,\n-    def_map: &'a DefMap,\n     // Deep breath. Our representation for poly trait refs contains a single\n     // binder and thus we only allow a single level of quantification. However,\n     // the syntax of Rust permits quantification in two places, e.g., `T: for <'a> Foo<'a>`\n@@ -109,8 +108,7 @@ type Scope<'a> = &'a ScopeChain<'a>;\n static ROOT_SCOPE: ScopeChain<'static> = RootScope;\n \n pub fn krate(sess: &Session,\n-             hir_map: &Map,\n-             def_map: &DefMap)\n+             hir_map: &Map)\n              -> Result<NamedRegionMap, usize> {\n     let _task = hir_map.dep_graph.in_task(DepNode::ResolveLifetimes);\n     let krate = hir_map.krate();\n@@ -124,7 +122,6 @@ pub fn krate(sess: &Session,\n             hir_map: hir_map,\n             map: &mut map,\n             scope: &ROOT_SCOPE,\n-            def_map: def_map,\n             trait_ref_hack: false,\n             labels_in_fn: vec![],\n         }, krate);\n@@ -247,8 +244,8 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n             hir::TyPath(hir::QPath::Resolved(None, ref path)) => {\n                 // if this path references a trait, then this will resolve to\n                 // a trait ref, which introduces a binding scope.\n-                match self.def_map.get(&ty.id).map(|d| (d.base_def, d.depth)) {\n-                    Some((Def::Trait(..), 0)) => {\n+                match path.def {\n+                    Def::Trait(..) => {\n                         self.with(LateScope(&[], self.scope), |_, this| {\n                             this.visit_path(path, ty.id);\n                         });\n@@ -541,7 +538,6 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n             hir_map: hir_map,\n             map: *map,\n             scope: &wrap_scope,\n-            def_map: self.def_map,\n             trait_ref_hack: self.trait_ref_hack,\n             labels_in_fn: self.labels_in_fn.clone(),\n         };"}, {"sha": "29af505f9dc40bc9a5ad5f0750206f681e091ee1", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/962633cdbbe2ce87c1311edbaa0d4e0aca022b6d/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962633cdbbe2ce87c1311edbaa0d4e0aca022b6d/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=962633cdbbe2ce87c1311edbaa0d4e0aca022b6d", "patch": "@@ -468,8 +468,8 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n         intravisit::walk_expr(self, ex);\n     }\n \n-    fn visit_path(&mut self, path: &'tcx hir::Path, id: ast::NodeId) {\n-        check_path(self.tcx, path, id,\n+    fn visit_path(&mut self, path: &'tcx hir::Path, _: ast::NodeId) {\n+        check_path(self.tcx, path,\n                    &mut |id, sp, stab, depr| self.check(id, sp, stab, depr));\n         intravisit::walk_path(self, path)\n     }\n@@ -526,7 +526,7 @@ pub fn check_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         // individually as it's possible to have a stable trait with unstable\n         // items.\n         hir::ItemImpl(.., Some(ref t), _, ref impl_item_refs) => {\n-            let trait_did = tcx.expect_def(t.ref_id).def_id();\n+            let trait_did = t.path.def.def_id();\n             for impl_item_ref in impl_item_refs {\n                 let impl_item = tcx.map.impl_item(impl_item_ref.id);\n                 let item = tcx.associated_items(trait_did)\n@@ -553,9 +553,9 @@ pub fn check_expr<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, e: &hir::Expr,\n             let method_call = ty::MethodCall::expr(e.id);\n             tcx.tables().method_map[&method_call].def_id\n         }\n-        hir::ExprPath(hir::QPath::TypeRelative(..)) => {\n+        hir::ExprPath(ref qpath @ hir::QPath::TypeRelative(..)) => {\n             span = e.span;\n-            tcx.expect_def(e.id).def_id()\n+            tcx.tables().qpath_def(qpath, e.id).def_id()\n         }\n         hir::ExprField(ref base_e, ref field) => {\n             span = field.span;\n@@ -611,14 +611,13 @@ pub fn check_expr<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, e: &hir::Expr,\n }\n \n pub fn check_path<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                            path: &hir::Path, id: ast::NodeId,\n+                            path: &hir::Path,\n                             cb: &mut FnMut(DefId, Span,\n                                            &Option<&Stability>,\n                                            &Option<DeprecationEntry>)) {\n-    // Paths in import prefixes may have no resolution.\n-    match tcx.expect_def_or_none(id) {\n-        None | Some(Def::PrimTy(..)) | Some(Def::SelfTy(..)) => {}\n-        Some(def) => maybe_do_stability_check(tcx, def.def_id(), path.span, cb)\n+    match path.def {\n+        Def::PrimTy(..) | Def::SelfTy(..) | Def::Err => {}\n+        _ => maybe_do_stability_check(tcx, path.def.def_id(), path.span, cb)\n     }\n }\n \n@@ -629,8 +628,8 @@ pub fn check_pat<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, pat: &hir::Pat,\n     debug!(\"check_pat(pat = {:?})\", pat);\n     if is_internal(tcx, pat.span) { return; }\n \n-    if let PatKind::Path(hir::QPath::TypeRelative(..)) = pat.node {\n-        let def_id = tcx.expect_def(pat.id).def_id();\n+    if let PatKind::Path(ref qpath @ hir::QPath::TypeRelative(..)) = pat.node {\n+        let def_id = tcx.tables().qpath_def(qpath, pat.id).def_id();\n         maybe_do_stability_check(tcx, def_id, pat.span, cb)\n     }\n \n@@ -665,7 +664,7 @@ pub fn check_ty<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, ty: &hir::Ty,\n     if is_internal(tcx, ty.span) { return; }\n \n     if let hir::TyPath(hir::QPath::TypeRelative(..)) = ty.node {\n-        let def_id = tcx.expect_def(ty.id).def_id();\n+        let def_id = tcx.tables().type_relative_path_defs[&ty.id].def_id();\n         maybe_do_stability_check(tcx, def_id, ty.span, cb);\n     }\n }"}, {"sha": "ea81c85ba6a53f96fe1280de57646157bb560dbf", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 15, "deletions": 8, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/962633cdbbe2ce87c1311edbaa0d4e0aca022b6d/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962633cdbbe2ce87c1311edbaa0d4e0aca022b6d/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=962633cdbbe2ce87c1311edbaa0d4e0aca022b6d", "patch": "@@ -14,7 +14,7 @@ use dep_graph::{DepGraph, DepTrackingMap};\n use session::Session;\n use middle;\n use hir::TraitMap;\n-use hir::def::DefMap;\n+use hir::def::Def;\n use hir::def_id::{CrateNum, DefId, DefIndex, LOCAL_CRATE};\n use hir::map as ast_map;\n use hir::map::{DefKey, DefPathData, DisambiguatedDefPathData};\n@@ -201,6 +201,9 @@ pub struct CommonTypes<'tcx> {\n }\n \n pub struct Tables<'tcx> {\n+    /// Resolved definitions for `<T>::X` associated paths.\n+    pub type_relative_path_defs: NodeMap<Def>,\n+\n     /// Stores the types for various nodes in the AST.  Note that this table\n     /// is not guaranteed to be populated until after typeck.  See\n     /// typeck::check::fn_ctxt for details.\n@@ -244,6 +247,7 @@ pub struct Tables<'tcx> {\n impl<'a, 'gcx, 'tcx> Tables<'tcx> {\n     pub fn empty() -> Tables<'tcx> {\n         Tables {\n+            type_relative_path_defs: NodeMap(),\n             node_types: FxHashMap(),\n             item_substs: NodeMap(),\n             adjustments: NodeMap(),\n@@ -256,6 +260,16 @@ impl<'a, 'gcx, 'tcx> Tables<'tcx> {\n         }\n     }\n \n+    /// Returns the final resolution of a `QPath` in an `Expr` or `Pat` node.\n+    pub fn qpath_def(&self, qpath: &hir::QPath, id: NodeId) -> Def {\n+        match *qpath {\n+            hir::QPath::Resolved(_, ref path) => path.def,\n+            hir::QPath::TypeRelative(..) => {\n+                self.type_relative_path_defs.get(&id).cloned().unwrap_or(Def::Err)\n+            }\n+        }\n+    }\n+\n     pub fn node_id_to_type(&self, id: NodeId) -> Ty<'tcx> {\n         match self.node_id_to_type_opt(id) {\n             Some(ty) => ty,\n@@ -379,11 +393,6 @@ pub struct GlobalCtxt<'tcx> {\n \n     pub sess: &'tcx Session,\n \n-    /// Map from path id to the results from resolve; generated\n-    /// initially by resolve and updated during typeck in some cases\n-    /// (e.g., UFCS paths)\n-    pub def_map: RefCell<DefMap>,\n-\n     /// Map indicating what traits are in scope for places where this\n     /// is relevant; generated by resolve.\n     pub trait_map: TraitMap,\n@@ -768,7 +777,6 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     /// reference to the context, to allow formatting values that need it.\n     pub fn create_and_enter<F, R>(s: &'tcx Session,\n                                   arenas: &'tcx CtxtArenas<'tcx>,\n-                                  def_map: DefMap,\n                                   trait_map: TraitMap,\n                                   named_region_map: resolve_lifetime::NamedRegionMap,\n                                   map: ast_map::Map<'tcx>,\n@@ -797,7 +805,6 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             item_variance_map: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n             variance_computed: Cell::new(false),\n             sess: s,\n-            def_map: RefCell::new(def_map),\n             trait_map: trait_map,\n             tables: RefCell::new(Tables::empty()),\n             impl_trait_refs: RefCell::new(DepTrackingMap::new(dep_graph.clone())),"}, {"sha": "ee7cf0788e57087694f4e693225383f2bd1a0194", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 5, "deletions": 21, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/962633cdbbe2ce87c1311edbaa0d4e0aca022b6d/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962633cdbbe2ce87c1311edbaa0d4e0aca022b6d/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=962633cdbbe2ce87c1311edbaa0d4e0aca022b6d", "patch": "@@ -19,7 +19,7 @@ pub use self::fold::TypeFoldable;\n use dep_graph::{self, DepNode};\n use hir::map as ast_map;\n use middle;\n-use hir::def::{Def, CtorKind, PathResolution, ExportMap};\n+use hir::def::{Def, CtorKind, ExportMap};\n use hir::def_id::{CrateNum, DefId, CRATE_DEF_INDEX, LOCAL_CRATE};\n use middle::lang_items::{FnTraitLangItem, FnMutTraitLangItem, FnOnceTraitLangItem};\n use middle::region::{CodeExtent, ROOT_CODE_EXTENT};\n@@ -247,7 +247,7 @@ impl Visibility {\n         match *visibility {\n             hir::Public => Visibility::Public,\n             hir::Visibility::Crate => Visibility::Restricted(ast::CRATE_NODE_ID),\n-            hir::Visibility::Restricted { id, .. } => match tcx.expect_def(id) {\n+            hir::Visibility::Restricted { ref path, .. } => match path.def {\n                 // If there is no resolution, `resolve` will have already reported an error, so\n                 // assume that the visibility is public to avoid reporting more privacy errors.\n                 Def::Err => Visibility::Public,\n@@ -2047,7 +2047,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         match self.map.find(id) {\n             Some(ast_map::NodeLocal(pat)) => {\n                 match pat.node {\n-                    hir::PatKind::Binding(_, ref path1, _) => path1.node.as_str(),\n+                    hir::PatKind::Binding(_, _, ref path1, _) => path1.node.as_str(),\n                     _ => {\n                         bug!(\"Variable id {} maps to {:?}, not local\", id, pat);\n                     },\n@@ -2059,8 +2059,8 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n \n     pub fn expr_is_lval(self, expr: &hir::Expr) -> bool {\n          match expr.node {\n-            hir::ExprPath(hir::QPath::Resolved(..)) => {\n-                match self.expect_def(expr.id) {\n+            hir::ExprPath(hir::QPath::Resolved(_, ref path)) => {\n+                match path.def {\n                     Def::Local(..) | Def::Upvar(..) | Def::Static(..) | Def::Err => true,\n                     _ => false,\n                 }\n@@ -2298,22 +2298,6 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             || self.sess.cstore.impl_trait_ref(self.global_tcx(), id))\n     }\n \n-    /// Returns a path resolution for node id if it exists, panics otherwise.\n-    pub fn expect_resolution(self, id: NodeId) -> PathResolution {\n-        *self.def_map.borrow().get(&id).expect(\"no def-map entry for node id\")\n-    }\n-\n-    /// Returns a fully resolved definition for node id if it exists, panics otherwise.\n-    pub fn expect_def(self, id: NodeId) -> Def {\n-        self.expect_resolution(id).full_def()\n-    }\n-\n-    /// Returns a fully resolved definition for node id if it exists, or none if no\n-    /// definition exists, panics on partial resolutions to catch errors.\n-    pub fn expect_def_or_none(self, id: NodeId) -> Option<Def> {\n-        self.def_map.borrow().get(&id).map(|resolution| resolution.full_def())\n-    }\n-\n     // Returns `ty::VariantDef` if `def` refers to a struct,\n     // or variant or their constructors, panics otherwise.\n     pub fn expect_variant_def(self, def: Def) -> VariantDef<'tcx> {"}, {"sha": "1dde8106ec6a602f587a3666829f83976ebb20bb", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/962633cdbbe2ce87c1311edbaa0d4e0aca022b6d/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962633cdbbe2ce87c1311edbaa0d4e0aca022b6d/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=962633cdbbe2ce87c1311edbaa0d4e0aca022b6d", "patch": "@@ -14,7 +14,6 @@ use hir::def_id::DefId;\n use hir::map::DefPathData;\n use infer::InferCtxt;\n use hir::map as ast_map;\n-use hir::pat_util;\n use traits::{self, Reveal};\n use ty::{self, Ty, AdtKind, TyCtxt, TypeAndMut, TypeFlags, TypeFoldable};\n use ty::{Disr, ParameterEnvironment};\n@@ -180,14 +179,6 @@ impl<'tcx> ParameterEnvironment<'tcx> {\n }\n \n impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n-    pub fn pat_contains_ref_binding(self, pat: &hir::Pat) -> Option<hir::Mutability> {\n-        pat_util::pat_contains_ref_binding(pat)\n-    }\n-\n-    pub fn arm_contains_ref_binding(self, arm: &hir::Arm) -> Option<hir::Mutability> {\n-        pat_util::arm_contains_ref_binding(arm)\n-    }\n-\n     pub fn has_error_field(self, ty: Ty<'tcx>) -> bool {\n         match ty.sty {\n             ty::TyAdt(def, substs) => {"}, {"sha": "2c277c04a52e39568f7230e4c99876c64ec81468", "filename": "src/librustc_borrowck/borrowck/gather_loans/gather_moves.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/962633cdbbe2ce87c1311edbaa0d4e0aca022b6d/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962633cdbbe2ce87c1311edbaa0d4e0aca022b6d/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs?ref=962633cdbbe2ce87c1311edbaa0d4e0aca022b6d", "patch": "@@ -98,7 +98,7 @@ pub fn gather_move_from_pat<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n                                       move_pat: &hir::Pat,\n                                       cmt: mc::cmt<'tcx>) {\n     let pat_span_path_opt = match move_pat.node {\n-        PatKind::Binding(_, ref path1, _) => {\n+        PatKind::Binding(_, _, ref path1, _) => {\n             Some(MoveSpanAndPath{span: move_pat.span,\n                                  name: path1.node})\n         },"}, {"sha": "db24ad0fd67ce36e8056bf913edafa925a0ea5f7", "filename": "src/librustc_const_eval/_match.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/962633cdbbe2ce87c1311edbaa0d4e0aca022b6d/src%2Flibrustc_const_eval%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962633cdbbe2ce87c1311edbaa0d4e0aca022b6d/src%2Flibrustc_const_eval%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2F_match.rs?ref=962633cdbbe2ce87c1311edbaa0d4e0aca022b6d", "patch": "@@ -23,8 +23,8 @@ use rustc_data_structures::indexed_vec::Idx;\n use pattern::{FieldPattern, Pattern, PatternKind};\n use pattern::{PatternFoldable, PatternFolder};\n \n-use rustc::hir::def_id::{DefId};\n-use rustc::hir::pat_util::def_to_path;\n+use rustc::hir::def::Def;\n+use rustc::hir::def_id::DefId;\n use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n \n use rustc::hir;\n@@ -324,7 +324,12 @@ impl Witness {\n \n                 ty::TyAdt(adt, _) => {\n                     let v = ctor.variant_for_adt(adt);\n-                    let qpath = hir::QPath::Resolved(None, P(def_to_path(cx.tcx, v.did)));\n+                    let qpath = hir::QPath::Resolved(None, P(hir::Path {\n+                        span: DUMMY_SP,\n+                        global: false,\n+                        def: Def::Err,\n+                        segments: vec![hir::PathSegment::from_name(v.name)].into(),\n+                    }));\n                     match v.ctor_kind {\n                         CtorKind::Fictive => {\n                             let field_pats: hir::HirVec<_> = v.fields.iter()"}, {"sha": "b67c2c8ec9cddf840c7736c85c1be06a73574992", "filename": "src/librustc_const_eval/check_match.rs", "status": "modified", "additions": 22, "deletions": 28, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/962633cdbbe2ce87c1311edbaa0d4e0aca022b6d/src%2Flibrustc_const_eval%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962633cdbbe2ce87c1311edbaa0d4e0aca022b6d/src%2Flibrustc_const_eval%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fcheck_match.rs?ref=962633cdbbe2ce87c1311edbaa0d4e0aca022b6d", "patch": "@@ -19,8 +19,6 @@ use eval::report_const_eval_err;\n \n use rustc::dep_graph::DepNode;\n \n-use rustc::hir::pat_util::{pat_bindings, pat_contains_bindings};\n-\n use rustc::middle::expr_use_visitor::{ConsumeMode, Delegate, ExprUseVisitor};\n use rustc::middle::expr_use_visitor::{LoanCause, MutateMode};\n use rustc::middle::expr_use_visitor as euv;\n@@ -262,26 +260,22 @@ impl<'a, 'tcx> MatchVisitor<'a, 'tcx> {\n \n fn check_for_bindings_named_the_same_as_variants(cx: &MatchVisitor, pat: &Pat) {\n     pat.walk(|p| {\n-        if let PatKind::Binding(hir::BindByValue(hir::MutImmutable), name, None) = p.node {\n+        if let PatKind::Binding(hir::BindByValue(hir::MutImmutable), _, name, None) = p.node {\n             let pat_ty = cx.tcx.tables().pat_ty(p);\n             if let ty::TyAdt(edef, _) = pat_ty.sty {\n-                if edef.is_enum() {\n-                    if let Def::Local(..) = cx.tcx.expect_def(p.id) {\n-                        if edef.variants.iter().any(|variant| {\n-                            variant.name == name.node && variant.ctor_kind == CtorKind::Const\n-                        }) {\n-                            let ty_path = cx.tcx.item_path_str(edef.did);\n-                            let mut err = struct_span_warn!(cx.tcx.sess, p.span, E0170,\n-                                \"pattern binding `{}` is named the same as one \\\n-                                of the variants of the type `{}`\",\n-                                name.node, ty_path);\n-                            help!(err,\n-                                \"if you meant to match on a variant, \\\n-                                consider making the path in the pattern qualified: `{}::{}`\",\n-                                ty_path, name.node);\n-                            err.emit();\n-                        }\n-                    }\n+                if edef.is_enum() && edef.variants.iter().any(|variant| {\n+                    variant.name == name.node && variant.ctor_kind == CtorKind::Const\n+                }) {\n+                    let ty_path = cx.tcx.item_path_str(edef.did);\n+                    let mut err = struct_span_warn!(cx.tcx.sess, p.span, E0170,\n+                        \"pattern binding `{}` is named the same as one \\\n+                         of the variants of the type `{}`\",\n+                        name.node, ty_path);\n+                    help!(err,\n+                        \"if you meant to match on a variant, \\\n+                        consider making the path in the pattern qualified: `{}::{}`\",\n+                        ty_path, name.node);\n+                    err.emit();\n                 }\n             }\n         }\n@@ -290,13 +284,13 @@ fn check_for_bindings_named_the_same_as_variants(cx: &MatchVisitor, pat: &Pat) {\n }\n \n /// Checks for common cases of \"catchall\" patterns that may not be intended as such.\n-fn pat_is_catchall(dm: &DefMap, pat: &Pat) -> bool {\n+fn pat_is_catchall(pat: &Pat) -> bool {\n     match pat.node {\n         PatKind::Binding(.., None) => true,\n-        PatKind::Binding(.., Some(ref s)) => pat_is_catchall(dm, s),\n-        PatKind::Ref(ref s, _) => pat_is_catchall(dm, s),\n+        PatKind::Binding(.., Some(ref s)) => pat_is_catchall(s),\n+        PatKind::Ref(ref s, _) => pat_is_catchall(s),\n         PatKind::Tuple(ref v, _) => v.iter().all(|p| {\n-            pat_is_catchall(dm, &p)\n+            pat_is_catchall(&p)\n         }),\n         _ => false\n     }\n@@ -374,7 +368,7 @@ fn check_arms<'a, 'tcx>(cx: &mut MatchCheckCtxt<'a, 'tcx>,\n             }\n             if guard.is_none() {\n                 seen.push(v);\n-                if catchall.is_none() && pat_is_catchall(&cx.tcx.def_map.borrow(), hir_pat) {\n+                if catchall.is_none() && pat_is_catchall(hir_pat) {\n                     catchall = Some(pat.span);\n                 }\n             }\n@@ -454,7 +448,7 @@ fn check_legality_of_move_bindings(cx: &MatchVisitor,\n                                    pats: &[P<Pat>]) {\n     let mut by_ref_span = None;\n     for pat in pats {\n-        pat_bindings(&pat, |bm, _, span, _path| {\n+        pat.each_binding(|bm, _, span, _path| {\n             if let hir::BindByRef(..) = bm {\n                 by_ref_span = Some(span);\n             }\n@@ -465,7 +459,7 @@ fn check_legality_of_move_bindings(cx: &MatchVisitor,\n         // check legality of moving out of the enum\n \n         // x @ Foo(..) is legal, but x @ Foo(y) isn't.\n-        if sub.map_or(false, |p| pat_contains_bindings(&p)) {\n+        if sub.map_or(false, |p| p.contains_bindings()) {\n             struct_span_err!(cx.tcx.sess, p.span, E0007,\n                              \"cannot bind by-move with sub-bindings\")\n                 .span_label(p.span, &format!(\"binds an already bound by-move value by moving it\"))\n@@ -486,7 +480,7 @@ fn check_legality_of_move_bindings(cx: &MatchVisitor,\n \n     for pat in pats {\n         pat.walk(|p| {\n-            if let PatKind::Binding(hir::BindByValue(..), _, ref sub) = p.node {\n+            if let PatKind::Binding(hir::BindByValue(..), _, _, ref sub) = p.node {\n                 let pat_ty = cx.tcx.tables().node_id_to_type(p.id);\n                 if pat_ty.moves_by_default(cx.tcx, cx.param_env, pat.span) {\n                     check_move(p, sub.as_ref().map(|p| &**p));"}, {"sha": "053d3072ddf52281a4434c16d40f8dd99d61c091", "filename": "src/librustc_const_eval/eval.rs", "status": "modified", "additions": 38, "deletions": 36, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/962633cdbbe2ce87c1311edbaa0d4e0aca022b6d/src%2Flibrustc_const_eval%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962633cdbbe2ce87c1311edbaa0d4e0aca022b6d/src%2Flibrustc_const_eval%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Feval.rs?ref=962633cdbbe2ce87c1311edbaa0d4e0aca022b6d", "patch": "@@ -19,9 +19,8 @@ use rustc::hir::map as ast_map;\n use rustc::hir::map::blocks::FnLikeNode;\n use rustc::middle::cstore::InlinedItem;\n use rustc::traits;\n-use rustc::hir::def::{Def, CtorKind, PathResolution};\n+use rustc::hir::def::{Def, CtorKind};\n use rustc::hir::def_id::DefId;\n-use rustc::hir::pat_util::def_to_path;\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::ty::util::IntTypeExt;\n use rustc::ty::subst::Substs;\n@@ -42,7 +41,6 @@ use syntax_pos::{self, Span};\n \n use std::borrow::Cow;\n use std::cmp::Ordering;\n-use std::collections::hash_map::Entry::Vacant;\n \n use rustc_const_math::*;\n use rustc_errors::DiagnosticBuilder;\n@@ -282,26 +280,34 @@ pub fn const_expr_to_pat<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                 .collect::<Result<_, _>>()?, None),\n \n         hir::ExprCall(ref callee, ref args) => {\n-            let def = tcx.expect_def(callee.id);\n-            if let Vacant(entry) = tcx.def_map.borrow_mut().entry(expr.id) {\n-               entry.insert(PathResolution::new(def));\n-            }\n-            let qpath = match def {\n-                Def::StructCtor(def_id, CtorKind::Fn) |\n-                Def::VariantCtor(def_id, CtorKind::Fn) => {\n-                    hir::QPath::Resolved(None, P(def_to_path(tcx, def_id)))\n-                }\n-                Def::Fn(..) | Def::Method(..) => return Ok(P(hir::Pat {\n-                    id: expr.id,\n-                    node: PatKind::Lit(P(expr.clone())),\n-                    span: span,\n-                })),\n+            let qpath = match callee.node {\n+                hir::ExprPath(ref qpath) => qpath,\n                 _ => bug!()\n             };\n-            let pats = args.iter()\n-                           .map(|expr| const_expr_to_pat(tcx, &*expr, pat_id, span))\n-                           .collect::<Result<_, _>>()?;\n-            PatKind::TupleStruct(qpath, pats, None)\n+            let def = tcx.tables().qpath_def(qpath, callee.id);\n+            let ctor_path = if let hir::QPath::Resolved(_, ref path) = *qpath {\n+                match def {\n+                    Def::StructCtor(_, CtorKind::Fn) |\n+                    Def::VariantCtor(_, CtorKind::Fn) => {\n+                        Some(path.clone())\n+                    }\n+                    _ => None\n+                }\n+            } else {\n+                None\n+            };\n+            match (def, ctor_path) {\n+                (Def::Fn(..), None) | (Def::Method(..), None) => {\n+                    PatKind::Lit(P(expr.clone()))\n+                }\n+                (_, Some(ctor_path)) => {\n+                    let pats = args.iter()\n+                                   .map(|expr| const_expr_to_pat(tcx, expr, pat_id, span))\n+                                   .collect::<Result<_, _>>()?;\n+                    PatKind::TupleStruct(hir::QPath::Resolved(None, ctor_path), pats, None)\n+                }\n+                _ => bug!()\n+            }\n         }\n \n         hir::ExprStruct(ref qpath, ref fields, None) => {\n@@ -326,8 +332,9 @@ pub fn const_expr_to_pat<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             PatKind::Slice(pats, None, hir::HirVec::new())\n         }\n \n-        hir::ExprPath(_) => {\n-            match tcx.expect_def(expr.id) {\n+        hir::ExprPath(ref qpath) => {\n+            let def = tcx.tables().qpath_def(qpath, expr.id);\n+            match def {\n                 Def::StructCtor(_, CtorKind::Const) |\n                 Def::VariantCtor(_, CtorKind::Const) => {\n                     match expr.node {\n@@ -797,13 +804,8 @@ pub fn eval_const_expr_partial<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             Err(kind) => return Err(ConstEvalErr { span: e.span, kind: kind }),\n         }\n       }\n-      hir::ExprPath(_) => {\n-          // This function can be used before type checking when not all paths are fully resolved.\n-          // FIXME: There's probably a better way to make sure we don't panic here.\n-          let def = match tcx.expect_def_or_none(e.id) {\n-              Some(def) => def,\n-              None => signal!(e, UnresolvedPath)\n-          };\n+      hir::ExprPath(ref qpath) => {\n+          let def = tcx.tables().qpath_def(qpath, e.id);\n           match def {\n               Def::Const(def_id) |\n               Def::AssociatedConst(def_id) => {\n@@ -854,6 +856,7 @@ pub fn eval_const_expr_partial<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                   }\n               },\n               Def::Method(id) | Def::Fn(id) => Function(id),\n+              Def::Err => signal!(e, UnresolvedPath),\n               _ => signal!(e, NonConstPath),\n           }\n       }\n@@ -882,8 +885,9 @@ pub fn eval_const_expr_partial<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                   fn_args\n               )?;\n               debug!(\"const call arg: {:?}\", arg);\n-              let old = call_args.insert(tcx.expect_def(arg.pat.id).def_id(), arg_val);\n-              assert!(old.is_none());\n+              if let PatKind::Binding(_, def_id, _, _) = arg.pat.node {\n+                assert!(call_args.insert(def_id, arg_val).is_none());\n+              }\n           }\n           debug!(\"const call({:?})\", call_args);\n           eval_const_expr_partial(tcx, &result, ty_hint, Some(&call_args))?\n@@ -1368,10 +1372,8 @@ pub fn eval_length<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                 tcx, &err, count_expr.span, reason);\n \n             if let hir::ExprPath(hir::QPath::Resolved(None, ref path)) = count_expr.node {\n-                if !path.global && path.segments.len() == 1 {\n-                    if let Some(Def::Local(..)) = tcx.expect_def_or_none(count_expr.id) {\n-                        diag.note(&format!(\"`{}` is a variable\", path.segments[0].name));\n-                    }\n+                if let Def::Local(..) = path.def {\n+                    diag.note(&format!(\"`{}` is a variable\", path));\n                 }\n             }\n "}, {"sha": "8e803da98f89dc34c90c0a78d3675a73357c50b8", "filename": "src/librustc_const_eval/pattern.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/962633cdbbe2ce87c1311edbaa0d4e0aca022b6d/src%2Flibrustc_const_eval%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962633cdbbe2ce87c1311edbaa0d4e0aca022b6d/src%2Flibrustc_const_eval%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fpattern.rs?ref=962633cdbbe2ce87c1311edbaa0d4e0aca022b6d", "patch": "@@ -163,8 +163,9 @@ impl<'a, 'gcx, 'tcx> PatternContext<'a, 'gcx, 'tcx> {\n                 }\n             }\n \n-            PatKind::Path(..) => {\n-                match self.tcx.expect_def(pat.id) {\n+            PatKind::Path(ref qpath) => {\n+                let def = self.tcx.tables().qpath_def(qpath, pat.id);\n+                match def {\n                     Def::Const(def_id) | Def::AssociatedConst(def_id) => {\n                         let tcx = self.tcx.global_tcx();\n                         let substs = tcx.tables().node_id_item_substs(pat.id)\n@@ -188,7 +189,7 @@ impl<'a, 'gcx, 'tcx> PatternContext<'a, 'gcx, 'tcx> {\n                             }\n                         }\n                     }\n-                    _ => self.lower_variant_or_leaf(pat, vec![])\n+                    _ => self.lower_variant_or_leaf(def, vec![])\n                 }\n             }\n \n@@ -242,8 +243,7 @@ impl<'a, 'gcx, 'tcx> PatternContext<'a, 'gcx, 'tcx> {\n                 }\n             }\n \n-            PatKind::Binding(bm, ref ident, ref sub) => {\n-                let def_id = self.tcx.expect_def(pat.id).def_id();\n+            PatKind::Binding(bm, def_id, ref ident, ref sub) => {\n                 let id = self.tcx.map.as_local_node_id(def_id).unwrap();\n                 let var_ty = self.tcx.tables().node_id_to_type(pat.id);\n                 let region = match var_ty.sty {\n@@ -281,13 +281,14 @@ impl<'a, 'gcx, 'tcx> PatternContext<'a, 'gcx, 'tcx> {\n                 }\n             }\n \n-            PatKind::TupleStruct(_, ref subpatterns, ddpos) => {\n+            PatKind::TupleStruct(ref qpath, ref subpatterns, ddpos) => {\n+                let def = self.tcx.tables().qpath_def(qpath, pat.id);\n                 let pat_ty = self.tcx.tables().node_id_to_type(pat.id);\n                 let adt_def = match pat_ty.sty {\n                     ty::TyAdt(adt_def, _) => adt_def,\n                     _ => span_bug!(pat.span, \"tuple struct pattern not applied to an ADT\"),\n                 };\n-                let variant_def = adt_def.variant_of_def(self.tcx.expect_def(pat.id));\n+                let variant_def = adt_def.variant_of_def(def);\n \n                 let subpatterns =\n                         subpatterns.iter()\n@@ -297,10 +298,11 @@ impl<'a, 'gcx, 'tcx> PatternContext<'a, 'gcx, 'tcx> {\n                                        pattern: self.lower_pattern(field),\n                                    })\n                                    .collect();\n-                self.lower_variant_or_leaf(pat, subpatterns)\n+                self.lower_variant_or_leaf(def, subpatterns)\n             }\n \n-            PatKind::Struct(_, ref fields, _) => {\n+            PatKind::Struct(ref qpath, ref fields, _) => {\n+                let def = self.tcx.tables().qpath_def(qpath, pat.id);\n                 let pat_ty = self.tcx.tables().node_id_to_type(pat.id);\n                 let adt_def = match pat_ty.sty {\n                     ty::TyAdt(adt_def, _) => adt_def,\n@@ -310,7 +312,7 @@ impl<'a, 'gcx, 'tcx> PatternContext<'a, 'gcx, 'tcx> {\n                             \"struct pattern not applied to an ADT\");\n                     }\n                 };\n-                let variant_def = adt_def.variant_of_def(self.tcx.expect_def(pat.id));\n+                let variant_def = adt_def.variant_of_def(def);\n \n                 let subpatterns =\n                     fields.iter()\n@@ -329,7 +331,7 @@ impl<'a, 'gcx, 'tcx> PatternContext<'a, 'gcx, 'tcx> {\n                           })\n                           .collect();\n \n-                self.lower_variant_or_leaf(pat, subpatterns)\n+                self.lower_variant_or_leaf(def, subpatterns)\n             }\n         };\n \n@@ -418,11 +420,11 @@ impl<'a, 'gcx, 'tcx> PatternContext<'a, 'gcx, 'tcx> {\n \n     fn lower_variant_or_leaf(\n         &mut self,\n-        pat: &hir::Pat,\n+        def: Def,\n         subpatterns: Vec<FieldPattern<'tcx>>)\n         -> PatternKind<'tcx>\n     {\n-        match self.tcx.expect_def(pat.id) {\n+        match def {\n             Def::Variant(variant_id) | Def::VariantCtor(variant_id, ..) => {\n                 let enum_id = self.tcx.parent_def_id(variant_id).unwrap();\n                 let adt_def = self.tcx.lookup_adt_def(enum_id);\n@@ -442,9 +444,7 @@ impl<'a, 'gcx, 'tcx> PatternContext<'a, 'gcx, 'tcx> {\n                 PatternKind::Leaf { subpatterns: subpatterns }\n             }\n \n-            def => {\n-                span_bug!(pat.span, \"inappropriate def for pattern: {:?}\", def);\n-            }\n+            _ => bug!()\n         }\n     }\n }"}, {"sha": "a1d1d1105278cc3e8700632edc43e7f8be3b734d", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/962633cdbbe2ce87c1311edbaa0d4e0aca022b6d/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962633cdbbe2ce87c1311edbaa0d4e0aca022b6d/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=962633cdbbe2ce87c1311edbaa0d4e0aca022b6d", "patch": "@@ -840,9 +840,7 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n \n     let named_region_map = time(time_passes,\n                                 \"lifetime resolution\",\n-                                || middle::resolve_lifetime::krate(sess,\n-                                                                   &hir_map,\n-                                                                   &resolutions.def_map))?;\n+                                || middle::resolve_lifetime::krate(sess, &hir_map))?;\n \n     time(time_passes,\n          \"looking for entry point\",\n@@ -859,17 +857,16 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n \n     time(time_passes,\n          \"loop checking\",\n-         || loops::check_crate(sess, &resolutions.def_map, &hir_map));\n+         || loops::check_crate(sess, &hir_map));\n \n     time(time_passes,\n               \"static item recursion checking\",\n-              || static_recursion::check_crate(sess, &resolutions.def_map, &hir_map))?;\n+              || static_recursion::check_crate(sess, &hir_map))?;\n \n     let index = stability::Index::new(&hir_map);\n \n     TyCtxt::create_and_enter(sess,\n                              arenas,\n-                             resolutions.def_map,\n                              resolutions.trait_map,\n                              named_region_map,\n                              hir_map,"}, {"sha": "464e15faeaf75ca4a63fad4f080e9b9bdd0596b6", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/962633cdbbe2ce87c1311edbaa0d4e0aca022b6d/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962633cdbbe2ce87c1311edbaa0d4e0aca022b6d/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=962633cdbbe2ce87c1311edbaa0d4e0aca022b6d", "patch": "@@ -131,12 +131,11 @@ fn test_env<F>(source_string: &str,\n \n     // run just enough stuff to build a tcx:\n     let lang_items = lang_items::collect_language_items(&sess, &ast_map);\n-    let named_region_map = resolve_lifetime::krate(&sess, &ast_map, &resolutions.def_map);\n+    let named_region_map = resolve_lifetime::krate(&sess, &ast_map);\n     let region_map = region::resolve_crate(&sess, &ast_map);\n     let index = stability::Index::new(&ast_map);\n     TyCtxt::create_and_enter(&sess,\n                              &arenas,\n-                             resolutions.def_map,\n                              resolutions.trait_map,\n                              named_region_map.unwrap(),\n                              ast_map,"}, {"sha": "e2b141f2ea62d5f35afb774f9b47823d3cfc34ff", "filename": "src/librustc_incremental/calculate_svh/svh_visitor.rs", "status": "modified", "additions": 7, "deletions": 13, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/962633cdbbe2ce87c1311edbaa0d4e0aca022b6d/src%2Flibrustc_incremental%2Fcalculate_svh%2Fsvh_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962633cdbbe2ce87c1311edbaa0d4e0aca022b6d/src%2Flibrustc_incremental%2Fcalculate_svh%2Fsvh_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fcalculate_svh%2Fsvh_visitor.rs?ref=962633cdbbe2ce87c1311edbaa0d4e0aca022b6d", "patch": "@@ -23,7 +23,7 @@ use syntax_pos::{Span, NO_EXPANSION, COMMAND_LINE_EXPN, BytePos};\n use syntax::tokenstream;\n use rustc::hir;\n use rustc::hir::*;\n-use rustc::hir::def::{Def, PathResolution};\n+use rustc::hir::def::Def;\n use rustc::hir::def_id::DefId;\n use rustc::hir::intravisit as visit;\n use rustc::ty::TyCtxt;\n@@ -335,8 +335,8 @@ fn saw_expr<'a>(node: &'a Expr_,\n         ExprIndex(..)            => (SawExprIndex, true),\n         ExprPath(_)              => (SawExprPath, false),\n         ExprAddrOf(m, _)         => (SawExprAddrOf(m), false),\n-        ExprBreak(id, _)         => (SawExprBreak(id.map(|id| id.node.as_str())), false),\n-        ExprAgain(id)            => (SawExprAgain(id.map(|id| id.node.as_str())), false),\n+        ExprBreak(label, _)      => (SawExprBreak(label.map(|l| l.name.as_str())), false),\n+        ExprAgain(label)         => (SawExprAgain(label.map(|l| l.name.as_str())), false),\n         ExprRet(..)              => (SawExprRet, false),\n         ExprInlineAsm(ref a,..)  => (SawExprInlineAsm(a), false),\n         ExprStruct(..)           => (SawExprStruct, false),\n@@ -669,6 +669,10 @@ impl<'a, 'hash, 'tcx> visit::Visitor<'tcx> for StrictVersionHashVisitor<'a, 'has\n         visit::walk_path(self, path)\n     }\n \n+    fn visit_def_mention(&mut self, def: Def) {\n+        self.hash_def(def);\n+    }\n+\n     fn visit_block(&mut self, b: &'tcx Block) {\n         debug!(\"visit_block: st={:?}\", self.st);\n         SawBlock.hash(self.st);\n@@ -799,11 +803,6 @@ impl<'a, 'hash, 'tcx> StrictVersionHashVisitor<'a, 'hash, 'tcx> {\n         // or not an entry was present (we are already hashing what\n         // variant it is above when we visit the HIR).\n \n-        if let Some(def) = self.tcx.def_map.borrow().get(&id) {\n-            debug!(\"hash_resolve: id={:?} def={:?} st={:?}\", id, def, self.st);\n-            self.hash_partial_def(def);\n-        }\n-\n         if let Some(traits) = self.tcx.trait_map.get(&id) {\n             debug!(\"hash_resolve: id={:?} traits={:?} st={:?}\", id, traits, self.st);\n             traits.len().hash(self.st);\n@@ -825,11 +824,6 @@ impl<'a, 'hash, 'tcx> StrictVersionHashVisitor<'a, 'hash, 'tcx> {\n         self.compute_def_id_hash(def_id).hash(self.st);\n     }\n \n-    fn hash_partial_def(&mut self, def: &PathResolution) {\n-        self.hash_def(def.base_def);\n-        def.depth.hash(self.st);\n-    }\n-\n     fn hash_def(&mut self, def: Def) {\n         match def {\n             // Crucial point: for all of these variants, the variant +"}, {"sha": "7c3ea656124bcdb4fb0e0120d45cad49da75a4ed", "filename": "src/librustc_lint/bad_style.rs", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/962633cdbbe2ce87c1311edbaa0d4e0aca022b6d/src%2Flibrustc_lint%2Fbad_style.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962633cdbbe2ce87c1311edbaa0d4e0aca022b6d/src%2Flibrustc_lint%2Fbad_style.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbad_style.rs?ref=962633cdbbe2ce87c1311edbaa0d4e0aca022b6d", "patch": "@@ -288,12 +288,17 @@ impl LateLintPass for NonSnakeCase {\n     }\n \n     fn check_pat(&mut self, cx: &LateContext, p: &hir::Pat) {\n-        if let &PatKind::Binding(_, ref path1, _) = &p.node {\n-            // Exclude parameter names from foreign functions (they have no `Def`)\n-            if cx.tcx.expect_def_or_none(p.id).is_some() {\n-                self.check_snake_case(cx, \"variable\", &path1.node.as_str(), Some(p.span));\n+        // Exclude parameter names from foreign functions\n+        let parent_node = cx.tcx.map.get_parent_node(p.id);\n+        if let hir::map::NodeForeignItem(item) = cx.tcx.map.get(parent_node) {\n+            if let hir::ForeignItemFn(..) = item.node {\n+                return;\n             }\n         }\n+\n+        if let &PatKind::Binding(_, _, ref path1, _) = &p.node {\n+            self.check_snake_case(cx, \"variable\", &path1.node.as_str(), Some(p.span));\n+        }\n     }\n \n     fn check_struct_def(&mut self,\n@@ -378,7 +383,7 @@ impl LateLintPass for NonUpperCaseGlobals {\n         // Lint for constants that look like binding identifiers (#7526)\n         if let PatKind::Path(hir::QPath::Resolved(None, ref path)) = p.node {\n             if !path.global && path.segments.len() == 1 && path.segments[0].parameters.is_empty() {\n-                if let Def::Const(..) = cx.tcx.expect_def(p.id) {\n+                if let Def::Const(..) = path.def {\n                     NonUpperCaseGlobals::check_upper_case(cx,\n                                                           \"constant in pattern\",\n                                                           path.segments[0].name,"}, {"sha": "490b0028d7473a95455524caab273c7eb2b2424f", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 22, "deletions": 15, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/962633cdbbe2ce87c1311edbaa0d4e0aca022b6d/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962633cdbbe2ce87c1311edbaa0d4e0aca022b6d/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=962633cdbbe2ce87c1311edbaa0d4e0aca022b6d", "patch": "@@ -167,7 +167,7 @@ impl LateLintPass for NonShorthandFieldPatterns {\n                 if fieldpat.node.is_shorthand {\n                     continue;\n                 }\n-                if let PatKind::Binding(_, ident, None) = fieldpat.node.pat.node {\n+                if let PatKind::Binding(_, _, ident, None) = fieldpat.node.pat.node {\n                     if ident.node == fieldpat.node.name {\n                         cx.span_lint(NON_SHORTHAND_FIELD_PATTERNS,\n                                      fieldpat.span,\n@@ -391,7 +391,7 @@ impl LateLintPass for MissingDoc {\n             hir::ItemImpl(.., Some(ref trait_ref), _, ref impl_item_refs) => {\n                 // If the trait is private, add the impl items to private_traits so they don't get\n                 // reported for missing docs.\n-                let real_trait = cx.tcx.expect_def(trait_ref.ref_id).def_id();\n+                let real_trait = trait_ref.path.def.def_id();\n                 if let Some(node_id) = cx.tcx.map.as_local_node_id(real_trait) {\n                     match cx.tcx.map.find(node_id) {\n                         Some(hir_map::NodeItem(item)) => {\n@@ -697,10 +697,9 @@ impl LateLintPass for Deprecated {\n                               &mut |id, sp, stab, depr| self.lint(cx, id, sp, &stab, &depr));\n     }\n \n-    fn check_path(&mut self, cx: &LateContext, path: &hir::Path, id: ast::NodeId) {\n+    fn check_path(&mut self, cx: &LateContext, path: &hir::Path, _: ast::NodeId) {\n         stability::check_path(cx.tcx,\n                               path,\n-                              id,\n                               &mut |id, sp, stab, depr| self.lint(cx, id, sp, &stab, &depr));\n     }\n \n@@ -926,8 +925,12 @@ impl LateLintPass for UnconditionalRecursion {\n         fn expr_refers_to_this_fn(tcx: TyCtxt, fn_id: ast::NodeId, id: ast::NodeId) -> bool {\n             match tcx.map.get(id) {\n                 hir_map::NodeExpr(&hir::Expr { node: hir::ExprCall(ref callee, _), .. }) => {\n-                    tcx.expect_def_or_none(callee.id)\n-                        .map_or(false, |def| def.def_id() == tcx.map.local_def_id(fn_id))\n+                    let def = if let hir::ExprPath(ref qpath) = callee.node {\n+                        tcx.tables().qpath_def(qpath, callee.id)\n+                    } else {\n+                        return false;\n+                    };\n+                    def.def_id() == tcx.map.local_def_id(fn_id)\n                 }\n                 _ => false,\n             }\n@@ -965,10 +968,13 @@ impl LateLintPass for UnconditionalRecursion {\n             // Check for calls to methods via explicit paths (e.g. `T::method()`).\n             match tcx.map.get(id) {\n                 hir_map::NodeExpr(&hir::Expr { node: hir::ExprCall(ref callee, _), .. }) => {\n-                    // The callee is an arbitrary expression,\n-                    // it doesn't necessarily have a definition.\n-                    match tcx.expect_def_or_none(callee.id) {\n-                        Some(Def::Method(def_id)) => {\n+                    let def = if let hir::ExprPath(ref qpath) = callee.node {\n+                        tcx.tables().qpath_def(qpath, callee.id)\n+                    } else {\n+                        return false;\n+                    };\n+                    match def {\n+                        Def::Method(def_id) => {\n                             let substs = tcx.tables().node_id_item_substs(callee.id)\n                                 .unwrap_or_else(|| tcx.intern_substs(&[]));\n                             method_call_refers_to_method(\n@@ -1201,11 +1207,12 @@ impl LateLintPass for MutableTransmutes {\n             (cx: &LateContext<'a, 'tcx>,\n              expr: &hir::Expr)\n              -> Option<(&'tcx ty::TypeVariants<'tcx>, &'tcx ty::TypeVariants<'tcx>)> {\n-            match expr.node {\n-                hir::ExprPath(_) => (),\n-                _ => return None,\n-            }\n-            if let Def::Fn(did) = cx.tcx.expect_def(expr.id) {\n+            let def = if let hir::ExprPath(ref qpath) = expr.node {\n+                cx.tcx.tables().qpath_def(qpath, expr.id)\n+            } else {\n+                return None;\n+            };\n+            if let Def::Fn(did) = def {\n                 if !def_id_is_transmute(cx, did) {\n                     return None;\n                 }"}, {"sha": "873c141065ec37dc41bf3014f37afdd0e248c321", "filename": "src/librustc_lint/unused.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/962633cdbbe2ce87c1311edbaa0d4e0aca022b6d/src%2Flibrustc_lint%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962633cdbbe2ce87c1311edbaa0d4e0aca022b6d/src%2Flibrustc_lint%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Funused.rs?ref=962633cdbbe2ce87c1311edbaa0d4e0aca022b6d", "patch": "@@ -8,7 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use rustc::hir::pat_util;\n use rustc::ty;\n use rustc::ty::adjustment;\n use util::nodemap::FxHashMap;\n@@ -44,7 +43,7 @@ impl UnusedMut {\n \n         let mut mutables = FxHashMap();\n         for p in pats {\n-            pat_util::pat_bindings(p, |mode, id, _, path1| {\n+            p.each_binding(|mode, id, _, path1| {\n                 let name = path1.node;\n                 if let hir::BindByValue(hir::MutMutable) = mode {\n                     if !name.as_str().starts_with(\"_\") {"}, {"sha": "806d20c72dcd92c21e80b9e9c3723de7bab3443a", "filename": "src/librustc_metadata/astencode.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/962633cdbbe2ce87c1311edbaa0d4e0aca022b6d/src%2Flibrustc_metadata%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962633cdbbe2ce87c1311edbaa0d4e0aca022b6d/src%2Flibrustc_metadata%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fastencode.rs?ref=962633cdbbe2ce87c1311edbaa0d4e0aca022b6d", "patch": "@@ -18,7 +18,7 @@ use schema::*;\n \n use rustc::middle::cstore::{InlinedItem, InlinedItemRef};\n use rustc::middle::const_qualif::ConstQualif;\n-use rustc::hir::def::{self, Def};\n+use rustc::hir::def::Def;\n use rustc::hir::def_id::DefId;\n use rustc::ty::{self, TyCtxt, Ty};\n \n@@ -35,7 +35,7 @@ pub struct Ast<'tcx> {\n \n #[derive(RustcEncodable, RustcDecodable)]\n enum TableEntry<'tcx> {\n-    Def(Def),\n+    TypeRelativeDef(Def),\n     NodeType(Ty<'tcx>),\n     ItemSubsts(ty::ItemSubsts<'tcx>),\n     Adjustment(ty::adjustment::Adjustment<'tcx>),\n@@ -93,7 +93,8 @@ impl<'a, 'b, 'tcx, 'v> Visitor<'v> for SideTableEncodingIdVisitor<'a, 'b, 'tcx>\n             }\n         };\n \n-        encode(tcx.expect_def_or_none(id).map(TableEntry::Def));\n+        encode(tcx.tables().type_relative_path_defs.get(&id).cloned()\n+                  .map(TableEntry::TypeRelativeDef));\n         encode(tcx.tables().node_types.get(&id).cloned().map(TableEntry::NodeType));\n         encode(tcx.tables().item_substs.get(&id).cloned().map(TableEntry::ItemSubsts));\n         encode(tcx.tables().adjustments.get(&id).cloned().map(TableEntry::Adjustment));\n@@ -140,8 +141,8 @@ pub fn decode_inlined_item<'a, 'tcx>(cdata: &CrateMetadata,\n \n     for (id, entry) in ast.side_tables.decode((cdata, tcx, id_ranges)) {\n         match entry {\n-            TableEntry::Def(def) => {\n-                tcx.def_map.borrow_mut().insert(id, def::PathResolution::new(def));\n+            TableEntry::TypeRelativeDef(def) => {\n+                tcx.tables.borrow_mut().type_relative_path_defs.insert(id, def);\n             }\n             TableEntry::NodeType(ty) => {\n                 tcx.tables.borrow_mut().node_types.insert(id, ty);"}, {"sha": "a243962b4eef886f01bfeb40b3c4e93996856344", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/962633cdbbe2ce87c1311edbaa0d4e0aca022b6d/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962633cdbbe2ce87c1311edbaa0d4e0aca022b6d/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=962633cdbbe2ce87c1311edbaa0d4e0aca022b6d", "patch": "@@ -597,7 +597,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n \n     fn encode_fn_arg_names(&mut self, decl: &hir::FnDecl) -> LazySeq<ast::Name> {\n         self.lazy_seq(decl.inputs.iter().map(|arg| {\n-            if let PatKind::Binding(_, ref path1, _) = arg.pat.node {\n+            if let PatKind::Binding(_, _, ref path1, _) = arg.pat.node {\n                 path1.node\n             } else {\n                 Symbol::intern(\"\")"}, {"sha": "0e4dbb0477716a246acaa97d24c15c02c4d2860d", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/962633cdbbe2ce87c1311edbaa0d4e0aca022b6d/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962633cdbbe2ce87c1311edbaa0d4e0aca022b6d/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=962633cdbbe2ce87c1311edbaa0d4e0aca022b6d", "patch": "@@ -182,7 +182,7 @@ pub fn construct_fn<'a, 'gcx, 'tcx, A>(hir: Cx<'a, 'gcx, 'tcx>,\n                 by_ref: by_ref\n             };\n             if let Some(hir::map::NodeLocal(pat)) = tcx.map.find(var_id) {\n-                if let hir::PatKind::Binding(_, ref ident, _) = pat.node {\n+                if let hir::PatKind::Binding(_, _, ref ident, _) = pat.node {\n                     decl.debug_name = ident.node;\n                 }\n             }\n@@ -286,7 +286,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             // If this is a simple binding pattern, give the local a nice name for debuginfo.\n             let mut name = None;\n             if let Some(pat) = pattern {\n-                if let hir::PatKind::Binding(_, ref ident, _) = pat.node {\n+                if let hir::PatKind::Binding(_, _, ref ident, _) = pat.node {\n                     name = Some(ident.node);\n                 }\n             }"}, {"sha": "a148ae08c53a4a1270c576141f227e6bd49e43cf", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 25, "deletions": 21, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/962633cdbbe2ce87c1311edbaa0d4e0aca022b6d/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962633cdbbe2ce87c1311edbaa0d4e0aca022b6d/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=962633cdbbe2ce87c1311edbaa0d4e0aca022b6d", "patch": "@@ -18,7 +18,6 @@ use rustc::hir::map;\n use rustc::hir::def::{Def, CtorKind};\n use rustc::middle::const_val::ConstVal;\n use rustc_const_eval as const_eval;\n-use rustc::middle::region::CodeExtent;\n use rustc::ty::{self, AdtKind, VariantDef, Ty};\n use rustc::ty::cast::CastKind as TyCastKind;\n use rustc::hir;\n@@ -265,10 +264,10 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                     args: vec![fun.to_ref(), tupled_args.to_ref()]\n                 }\n             } else {\n-                let adt_data = if let hir::ExprPath(hir::QPath::Resolved(..)) = fun.node {\n+                let adt_data = if let hir::ExprPath(hir::QPath::Resolved(_, ref path)) = fun.node {\n                     // Tuple-like ADTs are represented as ExprCall. We convert them here.\n                     expr_ty.ty_adt_def().and_then(|adt_def|{\n-                        match cx.tcx.expect_def(fun.id) {\n+                        match path.def {\n                             Def::VariantCtor(variant_id, CtorKind::Fn) => {\n                                 Some((adt_def, adt_def.variant_index_with_id(variant_id)))\n                             },\n@@ -456,7 +455,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n             }\n         }\n \n-        hir::ExprStruct(_, ref fields, ref base) => {\n+        hir::ExprStruct(ref qpath, ref fields, ref base) => {\n             match expr_ty.sty {\n                 ty::TyAdt(adt, substs) => match adt.adt_kind() {\n                     AdtKind::Struct | AdtKind::Union => {\n@@ -476,7 +475,11 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                         }\n                     }\n                     AdtKind::Enum => {\n-                        match cx.tcx.expect_def(expr.id) {\n+                        let def = match *qpath {\n+                            hir::QPath::Resolved(_, ref path) => path.def,\n+                            hir::QPath::TypeRelative(..) => Def::Err\n+                        };\n+                        match def {\n                             Def::Variant(variant_id) => {\n                                 assert!(base.is_none());\n \n@@ -490,7 +493,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                                     base: None\n                                 }\n                             }\n-                            ref def => {\n+                            _ => {\n                                 span_bug!(\n                                     expr.span,\n                                     \"unexpected def: {:?}\",\n@@ -531,8 +534,9 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n             }\n         }\n \n-        hir::ExprPath(_) => {\n-            convert_path_expr(cx, expr)\n+        hir::ExprPath(ref qpath) => {\n+            let def = cx.tcx.tables().qpath_def(qpath, expr.id);\n+            convert_path_expr(cx, expr, def)\n         }\n \n         hir::ExprInlineAsm(ref asm, ref outputs, ref inputs) => {\n@@ -559,10 +563,18 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n         hir::ExprRet(ref v) =>\n             ExprKind::Return { value: v.to_ref() },\n         hir::ExprBreak(label, ref value) =>\n-            ExprKind::Break { label: label.map(|_| loop_label(cx, expr)),\n-                              value: value.to_ref() },\n+            ExprKind::Break {\n+                label: label.map(|label| {\n+                    cx.tcx.region_maps.node_extent(label.loop_id)\n+                }),\n+                value: value.to_ref()\n+            },\n         hir::ExprAgain(label) =>\n-            ExprKind::Continue { label: label.map(|_| loop_label(cx, expr)) },\n+            ExprKind::Continue {\n+                label: label.map(|label| {\n+                    cx.tcx.region_maps.node_extent(label.loop_id)\n+                })\n+            },\n         hir::ExprMatch(ref discr, ref arms, _) =>\n             ExprKind::Match { discriminant: discr.to_ref(),\n                               arms: arms.iter().map(|a| convert_arm(cx, a)).collect() },\n@@ -661,11 +673,11 @@ fn convert_arm<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n }\n \n fn convert_path_expr<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n-                                     expr: &'tcx hir::Expr)\n+                                     expr: &'tcx hir::Expr,\n+                                     def: Def)\n                                      -> ExprKind<'tcx> {\n     let substs = cx.tcx.tables().node_id_item_substs(expr.id)\n         .unwrap_or_else(|| cx.tcx.intern_substs(&[]));\n-    let def = cx.tcx.expect_def(expr.id);\n     let def_id = match def {\n         // A regular function, constructor function or a constant.\n         Def::Fn(def_id) | Def::Method(def_id) |\n@@ -990,14 +1002,6 @@ fn capture_freevar<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n     }\n }\n \n-fn loop_label<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n-                              expr: &'tcx hir::Expr) -> CodeExtent {\n-    match cx.tcx.expect_def(expr.id) {\n-        Def::Label(loop_id) => cx.tcx.region_maps.node_extent(loop_id),\n-        d => span_bug!(expr.span, \"loop scope resolved to {:?}\", d),\n-    }\n-}\n-\n /// Converts a list of named fields (i.e. for struct-like struct/enum ADTs) into FieldExprRef.\n fn field_refs<'tcx>(variant: VariantDef<'tcx>,\n                     fields: &'tcx [hir::Field])"}, {"sha": "d9b1f247c7270e0cc17123e9e1da41318a487ce9", "filename": "src/librustc_passes/consts.rs", "status": "modified", "additions": 13, "deletions": 7, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/962633cdbbe2ce87c1311edbaa0d4e0aca022b6d/src%2Flibrustc_passes%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962633cdbbe2ce87c1311edbaa0d4e0aca022b6d/src%2Flibrustc_passes%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fconsts.rs?ref=962633cdbbe2ce87c1311edbaa0d4e0aca022b6d", "patch": "@@ -487,8 +487,9 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>, e: &hir::Expr, node\n                 _ => {}\n             }\n         }\n-        hir::ExprPath(_) => {\n-            match v.tcx.expect_def(e.id) {\n+        hir::ExprPath(ref qpath) => {\n+            let def = v.tcx.tables().qpath_def(qpath, e.id);\n+            match def {\n                 Def::VariantCtor(_, CtorKind::Const) => {\n                     // Size is determined by the whole enum, may be non-zero.\n                     v.add_qualif(ConstQualif::NON_ZERO_SIZED);\n@@ -531,17 +532,22 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>, e: &hir::Expr, node\n                 };\n             }\n             // The callee is an arbitrary expression, it doesn't necessarily have a definition.\n-            let is_const = match v.tcx.expect_def_or_none(callee.id) {\n-                Some(Def::StructCtor(_, CtorKind::Fn)) |\n-                Some(Def::VariantCtor(_, CtorKind::Fn)) => {\n+            let def = if let hir::ExprPath(ref qpath) = callee.node {\n+                v.tcx.tables().qpath_def(qpath, callee.id)\n+            } else {\n+                Def::Err\n+            };\n+            let is_const = match def {\n+                Def::StructCtor(_, CtorKind::Fn) |\n+                Def::VariantCtor(_, CtorKind::Fn) => {\n                     // `NON_ZERO_SIZED` is about the call result, not about the ctor itself.\n                     v.add_qualif(ConstQualif::NON_ZERO_SIZED);\n                     true\n                 }\n-                Some(Def::Fn(did)) => {\n+                Def::Fn(did) => {\n                     v.handle_const_fn_call(e, did, node_ty)\n                 }\n-                Some(Def::Method(did)) => {\n+                Def::Method(did) => {\n                     match v.tcx.associated_item(did).container {\n                         ty::ImplContainer(_) => {\n                             v.handle_const_fn_call(e, did, node_ty)"}, {"sha": "a622a3faf7098dc31326ec7a91f496892eeb683b", "filename": "src/librustc_passes/loops.rs", "status": "modified", "additions": 7, "deletions": 12, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/962633cdbbe2ce87c1311edbaa0d4e0aca022b6d/src%2Flibrustc_passes%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962633cdbbe2ce87c1311edbaa0d4e0aca022b6d/src%2Flibrustc_passes%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Floops.rs?ref=962633cdbbe2ce87c1311edbaa0d4e0aca022b6d", "patch": "@@ -12,10 +12,10 @@ use self::Context::*;\n use rustc::session::Session;\n \n use rustc::dep_graph::DepNode;\n-use rustc::hir::def::{Def, DefMap};\n use rustc::hir::map::Map;\n use rustc::hir::intravisit::{self, Visitor};\n use rustc::hir;\n+use syntax::ast;\n use syntax_pos::Span;\n \n #[derive(Clone, Copy, PartialEq)]\n@@ -45,17 +45,15 @@ enum Context {\n #[derive(Copy, Clone)]\n struct CheckLoopVisitor<'a, 'ast: 'a> {\n     sess: &'a Session,\n-    def_map: &'a DefMap,\n     hir_map: &'a Map<'ast>,\n     cx: Context,\n }\n \n-pub fn check_crate(sess: &Session, def_map: &DefMap, map: &Map) {\n+pub fn check_crate(sess: &Session, map: &Map) {\n     let _task = map.dep_graph.in_task(DepNode::CheckLoops);\n     let krate = map.krate();\n     krate.visit_all_item_likes(&mut CheckLoopVisitor {\n         sess: sess,\n-        def_map: def_map,\n         hir_map: map,\n         cx: Normal,\n     }.as_deep_visitor());\n@@ -84,21 +82,18 @@ impl<'a, 'ast, 'v> Visitor<'v> for CheckLoopVisitor<'a, 'ast> {\n             hir::ExprClosure(.., ref b, _) => {\n                 self.with_context(Closure, |v| v.visit_expr(&b));\n             }\n-            hir::ExprBreak(ref opt_label, ref opt_expr) => {\n+            hir::ExprBreak(label, ref opt_expr) => {\n                 if opt_expr.is_some() {\n-                    let loop_kind = if opt_label.is_some() {\n-                        let loop_def = self.def_map.get(&e.id).unwrap().full_def();\n-                        if loop_def == Def::Err {\n+                    let loop_kind = if let Some(label) = label {\n+                        if label.loop_id == ast::DUMMY_NODE_ID {\n                             None\n-                        } else if let Def::Label(loop_id) = loop_def {\n-                            Some(match self.hir_map.expect_expr(loop_id).node {\n+                        } else {\n+                            Some(match self.hir_map.expect_expr(label.loop_id).node {\n                                 hir::ExprWhile(..) => LoopKind::WhileLoop,\n                                 hir::ExprLoop(_, _, source) => LoopKind::Loop(source),\n                                 ref r => span_bug!(e.span,\n                                                    \"break label resolved to a non-loop: {:?}\", r),\n                             })\n-                        } else {\n-                            span_bug!(e.span, \"break resolved to a non-label\")\n                         }\n                     } else if let Loop(kind) = self.cx {\n                         Some(kind)"}, {"sha": "b5daf0284e1d6a4e8b6b2606a79c0496a2d46b0a", "filename": "src/librustc_passes/static_recursion.rs", "status": "modified", "additions": 7, "deletions": 12, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/962633cdbbe2ce87c1311edbaa0d4e0aca022b6d/src%2Flibrustc_passes%2Fstatic_recursion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962633cdbbe2ce87c1311edbaa0d4e0aca022b6d/src%2Flibrustc_passes%2Fstatic_recursion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fstatic_recursion.rs?ref=962633cdbbe2ce87c1311edbaa0d4e0aca022b6d", "patch": "@@ -14,7 +14,7 @@\n use rustc::dep_graph::DepNode;\n use rustc::hir::map as ast_map;\n use rustc::session::{CompileResult, Session};\n-use rustc::hir::def::{Def, CtorKind, DefMap};\n+use rustc::hir::def::{Def, CtorKind};\n use rustc::util::nodemap::NodeMap;\n \n use syntax::ast;\n@@ -27,7 +27,6 @@ use std::cell::RefCell;\n \n struct CheckCrateVisitor<'a, 'ast: 'a> {\n     sess: &'a Session,\n-    def_map: &'a DefMap,\n     ast_map: &'a ast_map::Map<'ast>,\n     // `discriminant_map` is a cache that associates the `NodeId`s of local\n     // variant definitions with the discriminant expression that applies to\n@@ -88,14 +87,12 @@ impl<'a, 'ast: 'a> Visitor<'ast> for CheckCrateVisitor<'a, 'ast> {\n }\n \n pub fn check_crate<'ast>(sess: &Session,\n-                         def_map: &DefMap,\n                          ast_map: &ast_map::Map<'ast>)\n                          -> CompileResult {\n     let _task = ast_map.dep_graph.in_task(DepNode::CheckStaticRecursion);\n \n     let mut visitor = CheckCrateVisitor {\n         sess: sess,\n-        def_map: def_map,\n         ast_map: ast_map,\n         discriminant_map: RefCell::new(NodeMap()),\n     };\n@@ -109,7 +106,6 @@ struct CheckItemRecursionVisitor<'a, 'ast: 'a> {\n     root_span: &'a Span,\n     sess: &'a Session,\n     ast_map: &'a ast_map::Map<'ast>,\n-    def_map: &'a DefMap,\n     discriminant_map: &'a RefCell<NodeMap<Option<&'ast hir::Expr>>>,\n     idstack: Vec<ast::NodeId>,\n }\n@@ -122,7 +118,6 @@ impl<'a, 'ast: 'a> CheckItemRecursionVisitor<'a, 'ast> {\n             root_span: span,\n             sess: v.sess,\n             ast_map: v.ast_map,\n-            def_map: v.def_map,\n             discriminant_map: &v.discriminant_map,\n             idstack: Vec::new(),\n         }\n@@ -250,11 +245,11 @@ impl<'a, 'ast: 'a> Visitor<'ast> for CheckItemRecursionVisitor<'a, 'ast> {\n \n     fn visit_expr(&mut self, e: &'ast hir::Expr) {\n         match e.node {\n-            hir::ExprPath(_) => {\n-                match self.def_map.get(&e.id).map(|d| d.base_def) {\n-                    Some(Def::Static(def_id, _)) |\n-                    Some(Def::AssociatedConst(def_id)) |\n-                    Some(Def::Const(def_id)) => {\n+            hir::ExprPath(hir::QPath::Resolved(_, ref path)) => {\n+                match path.def {\n+                    Def::Static(def_id, _) |\n+                    Def::AssociatedConst(def_id) |\n+                    Def::Const(def_id) => {\n                         if let Some(node_id) = self.ast_map.as_local_node_id(def_id) {\n                             match self.ast_map.get(node_id) {\n                                 ast_map::NodeItem(item) => self.visit_item(item),\n@@ -273,7 +268,7 @@ impl<'a, 'ast: 'a> Visitor<'ast> for CheckItemRecursionVisitor<'a, 'ast> {\n                     // affect the specific variant used, but we need to check\n                     // the whole enum definition to see what expression that\n                     // might be (if any).\n-                    Some(Def::VariantCtor(variant_id, CtorKind::Const)) => {\n+                    Def::VariantCtor(variant_id, CtorKind::Const) => {\n                         if let Some(variant_id) = self.ast_map.as_local_node_id(variant_id) {\n                             let variant = self.ast_map.expect_variant(variant_id);\n                             let enum_id = self.ast_map.get_parent(variant_id);"}, {"sha": "29bcb73602ea3dd5fdcbffecd416b07d06485eef", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 47, "deletions": 31, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/962633cdbbe2ce87c1311edbaa0d4e0aca022b6d/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962633cdbbe2ce87c1311edbaa0d4e0aca022b6d/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=962633cdbbe2ce87c1311edbaa0d4e0aca022b6d", "patch": "@@ -67,8 +67,12 @@ struct ReachEverythingInTheInterfaceVisitor<'b, 'a: 'b, 'tcx: 'a> {\n \n impl<'a, 'tcx> EmbargoVisitor<'a, 'tcx> {\n     fn ty_level(&self, ty: &hir::Ty) -> Option<AccessLevel> {\n-        if let hir::TyPath(_) = ty.node {\n-            match self.tcx.expect_def(ty.id) {\n+        if let hir::TyPath(ref qpath) = ty.node {\n+            let def = match *qpath {\n+                hir::QPath::Resolved(_, ref path) => path.def,\n+                hir::QPath::TypeRelative(..) => self.tcx.tables().type_relative_path_defs[&ty.id]\n+            };\n+            match def {\n                 Def::PrimTy(..) | Def::SelfTy(..) | Def::TyParam(..) => {\n                     Some(AccessLevel::Public)\n                 }\n@@ -86,7 +90,7 @@ impl<'a, 'tcx> EmbargoVisitor<'a, 'tcx> {\n     }\n \n     fn trait_level(&self, trait_ref: &hir::TraitRef) -> Option<AccessLevel> {\n-        let did = self.tcx.expect_def(trait_ref.ref_id).def_id();\n+        let did = trait_ref.path.def.def_id();\n         if let Some(node_id) = self.tcx.map.as_local_node_id(did) {\n             self.get(node_id)\n         } else {\n@@ -328,13 +332,16 @@ impl<'b, 'a, 'tcx: 'a> Visitor<'tcx> for ReachEverythingInTheInterfaceVisitor<'b\n     }\n \n     fn visit_ty(&mut self, ty: &'tcx hir::Ty) {\n-        let path_segment = match ty.node {\n-            hir::TyPath(hir::QPath::Resolved(_, ref path)) => path.segments.last(),\n-            hir::TyPath(hir::QPath::TypeRelative(_, ref segment)) => Some(&**segment),\n+        let def_and_segment = match ty.node {\n+            hir::TyPath(hir::QPath::Resolved(_, ref path)) => {\n+                Some((path.def, path.segments.last().unwrap()))\n+            }\n+            hir::TyPath(hir::QPath::TypeRelative(_, ref segment)) => {\n+                Some((self.ev.tcx.tables().type_relative_path_defs[&ty.id], &**segment))\n+            }\n             _ => None\n         };\n-        if let Some(segment) = path_segment {\n-            let def = self.ev.tcx.expect_def(ty.id);\n+        if let Some((def, segment)) = def_and_segment {\n             match def {\n                 Def::Struct(def_id) | Def::Union(def_id) | Def::Enum(def_id) |\n                 Def::TyAlias(def_id) | Def::Trait(def_id) | Def::AssociatedTy(def_id) => {\n@@ -365,7 +372,7 @@ impl<'b, 'a, 'tcx: 'a> Visitor<'tcx> for ReachEverythingInTheInterfaceVisitor<'b\n     }\n \n     fn visit_trait_ref(&mut self, trait_ref: &'tcx hir::TraitRef) {\n-        let def_id = self.ev.tcx.expect_def(trait_ref.ref_id).def_id();\n+        let def_id = trait_ref.path.def.def_id();\n         if let Some(node_id) = self.ev.tcx.map.as_local_node_id(def_id) {\n             let item = self.ev.tcx.map.expect_item(node_id);\n             self.ev.update(item.id, Some(AccessLevel::Reachable));\n@@ -446,9 +453,10 @@ impl<'a, 'tcx> Visitor<'tcx> for PrivacyVisitor<'a, 'tcx> {\n                 let method = self.tcx.tables().method_map[&method_call];\n                 self.check_method(expr.span, method.def_id);\n             }\n-            hir::ExprStruct(_, ref expr_fields, _) => {\n+            hir::ExprStruct(ref qpath, ref expr_fields, _) => {\n+                let def = self.tcx.tables().qpath_def(qpath, expr.id);\n                 let adt = self.tcx.tables().expr_ty(expr).ty_adt_def().unwrap();\n-                let variant = adt.variant_of_def(self.tcx.expect_def(expr.id));\n+                let variant = adt.variant_of_def(def);\n                 // RFC 736: ensure all unmentioned fields are visible.\n                 // Rather than computing the set of unmentioned fields\n                 // (i.e. `all_fields - fields`), just check them all,\n@@ -466,9 +474,9 @@ impl<'a, 'tcx> Visitor<'tcx> for PrivacyVisitor<'a, 'tcx> {\n                     }\n                 }\n             }\n-            hir::ExprPath(hir::QPath::Resolved(..)) => {\n-                if let def @ Def::StructCtor(_, CtorKind::Fn) = self.tcx.expect_def(expr.id) {\n-                    let adt_def = self.tcx.expect_variant_def(def);\n+            hir::ExprPath(hir::QPath::Resolved(_, ref path)) => {\n+                if let Def::StructCtor(_, CtorKind::Fn) = path.def {\n+                    let adt_def = self.tcx.expect_variant_def(path.def);\n                     let private_indexes = adt_def.fields.iter().enumerate().filter(|&(_, field)| {\n                         !field.vis.is_accessible_from(self.curitem, &self.tcx.map)\n                     }).map(|(i, _)| i).collect::<Vec<_>>();\n@@ -507,9 +515,10 @@ impl<'a, 'tcx> Visitor<'tcx> for PrivacyVisitor<'a, 'tcx> {\n         if self.in_foreign { return }\n \n         match pattern.node {\n-            PatKind::Struct(_, ref fields, _) => {\n+            PatKind::Struct(ref qpath, ref fields, _) => {\n+                let def = self.tcx.tables().qpath_def(qpath, pattern.id);\n                 let adt = self.tcx.tables().pat_ty(pattern).ty_adt_def().unwrap();\n-                let variant = adt.variant_of_def(self.tcx.expect_def(pattern.id));\n+                let variant = adt.variant_of_def(def);\n                 for field in fields {\n                     self.check_field(field.span, adt, variant.field_named(field.node.name));\n                 }\n@@ -569,8 +578,8 @@ struct ObsoleteCheckTypeForPrivatenessVisitor<'a, 'b: 'a, 'tcx: 'b> {\n }\n \n impl<'a, 'tcx> ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n-    fn path_is_private_type(&self, path_id: ast::NodeId) -> bool {\n-        let did = match self.tcx.expect_def(path_id) {\n+    fn path_is_private_type(&self, path: &hir::Path) -> bool {\n+        let did = match path.def {\n             Def::PrimTy(..) | Def::SelfTy(..) => return false,\n             def => def.def_id(),\n         };\n@@ -598,7 +607,7 @@ impl<'a, 'tcx> ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n     fn check_ty_param_bound(&mut self,\n                             ty_param_bound: &hir::TyParamBound) {\n         if let hir::TraitTyParamBound(ref trait_ref, _) = *ty_param_bound {\n-            if self.path_is_private_type(trait_ref.trait_ref.ref_id) {\n+            if self.path_is_private_type(&trait_ref.trait_ref.path) {\n                 self.old_error_set.insert(trait_ref.trait_ref.ref_id);\n             }\n         }\n@@ -611,13 +620,16 @@ impl<'a, 'tcx> ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n \n impl<'a, 'b, 'tcx, 'v> Visitor<'v> for ObsoleteCheckTypeForPrivatenessVisitor<'a, 'b, 'tcx> {\n     fn visit_ty(&mut self, ty: &hir::Ty) {\n-        if let hir::TyPath(_) = ty.node {\n-            if self.inner.path_is_private_type(ty.id) {\n+        if let hir::TyPath(hir::QPath::Resolved(_, ref path)) = ty.node {\n+            if self.inner.path_is_private_type(path) {\n                 self.contains_private = true;\n                 // found what we're looking for so let's stop\n                 // working.\n                 return\n-            } else if self.at_outer_type {\n+            }\n+        }\n+        if let hir::TyPath(_) = ty.node {\n+            if self.at_outer_type {\n                 self.outer_type_is_public_path = true;\n             }\n         }\n@@ -687,7 +699,7 @@ impl<'a, 'tcx> Visitor<'tcx> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n                 let not_private_trait =\n                     trait_ref.as_ref().map_or(true, // no trait counts as public trait\n                                               |tr| {\n-                        let did = self.tcx.expect_def(tr.ref_id).def_id();\n+                        let did = tr.path.def.def_id();\n \n                         if let Some(node_id) = self.tcx.map.as_local_node_id(did) {\n                             self.trait_is_public(node_id)\n@@ -849,8 +861,8 @@ impl<'a, 'tcx> Visitor<'tcx> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n     }\n \n     fn visit_ty(&mut self, t: &'tcx hir::Ty) {\n-        if let hir::TyPath(_) = t.node {\n-            if self.path_is_private_type(t.id) {\n+        if let hir::TyPath(hir::QPath::Resolved(_, ref path)) = t.node {\n+            if self.path_is_private_type(path) {\n                 self.old_error_set.insert(t.id);\n             }\n         }\n@@ -941,13 +953,17 @@ impl<'a, 'tcx: 'a> SearchInterfaceForPrivateItemsVisitor<'a, 'tcx> {\n \n impl<'a, 'tcx: 'a, 'v> Visitor<'v> for SearchInterfaceForPrivateItemsVisitor<'a, 'tcx> {\n     fn visit_ty(&mut self, ty: &hir::Ty) {\n-        let path_segment = match ty.node {\n-            hir::TyPath(hir::QPath::Resolved(_, ref path)) => path.segments.last(),\n-            hir::TyPath(hir::QPath::TypeRelative(_, ref segment)) => Some(&**segment),\n+        let def_and_segment = match ty.node {\n+            hir::TyPath(hir::QPath::Resolved(_, ref path)) => {\n+                Some((path.def, path.segments.last().unwrap()))\n+            }\n+            hir::TyPath(hir::QPath::TypeRelative(_, ref segment)) => {\n+                Some((self.tcx.tables().type_relative_path_defs[&ty.id], &**segment))\n+            }\n             _ => None\n         };\n-        if let Some(segment) = path_segment {\n-            match self.tcx.expect_def(ty.id) {\n+        if let Some((def, segment)) = def_and_segment {\n+            match def {\n                 Def::PrimTy(..) | Def::SelfTy(..) | Def::TyParam(..) => {\n                     // Public\n                 }\n@@ -1005,7 +1021,7 @@ impl<'a, 'tcx: 'a, 'v> Visitor<'v> for SearchInterfaceForPrivateItemsVisitor<'a,\n \n     fn visit_trait_ref(&mut self, trait_ref: &hir::TraitRef) {\n         // Non-local means public (private items can't leave their crate, modulo bugs)\n-        let def_id = self.tcx.expect_def(trait_ref.ref_id).def_id();\n+        let def_id = trait_ref.path.def.def_id();\n         if let Some(node_id) = self.tcx.map.as_local_node_id(def_id) {\n             let item = self.tcx.map.expect_item(node_id);\n             let vis = ty::Visibility::from_hir(&item.vis, node_id, self.tcx);"}, {"sha": "058c8266a35e959f6772e5287a7af2a5109daed1", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/962633cdbbe2ce87c1311edbaa0d4e0aca022b6d/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962633cdbbe2ce87c1311edbaa0d4e0aca022b6d/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=962633cdbbe2ce87c1311edbaa0d4e0aca022b6d", "patch": "@@ -1201,11 +1201,11 @@ impl<'a> ty::NodeIdTree for Resolver<'a> {\n }\n \n impl<'a> hir::lowering::Resolver for Resolver<'a> {\n-    fn resolve_generated_global_path(&mut self, path: &hir::Path, is_value: bool) -> Def {\n+    fn resolve_generated_global_path(&mut self, path: &mut hir::Path, is_value: bool) {\n         let namespace = if is_value { ValueNS } else { TypeNS };\n         match self.resolve_crate_relative_path(path.span, &path.segments, namespace) {\n-            Ok(binding) => binding.def(),\n-            Err(true) => Def::Err,\n+            Ok(binding) => path.def = binding.def(),\n+            Err(true) => {}\n             Err(false) => {\n                 let path_name = &format!(\"{}\", path);\n                 let error =\n@@ -1218,7 +1218,6 @@ impl<'a> hir::lowering::Resolver for Resolver<'a> {\n                         def: Def::Err,\n                     };\n                 resolve_error(self, path.span, error);\n-                Def::Err\n             }\n         }\n     }"}, {"sha": "3e7ca155da08469755fedebba7e0a4b433d59fce", "filename": "src/librustc_save_analysis/dump_visitor.rs", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/962633cdbbe2ce87c1311edbaa0d4e0aca022b6d/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962633cdbbe2ce87c1311edbaa0d4e0aca022b6d/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdump_visitor.rs?ref=962633cdbbe2ce87c1311edbaa0d4e0aca022b6d", "patch": "@@ -274,12 +274,10 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n     }\n \n     fn lookup_def_id(&self, ref_id: NodeId) -> Option<DefId> {\n-        self.tcx.expect_def_or_none(ref_id).and_then(|def| {\n-            match def {\n-                Def::Label(..) | Def::PrimTy(..) | Def::SelfTy(..) | Def::Err => None,\n-                def => Some(def.def_id()),\n-            }\n-        })\n+        match self.save_ctxt.get_path_def(ref_id) {\n+            Def::PrimTy(..) | Def::SelfTy(..) | Def::Err => None,\n+            def => Some(def.def_id()),\n+        }\n     }\n \n     fn process_def_kind(&mut self,\n@@ -292,7 +290,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n             return;\n         }\n \n-        let def = self.tcx.expect_def(ref_id);\n+        let def = self.save_ctxt.get_path_def(ref_id);\n         match def {\n             Def::Mod(_) => {\n                 self.dumper.mod_ref(ModRefData {\n@@ -919,7 +917,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n         }\n \n         // Modules or types in the path prefix.\n-        match self.tcx.expect_def(id) {\n+        match self.save_ctxt.get_path_def(id) {\n             Def::Method(did) => {\n                 let ti = self.tcx.associated_item(did);\n                 if ti.kind == ty::AssociatedKind::Method && ti.method_has_self_argument {\n@@ -998,7 +996,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n                         return;\n                     }\n                 };\n-                let variant = adt.variant_of_def(self.tcx.expect_def(p.id));\n+                let variant = adt.variant_of_def(self.save_ctxt.get_path_def(p.id));\n \n                 for &Spanned { node: ref field, span } in fields {\n                     let sub_span = self.span.span_for_first_ident(span);\n@@ -1370,7 +1368,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump +'ll> Visitor for DumpVisitor<'l, 'tcx, 'll, D>\n                         return;\n                     }\n                 };\n-                let def = self.tcx.expect_def(hir_expr.id);\n+                let def = self.save_ctxt.get_path_def(hir_expr.id);\n                 self.process_struct_lit(ex, path, fields, adt.variant_of_def(def), base)\n             }\n             ast::ExprKind::MethodCall(.., ref args) => self.process_method_call(ex, args),\n@@ -1480,7 +1478,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump +'ll> Visitor for DumpVisitor<'l, 'tcx, 'll, D>\n \n         // process collected paths\n         for &(id, ref p, immut, ref_kind) in &collector.collected_paths {\n-            match self.tcx.expect_def(id) {\n+            match self.save_ctxt.get_path_def(id) {\n                 Def::Local(def_id) => {\n                     let id = self.tcx.map.as_local_node_id(def_id).unwrap();\n                     let mut value = if immut == ast::Mutability::Immutable {"}, {"sha": "e79ca6721db9a45a846553d2f4ebd3ddd2f5db6b", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 38, "deletions": 10, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/962633cdbbe2ce87c1311edbaa0d4e0aca022b6d/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962633cdbbe2ce87c1311edbaa0d4e0aca022b6d/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=962633cdbbe2ce87c1311edbaa0d4e0aca022b6d", "patch": "@@ -42,8 +42,8 @@ pub mod external_data;\n pub mod span_utils;\n \n use rustc::hir;\n-use rustc::hir::map::{Node, NodeItem};\n use rustc::hir::def::Def;\n+use rustc::hir::map::Node;\n use rustc::hir::def_id::DefId;\n use rustc::session::config::CrateType::CrateTypeExecutable;\n use rustc::ty::{self, TyCtxt};\n@@ -318,7 +318,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n         let (qualname, parent_scope, decl_id, vis, docs) =\n           match self.tcx.impl_of_method(self.tcx.map.local_def_id(id)) {\n             Some(impl_id) => match self.tcx.map.get_if_local(impl_id) {\n-                Some(NodeItem(item)) => {\n+                Some(Node::NodeItem(item)) => {\n                     match item.node {\n                         hir::ItemImpl(.., ref ty, _) => {\n                             let mut result = String::from(\"<\");\n@@ -358,7 +358,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n             None => match self.tcx.trait_of_item(self.tcx.map.local_def_id(id)) {\n                 Some(def_id) => {\n                     match self.tcx.map.get_if_local(def_id) {\n-                        Some(NodeItem(item)) => {\n+                        Some(Node::NodeItem(item)) => {\n                             (format!(\"::{}\", self.tcx.item_path_str(def_id)),\n                              Some(def_id), None,\n                              From::from(&item.vis),\n@@ -497,13 +497,41 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n         }\n     }\n \n-    pub fn get_path_data(&self, id: NodeId, path: &ast::Path) -> Option<Data> {\n-        let resolution = self.tcx.expect_resolution(id);\n-        if resolution.depth != 0 {\n-            return None;\n+    pub fn get_path_def(&self, id: NodeId) -> Def {\n+        match self.tcx.map.get(id) {\n+            Node::NodeTraitRef(tr) => tr.path.def,\n+\n+            Node::NodeItem(&hir::Item { node: hir::ItemUse(ref path, _), .. }) |\n+            Node::NodeVisibility(&hir::Visibility::Restricted { ref path, .. }) => path.def,\n+\n+            Node::NodeExpr(&hir::Expr { node: hir::ExprPath(ref qpath), .. }) |\n+            Node::NodeExpr(&hir::Expr { node: hir::ExprStruct(ref qpath, ..), .. }) |\n+            Node::NodePat(&hir::Pat { node: hir::PatKind::Path(ref qpath), .. }) |\n+            Node::NodePat(&hir::Pat { node: hir::PatKind::Struct(ref qpath, ..), .. }) |\n+            Node::NodePat(&hir::Pat { node: hir::PatKind::TupleStruct(ref qpath, ..), .. }) => {\n+                self.tcx.tables().qpath_def(qpath, id)\n+            }\n+\n+            Node::NodeLocal(&hir::Pat { node: hir::PatKind::Binding(_, def_id, ..), .. }) => {\n+                Def::Local(def_id)\n+            }\n+\n+            Node::NodeTy(&hir::Ty { node: hir::TyPath(ref qpath), .. }) => {\n+                match *qpath {\n+                    hir::QPath::Resolved(_, ref path) => path.def,\n+                    hir::QPath::TypeRelative(..) => {\n+                        // FIXME(eddyb) Avoid keeping associated type resolutions.\n+                        self.tcx.tables().type_relative_path_defs[&id]\n+                    }\n+                }\n+            }\n+\n+            _ => Def::Err\n         }\n-        let def = resolution.base_def;\n+    }\n \n+    pub fn get_path_data(&self, id: NodeId, path: &ast::Path) -> Option<Data> {\n+        let def = self.get_path_def(id);\n         let sub_span = self.span_utils.span_for_last_ident(path.span);\n         filter!(self.span_utils, sub_span, path.span, None);\n         match def {\n@@ -647,8 +675,8 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n     }\n \n     fn lookup_ref_id(&self, ref_id: NodeId) -> Option<DefId> {\n-        match self.tcx.expect_def(ref_id) {\n-            Def::PrimTy(_) | Def::SelfTy(..) => None,\n+        match self.get_path_def(ref_id) {\n+            Def::PrimTy(_) | Def::SelfTy(..) | Def::Err => None,\n             def => Some(def.def_id()),\n         }\n     }"}, {"sha": "646f941deae7f546d0c1dfb84f1066dcc7649aed", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 43, "deletions": 50, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/962633cdbbe2ce87c1311edbaa0d4e0aca022b6d/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962633cdbbe2ce87c1311edbaa0d4e0aca022b6d/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=962633cdbbe2ce87c1311edbaa0d4e0aca022b6d", "patch": "@@ -50,7 +50,7 @@\n \n use rustc_const_eval::eval_length;\n use hir::{self, SelfKind};\n-use hir::def::{Def, PathResolution};\n+use hir::def::Def;\n use hir::def_id::DefId;\n use hir::print as pprust;\n use middle::resolve_lifetime as rl;\n@@ -678,7 +678,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n \n     fn trait_def_id(&self, trait_ref: &hir::TraitRef) -> DefId {\n         let path = &trait_ref.path;\n-        match self.tcx().expect_def(trait_ref.ref_id) {\n+        match path.def {\n             Def::Trait(trait_def_id) => trait_def_id,\n             Def::Err => {\n                 self.tcx().sess.fatal(\"cannot continue compilation due to previous error\");\n@@ -953,24 +953,20 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         let tcx = self.tcx();\n         match ty.node {\n             hir::TyPath(hir::QPath::Resolved(None, ref path)) => {\n-                let resolution = tcx.expect_resolution(ty.id);\n-                match resolution.base_def {\n-                    Def::Trait(trait_def_id) if resolution.depth == 0 => {\n-                        self.trait_path_to_object_type(rscope,\n-                                                       path.span,\n-                                                       trait_def_id,\n-                                                       ty.id,\n-                                                       path.segments.last().unwrap(),\n-                                                       span,\n-                                                       partition_bounds(tcx, span, bounds))\n-                    }\n-                    _ => {\n-                        struct_span_err!(tcx.sess, ty.span, E0172,\n-                                  \"expected a reference to a trait\")\n-                            .span_label(ty.span, &format!(\"expected a trait\"))\n-                            .emit();\n-                        tcx.types.err\n-                    }\n+                if let Def::Trait(trait_def_id) = path.def {\n+                    self.trait_path_to_object_type(rscope,\n+                                                   path.span,\n+                                                   trait_def_id,\n+                                                   ty.id,\n+                                                   path.segments.last().unwrap(),\n+                                                   span,\n+                                                   partition_bounds(tcx, span, bounds))\n+                } else {\n+                    struct_span_err!(tcx.sess, ty.span, E0172,\n+                                     \"expected a reference to a trait\")\n+                        .span_label(ty.span, &format!(\"expected a trait\"))\n+                        .emit();\n+                    tcx.types.err\n                 }\n             }\n             _ => {\n@@ -1412,55 +1408,54 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         }\n     }\n \n-    // Check a type Def and convert it to a Ty.\n+    // Check a type Path and convert it to a Ty.\n     pub fn def_to_ty(&self,\n                      rscope: &RegionScope,\n-                     span: Span,\n-                     def: Def,\n                      opt_self_ty: Option<Ty<'tcx>>,\n+                     path: &hir::Path,\n                      path_id: ast::NodeId,\n-                     path_segments: &[hir::PathSegment],\n                      permit_variants: bool)\n                      -> Ty<'tcx> {\n         let tcx = self.tcx();\n \n         debug!(\"base_def_to_ty(def={:?}, opt_self_ty={:?}, path_segments={:?})\",\n-               def, opt_self_ty, path_segments);\n+               path.def, opt_self_ty, path.segments);\n \n-        match def {\n+        let span = path.span;\n+        match path.def {\n             Def::Trait(trait_def_id) => {\n                 // N.B. this case overlaps somewhat with\n                 // TyObjectSum, see that fn for details\n \n                 assert_eq!(opt_self_ty, None);\n-                tcx.prohibit_type_params(path_segments.split_last().unwrap().1);\n+                tcx.prohibit_type_params(path.segments.split_last().unwrap().1);\n \n                 self.trait_path_to_object_type(rscope,\n                                                span,\n                                                trait_def_id,\n                                                path_id,\n-                                               path_segments.last().unwrap(),\n+                                               path.segments.last().unwrap(),\n                                                span,\n                                                partition_bounds(tcx, span, &[]))\n             }\n             Def::Enum(did) | Def::TyAlias(did) | Def::Struct(did) | Def::Union(did) => {\n                 assert_eq!(opt_self_ty, None);\n-                tcx.prohibit_type_params(path_segments.split_last().unwrap().1);\n-                self.ast_path_to_ty(rscope, span, did, path_segments.last().unwrap())\n+                tcx.prohibit_type_params(path.segments.split_last().unwrap().1);\n+                self.ast_path_to_ty(rscope, span, did, path.segments.last().unwrap())\n             }\n             Def::Variant(did) if permit_variants => {\n                 // Convert \"variant type\" as if it were a real type.\n                 // The resulting `Ty` is type of the variant's enum for now.\n                 assert_eq!(opt_self_ty, None);\n-                tcx.prohibit_type_params(path_segments.split_last().unwrap().1);\n+                tcx.prohibit_type_params(path.segments.split_last().unwrap().1);\n                 self.ast_path_to_ty(rscope,\n                                     span,\n                                     tcx.parent_def_id(did).unwrap(),\n-                                    path_segments.last().unwrap())\n+                                    path.segments.last().unwrap())\n             }\n             Def::TyParam(did) => {\n                 assert_eq!(opt_self_ty, None);\n-                tcx.prohibit_type_params(path_segments);\n+                tcx.prohibit_type_params(&path.segments);\n \n                 let node_id = tcx.map.as_local_node_id(did).unwrap();\n                 let param = tcx.ty_param_defs.borrow().get(&node_id)\n@@ -1483,7 +1478,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                 // Self in impl (we know the concrete type).\n \n                 assert_eq!(opt_self_ty, None);\n-                tcx.prohibit_type_params(path_segments);\n+                tcx.prohibit_type_params(&path.segments);\n                 let ty = tcx.item_type(def_id);\n                 if let Some(free_substs) = self.get_free_substs() {\n                     ty.subst(tcx, free_substs)\n@@ -1494,22 +1489,22 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n             Def::SelfTy(Some(_), None) => {\n                 // Self in trait.\n                 assert_eq!(opt_self_ty, None);\n-                tcx.prohibit_type_params(path_segments);\n+                tcx.prohibit_type_params(&path.segments);\n                 tcx.mk_self_type()\n             }\n             Def::AssociatedTy(def_id) => {\n-                tcx.prohibit_type_params(&path_segments[..path_segments.len()-2]);\n+                tcx.prohibit_type_params(&path.segments[..path.segments.len()-2]);\n                 let trait_did = tcx.parent_def_id(def_id).unwrap();\n                 self.qpath_to_ty(rscope,\n                                  span,\n                                  opt_self_ty,\n                                  trait_did,\n-                                 &path_segments[path_segments.len()-2],\n-                                 path_segments.last().unwrap())\n+                                 &path.segments[path.segments.len()-2],\n+                                 path.segments.last().unwrap())\n             }\n             Def::PrimTy(prim_ty) => {\n                 assert_eq!(opt_self_ty, None);\n-                tcx.prim_ty_to_ty(path_segments, prim_ty)\n+                tcx.prim_ty_to_ty(&path.segments, prim_ty)\n             }\n             Def::Err => {\n                 self.set_tainted_by_errors();\n@@ -1518,7 +1513,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n             _ => {\n                 struct_span_err!(tcx.sess, span, E0248,\n                            \"found value `{}` used as a type\",\n-                            tcx.item_path_str(def.def_id()))\n+                            tcx.item_path_str(path.def.def_id()))\n                            .span_label(span, &format!(\"value used as a type\"))\n                            .emit();\n                 return self.tcx().types.err;\n@@ -1653,23 +1648,21 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                 let opt_self_ty = maybe_qself.as_ref().map(|qself| {\n                     self.ast_ty_to_ty(rscope, qself)\n                 });\n-                self.def_to_ty(rscope,\n-                               ast_ty.span,\n-                               tcx.expect_def(ast_ty.id),\n-                               opt_self_ty,\n-                               ast_ty.id,\n-                               &path.segments,\n-                               false)\n+                self.def_to_ty(rscope, opt_self_ty, path, ast_ty.id, false)\n             }\n             hir::TyPath(hir::QPath::TypeRelative(ref qself, ref segment)) => {\n                 debug!(\"ast_ty_to_ty: qself={:?} segment={:?}\", qself, segment);\n                 let ty = self.ast_ty_to_ty(rscope, qself);\n \n-                let def = tcx.expect_def_or_none(qself.id).unwrap_or(Def::Err);\n+                let def = if let hir::TyPath(hir::QPath::Resolved(_, ref path)) = qself.node {\n+                    path.def\n+                } else {\n+                    Def::Err\n+                };\n                 let (ty, def) = self.associated_path_def_to_ty(ast_ty.span, ty, def, segment);\n \n                 // Write back the new resolution.\n-                tcx.def_map.borrow_mut().insert(ast_ty.id, PathResolution::new(def));\n+                tcx.tables.borrow_mut().type_relative_path_defs.insert(ast_ty.id, def);\n \n                 ty\n             }\n@@ -2007,7 +2000,7 @@ pub fn partition_bounds<'a, 'b, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n     for ast_bound in ast_bounds {\n         match *ast_bound {\n             hir::TraitTyParamBound(ref b, hir::TraitBoundModifier::None) => {\n-                match tcx.expect_def(b.trait_ref.ref_id) {\n+                match b.trait_ref.path.def {\n                     Def::Trait(trait_did) => {\n                         if tcx.try_add_builtin_trait(trait_did,\n                                                      &mut builtin_bounds) {"}, {"sha": "9381d653ed22990d367f7ed5fef4d426b89c7671", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 6, "deletions": 12, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/962633cdbbe2ce87c1311edbaa0d4e0aca022b6d/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962633cdbbe2ce87c1311edbaa0d4e0aca022b6d/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=962633cdbbe2ce87c1311edbaa0d4e0aca022b6d", "patch": "@@ -103,7 +103,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 self.demand_eqtype(pat.span, expected, rhs_ty);\n                 common_type\n             }\n-            PatKind::Binding(bm, _, ref sub) => {\n+            PatKind::Binding(bm, def_id, _, ref sub) => {\n                 let typ = self.local_ty(pat.span, pat.id);\n                 match bm {\n                     hir::BindByRef(mutbl) => {\n@@ -130,16 +130,10 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n                 // if there are multiple arms, make sure they all agree on\n                 // what the type of the binding `x` ought to be\n-                match tcx.expect_def(pat.id) {\n-                    Def::Err => {}\n-                    Def::Local(def_id) => {\n-                        let var_id = tcx.map.as_local_node_id(def_id).unwrap();\n-                        if var_id != pat.id {\n-                            let vt = self.local_ty(pat.span, var_id);\n-                            self.demand_eqtype(pat.span, vt, typ);\n-                        }\n-                    }\n-                    d => bug!(\"bad def for pattern binding `{:?}`\", d)\n+                let var_id = tcx.map.as_local_node_id(def_id).unwrap();\n+                if var_id != pat.id {\n+                    let vt = self.local_ty(pat.span, var_id);\n+                    self.demand_eqtype(pat.span, vt, typ);\n                 }\n \n                 if let Some(ref p) = *sub {\n@@ -373,7 +367,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // want to use the *precise* type of the discriminant, *not* some\n         // supertype, as the \"discriminant type\" (issue #23116).\n         let contains_ref_bindings = arms.iter()\n-                                        .filter_map(|a| tcx.arm_contains_ref_binding(a))\n+                                        .filter_map(|a| a.contains_ref_binding())\n                                         .max_by_key(|m| match *m {\n                                             hir::MutMutable => 1,\n                                             hir::MutImmutable => 0,"}, {"sha": "fdf496b7c86f473dcebde50b0ecedc0297423a73", "filename": "src/librustc_typeck/check/callee.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/962633cdbbe2ce87c1311edbaa0d4e0aca022b6d/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962633cdbbe2ce87c1311edbaa0d4e0aca022b6d/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs?ref=962633cdbbe2ce87c1311edbaa0d4e0aca022b6d", "patch": "@@ -218,12 +218,14 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 };\n \n                 if let hir::ExprCall(ref expr, _) = call_expr.node {\n-                    let tcx = self.tcx;\n-                    if let Some(pr) = tcx.def_map.borrow().get(&expr.id) {\n-                        if pr.depth == 0 && pr.base_def != Def::Err {\n-                            if let Some(span) = tcx.map.span_if_local(pr.base_def.def_id()) {\n-                                err.span_note(span, \"defined here\");\n-                            }\n+                    let def = if let hir::ExprPath(ref qpath) = expr.node {\n+                        self.tcx.tables().qpath_def(qpath, expr.id)\n+                    } else {\n+                        Def::Err\n+                    };\n+                    if def != Def::Err {\n+                        if let Some(span) = self.tcx.map.span_if_local(def.def_id()) {\n+                            err.span_note(span, \"defined here\");\n                         }\n                     }\n                 }"}, {"sha": "6bc37f5c44d080b715c99c4933e9c48bb6455b41", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 60, "deletions": 78, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/962633cdbbe2ce87c1311edbaa0d4e0aca022b6d/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962633cdbbe2ce87c1311edbaa0d4e0aca022b6d/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=962633cdbbe2ce87c1311edbaa0d4e0aca022b6d", "patch": "@@ -83,9 +83,8 @@ use self::TupleArgumentsFlag::*;\n use astconv::{AstConv, ast_region_to_region};\n use dep_graph::DepNode;\n use fmt_macros::{Parser, Piece, Position};\n-use hir::def::{Def, CtorKind, PathResolution};\n+use hir::def::{Def, CtorKind};\n use hir::def_id::{DefId, LOCAL_CRATE};\n-use hir::pat_util;\n use rustc::infer::{self, InferCtxt, InferOk, RegionVariableOrigin,\n                    TypeTrace, type_variable};\n use rustc::ty::subst::{Kind, Subst, Substs};\n@@ -711,7 +710,7 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for GatherLocalsVisitor<'a, 'gcx, 'tcx> {\n \n     // Add pattern bindings.\n     fn visit_pat(&mut self, p: &'gcx hir::Pat) {\n-        if let PatKind::Binding(_, ref path1, _) = p.node {\n+        if let PatKind::Binding(_, _, ref path1, _) = p.node {\n             let var_ty = self.assign(p.span, p.id, None);\n \n             self.fcx.require_type_is_sized(var_ty, p.span,\n@@ -796,7 +795,7 @@ fn check_fn<'a, 'gcx, 'tcx>(inherited: &'a Inherited<'a, 'gcx, 'tcx>,\n             fcx.register_old_wf_obligation(arg_ty, input.ty.span, traits::MiscObligation);\n \n             // Create type variables for each argument.\n-            pat_util::pat_bindings(&input.pat, |_bm, pat_id, sp, _path| {\n+            input.pat.each_binding(|_bm, pat_id, sp, _path| {\n                 let var_ty = visit.assign(sp, pat_id, None);\n                 fcx.require_type_is_sized(var_ty, sp, traits::VariableType(pat_id));\n             });\n@@ -3627,72 +3626,58 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n               }\n               tcx.mk_nil()\n           }\n-          hir::ExprBreak(ref label_opt, ref expr_opt) => {\n-            let loop_id = if label_opt.is_some() {\n-                let loop_def = tcx.expect_def(expr.id);\n-                if let Def::Label(loop_id) = loop_def {\n-                    Some(Some(loop_id))\n-                } else if loop_def == Def::Err {\n-                    // an error was already printed, so just ignore it\n-                    None\n+          hir::ExprBreak(label, ref expr_opt) => {\n+            let loop_id = label.map(|l| l.loop_id);\n+            let coerce_to = {\n+                let mut enclosing_loops = self.enclosing_loops.borrow_mut();\n+                enclosing_loops.find_loop(loop_id).map(|ctxt| ctxt.coerce_to)\n+            };\n+            if let Some(coerce_to) = coerce_to {\n+                let e_ty;\n+                let cause;\n+                if let Some(ref e) = *expr_opt {\n+                    // Recurse without `enclosing_loops` borrowed.\n+                    e_ty = self.check_expr_with_hint(e, coerce_to);\n+                    cause = self.misc(e.span);\n+                    // Notably, the recursive call may alter coerce_to - must not keep using it!\n                 } else {\n-                    span_bug!(expr.span, \"break label resolved to a non-label\");\n+                    // `break` without argument acts like `break ()`.\n+                    e_ty = tcx.mk_nil();\n+                    cause = self.misc(expr.span);\n                 }\n-            } else {\n-                Some(None)\n-            };\n-            if let Some(loop_id) = loop_id {\n-                let coerce_to = {\n-                    let mut enclosing_loops = self.enclosing_loops.borrow_mut();\n-                    enclosing_loops.find_loop(loop_id).map(|ctxt| ctxt.coerce_to)\n-                };\n-                if let Some(coerce_to) = coerce_to {\n-                    let e_ty;\n-                    let cause;\n-                    if let Some(ref e) = *expr_opt {\n-                        // Recurse without `enclosing_loops` borrowed.\n-                        e_ty = self.check_expr_with_hint(e, coerce_to);\n-                        cause = self.misc(e.span);\n-                        // Notably, the recursive call may alter coerce_to - must not keep using it!\n-                    } else {\n-                        // `break` without argument acts like `break ()`.\n-                        e_ty = tcx.mk_nil();\n-                        cause = self.misc(expr.span);\n-                    }\n-                    let mut enclosing_loops = self.enclosing_loops.borrow_mut();\n-                    let ctxt = enclosing_loops.find_loop(loop_id).unwrap();\n+                let mut enclosing_loops = self.enclosing_loops.borrow_mut();\n+                let ctxt = enclosing_loops.find_loop(loop_id).unwrap();\n \n-                    let result = if let Some(ref e) = *expr_opt {\n-                        // Special-case the first element, as it has no \"previous expressions\".\n-                        let result = if !ctxt.may_break {\n-                            self.try_coerce(e, e_ty, ctxt.coerce_to)\n-                        } else {\n-                            self.try_find_coercion_lub(&cause, || ctxt.break_exprs.iter().cloned(),\n-                                                       ctxt.unified, e, e_ty)\n-                        };\n-\n-                        ctxt.break_exprs.push(e);\n-                        result\n+                let result = if let Some(ref e) = *expr_opt {\n+                    // Special-case the first element, as it has no \"previous expressions\".\n+                    let result = if !ctxt.may_break {\n+                        self.try_coerce(e, e_ty, ctxt.coerce_to)\n                     } else {\n-                        self.eq_types(true, &cause, e_ty, ctxt.unified)\n-                            .map(|InferOk { obligations, .. }| {\n-                                // FIXME(#32730) propagate obligations\n-                                assert!(obligations.is_empty());\n-                                e_ty\n-                            })\n+                        self.try_find_coercion_lub(&cause, || ctxt.break_exprs.iter().cloned(),\n+                                                   ctxt.unified, e, e_ty)\n                     };\n-                    match result {\n-                        Ok(ty) => ctxt.unified = ty,\n-                        Err(err) => {\n-                            self.report_mismatched_types(&cause, ctxt.unified, e_ty, err);\n-                        }\n-                    }\n \n-                    ctxt.may_break = true;\n+                    ctxt.break_exprs.push(e);\n+                    result\n+                } else {\n+                    self.eq_types(true, &cause, e_ty, ctxt.unified)\n+                        .map(|InferOk { obligations, .. }| {\n+                            // FIXME(#32730) propagate obligations\n+                            assert!(obligations.is_empty());\n+                            e_ty\n+                        })\n+                };\n+                match result {\n+                    Ok(ty) => ctxt.unified = ty,\n+                    Err(err) => {\n+                        self.report_mismatched_types(&cause, ctxt.unified, e_ty, err);\n+                    }\n                 }\n-                // Otherwise, we failed to find the enclosing loop; this can only happen if the\n-                // `break` was not inside a loop at all, which is caught by the loop-checking pass.\n+\n+                ctxt.may_break = true;\n             }\n+            // Otherwise, we failed to find the enclosing loop; this can only happen if the\n+            // `break` was not inside a loop at all, which is caught by the loop-checking pass.\n             tcx.types.never\n           }\n           hir::ExprAgain(_) => { tcx.types.never }\n@@ -4006,7 +3991,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     // Finish resolving a path in a struct expression or pattern `S::A { .. }` if necessary.\n-    // The newly resolved definition is written into `def_map`.\n+    // The newly resolved definition is written into `type_relative_path_defs`.\n     fn finish_resolving_struct_path(&self,\n                                     qpath: &hir::QPath,\n                                     path_span: Span,\n@@ -4016,33 +4001,30 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         match *qpath {\n             hir::QPath::Resolved(ref maybe_qself, ref path) => {\n                 let opt_self_ty = maybe_qself.as_ref().map(|qself| self.to_ty(qself));\n-                let def = self.tcx.expect_def(node_id);\n-                let ty = AstConv::def_to_ty(self, self,\n-                                            path.span,\n-                                            def,\n-                                            opt_self_ty,\n-                                            node_id,\n-                                            &path.segments,\n-                                            true);\n-                (def, ty)\n+                let ty = AstConv::def_to_ty(self, self, opt_self_ty, path, node_id, true);\n+                (path.def, ty)\n             }\n             hir::QPath::TypeRelative(ref qself, ref segment) => {\n                 let ty = self.to_ty(qself);\n \n-                let def = self.tcx.expect_def_or_none(qself.id).unwrap_or(Def::Err);\n+                let def = if let hir::TyPath(hir::QPath::Resolved(_, ref path)) = qself.node {\n+                    path.def\n+                } else {\n+                    Def::Err\n+                };\n                 let (ty, def) = AstConv::associated_path_def_to_ty(self, path_span,\n                                                                    ty, def, segment);\n \n                 // Write back the new resolution.\n-                self.tcx.def_map.borrow_mut().insert(node_id, PathResolution::new(def));\n+                self.tcx.tables.borrow_mut().type_relative_path_defs.insert(node_id, def);\n \n                 (def, ty)\n             }\n         }\n     }\n \n     // Resolve associated value path into a base type and associated constant or method definition.\n-    // The newly resolved definition is written into `def_map`.\n+    // The newly resolved definition is written into `type_relative_path_defs`.\n     pub fn resolve_ty_and_def_ufcs<'b>(&self,\n                                        qpath: &'b hir::QPath,\n                                        node_id: ast::NodeId,\n@@ -4051,7 +4033,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     {\n         let (ty, item_segment) = match *qpath {\n             hir::QPath::Resolved(ref opt_qself, ref path) => {\n-                return (self.tcx.expect_def(node_id),\n+                return (path.def,\n                         opt_qself.as_ref().map(|qself| self.to_ty(qself)),\n                         &path.segments[..]);\n             }\n@@ -4075,15 +4057,15 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         };\n \n         // Write back the new resolution.\n-        self.tcx.def_map.borrow_mut().insert(node_id, PathResolution::new(def));\n+        self.tcx.tables.borrow_mut().type_relative_path_defs.insert(node_id, def);\n         (def, Some(ty), slice::ref_slice(&**item_segment))\n     }\n \n     pub fn check_decl_initializer(&self,\n                                   local: &'gcx hir::Local,\n                                   init: &'gcx hir::Expr) -> Ty<'tcx>\n     {\n-        let ref_bindings = self.tcx.pat_contains_ref_binding(&local.pat);\n+        let ref_bindings = local.pat.contains_ref_binding();\n \n         let local_ty = self.local_ty(init.span, local.id);\n         if let Some(m) = ref_bindings {"}, {"sha": "ca33682480c4c61c1667243b0b56d16bbf58f8bb", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/962633cdbbe2ce87c1311edbaa0d4e0aca022b6d/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962633cdbbe2ce87c1311edbaa0d4e0aca022b6d/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=962633cdbbe2ce87c1311edbaa0d4e0aca022b6d", "patch": "@@ -92,7 +92,6 @@ use rustc::ty::subst::Substs;\n use rustc::traits;\n use rustc::ty::{self, Ty, MethodCall, TypeFoldable};\n use rustc::infer::{self, GenericKind, SubregionOrigin, VerifyBound};\n-use hir::pat_util;\n use rustc::ty::adjustment;\n use rustc::ty::wf::ImpliedBound;\n \n@@ -434,7 +433,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n     fn constrain_bindings_in_pat(&mut self, pat: &hir::Pat) {\n         let tcx = self.tcx;\n         debug!(\"regionck::visit_pat(pat={:?})\", pat);\n-        pat_util::pat_bindings(pat, |_, id, span, _| {\n+        pat.each_binding(|_, id, span, _| {\n             // If we have a variable that contains region'd data, that\n             // data will be accessible from anywhere that the variable is\n             // accessed. We must be wary of loops like this:"}, {"sha": "493f9d96fe028dcbfb0cee1d636bfb7f07bca3e3", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/962633cdbbe2ce87c1311edbaa0d4e0aca022b6d/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962633cdbbe2ce87c1311edbaa0d4e0aca022b6d/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=962633cdbbe2ce87c1311edbaa0d4e0aca022b6d", "patch": "@@ -542,11 +542,10 @@ fn is_param<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                       param_id: ast::NodeId)\n                       -> bool\n {\n-    if let hir::TyPath(hir::QPath::Resolved(None, _)) = ast_ty.node {\n-        let path_res = tcx.expect_resolution(ast_ty.id);\n-        match path_res.base_def {\n+    if let hir::TyPath(hir::QPath::Resolved(None, ref path)) = ast_ty.node {\n+        match path.def {\n             Def::SelfTy(Some(def_id), None) |\n-            Def::TyParam(def_id) if path_res.depth == 0 => {\n+            Def::TyParam(def_id) => {\n                 def_id == tcx.map.local_def_id(param_id)\n             }\n             _ => false\n@@ -1625,8 +1624,7 @@ fn add_unsized_bound<'gcx: 'tcx, 'tcx>(astconv: &AstConv<'gcx, 'tcx>,\n         Some(ref tpb) => {\n             // FIXME(#8559) currently requires the unbound to be built-in.\n             if let Ok(kind_id) = kind_id {\n-                let trait_def = tcx.expect_def(tpb.ref_id);\n-                if trait_def != Def::Trait(kind_id) {\n+                if tpb.path.def != Def::Trait(kind_id) {\n                     tcx.sess.span_warn(span,\n                                        \"default bound relaxed for a type parameter, but \\\n                                        this does nothing because the given bound is not \\"}, {"sha": "e3274611e5bff3ee30ba50c61b825865e20e7dfa", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 8, "deletions": 11, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/962633cdbbe2ce87c1311edbaa0d4e0aca022b6d/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962633cdbbe2ce87c1311edbaa0d4e0aca022b6d/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=962633cdbbe2ce87c1311edbaa0d4e0aca022b6d", "patch": "@@ -29,24 +29,21 @@ use clean::{self, GetDefId};\n \n use super::Clean;\n \n-/// Attempt to inline the definition of a local node id into this AST.\n+/// Attempt to inline a definition into this AST.\n ///\n-/// This function will fetch the definition of the id specified, and if it is\n-/// from another crate it will attempt to inline the documentation from the\n-/// other crate into this crate.\n+/// This function will fetch the definition specified, and if it is\n+/// from another crate it will attempt to inline the documentation\n+/// from the other crate into this crate.\n ///\n /// This is primarily used for `pub use` statements which are, in general,\n /// implementation details. Inlining the documentation should help provide a\n /// better experience when reading the documentation in this use case.\n ///\n-/// The returned value is `None` if the `id` could not be inlined, and `Some`\n-/// of a vector of items if it was successfully expanded.\n-pub fn try_inline(cx: &DocContext, id: ast::NodeId, into: Option<ast::Name>)\n+/// The returned value is `None` if the definition could not be inlined,\n+/// and `Some` of a vector of items if it was successfully expanded.\n+pub fn try_inline(cx: &DocContext, def: Def, into: Option<ast::Name>)\n                   -> Option<Vec<clean::Item>> {\n-    let def = match cx.tcx.expect_def_or_none(id) {\n-        Some(def) => def,\n-        None => return None,\n-    };\n+    if def == Def::Err { return None }\n     let did = def.def_id();\n     if did.is_local() { return None }\n     try_inline_def(cx, def).map(|vec| {"}, {"sha": "0fda1f4bf100aa1b8e49a9afd4fb187c0ac52ac3", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 26, "deletions": 19, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/962633cdbbe2ce87c1311edbaa0d4e0aca022b6d/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962633cdbbe2ce87c1311edbaa0d4e0aca022b6d/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=962633cdbbe2ce87c1311edbaa0d4e0aca022b6d", "patch": "@@ -667,6 +667,7 @@ fn external_path(cx: &DocContext, name: &str, trait_did: Option<DefId>, has_self\n                  bindings: Vec<TypeBinding>, substs: &Substs) -> Path {\n     Path {\n         global: false,\n+        def: Def::Err,\n         segments: vec![PathSegment {\n             name: name.to_string(),\n             params: external_path_params(cx, trait_did, has_self, bindings, substs)\n@@ -1728,13 +1729,12 @@ impl Clean<Type> for hir::Ty {\n             },\n             TyTup(ref tys) => Tuple(tys.clean(cx)),\n             TyPath(hir::QPath::Resolved(None, ref path)) => {\n-                let def = cx.tcx.expect_def(self.id);\n-                if let Some(new_ty) = cx.ty_substs.borrow().get(&def).cloned() {\n+                if let Some(new_ty) = cx.ty_substs.borrow().get(&path.def).cloned() {\n                     return new_ty;\n                 }\n \n                 let mut alias = None;\n-                if let Def::TyAlias(def_id) = def {\n+                if let Def::TyAlias(def_id) = path.def {\n                     // Substitute private type aliases\n                     if let Some(node_id) = cx.tcx.map.as_local_node_id(def_id) {\n                         if !cx.access_levels.borrow().is_exported(def_id) {\n@@ -1748,7 +1748,7 @@ impl Clean<Type> for hir::Ty {\n                     let mut ty_substs = FxHashMap();\n                     let mut lt_substs = FxHashMap();\n                     for (i, ty_param) in generics.ty_params.iter().enumerate() {\n-                        let ty_param_def = cx.tcx.expect_def(ty_param.id);\n+                        let ty_param_def = Def::TyParam(cx.tcx.map.local_def_id(ty_param.id));\n                         if let Some(ty) = provided_params.types().get(i).cloned()\n                                                                         .cloned() {\n                             ty_substs.insert(ty_param_def, ty.unwrap().clean(cx));\n@@ -1772,6 +1772,7 @@ impl Clean<Type> for hir::Ty {\n                 let trait_path = hir::Path {\n                     span: p.span,\n                     global: p.global,\n+                    def: Def::Trait(cx.tcx.associated_item(p.def.def_id()).container.id()),\n                     segments: segments.into(),\n                 };\n                 Type::QPath {\n@@ -1784,6 +1785,10 @@ impl Clean<Type> for hir::Ty {\n                 let trait_path = hir::Path {\n                     span: self.span,\n                     global: false,\n+                    def: cx.tcx_opt().map_or(Def::Err, |tcx| {\n+                        let def_id = tcx.tables().type_relative_path_defs[&self.id].def_id();\n+                        Def::Trait(tcx.associated_item(def_id).container.id())\n+                    }),\n                     segments: vec![].into(),\n                 };\n                 Type::QPath {\n@@ -2194,13 +2199,15 @@ impl Clean<Span> for syntax_pos::Span {\n #[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Debug)]\n pub struct Path {\n     pub global: bool,\n+    pub def: Def,\n     pub segments: Vec<PathSegment>,\n }\n \n impl Path {\n     pub fn singleton(name: String) -> Path {\n         Path {\n             global: false,\n+            def: Def::Err,\n             segments: vec![PathSegment {\n                 name: name,\n                 params: PathParameters::AngleBracketed {\n@@ -2221,6 +2228,7 @@ impl Clean<Path> for hir::Path {\n     fn clean(&self, cx: &DocContext) -> Path {\n         Path {\n             global: self.global,\n+            def: self.def,\n             segments: self.segments.clean(cx),\n         }\n     }\n@@ -2591,15 +2599,15 @@ impl Clean<Vec<Item>> for doctree::Import {\n         });\n         let path = self.path.clean(cx);\n         let inner = if self.glob {\n-            Import::Glob(resolve_use_source(cx, path, self.id))\n+            Import::Glob(resolve_use_source(cx, path))\n         } else {\n             let name = self.name;\n             if !denied {\n-                if let Some(items) = inline::try_inline(cx, self.id, Some(name)) {\n+                if let Some(items) = inline::try_inline(cx, path.def, Some(name)) {\n                     return items;\n                 }\n             }\n-            Import::Simple(name.clean(cx), resolve_use_source(cx, path, self.id))\n+            Import::Simple(name.clean(cx), resolve_use_source(cx, path))\n         };\n         vec![Item {\n             name: None,\n@@ -2697,7 +2705,7 @@ fn name_from_pat(p: &hir::Pat) -> String {\n \n     match p.node {\n         PatKind::Wild => \"_\".to_string(),\n-        PatKind::Binding(_, ref p, _) => p.node.to_string(),\n+        PatKind::Binding(_, _, ref p, _) => p.node.to_string(),\n         PatKind::TupleStruct(ref p, ..) | PatKind::Path(ref p) => qpath_to_string(p),\n         PatKind::Struct(ref name, ref fields, etc) => {\n             format!(\"{} {{ {}{} }}\", qpath_to_string(name),\n@@ -2727,15 +2735,13 @@ fn name_from_pat(p: &hir::Pat) -> String {\n     }\n }\n \n-/// Given a Type, resolve it using the def_map\n+/// Given a type Path, resolve it to a Type using the TyCtxt\n fn resolve_type(cx: &DocContext,\n                 path: Path,\n                 id: ast::NodeId) -> Type {\n     debug!(\"resolve_type({:?},{:?})\", path, id);\n-    let def = cx.tcx.expect_def(id);\n-    debug!(\"resolve_type: def={:?}\", def);\n \n-    let is_generic = match def {\n+    let is_generic = match path.def {\n         Def::PrimTy(p) => match p {\n             hir::TyStr => return Primitive(PrimitiveType::Str),\n             hir::TyBool => return Primitive(PrimitiveType::Bool),\n@@ -2750,7 +2756,7 @@ fn resolve_type(cx: &DocContext,\n         Def::SelfTy(..) | Def::TyParam(..) | Def::AssociatedTy(..) => true,\n         _ => false,\n     };\n-    let did = register_def(&*cx, def);\n+    let did = register_def(&*cx, path.def);\n     ResolvedPath { path: path, typarams: None, did: did, is_generic: is_generic }\n }\n \n@@ -2782,17 +2788,17 @@ fn register_def(cx: &DocContext, def: Def) -> DefId {\n     did\n }\n \n-fn resolve_use_source(cx: &DocContext, path: Path, id: ast::NodeId) -> ImportSource {\n+fn resolve_use_source(cx: &DocContext, path: Path) -> ImportSource {\n     ImportSource {\n+        did: if path.def == Def::Err {\n+            None\n+        } else {\n+            Some(register_def(cx, path.def))\n+        },\n         path: path,\n-        did: resolve_def(cx, id),\n     }\n }\n \n-fn resolve_def(cx: &DocContext, id: ast::NodeId) -> Option<DefId> {\n-    cx.tcx.expect_def_or_none(id).map(|def| register_def(cx, def))\n-}\n-\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub struct Macro {\n     pub source: String,\n@@ -2896,6 +2902,7 @@ fn lang_struct(cx: &DocContext, did: Option<DefId>,\n         did: did,\n         path: Path {\n             global: false,\n+            def: Def::Err,\n             segments: vec![PathSegment {\n                 name: name.to_string(),\n                 params: PathParameters::AngleBracketed {"}, {"sha": "4087b9a761f97dfc44f066eb3de568b1ae276e4e", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 17, "deletions": 5, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/962633cdbbe2ce87c1311edbaa0d4e0aca022b6d/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962633cdbbe2ce87c1311edbaa0d4e0aca022b6d/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=962633cdbbe2ce87c1311edbaa0d4e0aca022b6d", "patch": "@@ -234,8 +234,13 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n     /// and follows different rules.\n     ///\n     /// Returns true if the target has been inlined.\n-    fn maybe_inline_local(&mut self, id: ast::NodeId, renamed: Option<ast::Name>,\n-                  glob: bool, om: &mut Module, please_inline: bool) -> bool {\n+    fn maybe_inline_local(&mut self,\n+                          id: ast::NodeId,\n+                          def: Def,\n+                          renamed: Option<ast::Name>,\n+                          glob: bool,\n+                          om: &mut Module,\n+                          please_inline: bool) -> bool {\n \n         fn inherits_doc_hidden(cx: &core::DocContext, mut node: ast::NodeId) -> bool {\n             while let Some(id) = cx.tcx.map.get_enclosing_scope(node) {\n@@ -251,7 +256,9 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n         }\n \n         let tcx = self.cx.tcx;\n-        let def = tcx.expect_def(id);\n+        if def == Def::Err {\n+            return false;\n+        }\n         let def_did = def.def_id();\n \n         let use_attrs = tcx.map.attrs(id);\n@@ -368,13 +375,18 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                         }\n                     });\n                     let name = if is_glob { None } else { Some(name) };\n-                    if self.maybe_inline_local(item.id, name, is_glob, om, please_inline) {\n+                    if self.maybe_inline_local(item.id,\n+                                               path.def,\n+                                               name,\n+                                               is_glob,\n+                                               om,\n+                                               please_inline) {\n                         return;\n                     }\n                 }\n \n                 om.imports.push(Import {\n-                    name: item.name,\n+                    name: name,\n                     id: item.id,\n                     vis: item.vis.clone(),\n                     attrs: item.attrs.clone(),"}, {"sha": "e2acdcee3de8f7447c00c613617b8969617f6137", "filename": "src/test/compile-fail/issue-3521.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/962633cdbbe2ce87c1311edbaa0d4e0aca022b6d/src%2Ftest%2Fcompile-fail%2Fissue-3521.rs", "raw_url": "https://github.com/rust-lang/rust/raw/962633cdbbe2ce87c1311edbaa0d4e0aca022b6d/src%2Ftest%2Fcompile-fail%2Fissue-3521.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3521.rs?ref=962633cdbbe2ce87c1311edbaa0d4e0aca022b6d", "patch": "@@ -16,7 +16,7 @@ fn main() {\n         Bar = foo\n         //~^ ERROR attempt to use a non-constant value in a constant\n         //~^^ ERROR constant evaluation error\n-        //~| non-constant path in constant expression\n+        //~| unresolved path in constant expression\n     }\n \n     println!(\"{}\", Stuff::Bar);"}]}