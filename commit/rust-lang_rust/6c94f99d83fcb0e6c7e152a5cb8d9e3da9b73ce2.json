{"sha": "6c94f99d83fcb0e6c7e152a5cb8d9e3da9b73ce2", "node_id": "C_kwDOAAsO6NoAKDZjOTRmOTlkODNmY2IwZTZjN2UxNTJhNWNiOGQ5ZTNkYTliNzNjZTI", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2022-01-15T01:25:20Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-01-15T01:25:20Z"}, "message": "Rollup merge of #92875 - BoxyUwU:infer_arg_opt_const_param_of, r=lcnr\n\nMake `opt_const_param_of` work in the presence of `GenericArg::Infer`\n\nhighly recommend viewing the first and second commits on their own rather than looking at file changes :rofl:\n\nBecause we filtered args down to just const args we would ignore `GenericArg::Infer` which made us get a `arg_index` which was wrong by however many const `GenericArg::Infer` came previously\n\n[example](https://play.rust-lang.org/?version=nightly&mode=debug&edition=2021&gist=46dba6a53aca6333028a10908ef16e0b) of the [bugs](https://play.rust-lang.org/?version=nightly&mode=debug&edition=2021&gist=a8eebced26eefa4119fc2e7ae0c76de6) fixed.\n\nr? ```@lcnr```", "tree": {"sha": "d7b3f3c936887c160c03a321bbac385c2bacbc9c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d7b3f3c936887c160c03a321bbac385c2bacbc9c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6c94f99d83fcb0e6c7e152a5cb8d9e3da9b73ce2", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJh4iKACRBK7hj4Ov3rIwAAuVcIADrmVwlF3lV71+cwZnoDiSRn\nTN2/vdgVwcXaHZ2Mur0ilf7cox1C9pqDt6i8N3oNl84DsJUsYhsuMWAuwLdPX+no\nqZvYQjBuHyqoL74wR2pFoURaMduKyaRjIc83yZDwrGChB54Vyau5EQkaPwvLLJHx\n1IG7ujlfeGUs6cUCW9fNS7t0E1lHDF9JNhADez0hjxE68M/1wT1c6TZZgnwaMVeP\njsIROmFlL+lA4KAVqRsB/xOCMgLiRCwR0jNsephAF9+oq5O0HlS0ucowtuivDWd2\nhtoQoP2B6y2QlL8H5thB/Bujzr4m1T3ii/SKb4cIE8gx12a7Vphpkpn2Z2NfiTg=\n=mVjV\n-----END PGP SIGNATURE-----\n", "payload": "tree d7b3f3c936887c160c03a321bbac385c2bacbc9c\nparent 8f4155909c6008cc4749c208c4dbcc1ae6b1218b\nparent 61c07a9a23d8967564bdddb5137efadeb48df271\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1642209920 +0100\ncommitter GitHub <noreply@github.com> 1642209920 +0100\n\nRollup merge of #92875 - BoxyUwU:infer_arg_opt_const_param_of, r=lcnr\n\nMake `opt_const_param_of` work in the presence of `GenericArg::Infer`\n\nhighly recommend viewing the first and second commits on their own rather than looking at file changes :rofl:\n\nBecause we filtered args down to just const args we would ignore `GenericArg::Infer` which made us get a `arg_index` which was wrong by however many const `GenericArg::Infer` came previously\n\n[example](https://play.rust-lang.org/?version=nightly&mode=debug&edition=2021&gist=46dba6a53aca6333028a10908ef16e0b) of the [bugs](https://play.rust-lang.org/?version=nightly&mode=debug&edition=2021&gist=a8eebced26eefa4119fc2e7ae0c76de6) fixed.\n\nr? ```@lcnr```\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6c94f99d83fcb0e6c7e152a5cb8d9e3da9b73ce2", "html_url": "https://github.com/rust-lang/rust/commit/6c94f99d83fcb0e6c7e152a5cb8d9e3da9b73ce2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6c94f99d83fcb0e6c7e152a5cb8d9e3da9b73ce2/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8f4155909c6008cc4749c208c4dbcc1ae6b1218b", "url": "https://api.github.com/repos/rust-lang/rust/commits/8f4155909c6008cc4749c208c4dbcc1ae6b1218b", "html_url": "https://github.com/rust-lang/rust/commit/8f4155909c6008cc4749c208c4dbcc1ae6b1218b"}, {"sha": "61c07a9a23d8967564bdddb5137efadeb48df271", "url": "https://api.github.com/repos/rust-lang/rust/commits/61c07a9a23d8967564bdddb5137efadeb48df271", "html_url": "https://github.com/rust-lang/rust/commit/61c07a9a23d8967564bdddb5137efadeb48df271"}], "stats": {"total": 450, "additions": 231, "deletions": 219}, "files": [{"sha": "76f4df6ec2da8c4080cea1bc4fc93fff2ef34e38", "filename": "compiler/rustc_hir/src/hir.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/6c94f99d83fcb0e6c7e152a5cb8d9e3da9b73ce2/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c94f99d83fcb0e6c7e152a5cb8d9e3da9b73ce2/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fhir.rs?ref=6c94f99d83fcb0e6c7e152a5cb8d9e3da9b73ce2", "patch": "@@ -293,10 +293,6 @@ impl GenericArg<'_> {\n         }\n     }\n \n-    pub fn is_const(&self) -> bool {\n-        matches!(self, GenericArg::Const(_))\n-    }\n-\n     pub fn is_synthetic(&self) -> bool {\n         matches!(self, GenericArg::Lifetime(lifetime) if lifetime.name.ident() == Ident::empty())\n     }\n@@ -318,6 +314,13 @@ impl GenericArg<'_> {\n             GenericArg::Infer(_) => ast::ParamKindOrd::Infer,\n         }\n     }\n+\n+    pub fn is_ty_or_const(&self) -> bool {\n+        match self {\n+            GenericArg::Lifetime(_) => false,\n+            GenericArg::Type(_) | GenericArg::Const(_) | GenericArg::Infer(_) => true,\n+        }\n+    }\n }\n \n #[derive(Debug, HashStable_Generic)]"}, {"sha": "0bd96f8f865fcaa33f4882a1c1f5535802300765", "filename": "compiler/rustc_middle/src/ty/generics.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6c94f99d83fcb0e6c7e152a5cb8d9e3da9b73ce2/compiler%2Frustc_middle%2Fsrc%2Fty%2Fgenerics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c94f99d83fcb0e6c7e152a5cb8d9e3da9b73ce2/compiler%2Frustc_middle%2Fsrc%2Fty%2Fgenerics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fgenerics.rs?ref=6c94f99d83fcb0e6c7e152a5cb8d9e3da9b73ce2", "patch": "@@ -31,6 +31,13 @@ impl GenericParamDefKind {\n             GenericParamDefKind::Const { .. } => ast::ParamKindOrd::Const,\n         }\n     }\n+\n+    pub fn is_ty_or_const(&self) -> bool {\n+        match self {\n+            GenericParamDefKind::Lifetime => false,\n+            GenericParamDefKind::Type { .. } | GenericParamDefKind::Const { .. } => true,\n+        }\n+    }\n }\n \n #[derive(Clone, Debug, TyEncodable, TyDecodable, HashStable)]"}, {"sha": "5ff2a74754117d988c44c17a5b12971f89faac3c", "filename": "compiler/rustc_typeck/src/collect/type_of.rs", "status": "modified", "additions": 202, "deletions": 204, "changes": 406, "blob_url": "https://github.com/rust-lang/rust/blob/6c94f99d83fcb0e6c7e152a5cb8d9e3da9b73ce2/compiler%2Frustc_typeck%2Fsrc%2Fcollect%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c94f99d83fcb0e6c7e152a5cb8d9e3da9b73ce2/compiler%2Frustc_typeck%2Fsrc%2Fcollect%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcollect%2Ftype_of.rs?ref=6c94f99d83fcb0e6c7e152a5cb8d9e3da9b73ce2", "patch": "@@ -18,238 +18,236 @@ use super::{bad_placeholder, is_suggestable_infer_ty};\n /// Computes the relevant generic parameter for a potential generic const argument.\n ///\n /// This should be called using the query `tcx.opt_const_param_of`.\n+#[instrument(level = \"debug\", skip(tcx))]\n pub(super) fn opt_const_param_of(tcx: TyCtxt<'_>, def_id: LocalDefId) -> Option<DefId> {\n     // FIXME(generic_arg_infer): allow for returning DefIds of inference of\n     // GenericArg::Infer below. This may require a change where GenericArg::Infer has some flag\n     // for const or type.\n     use hir::*;\n     let hir_id = tcx.hir().local_def_id_to_hir_id(def_id);\n \n-    if let Node::AnonConst(_) = tcx.hir().get(hir_id) {\n-        let parent_node_id = tcx.hir().get_parent_node(hir_id);\n-        let parent_node = tcx.hir().get(parent_node_id);\n+    match tcx.hir().get(hir_id) {\n+        Node::AnonConst(_) => (),\n+        _ => return None,\n+    };\n \n-        match parent_node {\n-            // This match arm is for when the def_id appears in a GAT whose\n-            // path can't be resolved without typechecking e.g.\n-            //\n-            // trait Foo {\n-            //   type Assoc<const N: usize>;\n-            //   fn foo() -> Self::Assoc<3>;\n-            // }\n-            //\n-            // In the above code we would call this query with the def_id of 3 and\n-            // the parent_node we match on would be the hir node for Self::Assoc<3>\n-            //\n-            // `Self::Assoc<3>` cant be resolved without typchecking here as we\n-            // didnt write <Self as Foo>::Assoc<3>. If we did then another match\n-            // arm would handle this.\n-            //\n-            // I believe this match arm is only needed for GAT but I am not 100% sure - BoxyUwU\n-            Node::Ty(hir_ty @ Ty { kind: TyKind::Path(QPath::TypeRelative(_, segment)), .. }) => {\n-                // Find the Item containing the associated type so we can create an ItemCtxt.\n-                // Using the ItemCtxt convert the HIR for the unresolved assoc type into a\n-                // ty which is a fully resolved projection.\n-                // For the code example above, this would mean converting Self::Assoc<3>\n-                // into a ty::Projection(<Self as Foo>::Assoc<3>)\n-                let item_hir_id = tcx\n-                    .hir()\n-                    .parent_iter(hir_id)\n-                    .filter(|(_, node)| matches!(node, Node::Item(_)))\n-                    .map(|(id, _)| id)\n-                    .next()\n-                    .unwrap();\n-                let item_did = tcx.hir().local_def_id(item_hir_id).to_def_id();\n-                let item_ctxt = &ItemCtxt::new(tcx, item_did) as &dyn crate::astconv::AstConv<'_>;\n-                let ty = item_ctxt.ast_ty_to_ty(hir_ty);\n-\n-                // Iterate through the generics of the projection to find the one that corresponds to\n-                // the def_id that this query was called with. We filter to only const args here as a\n-                // precaution for if it's ever allowed to elide lifetimes in GAT's. It currently isn't\n-                // but it can't hurt to be safe ^^\n-                if let ty::Projection(projection) = ty.kind() {\n-                    let generics = tcx.generics_of(projection.item_def_id);\n-\n-                    let arg_index = segment\n-                        .args\n-                        .and_then(|args| {\n-                            args.args\n-                                .iter()\n-                                .filter(|arg| arg.is_const())\n-                                .position(|arg| arg.id() == hir_id)\n-                        })\n-                        .unwrap_or_else(|| {\n-                            bug!(\"no arg matching AnonConst in segment\");\n-                        });\n+    let parent_node_id = tcx.hir().get_parent_node(hir_id);\n+    let parent_node = tcx.hir().get(parent_node_id);\n \n-                    return generics\n-                        .params\n-                        .iter()\n-                        .filter(|param| matches!(param.kind, ty::GenericParamDefKind::Const { .. }))\n-                        .nth(arg_index)\n-                        .map(|param| param.def_id);\n-                }\n-\n-                // I dont think it's possible to reach this but I'm not 100% sure - BoxyUwU\n-                tcx.sess.delay_span_bug(\n-                    tcx.def_span(def_id),\n-                    \"unexpected non-GAT usage of an anon const\",\n-                );\n-                return None;\n-            }\n-            Node::Expr(&Expr {\n-                kind:\n-                    ExprKind::MethodCall(segment, ..) | ExprKind::Path(QPath::TypeRelative(_, segment)),\n-                ..\n-            }) => {\n-                let body_owner = tcx.hir().local_def_id(tcx.hir().enclosing_body_owner(hir_id));\n-                let tables = tcx.typeck(body_owner);\n-                // This may fail in case the method/path does not actually exist.\n-                // As there is no relevant param for `def_id`, we simply return\n-                // `None` here.\n-                let type_dependent_def = tables.type_dependent_def_id(parent_node_id)?;\n-                let idx = segment\n+    let (generics, arg_idx) = match parent_node {\n+        // This match arm is for when the def_id appears in a GAT whose\n+        // path can't be resolved without typechecking e.g.\n+        //\n+        // trait Foo {\n+        //   type Assoc<const N: usize>;\n+        //   fn foo() -> Self::Assoc<3>;\n+        // }\n+        //\n+        // In the above code we would call this query with the def_id of 3 and\n+        // the parent_node we match on would be the hir node for Self::Assoc<3>\n+        //\n+        // `Self::Assoc<3>` cant be resolved without typchecking here as we\n+        // didnt write <Self as Foo>::Assoc<3>. If we did then another match\n+        // arm would handle this.\n+        //\n+        // I believe this match arm is only needed for GAT but I am not 100% sure - BoxyUwU\n+        Node::Ty(hir_ty @ Ty { kind: TyKind::Path(QPath::TypeRelative(_, segment)), .. }) => {\n+            // Find the Item containing the associated type so we can create an ItemCtxt.\n+            // Using the ItemCtxt convert the HIR for the unresolved assoc type into a\n+            // ty which is a fully resolved projection.\n+            // For the code example above, this would mean converting Self::Assoc<3>\n+            // into a ty::Projection(<Self as Foo>::Assoc<3>)\n+            let item_hir_id = tcx\n+                .hir()\n+                .parent_iter(hir_id)\n+                .filter(|(_, node)| matches!(node, Node::Item(_)))\n+                .map(|(id, _)| id)\n+                .next()\n+                .unwrap();\n+            let item_did = tcx.hir().local_def_id(item_hir_id).to_def_id();\n+            let item_ctxt = &ItemCtxt::new(tcx, item_did) as &dyn crate::astconv::AstConv<'_>;\n+            let ty = item_ctxt.ast_ty_to_ty(hir_ty);\n+\n+            // Iterate through the generics of the projection to find the one that corresponds to\n+            // the def_id that this query was called with. We filter to only const args here as a\n+            // precaution for if it's ever allowed to elide lifetimes in GAT's. It currently isn't\n+            // but it can't hurt to be safe ^^\n+            if let ty::Projection(projection) = ty.kind() {\n+                let generics = tcx.generics_of(projection.item_def_id);\n+\n+                let arg_index = segment\n                     .args\n                     .and_then(|args| {\n                         args.args\n                             .iter()\n-                            .filter(|arg| arg.is_const())\n+                            .filter(|arg| arg.is_ty_or_const())\n                             .position(|arg| arg.id() == hir_id)\n                     })\n                     .unwrap_or_else(|| {\n                         bug!(\"no arg matching AnonConst in segment\");\n                     });\n \n-                tcx.generics_of(type_dependent_def)\n-                    .params\n-                    .iter()\n-                    .filter(|param| matches!(param.kind, ty::GenericParamDefKind::Const { .. }))\n-                    .nth(idx)\n-                    .map(|param| param.def_id)\n+                (generics, arg_index)\n+            } else {\n+                // I dont think it's possible to reach this but I'm not 100% sure - BoxyUwU\n+                tcx.sess.delay_span_bug(\n+                    tcx.def_span(def_id),\n+                    \"unexpected non-GAT usage of an anon const\",\n+                );\n+                return None;\n             }\n+        }\n+        Node::Expr(&Expr {\n+            kind:\n+                ExprKind::MethodCall(segment, ..) | ExprKind::Path(QPath::TypeRelative(_, segment)),\n+            ..\n+        }) => {\n+            let body_owner = tcx.hir().local_def_id(tcx.hir().enclosing_body_owner(hir_id));\n+            let tables = tcx.typeck(body_owner);\n+            // This may fail in case the method/path does not actually exist.\n+            // As there is no relevant param for `def_id`, we simply return\n+            // `None` here.\n+            let type_dependent_def = tables.type_dependent_def_id(parent_node_id)?;\n+            let idx = segment\n+                .args\n+                .and_then(|args| {\n+                    args.args\n+                        .iter()\n+                        .filter(|arg| arg.is_ty_or_const())\n+                        .position(|arg| arg.id() == hir_id)\n+                })\n+                .unwrap_or_else(|| {\n+                    bug!(\"no arg matching AnonConst in segment\");\n+                });\n \n-            Node::Ty(&Ty { kind: TyKind::Path(_), .. })\n-            | Node::Expr(&Expr { kind: ExprKind::Path(_) | ExprKind::Struct(..), .. })\n-            | Node::TraitRef(..)\n-            | Node::Pat(_) => {\n-                let path = match parent_node {\n-                    Node::Ty(&Ty { kind: TyKind::Path(QPath::Resolved(_, path)), .. })\n-                    | Node::TraitRef(&TraitRef { path, .. }) => &*path,\n-                    Node::Expr(&Expr {\n-                        kind:\n-                            ExprKind::Path(QPath::Resolved(_, path))\n-                            | ExprKind::Struct(&QPath::Resolved(_, path), ..),\n-                        ..\n-                    }) => {\n-                        let body_owner =\n-                            tcx.hir().local_def_id(tcx.hir().enclosing_body_owner(hir_id));\n-                        let _tables = tcx.typeck(body_owner);\n-                        &*path\n-                    }\n-                    Node::Pat(pat) => {\n-                        if let Some(path) = get_path_containing_arg_in_pat(pat, hir_id) {\n-                            path\n-                        } else {\n-                            tcx.sess.delay_span_bug(\n-                                tcx.def_span(def_id),\n-                                &format!(\n-                                    \"unable to find const parent for {} in pat {:?}\",\n-                                    hir_id, pat\n-                                ),\n-                            );\n-                            return None;\n-                        }\n-                    }\n-                    _ => {\n-                        tcx.sess.delay_span_bug(\n-                            tcx.def_span(def_id),\n-                            &format!(\"unexpected const parent path {:?}\", parent_node),\n-                        );\n-                        return None;\n-                    }\n-                };\n-\n-                // We've encountered an `AnonConst` in some path, so we need to\n-                // figure out which generic parameter it corresponds to and return\n-                // the relevant type.\n-                let filtered = path\n-                    .segments\n-                    .iter()\n-                    .filter_map(|seg| seg.args.map(|args| (args.args, seg)))\n-                    .find_map(|(args, seg)| {\n-                        args.iter()\n-                            .filter(|arg| arg.is_const())\n-                            .position(|arg| arg.id() == hir_id)\n-                            .map(|index| (index, seg))\n-                    });\n-                let (arg_index, segment) = match filtered {\n-                    None => {\n-                        tcx.sess.delay_span_bug(\n-                            tcx.def_span(def_id),\n-                            \"no arg matching AnonConst in path\",\n-                        );\n-                        return None;\n-                    }\n-                    Some(inner) => inner,\n-                };\n-\n-                // Try to use the segment resolution if it is valid, otherwise we\n-                // default to the path resolution.\n-                let res = segment.res.filter(|&r| r != Res::Err).unwrap_or(path.res);\n-                use def::CtorOf;\n-                let generics = match res {\n-                    Res::Def(DefKind::Ctor(CtorOf::Variant, _), def_id) => tcx.generics_of(\n-                        tcx.parent(def_id).and_then(|def_id| tcx.parent(def_id)).unwrap(),\n-                    ),\n-                    Res::Def(DefKind::Variant | DefKind::Ctor(CtorOf::Struct, _), def_id) => {\n-                        tcx.generics_of(tcx.parent(def_id).unwrap())\n-                    }\n-                    // Other `DefKind`s don't have generics and would ICE when calling\n-                    // `generics_of`.\n-                    Res::Def(\n-                        DefKind::Struct\n-                        | DefKind::Union\n-                        | DefKind::Enum\n-                        | DefKind::Trait\n-                        | DefKind::OpaqueTy\n-                        | DefKind::TyAlias\n-                        | DefKind::ForeignTy\n-                        | DefKind::TraitAlias\n-                        | DefKind::AssocTy\n-                        | DefKind::Fn\n-                        | DefKind::AssocFn\n-                        | DefKind::AssocConst\n-                        | DefKind::Impl,\n-                        def_id,\n-                    ) => tcx.generics_of(def_id),\n-                    Res::Err => {\n-                        tcx.sess.delay_span_bug(tcx.def_span(def_id), \"anon const with Res::Err\");\n-                        return None;\n-                    }\n-                    _ => {\n-                        // If the user tries to specify generics on a type that does not take them,\n-                        // e.g. `usize<T>`, we may hit this branch, in which case we treat it as if\n-                        // no arguments have been passed. An error should already have been emitted.\n+            (tcx.generics_of(type_dependent_def), idx)\n+        }\n+\n+        Node::Ty(&Ty { kind: TyKind::Path(_), .. })\n+        | Node::Expr(&Expr { kind: ExprKind::Path(_) | ExprKind::Struct(..), .. })\n+        | Node::TraitRef(..)\n+        | Node::Pat(_) => {\n+            let path = match parent_node {\n+                Node::Ty(&Ty { kind: TyKind::Path(QPath::Resolved(_, path)), .. })\n+                | Node::TraitRef(&TraitRef { path, .. }) => &*path,\n+                Node::Expr(&Expr {\n+                    kind:\n+                        ExprKind::Path(QPath::Resolved(_, path))\n+                        | ExprKind::Struct(&QPath::Resolved(_, path), ..),\n+                    ..\n+                }) => {\n+                    let body_owner = tcx.hir().local_def_id(tcx.hir().enclosing_body_owner(hir_id));\n+                    let _tables = tcx.typeck(body_owner);\n+                    &*path\n+                }\n+                Node::Pat(pat) => {\n+                    if let Some(path) = get_path_containing_arg_in_pat(pat, hir_id) {\n+                        path\n+                    } else {\n                         tcx.sess.delay_span_bug(\n                             tcx.def_span(def_id),\n-                            &format!(\"unexpected anon const res {:?} in path: {:?}\", res, path),\n+                            &format!(\"unable to find const parent for {} in pat {:?}\", hir_id, pat),\n                         );\n                         return None;\n                     }\n-                };\n-\n-                generics\n-                    .params\n-                    .iter()\n-                    .filter(|param| matches!(param.kind, ty::GenericParamDefKind::Const { .. }))\n-                    .nth(arg_index)\n-                    .map(|param| param.def_id)\n+                }\n+                _ => {\n+                    tcx.sess.delay_span_bug(\n+                        tcx.def_span(def_id),\n+                        &format!(\"unexpected const parent path {:?}\", parent_node),\n+                    );\n+                    return None;\n+                }\n+            };\n+\n+            // We've encountered an `AnonConst` in some path, so we need to\n+            // figure out which generic parameter it corresponds to and return\n+            // the relevant type.\n+            let filtered = path\n+                .segments\n+                .iter()\n+                .filter_map(|seg| seg.args.map(|args| (args.args, seg)))\n+                .find_map(|(args, seg)| {\n+                    args.iter()\n+                        .filter(|arg| arg.is_ty_or_const())\n+                        .position(|arg| arg.id() == hir_id)\n+                        .map(|index| (index, seg))\n+                });\n+            let (arg_index, segment) = match filtered {\n+                None => {\n+                    tcx.sess\n+                        .delay_span_bug(tcx.def_span(def_id), \"no arg matching AnonConst in path\");\n+                    return None;\n+                }\n+                Some(inner) => inner,\n+            };\n+\n+            // Try to use the segment resolution if it is valid, otherwise we\n+            // default to the path resolution.\n+            let res = segment.res.filter(|&r| r != Res::Err).unwrap_or(path.res);\n+            use def::CtorOf;\n+            let generics = match res {\n+                Res::Def(DefKind::Ctor(CtorOf::Variant, _), def_id) => tcx\n+                    .generics_of(tcx.parent(def_id).and_then(|def_id| tcx.parent(def_id)).unwrap()),\n+                Res::Def(DefKind::Variant | DefKind::Ctor(CtorOf::Struct, _), def_id) => {\n+                    tcx.generics_of(tcx.parent(def_id).unwrap())\n+                }\n+                // Other `DefKind`s don't have generics and would ICE when calling\n+                // `generics_of`.\n+                Res::Def(\n+                    DefKind::Struct\n+                    | DefKind::Union\n+                    | DefKind::Enum\n+                    | DefKind::Trait\n+                    | DefKind::OpaqueTy\n+                    | DefKind::TyAlias\n+                    | DefKind::ForeignTy\n+                    | DefKind::TraitAlias\n+                    | DefKind::AssocTy\n+                    | DefKind::Fn\n+                    | DefKind::AssocFn\n+                    | DefKind::AssocConst\n+                    | DefKind::Impl,\n+                    def_id,\n+                ) => tcx.generics_of(def_id),\n+                Res::Err => {\n+                    tcx.sess.delay_span_bug(tcx.def_span(def_id), \"anon const with Res::Err\");\n+                    return None;\n+                }\n+                _ => {\n+                    // If the user tries to specify generics on a type that does not take them,\n+                    // e.g. `usize<T>`, we may hit this branch, in which case we treat it as if\n+                    // no arguments have been passed. An error should already have been emitted.\n+                    tcx.sess.delay_span_bug(\n+                        tcx.def_span(def_id),\n+                        &format!(\"unexpected anon const res {:?} in path: {:?}\", res, path),\n+                    );\n+                    return None;\n+                }\n+            };\n+\n+            (generics, arg_index)\n+        }\n+        _ => return None,\n+    };\n+\n+    debug!(?parent_node);\n+    debug!(?generics, ?arg_idx);\n+    generics\n+        .params\n+        .iter()\n+        .filter(|param| param.kind.is_ty_or_const())\n+        .nth(match generics.has_self && generics.parent.is_none() {\n+            true => arg_idx + 1,\n+            false => arg_idx,\n+        })\n+        .and_then(|param| match param.kind {\n+            ty::GenericParamDefKind::Const { .. } => {\n+                debug!(?param);\n+                Some(param.def_id)\n             }\n             _ => None,\n-        }\n-    } else {\n-        None\n-    }\n+        })\n }\n \n fn get_path_containing_arg_in_pat<'hir>("}, {"sha": "23c8d7537521819e2c50dea7dbc66ae8a8dcba01", "filename": "src/test/ui/const-generics/generic_arg_infer/infer_arg_and_const_arg.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6c94f99d83fcb0e6c7e152a5cb8d9e3da9b73ce2/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_arg_infer%2Finfer_arg_and_const_arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c94f99d83fcb0e6c7e152a5cb8d9e3da9b73ce2/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_arg_infer%2Finfer_arg_and_const_arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_arg_infer%2Finfer_arg_and_const_arg.rs?ref=6c94f99d83fcb0e6c7e152a5cb8d9e3da9b73ce2", "patch": "@@ -0,0 +1,12 @@\n+// check-pass\n+#![feature(generic_arg_infer)]\n+\n+struct Foo<const N: bool, const M: u8>;\n+struct Bar<const N: u8, const M: u32>;\n+\n+fn main() {\n+    let _: Foo<true, _> = Foo::<_, 1>;\n+    let _: Foo<_, 1> = Foo::<true, _>;\n+    let _: Bar<1, _> = Bar::<_, 300>;\n+    let _: Bar<_, 300> = Bar::<1, _>;\n+}"}, {"sha": "3a2b291d7ba1f127fd71bdbb95c4c8d3ed2c9a6c", "filename": "src/test/ui/const-generics/issues/issue-62878.full.stderr", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/6c94f99d83fcb0e6c7e152a5cb8d9e3da9b73ce2/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-62878.full.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6c94f99d83fcb0e6c7e152a5cb8d9e3da9b73ce2/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-62878.full.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-62878.full.stderr?ref=6c94f99d83fcb0e6c7e152a5cb8d9e3da9b73ce2", "patch": "@@ -4,13 +4,6 @@ error[E0770]: the type of const parameters must not depend on other generic para\n LL | fn foo<const N: usize, const A: [u8; N]>() {}\n    |                                      ^ the type must not depend on the parameter `N`\n \n-error[E0308]: mismatched types\n-  --> $DIR/issue-62878.rs:10:15\n-   |\n-LL |     foo::<_, {[1]}>();\n-   |               ^^^ expected `usize`, found array `[{integer}; 1]`\n-\n-error: aborting due to 2 previous errors\n+error: aborting due to previous error\n \n-Some errors have detailed explanations: E0308, E0770.\n-For more information about an error, try `rustc --explain E0308`.\n+For more information about this error, try `rustc --explain E0770`."}, {"sha": "578ce765b2fb82048309f1be5ef325f467ed28c2", "filename": "src/test/ui/const-generics/issues/issue-62878.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6c94f99d83fcb0e6c7e152a5cb8d9e3da9b73ce2/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-62878.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c94f99d83fcb0e6c7e152a5cb8d9e3da9b73ce2/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-62878.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-62878.rs?ref=6c94f99d83fcb0e6c7e152a5cb8d9e3da9b73ce2", "patch": "@@ -7,6 +7,5 @@ fn foo<const N: usize, const A: [u8; N]>() {}\n //[min]~| ERROR `[u8; _]` is forbidden as the type of a const generic parameter\n \n fn main() {\n-    foo::<_, {[1]}>();\n-    //[full]~^ ERROR mismatched types\n+    foo::<_, { [1] }>();\n }"}]}