{"sha": "5ab73450f820f258205aff069be465a2f72c3c55", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVhYjczNDUwZjgyMGYyNTgyMDVhZmYwNjliZTQ2NWEyZjcyYzNjNTU=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-08-10T18:13:12Z"}, "committer": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-08-10T18:24:43Z"}, "message": "lowering: refactor into item.rs", "tree": {"sha": "a25c0701217d321fea40cde366d24876040a86df", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a25c0701217d321fea40cde366d24876040a86df"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5ab73450f820f258205aff069be465a2f72c3c55", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5ab73450f820f258205aff069be465a2f72c3c55", "html_url": "https://github.com/rust-lang/rust/commit/5ab73450f820f258205aff069be465a2f72c3c55", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5ab73450f820f258205aff069be465a2f72c3c55/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7f522155ddab6437ff472f3563cb42376df056ce", "url": "https://api.github.com/repos/rust-lang/rust/commits/7f522155ddab6437ff472f3563cb42376df056ce", "html_url": "https://github.com/rust-lang/rust/commit/7f522155ddab6437ff472f3563cb42376df056ce"}], "stats": {"total": 2861, "additions": 1444, "deletions": 1417}, "files": [{"sha": "9a4cf4c36cc7f4867f19c740994e94110094f76c", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 3, "deletions": 1417, "changes": 1420, "blob_url": "https://github.com/rust-lang/rust/blob/5ab73450f820f258205aff069be465a2f72c3c55/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ab73450f820f258205aff069be465a2f72c3c55/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=5ab73450f820f258205aff069be465a2f72c3c55", "patch": "@@ -33,6 +33,7 @@\n //! in the HIR, especially for multiple identifiers.\n \n mod expr;\n+mod item;\n \n use crate::dep_graph::DepGraph;\n use crate::hir::{self, ParamName};\n@@ -55,7 +56,7 @@ use rustc_data_structures::indexed_vec::IndexVec;\n use rustc_data_structures::thin_vec::ThinVec;\n use rustc_data_structures::sync::Lrc;\n \n-use std::collections::{BTreeSet, BTreeMap};\n+use std::collections::BTreeMap;\n use std::mem;\n use smallvec::SmallVec;\n use syntax::attr;\n@@ -563,90 +564,11 @@ impl<'a> LoweringContext<'a> {\n             }\n         }\n \n-        struct ItemLowerer<'tcx, 'interner> {\n-            lctx: &'tcx mut LoweringContext<'interner>,\n-        }\n-\n-        impl<'tcx, 'interner> ItemLowerer<'tcx, 'interner> {\n-            fn with_trait_impl_ref<F>(&mut self, trait_impl_ref: &Option<TraitRef>, f: F)\n-            where\n-                F: FnOnce(&mut Self),\n-            {\n-                let old = self.lctx.is_in_trait_impl;\n-                self.lctx.is_in_trait_impl = if let &None = trait_impl_ref {\n-                    false\n-                } else {\n-                    true\n-                };\n-                f(self);\n-                self.lctx.is_in_trait_impl = old;\n-            }\n-        }\n-\n-        impl<'tcx, 'interner> Visitor<'tcx> for ItemLowerer<'tcx, 'interner> {\n-            fn visit_mod(&mut self, m: &'tcx Mod, _s: Span, _attrs: &[Attribute], n: NodeId) {\n-                self.lctx.modules.insert(n, hir::ModuleItems {\n-                    items: BTreeSet::new(),\n-                    trait_items: BTreeSet::new(),\n-                    impl_items: BTreeSet::new(),\n-                });\n-\n-                let old = self.lctx.current_module;\n-                self.lctx.current_module = n;\n-                visit::walk_mod(self, m);\n-                self.lctx.current_module = old;\n-            }\n-\n-            fn visit_item(&mut self, item: &'tcx Item) {\n-                let mut item_hir_id = None;\n-                self.lctx.with_hir_id_owner(item.id, |lctx| {\n-                    if let Some(hir_item) = lctx.lower_item(item) {\n-                        item_hir_id = Some(hir_item.hir_id);\n-                        lctx.insert_item(hir_item);\n-                    }\n-                });\n-\n-                if let Some(hir_id) = item_hir_id {\n-                    self.lctx.with_parent_item_lifetime_defs(hir_id, |this| {\n-                        let this = &mut ItemLowerer { lctx: this };\n-                        if let ItemKind::Impl(.., ref opt_trait_ref, _, _) = item.node {\n-                            this.with_trait_impl_ref(opt_trait_ref, |this| {\n-                                visit::walk_item(this, item)\n-                            });\n-                        } else {\n-                            visit::walk_item(this, item);\n-                        }\n-                    });\n-                }\n-            }\n-\n-            fn visit_trait_item(&mut self, item: &'tcx TraitItem) {\n-                self.lctx.with_hir_id_owner(item.id, |lctx| {\n-                    let hir_item = lctx.lower_trait_item(item);\n-                    let id = hir::TraitItemId { hir_id: hir_item.hir_id };\n-                    lctx.trait_items.insert(id, hir_item);\n-                    lctx.modules.get_mut(&lctx.current_module).unwrap().trait_items.insert(id);\n-                });\n-\n-                visit::walk_trait_item(self, item);\n-            }\n-\n-            fn visit_impl_item(&mut self, item: &'tcx ImplItem) {\n-                self.lctx.with_hir_id_owner(item.id, |lctx| {\n-                    let hir_item = lctx.lower_impl_item(item);\n-                    let id = hir::ImplItemId { hir_id: hir_item.hir_id };\n-                    lctx.impl_items.insert(id, hir_item);\n-                    lctx.modules.get_mut(&lctx.current_module).unwrap().impl_items.insert(id);\n-                });\n-                visit::walk_impl_item(self, item);\n-            }\n-        }\n-\n         self.lower_node_id(CRATE_NODE_ID);\n         debug_assert!(self.node_id_to_hir_id[CRATE_NODE_ID] == hir::CRATE_HIR_ID);\n \n         visit::walk_crate(&mut MiscCollector { lctx: &mut self, hir_id_owner: None }, c);\n-        visit::walk_crate(&mut ItemLowerer { lctx: &mut self }, c);\n+        visit::walk_crate(&mut item::ItemLowerer { lctx: &mut self }, c);\n \n         let module = self.lower_mod(&c.module);\n         let attrs = self.lower_attrs(&c.attrs);\n@@ -785,57 +707,6 @@ impl<'a> LoweringContext<'a> {\n         })\n     }\n \n-    fn generator_movability_for_fn(\n-        &mut self,\n-        decl: &ast::FnDecl,\n-        fn_decl_span: Span,\n-        generator_kind: Option<hir::GeneratorKind>,\n-        movability: Movability,\n-    ) -> Option<hir::GeneratorMovability> {\n-        match generator_kind {\n-            Some(hir::GeneratorKind::Gen) =>  {\n-                if !decl.inputs.is_empty() {\n-                    span_err!(\n-                        self.sess,\n-                        fn_decl_span,\n-                        E0628,\n-                        \"generators cannot have explicit arguments\"\n-                    );\n-                    self.sess.abort_if_errors();\n-                }\n-                Some(match movability {\n-                    Movability::Movable => hir::GeneratorMovability::Movable,\n-                    Movability::Static => hir::GeneratorMovability::Static,\n-                })\n-            },\n-            Some(hir::GeneratorKind::Async) => {\n-                bug!(\"non-`async` closure body turned `async` during lowering\");\n-            },\n-            None => {\n-                if movability == Movability::Static {\n-                    span_err!(\n-                        self.sess,\n-                        fn_decl_span,\n-                        E0697,\n-                        \"closures cannot be static\"\n-                    );\n-                }\n-                None\n-            },\n-        }\n-    }\n-\n-    fn record_body(&mut self, arguments: HirVec<hir::Arg>, value: hir::Expr) -> hir::BodyId {\n-        let body = hir::Body {\n-            generator_kind: self.generator_kind,\n-            arguments,\n-            value,\n-        };\n-        let id = body.id();\n-        self.bodies.insert(id, body);\n-        id\n-    }\n-\n     fn next_id(&mut self) -> hir::HirId {\n         self.lower_node_id(self.sess.next_node_id())\n     }\n@@ -1039,38 +910,6 @@ impl<'a> LoweringContext<'a> {\n         res\n     }\n \n-    // Same as the method above, but accepts `hir::GenericParam`s\n-    // instead of `ast::GenericParam`s.\n-    // This should only be used with generics that have already had their\n-    // in-band lifetimes added. In practice, this means that this function is\n-    // only used when lowering a child item of a trait or impl.\n-    fn with_parent_item_lifetime_defs<T, F>(&mut self,\n-        parent_hir_id: hir::HirId,\n-        f: F\n-    ) -> T where\n-        F: FnOnce(&mut LoweringContext<'_>) -> T,\n-    {\n-        let old_len = self.in_scope_lifetimes.len();\n-\n-        let parent_generics = match self.items.get(&parent_hir_id).unwrap().node {\n-            hir::ItemKind::Impl(_, _, _, ref generics, ..)\n-            | hir::ItemKind::Trait(_, _, ref generics, ..) => {\n-                &generics.params[..]\n-            }\n-            _ => &[],\n-        };\n-        let lt_def_names = parent_generics.iter().filter_map(|param| match param.kind {\n-            hir::GenericParamKind::Lifetime { .. } => Some(param.name.ident().modern()),\n-            _ => None,\n-        });\n-        self.in_scope_lifetimes.extend(lt_def_names);\n-\n-        let res = f(self);\n-\n-        self.in_scope_lifetimes.truncate(old_len);\n-        res\n-    }\n-\n     /// Appends in-band lifetime defs and argument-position `impl\n     /// Trait` defs to the existing set of generics.\n     ///\n@@ -1151,39 +990,6 @@ impl<'a> LoweringContext<'a> {\n         result\n     }\n \n-    fn lower_body(\n-        &mut self,\n-        f: impl FnOnce(&mut LoweringContext<'_>) -> (HirVec<hir::Arg>, hir::Expr),\n-    ) -> hir::BodyId {\n-        let prev_gen_kind = self.generator_kind.take();\n-        let (arguments, result) = f(self);\n-        let body_id = self.record_body(arguments, result);\n-        self.generator_kind = prev_gen_kind;\n-        body_id\n-    }\n-\n-    fn lower_fn_body(\n-        &mut self,\n-        decl: &FnDecl,\n-        body: impl FnOnce(&mut LoweringContext<'_>) -> hir::Expr,\n-    ) -> hir::BodyId {\n-        self.lower_body(|this| (\n-            decl.inputs.iter().map(|x| this.lower_arg(x)).collect(),\n-            body(this),\n-        ))\n-    }\n-\n-    fn lower_fn_body_block(&mut self, decl: &FnDecl, body: &Block) -> hir::BodyId {\n-        self.lower_fn_body(decl, |this| {\n-            let body = this.lower_block(body, false);\n-            this.expr_block(body, ThinVec::new())\n-        })\n-    }\n-\n-    fn lower_const_body(&mut self, expr: &Expr) -> hir::BodyId {\n-        self.lower_body(|this| (hir_vec![], this.lower_expr(expr)))\n-    }\n-\n     fn with_loop_scope<T, F>(&mut self, loop_id: NodeId, f: F) -> T\n     where\n         F: FnOnce(&mut LoweringContext<'_>) -> T,\n@@ -1894,36 +1700,6 @@ impl<'a> LoweringContext<'a> {\n         )\n     }\n \n-    fn lower_foreign_mod(&mut self, fm: &ForeignMod) -> hir::ForeignMod {\n-        hir::ForeignMod {\n-            abi: fm.abi,\n-            items: fm.items\n-                .iter()\n-                .map(|x| self.lower_foreign_item(x))\n-                .collect(),\n-        }\n-    }\n-\n-    fn lower_global_asm(&mut self, ga: &GlobalAsm) -> P<hir::GlobalAsm> {\n-        P(hir::GlobalAsm {\n-            asm: ga.asm,\n-            ctxt: ga.ctxt,\n-        })\n-    }\n-\n-    fn lower_variant(&mut self, v: &Variant) -> hir::Variant {\n-        Spanned {\n-            node: hir::VariantKind {\n-                ident: v.node.ident,\n-                id: self.lower_node_id(v.node.id),\n-                attrs: self.lower_attrs(&v.node.attrs),\n-                data: self.lower_variant_data(&v.node.data),\n-                disr_expr: v.node.disr_expr.as_ref().map(|e| self.lower_anon_const(e)),\n-            },\n-            span: v.span,\n-        }\n-    }\n-\n     fn lower_qpath(\n         &mut self,\n         id: NodeId,\n@@ -2857,169 +2633,6 @@ impl<'a> LoweringContext<'a> {\n         }\n     }\n \n-    fn lower_generics(\n-        &mut self,\n-        generics: &Generics,\n-        itctx: ImplTraitContext<'_>)\n-        -> hir::Generics\n-    {\n-        // Collect `?Trait` bounds in where clause and move them to parameter definitions.\n-        // FIXME: this could probably be done with less rightward drift. It also looks like two\n-        // control paths where `report_error` is called are the only paths that advance to after the\n-        // match statement, so the error reporting could probably just be moved there.\n-        let mut add_bounds: NodeMap<Vec<_>> = Default::default();\n-        for pred in &generics.where_clause.predicates {\n-            if let WherePredicate::BoundPredicate(ref bound_pred) = *pred {\n-                'next_bound: for bound in &bound_pred.bounds {\n-                    if let GenericBound::Trait(_, TraitBoundModifier::Maybe) = *bound {\n-                        let report_error = |this: &mut Self| {\n-                            this.diagnostic().span_err(\n-                                bound_pred.bounded_ty.span,\n-                                \"`?Trait` bounds are only permitted at the \\\n-                                 point where a type parameter is declared\",\n-                            );\n-                        };\n-                        // Check if the where clause type is a plain type parameter.\n-                        match bound_pred.bounded_ty.node {\n-                            TyKind::Path(None, ref path)\n-                                if path.segments.len() == 1\n-                                    && bound_pred.bound_generic_params.is_empty() =>\n-                            {\n-                                if let Some(Res::Def(DefKind::TyParam, def_id)) = self.resolver\n-                                    .get_partial_res(bound_pred.bounded_ty.id)\n-                                    .map(|d| d.base_res())\n-                                {\n-                                    if let Some(node_id) =\n-                                        self.resolver.definitions().as_local_node_id(def_id)\n-                                    {\n-                                        for param in &generics.params {\n-                                            match param.kind {\n-                                                GenericParamKind::Type { .. } => {\n-                                                    if node_id == param.id {\n-                                                        add_bounds.entry(param.id)\n-                                                            .or_default()\n-                                                            .push(bound.clone());\n-                                                        continue 'next_bound;\n-                                                    }\n-                                                }\n-                                                _ => {}\n-                                            }\n-                                        }\n-                                    }\n-                                }\n-                                report_error(self)\n-                            }\n-                            _ => report_error(self),\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-\n-        hir::Generics {\n-            params: self.lower_generic_params(&generics.params, &add_bounds, itctx),\n-            where_clause: self.lower_where_clause(&generics.where_clause),\n-            span: generics.span,\n-        }\n-    }\n-\n-    fn lower_where_clause(&mut self, wc: &WhereClause) -> hir::WhereClause {\n-        self.with_anonymous_lifetime_mode(\n-            AnonymousLifetimeMode::ReportError,\n-            |this| {\n-                hir::WhereClause {\n-                    predicates: wc.predicates\n-                        .iter()\n-                        .map(|predicate| this.lower_where_predicate(predicate))\n-                        .collect(),\n-                    span: wc.span,\n-                }\n-            },\n-        )\n-    }\n-\n-    fn lower_where_predicate(&mut self, pred: &WherePredicate) -> hir::WherePredicate {\n-        match *pred {\n-            WherePredicate::BoundPredicate(WhereBoundPredicate {\n-                ref bound_generic_params,\n-                ref bounded_ty,\n-                ref bounds,\n-                span,\n-            }) => {\n-                self.with_in_scope_lifetime_defs(\n-                    &bound_generic_params,\n-                    |this| {\n-                        hir::WherePredicate::BoundPredicate(hir::WhereBoundPredicate {\n-                            bound_generic_params: this.lower_generic_params(\n-                                bound_generic_params,\n-                                &NodeMap::default(),\n-                                ImplTraitContext::disallowed(),\n-                            ),\n-                            bounded_ty: this.lower_ty(bounded_ty, ImplTraitContext::disallowed()),\n-                            bounds: bounds\n-                                .iter()\n-                                .filter_map(|bound| match *bound {\n-                                    // Ignore `?Trait` bounds.\n-                                    // They were copied into type parameters already.\n-                                    GenericBound::Trait(_, TraitBoundModifier::Maybe) => None,\n-                                    _ => Some(this.lower_param_bound(\n-                                        bound,\n-                                        ImplTraitContext::disallowed(),\n-                                    )),\n-                                })\n-                                .collect(),\n-                            span,\n-                        })\n-                    },\n-                )\n-            }\n-            WherePredicate::RegionPredicate(WhereRegionPredicate {\n-                ref lifetime,\n-                ref bounds,\n-                span,\n-            }) => hir::WherePredicate::RegionPredicate(hir::WhereRegionPredicate {\n-                span,\n-                lifetime: self.lower_lifetime(lifetime),\n-                bounds: self.lower_param_bounds(bounds, ImplTraitContext::disallowed()),\n-            }),\n-            WherePredicate::EqPredicate(WhereEqPredicate {\n-                id,\n-                ref lhs_ty,\n-                ref rhs_ty,\n-                span,\n-            }) => {\n-                hir::WherePredicate::EqPredicate(hir::WhereEqPredicate {\n-                    hir_id: self.lower_node_id(id),\n-                    lhs_ty: self.lower_ty(lhs_ty, ImplTraitContext::disallowed()),\n-                    rhs_ty: self.lower_ty(rhs_ty, ImplTraitContext::disallowed()),\n-                    span,\n-                })\n-            },\n-        }\n-    }\n-\n-    fn lower_variant_data(&mut self, vdata: &VariantData) -> hir::VariantData {\n-        match *vdata {\n-            VariantData::Struct(ref fields, recovered) => hir::VariantData::Struct(\n-                fields.iter().enumerate().map(|f| self.lower_struct_field(f)).collect(),\n-                recovered,\n-            ),\n-            VariantData::Tuple(ref fields, id) => {\n-                hir::VariantData::Tuple(\n-                    fields\n-                        .iter()\n-                        .enumerate()\n-                        .map(|f| self.lower_struct_field(f))\n-                        .collect(),\n-                    self.lower_node_id(id),\n-                )\n-            },\n-            VariantData::Unit(id) => {\n-                hir::VariantData::Unit(self.lower_node_id(id))\n-            },\n-        }\n-    }\n-\n     fn lower_trait_ref(&mut self, p: &TraitRef, itctx: ImplTraitContext<'_>) -> hir::TraitRef {\n         let path = match self.lower_qpath(p.ref_id, &None, &p.path, ParamMode::Explicit, itctx) {\n             hir::QPath::Resolved(None, path) => path,\n@@ -3053,33 +2666,6 @@ impl<'a> LoweringContext<'a> {\n         }\n     }\n \n-    fn lower_struct_field(&mut self, (index, f): (usize, &StructField)) -> hir::StructField {\n-        let ty = if let TyKind::Path(ref qself, ref path) = f.ty.node {\n-            let t = self.lower_path_ty(\n-                &f.ty,\n-                qself,\n-                path,\n-                ParamMode::ExplicitNamed, // no `'_` in declarations (Issue #61124)\n-                ImplTraitContext::disallowed()\n-            );\n-            P(t)\n-        } else {\n-            self.lower_ty(&f.ty, ImplTraitContext::disallowed())\n-        };\n-        hir::StructField {\n-            span: f.span,\n-            hir_id: self.lower_node_id(f.id),\n-            ident: match f.ident {\n-                Some(ident) => ident,\n-                // FIXME(jseyfried): positional field hygiene.\n-                None => Ident::new(sym::integer(index), f.span),\n-            },\n-            vis: self.lower_visibility(&f.vis, None),\n-            ty,\n-            attrs: self.lower_attrs(&f.attrs),\n-        }\n-    }\n-\n     fn lower_mt(&mut self, mt: &MutTy, itctx: ImplTraitContext<'_>) -> hir::MutTy {\n         hir::MutTy {\n             ty: self.lower_ty(&mt.ty, itctx),\n@@ -3126,950 +2712,6 @@ impl<'a> LoweringContext<'a> {\n         self.lower_block_with_stmts(b, targeted_by_break, vec![])\n     }\n \n-    fn lower_maybe_async_body(\n-        &mut self,\n-        decl: &FnDecl,\n-        asyncness: IsAsync,\n-        body: &Block,\n-    ) -> hir::BodyId {\n-        let closure_id = match asyncness {\n-            IsAsync::Async { closure_id, .. } => closure_id,\n-            IsAsync::NotAsync => return self.lower_fn_body_block(decl, body),\n-        };\n-\n-        self.lower_body(|this| {\n-            let mut arguments: Vec<hir::Arg> = Vec::new();\n-            let mut statements: Vec<hir::Stmt> = Vec::new();\n-\n-            // Async function arguments are lowered into the closure body so that they are\n-            // captured and so that the drop order matches the equivalent non-async functions.\n-            //\n-            // from:\n-            //\n-            //     async fn foo(<pattern>: <ty>, <pattern>: <ty>, <pattern>: <ty>) {\n-            //       async move {\n-            //       }\n-            //     }\n-            //\n-            // into:\n-            //\n-            //     fn foo(__arg0: <ty>, __arg1: <ty>, __arg2: <ty>) {\n-            //       async move {\n-            //         let __arg2 = __arg2;\n-            //         let <pattern> = __arg2;\n-            //         let __arg1 = __arg1;\n-            //         let <pattern> = __arg1;\n-            //         let __arg0 = __arg0;\n-            //         let <pattern> = __arg0;\n-            //       }\n-            //     }\n-            //\n-            // If `<pattern>` is a simple ident, then it is lowered to a single\n-            // `let <pattern> = <pattern>;` statement as an optimization.\n-            for (index, argument) in decl.inputs.iter().enumerate() {\n-                let argument = this.lower_arg(argument);\n-                let span = argument.pat.span;\n-\n-                // Check if this is a binding pattern, if so, we can optimize and avoid adding a\n-                // `let <pat> = __argN;` statement. In this case, we do not rename the argument.\n-                let (ident, is_simple_argument) = match argument.pat.node {\n-                    hir::PatKind::Binding(hir::BindingAnnotation::Unannotated, _, ident, _) =>\n-                        (ident, true),\n-                    _ => {\n-                        // Replace the ident for bindings that aren't simple.\n-                        let name = format!(\"__arg{}\", index);\n-                        let ident = Ident::from_str(&name);\n-\n-                        (ident, false)\n-                    },\n-                };\n-\n-                let desugared_span =\n-                    this.mark_span_with_reason(DesugaringKind::Async, span, None);\n-\n-                // Construct an argument representing `__argN: <ty>` to replace the argument of the\n-                // async function.\n-                //\n-                // If this is the simple case, this argument will end up being the same as the\n-                // original argument, but with a different pattern id.\n-                let mut stmt_attrs = ThinVec::new();\n-                stmt_attrs.extend(argument.attrs.iter().cloned());\n-                let (new_argument_pat, new_argument_id) = this.pat_ident(desugared_span, ident);\n-                let new_argument = hir::Arg {\n-                    attrs: argument.attrs,\n-                    hir_id: argument.hir_id,\n-                    pat: new_argument_pat,\n-                    span: argument.span,\n-                };\n-\n-\n-                if is_simple_argument {\n-                    // If this is the simple case, then we only insert one statement that is\n-                    // `let <pat> = <pat>;`. We re-use the original argument's pattern so that\n-                    // `HirId`s are densely assigned.\n-                    let expr = this.expr_ident(desugared_span, ident, new_argument_id);\n-                    let stmt = this.stmt_let_pat(\n-                        stmt_attrs,\n-                        desugared_span,\n-                        Some(P(expr)),\n-                        argument.pat,\n-                        hir::LocalSource::AsyncFn\n-                    );\n-                    statements.push(stmt);\n-                } else {\n-                    // If this is not the simple case, then we construct two statements:\n-                    //\n-                    // ```\n-                    // let __argN = __argN;\n-                    // let <pat> = __argN;\n-                    // ```\n-                    //\n-                    // The first statement moves the argument into the closure and thus ensures\n-                    // that the drop order is correct.\n-                    //\n-                    // The second statement creates the bindings that the user wrote.\n-\n-                    // Construct the `let mut __argN = __argN;` statement. It must be a mut binding\n-                    // because the user may have specified a `ref mut` binding in the next\n-                    // statement.\n-                    let (move_pat, move_id) = this.pat_ident_binding_mode(\n-                        desugared_span, ident, hir::BindingAnnotation::Mutable);\n-                    let move_expr = this.expr_ident(desugared_span, ident, new_argument_id);\n-                    let move_stmt = this.stmt_let_pat(\n-                        ThinVec::new(),\n-                        desugared_span,\n-                        Some(P(move_expr)),\n-                        move_pat,\n-                        hir::LocalSource::AsyncFn\n-                    );\n-\n-                    // Construct the `let <pat> = __argN;` statement. We re-use the original\n-                    // argument's pattern so that `HirId`s are densely assigned.\n-                    let pattern_expr = this.expr_ident(desugared_span, ident, move_id);\n-                    let pattern_stmt = this.stmt_let_pat(\n-                        stmt_attrs,\n-                        desugared_span,\n-                        Some(P(pattern_expr)),\n-                        argument.pat,\n-                        hir::LocalSource::AsyncFn\n-                    );\n-\n-                    statements.push(move_stmt);\n-                    statements.push(pattern_stmt);\n-                };\n-\n-                arguments.push(new_argument);\n-            }\n-\n-            let async_expr = this.make_async_expr(\n-                CaptureBy::Value, closure_id, None, body.span,\n-                |this| {\n-                    let body = this.lower_block_with_stmts(body, false, statements);\n-                    this.expr_block(body, ThinVec::new())\n-                });\n-            (HirVec::from(arguments), this.expr(body.span, async_expr, ThinVec::new()))\n-        })\n-    }\n-\n-    fn lower_item_kind(\n-        &mut self,\n-        id: NodeId,\n-        ident: &mut Ident,\n-        attrs: &hir::HirVec<Attribute>,\n-        vis: &mut hir::Visibility,\n-        i: &ItemKind,\n-    ) -> hir::ItemKind {\n-        match *i {\n-            ItemKind::ExternCrate(orig_name) => hir::ItemKind::ExternCrate(orig_name),\n-            ItemKind::Use(ref use_tree) => {\n-                // Start with an empty prefix.\n-                let prefix = Path {\n-                    segments: vec![],\n-                    span: use_tree.span,\n-                };\n-\n-                self.lower_use_tree(use_tree, &prefix, id, vis, ident, attrs)\n-            }\n-            ItemKind::Static(ref t, m, ref e) => {\n-                hir::ItemKind::Static(\n-                    self.lower_ty(\n-                        t,\n-                        if self.sess.features_untracked().impl_trait_in_bindings {\n-                            ImplTraitContext::OpaqueTy(None)\n-                        } else {\n-                            ImplTraitContext::Disallowed(ImplTraitPosition::Binding)\n-                        }\n-                    ),\n-                    self.lower_mutability(m),\n-                    self.lower_const_body(e),\n-                )\n-            }\n-            ItemKind::Const(ref t, ref e) => {\n-                hir::ItemKind::Const(\n-                    self.lower_ty(\n-                        t,\n-                        if self.sess.features_untracked().impl_trait_in_bindings {\n-                            ImplTraitContext::OpaqueTy(None)\n-                        } else {\n-                            ImplTraitContext::Disallowed(ImplTraitPosition::Binding)\n-                        }\n-                    ),\n-                    self.lower_const_body(e)\n-                )\n-            }\n-            ItemKind::Fn(ref decl, header, ref generics, ref body) => {\n-                let fn_def_id = self.resolver.definitions().local_def_id(id);\n-                self.with_new_scopes(|this| {\n-                    this.current_item = Some(ident.span);\n-\n-                    // Note: we don't need to change the return type from `T` to\n-                    // `impl Future<Output = T>` here because lower_body\n-                    // only cares about the input argument patterns in the function\n-                    // declaration (decl), not the return types.\n-                    let body_id = this.lower_maybe_async_body(&decl, header.asyncness.node, body);\n-\n-                    let (generics, fn_decl) = this.add_in_band_defs(\n-                        generics,\n-                        fn_def_id,\n-                        AnonymousLifetimeMode::PassThrough,\n-                        |this, idty| this.lower_fn_decl(\n-                            &decl,\n-                            Some((fn_def_id, idty)),\n-                            true,\n-                            header.asyncness.node.opt_return_id()\n-                        ),\n-                    );\n-\n-                    hir::ItemKind::Fn(\n-                        fn_decl,\n-                        this.lower_fn_header(header),\n-                        generics,\n-                        body_id,\n-                    )\n-                })\n-            }\n-            ItemKind::Mod(ref m) => hir::ItemKind::Mod(self.lower_mod(m)),\n-            ItemKind::ForeignMod(ref nm) => hir::ItemKind::ForeignMod(self.lower_foreign_mod(nm)),\n-            ItemKind::GlobalAsm(ref ga) => hir::ItemKind::GlobalAsm(self.lower_global_asm(ga)),\n-            ItemKind::TyAlias(ref t, ref generics) => hir::ItemKind::TyAlias(\n-                self.lower_ty(t, ImplTraitContext::disallowed()),\n-                self.lower_generics(generics, ImplTraitContext::disallowed()),\n-            ),\n-            ItemKind::OpaqueTy(ref b, ref generics) => hir::ItemKind::OpaqueTy(\n-                hir::OpaqueTy {\n-                    generics: self.lower_generics(generics,\n-                        ImplTraitContext::OpaqueTy(None)),\n-                    bounds: self.lower_param_bounds(b,\n-                        ImplTraitContext::OpaqueTy(None)),\n-                    impl_trait_fn: None,\n-                    origin: hir::OpaqueTyOrigin::TypeAlias,\n-                },\n-            ),\n-            ItemKind::Enum(ref enum_definition, ref generics) => {\n-                hir::ItemKind::Enum(\n-                    hir::EnumDef {\n-                        variants: enum_definition\n-                            .variants\n-                            .iter()\n-                            .map(|x| self.lower_variant(x))\n-                            .collect(),\n-                    },\n-                    self.lower_generics(generics, ImplTraitContext::disallowed()),\n-                )\n-            },\n-            ItemKind::Struct(ref struct_def, ref generics) => {\n-                let struct_def = self.lower_variant_data(struct_def);\n-                hir::ItemKind::Struct(\n-                    struct_def,\n-                    self.lower_generics(generics, ImplTraitContext::disallowed()),\n-                )\n-            }\n-            ItemKind::Union(ref vdata, ref generics) => {\n-                let vdata = self.lower_variant_data(vdata);\n-                hir::ItemKind::Union(\n-                    vdata,\n-                    self.lower_generics(generics, ImplTraitContext::disallowed()),\n-                )\n-            }\n-            ItemKind::Impl(\n-                unsafety,\n-                polarity,\n-                defaultness,\n-                ref ast_generics,\n-                ref trait_ref,\n-                ref ty,\n-                ref impl_items,\n-            ) => {\n-                let def_id = self.resolver.definitions().local_def_id(id);\n-\n-                // Lower the \"impl header\" first. This ordering is important\n-                // for in-band lifetimes! Consider `'a` here:\n-                //\n-                //     impl Foo<'a> for u32 {\n-                //         fn method(&'a self) { .. }\n-                //     }\n-                //\n-                // Because we start by lowering the `Foo<'a> for u32`\n-                // part, we will add `'a` to the list of generics on\n-                // the impl. When we then encounter it later in the\n-                // method, it will not be considered an in-band\n-                // lifetime to be added, but rather a reference to a\n-                // parent lifetime.\n-                let lowered_trait_impl_id = self.lower_node_id(id);\n-                let (generics, (trait_ref, lowered_ty)) = self.add_in_band_defs(\n-                    ast_generics,\n-                    def_id,\n-                    AnonymousLifetimeMode::CreateParameter,\n-                    |this, _| {\n-                        let trait_ref = trait_ref.as_ref().map(|trait_ref| {\n-                            this.lower_trait_ref(trait_ref, ImplTraitContext::disallowed())\n-                        });\n-\n-                        if let Some(ref trait_ref) = trait_ref {\n-                            if let Res::Def(DefKind::Trait, def_id) = trait_ref.path.res {\n-                                this.trait_impls.entry(def_id).or_default().push(\n-                                    lowered_trait_impl_id);\n-                            }\n-                        }\n-\n-                        let lowered_ty = this.lower_ty(ty, ImplTraitContext::disallowed());\n-\n-                        (trait_ref, lowered_ty)\n-                    },\n-                );\n-\n-                let new_impl_items = self.with_in_scope_lifetime_defs(\n-                    &ast_generics.params,\n-                    |this| {\n-                        impl_items\n-                            .iter()\n-                            .map(|item| this.lower_impl_item_ref(item))\n-                            .collect()\n-                    },\n-                );\n-\n-                hir::ItemKind::Impl(\n-                    self.lower_unsafety(unsafety),\n-                    self.lower_impl_polarity(polarity),\n-                    self.lower_defaultness(defaultness, true /* [1] */),\n-                    generics,\n-                    trait_ref,\n-                    lowered_ty,\n-                    new_impl_items,\n-                )\n-            }\n-            ItemKind::Trait(is_auto, unsafety, ref generics, ref bounds, ref items) => {\n-                let bounds = self.lower_param_bounds(bounds, ImplTraitContext::disallowed());\n-                let items = items\n-                    .iter()\n-                    .map(|item| self.lower_trait_item_ref(item))\n-                    .collect();\n-                hir::ItemKind::Trait(\n-                    self.lower_is_auto(is_auto),\n-                    self.lower_unsafety(unsafety),\n-                    self.lower_generics(generics, ImplTraitContext::disallowed()),\n-                    bounds,\n-                    items,\n-                )\n-            }\n-            ItemKind::TraitAlias(ref generics, ref bounds) => hir::ItemKind::TraitAlias(\n-                self.lower_generics(generics, ImplTraitContext::disallowed()),\n-                self.lower_param_bounds(bounds, ImplTraitContext::disallowed()),\n-            ),\n-            ItemKind::MacroDef(..)\n-            | ItemKind::Mac(..) => bug!(\"`TyMac` should have been expanded by now\"),\n-        }\n-\n-        // [1] `defaultness.has_value()` is never called for an `impl`, always `true` in order to\n-        //     not cause an assertion failure inside the `lower_defaultness` function.\n-    }\n-\n-    fn lower_use_tree(\n-        &mut self,\n-        tree: &UseTree,\n-        prefix: &Path,\n-        id: NodeId,\n-        vis: &mut hir::Visibility,\n-        ident: &mut Ident,\n-        attrs: &hir::HirVec<Attribute>,\n-    ) -> hir::ItemKind {\n-        debug!(\"lower_use_tree(tree={:?})\", tree);\n-        debug!(\"lower_use_tree: vis = {:?}\", vis);\n-\n-        let path = &tree.prefix;\n-        let segments = prefix\n-            .segments\n-            .iter()\n-            .chain(path.segments.iter())\n-            .cloned()\n-            .collect();\n-\n-        match tree.kind {\n-            UseTreeKind::Simple(rename, id1, id2) => {\n-                *ident = tree.ident();\n-\n-                // First, apply the prefix to the path.\n-                let mut path = Path {\n-                    segments,\n-                    span: path.span,\n-                };\n-\n-                // Correctly resolve `self` imports.\n-                if path.segments.len() > 1\n-                    && path.segments.last().unwrap().ident.name == kw::SelfLower\n-                {\n-                    let _ = path.segments.pop();\n-                    if rename.is_none() {\n-                        *ident = path.segments.last().unwrap().ident;\n-                    }\n-                }\n-\n-                let mut resolutions = self.expect_full_res_from_use(id);\n-                // We want to return *something* from this function, so hold onto the first item\n-                // for later.\n-                let ret_res = self.lower_res(resolutions.next().unwrap_or(Res::Err));\n-\n-                // Here, we are looping over namespaces, if they exist for the definition\n-                // being imported. We only handle type and value namespaces because we\n-                // won't be dealing with macros in the rest of the compiler.\n-                // Essentially a single `use` which imports two names is desugared into\n-                // two imports.\n-                for (res, &new_node_id) in resolutions.zip([id1, id2].iter()) {\n-                    let ident = *ident;\n-                    let mut path = path.clone();\n-                    for seg in &mut path.segments {\n-                        seg.id = self.sess.next_node_id();\n-                    }\n-                    let span = path.span;\n-\n-                    self.with_hir_id_owner(new_node_id, |this| {\n-                        let new_id = this.lower_node_id(new_node_id);\n-                        let res = this.lower_res(res);\n-                        let path =\n-                            this.lower_path_extra(res, &path, ParamMode::Explicit, None);\n-                        let item = hir::ItemKind::Use(P(path), hir::UseKind::Single);\n-                        let vis = this.rebuild_vis(&vis);\n-\n-                        this.insert_item(\n-                            hir::Item {\n-                                hir_id: new_id,\n-                                ident,\n-                                attrs: attrs.into_iter().cloned().collect(),\n-                                node: item,\n-                                vis,\n-                                span,\n-                            },\n-                        );\n-                    });\n-                }\n-\n-                let path =\n-                    P(self.lower_path_extra(ret_res, &path, ParamMode::Explicit, None));\n-                hir::ItemKind::Use(path, hir::UseKind::Single)\n-            }\n-            UseTreeKind::Glob => {\n-                let path = P(self.lower_path(\n-                    id,\n-                    &Path {\n-                        segments,\n-                        span: path.span,\n-                    },\n-                    ParamMode::Explicit,\n-                ));\n-                hir::ItemKind::Use(path, hir::UseKind::Glob)\n-            }\n-            UseTreeKind::Nested(ref trees) => {\n-                // Nested imports are desugared into simple imports.\n-                // So, if we start with\n-                //\n-                // ```\n-                // pub(x) use foo::{a, b};\n-                // ```\n-                //\n-                // we will create three items:\n-                //\n-                // ```\n-                // pub(x) use foo::a;\n-                // pub(x) use foo::b;\n-                // pub(x) use foo::{}; // <-- this is called the `ListStem`\n-                // ```\n-                //\n-                // The first two are produced by recursively invoking\n-                // `lower_use_tree` (and indeed there may be things\n-                // like `use foo::{a::{b, c}}` and so forth).  They\n-                // wind up being directly added to\n-                // `self.items`. However, the structure of this\n-                // function also requires us to return one item, and\n-                // for that we return the `{}` import (called the\n-                // `ListStem`).\n-\n-                let prefix = Path {\n-                    segments,\n-                    span: prefix.span.to(path.span),\n-                };\n-\n-                // Add all the nested `PathListItem`s to the HIR.\n-                for &(ref use_tree, id) in trees {\n-                    let new_hir_id = self.lower_node_id(id);\n-\n-                    let mut prefix = prefix.clone();\n-\n-                    // Give the segments new node-ids since they are being cloned.\n-                    for seg in &mut prefix.segments {\n-                        seg.id = self.sess.next_node_id();\n-                    }\n-\n-                    // Each `use` import is an item and thus are owners of the\n-                    // names in the path. Up to this point the nested import is\n-                    // the current owner, since we want each desugared import to\n-                    // own its own names, we have to adjust the owner before\n-                    // lowering the rest of the import.\n-                    self.with_hir_id_owner(id, |this| {\n-                        let mut vis = this.rebuild_vis(&vis);\n-                        let mut ident = *ident;\n-\n-                        let item = this.lower_use_tree(use_tree,\n-                                                       &prefix,\n-                                                       id,\n-                                                       &mut vis,\n-                                                       &mut ident,\n-                                                       attrs);\n-\n-                        this.insert_item(\n-                            hir::Item {\n-                                hir_id: new_hir_id,\n-                                ident,\n-                                attrs: attrs.into_iter().cloned().collect(),\n-                                node: item,\n-                                vis,\n-                                span: use_tree.span,\n-                            },\n-                        );\n-                    });\n-                }\n-\n-                // Subtle and a bit hacky: we lower the privacy level\n-                // of the list stem to \"private\" most of the time, but\n-                // not for \"restricted\" paths. The key thing is that\n-                // we don't want it to stay as `pub` (with no caveats)\n-                // because that affects rustdoc and also the lints\n-                // about `pub` items. But we can't *always* make it\n-                // private -- particularly not for restricted paths --\n-                // because it contains node-ids that would then be\n-                // unused, failing the check that HirIds are \"densely\n-                // assigned\".\n-                match vis.node {\n-                    hir::VisibilityKind::Public |\n-                    hir::VisibilityKind::Crate(_) |\n-                    hir::VisibilityKind::Inherited => {\n-                        *vis = respan(prefix.span.shrink_to_lo(), hir::VisibilityKind::Inherited);\n-                    }\n-                    hir::VisibilityKind::Restricted { .. } => {\n-                        // Do nothing here, as described in the comment on the match.\n-                    }\n-                }\n-\n-                let res = self.expect_full_res_from_use(id).next().unwrap_or(Res::Err);\n-                let res = self.lower_res(res);\n-                let path = P(self.lower_path_extra(res, &prefix, ParamMode::Explicit, None));\n-                hir::ItemKind::Use(path, hir::UseKind::ListStem)\n-            }\n-        }\n-    }\n-\n-    /// Paths like the visibility path in `pub(super) use foo::{bar, baz}` are repeated\n-    /// many times in the HIR tree; for each occurrence, we need to assign distinct\n-    /// `NodeId`s. (See, e.g., #56128.)\n-    fn rebuild_use_path(&mut self, path: &hir::Path) -> hir::Path {\n-        debug!(\"rebuild_use_path(path = {:?})\", path);\n-        let segments = path.segments.iter().map(|seg| hir::PathSegment {\n-            ident: seg.ident,\n-            hir_id: seg.hir_id.map(|_| self.next_id()),\n-            res: seg.res,\n-            args: None,\n-            infer_args: seg.infer_args,\n-        }).collect();\n-        hir::Path {\n-            span: path.span,\n-            res: path.res,\n-            segments,\n-        }\n-    }\n-\n-    fn rebuild_vis(&mut self, vis: &hir::Visibility) -> hir::Visibility {\n-        let vis_kind = match vis.node {\n-            hir::VisibilityKind::Public => hir::VisibilityKind::Public,\n-            hir::VisibilityKind::Crate(sugar) => hir::VisibilityKind::Crate(sugar),\n-            hir::VisibilityKind::Inherited => hir::VisibilityKind::Inherited,\n-            hir::VisibilityKind::Restricted { ref path, hir_id: _ } => {\n-                hir::VisibilityKind::Restricted {\n-                    path: P(self.rebuild_use_path(path)),\n-                    hir_id: self.next_id(),\n-                }\n-            }\n-        };\n-        respan(vis.span, vis_kind)\n-    }\n-\n-    fn lower_trait_item(&mut self, i: &TraitItem) -> hir::TraitItem {\n-        let trait_item_def_id = self.resolver.definitions().local_def_id(i.id);\n-\n-        let (generics, node) = match i.node {\n-            TraitItemKind::Const(ref ty, ref default) => (\n-                self.lower_generics(&i.generics, ImplTraitContext::disallowed()),\n-                hir::TraitItemKind::Const(\n-                    self.lower_ty(ty, ImplTraitContext::disallowed()),\n-                    default\n-                        .as_ref()\n-                        .map(|x| self.lower_const_body(x)),\n-                ),\n-            ),\n-            TraitItemKind::Method(ref sig, None) => {\n-                let names = self.lower_fn_args_to_names(&sig.decl);\n-                let (generics, sig) = self.lower_method_sig(\n-                    &i.generics,\n-                    sig,\n-                    trait_item_def_id,\n-                    false,\n-                    None,\n-                );\n-                (generics, hir::TraitItemKind::Method(sig, hir::TraitMethod::Required(names)))\n-            }\n-            TraitItemKind::Method(ref sig, Some(ref body)) => {\n-                let body_id = self.lower_fn_body_block(&sig.decl, body);\n-                let (generics, sig) = self.lower_method_sig(\n-                    &i.generics,\n-                    sig,\n-                    trait_item_def_id,\n-                    false,\n-                    None,\n-                );\n-                (generics, hir::TraitItemKind::Method(sig, hir::TraitMethod::Provided(body_id)))\n-            }\n-            TraitItemKind::Type(ref bounds, ref default) => {\n-                let generics = self.lower_generics(&i.generics, ImplTraitContext::disallowed());\n-                let node = hir::TraitItemKind::Type(\n-                    self.lower_param_bounds(bounds, ImplTraitContext::disallowed()),\n-                    default\n-                        .as_ref()\n-                        .map(|x| self.lower_ty(x, ImplTraitContext::disallowed())),\n-                );\n-\n-                (generics, node)\n-            },\n-            TraitItemKind::Macro(..) => bug!(\"macro item shouldn't exist at this point\"),\n-        };\n-\n-        hir::TraitItem {\n-            hir_id: self.lower_node_id(i.id),\n-            ident: i.ident,\n-            attrs: self.lower_attrs(&i.attrs),\n-            generics,\n-            node,\n-            span: i.span,\n-        }\n-    }\n-\n-    fn lower_trait_item_ref(&mut self, i: &TraitItem) -> hir::TraitItemRef {\n-        let (kind, has_default) = match i.node {\n-            TraitItemKind::Const(_, ref default) => {\n-                (hir::AssocItemKind::Const, default.is_some())\n-            }\n-            TraitItemKind::Type(_, ref default) => {\n-                (hir::AssocItemKind::Type, default.is_some())\n-            }\n-            TraitItemKind::Method(ref sig, ref default) => (\n-                hir::AssocItemKind::Method {\n-                    has_self: sig.decl.has_self(),\n-                },\n-                default.is_some(),\n-            ),\n-            TraitItemKind::Macro(..) => unimplemented!(),\n-        };\n-        hir::TraitItemRef {\n-            id: hir::TraitItemId { hir_id: self.lower_node_id(i.id) },\n-            ident: i.ident,\n-            span: i.span,\n-            defaultness: self.lower_defaultness(Defaultness::Default, has_default),\n-            kind,\n-        }\n-    }\n-\n-    fn lower_impl_item(&mut self, i: &ImplItem) -> hir::ImplItem {\n-        let impl_item_def_id = self.resolver.definitions().local_def_id(i.id);\n-\n-        let (generics, node) = match i.node {\n-            ImplItemKind::Const(ref ty, ref expr) => (\n-                self.lower_generics(&i.generics, ImplTraitContext::disallowed()),\n-                hir::ImplItemKind::Const(\n-                    self.lower_ty(ty, ImplTraitContext::disallowed()),\n-                    self.lower_const_body(expr),\n-                ),\n-            ),\n-            ImplItemKind::Method(ref sig, ref body) => {\n-                self.current_item = Some(i.span);\n-                let body_id = self.lower_maybe_async_body(\n-                    &sig.decl, sig.header.asyncness.node, body\n-                );\n-                let impl_trait_return_allow = !self.is_in_trait_impl;\n-                let (generics, sig) = self.lower_method_sig(\n-                    &i.generics,\n-                    sig,\n-                    impl_item_def_id,\n-                    impl_trait_return_allow,\n-                    sig.header.asyncness.node.opt_return_id(),\n-                );\n-\n-                (generics, hir::ImplItemKind::Method(sig, body_id))\n-            }\n-            ImplItemKind::TyAlias(ref ty) => (\n-                self.lower_generics(&i.generics, ImplTraitContext::disallowed()),\n-                hir::ImplItemKind::TyAlias(self.lower_ty(ty, ImplTraitContext::disallowed())),\n-            ),\n-            ImplItemKind::OpaqueTy(ref bounds) => (\n-                self.lower_generics(&i.generics, ImplTraitContext::disallowed()),\n-                hir::ImplItemKind::OpaqueTy(\n-                    self.lower_param_bounds(bounds, ImplTraitContext::disallowed()),\n-                ),\n-            ),\n-            ImplItemKind::Macro(..) => bug!(\"`TyMac` should have been expanded by now\"),\n-        };\n-\n-        hir::ImplItem {\n-            hir_id: self.lower_node_id(i.id),\n-            ident: i.ident,\n-            attrs: self.lower_attrs(&i.attrs),\n-            generics,\n-            vis: self.lower_visibility(&i.vis, None),\n-            defaultness: self.lower_defaultness(i.defaultness, true /* [1] */),\n-            node,\n-            span: i.span,\n-        }\n-\n-        // [1] since `default impl` is not yet implemented, this is always true in impls\n-    }\n-\n-    fn lower_impl_item_ref(&mut self, i: &ImplItem) -> hir::ImplItemRef {\n-        hir::ImplItemRef {\n-            id: hir::ImplItemId { hir_id: self.lower_node_id(i.id) },\n-            ident: i.ident,\n-            span: i.span,\n-            vis: self.lower_visibility(&i.vis, Some(i.id)),\n-            defaultness: self.lower_defaultness(i.defaultness, true /* [1] */),\n-            kind: match i.node {\n-                ImplItemKind::Const(..) => hir::AssocItemKind::Const,\n-                ImplItemKind::TyAlias(..) => hir::AssocItemKind::Type,\n-                ImplItemKind::OpaqueTy(..) => hir::AssocItemKind::OpaqueTy,\n-                ImplItemKind::Method(ref sig, _) => hir::AssocItemKind::Method {\n-                    has_self: sig.decl.has_self(),\n-                },\n-                ImplItemKind::Macro(..) => unimplemented!(),\n-            },\n-        }\n-\n-        // [1] since `default impl` is not yet implemented, this is always true in impls\n-    }\n-\n-    fn lower_mod(&mut self, m: &Mod) -> hir::Mod {\n-        hir::Mod {\n-            inner: m.inner,\n-            item_ids: m.items.iter().flat_map(|x| self.lower_item_id(x)).collect(),\n-        }\n-    }\n-\n-    fn lower_item_id(&mut self, i: &Item) -> SmallVec<[hir::ItemId; 1]> {\n-        let node_ids = match i.node {\n-            ItemKind::Use(ref use_tree) => {\n-                let mut vec = smallvec![i.id];\n-                self.lower_item_id_use_tree(use_tree, i.id, &mut vec);\n-                vec\n-            }\n-            ItemKind::MacroDef(..) => SmallVec::new(),\n-            ItemKind::Fn(..) |\n-            ItemKind::Impl(.., None, _, _) => smallvec![i.id],\n-            ItemKind::Static(ref ty, ..) => {\n-                let mut ids = smallvec![i.id];\n-                if self.sess.features_untracked().impl_trait_in_bindings {\n-                    let mut visitor = ImplTraitTypeIdVisitor { ids: &mut ids };\n-                    visitor.visit_ty(ty);\n-                }\n-                ids\n-            },\n-            ItemKind::Const(ref ty, ..) => {\n-                let mut ids = smallvec![i.id];\n-                if self.sess.features_untracked().impl_trait_in_bindings {\n-                    let mut visitor = ImplTraitTypeIdVisitor { ids: &mut ids };\n-                    visitor.visit_ty(ty);\n-                }\n-                ids\n-            },\n-            _ => smallvec![i.id],\n-        };\n-\n-        node_ids.into_iter().map(|node_id| hir::ItemId {\n-            id: self.allocate_hir_id_counter(node_id)\n-        }).collect()\n-    }\n-\n-    fn lower_item_id_use_tree(&mut self,\n-                              tree: &UseTree,\n-                              base_id: NodeId,\n-                              vec: &mut SmallVec<[NodeId; 1]>)\n-    {\n-        match tree.kind {\n-            UseTreeKind::Nested(ref nested_vec) => for &(ref nested, id) in nested_vec {\n-                vec.push(id);\n-                self.lower_item_id_use_tree(nested, id, vec);\n-            },\n-            UseTreeKind::Glob => {}\n-            UseTreeKind::Simple(_, id1, id2) => {\n-                for (_, &id) in self.expect_full_res_from_use(base_id)\n-                                    .skip(1)\n-                                    .zip([id1, id2].iter())\n-                {\n-                    vec.push(id);\n-                }\n-            },\n-        }\n-    }\n-\n-    pub fn lower_item(&mut self, i: &Item) -> Option<hir::Item> {\n-        let mut ident = i.ident;\n-        let mut vis = self.lower_visibility(&i.vis, None);\n-        let mut attrs = self.lower_attrs_extendable(&i.attrs);\n-        if self.resolver.has_derives(i.id, SpecialDerives::PARTIAL_EQ | SpecialDerives::EQ) {\n-            // Add `#[structural_match]` if the item derived both `PartialEq` and `Eq`.\n-            let ident = Ident::new(sym::structural_match, i.span);\n-            attrs.push(attr::mk_attr_outer(attr::mk_word_item(ident)));\n-        }\n-        let attrs = attrs.into();\n-\n-        if let ItemKind::MacroDef(ref def) = i.node {\n-            if !def.legacy || attr::contains_name(&i.attrs, sym::macro_export) {\n-                let body = self.lower_token_stream(def.stream());\n-                let hir_id = self.lower_node_id(i.id);\n-                self.exported_macros.push(hir::MacroDef {\n-                    name: ident.name,\n-                    vis,\n-                    attrs,\n-                    hir_id,\n-                    span: i.span,\n-                    body,\n-                    legacy: def.legacy,\n-                });\n-            } else {\n-                self.non_exported_macro_attrs.extend(attrs.into_iter());\n-            }\n-            return None;\n-        }\n-\n-        let node = self.lower_item_kind(i.id, &mut ident, &attrs, &mut vis, &i.node);\n-\n-        Some(hir::Item {\n-            hir_id: self.lower_node_id(i.id),\n-            ident,\n-            attrs,\n-            node,\n-            vis,\n-            span: i.span,\n-        })\n-    }\n-\n-    fn lower_foreign_item(&mut self, i: &ForeignItem) -> hir::ForeignItem {\n-        let def_id = self.resolver.definitions().local_def_id(i.id);\n-        hir::ForeignItem {\n-            hir_id: self.lower_node_id(i.id),\n-            ident: i.ident,\n-            attrs: self.lower_attrs(&i.attrs),\n-            node: match i.node {\n-                ForeignItemKind::Fn(ref fdec, ref generics) => {\n-                    let (generics, (fn_dec, fn_args)) = self.add_in_band_defs(\n-                        generics,\n-                        def_id,\n-                        AnonymousLifetimeMode::PassThrough,\n-                        |this, _| {\n-                            (\n-                                // Disallow impl Trait in foreign items\n-                                this.lower_fn_decl(fdec, None, false, None),\n-                                this.lower_fn_args_to_names(fdec),\n-                            )\n-                        },\n-                    );\n-\n-                    hir::ForeignItemKind::Fn(fn_dec, fn_args, generics)\n-                }\n-                ForeignItemKind::Static(ref t, m) => {\n-                    hir::ForeignItemKind::Static(\n-                        self.lower_ty(t, ImplTraitContext::disallowed()), self.lower_mutability(m))\n-                }\n-                ForeignItemKind::Ty => hir::ForeignItemKind::Type,\n-                ForeignItemKind::Macro(_) => panic!(\"shouldn't exist here\"),\n-            },\n-            vis: self.lower_visibility(&i.vis, None),\n-            span: i.span,\n-        }\n-    }\n-\n-    fn lower_method_sig(\n-        &mut self,\n-        generics: &Generics,\n-        sig: &MethodSig,\n-        fn_def_id: DefId,\n-        impl_trait_return_allow: bool,\n-        is_async: Option<NodeId>,\n-    ) -> (hir::Generics, hir::MethodSig) {\n-        let header = self.lower_fn_header(sig.header);\n-        let (generics, decl) = self.add_in_band_defs(\n-            generics,\n-            fn_def_id,\n-            AnonymousLifetimeMode::PassThrough,\n-            |this, idty| this.lower_fn_decl(\n-                &sig.decl,\n-                Some((fn_def_id, idty)),\n-                impl_trait_return_allow,\n-                is_async,\n-            ),\n-        );\n-        (generics, hir::MethodSig { header, decl })\n-    }\n-\n-    fn lower_is_auto(&mut self, a: IsAuto) -> hir::IsAuto {\n-        match a {\n-            IsAuto::Yes => hir::IsAuto::Yes,\n-            IsAuto::No => hir::IsAuto::No,\n-        }\n-    }\n-\n-    fn lower_fn_header(&mut self, h: FnHeader) -> hir::FnHeader {\n-        hir::FnHeader {\n-            unsafety: self.lower_unsafety(h.unsafety),\n-            asyncness: self.lower_asyncness(h.asyncness.node),\n-            constness: self.lower_constness(h.constness),\n-            abi: h.abi,\n-        }\n-    }\n-\n-    fn lower_unsafety(&mut self, u: Unsafety) -> hir::Unsafety {\n-        match u {\n-            Unsafety::Unsafe => hir::Unsafety::Unsafe,\n-            Unsafety::Normal => hir::Unsafety::Normal,\n-        }\n-    }\n-\n-    fn lower_constness(&mut self, c: Spanned<Constness>) -> hir::Constness {\n-        match c.node {\n-            Constness::Const => hir::Constness::Const,\n-            Constness::NotConst => hir::Constness::NotConst,\n-        }\n-    }\n-\n-    fn lower_asyncness(&mut self, a: IsAsync) -> hir::IsAsync {\n-        match a {\n-            IsAsync::Async { .. } => hir::IsAsync::Async,\n-            IsAsync::NotAsync => hir::IsAsync::NotAsync,\n-        }\n-    }\n-\n     fn lower_pat(&mut self, p: &Pat) -> P<hir::Pat> {\n         let node = match p.node {\n             PatKind::Wild => hir::PatKind::Wild,\n@@ -4370,55 +3012,6 @@ impl<'a> LoweringContext<'a> {\n         }\n     }\n \n-    /// If an `explicit_owner` is given, this method allocates the `HirId` in\n-    /// the address space of that item instead of the item currently being\n-    /// lowered. This can happen during `lower_impl_item_ref()` where we need to\n-    /// lower a `Visibility` value although we haven't lowered the owning\n-    /// `ImplItem` in question yet.\n-    fn lower_visibility(\n-        &mut self,\n-        v: &Visibility,\n-        explicit_owner: Option<NodeId>,\n-    ) -> hir::Visibility {\n-        let node = match v.node {\n-            VisibilityKind::Public => hir::VisibilityKind::Public,\n-            VisibilityKind::Crate(sugar) => hir::VisibilityKind::Crate(sugar),\n-            VisibilityKind::Restricted { ref path, id } => {\n-                debug!(\"lower_visibility: restricted path id = {:?}\", id);\n-                let lowered_id = if let Some(owner) = explicit_owner {\n-                    self.lower_node_id_with_owner(id, owner)\n-                } else {\n-                    self.lower_node_id(id)\n-                };\n-                let res = self.expect_full_res(id);\n-                let res = self.lower_res(res);\n-                hir::VisibilityKind::Restricted {\n-                    path: P(self.lower_path_extra(\n-                        res,\n-                        path,\n-                        ParamMode::Explicit,\n-                        explicit_owner,\n-                    )),\n-                    hir_id: lowered_id,\n-                }\n-            },\n-            VisibilityKind::Inherited => hir::VisibilityKind::Inherited,\n-        };\n-        respan(v.span, node)\n-    }\n-\n-    fn lower_defaultness(&self, d: Defaultness, has_value: bool) -> hir::Defaultness {\n-        match d {\n-            Defaultness::Default => hir::Defaultness::Default {\n-                has_value: has_value,\n-            },\n-            Defaultness::Final => {\n-                assert!(has_value);\n-                hir::Defaultness::Final\n-            }\n-        }\n-    }\n-\n     fn lower_block_check_mode(&mut self, b: &BlockCheckMode) -> hir::BlockCheckMode {\n         match *b {\n             BlockCheckMode::Default => hir::DefaultBlock,\n@@ -4442,13 +3035,6 @@ impl<'a> LoweringContext<'a> {\n         }\n     }\n \n-    fn lower_impl_polarity(&mut self, i: ImplPolarity) -> hir::ImplPolarity {\n-        match i {\n-            ImplPolarity::Positive => hir::ImplPolarity::Positive,\n-            ImplPolarity::Negative => hir::ImplPolarity::Negative,\n-        }\n-    }\n-\n     fn lower_trait_bound_modifier(&mut self, f: TraitBoundModifier) -> hir::TraitBoundModifier {\n         match f {\n             TraitBoundModifier::None => hir::TraitBoundModifier::None,"}, {"sha": "96887ed85ae4cad1ad8277e9ca63651e37c2554f", "filename": "src/librustc/hir/lowering/expr.rs", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/5ab73450f820f258205aff069be465a2f72c3c55/src%2Flibrustc%2Fhir%2Flowering%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ab73450f820f258205aff069be465a2f72c3c55/src%2Flibrustc%2Fhir%2Flowering%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering%2Fexpr.rs?ref=5ab73450f820f258205aff069be465a2f72c3c55", "patch": "@@ -700,6 +700,46 @@ impl LoweringContext<'_> {\n         })\n     }\n \n+    fn generator_movability_for_fn(\n+        &mut self,\n+        decl: &ast::FnDecl,\n+        fn_decl_span: Span,\n+        generator_kind: Option<hir::GeneratorKind>,\n+        movability: Movability,\n+    ) -> Option<hir::GeneratorMovability> {\n+        match generator_kind {\n+            Some(hir::GeneratorKind::Gen) =>  {\n+                if !decl.inputs.is_empty() {\n+                    span_err!(\n+                        self.sess,\n+                        fn_decl_span,\n+                        E0628,\n+                        \"generators cannot have explicit arguments\"\n+                    );\n+                    self.sess.abort_if_errors();\n+                }\n+                Some(match movability {\n+                    Movability::Movable => hir::GeneratorMovability::Movable,\n+                    Movability::Static => hir::GeneratorMovability::Static,\n+                })\n+            },\n+            Some(hir::GeneratorKind::Async) => {\n+                bug!(\"non-`async` closure body turned `async` during lowering\");\n+            },\n+            None => {\n+                if movability == Movability::Static {\n+                    span_err!(\n+                        self.sess,\n+                        fn_decl_span,\n+                        E0697,\n+                        \"closures cannot be static\"\n+                    );\n+                }\n+                None\n+            },\n+        }\n+    }\n+\n     fn lower_expr_async_closure(\n         &mut self,\n         capture_clause: CaptureBy,"}, {"sha": "819fbf784c6c4dc09fc38750f63dc42ba7486248", "filename": "src/librustc/hir/lowering/item.rs", "status": "added", "additions": 1401, "deletions": 0, "changes": 1401, "blob_url": "https://github.com/rust-lang/rust/blob/5ab73450f820f258205aff069be465a2f72c3c55/src%2Flibrustc%2Fhir%2Flowering%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ab73450f820f258205aff069be465a2f72c3c55/src%2Flibrustc%2Fhir%2Flowering%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering%2Fitem.rs?ref=5ab73450f820f258205aff069be465a2f72c3c55", "patch": "@@ -0,0 +1,1401 @@\n+use super::LoweringContext;\n+use super::ImplTraitContext;\n+use super::ImplTraitPosition;\n+use super::ImplTraitTypeIdVisitor;\n+use super::AnonymousLifetimeMode;\n+use super::ParamMode;\n+\n+use crate::hir::{self, HirVec};\n+use crate::hir::ptr::P;\n+use crate::hir::def_id::DefId;\n+use crate::hir::def::{Res, DefKind};\n+use crate::util::nodemap::NodeMap;\n+\n+use rustc_data_structures::thin_vec::ThinVec;\n+\n+use std::collections::BTreeSet;\n+use smallvec::SmallVec;\n+use syntax::attr;\n+use syntax::ast::*;\n+use syntax::visit::{self, Visitor};\n+use syntax::ext::base::SpecialDerives;\n+use syntax::source_map::{respan, DesugaringKind, Spanned};\n+use syntax::symbol::{kw, sym};\n+use syntax_pos::Span;\n+\n+pub(super) struct ItemLowerer<'tcx, 'interner> {\n+    pub(super) lctx: &'tcx mut LoweringContext<'interner>,\n+}\n+\n+impl<'tcx, 'interner> ItemLowerer<'tcx, 'interner> {\n+    fn with_trait_impl_ref<F>(&mut self, trait_impl_ref: &Option<TraitRef>, f: F)\n+    where\n+        F: FnOnce(&mut Self),\n+    {\n+        let old = self.lctx.is_in_trait_impl;\n+        self.lctx.is_in_trait_impl = if let &None = trait_impl_ref {\n+            false\n+        } else {\n+            true\n+        };\n+        f(self);\n+        self.lctx.is_in_trait_impl = old;\n+    }\n+}\n+\n+impl<'tcx, 'interner> Visitor<'tcx> for ItemLowerer<'tcx, 'interner> {\n+    fn visit_mod(&mut self, m: &'tcx Mod, _s: Span, _attrs: &[Attribute], n: NodeId) {\n+        self.lctx.modules.insert(n, hir::ModuleItems {\n+            items: BTreeSet::new(),\n+            trait_items: BTreeSet::new(),\n+            impl_items: BTreeSet::new(),\n+        });\n+\n+        let old = self.lctx.current_module;\n+        self.lctx.current_module = n;\n+        visit::walk_mod(self, m);\n+        self.lctx.current_module = old;\n+    }\n+\n+    fn visit_item(&mut self, item: &'tcx Item) {\n+        let mut item_hir_id = None;\n+        self.lctx.with_hir_id_owner(item.id, |lctx| {\n+            if let Some(hir_item) = lctx.lower_item(item) {\n+                item_hir_id = Some(hir_item.hir_id);\n+                lctx.insert_item(hir_item);\n+            }\n+        });\n+\n+        if let Some(hir_id) = item_hir_id {\n+            self.lctx.with_parent_item_lifetime_defs(hir_id, |this| {\n+                let this = &mut ItemLowerer { lctx: this };\n+                if let ItemKind::Impl(.., ref opt_trait_ref, _, _) = item.node {\n+                    this.with_trait_impl_ref(opt_trait_ref, |this| {\n+                        visit::walk_item(this, item)\n+                    });\n+                } else {\n+                    visit::walk_item(this, item);\n+                }\n+            });\n+        }\n+    }\n+\n+    fn visit_trait_item(&mut self, item: &'tcx TraitItem) {\n+        self.lctx.with_hir_id_owner(item.id, |lctx| {\n+            let hir_item = lctx.lower_trait_item(item);\n+            let id = hir::TraitItemId { hir_id: hir_item.hir_id };\n+            lctx.trait_items.insert(id, hir_item);\n+            lctx.modules.get_mut(&lctx.current_module).unwrap().trait_items.insert(id);\n+        });\n+\n+        visit::walk_trait_item(self, item);\n+    }\n+\n+    fn visit_impl_item(&mut self, item: &'tcx ImplItem) {\n+        self.lctx.with_hir_id_owner(item.id, |lctx| {\n+            let hir_item = lctx.lower_impl_item(item);\n+            let id = hir::ImplItemId { hir_id: hir_item.hir_id };\n+            lctx.impl_items.insert(id, hir_item);\n+            lctx.modules.get_mut(&lctx.current_module).unwrap().impl_items.insert(id);\n+        });\n+        visit::walk_impl_item(self, item);\n+    }\n+}\n+\n+impl LoweringContext<'_> {\n+    // Same as the method above, but accepts `hir::GenericParam`s\n+    // instead of `ast::GenericParam`s.\n+    // This should only be used with generics that have already had their\n+    // in-band lifetimes added. In practice, this means that this function is\n+    // only used when lowering a child item of a trait or impl.\n+    fn with_parent_item_lifetime_defs<T>(\n+        &mut self,\n+        parent_hir_id: hir::HirId,\n+        f: impl FnOnce(&mut LoweringContext<'_>) -> T,\n+    ) -> T {\n+        let old_len = self.in_scope_lifetimes.len();\n+\n+        let parent_generics = match self.items.get(&parent_hir_id).unwrap().node {\n+            hir::ItemKind::Impl(_, _, _, ref generics, ..)\n+            | hir::ItemKind::Trait(_, _, ref generics, ..) => {\n+                &generics.params[..]\n+            }\n+            _ => &[],\n+        };\n+        let lt_def_names = parent_generics.iter().filter_map(|param| match param.kind {\n+            hir::GenericParamKind::Lifetime { .. } => Some(param.name.ident().modern()),\n+            _ => None,\n+        });\n+        self.in_scope_lifetimes.extend(lt_def_names);\n+\n+        let res = f(self);\n+\n+        self.in_scope_lifetimes.truncate(old_len);\n+        res\n+    }\n+\n+    pub(super) fn lower_mod(&mut self, m: &Mod) -> hir::Mod {\n+        hir::Mod {\n+            inner: m.inner,\n+            item_ids: m.items.iter().flat_map(|x| self.lower_item_id(x)).collect(),\n+        }\n+    }\n+\n+    pub(super) fn lower_item_id(&mut self, i: &Item) -> SmallVec<[hir::ItemId; 1]> {\n+        let node_ids = match i.node {\n+            ItemKind::Use(ref use_tree) => {\n+                let mut vec = smallvec![i.id];\n+                self.lower_item_id_use_tree(use_tree, i.id, &mut vec);\n+                vec\n+            }\n+            ItemKind::MacroDef(..) => SmallVec::new(),\n+            ItemKind::Fn(..) |\n+            ItemKind::Impl(.., None, _, _) => smallvec![i.id],\n+            ItemKind::Static(ref ty, ..) => {\n+                let mut ids = smallvec![i.id];\n+                if self.sess.features_untracked().impl_trait_in_bindings {\n+                    let mut visitor = ImplTraitTypeIdVisitor { ids: &mut ids };\n+                    visitor.visit_ty(ty);\n+                }\n+                ids\n+            },\n+            ItemKind::Const(ref ty, ..) => {\n+                let mut ids = smallvec![i.id];\n+                if self.sess.features_untracked().impl_trait_in_bindings {\n+                    let mut visitor = ImplTraitTypeIdVisitor { ids: &mut ids };\n+                    visitor.visit_ty(ty);\n+                }\n+                ids\n+            },\n+            _ => smallvec![i.id],\n+        };\n+\n+        node_ids.into_iter().map(|node_id| hir::ItemId {\n+            id: self.allocate_hir_id_counter(node_id)\n+        }).collect()\n+    }\n+\n+    fn lower_item_id_use_tree(\n+        &mut self,\n+        tree: &UseTree,\n+        base_id: NodeId,\n+        vec: &mut SmallVec<[NodeId; 1]>\n+    ) {\n+        match tree.kind {\n+            UseTreeKind::Nested(ref nested_vec) => for &(ref nested, id) in nested_vec {\n+                vec.push(id);\n+                self.lower_item_id_use_tree(nested, id, vec);\n+            },\n+            UseTreeKind::Glob => {}\n+            UseTreeKind::Simple(_, id1, id2) => {\n+                for (_, &id) in self.expect_full_res_from_use(base_id)\n+                                    .skip(1)\n+                                    .zip([id1, id2].iter())\n+                {\n+                    vec.push(id);\n+                }\n+            },\n+        }\n+    }\n+\n+    pub fn lower_item(&mut self, i: &Item) -> Option<hir::Item> {\n+        let mut ident = i.ident;\n+        let mut vis = self.lower_visibility(&i.vis, None);\n+        let mut attrs = self.lower_attrs_extendable(&i.attrs);\n+        if self.resolver.has_derives(i.id, SpecialDerives::PARTIAL_EQ | SpecialDerives::EQ) {\n+            // Add `#[structural_match]` if the item derived both `PartialEq` and `Eq`.\n+            let ident = Ident::new(sym::structural_match, i.span);\n+            attrs.push(attr::mk_attr_outer(attr::mk_word_item(ident)));\n+        }\n+        let attrs = attrs.into();\n+\n+        if let ItemKind::MacroDef(ref def) = i.node {\n+            if !def.legacy || attr::contains_name(&i.attrs, sym::macro_export) {\n+                let body = self.lower_token_stream(def.stream());\n+                let hir_id = self.lower_node_id(i.id);\n+                self.exported_macros.push(hir::MacroDef {\n+                    name: ident.name,\n+                    vis,\n+                    attrs,\n+                    hir_id,\n+                    span: i.span,\n+                    body,\n+                    legacy: def.legacy,\n+                });\n+            } else {\n+                self.non_exported_macro_attrs.extend(attrs.into_iter());\n+            }\n+            return None;\n+        }\n+\n+        let node = self.lower_item_kind(i.id, &mut ident, &attrs, &mut vis, &i.node);\n+\n+        Some(hir::Item {\n+            hir_id: self.lower_node_id(i.id),\n+            ident,\n+            attrs,\n+            node,\n+            vis,\n+            span: i.span,\n+        })\n+    }\n+\n+    fn lower_item_kind(\n+        &mut self,\n+        id: NodeId,\n+        ident: &mut Ident,\n+        attrs: &hir::HirVec<Attribute>,\n+        vis: &mut hir::Visibility,\n+        i: &ItemKind,\n+    ) -> hir::ItemKind {\n+        match *i {\n+            ItemKind::ExternCrate(orig_name) => hir::ItemKind::ExternCrate(orig_name),\n+            ItemKind::Use(ref use_tree) => {\n+                // Start with an empty prefix.\n+                let prefix = Path {\n+                    segments: vec![],\n+                    span: use_tree.span,\n+                };\n+\n+                self.lower_use_tree(use_tree, &prefix, id, vis, ident, attrs)\n+            }\n+            ItemKind::Static(ref t, m, ref e) => {\n+                hir::ItemKind::Static(\n+                    self.lower_ty(\n+                        t,\n+                        if self.sess.features_untracked().impl_trait_in_bindings {\n+                            ImplTraitContext::OpaqueTy(None)\n+                        } else {\n+                            ImplTraitContext::Disallowed(ImplTraitPosition::Binding)\n+                        }\n+                    ),\n+                    self.lower_mutability(m),\n+                    self.lower_const_body(e),\n+                )\n+            }\n+            ItemKind::Const(ref t, ref e) => {\n+                hir::ItemKind::Const(\n+                    self.lower_ty(\n+                        t,\n+                        if self.sess.features_untracked().impl_trait_in_bindings {\n+                            ImplTraitContext::OpaqueTy(None)\n+                        } else {\n+                            ImplTraitContext::Disallowed(ImplTraitPosition::Binding)\n+                        }\n+                    ),\n+                    self.lower_const_body(e)\n+                )\n+            }\n+            ItemKind::Fn(ref decl, header, ref generics, ref body) => {\n+                let fn_def_id = self.resolver.definitions().local_def_id(id);\n+                self.with_new_scopes(|this| {\n+                    this.current_item = Some(ident.span);\n+\n+                    // Note: we don't need to change the return type from `T` to\n+                    // `impl Future<Output = T>` here because lower_body\n+                    // only cares about the input argument patterns in the function\n+                    // declaration (decl), not the return types.\n+                    let body_id = this.lower_maybe_async_body(&decl, header.asyncness.node, body);\n+\n+                    let (generics, fn_decl) = this.add_in_band_defs(\n+                        generics,\n+                        fn_def_id,\n+                        AnonymousLifetimeMode::PassThrough,\n+                        |this, idty| this.lower_fn_decl(\n+                            &decl,\n+                            Some((fn_def_id, idty)),\n+                            true,\n+                            header.asyncness.node.opt_return_id()\n+                        ),\n+                    );\n+\n+                    hir::ItemKind::Fn(\n+                        fn_decl,\n+                        this.lower_fn_header(header),\n+                        generics,\n+                        body_id,\n+                    )\n+                })\n+            }\n+            ItemKind::Mod(ref m) => hir::ItemKind::Mod(self.lower_mod(m)),\n+            ItemKind::ForeignMod(ref nm) => hir::ItemKind::ForeignMod(self.lower_foreign_mod(nm)),\n+            ItemKind::GlobalAsm(ref ga) => hir::ItemKind::GlobalAsm(self.lower_global_asm(ga)),\n+            ItemKind::TyAlias(ref t, ref generics) => hir::ItemKind::TyAlias(\n+                self.lower_ty(t, ImplTraitContext::disallowed()),\n+                self.lower_generics(generics, ImplTraitContext::disallowed()),\n+            ),\n+            ItemKind::OpaqueTy(ref b, ref generics) => hir::ItemKind::OpaqueTy(\n+                hir::OpaqueTy {\n+                    generics: self.lower_generics(generics,\n+                        ImplTraitContext::OpaqueTy(None)),\n+                    bounds: self.lower_param_bounds(b,\n+                        ImplTraitContext::OpaqueTy(None)),\n+                    impl_trait_fn: None,\n+                    origin: hir::OpaqueTyOrigin::TypeAlias,\n+                },\n+            ),\n+            ItemKind::Enum(ref enum_definition, ref generics) => {\n+                hir::ItemKind::Enum(\n+                    hir::EnumDef {\n+                        variants: enum_definition\n+                            .variants\n+                            .iter()\n+                            .map(|x| self.lower_variant(x))\n+                            .collect(),\n+                    },\n+                    self.lower_generics(generics, ImplTraitContext::disallowed()),\n+                )\n+            },\n+            ItemKind::Struct(ref struct_def, ref generics) => {\n+                let struct_def = self.lower_variant_data(struct_def);\n+                hir::ItemKind::Struct(\n+                    struct_def,\n+                    self.lower_generics(generics, ImplTraitContext::disallowed()),\n+                )\n+            }\n+            ItemKind::Union(ref vdata, ref generics) => {\n+                let vdata = self.lower_variant_data(vdata);\n+                hir::ItemKind::Union(\n+                    vdata,\n+                    self.lower_generics(generics, ImplTraitContext::disallowed()),\n+                )\n+            }\n+            ItemKind::Impl(\n+                unsafety,\n+                polarity,\n+                defaultness,\n+                ref ast_generics,\n+                ref trait_ref,\n+                ref ty,\n+                ref impl_items,\n+            ) => {\n+                let def_id = self.resolver.definitions().local_def_id(id);\n+\n+                // Lower the \"impl header\" first. This ordering is important\n+                // for in-band lifetimes! Consider `'a` here:\n+                //\n+                //     impl Foo<'a> for u32 {\n+                //         fn method(&'a self) { .. }\n+                //     }\n+                //\n+                // Because we start by lowering the `Foo<'a> for u32`\n+                // part, we will add `'a` to the list of generics on\n+                // the impl. When we then encounter it later in the\n+                // method, it will not be considered an in-band\n+                // lifetime to be added, but rather a reference to a\n+                // parent lifetime.\n+                let lowered_trait_impl_id = self.lower_node_id(id);\n+                let (generics, (trait_ref, lowered_ty)) = self.add_in_band_defs(\n+                    ast_generics,\n+                    def_id,\n+                    AnonymousLifetimeMode::CreateParameter,\n+                    |this, _| {\n+                        let trait_ref = trait_ref.as_ref().map(|trait_ref| {\n+                            this.lower_trait_ref(trait_ref, ImplTraitContext::disallowed())\n+                        });\n+\n+                        if let Some(ref trait_ref) = trait_ref {\n+                            if let Res::Def(DefKind::Trait, def_id) = trait_ref.path.res {\n+                                this.trait_impls.entry(def_id).or_default().push(\n+                                    lowered_trait_impl_id);\n+                            }\n+                        }\n+\n+                        let lowered_ty = this.lower_ty(ty, ImplTraitContext::disallowed());\n+\n+                        (trait_ref, lowered_ty)\n+                    },\n+                );\n+\n+                let new_impl_items = self.with_in_scope_lifetime_defs(\n+                    &ast_generics.params,\n+                    |this| {\n+                        impl_items\n+                            .iter()\n+                            .map(|item| this.lower_impl_item_ref(item))\n+                            .collect()\n+                    },\n+                );\n+\n+                hir::ItemKind::Impl(\n+                    self.lower_unsafety(unsafety),\n+                    self.lower_impl_polarity(polarity),\n+                    self.lower_defaultness(defaultness, true /* [1] */),\n+                    generics,\n+                    trait_ref,\n+                    lowered_ty,\n+                    new_impl_items,\n+                )\n+            }\n+            ItemKind::Trait(is_auto, unsafety, ref generics, ref bounds, ref items) => {\n+                let bounds = self.lower_param_bounds(bounds, ImplTraitContext::disallowed());\n+                let items = items\n+                    .iter()\n+                    .map(|item| self.lower_trait_item_ref(item))\n+                    .collect();\n+                hir::ItemKind::Trait(\n+                    self.lower_is_auto(is_auto),\n+                    self.lower_unsafety(unsafety),\n+                    self.lower_generics(generics, ImplTraitContext::disallowed()),\n+                    bounds,\n+                    items,\n+                )\n+            }\n+            ItemKind::TraitAlias(ref generics, ref bounds) => hir::ItemKind::TraitAlias(\n+                self.lower_generics(generics, ImplTraitContext::disallowed()),\n+                self.lower_param_bounds(bounds, ImplTraitContext::disallowed()),\n+            ),\n+            ItemKind::MacroDef(..)\n+            | ItemKind::Mac(..) => bug!(\"`TyMac` should have been expanded by now\"),\n+        }\n+\n+        // [1] `defaultness.has_value()` is never called for an `impl`, always `true` in order to\n+        //     not cause an assertion failure inside the `lower_defaultness` function.\n+    }\n+\n+    fn lower_use_tree(\n+        &mut self,\n+        tree: &UseTree,\n+        prefix: &Path,\n+        id: NodeId,\n+        vis: &mut hir::Visibility,\n+        ident: &mut Ident,\n+        attrs: &hir::HirVec<Attribute>,\n+    ) -> hir::ItemKind {\n+        debug!(\"lower_use_tree(tree={:?})\", tree);\n+        debug!(\"lower_use_tree: vis = {:?}\", vis);\n+\n+        let path = &tree.prefix;\n+        let segments = prefix\n+            .segments\n+            .iter()\n+            .chain(path.segments.iter())\n+            .cloned()\n+            .collect();\n+\n+        match tree.kind {\n+            UseTreeKind::Simple(rename, id1, id2) => {\n+                *ident = tree.ident();\n+\n+                // First, apply the prefix to the path.\n+                let mut path = Path {\n+                    segments,\n+                    span: path.span,\n+                };\n+\n+                // Correctly resolve `self` imports.\n+                if path.segments.len() > 1\n+                    && path.segments.last().unwrap().ident.name == kw::SelfLower\n+                {\n+                    let _ = path.segments.pop();\n+                    if rename.is_none() {\n+                        *ident = path.segments.last().unwrap().ident;\n+                    }\n+                }\n+\n+                let mut resolutions = self.expect_full_res_from_use(id);\n+                // We want to return *something* from this function, so hold onto the first item\n+                // for later.\n+                let ret_res = self.lower_res(resolutions.next().unwrap_or(Res::Err));\n+\n+                // Here, we are looping over namespaces, if they exist for the definition\n+                // being imported. We only handle type and value namespaces because we\n+                // won't be dealing with macros in the rest of the compiler.\n+                // Essentially a single `use` which imports two names is desugared into\n+                // two imports.\n+                for (res, &new_node_id) in resolutions.zip([id1, id2].iter()) {\n+                    let ident = *ident;\n+                    let mut path = path.clone();\n+                    for seg in &mut path.segments {\n+                        seg.id = self.sess.next_node_id();\n+                    }\n+                    let span = path.span;\n+\n+                    self.with_hir_id_owner(new_node_id, |this| {\n+                        let new_id = this.lower_node_id(new_node_id);\n+                        let res = this.lower_res(res);\n+                        let path =\n+                            this.lower_path_extra(res, &path, ParamMode::Explicit, None);\n+                        let item = hir::ItemKind::Use(P(path), hir::UseKind::Single);\n+                        let vis = this.rebuild_vis(&vis);\n+\n+                        this.insert_item(\n+                            hir::Item {\n+                                hir_id: new_id,\n+                                ident,\n+                                attrs: attrs.into_iter().cloned().collect(),\n+                                node: item,\n+                                vis,\n+                                span,\n+                            },\n+                        );\n+                    });\n+                }\n+\n+                let path =\n+                    P(self.lower_path_extra(ret_res, &path, ParamMode::Explicit, None));\n+                hir::ItemKind::Use(path, hir::UseKind::Single)\n+            }\n+            UseTreeKind::Glob => {\n+                let path = P(self.lower_path(\n+                    id,\n+                    &Path {\n+                        segments,\n+                        span: path.span,\n+                    },\n+                    ParamMode::Explicit,\n+                ));\n+                hir::ItemKind::Use(path, hir::UseKind::Glob)\n+            }\n+            UseTreeKind::Nested(ref trees) => {\n+                // Nested imports are desugared into simple imports.\n+                // So, if we start with\n+                //\n+                // ```\n+                // pub(x) use foo::{a, b};\n+                // ```\n+                //\n+                // we will create three items:\n+                //\n+                // ```\n+                // pub(x) use foo::a;\n+                // pub(x) use foo::b;\n+                // pub(x) use foo::{}; // <-- this is called the `ListStem`\n+                // ```\n+                //\n+                // The first two are produced by recursively invoking\n+                // `lower_use_tree` (and indeed there may be things\n+                // like `use foo::{a::{b, c}}` and so forth).  They\n+                // wind up being directly added to\n+                // `self.items`. However, the structure of this\n+                // function also requires us to return one item, and\n+                // for that we return the `{}` import (called the\n+                // `ListStem`).\n+\n+                let prefix = Path {\n+                    segments,\n+                    span: prefix.span.to(path.span),\n+                };\n+\n+                // Add all the nested `PathListItem`s to the HIR.\n+                for &(ref use_tree, id) in trees {\n+                    let new_hir_id = self.lower_node_id(id);\n+\n+                    let mut prefix = prefix.clone();\n+\n+                    // Give the segments new node-ids since they are being cloned.\n+                    for seg in &mut prefix.segments {\n+                        seg.id = self.sess.next_node_id();\n+                    }\n+\n+                    // Each `use` import is an item and thus are owners of the\n+                    // names in the path. Up to this point the nested import is\n+                    // the current owner, since we want each desugared import to\n+                    // own its own names, we have to adjust the owner before\n+                    // lowering the rest of the import.\n+                    self.with_hir_id_owner(id, |this| {\n+                        let mut vis = this.rebuild_vis(&vis);\n+                        let mut ident = *ident;\n+\n+                        let item = this.lower_use_tree(use_tree,\n+                                                       &prefix,\n+                                                       id,\n+                                                       &mut vis,\n+                                                       &mut ident,\n+                                                       attrs);\n+\n+                        this.insert_item(\n+                            hir::Item {\n+                                hir_id: new_hir_id,\n+                                ident,\n+                                attrs: attrs.into_iter().cloned().collect(),\n+                                node: item,\n+                                vis,\n+                                span: use_tree.span,\n+                            },\n+                        );\n+                    });\n+                }\n+\n+                // Subtle and a bit hacky: we lower the privacy level\n+                // of the list stem to \"private\" most of the time, but\n+                // not for \"restricted\" paths. The key thing is that\n+                // we don't want it to stay as `pub` (with no caveats)\n+                // because that affects rustdoc and also the lints\n+                // about `pub` items. But we can't *always* make it\n+                // private -- particularly not for restricted paths --\n+                // because it contains node-ids that would then be\n+                // unused, failing the check that HirIds are \"densely\n+                // assigned\".\n+                match vis.node {\n+                    hir::VisibilityKind::Public |\n+                    hir::VisibilityKind::Crate(_) |\n+                    hir::VisibilityKind::Inherited => {\n+                        *vis = respan(prefix.span.shrink_to_lo(), hir::VisibilityKind::Inherited);\n+                    }\n+                    hir::VisibilityKind::Restricted { .. } => {\n+                        // Do nothing here, as described in the comment on the match.\n+                    }\n+                }\n+\n+                let res = self.expect_full_res_from_use(id).next().unwrap_or(Res::Err);\n+                let res = self.lower_res(res);\n+                let path = P(self.lower_path_extra(res, &prefix, ParamMode::Explicit, None));\n+                hir::ItemKind::Use(path, hir::UseKind::ListStem)\n+            }\n+        }\n+    }\n+\n+    /// Paths like the visibility path in `pub(super) use foo::{bar, baz}` are repeated\n+    /// many times in the HIR tree; for each occurrence, we need to assign distinct\n+    /// `NodeId`s. (See, e.g., #56128.)\n+    fn rebuild_use_path(&mut self, path: &hir::Path) -> hir::Path {\n+        debug!(\"rebuild_use_path(path = {:?})\", path);\n+        let segments = path.segments.iter().map(|seg| hir::PathSegment {\n+            ident: seg.ident,\n+            hir_id: seg.hir_id.map(|_| self.next_id()),\n+            res: seg.res,\n+            args: None,\n+            infer_args: seg.infer_args,\n+        }).collect();\n+        hir::Path {\n+            span: path.span,\n+            res: path.res,\n+            segments,\n+        }\n+    }\n+\n+    fn rebuild_vis(&mut self, vis: &hir::Visibility) -> hir::Visibility {\n+        let vis_kind = match vis.node {\n+            hir::VisibilityKind::Public => hir::VisibilityKind::Public,\n+            hir::VisibilityKind::Crate(sugar) => hir::VisibilityKind::Crate(sugar),\n+            hir::VisibilityKind::Inherited => hir::VisibilityKind::Inherited,\n+            hir::VisibilityKind::Restricted { ref path, hir_id: _ } => {\n+                hir::VisibilityKind::Restricted {\n+                    path: P(self.rebuild_use_path(path)),\n+                    hir_id: self.next_id(),\n+                }\n+            }\n+        };\n+        respan(vis.span, vis_kind)\n+    }\n+\n+    fn lower_foreign_item(&mut self, i: &ForeignItem) -> hir::ForeignItem {\n+        let def_id = self.resolver.definitions().local_def_id(i.id);\n+        hir::ForeignItem {\n+            hir_id: self.lower_node_id(i.id),\n+            ident: i.ident,\n+            attrs: self.lower_attrs(&i.attrs),\n+            node: match i.node {\n+                ForeignItemKind::Fn(ref fdec, ref generics) => {\n+                    let (generics, (fn_dec, fn_args)) = self.add_in_band_defs(\n+                        generics,\n+                        def_id,\n+                        AnonymousLifetimeMode::PassThrough,\n+                        |this, _| {\n+                            (\n+                                // Disallow impl Trait in foreign items\n+                                this.lower_fn_decl(fdec, None, false, None),\n+                                this.lower_fn_args_to_names(fdec),\n+                            )\n+                        },\n+                    );\n+\n+                    hir::ForeignItemKind::Fn(fn_dec, fn_args, generics)\n+                }\n+                ForeignItemKind::Static(ref t, m) => {\n+                    hir::ForeignItemKind::Static(\n+                        self.lower_ty(t, ImplTraitContext::disallowed()), self.lower_mutability(m))\n+                }\n+                ForeignItemKind::Ty => hir::ForeignItemKind::Type,\n+                ForeignItemKind::Macro(_) => panic!(\"shouldn't exist here\"),\n+            },\n+            vis: self.lower_visibility(&i.vis, None),\n+            span: i.span,\n+        }\n+    }\n+\n+    fn lower_foreign_mod(&mut self, fm: &ForeignMod) -> hir::ForeignMod {\n+        hir::ForeignMod {\n+            abi: fm.abi,\n+            items: fm.items\n+                .iter()\n+                .map(|x| self.lower_foreign_item(x))\n+                .collect(),\n+        }\n+    }\n+\n+    fn lower_global_asm(&mut self, ga: &GlobalAsm) -> P<hir::GlobalAsm> {\n+        P(hir::GlobalAsm {\n+            asm: ga.asm,\n+            ctxt: ga.ctxt,\n+        })\n+    }\n+\n+    fn lower_variant(&mut self, v: &Variant) -> hir::Variant {\n+        Spanned {\n+            node: hir::VariantKind {\n+                ident: v.node.ident,\n+                id: self.lower_node_id(v.node.id),\n+                attrs: self.lower_attrs(&v.node.attrs),\n+                data: self.lower_variant_data(&v.node.data),\n+                disr_expr: v.node.disr_expr.as_ref().map(|e| self.lower_anon_const(e)),\n+            },\n+            span: v.span,\n+        }\n+    }\n+\n+    fn lower_variant_data(&mut self, vdata: &VariantData) -> hir::VariantData {\n+        match *vdata {\n+            VariantData::Struct(ref fields, recovered) => hir::VariantData::Struct(\n+                fields.iter().enumerate().map(|f| self.lower_struct_field(f)).collect(),\n+                recovered,\n+            ),\n+            VariantData::Tuple(ref fields, id) => {\n+                hir::VariantData::Tuple(\n+                    fields\n+                        .iter()\n+                        .enumerate()\n+                        .map(|f| self.lower_struct_field(f))\n+                        .collect(),\n+                    self.lower_node_id(id),\n+                )\n+            },\n+            VariantData::Unit(id) => {\n+                hir::VariantData::Unit(self.lower_node_id(id))\n+            },\n+        }\n+    }\n+\n+    fn lower_struct_field(&mut self, (index, f): (usize, &StructField)) -> hir::StructField {\n+        let ty = if let TyKind::Path(ref qself, ref path) = f.ty.node {\n+            let t = self.lower_path_ty(\n+                &f.ty,\n+                qself,\n+                path,\n+                ParamMode::ExplicitNamed, // no `'_` in declarations (Issue #61124)\n+                ImplTraitContext::disallowed()\n+            );\n+            P(t)\n+        } else {\n+            self.lower_ty(&f.ty, ImplTraitContext::disallowed())\n+        };\n+        hir::StructField {\n+            span: f.span,\n+            hir_id: self.lower_node_id(f.id),\n+            ident: match f.ident {\n+                Some(ident) => ident,\n+                // FIXME(jseyfried): positional field hygiene.\n+                None => Ident::new(sym::integer(index), f.span),\n+            },\n+            vis: self.lower_visibility(&f.vis, None),\n+            ty,\n+            attrs: self.lower_attrs(&f.attrs),\n+        }\n+    }\n+\n+    fn lower_trait_item(&mut self, i: &TraitItem) -> hir::TraitItem {\n+        let trait_item_def_id = self.resolver.definitions().local_def_id(i.id);\n+\n+        let (generics, node) = match i.node {\n+            TraitItemKind::Const(ref ty, ref default) => (\n+                self.lower_generics(&i.generics, ImplTraitContext::disallowed()),\n+                hir::TraitItemKind::Const(\n+                    self.lower_ty(ty, ImplTraitContext::disallowed()),\n+                    default\n+                        .as_ref()\n+                        .map(|x| self.lower_const_body(x)),\n+                ),\n+            ),\n+            TraitItemKind::Method(ref sig, None) => {\n+                let names = self.lower_fn_args_to_names(&sig.decl);\n+                let (generics, sig) = self.lower_method_sig(\n+                    &i.generics,\n+                    sig,\n+                    trait_item_def_id,\n+                    false,\n+                    None,\n+                );\n+                (generics, hir::TraitItemKind::Method(sig, hir::TraitMethod::Required(names)))\n+            }\n+            TraitItemKind::Method(ref sig, Some(ref body)) => {\n+                let body_id = self.lower_fn_body_block(&sig.decl, body);\n+                let (generics, sig) = self.lower_method_sig(\n+                    &i.generics,\n+                    sig,\n+                    trait_item_def_id,\n+                    false,\n+                    None,\n+                );\n+                (generics, hir::TraitItemKind::Method(sig, hir::TraitMethod::Provided(body_id)))\n+            }\n+            TraitItemKind::Type(ref bounds, ref default) => {\n+                let generics = self.lower_generics(&i.generics, ImplTraitContext::disallowed());\n+                let node = hir::TraitItemKind::Type(\n+                    self.lower_param_bounds(bounds, ImplTraitContext::disallowed()),\n+                    default\n+                        .as_ref()\n+                        .map(|x| self.lower_ty(x, ImplTraitContext::disallowed())),\n+                );\n+\n+                (generics, node)\n+            },\n+            TraitItemKind::Macro(..) => bug!(\"macro item shouldn't exist at this point\"),\n+        };\n+\n+        hir::TraitItem {\n+            hir_id: self.lower_node_id(i.id),\n+            ident: i.ident,\n+            attrs: self.lower_attrs(&i.attrs),\n+            generics,\n+            node,\n+            span: i.span,\n+        }\n+    }\n+\n+    fn lower_trait_item_ref(&mut self, i: &TraitItem) -> hir::TraitItemRef {\n+        let (kind, has_default) = match i.node {\n+            TraitItemKind::Const(_, ref default) => {\n+                (hir::AssocItemKind::Const, default.is_some())\n+            }\n+            TraitItemKind::Type(_, ref default) => {\n+                (hir::AssocItemKind::Type, default.is_some())\n+            }\n+            TraitItemKind::Method(ref sig, ref default) => (\n+                hir::AssocItemKind::Method {\n+                    has_self: sig.decl.has_self(),\n+                },\n+                default.is_some(),\n+            ),\n+            TraitItemKind::Macro(..) => unimplemented!(),\n+        };\n+        hir::TraitItemRef {\n+            id: hir::TraitItemId { hir_id: self.lower_node_id(i.id) },\n+            ident: i.ident,\n+            span: i.span,\n+            defaultness: self.lower_defaultness(Defaultness::Default, has_default),\n+            kind,\n+        }\n+    }\n+\n+    fn lower_impl_item(&mut self, i: &ImplItem) -> hir::ImplItem {\n+        let impl_item_def_id = self.resolver.definitions().local_def_id(i.id);\n+\n+        let (generics, node) = match i.node {\n+            ImplItemKind::Const(ref ty, ref expr) => (\n+                self.lower_generics(&i.generics, ImplTraitContext::disallowed()),\n+                hir::ImplItemKind::Const(\n+                    self.lower_ty(ty, ImplTraitContext::disallowed()),\n+                    self.lower_const_body(expr),\n+                ),\n+            ),\n+            ImplItemKind::Method(ref sig, ref body) => {\n+                self.current_item = Some(i.span);\n+                let body_id = self.lower_maybe_async_body(\n+                    &sig.decl, sig.header.asyncness.node, body\n+                );\n+                let impl_trait_return_allow = !self.is_in_trait_impl;\n+                let (generics, sig) = self.lower_method_sig(\n+                    &i.generics,\n+                    sig,\n+                    impl_item_def_id,\n+                    impl_trait_return_allow,\n+                    sig.header.asyncness.node.opt_return_id(),\n+                );\n+\n+                (generics, hir::ImplItemKind::Method(sig, body_id))\n+            }\n+            ImplItemKind::TyAlias(ref ty) => (\n+                self.lower_generics(&i.generics, ImplTraitContext::disallowed()),\n+                hir::ImplItemKind::TyAlias(self.lower_ty(ty, ImplTraitContext::disallowed())),\n+            ),\n+            ImplItemKind::OpaqueTy(ref bounds) => (\n+                self.lower_generics(&i.generics, ImplTraitContext::disallowed()),\n+                hir::ImplItemKind::OpaqueTy(\n+                    self.lower_param_bounds(bounds, ImplTraitContext::disallowed()),\n+                ),\n+            ),\n+            ImplItemKind::Macro(..) => bug!(\"`TyMac` should have been expanded by now\"),\n+        };\n+\n+        hir::ImplItem {\n+            hir_id: self.lower_node_id(i.id),\n+            ident: i.ident,\n+            attrs: self.lower_attrs(&i.attrs),\n+            generics,\n+            vis: self.lower_visibility(&i.vis, None),\n+            defaultness: self.lower_defaultness(i.defaultness, true /* [1] */),\n+            node,\n+            span: i.span,\n+        }\n+\n+        // [1] since `default impl` is not yet implemented, this is always true in impls\n+    }\n+\n+    fn lower_impl_item_ref(&mut self, i: &ImplItem) -> hir::ImplItemRef {\n+        hir::ImplItemRef {\n+            id: hir::ImplItemId { hir_id: self.lower_node_id(i.id) },\n+            ident: i.ident,\n+            span: i.span,\n+            vis: self.lower_visibility(&i.vis, Some(i.id)),\n+            defaultness: self.lower_defaultness(i.defaultness, true /* [1] */),\n+            kind: match i.node {\n+                ImplItemKind::Const(..) => hir::AssocItemKind::Const,\n+                ImplItemKind::TyAlias(..) => hir::AssocItemKind::Type,\n+                ImplItemKind::OpaqueTy(..) => hir::AssocItemKind::OpaqueTy,\n+                ImplItemKind::Method(ref sig, _) => hir::AssocItemKind::Method {\n+                    has_self: sig.decl.has_self(),\n+                },\n+                ImplItemKind::Macro(..) => unimplemented!(),\n+            },\n+        }\n+\n+        // [1] since `default impl` is not yet implemented, this is always true in impls\n+    }\n+\n+    /// If an `explicit_owner` is given, this method allocates the `HirId` in\n+    /// the address space of that item instead of the item currently being\n+    /// lowered. This can happen during `lower_impl_item_ref()` where we need to\n+    /// lower a `Visibility` value although we haven't lowered the owning\n+    /// `ImplItem` in question yet.\n+    fn lower_visibility(\n+        &mut self,\n+        v: &Visibility,\n+        explicit_owner: Option<NodeId>,\n+    ) -> hir::Visibility {\n+        let node = match v.node {\n+            VisibilityKind::Public => hir::VisibilityKind::Public,\n+            VisibilityKind::Crate(sugar) => hir::VisibilityKind::Crate(sugar),\n+            VisibilityKind::Restricted { ref path, id } => {\n+                debug!(\"lower_visibility: restricted path id = {:?}\", id);\n+                let lowered_id = if let Some(owner) = explicit_owner {\n+                    self.lower_node_id_with_owner(id, owner)\n+                } else {\n+                    self.lower_node_id(id)\n+                };\n+                let res = self.expect_full_res(id);\n+                let res = self.lower_res(res);\n+                hir::VisibilityKind::Restricted {\n+                    path: P(self.lower_path_extra(\n+                        res,\n+                        path,\n+                        ParamMode::Explicit,\n+                        explicit_owner,\n+                    )),\n+                    hir_id: lowered_id,\n+                }\n+            },\n+            VisibilityKind::Inherited => hir::VisibilityKind::Inherited,\n+        };\n+        respan(v.span, node)\n+    }\n+\n+    fn lower_defaultness(&self, d: Defaultness, has_value: bool) -> hir::Defaultness {\n+        match d {\n+            Defaultness::Default => hir::Defaultness::Default {\n+                has_value: has_value,\n+            },\n+            Defaultness::Final => {\n+                assert!(has_value);\n+                hir::Defaultness::Final\n+            }\n+        }\n+    }\n+\n+    fn lower_impl_polarity(&mut self, i: ImplPolarity) -> hir::ImplPolarity {\n+        match i {\n+            ImplPolarity::Positive => hir::ImplPolarity::Positive,\n+            ImplPolarity::Negative => hir::ImplPolarity::Negative,\n+        }\n+    }\n+\n+    fn record_body(&mut self, arguments: HirVec<hir::Arg>, value: hir::Expr) -> hir::BodyId {\n+        let body = hir::Body {\n+            generator_kind: self.generator_kind,\n+            arguments,\n+            value,\n+        };\n+        let id = body.id();\n+        self.bodies.insert(id, body);\n+        id\n+    }\n+\n+    fn lower_body(\n+        &mut self,\n+        f: impl FnOnce(&mut LoweringContext<'_>) -> (HirVec<hir::Arg>, hir::Expr),\n+    ) -> hir::BodyId {\n+        let prev_gen_kind = self.generator_kind.take();\n+        let (arguments, result) = f(self);\n+        let body_id = self.record_body(arguments, result);\n+        self.generator_kind = prev_gen_kind;\n+        body_id\n+    }\n+\n+    pub(super) fn lower_fn_body(\n+        &mut self,\n+        decl: &FnDecl,\n+        body: impl FnOnce(&mut LoweringContext<'_>) -> hir::Expr,\n+    ) -> hir::BodyId {\n+        self.lower_body(|this| (\n+            decl.inputs.iter().map(|x| this.lower_arg(x)).collect(),\n+            body(this),\n+        ))\n+    }\n+\n+    fn lower_fn_body_block(&mut self, decl: &FnDecl, body: &Block) -> hir::BodyId {\n+        self.lower_fn_body(decl, |this| {\n+            let body = this.lower_block(body, false);\n+            this.expr_block(body, ThinVec::new())\n+        })\n+    }\n+\n+    pub(super) fn lower_const_body(&mut self, expr: &Expr) -> hir::BodyId {\n+        self.lower_body(|this| (hir_vec![], this.lower_expr(expr)))\n+    }\n+\n+    fn lower_maybe_async_body(\n+        &mut self,\n+        decl: &FnDecl,\n+        asyncness: IsAsync,\n+        body: &Block,\n+    ) -> hir::BodyId {\n+        let closure_id = match asyncness {\n+            IsAsync::Async { closure_id, .. } => closure_id,\n+            IsAsync::NotAsync => return self.lower_fn_body_block(decl, body),\n+        };\n+\n+        self.lower_body(|this| {\n+            let mut arguments: Vec<hir::Arg> = Vec::new();\n+            let mut statements: Vec<hir::Stmt> = Vec::new();\n+\n+            // Async function arguments are lowered into the closure body so that they are\n+            // captured and so that the drop order matches the equivalent non-async functions.\n+            //\n+            // from:\n+            //\n+            //     async fn foo(<pattern>: <ty>, <pattern>: <ty>, <pattern>: <ty>) {\n+            //       async move {\n+            //       }\n+            //     }\n+            //\n+            // into:\n+            //\n+            //     fn foo(__arg0: <ty>, __arg1: <ty>, __arg2: <ty>) {\n+            //       async move {\n+            //         let __arg2 = __arg2;\n+            //         let <pattern> = __arg2;\n+            //         let __arg1 = __arg1;\n+            //         let <pattern> = __arg1;\n+            //         let __arg0 = __arg0;\n+            //         let <pattern> = __arg0;\n+            //       }\n+            //     }\n+            //\n+            // If `<pattern>` is a simple ident, then it is lowered to a single\n+            // `let <pattern> = <pattern>;` statement as an optimization.\n+            for (index, argument) in decl.inputs.iter().enumerate() {\n+                let argument = this.lower_arg(argument);\n+                let span = argument.pat.span;\n+\n+                // Check if this is a binding pattern, if so, we can optimize and avoid adding a\n+                // `let <pat> = __argN;` statement. In this case, we do not rename the argument.\n+                let (ident, is_simple_argument) = match argument.pat.node {\n+                    hir::PatKind::Binding(hir::BindingAnnotation::Unannotated, _, ident, _) =>\n+                        (ident, true),\n+                    _ => {\n+                        // Replace the ident for bindings that aren't simple.\n+                        let name = format!(\"__arg{}\", index);\n+                        let ident = Ident::from_str(&name);\n+\n+                        (ident, false)\n+                    },\n+                };\n+\n+                let desugared_span =\n+                    this.mark_span_with_reason(DesugaringKind::Async, span, None);\n+\n+                // Construct an argument representing `__argN: <ty>` to replace the argument of the\n+                // async function.\n+                //\n+                // If this is the simple case, this argument will end up being the same as the\n+                // original argument, but with a different pattern id.\n+                let mut stmt_attrs = ThinVec::new();\n+                stmt_attrs.extend(argument.attrs.iter().cloned());\n+                let (new_argument_pat, new_argument_id) = this.pat_ident(desugared_span, ident);\n+                let new_argument = hir::Arg {\n+                    attrs: argument.attrs,\n+                    hir_id: argument.hir_id,\n+                    pat: new_argument_pat,\n+                    span: argument.span,\n+                };\n+\n+\n+                if is_simple_argument {\n+                    // If this is the simple case, then we only insert one statement that is\n+                    // `let <pat> = <pat>;`. We re-use the original argument's pattern so that\n+                    // `HirId`s are densely assigned.\n+                    let expr = this.expr_ident(desugared_span, ident, new_argument_id);\n+                    let stmt = this.stmt_let_pat(\n+                        stmt_attrs,\n+                        desugared_span,\n+                        Some(P(expr)),\n+                        argument.pat,\n+                        hir::LocalSource::AsyncFn\n+                    );\n+                    statements.push(stmt);\n+                } else {\n+                    // If this is not the simple case, then we construct two statements:\n+                    //\n+                    // ```\n+                    // let __argN = __argN;\n+                    // let <pat> = __argN;\n+                    // ```\n+                    //\n+                    // The first statement moves the argument into the closure and thus ensures\n+                    // that the drop order is correct.\n+                    //\n+                    // The second statement creates the bindings that the user wrote.\n+\n+                    // Construct the `let mut __argN = __argN;` statement. It must be a mut binding\n+                    // because the user may have specified a `ref mut` binding in the next\n+                    // statement.\n+                    let (move_pat, move_id) = this.pat_ident_binding_mode(\n+                        desugared_span, ident, hir::BindingAnnotation::Mutable);\n+                    let move_expr = this.expr_ident(desugared_span, ident, new_argument_id);\n+                    let move_stmt = this.stmt_let_pat(\n+                        ThinVec::new(),\n+                        desugared_span,\n+                        Some(P(move_expr)),\n+                        move_pat,\n+                        hir::LocalSource::AsyncFn\n+                    );\n+\n+                    // Construct the `let <pat> = __argN;` statement. We re-use the original\n+                    // argument's pattern so that `HirId`s are densely assigned.\n+                    let pattern_expr = this.expr_ident(desugared_span, ident, move_id);\n+                    let pattern_stmt = this.stmt_let_pat(\n+                        stmt_attrs,\n+                        desugared_span,\n+                        Some(P(pattern_expr)),\n+                        argument.pat,\n+                        hir::LocalSource::AsyncFn\n+                    );\n+\n+                    statements.push(move_stmt);\n+                    statements.push(pattern_stmt);\n+                };\n+\n+                arguments.push(new_argument);\n+            }\n+\n+            let async_expr = this.make_async_expr(\n+                CaptureBy::Value, closure_id, None, body.span,\n+                |this| {\n+                    let body = this.lower_block_with_stmts(body, false, statements);\n+                    this.expr_block(body, ThinVec::new())\n+                });\n+            (HirVec::from(arguments), this.expr(body.span, async_expr, ThinVec::new()))\n+        })\n+    }\n+\n+    fn lower_method_sig(\n+        &mut self,\n+        generics: &Generics,\n+        sig: &MethodSig,\n+        fn_def_id: DefId,\n+        impl_trait_return_allow: bool,\n+        is_async: Option<NodeId>,\n+    ) -> (hir::Generics, hir::MethodSig) {\n+        let header = self.lower_fn_header(sig.header);\n+        let (generics, decl) = self.add_in_band_defs(\n+            generics,\n+            fn_def_id,\n+            AnonymousLifetimeMode::PassThrough,\n+            |this, idty| this.lower_fn_decl(\n+                &sig.decl,\n+                Some((fn_def_id, idty)),\n+                impl_trait_return_allow,\n+                is_async,\n+            ),\n+        );\n+        (generics, hir::MethodSig { header, decl })\n+    }\n+\n+    fn lower_is_auto(&mut self, a: IsAuto) -> hir::IsAuto {\n+        match a {\n+            IsAuto::Yes => hir::IsAuto::Yes,\n+            IsAuto::No => hir::IsAuto::No,\n+        }\n+    }\n+\n+    fn lower_fn_header(&mut self, h: FnHeader) -> hir::FnHeader {\n+        hir::FnHeader {\n+            unsafety: self.lower_unsafety(h.unsafety),\n+            asyncness: self.lower_asyncness(h.asyncness.node),\n+            constness: self.lower_constness(h.constness),\n+            abi: h.abi,\n+        }\n+    }\n+\n+    pub(super) fn lower_unsafety(&mut self, u: Unsafety) -> hir::Unsafety {\n+        match u {\n+            Unsafety::Unsafe => hir::Unsafety::Unsafe,\n+            Unsafety::Normal => hir::Unsafety::Normal,\n+        }\n+    }\n+\n+    fn lower_constness(&mut self, c: Spanned<Constness>) -> hir::Constness {\n+        match c.node {\n+            Constness::Const => hir::Constness::Const,\n+            Constness::NotConst => hir::Constness::NotConst,\n+        }\n+    }\n+\n+    fn lower_asyncness(&mut self, a: IsAsync) -> hir::IsAsync {\n+        match a {\n+            IsAsync::Async { .. } => hir::IsAsync::Async,\n+            IsAsync::NotAsync => hir::IsAsync::NotAsync,\n+        }\n+    }\n+\n+    pub(super) fn lower_generics(\n+        &mut self,\n+        generics: &Generics,\n+        itctx: ImplTraitContext<'_>)\n+        -> hir::Generics\n+    {\n+        // Collect `?Trait` bounds in where clause and move them to parameter definitions.\n+        // FIXME: this could probably be done with less rightward drift. It also looks like two\n+        // control paths where `report_error` is called are the only paths that advance to after the\n+        // match statement, so the error reporting could probably just be moved there.\n+        let mut add_bounds: NodeMap<Vec<_>> = Default::default();\n+        for pred in &generics.where_clause.predicates {\n+            if let WherePredicate::BoundPredicate(ref bound_pred) = *pred {\n+                'next_bound: for bound in &bound_pred.bounds {\n+                    if let GenericBound::Trait(_, TraitBoundModifier::Maybe) = *bound {\n+                        let report_error = |this: &mut Self| {\n+                            this.diagnostic().span_err(\n+                                bound_pred.bounded_ty.span,\n+                                \"`?Trait` bounds are only permitted at the \\\n+                                 point where a type parameter is declared\",\n+                            );\n+                        };\n+                        // Check if the where clause type is a plain type parameter.\n+                        match bound_pred.bounded_ty.node {\n+                            TyKind::Path(None, ref path)\n+                                if path.segments.len() == 1\n+                                    && bound_pred.bound_generic_params.is_empty() =>\n+                            {\n+                                if let Some(Res::Def(DefKind::TyParam, def_id)) = self.resolver\n+                                    .get_partial_res(bound_pred.bounded_ty.id)\n+                                    .map(|d| d.base_res())\n+                                {\n+                                    if let Some(node_id) =\n+                                        self.resolver.definitions().as_local_node_id(def_id)\n+                                    {\n+                                        for param in &generics.params {\n+                                            match param.kind {\n+                                                GenericParamKind::Type { .. } => {\n+                                                    if node_id == param.id {\n+                                                        add_bounds.entry(param.id)\n+                                                            .or_default()\n+                                                            .push(bound.clone());\n+                                                        continue 'next_bound;\n+                                                    }\n+                                                }\n+                                                _ => {}\n+                                            }\n+                                        }\n+                                    }\n+                                }\n+                                report_error(self)\n+                            }\n+                            _ => report_error(self),\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        hir::Generics {\n+            params: self.lower_generic_params(&generics.params, &add_bounds, itctx),\n+            where_clause: self.lower_where_clause(&generics.where_clause),\n+            span: generics.span,\n+        }\n+    }\n+\n+    fn lower_where_clause(&mut self, wc: &WhereClause) -> hir::WhereClause {\n+        self.with_anonymous_lifetime_mode(\n+            AnonymousLifetimeMode::ReportError,\n+            |this| {\n+                hir::WhereClause {\n+                    predicates: wc.predicates\n+                        .iter()\n+                        .map(|predicate| this.lower_where_predicate(predicate))\n+                        .collect(),\n+                    span: wc.span,\n+                }\n+            },\n+        )\n+    }\n+\n+    fn lower_where_predicate(&mut self, pred: &WherePredicate) -> hir::WherePredicate {\n+        match *pred {\n+            WherePredicate::BoundPredicate(WhereBoundPredicate {\n+                ref bound_generic_params,\n+                ref bounded_ty,\n+                ref bounds,\n+                span,\n+            }) => {\n+                self.with_in_scope_lifetime_defs(\n+                    &bound_generic_params,\n+                    |this| {\n+                        hir::WherePredicate::BoundPredicate(hir::WhereBoundPredicate {\n+                            bound_generic_params: this.lower_generic_params(\n+                                bound_generic_params,\n+                                &NodeMap::default(),\n+                                ImplTraitContext::disallowed(),\n+                            ),\n+                            bounded_ty: this.lower_ty(bounded_ty, ImplTraitContext::disallowed()),\n+                            bounds: bounds\n+                                .iter()\n+                                .filter_map(|bound| match *bound {\n+                                    // Ignore `?Trait` bounds.\n+                                    // They were copied into type parameters already.\n+                                    GenericBound::Trait(_, TraitBoundModifier::Maybe) => None,\n+                                    _ => Some(this.lower_param_bound(\n+                                        bound,\n+                                        ImplTraitContext::disallowed(),\n+                                    )),\n+                                })\n+                                .collect(),\n+                            span,\n+                        })\n+                    },\n+                )\n+            }\n+            WherePredicate::RegionPredicate(WhereRegionPredicate {\n+                ref lifetime,\n+                ref bounds,\n+                span,\n+            }) => hir::WherePredicate::RegionPredicate(hir::WhereRegionPredicate {\n+                span,\n+                lifetime: self.lower_lifetime(lifetime),\n+                bounds: self.lower_param_bounds(bounds, ImplTraitContext::disallowed()),\n+            }),\n+            WherePredicate::EqPredicate(WhereEqPredicate {\n+                id,\n+                ref lhs_ty,\n+                ref rhs_ty,\n+                span,\n+            }) => {\n+                hir::WherePredicate::EqPredicate(hir::WhereEqPredicate {\n+                    hir_id: self.lower_node_id(id),\n+                    lhs_ty: self.lower_ty(lhs_ty, ImplTraitContext::disallowed()),\n+                    rhs_ty: self.lower_ty(rhs_ty, ImplTraitContext::disallowed()),\n+                    span,\n+                })\n+            },\n+        }\n+    }\n+}"}]}