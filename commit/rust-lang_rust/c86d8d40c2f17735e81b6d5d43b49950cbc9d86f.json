{"sha": "c86d8d40c2f17735e81b6d5d43b49950cbc9d86f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM4NmQ4ZDQwYzJmMTc3MzVlODFiNmQ1ZDQzYjQ5OTUwY2JjOWQ4NmY=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-03-31T22:39:50Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-04-01T07:42:23Z"}, "message": "Streamline flycheck implementation", "tree": {"sha": "61d8ea097f59043803b9b66d7bba5f52ffddfc50", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/61d8ea097f59043803b9b66d7bba5f52ffddfc50"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c86d8d40c2f17735e81b6d5d43b49950cbc9d86f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c86d8d40c2f17735e81b6d5d43b49950cbc9d86f", "html_url": "https://github.com/rust-lang/rust/commit/c86d8d40c2f17735e81b6d5d43b49950cbc9d86f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c86d8d40c2f17735e81b6d5d43b49950cbc9d86f/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b46fd3863203d662531c735389b4008d8a715561", "url": "https://api.github.com/repos/rust-lang/rust/commits/b46fd3863203d662531c735389b4008d8a715561", "html_url": "https://github.com/rust-lang/rust/commit/b46fd3863203d662531c735389b4008d8a715561"}], "stats": {"total": 148, "additions": 68, "deletions": 80}, "files": [{"sha": "f6f9171add8eddfc38919ccea21e06be5811373e", "filename": "crates/ra_flycheck/src/lib.rs", "status": "modified", "additions": 68, "deletions": 80, "changes": 148, "blob_url": "https://github.com/rust-lang/rust/blob/c86d8d40c2f17735e81b6d5d43b49950cbc9d86f/crates%2Fra_flycheck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c86d8d40c2f17735e81b6d5d43b49950cbc9d86f/crates%2Fra_flycheck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_flycheck%2Fsrc%2Flib.rs?ref=c86d8d40c2f17735e81b6d5d43b49950cbc9d86f", "patch": "@@ -79,17 +79,25 @@ pub enum CheckCommand {\n struct CheckWatcherThread {\n     options: CheckConfig,\n     workspace_root: PathBuf,\n-    watcher: WatchThread,\n     last_update_req: Option<Instant>,\n+    // XXX: drop order is significant\n+    message_recv: Receiver<CheckEvent>,\n+    /// WatchThread exists to wrap around the communication needed to be able to\n+    /// run `cargo check` without blocking. Currently the Rust standard library\n+    /// doesn't provide a way to read sub-process output without blocking, so we\n+    /// have to wrap sub-processes output handling in a thread and pass messages\n+    /// back over a channel.\n+    check_process: Option<jod_thread::JoinHandle<()>>,\n }\n \n impl CheckWatcherThread {\n     fn new(options: CheckConfig, workspace_root: PathBuf) -> CheckWatcherThread {\n         CheckWatcherThread {\n             options,\n             workspace_root,\n-            watcher: WatchThread::dummy(),\n             last_update_req: None,\n+            message_recv: never(),\n+            check_process: None,\n         }\n     }\n \n@@ -106,25 +114,21 @@ impl CheckWatcherThread {\n                         break;\n                     },\n                 },\n-                recv(self.watcher.message_recv) -> msg => match msg {\n+                recv(self.message_recv) -> msg => match msg {\n                     Ok(msg) => self.handle_message(msg, task_send),\n                     Err(RecvError) => {\n                         // Watcher finished, replace it with a never channel to\n                         // avoid busy-waiting.\n-                        std::mem::replace(&mut self.watcher.message_recv, never());\n+                        self.message_recv = never();\n+                        self.check_process = None;\n                     },\n                 }\n             };\n \n             if self.should_recheck() {\n-                self.last_update_req.take();\n+                self.last_update_req = None;\n                 task_send.send(CheckTask::ClearDiagnostics).unwrap();\n-\n-                // Replace with a dummy watcher first so we drop the original and wait for completion\n-                std::mem::replace(&mut self.watcher, WatchThread::dummy());\n-\n-                // Then create the actual new watcher\n-                self.watcher = WatchThread::new(&self.options, &self.workspace_root);\n+                self.restart_check_process();\n             }\n         }\n     }\n@@ -207,6 +211,59 @@ impl CheckWatcherThread {\n             CheckEvent::Msg(Message::Unknown) => {}\n         }\n     }\n+\n+    fn restart_check_process(&mut self) {\n+        // First, clear and cancel the old thread\n+        self.message_recv = never();\n+        self.check_process = None;\n+        if !self.options.enable {\n+            return;\n+        }\n+\n+        let mut args: Vec<String> = vec![\n+            self.options.command.clone(),\n+            \"--workspace\".to_string(),\n+            \"--message-format=json\".to_string(),\n+            \"--manifest-path\".to_string(),\n+            format!(\"{}/Cargo.toml\", self.workspace_root.display()),\n+        ];\n+        if self.options.all_targets {\n+            args.push(\"--all-targets\".to_string());\n+        }\n+        args.extend(self.options.args.iter().cloned());\n+\n+        let (message_send, message_recv) = unbounded();\n+        let workspace_root = self.workspace_root.to_owned();\n+        self.message_recv = message_recv;\n+        self.check_process = Some(jod_thread::spawn(move || {\n+            // If we trigger an error here, we will do so in the loop instead,\n+            // which will break out of the loop, and continue the shutdown\n+            let _ = message_send.send(CheckEvent::Begin);\n+\n+            let res = run_cargo(&args, Some(&workspace_root), &mut |message| {\n+                // Skip certain kinds of messages to only spend time on what's useful\n+                match &message {\n+                    Message::CompilerArtifact(artifact) if artifact.fresh => return true,\n+                    Message::BuildScriptExecuted(_) => return true,\n+                    Message::Unknown => return true,\n+                    _ => {}\n+                }\n+\n+                // if the send channel was closed, we want to shutdown\n+                message_send.send(CheckEvent::Msg(message)).is_ok()\n+            });\n+\n+            if let Err(err) = res {\n+                // FIXME: make the `message_send` to be `Sender<Result<CheckEvent, CargoError>>`\n+                // to display user-caused misconfiguration errors instead of just logging them here\n+                log::error!(\"Cargo watcher failed {:?}\", err);\n+            }\n+\n+            // We can ignore any error here, as we are already in the progress\n+            // of shutting down.\n+            let _ = message_send.send(CheckEvent::End);\n+        }))\n+    }\n }\n \n #[derive(Debug)]\n@@ -215,19 +272,6 @@ pub struct DiagnosticWithFixes {\n     fixes: Vec<CodeAction>,\n }\n \n-/// WatchThread exists to wrap around the communication needed to be able to\n-/// run `cargo check` without blocking. Currently the Rust standard library\n-/// doesn't provide a way to read sub-process output without blocking, so we\n-/// have to wrap sub-processes output handling in a thread and pass messages\n-/// back over a channel.\n-/// The correct way to dispose of the thread is to drop it, on which the\n-/// sub-process will be killed, and the thread will be joined.\n-struct WatchThread {\n-    // XXX: drop order is significant\n-    message_recv: Receiver<CheckEvent>,\n-    _handle: Option<jod_thread::JoinHandle<()>>,\n-}\n-\n enum CheckEvent {\n     Begin,\n     Msg(cargo_metadata::Message),\n@@ -317,59 +361,3 @@ fn run_cargo(\n \n     Err(CargoError(err_msg))\n }\n-\n-impl WatchThread {\n-    fn dummy() -> WatchThread {\n-        WatchThread { message_recv: never(), _handle: None }\n-    }\n-\n-    fn new(options: &CheckConfig, workspace_root: &Path) -> WatchThread {\n-        let mut args: Vec<String> = vec![\n-            options.command.clone(),\n-            \"--workspace\".to_string(),\n-            \"--message-format=json\".to_string(),\n-            \"--manifest-path\".to_string(),\n-            format!(\"{}/Cargo.toml\", workspace_root.display()),\n-        ];\n-        if options.all_targets {\n-            args.push(\"--all-targets\".to_string());\n-        }\n-        args.extend(options.args.iter().cloned());\n-\n-        let (message_send, message_recv) = unbounded();\n-        let workspace_root = workspace_root.to_owned();\n-        let handle = if options.enable {\n-            Some(jod_thread::spawn(move || {\n-                // If we trigger an error here, we will do so in the loop instead,\n-                // which will break out of the loop, and continue the shutdown\n-                let _ = message_send.send(CheckEvent::Begin);\n-\n-                let res = run_cargo(&args, Some(&workspace_root), &mut |message| {\n-                    // Skip certain kinds of messages to only spend time on what's useful\n-                    match &message {\n-                        Message::CompilerArtifact(artifact) if artifact.fresh => return true,\n-                        Message::BuildScriptExecuted(_) => return true,\n-                        Message::Unknown => return true,\n-                        _ => {}\n-                    }\n-\n-                    // if the send channel was closed, we want to shutdown\n-                    message_send.send(CheckEvent::Msg(message)).is_ok()\n-                });\n-\n-                if let Err(err) = res {\n-                    // FIXME: make the `message_send` to be `Sender<Result<CheckEvent, CargoError>>`\n-                    // to display user-caused misconfiguration errors instead of just logging them here\n-                    log::error!(\"Cargo watcher failed {:?}\", err);\n-                }\n-\n-                // We can ignore any error here, as we are already in the progress\n-                // of shutting down.\n-                let _ = message_send.send(CheckEvent::End);\n-            }))\n-        } else {\n-            None\n-        };\n-        WatchThread { message_recv, _handle: handle }\n-    }\n-}"}]}