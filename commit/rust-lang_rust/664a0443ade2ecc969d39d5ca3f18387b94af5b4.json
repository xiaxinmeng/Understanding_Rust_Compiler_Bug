{"sha": "664a0443ade2ecc969d39d5ca3f18387b94af5b4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY2NGEwNDQzYWRlMmVjYzk2OWQzOWQ1Y2EzZjE4Mzg3Yjk0YWY1YjQ=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-12-29T12:12:52Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2012-01-02T14:15:27Z"}, "message": "More resolving and typechecking of bounded type parameters.\n\nExtern interfaces still don't get recognized.\n\nIssue #1227", "tree": {"sha": "396745a9f593d8e758355afcec81237979f6eb21", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/396745a9f593d8e758355afcec81237979f6eb21"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/664a0443ade2ecc969d39d5ca3f18387b94af5b4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/664a0443ade2ecc969d39d5ca3f18387b94af5b4", "html_url": "https://github.com/rust-lang/rust/commit/664a0443ade2ecc969d39d5ca3f18387b94af5b4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/664a0443ade2ecc969d39d5ca3f18387b94af5b4/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "40d5f288c35865dc636e19d993260d5983b4fa55", "url": "https://api.github.com/repos/rust-lang/rust/commits/40d5f288c35865dc636e19d993260d5983b4fa55", "html_url": "https://github.com/rust-lang/rust/commit/40d5f288c35865dc636e19d993260d5983b4fa55"}], "stats": {"total": 266, "additions": 211, "deletions": 55}, "files": [{"sha": "3da705f41efc60c221a0360241c014e486665160", "filename": "src/comp/metadata/csearch.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/664a0443ade2ecc969d39d5ca3f18387b94af5b4/src%2Fcomp%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/664a0443ade2ecc969d39d5ca3f18387b94af5b4/src%2Fcomp%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fcsearch.rs?ref=664a0443ade2ecc969d39d5ca3f18387b94af5b4", "patch": "@@ -72,6 +72,7 @@ fn get_impls_for_mod(cstore: cstore::cstore, def: ast::def_id,\n         let nm = decoder::lookup_item_name(cdata, did.node);\n         if alt name { some(n) { n == nm } none. { true } } {\n             result += [@{did: did,\n+                         iface_did: none::<ast::def_id>, // FIXME[impl]\n                          ident: nm,\n                          methods: decoder::lookup_impl_methods(\n                              cdata, did.node, did.crate)}];"}, {"sha": "b920a9758b13eda304a3d8aca70f0bed6dbac502", "filename": "src/comp/middle/kind.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/664a0443ade2ecc969d39d5ca3f18387b94af5b4/src%2Fcomp%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/664a0443ade2ecc969d39d5ca3f18387b94af5b4/src%2Fcomp%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fkind.rs?ref=664a0443ade2ecc969d39d5ca3f18387b94af5b4", "patch": "@@ -163,14 +163,14 @@ fn check_expr(e: @expr, cx: ctx, v: visit::vt<ctx>) {\n         alt substs.substs {\n           some(ts) {\n             let did = ast_util::def_id_of_def(cx.tcx.def_map.get(e.id));\n-            let kinds = vec::map(ty::lookup_item_type(cx.tcx, did).bounds,\n-                                 {|bs| ty::param_bounds_to_kind(bs)});\n+            let bounds = ty::lookup_item_type(cx.tcx, did).bounds;\n             let i = 0u;\n             for ty in ts {\n                 let kind = ty::type_kind(cx.tcx, ty);\n-                if !ty::kind_lteq(kinds[i], kind) {\n+                let p_kind = ty::param_bounds_to_kind(bounds[i]);\n+                if !ty::kind_lteq(p_kind, kind) {\n                     cx.tcx.sess.span_err(e.span, \"instantiating a \" +\n-                                         kind_to_str(kinds[i]) +\n+                                         kind_to_str(p_kind) +\n                                          \" type parameter with a \"\n                                          + kind_to_str(kind) + \" type\");\n                 }"}, {"sha": "2013d9180e3b0aadf70bc985187022a02c916027", "filename": "src/comp/middle/resolve.rs", "status": "modified", "additions": 16, "deletions": 7, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/664a0443ade2ecc969d39d5ca3f18387b94af5b4/src%2Fcomp%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/664a0443ade2ecc969d39d5ca3f18387b94af5b4/src%2Fcomp%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fresolve.rs?ref=664a0443ade2ecc969d39d5ca3f18387b94af5b4", "patch": "@@ -1701,7 +1701,8 @@ fn check_exports(e: @env) {\n // Impl resolution\n \n type method_info = {did: def_id, n_tps: uint, ident: ast::ident};\n-type _impl = {did: def_id, ident: ast::ident, methods: [@method_info]};\n+type _impl = {did: def_id, iface_did: option::t<def_id>,\n+              ident: ast::ident, methods: [@method_info]};\n type iscopes = list<@[@_impl]>;\n \n fn resolve_impls(e: @env, c: @ast::crate) {\n@@ -1757,14 +1758,20 @@ fn find_impls_in_view_item(e: env, vi: @ast::view_item,\n     }\n }\n \n-fn find_impls_in_item(i: @ast::item, &impls: [@_impl],\n+fn find_impls_in_item(e: env, i: @ast::item, &impls: [@_impl],\n                       name: option::t<ident>,\n                       ck_exports: option::t<ast::_mod>) {\n     alt i.node {\n-      ast::item_impl(_, _, _, mthds) {\n+      ast::item_impl(_, ifce, _, mthds) {\n         if alt name { some(n) { n == i.ident } _ { true } } &&\n            alt ck_exports { some(m) { is_exported(i.ident, m) } _ { true } } {\n             impls += [@{did: local_def(i.id),\n+                        iface_did: alt ifce {\n+                            some(@{node: ast::ty_path(_, id), _}) {\n+                                some(def_id_of_def(e.def_map.get(id)))\n+                            }\n+                            _ { none }\n+                        },\n                         ident: i.ident,\n                         methods: vec::map(mthds, {|m|\n                             @{did: local_def(m.id),\n@@ -1788,7 +1795,7 @@ fn find_impls_in_mod(e: env, m: def, &impls: [@_impl],\n             cached = if defid.crate == ast::local_crate {\n                 let tmp = [];\n                 for i in option::get(e.mod_map.get(defid.node).m).items {\n-                    find_impls_in_item(i, tmp, name, none);\n+                    find_impls_in_item(e, i, tmp, name, none);\n                 }\n                 @tmp\n             } else {\n@@ -1816,7 +1823,7 @@ fn visit_block_with_impl_scope(e: @env, b: ast::blk, sc: iscopes,\n     for st in b.node.stmts {\n         alt st.node {\n           ast::stmt_decl(@{node: ast::decl_item(i), _}, _) {\n-            find_impls_in_item(i, impls, none, none);\n+            find_impls_in_item(*e, i, impls, none, none);\n           }\n           _ {}\n         }\n@@ -1829,13 +1836,15 @@ fn visit_mod_with_impl_scope(e: @env, m: ast::_mod, s: span, sc: iscopes,\n                              v: vt<iscopes>) {\n     let impls = [];\n     for vi in m.view_items { find_impls_in_view_item(*e, vi, impls, sc); }\n-    for i in m.items { find_impls_in_item(i, impls, none, none); }\n+    for i in m.items { find_impls_in_item(*e, i, impls, none, none); }\n     visit::visit_mod(m, s, vec::len(impls) > 0u ? cons(@impls, @sc) : sc, v);\n }\n \n fn resolve_impl_in_expr(e: @env, x: @ast::expr, sc: iscopes, v: vt<iscopes>) {\n     alt x.node {\n-      ast::expr_field(_, _, _) { e.impl_map.insert(x.id, sc); }\n+      ast::expr_field(_, _, _) | ast::expr_path(_) {\n+        e.impl_map.insert(x.id, sc);\n+      }\n       _ {}\n     }\n     visit::visit_expr(x, sc, v);"}, {"sha": "c843f6e524d4b965e19baf0030a1f1cd81dd1612", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/664a0443ade2ecc969d39d5ca3f18387b94af5b4/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/664a0443ade2ecc969d39d5ca3f18387b94af5b4/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=664a0443ade2ecc969d39d5ca3f18387b94af5b4", "patch": "@@ -2858,9 +2858,12 @@ fn trans_callee(bcx: @block_ctxt, e: @ast::expr) -> lval_maybe_callee {\n         // Lval means this is a record field, so not a method\n         if !expr_is_lval(bcx, e) {\n             alt bcx_ccx(bcx).method_map.find(e.id) {\n-              some(did) { // An impl method\n+              some(typeck::method_static(did)) { // An impl method\n                 ret trans_method_callee(bcx, e, base, did);\n               }\n+              some(typeck::method_param(_)) {\n+                fail \"not implemented\"; // FIXME[impl]\n+              }\n               none. { // An object method\n                 let of = trans_object_field(bcx, base, ident);\n                 ret {bcx: of.bcx, val: of.mthptr, kind: owned,"}, {"sha": "dad0a1609f4105a2ca052d6be3ba0be0d64ba2cf", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 25, "deletions": 9, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/664a0443ade2ecc969d39d5ca3f18387b94af5b4/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/664a0443ade2ecc969d39d5ca3f18387b94af5b4/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=664a0443ade2ecc969d39d5ca3f18387b94af5b4", "patch": "@@ -814,7 +814,7 @@ fn fold_ty(cx: ctxt, fld: fold_mode, ty_0: t) -> t {\n         alt fld { fm_var(folder) { ty = folder(id); } _ {/* no-op */ } }\n       }\n       ty_param(id, did) {\n-        alt fld { fm_param(folder) { ty = folder(id, did); } _ {/* no-op */ } }\n+        alt fld { fm_param(folder) { ty = folder(id, did); } _ {} }\n       }\n     }\n \n@@ -1731,6 +1731,7 @@ mod unify {\n     export ures_ok;\n     export ures_err;\n     export var_bindings;\n+    export precise, in_bindings, bind_params;\n \n     tag result { ures_ok(t); ures_err(type_err); }\n     tag union_result { unres_ok; unres_err(type_err); }\n@@ -1741,7 +1742,12 @@ mod unify {\n     type var_bindings =\n         {sets: ufind::ufind, types: smallintmap::smallintmap<t>};\n \n-    type ctxt = {vb: option::t<@var_bindings>, tcx: ty_ctxt};\n+    tag unify_style {\n+        precise;\n+        in_bindings(@var_bindings);\n+        bind_params(@mutable [mutable option::t<t>]);\n+    }\n+    type ctxt = {st: unify_style, tcx: ty_ctxt};\n \n     fn mk_var_bindings() -> @var_bindings {\n         ret @{sets: ufind::make(), types: smallintmap::mk::<t>()};\n@@ -1750,7 +1756,9 @@ mod unify {\n     // Unifies two sets.\n     fn union(cx: @ctxt, set_a: uint, set_b: uint,\n              variance: variance) -> union_result {\n-        let vb = option::get(cx.vb);\n+        let vb = alt cx.st {\n+            in_bindings(vb) { vb }\n+        };\n         ufind::grow(vb.sets, float::max(set_a, set_b) + 1u);\n         let root_a = ufind::find(vb.sets, set_a);\n         let root_b = ufind::find(vb.sets, set_b);\n@@ -1800,7 +1808,7 @@ mod unify {\n     fn record_var_binding(\n         cx: @ctxt, key: int, typ: t, variance: variance) -> result {\n \n-        let vb = option::get(cx.vb);\n+        let vb = alt cx.st { in_bindings(vb) { vb } };\n         ufind::grow(vb.sets, (key as uint) + 1u);\n         let root = ufind::find(vb.sets, key as uint);\n         let result_type = typ;\n@@ -2136,7 +2144,6 @@ mod unify {\n           // If the RHS is a variable type, then just do the\n           // appropriate binding.\n           ty::ty_var(actual_id) {\n-            assert option::is_some(cx.vb);\n             let actual_n = actual_id as uint;\n             alt struct(cx.tcx, expected) {\n               ty::ty_var(expected_id) {\n@@ -2157,11 +2164,20 @@ mod unify {\n             }\n             ret ures_ok(mk_var(cx.tcx, actual_id));\n           }\n+          ty::ty_param(n, _) {\n+            alt cx.st {\n+              bind_params(cell) {\n+                while vec::len(*cell) < n + 1u { *cell += [mutable none]; }\n+                cell[n] = some(expected);\n+                ret ures_ok(expected);\n+              }\n+              _ {}\n+            }\n+          }\n           _ {/* empty */ }\n         }\n         alt struct(cx.tcx, expected) {\n           ty::ty_var(expected_id) {\n-            assert option::is_some(cx.vb);\n             // Add a binding. (`actual` can't actually be a var here.)\n             alt record_var_binding_for_expected(\n                 cx, expected_id, actual,\n@@ -2478,9 +2494,9 @@ mod unify {\n           }\n         }\n     }\n-    fn unify(expected: t, actual: t, vb: option::t<@var_bindings>,\n+    fn unify(expected: t, actual: t, st: unify_style,\n              tcx: ty_ctxt) -> result {\n-        let cx = @{vb: vb, tcx: tcx};\n+        let cx = @{st: st, tcx: tcx};\n         ret unify_step(cx, expected, actual, covariant);\n     }\n     fn dump_var_bindings(tcx: ty_ctxt, vb: @var_bindings) {\n@@ -2553,7 +2569,7 @@ mod unify {\n }\n \n fn same_type(cx: ctxt, a: t, b: t) -> bool {\n-    alt unify::unify(a, b, none, cx) {\n+    alt unify::unify(a, b, unify::precise, cx) {\n       unify::ures_ok(_) { true }\n       _ { false }\n     }"}, {"sha": "a86a29d9f1a28f43e9e85c78729c1d1b53526fe7", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 161, "deletions": 34, "changes": 195, "blob_url": "https://github.com/rust-lang/rust/blob/664a0443ade2ecc969d39d5ca3f18387b94af5b4/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/664a0443ade2ecc969d39d5ca3f18387b94af5b4/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=664a0443ade2ecc969d39d5ca3f18387b94af5b4", "patch": "@@ -18,9 +18,13 @@ import std::map::{hashmap, new_int_hash};\n import option::{none, some};\n import syntax::print::pprust::*;\n \n-export check_crate, method_map;\n+export check_crate, method_map, method_origin, method_static, method_param;\n \n-type method_map = hashmap<ast::node_id, ast::def_id>;\n+tag method_origin {\n+    method_static(ast::def_id);\n+    method_param(uint);\n+}\n+type method_map = hashmap<ast::node_id, method_origin>;\n \n type ty_table = hashmap<ast::def_id, ty::t>;\n \n@@ -798,7 +802,8 @@ mod collect {\n mod unify {\n     fn unify(fcx: @fn_ctxt, expected: ty::t, actual: ty::t) ->\n        ty::unify::result {\n-        ret ty::unify::unify(expected, actual, some(fcx.var_bindings),\n+        ret ty::unify::unify(expected, actual,\n+                             ty::unify::in_bindings(fcx.var_bindings),\n                              fcx.ccx.tcx);\n     }\n }\n@@ -1115,7 +1120,8 @@ fn gather_locals(ccx: @crate_ctxt,\n             alt ty_opt {\n               none. {/* nothing to do */ }\n               some(typ) {\n-                ty::unify::unify(ty::mk_var(tcx, var_id), typ, some(vb), tcx);\n+                ty::unify::unify(ty::mk_var(tcx, var_id), typ,\n+                                 ty::unify::in_bindings(vb), tcx);\n               }\n             }\n         };\n@@ -1465,39 +1471,89 @@ fn check_expr_with(fcx: @fn_ctxt, expr: @ast::expr, expected: ty::t) -> bool {\n     ret check_expr_with_unifier(fcx, expr, demand::simple, expected);\n }\n \n+fn impl_self_ty(tcx: ty::ctxt, did: ast::def_id) -> {n_tps: uint, ty: ty::t} {\n+    if did.crate == ast::local_crate {\n+        alt tcx.items.get(did.node) {\n+          ast_map::node_item(@{node: ast::item_impl(ts, _, st, _),\n+                               _}) {\n+            {n_tps: vec::len(ts), ty: ast_ty_to_ty(tcx, m_check, st)}\n+          }\n+        }\n+    } else {\n+        let tpt = csearch::get_type(tcx, did);\n+        {n_tps: vec::len(tpt.bounds), ty: tpt.ty}\n+    }\n+}\n+\n fn lookup_method(fcx: @fn_ctxt, isc: resolve::iscopes,\n                  name: ast::ident, ty: ty::t, sp: span)\n-    -> option::t<{method: @resolve::method_info, ids: [int]}> {\n+    -> option::t<{method_ty: ty::t, n_tps: uint, ids: [int],\n+                  origin: method_origin}> {\n+    let tcx = fcx.ccx.tcx;\n+\n+    // First, see whether this is an interface-bounded parameter\n+    alt ty::struct(tcx, ty) {\n+      ty::ty_param(n, did) {\n+        for bound in *tcx.ty_param_bounds.get(did) {\n+            alt bound {\n+              ty::bound_iface(t) {\n+                let (iid, _tps) = alt ty::struct(tcx, t) {\n+                    ty::ty_iface(i, tps) { (i, tps) }\n+                    _ { ret none; }\n+                };\n+                alt vec::find(*ty::iface_methods(tcx, iid),\n+                              {|m| m.ident == name}) {\n+                  some(m) {\n+                    ret some({method_ty: ty::mk_fn(tcx, m.fty),\n+                              n_tps: vec::len(m.tps),\n+                              ids: [], // FIXME[impl]\n+                              origin: method_param(n)});\n+                  }\n+                  _ {}\n+                }\n+              }\n+              _ {}\n+            }\n+        }\n+        ret none;\n+      }\n+      _ {}\n+    }\n+\n+    fn ty_from_did(tcx: ty::ctxt, did: ast::def_id) -> ty::t {\n+        if did.crate == ast::local_crate {\n+            alt tcx.items.get(did.node) {\n+              ast_map::node_method(m) {\n+                let mt = ty_of_method(tcx, m_check, m);\n+                ty::mk_fn(tcx, mt.fty)\n+              }\n+            }\n+        } else { csearch::get_type(tcx, did).ty }\n+    }\n+\n     let result = none;\n     std::list::iter(isc) {|impls|\n         if option::is_some(result) { ret; }\n         for @{did, methods, _} in *impls {\n             alt vec::find(methods, {|m| m.ident == name}) {\n               some(m) {\n-                let (n_tps, self_ty) = if did.crate == ast::local_crate {\n-                    alt fcx.ccx.tcx.items.get(did.node) {\n-                      ast_map::node_item(@{node: ast::item_impl(ts, _, st, _),\n-                                           _}) {\n-                        (vec::len(ts), ast_ty_to_ty_crate(fcx.ccx, st))\n-                      }\n-                    }\n-                } else {\n-                    let tpt = csearch::get_type(fcx.ccx.tcx, did);\n-                    (vec::len(tpt.bounds), tpt.ty)\n-                };\n+                let {n_tps, ty: self_ty} = impl_self_ty(tcx, did);\n                 let {ids, ty: self_ty} = if n_tps > 0u {\n-                    bind_params_in_type(ast_util::dummy_sp(), fcx.ccx.tcx,\n+                    bind_params_in_type(ast_util::dummy_sp(), tcx,\n                                         bind next_ty_var_id(fcx), self_ty,\n                                         n_tps)\n                 } else { {ids: [], ty: self_ty} };\n                 alt unify::unify(fcx, ty, self_ty) {\n                   ures_ok(_) {\n                     if option::is_some(result) {\n                         // FIXME[impl] score specificity to resolve ambiguity?\n-                        fcx.ccx.tcx.sess.span_err(\n+                        tcx.sess.span_err(\n                             sp, \"multiple applicable methods in scope\");\n                     } else {\n-                        result = some({method: m, ids: ids});\n+                        result = some({method_ty: ty_from_did(tcx, m.did),\n+                                       n_tps: m.n_tps,\n+                                       ids: ids,\n+                                       origin: method_static(m.did)});\n                     }\n                   }\n                   _ {}\n@@ -2153,7 +2209,8 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n       }\n       ast::expr_field(base, field, tys) {\n         bot |= check_expr(fcx, base);\n-        let expr_t = expr_ty(tcx, base);\n+        let expr_t = structurally_resolved_type(fcx, expr.span,\n+                                                expr_ty(tcx, base));\n         let base_t = do_autoderef(fcx, expr.span, expr_t);\n         let handled = false, n_tys = vec::len(tys);\n         alt structure_of(fcx, expr.span, base_t) {\n@@ -2191,31 +2248,22 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n         if !handled {\n             let iscope = fcx.ccx.impl_map.get(expr.id);\n             alt lookup_method(fcx, iscope, field, expr_t, expr.span) {\n-              some({method, ids}) {\n-                let fty = if method.did.crate == ast::local_crate {\n-                    alt tcx.items.get(method.did.node) {\n-                      ast_map::node_method(m) {\n-                        let mt = ty_of_method(tcx, m_check, m);\n-                        ty::mk_fn(tcx, mt.fty)\n-                      }\n-                    }\n-                } else { csearch::get_type(tcx, method.did).ty };\n+              some({method_ty: fty, n_tps: method_n_tps, ids, origin}) {\n                 let tvars = vec::map(ids, {|id| ty::mk_var(tcx, id)});\n                 let n_tps = vec::len(ids);\n-                if method.n_tps + n_tps  > 0u {\n+                if method_n_tps + n_tps  > 0u {\n                     let b = bind_params_in_type(expr.span, tcx,\n                                                 bind next_ty_var_id(fcx), fty,\n-                                                n_tps + method.n_tps);\n+                                                n_tps + method_n_tps);\n                     let _tvars = vec::map(b.ids, {|id| ty::mk_var(tcx, id)});\n                     let i = 0;\n                     for v in tvars {\n                         demand::simple(fcx, expr.span, v, _tvars[i]);\n                         i += 1;\n                     }\n                     tvars = _tvars;\n-                    fty = b.ty;\n                     if n_tys > 0u {\n-                        if n_tys != method.n_tps {\n+                        if n_tys != method_n_tps {\n                             tcx.sess.span_fatal\n                                 (expr.span, \"incorrect number of type \\\n                                            parameters given for this method\");\n@@ -2235,7 +2283,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n                                          parameters\");\n                 }\n                 write::ty_fixup(fcx, id, {substs: some(tvars), ty: fty});\n-                fcx.ccx.method_map.insert(id, method.did);\n+                fcx.ccx.method_map.insert(id, origin);\n               }\n               none. {\n                 let t_err = resolve_type_vars_if_possible(fcx, expr_t);\n@@ -2807,6 +2855,84 @@ fn check_for_main_fn(tcx: ty::ctxt, crate: @ast::crate) {\n     }\n }\n \n+// Detect points where an interface-bounded type parameter is instantiated,\n+// resolve the impls for the parameters.\n+fn resolve_vtables(tcx: ty::ctxt, impl_map: resolve::impl_map,\n+                   crate: @ast::crate) {\n+    type ccx = {tcx: ty::ctxt, impl_map: resolve::impl_map};\n+    let cx = {tcx: tcx, impl_map: impl_map};\n+    fn resolve_expr(ex: @ast::expr, cx: ccx, v: visit::vt<ccx>) {\n+        alt ex.node {\n+          ast::expr_path(_) {\n+            let substs = ty::node_id_to_ty_param_substs_opt_and_ty(\n+                cx.tcx, ex.id);\n+            alt substs.substs {\n+              some(ts) {\n+                let did = ast_util::def_id_of_def(cx.tcx.def_map.get(ex.id));\n+                let item_ty = ty::lookup_item_type(cx.tcx, did), i = 0u;\n+                for s_ty in ts {\n+                    for bound in *item_ty.bounds[i] {\n+                        alt bound {\n+                          ty::bound_iface(i_ty) {\n+                            let impls = cx.impl_map.get(ex.id);\n+                            lookup_impl(cx, impls, ex.span, s_ty, i_ty);\n+                          }\n+                          _ {}\n+                        }\n+                    }\n+                    i += 1u;\n+                }\n+              }\n+              _ {}\n+            }\n+          }\n+          _ {}\n+        }\n+        visit::visit_expr(ex, cx, v);\n+    }\n+    fn lookup_impl(cx: ccx, isc: resolve::iscopes, sp: span,\n+                   sub_ty: ty::t, iface_ty: ty::t) {\n+        let iface_id = alt ty::struct(cx.tcx, iface_ty) {\n+            ty::ty_iface(did, _) { did }\n+            _ { ret; }\n+        };\n+        let found = false;\n+        std::list::iter(isc) {|impls|\n+            if found { ret; }\n+            for im in *impls {\n+                if im.iface_did == some(iface_id) {\n+                    let self_ty = impl_self_ty(cx.tcx, im.did).ty;\n+                    let params = @mutable [mutable];\n+                    alt ty::unify::unify(sub_ty, self_ty,\n+                                         ty::unify::bind_params(params),\n+                                         cx.tcx) {\n+                      ures_ok(_) {\n+                        if found {\n+                            cx.tcx.sess.span_err(\n+                                sp, \"multiple applicable implementations in \\\n+                                     scope\");\n+                        } else {\n+                            found = true;\n+                        }\n+                      }\n+                      _ {}\n+                    }\n+                }\n+            }\n+        }\n+        if !found {\n+            cx.tcx.sess.span_err(\n+                sp, \"failed to find an implementation of interface \" +\n+                ty_to_str(cx.tcx, iface_ty) + \" for \" +\n+                ty_to_str(cx.tcx, sub_ty));\n+        }\n+    }\n+    visit::visit_crate(*crate, cx, visit::mk_vt(@{\n+        visit_expr: resolve_expr\n+        with *visit::default_visitor()\n+    }));\n+}\n+\n fn check_crate(tcx: ty::ctxt, impl_map: resolve::impl_map,\n                crate: @ast::crate) -> method_map {\n     collect::collect_item_types(tcx, crate);\n@@ -2821,6 +2947,7 @@ fn check_crate(tcx: ty::ctxt, impl_map: resolve::impl_map,\n                                        bind check_native_item(ccx, _)\n                                    with *visit::default_simple_visitor()});\n     visit::visit_crate(*crate, (), visit);\n+    resolve_vtables(tcx, impl_map, crate);\n     check_for_main_fn(tcx, crate);\n     tcx.sess.abort_if_errors();\n     ccx.method_map"}]}