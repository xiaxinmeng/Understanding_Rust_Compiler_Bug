{"sha": "5782dc0eb992a4975eca370345e1ba455d12faa4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU3ODJkYzBlYjk5MmE0OTc1ZWNhMzcwMzQ1ZTFiYTQ1NWQxMmZhYTQ=", "commit": {"author": {"name": "Cameron Steffen", "email": "cam.steffen94@gmail.com", "date": "2021-09-09T20:35:26Z"}, "committer": {"name": "Cameron Steffen", "email": "cam.steffen94@gmail.com", "date": "2021-09-09T22:10:59Z"}, "message": "Fix redundant closure bugs", "tree": {"sha": "1fc78e96a8c59c8c54a203004e8d053a289d633b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1fc78e96a8c59c8c54a203004e8d053a289d633b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5782dc0eb992a4975eca370345e1ba455d12faa4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5782dc0eb992a4975eca370345e1ba455d12faa4", "html_url": "https://github.com/rust-lang/rust/commit/5782dc0eb992a4975eca370345e1ba455d12faa4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5782dc0eb992a4975eca370345e1ba455d12faa4/comments", "author": {"login": "camsteffen", "id": 5565418, "node_id": "MDQ6VXNlcjU1NjU0MTg=", "avatar_url": "https://avatars.githubusercontent.com/u/5565418?v=4", "gravatar_id": "", "url": "https://api.github.com/users/camsteffen", "html_url": "https://github.com/camsteffen", "followers_url": "https://api.github.com/users/camsteffen/followers", "following_url": "https://api.github.com/users/camsteffen/following{/other_user}", "gists_url": "https://api.github.com/users/camsteffen/gists{/gist_id}", "starred_url": "https://api.github.com/users/camsteffen/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/camsteffen/subscriptions", "organizations_url": "https://api.github.com/users/camsteffen/orgs", "repos_url": "https://api.github.com/users/camsteffen/repos", "events_url": "https://api.github.com/users/camsteffen/events{/privacy}", "received_events_url": "https://api.github.com/users/camsteffen/received_events", "type": "User", "site_admin": false}, "committer": {"login": "camsteffen", "id": 5565418, "node_id": "MDQ6VXNlcjU1NjU0MTg=", "avatar_url": "https://avatars.githubusercontent.com/u/5565418?v=4", "gravatar_id": "", "url": "https://api.github.com/users/camsteffen", "html_url": "https://github.com/camsteffen", "followers_url": "https://api.github.com/users/camsteffen/followers", "following_url": "https://api.github.com/users/camsteffen/following{/other_user}", "gists_url": "https://api.github.com/users/camsteffen/gists{/gist_id}", "starred_url": "https://api.github.com/users/camsteffen/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/camsteffen/subscriptions", "organizations_url": "https://api.github.com/users/camsteffen/orgs", "repos_url": "https://api.github.com/users/camsteffen/repos", "events_url": "https://api.github.com/users/camsteffen/events{/privacy}", "received_events_url": "https://api.github.com/users/camsteffen/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1a524783b14df30aad232066e87a58cd6d81f7a8", "url": "https://api.github.com/repos/rust-lang/rust/commits/1a524783b14df30aad232066e87a58cd6d81f7a8", "html_url": "https://github.com/rust-lang/rust/commit/1a524783b14df30aad232066e87a58cd6d81f7a8"}], "stats": {"total": 457, "additions": 227, "deletions": 230}, "files": [{"sha": "9df92cc5b640667faf06c1f63dcf3b3b634d7541", "filename": "clippy_lints/src/eta_reduction.rs", "status": "modified", "additions": 92, "deletions": 148, "changes": 240, "blob_url": "https://github.com/rust-lang/rust/blob/5782dc0eb992a4975eca370345e1ba455d12faa4/clippy_lints%2Fsrc%2Feta_reduction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5782dc0eb992a4975eca370345e1ba455d12faa4/clippy_lints%2Fsrc%2Feta_reduction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Feta_reduction.rs?ref=5782dc0eb992a4975eca370345e1ba455d12faa4", "patch": "@@ -1,16 +1,16 @@\n use clippy_utils::diagnostics::{span_lint_and_sugg, span_lint_and_then};\n use clippy_utils::higher::VecArgs;\n use clippy_utils::source::snippet_opt;\n-use clippy_utils::ty::{implements_trait, type_is_unsafe_function};\n use clippy_utils::usage::UsedAfterExprVisitor;\n-use clippy_utils::{get_enclosing_loop_or_closure, higher};\n-use clippy_utils::{is_adjusted, iter_input_pats};\n+use clippy_utils::{get_enclosing_loop_or_closure, higher, path_to_local_id};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n-use rustc_hir::{def_id, Expr, ExprKind, Param, PatKind, QPath};\n-use rustc_lint::{LateContext, LateLintPass, LintContext};\n-use rustc_middle::lint::in_external_macro;\n-use rustc_middle::ty::{self, ClosureKind, Ty};\n+use rustc_hir::def_id::DefId;\n+use rustc_hir::{Expr, ExprKind, Param, PatKind, Unsafety};\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_middle::ty::adjustment::{Adjust, Adjustment, AutoBorrow};\n+use rustc_middle::ty::subst::Subst;\n+use rustc_middle::ty::{self, ClosureKind, Ty, TypeFoldable};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n \n declare_clippy_lint! {\n@@ -52,12 +52,6 @@ declare_clippy_lint! {\n     /// ### Why is this bad?\n     /// It's unnecessary to create the closure.\n     ///\n-    /// ### Known problems\n-    /// [#3071](https://github.com/rust-lang/rust-clippy/issues/3071),\n-    /// [#3942](https://github.com/rust-lang/rust-clippy/issues/3942),\n-    /// [#4002](https://github.com/rust-lang/rust-clippy/issues/4002)\n-    ///\n-    ///\n     /// ### Example\n     /// ```rust,ignore\n     /// Some('a').map(|s| s.to_uppercase());\n@@ -75,32 +69,16 @@ declare_lint_pass!(EtaReduction => [REDUNDANT_CLOSURE, REDUNDANT_CLOSURE_FOR_MET\n \n impl<'tcx> LateLintPass<'tcx> for EtaReduction {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n-        if in_external_macro(cx.sess(), expr.span) {\n+        if expr.span.from_expansion() {\n             return;\n         }\n-\n-        match expr.kind {\n-            ExprKind::Call(_, args) | ExprKind::MethodCall(_, _, args, _) => {\n-                for arg in args {\n-                    // skip `foo(macro!())`\n-                    if arg.span.ctxt() == expr.span.ctxt() {\n-                        check_closure(cx, arg);\n-                    }\n-                }\n-            },\n-            _ => (),\n-        }\n-    }\n-}\n-\n-fn check_closure<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n-    if let ExprKind::Closure(_, decl, eid, _, _) = expr.kind {\n-        let body = cx.tcx.hir().body(eid);\n-        let ex = &body.value;\n-\n-        if ex.span.ctxt() != expr.span.ctxt() {\n-            if decl.inputs.is_empty() {\n-                if let Some(VecArgs::Vec(&[])) = higher::VecArgs::hir(cx, ex) {\n+        let body = match expr.kind {\n+            ExprKind::Closure(_, _, id, _, _) => cx.tcx.hir().body(id),\n+            _ => return,\n+        };\n+        if body.value.span.from_expansion() {\n+            if body.params.is_empty() {\n+                if let Some(VecArgs::Vec(&[])) = higher::VecArgs::hir(cx, &body.value) {\n                     // replace `|| vec![]` with `Vec::new`\n                     span_lint_and_sugg(\n                         cx,\n@@ -117,33 +95,30 @@ fn check_closure<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n             return;\n         }\n \n-        if_chain!(\n-            if let ExprKind::Call(caller, args) = ex.kind;\n-\n-            if let ExprKind::Path(_) = caller.kind;\n-\n-            // Not the same number of arguments, there is no way the closure is the same as the function return;\n-            if args.len() == decl.inputs.len();\n-\n-            // Are the expression or the arguments type-adjusted? Then we need the closure\n-            if !(is_adjusted(cx, ex) || args.iter().any(|arg| is_adjusted(cx, arg)));\n-\n-            let fn_ty = cx.typeck_results().expr_ty(caller);\n-\n-            if matches!(fn_ty.kind(), ty::FnDef(_, _) | ty::FnPtr(_) | ty::Closure(_, _));\n-\n-            if !type_is_unsafe_function(cx, fn_ty);\n-\n-            if compare_inputs(&mut iter_input_pats(decl, body), &mut args.iter());\n+        let closure_ty = cx.typeck_results().expr_ty(expr);\n \n+        if_chain!(\n+            if let ExprKind::Call(callee, args) = body.value.kind;\n+            if let ExprKind::Path(_) = callee.kind;\n+            if check_inputs(cx, body.params, args);\n+            let callee_ty = cx.typeck_results().expr_ty_adjusted(callee);\n+            let call_ty = cx.typeck_results().type_dependent_def_id(body.value.hir_id)\n+                .map_or(callee_ty, |id| cx.tcx.type_of(id));\n+            if check_sig(cx, closure_ty, call_ty);\n+            let substs = cx.typeck_results().node_substs(callee.hir_id);\n+            // This fixes some false positives that I don't entirely understand\n+            if substs.is_empty() || !cx.typeck_results().expr_ty(expr).has_late_bound_regions();\n+            // A type param function ref like `T::f` is not 'static, however\n+            // it is if cast like `T::f as fn()`. This seems like a rustc bug.\n+            if !substs.types().any(|t| matches!(t.kind(), ty::Param(_)));\n             then {\n                 span_lint_and_then(cx, REDUNDANT_CLOSURE, expr.span, \"redundant closure\", |diag| {\n-                    if let Some(mut snippet) = snippet_opt(cx, caller.span) {\n+                    if let Some(mut snippet) = snippet_opt(cx, callee.span) {\n                         if_chain! {\n-                            if let ty::Closure(_, substs) = fn_ty.kind();\n+                            if let ty::Closure(_, substs) = callee_ty.peel_refs().kind();\n                             if let ClosureKind::FnMut = substs.as_closure().kind();\n-                            if UsedAfterExprVisitor::is_found(cx, caller)\n-                                || get_enclosing_loop_or_closure(cx.tcx, expr).is_some();\n+                            if get_enclosing_loop_or_closure(cx.tcx, expr).is_some()\n+                                || UsedAfterExprVisitor::is_found(cx, callee);\n \n                             then {\n                                 // Mutable closure is used after current expr; we cannot consume it.\n@@ -162,110 +137,79 @@ fn check_closure<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n         );\n \n         if_chain!(\n-            if let ExprKind::MethodCall(path, _, args, _) = ex.kind;\n-\n-            // Not the same number of arguments, there is no way the closure is the same as the function return;\n-            if args.len() == decl.inputs.len();\n-\n-            // Are the expression or the arguments type-adjusted? Then we need the closure\n-            if !(is_adjusted(cx, ex) || args.iter().skip(1).any(|arg| is_adjusted(cx, arg)));\n-\n-            let method_def_id = cx.typeck_results().type_dependent_def_id(ex.hir_id).unwrap();\n-            if !type_is_unsafe_function(cx, cx.tcx.type_of(method_def_id));\n-\n-            if compare_inputs(&mut iter_input_pats(decl, body), &mut args.iter());\n-\n-            if let Some(name) = get_ufcs_type_name(cx, method_def_id, &args[0]);\n-\n+            if let ExprKind::MethodCall(path, _, args, _) = body.value.kind;\n+            if check_inputs(cx, body.params, args);\n+            let method_def_id = cx.typeck_results().type_dependent_def_id(body.value.hir_id).unwrap();\n+            let substs = cx.typeck_results().node_substs(body.value.hir_id);\n+            let call_ty = cx.tcx.type_of(method_def_id).subst(cx.tcx, substs);\n+            if check_sig(cx, closure_ty, call_ty);\n             then {\n-                span_lint_and_sugg(\n-                    cx,\n-                    REDUNDANT_CLOSURE_FOR_METHOD_CALLS,\n-                    expr.span,\n-                    \"redundant closure\",\n-                    \"replace the closure with the method itself\",\n-                    format!(\"{}::{}\", name, path.ident.name),\n-                    Applicability::MachineApplicable,\n-                );\n+                span_lint_and_then(cx, REDUNDANT_CLOSURE_FOR_METHOD_CALLS, expr.span, \"redundant closure\", |diag| {\n+                    let name = get_ufcs_type_name(cx, method_def_id);\n+                    diag.span_suggestion(\n+                        expr.span,\n+                        \"replace the closure with the method itself\",\n+                        format!(\"{}::{}\", name, path.ident.name),\n+                        Applicability::MachineApplicable,\n+                    );\n+                })\n             }\n         );\n     }\n }\n \n-/// Tries to determine the type for universal function call to be used instead of the closure\n-fn get_ufcs_type_name(cx: &LateContext<'_>, method_def_id: def_id::DefId, self_arg: &Expr<'_>) -> Option<String> {\n-    let expected_type_of_self = &cx.tcx.fn_sig(method_def_id).inputs_and_output().skip_binder()[0];\n-    let actual_type_of_self = &cx.typeck_results().node_type(self_arg.hir_id);\n-\n-    if let Some(trait_id) = cx.tcx.trait_of_item(method_def_id) {\n-        if match_borrow_depth(expected_type_of_self, actual_type_of_self)\n-            && implements_trait(cx, actual_type_of_self, trait_id, &[])\n-        {\n-            return Some(cx.tcx.def_path_str(trait_id));\n-        }\n+fn check_inputs(cx: &LateContext<'_>, params: &[Param<'_>], call_args: &[Expr<'_>]) -> bool {\n+    if params.len() != call_args.len() {\n+        return false;\n     }\n-\n-    cx.tcx.impl_of_method(method_def_id).and_then(|_| {\n-        //a type may implicitly implement other type's methods (e.g. Deref)\n-        if match_types(expected_type_of_self, actual_type_of_self) {\n-            Some(get_type_name(cx, actual_type_of_self))\n-        } else {\n-            None\n+    std::iter::zip(params, call_args).all(|(param, arg)| {\n+        match param.pat.kind {\n+            PatKind::Binding(_, id, ..) if path_to_local_id(arg, id) => {},\n+            _ => return false,\n+        }\n+        match *cx.typeck_results().expr_adjustments(arg) {\n+            [] => true,\n+            [Adjustment {\n+                kind: Adjust::Deref(None),\n+                ..\n+            }, Adjustment {\n+                kind: Adjust::Borrow(AutoBorrow::Ref(_, mu2)),\n+                ..\n+            }] => {\n+                // re-borrow with the same mutability is allowed\n+                let ty = cx.typeck_results().expr_ty(arg);\n+                matches!(*ty.kind(), ty::Ref(.., mu1) if mu1 == mu2.into())\n+            },\n+            _ => false,\n         }\n     })\n }\n \n-fn match_borrow_depth(lhs: Ty<'_>, rhs: Ty<'_>) -> bool {\n-    match (&lhs.kind(), &rhs.kind()) {\n-        (ty::Ref(_, t1, mut1), ty::Ref(_, t2, mut2)) => mut1 == mut2 && match_borrow_depth(t1, t2),\n-        (l, r) => !matches!((l, r), (ty::Ref(_, _, _), _) | (_, ty::Ref(_, _, _))),\n-    }\n-}\n-\n-fn match_types(lhs: Ty<'_>, rhs: Ty<'_>) -> bool {\n-    match (&lhs.kind(), &rhs.kind()) {\n-        (ty::Bool, ty::Bool)\n-        | (ty::Char, ty::Char)\n-        | (ty::Int(_), ty::Int(_))\n-        | (ty::Uint(_), ty::Uint(_))\n-        | (ty::Str, ty::Str) => true,\n-        (ty::Ref(_, t1, mut1), ty::Ref(_, t2, mut2)) => mut1 == mut2 && match_types(t1, t2),\n-        (ty::Array(t1, _), ty::Array(t2, _)) | (ty::Slice(t1), ty::Slice(t2)) => match_types(t1, t2),\n-        (ty::Adt(def1, _), ty::Adt(def2, _)) => def1 == def2,\n-        (_, _) => false,\n+fn check_sig<'tcx>(cx: &LateContext<'tcx>, closure_ty: Ty<'tcx>, call_ty: Ty<'tcx>) -> bool {\n+    let call_sig = call_ty.fn_sig(cx.tcx);\n+    if call_sig.unsafety() == Unsafety::Unsafe {\n+        return false;\n     }\n-}\n-\n-fn get_type_name(cx: &LateContext<'_>, ty: Ty<'_>) -> String {\n-    match ty.kind() {\n-        ty::Adt(t, _) => cx.tcx.def_path_str(t.did),\n-        ty::Ref(_, r, _) => get_type_name(cx, r),\n-        _ => ty.to_string(),\n+    if !closure_ty.has_late_bound_regions() {\n+        return true;\n     }\n+    let substs = match closure_ty.kind() {\n+        ty::Closure(_, substs) => substs,\n+        _ => return false,\n+    };\n+    let closure_sig = cx.tcx.signature_unclosure(substs.as_closure().sig(), Unsafety::Normal);\n+    cx.tcx.erase_late_bound_regions(closure_sig) == cx.tcx.erase_late_bound_regions(call_sig)\n }\n \n-fn compare_inputs(\n-    closure_inputs: &mut dyn Iterator<Item = &Param<'_>>,\n-    call_args: &mut dyn Iterator<Item = &Expr<'_>>,\n-) -> bool {\n-    for (closure_input, function_arg) in closure_inputs.zip(call_args) {\n-        if let PatKind::Binding(_, _, ident, _) = closure_input.pat.kind {\n-            // XXXManishearth Should I be checking the binding mode here?\n-            if let ExprKind::Path(QPath::Resolved(None, p)) = function_arg.kind {\n-                if p.segments.len() != 1 {\n-                    // If it's a proper path, it can't be a local variable\n-                    return false;\n-                }\n-                if p.segments[0].ident.name != ident.name {\n-                    // The two idents should be the same\n-                    return false;\n-                }\n-            } else {\n-                return false;\n+fn get_ufcs_type_name(cx: &LateContext<'_>, method_def_id: DefId) -> String {\n+    match cx.tcx.associated_item(method_def_id).container {\n+        ty::TraitContainer(def_id) => cx.tcx.def_path_str(def_id),\n+        ty::ImplContainer(def_id) => {\n+            let ty = cx.tcx.type_of(def_id);\n+            match ty.kind() {\n+                ty::Adt(adt, _) => cx.tcx.def_path_str(adt.did),\n+                _ => ty.to_string(),\n             }\n-        } else {\n-            return false;\n-        }\n+        },\n     }\n-    true\n }"}, {"sha": "9d9a1a3e5003fe010e60c5c3194c012ef9fce015", "filename": "tests/ui/eta.fixed", "status": "modified", "additions": 38, "deletions": 25, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/5782dc0eb992a4975eca370345e1ba455d12faa4/tests%2Fui%2Feta.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/5782dc0eb992a4975eca370345e1ba455d12faa4/tests%2Fui%2Feta.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Feta.fixed?ref=5782dc0eb992a4975eca370345e1ba455d12faa4", "patch": "@@ -14,7 +14,7 @@\n     clippy::needless_borrow\n )]\n \n-use std::path::PathBuf;\n+use std::path::{Path, PathBuf};\n \n macro_rules! mac {\n     () => {\n@@ -30,19 +30,18 @@ macro_rules! closure_mac {\n \n fn main() {\n     let a = Some(1u8).map(foo);\n-    meta(foo);\n     let c = Some(1u8).map(|a| {1+2; foo}(a));\n     true.then(|| mac!()); // don't lint function in macro expansion\n     Some(1).map(closure_mac!()); // don't lint closure in macro expansion\n     let _: Option<Vec<u8>> = true.then(std::vec::Vec::new); // special case vec!\n-    let d = Some(1u8).map(|a| foo((|b| foo2(b))(a))); //is adjusted?\n-    all(&[1, 2, 3], &2, |x, y| below(x, y)); //is adjusted\n+    let d = Some(1u8).map(|a| foo(foo2(a))); //is adjusted?\n+    all(&[1, 2, 3], &2, below); //is adjusted\n     unsafe {\n         Some(1u8).map(|a| unsafe_fn(a)); // unsafe fn\n     }\n \n     // See #815\n-    let e = Some(1u8).map(|a| divergent(a));\n+    let e = Some(1u8).map(divergent);\n     let e = Some(1u8).map(generic);\n     let e = Some(1u8).map(generic);\n     // See #515\n@@ -90,24 +89,17 @@ impl<'a> std::ops::Deref for TestStruct<'a> {\n fn test_redundant_closures_containing_method_calls() {\n     let i = 10;\n     let e = Some(TestStruct { some_ref: &i }).map(TestStruct::foo);\n-    let e = Some(TestStruct { some_ref: &i }).map(TestStruct::foo);\n     let e = Some(TestStruct { some_ref: &i }).map(TestTrait::trait_foo);\n     let e = Some(TestStruct { some_ref: &i }).map(|a| a.trait_foo_ref());\n-    let e = Some(TestStruct { some_ref: &i }).map(TestTrait::trait_foo);\n-    let e = Some(&mut vec![1, 2, 3]).map(std::vec::Vec::clear);\n     let e = Some(&mut vec![1, 2, 3]).map(std::vec::Vec::clear);\n     unsafe {\n         let e = Some(TestStruct { some_ref: &i }).map(|a| a.foo_unsafe());\n     }\n     let e = Some(\"str\").map(std::string::ToString::to_string);\n-    let e = Some(\"str\").map(str::to_string);\n-    let e = Some('a').map(char::to_uppercase);\n     let e = Some('a').map(char::to_uppercase);\n     let e: std::vec::Vec<usize> = vec!['a', 'b', 'c'].iter().map(|c| c.len_utf8()).collect();\n     let e: std::vec::Vec<char> = vec!['a', 'b', 'c'].iter().map(char::to_ascii_uppercase).collect();\n-    let e: std::vec::Vec<char> = vec!['a', 'b', 'c'].iter().map(char::to_ascii_uppercase).collect();\n-    let p = Some(PathBuf::new());\n-    let e = p.as_ref().and_then(|s| s.to_str());\n+    let e = Some(PathBuf::new()).as_ref().and_then(|s| s.to_str());\n     let c = Some(TestStruct { some_ref: &i })\n         .as_ref()\n         .map(|c| c.to_ascii_uppercase());\n@@ -119,10 +111,6 @@ fn test_redundant_closures_containing_method_calls() {\n         t.iter().filter(|x| x.trait_foo_ref());\n         t.iter().map(|x| x.trait_foo_ref());\n     }\n-\n-    let mut some = Some(|x| x * x);\n-    let arr = [Ok(1), Err(2)];\n-    let _: Vec<_> = arr.iter().map(|x| x.map_err(|e| some.take().unwrap()(e))).collect();\n }\n \n struct Thunk<T>(Box<dyn FnMut() -> T>);\n@@ -145,13 +133,6 @@ fn foobar() {\n     thunk.unwrap()\n }\n \n-fn meta<F>(f: F)\n-where\n-    F: Fn(u8),\n-{\n-    f(1u8)\n-}\n-\n fn foo(_: u8) {}\n \n fn foo2(_: u8) -> u8 {\n@@ -180,7 +161,7 @@ fn generic<T>(_: T) -> u8 {\n }\n \n fn passes_fn_mut(mut x: Box<dyn FnMut()>) {\n-    requires_fn_once(|| x());\n+    requires_fn_once(x);\n }\n fn requires_fn_once<T: FnOnce()>(_: T) {}\n \n@@ -236,3 +217,35 @@ fn mutable_closure_in_loop() {\n         Some(1).map(&mut closure);\n     }\n }\n+\n+fn late_bound_lifetimes() {\n+    fn take_asref_path<P: AsRef<Path>>(path: P) {}\n+\n+    fn map_str<F>(thunk: F)\n+    where\n+        F: FnOnce(&str),\n+    {\n+    }\n+\n+    fn map_str_to_path<F>(thunk: F)\n+    where\n+        F: FnOnce(&str) -> &Path,\n+    {\n+    }\n+    map_str(|s| take_asref_path(s));\n+    map_str_to_path(std::convert::AsRef::as_ref);\n+}\n+\n+mod type_param_bound {\n+    trait Trait {\n+        fn fun();\n+    }\n+\n+    fn take<T: 'static>(_: T) {}\n+\n+    fn test<X: Trait>() {\n+        // don't lint, but it's questionable that rust requires a cast\n+        take(|| X::fun());\n+        take(X::fun as fn());\n+    }\n+}"}, {"sha": "3b53b9b28eb1497da86faa49266dbcb59a3ddc0c", "filename": "tests/ui/eta.rs", "status": "modified", "additions": 34, "deletions": 21, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/5782dc0eb992a4975eca370345e1ba455d12faa4/tests%2Fui%2Feta.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5782dc0eb992a4975eca370345e1ba455d12faa4/tests%2Fui%2Feta.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Feta.rs?ref=5782dc0eb992a4975eca370345e1ba455d12faa4", "patch": "@@ -14,7 +14,7 @@\n     clippy::needless_borrow\n )]\n \n-use std::path::PathBuf;\n+use std::path::{Path, PathBuf};\n \n macro_rules! mac {\n     () => {\n@@ -30,7 +30,6 @@ macro_rules! closure_mac {\n \n fn main() {\n     let a = Some(1u8).map(|a| foo(a));\n-    meta(|a| foo(a));\n     let c = Some(1u8).map(|a| {1+2; foo}(a));\n     true.then(|| mac!()); // don't lint function in macro expansion\n     Some(1).map(closure_mac!()); // don't lint closure in macro expansion\n@@ -90,24 +89,17 @@ impl<'a> std::ops::Deref for TestStruct<'a> {\n fn test_redundant_closures_containing_method_calls() {\n     let i = 10;\n     let e = Some(TestStruct { some_ref: &i }).map(|a| a.foo());\n-    let e = Some(TestStruct { some_ref: &i }).map(TestStruct::foo);\n     let e = Some(TestStruct { some_ref: &i }).map(|a| a.trait_foo());\n     let e = Some(TestStruct { some_ref: &i }).map(|a| a.trait_foo_ref());\n-    let e = Some(TestStruct { some_ref: &i }).map(TestTrait::trait_foo);\n     let e = Some(&mut vec![1, 2, 3]).map(|v| v.clear());\n-    let e = Some(&mut vec![1, 2, 3]).map(std::vec::Vec::clear);\n     unsafe {\n         let e = Some(TestStruct { some_ref: &i }).map(|a| a.foo_unsafe());\n     }\n     let e = Some(\"str\").map(|s| s.to_string());\n-    let e = Some(\"str\").map(str::to_string);\n     let e = Some('a').map(|s| s.to_uppercase());\n-    let e = Some('a').map(char::to_uppercase);\n     let e: std::vec::Vec<usize> = vec!['a', 'b', 'c'].iter().map(|c| c.len_utf8()).collect();\n     let e: std::vec::Vec<char> = vec!['a', 'b', 'c'].iter().map(|c| c.to_ascii_uppercase()).collect();\n-    let e: std::vec::Vec<char> = vec!['a', 'b', 'c'].iter().map(char::to_ascii_uppercase).collect();\n-    let p = Some(PathBuf::new());\n-    let e = p.as_ref().and_then(|s| s.to_str());\n+    let e = Some(PathBuf::new()).as_ref().and_then(|s| s.to_str());\n     let c = Some(TestStruct { some_ref: &i })\n         .as_ref()\n         .map(|c| c.to_ascii_uppercase());\n@@ -119,10 +111,6 @@ fn test_redundant_closures_containing_method_calls() {\n         t.iter().filter(|x| x.trait_foo_ref());\n         t.iter().map(|x| x.trait_foo_ref());\n     }\n-\n-    let mut some = Some(|x| x * x);\n-    let arr = [Ok(1), Err(2)];\n-    let _: Vec<_> = arr.iter().map(|x| x.map_err(|e| some.take().unwrap()(e))).collect();\n }\n \n struct Thunk<T>(Box<dyn FnMut() -> T>);\n@@ -145,13 +133,6 @@ fn foobar() {\n     thunk.unwrap()\n }\n \n-fn meta<F>(f: F)\n-where\n-    F: Fn(u8),\n-{\n-    f(1u8)\n-}\n-\n fn foo(_: u8) {}\n \n fn foo2(_: u8) -> u8 {\n@@ -236,3 +217,35 @@ fn mutable_closure_in_loop() {\n         Some(1).map(|n| closure(n));\n     }\n }\n+\n+fn late_bound_lifetimes() {\n+    fn take_asref_path<P: AsRef<Path>>(path: P) {}\n+\n+    fn map_str<F>(thunk: F)\n+    where\n+        F: FnOnce(&str),\n+    {\n+    }\n+\n+    fn map_str_to_path<F>(thunk: F)\n+    where\n+        F: FnOnce(&str) -> &Path,\n+    {\n+    }\n+    map_str(|s| take_asref_path(s));\n+    map_str_to_path(|s| s.as_ref());\n+}\n+\n+mod type_param_bound {\n+    trait Trait {\n+        fn fun();\n+    }\n+\n+    fn take<T: 'static>(_: T) {}\n+\n+    fn test<X: Trait>() {\n+        // don't lint, but it's questionable that rust requires a cast\n+        take(|| X::fun());\n+        take(X::fun as fn());\n+    }\n+}"}, {"sha": "48d7e9e9c96262ee27ebe6387ef145dae6b709a1", "filename": "tests/ui/eta.stderr", "status": "modified", "additions": 45, "deletions": 21, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/5782dc0eb992a4975eca370345e1ba455d12faa4/tests%2Fui%2Feta.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5782dc0eb992a4975eca370345e1ba455d12faa4/tests%2Fui%2Feta.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Feta.stderr?ref=5782dc0eb992a4975eca370345e1ba455d12faa4", "patch": "@@ -7,104 +7,128 @@ LL |     let a = Some(1u8).map(|a| foo(a));\n    = note: `-D clippy::redundant-closure` implied by `-D warnings`\n \n error: redundant closure\n-  --> $DIR/eta.rs:33:10\n+  --> $DIR/eta.rs:36:40\n    |\n-LL |     meta(|a| foo(a));\n-   |          ^^^^^^^^^^ help: replace the closure with the function itself: `foo`\n+LL |     let _: Option<Vec<u8>> = true.then(|| vec![]); // special case vec!\n+   |                                        ^^^^^^^^^ help: replace the closure with `Vec::new`: `std::vec::Vec::new`\n \n error: redundant closure\n-  --> $DIR/eta.rs:37:40\n+  --> $DIR/eta.rs:37:35\n    |\n-LL |     let _: Option<Vec<u8>> = true.then(|| vec![]); // special case vec!\n-   |                                        ^^^^^^^^^ help: replace the closure with `Vec::new`: `std::vec::Vec::new`\n+LL |     let d = Some(1u8).map(|a| foo((|b| foo2(b))(a))); //is adjusted?\n+   |                                   ^^^^^^^^^^^^^ help: replace the closure with the function itself: `foo2`\n \n error: this expression borrows a reference (`&u8`) that is immediately dereferenced by the compiler\n-  --> $DIR/eta.rs:39:21\n+  --> $DIR/eta.rs:38:21\n    |\n LL |     all(&[1, 2, 3], &&2, |x, y| below(x, y)); //is adjusted\n    |                     ^^^ help: change this to: `&2`\n    |\n    = note: `-D clippy::needless-borrow` implied by `-D warnings`\n \n error: redundant closure\n-  --> $DIR/eta.rs:46:27\n+  --> $DIR/eta.rs:38:26\n+   |\n+LL |     all(&[1, 2, 3], &&2, |x, y| below(x, y)); //is adjusted\n+   |                          ^^^^^^^^^^^^^^^^^^ help: replace the closure with the function itself: `below`\n+\n+error: redundant closure\n+  --> $DIR/eta.rs:44:27\n+   |\n+LL |     let e = Some(1u8).map(|a| divergent(a));\n+   |                           ^^^^^^^^^^^^^^^^ help: replace the closure with the function itself: `divergent`\n+\n+error: redundant closure\n+  --> $DIR/eta.rs:45:27\n    |\n LL |     let e = Some(1u8).map(|a| generic(a));\n    |                           ^^^^^^^^^^^^^^ help: replace the closure with the function itself: `generic`\n \n error: redundant closure\n-  --> $DIR/eta.rs:92:51\n+  --> $DIR/eta.rs:91:51\n    |\n LL |     let e = Some(TestStruct { some_ref: &i }).map(|a| a.foo());\n    |                                                   ^^^^^^^^^^^ help: replace the closure with the method itself: `TestStruct::foo`\n    |\n    = note: `-D clippy::redundant-closure-for-method-calls` implied by `-D warnings`\n \n error: redundant closure\n-  --> $DIR/eta.rs:94:51\n+  --> $DIR/eta.rs:92:51\n    |\n LL |     let e = Some(TestStruct { some_ref: &i }).map(|a| a.trait_foo());\n    |                                                   ^^^^^^^^^^^^^^^^^ help: replace the closure with the method itself: `TestTrait::trait_foo`\n \n error: redundant closure\n-  --> $DIR/eta.rs:97:42\n+  --> $DIR/eta.rs:94:42\n    |\n LL |     let e = Some(&mut vec![1, 2, 3]).map(|v| v.clear());\n    |                                          ^^^^^^^^^^^^^ help: replace the closure with the method itself: `std::vec::Vec::clear`\n \n error: redundant closure\n-  --> $DIR/eta.rs:102:29\n+  --> $DIR/eta.rs:98:29\n    |\n LL |     let e = Some(\"str\").map(|s| s.to_string());\n    |                             ^^^^^^^^^^^^^^^^^ help: replace the closure with the method itself: `std::string::ToString::to_string`\n \n error: redundant closure\n-  --> $DIR/eta.rs:104:27\n+  --> $DIR/eta.rs:99:27\n    |\n LL |     let e = Some('a').map(|s| s.to_uppercase());\n    |                           ^^^^^^^^^^^^^^^^^^^^ help: replace the closure with the method itself: `char::to_uppercase`\n \n error: redundant closure\n-  --> $DIR/eta.rs:107:65\n+  --> $DIR/eta.rs:101:65\n    |\n LL |     let e: std::vec::Vec<char> = vec!['a', 'b', 'c'].iter().map(|c| c.to_ascii_uppercase()).collect();\n    |                                                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace the closure with the method itself: `char::to_ascii_uppercase`\n \n error: redundant closure\n-  --> $DIR/eta.rs:190:27\n+  --> $DIR/eta.rs:164:22\n+   |\n+LL |     requires_fn_once(|| x());\n+   |                      ^^^^^^ help: replace the closure with the function itself: `x`\n+\n+error: redundant closure\n+  --> $DIR/eta.rs:171:27\n    |\n LL |     let a = Some(1u8).map(|a| foo_ptr(a));\n    |                           ^^^^^^^^^^^^^^ help: replace the closure with the function itself: `foo_ptr`\n \n error: redundant closure\n-  --> $DIR/eta.rs:195:27\n+  --> $DIR/eta.rs:176:27\n    |\n LL |     let a = Some(1u8).map(|a| closure(a));\n    |                           ^^^^^^^^^^^^^^ help: replace the closure with the function itself: `closure`\n \n error: redundant closure\n-  --> $DIR/eta.rs:227:28\n+  --> $DIR/eta.rs:208:28\n    |\n LL |     x.into_iter().for_each(|x| add_to_res(x));\n    |                            ^^^^^^^^^^^^^^^^^ help: replace the closure with the function itself: `&mut add_to_res`\n \n error: redundant closure\n-  --> $DIR/eta.rs:228:28\n+  --> $DIR/eta.rs:209:28\n    |\n LL |     y.into_iter().for_each(|x| add_to_res(x));\n    |                            ^^^^^^^^^^^^^^^^^ help: replace the closure with the function itself: `&mut add_to_res`\n \n error: redundant closure\n-  --> $DIR/eta.rs:229:28\n+  --> $DIR/eta.rs:210:28\n    |\n LL |     z.into_iter().for_each(|x| add_to_res(x));\n    |                            ^^^^^^^^^^^^^^^^^ help: replace the closure with the function itself: `add_to_res`\n \n error: redundant closure\n-  --> $DIR/eta.rs:236:21\n+  --> $DIR/eta.rs:217:21\n    |\n LL |         Some(1).map(|n| closure(n));\n    |                     ^^^^^^^^^^^^^^ help: replace the closure with the function itself: `&mut closure`\n \n-error: aborting due to 17 previous errors\n+error: redundant closure\n+  --> $DIR/eta.rs:236:21\n+   |\n+LL |     map_str_to_path(|s| s.as_ref());\n+   |                     ^^^^^^^^^^^^^^ help: replace the closure with the method itself: `std::convert::AsRef::as_ref`\n+\n+error: aborting due to 21 previous errors\n "}, {"sha": "fec3a95edd62da54cddde339c8566e0fa56656e9", "filename": "tests/ui/map_flatten.fixed", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5782dc0eb992a4975eca370345e1ba455d12faa4/tests%2Fui%2Fmap_flatten.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/5782dc0eb992a4975eca370345e1ba455d12faa4/tests%2Fui%2Fmap_flatten.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmap_flatten.fixed?ref=5782dc0eb992a4975eca370345e1ba455d12faa4", "patch": "@@ -4,6 +4,7 @@\n #![allow(clippy::let_underscore_drop)]\n #![allow(clippy::missing_docs_in_private_items)]\n #![allow(clippy::map_identity)]\n+#![allow(clippy::redundant_closure)]\n #![allow(clippy::unnecessary_wraps)]\n #![feature(result_flattening)]\n "}, {"sha": "aa1f76e335af0dad3a395921b3e25e6fbf82b6a4", "filename": "tests/ui/map_flatten.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5782dc0eb992a4975eca370345e1ba455d12faa4/tests%2Fui%2Fmap_flatten.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5782dc0eb992a4975eca370345e1ba455d12faa4/tests%2Fui%2Fmap_flatten.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmap_flatten.rs?ref=5782dc0eb992a4975eca370345e1ba455d12faa4", "patch": "@@ -4,6 +4,7 @@\n #![allow(clippy::let_underscore_drop)]\n #![allow(clippy::missing_docs_in_private_items)]\n #![allow(clippy::map_identity)]\n+#![allow(clippy::redundant_closure)]\n #![allow(clippy::unnecessary_wraps)]\n #![feature(result_flattening)]\n "}, {"sha": "bcd2047e6faa3d3683b11f396e6a818855c94d21", "filename": "tests/ui/map_flatten.stderr", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/5782dc0eb992a4975eca370345e1ba455d12faa4/tests%2Fui%2Fmap_flatten.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5782dc0eb992a4975eca370345e1ba455d12faa4/tests%2Fui%2Fmap_flatten.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmap_flatten.stderr?ref=5782dc0eb992a4975eca370345e1ba455d12faa4", "patch": "@@ -1,43 +1,43 @@\n error: called `map(..).flatten()` on an `Iterator`\n-  --> $DIR/map_flatten.rs:17:46\n+  --> $DIR/map_flatten.rs:18:46\n    |\n LL |     let _: Vec<_> = vec![5_i8; 6].into_iter().map(option_id).flatten().collect();\n    |                                              ^^^^^^^^^^^^^^^^^^^^^^^^^ help: try using `filter_map` instead: `.filter_map(option_id)`\n    |\n    = note: `-D clippy::map-flatten` implied by `-D warnings`\n \n error: called `map(..).flatten()` on an `Iterator`\n-  --> $DIR/map_flatten.rs:18:46\n+  --> $DIR/map_flatten.rs:19:46\n    |\n LL |     let _: Vec<_> = vec![5_i8; 6].into_iter().map(option_id_ref).flatten().collect();\n    |                                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try using `filter_map` instead: `.filter_map(option_id_ref)`\n \n error: called `map(..).flatten()` on an `Iterator`\n-  --> $DIR/map_flatten.rs:19:46\n+  --> $DIR/map_flatten.rs:20:46\n    |\n LL |     let _: Vec<_> = vec![5_i8; 6].into_iter().map(option_id_closure).flatten().collect();\n    |                                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try using `filter_map` instead: `.filter_map(option_id_closure)`\n \n error: called `map(..).flatten()` on an `Iterator`\n-  --> $DIR/map_flatten.rs:20:46\n+  --> $DIR/map_flatten.rs:21:46\n    |\n LL |     let _: Vec<_> = vec![5_i8; 6].into_iter().map(|x| x.checked_add(1)).flatten().collect();\n    |                                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try using `filter_map` instead: `.filter_map(|x| x.checked_add(1))`\n \n error: called `map(..).flatten()` on an `Iterator`\n-  --> $DIR/map_flatten.rs:23:46\n+  --> $DIR/map_flatten.rs:24:46\n    |\n LL |     let _: Vec<_> = vec![5_i8; 6].into_iter().map(|x| 0..x).flatten().collect();\n    |                                              ^^^^^^^^^^^^^^^^^^^^^^^^ help: try using `flat_map` instead: `.flat_map(|x| 0..x)`\n \n error: called `map(..).flatten()` on an `Option`\n-  --> $DIR/map_flatten.rs:26:39\n+  --> $DIR/map_flatten.rs:27:39\n    |\n LL |     let _: Option<_> = (Some(Some(1))).map(|x| x).flatten();\n    |                                       ^^^^^^^^^^^^^^^^^^^^^ help: try using `and_then` instead: `.and_then(|x| x)`\n \n error: called `map(..).flatten()` on an `Result`\n-  --> $DIR/map_flatten.rs:29:41\n+  --> $DIR/map_flatten.rs:30:41\n    |\n LL |     let _: Result<_, &str> = (Ok(Ok(1))).map(|x| x).flatten();\n    |                                         ^^^^^^^^^^^^^^^^^^^^^ help: try using `and_then` instead: `.and_then(|x| x)`"}, {"sha": "9644a23296831bf1a67092feecba921180aa3ba7", "filename": "tests/ui/semicolon_if_nothing_returned.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5782dc0eb992a4975eca370345e1ba455d12faa4/tests%2Fui%2Fsemicolon_if_nothing_returned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5782dc0eb992a4975eca370345e1ba455d12faa4/tests%2Fui%2Fsemicolon_if_nothing_returned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsemicolon_if_nothing_returned.rs?ref=5782dc0eb992a4975eca370345e1ba455d12faa4", "patch": "@@ -1,4 +1,5 @@\n #![warn(clippy::semicolon_if_nothing_returned)]\n+#![allow(clippy::redundant_closure)]\n #![feature(label_break_value)]\n \n fn get_unit() {}\n@@ -30,8 +31,8 @@ fn unsafe_checks_error() {\n     use std::ptr;\n \n     let mut s = MaybeUninit::<String>::uninit();\n-    let _d = || unsafe { \n-        ptr::drop_in_place(s.as_mut_ptr()) \n+    let _d = || unsafe {\n+        ptr::drop_in_place(s.as_mut_ptr())\n     };\n }\n "}, {"sha": "78813e7cc1c39c5aa294f08db14ca9cfe0688a50", "filename": "tests/ui/semicolon_if_nothing_returned.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5782dc0eb992a4975eca370345e1ba455d12faa4/tests%2Fui%2Fsemicolon_if_nothing_returned.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5782dc0eb992a4975eca370345e1ba455d12faa4/tests%2Fui%2Fsemicolon_if_nothing_returned.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsemicolon_if_nothing_returned.stderr?ref=5782dc0eb992a4975eca370345e1ba455d12faa4", "patch": "@@ -1,33 +1,33 @@\n error: consider adding a `;` to the last statement for consistent formatting\n-  --> $DIR/semicolon_if_nothing_returned.rs:8:5\n+  --> $DIR/semicolon_if_nothing_returned.rs:9:5\n    |\n LL |     println!(\"Hello\")\n    |     ^^^^^^^^^^^^^^^^^ help: add a `;` here: `println!(\"Hello\");`\n    |\n    = note: `-D clippy::semicolon-if-nothing-returned` implied by `-D warnings`\n \n error: consider adding a `;` to the last statement for consistent formatting\n-  --> $DIR/semicolon_if_nothing_returned.rs:12:5\n+  --> $DIR/semicolon_if_nothing_returned.rs:13:5\n    |\n LL |     get_unit()\n    |     ^^^^^^^^^^ help: add a `;` here: `get_unit();`\n \n error: consider adding a `;` to the last statement for consistent formatting\n-  --> $DIR/semicolon_if_nothing_returned.rs:17:5\n+  --> $DIR/semicolon_if_nothing_returned.rs:18:5\n    |\n LL |     y = x + 1\n    |     ^^^^^^^^^ help: add a `;` here: `y = x + 1;`\n \n error: consider adding a `;` to the last statement for consistent formatting\n-  --> $DIR/semicolon_if_nothing_returned.rs:23:9\n+  --> $DIR/semicolon_if_nothing_returned.rs:24:9\n    |\n LL |         hello()\n    |         ^^^^^^^ help: add a `;` here: `hello();`\n \n error: consider adding a `;` to the last statement for consistent formatting\n-  --> $DIR/semicolon_if_nothing_returned.rs:34:9\n+  --> $DIR/semicolon_if_nothing_returned.rs:35:9\n    |\n-LL |         ptr::drop_in_place(s.as_mut_ptr()) \n+LL |         ptr::drop_in_place(s.as_mut_ptr())\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: add a `;` here: `ptr::drop_in_place(s.as_mut_ptr());`\n \n error: aborting due to 5 previous errors"}]}