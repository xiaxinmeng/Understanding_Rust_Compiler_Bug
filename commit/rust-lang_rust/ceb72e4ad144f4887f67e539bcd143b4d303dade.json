{"sha": "ceb72e4ad144f4887f67e539bcd143b4d303dade", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNlYjcyZTRhZDE0NGY0ODg3ZjY3ZTUzOWJjZDE0M2I0ZDMwM2RhZGU=", "commit": {"author": {"name": "Dylan MacKenzie", "email": "ecstaticmorse@gmail.com", "date": "2019-09-17T23:25:29Z"}, "committer": {"name": "Dylan MacKenzie", "email": "ecstaticmorse@gmail.com", "date": "2019-09-17T23:52:13Z"}, "message": "Add generic dataflow impl", "tree": {"sha": "a60d8302b8b325dae64ec57e83aae7a5fb6c775a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a60d8302b8b325dae64ec57e83aae7a5fb6c775a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ceb72e4ad144f4887f67e539bcd143b4d303dade", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ceb72e4ad144f4887f67e539bcd143b4d303dade", "html_url": "https://github.com/rust-lang/rust/commit/ceb72e4ad144f4887f67e539bcd143b4d303dade", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ceb72e4ad144f4887f67e539bcd143b4d303dade/comments", "author": {"login": "ecstatic-morse", "id": 29463364, "node_id": "MDQ6VXNlcjI5NDYzMzY0", "avatar_url": "https://avatars.githubusercontent.com/u/29463364?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ecstatic-morse", "html_url": "https://github.com/ecstatic-morse", "followers_url": "https://api.github.com/users/ecstatic-morse/followers", "following_url": "https://api.github.com/users/ecstatic-morse/following{/other_user}", "gists_url": "https://api.github.com/users/ecstatic-morse/gists{/gist_id}", "starred_url": "https://api.github.com/users/ecstatic-morse/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ecstatic-morse/subscriptions", "organizations_url": "https://api.github.com/users/ecstatic-morse/orgs", "repos_url": "https://api.github.com/users/ecstatic-morse/repos", "events_url": "https://api.github.com/users/ecstatic-morse/events{/privacy}", "received_events_url": "https://api.github.com/users/ecstatic-morse/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ecstatic-morse", "id": 29463364, "node_id": "MDQ6VXNlcjI5NDYzMzY0", "avatar_url": "https://avatars.githubusercontent.com/u/29463364?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ecstatic-morse", "html_url": "https://github.com/ecstatic-morse", "followers_url": "https://api.github.com/users/ecstatic-morse/followers", "following_url": "https://api.github.com/users/ecstatic-morse/following{/other_user}", "gists_url": "https://api.github.com/users/ecstatic-morse/gists{/gist_id}", "starred_url": "https://api.github.com/users/ecstatic-morse/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ecstatic-morse/subscriptions", "organizations_url": "https://api.github.com/users/ecstatic-morse/orgs", "repos_url": "https://api.github.com/users/ecstatic-morse/repos", "events_url": "https://api.github.com/users/ecstatic-morse/events{/privacy}", "received_events_url": "https://api.github.com/users/ecstatic-morse/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a44881d892fb4f4a8ed93f8f392bab942fac7a41", "url": "https://api.github.com/repos/rust-lang/rust/commits/a44881d892fb4f4a8ed93f8f392bab942fac7a41", "html_url": "https://github.com/rust-lang/rust/commit/a44881d892fb4f4a8ed93f8f392bab942fac7a41"}], "stats": {"total": 446, "additions": 446, "deletions": 0}, "files": [{"sha": "7819fd11845e6d53451bd4411c4ba10d51b5aae2", "filename": "src/librustc_mir/dataflow/generic.rs", "status": "added", "additions": 444, "deletions": 0, "changes": 444, "blob_url": "https://github.com/rust-lang/rust/blob/ceb72e4ad144f4887f67e539bcd143b4d303dade/src%2Flibrustc_mir%2Fdataflow%2Fgeneric.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ceb72e4ad144f4887f67e539bcd143b4d303dade/src%2Flibrustc_mir%2Fdataflow%2Fgeneric.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fgeneric.rs?ref=ceb72e4ad144f4887f67e539bcd143b4d303dade", "patch": "@@ -0,0 +1,444 @@\n+use std::cmp::Ordering;\n+use std::ops;\n+\n+use rustc::mir::{self, traversal, BasicBlock, Location};\n+use rustc_data_structures::bit_set::BitSet;\n+use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n+use rustc_data_structures::work_queue::WorkQueue;\n+\n+use crate::dataflow::BottomValue;\n+\n+pub trait Analysis<'tcx>: BottomValue {\n+    type Idx: Idx;\n+\n+    fn name() -> &'static str;\n+\n+    fn bits_per_block(&self, body: &mir::Body<'tcx>) -> usize;\n+\n+    fn initialize_start_block(&self, body: &mir::Body<'tcx>, state: &mut BitSet<Self::Idx>);\n+\n+    fn apply_statement_effect(\n+        &self,\n+        state: &mut BitSet<Self::Idx>,\n+        statement: &mir::Statement<'tcx>,\n+        location: Location,\n+    );\n+\n+    fn apply_terminator_effect(\n+        &self,\n+        state: &mut BitSet<Self::Idx>,\n+        terminator: &mir::Terminator<'tcx>,\n+        location: Location,\n+    );\n+\n+    fn apply_call_return_effect(\n+        &self,\n+        state: &mut BitSet<Self::Idx>,\n+        block: BasicBlock,\n+        func: &mir::Operand<'tcx>,\n+        args: &[mir::Operand<'tcx>],\n+        return_place: &mir::Place<'tcx>,\n+    );\n+\n+    /// Applies the cumulative effect of an entire basic block to the dataflow state (except for\n+    /// `call_return_effect`, which is handled in the `Engine`).\n+    ///\n+    /// The default implementation calls `statement_effect` for every statement in the block before\n+    /// finally calling `terminator_effect`. However, some dataflow analyses are able to coalesce\n+    /// transfer functions for an entire block and apply them at once. Such analyses should\n+    /// override `block_effect`.\n+    fn apply_whole_block_effect(\n+        &self,\n+        state: &mut BitSet<Self::Idx>,\n+        block: BasicBlock,\n+        block_data: &mir::BasicBlockData<'tcx>,\n+    ) {\n+        for (statement_index, stmt) in block_data.statements.iter().enumerate() {\n+            let location = Location { block, statement_index };\n+            self.apply_statement_effect(state, stmt, location);\n+        }\n+\n+        let location = Location { block, statement_index: block_data.statements.len() };\n+        self.apply_terminator_effect(state, block_data.terminator(), location);\n+    }\n+\n+    /// Applies the cumulative effect of a sequence of statements (and possibly a terminator)\n+    /// within a single basic block.\n+    ///\n+    /// When called with `0..block_data.statements.len() + 1` as the statement range, this function\n+    /// is equivalent to `apply_whole_block_effect`.\n+    fn apply_partial_block_effect(\n+        &self,\n+        state: &mut BitSet<Self::Idx>,\n+        block: BasicBlock,\n+        block_data: &mir::BasicBlockData<'tcx>,\n+        mut range: ops::Range<usize>,\n+    ) {\n+        if range.is_empty() {\n+            return;\n+        }\n+\n+        // The final location might be a terminator, so iterate through all statements until the\n+        // final one, then check to see whether the final one is a statement or terminator.\n+        //\n+        // This can't cause the range to wrap-around since we check that the range contains at\n+        // least one element above.\n+        range.end -= 1;\n+        let final_location = Location { block, statement_index: range.end };\n+\n+        for statement_index in range {\n+            let location = Location { block, statement_index };\n+            let stmt = &block_data.statements[statement_index];\n+            self.apply_statement_effect(state, stmt, location);\n+        }\n+\n+        if final_location.statement_index == block_data.statements.len() {\n+            let terminator = block_data.terminator();\n+            self.apply_terminator_effect(state, terminator, final_location);\n+        } else {\n+            let stmt = &block_data.statements[final_location.statement_index];\n+            self.apply_statement_effect(state, stmt, final_location);\n+        }\n+    }\n+}\n+\n+#[derive(Clone, Copy, Debug)]\n+enum CursorPosition {\n+    AtBlockStart(BasicBlock),\n+    After(Location),\n+}\n+\n+impl CursorPosition {\n+    fn block(&self) -> BasicBlock {\n+        match *self {\n+            Self::AtBlockStart(block) => block,\n+            Self::After(Location { block, .. }) => block,\n+        }\n+    }\n+}\n+\n+pub struct ResultsCursor<'mir, 'tcx, A>\n+where\n+    A: Analysis<'tcx>,\n+{\n+    body: &'mir mir::Body<'tcx>,\n+    results: Results<'tcx, A>,\n+    state: BitSet<A::Idx>,\n+\n+    pos: CursorPosition,\n+\n+    /// Whether the effects of `apply_call_return_effect` are currently stored in `state`.\n+    ///\n+    /// This flag ensures that multiple calls to `seek_after_assume_call_returns` with the same\n+    /// target only result in one invocation of `apply_call_return_effect`.\n+    is_call_return_effect_applied: bool,\n+}\n+\n+impl<'mir, 'tcx, A> ResultsCursor<'mir, 'tcx, A>\n+where\n+    A: Analysis<'tcx>,\n+{\n+    /// Returns a new cursor for `results` that points to the start of the `START_BLOCK`.\n+    pub fn new(body: &'mir mir::Body<'tcx>, results: Results<'tcx, A>) -> Self {\n+        ResultsCursor {\n+            body,\n+            pos: CursorPosition::AtBlockStart(mir::START_BLOCK),\n+            is_call_return_effect_applied: false,\n+            state: results.entry_sets[mir::START_BLOCK].clone(),\n+            results,\n+        }\n+    }\n+\n+    /// Resets the cursor to the start of the given `block`.\n+    pub fn seek_to_block_start(&mut self, block: BasicBlock) {\n+        self.state.overwrite(&self.results.entry_sets[block]);\n+        self.pos = CursorPosition::AtBlockStart(block);\n+        self.is_call_return_effect_applied = false;\n+    }\n+\n+    /// Updates the cursor to hold the dataflow state immediately before `target`.\n+    #[allow(unused)]\n+    pub fn seek_before(&mut self, target: Location) {\n+        assert!(target <= self.body.terminator_loc(target.block));\n+\n+        if target.statement_index == 0 {\n+            self.seek_to_block_start(target.block);\n+        } else {\n+            self._seek_after(Location {\n+                block: target.block,\n+                statement_index: target.statement_index - 1,\n+            });\n+        }\n+    }\n+\n+    /// Updates the cursor to hold the dataflow state at `target`.\n+    ///\n+    /// If `target` is a `Call` terminator, `apply_call_return_effect` will not be called. See\n+    /// `seek_after_assume_call_returns` if you wish to observe the dataflow state upon a\n+    /// successful return.\n+    #[allow(unused)]\n+    pub fn seek_after(&mut self, target: Location) {\n+        assert!(target <= self.body.terminator_loc(target.block));\n+\n+        // This check ensures the correctness of a call to `seek_after_assume_call_returns`\n+        // followed by one to `seek_after` with the same target.\n+        if self.is_call_return_effect_applied {\n+            self.seek_to_block_start(target.block);\n+        }\n+\n+        self._seek_after(target);\n+    }\n+\n+    /// Equivalent to `seek_after`, but also calls `apply_call_return_effect` if `target` is a\n+    /// `Call` terminator whose callee is convergent.\n+    #[allow(unused)]\n+    pub fn seek_after_assume_call_returns(&mut self, target: Location) {\n+        assert!(target <= self.body.terminator_loc(target.block));\n+\n+        self._seek_after(target);\n+\n+        if target != self.body.terminator_loc(target.block) {\n+            return;\n+        }\n+\n+        let term = self.body.basic_blocks()[target.block].terminator();\n+        if let mir::TerminatorKind::Call {\n+            destination: Some((return_place, _)),\n+            func,\n+            args,\n+            ..\n+        } = &term.kind {\n+            if !self.is_call_return_effect_applied {\n+                self.results.analysis.apply_call_return_effect(\n+                    &mut self.state,\n+                    target.block,\n+                    func,\n+                    args,\n+                    return_place,\n+                );\n+            }\n+        }\n+    }\n+\n+    fn _seek_after(&mut self, target: Location) {\n+        let Location { block: target_block, statement_index: target_index } = target;\n+\n+        if self.pos.block() != target_block {\n+            self.seek_to_block_start(target_block);\n+        }\n+\n+        // If we're in the same block but after the target statement, we need to reset to the start\n+        // of the block.\n+        if let CursorPosition::After(Location { statement_index: curr_index, .. }) = self.pos {\n+            match curr_index.cmp(&target_index) {\n+                Ordering::Equal => return,\n+                Ordering::Less => {},\n+                Ordering::Greater => self.seek_to_block_start(target_block),\n+            }\n+        }\n+\n+        // The cursor is now in the same block as the target location pointing at an earlier\n+        // statement.\n+        debug_assert_eq!(self.pos.block(), target_block);\n+        if let CursorPosition::After(Location { statement_index, .. }) = self.pos {\n+            debug_assert!(statement_index < target_index);\n+        }\n+\n+        let first_unapplied_statement = match self.pos {\n+            CursorPosition::AtBlockStart(_) => 0,\n+            CursorPosition::After(Location { statement_index, .. }) => statement_index + 1,\n+        };\n+\n+        let block_data = &self.body.basic_blocks()[target_block];\n+        self.results.analysis.apply_partial_block_effect(\n+            &mut self.state,\n+            target_block,\n+            block_data,\n+            first_unapplied_statement..target_index + 1,\n+        );\n+\n+        self.pos = CursorPosition::After(target);\n+        self.is_call_return_effect_applied = false;\n+    }\n+\n+    /// Gets the dataflow state at the current location.\n+    pub fn get(&self) -> &BitSet<A::Idx> {\n+        &self.state\n+    }\n+}\n+\n+pub struct Results<'tcx, A>\n+where\n+    A: Analysis<'tcx>,\n+{\n+    analysis: A,\n+    entry_sets: IndexVec<BasicBlock, BitSet<A::Idx>>,\n+}\n+\n+pub struct Engine<'a, 'tcx, A>\n+where\n+    A: Analysis<'tcx>,\n+{\n+    analysis: A,\n+    bits_per_block: usize,\n+    body: &'a mir::Body<'tcx>,\n+    dead_unwinds: &'a BitSet<BasicBlock>,\n+    entry_sets: IndexVec<BasicBlock, BitSet<A::Idx>>,\n+}\n+\n+impl<A> Engine<'a, 'tcx, A>\n+where\n+    A: Analysis<'tcx>,\n+{\n+    pub fn new(\n+        body: &'a mir::Body<'tcx>,\n+        dead_unwinds: &'a BitSet<BasicBlock>,\n+        analysis: A,\n+    ) -> Self {\n+        let bits_per_block = analysis.bits_per_block(body);\n+\n+        let bottom_value_set = if A::BOTTOM_VALUE == true {\n+            BitSet::new_filled(bits_per_block)\n+        } else {\n+            BitSet::new_empty(bits_per_block)\n+        };\n+\n+        let mut entry_sets = IndexVec::from_elem(bottom_value_set, body.basic_blocks());\n+        analysis.initialize_start_block(body, &mut entry_sets[mir::START_BLOCK]);\n+\n+        Engine {\n+            analysis,\n+            bits_per_block,\n+            body,\n+            dead_unwinds,\n+            entry_sets,\n+        }\n+    }\n+\n+    pub fn iterate_to_fixpoint(mut self) -> Results<'tcx, A> {\n+        let mut temp_state = BitSet::new_empty(self.bits_per_block);\n+\n+        let mut dirty_queue: WorkQueue<BasicBlock> =\n+            WorkQueue::with_none(self.body.basic_blocks().len());\n+\n+        for (bb, _) in traversal::reverse_postorder(self.body) {\n+            dirty_queue.insert(bb);\n+        }\n+\n+        // Add blocks that are not reachable from START_BLOCK to the work queue. These blocks will\n+        // be processed after the ones added above.\n+        for bb in self.body.basic_blocks().indices() {\n+            dirty_queue.insert(bb);\n+        }\n+\n+        while let Some(bb) = dirty_queue.pop() {\n+            let bb_data = &self.body[bb];\n+            let on_entry = &self.entry_sets[bb];\n+\n+            temp_state.overwrite(on_entry);\n+            self.analysis.apply_whole_block_effect(&mut temp_state, bb, bb_data);\n+\n+            self.propagate_bits_into_graph_successors_of(\n+                &mut temp_state,\n+                (bb, bb_data),\n+                &mut dirty_queue,\n+            );\n+        }\n+\n+        Results {\n+            analysis: self.analysis,\n+            entry_sets: self.entry_sets,\n+        }\n+    }\n+\n+    fn propagate_bits_into_graph_successors_of(\n+        &mut self,\n+        in_out: &mut BitSet<A::Idx>,\n+        (bb, bb_data): (BasicBlock, &'a mir::BasicBlockData<'tcx>),\n+        dirty_list: &mut WorkQueue<BasicBlock>,\n+    ) {\n+        match bb_data.terminator().kind {\n+            mir::TerminatorKind::Return\n+            | mir::TerminatorKind::Resume\n+            | mir::TerminatorKind::Abort\n+            | mir::TerminatorKind::GeneratorDrop\n+            | mir::TerminatorKind::Unreachable => {}\n+\n+            mir::TerminatorKind::Goto { target }\n+            | mir::TerminatorKind::Assert { target, cleanup: None, .. }\n+            | mir::TerminatorKind::Yield { resume: target, drop: None, .. }\n+            | mir::TerminatorKind::Drop { target, location: _, unwind: None }\n+            | mir::TerminatorKind::DropAndReplace { target, value: _, location: _, unwind: None } =>\n+            {\n+                self.propagate_bits_into_entry_set_for(in_out, target, dirty_list);\n+            }\n+\n+            mir::TerminatorKind::Yield { resume: target, drop: Some(drop), .. } => {\n+                self.propagate_bits_into_entry_set_for(in_out, target, dirty_list);\n+                self.propagate_bits_into_entry_set_for(in_out, drop, dirty_list);\n+            }\n+\n+            mir::TerminatorKind::Assert { target, cleanup: Some(unwind), .. }\n+            | mir::TerminatorKind::Drop { target, location: _, unwind: Some(unwind) }\n+            | mir::TerminatorKind::DropAndReplace {\n+                target,\n+                value: _,\n+                location: _,\n+                unwind: Some(unwind),\n+            } => {\n+                self.propagate_bits_into_entry_set_for(in_out, target, dirty_list);\n+                if !self.dead_unwinds.contains(bb) {\n+                    self.propagate_bits_into_entry_set_for(in_out, unwind, dirty_list);\n+                }\n+            }\n+\n+            mir::TerminatorKind::SwitchInt { ref targets, .. } => {\n+                for target in targets {\n+                    self.propagate_bits_into_entry_set_for(in_out, *target, dirty_list);\n+                }\n+            }\n+\n+            mir::TerminatorKind::Call { cleanup, ref destination, ref func, ref args, .. } => {\n+                if let Some(unwind) = cleanup {\n+                    if !self.dead_unwinds.contains(bb) {\n+                        self.propagate_bits_into_entry_set_for(in_out, unwind, dirty_list);\n+                    }\n+                }\n+\n+                if let Some((ref dest_place, dest_bb)) = *destination {\n+                    // N.B.: This must be done *last*, after all other\n+                    // propagation, as documented in comment above.\n+                    self.analysis.apply_call_return_effect(in_out, bb, func, args, dest_place);\n+                    self.propagate_bits_into_entry_set_for(in_out, dest_bb, dirty_list);\n+                }\n+            }\n+\n+            mir::TerminatorKind::FalseEdges { real_target, imaginary_target } => {\n+                self.propagate_bits_into_entry_set_for(in_out, real_target, dirty_list);\n+                self.propagate_bits_into_entry_set_for(in_out, imaginary_target, dirty_list);\n+            }\n+\n+            mir::TerminatorKind::FalseUnwind { real_target, unwind } => {\n+                self.propagate_bits_into_entry_set_for(in_out, real_target, dirty_list);\n+                if let Some(unwind) = unwind {\n+                    if !self.dead_unwinds.contains(bb) {\n+                        self.propagate_bits_into_entry_set_for(in_out, unwind, dirty_list);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    fn propagate_bits_into_entry_set_for(\n+        &mut self,\n+        in_out: &BitSet<A::Idx>,\n+        bb: BasicBlock,\n+        dirty_queue: &mut WorkQueue<BasicBlock>,\n+    ) {\n+        let entry_set = &mut self.entry_sets[bb];\n+        let set_changed = self.analysis.join(entry_set, &in_out);\n+        if set_changed {\n+            dirty_queue.insert(bb);\n+        }\n+    }\n+}"}, {"sha": "55baeef8860d017f736fc4d84e2554a3cdd69f1e", "filename": "src/librustc_mir/dataflow/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ceb72e4ad144f4887f67e539bcd143b4d303dade/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ceb72e4ad144f4887f67e539bcd143b4d303dade/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs?ref=ceb72e4ad144f4887f67e539bcd143b4d303dade", "patch": "@@ -30,6 +30,7 @@ use self::move_paths::MoveData;\n \n mod at_location;\n pub mod drop_flag_effects;\n+pub mod generic;\n mod graphviz;\n mod impls;\n pub mod move_paths;"}, {"sha": "c4738d846be6311b75daeb04e8065c370c6a09ac", "filename": "src/librustc_mir/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ceb72e4ad144f4887f67e539bcd143b4d303dade/src%2Flibrustc_mir%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ceb72e4ad144f4887f67e539bcd143b4d303dade/src%2Flibrustc_mir%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Flib.rs?ref=ceb72e4ad144f4887f67e539bcd143b4d303dade", "patch": "@@ -23,6 +23,7 @@ Rust MIR: a lowered representation of Rust. Also: an experiment!\n #![feature(try_blocks)]\n #![feature(mem_take)]\n #![feature(associated_type_bounds)]\n+#![feature(range_is_empty)]\n \n #![recursion_limit=\"256\"]\n "}]}