{"sha": "9520cba554e2844c92ede32066138c38de3d327f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk1MjBjYmE1NTRlMjg0NGM5MmVkZTMyMDY2MTM4YzM4ZGUzZDMyN2Y=", "commit": {"author": {"name": "nahuakang", "email": "kangnahua@gmail.com", "date": "2021-02-09T19:21:22Z"}, "committer": {"name": "Yoshitomo Nakanishi", "email": "yurayura.rounin.3@gmail.com", "date": "2021-03-02T09:13:32Z"}, "message": "Add check_infinite_loop to its own module", "tree": {"sha": "6ffd60e44d9d8ce941d7486ae23534f04574122d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6ffd60e44d9d8ce941d7486ae23534f04574122d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9520cba554e2844c92ede32066138c38de3d327f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9520cba554e2844c92ede32066138c38de3d327f", "html_url": "https://github.com/rust-lang/rust/commit/9520cba554e2844c92ede32066138c38de3d327f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9520cba554e2844c92ede32066138c38de3d327f/comments", "author": {"login": "nahuakang", "id": 18533347, "node_id": "MDQ6VXNlcjE4NTMzMzQ3", "avatar_url": "https://avatars.githubusercontent.com/u/18533347?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nahuakang", "html_url": "https://github.com/nahuakang", "followers_url": "https://api.github.com/users/nahuakang/followers", "following_url": "https://api.github.com/users/nahuakang/following{/other_user}", "gists_url": "https://api.github.com/users/nahuakang/gists{/gist_id}", "starred_url": "https://api.github.com/users/nahuakang/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nahuakang/subscriptions", "organizations_url": "https://api.github.com/users/nahuakang/orgs", "repos_url": "https://api.github.com/users/nahuakang/repos", "events_url": "https://api.github.com/users/nahuakang/events{/privacy}", "received_events_url": "https://api.github.com/users/nahuakang/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Y-Nak", "id": 6376004, "node_id": "MDQ6VXNlcjYzNzYwMDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6376004?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Y-Nak", "html_url": "https://github.com/Y-Nak", "followers_url": "https://api.github.com/users/Y-Nak/followers", "following_url": "https://api.github.com/users/Y-Nak/following{/other_user}", "gists_url": "https://api.github.com/users/Y-Nak/gists{/gist_id}", "starred_url": "https://api.github.com/users/Y-Nak/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Y-Nak/subscriptions", "organizations_url": "https://api.github.com/users/Y-Nak/orgs", "repos_url": "https://api.github.com/users/Y-Nak/repos", "events_url": "https://api.github.com/users/Y-Nak/events{/privacy}", "received_events_url": "https://api.github.com/users/Y-Nak/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1e5e541ac57e6757fe8c6c3b316a750730ba7f8c", "url": "https://api.github.com/repos/rust-lang/rust/commits/1e5e541ac57e6757fe8c6c3b316a750730ba7f8c", "html_url": "https://github.com/rust-lang/rust/commit/1e5e541ac57e6757fe8c6c3b316a750730ba7f8c"}], "stats": {"total": 275, "additions": 143, "deletions": 132}, "files": [{"sha": "b89942fb647559b4270ea5a7a1807c5b62ec8b87", "filename": "clippy_lints/src/loops/infinite_loop.rs", "status": "added", "additions": 138, "deletions": 0, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/9520cba554e2844c92ede32066138c38de3d327f/clippy_lints%2Fsrc%2Floops%2Finfinite_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9520cba554e2844c92ede32066138c38de3d327f/clippy_lints%2Fsrc%2Floops%2Finfinite_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Finfinite_loop.rs?ref=9520cba554e2844c92ede32066138c38de3d327f", "patch": "@@ -0,0 +1,138 @@\n+use crate::consts::constant;\n+use crate::utils::span_lint_and_then;\n+use crate::utils::usage::mutated_variables;\n+use if_chain::if_chain;\n+use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+use rustc_hir::def::{DefKind, Res};\n+use rustc_hir::intravisit::{walk_expr, NestedVisitorMap, Visitor};\n+use rustc_hir::{def_id, Expr, ExprKind, HirId, QPath};\n+use rustc_lint::LateContext;\n+use rustc_middle::hir::map::Map;\n+use std::iter::Iterator;\n+\n+pub(super) fn check_infinite_loop<'tcx>(cx: &LateContext<'tcx>, cond: &'tcx Expr<'_>, expr: &'tcx Expr<'_>) {\n+    if constant(cx, cx.typeck_results(), cond).is_some() {\n+        // A pure constant condition (e.g., `while false`) is not linted.\n+        return;\n+    }\n+\n+    let mut var_visitor = VarCollectorVisitor {\n+        cx,\n+        ids: FxHashSet::default(),\n+        def_ids: FxHashMap::default(),\n+        skip: false,\n+    };\n+    var_visitor.visit_expr(cond);\n+    if var_visitor.skip {\n+        return;\n+    }\n+    let used_in_condition = &var_visitor.ids;\n+    let no_cond_variable_mutated = if let Some(used_mutably) = mutated_variables(expr, cx) {\n+        used_in_condition.is_disjoint(&used_mutably)\n+    } else {\n+        return;\n+    };\n+    let mutable_static_in_cond = var_visitor.def_ids.iter().any(|(_, v)| *v);\n+\n+    let mut has_break_or_return_visitor = HasBreakOrReturnVisitor {\n+        has_break_or_return: false,\n+    };\n+    has_break_or_return_visitor.visit_expr(expr);\n+    let has_break_or_return = has_break_or_return_visitor.has_break_or_return;\n+\n+    if no_cond_variable_mutated && !mutable_static_in_cond {\n+        span_lint_and_then(\n+            cx,\n+            super::WHILE_IMMUTABLE_CONDITION,\n+            cond.span,\n+            \"variables in the condition are not mutated in the loop body\",\n+            |diag| {\n+                diag.note(\"this may lead to an infinite or to a never running loop\");\n+\n+                if has_break_or_return {\n+                    diag.note(\"this loop contains `return`s or `break`s\");\n+                    diag.help(\"rewrite it as `if cond { loop { } }`\");\n+                }\n+            },\n+        );\n+    }\n+}\n+\n+struct HasBreakOrReturnVisitor {\n+    has_break_or_return: bool,\n+}\n+\n+impl<'tcx> Visitor<'tcx> for HasBreakOrReturnVisitor {\n+    type Map = Map<'tcx>;\n+\n+    fn visit_expr(&mut self, expr: &'tcx Expr<'_>) {\n+        if self.has_break_or_return {\n+            return;\n+        }\n+\n+        match expr.kind {\n+            ExprKind::Ret(_) | ExprKind::Break(_, _) => {\n+                self.has_break_or_return = true;\n+                return;\n+            },\n+            _ => {},\n+        }\n+\n+        walk_expr(self, expr);\n+    }\n+\n+    fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n+        NestedVisitorMap::None\n+    }\n+}\n+\n+/// Collects the set of variables in an expression\n+/// Stops analysis if a function call is found\n+/// Note: In some cases such as `self`, there are no mutable annotation,\n+/// All variables definition IDs are collected\n+struct VarCollectorVisitor<'a, 'tcx> {\n+    cx: &'a LateContext<'tcx>,\n+    ids: FxHashSet<HirId>,\n+    def_ids: FxHashMap<def_id::DefId, bool>,\n+    skip: bool,\n+}\n+\n+impl<'a, 'tcx> VarCollectorVisitor<'a, 'tcx> {\n+    fn insert_def_id(&mut self, ex: &'tcx Expr<'_>) {\n+        if_chain! {\n+            if let ExprKind::Path(ref qpath) = ex.kind;\n+            if let QPath::Resolved(None, _) = *qpath;\n+            let res = self.cx.qpath_res(qpath, ex.hir_id);\n+            then {\n+                match res {\n+                    Res::Local(hir_id) => {\n+                        self.ids.insert(hir_id);\n+                    },\n+                    Res::Def(DefKind::Static, def_id) => {\n+                        let mutable = self.cx.tcx.is_mutable_static(def_id);\n+                        self.def_ids.insert(def_id, mutable);\n+                    },\n+                    _ => {},\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+impl<'a, 'tcx> Visitor<'tcx> for VarCollectorVisitor<'a, 'tcx> {\n+    type Map = Map<'tcx>;\n+\n+    fn visit_expr(&mut self, ex: &'tcx Expr<'_>) {\n+        match ex.kind {\n+            ExprKind::Path(_) => self.insert_def_id(ex),\n+            // If there is any function/method call\u2026 we just stop analysis\n+            ExprKind::Call(..) | ExprKind::MethodCall(..) => self.skip = true,\n+\n+            _ => walk_expr(self, ex),\n+        }\n+    }\n+\n+    fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n+        NestedVisitorMap::None\n+    }\n+}"}, {"sha": "6adfbb6b955ba0b6e24033e8125da849fa4e28fd", "filename": "clippy_lints/src/loops/mod.rs", "status": "modified", "additions": 5, "deletions": 132, "changes": 137, "blob_url": "https://github.com/rust-lang/rust/blob/9520cba554e2844c92ede32066138c38de3d327f/clippy_lints%2Fsrc%2Floops%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9520cba554e2844c92ede32066138c38de3d327f/clippy_lints%2Fsrc%2Floops%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fmod.rs?ref=9520cba554e2844c92ede32066138c38de3d327f", "patch": "@@ -4,10 +4,10 @@ mod for_loop_over_map_kv;\n mod for_loop_range;\n mod for_mut_range_bound;\n mod for_single_element_loop;\n+mod infinite_loop;\n mod manual_flatten;\n mod utils;\n \n-use crate::consts::constant;\n use crate::utils::sugg::Sugg;\n use crate::utils::usage::mutated_variables;\n use crate::utils::{\n@@ -18,13 +18,13 @@ use crate::utils::{\n };\n use if_chain::if_chain;\n use rustc_ast::ast;\n-use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+use rustc_data_structures::fx::FxHashMap;\n use rustc_errors::Applicability;\n use rustc_hir::def::{DefKind, Res};\n use rustc_hir::intravisit::{walk_block, walk_expr, walk_pat, walk_stmt, NestedVisitorMap, Visitor};\n use rustc_hir::{\n-    def_id, BinOpKind, BindingAnnotation, Block, BorrowKind, Expr, ExprKind, GenericArg, HirId, InlineAsmOperand,\n-    Local, LoopSource, MatchSource, Mutability, Node, Pat, PatKind, QPath, Stmt, StmtKind,\n+    BinOpKind, BindingAnnotation, Block, BorrowKind, Expr, ExprKind, GenericArg, HirId, InlineAsmOperand, Local,\n+    LoopSource, MatchSource, Mutability, Node, Pat, PatKind, QPath, Stmt, StmtKind,\n };\n use rustc_lint::{LateContext, LateLintPass, LintContext};\n use rustc_middle::hir::map::Map;\n@@ -683,7 +683,7 @@ impl<'tcx> LateLintPass<'tcx> for Loops {\n         }\n \n         if let Some((cond, body)) = higher::while_loop(&expr) {\n-            check_infinite_loop(cx, cond, body);\n+            infinite_loop::check_infinite_loop(cx, cond, body);\n         }\n \n         check_needless_collect(expr, cx);\n@@ -1895,133 +1895,6 @@ impl<'tcx> Visitor<'tcx> for LoopNestVisitor {\n     }\n }\n \n-fn check_infinite_loop<'tcx>(cx: &LateContext<'tcx>, cond: &'tcx Expr<'_>, expr: &'tcx Expr<'_>) {\n-    if constant(cx, cx.typeck_results(), cond).is_some() {\n-        // A pure constant condition (e.g., `while false`) is not linted.\n-        return;\n-    }\n-\n-    let mut var_visitor = VarCollectorVisitor {\n-        cx,\n-        ids: FxHashSet::default(),\n-        def_ids: FxHashMap::default(),\n-        skip: false,\n-    };\n-    var_visitor.visit_expr(cond);\n-    if var_visitor.skip {\n-        return;\n-    }\n-    let used_in_condition = &var_visitor.ids;\n-    let no_cond_variable_mutated = if let Some(used_mutably) = mutated_variables(expr, cx) {\n-        used_in_condition.is_disjoint(&used_mutably)\n-    } else {\n-        return;\n-    };\n-    let mutable_static_in_cond = var_visitor.def_ids.iter().any(|(_, v)| *v);\n-\n-    let mut has_break_or_return_visitor = HasBreakOrReturnVisitor {\n-        has_break_or_return: false,\n-    };\n-    has_break_or_return_visitor.visit_expr(expr);\n-    let has_break_or_return = has_break_or_return_visitor.has_break_or_return;\n-\n-    if no_cond_variable_mutated && !mutable_static_in_cond {\n-        span_lint_and_then(\n-            cx,\n-            WHILE_IMMUTABLE_CONDITION,\n-            cond.span,\n-            \"variables in the condition are not mutated in the loop body\",\n-            |diag| {\n-                diag.note(\"this may lead to an infinite or to a never running loop\");\n-\n-                if has_break_or_return {\n-                    diag.note(\"this loop contains `return`s or `break`s\");\n-                    diag.help(\"rewrite it as `if cond { loop { } }`\");\n-                }\n-            },\n-        );\n-    }\n-}\n-\n-struct HasBreakOrReturnVisitor {\n-    has_break_or_return: bool,\n-}\n-\n-impl<'tcx> Visitor<'tcx> for HasBreakOrReturnVisitor {\n-    type Map = Map<'tcx>;\n-\n-    fn visit_expr(&mut self, expr: &'tcx Expr<'_>) {\n-        if self.has_break_or_return {\n-            return;\n-        }\n-\n-        match expr.kind {\n-            ExprKind::Ret(_) | ExprKind::Break(_, _) => {\n-                self.has_break_or_return = true;\n-                return;\n-            },\n-            _ => {},\n-        }\n-\n-        walk_expr(self, expr);\n-    }\n-\n-    fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n-        NestedVisitorMap::None\n-    }\n-}\n-\n-/// Collects the set of variables in an expression\n-/// Stops analysis if a function call is found\n-/// Note: In some cases such as `self`, there are no mutable annotation,\n-/// All variables definition IDs are collected\n-struct VarCollectorVisitor<'a, 'tcx> {\n-    cx: &'a LateContext<'tcx>,\n-    ids: FxHashSet<HirId>,\n-    def_ids: FxHashMap<def_id::DefId, bool>,\n-    skip: bool,\n-}\n-\n-impl<'a, 'tcx> VarCollectorVisitor<'a, 'tcx> {\n-    fn insert_def_id(&mut self, ex: &'tcx Expr<'_>) {\n-        if_chain! {\n-            if let ExprKind::Path(ref qpath) = ex.kind;\n-            if let QPath::Resolved(None, _) = *qpath;\n-            let res = self.cx.qpath_res(qpath, ex.hir_id);\n-            then {\n-                match res {\n-                    Res::Local(hir_id) => {\n-                        self.ids.insert(hir_id);\n-                    },\n-                    Res::Def(DefKind::Static, def_id) => {\n-                        let mutable = self.cx.tcx.is_mutable_static(def_id);\n-                        self.def_ids.insert(def_id, mutable);\n-                    },\n-                    _ => {},\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-impl<'a, 'tcx> Visitor<'tcx> for VarCollectorVisitor<'a, 'tcx> {\n-    type Map = Map<'tcx>;\n-\n-    fn visit_expr(&mut self, ex: &'tcx Expr<'_>) {\n-        match ex.kind {\n-            ExprKind::Path(_) => self.insert_def_id(ex),\n-            // If there is any function/method call\u2026 we just stop analysis\n-            ExprKind::Call(..) | ExprKind::MethodCall(..) => self.skip = true,\n-\n-            _ => walk_expr(self, ex),\n-        }\n-    }\n-\n-    fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n-        NestedVisitorMap::None\n-    }\n-}\n-\n const NEEDLESS_COLLECT_MSG: &str = \"avoid using `collect()` when not needed\";\n \n fn check_needless_collect<'tcx>(expr: &'tcx Expr<'_>, cx: &LateContext<'tcx>) {"}]}