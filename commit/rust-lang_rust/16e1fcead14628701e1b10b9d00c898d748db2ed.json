{"sha": "16e1fcead14628701e1b10b9d00c898d748db2ed", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE2ZTFmY2VhZDE0NjI4NzAxZTFiMTBiOWQwMGM4OThkNzQ4ZGIyZWQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-04-15T01:05:03Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-04-15T01:05:03Z"}, "message": "Auto merge of #24433 - alexcrichton:rollup, r=alexcrichton", "tree": {"sha": "37d18d85fa9631880c287c3795d5b4b3d8994f20", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/37d18d85fa9631880c287c3795d5b4b3d8994f20"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/16e1fcead14628701e1b10b9d00c898d748db2ed", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/16e1fcead14628701e1b10b9d00c898d748db2ed", "html_url": "https://github.com/rust-lang/rust/commit/16e1fcead14628701e1b10b9d00c898d748db2ed", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/16e1fcead14628701e1b10b9d00c898d748db2ed/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8415fa27877a4309a79b08c75a52eb4c3546b7a5", "url": "https://api.github.com/repos/rust-lang/rust/commits/8415fa27877a4309a79b08c75a52eb4c3546b7a5", "html_url": "https://github.com/rust-lang/rust/commit/8415fa27877a4309a79b08c75a52eb4c3546b7a5"}, {"sha": "e053571df21fda7bb909c1b79de9b0cbe1a2931d", "url": "https://api.github.com/repos/rust-lang/rust/commits/e053571df21fda7bb909c1b79de9b0cbe1a2931d", "html_url": "https://github.com/rust-lang/rust/commit/e053571df21fda7bb909c1b79de9b0cbe1a2931d"}], "stats": {"total": 27388, "additions": 1564, "deletions": 25824}, "files": [{"sha": "eeb1493d86856d240dc099485b3964a63fb278d0", "filename": "src/compiletest/compiletest.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Fcompiletest%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Fcompiletest%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcompiletest.rs?ref=16e1fcead14628701e1b10b9d00c898d748db2ed", "patch": "@@ -12,16 +12,16 @@\n \n #![feature(box_syntax)]\n #![feature(collections)]\n-#![feature(old_io)]\n #![feature(rustc_private)]\n-#![feature(unboxed_closures)]\n #![feature(std_misc)]\n #![feature(test)]\n #![feature(path_ext)]\n #![feature(str_char)]\n+#![feature(libc)]\n \n #![deny(warnings)]\n \n+extern crate libc;\n extern crate test;\n extern crate getopts;\n \n@@ -42,6 +42,7 @@ pub mod header;\n pub mod runtest;\n pub mod common;\n pub mod errors;\n+mod raise_fd_limit;\n \n pub fn main() {\n     let config = parse_config(env::args().collect());\n@@ -245,11 +246,7 @@ pub fn run_tests(config: &Config) {\n     // sadly osx needs some file descriptor limits raised for running tests in\n     // parallel (especially when we have lots and lots of child processes).\n     // For context, see #8904\n-    #[allow(deprecated)]\n-    fn raise_fd_limit() {\n-        std::old_io::test::raise_fd_limit();\n-    }\n-    raise_fd_limit();\n+    unsafe { raise_fd_limit::raise_fd_limit(); }\n     // Prevent issue #21352 UAC blocking .exe containing 'patch' etc. on Windows\n     // If #11207 is resolved (adding manifest to .exe) this becomes unnecessary\n     env::set_var(\"__COMPAT_LAYER\", \"RunAsInvoker\");"}, {"sha": "89b9135558e062b9df9ba337811236c71d56de1e", "filename": "src/compiletest/raise_fd_limit.rs", "status": "added", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Fcompiletest%2Fraise_fd_limit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Fcompiletest%2Fraise_fd_limit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fraise_fd_limit.rs?ref=16e1fcead14628701e1b10b9d00c898d748db2ed", "patch": "@@ -0,0 +1,79 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+/// darwin_fd_limit exists to work around an issue where launchctl on Mac OS X\n+/// defaults the rlimit maxfiles to 256/unlimited. The default soft limit of 256\n+/// ends up being far too low for our multithreaded scheduler testing, depending\n+/// on the number of cores available.\n+///\n+/// This fixes issue #7772.\n+#[cfg(any(target_os = \"macos\", target_os = \"ios\"))]\n+#[allow(non_camel_case_types)]\n+pub unsafe fn raise_fd_limit() {\n+    use libc;\n+    use std::cmp;\n+    use std::io;\n+    use std::mem::size_of_val;\n+    use std::ptr::null_mut;\n+\n+    type rlim_t = libc::uint64_t;\n+\n+    #[repr(C)]\n+    struct rlimit {\n+        rlim_cur: rlim_t,\n+        rlim_max: rlim_t\n+    }\n+    extern {\n+        // name probably doesn't need to be mut, but the C function doesn't\n+        // specify const\n+        fn sysctl(name: *mut libc::c_int, namelen: libc::c_uint,\n+                  oldp: *mut libc::c_void, oldlenp: *mut libc::size_t,\n+                  newp: *mut libc::c_void, newlen: libc::size_t) -> libc::c_int;\n+        fn getrlimit(resource: libc::c_int, rlp: *mut rlimit) -> libc::c_int;\n+        fn setrlimit(resource: libc::c_int, rlp: *const rlimit) -> libc::c_int;\n+    }\n+    static CTL_KERN: libc::c_int = 1;\n+    static KERN_MAXFILESPERPROC: libc::c_int = 29;\n+    static RLIMIT_NOFILE: libc::c_int = 8;\n+\n+    // The strategy here is to fetch the current resource limits, read the\n+    // kern.maxfilesperproc sysctl value, and bump the soft resource limit for\n+    // maxfiles up to the sysctl value.\n+\n+    // Fetch the kern.maxfilesperproc value\n+    let mut mib: [libc::c_int; 2] = [CTL_KERN, KERN_MAXFILESPERPROC];\n+    let mut maxfiles: libc::c_int = 0;\n+    let mut size: libc::size_t = size_of_val(&maxfiles) as libc::size_t;\n+    if sysctl(&mut mib[0], 2, &mut maxfiles as *mut _ as *mut _, &mut size,\n+              null_mut(), 0) != 0 {\n+        let err = io::Error::last_os_error();\n+        panic!(\"raise_fd_limit: error calling sysctl: {}\", err);\n+    }\n+\n+    // Fetch the current resource limits\n+    let mut rlim = rlimit{rlim_cur: 0, rlim_max: 0};\n+    if getrlimit(RLIMIT_NOFILE, &mut rlim) != 0 {\n+        let err = io::Error::last_os_error();\n+        panic!(\"raise_fd_limit: error calling getrlimit: {}\", err);\n+    }\n+\n+    // Bump the soft limit to the smaller of kern.maxfilesperproc and the hard\n+    // limit\n+    rlim.rlim_cur = cmp::min(maxfiles as rlim_t, rlim.rlim_max);\n+\n+    // Set our newly-increased resource limit\n+    if setrlimit(RLIMIT_NOFILE, &rlim) != 0 {\n+        let err = io::Error::last_os_error();\n+        panic!(\"raise_fd_limit: error calling setrlimit: {}\", err);\n+    }\n+}\n+\n+#[cfg(not(any(target_os = \"macos\", target_os = \"ios\")))]\n+pub unsafe fn raise_fd_limit() {}"}, {"sha": "55f158675321bf920c853755d5faa22d739a6cf5", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=16e1fcead14628701e1b10b9d00c898d748db2ed", "patch": "@@ -29,7 +29,6 @@ use std::net::TcpStream;\n use std::path::{Path, PathBuf};\n use std::process::{Command, Output, ExitStatus};\n use std::str;\n-use std::time::Duration;\n use test::MetricMap;\n \n pub fn run(config: Config, testfile: &Path) {\n@@ -452,11 +451,7 @@ fn run_debuginfo_gdb_test(config: &Config, props: &TestProps, testfile: &Path) {\n                 .expect(&format!(\"failed to exec `{:?}`\", config.adb_path));\n             loop {\n                 //waiting 1 second for gdbserver start\n-                #[allow(deprecated)]\n-                fn sleep() {\n-                    ::std::old_io::timer::sleep(Duration::milliseconds(1000));\n-                }\n-                sleep();\n+                ::std::thread::sleep_ms(1000);\n                 if TcpStream::connect(\"127.0.0.1:5039\").is_ok() {\n                     break\n                 }"}, {"sha": "124a82aa7dc80c3c6c765f3dbd87785c9055f0da", "filename": "src/doc/index.md", "status": "modified", "additions": 6, "deletions": 14, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Fdoc%2Findex.md", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Fdoc%2Findex.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Findex.md?ref=16e1fcead14628701e1b10b9d00c898d748db2ed", "patch": "@@ -15,6 +15,12 @@ Rust, its syntax, and its concepts. Upon completing the book, you'll be an\n intermediate Rust developer, and will have a good grasp of the fundamental\n ideas behind Rust.\n \n+[Rust By Example][rbe] was originally a community resource, but was then\n+donated to the Rust project. As the name implies, it teaches you Rust through a\n+series of small examples.\n+\n+[rbe]: rustbyexample.com\n+\n # Community & Getting Help\n \n If you need help with something, or just want to talk about Rust with others,\n@@ -76,17 +82,3 @@ We have [API documentation for the entire standard\n library](std/index.html). There's a list of crates on the left with more\n specific sections, or you can use the search bar at the top to search for\n something if you know its name.\n-\n-# External documentation\n-\n-*Note: While these are great resources for learning Rust, they may track a\n-particular version of Rust that is likely not exactly the same as that for\n-which this documentation was generated.*\n-\n-* [Rust by Example] - Short examples of common tasks in Rust (tracks the master\n-  branch).\n-* [Rust for Rubyists] - The first community tutorial for Rust. Tracks the last\n-  stable release. Not just for Ruby programmers.\n-\n-[Rust by Example]: http://rustbyexample.com/\n-[Rust for Rubyists]: http://www.rustforrubyists.com/"}, {"sha": "e6d560d8122e6c9bb29899be075a83d6ed05df18", "filename": "src/doc/intro.md", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Fdoc%2Fintro.md", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Fdoc%2Fintro.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fintro.md?ref=16e1fcead14628701e1b10b9d00c898d748db2ed", "patch": "@@ -389,6 +389,7 @@ safe concurrent programs.\n Here's an example of a concurrent Rust program:\n \n ```{rust}\n+# #![feature(scoped)]\n use std::thread;\n \n fn main() {\n@@ -421,6 +422,7 @@ problem.\n Let's see an example. This Rust code will not compile:\n \n ```{rust,ignore}\n+# #![feature(scoped)]\n use std::thread;\n \n fn main() {\n@@ -467,6 +469,7 @@ that our mutation doesn't cause a data race.\n Here's what using a Mutex looks like:\n \n ```{rust}\n+# #![feature(scoped)]\n use std::thread;\n use std::sync::Mutex;\n \n@@ -527,6 +530,7 @@ As an example, Rust's ownership system is _entirely_ at compile time. The\n safety check that makes this an error about moved values:\n \n ```{rust,ignore}\n+# #![feature(scoped)]\n use std::thread;\n \n fn main() {"}, {"sha": "fa27d1c226cc494cdf06bc9ce24b2a71d7d1d3fc", "filename": "src/doc/trpl/comments.md", "status": "modified", "additions": 18, "deletions": 20, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Fdoc%2Ftrpl%2Fcomments.md", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Fdoc%2Ftrpl%2Fcomments.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fcomments.md?ref=16e1fcead14628701e1b10b9d00c898d748db2ed", "patch": "@@ -1,47 +1,45 @@\n % Comments\n \n-Now that we have some functions, it's a good idea to learn about comments.\n+Now that we have some functions, it\u2019s a good idea to learn about comments.\n Comments are notes that you leave to other programmers to help explain things\n about your code. The compiler mostly ignores them.\n \n Rust has two kinds of comments that you should care about: *line comments*\n and *doc comments*.\n \n-```{rust}\n-// Line comments are anything after '//' and extend to the end of the line.\n+```rust\n+// Line comments are anything after \u2018//\u2019 and extend to the end of the line.\n \n let x = 5; // this is also a line comment.\n \n // If you have a long explanation for something, you can put line comments next\n-// to each other. Put a space between the // and your comment so that it's\n+// to each other. Put a space between the // and your comment so that it\u2019s\n // more readable.\n ```\n \n The other kind of comment is a doc comment. Doc comments use `///` instead of\n `//`, and support Markdown notation inside:\n \n-```{rust}\n-/// `hello` is a function that prints a greeting that is personalized based on\n-/// the name given.\n-///\n-/// # Arguments\n-///\n-/// * `name` - The name of the person you'd like to greet.\n+```rust\n+/// Adds one to the number given.\n ///\n /// # Examples\n ///\n-/// ```rust\n-/// let name = \"Steve\";\n-/// hello(name); // prints \"Hello, Steve!\"\n /// ```\n-fn hello(name: &str) {\n-    println!(\"Hello, {}!\", name);\n+/// let five = 5;\n+///\n+/// assert_eq!(6, add_one(5));\n+/// ```\n+fn add_one(x: i32) -> i32 {\n+    x + 1\n }\n ```\n \n-When writing doc comments, adding sections for any arguments, return values,\n-and providing some examples of usage is very, very helpful. Don't worry about\n-the `&str`, we'll get to it soon.\n+When writing doc comments, providing some examples of usage is very, very\n+helpful. You\u2019ll notice we\u2019ve used a new macro here: `assert_eq!`. This compares\n+two values, and `panic!`s if they\u2019re not equal to each other. It\u2019s very helpful\n+in documentation. There\u2019s another macro, `assert!`, which `panic!`s if the\n+value passed to it is `false`.\n \n You can use the [`rustdoc`](documentation.html) tool to generate HTML documentation\n-from these doc comments.\n+from these doc comments, and also to run the code examples as tests!"}, {"sha": "159e04e9429a079a048c204757bf0ed4513c639c", "filename": "src/doc/trpl/concurrency.md", "status": "modified", "additions": 8, "deletions": 41, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Fdoc%2Ftrpl%2Fconcurrency.md", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Fdoc%2Ftrpl%2Fconcurrency.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fconcurrency.md?ref=16e1fcead14628701e1b10b9d00c898d748db2ed", "patch": "@@ -56,68 +56,35 @@ place!\n \n ## Threads\n \n-Rust's standard library provides a library for 'threads', which allow you to\n+Rust's standard library provides a library for threads, which allow you to\n run Rust code in parallel. Here's a basic example of using `std::thread`:\n \n ```\n use std::thread;\n \n fn main() {\n-    thread::scoped(|| {\n+    thread::spawn(|| {\n         println!(\"Hello from a thread!\");\n     });\n }\n ```\n \n-The `thread::scoped()` method accepts a closure, which is executed in a new\n-thread. It's called `scoped` because this thread returns a join guard:\n+The `thread::spawn()` method accepts a closure, which is executed in a\n+new thread. It returns a handle to the thread, that can be used to\n+wait for the child thread to finish and extract its result:\n \n ```\n use std::thread;\n \n fn main() {\n-    let guard = thread::scoped(|| {\n-        println!(\"Hello from a thread!\");\n+    let handle = thread::spawn(|| {\n+        \"Hello from a thread!\"\n     });\n \n-    // guard goes out of scope here\n+    println!(\"{}\", handle.join().unwrap());\n }\n ```\n \n-When `guard` goes out of scope, it will block execution until the thread is\n-finished. If we didn't want this behaviour, we could use `thread::spawn()`:\n-\n-```\n-use std::thread;\n-\n-fn main() {\n-    thread::spawn(|| {\n-        println!(\"Hello from a thread!\");\n-    });\n-\n-    thread::sleep_ms(50);\n-}\n-```\n-\n-We need to `sleep` here because when `main()` ends, it kills all of the\n-running threads.\n-\n-[`scoped`](std/thread/struct.Builder.html#method.scoped) has an interesting\n-type signature:\n-\n-```text\n-fn scoped<'a, T, F>(self, f: F) -> JoinGuard<'a, T>\n-    where T: Send + 'a,\n-          F: FnOnce() -> T,\n-          F: Send + 'a\n-```\n-\n-Specifically, `F`, the closure that we pass to execute in the new thread. It\n-has two restrictions: It must be a `FnOnce` from `()` to `T`. Using `FnOnce`\n-allows the closure to take ownership of any data it mentions from the parent\n-thread. The other restriction is that `F` must be `Send`. We aren't allowed to\n-transfer this ownership unless the type thinks that's okay.\n-\n Many languages have the ability to execute threads, but it's wildly unsafe.\n There are entire books about how to prevent errors that occur from shared\n mutable state. Rust helps out with its type system here as well, by preventing"}, {"sha": "504bd099171babc2b95cb8f9013784b084301807", "filename": "src/doc/trpl/enums.md", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Fdoc%2Ftrpl%2Fenums.md", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Fdoc%2Ftrpl%2Fenums.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fenums.md?ref=16e1fcead14628701e1b10b9d00c898d748db2ed", "patch": "@@ -143,7 +143,5 @@ matching, a tool that will let us deconstruct sum types (the type theory term\n for enums) like `Ordering` in a very elegant way that avoids all these messy\n and brittle `if`/`else`s.\n \n-\n-[arity]: ./glossary.html#arity\n [match]: ./match.html\n [generics]: ./generics.html"}, {"sha": "491f7b0c2a0f34f906f454f2e733118432224dab", "filename": "src/doc/trpl/error-handling.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Fdoc%2Ftrpl%2Ferror-handling.md", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Fdoc%2Ftrpl%2Ferror-handling.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Ferror-handling.md?ref=16e1fcead14628701e1b10b9d00c898d748db2ed", "patch": "@@ -297,5 +297,5 @@ It's worth noting that you can only use `try!` from a function that returns a\n `Result`, which means that you cannot use `try!` inside of `main()`, because\n `main()` doesn't return anything.\n \n-`try!` makes use of [`FromError`](../std/error/#the-fromerror-trait) to determine\n+`try!` makes use of [`From<Error>`](../std/convert/trait.From.hml) to determine\n what to return in the error case."}, {"sha": "87af48532a050dd35a736ebe2fbfb8fc5cd754cf", "filename": "src/doc/trpl/functions.md", "status": "modified", "additions": 85, "deletions": 51, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Fdoc%2Ftrpl%2Ffunctions.md", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Fdoc%2Ftrpl%2Ffunctions.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Ffunctions.md?ref=16e1fcead14628701e1b10b9d00c898d748db2ed", "patch": "@@ -1,31 +1,31 @@\n % Functions\n \n-You've already seen one function so far, the `main` function:\n+Every Rust program has at least one function, the `main` function:\n \n ```rust\n fn main() {\n }\n ```\n \n This is the simplest possible function declaration. As we mentioned before,\n-`fn` says \"this is a function,\" followed by the name, some parentheses because\n+`fn` says \u2018this is a function\u2019, followed by the name, some parentheses because\n this function takes no arguments, and then some curly braces to indicate the\n-body. Here's a function named `foo`:\n+body. Here\u2019s a function named `foo`:\n \n ```rust\n fn foo() {\n }\n ```\n \n-So, what about taking arguments? Here's a function that prints a number:\n+So, what about taking arguments? Here\u2019s a function that prints a number:\n \n ```rust\n fn print_number(x: i32) {\n     println!(\"x is: {}\", x);\n }\n ```\n \n-Here's a complete program that uses `print_number`:\n+Here\u2019s a complete program that uses `print_number`:\n \n ```rust\n fn main() {\n@@ -40,7 +40,7 @@ fn print_number(x: i32) {\n As you can see, function arguments work very similar to `let` declarations:\n you add a type to the argument name, after a colon.\n \n-Here's a complete program that adds two numbers together and prints them:\n+Here\u2019s a complete program that adds two numbers together and prints them:\n \n ```rust\n fn main() {\n@@ -58,7 +58,7 @@ as when you declare it.\n Unlike `let`, you _must_ declare the types of function arguments. This does\n not work:\n \n-```{rust,ignore}\n+```rust,ignore\n fn print_sum(x, y) {\n     println!(\"sum is: {}\", x + y);\n }\n@@ -67,8 +67,8 @@ fn print_sum(x, y) {\n You get this error:\n \n ```text\n-hello.rs:5:18: 5:19 expected one of `!`, `:`, or `@`, found `)`\n-hello.rs:5 fn print_number(x, y) {\n+expected one of `!`, `:`, or `@`, found `)`\n+fn print_number(x, y) {\n ```\n \n This is a deliberate design decision. While full-program inference is possible,\n@@ -77,7 +77,7 @@ types explicitly is a best-practice. We agree that forcing functions to declare\n types while allowing for inference inside of function bodies is a wonderful\n sweet spot between full inference and no inference.\n \n-What about returning a value? Here's a function that adds one to an integer:\n+What about returning a value? Here\u2019s a function that adds one to an integer:\n \n ```rust\n fn add_one(x: i32) -> i32 {\n@@ -86,11 +86,11 @@ fn add_one(x: i32) -> i32 {\n ```\n \n Rust functions return exactly one value, and you declare the type after an\n-\"arrow,\" which is a dash (`-`) followed by a greater-than sign (`>`).\n+\u2018arrow\u2019, which is a dash (`-`) followed by a greater-than sign (`>`). The last\n+line of a function determines what it returns. You\u2019ll note the lack of a\n+semicolon here. If we added it in:\n \n-You'll note the lack of a semicolon here. If we added it in:\n-\n-```{rust,ignore}\n+```rust,ignore\n fn add_one(x: i32) -> i32 {\n     x + 1;\n }\n@@ -109,60 +109,99 @@ help: consider removing this semicolon:\n           ^\n ```\n \n-Remember our earlier discussions about semicolons and `()`? Our function claims\n-to return an `i32`, but with a semicolon, it would return `()` instead. Rust\n-realizes this probably isn't what we want, and suggests removing the semicolon.\n+This reveals two interesting things about Rust: it is an expression-based\n+language, and semicolons are different from semicolons in other \u2018curly brace\n+and semicolon\u2019-based languages. These two things are related.\n \n-This is very much like our `if` statement before: the result of the block\n-(`{}`) is the value of the expression. Other expression-oriented languages,\n-such as Ruby, work like this, but it's a bit unusual in the systems programming\n-world. When people first learn about this, they usually assume that it\n-introduces bugs. But because Rust's type system is so strong, and because unit\n-is its own unique type, we have never seen an issue where adding or removing a\n-semicolon in a return position would cause a bug.\n+## Expressions vs. Statements\n \n-But what about early returns? Rust does have a keyword for that, `return`:\n+Rust is primarily an expression-based language. There are only two kinds of\n+statements, and everything else is an expression.\n \n-```rust\n-fn foo(x: i32) -> i32 {\n-    if x < 5 { return x; }\n+So what's the difference? Expressions return a value, and statements do not.\n+That\u2019s why we end up with \u2018not all control paths return a value\u2019 here: the\n+statement `x + 1;` doesn\u2019t return a value. There are two kinds of statements in\n+Rust: \u2018declaration statements\u2019 and \u2018expression statements\u2019. Everything else is\n+an expression. Let\u2019s talk about declaration statements first.\n+\n+In some languages, variable bindings can be written as expressions, not just\n+statements. Like Ruby:\n+\n+```ruby\n+x = y = 5\n+```\n+\n+In Rust, however, using `let` to introduce a binding is _not_ an expression. The\n+following will produce a compile-time error:\n+\n+```ignore\n+let x = (let y = 5); // expected identifier, found keyword `let`\n+```\n+\n+The compiler is telling us here that it was expecting to see the beginning of\n+an expression, and a `let` can only begin a statement, not an expression.\n+\n+Note that assigning to an already-bound variable (e.g. `y = 5`) is still an\n+expression, although its value is not particularly useful. Unlike other\n+languages where an assignment evaluates to the assigned value (e.g. `5` in the\n+previous example), in Rust the value of an assignment is an empty tuple `()`:\n+\n+```\n+let mut y = 5;\n+\n+let x = (y = 6);  // x has the value `()`, not `6`\n+```\n+\n+The second kind of statement in Rust is the *expression statement*. Its\n+purpose is to turn any expression into a statement. In practical terms, Rust's\n+grammar expects statements to follow other statements. This means that you use\n+semicolons to separate expressions from each other. This means that Rust\n+looks a lot like most other languages that require you to use semicolons\n+at the end of every line, and you will see semicolons at the end of almost\n+every line of Rust code you see.\n \n+What is this exception that makes us say \"almost\"? You saw it already, in this\n+code:\n+\n+```rust\n+fn add_one(x: i32) -> i32 {\n     x + 1\n }\n ```\n \n-Using a `return` as the last line of a function works, but is considered poor\n-style:\n+Our function claims to return an `i32`, but with a semicolon, it would return\n+`()` instead. Rust realizes this probably isn\u2019t what we want, and suggests\n+removing the semicolon in the error we saw before.\n+\n+## Early returns\n+\n+But what about early returns? Rust does have a keyword for that, `return`:\n \n ```rust\n fn foo(x: i32) -> i32 {\n-    if x < 5 { return x; }\n+    return x;\n \n-    return x + 1;\n+    // we never run this code!\n+    x + 1\n }\n ```\n \n-The previous definition without `return` may look a bit strange if you haven't\n-worked in an expression-based language before, but it becomes intuitive over\n-time. If this were production code, we wouldn't write it in that way anyway,\n-we'd write this:\n+Using a `return` as the last line of a function works, but is considered poor\n+style:\n \n ```rust\n fn foo(x: i32) -> i32 {\n-    if x < 5 {\n-        x\n-    } else {\n-        x + 1\n-    }\n+    return x + 1;\n }\n ```\n \n-Because `if` is an expression, and it's the only expression in this function,\n-the value will be the result of the `if`.\n+The previous definition without `return` may look a bit strange if you haven\u2019t\n+worked in an expression-based language before, but it becomes intuitive over\n+time.\n \n ## Diverging functions\n \n-Rust has some special syntax for 'diverging functions', which are functions that\n+Rust has some special syntax for \u2018diverging functions\u2019, which are functions that\n do not return:\n \n ```\n@@ -171,23 +210,18 @@ fn diverges() -> ! {\n }\n ```\n \n-`panic!` is a macro, similar to `println!()` that we've already seen. Unlike\n+`panic!` is a macro, similar to `println!()` that we\u2019ve already seen. Unlike\n `println!()`, `panic!()` causes the current thread of execution to crash with\n the given message.\n \n Because this function will cause a crash, it will never return, and so it has\n-the type '`!`', which is read \"diverges.\" A diverging function can be used\n+the type \u2018`!`\u2019, which is read \u2018diverges\u2019. A diverging function can be used\n as any type:\n \n ```should_panic\n # fn diverges() -> ! {\n #    panic!(\"This function never returns!\");\n # }\n-\n let x: i32 = diverges();\n let x: String = diverges();\n ```\n-\n-We don't have a good use for diverging functions yet, because they're used in\n-conjunction with other Rust features. But when you see `-> !` later, you'll\n-know what it's called."}, {"sha": "3b76cce568c72d13559d13901ce88bc94fe241af", "filename": "src/doc/trpl/nightly-rust.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Fdoc%2Ftrpl%2Fnightly-rust.md", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Fdoc%2Ftrpl%2Fnightly-rust.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fnightly-rust.md?ref=16e1fcead14628701e1b10b9d00c898d748db2ed", "patch": "@@ -18,7 +18,7 @@ use a two-step version of the installation and examine our installation script:\n \n ```bash\n $ curl -f -L https://static.rust-lang.org/rustup.sh -O\n-$ sudo sh rustup.sh\n+$ sudo sh rustup.sh --channel=nightly\n ```\n \n [insecurity]: http://curlpipesh.tumblr.com"}, {"sha": "83d5a15bc2c0a831137e6233df6140e2f2827ba0", "filename": "src/doc/trpl/structs.md", "status": "modified", "additions": 45, "deletions": 5, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Fdoc%2Ftrpl%2Fstructs.md", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Fdoc%2Ftrpl%2Fstructs.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fstructs.md?ref=16e1fcead14628701e1b10b9d00c898d748db2ed", "patch": "@@ -1,8 +1,15 @@\n % Structs\n \n-A struct is another form of a *record type*, just like a tuple. There's a\n-difference: structs give each element that they contain a name, called a\n-*field* or a *member*. Check it out:\n+Structs are a way of creating more complex datatypes. For example, if we were\n+doing calculations involving coordinates in 2D space, we would need both an `x`\n+and a `y` value:\n+\n+```rust\n+let origin_x = 0;\n+let origin_y = 0;\n+```\n+\n+A struct lets us combine these two into a single, unified datatype:\n \n ```rust\n struct Point {\n@@ -17,7 +24,7 @@ fn main() {\n }\n ```\n \n-There's a lot going on here, so let's break it down. We declare a struct with\n+There\u2019s a lot going on here, so let\u2019s break it down. We declare a struct with\n the `struct` keyword, and then with a name. By convention, structs begin with a\n capital letter and are also camel cased: `PointInSpace`, not `Point_In_Space`.\n \n@@ -31,7 +38,7 @@ notation: `origin.x`.\n The values in structs are immutable by default, like other bindings in Rust.\n Use `mut` to make them mutable:\n \n-```{rust}\n+```rust\n struct Point {\n     x: i32,\n     y: i32,\n@@ -47,3 +54,36 @@ fn main() {\n ```\n \n This will print `The point is at (5, 0)`.\n+\n+Rust does not support field mutability at the language level, so you cannot\n+write something like this:\n+\n+```rust,ignore\n+struct Point {\n+    mut x: i32,\n+    y: i32,\n+}\n+```\n+\n+Mutability is a property of the binding, not of the structure itself. If you\u2019re\n+used to field-level mutability, this may seem strange at first, but it\n+significantly simplifies things. It even lets you make things mutable for a short\n+time only:\n+\n+\n+```rust,ignore\n+struct Point {\n+    x: i32,\n+    y: i32,\n+}\n+\n+fn main() {\n+    let mut point = Point { x: 0, y: 0 };\n+\n+    point.x = 5;\n+\n+    let point = point; // this new binding can\u2019t change now\n+\n+    point.y = 6; // this causes an error\n+}\n+```"}, {"sha": "0dfbfc11913470d9f5c538706e8fe0b69636fd29", "filename": "src/doc/trpl/vectors.md", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Fdoc%2Ftrpl%2Fvectors.md", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Fdoc%2Ftrpl%2Fvectors.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fvectors.md?ref=16e1fcead14628701e1b10b9d00c898d748db2ed", "patch": "@@ -1,8 +1,7 @@\n % Vectors\n \n A *vector* is a dynamic or \"growable\" array, implemented as the standard\n-library type [`Vec<T>`](../std/vec/) (we'll talk about what the `<T>` means\n-later). Vectors always allocate their data on the heap. Vectors are to slices\n+library type [`Vec<T>`](../std/vec/) (Where `<T>` is a [Generic](./generics.md) statement). Vectors always allocate their data on the heap. Vectors are to slices\n what `String` is to `&str`. You can create them with the `vec!` macro:\n \n ```{rust}"}, {"sha": "d12b979e084fc33c8edb75a1c8e6d754c4d770a2", "filename": "src/libcollections/bit.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibcollections%2Fbit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibcollections%2Fbit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbit.rs?ref=16e1fcead14628701e1b10b9d00c898d748db2ed", "patch": "@@ -923,7 +923,7 @@ impl BitVec {\n         self.set(insert_pos, elem);\n     }\n \n-    /// Return the total number of bits in this vector\n+    /// Returns the total number of bits in this vector\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn len(&self) -> usize { self.nbits }\n@@ -1695,7 +1695,7 @@ impl BitSet {\n         self.other_op(other, |w1, w2| w1 ^ w2);\n     }\n \n-    /// Return the number of set bits in this set.\n+    /// Returns the number of set bits in this set.\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn len(&self) -> usize  {"}, {"sha": "413100039a2cc5ca50fc35110b74a4d970da5e03", "filename": "src/libcollections/btree/map.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fmap.rs?ref=16e1fcead14628701e1b10b9d00c898d748db2ed", "patch": "@@ -1339,7 +1339,7 @@ impl<K, V> BTreeMap<K, V> {\n         Values { inner: self.iter().map(second) }\n     }\n \n-    /// Return the number of elements in the map.\n+    /// Returns the number of elements in the map.\n     ///\n     /// # Examples\n     ///\n@@ -1354,7 +1354,7 @@ impl<K, V> BTreeMap<K, V> {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn len(&self) -> usize { self.length }\n \n-    /// Return true if the map contains no elements.\n+    /// Returns true if the map contains no elements.\n     ///\n     /// # Examples\n     ///"}, {"sha": "1abd56fd1458d25dab2562ff4d0ea9597831882d", "filename": "src/libcollections/btree/set.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibcollections%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibcollections%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fset.rs?ref=16e1fcead14628701e1b10b9d00c898d748db2ed", "patch": "@@ -284,7 +284,7 @@ impl<T: Ord> BTreeSet<T> {\n         Union{a: self.iter().peekable(), b: other.iter().peekable()}\n     }\n \n-    /// Return the number of elements in the set\n+    /// Returns the number of elements in the set.\n     ///\n     /// # Examples\n     ///\n@@ -299,7 +299,7 @@ impl<T: Ord> BTreeSet<T> {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn len(&self) -> usize { self.map.len() }\n \n-    /// Returns true if the set contains no elements\n+    /// Returns true if the set contains no elements.\n     ///\n     /// # Examples\n     ///"}, {"sha": "5179b04f8824dcb6152362eeb9453cb7f44f5f6b", "filename": "src/libcollections/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibcollections%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibcollections%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flib.rs?ref=16e1fcead14628701e1b10b9d00c898d748db2ed", "patch": "@@ -40,6 +40,7 @@\n #![feature(str_char)]\n #![feature(slice_patterns)]\n #![feature(debug_builders)]\n+#![feature(utf8_error)]\n #![cfg_attr(test, feature(rand, rustc_private, test, hash, collections))]\n #![cfg_attr(test, allow(deprecated))] // rand\n "}, {"sha": "391439bcdf2ff93beecabfcf1cc4834d79946aeb", "filename": "src/libcollections/linked_list.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibcollections%2Flinked_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibcollections%2Flinked_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flinked_list.rs?ref=16e1fcead14628701e1b10b9d00c898d748db2ed", "patch": "@@ -943,7 +943,7 @@ mod test {\n     use std::clone::Clone;\n     use std::iter::Iterator;\n     use std::option::Option::{Some, None, self};\n-    use std::rand;\n+    use std::__rand::{thread_rng, Rng};\n     use std::thread;\n     use std::vec::Vec;\n \n@@ -1095,7 +1095,7 @@ mod test {\n         let mut v = vec![];\n         for i in 0..sz {\n             check_links(&m);\n-            let r: u8 = rand::random();\n+            let r: u8 = thread_rng().next_u32() as u8;\n             match r % 6 {\n                 0 => {\n                     m.pop_back();"}, {"sha": "5be9739cb32de7ccba1e6dbcf61e4b12f0683a62", "filename": "src/libcollections/slice.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibcollections%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibcollections%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fslice.rs?ref=16e1fcead14628701e1b10b9d00c898d748db2ed", "patch": "@@ -549,7 +549,7 @@ impl<T> [T] {\n         core_slice::SliceExt::binary_search_by(self, f)\n     }\n \n-    /// Return the number of elements in the slice\n+    /// Returns the number of elements in the slice.\n     ///\n     /// # Example\n     ///\n@@ -757,7 +757,7 @@ impl<T> [T] {\n         core_slice::SliceExt::get_unchecked_mut(self, index)\n     }\n \n-    /// Return an unsafe mutable pointer to the slice's buffer.\n+    /// Returns an unsafe mutable pointer to the slice's buffer.\n     ///\n     /// The caller must ensure that the slice outlives the pointer this\n     /// function returns, or else it will end up pointing to garbage.\n@@ -984,7 +984,7 @@ impl<T> [T] {\n         core_slice::SliceExt::ends_with(self, needle)\n     }\n \n-    /// Convert `self` into a vector without clones or allocation.\n+    /// Converts `self` into a vector without clones or allocation.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn into_vec(self: Box<Self>) -> Vec<T> {"}, {"sha": "e1da8b3b3bccd375e3e3d250a60ac4498bdc8207", "filename": "src/libcollections/str.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibcollections%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibcollections%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstr.rs?ref=16e1fcead14628701e1b10b9d00c898d748db2ed", "patch": "@@ -1248,7 +1248,7 @@ impl str {\n         core_str::StrExt::trim_right_matches(&self[..], pat)\n     }\n \n-    /// Check that `index`-th byte lies at the start and/or end of a\n+    /// Checks that `index`-th byte lies at the start and/or end of a\n     /// UTF-8 code point sequence.\n     ///\n     /// The start and end of the string (when `index == self.len()`) are\n@@ -1435,7 +1435,7 @@ impl str {\n         core_str::StrExt::char_at_reverse(&self[..], i)\n     }\n \n-    /// Convert `self` to a byte slice.\n+    /// Converts `self` to a byte slice.\n     ///\n     /// # Examples\n     ///\n@@ -1591,7 +1591,7 @@ impl str {\n         core_str::StrExt::subslice_offset(&self[..], inner)\n     }\n \n-    /// Return an unsafe pointer to the `&str`'s buffer.\n+    /// Returns an unsafe pointer to the `&str`'s buffer.\n     ///\n     /// The caller must ensure that the string outlives this pointer, and\n     /// that it is not\n@@ -1609,7 +1609,7 @@ impl str {\n         core_str::StrExt::as_ptr(&self[..])\n     }\n \n-    /// Return an iterator of `u16` over the string encoded as UTF-16.\n+    /// Returns an iterator of `u16` over the string encoded as UTF-16.\n     #[unstable(feature = \"collections\",\n                reason = \"this functionality may only be provided by libunicode\")]\n     pub fn utf16_units(&self) -> Utf16Units {"}, {"sha": "51ce5564c49c5eedc1c9172df04758ea5467b05f", "filename": "src/libcollections/string.rs", "status": "modified", "additions": 13, "deletions": 17, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibcollections%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibcollections%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstring.rs?ref=16e1fcead14628701e1b10b9d00c898d748db2ed", "patch": "@@ -132,7 +132,7 @@ impl String {\n     ///\n     /// let invalid_vec = vec![240, 144, 128];\n     /// let s = String::from_utf8(invalid_vec).err().unwrap();\n-    /// assert_eq!(s.utf8_error(), Utf8Error::TooShort);\n+    /// let err = s.utf8_error();\n     /// assert_eq!(s.into_bytes(), [240, 144, 128]);\n     /// ```\n     #[inline]\n@@ -156,14 +156,10 @@ impl String {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn from_utf8_lossy<'a>(v: &'a [u8]) -> Cow<'a, str> {\n-        let mut i = 0;\n+        let mut i;\n         match str::from_utf8(v) {\n             Ok(s) => return Cow::Borrowed(s),\n-            Err(e) => {\n-                if let Utf8Error::InvalidByte(firstbad) = e {\n-                    i = firstbad;\n-                }\n-            }\n+            Err(e) => i = e.valid_up_to(),\n         }\n \n         const TAG_CONT_U8: u8 = 128;\n@@ -188,9 +184,9 @@ impl String {\n             };\n         }\n \n-        // subseqidx is the index of the first byte of the subsequence we're looking at.\n-        // It's used to copy a bunch of contiguous good codepoints at once instead of copying\n-        // them one by one.\n+        // subseqidx is the index of the first byte of the subsequence we're\n+        // looking at.  It's used to copy a bunch of contiguous good codepoints\n+        // at once instead of copying them one by one.\n         let mut subseqidx = i;\n \n         while i < total {\n@@ -347,7 +343,7 @@ impl String {\n         String { vec: bytes }\n     }\n \n-    /// Return the underlying byte buffer, encoded as UTF-8.\n+    /// Returns the underlying byte buffer, encoded as UTF-8.\n     ///\n     /// # Examples\n     ///\n@@ -363,7 +359,7 @@ impl String {\n         self.vec\n     }\n \n-    /// Extract a string slice containing the entire string.\n+    /// Extracts a string slice containing the entire string.\n     #[inline]\n     #[unstable(feature = \"convert\",\n                reason = \"waiting on RFC revision\")]\n@@ -607,7 +603,7 @@ impl String {\n         ch\n     }\n \n-    /// Insert a character into the string buffer at byte position `idx`.\n+    /// Inserts a character into the string buffer at byte position `idx`.\n     ///\n     /// # Warning\n     ///\n@@ -662,7 +658,7 @@ impl String {\n         &mut self.vec\n     }\n \n-    /// Return the number of bytes in this string.\n+    /// Returns the number of bytes in this string.\n     ///\n     /// # Examples\n     ///\n@@ -705,12 +701,12 @@ impl String {\n }\n \n impl FromUtf8Error {\n-    /// Consume this error, returning the bytes that were attempted to make a\n+    /// Consumes this error, returning the bytes that were attempted to make a\n     /// `String` with.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn into_bytes(self) -> Vec<u8> { self.bytes }\n \n-    /// Access the underlying UTF8-error that was the cause of this error.\n+    /// Accesss the underlying UTF8-error that was the cause of this error.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn utf8_error(&self) -> Utf8Error { self.error }\n }\n@@ -959,7 +955,7 @@ impl<'a> Deref for DerefString<'a> {\n     }\n }\n \n-/// Convert a string slice to a wrapper type providing a `&String` reference.\n+/// Converts a string slice to a wrapper type providing a `&String` reference.\n ///\n /// # Examples\n ///"}, {"sha": "4fa91a6a16a526ca9369b7ddfe4bc9b8b0209ddb", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=16e1fcead14628701e1b10b9d00c898d748db2ed", "patch": "@@ -393,7 +393,7 @@ impl<T> Vec<T> {\n         }\n     }\n \n-    /// Convert the vector into Box<[T]>.\n+    /// Converts the vector into Box<[T]>.\n     ///\n     /// Note that this will drop any excess capacity. Calling this and\n     /// converting back to a vector with `into_vec()` is equivalent to calling\n@@ -434,7 +434,7 @@ impl<T> Vec<T> {\n         }\n     }\n \n-    /// Extract a slice containing the entire vector.\n+    /// Extracts a slice containing the entire vector.\n     #[inline]\n     #[unstable(feature = \"convert\",\n                reason = \"waiting on RFC revision\")]\n@@ -1936,7 +1936,7 @@ impl<'a, T> Drop for DerefVec<'a, T> {\n     }\n }\n \n-/// Convert a slice to a wrapper type providing a `&Vec<T>` reference.\n+/// Converts a slice to a wrapper type providing a `&Vec<T>` reference.\n #[unstable(feature = \"collections\")]\n pub fn as_vec<'a, T>(x: &'a [T]) -> DerefVec<'a, T> {\n     unsafe {"}, {"sha": "a66cde81c8ba5943dd1adb609cd707b581d6c049", "filename": "src/libcollections/vec_deque.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibcollections%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibcollections%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec_deque.rs?ref=16e1fcead14628701e1b10b9d00c898d748db2ed", "patch": "@@ -481,7 +481,7 @@ impl<T> VecDeque<T> {\n         }\n     }\n \n-    /// Shorten a ringbuf, dropping excess elements from the back.\n+    /// Shortens a ringbuf, dropping excess elements from the back.\n     ///\n     /// If `len` is greater than the ringbuf's current length, this has no\n     /// effect."}, {"sha": "cb86e4ab38d3d0b0bf37937c85cc6875b44585ea", "filename": "src/libcollections/vec_map.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibcollections%2Fvec_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibcollections%2Fvec_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec_map.rs?ref=16e1fcead14628701e1b10b9d00c898d748db2ed", "patch": "@@ -452,7 +452,7 @@ impl<V> VecMap<V> {\n         Drain { iter: self.v.drain().enumerate().filter_map(filter) }\n     }\n \n-    /// Return the number of elements in the map.\n+    /// Returns the number of elements in the map.\n     ///\n     /// # Examples\n     ///\n@@ -470,7 +470,7 @@ impl<V> VecMap<V> {\n         self.v.iter().filter(|elt| elt.is_some()).count()\n     }\n \n-    /// Return true if the map contains no elements.\n+    /// Returns true if the map contains no elements.\n     ///\n     /// # Examples\n     ///"}, {"sha": "4e150d4a222341cc456eafb31a45747bbf78e1fe", "filename": "src/libcollectionstest/bench.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibcollectionstest%2Fbench.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibcollectionstest%2Fbench.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Fbench.rs?ref=16e1fcead14628701e1b10b9d00c898d748db2ed", "patch": "@@ -12,14 +12,13 @@ macro_rules! map_insert_rand_bench {\n     ($name: ident, $n: expr, $map: ident) => (\n         #[bench]\n         pub fn $name(b: &mut ::test::Bencher) {\n-            use std::rand;\n-            use std::rand::Rng;\n+            use std::__rand::{thread_rng, Rng};\n             use test::black_box;\n \n             let n: usize = $n;\n             let mut map = $map::new();\n             // setup\n-            let mut rng = rand::weak_rng();\n+            let mut rng = thread_rng();\n \n             for _ in 0..n {\n                 let i = rng.gen::<usize>() % n;\n@@ -67,16 +66,15 @@ macro_rules! map_find_rand_bench {\n         #[bench]\n         pub fn $name(b: &mut ::test::Bencher) {\n             use std::iter::Iterator;\n-            use std::rand::Rng;\n-            use std::rand;\n+            use std::__rand::{thread_rng, Rng};\n             use std::vec::Vec;\n             use test::black_box;\n \n             let mut map = $map::new();\n             let n: usize = $n;\n \n             // setup\n-            let mut rng = rand::weak_rng();\n+            let mut rng = thread_rng();\n             let mut keys: Vec<_> = (0..n).map(|_| rng.gen::<usize>() % n).collect();\n \n             for &k in &keys {"}, {"sha": "d020f551dd55dcd842df23048ce9db885ef4f6ad", "filename": "src/libcollectionstest/bit/set.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibcollectionstest%2Fbit%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibcollectionstest%2Fbit%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Fbit%2Fset.rs?ref=16e1fcead14628701e1b10b9d00c898d748db2ed", "patch": "@@ -389,16 +389,15 @@ fn test_bit_vec_clone() {\n \n mod bench {\n     use std::collections::{BitSet, BitVec};\n-    use std::rand::{Rng, self};\n+    use std::__rand::{Rng, thread_rng, ThreadRng};\n     use std::u32;\n \n     use test::{Bencher, black_box};\n \n     const BENCH_BITS : usize = 1 << 14;\n \n-    fn rng() -> rand::IsaacRng {\n-        let seed: &[_] = &[1, 2, 3, 4, 5, 6, 7, 8, 9, 0];\n-        rand::SeedableRng::from_seed(seed)\n+    fn rng() -> ThreadRng {\n+        thread_rng()\n     }\n \n     #[bench]"}, {"sha": "3cddaef07915ef6a03d7a8620d4d223c4d2d5ef6", "filename": "src/libcollectionstest/bit/vec.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibcollectionstest%2Fbit%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibcollectionstest%2Fbit%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Fbit%2Fvec.rs?ref=16e1fcead14628701e1b10b9d00c898d748db2ed", "patch": "@@ -633,15 +633,14 @@ fn test_bit_vec_extend() {\n mod bench {\n     use std::collections::BitVec;\n     use std::u32;\n-    use std::rand::{Rng, self};\n+    use std::__rand::{Rng, thread_rng, ThreadRng};\n \n     use test::{Bencher, black_box};\n \n     const BENCH_BITS : usize = 1 << 14;\n \n-    fn rng() -> rand::IsaacRng {\n-        let seed: &[_] = &[1, 2, 3, 4, 5, 6, 7, 8, 9, 0];\n-        rand::SeedableRng::from_seed(seed)\n+    fn rng() -> ThreadRng {\n+        thread_rng()\n     }\n \n     #[bench]"}, {"sha": "a29968ae8a2fc5f03eb01fbd2872ca1b5307e6da", "filename": "src/libcollectionstest/btree/map.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibcollectionstest%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibcollectionstest%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Fbtree%2Fmap.rs?ref=16e1fcead14628701e1b10b9d00c898d748db2ed", "patch": "@@ -251,7 +251,7 @@ fn test_entry(){\n \n mod bench {\n     use std::collections::BTreeMap;\n-    use std::rand::{Rng, weak_rng};\n+    use std::__rand::{Rng, thread_rng};\n \n     use test::{Bencher, black_box};\n \n@@ -269,7 +269,7 @@ mod bench {\n \n     fn bench_iter(b: &mut Bencher, size: i32) {\n         let mut map = BTreeMap::<i32, i32>::new();\n-        let mut rng = weak_rng();\n+        let mut rng = thread_rng();\n \n         for _ in 0..size {\n             map.insert(rng.gen(), rng.gen());"}, {"sha": "e1c4e05e192c7f85df4b18f935518b185b6ab466", "filename": "src/libcollectionstest/slice.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibcollectionstest%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibcollectionstest%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Fslice.rs?ref=16e1fcead14628701e1b10b9d00c898d748db2ed", "patch": "@@ -12,7 +12,7 @@ use std::cmp::Ordering::{Equal, Greater, Less};\n use std::default::Default;\n use std::iter::RandomAccessIterator;\n use std::mem;\n-use std::rand::{Rng, thread_rng};\n+use std::__rand::{Rng, thread_rng};\n use std::rc::Rc;\n use std::slice::ElementSwaps;\n \n@@ -1296,7 +1296,7 @@ fn test_to_vec() {\n mod bench {\n     use std::iter::repeat;\n     use std::{mem, ptr};\n-    use std::rand::{Rng, weak_rng};\n+    use std::__rand::{Rng, thread_rng};\n \n     use test::{Bencher, black_box};\n \n@@ -1465,7 +1465,7 @@ mod bench {\n \n     #[bench]\n     fn random_inserts(b: &mut Bencher) {\n-        let mut rng = weak_rng();\n+        let mut rng = thread_rng();\n         b.iter(|| {\n             let mut v: Vec<_> = repeat((0, 0)).take(30).collect();\n             for _ in 0..100 {\n@@ -1477,7 +1477,7 @@ mod bench {\n     }\n     #[bench]\n     fn random_removes(b: &mut Bencher) {\n-        let mut rng = weak_rng();\n+        let mut rng = thread_rng();\n         b.iter(|| {\n             let mut v: Vec<_> = repeat((0, 0)).take(130).collect();\n             for _ in 0..100 {\n@@ -1489,7 +1489,7 @@ mod bench {\n \n     #[bench]\n     fn sort_random_small(b: &mut Bencher) {\n-        let mut rng = weak_rng();\n+        let mut rng = thread_rng();\n         b.iter(|| {\n             let mut v: Vec<_> = rng.gen_iter::<u64>().take(5).collect();\n             v.sort();\n@@ -1499,7 +1499,7 @@ mod bench {\n \n     #[bench]\n     fn sort_random_medium(b: &mut Bencher) {\n-        let mut rng = weak_rng();\n+        let mut rng = thread_rng();\n         b.iter(|| {\n             let mut v: Vec<_> = rng.gen_iter::<u64>().take(100).collect();\n             v.sort();\n@@ -1509,7 +1509,7 @@ mod bench {\n \n     #[bench]\n     fn sort_random_large(b: &mut Bencher) {\n-        let mut rng = weak_rng();\n+        let mut rng = thread_rng();\n         b.iter(|| {\n             let mut v: Vec<_> = rng.gen_iter::<u64>().take(10000).collect();\n             v.sort();\n@@ -1530,7 +1530,7 @@ mod bench {\n \n     #[bench]\n     fn sort_big_random_small(b: &mut Bencher) {\n-        let mut rng = weak_rng();\n+        let mut rng = thread_rng();\n         b.iter(|| {\n             let mut v = rng.gen_iter::<BigSortable>().take(5)\n                            .collect::<Vec<BigSortable>>();\n@@ -1541,7 +1541,7 @@ mod bench {\n \n     #[bench]\n     fn sort_big_random_medium(b: &mut Bencher) {\n-        let mut rng = weak_rng();\n+        let mut rng = thread_rng();\n         b.iter(|| {\n             let mut v = rng.gen_iter::<BigSortable>().take(100)\n                            .collect::<Vec<BigSortable>>();\n@@ -1552,7 +1552,7 @@ mod bench {\n \n     #[bench]\n     fn sort_big_random_large(b: &mut Bencher) {\n-        let mut rng = weak_rng();\n+        let mut rng = thread_rng();\n         b.iter(|| {\n             let mut v = rng.gen_iter::<BigSortable>().take(10000)\n                            .collect::<Vec<BigSortable>>();"}, {"sha": "cacafab4e3c19f69f975b104bb89226686936f2b", "filename": "src/libcollectionstest/str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibcollectionstest%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibcollectionstest%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Fstr.rs?ref=16e1fcead14628701e1b10b9d00c898d748db2ed", "patch": "@@ -1502,7 +1502,7 @@ fn test_str_from_utf8() {\n     assert_eq!(from_utf8(xs), Ok(\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\"));\n \n     let xs = b\"hello\\xFF\";\n-    assert_eq!(from_utf8(xs), Err(Utf8Error::TooShort));\n+    assert!(from_utf8(xs).is_err());\n }\n \n #[test]"}, {"sha": "3184f842e9ae9799f3230702eaf55e96be4d5731", "filename": "src/libcollectionstest/string.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibcollectionstest%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibcollectionstest%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Fstring.rs?ref=16e1fcead14628701e1b10b9d00c898d748db2ed", "patch": "@@ -45,7 +45,6 @@ fn test_from_utf8() {\n \n     let xs = b\"hello\\xFF\".to_vec();\n     let err = String::from_utf8(xs).err().unwrap();\n-    assert_eq!(err.utf8_error(), Utf8Error::TooShort);\n     assert_eq!(err.into_bytes(), b\"hello\\xff\".to_vec());\n }\n "}, {"sha": "85b8accadf3e58665d4520591d773d98b6aceb1d", "filename": "src/libcore/any.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibcore%2Fany.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibcore%2Fany.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fany.rs?ref=16e1fcead14628701e1b10b9d00c898d748db2ed", "patch": "@@ -91,7 +91,7 @@ use marker::{Reflect, Sized};\n /// [mod]: index.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait Any: Reflect + 'static {\n-    /// Get the `TypeId` of `self`\n+    /// Gets the `TypeId` of `self`.\n     #[unstable(feature = \"core\",\n                reason = \"this method will likely be replaced by an associated static\")]\n     fn get_type_id(&self) -> TypeId;"}, {"sha": "02f9ee506f990f625caa9ff8f612da0f5d3590b3", "filename": "src/libcore/atomic.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibcore%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibcore%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fatomic.rs?ref=16e1fcead14628701e1b10b9d00c898d748db2ed", "patch": "@@ -78,12 +78,20 @@ use intrinsics;\n use cell::UnsafeCell;\n use marker::PhantomData;\n \n+use default::Default;\n+\n /// A boolean type which can be safely shared between threads.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct AtomicBool {\n     v: UnsafeCell<usize>,\n }\n \n+impl Default for AtomicBool {\n+    fn default() -> AtomicBool {\n+        ATOMIC_BOOL_INIT\n+    }\n+}\n+\n unsafe impl Sync for AtomicBool {}\n \n /// A signed integer type which can be safely shared between threads.\n@@ -92,6 +100,12 @@ pub struct AtomicIsize {\n     v: UnsafeCell<isize>,\n }\n \n+impl Default for AtomicIsize {\n+    fn default() -> AtomicIsize {\n+        ATOMIC_ISIZE_INIT\n+    }\n+}\n+\n unsafe impl Sync for AtomicIsize {}\n \n /// An unsigned integer type which can be safely shared between threads.\n@@ -100,6 +114,12 @@ pub struct AtomicUsize {\n     v: UnsafeCell<usize>,\n }\n \n+impl Default for AtomicUsize {\n+    fn default() -> AtomicUsize {\n+        ATOMIC_USIZE_INIT\n+    }\n+}\n+\n unsafe impl Sync for AtomicUsize {}\n \n /// A raw pointer type which can be safely shared between threads."}, {"sha": "df0de234b9a16ef9bc5ce6f2032d6c42bea77008", "filename": "src/libcore/cell.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibcore%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibcore%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcell.rs?ref=16e1fcead14628701e1b10b9d00c898d748db2ed", "patch": "@@ -211,7 +211,7 @@ impl<T:Copy> Cell<T> {\n         }\n     }\n \n-    /// Get a reference to the underlying `UnsafeCell`.\n+    /// Gets a reference to the underlying `UnsafeCell`.\n     ///\n     /// # Unsafety\n     ///\n@@ -436,7 +436,7 @@ impl<T> RefCell<T> {\n         }\n     }\n \n-    /// Get a reference to the underlying `UnsafeCell`.\n+    /// Gets a reference to the underlying `UnsafeCell`.\n     ///\n     /// This can be used to circumvent `RefCell`'s safety checks.\n     ///\n@@ -537,7 +537,7 @@ impl<'b, T> Deref for Ref<'b, T> {\n     }\n }\n \n-/// Copy a `Ref`.\n+/// Copies a `Ref`.\n ///\n /// The `RefCell` is already immutably borrowed, so this cannot fail.\n ///\n@@ -647,7 +647,7 @@ pub struct UnsafeCell<T> {\n impl<T> !Sync for UnsafeCell<T> {}\n \n impl<T> UnsafeCell<T> {\n-    /// Construct a new instance of `UnsafeCell` which will wrap the specified\n+    /// Constructs a new instance of `UnsafeCell` which will wrap the specified\n     /// value.\n     ///\n     /// All access to the inner value through methods is `unsafe`, and it is highly discouraged to\n@@ -685,7 +685,7 @@ impl<T> UnsafeCell<T> {\n         &self.value as *const T as *mut T\n     }\n \n-    /// Unwraps the value\n+    /// Unwraps the value.\n     ///\n     /// # Unsafety\n     ///"}, {"sha": "f11c01507dcd8aa22950cd7311c4e8abe552dc3f", "filename": "src/libcore/clone.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibcore%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibcore%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fclone.rs?ref=16e1fcead14628701e1b10b9d00c898d748db2ed", "patch": "@@ -38,7 +38,7 @@ pub trait Clone : Sized {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn clone(&self) -> Self;\n \n-    /// Perform copy-assignment from `source`.\n+    /// Performs copy-assignment from `source`.\n     ///\n     /// `a.clone_from(&b)` is equivalent to `a = b.clone()` in functionality,\n     /// but can be overridden to reuse the resources of `a` to avoid unnecessary\n@@ -52,7 +52,7 @@ pub trait Clone : Sized {\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T: ?Sized> Clone for &'a T {\n-    /// Return a shallow copy of the reference.\n+    /// Returns a shallow copy of the reference.\n     #[inline]\n     fn clone(&self) -> &'a T { *self }\n }\n@@ -61,7 +61,7 @@ macro_rules! clone_impl {\n     ($t:ty) => {\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         impl Clone for $t {\n-            /// Return a deep copy of the value.\n+            /// Returns a deep copy of the value.\n             #[inline]\n             fn clone(&self) -> $t { *self }\n         }\n@@ -92,28 +92,28 @@ macro_rules! extern_fn_clone {\n         #[unstable(feature = \"core\",\n                    reason = \"this may not be sufficient for fns with region parameters\")]\n         impl<$($A,)* ReturnType> Clone for extern \"Rust\" fn($($A),*) -> ReturnType {\n-            /// Return a copy of a function pointer\n+            /// Returns a copy of a function pointer.\n             #[inline]\n             fn clone(&self) -> extern \"Rust\" fn($($A),*) -> ReturnType { *self }\n         }\n \n         #[unstable(feature = \"core\", reason = \"brand new\")]\n         impl<$($A,)* ReturnType> Clone for extern \"C\" fn($($A),*) -> ReturnType {\n-            /// Return a copy of a function pointer\n+            /// Returns a copy of a function pointer.\n             #[inline]\n             fn clone(&self) -> extern \"C\" fn($($A),*) -> ReturnType { *self }\n         }\n \n         #[unstable(feature = \"core\", reason = \"brand new\")]\n         impl<$($A,)* ReturnType> Clone for unsafe extern \"Rust\" fn($($A),*) -> ReturnType {\n-            /// Return a copy of a function pointer\n+            /// Returns a copy of a function pointer.\n             #[inline]\n             fn clone(&self) -> unsafe extern \"Rust\" fn($($A),*) -> ReturnType { *self }\n         }\n \n         #[unstable(feature = \"core\", reason = \"brand new\")]\n         impl<$($A,)* ReturnType> Clone for unsafe extern \"C\" fn($($A),*) -> ReturnType {\n-            /// Return a copy of a function pointer\n+            /// Returns a copy of a function pointer.\n             #[inline]\n             fn clone(&self) -> unsafe extern \"C\" fn($($A),*) -> ReturnType { *self }\n         }"}, {"sha": "72c25c68040222ffd48913bf88c41b5b23b18332", "filename": "src/libcore/fmt/float.rs", "status": "modified", "additions": 29, "deletions": 91, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibcore%2Ffmt%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibcore%2Ffmt%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Ffloat.rs?ref=16e1fcead14628701e1b10b9d00c898d748db2ed", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2013-2015 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -8,14 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![allow(missing_docs)]\n-\n pub use self::ExponentFormat::*;\n pub use self::SignificantDigits::*;\n-pub use self::SignFormat::*;\n \n-use char;\n-use char::CharExt;\n+use char::{self, CharExt};\n use fmt;\n use iter::Iterator;\n use num::{cast, Float, ToPrimitive};\n@@ -46,67 +42,42 @@ pub enum SignificantDigits {\n     DigExact(usize)\n }\n \n-/// How to emit the sign of a number.\n-pub enum SignFormat {\n-    /// `-` will be printed for negative values, but no sign will be emitted\n-    /// for positive numbers.\n-    SignNeg\n-}\n-\n-const DIGIT_E_RADIX: u32 = ('e' as u32) - ('a' as u32) + 11;\n-\n-/// Converts a number to its string representation as a byte vector.\n-/// This is meant to be a common base implementation for all numeric string\n-/// conversion functions like `to_string()` or `to_str_radix()`.\n+/// Converts a float number to its string representation.\n+/// This is meant to be a common base implementation for various formatting styles.\n+/// The number is assumed to be non-negative, callers use `Formatter::pad_integral`\n+/// to add the right sign, if any.\n ///\n /// # Arguments\n ///\n-/// - `num`           - The number to convert. Accepts any number that\n+/// - `num`           - The number to convert (non-negative). Accepts any number that\n ///                     implements the numeric traits.\n-/// - `radix`         - Base to use. Accepts only the values 2-36. If the exponential notation\n-///                     is used, then this base is only used for the significand. The exponent\n-///                     itself always printed using a base of 10.\n-/// - `negative_zero` - Whether to treat the special value `-0` as\n-///                     `-0` or as `+0`.\n-/// - `sign`          - How to emit the sign. See `SignFormat`.\n /// - `digits`        - The amount of digits to use for emitting the fractional\n ///                     part, if any. See `SignificantDigits`.\n /// - `exp_format`   - Whether or not to use the exponential (scientific) notation.\n ///                    See `ExponentFormat`.\n /// - `exp_capital`   - Whether or not to use a capital letter for the exponent sign, if\n ///                     exponential notation is desired.\n-/// - `f`             - A closure to invoke with the bytes representing the\n+/// - `f`             - A closure to invoke with the string representing the\n ///                     float.\n ///\n /// # Panics\n ///\n-/// - Panics if `radix` < 2 or `radix` > 36.\n-/// - Panics if `radix` > 14 and `exp_format` is `ExpDec` due to conflict\n-///   between digit and exponent sign `'e'`.\n-/// - Panics if `radix` > 25 and `exp_format` is `ExpBin` due to conflict\n-///   between digit and exponent sign `'p'`.\n+/// - Panics if `num` is negative.\n pub fn float_to_str_bytes_common<T: Float, U, F>(\n     num: T,\n-    radix: u32,\n-    negative_zero: bool,\n-    sign: SignFormat,\n     digits: SignificantDigits,\n     exp_format: ExponentFormat,\n     exp_upper: bool,\n     f: F\n ) -> U where\n     F: FnOnce(&str) -> U,\n {\n-    assert!(2 <= radix && radix <= 36);\n-    match exp_format {\n-        ExpDec if radix >= DIGIT_E_RADIX       // decimal exponent 'e'\n-          => panic!(\"float_to_str_bytes_common: radix {} incompatible with \\\n-                    use of 'e' as decimal exponent\", radix),\n-        _ => ()\n-    }\n-\n     let _0: T = Float::zero();\n     let _1: T = Float::one();\n+    let radix: u32 = 10;\n+    let radix_f: T = cast(radix).unwrap();\n+\n+    assert!(num.is_nan() || num >= _0, \"float_to_str_bytes_common: number is negative\");\n \n     match num.classify() {\n         Fp::Nan => return f(\"NaN\"),\n@@ -119,41 +90,28 @@ pub fn float_to_str_bytes_common<T: Float, U, F>(\n         _ => {}\n     }\n \n-    let neg = num < _0 || (negative_zero && _1 / num == Float::neg_infinity());\n-    // For an f64 the exponent is in the range of [-1022, 1023] for base 2, so\n-    // we may have up to that many digits. Give ourselves some extra wiggle room\n-    // otherwise as well.\n-    let mut buf = [0; 1536];\n+    // For an f64 the (decimal) exponent is roughly in the range of [-307, 308], so\n+    // we may have up to that many digits. We err on the side of caution and\n+    // add 50% extra wiggle room.\n+    let mut buf = [0; 462];\n     let mut end = 0;\n-    let radix_gen: T = cast(radix as isize).unwrap();\n \n     let (num, exp) = match exp_format {\n-        ExpNone => (num, 0),\n-        ExpDec if num == _0 => (num, 0),\n-        ExpDec => {\n-            let (exp, exp_base) = match exp_format {\n-                ExpDec => (num.abs().log10().floor(), cast::<f64, T>(10.0f64).unwrap()),\n-                ExpNone => panic!(\"unreachable\"),\n-            };\n-\n-            (num / exp_base.powf(exp), cast::<T, i32>(exp).unwrap())\n+        ExpDec if num != _0 => {\n+            let exp = num.log10().floor();\n+            (num / radix_f.powf(exp), cast::<T, i32>(exp).unwrap())\n         }\n+        _ => (num, 0)\n     };\n \n     // First emit the non-fractional part, looping at least once to make\n     // sure at least a `0` gets emitted.\n     let mut deccum = num.trunc();\n     loop {\n-        // Calculate the absolute value of each digit instead of only\n-        // doing it once for the whole number because a\n-        // representable negative number doesn't necessary have an\n-        // representable additive inverse of the same type\n-        // (See twos complement). But we assume that for the\n-        // numbers [-35 .. 0] we always have [0 .. 35].\n-        let current_digit = (deccum % radix_gen).abs();\n+        let current_digit = deccum % radix_f;\n \n         // Decrease the deccumulator one digit at a time\n-        deccum = deccum / radix_gen;\n+        deccum = deccum / radix_f;\n         deccum = deccum.trunc();\n \n         let c = char::from_digit(current_digit.to_isize().unwrap() as u32, radix);\n@@ -170,15 +128,6 @@ pub fn float_to_str_bytes_common<T: Float, U, F>(\n         DigExact(count) => (true, count + 1, true)\n     };\n \n-    // Decide what sign to put in front\n-    match sign {\n-        SignNeg if neg => {\n-            buf[end] = b'-';\n-            end += 1;\n-        }\n-        _ => ()\n-    }\n-\n     buf[..end].reverse();\n \n     // Remember start of the fractional digits.\n@@ -205,14 +154,11 @@ pub fn float_to_str_bytes_common<T: Float, U, F>(\n               )\n         ) {\n             // Shift first fractional digit into the integer part\n-            deccum = deccum * radix_gen;\n+            deccum = deccum * radix_f;\n \n-            // Calculate the absolute value of each digit.\n-            // See note in first loop.\n-            let current_digit = deccum.trunc().abs();\n+            let current_digit = deccum.trunc();\n \n-            let c = char::from_digit(current_digit.to_isize().unwrap() as u32,\n-                                     radix);\n+            let c = char::from_digit(current_digit.to_isize().unwrap() as u32, radix);\n             buf[end] = c.unwrap() as u8;\n             end += 1;\n \n@@ -301,12 +247,8 @@ pub fn float_to_str_bytes_common<T: Float, U, F>(\n \n     match exp_format {\n         ExpNone => {},\n-        _ => {\n-            buf[end] = match exp_format {\n-                ExpDec if exp_upper => 'E',\n-                ExpDec if !exp_upper => 'e',\n-                _ => panic!(\"unreachable\"),\n-            } as u8;\n+        ExpDec => {\n+            buf[end] = if exp_upper { b'E' } else { b'e' };\n             end += 1;\n \n             struct Filler<'a> {\n@@ -324,11 +266,7 @@ pub fn float_to_str_bytes_common<T: Float, U, F>(\n             }\n \n             let mut filler = Filler { buf: &mut buf, end: &mut end };\n-            match sign {\n-                SignNeg => {\n-                    let _ = fmt::write(&mut filler, format_args!(\"{:-}\", exp));\n-                }\n-            }\n+            let _ = fmt::write(&mut filler, format_args!(\"{:-}\", exp));\n         }\n     }\n "}, {"sha": "80c661b260cbe219a6d9c4ed01130a246cc766d6", "filename": "src/libcore/fmt/mod.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibcore%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibcore%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fmod.rs?ref=16e1fcead14628701e1b10b9d00c898d748db2ed", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2013-2015 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -18,6 +18,7 @@ use clone::Clone;\n use iter::Iterator;\n use marker::{Copy, PhantomData, Sized};\n use mem;\n+use num::Float;\n use option::Option;\n use option::Option::{Some, None};\n use result::Result::Ok;\n@@ -910,33 +911,38 @@ impl<'a, T> Pointer for &'a mut T {\n     }\n }\n \n+// Common code of floating point Debug and Display.\n+fn float_to_str_common<T: Float, F>(num: &T, precision: Option<usize>, post: F) -> Result\n+        where F : FnOnce(&str) -> Result {\n+    let digits = match precision {\n+        Some(i) => float::DigExact(i),\n+        None => float::DigMax(6),\n+    };\n+    float::float_to_str_bytes_common(num.abs(),\n+                                     digits,\n+                                     float::ExpNone,\n+                                     false,\n+                                     post)\n+}\n+\n macro_rules! floating { ($ty:ident) => {\n \n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     impl Debug for $ty {\n         fn fmt(&self, fmt: &mut Formatter) -> Result {\n-            Display::fmt(self, fmt)\n+            float_to_str_common(self, fmt.precision, |absolute| {\n+                // is_positive() counts -0.0 as negative\n+                fmt.pad_integral(self.is_nan() || self.is_positive(), \"\", absolute)\n+            })\n         }\n     }\n \n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     impl Display for $ty {\n         fn fmt(&self, fmt: &mut Formatter) -> Result {\n-            use num::Float;\n-\n-            let digits = match fmt.precision {\n-                Some(i) => float::DigExact(i),\n-                None => float::DigMax(6),\n-            };\n-            float::float_to_str_bytes_common(self.abs(),\n-                                             10,\n-                                             true,\n-                                             float::SignNeg,\n-                                             digits,\n-                                             float::ExpNone,\n-                                             false,\n-                                             |bytes| {\n-                fmt.pad_integral(self.is_nan() || *self >= 0.0, \"\", bytes)\n+            float_to_str_common(self, fmt.precision, |absolute| {\n+                // simple comparison counts -0.0 as positive\n+                fmt.pad_integral(self.is_nan() || *self >= 0.0, \"\", absolute)\n             })\n         }\n     }\n@@ -951,9 +957,6 @@ macro_rules! floating { ($ty:ident) => {\n                 None => float::DigMax(6),\n             };\n             float::float_to_str_bytes_common(self.abs(),\n-                                             10,\n-                                             true,\n-                                             float::SignNeg,\n                                              digits,\n                                              float::ExpDec,\n                                              false,\n@@ -973,9 +976,6 @@ macro_rules! floating { ($ty:ident) => {\n                 None => float::DigMax(6),\n             };\n             float::float_to_str_bytes_common(self.abs(),\n-                                             10,\n-                                             true,\n-                                             float::SignNeg,\n                                              digits,\n                                              float::ExpDec,\n                                              true,"}, {"sha": "8ed89adec5b69385d208b821dcd39cfb67530497", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=16e1fcead14628701e1b10b9d00c898d748db2ed", "patch": "@@ -139,16 +139,16 @@ extern \"rust-intrinsic\" {\n     pub fn atomic_fence_rel();\n     pub fn atomic_fence_acqrel();\n \n-    /// Abort the execution of the process.\n+    /// Aborts the execution of the process.\n     pub fn abort() -> !;\n \n-    /// Tell LLVM that this point in the code is not reachable,\n+    /// Tells LLVM that this point in the code is not reachable,\n     /// enabling further optimizations.\n     ///\n     /// NB: This is very different from the `unreachable!()` macro!\n     pub fn unreachable() -> !;\n \n-    /// Inform the optimizer that a condition is always true.\n+    /// Informs the optimizer that a condition is always true.\n     /// If the condition is false, the behavior is undefined.\n     ///\n     /// No code is generated for this intrinsic, but the optimizer will try\n@@ -158,7 +158,7 @@ extern \"rust-intrinsic\" {\n     /// own, or if it does not enable any significant optimizations.\n     pub fn assume(b: bool);\n \n-    /// Execute a breakpoint trap, for inspection by a debugger.\n+    /// Executes a breakpoint trap, for inspection by a debugger.\n     pub fn breakpoint();\n \n     /// The size of a type in bytes.\n@@ -170,7 +170,7 @@ extern \"rust-intrinsic\" {\n     /// elements.\n     pub fn size_of<T>() -> usize;\n \n-    /// Move a value to an uninitialized memory location.\n+    /// Moves a value to an uninitialized memory location.\n     ///\n     /// Drop glue is not run on the destination.\n     pub fn move_val_init<T>(dst: &mut T, src: T);\n@@ -186,7 +186,7 @@ extern \"rust-intrinsic\" {\n     /// crate it is invoked in.\n     pub fn type_id<T: ?Sized + 'static>() -> u64;\n \n-    /// Create a value initialized to so that its drop flag,\n+    /// Creates a value initialized to so that its drop flag,\n     /// if any, says that it has been dropped.\n     ///\n     /// `init_dropped` is unsafe because it returns a datum with all\n@@ -199,15 +199,15 @@ extern \"rust-intrinsic\" {\n     /// intrinsic).\n     pub fn init_dropped<T>() -> T;\n \n-    /// Create a value initialized to zero.\n+    /// Creates a value initialized to zero.\n     ///\n     /// `init` is unsafe because it returns a zeroed-out datum,\n     /// which is unsafe unless T is `Copy`.  Also, even if T is\n     /// `Copy`, an all-zero value may not correspond to any legitimate\n     /// state for the type in question.\n     pub fn init<T>() -> T;\n \n-    /// Create an uninitialized value.\n+    /// Creates an uninitialized value.\n     ///\n     /// `uninit` is unsafe because there is no guarantee of what its\n     /// contents are. In particular its drop-flag may be set to any\n@@ -216,7 +216,7 @@ extern \"rust-intrinsic\" {\n     /// initialize memory previous set to the result of `uninit`.\n     pub fn uninit<T>() -> T;\n \n-    /// Move a value out of scope without running drop glue.\n+    /// Moves a value out of scope without running drop glue.\n     ///\n     /// `forget` is unsafe because the caller is responsible for\n     /// ensuring the argument is deallocated already."}, {"sha": "4a0706906ee9c77a6256674a5d61a4c97b190ced", "filename": "src/libcore/iter.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=16e1fcead14628701e1b10b9d00c898d748db2ed", "patch": "@@ -91,7 +91,7 @@ pub trait Iterator {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     type Item;\n \n-    /// Advance the iterator and return the next value. Return `None` when the\n+    /// Advances the iterator and returns the next value. Returns `None` when the\n     /// end is reached.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn next(&mut self) -> Option<Self::Item>;\n@@ -670,7 +670,7 @@ pub trait Iterator {\n         None\n     }\n \n-    /// Return the index of the first element satisfying the specified predicate\n+    /// Returns the index of the first element satisfying the specified predicate\n     ///\n     /// Does not consume the iterator past the first found element.\n     ///\n@@ -698,7 +698,7 @@ pub trait Iterator {\n         None\n     }\n \n-    /// Return the index of the last element satisfying the specified predicate\n+    /// Returns the index of the last element satisfying the specified predicate\n     ///\n     /// If no element matches, None is returned.\n     ///\n@@ -853,7 +853,7 @@ pub trait Iterator {\n         MinMax(min, max)\n     }\n \n-    /// Return the element that gives the maximum value from the\n+    /// Returns the element that gives the maximum value from the\n     /// specified function.\n     ///\n     /// Returns the rightmost element if the comparison determines two elements\n@@ -882,7 +882,7 @@ pub trait Iterator {\n             .map(|(_, x)| x)\n     }\n \n-    /// Return the element that gives the minimum value from the\n+    /// Returns the element that gives the minimum value from the\n     /// specified function.\n     ///\n     /// Returns the leftmost element if the comparison determines two elements\n@@ -1099,7 +1099,7 @@ impl<'a, I: Iterator + ?Sized> Iterator for &'a mut I {\n #[rustc_on_unimplemented=\"a collection of type `{Self}` cannot be \\\n                           built from an iterator over elements of type `{A}`\"]\n pub trait FromIterator<A> {\n-    /// Build a container with elements from something iterable.\n+    /// Builds a container with elements from something iterable.\n     ///\n     /// # Examples\n     ///\n@@ -1158,7 +1158,7 @@ impl<I: Iterator> IntoIterator for I {\n /// A type growable from an `Iterator` implementation\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait Extend<A> {\n-    /// Extend a container with the elements yielded by an arbitrary iterator\n+    /// Extends a container with the elements yielded by an arbitrary iterator\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn extend<T: IntoIterator<Item=A>>(&mut self, iterable: T);\n }\n@@ -1170,7 +1170,7 @@ pub trait Extend<A> {\n /// independently of each other.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait DoubleEndedIterator: Iterator {\n-    /// Yield an element from the end of the range, returning `None` if the\n+    /// Yields an element from the end of the range, returning `None` if the\n     /// range is empty.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn next_back(&mut self) -> Option<Self::Item>;\n@@ -1191,11 +1191,11 @@ impl<'a, I: DoubleEndedIterator + ?Sized> DoubleEndedIterator for &'a mut I {\n            reason = \"not widely used, may be better decomposed into Index \\\n                      and ExactSizeIterator\")]\n pub trait RandomAccessIterator: Iterator {\n-    /// Return the number of indexable elements. At most `std::usize::MAX`\n+    /// Returns the number of indexable elements. At most `std::usize::MAX`\n     /// elements are indexable, even if the iterator represents a longer range.\n     fn indexable(&self) -> usize;\n \n-    /// Return an element at an index, or `None` if the index is out of bounds\n+    /// Returns an element at an index, or `None` if the index is out of bounds\n     fn idx(&mut self, index: usize) -> Option<Self::Item>;\n }\n \n@@ -1210,7 +1210,7 @@ pub trait RandomAccessIterator: Iterator {\n pub trait ExactSizeIterator: Iterator {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    /// Return the exact length of the iterator.\n+    /// Returns the exact length of the iterator.\n     fn len(&self) -> usize {\n         let (lower, upper) = self.size_hint();\n         // Note: This assertion is overly defensive, but it checks the invariant\n@@ -1856,7 +1856,7 @@ impl<I: ExactSizeIterator> ExactSizeIterator for Peekable<I> {}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<I: Iterator> Peekable<I> {\n-    /// Return a reference to the next element of the iterator with out\n+    /// Returns a reference to the next element of the iterator with out\n     /// advancing it, or None if the iterator is exhausted.\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1870,7 +1870,7 @@ impl<I: Iterator> Peekable<I> {\n         }\n     }\n \n-    /// Check whether peekable iterator is empty or not.\n+    /// Checks whether peekable iterator is empty or not.\n     #[inline]\n     pub fn is_empty(&mut self) -> bool {\n         self.peek().is_none()\n@@ -2401,12 +2401,12 @@ pub trait Step: PartialOrd {\n     /// Steps `self` if possible.\n     fn step(&self, by: &Self) -> Option<Self>;\n \n-    /// The number of steps between two step objects.\n+    /// Returns the number of steps between two step objects.\n     ///\n     /// `start` should always be less than `end`, so the result should never\n     /// be negative.\n     ///\n-    /// Return `None` if it is not possible to calculate steps_between\n+    /// Returns `None` if it is not possible to calculate steps_between\n     /// without overflow.\n     fn steps_between(start: &Self, end: &Self, by: &Self) -> Option<usize>;\n }\n@@ -2549,7 +2549,7 @@ pub struct RangeInclusive<A> {\n     done: bool,\n }\n \n-/// Return an iterator over the range [start, stop]\n+/// Returns an iterator over the range [start, stop].\n #[inline]\n #[unstable(feature = \"core\",\n            reason = \"likely to be replaced by range notation and adapters\")]\n@@ -2657,7 +2657,7 @@ pub struct RangeStepInclusive<A> {\n     done: bool,\n }\n \n-/// Return an iterator over the range [start, stop] by `step`.\n+/// Returns an iterator over the range [start, stop] by `step`.\n ///\n /// It handles overflow by stopping.\n ///\n@@ -2827,7 +2827,7 @@ type IterateState<T, F> = (F, Option<T>, bool);\n #[unstable(feature = \"core\")]\n pub type Iterate<T, F> = Unfold<IterateState<T, F>, fn(&mut IterateState<T, F>) -> Option<T>>;\n \n-/// Create a new iterator that produces an infinite sequence of\n+/// Creates a new iterator that produces an infinite sequence of\n /// repeated applications of the given function `f`.\n #[unstable(feature = \"core\")]\n pub fn iterate<T, F>(seed: T, f: F) -> Iterate<T, F> where\n@@ -2853,7 +2853,7 @@ pub fn iterate<T, F>(seed: T, f: F) -> Iterate<T, F> where\n     Unfold::new((f, Some(seed), true), next)\n }\n \n-/// Create a new iterator that endlessly repeats the element `elt`.\n+/// Creates a new iterator that endlessly repeats the element `elt`.\n #[inline]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn repeat<T: Clone>(elt: T) -> Repeat<T> {\n@@ -2940,7 +2940,7 @@ pub mod order {\n         }\n     }\n \n-    /// Compare `a` and `b` for nonequality (Using partial equality, `PartialEq`)\n+    /// Compares `a` and `b` for nonequality (Using partial equality, `PartialEq`)\n     pub fn ne<L: Iterator, R: Iterator>(mut a: L, mut b: R) -> bool where\n         L::Item: PartialEq<R::Item>,\n     {\n@@ -2953,7 +2953,7 @@ pub mod order {\n         }\n     }\n \n-    /// Return `a` < `b` lexicographically (Using partial order, `PartialOrd`)\n+    /// Returns `a` < `b` lexicographically (Using partial order, `PartialOrd`)\n     pub fn lt<R: Iterator, L: Iterator>(mut a: L, mut b: R) -> bool where\n         L::Item: PartialOrd<R::Item>,\n     {\n@@ -2967,7 +2967,7 @@ pub mod order {\n         }\n     }\n \n-    /// Return `a` <= `b` lexicographically (Using partial order, `PartialOrd`)\n+    /// Returns `a` <= `b` lexicographically (Using partial order, `PartialOrd`)\n     pub fn le<L: Iterator, R: Iterator>(mut a: L, mut b: R) -> bool where\n         L::Item: PartialOrd<R::Item>,\n     {\n@@ -2981,7 +2981,7 @@ pub mod order {\n         }\n     }\n \n-    /// Return `a` > `b` lexicographically (Using partial order, `PartialOrd`)\n+    /// Returns `a` > `b` lexicographically (Using partial order, `PartialOrd`)\n     pub fn gt<L: Iterator, R: Iterator>(mut a: L, mut b: R) -> bool where\n         L::Item: PartialOrd<R::Item>,\n     {\n@@ -2995,7 +2995,7 @@ pub mod order {\n         }\n     }\n \n-    /// Return `a` >= `b` lexicographically (Using partial order, `PartialOrd`)\n+    /// Returns `a` >= `b` lexicographically (Using partial order, `PartialOrd`)\n     pub fn ge<L: Iterator, R: Iterator>(mut a: L, mut b: R) -> bool where\n         L::Item: PartialOrd<R::Item>,\n     {"}, {"sha": "c4128e79765c8157a8f738b2eb090b7a0d463c1f", "filename": "src/libcore/mem.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibcore%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibcore%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem.rs?ref=16e1fcead14628701e1b10b9d00c898d748db2ed", "patch": "@@ -134,7 +134,7 @@ pub fn align_of_val<T>(_val: &T) -> usize {\n     align_of::<T>()\n }\n \n-/// Create a value initialized to zero.\n+/// Creates a value initialized to zero.\n ///\n /// This function is similar to allocating space for a local variable and zeroing it out (an unsafe\n /// operation).\n@@ -158,7 +158,7 @@ pub unsafe fn zeroed<T>() -> T {\n     intrinsics::init()\n }\n \n-/// Create a value initialized to an unspecified series of bytes.\n+/// Creates a value initialized to an unspecified series of bytes.\n ///\n /// The byte sequence usually indicates that the value at the memory\n /// in question has been dropped. Thus, *if* T carries a drop flag,\n@@ -179,7 +179,7 @@ pub unsafe fn dropped<T>() -> T {\n     dropped_impl()\n }\n \n-/// Create an uninitialized value.\n+/// Creates an uninitialized value.\n ///\n /// Care must be taken when using this function, if the type `T` has a destructor and the value\n /// falls out of scope (due to unwinding or returning) before being initialized, then the\n@@ -234,7 +234,7 @@ pub fn swap<T>(x: &mut T, y: &mut T) {\n     }\n }\n \n-/// Replace the value at a mutable location with a new one, returning the old value, without\n+/// Replaces the value at a mutable location with a new one, returning the old value, without\n /// deinitialising or copying either one.\n ///\n /// This is primarily used for transferring and swapping ownership of a value in a mutable"}, {"sha": "db2d1b2f1fdaa7a686221fe803595a32d4812871", "filename": "src/libcore/nonzero.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibcore%2Fnonzero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibcore%2Fnonzero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnonzero.rs?ref=16e1fcead14628701e1b10b9d00c898d748db2ed", "patch": "@@ -38,7 +38,7 @@ unsafe impl Zeroable for u64 {}\n pub struct NonZero<T: Zeroable>(T);\n \n impl<T: Zeroable> NonZero<T> {\n-    /// Create an instance of NonZero with the provided value.\n+    /// Creates an instance of NonZero with the provided value.\n     /// You must indeed ensure that the value is actually \"non-zero\".\n     #[inline(always)]\n     pub unsafe fn new(inner: T) -> NonZero<T> {"}, {"sha": "9b1a384a0d06a90865556f930a15ffbe7fa721ec", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 43, "deletions": 43, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=16e1fcead14628701e1b10b9d00c898d748db2ed", "patch": "@@ -268,7 +268,7 @@ pub trait Int\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn swap_bytes(self) -> Self;\n \n-    /// Convert an integer from big endian to the target's endianness.\n+    /// Converts an integer from big endian to the target's endianness.\n     ///\n     /// On big endian this is a no-op. On little endian the bytes are swapped.\n     ///\n@@ -291,7 +291,7 @@ pub trait Int\n         if cfg!(target_endian = \"big\") { x } else { x.swap_bytes() }\n     }\n \n-    /// Convert an integer from little endian to the target's endianness.\n+    /// Converts an integer from little endian to the target's endianness.\n     ///\n     /// On little endian this is a no-op. On big endian the bytes are swapped.\n     ///\n@@ -314,7 +314,7 @@ pub trait Int\n         if cfg!(target_endian = \"little\") { x } else { x.swap_bytes() }\n     }\n \n-    /// Convert `self` to big endian from the target's endianness.\n+    /// Converts `self` to big endian from the target's endianness.\n     ///\n     /// On big endian this is a no-op. On little endian the bytes are swapped.\n     ///\n@@ -337,7 +337,7 @@ pub trait Int\n         if cfg!(target_endian = \"big\") { self } else { self.swap_bytes() }\n     }\n \n-    /// Convert `self` to little endian from the target's endianness.\n+    /// Converts `self` to little endian from the target's endianness.\n     ///\n     /// On little endian this is a no-op. On big endian the bytes are swapped.\n     ///\n@@ -845,7 +845,7 @@ macro_rules! int_impl {\n             let min: $T = Int::min_value(); !min\n         }\n \n-        /// Convert a string slice in a given base to an integer.\n+        /// Converts a string slice in a given base to an integer.\n         ///\n         /// Leading and trailing whitespace represent an error.\n         ///\n@@ -995,7 +995,7 @@ macro_rules! int_impl {\n             (self as $UnsignedT).swap_bytes() as $T\n         }\n \n-        /// Convert an integer from big endian to the target's endianness.\n+        /// Converts an integer from big endian to the target's endianness.\n         ///\n         /// On big endian this is a no-op. On little endian the bytes are\n         /// swapped.\n@@ -1019,7 +1019,7 @@ macro_rules! int_impl {\n             if cfg!(target_endian = \"big\") { x } else { x.swap_bytes() }\n         }\n \n-        /// Convert an integer from little endian to the target's endianness.\n+        /// Converts an integer from little endian to the target's endianness.\n         ///\n         /// On little endian this is a no-op. On big endian the bytes are\n         /// swapped.\n@@ -1043,7 +1043,7 @@ macro_rules! int_impl {\n             if cfg!(target_endian = \"little\") { x } else { x.swap_bytes() }\n         }\n \n-        /// Convert `self` to big endian from the target's endianness.\n+        /// Converts `self` to big endian from the target's endianness.\n         ///\n         /// On big endian this is a no-op. On little endian the bytes are\n         /// swapped.\n@@ -1067,7 +1067,7 @@ macro_rules! int_impl {\n             if cfg!(target_endian = \"big\") { self } else { self.swap_bytes() }\n         }\n \n-        /// Convert `self` to little endian from the target's endianness.\n+        /// Converts `self` to little endian from the target's endianness.\n         ///\n         /// On little endian this is a no-op. On big endian the bytes are\n         /// swapped.\n@@ -1361,7 +1361,7 @@ macro_rules! uint_impl {\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         pub fn max_value() -> $T { !0 }\n \n-        /// Convert a string slice in a given base to an integer.\n+        /// Converts a string slice in a given base to an integer.\n         ///\n         /// Leading and trailing whitespace represent an error.\n         ///\n@@ -1517,7 +1517,7 @@ macro_rules! uint_impl {\n             unsafe { $bswap(self as $ActualT) as $T }\n         }\n \n-        /// Convert an integer from big endian to the target's endianness.\n+        /// Converts an integer from big endian to the target's endianness.\n         ///\n         /// On big endian this is a no-op. On little endian the bytes are\n         /// swapped.\n@@ -1541,7 +1541,7 @@ macro_rules! uint_impl {\n             if cfg!(target_endian = \"big\") { x } else { x.swap_bytes() }\n         }\n \n-        /// Convert an integer from little endian to the target's endianness.\n+        /// Converts an integer from little endian to the target's endianness.\n         ///\n         /// On little endian this is a no-op. On big endian the bytes are\n         /// swapped.\n@@ -1565,7 +1565,7 @@ macro_rules! uint_impl {\n             if cfg!(target_endian = \"little\") { x } else { x.swap_bytes() }\n         }\n \n-        /// Convert `self` to big endian from the target's endianness.\n+        /// Converts `self` to big endian from the target's endianness.\n         ///\n         /// On big endian this is a no-op. On little endian the bytes are\n         /// swapped.\n@@ -1589,7 +1589,7 @@ macro_rules! uint_impl {\n             if cfg!(target_endian = \"big\") { self } else { self.swap_bytes() }\n         }\n \n-        /// Convert `self` to little endian from the target's endianness.\n+        /// Converts `self` to little endian from the target's endianness.\n         ///\n         /// On little endian this is a no-op. On big endian the bytes are\n         /// swapped.\n@@ -2183,7 +2183,7 @@ impl_to_primitive_float! { f64 }\n /// A generic trait for converting a number to a value.\n #[unstable(feature = \"core\", reason = \"trait is likely to be removed\")]\n pub trait FromPrimitive : ::marker::Sized {\n-    /// Convert an `isize` to return an optional value of this type. If the\n+    /// Converts an `isize` to return an optional value of this type. If the\n     /// value cannot be represented by this value, the `None` is returned.\n     #[inline]\n     #[unstable(feature = \"core\")]\n@@ -2192,39 +2192,39 @@ pub trait FromPrimitive : ::marker::Sized {\n         FromPrimitive::from_i64(n as i64)\n     }\n \n-    /// Convert an `isize` to return an optional value of this type. If the\n+    /// Converts an `isize` to return an optional value of this type. If the\n     /// value cannot be represented by this value, the `None` is returned.\n     #[inline]\n     fn from_isize(n: isize) -> Option<Self> {\n         FromPrimitive::from_i64(n as i64)\n     }\n \n-    /// Convert an `i8` to return an optional value of this type. If the\n+    /// Converts an `i8` to return an optional value of this type. If the\n     /// type cannot be represented by this value, the `None` is returned.\n     #[inline]\n     fn from_i8(n: i8) -> Option<Self> {\n         FromPrimitive::from_i64(n as i64)\n     }\n \n-    /// Convert an `i16` to return an optional value of this type. If the\n+    /// Converts an `i16` to return an optional value of this type. If the\n     /// type cannot be represented by this value, the `None` is returned.\n     #[inline]\n     fn from_i16(n: i16) -> Option<Self> {\n         FromPrimitive::from_i64(n as i64)\n     }\n \n-    /// Convert an `i32` to return an optional value of this type. If the\n+    /// Converts an `i32` to return an optional value of this type. If the\n     /// type cannot be represented by this value, the `None` is returned.\n     #[inline]\n     fn from_i32(n: i32) -> Option<Self> {\n         FromPrimitive::from_i64(n as i64)\n     }\n \n-    /// Convert an `i64` to return an optional value of this type. If the\n+    /// Converts an `i64` to return an optional value of this type. If the\n     /// type cannot be represented by this value, the `None` is returned.\n     fn from_i64(n: i64) -> Option<Self>;\n \n-    /// Convert an `usize` to return an optional value of this type. If the\n+    /// Converts an `usize` to return an optional value of this type. If the\n     /// type cannot be represented by this value, the `None` is returned.\n     #[inline]\n     #[unstable(feature = \"core\")]\n@@ -2233,46 +2233,46 @@ pub trait FromPrimitive : ::marker::Sized {\n         FromPrimitive::from_u64(n as u64)\n     }\n \n-    /// Convert a `usize` to return an optional value of this type. If the\n+    /// Converts a `usize` to return an optional value of this type. If the\n     /// type cannot be represented by this value, the `None` is returned.\n     #[inline]\n     fn from_usize(n: usize) -> Option<Self> {\n         FromPrimitive::from_u64(n as u64)\n     }\n \n-    /// Convert an `u8` to return an optional value of this type. If the\n+    /// Converts an `u8` to return an optional value of this type. If the\n     /// type cannot be represented by this value, the `None` is returned.\n     #[inline]\n     fn from_u8(n: u8) -> Option<Self> {\n         FromPrimitive::from_u64(n as u64)\n     }\n \n-    /// Convert an `u16` to return an optional value of this type. If the\n+    /// Converts an `u16` to return an optional value of this type. If the\n     /// type cannot be represented by this value, the `None` is returned.\n     #[inline]\n     fn from_u16(n: u16) -> Option<Self> {\n         FromPrimitive::from_u64(n as u64)\n     }\n \n-    /// Convert an `u32` to return an optional value of this type. If the\n+    /// Converts an `u32` to return an optional value of this type. If the\n     /// type cannot be represented by this value, the `None` is returned.\n     #[inline]\n     fn from_u32(n: u32) -> Option<Self> {\n         FromPrimitive::from_u64(n as u64)\n     }\n \n-    /// Convert an `u64` to return an optional value of this type. If the\n+    /// Converts an `u64` to return an optional value of this type. If the\n     /// type cannot be represented by this value, the `None` is returned.\n     fn from_u64(n: u64) -> Option<Self>;\n \n-    /// Convert a `f32` to return an optional value of this type. If the\n+    /// Converts a `f32` to return an optional value of this type. If the\n     /// type cannot be represented by this value, the `None` is returned.\n     #[inline]\n     fn from_f32(n: f32) -> Option<Self> {\n         FromPrimitive::from_f64(n as f64)\n     }\n \n-    /// Convert a `f64` to return an optional value of this type. If the\n+    /// Converts a `f64` to return an optional value of this type. If the\n     /// type cannot be represented by this value, the `None` is returned.\n     #[inline]\n     fn from_f64(n: f64) -> Option<Self> {\n@@ -2401,7 +2401,7 @@ impl_from_primitive! { u64, to_u64 }\n impl_from_primitive! { f32, to_f32 }\n impl_from_primitive! { f64, to_f64 }\n \n-/// Cast from one machine scalar to another.\n+/// Casts from one machine scalar to another.\n ///\n /// # Examples\n ///\n@@ -2583,16 +2583,16 @@ pub trait Float\n     /// Returns the mantissa, exponent and sign as integers, respectively.\n     fn integer_decode(self) -> (u64, i16, i8);\n \n-    /// Return the largest integer less than or equal to a number.\n+    /// Returns the largest integer less than or equal to a number.\n     fn floor(self) -> Self;\n-    /// Return the smallest integer greater than or equal to a number.\n+    /// Returns the smallest integer greater than or equal to a number.\n     fn ceil(self) -> Self;\n-    /// Return the nearest integer to a number. Round half-way cases away from\n+    /// Returns the nearest integer to a number. Round half-way cases away from\n     /// `0.0`.\n     fn round(self) -> Self;\n-    /// Return the integer part of a number.\n+    /// Returns the integer part of a number.\n     fn trunc(self) -> Self;\n-    /// Return the fractional part of a number.\n+    /// Returns the fractional part of a number.\n     fn fract(self) -> Self;\n \n     /// Computes the absolute value of `self`. Returns `Float::nan()` if the\n@@ -2615,21 +2615,21 @@ pub trait Float\n     /// error. This produces a more accurate result with better performance than\n     /// a separate multiplication operation followed by an add.\n     fn mul_add(self, a: Self, b: Self) -> Self;\n-    /// Take the reciprocal (inverse) of a number, `1/x`.\n+    /// Takes the reciprocal (inverse) of a number, `1/x`.\n     fn recip(self) -> Self;\n \n-    /// Raise a number to an integer power.\n+    /// Raises a number to an integer power.\n     ///\n     /// Using this function is generally faster than using `powf`\n     fn powi(self, n: i32) -> Self;\n-    /// Raise a number to a floating point power.\n+    /// Raises a number to a floating point power.\n     fn powf(self, n: Self) -> Self;\n \n-    /// Take the square root of a number.\n+    /// Takes the square root of a number.\n     ///\n     /// Returns NaN if `self` is a negative number.\n     fn sqrt(self) -> Self;\n-    /// Take the reciprocal (inverse) square root of a number, `1/sqrt(x)`.\n+    /// Takes the reciprocal (inverse) square root of a number, `1/sqrt(x)`.\n     fn rsqrt(self) -> Self;\n \n     /// Returns `e^(self)`, (the exponential function).\n@@ -2645,9 +2645,9 @@ pub trait Float\n     /// Returns the base 10 logarithm of the number.\n     fn log10(self) -> Self;\n \n-    /// Convert radians to degrees.\n+    /// Converts radians to degrees.\n     fn to_degrees(self) -> Self;\n-    /// Convert degrees to radians.\n+    /// Converts degrees to radians.\n     fn to_radians(self) -> Self;\n }\n \n@@ -2682,7 +2682,7 @@ macro_rules! from_str_radix_float_impl {\n         impl FromStr for $T {\n             type Err = ParseFloatError;\n \n-            /// Convert a string in base 10 to a float.\n+            /// Converts a string in base 10 to a float.\n             /// Accepts an optional decimal exponent.\n             ///\n             /// This function accepts strings such as\n@@ -2719,7 +2719,7 @@ macro_rules! from_str_radix_float_impl {\n         impl FromStrRadix for $T {\n             type Err = ParseFloatError;\n \n-            /// Convert a string in a given base to a float.\n+            /// Converts a string in a given base to a float.\n             ///\n             /// Due to possible conflicts, this function does **not** accept\n             /// the special values `inf`, `-inf`, `+inf` and `NaN`, **nor**"}, {"sha": "4c784a579da6b004f83b8f6616b56046f0546181", "filename": "src/libcore/option.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=16e1fcead14628701e1b10b9d00c898d748db2ed", "patch": "@@ -223,7 +223,7 @@ impl<T> Option<T> {\n     // Adapter for working with references\n     /////////////////////////////////////////////////////////////////////////\n \n-    /// Convert from `Option<T>` to `Option<&T>`\n+    /// Converts from `Option<T>` to `Option<&T>`\n     ///\n     /// # Examples\n     ///\n@@ -248,7 +248,7 @@ impl<T> Option<T> {\n         }\n     }\n \n-    /// Convert from `Option<T>` to `Option<&mut T>`\n+    /// Converts from `Option<T>` to `Option<&mut T>`\n     ///\n     /// # Examples\n     ///\n@@ -269,7 +269,7 @@ impl<T> Option<T> {\n         }\n     }\n \n-    /// Convert from `Option<T>` to `&mut [T]` (without copying)\n+    /// Converts from `Option<T>` to `&mut [T]` (without copying)\n     ///\n     /// # Examples\n     ///\n@@ -704,7 +704,7 @@ impl<T> Option<T> {\n         mem::replace(self, None)\n     }\n \n-    /// Convert from `Option<T>` to `&[T]` (without copying)\n+    /// Converts from `Option<T>` to `&[T]` (without copying)\n     #[inline]\n     #[unstable(feature = \"as_slice\", since = \"unsure of the utility here\")]\n     pub fn as_slice<'a>(&'a self) -> &'a [T] {"}, {"sha": "9a165a2e3173bca16654a16f977cc5b7b4796da8", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=16e1fcead14628701e1b10b9d00c898d748db2ed", "patch": "@@ -544,19 +544,19 @@ unsafe impl<T: Send + ?Sized> Send for Unique<T> { }\n unsafe impl<T: Sync + ?Sized> Sync for Unique<T> { }\n \n impl<T: ?Sized> Unique<T> {\n-    /// Create a new `Unique`.\n+    /// Creates a new `Unique`.\n     #[unstable(feature = \"unique\")]\n     pub unsafe fn new(ptr: *mut T) -> Unique<T> {\n         Unique { pointer: NonZero::new(ptr), _marker: PhantomData }\n     }\n \n-    /// Dereference the content.\n+    /// Dereferences the content.\n     #[unstable(feature = \"unique\")]\n     pub unsafe fn get(&self) -> &T {\n         &**self.pointer\n     }\n \n-    /// Mutably dereference the content.\n+    /// Mutably dereferences the content.\n     #[unstable(feature = \"unique\")]\n     pub unsafe fn get_mut(&mut self) -> &mut T {\n         &mut ***self"}, {"sha": "4c74f4646ac0691cc887dc609ef46e29c3cb3fa5", "filename": "src/libcore/result.rs", "status": "modified", "additions": 61, "deletions": 79, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=16e1fcead14628701e1b10b9d00c898d748db2ed", "patch": "@@ -69,7 +69,7 @@\n //! let good_result: Result<bool, i32> = good_result.and_then(|i| Ok(i == 11));\n //!\n //! // Use `or_else` to handle the error.\n-//! let bad_result: Result<i32, i32> = bad_result.or_else(|i| Ok(11));\n+//! let bad_result: Result<i32, i32> = bad_result.or_else(|i| Ok(i + 20));\n //!\n //! // Consume the result and return the contents with `unwrap`.\n //! let final_awesome_result = good_result.unwrap();\n@@ -85,35 +85,32 @@\n //! functions that may encounter errors but don't otherwise return a\n //! useful value.\n //!\n-//! Consider the `write_line` method defined for I/O types\n-//! by the [`Writer`](../old_io/trait.Writer.html) trait:\n+//! Consider the `write_all` method defined for I/O types\n+//! by the [`Write`](../io/trait.Write.html) trait:\n //!\n //! ```\n-//! # #![feature(old_io)]\n-//! use std::old_io::IoError;\n+//! use std::io;\n //!\n //! trait Writer {\n-//!     fn write_line(&mut self, s: &str) -> Result<(), IoError>;\n+//!     fn write_all(&mut self, bytes: &[u8]) -> Result<(), io::Error>;\n //! }\n //! ```\n //!\n-//! *Note: The actual definition of `Writer` uses `IoResult`, which\n-//! is just a synonym for `Result<T, IoError>`.*\n+//! *Note: The actual definition of `Write` uses `io::Result`, which\n+//! is just a synonym for `Result<T, io::Error>`.*\n //!\n //! This method doesn't produce a value, but the write may\n //! fail. It's crucial to handle the error case, and *not* write\n //! something like this:\n //!\n-//! ```{.ignore}\n-//! # #![feature(old_io)]\n-//! use std::old_io::*;\n-//! use std::old_path::Path;\n+//! ```no_run\n+//! use std::fs::File;\n+//! use std::io::prelude::*;\n //!\n-//! let mut file = File::open_mode(&Path::new(\"valuable_data.txt\"), Open, Write);\n-//! // If `write_line` errors, then we'll never know, because the return\n+//! let mut file = File::create(\"valuable_data.txt\").unwrap();\n+//! // If `write_all` errors, then we'll never know, because the return\n //! // value is ignored.\n-//! file.write_line(\"important message\");\n-//! drop(file);\n+//! file.write_all(b\"important message\");\n //! ```\n //!\n //! If you *do* write that in Rust, the compiler will give you a\n@@ -125,37 +122,31 @@\n //! a marginally useful message indicating why:\n //!\n //! ```{.no_run}\n-//! # #![feature(old_io, old_path)]\n-//! use std::old_io::*;\n-//! use std::old_path::Path;\n+//! use std::fs::File;\n+//! use std::io::prelude::*;\n //!\n-//! let mut file = File::open_mode(&Path::new(\"valuable_data.txt\"), Open, Write);\n-//! file.write_line(\"important message\").ok().expect(\"failed to write message\");\n-//! drop(file);\n+//! let mut file = File::create(\"valuable_data.txt\").unwrap();\n+//! file.write_all(b\"important message\").ok().expect(\"failed to write message\");\n //! ```\n //!\n //! You might also simply assert success:\n //!\n //! ```{.no_run}\n-//! # #![feature(old_io, old_path)]\n-//! # use std::old_io::*;\n-//! # use std::old_path::Path;\n-//!\n-//! # let mut file = File::open_mode(&Path::new(\"valuable_data.txt\"), Open, Write);\n-//! assert!(file.write_line(\"important message\").is_ok());\n-//! # drop(file);\n+//! # use std::fs::File;\n+//! # use std::io::prelude::*;\n+//! # let mut file = File::create(\"valuable_data.txt\").unwrap();\n+//! assert!(file.write_all(b\"important message\").is_ok());\n //! ```\n //!\n //! Or propagate the error up the call stack with `try!`:\n //!\n //! ```\n-//! # #![feature(old_io, old_path)]\n-//! # use std::old_io::*;\n-//! # use std::old_path::Path;\n-//! fn write_message() -> Result<(), IoError> {\n-//!     let mut file = File::open_mode(&Path::new(\"valuable_data.txt\"), Open, Write);\n-//!     try!(file.write_line(\"important message\"));\n-//!     drop(file);\n+//! # use std::fs::File;\n+//! # use std::io::prelude::*;\n+//! # use std::io;\n+//! fn write_message() -> io::Result<()> {\n+//!     let mut file = try!(File::create(\"valuable_data.txt\"));\n+//!     try!(file.write_all(b\"important message\"));\n //!     Ok(())\n //! }\n //! ```\n@@ -170,48 +161,51 @@\n //! It replaces this:\n //!\n //! ```\n-//! # #![feature(old_io, old_path)]\n-//! use std::old_io::*;\n-//! use std::old_path::Path;\n+//! use std::fs::File;\n+//! use std::io::prelude::*;\n+//! use std::io;\n //!\n //! struct Info {\n //!     name: String,\n //!     age: i32,\n //!     rating: i32,\n //! }\n //!\n-//! fn write_info(info: &Info) -> Result<(), IoError> {\n-//!     let mut file = File::open_mode(&Path::new(\"my_best_friends.txt\"), Open, Write);\n+//! fn write_info(info: &Info) -> io::Result<()> {\n+//!     let mut file = try!(File::create(\"my_best_friends.txt\"));\n //!     // Early return on error\n-//!     if let Err(e) = file.write_line(&format!(\"name: {}\", info.name)) {\n+//!     if let Err(e) = file.write_all(format!(\"name: {}\\n\", info.name).as_bytes()) {\n+//!         return Err(e)\n+//!     }\n+//!     if let Err(e) = file.write_all(format!(\"age: {}\\n\", info.age).as_bytes()) {\n //!         return Err(e)\n //!     }\n-//!     if let Err(e) = file.write_line(&format!(\"age: {}\", info.age)) {\n+//!     if let Err(e) = file.write_all(format!(\"rating: {}\\n\", info.rating).as_bytes()) {\n //!         return Err(e)\n //!     }\n-//!     file.write_line(&format!(\"rating: {}\", info.rating))\n+//!     Ok(())\n //! }\n //! ```\n //!\n //! With this:\n //!\n //! ```\n-//! # #![feature(old_io, old_path)]\n-//! use std::old_io::*;\n-//! use std::old_path::Path;\n+//! use std::fs::File;\n+//! use std::io::prelude::*;\n+//! use std::io;\n //!\n //! struct Info {\n //!     name: String,\n //!     age: i32,\n //!     rating: i32,\n //! }\n //!\n-//! fn write_info(info: &Info) -> Result<(), IoError> {\n-//!     let mut file = File::open_mode(&Path::new(\"my_best_friends.txt\"), Open, Write);\n+//! fn write_info(info: &Info) -> io::Result<()> {\n+//!     let mut file = try!(File::create(\"my_best_friends.txt\"));\n //!     // Early return on error\n-//!     try!(file.write_line(&format!(\"name: {}\", info.name)));\n-//!     try!(file.write_line(&format!(\"age: {}\", info.age)));\n-//!     try!(file.write_line(&format!(\"rating: {}\", info.rating)));\n+//!     try!(file.write_all(format!(\"name: {}\\n\", info.name).as_bytes()));\n+//!     try!(file.write_all(format!(\"age: {}\\n\", info.age).as_bytes()));\n+//!     try!(file.write_all(format!(\"rating: {}\\n\", info.rating).as_bytes()));\n //!     Ok(())\n //! }\n //! ```\n@@ -311,7 +305,7 @@ impl<T, E> Result<T, E> {\n     // Adapter for each variant\n     /////////////////////////////////////////////////////////////////////////\n \n-    /// Convert from `Result<T, E>` to `Option<T>`\n+    /// Converts from `Result<T, E>` to `Option<T>`\n     ///\n     /// Converts `self` into an `Option<T>`, consuming `self`,\n     /// and discarding the error, if any.\n@@ -334,7 +328,7 @@ impl<T, E> Result<T, E> {\n         }\n     }\n \n-    /// Convert from `Result<T, E>` to `Option<E>`\n+    /// Converts from `Result<T, E>` to `Option<E>`\n     ///\n     /// Converts `self` into an `Option<E>`, consuming `self`,\n     /// and discarding the success value, if any.\n@@ -361,7 +355,7 @@ impl<T, E> Result<T, E> {\n     // Adapter for working with references\n     /////////////////////////////////////////////////////////////////////////\n \n-    /// Convert from `Result<T, E>` to `Result<&T, &E>`\n+    /// Converts from `Result<T, E>` to `Result<&T, &E>`\n     ///\n     /// Produces a new `Result`, containing a reference\n     /// into the original, leaving the original in place.\n@@ -382,7 +376,7 @@ impl<T, E> Result<T, E> {\n         }\n     }\n \n-    /// Convert from `Result<T, E>` to `Result<&mut T, &mut E>`\n+    /// Converts from `Result<T, E>` to `Result<&mut T, &mut E>`\n     ///\n     /// ```\n     /// fn mutate(r: &mut Result<i32, i32>) {\n@@ -409,7 +403,7 @@ impl<T, E> Result<T, E> {\n         }\n     }\n \n-    /// Convert from `Result<T, E>` to `&[T]` (without copying)\n+    /// Converts from `Result<T, E>` to `&[T]` (without copying)\n     #[inline]\n     #[unstable(feature = \"as_slice\", since = \"unsure of the utility here\")]\n     pub fn as_slice(&self) -> &[T] {\n@@ -423,7 +417,7 @@ impl<T, E> Result<T, E> {\n         }\n     }\n \n-    /// Convert from `Result<T, E>` to `&mut [T]` (without copying)\n+    /// Converts from `Result<T, E>` to `&mut [T]` (without copying)\n     ///\n     /// ```\n     /// # #![feature(core)]\n@@ -464,29 +458,17 @@ impl<T, E> Result<T, E> {\n     ///\n     /// # Examples\n     ///\n-    /// Sum the lines of a buffer by mapping strings to numbers,\n-    /// ignoring I/O and parse errors:\n+    /// Print the numbers on each line of a string multiplied by two.\n     ///\n     /// ```\n-    /// # #![feature(old_io)]\n-    /// use std::old_io::*;\n+    /// let line = \"1\\n2\\n3\\n4\\n\";\n     ///\n-    /// let mut buffer: &[u8] = b\"1\\n2\\n3\\n4\\n\";\n-    /// let mut buffer = &mut buffer;\n-    ///\n-    /// let mut sum = 0;\n-    ///\n-    /// while !buffer.is_empty() {\n-    ///     let line: IoResult<String> = buffer.read_line();\n-    ///     // Convert the string line to a number using `map` and `from_str`\n-    ///     let val: IoResult<i32> = line.map(|line| {\n-    ///         line.trim_right().parse::<i32>().unwrap_or(0)\n-    ///     });\n-    ///     // Add the value if there were no errors, otherwise add 0\n-    ///     sum += val.unwrap_or(0);\n+    /// for num in line.lines() {\n+    ///     match num.parse::<i32>().map(|i| i * 2) {\n+    ///         Ok(n) => println!(\"{}\", n),\n+    ///         Err(..) => {}\n+    ///     }\n     /// }\n-    ///\n-    /// assert!(sum == 10);\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -811,7 +793,7 @@ impl<T: fmt::Debug, E> Result<T, E> {\n              reason = \"use inherent method instead\")]\n #[allow(deprecated)]\n impl<T, E> AsSlice<T> for Result<T, E> {\n-    /// Convert from `Result<T, E>` to `&[T]` (without copying)\n+    /// Converts from `Result<T, E>` to `&[T]` (without copying)\n     #[inline]\n     fn as_slice<'a>(&'a self) -> &'a [T] {\n         match *self {\n@@ -974,7 +956,7 @@ impl<A, E, V: FromIterator<A>> FromIterator<Result<A, E>> for Result<V, E> {\n // FromIterator\n /////////////////////////////////////////////////////////////////////////////\n \n-/// Perform a fold operation over the result values from an iterator.\n+/// Performs a fold operation over the result values from an iterator.\n ///\n /// If an `Err` is encountered, it is immediately returned.\n /// Otherwise, the folded value is returned."}, {"sha": "fc623f21167c798c95a94cc4ca6e8316f9ca3799", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 17, "deletions": 22, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=16e1fcead14628701e1b10b9d00c898d748db2ed", "patch": "@@ -106,19 +106,19 @@ Section: Creating a string\n \n /// Errors which can occur when attempting to interpret a byte slice as a `str`.\n #[derive(Copy, Eq, PartialEq, Clone, Debug)]\n-#[unstable(feature = \"core\",\n-           reason = \"error enumeration recently added and definitions may be refined\")]\n-pub enum Utf8Error {\n-    /// An invalid byte was detected at the byte offset given.\n-    ///\n-    /// The offset is guaranteed to be in bounds of the slice in question, and\n-    /// the byte at the specified offset was the first invalid byte in the\n-    /// sequence detected.\n-    InvalidByte(usize),\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub struct Utf8Error {\n+    valid_up_to: usize,\n+}\n \n-    /// The byte slice was invalid because more bytes were needed but no more\n-    /// bytes were available.\n-    TooShort,\n+impl Utf8Error {\n+    /// Returns the index in the given string up to which valid UTF-8 was\n+    /// verified.\n+    ///\n+    /// Starting at the index provided, but not necessarily at it precisely, an\n+    /// invalid UTF-8 encoding sequence was found.\n+    #[unstable(feature = \"utf8_error\", reason = \"method just added\")]\n+    pub fn valid_up_to(&self) -> usize { self.valid_up_to }\n }\n \n /// Converts a slice of bytes to a string slice without performing any\n@@ -147,14 +147,7 @@ pub unsafe fn from_utf8_unchecked<'a>(v: &'a [u8]) -> &'a str {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl fmt::Display for Utf8Error {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        match *self {\n-            Utf8Error::InvalidByte(n) => {\n-                write!(f, \"invalid utf-8: invalid byte at index {}\", n)\n-            }\n-            Utf8Error::TooShort => {\n-                write!(f, \"invalid utf-8: byte slice too short\")\n-            }\n-        }\n+        write!(f, \"invalid utf-8: invalid byte near index {}\", self.valid_up_to)\n     }\n }\n \n@@ -1218,14 +1211,16 @@ fn run_utf8_validation_iterator(iter: &mut slice::Iter<u8>)\n         // restore the iterator we had at the start of this codepoint.\n         macro_rules! err { () => {{\n             *iter = old.clone();\n-            return Err(Utf8Error::InvalidByte(whole.len() - iter.as_slice().len()))\n+            return Err(Utf8Error {\n+                valid_up_to: whole.len() - iter.as_slice().len()\n+            })\n         }}}\n \n         macro_rules! next { () => {\n             match iter.next() {\n                 Some(a) => *a,\n                 // we needed data, but there was none: error!\n-                None => return Err(Utf8Error::TooShort),\n+                None => err!(),\n             }\n         }}\n "}, {"sha": "62b693dcbe6ae06f093993622188ec7202a76ab3", "filename": "src/libcore/str/pattern.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibcore%2Fstr%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibcore%2Fstr%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fpattern.rs?ref=16e1fcead14628701e1b10b9d00c898d748db2ed", "patch": "@@ -32,17 +32,17 @@ pub trait Pattern<'a>: Sized {\n     /// Associated searcher for this pattern\n     type Searcher: Searcher<'a>;\n \n-    /// Construct the associated searcher from\n+    /// Constructs the associated searcher from\n     /// `self` and the `haystack` to search in.\n     fn into_searcher(self, haystack: &'a str) -> Self::Searcher;\n \n-    /// Check whether the pattern matches anywhere in the haystack\n+    /// Checks whether the pattern matches anywhere in the haystack\n     #[inline]\n     fn is_contained_in(self, haystack: &'a str) -> bool {\n         self.into_searcher(haystack).next_match().is_some()\n     }\n \n-    /// Check whether the pattern matches at the front of the haystack\n+    /// Checks whether the pattern matches at the front of the haystack\n     #[inline]\n     fn is_prefix_of(self, haystack: &'a str) -> bool {\n         match self.into_searcher(haystack).next() {\n@@ -51,7 +51,7 @@ pub trait Pattern<'a>: Sized {\n         }\n     }\n \n-    /// Check whether the pattern matches at the back of the haystack\n+    /// Checks whether the pattern matches at the back of the haystack\n     #[inline]\n     fn is_suffix_of(self, haystack: &'a str) -> bool\n         where Self::Searcher: ReverseSearcher<'a>"}, {"sha": "cab2175f897819a80566347fe9eee68c5dc6d413", "filename": "src/libcoretest/fmt/num.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibcoretest%2Ffmt%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibcoretest%2Ffmt%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Ffmt%2Fnum.rs?ref=16e1fcead14628701e1b10b9d00c898d748db2ed", "patch": "@@ -169,85 +169,85 @@ fn test_radix_base_too_large() {\n mod u32 {\n     use test::Bencher;\n     use core::fmt::radix;\n-    use std::rand::{weak_rng, Rng};\n+    use std::__rand::{thread_rng, Rng};\n     use std::io::{Write, sink};\n \n     #[bench]\n     fn format_bin(b: &mut Bencher) {\n-        let mut rng = weak_rng();\n+        let mut rng = thread_rng();\n         b.iter(|| { write!(&mut sink(), \"{:b}\", rng.gen::<u32>()) })\n     }\n \n     #[bench]\n     fn format_oct(b: &mut Bencher) {\n-        let mut rng = weak_rng();\n+        let mut rng = thread_rng();\n         b.iter(|| { write!(&mut sink(), \"{:o}\", rng.gen::<u32>()) })\n     }\n \n     #[bench]\n     fn format_dec(b: &mut Bencher) {\n-        let mut rng = weak_rng();\n+        let mut rng = thread_rng();\n         b.iter(|| { write!(&mut sink(), \"{}\", rng.gen::<u32>()) })\n     }\n \n     #[bench]\n     fn format_hex(b: &mut Bencher) {\n-        let mut rng = weak_rng();\n+        let mut rng = thread_rng();\n         b.iter(|| { write!(&mut sink(), \"{:x}\", rng.gen::<u32>()) })\n     }\n \n     #[bench]\n     fn format_show(b: &mut Bencher) {\n-        let mut rng = weak_rng();\n+        let mut rng = thread_rng();\n         b.iter(|| { write!(&mut sink(), \"{:?}\", rng.gen::<u32>()) })\n     }\n \n     #[bench]\n     fn format_base_36(b: &mut Bencher) {\n-        let mut rng = weak_rng();\n+        let mut rng = thread_rng();\n         b.iter(|| { write!(&mut sink(), \"{}\", radix(rng.gen::<u32>(), 36)) })\n     }\n }\n \n mod i32 {\n     use test::Bencher;\n     use core::fmt::radix;\n-    use std::rand::{weak_rng, Rng};\n+    use std::__rand::{thread_rng, Rng};\n     use std::io::{Write, sink};\n \n     #[bench]\n     fn format_bin(b: &mut Bencher) {\n-        let mut rng = weak_rng();\n+        let mut rng = thread_rng();\n         b.iter(|| { write!(&mut sink(), \"{:b}\", rng.gen::<i32>()) })\n     }\n \n     #[bench]\n     fn format_oct(b: &mut Bencher) {\n-        let mut rng = weak_rng();\n+        let mut rng = thread_rng();\n         b.iter(|| { write!(&mut sink(), \"{:o}\", rng.gen::<i32>()) })\n     }\n \n     #[bench]\n     fn format_dec(b: &mut Bencher) {\n-        let mut rng = weak_rng();\n+        let mut rng = thread_rng();\n         b.iter(|| { write!(&mut sink(), \"{}\", rng.gen::<i32>()) })\n     }\n \n     #[bench]\n     fn format_hex(b: &mut Bencher) {\n-        let mut rng = weak_rng();\n+        let mut rng = thread_rng();\n         b.iter(|| { write!(&mut sink(), \"{:x}\", rng.gen::<i32>()) })\n     }\n \n     #[bench]\n     fn format_show(b: &mut Bencher) {\n-        let mut rng = weak_rng();\n+        let mut rng = thread_rng();\n         b.iter(|| { write!(&mut sink(), \"{:?}\", rng.gen::<i32>()) })\n     }\n \n     #[bench]\n     fn format_base_36(b: &mut Bencher) {\n-        let mut rng = weak_rng();\n+        let mut rng = thread_rng();\n         b.iter(|| { write!(&mut sink(), \"{}\", radix(rng.gen::<i32>(), 36)) })\n     }\n }"}, {"sha": "1e0e2018050baff53e4ba74c07adc4ac47548cad", "filename": "src/libflate/lib.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibflate%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibflate%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibflate%2Flib.rs?ref=16e1fcead14628701e1b10b9d00c898d748db2ed", "patch": "@@ -155,12 +155,11 @@ pub fn inflate_bytes_zlib(bytes: &[u8]) -> Result<Bytes,Error> {\n mod tests {\n     #![allow(deprecated)]\n     use super::{inflate_bytes, deflate_bytes};\n-    use std::rand;\n-    use std::rand::Rng;\n+    use std::__rand::{thread_rng, Rng};\n \n     #[test]\n     fn test_flate_round_trip() {\n-        let mut r = rand::thread_rng();\n+        let mut r = thread_rng();\n         let mut words = vec![];\n         for _ in 0..20 {\n             let range = r.gen_range(1, 10);"}, {"sha": "ba3a6831d8c753c387ddbd59fbd5dbe0477e686c", "filename": "src/liblibc/lib.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Fliblibc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Fliblibc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblibc%2Flib.rs?ref=16e1fcead14628701e1b10b9d00c898d748db2ed", "patch": "@@ -3344,6 +3344,8 @@ pub mod consts {\n             pub const _SC_XOPEN_REALTIME : c_int = 130;\n             pub const _SC_XOPEN_REALTIME_THREADS : c_int = 131;\n \n+\n+\n             pub const PTHREAD_CREATE_JOINABLE: c_int = 0;\n             pub const PTHREAD_CREATE_DETACHED: c_int = 1;\n \n@@ -3727,12 +3729,14 @@ pub mod consts {\n             pub const _SC_2_FORT_RUN : c_int = 50;\n             pub const _SC_2_SW_DEV : c_int = 51;\n             pub const _SC_2_LOCALEDEF : c_int = 52;\n+            pub const _SC_NPROCESSORS_ONLN : c_int = 84;\n             pub const _SC_2_CHAR_TERM : c_int = 95;\n             pub const _SC_2_C_VERSION : c_int = 96;\n             pub const _SC_2_UPE : c_int = 97;\n             pub const _SC_XBS5_ILP32_OFF32 : c_int = 125;\n             pub const _SC_XBS5_ILP32_OFFBIG : c_int = 126;\n             pub const _SC_XBS5_LPBIG_OFFBIG : c_int = 128;\n+\n         }\n         #[cfg(target_os = \"nacl\")]\n         pub mod sysconf {\n@@ -3742,6 +3746,13 @@ pub mod consts {\n             pub static _SC_NPROCESSORS_ONLN : c_int = 1;\n             pub static _SC_PAGESIZE : c_int = 2;\n         }\n+\n+        #[cfg(target_os = \"macos\")]\n+        pub mod sysconf {\n+            use types::os::arch::c95::c_int;\n+            pub static _SC_NPROCESSORS_ONLN : c_int = 58;\n+        }\n+\n         #[cfg(target_os = \"android\")]\n         pub mod sysconf {\n             use types::os::arch::c95::c_int;"}, {"sha": "5ba6d8912f2672bcf73c58b0863f54fd18a87167", "filename": "src/librand/distributions/exponential.rs", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibrand%2Fdistributions%2Fexponential.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibrand%2Fdistributions%2Fexponential.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fdistributions%2Fexponential.rs?ref=16e1fcead14628701e1b10b9d00c898d748db2ed", "patch": "@@ -56,18 +56,6 @@ impl Rand for Exp1 {\n ///\n /// This distribution has density function: `f(x) = lambda *\n /// exp(-lambda * x)` for `x > 0`.\n-///\n-/// # Examples\n-///\n-/// ```\n-/// # #![feature(rand)]\n-/// use std::rand;\n-/// use std::rand::distributions::{Exp, IndependentSample};\n-///\n-/// let exp = Exp::new(2.0);\n-/// let v = exp.ind_sample(&mut rand::thread_rng());\n-/// println!(\"{} is from a Exp(2) distribution\", v);\n-/// ```\n #[derive(Copy, Clone)]\n pub struct Exp {\n     /// `lambda` stored as `1/lambda`, since this is what we scale by."}, {"sha": "1125d09653631cd84bdaa134c9ede52289908e7b", "filename": "src/librand/distributions/gamma.rs", "status": "modified", "additions": 0, "deletions": 48, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibrand%2Fdistributions%2Fgamma.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibrand%2Fdistributions%2Fgamma.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fdistributions%2Fgamma.rs?ref=16e1fcead14628701e1b10b9d00c898d748db2ed", "patch": "@@ -37,18 +37,6 @@ use super::{IndependentSample, Sample, Exp};\n /// == 1`, and using the boosting technique described in [1] for\n /// `shape < 1`.\n ///\n-/// # Examples\n-///\n-/// ```\n-/// # #![feature(rand)]\n-/// use std::rand;\n-/// use std::rand::distributions::{IndependentSample, Gamma};\n-///\n-/// let gamma = Gamma::new(2.0, 5.0);\n-/// let v = gamma.ind_sample(&mut rand::thread_rng());\n-/// println!(\"{} is from a Gamma(2, 5) distribution\", v);\n-/// ```\n-///\n /// [1]: George Marsaglia and Wai Wan Tsang. 2000. \"A Simple Method\n /// for Generating Gamma Variables\" *ACM Trans. Math. Softw.* 26, 3\n /// (September 2000),\n@@ -184,18 +172,6 @@ impl IndependentSample<f64> for GammaLargeShape {\n /// of `k` independent standard normal random variables. For other\n /// `k`, this uses the equivalent characterisation `\u03c7\u00b2(k) = Gamma(k/2,\n /// 2)`.\n-///\n-/// # Examples\n-///\n-/// ```\n-/// # #![feature(rand)]\n-/// use std::rand;\n-/// use std::rand::distributions::{ChiSquared, IndependentSample};\n-///\n-/// let chi = ChiSquared::new(11.0);\n-/// let v = chi.ind_sample(&mut rand::thread_rng());\n-/// println!(\"{} is from a \u03c7\u00b2(11) distribution\", v)\n-/// ```\n pub struct ChiSquared {\n     repr: ChiSquaredRepr,\n }\n@@ -242,18 +218,6 @@ impl IndependentSample<f64> for ChiSquared {\n /// This distribution is equivalent to the ratio of two normalised\n /// chi-squared distributions, that is, `F(m,n) = (\u03c7\u00b2(m)/m) /\n /// (\u03c7\u00b2(n)/n)`.\n-///\n-/// # Examples\n-///\n-/// ```\n-/// # #![feature(rand)]\n-/// use std::rand;\n-/// use std::rand::distributions::{FisherF, IndependentSample};\n-///\n-/// let f = FisherF::new(2.0, 32.0);\n-/// let v = f.ind_sample(&mut rand::thread_rng());\n-/// println!(\"{} is from an F(2, 32) distribution\", v)\n-/// ```\n pub struct FisherF {\n     numer: ChiSquared,\n     denom: ChiSquared,\n@@ -287,18 +251,6 @@ impl IndependentSample<f64> for FisherF {\n \n /// The Student t distribution, `t(nu)`, where `nu` is the degrees of\n /// freedom.\n-///\n-/// # Examples\n-///\n-/// ```\n-/// # #![feature(rand)]\n-/// use std::rand;\n-/// use std::rand::distributions::{StudentT, IndependentSample};\n-///\n-/// let t = StudentT::new(11.0);\n-/// let v = t.ind_sample(&mut rand::thread_rng());\n-/// println!(\"{} is from a t(11) distribution\", v)\n-/// ```\n pub struct StudentT {\n     chi: ChiSquared,\n     dof: f64"}, {"sha": "77e53248607ca91abb4c4b67a4ecb8b1e138ea79", "filename": "src/librand/distributions/mod.rs", "status": "modified", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibrand%2Fdistributions%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibrand%2Fdistributions%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fdistributions%2Fmod.rs?ref=16e1fcead14628701e1b10b9d00c898d748db2ed", "patch": "@@ -90,24 +90,6 @@ pub struct Weighted<T> {\n /// `IndependentSample` traits. Note that `&T` is (cheaply) `Clone` for\n /// all `T`, as is `usize`, so one can store references or indices into\n /// another vector.\n-///\n-/// # Examples\n-///\n-/// ```\n-/// # #![feature(rand)]\n-/// use std::rand;\n-/// use std::rand::distributions::{Weighted, WeightedChoice, IndependentSample};\n-///\n-/// let mut items = vec!(Weighted { weight: 2, item: 'a' },\n-///                      Weighted { weight: 4, item: 'b' },\n-///                      Weighted { weight: 1, item: 'c' });\n-/// let wc = WeightedChoice::new(&mut items[..]);\n-/// let mut rng = rand::thread_rng();\n-/// for _ in 0..16 {\n-///      // on average prints 'a' 4 times, 'b' 8 and 'c' twice.\n-///      println!(\"{}\", wc.ind_sample(&mut rng));\n-/// }\n-/// ```\n pub struct WeightedChoice<'a, T:'a> {\n     items: &'a mut [Weighted<T>],\n     weight_range: Range<usize>"}, {"sha": "ac3fe6510ebcdeb5b7c3b6cb206daa783fe0a13a", "filename": "src/librand/distributions/normal.rs", "status": "modified", "additions": 0, "deletions": 26, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibrand%2Fdistributions%2Fnormal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibrand%2Fdistributions%2Fnormal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fdistributions%2Fnormal.rs?ref=16e1fcead14628701e1b10b9d00c898d748db2ed", "patch": "@@ -72,19 +72,6 @@ impl Rand for StandardNormal {\n ///\n /// This uses the ZIGNOR variant of the Ziggurat method, see\n /// `StandardNormal` for more details.\n-///\n-/// # Examples\n-///\n-/// ```\n-/// # #![feature(rand)]\n-/// use std::rand;\n-/// use std::rand::distributions::{Normal, IndependentSample};\n-///\n-/// // mean 2, standard deviation 3\n-/// let normal = Normal::new(2.0, 3.0);\n-/// let v = normal.ind_sample(&mut rand::thread_rng());\n-/// println!(\"{} is from a N(2, 9) distribution\", v)\n-/// ```\n #[derive(Copy, Clone)]\n pub struct Normal {\n     mean: f64,\n@@ -121,19 +108,6 @@ impl IndependentSample<f64> for Normal {\n ///\n /// If `X` is log-normal distributed, then `ln(X)` is `N(mean,\n /// std_dev**2)` distributed.\n-///\n-/// # Examples\n-///\n-/// ```\n-/// # #![feature(rand)]\n-/// use std::rand;\n-/// use std::rand::distributions::{LogNormal, IndependentSample};\n-///\n-/// // mean 2, standard deviation 3\n-/// let log_normal = LogNormal::new(2.0, 3.0);\n-/// let v = log_normal.ind_sample(&mut rand::thread_rng());\n-/// println!(\"{} is from an ln N(2, 9) distribution\", v)\n-/// ```\n #[derive(Copy, Clone)]\n pub struct LogNormal {\n     norm: Normal"}, {"sha": "8406c76cc1bbc4b915a1c1d0a694b74da5a4eeda", "filename": "src/librand/distributions/range.rs", "status": "modified", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibrand%2Fdistributions%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibrand%2Fdistributions%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fdistributions%2Frange.rs?ref=16e1fcead14628701e1b10b9d00c898d748db2ed", "patch": "@@ -32,23 +32,6 @@ use distributions::{Sample, IndependentSample};\n /// including `high`, but this may be very difficult. All the\n /// primitive integer types satisfy this property, and the float types\n /// normally satisfy it, but rounding may mean `high` can occur.\n-///\n-/// # Examples\n-///\n-/// ```\n-/// # #![feature(rand)]\n-/// use std::rand::distributions::{IndependentSample, Range};\n-///\n-/// fn main() {\n-///     let between = Range::new(10, 10000);\n-///     let mut rng = std::rand::thread_rng();\n-///     let mut sum = 0;\n-///     for _ in 0..1000 {\n-///         sum += between.ind_sample(&mut rng);\n-///     }\n-///     println!(\"{}\", sum);\n-/// }\n-/// ```\n pub struct Range<X> {\n     low: X,\n     range: X,"}, {"sha": "53ea28f0c11d3998a29d22d19ab6ea3f86b71d7f", "filename": "src/librand/lib.rs", "status": "modified", "additions": 7, "deletions": 152, "changes": 159, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibrand%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibrand%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Flib.rs?ref=16e1fcead14628701e1b10b9d00c898d748db2ed", "patch": "@@ -24,15 +24,13 @@\n        html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n        html_root_url = \"http://doc.rust-lang.org/nightly/\",\n        html_playground_url = \"http://play.rust-lang.org/\")]\n-#![feature(no_std)]\n #![no_std]\n-#![unstable(feature = \"rand\")]\n-#![feature(staged_api)]\n #![staged_api]\n+#![unstable(feature = \"rand\")]\n #![feature(core)]\n+#![feature(no_std)]\n+#![feature(staged_api)]\n #![feature(step_by)]\n-#![deprecated(reason = \"use the crates.io `rand` library instead\",\n-              since = \"1.0.0-alpha\")]\n \n #![cfg_attr(test, feature(test, rand, rustc_private))]\n \n@@ -145,17 +143,6 @@ pub trait Rng : Sized {\n     /// with new data, and may panic if this is impossible\n     /// (e.g. reading past the end of a file that is being used as the\n     /// source of randomness).\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// # #![feature(rand, core)]\n-    /// use std::rand::{thread_rng, Rng};\n-    ///\n-    /// let mut v = [0; 13579];\n-    /// thread_rng().fill_bytes(&mut v);\n-    /// println!(\"{:?}\", &v[..]);\n-    /// ```\n     fn fill_bytes(&mut self, dest: &mut [u8]) {\n         // this could, in theory, be done by transmuting dest to a\n         // [u64], but this is (1) likely to be undefined behaviour for\n@@ -181,38 +168,13 @@ pub trait Rng : Sized {\n     }\n \n     /// Return a random value of a `Rand` type.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// # #![feature(rand)]\n-    /// use std::rand::{thread_rng, Rng};\n-    ///\n-    /// let mut rng = thread_rng();\n-    /// let x: usize = rng.gen();\n-    /// println!(\"{}\", x);\n-    /// println!(\"{:?}\", rng.gen::<(f64, bool)>());\n-    /// ```\n     #[inline(always)]\n     fn gen<T: Rand>(&mut self) -> T {\n         Rand::rand(self)\n     }\n \n     /// Return an iterator that will yield an infinite number of randomly\n     /// generated items.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// # #![feature(rand)]\n-    /// use std::rand::{thread_rng, Rng};\n-    ///\n-    /// let mut rng = thread_rng();\n-    /// let x = rng.gen_iter::<usize>().take(10).collect::<Vec<usize>>();\n-    /// println!(\"{:?}\", x);\n-    /// println!(\"{:?}\", rng.gen_iter::<(f64, bool)>().take(5)\n-    ///                     .collect::<Vec<(f64, bool)>>());\n-    /// ```\n     fn gen_iter<'a, T: Rand>(&'a mut self) -> Generator<'a, T, Self> {\n         Generator { rng: self, _marker: PhantomData }\n     }\n@@ -228,69 +190,24 @@ pub trait Rng : Sized {\n     /// # Panics\n     ///\n     /// Panics if `low >= high`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// # #![feature(rand)]\n-    /// use std::rand::{thread_rng, Rng};\n-    ///\n-    /// let mut rng = thread_rng();\n-    /// let n: usize = rng.gen_range(0, 10);\n-    /// println!(\"{}\", n);\n-    /// let m: f64 = rng.gen_range(-40.0f64, 1.3e5f64);\n-    /// println!(\"{}\", m);\n-    /// ```\n     fn gen_range<T: PartialOrd + SampleRange>(&mut self, low: T, high: T) -> T {\n         assert!(low < high, \"Rng.gen_range called with low >= high\");\n         Range::new(low, high).ind_sample(self)\n     }\n \n     /// Return a bool with a 1 in n chance of true\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// # #![feature(rand)]\n-    /// use std::rand::{thread_rng, Rng};\n-    ///\n-    /// let mut rng = thread_rng();\n-    /// println!(\"{}\", rng.gen_weighted_bool(3));\n-    /// ```\n     fn gen_weighted_bool(&mut self, n: usize) -> bool {\n         n <= 1 || self.gen_range(0, n) == 0\n     }\n \n     /// Return an iterator of random characters from the set A-Z,a-z,0-9.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// # #![feature(rand)]\n-    /// use std::rand::{thread_rng, Rng};\n-    ///\n-    /// let s: String = thread_rng().gen_ascii_chars().take(10).collect();\n-    /// println!(\"{}\", s);\n-    /// ```\n     fn gen_ascii_chars<'a>(&'a mut self) -> AsciiGenerator<'a, Self> {\n         AsciiGenerator { rng: self }\n     }\n \n     /// Return a random element from `values`.\n     ///\n     /// Return `None` if `values` is empty.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// # #![feature(rand)]\n-    /// use std::rand::{thread_rng, Rng};\n-    ///\n-    /// let choices = [1, 2, 4, 8, 16, 32];\n-    /// let mut rng = thread_rng();\n-    /// println!(\"{:?}\", rng.choose(&choices));\n-    /// assert_eq!(rng.choose(&choices[..0]), None);\n-    /// ```\n     fn choose<'a, T>(&mut self, values: &'a [T]) -> Option<&'a T> {\n         if values.is_empty() {\n             None\n@@ -300,20 +217,6 @@ pub trait Rng : Sized {\n     }\n \n     /// Shuffle a mutable slice in place.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// # #![feature(rand, core)]\n-    /// use std::rand::{thread_rng, Rng};\n-    ///\n-    /// let mut rng = thread_rng();\n-    /// let mut y = [1, 2, 3];\n-    /// rng.shuffle(&mut y);\n-    /// println!(\"{:?}\", y);\n-    /// rng.shuffle(&mut y);\n-    /// println!(\"{:?}\", y);\n-    /// ```\n     fn shuffle<T>(&mut self, values: &mut [T]) {\n         let mut i = values.len();\n         while i >= 2 {\n@@ -364,33 +267,9 @@ impl<'a, R: Rng> Iterator for AsciiGenerator<'a, R> {\n /// the same stream of randomness multiple times.\n pub trait SeedableRng<Seed>: Rng {\n     /// Reseed an RNG with the given seed.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// # #![feature(rand)]\n-    /// use std::rand::{Rng, SeedableRng, StdRng};\n-    ///\n-    /// let seed: &[_] = &[1, 2, 3, 4];\n-    /// let mut rng: StdRng = SeedableRng::from_seed(seed);\n-    /// println!(\"{}\", rng.gen::<f64>());\n-    /// rng.reseed(&[5, 6, 7, 8]);\n-    /// println!(\"{}\", rng.gen::<f64>());\n-    /// ```\n     fn reseed(&mut self, Seed);\n \n     /// Create a new RNG with the given seed.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// # #![feature(rand)]\n-    /// use std::rand::{Rng, SeedableRng, StdRng};\n-    ///\n-    /// let seed: &[_] = &[1, 2, 3, 4];\n-    /// let mut rng: StdRng = SeedableRng::from_seed(seed);\n-    /// println!(\"{}\", rng.gen::<f64>());\n-    /// ```\n     fn from_seed(seed: Seed) -> Self;\n }\n \n@@ -486,16 +365,6 @@ impl Rand for XorShiftRng {\n /// Use `Closed01` for the closed interval `[0,1]`, and the default\n /// `Rand` implementation for `f32` and `f64` for the half-open\n /// `[0,1)`.\n-///\n-/// # Examples\n-///\n-/// ```\n-/// # #![feature(rand)]\n-/// use std::rand::{random, Open01};\n-///\n-/// let Open01(val) = random::<Open01<f32>>();\n-/// println!(\"f32 from (0,1): {}\", val);\n-/// ```\n pub struct Open01<F>(pub F);\n \n /// A wrapper for generating floating point numbers uniformly in the\n@@ -504,39 +373,25 @@ pub struct Open01<F>(pub F);\n /// Use `Open01` for the closed interval `(0,1)`, and the default\n /// `Rand` implementation of `f32` and `f64` for the half-open\n /// `[0,1)`.\n-///\n-/// # Examples\n-///\n-/// ```\n-/// # #![feature(rand)]\n-/// use std::rand::{random, Closed01};\n-///\n-/// let Closed01(val) = random::<Closed01<f32>>();\n-/// println!(\"f32 from [0,1]: {}\", val);\n-/// ```\n pub struct Closed01<F>(pub F);\n \n #[cfg(test)]\n mod test {\n-    use std::rand;\n+    use std::__rand as rand;\n \n     pub struct MyRng<R> { inner: R }\n \n     impl<R: rand::Rng> ::Rng for MyRng<R> {\n         fn next_u32(&mut self) -> u32 {\n-            fn next<T: rand::Rng>(t: &mut T) -> u32 {\n-                use std::rand::Rng;\n-                t.next_u32()\n-            }\n-            next(&mut self.inner)\n+            rand::Rng::next_u32(&mut self.inner)\n         }\n     }\n \n     pub fn rng() -> MyRng<rand::ThreadRng> {\n         MyRng { inner: rand::thread_rng() }\n     }\n \n-    pub fn weak_rng() -> MyRng<rand::XorShiftRng> {\n-        MyRng { inner: rand::weak_rng() }\n+    pub fn weak_rng() -> MyRng<rand::ThreadRng> {\n+        MyRng { inner: rand::thread_rng() }\n     }\n }"}, {"sha": "2f37451ecbb3a095318c0ffefc1b47d0bccff72a", "filename": "src/librand/rand_impls.rs", "status": "modified", "additions": 0, "deletions": 52, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibrand%2Frand_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibrand%2Frand_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Frand_impls.rs?ref=16e1fcead14628701e1b10b9d00c898d748db2ed", "patch": "@@ -211,55 +211,3 @@ impl<T:Rand> Rand for Option<T> {\n         }\n     }\n }\n-\n-#[cfg(test)]\n-mod tests {\n-    use std::rand::{Rng, thread_rng, Open01, Closed01};\n-\n-    struct ConstantRng(u64);\n-    impl Rng for ConstantRng {\n-        fn next_u32(&mut self) -> u32 {\n-            let ConstantRng(v) = *self;\n-            v as u32\n-        }\n-        fn next_u64(&mut self) -> u64 {\n-            let ConstantRng(v) = *self;\n-            v\n-        }\n-    }\n-\n-    #[test]\n-    fn floating_point_edge_cases() {\n-        // the test for exact equality is correct here.\n-        assert!(ConstantRng(0xffff_ffff).gen::<f32>() != 1.0);\n-        assert!(ConstantRng(0xffff_ffff_ffff_ffff).gen::<f64>() != 1.0);\n-    }\n-\n-    #[test]\n-    fn rand_open() {\n-        // this is unlikely to catch an incorrect implementation that\n-        // generates exactly 0 or 1, but it keeps it sane.\n-        let mut rng = thread_rng();\n-        for _ in 0..1_000 {\n-            // strict inequalities\n-            let Open01(f) = rng.gen::<Open01<f64>>();\n-            assert!(0.0 < f && f < 1.0);\n-\n-            let Open01(f) = rng.gen::<Open01<f32>>();\n-            assert!(0.0 < f && f < 1.0);\n-        }\n-    }\n-\n-    #[test]\n-    fn rand_closed() {\n-        let mut rng = thread_rng();\n-        for _ in 0..1_000 {\n-            // strict inequalities\n-            let Closed01(f) = rng.gen::<Closed01<f64>>();\n-            assert!(0.0 <= f && f <= 1.0);\n-\n-            let Closed01(f) = rng.gen::<Closed01<f32>>();\n-            assert!(0.0 <= f && f <= 1.0);\n-        }\n-    }\n-}"}, {"sha": "287a23cf1d1b68a90d77ad2633880978f0273130", "filename": "src/librand/reseeding.rs", "status": "modified", "additions": 0, "deletions": 28, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibrand%2Freseeding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibrand%2Freseeding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Freseeding.rs?ref=16e1fcead14628701e1b10b9d00c898d748db2ed", "patch": "@@ -99,34 +99,6 @@ impl<S, R: SeedableRng<S>, Rsdr: Reseeder<R> + Default>\n }\n \n /// Something that can be used to reseed an RNG via `ReseedingRng`.\n-///\n-/// # Examples\n-///\n-/// ```\n-/// # #![feature(rand)]\n-/// use std::rand::{Rng, SeedableRng, StdRng};\n-/// use std::rand::reseeding::{Reseeder, ReseedingRng};\n-///\n-/// struct TickTockReseeder { tick: bool }\n-/// impl Reseeder<StdRng> for TickTockReseeder {\n-///     fn reseed(&mut self, rng: &mut StdRng) {\n-///         let val = if self.tick {0} else {1};\n-///         rng.reseed(&[val]);\n-///         self.tick = !self.tick;\n-///     }\n-/// }\n-/// fn main() {\n-///     let rsdr = TickTockReseeder { tick: true };\n-///\n-///     let inner = StdRng::new().unwrap();\n-///     let mut rng = ReseedingRng::new(inner, 10, rsdr);\n-///\n-///     // this will repeat, because it gets reseeded very regularly.\n-///     let s: String = rng.gen_ascii_chars().take(100).collect();\n-///     println!(\"{}\", s);\n-/// }\n-///\n-/// ```\n pub trait Reseeder<R> {\n     /// Reseed the given RNG.\n     fn reseed(&mut self, rng: &mut R);"}, {"sha": "b3188f260b906d69b5aa7bdf11672e94005645a8", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=16e1fcead14628701e1b10b9d00c898d748db2ed", "patch": "@@ -562,7 +562,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for DeadVisitor<'a, 'tcx> {\n                 span: codemap::Span, id: ast::NodeId) {\n         // Have to warn method here because methods are not ast::Item\n         match fk {\n-            visit::FkMethod(name, _) => {\n+            visit::FkMethod(name, _, _) => {\n                 if !self.symbol_is_live(id, None) {\n                     self.warn_dead_code(id, span, name.name, \"method\");\n                 }"}, {"sha": "b6a070c9332fda45b3e894ec19eab99a20252319", "filename": "src/librustc/middle/effect.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibrustc%2Fmiddle%2Feffect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibrustc%2Fmiddle%2Feffect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Feffect.rs?ref=16e1fcead14628701e1b10b9d00c898d748db2ed", "patch": "@@ -87,9 +87,9 @@ impl<'a, 'tcx, 'v> Visitor<'v> for EffectCheckVisitor<'a, 'tcx> {\n                 block: &'v ast::Block, span: Span, _: ast::NodeId) {\n \n         let (is_item_fn, is_unsafe_fn) = match fn_kind {\n-            visit::FkItemFn(_, _, fn_style, _) =>\n+            visit::FkItemFn(_, _, fn_style, _, _) =>\n                 (true, fn_style == ast::Unsafety::Unsafe),\n-            visit::FkMethod(_, sig) =>\n+            visit::FkMethod(_, sig, _) =>\n                 (true, sig.unsafety == ast::Unsafety::Unsafe),\n             _ => (false, false),\n         };"}, {"sha": "53ed3b919488737a7a4f8c683639d68717e6d488", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=16e1fcead14628701e1b10b9d00c898d748db2ed", "patch": "@@ -142,12 +142,12 @@ impl<'a, 'v> Visitor<'v> for LifetimeContext<'a> {\n     fn visit_fn(&mut self, fk: visit::FnKind<'v>, fd: &'v ast::FnDecl,\n                 b: &'v ast::Block, s: Span, _: ast::NodeId) {\n         match fk {\n-            visit::FkItemFn(_, generics, _, _) => {\n+            visit::FkItemFn(_, generics, _, _, _) => {\n                 self.visit_early_late(subst::FnSpace, generics, |this| {\n                     visit::walk_fn(this, fk, fd, b, s)\n                 })\n             }\n-            visit::FkMethod(_, sig) => {\n+            visit::FkMethod(_, sig, _) => {\n                 self.visit_early_late(subst::FnSpace, &sig.generics, |this| {\n                     visit::walk_fn(this, fk, fd, b, s)\n                 })"}, {"sha": "e7c25d82150933e72d92401659e76304abb7151c", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=16e1fcead14628701e1b10b9d00c898d748db2ed", "patch": "@@ -96,8 +96,8 @@ impl<'a> Annotator<'a> {\n                 if tag == \"unstable\" || tag == \"stable\" || tag == \"deprecated\" {\n                     attr::mark_used(attr);\n                     self.sess.span_warn(attr.span(),\n-                                        \"stability attributes are deprecated and \\\n-                                         will soon become errors\");\n+                                        \"stability attributes are deprecated \\\n+                                         and will soon become errors\");\n                 }\n             }\n             f(self);"}, {"sha": "2ab4d7ff78a1d256edc6fad38d6e96b17e308412", "filename": "src/librustc_back/fs.rs", "status": "modified", "additions": 37, "deletions": 64, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibrustc_back%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibrustc_back%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ffs.rs?ref=16e1fcead14628701e1b10b9d00c898d748db2ed", "patch": "@@ -9,69 +9,42 @@\n // except according to those terms.\n \n use std::io;\n-use std::env;\n-#[allow(deprecated)] use std::old_path::{self, GenericPath};\n-#[allow(deprecated)] use std::old_io;\n use std::path::{Path, PathBuf};\n \n-/// Returns an absolute path in the filesystem that `path` points to. The\n-/// returned path does not contain any symlinks in its hierarchy.\n-#[allow(deprecated)] // readlink is deprecated\n+#[cfg(windows)]\n pub fn realpath(original: &Path) -> io::Result<PathBuf> {\n-    let old = old_path::Path::new(original.to_str().unwrap());\n-    match old_realpath(&old) {\n-        Ok(p) => Ok(PathBuf::from(p.as_str().unwrap())),\n-        Err(e) => Err(io::Error::new(io::ErrorKind::Other, e))\n-    }\n+    Ok(original.to_path_buf())\n }\n \n-#[allow(deprecated)]\n-fn old_realpath(original: &old_path::Path) -> old_io::IoResult<old_path::Path> {\n-    use std::old_io::fs;\n-    const MAX_LINKS_FOLLOWED: usize = 256;\n-    let original = old_path::Path::new(env::current_dir().unwrap()\n-                                           .to_str().unwrap()).join(original);\n+#[cfg(unix)]\n+pub fn realpath(original: &Path) -> io::Result<PathBuf> {\n+    use libc;\n+    use std::ffi::{OsString, CString};\n+    use std::os::unix::prelude::*;\n \n-    // Right now lstat on windows doesn't work quite well\n-    if cfg!(windows) {\n-        return Ok(original)\n+    extern {\n+        fn realpath(pathname: *const libc::c_char, resolved: *mut libc::c_char)\n+                    -> *mut libc::c_char;\n     }\n \n-    let result = original.root_path();\n-    let mut result = result.expect(\"make_absolute has no root_path\");\n-    let mut followed = 0;\n-\n-    for part in original.components() {\n-        result.push(part);\n-\n-        loop {\n-            if followed == MAX_LINKS_FOLLOWED {\n-                return Err(old_io::standard_error(old_io::InvalidInput))\n-            }\n-\n-            match fs::lstat(&result) {\n-                Err(..) => break,\n-                Ok(ref stat) if stat.kind != old_io::FileType::Symlink => break,\n-                Ok(..) => {\n-                    followed += 1;\n-                    let path = try!(fs::readlink(&result));\n-                    result.pop();\n-                    result.push(path);\n-                }\n-            }\n+    let path = try!(CString::new(original.as_os_str().as_bytes()));\n+    let mut buf = vec![0u8; 16 * 1024];\n+    unsafe {\n+        let r = realpath(path.as_ptr(), buf.as_mut_ptr() as *mut _);\n+        if r.is_null() {\n+            return Err(io::Error::last_os_error())\n         }\n     }\n-\n-    return Ok(result);\n+    let p = buf.iter().position(|i| *i == 0).unwrap();\n+    buf.truncate(p);\n+    Ok(PathBuf::from(OsString::from_vec(buf)))\n }\n \n #[cfg(all(not(windows), test))]\n mod test {\n-    use std::old_io;\n-    use std::old_io::fs::{File, symlink, mkdir, mkdir_recursive};\n-    use super::old_realpath as realpath;\n-    use std::old_io::TempDir;\n-    use std::old_path::{Path, GenericPath};\n+    use tempdir::TempDir;\n+    use std::fs::{self, File};\n+    use super::realpath;\n \n     #[test]\n     fn realpath_works() {\n@@ -83,15 +56,15 @@ mod test {\n         let linkdir = tmpdir.join(\"test3\");\n \n         File::create(&file).unwrap();\n-        mkdir(&dir, old_io::USER_RWX).unwrap();\n-        symlink(&file, &link).unwrap();\n-        symlink(&dir, &linkdir).unwrap();\n-\n-        assert!(realpath(&tmpdir).unwrap() == tmpdir);\n-        assert!(realpath(&file).unwrap() == file);\n-        assert!(realpath(&link).unwrap() == file);\n-        assert!(realpath(&linkdir).unwrap() == dir);\n-        assert!(realpath(&linkdir.join(\"link\")).unwrap() == file);\n+        fs::create_dir(&dir).unwrap();\n+        fs::soft_link(&file, &link).unwrap();\n+        fs::soft_link(&dir, &linkdir).unwrap();\n+\n+        assert_eq!(realpath(&tmpdir).unwrap(), tmpdir);\n+        assert_eq!(realpath(&file).unwrap(), file);\n+        assert_eq!(realpath(&link).unwrap(), file);\n+        assert_eq!(realpath(&linkdir).unwrap(), dir);\n+        assert_eq!(realpath(&linkdir.join(\"link\")).unwrap(), file);\n     }\n \n     #[test]\n@@ -106,13 +79,13 @@ mod test {\n         let e = d.join(\"e\");\n         let f = a.join(\"f\");\n \n-        mkdir_recursive(&b, old_io::USER_RWX).unwrap();\n-        mkdir_recursive(&d, old_io::USER_RWX).unwrap();\n+        fs::create_dir_all(&b).unwrap();\n+        fs::create_dir_all(&d).unwrap();\n         File::create(&f).unwrap();\n-        symlink(&Path::new(\"../d/e\"), &c).unwrap();\n-        symlink(&Path::new(\"../f\"), &e).unwrap();\n+        fs::soft_link(\"../d/e\", &c).unwrap();\n+        fs::soft_link(\"../f\", &e).unwrap();\n \n-        assert!(realpath(&c).unwrap() == f);\n-        assert!(realpath(&e).unwrap() == f);\n+        assert_eq!(realpath(&c).unwrap(), f);\n+        assert_eq!(realpath(&e).unwrap(), f);\n     }\n }"}, {"sha": "3c54d6631f893897532778033f8481594587a05a", "filename": "src/librustc_back/lib.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibrustc_back%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibrustc_back%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Flib.rs?ref=16e1fcead14628701e1b10b9d00c898d748db2ed", "patch": "@@ -35,17 +35,16 @@\n #![feature(box_syntax)]\n #![feature(collections)]\n #![feature(core)]\n-#![feature(old_fs)]\n-#![feature(old_io)]\n-#![feature(old_path)]\n #![feature(rustc_private)]\n #![feature(staged_api)]\n #![feature(rand)]\n #![feature(path_ext)]\n #![feature(step_by)]\n+#![feature(libc)]\n #![cfg_attr(test, feature(test, rand))]\n \n extern crate syntax;\n+extern crate libc;\n extern crate serialize;\n #[macro_use] extern crate log;\n "}, {"sha": "58073079d31dffcdaf725bc6d7056bfdaaa9de1a", "filename": "src/librustc_back/rpath.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibrustc_back%2Frpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibrustc_back%2Frpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Frpath.rs?ref=16e1fcead14628701e1b10b9d00c898d748db2ed", "patch": "@@ -97,8 +97,9 @@ fn get_rpath_relative_to_output(config: &mut RPathConfig, lib: &Path) -> String\n     let cwd = env::current_dir().unwrap();\n     let mut lib = (config.realpath)(&cwd.join(lib)).unwrap();\n     lib.pop();\n-    let mut output = (config.realpath)(&cwd.join(&config.out_filename)).unwrap();\n+    let mut output = cwd.join(&config.out_filename);\n     output.pop();\n+    let output = (config.realpath)(&output).unwrap();\n     let relative = path_relative_from(&lib, &output)\n         .expect(&format!(\"couldn't create relative path from {:?} to {:?}\", output, lib));\n     // FIXME (#9639): This needs to handle non-utf8 paths"}, {"sha": "522d66cb563a344d8a404b3776bdba3d75fefa99", "filename": "src/librustc_back/tempdir.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibrustc_back%2Ftempdir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibrustc_back%2Ftempdir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftempdir.rs?ref=16e1fcead14628701e1b10b9d00c898d748db2ed", "patch": "@@ -12,7 +12,7 @@ use std::env;\n use std::io::{self, Error, ErrorKind};\n use std::fs;\n use std::path::{self, PathBuf, Path};\n-use std::rand::{thread_rng, Rng};\n+use std::__rand::{thread_rng, Rng};\n \n /// A wrapper for a path to temporary directory implementing automatic\n /// scope-based deletion."}, {"sha": "72c679e8833a2b25bf7426c59e97ff41f6f4fd2b", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=16e1fcead14628701e1b10b9d00c898d748db2ed", "patch": "@@ -957,7 +957,7 @@ impl LintPass for NonSnakeCase {\n                 fk: visit::FnKind, _: &ast::FnDecl,\n                 _: &ast::Block, span: Span, id: ast::NodeId) {\n         match fk {\n-            visit::FkMethod(ident, _) => match method_context(cx, id, span) {\n+            visit::FkMethod(ident, _, _) => match method_context(cx, id, span) {\n                 MethodContext::PlainImpl => {\n                     self.check_snake_case(cx, \"method\", ident, span)\n                 },\n@@ -966,7 +966,7 @@ impl LintPass for NonSnakeCase {\n                 },\n                 _ => (),\n             },\n-            visit::FkItemFn(ident, _, _, _) => {\n+            visit::FkItemFn(ident, _, _, _, _) => {\n                 self.check_snake_case(cx, \"function\", ident, span)\n             },\n             _ => (),\n@@ -1290,10 +1290,10 @@ impl LintPass for UnsafeCode {\n     fn check_fn(&mut self, cx: &Context, fk: visit::FnKind, _: &ast::FnDecl,\n                 _: &ast::Block, span: Span, _: ast::NodeId) {\n         match fk {\n-            visit::FkItemFn(_, _, ast::Unsafety::Unsafe, _) =>\n+            visit::FkItemFn(_, _, ast::Unsafety::Unsafe, _, _) =>\n                 cx.span_lint(UNSAFE_CODE, span, \"declaration of an `unsafe` function\"),\n \n-            visit::FkMethod(_, sig) => {\n+            visit::FkMethod(_, sig, _) => {\n                 if sig.unsafety == ast::Unsafety::Unsafe {\n                     cx.span_lint(UNSAFE_CODE, span, \"implementation of an `unsafe` method\")\n                 }\n@@ -1818,8 +1818,8 @@ impl LintPass for UnconditionalRecursion {\n                               ast::NodeId, ast::NodeId, ast::Ident, ast::NodeId) -> bool;\n \n         let (name, checker) = match fn_kind {\n-            visit::FkItemFn(name, _, _, _) => (name, id_refers_to_this_fn as F),\n-            visit::FkMethod(name, _) => (name, id_refers_to_this_method as F),\n+            visit::FkItemFn(name, _, _, _, _) => (name, id_refers_to_this_fn as F),\n+            visit::FkMethod(name, _, _) => (name, id_refers_to_this_method as F),\n             // closures can't recur, so they don't matter.\n             visit::FkFnBlock => return\n         };"}, {"sha": "6fd59a205323c38ccffb6b14d3d64ce7826e3ccc", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=16e1fcead14628701e1b10b9d00c898d748db2ed", "patch": "@@ -242,11 +242,11 @@ impl<'a, 'v, 'tcx> Visitor<'v> for Resolver<'a, 'tcx> {\n                 _: Span,\n                 node_id: NodeId) {\n         let rib_kind = match function_kind {\n-            visit::FkItemFn(_, generics, _, _) => {\n+            visit::FkItemFn(_, generics, _, _, _) => {\n                 self.visit_generics(generics);\n                 ItemRibKind\n             }\n-            visit::FkMethod(_, sig) => {\n+            visit::FkMethod(_, sig, _) => {\n                 self.visit_generics(&sig.generics);\n                 self.visit_explicit_self(&sig.explicit_self);\n                 MethodRibKind"}, {"sha": "8cecc39ec3900093cdc329552d5d268d0e70cad7", "filename": "src/librustc_trans/trans/controlflow.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibrustc_trans%2Ftrans%2Fcontrolflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibrustc_trans%2Ftrans%2Fcontrolflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcontrolflow.rs?ref=16e1fcead14628701e1b10b9d00c898d748db2ed", "patch": "@@ -131,7 +131,9 @@ pub fn trans_block<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n     match b.expr {\n         Some(ref e) => {\n-            bcx = expr::trans_into(bcx, &**e, dest);\n+            if !bcx.unreachable.get() {\n+                bcx = expr::trans_into(bcx, &**e, dest);\n+            }\n         }\n         None => {\n             assert!(dest == expr::Ignore || bcx.unreachable.get());"}, {"sha": "8264647b2561b579d6a821aa396657477eb4e212", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=16e1fcead14628701e1b10b9d00c898d748db2ed", "patch": "@@ -2616,8 +2616,8 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                             actual)\n                 },\n                 expr_t, None);\n-            if let Some(t) = ty::ty_to_def_id(expr_t) {\n-                suggest_field_names(t, field, tcx, vec![]);\n+            if let ty::ty_struct(did, _) = expr_t.sty {\n+                suggest_field_names(did, field, tcx, vec![]);\n             }\n         }\n "}, {"sha": "c3ab375a9e24a7b8a52dcb801f9582fab033f282", "filename": "src/librustdoc/html/static/main.js", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js?ref=16e1fcead14628701e1b10b9d00c898d748db2ed", "patch": "@@ -78,9 +78,11 @@\n             return;\n         }\n \n-        if (e.which === 191 && $('#help').hasClass('hidden')) { // question mark\n-            e.preventDefault();\n-            $('#help').removeClass('hidden');\n+        if (e.which === 191) { // question mark\n+            if (e.shiftKey && $('#help').hasClass('hidden')) {\n+                e.preventDefault();\n+                $('#help').removeClass('hidden');\n+            }\n         } else if (e.which === 27) { // esc\n             if (!$('#help').hasClass('hidden')) {\n                 e.preventDefault();"}, {"sha": "1393c39f66c954362250a4df667e11a47356138c", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=16e1fcead14628701e1b10b9d00c898d748db2ed", "patch": "@@ -130,10 +130,10 @@ struct Output {\n \n pub fn main() {\n     const STACK_SIZE: usize = 32000000; // 32MB\n-    let res = std::thread::Builder::new().stack_size(STACK_SIZE).scoped(move || {\n+    let res = std::thread::Builder::new().stack_size(STACK_SIZE).spawn(move || {\n         let s = env::args().collect::<Vec<_>>();\n         main_args(&s)\n-    }).unwrap().join();\n+    }).unwrap().join().unwrap();\n     env::set_exit_status(res as i32);\n }\n "}, {"sha": "620ea40b48a35e141b8261da183db1e7d744e300", "filename": "src/libserialize/json.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibserialize%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibserialize%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fjson.rs?ref=16e1fcead14628701e1b10b9d00c898d748db2ed", "patch": "@@ -2627,9 +2627,9 @@ mod tests {\n     use super::{Json, from_str, DecodeResult, DecoderError, JsonEvent, Parser,\n                 StackElement, Stack, Decoder, Encoder, EncoderError};\n     use std::{i64, u64, f32, f64};\n+    use std::io::prelude::*;\n     use std::collections::BTreeMap;\n     use std::string;\n-    use std::old_io::Writer;\n \n     #[derive(RustcDecodable, Eq, PartialEq, Debug)]\n     struct OptionData {\n@@ -3464,7 +3464,6 @@ mod tests {\n     #[test]\n     fn test_encode_hashmap_with_numeric_key() {\n         use std::str::from_utf8;\n-        use std::old_io::Writer;\n         use std::collections::HashMap;\n         let mut hm: HashMap<usize, bool> = HashMap::new();\n         hm.insert(1, true);\n@@ -3480,7 +3479,6 @@ mod tests {\n     #[test]\n     fn test_prettyencode_hashmap_with_numeric_key() {\n         use std::str::from_utf8;\n-        use std::old_io::Writer;\n         use std::collections::HashMap;\n         let mut hm: HashMap<usize, bool> = HashMap::new();\n         hm.insert(1, true);"}, {"sha": "dde79b123e602f456a9c3cb8d2e7371d64abbb6e", "filename": "src/libserialize/lib.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibserialize%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibserialize%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Flib.rs?ref=16e1fcead14628701e1b10b9d00c898d748db2ed", "patch": "@@ -30,13 +30,12 @@ Core encoding and decoding interfaces.\n #![feature(box_syntax)]\n #![feature(collections)]\n #![feature(core)]\n-#![feature(old_path)]\n #![feature(rustc_private)]\n #![feature(staged_api)]\n #![feature(std_misc)]\n #![feature(unicode)]\n #![feature(str_char)]\n-#![cfg_attr(test, feature(test, old_io))]\n+#![cfg_attr(test, feature(test))]\n \n // test harness access\n #[cfg(test)] extern crate test;"}, {"sha": "af1387346106a9f54213b09092773802dd72fea9", "filename": "src/libserialize/serialize.rs", "status": "modified", "additions": 0, "deletions": 32, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibserialize%2Fserialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibserialize%2Fserialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fserialize.rs?ref=16e1fcead14628701e1b10b9d00c898d748db2ed", "patch": "@@ -14,8 +14,6 @@\n Core encoding and decoding interfaces.\n */\n \n-#[allow(deprecated)]\n-use std::old_path::{self, GenericPath};\n use std::path;\n use std::rc::Rc;\n use std::cell::{Cell, RefCell};\n@@ -540,36 +538,6 @@ macro_rules! tuple {\n \n tuple! { T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, }\n \n-#[allow(deprecated)]\n-impl Encodable for old_path::posix::Path {\n-    fn encode<S: Encoder>(&self, e: &mut S) -> Result<(), S::Error> {\n-        self.as_vec().encode(e)\n-    }\n-}\n-\n-#[allow(deprecated)]\n-impl Decodable for old_path::posix::Path {\n-    fn decode<D: Decoder>(d: &mut D) -> Result<old_path::posix::Path, D::Error> {\n-        let bytes: Vec<u8> = try!(Decodable::decode(d));\n-        Ok(old_path::posix::Path::new(bytes))\n-    }\n-}\n-\n-#[allow(deprecated)]\n-impl Encodable for old_path::windows::Path {\n-    fn encode<S: Encoder>(&self, e: &mut S) -> Result<(), S::Error> {\n-        self.as_vec().encode(e)\n-    }\n-}\n-\n-#[allow(deprecated)]\n-impl Decodable for old_path::windows::Path {\n-    fn decode<D: Decoder>(d: &mut D) -> Result<old_path::windows::Path, D::Error> {\n-        let bytes: Vec<u8> = try!(Decodable::decode(d));\n-        Ok(old_path::windows::Path::new(bytes))\n-    }\n-}\n-\n impl Encodable for path::PathBuf {\n     fn encode<S: Encoder>(&self, e: &mut S) -> Result<(), S::Error> {\n         self.to_str().unwrap().encode(e)"}, {"sha": "a2ba8c4c1bae07dfb9d494e3eb3c60a54f366b84", "filename": "src/libstd/ascii.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibstd%2Fascii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibstd%2Fascii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fascii.rs?ref=16e1fcead14628701e1b10b9d00c898d748db2ed", "patch": "@@ -23,12 +23,12 @@ use mem;\n #[unstable(feature = \"std_misc\",\n            reason = \"would prefer to do this in a more general way\")]\n pub trait OwnedAsciiExt {\n-    /// Convert the string to ASCII upper case:\n+    /// Converts the string to ASCII upper case:\n     /// ASCII letters 'a' to 'z' are mapped to 'A' to 'Z',\n     /// but non-ASCII letters are unchanged.\n     fn into_ascii_uppercase(self) -> Self;\n \n-    /// Convert the string to ASCII lower case:\n+    /// Converts the string to ASCII lower case:\n     /// ASCII letters 'A' to 'Z' are mapped to 'a' to 'z',\n     /// but non-ASCII letters are unchanged.\n     fn into_ascii_lowercase(self) -> Self;\n@@ -41,7 +41,7 @@ pub trait AsciiExt {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     type Owned;\n \n-    /// Check if within the ASCII range.\n+    /// Checks if within the ASCII range.\n     ///\n     /// # Examples\n     ///\n@@ -95,7 +95,7 @@ pub trait AsciiExt {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn to_ascii_lowercase(&self) -> Self::Owned;\n \n-    /// Check that two strings are an ASCII case-insensitive match.\n+    /// Checks that two strings are an ASCII case-insensitive match.\n     ///\n     /// Same as `to_ascii_lowercase(a) == to_ascii_lowercase(b)`,\n     /// but without allocating and copying temporary strings.\n@@ -117,7 +117,7 @@ pub trait AsciiExt {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn eq_ignore_ascii_case(&self, other: &Self) -> bool;\n \n-    /// Convert this type to its ASCII upper case equivalent in-place.\n+    /// Converts this type to its ASCII upper case equivalent in-place.\n     ///\n     /// See `to_ascii_uppercase` for more information.\n     ///\n@@ -136,7 +136,7 @@ pub trait AsciiExt {\n     #[unstable(feature = \"ascii\")]\n     fn make_ascii_uppercase(&mut self);\n \n-    /// Convert this type to its ASCII lower case equivalent in-place.\n+    /// Converts this type to its ASCII lower case equivalent in-place.\n     ///\n     /// See `to_ascii_lowercase` for more information.\n     ///"}, {"sha": "f554a4f4ed6d185b9a5ba4f3ac12b8f482962d98", "filename": "src/libstd/collections/hash/map.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs?ref=16e1fcead14628701e1b10b9d00c898d748db2ed", "patch": "@@ -506,7 +506,7 @@ impl<K, V, S> HashMap<K, V, S>\n }\n \n impl<K: Hash + Eq, V> HashMap<K, V, RandomState> {\n-    /// Create an empty HashMap.\n+    /// Creates an empty HashMap.\n     ///\n     /// # Examples\n     ///\n@@ -563,7 +563,7 @@ impl<K, V, S> HashMap<K, V, S>\n         }\n     }\n \n-    /// Create an empty HashMap with space for at least `capacity`\n+    /// Creates an empty HashMap with space for at least `capacity`\n     /// elements, using `hasher` to hash the keys.\n     ///\n     /// Warning: `hasher` is normally randomly generated, and\n@@ -1596,7 +1596,7 @@ pub struct RandomState {\n #[unstable(feature = \"std_misc\",\n            reason = \"hashing an hash maps may be altered\")]\n impl RandomState {\n-    /// Construct a new `RandomState` that is initialized with random keys.\n+    /// Constructs a new `RandomState` that is initialized with random keys.\n     #[inline]\n     #[allow(deprecated)]\n     pub fn new() -> RandomState {\n@@ -1631,7 +1631,7 @@ mod test_map {\n     use super::Entry::{Occupied, Vacant};\n     use iter::{range_inclusive, range_step_inclusive, repeat};\n     use cell::RefCell;\n-    use rand::{weak_rng, Rng};\n+    use rand::{thread_rng, Rng};\n \n     #[test]\n     fn test_create_capacity_zero() {\n@@ -2290,7 +2290,7 @@ mod test_map {\n         }\n \n         let mut m = HashMap::new();\n-        let mut rng = weak_rng();\n+        let mut rng = thread_rng();\n \n         // Populate the map with some items.\n         for _ in 0..50 {"}, {"sha": "6b0546b1ee72f737c4e0cfa002afcb54d71e0d9a", "filename": "src/libstd/collections/hash/set.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs?ref=16e1fcead14628701e1b10b9d00c898d748db2ed", "patch": "@@ -111,7 +111,7 @@ pub struct HashSet<T, S = RandomState> {\n }\n \n impl<T: Hash + Eq> HashSet<T, RandomState> {\n-    /// Create an empty HashSet.\n+    /// Creates an empty HashSet.\n     ///\n     /// # Examples\n     ///\n@@ -125,7 +125,7 @@ impl<T: Hash + Eq> HashSet<T, RandomState> {\n         HashSet::with_capacity(INITIAL_CAPACITY)\n     }\n \n-    /// Create an empty HashSet with space for at least `n` elements in\n+    /// Creates an empty HashSet with space for at least `n` elements in\n     /// the hash table.\n     ///\n     /// # Examples\n@@ -166,7 +166,7 @@ impl<T, S> HashSet<T, S>\n         HashSet::with_capacity_and_hash_state(INITIAL_CAPACITY, hash_state)\n     }\n \n-    /// Create an empty HashSet with space for at least `capacity`\n+    /// Creates an empty HashSet with space for at least `capacity`\n     /// elements in the hash table, using `hasher` to hash the keys.\n     ///\n     /// Warning: `hasher` is normally randomly generated, and\n@@ -402,7 +402,7 @@ impl<T, S> HashSet<T, S>\n         Union { iter: self.iter().chain(other.difference(self)) }\n     }\n \n-    /// Return the number of elements in the set\n+    /// Returns the number of elements in the set.\n     ///\n     /// # Examples\n     ///\n@@ -417,7 +417,7 @@ impl<T, S> HashSet<T, S>\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn len(&self) -> usize { self.map.len() }\n \n-    /// Returns true if the set contains no elements\n+    /// Returns true if the set contains no elements.\n     ///\n     /// # Examples\n     ///"}, {"sha": "c69df6435c49889b8b1181963208ea3c186323e1", "filename": "src/libstd/dynamic_lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibstd%2Fdynamic_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibstd%2Fdynamic_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fdynamic_lib.rs?ref=16e1fcead14628701e1b10b9d00c898d748db2ed", "patch": "@@ -105,7 +105,7 @@ impl DynamicLibrary {\n         }\n     }\n \n-    /// Access the value at the symbol of the dynamic library\n+    /// Accesses the value at the symbol of the dynamic library.\n     pub unsafe fn symbol<T>(&self, symbol: &str) -> Result<*mut T, String> {\n         // This function should have a lifetime constraint of 'a on\n         // T but that feature is still unimplemented"}, {"sha": "bcc109a71cb0436970c93bec58574d734b1fc75b", "filename": "src/libstd/env.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibstd%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibstd%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fenv.rs?ref=16e1fcead14628701e1b10b9d00c898d748db2ed", "patch": "@@ -261,7 +261,7 @@ pub fn set_var<K: ?Sized, V: ?Sized>(k: &K, v: &V)\n     os_imp::setenv(k.as_ref(), v.as_ref())\n }\n \n-/// Remove an environment variable from the environment of the currently running process.\n+/// Removes an environment variable from the environment of the currently running process.\n ///\n /// # Examples\n ///"}, {"sha": "96087bf1183dfd6e686dc2e1b730e3061ac0149d", "filename": "src/libstd/error.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibstd%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibstd%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ferror.rs?ref=16e1fcead14628701e1b10b9d00c898d748db2ed", "patch": "@@ -122,10 +122,7 @@ impl Error for str::ParseBoolError {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Error for str::Utf8Error {\n     fn description(&self) -> &str {\n-        match *self {\n-            str::Utf8Error::TooShort => \"invalid utf-8: not enough bytes\",\n-            str::Utf8Error::InvalidByte(..) => \"invalid utf-8: corrupt contents\",\n-        }\n+        \"invalid utf-8: corrupt contents\"\n     }\n }\n "}, {"sha": "c1c05da4ee4b56767c6be4ec81661e4ec8d4fcd9", "filename": "src/libstd/ffi/c_str.rs", "status": "modified", "additions": 10, "deletions": 23, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibstd%2Fffi%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibstd%2Fffi%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fffi%2Fc_str.rs?ref=16e1fcead14628701e1b10b9d00c898d748db2ed", "patch": "@@ -18,8 +18,6 @@ use io;\n use iter::Iterator;\n use libc;\n use mem;\n-#[allow(deprecated)]\n-use old_io;\n use ops::Deref;\n use option::Option::{self, Some, None};\n use result::Result::{self, Ok, Err};\n@@ -133,7 +131,7 @@ pub struct CStr {\n pub struct NulError(usize, Vec<u8>);\n \n impl CString {\n-    /// Create a new C-compatible string from a container of bytes.\n+    /// Creates a new C-compatible string from a container of bytes.\n     ///\n     /// This method will consume the provided data and use the underlying bytes\n     /// to construct a new string, ensuring that there is a trailing 0 byte.\n@@ -169,11 +167,12 @@ impl CString {\n         }\n     }\n \n-    /// Create a C-compatible string from a byte vector without checking for\n+    /// Creates a C-compatible string from a byte vector without checking for\n     /// interior 0 bytes.\n     ///\n-    /// This method is equivalent to `from_vec` except that no runtime assertion\n-    /// is made that `v` contains no 0 bytes.\n+    /// This method is equivalent to `new` except that no runtime assertion\n+    /// is made that `v` contains no 0 bytes, and it requires an actual\n+    /// byte vector, not anyhting that can be converted to one with Into.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub unsafe fn from_vec_unchecked(mut v: Vec<u8>) -> CString {\n         v.push(0);\n@@ -215,7 +214,7 @@ impl fmt::Debug for CString {\n \n impl NulError {\n     /// Returns the position of the nul byte in the slice that was provided to\n-    /// `CString::from_vec`.\n+    /// `CString::new`.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn nul_position(&self) -> usize { self.0 }\n \n@@ -245,20 +244,8 @@ impl From<NulError> for io::Error {\n     }\n }\n \n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[allow(deprecated)]\n-impl From<NulError> for old_io::IoError {\n-    fn from(_: NulError) -> old_io::IoError {\n-        old_io::IoError {\n-            kind: old_io::IoErrorKind::InvalidInput,\n-            desc: \"data provided contains a nul byte\",\n-            detail: None\n-        }\n-    }\n-}\n-\n impl CStr {\n-    /// Cast a raw C string to a safe C string wrapper.\n+    /// Casts a raw C string to a safe C string wrapper.\n     ///\n     /// This function will cast the provided `ptr` to the `CStr` wrapper which\n     /// allows inspection and interoperation of non-owned C strings. This method\n@@ -301,7 +288,7 @@ impl CStr {\n         mem::transmute(slice::from_raw_parts(ptr, len as usize + 1))\n     }\n \n-    /// Return the inner pointer to this C string.\n+    /// Returns the inner pointer to this C string.\n     ///\n     /// The returned pointer will be valid for as long as `self` is and points\n     /// to a contiguous region of memory terminated with a 0 byte to represent\n@@ -311,7 +298,7 @@ impl CStr {\n         self.inner.as_ptr()\n     }\n \n-    /// Convert this C string to a byte slice.\n+    /// Converts this C string to a byte slice.\n     ///\n     /// This function will calculate the length of this string (which normally\n     /// requires a linear amount of work to be done) and then return the\n@@ -329,7 +316,7 @@ impl CStr {\n         &bytes[..bytes.len() - 1]\n     }\n \n-    /// Convert this C string to a byte slice containing the trailing 0 byte.\n+    /// Converts this C string to a byte slice containing the trailing 0 byte.\n     ///\n     /// This function is the equivalent of `to_bytes` except that it will retain\n     /// the trailing nul instead of chopping it off."}, {"sha": "99becb67a5a7a1e6a78eef3cdaaa2aaa1c6a42af", "filename": "src/libstd/ffi/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibstd%2Fffi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibstd%2Fffi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fffi%2Fmod.rs?ref=16e1fcead14628701e1b10b9d00c898d748db2ed", "patch": "@@ -25,6 +25,6 @@ mod os_str;\n /// Freely convertible to an `&OsStr` slice.\n #[unstable(feature = \"std_misc\")]\n pub trait AsOsStr {\n-    /// Convert to an `&OsStr` slice.\n+    /// Converts to an `&OsStr` slice.\n     fn as_os_str(&self) -> &OsStr;\n }"}, {"sha": "08b41915d9153930ff8ad4cfabb4a2d3dbeadd35", "filename": "src/libstd/ffi/os_str.rs", "status": "modified", "additions": 12, "deletions": 28, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibstd%2Fffi%2Fos_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibstd%2Fffi%2Fos_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fffi%2Fos_str.rs?ref=16e1fcead14628701e1b10b9d00c898d748db2ed", "patch": "@@ -42,7 +42,6 @@ use string::String;\n use ops;\n use cmp;\n use hash::{Hash, Hasher};\n-use old_path::{Path, GenericPath};\n use vec::Vec;\n \n use sys::os_str::{Buf, Slice};\n@@ -69,7 +68,7 @@ impl OsString {\n         OsString { inner: Buf::from_string(String::new()) }\n     }\n \n-    /// Construct an `OsString` from a byte sequence.\n+    /// Constructs an `OsString` from a byte sequence.\n     ///\n     /// # Platform behavior\n     ///\n@@ -94,21 +93,21 @@ impl OsString {\n         from_bytes_inner(bytes.into())\n     }\n \n-    /// Convert to an `OsStr` slice.\n+    /// Converts to an `OsStr` slice.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn as_os_str(&self) -> &OsStr {\n         self\n     }\n \n-    /// Convert the `OsString` into a `String` if it contains valid Unicode data.\n+    /// Converts the `OsString` into a `String` if it contains valid Unicode data.\n     ///\n     /// On failure, ownership of the original `OsString` is returned.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn into_string(self) -> Result<String, OsString> {\n         self.inner.into_string().map_err(|buf| OsString { inner: buf} )\n     }\n \n-    /// Extend the string with the given `&OsStr` slice.\n+    /// Extends the string with the given `&OsStr` slice.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn push<T: AsRef<OsStr>>(&mut self, s: T) {\n         self.inner.push_slice(&s.as_ref().inner)\n@@ -221,43 +220,43 @@ impl Hash for OsString {\n }\n \n impl OsStr {\n-    /// Coerce into an `OsStr` slice.\n+    /// Coerces into an `OsStr` slice.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn new<S: AsRef<OsStr> + ?Sized>(s: &S) -> &OsStr {\n         s.as_ref()\n     }\n \n-    /// Coerce directly from a `&str` slice to a `&OsStr` slice.\n+    /// Coerces directly from a `&str` slice to a `&OsStr` slice.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[deprecated(since = \"1.0.0\",\n                  reason = \"use `OsStr::new` instead\")]\n     pub fn from_str(s: &str) -> &OsStr {\n         unsafe { mem::transmute(Slice::from_str(s)) }\n     }\n \n-    /// Yield a `&str` slice if the `OsStr` is valid unicode.\n+    /// Yields a `&str` slice if the `OsStr` is valid unicode.\n     ///\n     /// This conversion may entail doing a check for UTF-8 validity.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn to_str(&self) -> Option<&str> {\n         self.inner.to_str()\n     }\n \n-    /// Convert an `OsStr` to a `Cow<str>`.\n+    /// Converts an `OsStr` to a `Cow<str>`.\n     ///\n     /// Any non-Unicode sequences are replaced with U+FFFD REPLACEMENT CHARACTER.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn to_string_lossy(&self) -> Cow<str> {\n         self.inner.to_string_lossy()\n     }\n \n-    /// Copy the slice into an owned `OsString`.\n+    /// Copies the slice into an owned `OsString`.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn to_os_string(&self) -> OsString {\n         OsString { inner: self.inner.to_owned() }\n     }\n \n-    /// Yield this `OsStr` as a byte slice.\n+    /// Yields this `OsStr` as a byte slice.\n     ///\n     /// # Platform behavior\n     ///\n@@ -275,7 +274,7 @@ impl OsStr {\n         }\n     }\n \n-    /// Create a `CString` containing this `OsStr` data.\n+    /// Creates a `CString` containing this `OsStr` data.\n     ///\n     /// Fails if the `OsStr` contains interior nulls.\n     ///\n@@ -287,7 +286,7 @@ impl OsStr {\n         self.to_bytes().and_then(|b| CString::new(b).ok())\n     }\n \n-    /// Get the underlying byte representation.\n+    /// Gets the underlying byte representation.\n     ///\n     /// Note: it is *crucial* that this API is private, to avoid\n     /// revealing the internal, platform-specific encodings.\n@@ -447,21 +446,6 @@ impl AsRef<OsStr> for String {\n     }\n }\n \n-#[allow(deprecated)]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[deprecated(since = \"1.0.0\", reason = \"trait is deprecated\")]\n-impl AsOsStr for Path {\n-    #[cfg(unix)]\n-    fn as_os_str(&self) -> &OsStr {\n-        unsafe { mem::transmute(self.as_vec()) }\n-    }\n-    #[cfg(windows)]\n-    fn as_os_str(&self) -> &OsStr {\n-        // currently .as_str() is actually infallible on windows\n-        OsStr::from_str(self.as_str().unwrap())\n-    }\n-}\n-\n impl FromInner<Buf> for OsString {\n     fn from_inner(buf: Buf) -> OsString {\n         OsString { inner: buf }"}, {"sha": "6e902a4739623ab87ba36027bd39e7575c9c4aa6", "filename": "src/libstd/fs.rs", "status": "modified", "additions": 16, "deletions": 15, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibstd%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibstd%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffs.rs?ref=16e1fcead14628701e1b10b9d00c898d748db2ed", "patch": "@@ -123,7 +123,7 @@ pub struct WalkDir {\n /// Opening a file for both reading and writing, as well as creating it if it\n /// doesn't exist:\n ///\n-/// ```\n+/// ```no_run\n /// use std::fs::OpenOptions;\n ///\n /// let file = OpenOptions::new()\n@@ -171,7 +171,7 @@ impl File {\n         OpenOptions::new().read(true).open(path)\n     }\n \n-    /// Open a file in write-only mode.\n+    /// Opens a file in write-only mode.\n     ///\n     /// This function will create a file if it does not exist,\n     /// and will truncate it if it does.\n@@ -201,7 +201,7 @@ impl File {\n         self.path.as_ref().map(|p| &**p)\n     }\n \n-    /// Attempt to sync all OS-internal metadata to disk.\n+    /// Attempts to sync all OS-internal metadata to disk.\n     ///\n     /// This function will attempt to ensure that all in-core data reaches the\n     /// filesystem before returning.\n@@ -362,7 +362,7 @@ impl OpenOptions {\n         OpenOptions(fs_imp::OpenOptions::new())\n     }\n \n-    /// Set the option for read access.\n+    /// Sets the option for read access.\n     ///\n     /// This option, when true, will indicate that the file should be\n     /// `read`-able if opened.\n@@ -379,7 +379,7 @@ impl OpenOptions {\n         self.0.read(read); self\n     }\n \n-    /// Set the option for write access.\n+    /// Sets the option for write access.\n     ///\n     /// This option, when true, will indicate that the file should be\n     /// `write`-able if opened.\n@@ -396,7 +396,7 @@ impl OpenOptions {\n         self.0.write(write); self\n     }\n \n-    /// Set the option for the append mode.\n+    /// Sets the option for the append mode.\n     ///\n     /// This option, when true, means that writes will append to a file instead\n     /// of overwriting previous contents.\n@@ -413,7 +413,7 @@ impl OpenOptions {\n         self.0.append(append); self\n     }\n \n-    /// Set the option for truncating a previous file.\n+    /// Sets the option for truncating a previous file.\n     ///\n     /// If a file is successfully opened with this option set it will truncate\n     /// the file to 0 length if it already exists.\n@@ -430,7 +430,7 @@ impl OpenOptions {\n         self.0.truncate(truncate); self\n     }\n \n-    /// Set the option for creating a new file.\n+    /// Sets the option for creating a new file.\n     ///\n     /// This option indicates whether a new file will be created if the file\n     /// does not yet already exist.\n@@ -447,7 +447,7 @@ impl OpenOptions {\n         self.0.create(create); self\n     }\n \n-    /// Open a file at `path` with the options specified by `self`.\n+    /// Opens a file at `path` with the options specified by `self`.\n     ///\n     /// # Errors\n     ///\n@@ -587,7 +587,7 @@ impl Permissions {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn readonly(&self) -> bool { self.0.readonly() }\n \n-    /// Modify the readonly flag for this set of permissions.\n+    /// Modifies the readonly flag for this set of permissions.\n     ///\n     /// This operation does **not** modify the filesystem. To modify the\n     /// filesystem use the `fs::set_permissions` function.\n@@ -670,7 +670,7 @@ impl DirEntry {\n     pub fn path(&self) -> PathBuf { self.0.path() }\n }\n \n-/// Remove a file from the underlying filesystem.\n+/// Removes a file from the underlying filesystem.\n ///\n /// Note that, just because an unlink call was successful, it is not\n /// guaranteed that a file is immediately deleted (e.g. depending on\n@@ -856,7 +856,7 @@ pub fn read_link<P: AsRef<Path>>(path: P) -> io::Result<PathBuf> {\n     fs_imp::readlink(path.as_ref())\n }\n \n-/// Create a new, empty directory at the provided path\n+/// Creates a new, empty directory at the provided path\n ///\n /// # Errors\n ///\n@@ -906,7 +906,7 @@ pub fn create_dir_all<P: AsRef<Path>>(path: P) -> io::Result<()> {\n     create_dir(path)\n }\n \n-/// Remove an existing, empty directory\n+/// Removes an existing, empty directory.\n ///\n /// # Errors\n ///\n@@ -1058,7 +1058,7 @@ impl Iterator for WalkDir {\n            reason = \"the precise set of methods exposed on this trait may \\\n                      change and some methods may be removed\")]\n pub trait PathExt {\n-    /// Get information on the file, directory, etc at this path.\n+    /// Gets information on the file, directory, etc at this path.\n     ///\n     /// Consult the `fs::stat` documentation for more info.\n     ///\n@@ -1195,7 +1195,8 @@ mod tests {\n \n     pub fn tmpdir() -> TempDir {\n         let p = env::temp_dir();\n-        let ret = p.join(&format!(\"rust-{}\", rand::random::<u32>()));\n+        let mut r = rand::thread_rng();\n+        let ret = p.join(&format!(\"rust-{}\", r.next_u32()));\n         check!(fs::create_dir(&ret));\n         TempDir(ret)\n     }"}, {"sha": "72743106abf6a24ac589e0c852b960d7159c952e", "filename": "src/libstd/io/cursor.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibstd%2Fio%2Fcursor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibstd%2Fio%2Fcursor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fcursor.rs?ref=16e1fcead14628701e1b10b9d00c898d748db2ed", "patch": "@@ -34,21 +34,21 @@ pub struct Cursor<T> {\n }\n \n impl<T> Cursor<T> {\n-    /// Create a new cursor wrapping the provided underlying I/O object.\n+    /// Creates a new cursor wrapping the provided underlying I/O object.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn new(inner: T) -> Cursor<T> {\n         Cursor { pos: 0, inner: inner }\n     }\n \n-    /// Consume this cursor, returning the underlying value.\n+    /// Consumes this cursor, returning the underlying value.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn into_inner(self) -> T { self.inner }\n \n-    /// Get a reference to the underlying value in this cursor.\n+    /// Gets a reference to the underlying value in this cursor.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn get_ref(&self) -> &T { &self.inner }\n \n-    /// Get a mutable reference to the underlying value in this cursor.\n+    /// Gets a mutable reference to the underlying value in this cursor.\n     ///\n     /// Care should be taken to avoid modifying the internal I/O state of the\n     /// underlying value as it may corrupt this cursor's position."}, {"sha": "a49039b1ec4ee808497ad20186006c19be57efed", "filename": "src/libstd/io/error.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibstd%2Fio%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibstd%2Fio%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ferror.rs?ref=16e1fcead14628701e1b10b9d00c898d748db2ed", "patch": "@@ -191,7 +191,7 @@ impl Error {\n         }\n     }\n \n-    /// Return the corresponding `ErrorKind` for this error.\n+    /// Returns the corresponding `ErrorKind` for this error.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn kind(&self) -> ErrorKind {\n         match self.repr {"}, {"sha": "f3ba5cd7854d967171f0c87c7bf1f3b8fbda929e", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 10, "deletions": 13, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=16e1fcead14628701e1b10b9d00c898d748db2ed", "patch": "@@ -172,14 +172,11 @@ pub trait Read {\n     /// Read all bytes until EOF in this source, placing them into `buf`.\n     ///\n     /// All bytes read from this source will be appended to the specified buffer\n-    /// `buf`. This function will return a call to `read` either:\n+    /// `buf`. This function will continuously call `read` to append more data to\n+    /// `buf` until `read` returns either `Ok(0)` or an error of\n+    /// non-`ErrorKind::Interrupted` kind.\n     ///\n-    /// 1. Returns `Ok(0)`.\n-    /// 2. Returns an error which is not of the kind `ErrorKind::Interrupted`.\n-    ///\n-    /// Until one of these conditions is met the function will continuously\n-    /// invoke `read` to append more data to `buf`. If successful, this function\n-    /// will return the total number of bytes read.\n+    /// If successful, this function will return the total number of bytes read.\n     ///\n     /// # Errors\n     ///\n@@ -220,14 +217,14 @@ pub trait Read {\n         append_to_string(buf, |b| read_to_end(self, b))\n     }\n \n-    /// Create a \"by reference\" adaptor for this instance of `Read`.\n+    /// Creates a \"by reference\" adaptor for this instance of `Read`.\n     ///\n     /// The returned adaptor also implements `Read` and will simply borrow this\n     /// current reader.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn by_ref(&mut self) -> &mut Self where Self: Sized { self }\n \n-    /// Transform this `Read` instance to an `Iterator` over its bytes.\n+    /// Transforms this `Read` instance to an `Iterator` over its bytes.\n     ///\n     /// The returned type implements `Iterator` where the `Item` is `Result<u8,\n     /// R::Err>`.  The yielded item is `Ok` if a byte was successfully read and\n@@ -238,7 +235,7 @@ pub trait Read {\n         Bytes { inner: self }\n     }\n \n-    /// Transform this `Read` instance to an `Iterator` over `char`s.\n+    /// Transforms this `Read` instance to an `Iterator` over `char`s.\n     ///\n     /// This adaptor will attempt to interpret this reader as an UTF-8 encoded\n     /// sequence of characters. The returned iterator will return `None` once\n@@ -255,7 +252,7 @@ pub trait Read {\n         Chars { inner: self }\n     }\n \n-    /// Create an adaptor which will chain this stream with another.\n+    /// Creates an adaptor which will chain this stream with another.\n     ///\n     /// The returned `Read` instance will first read all bytes from this object\n     /// until EOF is encountered. Afterwards the output is equivalent to the\n@@ -265,7 +262,7 @@ pub trait Read {\n         Chain { first: self, second: next, done_first: false }\n     }\n \n-    /// Create an adaptor which will read at most `limit` bytes from it.\n+    /// Creates an adaptor which will read at most `limit` bytes from it.\n     ///\n     /// This function returns a new instance of `Read` which will read at most\n     /// `limit` bytes, after which it will always return EOF (`Ok(0)`). Any\n@@ -406,7 +403,7 @@ pub trait Write {\n         }\n     }\n \n-    /// Create a \"by reference\" adaptor for this instance of `Write`.\n+    /// Creates a \"by reference\" adaptor for this instance of `Write`.\n     ///\n     /// The returned adaptor also implements `Write` and will simply borrow this\n     /// current writer."}, {"sha": "cd6af77daa9061e00c094979d9bad3f64dc00c45", "filename": "src/libstd/io/stdio.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibstd%2Fio%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibstd%2Fio%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fstdio.rs?ref=16e1fcead14628701e1b10b9d00c898d748db2ed", "patch": "@@ -45,7 +45,7 @@ struct StdoutRaw(stdio::Stdout);\n /// the `std::io::stdio::stderr_raw` function.\n struct StderrRaw(stdio::Stderr);\n \n-/// Construct a new raw handle to the standard input of this process.\n+/// Constructs a new raw handle to the standard input of this process.\n ///\n /// The returned handle does not interact with any other handles created nor\n /// handles returned by `std::io::stdin`. Data buffered by the `std::io::stdin`\n@@ -54,7 +54,7 @@ struct StderrRaw(stdio::Stderr);\n /// The returned handle has no external synchronization or buffering.\n fn stdin_raw() -> StdinRaw { StdinRaw(stdio::Stdin::new()) }\n \n-/// Construct a new raw handle to the standard input stream of this process.\n+/// Constructs a new raw handle to the standard input stream of this process.\n ///\n /// The returned handle does not interact with any other handles created nor\n /// handles returned by `std::io::stdout`. Note that data is buffered by the\n@@ -65,7 +65,7 @@ fn stdin_raw() -> StdinRaw { StdinRaw(stdio::Stdin::new()) }\n /// top.\n fn stdout_raw() -> StdoutRaw { StdoutRaw(stdio::Stdout::new()) }\n \n-/// Construct a new raw handle to the standard input stream of this process.\n+/// Constructs a new raw handle to the standard input stream of this process.\n ///\n /// The returned handle does not interact with any other handles created nor\n /// handles returned by `std::io::stdout`.\n@@ -109,7 +109,7 @@ pub struct StdinLock<'a> {\n     inner: MutexGuard<'a, BufReader<StdinRaw>>,\n }\n \n-/// Create a new handle to the global standard input stream of this process.\n+/// Creates a new handle to the global standard input stream of this process.\n ///\n /// The handle returned refers to a globally shared buffer between all threads.\n /// Access is synchronized and can be explicitly controlled with the `lock()`\n@@ -139,7 +139,7 @@ pub fn stdin() -> Stdin {\n }\n \n impl Stdin {\n-    /// Lock this handle to the standard input stream, returning a readable\n+    /// Locks this handle to the standard input stream, returning a readable\n     /// guard.\n     ///\n     /// The lock is released when the returned lock goes out of scope. The\n@@ -243,7 +243,7 @@ pub fn stdout() -> Stdout {\n }\n \n impl Stdout {\n-    /// Lock this handle to the standard output stream, returning a writable\n+    /// Locks this handle to the standard output stream, returning a writable\n     /// guard.\n     ///\n     /// The lock is released when the returned lock goes out of scope. The\n@@ -315,7 +315,7 @@ pub fn stderr() -> Stderr {\n }\n \n impl Stderr {\n-    /// Lock this handle to the standard error stream, returning a writable\n+    /// Locks this handle to the standard error stream, returning a writable\n     /// guard.\n     ///\n     /// The lock is released when the returned lock goes out of scope. The"}, {"sha": "b2bcbaa7b1c2b212cdca06ef2283915d069c5629", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=16e1fcead14628701e1b10b9d00c898d748db2ed", "patch": "@@ -262,12 +262,9 @@ pub mod ffi;\n pub mod fs;\n pub mod io;\n pub mod net;\n-pub mod old_io;\n-pub mod old_path;\n pub mod os;\n pub mod path;\n pub mod process;\n-pub mod rand;\n pub mod sync;\n pub mod time;\n \n@@ -281,6 +278,18 @@ pub mod time;\n \n pub mod rt;\n mod panicking;\n+mod rand;\n+\n+// Some external utilities of the standard library rely on randomness (aka\n+// rustc_back::TempDir and tests) and need a way to get at the OS rng we've got\n+// here. This module is not at all intended for stabilization as-is, however,\n+// but it may be stabilized long-term. As a result we're exposing a hidden,\n+// unstable module so we can get our build working.\n+#[doc(hidden)]\n+#[unstable(feature = \"rand\")]\n+pub mod __rand {\n+    pub use rand::{thread_rng, ThreadRng, Rng};\n+}\n \n // Modules that exist purely to document + host impl docs for primitive types\n \n@@ -297,8 +306,6 @@ mod std {\n     pub use sync; // used for select!()\n     pub use error; // used for try!()\n     pub use fmt; // used for any formatting strings\n-    #[allow(deprecated)]\n-    pub use old_io; // used for println!()\n     pub use option; // used for bitflags!{}\n     pub use rt; // used for panic!()\n     pub use vec; // used for vec![]"}, {"sha": "05a3ca9194851bde5f262ef6f9dff351a201b8e5", "filename": "src/libstd/net/addr.rs", "status": "modified", "additions": 16, "deletions": 13, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibstd%2Fnet%2Faddr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibstd%2Fnet%2Faddr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Faddr.rs?ref=16e1fcead14628701e1b10b9d00c898d748db2ed", "patch": "@@ -615,7 +615,7 @@ mod tests {\n     fn ipv4_properties() {\n         fn check(octets: &[u8; 4], unspec: bool, loopback: bool,\n                  private: bool, link_local: bool, global: bool,\n-                 multicast: bool) {\n+                 multicast: bool, broadcast: bool, documentation: bool) {\n             let ip = Ipv4Addr::new(octets[0], octets[1], octets[2], octets[3]);\n             assert_eq!(octets, &ip.octets());\n \n@@ -625,20 +625,23 @@ mod tests {\n             assert_eq!(ip.is_link_local(), link_local);\n             assert_eq!(ip.is_global(), global);\n             assert_eq!(ip.is_multicast(), multicast);\n+            assert_eq!(ip.is_broadcast(), broadcast);\n+            assert_eq!(ip.is_documentation(), documentation);\n         }\n \n-        //    address                unspec loopbk privt  linloc global multicast\n-        check(&[0, 0, 0, 0],         true,  false, false, false, true,  false);\n-        check(&[0, 0, 0, 1],         false, false, false, false, true,  false);\n-        check(&[1, 0, 0, 0],         false, false, false, false, true,  false);\n-        check(&[10, 9, 8, 7],        false, false, true,  false, false, false);\n-        check(&[127, 1, 2, 3],       false, true,  false, false, false, false);\n-        check(&[172, 31, 254, 253],  false, false, true,  false, false,  false);\n-        check(&[169, 254, 253, 242], false, false, false, true,  false, false);\n-        check(&[192, 168, 254, 253], false, false, true,  false, false, false);\n-        check(&[224, 0, 0, 0],       false, false, false, false, true,  true);\n-        check(&[239, 255, 255, 255], false, false, false, false, true,  true);\n-        check(&[255, 255, 255, 255], false, false, false, false, true,  false);\n+        //    address                unspec loopbk privt  linloc global multicast brdcast doc\n+        check(&[0, 0, 0, 0],         true,  false, false, false, true,  false,    false,  false);\n+        check(&[0, 0, 0, 1],         false, false, false, false, true,  false,    false,  false);\n+        check(&[1, 0, 0, 0],         false, false, false, false, true,  false,    false,  false);\n+        check(&[10, 9, 8, 7],        false, false, true,  false, false, false,    false,  false);\n+        check(&[127, 1, 2, 3],       false, true,  false, false, false, false,    false,  false);\n+        check(&[172, 31, 254, 253],  false, false, true,  false, false, false,    false,  false);\n+        check(&[169, 254, 253, 242], false, false, false, true,  false, false,    false,  false);\n+        check(&[192, 168, 254, 253], false, false, true,  false, false, false,    false,  false);\n+        check(&[224, 0, 0, 0],       false, false, false, false, true,  true,     false,  false);\n+        check(&[239, 255, 255, 255], false, false, false, false, true,  true,     false,  false);\n+        check(&[255, 255, 255, 255], false, false, false, false, false, false,    true,  false);\n+        check(&[198, 51, 100, 0],    false, false, false, false, false, false,    false,  true);\n     }\n \n     #[test]"}, {"sha": "0e493b271f98f6da93e84d74b597ea8d68b512f1", "filename": "src/libstd/net/ip.rs", "status": "modified", "additions": 33, "deletions": 8, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibstd%2Fnet%2Fip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibstd%2Fnet%2Fip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Fip.rs?ref=16e1fcead14628701e1b10b9d00c898d748db2ed", "patch": "@@ -58,7 +58,7 @@ pub enum Ipv6MulticastScope {\n }\n \n impl Ipv4Addr {\n-    /// Create a new IPv4 address from four eight-bit octets.\n+    /// Creates a new IPv4 address from four eight-bit octets.\n     ///\n     /// The result will represent the IP address a.b.c.d\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -115,9 +115,11 @@ impl Ipv4Addr {\n     ///\n     /// Non-globally-routable networks include the private networks (10.0.0.0/8,\n     /// 172.16.0.0/12 and 192.168.0.0/16), the loopback network (127.0.0.0/8),\n-    /// and the link-local network (169.254.0.0/16).\n+    /// the link-local network (169.254.0.0/16), the broadcast address (255.255.255.255/32) and\n+    /// the test networks used for documentation (192.0.2.0/24, 198.51.100.0/24 and 203.0.113.0/24)\n     pub fn is_global(&self) -> bool {\n-        !self.is_private() && !self.is_loopback() && !self.is_link_local()\n+        !self.is_private() && !self.is_loopback() && !self.is_link_local() &&\n+        !self.is_broadcast() && !self.is_documentation()\n     }\n \n     /// Returns true if this is a multicast address.\n@@ -127,7 +129,30 @@ impl Ipv4Addr {\n         self.octets()[0] >= 224 && self.octets()[0] <= 239\n     }\n \n-    /// Convert this address to an IPv4-compatible IPv6 address\n+    /// Returns true if this is a broadcast address.\n+    ///\n+    /// A broadcast address has all octets set to 255 as defined in RFC 919\n+    pub fn is_broadcast(&self) -> bool {\n+        self.octets()[0] == 255 && self.octets()[1] == 255 &&\n+        self.octets()[2] == 255 && self.octets()[3] == 255\n+    }\n+\n+    /// Returns true if this address is in a range designated for documentation\n+    ///\n+    /// This is defined in RFC 5737\n+    /// - 192.0.2.0/24 (TEST-NET-1)\n+    /// - 198.51.100.0/24 (TEST-NET-2)\n+    /// - 203.0.113.0/24 (TEST-NET-3)\n+    pub fn is_documentation(&self) -> bool {\n+        match(self.octets()[0], self.octets()[1], self.octets()[2], self.octets()[3]) {\n+            (192, _, 2, _) => true,\n+            (198, 51, 100, _) => true,\n+            (203, _, 113, _) => true,\n+            _ => false\n+        }\n+    }\n+\n+    /// Converts this address to an IPv4-compatible IPv6 address\n     ///\n     /// a.b.c.d becomes ::a.b.c.d\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -137,7 +162,7 @@ impl Ipv4Addr {\n                       ((self.octets()[2] as u16) << 8) | self.octets()[3] as u16)\n     }\n \n-    /// Convert this address to an IPv4-mapped IPv6 address\n+    /// Converts this address to an IPv4-mapped IPv6 address\n     ///\n     /// a.b.c.d becomes ::ffff:a.b.c.d\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -220,7 +245,7 @@ impl FromInner<libc::in_addr> for Ipv4Addr {\n }\n \n impl Ipv6Addr {\n-    /// Create a new IPv6 address from eight 16-bit segments.\n+    /// Creates a new IPv6 address from eight 16-bit segments.\n     ///\n     /// The result will represent the IP address a:b:c:d:e:f:g:h\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -234,7 +259,7 @@ impl Ipv6Addr {\n         }\n     }\n \n-    /// Return the eight 16-bit segments that make up this address\n+    /// Returns the eight 16-bit segments that make up this address\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn segments(&self) -> [u16; 8] {\n         [ntoh(self.inner.s6_addr[0]),\n@@ -324,7 +349,7 @@ impl Ipv6Addr {\n         (self.segments()[0] & 0xff00) == 0xff00\n     }\n \n-    /// Convert this address to an IPv4 address. Returns None if this address is\n+    /// Converts this address to an IPv4 address. Returns None if this address is\n     /// neither IPv4-compatible or IPv4-mapped.\n     ///\n     /// ::a.b.c.d and ::ffff:a.b.c.d become a.b.c.d"}, {"sha": "209a0032fb4419712fa2875eefd38a590971953d", "filename": "src/libstd/net/tcp.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibstd%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibstd%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Ftcp.rs?ref=16e1fcead14628701e1b10b9d00c898d748db2ed", "patch": "@@ -82,7 +82,7 @@ pub struct TcpListener(net_imp::TcpListener);\n pub struct Incoming<'a> { listener: &'a TcpListener }\n \n impl TcpStream {\n-    /// Open a TCP connection to a remote host.\n+    /// Opens a TCP connection to a remote host.\n     ///\n     /// `addr` is an address of the remote host. Anything which implements\n     /// `ToSocketAddrs` trait can be supplied for the address; see this trait\n@@ -104,7 +104,7 @@ impl TcpStream {\n         self.0.socket_addr()\n     }\n \n-    /// Shut down the read, write, or both halves of this connection.\n+    /// Shuts down the read, write, or both halves of this connection.\n     ///\n     /// This function will cause all pending and future I/O on the specified\n     /// portions to return immediately with an appropriate value (see the\n@@ -114,7 +114,7 @@ impl TcpStream {\n         self.0.shutdown(how)\n     }\n \n-    /// Create a new independently owned handle to the underlying socket.\n+    /// Creates a new independently owned handle to the underlying socket.\n     ///\n     /// The returned `TcpStream` is a reference to the same stream that this\n     /// object references. Both handles will read and write the same stream of\n@@ -190,7 +190,7 @@ impl TcpListener {\n         self.0.socket_addr()\n     }\n \n-    /// Create a new independently owned handle to the underlying socket.\n+    /// Creates a new independently owned handle to the underlying socket.\n     ///\n     /// The returned `TcpListener` is a reference to the same socket that this\n     /// object references. Both handles can be used to accept incoming"}, {"sha": "1955b895300ead37b634f3e191f32129b284396e", "filename": "src/libstd/net/udp.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibstd%2Fnet%2Fudp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibstd%2Fnet%2Fudp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Fudp.rs?ref=16e1fcead14628701e1b10b9d00c898d748db2ed", "patch": "@@ -85,7 +85,7 @@ impl UdpSocket {\n         self.0.socket_addr()\n     }\n \n-    /// Create a new independently owned handle to the underlying socket.\n+    /// Creates a new independently owned handle to the underlying socket.\n     ///\n     /// The returned `UdpSocket` is a reference to the same socket that this\n     /// object references. Both handles will read and write the same port, and\n@@ -100,7 +100,7 @@ impl UdpSocket {\n         self.0.set_broadcast(on)\n     }\n \n-    /// Set the multicast loop flag to the specified value\n+    /// Sets the multicast loop flag to the specified value\n     ///\n     /// This lets multicast packets loop back to local sockets (if enabled)\n     pub fn set_multicast_loop(&self, on: bool) -> io::Result<()> {"}, {"sha": "736f6d2f4f4f834f96894ff98161b1b6ffffef01", "filename": "src/libstd/num/f32.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibstd%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibstd%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff32.rs?ref=16e1fcead14628701e1b10b9d00c898d748db2ed", "patch": "@@ -527,7 +527,7 @@ impl f32 {\n     #[inline]\n     pub fn round(self) -> f32 { num::Float::round(self) }\n \n-    /// Return the integer part of a number.\n+    /// Returns the integer part of a number.\n     ///\n     /// ```\n     /// let f = 3.3_f32;\n@@ -666,7 +666,7 @@ impl f32 {\n     #[inline]\n     pub fn mul_add(self, a: f32, b: f32) -> f32 { num::Float::mul_add(self, a, b) }\n \n-    /// Take the reciprocal (inverse) of a number, `1/x`.\n+    /// Takes the reciprocal (inverse) of a number, `1/x`.\n     ///\n     /// ```\n     /// use std::f32;\n@@ -680,7 +680,7 @@ impl f32 {\n     #[inline]\n     pub fn recip(self) -> f32 { num::Float::recip(self) }\n \n-    /// Raise a number to an integer power.\n+    /// Raises a number to an integer power.\n     ///\n     /// Using this function is generally faster than using `powf`\n     ///\n@@ -696,7 +696,7 @@ impl f32 {\n     #[inline]\n     pub fn powi(self, n: i32) -> f32 { num::Float::powi(self, n) }\n \n-    /// Raise a number to a floating point power.\n+    /// Raises a number to a floating point power.\n     ///\n     /// ```\n     /// use std::f32;\n@@ -710,7 +710,7 @@ impl f32 {\n     #[inline]\n     pub fn powf(self, n: f32) -> f32 { num::Float::powf(self, n) }\n \n-    /// Take the square root of a number.\n+    /// Takes the square root of a number.\n     ///\n     /// Returns NaN if `self` is a negative number.\n     ///\n@@ -729,7 +729,7 @@ impl f32 {\n     #[inline]\n     pub fn sqrt(self) -> f32 { num::Float::sqrt(self) }\n \n-    /// Take the reciprocal (inverse) square root of a number, `1/sqrt(x)`.\n+    /// Takes the reciprocal (inverse) square root of a number, `1/sqrt(x)`.\n     ///\n     /// ```\n     /// # #![feature(std_misc)]\n@@ -852,7 +852,7 @@ impl f32 {\n     #[inline]\n     pub fn log10(self) -> f32 { num::Float::log10(self) }\n \n-    /// Convert radians to degrees.\n+    /// Converts radians to degrees.\n     ///\n     /// ```\n     /// # #![feature(std_misc)]\n@@ -868,7 +868,7 @@ impl f32 {\n     #[inline]\n     pub fn to_degrees(self) -> f32 { num::Float::to_degrees(self) }\n \n-    /// Convert degrees to radians.\n+    /// Converts degrees to radians.\n     ///\n     /// ```\n     /// # #![feature(std_misc)]\n@@ -1003,7 +1003,7 @@ impl f32 {\n         unsafe { cmath::fdimf(self, other) }\n     }\n \n-    /// Take the cubic root of a number.\n+    /// Takes the cubic root of a number.\n     ///\n     /// ```\n     /// use std::f32;\n@@ -1021,7 +1021,7 @@ impl f32 {\n         unsafe { cmath::cbrtf(self) }\n     }\n \n-    /// Calculate the length of the hypotenuse of a right-angle triangle given\n+    /// Calculates the length of the hypotenuse of a right-angle triangle given\n     /// legs of length `x` and `y`.\n     ///\n     /// ```"}, {"sha": "bb9067eca13dd85557bf6d88f75a26c126bedd51", "filename": "src/libstd/num/f64.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibstd%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibstd%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff64.rs?ref=16e1fcead14628701e1b10b9d00c898d748db2ed", "patch": "@@ -534,7 +534,7 @@ impl f64 {\n     #[inline]\n     pub fn round(self) -> f64 { num::Float::round(self) }\n \n-    /// Return the integer part of a number.\n+    /// Returns the integer part of a number.\n     ///\n     /// ```\n     /// let f = 3.3_f64;\n@@ -671,7 +671,7 @@ impl f64 {\n     #[inline]\n     pub fn mul_add(self, a: f64, b: f64) -> f64 { num::Float::mul_add(self, a, b) }\n \n-    /// Take the reciprocal (inverse) of a number, `1/x`.\n+    /// Takes the reciprocal (inverse) of a number, `1/x`.\n     ///\n     /// ```\n     /// let x = 2.0_f64;\n@@ -683,7 +683,7 @@ impl f64 {\n     #[inline]\n     pub fn recip(self) -> f64 { num::Float::recip(self) }\n \n-    /// Raise a number to an integer power.\n+    /// Raises a number to an integer power.\n     ///\n     /// Using this function is generally faster than using `powf`\n     ///\n@@ -697,7 +697,7 @@ impl f64 {\n     #[inline]\n     pub fn powi(self, n: i32) -> f64 { num::Float::powi(self, n) }\n \n-    /// Raise a number to a floating point power.\n+    /// Raises a number to a floating point power.\n     ///\n     /// ```\n     /// let x = 2.0_f64;\n@@ -709,7 +709,7 @@ impl f64 {\n     #[inline]\n     pub fn powf(self, n: f64) -> f64 { num::Float::powf(self, n) }\n \n-    /// Take the square root of a number.\n+    /// Takes the square root of a number.\n     ///\n     /// Returns NaN if `self` is a negative number.\n     ///\n@@ -726,7 +726,7 @@ impl f64 {\n     #[inline]\n     pub fn sqrt(self) -> f64 { num::Float::sqrt(self) }\n \n-    /// Take the reciprocal (inverse) square root of a number, `1/sqrt(x)`.\n+    /// Takes the reciprocal (inverse) square root of a number, `1/sqrt(x)`.\n     ///\n     /// ```\n     /// # #![feature(std_misc)]\n@@ -835,7 +835,7 @@ impl f64 {\n     #[inline]\n     pub fn log10(self) -> f64 { num::Float::log10(self) }\n \n-    /// Convert radians to degrees.\n+    /// Converts radians to degrees.\n     ///\n     /// ```\n     /// use std::f64::consts;\n@@ -850,7 +850,7 @@ impl f64 {\n     #[inline]\n     pub fn to_degrees(self) -> f64 { num::Float::to_degrees(self) }\n \n-    /// Convert degrees to radians.\n+    /// Converts degrees to radians.\n     ///\n     /// ```\n     /// use std::f64::consts;\n@@ -978,7 +978,7 @@ impl f64 {\n         unsafe { cmath::fdim(self, other) }\n     }\n \n-    /// Take the cubic root of a number.\n+    /// Takes the cubic root of a number.\n     ///\n     /// ```\n     /// let x = 8.0_f64;\n@@ -994,7 +994,7 @@ impl f64 {\n         unsafe { cmath::cbrt(self) }\n     }\n \n-    /// Calculate the length of the hypotenuse of a right-angle triangle given\n+    /// Calculates the length of the hypotenuse of a right-angle triangle given\n     /// legs of length `x` and `y`.\n     ///\n     /// ```"}, {"sha": "e0b9c720dbbed82b9be59c9e95ffd81df227ee33", "filename": "src/libstd/num/mod.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibstd%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibstd%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fmod.rs?ref=16e1fcead14628701e1b10b9d00c898d748db2ed", "patch": "@@ -383,7 +383,7 @@ pub trait Float\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn round(self) -> Self;\n-    /// Return the integer part of a number.\n+    /// Returns the integer part of a number.\n     ///\n     /// ```\n     /// use std::num::Float;\n@@ -509,7 +509,7 @@ pub trait Float\n     #[unstable(feature = \"std_misc\",\n                reason = \"unsure about its place in the world\")]\n     fn mul_add(self, a: Self, b: Self) -> Self;\n-    /// Take the reciprocal (inverse) of a number, `1/x`.\n+    /// Takes the reciprocal (inverse) of a number, `1/x`.\n     ///\n     /// ```\n     /// # #![feature(std_misc)]\n@@ -524,7 +524,7 @@ pub trait Float\n                reason = \"unsure about its place in the world\")]\n     fn recip(self) -> Self;\n \n-    /// Raise a number to an integer power.\n+    /// Raises a number to an integer power.\n     ///\n     /// Using this function is generally faster than using `powf`\n     ///\n@@ -538,7 +538,7 @@ pub trait Float\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn powi(self, n: i32) -> Self;\n-    /// Raise a number to a floating point power.\n+    /// Raises a number to a floating point power.\n     ///\n     /// ```\n     /// use std::num::Float;\n@@ -550,7 +550,7 @@ pub trait Float\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn powf(self, n: Self) -> Self;\n-    /// Take the square root of a number.\n+    /// Takes the square root of a number.\n     ///\n     /// Returns NaN if `self` is a negative number.\n     ///\n@@ -569,7 +569,7 @@ pub trait Float\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn sqrt(self) -> Self;\n \n-    /// Take the reciprocal (inverse) square root of a number, `1/sqrt(x)`.\n+    /// Takes the reciprocal (inverse) square root of a number, `1/sqrt(x)`.\n     ///\n     /// ```\n     /// # #![feature(std_misc)]\n@@ -679,7 +679,7 @@ pub trait Float\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn log10(self) -> Self;\n \n-    /// Convert radians to degrees.\n+    /// Converts radians to degrees.\n     ///\n     /// ```\n     /// use std::num::Float;\n@@ -693,7 +693,7 @@ pub trait Float\n     /// ```\n     #[unstable(feature = \"std_misc\", reason = \"desirability is unclear\")]\n     fn to_degrees(self) -> Self;\n-    /// Convert degrees to radians.\n+    /// Converts degrees to radians.\n     ///\n     /// ```\n     /// # #![feature(std_misc)]\n@@ -807,7 +807,7 @@ pub trait Float\n     /// ```\n     #[unstable(feature = \"std_misc\", reason = \"may be renamed\")]\n     fn abs_sub(self, other: Self) -> Self;\n-    /// Take the cubic root of a number.\n+    /// Takes the cubic root of a number.\n     ///\n     /// ```\n     /// # #![feature(std_misc)]\n@@ -822,7 +822,7 @@ pub trait Float\n     /// ```\n     #[unstable(feature = \"std_misc\", reason = \"may be renamed\")]\n     fn cbrt(self) -> Self;\n-    /// Calculate the length of the hypotenuse of a right-angle triangle given\n+    /// Calculates the length of the hypotenuse of a right-angle triangle given\n     /// legs of length `x` and `y`.\n     ///\n     /// ```"}, {"sha": "8ab66f2328fb6f837d2e2361fda5fb5487d5edbe", "filename": "src/libstd/num/strconv.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibstd%2Fnum%2Fstrconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibstd%2Fnum%2Fstrconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fstrconv.rs?ref=16e1fcead14628701e1b10b9d00c898d748db2ed", "patch": "@@ -464,7 +464,7 @@ mod bench {\n \n     mod usize {\n         use super::test::Bencher;\n-        use rand::{weak_rng, Rng};\n+        use rand::{thread_rng, Rng};\n         use std::fmt;\n \n         #[inline]\n@@ -474,38 +474,38 @@ mod bench {\n \n         #[bench]\n         fn to_str_bin(b: &mut Bencher) {\n-            let mut rng = weak_rng();\n+            let mut rng = thread_rng();\n             b.iter(|| { to_string(rng.gen::<usize>(), 2); })\n         }\n \n         #[bench]\n         fn to_str_oct(b: &mut Bencher) {\n-            let mut rng = weak_rng();\n+            let mut rng = thread_rng();\n             b.iter(|| { to_string(rng.gen::<usize>(), 8); })\n         }\n \n         #[bench]\n         fn to_str_dec(b: &mut Bencher) {\n-            let mut rng = weak_rng();\n+            let mut rng = thread_rng();\n             b.iter(|| { to_string(rng.gen::<usize>(), 10); })\n         }\n \n         #[bench]\n         fn to_str_hex(b: &mut Bencher) {\n-            let mut rng = weak_rng();\n+            let mut rng = thread_rng();\n             b.iter(|| { to_string(rng.gen::<usize>(), 16); })\n         }\n \n         #[bench]\n         fn to_str_base_36(b: &mut Bencher) {\n-            let mut rng = weak_rng();\n+            let mut rng = thread_rng();\n             b.iter(|| { to_string(rng.gen::<usize>(), 36); })\n         }\n     }\n \n     mod isize {\n         use super::test::Bencher;\n-        use rand::{weak_rng, Rng};\n+        use rand::{thread_rng, Rng};\n         use std::fmt;\n \n         #[inline]\n@@ -515,43 +515,43 @@ mod bench {\n \n         #[bench]\n         fn to_str_bin(b: &mut Bencher) {\n-            let mut rng = weak_rng();\n+            let mut rng = thread_rng();\n             b.iter(|| { to_string(rng.gen::<isize>(), 2); })\n         }\n \n         #[bench]\n         fn to_str_oct(b: &mut Bencher) {\n-            let mut rng = weak_rng();\n+            let mut rng = thread_rng();\n             b.iter(|| { to_string(rng.gen::<isize>(), 8); })\n         }\n \n         #[bench]\n         fn to_str_dec(b: &mut Bencher) {\n-            let mut rng = weak_rng();\n+            let mut rng = thread_rng();\n             b.iter(|| { to_string(rng.gen::<isize>(), 10); })\n         }\n \n         #[bench]\n         fn to_str_hex(b: &mut Bencher) {\n-            let mut rng = weak_rng();\n+            let mut rng = thread_rng();\n             b.iter(|| { to_string(rng.gen::<isize>(), 16); })\n         }\n \n         #[bench]\n         fn to_str_base_36(b: &mut Bencher) {\n-            let mut rng = weak_rng();\n+            let mut rng = thread_rng();\n             b.iter(|| { to_string(rng.gen::<isize>(), 36); })\n         }\n     }\n \n     mod f64 {\n         use super::test::Bencher;\n-        use rand::{weak_rng, Rng};\n+        use rand::{thread_rng, Rng};\n         use f64;\n \n         #[bench]\n         fn float_to_string(b: &mut Bencher) {\n-            let mut rng = weak_rng();\n+            let mut rng = thread_rng();\n             b.iter(|| { f64::to_string(rng.gen()); })\n         }\n     }"}, {"sha": "68aa7e4770f067e3cada0738e0256ac7381d242a", "filename": "src/libstd/old_io/buffered.rs", "status": "removed", "additions": 0, "deletions": 702, "changes": 702, "blob_url": "https://github.com/rust-lang/rust/blob/8415fa27877a4309a79b08c75a52eb4c3546b7a5/src%2Flibstd%2Fold_io%2Fbuffered.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8415fa27877a4309a79b08c75a52eb4c3546b7a5/src%2Flibstd%2Fold_io%2Fbuffered.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fbuffered.rs?ref=8415fa27877a4309a79b08c75a52eb4c3546b7a5", "patch": "@@ -1,702 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-//\n-// ignore-lexer-test FIXME #15883\n-\n-//! Buffering wrappers for I/O traits\n-\n-use cmp;\n-use fmt;\n-use old_io::{Reader, Writer, Stream, Buffer, DEFAULT_BUF_SIZE, IoResult};\n-use iter::{Iterator, ExactSizeIterator, repeat};\n-use ops::Drop;\n-use option::Option;\n-use option::Option::{Some, None};\n-use result::Result::Ok;\n-use slice;\n-use vec::Vec;\n-\n-/// Wraps a Reader and buffers input from it\n-///\n-/// It can be excessively inefficient to work directly with a `Reader`. For\n-/// example, every call to `read` on `TcpStream` results in a system call. A\n-/// `BufferedReader` performs large, infrequent reads on the underlying\n-/// `Reader` and maintains an in-memory buffer of the results.\n-///\n-/// # Examples\n-///\n-/// ```\n-/// # #![feature(old_io, old_path)]\n-/// use std::old_io::*;\n-/// use std::old_path::Path;\n-///\n-/// let file = File::open(&Path::new(\"message.txt\"));\n-/// let mut reader = BufferedReader::new(file);\n-///\n-/// let mut buf = [0; 100];\n-/// match reader.read(&mut buf) {\n-///     Ok(nread) => println!(\"Read {} bytes\", nread),\n-///     Err(e) => println!(\"error reading: {}\", e)\n-/// }\n-/// ```\n-pub struct BufferedReader<R> {\n-    inner: R,\n-    buf: Vec<u8>,\n-    pos: usize,\n-    cap: usize,\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<R> fmt::Debug for BufferedReader<R> where R: fmt::Debug {\n-    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n-        write!(fmt, \"BufferedReader {{ reader: {:?}, buffer: {}/{} }}\",\n-               self.inner, self.cap - self.pos, self.buf.len())\n-    }\n-}\n-\n-impl<R: Reader> BufferedReader<R> {\n-    /// Creates a new `BufferedReader` with the specified buffer capacity\n-    pub fn with_capacity(cap: usize, inner: R) -> BufferedReader<R> {\n-        BufferedReader {\n-            inner: inner,\n-            // We can't use the same trick here as we do for BufferedWriter,\n-            // since this memory is visible to the inner Reader.\n-            buf: repeat(0).take(cap).collect(),\n-            pos: 0,\n-            cap: 0,\n-        }\n-    }\n-\n-    /// Creates a new `BufferedReader` with a default buffer capacity\n-    pub fn new(inner: R) -> BufferedReader<R> {\n-        BufferedReader::with_capacity(DEFAULT_BUF_SIZE, inner)\n-    }\n-\n-    /// Gets a reference to the underlying reader.\n-    pub fn get_ref<'a>(&self) -> &R { &self.inner }\n-\n-    /// Gets a mutable reference to the underlying reader.\n-    ///\n-    /// # Warning\n-    ///\n-    /// It is inadvisable to directly read from the underlying reader.\n-    pub fn get_mut(&mut self) -> &mut R { &mut self.inner }\n-\n-    /// Unwraps this `BufferedReader`, returning the underlying reader.\n-    ///\n-    /// Note that any leftover data in the internal buffer is lost.\n-    pub fn into_inner(self) -> R { self.inner }\n-}\n-\n-impl<R: Reader> Buffer for BufferedReader<R> {\n-    fn fill_buf<'a>(&'a mut self) -> IoResult<&'a [u8]> {\n-        if self.pos == self.cap {\n-            self.cap = try!(self.inner.read(&mut self.buf));\n-            self.pos = 0;\n-        }\n-        Ok(&self.buf[self.pos..self.cap])\n-    }\n-\n-    fn consume(&mut self, amt: usize) {\n-        self.pos += amt;\n-        assert!(self.pos <= self.cap);\n-    }\n-}\n-\n-impl<R: Reader> Reader for BufferedReader<R> {\n-    fn read(&mut self, buf: &mut [u8]) -> IoResult<usize> {\n-        if self.pos == self.cap && buf.len() >= self.buf.len() {\n-            return self.inner.read(buf);\n-        }\n-        let nread = {\n-            let available = try!(self.fill_buf());\n-            let nread = cmp::min(available.len(), buf.len());\n-            slice::bytes::copy_memory(&available[..nread], buf);\n-            nread\n-        };\n-        self.pos += nread;\n-        Ok(nread)\n-    }\n-}\n-\n-/// Wraps a Writer and buffers output to it\n-///\n-/// It can be excessively inefficient to work directly with a `Writer`. For\n-/// example, every call to `write` on `TcpStream` results in a system call. A\n-/// `BufferedWriter` keeps an in memory buffer of data and writes it to the\n-/// underlying `Writer` in large, infrequent batches.\n-///\n-/// This writer will be flushed when it is dropped.\n-///\n-/// # Examples\n-///\n-/// ```\n-/// # #![feature(old_io, old_path)]\n-/// use std::old_io::*;\n-/// use std::old_path::Path;\n-///\n-/// let file = File::create(&Path::new(\"message.txt\")).unwrap();\n-/// let mut writer = BufferedWriter::new(file);\n-///\n-/// writer.write_str(\"hello, world\").unwrap();\n-/// writer.flush().unwrap();\n-/// ```\n-pub struct BufferedWriter<W: Writer> {\n-    inner: Option<W>,\n-    buf: Vec<u8>,\n-    pos: usize\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<W: Writer> fmt::Debug for BufferedWriter<W> where W: fmt::Debug {\n-    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n-        write!(fmt, \"BufferedWriter {{ writer: {:?}, buffer: {}/{} }}\",\n-               self.inner.as_ref().unwrap(), self.pos, self.buf.len())\n-    }\n-}\n-\n-impl<W: Writer> BufferedWriter<W> {\n-    /// Creates a new `BufferedWriter` with the specified buffer capacity\n-    pub fn with_capacity(cap: usize, inner: W) -> BufferedWriter<W> {\n-        // It's *much* faster to create an uninitialized buffer than it is to\n-        // fill everything in with 0. This buffer is entirely an implementation\n-        // detail and is never exposed, so we're safe to not initialize\n-        // everything up-front. This allows creation of BufferedWriter instances\n-        // to be very cheap (large mallocs are not nearly as expensive as large\n-        // callocs).\n-        let mut buf = Vec::with_capacity(cap);\n-        unsafe { buf.set_len(cap); }\n-        BufferedWriter {\n-            inner: Some(inner),\n-            buf: buf,\n-            pos: 0\n-        }\n-    }\n-\n-    /// Creates a new `BufferedWriter` with a default buffer capacity\n-    pub fn new(inner: W) -> BufferedWriter<W> {\n-        BufferedWriter::with_capacity(DEFAULT_BUF_SIZE, inner)\n-    }\n-\n-    fn flush_buf(&mut self) -> IoResult<()> {\n-        if self.pos != 0 {\n-            let ret = self.inner.as_mut().unwrap().write_all(&self.buf[..self.pos]);\n-            self.pos = 0;\n-            ret\n-        } else {\n-            Ok(())\n-        }\n-    }\n-\n-    /// Gets a reference to the underlying writer.\n-    pub fn get_ref(&self) -> &W { self.inner.as_ref().unwrap() }\n-\n-    /// Gets a mutable reference to the underlying write.\n-    ///\n-    /// # Warning\n-    ///\n-    /// It is inadvisable to directly read from the underlying writer.\n-    pub fn get_mut(&mut self) -> &mut W { self.inner.as_mut().unwrap() }\n-\n-    /// Unwraps this `BufferedWriter`, returning the underlying writer.\n-    ///\n-    /// The buffer is flushed before returning the writer.\n-    pub fn into_inner(mut self) -> W {\n-        // FIXME(#12628): is panicking the right thing to do if flushing panicks?\n-        self.flush_buf().unwrap();\n-        self.inner.take().unwrap()\n-    }\n-}\n-\n-impl<W: Writer> Writer for BufferedWriter<W> {\n-    fn write_all(&mut self, buf: &[u8]) -> IoResult<()> {\n-        if self.pos + buf.len() > self.buf.len() {\n-            try!(self.flush_buf());\n-        }\n-\n-        if buf.len() > self.buf.len() {\n-            self.inner.as_mut().unwrap().write_all(buf)\n-        } else {\n-            let dst = &mut self.buf[self.pos..];\n-            slice::bytes::copy_memory(buf, dst);\n-            self.pos += buf.len();\n-            Ok(())\n-        }\n-    }\n-\n-    fn flush(&mut self) -> IoResult<()> {\n-        self.flush_buf().and_then(|()| self.inner.as_mut().unwrap().flush())\n-    }\n-}\n-\n-#[unsafe_destructor]\n-impl<W: Writer> Drop for BufferedWriter<W> {\n-    fn drop(&mut self) {\n-        if self.inner.is_some() {\n-            // dtors should not panic, so we ignore a panicked flush\n-            let _ = self.flush_buf();\n-        }\n-    }\n-}\n-\n-/// Wraps a Writer and buffers output to it, flushing whenever a newline (`0x0a`,\n-/// `'\\n'`) is detected.\n-///\n-/// This writer will be flushed when it is dropped.\n-pub struct LineBufferedWriter<W: Writer> {\n-    inner: BufferedWriter<W>,\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<W: Writer> fmt::Debug for LineBufferedWriter<W> where W: fmt::Debug {\n-    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n-        write!(fmt, \"LineBufferedWriter {{ writer: {:?}, buffer: {}/{} }}\",\n-               self.inner.inner, self.inner.pos, self.inner.buf.len())\n-    }\n-}\n-\n-impl<W: Writer> LineBufferedWriter<W> {\n-    /// Creates a new `LineBufferedWriter`\n-    pub fn new(inner: W) -> LineBufferedWriter<W> {\n-        // Lines typically aren't that long, don't use a giant buffer\n-        LineBufferedWriter {\n-            inner: BufferedWriter::with_capacity(1024, inner)\n-        }\n-    }\n-\n-    /// Gets a reference to the underlying writer.\n-    ///\n-    /// This type does not expose the ability to get a mutable reference to the\n-    /// underlying reader because that could possibly corrupt the buffer.\n-    pub fn get_ref<'a>(&'a self) -> &'a W { self.inner.get_ref() }\n-\n-    /// Unwraps this `LineBufferedWriter`, returning the underlying writer.\n-    ///\n-    /// The internal buffer is flushed before returning the writer.\n-    pub fn into_inner(self) -> W { self.inner.into_inner() }\n-}\n-\n-impl<W: Writer> Writer for LineBufferedWriter<W> {\n-    fn write_all(&mut self, buf: &[u8]) -> IoResult<()> {\n-        match buf.iter().rposition(|&b| b == b'\\n') {\n-            Some(i) => {\n-                try!(self.inner.write_all(&buf[..i + 1]));\n-                try!(self.inner.flush());\n-                try!(self.inner.write_all(&buf[i + 1..]));\n-                Ok(())\n-            }\n-            None => self.inner.write_all(buf),\n-        }\n-    }\n-\n-    fn flush(&mut self) -> IoResult<()> { self.inner.flush() }\n-}\n-\n-struct InternalBufferedWriter<W: Writer>(BufferedWriter<W>);\n-\n-impl<W: Writer> InternalBufferedWriter<W> {\n-    fn get_mut<'a>(&'a mut self) -> &'a mut BufferedWriter<W> {\n-        let InternalBufferedWriter(ref mut w) = *self;\n-        return w;\n-    }\n-}\n-\n-impl<W: Reader + Writer> Reader for InternalBufferedWriter<W> {\n-    fn read(&mut self, buf: &mut [u8]) -> IoResult<usize> {\n-        self.get_mut().inner.as_mut().unwrap().read(buf)\n-    }\n-}\n-\n-/// Wraps a Stream and buffers input and output to and from it.\n-///\n-/// It can be excessively inefficient to work directly with a `Stream`. For\n-/// example, every call to `read` or `write` on `TcpStream` results in a system\n-/// call. A `BufferedStream` keeps in memory buffers of data, making large,\n-/// infrequent calls to `read` and `write` on the underlying `Stream`.\n-///\n-/// The output half will be flushed when this stream is dropped.\n-///\n-/// # Examples\n-///\n-/// ```\n-/// # #![feature(old_io, old_path)]\n-/// # #![allow(unused_must_use)]\n-/// use std::old_io::*;\n-/// use std::old_path::Path;\n-///\n-/// let file = File::open(&Path::new(\"message.txt\"));\n-/// let mut stream = BufferedStream::new(file);\n-///\n-/// stream.write_all(\"hello, world\".as_bytes());\n-/// stream.flush();\n-///\n-/// let mut buf = [0; 100];\n-/// match stream.read(&mut buf) {\n-///     Ok(nread) => println!(\"Read {} bytes\", nread),\n-///     Err(e) => println!(\"error reading: {}\", e)\n-/// }\n-/// ```\n-pub struct BufferedStream<S: Writer> {\n-    inner: BufferedReader<InternalBufferedWriter<S>>\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<S: Writer> fmt::Debug for BufferedStream<S> where S: fmt::Debug {\n-    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n-        let reader = &self.inner;\n-        let writer = &self.inner.inner.0;\n-        write!(fmt, \"BufferedStream {{ stream: {:?}, write_buffer: {}/{}, read_buffer: {}/{} }}\",\n-               writer.inner,\n-               writer.pos, writer.buf.len(),\n-               reader.cap - reader.pos, reader.buf.len())\n-    }\n-}\n-\n-impl<S: Stream> BufferedStream<S> {\n-    /// Creates a new buffered stream with explicitly listed capacities for the\n-    /// reader/writer buffer.\n-    pub fn with_capacities(reader_cap: usize, writer_cap: usize, inner: S)\n-                           -> BufferedStream<S> {\n-        let writer = BufferedWriter::with_capacity(writer_cap, inner);\n-        let internal_writer = InternalBufferedWriter(writer);\n-        let reader = BufferedReader::with_capacity(reader_cap,\n-                                                   internal_writer);\n-        BufferedStream { inner: reader }\n-    }\n-\n-    /// Creates a new buffered stream with the default reader/writer buffer\n-    /// capacities.\n-    pub fn new(inner: S) -> BufferedStream<S> {\n-        BufferedStream::with_capacities(DEFAULT_BUF_SIZE, DEFAULT_BUF_SIZE,\n-                                        inner)\n-    }\n-\n-    /// Gets a reference to the underlying stream.\n-    pub fn get_ref(&self) -> &S {\n-        let InternalBufferedWriter(ref w) = self.inner.inner;\n-        w.get_ref()\n-    }\n-\n-    /// Gets a mutable reference to the underlying stream.\n-    ///\n-    /// # Warning\n-    ///\n-    /// It is inadvisable to read directly from or write directly to the\n-    /// underlying stream.\n-    pub fn get_mut(&mut self) -> &mut S {\n-        let InternalBufferedWriter(ref mut w) = self.inner.inner;\n-        w.get_mut()\n-    }\n-\n-    /// Unwraps this `BufferedStream`, returning the underlying stream.\n-    ///\n-    /// The internal buffer is flushed before returning the stream. Any leftover\n-    /// data in the read buffer is lost.\n-    pub fn into_inner(self) -> S {\n-        let InternalBufferedWriter(w) = self.inner.inner;\n-        w.into_inner()\n-    }\n-}\n-\n-impl<S: Stream> Buffer for BufferedStream<S> {\n-    fn fill_buf<'a>(&'a mut self) -> IoResult<&'a [u8]> { self.inner.fill_buf() }\n-    fn consume(&mut self, amt: usize) { self.inner.consume(amt) }\n-}\n-\n-impl<S: Stream> Reader for BufferedStream<S> {\n-    fn read(&mut self, buf: &mut [u8]) -> IoResult<usize> {\n-        self.inner.read(buf)\n-    }\n-}\n-\n-impl<S: Stream> Writer for BufferedStream<S> {\n-    fn write_all(&mut self, buf: &[u8]) -> IoResult<()> {\n-        self.inner.inner.get_mut().write_all(buf)\n-    }\n-    fn flush(&mut self) -> IoResult<()> {\n-        self.inner.inner.get_mut().flush()\n-    }\n-}\n-\n-#[cfg(test)]\n-mod test {\n-    extern crate test;\n-    use old_io::{self, Reader, Writer, Buffer, BufferPrelude};\n-    use prelude::v1::*;\n-    use super::*;\n-    use super::super::{IoResult, EndOfFile};\n-    use super::super::mem::MemReader;\n-    use self::test::Bencher;\n-\n-    /// A type, free to create, primarily intended for benchmarking creation of\n-    /// wrappers that, just for construction, don't need a Reader/Writer that\n-    /// does anything useful. Is equivalent to `/dev/null` in semantics.\n-    #[derive(Clone,PartialEq,PartialOrd)]\n-    pub struct NullStream;\n-\n-    impl Reader for NullStream {\n-        fn read(&mut self, _: &mut [u8]) -> old_io::IoResult<usize> {\n-            Err(old_io::standard_error(old_io::EndOfFile))\n-        }\n-    }\n-\n-    impl Writer for NullStream {\n-        fn write_all(&mut self, _: &[u8]) -> old_io::IoResult<()> { Ok(()) }\n-    }\n-\n-    /// A dummy reader intended at testing short-reads propagation.\n-    pub struct ShortReader {\n-        lengths: Vec<usize>,\n-    }\n-\n-    impl Reader for ShortReader {\n-        fn read(&mut self, _: &mut [u8]) -> old_io::IoResult<usize> {\n-            if self.lengths.is_empty() {\n-                Err(old_io::standard_error(old_io::EndOfFile))\n-            } else {\n-                Ok(self.lengths.remove(0))\n-            }\n-        }\n-    }\n-\n-    #[test]\n-    fn test_buffered_reader() {\n-        let inner = MemReader::new(vec!(5, 6, 7, 0, 1, 2, 3, 4));\n-        let mut reader = BufferedReader::with_capacity(2, inner);\n-\n-        let mut buf = [0, 0, 0];\n-        let nread = reader.read(&mut buf);\n-        assert_eq!(Ok(3), nread);\n-        let b: &[_] = &[5, 6, 7];\n-        assert_eq!(buf, b);\n-\n-        let mut buf = [0, 0];\n-        let nread = reader.read(&mut buf);\n-        assert_eq!(Ok(2), nread);\n-        let b: &[_] = &[0, 1];\n-        assert_eq!(buf, b);\n-\n-        let mut buf = [0];\n-        let nread = reader.read(&mut buf);\n-        assert_eq!(Ok(1), nread);\n-        let b: &[_] = &[2];\n-        assert_eq!(buf, b);\n-\n-        let mut buf = [0, 0, 0];\n-        let nread = reader.read(&mut buf);\n-        assert_eq!(Ok(1), nread);\n-        let b: &[_] = &[3, 0, 0];\n-        assert_eq!(buf, b);\n-\n-        let nread = reader.read(&mut buf);\n-        assert_eq!(Ok(1), nread);\n-        let b: &[_] = &[4, 0, 0];\n-        assert_eq!(buf, b);\n-\n-        assert!(reader.read(&mut buf).is_err());\n-    }\n-\n-    #[test]\n-    fn test_buffered_writer() {\n-        let inner = Vec::new();\n-        let mut writer = BufferedWriter::with_capacity(2, inner);\n-\n-        writer.write_all(&[0, 1]).unwrap();\n-        let b: &[_] = &[];\n-        assert_eq!(&writer.get_ref()[..], b);\n-\n-        writer.write_all(&[2]).unwrap();\n-        let b: &[_] = &[0, 1];\n-        assert_eq!(&writer.get_ref()[..], b);\n-\n-        writer.write_all(&[3]).unwrap();\n-        assert_eq!(&writer.get_ref()[..], b);\n-\n-        writer.flush().unwrap();\n-        let a: &[_] = &[0, 1, 2, 3];\n-        assert_eq!(a, &writer.get_ref()[..]);\n-\n-        writer.write_all(&[4]).unwrap();\n-        writer.write_all(&[5]).unwrap();\n-        assert_eq!(a, &writer.get_ref()[..]);\n-\n-        writer.write_all(&[6]).unwrap();\n-        let a: &[_] = &[0, 1, 2, 3, 4, 5];\n-        assert_eq!(a, &writer.get_ref()[..]);\n-\n-        writer.write_all(&[7, 8]).unwrap();\n-        let a: &[_] = &[0, 1, 2, 3, 4, 5, 6];\n-        assert_eq!(a, &writer.get_ref()[..]);\n-\n-        writer.write_all(&[9, 10, 11]).unwrap();\n-        let a: &[_] = &[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11];\n-        assert_eq!(a, &writer.get_ref()[..]);\n-\n-        writer.flush().unwrap();\n-        assert_eq!(a, &writer.get_ref()[..]);\n-    }\n-\n-    #[test]\n-    fn test_buffered_writer_inner_flushes() {\n-        let mut w = BufferedWriter::with_capacity(3, Vec::new());\n-        w.write_all(&[0, 1]).unwrap();\n-        let a: &[_] = &[];\n-        assert_eq!(&w.get_ref()[..], a);\n-        let w = w.into_inner();\n-        let a: &[_] = &[0, 1];\n-        assert_eq!(a, &w[..]);\n-    }\n-\n-    // This is just here to make sure that we don't infinite loop in the\n-    // newtype struct autoderef weirdness\n-    #[test]\n-    fn test_buffered_stream() {\n-        struct S;\n-\n-        impl old_io::Writer for S {\n-            fn write_all(&mut self, _: &[u8]) -> old_io::IoResult<()> { Ok(()) }\n-        }\n-\n-        impl old_io::Reader for S {\n-            fn read(&mut self, _: &mut [u8]) -> old_io::IoResult<usize> {\n-                Err(old_io::standard_error(old_io::EndOfFile))\n-            }\n-        }\n-\n-        let mut stream = BufferedStream::new(S);\n-        let mut buf = [];\n-        assert!(stream.read(&mut buf).is_err());\n-        stream.write_all(&buf).unwrap();\n-        stream.flush().unwrap();\n-    }\n-\n-    #[test]\n-    fn test_read_until() {\n-        let inner = MemReader::new(vec!(0, 1, 2, 1, 0));\n-        let mut reader = BufferedReader::with_capacity(2, inner);\n-        assert_eq!(reader.read_until(0), Ok(vec!(0)));\n-        assert_eq!(reader.read_until(2), Ok(vec!(1, 2)));\n-        assert_eq!(reader.read_until(1), Ok(vec!(1)));\n-        assert_eq!(reader.read_until(8), Ok(vec!(0)));\n-        assert!(reader.read_until(9).is_err());\n-    }\n-\n-    #[test]\n-    fn test_line_buffer() {\n-        let mut writer = LineBufferedWriter::new(Vec::new());\n-        writer.write_all(&[0]).unwrap();\n-        let b: &[_] = &[];\n-        assert_eq!(&writer.get_ref()[..], b);\n-        writer.write_all(&[1]).unwrap();\n-        assert_eq!(&writer.get_ref()[..], b);\n-        writer.flush().unwrap();\n-        let b: &[_] = &[0, 1];\n-        assert_eq!(&writer.get_ref()[..], b);\n-        writer.write_all(&[0, b'\\n', 1, b'\\n', 2]).unwrap();\n-        let b: &[_] = &[0, 1, 0, b'\\n', 1, b'\\n'];\n-        assert_eq!(&writer.get_ref()[..], b);\n-        writer.flush().unwrap();\n-        let b: &[_] = &[0, 1, 0, b'\\n', 1, b'\\n', 2];\n-        assert_eq!(&writer.get_ref()[..], b);\n-        writer.write_all(&[3, b'\\n']).unwrap();\n-        let b: &[_] = &[0, 1, 0, b'\\n', 1, b'\\n', 2, 3, b'\\n'];\n-        assert_eq!(&writer.get_ref()[..], b);\n-    }\n-\n-    #[test]\n-    fn test_read_line() {\n-        let in_buf = MemReader::new(b\"a\\nb\\nc\".to_vec());\n-        let mut reader = BufferedReader::with_capacity(2, in_buf);\n-        assert_eq!(reader.read_line(), Ok(\"a\\n\".to_string()));\n-        assert_eq!(reader.read_line(), Ok(\"b\\n\".to_string()));\n-        assert_eq!(reader.read_line(), Ok(\"c\".to_string()));\n-        assert!(reader.read_line().is_err());\n-    }\n-\n-    #[test]\n-    fn test_lines() {\n-        let in_buf = MemReader::new(b\"a\\nb\\nc\".to_vec());\n-        let mut reader = BufferedReader::with_capacity(2, in_buf);\n-        let mut it = reader.lines();\n-        assert_eq!(it.next(), Some(Ok(\"a\\n\".to_string())));\n-        assert_eq!(it.next(), Some(Ok(\"b\\n\".to_string())));\n-        assert_eq!(it.next(), Some(Ok(\"c\".to_string())));\n-        assert_eq!(it.next(), None);\n-    }\n-\n-    #[test]\n-    fn test_short_reads() {\n-        let inner = ShortReader{lengths: vec![0, 1, 2, 0, 1, 0]};\n-        let mut reader = BufferedReader::new(inner);\n-        let mut buf = [0, 0];\n-        assert_eq!(reader.read(&mut buf), Ok(0));\n-        assert_eq!(reader.read(&mut buf), Ok(1));\n-        assert_eq!(reader.read(&mut buf), Ok(2));\n-        assert_eq!(reader.read(&mut buf), Ok(0));\n-        assert_eq!(reader.read(&mut buf), Ok(1));\n-        assert_eq!(reader.read(&mut buf), Ok(0));\n-        assert!(reader.read(&mut buf).is_err());\n-    }\n-\n-    #[test]\n-    fn read_char_buffered() {\n-        let buf = [195, 159];\n-        let mut reader = BufferedReader::with_capacity(1, &buf[..]);\n-        assert_eq!(reader.read_char(), Ok('\u00df'));\n-    }\n-\n-    #[test]\n-    fn test_chars() {\n-        let buf = [195, 159, b'a'];\n-        let mut reader = BufferedReader::with_capacity(1, &buf[..]);\n-        let mut it = reader.chars();\n-        assert_eq!(it.next(), Some(Ok('\u00df')));\n-        assert_eq!(it.next(), Some(Ok('a')));\n-        assert_eq!(it.next(), None);\n-    }\n-\n-    #[test]\n-    #[should_panic]\n-    fn dont_panic_in_drop_on_panicked_flush() {\n-        struct FailFlushWriter;\n-\n-        impl Writer for FailFlushWriter {\n-            fn write_all(&mut self, _buf: &[u8]) -> IoResult<()> { Ok(()) }\n-            fn flush(&mut self) -> IoResult<()> { Err(old_io::standard_error(EndOfFile)) }\n-        }\n-\n-        let writer = FailFlushWriter;\n-        let _writer = BufferedWriter::new(writer);\n-\n-        // If writer panics *again* due to the flush error then the process will abort.\n-        panic!();\n-    }\n-\n-    #[bench]\n-    fn bench_buffered_reader(b: &mut Bencher) {\n-        b.iter(|| {\n-            BufferedReader::new(NullStream)\n-        });\n-    }\n-\n-    #[bench]\n-    fn bench_buffered_writer(b: &mut Bencher) {\n-        b.iter(|| {\n-            BufferedWriter::new(NullStream)\n-        });\n-    }\n-\n-    #[bench]\n-    fn bench_buffered_stream(b: &mut Bencher) {\n-        b.iter(|| {\n-            BufferedStream::new(NullStream);\n-        });\n-    }\n-}"}, {"sha": "5ebf931e95c375f60f2358faae6b3112b756c3a8", "filename": "src/libstd/old_io/comm_adapters.rs", "status": "removed", "additions": 0, "deletions": 247, "changes": 247, "blob_url": "https://github.com/rust-lang/rust/blob/8415fa27877a4309a79b08c75a52eb4c3546b7a5/src%2Flibstd%2Fold_io%2Fcomm_adapters.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8415fa27877a4309a79b08c75a52eb4c3546b7a5/src%2Flibstd%2Fold_io%2Fcomm_adapters.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fcomm_adapters.rs?ref=8415fa27877a4309a79b08c75a52eb4c3546b7a5", "patch": "@@ -1,247 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use clone::Clone;\n-use cmp;\n-use sync::mpsc::{Sender, Receiver};\n-use old_io;\n-use option::Option::{None, Some};\n-use result::Result::{Ok, Err};\n-use slice::bytes;\n-use super::{Buffer, Reader, Writer, IoResult};\n-use vec::Vec;\n-\n-/// Allows reading from a rx.\n-///\n-/// # Examples\n-///\n-/// ```\n-/// # #![feature(old_io)]\n-/// use std::sync::mpsc::channel;\n-/// use std::old_io::*;\n-///\n-/// let (tx, rx) = channel();\n-/// # drop(tx);\n-/// let mut reader = ChanReader::new(rx);\n-///\n-/// let mut buf = [0; 100];\n-/// match reader.read(&mut buf) {\n-///     Ok(nread) => println!(\"Read {} bytes\", nread),\n-///     Err(e) => println!(\"read error: {}\", e),\n-/// }\n-/// ```\n-pub struct ChanReader {\n-    buf: Vec<u8>,          // A buffer of bytes received but not consumed.\n-    pos: usize,             // How many of the buffered bytes have already be consumed.\n-    rx: Receiver<Vec<u8>>, // The Receiver to pull data from.\n-    closed: bool,          // Whether the channel this Receiver connects to has been closed.\n-}\n-\n-impl ChanReader {\n-    /// Wraps a `Port` in a `ChanReader` structure\n-    pub fn new(rx: Receiver<Vec<u8>>) -> ChanReader {\n-        ChanReader {\n-            buf: Vec::new(),\n-            pos: 0,\n-            rx: rx,\n-            closed: false,\n-        }\n-    }\n-}\n-\n-impl Buffer for ChanReader {\n-    fn fill_buf<'a>(&'a mut self) -> IoResult<&'a [u8]> {\n-        if self.pos >= self.buf.len() {\n-            self.pos = 0;\n-            match self.rx.recv() {\n-                Ok(bytes) => {\n-                    self.buf = bytes;\n-                },\n-                Err(..) => {\n-                    self.closed = true;\n-                    self.buf = Vec::new();\n-                }\n-            }\n-        }\n-        if self.closed {\n-            Err(old_io::standard_error(old_io::EndOfFile))\n-        } else {\n-            Ok(&self.buf[self.pos..])\n-        }\n-    }\n-\n-    fn consume(&mut self, amt: usize) {\n-        self.pos += amt;\n-        assert!(self.pos <= self.buf.len());\n-    }\n-}\n-\n-impl Reader for ChanReader {\n-    fn read(&mut self, buf: &mut [u8]) -> IoResult<usize> {\n-        let mut num_read = 0;\n-        loop {\n-            let count = match self.fill_buf().ok() {\n-                Some(src) => {\n-                    let dst = &mut buf[num_read..];\n-                    let count = cmp::min(src.len(), dst.len());\n-                    bytes::copy_memory(&src[..count], dst);\n-                    count\n-                },\n-                None => 0,\n-            };\n-            self.consume(count);\n-            num_read += count;\n-            if num_read == buf.len() || self.closed {\n-                break;\n-            }\n-        }\n-        if self.closed && num_read == 0 {\n-            Err(old_io::standard_error(old_io::EndOfFile))\n-        } else {\n-            Ok(num_read)\n-        }\n-    }\n-}\n-\n-/// Allows writing to a tx.\n-///\n-/// # Examples\n-///\n-/// ```\n-/// # #![feature(old_io, io)]\n-/// # #![allow(unused_must_use)]\n-/// use std::sync::mpsc::channel;\n-/// use std::old_io::*;\n-///\n-/// let (tx, rx) = channel();\n-/// # drop(rx);\n-/// let mut writer = ChanWriter::new(tx);\n-/// writer.write(\"hello, world\".as_bytes());\n-/// ```\n-pub struct ChanWriter {\n-    tx: Sender<Vec<u8>>,\n-}\n-\n-impl ChanWriter {\n-    /// Wraps a channel in a `ChanWriter` structure\n-    pub fn new(tx: Sender<Vec<u8>>) -> ChanWriter {\n-        ChanWriter { tx: tx }\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl Clone for ChanWriter {\n-    fn clone(&self) -> ChanWriter {\n-        ChanWriter { tx: self.tx.clone() }\n-    }\n-}\n-\n-impl Writer for ChanWriter {\n-    fn write_all(&mut self, buf: &[u8]) -> IoResult<()> {\n-        self.tx.send(buf.to_vec()).map_err(|_| {\n-            old_io::IoError {\n-                kind: old_io::BrokenPipe,\n-                desc: \"Pipe closed\",\n-                detail: None\n-            }\n-        })\n-    }\n-}\n-\n-\n-#[cfg(test)]\n-mod test {\n-    use prelude::v1::*;\n-\n-    use sync::mpsc::channel;\n-    use super::*;\n-    use old_io::{self, Reader, Writer, Buffer};\n-    use thread;\n-\n-    #[test]\n-    fn test_rx_reader() {\n-        let (tx, rx) = channel();\n-        thread::spawn(move|| {\n-          tx.send(vec![1, 2]).unwrap();\n-          tx.send(vec![]).unwrap();\n-          tx.send(vec![3, 4]).unwrap();\n-          tx.send(vec![5, 6]).unwrap();\n-          tx.send(vec![7, 8]).unwrap();\n-        });\n-\n-        let mut reader = ChanReader::new(rx);\n-        let mut buf = [0; 3];\n-\n-        assert_eq!(Ok(0), reader.read(&mut []));\n-\n-        assert_eq!(Ok(3), reader.read(&mut buf));\n-        let a: &[u8] = &[1,2,3];\n-        assert_eq!(a, buf);\n-\n-        assert_eq!(Ok(3), reader.read(&mut buf));\n-        let a: &[u8] = &[4,5,6];\n-        assert_eq!(a, buf);\n-\n-        assert_eq!(Ok(2), reader.read(&mut buf));\n-        let a: &[u8] = &[7,8,6];\n-        assert_eq!(a, buf);\n-\n-        match reader.read(&mut buf) {\n-            Ok(..) => panic!(),\n-            Err(e) => assert_eq!(e.kind, old_io::EndOfFile),\n-        }\n-        assert_eq!(a, buf);\n-\n-        // Ensure it continues to panic in the same way.\n-        match reader.read(&mut buf) {\n-            Ok(..) => panic!(),\n-            Err(e) => assert_eq!(e.kind, old_io::EndOfFile),\n-        }\n-        assert_eq!(a, buf);\n-    }\n-\n-    #[test]\n-    fn test_rx_buffer() {\n-        let (tx, rx) = channel();\n-        thread::spawn(move|| {\n-          tx.send(b\"he\".to_vec()).unwrap();\n-          tx.send(b\"llo wo\".to_vec()).unwrap();\n-          tx.send(b\"\".to_vec()).unwrap();\n-          tx.send(b\"rld\\nhow \".to_vec()).unwrap();\n-          tx.send(b\"are you?\".to_vec()).unwrap();\n-          tx.send(b\"\".to_vec()).unwrap();\n-        });\n-\n-        let mut reader = ChanReader::new(rx);\n-\n-        assert_eq!(Ok(\"hello world\\n\".to_string()), reader.read_line());\n-        assert_eq!(Ok(\"how are you?\".to_string()), reader.read_line());\n-        match reader.read_line() {\n-            Ok(..) => panic!(),\n-            Err(e) => assert_eq!(e.kind, old_io::EndOfFile),\n-        }\n-    }\n-\n-    #[test]\n-    fn test_chan_writer() {\n-        let (tx, rx) = channel();\n-        let mut writer = ChanWriter::new(tx);\n-        writer.write_be_u32(42).unwrap();\n-\n-        let wanted = vec![0, 0, 0, 42];\n-        let got = thread::scoped(move|| { rx.recv().unwrap() }).join();\n-        assert_eq!(wanted, got);\n-\n-        match writer.write_u8(1) {\n-            Ok(..) => panic!(),\n-            Err(e) => assert_eq!(e.kind, old_io::BrokenPipe),\n-        }\n-    }\n-}"}, {"sha": "73973d0db282d26c92c8adc059d46bb0f1c5dc96", "filename": "src/libstd/old_io/extensions.rs", "status": "removed", "additions": 0, "deletions": 564, "changes": 564, "blob_url": "https://github.com/rust-lang/rust/blob/8415fa27877a4309a79b08c75a52eb4c3546b7a5/src%2Flibstd%2Fold_io%2Fextensions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8415fa27877a4309a79b08c75a52eb4c3546b7a5/src%2Flibstd%2Fold_io%2Fextensions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fextensions.rs?ref=8415fa27877a4309a79b08c75a52eb4c3546b7a5", "patch": "@@ -1,564 +0,0 @@\n-// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Utility mixins that apply to all Readers and Writers\n-\n-#![allow(missing_docs)]\n-#![unstable(feature = \"old_io\")]\n-#![deprecated(since = \"1.0.0\",\n-              reason = \"functionality will be removed with no immediate \\\n-                        replacement\")]\n-\n-// FIXME: Not sure how this should be structured\n-// FIXME: Iteration should probably be considered separately\n-\n-use old_io::{IoError, IoResult, Reader};\n-use old_io;\n-use iter::Iterator;\n-use num::Int;\n-use ops::FnOnce;\n-use option::Option;\n-use option::Option::{Some, None};\n-use result::Result::{Ok, Err};\n-\n-/// An iterator that reads a single byte on each iteration,\n-/// until `.read_byte()` returns `EndOfFile`.\n-///\n-/// # Notes about the Iteration Protocol\n-///\n-/// The `Bytes` may yield `None` and thus terminate\n-/// an iteration, but continue to yield elements if iteration\n-/// is attempted again.\n-///\n-/// # Error\n-///\n-/// Any error other than `EndOfFile` that is produced by the underlying Reader\n-/// is returned by the iterator and should be handled by the caller.\n-pub struct Bytes<'r, T:'r> {\n-    reader: &'r mut T,\n-}\n-\n-impl<'r, R: Reader> Bytes<'r, R> {\n-    /// Constructs a new byte iterator from the given Reader instance.\n-    pub fn new(r: &'r mut R) -> Bytes<'r, R> {\n-        Bytes {\n-            reader: r,\n-        }\n-    }\n-}\n-\n-impl<'r, R: Reader> Iterator for Bytes<'r, R> {\n-    type Item = IoResult<u8>;\n-\n-    #[inline]\n-    fn next(&mut self) -> Option<IoResult<u8>> {\n-        match self.reader.read_byte() {\n-            Ok(x) => Some(Ok(x)),\n-            Err(IoError { kind: old_io::EndOfFile, .. }) => None,\n-            Err(e) => Some(Err(e))\n-        }\n-    }\n-}\n-\n-/// Converts an 8-bit to 64-bit unsigned value to a little-endian byte\n-/// representation of the given size. If the size is not big enough to\n-/// represent the value, then the high-order bytes are truncated.\n-///\n-/// Arguments:\n-///\n-/// * `n`: The value to convert.\n-/// * `size`: The size of the value, in bytes. This must be 8 or less, or task\n-///           panic occurs. If this is less than 8, then a value of that\n-///           many bytes is produced. For example, if `size` is 4, then a\n-///           32-bit byte representation is produced.\n-/// * `f`: A callback that receives the value.\n-///\n-/// This function returns the value returned by the callback, for convenience.\n-pub fn u64_to_le_bytes<T, F>(n: u64, size: usize, f: F) -> T where\n-    F: FnOnce(&[u8]) -> T,\n-{\n-    use mem::transmute;\n-\n-    // LLVM fails to properly optimize this when using shifts instead of the to_le* intrinsics\n-    assert!(size <= 8);\n-    match size {\n-      1 => f(&[n as u8]),\n-      2 => f(unsafe { & transmute::<_, [u8; 2]>((n as u16).to_le()) }),\n-      4 => f(unsafe { & transmute::<_, [u8; 4]>((n as u32).to_le()) }),\n-      8 => f(unsafe { & transmute::<_, [u8; 8]>(n.to_le()) }),\n-      _ => {\n-\n-        let mut bytes = vec!();\n-        let mut i = size;\n-        let mut n = n;\n-        while i > 0 {\n-            bytes.push((n & 255) as u8);\n-            n >>= 8;\n-            i -= 1;\n-        }\n-        f(&bytes)\n-      }\n-    }\n-}\n-\n-/// Converts an 8-bit to 64-bit unsigned value to a big-endian byte\n-/// representation of the given size. If the size is not big enough to\n-/// represent the value, then the high-order bytes are truncated.\n-///\n-/// Arguments:\n-///\n-/// * `n`: The value to convert.\n-/// * `size`: The size of the value, in bytes. This must be 8 or less, or task\n-///           panic occurs. If this is less than 8, then a value of that\n-///           many bytes is produced. For example, if `size` is 4, then a\n-///           32-bit byte representation is produced.\n-/// * `f`: A callback that receives the value.\n-///\n-/// This function returns the value returned by the callback, for convenience.\n-pub fn u64_to_be_bytes<T, F>(n: u64, size: usize, f: F) -> T where\n-    F: FnOnce(&[u8]) -> T,\n-{\n-    use mem::transmute;\n-\n-    // LLVM fails to properly optimize this when using shifts instead of the to_be* intrinsics\n-    assert!(size <= 8);\n-    match size {\n-      1 => f(&[n as u8]),\n-      2 => f(unsafe { & transmute::<_, [u8; 2]>((n as u16).to_be()) }),\n-      4 => f(unsafe { & transmute::<_, [u8; 4]>((n as u32).to_be()) }),\n-      8 => f(unsafe { & transmute::<_, [u8; 8]>(n.to_be()) }),\n-      _ => {\n-        let mut bytes = vec!();\n-        let mut i = size;\n-        while i > 0 {\n-            let shift = (i - 1) * 8;\n-            bytes.push((n >> shift) as u8);\n-            i -= 1;\n-        }\n-        f(&bytes)\n-      }\n-    }\n-}\n-\n-/// Extracts an 8-bit to 64-bit unsigned big-endian value from the given byte\n-/// buffer and returns it as a 64-bit value.\n-///\n-/// Arguments:\n-///\n-/// * `data`: The buffer in which to extract the value.\n-/// * `start`: The offset at which to extract the value.\n-/// * `size`: The size of the value in bytes to extract. This must be 8 or\n-///           less, or task panic occurs. If this is less than 8, then only\n-///           that many bytes are parsed. For example, if `size` is 4, then a\n-///           32-bit value is parsed.\n-pub fn u64_from_be_bytes(data: &[u8], start: usize, size: usize) -> u64 {\n-    use ptr::{copy_nonoverlapping};\n-\n-    assert!(size <= 8);\n-\n-    if data.len() - start < size {\n-        panic!(\"index out of bounds\");\n-    }\n-\n-    let mut buf = [0; 8];\n-    unsafe {\n-        let ptr = data.as_ptr().offset(start as isize);\n-        let out = buf.as_mut_ptr();\n-        copy_nonoverlapping(ptr, out.offset((8 - size) as isize), size);\n-        (*(out as *const u64)).to_be()\n-    }\n-}\n-\n-#[cfg(test)]\n-mod test {\n-    use prelude::v1::*;\n-    use old_io::{self, Reader, Writer};\n-    use old_io::{MemReader, BytesReader};\n-\n-    struct InitialZeroByteReader {\n-        count: isize,\n-    }\n-\n-    impl Reader for InitialZeroByteReader {\n-        fn read(&mut self, buf: &mut [u8]) -> old_io::IoResult<usize> {\n-            if self.count == 0 {\n-                self.count = 1;\n-                Ok(0)\n-            } else {\n-                buf[0] = 10;\n-                Ok(1)\n-            }\n-        }\n-    }\n-\n-    struct EofReader;\n-\n-    impl Reader for EofReader {\n-        fn read(&mut self, _: &mut [u8]) -> old_io::IoResult<usize> {\n-            Err(old_io::standard_error(old_io::EndOfFile))\n-        }\n-    }\n-\n-    struct ErroringReader;\n-\n-    impl Reader for ErroringReader {\n-        fn read(&mut self, _: &mut [u8]) -> old_io::IoResult<usize> {\n-            Err(old_io::standard_error(old_io::InvalidInput))\n-        }\n-    }\n-\n-    struct PartialReader {\n-        count: isize,\n-    }\n-\n-    impl Reader for PartialReader {\n-        fn read(&mut self, buf: &mut [u8]) -> old_io::IoResult<usize> {\n-            if self.count == 0 {\n-                self.count = 1;\n-                buf[0] = 10;\n-                buf[1] = 11;\n-                Ok(2)\n-            } else {\n-                buf[0] = 12;\n-                buf[1] = 13;\n-                Ok(2)\n-            }\n-        }\n-    }\n-\n-    struct ErroringLaterReader {\n-        count: isize,\n-    }\n-\n-    impl Reader for ErroringLaterReader {\n-        fn read(&mut self, buf: &mut [u8]) -> old_io::IoResult<usize> {\n-            if self.count == 0 {\n-                self.count = 1;\n-                buf[0] = 10;\n-                Ok(1)\n-            } else {\n-                Err(old_io::standard_error(old_io::InvalidInput))\n-            }\n-        }\n-    }\n-\n-    struct ThreeChunkReader {\n-        count: isize,\n-    }\n-\n-    impl Reader for ThreeChunkReader {\n-        fn read(&mut self, buf: &mut [u8]) -> old_io::IoResult<usize> {\n-            if self.count == 0 {\n-                self.count = 1;\n-                buf[0] = 10;\n-                buf[1] = 11;\n-                Ok(2)\n-            } else if self.count == 1 {\n-                self.count = 2;\n-                buf[0] = 12;\n-                buf[1] = 13;\n-                Ok(2)\n-            } else {\n-                Err(old_io::standard_error(old_io::EndOfFile))\n-            }\n-        }\n-    }\n-\n-    #[test]\n-    fn read_byte() {\n-        let mut reader = MemReader::new(vec!(10));\n-        let byte = reader.read_byte();\n-        assert!(byte == Ok(10));\n-    }\n-\n-    #[test]\n-    fn read_byte_0_bytes() {\n-        let mut reader = InitialZeroByteReader {\n-            count: 0,\n-        };\n-        let byte = reader.read_byte();\n-        assert!(byte == Ok(10));\n-    }\n-\n-    #[test]\n-    fn read_byte_eof() {\n-        let mut reader = EofReader;\n-        let byte = reader.read_byte();\n-        assert!(byte.is_err());\n-    }\n-\n-    #[test]\n-    fn read_byte_error() {\n-        let mut reader = ErroringReader;\n-        let byte = reader.read_byte();\n-        assert!(byte.is_err());\n-    }\n-\n-    #[test]\n-    fn bytes_0_bytes() {\n-        let mut reader = InitialZeroByteReader {\n-            count: 0,\n-        };\n-        let byte = reader.bytes().next();\n-        assert!(byte == Some(Ok(10)));\n-    }\n-\n-    #[test]\n-    fn bytes_eof() {\n-        let mut reader = EofReader;\n-        let byte = reader.bytes().next();\n-        assert!(byte.is_none());\n-    }\n-\n-    #[test]\n-    fn bytes_error() {\n-        let mut reader = ErroringReader;\n-        let mut it = reader.bytes();\n-        let byte = it.next();\n-        assert!(byte.unwrap().is_err());\n-    }\n-\n-    #[test]\n-    fn read_bytes() {\n-        let mut reader = MemReader::new(vec!(10, 11, 12, 13));\n-        let bytes = reader.read_exact(4).unwrap();\n-        assert_eq!(bytes, [10, 11, 12, 13]);\n-    }\n-\n-    #[test]\n-    fn read_bytes_partial() {\n-        let mut reader = PartialReader {\n-            count: 0,\n-        };\n-        let bytes = reader.read_exact(4).unwrap();\n-        assert_eq!(bytes, [10, 11, 12, 13]);\n-    }\n-\n-    #[test]\n-    fn read_bytes_eof() {\n-        let mut reader = MemReader::new(vec!(10, 11));\n-        assert!(reader.read_exact(4).is_err());\n-    }\n-\n-    #[test]\n-    fn push_at_least() {\n-        let mut reader = MemReader::new(vec![10, 11, 12, 13]);\n-        let mut buf = vec![8, 9];\n-        assert!(reader.push_at_least(4, 4, &mut buf).is_ok());\n-        assert_eq!(buf, [8, 9, 10, 11, 12, 13]);\n-    }\n-\n-    #[test]\n-    fn push_at_least_partial() {\n-        let mut reader = PartialReader {\n-            count: 0,\n-        };\n-        let mut buf = vec![8, 9];\n-        assert!(reader.push_at_least(4, 4, &mut buf).is_ok());\n-        assert_eq!(buf, [8, 9, 10, 11, 12, 13]);\n-    }\n-\n-    #[test]\n-    fn push_at_least_eof() {\n-        let mut reader = MemReader::new(vec![10, 11]);\n-        let mut buf = vec![8, 9];\n-        assert!(reader.push_at_least(4, 4, &mut buf).is_err());\n-        assert_eq!(buf, [8, 9, 10, 11]);\n-    }\n-\n-    #[test]\n-    fn push_at_least_error() {\n-        let mut reader = ErroringLaterReader {\n-            count: 0,\n-        };\n-        let mut buf = vec![8, 9];\n-        assert!(reader.push_at_least(4, 4, &mut buf).is_err());\n-        assert_eq!(buf, [8, 9, 10]);\n-    }\n-\n-    #[test]\n-    fn read_to_end() {\n-        let mut reader = ThreeChunkReader {\n-            count: 0,\n-        };\n-        let buf = reader.read_to_end().unwrap();\n-        assert_eq!(buf, [10, 11, 12, 13]);\n-    }\n-\n-    #[test]\n-    #[should_panic]\n-    fn read_to_end_error() {\n-        let mut reader = ThreeChunkReader {\n-            count: 0,\n-        };\n-        let buf = reader.read_to_end().unwrap();\n-        assert_eq!(buf, [10, 11]);\n-    }\n-\n-    #[test]\n-    fn test_read_write_le_mem() {\n-        let uints = [0, 1, 2, 42, 10_123, 100_123_456, ::u64::MAX];\n-\n-        let mut writer = Vec::new();\n-        for i in &uints {\n-            writer.write_le_u64(*i).unwrap();\n-        }\n-\n-        let mut reader = MemReader::new(writer);\n-        for i in &uints {\n-            assert!(reader.read_le_u64().unwrap() == *i);\n-        }\n-    }\n-\n-\n-    #[test]\n-    fn test_read_write_be() {\n-        let uints = [0, 1, 2, 42, 10_123, 100_123_456, ::u64::MAX];\n-\n-        let mut writer = Vec::new();\n-        for i in &uints {\n-            writer.write_be_u64(*i).unwrap();\n-        }\n-\n-        let mut reader = MemReader::new(writer);\n-        for i in &uints {\n-            assert!(reader.read_be_u64().unwrap() == *i);\n-        }\n-    }\n-\n-    #[test]\n-    fn test_read_be_int_n() {\n-        let ints = [::i32::MIN, -123456, -42, -5, 0, 1, ::i32::MAX];\n-\n-        let mut writer = Vec::new();\n-        for i in &ints {\n-            writer.write_be_i32(*i).unwrap();\n-        }\n-\n-        let mut reader = MemReader::new(writer);\n-        for i in &ints {\n-            // this tests that the sign extension is working\n-            // (comparing the values as i32 would not test this)\n-            assert!(reader.read_be_int_n(4).unwrap() == *i as i64);\n-        }\n-    }\n-\n-    #[test]\n-    fn test_read_f32() {\n-        //big-endian floating-point 8.1250\n-        let buf = vec![0x41, 0x02, 0x00, 0x00];\n-\n-        let mut writer = Vec::new();\n-        writer.write(&buf).unwrap();\n-\n-        let mut reader = MemReader::new(writer);\n-        let f = reader.read_be_f32().unwrap();\n-        assert!(f == 8.1250);\n-    }\n-\n-    #[test]\n-    fn test_read_write_f32() {\n-        let f:f32 = 8.1250;\n-\n-        let mut writer = Vec::new();\n-        writer.write_be_f32(f).unwrap();\n-        writer.write_le_f32(f).unwrap();\n-\n-        let mut reader = MemReader::new(writer);\n-        assert!(reader.read_be_f32().unwrap() == 8.1250);\n-        assert!(reader.read_le_f32().unwrap() == 8.1250);\n-    }\n-\n-    #[test]\n-    fn test_u64_from_be_bytes() {\n-        use super::u64_from_be_bytes;\n-\n-        let buf = [0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09];\n-\n-        // Aligned access\n-        assert_eq!(u64_from_be_bytes(&buf, 0, 0), 0);\n-        assert_eq!(u64_from_be_bytes(&buf, 0, 1), 0x01);\n-        assert_eq!(u64_from_be_bytes(&buf, 0, 2), 0x0102);\n-        assert_eq!(u64_from_be_bytes(&buf, 0, 3), 0x010203);\n-        assert_eq!(u64_from_be_bytes(&buf, 0, 4), 0x01020304);\n-        assert_eq!(u64_from_be_bytes(&buf, 0, 5), 0x0102030405);\n-        assert_eq!(u64_from_be_bytes(&buf, 0, 6), 0x010203040506);\n-        assert_eq!(u64_from_be_bytes(&buf, 0, 7), 0x01020304050607);\n-        assert_eq!(u64_from_be_bytes(&buf, 0, 8), 0x0102030405060708);\n-\n-        // Unaligned access\n-        assert_eq!(u64_from_be_bytes(&buf, 1, 0), 0);\n-        assert_eq!(u64_from_be_bytes(&buf, 1, 1), 0x02);\n-        assert_eq!(u64_from_be_bytes(&buf, 1, 2), 0x0203);\n-        assert_eq!(u64_from_be_bytes(&buf, 1, 3), 0x020304);\n-        assert_eq!(u64_from_be_bytes(&buf, 1, 4), 0x02030405);\n-        assert_eq!(u64_from_be_bytes(&buf, 1, 5), 0x0203040506);\n-        assert_eq!(u64_from_be_bytes(&buf, 1, 6), 0x020304050607);\n-        assert_eq!(u64_from_be_bytes(&buf, 1, 7), 0x02030405060708);\n-        assert_eq!(u64_from_be_bytes(&buf, 1, 8), 0x0203040506070809);\n-    }\n-}\n-\n-#[cfg(test)]\n-mod bench {\n-    extern crate test;\n-\n-    use prelude::v1::*;\n-    use self::test::Bencher;\n-\n-    // why is this a macro? wouldn't an inlined function work just as well?\n-    macro_rules! u64_from_be_bytes_bench_impl {\n-        ($b:expr, $size:expr, $stride:expr, $start_index:expr) =>\n-        ({\n-            use super::u64_from_be_bytes;\n-\n-            let len = ($stride as u8).wrapping_mul(100).wrapping_add($start_index);\n-            let data = (0..len).collect::<Vec<_>>();\n-            let mut sum = 0;\n-            $b.iter(|| {\n-                let mut i = $start_index;\n-                while i < data.len() {\n-                    sum += u64_from_be_bytes(&data, i, $size);\n-                    i += $stride;\n-                }\n-            });\n-        })\n-    }\n-\n-    #[bench]\n-    fn u64_from_be_bytes_4_aligned(b: &mut Bencher) {\n-        u64_from_be_bytes_bench_impl!(b, 4, 4, 0);\n-    }\n-\n-    #[bench]\n-    fn u64_from_be_bytes_4_unaligned(b: &mut Bencher) {\n-        u64_from_be_bytes_bench_impl!(b, 4, 4, 1);\n-    }\n-\n-    #[bench]\n-    fn u64_from_be_bytes_7_aligned(b: &mut Bencher) {\n-        u64_from_be_bytes_bench_impl!(b, 7, 8, 0);\n-    }\n-\n-    #[bench]\n-    fn u64_from_be_bytes_7_unaligned(b: &mut Bencher) {\n-        u64_from_be_bytes_bench_impl!(b, 7, 8, 1);\n-    }\n-\n-    #[bench]\n-    fn u64_from_be_bytes_8_aligned(b: &mut Bencher) {\n-        u64_from_be_bytes_bench_impl!(b, 8, 8, 0);\n-    }\n-\n-    #[bench]\n-    fn u64_from_be_bytes_8_unaligned(b: &mut Bencher) {\n-        u64_from_be_bytes_bench_impl!(b, 8, 8, 1);\n-    }\n-}"}, {"sha": "509daa46ef3be1b509d54da638c27590b8d2dff5", "filename": "src/libstd/old_io/fs.rs", "status": "removed", "additions": 0, "deletions": 1654, "changes": 1654, "blob_url": "https://github.com/rust-lang/rust/blob/8415fa27877a4309a79b08c75a52eb4c3546b7a5/src%2Flibstd%2Fold_io%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8415fa27877a4309a79b08c75a52eb4c3546b7a5/src%2Flibstd%2Fold_io%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Ffs.rs?ref=8415fa27877a4309a79b08c75a52eb4c3546b7a5", "patch": "@@ -1,1654 +0,0 @@\n-// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-//\n-// ignore-lexer-test FIXME #15679\n-\n-//! Synchronous File I/O\n-//!\n-//! This module provides a set of functions and traits for working\n-//! with regular files & directories on a filesystem.\n-//!\n-//! At the top-level of the module are a set of freestanding functions, associated\n-//! with various filesystem operations. They all operate on `Path` objects.\n-//!\n-//! All operations in this module, including those as part of `File` et al block\n-//! the task during execution. In the event of failure, all functions/methods\n-//! will return an `IoResult` type with an `Err` value.\n-//!\n-//! Also included in this module is an implementation block on the `Path` object\n-//! defined in `std::path::Path`. The impl adds useful methods about inspecting\n-//! the metadata of a file. This includes getting the `stat` information,\n-//! reading off particular bits of it, etc.\n-//!\n-//! # Examples\n-//!\n-//! ```rust\n-//! # #![feature(old_io, io, old_path)]\n-//! # #![allow(unused_must_use)]\n-//! use std::old_io::fs::PathExtensions;\n-//! use std::old_io::*;\n-//! use std::old_path::Path;\n-//!\n-//! let path = Path::new(\"foo.txt\");\n-//!\n-//! // create the file, whether it exists or not\n-//! let mut file = File::create(&path);\n-//! file.write(b\"foobar\");\n-//! # drop(file);\n-//!\n-//! // open the file in read-only mode\n-//! let mut file = File::open(&path);\n-//! file.read_to_end();\n-//!\n-//! println!(\"{}\", path.stat().unwrap().size);\n-//! # drop(file);\n-//! fs::unlink(&path);\n-//! ```\n-\n-use clone::Clone;\n-use old_io::standard_error;\n-use old_io::{FilePermission, Write, Open, FileAccess, FileMode, FileType};\n-use old_io::{IoResult, IoError, InvalidInput};\n-use old_io::{FileStat, SeekStyle, Seek, Writer, Reader};\n-use old_io::{Read, Truncate, ReadWrite, Append};\n-use old_io::UpdateIoError;\n-use old_io;\n-use iter::{Iterator, Extend};\n-use option::Option;\n-use option::Option::{Some, None};\n-use old_path::{Path, GenericPath};\n-use old_path;\n-use result::Result::{Err, Ok};\n-use string::String;\n-use vec::Vec;\n-\n-use sys::fs as fs_imp;\n-use sys_common;\n-\n-/// Unconstrained file access type that exposes read and write operations\n-///\n-/// Can be constructed via `File::open()`, `File::create()`, and\n-/// `File::open_mode()`.\n-///\n-/// # Error\n-///\n-/// This type will return errors as an `IoResult<T>` if operations are\n-/// attempted against it for which its underlying file descriptor was not\n-/// configured at creation time, via the `FileAccess` parameter to\n-/// `File::open_mode()`.\n-#[deprecated(since = \"1.0.0\", reason = \"replaced with std::fs::File\")]\n-#[unstable(feature = \"old_io\")]\n-pub struct File {\n-    fd: fs_imp::FileDesc,\n-    path: Path,\n-    last_nread: isize,\n-}\n-\n-impl sys_common::AsInner<fs_imp::FileDesc> for File {\n-    fn as_inner(&self) -> &fs_imp::FileDesc {\n-        &self.fd\n-    }\n-}\n-\n-#[deprecated(since = \"1.0.0\", reason = \"replaced with std::fs\")]\n-#[unstable(feature = \"old_io\")]\n-impl File {\n-    /// Open a file at `path` in the mode specified by the `mode` and `access`\n-    /// arguments\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```rust,should_panic\n-    /// # #![feature(old_io, old_path)]\n-    /// use std::old_io::*;\n-    /// use std::old_path::Path;\n-    ///\n-    /// let p = Path::new(\"/some/file/path.txt\");\n-    ///\n-    /// let file = match File::open_mode(&p, Open, ReadWrite) {\n-    ///     Ok(f) => f,\n-    ///     Err(e) => panic!(\"file error: {}\", e),\n-    /// };\n-    /// // do some stuff with that file\n-    ///\n-    /// // the file will be closed at the end of this block\n-    /// ```\n-    ///\n-    /// `FileMode` and `FileAccess` provide information about the permissions\n-    /// context in which a given stream is created. More information about them\n-    /// can be found in `std::io`'s docs. If a file is opened with `Write`\n-    /// or `ReadWrite` access, then it will be created if it does not already\n-    /// exist.\n-    ///\n-    /// Note that, with this function, a `File` is returned regardless of the\n-    /// access-limitations indicated by `FileAccess` (e.g. calling `write` on a\n-    /// `File` opened as `Read` will return an error at runtime).\n-    ///\n-    /// # Error\n-    ///\n-    /// This function will return an error under a number of different\n-    /// circumstances, to include but not limited to:\n-    ///\n-    /// * Opening a file that does not exist with `Read` access.\n-    /// * Attempting to open a file with a `FileAccess` that the user lacks\n-    ///   permissions for\n-    /// * Filesystem-level errors (full disk, etc)\n-    #[deprecated(since = \"1.0.0\", reason = \"replaced with std::fs::OpenOptions\")]\n-    #[unstable(feature = \"old_io\")]\n-    pub fn open_mode(path: &Path,\n-                     mode: FileMode,\n-                     access: FileAccess) -> IoResult<File> {\n-        fs_imp::open(path, mode, access).and_then(|fd| {\n-            // On *BSD systems, we can open a directory as a file and read from it:\n-            // fd=open(\"/tmp\", O_RDONLY); read(fd, buf, N);\n-            // due to an old tradition before the introduction of opendir(3).\n-            // We explicitly reject it because there are few use cases.\n-            if cfg!(not(any(windows, target_os = \"linux\", target_os = \"android\"))) &&\n-               try!(fd.fstat()).kind == FileType::Directory {\n-                Err(IoError {\n-                    kind: InvalidInput,\n-                    desc: \"is a directory\",\n-                    detail: None\n-                })\n-            } else {\n-                Ok(File {\n-                    path: path.clone(),\n-                    fd: fd,\n-                    last_nread: -1\n-                })\n-            }\n-        }).update_err(\"couldn't open path as file\", |e| {\n-            format!(\"{}; path={}; mode={}; access={}\", e, path.display(),\n-                mode_string(mode), access_string(access))\n-        })\n-    }\n-\n-    /// Attempts to open a file in read-only mode. This function is equivalent to\n-    /// `File::open_mode(path, Open, Read)`, and will raise all of the same\n-    /// errors that `File::open_mode` does.\n-    ///\n-    /// For more information, see the `File::open_mode` function.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// # #![feature(old_io, old_path)]\n-    /// use std::old_io::*;\n-    /// use std::old_path::Path;\n-    ///\n-    /// let contents = File::open(&Path::new(\"foo.txt\")).read_to_end();\n-    /// ```\n-    #[deprecated(since = \"1.0.0\", reason = \"replaced with std::fs::File::open\")]\n-    #[unstable(feature = \"old_io\")]\n-    pub fn open(path: &Path) -> IoResult<File> {\n-        File::open_mode(path, Open, Read)\n-    }\n-\n-    /// Attempts to create a file in write-only mode. This function is\n-    /// equivalent to `File::open_mode(path, Truncate, Write)`, and will\n-    /// raise all of the same errors that `File::open_mode` does.\n-    ///\n-    /// For more information, see the `File::open_mode` function.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// # #![feature(old_io, old_path, io)]\n-    /// # #![allow(unused_must_use)]\n-    /// use std::old_io::*;\n-    /// use std::old_path::Path;\n-    ///\n-    /// let mut f = File::create(&Path::new(\"foo.txt\"));\n-    /// f.write(b\"This is a sample file\");\n-    /// # drop(f);\n-    /// # ::std::old_io::fs::unlink(&Path::new(\"foo.txt\"));\n-    /// ```\n-    #[deprecated(since = \"1.0.0\", reason = \"replaced with std::fs::File::create\")]\n-    #[unstable(feature = \"old_io\")]\n-    pub fn create(path: &Path) -> IoResult<File> {\n-        File::open_mode(path, Truncate, Write)\n-             .update_desc(\"couldn't create file\")\n-    }\n-\n-    /// Returns the original path that was used to open this file.\n-    #[deprecated(since = \"1.0.0\", reason = \"replaced with std::fs\")]\n-    #[unstable(feature = \"old_io\")]\n-    pub fn path<'a>(&'a self) -> &'a Path {\n-        &self.path\n-    }\n-\n-    /// Synchronizes all modifications to this file to its permanent storage\n-    /// device. This will flush any internal buffers necessary to perform this\n-    /// operation.\n-    #[deprecated(since = \"1.0.0\", reason = \"replaced with std::fs\")]\n-    #[unstable(feature = \"old_io\")]\n-    pub fn fsync(&mut self) -> IoResult<()> {\n-        self.fd.fsync()\n-            .update_err(\"couldn't fsync file\",\n-                        |e| format!(\"{}; path={}\", e, self.path.display()))\n-    }\n-\n-    /// This function is similar to `fsync`, except that it may not synchronize\n-    /// file metadata to the filesystem. This is intended for use cases that\n-    /// must synchronize content, but don't need the metadata on disk. The goal\n-    /// of this method is to reduce disk operations.\n-    #[deprecated(since = \"1.0.0\", reason = \"replaced with std::fs\")]\n-    #[unstable(feature = \"old_io\")]\n-    pub fn datasync(&mut self) -> IoResult<()> {\n-        self.fd.datasync()\n-            .update_err(\"couldn't datasync file\",\n-                        |e| format!(\"{}; path={}\", e, self.path.display()))\n-    }\n-\n-    /// Either truncates or extends the underlying file, updating the size of\n-    /// this file to become `size`. This is equivalent to unix's `truncate`\n-    /// function.\n-    ///\n-    /// If the `size` is less than the current file's size, then the file will\n-    /// be shrunk. If it is greater than the current file's size, then the file\n-    /// will be extended to `size` and have all of the intermediate data filled\n-    /// in with 0s.\n-    #[deprecated(since = \"1.0.0\", reason = \"replaced with std::fs\")]\n-    #[unstable(feature = \"old_io\")]\n-    pub fn truncate(&mut self, size: i64) -> IoResult<()> {\n-        self.fd.truncate(size)\n-            .update_err(\"couldn't truncate file\", |e|\n-                format!(\"{}; path={}; size={}\", e, self.path.display(), size))\n-    }\n-\n-    /// Returns true if the stream has reached the end of the file.\n-    ///\n-    /// If true, then this file will no longer continue to return data via\n-    /// `read`.\n-    ///\n-    /// Note that the operating system will not return an `EOF` indicator\n-    /// until you have attempted to read past the end of the file, so if\n-    /// you've read _exactly_ the number of bytes in the file, this will\n-    /// return `false`, not `true`.\n-    #[deprecated(since = \"1.0.0\", reason = \"replaced with std::fs\")]\n-    #[unstable(feature = \"old_io\")]\n-    pub fn eof(&self) -> bool {\n-        self.last_nread == 0\n-    }\n-\n-    /// Queries information about the underlying file.\n-    #[deprecated(since = \"1.0.0\", reason = \"replaced with std::fs\")]\n-    #[unstable(feature = \"old_io\")]\n-    pub fn stat(&self) -> IoResult<FileStat> {\n-        self.fd.fstat()\n-            .update_err(\"couldn't fstat file\", |e|\n-                format!(\"{}; path={}\", e, self.path.display()))\n-    }\n-}\n-\n-/// Unlink a file from the underlying filesystem.\n-///\n-/// # Examples\n-///\n-/// ```\n-/// # #![feature(old_io, old_path)]\n-/// # #![allow(unused_must_use)]\n-/// use std::old_io::*;\n-/// use std::old_path::Path;\n-///\n-/// let p = Path::new(\"/some/file/path.txt\");\n-/// fs::unlink(&p);\n-/// ```\n-///\n-/// Note that, just because an unlink call was successful, it is not\n-/// guaranteed that a file is immediately deleted (e.g. depending on\n-/// platform, other open file descriptors may prevent immediate removal)\n-///\n-/// # Error\n-///\n-/// This function will return an error if `path` points to a directory, if the\n-/// user lacks permissions to remove the file, or if some other filesystem-level\n-/// error occurs.\n-#[deprecated(since = \"1.0.0\", reason = \"replaced with std::fs::remove_file\")]\n-#[unstable(feature = \"old_io\")]\n-pub fn unlink(path: &Path) -> IoResult<()> {\n-    fs_imp::unlink(path)\n-           .update_err(\"couldn't unlink path\", |e|\n-               format!(\"{}; path={}\", e, path.display()))\n-}\n-\n-/// Given a path, query the file system to get information about a file,\n-/// directory, etc. This function will traverse symlinks to query\n-/// information about the destination file.\n-///\n-/// # Examples\n-///\n-/// ```\n-/// # #![feature(old_io, old_path)]\n-/// use std::old_io::*;\n-/// use std::old_path::Path;\n-///\n-/// let p = Path::new(\"/some/file/path.txt\");\n-/// match fs::stat(&p) {\n-///     Ok(stat) => { /* ... */ }\n-///     Err(e) => { /* handle error */ }\n-/// }\n-/// ```\n-///\n-/// # Error\n-///\n-/// This function will return an error if the user lacks the requisite permissions\n-/// to perform a `stat` call on the given `path` or if there is no entry in the\n-/// filesystem at the provided path.\n-#[deprecated(since = \"1.0.0\", reason = \"replaced with std::fs::metadata\")]\n-#[unstable(feature = \"old_io\")]\n-pub fn stat(path: &Path) -> IoResult<FileStat> {\n-    fs_imp::stat(path)\n-           .update_err(\"couldn't stat path\", |e|\n-               format!(\"{}; path={}\", e, path.display()))\n-}\n-\n-/// Perform the same operation as the `stat` function, except that this\n-/// function does not traverse through symlinks. This will return\n-/// information about the symlink file instead of the file that it points\n-/// to.\n-///\n-/// # Error\n-///\n-/// See `stat`\n-#[unstable(feature = \"old_fs\")]\n-pub fn lstat(path: &Path) -> IoResult<FileStat> {\n-    fs_imp::lstat(path)\n-           .update_err(\"couldn't lstat path\", |e|\n-               format!(\"{}; path={}\", e, path.display()))\n-}\n-\n-/// Rename a file or directory to a new name.\n-///\n-/// # Examples\n-///\n-/// ```\n-/// # #![feature(old_io, old_path)]\n-/// # #![allow(unused_must_use)]\n-/// use std::old_io::*;\n-/// use std::old_path::Path;\n-///\n-/// fs::rename(&Path::new(\"foo\"), &Path::new(\"bar\"));\n-/// ```\n-///\n-/// # Error\n-///\n-/// This function will return an error if the provided `from` doesn't exist, if\n-/// the process lacks permissions to view the contents, or if some other\n-/// intermittent I/O error occurs.\n-#[deprecated(since = \"1.0.0\", reason = \"replaced with std::fs::rename\")]\n-#[unstable(feature = \"old_io\")]\n-pub fn rename(from: &Path, to: &Path) -> IoResult<()> {\n-    fs_imp::rename(from, to)\n-           .update_err(\"couldn't rename path\", |e|\n-               format!(\"{}; from={:?}; to={:?}\", e, from.display(), to.display()))\n-}\n-\n-/// Copies the contents of one file to another. This function will also\n-/// copy the permission bits of the original file to the destination file.\n-///\n-/// Note that if `from` and `to` both point to the same file, then the file\n-/// will likely get truncated by this operation.\n-///\n-/// # Examples\n-///\n-/// ```\n-/// # #![feature(old_io, old_path)]\n-/// # #![allow(unused_must_use)]\n-/// use std::old_io::*;\n-/// use std::old_path::Path;\n-///\n-/// fs::copy(&Path::new(\"foo.txt\"), &Path::new(\"bar.txt\"));\n-/// ```\n-///\n-/// # Error\n-///\n-/// This function will return an error in the following situations, but is not\n-/// limited to just these cases:\n-///\n-/// * The `from` path is not a file\n-/// * The `from` file does not exist\n-/// * The current process does not have the permission rights to access\n-///   `from` or write `to`\n-///\n-/// Note that this copy is not atomic in that once the destination is\n-/// ensured to not exist, there is nothing preventing the destination from\n-/// being created and then destroyed by this operation.\n-#[deprecated(since = \"1.0.0\", reason = \"replaced with std::fs::copy\")]\n-#[unstable(feature = \"old_io\")]\n-pub fn copy(from: &Path, to: &Path) -> IoResult<()> {\n-    fn update_err<T>(result: IoResult<T>, from: &Path, to: &Path) -> IoResult<T> {\n-        result.update_err(\"couldn't copy path\", |e| {\n-            format!(\"{}; from={:?}; to={:?}\", e, from.display(), to.display())\n-        })\n-    }\n-\n-    if !from.is_file() {\n-        return update_err(Err(IoError {\n-            kind: old_io::MismatchedFileTypeForOperation,\n-            desc: \"the source path is not an existing file\",\n-            detail: None\n-        }), from, to)\n-    }\n-\n-    let mut reader = try!(File::open(from));\n-    let mut writer = try!(File::create(to));\n-\n-    try!(update_err(super::util::copy(&mut reader, &mut writer), from, to));\n-\n-    chmod(to, try!(update_err(from.stat(), from, to)).perm)\n-}\n-\n-/// Changes the permission mode bits found on a file or a directory. This\n-/// function takes a mask from the `io` module\n-///\n-/// # Examples\n-///\n-/// ```\n-/// # #![feature(old_io, old_path)]\n-/// # #![allow(unused_must_use)]\n-/// use std::old_io;\n-/// use std::old_io::*;\n-/// use std::old_path::Path;\n-///\n-/// fs::chmod(&Path::new(\"file.txt\"), old_io::USER_FILE);\n-/// fs::chmod(&Path::new(\"file.txt\"), old_io::USER_READ | old_io::USER_WRITE);\n-/// fs::chmod(&Path::new(\"dir\"),      old_io::USER_DIR);\n-/// fs::chmod(&Path::new(\"file.exe\"), old_io::USER_EXEC);\n-/// ```\n-///\n-/// # Error\n-///\n-/// This function will return an error if the provided `path` doesn't exist, if\n-/// the process lacks permissions to change the attributes of the file, or if\n-/// some other I/O error is encountered.\n-#[deprecated(since = \"1.0.0\", reason = \"replaced with std::fs::set_permissions\")]\n-#[unstable(feature = \"old_io\")]\n-pub fn chmod(path: &Path, mode: old_io::FilePermission) -> IoResult<()> {\n-    fs_imp::chmod(path, mode.bits() as usize)\n-           .update_err(\"couldn't chmod path\", |e|\n-               format!(\"{}; path={}; mode={:?}\", e, path.display(), mode))\n-}\n-\n-/// Change the user and group owners of a file at the specified path.\n-#[unstable(feature = \"old_fs\")]\n-pub fn chown(path: &Path, uid: isize, gid: isize) -> IoResult<()> {\n-    fs_imp::chown(path, uid, gid)\n-           .update_err(\"couldn't chown path\", |e|\n-               format!(\"{}; path={}; uid={}; gid={}\", e, path.display(), uid, gid))\n-}\n-\n-/// Creates a new hard link on the filesystem. The `dst` path will be a\n-/// link pointing to the `src` path. Note that systems often require these\n-/// two paths to both be located on the same filesystem.\n-#[deprecated(since = \"1.0.0\", reason = \"replaced with std::fs::hard_link\")]\n-#[unstable(feature = \"old_io\")]\n-pub fn link(src: &Path, dst: &Path) -> IoResult<()> {\n-    fs_imp::link(src, dst)\n-           .update_err(\"couldn't link path\", |e|\n-               format!(\"{}; src={:?}; dest={:?}\", e, src.display(), dst.display()))\n-}\n-\n-/// Creates a new symbolic link on the filesystem. The `dst` path will be a\n-/// symlink pointing to the `src` path.\n-#[deprecated(since = \"1.0.0\", reason = \"replaced with std::fs::soft_link\")]\n-#[unstable(feature = \"old_io\")]\n-pub fn symlink(src: &Path, dst: &Path) -> IoResult<()> {\n-    fs_imp::symlink(src, dst)\n-           .update_err(\"couldn't symlink path\", |e|\n-               format!(\"{}; src={:?}; dest={:?}\", e, src.display(), dst.display()))\n-}\n-\n-/// Reads a symlink, returning the file that the symlink points to.\n-///\n-/// # Error\n-///\n-/// This function will return an error on failure. Failure conditions include\n-/// reading a file that does not exist or reading a file that is not a symlink.\n-#[deprecated(since = \"1.0.0\", reason = \"replaced with std::fs::read_link\")]\n-#[unstable(feature = \"old_io\")]\n-pub fn readlink(path: &Path) -> IoResult<Path> {\n-    fs_imp::readlink(path)\n-           .update_err(\"couldn't resolve symlink for path\", |e|\n-               format!(\"{}; path={}\", e, path.display()))\n-}\n-\n-/// Create a new, empty directory at the provided path\n-///\n-/// # Examples\n-///\n-/// ```\n-/// # #![feature(old_io, old_path, old_fs)]\n-/// # #![allow(unused_must_use)]\n-/// use std::old_io;\n-/// use std::old_io::*;\n-/// use std::old_path::Path;\n-///\n-/// let p = Path::new(\"/some/dir\");\n-/// fs::mkdir(&p, old_io::USER_RWX);\n-/// ```\n-///\n-/// # Error\n-///\n-/// This function will return an error if the user lacks permissions to make a\n-/// new directory at the provided `path`, or if the directory already exists.\n-#[unstable(feature = \"old_fs\")]\n-pub fn mkdir(path: &Path, mode: FilePermission) -> IoResult<()> {\n-    fs_imp::mkdir(path, mode.bits() as usize)\n-           .update_err(\"couldn't create directory\", |e|\n-               format!(\"{}; path={}; mode={}\", e, path.display(), mode))\n-}\n-\n-/// Remove an existing, empty directory\n-///\n-/// # Examples\n-///\n-/// ```\n-/// # #![feature(old_io, old_path)]\n-/// # #![allow(unused_must_use)]\n-/// use std::old_io::*;\n-/// use std::old_path::Path;\n-///\n-/// let p = Path::new(\"/some/dir\");\n-/// fs::rmdir(&p);\n-/// ```\n-///\n-/// # Error\n-///\n-/// This function will return an error if the user lacks permissions to remove\n-/// the directory at the provided `path`, or if the directory isn't empty.\n-#[deprecated(since = \"1.0.0\", reason = \"replaced with std::fs::remove_dir\")]\n-#[unstable(feature = \"old_io\")]\n-pub fn rmdir(path: &Path) -> IoResult<()> {\n-    fs_imp::rmdir(path)\n-           .update_err(\"couldn't remove directory\", |e|\n-               format!(\"{}; path={}\", e, path.display()))\n-}\n-\n-/// Retrieve a vector containing all entries within a provided directory\n-///\n-/// # Examples\n-///\n-/// ```\n-/// # #![feature(old_io, old_path)]\n-/// use std::old_io::fs::PathExtensions;\n-/// use std::old_io;\n-/// use std::old_io::*;\n-/// use std::old_path::Path;\n-///\n-/// // one possible implementation of fs::walk_dir only visiting files\n-/// fn visit_dirs<F>(dir: &Path, cb: &mut F) -> old_io::IoResult<()> where\n-///     F: FnMut(&Path),\n-/// {\n-///     if dir.is_dir() {\n-///         let contents = try!(fs::readdir(dir));\n-///         for entry in contents.iter() {\n-///             if entry.is_dir() {\n-///                 try!(visit_dirs(entry, cb));\n-///             } else {\n-///                 (*cb)(entry);\n-///             }\n-///         }\n-///         Ok(())\n-///     } else {\n-///         Err(old_io::standard_error(old_io::InvalidInput))\n-///     }\n-/// }\n-/// ```\n-///\n-/// # Error\n-///\n-/// This function will return an error if the provided `path` doesn't exist, if\n-/// the process lacks permissions to view the contents or if the `path` points\n-/// at a non-directory file\n-#[deprecated(since = \"1.0.0\", reason = \"replaced with std::fs::read_dir\")]\n-#[unstable(feature = \"old_io\")]\n-pub fn readdir(path: &Path) -> IoResult<Vec<Path>> {\n-    fs_imp::readdir(path)\n-           .update_err(\"couldn't read directory\",\n-                       |e| format!(\"{}; path={}\", e, path.display()))\n-}\n-\n-/// Returns an iterator that will recursively walk the directory structure\n-/// rooted at `path`. The path given will not be iterated over, and this will\n-/// perform iteration in some top-down order.  The contents of unreadable\n-/// subdirectories are ignored.\n-#[deprecated(since = \"1.0.0\", reason = \"replaced with std::fs::walk_dir\")]\n-#[unstable(feature = \"old_io\")]\n-pub fn walk_dir(path: &Path) -> IoResult<Directories> {\n-    Ok(Directories {\n-        stack: try!(readdir(path).update_err(\"couldn't walk directory\",\n-                                             |e| format!(\"{}; path={}\", e, path.display())))\n-    })\n-}\n-\n-/// An iterator that walks over a directory\n-#[derive(Clone)]\n-#[deprecated(since = \"1.0.0\", reason = \"replaced with std::fs::ReadDir\")]\n-#[unstable(feature = \"old_io\")]\n-pub struct Directories {\n-    stack: Vec<Path>,\n-}\n-\n-impl Iterator for Directories {\n-    type Item = Path;\n-\n-    fn next(&mut self) -> Option<Path> {\n-        match self.stack.pop() {\n-            Some(path) => {\n-                if path.is_dir() {\n-                    match readdir(&path) {\n-                        Ok(dirs) => { self.stack.extend(dirs.into_iter()); }\n-                        Err(..) => {}\n-                    }\n-                }\n-                Some(path)\n-            }\n-            None => None\n-        }\n-    }\n-}\n-\n-/// Recursively create a directory and all of its parent components if they\n-/// are missing.\n-///\n-/// # Error\n-///\n-/// See `fs::mkdir`.\n-#[unstable(feature = \"old_fs\")]\n-pub fn mkdir_recursive(path: &Path, mode: FilePermission) -> IoResult<()> {\n-    // tjc: if directory exists but with different permissions,\n-    // should we return false?\n-    if path.is_dir() {\n-        return Ok(())\n-    }\n-\n-    let comps = path.components();\n-    let mut curpath = path.root_path().unwrap_or(Path::new(\".\"));\n-\n-    for c in comps {\n-        curpath.push(c);\n-\n-        let result = mkdir(&curpath, mode)\n-            .update_err(\"couldn't recursively mkdir\",\n-                        |e| format!(\"{}; path={}\", e, path.display()));\n-\n-        match result {\n-            Err(mkdir_err) => {\n-                // already exists ?\n-                if try!(stat(&curpath)).kind != FileType::Directory {\n-                    return Err(mkdir_err);\n-                }\n-            }\n-            Ok(()) => ()\n-        }\n-    }\n-\n-    Ok(())\n-}\n-\n-/// Removes a directory at this path, after removing all its contents. Use\n-/// carefully!\n-///\n-/// # Error\n-///\n-/// See `file::unlink` and `fs::readdir`\n-#[deprecated(since = \"1.0.0\", reason = \"replaced with std::fs::remove_dir_all\")]\n-#[unstable(feature = \"old_io\")]\n-pub fn rmdir_recursive(path: &Path) -> IoResult<()> {\n-    let mut rm_stack = Vec::new();\n-    rm_stack.push(path.clone());\n-\n-    fn rmdir_failed(err: &IoError, path: &Path) -> String {\n-        format!(\"rmdir_recursive failed; path={}; cause={}\",\n-                path.display(), err)\n-    }\n-\n-    fn update_err<T>(err: IoResult<T>, path: &Path) -> IoResult<T> {\n-        err.update_err(\"couldn't recursively rmdir\",\n-                       |e| rmdir_failed(e, path))\n-    }\n-\n-    while !rm_stack.is_empty() {\n-        let children = try!(readdir(rm_stack.last().unwrap())\n-            .update_detail(|e| rmdir_failed(e, path)));\n-\n-        let mut has_child_dir = false;\n-\n-        // delete all regular files in the way and push subdirs\n-        // on the stack\n-        for child in children {\n-            // FIXME(#12795) we should use lstat in all cases\n-            let child_type = match cfg!(windows) {\n-                true => try!(update_err(stat(&child), path)),\n-                false => try!(update_err(lstat(&child), path))\n-            };\n-\n-            if child_type.kind == FileType::Directory {\n-                rm_stack.push(child);\n-                has_child_dir = true;\n-            } else {\n-                // we can carry on safely if the file is already gone\n-                // (eg: deleted by someone else since readdir)\n-                match update_err(unlink(&child), path) {\n-                    Ok(()) => (),\n-                    Err(ref e) if e.kind == old_io::FileNotFound => (),\n-                    Err(e) => return Err(e)\n-                }\n-            }\n-        }\n-\n-        // if no subdir was found, let's pop and delete\n-        if !has_child_dir {\n-            let result = update_err(rmdir(&rm_stack.pop().unwrap()), path);\n-            match result {\n-                Ok(()) => (),\n-                Err(ref e) if e.kind == old_io::FileNotFound => (),\n-                Err(e) => return Err(e)\n-            }\n-        }\n-    }\n-\n-    Ok(())\n-}\n-\n-/// Changes the timestamps for a file's last modification and access time.\n-/// The file at the path specified will have its last access time set to\n-/// `atime` and its modification time set to `mtime`. The times specified should\n-/// be in milliseconds.\n-// FIXME(#10301) these arguments should not be u64\n-#[deprecated(since = \"1.0.0\", reason = \"replaced with std::fs::set_file_times\")]\n-#[unstable(feature = \"old_io\")]\n-pub fn change_file_times(path: &Path, atime: u64, mtime: u64) -> IoResult<()> {\n-    fs_imp::utime(path, atime, mtime)\n-           .update_err(\"couldn't change_file_times\", |e|\n-               format!(\"{}; path={}\", e, path.display()))\n-}\n-\n-impl Reader for File {\n-    fn read(&mut self, buf: &mut [u8]) -> IoResult<usize> {\n-        fn update_err<T>(result: IoResult<T>, file: &File) -> IoResult<T> {\n-            result.update_err(\"couldn't read file\",\n-                              |e| format!(\"{}; path={}\",\n-                                          e, file.path.display()))\n-        }\n-\n-        let result = update_err(self.fd.read(buf), self);\n-\n-        match result {\n-            Ok(read) => {\n-                self.last_nread = read as isize;\n-                match read {\n-                    0 => update_err(Err(standard_error(old_io::EndOfFile)), self),\n-                    _ => Ok(read as usize)\n-                }\n-            },\n-            Err(e) => Err(e)\n-        }\n-    }\n-}\n-\n-impl Writer for File {\n-    fn write_all(&mut self, buf: &[u8]) -> IoResult<()> {\n-        self.fd.write(buf)\n-            .update_err(\"couldn't write to file\",\n-                        |e| format!(\"{}; path={}\", e, self.path.display()))\n-    }\n-}\n-\n-impl Seek for File {\n-    fn tell(&self) -> IoResult<u64> {\n-        self.fd.tell()\n-            .update_err(\"couldn't retrieve file cursor (`tell`)\",\n-                        |e| format!(\"{}; path={}\", e, self.path.display()))\n-    }\n-\n-    fn seek(&mut self, pos: i64, style: SeekStyle) -> IoResult<()> {\n-        let err = match self.fd.seek(pos, style) {\n-            Ok(_) => {\n-                // successful seek resets EOF indicator\n-                self.last_nread = -1;\n-                Ok(())\n-            }\n-            Err(e) => Err(e),\n-        };\n-        err.update_err(\"couldn't seek in file\",\n-                       |e| format!(\"{}; path={}\", e, self.path.display()))\n-    }\n-}\n-\n-/// Utility methods for paths.\n-#[deprecated(since = \"1.0.0\", reason = \"replaced with std::fs::PathExt\")]\n-#[unstable(feature = \"old_io\")]\n-pub trait PathExtensions {\n-    /// Get information on the file, directory, etc at this path.\n-    ///\n-    /// Consult the `fs::stat` documentation for more info.\n-    ///\n-    /// This call preserves identical runtime/error semantics with `file::stat`.\n-    fn stat(&self) -> IoResult<FileStat>;\n-\n-    /// Get information on the file, directory, etc at this path, not following\n-    /// symlinks.\n-    ///\n-    /// Consult the `fs::lstat` documentation for more info.\n-    ///\n-    /// This call preserves identical runtime/error semantics with `file::lstat`.\n-    fn lstat(&self) -> IoResult<FileStat>;\n-\n-    /// Boolean value indicator whether the underlying file exists on the local\n-    /// filesystem. Returns false in exactly the cases where `fs::stat` fails.\n-    fn exists(&self) -> bool;\n-\n-    /// Whether the underlying implementation (be it a file path, or something\n-    /// else) points at a \"regular file\" on the FS. Will return false for paths\n-    /// to non-existent locations or directories or other non-regular files\n-    /// (named pipes, etc). Follows links when making this determination.\n-    fn is_file(&self) -> bool;\n-\n-    /// Whether the underlying implementation (be it a file path, or something\n-    /// else) is pointing at a directory in the underlying FS. Will return\n-    /// false for paths to non-existent locations or if the item is not a\n-    /// directory (eg files, named pipes, etc). Follows links when making this\n-    /// determination.\n-    fn is_dir(&self) -> bool;\n-}\n-\n-impl PathExtensions for old_path::Path {\n-    fn stat(&self) -> IoResult<FileStat> { stat(self) }\n-    fn lstat(&self) -> IoResult<FileStat> { lstat(self) }\n-    fn exists(&self) -> bool {\n-        self.stat().is_ok()\n-    }\n-    fn is_file(&self) -> bool {\n-        match self.stat() {\n-            Ok(s) => s.kind == FileType::RegularFile,\n-            Err(..) => false\n-        }\n-    }\n-    fn is_dir(&self) -> bool {\n-        match self.stat() {\n-            Ok(s) => s.kind == FileType::Directory,\n-            Err(..) => false\n-        }\n-    }\n-}\n-\n-fn mode_string(mode: FileMode) -> &'static str {\n-    match mode {\n-        super::Open => \"open\",\n-        super::Append => \"append\",\n-        super::Truncate => \"truncate\"\n-    }\n-}\n-\n-fn access_string(access: FileAccess) -> &'static str {\n-    match access {\n-        super::Read => \"read\",\n-        super::Write => \"write\",\n-        super::ReadWrite => \"readwrite\"\n-    }\n-}\n-\n-#[cfg(test)]\n-#[allow(unused_imports)]\n-#[allow(unused_variables)]\n-#[allow(unused_mut)]\n-#[allow(deprecated)] // rand\n-mod test {\n-    use prelude::v1::*;\n-    use old_io::{SeekSet, SeekCur, SeekEnd, Read, Open, ReadWrite, FileType};\n-    use old_io::{self, Reader, Writer, Seek};\n-    use old_path::{Path, GenericPath};\n-    use str;\n-    use old_io::fs::*;\n-\n-    macro_rules! check { ($e:expr) => (\n-        match $e {\n-            Ok(t) => t,\n-            Err(e) => panic!(\"{} failed with: {:?}\", stringify!($e), e),\n-        }\n-    ) }\n-\n-    macro_rules! error { ($e:expr, $s:expr) => (\n-        match $e {\n-            Ok(_) => panic!(\"Unexpected success. Should've been: {:?}\", $s),\n-            Err(ref err) => assert!(err.to_string().contains($s),\n-                                    format!(\"`{}` did not contain `{}`\", err, $s))\n-        }\n-    ) }\n-\n-    pub struct TempDir(Path);\n-\n-    impl TempDir {\n-        fn join(&self, path: &str) -> Path {\n-            let TempDir(ref p) = *self;\n-            p.join(path)\n-        }\n-\n-        fn path<'a>(&'a self) -> &'a Path {\n-            let TempDir(ref p) = *self;\n-            p\n-        }\n-    }\n-\n-    impl Drop for TempDir {\n-        fn drop(&mut self) {\n-            // Gee, seeing how we're testing the fs module I sure hope that we\n-            // at least implement this correctly!\n-            let TempDir(ref p) = *self;\n-            check!(old_io::fs::rmdir_recursive(p));\n-        }\n-    }\n-\n-    pub fn tmpdir() -> TempDir {\n-        use os;\n-        use rand;\n-        let temp = Path::new(::env::temp_dir().to_str().unwrap());\n-        let ret = temp.join(format!(\"rust-{}\", rand::random::<u32>()));\n-        check!(old_io::fs::mkdir(&ret, old_io::USER_RWX));\n-        TempDir(ret)\n-    }\n-\n-    #[test]\n-    fn file_test_io_smoke_test() {\n-        let message = \"it's alright. have a good time\";\n-        let tmpdir = tmpdir();\n-        let filename = &tmpdir.join(\"file_rt_io_file_test.txt\");\n-        {\n-            let mut write_stream = File::open_mode(filename, Open, ReadWrite);\n-            check!(write_stream.write(message.as_bytes()));\n-        }\n-        {\n-            let mut read_stream = File::open_mode(filename, Open, Read);\n-            let mut read_buf = [0; 1028];\n-            let read_str = match check!(read_stream.read(&mut read_buf)) {\n-                0 => panic!(\"shouldn't happen\"),\n-                n => str::from_utf8(&read_buf[..n]).unwrap().to_string()\n-            };\n-            assert_eq!(read_str, message);\n-        }\n-        check!(unlink(filename));\n-    }\n-\n-    #[test]\n-    fn invalid_path_raises() {\n-        let tmpdir = tmpdir();\n-        let filename = &tmpdir.join(\"file_that_does_not_exist.txt\");\n-        let result = File::open_mode(filename, Open, Read);\n-\n-        error!(result, \"couldn't open path as file\");\n-        if cfg!(unix) {\n-            error!(result, \"no such file or directory\");\n-        }\n-        error!(result, &format!(\"path={}; mode=open; access=read\", filename.display()));\n-    }\n-\n-    #[test]\n-    fn file_test_iounlinking_invalid_path_should_raise_condition() {\n-        let tmpdir = tmpdir();\n-        let filename = &tmpdir.join(\"file_another_file_that_does_not_exist.txt\");\n-\n-        let result = unlink(filename);\n-\n-        error!(result, \"couldn't unlink path\");\n-        if cfg!(unix) {\n-            error!(result, \"no such file or directory\");\n-        }\n-        error!(result, &format!(\"path={}\", filename.display()));\n-    }\n-\n-    #[test]\n-    fn file_test_io_non_positional_read() {\n-        let message: &str = \"ten-four\";\n-        let mut read_mem = [0; 8];\n-        let tmpdir = tmpdir();\n-        let filename = &tmpdir.join(\"file_rt_io_file_test_positional.txt\");\n-        {\n-            let mut rw_stream = File::open_mode(filename, Open, ReadWrite);\n-            check!(rw_stream.write(message.as_bytes()));\n-        }\n-        {\n-            let mut read_stream = File::open_mode(filename, Open, Read);\n-            {\n-                let read_buf = &mut read_mem[0..4];\n-                check!(read_stream.read(read_buf));\n-            }\n-            {\n-                let read_buf = &mut read_mem[4..8];\n-                check!(read_stream.read(read_buf));\n-            }\n-        }\n-        check!(unlink(filename));\n-        let read_str = str::from_utf8(&read_mem).unwrap();\n-        assert_eq!(read_str, message);\n-    }\n-\n-    #[test]\n-    fn file_test_io_seek_and_tell_smoke_test() {\n-        let message = \"ten-four\";\n-        let mut read_mem = [0; 4];\n-        let set_cursor = 4 as u64;\n-        let mut tell_pos_pre_read;\n-        let mut tell_pos_post_read;\n-        let tmpdir = tmpdir();\n-        let filename = &tmpdir.join(\"file_rt_io_file_test_seeking.txt\");\n-        {\n-            let mut rw_stream = File::open_mode(filename, Open, ReadWrite);\n-            check!(rw_stream.write(message.as_bytes()));\n-        }\n-        {\n-            let mut read_stream = File::open_mode(filename, Open, Read);\n-            check!(read_stream.seek(set_cursor as i64, SeekSet));\n-            tell_pos_pre_read = check!(read_stream.tell());\n-            check!(read_stream.read(&mut read_mem));\n-            tell_pos_post_read = check!(read_stream.tell());\n-        }\n-        check!(unlink(filename));\n-        let read_str = str::from_utf8(&read_mem).unwrap();\n-        assert_eq!(read_str, &message[4..8]);\n-        assert_eq!(tell_pos_pre_read, set_cursor);\n-        assert_eq!(tell_pos_post_read, message.len() as u64);\n-    }\n-\n-    #[test]\n-    fn file_test_io_seek_and_write() {\n-        let initial_msg =   \"food-is-yummy\";\n-        let overwrite_msg =    \"-the-bar!!\";\n-        let final_msg =     \"foo-the-bar!!\";\n-        let seek_idx = 3;\n-        let mut read_mem = [0; 13];\n-        let tmpdir = tmpdir();\n-        let filename = &tmpdir.join(\"file_rt_io_file_test_seek_and_write.txt\");\n-        {\n-            let mut rw_stream = File::open_mode(filename, Open, ReadWrite);\n-            check!(rw_stream.write(initial_msg.as_bytes()));\n-            check!(rw_stream.seek(seek_idx as i64, SeekSet));\n-            check!(rw_stream.write(overwrite_msg.as_bytes()));\n-        }\n-        {\n-            let mut read_stream = File::open_mode(filename, Open, Read);\n-            check!(read_stream.read(&mut read_mem));\n-        }\n-        check!(unlink(filename));\n-        let read_str = str::from_utf8(&read_mem).unwrap();\n-        assert!(read_str == final_msg);\n-    }\n-\n-    #[test]\n-    fn file_test_io_seek_shakedown() {\n-        use str;          // 01234567890123\n-        let initial_msg =   \"qwer-asdf-zxcv\";\n-        let chunk_one: &str = \"qwer\";\n-        let chunk_two: &str = \"asdf\";\n-        let chunk_three: &str = \"zxcv\";\n-        let mut read_mem = [0; 4];\n-        let tmpdir = tmpdir();\n-        let filename = &tmpdir.join(\"file_rt_io_file_test_seek_shakedown.txt\");\n-        {\n-            let mut rw_stream = File::open_mode(filename, Open, ReadWrite);\n-            check!(rw_stream.write(initial_msg.as_bytes()));\n-        }\n-        {\n-            let mut read_stream = File::open_mode(filename, Open, Read);\n-\n-            check!(read_stream.seek(-4, SeekEnd));\n-            check!(read_stream.read(&mut read_mem));\n-            assert_eq!(str::from_utf8(&read_mem).unwrap(), chunk_three);\n-\n-            check!(read_stream.seek(-9, SeekCur));\n-            check!(read_stream.read(&mut read_mem));\n-            assert_eq!(str::from_utf8(&read_mem).unwrap(), chunk_two);\n-\n-            check!(read_stream.seek(0, SeekSet));\n-            check!(read_stream.read(&mut read_mem));\n-            assert_eq!(str::from_utf8(&read_mem).unwrap(), chunk_one);\n-        }\n-        check!(unlink(filename));\n-    }\n-\n-    #[test]\n-    fn file_test_stat_is_correct_on_is_file() {\n-        let tmpdir = tmpdir();\n-        let filename = &tmpdir.join(\"file_stat_correct_on_is_file.txt\");\n-        {\n-            let mut fs = check!(File::open_mode(filename, Open, ReadWrite));\n-            let msg = \"hw\";\n-            fs.write(msg.as_bytes()).unwrap();\n-\n-            let fstat_res = check!(fs.stat());\n-            assert_eq!(fstat_res.kind, FileType::RegularFile);\n-        }\n-        let stat_res_fn = check!(stat(filename));\n-        assert_eq!(stat_res_fn.kind, FileType::RegularFile);\n-        let stat_res_meth = check!(filename.stat());\n-        assert_eq!(stat_res_meth.kind, FileType::RegularFile);\n-        check!(unlink(filename));\n-    }\n-\n-    #[test]\n-    fn file_test_stat_is_correct_on_is_dir() {\n-        let tmpdir = tmpdir();\n-        let filename = &tmpdir.join(\"file_stat_correct_on_is_dir\");\n-        check!(mkdir(filename, old_io::USER_RWX));\n-        let stat_res_fn = check!(stat(filename));\n-        assert!(stat_res_fn.kind == FileType::Directory);\n-        let stat_res_meth = check!(filename.stat());\n-        assert!(stat_res_meth.kind == FileType::Directory);\n-        check!(rmdir(filename));\n-    }\n-\n-    #[test]\n-    fn file_test_fileinfo_false_when_checking_is_file_on_a_directory() {\n-        let tmpdir = tmpdir();\n-        let dir = &tmpdir.join(\"fileinfo_false_on_dir\");\n-        check!(mkdir(dir, old_io::USER_RWX));\n-        assert!(dir.is_file() == false);\n-        check!(rmdir(dir));\n-    }\n-\n-    #[test]\n-    fn file_test_fileinfo_check_exists_before_and_after_file_creation() {\n-        let tmpdir = tmpdir();\n-        let file = &tmpdir.join(\"fileinfo_check_exists_b_and_a.txt\");\n-        check!(File::create(file).write(b\"foo\"));\n-        assert!(file.exists());\n-        check!(unlink(file));\n-        assert!(!file.exists());\n-    }\n-\n-    #[test]\n-    fn file_test_directoryinfo_check_exists_before_and_after_mkdir() {\n-        let tmpdir = tmpdir();\n-        let dir = &tmpdir.join(\"before_and_after_dir\");\n-        assert!(!dir.exists());\n-        check!(mkdir(dir, old_io::USER_RWX));\n-        assert!(dir.exists());\n-        assert!(dir.is_dir());\n-        check!(rmdir(dir));\n-        assert!(!dir.exists());\n-    }\n-\n-    #[test]\n-    fn file_test_directoryinfo_readdir() {\n-        use str;\n-        let tmpdir = tmpdir();\n-        let dir = &tmpdir.join(\"di_readdir\");\n-        check!(mkdir(dir, old_io::USER_RWX));\n-        let prefix = \"foo\";\n-        for n in 0..3 {\n-            let f = dir.join(format!(\"{}.txt\", n));\n-            let mut w = check!(File::create(&f));\n-            let msg_str = format!(\"{}{}\", prefix, n);\n-            let msg = msg_str.as_bytes();\n-            check!(w.write(msg));\n-        }\n-        let files = check!(readdir(dir));\n-        let mut mem = [0; 4];\n-        for f in &files {\n-            {\n-                let n = f.filestem_str();\n-                check!(File::open(f).read(&mut mem));\n-                let read_str = str::from_utf8(&mem).unwrap();\n-                let expected = match n {\n-                    None|Some(\"\") => panic!(\"really shouldn't happen..\"),\n-                    Some(n) => format!(\"{}{}\", prefix, n),\n-                };\n-                assert_eq!(expected, read_str);\n-            }\n-            check!(unlink(f));\n-        }\n-        check!(rmdir(dir));\n-    }\n-\n-    #[test]\n-    fn file_test_walk_dir() {\n-        let tmpdir = tmpdir();\n-        let dir = &tmpdir.join(\"walk_dir\");\n-        check!(mkdir(dir, old_io::USER_RWX));\n-\n-        let dir1 = &dir.join(\"01/02/03\");\n-        check!(mkdir_recursive(dir1, old_io::USER_RWX));\n-        check!(File::create(&dir1.join(\"04\")));\n-\n-        let dir2 = &dir.join(\"11/12/13\");\n-        check!(mkdir_recursive(dir2, old_io::USER_RWX));\n-        check!(File::create(&dir2.join(\"14\")));\n-\n-        let mut files = check!(walk_dir(dir));\n-        let mut cur = [0; 2];\n-        for f in files {\n-            let stem = f.filestem_str().unwrap();\n-            let root = stem.as_bytes()[0] - b'0';\n-            let name = stem.as_bytes()[1] - b'0';\n-            assert!(cur[root as usize] < name);\n-            cur[root as usize] = name;\n-        }\n-\n-        check!(rmdir_recursive(dir));\n-    }\n-\n-    #[test]\n-    fn mkdir_path_already_exists_error() {\n-        use old_io::{IoError, PathAlreadyExists};\n-\n-        let tmpdir = tmpdir();\n-        let dir = &tmpdir.join(\"mkdir_error_twice\");\n-        check!(mkdir(dir, old_io::USER_RWX));\n-        match mkdir(dir, old_io::USER_RWX) {\n-            Err(IoError{kind:PathAlreadyExists,..}) => (),\n-            _ => assert!(false)\n-        };\n-    }\n-\n-    #[test]\n-    fn recursive_mkdir() {\n-        let tmpdir = tmpdir();\n-        let dir = tmpdir.join(\"d1/d2\");\n-        check!(mkdir_recursive(&dir, old_io::USER_RWX));\n-        assert!(dir.is_dir())\n-    }\n-\n-    #[test]\n-    fn recursive_mkdir_failure() {\n-        let tmpdir = tmpdir();\n-        let dir = tmpdir.join(\"d1\");\n-        let file = dir.join(\"f1\");\n-\n-        check!(mkdir_recursive(&dir, old_io::USER_RWX));\n-        check!(File::create(&file));\n-\n-        let result = mkdir_recursive(&file, old_io::USER_RWX);\n-\n-        error!(result, \"couldn't recursively mkdir\");\n-        error!(result, \"couldn't create directory\");\n-        error!(result, \"mode=0700\");\n-        error!(result, &format!(\"path={}\", file.display()));\n-    }\n-\n-    #[test]\n-    fn recursive_mkdir_slash() {\n-        check!(mkdir_recursive(&Path::new(\"/\"), old_io::USER_RWX));\n-    }\n-\n-    // FIXME(#12795) depends on lstat to work on windows\n-    #[cfg(not(windows))]\n-    #[test]\n-    fn recursive_rmdir() {\n-        let tmpdir = tmpdir();\n-        let d1 = tmpdir.join(\"d1\");\n-        let dt = d1.join(\"t\");\n-        let dtt = dt.join(\"t\");\n-        let d2 = tmpdir.join(\"d2\");\n-        let canary = d2.join(\"do_not_delete\");\n-        check!(mkdir_recursive(&dtt, old_io::USER_RWX));\n-        check!(mkdir_recursive(&d2, old_io::USER_RWX));\n-        check!(File::create(&canary).write(b\"foo\"));\n-        check!(symlink(&d2, &dt.join(\"d2\")));\n-        check!(rmdir_recursive(&d1));\n-\n-        assert!(!d1.is_dir());\n-        assert!(canary.exists());\n-    }\n-\n-    #[test]\n-    fn unicode_path_is_dir() {\n-        assert!(Path::new(\".\").is_dir());\n-        assert!(!Path::new(\"test/stdtest/fs.rs\").is_dir());\n-\n-        let tmpdir = tmpdir();\n-\n-        let mut dirpath = tmpdir.path().clone();\n-        dirpath.push(format!(\"test-\uac00\u4e00\u30fc\u4f60\u597d\"));\n-        check!(mkdir(&dirpath, old_io::USER_RWX));\n-        assert!(dirpath.is_dir());\n-\n-        let mut filepath = dirpath;\n-        filepath.push(\"unicode-file-\\u{ac00}\\u{4e00}\\u{30fc}\\u{4f60}\\u{597d}.rs\");\n-        check!(File::create(&filepath)); // ignore return; touch only\n-        assert!(!filepath.is_dir());\n-        assert!(filepath.exists());\n-    }\n-\n-    #[test]\n-    fn unicode_path_exists() {\n-        assert!(Path::new(\".\").exists());\n-        assert!(!Path::new(\"test/nonexistent-bogus-path\").exists());\n-\n-        let tmpdir = tmpdir();\n-        let unicode = tmpdir.path();\n-        let unicode = unicode.join(format!(\"test-\uac01\u4e01\u30fc\u518d\u89c1\"));\n-        check!(mkdir(&unicode, old_io::USER_RWX));\n-        assert!(unicode.exists());\n-        assert!(!Path::new(\"test/unicode-bogus-path-\uac01\u4e01\u30fc\u518d\u89c1\").exists());\n-    }\n-\n-    #[test]\n-    fn copy_file_does_not_exist() {\n-        let from = Path::new(\"test/nonexistent-bogus-path\");\n-        let to = Path::new(\"test/other-bogus-path\");\n-\n-        error!(copy(&from, &to),\n-            &format!(\"couldn't copy path (the source path is not an \\\n-                     existing file; from={:?}; to={:?})\",\n-                     from.display(), to.display()));\n-\n-        match copy(&from, &to) {\n-            Ok(..) => panic!(),\n-            Err(..) => {\n-                assert!(!from.exists());\n-                assert!(!to.exists());\n-            }\n-        }\n-    }\n-\n-    #[test]\n-    fn copy_file_ok() {\n-        let tmpdir = tmpdir();\n-        let input = tmpdir.join(\"in.txt\");\n-        let out = tmpdir.join(\"out.txt\");\n-\n-        check!(File::create(&input).write(b\"hello\"));\n-        check!(copy(&input, &out));\n-        let contents = check!(File::open(&out).read_to_end());\n-        assert_eq!(contents, b\"hello\");\n-\n-        assert_eq!(check!(input.stat()).perm, check!(out.stat()).perm);\n-    }\n-\n-    #[test]\n-    fn copy_file_dst_dir() {\n-        let tmpdir = tmpdir();\n-        let out = tmpdir.join(\"out\");\n-\n-        check!(File::create(&out));\n-        match copy(&out, tmpdir.path()) {\n-            Ok(..) => panic!(), Err(..) => {}\n-        }\n-    }\n-\n-    #[test]\n-    fn copy_file_dst_exists() {\n-        let tmpdir = tmpdir();\n-        let input = tmpdir.join(\"in\");\n-        let output = tmpdir.join(\"out\");\n-\n-        check!(File::create(&input).write(\"foo\".as_bytes()));\n-        check!(File::create(&output).write(\"bar\".as_bytes()));\n-        check!(copy(&input, &output));\n-\n-        assert_eq!(check!(File::open(&output).read_to_end()),\n-                   b\"foo\".to_vec());\n-    }\n-\n-    #[test]\n-    fn copy_file_src_dir() {\n-        let tmpdir = tmpdir();\n-        let out = tmpdir.join(\"out\");\n-\n-        match copy(tmpdir.path(), &out) {\n-            Ok(..) => panic!(), Err(..) => {}\n-        }\n-        assert!(!out.exists());\n-    }\n-\n-    #[test]\n-    fn copy_file_preserves_perm_bits() {\n-        let tmpdir = tmpdir();\n-        let input = tmpdir.join(\"in.txt\");\n-        let out = tmpdir.join(\"out.txt\");\n-\n-        check!(File::create(&input));\n-        check!(chmod(&input, old_io::USER_READ));\n-        check!(copy(&input, &out));\n-        assert!(!check!(out.stat()).perm.intersects(old_io::USER_WRITE));\n-\n-        check!(chmod(&input, old_io::USER_FILE));\n-        check!(chmod(&out, old_io::USER_FILE));\n-    }\n-\n-    #[cfg(not(windows))] // FIXME(#10264) operation not permitted?\n-    #[test]\n-    fn symlinks_work() {\n-        let tmpdir = tmpdir();\n-        let input = tmpdir.join(\"in.txt\");\n-        let out = tmpdir.join(\"out.txt\");\n-\n-        check!(File::create(&input).write(\"foobar\".as_bytes()));\n-        check!(symlink(&input, &out));\n-        if cfg!(not(windows)) {\n-            assert_eq!(check!(lstat(&out)).kind, FileType::Symlink);\n-            assert_eq!(check!(out.lstat()).kind, FileType::Symlink);\n-        }\n-        assert_eq!(check!(stat(&out)).size, check!(stat(&input)).size);\n-        assert_eq!(check!(File::open(&out).read_to_end()),\n-                   b\"foobar\".to_vec());\n-    }\n-\n-    #[cfg(not(windows))] // apparently windows doesn't like symlinks\n-    #[test]\n-    fn symlink_noexist() {\n-        let tmpdir = tmpdir();\n-        // symlinks can point to things that don't exist\n-        check!(symlink(&tmpdir.join(\"foo\"), &tmpdir.join(\"bar\")));\n-        assert!(check!(readlink(&tmpdir.join(\"bar\"))) == tmpdir.join(\"foo\"));\n-    }\n-\n-    #[test]\n-    fn readlink_not_symlink() {\n-        let tmpdir = tmpdir();\n-        match readlink(tmpdir.path()) {\n-            Ok(..) => panic!(\"wanted a failure\"),\n-            Err(..) => {}\n-        }\n-    }\n-\n-    #[test]\n-    fn links_work() {\n-        let tmpdir = tmpdir();\n-        let input = tmpdir.join(\"in.txt\");\n-        let out = tmpdir.join(\"out.txt\");\n-\n-        check!(File::create(&input).write(\"foobar\".as_bytes()));\n-        check!(link(&input, &out));\n-        if cfg!(not(windows)) {\n-            assert_eq!(check!(lstat(&out)).kind, FileType::RegularFile);\n-            assert_eq!(check!(out.lstat()).kind, FileType::RegularFile);\n-            assert_eq!(check!(stat(&out)).unstable.nlink, 2);\n-            assert_eq!(check!(out.stat()).unstable.nlink, 2);\n-        }\n-        assert_eq!(check!(stat(&out)).size, check!(stat(&input)).size);\n-        assert_eq!(check!(stat(&out)).size, check!(input.stat()).size);\n-        assert_eq!(check!(File::open(&out).read_to_end()),\n-                   b\"foobar\".to_vec());\n-\n-        // can't link to yourself\n-        match link(&input, &input) {\n-            Ok(..) => panic!(\"wanted a failure\"),\n-            Err(..) => {}\n-        }\n-        // can't link to something that doesn't exist\n-        match link(&tmpdir.join(\"foo\"), &tmpdir.join(\"bar\")) {\n-            Ok(..) => panic!(\"wanted a failure\"),\n-            Err(..) => {}\n-        }\n-    }\n-\n-    #[test]\n-    fn chmod_works() {\n-        let tmpdir = tmpdir();\n-        let file = tmpdir.join(\"in.txt\");\n-\n-        check!(File::create(&file));\n-        assert!(check!(stat(&file)).perm.contains(old_io::USER_WRITE));\n-        check!(chmod(&file, old_io::USER_READ));\n-        assert!(!check!(stat(&file)).perm.contains(old_io::USER_WRITE));\n-\n-        match chmod(&tmpdir.join(\"foo\"), old_io::USER_RWX) {\n-            Ok(..) => panic!(\"wanted a panic\"),\n-            Err(..) => {}\n-        }\n-\n-        check!(chmod(&file, old_io::USER_FILE));\n-    }\n-\n-    #[test]\n-    fn sync_doesnt_kill_anything() {\n-        let tmpdir = tmpdir();\n-        let path = tmpdir.join(\"in.txt\");\n-\n-        let mut file = check!(File::open_mode(&path, old_io::Open, old_io::ReadWrite));\n-        check!(file.fsync());\n-        check!(file.datasync());\n-        check!(file.write(b\"foo\"));\n-        check!(file.fsync());\n-        check!(file.datasync());\n-        drop(file);\n-    }\n-\n-    #[test]\n-    fn truncate_works() {\n-        let tmpdir = tmpdir();\n-        let path = tmpdir.join(\"in.txt\");\n-\n-        let mut file = check!(File::open_mode(&path, old_io::Open, old_io::ReadWrite));\n-        check!(file.write(b\"foo\"));\n-        check!(file.fsync());\n-\n-        // Do some simple things with truncation\n-        assert_eq!(check!(file.stat()).size, 3);\n-        check!(file.truncate(10));\n-        assert_eq!(check!(file.stat()).size, 10);\n-        check!(file.write(b\"bar\"));\n-        check!(file.fsync());\n-        assert_eq!(check!(file.stat()).size, 10);\n-        assert_eq!(check!(File::open(&path).read_to_end()),\n-                   b\"foobar\\0\\0\\0\\0\".to_vec());\n-\n-        // Truncate to a smaller length, don't seek, and then write something.\n-        // Ensure that the intermediate zeroes are all filled in (we have `seek`ed\n-        // past the end of the file).\n-        check!(file.truncate(2));\n-        assert_eq!(check!(file.stat()).size, 2);\n-        check!(file.write(b\"wut\"));\n-        check!(file.fsync());\n-        assert_eq!(check!(file.stat()).size, 9);\n-        assert_eq!(check!(File::open(&path).read_to_end()),\n-                   b\"fo\\0\\0\\0\\0wut\".to_vec());\n-        drop(file);\n-    }\n-\n-    #[test]\n-    fn open_flavors() {\n-        let tmpdir = tmpdir();\n-\n-        match File::open_mode(&tmpdir.join(\"a\"), old_io::Open, old_io::Read) {\n-            Ok(..) => panic!(), Err(..) => {}\n-        }\n-\n-        // Perform each one twice to make sure that it succeeds the second time\n-        // (where the file exists)\n-        check!(File::open_mode(&tmpdir.join(\"b\"), old_io::Open, old_io::Write));\n-        assert!(tmpdir.join(\"b\").exists());\n-        check!(File::open_mode(&tmpdir.join(\"b\"), old_io::Open, old_io::Write));\n-\n-        check!(File::open_mode(&tmpdir.join(\"c\"), old_io::Open, old_io::ReadWrite));\n-        assert!(tmpdir.join(\"c\").exists());\n-        check!(File::open_mode(&tmpdir.join(\"c\"), old_io::Open, old_io::ReadWrite));\n-\n-        check!(File::open_mode(&tmpdir.join(\"d\"), old_io::Append, old_io::Write));\n-        assert!(tmpdir.join(\"d\").exists());\n-        check!(File::open_mode(&tmpdir.join(\"d\"), old_io::Append, old_io::Write));\n-\n-        check!(File::open_mode(&tmpdir.join(\"e\"), old_io::Append, old_io::ReadWrite));\n-        assert!(tmpdir.join(\"e\").exists());\n-        check!(File::open_mode(&tmpdir.join(\"e\"), old_io::Append, old_io::ReadWrite));\n-\n-        check!(File::open_mode(&tmpdir.join(\"f\"), old_io::Truncate, old_io::Write));\n-        assert!(tmpdir.join(\"f\").exists());\n-        check!(File::open_mode(&tmpdir.join(\"f\"), old_io::Truncate, old_io::Write));\n-\n-        check!(File::open_mode(&tmpdir.join(\"g\"), old_io::Truncate, old_io::ReadWrite));\n-        assert!(tmpdir.join(\"g\").exists());\n-        check!(File::open_mode(&tmpdir.join(\"g\"), old_io::Truncate, old_io::ReadWrite));\n-\n-        check!(File::create(&tmpdir.join(\"h\")).write(\"foo\".as_bytes()));\n-        check!(File::open_mode(&tmpdir.join(\"h\"), old_io::Open, old_io::Read));\n-        {\n-            let mut f = check!(File::open_mode(&tmpdir.join(\"h\"), old_io::Open,\n-                                               old_io::Read));\n-            match f.write(\"wut\".as_bytes()) {\n-                Ok(..) => panic!(), Err(..) => {}\n-            }\n-        }\n-        assert!(check!(stat(&tmpdir.join(\"h\"))).size == 3,\n-                \"write/stat failed\");\n-        {\n-            let mut f = check!(File::open_mode(&tmpdir.join(\"h\"), old_io::Append,\n-                                               old_io::Write));\n-            check!(f.write(\"bar\".as_bytes()));\n-        }\n-        assert!(check!(stat(&tmpdir.join(\"h\"))).size == 6,\n-                \"append didn't append\");\n-        {\n-            let mut f = check!(File::open_mode(&tmpdir.join(\"h\"), old_io::Truncate,\n-                                               old_io::Write));\n-            check!(f.write(\"bar\".as_bytes()));\n-        }\n-        assert!(check!(stat(&tmpdir.join(\"h\"))).size == 3,\n-                \"truncate didn't truncate\");\n-    }\n-\n-    #[test]\n-    fn utime() {\n-        let tmpdir = tmpdir();\n-        let path = tmpdir.join(\"a\");\n-        check!(File::create(&path));\n-        // These numbers have to be bigger than the time in the day to account\n-        // for timezones Windows in particular will fail in certain timezones\n-        // with small enough values\n-        check!(change_file_times(&path, 100000, 200000));\n-        assert_eq!(check!(path.stat()).accessed, 100000);\n-        assert_eq!(check!(path.stat()).modified, 200000);\n-    }\n-\n-    #[test]\n-    fn utime_noexist() {\n-        let tmpdir = tmpdir();\n-\n-        match change_file_times(&tmpdir.join(\"a\"), 100, 200) {\n-            Ok(..) => panic!(),\n-            Err(..) => {}\n-        }\n-    }\n-\n-    #[test]\n-    fn binary_file() {\n-        use rand::{StdRng, Rng};\n-\n-        let mut bytes = [0; 1024];\n-        StdRng::new().unwrap().fill_bytes(&mut bytes);\n-\n-        let tmpdir = tmpdir();\n-\n-        check!(File::create(&tmpdir.join(\"test\")).write(&bytes));\n-        let actual = check!(File::open(&tmpdir.join(\"test\")).read_to_end());\n-        assert!(actual == &bytes[..]);\n-    }\n-\n-    #[test]\n-    fn unlink_readonly() {\n-        let tmpdir = tmpdir();\n-        let path = tmpdir.join(\"file\");\n-        check!(File::create(&path));\n-        check!(chmod(&path, old_io::USER_READ));\n-        check!(unlink(&path));\n-    }\n-}"}, {"sha": "c92e74fbc565e10b3a84aa46c67b86a630d816d8", "filename": "src/libstd/old_io/mem.rs", "status": "removed", "additions": 0, "deletions": 765, "changes": 765, "blob_url": "https://github.com/rust-lang/rust/blob/8415fa27877a4309a79b08c75a52eb4c3546b7a5/src%2Flibstd%2Fold_io%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8415fa27877a4309a79b08c75a52eb4c3546b7a5/src%2Flibstd%2Fold_io%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fmem.rs?ref=8415fa27877a4309a79b08c75a52eb4c3546b7a5", "patch": "@@ -1,765 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-//\n-// ignore-lexer-test FIXME #15679\n-\n-//! Readers and Writers for in-memory buffers\n-\n-use cmp::min;\n-use option::Option::None;\n-use result::Result::{Err, Ok};\n-use old_io;\n-use old_io::{Reader, Writer, Seek, Buffer, IoError, SeekStyle, IoResult};\n-use slice;\n-use vec::Vec;\n-\n-const BUF_CAPACITY: usize = 128;\n-\n-fn combine(seek: SeekStyle, cur: usize, end: usize, offset: i64) -> IoResult<u64> {\n-    // compute offset as signed and clamp to prevent overflow\n-    let pos = match seek {\n-        old_io::SeekSet => 0,\n-        old_io::SeekEnd => end,\n-        old_io::SeekCur => cur,\n-    } as i64;\n-\n-    if offset + pos < 0 {\n-        Err(IoError {\n-            kind: old_io::InvalidInput,\n-            desc: \"invalid seek to a negative offset\",\n-            detail: None\n-        })\n-    } else {\n-        Ok((offset + pos) as u64)\n-    }\n-}\n-\n-impl Writer for Vec<u8> {\n-    #[inline]\n-    fn write_all(&mut self, buf: &[u8]) -> IoResult<()> {\n-        self.push_all(buf);\n-        Ok(())\n-    }\n-}\n-\n-/// Writes to an owned, growable byte vector\n-///\n-/// # Examples\n-///\n-/// ```\n-/// # #![feature(old_io, io)]\n-/// # #![allow(unused_must_use)]\n-/// use std::old_io::*;\n-///\n-/// let mut w = MemWriter::new();\n-/// w.write(&[0, 1, 2]);\n-///\n-/// assert_eq!(w.into_inner(), [0, 1, 2]);\n-/// ```\n-#[unstable(feature = \"io\")]\n-#[deprecated(since = \"1.0.0\",\n-             reason = \"use the Vec<u8> Writer implementation directly\")]\n-#[derive(Clone)]\n-#[allow(deprecated)]\n-pub struct MemWriter {\n-    buf: Vec<u8>,\n-}\n-\n-#[allow(deprecated)]\n-impl MemWriter {\n-    /// Create a new `MemWriter`.\n-    #[inline]\n-    pub fn new() -> MemWriter {\n-        MemWriter::with_capacity(BUF_CAPACITY)\n-    }\n-    /// Create a new `MemWriter`, allocating at least `n` bytes for\n-    /// the internal buffer.\n-    #[inline]\n-    pub fn with_capacity(n: usize) -> MemWriter {\n-        MemWriter::from_vec(Vec::with_capacity(n))\n-    }\n-    /// Create a new `MemWriter` that will append to an existing `Vec`.\n-    #[inline]\n-    pub fn from_vec(buf: Vec<u8>) -> MemWriter {\n-        MemWriter { buf: buf }\n-    }\n-\n-    /// Acquires an immutable reference to the underlying buffer of this\n-    /// `MemWriter`.\n-    #[inline]\n-    pub fn get_ref<'a>(&'a self) -> &'a [u8] { &self.buf }\n-\n-    /// Unwraps this `MemWriter`, returning the underlying buffer\n-    #[inline]\n-    pub fn into_inner(self) -> Vec<u8> { self.buf }\n-}\n-\n-impl Writer for MemWriter {\n-    #[inline]\n-    #[allow(deprecated)]\n-    fn write_all(&mut self, buf: &[u8]) -> IoResult<()> {\n-        self.buf.push_all(buf);\n-        Ok(())\n-    }\n-}\n-\n-/// Reads from an owned byte vector\n-///\n-/// # Examples\n-///\n-/// ```\n-/// # #![feature(old_io)]\n-/// # #![allow(unused_must_use)]\n-/// use std::old_io::*;\n-///\n-/// let mut r = MemReader::new(vec!(0, 1, 2));\n-///\n-/// assert_eq!(r.read_to_end().unwrap(), [0, 1, 2]);\n-/// ```\n-pub struct MemReader {\n-    buf: Vec<u8>,\n-    pos: usize\n-}\n-\n-impl MemReader {\n-    /// Creates a new `MemReader` which will read the buffer given. The buffer\n-    /// can be re-acquired through `unwrap`\n-    #[inline]\n-    pub fn new(buf: Vec<u8>) -> MemReader {\n-        MemReader {\n-            buf: buf,\n-            pos: 0\n-        }\n-    }\n-\n-    /// Tests whether this reader has read all bytes in its buffer.\n-    ///\n-    /// If `true`, then this will no longer return bytes from `read`.\n-    #[inline]\n-    pub fn eof(&self) -> bool { self.pos >= self.buf.len() }\n-\n-    /// Acquires an immutable reference to the underlying buffer of this\n-    /// `MemReader`.\n-    ///\n-    /// No method is exposed for acquiring a mutable reference to the buffer\n-    /// because it could corrupt the state of this `MemReader`.\n-    #[inline]\n-    pub fn get_ref<'a>(&'a self) -> &'a [u8] { &self.buf }\n-\n-    /// Unwraps this `MemReader`, returning the underlying buffer\n-    #[inline]\n-    pub fn into_inner(self) -> Vec<u8> { self.buf }\n-}\n-\n-impl Reader for MemReader {\n-    #[inline]\n-    fn read(&mut self, buf: &mut [u8]) -> IoResult<usize> {\n-        if self.eof() { return Err(old_io::standard_error(old_io::EndOfFile)) }\n-\n-        let write_len = min(buf.len(), self.buf.len() - self.pos);\n-        {\n-            let input = &self.buf[self.pos.. self.pos + write_len];\n-            let output = &mut buf[..write_len];\n-            assert_eq!(input.len(), output.len());\n-            slice::bytes::copy_memory(input, output);\n-        }\n-        self.pos += write_len;\n-        assert!(self.pos <= self.buf.len());\n-\n-        return Ok(write_len);\n-    }\n-}\n-\n-impl Seek for MemReader {\n-    #[inline]\n-    fn tell(&self) -> IoResult<u64> { Ok(self.pos as u64) }\n-\n-    #[inline]\n-    fn seek(&mut self, pos: i64, style: SeekStyle) -> IoResult<()> {\n-        let new = try!(combine(style, self.pos, self.buf.len(), pos));\n-        self.pos = new as usize;\n-        Ok(())\n-    }\n-}\n-\n-impl Buffer for MemReader {\n-    #[inline]\n-    fn fill_buf<'a>(&'a mut self) -> IoResult<&'a [u8]> {\n-        if self.pos < self.buf.len() {\n-            Ok(&self.buf[self.pos..])\n-        } else {\n-            Err(old_io::standard_error(old_io::EndOfFile))\n-        }\n-    }\n-\n-    #[inline]\n-    fn consume(&mut self, amt: usize) { self.pos += amt; }\n-}\n-\n-impl<'a> Reader for &'a [u8] {\n-    #[inline]\n-    fn read(&mut self, buf: &mut [u8]) -> IoResult<usize> {\n-        if self.is_empty() { return Err(old_io::standard_error(old_io::EndOfFile)); }\n-\n-        let write_len = min(buf.len(), self.len());\n-        {\n-            let input = &self[..write_len];\n-            let output = &mut buf[.. write_len];\n-            slice::bytes::copy_memory(input, output);\n-        }\n-\n-        *self = &self[write_len..];\n-\n-        Ok(write_len)\n-    }\n-}\n-\n-impl<'a> Buffer for &'a [u8] {\n-    #[inline]\n-    fn fill_buf(&mut self) -> IoResult<&[u8]> {\n-        if self.is_empty() {\n-            Err(old_io::standard_error(old_io::EndOfFile))\n-        } else {\n-            Ok(*self)\n-        }\n-    }\n-\n-    #[inline]\n-    fn consume(&mut self, amt: usize) {\n-        *self = &self[amt..];\n-    }\n-}\n-\n-\n-/// Writes to a fixed-size byte slice\n-///\n-/// If a write will not fit in the buffer, it returns an error and does not\n-/// write any data.\n-///\n-/// # Examples\n-///\n-/// ```\n-/// # #![feature(old_io, io)]\n-/// # #![allow(unused_must_use)]\n-/// use std::old_io::*;\n-///\n-/// let mut buf = [0; 4];\n-/// {\n-///     let mut w = BufWriter::new(&mut buf);\n-///     w.write(&[0, 1, 2]);\n-/// }\n-/// assert!(buf == [0, 1, 2, 0]);\n-/// ```\n-pub struct BufWriter<'a> {\n-    buf: &'a mut [u8],\n-    pos: usize\n-}\n-\n-impl<'a> BufWriter<'a> {\n-    /// Creates a new `BufWriter` which will wrap the specified buffer. The\n-    /// writer initially starts at position 0.\n-    #[inline]\n-    pub fn new(buf: &'a mut [u8]) -> BufWriter<'a> {\n-        BufWriter {\n-            buf: buf,\n-            pos: 0\n-        }\n-    }\n-}\n-\n-impl<'a> Writer for BufWriter<'a> {\n-    #[inline]\n-    fn write_all(&mut self, src: &[u8]) -> IoResult<()> {\n-        let dst = &mut self.buf[self.pos..];\n-        let dst_len = dst.len();\n-\n-        if dst_len == 0 {\n-            return Err(old_io::standard_error(old_io::EndOfFile));\n-        }\n-\n-        let src_len = src.len();\n-\n-        if dst_len >= src_len {\n-            slice::bytes::copy_memory(src, dst);\n-\n-            self.pos += src_len;\n-\n-            Ok(())\n-        } else {\n-            slice::bytes::copy_memory(&src[..dst_len], dst);\n-\n-            self.pos += dst_len;\n-\n-            Err(old_io::standard_error(old_io::ShortWrite(dst_len)))\n-        }\n-    }\n-}\n-\n-impl<'a> Seek for BufWriter<'a> {\n-    #[inline]\n-    fn tell(&self) -> IoResult<u64> { Ok(self.pos as u64) }\n-\n-    #[inline]\n-    fn seek(&mut self, pos: i64, style: SeekStyle) -> IoResult<()> {\n-        let new = try!(combine(style, self.pos, self.buf.len(), pos));\n-        self.pos = min(new as usize, self.buf.len());\n-        Ok(())\n-    }\n-}\n-\n-/// Reads from a fixed-size byte slice\n-///\n-/// # Examples\n-///\n-/// ```\n-/// # #![feature(old_io)]\n-/// # #![allow(unused_must_use)]\n-/// use std::old_io::*;\n-///\n-/// let buf = [0, 1, 2, 3];\n-/// let mut r = BufReader::new(&buf);\n-///\n-/// assert_eq!(r.read_to_end().unwrap(), [0, 1, 2, 3]);\n-/// ```\n-pub struct BufReader<'a> {\n-    buf: &'a [u8],\n-    pos: usize\n-}\n-\n-impl<'a> BufReader<'a> {\n-    /// Creates a new buffered reader which will read the specified buffer\n-    #[inline]\n-    pub fn new(buf: &'a [u8]) -> BufReader<'a> {\n-        BufReader {\n-            buf: buf,\n-            pos: 0\n-        }\n-    }\n-\n-    /// Tests whether this reader has read all bytes in its buffer.\n-    ///\n-    /// If `true`, then this will no longer return bytes from `read`.\n-    #[inline]\n-    pub fn eof(&self) -> bool { self.pos >= self.buf.len() }\n-}\n-\n-impl<'a> Reader for BufReader<'a> {\n-    #[inline]\n-    fn read(&mut self, buf: &mut [u8]) -> IoResult<usize> {\n-        if self.eof() { return Err(old_io::standard_error(old_io::EndOfFile)) }\n-\n-        let write_len = min(buf.len(), self.buf.len() - self.pos);\n-        {\n-            let input = &self.buf[self.pos.. self.pos + write_len];\n-            let output = &mut buf[..write_len];\n-            assert_eq!(input.len(), output.len());\n-            slice::bytes::copy_memory(input, output);\n-        }\n-        self.pos += write_len;\n-        assert!(self.pos <= self.buf.len());\n-\n-        return Ok(write_len);\n-     }\n-}\n-\n-impl<'a> Seek for BufReader<'a> {\n-    #[inline]\n-    fn tell(&self) -> IoResult<u64> { Ok(self.pos as u64) }\n-\n-    #[inline]\n-    fn seek(&mut self, pos: i64, style: SeekStyle) -> IoResult<()> {\n-        let new = try!(combine(style, self.pos, self.buf.len(), pos));\n-        self.pos = new as usize;\n-        Ok(())\n-    }\n-}\n-\n-impl<'a> Buffer for BufReader<'a> {\n-    #[inline]\n-    fn fill_buf(&mut self) -> IoResult<&[u8]> {\n-        if self.pos < self.buf.len() {\n-            Ok(&self.buf[self.pos..])\n-        } else {\n-            Err(old_io::standard_error(old_io::EndOfFile))\n-        }\n-    }\n-\n-    #[inline]\n-    fn consume(&mut self, amt: usize) { self.pos += amt; }\n-}\n-\n-#[cfg(test)]\n-mod test {\n-    extern crate test as test_crate;\n-    use old_io::{SeekSet, SeekCur, SeekEnd, Reader, Writer, Seek, Buffer};\n-    use prelude::v1::{Ok, Err, Vec};\n-    use prelude::v1::Iterator;\n-    use old_io;\n-    use iter::repeat;\n-    use self::test_crate::Bencher;\n-    use super::*;\n-\n-    #[test]\n-    fn test_vec_writer() {\n-        let mut writer = Vec::new();\n-        writer.write(&[0]).unwrap();\n-        writer.write(&[1, 2, 3]).unwrap();\n-        writer.write(&[4, 5, 6, 7]).unwrap();\n-        let b: &[_] = &[0, 1, 2, 3, 4, 5, 6, 7];\n-        assert_eq!(writer, b);\n-    }\n-\n-    #[test]\n-    fn test_mem_writer() {\n-        let mut writer = MemWriter::new();\n-        writer.write(&[0]).unwrap();\n-        writer.write(&[1, 2, 3]).unwrap();\n-        writer.write(&[4, 5, 6, 7]).unwrap();\n-        let b: &[_] = &[0, 1, 2, 3, 4, 5, 6, 7];\n-        assert_eq!(writer.get_ref(), b);\n-    }\n-\n-    #[test]\n-    fn test_buf_writer() {\n-        let mut buf = [0 as u8; 9];\n-        {\n-            let mut writer = BufWriter::new(&mut buf);\n-            assert_eq!(writer.tell(), Ok(0));\n-            writer.write(&[0]).unwrap();\n-            assert_eq!(writer.tell(), Ok(1));\n-            writer.write(&[1, 2, 3]).unwrap();\n-            writer.write(&[4, 5, 6, 7]).unwrap();\n-            assert_eq!(writer.tell(), Ok(8));\n-            writer.write(&[]).unwrap();\n-            assert_eq!(writer.tell(), Ok(8));\n-\n-            assert_eq!(writer.write(&[8, 9]).err().unwrap().kind, old_io::ShortWrite(1));\n-            assert_eq!(writer.write(&[10]).err().unwrap().kind, old_io::EndOfFile);\n-        }\n-        let b: &[_] = &[0, 1, 2, 3, 4, 5, 6, 7, 8];\n-        assert_eq!(buf, b);\n-    }\n-\n-    #[test]\n-    fn test_buf_writer_seek() {\n-        let mut buf = [0 as u8; 8];\n-        {\n-            let mut writer = BufWriter::new(&mut buf);\n-            assert_eq!(writer.tell(), Ok(0));\n-            writer.write(&[1]).unwrap();\n-            assert_eq!(writer.tell(), Ok(1));\n-\n-            writer.seek(2, SeekSet).unwrap();\n-            assert_eq!(writer.tell(), Ok(2));\n-            writer.write(&[2]).unwrap();\n-            assert_eq!(writer.tell(), Ok(3));\n-\n-            writer.seek(-2, SeekCur).unwrap();\n-            assert_eq!(writer.tell(), Ok(1));\n-            writer.write(&[3]).unwrap();\n-            assert_eq!(writer.tell(), Ok(2));\n-\n-            writer.seek(-1, SeekEnd).unwrap();\n-            assert_eq!(writer.tell(), Ok(7));\n-            writer.write(&[4]).unwrap();\n-            assert_eq!(writer.tell(), Ok(8));\n-\n-        }\n-        let b: &[_] = &[1, 3, 2, 0, 0, 0, 0, 4];\n-        assert_eq!(buf, b);\n-    }\n-\n-    #[test]\n-    fn test_buf_writer_error() {\n-        let mut buf = [0 as u8; 2];\n-        let mut writer = BufWriter::new(&mut buf);\n-        writer.write(&[0]).unwrap();\n-\n-        match writer.write(&[0, 0]) {\n-            Ok(..) => panic!(),\n-            Err(e) => assert_eq!(e.kind, old_io::ShortWrite(1)),\n-        }\n-    }\n-\n-    #[test]\n-    fn test_mem_reader() {\n-        let mut reader = MemReader::new(vec!(0, 1, 2, 3, 4, 5, 6, 7));\n-        let mut buf = [];\n-        assert_eq!(reader.read(&mut buf), Ok(0));\n-        assert_eq!(reader.tell(), Ok(0));\n-        let mut buf = [0];\n-        assert_eq!(reader.read(&mut buf), Ok(1));\n-        assert_eq!(reader.tell(), Ok(1));\n-        let b: &[_] = &[0];\n-        assert_eq!(buf, b);\n-        let mut buf = [0; 4];\n-        assert_eq!(reader.read(&mut buf), Ok(4));\n-        assert_eq!(reader.tell(), Ok(5));\n-        let b: &[_] = &[1, 2, 3, 4];\n-        assert_eq!(buf, b);\n-        assert_eq!(reader.read(&mut buf), Ok(3));\n-        let b: &[_] = &[5, 6, 7];\n-        assert_eq!(&buf[..3], b);\n-        assert!(reader.read(&mut buf).is_err());\n-        let mut reader = MemReader::new(vec!(0, 1, 2, 3, 4, 5, 6, 7));\n-        assert_eq!(reader.read_until(3).unwrap(), [0, 1, 2, 3]);\n-        assert_eq!(reader.read_until(3).unwrap(), [4, 5, 6, 7]);\n-        assert!(reader.read(&mut buf).is_err());\n-    }\n-\n-    #[test]\n-    fn test_slice_reader() {\n-        let in_buf = vec![0, 1, 2, 3, 4, 5, 6, 7];\n-        let mut reader = &mut &*in_buf;\n-        let mut buf = [];\n-        assert_eq!(reader.read(&mut buf), Ok(0));\n-        let mut buf = [0];\n-        assert_eq!(reader.read(&mut buf), Ok(1));\n-        assert_eq!(reader.len(), 7);\n-        let b: &[_] = &[0];\n-        assert_eq!(buf, b);\n-        let mut buf = [0; 4];\n-        assert_eq!(reader.read(&mut buf), Ok(4));\n-        assert_eq!(reader.len(), 3);\n-        let b: &[_] = &[1, 2, 3, 4];\n-        assert_eq!(buf, b);\n-        assert_eq!(reader.read(&mut buf), Ok(3));\n-        let b: &[_] = &[5, 6, 7];\n-        assert_eq!(&buf[..3], b);\n-        assert!(reader.read(&mut buf).is_err());\n-        let mut reader = &mut &*in_buf;\n-        assert_eq!(reader.read_until(3).unwrap(), [0, 1, 2, 3]);\n-        assert_eq!(reader.read_until(3).unwrap(), [4, 5, 6, 7]);\n-        assert!(reader.read(&mut buf).is_err());\n-    }\n-\n-    #[test]\n-    fn test_buf_reader() {\n-        let in_buf = vec![0, 1, 2, 3, 4, 5, 6, 7];\n-        let mut reader = BufReader::new(&in_buf);\n-        let mut buf = [];\n-        assert_eq!(reader.read(&mut buf), Ok(0));\n-        assert_eq!(reader.tell(), Ok(0));\n-        let mut buf = [0];\n-        assert_eq!(reader.read(&mut buf), Ok(1));\n-        assert_eq!(reader.tell(), Ok(1));\n-        let b: &[_] = &[0];\n-        assert_eq!(buf, b);\n-        let mut buf = [0; 4];\n-        assert_eq!(reader.read(&mut buf), Ok(4));\n-        assert_eq!(reader.tell(), Ok(5));\n-        let b: &[_] = &[1, 2, 3, 4];\n-        assert_eq!(buf, b);\n-        assert_eq!(reader.read(&mut buf), Ok(3));\n-        let b: &[_] = &[5, 6, 7];\n-        assert_eq!(&buf[..3], b);\n-        assert!(reader.read(&mut buf).is_err());\n-        let mut reader = BufReader::new(&in_buf);\n-        assert_eq!(reader.read_until(3).unwrap(), [0, 1, 2, 3]);\n-        assert_eq!(reader.read_until(3).unwrap(), [4, 5, 6, 7]);\n-        assert!(reader.read(&mut buf).is_err());\n-    }\n-\n-    #[test]\n-    fn test_read_char() {\n-        let b = b\"Vi\\xE1\\xBB\\x87t\";\n-        let mut r = BufReader::new(b);\n-        assert_eq!(r.read_char(), Ok('V'));\n-        assert_eq!(r.read_char(), Ok('i'));\n-        assert_eq!(r.read_char(), Ok('\u1ec7'));\n-        assert_eq!(r.read_char(), Ok('t'));\n-        assert!(r.read_char().is_err());\n-    }\n-\n-    #[test]\n-    fn test_read_bad_char() {\n-        let b = b\"\\x80\";\n-        let mut r = BufReader::new(b);\n-        assert!(r.read_char().is_err());\n-    }\n-\n-    #[test]\n-    fn test_write_strings() {\n-        let mut writer = MemWriter::new();\n-        writer.write_str(\"testing\").unwrap();\n-        writer.write_line(\"testing\").unwrap();\n-        writer.write_str(\"testing\").unwrap();\n-        let mut r = BufReader::new(writer.get_ref());\n-        assert_eq!(r.read_to_string().unwrap(), \"testingtesting\\ntesting\");\n-    }\n-\n-    #[test]\n-    fn test_write_char() {\n-        let mut writer = MemWriter::new();\n-        writer.write_char('a').unwrap();\n-        writer.write_char('\\n').unwrap();\n-        writer.write_char('\u1ec7').unwrap();\n-        let mut r = BufReader::new(writer.get_ref());\n-        assert_eq!(r.read_to_string().unwrap(), \"a\\n\u1ec7\");\n-    }\n-\n-    #[test]\n-    fn test_read_whole_string_bad() {\n-        let buf = [0xff];\n-        let mut r = BufReader::new(&buf);\n-        match r.read_to_string() {\n-            Ok(..) => panic!(),\n-            Err(..) => {}\n-        }\n-    }\n-\n-    #[test]\n-    fn seek_past_end() {\n-        let buf = [0xff];\n-        let mut r = BufReader::new(&buf);\n-        r.seek(10, SeekSet).unwrap();\n-        assert!(r.read(&mut []).is_err());\n-\n-        let mut r = MemReader::new(vec!(10));\n-        r.seek(10, SeekSet).unwrap();\n-        assert!(r.read(&mut []).is_err());\n-\n-        let mut buf = [0];\n-        let mut r = BufWriter::new(&mut buf);\n-        r.seek(10, SeekSet).unwrap();\n-        assert!(r.write(&[3]).is_err());\n-    }\n-\n-    #[test]\n-    fn seek_before_0() {\n-        let buf = [0xff];\n-        let mut r = BufReader::new(&buf);\n-        assert!(r.seek(-1, SeekSet).is_err());\n-\n-        let mut r = MemReader::new(vec!(10));\n-        assert!(r.seek(-1, SeekSet).is_err());\n-\n-        let mut buf = [0];\n-        let mut r = BufWriter::new(&mut buf);\n-        assert!(r.seek(-1, SeekSet).is_err());\n-    }\n-\n-    #[test]\n-    fn io_read_at_least() {\n-        let mut r = MemReader::new(vec![1, 2, 3, 4, 5, 6, 7, 8]);\n-        let mut buf = [0; 3];\n-        assert!(r.read_at_least(buf.len(), &mut buf).is_ok());\n-        let b: &[_] = &[1, 2, 3];\n-        assert_eq!(buf, b);\n-        assert!(r.read_at_least(0, &mut buf[..0]).is_ok());\n-        assert_eq!(buf, b);\n-        assert!(r.read_at_least(buf.len(), &mut buf).is_ok());\n-        let b: &[_] = &[4, 5, 6];\n-        assert_eq!(buf, b);\n-        assert!(r.read_at_least(buf.len(), &mut buf).is_err());\n-        let b: &[_] = &[7, 8, 6];\n-        assert_eq!(buf, b);\n-    }\n-\n-    fn do_bench_mem_writer(b: &mut Bencher, times: usize, len: usize) {\n-        let src: Vec<u8> = repeat(5).take(len).collect();\n-\n-        b.bytes = (times * len) as u64;\n-        b.iter(|| {\n-            let mut wr = MemWriter::new();\n-            for _ in 0..times {\n-                wr.write(&src).unwrap();\n-            }\n-\n-            let v = wr.into_inner();\n-            assert_eq!(v.len(), times * len);\n-            assert!(v.iter().all(|x| *x == 5));\n-        });\n-    }\n-\n-    #[bench]\n-    fn bench_mem_writer_001_0000(b: &mut Bencher) {\n-        do_bench_mem_writer(b, 1, 0)\n-    }\n-\n-    #[bench]\n-    fn bench_mem_writer_001_0010(b: &mut Bencher) {\n-        do_bench_mem_writer(b, 1, 10)\n-    }\n-\n-    #[bench]\n-    fn bench_mem_writer_001_0100(b: &mut Bencher) {\n-        do_bench_mem_writer(b, 1, 100)\n-    }\n-\n-    #[bench]\n-    fn bench_mem_writer_001_1000(b: &mut Bencher) {\n-        do_bench_mem_writer(b, 1, 1000)\n-    }\n-\n-    #[bench]\n-    fn bench_mem_writer_100_0000(b: &mut Bencher) {\n-        do_bench_mem_writer(b, 100, 0)\n-    }\n-\n-    #[bench]\n-    fn bench_mem_writer_100_0010(b: &mut Bencher) {\n-        do_bench_mem_writer(b, 100, 10)\n-    }\n-\n-    #[bench]\n-    fn bench_mem_writer_100_0100(b: &mut Bencher) {\n-        do_bench_mem_writer(b, 100, 100)\n-    }\n-\n-    #[bench]\n-    fn bench_mem_writer_100_1000(b: &mut Bencher) {\n-        do_bench_mem_writer(b, 100, 1000)\n-    }\n-\n-    #[bench]\n-    fn bench_mem_reader(b: &mut Bencher) {\n-        b.iter(|| {\n-            let buf = [5 as u8; 100].to_vec();\n-            {\n-                let mut rdr = MemReader::new(buf);\n-                for _i in 0..10 {\n-                    let mut buf = [0 as u8; 10];\n-                    rdr.read(&mut buf).unwrap();\n-                    assert_eq!(buf, [5; 10]);\n-                }\n-            }\n-        });\n-    }\n-\n-    #[bench]\n-    fn bench_buf_writer(b: &mut Bencher) {\n-        b.iter(|| {\n-            let mut buf = [0 as u8; 100];\n-            {\n-                let mut wr = BufWriter::new(&mut buf);\n-                for _i in 0..10 {\n-                    wr.write(&[5; 10]).unwrap();\n-                }\n-            }\n-            assert_eq!(&buf[..], &[5; 100][..]);\n-        });\n-    }\n-\n-    #[bench]\n-    fn bench_buf_reader(b: &mut Bencher) {\n-        b.iter(|| {\n-            let buf = [5 as u8; 100];\n-            {\n-                let mut rdr = BufReader::new(&buf);\n-                for _i in 0..10 {\n-                    let mut buf = [0 as u8; 10];\n-                    rdr.read(&mut buf).unwrap();\n-                    assert_eq!(buf, [5; 10]);\n-                }\n-            }\n-        });\n-    }\n-}"}, {"sha": "f62b1a836fd10201a4452780afe93d0427245efc", "filename": "src/libstd/old_io/mod.rs", "status": "removed", "additions": 0, "deletions": 1984, "changes": 1984, "blob_url": "https://github.com/rust-lang/rust/blob/8415fa27877a4309a79b08c75a52eb4c3546b7a5/src%2Flibstd%2Fold_io%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8415fa27877a4309a79b08c75a52eb4c3546b7a5/src%2Flibstd%2Fold_io%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fmod.rs?ref=8415fa27877a4309a79b08c75a52eb4c3546b7a5", "patch": "@@ -1,1984 +0,0 @@\n-// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-//\n-// ignore-lexer-test FIXME #15883\n-\n-// FIXME: cover these topics:\n-//        path, reader, writer, stream, raii (close not needed),\n-//        stdio, print!, println!, file access, process spawning,\n-//        error handling\n-\n-\n-//! I/O, including files, networking, timers, and processes\n-//!\n-//! > **Warning**: This module is currently called `old_io` for a reason! The\n-//! > module is currently being redesigned in a number of RFCs. For more details\n-//! > follow the RFC repository in connection with [RFC 517][base] or follow\n-//! > some of these sub-RFCs\n-//! >\n-//! > * [String handling][osstr]\n-//! > * [Core I/O support][core]\n-//! > * [Deadlines][deadlines]\n-//! > * [std::env][env]\n-//! > * [std::process][process]\n-//!\n-//! [base]: https://github.com/rust-lang/rfcs/blob/master/text/0517-io-os-reform.md\n-//! [osstr]: https://github.com/rust-lang/rfcs/pull/575\n-//! [core]: https://github.com/rust-lang/rfcs/pull/576\n-//! [deadlines]: https://github.com/rust-lang/rfcs/pull/577\n-//! [env]: https://github.com/rust-lang/rfcs/pull/578\n-//! [process]: https://github.com/rust-lang/rfcs/pull/579\n-//!\n-//! `std::io` provides Rust's basic I/O types,\n-//! for reading and writing to files, TCP, UDP,\n-//! and other types of sockets and pipes,\n-//! manipulating the file system, spawning processes.\n-//!\n-//! # Examples\n-//!\n-//! Some examples of obvious things you might want to do\n-//!\n-//! * Read lines from stdin\n-//!\n-//!     ```rust\n-//!     # #![feature(old_io)]\n-//!     use std::old_io as io;\n-//!     use std::old_io::*;\n-//!\n-//!     let mut stdin = io::stdin();\n-//!     for line in stdin.lock().lines() {\n-//!         print!(\"{}\", line.unwrap());\n-//!     }\n-//!     ```\n-//!\n-//! * Read a complete file\n-//!\n-//!     ```rust\n-//!     # #![feature(old_io, old_path)]\n-//!     use std::old_io::*;\n-//!     use std::old_path::Path;\n-//!\n-//!     let contents = File::open(&Path::new(\"message.txt\")).read_to_end();\n-//!     ```\n-//!\n-//! * Write a line to a file\n-//!\n-//!     ```rust\n-//!     # #![feature(old_io, old_path)]\n-//!     # #![allow(unused_must_use)]\n-//!     use std::old_io::*;\n-//!     use std::old_path::Path;\n-//!\n-//!     let mut file = File::create(&Path::new(\"message.txt\"));\n-//!     file.write_all(b\"hello, file!\\n\");\n-//!     # drop(file);\n-//!     # ::std::old_io::fs::unlink(&Path::new(\"message.txt\"));\n-//!     ```\n-//!\n-//! * Iterate over the lines of a file\n-//!\n-//!     ```rust,no_run\n-//!     # #![feature(old_io, old_path)]\n-//!     use std::old_io::*;\n-//!     use std::old_path::Path;\n-//!\n-//!     let path = Path::new(\"message.txt\");\n-//!     let mut file = BufferedReader::new(File::open(&path));\n-//!     for line in file.lines() {\n-//!         print!(\"{}\", line.unwrap());\n-//!     }\n-//!     ```\n-//!\n-//! * Pull the lines of a file into a vector of strings\n-//!\n-//!     ```rust,no_run\n-//!     # #![feature(old_io, old_path)]\n-//!     use std::old_io::*;\n-//!     use std::old_path::Path;\n-//!\n-//!     let path = Path::new(\"message.txt\");\n-//!     let mut file = BufferedReader::new(File::open(&path));\n-//!     let lines: Vec<String> = file.lines().map(|x| x.unwrap()).collect();\n-//!     ```\n-//!\n-//! * Make a simple TCP client connection and request\n-//!\n-//!     ```rust\n-//!     # #![feature(old_io)]\n-//!     # #![allow(unused_must_use)]\n-//!     use std::old_io::*;\n-//!\n-//!     # // connection doesn't fail if a server is running on 8080\n-//!     # // locally, we still want to be type checking this code, so lets\n-//!     # // just stop it running (#11576)\n-//!     # if false {\n-//!     let mut socket = TcpStream::connect(\"127.0.0.1:8080\").unwrap();\n-//!     socket.write_all(b\"GET / HTTP/1.0\\n\\n\");\n-//!     let response = socket.read_to_end();\n-//!     # }\n-//!     ```\n-//!\n-//! * Make a simple TCP server\n-//!\n-//!     ```rust\n-//!     # #![feature(old_io)]\n-//!     # fn main() { }\n-//!     # fn foo() {\n-//!     # #![allow(dead_code)]\n-//!     use std::old_io::*;\n-//!     use std::thread;\n-//!\n-//!     let listener = TcpListener::bind(\"127.0.0.1:80\");\n-//!\n-//!     // bind the listener to the specified address\n-//!     let mut acceptor = listener.listen();\n-//!\n-//!     fn handle_client(mut stream: TcpStream) {\n-//!         // ...\n-//!     # &mut stream; // silence unused mutability/variable warning\n-//!     }\n-//!     // accept connections and process them, spawning a new tasks for each one\n-//!     for stream in acceptor.incoming() {\n-//!         match stream {\n-//!             Err(e) => { /* connection failed */ }\n-//!             Ok(stream) => {\n-//!                 thread::spawn(move|| {\n-//!                     // connection succeeded\n-//!                     handle_client(stream)\n-//!                 });\n-//!             }\n-//!         }\n-//!     }\n-//!\n-//!     // close the socket server\n-//!     drop(acceptor);\n-//!     # }\n-//!     ```\n-//!\n-//!\n-//! # Error Handling\n-//!\n-//! I/O is an area where nearly every operation can result in unexpected\n-//! errors. Errors should be painfully visible when they happen, and handling them\n-//! should be easy to work with. It should be convenient to handle specific I/O\n-//! errors, and it should also be convenient to not deal with I/O errors.\n-//!\n-//! Rust's I/O employs a combination of techniques to reduce boilerplate\n-//! while still providing feedback about errors. The basic strategy:\n-//!\n-//! * All I/O operations return `IoResult<T>` which is equivalent to\n-//!   `Result<T, IoError>`. The `Result` type is defined in the `std::result`\n-//!   module.\n-//! * If the `Result` type goes unused, then the compiler will by default emit a\n-//!   warning about the unused result. This is because `Result` has the\n-//!   `#[must_use]` attribute.\n-//! * Common traits are implemented for `IoResult`, e.g.\n-//!   `impl<R: Reader> Reader for IoResult<R>`, so that error values do not have\n-//!   to be 'unwrapped' before use.\n-//!\n-//! These features combine in the API to allow for expressions like\n-//! `File::create(&Path::new(\"diary.txt\")).write_all(b\"Met a girl.\\n\")`\n-//! without having to worry about whether \"diary.txt\" exists or whether\n-//! the write succeeds. As written, if either `new` or `write_line`\n-//! encounters an error then the result of the entire expression will\n-//! be an error.\n-//!\n-//! If you wanted to handle the error though you might write:\n-//!\n-//! ```rust\n-//! # #![feature(old_io, old_path)]\n-//! # #![allow(unused_must_use)]\n-//! use std::old_io::*;\n-//! use std::old_path::Path;\n-//!\n-//! match File::create(&Path::new(\"diary.txt\")).write_all(b\"Met a girl.\\n\") {\n-//!     Ok(()) => (), // succeeded\n-//!     Err(e) => println!(\"failed to write to my diary: {}\", e),\n-//! }\n-//!\n-//! # ::std::old_io::fs::unlink(&Path::new(\"diary.txt\"));\n-//! ```\n-//!\n-//! So what actually happens if `create` encounters an error?\n-//! It's important to know that what `new` returns is not a `File`\n-//! but an `IoResult<File>`.  If the file does not open, then `new` will simply\n-//! return `Err(..)`. Because there is an implementation of `Writer` (the trait\n-//! required ultimately required for types to implement `write_line`) there is no\n-//! need to inspect or unwrap the `IoResult<File>` and we simply call `write_line`\n-//! on it. If `new` returned an `Err(..)` then the followup call to `write_line`\n-//! will also return an error.\n-//!\n-//! ## `try!`\n-//!\n-//! Explicit pattern matching on `IoResult`s can get quite verbose, especially\n-//! when performing many I/O operations. Some examples (like those above) are\n-//! alleviated with extra methods implemented on `IoResult`, but others have more\n-//! complex interdependencies among each I/O operation.\n-//!\n-//! The `try!` macro from `std::macros` is provided as a method of early-return\n-//! inside `Result`-returning functions. It expands to an early-return on `Err`\n-//! and otherwise unwraps the contained `Ok` value.\n-//!\n-//! If you wanted to read several `u32`s from a file and return their product:\n-//!\n-//! ```rust\n-//! # #![feature(old_io, old_path)]\n-//! use std::old_io::*;\n-//! use std::old_path::Path;\n-//!\n-//! fn file_product(p: &Path) -> IoResult<u32> {\n-//!     let mut f = File::open(p);\n-//!     let x1 = try!(f.read_le_u32());\n-//!     let x2 = try!(f.read_le_u32());\n-//!\n-//!     Ok(x1 * x2)\n-//! }\n-//!\n-//! match file_product(&Path::new(\"numbers.bin\")) {\n-//!     Ok(x) => println!(\"{}\", x),\n-//!     Err(e) => println!(\"Failed to read numbers!\")\n-//! }\n-//! ```\n-//!\n-//! With `try!` in `file_product`, each `read_le_u32` need not be directly\n-//! concerned with error handling; instead its caller is responsible for\n-//! responding to errors that may occur while attempting to read the numbers.\n-\n-#![unstable(feature = \"old_io\")]\n-#![deny(unused_must_use)]\n-#![allow(deprecated)] // seriously this is all deprecated\n-#![allow(unused_imports)]\n-#![deprecated(since = \"1.0.0\",\n-              reasons = \"APIs have been replaced with new I/O modules such as \\\n-                         std::{io, fs, net, process}\")]\n-\n-pub use self::SeekStyle::*;\n-pub use self::FileMode::*;\n-pub use self::FileAccess::*;\n-pub use self::IoErrorKind::*;\n-\n-use default::Default;\n-use error::Error;\n-use fmt;\n-use isize;\n-use iter::Iterator;\n-use marker::{PhantomFn, Sized};\n-use mem::transmute;\n-use ops::FnOnce;\n-use option::Option;\n-use option::Option::{Some, None};\n-use sys::os;\n-use boxed::Box;\n-use result::Result;\n-use result::Result::{Ok, Err};\n-use sys;\n-use str;\n-use string::String;\n-use usize;\n-use unicode;\n-use vec::Vec;\n-\n-// Reexports\n-pub use self::stdio::stdin;\n-pub use self::stdio::stdout;\n-pub use self::stdio::stderr;\n-pub use self::stdio::print;\n-pub use self::stdio::println;\n-\n-pub use self::fs::File;\n-pub use self::timer::Timer;\n-pub use self::net::ip::IpAddr;\n-pub use self::net::tcp::TcpListener;\n-pub use self::net::tcp::TcpStream;\n-pub use self::pipe::PipeStream;\n-pub use self::process::{Process, Command};\n-pub use self::tempfile::TempDir;\n-\n-pub use self::mem::{MemReader, BufReader, MemWriter, BufWriter};\n-pub use self::buffered::{BufferedReader, BufferedWriter, BufferedStream,\n-                         LineBufferedWriter};\n-pub use self::comm_adapters::{ChanReader, ChanWriter};\n-\n-mod buffered;\n-mod comm_adapters;\n-mod mem;\n-mod result;\n-mod tempfile;\n-pub mod extensions;\n-pub mod fs;\n-pub mod net;\n-pub mod pipe;\n-pub mod process;\n-pub mod stdio;\n-pub mod timer;\n-pub mod util;\n-\n-#[macro_use]\n-pub mod test;\n-\n-/// The default buffer size for various I/O operations\n-// libuv recommends 64k buffers to maximize throughput\n-// https://groups.google.com/forum/#!topic/libuv/oQO1HJAIDdA\n-const DEFAULT_BUF_SIZE: usize = 1024 * 64;\n-\n-/// A convenient typedef of the return value of any I/O action.\n-pub type IoResult<T> = Result<T, IoError>;\n-\n-/// The type passed to I/O condition handlers to indicate error\n-///\n-/// # FIXME\n-///\n-/// Is something like this sufficient? It's kind of archaic\n-#[derive(PartialEq, Eq, Clone, Debug)]\n-pub struct IoError {\n-    /// An enumeration which can be matched against for determining the flavor\n-    /// of error.\n-    pub kind: IoErrorKind,\n-    /// A human-readable description about the error\n-    pub desc: &'static str,\n-    /// Detailed information about this error, not always available\n-    pub detail: Option<String>\n-}\n-\n-impl IoError {\n-    /// Convert an `errno` value into an `IoError`.\n-    ///\n-    /// If `detail` is `true`, the `detail` field of the `IoError`\n-    /// struct is filled with an allocated string describing the error\n-    /// in more detail, retrieved from the operating system.\n-    pub fn from_errno(errno: i32, detail: bool) -> IoError {\n-        let mut err = sys::decode_error(errno as i32);\n-        if detail && err.kind == OtherIoError {\n-            err.detail = Some(os::error_string(errno).to_lowercase());\n-        }\n-        err\n-    }\n-\n-    /// Retrieve the last error to occur as a (detailed) IoError.\n-    ///\n-    /// This uses the OS `errno`, and so there should not be any task\n-    /// descheduling or migration (other than that performed by the\n-    /// operating system) between the call(s) for which errors are\n-    /// being checked and the call of this function.\n-    pub fn last_error() -> IoError {\n-        IoError::from_errno(os::errno(), true)\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl fmt::Display for IoError {\n-    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n-        match *self {\n-            IoError { kind: OtherIoError, desc: \"unknown error\", detail: Some(ref detail) } =>\n-                write!(fmt, \"{}\", detail),\n-            IoError { detail: None, desc, .. } =>\n-                write!(fmt, \"{}\", desc),\n-            IoError { detail: Some(ref detail), desc, .. } =>\n-                write!(fmt, \"{} ({})\", desc, detail)\n-        }\n-    }\n-}\n-\n-impl Error for IoError {\n-    fn description(&self) -> &str { self.desc }\n-}\n-\n-/// A list specifying general categories of I/O error.\n-#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n-pub enum IoErrorKind {\n-    /// Any I/O error not part of this list.\n-    OtherIoError,\n-    /// The operation could not complete because end of file was reached.\n-    EndOfFile,\n-    /// The file was not found.\n-    FileNotFound,\n-    /// The file permissions disallowed access to this file.\n-    PermissionDenied,\n-    /// A network connection failed for some reason not specified in this list.\n-    ConnectionFailed,\n-    /// The network operation failed because the network connection was closed.\n-    Closed,\n-    /// The connection was refused by the remote server.\n-    ConnectionRefused,\n-    /// The connection was reset by the remote server.\n-    ConnectionReset,\n-    /// The connection was aborted (terminated) by the remote server.\n-    ConnectionAborted,\n-    /// The network operation failed because it was not connected yet.\n-    NotConnected,\n-    /// The operation failed because a pipe was closed.\n-    BrokenPipe,\n-    /// A file already existed with that name.\n-    PathAlreadyExists,\n-    /// No file exists at that location.\n-    PathDoesntExist,\n-    /// The path did not specify the type of file that this operation required. For example,\n-    /// attempting to copy a directory with the `fs::copy()` operation will fail with this error.\n-    MismatchedFileTypeForOperation,\n-    /// The operation temporarily failed (for example, because a signal was received), and retrying\n-    /// may succeed.\n-    ResourceUnavailable,\n-    /// No I/O functionality is available for this task.\n-    IoUnavailable,\n-    /// A parameter was incorrect in a way that caused an I/O error not part of this list.\n-    InvalidInput,\n-    /// The I/O operation's timeout expired, causing it to be canceled.\n-    TimedOut,\n-    /// This write operation failed to write all of its data.\n-    ///\n-    /// Normally the write() method on a Writer guarantees that all of its data\n-    /// has been written, but some operations may be terminated after only\n-    /// partially writing some data. An example of this is a timed out write\n-    /// which successfully wrote a known number of bytes, but bailed out after\n-    /// doing so.\n-    ///\n-    /// The payload contained as part of this variant is the number of bytes\n-    /// which are known to have been successfully written.\n-    ShortWrite(usize),\n-    /// The Reader returned 0 bytes from `read()` too many times.\n-    NoProgress,\n-}\n-\n-/// A trait that lets you add a `detail` to an IoError easily\n-trait UpdateIoError {\n-    /// Returns an IoError with updated description and detail\n-    fn update_err<D>(self, desc: &'static str, detail: D) -> Self where\n-        D: FnOnce(&IoError) -> String;\n-\n-    /// Returns an IoError with updated detail\n-    fn update_detail<D>(self, detail: D) -> Self where\n-        D: FnOnce(&IoError) -> String;\n-\n-    /// Returns an IoError with update description\n-    fn update_desc(self, desc: &'static str) -> Self;\n-}\n-\n-impl<T> UpdateIoError for IoResult<T> {\n-    fn update_err<D>(self, desc: &'static str, detail: D) -> IoResult<T> where\n-        D: FnOnce(&IoError) -> String,\n-    {\n-        self.map_err(move |mut e| {\n-            let detail = detail(&e);\n-            e.desc = desc;\n-            e.detail = Some(detail);\n-            e\n-        })\n-    }\n-\n-    fn update_detail<D>(self, detail: D) -> IoResult<T> where\n-        D: FnOnce(&IoError) -> String,\n-    {\n-        self.map_err(move |mut e| { e.detail = Some(detail(&e)); e })\n-    }\n-\n-    fn update_desc(self, desc: &'static str) -> IoResult<T> {\n-        self.map_err(|mut e| { e.desc = desc; e })\n-    }\n-}\n-\n-static NO_PROGRESS_LIMIT: usize = 1000;\n-\n-/// A trait for objects which are byte-oriented streams. Readers are defined by\n-/// one method, `read`. This function will block until data is available,\n-/// filling in the provided buffer with any data read.\n-///\n-/// Readers are intended to be composable with one another. Many objects\n-/// throughout the I/O and related libraries take and provide types which\n-/// implement the `Reader` trait.\n-pub trait Reader {\n-\n-    // Only method which need to get implemented for this trait\n-\n-    /// Read bytes, up to the length of `buf` and place them in `buf`.\n-    /// Returns the number of bytes read. The number of bytes read may\n-    /// be less than the number requested, even 0. Returns `Err` on EOF.\n-    ///\n-    /// # Error\n-    ///\n-    /// If an error occurs during this I/O operation, then it is returned as\n-    /// `Err(IoError)`. Note that end-of-file is considered an error, and can be\n-    /// inspected for in the error's `kind` field. Also note that reading 0\n-    /// bytes is not considered an error in all circumstances\n-    ///\n-    /// # Implementation Note\n-    ///\n-    /// When implementing this method on a new Reader, you are strongly encouraged\n-    /// not to return 0 if you can avoid it.\n-    fn read(&mut self, buf: &mut [u8]) -> IoResult<usize>;\n-\n-    // Convenient helper methods based on the above methods\n-\n-    /// Reads at least `min` bytes and places them in `buf`.\n-    /// Returns the number of bytes read.\n-    ///\n-    /// This will continue to call `read` until at least `min` bytes have been\n-    /// read. If `read` returns 0 too many times, `NoProgress` will be\n-    /// returned.\n-    ///\n-    /// # Error\n-    ///\n-    /// If an error occurs at any point, that error is returned, and no further\n-    /// bytes are read.\n-    fn read_at_least(&mut self, min: usize, buf: &mut [u8]) -> IoResult<usize> {\n-        if min > buf.len() {\n-            return Err(IoError {\n-                detail: Some(String::from_str(\"the buffer is too short\")),\n-                ..standard_error(InvalidInput)\n-            });\n-        }\n-        let mut read = 0;\n-        while read < min {\n-            let mut zeroes = 0;\n-            loop {\n-                match self.read(&mut buf[read..]) {\n-                    Ok(0) => {\n-                        zeroes += 1;\n-                        if zeroes >= NO_PROGRESS_LIMIT {\n-                            return Err(standard_error(NoProgress));\n-                        }\n-                    }\n-                    Ok(n) => {\n-                        read += n;\n-                        break;\n-                    }\n-                    err@Err(_) => return err\n-                }\n-            }\n-        }\n-        Ok(read)\n-    }\n-\n-    /// Reads a single byte. Returns `Err` on EOF.\n-    fn read_byte(&mut self) -> IoResult<u8> {\n-        let mut buf = [0];\n-        try!(self.read_at_least(1, &mut buf));\n-        Ok(buf[0])\n-    }\n-\n-    /// Reads up to `len` bytes and appends them to a vector.\n-    /// Returns the number of bytes read. The number of bytes read may be\n-    /// less than the number requested, even 0. Returns Err on EOF.\n-    ///\n-    /// # Error\n-    ///\n-    /// If an error occurs during this I/O operation, then it is returned\n-    /// as `Err(IoError)`. See `read()` for more details.\n-    fn push(&mut self, len: usize, buf: &mut Vec<u8>) -> IoResult<usize> {\n-        let start_len = buf.len();\n-        buf.reserve(len);\n-\n-        let n = {\n-            let s = unsafe { slice_vec_capacity(buf, start_len, start_len + len) };\n-            try!(self.read(s))\n-        };\n-        unsafe { buf.set_len(start_len + n) };\n-        Ok(n)\n-    }\n-\n-    /// Reads at least `min` bytes, but no more than `len`, and appends them to\n-    /// a vector.\n-    /// Returns the number of bytes read.\n-    ///\n-    /// This will continue to call `read` until at least `min` bytes have been\n-    /// read. If `read` returns 0 too many times, `NoProgress` will be\n-    /// returned.\n-    ///\n-    /// # Error\n-    ///\n-    /// If an error occurs at any point, that error is returned, and no further\n-    /// bytes are read.\n-    fn push_at_least(&mut self, min: usize, len: usize, buf: &mut Vec<u8>) -> IoResult<usize> {\n-        if min > len {\n-            return Err(IoError {\n-                detail: Some(String::from_str(\"the buffer is too short\")),\n-                ..standard_error(InvalidInput)\n-            });\n-        }\n-\n-        let start_len = buf.len();\n-        buf.reserve(len);\n-\n-        // we can't just use self.read_at_least(min, slice) because we need to push\n-        // successful reads onto the vector before any returned errors.\n-\n-        let mut read = 0;\n-        while read < min {\n-            read += {\n-                let s = unsafe { slice_vec_capacity(buf, start_len + read, start_len + len) };\n-                try!(self.read_at_least(1, s))\n-            };\n-            unsafe { buf.set_len(start_len + read) };\n-        }\n-        Ok(read)\n-    }\n-\n-    /// Reads exactly `len` bytes and gives you back a new vector of length\n-    /// `len`\n-    ///\n-    /// # Error\n-    ///\n-    /// Fails with the same conditions as `read`. Additionally returns error\n-    /// on EOF. Note that if an error is returned, then some number of bytes may\n-    /// have already been consumed from the underlying reader, and they are lost\n-    /// (not returned as part of the error). If this is unacceptable, then it is\n-    /// recommended to use the `push_at_least` or `read` methods.\n-    fn read_exact(&mut self, len: usize) -> IoResult<Vec<u8>> {\n-        let mut buf = Vec::with_capacity(len);\n-        match self.push_at_least(len, len, &mut buf) {\n-            Ok(_) => Ok(buf),\n-            Err(e) => Err(e),\n-        }\n-    }\n-\n-    /// Reads all remaining bytes from the stream.\n-    ///\n-    /// # Error\n-    ///\n-    /// Returns any non-EOF error immediately. Previously read bytes are\n-    /// discarded when an error is returned.\n-    ///\n-    /// When EOF is encountered, all bytes read up to that point are returned.\n-    fn read_to_end(&mut self) -> IoResult<Vec<u8>> {\n-        let mut buf = Vec::with_capacity(DEFAULT_BUF_SIZE);\n-        loop {\n-            match self.push_at_least(1, DEFAULT_BUF_SIZE, &mut buf) {\n-                Ok(_) => {}\n-                Err(ref e) if e.kind == EndOfFile => break,\n-                Err(e) => return Err(e)\n-            }\n-        }\n-        return Ok(buf);\n-    }\n-\n-    /// Reads all of the remaining bytes of this stream, interpreting them as a\n-    /// UTF-8 encoded stream. The corresponding string is returned.\n-    ///\n-    /// # Error\n-    ///\n-    /// This function returns all of the same errors as `read_to_end` with an\n-    /// additional error if the reader's contents are not a valid sequence of\n-    /// UTF-8 bytes.\n-    fn read_to_string(&mut self) -> IoResult<String> {\n-        self.read_to_end().and_then(|s| {\n-            match String::from_utf8(s) {\n-                Ok(s)  => Ok(s),\n-                Err(_) => Err(standard_error(InvalidInput)),\n-            }\n-        })\n-    }\n-\n-    // Byte conversion helpers\n-\n-    /// Reads `n` little-endian unsigned integer bytes.\n-    ///\n-    /// `n` must be between 1 and 8, inclusive.\n-    fn read_le_uint_n(&mut self, nbytes: usize) -> IoResult<u64> {\n-        assert!(nbytes > 0 && nbytes <= 8);\n-\n-        let mut val = 0;\n-        let mut pos = 0;\n-        let mut i = nbytes;\n-        while i > 0 {\n-            val += (try!(self.read_u8()) as u64) << pos;\n-            pos += 8;\n-            i -= 1;\n-        }\n-        Ok(val)\n-    }\n-\n-    /// Reads `n` little-endian signed integer bytes.\n-    ///\n-    /// `n` must be between 1 and 8, inclusive.\n-    fn read_le_int_n(&mut self, nbytes: usize) -> IoResult<i64> {\n-        self.read_le_uint_n(nbytes).map(|i| extend_sign(i, nbytes))\n-    }\n-\n-    /// Reads `n` big-endian unsigned integer bytes.\n-    ///\n-    /// `n` must be between 1 and 8, inclusive.\n-    fn read_be_uint_n(&mut self, nbytes: usize) -> IoResult<u64> {\n-        assert!(nbytes > 0 && nbytes <= 8);\n-\n-        let mut val = 0;\n-        let mut i = nbytes;\n-        while i > 0 {\n-            i -= 1;\n-            val += (try!(self.read_u8()) as u64) << i * 8;\n-        }\n-        Ok(val)\n-    }\n-\n-    /// Reads `n` big-endian signed integer bytes.\n-    ///\n-    /// `n` must be between 1 and 8, inclusive.\n-    fn read_be_int_n(&mut self, nbytes: usize) -> IoResult<i64> {\n-        self.read_be_uint_n(nbytes).map(|i| extend_sign(i, nbytes))\n-    }\n-\n-    /// Reads a little-endian unsigned integer.\n-    ///\n-    /// The number of bytes returned is system-dependent.\n-    fn read_le_uint(&mut self) -> IoResult<usize> {\n-        self.read_le_uint_n(usize::BYTES).map(|i| i as usize)\n-    }\n-\n-    /// Reads a little-endian integer.\n-    ///\n-    /// The number of bytes returned is system-dependent.\n-    fn read_le_int(&mut self) -> IoResult<isize> {\n-        self.read_le_int_n(isize::BYTES).map(|i| i as isize)\n-    }\n-\n-    /// Reads a big-endian unsigned integer.\n-    ///\n-    /// The number of bytes returned is system-dependent.\n-    fn read_be_uint(&mut self) -> IoResult<usize> {\n-        self.read_be_uint_n(usize::BYTES).map(|i| i as usize)\n-    }\n-\n-    /// Reads a big-endian integer.\n-    ///\n-    /// The number of bytes returned is system-dependent.\n-    fn read_be_int(&mut self) -> IoResult<isize> {\n-        self.read_be_int_n(isize::BYTES).map(|i| i as isize)\n-    }\n-\n-    /// Reads a big-endian `u64`.\n-    ///\n-    /// `u64`s are 8 bytes long.\n-    fn read_be_u64(&mut self) -> IoResult<u64> {\n-        self.read_be_uint_n(8)\n-    }\n-\n-    /// Reads a big-endian `u32`.\n-    ///\n-    /// `u32`s are 4 bytes long.\n-    fn read_be_u32(&mut self) -> IoResult<u32> {\n-        self.read_be_uint_n(4).map(|i| i as u32)\n-    }\n-\n-    /// Reads a big-endian `u16`.\n-    ///\n-    /// `u16`s are 2 bytes long.\n-    fn read_be_u16(&mut self) -> IoResult<u16> {\n-        self.read_be_uint_n(2).map(|i| i as u16)\n-    }\n-\n-    /// Reads a big-endian `i64`.\n-    ///\n-    /// `i64`s are 8 bytes long.\n-    fn read_be_i64(&mut self) -> IoResult<i64> {\n-        self.read_be_int_n(8)\n-    }\n-\n-    /// Reads a big-endian `i32`.\n-    ///\n-    /// `i32`s are 4 bytes long.\n-    fn read_be_i32(&mut self) -> IoResult<i32> {\n-        self.read_be_int_n(4).map(|i| i as i32)\n-    }\n-\n-    /// Reads a big-endian `i16`.\n-    ///\n-    /// `i16`s are 2 bytes long.\n-    fn read_be_i16(&mut self) -> IoResult<i16> {\n-        self.read_be_int_n(2).map(|i| i as i16)\n-    }\n-\n-    /// Reads a big-endian `f64`.\n-    ///\n-    /// `f64`s are 8 byte, IEEE754 double-precision floating point numbers.\n-    fn read_be_f64(&mut self) -> IoResult<f64> {\n-        self.read_be_u64().map(|i| unsafe {\n-            transmute::<u64, f64>(i)\n-        })\n-    }\n-\n-    /// Reads a big-endian `f32`.\n-    ///\n-    /// `f32`s are 4 byte, IEEE754 single-precision floating point numbers.\n-    fn read_be_f32(&mut self) -> IoResult<f32> {\n-        self.read_be_u32().map(|i| unsafe {\n-            transmute::<u32, f32>(i)\n-        })\n-    }\n-\n-    /// Reads a little-endian `u64`.\n-    ///\n-    /// `u64`s are 8 bytes long.\n-    fn read_le_u64(&mut self) -> IoResult<u64> {\n-        self.read_le_uint_n(8)\n-    }\n-\n-    /// Reads a little-endian `u32`.\n-    ///\n-    /// `u32`s are 4 bytes long.\n-    fn read_le_u32(&mut self) -> IoResult<u32> {\n-        self.read_le_uint_n(4).map(|i| i as u32)\n-    }\n-\n-    /// Reads a little-endian `u16`.\n-    ///\n-    /// `u16`s are 2 bytes long.\n-    fn read_le_u16(&mut self) -> IoResult<u16> {\n-        self.read_le_uint_n(2).map(|i| i as u16)\n-    }\n-\n-    /// Reads a little-endian `i64`.\n-    ///\n-    /// `i64`s are 8 bytes long.\n-    fn read_le_i64(&mut self) -> IoResult<i64> {\n-        self.read_le_int_n(8)\n-    }\n-\n-    /// Reads a little-endian `i32`.\n-    ///\n-    /// `i32`s are 4 bytes long.\n-    fn read_le_i32(&mut self) -> IoResult<i32> {\n-        self.read_le_int_n(4).map(|i| i as i32)\n-    }\n-\n-    /// Reads a little-endian `i16`.\n-    ///\n-    /// `i16`s are 2 bytes long.\n-    fn read_le_i16(&mut self) -> IoResult<i16> {\n-        self.read_le_int_n(2).map(|i| i as i16)\n-    }\n-\n-    /// Reads a little-endian `f64`.\n-    ///\n-    /// `f64`s are 8 byte, IEEE754 double-precision floating point numbers.\n-    fn read_le_f64(&mut self) -> IoResult<f64> {\n-        self.read_le_u64().map(|i| unsafe {\n-            transmute::<u64, f64>(i)\n-        })\n-    }\n-\n-    /// Reads a little-endian `f32`.\n-    ///\n-    /// `f32`s are 4 byte, IEEE754 single-precision floating point numbers.\n-    fn read_le_f32(&mut self) -> IoResult<f32> {\n-        self.read_le_u32().map(|i| unsafe {\n-            transmute::<u32, f32>(i)\n-        })\n-    }\n-\n-    /// Read a u8.\n-    ///\n-    /// `u8`s are 1 byte.\n-    fn read_u8(&mut self) -> IoResult<u8> {\n-        self.read_byte()\n-    }\n-\n-    /// Read an i8.\n-    ///\n-    /// `i8`s are 1 byte.\n-    fn read_i8(&mut self) -> IoResult<i8> {\n-        self.read_byte().map(|i| i as i8)\n-    }\n-}\n-\n-/// A reader which can be converted to a RefReader.\n-pub trait ByRefReader {\n-    /// Creates a wrapper around a mutable reference to the reader.\n-    ///\n-    /// This is useful to allow applying adaptors while still\n-    /// retaining ownership of the original value.\n-    fn by_ref<'a>(&'a mut self) -> RefReader<'a, Self>;\n-}\n-\n-impl<T: Reader> ByRefReader for T {\n-    fn by_ref<'a>(&'a mut self) -> RefReader<'a, T> {\n-        RefReader { inner: self }\n-    }\n-}\n-\n-/// A reader which can be converted to bytes.\n-pub trait BytesReader {\n-    /// Create an iterator that reads a single byte on\n-    /// each iteration, until EOF.\n-    ///\n-    /// # Error\n-    ///\n-    /// Any error other than `EndOfFile` that is produced by the underlying Reader\n-    /// is returned by the iterator and should be handled by the caller.\n-    fn bytes<'r>(&'r mut self) -> extensions::Bytes<'r, Self>;\n-}\n-\n-impl<T: Reader> BytesReader for T {\n-    fn bytes<'r>(&'r mut self) -> extensions::Bytes<'r, T> {\n-        extensions::Bytes::new(self)\n-    }\n-}\n-\n-impl<'a> Reader for Box<Reader+'a> {\n-    fn read(&mut self, buf: &mut [u8]) -> IoResult<usize> {\n-        let reader: &mut Reader = &mut **self;\n-        reader.read(buf)\n-    }\n-}\n-\n-impl<'a> Reader for &'a mut (Reader+'a) {\n-    fn read(&mut self, buf: &mut [u8]) -> IoResult<usize> { (*self).read(buf) }\n-}\n-\n-/// Returns a slice of `v` between `start` and `end`.\n-///\n-/// Similar to `slice()` except this function only bounds the slice on the\n-/// capacity of `v`, not the length.\n-///\n-/// # Panics\n-///\n-/// Panics when `start` or `end` point outside the capacity of `v`, or when\n-/// `start` > `end`.\n-// Private function here because we aren't sure if we want to expose this as\n-// API yet. If so, it should be a method on Vec.\n-unsafe fn slice_vec_capacity<'a, T>(v: &'a mut Vec<T>, start: usize, end: usize) -> &'a mut [T] {\n-    use slice;\n-\n-    assert!(start <= end);\n-    assert!(end <= v.capacity());\n-    slice::from_raw_parts_mut(\n-        v.as_mut_ptr().offset(start as isize),\n-        end - start\n-    )\n-}\n-\n-/// A `RefReader` is a struct implementing `Reader` which contains a reference\n-/// to another reader. This is often useful when composing streams.\n-///\n-/// # Examples\n-///\n-/// ```\n-/// # #![feature(old_io)]\n-/// use std::old_io as io;\n-/// use std::old_io::*;\n-/// use std::old_io::util::LimitReader;\n-///\n-/// fn process_input<R: Reader>(r: R) {}\n-///\n-/// let mut stream = io::stdin();\n-///\n-/// // Only allow the function to process at most one kilobyte of input\n-/// {\n-///     let stream = LimitReader::new(stream.by_ref(), 1024);\n-///     process_input(stream);\n-/// }\n-///\n-/// // 'stream' is still available for use here\n-/// ```\n-pub struct RefReader<'a, R:'a> {\n-    /// The underlying reader which this is referencing\n-    inner: &'a mut R\n-}\n-\n-impl<'a, R: Reader> Reader for RefReader<'a, R> {\n-    fn read(&mut self, buf: &mut [u8]) -> IoResult<usize> { self.inner.read(buf) }\n-}\n-\n-impl<'a, R: Buffer> Buffer for RefReader<'a, R> {\n-    fn fill_buf(&mut self) -> IoResult<&[u8]> { self.inner.fill_buf() }\n-    fn consume(&mut self, amt: usize) { self.inner.consume(amt) }\n-}\n-\n-fn extend_sign(val: u64, nbytes: usize) -> i64 {\n-    let shift = (8 - nbytes) * 8;\n-    (val << shift) as i64 >> shift\n-}\n-\n-/// A trait for objects which are byte-oriented streams. Writers are defined by\n-/// one method, `write`. This function will block until the provided buffer of\n-/// bytes has been entirely written, and it will return any failures which occur.\n-///\n-/// Another commonly overridden method is the `flush` method for writers such as\n-/// buffered writers.\n-///\n-/// Writers are intended to be composable with one another. Many objects\n-/// throughout the I/O and related libraries take and provide types which\n-/// implement the `Writer` trait.\n-pub trait Writer {\n-    /// Write the entirety of a given buffer\n-    ///\n-    /// # Errors\n-    ///\n-    /// If an error happens during the I/O operation, the error is returned as\n-    /// `Err`. Note that it is considered an error if the entire buffer could\n-    /// not be written, and if an error is returned then it is unknown how much\n-    /// data (if any) was actually written.\n-    fn write_all(&mut self, buf: &[u8]) -> IoResult<()>;\n-\n-    /// Deprecated, this method was renamed to `write_all`\n-    #[unstable(feature = \"io\")]\n-    #[deprecated(since = \"1.0.0\", reason = \"renamed to `write_all`\")]\n-    fn write(&mut self, buf: &[u8]) -> IoResult<()> { self.write_all(buf) }\n-\n-    /// Flush this output stream, ensuring that all intermediately buffered\n-    /// contents reach their destination.\n-    ///\n-    /// This is by default a no-op and implementers of the `Writer` trait should\n-    /// decide whether their stream needs to be buffered or not.\n-    fn flush(&mut self) -> IoResult<()> { Ok(()) }\n-\n-    /// Writes a formatted string into this writer, returning any error\n-    /// encountered.\n-    ///\n-    /// This method is primarily used to interface with the `format_args!`\n-    /// macro, but it is rare that this should explicitly be called. The\n-    /// `write!` macro should be favored to invoke this method instead.\n-    ///\n-    /// # Errors\n-    ///\n-    /// This function will return any I/O error reported while formatting.\n-    fn write_fmt(&mut self, fmt: fmt::Arguments) -> IoResult<()> {\n-        // Create a shim which translates a Writer to a fmt::Write and saves\n-        // off I/O errors. instead of discarding them\n-        struct Adaptor<'a, T: ?Sized +'a> {\n-            inner: &'a mut T,\n-            error: IoResult<()>,\n-        }\n-\n-        impl<'a, T: ?Sized + Writer> fmt::Write for Adaptor<'a, T> {\n-            fn write_str(&mut self, s: &str) -> fmt::Result {\n-                match self.inner.write_all(s.as_bytes()) {\n-                    Ok(()) => Ok(()),\n-                    Err(e) => {\n-                        self.error = Err(e);\n-                        Err(fmt::Error)\n-                    }\n-                }\n-            }\n-        }\n-\n-        let mut output = Adaptor { inner: self, error: Ok(()) };\n-        match fmt::write(&mut output, fmt) {\n-            Ok(()) => Ok(()),\n-            Err(..) => output.error\n-        }\n-    }\n-\n-\n-    /// Write a rust string into this sink.\n-    ///\n-    /// The bytes written will be the UTF-8 encoded version of the input string.\n-    /// If other encodings are desired, it is recommended to compose this stream\n-    /// with another performing the conversion, or to use `write` with a\n-    /// converted byte-array instead.\n-    #[inline]\n-    fn write_str(&mut self, s: &str) -> IoResult<()> {\n-        self.write_all(s.as_bytes())\n-    }\n-\n-    /// Writes a string into this sink, and then writes a literal newline (`\\n`)\n-    /// byte afterwards. Note that the writing of the newline is *not* atomic in\n-    /// the sense that the call to `write` is invoked twice (once with the\n-    /// string and once with a newline character).\n-    ///\n-    /// If other encodings or line ending flavors are desired, it is recommended\n-    /// that the `write` method is used specifically instead.\n-    #[inline]\n-    fn write_line(&mut self, s: &str) -> IoResult<()> {\n-        self.write_str(s).and_then(|()| self.write_all(&[b'\\n']))\n-    }\n-\n-    /// Write a single char, encoded as UTF-8.\n-    #[inline]\n-    fn write_char(&mut self, c: char) -> IoResult<()> {\n-        let mut buf = [0; 4];\n-        let n = c.encode_utf8(&mut buf).unwrap_or(0);\n-        self.write_all(&buf[..n])\n-    }\n-\n-    /// Write the result of passing n through `isize::to_str_bytes`.\n-    #[inline]\n-    fn write_int(&mut self, n: isize) -> IoResult<()> {\n-        write!(self, \"{}\", n)\n-    }\n-\n-    /// Write the result of passing n through `usize::to_str_bytes`.\n-    #[inline]\n-    fn write_uint(&mut self, n: usize) -> IoResult<()> {\n-        write!(self, \"{}\", n)\n-    }\n-\n-    /// Write a little-endian usize (number of bytes depends on system).\n-    #[inline]\n-    fn write_le_uint(&mut self, n: usize) -> IoResult<()> {\n-        extensions::u64_to_le_bytes(n as u64, usize::BYTES, |v| self.write_all(v))\n-    }\n-\n-    /// Write a little-endian isize (number of bytes depends on system).\n-    #[inline]\n-    fn write_le_int(&mut self, n: isize) -> IoResult<()> {\n-        extensions::u64_to_le_bytes(n as u64, isize::BYTES, |v| self.write_all(v))\n-    }\n-\n-    /// Write a big-endian usize (number of bytes depends on system).\n-    #[inline]\n-    fn write_be_uint(&mut self, n: usize) -> IoResult<()> {\n-        extensions::u64_to_be_bytes(n as u64, usize::BYTES, |v| self.write_all(v))\n-    }\n-\n-    /// Write a big-endian isize (number of bytes depends on system).\n-    #[inline]\n-    fn write_be_int(&mut self, n: isize) -> IoResult<()> {\n-        extensions::u64_to_be_bytes(n as u64, isize::BYTES, |v| self.write_all(v))\n-    }\n-\n-    /// Write a big-endian u64 (8 bytes).\n-    #[inline]\n-    fn write_be_u64(&mut self, n: u64) -> IoResult<()> {\n-        extensions::u64_to_be_bytes(n, 8, |v| self.write_all(v))\n-    }\n-\n-    /// Write a big-endian u32 (4 bytes).\n-    #[inline]\n-    fn write_be_u32(&mut self, n: u32) -> IoResult<()> {\n-        extensions::u64_to_be_bytes(n as u64, 4, |v| self.write_all(v))\n-    }\n-\n-    /// Write a big-endian u16 (2 bytes).\n-    #[inline]\n-    fn write_be_u16(&mut self, n: u16) -> IoResult<()> {\n-        extensions::u64_to_be_bytes(n as u64, 2, |v| self.write_all(v))\n-    }\n-\n-    /// Write a big-endian i64 (8 bytes).\n-    #[inline]\n-    fn write_be_i64(&mut self, n: i64) -> IoResult<()> {\n-        extensions::u64_to_be_bytes(n as u64, 8, |v| self.write_all(v))\n-    }\n-\n-    /// Write a big-endian i32 (4 bytes).\n-    #[inline]\n-    fn write_be_i32(&mut self, n: i32) -> IoResult<()> {\n-        extensions::u64_to_be_bytes(n as u64, 4, |v| self.write_all(v))\n-    }\n-\n-    /// Write a big-endian i16 (2 bytes).\n-    #[inline]\n-    fn write_be_i16(&mut self, n: i16) -> IoResult<()> {\n-        extensions::u64_to_be_bytes(n as u64, 2, |v| self.write_all(v))\n-    }\n-\n-    /// Write a big-endian IEEE754 double-precision floating-point (8 bytes).\n-    #[inline]\n-    fn write_be_f64(&mut self, f: f64) -> IoResult<()> {\n-        unsafe {\n-            self.write_be_u64(transmute(f))\n-        }\n-    }\n-\n-    /// Write a big-endian IEEE754 single-precision floating-point (4 bytes).\n-    #[inline]\n-    fn write_be_f32(&mut self, f: f32) -> IoResult<()> {\n-        unsafe {\n-            self.write_be_u32(transmute(f))\n-        }\n-    }\n-\n-    /// Write a little-endian u64 (8 bytes).\n-    #[inline]\n-    fn write_le_u64(&mut self, n: u64) -> IoResult<()> {\n-        extensions::u64_to_le_bytes(n, 8, |v| self.write_all(v))\n-    }\n-\n-    /// Write a little-endian u32 (4 bytes).\n-    #[inline]\n-    fn write_le_u32(&mut self, n: u32) -> IoResult<()> {\n-        extensions::u64_to_le_bytes(n as u64, 4, |v| self.write_all(v))\n-    }\n-\n-    /// Write a little-endian u16 (2 bytes).\n-    #[inline]\n-    fn write_le_u16(&mut self, n: u16) -> IoResult<()> {\n-        extensions::u64_to_le_bytes(n as u64, 2, |v| self.write_all(v))\n-    }\n-\n-    /// Write a little-endian i64 (8 bytes).\n-    #[inline]\n-    fn write_le_i64(&mut self, n: i64) -> IoResult<()> {\n-        extensions::u64_to_le_bytes(n as u64, 8, |v| self.write_all(v))\n-    }\n-\n-    /// Write a little-endian i32 (4 bytes).\n-    #[inline]\n-    fn write_le_i32(&mut self, n: i32) -> IoResult<()> {\n-        extensions::u64_to_le_bytes(n as u64, 4, |v| self.write_all(v))\n-    }\n-\n-    /// Write a little-endian i16 (2 bytes).\n-    #[inline]\n-    fn write_le_i16(&mut self, n: i16) -> IoResult<()> {\n-        extensions::u64_to_le_bytes(n as u64, 2, |v| self.write_all(v))\n-    }\n-\n-    /// Write a little-endian IEEE754 double-precision floating-point\n-    /// (8 bytes).\n-    #[inline]\n-    fn write_le_f64(&mut self, f: f64) -> IoResult<()> {\n-        unsafe {\n-            self.write_le_u64(transmute(f))\n-        }\n-    }\n-\n-    /// Write a little-endian IEEE754 single-precision floating-point\n-    /// (4 bytes).\n-    #[inline]\n-    fn write_le_f32(&mut self, f: f32) -> IoResult<()> {\n-        unsafe {\n-            self.write_le_u32(transmute(f))\n-        }\n-    }\n-\n-    /// Write a u8 (1 byte).\n-    #[inline]\n-    fn write_u8(&mut self, n: u8) -> IoResult<()> {\n-        self.write_all(&[n])\n-    }\n-\n-    /// Write an i8 (1 byte).\n-    #[inline]\n-    fn write_i8(&mut self, n: i8) -> IoResult<()> {\n-        self.write_all(&[n as u8])\n-    }\n-}\n-\n-/// A writer which can be converted to a RefWriter.\n-pub trait ByRefWriter {\n-    /// Creates a wrapper around a mutable reference to the writer.\n-    ///\n-    /// This is useful to allow applying wrappers while still\n-    /// retaining ownership of the original value.\n-    #[inline]\n-    fn by_ref<'a>(&'a mut self) -> RefWriter<'a, Self>;\n-}\n-\n-impl<T: Writer> ByRefWriter for T {\n-    fn by_ref<'a>(&'a mut self) -> RefWriter<'a, T> {\n-        RefWriter { inner: self }\n-    }\n-}\n-\n-impl<'a> Writer for Box<Writer+'a> {\n-    #[inline]\n-    fn write_all(&mut self, buf: &[u8]) -> IoResult<()> {\n-        (&mut **self).write_all(buf)\n-    }\n-\n-    #[inline]\n-    fn flush(&mut self) -> IoResult<()> {\n-        (&mut **self).flush()\n-    }\n-}\n-\n-impl<'a> Writer for &'a mut (Writer+'a) {\n-    #[inline]\n-    fn write_all(&mut self, buf: &[u8]) -> IoResult<()> { (**self).write_all(buf) }\n-\n-    #[inline]\n-    fn flush(&mut self) -> IoResult<()> { (**self).flush() }\n-}\n-\n-/// A `RefWriter` is a struct implementing `Writer` which contains a reference\n-/// to another writer. This is often useful when composing streams.\n-///\n-/// # Examples\n-///\n-/// ```\n-/// # #![feature(old_io)]\n-/// use std::old_io::util::TeeReader;\n-/// use std::old_io::*;\n-///\n-/// fn process_input<R: Reader>(r: R) {}\n-///\n-/// let mut output = Vec::new();\n-///\n-/// {\n-///     // Don't give ownership of 'output' to the 'tee'. Instead we keep a\n-///     // handle to it in the outer scope\n-///     let mut tee = TeeReader::new(stdin(), output.by_ref());\n-///     process_input(tee);\n-/// }\n-///\n-/// println!(\"input processed: {:?}\", output);\n-/// ```\n-pub struct RefWriter<'a, W:'a> {\n-    /// The underlying writer which this is referencing\n-    inner: &'a mut W\n-}\n-\n-impl<'a, W: Writer> Writer for RefWriter<'a, W> {\n-    #[inline]\n-    fn write_all(&mut self, buf: &[u8]) -> IoResult<()> { self.inner.write_all(buf) }\n-\n-    #[inline]\n-    fn flush(&mut self) -> IoResult<()> { self.inner.flush() }\n-}\n-\n-\n-/// A Stream is a readable and a writable object. Data written is typically\n-/// received by the object which reads receive data from.\n-pub trait Stream: Reader + Writer { }\n-\n-impl<T: Reader + Writer> Stream for T {}\n-\n-/// An iterator that reads a line on each iteration,\n-/// until `.read_line()` encounters `EndOfFile`.\n-///\n-/// # Notes about the Iteration Protocol\n-///\n-/// The `Lines` may yield `None` and thus terminate\n-/// an iteration, but continue to yield elements if iteration\n-/// is attempted again.\n-///\n-/// # Error\n-///\n-/// Any error other than `EndOfFile` that is produced by the underlying Reader\n-/// is returned by the iterator and should be handled by the caller.\n-pub struct Lines<'r, T:'r> {\n-    buffer: &'r mut T,\n-}\n-\n-impl<'r, T: Buffer> Iterator for Lines<'r, T> {\n-    type Item = IoResult<String>;\n-\n-    fn next(&mut self) -> Option<IoResult<String>> {\n-        match self.buffer.read_line() {\n-            Ok(x) => Some(Ok(x)),\n-            Err(IoError { kind: EndOfFile, ..}) => None,\n-            Err(y) => Some(Err(y))\n-        }\n-    }\n-}\n-\n-/// An iterator that reads a utf8-encoded character on each iteration,\n-/// until `.read_char()` encounters `EndOfFile`.\n-///\n-/// # Notes about the Iteration Protocol\n-///\n-/// The `Chars` may yield `None` and thus terminate\n-/// an iteration, but continue to yield elements if iteration\n-/// is attempted again.\n-///\n-/// # Error\n-///\n-/// Any error other than `EndOfFile` that is produced by the underlying Reader\n-/// is returned by the iterator and should be handled by the caller.\n-pub struct Chars<'r, T:'r> {\n-    buffer: &'r mut T\n-}\n-\n-impl<'r, T: Buffer> Iterator for Chars<'r, T> {\n-    type Item = IoResult<char>;\n-\n-    fn next(&mut self) -> Option<IoResult<char>> {\n-        match self.buffer.read_char() {\n-            Ok(x) => Some(Ok(x)),\n-            Err(IoError { kind: EndOfFile, ..}) => None,\n-            Err(y) => Some(Err(y))\n-        }\n-    }\n-}\n-\n-/// A Buffer is a type of reader which has some form of internal buffering to\n-/// allow certain kinds of reading operations to be more optimized than others.\n-/// This type extends the `Reader` trait with a few methods that are not\n-/// possible to reasonably implement with purely a read interface.\n-pub trait Buffer: Reader {\n-    /// Fills the internal buffer of this object, returning the buffer contents.\n-    /// Note that none of the contents will be \"read\" in the sense that later\n-    /// calling `read` may return the same contents.\n-    ///\n-    /// The `consume` function must be called with the number of bytes that are\n-    /// consumed from this buffer returned to ensure that the bytes are never\n-    /// returned twice.\n-    ///\n-    /// # Error\n-    ///\n-    /// This function will return an I/O error if the underlying reader was\n-    /// read, but returned an error. Note that it is not an error to return a\n-    /// 0-length buffer.\n-    fn fill_buf<'a>(&'a mut self) -> IoResult<&'a [u8]>;\n-\n-    /// Tells this buffer that `amt` bytes have been consumed from the buffer,\n-    /// so they should no longer be returned in calls to `read`.\n-    fn consume(&mut self, amt: usize);\n-\n-    /// Reads the next line of input, interpreted as a sequence of UTF-8\n-    /// encoded Unicode codepoints. If a newline is encountered, then the\n-    /// newline is contained in the returned string.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// # #![feature(old_io)]\n-    /// use std::old_io::*;\n-    ///\n-    /// let mut reader = BufReader::new(b\"hello\\nworld\");\n-    /// assert_eq!(\"hello\\n\", &*reader.read_line().unwrap());\n-    /// ```\n-    ///\n-    /// # Error\n-    ///\n-    /// This function has the same error semantics as `read_until`:\n-    ///\n-    /// * All non-EOF errors will be returned immediately\n-    /// * If an error is returned previously consumed bytes are lost\n-    /// * EOF is only returned if no bytes have been read\n-    /// * Reach EOF may mean that the delimiter is not present in the return\n-    ///   value\n-    ///\n-    /// Additionally, this function can fail if the line of input read is not a\n-    /// valid UTF-8 sequence of bytes.\n-    fn read_line(&mut self) -> IoResult<String> {\n-        self.read_until(b'\\n').and_then(|line|\n-            match String::from_utf8(line) {\n-                Ok(s)  => Ok(s),\n-                Err(_) => Err(standard_error(InvalidInput)),\n-            }\n-        )\n-    }\n-\n-    /// Reads a sequence of bytes leading up to a specified delimiter. Once the\n-    /// specified byte is encountered, reading ceases and the bytes up to and\n-    /// including the delimiter are returned.\n-    ///\n-    /// # Error\n-    ///\n-    /// If any I/O error is encountered other than EOF, the error is immediately\n-    /// returned. Note that this may discard bytes which have already been read,\n-    /// and those bytes will *not* be returned. It is recommended to use other\n-    /// methods if this case is worrying.\n-    ///\n-    /// If EOF is encountered, then this function will return EOF if 0 bytes\n-    /// have been read, otherwise the pending byte buffer is returned. This\n-    /// is the reason that the byte buffer returned may not always contain the\n-    /// delimiter.\n-    fn read_until(&mut self, byte: u8) -> IoResult<Vec<u8>> {\n-        let mut res = Vec::new();\n-\n-        loop {\n-            let (done, used) = {\n-                let available = match self.fill_buf() {\n-                    Ok(n) => n,\n-                    Err(ref e) if res.len() > 0 && e.kind == EndOfFile => {\n-                        return Ok(res);\n-                    }\n-                    Err(e) => return Err(e)\n-                };\n-                match available.iter().position(|&b| b == byte) {\n-                    Some(i) => {\n-                        res.push_all(&available[..i + 1]);\n-                        (true, i + 1)\n-                    }\n-                    None => {\n-                        res.push_all(available);\n-                        (false, available.len())\n-                    }\n-                }\n-            };\n-            self.consume(used);\n-            if done {\n-                return Ok(res);\n-            }\n-        }\n-    }\n-\n-    /// Reads the next utf8-encoded character from the underlying stream.\n-    ///\n-    /// # Error\n-    ///\n-    /// If an I/O error occurs, or EOF, then this function will return `Err`.\n-    /// This function will also return error if the stream does not contain a\n-    /// valid utf-8 encoded codepoint as the next few bytes in the stream.\n-    fn read_char(&mut self) -> IoResult<char> {\n-        let first_byte = try!(self.read_byte());\n-        let width = unicode::str::utf8_char_width(first_byte);\n-        if width == 1 { return Ok(first_byte as char) }\n-        if width == 0 { return Err(standard_error(InvalidInput)) } // not utf8\n-        let mut buf = [first_byte, 0, 0, 0];\n-        {\n-            let mut start = 1;\n-            while start < width {\n-                match try!(self.read(&mut buf[start .. width])) {\n-                    n if n == width - start => break,\n-                    n if n < width - start => { start += n; }\n-                    _ => return Err(standard_error(InvalidInput)),\n-                }\n-            }\n-        }\n-        match str::from_utf8(&buf[..width]).ok() {\n-            Some(s) => Ok(s.char_at(0)),\n-            None => Err(standard_error(InvalidInput))\n-        }\n-    }\n-}\n-\n-/// Extension methods for the Buffer trait which are included in the prelude.\n-pub trait BufferPrelude {\n-    /// Create an iterator that reads a utf8-encoded character on each iteration\n-    /// until EOF.\n-    ///\n-    /// # Error\n-    ///\n-    /// Any error other than `EndOfFile` that is produced by the underlying Reader\n-    /// is returned by the iterator and should be handled by the caller.\n-    fn chars<'r>(&'r mut self) -> Chars<'r, Self>;\n-\n-    /// Create an iterator that reads a line on each iteration until EOF.\n-    ///\n-    /// # Error\n-    ///\n-    /// Any error other than `EndOfFile` that is produced by the underlying Reader\n-    /// is returned by the iterator and should be handled by the caller.\n-    fn lines<'r>(&'r mut self) -> Lines<'r, Self>;\n-}\n-\n-impl<T: Buffer> BufferPrelude for T {\n-    fn chars<'r>(&'r mut self) -> Chars<'r, T> {\n-        Chars { buffer: self }\n-    }\n-\n-    fn lines<'r>(&'r mut self) -> Lines<'r, T> {\n-        Lines { buffer: self }\n-    }\n-}\n-\n-/// When seeking, the resulting cursor is offset from a base by the offset given\n-/// to the `seek` function. The base used is specified by this enumeration.\n-#[derive(Copy, Clone)]\n-pub enum SeekStyle {\n-    /// Seek from the beginning of the stream\n-    SeekSet,\n-    /// Seek from the end of the stream\n-    SeekEnd,\n-    /// Seek from the current position\n-    SeekCur,\n-}\n-\n-/// An object implementing `Seek` internally has some form of cursor which can\n-/// be moved within a stream of bytes. The stream typically has a fixed size,\n-/// allowing seeking relative to either end.\n-pub trait Seek {\n-    /// Return position of file cursor in the stream\n-    fn tell(&self) -> IoResult<u64>;\n-\n-    /// Seek to an offset in a stream\n-    ///\n-    /// A successful seek clears the EOF indicator. Seeking beyond EOF is\n-    /// allowed, but seeking before position 0 is not allowed.\n-    ///\n-    /// # Errors\n-    ///\n-    /// * Seeking to a negative offset is considered an error\n-    /// * Seeking past the end of the stream does not modify the underlying\n-    ///   stream, but the next write may cause the previous data to be filled in\n-    ///   with a bit pattern.\n-    fn seek(&mut self, pos: i64, style: SeekStyle) -> IoResult<()>;\n-}\n-\n-/// A listener is a value that can consume itself to start listening for\n-/// connections.\n-///\n-/// Doing so produces some sort of Acceptor.\n-pub trait Listener<A: Acceptor> {\n-    /// Spin up the listener and start queuing incoming connections\n-    ///\n-    /// # Error\n-    ///\n-    /// Returns `Err` if this listener could not be bound to listen for\n-    /// connections. In all cases, this listener is consumed.\n-    fn listen(self) -> IoResult<A>;\n-}\n-\n-/// An acceptor is a value that presents incoming connections\n-pub trait Acceptor {\n-    /// Type of connection that is accepted by this acceptor.\n-    type Connection;\n-\n-    /// Wait for and accept an incoming connection\n-    ///\n-    /// # Error\n-    ///\n-    /// Returns `Err` if an I/O error is encountered.\n-    fn accept(&mut self) -> IoResult<Self::Connection>;\n-\n-    /// Create an iterator over incoming connection attempts.\n-    ///\n-    /// Note that I/O errors will be yielded by the iterator itself.\n-    fn incoming<'r>(&'r mut self) -> IncomingConnections<'r, Self> {\n-        IncomingConnections { inc: self }\n-    }\n-}\n-\n-/// An infinite iterator over incoming connection attempts.\n-/// Calling `next` will block the task until a connection is attempted.\n-///\n-/// Since connection attempts can continue forever, this iterator always returns\n-/// `Some`. The `Some` contains the `IoResult` representing whether the\n-/// connection attempt was successful.  A successful connection will be wrapped\n-/// in `Ok`. A failed connection is represented as an `Err`.\n-pub struct IncomingConnections<'a, A: ?Sized +'a> {\n-    inc: &'a mut A,\n-}\n-\n-impl<'a, A: ?Sized + Acceptor> Iterator for IncomingConnections<'a, A> {\n-    type Item = IoResult<A::Connection>;\n-\n-    fn next(&mut self) -> Option<IoResult<A::Connection>> {\n-        Some(self.inc.accept())\n-    }\n-}\n-\n-/// Creates a standard error for a commonly used flavor of error. The `detail`\n-/// field of the returned error will always be `None`.\n-///\n-/// # Examples\n-///\n-/// ```\n-/// # #![feature(old_io)]\n-/// use std::old_io as io;\n-///\n-/// let eof = io::standard_error(io::EndOfFile);\n-/// let einval = io::standard_error(io::InvalidInput);\n-/// ```\n-pub fn standard_error(kind: IoErrorKind) -> IoError {\n-    let desc = match kind {\n-        EndOfFile => \"end of file\",\n-        IoUnavailable => \"I/O is unavailable\",\n-        InvalidInput => \"invalid input\",\n-        OtherIoError => \"unknown I/O error\",\n-        FileNotFound => \"file not found\",\n-        PermissionDenied => \"permission denied\",\n-        ConnectionFailed => \"connection failed\",\n-        Closed => \"stream is closed\",\n-        ConnectionRefused => \"connection refused\",\n-        ConnectionReset => \"connection reset\",\n-        ConnectionAborted => \"connection aborted\",\n-        NotConnected => \"not connected\",\n-        BrokenPipe => \"broken pipe\",\n-        PathAlreadyExists => \"file already exists\",\n-        PathDoesntExist => \"no such file\",\n-        MismatchedFileTypeForOperation => \"mismatched file type\",\n-        ResourceUnavailable => \"resource unavailable\",\n-        TimedOut => \"operation timed out\",\n-        ShortWrite(..) => \"short write\",\n-        NoProgress => \"no progress\",\n-    };\n-    IoError {\n-        kind: kind,\n-        desc: desc,\n-        detail: None,\n-    }\n-}\n-\n-/// A mode specifies how a file should be opened or created. These modes are\n-/// passed to `File::open_mode` and are used to control where the file is\n-/// positioned when it is initially opened.\n-#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n-pub enum FileMode {\n-    /// Opens a file positioned at the beginning.\n-    Open,\n-    /// Opens a file positioned at EOF.\n-    Append,\n-    /// Opens a file, truncating it if it already exists.\n-    Truncate,\n-}\n-\n-/// Access permissions with which the file should be opened. `File`s\n-/// opened with `Read` will return an error if written to.\n-#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n-pub enum FileAccess {\n-    /// Read-only access, requests to write will result in an error\n-    Read,\n-    /// Write-only access, requests to read will result in an error\n-    Write,\n-    /// Read-write access, no requests are denied by default\n-    ReadWrite,\n-}\n-\n-/// Different kinds of files which can be identified by a call to stat\n-#[derive(Copy, PartialEq, Debug, Hash, Clone)]\n-pub enum FileType {\n-    /// This is a normal file, corresponding to `S_IFREG`\n-    RegularFile,\n-\n-    /// This file is a directory, corresponding to `S_IFDIR`\n-    Directory,\n-\n-    /// This file is a named pipe, corresponding to `S_IFIFO`\n-    NamedPipe,\n-\n-    /// This file is a block device, corresponding to `S_IFBLK`\n-    BlockSpecial,\n-\n-    /// This file is a symbolic link to another file, corresponding to `S_IFLNK`\n-    Symlink,\n-\n-    /// The type of this file is not recognized as one of the other categories\n-    Unknown,\n-}\n-\n-/// A structure used to describe metadata information about a file. This\n-/// structure is created through the `stat` method on a `Path`.\n-///\n-/// # Examples\n-///\n-/// ```no_run\n-/// # #![feature(old_io, old_path)]\n-///\n-/// use std::old_io::fs::PathExtensions;\n-/// use std::old_path::Path;\n-///\n-/// let info = match Path::new(\"foo.txt\").stat() {\n-///     Ok(stat) => stat,\n-///     Err(e) => panic!(\"couldn't read foo.txt: {}\", e),\n-/// };\n-///\n-/// println!(\"byte size: {}\", info.size);\n-/// ```\n-#[derive(Copy, Clone, Hash)]\n-pub struct FileStat {\n-    /// The size of the file, in bytes\n-    pub size: u64,\n-    /// The kind of file this path points to (directory, file, pipe, etc.)\n-    pub kind: FileType,\n-    /// The file permissions currently on the file\n-    pub perm: FilePermission,\n-\n-    // FIXME(#10301): These time fields are pretty useless without an actual\n-    //                time representation, what are the milliseconds relative\n-    //                to?\n-\n-    /// The time that the file was created at, in platform-dependent\n-    /// milliseconds\n-    pub created: u64,\n-    /// The time that this file was last modified, in platform-dependent\n-    /// milliseconds\n-    pub modified: u64,\n-    /// The time that this file was last accessed, in platform-dependent\n-    /// milliseconds\n-    pub accessed: u64,\n-\n-    /// Information returned by stat() which is not guaranteed to be\n-    /// platform-independent. This information may be useful on some platforms,\n-    /// but it may have different meanings or no meaning at all on other\n-    /// platforms.\n-    ///\n-    /// Usage of this field is discouraged, but if access is desired then the\n-    /// fields are located here.\n-    #[unstable(feature = \"io\")]\n-    pub unstable: UnstableFileStat,\n-}\n-\n-/// This structure represents all of the possible information which can be\n-/// returned from a `stat` syscall which is not contained in the `FileStat`\n-/// structure. This information is not necessarily platform independent, and may\n-/// have different meanings or no meaning at all on some platforms.\n-#[unstable(feature = \"io\")]\n-#[derive(Copy, Clone, Hash)]\n-pub struct UnstableFileStat {\n-    /// The ID of the device containing the file.\n-    pub device: u64,\n-    /// The file serial number.\n-    pub inode: u64,\n-    /// The device ID.\n-    pub rdev: u64,\n-    /// The number of hard links to this file.\n-    pub nlink: u64,\n-    /// The user ID of the file.\n-    pub uid: u64,\n-    /// The group ID of the file.\n-    pub gid: u64,\n-    /// The optimal block size for I/O.\n-    pub blksize: u64,\n-    /// The blocks allocated for this file.\n-    pub blocks: u64,\n-    /// User-defined flags for the file.\n-    pub flags: u64,\n-    /// The file generation number.\n-    pub gen: u64,\n-}\n-\n-\n-bitflags! {\n-    /// A set of permissions for a file or directory is represented by a set of\n-    /// flags which are or'd together.\n-    #[derive(Debug)]\n-    flags FilePermission: u32 {\n-        const USER_READ     = 0o400,\n-        const USER_WRITE    = 0o200,\n-        const USER_EXECUTE  = 0o100,\n-        const GROUP_READ    = 0o040,\n-        const GROUP_WRITE   = 0o020,\n-        const GROUP_EXECUTE = 0o010,\n-        const OTHER_READ    = 0o004,\n-        const OTHER_WRITE   = 0o002,\n-        const OTHER_EXECUTE = 0o001,\n-\n-        const USER_RWX  = USER_READ.bits | USER_WRITE.bits | USER_EXECUTE.bits,\n-        const GROUP_RWX = GROUP_READ.bits | GROUP_WRITE.bits | GROUP_EXECUTE.bits,\n-        const OTHER_RWX = OTHER_READ.bits | OTHER_WRITE.bits | OTHER_EXECUTE.bits,\n-\n-        /// Permissions for user owned files, equivalent to 0644 on unix-like\n-        /// systems.\n-        const USER_FILE = USER_READ.bits | USER_WRITE.bits | GROUP_READ.bits | OTHER_READ.bits,\n-\n-        /// Permissions for user owned directories, equivalent to 0755 on\n-        /// unix-like systems.\n-        const USER_DIR  = USER_RWX.bits | GROUP_READ.bits | GROUP_EXECUTE.bits |\n-                   OTHER_READ.bits | OTHER_EXECUTE.bits,\n-\n-        /// Permissions for user owned executables, equivalent to 0755\n-        /// on unix-like systems.\n-        const USER_EXEC = USER_DIR.bits,\n-\n-        /// All possible permissions enabled.\n-        const ALL_PERMISSIONS = USER_RWX.bits | GROUP_RWX.bits | OTHER_RWX.bits,\n-    }\n-}\n-\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl Default for FilePermission {\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[inline]\n-    fn default() -> FilePermission { FilePermission::empty() }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl fmt::Display for FilePermission {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"{:04o}\", self.bits)\n-    }\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    use self::BadReaderBehavior::*;\n-    use super::{IoResult, Reader, MemReader, NoProgress, InvalidInput, Writer};\n-    use super::Buffer;\n-    use prelude::v1::{Ok, Vec};\n-    use usize;\n-\n-    #[derive(Clone, PartialEq, Debug)]\n-    enum BadReaderBehavior {\n-        GoodBehavior(usize),\n-        BadBehavior(usize)\n-    }\n-\n-    struct BadReader<T> {\n-        r: T,\n-        behavior: Vec<BadReaderBehavior>,\n-    }\n-\n-    impl<T: Reader> BadReader<T> {\n-        fn new(r: T, behavior: Vec<BadReaderBehavior>) -> BadReader<T> {\n-            BadReader { behavior: behavior, r: r }\n-        }\n-    }\n-\n-    impl<T: Reader> Reader for BadReader<T> {\n-        fn read(&mut self, buf: &mut [u8]) -> IoResult<usize> {\n-            let BadReader { ref mut behavior, ref mut r } = *self;\n-            loop {\n-                if behavior.is_empty() {\n-                    // fall back on good\n-                    return r.read(buf);\n-                }\n-                match (&mut **behavior)[0] {\n-                    GoodBehavior(0) => (),\n-                    GoodBehavior(ref mut x) => {\n-                        *x -= 1;\n-                        return r.read(buf);\n-                    }\n-                    BadBehavior(0) => (),\n-                    BadBehavior(ref mut x) => {\n-                        *x -= 1;\n-                        return Ok(0);\n-                    }\n-                };\n-                behavior.remove(0);\n-            }\n-        }\n-    }\n-\n-    #[test]\n-    fn test_read_at_least() {\n-        let mut r = BadReader::new(MemReader::new(b\"hello, world!\".to_vec()),\n-                                   vec![GoodBehavior(usize::MAX)]);\n-        let buf = &mut [0; 5];\n-        assert!(r.read_at_least(1, buf).unwrap() >= 1);\n-        assert!(r.read_exact(5).unwrap().len() == 5); // read_exact uses read_at_least\n-        assert!(r.read_at_least(0, buf).is_ok());\n-\n-        let mut r = BadReader::new(MemReader::new(b\"hello, world!\".to_vec()),\n-                                   vec![BadBehavior(50), GoodBehavior(usize::MAX)]);\n-        assert!(r.read_at_least(1, buf).unwrap() >= 1);\n-\n-        let mut r = BadReader::new(MemReader::new(b\"hello, world!\".to_vec()),\n-                                   vec![BadBehavior(1), GoodBehavior(1),\n-                                        BadBehavior(50), GoodBehavior(usize::MAX)]);\n-        assert!(r.read_at_least(1, buf).unwrap() >= 1);\n-        assert!(r.read_at_least(1, buf).unwrap() >= 1);\n-\n-        let mut r = BadReader::new(MemReader::new(b\"hello, world!\".to_vec()),\n-                                   vec![BadBehavior(usize::MAX)]);\n-        assert_eq!(r.read_at_least(1, buf).unwrap_err().kind, NoProgress);\n-\n-        let mut r = MemReader::new(b\"hello, world!\".to_vec());\n-        assert_eq!(r.read_at_least(5, buf).unwrap(), 5);\n-        assert_eq!(r.read_at_least(6, buf).unwrap_err().kind, InvalidInput);\n-    }\n-\n-    #[test]\n-    fn test_push_at_least() {\n-        let mut r = BadReader::new(MemReader::new(b\"hello, world!\".to_vec()),\n-                                   vec![GoodBehavior(usize::MAX)]);\n-        let mut buf = Vec::new();\n-        assert!(r.push_at_least(1, 5, &mut buf).unwrap() >= 1);\n-        assert!(r.push_at_least(0, 5, &mut buf).is_ok());\n-\n-        let mut r = BadReader::new(MemReader::new(b\"hello, world!\".to_vec()),\n-                                   vec![BadBehavior(50), GoodBehavior(usize::MAX)]);\n-        assert!(r.push_at_least(1, 5, &mut buf).unwrap() >= 1);\n-\n-        let mut r = BadReader::new(MemReader::new(b\"hello, world!\".to_vec()),\n-                                   vec![BadBehavior(1), GoodBehavior(1),\n-                                        BadBehavior(50), GoodBehavior(usize::MAX)]);\n-        assert!(r.push_at_least(1, 5, &mut buf).unwrap() >= 1);\n-        assert!(r.push_at_least(1, 5, &mut buf).unwrap() >= 1);\n-\n-        let mut r = BadReader::new(MemReader::new(b\"hello, world!\".to_vec()),\n-                                   vec![BadBehavior(usize::MAX)]);\n-        assert_eq!(r.push_at_least(1, 5, &mut buf).unwrap_err().kind, NoProgress);\n-\n-        let mut r = MemReader::new(b\"hello, world!\".to_vec());\n-        assert_eq!(r.push_at_least(5, 1, &mut buf).unwrap_err().kind, InvalidInput);\n-    }\n-\n-    #[test]\n-    fn test_show() {\n-        use super::*;\n-\n-        assert_eq!(format!(\"{}\", USER_READ), \"0400\");\n-        assert_eq!(format!(\"{}\", USER_FILE), \"0644\");\n-        assert_eq!(format!(\"{}\", USER_EXEC), \"0755\");\n-        assert_eq!(format!(\"{}\", USER_RWX),  \"0700\");\n-        assert_eq!(format!(\"{}\", GROUP_RWX), \"0070\");\n-        assert_eq!(format!(\"{}\", OTHER_RWX), \"0007\");\n-        assert_eq!(format!(\"{}\", ALL_PERMISSIONS), \"0777\");\n-        assert_eq!(format!(\"{}\", USER_READ | USER_WRITE | OTHER_WRITE), \"0602\");\n-    }\n-\n-    fn _ensure_buffer_is_object_safe<T: Buffer>(x: &T) -> &Buffer {\n-        x as &Buffer\n-    }\n-}"}, {"sha": "dd30363e316afee68a12ed105ac1293daeec084f", "filename": "src/libstd/old_io/net/addrinfo.rs", "status": "removed", "additions": 0, "deletions": 136, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/8415fa27877a4309a79b08c75a52eb4c3546b7a5/src%2Flibstd%2Fold_io%2Fnet%2Faddrinfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8415fa27877a4309a79b08c75a52eb4c3546b7a5/src%2Flibstd%2Fold_io%2Fnet%2Faddrinfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fnet%2Faddrinfo.rs?ref=8415fa27877a4309a79b08c75a52eb4c3546b7a5", "patch": "@@ -1,136 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Synchronous DNS Resolution\n-//!\n-//! Contains the functionality to perform DNS resolution or reverse lookup,\n-//! in a style related to `getaddrinfo()` and `getnameinfo()`, respectively.\n-\n-#![allow(missing_docs)]\n-\n-pub use self::SocketType::*;\n-pub use self::Flag::*;\n-pub use self::Protocol::*;\n-\n-use iter::Iterator;\n-use old_io::IoResult;\n-use old_io::net::ip::{SocketAddr, IpAddr};\n-use option::Option;\n-use option::Option::{Some, None};\n-use string::String;\n-use sys;\n-use vec::Vec;\n-\n-/// Hints to the types of sockets that are desired when looking up hosts\n-#[derive(Copy, Clone, Debug)]\n-pub enum SocketType {\n-    Stream, Datagram, Raw\n-}\n-\n-/// Flags which can be or'd into the `flags` field of a `Hint`. These are used\n-/// to manipulate how a query is performed.\n-///\n-/// The meaning of each of these flags can be found with `man -s 3 getaddrinfo`\n-#[derive(Copy, Clone, Debug)]\n-pub enum Flag {\n-    AddrConfig,\n-    All,\n-    CanonName,\n-    NumericHost,\n-    NumericServ,\n-    Passive,\n-    V4Mapped,\n-}\n-\n-/// A transport protocol associated with either a hint or a return value of\n-/// `lookup`\n-#[derive(Copy, Clone, Debug)]\n-pub enum Protocol {\n-    TCP, UDP\n-}\n-\n-/// This structure is used to provide hints when fetching addresses for a\n-/// remote host to control how the lookup is performed.\n-///\n-/// For details on these fields, see their corresponding definitions via\n-/// `man -s 3 getaddrinfo`\n-#[derive(Copy, Clone, Debug)]\n-pub struct Hint {\n-    pub family: usize,\n-    pub socktype: Option<SocketType>,\n-    pub protocol: Option<Protocol>,\n-    pub flags: usize,\n-}\n-\n-#[derive(Copy, Clone, Debug)]\n-pub struct Info {\n-    pub address: SocketAddr,\n-    pub family: usize,\n-    pub socktype: Option<SocketType>,\n-    pub protocol: Option<Protocol>,\n-    pub flags: usize,\n-}\n-\n-/// Easy name resolution. Given a hostname, returns the list of IP addresses for\n-/// that hostname.\n-pub fn get_host_addresses(host: &str) -> IoResult<Vec<IpAddr>> {\n-    lookup(Some(host), None, None).map(|a| a.into_iter().map(|i| i.address.ip).collect())\n-}\n-\n-/// Reverse name resolution. Given an address, returns the corresponding\n-/// hostname.\n-pub fn get_address_name(addr: IpAddr) -> IoResult<String> {\n-    sys::addrinfo::get_address_name(addr)\n-}\n-\n-/// Full-fledged resolution. This function will perform a synchronous call to\n-/// getaddrinfo, controlled by the parameters\n-///\n-/// # Arguments\n-///\n-/// * hostname - an optional hostname to lookup against\n-/// * servname - an optional service name, listed in the system services\n-/// * hint - see the hint structure, and \"man -s 3 getaddrinfo\", for how this\n-///          controls lookup\n-///\n-/// FIXME: this is not public because the `Hint` structure is not ready for public\n-///      consumption just yet.\n-#[allow(unused_variables)]\n-fn lookup(hostname: Option<&str>, servname: Option<&str>, hint: Option<Hint>)\n-          -> IoResult<Vec<Info>> {\n-    sys::addrinfo::get_host_addresses(hostname, servname, hint)\n-}\n-\n-// Ignored on android since we cannot give tcp/ip\n-// permission without help of apk\n-#[cfg(all(test, not(target_os = \"android\")))]\n-mod test {\n-    use prelude::v1::*;\n-    use super::*;\n-    use old_io::net::ip::*;\n-\n-    #[test]\n-    fn dns_smoke_test() {\n-        let ipaddrs = get_host_addresses(\"localhost\").unwrap();\n-        let mut found_local = false;\n-        let local_addr = &Ipv4Addr(127, 0, 0, 1);\n-        for addr in &ipaddrs {\n-            found_local = found_local || addr == local_addr;\n-        }\n-        assert!(found_local);\n-    }\n-\n-    #[test]\n-    fn issue_10663() {\n-        // Something should happen here, but this certainly shouldn't cause\n-        // everything to die. The actual outcome we don't care too much about.\n-        let _ = get_host_addresses(\"example.com\");\n-    }\n-}"}, {"sha": "f5310292b911b8c4f15a204263c849a3179e3341", "filename": "src/libstd/old_io/net/ip.rs", "status": "removed", "additions": 0, "deletions": 710, "changes": 710, "blob_url": "https://github.com/rust-lang/rust/blob/8415fa27877a4309a79b08c75a52eb4c3546b7a5/src%2Flibstd%2Fold_io%2Fnet%2Fip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8415fa27877a4309a79b08c75a52eb4c3546b7a5/src%2Flibstd%2Fold_io%2Fnet%2Fip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fnet%2Fip.rs?ref=8415fa27877a4309a79b08c75a52eb4c3546b7a5", "patch": "@@ -1,710 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Internet Protocol (IP) addresses.\n-//!\n-//! This module contains functions useful for parsing, formatting, and\n-//! manipulating IP addresses.\n-\n-#![allow(missing_docs)]\n-\n-pub use self::IpAddr::*;\n-\n-use boxed::Box;\n-use fmt;\n-use old_io::{self, IoResult, IoError};\n-use old_io::net;\n-use iter::Iterator;\n-use ops::{FnOnce, FnMut};\n-use option::Option;\n-use option::Option::{None, Some};\n-use result::Result::{self, Ok, Err};\n-use str::FromStr;\n-use vec::Vec;\n-\n-pub type Port = u16;\n-\n-#[derive(Copy, PartialEq, Eq, Clone, Hash, Debug)]\n-pub enum IpAddr {\n-    Ipv4Addr(u8, u8, u8, u8),\n-    Ipv6Addr(u16, u16, u16, u16, u16, u16, u16, u16)\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl fmt::Display for IpAddr {\n-    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n-        match *self {\n-            Ipv4Addr(a, b, c, d) =>\n-                write!(fmt, \"{}.{}.{}.{}\", a, b, c, d),\n-\n-            // Ipv4 Compatible address\n-            Ipv6Addr(0, 0, 0, 0, 0, 0, g, h) => {\n-                write!(fmt, \"::{}.{}.{}.{}\", (g >> 8) as u8, g as u8,\n-                       (h >> 8) as u8, h as u8)\n-            }\n-\n-            // Ipv4-Mapped address\n-            Ipv6Addr(0, 0, 0, 0, 0, 0xFFFF, g, h) => {\n-                write!(fmt, \"::FFFF:{}.{}.{}.{}\", (g >> 8) as u8, g as u8,\n-                       (h >> 8) as u8, h as u8)\n-            }\n-\n-            Ipv6Addr(a, b, c, d, e, f, g, h) =>\n-                write!(fmt, \"{:x}:{:x}:{:x}:{:x}:{:x}:{:x}:{:x}:{:x}\",\n-                       a, b, c, d, e, f, g, h)\n-        }\n-    }\n-}\n-\n-#[derive(Copy, PartialEq, Eq, Clone, Hash, Debug)]\n-pub struct SocketAddr {\n-    pub ip: IpAddr,\n-    pub port: Port,\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl fmt::Display for SocketAddr {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        match self.ip {\n-            Ipv4Addr(..) => write!(f, \"{}:{}\", self.ip, self.port),\n-            Ipv6Addr(..) => write!(f, \"[{}]:{}\", self.ip, self.port),\n-        }\n-    }\n-}\n-\n-struct Parser<'a> {\n-    // parsing as ASCII, so can use byte array\n-    s: &'a [u8],\n-    pos: usize,\n-}\n-\n-impl<'a> Parser<'a> {\n-    fn new(s: &'a str) -> Parser<'a> {\n-        Parser {\n-            s: s.as_bytes(),\n-            pos: 0,\n-        }\n-    }\n-\n-    fn is_eof(&self) -> bool {\n-        self.pos == self.s.len()\n-    }\n-\n-    // Commit only if parser returns Some\n-    fn read_atomically<T, F>(&mut self, cb: F) -> Option<T> where\n-        F: FnOnce(&mut Parser) -> Option<T>,\n-    {\n-        let pos = self.pos;\n-        let r = cb(self);\n-        if r.is_none() {\n-            self.pos = pos;\n-        }\n-        r\n-    }\n-\n-    // Commit only if parser read till EOF\n-    fn read_till_eof<T, F>(&mut self, cb: F) -> Option<T> where\n-        F: FnOnce(&mut Parser) -> Option<T>,\n-    {\n-        self.read_atomically(move |p| {\n-            match cb(p) {\n-                Some(x) => if p.is_eof() {Some(x)} else {None},\n-                None => None,\n-            }\n-        })\n-    }\n-\n-    // Return result of first successful parser\n-    fn read_or<T>(&mut self, parsers: &mut [Box<FnMut(&mut Parser) -> Option<T>>])\n-               -> Option<T> {\n-        for pf in parsers {\n-            match self.read_atomically(|p: &mut Parser| pf.call_mut((p,))) {\n-                Some(r) => return Some(r),\n-                None => {}\n-            }\n-        }\n-        None\n-    }\n-\n-    // Apply 3 parsers sequentially\n-    fn read_seq_3<A, B, C, PA, PB, PC>(&mut self,\n-                                       pa: PA,\n-                                       pb: PB,\n-                                       pc: PC)\n-                                       -> Option<(A, B, C)> where\n-        PA: FnOnce(&mut Parser) -> Option<A>,\n-        PB: FnOnce(&mut Parser) -> Option<B>,\n-        PC: FnOnce(&mut Parser) -> Option<C>,\n-    {\n-        self.read_atomically(move |p| {\n-            let a = pa(p);\n-            let b = if a.is_some() { pb(p) } else { None };\n-            let c = if b.is_some() { pc(p) } else { None };\n-            match (a, b, c) {\n-                (Some(a), Some(b), Some(c)) => Some((a, b, c)),\n-                _ => None\n-            }\n-        })\n-    }\n-\n-    // Read next char\n-    fn read_char(&mut self) -> Option<char> {\n-        if self.is_eof() {\n-            None\n-        } else {\n-            let r = self.s[self.pos] as char;\n-            self.pos += 1;\n-            Some(r)\n-        }\n-    }\n-\n-    // Return char and advance iff next char is equal to requested\n-    fn read_given_char(&mut self, c: char) -> Option<char> {\n-        self.read_atomically(|p| {\n-            match p.read_char() {\n-                Some(next) if next == c => Some(next),\n-                _ => None,\n-            }\n-        })\n-    }\n-\n-    // Read digit\n-    fn read_digit(&mut self, radix: u8) -> Option<u8> {\n-        fn parse_digit(c: char, radix: u8) -> Option<u8> {\n-            let c = c as u8;\n-            // assuming radix is either 10 or 16\n-            if c >= b'0' && c <= b'9' {\n-                Some(c - b'0')\n-            } else if radix > 10 && c >= b'a' && c < b'a' + (radix - 10) {\n-                Some(c - b'a' + 10)\n-            } else if radix > 10 && c >= b'A' && c < b'A' + (radix - 10) {\n-                Some(c - b'A' + 10)\n-            } else {\n-                None\n-            }\n-        }\n-\n-        self.read_atomically(|p| {\n-            p.read_char().and_then(|c| parse_digit(c, radix))\n-        })\n-    }\n-\n-    fn read_number_impl(&mut self, radix: u8, max_digits: u32, upto: u32) -> Option<u32> {\n-        let mut r = 0;\n-        let mut digit_count = 0;\n-        loop {\n-            match self.read_digit(radix) {\n-                Some(d) => {\n-                    r = r * (radix as u32) + (d as u32);\n-                    digit_count += 1;\n-                    if digit_count > max_digits || r >= upto {\n-                        return None\n-                    }\n-                }\n-                None => {\n-                    if digit_count == 0 {\n-                        return None\n-                    } else {\n-                        return Some(r)\n-                    }\n-                }\n-            };\n-        }\n-    }\n-\n-    // Read number, failing if max_digits of number value exceeded\n-    fn read_number(&mut self, radix: u8, max_digits: u32, upto: u32) -> Option<u32> {\n-        self.read_atomically(|p| p.read_number_impl(radix, max_digits, upto))\n-    }\n-\n-    fn read_ipv4_addr_impl(&mut self) -> Option<IpAddr> {\n-        let mut bs = [0; 4];\n-        let mut i = 0;\n-        while i < 4 {\n-            if i != 0 && self.read_given_char('.').is_none() {\n-                return None;\n-            }\n-\n-            let octet = self.read_number(10, 3, 0x100).map(|n| n as u8);\n-            match octet {\n-                Some(d) => bs[i] = d,\n-                None => return None,\n-            };\n-            i += 1;\n-        }\n-        Some(Ipv4Addr(bs[0], bs[1], bs[2], bs[3]))\n-    }\n-\n-    // Read IPv4 address\n-    fn read_ipv4_addr(&mut self) -> Option<IpAddr> {\n-        self.read_atomically(|p| p.read_ipv4_addr_impl())\n-    }\n-\n-    fn read_ipv6_addr_impl(&mut self) -> Option<IpAddr> {\n-        fn ipv6_addr_from_head_tail(head: &[u16], tail: &[u16]) -> IpAddr {\n-            assert!(head.len() + tail.len() <= 8);\n-            let mut gs = [0; 8];\n-            gs.clone_from_slice(head);\n-            gs[(8 - tail.len()) .. 8].clone_from_slice(tail);\n-            Ipv6Addr(gs[0], gs[1], gs[2], gs[3], gs[4], gs[5], gs[6], gs[7])\n-        }\n-\n-        fn read_groups(p: &mut Parser, groups: &mut [u16; 8], limit: usize) -> (usize, bool) {\n-            let mut i = 0;\n-            while i < limit {\n-                if i < limit - 1 {\n-                    let ipv4 = p.read_atomically(|p| {\n-                        if i == 0 || p.read_given_char(':').is_some() {\n-                            p.read_ipv4_addr()\n-                        } else {\n-                            None\n-                        }\n-                    });\n-                    match ipv4 {\n-                        Some(Ipv4Addr(a, b, c, d)) => {\n-                            groups[i + 0] = ((a as u16) << 8) | (b as u16);\n-                            groups[i + 1] = ((c as u16) << 8) | (d as u16);\n-                            return (i + 2, true);\n-                        }\n-                        _ => {}\n-                    }\n-                }\n-\n-                let group = p.read_atomically(|p| {\n-                    if i == 0 || p.read_given_char(':').is_some() {\n-                        p.read_number(16, 4, 0x10000).map(|n| n as u16)\n-                    } else {\n-                        None\n-                    }\n-                });\n-                match group {\n-                    Some(g) => groups[i] = g,\n-                    None => return (i, false)\n-                }\n-                i += 1;\n-            }\n-            (i, false)\n-        }\n-\n-        let mut head = [0; 8];\n-        let (head_size, head_ipv4) = read_groups(self, &mut head, 8);\n-\n-        if head_size == 8 {\n-            return Some(Ipv6Addr(\n-                head[0], head[1], head[2], head[3],\n-                head[4], head[5], head[6], head[7]))\n-        }\n-\n-        // IPv4 part is not allowed before `::`\n-        if head_ipv4 {\n-            return None\n-        }\n-\n-        // read `::` if previous code parsed less than 8 groups\n-        if !self.read_given_char(':').is_some() || !self.read_given_char(':').is_some() {\n-            return None;\n-        }\n-\n-        let mut tail = [0; 8];\n-        let (tail_size, _) = read_groups(self, &mut tail, 8 - head_size);\n-        Some(ipv6_addr_from_head_tail(&head[..head_size], &tail[..tail_size]))\n-    }\n-\n-    fn read_ipv6_addr(&mut self) -> Option<IpAddr> {\n-        self.read_atomically(|p| p.read_ipv6_addr_impl())\n-    }\n-\n-    fn read_ip_addr(&mut self) -> Option<IpAddr> {\n-        let ipv4_addr: Box<_> = box |p: &mut Parser| p.read_ipv4_addr();\n-        let ipv6_addr: Box<_> = box |p: &mut Parser| p.read_ipv6_addr();\n-        self.read_or(&mut [ipv4_addr, ipv6_addr])\n-    }\n-\n-    fn read_socket_addr(&mut self) -> Option<SocketAddr> {\n-        let ip_addr = |p: &mut Parser| {\n-            let ipv4_p: Box<_> = box |p: &mut Parser| p.read_ip_addr();\n-            let ipv6_p: Box<_> = box |p: &mut Parser| {\n-                let open_br = |p: &mut Parser| p.read_given_char('[');\n-                let ip_addr = |p: &mut Parser| p.read_ipv6_addr();\n-                let clos_br = |p: &mut Parser| p.read_given_char(']');\n-                p.read_seq_3::<char, IpAddr, char, _, _, _>(open_br, ip_addr, clos_br)\n-                        .map(|t| match t { (_, ip, _) => ip })\n-            };\n-            p.read_or(&mut [ipv4_p, ipv6_p])\n-        };\n-        let colon = |p: &mut Parser| p.read_given_char(':');\n-        let port  = |p: &mut Parser| p.read_number(10, 5, 0x10000).map(|n| n as u16);\n-\n-        // host, colon, port\n-        self.read_seq_3::<IpAddr, char, u16, _, _, _>(ip_addr, colon, port)\n-                .map(|t| match t { (ip, _, port) => SocketAddr { ip: ip, port: port } })\n-    }\n-}\n-\n-impl FromStr for IpAddr {\n-    type Err = ParseError;\n-    fn from_str(s: &str) -> Result<IpAddr, ParseError> {\n-        match Parser::new(s).read_till_eof(|p| p.read_ip_addr()) {\n-            Some(s) => Ok(s),\n-            None => Err(ParseError),\n-        }\n-    }\n-}\n-\n-impl FromStr for SocketAddr {\n-    type Err = ParseError;\n-    fn from_str(s: &str) -> Result<SocketAddr, ParseError> {\n-        match Parser::new(s).read_till_eof(|p| p.read_socket_addr()) {\n-            Some(s) => Ok(s),\n-            None => Err(ParseError),\n-        }\n-    }\n-}\n-\n-#[derive(Debug, Clone, PartialEq, Copy)]\n-pub struct ParseError;\n-\n-/// A trait for objects which can be converted or resolved to one or more `SocketAddr` values.\n-///\n-/// Implementing types minimally have to implement either `to_socket_addr` or `to_socket_addr_all`\n-/// method, and its trivial counterpart will be available automatically.\n-///\n-/// This trait is used for generic address resolution when constructing network objects.\n-/// By default it is implemented for the following types:\n-///\n-///  * `SocketAddr` - `to_socket_addr` is identity function.\n-///\n-///  * `(IpAddr, u16)` - `to_socket_addr` constructs `SocketAddr` trivially.\n-///\n-///  * `(&str, u16)` - the string should be either a string representation of an IP address\n-///    expected by `FromStr` implementation for `IpAddr` or a host name.\n-///\n-///    For the former, `to_socket_addr_all` returns a vector with a single element corresponding\n-///    to that IP address joined with the given port.\n-///\n-///    For the latter, it tries to resolve the host name and returns a vector of all IP addresses\n-///    for the host name, each joined with the given port.\n-///\n-///  * `&str` - the string should be either a string representation of a `SocketAddr` as\n-///    expected by its `FromStr` implementation or a string like `<host_name>:<port>` pair\n-///    where `<port>` is a `u16` value.\n-///\n-///    For the former, `to_socket_addr_all` returns a vector with a single element corresponding\n-///    to that socket address.\n-///\n-///    For the latter, it tries to resolve the host name and returns a vector of all IP addresses\n-///    for the host name, each joined with the port.\n-///\n-///\n-/// This trait allows constructing network objects like `TcpStream` or `UdpSocket` easily with\n-/// values of various types for the bind/connection address. It is needed because sometimes\n-/// one type is more appropriate than the other: for simple uses a string like `\"localhost:12345\"`\n-/// is much nicer than manual construction of the corresponding `SocketAddr`, but sometimes\n-/// `SocketAddr` value is *the* main source of the address, and converting it to some other type\n-/// (e.g. a string) just for it to be converted back to `SocketAddr` in constructor methods\n-/// is pointless.\n-///\n-/// Some examples:\n-///\n-/// ```rust,no_run\n-/// # #![feature(old_io)]\n-/// # #![allow(unused_must_use)]\n-///\n-/// use std::old_io::{TcpStream, TcpListener};\n-/// use std::old_io::net::udp::UdpSocket;\n-/// use std::old_io::net::ip::{Ipv4Addr, SocketAddr};\n-///\n-/// fn main() {\n-///     // The following lines are equivalent modulo possible \"localhost\" name resolution\n-///     // differences\n-///     let tcp_s = TcpStream::connect(SocketAddr { ip: Ipv4Addr(127, 0, 0, 1), port: 12345 });\n-///     let tcp_s = TcpStream::connect((Ipv4Addr(127, 0, 0, 1), 12345));\n-///     let tcp_s = TcpStream::connect((\"127.0.0.1\", 12345));\n-///     let tcp_s = TcpStream::connect((\"localhost\", 12345));\n-///     let tcp_s = TcpStream::connect(\"127.0.0.1:12345\");\n-///     let tcp_s = TcpStream::connect(\"localhost:12345\");\n-///\n-///     // TcpListener::bind(), UdpSocket::bind() and UdpSocket::send_to() behave similarly\n-///     let tcp_l = TcpListener::bind(\"localhost:12345\");\n-///\n-///     let mut udp_s = UdpSocket::bind((\"127.0.0.1\", 23451)).unwrap();\n-///     udp_s.send_to([7, 7, 7].as_ref(), (Ipv4Addr(127, 0, 0, 1), 23451));\n-/// }\n-/// ```\n-pub trait ToSocketAddr {\n-    /// Converts this object to single socket address value.\n-    ///\n-    /// If more than one value is available, this method returns the first one. If no\n-    /// values are available, this method returns an `IoError`.\n-    ///\n-    /// By default this method delegates to `to_socket_addr_all` method, taking the first\n-    /// item from its result.\n-    fn to_socket_addr(&self) -> IoResult<SocketAddr> {\n-        self.to_socket_addr_all()\n-            .and_then(|v| v.into_iter().next().ok_or_else(|| IoError {\n-                kind: old_io::InvalidInput,\n-                desc: \"no address available\",\n-                detail: None\n-            }))\n-    }\n-\n-    /// Converts this object to all available socket address values.\n-    ///\n-    /// Some values like host name string naturally correspond to multiple IP addresses.\n-    /// This method tries to return all available addresses corresponding to this object.\n-    ///\n-    /// By default this method delegates to `to_socket_addr` method, creating a singleton\n-    /// vector from its result.\n-    #[inline]\n-    fn to_socket_addr_all(&self) -> IoResult<Vec<SocketAddr>> {\n-        self.to_socket_addr().map(|a| vec![a])\n-    }\n-}\n-\n-impl ToSocketAddr for SocketAddr {\n-    #[inline]\n-    fn to_socket_addr(&self) -> IoResult<SocketAddr> { Ok(*self) }\n-}\n-\n-impl ToSocketAddr for (IpAddr, u16) {\n-    #[inline]\n-    fn to_socket_addr(&self) -> IoResult<SocketAddr> {\n-        let (ip, port) = *self;\n-        Ok(SocketAddr { ip: ip, port: port })\n-    }\n-}\n-\n-fn resolve_socket_addr(s: &str, p: u16) -> IoResult<Vec<SocketAddr>> {\n-    net::get_host_addresses(s)\n-        .map(|v| v.into_iter().map(|a| SocketAddr { ip: a, port: p }).collect())\n-}\n-\n-fn parse_and_resolve_socket_addr(s: &str) -> IoResult<Vec<SocketAddr>> {\n-    macro_rules! try_opt {\n-        ($e:expr, $msg:expr) => (\n-            match $e {\n-                Some(r) => r,\n-                None => return Err(IoError {\n-                    kind: old_io::InvalidInput,\n-                    desc: $msg,\n-                    detail: None\n-                })\n-            }\n-        )\n-    }\n-\n-    // split the string by ':' and convert the second part to u16\n-    let mut parts_iter = s.rsplitn(2, ':');\n-    let port_str = try_opt!(parts_iter.next(), \"invalid socket address\");\n-    let host = try_opt!(parts_iter.next(), \"invalid socket address\");\n-    let port: u16 = try_opt!(port_str.parse().ok(), \"invalid port value\");\n-    resolve_socket_addr(host, port)\n-}\n-\n-impl<'a> ToSocketAddr for (&'a str, u16) {\n-    fn to_socket_addr_all(&self) -> IoResult<Vec<SocketAddr>> {\n-        let (host, port) = *self;\n-\n-        // try to parse the host as a regular IpAddr first\n-        match host.parse().ok() {\n-            Some(addr) => return Ok(vec![SocketAddr {\n-                ip: addr,\n-                port: port\n-            }]),\n-            None => {}\n-        }\n-\n-        resolve_socket_addr(host, port)\n-    }\n-}\n-\n-// accepts strings like 'localhost:12345'\n-impl<'a> ToSocketAddr for &'a str {\n-    fn to_socket_addr(&self) -> IoResult<SocketAddr> {\n-        // try to parse as a regular SocketAddr first\n-        match self.parse().ok() {\n-            Some(addr) => return Ok(addr),\n-            None => {}\n-        }\n-\n-        parse_and_resolve_socket_addr(*self)\n-            .and_then(|v| v.into_iter().next()\n-                .ok_or_else(|| IoError {\n-                    kind: old_io::InvalidInput,\n-                    desc: \"no address available\",\n-                    detail: None\n-                })\n-            )\n-    }\n-\n-    fn to_socket_addr_all(&self) -> IoResult<Vec<SocketAddr>> {\n-        // try to parse as a regular SocketAddr first\n-        match self.parse().ok() {\n-            Some(addr) => return Ok(vec![addr]),\n-            None => {}\n-        }\n-\n-        parse_and_resolve_socket_addr(*self)\n-    }\n-}\n-\n-\n-#[cfg(test)]\n-mod test {\n-    use prelude::v1::*;\n-    use super::*;\n-    use str::FromStr;\n-\n-    #[test]\n-    fn test_from_str_ipv4() {\n-        assert_eq!(Ok(Ipv4Addr(127, 0, 0, 1)), \"127.0.0.1\".parse());\n-        assert_eq!(Ok(Ipv4Addr(255, 255, 255, 255)), \"255.255.255.255\".parse());\n-        assert_eq!(Ok(Ipv4Addr(0, 0, 0, 0)), \"0.0.0.0\".parse());\n-\n-        // out of range\n-        let none: Option<IpAddr> = \"256.0.0.1\".parse().ok();\n-        assert_eq!(None, none);\n-        // too short\n-        let none: Option<IpAddr> = \"255.0.0\".parse().ok();\n-        assert_eq!(None, none);\n-        // too long\n-        let none: Option<IpAddr> = \"255.0.0.1.2\".parse().ok();\n-        assert_eq!(None, none);\n-        // no number between dots\n-        let none: Option<IpAddr> = \"255.0..1\".parse().ok();\n-        assert_eq!(None, none);\n-    }\n-\n-    #[test]\n-    fn test_from_str_ipv6() {\n-        assert_eq!(Ok(Ipv6Addr(0, 0, 0, 0, 0, 0, 0, 0)), \"0:0:0:0:0:0:0:0\".parse());\n-        assert_eq!(Ok(Ipv6Addr(0, 0, 0, 0, 0, 0, 0, 1)), \"0:0:0:0:0:0:0:1\".parse());\n-\n-        assert_eq!(Ok(Ipv6Addr(0, 0, 0, 0, 0, 0, 0, 1)), \"::1\".parse());\n-        assert_eq!(Ok(Ipv6Addr(0, 0, 0, 0, 0, 0, 0, 0)), \"::\".parse());\n-\n-        assert_eq!(Ok(Ipv6Addr(0x2a02, 0x6b8, 0, 0, 0, 0, 0x11, 0x11)),\n-                \"2a02:6b8::11:11\".parse());\n-\n-        // too long group\n-        let none: Option<IpAddr> = \"::00000\".parse().ok();\n-        assert_eq!(None, none);\n-        // too short\n-        let none: Option<IpAddr> = \"1:2:3:4:5:6:7\".parse().ok();\n-        assert_eq!(None, none);\n-        // too long\n-        let none: Option<IpAddr> = \"1:2:3:4:5:6:7:8:9\".parse().ok();\n-        assert_eq!(None, none);\n-        // triple colon\n-        let none: Option<IpAddr> = \"1:2:::6:7:8\".parse().ok();\n-        assert_eq!(None, none);\n-        // two double colons\n-        let none: Option<IpAddr> = \"1:2::6::8\".parse().ok();\n-        assert_eq!(None, none);\n-    }\n-\n-    #[test]\n-    fn test_from_str_ipv4_in_ipv6() {\n-        assert_eq!(Ok(Ipv6Addr(0, 0, 0, 0, 0, 0, 49152, 545)),\n-                \"::192.0.2.33\".parse());\n-        assert_eq!(Ok(Ipv6Addr(0, 0, 0, 0, 0, 0xFFFF, 49152, 545)),\n-                \"::FFFF:192.0.2.33\".parse());\n-        assert_eq!(Ok(Ipv6Addr(0x64, 0xff9b, 0, 0, 0, 0, 49152, 545)),\n-                \"64:ff9b::192.0.2.33\".parse());\n-        assert_eq!(Ok(Ipv6Addr(0x2001, 0xdb8, 0x122, 0xc000, 0x2, 0x2100, 49152, 545)),\n-                \"2001:db8:122:c000:2:2100:192.0.2.33\".parse());\n-\n-        // colon after v4\n-        let none: Option<IpAddr> = \"::127.0.0.1:\".parse().ok();\n-        assert_eq!(None, none);\n-        // not enough groups\n-        let none: Option<IpAddr> = \"1.2.3.4.5:127.0.0.1\".parse().ok();\n-        assert_eq!(None, none);\n-        // too many groups\n-        let none: Option<IpAddr> = \"1.2.3.4.5:6:7:127.0.0.1\".parse().ok();\n-        assert_eq!(None, none);\n-    }\n-\n-    #[test]\n-    fn test_from_str_socket_addr() {\n-        assert_eq!(Ok(SocketAddr { ip: Ipv4Addr(77, 88, 21, 11), port: 80 }),\n-                \"77.88.21.11:80\".parse());\n-        assert_eq!(Ok(SocketAddr { ip: Ipv6Addr(0x2a02, 0x6b8, 0, 1, 0, 0, 0, 1), port: 53 }),\n-                \"[2a02:6b8:0:1::1]:53\".parse());\n-        assert_eq!(Ok(SocketAddr { ip: Ipv6Addr(0, 0, 0, 0, 0, 0, 0x7F00, 1), port: 22 }),\n-                \"[::127.0.0.1]:22\".parse());\n-\n-        // without port\n-        let none: Option<SocketAddr> = \"127.0.0.1\".parse().ok();\n-        assert_eq!(None, none);\n-        // without port\n-        let none: Option<SocketAddr> = \"127.0.0.1:\".parse().ok();\n-        assert_eq!(None, none);\n-        // wrong brackets around v4\n-        let none: Option<SocketAddr> = \"[127.0.0.1]:22\".parse().ok();\n-        assert_eq!(None, none);\n-        // port out of range\n-        let none: Option<SocketAddr> = \"127.0.0.1:123456\".parse().ok();\n-        assert_eq!(None, none);\n-    }\n-\n-    #[test]\n-    fn ipv6_addr_to_string() {\n-        let a1 = Ipv6Addr(0, 0, 0, 0, 0, 0xffff, 0xc000, 0x280);\n-        assert!(a1.to_string() == \"::ffff:192.0.2.128\" ||\n-                a1.to_string() == \"::FFFF:192.0.2.128\");\n-        assert_eq!(Ipv6Addr(8, 9, 10, 11, 12, 13, 14, 15).to_string(),\n-                   \"8:9:a:b:c:d:e:f\");\n-    }\n-\n-    #[test]\n-    fn to_socket_addr_socketaddr() {\n-        let a = SocketAddr { ip: Ipv4Addr(77, 88, 21, 11), port: 12345 };\n-        assert_eq!(Ok(a), a.to_socket_addr());\n-        assert_eq!(Ok(vec![a]), a.to_socket_addr_all());\n-    }\n-\n-    #[test]\n-    fn to_socket_addr_ipaddr_u16() {\n-        let a = Ipv4Addr(77, 88, 21, 11);\n-        let p = 12345;\n-        let e = SocketAddr { ip: a, port: p };\n-        assert_eq!(Ok(e), (a, p).to_socket_addr());\n-        assert_eq!(Ok(vec![e]), (a, p).to_socket_addr_all());\n-    }\n-\n-    #[test]\n-    fn to_socket_addr_str_u16() {\n-        let a = SocketAddr { ip: Ipv4Addr(77, 88, 21, 11), port: 24352 };\n-        assert_eq!(Ok(a), (\"77.88.21.11\", 24352).to_socket_addr());\n-        assert_eq!(Ok(vec![a]), (\"77.88.21.11\", 24352).to_socket_addr_all());\n-\n-        let a = SocketAddr { ip: Ipv6Addr(0x2a02, 0x6b8, 0, 1, 0, 0, 0, 1), port: 53 };\n-        assert_eq!(Ok(a), (\"2a02:6b8:0:1::1\", 53).to_socket_addr());\n-        assert_eq!(Ok(vec![a]), (\"2a02:6b8:0:1::1\", 53).to_socket_addr_all());\n-\n-        let a = SocketAddr { ip: Ipv4Addr(127, 0, 0, 1), port: 23924 };\n-        assert!((\"localhost\", 23924).to_socket_addr_all().unwrap().contains(&a));\n-    }\n-\n-    #[test]\n-    fn to_socket_addr_str() {\n-        let a = SocketAddr { ip: Ipv4Addr(77, 88, 21, 11), port: 24352 };\n-        assert_eq!(Ok(a), \"77.88.21.11:24352\".to_socket_addr());\n-        assert_eq!(Ok(vec![a]), \"77.88.21.11:24352\".to_socket_addr_all());\n-\n-        let a = SocketAddr { ip: Ipv6Addr(0x2a02, 0x6b8, 0, 1, 0, 0, 0, 1), port: 53 };\n-        assert_eq!(Ok(a), \"[2a02:6b8:0:1::1]:53\".to_socket_addr());\n-        assert_eq!(Ok(vec![a]), \"[2a02:6b8:0:1::1]:53\".to_socket_addr_all());\n-\n-        let a = SocketAddr { ip: Ipv4Addr(127, 0, 0, 1), port: 23924 };\n-        assert!(\"localhost:23924\".to_socket_addr_all().unwrap().contains(&a));\n-    }\n-}"}, {"sha": "a3567290b0e16395a83003ed874f3301bb469e50", "filename": "src/libstd/old_io/net/mod.rs", "status": "removed", "additions": 0, "deletions": 50, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/8415fa27877a4309a79b08c75a52eb4c3546b7a5/src%2Flibstd%2Fold_io%2Fnet%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8415fa27877a4309a79b08c75a52eb4c3546b7a5/src%2Flibstd%2Fold_io%2Fnet%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fnet%2Fmod.rs?ref=8415fa27877a4309a79b08c75a52eb4c3546b7a5", "patch": "@@ -1,50 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Networking I/O\n-\n-#![deprecated(since = \"1.0.0\",\n-              reason = \"replaced with new I/O primitives in `std::net`\")]\n-#![unstable(feature = \"old_io\")]\n-\n-use old_io::{IoError, IoResult, InvalidInput};\n-use ops::FnMut;\n-use option::Option::None;\n-use result::Result::{Ok, Err};\n-use self::ip::{SocketAddr, ToSocketAddr};\n-\n-pub use self::addrinfo::get_host_addresses;\n-\n-pub mod addrinfo;\n-pub mod tcp;\n-pub mod udp;\n-pub mod ip;\n-pub mod pipe;\n-\n-fn with_addresses<A, T, F>(addr: A, mut action: F) -> IoResult<T> where\n-    A: ToSocketAddr,\n-    F: FnMut(SocketAddr) -> IoResult<T>,\n-{\n-    const DEFAULT_ERROR: IoError = IoError {\n-        kind: InvalidInput,\n-        desc: \"no addresses found for hostname\",\n-        detail: None\n-    };\n-\n-    let addresses = try!(addr.to_socket_addr_all());\n-    let mut err = DEFAULT_ERROR;\n-    for addr in addresses {\n-        match action(addr) {\n-            Ok(r) => return Ok(r),\n-            Err(e) => err = e\n-        }\n-    }\n-    Err(err)\n-}"}, {"sha": "7b23c3e1d03f21f8f60be42924fc1608f3d84f5d", "filename": "src/libstd/old_io/net/pipe.rs", "status": "removed", "additions": 0, "deletions": 883, "changes": 883, "blob_url": "https://github.com/rust-lang/rust/blob/8415fa27877a4309a79b08c75a52eb4c3546b7a5/src%2Flibstd%2Fold_io%2Fnet%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8415fa27877a4309a79b08c75a52eb4c3546b7a5/src%2Flibstd%2Fold_io%2Fnet%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fnet%2Fpipe.rs?ref=8415fa27877a4309a79b08c75a52eb4c3546b7a5", "patch": "@@ -1,883 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Named pipes\n-//!\n-//! This module contains the ability to communicate over named pipes with\n-//! synchronous I/O. On windows, this corresponds to talking over a Named Pipe,\n-//! while on Unix it corresponds to UNIX domain sockets.\n-//!\n-//! These pipes are similar to TCP in the sense that you can have both a stream to a\n-//! server and a server itself. The server provided accepts other `UnixStream`\n-//! instances as clients.\n-\n-#![allow(missing_docs)]\n-#![deprecated(since = \"1.0.0\",\n-              reason = \"will be removed to be reintroduced at a later date; \\\n-                        in the meantime consider using the `unix_socket` crate \\\n-                        for unix sockets; there is currently no replacement \\\n-                        for named pipes\")]\n-#![unstable(feature = \"old_io\")]\n-\n-use prelude::v1::*;\n-\n-use ffi::CString;\n-use old_path::BytesContainer;\n-use old_io::{Listener, Acceptor, IoResult, TimedOut, standard_error};\n-use old_io::{Reader, Writer};\n-use sys::pipe::UnixAcceptor as UnixAcceptorImp;\n-use sys::pipe::UnixListener as UnixListenerImp;\n-use sys::pipe::UnixStream as UnixStreamImp;\n-use time::Duration;\n-\n-use sys_common;\n-\n-/// A stream which communicates over a named pipe.\n-pub struct UnixStream {\n-    inner: UnixStreamImp,\n-}\n-\n-impl UnixStream {\n-\n-    /// Connect to a pipe named by `path`. This will attempt to open a\n-    /// connection to the underlying socket.\n-    ///\n-    /// The returned stream will be closed when the object falls out of scope.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// # #![feature(old_io, old_path, io)]\n-    /// # #![allow(unused_must_use)]\n-    /// use std::old_io::net::pipe::UnixStream;\n-    /// use std::old_io::*;\n-    /// use std::old_path::Path;\n-    ///\n-    /// let server = Path::new(\"path/to/my/socket\");\n-    /// let mut stream = UnixStream::connect(&server);\n-    /// stream.write(&[1, 2, 3]);\n-    /// ```\n-    pub fn connect<P: BytesContainer>(path: P) -> IoResult<UnixStream> {\n-        let path = try!(CString::new(path.container_as_bytes()));\n-        UnixStreamImp::connect(&path, None)\n-            .map(|inner| UnixStream { inner: inner })\n-    }\n-\n-    /// Connect to a pipe named by `path`, timing out if the specified number of\n-    /// milliseconds.\n-    ///\n-    /// This function is similar to `connect`, except that if `timeout`\n-    /// elapses the function will return an error of kind `TimedOut`.\n-    ///\n-    /// If a `timeout` with zero or negative duration is specified then\n-    /// the function returns `Err`, with the error kind set to `TimedOut`.\n-    #[unstable(feature = \"io\",\n-               reason = \"the timeout argument is likely to change types\")]\n-    pub fn connect_timeout<P>(path: P, timeout: Duration)\n-                              -> IoResult<UnixStream>\n-                              where P: BytesContainer {\n-        if timeout <= Duration::milliseconds(0) {\n-            return Err(standard_error(TimedOut));\n-        }\n-\n-        let path = try!(CString::new(path.container_as_bytes()));\n-        UnixStreamImp::connect(&path, Some(timeout.num_milliseconds() as u64))\n-            .map(|inner| UnixStream { inner: inner })\n-    }\n-\n-\n-    /// Closes the reading half of this connection.\n-    ///\n-    /// This method will close the reading portion of this connection, causing\n-    /// all pending and future reads to immediately return with an error.\n-    ///\n-    /// Note that this method affects all cloned handles associated with this\n-    /// stream, not just this one handle.\n-    pub fn close_read(&mut self) -> IoResult<()> {\n-        self.inner.close_read()\n-    }\n-\n-    /// Closes the writing half of this connection.\n-    ///\n-    /// This method will close the writing portion of this connection, causing\n-    /// all pending and future writes to immediately return with an error.\n-    ///\n-    /// Note that this method affects all cloned handles associated with this\n-    /// stream, not just this one handle.\n-    pub fn close_write(&mut self) -> IoResult<()> {\n-        self.inner.close_write()\n-    }\n-\n-    /// Sets the read/write timeout for this socket.\n-    ///\n-    /// For more information, see `TcpStream::set_timeout`\n-    #[unstable(feature = \"io\",\n-               reason = \"the timeout argument may change in type and value\")]\n-    pub fn set_timeout(&mut self, timeout_ms: Option<u64>) {\n-        self.inner.set_timeout(timeout_ms)\n-    }\n-\n-    /// Sets the read timeout for this socket.\n-    ///\n-    /// For more information, see `TcpStream::set_timeout`\n-    #[unstable(feature = \"io\",\n-               reason = \"the timeout argument may change in type and value\")]\n-    pub fn set_read_timeout(&mut self, timeout_ms: Option<u64>) {\n-        self.inner.set_read_timeout(timeout_ms)\n-    }\n-\n-    /// Sets the write timeout for this socket.\n-    ///\n-    /// For more information, see `TcpStream::set_timeout`\n-    #[unstable(feature = \"io\",\n-               reason = \"the timeout argument may change in type and value\")]\n-    pub fn set_write_timeout(&mut self, timeout_ms: Option<u64>) {\n-        self.inner.set_write_timeout(timeout_ms)\n-    }\n-}\n-\n-impl Clone for UnixStream {\n-    fn clone(&self) -> UnixStream {\n-        UnixStream { inner: self.inner.clone() }\n-    }\n-}\n-\n-impl Reader for UnixStream {\n-    fn read(&mut self, buf: &mut [u8]) -> IoResult<usize> {\n-        self.inner.read(buf)\n-    }\n-}\n-\n-impl Writer for UnixStream {\n-    fn write_all(&mut self, buf: &[u8]) -> IoResult<()> {\n-        self.inner.write(buf)\n-    }\n-}\n-\n-impl sys_common::AsInner<UnixStreamImp> for UnixStream {\n-    fn as_inner(&self) -> &UnixStreamImp {\n-        &self.inner\n-    }\n-}\n-\n-/// A value that can listen for incoming named pipe connection requests.\n-pub struct UnixListener {\n-    /// The internal, opaque runtime Unix listener.\n-    inner: UnixListenerImp,\n-}\n-\n-impl UnixListener {\n-    /// Creates a new listener, ready to receive incoming connections on the\n-    /// specified socket. The server will be named by `path`.\n-    ///\n-    /// This listener will be closed when it falls out of scope.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// # #![feature(old_io, io, old_path)]\n-    /// # fn foo() {\n-    /// use std::old_io::net::pipe::UnixListener;\n-    /// use std::old_io::*;\n-    /// use std::old_path::Path;\n-    ///\n-    /// let server = Path::new(\"/path/to/my/socket\");\n-    /// let stream = UnixListener::bind(&server);\n-    /// for mut client in stream.listen().incoming() {\n-    ///     let _ = client.write(&[1, 2, 3, 4]);\n-    /// }\n-    /// # }\n-    /// ```\n-    pub fn bind<P: BytesContainer>(path: P) -> IoResult<UnixListener> {\n-        let path = try!(CString::new(path.container_as_bytes()));\n-        UnixListenerImp::bind(&path)\n-            .map(|inner| UnixListener { inner: inner })\n-    }\n-}\n-\n-impl Listener<UnixAcceptor> for UnixListener {\n-    fn listen(self) -> IoResult<UnixAcceptor> {\n-        self.inner.listen()\n-            .map(|inner| UnixAcceptor { inner: inner })\n-    }\n-}\n-\n-impl sys_common::AsInner<UnixListenerImp> for UnixListener {\n-    fn as_inner(&self) -> &UnixListenerImp {\n-        &self.inner\n-    }\n-}\n-\n-/// A value that can accept named pipe connections, returned from `listen()`.\n-pub struct UnixAcceptor {\n-    /// The internal, opaque runtime Unix acceptor.\n-    inner: UnixAcceptorImp\n-}\n-\n-impl UnixAcceptor {\n-    /// Sets a timeout for this acceptor, after which accept() will no longer\n-    /// block indefinitely.\n-    ///\n-    /// The argument specified is the amount of time, in milliseconds, into the\n-    /// future after which all invocations of accept() will not block (and any\n-    /// pending invocation will return). A value of `None` will clear any\n-    /// existing timeout.\n-    ///\n-    /// When using this method, it is likely necessary to reset the timeout as\n-    /// appropriate, the timeout specified is specific to this object, not\n-    /// specific to the next request.\n-    #[unstable(feature = \"io\",\n-               reason = \"the name and arguments to this function are likely \\\n-                         to change\")]\n-    pub fn set_timeout(&mut self, timeout_ms: Option<u64>) {\n-        self.inner.set_timeout(timeout_ms)\n-    }\n-\n-    /// Closes the accepting capabilities of this acceptor.\n-    ///\n-    /// This function has the same semantics as `TcpAcceptor::close_accept`, and\n-    /// more information can be found in that documentation.\n-    #[unstable(feature = \"io\")]\n-    pub fn close_accept(&mut self) -> IoResult<()> {\n-        self.inner.close_accept()\n-    }\n-}\n-\n-impl Acceptor for UnixAcceptor {\n-    type Connection = UnixStream;\n-    fn accept(&mut self) -> IoResult<UnixStream> {\n-        self.inner.accept().map(|s| {\n-            UnixStream { inner: s }\n-        })\n-    }\n-}\n-\n-impl Clone for UnixAcceptor {\n-    /// Creates a new handle to this unix acceptor, allowing for simultaneous\n-    /// accepts.\n-    ///\n-    /// The underlying unix acceptor will not be closed until all handles to the\n-    /// acceptor have been deallocated. Incoming connections will be received on\n-    /// at most once acceptor, the same connection will not be accepted twice.\n-    ///\n-    /// The `close_accept` method will shut down *all* acceptors cloned from the\n-    /// same original acceptor, whereas the `set_timeout` method only affects\n-    /// the selector that it is called on.\n-    ///\n-    /// This function is useful for creating a handle to invoke `close_accept`\n-    /// on to wake up any other task blocked in `accept`.\n-    fn clone(&self) -> UnixAcceptor {\n-        UnixAcceptor { inner: self.inner.clone() }\n-    }\n-}\n-\n-impl sys_common::AsInner<UnixAcceptorImp> for UnixAcceptor {\n-    fn as_inner(&self) -> &UnixAcceptorImp {\n-        &self.inner\n-    }\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    use prelude::v1::*;\n-\n-    use old_io::fs::PathExtensions;\n-    use old_io::{EndOfFile, TimedOut, ShortWrite, IoError, ConnectionReset};\n-    use old_io::{NotConnected, BrokenPipe, FileNotFound, InvalidInput, OtherIoError};\n-    use old_io::{PermissionDenied, Acceptor, Listener};\n-    use old_io::{Reader, Writer};\n-    use old_io::test::*;\n-    use super::*;\n-    use sync::mpsc::channel;\n-    use thread;\n-    use time::Duration;\n-\n-    pub fn smalltest<F,G>(server: F, client: G)\n-        where F : FnOnce(UnixStream), F : Send,\n-              G : FnOnce(UnixStream), G : Send + 'static\n-    {\n-        let path1 = next_test_unix();\n-        let path2 = path1.clone();\n-\n-        let mut acceptor = UnixListener::bind(&path1).listen();\n-\n-        let _t = thread::spawn(move|| {\n-            match UnixStream::connect(&path2) {\n-                Ok(c) => client(c),\n-                Err(e) => panic!(\"failed connect: {}\", e),\n-            }\n-        });\n-\n-        match acceptor.accept() {\n-            Ok(c) => server(c),\n-            Err(e) => panic!(\"failed accept: {}\", e),\n-        }\n-    }\n-\n-    #[test]\n-    fn bind_error() {\n-        let path = \"path/to/nowhere\";\n-        match UnixListener::bind(&path) {\n-            Ok(..) => panic!(),\n-            Err(e) => {\n-                assert!(e.kind == PermissionDenied || e.kind == FileNotFound ||\n-                        e.kind == InvalidInput);\n-            }\n-        }\n-    }\n-\n-    #[test]\n-    fn connect_error() {\n-        let path = if cfg!(windows) {\n-            r\"\\\\.\\pipe\\this_should_not_exist_ever\"\n-        } else {\n-            \"path/to/nowhere\"\n-        };\n-        match UnixStream::connect(&path) {\n-            Ok(..) => panic!(),\n-            Err(e) => {\n-                assert!(e.kind == FileNotFound || e.kind == OtherIoError);\n-            }\n-        }\n-    }\n-\n-    #[test]\n-    fn smoke() {\n-        smalltest(move |mut server| {\n-            let mut buf = [0];\n-            server.read(&mut buf).unwrap();\n-            assert!(buf[0] == 99);\n-        }, move|mut client| {\n-            client.write(&[99]).unwrap();\n-        })\n-    }\n-\n-    #[cfg_attr(windows, ignore)] // FIXME(#12516)\n-    #[test]\n-    fn read_eof() {\n-        smalltest(move|mut server| {\n-            let mut buf = [0];\n-            assert!(server.read(&mut buf).is_err());\n-            assert!(server.read(&mut buf).is_err());\n-        }, move|_client| {\n-            // drop the client\n-        })\n-    }\n-\n-    #[test]\n-    fn write_begone() {\n-        smalltest(move|mut server| {\n-            let buf = [0];\n-            loop {\n-                match server.write(&buf) {\n-                    Ok(..) => {}\n-                    Err(e) => {\n-                        assert!(e.kind == BrokenPipe ||\n-                                e.kind == NotConnected ||\n-                                e.kind == ConnectionReset,\n-                                \"unknown error {}\", e);\n-                        break;\n-                    }\n-                }\n-            }\n-        }, move|_client| {\n-            // drop the client\n-        })\n-    }\n-\n-    #[test]\n-    fn accept_lots() {\n-        let times = 10;\n-        let path1 = next_test_unix();\n-        let path2 = path1.clone();\n-\n-        let mut acceptor = match UnixListener::bind(&path1).listen() {\n-            Ok(a) => a,\n-            Err(e) => panic!(\"failed listen: {}\", e),\n-        };\n-\n-        let _t = thread::spawn(move|| {\n-            for _ in 0..times {\n-                let mut stream = UnixStream::connect(&path2);\n-                match stream.write(&[100]) {\n-                    Ok(..) => {}\n-                    Err(e) => panic!(\"failed write: {}\", e)\n-                }\n-            }\n-        });\n-\n-        for _ in 0..times {\n-            let mut client = acceptor.accept();\n-            let mut buf = [0];\n-            match client.read(&mut buf) {\n-                Ok(..) => {}\n-                Err(e) => panic!(\"failed read/accept: {}\", e),\n-            }\n-            assert_eq!(buf[0], 100);\n-        }\n-    }\n-\n-    #[cfg(unix)]\n-    #[test]\n-    fn path_exists() {\n-        let path = next_test_unix();\n-        let _acceptor = UnixListener::bind(&path).listen();\n-        assert!(path.exists());\n-    }\n-\n-    #[test]\n-    fn unix_clone_smoke() {\n-        let addr = next_test_unix();\n-        let mut acceptor = UnixListener::bind(&addr).listen();\n-\n-        let _t = thread::spawn(move|| {\n-            let mut s = UnixStream::connect(&addr);\n-            let mut buf = [0, 0];\n-            debug!(\"client reading\");\n-            assert_eq!(s.read(&mut buf), Ok(1));\n-            assert_eq!(buf[0], 1);\n-            debug!(\"client writing\");\n-            s.write(&[2]).unwrap();\n-            debug!(\"client dropping\");\n-        });\n-\n-        let mut s1 = acceptor.accept().unwrap();\n-        let s2 = s1.clone();\n-\n-        let (tx1, rx1) = channel();\n-        let (tx2, rx2) = channel();\n-        let _t = thread::spawn(move|| {\n-            let mut s2 = s2;\n-            rx1.recv().unwrap();\n-            debug!(\"writer writing\");\n-            s2.write(&[1]).unwrap();\n-            debug!(\"writer done\");\n-            tx2.send(()).unwrap();\n-        });\n-        tx1.send(()).unwrap();\n-        let mut buf = [0, 0];\n-        debug!(\"reader reading\");\n-        assert_eq!(s1.read(&mut buf), Ok(1));\n-        debug!(\"reader done\");\n-        rx2.recv().unwrap();\n-    }\n-\n-    #[test]\n-    fn unix_clone_two_read() {\n-        let addr = next_test_unix();\n-        let mut acceptor = UnixListener::bind(&addr).listen();\n-        let (tx1, rx) = channel();\n-        let tx2 = tx1.clone();\n-\n-        let _t = thread::spawn(move|| {\n-            let mut s = UnixStream::connect(&addr);\n-            s.write(&[1]).unwrap();\n-            rx.recv().unwrap();\n-            s.write(&[2]).unwrap();\n-            rx.recv().unwrap();\n-        });\n-\n-        let mut s1 = acceptor.accept().unwrap();\n-        let s2 = s1.clone();\n-\n-        let (done, rx) = channel();\n-        let _t = thread::spawn(move|| {\n-            let mut s2 = s2;\n-            let mut buf = [0, 0];\n-            s2.read(&mut buf).unwrap();\n-            tx2.send(()).unwrap();\n-            done.send(()).unwrap();\n-        });\n-        let mut buf = [0, 0];\n-        s1.read(&mut buf).unwrap();\n-        tx1.send(()).unwrap();\n-\n-        rx.recv().unwrap();\n-    }\n-\n-    #[test]\n-    fn unix_clone_two_write() {\n-        let addr = next_test_unix();\n-        let mut acceptor = UnixListener::bind(&addr).listen();\n-\n-        let _t = thread::spawn(move|| {\n-            let mut s = UnixStream::connect(&addr);\n-            let buf = &mut [0, 1];\n-            s.read(buf).unwrap();\n-            s.read(buf).unwrap();\n-        });\n-\n-        let mut s1 = acceptor.accept().unwrap();\n-        let s2 = s1.clone();\n-\n-        let (tx, rx) = channel();\n-        let _t = thread::spawn(move|| {\n-            let mut s2 = s2;\n-            s2.write(&[1]).unwrap();\n-            tx.send(()).unwrap();\n-        });\n-        s1.write(&[2]).unwrap();\n-\n-        rx.recv().unwrap();\n-    }\n-\n-    #[cfg(not(windows))]\n-    #[test]\n-    fn drop_removes_listener_path() {\n-        let path = next_test_unix();\n-        let l = UnixListener::bind(&path).unwrap();\n-        assert!(path.exists());\n-        drop(l);\n-        assert!(!path.exists());\n-    }\n-\n-    #[cfg(not(windows))]\n-    #[test]\n-    fn drop_removes_acceptor_path() {\n-        let path = next_test_unix();\n-        let l = UnixListener::bind(&path).unwrap();\n-        assert!(path.exists());\n-        drop(l.listen().unwrap());\n-        assert!(!path.exists());\n-    }\n-\n-    #[test]\n-    fn accept_timeout() {\n-        let addr = next_test_unix();\n-        let mut a = UnixListener::bind(&addr).unwrap().listen().unwrap();\n-\n-        a.set_timeout(Some(10));\n-\n-        // Make sure we time out once and future invocations also time out\n-        let err = a.accept().err().unwrap();\n-        assert_eq!(err.kind, TimedOut);\n-        let err = a.accept().err().unwrap();\n-        assert_eq!(err.kind, TimedOut);\n-\n-        // Also make sure that even though the timeout is expired that we will\n-        // continue to receive any pending connections.\n-        let (tx, rx) = channel();\n-        let addr2 = addr.clone();\n-        let _t = thread::spawn(move|| {\n-            tx.send(UnixStream::connect(&addr2).unwrap()).unwrap();\n-        });\n-        let l = rx.recv().unwrap();\n-        for i in 0..1001 {\n-            match a.accept() {\n-                Ok(..) => break,\n-                Err(ref e) if e.kind == TimedOut => {}\n-                Err(e) => panic!(\"error: {}\", e),\n-            }\n-            ::thread::yield_now();\n-            if i == 1000 { panic!(\"should have a pending connection\") }\n-        }\n-        drop(l);\n-\n-        // Unset the timeout and make sure that this always blocks.\n-        a.set_timeout(None);\n-        let addr2 = addr.clone();\n-        let _t = thread::spawn(move|| {\n-            drop(UnixStream::connect(&addr2).unwrap());\n-        });\n-        a.accept().unwrap();\n-    }\n-\n-    #[test]\n-    fn connect_timeout_error() {\n-        let addr = next_test_unix();\n-        assert!(UnixStream::connect_timeout(&addr, Duration::milliseconds(100)).is_err());\n-    }\n-\n-    #[test]\n-    fn connect_timeout_success() {\n-        let addr = next_test_unix();\n-        let _a = UnixListener::bind(&addr).unwrap().listen().unwrap();\n-        assert!(UnixStream::connect_timeout(&addr, Duration::milliseconds(100)).is_ok());\n-    }\n-\n-    #[test]\n-    fn connect_timeout_zero() {\n-        let addr = next_test_unix();\n-        let _a = UnixListener::bind(&addr).unwrap().listen().unwrap();\n-        assert!(UnixStream::connect_timeout(&addr, Duration::milliseconds(0)).is_err());\n-    }\n-\n-    #[test]\n-    fn connect_timeout_negative() {\n-        let addr = next_test_unix();\n-        let _a = UnixListener::bind(&addr).unwrap().listen().unwrap();\n-        assert!(UnixStream::connect_timeout(&addr, Duration::milliseconds(-1)).is_err());\n-    }\n-\n-    #[test]\n-    fn close_readwrite_smoke() {\n-        let addr = next_test_unix();\n-        let a = UnixListener::bind(&addr).listen().unwrap();\n-        let (_tx, rx) = channel::<()>();\n-        thread::spawn(move|| {\n-            let mut a = a;\n-            let _s = a.accept().unwrap();\n-            let _ = rx.recv();\n-        });\n-\n-        let mut b = [0];\n-        let mut s = UnixStream::connect(&addr).unwrap();\n-        let mut s2 = s.clone();\n-\n-        // closing should prevent reads/writes\n-        s.close_write().unwrap();\n-        assert!(s.write(&[0]).is_err());\n-        s.close_read().unwrap();\n-        assert!(s.read(&mut b).is_err());\n-\n-        // closing should affect previous handles\n-        assert!(s2.write(&[0]).is_err());\n-        assert!(s2.read(&mut b).is_err());\n-\n-        // closing should affect new handles\n-        let mut s3 = s.clone();\n-        assert!(s3.write(&[0]).is_err());\n-        assert!(s3.read(&mut b).is_err());\n-\n-        // make sure these don't die\n-        let _ = s2.close_read();\n-        let _ = s2.close_write();\n-        let _ = s3.close_read();\n-        let _ = s3.close_write();\n-    }\n-\n-    #[test]\n-    fn close_read_wakes_up() {\n-        let addr = next_test_unix();\n-        let a = UnixListener::bind(&addr).listen().unwrap();\n-        let (_tx, rx) = channel::<()>();\n-        thread::spawn(move|| {\n-            let mut a = a;\n-            let _s = a.accept().unwrap();\n-            let _ = rx.recv();\n-        });\n-\n-        let mut s = UnixStream::connect(&addr).unwrap();\n-        let s2 = s.clone();\n-        let (tx, rx) = channel();\n-        let _t = thread::spawn(move|| {\n-            let mut s2 = s2;\n-            assert!(s2.read(&mut [0]).is_err());\n-            tx.send(()).unwrap();\n-        });\n-        // this should wake up the child task\n-        s.close_read().unwrap();\n-\n-        // this test will never finish if the child doesn't wake up\n-        rx.recv().unwrap();\n-    }\n-\n-    #[test]\n-    fn readwrite_timeouts() {\n-        let addr = next_test_unix();\n-        let mut a = UnixListener::bind(&addr).listen().unwrap();\n-        let (tx, rx) = channel::<()>();\n-        thread::spawn(move|| {\n-            let mut s = UnixStream::connect(&addr).unwrap();\n-            rx.recv().unwrap();\n-            assert!(s.write(&[0]).is_ok());\n-            let _ = rx.recv();\n-        });\n-\n-        let mut s = a.accept().unwrap();\n-        s.set_timeout(Some(20));\n-        assert_eq!(s.read(&mut [0]).err().unwrap().kind, TimedOut);\n-        assert_eq!(s.read(&mut [0]).err().unwrap().kind, TimedOut);\n-\n-        s.set_timeout(Some(20));\n-        for i in 0..1001 {\n-            match s.write(&[0; 128 * 1024]) {\n-                Ok(()) | Err(IoError { kind: ShortWrite(..), .. }) => {},\n-                Err(IoError { kind: TimedOut, .. }) => break,\n-                Err(e) => panic!(\"{}\", e),\n-           }\n-           if i == 1000 { panic!(\"should have filled up?!\"); }\n-        }\n-\n-        // I'm not sure as to why, but apparently the write on windows always\n-        // succeeds after the previous timeout. Who knows?\n-        if !cfg!(windows) {\n-            assert_eq!(s.write(&[0]).err().unwrap().kind, TimedOut);\n-        }\n-\n-        tx.send(()).unwrap();\n-        s.set_timeout(None);\n-        assert_eq!(s.read(&mut [0, 0]), Ok(1));\n-    }\n-\n-    #[test]\n-    fn read_timeouts() {\n-        let addr = next_test_unix();\n-        let mut a = UnixListener::bind(&addr).listen().unwrap();\n-        let (tx, rx) = channel::<()>();\n-        thread::spawn(move|| {\n-            let mut s = UnixStream::connect(&addr).unwrap();\n-            rx.recv().unwrap();\n-            let mut amt = 0;\n-            while amt < 100 * 128 * 1024 {\n-                match s.read(&mut [0;128 * 1024]) {\n-                    Ok(n) => { amt += n; }\n-                    Err(e) => panic!(\"{}\", e),\n-                }\n-            }\n-            let _ = rx.recv();\n-        });\n-\n-        let mut s = a.accept().unwrap();\n-        s.set_read_timeout(Some(20));\n-        assert_eq!(s.read(&mut [0]).err().unwrap().kind, TimedOut);\n-        assert_eq!(s.read(&mut [0]).err().unwrap().kind, TimedOut);\n-\n-        tx.send(()).unwrap();\n-        for _ in 0..100 {\n-            assert!(s.write(&[0;128 * 1024]).is_ok());\n-        }\n-    }\n-\n-    #[test]\n-    fn write_timeouts() {\n-        let addr = next_test_unix();\n-        let mut a = UnixListener::bind(&addr).listen().unwrap();\n-        let (tx, rx) = channel::<()>();\n-        thread::spawn(move|| {\n-            let mut s = UnixStream::connect(&addr).unwrap();\n-            rx.recv().unwrap();\n-            assert!(s.write(&[0]).is_ok());\n-            let _ = rx.recv();\n-        });\n-\n-        let mut s = a.accept().unwrap();\n-        s.set_write_timeout(Some(20));\n-        for i in 0..1001 {\n-            match s.write(&[0; 128 * 1024]) {\n-                Ok(()) | Err(IoError { kind: ShortWrite(..), .. }) => {},\n-                Err(IoError { kind: TimedOut, .. }) => break,\n-                Err(e) => panic!(\"{}\", e),\n-           }\n-           if i == 1000 { panic!(\"should have filled up?!\"); }\n-        }\n-\n-        tx.send(()).unwrap();\n-        assert!(s.read(&mut [0]).is_ok());\n-    }\n-\n-    #[test]\n-    fn timeout_concurrent_read() {\n-        let addr = next_test_unix();\n-        let mut a = UnixListener::bind(&addr).listen().unwrap();\n-        let (tx, rx) = channel::<()>();\n-        thread::spawn(move|| {\n-            let mut s = UnixStream::connect(&addr).unwrap();\n-            rx.recv().unwrap();\n-            assert!(s.write(&[0]).is_ok());\n-            let _ = rx.recv();\n-        });\n-\n-        let mut s = a.accept().unwrap();\n-        let s2 = s.clone();\n-        let (tx2, rx2) = channel();\n-        let _t = thread::spawn(move|| {\n-            let mut s2 = s2;\n-            assert!(s2.read(&mut [0]).is_ok());\n-            tx2.send(()).unwrap();\n-        });\n-\n-        s.set_read_timeout(Some(20));\n-        assert_eq!(s.read(&mut [0]).err().unwrap().kind, TimedOut);\n-        tx.send(()).unwrap();\n-\n-        rx2.recv().unwrap();\n-    }\n-\n-    #[cfg(not(windows))]\n-    #[test]\n-    fn clone_accept_smoke() {\n-        let addr = next_test_unix();\n-        let l = UnixListener::bind(&addr);\n-        let mut a = l.listen().unwrap();\n-        let mut a2 = a.clone();\n-\n-        let addr2 = addr.clone();\n-        let _t = thread::spawn(move|| {\n-            let _ = UnixStream::connect(&addr2);\n-        });\n-        let _t = thread::spawn(move|| {\n-            let _ = UnixStream::connect(&addr);\n-        });\n-\n-        assert!(a.accept().is_ok());\n-        drop(a);\n-        assert!(a2.accept().is_ok());\n-    }\n-\n-    #[cfg(not(windows))] // FIXME #17553\n-    #[test]\n-    fn clone_accept_concurrent() {\n-        let addr = next_test_unix();\n-        let l = UnixListener::bind(&addr);\n-        let a = l.listen().unwrap();\n-        let a2 = a.clone();\n-\n-        let (tx, rx) = channel();\n-        let tx2 = tx.clone();\n-\n-        let _t = thread::spawn(move|| {\n-            let mut a = a;\n-            tx.send(a.accept()).unwrap()\n-        });\n-        let _t = thread::spawn(move|| {\n-            let mut a = a2;\n-            tx2.send(a.accept()).unwrap()\n-        });\n-\n-        let addr2 = addr.clone();\n-        let _t = thread::spawn(move|| {\n-            let _ = UnixStream::connect(&addr2);\n-        });\n-        let _t = thread::spawn(move|| {\n-            let _ = UnixStream::connect(&addr);\n-        });\n-\n-        assert!(rx.recv().unwrap().is_ok());\n-        assert!(rx.recv().unwrap().is_ok());\n-    }\n-\n-    #[test]\n-    fn close_accept_smoke() {\n-        let addr = next_test_unix();\n-        let l = UnixListener::bind(&addr);\n-        let mut a = l.listen().unwrap();\n-\n-        a.close_accept().unwrap();\n-        assert_eq!(a.accept().err().unwrap().kind, EndOfFile);\n-    }\n-\n-    #[test]\n-    fn close_accept_concurrent() {\n-        let addr = next_test_unix();\n-        let l = UnixListener::bind(&addr);\n-        let a = l.listen().unwrap();\n-        let mut a2 = a.clone();\n-\n-        let (tx, rx) = channel();\n-        let _t = thread::spawn(move|| {\n-            let mut a = a;\n-            tx.send(a.accept()).unwrap();\n-        });\n-        a2.close_accept().unwrap();\n-\n-        assert_eq!(rx.recv().unwrap().err().unwrap().kind, EndOfFile);\n-    }\n-}"}, {"sha": "7fc460c16efca2454a61b7e48bb5d606c62741cf", "filename": "src/libstd/old_io/net/tcp.rs", "status": "removed", "additions": 0, "deletions": 1483, "changes": 1483, "blob_url": "https://github.com/rust-lang/rust/blob/8415fa27877a4309a79b08c75a52eb4c3546b7a5/src%2Flibstd%2Fold_io%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8415fa27877a4309a79b08c75a52eb4c3546b7a5/src%2Flibstd%2Fold_io%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fnet%2Ftcp.rs?ref=8415fa27877a4309a79b08c75a52eb4c3546b7a5", "patch": "@@ -1,1483 +0,0 @@\n-// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! TCP network connections\n-//!\n-//! This module contains the ability to open a TCP stream to a socket address,\n-//! as well as creating a socket server to accept incoming connections. The\n-//! destination and binding addresses can either be an IPv4 or IPv6 address.\n-//!\n-//! A TCP connection implements the `Reader` and `Writer` traits, while the TCP\n-//! listener (socket server) implements the `Listener` and `Acceptor` traits.\n-\n-use clone::Clone;\n-use old_io::IoResult;\n-use result::Result::Err;\n-use old_io::net::ip::{SocketAddr, ToSocketAddr};\n-use old_io::{Reader, Writer, Listener, Acceptor};\n-use old_io::{standard_error, TimedOut};\n-use option::Option;\n-use option::Option::{None, Some};\n-use time::Duration;\n-\n-use sys::tcp::TcpStream as TcpStreamImp;\n-use sys::tcp::TcpListener as TcpListenerImp;\n-use sys::tcp::TcpAcceptor as TcpAcceptorImp;\n-\n-use sys_common;\n-\n-/// A structure which represents a TCP stream between a local socket and a\n-/// remote socket.\n-///\n-/// The socket will be closed when the value is dropped.\n-///\n-/// # Examples\n-///\n-/// ```no_run\n-/// # #![feature(old_io, io)]\n-/// use std::old_io::*;\n-///\n-/// {\n-///     let mut stream = TcpStream::connect(\"127.0.0.1:34254\");\n-///\n-///     // ignore the Result\n-///     let _ = stream.write(&[1]);\n-///\n-///     let mut buf = [0];\n-///     let _ = stream.read(&mut buf); // ignore here too\n-/// } // the stream is closed here\n-/// ```\n-pub struct TcpStream {\n-    inner: TcpStreamImp,\n-}\n-\n-impl TcpStream {\n-    fn new(s: TcpStreamImp) -> TcpStream {\n-        TcpStream { inner: s }\n-    }\n-\n-    /// Open a TCP connection to a remote host.\n-    ///\n-    /// `addr` is an address of the remote host. Anything which implements `ToSocketAddr`\n-    /// trait can be supplied for the address; see this trait documentation for\n-    /// concrete examples.\n-    pub fn connect<A: ToSocketAddr>(addr: A) -> IoResult<TcpStream> {\n-        super::with_addresses(addr, |addr| {\n-            TcpStreamImp::connect(addr, None).map(TcpStream::new)\n-        })\n-    }\n-\n-    /// Creates a TCP connection to a remote socket address, timing out after\n-    /// the specified duration.\n-    ///\n-    /// This is the same as the `connect` method, except that if the timeout\n-    /// specified elapses before a connection is made an error will be\n-    /// returned. The error's kind will be `TimedOut`.\n-    ///\n-    /// Same as the `connect` method, `addr` argument type can be anything which\n-    /// implements `ToSocketAddr` trait.\n-    ///\n-    /// If a `timeout` with zero or negative duration is specified then\n-    /// the function returns `Err`, with the error kind set to `TimedOut`.\n-    #[unstable(feature = \"io\",\n-               reason = \"the timeout argument may eventually change types\")]\n-    pub fn connect_timeout<A: ToSocketAddr>(addr: A,\n-                                            timeout: Duration) -> IoResult<TcpStream> {\n-        if timeout <= Duration::milliseconds(0) {\n-            return Err(standard_error(TimedOut));\n-        }\n-\n-        super::with_addresses(addr, |addr| {\n-            TcpStreamImp::connect(addr, Some(timeout.num_milliseconds() as u64))\n-                .map(TcpStream::new)\n-        })\n-    }\n-\n-    /// Returns the socket address of the remote peer of this TCP connection.\n-    pub fn peer_name(&mut self) -> IoResult<SocketAddr> {\n-        self.inner.peer_name()\n-    }\n-\n-    /// Returns the socket address of the local half of this TCP connection.\n-    pub fn socket_name(&mut self) -> IoResult<SocketAddr> {\n-        self.inner.socket_name()\n-    }\n-\n-    /// Sets the nodelay flag on this connection to the boolean specified\n-    #[unstable(feature = \"io\")]\n-    pub fn set_nodelay(&mut self, nodelay: bool) -> IoResult<()> {\n-        self.inner.set_nodelay(nodelay)\n-    }\n-\n-    /// Sets the keepalive timeout to the timeout specified.\n-    ///\n-    /// If the value specified is `None`, then the keepalive flag is cleared on\n-    /// this connection. Otherwise, the keepalive timeout will be set to the\n-    /// specified time, in seconds.\n-    #[unstable(feature = \"io\")]\n-    pub fn set_keepalive(&mut self, delay_in_seconds: Option<usize>) -> IoResult<()> {\n-        self.inner.set_keepalive(delay_in_seconds)\n-    }\n-\n-    /// Closes the reading half of this connection.\n-    ///\n-    /// This method will close the reading portion of this connection, causing\n-    /// all pending and future reads to immediately return with an error.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// # #![feature(old_io, std_misc)]\n-    /// # #![allow(unused_must_use)]\n-    /// use std::old_io::*;\n-    /// use std::time::Duration;\n-    /// use std::thread;\n-    ///\n-    /// let mut stream = TcpStream::connect(\"127.0.0.1:34254\").unwrap();\n-    /// let stream2 = stream.clone();\n-    ///\n-    /// let _t = thread::spawn(move|| {\n-    ///     // close this stream after one second\n-    ///     timer::sleep(Duration::seconds(1));\n-    ///     let mut stream = stream2;\n-    ///     stream.close_read();\n-    /// });\n-    ///\n-    /// // wait for some data, will get canceled after one second\n-    /// let mut buf = [0];\n-    /// stream.read(&mut buf);\n-    /// ```\n-    ///\n-    /// Note that this method affects all cloned handles associated with this\n-    /// stream, not just this one handle.\n-    pub fn close_read(&mut self) -> IoResult<()> {\n-        self.inner.close_read()\n-    }\n-\n-    /// Closes the writing half of this connection.\n-    ///\n-    /// This method will close the writing portion of this connection, causing\n-    /// all future writes to immediately return with an error.\n-    ///\n-    /// Note that this method affects all cloned handles associated with this\n-    /// stream, not just this one handle.\n-    pub fn close_write(&mut self) -> IoResult<()> {\n-        self.inner.close_write()\n-    }\n-\n-    /// Sets a timeout, in milliseconds, for blocking operations on this stream.\n-    ///\n-    /// This function will set a timeout for all blocking operations (including\n-    /// reads and writes) on this stream. The timeout specified is a relative\n-    /// time, in milliseconds, into the future after which point operations will\n-    /// time out. This means that the timeout must be reset periodically to keep\n-    /// it from expiring. Specifying a value of `None` will clear the timeout\n-    /// for this stream.\n-    ///\n-    /// The timeout on this stream is local to this stream only. Setting a\n-    /// timeout does not affect any other cloned instances of this stream, nor\n-    /// does the timeout propagated to cloned handles of this stream. Setting\n-    /// this timeout will override any specific read or write timeouts\n-    /// previously set for this stream.\n-    ///\n-    /// For clarification on the semantics of interrupting a read and a write,\n-    /// take a look at `set_read_timeout` and `set_write_timeout`.\n-    #[unstable(feature = \"io\",\n-               reason = \"the timeout argument may change in type and value\")]\n-    pub fn set_timeout(&mut self, timeout_ms: Option<u64>) {\n-        self.inner.set_timeout(timeout_ms)\n-    }\n-\n-    /// Sets the timeout for read operations on this stream.\n-    ///\n-    /// See documentation in `set_timeout` for the semantics of this read time.\n-    /// This will overwrite any previous read timeout set through either this\n-    /// function or `set_timeout`.\n-    ///\n-    /// # Errors\n-    ///\n-    /// When this timeout expires, if there is no pending read operation, no\n-    /// action is taken. Otherwise, the read operation will be scheduled to\n-    /// promptly return. If a timeout error is returned, then no data was read\n-    /// during the timeout period.\n-    #[unstable(feature = \"io\",\n-               reason = \"the timeout argument may change in type and value\")]\n-    pub fn set_read_timeout(&mut self, timeout_ms: Option<u64>) {\n-        self.inner.set_read_timeout(timeout_ms)\n-    }\n-\n-    /// Sets the timeout for write operations on this stream.\n-    ///\n-    /// See documentation in `set_timeout` for the semantics of this write time.\n-    /// This will overwrite any previous write timeout set through either this\n-    /// function or `set_timeout`.\n-    ///\n-    /// # Errors\n-    ///\n-    /// When this timeout expires, if there is no pending write operation, no\n-    /// action is taken. Otherwise, the pending write operation will be\n-    /// scheduled to promptly return. The actual state of the underlying stream\n-    /// is not specified.\n-    ///\n-    /// The write operation may return an error of type `ShortWrite` which\n-    /// indicates that the object is known to have written an exact number of\n-    /// bytes successfully during the timeout period, and the remaining bytes\n-    /// were never written.\n-    ///\n-    /// If the write operation returns `TimedOut`, then it the timeout primitive\n-    /// does not know how many bytes were written as part of the timeout\n-    /// operation. It may be the case that bytes continue to be written in an\n-    /// asynchronous fashion after the call to write returns.\n-    #[unstable(feature = \"io\",\n-               reason = \"the timeout argument may change in type and value\")]\n-    pub fn set_write_timeout(&mut self, timeout_ms: Option<u64>) {\n-        self.inner.set_write_timeout(timeout_ms)\n-    }\n-}\n-\n-impl Clone for TcpStream {\n-    /// Creates a new handle to this TCP stream, allowing for simultaneous reads\n-    /// and writes of this connection.\n-    ///\n-    /// The underlying TCP stream will not be closed until all handles to the\n-    /// stream have been deallocated. All handles will also follow the same\n-    /// stream, but two concurrent reads will not receive the same data.\n-    /// Instead, the first read will receive the first packet received, and the\n-    /// second read will receive the second packet.\n-    fn clone(&self) -> TcpStream {\n-        TcpStream { inner: self.inner.clone() }\n-    }\n-}\n-\n-impl Reader for TcpStream {\n-    fn read(&mut self, buf: &mut [u8]) -> IoResult<usize> {\n-        self.inner.read(buf)\n-    }\n-}\n-\n-impl Writer for TcpStream {\n-    fn write_all(&mut self, buf: &[u8]) -> IoResult<()> {\n-        self.inner.write(buf)\n-    }\n-}\n-\n-impl sys_common::AsInner<TcpStreamImp> for TcpStream {\n-    fn as_inner(&self) -> &TcpStreamImp {\n-        &self.inner\n-    }\n-}\n-\n-/// A structure representing a socket server. This listener is used to create a\n-/// `TcpAcceptor` which can be used to accept sockets on a local port.\n-///\n-/// # Examples\n-///\n-/// ```\n-/// # #![feature(old_io)]\n-/// # fn foo() {\n-/// use std::old_io::*;\n-/// use std::thread;\n-///\n-/// let listener = TcpListener::bind(\"127.0.0.1:80\").unwrap();\n-///\n-/// // bind the listener to the specified address\n-/// let mut acceptor = listener.listen().unwrap();\n-///\n-/// fn handle_client(mut stream: TcpStream) {\n-///     // ...\n-/// # &mut stream; // silence unused mutability/variable warning\n-/// }\n-/// // accept connections and process them, spawning a new tasks for each one\n-/// for stream in acceptor.incoming() {\n-///     match stream {\n-///         Err(e) => { /* connection failed */ }\n-///         Ok(stream) => {\n-///             thread::spawn(move|| {\n-///                 // connection succeeded\n-///                 handle_client(stream)\n-///             });\n-///         }\n-///     }\n-/// }\n-///\n-/// // close the socket server\n-/// drop(acceptor);\n-/// # }\n-/// ```\n-pub struct TcpListener {\n-    inner: TcpListenerImp,\n-}\n-\n-impl TcpListener {\n-    /// Creates a new `TcpListener` which will be bound to the specified address.\n-    /// This listener is not ready for accepting connections, `listen` must be called\n-    /// on it before that's possible.\n-    ///\n-    /// Binding with a port number of 0 will request that the OS assigns a port\n-    /// to this listener. The port allocated can be queried via the\n-    /// `socket_name` function.\n-    ///\n-    /// The address type can be any implementer of `ToSocketAddr` trait. See its\n-    /// documentation for concrete examples.\n-    pub fn bind<A: ToSocketAddr>(addr: A) -> IoResult<TcpListener> {\n-        super::with_addresses(addr, |addr| {\n-            TcpListenerImp::bind(addr).map(|inner| TcpListener { inner: inner })\n-        })\n-    }\n-\n-    /// Returns the local socket address of this listener.\n-    pub fn socket_name(&mut self) -> IoResult<SocketAddr> {\n-        self.inner.socket_name()\n-    }\n-}\n-\n-impl Listener<TcpAcceptor> for TcpListener {\n-    fn listen(self) -> IoResult<TcpAcceptor> {\n-        self.inner.listen(128).map(|a| TcpAcceptor { inner: a })\n-    }\n-}\n-\n-impl sys_common::AsInner<TcpListenerImp> for TcpListener {\n-    fn as_inner(&self) -> &TcpListenerImp {\n-        &self.inner\n-    }\n-}\n-\n-/// The accepting half of a TCP socket server. This structure is created through\n-/// a `TcpListener`'s `listen` method, and this object can be used to accept new\n-/// `TcpStream` instances.\n-pub struct TcpAcceptor {\n-    inner: TcpAcceptorImp,\n-}\n-\n-impl TcpAcceptor {\n-    /// Prevents blocking on all future accepts after `ms` milliseconds have\n-    /// elapsed.\n-    ///\n-    /// This function is used to set a deadline after which this acceptor will\n-    /// time out accepting any connections. The argument is the relative\n-    /// distance, in milliseconds, to a point in the future after which all\n-    /// accepts will fail.\n-    ///\n-    /// If the argument specified is `None`, then any previously registered\n-    /// timeout is cleared.\n-    ///\n-    /// A timeout of `0` can be used to \"poll\" this acceptor to see if it has\n-    /// any pending connections. All pending connections will be accepted,\n-    /// regardless of whether the timeout has expired or not (the accept will\n-    /// not block in this case).\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// # #![feature(old_io, io)]\n-    /// use std::old_io::*;\n-    ///\n-    /// let mut a = TcpListener::bind(\"127.0.0.1:8482\").listen().unwrap();\n-    ///\n-    /// // After 100ms have passed, all accepts will fail\n-    /// a.set_timeout(Some(100));\n-    ///\n-    /// match a.accept() {\n-    ///     Ok(..) => println!(\"accepted a socket\"),\n-    ///     Err(ref e) if e.kind == TimedOut => { println!(\"timed out!\"); }\n-    ///     Err(e) => println!(\"err: {}\", e),\n-    /// }\n-    ///\n-    /// // Reset the timeout and try again\n-    /// a.set_timeout(Some(100));\n-    /// let socket = a.accept();\n-    ///\n-    /// // Clear the timeout and block indefinitely waiting for a connection\n-    /// a.set_timeout(None);\n-    /// let socket = a.accept();\n-    /// ```\n-    #[unstable(feature = \"io\",\n-               reason = \"the type of the argument and name of this function are \\\n-                         subject to change\")]\n-    pub fn set_timeout(&mut self, ms: Option<u64>) { self.inner.set_timeout(ms); }\n-\n-    /// Closes the accepting capabilities of this acceptor.\n-    ///\n-    /// This function is similar to `TcpStream`'s `close_{read,write}` methods\n-    /// in that it will affect *all* cloned handles of this acceptor's original\n-    /// handle.\n-    ///\n-    /// Once this function succeeds, all future calls to `accept` will return\n-    /// immediately with an error, preventing all future calls to accept. The\n-    /// underlying socket will not be relinquished back to the OS until all\n-    /// acceptors have been deallocated.\n-    ///\n-    /// This is useful for waking up a thread in an accept loop to indicate that\n-    /// it should exit.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// # #![feature(old_io, io)]\n-    /// use std::old_io::*;\n-    /// use std::thread;\n-    ///\n-    /// let mut a = TcpListener::bind(\"127.0.0.1:8482\").listen().unwrap();\n-    /// let a2 = a.clone();\n-    ///\n-    /// let _t = thread::spawn(move|| {\n-    ///     let mut a2 = a2;\n-    ///     for socket in a2.incoming() {\n-    ///         match socket {\n-    ///             Ok(s) => { /* handle s */ }\n-    ///             Err(ref e) if e.kind == EndOfFile => break, // closed\n-    ///             Err(e) => panic!(\"unexpected error: {}\", e),\n-    ///         }\n-    ///     }\n-    /// });\n-    ///\n-    /// # fn wait_for_sigint() {}\n-    /// // Now that our accept loop is running, wait for the program to be\n-    /// // requested to exit.\n-    /// wait_for_sigint();\n-    ///\n-    /// // Signal our accept loop to exit\n-    /// assert!(a.close_accept().is_ok());\n-    /// ```\n-    #[unstable(feature = \"io\")]\n-    pub fn close_accept(&mut self) -> IoResult<()> {\n-        self.inner.close_accept()\n-    }\n-}\n-\n-impl Acceptor for TcpAcceptor {\n-    type Connection = TcpStream;\n-    fn accept(&mut self) -> IoResult<TcpStream> {\n-        self.inner.accept().map(TcpStream::new)\n-    }\n-}\n-\n-impl Clone for TcpAcceptor {\n-    /// Creates a new handle to this TCP acceptor, allowing for simultaneous\n-    /// accepts.\n-    ///\n-    /// The underlying TCP acceptor will not be closed until all handles to the\n-    /// acceptor have been deallocated. Incoming connections will be received on\n-    /// at most once acceptor, the same connection will not be accepted twice.\n-    ///\n-    /// The `close_accept` method will shut down *all* acceptors cloned from the\n-    /// same original acceptor, whereas the `set_timeout` method only affects\n-    /// the selector that it is called on.\n-    ///\n-    /// This function is useful for creating a handle to invoke `close_accept`\n-    /// on to wake up any other task blocked in `accept`.\n-    fn clone(&self) -> TcpAcceptor {\n-        TcpAcceptor { inner: self.inner.clone() }\n-    }\n-}\n-\n-impl sys_common::AsInner<TcpAcceptorImp> for TcpAcceptor {\n-    fn as_inner(&self) -> &TcpAcceptorImp {\n-        &self.inner\n-    }\n-}\n-\n-#[cfg(test)]\n-mod test {\n-    use prelude::v1::*;\n-\n-    use sync::mpsc::channel;\n-    use thread;\n-    use old_io::net::tcp::*;\n-    use old_io::net::ip::*;\n-    use old_io::test::*;\n-    use old_io::{EndOfFile, TimedOut, ShortWrite, IoError};\n-    use old_io::{ConnectionRefused, BrokenPipe, ConnectionAborted};\n-    use old_io::{ConnectionReset, NotConnected, PermissionDenied, OtherIoError};\n-    use old_io::{InvalidInput};\n-    use old_io::{Acceptor, Listener};\n-    use old_io::{Reader, Writer};\n-\n-    // FIXME #11530 this fails on android because tests are run as root\n-    #[cfg_attr(any(windows, target_os = \"android\"), ignore)]\n-    #[test]\n-    fn bind_error() {\n-        match TcpListener::bind(\"0.0.0.0:1\") {\n-            Ok(..) => panic!(),\n-            Err(e) => assert_eq!(e.kind, PermissionDenied),\n-        }\n-    }\n-\n-    #[test]\n-    fn connect_error() {\n-        match TcpStream::connect(\"0.0.0.0:1\") {\n-            Ok(..) => panic!(),\n-            Err(e) => assert!((e.kind == ConnectionRefused)\n-                              || (e.kind == InvalidInput)),\n-        }\n-    }\n-\n-    #[test]\n-    fn listen_ip4_localhost() {\n-        let socket_addr = next_test_ip4();\n-        let listener = TcpListener::bind(socket_addr);\n-        let mut acceptor = listener.listen();\n-\n-        let _t = thread::spawn(move|| {\n-            let mut stream = TcpStream::connect((\"localhost\", socket_addr.port));\n-            stream.write(&[144]).unwrap();\n-        });\n-\n-        let mut stream = acceptor.accept();\n-        let mut buf = [0];\n-        stream.read(&mut buf).unwrap();\n-        assert!(buf[0] == 144);\n-    }\n-\n-    #[test]\n-    fn connect_localhost() {\n-        let addr = next_test_ip4();\n-        let mut acceptor = TcpListener::bind(addr).listen();\n-\n-        let _t = thread::spawn(move|| {\n-            let mut stream = TcpStream::connect((\"localhost\", addr.port));\n-            stream.write(&[64]).unwrap();\n-        });\n-\n-        let mut stream = acceptor.accept();\n-        let mut buf = [0];\n-        stream.read(&mut buf).unwrap();\n-        assert!(buf[0] == 64);\n-    }\n-\n-    #[test]\n-    fn connect_ip4_loopback() {\n-        let addr = next_test_ip4();\n-        let mut acceptor = TcpListener::bind(addr).listen();\n-\n-        let _t = thread::spawn(move|| {\n-            let mut stream = TcpStream::connect((\"127.0.0.1\", addr.port));\n-            stream.write(&[44]).unwrap();\n-        });\n-\n-        let mut stream = acceptor.accept();\n-        let mut buf = [0];\n-        stream.read(&mut buf).unwrap();\n-        assert!(buf[0] == 44);\n-    }\n-\n-    #[test]\n-    fn connect_ip6_loopback() {\n-        let addr = next_test_ip6();\n-        let mut acceptor = TcpListener::bind(addr).listen();\n-\n-        let _t = thread::spawn(move|| {\n-            let mut stream = TcpStream::connect((\"::1\", addr.port));\n-            stream.write(&[66]).unwrap();\n-        });\n-\n-        let mut stream = acceptor.accept();\n-        let mut buf = [0];\n-        stream.read(&mut buf).unwrap();\n-        assert!(buf[0] == 66);\n-    }\n-\n-    #[test]\n-    fn smoke_test_ip4() {\n-        let addr = next_test_ip4();\n-        let mut acceptor = TcpListener::bind(addr).listen();\n-\n-        let _t = thread::spawn(move|| {\n-            let mut stream = TcpStream::connect(addr);\n-            stream.write(&[99]).unwrap();\n-        });\n-\n-        let mut stream = acceptor.accept();\n-        let mut buf = [0];\n-        stream.read(&mut buf).unwrap();\n-        assert!(buf[0] == 99);\n-    }\n-\n-    #[test]\n-    fn smoke_test_ip6() {\n-        let addr = next_test_ip6();\n-        let mut acceptor = TcpListener::bind(addr).listen();\n-\n-        let _t = thread::spawn(move|| {\n-            let mut stream = TcpStream::connect(addr);\n-            stream.write(&[99]).unwrap();\n-        });\n-\n-        let mut stream = acceptor.accept();\n-        let mut buf = [0];\n-        stream.read(&mut buf).unwrap();\n-        assert!(buf[0] == 99);\n-    }\n-\n-    #[test]\n-    fn read_eof_ip4() {\n-        let addr = next_test_ip4();\n-        let mut acceptor = TcpListener::bind(addr).listen();\n-\n-        let _t = thread::spawn(move|| {\n-            let _stream = TcpStream::connect(addr);\n-            // Close\n-        });\n-\n-        let mut stream = acceptor.accept();\n-        let mut buf = [0];\n-        let nread = stream.read(&mut buf);\n-        assert!(nread.is_err());\n-    }\n-\n-    #[test]\n-    fn read_eof_ip6() {\n-        let addr = next_test_ip6();\n-        let mut acceptor = TcpListener::bind(addr).listen();\n-\n-        let _t = thread::spawn(move|| {\n-            let _stream = TcpStream::connect(addr);\n-            // Close\n-        });\n-\n-        let mut stream = acceptor.accept();\n-        let mut buf = [0];\n-        let nread = stream.read(&mut buf);\n-        assert!(nread.is_err());\n-    }\n-\n-    #[test]\n-    fn read_eof_twice_ip4() {\n-        let addr = next_test_ip4();\n-        let mut acceptor = TcpListener::bind(addr).listen();\n-\n-        let _t = thread::spawn(move|| {\n-            let _stream = TcpStream::connect(addr);\n-            // Close\n-        });\n-\n-        let mut stream = acceptor.accept();\n-        let mut buf = [0];\n-        let nread = stream.read(&mut buf);\n-        assert!(nread.is_err());\n-\n-        match stream.read(&mut buf) {\n-            Ok(..) => panic!(),\n-            Err(ref e) => {\n-                assert!(e.kind == NotConnected || e.kind == EndOfFile,\n-                        \"unknown kind: {:?}\", e.kind);\n-            }\n-        }\n-    }\n-\n-    #[test]\n-    fn read_eof_twice_ip6() {\n-        let addr = next_test_ip6();\n-        let mut acceptor = TcpListener::bind(addr).listen();\n-\n-        let _t = thread::spawn(move|| {\n-            let _stream = TcpStream::connect(addr);\n-            // Close\n-        });\n-\n-        let mut stream = acceptor.accept();\n-        let mut buf = [0];\n-        let nread = stream.read(&mut buf);\n-        assert!(nread.is_err());\n-\n-        match stream.read(&mut buf) {\n-            Ok(..) => panic!(),\n-            Err(ref e) => {\n-                assert!(e.kind == NotConnected || e.kind == EndOfFile,\n-                        \"unknown kind: {:?}\", e.kind);\n-            }\n-        }\n-    }\n-\n-    #[test]\n-    fn write_close_ip4() {\n-        let addr = next_test_ip4();\n-        let mut acceptor = TcpListener::bind(addr).listen();\n-\n-        let (tx, rx) = channel();\n-        let _t = thread::spawn(move|| {\n-            drop(TcpStream::connect(addr));\n-            tx.send(()).unwrap();\n-        });\n-\n-        let mut stream = acceptor.accept();\n-        rx.recv().unwrap();\n-        let buf = [0];\n-        match stream.write(&buf) {\n-            Ok(..) => {}\n-            Err(e) => {\n-                assert!(e.kind == ConnectionReset ||\n-                        e.kind == BrokenPipe ||\n-                        e.kind == ConnectionAborted,\n-                        \"unknown error: {}\", e);\n-            }\n-        }\n-    }\n-\n-    #[test]\n-    fn write_close_ip6() {\n-        let addr = next_test_ip6();\n-        let mut acceptor = TcpListener::bind(addr).listen();\n-\n-        let (tx, rx) = channel();\n-        let _t = thread::spawn(move|| {\n-            drop(TcpStream::connect(addr));\n-            tx.send(()).unwrap();\n-        });\n-\n-        let mut stream = acceptor.accept();\n-        rx.recv().unwrap();\n-        let buf = [0];\n-        match stream.write(&buf) {\n-            Ok(..) => {}\n-            Err(e) => {\n-                assert!(e.kind == ConnectionReset ||\n-                        e.kind == BrokenPipe ||\n-                        e.kind == ConnectionAborted,\n-                        \"unknown error: {}\", e);\n-            }\n-        }\n-    }\n-\n-    #[test]\n-    fn multiple_connect_serial_ip4() {\n-        let addr = next_test_ip4();\n-        let max = 10;\n-        let mut acceptor = TcpListener::bind(addr).listen();\n-\n-        let _t = thread::spawn(move|| {\n-            for _ in 0..max {\n-                let mut stream = TcpStream::connect(addr);\n-                stream.write(&[99]).unwrap();\n-            }\n-        });\n-\n-        for ref mut stream in acceptor.incoming().take(max) {\n-            let mut buf = [0];\n-            stream.read(&mut buf).unwrap();\n-            assert_eq!(buf[0], 99);\n-        }\n-    }\n-\n-    #[test]\n-    fn multiple_connect_serial_ip6() {\n-        let addr = next_test_ip6();\n-        let max = 10;\n-        let mut acceptor = TcpListener::bind(addr).listen();\n-\n-        let _t = thread::spawn(move|| {\n-            for _ in 0..max {\n-                let mut stream = TcpStream::connect(addr);\n-                stream.write(&[99]).unwrap();\n-            }\n-        });\n-\n-        for ref mut stream in acceptor.incoming().take(max) {\n-            let mut buf = [0];\n-            stream.read(&mut buf).unwrap();\n-            assert_eq!(buf[0], 99);\n-        }\n-    }\n-\n-    #[test]\n-    fn multiple_connect_interleaved_greedy_schedule_ip4() {\n-        let addr = next_test_ip4();\n-        static MAX: isize = 10;\n-        let acceptor = TcpListener::bind(addr).listen();\n-\n-        let _t = thread::spawn(move|| {\n-            let mut acceptor = acceptor;\n-            for (i, stream) in acceptor.incoming().enumerate().take(MAX as usize) {\n-                // Start another task to handle the connection\n-                let _t = thread::spawn(move|| {\n-                    let mut stream = stream;\n-                    let mut buf = [0];\n-                    stream.read(&mut buf).unwrap();\n-                    assert!(buf[0] == i as u8);\n-                    debug!(\"read\");\n-                });\n-            }\n-        });\n-\n-        connect(0, addr);\n-\n-        fn connect(i: isize, addr: SocketAddr) {\n-            if i == MAX { return }\n-\n-            let _t = thread::spawn(move|| {\n-                debug!(\"connecting\");\n-                let mut stream = TcpStream::connect(addr);\n-                // Connect again before writing\n-                connect(i + 1, addr);\n-                debug!(\"writing\");\n-                stream.write(&[i as u8]).unwrap();\n-            });\n-        }\n-    }\n-\n-    #[test]\n-    fn multiple_connect_interleaved_greedy_schedule_ip6() {\n-        let addr = next_test_ip6();\n-        static MAX: isize = 10;\n-        let acceptor = TcpListener::bind(addr).listen();\n-\n-        let _t = thread::spawn(move|| {\n-            let mut acceptor = acceptor;\n-            for (i, stream) in acceptor.incoming().enumerate().take(MAX as usize) {\n-                // Start another task to handle the connection\n-                let _t = thread::spawn(move|| {\n-                    let mut stream = stream;\n-                    let mut buf = [0];\n-                    stream.read(&mut buf).unwrap();\n-                    assert!(buf[0] == i as u8);\n-                    debug!(\"read\");\n-                });\n-            }\n-        });\n-\n-        connect(0, addr);\n-\n-        fn connect(i: isize, addr: SocketAddr) {\n-            if i == MAX { return }\n-\n-            let _t = thread::spawn(move|| {\n-                debug!(\"connecting\");\n-                let mut stream = TcpStream::connect(addr);\n-                // Connect again before writing\n-                connect(i + 1, addr);\n-                debug!(\"writing\");\n-                stream.write(&[i as u8]).unwrap();\n-            });\n-        }\n-    }\n-\n-    #[test]\n-    fn multiple_connect_interleaved_lazy_schedule_ip4() {\n-        static MAX: isize = 10;\n-        let addr = next_test_ip4();\n-        let acceptor = TcpListener::bind(addr).listen();\n-\n-        let _t = thread::spawn(move|| {\n-            let mut acceptor = acceptor;\n-            for stream in acceptor.incoming().take(MAX as usize) {\n-                // Start another task to handle the connection\n-                let _t = thread::spawn(move|| {\n-                    let mut stream = stream;\n-                    let mut buf = [0];\n-                    stream.read(&mut buf).unwrap();\n-                    assert!(buf[0] == 99);\n-                    debug!(\"read\");\n-                });\n-            }\n-        });\n-\n-        connect(0, addr);\n-\n-        fn connect(i: isize, addr: SocketAddr) {\n-            if i == MAX { return }\n-\n-            let _t = thread::spawn(move|| {\n-                debug!(\"connecting\");\n-                let mut stream = TcpStream::connect(addr);\n-                // Connect again before writing\n-                connect(i + 1, addr);\n-                debug!(\"writing\");\n-                stream.write(&[99]).unwrap();\n-            });\n-        }\n-    }\n-\n-    #[test]\n-    fn multiple_connect_interleaved_lazy_schedule_ip6() {\n-        static MAX: isize = 10;\n-        let addr = next_test_ip6();\n-        let acceptor = TcpListener::bind(addr).listen();\n-\n-        let _t = thread::spawn(move|| {\n-            let mut acceptor = acceptor;\n-            for stream in acceptor.incoming().take(MAX as usize) {\n-                // Start another task to handle the connection\n-                let _t = thread::spawn(move|| {\n-                    let mut stream = stream;\n-                    let mut buf = [0];\n-                    stream.read(&mut buf).unwrap();\n-                    assert!(buf[0] == 99);\n-                    debug!(\"read\");\n-                });\n-            }\n-        });\n-\n-        connect(0, addr);\n-\n-        fn connect(i: isize, addr: SocketAddr) {\n-            if i == MAX { return }\n-\n-            let _t = thread::spawn(move|| {\n-                debug!(\"connecting\");\n-                let mut stream = TcpStream::connect(addr);\n-                // Connect again before writing\n-                connect(i + 1, addr);\n-                debug!(\"writing\");\n-                stream.write(&[99]).unwrap();\n-            });\n-        }\n-    }\n-\n-    pub fn socket_name(addr: SocketAddr) {\n-        let mut listener = TcpListener::bind(addr).unwrap();\n-\n-        // Make sure socket_name gives\n-        // us the socket we binded to.\n-        let so_name = listener.socket_name();\n-        assert!(so_name.is_ok());\n-        assert_eq!(addr, so_name.unwrap());\n-    }\n-\n-    pub fn peer_name(addr: SocketAddr) {\n-        let acceptor = TcpListener::bind(addr).listen();\n-        let _t = thread::spawn(move|| {\n-            let mut acceptor = acceptor;\n-            acceptor.accept().unwrap();\n-        });\n-\n-        let stream = TcpStream::connect(addr);\n-\n-        assert!(stream.is_ok());\n-        let mut stream = stream.unwrap();\n-\n-        // Make sure peer_name gives us the\n-        // address/port of the peer we've\n-        // connected to.\n-        let peer_name = stream.peer_name();\n-        assert!(peer_name.is_ok());\n-        assert_eq!(addr, peer_name.unwrap());\n-    }\n-\n-    #[test]\n-    fn socket_and_peer_name_ip4() {\n-        peer_name(next_test_ip4());\n-        socket_name(next_test_ip4());\n-    }\n-\n-    #[test]\n-    fn socket_and_peer_name_ip6() {\n-        // FIXME: peer name is not consistent\n-        //peer_name(next_test_ip6());\n-        socket_name(next_test_ip6());\n-    }\n-\n-    #[test]\n-    fn partial_read() {\n-        let addr = next_test_ip4();\n-        let (tx, rx) = channel();\n-        let _t = thread::spawn(move|| {\n-            let mut srv = TcpListener::bind(addr).listen().unwrap();\n-            tx.send(()).unwrap();\n-            let mut cl = srv.accept().unwrap();\n-            cl.write(&[10]).unwrap();\n-            let mut b = [0];\n-            cl.read(&mut b).unwrap();\n-            tx.send(()).unwrap();\n-        });\n-\n-        rx.recv().unwrap();\n-        let mut c = TcpStream::connect(addr).unwrap();\n-        let mut b = [0; 10];\n-        assert_eq!(c.read(&mut b), Ok(1));\n-        c.write(&[1]).unwrap();\n-        rx.recv().unwrap();\n-    }\n-\n-    #[test]\n-    fn double_bind() {\n-        let addr = next_test_ip4();\n-        let listener = TcpListener::bind(addr).unwrap().listen();\n-        assert!(listener.is_ok());\n-        match TcpListener::bind(addr).listen() {\n-            Ok(..) => panic!(),\n-            Err(e) => {\n-                assert!(e.kind == ConnectionRefused || e.kind == OtherIoError,\n-                        \"unknown error: {} {:?}\", e, e.kind);\n-            }\n-        }\n-    }\n-\n-    #[test]\n-    fn fast_rebind() {\n-        let addr = next_test_ip4();\n-        let (tx, rx) = channel();\n-\n-        let _t = thread::spawn(move|| {\n-            rx.recv().unwrap();\n-            let _stream = TcpStream::connect(addr).unwrap();\n-            // Close\n-            rx.recv().unwrap();\n-        });\n-\n-        {\n-            let mut acceptor = TcpListener::bind(addr).listen();\n-            tx.send(()).unwrap();\n-            {\n-                let _stream = acceptor.accept().unwrap();\n-                // Close client\n-                tx.send(()).unwrap();\n-            }\n-            // Close listener\n-        }\n-        let _listener = TcpListener::bind(addr);\n-    }\n-\n-    #[test]\n-    fn tcp_clone_smoke() {\n-        let addr = next_test_ip4();\n-        let mut acceptor = TcpListener::bind(addr).listen();\n-\n-        let _t = thread::spawn(move|| {\n-            let mut s = TcpStream::connect(addr);\n-            let mut buf = [0, 0];\n-            assert_eq!(s.read(&mut buf), Ok(1));\n-            assert_eq!(buf[0], 1);\n-            s.write(&[2]).unwrap();\n-        });\n-\n-        let mut s1 = acceptor.accept().unwrap();\n-        let s2 = s1.clone();\n-\n-        let (tx1, rx1) = channel();\n-        let (tx2, rx2) = channel();\n-        let _t = thread::spawn(move|| {\n-            let mut s2 = s2;\n-            rx1.recv().unwrap();\n-            s2.write(&[1]).unwrap();\n-            tx2.send(()).unwrap();\n-        });\n-        tx1.send(()).unwrap();\n-        let mut buf = [0, 0];\n-        assert_eq!(s1.read(&mut buf), Ok(1));\n-        rx2.recv().unwrap();\n-    }\n-\n-    #[test]\n-    fn tcp_clone_two_read() {\n-        let addr = next_test_ip6();\n-        let mut acceptor = TcpListener::bind(addr).listen();\n-        let (tx1, rx) = channel();\n-        let tx2 = tx1.clone();\n-\n-        let _t = thread::spawn(move|| {\n-            let mut s = TcpStream::connect(addr);\n-            s.write(&[1]).unwrap();\n-            rx.recv().unwrap();\n-            s.write(&[2]).unwrap();\n-            rx.recv().unwrap();\n-        });\n-\n-        let mut s1 = acceptor.accept().unwrap();\n-        let s2 = s1.clone();\n-\n-        let (done, rx) = channel();\n-        let _t = thread::spawn(move|| {\n-            let mut s2 = s2;\n-            let mut buf = [0, 0];\n-            s2.read(&mut buf).unwrap();\n-            tx2.send(()).unwrap();\n-            done.send(()).unwrap();\n-        });\n-        let mut buf = [0, 0];\n-        s1.read(&mut buf).unwrap();\n-        tx1.send(()).unwrap();\n-\n-        rx.recv().unwrap();\n-    }\n-\n-    #[test]\n-    fn tcp_clone_two_write() {\n-        let addr = next_test_ip4();\n-        let mut acceptor = TcpListener::bind(addr).listen();\n-\n-        let _t = thread::spawn(move|| {\n-            let mut s = TcpStream::connect(addr);\n-            let mut buf = [0, 1];\n-            s.read(&mut buf).unwrap();\n-            s.read(&mut buf).unwrap();\n-        });\n-\n-        let mut s1 = acceptor.accept().unwrap();\n-        let s2 = s1.clone();\n-\n-        let (done, rx) = channel();\n-        let _t = thread::spawn(move|| {\n-            let mut s2 = s2;\n-            s2.write(&[1]).unwrap();\n-            done.send(()).unwrap();\n-        });\n-        s1.write(&[2]).unwrap();\n-\n-        rx.recv().unwrap();\n-    }\n-\n-    #[test]\n-    fn shutdown_smoke() {\n-        let addr = next_test_ip4();\n-        let a = TcpListener::bind(addr).unwrap().listen();\n-        let _t = thread::spawn(move|| {\n-            let mut a = a;\n-            let mut c = a.accept().unwrap();\n-            assert_eq!(c.read_to_end(), Ok(vec!()));\n-            c.write(&[1]).unwrap();\n-        });\n-\n-        let mut s = TcpStream::connect(addr).unwrap();\n-        assert!(s.inner.close_write().is_ok());\n-        assert!(s.write(&[1]).is_err());\n-        assert_eq!(s.read_to_end(), Ok(vec!(1)));\n-    }\n-\n-    #[test]\n-    fn accept_timeout() {\n-        let addr = next_test_ip4();\n-        let mut a = TcpListener::bind(addr).unwrap().listen().unwrap();\n-\n-        a.set_timeout(Some(10));\n-\n-        // Make sure we time out once and future invocations also time out\n-        let err = a.accept().err().unwrap();\n-        assert_eq!(err.kind, TimedOut);\n-        let err = a.accept().err().unwrap();\n-        assert_eq!(err.kind, TimedOut);\n-\n-        // Also make sure that even though the timeout is expired that we will\n-        // continue to receive any pending connections.\n-        //\n-        // FIXME: freebsd apparently never sees the pending connection, but\n-        //        testing manually always works. Need to investigate this\n-        //        flakiness.\n-        if !cfg!(target_os = \"freebsd\") {\n-            let (tx, rx) = channel();\n-            let _t = thread::spawn(move|| {\n-                tx.send(TcpStream::connect(addr).unwrap()).unwrap();\n-            });\n-            let _l = rx.recv().unwrap();\n-            for i in 0..1001 {\n-                match a.accept() {\n-                    Ok(..) => break,\n-                    Err(ref e) if e.kind == TimedOut => {}\n-                    Err(e) => panic!(\"error: {}\", e),\n-                }\n-                ::thread::yield_now();\n-                if i == 1000 { panic!(\"should have a pending connection\") }\n-            }\n-        }\n-\n-        // Unset the timeout and make sure that this always blocks.\n-        a.set_timeout(None);\n-        let _t = thread::spawn(move|| {\n-            drop(TcpStream::connect(addr).unwrap());\n-        });\n-        a.accept().unwrap();\n-    }\n-\n-    #[test]\n-    fn close_readwrite_smoke() {\n-        let addr = next_test_ip4();\n-        let a = TcpListener::bind(addr).listen().unwrap();\n-        let (_tx, rx) = channel::<()>();\n-        thread::spawn(move|| {\n-            let mut a = a;\n-            let _s = a.accept().unwrap();\n-            let _ = rx.recv().unwrap();\n-        });\n-\n-        let mut b = [0];\n-        let mut s = TcpStream::connect(addr).unwrap();\n-        let mut s2 = s.clone();\n-\n-        // closing should prevent reads/writes\n-        s.close_write().unwrap();\n-        assert!(s.write(&[0]).is_err());\n-        s.close_read().unwrap();\n-        assert!(s.read(&mut b).is_err());\n-\n-        // closing should affect previous handles\n-        assert!(s2.write(&[0]).is_err());\n-        assert!(s2.read(&mut b).is_err());\n-\n-        // closing should affect new handles\n-        let mut s3 = s.clone();\n-        assert!(s3.write(&[0]).is_err());\n-        assert!(s3.read(&mut b).is_err());\n-\n-        // make sure these don't die\n-        let _ = s2.close_read();\n-        let _ = s2.close_write();\n-        let _ = s3.close_read();\n-        let _ = s3.close_write();\n-    }\n-\n-    #[test]\n-    fn close_read_wakes_up() {\n-        let addr = next_test_ip4();\n-        let a = TcpListener::bind(addr).listen().unwrap();\n-        let (_tx, rx) = channel::<()>();\n-        thread::spawn(move|| {\n-            let mut a = a;\n-            let _s = a.accept().unwrap();\n-            let _ = rx.recv().unwrap();\n-        });\n-\n-        let mut s = TcpStream::connect(addr).unwrap();\n-        let s2 = s.clone();\n-        let (tx, rx) = channel();\n-        let _t = thread::spawn(move|| {\n-            let mut s2 = s2;\n-            assert!(s2.read(&mut [0]).is_err());\n-            tx.send(()).unwrap();\n-        });\n-        // this should wake up the child task\n-        s.close_read().unwrap();\n-\n-        // this test will never finish if the child doesn't wake up\n-        rx.recv().unwrap();\n-    }\n-\n-    #[test]\n-    fn readwrite_timeouts() {\n-        let addr = next_test_ip6();\n-        let mut a = TcpListener::bind(addr).listen().unwrap();\n-        let (tx, rx) = channel::<()>();\n-        thread::spawn(move|| {\n-            let mut s = TcpStream::connect(addr).unwrap();\n-            rx.recv().unwrap();\n-            assert!(s.write(&[0]).is_ok());\n-            let _ = rx.recv();\n-        });\n-\n-        let mut s = a.accept().unwrap();\n-        s.set_timeout(Some(20));\n-        assert_eq!(s.read(&mut [0]).err().unwrap().kind, TimedOut);\n-        assert_eq!(s.read(&mut [0]).err().unwrap().kind, TimedOut);\n-\n-        s.set_timeout(Some(20));\n-        for i in 0..1001 {\n-            match s.write(&[0; 128 * 1024]) {\n-                Ok(()) | Err(IoError { kind: ShortWrite(..), .. }) => {},\n-                Err(IoError { kind: TimedOut, .. }) => break,\n-                Err(e) => panic!(\"{}\", e),\n-           }\n-           if i == 1000 { panic!(\"should have filled up?!\"); }\n-        }\n-        assert_eq!(s.write(&[0]).err().unwrap().kind, TimedOut);\n-\n-        tx.send(()).unwrap();\n-        s.set_timeout(None);\n-        assert_eq!(s.read(&mut [0, 0]), Ok(1));\n-    }\n-\n-    #[test]\n-    fn read_timeouts() {\n-        let addr = next_test_ip6();\n-        let mut a = TcpListener::bind(addr).listen().unwrap();\n-        let (tx, rx) = channel::<()>();\n-        thread::spawn(move|| {\n-            let mut s = TcpStream::connect(addr).unwrap();\n-            rx.recv().unwrap();\n-            let mut amt = 0;\n-            while amt < 100 * 128 * 1024 {\n-                match s.read(&mut [0;128 * 1024]) {\n-                    Ok(n) => { amt += n; }\n-                    Err(e) => panic!(\"{}\", e),\n-                }\n-            }\n-            let _ = rx.recv();\n-        });\n-\n-        let mut s = a.accept().unwrap();\n-        s.set_read_timeout(Some(20));\n-        assert_eq!(s.read(&mut [0]).err().unwrap().kind, TimedOut);\n-        assert_eq!(s.read(&mut [0]).err().unwrap().kind, TimedOut);\n-\n-        tx.send(()).unwrap();\n-        for _ in 0..100 {\n-            assert!(s.write(&[0;128 * 1024]).is_ok());\n-        }\n-    }\n-\n-    #[test]\n-    fn write_timeouts() {\n-        let addr = next_test_ip6();\n-        let mut a = TcpListener::bind(addr).listen().unwrap();\n-        let (tx, rx) = channel::<()>();\n-        thread::spawn(move|| {\n-            let mut s = TcpStream::connect(addr).unwrap();\n-            rx.recv().unwrap();\n-            assert!(s.write(&[0]).is_ok());\n-            let _ = rx.recv();\n-        });\n-\n-        let mut s = a.accept().unwrap();\n-        s.set_write_timeout(Some(20));\n-        for i in 0..1001 {\n-            match s.write(&[0; 128 * 1024]) {\n-                Ok(()) | Err(IoError { kind: ShortWrite(..), .. }) => {},\n-                Err(IoError { kind: TimedOut, .. }) => break,\n-                Err(e) => panic!(\"{}\", e),\n-           }\n-           if i == 1000 { panic!(\"should have filled up?!\"); }\n-        }\n-        assert_eq!(s.write(&[0]).err().unwrap().kind, TimedOut);\n-\n-        tx.send(()).unwrap();\n-        assert!(s.read(&mut [0]).is_ok());\n-    }\n-\n-    #[test]\n-    fn timeout_concurrent_read() {\n-        let addr = next_test_ip6();\n-        let mut a = TcpListener::bind(addr).listen().unwrap();\n-        let (tx, rx) = channel::<()>();\n-        thread::spawn(move|| {\n-            let mut s = TcpStream::connect(addr).unwrap();\n-            rx.recv().unwrap();\n-            assert_eq!(s.write(&[0]), Ok(()));\n-            let _ = rx.recv();\n-        });\n-\n-        let mut s = a.accept().unwrap();\n-        let s2 = s.clone();\n-        let (tx2, rx2) = channel();\n-        let _t = thread::spawn(move|| {\n-            let mut s2 = s2;\n-            assert_eq!(s2.read(&mut [0]), Ok(1));\n-            tx2.send(()).unwrap();\n-        });\n-\n-        s.set_read_timeout(Some(20));\n-        assert_eq!(s.read(&mut [0]).err().unwrap().kind, TimedOut);\n-        tx.send(()).unwrap();\n-\n-        rx2.recv().unwrap();\n-    }\n-\n-    #[test]\n-    fn clone_while_reading() {\n-        let addr = next_test_ip6();\n-        let listen = TcpListener::bind(addr);\n-        let mut accept = listen.listen().unwrap();\n-\n-        // Enqueue a task to write to a socket\n-        let (tx, rx) = channel();\n-        let (txdone, rxdone) = channel();\n-        let txdone2 = txdone.clone();\n-        let _t = thread::spawn(move|| {\n-            let mut tcp = TcpStream::connect(addr).unwrap();\n-            rx.recv().unwrap();\n-            tcp.write_u8(0).unwrap();\n-            txdone2.send(()).unwrap();\n-        });\n-\n-        // Spawn off a reading clone\n-        let tcp = accept.accept().unwrap();\n-        let tcp2 = tcp.clone();\n-        let txdone3 = txdone.clone();\n-        let _t = thread::spawn(move|| {\n-            let mut tcp2 = tcp2;\n-            tcp2.read_u8().unwrap();\n-            txdone3.send(()).unwrap();\n-        });\n-\n-        // Try to ensure that the reading clone is indeed reading\n-        for _ in 0..50 {\n-            ::thread::yield_now();\n-        }\n-\n-        // clone the handle again while it's reading, then let it finish the\n-        // read.\n-        let _ = tcp.clone();\n-        tx.send(()).unwrap();\n-        rxdone.recv().unwrap();\n-        rxdone.recv().unwrap();\n-    }\n-\n-    #[test]\n-    fn clone_accept_smoke() {\n-        let addr = next_test_ip4();\n-        let l = TcpListener::bind(addr);\n-        let mut a = l.listen().unwrap();\n-        let mut a2 = a.clone();\n-\n-        let _t = thread::spawn(move|| {\n-            let _ = TcpStream::connect(addr);\n-        });\n-        let _t = thread::spawn(move|| {\n-            let _ = TcpStream::connect(addr);\n-        });\n-\n-        assert!(a.accept().is_ok());\n-        assert!(a2.accept().is_ok());\n-    }\n-\n-    #[test]\n-    fn clone_accept_concurrent() {\n-        let addr = next_test_ip4();\n-        let l = TcpListener::bind(addr);\n-        let a = l.listen().unwrap();\n-        let a2 = a.clone();\n-\n-        let (tx, rx) = channel();\n-        let tx2 = tx.clone();\n-\n-        let _t = thread::spawn(move|| {\n-            let mut a = a;\n-            tx.send(a.accept()).unwrap();\n-        });\n-        let _t = thread::spawn(move|| {\n-            let mut a = a2;\n-            tx2.send(a.accept()).unwrap();\n-        });\n-\n-        let _t = thread::spawn(move|| {\n-            let _ = TcpStream::connect(addr);\n-        });\n-        let _t = thread::spawn(move|| {\n-            let _ = TcpStream::connect(addr);\n-        });\n-\n-        assert!(rx.recv().unwrap().is_ok());\n-        assert!(rx.recv().unwrap().is_ok());\n-    }\n-\n-    #[test]\n-    fn close_accept_smoke() {\n-        let addr = next_test_ip4();\n-        let l = TcpListener::bind(addr);\n-        let mut a = l.listen().unwrap();\n-\n-        a.close_accept().unwrap();\n-        assert_eq!(a.accept().err().unwrap().kind, EndOfFile);\n-    }\n-\n-    #[test]\n-    fn close_accept_concurrent() {\n-        let addr = next_test_ip4();\n-        let l = TcpListener::bind(addr);\n-        let a = l.listen().unwrap();\n-        let mut a2 = a.clone();\n-\n-        let (tx, rx) = channel();\n-        let _t = thread::spawn(move|| {\n-            let mut a = a;\n-            tx.send(a.accept()).unwrap();\n-        });\n-        a2.close_accept().unwrap();\n-\n-        assert_eq!(rx.recv().unwrap().err().unwrap().kind, EndOfFile);\n-    }\n-}"}, {"sha": "196447d71efbf8ff598cf6fa4bb564365aa790b1", "filename": "src/libstd/old_io/net/udp.rs", "status": "removed", "additions": 0, "deletions": 459, "changes": 459, "blob_url": "https://github.com/rust-lang/rust/blob/8415fa27877a4309a79b08c75a52eb4c3546b7a5/src%2Flibstd%2Fold_io%2Fnet%2Fudp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8415fa27877a4309a79b08c75a52eb4c3546b7a5/src%2Flibstd%2Fold_io%2Fnet%2Fudp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fnet%2Fudp.rs?ref=8415fa27877a4309a79b08c75a52eb4c3546b7a5", "patch": "@@ -1,459 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! UDP (User Datagram Protocol) network connections.\n-//!\n-//! This module contains the ability to open a UDP stream to a socket address.\n-//! The destination and binding addresses can either be an IPv4 or IPv6\n-//! address. There is no corresponding notion of a server because UDP is a\n-//! datagram protocol.\n-\n-use clone::Clone;\n-use old_io::net::ip::{SocketAddr, IpAddr, ToSocketAddr};\n-use old_io::IoResult;\n-use option::Option;\n-use sys::udp::UdpSocket as UdpSocketImp;\n-use sys_common;\n-\n-/// A User Datagram Protocol socket.\n-///\n-/// This is an implementation of a bound UDP socket. This supports both IPv4 and\n-/// IPv6 addresses, and there is no corresponding notion of a server because UDP\n-/// is a datagram protocol.\n-///\n-/// # Examples\n-///\n-/// ```rust,no_run\n-/// # #![feature(old_io)]\n-/// # #![allow(unused_must_use)]\n-///\n-/// use std::old_io::net::udp::UdpSocket;\n-/// use std::old_io::net::ip::{Ipv4Addr, SocketAddr};\n-/// fn main() {\n-///     let addr = SocketAddr { ip: Ipv4Addr(127, 0, 0, 1), port: 34254 };\n-///     let mut socket = match UdpSocket::bind(addr) {\n-///         Ok(s) => s,\n-///         Err(e) => panic!(\"couldn't bind socket: {}\", e),\n-///     };\n-///\n-///     let mut buf = [0; 10];\n-///     match socket.recv_from(&mut buf) {\n-///         Ok((amt, src)) => {\n-///             // Send a reply to the socket we received data from\n-///             let buf = &mut buf[..amt];\n-///             buf.reverse();\n-///             socket.send_to(buf, src);\n-///         }\n-///         Err(e) => println!(\"couldn't receive a datagram: {}\", e)\n-///     }\n-///     drop(socket); // close the socket\n-/// }\n-/// ```\n-pub struct UdpSocket {\n-    inner: UdpSocketImp,\n-}\n-\n-impl UdpSocket {\n-    /// Creates a UDP socket from the given address.\n-    ///\n-    /// Address type can be any implementor of `ToSocketAddr` trait. See its\n-    /// documentation for concrete examples.\n-    pub fn bind<A: ToSocketAddr>(addr: A) -> IoResult<UdpSocket> {\n-        super::with_addresses(addr, |addr| {\n-            UdpSocketImp::bind(addr).map(|s| UdpSocket { inner: s })\n-        })\n-    }\n-\n-    /// Receives data from the socket. On success, returns the number of bytes\n-    /// read and the address from whence the data came.\n-    pub fn recv_from(&mut self, buf: &mut [u8]) -> IoResult<(usize, SocketAddr)> {\n-        self.inner.recv_from(buf)\n-    }\n-\n-    /// Sends data on the socket to the given address. Returns nothing on\n-    /// success.\n-    ///\n-    /// Address type can be any implementer of `ToSocketAddr` trait. See its\n-    /// documentation for concrete examples.\n-    pub fn send_to<A: ToSocketAddr>(&mut self, buf: &[u8], addr: A) -> IoResult<()> {\n-        super::with_addresses(addr, |addr| self.inner.send_to(buf, addr))\n-    }\n-\n-    /// Returns the socket address that this socket was created from.\n-    pub fn socket_name(&mut self) -> IoResult<SocketAddr> {\n-        self.inner.socket_name()\n-    }\n-\n-    /// Joins a multicast IP address (becomes a member of it)\n-    #[unstable(feature = \"io\")]\n-    pub fn join_multicast(&mut self, multi: IpAddr) -> IoResult<()> {\n-        self.inner.join_multicast(multi)\n-    }\n-\n-    /// Leaves a multicast IP address (drops membership from it)\n-    #[unstable(feature = \"io\")]\n-    pub fn leave_multicast(&mut self, multi: IpAddr) -> IoResult<()> {\n-        self.inner.leave_multicast(multi)\n-    }\n-\n-    /// Set the multicast loop flag to the specified value\n-    ///\n-    /// This lets multicast packets loop back to local sockets (if enabled)\n-    #[unstable(feature = \"io\")]\n-    pub fn set_multicast_loop(&mut self, on: bool) -> IoResult<()> {\n-        self.inner.set_multicast_loop(on)\n-    }\n-\n-    /// Sets the multicast TTL\n-    #[unstable(feature = \"io\")]\n-    pub fn set_multicast_ttl(&mut self, ttl: isize) -> IoResult<()> {\n-        self.inner.multicast_time_to_live(ttl)\n-    }\n-\n-    /// Sets this socket's TTL\n-    #[unstable(feature = \"io\")]\n-    pub fn set_ttl(&mut self, ttl: isize) -> IoResult<()> {\n-        self.inner.time_to_live(ttl)\n-    }\n-\n-    /// Sets the broadcast flag on or off\n-    #[unstable(feature = \"io\")]\n-    pub fn set_broadcast(&mut self, broadcast: bool) -> IoResult<()> {\n-        self.inner.set_broadcast(broadcast)\n-    }\n-\n-    /// Sets the read/write timeout for this socket.\n-    ///\n-    /// For more information, see `TcpStream::set_timeout`\n-    #[unstable(feature = \"io\",\n-               reason = \"the timeout argument may change in type and value\")]\n-    pub fn set_timeout(&mut self, timeout_ms: Option<u64>) {\n-        self.inner.set_timeout(timeout_ms)\n-    }\n-\n-    /// Sets the read timeout for this socket.\n-    ///\n-    /// For more information, see `TcpStream::set_timeout`\n-    #[unstable(feature = \"io\",\n-               reason = \"the timeout argument may change in type and value\")]\n-    pub fn set_read_timeout(&mut self, timeout_ms: Option<u64>) {\n-        self.inner.set_read_timeout(timeout_ms)\n-    }\n-\n-    /// Sets the write timeout for this socket.\n-    ///\n-    /// For more information, see `TcpStream::set_timeout`\n-    #[unstable(feature = \"io\",\n-               reason = \"the timeout argument may change in type and value\")]\n-    pub fn set_write_timeout(&mut self, timeout_ms: Option<u64>) {\n-        self.inner.set_write_timeout(timeout_ms)\n-    }\n-}\n-\n-impl Clone for UdpSocket {\n-    /// Creates a new handle to this UDP socket, allowing for simultaneous\n-    /// reads and writes of the socket.\n-    ///\n-    /// The underlying UDP socket will not be closed until all handles to the\n-    /// socket have been deallocated. Two concurrent reads will not receive\n-    /// the same data. Instead, the first read will receive the first packet\n-    /// received, and the second read will receive the second packet.\n-    fn clone(&self) -> UdpSocket {\n-        UdpSocket {\n-            inner: self.inner.clone(),\n-        }\n-    }\n-}\n-\n-impl sys_common::AsInner<UdpSocketImp> for UdpSocket {\n-    fn as_inner(&self) -> &UdpSocketImp {\n-        &self.inner\n-    }\n-}\n-\n-#[cfg(test)]\n-mod test {\n-    use prelude::v1::*;\n-\n-    use sync::mpsc::channel;\n-    use old_io::net::ip::*;\n-    use old_io::test::*;\n-    use old_io::{IoError, TimedOut, PermissionDenied, ShortWrite};\n-    use super::*;\n-    use thread;\n-\n-    // FIXME #11530 this fails on android because tests are run as root\n-    #[cfg_attr(any(windows, target_os = \"android\"), ignore)]\n-    #[test]\n-    fn bind_error() {\n-        let addr = SocketAddr { ip: Ipv4Addr(0, 0, 0, 0), port: 1 };\n-        match UdpSocket::bind(addr) {\n-            Ok(..) => panic!(),\n-            Err(e) => assert_eq!(e.kind, PermissionDenied),\n-        }\n-    }\n-\n-    #[test]\n-    fn socket_smoke_test_ip4() {\n-        let server_ip = next_test_ip4();\n-        let client_ip = next_test_ip4();\n-        let (tx1, rx1) = channel();\n-        let (tx2, rx2) = channel();\n-\n-        let _t = thread::spawn(move|| {\n-            match UdpSocket::bind(client_ip) {\n-                Ok(ref mut client) => {\n-                    rx1.recv().unwrap();\n-                    client.send_to(&[99], server_ip).unwrap()\n-                }\n-                Err(..) => panic!()\n-            }\n-            tx2.send(()).unwrap();\n-        });\n-\n-        match UdpSocket::bind(server_ip) {\n-            Ok(ref mut server) => {\n-                tx1.send(()).unwrap();\n-                let mut buf = [0];\n-                match server.recv_from(&mut buf) {\n-                    Ok((nread, src)) => {\n-                        assert_eq!(nread, 1);\n-                        assert_eq!(buf[0], 99);\n-                        assert_eq!(src, client_ip);\n-                    }\n-                    Err(..) => panic!()\n-                }\n-            }\n-            Err(..) => panic!()\n-        }\n-        rx2.recv().unwrap();\n-    }\n-\n-    #[test]\n-    fn socket_smoke_test_ip6() {\n-        let server_ip = next_test_ip6();\n-        let client_ip = next_test_ip6();\n-        let (tx, rx) = channel::<()>();\n-\n-        let _t = thread::spawn(move|| {\n-            match UdpSocket::bind(client_ip) {\n-                Ok(ref mut client) => {\n-                    rx.recv().unwrap();\n-                    client.send_to(&[99], server_ip).unwrap()\n-                }\n-                Err(..) => panic!()\n-            }\n-        });\n-\n-        match UdpSocket::bind(server_ip) {\n-            Ok(ref mut server) => {\n-                tx.send(()).unwrap();\n-                let mut buf = [0];\n-                match server.recv_from(&mut buf) {\n-                    Ok((nread, src)) => {\n-                        assert_eq!(nread, 1);\n-                        assert_eq!(buf[0], 99);\n-                        assert_eq!(src, client_ip);\n-                    }\n-                    Err(..) => panic!()\n-                }\n-            }\n-            Err(..) => panic!()\n-        }\n-    }\n-\n-    pub fn socket_name(addr: SocketAddr) {\n-        let server = UdpSocket::bind(addr);\n-\n-        assert!(server.is_ok());\n-        let mut server = server.unwrap();\n-\n-        // Make sure socket_name gives\n-        // us the socket we binded to.\n-        let so_name = server.socket_name();\n-        assert!(so_name.is_ok());\n-        assert_eq!(addr, so_name.unwrap());\n-    }\n-\n-    #[test]\n-    fn socket_name_ip4() {\n-        socket_name(next_test_ip4());\n-    }\n-\n-    #[test]\n-    fn socket_name_ip6() {\n-        socket_name(next_test_ip6());\n-    }\n-\n-    #[test]\n-    fn udp_clone_smoke() {\n-        let addr1 = next_test_ip4();\n-        let addr2 = next_test_ip4();\n-        let mut sock1 = UdpSocket::bind(addr1).unwrap();\n-        let sock2 = UdpSocket::bind(addr2).unwrap();\n-\n-        let _t = thread::spawn(move|| {\n-            let mut sock2 = sock2;\n-            let mut buf = [0, 0];\n-            assert_eq!(sock2.recv_from(&mut buf), Ok((1, addr1)));\n-            assert_eq!(buf[0], 1);\n-            sock2.send_to(&[2], addr1).unwrap();\n-        });\n-\n-        let sock3 = sock1.clone();\n-\n-        let (tx1, rx1) = channel();\n-        let (tx2, rx2) = channel();\n-        let _t = thread::spawn(move|| {\n-            let mut sock3 = sock3;\n-            rx1.recv().unwrap();\n-            sock3.send_to(&[1], addr2).unwrap();\n-            tx2.send(()).unwrap();\n-        });\n-        tx1.send(()).unwrap();\n-        let mut buf = [0, 0];\n-        assert_eq!(sock1.recv_from(&mut buf), Ok((1, addr2)));\n-        rx2.recv().unwrap();\n-    }\n-\n-    #[test]\n-    fn udp_clone_two_read() {\n-        let addr1 = next_test_ip4();\n-        let addr2 = next_test_ip4();\n-        let mut sock1 = UdpSocket::bind(addr1).unwrap();\n-        let sock2 = UdpSocket::bind(addr2).unwrap();\n-        let (tx1, rx) = channel();\n-        let tx2 = tx1.clone();\n-\n-        let _t = thread::spawn(move|| {\n-            let mut sock2 = sock2;\n-            sock2.send_to(&[1], addr1).unwrap();\n-            rx.recv().unwrap();\n-            sock2.send_to(&[2], addr1).unwrap();\n-            rx.recv().unwrap();\n-        });\n-\n-        let sock3 = sock1.clone();\n-\n-        let (done, rx) = channel();\n-        let _t = thread::spawn(move|| {\n-            let mut sock3 = sock3;\n-            let mut buf = [0, 0];\n-            sock3.recv_from(&mut buf).unwrap();\n-            tx2.send(()).unwrap();\n-            done.send(()).unwrap();\n-        });\n-        let mut buf = [0, 0];\n-        sock1.recv_from(&mut buf).unwrap();\n-        tx1.send(()).unwrap();\n-\n-        rx.recv().unwrap();\n-    }\n-\n-    #[test]\n-    fn udp_clone_two_write() {\n-        let addr1 = next_test_ip4();\n-        let addr2 = next_test_ip4();\n-        let mut sock1 = UdpSocket::bind(addr1).unwrap();\n-        let sock2 = UdpSocket::bind(addr2).unwrap();\n-\n-        let (tx, rx) = channel();\n-        let (serv_tx, serv_rx) = channel();\n-\n-        let _t = thread::spawn(move|| {\n-            let mut sock2 = sock2;\n-            let mut buf = [0, 1];\n-\n-            rx.recv().unwrap();\n-            match sock2.recv_from(&mut buf) {\n-                Ok(..) => {}\n-                Err(e) => panic!(\"failed receive: {}\", e),\n-            }\n-            serv_tx.send(()).unwrap();\n-        });\n-\n-        let sock3 = sock1.clone();\n-\n-        let (done, rx) = channel();\n-        let tx2 = tx.clone();\n-        let _t = thread::spawn(move|| {\n-            let mut sock3 = sock3;\n-            match sock3.send_to(&[1], addr2) {\n-                Ok(..) => { let _ = tx2.send(()); }\n-                Err(..) => {}\n-            }\n-            done.send(()).unwrap();\n-        });\n-        match sock1.send_to(&[2], addr2) {\n-            Ok(..) => { let _ = tx.send(()); }\n-            Err(..) => {}\n-        }\n-        drop(tx);\n-\n-        rx.recv().unwrap();\n-        serv_rx.recv().unwrap();\n-    }\n-\n-    #[cfg(not(windows))] // FIXME #17553\n-    #[test]\n-    fn recv_from_timeout() {\n-        let addr1 = next_test_ip4();\n-        let addr2 = next_test_ip4();\n-        let mut a = UdpSocket::bind(addr1).unwrap();\n-        let a2 = UdpSocket::bind(addr2).unwrap();\n-\n-        let (tx, rx) = channel();\n-        let (tx2, rx2) = channel();\n-        let _t = thread::spawn(move|| {\n-            let mut a = a2;\n-            assert_eq!(a.recv_from(&mut [0]), Ok((1, addr1)));\n-            assert_eq!(a.send_to(&[0], addr1), Ok(()));\n-            rx.recv().unwrap();\n-            assert_eq!(a.send_to(&[0], addr1), Ok(()));\n-\n-            tx2.send(()).unwrap();\n-        });\n-\n-        // Make sure that reads time out, but writes can continue\n-        a.set_read_timeout(Some(20));\n-        assert_eq!(a.recv_from(&mut [0]).err().unwrap().kind, TimedOut);\n-        assert_eq!(a.recv_from(&mut [0]).err().unwrap().kind, TimedOut);\n-        assert_eq!(a.send_to(&[0], addr2), Ok(()));\n-\n-        // Cloned handles should be able to block\n-        let mut a2 = a.clone();\n-        assert_eq!(a2.recv_from(&mut [0]), Ok((1, addr2)));\n-\n-        // Clearing the timeout should allow for receiving\n-        a.set_timeout(None);\n-        tx.send(()).unwrap();\n-        assert_eq!(a2.recv_from(&mut [0]), Ok((1, addr2)));\n-\n-        // Make sure the child didn't die\n-        rx2.recv().unwrap();\n-    }\n-\n-    #[test]\n-    fn send_to_timeout() {\n-        let addr1 = next_test_ip4();\n-        let addr2 = next_test_ip4();\n-        let mut a = UdpSocket::bind(addr1).unwrap();\n-        let _b = UdpSocket::bind(addr2).unwrap();\n-\n-        a.set_write_timeout(Some(1000));\n-        for _ in 0..100 {\n-            match a.send_to(&[0;4*1024], addr2) {\n-                Ok(()) | Err(IoError { kind: ShortWrite(..), .. }) => {},\n-                Err(IoError { kind: TimedOut, .. }) => break,\n-                Err(e) => panic!(\"other error: {}\", e),\n-            }\n-        }\n-    }\n-}"}, {"sha": "fd1df49473e586d4bd6c40b8a497bf1a1937d963", "filename": "src/libstd/old_io/pipe.rs", "status": "removed", "additions": 0, "deletions": 141, "changes": 141, "blob_url": "https://github.com/rust-lang/rust/blob/8415fa27877a4309a79b08c75a52eb4c3546b7a5/src%2Flibstd%2Fold_io%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8415fa27877a4309a79b08c75a52eb4c3546b7a5/src%2Flibstd%2Fold_io%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fpipe.rs?ref=8415fa27877a4309a79b08c75a52eb4c3546b7a5", "patch": "@@ -1,141 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Synchronous, in-memory pipes.\n-//!\n-//! Currently these aren't particularly useful, there only exists bindings\n-//! enough so that pipes can be created to child processes.\n-\n-#![allow(missing_docs)]\n-\n-use prelude::v1::*;\n-\n-use old_io::{IoResult, Reader, Writer};\n-use libc;\n-use sync::Arc;\n-\n-use sys_common;\n-use sys;\n-use sys::fs::FileDesc as FileDesc;\n-\n-/// A synchronous, in-memory pipe.\n-pub struct PipeStream {\n-    inner: Arc<FileDesc>\n-}\n-\n-pub struct PipePair {\n-    pub reader: PipeStream,\n-    pub writer: PipeStream,\n-}\n-\n-impl PipeStream {\n-    /// Consumes a file descriptor to return a pipe stream that will have\n-    /// synchronous, but non-blocking reads/writes. This is useful if the file\n-    /// descriptor is acquired via means other than the standard methods.\n-    ///\n-    /// This operation consumes ownership of the file descriptor and it will be\n-    /// closed once the object is deallocated.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```{rust,no_run}\n-    /// # #![feature(old_io, libc, io)]\n-    /// # #![allow(unused_must_use)]\n-    /// extern crate libc;\n-    ///\n-    /// use std::old_io::*;\n-    ///\n-    /// fn main() {\n-    ///     let mut pipe = PipeStream::open(libc::STDERR_FILENO);\n-    ///     pipe.write(b\"Hello, stderr!\");\n-    /// }\n-    /// ```\n-    pub fn open(fd: libc::c_int) -> IoResult<PipeStream> {\n-        Ok(PipeStream::from_filedesc(FileDesc::new(fd, true)))\n-    }\n-\n-    // FIXME: expose this some other way\n-    /// Wrap a FileDesc directly, taking ownership.\n-    #[doc(hidden)]\n-    pub fn from_filedesc(fd: FileDesc) -> PipeStream {\n-        PipeStream { inner: Arc::new(fd) }\n-    }\n-\n-    /// Creates a pair of in-memory OS pipes for a unidirectional communication\n-    /// stream.\n-    ///\n-    /// The structure returned contains a reader and writer I/O object. Data\n-    /// written to the writer can be read from the reader.\n-    ///\n-    /// # Errors\n-    ///\n-    /// This function can fail to succeed if the underlying OS has run out of\n-    /// available resources to allocate a new pipe.\n-    pub fn pair() -> IoResult<PipePair> {\n-        let (reader, writer) = try!(unsafe { sys::os::pipe() });\n-        Ok(PipePair {\n-            reader: PipeStream::from_filedesc(reader),\n-            writer: PipeStream::from_filedesc(writer),\n-        })\n-    }\n-}\n-\n-impl sys_common::AsInner<sys::fs::FileDesc> for PipeStream {\n-    fn as_inner(&self) -> &sys::fs::FileDesc {\n-        &*self.inner\n-    }\n-}\n-\n-impl Clone for PipeStream {\n-    fn clone(&self) -> PipeStream {\n-        PipeStream { inner: self.inner.clone() }\n-    }\n-}\n-\n-impl Reader for PipeStream {\n-    fn read(&mut self, buf: &mut [u8]) -> IoResult<usize> {\n-        self.inner.read(buf)\n-    }\n-}\n-\n-impl Writer for PipeStream {\n-    fn write_all(&mut self, buf: &[u8]) -> IoResult<()> {\n-        self.inner.write(buf)\n-    }\n-}\n-\n-#[cfg(test)]\n-mod test {\n-    use prelude::v1::*;\n-\n-    use old_io::{Writer, Reader};\n-    use sync::mpsc::channel;\n-    use thread;\n-\n-    #[test]\n-    fn partial_read() {\n-        use os;\n-        use old_io::pipe::PipeStream;\n-\n-        let (reader, writer) = unsafe { ::sys::os::pipe().unwrap() };\n-        let out = PipeStream::open(writer.unwrap());\n-        let mut input = PipeStream::open(reader.unwrap());\n-        let (tx, rx) = channel();\n-        let _t = thread::spawn(move|| {\n-            let mut out = out;\n-            out.write(&[10]).unwrap();\n-            rx.recv().unwrap(); // don't close the pipe until the other read has finished\n-        });\n-\n-        let mut buf = [0; 10];\n-        input.read(&mut buf).unwrap();\n-        tx.send(()).unwrap();\n-    }\n-}"}, {"sha": "b55d1f4db07f78e6e5c57480c557d4192828dca1", "filename": "src/libstd/old_io/process.rs", "status": "removed", "additions": 0, "deletions": 1239, "changes": 1239, "blob_url": "https://github.com/rust-lang/rust/blob/8415fa27877a4309a79b08c75a52eb4c3546b7a5/src%2Flibstd%2Fold_io%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8415fa27877a4309a79b08c75a52eb4c3546b7a5/src%2Flibstd%2Fold_io%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fprocess.rs?ref=8415fa27877a4309a79b08c75a52eb4c3546b7a5", "patch": "@@ -1,1239 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Bindings for executing child processes\n-\n-#![allow(non_upper_case_globals)]\n-#![unstable(feature = \"old_io\")]\n-#![deprecated(since = \"1.0.0\",\n-              reason = \"replaced with the std::process module\")]\n-\n-pub use self::StdioContainer::*;\n-pub use self::ProcessExit::*;\n-\n-use prelude::v1::*;\n-\n-use collections::HashMap;\n-use ffi::CString;\n-use fmt;\n-use old_io::pipe::{PipeStream, PipePair};\n-use old_io::{IoResult, IoError, Reader, Writer};\n-use old_io;\n-use old_path::{Path, GenericPath};\n-use libc;\n-use os;\n-use old_path::BytesContainer;\n-use sync::mpsc::{channel, Receiver};\n-use sys::fs::FileDesc;\n-use sys::process::Process as ProcessImp;\n-use sys;\n-use thread;\n-\n-#[cfg(windows)] use hash;\n-#[cfg(windows)] use str;\n-\n-/// Signal a process to exit, without forcibly killing it. Corresponds to\n-/// SIGTERM on unix platforms.\n-#[cfg(windows)] pub const PleaseExitSignal: isize = 15;\n-/// Signal a process to exit immediately, forcibly killing it. Corresponds to\n-/// SIGKILL on unix platforms.\n-#[cfg(windows)] pub const MustDieSignal: isize = 9;\n-/// Signal a process to exit, without forcibly killing it. Corresponds to\n-/// SIGTERM on unix platforms.\n-#[cfg(not(windows))] pub const PleaseExitSignal: isize = libc::SIGTERM as isize;\n-/// Signal a process to exit immediately, forcibly killing it. Corresponds to\n-/// SIGKILL on unix platforms.\n-#[cfg(not(windows))] pub const MustDieSignal: isize = libc::SIGKILL as isize;\n-\n-/// Representation of a running or exited child process.\n-///\n-/// This structure is used to represent and manage child processes. A child\n-/// process is created via the `Command` struct, which configures the spawning\n-/// process and can itself be constructed using a builder-style interface.\n-///\n-/// # Examples\n-///\n-/// ```should_panic\n-/// # #![feature(old_io)]\n-/// use std::old_io::*;\n-///\n-/// let mut child = match Command::new(\"/bin/cat\").arg(\"file.txt\").spawn() {\n-///     Ok(child) => child,\n-///     Err(e) => panic!(\"failed to execute child: {}\", e),\n-/// };\n-///\n-/// let contents = child.stdout.as_mut().unwrap().read_to_end();\n-/// assert!(child.wait().unwrap().success());\n-/// ```\n-pub struct Process {\n-    handle: ProcessImp,\n-    forget: bool,\n-\n-    /// None until wait() is called.\n-    exit_code: Option<ProcessExit>,\n-\n-    /// Manually delivered signal\n-    exit_signal: Option<isize>,\n-\n-    /// Deadline after which wait() will return\n-    deadline: u64,\n-\n-    /// Handle to the child's stdin, if the `stdin` field of this process's\n-    /// `ProcessConfig` was `CreatePipe`. By default, this handle is `Some`.\n-    pub stdin: Option<PipeStream>,\n-\n-    /// Handle to the child's stdout, if the `stdout` field of this process's\n-    /// `ProcessConfig` was `CreatePipe`. By default, this handle is `Some`.\n-    pub stdout: Option<PipeStream>,\n-\n-    /// Handle to the child's stderr, if the `stderr` field of this process's\n-    /// `ProcessConfig` was `CreatePipe`. By default, this handle is `Some`.\n-    pub stderr: Option<PipeStream>,\n-}\n-\n-/// A representation of environment variable name\n-/// It compares case-insensitive on Windows and case-sensitive everywhere else.\n-#[cfg(not(windows))]\n-#[derive(Hash, PartialEq, Eq, Clone, Debug)]\n-struct EnvKey(CString);\n-\n-#[doc(hidden)]\n-#[cfg(windows)]\n-#[derive(Eq, Clone, Debug)]\n-struct EnvKey(CString);\n-\n-#[cfg(windows)]\n-impl hash::Hash for EnvKey {\n-    fn hash<H: hash::Hasher>(&self, state: &mut H) {\n-        use ascii::AsciiExt;\n-        let &EnvKey(ref x) = self;\n-        match str::from_utf8(x.as_bytes()) {\n-            Ok(s) => for ch in s.chars() {\n-                ch.to_ascii_lowercase().hash(state);\n-            },\n-            Err(..) => x.hash(state)\n-        }\n-    }\n-}\n-\n-#[cfg(windows)]\n-impl PartialEq for EnvKey {\n-    fn eq(&self, other: &EnvKey) -> bool {\n-        use ascii::AsciiExt;\n-        let &EnvKey(ref x) = self;\n-        let &EnvKey(ref y) = other;\n-        match (str::from_utf8(x.as_bytes()), str::from_utf8(y.as_bytes())) {\n-            (Ok(xs), Ok(ys)) => {\n-                if xs.len() != ys.len() {\n-                    return false\n-                } else {\n-                    for (xch, ych) in xs.chars().zip(ys.chars()) {\n-                        if xch.to_ascii_lowercase() != ych.to_ascii_lowercase() {\n-                            return false;\n-                        }\n-                    }\n-                    return true;\n-                }\n-            },\n-            // If either is not a valid utf8 string, just compare them byte-wise\n-            _ => return x.eq(y)\n-        }\n-    }\n-}\n-\n-impl BytesContainer for EnvKey {\n-    fn container_as_bytes<'a>(&'a self) -> &'a [u8] {\n-        let &EnvKey(ref k) = self;\n-        k.container_as_bytes()\n-    }\n-}\n-\n-/// A HashMap representation of environment variables.\n-pub type EnvMap = HashMap<EnvKey, CString>;\n-\n-/// The `Command` type acts as a process builder, providing fine-grained control\n-/// over how a new process should be spawned. A default configuration can be\n-/// generated using `Command::new(program)`, where `program` gives a path to the\n-/// program to be executed. Additional builder methods allow the configuration\n-/// to be changed (for example, by adding arguments) prior to spawning:\n-///\n-/// ```\n-/// # #![feature(old_io)]\n-/// use std::old_io::*;\n-///\n-/// let mut process = match Command::new(\"sh\").arg(\"-c\").arg(\"echo hello\").spawn() {\n-///   Ok(p) => p,\n-///   Err(e) => panic!(\"failed to execute process: {}\", e),\n-/// };\n-///\n-/// let output = process.stdout.as_mut().unwrap().read_to_end();\n-/// ```\n-#[derive(Clone)]\n-pub struct Command {\n-    // The internal data for the builder. Documented by the builder\n-    // methods below, and serialized into rt::rtio::ProcessConfig.\n-    program: CString,\n-    args: Vec<CString>,\n-    env: Option<EnvMap>,\n-    cwd: Option<CString>,\n-    stdin: StdioContainer,\n-    stdout: StdioContainer,\n-    stderr: StdioContainer,\n-    uid: Option<usize>,\n-    gid: Option<usize>,\n-    detach: bool,\n-}\n-\n-// FIXME (#12938): Until DST lands, we cannot decompose &str into & and str, so\n-// we cannot usefully take BytesContainer arguments by reference (without forcing an\n-// additional & around &str). So we are instead temporarily adding an instance\n-// for &Path, so that we can take BytesContainer as owned. When DST lands, the &Path\n-// instance should be removed, and arguments bound by BytesContainer should be passed by\n-// reference. (Here: {new, arg, args, env}.)\n-\n-impl Command {\n-    /// Constructs a new `Command` for launching the program at\n-    /// path `program`, with the following default configuration:\n-    ///\n-    /// * No arguments to the program\n-    /// * Inherit the current process's environment\n-    /// * Inherit the current process's working directory\n-    /// * A readable pipe for stdin (file descriptor 0)\n-    /// * A writeable pipe for stdout and stderr (file descriptors 1 and 2)\n-    ///\n-    /// Builder methods are provided to change these defaults and\n-    /// otherwise configure the process.\n-    pub fn new<T: BytesContainer>(program: T) -> Command {\n-        Command {\n-            program: CString::new(program.container_as_bytes()).unwrap(),\n-            args: Vec::new(),\n-            env: None,\n-            cwd: None,\n-            stdin: CreatePipe(true, false),\n-            stdout: CreatePipe(false, true),\n-            stderr: CreatePipe(false, true),\n-            uid: None,\n-            gid: None,\n-            detach: false,\n-        }\n-    }\n-\n-    /// Add an argument to pass to the program.\n-    pub fn arg<'a, T: BytesContainer>(&'a mut self, arg: T) -> &'a mut Command {\n-        self.args.push(CString::new(arg.container_as_bytes()).unwrap());\n-        self\n-    }\n-\n-    /// Add multiple arguments to pass to the program.\n-    pub fn args<'a, T: BytesContainer>(&'a mut self, args: &[T]) -> &'a mut Command {\n-        self.args.extend(args.iter().map(|arg| {\n-            CString::new(arg.container_as_bytes()).unwrap()\n-        }));\n-        self\n-    }\n-    // Get a mutable borrow of the environment variable map for this `Command`.\n-    #[allow(deprecated)]\n-    fn get_env_map<'a>(&'a mut self) -> &'a mut EnvMap {\n-        match self.env {\n-            Some(ref mut map) => map,\n-            None => {\n-                // if the env is currently just inheriting from the parent's,\n-                // materialize the parent's env into a hashtable.\n-                self.env = Some(::env::vars().map(|(k, v)| {\n-                    (EnvKey(CString::new(k).unwrap()),\n-                     CString::new(v).unwrap())\n-                }).collect());\n-                self.env.as_mut().unwrap()\n-            }\n-        }\n-    }\n-\n-    /// Inserts or updates an environment variable mapping.\n-    ///\n-    /// Note that environment variable names are case-insensitive (but case-preserving) on Windows,\n-    /// and case-sensitive on all other platforms.\n-    pub fn env<'a, T, U>(&'a mut self, key: T, val: U)\n-                         -> &'a mut Command\n-                         where T: BytesContainer, U: BytesContainer {\n-        let key = EnvKey(CString::new(key.container_as_bytes()).unwrap());\n-        let val = CString::new(val.container_as_bytes()).unwrap();\n-        self.get_env_map().insert(key, val);\n-        self\n-    }\n-\n-    /// Removes an environment variable mapping.\n-    pub fn env_remove<'a, T>(&'a mut self, key: T) -> &'a mut Command\n-                             where T: BytesContainer {\n-        let key = EnvKey(CString::new(key.container_as_bytes()).unwrap());\n-        self.get_env_map().remove(&key);\n-        self\n-    }\n-\n-    /// Sets the entire environment map for the child process.\n-    ///\n-    /// If the given slice contains multiple instances of an environment\n-    /// variable, the *rightmost* instance will determine the value.\n-    pub fn env_set_all<'a, T, U>(&'a mut self, env: &[(T,U)])\n-                                 -> &'a mut Command\n-                                 where T: BytesContainer, U: BytesContainer {\n-        self.env = Some(env.iter().map(|&(ref k, ref v)| {\n-            (EnvKey(CString::new(k.container_as_bytes()).unwrap()),\n-             CString::new(v.container_as_bytes()).unwrap())\n-        }).collect());\n-        self\n-    }\n-\n-    /// Set the working directory for the child process.\n-    pub fn cwd<'a>(&'a mut self, dir: &Path) -> &'a mut Command {\n-        self.cwd = Some(CString::new(dir.as_vec()).unwrap());\n-        self\n-    }\n-\n-    /// Configuration for the child process's stdin handle (file descriptor 0).\n-    /// Defaults to `CreatePipe(true, false)` so the input can be written to.\n-    pub fn stdin<'a>(&'a mut self, cfg: StdioContainer) -> &'a mut Command {\n-        self.stdin = cfg;\n-        self\n-    }\n-\n-    /// Configuration for the child process's stdout handle (file descriptor 1).\n-    /// Defaults to `CreatePipe(false, true)` so the output can be collected.\n-    pub fn stdout<'a>(&'a mut self, cfg: StdioContainer) -> &'a mut Command {\n-        self.stdout = cfg;\n-        self\n-    }\n-\n-    /// Configuration for the child process's stderr handle (file descriptor 2).\n-    /// Defaults to `CreatePipe(false, true)` so the output can be collected.\n-    pub fn stderr<'a>(&'a mut self, cfg: StdioContainer) -> &'a mut Command {\n-        self.stderr = cfg;\n-        self\n-    }\n-\n-    /// Sets the child process's user id. This translates to a `setuid` call in\n-    /// the child process. Setting this value on windows will cause the spawn to\n-    /// fail. Failure in the `setuid` call on unix will also cause the spawn to\n-    /// fail.\n-    pub fn uid<'a>(&'a mut self, id: usize) -> &'a mut Command {\n-        self.uid = Some(id);\n-        self\n-    }\n-\n-    /// Similar to `uid`, but sets the group id of the child process. This has\n-    /// the same semantics as the `uid` field.\n-    pub fn gid<'a>(&'a mut self, id: usize) -> &'a mut Command {\n-        self.gid = Some(id);\n-        self\n-    }\n-\n-    /// Sets the child process to be spawned in a detached state. On unix, this\n-    /// means that the child is the leader of a new process group.\n-    pub fn detached<'a>(&'a mut self) -> &'a mut Command {\n-        self.detach = true;\n-        self\n-    }\n-\n-    /// Executes the command as a child process, which is returned.\n-    pub fn spawn(&self) -> IoResult<Process> {\n-        let (their_stdin, our_stdin) = try!(setup_io(self.stdin));\n-        let (their_stdout, our_stdout) = try!(setup_io(self.stdout));\n-        let (their_stderr, our_stderr) = try!(setup_io(self.stderr));\n-\n-        match ProcessImp::spawn(self, their_stdin, their_stdout, their_stderr) {\n-            Err(e) => Err(e),\n-            Ok(handle) => Ok(Process {\n-                handle: handle,\n-                forget: false,\n-                exit_code: None,\n-                exit_signal: None,\n-                deadline: 0,\n-                stdin: our_stdin,\n-                stdout: our_stdout,\n-                stderr: our_stderr,\n-            })\n-        }\n-    }\n-\n-    /// Executes the command as a child process, waiting for it to finish and\n-    /// collecting all of its output.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// # #![feature(old_io)]\n-    /// use std::old_io::Command;\n-    ///\n-    /// let output = match Command::new(\"cat\").arg(\"foot.txt\").output() {\n-    ///     Ok(output) => output,\n-    ///     Err(e) => panic!(\"failed to execute process: {}\", e),\n-    /// };\n-    ///\n-    /// println!(\"status: {}\", output.status);\n-    /// println!(\"stdout: {}\", String::from_utf8_lossy(output.output.as_ref()));\n-    /// println!(\"stderr: {}\", String::from_utf8_lossy(output.error.as_ref()));\n-    /// ```\n-    pub fn output(&self) -> IoResult<ProcessOutput> {\n-        self.spawn().and_then(|p| p.wait_with_output())\n-    }\n-\n-    /// Executes a command as a child process, waiting for it to finish and\n-    /// collecting its exit status.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// # #![feature(old_io)]\n-    /// use std::old_io::Command;\n-    ///\n-    /// let status = match Command::new(\"ls\").status() {\n-    ///     Ok(status) => status,\n-    ///     Err(e) => panic!(\"failed to execute process: {}\", e),\n-    /// };\n-    ///\n-    /// println!(\"process exited with: {}\", status);\n-    /// ```\n-    pub fn status(&self) -> IoResult<ProcessExit> {\n-        self.spawn().and_then(|mut p| p.wait())\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl fmt::Debug for Command {\n-    /// Format the program and arguments of a Command for display. Any\n-    /// non-utf8 data is lossily converted using the utf8 replacement\n-    /// character.\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        try!(write!(f, \"{:?}\", self.program));\n-        for arg in &self.args {\n-            try!(write!(f, \" '{:?}'\", arg));\n-        }\n-        Ok(())\n-    }\n-}\n-\n-fn setup_io(io: StdioContainer) -> IoResult<(Option<PipeStream>, Option<PipeStream>)> {\n-    let ours;\n-    let theirs;\n-    match io {\n-        Ignored => {\n-            theirs = None;\n-            ours = None;\n-        }\n-        InheritFd(fd) => {\n-            theirs = Some(PipeStream::from_filedesc(FileDesc::new(fd, false)));\n-            ours = None;\n-        }\n-        CreatePipe(readable, _writable) => {\n-            let PipePair { reader, writer } = try!(PipeStream::pair());\n-            if readable {\n-                theirs = Some(reader);\n-                ours = Some(writer);\n-            } else {\n-                theirs = Some(writer);\n-                ours = Some(reader);\n-            }\n-        }\n-    }\n-    Ok((theirs, ours))\n-}\n-\n-// Allow the sys module to get access to the Command state\n-impl sys::process::ProcessConfig<EnvKey, CString> for Command {\n-    fn program(&self) -> &CString {\n-        &self.program\n-    }\n-    fn args(&self) -> &[CString] {\n-        &self.args\n-    }\n-    fn env(&self) -> Option<&EnvMap> {\n-        self.env.as_ref()\n-    }\n-    fn cwd(&self) -> Option<&CString> {\n-        self.cwd.as_ref()\n-    }\n-    fn uid(&self) -> Option<usize> {\n-        self.uid.clone()\n-    }\n-    fn gid(&self) -> Option<usize> {\n-        self.gid.clone()\n-    }\n-    fn detach(&self) -> bool {\n-        self.detach\n-    }\n-\n-}\n-\n-/// The output of a finished process.\n-#[derive(PartialEq, Eq, Clone)]\n-pub struct ProcessOutput {\n-    /// The status (exit code) of the process.\n-    pub status: ProcessExit,\n-    /// The data that the process wrote to stdout.\n-    pub output: Vec<u8>,\n-    /// The data that the process wrote to stderr.\n-    pub error: Vec<u8>,\n-}\n-\n-/// Describes what to do with a standard io stream for a child process.\n-#[derive(Clone, Copy)]\n-pub enum StdioContainer {\n-    /// This stream will be ignored. This is the equivalent of attaching the\n-    /// stream to `/dev/null`\n-    Ignored,\n-\n-    /// The specified file descriptor is inherited for the stream which it is\n-    /// specified for. Ownership of the file descriptor is *not* taken, so the\n-    /// caller must clean it up.\n-    InheritFd(libc::c_int),\n-\n-    /// Creates a pipe for the specified file descriptor which will be created\n-    /// when the process is spawned.\n-    ///\n-    /// The first boolean argument is whether the pipe is readable, and the\n-    /// second is whether it is writable. These properties are from the view of\n-    /// the *child* process, not the parent process.\n-    CreatePipe(bool /* readable */, bool /* writable */),\n-}\n-\n-/// Describes the result of a process after it has terminated.\n-/// Note that Windows have no signals, so the result is usually ExitStatus.\n-#[derive(PartialEq, Eq, Clone, Copy, Debug)]\n-pub enum ProcessExit {\n-    /// Normal termination with an exit status.\n-    ExitStatus(isize),\n-\n-    /// Termination by signal, with the signal number.\n-    ExitSignal(isize),\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl fmt::Display for ProcessExit {\n-    /// Format a ProcessExit enum, to nicely present the information.\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        match *self {\n-            ExitStatus(code) =>  write!(f, \"exit code: {}\", code),\n-            ExitSignal(code) =>  write!(f, \"signal: {}\", code),\n-        }\n-    }\n-}\n-\n-impl ProcessExit {\n-    /// Was termination successful? Signal termination not considered a success,\n-    /// and success is defined as a zero exit status.\n-    pub fn success(&self) -> bool {\n-        return self.matches_exit_status(0);\n-    }\n-\n-    /// Checks whether this ProcessExit matches the given exit status.\n-    /// Termination by signal will never match an exit code.\n-    pub fn matches_exit_status(&self, wanted: isize) -> bool {\n-        *self == ExitStatus(wanted)\n-    }\n-}\n-\n-impl Process {\n-    /// Sends `signal` to another process in the system identified by `id`.\n-    ///\n-    /// Note that windows doesn't quite have the same model as unix, so some\n-    /// unix signals are mapped to windows signals. Notably, unix termination\n-    /// signals (SIGTERM/SIGKILL/SIGINT) are translated to `TerminateProcess`.\n-    ///\n-    /// Additionally, a signal number of 0 can check for existence of the target\n-    /// process. Note, though, that on some platforms signals will continue to\n-    /// be successfully delivered if the child has exited, but not yet been\n-    /// reaped.\n-    pub fn kill(id: libc::pid_t, signal: isize) -> IoResult<()> {\n-        unsafe { ProcessImp::killpid(id, signal) }\n-    }\n-\n-    /// Returns the process id of this child process\n-    pub fn id(&self) -> libc::pid_t { self.handle.id() }\n-\n-    /// Sends the specified signal to the child process, returning whether the\n-    /// signal could be delivered or not.\n-    ///\n-    /// Note that signal 0 is interpreted as a poll to check whether the child\n-    /// process is still alive or not. If an error is returned, then the child\n-    /// process has exited.\n-    ///\n-    /// On some unix platforms signals will continue to be received after a\n-    /// child has exited but not yet been reaped. In order to report the status\n-    /// of signal delivery correctly, unix implementations may invoke\n-    /// `waitpid()` with `WNOHANG` in order to reap the child as necessary.\n-    ///\n-    /// # Errors\n-    ///\n-    /// If the signal delivery fails, the corresponding error is returned.\n-    pub fn signal(&mut self, signal: isize) -> IoResult<()> {\n-        #[cfg(unix)] fn collect_status(p: &mut Process) {\n-            // On Linux (and possibly other unices), a process that has exited will\n-            // continue to accept signals because it is \"defunct\". The delivery of\n-            // signals will only fail once the child has been reaped. For this\n-            // reason, if the process hasn't exited yet, then we attempt to collect\n-            // their status with WNOHANG.\n-            if p.exit_code.is_none() {\n-                match p.handle.try_wait() {\n-                    Some(code) => { p.exit_code = Some(code); }\n-                    None => {}\n-                }\n-            }\n-        }\n-        #[cfg(windows)] fn collect_status(_p: &mut Process) {}\n-\n-        collect_status(self);\n-\n-        // if the process has finished, and therefore had waitpid called,\n-        // and we kill it, then on unix we might ending up killing a\n-        // newer process that happens to have the same (re-used) id\n-        if self.exit_code.is_some() {\n-            return Err(IoError {\n-                kind: old_io::InvalidInput,\n-                desc: \"invalid argument: can't kill an exited process\",\n-                detail: None,\n-            })\n-        }\n-\n-        // A successfully delivered signal that isn't 0 (just a poll for being\n-        // alive) is recorded for windows (see wait())\n-        match unsafe { self.handle.kill(signal) } {\n-            Ok(()) if signal == 0 => Ok(()),\n-            Ok(()) => { self.exit_signal = Some(signal); Ok(()) }\n-            Err(e) => Err(e),\n-        }\n-\n-    }\n-\n-    /// Sends a signal to this child requesting that it exits. This is\n-    /// equivalent to sending a SIGTERM on unix platforms.\n-    pub fn signal_exit(&mut self) -> IoResult<()> {\n-        self.signal(PleaseExitSignal)\n-    }\n-\n-    /// Sends a signal to this child forcing it to exit. This is equivalent to\n-    /// sending a SIGKILL on unix platforms.\n-    pub fn signal_kill(&mut self) -> IoResult<()> {\n-        self.signal(MustDieSignal)\n-    }\n-\n-    /// Wait for the child to exit completely, returning the status that it\n-    /// exited with. This function will continue to have the same return value\n-    /// after it has been called at least once.\n-    ///\n-    /// The stdin handle to the child process will be closed before waiting.\n-    ///\n-    /// # Errors\n-    ///\n-    /// This function can fail if a timeout was previously specified via\n-    /// `set_timeout` and the timeout expires before the child exits.\n-    pub fn wait(&mut self) -> IoResult<ProcessExit> {\n-        drop(self.stdin.take());\n-        match self.exit_code {\n-            Some(code) => Ok(code),\n-            None => {\n-                let code = try!(self.handle.wait(self.deadline));\n-                // On windows, waitpid will never return a signal. If a signal\n-                // was successfully delivered to the process, however, we can\n-                // consider it as having died via a signal.\n-                let code = match self.exit_signal {\n-                    None => code,\n-                    Some(signal) if cfg!(windows) => ExitSignal(signal),\n-                    Some(..) => code,\n-                };\n-                self.exit_code = Some(code);\n-                Ok(code)\n-            }\n-        }\n-    }\n-\n-    /// Sets a timeout, in milliseconds, for future calls to wait().\n-    ///\n-    /// The argument specified is a relative distance into the future, in\n-    /// milliseconds, after which any call to wait() will return immediately\n-    /// with a timeout error, and all future calls to wait() will not block.\n-    ///\n-    /// A value of `None` will clear any previous timeout, and a value of `Some`\n-    /// will override any previously set timeout.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// # #![feature(old_io, io)]\n-    /// use std::old_io::{Command, IoResult};\n-    /// use std::old_io::process::ProcessExit;\n-    ///\n-    /// fn run_gracefully(prog: &str) -> IoResult<ProcessExit> {\n-    ///     let mut p = try!(Command::new(\"long-running-process\").spawn());\n-    ///\n-    ///     // give the process 10 seconds to finish completely\n-    ///     p.set_timeout(Some(10_000));\n-    ///     match p.wait() {\n-    ///         Ok(status) => return Ok(status),\n-    ///         Err(..) => {}\n-    ///     }\n-    ///\n-    ///     // Attempt to exit gracefully, but don't wait for it too long\n-    ///     try!(p.signal_exit());\n-    ///     p.set_timeout(Some(1_000));\n-    ///     match p.wait() {\n-    ///         Ok(status) => return Ok(status),\n-    ///         Err(..) => {}\n-    ///     }\n-    ///\n-    ///     // Well, we did our best, forcefully kill the process\n-    ///     try!(p.signal_kill());\n-    ///     p.set_timeout(None);\n-    ///     p.wait()\n-    /// }\n-    /// ```\n-    #[unstable(feature = \"io\",\n-               reason = \"the type of the timeout is likely to change\")]\n-    pub fn set_timeout(&mut self, timeout_ms: Option<u64>) {\n-        self.deadline = timeout_ms.map(|i| i + sys::timer::now()).unwrap_or(0);\n-    }\n-\n-    /// Simultaneously wait for the child to exit and collect all remaining\n-    /// output on the stdout/stderr handles, returning a `ProcessOutput`\n-    /// instance.\n-    ///\n-    /// The stdin handle to the child is closed before waiting.\n-    ///\n-    /// # Errors\n-    ///\n-    /// This function can fail for any of the same reasons that `wait()` can\n-    /// fail.\n-    pub fn wait_with_output(mut self) -> IoResult<ProcessOutput> {\n-        drop(self.stdin.take());\n-        fn read(stream: Option<old_io::PipeStream>) -> Receiver<IoResult<Vec<u8>>> {\n-            let (tx, rx) = channel();\n-            match stream {\n-                Some(stream) => {\n-                    thread::spawn(move || {\n-                        let mut stream = stream;\n-                        tx.send(stream.read_to_end()).unwrap();\n-                    });\n-                }\n-                None => tx.send(Ok(Vec::new())).unwrap()\n-            }\n-            rx\n-        }\n-        let stdout = read(self.stdout.take());\n-        let stderr = read(self.stderr.take());\n-\n-        let status = try!(self.wait());\n-\n-        Ok(ProcessOutput {\n-            status: status,\n-            output: stdout.recv().unwrap().unwrap_or(Vec::new()),\n-            error:  stderr.recv().unwrap().unwrap_or(Vec::new()),\n-        })\n-    }\n-\n-    /// Forgets this process, allowing it to outlive the parent\n-    ///\n-    /// This function will forcefully prevent calling `wait()` on the child\n-    /// process in the destructor, allowing the child to outlive the\n-    /// parent. Note that this operation can easily lead to leaking the\n-    /// resources of the child process, so care must be taken when\n-    /// invoking this method.\n-    pub fn forget(mut self) {\n-        self.forget = true;\n-    }\n-}\n-\n-impl Drop for Process {\n-    fn drop(&mut self) {\n-        if self.forget { return }\n-\n-        // Close all I/O before exiting to ensure that the child doesn't wait\n-        // forever to print some text or something similar.\n-        drop(self.stdin.take());\n-        drop(self.stdout.take());\n-        drop(self.stderr.take());\n-\n-        self.set_timeout(None);\n-        let _ = self.wait().unwrap();\n-    }\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    use prelude::v1::*;\n-    use old_io::{Truncate, Write, TimedOut, timer, process, FileNotFound};\n-    use old_io::{Reader, Writer};\n-    use old_path::{GenericPath, Path};\n-    use old_io::fs::PathExtensions;\n-    use old_io::timer::*;\n-    use rt::running_on_valgrind;\n-    use str;\n-    use super::{CreatePipe};\n-    use super::{InheritFd, Process, PleaseExitSignal, Command, ProcessOutput};\n-    use sync::mpsc::channel;\n-    use thread;\n-    use time::Duration;\n-\n-    // FIXME(#10380) these tests should not all be ignored on android.\n-\n-    #[cfg(not(target_os=\"android\"))]\n-    #[test]\n-    fn smoke() {\n-        let p = Command::new(\"true\").spawn();\n-        assert!(p.is_ok());\n-        let mut p = p.unwrap();\n-        assert!(p.wait().unwrap().success());\n-    }\n-\n-    #[cfg(not(target_os=\"android\"))]\n-    #[test]\n-    fn smoke_failure() {\n-        match Command::new(\"if-this-is-a-binary-then-the-world-has-ended\").spawn() {\n-            Ok(..) => panic!(),\n-            Err(..) => {}\n-        }\n-    }\n-\n-    #[cfg(not(target_os=\"android\"))]\n-    #[test]\n-    fn exit_reported_right() {\n-        let p = Command::new(\"false\").spawn();\n-        assert!(p.is_ok());\n-        let mut p = p.unwrap();\n-        assert!(p.wait().unwrap().matches_exit_status(1));\n-        drop(p.wait().clone());\n-    }\n-\n-    #[cfg(all(unix, not(target_os=\"android\")))]\n-    #[test]\n-    fn signal_reported_right() {\n-        let p = Command::new(\"/bin/sh\").arg(\"-c\").arg(\"kill -9 $$\").spawn();\n-        assert!(p.is_ok());\n-        let mut p = p.unwrap();\n-        match p.wait().unwrap() {\n-            process::ExitSignal(9) => {},\n-            result => panic!(\"not terminated by signal 9 (instead, {})\", result),\n-        }\n-    }\n-\n-    pub fn read_all(input: &mut Reader) -> String {\n-        input.read_to_string().unwrap()\n-    }\n-\n-    pub fn run_output(cmd: Command) -> String {\n-        let p = cmd.spawn();\n-        assert!(p.is_ok());\n-        let mut p = p.unwrap();\n-        assert!(p.stdout.is_some());\n-        let ret = read_all(p.stdout.as_mut().unwrap() as &mut Reader);\n-        assert!(p.wait().unwrap().success());\n-        return ret;\n-    }\n-\n-    #[cfg(not(target_os=\"android\"))]\n-    #[test]\n-    fn stdout_works() {\n-        let mut cmd = Command::new(\"echo\");\n-        cmd.arg(\"foobar\").stdout(CreatePipe(false, true));\n-        assert_eq!(run_output(cmd), \"foobar\\n\");\n-    }\n-\n-    #[cfg(all(unix, not(target_os=\"android\")))]\n-    #[test]\n-    fn set_cwd_works() {\n-        let mut cmd = Command::new(\"/bin/sh\");\n-        cmd.arg(\"-c\").arg(\"pwd\")\n-           .cwd(&Path::new(\"/\"))\n-           .stdout(CreatePipe(false, true));\n-        assert_eq!(run_output(cmd), \"/\\n\");\n-    }\n-\n-    #[cfg(all(unix, not(target_os=\"android\")))]\n-    #[test]\n-    fn stdin_works() {\n-        let mut p = Command::new(\"/bin/sh\")\n-                            .arg(\"-c\").arg(\"read line; echo $line\")\n-                            .stdin(CreatePipe(true, false))\n-                            .stdout(CreatePipe(false, true))\n-                            .spawn().unwrap();\n-        p.stdin.as_mut().unwrap().write(\"foobar\".as_bytes()).unwrap();\n-        drop(p.stdin.take());\n-        let out = read_all(p.stdout.as_mut().unwrap() as &mut Reader);\n-        assert!(p.wait().unwrap().success());\n-        assert_eq!(out, \"foobar\\n\");\n-    }\n-\n-    #[cfg(not(target_os=\"android\"))]\n-    #[test]\n-    fn detach_works() {\n-        let mut p = Command::new(\"true\").detached().spawn().unwrap();\n-        assert!(p.wait().unwrap().success());\n-    }\n-\n-    #[cfg(windows)]\n-    #[test]\n-    fn uid_fails_on_windows() {\n-        assert!(Command::new(\"test\").uid(10).spawn().is_err());\n-    }\n-\n-    #[cfg(all(unix, not(target_os=\"android\")))]\n-    #[test]\n-    fn uid_works() {\n-        use libc;\n-        let mut p = Command::new(\"/bin/sh\")\n-                            .arg(\"-c\").arg(\"true\")\n-                            .uid(unsafe { libc::getuid() as usize })\n-                            .gid(unsafe { libc::getgid() as usize })\n-                            .spawn().unwrap();\n-        assert!(p.wait().unwrap().success());\n-    }\n-\n-    #[cfg(all(unix, not(target_os=\"android\")))]\n-    #[test]\n-    fn uid_to_root_fails() {\n-        use libc;\n-\n-        // if we're already root, this isn't a valid test. Most of the bots run\n-        // as non-root though (android is an exception).\n-        if unsafe { libc::getuid() == 0 } { return }\n-        assert!(Command::new(\"/bin/ls\").uid(0).gid(0).spawn().is_err());\n-    }\n-\n-    #[cfg(not(target_os=\"android\"))]\n-    #[test]\n-    fn test_process_status() {\n-        let mut status = Command::new(\"false\").status().unwrap();\n-        assert!(status.matches_exit_status(1));\n-\n-        status = Command::new(\"true\").status().unwrap();\n-        assert!(status.success());\n-    }\n-\n-    #[test]\n-    fn test_process_output_fail_to_start() {\n-        match Command::new(\"/no-binary-by-this-name-should-exist\").output() {\n-            Err(e) => assert_eq!(e.kind, FileNotFound),\n-            Ok(..) => panic!()\n-        }\n-    }\n-\n-    #[cfg(not(target_os=\"android\"))]\n-    #[test]\n-    fn test_process_output_output() {\n-        let ProcessOutput {status, output, error}\n-             = Command::new(\"echo\").arg(\"hello\").output().unwrap();\n-        let output_str = str::from_utf8(&output).unwrap();\n-\n-        assert!(status.success());\n-        assert_eq!(output_str.trim().to_string(), \"hello\");\n-        // FIXME #7224\n-        if !running_on_valgrind() {\n-            assert_eq!(error, Vec::new());\n-        }\n-    }\n-\n-    #[cfg(not(target_os=\"android\"))]\n-    #[test]\n-    fn test_process_output_error() {\n-        let ProcessOutput {status, output, error}\n-             = Command::new(\"mkdir\").arg(\".\").output().unwrap();\n-\n-        assert!(status.matches_exit_status(1));\n-        assert_eq!(output, Vec::new());\n-        assert!(!error.is_empty());\n-    }\n-\n-    #[cfg(not(target_os=\"android\"))]\n-    #[test]\n-    fn test_finish_once() {\n-        let mut prog = Command::new(\"false\").spawn().unwrap();\n-        assert!(prog.wait().unwrap().matches_exit_status(1));\n-    }\n-\n-    #[cfg(not(target_os=\"android\"))]\n-    #[test]\n-    fn test_finish_twice() {\n-        let mut prog = Command::new(\"false\").spawn().unwrap();\n-        assert!(prog.wait().unwrap().matches_exit_status(1));\n-        assert!(prog.wait().unwrap().matches_exit_status(1));\n-    }\n-\n-    #[cfg(not(target_os=\"android\"))]\n-    #[test]\n-    fn test_wait_with_output_once() {\n-        let prog = Command::new(\"echo\").arg(\"hello\").spawn().unwrap();\n-        let ProcessOutput {status, output, error} = prog.wait_with_output().unwrap();\n-        let output_str = str::from_utf8(&output).unwrap();\n-\n-        assert!(status.success());\n-        assert_eq!(output_str.trim().to_string(), \"hello\");\n-        // FIXME #7224\n-        if !running_on_valgrind() {\n-            assert_eq!(error, Vec::new());\n-        }\n-    }\n-\n-    #[cfg(all(unix, not(target_os=\"android\")))]\n-    pub fn pwd_cmd() -> Command {\n-        Command::new(\"pwd\")\n-    }\n-    #[cfg(target_os=\"android\")]\n-    pub fn pwd_cmd() -> Command {\n-        let mut cmd = Command::new(\"/system/bin/sh\");\n-        cmd.arg(\"-c\").arg(\"pwd\");\n-        cmd\n-    }\n-\n-    #[cfg(windows)]\n-    pub fn pwd_cmd() -> Command {\n-        let mut cmd = Command::new(\"cmd\");\n-        cmd.arg(\"/c\").arg(\"cd\");\n-        cmd\n-    }\n-\n-    #[test]\n-    fn test_keep_current_working_dir() {\n-        use os;\n-        let prog = pwd_cmd().spawn().unwrap();\n-\n-        let output = String::from_utf8(prog.wait_with_output().unwrap().output).unwrap();\n-        let parent_dir = Path::new(::env::current_dir().unwrap().to_str().unwrap());\n-        let child_dir = Path::new(output.trim());\n-\n-        let parent_stat = parent_dir.stat().unwrap();\n-        let child_stat = child_dir.stat().unwrap();\n-\n-        assert_eq!(parent_stat.unstable.device, child_stat.unstable.device);\n-        assert_eq!(parent_stat.unstable.inode, child_stat.unstable.inode);\n-    }\n-\n-    #[test]\n-    fn test_change_working_directory() {\n-        use os;\n-        // test changing to the parent of os::getcwd() because we know\n-        // the path exists (and os::getcwd() is not expected to be root)\n-        let parent_dir = Path::new(::env::current_dir().unwrap().to_str().unwrap());\n-        let prog = pwd_cmd().cwd(&parent_dir).spawn().unwrap();\n-\n-        let output = String::from_utf8(prog.wait_with_output().unwrap().output).unwrap();\n-        let child_dir = Path::new(output.trim());\n-\n-        let parent_stat = parent_dir.stat().unwrap();\n-        let child_stat = child_dir.stat().unwrap();\n-\n-        assert_eq!(parent_stat.unstable.device, child_stat.unstable.device);\n-        assert_eq!(parent_stat.unstable.inode, child_stat.unstable.inode);\n-    }\n-\n-    #[cfg(all(unix, not(target_os=\"android\")))]\n-    pub fn env_cmd() -> Command {\n-        Command::new(\"env\")\n-    }\n-    #[cfg(target_os=\"android\")]\n-    pub fn env_cmd() -> Command {\n-        let mut cmd = Command::new(\"/system/bin/sh\");\n-        cmd.arg(\"-c\").arg(\"set\");\n-        cmd\n-    }\n-\n-    #[cfg(windows)]\n-    pub fn env_cmd() -> Command {\n-        let mut cmd = Command::new(\"cmd\");\n-        cmd.arg(\"/c\").arg(\"set\");\n-        cmd\n-    }\n-\n-    #[cfg(not(target_os=\"android\"))]\n-    #[test]\n-    fn test_inherit_env() {\n-        use os;\n-        if running_on_valgrind() { return; }\n-\n-        let prog = env_cmd().spawn().unwrap();\n-        let output = String::from_utf8(prog.wait_with_output().unwrap().output).unwrap();\n-\n-        let r = ::env::vars();\n-        for (k, v) in r {\n-            // don't check windows magical empty-named variables\n-            assert!(k.is_empty() ||\n-                    output.contains(&format!(\"{}={}\", k, v)),\n-                    \"output doesn't contain `{}={}`\\n{}\",\n-                    k, v, output);\n-        }\n-    }\n-    #[cfg(target_os=\"android\")]\n-    #[test]\n-    fn test_inherit_env() {\n-        use os;\n-        if running_on_valgrind() { return; }\n-\n-        let mut prog = env_cmd().spawn().unwrap();\n-        let output = String::from_utf8(prog.wait_with_output().unwrap().output).unwrap();\n-\n-        let r = ::env::vars();\n-        for (k, v) in r {\n-            // don't check android RANDOM variables\n-            if k != \"RANDOM\".to_string() {\n-                assert!(output.contains(&format!(\"{}={}\", k, v)) ||\n-                        output.contains(&format!(\"{}=\\'{}\\'\", k, v)));\n-            }\n-        }\n-    }\n-\n-    #[test]\n-    fn test_override_env() {\n-        use os;\n-\n-        // In some build environments (such as chrooted Nix builds), `env` can\n-        // only be found in the explicitly-provided PATH env variable, not in\n-        // default places such as /bin or /usr/bin. So we need to pass through\n-        // PATH to our sub-process.\n-        let path_val: String;\n-        let mut new_env = vec![(\"RUN_TEST_NEW_ENV\", \"123\")];\n-        match ::env::var(\"PATH\") {\n-            Err(..) => {}\n-            Ok(val) => {\n-                path_val = val;\n-                new_env.push((\"PATH\", &path_val))\n-            }\n-        }\n-\n-        let prog = env_cmd().env_set_all(&new_env).spawn().unwrap();\n-        let result = prog.wait_with_output().unwrap();\n-        let output = String::from_utf8_lossy(&result.output).to_string();\n-\n-        assert!(output.contains(\"RUN_TEST_NEW_ENV=123\"),\n-                \"didn't find RUN_TEST_NEW_ENV inside of:\\n\\n{}\", output);\n-    }\n-\n-    #[test]\n-    fn test_add_to_env() {\n-        let prog = env_cmd().env(\"RUN_TEST_NEW_ENV\", \"123\").spawn().unwrap();\n-        let result = prog.wait_with_output().unwrap();\n-        let output = String::from_utf8_lossy(&result.output).to_string();\n-\n-        assert!(output.contains(\"RUN_TEST_NEW_ENV=123\"),\n-                \"didn't find RUN_TEST_NEW_ENV inside of:\\n\\n{}\", output);\n-    }\n-\n-    #[cfg(unix)]\n-    pub fn sleeper() -> Process {\n-        Command::new(\"sleep\").arg(\"1000\").spawn().unwrap()\n-    }\n-    #[cfg(windows)]\n-    pub fn sleeper() -> Process {\n-        // There's a `timeout` command on windows, but it doesn't like having\n-        // its output piped, so instead just ping ourselves a few times with\n-        // gaps in between so we're sure this process is alive for awhile\n-        Command::new(\"ping\").arg(\"127.0.0.1\").arg(\"-n\").arg(\"1000\").spawn().unwrap()\n-    }\n-\n-    #[test]\n-    fn test_kill() {\n-        let mut p = sleeper();\n-        Process::kill(p.id(), PleaseExitSignal).unwrap();\n-        assert!(!p.wait().unwrap().success());\n-    }\n-\n-    #[test]\n-    fn test_exists() {\n-        let mut p = sleeper();\n-        assert!(Process::kill(p.id(), 0).is_ok());\n-        p.signal_kill().unwrap();\n-        assert!(!p.wait().unwrap().success());\n-    }\n-\n-    #[test]\n-    fn test_zero() {\n-        let mut p = sleeper();\n-        p.signal_kill().unwrap();\n-        for _ in 0..20 {\n-            if p.signal(0).is_err() {\n-                assert!(!p.wait().unwrap().success());\n-                return\n-            }\n-            timer::sleep(Duration::milliseconds(100));\n-        }\n-        panic!(\"never saw the child go away\");\n-    }\n-\n-    #[test]\n-    fn wait_timeout() {\n-        let mut p = sleeper();\n-        p.set_timeout(Some(10));\n-        assert_eq!(p.wait().err().unwrap().kind, TimedOut);\n-        assert_eq!(p.wait().err().unwrap().kind, TimedOut);\n-        p.signal_kill().unwrap();\n-        p.set_timeout(None);\n-        assert!(p.wait().is_ok());\n-    }\n-\n-    #[test]\n-    fn wait_timeout2() {\n-        let (tx, rx) = channel();\n-        let tx2 = tx.clone();\n-        let _t = thread::spawn(move|| {\n-            let mut p = sleeper();\n-            p.set_timeout(Some(10));\n-            assert_eq!(p.wait().err().unwrap().kind, TimedOut);\n-            p.signal_kill().unwrap();\n-            tx.send(()).unwrap();\n-        });\n-        let _t = thread::spawn(move|| {\n-            let mut p = sleeper();\n-            p.set_timeout(Some(10));\n-            assert_eq!(p.wait().err().unwrap().kind, TimedOut);\n-            p.signal_kill().unwrap();\n-            tx2.send(()).unwrap();\n-        });\n-        rx.recv().unwrap();\n-        rx.recv().unwrap();\n-    }\n-\n-    #[test]\n-    fn forget() {\n-        let p = sleeper();\n-        let id = p.id();\n-        p.forget();\n-        assert!(Process::kill(id, 0).is_ok());\n-        assert!(Process::kill(id, PleaseExitSignal).is_ok());\n-    }\n-\n-    #[test]\n-    fn dont_close_fd_on_command_spawn() {\n-        use sys::fs;\n-\n-        let path = if cfg!(windows) {\n-            Path::new(\"NUL\")\n-        } else {\n-            Path::new(\"/dev/null\")\n-        };\n-\n-        let fdes = match fs::open(&path, Truncate, Write) {\n-            Ok(f) => f,\n-            Err(_) => panic!(\"failed to open file descriptor\"),\n-        };\n-\n-        let mut cmd = pwd_cmd();\n-        let _ = cmd.stdout(InheritFd(fdes.fd()));\n-        assert!(cmd.status().unwrap().success());\n-        assert!(fdes.write(\"extra write\\n\".as_bytes()).is_ok());\n-    }\n-\n-    #[test]\n-    #[cfg(windows)]\n-    fn env_map_keys_ci() {\n-        use ffi::CString;\n-        use super::EnvKey;\n-        let mut cmd = Command::new(\"\");\n-        cmd.env(\"path\", \"foo\");\n-        cmd.env(\"Path\", \"bar\");\n-        let env = &cmd.env.unwrap();\n-        let val = env.get(&EnvKey(CString::new(\"PATH\").unwrap()));\n-        assert!(val.unwrap() == &CString::new(\"bar\").unwrap());\n-    }\n-}"}, {"sha": "e1037f26b7fcf575bf61f50a0905745125ceb6da", "filename": "src/libstd/old_io/result.rs", "status": "removed", "additions": 0, "deletions": 130, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/8415fa27877a4309a79b08c75a52eb4c3546b7a5/src%2Flibstd%2Fold_io%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8415fa27877a4309a79b08c75a52eb4c3546b7a5/src%2Flibstd%2Fold_io%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fresult.rs?ref=8415fa27877a4309a79b08c75a52eb4c3546b7a5", "patch": "@@ -1,130 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Implementations of I/O traits for the IoResult type\n-//!\n-//! I/O constructors return option types to allow errors to be handled.\n-//! These implementations allow e.g. `IoResult<File>` to be used\n-//! as a `Reader` without unwrapping the result first.\n-\n-use clone::Clone;\n-use result::Result::{Ok, Err};\n-use super::{Reader, Writer, Listener, Acceptor, Seek, SeekStyle, IoResult};\n-\n-impl<W: Writer> Writer for IoResult<W> {\n-    fn write_all(&mut self, buf: &[u8]) -> IoResult<()> {\n-        match *self {\n-            Ok(ref mut writer) => writer.write_all(buf),\n-            Err(ref e) => Err((*e).clone())\n-        }\n-    }\n-\n-    fn flush(&mut self) -> IoResult<()> {\n-        match *self {\n-            Ok(ref mut writer) => writer.flush(),\n-            Err(ref e) => Err(e.clone()),\n-        }\n-    }\n-}\n-\n-impl<R: Reader> Reader for IoResult<R> {\n-    fn read(&mut self, buf: &mut [u8]) -> IoResult<usize> {\n-        match *self {\n-            Ok(ref mut reader) => reader.read(buf),\n-            Err(ref e) => Err(e.clone()),\n-        }\n-    }\n-}\n-\n-impl<S: Seek> Seek for IoResult<S> {\n-    fn tell(&self) -> IoResult<u64> {\n-        match *self {\n-            Ok(ref seeker) => seeker.tell(),\n-            Err(ref e) => Err(e.clone()),\n-        }\n-    }\n-    fn seek(&mut self, pos: i64, style: SeekStyle) -> IoResult<()> {\n-        match *self {\n-            Ok(ref mut seeker) => seeker.seek(pos, style),\n-            Err(ref e) => Err(e.clone())\n-        }\n-    }\n-}\n-\n-impl<A: Acceptor, L: Listener<A>> Listener<A> for IoResult<L> {\n-    fn listen(self) -> IoResult<A> {\n-        match self {\n-            Ok(listener) => listener.listen(),\n-            Err(e) => Err(e),\n-        }\n-    }\n-}\n-\n-impl<A: Acceptor> Acceptor for IoResult<A> {\n-    type Connection = A::Connection;\n-    fn accept(&mut self) -> IoResult<A::Connection> {\n-        match *self {\n-            Ok(ref mut acceptor) => acceptor.accept(),\n-            Err(ref e) => Err(e.clone()),\n-        }\n-    }\n-}\n-\n-#[cfg(test)]\n-mod test {\n-    use prelude::v1::*;\n-    use super::super::mem::*;\n-    use old_io::{self, Reader, Writer};\n-\n-    #[test]\n-    fn test_option_writer() {\n-        let mut writer: old_io::IoResult<Vec<u8>> = Ok(Vec::new());\n-        writer.write_all(&[0, 1, 2]).unwrap();\n-        writer.flush().unwrap();\n-        assert_eq!(writer.unwrap(), [0, 1, 2]);\n-    }\n-\n-    #[test]\n-    fn test_option_writer_error() {\n-        let mut writer: old_io::IoResult<Vec<u8>> =\n-            Err(old_io::standard_error(old_io::EndOfFile));\n-\n-        match writer.write_all(&[0, 0, 0]) {\n-            Ok(..) => panic!(),\n-            Err(e) => assert_eq!(e.kind, old_io::EndOfFile),\n-        }\n-        match writer.flush() {\n-            Ok(..) => panic!(),\n-            Err(e) => assert_eq!(e.kind, old_io::EndOfFile),\n-        }\n-    }\n-\n-    #[test]\n-    fn test_option_reader() {\n-        let mut reader: old_io::IoResult<MemReader> =\n-            Ok(MemReader::new(vec!(0, 1, 2, 3)));\n-        let mut buf = [0, 0];\n-        reader.read(&mut buf).unwrap();\n-        let b: &[_] = &[0, 1];\n-        assert_eq!(buf, b);\n-    }\n-\n-    #[test]\n-    fn test_option_reader_error() {\n-        let mut reader: old_io::IoResult<MemReader> =\n-            Err(old_io::standard_error(old_io::EndOfFile));\n-        let mut buf = [];\n-\n-        match reader.read(&mut buf) {\n-            Ok(..) => panic!(),\n-            Err(e) => assert_eq!(e.kind, old_io::EndOfFile),\n-        }\n-    }\n-}"}, {"sha": "b4924c7b78b753112d6e58ff59b9b8872fe4c28c", "filename": "src/libstd/old_io/stdio.rs", "status": "removed", "additions": 0, "deletions": 540, "changes": 540, "blob_url": "https://github.com/rust-lang/rust/blob/8415fa27877a4309a79b08c75a52eb4c3546b7a5/src%2Flibstd%2Fold_io%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8415fa27877a4309a79b08c75a52eb4c3546b7a5/src%2Flibstd%2Fold_io%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fstdio.rs?ref=8415fa27877a4309a79b08c75a52eb4c3546b7a5", "patch": "@@ -1,540 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Non-blocking access to stdin, stdout, and stderr.\n-//!\n-//! This module provides bindings to the local event loop's TTY interface, using it\n-//! to offer synchronous but non-blocking versions of stdio. These handles can be\n-//! inspected for information about terminal dimensions or for related information\n-//! about the stream or terminal to which it is attached.\n-//!\n-//! # Examples\n-//!\n-//! ```rust\n-//! # #![feature(old_io)]\n-//! # #![allow(unused_must_use)]\n-//! use std::old_io;\n-//! use std::old_io::*;\n-//!\n-//! let mut out = old_io::stdout();\n-//! out.write_all(b\"Hello, world!\");\n-//! ```\n-\n-use self::StdSource::*;\n-\n-use boxed;\n-use boxed::Box;\n-use cell::RefCell;\n-use clone::Clone;\n-use fmt;\n-use old_io::{Reader, Writer, IoResult, IoError, OtherIoError, Buffer,\n-             standard_error, EndOfFile, LineBufferedWriter, BufferedReader};\n-use marker::{Sync, Send};\n-use libc;\n-use mem;\n-use option::Option;\n-use option::Option::{Some, None};\n-use ops::{Deref, DerefMut, FnOnce};\n-use ptr;\n-use result::Result::{Ok, Err};\n-use rt;\n-use string::String;\n-use sys::{fs, tty};\n-use sync::{Arc, Mutex, MutexGuard, Once, ONCE_INIT};\n-use usize;\n-use vec::Vec;\n-\n-// And so begins the tale of acquiring a uv handle to a stdio stream on all\n-// platforms in all situations. Our story begins by splitting the world into two\n-// categories, windows and unix. Then one day the creators of unix said let\n-// there be redirection! And henceforth there was redirection away from the\n-// console for standard I/O streams.\n-//\n-// After this day, the world split into four factions:\n-//\n-// 1. Unix with stdout on a terminal.\n-// 2. Unix with stdout redirected.\n-// 3. Windows with stdout on a terminal.\n-// 4. Windows with stdout redirected.\n-//\n-// Many years passed, and then one day the nation of libuv decided to unify this\n-// world. After months of toiling, uv created three ideas: TTY, Pipe, File.\n-// These three ideas propagated throughout the lands and the four great factions\n-// decided to settle among them.\n-//\n-// The groups of 1, 2, and 3 all worked very hard towards the idea of TTY. Upon\n-// doing so, they even enhanced themselves further then their Pipe/File\n-// brethren, becoming the dominant powers.\n-//\n-// The group of 4, however, decided to work independently. They abandoned the\n-// common TTY belief throughout, and even abandoned the fledgling Pipe belief.\n-// The members of the 4th faction decided to only align themselves with File.\n-//\n-// tl;dr; TTY works on everything but when windows stdout is redirected, in that\n-//        case pipe also doesn't work, but magically file does!\n-enum StdSource {\n-    TTY(tty::TTY),\n-    File(fs::FileDesc),\n-}\n-\n-fn src<T, F>(fd: libc::c_int, _readable: bool, f: F) -> T where\n-    F: FnOnce(StdSource) -> T,\n-{\n-    match tty::TTY::new(fd) {\n-        Ok(tty) => f(TTY(tty)),\n-        Err(_) => f(File(fs::FileDesc::new(fd, false))),\n-    }\n-}\n-\n-thread_local! {\n-    static LOCAL_STDOUT: RefCell<Option<Box<Writer + Send>>> = {\n-        RefCell::new(None)\n-    }\n-}\n-\n-struct RaceBox(BufferedReader<StdReader>);\n-\n-unsafe impl Send for RaceBox {}\n-unsafe impl Sync for RaceBox {}\n-\n-/// A synchronized wrapper around a buffered reader from stdin\n-#[derive(Clone)]\n-pub struct StdinReader {\n-    inner: Arc<Mutex<RaceBox>>,\n-}\n-\n-unsafe impl Send for StdinReader {}\n-unsafe impl Sync for StdinReader {}\n-\n-/// A guard for exclusive access to `StdinReader`'s internal `BufferedReader`.\n-pub struct StdinReaderGuard<'a> {\n-    inner: MutexGuard<'a, RaceBox>,\n-}\n-\n-impl<'a> Deref for StdinReaderGuard<'a> {\n-    type Target = BufferedReader<StdReader>;\n-\n-    fn deref(&self) -> &BufferedReader<StdReader> {\n-        &self.inner.0\n-    }\n-}\n-\n-impl<'a> DerefMut for StdinReaderGuard<'a> {\n-    fn deref_mut(&mut self) -> &mut BufferedReader<StdReader> {\n-        &mut self.inner.0\n-    }\n-}\n-\n-impl StdinReader {\n-    /// Locks the `StdinReader`, granting the calling thread exclusive access\n-    /// to the underlying `BufferedReader`.\n-    ///\n-    /// This provides access to methods like `chars` and `lines`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// # #![feature(old_io)]\n-    /// use std::old_io;\n-    /// use std::old_io::*;\n-    ///\n-    /// let mut stdin = old_io::stdin();\n-    /// for line in stdin.lock().lines() {\n-    ///     println!(\"{}\", line.unwrap());\n-    /// }\n-    /// ```\n-    pub fn lock<'a>(&'a mut self) -> StdinReaderGuard<'a> {\n-        StdinReaderGuard {\n-            inner: self.inner.lock().unwrap()\n-        }\n-    }\n-\n-    /// Like `Buffer::read_line`.\n-    ///\n-    /// The read is performed atomically - concurrent read calls in other\n-    /// threads will not interleave with this one.\n-    pub fn read_line(&mut self) -> IoResult<String> {\n-        self.inner.lock().unwrap().0.read_line()\n-    }\n-\n-    /// Like `Buffer::read_until`.\n-    ///\n-    /// The read is performed atomically - concurrent read calls in other\n-    /// threads will not interleave with this one.\n-    pub fn read_until(&mut self, byte: u8) -> IoResult<Vec<u8>> {\n-        self.inner.lock().unwrap().0.read_until(byte)\n-    }\n-\n-    /// Like `Buffer::read_char`.\n-    ///\n-    /// The read is performed atomically - concurrent read calls in other\n-    /// threads will not interleave with this one.\n-    pub fn read_char(&mut self) -> IoResult<char> {\n-        self.inner.lock().unwrap().0.read_char()\n-    }\n-}\n-\n-impl Reader for StdinReader {\n-    fn read(&mut self, buf: &mut [u8]) -> IoResult<usize> {\n-        self.inner.lock().unwrap().0.read(buf)\n-    }\n-\n-    // We have to manually delegate all of these because the default impls call\n-    // read more than once and we don't want those calls to interleave (or\n-    // incur the costs of repeated locking).\n-\n-    fn read_at_least(&mut self, min: usize, buf: &mut [u8]) -> IoResult<usize> {\n-        self.inner.lock().unwrap().0.read_at_least(min, buf)\n-    }\n-\n-    fn push_at_least(&mut self, min: usize, len: usize, buf: &mut Vec<u8>) -> IoResult<usize> {\n-        self.inner.lock().unwrap().0.push_at_least(min, len, buf)\n-    }\n-\n-    fn read_to_end(&mut self) -> IoResult<Vec<u8>> {\n-        self.inner.lock().unwrap().0.read_to_end()\n-    }\n-\n-    fn read_le_uint_n(&mut self, nbytes: usize) -> IoResult<u64> {\n-        self.inner.lock().unwrap().0.read_le_uint_n(nbytes)\n-    }\n-\n-    fn read_be_uint_n(&mut self, nbytes: usize) -> IoResult<u64> {\n-        self.inner.lock().unwrap().0.read_be_uint_n(nbytes)\n-    }\n-}\n-\n-/// Creates a new handle to the stdin of the current process.\n-///\n-/// The returned handle is a wrapper around a global `BufferedReader` shared\n-/// by all threads. If buffered access is not desired, the `stdin_raw` function\n-/// is provided to provided unbuffered access to stdin.\n-///\n-/// See `stdout()` for more notes about this function.\n-pub fn stdin() -> StdinReader {\n-    // We're following the same strategy as kimundi's lazy_static library\n-    static mut STDIN: *mut StdinReader = 0 as *mut StdinReader;\n-    static ONCE: Once = ONCE_INIT;\n-\n-    unsafe {\n-        ONCE.call_once(|| {\n-            // The default buffer capacity is 64k, but apparently windows\n-            // doesn't like 64k reads on stdin. See #13304 for details, but the\n-            // idea is that on windows we use a slightly smaller buffer that's\n-            // been seen to be acceptable.\n-            let stdin = if cfg!(windows) {\n-                BufferedReader::with_capacity(8 * 1024, stdin_raw())\n-            } else {\n-                BufferedReader::new(stdin_raw())\n-            };\n-            let stdin = StdinReader {\n-                inner: Arc::new(Mutex::new(RaceBox(stdin)))\n-            };\n-            STDIN = boxed::into_raw(box stdin);\n-\n-            // Make sure to free it at exit\n-            let _ = rt::at_exit(|| {\n-                Box::from_raw(STDIN);\n-                STDIN = ptr::null_mut();\n-            });\n-        });\n-\n-        (*STDIN).clone()\n-    }\n-}\n-\n-/// Creates a new non-blocking handle to the stdin of the current process.\n-///\n-/// Unlike `stdin()`, the returned reader is *not* a buffered reader.\n-///\n-/// See `stdout()` for more notes about this function.\n-pub fn stdin_raw() -> StdReader {\n-    src(libc::STDIN_FILENO, true, |src| StdReader { inner: src })\n-}\n-\n-/// Creates a line-buffered handle to the stdout of the current process.\n-///\n-/// Note that this is a fairly expensive operation in that at least one memory\n-/// allocation is performed. Additionally, this must be called from a runtime\n-/// task context because the stream returned will be a non-blocking object using\n-/// the local scheduler to perform the I/O.\n-///\n-/// Care should be taken when creating multiple handles to an output stream for\n-/// a single process. While usage is still safe, the output may be surprising if\n-/// no synchronization is performed to ensure a sane output.\n-pub fn stdout() -> LineBufferedWriter<StdWriter> {\n-    LineBufferedWriter::new(stdout_raw())\n-}\n-\n-/// Creates an unbuffered handle to the stdout of the current process\n-///\n-/// See notes in `stdout()` for more information.\n-pub fn stdout_raw() -> StdWriter {\n-    src(libc::STDOUT_FILENO, false, |src| StdWriter { inner: src })\n-}\n-\n-/// Creates a line-buffered handle to the stderr of the current process.\n-///\n-/// See `stdout()` for notes about this function.\n-pub fn stderr() -> LineBufferedWriter<StdWriter> {\n-    LineBufferedWriter::new(stderr_raw())\n-}\n-\n-/// Creates an unbuffered handle to the stderr of the current process\n-///\n-/// See notes in `stdout()` for more information.\n-pub fn stderr_raw() -> StdWriter {\n-    src(libc::STDERR_FILENO, false, |src| StdWriter { inner: src })\n-}\n-\n-/// Resets the task-local stdout handle to the specified writer\n-///\n-/// This will replace the current task's stdout handle, returning the old\n-/// handle. All future calls to `print` and friends will emit their output to\n-/// this specified handle.\n-///\n-/// Note that this does not need to be called for all new tasks; the default\n-/// output handle is to the process's stdout stream.\n-pub fn set_stdout(stdout: Box<Writer + Send>) -> Option<Box<Writer + Send>> {\n-    let mut new = Some(stdout);\n-    LOCAL_STDOUT.with(|slot| {\n-        mem::replace(&mut *slot.borrow_mut(), new.take())\n-    }).and_then(|mut s| {\n-        let _ = s.flush();\n-        Some(s)\n-    })\n-}\n-\n-/// Resets the task-local stderr handle to the specified writer\n-///\n-/// This will replace the current task's stderr handle, returning the old\n-/// handle. Currently, the stderr handle is used for printing panic messages\n-/// during task panic.\n-///\n-/// Note that this does not need to be called for all new tasks; the default\n-/// output handle is to the process's stderr stream.\n-#[unstable(feature = \"old_io\")]\n-#[deprecated(since = \"1.0.0\", reason = \"replaced with std::io::set_panic\")]\n-pub fn set_stderr(_stderr: Box<Writer + Send>) -> Option<Box<Writer + Send>> {\n-    None\n-}\n-\n-// Helper to access the local task's stdout handle\n-//\n-// Note that this is not a safe function to expose because you can create an\n-// aliased pointer very easily:\n-//\n-//  with_task_stdout(|io1| {\n-//      with_task_stdout(|io2| {\n-//          // io1 aliases io2\n-//      })\n-//  })\n-fn with_task_stdout<F>(f: F) where F: FnOnce(&mut Writer) -> IoResult<()> {\n-    let mut my_stdout: Box<Writer + Send> = LOCAL_STDOUT.with(|slot| {\n-        slot.borrow_mut().take()\n-    }).unwrap_or_else(|| {\n-        box stdout()\n-    });\n-    let result = f(&mut *my_stdout);\n-    let mut var = Some(my_stdout);\n-    LOCAL_STDOUT.with(|slot| {\n-        *slot.borrow_mut() = var.take();\n-    });\n-    match result {\n-        Ok(()) => {}\n-        Err(e) => panic!(\"failed printing to stdout: {:?}\", e),\n-    }\n-}\n-\n-/// Flushes the local task's stdout handle.\n-///\n-/// By default, this stream is a line-buffering stream, so flushing may be\n-/// necessary to ensure that all output is printed to the screen (if there are\n-/// no newlines printed).\n-///\n-/// Note that logging macros do not use this stream. Using the logging macros\n-/// will emit output to stderr, and while they are line buffered the log\n-/// messages are always terminated in a newline (no need to flush).\n-pub fn flush() {\n-    with_task_stdout(|io| io.flush())\n-}\n-\n-/// Prints a string to the stdout of the current process. No newline is emitted\n-/// after the string is printed.\n-pub fn print(s: &str) {\n-    with_task_stdout(|io| io.write_all(s.as_bytes()))\n-}\n-\n-/// Prints a string to the stdout of the current process. A literal\n-/// `\\n` character is printed to the console after the string.\n-pub fn println(s: &str) {\n-    with_task_stdout(|io| {\n-        io.write_all(s.as_bytes()).and_then(|()| io.write_all(&[b'\\n']))\n-    })\n-}\n-\n-/// Similar to `print`, but takes a `fmt::Arguments` structure to be compatible\n-/// with the `format_args!` macro.\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub fn print_args(fmt: fmt::Arguments) {\n-    with_task_stdout(|io| write!(io, \"{}\", fmt))\n-}\n-\n-/// Similar to `println`, but takes a `fmt::Arguments` structure to be\n-/// compatible with the `format_args!` macro.\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub fn println_args(fmt: fmt::Arguments) {\n-    with_task_stdout(|io| writeln!(io, \"{}\", fmt))\n-}\n-\n-/// Representation of a reader of a standard input stream\n-pub struct StdReader {\n-    inner: StdSource\n-}\n-\n-impl StdReader {\n-    /// Returns whether this stream is attached to a TTY instance or not.\n-    pub fn isatty(&self) -> bool {\n-        match self.inner {\n-            TTY(..) => true,\n-            File(..) => false,\n-        }\n-    }\n-}\n-\n-impl Reader for StdReader {\n-    fn read(&mut self, buf: &mut [u8]) -> IoResult<usize> {\n-        let ret = match self.inner {\n-            TTY(ref mut tty) => {\n-                // Flush the task-local stdout so that weird issues like a\n-                // print!'d prompt not being shown until after the user hits\n-                // enter.\n-                flush();\n-                tty.read(buf).map(|i| i as usize)\n-            },\n-            File(ref mut file) => file.read(buf).map(|i| i as usize),\n-        };\n-        match ret {\n-            // When reading a piped stdin, libuv will return 0-length reads when\n-            // stdin reaches EOF. For pretty much all other streams it will\n-            // return an actual EOF error, but apparently for stdin it's a\n-            // little different. Hence, here we convert a 0 length read to an\n-            // end-of-file indicator so the caller knows to stop reading.\n-            Ok(0) => { Err(standard_error(EndOfFile)) }\n-            ret @ Ok(..) | ret @ Err(..) => ret,\n-        }\n-    }\n-}\n-\n-/// Representation of a writer to a standard output stream\n-pub struct StdWriter {\n-    inner: StdSource\n-}\n-\n-unsafe impl Send for StdWriter {}\n-unsafe impl Sync for StdWriter {}\n-\n-impl StdWriter {\n-    /// Gets the size of this output window, if possible. This is typically used\n-    /// when the writer is attached to something like a terminal, this is used\n-    /// to fetch the dimensions of the terminal.\n-    ///\n-    /// If successful, returns `Ok((width, height))`.\n-    ///\n-    /// # Error\n-    ///\n-    /// This function will return an error if the output stream is not actually\n-    /// connected to a TTY instance, or if querying the TTY instance fails.\n-    pub fn winsize(&mut self) -> IoResult<(isize, isize)> {\n-        match self.inner {\n-            TTY(ref mut tty) => {\n-                tty.get_winsize()\n-            }\n-            File(..) => {\n-                Err(IoError {\n-                    kind: OtherIoError,\n-                    desc: \"stream is not a tty\",\n-                    detail: None,\n-                })\n-            }\n-        }\n-    }\n-\n-    /// Controls whether this output stream is a \"raw stream\" or simply a normal\n-    /// stream.\n-    ///\n-    /// # Error\n-    ///\n-    /// This function will return an error if the output stream is not actually\n-    /// connected to a TTY instance, or if querying the TTY instance fails.\n-    pub fn set_raw(&mut self, raw: bool) -> IoResult<()> {\n-        match self.inner {\n-            TTY(ref mut tty) => {\n-                tty.set_raw(raw)\n-            }\n-            File(..) => {\n-                Err(IoError {\n-                    kind: OtherIoError,\n-                    desc: \"stream is not a tty\",\n-                    detail: None,\n-                })\n-            }\n-        }\n-    }\n-\n-    /// Returns whether this stream is attached to a TTY instance or not.\n-    pub fn isatty(&self) -> bool {\n-        match self.inner {\n-            TTY(..) => true,\n-            File(..) => false,\n-        }\n-    }\n-}\n-\n-impl Writer for StdWriter {\n-    fn write_all(&mut self, buf: &[u8]) -> IoResult<()> {\n-        // As with stdin on windows, stdout often can't handle writes of large\n-        // sizes. For an example, see #14940. For this reason, chunk the output\n-        // buffer on windows, but on unix we can just write the whole buffer all\n-        // at once.\n-        //\n-        // For some other references, it appears that this problem has been\n-        // encountered by others [1] [2]. We choose the number 8KB just because\n-        // libuv does the same.\n-        //\n-        // [1]: https://tahoe-lafs.org/trac/tahoe-lafs/ticket/1232\n-        // [2]: http://www.mail-archive.com/log4net-dev@logging.apache.org/msg00661.html\n-        let max_size = if cfg!(windows) {8192} else {usize::MAX};\n-        for chunk in buf.chunks(max_size) {\n-            try!(match self.inner {\n-                TTY(ref mut tty) => tty.write(chunk),\n-                File(ref mut file) => file.write(chunk),\n-            })\n-        }\n-        Ok(())\n-    }\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    use prelude::v1::*;\n-\n-    use super::*;\n-    use sync::mpsc::channel;\n-    use thread;\n-\n-    #[test]\n-    fn smoke() {\n-        // Just make sure we can acquire handles\n-        stdin();\n-        stdout();\n-        stderr();\n-    }\n-}"}, {"sha": "94faa5540bb30d538945a8e27b8c239a61345aee", "filename": "src/libstd/old_io/tempfile.rs", "status": "removed", "additions": 0, "deletions": 188, "changes": 188, "blob_url": "https://github.com/rust-lang/rust/blob/8415fa27877a4309a79b08c75a52eb4c3546b7a5/src%2Flibstd%2Fold_io%2Ftempfile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8415fa27877a4309a79b08c75a52eb4c3546b7a5/src%2Flibstd%2Fold_io%2Ftempfile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Ftempfile.rs?ref=8415fa27877a4309a79b08c75a52eb4c3546b7a5", "patch": "@@ -1,188 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Temporary files and directories\n-#![allow(deprecated)] // rand\n-\n-use env;\n-use iter::Iterator;\n-use old_io::{fs, IoError, IoErrorKind, IoResult};\n-use old_io;\n-use ops::Drop;\n-use option::Option::{None, Some};\n-use option::Option;\n-use old_path::{Path, GenericPath};\n-use rand::{Rng, thread_rng};\n-use result::Result::{Ok, Err};\n-use string::String;\n-\n-/// A wrapper for a path to temporary directory implementing automatic\n-/// scope-based deletion.\n-///\n-/// # Examples\n-///\n-/// ```no_run\n-/// # #![feature(old_io, old_path)]\n-/// use std::old_io::*;\n-/// use std::old_path::{Path, GenericPath};\n-///\n-/// {\n-///     // create a temporary directory\n-///     let tmpdir = match TempDir::new(\"myprefix\") {\n-///         Ok(dir) => dir,\n-///         Err(e) => panic!(\"couldn't create temporary directory: {}\", e)\n-///     };\n-///\n-///     // get the path of the temporary directory without affecting the wrapper\n-///     let tmppath = tmpdir.path();\n-///\n-///     println!(\"The path of temporary directory is {}\", tmppath.display());\n-///\n-///     // the temporary directory is automatically removed when tmpdir goes\n-///     // out of scope at the end of the block\n-/// }\n-/// {\n-///     // create a temporary directory, this time using a custom path\n-///     let tmpdir = match TempDir::new_in(&Path::new(\"/tmp/best/custom/path\"), \"myprefix\") {\n-///         Ok(dir) => dir,\n-///         Err(e) => panic!(\"couldn't create temporary directory: {}\", e)\n-///     };\n-///\n-///     // get the path of the temporary directory and disable automatic deletion in the wrapper\n-///     let tmppath = tmpdir.into_inner();\n-///\n-///     println!(\"The path of the not-so-temporary directory is {}\", tmppath.display());\n-///\n-///     // the temporary directory is not removed here\n-///     // because the directory is detached from the wrapper\n-/// }\n-/// {\n-///     // create a temporary directory\n-///     let tmpdir = match TempDir::new(\"myprefix\") {\n-///         Ok(dir) => dir,\n-///         Err(e) => panic!(\"couldn't create temporary directory: {}\", e)\n-///     };\n-///\n-///     // close the temporary directory manually and check the result\n-///     match tmpdir.close() {\n-///         Ok(_) => println!(\"success!\"),\n-///         Err(e) => panic!(\"couldn't remove temporary directory: {}\", e)\n-///     };\n-/// }\n-/// ```\n-pub struct TempDir {\n-    path: Option<Path>,\n-    disarmed: bool\n-}\n-\n-// How many times should we (re)try finding an unused random name? It should be\n-// enough that an attacker will run out of luck before we run out of patience.\n-const NUM_RETRIES: u32 = 1 << 31;\n-// How many characters should we include in a random file name? It needs to\n-// be enough to dissuade an attacker from trying to preemptively create names\n-// of that length, but not so huge that we unnecessarily drain the random number\n-// generator of entropy.\n-const NUM_RAND_CHARS: usize = 12;\n-\n-impl TempDir {\n-    /// Attempts to make a temporary directory inside of `tmpdir` whose name\n-    /// will have the prefix `prefix`. The directory will be automatically\n-    /// deleted once the returned wrapper is destroyed.\n-    ///\n-    /// If no directory can be created, `Err` is returned.\n-    #[allow(deprecated)]\n-    pub fn new_in(tmpdir: &Path, prefix: &str) -> IoResult<TempDir> {\n-        if !tmpdir.is_absolute() {\n-            let cur_dir = ::env::current_dir().unwrap();\n-            let cur_dir = Path::new(cur_dir.to_str().unwrap());\n-            return TempDir::new_in(&cur_dir.join(tmpdir), prefix);\n-        }\n-\n-        let mut rng = thread_rng();\n-        for _ in 0..NUM_RETRIES {\n-            let suffix: String = rng.gen_ascii_chars().take(NUM_RAND_CHARS).collect();\n-            let leaf = if prefix.len() > 0 {\n-                format!(\"{}.{}\", prefix, suffix)\n-            } else {\n-                // If we're given an empty string for a prefix, then creating a\n-                // directory starting with \".\" would lead to it being\n-                // semi-invisible on some systems.\n-                suffix\n-            };\n-            let path = tmpdir.join(leaf);\n-            match fs::mkdir(&path, old_io::USER_RWX) {\n-                Ok(_) => return Ok(TempDir { path: Some(path), disarmed: false }),\n-                Err(IoError{kind:IoErrorKind::PathAlreadyExists,..}) => (),\n-                Err(e) => return Err(e)\n-            }\n-        }\n-\n-        return Err(IoError{\n-                       kind: IoErrorKind::PathAlreadyExists,\n-                       desc:\"Exhausted\",\n-                       detail: None});\n-    }\n-\n-    /// Attempts to make a temporary directory inside of `os::tmpdir()` whose\n-    /// name will have the prefix `prefix`. The directory will be automatically\n-    /// deleted once the returned wrapper is destroyed.\n-    ///\n-    /// If no directory can be created, `Err` is returned.\n-    #[allow(deprecated)]\n-    pub fn new(prefix: &str) -> IoResult<TempDir> {\n-        let tmp = Path::new(::env::temp_dir().to_str().unwrap());\n-        TempDir::new_in(&tmp, prefix)\n-    }\n-\n-    /// Unwrap the wrapped `std::path::Path` from the `TempDir` wrapper.\n-    /// This discards the wrapper so that the automatic deletion of the\n-    /// temporary directory is prevented.\n-    pub fn into_inner(self) -> Path {\n-        let mut tmpdir = self;\n-        tmpdir.path.take().unwrap()\n-    }\n-\n-    /// Access the wrapped `std::path::Path` to the temporary directory.\n-    pub fn path<'a>(&'a self) -> &'a Path {\n-        self.path.as_ref().unwrap()\n-    }\n-\n-    /// Close and remove the temporary directory\n-    ///\n-    /// Although `TempDir` removes the directory on drop, in the destructor\n-    /// any errors are ignored. To detect errors cleaning up the temporary\n-    /// directory, call `close` instead.\n-    pub fn close(mut self) -> IoResult<()> {\n-        self.cleanup_dir()\n-    }\n-\n-    fn cleanup_dir(&mut self) -> IoResult<()> {\n-        assert!(!self.disarmed);\n-        self.disarmed = true;\n-        match self.path {\n-            Some(ref p) => {\n-                fs::rmdir_recursive(p)\n-            }\n-            None => Ok(())\n-        }\n-    }\n-}\n-\n-impl Drop for TempDir {\n-    fn drop(&mut self) {\n-        if !self.disarmed {\n-            let _ = self.cleanup_dir();\n-        }\n-    }\n-}\n-\n-// the tests for this module need to change the path using change_dir,\n-// and this doesn't play nicely with other tests so these unit tests are located\n-// in src/test/run-pass/tempfile.rs"}, {"sha": "312e1c814dc58e730c588e446da5dbcd877879ce", "filename": "src/libstd/old_io/test.rs", "status": "removed", "additions": 0, "deletions": 177, "changes": 177, "blob_url": "https://github.com/rust-lang/rust/blob/8415fa27877a4309a79b08c75a52eb4c3546b7a5/src%2Flibstd%2Fold_io%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8415fa27877a4309a79b08c75a52eb4c3546b7a5/src%2Flibstd%2Fold_io%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Ftest.rs?ref=8415fa27877a4309a79b08c75a52eb4c3546b7a5", "patch": "@@ -1,177 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Various utility functions useful for writing I/O tests\n-\n-use prelude::v1::*;\n-\n-use env;\n-use libc;\n-use old_io::net::ip::*;\n-use old_path::{Path, GenericPath};\n-use sync::atomic::{AtomicUsize, ATOMIC_USIZE_INIT, Ordering};\n-\n-/// Get a port number, starting at 9600, for use in tests\n-pub fn next_test_port() -> u16 {\n-    static NEXT_OFFSET: AtomicUsize = ATOMIC_USIZE_INIT;\n-    base_port() + NEXT_OFFSET.fetch_add(1, Ordering::Relaxed) as u16\n-}\n-\n-// iOS has a pretty long tmpdir path which causes pipe creation\n-// to like: invalid argument: path must be smaller than SUN_LEN\n-fn next_test_unix_socket() -> String {\n-    static COUNT: AtomicUsize = ATOMIC_USIZE_INIT;\n-    // base port and pid are an attempt to be unique between multiple\n-    // test-runners of different configurations running on one\n-    // buildbot, the count is to be unique within this executable.\n-    format!(\"rust-test-unix-path-{}-{}-{}\",\n-            base_port(),\n-            unsafe {libc::getpid()},\n-            COUNT.fetch_add(1, Ordering::Relaxed))\n-}\n-\n-/// Get a temporary path which could be the location of a unix socket\n-#[cfg(not(target_os = \"ios\"))]\n-#[allow(deprecated)]\n-pub fn next_test_unix() -> Path {\n-    let string = next_test_unix_socket();\n-    if cfg!(unix) {\n-        Path::new(::env::temp_dir().to_str().unwrap()).join(string)\n-    } else {\n-        Path::new(format!(\"{}{}\", r\"\\\\.\\pipe\\\", string))\n-    }\n-}\n-\n-/// Get a temporary path which could be the location of a unix socket\n-#[cfg(target_os = \"ios\")]\n-pub fn next_test_unix() -> Path {\n-    Path::new(format!(\"/var/tmp/{}\", next_test_unix_socket()))\n-}\n-\n-/// Get a unique IPv4 localhost:port pair starting at 9600\n-pub fn next_test_ip4() -> SocketAddr {\n-    SocketAddr { ip: Ipv4Addr(127, 0, 0, 1), port: next_test_port() }\n-}\n-\n-/// Get a unique IPv6 localhost:port pair starting at 9600\n-pub fn next_test_ip6() -> SocketAddr {\n-    SocketAddr { ip: Ipv6Addr(0, 0, 0, 0, 0, 0, 0, 1), port: next_test_port() }\n-}\n-\n-/*\n-XXX: Welcome to MegaHack City.\n-\n-The bots run multiple builds at the same time, and these builds\n-all want to use ports. This function figures out which workspace\n-it is running in and assigns a port range based on it.\n-*/\n-fn base_port() -> u16 {\n-\n-    let base = 9600;\n-    let range = 1000;\n-\n-    let bases = [\n-        (\"32-opt\", base + range * 1),\n-        (\"32-nopt\", base + range * 2),\n-        (\"64-opt\", base + range * 3),\n-        (\"64-nopt\", base + range * 4),\n-        (\"64-opt-vg\", base + range * 5),\n-        (\"all-opt\", base + range * 6),\n-        (\"snap3\", base + range * 7),\n-        (\"dist\", base + range * 8)\n-    ];\n-\n-    // FIXME (#9639): This needs to handle non-utf8 paths\n-    let path = env::current_dir().unwrap();\n-    let path_s = path.to_str().unwrap();\n-\n-    let mut final_base = base;\n-\n-    for &(dir, base) in &bases {\n-        if path_s.contains(dir) {\n-            final_base = base;\n-            break;\n-        }\n-    }\n-\n-    return final_base;\n-}\n-\n-/// Raises the file descriptor limit when running tests if necessary\n-pub fn raise_fd_limit() {\n-    unsafe { darwin_fd_limit::raise_fd_limit() }\n-}\n-\n-/// darwin_fd_limit exists to work around an issue where launchctl on Mac OS X defaults the rlimit\n-/// maxfiles to 256/unlimited. The default soft limit of 256 ends up being far too low for our\n-/// multithreaded scheduler testing, depending on the number of cores available.\n-///\n-/// This fixes issue #7772.\n-#[cfg(any(target_os = \"macos\", target_os = \"ios\"))]\n-#[allow(non_camel_case_types)]\n-mod darwin_fd_limit {\n-    use libc;\n-    type rlim_t = libc::uint64_t;\n-    #[repr(C)]\n-    struct rlimit {\n-        rlim_cur: rlim_t,\n-        rlim_max: rlim_t\n-    }\n-    extern {\n-        // name probably doesn't need to be mut, but the C function doesn't specify const\n-        fn sysctl(name: *mut libc::c_int, namelen: libc::c_uint,\n-                  oldp: *mut libc::c_void, oldlenp: *mut libc::size_t,\n-                  newp: *mut libc::c_void, newlen: libc::size_t) -> libc::c_int;\n-        fn getrlimit(resource: libc::c_int, rlp: *mut rlimit) -> libc::c_int;\n-        fn setrlimit(resource: libc::c_int, rlp: *const rlimit) -> libc::c_int;\n-    }\n-    static CTL_KERN: libc::c_int = 1;\n-    static KERN_MAXFILESPERPROC: libc::c_int = 29;\n-    static RLIMIT_NOFILE: libc::c_int = 8;\n-\n-    pub unsafe fn raise_fd_limit() {\n-        // The strategy here is to fetch the current resource limits, read the kern.maxfilesperproc\n-        // sysctl value, and bump the soft resource limit for maxfiles up to the sysctl value.\n-        use ptr::null_mut;\n-        use mem::size_of_val;\n-        use io;\n-\n-        // Fetch the kern.maxfilesperproc value\n-        let mut mib: [libc::c_int; 2] = [CTL_KERN, KERN_MAXFILESPERPROC];\n-        let mut maxfiles: libc::c_int = 0;\n-        let mut size: libc::size_t = size_of_val(&maxfiles) as libc::size_t;\n-        if sysctl(&mut mib[0], 2, &mut maxfiles as *mut libc::c_int as *mut libc::c_void, &mut size,\n-                  null_mut(), 0) != 0 {\n-            let err = io::Error::last_os_error();\n-            panic!(\"raise_fd_limit: error calling sysctl: {}\", err);\n-        }\n-\n-        // Fetch the current resource limits\n-        let mut rlim = rlimit{rlim_cur: 0, rlim_max: 0};\n-        if getrlimit(RLIMIT_NOFILE, &mut rlim) != 0 {\n-            let err = io::Error::last_os_error();\n-            panic!(\"raise_fd_limit: error calling getrlimit: {}\", err);\n-        }\n-\n-        // Bump the soft limit to the smaller of kern.maxfilesperproc and the hard limit\n-        rlim.rlim_cur = ::cmp::min(maxfiles as rlim_t, rlim.rlim_max);\n-\n-        // Set our newly-increased resource limit\n-        if setrlimit(RLIMIT_NOFILE, &rlim) != 0 {\n-            let err = io::Error::last_os_error();\n-            panic!(\"raise_fd_limit: error calling setrlimit: {}\", err);\n-        }\n-    }\n-}\n-\n-#[cfg(not(any(target_os = \"macos\", target_os = \"ios\")))]\n-mod darwin_fd_limit {\n-    pub unsafe fn raise_fd_limit() {}\n-}"}, {"sha": "f8cba0444433175b02a141ed88cdd62b234b81c5", "filename": "src/libstd/old_io/timer.rs", "status": "removed", "additions": 0, "deletions": 488, "changes": 488, "blob_url": "https://github.com/rust-lang/rust/blob/8415fa27877a4309a79b08c75a52eb4c3546b7a5/src%2Flibstd%2Fold_io%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8415fa27877a4309a79b08c75a52eb4c3546b7a5/src%2Flibstd%2Fold_io%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Ftimer.rs?ref=8415fa27877a4309a79b08c75a52eb4c3546b7a5", "patch": "@@ -1,488 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Synchronous Timers\n-//!\n-//! This module exposes the functionality to create timers, block the current task,\n-//! and create receivers which will receive notifications after a period of time.\n-\n-// FIXME: These functions take Durations but only pass ms to the backend impls.\n-\n-use boxed::Box;\n-use sync::mpsc::{Receiver, Sender, channel};\n-use time::Duration;\n-use old_io::IoResult;\n-use sys::timer::Callback;\n-use sys::timer::Timer as TimerImp;\n-\n-/// A synchronous timer object\n-///\n-/// Values of this type can be used to put the current task to sleep for a\n-/// period of time. Handles to this timer can also be created in the form of\n-/// receivers which will receive notifications over time.\n-///\n-/// # Examples\n-///\n-/// ```\n-/// # #![feature(old_io, std_misc)]\n-/// # fn foo() {\n-/// use std::old_io::Timer;\n-/// use std::time::Duration;\n-///\n-/// let mut timer = Timer::new().unwrap();\n-/// timer.sleep(Duration::milliseconds(10)); // block the task for awhile\n-///\n-/// let timeout = timer.oneshot(Duration::milliseconds(10));\n-/// // do some work\n-/// timeout.recv().unwrap(); // wait for the timeout to expire\n-///\n-/// let periodic = timer.periodic(Duration::milliseconds(10));\n-/// loop {\n-///     periodic.recv().unwrap();\n-///     // this loop is only executed once every 10ms\n-/// }\n-/// # }\n-/// ```\n-///\n-/// If only sleeping is necessary, then a convenience API is provided through\n-/// the `old_io::timer` module.\n-///\n-/// ```\n-/// # #![feature(old_io, std_misc)]\n-/// # fn foo() {\n-/// use std::old_io::timer;\n-/// use std::time::Duration;\n-///\n-/// // Put this task to sleep for 5 seconds\n-/// timer::sleep(Duration::seconds(5));\n-/// # }\n-/// ```\n-pub struct Timer {\n-    inner: TimerImp,\n-}\n-\n-struct TimerCallback { tx: Sender<()> }\n-\n-/// Sleep the current task for the specified duration.\n-///\n-/// When provided a zero or negative `duration`, the function will\n-/// return immediately.\n-pub fn sleep(duration: Duration) {\n-    let timer = Timer::new();\n-    let mut timer = timer.ok().expect(\"timer::sleep: could not create a Timer\");\n-\n-    timer.sleep(duration)\n-}\n-\n-impl Timer {\n-    /// Creates a new timer which can be used to put the current task to sleep\n-    /// for a number of milliseconds, or to possibly create channels which will\n-    /// get notified after an amount of time has passed.\n-    pub fn new() -> IoResult<Timer> {\n-        TimerImp::new().map(|t| Timer { inner: t })\n-    }\n-\n-    /// Blocks the current task for the specified duration.\n-    ///\n-    /// Note that this function will cause any other receivers for this timer to\n-    /// be invalidated (the other end will be closed).\n-    ///\n-    /// When provided a zero or negative `duration`, the function will\n-    /// return immediately.\n-    pub fn sleep(&mut self, duration: Duration) {\n-        // Short-circuit the timer backend for 0 duration\n-        let ms = in_ms_u64(duration);\n-        if ms == 0 { return }\n-        self.inner.sleep(ms);\n-    }\n-\n-    /// Creates a oneshot receiver which will have a notification sent when\n-    /// the specified duration has elapsed.\n-    ///\n-    /// This does *not* block the current task, but instead returns immediately.\n-    ///\n-    /// Note that this invalidates any previous receiver which has been created\n-    /// by this timer, and that the returned receiver will be invalidated once\n-    /// the timer is destroyed (when it falls out of scope). In particular, if\n-    /// this is called in method-chaining style, the receiver will be\n-    /// invalidated at the end of that statement, and all `recv` calls will\n-    /// fail.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// # #![feature(old_io, std_misc)]\n-    /// use std::old_io::Timer;\n-    /// use std::time::Duration;\n-    ///\n-    /// let mut timer = Timer::new().unwrap();\n-    /// let ten_milliseconds = timer.oneshot(Duration::milliseconds(10));\n-    ///\n-    /// for _ in 0..100 { /* do work */ }\n-    ///\n-    /// // blocks until 10 ms after the `oneshot` call\n-    /// ten_milliseconds.recv().unwrap();\n-    /// ```\n-    ///\n-    /// ```\n-    /// # #![feature(old_io, std_misc)]\n-    /// use std::old_io::Timer;\n-    /// use std::time::Duration;\n-    ///\n-    /// // Incorrect, method chaining-style:\n-    /// let mut five_ms = Timer::new().unwrap().oneshot(Duration::milliseconds(5));\n-    /// // The timer object was destroyed, so this will always fail:\n-    /// // five_ms.recv().unwrap()\n-    /// ```\n-    ///\n-    /// When provided a zero or negative `duration`, the message will\n-    /// be sent immediately.\n-    pub fn oneshot(&mut self, duration: Duration) -> Receiver<()> {\n-        let (tx, rx) = channel();\n-        // Short-circuit the timer backend for 0 duration\n-        if in_ms_u64(duration) != 0 {\n-            self.inner.oneshot(in_ms_u64(duration), Box::new(TimerCallback { tx: tx }));\n-        } else {\n-            tx.send(()).unwrap();\n-        }\n-        return rx\n-    }\n-\n-    /// Creates a receiver which will have a continuous stream of notifications\n-    /// being sent each time the specified duration has elapsed.\n-    ///\n-    /// This does *not* block the current task, but instead returns\n-    /// immediately. The first notification will not be received immediately,\n-    /// but rather after the first duration.\n-    ///\n-    /// Note that this invalidates any previous receiver which has been created\n-    /// by this timer, and that the returned receiver will be invalidated once\n-    /// the timer is destroyed (when it falls out of scope). In particular, if\n-    /// this is called in method-chaining style, the receiver will be\n-    /// invalidated at the end of that statement, and all `recv` calls will\n-    /// fail.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// # #![feature(old_io, std_misc)]\n-    /// use std::old_io::Timer;\n-    /// use std::time::Duration;\n-    ///\n-    /// let mut timer = Timer::new().unwrap();\n-    /// let ten_milliseconds = timer.periodic(Duration::milliseconds(10));\n-    ///\n-    /// for _ in 0..100 { /* do work */ }\n-    ///\n-    /// // blocks until 10 ms after the `periodic` call\n-    /// ten_milliseconds.recv().unwrap();\n-    ///\n-    /// for _ in 0..100 { /* do work */ }\n-    ///\n-    /// // blocks until 20 ms after the `periodic` call (*not* 10ms after the\n-    /// // previous `recv`)\n-    /// ten_milliseconds.recv().unwrap();\n-    /// ```\n-    ///\n-    /// ```\n-    /// # #![feature(old_io, std_misc)]\n-    /// use std::old_io::Timer;\n-    /// use std::time::Duration;\n-    ///\n-    /// // Incorrect, method chaining-style.\n-    /// let mut five_ms = Timer::new().unwrap().periodic(Duration::milliseconds(5));\n-    /// // The timer object was destroyed, so this will always fail:\n-    /// // five_ms.recv().unwrap()\n-    /// ```\n-    ///\n-    /// When provided a zero or negative `duration`, the messages will\n-    /// be sent without delay.\n-    pub fn periodic(&mut self, duration: Duration) -> Receiver<()> {\n-        let ms = in_ms_u64(duration);\n-        // FIXME: The backend implementations don't ever send a message\n-        // if given a 0 ms duration. Temporarily using 1ms. It's\n-        // not clear what use a 0ms period is anyway...\n-        let ms = if ms == 0 { 1 } else { ms };\n-        let (tx, rx) = channel();\n-        self.inner.period(ms, Box::new(TimerCallback { tx: tx }));\n-        return rx\n-    }\n-}\n-\n-impl Callback for TimerCallback {\n-    fn call(&mut self) {\n-        let _ = self.tx.send(());\n-    }\n-}\n-\n-fn in_ms_u64(d: Duration) -> u64 {\n-    let ms = d.num_milliseconds();\n-    if ms < 0 { return 0 };\n-    return ms as u64;\n-}\n-\n-#[cfg(test)]\n-mod test {\n-    use super::Timer;\n-    use thread;\n-    use time::Duration;\n-\n-    #[test]\n-    fn test_timer_send() {\n-        let mut timer = Timer::new().unwrap();\n-        thread::spawn(move || timer.sleep(Duration::milliseconds(1)));\n-    }\n-\n-    #[test]\n-    fn test_io_timer_sleep_simple() {\n-        let mut timer = Timer::new().unwrap();\n-        timer.sleep(Duration::milliseconds(1));\n-    }\n-\n-    #[test]\n-    fn test_io_timer_sleep_oneshot() {\n-        let mut timer = Timer::new().unwrap();\n-        timer.oneshot(Duration::milliseconds(1)).recv().unwrap();\n-    }\n-\n-    #[test]\n-    fn test_io_timer_sleep_oneshot_forget() {\n-        let mut timer = Timer::new().unwrap();\n-        timer.oneshot(Duration::milliseconds(100000000));\n-    }\n-\n-    #[test]\n-    fn oneshot_twice() {\n-        let mut timer = Timer::new().unwrap();\n-        let rx1 = timer.oneshot(Duration::milliseconds(10000));\n-        let rx = timer.oneshot(Duration::milliseconds(1));\n-        rx.recv().unwrap();\n-        assert!(rx1.recv().is_err());\n-    }\n-\n-    #[test]\n-    fn test_io_timer_oneshot_then_sleep() {\n-        let mut timer = Timer::new().unwrap();\n-        let rx = timer.oneshot(Duration::milliseconds(100000000));\n-        timer.sleep(Duration::milliseconds(1)); // this should invalidate rx\n-\n-        assert!(rx.recv().is_err());\n-    }\n-\n-    #[test]\n-    fn test_io_timer_sleep_periodic() {\n-        let mut timer = Timer::new().unwrap();\n-        let rx = timer.periodic(Duration::milliseconds(1));\n-        rx.recv().unwrap();\n-        rx.recv().unwrap();\n-        rx.recv().unwrap();\n-    }\n-\n-    #[test]\n-    fn test_io_timer_sleep_periodic_forget() {\n-        let mut timer = Timer::new().unwrap();\n-        timer.periodic(Duration::milliseconds(100000000));\n-    }\n-\n-    #[test]\n-    fn test_io_timer_sleep_standalone() {\n-        super::sleep(Duration::milliseconds(1))\n-    }\n-\n-    #[test]\n-    fn oneshot() {\n-        let mut timer = Timer::new().unwrap();\n-\n-        let rx = timer.oneshot(Duration::milliseconds(1));\n-        rx.recv().unwrap();\n-        assert!(rx.recv().is_err());\n-\n-        let rx = timer.oneshot(Duration::milliseconds(1));\n-        rx.recv().unwrap();\n-        assert!(rx.recv().is_err());\n-    }\n-\n-    #[test]\n-    fn test_override() {\n-        let mut timer = Timer::new().unwrap();\n-        let orx = timer.oneshot(Duration::milliseconds(100));\n-        let prx = timer.periodic(Duration::milliseconds(100));\n-        timer.sleep(Duration::milliseconds(1));\n-        assert!(orx.recv().is_err());\n-        assert!(prx.recv().is_err());\n-        timer.oneshot(Duration::milliseconds(1)).recv().unwrap();\n-    }\n-\n-    #[test]\n-    fn period() {\n-        let mut timer = Timer::new().unwrap();\n-        let rx = timer.periodic(Duration::milliseconds(1));\n-        rx.recv().unwrap();\n-        rx.recv().unwrap();\n-        let rx2 = timer.periodic(Duration::milliseconds(1));\n-        rx2.recv().unwrap();\n-        rx2.recv().unwrap();\n-    }\n-\n-    #[test]\n-    fn sleep() {\n-        let mut timer = Timer::new().unwrap();\n-        timer.sleep(Duration::milliseconds(1));\n-        timer.sleep(Duration::milliseconds(1));\n-    }\n-\n-    #[test]\n-    #[should_panic]\n-    fn oneshot_fail() {\n-        let mut timer = Timer::new().unwrap();\n-        let _rx = timer.oneshot(Duration::milliseconds(1));\n-        panic!();\n-    }\n-\n-    #[test]\n-    #[should_panic]\n-    fn period_fail() {\n-        let mut timer = Timer::new().unwrap();\n-        let _rx = timer.periodic(Duration::milliseconds(1));\n-        panic!();\n-    }\n-\n-    #[test]\n-    #[should_panic]\n-    fn normal_fail() {\n-        let _timer = Timer::new().unwrap();\n-        panic!();\n-    }\n-\n-    #[test]\n-    fn closing_channel_during_drop_doesnt_kill_everything() {\n-        // see issue #10375\n-        let mut timer = Timer::new().unwrap();\n-        let timer_rx = timer.periodic(Duration::milliseconds(1000));\n-\n-        thread::spawn(move|| {\n-            let _ = timer_rx.recv();\n-        });\n-\n-        // when we drop the TimerWatcher we're going to destroy the channel,\n-        // which must wake up the task on the other end\n-    }\n-\n-    #[test]\n-    fn reset_doesnt_switch_tasks() {\n-        // similar test to the one above.\n-        let mut timer = Timer::new().unwrap();\n-        let timer_rx = timer.periodic(Duration::milliseconds(1000));\n-\n-        thread::spawn(move|| {\n-            let _ = timer_rx.recv();\n-        });\n-\n-        timer.oneshot(Duration::milliseconds(1));\n-    }\n-\n-    #[test]\n-    fn reset_doesnt_switch_tasks2() {\n-        // similar test to the one above.\n-        let mut timer = Timer::new().unwrap();\n-        let timer_rx = timer.periodic(Duration::milliseconds(1000));\n-\n-        thread::spawn(move|| {\n-            let _ = timer_rx.recv();\n-        });\n-\n-        timer.sleep(Duration::milliseconds(1));\n-    }\n-\n-    #[test]\n-    fn sender_goes_away_oneshot() {\n-        let rx = {\n-            let mut timer = Timer::new().unwrap();\n-            timer.oneshot(Duration::milliseconds(1000))\n-        };\n-        assert!(rx.recv().is_err());\n-    }\n-\n-    #[test]\n-    fn sender_goes_away_period() {\n-        let rx = {\n-            let mut timer = Timer::new().unwrap();\n-            timer.periodic(Duration::milliseconds(1000))\n-        };\n-        assert!(rx.recv().is_err());\n-    }\n-\n-    #[test]\n-    fn receiver_goes_away_oneshot() {\n-        let mut timer1 = Timer::new().unwrap();\n-        timer1.oneshot(Duration::milliseconds(1));\n-        let mut timer2 = Timer::new().unwrap();\n-        // while sleeping, the previous timer should fire and not have its\n-        // callback do something terrible.\n-        timer2.sleep(Duration::milliseconds(2));\n-    }\n-\n-    #[test]\n-    fn receiver_goes_away_period() {\n-        let mut timer1 = Timer::new().unwrap();\n-        timer1.periodic(Duration::milliseconds(1));\n-        let mut timer2 = Timer::new().unwrap();\n-        // while sleeping, the previous timer should fire and not have its\n-        // callback do something terrible.\n-        timer2.sleep(Duration::milliseconds(2));\n-    }\n-\n-    #[test]\n-    fn sleep_zero() {\n-        let mut timer = Timer::new().unwrap();\n-        timer.sleep(Duration::milliseconds(0));\n-    }\n-\n-    #[test]\n-    fn sleep_negative() {\n-        let mut timer = Timer::new().unwrap();\n-        timer.sleep(Duration::milliseconds(-1000000));\n-    }\n-\n-    #[test]\n-    fn oneshot_zero() {\n-        let mut timer = Timer::new().unwrap();\n-        let rx = timer.oneshot(Duration::milliseconds(0));\n-        rx.recv().unwrap();\n-    }\n-\n-    #[test]\n-    fn oneshot_negative() {\n-        let mut timer = Timer::new().unwrap();\n-        let rx = timer.oneshot(Duration::milliseconds(-1000000));\n-        rx.recv().unwrap();\n-    }\n-\n-    #[test]\n-    fn periodic_zero() {\n-        let mut timer = Timer::new().unwrap();\n-        let rx = timer.periodic(Duration::milliseconds(0));\n-        rx.recv().unwrap();\n-        rx.recv().unwrap();\n-        rx.recv().unwrap();\n-        rx.recv().unwrap();\n-    }\n-\n-    #[test]\n-    fn periodic_negative() {\n-        let mut timer = Timer::new().unwrap();\n-        let rx = timer.periodic(Duration::milliseconds(-1000000));\n-        rx.recv().unwrap();\n-        rx.recv().unwrap();\n-        rx.recv().unwrap();\n-        rx.recv().unwrap();\n-    }\n-\n-}"}, {"sha": "818c8e76d6087aff50dbe3ae3e3675159bc5b0dd", "filename": "src/libstd/old_io/util.rs", "status": "removed", "additions": 0, "deletions": 495, "changes": 495, "blob_url": "https://github.com/rust-lang/rust/blob/8415fa27877a4309a79b08c75a52eb4c3546b7a5/src%2Flibstd%2Fold_io%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8415fa27877a4309a79b08c75a52eb4c3546b7a5/src%2Flibstd%2Fold_io%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Futil.rs?ref=8415fa27877a4309a79b08c75a52eb4c3546b7a5", "patch": "@@ -1,495 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Utility implementations of Reader and Writer\n-\n-#![allow(deprecated)]\n-\n-use prelude::v1::*;\n-use cmp;\n-use old_io::{self, Reader, Writer, Buffer};\n-use slice::bytes::MutableByteVector;\n-\n-/// Wraps a `Reader`, limiting the number of bytes that can be read from it.\n-#[derive(Debug)]\n-#[deprecated(since = \"1.0.0\", reason = \"use std::io::Take\")]\n-#[unstable(feature = \"old_io\")]\n-pub struct LimitReader<R> {\n-    limit: usize,\n-    inner: R\n-}\n-\n-#[deprecated(since = \"1.0.0\", reason = \"use std::io::Take\")]\n-#[unstable(feature = \"old_io\")]\n-impl<R: Reader> LimitReader<R> {\n-    /// Creates a new `LimitReader`\n-    #[deprecated(since = \"1.0.0\", reason = \"use std::io's take method instead\")]\n-    #[unstable(feature = \"old_io\")]\n-    pub fn new(r: R, limit: usize) -> LimitReader<R> {\n-        LimitReader { limit: limit, inner: r }\n-    }\n-\n-    /// Consumes the `LimitReader`, returning the underlying `Reader`.\n-    pub fn into_inner(self) -> R { self.inner }\n-\n-    /// Returns the number of bytes that can be read before the `LimitReader`\n-    /// will return EOF.\n-    ///\n-    /// # Note\n-    ///\n-    /// The reader may reach EOF after reading fewer bytes than indicated by\n-    /// this method if the underlying reader reaches EOF.\n-    pub fn limit(&self) -> usize { self.limit }\n-}\n-\n-#[deprecated(since = \"1.0.0\", reason = \"use std::io's take method instead\")]\n-#[unstable(feature = \"old_io\")]\n-impl<R: Reader> Reader for LimitReader<R> {\n-    fn read(&mut self, buf: &mut [u8]) -> old_io::IoResult<usize> {\n-        if self.limit == 0 {\n-            return Err(old_io::standard_error(old_io::EndOfFile));\n-        }\n-\n-        let len = cmp::min(self.limit, buf.len());\n-        let res = self.inner.read(&mut buf[..len]);\n-        match res {\n-            Ok(len) => self.limit -= len,\n-            _ => {}\n-        }\n-        res\n-    }\n-}\n-\n-#[deprecated(since = \"1.0.0\", reason = \"use std::io's take method instead\")]\n-#[unstable(feature = \"old_io\")]\n-impl<R: Buffer> Buffer for LimitReader<R> {\n-    fn fill_buf<'a>(&'a mut self) -> old_io::IoResult<&'a [u8]> {\n-        let amt = try!(self.inner.fill_buf());\n-        let buf = &amt[..cmp::min(amt.len(), self.limit)];\n-        if buf.len() == 0 {\n-            Err(old_io::standard_error(old_io::EndOfFile))\n-        } else {\n-            Ok(buf)\n-        }\n-    }\n-\n-    fn consume(&mut self, amt: usize) {\n-        // Don't let callers reset the limit by passing an overlarge value\n-        let amt = cmp::min(amt, self.limit);\n-        self.limit -= amt;\n-        self.inner.consume(amt);\n-    }\n-\n-}\n-\n-/// A `Writer` which ignores bytes written to it, like /dev/null.\n-#[derive(Copy, Clone, Debug)]\n-#[deprecated(since = \"1.0.0\", reason = \"use std::io::sink() instead\")]\n-#[unstable(feature = \"old_io\")]\n-pub struct NullWriter;\n-\n-#[deprecated(since = \"1.0.0\", reason = \"use std::io::sink() instead\")]\n-#[unstable(feature = \"old_io\")]\n-impl Writer for NullWriter {\n-    #[inline]\n-    fn write_all(&mut self, _buf: &[u8]) -> old_io::IoResult<()> { Ok(()) }\n-}\n-\n-/// A `Reader` which returns an infinite stream of 0 bytes, like /dev/zero.\n-#[derive(Copy, Clone, Debug)]\n-#[deprecated(since = \"1.0.0\", reason = \"use std::io::repeat(0) instead\")]\n-#[unstable(feature = \"old_io\")]\n-pub struct ZeroReader;\n-\n-#[deprecated(since = \"1.0.0\", reason = \"use std::io::repeat(0) instead\")]\n-#[unstable(feature = \"old_io\")]\n-impl Reader for ZeroReader {\n-    #[inline]\n-    fn read(&mut self, buf: &mut [u8]) -> old_io::IoResult<usize> {\n-        buf.set_memory(0);\n-        Ok(buf.len())\n-    }\n-}\n-\n-#[deprecated(since = \"1.0.0\", reason = \"use std::io::repeat(0) instead\")]\n-#[unstable(feature = \"old_io\")]\n-impl Buffer for ZeroReader {\n-    fn fill_buf<'a>(&'a mut self) -> old_io::IoResult<&'a [u8]> {\n-        static DATA: [u8; 64] = [0; 64];\n-        Ok(&DATA)\n-    }\n-\n-    fn consume(&mut self, _amt: usize) {}\n-}\n-\n-/// A `Reader` which is always at EOF, like /dev/null.\n-#[derive(Copy, Clone, Debug)]\n-#[deprecated(since = \"1.0.0\", reason = \"use std::io::empty() instead\")]\n-#[unstable(feature = \"old_io\")]\n-pub struct NullReader;\n-\n-#[deprecated(since = \"1.0.0\", reason = \"use std::io::empty() instead\")]\n-#[unstable(feature = \"old_io\")]\n-impl Reader for NullReader {\n-    #[inline]\n-    fn read(&mut self, _buf: &mut [u8]) -> old_io::IoResult<usize> {\n-        Err(old_io::standard_error(old_io::EndOfFile))\n-    }\n-}\n-\n-#[deprecated(since = \"1.0.0\", reason = \"use std::io::empty() instead\")]\n-#[unstable(feature = \"old_io\")]\n-impl Buffer for NullReader {\n-    fn fill_buf<'a>(&'a mut self) -> old_io::IoResult<&'a [u8]> {\n-        Err(old_io::standard_error(old_io::EndOfFile))\n-    }\n-    fn consume(&mut self, _amt: usize) {}\n-}\n-\n-/// A `Writer` which multiplexes writes to a set of `Writer`s.\n-///\n-/// The `Writer`s are delegated to in order. If any `Writer` returns an error,\n-/// that error is returned immediately and remaining `Writer`s are not called.\n-#[derive(Debug)]\n-#[deprecated(since = \"1.0.0\", reason = \"use std::io::Broadcast instead\")]\n-#[unstable(feature = \"old_io\")]\n-pub struct MultiWriter<W> {\n-    writers: Vec<W>\n-}\n-\n-impl<W> MultiWriter<W> where W: Writer {\n-    /// Creates a new `MultiWriter`\n-    #[deprecated(since = \"1.0.0\", reason = \"use std::io's broadcast method instead\")]\n-    #[unstable(feature = \"old_io\")]\n-    pub fn new(writers: Vec<W>) -> MultiWriter<W> {\n-        MultiWriter { writers: writers }\n-    }\n-}\n-\n-#[deprecated(since = \"1.0.0\", reason = \"use std::io::Broadcast instead\")]\n-#[unstable(feature = \"old_io\")]\n-impl<W> Writer for MultiWriter<W> where W: Writer {\n-    #[inline]\n-    fn write_all(&mut self, buf: &[u8]) -> old_io::IoResult<()> {\n-        for writer in &mut self.writers {\n-            try!(writer.write_all(buf));\n-        }\n-        Ok(())\n-    }\n-\n-    #[inline]\n-    fn flush(&mut self) -> old_io::IoResult<()> {\n-        for writer in &mut self.writers {\n-            try!(writer.flush());\n-        }\n-        Ok(())\n-    }\n-}\n-\n-/// A `Reader` which chains input from multiple `Reader`s, reading each to\n-/// completion before moving onto the next.\n-#[derive(Clone, Debug)]\n-#[deprecated(since = \"1.0.0\", reason = \"use std::io::Chain instead\")]\n-#[unstable(feature = \"old_io\")]\n-pub struct ChainedReader<I, R> {\n-    readers: I,\n-    cur_reader: Option<R>,\n-}\n-\n-impl<R: Reader, I: Iterator<Item=R>> ChainedReader<I, R> {\n-    /// Creates a new `ChainedReader`\n-    #[deprecated(since = \"1.0.0\", reason = \"use std::io's chain method instead\")]\n-    #[unstable(feature = \"old_io\")]\n-    pub fn new(mut readers: I) -> ChainedReader<I, R> {\n-        let r = readers.next();\n-        ChainedReader { readers: readers, cur_reader: r }\n-    }\n-}\n-\n-#[deprecated(since = \"1.0.0\", reason = \"use std::io::Chain instead\")]\n-#[unstable(feature = \"old_io\")]\n-impl<R: Reader, I: Iterator<Item=R>> Reader for ChainedReader<I, R> {\n-    fn read(&mut self, buf: &mut [u8]) -> old_io::IoResult<usize> {\n-        loop {\n-            let err = match self.cur_reader {\n-                Some(ref mut r) => {\n-                    match r.read(buf) {\n-                        Ok(len) => return Ok(len),\n-                        Err(ref e) if e.kind == old_io::EndOfFile => None,\n-                        Err(e) => Some(e),\n-                    }\n-                }\n-                None => break\n-            };\n-            self.cur_reader = self.readers.next();\n-            match err {\n-                Some(e) => return Err(e),\n-                None => {}\n-            }\n-        }\n-        Err(old_io::standard_error(old_io::EndOfFile))\n-    }\n-}\n-\n-/// A `Reader` which forwards input from another `Reader`, passing it along to\n-/// a `Writer` as well. Similar to the `tee(1)` command.\n-#[derive(Debug)]\n-#[deprecated(since = \"1.0.0\", reason = \"use std::io::Tee instead\")]\n-#[unstable(feature = \"old_io\")]\n-pub struct TeeReader<R, W> {\n-    reader: R,\n-    writer: W,\n-}\n-\n-#[deprecated(since = \"1.0.0\", reason = \"use std::io::Tee instead\")]\n-#[unstable(feature = \"old_io\")]\n-impl<R: Reader, W: Writer> TeeReader<R, W> {\n-    /// Creates a new `TeeReader`\n-    #[deprecated(since = \"1.0.0\", reason = \"use std::io's tee method instead\")]\n-    #[unstable(feature = \"old_io\")]\n-    pub fn new(r: R, w: W) -> TeeReader<R, W> {\n-        TeeReader { reader: r, writer: w }\n-    }\n-\n-    /// Consumes the `TeeReader`, returning the underlying `Reader` and\n-    /// `Writer`.\n-    pub fn into_inner(self) -> (R, W) {\n-        let TeeReader { reader, writer } = self;\n-        (reader, writer)\n-    }\n-}\n-\n-#[deprecated(since = \"1.0.0\", reason = \"use std::io::Tee instead\")]\n-#[unstable(feature = \"old_io\")]\n-impl<R: Reader, W: Writer> Reader for TeeReader<R, W> {\n-    fn read(&mut self, buf: &mut [u8]) -> old_io::IoResult<usize> {\n-        self.reader.read(buf).and_then(|len| {\n-            self.writer.write_all(&mut buf[..len]).map(|()| len)\n-        })\n-    }\n-}\n-\n-/// Copies all data from a `Reader` to a `Writer`.\n-#[deprecated(since = \"1.0.0\", reason = \"use std::io's copy function instead\")]\n-#[unstable(feature = \"old_io\")]\n-pub fn copy<R: Reader, W: Writer>(r: &mut R, w: &mut W) -> old_io::IoResult<()> {\n-    let mut buf = [0; super::DEFAULT_BUF_SIZE];\n-    loop {\n-        let len = match r.read(&mut buf) {\n-            Ok(len) => len,\n-            Err(ref e) if e.kind == old_io::EndOfFile => return Ok(()),\n-            Err(e) => return Err(e),\n-        };\n-        try!(w.write_all(&buf[..len]));\n-    }\n-}\n-\n-/// An adaptor converting an `Iterator<u8>` to a `Reader`.\n-#[derive(Clone, Debug)]\n-pub struct IterReader<T> {\n-    iter: T,\n-}\n-\n-impl<T: Iterator<Item=u8>> IterReader<T> {\n-    /// Creates a new `IterReader` which will read from the specified\n-    /// `Iterator`.\n-    pub fn new(iter: T) -> IterReader<T> {\n-        IterReader { iter: iter }\n-    }\n-}\n-\n-impl<T: Iterator<Item=u8>> Reader for IterReader<T> {\n-    #[inline]\n-    fn read(&mut self, buf: &mut [u8]) -> old_io::IoResult<usize> {\n-        let mut len = 0;\n-        for (slot, elt) in buf.iter_mut().zip(self.iter.by_ref()) {\n-            *slot = elt;\n-            len += 1;\n-        }\n-        if len == 0 && buf.len() != 0 {\n-            Err(old_io::standard_error(old_io::EndOfFile))\n-        } else {\n-            Ok(len)\n-        }\n-    }\n-}\n-\n-#[cfg(test)]\n-mod test {\n-    use prelude::v1::*;\n-\n-    use old_io::{MemReader, ByRefReader, Reader, Writer, Buffer};\n-    use old_io;\n-    use super::*;\n-\n-    #[test]\n-    fn test_limit_reader_unlimited() {\n-        let mut r = MemReader::new(vec!(0, 1, 2));\n-        {\n-            let mut r = LimitReader::new(r.by_ref(), 4);\n-            assert_eq!(r.read_to_end().unwrap(), [0, 1, 2]);\n-        }\n-    }\n-\n-    #[test]\n-    fn test_limit_reader_limited() {\n-        let mut r = MemReader::new(vec!(0, 1, 2));\n-        {\n-            let mut r = LimitReader::new(r.by_ref(), 2);\n-            assert_eq!(r.read_to_end().unwrap(), [0, 1]);\n-        }\n-        assert_eq!(r.read_to_end().unwrap(), [2]);\n-    }\n-\n-    #[test]\n-    fn test_limit_reader_limit() {\n-        let r = MemReader::new(vec!(0, 1, 2));\n-        let mut r = LimitReader::new(r, 3);\n-        assert_eq!(3, r.limit());\n-        assert_eq!(0, r.read_byte().unwrap());\n-        assert_eq!(2, r.limit());\n-        assert_eq!(r.read_to_end().unwrap(), [1, 2]);\n-        assert_eq!(0, r.limit());\n-    }\n-\n-    #[test]\n-    fn test_limit_reader_overlong_consume() {\n-        let mut r = MemReader::new(vec![0, 1, 2, 3, 4, 5]);\n-        let mut r = LimitReader::new(r.by_ref(), 1);\n-        r.consume(2);\n-        assert_eq!(r.read_to_end().unwrap(), []);\n-    }\n-\n-    #[test]\n-    fn test_null_writer() {\n-        let mut s = NullWriter;\n-        let buf = vec![0, 0, 0];\n-        s.write_all(&buf).unwrap();\n-        s.flush().unwrap();\n-    }\n-\n-    #[test]\n-    fn test_zero_reader() {\n-        let mut s = ZeroReader;\n-        let mut buf = vec![1, 2, 3];\n-        assert_eq!(s.read(&mut buf), Ok(3));\n-        assert_eq!(buf, [0, 0, 0]);\n-    }\n-\n-    #[test]\n-    fn test_null_reader() {\n-        let mut r = NullReader;\n-        let mut buf = vec![0];\n-        assert!(r.read(&mut buf).is_err());\n-    }\n-\n-    #[test]\n-    fn test_multi_writer() {\n-        static mut writes: usize = 0;\n-        static mut flushes: usize = 0;\n-\n-        struct TestWriter;\n-        impl Writer for TestWriter {\n-            fn write_all(&mut self, _buf: &[u8]) -> old_io::IoResult<()> {\n-                unsafe { writes += 1 }\n-                Ok(())\n-            }\n-\n-            fn flush(&mut self) -> old_io::IoResult<()> {\n-                unsafe { flushes += 1 }\n-                Ok(())\n-            }\n-        }\n-\n-        let mut multi = MultiWriter::new(vec!(box TestWriter as Box<Writer>,\n-                                              box TestWriter as Box<Writer>));\n-        multi.write_all(&[1, 2, 3]).unwrap();\n-        assert_eq!(2, unsafe { writes });\n-        assert_eq!(0, unsafe { flushes });\n-        multi.flush().unwrap();\n-        assert_eq!(2, unsafe { writes });\n-        assert_eq!(2, unsafe { flushes });\n-    }\n-\n-    #[test]\n-    fn test_chained_reader() {\n-        let rs = vec!(MemReader::new(vec!(0, 1)), MemReader::new(vec!()),\n-                      MemReader::new(vec!(2, 3)));\n-        let mut r = ChainedReader::new(rs.into_iter());\n-        assert_eq!(r.read_to_end().unwrap(), [0, 1, 2, 3]);\n-    }\n-\n-    #[test]\n-    fn test_tee_reader() {\n-        let mut r = TeeReader::new(MemReader::new(vec!(0, 1, 2)),\n-                                   Vec::new());\n-        assert_eq!(r.read_to_end().unwrap(), [0, 1, 2]);\n-        let (_, w) = r.into_inner();\n-        assert_eq!(w, [0, 1, 2]);\n-    }\n-\n-    #[test]\n-    fn test_copy() {\n-        let mut r = MemReader::new(vec!(0, 1, 2, 3, 4));\n-        let mut w = Vec::new();\n-        copy(&mut r, &mut w).unwrap();\n-        assert_eq!(w, [0, 1, 2, 3, 4]);\n-    }\n-\n-    #[test]\n-    fn limit_reader_buffer() {\n-        let mut r: &[u8] = b\"0123456789\\n0123456789\\n\";\n-        let r = &mut r;\n-        {\n-            let mut r = LimitReader::new(r.by_ref(), 3);\n-            assert_eq!(r.read_line(), Ok(\"012\".to_string()));\n-            assert_eq!(r.limit(), 0);\n-            assert_eq!(r.read_line().err().unwrap().kind, old_io::EndOfFile);\n-        }\n-        {\n-            let mut r = LimitReader::new(r.by_ref(), 9);\n-            assert_eq!(r.read_line(), Ok(\"3456789\\n\".to_string()));\n-            assert_eq!(r.limit(), 1);\n-            assert_eq!(r.read_line(), Ok(\"0\".to_string()));\n-        }\n-        {\n-            let mut r = LimitReader::new(r.by_ref(), 100);\n-            assert_eq!(r.read_char(), Ok('1'));\n-            assert_eq!(r.limit(), 99);\n-            assert_eq!(r.read_line(), Ok(\"23456789\\n\".to_string()));\n-        }\n-    }\n-\n-    #[test]\n-    fn test_iter_reader() {\n-        let mut r = IterReader::new(0..8);\n-        let mut buf = [0, 0, 0];\n-        let len = r.read(&mut buf).unwrap();\n-        assert_eq!(len, 3);\n-        assert!(buf == [0, 1, 2]);\n-\n-        let len = r.read(&mut buf).unwrap();\n-        assert_eq!(len, 3);\n-        assert!(buf == [3, 4, 5]);\n-\n-        let len = r.read(&mut buf).unwrap();\n-        assert_eq!(len, 2);\n-        assert!(buf == [6, 7, 5]);\n-\n-        assert_eq!(r.read(&mut buf).unwrap_err().kind, old_io::EndOfFile);\n-    }\n-\n-    #[test]\n-    fn iter_reader_zero_length() {\n-        let mut r = IterReader::new(0..8);\n-        let mut buf = [];\n-        assert_eq!(Ok(0), r.read(&mut buf));\n-    }\n-}"}, {"sha": "2dee90e9a6660daad699813cf8bac4ab0923bae6", "filename": "src/libstd/old_path/mod.rs", "status": "removed", "additions": 0, "deletions": 985, "changes": 985, "blob_url": "https://github.com/rust-lang/rust/blob/8415fa27877a4309a79b08c75a52eb4c3546b7a5/src%2Flibstd%2Fold_path%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8415fa27877a4309a79b08c75a52eb4c3546b7a5/src%2Flibstd%2Fold_path%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_path%2Fmod.rs?ref=8415fa27877a4309a79b08c75a52eb4c3546b7a5", "patch": "@@ -1,985 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Cross-platform path support\n-//!\n-//! This module implements support for two flavors of paths. `PosixPath` represents a path on any\n-//! unix-like system, whereas `WindowsPath` represents a path on Windows. This module also exposes\n-//! a typedef `Path` which is equal to the appropriate platform-specific path variant.\n-//!\n-//! Both `PosixPath` and `WindowsPath` implement a trait `GenericPath`, which contains the set of\n-//! methods that behave the same for both paths. They each also implement some methods that could\n-//! not be expressed in `GenericPath`, yet behave identically for both path flavors, such as\n-//! `.components()`.\n-//!\n-//! The three main design goals of this module are 1) to avoid unnecessary allocation, 2) to behave\n-//! the same regardless of which flavor of path is being used, and 3) to support paths that cannot\n-//! be represented in UTF-8 (as Linux has no restriction on paths beyond disallowing NUL).\n-//!\n-//! ## Usage\n-//!\n-//! Usage of this module is fairly straightforward. Unless writing platform-specific code, `Path`\n-//! should be used to refer to the platform-native path.\n-//!\n-//! Creation of a path is typically done with either `Path::new(some_str)` or\n-//! `Path::new(some_vec)`. This path can be modified with `.push()` and `.pop()` (and other\n-//! setters). The resulting Path can either be passed to another API that expects a path, or can be\n-//! turned into a `&[u8]` with `.as_vec()` or a `Option<&str>` with `.as_str()`. Similarly,\n-//! attributes of the path can be queried with methods such as `.filename()`. There are also\n-//! methods that return a new path instead of modifying the receiver, such as `.join()` or\n-//! `.dir_path()`.\n-//!\n-//! Paths are always kept in normalized form. This means that creating the path\n-//! `Path::new(\"a/b/../c\")` will return the path `a/c`. Similarly any attempt to mutate the path\n-//! will always leave it in normalized form.\n-//!\n-//! When rendering a path to some form of output, there is a method `.display()` which is\n-//! compatible with the `format!()` parameter `{}`. This will render the path as a string,\n-//! replacing all non-utf8 sequences with the Replacement Character (U+FFFD). As such it is not\n-//! suitable for passing to any API that actually operates on the path; it is only intended for\n-//! display.\n-//!\n-//! ## Examples\n-//!\n-//! ```rust,ignore\n-//! # #![feature(old_path, old_io)]\n-//! use std::old_io::fs::PathExtensions;\n-//! use std::old_path::{Path, GenericPath};\n-//!\n-//! let mut path = Path::new(\"/tmp/path\");\n-//! println!(\"path: {}\", path.display());\n-//! path.set_filename(\"foo\");\n-//! path.push(\"bar\");\n-//! println!(\"new path: {}\", path.display());\n-//! println!(\"path exists: {}\", path.exists());\n-//! ```\n-\n-#![unstable(feature = \"old_path\")]\n-#![deprecated(since = \"1.0.0\", reason = \"use std::path instead\")]\n-#![allow(deprecated)] // seriously this is all deprecated\n-#![allow(unused_imports)]\n-\n-use core::marker::Sized;\n-use ffi::CString;\n-use clone::Clone;\n-use borrow::Cow;\n-use fmt;\n-use iter::Iterator;\n-use option::Option;\n-use option::Option::{None, Some};\n-use str;\n-use string::String;\n-use vec::Vec;\n-\n-/// Typedef for POSIX file paths.\n-/// See `posix::Path` for more info.\n-pub use self::posix::Path as PosixPath;\n-\n-/// Typedef for Windows file paths.\n-/// See `windows::Path` for more info.\n-pub use self::windows::Path as WindowsPath;\n-\n-/// Typedef for the platform-native path type\n-#[cfg(unix)]\n-pub use self::posix::Path as Path;\n-/// Typedef for the platform-native path type\n-#[cfg(windows)]\n-pub use self::windows::Path as Path;\n-\n-/// Typedef for the platform-native component iterator\n-#[cfg(unix)]\n-pub use self::posix::Components as Components;\n-/// Typedef for the platform-native component iterator\n-#[cfg(windows)]\n-pub use self::windows::Components as Components;\n-\n-/// Typedef for the platform-native str component iterator\n-#[cfg(unix)]\n-pub use self::posix::StrComponents as StrComponents;\n-/// Typedef for the platform-native str component iterator\n-#[cfg(windows)]\n-pub use self::windows::StrComponents as StrComponents;\n-\n-/// Alias for the platform-native separator character.\n-#[cfg(unix)]\n-pub use self::posix::SEP as SEP;\n-/// Alias for the platform-native separator character.\n-#[cfg(windows)]\n-pub use self::windows::SEP as SEP;\n-\n-/// Alias for the platform-native separator byte.\n-#[cfg(unix)]\n-pub use self::posix::SEP_BYTE as SEP_BYTE;\n-/// Alias for the platform-native separator byte.\n-#[cfg(windows)]\n-pub use self::windows::SEP_BYTE as SEP_BYTE;\n-\n-/// Typedef for the platform-native separator char func\n-#[cfg(unix)]\n-pub use self::posix::is_sep as is_sep;\n-/// Typedef for the platform-native separator char func\n-#[cfg(windows)]\n-pub use self::windows::is_sep as is_sep;\n-/// Typedef for the platform-native separator byte func\n-#[cfg(unix)]\n-pub use self::posix::is_sep_byte as is_sep_byte;\n-/// Typedef for the platform-native separator byte func\n-#[cfg(windows)]\n-pub use self::windows::is_sep_byte as is_sep_byte;\n-\n-pub mod posix;\n-pub mod windows;\n-\n-/// A trait that represents the generic operations available on paths\n-pub trait GenericPath: Clone + GenericPathUnsafe {\n-    /// Creates a new Path from a byte vector or string.\n-    /// The resulting Path will always be normalized.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// # #![feature(old_path)]\n-    /// # fn main() {\n-    /// use std::old_path::Path;\n-    /// let path = Path::new(\"foo/bar\");\n-    /// # }\n-    /// ```\n-    ///\n-    /// # Panics\n-    ///\n-    /// Panics the task if the path contains a NUL.\n-    ///\n-    /// See individual Path impls for additional restrictions.\n-    #[inline]\n-    fn new<T: BytesContainer>(path: T) -> Self {\n-        assert!(!contains_nul(&path));\n-        unsafe { GenericPathUnsafe::new_unchecked(path) }\n-    }\n-\n-    /// Creates a new Path from a byte vector or string, if possible.\n-    /// The resulting Path will always be normalized.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// # #![feature(old_path)]\n-    /// # fn main() {\n-    /// use std::old_path::Path;\n-    /// let x: &[u8] = b\"foo\\0\";\n-    /// assert!(Path::new_opt(x).is_none());\n-    /// # }\n-    /// ```\n-    #[inline]\n-    fn new_opt<T: BytesContainer>(path: T) -> Option<Self> {\n-        if contains_nul(&path) {\n-            None\n-        } else {\n-            Some(unsafe { GenericPathUnsafe::new_unchecked(path) })\n-        }\n-    }\n-\n-    /// Returns the path as a string, if possible.\n-    /// If the path is not representable in utf-8, this returns None.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```ignore\n-    /// # #![feature(old_path)]\n-    /// use std::old_path::{Path, GenericPath};\n-    /// # foo();\n-    /// # #[cfg(windows)] fn foo() {}\n-    /// # #[cfg(unix)] fn foo() {\n-    /// let p = Path::new(\"/abc/def\");\n-    /// assert_eq!(p.as_str(), Some(\"/abc/def\"));\n-    /// # }\n-    /// ```\n-    #[inline]\n-    fn as_str<'a>(&'a self) -> Option<&'a str> {\n-        str::from_utf8(self.as_vec()).ok()\n-    }\n-\n-    /// Returns the path as a byte vector\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```ignore\n-    /// # #![feature(old_path)]\n-    /// use std::old_path::{Path, GenericPath};\n-    /// # foo();\n-    /// # #[cfg(windows)] fn foo() {}\n-    /// # #[cfg(unix)] fn foo() {\n-    /// let p = Path::new(\"abc/def\");\n-    /// assert_eq!(p.as_vec(), b\"abc/def\");\n-    /// # }\n-    /// ```\n-    fn as_vec<'a>(&'a self) -> &'a [u8];\n-\n-    /// Converts the Path into an owned byte vector\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```ignore\n-    /// # #![feature(old_path)]\n-    /// use std::old_path::{Path, GenericPath};\n-    /// # foo();\n-    /// # #[cfg(windows)] fn foo() {}\n-    /// # #[cfg(unix)] fn foo() {\n-    /// let p = Path::new(\"abc/def\");\n-    /// assert_eq!(p.into_vec(), b\"abc/def\".to_vec());\n-    /// // attempting to use p now results in \"error: use of moved value\"\n-    /// # }\n-    /// ```\n-    fn into_vec(self) -> Vec<u8>;\n-\n-    /// Returns an object that implements `Display` for printing paths\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```ignore\n-    /// # #![feature(old_path)]\n-    /// use std::old_path::{Path, GenericPath};\n-    /// # foo();\n-    /// # #[cfg(windows)] fn foo() {}\n-    /// # #[cfg(unix)] fn foo() {\n-    /// let p = Path::new(\"abc/def\");\n-    /// println!(\"{}\", p.display()); // prints \"abc/def\"\n-    /// # }\n-    /// ```\n-    fn display<'a>(&'a self) -> Display<'a, Self> {\n-        Display{ path: self, filename: false }\n-    }\n-\n-    /// Returns an object that implements `Display` for printing filenames\n-    ///\n-    /// If there is no filename, nothing will be printed.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```ignore\n-    /// # #![feature(old_path)]\n-    /// use std::old_path::{Path, GenericPath};\n-    /// # foo();\n-    /// # #[cfg(windows)] fn foo() {}\n-    /// # #[cfg(unix)] fn foo() {\n-    /// let p = Path::new(\"abc/def\");\n-    /// println!(\"{}\", p.filename_display()); // prints \"def\"\n-    /// # }\n-    /// ```\n-    fn filename_display<'a>(&'a self) -> Display<'a, Self> {\n-        Display{ path: self, filename: true }\n-    }\n-\n-    /// Returns the directory component of `self`, as a byte vector (with no trailing separator).\n-    /// If `self` has no directory component, returns ['.'].\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```ignore\n-    /// # #![feature(old_path)]\n-    /// use std::old_path::{Path, GenericPath};\n-    /// # foo();\n-    /// # #[cfg(windows)] fn foo() {}\n-    /// # #[cfg(unix)] fn foo() {\n-    /// let p = Path::new(\"abc/def/ghi\");\n-    /// assert_eq!(p.dirname(), b\"abc/def\");\n-    /// # }\n-    /// ```\n-    fn dirname<'a>(&'a self) -> &'a [u8];\n-\n-    /// Returns the directory component of `self`, as a string, if possible.\n-    /// See `dirname` for details.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```ignore\n-    /// # #![feature(old_path)]\n-    /// use std::old_path::{Path, GenericPath};\n-    /// # foo();\n-    /// # #[cfg(windows)] fn foo() {}\n-    /// # #[cfg(unix)] fn foo() {\n-    /// let p = Path::new(\"abc/def/ghi\");\n-    /// assert_eq!(p.dirname_str(), Some(\"abc/def\"));\n-    /// # }\n-    /// ```\n-    #[inline]\n-    fn dirname_str<'a>(&'a self) -> Option<&'a str> {\n-        str::from_utf8(self.dirname()).ok()\n-    }\n-\n-    /// Returns the file component of `self`, as a byte vector.\n-    /// If `self` represents the root of the file hierarchy, returns None.\n-    /// If `self` is \".\" or \"..\", returns None.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```ignore\n-    /// # #![feature(old_path)]\n-    /// use std::old_path::{Path, GenericPath};\n-    /// # foo();\n-    /// # #[cfg(windows)] fn foo() {}\n-    /// # #[cfg(unix)] fn foo() {\n-    /// let p = Path::new(\"abc/def/ghi\");\n-    /// assert_eq!(p.filename(), Some(&b\"ghi\"[..]));\n-    /// # }\n-    /// ```\n-    fn filename<'a>(&'a self) -> Option<&'a [u8]>;\n-\n-    /// Returns the file component of `self`, as a string, if possible.\n-    /// See `filename` for details.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```ignore\n-    /// # #![feature(old_path)]\n-    /// use std::old_path::{Path, GenericPath};\n-    /// # foo();\n-    /// # #[cfg(windows)] fn foo() {}\n-    /// # #[cfg(unix)] fn foo() {\n-    /// let p = Path::new(\"abc/def/ghi\");\n-    /// assert_eq!(p.filename_str(), Some(\"ghi\"));\n-    /// # }\n-    /// ```\n-    #[inline]\n-    fn filename_str<'a>(&'a self) -> Option<&'a str> {\n-        self.filename().and_then(|s| str::from_utf8(s).ok())\n-    }\n-\n-    /// Returns the stem of the filename of `self`, as a byte vector.\n-    /// The stem is the portion of the filename just before the last '.'.\n-    /// If there is no '.', the entire filename is returned.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```ignore\n-    /// # #![feature(old_path)]\n-    /// use std::old_path::{Path, GenericPath};\n-    /// # foo();\n-    /// # #[cfg(windows)] fn foo() {}\n-    /// # #[cfg(unix)] fn foo() {\n-    /// let p = Path::new(\"/abc/def.txt\");\n-    /// assert_eq!(p.filestem(), Some(&b\"def\"[..]));\n-    /// # }\n-    /// ```\n-    fn filestem<'a>(&'a self) -> Option<&'a [u8]> {\n-        match self.filename() {\n-            None => None,\n-            Some(name) => Some({\n-                let dot = b'.';\n-                match name.rposition_elem(&dot) {\n-                    None | Some(0) => name,\n-                    Some(1) if name == b\"..\" => name,\n-                    Some(pos) => &name[..pos]\n-                }\n-            })\n-        }\n-    }\n-\n-    /// Returns the stem of the filename of `self`, as a string, if possible.\n-    /// See `filestem` for details.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```ignore\n-    /// # #![feature(old_path)]\n-    /// use std::old_path::{Path, GenericPath};\n-    /// # foo();\n-    /// # #[cfg(windows)] fn foo() {}\n-    /// # #[cfg(unix)] fn foo() {\n-    /// let p = Path::new(\"/abc/def.txt\");\n-    /// assert_eq!(p.filestem_str(), Some(\"def\"));\n-    /// # }\n-    /// ```\n-    #[inline]\n-    fn filestem_str<'a>(&'a self) -> Option<&'a str> {\n-        self.filestem().and_then(|s| str::from_utf8(s).ok())\n-    }\n-\n-    /// Returns the extension of the filename of `self`, as an optional byte vector.\n-    /// The extension is the portion of the filename just after the last '.'.\n-    /// If there is no extension, None is returned.\n-    /// If the filename ends in '.', the empty vector is returned.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```ignore\n-    /// # #![feature(old_path)]\n-    /// use std::old_path::{Path, GenericPath};\n-    /// # foo();\n-    /// # #[cfg(windows)] fn foo() {}\n-    /// # #[cfg(unix)] fn foo() {\n-    /// let p = Path::new(\"abc/def.txt\");\n-    /// assert_eq!(p.extension(), Some(&b\"txt\"[..]));\n-    /// # }\n-    /// ```\n-    fn extension<'a>(&'a self) -> Option<&'a [u8]> {\n-        match self.filename() {\n-            None => None,\n-            Some(name) => {\n-                let dot = b'.';\n-                match name.rposition_elem(&dot) {\n-                    None | Some(0) => None,\n-                    Some(1) if name == b\"..\" => None,\n-                    Some(pos) => Some(&name[pos+1..])\n-                }\n-            }\n-        }\n-    }\n-\n-    /// Returns the extension of the filename of `self`, as a string, if possible.\n-    /// See `extension` for details.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```ignore\n-    /// # #![feature(old_path)]\n-    /// use std::old_path::{Path, GenericPath};\n-    /// # foo();\n-    /// # #[cfg(windows)] fn foo() {}\n-    /// # #[cfg(unix)] fn foo() {\n-    /// let p = Path::new(\"abc/def.txt\");\n-    /// assert_eq!(p.extension_str(), Some(\"txt\"));\n-    /// # }\n-    /// ```\n-    #[inline]\n-    fn extension_str<'a>(&'a self) -> Option<&'a str> {\n-        self.extension().and_then(|s| str::from_utf8(s).ok())\n-    }\n-\n-    /// Replaces the filename portion of the path with the given byte vector or string.\n-    /// If the replacement name is [], this is equivalent to popping the path.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```ignore\n-    /// # #![feature(old_path)]\n-    /// use std::old_path::{Path, GenericPath};\n-    /// # foo();\n-    /// # #[cfg(windows)] fn foo() {}\n-    /// # #[cfg(unix)] fn foo() {\n-    /// let mut p = Path::new(\"abc/def.txt\");\n-    /// p.set_filename(\"foo.dat\");\n-    /// assert!(p == Path::new(\"abc/foo.dat\"));\n-    /// # }\n-    /// ```\n-    ///\n-    /// # Panics\n-    ///\n-    /// Panics the task if the filename contains a NUL.\n-    #[inline]\n-    fn set_filename<T: BytesContainer>(&mut self, filename: T) {\n-        assert!(!contains_nul(&filename));\n-        unsafe { self.set_filename_unchecked(filename) }\n-    }\n-\n-    /// Replaces the extension with the given byte vector or string.\n-    /// If there is no extension in `self`, this adds one.\n-    /// If the argument is [] or \"\", this removes the extension.\n-    /// If `self` has no filename, this is a no-op.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```ignore\n-    /// # #![feature(old_path)]\n-    /// use std::old_path::{Path, GenericPath};\n-    /// # foo();\n-    /// # #[cfg(windows)] fn foo() {}\n-    /// # #[cfg(unix)] fn foo() {\n-    /// let mut p = Path::new(\"abc/def.txt\");\n-    /// p.set_extension(\"csv\");\n-    /// assert_eq!(p, Path::new(\"abc/def.csv\"));\n-    /// # }\n-    /// ```\n-    ///\n-    /// # Panics\n-    ///\n-    /// Panics the task if the extension contains a NUL.\n-    fn set_extension<T: BytesContainer>(&mut self, extension: T) {\n-        assert!(!contains_nul(&extension));\n-\n-        let val = self.filename().and_then(|name| {\n-            let dot = b'.';\n-            let extlen = extension.container_as_bytes().len();\n-            match (name.rposition_elem(&dot), extlen) {\n-                (None, 0) | (Some(0), 0) => None,\n-                (Some(idx), 0) => Some(name[..idx].to_vec()),\n-                (idx, extlen) => {\n-                    let idx = match idx {\n-                        None | Some(0) => name.len(),\n-                        Some(val) => val\n-                    };\n-\n-                    let mut v;\n-                    v = Vec::with_capacity(idx + extlen + 1);\n-                    v.push_all(&name[..idx]);\n-                    v.push(dot);\n-                    v.push_all(extension.container_as_bytes());\n-                    Some(v)\n-                }\n-            }\n-        });\n-\n-        match val {\n-            None => (),\n-            Some(v) => unsafe { self.set_filename_unchecked(v) }\n-        }\n-    }\n-\n-    /// Returns a new Path constructed by replacing the filename with the given\n-    /// byte vector or string.\n-    /// See `set_filename` for details.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```ignore\n-    /// # #![feature(old_path)]\n-    /// use std::old_path::{Path, GenericPath};\n-    /// # foo();\n-    /// # #[cfg(windows)] fn foo() {}\n-    /// # #[cfg(unix)] fn foo() {\n-    /// let mut p = Path::new(\"abc/def.txt\");\n-    /// assert_eq!(p.with_filename(\"foo.dat\"), Path::new(\"abc/foo.dat\"));\n-    /// # }\n-    /// ```\n-    ///\n-    /// # Panics\n-    ///\n-    /// Panics the task if the filename contains a NUL.\n-    #[inline]\n-    fn with_filename<T: BytesContainer>(&self, filename: T) -> Self {\n-        let mut p = self.clone();\n-        p.set_filename(filename);\n-        p\n-    }\n-\n-    /// Returns a new Path constructed by setting the extension to the given\n-    /// byte vector or string.\n-    /// See `set_extension` for details.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```ignore\n-    /// # #![feature(old_path)]\n-    /// use std::old_path::{Path, GenericPath};\n-    /// # foo();\n-    /// # #[cfg(windows)] fn foo() {}\n-    /// # #[cfg(unix)] fn foo() {\n-    /// let mut p = Path::new(\"abc/def.txt\");\n-    /// assert_eq!(p.with_extension(\"csv\"), Path::new(\"abc/def.csv\"));\n-    /// # }\n-    /// ```\n-    ///\n-    /// # Panics\n-    ///\n-    /// Panics the task if the extension contains a NUL.\n-    #[inline]\n-    fn with_extension<T: BytesContainer>(&self, extension: T) -> Self {\n-        let mut p = self.clone();\n-        p.set_extension(extension);\n-        p\n-    }\n-\n-    /// Returns the directory component of `self`, as a Path.\n-    /// If `self` represents the root of the filesystem hierarchy, returns `self`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```ignore\n-    /// # #![feature(old_path)]\n-    /// use std::old_path::{Path, GenericPath};\n-    /// # foo();\n-    /// # #[cfg(windows)] fn foo() {}\n-    /// # #[cfg(unix)] fn foo() {\n-    /// let p = Path::new(\"abc/def/ghi\");\n-    /// assert_eq!(p.dir_path(), Path::new(\"abc/def\"));\n-    /// # }\n-    /// ```\n-    fn dir_path(&self) -> Self {\n-        // self.dirname() returns a NUL-free vector\n-        unsafe { GenericPathUnsafe::new_unchecked(self.dirname()) }\n-    }\n-\n-    /// Returns a Path that represents the filesystem root that `self` is rooted in.\n-    ///\n-    /// If `self` is not absolute, or vol/cwd-relative in the case of Windows, this returns None.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```ignore\n-    /// # #![feature(old_path)]\n-    /// use std::old_path::{Path, GenericPath};\n-    /// # foo();\n-    /// # #[cfg(windows)] fn foo() {}\n-    /// # #[cfg(unix)] fn foo() {\n-    /// assert_eq!(Path::new(\"abc/def\").root_path(), None);\n-    /// assert_eq!(Path::new(\"/abc/def\").root_path(), Some(Path::new(\"/\")));\n-    /// # }\n-    /// ```\n-    fn root_path(&self) -> Option<Self>;\n-\n-    /// Pushes a path (as a byte vector or string) onto `self`.\n-    /// If the argument represents an absolute path, it replaces `self`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```ignore\n-    /// # #![feature(old_path)]\n-    /// use std::old_path::{Path, GenericPath};\n-    /// # foo();\n-    /// # #[cfg(windows)] fn foo() {}\n-    /// # #[cfg(unix)] fn foo() {\n-    /// let mut p = Path::new(\"foo/bar\");\n-    /// p.push(\"baz.txt\");\n-    /// assert_eq!(p, Path::new(\"foo/bar/baz.txt\"));\n-    /// # }\n-    /// ```\n-    ///\n-    /// # Panics\n-    ///\n-    /// Panics the task if the path contains a NUL.\n-    #[inline]\n-    fn push<T: BytesContainer>(&mut self, path: T) {\n-        assert!(!contains_nul(&path));\n-        unsafe { self.push_unchecked(path) }\n-    }\n-\n-    /// Pushes multiple paths (as byte vectors or strings) onto `self`.\n-    /// See `push` for details.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```ignore\n-    /// # #![feature(old_path)]\n-    /// use std::old_path::{Path, GenericPath};\n-    /// # foo();\n-    /// # #[cfg(windows)] fn foo() {}\n-    /// # #[cfg(unix)] fn foo() {\n-    /// let mut p = Path::new(\"foo\");\n-    /// p.push_many(&[\"bar\", \"baz.txt\"]);\n-    /// assert_eq!(p, Path::new(\"foo/bar/baz.txt\"));\n-    /// # }\n-    /// ```\n-    #[inline]\n-    fn push_many<T: BytesContainer>(&mut self, paths: &[T]) {\n-        let t: Option<&T> = None;\n-        if BytesContainer::is_str(t) {\n-            for p in paths {\n-                self.push(p.container_as_str().unwrap())\n-            }\n-        } else {\n-            for p in paths {\n-                self.push(p.container_as_bytes())\n-            }\n-        }\n-    }\n-\n-    /// Removes the last path component from the receiver.\n-    /// Returns `true` if the receiver was modified, or `false` if it already\n-    /// represented the root of the file hierarchy.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```ignore\n-    /// # #![feature(old_path)]\n-    /// use std::old_path::{Path, GenericPath};\n-    /// # foo();\n-    /// # #[cfg(windows)] fn foo() {}\n-    /// # #[cfg(unix)] fn foo() {\n-    /// let mut p = Path::new(\"foo/bar/baz.txt\");\n-    /// p.pop();\n-    /// assert_eq!(p, Path::new(\"foo/bar\"));\n-    /// # }\n-    /// ```\n-    fn pop(&mut self) -> bool;\n-\n-    /// Returns a new Path constructed by joining `self` with the given path\n-    /// (as a byte vector or string).\n-    /// If the given path is absolute, the new Path will represent just that.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```ignore\n-    /// # #![feature(old_path)]\n-    /// use std::old_path::{Path, GenericPath};\n-    /// # foo();\n-    /// # #[cfg(windows)] fn foo() {}\n-    /// # #[cfg(unix)] fn foo() {\n-    /// let p = Path::new(\"/foo\");\n-    /// assert_eq!(p.join(\"bar.txt\"), Path::new(\"/foo/bar.txt\"));\n-    /// # }\n-    /// ```\n-    ///\n-    /// # Panics\n-    ///\n-    /// Panics the task if the path contains a NUL.\n-    #[inline]\n-    fn join<T: BytesContainer>(&self, path: T) -> Self {\n-        let mut p = self.clone();\n-        p.push(path);\n-        p\n-    }\n-\n-    /// Returns a new Path constructed by joining `self` with the given paths\n-    /// (as byte vectors or strings).\n-    /// See `join` for details.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```ignore\n-    /// # #![feature(old_path)]\n-    /// use std::old_path::{Path, GenericPath};\n-    /// # foo();\n-    /// # #[cfg(windows)] fn foo() {}\n-    /// # #[cfg(unix)] fn foo() {\n-    /// let p = Path::new(\"foo\");\n-    /// let fbbq = Path::new(\"foo/bar/baz/quux.txt\");\n-    /// assert_eq!(p.join_many(&[\"bar\", \"baz\", \"quux.txt\"]), fbbq);\n-    /// # }\n-    /// ```\n-    #[inline]\n-    fn join_many<T: BytesContainer>(&self, paths: &[T]) -> Self {\n-        let mut p = self.clone();\n-        p.push_many(paths);\n-        p\n-    }\n-\n-    /// Returns whether `self` represents an absolute path.\n-    /// An absolute path is defined as one that, when joined to another path, will\n-    /// yield back the same absolute path.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```ignore\n-    /// # #![feature(old_path)]\n-    /// use std::old_path::{Path, GenericPath};\n-    /// # foo();\n-    /// # #[cfg(windows)] fn foo() {}\n-    /// # #[cfg(unix)] fn foo() {\n-    /// let p = Path::new(\"/abc/def\");\n-    /// assert!(p.is_absolute());\n-    /// # }\n-    /// ```\n-    fn is_absolute(&self) -> bool;\n-\n-    /// Returns whether `self` represents a relative path.\n-    /// Typically this is the inverse of `is_absolute`.\n-    /// But for Windows paths, it also means the path is not volume-relative or\n-    /// relative to the current working directory.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```ignore\n-    /// # #![feature(old_path)]\n-    /// use std::old_path::{Path, GenericPath};\n-    /// # foo();\n-    /// # #[cfg(windows)] fn foo() {}\n-    /// # #[cfg(unix)] fn foo() {\n-    /// let p = Path::new(\"abc/def\");\n-    /// assert!(p.is_relative());\n-    /// # }\n-    /// ```\n-    fn is_relative(&self) -> bool {\n-        !self.is_absolute()\n-    }\n-\n-    /// Returns whether `self` is equal to, or is an ancestor of, the given path.\n-    /// If both paths are relative, they are compared as though they are relative\n-    /// to the same parent path.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```ignore\n-    /// # #![feature(old_path)]\n-    /// use std::old_path::{Path, GenericPath};\n-    /// # foo();\n-    /// # #[cfg(windows)] fn foo() {}\n-    /// # #[cfg(unix)] fn foo() {\n-    /// let p = Path::new(\"foo/bar/baz/quux.txt\");\n-    /// let fb = Path::new(\"foo/bar\");\n-    /// let bq = Path::new(\"baz/quux.txt\");\n-    /// assert!(fb.is_ancestor_of(&p));\n-    /// # }\n-    /// ```\n-    fn is_ancestor_of(&self, other: &Self) -> bool;\n-\n-    /// Returns the Path that, were it joined to `base`, would yield `self`.\n-    /// If no such path exists, None is returned.\n-    /// If `self` is absolute and `base` is relative, or on Windows if both\n-    /// paths refer to separate drives, an absolute path is returned.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```ignore\n-    /// # #![feature(old_path)]\n-    /// use std::old_path::{Path, GenericPath};\n-    /// # foo();\n-    /// # #[cfg(windows)] fn foo() {}\n-    /// # #[cfg(unix)] fn foo() {\n-    /// let p = Path::new(\"foo/bar/baz/quux.txt\");\n-    /// let fb = Path::new(\"foo/bar\");\n-    /// let bq = Path::new(\"baz/quux.txt\");\n-    /// assert_eq!(p.path_relative_from(&fb), Some(bq));\n-    /// # }\n-    /// ```\n-    fn path_relative_from(&self, base: &Self) -> Option<Self>;\n-\n-    /// Returns whether the relative path `child` is a suffix of `self`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```ignore\n-    /// # #![feature(old_path)]\n-    /// use std::old_path::{Path, GenericPath};\n-    /// # foo();\n-    /// # #[cfg(windows)] fn foo() {}\n-    /// # #[cfg(unix)] fn foo() {\n-    /// let p = Path::new(\"foo/bar/baz/quux.txt\");\n-    /// let bq = Path::new(\"baz/quux.txt\");\n-    /// assert!(p.ends_with_path(&bq));\n-    /// # }\n-    /// ```\n-    fn ends_with_path(&self, child: &Self) -> bool;\n-}\n-\n-/// A trait that represents something bytes-like (e.g. a &[u8] or a &str)\n-pub trait BytesContainer {\n-    /// Returns a &[u8] representing the receiver\n-    fn container_as_bytes<'a>(&'a self) -> &'a [u8];\n-    /// Returns the receiver interpreted as a utf-8 string, if possible\n-    #[inline]\n-    fn container_as_str<'a>(&'a self) -> Option<&'a str> {\n-        str::from_utf8(self.container_as_bytes()).ok()\n-    }\n-    /// Returns whether .container_as_str() is guaranteed to not fail\n-    // FIXME (#8888): Remove unused arg once ::<for T> works\n-    #[inline]\n-    fn is_str(_: Option<&Self>) -> bool { false }\n-}\n-\n-/// A trait that represents the unsafe operations on GenericPaths\n-pub trait GenericPathUnsafe {\n-    /// Creates a new Path without checking for null bytes.\n-    /// The resulting Path will always be normalized.\n-    unsafe fn new_unchecked<T: BytesContainer>(path: T) -> Self;\n-\n-    /// Replaces the filename portion of the path without checking for null\n-    /// bytes.\n-    /// See `set_filename` for details.\n-    unsafe fn set_filename_unchecked<T: BytesContainer>(&mut self, filename: T);\n-\n-    /// Pushes a path onto `self` without checking for null bytes.\n-    /// See `push` for details.\n-    unsafe fn push_unchecked<T: BytesContainer>(&mut self, path: T);\n-}\n-\n-/// Helper struct for printing paths with format!()\n-pub struct Display<'a, P:'a> {\n-    path: &'a P,\n-    filename: bool\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, P: GenericPath> fmt::Debug for Display<'a, P> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        fmt::Debug::fmt(&self.as_cow(), f)\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, P: GenericPath> fmt::Display for Display<'a, P> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        self.as_cow().fmt(f)\n-    }\n-}\n-\n-impl<'a, P: GenericPath> Display<'a, P> {\n-    /// Returns the path as a possibly-owned string.\n-    ///\n-    /// If the path is not UTF-8, invalid sequences will be replaced with the\n-    /// Unicode replacement char. This involves allocation.\n-    #[inline]\n-    pub fn as_cow(&self) -> Cow<'a, str> {\n-        String::from_utf8_lossy(if self.filename {\n-            match self.path.filename() {\n-                None => {\n-                    let result: &[u8] = &[];\n-                    result\n-                }\n-                Some(v) => v\n-            }\n-        } else {\n-            self.path.as_vec()\n-        })\n-    }\n-}\n-\n-impl BytesContainer for str {\n-    #[inline]\n-    fn container_as_bytes(&self) -> &[u8] {\n-        self.as_bytes()\n-    }\n-    #[inline]\n-    fn container_as_str(&self) -> Option<&str> {\n-        Some(self)\n-    }\n-    #[inline]\n-    fn is_str(_: Option<&str>) -> bool { true }\n-}\n-\n-impl BytesContainer for String {\n-    #[inline]\n-    fn container_as_bytes(&self) -> &[u8] {\n-        self.as_bytes()\n-    }\n-    #[inline]\n-    fn container_as_str(&self) -> Option<&str> {\n-        Some(&self[..])\n-    }\n-    #[inline]\n-    fn is_str(_: Option<&String>) -> bool { true }\n-}\n-\n-impl BytesContainer for [u8] {\n-    #[inline]\n-    fn container_as_bytes(&self) -> &[u8] {\n-        self\n-    }\n-}\n-\n-impl BytesContainer for Vec<u8> {\n-    #[inline]\n-    fn container_as_bytes(&self) -> &[u8] {\n-        &self[..]\n-    }\n-}\n-\n-impl BytesContainer for CString {\n-    #[inline]\n-    fn container_as_bytes<'a>(&'a self) -> &'a [u8] {\n-        self.as_bytes()\n-    }\n-}\n-\n-impl<'a, T: ?Sized + BytesContainer> BytesContainer for &'a T {\n-    #[inline]\n-    fn container_as_bytes(&self) -> &[u8] {\n-        (**self).container_as_bytes()\n-    }\n-    #[inline]\n-    fn container_as_str(&self) -> Option<&str> {\n-        (**self).container_as_str()\n-    }\n-    #[inline]\n-    fn is_str(_: Option<& &'a T>) -> bool { BytesContainer::is_str(None::<&T>) }\n-}\n-\n-#[inline(always)]\n-fn contains_nul<T: BytesContainer>(v: &T) -> bool {\n-    v.container_as_bytes().iter().any(|&x| x == 0)\n-}"}, {"sha": "af63be2aa9e3f891d0ec2716f7a68cd8e4ddc6b6", "filename": "src/libstd/old_path/posix.rs", "status": "removed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/8415fa27877a4309a79b08c75a52eb4c3546b7a5/src%2Flibstd%2Fold_path%2Fposix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8415fa27877a4309a79b08c75a52eb4c3546b7a5/src%2Flibstd%2Fold_path%2Fposix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_path%2Fposix.rs?ref=8415fa27877a4309a79b08c75a52eb4c3546b7a5"}, {"sha": "65aad38a2b43d5e848edba99ae4d9174fae3d2fa", "filename": "src/libstd/old_path/windows.rs", "status": "removed", "additions": 0, "deletions": 2330, "changes": 2330, "blob_url": "https://github.com/rust-lang/rust/blob/8415fa27877a4309a79b08c75a52eb4c3546b7a5/src%2Flibstd%2Fold_path%2Fwindows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8415fa27877a4309a79b08c75a52eb4c3546b7a5/src%2Flibstd%2Fold_path%2Fwindows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_path%2Fwindows.rs?ref=8415fa27877a4309a79b08c75a52eb4c3546b7a5"}, {"sha": "b7160df6c925dcb3b516e6cd94ba58eee76bd7a1", "filename": "src/libstd/path.rs", "status": "modified", "additions": 19, "deletions": 18, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibstd%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibstd%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath.rs?ref=16e1fcead14628701e1b10b9d00c898d748db2ed"}, {"sha": "c93fc13284b44ac8ef25acbf470a3c56262aa58a", "filename": "src/libstd/prelude/v1.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibstd%2Fprelude%2Fv1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibstd%2Fprelude%2Fv1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprelude%2Fv1.rs?ref=16e1fcead14628701e1b10b9d00c898d748db2ed"}, {"sha": "610b3b3c019d4a45eb847ab4e2b7b1bea7e08c87", "filename": "src/libstd/process.rs", "status": "modified", "additions": 4, "deletions": 43, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibstd%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibstd%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprocess.rs?ref=16e1fcead14628701e1b10b9d00c898d748db2ed"}, {"sha": "e11a5818966fa2125e1d2796c7bb2b9eb41cb4f9", "filename": "src/libstd/rand/mod.rs", "status": "modified", "additions": 7, "deletions": 531, "changes": 538, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibstd%2Frand%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibstd%2Frand%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fmod.rs?ref=16e1fcead14628701e1b10b9d00c898d748db2ed"}, {"sha": "6c10759023770b3f36d861721f4431ae9921bccb", "filename": "src/libstd/rand/os.rs", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibstd%2Frand%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibstd%2Frand%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fos.rs?ref=16e1fcead14628701e1b10b9d00c898d748db2ed"}, {"sha": "60645707c6aeefde6ea4ef78d86bf86b7043507e", "filename": "src/libstd/rand/reader.rs", "status": "modified", "additions": 31, "deletions": 42, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibstd%2Frand%2Freader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibstd%2Frand%2Freader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Freader.rs?ref=16e1fcead14628701e1b10b9d00c898d748db2ed"}, {"sha": "34fcf6cdadd304165d2bc29cfc677ed5f212abe1", "filename": "src/libstd/sync/barrier.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibstd%2Fsync%2Fbarrier.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibstd%2Fsync%2Fbarrier.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fbarrier.rs?ref=16e1fcead14628701e1b10b9d00c898d748db2ed"}, {"sha": "fcb0d2c0b2d38bbe60e00117b1315e1515c15d90", "filename": "src/libstd/sync/condvar.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibstd%2Fsync%2Fcondvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibstd%2Fsync%2Fcondvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fcondvar.rs?ref=16e1fcead14628701e1b10b9d00c898d748db2ed"}, {"sha": "422439fadc1a1b77255d220977b180936a6593f4", "filename": "src/libstd/sync/mpsc/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs?ref=16e1fcead14628701e1b10b9d00c898d748db2ed"}, {"sha": "b8ad92841f2de65a8a7e8ef3df3a17886829fb6e", "filename": "src/libstd/sync/mpsc/select.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibstd%2Fsync%2Fmpsc%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibstd%2Fsync%2Fmpsc%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fselect.rs?ref=16e1fcead14628701e1b10b9d00c898d748db2ed"}, {"sha": "7896870ea07e0c5060019da93ded747edc094a52", "filename": "src/libstd/sync/mutex.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibstd%2Fsync%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibstd%2Fsync%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmutex.rs?ref=16e1fcead14628701e1b10b9d00c898d748db2ed"}, {"sha": "948965f5efa9d157dca85f7e0121eba169546dc0", "filename": "src/libstd/sync/once.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibstd%2Fsync%2Fonce.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibstd%2Fsync%2Fonce.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fonce.rs?ref=16e1fcead14628701e1b10b9d00c898d748db2ed"}, {"sha": "1ea92d5eff7fe92b4e019880ec46360209145ad6", "filename": "src/libstd/sync/rwlock.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibstd%2Fsync%2Frwlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibstd%2Fsync%2Frwlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Frwlock.rs?ref=16e1fcead14628701e1b10b9d00c898d748db2ed"}, {"sha": "9f46b0c38248fef95129fdea634311bee4552f29", "filename": "src/libstd/sys/common/condvar.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibstd%2Fsys%2Fcommon%2Fcondvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibstd%2Fsys%2Fcommon%2Fcondvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fcondvar.rs?ref=16e1fcead14628701e1b10b9d00c898d748db2ed"}, {"sha": "95294b813ea195dbd7bafc7e180e5b98260e416c", "filename": "src/libstd/sys/common/mod.rs", "status": "modified", "additions": 0, "deletions": 91, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibstd%2Fsys%2Fcommon%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibstd%2Fsys%2Fcommon%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fmod.rs?ref=16e1fcead14628701e1b10b9d00c898d748db2ed"}, {"sha": "1f9dd54192ccaeae9170b4e58162b893c2551bf7", "filename": "src/libstd/sys/common/mutex.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibstd%2Fsys%2Fcommon%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibstd%2Fsys%2Fcommon%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fmutex.rs?ref=16e1fcead14628701e1b10b9d00c898d748db2ed"}, {"sha": "6deb4a48007b4aade00d2a07d341087e9b4a98ac", "filename": "src/libstd/sys/common/poison.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibstd%2Fsys%2Fcommon%2Fpoison.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibstd%2Fsys%2Fcommon%2Fpoison.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fpoison.rs?ref=16e1fcead14628701e1b10b9d00c898d748db2ed"}, {"sha": "725a09bcc86a99b88432adfefbc236a2369f0d66", "filename": "src/libstd/sys/common/rwlock.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibstd%2Fsys%2Fcommon%2Frwlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibstd%2Fsys%2Fcommon%2Frwlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Frwlock.rs?ref=16e1fcead14628701e1b10b9d00c898d748db2ed"}, {"sha": "618a389110ac1627b3853da2848d0eae670b9e32", "filename": "src/libstd/sys/common/thread_local.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibstd%2Fsys%2Fcommon%2Fthread_local.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibstd%2Fsys%2Fcommon%2Fthread_local.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fthread_local.rs?ref=16e1fcead14628701e1b10b9d00c898d748db2ed"}, {"sha": "34a4a773f8ea7233ee325efb551ee3cd8a27b2ca", "filename": "src/libstd/sys/common/wtf8.rs", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibstd%2Fsys%2Fcommon%2Fwtf8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibstd%2Fsys%2Fcommon%2Fwtf8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fwtf8.rs?ref=16e1fcead14628701e1b10b9d00c898d748db2ed"}, {"sha": "032fd33b1d348589d29fd706f8971cfbb7301f5c", "filename": "src/libstd/sys/unix/ext.rs", "status": "modified", "additions": 8, "deletions": 83, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibstd%2Fsys%2Funix%2Fext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibstd%2Fsys%2Funix%2Fext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fext.rs?ref=16e1fcead14628701e1b10b9d00c898d748db2ed"}, {"sha": "e5bdb554359df6257ddf43929c7dce9dc922fa11", "filename": "src/libstd/sys/unix/fd.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibstd%2Fsys%2Funix%2Ffd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibstd%2Fsys%2Funix%2Ffd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ffd.rs?ref=16e1fcead14628701e1b10b9d00c898d748db2ed"}, {"sha": "6121105f10b956c4cefb6ce859e9753726ee85ad", "filename": "src/libstd/sys/unix/fs.rs", "status": "removed", "additions": 0, "deletions": 409, "changes": 409, "blob_url": "https://github.com/rust-lang/rust/blob/8415fa27877a4309a79b08c75a52eb4c3546b7a5/src%2Flibstd%2Fsys%2Funix%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8415fa27877a4309a79b08c75a52eb4c3546b7a5/src%2Flibstd%2Fsys%2Funix%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ffs.rs?ref=8415fa27877a4309a79b08c75a52eb4c3546b7a5"}, {"sha": "a8a6219f3981deb2cdf952973448016be13bf301", "filename": "src/libstd/sys/unix/mod.rs", "status": "modified", "additions": 1, "deletions": 110, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibstd%2Fsys%2Funix%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibstd%2Fsys%2Funix%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fmod.rs?ref=16e1fcead14628701e1b10b9d00c898d748db2ed"}, {"sha": "5919502abde0d88eef88aa4e758d5c08f4f5187c", "filename": "src/libstd/sys/unix/os.rs", "status": "modified", "additions": 1, "deletions": 13, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibstd%2Fsys%2Funix%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibstd%2Fsys%2Funix%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fos.rs?ref=16e1fcead14628701e1b10b9d00c898d748db2ed"}, {"sha": "f0071295bf237316afdc4bed80434ea40e267d7f", "filename": "src/libstd/sys/unix/pipe.rs", "status": "removed", "additions": 0, "deletions": 328, "changes": 328, "blob_url": "https://github.com/rust-lang/rust/blob/8415fa27877a4309a79b08c75a52eb4c3546b7a5/src%2Flibstd%2Fsys%2Funix%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8415fa27877a4309a79b08c75a52eb4c3546b7a5/src%2Flibstd%2Fsys%2Funix%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fpipe.rs?ref=8415fa27877a4309a79b08c75a52eb4c3546b7a5"}, {"sha": "8095325f83d1faf553220784814a6e2f84b102a7", "filename": "src/libstd/sys/unix/process.rs", "status": "removed", "additions": 0, "deletions": 627, "changes": 627, "blob_url": "https://github.com/rust-lang/rust/blob/8415fa27877a4309a79b08c75a52eb4c3546b7a5/src%2Flibstd%2Fsys%2Funix%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8415fa27877a4309a79b08c75a52eb4c3546b7a5/src%2Flibstd%2Fsys%2Funix%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fprocess.rs?ref=8415fa27877a4309a79b08c75a52eb4c3546b7a5"}, {"sha": "caa7b4eb29c7bb558ac65a50d6ec1433a81f6a14", "filename": "src/libstd/sys/unix/process2.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibstd%2Fsys%2Funix%2Fprocess2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibstd%2Fsys%2Funix%2Fprocess2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fprocess2.rs?ref=16e1fcead14628701e1b10b9d00c898d748db2ed"}, {"sha": "a9f2198208bc31cbd825ce36302f2c9c4fa0619f", "filename": "src/libstd/sys/unix/tcp.rs", "status": "removed", "additions": 0, "deletions": 164, "changes": 164, "blob_url": "https://github.com/rust-lang/rust/blob/8415fa27877a4309a79b08c75a52eb4c3546b7a5/src%2Flibstd%2Fsys%2Funix%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8415fa27877a4309a79b08c75a52eb4c3546b7a5/src%2Flibstd%2Fsys%2Funix%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ftcp.rs?ref=8415fa27877a4309a79b08c75a52eb4c3546b7a5"}, {"sha": "9309147b15c44f6bd14ae38417bf04ef010fcda2", "filename": "src/libstd/sys/unix/timer.rs", "status": "removed", "additions": 0, "deletions": 294, "changes": 294, "blob_url": "https://github.com/rust-lang/rust/blob/8415fa27877a4309a79b08c75a52eb4c3546b7a5/src%2Flibstd%2Fsys%2Funix%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8415fa27877a4309a79b08c75a52eb4c3546b7a5/src%2Flibstd%2Fsys%2Funix%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ftimer.rs?ref=8415fa27877a4309a79b08c75a52eb4c3546b7a5"}, {"sha": "2f6fd713bfba50c01d7049e83e84ab5a48d873fd", "filename": "src/libstd/sys/unix/tty.rs", "status": "removed", "additions": 0, "deletions": 81, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/8415fa27877a4309a79b08c75a52eb4c3546b7a5/src%2Flibstd%2Fsys%2Funix%2Ftty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8415fa27877a4309a79b08c75a52eb4c3546b7a5/src%2Flibstd%2Fsys%2Funix%2Ftty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ftty.rs?ref=8415fa27877a4309a79b08c75a52eb4c3546b7a5"}, {"sha": "90548dcefb4830b9fac6bee44095642f26f6ed52", "filename": "src/libstd/sys/windows/ext.rs", "status": "modified", "additions": 9, "deletions": 84, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibstd%2Fsys%2Fwindows%2Fext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibstd%2Fsys%2Fwindows%2Fext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fext.rs?ref=16e1fcead14628701e1b10b9d00c898d748db2ed"}, {"sha": "0bbb1a9e92752c09c39f81adbcb6b53335b23baf", "filename": "src/libstd/sys/windows/fs.rs", "status": "removed", "additions": 0, "deletions": 452, "changes": 452, "blob_url": "https://github.com/rust-lang/rust/blob/8415fa27877a4309a79b08c75a52eb4c3546b7a5/src%2Flibstd%2Fsys%2Fwindows%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8415fa27877a4309a79b08c75a52eb4c3546b7a5/src%2Flibstd%2Fsys%2Fwindows%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Ffs.rs?ref=8415fa27877a4309a79b08c75a52eb4c3546b7a5"}, {"sha": "a9fb2c682276715b3eadb2ad52057da118415082", "filename": "src/libstd/sys/windows/helper_signal.rs", "status": "removed", "additions": 0, "deletions": 38, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/8415fa27877a4309a79b08c75a52eb4c3546b7a5/src%2Flibstd%2Fsys%2Fwindows%2Fhelper_signal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8415fa27877a4309a79b08c75a52eb4c3546b7a5/src%2Flibstd%2Fsys%2Fwindows%2Fhelper_signal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fhelper_signal.rs?ref=8415fa27877a4309a79b08c75a52eb4c3546b7a5"}, {"sha": "1171c6c068b12077b2ad92328cf035149266a189", "filename": "src/libstd/sys/windows/mod.rs", "status": "modified", "additions": 2, "deletions": 174, "changes": 176, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs?ref=16e1fcead14628701e1b10b9d00c898d748db2ed"}, {"sha": "5cfc20104245b4bef8db545e42da939d054661d9", "filename": "src/libstd/sys/windows/os.rs", "status": "modified", "additions": 6, "deletions": 28, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibstd%2Fsys%2Fwindows%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibstd%2Fsys%2Fwindows%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fos.rs?ref=16e1fcead14628701e1b10b9d00c898d748db2ed"}, {"sha": "064c003bd15a909b90392f5ce531e5330a6085d7", "filename": "src/libstd/sys/windows/pipe.rs", "status": "removed", "additions": 0, "deletions": 775, "changes": 775, "blob_url": "https://github.com/rust-lang/rust/blob/8415fa27877a4309a79b08c75a52eb4c3546b7a5/src%2Flibstd%2Fsys%2Fwindows%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8415fa27877a4309a79b08c75a52eb4c3546b7a5/src%2Flibstd%2Fsys%2Fwindows%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fpipe.rs?ref=8415fa27877a4309a79b08c75a52eb4c3546b7a5"}, {"sha": "b10042090ddc8d634a89d875cb10334ea07cf52e", "filename": "src/libstd/sys/windows/process.rs", "status": "removed", "additions": 0, "deletions": 518, "changes": 518, "blob_url": "https://github.com/rust-lang/rust/blob/8415fa27877a4309a79b08c75a52eb4c3546b7a5/src%2Flibstd%2Fsys%2Fwindows%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8415fa27877a4309a79b08c75a52eb4c3546b7a5/src%2Flibstd%2Fsys%2Fwindows%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fprocess.rs?ref=8415fa27877a4309a79b08c75a52eb4c3546b7a5"}, {"sha": "41e97dc8475027741473f7f5458ff89661bdfea2", "filename": "src/libstd/sys/windows/tcp.rs", "status": "removed", "additions": 0, "deletions": 230, "changes": 230, "blob_url": "https://github.com/rust-lang/rust/blob/8415fa27877a4309a79b08c75a52eb4c3546b7a5/src%2Flibstd%2Fsys%2Fwindows%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8415fa27877a4309a79b08c75a52eb4c3546b7a5/src%2Flibstd%2Fsys%2Fwindows%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Ftcp.rs?ref=8415fa27877a4309a79b08c75a52eb4c3546b7a5"}, {"sha": "8856cc26b2e9060b8eaa3dbff863e5e70a6bba5f", "filename": "src/libstd/sys/windows/timer.rs", "status": "removed", "additions": 0, "deletions": 214, "changes": 214, "blob_url": "https://github.com/rust-lang/rust/blob/8415fa27877a4309a79b08c75a52eb4c3546b7a5/src%2Flibstd%2Fsys%2Fwindows%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8415fa27877a4309a79b08c75a52eb4c3546b7a5/src%2Flibstd%2Fsys%2Fwindows%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Ftimer.rs?ref=8415fa27877a4309a79b08c75a52eb4c3546b7a5"}, {"sha": "791c7532bd007148b282967fb797a45828b29c34", "filename": "src/libstd/sys/windows/tty.rs", "status": "removed", "additions": 0, "deletions": 169, "changes": 169, "blob_url": "https://github.com/rust-lang/rust/blob/8415fa27877a4309a79b08c75a52eb4c3546b7a5/src%2Flibstd%2Fsys%2Fwindows%2Ftty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8415fa27877a4309a79b08c75a52eb4c3546b7a5/src%2Flibstd%2Fsys%2Fwindows%2Ftty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Ftty.rs?ref=8415fa27877a4309a79b08c75a52eb4c3546b7a5"}, {"sha": "50f8fb828ad323572f17ef3972cbb0f9d5861996", "filename": "src/libstd/sys/windows/udp.rs", "status": "removed", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/8415fa27877a4309a79b08c75a52eb4c3546b7a5/src%2Flibstd%2Fsys%2Fwindows%2Fudp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8415fa27877a4309a79b08c75a52eb4c3546b7a5/src%2Flibstd%2Fsys%2Fwindows%2Fudp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fudp.rs?ref=8415fa27877a4309a79b08c75a52eb4c3546b7a5"}, {"sha": "cc4031cc180765ffa7866f18c7af120e3844959a", "filename": "src/libstd/thread/local.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibstd%2Fthread%2Flocal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibstd%2Fthread%2Flocal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread%2Flocal.rs?ref=16e1fcead14628701e1b10b9d00c898d748db2ed"}, {"sha": "4fd0340f09ac0ef533feff7194203883603a11ab", "filename": "src/libstd/thread/mod.rs", "status": "modified", "additions": 60, "deletions": 36, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibstd%2Fthread%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibstd%2Fthread%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread%2Fmod.rs?ref=16e1fcead14628701e1b10b9d00c898d748db2ed"}, {"sha": "9c0b4a5d8337800211d774098f57f81fa9f5a132", "filename": "src/libstd/thread/scoped_tls.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibstd%2Fthread%2Fscoped_tls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibstd%2Fthread%2Fscoped_tls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread%2Fscoped_tls.rs?ref=16e1fcead14628701e1b10b9d00c898d748db2ed"}, {"sha": "1505d1e91b8206a9e44b8b4b5b938b16f35b6d06", "filename": "src/libsyntax/ast_map/blocks.rs", "status": "modified", "additions": 18, "deletions": 11, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibsyntax%2Fast_map%2Fblocks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibsyntax%2Fast_map%2Fblocks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map%2Fblocks.rs?ref=16e1fcead14628701e1b10b9d00c898d748db2ed"}, {"sha": "0ad75c5ec8cbcddba43adf03c83500b18e06f297", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=16e1fcead14628701e1b10b9d00c898d748db2ed"}, {"sha": "65554efdd680f9229fc9332799295db930d63a6e", "filename": "src/libsyntax/ext/deriving/mod.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs?ref=16e1fcead14628701e1b10b9d00c898d748db2ed"}, {"sha": "631e5f979d9ee7a38a1cf426dbc141828fa0f6a3", "filename": "src/libsyntax/ext/deriving/rand.rs", "status": "removed", "additions": 0, "deletions": 175, "changes": 175, "blob_url": "https://github.com/rust-lang/rust/blob/8415fa27877a4309a79b08c75a52eb4c3546b7a5/src%2Flibsyntax%2Fext%2Fderiving%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8415fa27877a4309a79b08c75a52eb4c3546b7a5/src%2Flibsyntax%2Fext%2Fderiving%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Frand.rs?ref=8415fa27877a4309a79b08c75a52eb4c3546b7a5"}, {"sha": "a6f8a718b3381f01b14f0a76122f84f0822b6fa0", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=16e1fcead14628701e1b10b9d00c898d748db2ed"}, {"sha": "3f36d0e8eda0f8ebd8246b3b45e246102cd1b12b", "filename": "src/libsyntax/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibsyntax%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibsyntax%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Flib.rs?ref=16e1fcead14628701e1b10b9d00c898d748db2ed"}, {"sha": "e45b7c1df91ca69aba6dfb84d00870cc32284eec", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=16e1fcead14628701e1b10b9d00c898d748db2ed"}, {"sha": "2bb74944ce91abf0b085cd932ceb4439e985ae62", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=16e1fcead14628701e1b10b9d00c898d748db2ed"}, {"sha": "3f883fb11725bc0f43eab3e1db2f8b71955e09db", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=16e1fcead14628701e1b10b9d00c898d748db2ed"}, {"sha": "4c70fc9f81fb93ce267563a3253b1fe0614e51cc", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=16e1fcead14628701e1b10b9d00c898d748db2ed"}, {"sha": "a786d24ed8581426c778ac346ab16084e02b48db", "filename": "src/libtest/stats.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibtest%2Fstats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Flibtest%2Fstats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Fstats.rs?ref=16e1fcead14628701e1b10b9d00c898d748db2ed"}, {"sha": "8f3e939f1f40d7f37f6954a51e54e92c4235354f", "filename": "src/test/bench/core-map.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Ftest%2Fbench%2Fcore-map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Ftest%2Fbench%2Fcore-map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-map.rs?ref=16e1fcead14628701e1b10b9d00c898d748db2ed"}, {"sha": "d910367afbf496088ebcc49ff599bbde2787105c", "filename": "src/test/bench/core-std.rs", "status": "modified", "additions": 5, "deletions": 23, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Ftest%2Fbench%2Fcore-std.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Ftest%2Fbench%2Fcore-std.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-std.rs?ref=16e1fcead14628701e1b10b9d00c898d748db2ed"}, {"sha": "c21470d4bb3e7f48e82ccf4f5b2c998382730d44", "filename": "src/test/bench/noise.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Ftest%2Fbench%2Fnoise.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Ftest%2Fbench%2Fnoise.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fnoise.rs?ref=16e1fcead14628701e1b10b9d00c898d748db2ed"}, {"sha": "61fe6593dc398dd72381c5691bf9b5aa51d4e5f6", "filename": "src/test/bench/shootout-binarytrees.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Ftest%2Fbench%2Fshootout-binarytrees.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Ftest%2Fbench%2Fshootout-binarytrees.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-binarytrees.rs?ref=16e1fcead14628701e1b10b9d00c898d748db2ed"}, {"sha": "32504350e42682d33fcea64af426e6a1fe65c032", "filename": "src/test/bench/shootout-fannkuch-redux.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Ftest%2Fbench%2Fshootout-fannkuch-redux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Ftest%2Fbench%2Fshootout-fannkuch-redux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fannkuch-redux.rs?ref=16e1fcead14628701e1b10b9d00c898d748db2ed"}, {"sha": "145ab71446354183d32dcefdcb80223b70532aa5", "filename": "src/test/bench/shootout-fasta-redux.rs", "status": "modified", "additions": 21, "deletions": 19, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Ftest%2Fbench%2Fshootout-fasta-redux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Ftest%2Fbench%2Fshootout-fasta-redux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fasta-redux.rs?ref=16e1fcead14628701e1b10b9d00c898d748db2ed"}, {"sha": "0474cfb6fc8193c90356172d713afac0b17f32d2", "filename": "src/test/bench/shootout-fasta.rs", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Ftest%2Fbench%2Fshootout-fasta.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Ftest%2Fbench%2Fshootout-fasta.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fasta.rs?ref=16e1fcead14628701e1b10b9d00c898d748db2ed"}, {"sha": "bcd8fbf88523ea8c3d87f6852352bec101931c7f", "filename": "src/test/bench/shootout-k-nucleotide-pipes.rs", "status": "modified", "additions": 12, "deletions": 15, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs?ref=16e1fcead14628701e1b10b9d00c898d748db2ed"}, {"sha": "07cb120ef0e29c18cf0d7ca1bef57d9802170d8d", "filename": "src/test/bench/shootout-k-nucleotide.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs?ref=16e1fcead14628701e1b10b9d00c898d748db2ed"}, {"sha": "f2714d55e5ea772753b032451524ee927873b0b1", "filename": "src/test/bench/shootout-mandelbrot.rs", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs?ref=16e1fcead14628701e1b10b9d00c898d748db2ed"}, {"sha": "7c9f33678a39c924fdabdd7849fe75a1bf865f49", "filename": "src/test/bench/shootout-reverse-complement.rs", "status": "modified", "additions": 15, "deletions": 50, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Ftest%2Fbench%2Fshootout-reverse-complement.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Ftest%2Fbench%2Fshootout-reverse-complement.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-reverse-complement.rs?ref=16e1fcead14628701e1b10b9d00c898d748db2ed"}, {"sha": "b0e8c39567323b4b32ec5d5d8503c57095051995", "filename": "src/test/bench/shootout-spectralnorm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Ftest%2Fbench%2Fshootout-spectralnorm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Ftest%2Fbench%2Fshootout-spectralnorm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-spectralnorm.rs?ref=16e1fcead14628701e1b10b9d00c898d748db2ed"}, {"sha": "327e2c9e0f996d7aac466c30a3dfa78ef5b19e40", "filename": "src/test/compile-fail/derive-no-std-not-supported.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Ftest%2Fcompile-fail%2Fderive-no-std-not-supported.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Ftest%2Fcompile-fail%2Fderive-no-std-not-supported.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fderive-no-std-not-supported.rs?ref=16e1fcead14628701e1b10b9d00c898d748db2ed"}, {"sha": "a4df42a8c70f25245da96d7af1f06b5ab087a35d", "filename": "src/test/compile-fail/issue-24365.rs", "status": "renamed", "additions": 15, "deletions": 12, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Ftest%2Fcompile-fail%2Fissue-24365.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Ftest%2Fcompile-fail%2Fissue-24365.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-24365.rs?ref=16e1fcead14628701e1b10b9d00c898d748db2ed", "previous_filename": "src/test/run-pass/issue-12684.rs"}, {"sha": "a1ca59caa3304008e638380cb13c2f4c1390371b", "filename": "src/test/debuginfo/function-arg-initialization.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Ftest%2Fdebuginfo%2Ffunction-arg-initialization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Ftest%2Fdebuginfo%2Ffunction-arg-initialization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Ffunction-arg-initialization.rs?ref=16e1fcead14628701e1b10b9d00c898d748db2ed"}, {"sha": "7e959a1e920126bb08e647eaaa45a64a2558e62d", "filename": "src/test/debuginfo/function-prologue-stepping-no-stack-check.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Ftest%2Fdebuginfo%2Ffunction-prologue-stepping-no-stack-check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Ftest%2Fdebuginfo%2Ffunction-prologue-stepping-no-stack-check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Ffunction-prologue-stepping-no-stack-check.rs?ref=16e1fcead14628701e1b10b9d00c898d748db2ed"}, {"sha": "b34f1af01f5fd35b76bfda019fdcf9569737b016", "filename": "src/test/debuginfo/function-prologue-stepping-regular.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Ftest%2Fdebuginfo%2Ffunction-prologue-stepping-regular.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Ftest%2Fdebuginfo%2Ffunction-prologue-stepping-regular.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Ffunction-prologue-stepping-regular.rs?ref=16e1fcead14628701e1b10b9d00c898d748db2ed"}, {"sha": "13dc0c6d12007e1f9dc5a8d8b0450783e69143b2", "filename": "src/test/debuginfo/issue13213.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Ftest%2Fdebuginfo%2Fissue13213.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Ftest%2Fdebuginfo%2Fissue13213.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fissue13213.rs?ref=16e1fcead14628701e1b10b9d00c898d748db2ed"}, {"sha": "561f141100ca7c3a7c962f4a50c7b893598b162c", "filename": "src/test/run-fail/panic-task-name-owned.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Ftest%2Frun-fail%2Fpanic-task-name-owned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Ftest%2Frun-fail%2Fpanic-task-name-owned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fpanic-task-name-owned.rs?ref=16e1fcead14628701e1b10b9d00c898d748db2ed"}, {"sha": "b4f0d7ceb99eb911ef8990dcd7ee8d3c52129191", "filename": "src/test/run-fail/rt-set-exit-status-panic2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Ftest%2Frun-fail%2Frt-set-exit-status-panic2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Ftest%2Frun-fail%2Frt-set-exit-status-panic2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Frt-set-exit-status-panic2.rs?ref=16e1fcead14628701e1b10b9d00c898d748db2ed"}, {"sha": "fe84db08da9008f6af7349f7e4dc98fb16a9d08e", "filename": "src/test/run-make/save-analysis/SubDir/mod.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Ftest%2Frun-make%2Fsave-analysis%2FSubDir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Ftest%2Frun-make%2Fsave-analysis%2FSubDir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fsave-analysis%2FSubDir%2Fmod.rs?ref=16e1fcead14628701e1b10b9d00c898d748db2ed"}, {"sha": "fe0f32d97d6b102c07e0d49cd80293934503436c", "filename": "src/test/run-make/save-analysis/foo.rs", "status": "modified", "additions": 24, "deletions": 27, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Ftest%2Frun-make%2Fsave-analysis%2Ffoo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Ftest%2Frun-make%2Fsave-analysis%2Ffoo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fsave-analysis%2Ffoo.rs?ref=16e1fcead14628701e1b10b9d00c898d748db2ed"}, {"sha": "b1fe938767dc912cd8a533b7df908799b2e6fd3d", "filename": "src/test/run-make/unicode-input/multiple_files.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Ftest%2Frun-make%2Funicode-input%2Fmultiple_files.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Ftest%2Frun-make%2Funicode-input%2Fmultiple_files.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Funicode-input%2Fmultiple_files.rs?ref=16e1fcead14628701e1b10b9d00c898d748db2ed"}, {"sha": "0c01a84d1bf93c1025dfe6a4f76ad987e383797f", "filename": "src/test/run-make/unicode-input/span_length.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Ftest%2Frun-make%2Funicode-input%2Fspan_length.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Ftest%2Frun-make%2Funicode-input%2Fspan_length.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Funicode-input%2Fspan_length.rs?ref=16e1fcead14628701e1b10b9d00c898d748db2ed"}, {"sha": "7e64bbdf703b7911dee91dc0173d2f995d1cfeb5", "filename": "src/test/run-pass-fulldeps/issue-15149.rs", "status": "renamed", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Ftest%2Frun-pass-fulldeps%2Fissue-15149.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Ftest%2Frun-pass-fulldeps%2Fissue-15149.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fissue-15149.rs?ref=16e1fcead14628701e1b10b9d00c898d748db2ed", "previous_filename": "src/test/run-pass/issue-15149.rs"}, {"sha": "dcdce50c1e9b5dba35a39534a9f2042c5e9c46c2", "filename": "src/test/run-pass-valgrind/cleanup-stdin.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Ftest%2Frun-pass-valgrind%2Fcleanup-stdin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Ftest%2Frun-pass-valgrind%2Fcleanup-stdin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-valgrind%2Fcleanup-stdin.rs?ref=16e1fcead14628701e1b10b9d00c898d748db2ed"}, {"sha": "ae0a358ac4e3f952d6a1681c310e20e4ac41f43e", "filename": "src/test/run-pass/atomic-print.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Ftest%2Frun-pass%2Fatomic-print.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Ftest%2Frun-pass%2Fatomic-print.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fatomic-print.rs?ref=16e1fcead14628701e1b10b9d00c898d748db2ed"}, {"sha": "f4b62eb2e7c50a4191a540983dbdac96d5e461d9", "filename": "src/test/run-pass/backtrace.rs", "status": "modified", "additions": 17, "deletions": 15, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Ftest%2Frun-pass%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Ftest%2Frun-pass%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbacktrace.rs?ref=16e1fcead14628701e1b10b9d00c898d748db2ed"}, {"sha": "6c58194f857a6769dee846ad8d90cdca4ba8904d", "filename": "src/test/run-pass/capturing-logging.rs", "status": "removed", "additions": 0, "deletions": 46, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/8415fa27877a4309a79b08c75a52eb4c3546b7a5/src%2Ftest%2Frun-pass%2Fcapturing-logging.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8415fa27877a4309a79b08c75a52eb4c3546b7a5/src%2Ftest%2Frun-pass%2Fcapturing-logging.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcapturing-logging.rs?ref=8415fa27877a4309a79b08c75a52eb4c3546b7a5"}, {"sha": "5a7b1c83dfda3acca3a9e410b34cac239b9efe09", "filename": "src/test/run-pass/clone-with-exterior.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Ftest%2Frun-pass%2Fclone-with-exterior.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Ftest%2Frun-pass%2Fclone-with-exterior.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclone-with-exterior.rs?ref=16e1fcead14628701e1b10b9d00c898d748db2ed"}, {"sha": "50f05c050b173cfee3f3d3a12a006eee5fd746a0", "filename": "src/test/run-pass/closure-reform.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Ftest%2Frun-pass%2Fclosure-reform.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Ftest%2Frun-pass%2Fclosure-reform.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclosure-reform.rs?ref=16e1fcead14628701e1b10b9d00c898d748db2ed"}, {"sha": "72f623ccfde7aaa30a0e207a8c5834acaec7ff7e", "filename": "src/test/run-pass/comm.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Ftest%2Frun-pass%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Ftest%2Frun-pass%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcomm.rs?ref=16e1fcead14628701e1b10b9d00c898d748db2ed"}, {"sha": "df7cedd1c293890adc17ccb1114204d6d66ef3ce", "filename": "src/test/run-pass/core-run-destroy.rs", "status": "modified", "additions": 27, "deletions": 42, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Ftest%2Frun-pass%2Fcore-run-destroy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Ftest%2Frun-pass%2Fcore-run-destroy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcore-run-destroy.rs?ref=16e1fcead14628701e1b10b9d00c898d748db2ed"}, {"sha": "10e8ddc41f3f9e71da6585ad1decea0dda069f22", "filename": "src/test/run-pass/deriving-global.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Ftest%2Frun-pass%2Fderiving-global.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Ftest%2Frun-pass%2Fderiving-global.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-global.rs?ref=16e1fcead14628701e1b10b9d00c898d748db2ed"}, {"sha": "bc11b55d3105f3029fa9a054a4a77047cb5f3c6e", "filename": "src/test/run-pass/deriving-rand.rs", "status": "removed", "additions": 0, "deletions": 43, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/8415fa27877a4309a79b08c75a52eb4c3546b7a5/src%2Ftest%2Frun-pass%2Fderiving-rand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8415fa27877a4309a79b08c75a52eb4c3546b7a5/src%2Ftest%2Frun-pass%2Fderiving-rand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-rand.rs?ref=8415fa27877a4309a79b08c75a52eb4c3546b7a5"}, {"sha": "f9e1b651a4933edcbb9493ff9e37d1a854038dc7", "filename": "src/test/run-pass/drop-flag-sanity-check.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Ftest%2Frun-pass%2Fdrop-flag-sanity-check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Ftest%2Frun-pass%2Fdrop-flag-sanity-check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdrop-flag-sanity-check.rs?ref=16e1fcead14628701e1b10b9d00c898d748db2ed"}, {"sha": "4a6c8ce70dcee16d2dc711b8d836c055904369d3", "filename": "src/test/run-pass/drop-flag-skip-sanity-check.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Ftest%2Frun-pass%2Fdrop-flag-skip-sanity-check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Ftest%2Frun-pass%2Fdrop-flag-skip-sanity-check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdrop-flag-skip-sanity-check.rs?ref=16e1fcead14628701e1b10b9d00c898d748db2ed"}, {"sha": "b35095171ece00d800c2b918a5a407c996c6cc77", "filename": "src/test/run-pass/extern-call-deep2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Ftest%2Frun-pass%2Fextern-call-deep2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Ftest%2Frun-pass%2Fextern-call-deep2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fextern-call-deep2.rs?ref=16e1fcead14628701e1b10b9d00c898d748db2ed"}, {"sha": "3993868068197ebb44a026865b761c85f6b78867", "filename": "src/test/run-pass/extern-call-scrub.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Ftest%2Frun-pass%2Fextern-call-scrub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Ftest%2Frun-pass%2Fextern-call-scrub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fextern-call-scrub.rs?ref=16e1fcead14628701e1b10b9d00c898d748db2ed"}, {"sha": "3be47e8430d598f675336ea0bda6a11300d7e097", "filename": "src/test/run-pass/fds-are-cloexec.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Ftest%2Frun-pass%2Ffds-are-cloexec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Ftest%2Frun-pass%2Ffds-are-cloexec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ffds-are-cloexec.rs?ref=16e1fcead14628701e1b10b9d00c898d748db2ed"}, {"sha": "ea9db9b1e1f8d91aabb86d5628b4c727f9af657f", "filename": "src/test/run-pass/ifmt.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Ftest%2Frun-pass%2Fifmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Ftest%2Frun-pass%2Fifmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fifmt.rs?ref=16e1fcead14628701e1b10b9d00c898d748db2ed"}, {"sha": "dafa8ee10339ee706c810153987fe7787bbc35a3", "filename": "src/test/run-pass/init-large-type.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Ftest%2Frun-pass%2Finit-large-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Ftest%2Frun-pass%2Finit-large-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Finit-large-type.rs?ref=16e1fcead14628701e1b10b9d00c898d748db2ed"}, {"sha": "0d8f22254857db7ee9376dca003537fc9c92fb04", "filename": "src/test/run-pass/issue-10626.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Ftest%2Frun-pass%2Fissue-10626.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Ftest%2Frun-pass%2Fissue-10626.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-10626.rs?ref=16e1fcead14628701e1b10b9d00c898d748db2ed"}, {"sha": "1e9f30bb766b206f5a99d3ffcead2f5378ed0615", "filename": "src/test/run-pass/issue-12699.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Ftest%2Frun-pass%2Fissue-12699.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Ftest%2Frun-pass%2Fissue-12699.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-12699.rs?ref=16e1fcead14628701e1b10b9d00c898d748db2ed"}, {"sha": "71897ea68c209b39358e5ca678a632e1978584ca", "filename": "src/test/run-pass/issue-13494.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Ftest%2Frun-pass%2Fissue-13494.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Ftest%2Frun-pass%2Fissue-13494.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-13494.rs?ref=16e1fcead14628701e1b10b9d00c898d748db2ed"}, {"sha": "566836784696d813d7ae35b631bc7aeb5f32fc63", "filename": "src/test/run-pass/issue-14901.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Ftest%2Frun-pass%2Fissue-14901.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Ftest%2Frun-pass%2Fissue-14901.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-14901.rs?ref=16e1fcead14628701e1b10b9d00c898d748db2ed"}, {"sha": "a256e619216862d5e9205ef0c7432fae46f5f4c7", "filename": "src/test/run-pass/issue-18619.rs", "status": "removed", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/8415fa27877a4309a79b08c75a52eb4c3546b7a5/src%2Ftest%2Frun-pass%2Fissue-18619.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8415fa27877a4309a79b08c75a52eb4c3546b7a5/src%2Ftest%2Frun-pass%2Fissue-18619.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-18619.rs?ref=8415fa27877a4309a79b08c75a52eb4c3546b7a5"}, {"sha": "522f544a21c1037c87e89c7142c8ecb8d2a31efd", "filename": "src/test/run-pass/issue-20454.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Ftest%2Frun-pass%2Fissue-20454.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Ftest%2Frun-pass%2Fissue-20454.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-20454.rs?ref=16e1fcead14628701e1b10b9d00c898d748db2ed"}, {"sha": "2c45d664d894e402450d19da32f7d476b8c97fe6", "filename": "src/test/run-pass/issue-2904.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Ftest%2Frun-pass%2Fissue-2904.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Ftest%2Frun-pass%2Fissue-2904.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2904.rs?ref=16e1fcead14628701e1b10b9d00c898d748db2ed"}, {"sha": "74e58f31e23e245ce43af6a84f7dc458f8f9b534", "filename": "src/test/run-pass/issue-3424.rs", "status": "modified", "additions": 5, "deletions": 12, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Ftest%2Frun-pass%2Fissue-3424.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Ftest%2Frun-pass%2Fissue-3424.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-3424.rs?ref=16e1fcead14628701e1b10b9d00c898d748db2ed"}, {"sha": "61de3c6385e7bb49581f01e73703a241e7ded94b", "filename": "src/test/run-pass/issue-3609.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Ftest%2Frun-pass%2Fissue-3609.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Ftest%2Frun-pass%2Fissue-3609.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-3609.rs?ref=16e1fcead14628701e1b10b9d00c898d748db2ed"}, {"sha": "9292a9c608eb9fbd028b0008548a07780f09f0e2", "filename": "src/test/run-pass/issue-4446.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Ftest%2Frun-pass%2Fissue-4446.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Ftest%2Frun-pass%2Fissue-4446.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-4446.rs?ref=16e1fcead14628701e1b10b9d00c898d748db2ed"}, {"sha": "2cf0089c6bb65df7f1bd58748b4c44c5e4aa968e", "filename": "src/test/run-pass/issue-5988.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Ftest%2Frun-pass%2Fissue-5988.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Ftest%2Frun-pass%2Fissue-5988.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-5988.rs?ref=16e1fcead14628701e1b10b9d00c898d748db2ed"}, {"sha": "5c2c03f9857f3809d54458d7e33ccb8436767a94", "filename": "src/test/run-pass/issue-8398.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Ftest%2Frun-pass%2Fissue-8398.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Ftest%2Frun-pass%2Fissue-8398.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-8398.rs?ref=16e1fcead14628701e1b10b9d00c898d748db2ed"}, {"sha": "ed67630bcac44540024f6834e9065d65799855a2", "filename": "src/test/run-pass/issue-9396.rs", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Ftest%2Frun-pass%2Fissue-9396.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Ftest%2Frun-pass%2Fissue-9396.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-9396.rs?ref=16e1fcead14628701e1b10b9d00c898d748db2ed"}, {"sha": "7a41a0139273ffffeb63bd110c19462f73fc50fa", "filename": "src/test/run-pass/issue24353.rs", "status": "renamed", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Ftest%2Frun-pass%2Fissue24353.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Ftest%2Frun-pass%2Fissue24353.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue24353.rs?ref=16e1fcead14628701e1b10b9d00c898d748db2ed", "previous_filename": "src/libstd/sys/unix/udp.rs"}, {"sha": "3f0daf2610ce970704f31a2fa685b3a23b8fda7d", "filename": "src/test/run-pass/ivec-tag.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Ftest%2Frun-pass%2Fivec-tag.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Ftest%2Frun-pass%2Fivec-tag.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fivec-tag.rs?ref=16e1fcead14628701e1b10b9d00c898d748db2ed"}, {"sha": "a81c0846a279489534080fc789c3cb7ef5509040", "filename": "src/test/run-pass/kindck-implicit-close-over-mut-var.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Ftest%2Frun-pass%2Fkindck-implicit-close-over-mut-var.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Ftest%2Frun-pass%2Fkindck-implicit-close-over-mut-var.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fkindck-implicit-close-over-mut-var.rs?ref=16e1fcead14628701e1b10b9d00c898d748db2ed"}, {"sha": "29cfe91eba5acce01f17ec2cea8e0ecdd1605b64", "filename": "src/test/run-pass/logging-separate-lines.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Ftest%2Frun-pass%2Flogging-separate-lines.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Ftest%2Frun-pass%2Flogging-separate-lines.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flogging-separate-lines.rs?ref=16e1fcead14628701e1b10b9d00c898d748db2ed"}, {"sha": "1611a2c07227a97a3d5db5f1ac9fd8fde36678a2", "filename": "src/test/run-pass/method-mut-self-modifies-mut-slice-lvalue.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Ftest%2Frun-pass%2Fmethod-mut-self-modifies-mut-slice-lvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Ftest%2Frun-pass%2Fmethod-mut-self-modifies-mut-slice-lvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmethod-mut-self-modifies-mut-slice-lvalue.rs?ref=16e1fcead14628701e1b10b9d00c898d748db2ed"}, {"sha": "c7ef9776367bd10d410d56e80f68dd398b428557", "filename": "src/test/run-pass/moves-based-on-type-capture-clause.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Ftest%2Frun-pass%2Fmoves-based-on-type-capture-clause.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Ftest%2Frun-pass%2Fmoves-based-on-type-capture-clause.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmoves-based-on-type-capture-clause.rs?ref=16e1fcead14628701e1b10b9d00c898d748db2ed"}, {"sha": "0d0a5bee8a443f879ddc00df20d2bf80d1a153de", "filename": "src/test/run-pass/out-of-stack-new-thread-no-split.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Ftest%2Frun-pass%2Fout-of-stack-new-thread-no-split.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Ftest%2Frun-pass%2Fout-of-stack-new-thread-no-split.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fout-of-stack-new-thread-no-split.rs?ref=16e1fcead14628701e1b10b9d00c898d748db2ed"}, {"sha": "da7342d251e6e3e550caca73f4c77ed166cbfc90", "filename": "src/test/run-pass/out-of-stack-no-split.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Ftest%2Frun-pass%2Fout-of-stack-no-split.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Ftest%2Frun-pass%2Fout-of-stack-no-split.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fout-of-stack-no-split.rs?ref=16e1fcead14628701e1b10b9d00c898d748db2ed"}, {"sha": "d90b88cbfd57348b263f85b77cb4b0cc24c50859", "filename": "src/test/run-pass/out-of-stack.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Ftest%2Frun-pass%2Fout-of-stack.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Ftest%2Frun-pass%2Fout-of-stack.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fout-of-stack.rs?ref=16e1fcead14628701e1b10b9d00c898d748db2ed"}, {"sha": "3096fe4a266c996e2551e2c994a8cccc16b5015a", "filename": "src/test/run-pass/process-remove-from-env.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Ftest%2Frun-pass%2Fprocess-remove-from-env.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Ftest%2Frun-pass%2Fprocess-remove-from-env.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fprocess-remove-from-env.rs?ref=16e1fcead14628701e1b10b9d00c898d748db2ed"}, {"sha": "31d97305e0be49e7b6a37c2a89702b229c1e612d", "filename": "src/test/run-pass/running-with-no-runtime.rs", "status": "modified", "additions": 16, "deletions": 21, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Ftest%2Frun-pass%2Frunning-with-no-runtime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Ftest%2Frun-pass%2Frunning-with-no-runtime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frunning-with-no-runtime.rs?ref=16e1fcead14628701e1b10b9d00c898d748db2ed"}, {"sha": "59179206104f8421cf8229d053dcccac638dcd29", "filename": "src/test/run-pass/rust-log-filter.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Ftest%2Frun-pass%2Frust-log-filter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Ftest%2Frun-pass%2Frust-log-filter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frust-log-filter.rs?ref=16e1fcead14628701e1b10b9d00c898d748db2ed"}, {"sha": "dd33c330cfd36b652466ad7cd196f9f34f50b1cf", "filename": "src/test/run-pass/segfault-no-out-of-stack.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Ftest%2Frun-pass%2Fsegfault-no-out-of-stack.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Ftest%2Frun-pass%2Fsegfault-no-out-of-stack.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsegfault-no-out-of-stack.rs?ref=16e1fcead14628701e1b10b9d00c898d748db2ed"}, {"sha": "5f0902d34d3e87a28a73fa8809742fca4bab9587", "filename": "src/test/run-pass/send-is-not-static-par-for.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Ftest%2Frun-pass%2Fsend-is-not-static-par-for.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Ftest%2Frun-pass%2Fsend-is-not-static-par-for.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsend-is-not-static-par-for.rs?ref=16e1fcead14628701e1b10b9d00c898d748db2ed"}, {"sha": "66878d98c840cf5088112c79cb33c96aabb0f041", "filename": "src/test/run-pass/send-resource.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Ftest%2Frun-pass%2Fsend-resource.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Ftest%2Frun-pass%2Fsend-resource.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsend-resource.rs?ref=16e1fcead14628701e1b10b9d00c898d748db2ed"}, {"sha": "51b369092f0f4e7a2cb42703c1f22c7ef71a835c", "filename": "src/test/run-pass/signal-exit-status.rs", "status": "modified", "additions": 2, "deletions": 10, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Ftest%2Frun-pass%2Fsignal-exit-status.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Ftest%2Frun-pass%2Fsignal-exit-status.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsignal-exit-status.rs?ref=16e1fcead14628701e1b10b9d00c898d748db2ed"}, {"sha": "4a35ed609e0801c793997c53785cc46d39e63549", "filename": "src/test/run-pass/spawn-fn.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Ftest%2Frun-pass%2Fspawn-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Ftest%2Frun-pass%2Fspawn-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fspawn-fn.rs?ref=16e1fcead14628701e1b10b9d00c898d748db2ed"}, {"sha": "1409caf9c702db352b046f27e46c8419571c9941", "filename": "src/test/run-pass/task-comm-0.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Ftest%2Frun-pass%2Ftask-comm-0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Ftest%2Frun-pass%2Ftask-comm-0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-0.rs?ref=16e1fcead14628701e1b10b9d00c898d748db2ed"}, {"sha": "b3327d82c3ebe8b05707b35cef118278f52479b4", "filename": "src/test/run-pass/task-comm-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Ftest%2Frun-pass%2Ftask-comm-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Ftest%2Frun-pass%2Ftask-comm-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-1.rs?ref=16e1fcead14628701e1b10b9d00c898d748db2ed"}, {"sha": "a796750ef88b7d999e4a289f893203ff6288930c", "filename": "src/test/run-pass/task-comm-10.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Ftest%2Frun-pass%2Ftask-comm-10.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Ftest%2Frun-pass%2Ftask-comm-10.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-10.rs?ref=16e1fcead14628701e1b10b9d00c898d748db2ed"}, {"sha": "7af8f5d3b35759b109760146dadec7000bf09828", "filename": "src/test/run-pass/task-comm-11.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Ftest%2Frun-pass%2Ftask-comm-11.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Ftest%2Frun-pass%2Ftask-comm-11.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-11.rs?ref=16e1fcead14628701e1b10b9d00c898d748db2ed"}, {"sha": "f8d608d31689c0536a09d8955e4022e218e1a3c1", "filename": "src/test/run-pass/task-comm-12.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Ftest%2Frun-pass%2Ftask-comm-12.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Ftest%2Frun-pass%2Ftask-comm-12.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-12.rs?ref=16e1fcead14628701e1b10b9d00c898d748db2ed"}, {"sha": "156ddd9c77fc339d817b749a9e13b5bef09d9c31", "filename": "src/test/run-pass/task-comm-13.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Ftest%2Frun-pass%2Ftask-comm-13.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Ftest%2Frun-pass%2Ftask-comm-13.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-13.rs?ref=16e1fcead14628701e1b10b9d00c898d748db2ed"}, {"sha": "0048d7d2d73217de7971695569e9c28df12f9473", "filename": "src/test/run-pass/task-comm-14.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Ftest%2Frun-pass%2Ftask-comm-14.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Ftest%2Frun-pass%2Ftask-comm-14.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-14.rs?ref=16e1fcead14628701e1b10b9d00c898d748db2ed"}, {"sha": "1d853b3e67ffc4c86c55b9c9de9d9ce22d796ad0", "filename": "src/test/run-pass/task-comm-15.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Ftest%2Frun-pass%2Ftask-comm-15.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Ftest%2Frun-pass%2Ftask-comm-15.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-15.rs?ref=16e1fcead14628701e1b10b9d00c898d748db2ed"}, {"sha": "8f6f971ce35c817dd4a06a2a3a2ca4a9592da68a", "filename": "src/test/run-pass/task-comm-17.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Ftest%2Frun-pass%2Ftask-comm-17.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Ftest%2Frun-pass%2Ftask-comm-17.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-17.rs?ref=16e1fcead14628701e1b10b9d00c898d748db2ed"}, {"sha": "25f40757b7b8ae652cdab0cd08a953bf3d49be09", "filename": "src/test/run-pass/task-comm-3.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Ftest%2Frun-pass%2Ftask-comm-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Ftest%2Frun-pass%2Ftask-comm-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-3.rs?ref=16e1fcead14628701e1b10b9d00c898d748db2ed"}, {"sha": "e37160f979c268849d3756587f6703012fd00c60", "filename": "src/test/run-pass/task-comm-7.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Ftest%2Frun-pass%2Ftask-comm-7.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Ftest%2Frun-pass%2Ftask-comm-7.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-7.rs?ref=16e1fcead14628701e1b10b9d00c898d748db2ed"}, {"sha": "d8eec4169e3531c0f749a827b39ffc64256ec97a", "filename": "src/test/run-pass/task-comm-9.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Ftest%2Frun-pass%2Ftask-comm-9.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Ftest%2Frun-pass%2Ftask-comm-9.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-9.rs?ref=16e1fcead14628701e1b10b9d00c898d748db2ed"}, {"sha": "ba8819fd0b0fee8e236977c8ac70b97672a3c15d", "filename": "src/test/run-pass/task-life-0.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Ftest%2Frun-pass%2Ftask-life-0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Ftest%2Frun-pass%2Ftask-life-0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-life-0.rs?ref=16e1fcead14628701e1b10b9d00c898d748db2ed"}, {"sha": "6a84ec47c93a1a0a22f0db4b299428c3d5a040e2", "filename": "src/test/run-pass/task-spawn-move-and-copy.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Ftest%2Frun-pass%2Ftask-spawn-move-and-copy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Ftest%2Frun-pass%2Ftask-spawn-move-and-copy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-spawn-move-and-copy.rs?ref=16e1fcead14628701e1b10b9d00c898d748db2ed"}, {"sha": "00467e563347a32174c7cb5a693448d75a7b68dc", "filename": "src/test/run-pass/tcp-accept-stress.rs", "status": "removed", "additions": 0, "deletions": 88, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/8415fa27877a4309a79b08c75a52eb4c3546b7a5/src%2Ftest%2Frun-pass%2Ftcp-accept-stress.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8415fa27877a4309a79b08c75a52eb4c3546b7a5/src%2Ftest%2Frun-pass%2Ftcp-accept-stress.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftcp-accept-stress.rs?ref=8415fa27877a4309a79b08c75a52eb4c3546b7a5"}, {"sha": "64f07a60b3503858390cadc58b92687422f0c8d9", "filename": "src/test/run-pass/tcp-connect-timeouts.rs", "status": "removed", "additions": 0, "deletions": 76, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/8415fa27877a4309a79b08c75a52eb4c3546b7a5/src%2Ftest%2Frun-pass%2Ftcp-connect-timeouts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8415fa27877a4309a79b08c75a52eb4c3546b7a5/src%2Ftest%2Frun-pass%2Ftcp-connect-timeouts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftcp-connect-timeouts.rs?ref=8415fa27877a4309a79b08c75a52eb4c3546b7a5"}, {"sha": "c47b95bec2b52daaad2ccb4ce63fd519f76f2302", "filename": "src/test/run-pass/tcp-stress.rs", "status": "modified", "additions": 15, "deletions": 34, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Ftest%2Frun-pass%2Ftcp-stress.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Ftest%2Frun-pass%2Ftcp-stress.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftcp-stress.rs?ref=16e1fcead14628701e1b10b9d00c898d748db2ed"}, {"sha": "49fac24d0b3a5b7e921233856ad3dff79776f99a", "filename": "src/test/run-pass/tempfile.rs", "status": "removed", "additions": 0, "deletions": 213, "changes": 213, "blob_url": "https://github.com/rust-lang/rust/blob/8415fa27877a4309a79b08c75a52eb4c3546b7a5/src%2Ftest%2Frun-pass%2Ftempfile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8415fa27877a4309a79b08c75a52eb4c3546b7a5/src%2Ftest%2Frun-pass%2Ftempfile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftempfile.rs?ref=8415fa27877a4309a79b08c75a52eb4c3546b7a5"}, {"sha": "184338c3294ff9290502609af17cd762263705d3", "filename": "src/test/run-pass/threads.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Ftest%2Frun-pass%2Fthreads.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Ftest%2Frun-pass%2Fthreads.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fthreads.rs?ref=16e1fcead14628701e1b10b9d00c898d748db2ed"}, {"sha": "21205a2d7fa590427a4ee581e2f74d6535430610", "filename": "src/test/run-pass/trait-bounds-in-arc.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Ftest%2Frun-pass%2Ftrait-bounds-in-arc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Ftest%2Frun-pass%2Ftrait-bounds-in-arc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-bounds-in-arc.rs?ref=16e1fcead14628701e1b10b9d00c898d748db2ed"}, {"sha": "eec852ae181c4623daece1c63fd81e21ad0dead4", "filename": "src/test/run-pass/ufcs-polymorphic-paths.rs", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Ftest%2Frun-pass%2Fufcs-polymorphic-paths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Ftest%2Frun-pass%2Fufcs-polymorphic-paths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fufcs-polymorphic-paths.rs?ref=16e1fcead14628701e1b10b9d00c898d748db2ed"}, {"sha": "c32483f629e03dd4d6130e8602a38834a550ad99", "filename": "src/test/run-pass/unique-send-2.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Ftest%2Frun-pass%2Funique-send-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Ftest%2Frun-pass%2Funique-send-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funique-send-2.rs?ref=16e1fcead14628701e1b10b9d00c898d748db2ed"}, {"sha": "a51274199b6200069ff6816e81f2de39f8eea81a", "filename": "src/test/run-pass/vector-sort-panic-safe.rs", "status": "modified", "additions": 9, "deletions": 16, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Ftest%2Frun-pass%2Fvector-sort-panic-safe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Ftest%2Frun-pass%2Fvector-sort-panic-safe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fvector-sort-panic-safe.rs?ref=16e1fcead14628701e1b10b9d00c898d748db2ed"}, {"sha": "1d0004bafa3560a340eb77a9be518014c77978b3", "filename": "src/test/run-pass/wait-forked-but-failed-child.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Ftest%2Frun-pass%2Fwait-forked-but-failed-child.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e1fcead14628701e1b10b9d00c898d748db2ed/src%2Ftest%2Frun-pass%2Fwait-forked-but-failed-child.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fwait-forked-but-failed-child.rs?ref=16e1fcead14628701e1b10b9d00c898d748db2ed"}]}