{"sha": "a32249d4477f449646162bbad607c39d0ad7f3ca", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEzMjI0OWQ0NDc3ZjQ0OTY0NjE2MmJiYWQ2MDdjMzlkMGFkN2YzY2E=", "commit": {"author": {"name": "Paul Collier", "email": "paul@paulcollier.ca", "date": "2015-01-17T23:33:05Z"}, "committer": {"name": "Paul Collier", "email": "paul@paulcollier.ca", "date": "2015-01-17T23:45:29Z"}, "message": "libsyntax: uint types to usize", "tree": {"sha": "fd561fde4f3f7bc60796ecd3683c1ad1c173f403", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fd561fde4f3f7bc60796ecd3683c1ad1c173f403"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a32249d4477f449646162bbad607c39d0ad7f3ca", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a32249d4477f449646162bbad607c39d0ad7f3ca", "html_url": "https://github.com/rust-lang/rust/commit/a32249d4477f449646162bbad607c39d0ad7f3ca", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a32249d4477f449646162bbad607c39d0ad7f3ca/comments", "author": {"login": "pshc", "id": 6398, "node_id": "MDQ6VXNlcjYzOTg=", "avatar_url": "https://avatars.githubusercontent.com/u/6398?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pshc", "html_url": "https://github.com/pshc", "followers_url": "https://api.github.com/users/pshc/followers", "following_url": "https://api.github.com/users/pshc/following{/other_user}", "gists_url": "https://api.github.com/users/pshc/gists{/gist_id}", "starred_url": "https://api.github.com/users/pshc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pshc/subscriptions", "organizations_url": "https://api.github.com/users/pshc/orgs", "repos_url": "https://api.github.com/users/pshc/repos", "events_url": "https://api.github.com/users/pshc/events{/privacy}", "received_events_url": "https://api.github.com/users/pshc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pshc", "id": 6398, "node_id": "MDQ6VXNlcjYzOTg=", "avatar_url": "https://avatars.githubusercontent.com/u/6398?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pshc", "html_url": "https://github.com/pshc", "followers_url": "https://api.github.com/users/pshc/followers", "following_url": "https://api.github.com/users/pshc/following{/other_user}", "gists_url": "https://api.github.com/users/pshc/gists{/gist_id}", "starred_url": "https://api.github.com/users/pshc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pshc/subscriptions", "organizations_url": "https://api.github.com/users/pshc/orgs", "repos_url": "https://api.github.com/users/pshc/repos", "events_url": "https://api.github.com/users/pshc/events{/privacy}", "received_events_url": "https://api.github.com/users/pshc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "89c4e3792ddc5b45706ea0e919806a248f7a87c3", "url": "https://api.github.com/repos/rust-lang/rust/commits/89c4e3792ddc5b45706ea0e919806a248f7a87c3", "html_url": "https://github.com/rust-lang/rust/commit/89c4e3792ddc5b45706ea0e919806a248f7a87c3"}], "stats": {"total": 330, "additions": 165, "deletions": 165}, "files": [{"sha": "72b9d4d1e63f2ee777d4cabdb5f0d63cfa55a1ec", "filename": "src/libsyntax/abi.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a32249d4477f449646162bbad607c39d0ad7f3ca/src%2Flibsyntax%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a32249d4477f449646162bbad607c39d0ad7f3ca/src%2Flibsyntax%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fabi.rs?ref=a32249d4477f449646162bbad607c39d0ad7f3ca", "patch": "@@ -105,8 +105,8 @@ pub fn all_names() -> Vec<&'static str> {\n \n impl Abi {\n     #[inline]\n-    pub fn index(&self) -> uint {\n-        *self as uint\n+    pub fn index(&self) -> usize {\n+        *self as usize\n     }\n \n     #[inline]"}, {"sha": "81ce521f68c8f877c93a59ac9ae3ae9ac0c18478", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/a32249d4477f449646162bbad607c39d0ad7f3ca/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a32249d4477f449646162bbad607c39d0ad7f3ca/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=a32249d4477f449646162bbad607c39d0ad7f3ca", "patch": "@@ -152,7 +152,7 @@ impl PartialEq for Ident {\n \n /// A SyntaxContext represents a chain of macro-expandings\n /// and renamings. Each macro expansion corresponds to\n-/// a fresh uint\n+/// a fresh usize\n \n // I'm representing this syntax context as an index into\n // a table, in order to work around a compiler bug\n@@ -181,9 +181,9 @@ impl Name {\n         }\n     }\n \n-    pub fn uint(&self) -> uint {\n+    pub fn uint(&self) -> usize {\n         let Name(nm) = *self;\n-        nm as uint\n+        nm as usize\n     }\n \n     pub fn ident(&self) -> Ident {\n@@ -740,7 +740,7 @@ pub enum Expr_ {\n     ExprAssign(P<Expr>, P<Expr>),\n     ExprAssignOp(BinOp, P<Expr>, P<Expr>),\n     ExprField(P<Expr>, SpannedIdent),\n-    ExprTupField(P<Expr>, Spanned<uint>),\n+    ExprTupField(P<Expr>, Spanned<usize>),\n     ExprIndex(P<Expr>, P<Expr>),\n     ExprRange(Option<P<Expr>>, Option<P<Expr>>),\n \n@@ -839,7 +839,7 @@ pub struct SequenceRepetition {\n     /// Whether the sequence can be repeated zero (*), or one or more times (+)\n     pub op: KleeneOp,\n     /// The number of `MatchNt`s that appear in the sequence (and subsequences)\n-    pub num_captures: uint,\n+    pub num_captures: usize,\n }\n \n /// A Kleene-style [repetition operator](http://en.wikipedia.org/wiki/Kleene_star)\n@@ -878,7 +878,7 @@ pub enum TokenTree {\n }\n \n impl TokenTree {\n-    pub fn len(&self) -> uint {\n+    pub fn len(&self) -> usize {\n         match *self {\n             TtToken(_, token::DocComment(_)) => 2,\n             TtToken(_, token::SpecialVarNt(..)) => 2,\n@@ -893,7 +893,7 @@ impl TokenTree {\n         }\n     }\n \n-    pub fn get_tt(&self, index: uint) -> TokenTree {\n+    pub fn get_tt(&self, index: usize) -> TokenTree {\n         match (self, index) {\n             (&TtToken(sp, token::DocComment(_)), 0) => {\n                 TtToken(sp, token::Pound)\n@@ -963,7 +963,7 @@ pub enum Mac_ {\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Show, Copy)]\n pub enum StrStyle {\n     CookedStr,\n-    RawStr(uint)\n+    RawStr(usize)\n }\n \n pub type Lit = Spanned<Lit_>;\n@@ -992,7 +992,7 @@ pub enum LitIntType {\n }\n \n impl LitIntType {\n-    pub fn suffix_len(&self) -> uint {\n+    pub fn suffix_len(&self) -> usize {\n         match *self {\n             UnsuffixedIntLit(_) => 0,\n             SignedIntLit(s, _) => s.suffix_len(),\n@@ -1113,7 +1113,7 @@ impl fmt::String for IntTy {\n }\n \n impl IntTy {\n-    pub fn suffix_len(&self) -> uint {\n+    pub fn suffix_len(&self) -> usize {\n         match *self {\n             TyIs(true) /* i */ => 1,\n             TyIs(false) /* is */ | TyI8 => 2,\n@@ -1146,7 +1146,7 @@ impl PartialEq for UintTy {\n }\n \n impl UintTy {\n-    pub fn suffix_len(&self) -> uint {\n+    pub fn suffix_len(&self) -> usize {\n         match *self {\n             TyUs(true) /* u */ => 1,\n             TyUs(false) /* us */ | TyU8 => 2,\n@@ -1186,7 +1186,7 @@ impl fmt::String for FloatTy {\n }\n \n impl FloatTy {\n-    pub fn suffix_len(&self) -> uint {\n+    pub fn suffix_len(&self) -> usize {\n         match *self {\n             TyF32 | TyF64 => 3, // add F128 handling here\n         }\n@@ -1274,7 +1274,7 @@ pub enum Ty_ {\n     TyPtr(MutTy),\n     /// A reference (`&'a T` or `&'a mut T`)\n     TyRptr(Option<Lifetime>, MutTy),\n-    /// A bare function (e.g. `fn(uint) -> bool`)\n+    /// A bare function (e.g. `fn(usize) -> bool`)\n     TyBareFn(P<BareFnTy>),\n     /// A tuple (`(A, B, C, D,...)`)\n     TyTup(Vec<P<Ty>> ),\n@@ -1566,7 +1566,7 @@ pub enum AttrStyle {\n }\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Show, Copy)]\n-pub struct AttrId(pub uint);\n+pub struct AttrId(pub usize);\n \n /// Doc-comments are promoted to attributes that have is_sugared_doc = true\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Show)]"}, {"sha": "d57a1356def0ec53c8e4564853284c112d4d94e6", "filename": "src/libsyntax/ast_map/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a32249d4477f449646162bbad607c39d0ad7f3ca/src%2Flibsyntax%2Fast_map%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a32249d4477f449646162bbad607c39d0ad7f3ca/src%2Flibsyntax%2Fast_map%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map%2Fmod.rs?ref=a32249d4477f449646162bbad607c39d0ad7f3ca", "patch": "@@ -264,12 +264,12 @@ pub struct Map<'ast> {\n }\n \n impl<'ast> Map<'ast> {\n-    fn entry_count(&self) -> uint {\n+    fn entry_count(&self) -> usize {\n         self.map.borrow().len()\n     }\n \n     fn find_entry(&self, id: NodeId) -> Option<MapEntry<'ast>> {\n-        self.map.borrow().get(id as uint).map(|e| *e)\n+        self.map.borrow().get(id as usize).map(|e| *e)\n     }\n \n     pub fn krate(&self) -> &'ast Crate {\n@@ -652,7 +652,7 @@ impl<'a, 'ast> Iterator for NodesMatchingSuffix<'a, 'ast> {\n     fn next(&mut self) -> Option<NodeId> {\n         loop {\n             let idx = self.idx;\n-            if idx as uint >= self.map.entry_count() {\n+            if idx as usize >= self.map.entry_count() {\n                 return None;\n             }\n             self.idx += 1;\n@@ -744,10 +744,10 @@ impl<'ast> NodeCollector<'ast> {\n     fn insert_entry(&mut self, id: NodeId, entry: MapEntry<'ast>) {\n         debug!(\"ast_map: {:?} => {:?}\", id, entry);\n         let len = self.map.len();\n-        if id as uint >= len {\n-            self.map.extend(repeat(NotPresent).take(id as uint - len + 1));\n+        if id as usize >= len {\n+            self.map.extend(repeat(NotPresent).take(id as usize - len + 1));\n         }\n-        self.map[id as uint] = entry;\n+        self.map[id as usize] = entry;\n     }\n \n     fn insert(&mut self, id: NodeId, node: Node<'ast>) {"}, {"sha": "73f84f4fbe7f097e4ff48fd257f61683fbec2a1b", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a32249d4477f449646162bbad607c39d0ad7f3ca/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a32249d4477f449646162bbad607c39d0ad7f3ca/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=a32249d4477f449646162bbad607c39d0ad7f3ca", "patch": "@@ -156,7 +156,7 @@ pub fn int_ty_max(t: IntTy) -> u64 {\n }\n \n /// Get a string representation of an unsigned int type, with its value.\n-/// We want to avoid \"42uint\" in favor of \"42u\"\n+/// We want to avoid \"42u\" in favor of \"42us\". \"42uint\" is right out.\n pub fn uint_ty_to_string(t: UintTy, val: Option<u64>) -> String {\n     let s = match t {\n         TyUs(true) if val.is_some() => \"u\",\n@@ -319,7 +319,7 @@ pub fn struct_field_visibility(field: ast::StructField) -> Visibility {\n }\n \n /// Maps a binary operator to its precedence\n-pub fn operator_prec(op: ast::BinOp) -> uint {\n+pub fn operator_prec(op: ast::BinOp) -> usize {\n   match op {\n       // 'as' sits here with 12\n       BiMul | BiDiv | BiRem     => 11u,\n@@ -337,7 +337,7 @@ pub fn operator_prec(op: ast::BinOp) -> uint {\n /// Precedence of the `as` operator, which is a binary operator\n /// not appearing in the prior table.\n #[allow(non_upper_case_globals)]\n-pub static as_prec: uint = 12u;\n+pub static as_prec: usize = 12us;\n \n pub fn empty_generics() -> Generics {\n     Generics {"}, {"sha": "8f58b7694b6fb3763a7318517ede958544052433", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a32249d4477f449646162bbad607c39d0ad7f3ca/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a32249d4477f449646162bbad607c39d0ad7f3ca/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=a32249d4477f449646162bbad607c39d0ad7f3ca", "patch": "@@ -170,7 +170,7 @@ pub fn mk_word_item(name: InternedString) -> P<MetaItem> {\n     P(dummy_spanned(MetaWord(name)))\n }\n \n-thread_local! { static NEXT_ATTR_ID: Cell<uint> = Cell::new(0) }\n+thread_local! { static NEXT_ATTR_ID: Cell<usize> = Cell::new(0) }\n \n pub fn mk_attr_id() -> AttrId {\n     let id = NEXT_ATTR_ID.with(|slot| {"}, {"sha": "6b9dda88a3697641a437374fe0181c06a18cd580", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/a32249d4477f449646162bbad607c39d0ad7f3ca/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a32249d4477f449646162bbad607c39d0ad7f3ca/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=a32249d4477f449646162bbad607c39d0ad7f3ca", "patch": "@@ -30,8 +30,8 @@ use libc::c_uint;\n use serialize::{Encodable, Decodable, Encoder, Decoder};\n \n pub trait Pos {\n-    fn from_uint(n: uint) -> Self;\n-    fn to_uint(&self) -> uint;\n+    fn from_uint(n: usize) -> Self;\n+    fn to_uint(&self) -> usize;\n }\n \n /// A byte offset. Keep this small (currently 32-bits), as AST contains\n@@ -43,14 +43,14 @@ pub struct BytePos(pub u32);\n /// is not equivalent to a character offset. The CodeMap will convert BytePos\n /// values to CharPos values as necessary.\n #[derive(Copy, PartialEq, Hash, PartialOrd, Show)]\n-pub struct CharPos(pub uint);\n+pub struct CharPos(pub usize);\n \n // FIXME: Lots of boilerplate in these impls, but so far my attempts to fix\n // have been unsuccessful\n \n impl Pos for BytePos {\n-    fn from_uint(n: uint) -> BytePos { BytePos(n as u32) }\n-    fn to_uint(&self) -> uint { let BytePos(n) = *self; n as uint }\n+    fn from_uint(n: usize) -> BytePos { BytePos(n as u32) }\n+    fn to_uint(&self) -> usize { let BytePos(n) = *self; n as usize }\n }\n \n impl Add for BytePos {\n@@ -70,8 +70,8 @@ impl Sub for BytePos {\n }\n \n impl Pos for CharPos {\n-    fn from_uint(n: uint) -> CharPos { CharPos(n) }\n-    fn to_uint(&self) -> uint { let CharPos(n) = *self; n }\n+    fn from_uint(n: usize) -> CharPos { CharPos(n) }\n+    fn to_uint(&self) -> usize { let CharPos(n) = *self; n }\n }\n \n impl Add for CharPos {\n@@ -173,7 +173,7 @@ pub struct Loc {\n     /// Information about the original source\n     pub file: Rc<FileMap>,\n     /// The (1-based) line number\n-    pub line: uint,\n+    pub line: usize,\n     /// The (0-based) column offset\n     pub col: CharPos\n }\n@@ -183,13 +183,13 @@ pub struct Loc {\n // perhaps they should just be removed.\n pub struct LocWithOpt {\n     pub filename: FileName,\n-    pub line: uint,\n+    pub line: usize,\n     pub col: CharPos,\n     pub file: Option<Rc<FileMap>>,\n }\n \n // used to be structural records. Better names, anyone?\n-pub struct FileMapAndLine { pub fm: Rc<FileMap>, pub line: uint }\n+pub struct FileMapAndLine { pub fm: Rc<FileMap>, pub line: usize }\n pub struct FileMapAndBytePos { pub fm: Rc<FileMap>, pub pos: BytePos }\n \n /// The syntax with which a macro was invoked.\n@@ -258,7 +258,7 @@ pub type FileName = String;\n \n pub struct FileLines {\n     pub file: Rc<FileMap>,\n-    pub lines: Vec<uint>\n+    pub lines: Vec<usize>\n }\n \n /// Identifies an offset of a multi-byte character in a FileMap\n@@ -267,7 +267,7 @@ pub struct MultiByteChar {\n     /// The absolute offset of the character in the CodeMap\n     pub pos: BytePos,\n     /// The number of bytes, >=2\n-    pub bytes: uint,\n+    pub bytes: usize,\n }\n \n /// A single source in the CodeMap\n@@ -306,7 +306,7 @@ impl FileMap {\n \n     /// get a line from the list of pre-computed line-beginnings\n     ///\n-    pub fn get_line(&self, line_number: uint) -> Option<String> {\n+    pub fn get_line(&self, line_number: usize) -> Option<String> {\n         let lines = self.lines.borrow();\n         lines.get(line_number).map(|&line| {\n             let begin: BytePos = line - self.start_pos;\n@@ -319,7 +319,7 @@ impl FileMap {\n         })\n     }\n \n-    pub fn record_multibyte_char(&self, pos: BytePos, bytes: uint) {\n+    pub fn record_multibyte_char(&self, pos: BytePos, bytes: usize) {\n         assert!(bytes >=2 && bytes <= 4);\n         let mbc = MultiByteChar {\n             pos: pos,\n@@ -430,7 +430,7 @@ impl CodeMap {\n         let lo = self.lookup_char_pos(sp.lo);\n         let hi = self.lookup_char_pos(sp.hi);\n         let mut lines = Vec::new();\n-        for i in range(lo.line - 1u, hi.line as uint) {\n+        for i in range(lo.line - 1u, hi.line as usize) {\n             lines.push(i);\n         };\n         FileLines {file: lo.file, lines: lines}\n@@ -494,7 +494,7 @@ impl CodeMap {\n         CharPos(bpos.to_uint() - map.start_pos.to_uint() - total_extra_bytes)\n     }\n \n-    fn lookup_filemap_idx(&self, pos: BytePos) -> uint {\n+    fn lookup_filemap_idx(&self, pos: BytePos) -> usize {\n         let files = self.files.borrow();\n         let files = &*files;\n         let len = files.len();\n@@ -579,7 +579,7 @@ impl CodeMap {\n     {\n         match id {\n             NO_EXPANSION => f(None),\n-            ExpnId(i) => f(Some(&(*self.expansions.borrow())[i as uint]))\n+            ExpnId(i) => f(Some(&(*self.expansions.borrow())[i as usize]))\n         }\n     }\n "}, {"sha": "9c8ea7d9d684376ea8bb4cc3789b6aa3ea5225a7", "filename": "src/libsyntax/diagnostic.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a32249d4477f449646162bbad607c39d0ad7f3ca/src%2Flibsyntax%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a32249d4477f449646162bbad607c39d0ad7f3ca/src%2Flibsyntax%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic.rs?ref=a32249d4477f449646162bbad607c39d0ad7f3ca", "patch": "@@ -26,7 +26,7 @@ use term::WriterWrapper;\n use term;\n \n /// maximum number of lines we will print for each error; arbitrary.\n-static MAX_LINES: uint = 6u;\n+static MAX_LINES: usize = 6u;\n \n #[derive(Clone, Copy)]\n pub enum RenderSpan {\n@@ -137,7 +137,7 @@ impl SpanHandler {\n /// (fatal, bug, unimpl) may cause immediate exit,\n /// others log errors for later reporting.\n pub struct Handler {\n-    err_count: Cell<uint>,\n+    err_count: Cell<usize>,\n     emit: RefCell<Box<Emitter + Send>>,\n }\n \n@@ -153,7 +153,7 @@ impl Handler {\n     pub fn bump_err_count(&self) {\n         self.err_count.set(self.err_count.get() + 1u);\n     }\n-    pub fn err_count(&self) -> uint {\n+    pub fn err_count(&self) -> usize {\n         self.err_count.get()\n     }\n     pub fn has_errors(&self) -> bool {"}, {"sha": "9128bc05f6f3d48f038d3de752499281cfa77511", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a32249d4477f449646162bbad607c39d0ad7f3ca/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a32249d4477f449646162bbad607c39d0ad7f3ca/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=a32249d4477f449646162bbad607c39d0ad7f3ca", "patch": "@@ -548,7 +548,7 @@ pub struct ExtCtxt<'a> {\n     pub exported_macros: Vec<ast::MacroDef>,\n \n     pub syntax_env: SyntaxEnv,\n-    pub recursion_count: uint,\n+    pub recursion_count: usize,\n }\n \n impl<'a> ExtCtxt<'a> {"}, {"sha": "d960186cdd88053789504050cddfd5d9693b0418", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a32249d4477f449646162bbad607c39d0ad7f3ca/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a32249d4477f449646162bbad607c39d0ad7f3ca/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=a32249d4477f449646162bbad607c39d0ad7f3ca", "patch": "@@ -116,7 +116,7 @@ pub trait AstBuilder {\n     fn expr_mut_addr_of(&self, sp: Span, e: P<ast::Expr>) -> P<ast::Expr>;\n     fn expr_field_access(&self, span: Span, expr: P<ast::Expr>, ident: ast::Ident) -> P<ast::Expr>;\n     fn expr_tup_field_access(&self, sp: Span, expr: P<ast::Expr>,\n-                             idx: uint) -> P<ast::Expr>;\n+                             idx: usize) -> P<ast::Expr>;\n     fn expr_call(&self, span: Span, expr: P<ast::Expr>, args: Vec<P<ast::Expr>>) -> P<ast::Expr>;\n     fn expr_call_ident(&self, span: Span, id: ast::Ident, args: Vec<P<ast::Expr>>) -> P<ast::Expr>;\n     fn expr_call_global(&self, sp: Span, fn_path: Vec<ast::Ident>,\n@@ -134,7 +134,7 @@ pub trait AstBuilder {\n \n     fn expr_lit(&self, sp: Span, lit: ast::Lit_) -> P<ast::Expr>;\n \n-    fn expr_uint(&self, span: Span, i: uint) -> P<ast::Expr>;\n+    fn expr_uint(&self, span: Span, i: usize) -> P<ast::Expr>;\n     fn expr_int(&self, sp: Span, i: int) -> P<ast::Expr>;\n     fn expr_u8(&self, sp: Span, u: u8) -> P<ast::Expr>;\n     fn expr_bool(&self, sp: Span, value: bool) -> P<ast::Expr>;\n@@ -587,7 +587,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n         let id = Spanned { node: ident, span: field_span };\n         self.expr(sp, ast::ExprField(expr, id))\n     }\n-    fn expr_tup_field_access(&self, sp: Span, expr: P<ast::Expr>, idx: uint) -> P<ast::Expr> {\n+    fn expr_tup_field_access(&self, sp: Span, expr: P<ast::Expr>, idx: usize) -> P<ast::Expr> {\n         let field_span = Span {\n             lo: sp.lo - Pos::from_uint(idx.to_string().len()),\n             hi: sp.hi,\n@@ -641,7 +641,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n     fn expr_lit(&self, sp: Span, lit: ast::Lit_) -> P<ast::Expr> {\n         self.expr(sp, ast::ExprLit(P(respan(sp, lit))))\n     }\n-    fn expr_uint(&self, span: Span, i: uint) -> P<ast::Expr> {\n+    fn expr_uint(&self, span: Span, i: usize) -> P<ast::Expr> {\n         self.expr_lit(span, ast::LitInt(i as u64, ast::UnsignedIntLit(ast::TyUs(false))))\n     }\n     fn expr_int(&self, sp: Span, i: int) -> P<ast::Expr> {"}, {"sha": "6a41874b9350d65459d5636f4691b79f08906b63", "filename": "src/libsyntax/ext/deriving/decodable.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a32249d4477f449646162bbad607c39d0ad7f3ca/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a32249d4477f449646162bbad607c39d0ad7f3ca/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs?ref=a32249d4477f449646162bbad607c39d0ad7f3ca", "patch": "@@ -179,14 +179,14 @@ fn decodable_substructure(cx: &mut ExtCtxt, trait_span: Span,\n \n /// Create a decoder for a single enum variant/struct:\n /// - `outer_pat_path` is the path to this enum variant/struct\n-/// - `getarg` should retrieve the `uint`-th field with name `@str`.\n+/// - `getarg` should retrieve the `usize`-th field with name `@str`.\n fn decode_static_fields<F>(cx: &mut ExtCtxt,\n                            trait_span: Span,\n                            outer_pat_path: ast::Path,\n                            fields: &StaticFields,\n                            mut getarg: F)\n                            -> P<Expr> where\n-    F: FnMut(&mut ExtCtxt, Span, InternedString, uint) -> P<Expr>,\n+    F: FnMut(&mut ExtCtxt, Span, InternedString, usize) -> P<Expr>,\n {\n     match *fields {\n         Unnamed(ref fields) => {"}, {"sha": "496aec556f1fd8b6f421238e7bfcb022d491347e", "filename": "src/libsyntax/ext/deriving/encodable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a32249d4477f449646162bbad607c39d0ad7f3ca/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a32249d4477f449646162bbad607c39d0ad7f3ca/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs?ref=a32249d4477f449646162bbad607c39d0ad7f3ca", "patch": "@@ -16,7 +16,7 @@\n //!\n //! ```ignore\n //! #[derive(Encodable, Decodable)]\n-//! struct Node { id: uint }\n+//! struct Node { id: usize }\n //! ```\n //!\n //! would generate two implementations like:"}, {"sha": "27199de0ea867eb382b227fe25137e07393e83ed", "filename": "src/libsyntax/ext/deriving/generic/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a32249d4477f449646162bbad607c39d0ad7f3ca/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a32249d4477f449646162bbad607c39d0ad7f3ca/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs?ref=a32249d4477f449646162bbad607c39d0ad7f3ca", "patch": "@@ -294,7 +294,7 @@ pub enum SubstructureFields<'a> {\n     /// Matching variants of the enum: variant index, ast::Variant,\n     /// fields: the field name is only non-`None` in the case of a struct\n     /// variant.\n-    EnumMatching(uint, &'a ast::Variant, Vec<FieldInfo>),\n+    EnumMatching(usize, &'a ast::Variant, Vec<FieldInfo>),\n \n     /// Non-matching variants of the enum, but with all state hidden from\n     /// the consequent code.  The first component holds `Ident`s for all of\n@@ -915,7 +915,7 @@ impl<'a> MethodDef<'a> {\n             .collect::<Vec<ast::Ident>>();\n \n         // The `vi_idents` will be bound, solely in the catch-all, to\n-        // a series of let statements mapping each self_arg to a uint\n+        // a series of let statements mapping each self_arg to a usize\n         // corresponding to its variant index.\n         let vi_idents: Vec<ast::Ident> = self_arg_names.iter()\n             .map(|name| { let vi_suffix = format!(\"{}_vi\", &name[]);\n@@ -1039,7 +1039,7 @@ impl<'a> MethodDef<'a> {\n                 }).collect();\n \n             // Build a series of let statements mapping each self_arg\n-            // to a uint corresponding to its variant index.\n+            // to a usize corresponding to its variant index.\n             // i.e. for `enum E<T> { A, B(1), C(T, T) }`, and a deriving\n             // with three Self args, builds three statements:\n             //"}, {"sha": "1fd0334c016f6a3b0064c61ae08e2f5af6e78b1a", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a32249d4477f449646162bbad607c39d0ad7f3ca/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a32249d4477f449646162bbad607c39d0ad7f3ca/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=a32249d4477f449646162bbad607c39d0ad7f3ca", "patch": "@@ -1311,7 +1311,7 @@ fn new_span(cx: &ExtCtxt, sp: Span) -> Span {\n pub struct ExpansionConfig {\n     pub crate_name: String,\n     pub enable_quotes: bool,\n-    pub recursion_limit: uint,\n+    pub recursion_limit: usize,\n }\n \n impl ExpansionConfig {\n@@ -1595,7 +1595,7 @@ mod test {\n     // in principle, you might want to control this boolean on a per-varref basis,\n     // but that would make things even harder to understand, and might not be\n     // necessary for thorough testing.\n-    type RenamingTest = (&'static str, Vec<Vec<uint>>, bool);\n+    type RenamingTest = (&'static str, Vec<Vec<usize>>, bool);\n \n     #[test]\n     fn automatic_renaming () {\n@@ -1749,7 +1749,7 @@ mod test {\n     }\n \n     // run one of the renaming tests\n-    fn run_renaming_test(t: &RenamingTest, test_idx: uint) {\n+    fn run_renaming_test(t: &RenamingTest, test_idx: usize) {\n         let invalid_name = token::special_idents::invalid.name;\n         let (teststr, bound_connections, bound_ident_check) = match *t {\n             (ref str,ref conns, bic) => (str.to_string(), conns.clone(), bic)"}, {"sha": "684ae84872be1d29f3ea8ea19d0dc5ae2cf46ab5", "filename": "src/libsyntax/ext/format.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a32249d4477f449646162bbad607c39d0ad7f3ca/src%2Flibsyntax%2Fext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a32249d4477f449646162bbad607c39d0ad7f3ca/src%2Flibsyntax%2Fext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fformat.rs?ref=a32249d4477f449646162bbad607c39d0ad7f3ca", "patch": "@@ -31,7 +31,7 @@ enum ArgumentType {\n }\n \n enum Position {\n-    Exact(uint),\n+    Exact(usize),\n     Named(String),\n }\n \n@@ -61,11 +61,11 @@ struct Context<'a, 'b:'a> {\n     /// Stays `true` if all formatting parameters are default (as in \"{}{}\").\n     all_pieces_simple: bool,\n \n-    name_positions: HashMap<String, uint>,\n+    name_positions: HashMap<String, usize>,\n \n     /// Updated as arguments are consumed or methods are entered\n-    nest_level: uint,\n-    next_arg: uint,\n+    nest_level: usize,\n+    next_arg: usize,\n }\n \n /// Parses the arguments from the given list of tokens, returning None"}, {"sha": "9bcb026a550fa228c8a961fde8b9ff7c3357af7d", "filename": "src/libsyntax/ext/mtwt.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a32249d4477f449646162bbad607c39d0ad7f3ca/src%2Flibsyntax%2Fext%2Fmtwt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a32249d4477f449646162bbad607c39d0ad7f3ca/src%2Flibsyntax%2Fext%2Fmtwt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fmtwt.rs?ref=a32249d4477f449646162bbad607c39d0ad7f3ca", "patch": "@@ -187,7 +187,7 @@ fn resolve_internal(id: Ident,\n     }\n \n     let resolved = {\n-        let result = (*table.table.borrow())[id.ctxt as uint];\n+        let result = (*table.table.borrow())[id.ctxt as usize];\n         match result {\n             EmptyCtxt => id.name,\n             // ignore marks here:\n@@ -231,7 +231,7 @@ fn marksof_internal(ctxt: SyntaxContext,\n     let mut result = Vec::new();\n     let mut loopvar = ctxt;\n     loop {\n-        let table_entry = (*table.table.borrow())[loopvar as uint];\n+        let table_entry = (*table.table.borrow())[loopvar as usize];\n         match table_entry {\n             EmptyCtxt => {\n                 return result;\n@@ -258,7 +258,7 @@ fn marksof_internal(ctxt: SyntaxContext,\n /// FAILS when outside is not a mark.\n pub fn outer_mark(ctxt: SyntaxContext) -> Mrk {\n     with_sctable(|sctable| {\n-        match (*sctable.table.borrow())[ctxt as uint] {\n+        match (*sctable.table.borrow())[ctxt as usize] {\n             Mark(mrk, _) => mrk,\n             _ => panic!(\"can't retrieve outer mark when outside is not a mark\")\n         }\n@@ -330,7 +330,7 @@ mod tests {\n         let mut result = Vec::new();\n         loop {\n             let table = table.table.borrow();\n-            match (*table)[sc as uint] {\n+            match (*table)[sc as usize] {\n                 EmptyCtxt => {return result;},\n                 Mark(mrk,tail) => {\n                     result.push(M(mrk));"}, {"sha": "75d904a4632db79e33bf59ddf901cbbd957ca771", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a32249d4477f449646162bbad607c39d0ad7f3ca/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a32249d4477f449646162bbad607c39d0ad7f3ca/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=a32249d4477f449646162bbad607c39d0ad7f3ca", "patch": "@@ -110,14 +110,14 @@ enum TokenTreeOrTokenTreeVec {\n }\n \n impl TokenTreeOrTokenTreeVec {\n-    fn len(&self) -> uint {\n+    fn len(&self) -> usize {\n         match self {\n             &TtSeq(ref v) => v.len(),\n             &Tt(ref tt) => tt.len(),\n         }\n     }\n \n-    fn get_tt(&self, index: uint) -> TokenTree {\n+    fn get_tt(&self, index: usize) -> TokenTree {\n         match self {\n             &TtSeq(ref v) => v[index].clone(),\n             &Tt(ref tt) => tt.get_tt(index),\n@@ -129,24 +129,24 @@ impl TokenTreeOrTokenTreeVec {\n #[derive(Clone)]\n struct MatcherTtFrame {\n     elts: TokenTreeOrTokenTreeVec,\n-    idx: uint,\n+    idx: usize,\n }\n \n #[derive(Clone)]\n pub struct MatcherPos {\n     stack: Vec<MatcherTtFrame>,\n     top_elts: TokenTreeOrTokenTreeVec,\n     sep: Option<Token>,\n-    idx: uint,\n+    idx: usize,\n     up: Option<Box<MatcherPos>>,\n     matches: Vec<Vec<Rc<NamedMatch>>>,\n-    match_lo: uint,\n-    match_cur: uint,\n-    match_hi: uint,\n+    match_lo: usize,\n+    match_cur: usize,\n+    match_hi: usize,\n     sp_lo: BytePos,\n }\n \n-pub fn count_names(ms: &[TokenTree]) -> uint {\n+pub fn count_names(ms: &[TokenTree]) -> usize {\n     ms.iter().fold(0, |count, elt| {\n         count + match elt {\n             &TtSequence(_, ref seq) => {\n@@ -206,7 +206,7 @@ pub enum NamedMatch {\n pub fn nameize(p_s: &ParseSess, ms: &[TokenTree], res: &[Rc<NamedMatch>])\n             -> HashMap<Ident, Rc<NamedMatch>> {\n     fn n_rec(p_s: &ParseSess, m: &TokenTree, res: &[Rc<NamedMatch>],\n-             ret_val: &mut HashMap<Ident, Rc<NamedMatch>>, idx: &mut uint) {\n+             ret_val: &mut HashMap<Ident, Rc<NamedMatch>>, idx: &mut usize) {\n         match m {\n             &TtSequence(_, ref seq) => {\n                 for next_m in seq.tts.iter() {"}, {"sha": "7936b9fcfc7385e5f83dacef32eac05298484e0d", "filename": "src/libsyntax/ext/tt/transcribe.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a32249d4477f449646162bbad607c39d0ad7f3ca/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a32249d4477f449646162bbad607c39d0ad7f3ca/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs?ref=a32249d4477f449646162bbad607c39d0ad7f3ca", "patch": "@@ -27,7 +27,7 @@ use std::collections::HashMap;\n #[derive(Clone)]\n struct TtFrame {\n     forest: TokenTree,\n-    idx: uint,\n+    idx: usize,\n     dotdotdoted: bool,\n     sep: Option<Token>,\n }\n@@ -43,8 +43,8 @@ pub struct TtReader<'a> {\n \n     // Some => return imported_from as the next token\n     crate_name_next: Option<Span>,\n-    repeat_idx: Vec<uint>,\n-    repeat_len: Vec<uint>,\n+    repeat_idx: Vec<usize>,\n+    repeat_len: Vec<usize>,\n     /* cached: */\n     pub cur_tok: Token,\n     pub cur_span: Span,\n@@ -124,7 +124,7 @@ fn lookup_cur_matched(r: &TtReader, name: Ident) -> Option<Rc<NamedMatch>> {\n #[derive(Clone)]\n enum LockstepIterSize {\n     LisUnconstrained,\n-    LisConstraint(uint, Ident),\n+    LisConstraint(usize, Ident),\n     LisContradiction(String),\n }\n "}, {"sha": "cae0cf904f6774b9b3b38c47b667fb97e7b6c200", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a32249d4477f449646162bbad607c39d0ad7f3ca/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a32249d4477f449646162bbad607c39d0ad7f3ca/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=a32249d4477f449646162bbad607c39d0ad7f3ca", "patch": "@@ -174,7 +174,7 @@ pub trait Folder : Sized {\n         noop_fold_ident(i, self)\n     }\n \n-    fn fold_uint(&mut self, i: uint) -> uint {\n+    fn fold_uint(&mut self, i: usize) -> usize {\n         noop_fold_uint(i, self)\n     }\n \n@@ -505,7 +505,7 @@ pub fn noop_fold_ident<T: Folder>(i: Ident, _: &mut T) -> Ident {\n     i\n }\n \n-pub fn noop_fold_uint<T: Folder>(i: uint, _: &mut T) -> uint {\n+pub fn noop_fold_uint<T: Folder>(i: usize, _: &mut T) -> usize {\n     i\n }\n "}, {"sha": "59a3c3bcb3edc94d99b8bfc2dd130474d80cbaa4", "filename": "src/libsyntax/parse/lexer/comments.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a32249d4477f449646162bbad607c39d0ad7f3ca/src%2Flibsyntax%2Fparse%2Flexer%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a32249d4477f449646162bbad607c39d0ad7f3ca/src%2Flibsyntax%2Fparse%2Flexer%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fcomments.rs?ref=a32249d4477f449646162bbad607c39d0ad7f3ca", "patch": "@@ -22,7 +22,7 @@ use print::pprust;\n use std::io;\n use std::str;\n use std::string::String;\n-use std::uint;\n+use std::usize;\n \n #[derive(Clone, Copy, PartialEq)]\n pub enum CommentStyle {\n@@ -87,7 +87,7 @@ pub fn strip_doc_comment_decoration(comment: &str) -> String {\n \n     /// remove a \"[ \\t]*\\*\" block from each line, if possible\n     fn horizontal_trim(lines: Vec<String> ) -> Vec<String> {\n-        let mut i = uint::MAX;\n+        let mut i = usize::MAX;\n         let mut can_trim = true;\n         let mut first = true;\n         for line in lines.iter() {\n@@ -206,10 +206,10 @@ fn read_line_comments(rdr: &mut StringReader, code_to_the_left: bool,\n /// Returns None if the first col chars of s contain a non-whitespace char.\n /// Otherwise returns Some(k) where k is first char offset after that leading\n /// whitespace.  Note k may be outside bounds of s.\n-fn all_whitespace(s: &str, col: CharPos) -> Option<uint> {\n+fn all_whitespace(s: &str, col: CharPos) -> Option<usize> {\n     let len = s.len();\n     let mut col = col.to_uint();\n-    let mut cursor: uint = 0;\n+    let mut cursor: usize = 0;\n     while col > 0 && cursor < len {\n         let r: str::CharRange = s.char_range_at(cursor);\n         if !r.ch.is_whitespace() {"}, {"sha": "cd159f7c599bba64c654a0cf71a8fb6d8d388950", "filename": "src/libsyntax/parse/lexer/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a32249d4477f449646162bbad607c39d0ad7f3ca/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a32249d4477f449646162bbad607c39d0ad7f3ca/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=a32249d4477f449646162bbad607c39d0ad7f3ca", "patch": "@@ -295,7 +295,7 @@ impl<'a> StringReader<'a> {\n         return s.into_cow();\n \n         fn translate_crlf_(rdr: &StringReader, start: BytePos,\n-                        s: &str, errmsg: &str, mut i: uint) -> String {\n+                        s: &str, errmsg: &str, mut i: usize) -> String {\n             let mut buf = String::with_capacity(s.len());\n             let mut j = 0;\n             while i < s.len() {\n@@ -645,7 +645,7 @@ impl<'a> StringReader<'a> {\n \n     /// Scan through any digits (base `radix`) or underscores, and return how\n     /// many digits there were.\n-    fn scan_digits(&mut self, radix: uint) -> uint {\n+    fn scan_digits(&mut self, radix: usize) -> usize {\n         let mut len = 0u;\n         loop {\n             let c = self.curr;\n@@ -724,7 +724,7 @@ impl<'a> StringReader<'a> {\n     /// Scan over `n_digits` hex digits, stopping at `delim`, reporting an\n     /// error if too many or too few digits are encountered.\n     fn scan_hex_digits(&mut self,\n-                       n_digits: uint,\n+                       n_digits: usize,\n                        delim: char,\n                        below_0x7f_only: bool)\n                        -> bool {\n@@ -877,7 +877,7 @@ impl<'a> StringReader<'a> {\n     fn scan_unicode_escape(&mut self, delim: char) -> bool {\n         self.bump(); // past the {\n         let start_bpos = self.last_pos;\n-        let mut count: uint = 0;\n+        let mut count = 0us;\n         let mut accum_int = 0;\n \n         while !self.curr_is('}') && count <= 6 {\n@@ -935,7 +935,7 @@ impl<'a> StringReader<'a> {\n \n     /// Check that a base is valid for a floating literal, emitting a nice\n     /// error if it isn't.\n-    fn check_float_base(&mut self, start_bpos: BytePos, last_bpos: BytePos, base: uint) {\n+    fn check_float_base(&mut self, start_bpos: BytePos, last_bpos: BytePos, base: usize) {\n         match base {\n             16u => self.err_span_(start_bpos, last_bpos, \"hexadecimal float literal is not \\\n                                  supported\"),"}, {"sha": "7bde32326fa8e59cfbf86b1a6d24e39ce2e4a113", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/a32249d4477f449646162bbad607c39d0ad7f3ca/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a32249d4477f449646162bbad607c39d0ad7f3ca/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=a32249d4477f449646162bbad607c39d0ad7f3ca", "patch": "@@ -374,7 +374,7 @@ pub fn maybe_aborted<T>(result: T, mut p: Parser) -> T {\n /// Rather than just accepting/rejecting a given literal, unescapes it as\n /// well. Can take any slice prefixed by a character escape. Returns the\n /// character and the number of characters consumed.\n-pub fn char_lit(lit: &str) -> (char, int) {\n+pub fn char_lit(lit: &str) -> (char, isize) {\n     use std::{num, char};\n \n     let mut chars = lit.chars();\n@@ -401,19 +401,19 @@ pub fn char_lit(lit: &str) -> (char, int) {\n     let msg = format!(\"lexer should have rejected a bad character escape {}\", lit);\n     let msg2 = &msg[];\n \n-    fn esc(len: uint, lit: &str) -> Option<(char, int)> {\n+    fn esc(len: usize, lit: &str) -> Option<(char, isize)> {\n         num::from_str_radix(&lit[2..len], 16)\n         .and_then(char::from_u32)\n-        .map(|x| (x, len as int))\n+        .map(|x| (x, len as isize))\n     }\n \n-    let unicode_escape = |&: | -> Option<(char, int)>\n+    let unicode_escape = |&: | -> Option<(char, isize)>\n         if lit.as_bytes()[2] == b'{' {\n             let idx = lit.find('}').expect(msg2);\n             let subslice = &lit[3..idx];\n             num::from_str_radix(subslice, 16)\n                 .and_then(char::from_u32)\n-                .map(|x| (x, subslice.chars().count() as int + 4))\n+                .map(|x| (x, subslice.chars().count() as isize + 4))\n         } else {\n             esc(6, lit)\n         };\n@@ -437,7 +437,7 @@ pub fn str_lit(lit: &str) -> String {\n     let error = |&: i| format!(\"lexer should have rejected {} at {}\", lit, i);\n \n     /// Eat everything up to a non-whitespace\n-    fn eat<'a>(it: &mut iter::Peekable<(uint, char), str::CharIndices<'a>>) {\n+    fn eat<'a>(it: &mut iter::Peekable<(usize, char), str::CharIndices<'a>>) {\n         loop {\n             match it.peek().map(|x| x.1) {\n                 Some(' ') | Some('\\n') | Some('\\r') | Some('\\t') => {\n@@ -568,7 +568,7 @@ pub fn float_lit(s: &str, suffix: Option<&str>, sd: &SpanHandler, sp: Span) -> a\n }\n \n /// Parse a string representing a byte literal into its final form. Similar to `char_lit`\n-pub fn byte_lit(lit: &str) -> (u8, uint) {\n+pub fn byte_lit(lit: &str) -> (u8, usize) {\n     let err = |&: i| format!(\"lexer accepted invalid byte literal {} step {}\", lit, i);\n \n     if lit.len() == 1 {\n@@ -606,7 +606,7 @@ pub fn binary_lit(lit: &str) -> Rc<Vec<u8>> {\n     let error = |&: i| format!(\"lexer should have rejected {} at {}\", lit, i);\n \n     /// Eat everything up to a non-whitespace\n-    fn eat<'a, I: Iterator<Item=(uint, u8)>>(it: &mut iter::Peekable<(uint, u8), I>) {\n+    fn eat<'a, I: Iterator<Item=(usize, u8)>>(it: &mut iter::Peekable<(usize, u8), I>) {\n         loop {\n             match it.peek().map(|x| x.1) {\n                 Some(b' ') | Some(b'\\n') | Some(b'\\r') | Some(b'\\t') => {\n@@ -1161,11 +1161,11 @@ mod test {\n \n     #[test] fn span_of_self_arg_pat_idents_are_correct() {\n \n-        let srcs = [\"impl z { fn a (&self, &myarg: int) {} }\",\n-                    \"impl z { fn a (&mut self, &myarg: int) {} }\",\n-                    \"impl z { fn a (&'a self, &myarg: int) {} }\",\n-                    \"impl z { fn a (self, &myarg: int) {} }\",\n-                    \"impl z { fn a (self: Foo, &myarg: int) {} }\",\n+        let srcs = [\"impl z { fn a (&self, &myarg: i32) {} }\",\n+                    \"impl z { fn a (&mut self, &myarg: i32) {} }\",\n+                    \"impl z { fn a (&'a self, &myarg: i32) {} }\",\n+                    \"impl z { fn a (self, &myarg: i32) {} }\",\n+                    \"impl z { fn a (self: Foo, &myarg: i32) {} }\",\n                     ];\n \n         for &src in srcs.iter() {"}, {"sha": "a3600506057af8737ff9b1e3c7b73d73005f6bfb", "filename": "src/libsyntax/parse/obsolete.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a32249d4477f449646162bbad607c39d0ad7f3ca/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a32249d4477f449646162bbad607c39d0ad7f3ca/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fobsolete.rs?ref=a32249d4477f449646162bbad607c39d0ad7f3ca", "patch": "@@ -62,7 +62,7 @@ impl<'a> ParserObsoleteMethods for parser::Parser<'a> {\n                 \"use a `move ||` expression instead\",\n             ),\n             ObsoleteSyntax::ClosureType => (\n-                \"`|uint| -> bool` closure type syntax\",\n+                \"`|usize| -> bool` closure type syntax\",\n                 \"use unboxed closures instead, no type annotation needed\"\n             ),\n             ObsoleteSyntax::Sized => ("}, {"sha": "9822dcef0c022b334a7e1c91c68ef794ac3469a8", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/a32249d4477f449646162bbad607c39d0ad7f3ca/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a32249d4477f449646162bbad607c39d0ad7f3ca/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=a32249d4477f449646162bbad607c39d0ad7f3ca", "patch": "@@ -292,9 +292,9 @@ pub struct Parser<'a> {\n     pub buffer: [TokenAndSpan; 4],\n     pub buffer_start: int,\n     pub buffer_end: int,\n-    pub tokens_consumed: uint,\n+    pub tokens_consumed: usize,\n     pub restrictions: Restrictions,\n-    pub quote_depth: uint, // not (yet) related to the quasiquoter\n+    pub quote_depth: usize, // not (yet) related to the quasiquoter\n     pub reader: Box<Reader+'a>,\n     pub interner: Rc<token::IdentInterner>,\n     /// The set of seen errors about obsolete syntax. Used to suppress\n@@ -932,8 +932,8 @@ impl<'a> Parser<'a> {\n             self.reader.real_token()\n         } else {\n             // Avoid token copies with `replace`.\n-            let buffer_start = self.buffer_start as uint;\n-            let next_index = (buffer_start + 1) & 3 as uint;\n+            let buffer_start = self.buffer_start as usize;\n+            let next_index = (buffer_start + 1) & 3 as usize;\n             self.buffer_start = next_index as int;\n \n             let placeholder = TokenAndSpan {\n@@ -972,15 +972,15 @@ impl<'a> Parser<'a> {\n         }\n         return (4 - self.buffer_start) + self.buffer_end;\n     }\n-    pub fn look_ahead<R, F>(&mut self, distance: uint, f: F) -> R where\n+    pub fn look_ahead<R, F>(&mut self, distance: usize, f: F) -> R where\n         F: FnOnce(&token::Token) -> R,\n     {\n         let dist = distance as int;\n         while self.buffer_length() < dist {\n-            self.buffer[self.buffer_end as uint] = self.reader.real_token();\n+            self.buffer[self.buffer_end as usize] = self.reader.real_token();\n             self.buffer_end = (self.buffer_end + 1) & 3;\n         }\n-        f(&self.buffer[((self.buffer_start + dist - 1) & 3) as uint].tok)\n+        f(&self.buffer[((self.buffer_start + dist - 1) & 3) as usize].tok)\n     }\n     pub fn fatal(&mut self, m: &str) -> ! {\n         self.sess.span_diagnostic.span_fatal(self.span, m)\n@@ -2087,7 +2087,7 @@ impl<'a> Parser<'a> {\n         ExprField(expr, ident)\n     }\n \n-    pub fn mk_tup_field(&mut self, expr: P<Expr>, idx: codemap::Spanned<uint>) -> ast::Expr_ {\n+    pub fn mk_tup_field(&mut self, expr: P<Expr>, idx: codemap::Spanned<usize>) -> ast::Expr_ {\n         ExprTupField(expr, idx)\n     }\n \n@@ -2485,7 +2485,7 @@ impl<'a> Parser<'a> {\n                     hi = self.span.hi;\n                     self.bump();\n \n-                    let index = n.as_str().parse::<uint>();\n+                    let index = n.as_str().parse::<usize>();\n                     match index {\n                         Some(n) => {\n                             let id = spanned(dot, hi, n);\n@@ -2511,7 +2511,7 @@ impl<'a> Parser<'a> {\n                         };\n                         self.span_help(last_span,\n                             &format!(\"try parenthesizing the first index; e.g., `(foo.{}){}`\",\n-                                    float.trunc() as uint,\n+                                    float.trunc() as usize,\n                                     &float.fract().to_string()[1..])[]);\n                     }\n                     self.abort_if_errors();\n@@ -2864,7 +2864,7 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parse an expression of binops of at least min_prec precedence\n-    pub fn parse_more_binops(&mut self, lhs: P<Expr>, min_prec: uint) -> P<Expr> {\n+    pub fn parse_more_binops(&mut self, lhs: P<Expr>, min_prec: usize) -> P<Expr> {\n         if self.expr_is_complete(&*lhs) { return lhs; }\n \n         // Prevent dynamic borrow errors later on by limiting the"}, {"sha": "aeb9599923e0e20a4bc4647ae92086735ddb7efb", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a32249d4477f449646162bbad607c39d0ad7f3ca/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a32249d4477f449646162bbad607c39d0ad7f3ca/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=a32249d4477f449646162bbad607c39d0ad7f3ca", "patch": "@@ -83,9 +83,9 @@ pub enum Lit {\n     Integer(ast::Name),\n     Float(ast::Name),\n     Str_(ast::Name),\n-    StrRaw(ast::Name, uint), /* raw str delimited by n hash symbols */\n+    StrRaw(ast::Name, usize), /* raw str delimited by n hash symbols */\n     Binary(ast::Name),\n-    BinaryRaw(ast::Name, uint), /* raw binary str delimited by n hash symbols */\n+    BinaryRaw(ast::Name, usize), /* raw binary str delimited by n hash symbols */\n }\n \n impl Lit {\n@@ -724,7 +724,7 @@ pub fn intern(s: &str) -> ast::Name {\n     get_ident_interner().intern(s)\n }\n \n-/// gensym's a new uint, using the current interner.\n+/// gensym's a new usize, using the current interner.\n #[inline]\n pub fn gensym(s: &str) -> ast::Name {\n     get_ident_interner().gensym(s)"}, {"sha": "0cfc3d38e15d609750f8982948c498be09435e1f", "filename": "src/libsyntax/print/pp.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/a32249d4477f449646162bbad607c39d0ad7f3ca/src%2Flibsyntax%2Fprint%2Fpp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a32249d4477f449646162bbad607c39d0ad7f3ca/src%2Flibsyntax%2Fprint%2Fpp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpp.rs?ref=a32249d4477f449646162bbad607c39d0ad7f3ca", "patch": "@@ -31,7 +31,7 @@\n //!\n //! In particular you'll see a certain amount of churn related to INTEGER vs.\n //! CARDINAL in the Mesa implementation. Mesa apparently interconverts the two\n-//! somewhat readily? In any case, I've used uint for indices-in-buffers and\n+//! somewhat readily? In any case, I've used usize for indices-in-buffers and\n //! ints for character-sizes-and-indentation-offsets. This respects the need\n //! for ints to \"go negative\" while carrying a pending-calculation balance, and\n //! helps differentiate all the numbers flying around internally (slightly).\n@@ -123,9 +123,9 @@ pub fn tok_str(token: &Token) -> String {\n \n pub fn buf_str(toks: &[Token],\n                szs: &[int],\n-               left: uint,\n-               right: uint,\n-               lim: uint)\n+               left: usize,\n+               right: usize,\n+               lim: usize)\n                -> String {\n     let n = toks.len();\n     assert_eq!(n, szs.len());\n@@ -161,14 +161,14 @@ pub struct PrintStackElem {\n \n static SIZE_INFINITY: int = 0xffff;\n \n-pub fn mk_printer(out: Box<io::Writer+'static>, linewidth: uint) -> Printer {\n+pub fn mk_printer(out: Box<io::Writer+'static>, linewidth: usize) -> Printer {\n     // Yes 3, it makes the ring buffers big enough to never\n     // fall behind.\n-    let n: uint = 3 * linewidth;\n+    let n: usize = 3 * linewidth;\n     debug!(\"mk_printer {}\", linewidth);\n     let token: Vec<Token> = repeat(Token::Eof).take(n).collect();\n     let size: Vec<int> = repeat(0i).take(n).collect();\n-    let scan_stack: Vec<uint> = repeat(0u).take(n).collect();\n+    let scan_stack: Vec<usize> = repeat(0us).take(n).collect();\n     Printer {\n         out: out,\n         buf_len: n,\n@@ -267,15 +267,15 @@ pub fn mk_printer(out: Box<io::Writer+'static>, linewidth: uint) -> Printer {\n /// called 'print'.\n pub struct Printer {\n     pub out: Box<io::Writer+'static>,\n-    buf_len: uint,\n+    buf_len: usize,\n     /// Width of lines we're constrained to\n     margin: int,\n     /// Number of spaces left on line\n     space: int,\n     /// Index of left side of input stream\n-    left: uint,\n+    left: usize,\n     /// Index of right side of input stream\n-    right: uint,\n+    right: usize,\n     /// Ring-buffer stream goes through\n     token: Vec<Token> ,\n     /// Ring-buffer of calculated sizes\n@@ -290,13 +290,13 @@ pub struct Printer {\n     /// Begin (if there is any) on top of it. Stuff is flushed off the\n     /// bottom as it becomes irrelevant due to the primary ring-buffer\n     /// advancing.\n-    scan_stack: Vec<uint> ,\n+    scan_stack: Vec<usize> ,\n     /// Top==bottom disambiguator\n     scan_stack_empty: bool,\n     /// Index of top of scan_stack\n-    top: uint,\n+    top: usize,\n     /// Index of bottom of scan_stack\n-    bottom: uint,\n+    bottom: usize,\n     /// Stack of blocks-in-progress being flushed by print\n     print_stack: Vec<PrintStackElem> ,\n     /// Buffered indentation to avoid writing trailing whitespace\n@@ -405,7 +405,7 @@ impl Printer {\n         }\n         Ok(())\n     }\n-    pub fn scan_push(&mut self, x: uint) {\n+    pub fn scan_push(&mut self, x: usize) {\n         debug!(\"scan_push {}\", x);\n         if self.scan_stack_empty {\n             self.scan_stack_empty = false;\n@@ -416,7 +416,7 @@ impl Printer {\n         }\n         self.scan_stack[self.top] = x;\n     }\n-    pub fn scan_pop(&mut self) -> uint {\n+    pub fn scan_pop(&mut self) -> usize {\n         assert!((!self.scan_stack_empty));\n         let x = self.scan_stack[self.top];\n         if self.top == self.bottom {\n@@ -426,11 +426,11 @@ impl Printer {\n         }\n         return x;\n     }\n-    pub fn scan_top(&mut self) -> uint {\n+    pub fn scan_top(&mut self) -> usize {\n         assert!((!self.scan_stack_empty));\n         return self.scan_stack[self.top];\n     }\n-    pub fn scan_pop_bottom(&mut self) -> uint {\n+    pub fn scan_pop_bottom(&mut self) -> usize {\n         assert!((!self.scan_stack_empty));\n         let x = self.scan_stack[self.bottom];\n         if self.top == self.bottom {\n@@ -620,22 +620,22 @@ impl Printer {\n // Convenience functions to talk to the printer.\n //\n // \"raw box\"\n-pub fn rbox(p: &mut Printer, indent: uint, b: Breaks) -> io::IoResult<()> {\n+pub fn rbox(p: &mut Printer, indent: usize, b: Breaks) -> io::IoResult<()> {\n     p.pretty_print(Token::Begin(BeginToken {\n         offset: indent as int,\n         breaks: b\n     }))\n }\n \n-pub fn ibox(p: &mut Printer, indent: uint) -> io::IoResult<()> {\n+pub fn ibox(p: &mut Printer, indent: usize) -> io::IoResult<()> {\n     rbox(p, indent, Breaks::Inconsistent)\n }\n \n-pub fn cbox(p: &mut Printer, indent: uint) -> io::IoResult<()> {\n+pub fn cbox(p: &mut Printer, indent: usize) -> io::IoResult<()> {\n     rbox(p, indent, Breaks::Consistent)\n }\n \n-pub fn break_offset(p: &mut Printer, n: uint, off: int) -> io::IoResult<()> {\n+pub fn break_offset(p: &mut Printer, n: usize, off: int) -> io::IoResult<()> {\n     p.pretty_print(Token::Break(BreakToken {\n         offset: off,\n         blank_space: n as int\n@@ -662,7 +662,7 @@ pub fn zero_word(p: &mut Printer, wrd: &str) -> io::IoResult<()> {\n     p.pretty_print(Token::String(/* bad */ wrd.to_string(), 0))\n }\n \n-pub fn spaces(p: &mut Printer, n: uint) -> io::IoResult<()> {\n+pub fn spaces(p: &mut Printer, n: usize) -> io::IoResult<()> {\n     break_offset(p, n, 0)\n }\n \n@@ -675,7 +675,7 @@ pub fn space(p: &mut Printer) -> io::IoResult<()> {\n }\n \n pub fn hardbreak(p: &mut Printer) -> io::IoResult<()> {\n-    spaces(p, SIZE_INFINITY as uint)\n+    spaces(p, SIZE_INFINITY as usize)\n }\n \n pub fn hardbreak_tok_offset(off: int) -> Token {"}, {"sha": "2583c30229312cdacaf7f0017fa303c63c05637a", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/a32249d4477f449646162bbad607c39d0ad7f3ca/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a32249d4477f449646162bbad607c39d0ad7f3ca/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=a32249d4477f449646162bbad607c39d0ad7f3ca", "patch": "@@ -54,8 +54,8 @@ impl PpAnn for NoAnn {}\n \n #[derive(Copy)]\n pub struct CurrentCommentAndLiteral {\n-    cur_cmnt: uint,\n-    cur_lit: uint,\n+    cur_cmnt: usize,\n+    cur_lit: usize,\n }\n \n pub struct State<'a> {\n@@ -92,10 +92,10 @@ pub fn rust_printer_annotated<'a>(writer: Box<io::Writer+'static>,\n }\n \n #[allow(non_upper_case_globals)]\n-pub const indent_unit: uint = 4u;\n+pub const indent_unit: usize = 4us;\n \n #[allow(non_upper_case_globals)]\n-pub const default_columns: uint = 78u;\n+pub const default_columns: usize = 78us;\n \n /// Requires you to pass an input filename and reader so that\n /// it can scan the input text for comments and literals to\n@@ -459,7 +459,7 @@ fn needs_parentheses(expr: &ast::Expr) -> bool {\n }\n \n impl<'a> State<'a> {\n-    pub fn ibox(&mut self, u: uint) -> IoResult<()> {\n+    pub fn ibox(&mut self, u: usize) -> IoResult<()> {\n         self.boxes.push(pp::Breaks::Inconsistent);\n         pp::ibox(&mut self.s, u)\n     }\n@@ -469,13 +469,13 @@ impl<'a> State<'a> {\n         pp::end(&mut self.s)\n     }\n \n-    pub fn cbox(&mut self, u: uint) -> IoResult<()> {\n+    pub fn cbox(&mut self, u: usize) -> IoResult<()> {\n         self.boxes.push(pp::Breaks::Consistent);\n         pp::cbox(&mut self.s, u)\n     }\n \n     // \"raw box\"\n-    pub fn rbox(&mut self, u: uint, b: pp::Breaks) -> IoResult<()> {\n+    pub fn rbox(&mut self, u: usize, b: pp::Breaks) -> IoResult<()> {\n         self.boxes.push(b);\n         pp::rbox(&mut self.s, u, b)\n     }\n@@ -514,11 +514,11 @@ impl<'a> State<'a> {\n     }\n \n     pub fn bclose_(&mut self, span: codemap::Span,\n-                   indented: uint) -> IoResult<()> {\n+                   indented: usize) -> IoResult<()> {\n         self.bclose_maybe_open(span, indented, true)\n     }\n     pub fn bclose_maybe_open (&mut self, span: codemap::Span,\n-                              indented: uint, close_box: bool) -> IoResult<()> {\n+                              indented: usize, close_box: bool) -> IoResult<()> {\n         try!(self.maybe_print_comment(span.hi));\n         try!(self.break_offset_if_not_bol(1u, -(indented as int)));\n         try!(word(&mut self.s, \"}\"));\n@@ -567,7 +567,7 @@ impl<'a> State<'a> {\n         if !self.is_bol() { try!(space(&mut self.s)); }\n         Ok(())\n     }\n-    pub fn break_offset_if_not_bol(&mut self, n: uint,\n+    pub fn break_offset_if_not_bol(&mut self, n: usize,\n                                    off: int) -> IoResult<()> {\n         if !self.is_bol() {\n             break_offset(&mut self.s, n, off)\n@@ -1355,7 +1355,7 @@ impl<'a> State<'a> {\n     }\n \n     pub fn print_block_unclosed_indent(&mut self, blk: &ast::Block,\n-                                       indented: uint) -> IoResult<()> {\n+                                       indented: usize) -> IoResult<()> {\n         self.print_block_maybe_unclosed(blk, indented, &[], false)\n     }\n \n@@ -1367,7 +1367,7 @@ impl<'a> State<'a> {\n \n     pub fn print_block_maybe_unclosed(&mut self,\n                                       blk: &ast::Block,\n-                                      indented: uint,\n+                                      indented: usize,\n                                       attrs: &[ast::Attribute],\n                                       close_box: bool) -> IoResult<()> {\n         match blk.rules {\n@@ -1951,7 +1951,7 @@ impl<'a> State<'a> {\n         self.ann.post(self, NodeIdent(&ident))\n     }\n \n-    pub fn print_uint(&mut self, i: uint) -> IoResult<()> {\n+    pub fn print_uint(&mut self, i: usize) -> IoResult<()> {\n         word(&mut self.s, &i.to_string()[])\n     }\n \n@@ -3053,7 +3053,7 @@ impl<'a> State<'a> {\n     }\n }\n \n-fn repeat(s: &str, n: uint) -> String { iter::repeat(s).take(n).collect() }\n+fn repeat(s: &str, n: usize) -> String { iter::repeat(s).take(n).collect() }\n \n #[cfg(test)]\n mod test {"}, {"sha": "757bafaf5cb91f49f5314be074ecd07bc56df447", "filename": "src/libsyntax/util/interner.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a32249d4477f449646162bbad607c39d0ad7f3ca/src%2Flibsyntax%2Futil%2Finterner.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a32249d4477f449646162bbad607c39d0ad7f3ca/src%2Flibsyntax%2Futil%2Finterner.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Finterner.rs?ref=a32249d4477f449646162bbad607c39d0ad7f3ca", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! An \"interner\" is a data structure that associates values with uint tags and\n+//! An \"interner\" is a data structure that associates values with usize tags and\n //! allows bidirectional lookup; i.e. given a value, one can easily find the\n //! type, and vice versa.\n \n@@ -73,7 +73,7 @@ impl<T: Eq + Hash<Hasher> + Clone + 'static> Interner<T> {\n         (*vect)[idx.uint()].clone()\n     }\n \n-    pub fn len(&self) -> uint {\n+    pub fn len(&self) -> usize {\n         let vect = self.vect.borrow();\n         (*vect).len()\n     }\n@@ -199,7 +199,7 @@ impl StrInterner {\n         (*self.vect.borrow())[idx.uint()].clone()\n     }\n \n-    pub fn len(&self) -> uint {\n+    pub fn len(&self) -> usize {\n         self.vect.borrow().len()\n     }\n "}, {"sha": "5466b7337e776dce97788e008c15d2d50d23ec97", "filename": "src/libsyntax/util/parser_testing.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a32249d4477f449646162bbad607c39d0ad7f3ca/src%2Flibsyntax%2Futil%2Fparser_testing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a32249d4477f449646162bbad607c39d0ad7f3ca/src%2Flibsyntax%2Futil%2Fparser_testing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Fparser_testing.rs?ref=a32249d4477f449646162bbad607c39d0ad7f3ca", "patch": "@@ -130,10 +130,10 @@ pub fn matches_codepattern(a : &str, b : &str) -> bool {\n     }\n }\n \n-/// Given a string and an index, return the first uint >= idx\n+/// Given a string and an index, return the first usize >= idx\n /// that is a non-ws-char or is outside of the legal range of\n /// the string.\n-fn scan_for_non_ws_or_end(a : &str, idx: uint) -> uint {\n+fn scan_for_non_ws_or_end(a : &str, idx: usize) -> usize {\n     let mut i = idx;\n     let len = a.len();\n     while (i < len) && (is_whitespace(a.char_at(i))) {"}, {"sha": "a4494a9886405cb8fcd729401df3b185651fe030", "filename": "src/libsyntax/util/small_vector.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a32249d4477f449646162bbad607c39d0ad7f3ca/src%2Flibsyntax%2Futil%2Fsmall_vector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a32249d4477f449646162bbad607c39d0ad7f3ca/src%2Flibsyntax%2Futil%2Fsmall_vector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Fsmall_vector.rs?ref=a32249d4477f449646162bbad607c39d0ad7f3ca", "patch": "@@ -89,7 +89,7 @@ impl<T> SmallVector<T> {\n         }\n     }\n \n-    pub fn get<'a>(&'a self, idx: uint) -> &'a T {\n+    pub fn get<'a>(&'a self, idx: usize) -> &'a T {\n         match self.repr {\n             One(ref v) if idx == 0 => v,\n             Many(ref vs) => &vs[idx],\n@@ -126,7 +126,7 @@ impl<T> SmallVector<T> {\n         IntoIter { repr: repr }\n     }\n \n-    pub fn len(&self) -> uint {\n+    pub fn len(&self) -> usize {\n         match self.repr {\n             Zero => 0,\n             One(..) => 1,\n@@ -165,7 +165,7 @@ impl<T> Iterator for IntoIter<T> {\n         }\n     }\n \n-    fn size_hint(&self) -> (uint, Option<uint>) {\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n         match self.repr {\n             ZeroIterator => (0, Some(0)),\n             OneIterator(..) => (1, Some(1)),"}]}