{"sha": "0d4705b0097a132cbb721095997d91090e8cdb21", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBkNDcwNWIwMDk3YTEzMmNiYjcyMTA5NTk5N2Q5MTA5MGU4Y2RiMjE=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2020-03-20T03:28:17Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2020-04-06T18:55:43Z"}, "message": "traits/coherence: stop using `Ty::walk_shallow`.", "tree": {"sha": "766aee5abc5f59d8b01b70db73acc230b3439f16", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/766aee5abc5f59d8b01b70db73acc230b3439f16"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0d4705b0097a132cbb721095997d91090e8cdb21", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0d4705b0097a132cbb721095997d91090e8cdb21", "html_url": "https://github.com/rust-lang/rust/commit/0d4705b0097a132cbb721095997d91090e8cdb21", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0d4705b0097a132cbb721095997d91090e8cdb21/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e53c42c0b304c809d5f20bfb849e77312735a399", "url": "https://api.github.com/repos/rust-lang/rust/commits/e53c42c0b304c809d5f20bfb849e77312735a399", "html_url": "https://github.com/rust-lang/rust/commit/e53c42c0b304c809d5f20bfb849e77312735a399"}], "stats": {"total": 73, "additions": 52, "deletions": 21}, "files": [{"sha": "4a71585ec1c10cb8683440746b4fdc9ccbb287cf", "filename": "src/librustc_trait_selection/traits/coherence.rs", "status": "modified", "additions": 50, "deletions": 19, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/0d4705b0097a132cbb721095997d91090e8cdb21/src%2Flibrustc_trait_selection%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d4705b0097a132cbb721095997d91090e8cdb21/src%2Flibrustc_trait_selection%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fcoherence.rs?ref=0d4705b0097a132cbb721095997d91090e8cdb21", "patch": "@@ -14,6 +14,7 @@ use rustc_middle::ty::subst::Subst;\n use rustc_middle::ty::{self, Ty, TyCtxt};\n use rustc_span::symbol::sym;\n use rustc_span::DUMMY_SP;\n+use std::iter;\n \n /// Whether we do the orphan check relative to this crate or\n /// to some remote crate.\n@@ -378,19 +379,25 @@ fn orphan_check_trait_ref<'tcx>(\n         ty: Ty<'tcx>,\n         in_crate: InCrate,\n     ) -> Vec<Ty<'tcx>> {\n-        if fundamental_ty(ty) && ty_is_non_local(ty, in_crate).is_some() {\n-            ty.walk_shallow().flat_map(|ty| uncover_fundamental_ty(tcx, ty, in_crate)).collect()\n-        } else {\n-            vec![ty]\n+        // FIXME(eddyb) figure out if this is redundant with `ty_is_non_local`,\n+        // or maybe if this should be calling `ty_is_non_local_constructor`.\n+        if ty_is_non_local(tcx, ty, in_crate).is_some() {\n+            if let Some(inner_tys) = fundamental_ty_inner_tys(tcx, ty) {\n+                return inner_tys\n+                    .flat_map(|ty| uncover_fundamental_ty(tcx, ty, in_crate))\n+                    .collect();\n+            }\n         }\n+\n+        vec![ty]\n     }\n \n     let mut non_local_spans = vec![];\n     for (i, input_ty) in\n         trait_ref.input_types().flat_map(|ty| uncover_fundamental_ty(tcx, ty, in_crate)).enumerate()\n     {\n         debug!(\"orphan_check_trait_ref: check ty `{:?}`\", input_ty);\n-        let non_local_tys = ty_is_non_local(input_ty, in_crate);\n+        let non_local_tys = ty_is_non_local(tcx, input_ty, in_crate);\n         if non_local_tys.is_none() {\n             debug!(\"orphan_check_trait_ref: ty_is_local `{:?}`\", input_ty);\n             return Ok(());\n@@ -416,30 +423,53 @@ fn orphan_check_trait_ref<'tcx>(\n     Err(OrphanCheckErr::NonLocalInputType(non_local_spans))\n }\n \n-fn ty_is_non_local<'t>(ty: Ty<'t>, in_crate: InCrate) -> Option<Vec<Ty<'t>>> {\n+fn ty_is_non_local(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>, in_crate: InCrate) -> Option<Vec<Ty<'tcx>>> {\n     match ty_is_non_local_constructor(ty, in_crate) {\n         Some(ty) => {\n-            if !fundamental_ty(ty) {\n-                Some(vec![ty])\n-            } else {\n-                let tys: Vec<_> = ty\n-                    .walk_shallow()\n-                    .filter_map(|t| ty_is_non_local(t, in_crate))\n-                    .flat_map(|i| i)\n+            if let Some(inner_tys) = fundamental_ty_inner_tys(tcx, ty) {\n+                let tys: Vec<_> = inner_tys\n+                    .filter_map(|ty| ty_is_non_local(tcx, ty, in_crate))\n+                    .flatten()\n                     .collect();\n                 if tys.is_empty() { None } else { Some(tys) }\n+            } else {\n+                Some(vec![ty])\n             }\n         }\n         None => None,\n     }\n }\n \n-fn fundamental_ty(ty: Ty<'_>) -> bool {\n-    match ty.kind {\n-        ty::Ref(..) => true,\n-        ty::Adt(def, _) => def.is_fundamental(),\n-        _ => false,\n-    }\n+/// For `#[fundamental]` ADTs and `&T` / `&mut T`, returns `Some` with the\n+/// type parameters of the ADT, or `T`, respectively. For non-fundamental\n+/// types, returns `None`.\n+fn fundamental_ty_inner_tys(\n+    tcx: TyCtxt<'tcx>,\n+    ty: Ty<'tcx>,\n+) -> Option<impl Iterator<Item = Ty<'tcx>>> {\n+    let (first_ty, rest_tys) = match ty.kind {\n+        ty::Ref(_, ty, _) => (ty, ty::subst::InternalSubsts::empty().types()),\n+        ty::Adt(def, substs) if def.is_fundamental() => {\n+            let mut types = substs.types();\n+\n+            // FIXME(eddyb) actually validate `#[fundamental]` up-front.\n+            match types.next() {\n+                None => {\n+                    tcx.sess.span_err(\n+                        tcx.def_span(def.did),\n+                        \"`#[fundamental]` requires at least one type parameter\",\n+                    );\n+\n+                    return None;\n+                }\n+\n+                Some(first_ty) => (first_ty, types),\n+            }\n+        }\n+        _ => return None,\n+    };\n+\n+    Some(iter::once(first_ty).chain(rest_tys))\n }\n \n fn def_id_is_local(def_id: DefId, in_crate: InCrate) -> bool {\n@@ -451,6 +481,7 @@ fn def_id_is_local(def_id: DefId, in_crate: InCrate) -> bool {\n     }\n }\n \n+// FIXME(eddyb) this can just return `bool` as it always returns `Some(ty)` or `None`.\n fn ty_is_non_local_constructor(ty: Ty<'_>, in_crate: InCrate) -> Option<Ty<'_>> {\n     debug!(\"ty_is_non_local_constructor({:?})\", ty);\n "}, {"sha": "bc1e18b657f3163e4a137ac2283a6af23848c304", "filename": "src/test/ui/coherence/impl-foreign-for-locally-defined-fundamental.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0d4705b0097a132cbb721095997d91090e8cdb21/src%2Ftest%2Fui%2Fcoherence%2Fimpl-foreign-for-locally-defined-fundamental.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d4705b0097a132cbb721095997d91090e8cdb21/src%2Ftest%2Fui%2Fcoherence%2Fimpl-foreign-for-locally-defined-fundamental.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcoherence%2Fimpl-foreign-for-locally-defined-fundamental.rs?ref=0d4705b0097a132cbb721095997d91090e8cdb21", "patch": "@@ -8,8 +8,8 @@ extern crate coherence_lib as lib;\n use lib::*;\n \n #[fundamental]\n-struct Local;\n+struct Local<T>(T);\n \n-impl Remote for Local {}\n+impl Remote for Local<()> {}\n \n fn main() {}"}]}