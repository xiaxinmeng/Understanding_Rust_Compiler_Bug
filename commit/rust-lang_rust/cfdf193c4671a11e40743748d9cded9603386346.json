{"sha": "cfdf193c4671a11e40743748d9cded9603386346", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNmZGYxOTNjNDY3MWExMWU0MDc0Mzc0OGQ5Y2RlZDk2MDMzODYzNDY=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-10-25T13:56:55Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-10-25T13:56:55Z"}, "message": "Update our code to new type parameter kind syntax\n\nCloses #1067", "tree": {"sha": "dc7b1013eab9d6be0399816279d10b92f181abc2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dc7b1013eab9d6be0399816279d10b92f181abc2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cfdf193c4671a11e40743748d9cded9603386346", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cfdf193c4671a11e40743748d9cded9603386346", "html_url": "https://github.com/rust-lang/rust/commit/cfdf193c4671a11e40743748d9cded9603386346", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cfdf193c4671a11e40743748d9cded9603386346/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "58c82a8da2b16878766b5dc630f7499166cceb21", "url": "https://api.github.com/repos/rust-lang/rust/commits/58c82a8da2b16878766b5dc630f7499166cceb21", "html_url": "https://github.com/rust-lang/rust/commit/58c82a8da2b16878766b5dc630f7499166cceb21"}], "stats": {"total": 577, "additions": 289, "deletions": 288}, "files": [{"sha": "67a6d09ce17a0aba1785f07683fbdaef0b2070d6", "filename": "src/comp/driver/rustc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cfdf193c4671a11e40743748d9cded9603386346/src%2Fcomp%2Fdriver%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfdf193c4671a11e40743748d9cded9603386346/src%2Fcomp%2Fdriver%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fdriver%2Frustc.rs?ref=cfdf193c4671a11e40743748d9cded9603386346", "patch": "@@ -88,7 +88,7 @@ fn parse_input_src(sess: session::session, cfg: ast::crate_cfg, infile: str)\n     ret {crate: crate, src: src};\n }\n \n-fn time<@T>(do_it: bool, what: str, thunk: fn@() -> T) -> T {\n+fn time<T>(do_it: bool, what: str, thunk: fn@() -> T) -> T {\n     if !do_it { ret thunk(); }\n     let start = std::time::precise_time_s();\n     let rv = thunk();"}, {"sha": "a9da327fcef2def54ccf161e4ab28480073fbbc8", "filename": "src/comp/front/attr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cfdf193c4671a11e40743748d9cded9603386346/src%2Fcomp%2Ffront%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfdf193c4671a11e40743748d9cded9603386346/src%2Fcomp%2Ffront%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fattr.rs?ref=cfdf193c4671a11e40743748d9cded9603386346", "patch": "@@ -182,7 +182,7 @@ fn require_unique_names(sess: session::session, metas: [@ast::meta_item]) {\n     }\n }\n \n-fn span<@T>(item: T) -> ast::spanned<T> {\n+fn span<T>(item: T) -> ast::spanned<T> {\n     ret {node: item, span: ast_util::dummy_sp()};\n }\n "}, {"sha": "255a83712f82011cfa6ce10ec3d8a9f701692c70", "filename": "src/comp/front/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cfdf193c4671a11e40743748d9cded9603386346/src%2Fcomp%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfdf193c4671a11e40743748d9cded9603386346/src%2Fcomp%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Ftest.rs?ref=cfdf193c4671a11e40743748d9cded9603386346", "patch": "@@ -180,7 +180,7 @@ fn mk_test_module(cx: test_ctxt) -> @ast::item {\n     ret @item;\n }\n \n-fn nospan<@T>(t: T) -> ast::spanned<T> { ret {node: t, span: dummy_sp()}; }\n+fn nospan<T>(t: T) -> ast::spanned<T> { ret {node: t, span: dummy_sp()}; }\n \n fn mk_tests(cx: test_ctxt) -> @ast::item {\n     let ret_ty = mk_test_desc_vec_ty(cx);"}, {"sha": "91f0feda596bef0dfb9970fdb94c98c57e5c3dfb", "filename": "src/comp/metadata/encoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cfdf193c4671a11e40743748d9cded9603386346/src%2Fcomp%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfdf193c4671a11e40743748d9cded9603386346/src%2Fcomp%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fencoder.rs?ref=cfdf193c4671a11e40743748d9cded9603386346", "patch": "@@ -391,7 +391,7 @@ fn encode_info_for_items(ecx: @encode_ctxt, ebml_w: ebml::writer) ->\n \n // Path and definition ID indexing\n \n-fn create_index<@T>(index: [entry<T>], hash_fn: fn(T) -> uint) ->\n+fn create_index<T>(index: [entry<T>], hash_fn: fn(T) -> uint) ->\n    [@[entry<T>]] {\n     let buckets: [@mutable [entry<T>]] = [];\n     uint::range(0u, 256u) {|_i| buckets += [@mutable []]; };"}, {"sha": "e1f98ca34bbca66010de44b4284781cb02b2b642", "filename": "src/comp/metadata/tydecode.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cfdf193c4671a11e40743748d9cded9603386346/src%2Fcomp%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfdf193c4671a11e40743748d9cded9603386346/src%2Fcomp%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Ftydecode.rs?ref=cfdf193c4671a11e40743748d9cded9603386346", "patch": "@@ -150,7 +150,7 @@ fn parse_ty_constr_arg(st: @pstate, sd: str_def) ->\n     }\n }\n \n-fn parse_constr<@T>(st: @pstate, sd: str_def, pser: arg_parser<T>) ->\n+fn parse_constr<T>(st: @pstate, sd: str_def, pser: arg_parser<T>) ->\n    @ty::constr_general<T> {\n     let sp = ast_util::dummy_sp(); // FIXME: use a real span\n     let args: [@sp_constr_arg<T>] = [];"}, {"sha": "3e73ec1060cdbd58141b1390c00b9c66f80318f0", "filename": "src/comp/middle/ast_map.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/cfdf193c4671a11e40743748d9cded9603386346/src%2Fcomp%2Fmiddle%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfdf193c4671a11e40743748d9cded9603386346/src%2Fcomp%2Fmiddle%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fast_map.rs?ref=cfdf193c4671a11e40743748d9cded9603386346", "patch": "@@ -75,7 +75,7 @@ fn map_expr(cx: ctx, ex: @expr) {\n     cx.map.insert(ex.id, node_expr(ex));\n }\n \n-fn new_smallintmap_int_adapter<@V>() -> std::map::hashmap<int, V> {\n+fn new_smallintmap_int_adapter<V>() -> std::map::hashmap<int, V> {\n     let key_idx = fn (&&key: int) -> uint { key as uint };\n     let idx_key = fn (idx: uint) -> int { idx as int };\n     ret new_smallintmap_adapter(key_idx, idx_key);\n@@ -86,13 +86,13 @@ fn new_smallintmap_int_adapter<@V>() -> std::map::hashmap<int, V> {\n // the entire codebase adapting all the callsites to the different\n // interface.\n // FIXME: hashmap and smallintmap should support the same interface.\n-fn new_smallintmap_adapter<@K, @V>(key_idx: fn(K) -> uint,\n+fn new_smallintmap_adapter<K, V>(key_idx: fn(K) -> uint,\n                                    idx_key: fn(uint) -> K)\n     -> std::map::hashmap<K, V> {\n \n-    obj adapter<@K, @V>(map: smallintmap::smallintmap<V>,\n-                        key_idx: fn(K) -> uint,\n-                        idx_key: fn(uint) -> K) {\n+    obj adapter<K, V>(map: smallintmap::smallintmap<V>,\n+                      key_idx: fn(K) -> uint,\n+                      idx_key: fn(uint) -> K) {\n \n         fn size() -> uint { fail }\n "}, {"sha": "149e463c111d44b1e5cf798a67e2b697e1a8cb3a", "filename": "src/comp/middle/kind.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cfdf193c4671a11e40743748d9cded9603386346/src%2Fcomp%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfdf193c4671a11e40743748d9cded9603386346/src%2Fcomp%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fkind.rs?ref=cfdf193c4671a11e40743748d9cded9603386346", "patch": "@@ -25,10 +25,10 @@\n *\n *\n * Since this forms a lattice, we denote the capabilites in terms of a\n-* worst-case requirement.  That is, if your function needs to move-and-send\n-* (or copy) your T, you write fn<~T>(...). If you need to move but not send,\n-* you write fn<@T>(...). And if you need neither -- can work with any sort of\n-* pinned data at all -- then you write fn<T>(...).\n+* worst-case requirement. That is, if your function needs to move-and-send (or\n+* copy) your T, you write fn<unique T>(...). If you need to move but not send,\n+* you write fn<T>(...). And if you need neither -- can work with any sort of\n+* pinned data at all -- then you write fn<pinned T>(...).\n *\n * Most types are unique or shared. Other possible name combinations for these\n * two: (tree, graph; pruned, pooled; message, local; owned, common) are"}, {"sha": "864b82ed9fbd7ccb28bb073c0ef29a015377b6b6", "filename": "src/comp/syntax/ast_util.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cfdf193c4671a11e40743748d9cded9603386346/src%2Fcomp%2Fsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfdf193c4671a11e40743748d9cded9603386346/src%2Fcomp%2Fsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fast_util.rs?ref=cfdf193c4671a11e40743748d9cded9603386346", "patch": "@@ -2,7 +2,7 @@ import std::{str, option};\n import codemap::span;\n import ast::*;\n \n-fn respan<@T>(sp: span, t: T) -> spanned<T> { ret {node: t, span: sp}; }\n+fn respan<T>(sp: span, t: T) -> spanned<T> { ret {node: t, span: sp}; }\n \n /* assuming that we're not in macro expansion */\n fn mk_sp(lo: uint, hi: uint) -> span {\n@@ -186,7 +186,7 @@ fn eq_def_id(&&a: def_id, &&b: def_id) -> bool {\n     a == b\n }\n \n-fn new_def_id_hash<@T>() -> std::map::hashmap<def_id, T> {\n+fn new_def_id_hash<T>() -> std::map::hashmap<def_id, T> {\n     std::map::mk_hashmap(hash_def_id, eq_def_id)\n }\n "}, {"sha": "3adcfbccf4e7dcd58eed88523d04145c0916f394", "filename": "src/comp/syntax/ext/simplext.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cfdf193c4671a11e40743748d9cded9603386346/src%2Fcomp%2Fsyntax%2Fext%2Fsimplext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfdf193c4671a11e40743748d9cded9603386346/src%2Fcomp%2Fsyntax%2Fext%2Fsimplext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fext%2Fsimplext.rs?ref=cfdf193c4671a11e40743748d9cded9603386346", "patch": "@@ -104,7 +104,7 @@ fn elts_to_ell(cx: ext_ctxt, elts: [@expr]) ->\n         }\n }\n \n-fn option_flatten_map<T, @U>(f: fn@(T) -> option::t<U>, v: [T]) ->\n+fn option_flatten_map<T, U>(f: fn@(T) -> option::t<U>, v: [T]) ->\n    option::t<[U]> {\n     let res = [];\n     for elem: T in v {"}, {"sha": "9b467e683b80dcb5fdf2c8a06427781ea1f5ee81", "filename": "src/comp/syntax/parse/parser.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/cfdf193c4671a11e40743748d9cded9603386346/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfdf193c4671a11e40743748d9cded9603386346/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs?ref=cfdf193c4671a11e40743748d9cded9603386346", "patch": "@@ -210,7 +210,7 @@ fn expect_gt(p: parser) {\n     }\n }\n \n-fn spanned<@T>(lo: uint, hi: uint, node: T) -> spanned<T> {\n+fn spanned<T>(lo: uint, hi: uint, node: T) -> spanned<T> {\n     ret {node: node, span: ast_util::mk_sp(lo, hi)};\n }\n \n@@ -595,7 +595,7 @@ fn parse_fn_block_arg(p: parser) -> ast::arg {\n     ret {mode: m, ty: t, ident: i, id: p.get_id()};\n }\n \n-fn parse_seq_to_before_gt<@T>(sep: option::t<token::token>,\n+fn parse_seq_to_before_gt<T>(sep: option::t<token::token>,\n                               f: fn@(parser) -> T,\n                               p: parser) -> [T] {\n     let first = true;\n@@ -612,15 +612,15 @@ fn parse_seq_to_before_gt<@T>(sep: option::t<token::token>,\n     ret v;\n }\n \n-fn parse_seq_to_gt<@T>(sep: option::t<token::token>, f: fn@(parser) -> T,\n+fn parse_seq_to_gt<T>(sep: option::t<token::token>, f: fn@(parser) -> T,\n                       p: parser) -> [T] {\n     let v = parse_seq_to_before_gt(sep, f, p);\n     expect_gt(p);\n \n     ret v;\n }\n \n-fn parse_seq_lt_gt<@T>(sep: option::t<token::token>, f: fn@(parser) -> T,\n+fn parse_seq_lt_gt<T>(sep: option::t<token::token>, f: fn@(parser) -> T,\n                       p: parser) -> spanned<[T]> {\n     let lo = p.get_lo_pos();\n     expect(p, token::LT);\n@@ -630,14 +630,14 @@ fn parse_seq_lt_gt<@T>(sep: option::t<token::token>, f: fn@(parser) -> T,\n     ret spanned(lo, hi, result);\n }\n \n-fn parse_seq_to_end<@T>(ket: token::token, sep: option::t<token::token>,\n+fn parse_seq_to_end<T>(ket: token::token, sep: option::t<token::token>,\n                        f: fn(parser) -> T, p: parser) -> [T] {\n     let val = parse_seq_to_before_end(ket, sep, f, p);\n     p.bump();\n     ret val;\n }\n \n-fn parse_seq_to_before_end<@T>(ket: token::token,\n+fn parse_seq_to_before_end<T>(ket: token::token,\n                                sep: option::t<token::token>,\n                                f: fn@(parser) -> T, p: parser) -> [T] {\n     let first: bool = true;\n@@ -653,7 +653,7 @@ fn parse_seq_to_before_end<@T>(ket: token::token,\n }\n \n \n-fn parse_seq<@T>(bra: token::token, ket: token::token,\n+fn parse_seq<T>(bra: token::token, ket: token::token,\n                 sep: option::t<token::token>, f: fn@(parser) -> T, p: parser)\n    -> spanned<[T]> {\n     let lo = p.get_lo_pos();"}, {"sha": "dea86723af376f9b4f2e2f67337383d712dce780", "filename": "src/comp/syntax/util/interner.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cfdf193c4671a11e40743748d9cded9603386346/src%2Fcomp%2Fsyntax%2Futil%2Finterner.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfdf193c4671a11e40743748d9cded9603386346/src%2Fcomp%2Fsyntax%2Futil%2Finterner.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Futil%2Finterner.rs?ref=cfdf193c4671a11e40743748d9cded9603386346", "patch": "@@ -11,12 +11,12 @@ type interner<T> =\n      hasher: hashfn<T>,\n      eqer: eqfn<T>};\n \n-fn mk<@T>(hasher: hashfn<T>, eqer: eqfn<T>) -> interner<T> {\n+fn mk<T>(hasher: hashfn<T>, eqer: eqfn<T>) -> interner<T> {\n     let m = map::mk_hashmap::<T, uint>(hasher, eqer);\n     ret {map: m, mutable vect: [], hasher: hasher, eqer: eqer};\n }\n \n-fn intern<@T>(itr: interner<T>, val: T) -> uint {\n+fn intern<T>(itr: interner<T>, val: T) -> uint {\n     alt itr.map.find(val) {\n       some(idx) { ret idx; }\n       none. {\n@@ -31,7 +31,7 @@ fn intern<@T>(itr: interner<T>, val: T) -> uint {\n // |get| isn't \"pure\" in the traditional sense, because it can go from\n // failing to returning a value as items are interned. But for typestate,\n // where we first check a pred and then rely on it, ceasing to fail is ok.\n-pure fn get<@T>(itr: interner<T>, idx: uint) -> T {\n+pure fn get<T>(itr: interner<T>, idx: uint) -> T {\n     unchecked {\n         itr.vect[idx]\n     }"}, {"sha": "2eb717f5109c68668d474dcc0595cd293f274104", "filename": "src/comp/util/common.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cfdf193c4671a11e40743748d9cded9603386346/src%2Fcomp%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfdf193c4671a11e40743748d9cded9603386346/src%2Fcomp%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Futil%2Fcommon.rs?ref=cfdf193c4671a11e40743748d9cded9603386346", "patch": "@@ -25,7 +25,7 @@ fn hash_def(d: ast::def_id) -> uint {\n     ret h;\n }\n \n-fn new_def_hash<@V>() -> std::map::hashmap<ast::def_id, V> {\n+fn new_def_hash<V>() -> std::map::hashmap<ast::def_id, V> {\n     let hasher: std::map::hashfn<ast::def_id> = hash_def;\n     let eqer: std::map::eqfn<ast::def_id> = def_eq;\n     ret std::map::mk_hashmap::<ast::def_id, V>(hasher, eqer);\n@@ -166,7 +166,7 @@ fn lit_in_range(l: @ast::lit, m1: @ast::lit, m2: @ast::lit) -> bool {\n     }\n }\n \n-fn ranges_overlap<@T>(a1: T, a2: T, b1: T, b2: T) -> bool {\n+fn ranges_overlap<T>(a1: T, a2: T, b1: T, b2: T) -> bool {\n     let min1 = min(a1, a2);\n     let max1 = max(a1, a2);\n     let min2 = min(b1, b2);"}, {"sha": "a619d7e6884691029613ca65851148e03536cd52", "filename": "src/comp/util/filesearch.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cfdf193c4671a11e40743748d9cded9603386346/src%2Fcomp%2Futil%2Ffilesearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfdf193c4671a11e40743748d9cded9603386346/src%2Fcomp%2Futil%2Ffilesearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Futil%2Ffilesearch.rs?ref=cfdf193c4671a11e40743748d9cded9603386346", "patch": "@@ -16,7 +16,7 @@ export pick_file;\n export search;\n export relative_target_lib_path;\n \n-type pick<@T> = block(path: fs::path) -> option::t<T>;\n+type pick<T> = block(path: fs::path) -> option::t<T>;\n \n fn pick_file(file: fs::path, path: fs::path) -> option::t<fs::path> {\n     if fs::basename(path) == file { option::some(path) }\n@@ -57,7 +57,7 @@ fn mk_filesearch(maybe_sysroot: option::t<fs::path>,\n }\n \n // FIXME #1001: This can't be an obj method\n-fn search<@T>(filesearch: filesearch, pick: pick<T>) -> option::t<T> {\n+fn search<T>(filesearch: filesearch, pick: pick<T>) -> option::t<T> {\n     for lib_search_path in filesearch.lib_search_paths() {\n         log #fmt[\"searching %s\", lib_search_path];\n         for path in fs::list_dir(lib_search_path) {"}, {"sha": "173403690e5faec45beacf77fdb6d228c573ae8a", "filename": "src/compiletest/procsrv.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cfdf193c4671a11e40743748d9cded9603386346/src%2Fcompiletest%2Fprocsrv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfdf193c4671a11e40743748d9cded9603386346/src%2Fcompiletest%2Fprocsrv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fprocsrv.rs?ref=cfdf193c4671a11e40743748d9cded9603386346", "patch": "@@ -154,17 +154,17 @@ fn worker(p: port<request>) {\n \n // Only windows needs to set the library path\n #[cfg(target_os = \"win32\")]\n-fn maybe_with_lib_path<@T>(path: str, f: fn@() -> T) -> T {\n+fn maybe_with_lib_path<T>(path: str, f: fn@() -> T) -> T {\n     with_lib_path(path, f)\n }\n \n #[cfg(target_os = \"linux\")]\n #[cfg(target_os = \"macos\")]\n-fn maybe_with_lib_path<@T>(_path: str, f: fn@() -> T) -> T {\n+fn maybe_with_lib_path<T>(_path: str, f: fn@() -> T) -> T {\n     f()\n }\n \n-fn with_lib_path<@T>(path: str, f: fn@() -> T) -> T {\n+fn with_lib_path<T>(path: str, f: fn@() -> T) -> T {\n     let maybe_oldpath = getenv(util::lib_path_env_var());\n     append_lib_path(path);\n     let res = f();"}, {"sha": "f99bff1cf47832a5eb3edb32d94d4f47e821ebf1", "filename": "src/fuzzer/fuzzer.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cfdf193c4671a11e40743748d9cded9603386346/src%2Ffuzzer%2Ffuzzer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfdf193c4671a11e40743748d9cded9603386346/src%2Ffuzzer%2Ffuzzer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ffuzzer%2Ffuzzer.rs?ref=cfdf193c4671a11e40743748d9cded9603386346", "patch": "@@ -227,7 +227,7 @@ fn check_variants_of_ast(crate: ast::crate, codemap: codemap::codemap,\n     check_variants_T(crate, codemap, filename, \"ty\", stolen.tys, pprust::ty_to_str, replace_ty_in_crate, cx);\n }\n \n-fn check_variants_T<@T>(\n+fn check_variants_T<T>(\n   crate: ast::crate,\n   codemap: codemap::codemap,\n   filename: str,"}, {"sha": "66b1a60f1732e010e5229b2d94b3e82d26514090", "filename": "src/fuzzer/ivec_fuzz.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/cfdf193c4671a11e40743748d9cded9603386346/src%2Ffuzzer%2Fivec_fuzz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfdf193c4671a11e40743748d9cded9603386346/src%2Ffuzzer%2Fivec_fuzz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ffuzzer%2Fivec_fuzz.rs?ref=cfdf193c4671a11e40743748d9cded9603386346", "patch": "@@ -22,22 +22,22 @@ import std::vec::slice;\n import std::vec::len;\n import std::int;\n \n-fn vec_omit<@T>(v: [T], i: uint) -> [T] {\n+fn vec_omit<T>(v: [T], i: uint) -> [T] {\n     slice(v, 0u, i) + slice(v, i + 1u, len(v))\n }\n-fn vec_dup<@T>(v: [T], i: uint) -> [T] {\n+fn vec_dup<T>(v: [T], i: uint) -> [T] {\n     slice(v, 0u, i) + [v[i]] + slice(v, i, len(v))\n }\n-fn vec_swadj<@T>(v: [T], i: uint) -> [T] {\n+fn vec_swadj<T>(v: [T], i: uint) -> [T] {\n     slice(v, 0u, i) + [v[i + 1u], v[i]] + slice(v, i + 2u, len(v))\n }\n-fn vec_prefix<@T>(v: [T], i: uint) -> [T] { slice(v, 0u, i) }\n-fn vec_suffix<@T>(v: [T], i: uint) -> [T] { slice(v, i, len(v)) }\n+fn vec_prefix<T>(v: [T], i: uint) -> [T] { slice(v, 0u, i) }\n+fn vec_suffix<T>(v: [T], i: uint) -> [T] { slice(v, i, len(v)) }\n \n-fn vec_poke<@T>(v: [T], i: uint, x: T) -> [T] {\n+fn vec_poke<T>(v: [T], i: uint, x: T) -> [T] {\n     slice(v, 0u, i) + [x] + slice(v, i + 1u, len(v))\n }\n-fn vec_insert<@T>(v: [T], i: uint, x: T) -> [T] {\n+fn vec_insert<T>(v: [T], i: uint, x: T) -> [T] {\n     slice(v, 0u, i) + [x] + slice(v, i, len(v))\n }\n \n@@ -48,7 +48,7 @@ fn ix(skip_low: uint, skip_high: uint, length: uint, it: block(uint)) {\n }\n \n // Returns a bunch of modified versions of v, some of which introduce new elements (borrowed from xs).\n-fn vec_edits<@T>(v: [T], xs: [T]) -> [[T]] {\n+fn vec_edits<T>(v: [T], xs: [T]) -> [[T]] {\n     let edits: [[T]] = [];\n     let Lv: uint = len(v);\n "}, {"sha": "d59cf06b2a2b92ca6ad133be708e022661c3ffbe", "filename": "src/fuzzer/rand_util.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cfdf193c4671a11e40743748d9cded9603386346/src%2Ffuzzer%2Frand_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfdf193c4671a11e40743748d9cded9603386346/src%2Ffuzzer%2Frand_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ffuzzer%2Frand_util.rs?ref=cfdf193c4671a11e40743748d9cded9603386346", "patch": "@@ -12,7 +12,7 @@ fn choice<T>(r : rand::rng, v : [T]) -> T { assert vec::len(v) != 0u; v[under(r,\n fn unlikely(r : rand::rng, n : uint) -> bool { under(r, n) == 0u }\n \n // shuffle a vec in place\n-fn shuffle<@T>(r : rand::rng, &v : [mutable T]) {\n+fn shuffle<T>(r : rand::rng, &v : [mutable T]) {\n     let i = vec::len(v);\n     while i >= 2u {\n         // Loop invariant: elements with index >= i have been locked in place.\n@@ -22,7 +22,7 @@ fn shuffle<@T>(r : rand::rng, &v : [mutable T]) {\n }\n \n // create a shuffled copy of a vec\n-fn shuffled<@T>(r : rand::rng, v : [T]) -> [T] {\n+fn shuffled<T>(r : rand::rng, v : [T]) -> [T] {\n     let w = vec::to_mut(v);\n     shuffle(r, w);\n     vec::from_mut(w) // Shouldn't this happen automatically?\n@@ -35,7 +35,7 @@ fn shuffled<@T>(r : rand::rng, v : [T]) -> [T] {\n // * weighted_choice is O(number of choices) time\n // * weighted_vec is O(total weight) space\n type weighted<T> = { weight: uint, item: T };\n-fn weighted_choice<@T>(r : rand::rng, v : [weighted<T>]) -> T {\n+fn weighted_choice<T>(r : rand::rng, v : [weighted<T>]) -> T {\n     assert vec::len(v) != 0u;\n     let total = 0u;\n     for {weight: weight, item: _} in v {"}, {"sha": "dbf7bb3df1020b5c7a353381c1a1c25dfb0685f8", "filename": "src/lib/comm.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/cfdf193c4671a11e40743748d9cded9603386346/src%2Flib%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfdf193c4671a11e40743748d9cded9603386346/src%2Flib%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fcomm.rs?ref=cfdf193c4671a11e40743748d9cded9603386346", "patch": "@@ -12,9 +12,9 @@ native \"c-stack-cdecl\" mod rustrt {\n     type void;\n     type rust_port;\n \n-    fn chan_id_send<~T>(t: *sys::type_desc,\n-                        target_task: task::task, target_port: port_id,\n-                        -data: T);\n+    fn chan_id_send<unique T>(t: *sys::type_desc,\n+                              target_task: task::task, target_port: port_id,\n+                              -data: T);\n \n     fn new_port(unit_sz: uint) -> *rust_port;\n     fn del_port(po: *rust_port);\n@@ -23,38 +23,38 @@ native \"c-stack-cdecl\" mod rustrt {\n }\n \n native \"rust-intrinsic\" mod rusti {\n-    fn recv<~T>(port: *rustrt::rust_port) -> T;\n+    fn recv<unique T>(port: *rustrt::rust_port) -> T;\n }\n \n type port_id = int;\n \n // It's critical that this only have one variant, so it has a record\n // layout, and will work in the rust_task structure in task.rs.\n-tag chan<~T> { chan_t(task::task, port_id); }\n+tag chan<unique T> { chan_t(task::task, port_id); }\n \n resource port_ptr(po: *rustrt::rust_port) {\n     rustrt::drop_port(po);\n     rustrt::del_port(po);\n }\n \n-tag port<~T> { port_t(@port_ptr); }\n+tag port<unique T> { port_t(@port_ptr); }\n \n-fn send<~T>(ch: chan<T>, -data: T) {\n+fn send<unique T>(ch: chan<T>, -data: T) {\n     let chan_t(t, p) = ch;\n     rustrt::chan_id_send(sys::get_type_desc::<T>(), t, p, data);\n     task::yield();\n }\n \n-fn port<~T>() -> port<T> {\n+fn port<unique T>() -> port<T> {\n     let p = rustrt::new_port(sys::size_of::<T>());\n     ret port_t(@port_ptr(p));\n }\n \n-fn recv<~T>(p: port<T>) -> T {\n+fn recv<unique T>(p: port<T>) -> T {\n     ret rusti::recv(***p);\n }\n \n-fn chan<~T>(p: port<T>) -> chan<T> {\n+fn chan<unique T>(p: port<T>) -> chan<T> {\n     let id = rustrt::get_port_id(***p);\n     ret chan_t(task::get_task_id(), id);\n }"}, {"sha": "24aa95bfc28ecb15ba024cd4a8ab4170004730b6", "filename": "src/lib/deque.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cfdf193c4671a11e40743748d9cded9603386346/src%2Flib%2Fdeque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfdf193c4671a11e40743748d9cded9603386346/src%2Flib%2Fdeque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fdeque.rs?ref=cfdf193c4671a11e40743748d9cded9603386346", "patch": "@@ -16,7 +16,7 @@ type t<T> =\n         fn get(int) -> T;\n     };\n \n-fn create<@T>() -> t<T> {\n+fn create<T>() -> t<T> {\n     type cell<T> = option::t<T>;\n \n     let initial_capacity: uint = 32u; // 2^5\n@@ -30,7 +30,7 @@ fn create<@T>() -> t<T> {\n \n \n \n-    fn grow<@T>(nelts: uint, lo: uint, elts: [mutable cell<T>]) ->\n+    fn grow<T>(nelts: uint, lo: uint, elts: [mutable cell<T>]) ->\n        [mutable cell<T>] {\n         assert (nelts == vec::len(elts));\n         let rv = [mutable];\n@@ -46,10 +46,10 @@ fn create<@T>() -> t<T> {\n \n         ret rv;\n     }\n-    fn get<@T>(elts: [mutable cell<T>], i: uint) -> T {\n+    fn get<T>(elts: [mutable cell<T>], i: uint) -> T {\n         ret alt elts[i] { option::some(t) { t } _ { fail } };\n     }\n-    obj deque<@T>(mutable nelts: uint,\n+    obj deque<T>(mutable nelts: uint,\n                   mutable lo: uint,\n                   mutable hi: uint,\n                   mutable elts: [mutable cell<T>]) {"}, {"sha": "143f0cabe92d1725dc28e6110a2a419caa97d256", "filename": "src/lib/either.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cfdf193c4671a11e40743748d9cded9603386346/src%2Flib%2Feither.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfdf193c4671a11e40743748d9cded9603386346/src%2Flib%2Feither.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Feither.rs?ref=cfdf193c4671a11e40743748d9cded9603386346", "patch": "@@ -10,23 +10,23 @@ fn either<T, U,\n     alt value { left(l) { f_left(l) } right(r) { f_right(r) } }\n }\n \n-fn lefts<@T, U>(eithers: [t<T, U>]) -> [T] {\n+fn lefts<T, U>(eithers: [t<T, U>]) -> [T] {\n     let result: [T] = [];\n     for elt: t<T, U> in eithers {\n         alt elt { left(l) { result += [l]; } _ {/* fallthrough */ } }\n     }\n     ret result;\n }\n \n-fn rights<T, @U>(eithers: [t<T, U>]) -> [U] {\n+fn rights<T, U>(eithers: [t<T, U>]) -> [U] {\n     let result: [U] = [];\n     for elt: t<T, U> in eithers {\n         alt elt { right(r) { result += [r]; } _ {/* fallthrough */ } }\n     }\n     ret result;\n }\n \n-fn partition<@T, @U>(eithers: [t<T, U>]) -> {lefts: [T], rights: [U]} {\n+fn partition<T, U>(eithers: [t<T, U>]) -> {lefts: [T], rights: [U]} {\n     let lefts: [T] = [];\n     let rights: [U] = [];\n     for elt: t<T, U> in eithers {"}, {"sha": "4a65d6191de598bae1ce6538d888726ef01c6493", "filename": "src/lib/fun_treemap.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/cfdf193c4671a11e40743748d9cded9603386346/src%2Flib%2Ffun_treemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfdf193c4671a11e40743748d9cded9603386346/src%2Flib%2Ffun_treemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Ffun_treemap.rs?ref=cfdf193c4671a11e40743748d9cded9603386346", "patch": "@@ -19,16 +19,16 @@ export insert;\n export find;\n export traverse;\n \n-tag tree_node<@K, @V> {\n+tag tree_node<K, V> {\n     empty;\n     node(@K, @V, @tree_node<K, V>, @tree_node<K, V>);\n }\n \n-type treemap<@K, @V> = @tree_node<K, V>;\n+type treemap<K, V> = @tree_node<K, V>;\n \n-fn init<@K, @V>() -> treemap<K, V> { @empty }\n+fn init<K, V>() -> treemap<K, V> { @empty }\n \n-fn insert<@K, @V>(m: treemap<K, V>, k: K, v: V) -> treemap<K, V> {\n+fn insert<K, V>(m: treemap<K, V>, k: K, v: V) -> treemap<K, V> {\n     @alt m {\n        @empty. { node(@k, @v, @empty, @empty) }\n        @node(@kk, vv, left, right) {\n@@ -41,7 +41,7 @@ fn insert<@K, @V>(m: treemap<K, V>, k: K, v: V) -> treemap<K, V> {\n      }\n }\n \n-fn find<@K, @V>(m: treemap<K, V>, k: K) -> option<V> {\n+fn find<K, V>(m: treemap<K, V>, k: K) -> option<V> {\n     alt *m {\n       empty. { none }\n       node(@kk, @v, left, right) {\n@@ -54,7 +54,7 @@ fn find<@K, @V>(m: treemap<K, V>, k: K) -> option<V> {\n \n \n // Performs an in-order traversal\n-fn traverse<@K, @V>(m: treemap<K, V>, f: fn(K, V)) {\n+fn traverse<K, V>(m: treemap<K, V>, f: fn(K, V)) {\n     alt *m {\n       empty. { }\n       node(@k, @v, _, _) {"}, {"sha": "0bacf29d03d43e0d8ca8546ffe822ce3a351ba03", "filename": "src/lib/list.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/cfdf193c4671a11e40743748d9cded9603386346/src%2Flib%2Flist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfdf193c4671a11e40743748d9cded9603386346/src%2Flib%2Flist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Flist.rs?ref=cfdf193c4671a11e40743748d9cded9603386346", "patch": "@@ -2,7 +2,7 @@ import option::{some, none};\n \n tag list<T> { cons(T, @list<T>); nil; }\n \n-fn from_vec<@T>(v: [T]) -> list<T> {\n+fn from_vec<T>(v: [T]) -> list<T> {\n     let l = nil::<T>;\n     // FIXME: This would be faster and more space efficient if it looped over\n     // a reverse vector iterator. Unfortunately generic iterators seem not to\n@@ -12,7 +12,7 @@ fn from_vec<@T>(v: [T]) -> list<T> {\n     ret l;\n }\n \n-fn foldl<@T, @U>(ls_: list<T>, u: U, f: block(T, U) -> U) -> U {\n+fn foldl<T, U>(ls_: list<T>, u: U, f: block(T, U) -> U) -> U {\n     let accum: U = u;\n     let ls = ls_;\n     while true {\n@@ -24,7 +24,7 @@ fn foldl<@T, @U>(ls_: list<T>, u: U, f: block(T, U) -> U) -> U {\n     ret accum;\n }\n \n-fn find<@T, @U>(ls_: list<T>, f: block(T) -> option::t<U>) -> option::t<U> {\n+fn find<T, U>(ls_: list<T>, f: block(T) -> option::t<U>) -> option::t<U> {\n     let ls = ls_;\n     while true {\n         alt ls {\n@@ -37,7 +37,7 @@ fn find<@T, @U>(ls_: list<T>, f: block(T) -> option::t<U>) -> option::t<U> {\n     ret none;\n }\n \n-fn has<@T>(ls_: list<T>, elt: T) -> bool {\n+fn has<T>(ls_: list<T>, elt: T) -> bool {\n     let ls = ls_;\n     while true {\n         alt ls {\n@@ -48,20 +48,20 @@ fn has<@T>(ls_: list<T>, elt: T) -> bool {\n     ret false;\n }\n \n-fn length<@T>(ls: list<T>) -> uint {\n+fn length<T>(ls: list<T>) -> uint {\n     fn count<T>(_t: T, &&u: uint) -> uint { ret u + 1u; }\n     ret foldl(ls, 0u, bind count(_, _));\n }\n \n-fn cdr<@T>(ls: list<T>) -> list<T> {\n+fn cdr<T>(ls: list<T>) -> list<T> {\n     alt ls { cons(_, tl) { ret *tl; } nil. { fail \"list empty\" } }\n }\n \n-fn car<@T>(ls: list<T>) -> T {\n+fn car<T>(ls: list<T>) -> T {\n     alt ls { cons(hd, _) { ret hd; } nil. { fail \"list empty\" } }\n }\n \n-fn append<@T>(l: list<T>, m: list<T>) -> list<T> {\n+fn append<T>(l: list<T>, m: list<T>) -> list<T> {\n     alt l {\n       nil. { ret m; }\n       cons(x, xs) { let rest = append(*xs, m); ret cons(x, @rest); }"}, {"sha": "88d190922808a649fd78a572e55771b22ab7f87b", "filename": "src/lib/map.rs", "status": "modified", "additions": 16, "deletions": 19, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/cfdf193c4671a11e40743748d9cded9603386346/src%2Flib%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfdf193c4671a11e40743748d9cded9603386346/src%2Flib%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fmap.rs?ref=cfdf193c4671a11e40743748d9cded9603386346", "patch": "@@ -20,14 +20,14 @@ type hashmap<K, V> =\n     };\n type hashset<K> = hashmap<K, ()>;\n \n-fn set_add<@K>(set: hashset<K>, key: K) -> bool { ret set.insert(key, ()); }\n+fn set_add<K>(set: hashset<K>, key: K) -> bool { ret set.insert(key, ()); }\n \n-fn mk_hashmap<@K, @V>(hasher: hashfn<K>, eqer: eqfn<K>) -> hashmap<K, V> {\n+fn mk_hashmap<K, V>(hasher: hashfn<K>, eqer: eqfn<K>) -> hashmap<K, V> {\n     let initial_capacity: uint = 32u; // 2^5\n \n     let load_factor: util::rational = {num: 3, den: 4};\n-    tag bucket<@K, @V> { nil; deleted; some(K, V); }\n-    fn make_buckets<@K, @V>(nbkts: uint) -> [mutable bucket<K, V>] {\n+    tag bucket<K, V> { nil; deleted; some(K, V); }\n+    fn make_buckets<K, V>(nbkts: uint) -> [mutable bucket<K, V>] {\n         ret vec::init_elt_mut::<bucket<K, V>>(nil::<K, V>, nbkts);\n     }\n     // Derive two hash functions from the one given by taking the upper\n@@ -54,10 +54,9 @@ fn mk_hashmap<@K, @V>(hasher: hashfn<K>, eqer: eqfn<K>) -> hashmap<K, V> {\n      * will fail.\n      */\n \n-    fn insert_common<@K,\n-                     @V>(hasher: hashfn<K>, eqer: eqfn<K>,\n-                         bkts: [mutable bucket<K, V>], nbkts: uint, key: K,\n-                         val: V) -> bool {\n+    fn insert_common<K, V>(hasher: hashfn<K>, eqer: eqfn<K>,\n+                           bkts: [mutable bucket<K, V>], nbkts: uint, key: K,\n+                           val: V) -> bool {\n         let i: uint = 0u;\n         let h: uint = hasher(key);\n         while i < nbkts {\n@@ -75,9 +74,8 @@ fn mk_hashmap<@K, @V>(hasher: hashfn<K>, eqer: eqfn<K>) -> hashmap<K, V> {\n         }\n         fail; // full table\n     }\n-    fn find_common<@K,\n-                   @V>(hasher: hashfn<K>, eqer: eqfn<K>,\n-                       bkts: [mutable bucket<K, V>], nbkts: uint, key: K) ->\n+    fn find_common<K, V>(hasher: hashfn<K>, eqer: eqfn<K>,\n+                         bkts: [mutable bucket<K, V>], nbkts: uint, key: K) ->\n        option::t<V> {\n         let i: uint = 0u;\n         let h: uint = hasher(key);\n@@ -97,10 +95,9 @@ fn mk_hashmap<@K, @V>(hasher: hashfn<K>, eqer: eqfn<K>) -> hashmap<K, V> {\n         }\n         ret option::none;\n     }\n-    fn rehash<@K,\n-              @V>(hasher: hashfn<K>, eqer: eqfn<K>,\n-                  oldbkts: [mutable bucket<K, V>], _noldbkts: uint,\n-                  newbkts: [mutable bucket<K, V>], nnewbkts: uint) {\n+    fn rehash<K, V>(hasher: hashfn<K>, eqer: eqfn<K>,\n+                    oldbkts: [mutable bucket<K, V>], _noldbkts: uint,\n+                    newbkts: [mutable bucket<K, V>], nnewbkts: uint) {\n         for b: bucket<K, V> in oldbkts {\n             alt b {\n               some(k_, v_) {\n@@ -112,7 +109,7 @@ fn mk_hashmap<@K, @V>(hasher: hashfn<K>, eqer: eqfn<K>) -> hashmap<K, V> {\n             }\n         }\n     }\n-    obj hashmap<@K, @V>(hasher: hashfn<K>,\n+    obj hashmap<K, V>(hasher: hashfn<K>,\n                     eqer: eqfn<K>,\n                     mutable bkts: [mutable bucket<K, V>],\n                     mutable nbkts: uint,\n@@ -199,17 +196,17 @@ fn mk_hashmap<@K, @V>(hasher: hashfn<K>, eqer: eqfn<K>) -> hashmap<K, V> {\n \n // Hash map constructors for basic types\n \n-fn new_str_hash<@V>() -> hashmap<str, V> {\n+fn new_str_hash<V>() -> hashmap<str, V> {\n     ret mk_hashmap(str::hash, str::eq);\n }\n \n-fn new_int_hash<@V>() -> hashmap<int, V> {\n+fn new_int_hash<V>() -> hashmap<int, V> {\n     fn hash_int(&&x: int) -> uint { ret x as uint; }\n     fn eq_int(&&a: int, &&b: int) -> bool { ret a == b; }\n     ret mk_hashmap(hash_int, eq_int);\n }\n \n-fn new_uint_hash<@V>() -> hashmap<uint, V> {\n+fn new_uint_hash<V>() -> hashmap<uint, V> {\n     fn hash_uint(&&x: uint) -> uint { ret x; }\n     fn eq_uint(&&a: uint, &&b: uint) -> bool { ret a == b; }\n     ret mk_hashmap(hash_uint, eq_uint);"}, {"sha": "0b69b78d031d82de2456472dd2b0476d879af4bb", "filename": "src/lib/math.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cfdf193c4671a11e40743748d9cded9603386346/src%2Flib%2Fmath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfdf193c4671a11e40743748d9cded9603386346/src%2Flib%2Fmath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fmath.rs?ref=cfdf193c4671a11e40743748d9cded9603386346", "patch": "@@ -18,5 +18,5 @@ fn atan(x: float) -> float { llvm::atan(x) }\n \n const pi: float = 3.141592653589793;\n \n-fn min<@T>(x: T, y: T) -> T { x < y ? x : y }\n-fn max<@T>(x: T, y: T) -> T { x < y ? y : x }\n+fn min<T>(x: T, y: T) -> T { x < y ? x : y }\n+fn max<T>(x: T, y: T) -> T { x < y ? y : x }"}, {"sha": "50240c3087b4e51b34000d73ca806ab65bb7aa58", "filename": "src/lib/option.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/cfdf193c4671a11e40743748d9cded9603386346/src%2Flib%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfdf193c4671a11e40743748d9cded9603386346/src%2Flib%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Foption.rs?ref=cfdf193c4671a11e40743748d9cded9603386346", "patch": "@@ -1,31 +1,31 @@\n // lib/option::rs\n \n-tag t<@T> { none; some(T); }\n+tag t<T> { none; some(T); }\n \n-fn get<@T>(opt: t<T>) -> &T {\n+fn get<T>(opt: t<T>) -> &T {\n     alt opt { some(x) { ret x; } none. { fail \"option none\"; } }\n }\n \n-fn map<@T, @U>(f: block(T) -> U, opt: t<T>) -> t<U> {\n+fn map<T, U>(f: block(T) -> U, opt: t<T>) -> t<U> {\n     alt opt { some(x) { some(f(x)) } none. { none } }\n }\n \n-fn is_none<@T>(opt: t<T>) -> bool {\n+fn is_none<T>(opt: t<T>) -> bool {\n     alt opt { none. { true } some(_) { false } }\n }\n \n-fn is_some<@T>(opt: t<T>) -> bool { !is_none(opt) }\n+fn is_some<T>(opt: t<T>) -> bool { !is_none(opt) }\n \n-fn from_maybe<@T>(def: T, opt: t<T>) -> T {\n+fn from_maybe<T>(def: T, opt: t<T>) -> T {\n     alt opt { some(x) { x } none. { def } }\n }\n \n-fn maybe<@T, @U>(def: U, f: block(T) -> U, opt: t<T>) -> U {\n+fn maybe<T, U>(def: U, f: block(T) -> U, opt: t<T>) -> U {\n     alt opt { none. { def } some(t) { f(t) } }\n }\n \n // Can be defined in terms of the above when/if we have const bind.\n-fn may<@T>(f: block(T), opt: t<T>) {\n+fn may<T>(f: block(T), opt: t<T>) {\n     alt opt { none. {/* nothing */ } some(t) { f(t); } }\n }\n "}, {"sha": "8d730732c3cd6d8cd04284cfef0c9786979e1348", "filename": "src/lib/ptr.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cfdf193c4671a11e40743748d9cded9603386346/src%2Flib%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfdf193c4671a11e40743748d9cded9603386346/src%2Flib%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fptr.rs?ref=cfdf193c4671a11e40743748d9cded9603386346", "patch": "@@ -5,9 +5,9 @@ native \"rust-intrinsic\" mod rusti {\n     fn ptr_offset<T>(ptr: *T, count: uint) -> *T;\n }\n \n-fn addr_of<@T>(val: T) -> *mutable T { ret rusti::addr_of(val); }\n-fn offset<@T>(ptr: *T, count: uint) -> *T {\n+fn addr_of<T>(val: T) -> *mutable T { ret rusti::addr_of(val); }\n+fn offset<T>(ptr: *T, count: uint) -> *T {\n     ret rusti::ptr_offset(ptr, count);\n }\n \n-fn null<@T>() -> *T { ret unsafe::reinterpret_cast(0u); }\n+fn null<T>() -> *T { ret unsafe::reinterpret_cast(0u); }"}, {"sha": "b70c03ad1d5cbe4980b473b68bde8154bd32366c", "filename": "src/lib/smallintmap.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/cfdf193c4671a11e40743748d9cded9603386346/src%2Flib%2Fsmallintmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfdf193c4671a11e40743748d9cded9603386346/src%2Flib%2Fsmallintmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fsmallintmap.rs?ref=cfdf193c4671a11e40743748d9cded9603386346", "patch": "@@ -8,32 +8,32 @@ import option::{some, none};\n // to be.\n type smallintmap<T> = @{mutable v: [mutable option::t<T>]};\n \n-fn mk<@T>() -> smallintmap<T> {\n+fn mk<T>() -> smallintmap<T> {\n     let v: [mutable option::t<T>] = [mutable];\n     ret @{mutable v: v};\n }\n \n-fn insert<@T>(m: smallintmap<T>, key: uint, val: T) {\n+fn insert<T>(m: smallintmap<T>, key: uint, val: T) {\n     vec::grow_set::<option::t<T>>(m.v, key, none::<T>, some::<T>(val));\n }\n \n-fn find<@T>(m: smallintmap<T>, key: uint) -> option::t<T> {\n+fn find<T>(m: smallintmap<T>, key: uint) -> option::t<T> {\n     if key < vec::len::<option::t<T>>(m.v) { ret m.v[key]; }\n     ret none::<T>;\n }\n \n-fn get<@T>(m: smallintmap<T>, key: uint) -> T {\n+fn get<T>(m: smallintmap<T>, key: uint) -> T {\n     alt find::<T>(m, key) {\n       none::<T>. { log_err \"smallintmap::get(): key not present\"; fail; }\n       some::<T>(v) { ret v; }\n     }\n }\n \n-fn contains_key<@T>(m: smallintmap<T>, key: uint) -> bool {\n+fn contains_key<T>(m: smallintmap<T>, key: uint) -> bool {\n     ret !option::is_none(find::<T>(m, key));\n }\n \n-fn truncate<@T>(m: smallintmap<T>, len: uint) {\n+fn truncate<T>(m: smallintmap<T>, len: uint) {\n     m.v = vec::slice_mut::<option::t<T>>(m.v, 0u, len);\n }\n "}, {"sha": "a70505e4847b501fbb1ecc92bf20d78ec8b38688", "filename": "src/lib/sort.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/cfdf193c4671a11e40743748d9cded9603386346/src%2Flib%2Fsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfdf193c4671a11e40743748d9cded9603386346/src%2Flib%2Fsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fsort.rs?ref=cfdf193c4671a11e40743748d9cded9603386346", "patch": "@@ -7,8 +7,8 @@ export quick_sort3;\n \n type lteq<T> = block(T, T) -> bool;\n \n-fn merge_sort<@T>(le: lteq<T>, v: [T]) -> [T] {\n-    fn merge<@T>(le: lteq<T>, a: [T], b: [T]) -> [T] {\n+fn merge_sort<T>(le: lteq<T>, v: [T]) -> [T] {\n+    fn merge<T>(le: lteq<T>, a: [T], b: [T]) -> [T] {\n         let rs: [T] = [];\n         let a_len: uint = len::<T>(a);\n         let a_ix: uint = 0u;\n@@ -32,13 +32,13 @@ fn merge_sort<@T>(le: lteq<T>, v: [T]) -> [T] {\n     ret merge::<T>(le, merge_sort::<T>(le, a), merge_sort::<T>(le, b));\n }\n \n-fn swap<@T>(arr: [mutable T], x: uint, y: uint) {\n+fn swap<T>(arr: [mutable T], x: uint, y: uint) {\n     let a = arr[x];\n     arr[x] = arr[y];\n     arr[y] = a;\n }\n \n-fn part<@T>(compare_func: lteq<T>, arr: [mutable T], left: uint, right: uint,\n+fn part<T>(compare_func: lteq<T>, arr: [mutable T], left: uint, right: uint,\n             pivot: uint) -> uint {\n     let pivot_value = arr[pivot];\n     swap::<T>(arr, pivot, right);\n@@ -55,7 +55,7 @@ fn part<@T>(compare_func: lteq<T>, arr: [mutable T], left: uint, right: uint,\n     ret storage_index;\n }\n \n-fn qsort<@T>(compare_func: lteq<T>, arr: [mutable T], left: uint,\n+fn qsort<T>(compare_func: lteq<T>, arr: [mutable T], left: uint,\n              right: uint) {\n     if right > left {\n         let pivot = (left + right) / 2u;\n@@ -68,7 +68,7 @@ fn qsort<@T>(compare_func: lteq<T>, arr: [mutable T], left: uint,\n     }\n }\n \n-fn quick_sort<@T>(compare_func: lteq<T>, arr: [mutable T]) {\n+fn quick_sort<T>(compare_func: lteq<T>, arr: [mutable T]) {\n     if len::<T>(arr) == 0u { ret; }\n     qsort::<T>(compare_func, arr, 0u, len::<T>(arr) - 1u);\n }\n@@ -78,7 +78,7 @@ fn quick_sort<@T>(compare_func: lteq<T>, arr: [mutable T]) {\n // http://www.cs.princeton.edu/~rs/talks/QuicksortIsOptimal.pdf\n // According to these slides this is the algorithm of choice for\n // 'randomly ordered keys, abstract compare' & 'small number of key values'\n-fn qsort3<@T>(compare_func_lt: lteq<T>, compare_func_eq: lteq<T>,\n+fn qsort3<T>(compare_func_lt: lteq<T>, compare_func_eq: lteq<T>,\n               arr: [mutable T], left: int, right: int) {\n     if right <= left { ret; }\n     let v: T = arr[right];\n@@ -126,8 +126,8 @@ fn qsort3<@T>(compare_func_lt: lteq<T>, compare_func_eq: lteq<T>,\n     qsort3::<T>(compare_func_lt, compare_func_eq, arr, i, right);\n }\n \n-fn quick_sort3<@T>(compare_func_lt: lteq<T>, compare_func_eq: lteq<T>,\n-                   arr: [mutable T]) {\n+fn quick_sort3<T>(compare_func_lt: lteq<T>, compare_func_eq: lteq<T>,\n+                  arr: [mutable T]) {\n     if len::<T>(arr) == 0u { ret; }\n     qsort3::<T>(compare_func_lt, compare_func_eq, arr, 0,\n                 (len::<T>(arr) as int) - 1);"}, {"sha": "0a44026ea52b542e911a3bd43b146c7ff69a1282", "filename": "src/lib/task.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/cfdf193c4671a11e40743748d9cded9603386346/src%2Flib%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfdf193c4671a11e40743748d9cded9603386346/src%2Flib%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Ftask.rs?ref=cfdf193c4671a11e40743748d9cded9603386346", "patch": "@@ -95,16 +95,16 @@ fn unpin() { rustrt2::unpin_task(); }\n \n fn set_min_stack(stack_size: uint) { rustrt2::set_min_stack(stack_size); }\n \n-fn spawn<~T>(-data: T, f: fn(T)) -> task {\n+fn spawn<unique T>(-data: T, f: fn(T)) -> task {\n     spawn_inner2(data, f, none)\n }\n \n-fn spawn_notify<~T>(-data: T, f: fn(T),\n+fn spawn_notify<unique T>(-data: T, f: fn(T),\n                          notify: comm::chan<task_notification>) -> task {\n     spawn_inner2(data, f, some(notify))\n }\n \n-fn spawn_joinable<~T>(-data: T, f: fn(T)) -> joinable_task {\n+fn spawn_joinable<unique T>(-data: T, f: fn(T)) -> joinable_task {\n     let p = comm::port::<task_notification>();\n     let id = spawn_notify(data, f, comm::chan::<task_notification>(p));\n     ret (id, p);\n@@ -120,11 +120,11 @@ fn spawn_joinable<~T>(-data: T, f: fn(T)) -> joinable_task {\n //\n // After the transition this should all be rewritten.\n \n-fn spawn_inner2<~T>(-data: T, f: fn(T),\n-                    notify: option<comm::chan<task_notification>>)\n+fn spawn_inner2<unique T>(-data: T, f: fn(T),\n+                          notify: option<comm::chan<task_notification>>)\n     -> task_id {\n \n-    fn wrapper<~T>(-data: *u8, f: fn(T)) {\n+    fn wrapper<unique T>(-data: *u8, f: fn(T)) {\n         let data: ~T = unsafe::reinterpret_cast(data);\n         f(*data);\n     }"}, {"sha": "8c76d397d95828f2b9678d6bd68a6f762c3d1ada", "filename": "src/lib/test.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/cfdf193c4671a11e40743748d9cded9603386346/src%2Flib%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfdf193c4671a11e40743748d9cded9603386346/src%2Flib%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Ftest.rs?ref=cfdf193c4671a11e40743748d9cded9603386346", "patch": "@@ -41,13 +41,13 @@ type test_name = str;\n // the test succeeds; if the function fails then the test fails. We\n // may need to come up with a more clever definition of test in order\n // to support isolation of tests into tasks.\n-type test_fn<@T> = T;\n+type test_fn<T> = T;\n \n type default_test_fn = test_fn<fn()>;\n \n // The definition of a single test. A test runner will run a list of\n // these.\n-type test_desc<@T> = {\n+type test_desc<T> = {\n     name: test_name,\n     fn: test_fn<T>,\n     ignore: bool\n@@ -100,15 +100,15 @@ type joinable = (task, comm::port<task::task_notification>);\n // In cases where test functions are closures it is not ok to just dump them\n // into a task and run them, so this transformation gives the caller a chance\n // to create the test task.\n-type test_to_task<@T> = fn@(test_fn<T>) -> joinable;\n+type test_to_task<T> = fn@(test_fn<T>) -> joinable;\n \n // A simple console test runner\n fn run_tests_console(opts: test_opts,\n                          tests: [test_desc<default_test_fn>]) -> bool {\n     run_tests_console_(opts, tests, default_test_to_task)\n }\n \n-fn run_tests_console_<@T>(opts: test_opts, tests: [test_desc<T>],\n+fn run_tests_console_<T>(opts: test_opts, tests: [test_desc<T>],\n                           to_task: test_to_task<T>) -> bool {\n \n     type test_state =\n@@ -120,7 +120,7 @@ fn run_tests_console_<@T>(opts: test_opts, tests: [test_desc<T>],\n           mutable ignored: uint,\n           mutable failures: [test_desc<T>]};\n \n-    fn callback<@T>(event: testevent<T>, st: test_state) {\n+    fn callback<T>(event: testevent<T>, st: test_state) {\n         alt event {\n           te_filtered(filtered_tests) {\n             st.total = vec::len(filtered_tests);\n@@ -207,13 +207,13 @@ fn run_tests_console_<@T>(opts: test_opts, tests: [test_desc<T>],\n \n fn use_color() -> bool { ret get_concurrency() == 1u; }\n \n-tag testevent<@T> {\n+tag testevent<T> {\n     te_filtered([test_desc<T>]);\n     te_wait(test_desc<T>);\n     te_result(test_desc<T>, test_result);\n }\n \n-fn run_tests<@T>(opts: test_opts, tests: [test_desc<T>],\n+fn run_tests<T>(opts: test_opts, tests: [test_desc<T>],\n                  to_task: test_to_task<T>,\n                  callback: fn@(testevent<T>)) {\n \n@@ -248,7 +248,7 @@ fn run_tests<@T>(opts: test_opts, tests: [test_desc<T>],\n \n fn get_concurrency() -> uint { rustrt::sched_threads() }\n \n-fn filter_tests<@T>(opts: test_opts,\n+fn filter_tests<T>(opts: test_opts,\n                     tests: [test_desc<T>]) -> [test_desc<T>] {\n     let filtered = tests;\n \n@@ -262,7 +262,7 @@ fn filter_tests<@T>(opts: test_opts,\n           option::none. { \"\" }\n         };\n \n-        fn filter_fn<@T>(test: test_desc<T>, filter_str: str) ->\n+        fn filter_fn<T>(test: test_desc<T>, filter_str: str) ->\n             option::t<test_desc<T>> {\n             if str::find(test.name, filter_str) >= 0 {\n                 ret option::some(test);\n@@ -278,7 +278,7 @@ fn filter_tests<@T>(opts: test_opts,\n     filtered = if !opts.run_ignored {\n         filtered\n     } else {\n-        fn filter<@T>(test: test_desc<T>) -> option::t<test_desc<T>> {\n+        fn filter<T>(test: test_desc<T>) -> option::t<test_desc<T>> {\n             if test.ignore {\n                 ret option::some({name: test.name,\n                                   fn: test.fn,\n@@ -292,7 +292,7 @@ fn filter_tests<@T>(opts: test_opts,\n     // Sort the tests alphabetically\n     filtered =\n         {\n-            fn lteq<@T>(t1: test_desc<T>, t2: test_desc<T>) -> bool {\n+            fn lteq<T>(t1: test_desc<T>, t2: test_desc<T>) -> bool {\n                 str::lteq(t1.name, t2.name)\n             }\n             sort::merge_sort(bind lteq(_, _), filtered)\n@@ -301,9 +301,9 @@ fn filter_tests<@T>(opts: test_opts,\n     ret filtered;\n }\n \n-type test_future<@T> = {test: test_desc<T>, wait: fn@() -> test_result};\n+type test_future<T> = {test: test_desc<T>, wait: fn@() -> test_result};\n \n-fn run_test<@T>(test: test_desc<T>,\n+fn run_test<T>(test: test_desc<T>,\n                 to_task: test_to_task<T>) -> test_future<T> {\n     if !test.ignore {\n         let test_task = to_task(test.fn);"}, {"sha": "a361bd20cdb26e9ab6cffdd4d8fd44ba6f77bf85", "filename": "src/lib/treemap.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/cfdf193c4671a11e40743748d9cded9603386346/src%2Flib%2Ftreemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfdf193c4671a11e40743748d9cded9603386346/src%2Flib%2Ftreemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Ftreemap.rs?ref=cfdf193c4671a11e40743748d9cded9603386346", "patch": "@@ -16,13 +16,13 @@ export insert;\n export find;\n export traverse;\n \n-tag tree_node<@K, @V> { empty; node(@K, @V, treemap<K, V>, treemap<K, V>); }\n+tag tree_node<K, V> { empty; node(@K, @V, treemap<K, V>, treemap<K, V>); }\n \n-type treemap<@K, @V> = @mutable tree_node<K, V>;\n+type treemap<K, V> = @mutable tree_node<K, V>;\n \n-fn init<@K, @V>() -> treemap<K, V> { @mutable empty }\n+fn init<K, V>() -> treemap<K, V> { @mutable empty }\n \n-fn insert<@K, @V>(m: treemap<K, V>, k: K, v: V) {\n+fn insert<K, V>(m: treemap<K, V>, k: K, v: V) {\n     alt m {\n       @empty. { *m = node(@k, @v, @mutable empty, @mutable empty); }\n       @node(@kk, _, _, _) {\n@@ -36,7 +36,7 @@ fn insert<@K, @V>(m: treemap<K, V>, k: K, v: V) {\n     }\n }\n \n-fn find<@K, @V>(m: treemap<K, V>, k: K) -> option<V> {\n+fn find<K, V>(m: treemap<K, V>, k: K) -> option<V> {\n     alt *m {\n       empty. { none }\n       node(@kk, @v, _, _) {\n@@ -52,7 +52,7 @@ fn find<@K, @V>(m: treemap<K, V>, k: K) -> option<V> {\n }\n \n // Performs an in-order traversal\n-fn traverse<@K, @V>(m: treemap<K, V>, f: fn@(K, V)) {\n+fn traverse<K, V>(m: treemap<K, V>, f: fn@(K, V)) {\n     alt *m {\n       empty. { }\n       node(k, v, _, _) {"}, {"sha": "5194392d1bee149b58055c5fd6e61899f2ca84a2", "filename": "src/lib/unsafe.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cfdf193c4671a11e40743748d9cded9603386346/src%2Flib%2Funsafe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfdf193c4671a11e40743748d9cded9603386346/src%2Flib%2Funsafe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Funsafe.rs?ref=cfdf193c4671a11e40743748d9cded9603386346", "patch": "@@ -5,10 +5,10 @@ native \"rust-intrinsic\" mod rusti {\n }\n \n native \"c-stack-cdecl\" mod rustrt {\n-    fn leak<@T>(-thing: T);\n+    fn leak<T>(-thing: T);\n }\n \n // Casts the value at `src` to U. The two types must have the same length.\n-fn reinterpret_cast<T, @U>(src: T) -> U { ret rusti::cast(src); }\n+fn reinterpret_cast<T, U>(src: T) -> U { ret rusti::cast(src); }\n \n-fn leak<@T>(-thing: T) { rustrt::leak(thing); }\n+fn leak<T>(-thing: T) { rustrt::leak(thing); }"}, {"sha": "3c441f1656fc02c44f33ab94b33bd69cb2982821", "filename": "src/lib/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cfdf193c4671a11e40743748d9cded9603386346/src%2Flib%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfdf193c4671a11e40743748d9cded9603386346/src%2Flib%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Futil.rs?ref=cfdf193c4671a11e40743748d9cded9603386346", "patch": "@@ -1,5 +1,5 @@\n \n-pure fn id<@T>(x: T) -> T { x }\n+pure fn id<T>(x: T) -> T { x }\n \n fn unreachable() -> ! {\n     fail \"Internal error: entered unreachable code\";"}, {"sha": "e0184767e9d20aa1ec3476ef942b94d522f4ef89", "filename": "src/lib/vec.rs", "status": "modified", "additions": 37, "deletions": 37, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/cfdf193c4671a11e40743748d9cded9603386346/src%2Flib%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfdf193c4671a11e40743748d9cded9603386346/src%2Flib%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fvec.rs?ref=cfdf193c4671a11e40743748d9cded9603386346", "patch": "@@ -18,15 +18,15 @@ native \"c-stack-cdecl\" mod rustrt {\n }\n \n /// Reserves space for `n` elements in the given vector.\n-fn reserve<@T>(&v: [mutable? T], n: uint) {\n+fn reserve<T>(&v: [mutable? T], n: uint) {\n     rustrt::vec_reserve_shared(sys::get_type_desc::<T>(), v, n);\n }\n \n pure fn len<T>(v: [mutable? T]) -> uint { unchecked { rusti::vec_len(v) } }\n \n type init_op<T> = fn@(uint) -> T;\n \n-fn init_fn<@T>(op: init_op<T>, n_elts: uint) -> [T] {\n+fn init_fn<T>(op: init_op<T>, n_elts: uint) -> [T] {\n     let v = [];\n     reserve(v, n_elts);\n     let i: uint = 0u;\n@@ -35,15 +35,15 @@ fn init_fn<@T>(op: init_op<T>, n_elts: uint) -> [T] {\n }\n \n // TODO: Remove me once we have slots.\n-fn init_fn_mut<@T>(op: init_op<T>, n_elts: uint) -> [mutable T] {\n+fn init_fn_mut<T>(op: init_op<T>, n_elts: uint) -> [mutable T] {\n     let v = [mutable];\n     reserve(v, n_elts);\n     let i: uint = 0u;\n     while i < n_elts { v += [mutable op(i)]; i += 1u; }\n     ret v;\n }\n \n-fn init_elt<@T>(t: T, n_elts: uint) -> [T] {\n+fn init_elt<T>(t: T, n_elts: uint) -> [T] {\n     let v = [];\n     reserve(v, n_elts);\n     let i: uint = 0u;\n@@ -52,7 +52,7 @@ fn init_elt<@T>(t: T, n_elts: uint) -> [T] {\n }\n \n // TODO: Remove me once we have slots.\n-fn init_elt_mut<@T>(t: T, n_elts: uint) -> [mutable T] {\n+fn init_elt_mut<T>(t: T, n_elts: uint) -> [mutable T] {\n     let v = [mutable];\n     reserve(v, n_elts);\n     let i: uint = 0u;\n@@ -62,14 +62,14 @@ fn init_elt_mut<@T>(t: T, n_elts: uint) -> [mutable T] {\n \n // FIXME: Possible typestate postcondition:\n // len(result) == len(v) (needs issue #586)\n-fn to_mut<@T>(v: [T]) -> [mutable T] {\n+fn to_mut<T>(v: [T]) -> [mutable T] {\n     let vres = [mutable];\n     for t: T in v { vres += [mutable t]; }\n     ret vres;\n }\n \n // Same comment as from_mut\n-fn from_mut<@T>(v: [mutable T]) -> [T] {\n+fn from_mut<T>(v: [mutable T]) -> [T] {\n     let vres = [];\n     for t: T in v { vres += [t]; }\n     ret vres;\n@@ -87,26 +87,26 @@ pure fn is_not_empty<T>(v: [mutable? T]) -> bool { ret !is_empty(v); }\n // Accessors\n \n /// Returns the first element of a vector\n-fn head<@T>(v: [mutable? T]) : is_not_empty(v) -> T { ret v[0]; }\n+fn head<T>(v: [mutable? T]) : is_not_empty(v) -> T { ret v[0]; }\n \n /// Returns all but the first element of a vector\n-fn tail<@T>(v: [mutable? T]) : is_not_empty(v) -> [T] {\n+fn tail<T>(v: [mutable? T]) : is_not_empty(v) -> [T] {\n     ret slice(v, 1u, len(v));\n }\n \n /// Returns the last element of `v`.\n-fn last<@T>(v: [mutable? T]) -> option::t<T> {\n+fn last<T>(v: [mutable? T]) -> option::t<T> {\n     if len(v) == 0u { ret none; }\n     ret some(v[len(v) - 1u]);\n }\n \n /// Returns the last element of a non-empty vector `v`.\n-fn last_total<@T>(v: [mutable? T]) : is_not_empty(v) -> T {\n+fn last_total<T>(v: [mutable? T]) : is_not_empty(v) -> T {\n     ret v[len(v) - 1u];\n }\n \n /// Returns a copy of the elements from [`start`..`end`) from `v`.\n-fn slice<@T>(v: [mutable? T], start: uint, end: uint) -> [T] {\n+fn slice<T>(v: [mutable? T], start: uint, end: uint) -> [T] {\n     assert (start <= end);\n     assert (end <= len(v));\n     let result = [];\n@@ -117,7 +117,7 @@ fn slice<@T>(v: [mutable? T], start: uint, end: uint) -> [T] {\n }\n \n // TODO: Remove me once we have slots.\n-fn slice_mut<@T>(v: [mutable? T], start: uint, end: uint) -> [mutable T] {\n+fn slice_mut<T>(v: [mutable? T], start: uint, end: uint) -> [mutable T] {\n     assert (start <= end);\n     assert (end <= len(v));\n     let result = [mutable];\n@@ -130,7 +130,7 @@ fn slice_mut<@T>(v: [mutable? T], start: uint, end: uint) -> [mutable T] {\n \n // Mutators\n \n-fn shift<@T>(&v: [mutable? T]) -> T {\n+fn shift<T>(&v: [mutable? T]) -> T {\n     let ln = len::<T>(v);\n     assert (ln > 0u);\n     let e = v[0];\n@@ -139,7 +139,7 @@ fn shift<@T>(&v: [mutable? T]) -> T {\n }\n \n // TODO: Write this, unsafely, in a way that's not O(n).\n-fn pop<@T>(&v: [mutable? T]) -> T {\n+fn pop<T>(&v: [mutable? T]) -> T {\n     let ln = len(v);\n     assert (ln > 0u);\n     ln -= 1u;\n@@ -154,22 +154,22 @@ fn pop<@T>(&v: [mutable? T]) -> T {\n // Appending\n \n /// Expands the given vector in-place by appending `n` copies of `initval`.\n-fn grow<@T>(&v: [T], n: uint, initval: T) {\n+fn grow<T>(&v: [T], n: uint, initval: T) {\n     reserve(v, next_power_of_two(len(v) + n));\n     let i: uint = 0u;\n     while i < n { v += [initval]; i += 1u; }\n }\n \n // TODO: Remove me once we have slots.\n-fn grow_mut<@T>(&v: [mutable T], n: uint, initval: T) {\n+fn grow_mut<T>(&v: [mutable T], n: uint, initval: T) {\n     reserve(v, next_power_of_two(len(v) + n));\n     let i: uint = 0u;\n     while i < n { v += [mutable initval]; i += 1u; }\n }\n \n /// Calls `f` `n` times and appends the results of these calls to the given\n /// vector.\n-fn grow_fn<@T>(&v: [T], n: uint, init_fn: fn(uint) -> T) {\n+fn grow_fn<T>(&v: [T], n: uint, init_fn: fn(uint) -> T) {\n     reserve(v, next_power_of_two(len(v) + n));\n     let i: uint = 0u;\n     while i < n { v += [init_fn(i)]; i += 1u; }\n@@ -178,15 +178,15 @@ fn grow_fn<@T>(&v: [T], n: uint, init_fn: fn(uint) -> T) {\n /// Sets the element at position `index` to `val`. If `index` is past the end\n /// of the vector, expands the vector by replicating `initval` to fill the\n /// intervening space.\n-fn grow_set<@T>(&v: [mutable T], index: uint, initval: T, val: T) {\n+fn grow_set<T>(&v: [mutable T], index: uint, initval: T, val: T) {\n     if index >= len(v) { grow_mut(v, index - len(v) + 1u, initval); }\n     v[index] = val;\n }\n \n \n // Functional utilities\n \n-fn map<@T, @U>(f: block(T) -> U, v: [mutable? T]) -> [U] {\n+fn map<T, U>(f: block(T) -> U, v: [mutable? T]) -> [U] {\n     let result = [];\n     reserve(result, len(v));\n     for elem: T in v {\n@@ -196,7 +196,7 @@ fn map<@T, @U>(f: block(T) -> U, v: [mutable? T]) -> [U] {\n     ret result;\n }\n \n-fn map2<@T, @U, @V>(f: block(T, U) -> V, v0: [T], v1: [U]) -> [V] {\n+fn map2<T, U, V>(f: block(T, U) -> V, v0: [T], v1: [U]) -> [V] {\n     let v0_len = len::<T>(v0);\n     if v0_len != len::<U>(v1) { fail; }\n     let u: [V] = [];\n@@ -205,7 +205,7 @@ fn map2<@T, @U, @V>(f: block(T, U) -> V, v0: [T], v1: [U]) -> [V] {\n     ret u;\n }\n \n-fn filter_map<@T, @U>(f: block(T) -> option::t<U>, v: [mutable? T]) -> [U] {\n+fn filter_map<T, U>(f: block(T) -> option::t<U>, v: [mutable? T]) -> [U] {\n     let result = [];\n     for elem: T in v {\n         let elem2 = elem; // satisfies alias checker\n@@ -217,7 +217,7 @@ fn filter_map<@T, @U>(f: block(T) -> option::t<U>, v: [mutable? T]) -> [U] {\n     ret result;\n }\n \n-fn filter<@T>(f: block(T) -> bool, v: [mutable? T]) -> [T] {\n+fn filter<T>(f: block(T) -> bool, v: [mutable? T]) -> [T] {\n     let result = [];\n     for elem: T in v {\n         let elem2 = elem; // satisfies alias checker\n@@ -228,7 +228,7 @@ fn filter<@T>(f: block(T) -> bool, v: [mutable? T]) -> [T] {\n     ret result;\n }\n \n-fn foldl<@T, @U>(p: block(U, T) -> U, z: U, v: [mutable? T]) -> U {\n+fn foldl<T, U>(p: block(U, T) -> U, z: U, v: [mutable? T]) -> U {\n     let sz = len(v);\n     if sz == 0u { ret z; }\n     let first = v[0];\n@@ -257,12 +257,12 @@ fn count<T>(x: T, v: [mutable? T]) -> uint {\n     ret cnt;\n }\n \n-fn find<@T>(f: block(T) -> bool, v: [T]) -> option::t<T> {\n+fn find<T>(f: block(T) -> bool, v: [T]) -> option::t<T> {\n     for elt: T in v { if f(elt) { ret some(elt); } }\n     ret none;\n }\n \n-fn position<@T>(x: T, v: [T]) -> option::t<uint> {\n+fn position<T>(x: T, v: [T]) -> option::t<uint> {\n     let i: uint = 0u;\n     while i < len(v) { if x == v[i] { ret some::<uint>(i); } i += 1u; }\n     ret none;\n@@ -282,13 +282,13 @@ pure fn same_length<T, U>(xs: [T], ys: [U]) -> bool {\n // saying the two result lists have the same length -- or, could\n // return a nominal record with a constraint saying that, instead of\n // returning a tuple (contingent on issue #869)\n-fn unzip<@T, @U>(v: [(T, U)]) -> ([T], [U]) {\n+fn unzip<T, U>(v: [(T, U)]) -> ([T], [U]) {\n     let as = [], bs = [];\n     for (a, b) in v { as += [a]; bs += [b]; }\n     ret (as, bs);\n }\n \n-fn zip<@T, @U>(v: [T], u: [U]) : same_length(v, u) -> [(T, U)] {\n+fn zip<T, U>(v: [T], u: [U]) : same_length(v, u) -> [(T, U)] {\n     let zipped = [];\n     let sz = len(v), i = 0u;\n     assert (sz == len(u));\n@@ -297,22 +297,22 @@ fn zip<@T, @U>(v: [T], u: [U]) : same_length(v, u) -> [(T, U)] {\n }\n \n // Swaps two elements in a vector\n-fn swap<@T>(v: [mutable T], a: uint, b: uint) {\n+fn swap<T>(v: [mutable T], a: uint, b: uint) {\n     let t: T = v[a];\n     v[a] = v[b];\n     v[b] = t;\n }\n \n // In place vector reversal\n-fn reverse<@T>(v: [mutable T]) {\n+fn reverse<T>(v: [mutable T]) {\n     let i: uint = 0u;\n     let ln = len::<T>(v);\n     while i < ln / 2u { swap(v, i, ln - i - 1u); i += 1u; }\n }\n \n \n // Functional vector reversal. Returns a reversed copy of v.\n-fn reversed<@T>(v: [T]) -> [T] {\n+fn reversed<T>(v: [T]) -> [T] {\n     let rs: [T] = [];\n     let i = len::<T>(v);\n     if i == 0u { ret rs; } else { i -= 1u; }\n@@ -336,7 +336,7 @@ fn enum_uints(start: uint, end: uint) : uint::le(start, end) -> [uint] {\n     ret r;\n }\n \n-fn eachi<@T>(f: block(T, uint) -> (), v: [mutable? T]) {\n+fn eachi<T>(f: block(T, uint) -> (), v: [mutable? T]) {\n     let i = 0u;\n     let l = len(v);\n     while (i < l) {\n@@ -347,31 +347,31 @@ fn eachi<@T>(f: block(T, uint) -> (), v: [mutable? T]) {\n }\n \n // Iterate over a list with with the indexes\n-fn iter2<@T>(v: [T], it: block(uint, T)) {\n+fn iter2<T>(v: [T], it: block(uint, T)) {\n     let i = 0u;\n     for x in v { it(i, x); i += 1u; }\n }\n \n mod unsafe {\n     type vec_repr = {mutable fill: uint, mutable alloc: uint, data: u8};\n \n-    unsafe fn from_buf<@T>(ptr: *T, elts: uint) -> [T] {\n+    unsafe fn from_buf<T>(ptr: *T, elts: uint) -> [T] {\n         ret rustrt::vec_from_buf_shared(sys::get_type_desc::<T>(),\n                                         ptr, elts);\n     }\n \n-    unsafe fn set_len<@T>(&v: [T], new_len: uint) {\n+    unsafe fn set_len<T>(&v: [T], new_len: uint) {\n         let repr: **vec_repr = ::unsafe::reinterpret_cast(addr_of(v));\n         (**repr).fill = new_len * sys::size_of::<T>();\n     }\n \n-    unsafe fn to_ptr<@T>(v: [T]) -> *T {\n+    unsafe fn to_ptr<T>(v: [T]) -> *T {\n         let repr: **vec_repr = ::unsafe::reinterpret_cast(addr_of(v));\n         ret ::unsafe::reinterpret_cast(addr_of((**repr).data));\n     }\n }\n \n-unsafe fn to_ptr<@T>(v: [T]) -> *T { ret unsafe::to_ptr(v); }\n+unsafe fn to_ptr<T>(v: [T]) -> *T { ret unsafe::to_ptr(v); }\n \n // Local Variables:\n // mode: rust;"}, {"sha": "d2c6b5f5a5d9d4ec3e51bfeb3369336ead84256e", "filename": "src/test/bench/task-perf-word-count-generic.rs", "status": "modified", "additions": 23, "deletions": 19, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/cfdf193c4671a11e40743748d9cded9603386346/src%2Ftest%2Fbench%2Ftask-perf-word-count-generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfdf193c4671a11e40743748d9cded9603386346/src%2Ftest%2Fbench%2Ftask-perf-word-count-generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-word-count-generic.rs?ref=cfdf193c4671a11e40743748d9cded9603386346", "patch": "@@ -55,25 +55,25 @@ mod map_reduce {\n     export reducer;\n     export map_reduce;\n \n-    type putter<~K, ~V> = fn(K, V);\n+    type putter<unique K, unique V> = fn(K, V);\n \n     // FIXME: the first K1 parameter should probably be a -, but that\n     // doesn't parse at the moment.\n-    type mapper<~K1, ~K2, ~V> = fn(K1, putter<K2, V>);\n+    type mapper<unique K1, unique K2, unique V> = fn(K1, putter<K2, V>);\n \n-    type getter<~V> = fn() -> option<V>;\n+    type getter<unique V> = fn() -> option<V>;\n \n-    type reducer<~K, ~V> = fn(K, getter<V>);\n+    type reducer<unique K, unique V> = fn(K, getter<V>);\n \n-    tag ctrl_proto<~K, ~V> {\n+    tag ctrl_proto<unique K, unique V> {\n         find_reducer(K, chan<chan<reduce_proto<V>>>);\n         mapper_done;\n     }\n \n-    tag reduce_proto<~V> { emit_val(V); done; ref; release; }\n+    tag reduce_proto<unique V> { emit_val(V); done; ref; release; }\n \n-    fn start_mappers<~K1, ~K2,\n-                     ~V>(map: mapper<K1, K2, V>,\n+    fn start_mappers<unique K1, unique K2,\n+                     unique V>(map: mapper<K1, K2, V>,\n                          ctrl: chan<ctrl_proto<K2, V>>, inputs: [K1]) ->\n        [joinable_task] {\n         let tasks = [];\n@@ -84,14 +84,15 @@ mod map_reduce {\n         ret tasks;\n     }\n \n-    fn map_task<~K1, ~K2,\n-                ~V>(-map: mapper<K1, K2, V>, -ctrl: chan<ctrl_proto<K2, V>>,\n+    fn map_task<unique K1, unique K2,\n+                unique V>(-map: mapper<K1, K2, V>,\n+                          -ctrl: chan<ctrl_proto<K2, V>>,\n                     -input: K1) {\n         // log_err \"map_task \" + input;\n         let intermediates = treemap::init();\n \n-        fn emit<~K2,\n-                ~V>(im: treemap::treemap<K2, chan<reduce_proto<V>>>,\n+        fn emit<unique K2,\n+                unique V>(im: treemap::treemap<K2, chan<reduce_proto<V>>>,\n                     ctrl: chan<ctrl_proto<K2, V>>, key: K2, val: V) {\n             let c;\n             alt treemap::find(im, key) {\n@@ -109,15 +110,15 @@ mod map_reduce {\n \n         map(input, bind emit(intermediates, ctrl, _, _));\n \n-        fn finish<~K, ~V>(_k: K, v: chan<reduce_proto<V>>) {\n+        fn finish<unique K, unique V>(_k: K, v: chan<reduce_proto<V>>) {\n             send(v, release);\n         }\n         treemap::traverse(intermediates, finish);\n         send(ctrl, mapper_done);\n     }\n \n-    fn reduce_task<~K,\n-                   ~V>(-reduce: reducer<K, V>, -key: K,\n+    fn reduce_task<unique K,\n+                   unique V>(-reduce: reducer<K, V>, -key: K,\n                        -out: chan<chan<reduce_proto<V>>>) {\n         let p = port();\n \n@@ -126,7 +127,8 @@ mod map_reduce {\n         let ref_count = 0;\n         let is_done = false;\n \n-        fn get<~V>(p: port<reduce_proto<V>>, &ref_count: int, &is_done: bool)\n+        fn get<unique V>(p: port<reduce_proto<V>>,\n+                         &ref_count: int, &is_done: bool)\n            -> option<V> {\n             while !is_done || ref_count > 0 {\n                 alt recv(p) {\n@@ -148,8 +150,8 @@ mod map_reduce {\n         reduce(key, bind get(p, ref_count, is_done));\n     }\n \n-    fn map_reduce<~K1, ~K2,\n-                  ~V>(map: mapper<K1, K2, V>, reduce: reducer<K2, V>,\n+    fn map_reduce<unique K1, unique K2,\n+                  unique V>(map: mapper<K1, K2, V>, reduce: reducer<K2, V>,\n                       inputs: [K1]) {\n         let ctrl = port();\n \n@@ -192,7 +194,9 @@ mod map_reduce {\n             }\n         }\n \n-        fn finish<~K, ~V>(_k: K, v: chan<reduce_proto<V>>) { send(v, done); }\n+        fn finish<unique K, unique V>(_k: K, v: chan<reduce_proto<V>>) {\n+            send(v, done);\n+        }\n         treemap::traverse(reducers, finish);\n \n         for t in tasks { task::join(t); }"}, {"sha": "e217866882925be86a2bfad8297c1a9bf647d605", "filename": "src/test/compile-fail/unique-unique-kind.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cfdf193c4671a11e40743748d9cded9603386346/src%2Ftest%2Fcompile-fail%2Funique-unique-kind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfdf193c4671a11e40743748d9cded9603386346/src%2Ftest%2Fcompile-fail%2Funique-unique-kind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funique-unique-kind.rs?ref=cfdf193c4671a11e40743748d9cded9603386346", "patch": "@@ -1,6 +1,6 @@\n // error-pattern: needed unique type\n \n-fn f<~T>(i: T) {\n+fn f<unique T>(i: T) {\n }\n \n fn main() {"}, {"sha": "dd077da48138f507f902bf44f52b1f5849b6fd2b", "filename": "src/test/compile-fail/unique-vec-res.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cfdf193c4671a11e40743748d9cded9603386346/src%2Ftest%2Fcompile-fail%2Funique-vec-res.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfdf193c4671a11e40743748d9cded9603386346/src%2Ftest%2Fcompile-fail%2Funique-vec-res.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funique-vec-res.rs?ref=cfdf193c4671a11e40743748d9cded9603386346", "patch": "@@ -4,7 +4,7 @@ resource r(i: @mutable int) {\n     *i = *i + 1;\n }\n \n-fn f<@T>(i: [T], j: [T]) {\n+fn f<T>(i: [T], j: [T]) {\n     // Shouldn't be able to do this copy of j\n     let k = i + j;\n }"}, {"sha": "2a38a5f6d04d93213bbbd33ca8c115e764ef4083", "filename": "src/test/compile-fail/use-after-send.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cfdf193c4671a11e40743748d9cded9603386346/src%2Ftest%2Fcompile-fail%2Fuse-after-send.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfdf193c4671a11e40743748d9cded9603386346/src%2Ftest%2Fcompile-fail%2Fuse-after-send.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fuse-after-send.rs?ref=cfdf193c4671a11e40743748d9cded9603386346", "patch": "@@ -1,5 +1,5 @@\n // error-pattern: Unsatisfied precondition constraint\n-fn send<~T>(ch: _chan<T>, -data: T) { log ch; log data; fail; }\n+fn send<unique T>(ch: _chan<T>, -data: T) { log ch; log data; fail; }\n type _chan<T> = int;\n \n // Tests that \"log message;\" is flagged as using"}, {"sha": "92e9062534af50c5158c231152efe2e3ce3dae40", "filename": "src/test/run-fail/bug-811.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cfdf193c4671a11e40743748d9cded9603386346/src%2Ftest%2Frun-fail%2Fbug-811.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfdf193c4671a11e40743748d9cded9603386346/src%2Ftest%2Frun-fail%2Fbug-811.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fbug-811.rs?ref=cfdf193c4671a11e40743748d9cded9603386346", "patch": "@@ -4,8 +4,8 @@ fn test00_start(ch: chan_t<int>, message: int) { send(ch, message); }\n type task_id = int;\n type port_id = int;\n \n-type chan_t<~T> = {task: task_id, port: port_id};\n+type chan_t<unique T> = {task: task_id, port: port_id};\n \n-fn send<~T>(ch: chan_t<T>, -data: T) { fail; }\n+fn send<unique T>(ch: chan_t<T>, -data: T) { fail; }\n \n fn main() { fail \"quux\"; }"}, {"sha": "a648f0b560a5ac881b1e9fa229375eb622be5ca2", "filename": "src/test/run-fail/port-type.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cfdf193c4671a11e40743748d9cded9603386346/src%2Ftest%2Frun-fail%2Fport-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfdf193c4671a11e40743748d9cded9603386346/src%2Ftest%2Frun-fail%2Fport-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fport-type.rs?ref=cfdf193c4671a11e40743748d9cded9603386346", "patch": "@@ -5,7 +5,7 @@ import std::comm::port;\n import std::comm::send;\n import std::comm::recv;\n \n-fn echo<~T>(c: chan<T>, oc: chan<chan<T>>) {\n+fn echo<unique T>(c: chan<T>, oc: chan<chan<T>>) {\n     // Tests that the type argument in port gets\n     // visited\n     let p = port::<T>();"}, {"sha": "6077bbf6723b8a98065f2f742000c97551c3e18a", "filename": "src/test/run-pass/alloca-from-derived-tydesc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cfdf193c4671a11e40743748d9cded9603386346/src%2Ftest%2Frun-pass%2Falloca-from-derived-tydesc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfdf193c4671a11e40743748d9cded9603386346/src%2Ftest%2Frun-pass%2Falloca-from-derived-tydesc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Falloca-from-derived-tydesc.rs?ref=cfdf193c4671a11e40743748d9cded9603386346", "patch": "@@ -2,6 +2,6 @@ tag option<T> { some(T); none; }\n \n type r<T> = {mutable v: [option<T>]};\n \n-fn f<@T>() -> [T] { ret []; }\n+fn f<T>() -> [T] { ret []; }\n \n fn main() { let r: r<int> = {mutable v: []}; r.v = f(); }"}, {"sha": "4900df4aed00e3a4ac4a4898045ccf2d893e9bfe", "filename": "src/test/run-pass/auto-instantiate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cfdf193c4671a11e40743748d9cded9603386346/src%2Ftest%2Frun-pass%2Fauto-instantiate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfdf193c4671a11e40743748d9cded9603386346/src%2Ftest%2Frun-pass%2Fauto-instantiate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fauto-instantiate.rs?ref=cfdf193c4671a11e40743748d9cded9603386346", "patch": "@@ -2,6 +2,6 @@\n \n \n // -*- rust -*-\n-fn f<@T, @U>(x: T, y: U) -> {a: T, b: U} { ret {a: x, b: y}; }\n+fn f<T, U>(x: T, y: U) -> {a: T, b: U} { ret {a: x, b: y}; }\n \n fn main() { log f({x: 3, y: 4, z: 5}, 4).a.x; log f(5, 6).a; }"}, {"sha": "dc875c3133d49a023ca156dde5b80dbbee435f59", "filename": "src/test/run-pass/autobind.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cfdf193c4671a11e40743748d9cded9603386346/src%2Ftest%2Frun-pass%2Fautobind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfdf193c4671a11e40743748d9cded9603386346/src%2Ftest%2Frun-pass%2Fautobind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fautobind.rs?ref=cfdf193c4671a11e40743748d9cded9603386346", "patch": "@@ -2,7 +2,7 @@\n // because it would have to convert them to shared closures\n // xfail-test\n \n-fn f<@T>(x: [T]) -> T { ret x[0]; }\n+fn f<T>(x: [T]) -> T { ret x[0]; }\n \n fn g(act: fn([int]) -> int) -> int { ret act([1, 2, 3]); }\n "}, {"sha": "5dc0c670dca17b9852f85c1787d7a7db1fe3ae23", "filename": "src/test/run-pass/box-unbox.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cfdf193c4671a11e40743748d9cded9603386346/src%2Ftest%2Frun-pass%2Fbox-unbox.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfdf193c4671a11e40743748d9cded9603386346/src%2Ftest%2Frun-pass%2Fbox-unbox.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbox-unbox.rs?ref=cfdf193c4671a11e40743748d9cded9603386346", "patch": "@@ -2,7 +2,7 @@\n \n type box<T> = {c: @T};\n \n-fn unbox<@T>(b: box<T>) -> T { ret *b.c; }\n+fn unbox<T>(b: box<T>) -> T { ret *b.c; }\n \n fn main() {\n     let foo: int = 17;"}, {"sha": "53cab4546e22a4063c4e9e9ecd79f891eb2df11e", "filename": "src/test/run-pass/expr-alt-generic-box2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cfdf193c4671a11e40743748d9cded9603386346/src%2Ftest%2Frun-pass%2Fexpr-alt-generic-box2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfdf193c4671a11e40743748d9cded9603386346/src%2Ftest%2Frun-pass%2Fexpr-alt-generic-box2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-alt-generic-box2.rs?ref=cfdf193c4671a11e40743748d9cded9603386346", "patch": "@@ -4,7 +4,7 @@\n // -*- rust -*-\n type compare<T> = fn@(T, T) -> bool;\n \n-fn test_generic<@T>(expected: T, eq: compare<T>) {\n+fn test_generic<T>(expected: T, eq: compare<T>) {\n     let actual: T = alt true { true { expected } };\n     assert (eq(expected, actual));\n }"}, {"sha": "e8b949e9410dc570a1e16ac58b4bc53b57633899", "filename": "src/test/run-pass/expr-alt-generic-unique1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cfdf193c4671a11e40743748d9cded9603386346/src%2Ftest%2Frun-pass%2Fexpr-alt-generic-unique1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfdf193c4671a11e40743748d9cded9603386346/src%2Ftest%2Frun-pass%2Fexpr-alt-generic-unique1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-alt-generic-unique1.rs?ref=cfdf193c4671a11e40743748d9cded9603386346", "patch": "@@ -3,7 +3,7 @@\n // -*- rust -*-\n type compare<T> = fn@(~T, ~T) -> bool;\n \n-fn test_generic<@T>(expected: ~T, eq: compare<T>) {\n+fn test_generic<T>(expected: ~T, eq: compare<T>) {\n     let actual: ~T = alt true { true { expected } };\n     assert (eq(expected, actual));\n }"}, {"sha": "ee0be17ffa26ac892a6f46b9cc68ffbbaaa3aea6", "filename": "src/test/run-pass/expr-alt-generic-unique2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cfdf193c4671a11e40743748d9cded9603386346/src%2Ftest%2Frun-pass%2Fexpr-alt-generic-unique2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfdf193c4671a11e40743748d9cded9603386346/src%2Ftest%2Frun-pass%2Fexpr-alt-generic-unique2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-alt-generic-unique2.rs?ref=cfdf193c4671a11e40743748d9cded9603386346", "patch": "@@ -4,7 +4,7 @@\n // -*- rust -*-\n type compare<T> = fn@(T, T) -> bool;\n \n-fn test_generic<@T>(expected: T, eq: compare<T>) {\n+fn test_generic<T>(expected: T, eq: compare<T>) {\n     let actual: T = alt true { true { expected } };\n     assert (eq(expected, actual));\n }"}, {"sha": "c3df90f7fdc32f7487ee0a882da22ad0f6fc2d17", "filename": "src/test/run-pass/expr-alt-generic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cfdf193c4671a11e40743748d9cded9603386346/src%2Ftest%2Frun-pass%2Fexpr-alt-generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfdf193c4671a11e40743748d9cded9603386346/src%2Ftest%2Frun-pass%2Fexpr-alt-generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-alt-generic.rs?ref=cfdf193c4671a11e40743748d9cded9603386346", "patch": "@@ -4,7 +4,7 @@\n // -*- rust -*-\n type compare<T> = fn@(T, T) -> bool;\n \n-fn test_generic<@T>(expected: T, eq: compare<T>) {\n+fn test_generic<T>(expected: T, eq: compare<T>) {\n     let actual: T = alt true { true { expected } };\n     assert (eq(expected, actual));\n }"}, {"sha": "9a54cd20a8b26cc701a8a150e2d084ca9d1cdb69", "filename": "src/test/run-pass/expr-block-generic-box2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cfdf193c4671a11e40743748d9cded9603386346/src%2Ftest%2Frun-pass%2Fexpr-block-generic-box2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfdf193c4671a11e40743748d9cded9603386346/src%2Ftest%2Frun-pass%2Fexpr-block-generic-box2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-block-generic-box2.rs?ref=cfdf193c4671a11e40743748d9cded9603386346", "patch": "@@ -4,7 +4,7 @@\n // -*- rust -*-\n type compare<T> = fn@(T, T) -> bool;\n \n-fn test_generic<@T>(expected: T, eq: compare<T>) {\n+fn test_generic<T>(expected: T, eq: compare<T>) {\n     let actual: T = { expected };\n     assert (eq(expected, actual));\n }"}, {"sha": "1055cd16221e14a94424bdfa3efb2165079f10c3", "filename": "src/test/run-pass/expr-block-generic-unique1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cfdf193c4671a11e40743748d9cded9603386346/src%2Ftest%2Frun-pass%2Fexpr-block-generic-unique1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfdf193c4671a11e40743748d9cded9603386346/src%2Ftest%2Frun-pass%2Fexpr-block-generic-unique1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-block-generic-unique1.rs?ref=cfdf193c4671a11e40743748d9cded9603386346", "patch": "@@ -3,7 +3,7 @@\n // -*- rust -*-\n type compare<T> = fn@(~T, ~T) -> bool;\n \n-fn test_generic<@T>(expected: ~T, eq: compare<T>) {\n+fn test_generic<T>(expected: ~T, eq: compare<T>) {\n     let actual: ~T = { expected };\n     assert (eq(expected, actual));\n }"}, {"sha": "3325c8f2384bc2fa17b7394fc45e314526d35ebb", "filename": "src/test/run-pass/expr-block-generic-unique2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cfdf193c4671a11e40743748d9cded9603386346/src%2Ftest%2Frun-pass%2Fexpr-block-generic-unique2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfdf193c4671a11e40743748d9cded9603386346/src%2Ftest%2Frun-pass%2Fexpr-block-generic-unique2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-block-generic-unique2.rs?ref=cfdf193c4671a11e40743748d9cded9603386346", "patch": "@@ -4,7 +4,7 @@\n // -*- rust -*-\n type compare<T> = fn@(T, T) -> bool;\n \n-fn test_generic<@T>(expected: T, eq: compare<T>) {\n+fn test_generic<T>(expected: T, eq: compare<T>) {\n     let actual: T = { expected };\n     assert (eq(expected, actual));\n }"}, {"sha": "8e270a56edd982a34f37056ec8ea60b0a78752a9", "filename": "src/test/run-pass/expr-block-generic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cfdf193c4671a11e40743748d9cded9603386346/src%2Ftest%2Frun-pass%2Fexpr-block-generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfdf193c4671a11e40743748d9cded9603386346/src%2Ftest%2Frun-pass%2Fexpr-block-generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-block-generic.rs?ref=cfdf193c4671a11e40743748d9cded9603386346", "patch": "@@ -6,7 +6,7 @@\n // Tests for standalone blocks as expressions with dynamic type sizes\n type compare<T> = fn@(T, T) -> bool;\n \n-fn test_generic<@T>(expected: T, eq: compare<T>) {\n+fn test_generic<T>(expected: T, eq: compare<T>) {\n     let actual: T = { expected };\n     assert (eq(expected, actual));\n }"}, {"sha": "549d3a69aead9d9eaeabf8e0f759da4fe97b6d14", "filename": "src/test/run-pass/expr-if-generic-box2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cfdf193c4671a11e40743748d9cded9603386346/src%2Ftest%2Frun-pass%2Fexpr-if-generic-box2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfdf193c4671a11e40743748d9cded9603386346/src%2Ftest%2Frun-pass%2Fexpr-if-generic-box2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-if-generic-box2.rs?ref=cfdf193c4671a11e40743748d9cded9603386346", "patch": "@@ -4,7 +4,7 @@\n // -*- rust -*-\n type compare<T> = fn@(T, T) -> bool;\n \n-fn test_generic<@T>(expected: T, not_expected: T, eq: compare<T>) {\n+fn test_generic<T>(expected: T, not_expected: T, eq: compare<T>) {\n     let actual: T = if true { expected } else { not_expected };\n     assert (eq(expected, actual));\n }"}, {"sha": "b2b62523e556f24d213c8f209478d091af2798fd", "filename": "src/test/run-pass/expr-if-generic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cfdf193c4671a11e40743748d9cded9603386346/src%2Ftest%2Frun-pass%2Fexpr-if-generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfdf193c4671a11e40743748d9cded9603386346/src%2Ftest%2Frun-pass%2Fexpr-if-generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-if-generic.rs?ref=cfdf193c4671a11e40743748d9cded9603386346", "patch": "@@ -6,7 +6,7 @@\n // Tests for if as expressions with dynamic type sizes\n type compare<T> = fn@(T, T) -> bool;\n \n-fn test_generic<@T>(expected: T, not_expected: T, eq: compare<T>) {\n+fn test_generic<T>(expected: T, not_expected: T, eq: compare<T>) {\n     let actual: T = if true { expected } else { not_expected };\n     assert (eq(expected, actual));\n }"}, {"sha": "a9686c83645188fa17445912f5d2c3ae4ff35b73", "filename": "src/test/run-pass/fixed-point-bind-box.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cfdf193c4671a11e40743748d9cded9603386346/src%2Ftest%2Frun-pass%2Ffixed-point-bind-box.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfdf193c4671a11e40743748d9cded9603386346/src%2Ftest%2Frun-pass%2Ffixed-point-bind-box.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ffixed-point-bind-box.rs?ref=cfdf193c4671a11e40743748d9cded9603386346", "patch": "@@ -1,8 +1,8 @@\n-fn fix_help<A, @B>(f: fn(fn@(A) -> B, A) -> B, x: A) -> B {\n+fn fix_help<A, B>(f: fn(fn@(A) -> B, A) -> B, x: A) -> B {\n     ret f(bind fix_help(f, _), x);\n }\n \n-fn fix<A, @B>(f: fn(fn@(A) -> B, A) -> B) -> fn@(A) -> B {\n+fn fix<A, B>(f: fn(fn@(A) -> B, A) -> B) -> fn@(A) -> B {\n     ret bind fix_help(f, _);\n }\n "}, {"sha": "9e14ab19228e218726846b28e9dbc319d3a08f35", "filename": "src/test/run-pass/fixed-point-bind-unique.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cfdf193c4671a11e40743748d9cded9603386346/src%2Ftest%2Frun-pass%2Ffixed-point-bind-unique.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfdf193c4671a11e40743748d9cded9603386346/src%2Ftest%2Frun-pass%2Ffixed-point-bind-unique.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ffixed-point-bind-unique.rs?ref=cfdf193c4671a11e40743748d9cded9603386346", "patch": "@@ -1,8 +1,8 @@\n-fn fix_help<A, ~B>(f: fn(fn@(A) -> B, A) -> B, x: A) -> B {\n+fn fix_help<A, unique B>(f: fn(fn@(A) -> B, A) -> B, x: A) -> B {\n     ret f(bind fix_help(f, _), x);\n }\n \n-fn fix<A, ~B>(f: fn(fn@(A) -> B, A) -> B) -> fn@(A) -> B {\n+fn fix<A, unique B>(f: fn(fn@(A) -> B, A) -> B) -> fn@(A) -> B {\n     ret bind fix_help(f, _);\n }\n "}, {"sha": "19c59529870d00d503a3454665a240d613919451", "filename": "src/test/run-pass/fn-bare-spawn.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cfdf193c4671a11e40743748d9cded9603386346/src%2Ftest%2Frun-pass%2Ffn-bare-spawn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfdf193c4671a11e40743748d9cded9603386346/src%2Ftest%2Frun-pass%2Ffn-bare-spawn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ffn-bare-spawn.rs?ref=cfdf193c4671a11e40743748d9cded9603386346", "patch": "@@ -1,6 +1,6 @@\n // This is what the signature to spawn should look like with bare functions\n \n-fn spawn<~T>(val: T, f: fn(T)) {\n+fn spawn<unique T>(val: T, f: fn(T)) {\n     f(val);\n }\n "}, {"sha": "bd33b4bbc51bfb31ad652bce282ae88cf09b245c", "filename": "src/test/run-pass/foreach-unique-drop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cfdf193c4671a11e40743748d9cded9603386346/src%2Ftest%2Frun-pass%2Fforeach-unique-drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfdf193c4671a11e40743748d9cded9603386346/src%2Ftest%2Frun-pass%2Fforeach-unique-drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fforeach-unique-drop.rs?ref=cfdf193c4671a11e40743748d9cded9603386346", "patch": "@@ -1,5 +1,5 @@\n \n-obj ob<@K>(k: K) {\n+obj ob<K>(k: K) {\n     fn foo(it: block(~{a: K})) { it(~{a: k}); }\n }\n "}, {"sha": "9624eca31acc2f1ae11bb6ae3e87dc4adf3a31c9", "filename": "src/test/run-pass/generic-alias-box.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cfdf193c4671a11e40743748d9cded9603386346/src%2Ftest%2Frun-pass%2Fgeneric-alias-box.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfdf193c4671a11e40743748d9cded9603386346/src%2Ftest%2Frun-pass%2Fgeneric-alias-box.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgeneric-alias-box.rs?ref=cfdf193c4671a11e40743748d9cded9603386346", "patch": "@@ -1,6 +1,6 @@\n \n \n-fn id<@T>(t: T) -> T { ret t; }\n+fn id<T>(t: T) -> T { ret t; }\n \n fn main() {\n     let expected = @100;"}, {"sha": "dbcbdcfae1a947ab6461bcff150d1bb0aa779e48", "filename": "src/test/run-pass/generic-alias-unique.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cfdf193c4671a11e40743748d9cded9603386346/src%2Ftest%2Frun-pass%2Fgeneric-alias-unique.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfdf193c4671a11e40743748d9cded9603386346/src%2Ftest%2Frun-pass%2Fgeneric-alias-unique.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgeneric-alias-unique.rs?ref=cfdf193c4671a11e40743748d9cded9603386346", "patch": "@@ -1,6 +1,6 @@\n \n \n-fn id<~T>(t: T) -> T { ret t; }\n+fn id<unique T>(t: T) -> T { ret t; }\n \n fn main() {\n     let expected = ~100;"}, {"sha": "8b03cc68f0f1650c76c4af2755db7c4c8afbf113", "filename": "src/test/run-pass/generic-bind-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cfdf193c4671a11e40743748d9cded9603386346/src%2Ftest%2Frun-pass%2Fgeneric-bind-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfdf193c4671a11e40743748d9cded9603386346/src%2Ftest%2Frun-pass%2Fgeneric-bind-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgeneric-bind-2.rs?ref=cfdf193c4671a11e40743748d9cded9603386346", "patch": "@@ -1,6 +1,6 @@\n \n \n-fn id<@T>(t: T) -> T { ret t; }\n+fn id<T>(t: T) -> T { ret t; }\n \n fn main() {\n     let t = {a: 1, b: 2, c: 3, d: 4, e: 5, f: 6, g: 7};"}, {"sha": "47e0ffc973e022bb0f22ba114a94cf31b3d59294", "filename": "src/test/run-pass/generic-bind.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cfdf193c4671a11e40743748d9cded9603386346/src%2Ftest%2Frun-pass%2Fgeneric-bind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfdf193c4671a11e40743748d9cded9603386346/src%2Ftest%2Frun-pass%2Fgeneric-bind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgeneric-bind.rs?ref=cfdf193c4671a11e40743748d9cded9603386346", "patch": "@@ -1,6 +1,6 @@\n \n \n-fn id<@T>(t: T) -> T { ret t; }\n+fn id<T>(t: T) -> T { ret t; }\n \n fn main() {\n     let t = {_0: 1, _1: 2, _2: 3, _3: 4, _4: 5, _5: 6, _6: 7};"}, {"sha": "3e37834f47b1e49b7e3f08bc3e703019b1ea6c04", "filename": "src/test/run-pass/generic-box.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cfdf193c4671a11e40743748d9cded9603386346/src%2Ftest%2Frun-pass%2Fgeneric-box.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfdf193c4671a11e40743748d9cded9603386346/src%2Ftest%2Frun-pass%2Fgeneric-box.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgeneric-box.rs?ref=cfdf193c4671a11e40743748d9cded9603386346", "patch": "@@ -1,6 +1,6 @@\n \n \n-fn box<@T>(x: {x: T, y: T, z: T}) -> @{x: T, y: T, z: T} { ret @x; }\n+fn box<T>(x: {x: T, y: T, z: T}) -> @{x: T, y: T, z: T} { ret @x; }\n \n fn main() {\n     let x: @{x: int, y: int, z: int} = box::<int>({x: 1, y: 2, z: 3});"}, {"sha": "50834dd2b1f90669920db348013ae03882ea3956", "filename": "src/test/run-pass/generic-derived-type.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cfdf193c4671a11e40743748d9cded9603386346/src%2Ftest%2Frun-pass%2Fgeneric-derived-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfdf193c4671a11e40743748d9cded9603386346/src%2Ftest%2Frun-pass%2Fgeneric-derived-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgeneric-derived-type.rs?ref=cfdf193c4671a11e40743748d9cded9603386346", "patch": "@@ -1,8 +1,8 @@\n \n \n-fn g<@X>(x: X) -> X { ret x; }\n+fn g<X>(x: X) -> X { ret x; }\n \n-fn f<@T>(t: T) -> {a: T, b: T} {\n+fn f<T>(t: T) -> {a: T, b: T} {\n     type pair = {a: T, b: T};\n \n     let x: pair = {a: t, b: t};"}, {"sha": "ad89b7fe55640cd73283981866e37ebd2bdd9e57", "filename": "src/test/run-pass/generic-drop-glue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cfdf193c4671a11e40743748d9cded9603386346/src%2Ftest%2Frun-pass%2Fgeneric-drop-glue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfdf193c4671a11e40743748d9cded9603386346/src%2Ftest%2Frun-pass%2Fgeneric-drop-glue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgeneric-drop-glue.rs?ref=cfdf193c4671a11e40743748d9cded9603386346", "patch": "@@ -1,5 +1,5 @@\n \n \n-fn f<@T>(t: T) { let t1: T = t; }\n+fn f<T>(t: T) { let t1: T = t; }\n \n fn main() { let x = {x: @10, y: @12}; f(x); }"}, {"sha": "7573bff74e85070aa2ecaf8d46e0ba6daaf26aee", "filename": "src/test/run-pass/generic-exterior-box.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cfdf193c4671a11e40743748d9cded9603386346/src%2Ftest%2Frun-pass%2Fgeneric-exterior-box.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfdf193c4671a11e40743748d9cded9603386346/src%2Ftest%2Frun-pass%2Fgeneric-exterior-box.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgeneric-exterior-box.rs?ref=cfdf193c4671a11e40743748d9cded9603386346", "patch": "@@ -2,7 +2,7 @@\n \n type recbox<T> = {x: @T};\n \n-fn reclift<@T>(t: T) -> recbox<T> { ret {x: @t}; }\n+fn reclift<T>(t: T) -> recbox<T> { ret {x: @t}; }\n \n fn main() {\n     let foo: int = 17;"}, {"sha": "09c2a5daead45cbcf870282b026eb53a0398509e", "filename": "src/test/run-pass/generic-exterior-unique.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cfdf193c4671a11e40743748d9cded9603386346/src%2Ftest%2Frun-pass%2Fgeneric-exterior-unique.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfdf193c4671a11e40743748d9cded9603386346/src%2Ftest%2Frun-pass%2Fgeneric-exterior-unique.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgeneric-exterior-unique.rs?ref=cfdf193c4671a11e40743748d9cded9603386346", "patch": "@@ -1,6 +1,6 @@\n type recbox<T> = {x: ~T};\n \n-fn reclift<@T>(t: T) -> recbox<T> { ret {x: ~t}; }\n+fn reclift<T>(t: T) -> recbox<T> { ret {x: ~t}; }\n \n fn main() {\n     let foo: int = 17;"}, {"sha": "d45722ccc9498cbff0662b25154f6e7002a234bf", "filename": "src/test/run-pass/generic-fn-infer.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cfdf193c4671a11e40743748d9cded9603386346/src%2Ftest%2Frun-pass%2Fgeneric-fn-infer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfdf193c4671a11e40743748d9cded9603386346/src%2Ftest%2Frun-pass%2Fgeneric-fn-infer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgeneric-fn-infer.rs?ref=cfdf193c4671a11e40743748d9cded9603386346", "patch": "@@ -4,6 +4,6 @@\n // -*- rust -*-\n \n // Issue #45: infer type parameters in function applications\n-fn id<@T>(x: T) -> T { ret x; }\n+fn id<T>(x: T) -> T { ret x; }\n \n fn main() { let x: int = 42; let y: int = id(x); assert (x == y); }"}, {"sha": "28f3fcec1e4b70190c88ab3896b3a7f4ac44d8bd", "filename": "src/test/run-pass/generic-fn-unique.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cfdf193c4671a11e40743748d9cded9603386346/src%2Ftest%2Frun-pass%2Fgeneric-fn-unique.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfdf193c4671a11e40743748d9cded9603386346/src%2Ftest%2Frun-pass%2Fgeneric-fn-unique.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgeneric-fn-unique.rs?ref=cfdf193c4671a11e40743748d9cded9603386346", "patch": "@@ -1,4 +1,4 @@\n \n-fn f<@T>(x: ~T) -> ~T { ret x; }\n+fn f<T>(x: ~T) -> ~T { ret x; }\n \n fn main() { let x = f(~3); log *x; }"}, {"sha": "9dbd6dd156c9a7fe0a21804b80ee2e05400d82e3", "filename": "src/test/run-pass/generic-fn.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cfdf193c4671a11e40743748d9cded9603386346/src%2Ftest%2Frun-pass%2Fgeneric-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfdf193c4671a11e40743748d9cded9603386346/src%2Ftest%2Frun-pass%2Fgeneric-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgeneric-fn.rs?ref=cfdf193c4671a11e40743748d9cded9603386346", "patch": "@@ -2,7 +2,7 @@\n \n \n // -*- rust -*-\n-fn id<@T>(x: T) -> T { ret x; }\n+fn id<T>(x: T) -> T { ret x; }\n \n type triple = {x: int, y: int, z: int};\n "}, {"sha": "05552db04ffa6ce8eef029efab87e8e36c99946e", "filename": "src/test/run-pass/generic-obj-with-derived-type.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cfdf193c4671a11e40743748d9cded9603386346/src%2Ftest%2Frun-pass%2Fgeneric-obj-with-derived-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfdf193c4671a11e40743748d9cded9603386346/src%2Ftest%2Frun-pass%2Fgeneric-obj-with-derived-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgeneric-obj-with-derived-type.rs?ref=cfdf193c4671a11e40743748d9cded9603386346", "patch": "@@ -1,6 +1,6 @@\n \n \n-obj handle<@T>(data: T) {\n+obj handle<T>(data: T) {\n     fn get() -> T { ret data; }\n }\n "}, {"sha": "b81aba5604fc94890ec26436f9879b4d492b4217", "filename": "src/test/run-pass/generic-obj.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cfdf193c4671a11e40743748d9cded9603386346/src%2Ftest%2Frun-pass%2Fgeneric-obj.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfdf193c4671a11e40743748d9cded9603386346/src%2Ftest%2Frun-pass%2Fgeneric-obj.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgeneric-obj.rs?ref=cfdf193c4671a11e40743748d9cded9603386346", "patch": "@@ -1,6 +1,6 @@\n \n \n-obj buf<@T>(data: {_0: T, _1: T, _2: T}) {\n+obj buf<T>(data: {_0: T, _1: T, _2: T}) {\n     fn get(i: int) -> T {\n         if i == 0 {\n             ret data._0;"}, {"sha": "e85de5dd48582c2bf22994c7996cd8d75ed4de72", "filename": "src/test/run-pass/generic-tup.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cfdf193c4671a11e40743748d9cded9603386346/src%2Ftest%2Frun-pass%2Fgeneric-tup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfdf193c4671a11e40743748d9cded9603386346/src%2Ftest%2Frun-pass%2Fgeneric-tup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgeneric-tup.rs?ref=cfdf193c4671a11e40743748d9cded9603386346", "patch": "@@ -1,4 +1,4 @@\n-fn get_third<@T>(t: (T, T, T)) -> T { let (_, _, x) = t; ret x; }\n+fn get_third<T>(t: (T, T, T)) -> T { let (_, _, x) = t; ret x; }\n \n fn main() {\n     log get_third((1, 2, 3));"}, {"sha": "29a40dd4c1f4d90d764b80bd173c86fc9c1e8c25", "filename": "src/test/run-pass/generic-unique.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cfdf193c4671a11e40743748d9cded9603386346/src%2Ftest%2Frun-pass%2Fgeneric-unique.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfdf193c4671a11e40743748d9cded9603386346/src%2Ftest%2Frun-pass%2Fgeneric-unique.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgeneric-unique.rs?ref=cfdf193c4671a11e40743748d9cded9603386346", "patch": "@@ -1,5 +1,5 @@\n \n-fn box<@T>(x: {x: T, y: T, z: T}) -> ~{x: T, y: T, z: T} { ret ~x; }\n+fn box<T>(x: {x: T, y: T, z: T}) -> ~{x: T, y: T, z: T} { ret ~x; }\n \n fn main() {\n     let x: ~{x: int, y: int, z: int} = box::<int>({x: 1, y: 2, z: 3});"}, {"sha": "0a01845841a6996f8cd14f733ff36a316802e6ea", "filename": "src/test/run-pass/issue-333.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cfdf193c4671a11e40743748d9cded9603386346/src%2Ftest%2Frun-pass%2Fissue-333.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfdf193c4671a11e40743748d9cded9603386346/src%2Ftest%2Frun-pass%2Fissue-333.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-333.rs?ref=cfdf193c4671a11e40743748d9cded9603386346", "patch": "@@ -1,5 +1,5 @@\n-fn quux<@T>(x: T) -> T { let f = bind id::<T>(_); ret f(x); }\n+fn quux<T>(x: T) -> T { let f = bind id::<T>(_); ret f(x); }\n \n-fn id<@T>(x: T) -> T { ret x; }\n+fn id<T>(x: T) -> T { ret x; }\n \n fn main() { assert (quux(10) == 10); }"}, {"sha": "b843d42570be455d71c13c66d95068b3a86fef42", "filename": "src/test/run-pass/issue-511.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cfdf193c4671a11e40743748d9cded9603386346/src%2Ftest%2Frun-pass%2Fissue-511.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfdf193c4671a11e40743748d9cded9603386346/src%2Ftest%2Frun-pass%2Fissue-511.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-511.rs?ref=cfdf193c4671a11e40743748d9cded9603386346", "patch": "@@ -1,7 +1,7 @@\n use std;\n import std::option;\n \n-fn f<@T>(&o: option::t<T>) {\n+fn f<T>(&o: option::t<T>) {\n     assert o == option::none;\n }\n "}, {"sha": "f9378b213177895a2641d2c0b9d2ae62eb141d6f", "filename": "src/test/run-pass/ivec-add.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cfdf193c4671a11e40743748d9cded9603386346/src%2Ftest%2Frun-pass%2Fivec-add.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfdf193c4671a11e40743748d9cded9603386346/src%2Ftest%2Frun-pass%2Fivec-add.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fivec-add.rs?ref=cfdf193c4671a11e40743748d9cded9603386346", "patch": "@@ -1,4 +1,4 @@\n-fn double<@T>(a: T) -> [T] { ret [a] + [a]; }\n+fn double<T>(a: T) -> [T] { ret [a] + [a]; }\n \n fn double_int(a: int) -> [int] { ret [a] + [a]; }\n "}, {"sha": "d45417e20e3f7824e2af2993ac8abc82ed0a2d35", "filename": "src/test/run-pass/log-linearized.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cfdf193c4671a11e40743748d9cded9603386346/src%2Ftest%2Frun-pass%2Flog-linearized.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfdf193c4671a11e40743748d9cded9603386346/src%2Ftest%2Frun-pass%2Flog-linearized.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flog-linearized.rs?ref=cfdf193c4671a11e40743748d9cded9603386346", "patch": "@@ -7,12 +7,12 @@ tag option<T> {\n \n type smallintmap<T> = @{mutable v: [mutable option<T>]};\n \n-fn mk<@T>() -> smallintmap<T> {\n+fn mk<T>() -> smallintmap<T> {\n     let v: [mutable option<T>] = [mutable];\n     ret @{mutable v: v};\n }\n \n-fn f<@T,@U>() {\n+fn f<T,U>() {\n     let sim = mk::<U>();\n     log_err sim;\n }"}, {"sha": "e08ace6947dae11037bd3562fdab0f576b7c524b", "filename": "src/test/run-pass/newtype-polymorphic.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cfdf193c4671a11e40743748d9cded9603386346/src%2Ftest%2Frun-pass%2Fnewtype-polymorphic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfdf193c4671a11e40743748d9cded9603386346/src%2Ftest%2Frun-pass%2Fnewtype-polymorphic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnewtype-polymorphic.rs?ref=cfdf193c4671a11e40743748d9cded9603386346", "patch": "@@ -1,8 +1,8 @@\n tag myvec<X> = [X];\n \n-fn myvec_deref<@X>(mv: myvec<X>) -> [X] { ret *mv; }\n+fn myvec_deref<X>(mv: myvec<X>) -> [X] { ret *mv; }\n \n-fn myvec_elt<@X>(mv: myvec<X>) -> X { ret mv[0]; }\n+fn myvec_elt<X>(mv: myvec<X>) -> X { ret mv[0]; }\n \n fn main() {\n     let mv = myvec([1, 2, 3]);"}, {"sha": "abf2ec0d039cd406374ce6cf0f87127230dd4324", "filename": "src/test/run-pass/non-boolean-pure-fns.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cfdf193c4671a11e40743748d9cded9603386346/src%2Ftest%2Frun-pass%2Fnon-boolean-pure-fns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfdf193c4671a11e40743748d9cded9603386346/src%2Ftest%2Frun-pass%2Fnon-boolean-pure-fns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnon-boolean-pure-fns.rs?ref=cfdf193c4671a11e40743748d9cded9603386346", "patch": "@@ -2,19 +2,19 @@ use std;\n \n import std::list::*;\n \n-pure fn pure_length_go<@T>(ls: list<T>, acc: uint) -> uint {\n+pure fn pure_length_go<T>(ls: list<T>, acc: uint) -> uint {\n     alt ls { nil. { acc } cons(_, tl) { pure_length_go(*tl, acc + 1u) } }\n }\n \n-pure fn pure_length<@T>(ls: list<T>) -> uint { pure_length_go(ls, 0u) }\n+pure fn pure_length<T>(ls: list<T>) -> uint { pure_length_go(ls, 0u) }\n \n-pure fn nonempty_list<@T>(ls: list<T>) -> bool { pure_length(ls) > 0u }\n+pure fn nonempty_list<T>(ls: list<T>) -> bool { pure_length(ls) > 0u }\n \n // Of course, the compiler can't take advantage of the\n // knowledge that ls is a cons node. Future work.\n // Also, this is pretty contrived since nonempty_list\n // could be a \"tag refinement\", if we implement those.\n-fn safe_head<@T>(ls: list<T>) : nonempty_list(ls) -> T { car(ls) }\n+fn safe_head<T>(ls: list<T>) : nonempty_list(ls) -> T { car(ls) }\n \n fn main() {\n     let mylist = cons(@1u, @nil);"}, {"sha": "9c2324a21691c943664e0b95857d701c0ff2a11c", "filename": "src/test/run-pass/ret-by-reference.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cfdf193c4671a11e40743748d9cded9603386346/src%2Ftest%2Frun-pass%2Fret-by-reference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfdf193c4671a11e40743748d9cded9603386346/src%2Ftest%2Frun-pass%2Fret-by-reference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fret-by-reference.rs?ref=cfdf193c4671a11e40743748d9cded9603386346", "patch": "@@ -1,6 +1,6 @@\n tag option<T> { some(T); none; }\n \n-fn get<@T>(opt: option<T>) -> &T {\n+fn get<T>(opt: option<T>) -> &T {\n     alt opt {\n       some(x) { ret x; }\n     }"}, {"sha": "b56db9f9c700744ed3cc177d3fca4371ab815090", "filename": "src/test/run-pass/ret-none.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cfdf193c4671a11e40743748d9cded9603386346/src%2Ftest%2Frun-pass%2Fret-none.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfdf193c4671a11e40743748d9cded9603386346/src%2Ftest%2Frun-pass%2Fret-none.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fret-none.rs?ref=cfdf193c4671a11e40743748d9cded9603386346", "patch": "@@ -2,6 +2,6 @@\n \n tag option<T> { none; some(T); }\n \n-fn f<@T>() -> option<T> { ret none; }\n+fn f<T>() -> option<T> { ret none; }\n \n fn main() { f::<int>(); }"}, {"sha": "73c36e0cdb35cd5fe54f35eb64eab09139b7ac32", "filename": "src/test/run-pass/send-type-inference.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cfdf193c4671a11e40743748d9cded9603386346/src%2Ftest%2Frun-pass%2Fsend-type-inference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfdf193c4671a11e40743748d9cded9603386346/src%2Ftest%2Frun-pass%2Fsend-type-inference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsend-type-inference.rs?ref=cfdf193c4671a11e40743748d9cded9603386346", "patch": "@@ -4,9 +4,9 @@ import std::comm::send;\n import std::comm::port;\n \n // tests that ctrl's type gets inferred properly\n-type command<~K, ~V> = {key: K, val: V};\n+type command<unique K, unique V> = {key: K, val: V};\n \n-fn cache_server<~K, ~V>(c: chan<chan<command<K, V>>>) {\n+fn cache_server<unique K, unique V>(c: chan<chan<command<K, V>>>) {\n     let ctrl = port();\n     send(c, chan(ctrl));\n }"}, {"sha": "19c56111b6172f735413d5ee66a2d0d86e69360c", "filename": "src/test/run-pass/swap-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cfdf193c4671a11e40743748d9cded9603386346/src%2Ftest%2Frun-pass%2Fswap-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfdf193c4671a11e40743748d9cded9603386346/src%2Ftest%2Frun-pass%2Fswap-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fswap-2.rs?ref=cfdf193c4671a11e40743748d9cded9603386346", "patch": "@@ -1,4 +1,4 @@\n-fn swap<@T>(v: [mutable T], i: int, j: int) { v[i] <-> v[j]; }\n+fn swap<T>(v: [mutable T], i: int, j: int) { v[i] <-> v[j]; }\n \n fn main() {\n     let a: [mutable int] = [mutable 0, 1, 2, 3, 4, 5, 6];"}, {"sha": "293b1ae5118622b75ed3547d8f1d272108404c0e", "filename": "src/test/run-pass/type-param-constraints.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cfdf193c4671a11e40743748d9cded9603386346/src%2Ftest%2Frun-pass%2Ftype-param-constraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfdf193c4671a11e40743748d9cded9603386346/src%2Ftest%2Frun-pass%2Ftype-param-constraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftype-param-constraints.rs?ref=cfdf193c4671a11e40743748d9cded9603386346", "patch": "@@ -1,6 +1,6 @@\n fn p_foo<T>(pinned: T) { }\n-fn s_foo<@T>(shared: T) { }\n-fn u_foo<~T>(unique: T) { }\n+fn s_foo<T>(shared: T) { }\n+fn u_foo<unique T>(unique: T) { }\n \n resource r(i: int) { }\n "}, {"sha": "b2ccb96efdf5b167f9791c59660443fa5bf1a6fc", "filename": "src/test/run-pass/type-params-in-for-each.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cfdf193c4671a11e40743748d9cded9603386346/src%2Ftest%2Frun-pass%2Ftype-params-in-for-each.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfdf193c4671a11e40743748d9cded9603386346/src%2Ftest%2Frun-pass%2Ftype-params-in-for-each.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftype-params-in-for-each.rs?ref=cfdf193c4671a11e40743748d9cded9603386346", "patch": "@@ -5,7 +5,7 @@ fn range(lo: uint, hi: uint, it: block(uint)) {\n     while lo_ < hi { it(lo_); lo_ += 1u; }\n }\n \n-fn create_index<@T>(index: [{a: T, b: uint}], hash_fn: fn(T) -> uint) {\n+fn create_index<T>(index: [{a: T, b: uint}], hash_fn: fn(T) -> uint) {\n     range(0u, 256u) {|_i| let bucket: [T] = []; }\n }\n "}, {"sha": "a855f96297dc472a83cc282ec1f3646df2d765dc", "filename": "src/test/run-pass/unchecked-predicates.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cfdf193c4671a11e40743748d9cded9603386346/src%2Ftest%2Frun-pass%2Funchecked-predicates.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfdf193c4671a11e40743748d9cded9603386346/src%2Ftest%2Frun-pass%2Funchecked-predicates.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funchecked-predicates.rs?ref=cfdf193c4671a11e40743748d9cded9603386346", "patch": "@@ -5,24 +5,24 @@ import std::list::*;\n \n // Can't easily be written as a \"pure fn\" because there's\n // no syntax for specifying that f is pure.\n-fn pure_foldl<@T, @U>(ls: list<T>, u: U, f: block(T, U) -> U) -> U {\n+fn pure_foldl<T, U>(ls: list<T>, u: U, f: block(T, U) -> U) -> U {\n     alt ls { nil. { u } cons(hd, tl) { f(hd, pure_foldl(*tl, f(hd, u), f)) } }\n }\n \n // Shows how to use an \"unchecked\" block to call a general\n // fn from a pure fn\n-pure fn pure_length<@T>(ls: list<T>) -> uint {\n+pure fn pure_length<T>(ls: list<T>) -> uint {\n     fn count<T>(_t: T, &&u: uint) -> uint { u + 1u }\n     unchecked{ pure_foldl(ls, 0u, bind count(_, _)) }\n }\n \n-pure fn nonempty_list<@T>(ls: list<T>) -> bool { pure_length(ls) > 0u }\n+pure fn nonempty_list<T>(ls: list<T>) -> bool { pure_length(ls) > 0u }\n \n // Of course, the compiler can't take advantage of the\n // knowledge that ls is a cons node. Future work.\n // Also, this is pretty contrived since nonempty_list\n // could be a \"tag refinement\", if we implement those.\n-fn safe_head<@T>(ls: list<T>) : nonempty_list(ls) -> T { car(ls) }\n+fn safe_head<T>(ls: list<T>) : nonempty_list(ls) -> T { car(ls) }\n \n fn main() {\n     let mylist = cons(@1u, @nil);"}, {"sha": "81a93b6ab13a93868a70af10a9f0c81e9786529b", "filename": "src/test/run-pass/unify-return-ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cfdf193c4671a11e40743748d9cded9603386346/src%2Ftest%2Frun-pass%2Funify-return-ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfdf193c4671a11e40743748d9cded9603386346/src%2Ftest%2Frun-pass%2Funify-return-ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funify-return-ty.rs?ref=cfdf193c4671a11e40743748d9cded9603386346", "patch": "@@ -4,6 +4,6 @@\n use std;\n import std::unsafe;\n \n-fn null<@T>() -> *T unsafe { unsafe::reinterpret_cast(0) }\n+fn null<T>() -> *T unsafe { unsafe::reinterpret_cast(0) }\n \n fn main() { null::<int>(); }"}, {"sha": "dfff2490b059b91f91ee04d5f2b6298d1ad0d2b3", "filename": "src/test/run-pass/unique-assign-generic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cfdf193c4671a11e40743748d9cded9603386346/src%2Ftest%2Frun-pass%2Funique-assign-generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfdf193c4671a11e40743748d9cded9603386346/src%2Ftest%2Frun-pass%2Funique-assign-generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funique-assign-generic.rs?ref=cfdf193c4671a11e40743748d9cded9603386346", "patch": "@@ -1,4 +1,4 @@\n-fn f<@T>(t: T) -> T {\n+fn f<T>(t: T) -> T {\n     let t1 = t;\n     t1\n }"}, {"sha": "3f692a59db758a96b740d465fd2819d62f500a99", "filename": "src/test/run-pass/unique-generic-assign.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cfdf193c4671a11e40743748d9cded9603386346/src%2Ftest%2Frun-pass%2Funique-generic-assign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfdf193c4671a11e40743748d9cded9603386346/src%2Ftest%2Frun-pass%2Funique-generic-assign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funique-generic-assign.rs?ref=cfdf193c4671a11e40743748d9cded9603386346", "patch": "@@ -1,6 +1,6 @@\n // Issue #976\n \n-fn f<@T>(x: ~T) {\n+fn f<T>(x: ~T) {\n     let _x2 = x;\n }\n fn main() { }"}, {"sha": "5378bddff2d8372f466c74975c03a0e234dfa630", "filename": "src/test/run-pass/unique-kinds.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cfdf193c4671a11e40743748d9cded9603386346/src%2Ftest%2Frun-pass%2Funique-kinds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfdf193c4671a11e40743748d9cded9603386346/src%2Ftest%2Frun-pass%2Funique-kinds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funique-kinds.rs?ref=cfdf193c4671a11e40743748d9cded9603386346", "patch": "@@ -1,10 +1,10 @@\n fn unique() {\n \n-    fn f<~T>(i: T, j: T) {\n+    fn f<unique T>(i: T, j: T) {\n         assert i == j;\n     }\n \n-    fn g<~T>(i: T, j: T) {\n+    fn g<unique T>(i: T, j: T) {\n         assert i != j;\n     }\n \n@@ -18,11 +18,11 @@ fn unique() {\n \n fn shared() {\n \n-    fn f<@T>(i: T, j: T) {\n+    fn f<T>(i: T, j: T) {\n         assert i == j;\n     }\n \n-    fn g<@T>(i: T, j: T) {\n+    fn g<T>(i: T, j: T) {\n         assert i != j;\n     }\n "}, {"sha": "0e0d828bf63d1981002cb787efcce43f2e39eeab", "filename": "src/test/run-pass/vec-push.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cfdf193c4671a11e40743748d9cded9603386346/src%2Ftest%2Frun-pass%2Fvec-push.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfdf193c4671a11e40743748d9cded9603386346/src%2Ftest%2Frun-pass%2Fvec-push.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fvec-push.rs?ref=cfdf193c4671a11e40743748d9cded9603386346", "patch": "@@ -1,5 +1,5 @@\n \n \n-fn push<@T>(&v: [mutable? T], t: T) { v += [t]; }\n+fn push<T>(&v: [mutable? T], t: T) { v += [t]; }\n \n fn main() { let v = [1, 2, 3]; push(v, 1); }"}, {"sha": "fac7aa3a853e7b24bde523a228b2a82646736a60", "filename": "src/test/stdtest/deque.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cfdf193c4671a11e40743748d9cded9603386346/src%2Ftest%2Fstdtest%2Fdeque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfdf193c4671a11e40743748d9cded9603386346/src%2Ftest%2Fstdtest%2Fdeque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fstdtest%2Fdeque.rs?ref=cfdf193c4671a11e40743748d9cded9603386346", "patch": "@@ -81,7 +81,7 @@ fn test_boxes(a: @int, b: @int, c: @int, d: @int) {\n \n type eqfn<T> = fn@(T, T) -> bool;\n \n-fn test_parameterized<@T>(e: eqfn<T>, a: T, b: T, c: T, d: T) {\n+fn test_parameterized<T>(e: eqfn<T>, a: T, b: T, c: T, d: T) {\n     let deq: deque::t<T> = deque::create::<T>();\n     assert (deq.size() == 0u);\n     deq.add_front(a);\n@@ -113,7 +113,7 @@ fn test_parameterized<@T>(e: eqfn<T>, a: T, b: T, c: T, d: T) {\n \n tag taggy { one(int); two(int, int); three(int, int, int); }\n \n-tag taggypar<@T> { onepar(int); twopar(int, int); threepar(int, int, int); }\n+tag taggypar<T> { onepar(int); twopar(int, int); threepar(int, int, int); }\n \n type reccy = {x: int, y: int, t: taggy};\n \n@@ -138,7 +138,7 @@ fn test() {\n           }\n         }\n     }\n-    fn taggypareq<@T>(a: taggypar<T>, b: taggypar<T>) -> bool {\n+    fn taggypareq<T>(a: taggypar<T>, b: taggypar<T>) -> bool {\n         alt a {\n           onepar::<T>(a1) {\n             alt b { onepar::<T>(b1) { ret a1 == b1; } _ { ret false; } }"}, {"sha": "b12636a58c0d64c3c9124b7c6912fc5b98484ff2", "filename": "src/test/stdtest/task.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cfdf193c4671a11e40743748d9cded9603386346/src%2Ftest%2Fstdtest%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfdf193c4671a11e40743748d9cded9603386346/src%2Ftest%2Fstdtest%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fstdtest%2Ftask.rs?ref=cfdf193c4671a11e40743748d9cded9603386346", "patch": "@@ -80,7 +80,7 @@ fn test_join_convenient() {\n #[ignore]\n fn spawn_polymorphic() {\n     // FIXME #1038: Can't spawn palymorphic functions\n-    /*fn foo<~T>(x: T) { log_err x; }\n+    /*fn foo<unique T>(x: T) { log_err x; }\n \n     task::spawn(true, foo);\n     task::spawn(42, foo);*/"}]}