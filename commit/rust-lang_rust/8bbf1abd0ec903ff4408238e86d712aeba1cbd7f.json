{"sha": "8bbf1abd0ec903ff4408238e86d712aeba1cbd7f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhiYmYxYWJkMGVjOTAzZmY0NDA4MjM4ZTg2ZDcxMmFlYmExY2JkN2Y=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-06-21T01:52:38Z"}, "committer": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-06-21T01:52:38Z"}, "message": "shared_from_iter: Add more tests.", "tree": {"sha": "2a23a04b83d9ceaa1a02bc433c0fc64381126508", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2a23a04b83d9ceaa1a02bc433c0fc64381126508"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8bbf1abd0ec903ff4408238e86d712aeba1cbd7f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8bbf1abd0ec903ff4408238e86d712aeba1cbd7f", "html_url": "https://github.com/rust-lang/rust/commit/8bbf1abd0ec903ff4408238e86d712aeba1cbd7f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8bbf1abd0ec903ff4408238e86d712aeba1cbd7f/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6b8417b55c59f3412e97131fd1f99e34bdd8f5d2", "url": "https://api.github.com/repos/rust-lang/rust/commits/6b8417b55c59f3412e97131fd1f99e34bdd8f5d2", "html_url": "https://github.com/rust-lang/rust/commit/6b8417b55c59f3412e97131fd1f99e34bdd8f5d2"}], "stats": {"total": 238, "additions": 238, "deletions": 0}, "files": [{"sha": "ce64e2de01377cc6c64d4f60480f6fad07c74515", "filename": "src/liballoc/tests/arc.rs", "status": "modified", "additions": 119, "deletions": 0, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/8bbf1abd0ec903ff4408238e86d712aeba1cbd7f/src%2Fliballoc%2Ftests%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bbf1abd0ec903ff4408238e86d712aeba1cbd7f/src%2Fliballoc%2Ftests%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Farc.rs?ref=8bbf1abd0ec903ff4408238e86d712aeba1cbd7f", "patch": "@@ -2,6 +2,8 @@ use std::any::Any;\n use std::sync::{Arc, Weak};\n use std::cell::RefCell;\n use std::cmp::PartialEq;\n+use std::iter::TrustedLen;\n+use std::mem;\n \n #[test]\n fn uninhabited() {\n@@ -85,3 +87,120 @@ fn eq() {\n     assert!(!(x != x));\n     assert_eq!(*x.0.borrow(), 0);\n }\n+\n+type Rc<T> = Arc<T>;\n+\n+const SHARED_ITER_MAX: u16 = 100;\n+\n+fn assert_trusted_len<I: TrustedLen>(_: &I) {}\n+\n+#[test]\n+fn shared_from_iter_normal() {\n+    // Exercise the base implementation for non-`TrustedLen` iterators.\n+    {\n+        // `Filter` is never `TrustedLen` since we don't\n+        // know statically how many elements will be kept:\n+        let iter = (0..SHARED_ITER_MAX).filter(|x| x % 2 == 0).map(Box::new);\n+\n+        // Collecting into a `Vec<T>` or `Rc<[T]>` should make no difference:\n+        let vec = iter.clone().collect::<Vec<_>>();\n+        let rc = iter.collect::<Rc<[_]>>();\n+        assert_eq!(&*vec, &*rc);\n+\n+        // Clone a bit and let these get dropped.\n+        {\n+            let _rc_2 = rc.clone();\n+            let _rc_3 = rc.clone();\n+            let _rc_4 = Rc::downgrade(&_rc_3);\n+        }\n+    } // Drop what hasn't been here.\n+}\n+\n+#[test]\n+fn shared_from_iter_trustedlen_normal() {\n+    // Exercise the `TrustedLen` implementation under normal circumstances\n+    // where `size_hint()` matches `(_, Some(exact_len))`.\n+    {\n+        let iter = (0..SHARED_ITER_MAX).map(Box::new);\n+        assert_trusted_len(&iter);\n+\n+        // Collecting into a `Vec<T>` or `Rc<[T]>` should make no difference:\n+        let vec = iter.clone().collect::<Vec<_>>();\n+        let rc = iter.collect::<Rc<[_]>>();\n+        assert_eq!(&*vec, &*rc);\n+        assert_eq!(mem::size_of::<Box<u16>>() * SHARED_ITER_MAX as usize, mem::size_of_val(&*rc));\n+\n+        // Clone a bit and let these get dropped.\n+        {\n+            let _rc_2 = rc.clone();\n+            let _rc_3 = rc.clone();\n+            let _rc_4 = Rc::downgrade(&_rc_3);\n+        }\n+    } // Drop what hasn't been here.\n+\n+    // Try a ZST to make sure it is handled well.\n+    {\n+        let iter = (0..SHARED_ITER_MAX).map(|_| ());\n+        let vec = iter.clone().collect::<Vec<_>>();\n+        let rc = iter.collect::<Rc<[_]>>();\n+        assert_eq!(&*vec, &*rc);\n+        assert_eq!(0, mem::size_of_val(&*rc));\n+        {\n+            let _rc_2 = rc.clone();\n+            let _rc_3 = rc.clone();\n+            let _rc_4 = Rc::downgrade(&_rc_3);\n+        }\n+    }\n+}\n+\n+#[test]\n+#[should_panic = \"I've almost got 99 problems.\"]\n+fn shared_from_iter_trustedlen_panic() {\n+    // Exercise the `TrustedLen` implementation when `size_hint()` matches\n+    // `(_, Some(exact_len))` but where `.next()` drops before the last iteration.\n+    let iter = (0..SHARED_ITER_MAX)\n+        .map(|val| {\n+            match val {\n+                98 => panic!(\"I've almost got 99 problems.\"),\n+                _ => Box::new(val),\n+            }\n+        });\n+    assert_trusted_len(&iter);\n+    let _ = iter.collect::<Rc<[_]>>();\n+\n+    panic!(\"I am unreachable.\");\n+}\n+\n+#[test]\n+fn shared_from_iter_trustedlen_no_fuse() {\n+    // Exercise the `TrustedLen` implementation when `size_hint()` matches\n+    // `(_, Some(exact_len))` but where the iterator does not behave in a fused manner.\n+    struct Iter(std::vec::IntoIter<Option<Box<u8>>>);\n+\n+    unsafe impl TrustedLen for Iter {}\n+\n+    impl Iterator for Iter {\n+        fn size_hint(&self) -> (usize, Option<usize>) {\n+            (2, Some(2))\n+        }\n+\n+        type Item = Box<u8>;\n+\n+        fn next(&mut self) -> Option<Self::Item> {\n+            self.0.next().flatten()\n+        }\n+    }\n+\n+    let vec = vec![\n+        Some(Box::new(42)),\n+        Some(Box::new(24)),\n+        None,\n+        Some(Box::new(12)),\n+    ];\n+    let iter = Iter(vec.into_iter());\n+    assert_trusted_len(&iter);\n+    assert_eq!(\n+        &[Box::new(42), Box::new(24)],\n+        &*iter.collect::<Rc<[_]>>()\n+    );\n+}"}, {"sha": "5a43c8e09a2a8a5b4b82b655e1adeb1842c974e0", "filename": "src/liballoc/tests/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8bbf1abd0ec903ff4408238e86d712aeba1cbd7f/src%2Fliballoc%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bbf1abd0ec903ff4408238e86d712aeba1cbd7f/src%2Fliballoc%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Flib.rs?ref=8bbf1abd0ec903ff4408238e86d712aeba1cbd7f", "patch": "@@ -2,8 +2,10 @@\n #![feature(box_syntax)]\n #![feature(drain_filter)]\n #![feature(exact_size_is_empty)]\n+#![feature(option_flattening)]\n #![feature(pattern)]\n #![feature(repeat_generic_slice)]\n+#![feature(trusted_len)]\n #![feature(try_reserve)]\n #![feature(unboxed_closures)]\n #![deny(rust_2018_idioms)]"}, {"sha": "7854ca0fc16b26936111d78926fff1252df1e960", "filename": "src/liballoc/tests/rc.rs", "status": "modified", "additions": 117, "deletions": 0, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/8bbf1abd0ec903ff4408238e86d712aeba1cbd7f/src%2Fliballoc%2Ftests%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bbf1abd0ec903ff4408238e86d712aeba1cbd7f/src%2Fliballoc%2Ftests%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Frc.rs?ref=8bbf1abd0ec903ff4408238e86d712aeba1cbd7f", "patch": "@@ -2,6 +2,8 @@ use std::any::Any;\n use std::rc::{Rc, Weak};\n use std::cell::RefCell;\n use std::cmp::PartialEq;\n+use std::mem;\n+use std::iter::TrustedLen;\n \n #[test]\n fn uninhabited() {\n@@ -85,3 +87,118 @@ fn eq() {\n     assert!(!(x != x));\n     assert_eq!(*x.0.borrow(), 0);\n }\n+\n+const SHARED_ITER_MAX: u16 = 100;\n+\n+fn assert_trusted_len<I: TrustedLen>(_: &I) {}\n+\n+#[test]\n+fn shared_from_iter_normal() {\n+    // Exercise the base implementation for non-`TrustedLen` iterators.\n+    {\n+        // `Filter` is never `TrustedLen` since we don't\n+        // know statically how many elements will be kept:\n+        let iter = (0..SHARED_ITER_MAX).filter(|x| x % 2 == 0).map(Box::new);\n+\n+        // Collecting into a `Vec<T>` or `Rc<[T]>` should make no difference:\n+        let vec = iter.clone().collect::<Vec<_>>();\n+        let rc = iter.collect::<Rc<[_]>>();\n+        assert_eq!(&*vec, &*rc);\n+\n+        // Clone a bit and let these get dropped.\n+        {\n+            let _rc_2 = rc.clone();\n+            let _rc_3 = rc.clone();\n+            let _rc_4 = Rc::downgrade(&_rc_3);\n+        }\n+    } // Drop what hasn't been here.\n+}\n+\n+#[test]\n+fn shared_from_iter_trustedlen_normal() {\n+    // Exercise the `TrustedLen` implementation under normal circumstances\n+    // where `size_hint()` matches `(_, Some(exact_len))`.\n+    {\n+        let iter = (0..SHARED_ITER_MAX).map(Box::new);\n+        assert_trusted_len(&iter);\n+\n+        // Collecting into a `Vec<T>` or `Rc<[T]>` should make no difference:\n+        let vec = iter.clone().collect::<Vec<_>>();\n+        let rc = iter.collect::<Rc<[_]>>();\n+        assert_eq!(&*vec, &*rc);\n+        assert_eq!(mem::size_of::<Box<u16>>() * SHARED_ITER_MAX as usize, mem::size_of_val(&*rc));\n+\n+        // Clone a bit and let these get dropped.\n+        {\n+            let _rc_2 = rc.clone();\n+            let _rc_3 = rc.clone();\n+            let _rc_4 = Rc::downgrade(&_rc_3);\n+        }\n+    } // Drop what hasn't been here.\n+\n+    // Try a ZST to make sure it is handled well.\n+    {\n+        let iter = (0..SHARED_ITER_MAX).map(|_| ());\n+        let vec = iter.clone().collect::<Vec<_>>();\n+        let rc = iter.collect::<Rc<[_]>>();\n+        assert_eq!(&*vec, &*rc);\n+        assert_eq!(0, mem::size_of_val(&*rc));\n+        {\n+            let _rc_2 = rc.clone();\n+            let _rc_3 = rc.clone();\n+            let _rc_4 = Rc::downgrade(&_rc_3);\n+        }\n+    }\n+}\n+\n+#[test]\n+#[should_panic = \"I've almost got 99 problems.\"]\n+fn shared_from_iter_trustedlen_panic() {\n+    // Exercise the `TrustedLen` implementation when `size_hint()` matches\n+    // `(_, Some(exact_len))` but where `.next()` drops before the last iteration.\n+    let iter = (0..SHARED_ITER_MAX)\n+        .map(|val| {\n+            match val {\n+                98 => panic!(\"I've almost got 99 problems.\"),\n+                _ => Box::new(val),\n+            }\n+        });\n+    assert_trusted_len(&iter);\n+    let _ = iter.collect::<Rc<[_]>>();\n+\n+    panic!(\"I am unreachable.\");\n+}\n+\n+#[test]\n+fn shared_from_iter_trustedlen_no_fuse() {\n+    // Exercise the `TrustedLen` implementation when `size_hint()` matches\n+    // `(_, Some(exact_len))` but where the iterator does not behave in a fused manner.\n+    struct Iter(std::vec::IntoIter<Option<Box<u8>>>);\n+\n+    unsafe impl TrustedLen for Iter {}\n+\n+    impl Iterator for Iter {\n+        fn size_hint(&self) -> (usize, Option<usize>) {\n+            (2, Some(2))\n+        }\n+\n+        type Item = Box<u8>;\n+\n+        fn next(&mut self) -> Option<Self::Item> {\n+            self.0.next().flatten()\n+        }\n+    }\n+\n+    let vec = vec![\n+        Some(Box::new(42)),\n+        Some(Box::new(24)),\n+        None,\n+        Some(Box::new(12)),\n+    ];\n+    let iter = Iter(vec.into_iter());\n+    assert_trusted_len(&iter);\n+    assert_eq!(\n+        &[Box::new(42), Box::new(24)],\n+        &*iter.collect::<Rc<[_]>>()\n+    );\n+}"}]}