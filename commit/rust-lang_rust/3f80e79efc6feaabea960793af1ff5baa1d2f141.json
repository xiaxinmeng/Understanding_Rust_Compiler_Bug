{"sha": "3f80e79efc6feaabea960793af1ff5baa1d2f141", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNmODBlNzllZmM2ZmVhYWJlYTk2MDc5M2FmMWZmNWJhYTFkMmYxNDE=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2010-10-22T01:13:57Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2010-10-22T01:13:57Z"}, "message": "Add support for passing args to fns in rustc.", "tree": {"sha": "4e049b0079ee4b8c8566c73d54177ace963ec7e7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4e049b0079ee4b8c8566c73d54177ace963ec7e7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3f80e79efc6feaabea960793af1ff5baa1d2f141", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3f80e79efc6feaabea960793af1ff5baa1d2f141", "html_url": "https://github.com/rust-lang/rust/commit/3f80e79efc6feaabea960793af1ff5baa1d2f141", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3f80e79efc6feaabea960793af1ff5baa1d2f141/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "67477b85ae7404508e3a963d68dbfb09a3d247f9", "url": "https://api.github.com/repos/rust-lang/rust/commits/67477b85ae7404508e3a963d68dbfb09a3d247f9", "html_url": "https://github.com/rust-lang/rust/commit/67477b85ae7404508e3a963d68dbfb09a3d247f9"}], "stats": {"total": 67, "additions": 49, "deletions": 18}, "files": [{"sha": "6263c3db8cb59ec3cd3038e2132dc411e4148087", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 49, "deletions": 18, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/3f80e79efc6feaabea960793af1ff5baa1d2f141/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f80e79efc6feaabea960793af1ff5baa1d2f141/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=3f80e79efc6feaabea960793af1ff5baa1d2f141", "patch": "@@ -42,16 +42,17 @@ type glue_fns = rec(ValueRef activate_glue,\n \n state type trans_ctxt = rec(session.session sess,\n                             ModuleRef llmod,\n-                            hashmap[str,ValueRef] upcalls,\n-                            hashmap[str,ValueRef] fn_names,\n-                            hashmap[ast.def_id,ValueRef] fn_ids,\n+                            hashmap[str, ValueRef] upcalls,\n+                            hashmap[str, ValueRef] fn_names,\n+                            hashmap[ast.def_id, ValueRef] fn_ids,\n                             @glue_fns glues,\n                             namegen names,\n                             str path);\n \n state type fn_ctxt = rec(ValueRef llfn,\n                          ValueRef lloutptr,\n                          ValueRef lltaskptr,\n+                         hashmap[ast.def_id, ValueRef] llargs,\n                          hashmap[ast.def_id, ValueRef] lllocals,\n                          @trans_ctxt tcx);\n \n@@ -659,17 +660,25 @@ fn trans_if(@block_ctxt cx, &ast.expr cond,\n     ret res(next_cx, phi);\n }\n \n-fn trans_lval(@block_ctxt cx, &ast.expr e) -> result {\n+// The additional bool returned indicates whether it's a local\n+// (that is represented as an alloca, hence needs a 'load' to be\n+// used as an rval).\n+\n+fn trans_lval(@block_ctxt cx, &ast.expr e) -> tup(result, bool) {\n     alt (e.node) {\n         case (ast.expr_name(?n, ?dopt, _)) {\n             alt (dopt) {\n                 case (some[ast.def](?def)) {\n                     alt (def) {\n+                        case (ast.def_arg(?did)) {\n+                            ret tup(res(cx, cx.fcx.llargs.get(did)), false);\n+                        }\n                         case (ast.def_local(?did)) {\n-                            ret res(cx, cx.fcx.lllocals.get(did));\n+                            ret tup(res(cx, cx.fcx.lllocals.get(did)), true);\n                         }\n                         case (ast.def_fn(?did)) {\n-                            ret res(cx, cx.fcx.tcx.fn_ids.get(did));\n+                            ret tup(res(cx, cx.fcx.tcx.fn_ids.get(did)),\n+                                    false);\n                         }\n                         case (_) {\n                             cx.fcx.tcx.sess.unimpl(\"def variant in trans\");\n@@ -731,24 +740,30 @@ fn trans_expr(@block_ctxt cx, &ast.expr e) -> result {\n \n         case (ast.expr_name(_,_,_)) {\n             auto sub = trans_lval(cx, e);\n-            ret res(sub.bcx, cx.build.Load(sub.val));\n+            if (sub._1) {\n+                ret res(sub._0.bcx, cx.build.Load(sub._0.val));\n+            } else {\n+                ret sub._0;\n+            }\n         }\n \n         case (ast.expr_assign(?dst, ?src, _)) {\n             auto lhs_res = trans_lval(cx, *dst);\n-            auto rhs_res = trans_expr(lhs_res.bcx, *src);\n+            check (lhs_res._1);\n+            auto rhs_res = trans_expr(lhs_res._0.bcx, *src);\n             ret res(rhs_res.bcx,\n-                    cx.build.Store(rhs_res.val, lhs_res.val));\n+                    cx.build.Store(rhs_res.val, lhs_res._0.val));\n         }\n \n         case (ast.expr_call(?f, ?args, _)) {\n             auto f_res = trans_lval(cx, *f);\n-            auto args_res = trans_exprs(f_res.bcx, args);\n+            check (! f_res._1);\n+            auto args_res = trans_exprs(f_res._0.bcx, args);\n             auto llargs = vec(cx.fcx.lloutptr,\n                               cx.fcx.lltaskptr);\n             llargs += args_res._1;\n             ret res(args_res._0,\n-                    cx.build.Call(f_res.val, llargs));\n+                    cx.build.Call(f_res._0.val, llargs));\n         }\n \n     }\n@@ -923,31 +938,46 @@ fn trans_block(@block_ctxt cx, &ast.block b) -> result {\n \n fn new_fn_ctxt(@trans_ctxt cx,\n                str name,\n-               ast.def_id fid,\n-               TypeRef T_out,\n-               vec[TypeRef] T_explicit_args) -> @fn_ctxt {\n-    let vec[TypeRef] args = vec(T_ptr(T_out), // outptr.\n+               &ast._fn f,\n+               ast.def_id fid) -> @fn_ctxt {\n+\n+    let vec[TypeRef] args = vec(T_ptr(type_of(cx, f.output)), // outptr.\n                                 T_taskptr()   // taskptr\n                                 );\n+    let uint arg_n = _vec.len[TypeRef](args);\n+\n+    let vec[TypeRef] T_explicit_args = vec();\n+    for (ast.arg arg in f.inputs) {\n+        T_explicit_args += type_of(cx, arg.ty);\n+    }\n     args += T_explicit_args;\n+\n     let ValueRef llfn = decl_cdecl_fn(cx.llmod, name, args, T_void());\n     cx.fn_names.insert(cx.path, llfn);\n     cx.fn_ids.insert(fid, llfn);\n+\n     let ValueRef lloutptr = llvm.LLVMGetParam(llfn, 0u);\n     let ValueRef lltaskptr = llvm.LLVMGetParam(llfn, 1u);\n+\n     let hashmap[ast.def_id, ValueRef] lllocals = new_def_hash[ValueRef]();\n+    let hashmap[ast.def_id, ValueRef] llargs = new_def_hash[ValueRef]();\n+\n+    for (ast.arg arg in f.inputs) {\n+        llargs.insert(arg.id, llvm.LLVMGetParam(llfn, arg_n));\n+        arg_n += 1u;\n+    }\n+\n     ret @rec(llfn=llfn,\n              lloutptr=lloutptr,\n              lltaskptr=lltaskptr,\n+             llargs=llargs,\n              lllocals=lllocals,\n              tcx=cx);\n }\n \n fn trans_fn(@trans_ctxt cx, &ast._fn f, ast.def_id fid) {\n-    let TypeRef out = T_int();\n-    let vec[TypeRef] args = vec();\n \n-    auto fcx = new_fn_ctxt(cx, cx.path, fid, out, args);\n+    auto fcx = new_fn_ctxt(cx, cx.path, f, fid);\n \n     trans_block(new_top_block_ctxt(fcx), f.body);\n }\n@@ -986,6 +1016,7 @@ fn trans_exit_task_glue(@trans_ctxt cx) {\n     auto fcx = @rec(llfn=llfn,\n                     lloutptr=lloutptr,\n                     lltaskptr=lltaskptr,\n+                    llargs=new_def_hash[ValueRef](),\n                     lllocals=new_def_hash[ValueRef](),\n                     tcx=cx);\n "}]}