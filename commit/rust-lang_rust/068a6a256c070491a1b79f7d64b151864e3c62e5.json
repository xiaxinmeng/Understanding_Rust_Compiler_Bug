{"sha": "068a6a256c070491a1b79f7d64b151864e3c62e5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA2OGE2YTI1NmMwNzA0OTFhMWI3OWY3ZDY0YjE1MTg2NGUzYzYyZTU=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-10-03T00:09:32Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-10-04T15:02:40Z"}, "message": "remove occurences of `skolemization`", "tree": {"sha": "2c0ff1df1b7fd99ac9a2221fd3ee531c32d9b31b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2c0ff1df1b7fd99ac9a2221fd3ee531c32d9b31b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/068a6a256c070491a1b79f7d64b151864e3c62e5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/068a6a256c070491a1b79f7d64b151864e3c62e5", "html_url": "https://github.com/rust-lang/rust/commit/068a6a256c070491a1b79f7d64b151864e3c62e5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/068a6a256c070491a1b79f7d64b151864e3c62e5/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "21aaaac29b5f0d009a0a136bdf3e6534d9f1c846", "url": "https://api.github.com/repos/rust-lang/rust/commits/21aaaac29b5f0d009a0a136bdf3e6534d9f1c846", "html_url": "https://github.com/rust-lang/rust/commit/21aaaac29b5f0d009a0a136bdf3e6534d9f1c846"}], "stats": {"total": 103, "additions": 50, "deletions": 53}, "files": [{"sha": "b1ac8bae4fb986bbbfd8239c7d8173a542e95a82", "filename": "src/librustc/infer/higher_ranked/README.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/068a6a256c070491a1b79f7d64b151864e3c62e5/src%2Flibrustc%2Finfer%2Fhigher_ranked%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/068a6a256c070491a1b79f7d64b151864e3c62e5/src%2Flibrustc%2Finfer%2Fhigher_ranked%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fhigher_ranked%2FREADME.md?ref=068a6a256c070491a1b79f7d64b151864e3c62e5", "patch": "@@ -133,7 +133,7 @@ match. This will ultimately require (as before) that `'a` <= `&x`\n must hold: but this does not hold. `self` and `x` are both distinct\n free regions. So the subtype check fails.\n \n-#### Checking for skolemization leaks\n+#### Checking for placeholder leaks\n \n You may be wondering about that mysterious last step in the algorithm.\n So far it has not been relevant. The purpose of that last step is to\n@@ -175,7 +175,7 @@ region `x` and think that everything is happy. In fact, this behavior\n is *necessary*, it was key to the first example we walked through.\n \n The difference between this example and the first one is that the variable\n-`A` already existed at the point where the skolemization occurred. In\n+`A` already existed at the point where the placeholders were added. In\n the first example, you had two functions:\n \n     for<'a> fn(&'a T) <: for<'b> fn(&'b T)\n@@ -191,7 +191,7 @@ constraints that refer to placeholder names. Basically, consider a\n non-directed version of the constraint graph. Let `Tainted(x)` be the\n set of all things reachable from a placeholder variable `x`.\n `Tainted(x)` should not contain any regions that existed before the\n-step at which the skolemization was performed. So this case here\n+step at which the placeholders were created. So this case here\n would fail because `&x` was created alone, but is relatable to `&A`.\n \n ## Computing the LUB and GLB"}, {"sha": "e77d20665bf3bd7b510f3138624bbd4ffee2bbc2", "filename": "src/librustc/infer/higher_ranked/mod.rs", "status": "modified", "additions": 31, "deletions": 31, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/068a6a256c070491a1b79f7d64b151864e3c62e5/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/068a6a256c070491a1b79f7d64b151864e3c62e5/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs?ref=068a6a256c070491a1b79f7d64b151864e3c62e5", "patch": "@@ -127,55 +127,55 @@ impl<'a, 'gcx, 'tcx> CombineFields<'a, 'gcx, 'tcx> {\n             // Map each placeholder region to a vector of other regions that it\n             // must be equated with. (Note that this vector may include other\n             // placeholder regions from `placeholder_map`.)\n-            let skol_resolution_map: FxHashMap<_, _> =\n+            let placeholder_resolution_map: FxHashMap<_, _> =\n                 placeholder_map\n                 .iter()\n-                .map(|(&br, &skol)| {\n+                .map(|(&br, &placeholder)| {\n                     let tainted_regions =\n                         self.infcx.tainted_regions(snapshot,\n-                                                   skol,\n+                                                   placeholder,\n                                                    TaintDirections::incoming()); // [1]\n \n                     // [1] this routine executes after the placeholder\n                     // regions have been *equated* with something\n                     // else, so examining the incoming edges ought to\n                     // be enough to collect all constraints\n \n-                    (skol, (br, tainted_regions))\n+                    (placeholder, (br, tainted_regions))\n                 })\n                 .collect();\n \n             // For each placeholder region, pick a representative -- which can\n             // be any region from the sets above, except for other members of\n             // `placeholder_map`. There should always be a representative if things\n             // are properly well-formed.\n-            let skol_representatives: FxHashMap<_, _> =\n-                skol_resolution_map\n+            let placeholder_representatives: FxHashMap<_, _> =\n+                placeholder_resolution_map\n                 .iter()\n-                .map(|(&skol, &(_, ref regions))| {\n+                .map(|(&placeholder, &(_, ref regions))| {\n                     let representative =\n                         regions.iter()\n-                               .filter(|&&r| !skol_resolution_map.contains_key(r))\n+                               .filter(|&&r| !placeholder_resolution_map.contains_key(r))\n                                .cloned()\n                                .next()\n                                .unwrap_or_else(|| {\n                                    bug!(\"no representative region for `{:?}` in `{:?}`\",\n-                                        skol, regions)\n+                                        placeholder, regions)\n                                });\n \n-                    (skol, representative)\n+                    (placeholder, representative)\n                 })\n                 .collect();\n \n-            // Equate all the members of each skolemization set with the\n+            // Equate all the members of each placeholder set with the\n             // representative.\n-            for (skol, &(_br, ref regions)) in &skol_resolution_map {\n-                let representative = &skol_representatives[skol];\n+            for (placeholder, &(_br, ref regions)) in &placeholder_resolution_map {\n+                let representative = &placeholder_representatives[placeholder];\n                 debug!(\"higher_ranked_match: \\\n-                        skol={:?} representative={:?} regions={:?}\",\n-                       skol, representative, regions);\n+                        placeholder={:?} representative={:?} regions={:?}\",\n+                       placeholder, representative, regions);\n                 for region in regions.iter()\n-                                     .filter(|&r| !skol_resolution_map.contains_key(r))\n+                                     .filter(|&r| !placeholder_resolution_map.contains_key(r))\n                                      .filter(|&r| r != representative)\n                 {\n                     let origin = SubregionOrigin::Subtype(self.trace.clone());\n@@ -192,7 +192,7 @@ impl<'a, 'gcx, 'tcx> CombineFields<'a, 'gcx, 'tcx> {\n                 fold_regions_in(\n                     self.tcx(),\n                     &a_value,\n-                    |r, _| skol_representatives.get(&r).cloned().unwrap_or(r));\n+                    |r, _| placeholder_representatives.get(&r).cloned().unwrap_or(r));\n \n             debug!(\"higher_ranked_match: value={:?}\", a_value);\n \n@@ -582,7 +582,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     /// the pop occurs as part of the rollback, so an explicit call is not\n     /// needed (but is also permitted).\n     ///\n-    /// For more information about how skolemization for HRTBs works, see\n+    /// For more information about how placeholders and HRTBs work, see\n     /// the [rustc guide].\n     ///\n     /// [rustc guide]: https://rust-lang-nursery.github.io/rustc-guide/traits/hrtb.html\n@@ -638,11 +638,11 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         }\n \n         let new_vars = self.region_vars_confined_to_snapshot(snapshot);\n-        for (&skol_br, &skol) in placeholder_map {\n+        for (&placeholder_br, &placeholder) in placeholder_map {\n             // The inputs to a placeholder variable can only\n             // be itself or other new variables.\n             let incoming_taints = self.tainted_regions(snapshot,\n-                                                       skol,\n+                                                       placeholder,\n                                                        TaintDirections::both());\n             for &tainted_region in &incoming_taints {\n                 // Each placeholder should only be relatable to itself\n@@ -654,21 +654,21 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                         }\n                     }\n                     _ => {\n-                        if tainted_region == skol { continue; }\n+                        if tainted_region == placeholder { continue; }\n                     }\n                 };\n \n                 debug!(\"{:?} (which replaced {:?}) is tainted by {:?}\",\n-                       skol,\n-                       skol_br,\n+                       placeholder,\n+                       placeholder_br,\n                        tainted_region);\n \n                 return Err(if overly_polymorphic {\n                     debug!(\"Overly polymorphic!\");\n-                    TypeError::RegionsOverlyPolymorphic(skol_br, tainted_region)\n+                    TypeError::RegionsOverlyPolymorphic(placeholder_br, tainted_region)\n                 } else {\n                     debug!(\"Not as polymorphic!\");\n-                    TypeError::RegionsInsufficientlyPolymorphic(skol_br, tainted_region)\n+                    TypeError::RegionsInsufficientlyPolymorphic(placeholder_br, tainted_region)\n                 })\n             }\n         }\n@@ -725,10 +725,10 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         let inv_placeholder_map: FxHashMap<ty::Region<'tcx>, ty::BoundRegion> =\n             placeholder_map\n             .iter()\n-            .flat_map(|(&skol_br, &skol)| {\n-                self.tainted_regions(snapshot, skol, TaintDirections::both())\n+            .flat_map(|(&placeholder_br, &placeholder)| {\n+                self.tainted_regions(snapshot, placeholder, TaintDirections::both())\n                     .into_iter()\n-                    .map(move |tainted_region| (tainted_region, skol_br))\n+                    .map(move |tainted_region| (tainted_region, placeholder_br))\n             })\n             .collect();\n \n@@ -739,7 +739,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         // references to regions from the `fold_regions` code below.\n         let value = self.resolve_type_vars_if_possible(&value);\n \n-        // Map any skolemization byproducts back to a late-bound\n+        // Map any placeholder byproducts back to a late-bound\n         // region. Put that late-bound region at whatever the outermost\n         // binder is that we encountered in `value`. The caller is\n         // responsible for ensuring that (a) `value` contains at least one\n@@ -798,10 +798,10 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         snapshot: &CombinedSnapshot<'a, 'tcx>,\n     ) {\n         debug!(\"pop_placeholders({:?})\", placeholder_map);\n-        let skol_regions: FxHashSet<_> = placeholder_map.values().cloned().collect();\n+        let placeholder_regions: FxHashSet<_> = placeholder_map.values().cloned().collect();\n         self.borrow_region_constraints()\n             .pop_placeholders(\n-                &skol_regions,\n+                &placeholder_regions,\n                 &snapshot.region_constraints_snapshot,\n             );\n         self.universe.set(snapshot.universe);"}, {"sha": "82d881e10b1688304313581adbd9d1977485650b", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/068a6a256c070491a1b79f7d64b151864e3c62e5/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/068a6a256c070491a1b79f7d64b151864e3c62e5/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=068a6a256c070491a1b79f7d64b151864e3c62e5", "patch": "@@ -1658,7 +1658,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n     ) {\n         debug!(\"assemble_candidates_for_projected_tys({:?})\", obligation);\n \n-        // before we go into the whole skolemization thing, just\n+        // before we go into the whole placeholder thing, just\n         // quickly check if the self-type is a projection at all.\n         match obligation.predicate.skip_binder().trait_ref.self_ty().sty {\n             ty::Projection(_) | ty::Opaque(..) => {}\n@@ -2230,9 +2230,8 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n     //\n     // Winnowing is the process of attempting to resolve ambiguity by\n     // probing further. During the winnowing process, we unify all\n-    // type variables (ignoring skolemization) and then we also\n-    // attempt to evaluate recursive bounds to see if they are\n-    // satisfied.\n+    // type variables and then we also attempt to evaluate recursive\n+    // bounds to see if they are satisfied.\n \n     /// Returns true if `victim` should be dropped in favor of\n     /// `other`.  Generally speaking we will drop duplicate"}, {"sha": "08a9f08519b7ebbdbb955b11ac2516e8faac021f", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/068a6a256c070491a1b79f7d64b151864e3c62e5/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/068a6a256c070491a1b79f7d64b151864e3c62e5/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=068a6a256c070491a1b79f7d64b151864e3c62e5", "patch": "@@ -1479,18 +1479,17 @@ impl<'tcx> InstantiatedPredicates<'tcx> {\n /// region `'a` is in a subuniverse U2 of U1, because we can name it\n /// inside the fn type but not outside.\n ///\n-/// Universes are related to **skolemization** -- which is a way of\n-/// doing type- and trait-checking around these \"forall\" binders (also\n-/// called **universal quantification**). The idea is that when, in\n-/// the body of `bar`, we refer to `T` as a type, we aren't referring\n-/// to any type in particular, but rather a kind of \"fresh\" type that\n-/// is distinct from all other types we have actually declared. This\n-/// is called a **placeholder** type, and we use universes to talk\n-/// about this. In other words, a type name in universe 0 always\n-/// corresponds to some \"ground\" type that the user declared, but a\n-/// type name in a non-zero universe is a placeholder type -- an\n-/// idealized representative of \"types in general\" that we use for\n-/// checking generic functions.\n+/// Universes are used to do type- and trait-checking around these\n+/// \"forall\" binders (also called **universal quantification**). The\n+/// idea is that when, in the body of `bar`, we refer to `T` as a\n+/// type, we aren't referring to any type in particular, but rather a\n+/// kind of \"fresh\" type that is distinct from all other types we have\n+/// actually declared. This is called a **placeholder** type, and we\n+/// use universes to talk about this. In other words, a type name in\n+/// universe 0 always corresponds to some \"ground\" type that the user\n+/// declared, but a type name in a non-zero universe is a placeholder\n+/// type -- an idealized representative of \"types in general\" that we\n+/// use for checking generic functions.\n #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable)]\n pub struct UniverseIndex(u32);\n "}, {"sha": "db0756fb1905324b9d29dbc8bd3019f36768898c", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/068a6a256c070491a1b79f7d64b151864e3c62e5/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/068a6a256c070491a1b79f7d64b151864e3c62e5/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=068a6a256c070491a1b79f7d64b151864e3c62e5", "patch": "@@ -1077,9 +1077,8 @@ pub type Region<'tcx> = &'tcx RegionKind;\n /// it must be ensured that bounds on the region can't be accidentally\n /// assumed without being checked.\n ///\n-/// The process of doing that is called \"skolemization\". The bound regions\n-/// are replaced by placeholder markers, which don't satisfy any relation\n-/// not explicitly provided.\n+/// To do this, we replace the bound regions with placeholder markers,\n+/// which don't satisfy any relation not explicitly provided.\n ///\n /// There are 2 kinds of placeholder regions in rustc: `ReFree` and\n /// `RePlaceholder`. When checking an item's body, `ReFree` is supposed"}]}