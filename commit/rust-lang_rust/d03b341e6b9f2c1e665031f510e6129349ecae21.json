{"sha": "d03b341e6b9f2c1e665031f510e6129349ecae21", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQwM2IzNDFlNmI5ZjJjMWU2NjUwMzFmNTEwZTYxMjkzNDllY2FlMjE=", "commit": {"author": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2016-04-28T16:51:33Z"}, "committer": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2016-05-16T07:13:42Z"}, "message": "Unit struct defns for 3 dataflow analyses for `borrowck::mir::dataflow`.", "tree": {"sha": "d6c9616bedd66923e4e989440d6aff9024dcd1b8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d6c9616bedd66923e4e989440d6aff9024dcd1b8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d03b341e6b9f2c1e665031f510e6129349ecae21", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d03b341e6b9f2c1e665031f510e6129349ecae21", "html_url": "https://github.com/rust-lang/rust/commit/d03b341e6b9f2c1e665031f510e6129349ecae21", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d03b341e6b9f2c1e665031f510e6129349ecae21/comments", "author": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "79ab85544bc14a3eadd8ad2dfba24fd5757a6d23", "url": "https://api.github.com/repos/rust-lang/rust/commits/79ab85544bc14a3eadd8ad2dfba24fd5757a6d23", "html_url": "https://github.com/rust-lang/rust/commit/79ab85544bc14a3eadd8ad2dfba24fd5757a6d23"}], "stats": {"total": 117, "additions": 117, "deletions": 0}, "files": [{"sha": "5a508ba9e961048ce8366ed81bbd76041362b396", "filename": "src/librustc_borrowck/borrowck/mir/dataflow.rs", "status": "modified", "additions": 117, "deletions": 0, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/d03b341e6b9f2c1e665031f510e6129349ecae21/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d03b341e6b9f2c1e665031f510e6129349ecae21/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow.rs?ref=d03b341e6b9f2c1e665031f510e6129349ecae21", "patch": "@@ -14,6 +14,7 @@ use rustc::ty::TyCtxt;\n use rustc::mir::repr::{self, Mir};\n \n use std::io;\n+use std::marker::PhantomData;\n use std::mem;\n use std::usize;\n \n@@ -465,6 +466,122 @@ impl<D: BitDenotation> DataflowState<D> {\n     }\n }\n \n+// Dataflow analyses are built upon some interpretation of the\n+// bitvectors attached to each basic block, represented via a\n+// zero-sized structure.\n+//\n+// Note on PhantomData: Each interpretation will need to instantiate\n+// the `Bit` and `Ctxt` associated types, and in this case, those\n+// associated types need an associated lifetime `'tcx`. The\n+// interpretive structures are zero-sized, so they all need to carry a\n+// `PhantomData` representing how the structures relate to the `'tcx`\n+// lifetime.\n+//\n+// But, since all of the uses of `'tcx` are solely via instances of\n+// `Ctxt` that are passed into the `BitDenotation` methods, we can\n+// consistently use a `PhantomData` that is just a function over a\n+// `&Ctxt` (== `&MoveData<'tcx>).\n+\n+/// `MaybeInitializedLvals` tracks all l-values that might be\n+/// initialized upon reaching a particular point in the control flow\n+/// for a function.\n+///\n+/// For example, in code like the following, we have corresponding\n+/// dataflow information shown in the right-hand comments.\n+///\n+/// ```rust\n+/// struct S;\n+/// fn foo(pred: bool) {                       // maybe-init:\n+///                                            // {}\n+///     let a = S; let b = S; let c; let d;    // {a, b}\n+///\n+///     if pred {\n+///         drop(a);                           // {   b}\n+///         b = S;                             // {   b}\n+///\n+///     } else {\n+///         drop(b);                           // {a}\n+///         d = S;                             // {a,       d}\n+///\n+///     }                                      // {a, b,    d}\n+///\n+///     c = S;                                 // {a, b, c, d}\n+/// }\n+/// ```\n+///\n+/// To determine whether an l-value *must* be initialized at a\n+/// particular control-flow point, one can take the set-difference\n+/// between this data and the data from `MaybeUninitializedLvals` at the\n+/// corresponding control-flow point.\n+///\n+/// Similarly, at a given `drop` statement, the set-intersection\n+/// between this data and `MaybeUninitializedLvals` yields the set of\n+/// l-values that would require a dynamic drop-flag at that statement.\n+#[derive(Debug, Default)]\n+pub struct MaybeInitializedLvals<'tcx> {\n+    // See \"Note on PhantomData\" above.\n+    phantom: PhantomData<for <'a> Fn(&'a MoveData<'tcx>)>,\n+}\n+\n+/// `MaybeUninitializedLvals` tracks all l-values that might be\n+/// uninitialized upon reaching a particular point in the control flow\n+/// for a function.\n+///\n+/// For example, in code like the following, we have corresponding\n+/// dataflow information shown in the right-hand comments.\n+///\n+/// ```rust\n+/// struct S;\n+/// fn foo(pred: bool) {                       // maybe-uninit:\n+///                                            // {a, b, c, d}\n+///     let a = S; let b = S; let c; let d;    // {      c, d}\n+///\n+///     if pred {\n+///         drop(a);                           // {a,    c, d}\n+///         b = S;                             // {a,    c, d}\n+///\n+///     } else {\n+///         drop(b);                           // {   b, c, d}\n+///         d = S;                             // {   b, c   }\n+///\n+///     }                                      // {a, b, c, d}\n+///\n+///     c = S;                                 // {a, b,    d}\n+/// }\n+/// ```\n+///\n+/// To determine whether an l-value *must* be uninitialized at a\n+/// particular control-flow point, one can take the set-difference\n+/// between this data and the data from `MaybeInitializedLvals` at the\n+/// corresponding control-flow point.\n+///\n+/// Similarly, at a given `drop` statement, the set-intersection\n+/// between this data and `MaybeInitializedLvals` yields the set of\n+/// l-values that would require a dynamic drop-flag at that statement.\n+#[derive(Debug, Default)]\n+pub struct MaybeUninitializedLvals<'tcx> {\n+    // See \"Note on PhantomData\" above.\n+    phantom: PhantomData<for <'a> Fn(&'a MoveData<'tcx>)>,\n+}\n+\n+/// `MovingOutStatements` tracks the statements that perform moves out\n+/// of particular l-values. More precisely, it tracks whether the\n+/// *effect* of such moves (namely, the uninitialization of the\n+/// l-value in question) can reach some point in the control-flow of\n+/// the function, or if that effect is \"killed\" by some intervening\n+/// operation reinitializing that l-value.\n+///\n+/// The resulting dataflow is a more enriched version of\n+/// `MaybeUninitializedLvals`. Both structures on their own only tell\n+/// you if an l-value *might* be uninitialized at a given point in the\n+/// control flow. But `MovingOutStatements` also includes the added\n+/// data of *which* particular statement causing the deinitialization\n+/// that the borrow checker's error meessage may need to report.\n+#[derive(Debug, Default)]\n+pub struct MovingOutStatements<'tcx> {\n+    // See \"Note on PhantomData\" above.\n+    phantom: PhantomData<for <'a> Fn(&'a MoveData<'tcx>)>,\n+}\n \n impl<'a, 'tcx> DataflowState<MoveData<'tcx>> {\n     pub fn new_move_analysis(mir: &Mir<'tcx>, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Self {"}]}