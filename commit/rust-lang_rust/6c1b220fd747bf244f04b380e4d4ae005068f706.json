{"sha": "6c1b220fd747bf244f04b380e4d4ae005068f706", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZjMWIyMjBmZDc0N2JmMjQ0ZjA0YjM4MGU0ZDRhZTAwNTA2OGY3MDY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-11-02T22:26:54Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-11-02T22:26:54Z"}, "message": "Auto merge of #63810 - oli-obk:const_offset_from, r=RalfJung,nikic\n\nMake <*const/mut T>::offset_from `const fn`\n\nThis reenables offset_of cc @mjbshaw \tafter https://github.com/rust-lang/rust/pull/63075 broke it", "tree": {"sha": "54c194966953385b5b99a2adada205e6f1631391", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/54c194966953385b5b99a2adada205e6f1631391"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6c1b220fd747bf244f04b380e4d4ae005068f706", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6c1b220fd747bf244f04b380e4d4ae005068f706", "html_url": "https://github.com/rust-lang/rust/commit/6c1b220fd747bf244f04b380e4d4ae005068f706", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6c1b220fd747bf244f04b380e4d4ae005068f706/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "91fd6283e658e2c7aab2d3f5206fc1891f486af2", "url": "https://api.github.com/repos/rust-lang/rust/commits/91fd6283e658e2c7aab2d3f5206fc1891f486af2", "html_url": "https://github.com/rust-lang/rust/commit/91fd6283e658e2c7aab2d3f5206fc1891f486af2"}, {"sha": "b93f48f71a1764420978c6344acd5faf4c3f9a51", "url": "https://api.github.com/repos/rust-lang/rust/commits/b93f48f71a1764420978c6344acd5faf4c3f9a51", "html_url": "https://github.com/rust-lang/rust/commit/b93f48f71a1764420978c6344acd5faf4c3f9a51"}], "stats": {"total": 255, "additions": 252, "deletions": 3}, "files": [{"sha": "3db85d05d7a986b0da42dc2f00cab35947678f7a", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6c1b220fd747bf244f04b380e4d4ae005068f706/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c1b220fd747bf244f04b380e4d4ae005068f706/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=6c1b220fd747bf244f04b380e4d4ae005068f706", "patch": "@@ -1344,6 +1344,10 @@ extern \"rust-intrinsic\" {\n     /// Emits a `!nontemporal` store according to LLVM (see their docs).\n     /// Probably will never become stable.\n     pub fn nontemporal_store<T>(ptr: *mut T, val: T);\n+\n+    /// See documentation of `<*const T>::offset_from` for details.\n+    #[cfg(not(bootstrap))]\n+    pub fn ptr_offset_from<T>(ptr: *const T, base: *const T) -> isize;\n }\n \n // Some functions are defined here because they accidentally got made"}, {"sha": "1355ce1aa43b736272b5f51b3eb260ce6be44d3d", "filename": "src/libcore/ptr/mod.rs", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/6c1b220fd747bf244f04b380e4d4ae005068f706/src%2Flibcore%2Fptr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c1b220fd747bf244f04b380e4d4ae005068f706/src%2Flibcore%2Fptr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr%2Fmod.rs?ref=6c1b220fd747bf244f04b380e4d4ae005068f706", "patch": "@@ -1286,7 +1286,22 @@ impl<T: ?Sized> *const T {\n     /// }\n     /// ```\n     #[unstable(feature = \"ptr_offset_from\", issue = \"41079\")]\n+    #[cfg(not(bootstrap))]\n+    #[rustc_const_unstable(feature = \"const_ptr_offset_from\")]\n     #[inline]\n+    pub const unsafe fn offset_from(self, origin: *const T) -> isize where T: Sized {\n+        let pointee_size = mem::size_of::<T>();\n+        let ok = 0 < pointee_size && pointee_size <= isize::max_value() as usize;\n+        // assert that the pointee size is valid in a const eval compatible way\n+        // FIXME: do this with a real assert at some point\n+        [()][(!ok) as usize];\n+        intrinsics::ptr_offset_from(self, origin)\n+    }\n+\n+    #[unstable(feature = \"ptr_offset_from\", issue = \"41079\")]\n+    #[inline]\n+    #[cfg(bootstrap)]\n+    /// bootstrap\n     pub unsafe fn offset_from(self, origin: *const T) -> isize where T: Sized {\n         let pointee_size = mem::size_of::<T>();\n         assert!(0 < pointee_size && pointee_size <= isize::max_value() as usize);\n@@ -2013,8 +2028,9 @@ impl<T: ?Sized> *mut T {\n     /// }\n     /// ```\n     #[unstable(feature = \"ptr_offset_from\", issue = \"41079\")]\n+    #[rustc_const_unstable(feature = \"const_ptr_offset_from\")]\n     #[inline]\n-    pub unsafe fn offset_from(self, origin: *const T) -> isize where T: Sized {\n+    pub const unsafe fn offset_from(self, origin: *const T) -> isize where T: Sized {\n         (self as *const T).offset_from(origin)\n     }\n "}, {"sha": "97bd57a7ded06aa0e4abdada6f580e3ac2131fa2", "filename": "src/librustc_codegen_llvm/intrinsic.rs", "status": "modified", "additions": 18, "deletions": 1, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/6c1b220fd747bf244f04b380e4d4ae005068f706/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c1b220fd747bf244f04b380e4d4ae005068f706/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs?ref=6c1b220fd747bf244f04b380e4d4ae005068f706", "patch": "@@ -19,6 +19,7 @@ use rustc::mir::interpret::GlobalId;\n use rustc_codegen_ssa::common::{IntPredicate, TypeKind};\n use rustc::hir;\n use syntax::ast::{self, FloatTy};\n+use rustc_target::abi::HasDataLayout;\n \n use rustc_codegen_ssa::common::span_invalid_monomorphization_error;\n use rustc_codegen_ssa::traits::*;\n@@ -694,6 +695,23 @@ impl IntrinsicCallMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n                 return;\n             }\n \n+            \"ptr_offset_from\" => {\n+                let ty = substs.type_at(0);\n+                let pointee_size = self.size_of(ty);\n+\n+                // This is the same sequence that Clang emits for pointer subtraction.\n+                // It can be neither `nsw` nor `nuw` because the input is treated as\n+                // unsigned but then the output is treated as signed, so neither works.\n+                let a = args[0].immediate();\n+                let b = args[1].immediate();\n+                let a = self.ptrtoint(a, self.type_isize());\n+                let b = self.ptrtoint(b, self.type_isize());\n+                let d = self.sub(a, b);\n+                let pointee_size = self.const_usize(pointee_size.bytes());\n+                // this is where the signed magic happens (notice the `s` in `exactsdiv`)\n+                self.exactsdiv(d, pointee_size)\n+            }\n+\n             _ => bug!(\"unknown intrinsic '{}'\", name),\n         };\n \n@@ -1224,7 +1242,6 @@ fn generic_simd_intrinsic(\n         // The `fn simd_bitmask(vector) -> unsigned integer` intrinsic takes a\n         // vector mask and returns an unsigned integer containing the most\n         // significant bit (MSB) of each lane.\n-        use rustc_target::abi::HasDataLayout;\n \n         // If the vector has less than 8 lanes, an u8 is returned with zeroed\n         // trailing bits."}, {"sha": "c08e4c896094b6f99e00cc99e4fcff33d7fc0e09", "filename": "src/librustc_mir/interpret/intrinsics.rs", "status": "modified", "additions": 50, "deletions": 1, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/6c1b220fd747bf244f04b380e4d4ae005068f706/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c1b220fd747bf244f04b380e4d4ae005068f706/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs?ref=6c1b220fd747bf244f04b380e4d4ae005068f706", "patch": "@@ -13,7 +13,7 @@ use rustc::mir::BinOp;\n use rustc::mir::interpret::{InterpResult, Scalar, GlobalId, ConstValue};\n \n use super::{\n-    Machine, PlaceTy, OpTy, InterpCx,\n+    Machine, PlaceTy, OpTy, InterpCx, ImmTy,\n };\n \n mod caller_location;\n@@ -249,6 +249,29 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 let result = Scalar::from_uint(truncated_bits, layout.size);\n                 self.write_scalar(result, dest)?;\n             }\n+\n+            \"ptr_offset_from\" => {\n+                let a = self.read_immediate(args[0])?.to_scalar()?.to_ptr()?;\n+                let b = self.read_immediate(args[1])?.to_scalar()?.to_ptr()?;\n+                if a.alloc_id != b.alloc_id {\n+                    throw_ub_format!(\n+                        \"ptr_offset_from cannot compute offset of pointers into different \\\n+                        allocations.\",\n+                    );\n+                }\n+                let usize_layout = self.layout_of(self.tcx.types.usize)?;\n+                let a_offset = ImmTy::from_uint(a.offset.bytes(), usize_layout);\n+                let b_offset = ImmTy::from_uint(b.offset.bytes(), usize_layout);\n+                let (val, _overflowed, _ty) = self.overflowing_binary_op(\n+                    BinOp::Sub, a_offset, b_offset,\n+                )?;\n+                let pointee_layout = self.layout_of(substs.type_at(0))?;\n+                let isize_layout = self.layout_of(self.tcx.types.isize)?;\n+                let val = ImmTy::from_scalar(val, isize_layout);\n+                let size = ImmTy::from_int(pointee_layout.size.bytes(), isize_layout);\n+                self.exact_div(val, size, dest)?;\n+            }\n+\n             \"transmute\" => {\n                 self.copy_op_transmute(args[0], dest)?;\n             }\n@@ -354,4 +377,30 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             return Ok(false);\n         }\n     }\n+\n+    pub fn exact_div(\n+        &mut self,\n+        a: ImmTy<'tcx, M::PointerTag>,\n+        b: ImmTy<'tcx, M::PointerTag>,\n+        dest: PlaceTy<'tcx, M::PointerTag>,\n+    ) -> InterpResult<'tcx> {\n+        // Performs an exact division, resulting in undefined behavior where\n+        // `x % y != 0` or `y == 0` or `x == T::min_value() && y == -1`.\n+        // First, check x % y != 0.\n+        if self.binary_op(BinOp::Rem, a, b)?.to_bits()? != 0 {\n+            // Then, check if `b` is -1, which is the \"min_value / -1\" case.\n+            let minus1 = Scalar::from_int(-1, dest.layout.size);\n+            let b = b.to_scalar().unwrap();\n+            if b == minus1 {\n+                throw_ub_format!(\"exact_div: result of dividing MIN by -1 cannot be represented\")\n+            } else {\n+                throw_ub_format!(\n+                    \"exact_div: {} cannot be divided by {} without remainder\",\n+                    a.to_scalar().unwrap(),\n+                    b,\n+                )\n+            }\n+        }\n+        self.binop_ignore_overflow(BinOp::Div, a, b, dest)\n+    }\n }"}, {"sha": "5463b9444731f8c40657f0b156c6ef5609dd3d16", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6c1b220fd747bf244f04b380e4d4ae005068f706/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c1b220fd747bf244f04b380e4d4ae005068f706/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=6c1b220fd747bf244f04b380e4d4ae005068f706", "patch": "@@ -564,6 +564,7 @@ impl Qualif for IsNotPromotable {\n                             | \"transmute\"\n                             | \"simd_insert\"\n                             | \"simd_extract\"\n+                            | \"ptr_offset_from\"\n                             => return true,\n \n                             _ => {}"}, {"sha": "33dc85fc68a2ee182ab4e8b7f2670d5e302e2d26", "filename": "src/librustc_typeck/check/intrinsic.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c1b220fd747bf244f04b380e4d4ae005068f706/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c1b220fd747bf244f04b380e4d4ae005068f706/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs?ref=6c1b220fd747bf244f04b380e4d4ae005068f706", "patch": "@@ -317,6 +317,8 @@ pub fn check_intrinsic_type(tcx: TyCtxt<'_>, it: &hir::ForeignItem) {\n                 (1, vec![param(0), param(0)],\n                 tcx.intern_tup(&[param(0), tcx.types.bool])),\n \n+            \"ptr_offset_from\" =>\n+                (1, vec![ tcx.mk_imm_ptr(param(0)), tcx.mk_imm_ptr(param(0)) ], tcx.types.isize),\n             \"unchecked_div\" | \"unchecked_rem\" | \"exact_div\" =>\n                 (1, vec![param(0), param(0)], param(0)),\n             \"unchecked_shl\" | \"unchecked_shr\" |"}, {"sha": "4d6800681889c9a8ac6a4a90758b6e6229909ad4", "filename": "src/test/ui/consts/offset_from.rs", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/6c1b220fd747bf244f04b380e4d4ae005068f706/src%2Ftest%2Fui%2Fconsts%2Foffset_from.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c1b220fd747bf244f04b380e4d4ae005068f706/src%2Ftest%2Fui%2Fconsts%2Foffset_from.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Foffset_from.rs?ref=6c1b220fd747bf244f04b380e4d4ae005068f706", "patch": "@@ -0,0 +1,47 @@\n+// run-pass\n+\n+#![feature(const_raw_ptr_deref)]\n+#![feature(const_ptr_offset_from)]\n+#![feature(ptr_offset_from)]\n+\n+struct Struct {\n+    field: (),\n+}\n+\n+#[repr(C)]\n+struct Struct2 {\n+    data: u8,\n+    field: u8,\n+}\n+\n+pub const OFFSET: usize = {\n+    let uninit = std::mem::MaybeUninit::<Struct>::uninit();\n+    let base_ptr: *const Struct = &uninit as *const _ as *const Struct;\n+    // The following statement is UB (taking the address of an uninitialized field).\n+    // Const eval doesn't detect this right now, but it may stop compiling at some point\n+    // in the future.\n+    let field_ptr = unsafe { &(*base_ptr).field as *const () as *const u8 };\n+    let offset = unsafe { field_ptr.offset_from(base_ptr as *const u8) };\n+    offset as usize\n+};\n+\n+pub const OFFSET_2: usize = {\n+    let uninit = std::mem::MaybeUninit::<Struct2>::uninit();\n+    let base_ptr: *const Struct2 = &uninit as *const _ as *const Struct2;\n+    let field_ptr = unsafe { &(*base_ptr).field as *const u8 };\n+    let offset = unsafe { field_ptr.offset_from(base_ptr as *const u8) };\n+    offset as usize\n+};\n+\n+pub const OVERFLOW: isize = {\n+    let uninit = std::mem::MaybeUninit::<Struct2>::uninit();\n+    let base_ptr: *const Struct2 = &uninit as *const _ as *const Struct2;\n+    let field_ptr = unsafe { &(*base_ptr).field as *const u8 };\n+    unsafe { (base_ptr as *const u8).offset_from(field_ptr) }\n+};\n+\n+fn main() {\n+    assert_eq!(OFFSET, 0);\n+    assert_eq!(OFFSET_2, 1);\n+    assert_eq!(OVERFLOW, -1);\n+}"}, {"sha": "18b4d7271260f54388447636a974352c5f83d9cf", "filename": "src/test/ui/consts/offset_from_ub.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/6c1b220fd747bf244f04b380e4d4ae005068f706/src%2Ftest%2Fui%2Fconsts%2Foffset_from_ub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c1b220fd747bf244f04b380e4d4ae005068f706/src%2Ftest%2Fui%2Fconsts%2Foffset_from_ub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Foffset_from_ub.rs?ref=6c1b220fd747bf244f04b380e4d4ae005068f706", "patch": "@@ -0,0 +1,37 @@\n+// ignore-x86 FIXME: missing sysroot spans (#53081)\n+\n+#![feature(const_raw_ptr_deref)]\n+#![feature(const_ptr_offset_from)]\n+#![feature(ptr_offset_from)]\n+\n+#[repr(C)]\n+struct Struct {\n+    data: u8,\n+    field: u8,\n+}\n+\n+pub const DIFFERENT_ALLOC: usize = {\n+    //~^ NOTE\n+    let uninit = std::mem::MaybeUninit::<Struct>::uninit();\n+    let base_ptr: *const Struct = &uninit as *const _ as *const Struct;\n+    let uninit2 = std::mem::MaybeUninit::<Struct>::uninit();\n+    let field_ptr: *const Struct = &uninit2 as *const _ as *const Struct;\n+    let offset = unsafe { field_ptr.offset_from(base_ptr) };\n+    offset as usize\n+};\n+\n+pub const NOT_PTR: usize = {\n+    //~^ NOTE\n+    unsafe { (42 as *const u8).offset_from(&5u8) as usize }\n+};\n+\n+pub const NOT_MULTIPLE_OF_SIZE: usize = {\n+    //~^ NOTE\n+    let data = [5u8, 6, 7];\n+    let base_ptr = data.as_ptr();\n+    let field_ptr = &data[1] as *const u8 as *const u16;\n+    let offset = unsafe { field_ptr.offset_from(base_ptr as *const u16) };\n+    offset as usize\n+};\n+\n+fn main() {}"}, {"sha": "289128b4a170b06ae6a31203ccda7e0cdc4698b9", "filename": "src/test/ui/consts/offset_from_ub.stderr", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/6c1b220fd747bf244f04b380e4d4ae005068f706/src%2Ftest%2Fui%2Fconsts%2Foffset_from_ub.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6c1b220fd747bf244f04b380e4d4ae005068f706/src%2Ftest%2Fui%2Fconsts%2Foffset_from_ub.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Foffset_from_ub.stderr?ref=6c1b220fd747bf244f04b380e4d4ae005068f706", "patch": "@@ -0,0 +1,61 @@\n+error: any use of this value will cause an error\n+  --> $SRC_DIR/libcore/ptr/mod.rs:LL:COL\n+   |\n+LL |           intrinsics::ptr_offset_from(self, origin)\n+   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |           |\n+   |           ptr_offset_from cannot compute offset of pointers into different allocations.\n+   |           inside call to `std::ptr::<impl *const Struct>::offset_from` at $DIR/offset_from_ub.rs:19:27\n+   | \n+  ::: $DIR/offset_from_ub.rs:13:1\n+   |\n+LL | / pub const DIFFERENT_ALLOC: usize = {\n+LL | |\n+LL | |     let uninit = std::mem::MaybeUninit::<Struct>::uninit();\n+LL | |     let base_ptr: *const Struct = &uninit as *const _ as *const Struct;\n+...  |\n+LL | |     offset as usize\n+LL | | };\n+   | |__-\n+   |\n+   = note: `#[deny(const_err)]` on by default\n+\n+error: any use of this value will cause an error\n+  --> $SRC_DIR/libcore/ptr/mod.rs:LL:COL\n+   |\n+LL |           intrinsics::ptr_offset_from(self, origin)\n+   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |           |\n+   |           a memory access tried to interpret some bytes as a pointer\n+   |           inside call to `std::ptr::<impl *const u8>::offset_from` at $DIR/offset_from_ub.rs:25:14\n+   | \n+  ::: $DIR/offset_from_ub.rs:23:1\n+   |\n+LL | / pub const NOT_PTR: usize = {\n+LL | |\n+LL | |     unsafe { (42 as *const u8).offset_from(&5u8) as usize }\n+LL | | };\n+   | |__-\n+\n+error: any use of this value will cause an error\n+  --> $SRC_DIR/libcore/ptr/mod.rs:LL:COL\n+   |\n+LL |           intrinsics::ptr_offset_from(self, origin)\n+   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |           |\n+   |           exact_div: 1 cannot be divided by 2 without remainder\n+   |           inside call to `std::ptr::<impl *const u16>::offset_from` at $DIR/offset_from_ub.rs:33:27\n+   | \n+  ::: $DIR/offset_from_ub.rs:28:1\n+   |\n+LL | / pub const NOT_MULTIPLE_OF_SIZE: usize = {\n+LL | |\n+LL | |     let data = [5u8, 6, 7];\n+LL | |     let base_ptr = data.as_ptr();\n+...  |\n+LL | |     offset as usize\n+LL | | };\n+   | |__-\n+\n+error: aborting due to 3 previous errors\n+"}, {"sha": "cbbb2adf15f91acc80b398a281e3eac4c5704eaf", "filename": "src/test/ui/offset_from.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/6c1b220fd747bf244f04b380e4d4ae005068f706/src%2Ftest%2Fui%2Foffset_from.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c1b220fd747bf244f04b380e4d4ae005068f706/src%2Ftest%2Fui%2Foffset_from.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Foffset_from.rs?ref=6c1b220fd747bf244f04b380e4d4ae005068f706", "patch": "@@ -0,0 +1,15 @@\n+// run-pass\n+\n+#![feature(ptr_offset_from)]\n+\n+fn main() {\n+    let mut a = [0; 5];\n+    let ptr1: *mut i32 = &mut a[1];\n+    let ptr2: *mut i32 = &mut a[3];\n+    unsafe {\n+        assert_eq!(ptr2.offset_from(ptr1), 2);\n+        assert_eq!(ptr1.offset_from(ptr2), -2);\n+        assert_eq!(ptr1.offset(2), ptr2);\n+        assert_eq!(ptr2.offset(-2), ptr1);\n+    }\n+}"}]}