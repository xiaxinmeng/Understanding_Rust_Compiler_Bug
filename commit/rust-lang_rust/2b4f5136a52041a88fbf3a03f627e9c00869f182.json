{"sha": "2b4f5136a52041a88fbf3a03f627e9c00869f182", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJiNGY1MTM2YTUyMDQxYTg4ZmJmM2EwM2Y2MjdlOWMwMDg2OWYxODI=", "commit": {"author": {"name": "Kevin Cantu", "email": "me@kevincantu.org", "date": "2012-02-12T08:14:05Z"}, "committer": {"name": "Kevin Cantu", "email": "me@kevincantu.org", "date": "2012-02-12T23:30:20Z"}, "message": "(core::str) rename byte_len -> len_bytes and rename char_len -> len", "tree": {"sha": "f17de603cfa62934ec39da320262297fd865dceb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f17de603cfa62934ec39da320262297fd865dceb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2b4f5136a52041a88fbf3a03f627e9c00869f182", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2b4f5136a52041a88fbf3a03f627e9c00869f182", "html_url": "https://github.com/rust-lang/rust/commit/2b4f5136a52041a88fbf3a03f627e9c00869f182", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2b4f5136a52041a88fbf3a03f627e9c00869f182/comments", "author": {"login": "killerswan", "id": 195060, "node_id": "MDQ6VXNlcjE5NTA2MA==", "avatar_url": "https://avatars.githubusercontent.com/u/195060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/killerswan", "html_url": "https://github.com/killerswan", "followers_url": "https://api.github.com/users/killerswan/followers", "following_url": "https://api.github.com/users/killerswan/following{/other_user}", "gists_url": "https://api.github.com/users/killerswan/gists{/gist_id}", "starred_url": "https://api.github.com/users/killerswan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/killerswan/subscriptions", "organizations_url": "https://api.github.com/users/killerswan/orgs", "repos_url": "https://api.github.com/users/killerswan/repos", "events_url": "https://api.github.com/users/killerswan/events{/privacy}", "received_events_url": "https://api.github.com/users/killerswan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "killerswan", "id": 195060, "node_id": "MDQ6VXNlcjE5NTA2MA==", "avatar_url": "https://avatars.githubusercontent.com/u/195060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/killerswan", "html_url": "https://github.com/killerswan", "followers_url": "https://api.github.com/users/killerswan/followers", "following_url": "https://api.github.com/users/killerswan/following{/other_user}", "gists_url": "https://api.github.com/users/killerswan/gists{/gist_id}", "starred_url": "https://api.github.com/users/killerswan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/killerswan/subscriptions", "organizations_url": "https://api.github.com/users/killerswan/orgs", "repos_url": "https://api.github.com/users/killerswan/repos", "events_url": "https://api.github.com/users/killerswan/events{/privacy}", "received_events_url": "https://api.github.com/users/killerswan/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "944f5a65983e929f63c9867c3e635997f89cbe85", "url": "https://api.github.com/repos/rust-lang/rust/commits/944f5a65983e929f63c9867c3e635997f89cbe85", "html_url": "https://github.com/rust-lang/rust/commit/944f5a65983e929f63c9867c3e635997f89cbe85"}], "stats": {"total": 242, "additions": 123, "deletions": 119}, "files": [{"sha": "57a63052ee80c57b00336855eca00c987ce2a466", "filename": "src/cargo/cargo.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2b4f5136a52041a88fbf3a03f627e9c00869f182/src%2Fcargo%2Fcargo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b4f5136a52041a88fbf3a03f627e9c00869f182/src%2Fcargo%2Fcargo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcargo%2Fcargo.rs?ref=2b4f5136a52041a88fbf3a03f627e9c00869f182", "patch": "@@ -174,10 +174,10 @@ fn print(s: str) {\n }\n \n fn rest(s: str, start: uint) -> str {\n-    if (start >= str::char_len(s)) {\n+    if (start >= str::len(s)) {\n         \"\"\n     } else {\n-        str::slice(s, start, str::char_len(s))\n+        str::slice(s, start, str::len(s))\n     }\n }\n \n@@ -654,7 +654,7 @@ fn cmd_install(c: cargo) unsafe {\n         alt str::index(uuid, '/') {\n             option::some(idx) {\n                let source = str::slice(uuid, 0u, idx);\n-               uuid = str::slice(uuid, idx + 1u, str::char_len(uuid));\n+               uuid = str::slice(uuid, idx + 1u, str::len(uuid));\n                install_uuid_specific(c, wd, source, uuid);\n             }\n             option::none {\n@@ -666,7 +666,7 @@ fn cmd_install(c: cargo) unsafe {\n         alt str::index(name, '/') {\n             option::some(idx) {\n                let source = str::slice(name, 0u, idx);\n-               name = str::slice(name, idx + 1u, str::char_len(name));\n+               name = str::slice(name, idx + 1u, str::len(name));\n                install_named_specific(c, wd, source, name);\n             }\n             option::none {"}, {"sha": "adb9f31f13ecf7ab9401027494ece3e77158692c", "filename": "src/comp/back/link.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2b4f5136a52041a88fbf3a03f627e9c00869f182/src%2Fcomp%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b4f5136a52041a88fbf3a03f627e9c00869f182/src%2Fcomp%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fback%2Flink.rs?ref=2b4f5136a52041a88fbf3a03f627e9c00869f182", "patch": "@@ -396,7 +396,7 @@ fn build_link_meta(sess: session, c: ast::crate, output: str,\n                               metas: provided_metas,\n                               dep_hashes: [str]) -> str {\n         fn len_and_str(s: str) -> str {\n-            ret #fmt[\"%u_%s\", str::byte_len(s), s];\n+            ret #fmt[\"%u_%s\", str::len_bytes(s), s];\n         }\n \n         fn len_and_str_lit(l: ast::lit) -> str {\n@@ -521,7 +521,7 @@ fn mangle(ss: path) -> str {\n \n     for s in ss {\n         alt s { path_name(s) | path_mod(s) {\n-          n += #fmt[\"%u%s\", str::byte_len(s), s];\n+          n += #fmt[\"%u%s\", str::len_bytes(s), s];\n         } }\n     }\n     n += \"E\"; // End name-sequence.\n@@ -573,7 +573,7 @@ fn link_binary(sess: session,\n                  config.os == session::os_freebsd) &&\n                 str::find(filename, \"lib\") == 0 {\n                 ret str::unsafe::slice_bytes(filename, 3u,\n-                               str::byte_len(filename));\n+                               str::len_bytes(filename));\n             } else { ret filename; }\n         };\n         fn rmext(filename: str) -> str {"}, {"sha": "556d3c74ef3b339d57b48ba6b265425f5b17451b", "filename": "src/comp/driver/diagnostic.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2b4f5136a52041a88fbf3a03f627e9c00869f182/src%2Fcomp%2Fdriver%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b4f5136a52041a88fbf3a03f627e9c00869f182/src%2Fcomp%2Fdriver%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fdriver%2Fdiagnostic.rs?ref=2b4f5136a52041a88fbf3a03f627e9c00869f182", "patch": "@@ -210,7 +210,7 @@ fn highlight_lines(cm: codemap::codemap, sp: span,\n     if elided {\n         let last_line = display_lines[vec::len(display_lines) - 1u];\n         let s = #fmt[\"%s:%u \", fm.name, last_line + 1u];\n-        let indent = str::char_len(s);\n+        let indent = str::len(s);\n         let out = \"\";\n         while indent > 0u { out += \" \"; indent -= 1u; }\n         out += \"...\\n\";\n@@ -228,7 +228,7 @@ fn highlight_lines(cm: codemap::codemap, sp: span,\n         while num > 0u { num /= 10u; digits += 1u; }\n \n         // indent past |name:## | and the 0-offset column location\n-        let left = str::char_len(fm.name) + digits + lo.col + 3u;\n+        let left = str::len(fm.name) + digits + lo.col + 3u;\n         let s = \"\";\n         while left > 0u { str::push_char(s, ' '); left -= 1u; }\n "}, {"sha": "0239f3921de743ce6499e1ca5542c63a315d5d8f", "filename": "src/comp/driver/rustc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2b4f5136a52041a88fbf3a03f627e9c00869f182/src%2Fcomp%2Fdriver%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b4f5136a52041a88fbf3a03f627e9c00869f182/src%2Fcomp%2Fdriver%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fdriver%2Frustc.rs?ref=2b4f5136a52041a88fbf3a03f627e9c00869f182", "patch": "@@ -13,7 +13,7 @@ import rustc::driver::diagnostic;\n fn version(argv0: str) {\n     let vers = \"unknown version\";\n     let env_vers = #env[\"CFG_VERSION\"];\n-    if str::byte_len(env_vers) != 0u { vers = env_vers; }\n+    if str::len_bytes(env_vers) != 0u { vers = env_vers; }\n     io::stdout().write_str(#fmt[\"%s %s\\n\", argv0, vers]);\n     io::stdout().write_str(#fmt[\"host: %s\\n\", host_triple()]);\n }"}, {"sha": "79af3f05d5f51b1fd4404c46f892566e561f4bab", "filename": "src/comp/middle/debuginfo.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2b4f5136a52041a88fbf3a03f627e9c00869f182/src%2Fcomp%2Fmiddle%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b4f5136a52041a88fbf3a03f627e9c00869f182/src%2Fcomp%2Fmiddle%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fdebuginfo.rs?ref=2b4f5136a52041a88fbf3a03f627e9c00869f182", "patch": "@@ -48,7 +48,7 @@ const DW_ATE_unsigned_char: int = 0x08;\n \n fn llstr(s: str) -> ValueRef {\n     str::as_buf(s, {|sbuf|\n-        llvm::LLVMMDString(sbuf, str::byte_len(s) as ctypes::c_uint)\n+        llvm::LLVMMDString(sbuf, str::len_bytes(s) as ctypes::c_uint)\n     })\n }\n fn lltag(lltag: int) -> ValueRef {\n@@ -167,8 +167,8 @@ fn create_compile_unit(cx: @crate_ctxt, full_path: str)\n \n     let work_dir = cx.sess.working_dir;\n     let file_path = if str::starts_with(full_path, work_dir) {\n-        str::unsafe::slice_bytes(full_path, str::byte_len(work_dir),\n-                   str::byte_len(full_path))\n+        str::unsafe::slice_bytes(full_path, str::len_bytes(work_dir),\n+                   str::len_bytes(full_path))\n     } else {\n         full_path\n     };"}, {"sha": "c8965bd3f60e52d8a39494c2e6bded29c5e408ba", "filename": "src/comp/middle/trans/common.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2b4f5136a52041a88fbf3a03f627e9c00869f182/src%2Fcomp%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b4f5136a52041a88fbf3a03f627e9c00869f182/src%2Fcomp%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans%2Fcommon.rs?ref=2b4f5136a52041a88fbf3a03f627e9c00869f182", "patch": "@@ -767,7 +767,7 @@ fn C_u8(i: uint) -> ValueRef { ret C_integral(T_i8(), i as u64, False); }\n // our boxed-and-length-annotated strings.\n fn C_cstr(cx: @crate_ctxt, s: str) -> ValueRef {\n     let sc = str::as_buf(s) {|buf|\n-        llvm::LLVMConstString(buf, str::byte_len(s) as unsigned, False)\n+        llvm::LLVMConstString(buf, str::len_bytes(s) as unsigned, False)\n     };\n     let g =\n         str::as_buf(cx.names(\"str\"),\n@@ -781,7 +781,7 @@ fn C_cstr(cx: @crate_ctxt, s: str) -> ValueRef {\n // Returns a Plain Old LLVM String:\n fn C_postr(s: str) -> ValueRef {\n     ret str::as_buf(s) {|buf|\n-        llvm::LLVMConstString(buf, str::byte_len(s) as unsigned, False)\n+        llvm::LLVMConstString(buf, str::len_bytes(s) as unsigned, False)\n     };\n }\n "}, {"sha": "a3700ca423e4949d165f5db55945e708aa72361c", "filename": "src/comp/middle/trans/tvec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2b4f5136a52041a88fbf3a03f627e9c00869f182/src%2Fcomp%2Fmiddle%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b4f5136a52041a88fbf3a03f627e9c00869f182/src%2Fcomp%2Fmiddle%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans%2Ftvec.rs?ref=2b4f5136a52041a88fbf3a03f627e9c00869f182", "patch": "@@ -130,7 +130,7 @@ fn trans_vec(bcx: @block_ctxt, args: [@ast::expr], id: ast::node_id,\n }\n \n fn trans_str(bcx: @block_ctxt, s: str, dest: dest) -> @block_ctxt {\n-    let veclen = str::byte_len(s) + 1u; // +1 for \\0\n+    let veclen = str::len_bytes(s) + 1u; // +1 for \\0\n     let {bcx: bcx, val: sptr, _} =\n         alloc(bcx, ty::mk_str(bcx_tcx(bcx)), veclen);\n "}, {"sha": "ba66cb78a15c304b45f91a6cddbd6e7d92d2fde5", "filename": "src/comp/syntax/ext/qquote.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2b4f5136a52041a88fbf3a03f627e9c00869f182/src%2Fcomp%2Fsyntax%2Fext%2Fqquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b4f5136a52041a88fbf3a03f627e9c00869f182/src%2Fcomp%2Fsyntax%2Fext%2Fqquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fext%2Fqquote.rs?ref=2b4f5136a52041a88fbf3a03f627e9c00869f182", "patch": "@@ -202,7 +202,7 @@ fn expand_qquote<N: qq_helper>\n         if (j < g_len && i == cx.gather[j].lo) {\n             assert ch == '$';\n             let repl = #fmt(\"$%u \", j);\n-            state = skip(str::char_len(repl));\n+            state = skip(str::len(repl));\n             str2 += repl;\n         }\n         alt state {"}, {"sha": "300d0a66f1db2287d21cb61b27bee94a516b5a27", "filename": "src/comp/syntax/parse/lexer.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/2b4f5136a52041a88fbf3a03f627e9c00869f182/src%2Fcomp%2Fsyntax%2Fparse%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b4f5136a52041a88fbf3a03f627e9c00869f182/src%2Fcomp%2Fsyntax%2Fparse%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fparse%2Flexer.rs?ref=2b4f5136a52041a88fbf3a03f627e9c00869f182", "patch": "@@ -58,7 +58,7 @@ fn new_reader(cm: codemap::codemap,\n               itr: @interner::interner<str>) -> reader {\n     let r = @{cm: cm,\n               span_diagnostic: span_diagnostic,\n-              src: filemap.src, len: str::byte_len(*filemap.src),\n+              src: filemap.src, len: str::len_bytes(*filemap.src),\n               mutable col: 0u, mutable pos: 0u, mutable curr: -1 as char,\n               mutable chpos: filemap.start_pos.ch, mutable strs: [],\n               filemap: filemap, interner: itr};\n@@ -157,7 +157,7 @@ fn scan_exponent(rdr: reader) -> option<str> {\n             rdr.bump();\n         }\n         let exponent = scan_digits(rdr, 10u);\n-        if str::byte_len(exponent) > 0u {\n+        if str::len_bytes(exponent) > 0u {\n             ret some(rslt + exponent);\n         } else { rdr.fatal(\"scan_exponent: bad fp literal\"); }\n     } else { ret none::<str>; }\n@@ -220,7 +220,7 @@ fn scan_number(c: char, rdr: reader) -> token::token {\n             tp = if signed { either::left(ast::ty_i64) }\n                       else { either::right(ast::ty_u64) };\n         }\n-        if str::byte_len(num_str) == 0u {\n+        if str::len_bytes(num_str) == 0u {\n             rdr.fatal(\"no valid digits found for number\");\n         }\n         let parsed = u64::from_str(num_str, base as u64);\n@@ -267,7 +267,7 @@ fn scan_number(c: char, rdr: reader) -> token::token {\n         ret token::LIT_FLOAT(interner::intern(*rdr.interner, num_str),\n                              ast::ty_f);\n     } else {\n-        if str::byte_len(num_str) == 0u {\n+        if str::len_bytes(num_str) == 0u {\n             rdr.fatal(\"no valid digits found for number\");\n         }\n         let parsed = u64::from_str(num_str, base as u64);\n@@ -604,8 +604,8 @@ fn trim_whitespace_prefix_and_push_line(&lines: [str],\n                                         s: str, col: uint) unsafe {\n     let s1;\n     if all_whitespace(s, 0u, col) {\n-        if col < str::byte_len(s) {\n-            s1 = str::unsafe::slice_bytes(s, col, str::byte_len(s));\n+        if col < str::len_bytes(s) {\n+            s1 = str::unsafe::slice_bytes(s, col, str::len_bytes(s));\n         } else { s1 = \"\"; }\n     } else { s1 = s; }\n     log(debug, \"pushing line: \" + s1);\n@@ -645,7 +645,7 @@ fn read_block_comment(rdr: reader, code_to_the_left: bool) -> cmnt {\n             }\n         }\n     }\n-    if str::byte_len(curr_line) != 0u {\n+    if str::len_bytes(curr_line) != 0u {\n         trim_whitespace_prefix_and_push_line(lines, curr_line, col);\n     }\n     let style = if code_to_the_left { trailing } else { isolated };"}, {"sha": "3ee31314299291cf31542cb6c0261ca033e91d5a", "filename": "src/comp/syntax/print/pp.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2b4f5136a52041a88fbf3a03f627e9c00869f182/src%2Fcomp%2Fsyntax%2Fprint%2Fpp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b4f5136a52041a88fbf3a03f627e9c00869f182/src%2Fcomp%2Fsyntax%2Fprint%2Fpp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fprint%2Fpp.rs?ref=2b4f5136a52041a88fbf3a03f627e9c00869f182", "patch": "@@ -491,7 +491,7 @@ fn end(p: printer) { p.pretty_print(END); }\n fn eof(p: printer) { p.pretty_print(EOF); }\n \n fn word(p: printer, wrd: str) {\n-    p.pretty_print(STRING(wrd, str::char_len(wrd) as int));\n+    p.pretty_print(STRING(wrd, str::len(wrd) as int));\n }\n \n fn huge_word(p: printer, wrd: str) {"}, {"sha": "047653cc4c98f1c54ce05f76bcfb539f373c6ee7", "filename": "src/comp/syntax/print/pprust.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2b4f5136a52041a88fbf3a03f627e9c00869f182/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b4f5136a52041a88fbf3a03f627e9c00869f182/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs?ref=2b4f5136a52041a88fbf3a03f627e9c00869f182", "patch": "@@ -201,7 +201,7 @@ fn head(s: ps, w: str) {\n     // outer-box is consistent\n     cbox(s, indent_unit);\n     // head-box is inconsistent\n-    ibox(s, str::char_len(w) + 1u);\n+    ibox(s, str::len(w) + 1u);\n     // keyword that starts the head\n     word_nbsp(s, w);\n }\n@@ -1458,7 +1458,7 @@ fn print_ty_fn(s: ps, opt_proto: option<ast::proto>,\n     popen(s);\n     fn print_arg(s: ps, input: ast::arg) {\n         print_arg_mode(s, input.mode);\n-        if str::byte_len(input.ident) > 0u {\n+        if str::len_bytes(input.ident) > 0u {\n             word_space(s, input.ident + \":\");\n         }\n         print_type(s, input.ty);\n@@ -1640,7 +1640,7 @@ fn print_string(s: ps, st: str) {\n \n fn escape_str(st: str, to_escape: char) -> str {\n     let out: str = \"\";\n-    let len = str::byte_len(st);\n+    let len = str::len_bytes(st);\n     let i = 0u;\n     while i < len {\n         alt st[i] as char {"}, {"sha": "03bbeb0d538947acb0046f3acae49b331cd217d9", "filename": "src/comp/util/ppaux.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2b4f5136a52041a88fbf3a03f627e9c00869f182/src%2Fcomp%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b4f5136a52041a88fbf3a03f627e9c00869f182/src%2Fcomp%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Futil%2Fppaux.rs?ref=2b4f5136a52041a88fbf3a03f627e9c00869f182", "patch": "@@ -132,7 +132,7 @@ fn ty_to_str(cx: ctxt, typ: t) -> str {\n \n fn ty_to_short_str(cx: ctxt, typ: t) -> str unsafe {\n     let s = encoder::encoded_ty(cx, typ);\n-    if str::byte_len(s) >= 32u { s = str::unsafe::slice_bytes(s, 0u, 32u); }\n+    if str::len_bytes(s) >= 32u { s = str::unsafe::slice_bytes(s, 0u, 32u); }\n     ret s;\n }\n "}, {"sha": "9d81b6f00e209aea1382cbf90a8f5e72e75784bb", "filename": "src/compiletest/errors.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2b4f5136a52041a88fbf3a03f627e9c00869f182/src%2Fcompiletest%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b4f5136a52041a88fbf3a03f627e9c00869f182/src%2Fcompiletest%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Ferrors.rs?ref=2b4f5136a52041a88fbf3a03f627e9c00869f182", "patch": "@@ -26,12 +26,12 @@ fn parse_expected(line_num: uint, line: str) -> [expected_error] unsafe {\n     let error_tag = \"//!\";\n     let idx0 = str::find(line, error_tag);\n     if idx0 < 0 { ret []; }\n-    let idx = (idx0 as uint) + str::byte_len(error_tag);\n+    let idx = (idx0 as uint) + str::len_bytes(error_tag);\n \n     // \"//!^^^ kind msg\" denotes a message expected\n     // three lines above current line:\n     let adjust_line = 0u;\n-    let len = str::byte_len(line);\n+    let len = str::len_bytes(line);\n     while idx < len && line[idx] == ('^' as u8) {\n         adjust_line += 1u;\n         idx += 1u;"}, {"sha": "f9c7a7a66e05b05961a7d73bf1f02ee566f53c4f", "filename": "src/compiletest/header.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2b4f5136a52041a88fbf3a03f627e9c00869f182/src%2Fcompiletest%2Fheader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b4f5136a52041a88fbf3a03f627e9c00869f182/src%2Fcompiletest%2Fheader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fheader.rs?ref=2b4f5136a52041a88fbf3a03f627e9c00869f182", "patch": "@@ -109,8 +109,8 @@ fn parse_name_value_directive(line: str,\n     if str::find(line, keycolon) >= 0 {\n         let colon = str::find(line, keycolon) as uint;\n         let value =\n-            str::unsafe::slice_bytes(line, colon + str::byte_len(keycolon),\n-                       str::byte_len(line));\n+            str::unsafe::slice_bytes(line, colon + str::len_bytes(keycolon),\n+                       str::len_bytes(line));\n         #debug(\"%s: %s\", directive,  value);\n         option::some(value)\n     } else { option::none }"}, {"sha": "f6d5f72c367f1596298a65c73364b9fcbf47aade", "filename": "src/fuzzer/fuzzer.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2b4f5136a52041a88fbf3a03f627e9c00869f182/src%2Ffuzzer%2Ffuzzer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b4f5136a52041a88fbf3a03f627e9c00869f182/src%2Ffuzzer%2Ffuzzer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ffuzzer%2Ffuzzer.rs?ref=2b4f5136a52041a88fbf3a03f627e9c00869f182", "patch": "@@ -285,7 +285,7 @@ fn check_variants_T<T: copy>(\n \n fn last_part(filename: str) -> str {\n   let ix = option::get(str::rindex(filename, '/'));\n-  str::slice(filename, ix + 1u, str::char_len(filename) - 3u)\n+  str::slice(filename, ix + 1u, str::len(filename) - 3u)\n }\n \n enum happiness { passed, cleanly_rejected(str), known_bug(str), failed(str), }\n@@ -333,7 +333,7 @@ fn removeDirIfExists(filename: str) {\n fn check_running(exe_filename: str) -> happiness {\n     let p = std::run::program_output(\"/Users/jruderman/scripts/timed_run_rust_program.py\", [exe_filename]);\n     let comb = p.out + \"\\n\" + p.err;\n-    if str::byte_len(comb) > 1u {\n+    if str::len_bytes(comb) > 1u {\n         log(error, \"comb comb comb: \" + comb);\n     }\n "}, {"sha": "30676e34de831b0409af02a9d052f21ecca596fc", "filename": "src/libcore/extfmt.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/2b4f5136a52041a88fbf3a03f627e9c00869f182/src%2Flibcore%2Fextfmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b4f5136a52041a88fbf3a03f627e9c00869f182/src%2Flibcore%2Fextfmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fextfmt.rs?ref=2b4f5136a52041a88fbf3a03f627e9c00869f182", "patch": "@@ -82,10 +82,10 @@ mod ct {\n \n     fn parse_fmt_string(s: str, error: error_fn) -> [piece] unsafe {\n         let pieces: [piece] = [];\n-        let lim = str::byte_len(s);\n+        let lim = str::len_bytes(s);\n         let buf = \"\";\n         fn flush_buf(buf: str, &pieces: [piece]) -> str {\n-            if str::byte_len(buf) > 0u {\n+            if str::len_bytes(buf) > 0u {\n                 let piece = piece_string(buf);\n                 pieces += [piece];\n             }\n@@ -325,7 +325,7 @@ mod rt {\n             alt cv.precision {\n               count_implied { s }\n               count_is(max) {\n-                if max as uint < str::char_len(s) {\n+                if max as uint < str::len(s) {\n                     str::substr(s, 0u, max as uint)\n                 } else { s }\n               }\n@@ -368,7 +368,7 @@ mod rt {\n                 \"\"\n             } else {\n                 let s = uint::to_str(num, radix);\n-                let len = str::char_len(s);\n+                let len = str::len(s);\n                 if len < prec {\n                     let diff = prec - len;\n                     let pad = str_init_elt(diff, '0');\n@@ -400,7 +400,7 @@ mod rt {\n             uwidth = width as uint;\n           }\n         }\n-        let strlen = str::char_len(s);\n+        let strlen = str::len(s);\n         if uwidth <= strlen { ret s; }\n         let padchar = ' ';\n         let diff = uwidth - strlen;\n@@ -433,12 +433,12 @@ mod rt {\n         // zeros. It may make sense to convert zero padding to a precision\n         // instead.\n \n-        if signed && zero_padding && str::byte_len(s) > 0u {\n+        if signed && zero_padding && str::len_bytes(s) > 0u {\n             let head = s[0];\n             if head == '+' as u8 || head == '-' as u8 || head == ' ' as u8 {\n                 let headstr = str::from_bytes([head]);\n                 // FIXME: not UTF-8 safe\n-                let bytelen = str::byte_len(s);\n+                let bytelen = str::len_bytes(s);\n                 let numpart = str::unsafe::slice_bytes(s, 1u, bytelen);\n                 ret headstr + padstr + numpart;\n             }"}, {"sha": "5b9f1ce3636551f4d0c3665bd6fff1b466db4bd9", "filename": "src/libcore/float.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2b4f5136a52041a88fbf3a03f627e9c00869f182/src%2Flibcore%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b4f5136a52041a88fbf3a03f627e9c00869f182/src%2Flibcore%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffloat.rs?ref=2b4f5136a52041a88fbf3a03f627e9c00869f182", "patch": "@@ -128,7 +128,7 @@ fn from_str(num: str) -> float {\n \n    let pos = 0u;                  //Current byte position in the string.\n                                   //Used to walk the string in O(n).\n-   let len = str::byte_len(num);  //Length of the string, in bytes.\n+   let len = str::len_bytes(num);  //Length of the string, in bytes.\n \n    if len == 0u { ret 0.; }\n    let total = 0f;                //Accumulated result"}, {"sha": "c9f4291403205d37bbde2741d65295ead43e1de1", "filename": "src/libcore/str.rs", "status": "modified", "additions": 28, "deletions": 25, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/2b4f5136a52041a88fbf3a03f627e9c00869f182/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b4f5136a52041a88fbf3a03f627e9c00869f182/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=2b4f5136a52041a88fbf3a03f627e9c00869f182", "patch": "@@ -79,8 +79,8 @@ export\n    is_empty,\n    is_not_empty,\n    is_whitespace,\n-   byte_len,\n-   char_len,\n+   len_bytes,\n+   len_chars, len,\n \n    // Misc\n    // FIXME: perhaps some more of this section shouldn't be exported?\n@@ -473,7 +473,7 @@ fn split_str(ss: str, sep: str) -> [str] unsafe {\n     // unsafe is justified: we are splitting\n     // UTF-8 with UTF-8, so the results will be OK\n \n-    let sep_len = str::byte_len(sep);\n+    let sep_len = len_bytes(sep);\n     assert sep_len > 0u;\n     let vv = [];\n     let start = 0u, start_match = 0u, current = 0u, matching = 0u;\n@@ -525,7 +525,7 @@ fn split(ss: str, sepfn: fn(cc: char)->bool) -> [str] {\n         }\n     });\n \n-    if char_len(accum) >= 0u || ends_with_sep {\n+    if len(accum) >= 0u || ends_with_sep {\n         vv += [accum];\n     }\n \n@@ -597,7 +597,7 @@ separated by whitespace\n */\n fn words(ss: str) -> [str] {\n     ret vec::filter( split(ss, {|cc| char::is_whitespace(cc)}),\n-                     {|w| 0u < str::char_len(w)});\n+                     {|w| 0u < str::len(w)});\n }\n \n /*\n@@ -607,7 +607,7 @@ Create a vector of substrings of size `nn`\n */\n fn windowed(nn: uint, ss: str) -> [str] {\n     let ww = [];\n-    let len = str::char_len(ss);\n+    let len = str::len(ss);\n \n     assert 1u <= nn;\n \n@@ -667,7 +667,7 @@ fn replace(s: str, from: str, to: str) : is_not_empty(from) -> str unsafe {\n             ret s;\n         }\n         ret slice(s, 0u, idx as uint) + to +\n-            replace(slice(s, idx as uint + char_len(from), char_len(s)),\n+            replace(slice(s, idx as uint + len(from), len(s)),\n                     from, to);\n     }\n }\n@@ -856,7 +856,7 @@ fn index(ss: str, cc: char) -> option<uint> {\n // (as option some/none)\n fn rindex(ss: str, cc: char) -> option<uint> {\n     let bii = byte_len(ss);\n-    let cii = char_len(ss);\n+    let cii = len(ss);\n     while bii > 0u {\n         let {ch, prev} = char_range_at_reverse(ss, bii);\n         cii -= 1u;\n@@ -947,8 +947,8 @@ haystack - The string to look in\n needle - The string to look for\n */\n fn ends_with(haystack: str, needle: str) -> bool {\n-    let haystack_len: uint = char_len(haystack);\n-    let needle_len: uint = char_len(needle);\n+    let haystack_len: uint = len(haystack);\n+    let needle_len: uint = len(needle);\n     ret if needle_len == 0u {\n             true\n         } else if needle_len > haystack_len {\n@@ -997,14 +997,12 @@ fn is_whitespace(s: str) -> bool {\n     ret all(s, char::is_whitespace);\n }\n \n-/*\n-Function: byte_len\n-\n-Returns the length in bytes of a string\n \n-FIXME: rename to 'len_bytes'\n-*/\n-pure fn byte_len(s: str) -> uint unsafe {\n+// Function: len_bytes\n+//\n+// Returns the string length in bytes\n+// (Synonym: byte_len)\n+pure fn len_bytes(s: str) -> uint unsafe {\n     as_bytes(s) { |v|\n         let vlen = vec::len(v);\n         // There should always be a null terminator\n@@ -1013,17 +1011,22 @@ pure fn byte_len(s: str) -> uint unsafe {\n     }\n }\n \n-/*\n-Function: char_len\n-\n-Count the number of unicode characters in a string\n+// FIXME: remove\n+pure fn byte_len(s: str) -> uint unsafe { len_bytes(s) }\n \n-FIXME: rename to 'len_chars'\n-*/\n-fn char_len(s: str) -> uint {\n-    ret char_len_range(s, 0u, byte_len(s));\n+// Function: len\n+//\n+// String length or size in characters.\n+// (Synonyms: len_chars, char_len)\n+fn len(s: str) -> uint {\n+    char_len_range(s, 0u, byte_len(s))\n }\n \n+fn len_chars(s: str) -> uint { len(s) }\n+\n+// FIXME: remove\n+fn char_len(s: str) -> uint { len(s) }\n+\n /*\n Section: Misc\n */"}, {"sha": "e169b6192dbe50ae6f87fe02941c719758903022", "filename": "src/libcore/u64.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2b4f5136a52041a88fbf3a03f627e9c00869f182/src%2Flibcore%2Fu64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b4f5136a52041a88fbf3a03f627e9c00869f182/src%2Flibcore%2Fu64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fu64.rs?ref=2b4f5136a52041a88fbf3a03f627e9c00869f182", "patch": "@@ -118,11 +118,11 @@ Function: from_str\n Parse a string as an unsigned integer.\n */\n fn from_str(buf: str, radix: u64) -> u64 {\n-    if str::byte_len(buf) == 0u {\n+    if str::len_bytes(buf) == 0u {\n         #error(\"parse_buf(): buf is empty\");\n         fail;\n     }\n-    let i = str::byte_len(buf) - 1u;\n+    let i = str::len_bytes(buf) - 1u;\n     let power = 1u64, n = 0u64;\n     while true {\n         let digit = char::to_digit(buf[i] as char) as u64;"}, {"sha": "22b2a95f3cbdf2b7897740122d79f5805bea34e6", "filename": "src/libcore/uint.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2b4f5136a52041a88fbf3a03f627e9c00869f182/src%2Flibcore%2Fuint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b4f5136a52041a88fbf3a03f627e9c00869f182/src%2Flibcore%2Fuint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fuint.rs?ref=2b4f5136a52041a88fbf3a03f627e9c00869f182", "patch": "@@ -256,7 +256,7 @@ fn to_str(num: uint, radix: uint) -> str {\n         n /= radix;\n     }\n     let s1: str = \"\";\n-    let len: uint = str::byte_len(s);\n+    let len: uint = str::len_bytes(s);\n     while len != 0u { len -= 1u; s1 += str::from_byte(s[len]); }\n     ret s1;\n }"}, {"sha": "947942e20d86da1781c2163f10d8a724c34f5ecb", "filename": "src/libstd/fs.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2b4f5136a52041a88fbf3a03f627e9c00869f182/src%2Flibstd%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b4f5136a52041a88fbf3a03f627e9c00869f182/src%2Flibstd%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffs.rs?ref=2b4f5136a52041a88fbf3a03f627e9c00869f182", "patch": "@@ -45,7 +45,7 @@ fn splitDirnameBasename (pp: path) -> {dirname: str, basename: str} {\n     }\n \n     ret {dirname: str::slice(pp, 0u, ii),\n-         basename: str::slice(pp, ii + 1u, str::char_len(pp))};\n+         basename: str::slice(pp, ii + 1u, str::len(pp))};\n }\n \n /*\n@@ -93,8 +93,8 @@ fn connect(pre: path, post: path) -> path unsafe {\n     let pre_ = pre;\n     let post_ = post;\n     let sep = os_fs::path_sep as u8;\n-    let pre_len = str::byte_len(pre);\n-    let post_len = str::byte_len(post);\n+    let pre_len = str::len_bytes(pre);\n+    let post_len = str::len_bytes(post);\n     if pre_len > 1u && pre[pre_len-1u] == sep { str::unsafe::pop_byte(pre_); }\n     if post_len > 1u && post[0] == sep { str::unsafe::shift_byte(post_); }\n     ret pre_ + path_sep() + post_;\n@@ -171,7 +171,7 @@ Lists the contents of a directory.\n */\n fn list_dir(p: path) -> [str] {\n     let p = p;\n-    let pl = str::byte_len(p);\n+    let pl = str::len_bytes(p);\n     if pl == 0u || p[pl - 1u] as char != os_fs::path_sep { p += path_sep(); }\n     let full_paths: [str] = [];\n     for filename: str in os_fs::list_dir(p) {\n@@ -337,7 +337,7 @@ fn normalize(p: path) -> path {\n     let s = reabsolute(p, s);\n     let s = reterminate(p, s);\n \n-    let s = if str::byte_len(s) == 0u {\n+    let s = if str::len_bytes(s) == 0u {\n         \".\"\n     } else {\n         s\n@@ -404,7 +404,7 @@ fn normalize(p: path) -> path {\n     }\n \n     fn reterminate(orig: path, new: path) -> path {\n-        let last = orig[str::byte_len(orig) - 1u];\n+        let last = orig[str::len_bytes(orig) - 1u];\n         if last == os_fs::path_sep as u8\n             || last == os_fs::path_sep as u8 {\n             ret new + path_sep();"}, {"sha": "00187aee01f8f78a603964de8b09ea968764a1f5", "filename": "src/libstd/getopts.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2b4f5136a52041a88fbf3a03f627e9c00869f182/src%2Flibstd%2Fgetopts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b4f5136a52041a88fbf3a03f627e9c00869f182/src%2Flibstd%2Fgetopts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fgetopts.rs?ref=2b4f5136a52041a88fbf3a03f627e9c00869f182", "patch": "@@ -79,7 +79,7 @@ A description of a possible option\n type opt = {name: name, hasarg: hasarg, occur: occur};\n \n fn mkname(nm: str) -> name {\n-    ret if str::char_len(nm) == 1u {\n+    ret if str::len(nm) == 1u {\n             short(str::char_at(nm, 0u))\n         } else { long(nm) };\n }\n@@ -141,7 +141,7 @@ of matches and a vector of free strings.\n type match = {opts: [opt], vals: [mutable [optval]], free: [str]};\n \n fn is_arg(arg: str) -> bool {\n-    ret str::byte_len(arg) > 1u && arg[0] == '-' as u8;\n+    ret str::len_bytes(arg) > 1u && arg[0] == '-' as u8;\n }\n \n fn name_str(nm: name) -> str {\n@@ -218,7 +218,7 @@ fn getopts(args: [str], opts: [opt]) -> result unsafe {\n     let i = 0u;\n     while i < l {\n         let cur = args[i];\n-        let curlen = str::byte_len(cur);\n+        let curlen = str::len_bytes(cur);\n         if !is_arg(cur) {\n             free += [cur];\n         } else if str::eq(cur, \"--\") {"}, {"sha": "127cd93952e78563e4d411d3ae5b3b952a004fb7", "filename": "src/libstd/json.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/2b4f5136a52041a88fbf3a03f627e9c00869f182/src%2Flibstd%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b4f5136a52041a88fbf3a03f627e9c00869f182/src%2Flibstd%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fjson.rs?ref=2b4f5136a52041a88fbf3a03f627e9c00869f182", "patch": "@@ -70,13 +70,13 @@ fn to_str(j: json) -> str {\n }\n \n fn rest(s: str) -> str {\n-    assert(str::char_len(s) >= 1u);\n-    str::slice(s, 1u, str::char_len(s))\n+    assert(str::len(s) >= 1u);\n+    str::slice(s, 1u, str::len(s))\n }\n \n fn from_str_str(s: str) -> (option<json>, str) {\n     let pos = 0u;\n-    let len = str::byte_len(s);\n+    let len = str::len_bytes(s);\n     let escape = false;\n     let res = \"\";\n \n@@ -99,7 +99,7 @@ fn from_str_str(s: str) -> (option<json>, str) {\n             cont;\n         } else if (c == '\"') {\n             ret (some(string(res)),\n-                 str::slice(s, pos, str::char_len(s)));\n+                 str::slice(s, pos, str::len(s)));\n         }\n         res = res + str::from_char(c);\n     }\n@@ -172,7 +172,7 @@ fn from_str_dict(s: str) -> (option<json>, str) {\n \n fn from_str_float(s: str) -> (option<json>, str) {\n     let pos = 0u;\n-    let len = str::byte_len(s);\n+    let len = str::len_bytes(s);\n     let res = 0f;\n     let neg = 1f;\n \n@@ -200,12 +200,12 @@ fn from_str_float(s: str) -> (option<json>, str) {\n             }\n             '.' { break; }\n             _ { ret (some(num(neg * res)),\n-                     str::slice(s, opos, str::char_len(s))); }\n+                     str::slice(s, opos, str::len(s))); }\n         }\n     }\n \n     if pos == len {\n-        ret (some(num(neg * res)), str::slice(s, pos, str::char_len(s)));\n+        ret (some(num(neg * res)), str::slice(s, pos, str::len(s)));\n     }\n \n     let dec = 1f;\n@@ -220,25 +220,25 @@ fn from_str_float(s: str) -> (option<json>, str) {\n                 res += (((c as int) - ('0' as int)) as float) * dec;\n             }\n             _ { ret (some(num(neg * res)),\n-                     str::slice(s, opos, str::char_len(s))); }\n+                     str::slice(s, opos, str::len(s))); }\n         }\n     }\n-    ret (some(num(neg * res)), str::slice(s, pos, str::char_len(s)));\n+    ret (some(num(neg * res)), str::slice(s, pos, str::len(s)));\n }\n \n fn from_str_bool(s: str) -> (option<json>, str) {\n     if (str::starts_with(s, \"true\")) {\n-        (some(boolean(true)), str::slice(s, 4u, str::char_len(s)))\n+        (some(boolean(true)), str::slice(s, 4u, str::len(s)))\n     } else if (str::starts_with(s, \"false\")) {\n-        (some(boolean(false)), str::slice(s, 5u, str::char_len(s)))\n+        (some(boolean(false)), str::slice(s, 5u, str::len(s)))\n     } else {\n         (none, s)\n     }\n }\n \n fn from_str_null(s: str) -> (option<json>, str) {\n     if (str::starts_with(s, \"null\")) {\n-        (some(null), str::slice(s, 4u, str::char_len(s)))\n+        (some(null), str::slice(s, 4u, str::len(s)))\n     } else {\n         (none, s)\n     }"}, {"sha": "35525b70710ac4f6a6cb0514758e041a1c3064f2", "filename": "src/libstd/rand.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2b4f5136a52041a88fbf3a03f627e9c00869f182/src%2Flibstd%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b4f5136a52041a88fbf3a03f627e9c00869f182/src%2Flibstd%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand.rs?ref=2b4f5136a52041a88fbf3a03f627e9c00869f182", "patch": "@@ -77,7 +77,7 @@ fn mk_rng() -> rng {\n             let i = 0u;\n             while (i < len) {\n                 let n = rustrt::rand_next(**self) as uint %\n-                    str::char_len(charset);\n+                    str::len(charset);\n                 s = s + str::from_char(str::char_at(charset, n));\n                 i += 1u;\n             }\n@@ -130,8 +130,8 @@ mod tests {\n         log(debug, r.gen_str(10u));\n         log(debug, r.gen_str(10u));\n         log(debug, r.gen_str(10u));\n-        assert(str::char_len(r.gen_str(10u)) == 10u);\n-        assert(str::char_len(r.gen_str(16u)) == 16u);\n+        assert(str::len(r.gen_str(10u)) == 10u);\n+        assert(str::len(r.gen_str(16u)) == 16u);\n     }\n }\n "}, {"sha": "c329cdd34948a7b1fddf04a4dd16fac4be077919", "filename": "src/libstd/rope.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/2b4f5136a52041a88fbf3a03f627e9c00869f182/src%2Flibstd%2Frope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b4f5136a52041a88fbf3a03f627e9c00869f182/src%2Flibstd%2Frope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frope.rs?ref=2b4f5136a52041a88fbf3a03f627e9c00869f182", "patch": "@@ -65,7 +65,7 @@ Performance notes:\n - the function runs in linear time.\n  */\n fn of_str(str: @str) -> rope {\n-    ret of_substr(str, 0u, str::byte_len(*str));\n+    ret of_substr(str, 0u, str::len_bytes(*str));\n }\n \n /*\n@@ -93,7 +93,7 @@ Safety notes:\n  */\n fn of_substr(str: @str, byte_offset: uint, byte_len: uint) -> rope {\n     if byte_len == 0u { ret node::empty; }\n-    if byte_offset + byte_len  > str::byte_len(*str) { fail; }\n+    if byte_offset + byte_len  > str::len_bytes(*str) { fail; }\n     ret node::content(node::of_substr(str, byte_offset, byte_len));\n }\n \n@@ -540,6 +540,7 @@ pure fn char_len(rope: rope) -> uint {\n  Returns: The number of bytes in the rope\n \n  Performance note: Constant time.\n+ FIXME: char or byte?\n  */\n pure fn byte_len(rope: rope) -> uint {\n    alt(rope) {\n@@ -720,7 +721,7 @@ mod node {\n     the length of `str`.\n      */\n     fn of_str(str: @str) -> @node {\n-        ret of_substr(str, 0u, str::byte_len(*str));\n+        ret of_substr(str, 0u, str::len_bytes(*str));\n     }\n \n     /*\n@@ -767,7 +768,7 @@ mod node {\n     */\n     fn of_substr_unsafer(str: @str, byte_start: uint, byte_len: uint,\n                           char_len: uint) -> @node {\n-        assert(byte_start + byte_len <= str::byte_len(*str));\n+        assert(byte_start + byte_len <= str::len_bytes(*str));\n         let candidate = @leaf({\n                 byte_offset: byte_start,\n                 byte_len:    byte_len,\n@@ -1372,7 +1373,7 @@ mod tests {\n         let sample = @\"0123456789ABCDE\";\n         let r      = of_str(sample);\n \n-        assert char_len(r) == str::char_len(*sample);\n+        assert char_len(r) == str::len(*sample);\n         assert rope_to_string(r) == *sample;\n     }\n \n@@ -1383,11 +1384,11 @@ mod tests {\n         while i < 10 { *buf = *buf + *buf; i+=1;}\n         let sample = @*buf;\n         let r      = of_str(sample);\n-        assert char_len(r) == str::char_len(*sample);\n+        assert char_len(r) == str::len(*sample);\n         assert rope_to_string(r) == *sample;\n \n         let string_iter = 0u;\n-        let string_len  = str::byte_len(*sample);\n+        let string_len  = str::len_bytes(*sample);\n         let rope_iter   = iterator::char::start(r);\n         let equal       = true;\n         let pos         = 0u;\n@@ -1426,7 +1427,7 @@ mod tests {\n             }\n         }\n \n-        assert len == str::char_len(*sample);\n+        assert len == str::len(*sample);\n     }\n \n     #[test]"}, {"sha": "c28d67a7526cd47271a2532bc7b9efa4a5d57d68", "filename": "src/libstd/sha1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2b4f5136a52041a88fbf3a03f627e9c00869f182/src%2Flibstd%2Fsha1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b4f5136a52041a88fbf3a03f627e9c00869f182/src%2Flibstd%2Fsha1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsha1.rs?ref=2b4f5136a52041a88fbf3a03f627e9c00869f182", "patch": "@@ -368,7 +368,7 @@ mod tests {\n \n         // Test that it works when accepting the message in pieces\n         for t: test in tests {\n-            let len = str::byte_len(t.input);\n+            let len = str::len_bytes(t.input);\n             let left = len;\n             while left > 0u {\n                 let take = (left + 1u) / 2u;"}, {"sha": "4be1b43d50eae7129c46ab010a952485c438c562", "filename": "src/rustdoc/desc_to_brief_pass.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2b4f5136a52041a88fbf3a03f627e9c00869f182/src%2Frustdoc%2Fdesc_to_brief_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b4f5136a52041a88fbf3a03f627e9c00869f182/src%2Frustdoc%2Fdesc_to_brief_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fdesc_to_brief_pass.rs?ref=2b4f5136a52041a88fbf3a03f627e9c00869f182", "patch": "@@ -240,7 +240,7 @@ fn parse_desc(desc: str) -> (option<str>, option<str>) {\n \n     if check vec::is_not_empty(paras) {\n         let maybe_brief = vec::head(paras);\n-        if str::char_len(maybe_brief) <= max_brief_len {\n+        if str::len(maybe_brief) <= max_brief_len {\n             let desc_paras = vec::tail(paras);\n             let desc = if vec::is_not_empty(desc_paras) {\n                 some(str::connect(desc_paras, \"\\n\\n\"))"}, {"sha": "b52316ccb15b9c05eb8d98873d61a2dacf170856", "filename": "src/rustdoc/unindent_pass.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2b4f5136a52041a88fbf3a03f627e9c00869f182/src%2Frustdoc%2Funindent_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b4f5136a52041a88fbf3a03f627e9c00869f182/src%2Frustdoc%2Funindent_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Funindent_pass.rs?ref=2b4f5136a52041a88fbf3a03f627e9c00869f182", "patch": "@@ -67,8 +67,8 @@ fn unindent(s: str) -> str {\n             if str::is_whitespace(line) {\n                 line\n             } else {\n-                assert str::byte_len(line) >= min_indent;\n-                str::slice(line, min_indent, str::char_len(line))\n+                assert str::len_bytes(line) >= min_indent;\n+                str::slice(line, min_indent, str::len(line))\n             }\n         };\n         str::connect(unindented, \"\\n\")"}, {"sha": "0e338ae5c52facb6e2fa10159cf96d48044f6fde", "filename": "src/test/bench/99bob-iter.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2b4f5136a52041a88fbf3a03f627e9c00869f182/src%2Ftest%2Fbench%2F99bob-iter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b4f5136a52041a88fbf3a03f627e9c00869f182/src%2Ftest%2Fbench%2F99bob-iter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2F99bob-iter.rs?ref=2b4f5136a52041a88fbf3a03f627e9c00869f182", "patch": "@@ -31,7 +31,7 @@ fn sub(t: str, n: int) -> str unsafe {\n       1 { ns = \"1 bottle\"; }\n       _ { ns = int::to_str(n, 10u) + \" bottles\"; }\n     }\n-    while i < str::byte_len(t) {\n+    while i < str::len_bytes(t) {\n         if t[i] == '#' as u8 { b += ns; }\n         else { str::unsafe::push_byte(b, t[i]); }\n         i += 1u;"}, {"sha": "351f5463d5291742a7fd0875eb62c3f22281a4ef", "filename": "src/test/bench/99bob-simple.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2b4f5136a52041a88fbf3a03f627e9c00869f182/src%2Ftest%2Fbench%2F99bob-simple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b4f5136a52041a88fbf3a03f627e9c00869f182/src%2Ftest%2Fbench%2F99bob-simple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2F99bob-simple.rs?ref=2b4f5136a52041a88fbf3a03f627e9c00869f182", "patch": "@@ -31,7 +31,7 @@ fn sub(t: str, n: int) -> str unsafe {\n       1 { ns = \"1 bottle\"; }\n       _ { ns = int::to_str(n, 10u) + \" bottles\"; }\n     }\n-    while i < str::byte_len(t) {\n+    while i < str::len_bytes(t) {\n         if t[i] == '#' as u8 { b += ns; }\n         else { str::unsafe::push_byte(b, t[i]); }\n         i += 1u;"}, {"sha": "ef82f0742de16ad3e609e9312a6a379867de7c9d", "filename": "src/test/bench/shootout-fasta.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2b4f5136a52041a88fbf3a03f627e9c00869f182/src%2Ftest%2Fbench%2Fshootout-fasta.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b4f5136a52041a88fbf3a03f627e9c00869f182/src%2Ftest%2Fbench%2Fshootout-fasta.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fasta.rs?ref=2b4f5136a52041a88fbf3a03f627e9c00869f182", "patch": "@@ -49,26 +49,26 @@ fn make_random_fasta(id: str, desc: str, genelist: [aminoacids], n: int) {\n     uint::range(0u, n as uint) {|_i|\n         str::push_char(op, select_random(myrandom_next(rng, 100u32),\n                                          genelist));\n-        if str::byte_len(op) >= LINE_LENGTH() {\n+        if str::len_bytes(op) >= LINE_LENGTH() {\n             log(debug, op);\n             op = \"\";\n         }\n     }\n-    if str::byte_len(op) > 0u { log(debug, op); }\n+    if str::len_bytes(op) > 0u { log(debug, op); }\n }\n \n fn make_repeat_fasta(id: str, desc: str, s: str, n: int) unsafe {\n     log(debug, \">\" + id + \" \" + desc);\n     let op: str = \"\";\n-    let sl: uint = str::byte_len(s);\n+    let sl: uint = str::len_bytes(s);\n     uint::range(0u, n as uint) {|i|\n         str::unsafe::push_byte(op, s[i % sl]);\n-        if str::byte_len(op) >= LINE_LENGTH() {\n+        if str::len_bytes(op) >= LINE_LENGTH() {\n             log(debug, op);\n             op = \"\";\n         }\n     }\n-    if str::byte_len(op) > 0u { log(debug, op); }\n+    if str::len_bytes(op) > 0u { log(debug, op); }\n }\n \n fn acid(ch: char, prob: u32) -> aminoacids { ret {ch: ch, prob: prob}; }"}, {"sha": "88b0fbf4b355349060e1b2e76683389812d2e4a5", "filename": "src/test/run-pass/bind-native-fn.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2b4f5136a52041a88fbf3a03f627e9c00869f182/src%2Ftest%2Frun-pass%2Fbind-native-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b4f5136a52041a88fbf3a03f627e9c00869f182/src%2Ftest%2Frun-pass%2Fbind-native-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbind-native-fn.rs?ref=2b4f5136a52041a88fbf3a03f627e9c00869f182", "patch": "@@ -13,7 +13,7 @@ native mod libc {\n fn main() {\n     let s = \"hello world\\n\";\n     let b = str::bytes(s);\n-    let l = str::byte_len(s);\n+    let l = str::len_bytes(s);\n     let b8 = unsafe { vec::unsafe::to_ptr(b) };\n     libc::write(0i32, b8, l);\n     let a = bind libc::write(0i32, _, _);"}, {"sha": "260b0194a0c9495351d38d3ea2e644f4708e43fd", "filename": "src/test/run-pass/string-self-append.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2b4f5136a52041a88fbf3a03f627e9c00869f182/src%2Ftest%2Frun-pass%2Fstring-self-append.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b4f5136a52041a88fbf3a03f627e9c00869f182/src%2Ftest%2Frun-pass%2Fstring-self-append.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstring-self-append.rs?ref=2b4f5136a52041a88fbf3a03f627e9c00869f182", "patch": "@@ -7,8 +7,8 @@ fn main() {\n     let i = 20;\n     let expected_len = 1u;\n     while i > 0 {\n-        log(error, str::byte_len(a));\n-        assert (str::byte_len(a) == expected_len);\n+        log(error, str::len_bytes(a));\n+        assert (str::len_bytes(a) == expected_len);\n         a += a;\n         i -= 1;\n         expected_len *= 2u;"}, {"sha": "cd591866c248856710b3bca99eddf6ee0d92052d", "filename": "src/test/run-pass/utf8_chars.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2b4f5136a52041a88fbf3a03f627e9c00869f182/src%2Ftest%2Frun-pass%2Futf8_chars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b4f5136a52041a88fbf3a03f627e9c00869f182/src%2Ftest%2Frun-pass%2Futf8_chars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Futf8_chars.rs?ref=2b4f5136a52041a88fbf3a03f627e9c00869f182", "patch": "@@ -7,8 +7,8 @@ fn main() {\n     let chs: [char] = ['e', '\u00e9', '\u20ac', 0x10000 as char];\n     let s: str = str::from_chars(chs);\n \n-    assert (str::byte_len(s) == 10u);\n-    assert (str::char_len(s) == 4u);\n+    assert (str::len_bytes(s) == 10u);\n+    assert (str::len(s) == 4u);\n     assert (vec::len::<char>(str::chars(s)) == 4u);\n     assert (str::eq(str::from_chars(str::chars(s)), s));\n     assert (str::char_at(s, 0u) == 'e');"}]}