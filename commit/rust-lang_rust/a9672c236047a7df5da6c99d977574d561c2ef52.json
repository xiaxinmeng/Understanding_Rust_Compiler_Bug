{"sha": "a9672c236047a7df5da6c99d977574d561c2ef52", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE5NjcyYzIzNjA0N2E3ZGY1ZGE2Yzk5ZDk3NzU3NGQ1NjFjMmVmNTI=", "commit": {"author": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2018-01-20T21:32:49Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2018-01-20T21:32:49Z"}, "message": "Rollup merge of #47573 - estebank:closures, r=nikomatsakis\n\nClosure argument mismatch tweaks\n\n - use consistent phrasing for expected and found arguments\n - suggest changing arguments to tuple if possible\n - suggest changing single tuple argument to arguments if possible\n\nFix #44150.", "tree": {"sha": "cbcbf6b1f274c841dfe448201ea3d8d0c2c52955", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cbcbf6b1f274c841dfe448201ea3d8d0c2c52955"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a9672c236047a7df5da6c99d977574d561c2ef52", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a9672c236047a7df5da6c99d977574d561c2ef52", "html_url": "https://github.com/rust-lang/rust/commit/a9672c236047a7df5da6c99d977574d561c2ef52", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a9672c236047a7df5da6c99d977574d561c2ef52/comments", "author": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "40ba599365570ab4c3fa7091736b25a602d2b6e0", "url": "https://api.github.com/repos/rust-lang/rust/commits/40ba599365570ab4c3fa7091736b25a602d2b6e0", "html_url": "https://github.com/rust-lang/rust/commit/40ba599365570ab4c3fa7091736b25a602d2b6e0"}, {"sha": "7ed00caacc6801c8d99bcb5754a22209e9bfe661", "url": "https://api.github.com/repos/rust-lang/rust/commits/7ed00caacc6801c8d99bcb5754a22209e9bfe661", "html_url": "https://github.com/rust-lang/rust/commit/7ed00caacc6801c8d99bcb5754a22209e9bfe661"}], "stats": {"total": 391, "additions": 214, "deletions": 177}, "files": [{"sha": "e649f1b49df765052fdd61b6b3b69c0e69c8d2ef", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 152, "deletions": 153, "changes": 305, "blob_url": "https://github.com/rust-lang/rust/blob/a9672c236047a7df5da6c99d977574d561c2ef52/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9672c236047a7df5da6c99d977574d561c2ef52/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=a9672c236047a7df5da6c99d977574d561c2ef52", "patch": "@@ -717,93 +717,40 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                     self.tcx.hir.span_if_local(did)\n                 }).map(|sp| self.tcx.sess.codemap().def_span(sp)); // the sp could be an fn def\n \n-                let found_ty_count =\n-                    match found_trait_ref.skip_binder().substs.type_at(1).sty {\n-                        ty::TyTuple(ref tys, _) => tys.len(),\n-                        _ => 1,\n-                    };\n-                let (expected_tys, expected_ty_count) =\n-                    match expected_trait_ref.skip_binder().substs.type_at(1).sty {\n-                        ty::TyTuple(ref tys, _) =>\n-                            (tys.iter().map(|t| &t.sty).collect(), tys.len()),\n-                        ref sty => (vec![sty], 1),\n-                    };\n-                if found_ty_count == expected_ty_count {\n+                let found = match found_trait_ref.skip_binder().substs.type_at(1).sty {\n+                    ty::TyTuple(ref tys, _) => tys.iter()\n+                        .map(|_| ArgKind::empty()).collect::<Vec<_>>(),\n+                    _ => vec![ArgKind::empty()],\n+                };\n+                let expected = match expected_trait_ref.skip_binder().substs.type_at(1).sty {\n+                    ty::TyTuple(ref tys, _) => tys.iter()\n+                        .map(|t| match t.sty {\n+                            ty::TypeVariants::TyTuple(ref tys, _) => ArgKind::Tuple(\n+                                span,\n+                                tys.iter()\n+                                    .map(|ty| (\"_\".to_owned(), format!(\"{}\", ty.sty)))\n+                                    .collect::<Vec<_>>()\n+                            ),\n+                            _ => ArgKind::Arg(\"_\".to_owned(), format!(\"{}\", t.sty)),\n+                        }).collect(),\n+                    ref sty => vec![ArgKind::Arg(\"_\".to_owned(), format!(\"{}\", sty))],\n+                };\n+                if found.len()== expected.len() {\n                     self.report_closure_arg_mismatch(span,\n                                                      found_span,\n                                                      found_trait_ref,\n                                                      expected_trait_ref)\n                 } else {\n-                    let expected_tuple = if expected_ty_count == 1 {\n-                        expected_tys.first().and_then(|t| {\n-                            if let &&ty::TyTuple(ref tuptys, _) = t {\n-                                Some(tuptys.len())\n-                            } else {\n-                                None\n-                            }\n-                        })\n-                    } else {\n-                        None\n-                    };\n-\n-                    // FIXME(#44150): Expand this to \"N args expected but a N-tuple found.\"\n-                    // Type of the 1st expected argument is somehow provided as type of a\n-                    // found one in that case.\n-                    //\n-                    // ```\n-                    // [1i32, 2, 3].sort_by(|(a, b)| ..)\n-                    // //           ^^^^^^^ --------\n-                    // // expected_trait_ref:  std::ops::FnMut<(&i32, &i32)>\n-                    // //    found_trait_ref:  std::ops::FnMut<(&i32,)>\n-                    // ```\n-\n-                    let (closure_span, closure_args) = found_did\n+                    let (closure_span, found) = found_did\n                         .and_then(|did| self.tcx.hir.get_if_local(did))\n-                        .and_then(|node| {\n-                            if let hir::map::NodeExpr(\n-                                &hir::Expr {\n-                                    node: hir::ExprClosure(_, ref decl, id, span, _),\n-                                    ..\n-                                }) = node\n-                            {\n-                                let ty_snips = decl.inputs.iter()\n-                                    .map(|ty| {\n-                                        self.tcx.sess.codemap().span_to_snippet(ty.span).ok()\n-                                            .and_then(|snip| {\n-                                                // filter out dummy spans\n-                                                if snip == \",\" || snip == \"|\" {\n-                                                    None\n-                                                } else {\n-                                                    Some(snip)\n-                                                }\n-                                            })\n-                                    })\n-                                    .collect::<Vec<Option<String>>>();\n-\n-                                let body = self.tcx.hir.body(id);\n-                                let pat_snips = body.arguments.iter()\n-                                    .map(|arg|\n-                                        self.tcx.sess.codemap().span_to_snippet(arg.pat.span).ok())\n-                                    .collect::<Option<Vec<String>>>();\n-\n-                                Some((span, pat_snips, ty_snips))\n-                            } else {\n-                                None\n-                            }\n-                        })\n-                        .map(|(span, pat, ty)| (Some(span), Some((pat, ty))))\n-                        .unwrap_or((None, None));\n-                    let closure_args = closure_args.and_then(|(pat, ty)| Some((pat?, ty)));\n-\n-                    self.report_arg_count_mismatch(\n-                        span,\n-                        closure_span.or(found_span),\n-                        expected_ty_count,\n-                        expected_tuple,\n-                        found_ty_count,\n-                        closure_args,\n-                        found_trait_ty.is_closure()\n-                    )\n+                        .map(|node| self.get_fn_like_arguments(node))\n+                        .unwrap_or((found_span.unwrap(), found));\n+\n+                    self.report_arg_count_mismatch(span,\n+                                                   closure_span,\n+                                                   expected,\n+                                                   found,\n+                                                   found_trait_ty.is_closure())\n                 }\n             }\n \n@@ -845,94 +792,135 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n+    fn get_fn_like_arguments(&self, node: hir::map::Node) -> (Span, Vec<ArgKind>) {\n+        if let hir::map::NodeExpr(&hir::Expr {\n+            node: hir::ExprClosure(_, ref _decl, id, span, _),\n+            ..\n+        }) = node {\n+            (self.tcx.sess.codemap().def_span(span), self.tcx.hir.body(id).arguments.iter()\n+                .map(|arg| {\n+                    if let hir::Pat {\n+                        node: hir::PatKind::Tuple(args, _),\n+                        span,\n+                        ..\n+                    } = arg.pat.clone().into_inner() {\n+                        ArgKind::Tuple(\n+                            span,\n+                            args.iter().map(|pat| {\n+                                let snippet = self.tcx.sess.codemap()\n+                                    .span_to_snippet(pat.span).unwrap();\n+                                (snippet, \"_\".to_owned())\n+                            }).collect::<Vec<_>>(),\n+                        )\n+                    } else {\n+                        let name = self.tcx.sess.codemap().span_to_snippet(arg.pat.span).unwrap();\n+                        ArgKind::Arg(name, \"_\".to_owned())\n+                    }\n+                })\n+                .collect::<Vec<ArgKind>>())\n+        } else if let hir::map::NodeItem(&hir::Item {\n+            span,\n+            node: hir::ItemFn(ref decl, ..),\n+            ..\n+        }) = node {\n+            (self.tcx.sess.codemap().def_span(span), decl.inputs.iter()\n+                    .map(|arg| match arg.clone().into_inner().node {\n+                hir::TyTup(ref tys) => ArgKind::Tuple(\n+                    arg.span,\n+                    tys.iter()\n+                        .map(|_| (\"_\".to_owned(), \"_\".to_owned()))\n+                        .collect::<Vec<_>>(),\n+                ),\n+                _ => ArgKind::Arg(\"_\".to_owned(), \"_\".to_owned())\n+            }).collect::<Vec<ArgKind>>())\n+        } else {\n+            panic!(\"non-FnLike node found: {:?}\", node);\n+        }\n+    }\n+\n     fn report_arg_count_mismatch(\n         &self,\n         span: Span,\n-        found_span: Option<Span>,\n-        expected: usize,\n-        expected_tuple: Option<usize>,\n-        found: usize,\n-        closure_args: Option<(Vec<String>, Vec<Option<String>>)>,\n-        is_closure: bool\n+        found_span: Span,\n+        expected_args: Vec<ArgKind>,\n+        found_args: Vec<ArgKind>,\n+        is_closure: bool,\n     ) -> DiagnosticBuilder<'tcx> {\n-        use std::borrow::Cow;\n-\n         let kind = if is_closure { \"closure\" } else { \"function\" };\n \n-        let args_str = |n, distinct| format!(\n-                \"{} {}argument{}\",\n-                n,\n-                if distinct && n >= 2 { \"distinct \" } else { \"\" },\n-                if n == 1 { \"\" } else { \"s\" },\n-            );\n-\n-        let expected_str = if let Some(n) = expected_tuple {\n-            assert!(expected == 1);\n-            if closure_args.as_ref().map(|&(ref pats, _)| pats.len()) == Some(n) {\n-                Cow::from(\"a single tuple as argument\")\n-            } else {\n-                // be verbose when numbers differ\n-                Cow::from(format!(\"a single {}-tuple as argument\", n))\n+        let args_str = |arguments: &Vec<ArgKind>, other: &Vec<ArgKind>| {\n+            let arg_length = arguments.len();\n+            let distinct = match &other[..] {\n+                &[ArgKind::Tuple(..)] => true,\n+                _ => false,\n+            };\n+            match (arg_length, arguments.get(0)) {\n+                (1, Some(&ArgKind::Tuple(_, ref fields))) => {\n+                    format!(\"a single {}-tuple as argument\", fields.len())\n+                }\n+                _ => format!(\"{} {}argument{}\",\n+                             arg_length,\n+                             if distinct && arg_length > 1 { \"distinct \" } else { \"\" },\n+                             if arg_length == 1 { \"\" } else { \"s\" }),\n             }\n-        } else {\n-            Cow::from(args_str(expected, false))\n-        };\n-\n-        let found_str = if expected_tuple.is_some() {\n-            args_str(found, true)\n-        } else {\n-            args_str(found, false)\n         };\n \n+        let expected_str = args_str(&expected_args, &found_args);\n+        let found_str = args_str(&found_args, &expected_args);\n \n-        let mut err = struct_span_err!(self.tcx.sess, span, E0593,\n+        let mut err = struct_span_err!(\n+            self.tcx.sess,\n+            span,\n+            E0593,\n             \"{} is expected to take {}, but it takes {}\",\n             kind,\n             expected_str,\n             found_str,\n         );\n \n-        err.span_label(\n-            span,\n-            format!(\n-                \"expected {} that takes {}\",\n-                kind,\n-                expected_str,\n-            )\n-        );\n-\n-        if let Some(span) = found_span {\n-            if let (Some(expected_tuple), Some((pats, tys))) = (expected_tuple, closure_args) {\n-                if expected_tuple != found || pats.len() != found {\n-                    err.span_label(span, format!(\"takes {}\", found_str));\n-                } else {\n-                    let sugg = format!(\n-                        \"|({}){}|\",\n-                        pats.join(\", \"),\n-\n-                        // add type annotations if available\n-                        if tys.iter().any(|ty| ty.is_some()) {\n-                            Cow::from(format!(\n-                                \": ({})\",\n-                                tys.into_iter().map(|ty| if let Some(ty) = ty {\n-                                    ty\n-                                } else {\n-                                    \"_\".to_string()\n-                                }).collect::<Vec<String>>().join(\", \")\n-                            ))\n-                        } else {\n-                            Cow::from(\"\")\n-                        },\n-                    );\n-\n-                    err.span_suggestion(\n-                        span,\n-                        \"consider changing the closure to accept a tuple\",\n-                        sugg\n-                    );\n-                }\n-            } else {\n-                err.span_label(span, format!(\"takes {}\", found_str));\n+        err.span_label(span, format!( \"expected {} that takes {}\", kind, expected_str));\n+        err.span_label(found_span, format!(\"takes {}\", found_str));\n+\n+        if let &[ArgKind::Tuple(_, ref fields)] = &found_args[..] {\n+            if fields.len() == expected_args.len() {\n+                let sugg = fields.iter()\n+                    .map(|(name, _)| name.to_owned())\n+                    .collect::<Vec<String>>().join(\", \");\n+                err.span_suggestion(found_span,\n+                                    \"change the closure to take multiple arguments instead of \\\n+                                     a single tuple\",\n+                                    format!(\"|{}|\", sugg));\n+            }\n+        }\n+        if let &[ArgKind::Tuple(_, ref fields)] = &expected_args[..] {\n+            if fields.len() == found_args.len() && is_closure {\n+                let sugg = format!(\n+                    \"|({}){}|\",\n+                    found_args.iter()\n+                        .map(|arg| match arg {\n+                            ArgKind::Arg(name, _) => name.to_owned(),\n+                            _ => \"_\".to_owned(),\n+                        })\n+                        .collect::<Vec<String>>()\n+                        .join(\", \"),\n+                    // add type annotations if available\n+                    if found_args.iter().any(|arg| match arg {\n+                        ArgKind::Arg(_, ty) => ty != \"_\",\n+                        _ => false,\n+                    }) {\n+                        format!(\": ({})\",\n+                                fields.iter()\n+                                    .map(|(_, ty)| ty.to_owned())\n+                                    .collect::<Vec<String>>()\n+                                    .join(\", \"))\n+                    } else {\n+                        \"\".to_owned()\n+                    },\n+                );\n+                err.span_suggestion(found_span,\n+                                    \"change the closure to accept a tuple instead of individual \\\n+                                     arguments\",\n+                                    sugg);\n             }\n         }\n \n@@ -1331,3 +1319,14 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                           suggested_limit));\n     }\n }\n+\n+enum ArgKind {\n+    Arg(String, String),\n+    Tuple(Span, Vec<(String, String)>),\n+}\n+\n+impl ArgKind {\n+    fn empty() -> ArgKind {\n+        ArgKind::Arg(\"_\".to_owned(), \"_\".to_owned())\n+    }\n+}"}, {"sha": "96e5201716c7173f2be48a72aac924ed94d650ab", "filename": "src/test/ui/mismatched_types/closure-arg-count.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a9672c236047a7df5da6c99d977574d561c2ef52/src%2Ftest%2Fui%2Fmismatched_types%2Fclosure-arg-count.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9672c236047a7df5da6c99d977574d561c2ef52/src%2Ftest%2Fui%2Fmismatched_types%2Fclosure-arg-count.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmismatched_types%2Fclosure-arg-count.rs?ref=a9672c236047a7df5da6c99d977574d561c2ef52", "patch": "@@ -18,6 +18,8 @@ fn main() {\n     //~^ ERROR closure is expected to take\n     [1, 2, 3].sort_by(|(tuple, tuple2)| panic!());\n     //~^ ERROR closure is expected to take\n+    [1, 2, 3].sort_by(|(tuple, tuple2): (usize, _)| panic!());\n+    //~^ ERROR closure is expected to take\n     f(|| panic!());\n     //~^ ERROR closure is expected to take\n \n@@ -32,6 +34,9 @@ fn main() {\n     let bar = |i, x, y| i;\n     let _it = vec![1, 2, 3].into_iter().enumerate().map(bar);\n     //~^ ERROR closure is expected to take\n+    let _it = vec![1, 2, 3].into_iter().enumerate().map(qux);\n+    //~^ ERROR function is expected to take\n }\n \n fn foo() {}\n+fn qux(x: usize, y: usize) {}"}, {"sha": "be00ee4d74e7eededd2590ec6468ed33a62e651d", "filename": "src/test/ui/mismatched_types/closure-arg-count.stderr", "status": "modified", "additions": 57, "deletions": 24, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/a9672c236047a7df5da6c99d977574d561c2ef52/src%2Ftest%2Fui%2Fmismatched_types%2Fclosure-arg-count.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a9672c236047a7df5da6c99d977574d561c2ef52/src%2Ftest%2Fui%2Fmismatched_types%2Fclosure-arg-count.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmismatched_types%2Fclosure-arg-count.stderr?ref=a9672c236047a7df5da6c99d977574d561c2ef52", "patch": "@@ -14,18 +14,34 @@ error[E0593]: closure is expected to take 2 arguments, but it takes 1 argument\n    |               |\n    |               expected closure that takes 2 arguments\n \n-error[E0593]: closure is expected to take 2 arguments, but it takes 1 argument\n+error[E0593]: closure is expected to take 2 distinct arguments, but it takes a single 2-tuple as argument\n   --> $DIR/closure-arg-count.rs:19:15\n    |\n 19 |     [1, 2, 3].sort_by(|(tuple, tuple2)| panic!());\n-   |               ^^^^^^^ ----------------- takes 1 argument\n+   |               ^^^^^^^ ----------------- takes a single 2-tuple as argument\n    |               |\n-   |               expected closure that takes 2 arguments\n+   |               expected closure that takes 2 distinct arguments\n+help: change the closure to take multiple arguments instead of a single tuple\n+   |\n+19 |     [1, 2, 3].sort_by(|tuple, tuple2| panic!());\n+   |                       ^^^^^^^^^^^^^^^\n+\n+error[E0593]: closure is expected to take 2 distinct arguments, but it takes a single 2-tuple as argument\n+  --> $DIR/closure-arg-count.rs:21:15\n+   |\n+21 |     [1, 2, 3].sort_by(|(tuple, tuple2): (usize, _)| panic!());\n+   |               ^^^^^^^ ----------------------------- takes a single 2-tuple as argument\n+   |               |\n+   |               expected closure that takes 2 distinct arguments\n+help: change the closure to take multiple arguments instead of a single tuple\n+   |\n+21 |     [1, 2, 3].sort_by(|tuple, tuple2| panic!());\n+   |                       ^^^^^^^^^^^^^^^\n \n error[E0593]: closure is expected to take 1 argument, but it takes 0 arguments\n-  --> $DIR/closure-arg-count.rs:21:5\n+  --> $DIR/closure-arg-count.rs:23:5\n    |\n-21 |     f(|| panic!());\n+23 |     f(|| panic!());\n    |     ^ -- takes 0 arguments\n    |     |\n    |     expected closure that takes 1 argument\n@@ -36,46 +52,63 @@ note: required by `f`\n 13 | fn f<F: Fn<usize>>(_: F) {}\n    | ^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error[E0593]: closure is expected to take a single tuple as argument, but it takes 2 distinct arguments\n-  --> $DIR/closure-arg-count.rs:24:53\n+error[E0593]: closure is expected to take a single 2-tuple as argument, but it takes 2 distinct arguments\n+  --> $DIR/closure-arg-count.rs:26:53\n    |\n-24 |     let _it = vec![1, 2, 3].into_iter().enumerate().map(|i, x| i);\n-   |                                                     ^^^ ------ help: consider changing the closure to accept a tuple: `|(i, x)|`\n+26 |     let _it = vec![1, 2, 3].into_iter().enumerate().map(|i, x| i);\n+   |                                                     ^^^ ------ takes 2 distinct arguments\n    |                                                     |\n-   |                                                     expected closure that takes a single tuple as argument\n+   |                                                     expected closure that takes a single 2-tuple as argument\n+help: change the closure to accept a tuple instead of individual arguments\n+   |\n+26 |     let _it = vec![1, 2, 3].into_iter().enumerate().map(|(i, x)| i);\n+   |                                                         ^^^^^^^^\n \n-error[E0593]: closure is expected to take a single tuple as argument, but it takes 2 distinct arguments\n-  --> $DIR/closure-arg-count.rs:26:53\n+error[E0593]: closure is expected to take a single 2-tuple as argument, but it takes 2 distinct arguments\n+  --> $DIR/closure-arg-count.rs:28:53\n    |\n-26 |     let _it = vec![1, 2, 3].into_iter().enumerate().map(|i: usize, x| i);\n-   |                                                     ^^^ ------------- help: consider changing the closure to accept a tuple: `|(i, x): (usize, _)|`\n+28 |     let _it = vec![1, 2, 3].into_iter().enumerate().map(|i: usize, x| i);\n+   |                                                     ^^^ ------------- takes 2 distinct arguments\n    |                                                     |\n-   |                                                     expected closure that takes a single tuple as argument\n+   |                                                     expected closure that takes a single 2-tuple as argument\n+help: change the closure to accept a tuple instead of individual arguments\n+   |\n+28 |     let _it = vec![1, 2, 3].into_iter().enumerate().map(|(i, x)| i);\n+   |                                                         ^^^^^^^^\n \n error[E0593]: closure is expected to take a single 2-tuple as argument, but it takes 3 distinct arguments\n-  --> $DIR/closure-arg-count.rs:28:53\n+  --> $DIR/closure-arg-count.rs:30:53\n    |\n-28 |     let _it = vec![1, 2, 3].into_iter().enumerate().map(|i, x, y| i);\n+30 |     let _it = vec![1, 2, 3].into_iter().enumerate().map(|i, x, y| i);\n    |                                                     ^^^ --------- takes 3 distinct arguments\n    |                                                     |\n    |                                                     expected closure that takes a single 2-tuple as argument\n \n error[E0593]: function is expected to take a single 2-tuple as argument, but it takes 0 arguments\n-  --> $DIR/closure-arg-count.rs:30:53\n+  --> $DIR/closure-arg-count.rs:32:53\n    |\n-30 |     let _it = vec![1, 2, 3].into_iter().enumerate().map(foo);\n+32 |     let _it = vec![1, 2, 3].into_iter().enumerate().map(foo);\n    |                                                     ^^^ expected function that takes a single 2-tuple as argument\n ...\n-37 | fn foo() {}\n+41 | fn foo() {}\n    | -------- takes 0 arguments\n \n error[E0593]: closure is expected to take a single 2-tuple as argument, but it takes 3 distinct arguments\n-  --> $DIR/closure-arg-count.rs:33:53\n+  --> $DIR/closure-arg-count.rs:35:53\n    |\n-32 |     let bar = |i, x, y| i;\n+34 |     let bar = |i, x, y| i;\n    |               --------- takes 3 distinct arguments\n-33 |     let _it = vec![1, 2, 3].into_iter().enumerate().map(bar);\n+35 |     let _it = vec![1, 2, 3].into_iter().enumerate().map(bar);\n    |                                                     ^^^ expected closure that takes a single 2-tuple as argument\n \n-error: aborting due to 9 previous errors\n+error[E0593]: function is expected to take a single 2-tuple as argument, but it takes 2 distinct arguments\n+  --> $DIR/closure-arg-count.rs:37:53\n+   |\n+37 |     let _it = vec![1, 2, 3].into_iter().enumerate().map(qux);\n+   |                                                     ^^^ expected function that takes a single 2-tuple as argument\n+...\n+42 | fn qux(x: usize, y: usize) {}\n+   | -------------------------- takes 2 distinct arguments\n+\n+error: aborting due to 11 previous errors\n "}]}