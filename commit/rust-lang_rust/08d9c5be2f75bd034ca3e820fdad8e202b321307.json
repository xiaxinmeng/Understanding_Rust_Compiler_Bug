{"sha": "08d9c5be2f75bd034ca3e820fdad8e202b321307", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA4ZDljNWJlMmY3NWJkMDM0Y2EzZTgyMGZkYWQ4ZTIwMmIzMjEzMDc=", "commit": {"author": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2012-12-30T23:58:20Z"}, "committer": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2012-12-30T23:58:20Z"}, "message": "Merge pull request #4312 from Dretch/issue-2914\n\nWork towards fixing issue #2914", "tree": {"sha": "e2d9133d406113e32ebaf4962f9ea46664202324", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e2d9133d406113e32ebaf4962f9ea46664202324"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/08d9c5be2f75bd034ca3e820fdad8e202b321307", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/08d9c5be2f75bd034ca3e820fdad8e202b321307", "html_url": "https://github.com/rust-lang/rust/commit/08d9c5be2f75bd034ca3e820fdad8e202b321307", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/08d9c5be2f75bd034ca3e820fdad8e202b321307/comments", "author": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "committer": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4dde334b474e51154f22d4e497fd66d1b0abb6b3", "url": "https://api.github.com/repos/rust-lang/rust/commits/4dde334b474e51154f22d4e497fd66d1b0abb6b3", "html_url": "https://github.com/rust-lang/rust/commit/4dde334b474e51154f22d4e497fd66d1b0abb6b3"}, {"sha": "624421aa3d5d09fd59834c524f1909120685232d", "url": "https://api.github.com/repos/rust-lang/rust/commits/624421aa3d5d09fd59834c524f1909120685232d", "html_url": "https://github.com/rust-lang/rust/commit/624421aa3d5d09fd59834c524f1909120685232d"}], "stats": {"total": 83, "additions": 35, "deletions": 48}, "files": [{"sha": "ffb696ec4f946a5d99038585d7bf5135705ab01c", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 35, "deletions": 48, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/08d9c5be2f75bd034ca3e820fdad8e202b321307/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08d9c5be2f75bd034ca3e820fdad8e202b321307/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=08d9c5be2f75bd034ca3e820fdad8e202b321307", "patch": "@@ -2086,8 +2086,11 @@ impl Resolver {\n             match self.resolve_import_for_module(module_, import_directive) {\n                 Failed => {\n                     // We presumably emitted an error. Continue.\n-                    self.session.span_err(import_directive.span,\n-                                          ~\"failed to resolve import\");\n+                    let idents = import_directive.module_path.get();\n+                    let msg = fmt!(\"failed to resolve import: %s\",\n+                                   self.import_path_to_str(idents,\n+                                   *import_directive.subclass));\n+                    self.session.span_err(import_directive.span, msg);\n                 }\n                 Indeterminate => {\n                     // Bail out. We'll come around next time.\n@@ -2103,20 +2106,29 @@ impl Resolver {\n     }\n \n     fn idents_to_str(idents: ~[ident]) -> ~str {\n-        // XXX: str::connect should do this.\n-        let mut result = ~\"\";\n-        let mut first = true;\n-        for idents.each() |ident| {\n-            if first {\n-                first = false;\n-            } else {\n-                result += ~\"::\";\n-            }\n-            result += self.session.str_of(*ident);\n-        }\n-        // XXX: Shouldn't copy here. We need string builder functionality.\n-        return result;\n+        let ident_strs = idents.map(|&ident| self.session.str_of(ident));\n+        return str::connect(ident_strs, \"::\");\n     }\n+\n+    fn import_directive_subclass_to_str(subclass: ImportDirectiveSubclass)\n+                                                                     -> ~str {\n+        match subclass {\n+            SingleImport(_target, source, _ns) => self.session.str_of(source),\n+            GlobImport => ~\"*\"\n+        }\n+    }\n+\n+    fn import_path_to_str(idents: ~[ident], subclass: ImportDirectiveSubclass)\n+                                                                     -> ~str {\n+        if idents.is_empty() {\n+            self.import_directive_subclass_to_str(subclass)\n+        } else {\n+            fmt!(\"%s::%s\",\n+                 self.idents_to_str(idents),\n+                 self.import_directive_subclass_to_str(subclass))\n+        }\n+    }\n+\n     /**\n      * Attempts to resolve the given import. The return value indicates\n      * failure if we're certain the name does not exist, indeterminate if we\n@@ -4501,17 +4513,14 @@ impl Resolver {\n                         // Write the result into the def map.\n                         debug!(\"(resolving type) writing resolution for `%s` \\\n                                 (id %d)\",\n-                               connect(path.idents.map(\n-                                   |x| self.session.str_of(*x)), ~\"::\"),\n+                               self.idents_to_str(path.idents),\n                                path_id);\n                         self.record_def(path_id, def);\n                     }\n                     None => {\n                         self.session.span_err\n                             (ty.span, fmt!(\"use of undeclared type name `%s`\",\n-                                           connect(path.idents.map(\n-                                               |x| self.session.str_of(*x)),\n-                                                   ~\"::\")));\n+                                           self.idents_to_str(path.idents)));\n                     }\n                 }\n             }\n@@ -4705,9 +4714,7 @@ impl Resolver {\n                             self.session.span_err(\n                                 path.span,\n                                 fmt!(\"`%s` does not name a structure\",\n-                                     connect(path.idents.map(\n-                                         |x| self.session.str_of(*x)),\n-                                             ~\"::\")));\n+                                     self.idents_to_str(path.idents)));\n                         }\n                     }\n                 }\n@@ -5103,14 +5110,11 @@ impl Resolver {\n                     Some(def) => {\n                         // Write the result into the def map.\n                         debug!(\"(resolving expr) resolved `%s`\",\n-                               connect(path.idents.map(\n-                                   |x| self.session.str_of(*x)), ~\"::\"));\n+                               self.idents_to_str(path.idents));\n                         self.record_def(expr.id, def);\n                     }\n                     None => {\n-                        let wrong_name =\n-                            connect(path.idents.map(\n-                                |x| self.session.str_of(*x)), ~\"::\") ;\n+                        let wrong_name = self.idents_to_str(path.idents);\n                         if self.name_exists_in_scope_struct(wrong_name) {\n                             self.session.span_err(expr.span,\n                                         fmt!(\"unresolved name: `%s`. \\\n@@ -5170,9 +5174,7 @@ impl Resolver {\n                         self.session.span_err(\n                             path.span,\n                             fmt!(\"`%s` does not name a structure\",\n-                                 connect(path.idents.map(\n-                                     |x| self.session.str_of(*x)),\n-                                         ~\"::\")));\n+                                 self.idents_to_str(path.idents)));\n                     }\n                 }\n \n@@ -5491,7 +5493,7 @@ impl Resolver {\n     // hit.\n     //\n \n-    /// A somewhat inefficient routine to print out the name of a module.\n+    /// A somewhat inefficient routine to obtain the name of a module.\n     fn module_to_str(module_: @Module) -> ~str {\n         let idents = DVec();\n         let mut current_module = module_;\n@@ -5514,22 +5516,7 @@ impl Resolver {\n         if idents.len() == 0 {\n             return ~\"???\";\n         }\n-\n-        let mut string = ~\"\";\n-        let mut i = idents.len() - 1;\n-        loop {\n-            if i < idents.len() - 1 {\n-                string += ~\"::\";\n-            }\n-            string += self.session.str_of(idents.get_elt(i));\n-\n-            if i == 0 {\n-                break;\n-            }\n-            i -= 1;\n-        }\n-\n-        return string;\n+        return self.idents_to_str(vec::reversed(idents.get()));\n     }\n \n     fn dump_module(module_: @Module) {"}]}