{"sha": "99ebb7a51716a98b7d9b261a6d6b37695c6b2359", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk5ZWJiN2E1MTcxNmE5OGI3ZDliMjYxYTZkNmIzNzY5NWM2YjIzNTk=", "commit": {"author": {"name": "Yuki Okushi", "email": "huyuumi.dev@gmail.com", "date": "2019-05-01T21:03:17Z"}, "committer": {"name": "Yuki Okushi", "email": "huyuumi.dev@gmail.com", "date": "2019-05-01T22:12:32Z"}, "message": "Remove Context and ContextKind", "tree": {"sha": "f4f98199cc171d769af32b12e9525579821affda", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f4f98199cc171d769af32b12e9525579821affda"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/99ebb7a51716a98b7d9b261a6d6b37695c6b2359", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/99ebb7a51716a98b7d9b261a6d6b37695c6b2359", "html_url": "https://github.com/rust-lang/rust/commit/99ebb7a51716a98b7d9b261a6d6b37695c6b2359", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/99ebb7a51716a98b7d9b261a6d6b37695c6b2359/comments", "author": {"login": "JohnTitor", "id": 25030997, "node_id": "MDQ6VXNlcjI1MDMwOTk3", "avatar_url": "https://avatars.githubusercontent.com/u/25030997?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JohnTitor", "html_url": "https://github.com/JohnTitor", "followers_url": "https://api.github.com/users/JohnTitor/followers", "following_url": "https://api.github.com/users/JohnTitor/following{/other_user}", "gists_url": "https://api.github.com/users/JohnTitor/gists{/gist_id}", "starred_url": "https://api.github.com/users/JohnTitor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JohnTitor/subscriptions", "organizations_url": "https://api.github.com/users/JohnTitor/orgs", "repos_url": "https://api.github.com/users/JohnTitor/repos", "events_url": "https://api.github.com/users/JohnTitor/events{/privacy}", "received_events_url": "https://api.github.com/users/JohnTitor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "JohnTitor", "id": 25030997, "node_id": "MDQ6VXNlcjI1MDMwOTk3", "avatar_url": "https://avatars.githubusercontent.com/u/25030997?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JohnTitor", "html_url": "https://github.com/JohnTitor", "followers_url": "https://api.github.com/users/JohnTitor/followers", "following_url": "https://api.github.com/users/JohnTitor/following{/other_user}", "gists_url": "https://api.github.com/users/JohnTitor/gists{/gist_id}", "starred_url": "https://api.github.com/users/JohnTitor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JohnTitor/subscriptions", "organizations_url": "https://api.github.com/users/JohnTitor/orgs", "repos_url": "https://api.github.com/users/JohnTitor/repos", "events_url": "https://api.github.com/users/JohnTitor/events{/privacy}", "received_events_url": "https://api.github.com/users/JohnTitor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6cc24f26036b28fb3366de86efe3da6c4464057a", "url": "https://api.github.com/repos/rust-lang/rust/commits/6cc24f26036b28fb3366de86efe3da6c4464057a", "html_url": "https://github.com/rust-lang/rust/commit/6cc24f26036b28fb3366de86efe3da6c4464057a"}], "stats": {"total": 382, "additions": 171, "deletions": 211}, "files": [{"sha": "ed42326d7d5206f6398ffdf9d8f62b622843c24c", "filename": "src/librustc_mir/borrow_check/error_reporting.rs", "status": "modified", "additions": 38, "deletions": 38, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/99ebb7a51716a98b7d9b261a6d6b37695c6b2359/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99ebb7a51716a98b7d9b261a6d6b37695c6b2359/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs?ref=99ebb7a51716a98b7d9b261a6d6b37695c6b2359", "patch": "@@ -22,7 +22,7 @@ use syntax_pos::Span;\n use syntax::source_map::CompilerDesugaringKind;\n \n use super::borrow_set::BorrowData;\n-use super::{Context, MirBorrowckCtxt};\n+use super::{MirBorrowckCtxt};\n use super::{InitializationRequiringAction, PrefixSet};\n use crate::dataflow::drop_flag_effects;\n use crate::dataflow::indexes::{MovePathIndex, MoveOutIndex};\n@@ -42,22 +42,22 @@ struct MoveSite {\n impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n     pub(super) fn report_use_of_moved_or_uninitialized(\n         &mut self,\n-        context: Context,\n+        location: Location,\n         desired_action: InitializationRequiringAction,\n         (moved_place, used_place, span): (&Place<'tcx>, &Place<'tcx>, Span),\n         mpi: MovePathIndex,\n     ) {\n         debug!(\n-            \"report_use_of_moved_or_uninitialized: context={:?} desired_action={:?} \\\n+            \"report_use_of_moved_or_uninitialized: location={:?} desired_action={:?} \\\n              moved_place={:?} used_place={:?} span={:?} mpi={:?}\",\n-            context, desired_action, moved_place, used_place, span, mpi\n+            location, desired_action, moved_place, used_place, span, mpi\n         );\n \n-        let use_spans = self.move_spans(moved_place, context.loc)\n-            .or_else(|| self.borrow_spans(span, context.loc));\n+        let use_spans = self.move_spans(moved_place, location)\n+            .or_else(|| self.borrow_spans(span, location));\n         let span = use_spans.args_or_use();\n \n-        let move_site_vec = self.get_moved_indexes(context, mpi);\n+        let move_site_vec = self.get_moved_indexes(location, mpi);\n         debug!(\n             \"report_use_of_moved_or_uninitialized: move_site_vec={:?}\",\n             move_site_vec\n@@ -125,7 +125,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             );\n \n             self.add_moved_or_invoked_closure_note(\n-                context.loc,\n+                location,\n                 used_place,\n                 &mut err,\n             );\n@@ -261,13 +261,13 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n \n     pub(super) fn report_move_out_while_borrowed(\n         &mut self,\n-        context: Context,\n+        location: Location,\n         (place, span): (&Place<'tcx>, Span),\n         borrow: &BorrowData<'tcx>,\n     ) {\n         debug!(\n-            \"report_move_out_while_borrowed: context={:?} place={:?} span={:?} borrow={:?}\",\n-            context, place, span, borrow\n+            \"report_move_out_while_borrowed: location={:?} place={:?} span={:?} borrow={:?}\",\n+            location, place, span, borrow\n         );\n         let tcx = self.infcx.tcx;\n         let value_msg = match self.describe_place(place) {\n@@ -282,7 +282,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         let borrow_spans = self.retrieve_borrow_spans(borrow);\n         let borrow_span = borrow_spans.args_or_use();\n \n-        let move_spans = self.move_spans(place, context.loc);\n+        let move_spans = self.move_spans(place, location);\n         let span = move_spans.args_or_use();\n \n         let mut err = tcx.cannot_move_when_borrowed(\n@@ -304,7 +304,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         );\n \n         self.explain_why_borrow_contains_point(\n-            context,\n+            location,\n             borrow,\n             None,\n         ).add_explanation_to_diagnostic(self.infcx.tcx, self.mir, &mut err, \"\", Some(borrow_span));\n@@ -313,7 +313,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n \n     pub(super) fn report_use_while_mutably_borrowed(\n         &mut self,\n-        context: Context,\n+        location: Location,\n         (place, _span): (&Place<'tcx>, Span),\n         borrow: &BorrowData<'tcx>,\n     ) -> DiagnosticBuilder<'cx> {\n@@ -324,7 +324,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n \n         // Conflicting borrows are reported separately, so only check for move\n         // captures.\n-        let use_spans = self.move_spans(place, context.loc);\n+        let use_spans = self.move_spans(place, location);\n         let span = use_spans.var_or_use();\n \n         let mut err = tcx.cannot_use_when_mutably_borrowed(\n@@ -343,22 +343,22 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             format!(\"borrow occurs due to use of `{}`{}\", desc_place, borrow_spans.describe())\n         });\n \n-        self.explain_why_borrow_contains_point(context, borrow, None)\n+        self.explain_why_borrow_contains_point(location, borrow, None)\n             .add_explanation_to_diagnostic(self.infcx.tcx, self.mir, &mut err, \"\", None);\n         err\n     }\n \n     pub(super) fn report_conflicting_borrow(\n         &mut self,\n-        context: Context,\n+        location: Location,\n         (place, span): (&Place<'tcx>, Span),\n         gen_borrow_kind: BorrowKind,\n         issued_borrow: &BorrowData<'tcx>,\n     ) -> DiagnosticBuilder<'cx> {\n         let issued_spans = self.retrieve_borrow_spans(issued_borrow);\n         let issued_span = issued_spans.args_or_use();\n \n-        let borrow_spans = self.borrow_spans(span, context.loc);\n+        let borrow_spans = self.borrow_spans(span, location);\n         let span = borrow_spans.args_or_use();\n \n         let container_name = if issued_spans.for_generator() || borrow_spans.for_generator() {\n@@ -370,7 +370,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         let (desc_place, msg_place, msg_borrow, union_type_name) =\n             self.describe_place_for_conflicting_borrow(place, &issued_borrow.borrowed_place);\n \n-        let explanation = self.explain_why_borrow_contains_point(context, issued_borrow, None);\n+        let explanation = self.explain_why_borrow_contains_point(location, issued_borrow, None);\n         let second_borrow_desc = if explanation.is_explained() {\n             \"second \"\n         } else {\n@@ -671,7 +671,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n     /// `Drop::drop` with an aliasing borrow.)\n     pub(super) fn report_borrowed_value_does_not_live_long_enough(\n         &mut self,\n-        context: Context,\n+        location: Location,\n         borrow: &BorrowData<'tcx>,\n         place_span: (&Place<'tcx>, Span),\n         kind: Option<WriteKind>,\n@@ -680,7 +680,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             \"report_borrowed_value_does_not_live_long_enough(\\\n              {:?}, {:?}, {:?}, {:?}\\\n              )\",\n-            context, borrow, place_span, kind\n+            location, borrow, place_span, kind\n         );\n \n         let drop_span = place_span.1;\n@@ -719,7 +719,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             // destructor conflict.\n             if !borrow.borrowed_place.is_prefix_of(place_span.0) {\n                 self.report_borrow_conflicts_with_destructor(\n-                    context, borrow, place_span, kind, dropped_ty,\n+                    location, borrow, place_span, kind, dropped_ty,\n                 );\n                 return;\n             }\n@@ -728,7 +728,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         let place_desc = self.describe_place(&borrow.borrowed_place);\n \n         let kind_place = kind.filter(|_| place_desc.is_some()).map(|k| (k, place_span.0));\n-        let explanation = self.explain_why_borrow_contains_point(context, &borrow, kind_place);\n+        let explanation = self.explain_why_borrow_contains_point(location, &borrow, kind_place);\n \n         let err = match (place_desc, explanation) {\n             (Some(_), _) if self.is_place_thread_local(root_place) => {\n@@ -784,7 +784,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 },\n             ) => self.report_escaping_data(borrow_span, name, upvar_span, upvar_name, span),\n             (Some(name), explanation) => self.report_local_value_does_not_live_long_enough(\n-                context,\n+                location,\n                 &name,\n                 &scope_tree,\n                 &borrow,\n@@ -793,7 +793,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 explanation,\n             ),\n             (None, explanation) => self.report_temporary_value_does_not_live_long_enough(\n-                context,\n+                location,\n                 &scope_tree,\n                 &borrow,\n                 drop_span,\n@@ -808,7 +808,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n \n     fn report_local_value_does_not_live_long_enough(\n         &mut self,\n-        context: Context,\n+        location: Location,\n         name: &str,\n         scope_tree: &'tcx ScopeTree,\n         borrow: &BorrowData<'tcx>,\n@@ -820,7 +820,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             \"report_local_value_does_not_live_long_enough(\\\n              {:?}, {:?}, {:?}, {:?}, {:?}, {:?}\\\n              )\",\n-            context, name, scope_tree, borrow, drop_span, borrow_spans\n+            location, name, scope_tree, borrow, drop_span, borrow_spans\n         );\n \n         let borrow_span = borrow_spans.var_or_use();\n@@ -914,7 +914,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n \n     fn report_borrow_conflicts_with_destructor(\n         &mut self,\n-        context: Context,\n+        location: Location,\n         borrow: &BorrowData<'tcx>,\n         (place, drop_span): (&Place<'tcx>, Span),\n         kind: Option<WriteKind>,\n@@ -924,7 +924,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             \"report_borrow_conflicts_with_destructor(\\\n              {:?}, {:?}, ({:?}, {:?}), {:?}\\\n              )\",\n-            context, borrow, place, drop_span, kind,\n+            location, borrow, place, drop_span, kind,\n         );\n \n         let borrow_spans = self.retrieve_borrow_spans(borrow);\n@@ -957,7 +957,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n \n         // Only give this note and suggestion if they could be relevant.\n         let explanation =\n-            self.explain_why_borrow_contains_point(context, borrow, kind.map(|k| (k, place)));\n+            self.explain_why_borrow_contains_point(location, borrow, kind.map(|k| (k, place)));\n         match explanation {\n             BorrowExplanation::UsedLater { .. }\n             | BorrowExplanation::UsedLaterWhenDropped { .. } => {\n@@ -998,7 +998,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n \n     fn report_temporary_value_does_not_live_long_enough(\n         &mut self,\n-        context: Context,\n+        location: Location,\n         scope_tree: &'tcx ScopeTree,\n         borrow: &BorrowData<'tcx>,\n         drop_span: Span,\n@@ -1010,7 +1010,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             \"report_temporary_value_does_not_live_long_enough(\\\n              {:?}, {:?}, {:?}, {:?}, {:?}\\\n              )\",\n-            context, scope_tree, borrow, drop_span, proper_span\n+            location, scope_tree, borrow, drop_span, proper_span\n         );\n \n         if let BorrowExplanation::MustBeValidFor {\n@@ -1246,12 +1246,12 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         err\n     }\n \n-    fn get_moved_indexes(&mut self, context: Context, mpi: MovePathIndex) -> Vec<MoveSite> {\n+    fn get_moved_indexes(&mut self, location: Location, mpi: MovePathIndex) -> Vec<MoveSite> {\n         let mir = self.mir;\n \n         let mut stack = Vec::new();\n-        stack.extend(mir.predecessor_locations(context.loc).map(|predecessor| {\n-            let is_back_edge = context.loc.dominates(predecessor, &self.dominators);\n+        stack.extend(mir.predecessor_locations(location).map(|predecessor| {\n+            let is_back_edge = location.dominates(predecessor, &self.dominators);\n             (predecessor, is_back_edge)\n         }));\n \n@@ -1348,7 +1348,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n \n     pub(super) fn report_illegal_mutation_of_borrowed(\n         &mut self,\n-        context: Context,\n+        location: Location,\n         (place, span): (&Place<'tcx>, Span),\n         loan: &BorrowData<'tcx>,\n     ) {\n@@ -1386,7 +1386,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             format!(\"borrow occurs due to use{}\", loan_spans.describe()),\n         );\n \n-        self.explain_why_borrow_contains_point(context, loan, None)\n+        self.explain_why_borrow_contains_point(location, loan, None)\n             .add_explanation_to_diagnostic(self.infcx.tcx, self.mir, &mut err, \"\", None);\n \n         err.buffer(&mut self.errors_buffer);\n@@ -1400,7 +1400,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n     /// assignment to `x.f`).\n     pub(super) fn report_illegal_reassignment(\n         &mut self,\n-        _context: Context,\n+        _location: Location,\n         (place, span): (&Place<'tcx>, Span),\n         assigned_span: Span,\n         err_place: &Place<'tcx>,"}, {"sha": "1d65a018dd62d6b584016be3100e0bd00c90ed0b", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 83, "deletions": 120, "changes": 203, "blob_url": "https://github.com/rust-lang/rust/blob/99ebb7a51716a98b7d9b261a6d6b37695c6b2359/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99ebb7a51716a98b7d9b261a6d6b37695c6b2359/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=99ebb7a51716a98b7d9b261a6d6b37695c6b2359", "patch": "@@ -302,11 +302,12 @@ fn do_mir_borrowck<'a, 'gcx, 'tcx>(\n \n     // Convert any reservation warnings into lints.\n     let reservation_warnings = mem::replace(&mut mbcx.reservation_warnings, Default::default());\n-    for (_, (place, span, context, bk, borrow)) in reservation_warnings {\n-        let mut initial_diag = mbcx.report_conflicting_borrow(context, (&place, span), bk, &borrow);\n+    for (_, (place, span, location, bk, borrow)) in reservation_warnings {\n+        let mut initial_diag =\n+            mbcx.report_conflicting_borrow(location, (&place, span), bk, &borrow);\n \n         let lint_root = if let ClearCrossCrate::Set(ref vsi) = mbcx.mir.source_scope_local_data {\n-            let scope = mbcx.mir.source_info(context.loc).scope;\n+            let scope = mbcx.mir.source_info(location).scope;\n             vsi[scope].lint_root\n         } else {\n             id\n@@ -483,7 +484,7 @@ pub struct MirBorrowckCtxt<'cx, 'gcx: 'tcx, 'tcx: 'cx> {\n     /// for the activation of the borrow.\n     reservation_warnings: FxHashMap<\n         BorrowIndex,\n-        (Place<'tcx>, Span, Context, BorrowKind, BorrowData<'tcx>)\n+        (Place<'tcx>, Span, Location, BorrowKind, BorrowData<'tcx>)\n     >,\n     /// This field keeps track of move errors that are to be reported for given move indicies.\n     ///\n@@ -559,14 +560,13 @@ impl<'cx, 'gcx, 'tcx> DataflowResultsConsumer<'cx, 'tcx> for MirBorrowckCtxt<'cx\n         match stmt.kind {\n             StatementKind::Assign(ref lhs, ref rhs) => {\n                 self.consume_rvalue(\n-                    ContextKind::AssignRhs.new(location),\n-                    (rhs, span),\n                     location,\n+                    (rhs, span),\n                     flow_state,\n                 );\n \n                 self.mutate_place(\n-                    ContextKind::AssignLhs.new(location),\n+                    location,\n                     (lhs, span),\n                     Shallow(None),\n                     JustWrite,\n@@ -585,7 +585,7 @@ impl<'cx, 'gcx, 'tcx> DataflowResultsConsumer<'cx, 'tcx> for MirBorrowckCtxt<'cx\n                 //      match x {};\n                 // from compiling.\n                 self.check_if_path_or_subpath_is_moved(\n-                    ContextKind::FakeRead.new(location),\n+                    location,\n                     InitializationRequiringAction::Use,\n                     (place, span),\n                     flow_state,\n@@ -596,35 +596,34 @@ impl<'cx, 'gcx, 'tcx> DataflowResultsConsumer<'cx, 'tcx> for MirBorrowckCtxt<'cx\n                 variant_index: _,\n             } => {\n                 self.mutate_place(\n-                    ContextKind::SetDiscrim.new(location),\n+                    location,\n                     (place, span),\n                     Shallow(None),\n                     JustWrite,\n                     flow_state,\n                 );\n             }\n             StatementKind::InlineAsm(ref asm) => {\n-                let context = ContextKind::InlineAsm.new(location);\n                 for (o, output) in asm.asm.outputs.iter().zip(asm.outputs.iter()) {\n                     if o.is_indirect {\n                         // FIXME(eddyb) indirect inline asm outputs should\n                         // be encoded through MIR place derefs instead.\n                         self.access_place(\n-                            context,\n+                            location,\n                             (output, o.span),\n                             (Deep, Read(ReadKind::Copy)),\n                             LocalMutationIsAllowed::No,\n                             flow_state,\n                         );\n                         self.check_if_path_or_subpath_is_moved(\n-                            context,\n+                            location,\n                             InitializationRequiringAction::Use,\n                             (output, o.span),\n                             flow_state,\n                         );\n                     } else {\n                         self.mutate_place(\n-                            context,\n+                            location,\n                             (output, o.span),\n                             if o.is_rw { Deep } else { Shallow(None) },\n                             if o.is_rw { WriteAndRead } else { JustWrite },\n@@ -633,7 +632,7 @@ impl<'cx, 'gcx, 'tcx> DataflowResultsConsumer<'cx, 'tcx> for MirBorrowckCtxt<'cx\n                     }\n                 }\n                 for (_, input) in asm.inputs.iter() {\n-                    self.consume_operand(context, (input, span), flow_state);\n+                    self.consume_operand(location, (input, span), flow_state);\n                 }\n             }\n             StatementKind::Nop\n@@ -645,7 +644,7 @@ impl<'cx, 'gcx, 'tcx> DataflowResultsConsumer<'cx, 'tcx> for MirBorrowckCtxt<'cx\n             }\n             StatementKind::StorageDead(local) => {\n                 self.access_place(\n-                    ContextKind::StorageDead.new(location),\n+                    location,\n                     (&Place::Base(PlaceBase::Local(local)), span),\n                     (Shallow(None), Write(WriteKind::StorageDeadOrDrop)),\n                     LocalMutationIsAllowed::Yes,\n@@ -677,7 +676,7 @@ impl<'cx, 'gcx, 'tcx> DataflowResultsConsumer<'cx, 'tcx> for MirBorrowckCtxt<'cx\n                 values: _,\n                 targets: _,\n             } => {\n-                self.consume_operand(ContextKind::SwitchInt.new(loc), (discr, span), flow_state);\n+                self.consume_operand(loc, (discr, span), flow_state);\n             }\n             TerminatorKind::Drop {\n                 location: ref drop_place,\n@@ -702,7 +701,7 @@ impl<'cx, 'gcx, 'tcx> DataflowResultsConsumer<'cx, 'tcx> for MirBorrowckCtxt<'cx\n                        loc, term, drop_place, drop_place_ty, span);\n \n                 self.access_place(\n-                    ContextKind::Drop.new(loc),\n+                    loc,\n                     (drop_place, span),\n                     (AccessDepth::Drop, Write(WriteKind::StorageDeadOrDrop)),\n                     LocalMutationIsAllowed::Yes,\n@@ -716,14 +715,14 @@ impl<'cx, 'gcx, 'tcx> DataflowResultsConsumer<'cx, 'tcx> for MirBorrowckCtxt<'cx\n                 unwind: _,\n             } => {\n                 self.mutate_place(\n-                    ContextKind::DropAndReplace.new(loc),\n+                    loc,\n                     (drop_place, span),\n                     Deep,\n                     JustWrite,\n                     flow_state,\n                 );\n                 self.consume_operand(\n-                    ContextKind::DropAndReplace.new(loc),\n+                    loc,\n                     (new_value, span),\n                     flow_state,\n                 );\n@@ -735,17 +734,17 @@ impl<'cx, 'gcx, 'tcx> DataflowResultsConsumer<'cx, 'tcx> for MirBorrowckCtxt<'cx\n                 cleanup: _,\n                 from_hir_call: _,\n             } => {\n-                self.consume_operand(ContextKind::CallOperator.new(loc), (func, span), flow_state);\n+                self.consume_operand(loc, (func, span), flow_state);\n                 for arg in args {\n                     self.consume_operand(\n-                        ContextKind::CallOperand.new(loc),\n+                        loc,\n                         (arg, span),\n                         flow_state,\n                     );\n                 }\n                 if let Some((ref dest, _ /*bb*/)) = *destination {\n                     self.mutate_place(\n-                        ContextKind::CallDest.new(loc),\n+                        loc,\n                         (dest, span),\n                         Deep,\n                         JustWrite,\n@@ -760,11 +759,11 @@ impl<'cx, 'gcx, 'tcx> DataflowResultsConsumer<'cx, 'tcx> for MirBorrowckCtxt<'cx\n                 target: _,\n                 cleanup: _,\n             } => {\n-                self.consume_operand(ContextKind::Assert.new(loc), (cond, span), flow_state);\n+                self.consume_operand(loc, (cond, span), flow_state);\n                 use rustc::mir::interpret::InterpError::BoundsCheck;\n                 if let BoundsCheck { ref len, ref index } = *msg {\n-                    self.consume_operand(ContextKind::Assert.new(loc), (len, span), flow_state);\n-                    self.consume_operand(ContextKind::Assert.new(loc), (index, span), flow_state);\n+                    self.consume_operand(loc, (len, span), flow_state);\n+                    self.consume_operand(loc, (index, span), flow_state);\n                 }\n             }\n \n@@ -773,7 +772,7 @@ impl<'cx, 'gcx, 'tcx> DataflowResultsConsumer<'cx, 'tcx> for MirBorrowckCtxt<'cx\n                 resume: _,\n                 drop: _,\n             } => {\n-                self.consume_operand(ContextKind::Yield.new(loc), (value, span), flow_state);\n+                self.consume_operand(loc, (value, span), flow_state);\n \n                 if self.movable_generator {\n                     // Look for any active borrows to locals\n@@ -796,8 +795,7 @@ impl<'cx, 'gcx, 'tcx> DataflowResultsConsumer<'cx, 'tcx> for MirBorrowckCtxt<'cx\n                 flow_state.with_outgoing_borrows(|borrows| {\n                     for i in borrows {\n                         let borrow = &borrow_set[i];\n-                        let context = ContextKind::StorageDead.new(loc);\n-                        self.check_for_invalidation_at_exit(context, borrow, span);\n+                        self.check_for_invalidation_at_exit(loc, borrow, span);\n                     }\n                 });\n             }\n@@ -955,7 +953,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n     /// Returns `true` if an error is reported.\n     fn access_place(\n         &mut self,\n-        context: Context,\n+        location: Location,\n         place_span: (&Place<'tcx>, Span),\n         kind: (AccessDepth, ReadOrWrite),\n         is_local_mutation_allowed: LocalMutationIsAllowed,\n@@ -994,10 +992,10 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 rw,\n                 is_local_mutation_allowed,\n                 flow_state,\n-                context.loc,\n+                location,\n             );\n         let conflict_error =\n-            self.check_access_for_conflict(context, place_span, sd, rw, flow_state);\n+            self.check_access_for_conflict(location, place_span, sd, rw, flow_state);\n \n         if let (Activation(_, borrow_idx), true) = (kind.1, conflict_error) {\n             // Suppress this warning when there's an error being emited for the\n@@ -1018,30 +1016,30 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n \n     fn check_access_for_conflict(\n         &mut self,\n-        context: Context,\n+        location: Location,\n         place_span: (&Place<'tcx>, Span),\n         sd: AccessDepth,\n         rw: ReadOrWrite,\n         flow_state: &Flows<'cx, 'gcx, 'tcx>,\n     ) -> bool {\n         debug!(\n-            \"check_access_for_conflict(context={:?}, place_span={:?}, sd={:?}, rw={:?})\",\n-            context, place_span, sd, rw,\n+            \"check_access_for_conflict(location={:?}, place_span={:?}, sd={:?}, rw={:?})\",\n+            location, place_span, sd, rw,\n         );\n \n         let mut error_reported = false;\n         let tcx = self.infcx.tcx;\n         let mir = self.mir;\n-        let location = self.location_table.start_index(context.loc);\n+        let location_table = self.location_table.start_index(location);\n         let borrow_set = self.borrow_set.clone();\n         each_borrow_involving_path(\n             self,\n             tcx,\n             mir,\n-            context,\n+            location,\n             (sd, place_span.0),\n             &borrow_set,\n-            flow_state.borrows_in_scope(location),\n+            flow_state.borrows_in_scope(location_table),\n             |this, borrow_index, borrow| match (rw, borrow.kind) {\n                 // Obviously an activation is compatible with its own\n                 // reservation (or even prior activating uses of same\n@@ -1075,19 +1073,19 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n \n                 (Read(kind), BorrowKind::Unique) | (Read(kind), BorrowKind::Mut { .. }) => {\n                     // Reading from mere reservations of mutable-borrows is OK.\n-                    if !is_active(&this.dominators, borrow, context.loc) {\n+                    if !is_active(&this.dominators, borrow, location) {\n                         assert!(allow_two_phase_borrow(borrow.kind));\n                         return Control::Continue;\n                     }\n \n                     error_reported = true;\n                     match kind {\n                         ReadKind::Copy  => {\n-                            this.report_use_while_mutably_borrowed(context, place_span, borrow)\n+                            this.report_use_while_mutably_borrowed(location, place_span, borrow)\n                                 .buffer(&mut this.errors_buffer);\n                         }\n                         ReadKind::Borrow(bk) => {\n-                            this.report_conflicting_borrow(context, place_span, bk, borrow)\n+                            this.report_conflicting_borrow(location, place_span, bk, borrow)\n                                 .buffer(&mut this.errors_buffer);\n                         }\n                     }\n@@ -1098,7 +1096,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 | (Reservation(WriteKind::MutableBorrow(bk)), BorrowKind::Shared) if {\n                     tcx.migrate_borrowck()\n                 } => {\n-                    let bi = this.borrow_set.location_map[&context.loc];\n+                    let bi = this.borrow_set.location_map[&location];\n                     debug!(\n                         \"recording invalid reservation of place: {:?} with \\\n                          borrow index {:?} as warning\",\n@@ -1111,7 +1109,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                     // checking was otherwise successful.\n                     this.reservation_warnings.insert(\n                         bi,\n-                        (place_span.0.clone(), place_span.1, context, bk, borrow.clone()),\n+                        (place_span.0.clone(), place_span.1, location, bk, borrow.clone()),\n                     );\n \n                     // Don't suppress actual errors.\n@@ -1143,21 +1141,21 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                     error_reported = true;\n                     match kind {\n                         WriteKind::MutableBorrow(bk) => {\n-                            this.report_conflicting_borrow(context, place_span, bk, borrow)\n+                            this.report_conflicting_borrow(location, place_span, bk, borrow)\n                                 .buffer(&mut this.errors_buffer);\n                         }\n                         WriteKind::StorageDeadOrDrop => {\n                             this.report_borrowed_value_does_not_live_long_enough(\n-                                context,\n+                                location,\n                                 borrow,\n                                 place_span,\n                                 Some(kind))\n                         }\n                         WriteKind::Mutate => {\n-                            this.report_illegal_mutation_of_borrowed(context, place_span, borrow)\n+                            this.report_illegal_mutation_of_borrowed(location, place_span, borrow)\n                         }\n                         WriteKind::Move => {\n-                            this.report_move_out_while_borrowed(context, place_span, borrow)\n+                            this.report_move_out_while_borrowed(location, place_span, borrow)\n                         }\n                     }\n                     Control::Break\n@@ -1170,7 +1168,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n \n     fn mutate_place(\n         &mut self,\n-        context: Context,\n+        location: Location,\n         place_span: (&Place<'tcx>, Span),\n         kind: AccessDepth,\n         mode: MutateMode,\n@@ -1180,14 +1178,14 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         match mode {\n             MutateMode::WriteAndRead => {\n                 self.check_if_path_or_subpath_is_moved(\n-                    context,\n+                    location,\n                     InitializationRequiringAction::Update,\n                     place_span,\n                     flow_state,\n                 );\n             }\n             MutateMode::JustWrite => {\n-                self.check_if_assigned_path_is_moved(context, place_span, flow_state);\n+                self.check_if_assigned_path_is_moved(location, place_span, flow_state);\n             }\n         }\n \n@@ -1198,7 +1196,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             if let Mutability::Not = self.mir.local_decls[local].mutability {\n                 // check for reassignments to immutable local variables\n                 self.check_if_reassignment_to_immutable_state(\n-                    context,\n+                    location,\n                     local,\n                     place_span,\n                     flow_state,\n@@ -1209,7 +1207,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n \n         // Otherwise, use the normal access permission rules.\n         self.access_place(\n-            context,\n+            location,\n             place_span,\n             (kind, Write(WriteKind::Mutate)),\n             LocalMutationIsAllowed::No,\n@@ -1219,9 +1217,8 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n \n     fn consume_rvalue(\n         &mut self,\n-        context: Context,\n+        location: Location,\n         (rvalue, span): (&Rvalue<'tcx>, Span),\n-        _location: Location,\n         flow_state: &Flows<'cx, 'gcx, 'tcx>,\n     ) {\n         match *rvalue {\n@@ -1242,7 +1239,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 };\n \n                 self.access_place(\n-                    context,\n+                    location,\n                     (place, span),\n                     access_kind,\n                     LocalMutationIsAllowed::No,\n@@ -1256,7 +1253,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 };\n \n                 self.check_if_path_or_subpath_is_moved(\n-                    context,\n+                    location,\n                     action,\n                     (place, span),\n                     flow_state,\n@@ -1267,7 +1264,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             | Rvalue::Repeat(ref operand, _)\n             | Rvalue::UnaryOp(_ /*un_op*/, ref operand)\n             | Rvalue::Cast(_ /*cast_kind*/, ref operand, _ /*ty*/) => {\n-                self.consume_operand(context, (operand, span), flow_state)\n+                self.consume_operand(location, (operand, span), flow_state)\n             }\n \n             Rvalue::Len(ref place) | Rvalue::Discriminant(ref place) => {\n@@ -1277,14 +1274,14 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                     _ => unreachable!(),\n                 };\n                 self.access_place(\n-                    context,\n+                    location,\n                     (place, span),\n                     (Shallow(af), Read(ReadKind::Copy)),\n                     LocalMutationIsAllowed::No,\n                     flow_state,\n                 );\n                 self.check_if_path_or_subpath_is_moved(\n-                    context,\n+                    location,\n                     InitializationRequiringAction::Use,\n                     (place, span),\n                     flow_state,\n@@ -1293,8 +1290,8 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n \n             Rvalue::BinaryOp(_bin_op, ref operand1, ref operand2)\n             | Rvalue::CheckedBinaryOp(_bin_op, ref operand1, ref operand2) => {\n-                self.consume_operand(context, (operand1, span), flow_state);\n-                self.consume_operand(context, (operand2, span), flow_state);\n+                self.consume_operand(location, (operand1, span), flow_state);\n+                self.consume_operand(location, (operand2, span), flow_state);\n             }\n \n             Rvalue::NullaryOp(_op, _ty) => {\n@@ -1326,7 +1323,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 }\n \n                 for operand in operands {\n-                    self.consume_operand(context, (operand, span), flow_state);\n+                    self.consume_operand(location, (operand, span), flow_state);\n                 }\n             }\n         }\n@@ -1407,7 +1404,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n \n     fn consume_operand(\n         &mut self,\n-        context: Context,\n+        location: Location,\n         (operand, span): (&Operand<'tcx>, Span),\n         flow_state: &Flows<'cx, 'gcx, 'tcx>,\n     ) {\n@@ -1416,7 +1413,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 // copy of place: check if this is \"copy of frozen path\"\n                 // (FIXME: see check_loans.rs)\n                 self.access_place(\n-                    context,\n+                    location,\n                     (place, span),\n                     (Deep, Read(ReadKind::Copy)),\n                     LocalMutationIsAllowed::No,\n@@ -1425,7 +1422,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n \n                 // Finally, check if path was already moved.\n                 self.check_if_path_or_subpath_is_moved(\n-                    context,\n+                    location,\n                     InitializationRequiringAction::Use,\n                     (place, span),\n                     flow_state,\n@@ -1434,7 +1431,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             Operand::Move(ref place) => {\n                 // move of place: check if this is move of already borrowed path\n                 self.access_place(\n-                    context,\n+                    location,\n                     (place, span),\n                     (Deep, Write(WriteKind::Move)),\n                     LocalMutationIsAllowed::Yes,\n@@ -1443,7 +1440,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n \n                 // Finally, check if path was already moved.\n                 self.check_if_path_or_subpath_is_moved(\n-                    context,\n+                    location,\n                     InitializationRequiringAction::Use,\n                     (place, span),\n                     flow_state,\n@@ -1457,7 +1454,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n     /// exits\n     fn check_for_invalidation_at_exit(\n         &mut self,\n-        context: Context,\n+        location: Location,\n         borrow: &BorrowData<'tcx>,\n         span: Span,\n     ) {\n@@ -1513,7 +1510,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             // of just a span here.\n             let span = self.infcx.tcx.sess.source_map().end_point(span);\n             self.report_borrowed_value_does_not_live_long_enough(\n-                context,\n+                location,\n                 borrow,\n                 (place, span),\n                 None,\n@@ -1558,7 +1555,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             });\n \n             self.access_place(\n-                ContextKind::Activation.new(location),\n+                location,\n                 (&borrow.borrowed_place, span),\n                 (\n                     Deep,\n@@ -1577,7 +1574,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n     fn check_if_reassignment_to_immutable_state(\n         &mut self,\n-        context: Context,\n+        location: Location,\n         local: Local,\n         place_span: (&Place<'tcx>, Span),\n         flow_state: &Flows<'cx, 'gcx, 'tcx>,\n@@ -1590,14 +1587,14 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             let init = &self.move_data.inits[init_index];\n             let span = init.span(&self.mir);\n             self.report_illegal_reassignment(\n-                context, place_span, span, place_span.0\n+                location, place_span, span, place_span.0\n             );\n         }\n     }\n \n     fn check_if_full_path_is_moved(\n         &mut self,\n-        context: Context,\n+        location: Location,\n         desired_action: InitializationRequiringAction,\n         place_span: (&Place<'tcx>, Span),\n         flow_state: &Flows<'cx, 'gcx, 'tcx>,\n@@ -1644,7 +1641,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             Ok((prefix, mpi)) => {\n                 if maybe_uninits.contains(mpi) {\n                     self.report_use_of_moved_or_uninitialized(\n-                        context,\n+                        location,\n                         desired_action,\n                         (prefix, place_span.0, place_span.1),\n                         mpi,\n@@ -1665,7 +1662,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n \n     fn check_if_path_or_subpath_is_moved(\n         &mut self,\n-        context: Context,\n+        location: Location,\n         desired_action: InitializationRequiringAction,\n         place_span: (&Place<'tcx>, Span),\n         flow_state: &Flows<'cx, 'gcx, 'tcx>,\n@@ -1687,7 +1684,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         //    must have been initialized for the use to be sound.\n         // 6. Move of `a.b.c` then reinit of `a.b.c.d`, use of `a.b.c.d`\n \n-        self.check_if_full_path_is_moved(context, desired_action, place_span, flow_state);\n+        self.check_if_full_path_is_moved(location, desired_action, place_span, flow_state);\n \n         // A move of any shallow suffix of `place` also interferes\n         // with an attempt to use `place`. This is scenario 3 above.\n@@ -1702,7 +1699,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         if let Some(mpi) = self.move_path_for_place(place_span.0) {\n             if let Some(child_mpi) = maybe_uninits.has_any_child_of(mpi) {\n                 self.report_use_of_moved_or_uninitialized(\n-                    context,\n+                    location,\n                     desired_action,\n                     (place_span.0, place_span.0, place_span.1),\n                     child_mpi,\n@@ -1753,7 +1750,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n \n     fn check_if_assigned_path_is_moved(\n         &mut self,\n-        context: Context,\n+        location: Location,\n         (place, span): (&Place<'tcx>, Span),\n         flow_state: &Flows<'cx, 'gcx, 'tcx>,\n     ) {\n@@ -1781,16 +1778,16 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                         // assigning to (*P) requires P to be initialized\n                         ProjectionElem::Deref => {\n                             self.check_if_full_path_is_moved(\n-                                context, InitializationRequiringAction::Use,\n+                                location, InitializationRequiringAction::Use,\n                                 (base, span), flow_state);\n                             // (base initialized; no need to\n                             // recur further)\n                             break;\n                         }\n \n                         ProjectionElem::Subslice { .. } => {\n-                            panic!(\"we don't allow assignments to subslices, context: {:?}\",\n-                                   context);\n+                            panic!(\"we don't allow assignments to subslices, location: {:?}\",\n+                                   location);\n                         }\n \n                         ProjectionElem::Field(..) => {\n@@ -1801,7 +1798,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                             match base.ty(self.mir, tcx).ty.sty {\n                                 ty::Adt(def, _) if def.has_dtor(tcx) => {\n                                     self.check_if_path_or_subpath_is_moved(\n-                                        context, InitializationRequiringAction::Assignment,\n+                                        location, InitializationRequiringAction::Assignment,\n                                         (base, span), flow_state);\n \n                                     // (base initialized; no need to\n@@ -1813,7 +1810,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                                 // Once `let s; s.x = V; read(s.x);`,\n                                 // is allowed, remove this match arm.\n                                 ty::Adt(..) | ty::Tuple(..) => {\n-                                    check_parent_of_field(self, context, base, span, flow_state);\n+                                    check_parent_of_field(self, location, base, span, flow_state);\n \n                                     if let Some(local) = place.base_local() {\n                                         // rust-lang/rust#21232,\n@@ -1841,7 +1838,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n \n         fn check_parent_of_field<'cx, 'gcx, 'tcx>(\n             this: &mut MirBorrowckCtxt<'cx, 'gcx, 'tcx>,\n-            context: Context,\n+            location: Location,\n             base: &Place<'tcx>,\n             span: Span,\n             flow_state: &Flows<'cx, 'gcx, 'tcx>,\n@@ -1907,7 +1904,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                     if def.is_union() {\n                         if this.move_data.path_map[mpi].iter().any(|moi| {\n                             this.move_data.moves[*moi].source.is_predecessor_of(\n-                                context.loc, this.mir,\n+                                location, this.mir,\n                             )\n                         }) {\n                             return;\n@@ -1916,7 +1913,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 }\n \n                 this.report_use_of_moved_or_uninitialized(\n-                    context,\n+                    location,\n                     InitializationRequiringAction::PartialAssignment,\n                     (prefix, base, span),\n                     mpi,\n@@ -2234,7 +2231,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                                     // Subtle: this is an upvar\n                                     // reference, so it looks like\n                                     // `self.foo` -- we want to double\n-                                    // check that the context `*self`\n+                                    // check that the location `*self`\n                                     // is mutable (i.e., this is not a\n                                     // `Fn` closure).  But if that\n                                     // check succeeds, we want to\n@@ -2331,37 +2328,3 @@ enum Overlap {\n     /// will also be disjoint.\n     Disjoint,\n }\n-\n-#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n-struct Context {\n-    kind: ContextKind,\n-    loc: Location,\n-}\n-\n-#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n-enum ContextKind {\n-    Activation,\n-    AssignLhs,\n-    AssignRhs,\n-    SetDiscrim,\n-    InlineAsm,\n-    SwitchInt,\n-    Drop,\n-    DropAndReplace,\n-    CallOperator,\n-    CallOperand,\n-    CallDest,\n-    Assert,\n-    Yield,\n-    FakeRead,\n-    StorageDead,\n-}\n-\n-impl ContextKind {\n-    fn new(self, loc: Location) -> Context {\n-        Context {\n-            kind: self,\n-            loc,\n-        }\n-    }\n-}"}, {"sha": "c64d4b4a531e046994e7a39e6ef4737c87e916c8", "filename": "src/librustc_mir/borrow_check/nll/explain_borrow/mod.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/99ebb7a51716a98b7d9b261a6d6b37695c6b2359/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99ebb7a51716a98b7d9b261a6d6b37695c6b2359/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Fmod.rs?ref=99ebb7a51716a98b7d9b261a6d6b37695c6b2359", "patch": "@@ -4,7 +4,7 @@ use crate::borrow_check::borrow_set::BorrowData;\n use crate::borrow_check::error_reporting::UseSpans;\n use crate::borrow_check::nll::region_infer::{Cause, RegionName};\n use crate::borrow_check::nll::ConstraintDescription;\n-use crate::borrow_check::{Context, MirBorrowckCtxt, WriteKind};\n+use crate::borrow_check::{MirBorrowckCtxt, WriteKind};\n use rustc::mir::{\n     CastKind, ConstraintCategory, FakeReadCause, Local, Location, Mir, Operand, Place, PlaceBase,\n     Projection, ProjectionElem, Rvalue, Statement, StatementKind, TerminatorKind,\n@@ -209,27 +209,27 @@ impl BorrowExplanation {\n \n impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n     /// Returns structured explanation for *why* the borrow contains the\n-    /// point from `context`. This is key for the \"3-point errors\"\n+    /// point from `location`. This is key for the \"3-point errors\"\n     /// [described in the NLL RFC][d].\n     ///\n     /// # Parameters\n     ///\n     /// - `borrow`: the borrow in question\n-    /// - `context`: where the borrow occurs\n+    /// - `location`: where the borrow occurs\n     /// - `kind_place`: if Some, this describes the statement that triggered the error.\n     ///   - first half is the kind of write, if any, being performed\n     ///   - second half is the place being accessed\n     ///\n     /// [d]: https://rust-lang.github.io/rfcs/2094-nll.html#leveraging-intuition-framing-errors-in-terms-of-points\n     pub(in crate::borrow_check) fn explain_why_borrow_contains_point(\n         &self,\n-        context: Context,\n+        location: Location,\n         borrow: &BorrowData<'tcx>,\n         kind_place: Option<(WriteKind, &Place<'tcx>)>,\n     ) -> BorrowExplanation {\n         debug!(\n-            \"explain_why_borrow_contains_point(context={:?}, borrow={:?}, kind_place={:?})\",\n-            context, borrow, kind_place\n+            \"explain_why_borrow_contains_point(location={:?}, borrow={:?}, kind_place={:?})\",\n+            location, borrow, kind_place\n         );\n \n         let regioncx = &self.nonlexical_regioncx;\n@@ -242,20 +242,20 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             borrow_region_vid\n         );\n \n-        let region_sub = regioncx.find_sub_region_live_at(borrow_region_vid, context.loc);\n+        let region_sub = regioncx.find_sub_region_live_at(borrow_region_vid, location);\n         debug!(\n             \"explain_why_borrow_contains_point: region_sub={:?}\",\n             region_sub\n         );\n \n-        match find_use::find(mir, regioncx, tcx, region_sub, context.loc) {\n+        match find_use::find(mir, regioncx, tcx, region_sub, location) {\n             Some(Cause::LiveVar(local, location)) => {\n                 let span = mir.source_info(location).span;\n                 let spans = self\n                     .move_spans(&Place::Base(PlaceBase::Local(local)), location)\n                     .or_else(|| self.borrow_spans(span, location));\n \n-                let borrow_location = context.loc;\n+                let borrow_location = location;\n                 if self.is_use_in_later_iteration_of_loop(borrow_location, location) {\n                     let later_use = self.later_use_kind(borrow, spans, location);\n                     BorrowExplanation::UsedLaterInLoop(later_use.0, later_use.1)"}, {"sha": "e3ab48ccff15b0a3f812fa77122c4996b9e89dcb", "filename": "src/librustc_mir/borrow_check/nll/invalidation.rs", "status": "modified", "additions": 40, "deletions": 42, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/99ebb7a51716a98b7d9b261a6d6b37695c6b2359/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Finvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99ebb7a51716a98b7d9b261a6d6b37695c6b2359/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Finvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Finvalidation.rs?ref=99ebb7a51716a98b7d9b261a6d6b37695c6b2359", "patch": "@@ -3,7 +3,6 @@ use crate::borrow_check::location::LocationTable;\n use crate::borrow_check::{JustWrite, WriteAndRead};\n use crate::borrow_check::{AccessDepth, Deep, Shallow};\n use crate::borrow_check::{ReadOrWrite, Activation, Read, Reservation, Write};\n-use crate::borrow_check::{Context, ContextKind};\n use crate::borrow_check::{LocalMutationIsAllowed, MutateMode};\n use crate::borrow_check::ArtificialField;\n use crate::borrow_check::{ReadKind, WriteKind};\n@@ -66,12 +65,12 @@ impl<'cx, 'tcx, 'gcx> Visitor<'tcx> for InvalidationGenerator<'cx, 'tcx, 'gcx> {\n         match statement.kind {\n             StatementKind::Assign(ref lhs, ref rhs) => {\n                 self.consume_rvalue(\n-                    ContextKind::AssignRhs.new(location),\n+                    location,\n                     rhs,\n                 );\n \n                 self.mutate_place(\n-                    ContextKind::AssignLhs.new(location),\n+                    location,\n                     lhs,\n                     Shallow(None),\n                     JustWrite\n@@ -85,35 +84,34 @@ impl<'cx, 'tcx, 'gcx> Visitor<'tcx> for InvalidationGenerator<'cx, 'tcx, 'gcx> {\n                 variant_index: _,\n             } => {\n                 self.mutate_place(\n-                    ContextKind::SetDiscrim.new(location),\n+                    location,\n                     place,\n                     Shallow(None),\n                     JustWrite,\n                 );\n             }\n             StatementKind::InlineAsm(ref asm) => {\n-                let context = ContextKind::InlineAsm.new(location);\n                 for (o, output) in asm.asm.outputs.iter().zip(asm.outputs.iter()) {\n                     if o.is_indirect {\n                         // FIXME(eddyb) indirect inline asm outputs should\n                         // be encoded through MIR place derefs instead.\n                         self.access_place(\n-                            context,\n+                            location,\n                             output,\n                             (Deep, Read(ReadKind::Copy)),\n                             LocalMutationIsAllowed::No,\n                         );\n                     } else {\n                         self.mutate_place(\n-                            context,\n+                            location,\n                             output,\n                             if o.is_rw { Deep } else { Shallow(None) },\n                             if o.is_rw { WriteAndRead } else { JustWrite },\n                         );\n                     }\n                 }\n                 for (_, input) in asm.inputs.iter() {\n-                    self.consume_operand(context, input);\n+                    self.consume_operand(location, input);\n                 }\n             }\n             StatementKind::Nop |\n@@ -125,7 +123,7 @@ impl<'cx, 'tcx, 'gcx> Visitor<'tcx> for InvalidationGenerator<'cx, 'tcx, 'gcx> {\n             }\n             StatementKind::StorageDead(local) => {\n                 self.access_place(\n-                    ContextKind::StorageDead.new(location),\n+                    location,\n                     &Place::Base(PlaceBase::Local(local)),\n                     (Shallow(None), Write(WriteKind::StorageDeadOrDrop)),\n                     LocalMutationIsAllowed::Yes,\n@@ -150,15 +148,15 @@ impl<'cx, 'tcx, 'gcx> Visitor<'tcx> for InvalidationGenerator<'cx, 'tcx, 'gcx> {\n                 values: _,\n                 targets: _,\n             } => {\n-                self.consume_operand(ContextKind::SwitchInt.new(location), discr);\n+                self.consume_operand(location, discr);\n             }\n             TerminatorKind::Drop {\n                 location: ref drop_place,\n                 target: _,\n                 unwind: _,\n             } => {\n                 self.access_place(\n-                    ContextKind::Drop.new(location),\n+                    location,\n                     drop_place,\n                     (AccessDepth::Drop, Write(WriteKind::StorageDeadOrDrop)),\n                     LocalMutationIsAllowed::Yes,\n@@ -171,13 +169,13 @@ impl<'cx, 'tcx, 'gcx> Visitor<'tcx> for InvalidationGenerator<'cx, 'tcx, 'gcx> {\n                 unwind: _,\n             } => {\n                 self.mutate_place(\n-                    ContextKind::DropAndReplace.new(location),\n+                    location,\n                     drop_place,\n                     Deep,\n                     JustWrite,\n                 );\n                 self.consume_operand(\n-                    ContextKind::DropAndReplace.new(location),\n+                    location,\n                     new_value,\n                 );\n             }\n@@ -188,13 +186,13 @@ impl<'cx, 'tcx, 'gcx> Visitor<'tcx> for InvalidationGenerator<'cx, 'tcx, 'gcx> {\n                 cleanup: _,\n                 from_hir_call: _,\n             } => {\n-                self.consume_operand(ContextKind::CallOperator.new(location), func);\n+                self.consume_operand(location, func);\n                 for arg in args {\n-                    self.consume_operand(ContextKind::CallOperand.new(location), arg);\n+                    self.consume_operand(location, arg);\n                 }\n                 if let Some((ref dest, _ /*bb*/)) = *destination {\n                     self.mutate_place(\n-                        ContextKind::CallDest.new(location),\n+                        location,\n                         dest,\n                         Deep,\n                         JustWrite,\n@@ -208,19 +206,19 @@ impl<'cx, 'tcx, 'gcx> Visitor<'tcx> for InvalidationGenerator<'cx, 'tcx, 'gcx> {\n                 target: _,\n                 cleanup: _,\n             } => {\n-                self.consume_operand(ContextKind::Assert.new(location), cond);\n+                self.consume_operand(location, cond);\n                 use rustc::mir::interpret::InterpError::BoundsCheck;\n                 if let BoundsCheck { ref len, ref index } = *msg {\n-                    self.consume_operand(ContextKind::Assert.new(location), len);\n-                    self.consume_operand(ContextKind::Assert.new(location), index);\n+                    self.consume_operand(location, len);\n+                    self.consume_operand(location, index);\n                 }\n             }\n             TerminatorKind::Yield {\n                 ref value,\n                 resume,\n                 drop: _,\n             } => {\n-                self.consume_operand(ContextKind::Yield.new(location), value);\n+                self.consume_operand(location, value);\n \n                 // Invalidate all borrows of local places\n                 let borrow_set = self.borrow_set.clone();\n@@ -264,13 +262,13 @@ impl<'cg, 'cx, 'tcx, 'gcx> InvalidationGenerator<'cx, 'tcx, 'gcx> {\n     /// Simulates mutation of a place.\n     fn mutate_place(\n         &mut self,\n-        context: Context,\n+        location: Location,\n         place: &Place<'tcx>,\n         kind: AccessDepth,\n         _mode: MutateMode,\n     ) {\n         self.access_place(\n-            context,\n+            location,\n             place,\n             (kind, Write(WriteKind::Mutate)),\n             LocalMutationIsAllowed::ExceptUpvars,\n@@ -280,21 +278,21 @@ impl<'cg, 'cx, 'tcx, 'gcx> InvalidationGenerator<'cx, 'tcx, 'gcx> {\n     /// Simulates consumption of an operand.\n     fn consume_operand(\n         &mut self,\n-        context: Context,\n+        location: Location,\n         operand: &Operand<'tcx>,\n     ) {\n         match *operand {\n             Operand::Copy(ref place) => {\n                 self.access_place(\n-                    context,\n+                    location,\n                     place,\n                     (Deep, Read(ReadKind::Copy)),\n                     LocalMutationIsAllowed::No,\n                 );\n             }\n             Operand::Move(ref place) => {\n                 self.access_place(\n-                    context,\n+                    location,\n                     place,\n                     (Deep, Write(WriteKind::Move)),\n                     LocalMutationIsAllowed::Yes,\n@@ -307,7 +305,7 @@ impl<'cg, 'cx, 'tcx, 'gcx> InvalidationGenerator<'cx, 'tcx, 'gcx> {\n     // Simulates consumption of an rvalue\n     fn consume_rvalue(\n         &mut self,\n-        context: Context,\n+        location: Location,\n         rvalue: &Rvalue<'tcx>,\n     ) {\n         match *rvalue {\n@@ -328,7 +326,7 @@ impl<'cg, 'cx, 'tcx, 'gcx> InvalidationGenerator<'cx, 'tcx, 'gcx> {\n                 };\n \n                 self.access_place(\n-                    context,\n+                    location,\n                     place,\n                     access_kind,\n                     LocalMutationIsAllowed::No,\n@@ -339,7 +337,7 @@ impl<'cg, 'cx, 'tcx, 'gcx> InvalidationGenerator<'cx, 'tcx, 'gcx> {\n             | Rvalue::Repeat(ref operand, _)\n             | Rvalue::UnaryOp(_ /*un_op*/, ref operand)\n             | Rvalue::Cast(_ /*cast_kind*/, ref operand, _ /*ty*/) => {\n-                self.consume_operand(context, operand)\n+                self.consume_operand(location, operand)\n             }\n \n             Rvalue::Len(ref place) | Rvalue::Discriminant(ref place) => {\n@@ -349,7 +347,7 @@ impl<'cg, 'cx, 'tcx, 'gcx> InvalidationGenerator<'cx, 'tcx, 'gcx> {\n                     _ => unreachable!(),\n                 };\n                 self.access_place(\n-                    context,\n+                    location,\n                     place,\n                     (Shallow(af), Read(ReadKind::Copy)),\n                     LocalMutationIsAllowed::No,\n@@ -358,16 +356,16 @@ impl<'cg, 'cx, 'tcx, 'gcx> InvalidationGenerator<'cx, 'tcx, 'gcx> {\n \n             Rvalue::BinaryOp(_bin_op, ref operand1, ref operand2)\n             | Rvalue::CheckedBinaryOp(_bin_op, ref operand1, ref operand2) => {\n-                self.consume_operand(context, operand1);\n-                self.consume_operand(context, operand2);\n+                self.consume_operand(location, operand1);\n+                self.consume_operand(location, operand2);\n             }\n \n             Rvalue::NullaryOp(_op, _ty) => {\n             }\n \n             Rvalue::Aggregate(_, ref operands) => {\n                 for operand in operands {\n-                    self.consume_operand(context, operand);\n+                    self.consume_operand(location, operand);\n                 }\n             }\n         }\n@@ -376,27 +374,27 @@ impl<'cg, 'cx, 'tcx, 'gcx> InvalidationGenerator<'cx, 'tcx, 'gcx> {\n     /// Simulates an access to a place.\n     fn access_place(\n         &mut self,\n-        context: Context,\n+        location: Location,\n         place: &Place<'tcx>,\n         kind: (AccessDepth, ReadOrWrite),\n         _is_local_mutation_allowed: LocalMutationIsAllowed,\n     ) {\n         let (sd, rw) = kind;\n         // note: not doing check_access_permissions checks because they don't generate invalidates\n-        self.check_access_for_conflict(context, place, sd, rw);\n+        self.check_access_for_conflict(location, place, sd, rw);\n     }\n \n     fn check_access_for_conflict(\n         &mut self,\n-        context: Context,\n+        location: Location,\n         place: &Place<'tcx>,\n         sd: AccessDepth,\n         rw: ReadOrWrite,\n     ) {\n         debug!(\n-            \"invalidation::check_access_for_conflict(context={:?}, place={:?}, sd={:?}, \\\n+            \"invalidation::check_access_for_conflict(location={:?}, place={:?}, sd={:?}, \\\n              rw={:?})\",\n-            context,\n+            location,\n             place,\n             sd,\n             rw,\n@@ -409,7 +407,7 @@ impl<'cg, 'cx, 'tcx, 'gcx> InvalidationGenerator<'cx, 'tcx, 'gcx> {\n             self,\n             tcx,\n             mir,\n-            context,\n+            location,\n             (sd, place),\n             &borrow_set.clone(),\n             indices,\n@@ -435,15 +433,15 @@ impl<'cg, 'cx, 'tcx, 'gcx> InvalidationGenerator<'cx, 'tcx, 'gcx> {\n \n                     (Read(_), BorrowKind::Unique) | (Read(_), BorrowKind::Mut { .. }) => {\n                         // Reading from mere reservations of mutable-borrows is OK.\n-                        if !is_active(&this.dominators, borrow, context.loc) {\n+                        if !is_active(&this.dominators, borrow, location) {\n                             // If the borrow isn't active yet, reads don't invalidate it\n                             assert!(allow_two_phase_borrow(borrow.kind));\n                             return Control::Continue;\n                         }\n \n                         // Unique and mutable borrows are invalidated by reads from any\n                         // involved path\n-                        this.generate_invalidates(borrow_index, context.loc);\n+                        this.generate_invalidates(borrow_index, location);\n                     }\n \n                     (Reservation(_), _)\n@@ -453,7 +451,7 @@ impl<'cg, 'cx, 'tcx, 'gcx> InvalidationGenerator<'cx, 'tcx, 'gcx> {\n                         // Reservations count as writes since we need to check\n                         // that activating the borrow will be OK\n                         // FIXME(bob_twinkles) is this actually the right thing to do?\n-                        this.generate_invalidates(borrow_index, context.loc);\n+                        this.generate_invalidates(borrow_index, location);\n                     }\n                 }\n                 Control::Continue\n@@ -485,7 +483,7 @@ impl<'cg, 'cx, 'tcx, 'gcx> InvalidationGenerator<'cx, 'tcx, 'gcx> {\n             });\n \n             self.access_place(\n-                ContextKind::Activation.new(location),\n+                location,\n                 &borrow.borrowed_place,\n                 (\n                     Deep,"}, {"sha": "0c2a4ef45f104f3986d33da833a689eb1e30913c", "filename": "src/librustc_mir/borrow_check/path_utils.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/99ebb7a51716a98b7d9b261a6d6b37695c6b2359/src%2Flibrustc_mir%2Fborrow_check%2Fpath_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99ebb7a51716a98b7d9b261a6d6b37695c6b2359/src%2Flibrustc_mir%2Fborrow_check%2Fpath_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fpath_utils.rs?ref=99ebb7a51716a98b7d9b261a6d6b37695c6b2359", "patch": "@@ -1,6 +1,5 @@\n use crate::borrow_check::borrow_set::{BorrowSet, BorrowData, TwoPhaseActivation};\n use crate::borrow_check::places_conflict;\n-use crate::borrow_check::Context;\n use crate::borrow_check::AccessDepth;\n use crate::dataflow::indexes::BorrowIndex;\n use rustc::mir::{BasicBlock, Location, Mir, Place, PlaceBase};\n@@ -27,7 +26,7 @@ pub(super) fn each_borrow_involving_path<'a, 'tcx, 'gcx: 'tcx, F, I, S> (\n     s: &mut S,\n     tcx: TyCtxt<'a, 'gcx, 'tcx>,\n     mir: &Mir<'tcx>,\n-    _context: Context,\n+    _location: Location,\n     access_place: (AccessDepth, &Place<'tcx>),\n     borrow_set: &BorrowSet<'tcx>,\n     candidates: I,"}]}