{"sha": "d1f0f04a488d027fdf91e08cdf25df00fb677205", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQxZjBmMDRhNDg4ZDAyN2ZkZjkxZTA4Y2RmMjVkZjAwZmI2NzcyMDU=", "commit": {"author": {"name": "Michael Wright", "email": "mikerite@lavabit.com", "date": "2020-09-14T04:11:35Z"}, "committer": {"name": "Michael Wright", "email": "mikerite@lavabit.com", "date": "2020-09-14T04:11:35Z"}, "message": "New lint: `manual-strip`\n\nAdd a new lint, `manual-strip`, that suggests using the `str::strip_prefix`\nand `str::strip_suffix` methods introduced in Rust 1.45 when the same\nfunctionality is performed 'manually'.\n\nCloses #5734", "tree": {"sha": "9940a360cbbc9fb04beff141a212b7f366f74997", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9940a360cbbc9fb04beff141a212b7f366f74997"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d1f0f04a488d027fdf91e08cdf25df00fb677205", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d1f0f04a488d027fdf91e08cdf25df00fb677205", "html_url": "https://github.com/rust-lang/rust/commit/d1f0f04a488d027fdf91e08cdf25df00fb677205", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d1f0f04a488d027fdf91e08cdf25df00fb677205/comments", "author": null, "committer": null, "parents": [{"sha": "231444d989db23ab53001e29af53fa844e0b08a1", "url": "https://api.github.com/repos/rust-lang/rust/commits/231444d989db23ab53001e29af53fa844e0b08a1", "html_url": "https://github.com/rust-lang/rust/commit/231444d989db23ab53001e29af53fa844e0b08a1"}], "stats": {"total": 453, "additions": 453, "deletions": 0}, "files": [{"sha": "a6fafdf53572892a653edd59aca55c6b026cb722", "filename": "CHANGELOG.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d1f0f04a488d027fdf91e08cdf25df00fb677205/CHANGELOG.md", "raw_url": "https://github.com/rust-lang/rust/raw/d1f0f04a488d027fdf91e08cdf25df00fb677205/CHANGELOG.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CHANGELOG.md?ref=d1f0f04a488d027fdf91e08cdf25df00fb677205", "patch": "@@ -1672,6 +1672,7 @@ Released 2018-09-13\n [`manual_memcpy`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_memcpy\n [`manual_non_exhaustive`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_non_exhaustive\n [`manual_saturating_arithmetic`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_saturating_arithmetic\n+[`manual_strip`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_strip\n [`manual_swap`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_swap\n [`many_single_char_names`]: https://rust-lang.github.io/rust-clippy/master/index.html#many_single_char_names\n [`map_clone`]: https://rust-lang.github.io/rust-clippy/master/index.html#map_clone"}, {"sha": "38ddc69c8cbbc392a21b83120f64b28cffde7ea6", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d1f0f04a488d027fdf91e08cdf25df00fb677205/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1f0f04a488d027fdf91e08cdf25df00fb677205/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=d1f0f04a488d027fdf91e08cdf25df00fb677205", "patch": "@@ -230,6 +230,7 @@ mod macro_use;\n mod main_recursion;\n mod manual_async_fn;\n mod manual_non_exhaustive;\n+mod manual_strip;\n mod map_clone;\n mod map_identity;\n mod map_unit_fn;\n@@ -626,6 +627,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         &main_recursion::MAIN_RECURSION,\n         &manual_async_fn::MANUAL_ASYNC_FN,\n         &manual_non_exhaustive::MANUAL_NON_EXHAUSTIVE,\n+        &manual_strip::MANUAL_STRIP,\n         &map_clone::MAP_CLONE,\n         &map_identity::MAP_IDENTITY,\n         &map_unit_fn::OPTION_MAP_UNIT_FN,\n@@ -1109,6 +1111,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(|| box self_assignment::SelfAssignment);\n     store.register_late_pass(|| box float_equality_without_abs::FloatEqualityWithoutAbs);\n     store.register_late_pass(|| box async_yields_async::AsyncYieldsAsync);\n+    store.register_late_pass(|| box manual_strip::ManualStrip);\n \n     store.register_group(true, \"clippy::restriction\", Some(\"clippy_restriction\"), vec![\n         LintId::of(&arithmetic::FLOAT_ARITHMETIC),\n@@ -1335,6 +1338,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&main_recursion::MAIN_RECURSION),\n         LintId::of(&manual_async_fn::MANUAL_ASYNC_FN),\n         LintId::of(&manual_non_exhaustive::MANUAL_NON_EXHAUSTIVE),\n+        LintId::of(&manual_strip::MANUAL_STRIP),\n         LintId::of(&map_clone::MAP_CLONE),\n         LintId::of(&map_identity::MAP_IDENTITY),\n         LintId::of(&map_unit_fn::OPTION_MAP_UNIT_FN),\n@@ -1626,6 +1630,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&loops::EXPLICIT_COUNTER_LOOP),\n         LintId::of(&loops::MUT_RANGE_BOUND),\n         LintId::of(&loops::WHILE_LET_LOOP),\n+        LintId::of(&manual_strip::MANUAL_STRIP),\n         LintId::of(&map_identity::MAP_IDENTITY),\n         LintId::of(&map_unit_fn::OPTION_MAP_UNIT_FN),\n         LintId::of(&map_unit_fn::RESULT_MAP_UNIT_FN),"}, {"sha": "127938aecd63cc856b5a168ed336eb6e3dd7c1fd", "filename": "clippy_lints/src/manual_strip.rs", "status": "added", "additions": 246, "deletions": 0, "changes": 246, "blob_url": "https://github.com/rust-lang/rust/blob/d1f0f04a488d027fdf91e08cdf25df00fb677205/clippy_lints%2Fsrc%2Fmanual_strip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1f0f04a488d027fdf91e08cdf25df00fb677205/clippy_lints%2Fsrc%2Fmanual_strip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmanual_strip.rs?ref=d1f0f04a488d027fdf91e08cdf25df00fb677205", "patch": "@@ -0,0 +1,246 @@\n+use crate::consts::{constant, Constant};\n+use crate::utils::usage::mutated_variables;\n+use crate::utils::{\n+    eq_expr_value, higher, match_def_path, multispan_sugg, paths, qpath_res, snippet, span_lint_and_then,\n+};\n+\n+use if_chain::if_chain;\n+use rustc_ast::ast::LitKind;\n+use rustc_hir::def::Res;\n+use rustc_hir::intravisit::{walk_expr, NestedVisitorMap, Visitor};\n+use rustc_hir::BinOpKind;\n+use rustc_hir::{BorrowKind, Expr, ExprKind};\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_middle::hir::map::Map;\n+use rustc_middle::ty;\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::source_map::Spanned;\n+use rustc_span::Span;\n+\n+declare_clippy_lint! {\n+    /// **What it does:**\n+    /// Suggests using `strip_{prefix,suffix}` over `str::{starts,ends}_with` and slicing using\n+    /// the pattern's length.\n+    ///\n+    /// **Why is this bad?**\n+    /// Using `str:strip_{prefix,suffix}` is safer and may have better performance as there is no\n+    /// slicing which may panic and the compiler does not need to insert this panic code. It is\n+    /// also sometimes more readable as it removes the need for duplicating or storing the pattern\n+    /// used by `str::{starts,ends}_with` and in the slicing.\n+    ///\n+    /// **Known problems:**\n+    /// None.\n+    ///\n+    /// **Example:**\n+    ///\n+    /// ```rust\n+    /// let s = \"hello, world!\";\n+    /// if s.starts_with(\"hello, \") {\n+    ///     assert_eq!(s[\"hello, \".len()..].to_uppercase(), \"WORLD!\");\n+    /// }\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// let s = \"hello, world!\";\n+    /// if let Some(end) = s.strip_prefix(\"hello, \") {\n+    ///     assert_eq!(end.to_uppercase(), \"WORLD!\");\n+    /// }\n+    /// ```\n+    pub MANUAL_STRIP,\n+    complexity,\n+    \"suggests using `strip_{prefix,suffix}` over `str::{starts,ends}_with` and slicing\"\n+}\n+\n+declare_lint_pass!(ManualStrip => [MANUAL_STRIP]);\n+\n+#[derive(Clone, Copy, Debug, Eq, PartialEq)]\n+enum StripKind {\n+    Prefix,\n+    Suffix,\n+}\n+\n+impl<'tcx> LateLintPass<'tcx> for ManualStrip {\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n+        if_chain! {\n+            if let Some((cond, then, _)) = higher::if_block(&expr);\n+            if let ExprKind::MethodCall(_, _, [target_arg, pattern], _) = cond.kind;\n+            if let Some(method_def_id) = cx.typeck_results().type_dependent_def_id(cond.hir_id);\n+            if let ExprKind::Path(target_path) = &target_arg.kind;\n+            then {\n+                let strip_kind = if match_def_path(cx, method_def_id, &paths::STR_STARTS_WITH) {\n+                    StripKind::Prefix\n+                } else if match_def_path(cx, method_def_id, &paths::STR_ENDS_WITH) {\n+                    StripKind::Suffix\n+                } else {\n+                    return;\n+                };\n+                let target_res = qpath_res(cx, &target_path, target_arg.hir_id);\n+                if target_res == Res::Err {\n+                    return;\n+                };\n+\n+                if_chain! {\n+                    if let Res::Local(hir_id) = target_res;\n+                    if let Some(used_mutably) = mutated_variables(then, cx);\n+                    if used_mutably.contains(&hir_id);\n+                    then {\n+                        return;\n+                    }\n+                }\n+\n+                let strippings = find_stripping(cx, strip_kind, target_res, pattern, then);\n+                if !strippings.is_empty() {\n+\n+                    let kind_word = match strip_kind {\n+                        StripKind::Prefix => \"prefix\",\n+                        StripKind::Suffix => \"suffix\",\n+                    };\n+\n+                    let test_span = expr.span.until(then.span);\n+                    span_lint_and_then(cx, MANUAL_STRIP, strippings[0], &format!(\"stripping a {} manually\", kind_word), |diag| {\n+                        diag.span_note(test_span, &format!(\"the {} was tested here\", kind_word));\n+                        multispan_sugg(\n+                            diag,\n+                            &format!(\"try using the `strip_{}` method\", kind_word),\n+                            vec![(test_span,\n+                                  format!(\"if let Some(<stripped>) = {}.strip_{}({}) \",\n+                                          snippet(cx, target_arg.span, \"..\"),\n+                                          kind_word,\n+                                          snippet(cx, pattern.span, \"..\")))]\n+                            .into_iter().chain(strippings.into_iter().map(|span| (span, \"<stripped>\".into()))),\n+                        )\n+                    });\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+// Returns `Some(arg)` if `expr` matches `arg.len()` and `None` otherwise.\n+fn len_arg<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) -> Option<&'tcx Expr<'tcx>> {\n+    if_chain! {\n+        if let ExprKind::MethodCall(_, _, [arg], _) = expr.kind;\n+        if let Some(method_def_id) = cx.typeck_results().type_dependent_def_id(expr.hir_id);\n+        if match_def_path(cx, method_def_id, &paths::STR_LEN);\n+        then {\n+            Some(arg)\n+        }\n+        else {\n+            None\n+        }\n+    }\n+}\n+\n+// Returns the length of the `expr` if it's a constant string or char.\n+fn constant_length(cx: &LateContext<'_>, expr: &Expr<'_>) -> Option<u128> {\n+    let (value, _) = constant(cx, cx.typeck_results(), expr)?;\n+    match value {\n+        Constant::Str(value) => Some(value.len() as u128),\n+        Constant::Char(value) => Some(value.len_utf8() as u128),\n+        _ => None,\n+    }\n+}\n+\n+// Tests if `expr` equals the length of the pattern.\n+fn eq_pattern_length<'tcx>(cx: &LateContext<'tcx>, pattern: &Expr<'_>, expr: &'tcx Expr<'_>) -> bool {\n+    if let ExprKind::Lit(Spanned {\n+        node: LitKind::Int(n, _),\n+        ..\n+    }) = expr.kind\n+    {\n+        constant_length(cx, pattern).map_or(false, |length| length == n)\n+    } else {\n+        len_arg(cx, expr).map_or(false, |arg| eq_expr_value(cx, pattern, arg))\n+    }\n+}\n+\n+// Tests if `expr` is a `&str`.\n+fn is_ref_str(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n+    match cx.typeck_results().expr_ty_adjusted(&expr).kind() {\n+        ty::Ref(_, ty, _) => ty.is_str(),\n+        _ => false,\n+    }\n+}\n+\n+// Removes the outer `AddrOf` expression if needed.\n+fn peel_ref<'a>(expr: &'a Expr<'_>) -> &'a Expr<'a> {\n+    if let ExprKind::AddrOf(BorrowKind::Ref, _, unref) = &expr.kind {\n+        unref\n+    } else {\n+        expr\n+    }\n+}\n+\n+// Find expressions where `target` is stripped using the length of `pattern`.\n+// We'll suggest replacing these expressions with the result of the `strip_{prefix,suffix}`\n+// method.\n+fn find_stripping<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    strip_kind: StripKind,\n+    target: Res,\n+    pattern: &'tcx Expr<'_>,\n+    expr: &'tcx Expr<'_>,\n+) -> Vec<Span> {\n+    struct StrippingFinder<'a, 'tcx> {\n+        cx: &'a LateContext<'tcx>,\n+        strip_kind: StripKind,\n+        target: Res,\n+        pattern: &'tcx Expr<'tcx>,\n+        results: Vec<Span>,\n+    }\n+\n+    impl<'a, 'tcx> Visitor<'tcx> for StrippingFinder<'a, 'tcx> {\n+        type Map = Map<'tcx>;\n+        fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n+            NestedVisitorMap::None\n+        }\n+\n+        fn visit_expr(&mut self, ex: &'tcx Expr<'_>) {\n+            if_chain! {\n+                if is_ref_str(self.cx, ex);\n+                let unref = peel_ref(ex);\n+                if let ExprKind::Index(indexed, index) = &unref.kind;\n+                if let Some(range) = higher::range(index);\n+                if let higher::Range { start, end, .. } = range;\n+                if let ExprKind::Path(path) = &indexed.kind;\n+                if qpath_res(self.cx, path, ex.hir_id) == self.target;\n+                then {\n+                    match (self.strip_kind, start, end) {\n+                        (StripKind::Prefix, Some(start), None) => {\n+                            if eq_pattern_length(self.cx, self.pattern, start) {\n+                                self.results.push(ex.span);\n+                                return;\n+                            }\n+                        },\n+                        (StripKind::Suffix, None, Some(end)) => {\n+                            if_chain! {\n+                                if let ExprKind::Binary(Spanned { node: BinOpKind::Sub, .. }, left, right) = end.kind;\n+                                if let Some(left_arg) = len_arg(self.cx, left);\n+                                if let ExprKind::Path(left_path) = &left_arg.kind;\n+                                if qpath_res(self.cx, left_path, left_arg.hir_id) == self.target;\n+                                if eq_pattern_length(self.cx, self.pattern, right);\n+                                then {\n+                                    self.results.push(ex.span);\n+                                    return;\n+                                }\n+                            }\n+                        },\n+                        _ => {}\n+                    }\n+                }\n+            }\n+\n+            walk_expr(self, ex);\n+        }\n+    }\n+\n+    let mut finder = StrippingFinder {\n+        cx,\n+        strip_kind,\n+        target,\n+        pattern,\n+        results: vec![],\n+    };\n+    walk_expr(&mut finder, expr);\n+    finder.results\n+}"}, {"sha": "f0f7719e2fdf0b9e0ad5a885c604c07d910c45ad", "filename": "clippy_lints/src/utils/paths.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d1f0f04a488d027fdf91e08cdf25df00fb677205/clippy_lints%2Fsrc%2Futils%2Fpaths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1f0f04a488d027fdf91e08cdf25df00fb677205/clippy_lints%2Fsrc%2Futils%2Fpaths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fpaths.rs?ref=d1f0f04a488d027fdf91e08cdf25df00fb677205", "patch": "@@ -115,6 +115,9 @@ pub const STD_MEM_TRANSMUTE: [&str; 3] = [\"std\", \"mem\", \"transmute\"];\n pub const STD_PTR_NULL: [&str; 3] = [\"std\", \"ptr\", \"null\"];\n pub const STRING_AS_MUT_STR: [&str; 4] = [\"alloc\", \"string\", \"String\", \"as_mut_str\"];\n pub const STRING_AS_STR: [&str; 4] = [\"alloc\", \"string\", \"String\", \"as_str\"];\n+pub const STR_ENDS_WITH: [&str; 4] = [\"core\", \"str\", \"<impl str>\", \"ends_with\"];\n+pub const STR_LEN: [&str; 4] = [\"core\", \"str\", \"<impl str>\", \"len\"];\n+pub const STR_STARTS_WITH: [&str; 4] = [\"core\", \"str\", \"<impl str>\", \"starts_with\"];\n pub const SYNTAX_CONTEXT: [&str; 3] = [\"rustc_span\", \"hygiene\", \"SyntaxContext\"];\n pub const TO_OWNED: [&str; 3] = [\"alloc\", \"borrow\", \"ToOwned\"];\n pub const TO_OWNED_METHOD: [&str; 4] = [\"alloc\", \"borrow\", \"ToOwned\", \"to_owned\"];"}, {"sha": "8bceef80abffc9d3b71ff6176f94d1d37f4bede1", "filename": "src/lintlist/mod.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d1f0f04a488d027fdf91e08cdf25df00fb677205/src%2Flintlist%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1f0f04a488d027fdf91e08cdf25df00fb677205/src%2Flintlist%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flintlist%2Fmod.rs?ref=d1f0f04a488d027fdf91e08cdf25df00fb677205", "patch": "@@ -1144,6 +1144,13 @@ pub static ref ALL_LINTS: Vec<Lint> = vec![\n         deprecation: None,\n         module: \"methods\",\n     },\n+    Lint {\n+        name: \"manual_strip\",\n+        group: \"complexity\",\n+        desc: \"suggests using `strip_{prefix,suffix}` over `str::{starts,ends}_with` and slicing\",\n+        deprecation: None,\n+        module: \"manual_strip\",\n+    },\n     Lint {\n         name: \"manual_swap\",\n         group: \"complexity\","}, {"sha": "d1b4772c7deea3929bf4713b8012b9a7b82deec1", "filename": "tests/ui/manual_strip.rs", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/d1f0f04a488d027fdf91e08cdf25df00fb677205/tests%2Fui%2Fmanual_strip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1f0f04a488d027fdf91e08cdf25df00fb677205/tests%2Fui%2Fmanual_strip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmanual_strip.rs?ref=d1f0f04a488d027fdf91e08cdf25df00fb677205", "patch": "@@ -0,0 +1,59 @@\n+#![warn(clippy::manual_strip)]\n+\n+fn main() {\n+    let s = \"abc\";\n+\n+    if s.starts_with(\"ab\") {\n+        str::to_string(&s[\"ab\".len()..]);\n+        s[\"ab\".len()..].to_string();\n+\n+        str::to_string(&s[2..]);\n+        s[2..].to_string();\n+    }\n+\n+    if s.ends_with(\"bc\") {\n+        str::to_string(&s[..s.len() - \"bc\".len()]);\n+        s[..s.len() - \"bc\".len()].to_string();\n+\n+        str::to_string(&s[..s.len() - 2]);\n+        s[..s.len() - 2].to_string();\n+    }\n+\n+    // Character patterns\n+    if s.starts_with('a') {\n+        str::to_string(&s[1..]);\n+        s[1..].to_string();\n+    }\n+\n+    // Variable prefix\n+    let prefix = \"ab\";\n+    if s.starts_with(prefix) {\n+        str::to_string(&s[prefix.len()..]);\n+    }\n+\n+    // Constant prefix\n+    const PREFIX: &str = \"ab\";\n+    if s.starts_with(PREFIX) {\n+        str::to_string(&s[PREFIX.len()..]);\n+        str::to_string(&s[2..]);\n+    }\n+\n+    // Constant target\n+    const TARGET: &str = \"abc\";\n+    if TARGET.starts_with(prefix) {\n+        str::to_string(&TARGET[prefix.len()..]);\n+    }\n+\n+    // String target - not mutated.\n+    let s1: String = \"abc\".into();\n+    if s1.starts_with(\"ab\") {\n+        s1[2..].to_uppercase();\n+    }\n+\n+    // String target - mutated. (Don't lint.)\n+    let mut s2: String = \"abc\".into();\n+    if s2.starts_with(\"ab\") {\n+        s2.push('d');\n+        s2[2..].to_uppercase();\n+    }\n+}"}, {"sha": "1352a8713d4f8d31ef98b3ec74b9b8ebbf88667b", "filename": "tests/ui/manual_strip.stderr", "status": "added", "additions": 132, "deletions": 0, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/d1f0f04a488d027fdf91e08cdf25df00fb677205/tests%2Fui%2Fmanual_strip.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d1f0f04a488d027fdf91e08cdf25df00fb677205/tests%2Fui%2Fmanual_strip.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmanual_strip.stderr?ref=d1f0f04a488d027fdf91e08cdf25df00fb677205", "patch": "@@ -0,0 +1,132 @@\n+error: stripping a prefix manually\n+  --> $DIR/manual_strip.rs:7:24\n+   |\n+LL |         str::to_string(&s[\"ab\".len()..]);\n+   |                        ^^^^^^^^^^^^^^^^\n+   |\n+   = note: `-D clippy::manual-strip` implied by `-D warnings`\n+note: the prefix was tested here\n+  --> $DIR/manual_strip.rs:6:5\n+   |\n+LL |     if s.starts_with(\"ab\") {\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^\n+help: try using the `strip_prefix` method\n+   |\n+LL |     if let Some(<stripped>) = s.strip_prefix(\"ab\") {\n+LL |         str::to_string(<stripped>);\n+LL |         <stripped>.to_string();\n+LL | \n+LL |         str::to_string(<stripped>);\n+LL |         <stripped>.to_string();\n+   |\n+\n+error: stripping a suffix manually\n+  --> $DIR/manual_strip.rs:15:24\n+   |\n+LL |         str::to_string(&s[..s.len() - \"bc\".len()]);\n+   |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+note: the suffix was tested here\n+  --> $DIR/manual_strip.rs:14:5\n+   |\n+LL |     if s.ends_with(\"bc\") {\n+   |     ^^^^^^^^^^^^^^^^^^^^^\n+help: try using the `strip_suffix` method\n+   |\n+LL |     if let Some(<stripped>) = s.strip_suffix(\"bc\") {\n+LL |         str::to_string(<stripped>);\n+LL |         <stripped>.to_string();\n+LL | \n+LL |         str::to_string(<stripped>);\n+LL |         <stripped>.to_string();\n+   |\n+\n+error: stripping a prefix manually\n+  --> $DIR/manual_strip.rs:24:24\n+   |\n+LL |         str::to_string(&s[1..]);\n+   |                        ^^^^^^^\n+   |\n+note: the prefix was tested here\n+  --> $DIR/manual_strip.rs:23:5\n+   |\n+LL |     if s.starts_with('a') {\n+   |     ^^^^^^^^^^^^^^^^^^^^^^\n+help: try using the `strip_prefix` method\n+   |\n+LL |     if let Some(<stripped>) = s.strip_prefix('a') {\n+LL |         str::to_string(<stripped>);\n+LL |         <stripped>.to_string();\n+   |\n+\n+error: stripping a prefix manually\n+  --> $DIR/manual_strip.rs:31:24\n+   |\n+LL |         str::to_string(&s[prefix.len()..]);\n+   |                        ^^^^^^^^^^^^^^^^^^\n+   |\n+note: the prefix was tested here\n+  --> $DIR/manual_strip.rs:30:5\n+   |\n+LL |     if s.starts_with(prefix) {\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n+help: try using the `strip_prefix` method\n+   |\n+LL |     if let Some(<stripped>) = s.strip_prefix(prefix) {\n+LL |         str::to_string(<stripped>);\n+   |\n+\n+error: stripping a prefix manually\n+  --> $DIR/manual_strip.rs:37:24\n+   |\n+LL |         str::to_string(&s[PREFIX.len()..]);\n+   |                        ^^^^^^^^^^^^^^^^^^\n+   |\n+note: the prefix was tested here\n+  --> $DIR/manual_strip.rs:36:5\n+   |\n+LL |     if s.starts_with(PREFIX) {\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n+help: try using the `strip_prefix` method\n+   |\n+LL |     if let Some(<stripped>) = s.strip_prefix(PREFIX) {\n+LL |         str::to_string(<stripped>);\n+LL |         str::to_string(<stripped>);\n+   |\n+\n+error: stripping a prefix manually\n+  --> $DIR/manual_strip.rs:44:24\n+   |\n+LL |         str::to_string(&TARGET[prefix.len()..]);\n+   |                        ^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+note: the prefix was tested here\n+  --> $DIR/manual_strip.rs:43:5\n+   |\n+LL |     if TARGET.starts_with(prefix) {\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+help: try using the `strip_prefix` method\n+   |\n+LL |     if let Some(<stripped>) = TARGET.strip_prefix(prefix) {\n+LL |         str::to_string(<stripped>);\n+   |\n+\n+error: stripping a prefix manually\n+  --> $DIR/manual_strip.rs:50:9\n+   |\n+LL |         s1[2..].to_uppercase();\n+   |         ^^^^^^^\n+   |\n+note: the prefix was tested here\n+  --> $DIR/manual_strip.rs:49:5\n+   |\n+LL |     if s1.starts_with(\"ab\") {\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^\n+help: try using the `strip_prefix` method\n+   |\n+LL |     if let Some(<stripped>) = s1.strip_prefix(\"ab\") {\n+LL |         <stripped>.to_uppercase();\n+   |\n+\n+error: aborting due to 7 previous errors\n+"}]}