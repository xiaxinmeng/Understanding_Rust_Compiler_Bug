{"sha": "1755b57e1a568176bc0bda144889460e7d603cd5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE3NTViNTdlMWE1NjgxNzZiYzBiZGExNDQ4ODk0NjBlN2Q2MDNjZDU=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2021-05-08T20:09:36Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2021-05-08T20:11:42Z"}, "message": "internal: pull_assignment_up uses mutable trees", "tree": {"sha": "3f6805d7bfe6824c2ce10e4922d5b6e1b2c13347", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3f6805d7bfe6824c2ce10e4922d5b6e1b2c13347"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1755b57e1a568176bc0bda144889460e7d603cd5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1755b57e1a568176bc0bda144889460e7d603cd5", "html_url": "https://github.com/rust-lang/rust/commit/1755b57e1a568176bc0bda144889460e7d603cd5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1755b57e1a568176bc0bda144889460e7d603cd5/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e603090961d950b1130950c179361b530c7ad10a", "url": "https://api.github.com/repos/rust-lang/rust/commits/e603090961d950b1130950c179361b530c7ad10a", "html_url": "https://github.com/rust-lang/rust/commit/e603090961d950b1130950c179361b530c7ad10a"}], "stats": {"total": 140, "additions": 71, "deletions": 69}, "files": [{"sha": "602c3813ede483343060e85c37f432581fbe7706", "filename": "crates/ide_assists/src/handlers/pull_assignment_up.rs", "status": "modified", "additions": 68, "deletions": 69, "changes": 137, "blob_url": "https://github.com/rust-lang/rust/blob/1755b57e1a568176bc0bda144889460e7d603cd5/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fpull_assignment_up.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1755b57e1a568176bc0bda144889460e7d603cd5/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fpull_assignment_up.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fpull_assignment_up.rs?ref=1755b57e1a568176bc0bda144889460e7d603cd5", "patch": "@@ -1,6 +1,6 @@\n use syntax::{\n-    ast::{self, edit::AstNodeEdit, make},\n-    AstNode,\n+    ast::{self, make},\n+    ted, AstNode,\n };\n \n use crate::{\n@@ -44,96 +44,95 @@ pub(crate) fn pull_assignment_up(acc: &mut Assists, ctx: &AssistContext) -> Opti\n         return None;\n     }\n \n-    let name_expr = assign_expr.lhs()?;\n-\n-    let old_stmt: ast::Expr;\n-    let new_stmt: ast::Expr;\n+    let mut collector = AssignmentsCollector {\n+        sema: &ctx.sema,\n+        common_lhs: assign_expr.lhs()?,\n+        assignments: Vec::new(),\n+    };\n \n-    if let Some(if_expr) = ctx.find_node_at_offset::<ast::IfExpr>() {\n-        new_stmt = exprify_if(&if_expr, &ctx.sema, &name_expr)?.indent(if_expr.indent_level());\n-        old_stmt = if_expr.into();\n+    let tgt: ast::Expr = if let Some(if_expr) = ctx.find_node_at_offset::<ast::IfExpr>() {\n+        collector.collect_if(&if_expr)?;\n+        if_expr.into()\n     } else if let Some(match_expr) = ctx.find_node_at_offset::<ast::MatchExpr>() {\n-        new_stmt = exprify_match(&match_expr, &ctx.sema, &name_expr)?;\n-        old_stmt = match_expr.into()\n+        collector.collect_match(&match_expr)?;\n+        match_expr.into()\n     } else {\n         return None;\n     };\n \n-    let expr_stmt = make::expr_stmt(new_stmt);\n-\n     acc.add(\n         AssistId(\"pull_assignment_up\", AssistKind::RefactorExtract),\n         \"Pull assignment up\",\n-        old_stmt.syntax().text_range(),\n+        tgt.syntax().text_range(),\n         move |edit| {\n-            edit.replace(old_stmt.syntax().text_range(), format!(\"{} = {};\", name_expr, expr_stmt));\n+            let assignments: Vec<_> = collector\n+                .assignments\n+                .into_iter()\n+                .map(|(stmt, rhs)| (edit.make_ast_mut(stmt), rhs.clone_for_update()))\n+                .collect();\n+\n+            let tgt = edit.make_ast_mut(tgt);\n+\n+            for (stmt, rhs) in assignments {\n+                ted::replace(stmt.syntax(), rhs.syntax());\n+            }\n+            let assign_expr = make::expr_assignment(collector.common_lhs, tgt.clone());\n+            let assign_stmt = make::expr_stmt(assign_expr);\n+\n+            ted::replace(tgt.syntax(), assign_stmt.syntax().clone_for_update());\n         },\n     )\n }\n \n-fn exprify_match(\n-    match_expr: &ast::MatchExpr,\n-    sema: &hir::Semantics<ide_db::RootDatabase>,\n-    name: &ast::Expr,\n-) -> Option<ast::Expr> {\n-    let new_arm_list = match_expr\n-        .match_arm_list()?\n-        .arms()\n-        .map(|arm| {\n-            if let ast::Expr::BlockExpr(block) = arm.expr()? {\n-                let new_block = exprify_block(&block, sema, name)?.indent(block.indent_level());\n-                Some(arm.replace_descendant(block, new_block))\n-            } else {\n-                None\n-            }\n-        })\n-        .collect::<Option<Vec<_>>>()?;\n-    let new_arm_list = match_expr\n-        .match_arm_list()?\n-        .replace_descendants(match_expr.match_arm_list()?.arms().zip(new_arm_list));\n-    Some(make::expr_match(match_expr.expr()?, new_arm_list))\n+struct AssignmentsCollector<'a> {\n+    sema: &'a hir::Semantics<'a, ide_db::RootDatabase>,\n+    common_lhs: ast::Expr,\n+    assignments: Vec<(ast::ExprStmt, ast::Expr)>,\n }\n \n-fn exprify_if(\n-    statement: &ast::IfExpr,\n-    sema: &hir::Semantics<ide_db::RootDatabase>,\n-    name: &ast::Expr,\n-) -> Option<ast::Expr> {\n-    let then_branch = exprify_block(&statement.then_branch()?, sema, name)?;\n-    let else_branch = match statement.else_branch()? {\n-        ast::ElseBranch::Block(block) => ast::ElseBranch::Block(exprify_block(&block, sema, name)?),\n-        ast::ElseBranch::IfExpr(expr) => {\n-            cov_mark::hit!(test_pull_assignment_up_chained_if);\n-            ast::ElseBranch::IfExpr(ast::IfExpr::cast(\n-                exprify_if(&expr, sema, name)?.syntax().to_owned(),\n-            )?)\n+impl<'a> AssignmentsCollector<'a> {\n+    fn collect_match(&mut self, match_expr: &ast::MatchExpr) -> Option<()> {\n+        for arm in match_expr.match_arm_list()?.arms() {\n+            match arm.expr()? {\n+                ast::Expr::BlockExpr(block) => self.collect_block(&block)?,\n+                // TODO: Handle this while we are at it?\n+                _ => return None,\n+            }\n         }\n-    };\n-    Some(make::expr_if(statement.condition()?, then_branch, Some(else_branch)))\n-}\n \n-fn exprify_block(\n-    block: &ast::BlockExpr,\n-    sema: &hir::Semantics<ide_db::RootDatabase>,\n-    name: &ast::Expr,\n-) -> Option<ast::BlockExpr> {\n-    if block.tail_expr().is_some() {\n-        return None;\n+        Some(())\n     }\n+    fn collect_if(&mut self, if_expr: &ast::IfExpr) -> Option<()> {\n+        let then_branch = if_expr.then_branch()?;\n+        self.collect_block(&then_branch)?;\n+\n+        match if_expr.else_branch()? {\n+            ast::ElseBranch::Block(block) => self.collect_block(&block),\n+            ast::ElseBranch::IfExpr(expr) => {\n+                cov_mark::hit!(test_pull_assignment_up_chained_if);\n+                self.collect_if(&expr)\n+            }\n+        }\n+    }\n+    fn collect_block(&mut self, block: &ast::BlockExpr) -> Option<()> {\n+        if block.tail_expr().is_some() {\n+            return None;\n+        }\n \n-    let mut stmts: Vec<_> = block.statements().collect();\n-    let stmt = stmts.pop()?;\n-\n-    if let ast::Stmt::ExprStmt(stmt) = stmt {\n-        if let ast::Expr::BinExpr(expr) = stmt.expr()? {\n-            if expr.op_kind()? == ast::BinOp::Assignment && is_equivalent(sema, &expr.lhs()?, name)\n-            {\n-                // The last statement in the block is an assignment to the name we want\n-                return Some(make::block_expr(stmts, Some(expr.rhs()?)));\n+        let last_stmt = block.statements().last()?;\n+        if let ast::Stmt::ExprStmt(stmt) = last_stmt {\n+            if let ast::Expr::BinExpr(expr) = stmt.expr()? {\n+                if expr.op_kind()? == ast::BinOp::Assignment\n+                    && is_equivalent(self.sema, &expr.lhs()?, &self.common_lhs)\n+                {\n+                    self.assignments.push((stmt, expr.rhs()?));\n+                    return Some(());\n+                }\n             }\n         }\n+\n+        None\n     }\n-    None\n }\n \n fn is_equivalent("}, {"sha": "5a6687397236f12924c11f0eccf84255162158f2", "filename": "crates/syntax/src/ast/make.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1755b57e1a568176bc0bda144889460e7d603cd5/crates%2Fsyntax%2Fsrc%2Fast%2Fmake.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1755b57e1a568176bc0bda144889460e7d603cd5/crates%2Fsyntax%2Fsrc%2Fast%2Fmake.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Fast%2Fmake.rs?ref=1755b57e1a568176bc0bda144889460e7d603cd5", "patch": "@@ -275,6 +275,9 @@ pub fn expr_tuple(elements: impl IntoIterator<Item = ast::Expr>) -> ast::Expr {\n     let expr = elements.into_iter().format(\", \");\n     expr_from_text(&format!(\"({})\", expr))\n }\n+pub fn expr_assignment(lhs: ast::Expr, rhs: ast::Expr) -> ast::Expr {\n+    expr_from_text(&format!(\"{} = {}\", lhs, rhs))\n+}\n fn expr_from_text(text: &str) -> ast::Expr {\n     ast_from_text(&format!(\"const C: () = {};\", text))\n }"}]}