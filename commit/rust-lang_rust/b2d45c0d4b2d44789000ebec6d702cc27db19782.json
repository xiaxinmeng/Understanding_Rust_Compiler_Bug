{"sha": "b2d45c0d4b2d44789000ebec6d702cc27db19782", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIyZDQ1YzBkNGIyZDQ0Nzg5MDAwZWJlYzZkNzAyY2MyN2RiMTk3ODI=", "commit": {"author": {"name": "Caleb Cartwright", "email": "caleb.cartwright@outlook.com", "date": "2021-05-15T02:53:36Z"}, "committer": {"name": "Caleb Cartwright", "email": "caleb.cartwright@outlook.com", "date": "2021-05-15T02:53:36Z"}, "message": "Add 'src/tools/rustfmt/' from commit '7872306edf2e11a69aaffb9434088fd66b46a863'\n\ngit-subtree-dir: src/tools/rustfmt\ngit-subtree-mainline: e659b6de9170c055b6f2d16e2679b22d67297b13\ngit-subtree-split: 7872306edf2e11a69aaffb9434088fd66b46a863", "tree": {"sha": "c3accc00616767e5de0f89f69ce87519f02de6d5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c3accc00616767e5de0f89f69ce87519f02de6d5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b2d45c0d4b2d44789000ebec6d702cc27db19782", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b2d45c0d4b2d44789000ebec6d702cc27db19782", "html_url": "https://github.com/rust-lang/rust/commit/b2d45c0d4b2d44789000ebec6d702cc27db19782", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b2d45c0d4b2d44789000ebec6d702cc27db19782/comments", "author": {"login": "calebcartwright", "id": 13042488, "node_id": "MDQ6VXNlcjEzMDQyNDg4", "avatar_url": "https://avatars.githubusercontent.com/u/13042488?v=4", "gravatar_id": "", "url": "https://api.github.com/users/calebcartwright", "html_url": "https://github.com/calebcartwright", "followers_url": "https://api.github.com/users/calebcartwright/followers", "following_url": "https://api.github.com/users/calebcartwright/following{/other_user}", "gists_url": "https://api.github.com/users/calebcartwright/gists{/gist_id}", "starred_url": "https://api.github.com/users/calebcartwright/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/calebcartwright/subscriptions", "organizations_url": "https://api.github.com/users/calebcartwright/orgs", "repos_url": "https://api.github.com/users/calebcartwright/repos", "events_url": "https://api.github.com/users/calebcartwright/events{/privacy}", "received_events_url": "https://api.github.com/users/calebcartwright/received_events", "type": "User", "site_admin": false}, "committer": {"login": "calebcartwright", "id": 13042488, "node_id": "MDQ6VXNlcjEzMDQyNDg4", "avatar_url": "https://avatars.githubusercontent.com/u/13042488?v=4", "gravatar_id": "", "url": "https://api.github.com/users/calebcartwright", "html_url": "https://github.com/calebcartwright", "followers_url": "https://api.github.com/users/calebcartwright/followers", "following_url": "https://api.github.com/users/calebcartwright/following{/other_user}", "gists_url": "https://api.github.com/users/calebcartwright/gists{/gist_id}", "starred_url": "https://api.github.com/users/calebcartwright/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/calebcartwright/subscriptions", "organizations_url": "https://api.github.com/users/calebcartwright/orgs", "repos_url": "https://api.github.com/users/calebcartwright/repos", "events_url": "https://api.github.com/users/calebcartwright/events{/privacy}", "received_events_url": "https://api.github.com/users/calebcartwright/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e659b6de9170c055b6f2d16e2679b22d67297b13", "url": "https://api.github.com/repos/rust-lang/rust/commits/e659b6de9170c055b6f2d16e2679b22d67297b13", "html_url": "https://github.com/rust-lang/rust/commit/e659b6de9170c055b6f2d16e2679b22d67297b13"}, {"sha": "7872306edf2e11a69aaffb9434088fd66b46a863", "url": "https://api.github.com/repos/rust-lang/rust/commits/7872306edf2e11a69aaffb9434088fd66b46a863", "html_url": "https://github.com/rust-lang/rust/commit/7872306edf2e11a69aaffb9434088fd66b46a863"}], "stats": {"total": 78073, "additions": 78073, "deletions": 0}, "files": [{"sha": "5bb92df3e04329867d1ed8bc6449f84ed4efb5d5", "filename": "src/tools/rustfmt/.editorconfig", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2F.editorconfig", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2F.editorconfig", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2F.editorconfig?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782", "patch": "@@ -0,0 +1,26 @@\n+root = true\n+\n+[*]\n+charset = utf-8\n+end_of_line = lf\n+indent_size = 2\n+indent_style = space\n+trim_trailing_whitespace = true\n+insert_final_newline = true\n+\n+[*.md]\n+trim_trailing_whitespace = false\n+\n+[*.rs]\n+indent_size = 4\n+\n+[tests/**/*.rs]\n+charset = utf-8\n+end_of_line = unset\n+indent_size = unset\n+indent_style = unset\n+trim_trailing_whitespace = unset\n+insert_final_newline = unset\n+\n+[appveyor.yml]\n+end_of_line = unset"}, {"sha": "91df4f0eb18dcf3b6aa8aa1686cd7110ebe97fbb", "filename": "src/tools/rustfmt/.gitattributes", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2F.gitattributes", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2F.gitattributes", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2F.gitattributes?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782", "patch": "@@ -0,0 +1,7 @@\n+* text=auto eol=lf\n+tests/source/issue-3494/crlf.rs -text\n+tests/source/comment_crlf_newline.rs -text\n+tests/source/configs/enum_discrim_align_threshold/40.rs -text\n+tests/target/issue-3494/crlf.rs -text\n+tests/target/comment_crlf_newline.rs -text\n+tests/target/configs/enum_discrim_align_threshold/40.rs -text"}, {"sha": "b79221d0543694426f2a460b6f60575c81acb6a7", "filename": "src/tools/rustfmt/.github/workflows/integration.yml", "status": "added", "additions": 85, "deletions": 0, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2F.github%2Fworkflows%2Fintegration.yml", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2F.github%2Fworkflows%2Fintegration.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2F.github%2Fworkflows%2Fintegration.yml?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782", "patch": "@@ -0,0 +1,85 @@\n+name: integration\n+on:\n+  push:\n+    branches:\n+      - master\n+  pull_request:\n+\n+jobs:\n+  integration-tests:\n+    runs-on: ubuntu-latest\n+    name: ${{ matrix.integration }}\n+    strategy:\n+      # https://help.github.com/en/actions/getting-started-with-github-actions/about-github-actions#usage-limits\n+      # There's a limit of 60 concurrent jobs across all repos in the rust-lang organization.\n+      # In order to prevent overusing too much of that 60 limit, we throttle the\n+      # number of rustfmt jobs that will run concurrently.\n+      max-parallel: 4\n+      fail-fast: false\n+      matrix:\n+        integration: [\n+          bitflags,\n+          error-chain,\n+          log,\n+          mdbook,\n+          packed_simd,\n+          rust-semverver,\n+          tempdir,\n+          futures-rs,\n+          rust-clippy,\n+          failure,\n+        ]\n+        include:\n+          # Allowed Failures\n+          # Actions doesn't yet support explicitly marking matrix legs as allowed failures\n+          # https://github.community/t5/GitHub-Actions/continue-on-error-allow-failure-UI-indication/td-p/37033\n+          # https://github.community/t5/GitHub-Actions/Why-a-matrix-step-will-be-canceled-if-another-one-failed/td-p/30920\n+          # Instead, leverage `continue-on-error`\n+          # https://help.github.com/en/actions/automating-your-workflow-with-github-actions/workflow-syntax-for-github-actions#jobsjob_idstepscontinue-on-error\n+          #\n+          # Failing due to breaking changes in rustfmt 2.0 where empty\n+          # match blocks have trailing commas removed\n+          # https://github.com/rust-lang/rustfmt/pull/4226\n+          - integration: chalk\n+            allow-failure: true\n+          - integration: crater\n+            allow-failure: true\n+          - integration: glob\n+            allow-failure: true\n+          - integration: stdsimd\n+            allow-failure: true\n+          # Using old rustfmt configuration option\n+          - integration: rand\n+            allow-failure: true\n+          # Keep this as an allowed failure as it's fragile to breaking changes of rustc.\n+          - integration: rust-clippy\n+            allow-failure: true\n+          # Using old rustfmt configuration option\n+          - integration: packed_simd\n+            allow-failure: true\n+          # calebcartwright (2019-12-24)\n+          # Keeping this as an allowed failure since it was flagged as such in the TravisCI config, even though\n+          # it appears to have been passing for quite some time.\n+          # Original comment was: temporal build failure due to breaking changes in the nightly compiler\n+          - integration: rust-semverver\n+            allow-failure: true\n+          # Can be moved back to include section after https://github.com/rust-lang-nursery/failure/pull/298 is merged\n+          - integration: failure\n+            allow-failure: true\n+\n+    steps:\n+    - name: checkout\n+      uses: actions/checkout@v2\n+\n+      # Run build\n+    - name: install rustup\n+      run: |\n+        curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs > rustup-init.sh\n+        sh rustup-init.sh -y --default-toolchain none\n+\n+    - name: run integration tests\n+      env:\n+        INTEGRATION: ${{ matrix.integration }}\n+        TARGET: x86_64-unknown-linux-gnu\n+      run: ./ci/integration.sh\n+      continue-on-error: ${{ matrix.allow-failure == true }}"}, {"sha": "6eaae69c708056c56c0e6c8d44883fb8625f241b", "filename": "src/tools/rustfmt/.github/workflows/linux.yml", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2F.github%2Fworkflows%2Flinux.yml", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2F.github%2Fworkflows%2Flinux.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2F.github%2Fworkflows%2Flinux.yml?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782", "patch": "@@ -0,0 +1,42 @@\n+name: linux\n+on:\n+  push:\n+    branches:\n+      - master\n+  pull_request:\n+\n+jobs:\n+  test:\n+    runs-on: ubuntu-latest\n+    name: (${{ matrix.target }}, nightly)\n+    strategy:\n+      # https://help.github.com/en/actions/getting-started-with-github-actions/about-github-actions#usage-limits\n+      # There's a limit of 60 concurrent jobs across all repos in the rust-lang organization.\n+      # In order to prevent overusing too much of that 60 limit, we throttle the\n+      # number of rustfmt jobs that will run concurrently.\n+      max-parallel: 1\n+      fail-fast: false\n+      matrix:\n+        target: [\n+          x86_64-unknown-linux-gnu,\n+        ]\n+\n+    steps:\n+    - name: checkout\n+      uses: actions/checkout@v2\n+\n+      # Run build\n+    - name: install rustup\n+      run: |\n+        curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs > rustup-init.sh\n+        sh rustup-init.sh -y --default-toolchain none\n+        rustup target add ${{ matrix.target }}\n+\n+    - name: build\n+      run: |\n+        rustc -Vv\n+        cargo -V\n+        cargo build\n+\n+    - name: test\n+      run: cargo test"}, {"sha": "79e4f69163e030b3a5eae659ab0165cb093790bf", "filename": "src/tools/rustfmt/.github/workflows/mac.yml", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2F.github%2Fworkflows%2Fmac.yml", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2F.github%2Fworkflows%2Fmac.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2F.github%2Fworkflows%2Fmac.yml?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782", "patch": "@@ -0,0 +1,39 @@\n+name: mac\n+on:\n+  push:\n+    branches:\n+      - master\n+  pull_request:\n+\n+jobs:\n+  test:\n+    # https://help.github.com/en/actions/automating-your-workflow-with-github-actions/virtual-environments-for-github-hosted-runners#supported-runners-and-hardware-resources\n+    # macOS Catalina 10.15\n+    runs-on: macos-latest\n+    name: (${{ matrix.target }}, nightly)\n+    strategy:\n+      fail-fast: false\n+      matrix:\n+        target: [\n+          x86_64-apple-darwin,\n+        ]\n+\n+    steps:\n+    - name: checkout\n+      uses: actions/checkout@v2\n+\n+      # Run build\n+    - name: install rustup\n+      run: |\n+        curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs > rustup-init.sh\n+        sh rustup-init.sh -y --default-toolchain none\n+        rustup target add ${{ matrix.target }}\n+\n+    - name: build\n+      run: |\n+        rustc -Vv\n+        cargo -V\n+        cargo build\n+\n+    - name: test\n+      run: cargo test"}, {"sha": "9a5fd0dd1d31b84ae98d1ff8dfaddaacba29aeed", "filename": "src/tools/rustfmt/.github/workflows/upload-assets.yml", "status": "added", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2F.github%2Fworkflows%2Fupload-assets.yml", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2F.github%2Fworkflows%2Fupload-assets.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2F.github%2Fworkflows%2Fupload-assets.yml?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782", "patch": "@@ -0,0 +1,80 @@\n+name: upload\n+\n+on:\n+  release:\n+    types: [created]\n+\n+jobs:\n+  build-release:\n+    name: build-release\n+    strategy:\n+      matrix:\n+        build: [linux-x86_64, macos-x86_64, windows-x86_64-gnu, windows-x86_64-msvc]\n+        include:\n+          - build: linux-x86_64\n+            os: ubuntu-latest\n+            rust: nightly\n+          - build: macos-x86_64\n+            os: macos-latest\n+            rust: nightly\n+          - build: windows-x86_64-gnu\n+            os: windows-latest\n+            rust: nightly-x86_64-gnu\n+          - build: windows-x86_64-msvc\n+            os: windows-latest\n+            rust: nightly-x86_64-msvc\n+    runs-on: ${{ matrix.os }}\n+    steps:\n+      - uses: actions/checkout@v2\n+\n+      - name: Install Rust\n+        uses: actions-rs/toolchain@v1\n+        with:\n+          profile: minimal\n+          toolchain: ${{ matrix.rust }}\n+          override: true\n+\n+      - name: Add mingw64 to path for x86_64-gnu\n+        run: echo \"C:\\msys64\\mingw64\\bin\" >> $GITHUB_PATH\n+        if: matrix.rust == 'nightly-x86_64-gnu'\n+        shell: bash\n+\n+      - name: Install cargo-make\n+        uses: actions-rs/cargo@v1\n+        with:\n+          command: install\n+          args: --force cargo-make\n+\n+      - name: Build release binaries\n+        uses: actions-rs/cargo@v1\n+        with:\n+          command: make\n+          args: release\n+\n+      - name: Build archive\n+        shell: bash\n+        run: |\n+          staging=\"rustfmt_${{ matrix.build }}_${{ github.event.release.tag_name }}\"\n+          mkdir -p \"$staging\"\n+\n+          cp {README.md,Configurations.md,CHANGELOG.md,LICENSE-MIT,LICENSE-APACHE} \"$staging/\"\n+\n+          if [ \"${{ matrix.os }}\" = \"windows-latest\" ]; then\n+            cp target/release/{rustfmt.exe,cargo-fmt.exe,rustfmt-format-diff.exe,git-rustfmt.exe} \"$staging/\"\n+            7z a \"$staging.zip\" \"$staging\"\n+            echo \"ASSET=$staging.zip\" >> $GITHUB_ENV\n+          else\n+            cp target/release/{rustfmt,cargo-fmt,rustfmt-format-diff,git-rustfmt} \"$staging/\"\n+            tar czf \"$staging.tar.gz\" \"$staging\"\n+            echo \"ASSET=$staging.tar.gz\" >> $GITHUB_ENV\n+          fi\n+\n+      - name: Upload Release Asset\n+        uses: actions/upload-release-asset@v1\n+        env:\n+          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n+        with:\n+          upload_url: ${{ github.event.release.upload_url }}\n+          asset_path: ${{ env.ASSET }}\n+          asset_name: ${{ env.ASSET }}\n+          asset_content_type: application/octet-stream"}, {"sha": "08cb52eedaea789ad2550f97e11e6dd92e2f2f37", "filename": "src/tools/rustfmt/.github/workflows/windows.yml", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2F.github%2Fworkflows%2Fwindows.yml", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2F.github%2Fworkflows%2Fwindows.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2F.github%2Fworkflows%2Fwindows.yml?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782", "patch": "@@ -0,0 +1,69 @@\n+name: windows\n+on:\n+  push:\n+    branches:\n+      - master\n+  pull_request:\n+\n+jobs:\n+  test:\n+    runs-on: windows-latest\n+    name: (${{ matrix.target }}, nightly)\n+    strategy:\n+      # https://help.github.com/en/actions/getting-started-with-github-actions/about-github-actions#usage-limits\n+      # There's a limit of 60 concurrent jobs across all repos in the rust-lang organization.\n+      # In order to prevent overusing too much of that 60 limit, we throttle the\n+      # number of rustfmt jobs that will run concurrently.\n+      max-parallel: 2\n+      fail-fast: false\n+      matrix:\n+        target: [\n+          i686-pc-windows-gnu,\n+          i686-pc-windows-msvc,\n+          x86_64-pc-windows-gnu,\n+          x86_64-pc-windows-msvc,\n+        ]\n+\n+    steps:\n+    # The Windows runners have autocrlf enabled by default\n+    # which causes failures for some of rustfmt's line-ending sensitive tests\n+    - name: disable git eol translation\n+      run: git config --global core.autocrlf false\n+    - name: checkout\n+      uses: actions/checkout@v2\n+\n+      # Run build\n+    - name: Install Rustup using win.rustup.rs\n+      run: |\n+        # Disable the download progress bar which can cause perf issues\n+        $ProgressPreference = \"SilentlyContinue\"\n+        Invoke-WebRequest https://win.rustup.rs/ -OutFile rustup-init.exe\n+        .\\rustup-init.exe -y --default-host=x86_64-pc-windows-msvc --default-toolchain=none\n+        del rustup-init.exe\n+        rustup target add ${{ matrix.target }}\n+      shell: powershell\n+\n+    - name: Add mingw32 to path for i686-gnu\n+      run: |\n+        echo \"C:\\msys64\\mingw32\\bin\" >> $GITHUB_PATH\n+      if: matrix.target == 'i686-pc-windows-gnu' && matrix.channel == 'nightly'\n+      shell: bash\n+\n+    - name: Add mingw64 to path for x86_64-gnu\n+      run: echo \"C:\\msys64\\mingw64\\bin\" >> $GITHUB_PATH\n+      if: matrix.target == 'x86_64-pc-windows-gnu' && matrix.channel == 'nightly'\n+      shell: bash\n+\n+    - name: cargo-make\n+      run: cargo install --force cargo-make\n+\n+    - name: build\n+      run: |\n+        rustc -Vv\n+        cargo -V\n+        cargo build\n+      shell: cmd\n+\n+    - name: test\n+      run: cargo test\n+      shell: cmd"}, {"sha": "37adf8751ca8f91fb041bcdbf31845632114562c", "filename": "src/tools/rustfmt/.gitignore", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2F.gitignore", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2F.gitignore", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2F.gitignore?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782", "patch": "@@ -0,0 +1,24 @@\n+\n+# Created by https://www.gitignore.io/api/rust\n+\n+### Rust ###\n+# Generated by Cargo\n+# will have compiled files and executables\n+/target\n+\n+# Remove Cargo.lock from gitignore if creating an executable, leave it for libraries\n+# More information here http://doc.crates.io/guide.html#cargotoml-vs-cargolock\n+# Cargo.lock\n+\n+# These are backup files generated by rustfmt\n+**/*.rs.bk\n+\n+# End of https://www.gitignore.io/api/rust\n+\n+# Used by macOS' file system to track custom attributes of containing folder\n+.DS_Store\n+\n+# Editors' specific files\n+.idea/\n+.vscode/\n+*~"}, {"sha": "d699bd842eeccb031b041de681252282f7a229cd", "filename": "src/tools/rustfmt/.travis.yml", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2F.travis.yml", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2F.travis.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2F.travis.yml?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782", "patch": "@@ -0,0 +1,77 @@\n+sudo: false\n+language: rust\n+rust: nightly\n+os: linux\n+cache:\n+ directories:\n+  - $HOME/.cargo\n+\n+addons:\n+  apt:\n+    packages:\n+    - libcurl4-openssl-dev\n+    - libelf-dev\n+    - libdw-dev\n+\n+matrix:\n+  include:\n+    - env: DEPLOY=LINUX\n+    - env: CFG_RELEASE_CHANNEL=beta\n+    - os: osx\n+    - env: INTEGRATION=bitflags\n+    - env: INTEGRATION=chalk\n+    - env: INTEGRATION=crater\n+    - env: INTEGRATION=error-chain\n+    - env: INTEGRATION=glob\n+    - env: INTEGRATION=log\n+    - env: INTEGRATION=mdbook\n+    - env: INTEGRATION=packed_simd\n+    - env: INTEGRATION=rust-semverver\n+    - env: INTEGRATION=stdsimd TARGET=x86_64-unknown-linux-gnu\n+    - env: INTEGRATION=tempdir\n+    - env: INTEGRATION=futures-rs\n+  allow_failures:\n+    # Using old configuration option\n+    - env: INTEGRATION=rand\n+    # Doesn't build - keep this in allow_failures as it's fragile to breaking changes of rustc.\n+    - env: INTEGRATION=rust-clippy\n+    # Doesn't build - seems to be because of an option\n+    - env: INTEGRATION=packed_simd\n+    # Doesn't build - a temporal build failure due to breaking changes in the nightly compilre\n+    - env: INTEGRATION=rust-semverver\n+    # can be moved back to include section after https://github.com/rust-lang-nursery/failure/pull/298 is merged\n+    - env: INTEGRATION=failure\n+    # `cargo test` doesn't finish - disabling for now.\n+    # - env: INTEGRATION=cargo\n+\n+script:\n+  - |\n+    if [ -z ${INTEGRATION} ]; then\n+      export CFG_RELEASE_CHANNEL=nightly\n+      export CFG_RELEASE=nightly\n+      cargo build\n+      cargo test\n+      cargo test -- --ignored\n+    else\n+      ./ci/integration.sh\n+    fi\n+\n+after_success:\n+- if [ -z ${INTEGRATION} ]; then travis-cargo coveralls --no-sudo; fi\n+\n+before_deploy:\n+  # TODO: cross build\n+ - cargo build --release --target=x86_64-unknown-linux-gnu\n+ - tar czf rustfmt-x86_64-unknown-linux-gnu.tar.gz Contributing.md Design.md README.md -C target/x86_64-unknown-linux-gnu/release/rustfmt rustfmt\n+\n+deploy:\n+  provider: releases\n+  api_key:\n+    secure: \"your own encrypted key\"\n+  file:\n+  - rustfmt-x86_64-unknown-linux-gnu.tar.gz\n+  on:\n+    repo: nrc/rustfmt\n+    tags: true\n+    condition: \"$DEPLOY = LINUX\"\n+  skip_cleanup: true"}, {"sha": "0f23663d6c2f9d057b35b8479bb3a1037fdea46b", "filename": "src/tools/rustfmt/CHANGELOG.md", "status": "added", "additions": 1168, "deletions": 0, "changes": 1168, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2FCHANGELOG.md", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2FCHANGELOG.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2FCHANGELOG.md?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782", "patch": "@@ -0,0 +1,1168 @@\n+# Changelog\n+\n+## [Unreleased]\n+\n+## [1.4.37] 2021-04-03\n+\n+### Changed\n+\n+- `rustc-ap-*` crates updated to v712.0.0\n+\n+### Fixed\n+- Resolve idempotence issue related to indentation of macro defs that contain or-patterns with inner comments ([#4603](https://github.com/rust-lang/rustfmt/issues/4603))\n+- Addressed various clippy and rustc warnings\n+\n+### Install/Download Options\n+- **crates.io package** - *pending*\n+- **rustup (nightly)** - *pending*\n+- **GitHub Release Binaries** - [Release v1.4.37](https://github.com/rust-lang/rustfmt/releases/tag/v1.4.37)\n+- **Build from source** - [Tag v1.4.37](https://github.com/rust-lang/rustfmt/tree/v1.4.37), see instructions for how to [install rustfmt from source][install-from-source]\n+\n+## [1.4.36] 2021-02-07\n+\n+### Changed\n+\n+- `rustc-ap-*` crates updated to v705.0.0\n+\n+### Install/Download Options\n+- **crates.io package** - *pending*\n+- **rustup (nightly)** - *pending*\n+- **GitHub Release Binaries** - [Release v1.4.36](https://github.com/rust-lang/rustfmt/releases/tag/v1.4.36)\n+- **Build from source** - [Tag v1.4.36](https://github.com/rust-lang/rustfmt/tree/v1.4.36), see instructions for how to [install rustfmt from source][install-from-source]\n+\n+## [1.4.35] 2021-02-03\n+\n+### Changed\n+\n+- `rustc-ap-*` crates updated to v702.0.0\n+\n+### Install/Download Options\n+- **crates.io package** - *pending*\n+- **rustup (nightly)** - *n/a (superseded by [v1.4.36](#1436-2021-02-07))\n+- **GitHub Release Binaries** - [Release v1.4.35](https://github.com/rust-lang/rustfmt/releases/tag/v1.4.35)\n+- **Build from source** - [Tag v1.4.35](https://github.com/rust-lang/rustfmt/tree/v1.4.35), see instructions for how to [install rustfmt from source][install-from-source]\n+\n+## [1.4.34] 2021-01-28\n+\n+### Fixed\n+- Don't insert trailing comma on (base-less) rest in struct literals within macros ([#4675](https://github.com/rust-lang/rustfmt/issues/4675))\n+\n+### Install/Download Options\n+- **crates.io package** - *pending*\n+- **rustup (nightly)** - Starting in `2021-01-31`\n+- **GitHub Release Binaries** - [Release v1.4.34](https://github.com/rust-lang/rustfmt/releases/tag/v1.4.34)\n+- **Build from source** - [Tag v1.4.34](https://github.com/rust-lang/rustfmt/tree/v1.4.34), see instructions for how to [install rustfmt from source][install-from-source]\n+\n+## [1.4.33] 2021-01-27\n+\n+### Changed\n+- `merge_imports` configuration has been deprecated in favor of the new `imports_granularity` option. Any existing usage of `merge_imports` will be automatically mapped to the corresponding value on `imports_granularity` with a warning message printed to encourage users to update their config files.\n+\n+### Added\n+- New `imports_granularity` option has been added which succeeds `merge_imports`. This new option supports several additional variants which allow users to merge imports at different levels (crate or module), and even flatten imports to have a single use statement per item. ([PR #4634](https://github.com/rust-lang/rustfmt/pull/4634), [PR #4639](https://github.com/rust-lang/rustfmt/pull/4639))\n+\n+See the section on the configuration site for more information\n+https://rust-lang.github.io/rustfmt/?version=v1.4.33&search=#imports_granularity\n+\n+### Fixed\n+- Fix erroneous removal of `const` keyword on const trait impl ([#4084](https://github.com/rust-lang/rustfmt/issues/4084))\n+- Fix incorrect span usage wit const generics in supertraits ([#4204](https://github.com/rust-lang/rustfmt/issues/4204))\n+- Use correct span for const generic params ([#4263](https://github.com/rust-lang/rustfmt/issues/4263))\n+- Correct span on const generics to include type bounds ([#4310](https://github.com/rust-lang/rustfmt/issues/4310))\n+- Idempotence issue on blocks containing only empty statements ([#4627](https://github.com/rust-lang/rustfmt/issues/4627) and [#3868](https://github.com/rust-lang/rustfmt/issues/3868))\n+- Fix issue with semicolon placement on required functions that have a trailing comment that ends in a line-style comment before the semicolon ([#4646](https://github.com/rust-lang/rustfmt/issues/4646))\n+- Avoid shared interned cfg_if symbol since rustfmt can re-initialize the rustc_ast globals on multiple inputs ([#4656](https://github.com/rust-lang/rustfmt/issues/4656))\n+\n+### Install/Download Options\n+- **crates.io package** - *pending*\n+- **rustup (nightly)** - n/a (superseded by [v1.4.34](#1434-2021-01-28))\n+- **GitHub Release Binaries** - [Release v1.4.33](https://github.com/rust-lang/rustfmt/releases/tag/v1.4.33)\n+- **Build from source** - [Tag v1.4.33](https://github.com/rust-lang/rustfmt/tree/v1.4.33), see instructions for how to [install rustfmt from source][install-from-source]\n+\n+## [1.4.32] 2021-01-16\n+\n+### Fixed\n+- Indentation now correct on first bound in cases where the generic bounds are multiline formatted and the first bound itself is multiline formatted ([#4636](https://github.com/rust-lang/rustfmt/issues/4636))\n+\n+### Install/Download Options\n+- **crates.io package** - *pending*\n+- **rustup (nightly)** - Starting in `2021-01-18`\n+- **GitHub Release Binaries** - [Release v1.4.32](https://github.com/rust-lang/rustfmt/releases/tag/v1.4.32)\n+- **Build from source** - [Tag v1.4.32](https://github.com/rust-lang/rustfmt/tree/v1.4.32), see instructions for how to [install rustfmt from source][install-from-source]\n+\n+## [1.4.31] 2021-01-09\n+\n+### Changed\n+\n+- `rustc-ap-*` crates updated to v697.0.0\n+\n+### Added\n+- Support for 2021 Edition [#4618](https://github.com/rust-lang/rustfmt/pull/4618))\n+\n+### Install/Download Options\n+- **crates.io package** - *pending*\n+- **rustup (nightly)** - Starting in `2021-01-16`\n+- **GitHub Release Binaries** - [Release v1.4.31](https://github.com/rust-lang/rustfmt/releases/tag/v1.4.31)\n+- **Build from source** - [Tag v1.4.31](https://github.com/rust-lang/rustfmt/tree/v1.4.31), see instructions for how to [install rustfmt from source][install-from-source]\n+\n+## [1.4.30] 2020-12-20\n+\n+### Fixed\n+- Last character in derive no longer erroneously stripped when `indent_style` is overridden to `Visual`. ([#4584](https://github.com/rust-lang/rustfmt/issues/4584))\n+- Brace wrapping of closure bodies maintained in cases where the closure has an explicit return type and the body consists of a single expression statement. ([#4577](https://github.com/rust-lang/rustfmt/issues/4577))\n+- No more panics on invalid code with `err` and `typeof` types ([#4357](https://github.com/rust-lang/rustfmt/issues/4357), [#4586](https://github.com/rust-lang/rustfmt/issues/4586))\n+\n+### Install/Download Options\n+- **crates.io package** - *pending*\n+- **rustup (nightly)** - Starting in `2020-12-25`\n+- **GitHub Release Binaries** - [Release v1.4.30](https://github.com/rust-lang/rustfmt/releases/tag/v1.4.30)\n+- **Build from source** - [Tag v1.4.30](https://github.com/rust-lang/rustfmt/tree/v1.4.30), see instructions for how to [install rustfmt from source][install-from-source]\n+\n+## [1.4.29] 2020-12-04\n+\n+### Fixed\n+- Negative polarity on non-trait impl now preserved. ([#4566](https://github.com/rust-lang/rustfmt/issues/4566))\n+\n+### Install/Download Options\n+- **crates.io package** - *pending*\n+- **rustup (nightly)** - Starting in `2020-12-07`\n+- **GitHub Release Binaries** - [Release v1.4.29](https://github.com/rust-lang/rustfmt/releases/tag/v1.4.29)\n+- **Build from source** - [Tag v1.4.29](https://github.com/rust-lang/rustfmt/tree/v1.4.29), see instructions for how to [install rustfmt from source][install-from-source]\n+\n+## [1.4.28] 2020-11-29\n+\n+### Changed\n+\n+- `rustc-ap-*` crates updated to v691.0.0\n+- In the event of an invalid inner attribute on a `cfg_if` condition, rustfmt will now attempt to continue and format the imported modules. Previously rustfmt would emit the parser error about an inner attribute being invalid in this position, but for rustfmt's purposes the invalid attribute doesn't prevent nor impact module formatting.\n+\n+### Added\n+\n+- [`group_imports`][group-imports-config-docs] - a new configuration option that allows users to control the strategy used for grouping imports ([#4107](https://github.com/rust-lang/rustfmt/issues/4107))\n+\n+[group-imports-config-docs]: https://github.com/rust-lang/rustfmt/blob/v1.4.28/Configurations.md#group_imports\n+\n+### Fixed\n+- Formatting of malformed derived attributes is no longer butchered. ([#3898](https://github.com/rust-lang/rustfmt/issues/3898), [#4029](https://github.com/rust-lang/rustfmt/issues/4029), [#4115](https://github.com/rust-lang/rustfmt/issues/4115), [#4545](https://github.com/rust-lang/rustfmt/issues/4545))\n+- Correct indentation used in macro branches when `hard_tabs` is enabled. ([#4152](https://github.com/rust-lang/rustfmt/issues/4152))\n+- Comments between the visibility modifier and item name are no longer dropped. ([#2781](https://github.com/rust-lang/rustfmt/issues/2781))\n+- Comments preceding the assignment operator in type aliases are no longer dropped. ([#4244](https://github.com/rust-lang/rustfmt/issues/4244))\n+- Comments between {`&` operator, lifetime, `mut` kw, type} are no longer dropped. ([#4245](https://github.com/rust-lang/rustfmt/issues/4245))\n+- Comments between type bounds are no longer dropped. ([#4243](https://github.com/rust-lang/rustfmt/issues/4243))\n+- Function headers are no longer dropped on foreign function items. ([#4288](https://github.com/rust-lang/rustfmt/issues/4288))\n+- Foreign function blocks are no longer dropped. ([#4313](https://github.com/rust-lang/rustfmt/issues/4313))\n+- `where_single_line` is no longer incorrectly applied to multiline function signatures that have no `where` clause. ([#4547](https://github.com/rust-lang/rustfmt/issues/4547))\n+- `matches!` expressions with multiple patterns and a destructure pattern are now able to be formatted. ([#4512](https://github.com/rust-lang/rustfmt/issues/4512))\n+\n+### Install/Download Options\n+- **crates.io package** - *pending*\n+- **rustup (nightly)** - n/a (superseded by [v1.4.29](#1429-2020-12-04))\n+- **GitHub Release Binaries** - [Release v1.4.28](https://github.com/rust-lang/rustfmt/releases/tag/v1.4.28)\n+- **Build from source** - [Tag v1.4.28](https://github.com/rust-lang/rustfmt/tree/v1.4.28), see instructions for how to [install rustfmt from source][install-from-source]\n+\n+## [1.4.27] 2020-11-16\n+\n+### Fixed\n+\n+- Leading comments in an extern block are no longer dropped (a bug that exists in v1.4.26). ([#4528](https://github.com/rust-lang/rustfmt/issues/4528))\n+\n+### Install/Download Options\n+- **crates.io package** - *pending*\n+- **rustup (nightly)** - Starting in `2020-11-18`\n+- **GitHub Release Binaries** - [Release v1.4.27](https://github.com/rust-lang/rustfmt/releases/tag/v1.4.27)\n+- **Build from source** - [Tag v1.4.27](https://github.com/rust-lang/rustfmt/tree/v1.4.27), see instructions for how to [install rustfmt from source][install-from-source]\n+\n+## [1.4.26] 2020-11-14\n+\n+### Changed\n+\n+- Original comment indentation for trailing comments within an `if` is now taken into account when determining the indentation level to use for the trailing comment in formatted code. This does not modify any existing code formatted with rustfmt; it simply gives the programmer discretion to specify whether the comment is associated to the `else` block, or if the trailing comment is just a member of the `if` block. ([#1575](https://github.com/rust-lang/rustfmt/issues/1575), [#4120](https://github.com/rust-lang/rustfmt/issues/4120), [#4506](https://github.com/rust-lang/rustfmt/issues/4506)) \n+\n+In this example the `// else comment` refers to the `else`:\n+```rust\n+// if comment\n+if cond {\n+    \"if\"\n+// else comment\n+} else {\n+    \"else\"\n+}\n+```\n+\n+Whereas in this case the `// continue` comments are members of their respective blocks and do not refer to the `else` below.\n+```rust\n+if toks.eat_token(Token::Word(\"modify\"))? && toks.eat_token(Token::Word(\"labels\"))? {\n+    if toks.eat_token(Token::Colon)? {\n+        // ate the token\n+    } else if toks.eat_token(Token::Word(\"to\"))? {\n+        // optionally eat the colon after to, e.g.:\n+        // @rustbot modify labels to: -S-waiting-on-author, +S-waiting-on-review\n+        toks.eat_token(Token::Colon)?;\n+    } else {\n+        // It's okay if there's no to or colon, we can just eat labels\n+        // afterwards.\n+    }\n+    1 + 2;\n+    // continue\n+} else if toks.eat_token(Token::Word(\"label\"))? {\n+    // continue\n+} else {\n+    return Ok(None);\n+}\n+```\n+\n+### Fixed\n+- Formatting of empty blocks with attributes which only contained comments is no longer butchered.([#4475](https://github.com/rust-lang/rustfmt/issues/4475), [#4467](https://github.com/rust-lang/rustfmt/issues/4467), [#4452](https://github.com/rust-lang/rustfmt/issues/4452#issuecomment-705886282), [#4522](https://github.com/rust-lang/rustfmt/issues/4522))\n+- Indentation of trailing comments in non-empty extern blocks is now correct. ([#4120](https://github.com/rust-lang/rustfmt/issues/4120#issuecomment-696491872)) \n+\n+### Install/Download Options\n+- **crates.io package** - *pending*\n+- **rustup (nightly)** - Starting in `2020-11-16`\n+- **GitHub Release Binaries** - [Release v1.4.26](https://github.com/rust-lang/rustfmt/releases/tag/v1.4.26)\n+- **Build from source** - [Tag v1.4.26](https://github.com/rust-lang/rustfmt/tree/v1.4.26), see instructions for how to [install rustfmt from source][install-from-source]\n+\n+## [1.4.25] 2020-11-10\n+\n+### Changed\n+\n+- Semicolons are no longer automatically inserted on trailing expressions in macro definition arms ([#4507](https://github.com/rust-lang/rustfmt/pull/4507)). This gives the programmer control and discretion over whether there should be semicolons in these scenarios so that potential expansion issues can be avoided.\n+\n+### Install/Download Options\n+- **crates.io package** - *pending*\n+- **rustup (nightly)** - Starting in `2020-11-14`\n+- **GitHub Release Binaries** - [Release v1.4.25](https://github.com/rust-lang/rustfmt/releases/tag/v1.4.25)\n+- **Build from source** - [Tag v1.4.25](https://github.com/rust-lang/rustfmt/tree/v1.4.25), see instructions for how to [install rustfmt from source][install-from-source]\n+\n+## [1.4.24] 2020-11-05\n+\n+### Changed\n+\n+- Block wrapped match arm bodies containing a single macro call expression are no longer flattened ([#4496](https://github.com/rust-lang/rustfmt/pull/4496)). This allows programmer discretion so that the block wrapping can be preserved in cases where needed to prevent issues in expansion, such as with trailing semicolons, and aligns with updated [Style Guide guidance](https://github.com/rust-dev-tools/fmt-rfcs/blob/master/guide/expressions.md#macro-call-expressions) for such scenarios.\n+\n+### Fixed\n+- Remove useless `deprecated` attribute on a trait impl block in the rustfmt lib, as these now trigger errors ([rust-lang/rust/#78626](https://github.com/rust-lang/rust/pull/78626))\n+\n+### Install/Download Options\n+- **crates.io package** - *pending*\n+- **rustup (nightly)** - Starting in `2020-11-09`\n+- **GitHub Release Binaries** - [Release v1.4.24](https://github.com/rust-lang/rustfmt/releases/tag/v1.4.24)\n+- **Build from source** - [Tag v1.4.24](https://github.com/rust-lang/rustfmt/tree/v1.4.24), see instructions for how to [install rustfmt from source][install-from-source]\n+\n+## [1.4.23] 2020-10-30\n+\n+### Changed\n+\n+- Update `rustc-ap-*` crates to v686.0.0\n+\n+### Added\n+- Initial support for formatting new ConstBlock syntax ([#4478](https://github.com/rust-lang/rustfmt/pull/4478))\n+\n+### Fixed\n+- Handling of unclosed delimiter-only parsing errors in input files ([#4466](https://github.com/rust-lang/rustfmt/issues/4466))\n+- Misc. minor parser bugs ([#4418](https://github.com/rust-lang/rustfmt/issues/4418) and [#4431](https://github.com/rust-lang/rustfmt/issues/4431))\n+- Panic on nested tuple access ([#4355](https://github.com/rust-lang/rustfmt/issues/4355))\n+- Unable to disable license template path via cli override ([#4487](https://github.com/rust-lang/rustfmt/issues/4487))\n+- Preserve comments in empty statements [#4018](https://github.com/rust-lang/rustfmt/issues/4018))\n+- Indentation on skipped code [#4398](https://github.com/rust-lang/rustfmt/issues/4398))\n+\n+### Install/Download Options\n+- **crates.io package** - *pending*\n+- **rustup (nightly)** - n/a (superseded by [v1.4.24](#1424-2020-11-05))\n+- **GitHub Release Binaries** - [Release v1.4.23](https://github.com/rust-lang/rustfmt/releases/tag/v1.4.23)\n+- **Build from source** - [Tag v1.4.23](https://github.com/rust-lang/rustfmt/tree/v1.4.23), see instructions for how to [install rustfmt from source][install-from-source]\n+\n+\n+\n+## [1.4.22] 2020-10-04\n+\n+### Changed\n+\n+- Update `rustc-ap-*` crates to v679.0.0\n+- Add config option to allow control of leading match arm pipes\n+- Support `RUSTFMT` environment variable in `cargo fmt` to run specified `rustfmt` instance\n+\n+### Fixed\n+\n+- Fix preservation of type aliases within extern blocks\n+\n+\n+## [1.4.9] 2019-10-07\n+\n+### Changed\n+\n+- Update `rustc-ap-*` crates to 606.0.0.\n+\n+### Fixed\n+\n+- Fix aligning comments of different group\n+- Fix flattening imports with a single `self`.\n+- Fix removing attributes on function parameters.\n+- Fix removing `impl` keyword from opaque type. \n+\n+## [1.4.8] 2019-09-08\n+\n+### Changed\n+\n+- Update `rustc-ap-*` crates to 583.0.0.\n+\n+## [1.4.7] 2019-09-06\n+\n+### Added\n+\n+- Add `--config` command line option.\n+\n+### Changed\n+\n+- Update `rustc-ap-*` crates to 581.0.0.\n+- rustfmt now do not warn against trailing whitespaces inside macro calls.\n+\n+### Fixed\n+\n+- Fix `merge_imports` generating invalid code.\n+- Fix removing discriminant values on enum variants.\n+- Fix modules defined inside `cfg_if!` not being formatted.\n+- Fix minor formatting issues.\n+\n+## [1.4.6] 2019-08-28\n+\n+### Added\n+\n+- Add `--message-format` command line option to `cargo-fmt`.\n+- Add `-l,--files-with-diff` command line option to `rustfmt`.\n+- Add `json` emit mode. \n+\n+### Fixed\n+\n+- Fix removing attributes on struct pattern's fields.\n+- Fix non-idempotent formatting of match arm.\n+- Fix `merge_imports` generating invalid code.\n+- Fix imports with `#![macro_use]` getting reordered with `reorder_imports`.\n+- Fix calculation of line numbers in checkstyle output.\n+- Fix poor formatting of complex fn type.\n+\n+## [1.4.5] 2019-08-13\n+\n+### Fixed\n+\n+- Fix generating invalid code when formatting an impl block with const generics inside a where clause.\n+- Fix adding a trailing space after a `dyn` keyword which is used as a macro argument by itself.\n+\n+## [1.4.4] 2019-08-06\n+\n+### Fixed\n+\n+- Fix `cargo fmt` incorrectly formatting crates that is not part of the workspace or the path dependencies.\n+- Fix removing a trailing comma from a tuple pattern.\n+\n+## [1.4.3] 2019-08-02\n+\n+### Changed\n+\n+- Update `rustc-ap-*` crates to 546.0.0.\n+\n+### Fixed\n+\n+- Fix an underscore pattern getting removed.\n+\n+## [1.4.2] 2019-07-31\n+\n+### Changed\n+\n+- Explicitly require the version of `rustfmt-config_proc_macro` to be 0.1.2 or later.\n+\n+## [1.4.1] 2019-07-30\n+\n+### Changed\n+\n+- Update `rustc-ap-*` crates to 542.0.0.\n+\n+## [1.4.0] 2019-07-29\n+\n+### Added\n+\n+- Add new attribute `rustfmt::skip::attributes` to prevent rustfmt \n+from formatting an attribute #3665\n+\n+### Changed\n+\n+- Update `rustc-ap-*` crates to 541.0.0.\n+- Remove multiple semicolons.\n+\n+## [1.3.3] 2019-07-15\n+\n+### Added\n+\n+- Add `--manifest-path` support to `cargo fmt` (#3683).\n+\n+### Fixed\n+\n+- Fix `cargo fmt -- --help` printing nothing (#3620).\n+- Fix inserting an extra comma (#3677).\n+- Fix incorrect handling of CRLF with `file-lines` (#3684).\n+- Fix `print-config=minimal` option (#3687).\n+\n+## [1.3.2] 2019-07-06\n+\n+### Fixed\n+\n+- Fix rustfmt crashing when `await!` macro call is used in a method chain.\n+- Fix rustfmt not recognizing a package whose name differs from its directory's name.\n+\n+## [1.3.1] 2019-06-30\n+\n+### Added\n+\n+- Implement the `Display` trait on the types of `Config`.\n+\n+### Changed\n+\n+- `ignore` configuration option now only supports paths separated by `/`. Windows-style paths are not supported.\n+- Running `cargo fmt` in a sub-directory of a project is now supported.\n+\n+### Fixed\n+\n+- Fix bugs that may cause rustfmt to crash.\n+\n+## [1.3.0] 2019-06-09\n+\n+### Added\n+\n+- Format modules defined inside `cfg_if` macro calls #3600\n+\n+### Changed\n+\n+- Change option `format_doc_comment` to `format_code_in_doc_comment`.\n+- `use_small_heuristics` changed to be an enum and stabilised. Configuration\n+  options are now ready for 1.0.\n+- Stabilise `fn_args_density` configuration option and rename it to `fn_args_layout` #3581\n+- Update `rustc-ap-*` crates to 486.0.0\n+- Ignore sub-modules when skip-children is used #3607\n+- Removed bitrig support #3608\n+\n+### Fixed\n+\n+- `wrap_comments` should not imply `format_doc_comments` #3535\n+- Incorrect handling of const generics #3555\n+- Add the handling for `vec!` with paren inside macro #3576\n+- Format trait aliases with where clauses #3586\n+- Catch panics from the parser while rewriting macro calls #3589\n+- Fix erasing inner attributes in struct #3593\n+- Inline the attribute with its item even with the `macro_use` attribute or when `reorder_imports` is disabled #3598\n+- Fix the bug add unwanted code to impl #3602\n+\n+## [1.2.2] 2019-04-24\n+\n+### Fixed\n+\n+- Fix processing of `ignore` paths #3522\n+- Attempt to format attributes if only they exist #3523\n+\n+## [1.2.1] 2019-04-18\n+\n+### Added\n+\n+- Add `--print-config current` CLI option b473e65\n+- Create GitHub [page](https://rust-lang.github.io/rustfmt/) for Configuration.md #3485\n+\n+### Fixed\n+\n+- Keep comment appearing between parameter's name and its type #3491\n+- Do not delete semicolon after macro call with square brackets #3500\n+- Fix `--version` CLI option #3506\n+- Fix duplication of attributes on a match arm's body #3510\n+- Avoid overflowing item with attributes #3511\n+\n+## [1.2.0] 2019-03-27\n+\n+### Added\n+\n+- Add new attribute `rustfmt::skip::macros` to prevent rustfmt from formatting a macro #3454\n+\n+### Changed\n+\n+- Discard error report in silent_emitter #3466\n+\n+### Fixed\n+\n+- Fix bad performance on deeply nested binary expressions #3467\n+- Use BTreeMap to guarantee consistent ordering b4d4b57\n+\n+## [1.1.1] 2019-03-21\n+\n+### Fixed\n+\n+- Avoid panic on macro inside deeply nested block c9479de\n+- Fix line numbering in missed spans and handle file_lines in edge cases cdd08da\n+- Fix formatting of async blocks 1fa06ec\n+- Avoid duplication on the presence of spaces between macro name and `!` #3464\n+\n+## [1.1.0] 2019-03-17\n+\n+### Added\n+\n+- Add `inline_attribute_width` configuration option to write an item and its attribute on the same line if their combined width is below a threshold #3409\n+- Support `const` generics f0c861b\n+- Support path clarity module #3448\n+\n+### Changed\n+\n+- Align loop and while formatting 7d9a2ef\n+- Support `EmitMode::ModifiedLines` with stdin input #3424\n+- Update `rustc-ap-*` crates to 407.0.0\n+- Remove trailing whitespaces in missing spans 2d5bc69\n+\n+### Fixed\n+\n+- Do not remove comment in the case of no arg 8e3ef3e\n+- Fix `Ident of macro+ident gets duplicated` error 40ff078\n+- Format the if expression at the end of the block in a single line 5f3dfe6\n+\n+## [1.0.3] 2019-02-14\n+\n+### Added\n+\n+- Point unstable options to tracking issues 412dcc7\n+\n+### Changed\n+\n+- Update `rustc-ap-*` crates to 373.0.0\n+\n+## [1.0.2] 2019-02-12\n+\n+### Added\n+\n+- Add a [section](https://github.com/rust-lang/rustfmt/blob/ae331be/Contributing.md#version-gate-formatting-changes) to the Contributing.md file about version-gating formatting changes 36e2cb0\n+- Allow specifying package with `-p` CLI option a8d2591\n+- Support `rustfmt::skip` on imports #3289\n+- Support global `rustfmt.toml` to be written in user config directory #3280\n+- Format visibility on trait alias 96a3df3\n+\n+### Changed\n+\n+- Do not modify original source code inside macro call #3260\n+- Recognize strings inside comments in order to avoid indenting them baa62c6\n+- Use Unicode-standard char width to wrap comments or strings a01990c\n+- Change new line point in the case of no args #3294\n+- Use the same formatting rule between functions and macros #3298\n+- Update rustc-ap-rustc_target to 366.0.0, rustc-ap-syntax to 366.0.0, and rustc-ap-syntax_pos to 366.0.0\n+\n+### Fixed\n+\n+- rewrite_comment: fix block fallback when failing to rewrite an itemized block ab7f4e1\n+- Catch possible tokenizer panics #3240\n+- Fix macro indentation on Windows #3266\n+- Fix shape when formatting return or break expr on statement position #3259\n+- rewrite_comment: fix block fallback when failing to rewrite an itemized block\n+- Keep leading double-colon to respect the 2018 edition of rust's paths a2bfc02\n+- Fix glob and nested global imports 2125ad2\n+- Do not force trailing comma when using mixed layout #3306\n+- Prioritize `single_line_fn` and `empty_item_single_line` over `brace_style` #3308\n+- Fix `internal error: left behind trailing whitespace` with long lines c2534f5\n+- Fix attribute duplication #3325\n+- Fix formatting of strings within a macro 813aa79\n+- Handle a macro argument with a single keyword 9a7ea6a\n+\n+## [1.0.1] 2018-12-09\n+\n+### Added\n+\n+- Add a `version` option 378994b\n+\n+### Changed\n+\n+- End expressions like return/continue/break with a semicolon #3223\n+- Update rustc-ap-rustc_target to 306.0.0, rustc-ap-syntax to 306.0.0, and rustc-ap-syntax_pos to 306.0.0\n+\n+### Fixed\n+\n+- Allow to run a rustfmt command from cargo-fmt even when there is no target a2da636\n+- Fix `un-closed delimiter` errors when formatting break labels 40174e9\n+\n+## [1.0.0] 2018-11-19\n+\n+### Changed\n+\n+- Preserve possibly one whitespace for brace macros 1a3bc79\n+- Prefer to break arguments over putting output type on the next line 1dd54e6\n+\n+## [0.99.9] 2018-11-15\n+\n+### Changed\n+\n+- Update rustc-ap-rustc_target to 297.0.0, rustc-ap-syntax to 297.0.0, to rustc-ap-syntax_pos to 297.0.0\n+- Don't align comments on `extern crate`s dd7add7\n+\n+## [0.99.8] 2018-11-14\n+\n+### Added\n+\n+- Add `overflow_delimited_expr` config option to more aggressively allow overflow #3175\n+\n+### Fixed\n+\n+- Fix the logic for retaining a comment before the arrow in a match #3181\n+- Do not wrap comments in doctest to avoid failing doctest runs #3183\n+- Fix comment rewriting that was wrapping code into a line comment #3188\n+- Fix formatting of unit-struct with `where`-clause #3200\n+\n+## [0.99.7] 2018-11-07\n+\n+### Changed\n+\n+- Force a newline after the `if` condition if there is a different indentation level #3109\n+- Use correct width when formatting type on local statement #3126\n+- Treat crates non-alphabetically when ordering 799005f\n+- Fix formatting of code that is annotated with rustfmt::skip #3113\n+- Stabilize `edition` configuration option 9c3ae2d\n+- cargo-fmt: detect Rust edition in use #3129\n+- Trim the indentation on macros which heuristically appear to use block-style indentation #3178\n+\n+### Fixed\n+\n+- Do not remove path disambiugator inside macro #3142\n+- Improve handling of Windows newlines #3141\n+- Fix alignment of a struct's fields (`struct_field_align_threshold` option) with the Visual `indent_style` #3165\n+- Fix a bug in formatting markdown lists within comments #3172\n+\n+## [0.99.6] 2018-10-18\n+\n+### Added\n+\n+- Add `enum_discrim_align_threshold` option to vertically align enum discriminants cc22869\n+- Add `println!`-like heuristic to the `fail` attribute #3067\n+- Handle itemized items inside comments #3083\n+- Add `format_doc_comments` configuration option to control the formatting of code snippets inside comments #3089\n+\n+### Changed\n+\n+- Makes brace behavior consistent with empty bodies for traits and impls 2727d41\n+- Consider a multi-lined array as a block-like expression #3969\n+- Improve formatting of strings #3073\n+- Get rid of extra commas in Visual struct literal formatting #3077\n+- Update rustc-ap-rustc_target to 274.0.0, rustc-ap-syntax to 274.0.0, and rustc-ap-syntax_pos to 274.0.0\n+- Format macro calls with item-like arguments #3080\n+- Avoid control flow expressions conditions to go multi line ef59b34\n+- Simplify multi-lining binop expressions #3101\n+\n+### Fixed\n+\n+- Do not format a code block in documentation if it is annotated with ignore or text 2bcc3a9\n+- Fix inconsistent overflow behavior in Visual style #3078\n+- Fix corner cases of the string formatting implementation #3083\n+- Do not add parens around lifetimes 0ac68c9\n+- Catch parser panic in format_snippet 8c4e92a\n+\n+## [0.99.5] 2018-09-25\n+\n+### Added\n+\n+- Handle leading module separator for 2018 Edition #2952\n+- Add configuration option `normalize_doc_attributes`: convert doc attributes to comments #3002\n+\n+### Changed\n+\n+- Accept 2015 and 2018 instead of Edition2015 and Edition2018 for edition option eec7436\n+- Support platforms without a timer 46e2a2e\n+- Update rustc-ap-rustc_target to 263.0.0, rustc-ap-syntax to 263.0.0, and rustc-ap-syntax_pos to 263.0.0\n+\n+### Fixed\n+\n+- Format of attributes with commas #2971\n+- Fix optional arg condensing #2972\n+- Improve formatting of long function parameters #2981\n+- Fix formatting of raw string literals #2983\n+- Handle chain with try operators with spaces #2986\n+- Use correct shape in Visual tuple rewriting #2987\n+- Impove formatting of arguments with `visual_style = \"Visual\"` option #2988\n+- Change `print_diff` to output the correct line number 992b179\n+- Propagate errors about failing to rewrite a macro 6f318e3\n+- Handle formatting of long function signature #3010\n+- Fix indent computation of a macro with braces c3edf6d\n+- Format generics on associated types #3035\n+- Incorrect indentation of multiline block match expression #3042\n+- Fix bug in import where two consecutive module separators were possible 98a0ef2\n+- Prevent right-shifting of block comments with bare lines 5fdb6db\n+\n+## [0.99.4] 2018-08-27\n+\n+### Added\n+\n+- Handle formatting of underscore imports #2951\n+- Handle formatting of try blocks #2965\n+\n+### Changed\n+\n+- Update rustc-ap-rustc_target to 237.0.0, rustc-ap-syntax to 237.0.0, and rustc-ap-syntax_pos to 237.0.0 ca19c9a\n+- Consider `dev` channel as nightly for unstable features #2948\n+\n+### Fixed\n+\n+- Fix formatting of patterns with ellipsis # 2942\n+\n+## [0.99.3] 2018-08-23\n+\n+### Added\n+\n+- Use path attribute when searching for modules #2901\n+- Expose FileLines JSON representation to allow external libraries to use the file_lines option #2915\n+\n+### Changed\n+\n+- Replace '--conifig-help' with '--config=help' cb10e06\n+- Improve formatting of slice patterns #2912\n+\n+### Fixed\n+\n+- Format chains with comment #2899\n+- Fix indentation of formatted macro body #2920\n+- Fix indentation of block comments f23e6aa\n+\n+## [0.99.2] 2018-08-07\n+\n+### Changed\n+\n+- Update rustc-ap-rustc_target to 218.0.0, rustc-ap-syntax to 218.0.0, and rustc-ap-syntax_pos to 218.0.0 5c9a2b6\n+- Combine function-like attributes #2900\n+\n+### Fixed\n+\n+- Explicitly handle semicolon after the item in statement position d96e3ca\n+- Fix parsing '#'-hiding of rustdoc 2eca09e\n+\n+## [0.99.1] 2018-08-04\n+\n+### Fixed\n+\n+- fix use statements ordering when a number is present 1928ae7\n+\n+## [0.99.0] 2018-08-03\n+\n+- 1.0 RC release\n+\n+### Changed\n+\n+- Clarification in README.md 30fe66b\n+\n+## [0.9.0] 2018-08-01\n+\n+### Added\n+\n+- Handle raw identifiers 3027c21\n+- Format async closure 60ce411\n+- Add max_width option for all heuristics c2ae39e\n+- Add config option `format_macro_matchers` to format the metavariable matching patterns in macros 79c5ee8\n+- Add config option `format_macro_bodies` to format the bodies of macros 79c5ee8\n+- Format exitential type fc307ff\n+- Support raw identifiers in struct expressions f121b1a\n+- Format Async block and async function 0b25f60\n+\n+### Changed\n+\n+- Update rustc-ap-rustc_target to 211.0.0, rustc-ap-syntax to 211.0.0, and rustc-ap-syntax_pos to 211.0.0\n+- Put each nested import on its own line while putting non-nested imports on the same line as much as possible 42ab258\n+- Respect `empty_item_single_line` config option when formatting empty impls. Put the `where` on its own line to improve readability #2771\n+- Strip leading `|` in match arm patterns 1d4b988\n+- Apply short function call heuristic to attributes 3abebf9\n+- Indent a match guard if the pattern is multiline be4d37d\n+- Change default newline style to `Native` 9d8f381\n+- Improve formatting of series of binop expressions a4cdb68\n+- Trigger an internal error if we skip formatting due to a lost comment b085113\n+- Refactor chain formatting #2838\n+\n+### Fixed\n+\n+- Do not insert spaces around braces with empty body or multiple lines 2f65852\n+- Allow using mixed layout with comments #2766\n+- Handle break labels #2726\n+- fix rewrite_string when a line feed is present 472a2ed\n+- Fix an anomaly with comments and array literals b28a0cd\n+- Check for comments after the `=>` in a match arm 6899471\n+\n+## [0.8.0,0.8.1,0.8.2] 2018-05-28\n+\n+### Added\n+\n+- Use scoped attributes for skip attribute https://github.com/rust-lang/rustfmt/pull/2703\n+\n+### Changed\n+\n+- Comment options `wrap_comments` and `normalize_comments` are reverted back to unstable 416bc4c\n+- Stabilise `reorder_imports` and `reorder_modules` options 7b6d2b4\n+- Remove `spaces_within_parens_and_brackets` option d726492\n+- Stabilise shorthand options: `use_try_shorthand`, `use_field_init_shorthand`, and `force_explicit_abi` 8afe367\n+- Stabilise `remove_nested_parens` and set default to true a70f716\n+- Unstabilise `unstable_features` dd9c15a\n+- Remove `remove_blank_lines_at_start_or_end_of_block` option 2ee8b0e\n+- Update rustc-ap-syntax to 146.0.0 and rustc-ap-rustc_target to 146.0.0 2c275a2\n+- Audit the public API #2639\n+\n+### Fixed\n+\n+- Handle code block in doc comment without rust prefix f1974e2\n+\n+## [0.7.0] 2018-05-14\n+\n+### Added\n+\n+- Add integration tests against crates in the rust-lang-nursery c79f39a\n+\n+### Changed\n+\n+- Update rustc-ap-syntax to 128.0.0 and ustc-ap-rustc_target to 128.0.0 195395f\n+- Put operands on its own line when each fits in a single line f8439ce\n+- Improve CLI options 55ac062 1869888 798bffb 4d9de48 eca7796 8396da1 5d9f5aa\n+\n+### Fixed\n+\n+- Use correct line width for list attribute 61a401a\n+- Avoid flip-flopping impl items when reordering them 37c216c\n+- Formatting breaks short lines when max_width is less than 100 9b36156\n+- Fix variant \"Mixed\" of imports_layout option 8c8676c\n+- Improve handling of long lines f885039\n+- Fix up lines exceeding max width 51c07f4\n+- Fix handling of modules in non_modrs_mods style cf573e8\n+- Do not duplicate attributes on use items e59ceaf\n+- Do not insert an extra brace in macros with native newlines 4c9ef93\n+\n+## [0.6.1] 2018-05-01\n+\n+### Changed\n+\n+- Change the default value of imports_indent to IndentStyle::Block https://github.com/rust-lang/rustfmt/pull/2662\n+\n+### Fixed\n+\n+- Handle formatting of auto traits 5b5a72c\n+- Use consistent formatting for empty enum and struct https://github.com/rust-lang/rustfmt/pull/2656\n+\n+## [0.6.0] 2018-04-20\n+\n+### Changed\n+\n+- Improve public API 8669004\n+\n+## [0.5.0] 2018-04-20\n+\n+### Added\n+\n+- Add `verbose-diff` CLI option 5194984\n+\n+### Changed\n+\n+- Update rustc-ap-syntax to 103.0.0 dd807e2\n+- Refactor to make a sensible public API ca610d3\n+\n+### Fixed\n+\n+- Add spaces between consecutive `..` `..=` 61d29eb\n+\n+## [0.4.2] 2018-04-12\n+\n+### Added\n+\n+- Handle binary operators and lifetimes 0fd174d\n+- Add reorder_impl_items config option 94f5a05\n+- Add `--unstable-features` CLI option to list unstable options from the `--help` output 8208f8a\n+- Add merge_imports config option 5dd203e\n+\n+### Changed\n+\n+- Format macro arguments with vertical layout ec71459\n+- Reorder imports by default 164cf7d\n+- Do not collapse block around expr with condition on match arm 5b9b7d5\n+- Use vertical layout for complex attributes c77708f\n+- Format array using heuristics for function calls 98c6f7b\n+- Implement stable ordering for impl items with the the following item priority: type, const, macro, then method fa80ddf\n+- Reorder imports by default 164cf7d\n+- Group `extern crate` by default 3a138a2\n+- Make `error_on_line_overflow` false by default f146711\n+- Merge imports with the same prefix into a single nested import 1954513\n+- Squash the various 'reorder imports' option into one 911395a\n+\n+### Fixed\n+\n+- Print version is missing the channel ca6fc67\n+- Do not add the beginning vert to the match arm 1e1d9d4\n+- Follow indent style config when formatting attributes efd295a\n+- Do not insert newline when item is empty a8022f3\n+- Do not indent or unindent inside string literal ec1907b\n+\n+## [0.4.1] 2018-03-16\n+\n+### Added\n+\n+- Add `ignore` configuration option.\n+- Add `license_template_path` configuration option.\n+- Format `lazy_static!`.\n+\n+### Fixed\n+\n+- Fix formatting bugs.\n+- Fix setting `reorder_modules` removing inline modules.\n+- Format attributes on block expressions.\n+- Support `dyn trait` syntax.\n+- Support multiple patterns in `if let` and `while let`.\n+- Support a pattern with parentheses.\n+\n+## [0.4.0] 2018-03-02\n+\n+### Changed\n+\n+- Do not print verbose outputs when formatting with stdin.\n+- Preserve trailing whitespaces in doc comments.\n+- Scale the values of width heuristics by `max_width`.\n+\n+### Fixed\n+\n+- Do not reorder items with `#[macro_use]`.\n+- Fix formatting bugs.\n+- Support the beginning `|` on a match arm.\n+\n+## [0.3.8] 2018-02-04\n+\n+### Added\n+\n+- Format (or at least try to format) `macro_rules!`.\n+\n+## [0.3.7] 2018-02-01\n+\n+### Added\n+\n+- Add `use_field_init_shorthand` config option.\n+- Add `reorder_modules` configuration option.\n+\n+## [0.3.6] 2018-01-18\n+\n+### Fixed\n+\n+- Fix panicking on formatting certain macros (#2371).\n+\n+## [0.3.5] 2018-01-15\n+\n+### Changed\n+\n+- Format code block in comments when `wrap_comments` is set to `true`.\n+- Remove `same_line_attributes` configuration option.\n+- Rename `git-fmt` to `git-rustfmt`.\n+\n+### Fixed\n+\n+- Rustup to `rustc 1.25.0-nightly (e6072a7b3 2018-01-13)`.\n+- Fix formatting bugs.\n+\n+## [0.3.4] 2017-12-23\n+\n+### Added\n+\n+- Add `--version` flag to `cargo-fmt`, allow `cargo fmt --version`.\n+\n+### Fixed\n+\n+- Rustup to `rustc 1.24.0-nightly (5165ee9e2 2017-12-22)`.\n+\n+## [0.3.3] 2017-12-22\n+\n+### Added\n+\n+- Format trait aliases.\n+\n+### Changed\n+\n+- `cargo fmt` will format every workspace member.\n+\n+### Fixed\n+\n+- Rustup to `rustc 1.24.0-nightly (250b49205 2017-12-21)`\n+- Fix formatting bugs.\n+\n+## [0.3.2] 2017-12-15\n+\n+### Changed\n+\n+- Warn when unknown configuration option is used.\n+\n+### Fixed\n+\n+- Rustup to `rustc 1.24.0-nightly (0077d128d 2017-12-14)`.\n+\n+## [0.3.1] 2017-12-11\n+\n+### Added\n+\n+- Add `error_on_unformatted` configuration option.\n+- Add `--error-on-unformatted` command line option.\n+\n+### Changed\n+\n+- Do not report formatting errors on comments or strings by default.\n+- Rename `error_on_line_overflow_comments` to `error_on_unformatted`.\n+\n+### Fixed\n+\n+- Fix formatting bugs.\n+- Fix adding a trailing whitespace inside code block when `wrap_comments = true`.\n+\n+## [0.3.0] 2017-12-11\n+\n+### Added\n+\n+- Support nested imports.\n+\n+### Changed\n+\n+- Do not report errors on skipped items.\n+- Do not format code block inside comments when `wrap_comments = true`.\n+- Keep vertical spaces between items within range.\n+- Format `format!` and its variants using compressed style.\n+- Format `write!` and its variants using compressed style.\n+- Format **simple** array using compressed style.\n+\n+### Fixed\n+\n+- Fix `rustfmt --package package_name` not working properly.\n+- Fix formatting bugs.\n+\n+## [0.2.17] 2017-12-03\n+\n+### Added\n+\n+- Add `blank_lines_lower_bound` and `blank_lines_upper_bound` configuration options.\n+\n+### Changed\n+\n+- Combine configuration options related to width heuristic into `width_heuristic`.\n+- If the match arm's body is `if` expression, force to use block.\n+\n+### Fixed\n+\n+- Fix `cargo fmt --all` being trapped in an infinite loop.\n+- Fix many formatting bugs.\n+\n+### Removed\n+\n+- Remove legacy configuration options.\n+\n+## [0.2.16] 2017-11-21\n+\n+### Added\n+\n+- Remove empty lines at the beginning of the file.\n+- Soft wrapping on doc comments.\n+\n+### Changed\n+\n+- Break before `|` when using multiple lines for match arm patterns.\n+- Combine `control_style`, `where_style` and `*_indent` config options into `indent_style`.\n+- Combine `item_brace_style` and `fn_brace_style` config options into `brace_style`.\n+- Combine config options related spacing around colons into `space_before_colon` and `space_after_colon`.\n+\n+### Fixed\n+\n+- Fix many bugs.\n+\n+## [0.2.15] 2017-11-08\n+\n+### Added\n+\n+- Add git-fmt tool\n+- `where_single_line` configuration option.\n+\n+### Changed\n+\n+- Rename `chain_one_line_max` to `chain_width`.\n+- Change the suffix of indent-related configuration options to `_indent`.\n+\n+## [0.2.14] 2017-11-06\n+\n+### Fixed\n+\n+- Rustup to the latest nightly.\n+\n+## [0.2.13] 2017-10-30\n+\n+### Fixed\n+\n+- Rustup to the latest nightly.\n+\n+## [0.2.12] 2017-10-29\n+\n+### Fixed\n+\n+- Fix a bug that `cargo fmt` hangs forever.\n+\n+## [0.2.11] 2017-10-29\n+\n+### Fixed\n+\n+- Fix a bug that `cargo fmt` crashes.\n+\n+## [0.2.10] 2017-10-28\n+\n+## [0.2.9] 2017-10-16\n+\n+## [0.2.8] 2017-09-28\n+\n+## [0.2.7] 2017-09-21\n+\n+### Added\n+\n+- `binop_separator` configuration option (#1964).\n+\n+### Changed\n+\n+- Use horizontal layout for function call with a single argument.\n+\n+### Fixed\n+\n+- Fix panicking when calling `cargo fmt --all` (#1963).\n+- Refactorings & faster rustfmt.\n+\n+## [0.2.6] 2017-09-14\n+\n+### Fixed\n+\n+- Fix a performance issue with nested block (#1940).\n+- Refactorings & faster rustfmt.\n+\n+## [0.2.5] 2017-08-31\n+\n+### Added\n+\n+- Format and preserve attributes on statements (#1933).\n+\n+### Fixed\n+\n+- Use getters to access `Span` fields (#1899).\n+\n+## [0.2.4] 2017-08-30\n+\n+### Added\n+\n+- Add support for `Yield` (#1928).\n+\n+## [0.2.3] 2017-08-30\n+\n+### Added\n+\n+- `multiline_closure_forces_block` configuration option (#1898).\n+- `multiline_match_arm_forces_block` configuration option (#1898).\n+- `merge_derives` configuration option (#1910).\n+- `struct_remove_empty_braces` configuration option (#1930).\n+- Various refactorings.\n+\n+### Changed\n+\n+- Put single-lined block comments on the same line with list-like structure's item (#1923).\n+- Preserve blank line between doc comment and attribute (#1925).\n+- Put the opening and the closing braces of enum and struct on the same line, even when `item_brace_style = \"AlwaysNextLine\"` (#1930).\n+\n+### Fixed\n+\n+- Format attributes on `ast::ForeignItem` and take max width into account (#1916).\n+- Ignore empty lines when calculating the shortest indent width inside macro with braces (#1918).\n+- Handle tabs properly inside macro with braces (#1918).\n+- Fix a typo in `compute_budgets_for_args()` (#1924).\n+- Recover comment between keyword (`impl` and `trait`) and `{` which used to get removed (#1925).\n+\n+\n+[install-from-source]: https://github.com/rust-lang/rustfmt#installing-from-source"}, {"sha": "d70b2b52aca1b136d70617a03d04b5c7bccd9969", "filename": "src/tools/rustfmt/CODE_OF_CONDUCT.md", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2FCODE_OF_CONDUCT.md", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2FCODE_OF_CONDUCT.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2FCODE_OF_CONDUCT.md?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782", "patch": "@@ -0,0 +1,40 @@\n+# The Rust Code of Conduct\n+\n+A version of this document [can be found online](https://www.rust-lang.org/conduct.html).\n+\n+## Conduct\n+\n+**Contact**: [rust-mods@rust-lang.org](mailto:rust-mods@rust-lang.org)\n+\n+* We are committed to providing a friendly, safe and welcoming environment for all, regardless of level of experience, gender identity and expression, sexual orientation, disability, personal appearance, body size, race, ethnicity, age, religion, nationality, or other similar characteristic.\n+* On IRC, please avoid using overtly sexual nicknames or other nicknames that might detract from a friendly, safe and welcoming environment for all.\n+* Please be kind and courteous. There's no need to be mean or rude.\n+* Respect that people have differences of opinion and that every design or implementation choice carries a trade-off and numerous costs. There is seldom a right answer.\n+* Please keep unstructured critique to a minimum. If you have solid ideas you want to experiment with, make a fork and see how it works.\n+* We will exclude you from interaction if you insult, demean or harass anyone. That is not welcome behavior. We interpret the term \"harassment\" as including the definition in the <a href=\"http://citizencodeofconduct.org/\">Citizen Code of Conduct</a>; if you have any lack of clarity about what might be included in that concept, please read their definition. In particular, we don't tolerate behavior that excludes people in socially marginalized groups.\n+* Private harassment is also unacceptable. No matter who you are, if you feel you have been or are being harassed or made uncomfortable by a community member, please contact one of the channel ops or any of the [Rust moderation team][mod_team] immediately. Whether you're a regular contributor or a newcomer, we care about making this community a safe place for you and we've got your back.\n+* Likewise any spamming, trolling, flaming, baiting or other attention-stealing behavior is not welcome.\n+\n+## Moderation\n+\n+\n+These are the policies for upholding our community's standards of conduct. If you feel that a thread needs moderation, please contact the [Rust moderation team][mod_team].\n+\n+1. Remarks that violate the Rust standards of conduct, including hateful, hurtful, oppressive, or exclusionary remarks, are not allowed. (Cursing is allowed, but never targeting another user, and never in a hateful manner.)\n+2. Remarks that moderators find inappropriate, whether listed in the code of conduct or not, are also not allowed.\n+3. Moderators will first respond to such remarks with a warning.\n+4. If the warning is unheeded, the user will be \"kicked,\" i.e., kicked out of the communication channel to cool off.\n+5. If the user comes back and continues to make trouble, they will be banned, i.e., indefinitely excluded.\n+6. Moderators may choose at their discretion to un-ban the user if it was a first offense and they offer the offended party a genuine apology.\n+7. If a moderator bans someone and you think it was unjustified, please take it up with that moderator, or with a different moderator, **in private**. Complaints about bans in-channel are not allowed.\n+8. Moderators are held to a higher standard than other community members. If a moderator creates an inappropriate situation, they should expect less leeway than others.\n+\n+In the Rust community we strive to go the extra step to look out for each other. Don't just aim to be technically unimpeachable, try to be your best self. In particular, avoid flirting with offensive or sensitive issues, particularly if they're off-topic; this all too often leads to unnecessary fights, hurt feelings, and damaged trust; worse, it can drive people away from the community entirely.\n+\n+And if someone takes issue with something you said or did, resist the urge to be defensive. Just stop doing what it was they complained about and apologize. Even if you feel you were misinterpreted or unfairly accused, chances are good there was something you could've communicated better \u2014 remember that it's your responsibility to make your fellow Rustaceans comfortable. Everyone wants to get along and we are all here first and foremost because we want to talk about cool technology. You will find that people will be eager to assume good intent and forgive as long as you earn their trust.\n+\n+The enforcement policies listed above apply to all official Rust venues; including official IRC channels (#rust, #rust-internals, #rust-tools, #rust-libs, #rustc, #rust-beginners, #rust-docs, #rust-community, #rust-lang, and #cargo); GitHub repositories under rust-lang, rust-lang-nursery, and rust-lang-deprecated; and all forums under rust-lang.org (users.rust-lang.org, internals.rust-lang.org). For other projects adopting the Rust Code of Conduct, please contact the maintainers of those projects for enforcement. If you wish to use this code of conduct for your own project, consider explicitly mentioning your moderation policy or making a copy with your own moderation policy so as to avoid confusion.\n+\n+*Adapted from the [Node.js Policy on Trolling](http://blog.izs.me/post/30036893703/policy-on-trolling) as well as the [Contributor Covenant v1.3.0](https://www.contributor-covenant.org/version/1/3/0/).*\n+\n+[mod_team]: https://www.rust-lang.org/team.html#Moderation-team"}, {"sha": "0e12e81904c9121cca83959459ffecd128fdf0e6", "filename": "src/tools/rustfmt/Cargo.lock", "status": "added", "additions": 915, "deletions": 0, "changes": 915, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2FCargo.lock?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782", "patch": "@@ -0,0 +1,915 @@\n+# This file is automatically @generated by Cargo.\n+# It is not intended for manual editing.\n+version = 3\n+\n+[[package]]\n+name = \"aho-corasick\"\n+version = \"0.7.6\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"58fb5e95d83b38284460a5fda7d6470aa0b8844d283a0b614b8535e880800d2d\"\n+dependencies = [\n+ \"memchr\",\n+]\n+\n+[[package]]\n+name = \"annotate-snippets\"\n+version = \"0.8.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"d78ea013094e5ea606b1c05fe35f1dd7ea1eb1ea259908d040b25bd5ec677ee5\"\n+dependencies = [\n+ \"yansi-term\",\n+]\n+\n+[[package]]\n+name = \"ansi_term\"\n+version = \"0.11.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"ee49baf6cb617b853aa8d93bf420db2383fab46d314482ca2803b40d5fde979b\"\n+dependencies = [\n+ \"winapi\",\n+]\n+\n+[[package]]\n+name = \"anyhow\"\n+version = \"1.0.25\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"9267dff192e68f3399525901e709a48c1d3982c9c072fa32f2127a0cb0babf14\"\n+\n+[[package]]\n+name = \"arrayref\"\n+version = \"0.3.5\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"0d382e583f07208808f6b1249e60848879ba3543f57c32277bf52d69c2f0f0ee\"\n+\n+[[package]]\n+name = \"arrayvec\"\n+version = \"0.4.12\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"cd9fd44efafa8690358b7408d253adf110036b88f55672a933f01d616ad9b1b9\"\n+dependencies = [\n+ \"nodrop\",\n+]\n+\n+[[package]]\n+name = \"atty\"\n+version = \"0.2.13\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"1803c647a3ec87095e7ae7acfca019e98de5ec9a7d01343f611cf3152ed71a90\"\n+dependencies = [\n+ \"libc\",\n+ \"winapi\",\n+]\n+\n+[[package]]\n+name = \"autocfg\"\n+version = \"0.1.7\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"1d49d90015b3c36167a20fe2810c5cd875ad504b39cff3d4eae7977e6b7c1cb2\"\n+\n+[[package]]\n+name = \"backtrace\"\n+version = \"0.3.40\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"924c76597f0d9ca25d762c25a4d369d51267536465dc5064bdf0eb073ed477ea\"\n+dependencies = [\n+ \"backtrace-sys\",\n+ \"cfg-if\",\n+ \"libc\",\n+ \"rustc-demangle\",\n+]\n+\n+[[package]]\n+name = \"backtrace-sys\"\n+version = \"0.1.32\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"5d6575f128516de27e3ce99689419835fce9643a9b215a14d2b5b685be018491\"\n+dependencies = [\n+ \"cc\",\n+ \"libc\",\n+]\n+\n+[[package]]\n+name = \"base64\"\n+version = \"0.10.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"0b25d992356d2eb0ed82172f5248873db5560c4721f564b13cb5193bda5e668e\"\n+dependencies = [\n+ \"byteorder\",\n+]\n+\n+[[package]]\n+name = \"bitflags\"\n+version = \"1.2.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"cf1de2fe8c75bc145a2f577add951f8134889b4795d47466a54a5c846d691693\"\n+\n+[[package]]\n+name = \"blake2b_simd\"\n+version = \"0.5.8\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"5850aeee1552f495dd0250014cf64b82b7c8879a89d83b33bbdace2cc4f63182\"\n+dependencies = [\n+ \"arrayref\",\n+ \"arrayvec\",\n+ \"constant_time_eq\",\n+]\n+\n+[[package]]\n+name = \"bstr\"\n+version = \"0.2.8\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"8d6c2c5b58ab920a4f5aeaaca34b4488074e8cc7596af94e6f8c6ff247c60245\"\n+dependencies = [\n+ \"memchr\",\n+]\n+\n+[[package]]\n+name = \"bytecount\"\n+version = \"0.6.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"b0017894339f586ccb943b01b9555de56770c11cda818e7e3d8bd93f4ed7f46e\"\n+dependencies = [\n+ \"packed_simd\",\n+]\n+\n+[[package]]\n+name = \"byteorder\"\n+version = \"1.3.2\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"a7c3dd8985a7111efc5c80b44e23ecdd8c007de8ade3b96595387e812b957cf5\"\n+\n+[[package]]\n+name = \"cargo_metadata\"\n+version = \"0.8.2\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"700b3731fd7d357223d0000f4dbf1808401b694609035c3c411fbc0cd375c426\"\n+dependencies = [\n+ \"semver\",\n+ \"serde\",\n+ \"serde_derive\",\n+ \"serde_json\",\n+]\n+\n+[[package]]\n+name = \"cc\"\n+version = \"1.0.46\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"0213d356d3c4ea2c18c40b037c3be23cd639825c18f25ee670ac7813beeef99c\"\n+\n+[[package]]\n+name = \"cfg-if\"\n+version = \"0.1.10\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"4785bdd1c96b2a846b2bd7cc02e86b6b3dbf14e7e53446c4f54c92a361040822\"\n+\n+[[package]]\n+name = \"clap\"\n+version = \"2.33.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"5067f5bb2d80ef5d68b4c87db81601f0b75bca627bc2ef76b141d7b846a3c6d9\"\n+dependencies = [\n+ \"ansi_term\",\n+ \"atty\",\n+ \"bitflags\",\n+ \"strsim\",\n+ \"textwrap\",\n+ \"unicode-width\",\n+ \"vec_map\",\n+]\n+\n+[[package]]\n+name = \"cloudabi\"\n+version = \"0.0.3\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"ddfc5b9aa5d4507acaf872de71051dfd0e309860e88966e1051e462a077aac4f\"\n+dependencies = [\n+ \"bitflags\",\n+]\n+\n+[[package]]\n+name = \"constant_time_eq\"\n+version = \"0.1.4\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"995a44c877f9212528ccc74b21a232f66ad69001e40ede5bcee2ac9ef2657120\"\n+\n+[[package]]\n+name = \"crossbeam-channel\"\n+version = \"0.4.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"acec9a3b0b3559f15aee4f90746c4e5e293b701c0f7d3925d24e01645267b68c\"\n+dependencies = [\n+ \"crossbeam-utils 0.7.0\",\n+]\n+\n+[[package]]\n+name = \"crossbeam-utils\"\n+version = \"0.6.6\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"04973fa96e96579258a5091af6003abde64af786b860f18622b82e026cca60e6\"\n+dependencies = [\n+ \"cfg-if\",\n+ \"lazy_static\",\n+]\n+\n+[[package]]\n+name = \"crossbeam-utils\"\n+version = \"0.7.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"ce446db02cdc3165b94ae73111e570793400d0794e46125cc4056c81cbb039f4\"\n+dependencies = [\n+ \"autocfg\",\n+ \"cfg-if\",\n+ \"lazy_static\",\n+]\n+\n+[[package]]\n+name = \"derive-new\"\n+version = \"0.5.8\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"71f31892cd5c62e414316f2963c5689242c43d8e7bbcaaeca97e5e28c95d91d9\"\n+dependencies = [\n+ \"proc-macro2\",\n+ \"quote\",\n+ \"syn\",\n+]\n+\n+[[package]]\n+name = \"diff\"\n+version = \"0.1.11\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"3c2b69f912779fbb121ceb775d74d51e915af17aaebc38d28a592843a2dd0a3a\"\n+\n+[[package]]\n+name = \"dirs\"\n+version = \"2.0.2\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"13aea89a5c93364a98e9b37b2fa237effbb694d5cfe01c5b70941f7eb087d5e3\"\n+dependencies = [\n+ \"cfg-if\",\n+ \"dirs-sys\",\n+]\n+\n+[[package]]\n+name = \"dirs-sys\"\n+version = \"0.3.4\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"afa0b23de8fd801745c471deffa6e12d248f962c9fd4b4c33787b055599bde7b\"\n+dependencies = [\n+ \"cfg-if\",\n+ \"libc\",\n+ \"redox_users\",\n+ \"winapi\",\n+]\n+\n+[[package]]\n+name = \"either\"\n+version = \"1.5.3\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"bb1f6b1ce1c140482ea30ddd3335fc0024ac7ee112895426e0a629a6c20adfe3\"\n+\n+[[package]]\n+name = \"env_logger\"\n+version = \"0.6.2\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"aafcde04e90a5226a6443b7aabdb016ba2f8307c847d524724bd9b346dd1a2d3\"\n+dependencies = [\n+ \"atty\",\n+ \"humantime\",\n+ \"log\",\n+ \"regex\",\n+ \"termcolor\",\n+]\n+\n+[[package]]\n+name = \"failure\"\n+version = \"0.1.6\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"f8273f13c977665c5db7eb2b99ae520952fe5ac831ae4cd09d80c4c7042b5ed9\"\n+dependencies = [\n+ \"backtrace\",\n+ \"failure_derive\",\n+]\n+\n+[[package]]\n+name = \"failure_derive\"\n+version = \"0.1.8\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"aa4da3c766cd7a0db8242e326e9e4e081edd567072893ed320008189715366a4\"\n+dependencies = [\n+ \"proc-macro2\",\n+ \"quote\",\n+ \"syn\",\n+ \"synstructure\",\n+]\n+\n+[[package]]\n+name = \"fnv\"\n+version = \"1.0.6\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"2fad85553e09a6f881f739c29f0b00b0f01357c743266d478b68951ce23285f3\"\n+\n+[[package]]\n+name = \"fuchsia-cprng\"\n+version = \"0.1.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"a06f77d526c1a601b7c4cdd98f54b5eaabffc14d5f2f0296febdc7f357c6d3ba\"\n+\n+[[package]]\n+name = \"getopts\"\n+version = \"0.2.21\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"14dbbfd5c71d70241ecf9e6f13737f7b5ce823821063188d7e46c41d371eebd5\"\n+dependencies = [\n+ \"unicode-width\",\n+]\n+\n+[[package]]\n+name = \"globset\"\n+version = \"0.4.4\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"925aa2cac82d8834e2b2a4415b6f6879757fb5c0928fc445ae76461a12eed8f2\"\n+dependencies = [\n+ \"aho-corasick\",\n+ \"bstr\",\n+ \"fnv\",\n+ \"log\",\n+ \"regex\",\n+]\n+\n+[[package]]\n+name = \"heck\"\n+version = \"0.3.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"20564e78d53d2bb135c343b3f47714a56af2061f1c928fdb541dc7b9fdd94205\"\n+dependencies = [\n+ \"unicode-segmentation\",\n+]\n+\n+[[package]]\n+name = \"humantime\"\n+version = \"1.3.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"df004cfca50ef23c36850aaaa59ad52cc70d0e90243c3c7737a4dd32dc7a3c4f\"\n+dependencies = [\n+ \"quick-error\",\n+]\n+\n+[[package]]\n+name = \"ignore\"\n+version = \"0.4.11\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"522daefc3b69036f80c7d2990b28ff9e0471c683bad05ca258e0a01dd22c5a1e\"\n+dependencies = [\n+ \"crossbeam-channel\",\n+ \"globset\",\n+ \"lazy_static\",\n+ \"log\",\n+ \"memchr\",\n+ \"regex\",\n+ \"same-file\",\n+ \"thread_local 1.0.1\",\n+ \"walkdir\",\n+ \"winapi-util\",\n+]\n+\n+[[package]]\n+name = \"itertools\"\n+version = \"0.8.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"5b8467d9c1cebe26feb08c640139247fac215782d35371ade9a2136ed6085358\"\n+dependencies = [\n+ \"either\",\n+]\n+\n+[[package]]\n+name = \"itoa\"\n+version = \"0.4.4\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"501266b7edd0174f8530248f87f99c88fbe60ca4ef3dd486835b8d8d53136f7f\"\n+\n+[[package]]\n+name = \"lazy_static\"\n+version = \"1.4.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"e2abad23fbc42b3700f2f279844dc832adb2b2eb069b2df918f455c4e18cc646\"\n+\n+[[package]]\n+name = \"libc\"\n+version = \"0.2.77\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"f2f96b10ec2560088a8e76961b00d47107b3a625fecb76dedb29ee7ccbf98235\"\n+\n+[[package]]\n+name = \"log\"\n+version = \"0.4.8\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"14b6052be84e6b71ab17edffc2eeabf5c2c3ae1fdb464aae35ac50c67a44e1f7\"\n+dependencies = [\n+ \"cfg-if\",\n+]\n+\n+[[package]]\n+name = \"memchr\"\n+version = \"2.2.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"88579771288728879b57485cc7d6b07d648c9f0141eb955f8ab7f9d45394468e\"\n+\n+[[package]]\n+name = \"nodrop\"\n+version = \"0.1.14\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"72ef4a56884ca558e5ddb05a1d1e7e1bfd9a68d9ed024c21704cc98872dae1bb\"\n+\n+[[package]]\n+name = \"packed_simd\"\n+version = \"0.3.3\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"a85ea9fc0d4ac0deb6fe7911d38786b32fc11119afd9e9d38b84ff691ce64220\"\n+dependencies = [\n+ \"cfg-if\",\n+]\n+\n+[[package]]\n+name = \"proc-macro-error\"\n+version = \"0.4.11\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"e7959c6467d962050d639361f7703b2051c43036d03493c36f01d440fdd3138a\"\n+dependencies = [\n+ \"proc-macro-error-attr\",\n+ \"proc-macro2\",\n+ \"quote\",\n+ \"syn\",\n+ \"version_check\",\n+]\n+\n+[[package]]\n+name = \"proc-macro-error-attr\"\n+version = \"0.4.11\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"e4002d9f55991d5e019fb940a90e1a95eb80c24e77cb2462dd4dc869604d543a\"\n+dependencies = [\n+ \"proc-macro2\",\n+ \"quote\",\n+ \"syn\",\n+ \"syn-mid\",\n+ \"version_check\",\n+]\n+\n+[[package]]\n+name = \"proc-macro2\"\n+version = \"1.0.6\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"9c9e470a8dc4aeae2dee2f335e8f533e2d4b347e1434e5671afc49b054592f27\"\n+dependencies = [\n+ \"unicode-xid\",\n+]\n+\n+[[package]]\n+name = \"quick-error\"\n+version = \"1.2.2\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"9274b940887ce9addde99c4eee6b5c44cc494b182b97e73dc8ffdcb3397fd3f0\"\n+\n+[[package]]\n+name = \"quote\"\n+version = \"1.0.6\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"54a21852a652ad6f610c9510194f398ff6f8692e334fd1145fed931f7fbe44ea\"\n+dependencies = [\n+ \"proc-macro2\",\n+]\n+\n+[[package]]\n+name = \"rand_core\"\n+version = \"0.3.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"7a6fdeb83b075e8266dcc8762c22776f6877a63111121f5f8c7411e5be7eed4b\"\n+dependencies = [\n+ \"rand_core 0.4.2\",\n+]\n+\n+[[package]]\n+name = \"rand_core\"\n+version = \"0.4.2\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"9c33a3c44ca05fa6f1807d8e6743f3824e8509beca625669633be0acbdf509dc\"\n+\n+[[package]]\n+name = \"rand_os\"\n+version = \"0.1.3\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"7b75f676a1e053fc562eafbb47838d67c84801e38fc1ba459e8f180deabd5071\"\n+dependencies = [\n+ \"cloudabi\",\n+ \"fuchsia-cprng\",\n+ \"libc\",\n+ \"rand_core 0.4.2\",\n+ \"rdrand\",\n+ \"winapi\",\n+]\n+\n+[[package]]\n+name = \"rdrand\"\n+version = \"0.4.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"678054eb77286b51581ba43620cc911abf02758c91f93f479767aed0f90458b2\"\n+dependencies = [\n+ \"rand_core 0.3.1\",\n+]\n+\n+[[package]]\n+name = \"redox_syscall\"\n+version = \"0.1.56\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"2439c63f3f6139d1b57529d16bc3b8bb855230c8efcc5d3a896c8bea7c3b1e84\"\n+\n+[[package]]\n+name = \"redox_users\"\n+version = \"0.3.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"4ecedbca3bf205f8d8f5c2b44d83cd0690e39ee84b951ed649e9f1841132b66d\"\n+dependencies = [\n+ \"failure\",\n+ \"rand_os\",\n+ \"redox_syscall\",\n+ \"rust-argon2\",\n+]\n+\n+[[package]]\n+name = \"regex\"\n+version = \"1.3.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"dc220bd33bdce8f093101afe22a037b8eb0e5af33592e6a9caafff0d4cb81cbd\"\n+dependencies = [\n+ \"aho-corasick\",\n+ \"memchr\",\n+ \"regex-syntax\",\n+ \"thread_local 0.3.6\",\n+]\n+\n+[[package]]\n+name = \"regex-syntax\"\n+version = \"0.6.12\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"11a7e20d1cce64ef2fed88b66d347f88bd9babb82845b2b858f3edbf59a4f716\"\n+\n+[[package]]\n+name = \"rust-argon2\"\n+version = \"0.5.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"4ca4eaef519b494d1f2848fc602d18816fed808a981aedf4f1f00ceb7c9d32cf\"\n+dependencies = [\n+ \"base64\",\n+ \"blake2b_simd\",\n+ \"crossbeam-utils 0.6.6\",\n+]\n+\n+[[package]]\n+name = \"rustc-demangle\"\n+version = \"0.1.16\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"4c691c0e608126e00913e33f0ccf3727d5fc84573623b8d65b2df340b5201783\"\n+\n+[[package]]\n+name = \"rustc-workspace-hack\"\n+version = \"1.0.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"fc71d2faa173b74b232dedc235e3ee1696581bb132fc116fa3626d6151a1a8fb\"\n+\n+[[package]]\n+name = \"rustfmt-config_proc_macro\"\n+version = \"0.2.0\"\n+dependencies = [\n+ \"proc-macro2\",\n+ \"quote\",\n+ \"syn\",\n+]\n+\n+[[package]]\n+name = \"rustfmt-nightly\"\n+version = \"1.4.37\"\n+dependencies = [\n+ \"annotate-snippets\",\n+ \"anyhow\",\n+ \"bytecount\",\n+ \"cargo_metadata\",\n+ \"derive-new\",\n+ \"diff\",\n+ \"dirs\",\n+ \"env_logger\",\n+ \"getopts\",\n+ \"ignore\",\n+ \"itertools\",\n+ \"lazy_static\",\n+ \"log\",\n+ \"regex\",\n+ \"rustc-workspace-hack\",\n+ \"rustfmt-config_proc_macro\",\n+ \"serde\",\n+ \"serde_json\",\n+ \"structopt\",\n+ \"term\",\n+ \"thiserror\",\n+ \"toml\",\n+ \"unicode-segmentation\",\n+ \"unicode-width\",\n+ \"unicode_categories\",\n+]\n+\n+[[package]]\n+name = \"ryu\"\n+version = \"1.0.2\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"bfa8506c1de11c9c4e4c38863ccbe02a305c8188e85a05a784c9e11e1c3910c8\"\n+\n+[[package]]\n+name = \"same-file\"\n+version = \"1.0.5\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"585e8ddcedc187886a30fa705c47985c3fa88d06624095856b36ca0b82ff4421\"\n+dependencies = [\n+ \"winapi-util\",\n+]\n+\n+[[package]]\n+name = \"semver\"\n+version = \"0.9.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"1d7eb9ef2c18661902cc47e535f9bc51b78acd254da71d375c2f6720d9a40403\"\n+dependencies = [\n+ \"semver-parser\",\n+ \"serde\",\n+]\n+\n+[[package]]\n+name = \"semver-parser\"\n+version = \"0.7.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"388a1df253eca08550bef6c72392cfe7c30914bf41df5269b68cbd6ff8f570a3\"\n+\n+[[package]]\n+name = \"serde\"\n+version = \"1.0.101\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"9796c9b7ba2ffe7a9ce53c2287dfc48080f4b2b362fcc245a259b3a7201119dd\"\n+dependencies = [\n+ \"serde_derive\",\n+]\n+\n+[[package]]\n+name = \"serde_derive\"\n+version = \"1.0.101\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"4b133a43a1ecd55d4086bd5b4dc6c1751c68b1bfbeba7a5040442022c7e7c02e\"\n+dependencies = [\n+ \"proc-macro2\",\n+ \"quote\",\n+ \"syn\",\n+]\n+\n+[[package]]\n+name = \"serde_json\"\n+version = \"1.0.41\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"2f72eb2a68a7dc3f9a691bfda9305a1c017a6215e5a4545c258500d2099a37c2\"\n+dependencies = [\n+ \"itoa\",\n+ \"ryu\",\n+ \"serde\",\n+]\n+\n+[[package]]\n+name = \"strsim\"\n+version = \"0.8.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"8ea5119cdb4c55b55d432abb513a0429384878c15dde60cc77b1c99de1a95a6a\"\n+\n+[[package]]\n+name = \"structopt\"\n+version = \"0.3.11\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"3fe43617218c0805c6eb37160119dc3c548110a67786da7218d1c6555212f073\"\n+dependencies = [\n+ \"clap\",\n+ \"lazy_static\",\n+ \"structopt-derive\",\n+]\n+\n+[[package]]\n+name = \"structopt-derive\"\n+version = \"0.4.4\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"c6e79c80e0f4efd86ca960218d4e056249be189ff1c42824dcd9a7f51a56f0bd\"\n+dependencies = [\n+ \"heck\",\n+ \"proc-macro-error\",\n+ \"proc-macro2\",\n+ \"quote\",\n+ \"syn\",\n+]\n+\n+[[package]]\n+name = \"syn\"\n+version = \"1.0.11\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"dff0acdb207ae2fe6d5976617f887eb1e35a2ba52c13c7234c790960cdad9238\"\n+dependencies = [\n+ \"proc-macro2\",\n+ \"quote\",\n+ \"unicode-xid\",\n+]\n+\n+[[package]]\n+name = \"syn-mid\"\n+version = \"0.5.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"7be3539f6c128a931cf19dcee741c1af532c7fd387baa739c03dd2e96479338a\"\n+dependencies = [\n+ \"proc-macro2\",\n+ \"quote\",\n+ \"syn\",\n+]\n+\n+[[package]]\n+name = \"synstructure\"\n+version = \"0.12.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"3f085a5855930c0441ca1288cf044ea4aecf4f43a91668abdb870b4ba546a203\"\n+dependencies = [\n+ \"proc-macro2\",\n+ \"quote\",\n+ \"syn\",\n+ \"unicode-xid\",\n+]\n+\n+[[package]]\n+name = \"term\"\n+version = \"0.6.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"c0863a3345e70f61d613eab32ee046ccd1bcc5f9105fe402c61fcd0c13eeb8b5\"\n+dependencies = [\n+ \"dirs\",\n+ \"winapi\",\n+]\n+\n+[[package]]\n+name = \"termcolor\"\n+version = \"1.0.5\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"96d6098003bde162e4277c70665bd87c326f5a0c3f3fbfb285787fa482d54e6e\"\n+dependencies = [\n+ \"wincolor\",\n+]\n+\n+[[package]]\n+name = \"textwrap\"\n+version = \"0.11.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"d326610f408c7a4eb6f51c37c330e496b08506c9457c9d34287ecc38809fb060\"\n+dependencies = [\n+ \"unicode-width\",\n+]\n+\n+[[package]]\n+name = \"thiserror\"\n+version = \"1.0.6\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"cc6b305ec0e323c7b6cfff6098a22516e0063d0bb7c3d88660a890217dca099a\"\n+dependencies = [\n+ \"thiserror-impl\",\n+]\n+\n+[[package]]\n+name = \"thiserror-impl\"\n+version = \"1.0.6\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"45ba8d810d9c48fc456b7ad54574e8bfb7c7918a57ad7a6e6a0985d7959e8597\"\n+dependencies = [\n+ \"proc-macro2\",\n+ \"quote\",\n+ \"syn\",\n+]\n+\n+[[package]]\n+name = \"thread_local\"\n+version = \"0.3.6\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"c6b53e329000edc2b34dbe8545fd20e55a333362d0a321909685a19bd28c3f1b\"\n+dependencies = [\n+ \"lazy_static\",\n+]\n+\n+[[package]]\n+name = \"thread_local\"\n+version = \"1.0.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"d40c6d1b69745a6ec6fb1ca717914848da4b44ae29d9b3080cbee91d72a69b14\"\n+dependencies = [\n+ \"lazy_static\",\n+]\n+\n+[[package]]\n+name = \"toml\"\n+version = \"0.5.3\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"c7aabe75941d914b72bf3e5d3932ed92ce0664d49d8432305a8b547c37227724\"\n+dependencies = [\n+ \"serde\",\n+]\n+\n+[[package]]\n+name = \"unicode-segmentation\"\n+version = \"1.3.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"1967f4cdfc355b37fd76d2a954fb2ed3871034eb4f26d60537d88795cfc332a9\"\n+\n+[[package]]\n+name = \"unicode-width\"\n+version = \"0.1.6\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"7007dbd421b92cc6e28410fe7362e2e0a2503394908f417b68ec8d1c364c4e20\"\n+\n+[[package]]\n+name = \"unicode-xid\"\n+version = \"0.2.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"826e7639553986605ec5979c7dd957c7895e93eabed50ab2ffa7f6128a75097c\"\n+\n+[[package]]\n+name = \"unicode_categories\"\n+version = \"0.1.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"39ec24b3121d976906ece63c9daad25b85969647682eee313cb5779fdd69e14e\"\n+\n+[[package]]\n+name = \"vec_map\"\n+version = \"0.8.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"05c78687fb1a80548ae3250346c3db86a80a7cdd77bda190189f2d0a0987c81a\"\n+\n+[[package]]\n+name = \"version_check\"\n+version = \"0.9.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"078775d0255232fb988e6fccf26ddc9d1ac274299aaedcedce21c6f72cc533ce\"\n+\n+[[package]]\n+name = \"walkdir\"\n+version = \"2.2.9\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"9658c94fa8b940eab2250bd5a457f9c48b748420d71293b165c8cdbe2f55f71e\"\n+dependencies = [\n+ \"same-file\",\n+ \"winapi\",\n+ \"winapi-util\",\n+]\n+\n+[[package]]\n+name = \"winapi\"\n+version = \"0.3.8\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"8093091eeb260906a183e6ae1abdba2ef5ef2257a21801128899c3fc699229c6\"\n+dependencies = [\n+ \"winapi-i686-pc-windows-gnu\",\n+ \"winapi-x86_64-pc-windows-gnu\",\n+]\n+\n+[[package]]\n+name = \"winapi-i686-pc-windows-gnu\"\n+version = \"0.4.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"ac3b87c63620426dd9b991e5ce0329eff545bccbbb34f3be09ff6fb6ab51b7b6\"\n+\n+[[package]]\n+name = \"winapi-util\"\n+version = \"0.1.2\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"7168bab6e1daee33b4557efd0e95d5ca70a03706d39fa5f3fe7a236f584b03c9\"\n+dependencies = [\n+ \"winapi\",\n+]\n+\n+[[package]]\n+name = \"winapi-x86_64-pc-windows-gnu\"\n+version = \"0.4.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"712e227841d057c1ee1cd2fb22fa7e5a5461ae8e48fa2ca79ec42cfc1931183f\"\n+\n+[[package]]\n+name = \"wincolor\"\n+version = \"1.0.2\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"96f5016b18804d24db43cebf3c77269e7569b8954a8464501c216cc5e070eaa9\"\n+dependencies = [\n+ \"winapi\",\n+ \"winapi-util\",\n+]\n+\n+[[package]]\n+name = \"yansi-term\"\n+version = \"0.1.2\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"fe5c30ade05e61656247b2e334a031dfd0cc466fadef865bdcdea8d537951bf1\"\n+dependencies = [\n+ \"winapi\",\n+]"}, {"sha": "24b3b79343b05587f56c44f9086ee48dea49f397", "filename": "src/tools/rustfmt/Cargo.toml", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2FCargo.toml?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782", "patch": "@@ -0,0 +1,67 @@\n+[package]\n+\n+name = \"rustfmt-nightly\"\n+version = \"1.4.37\"\n+authors = [\"Nicholas Cameron <ncameron@mozilla.com>\", \"The Rustfmt developers\"]\n+description = \"Tool to find and fix Rust formatting issues\"\n+repository = \"https://github.com/rust-lang/rustfmt\"\n+readme = \"README.md\"\n+license = \"Apache-2.0/MIT\"\n+build = \"build.rs\"\n+categories = [\"development-tools\"]\n+edition = \"2018\"\n+\n+[[bin]]\n+name = \"rustfmt\"\n+path = \"src/bin/main.rs\"\n+\n+[[bin]]\n+name = \"cargo-fmt\"\n+path = \"src/cargo-fmt/main.rs\"\n+\n+[[bin]]\n+name = \"rustfmt-format-diff\"\n+path = \"src/format-diff/main.rs\"\n+\n+[[bin]]\n+name = \"git-rustfmt\"\n+path = \"src/git-rustfmt/main.rs\"\n+\n+[features]\n+default = [\"cargo-fmt\", \"rustfmt-format-diff\"]\n+cargo-fmt = []\n+rustfmt-format-diff = []\n+generic-simd = [\"bytecount/generic-simd\"]\n+\n+[dependencies]\n+itertools = \"0.8\"\n+toml = \"0.5\"\n+serde = { version = \"1.0\", features = [\"derive\"] }\n+serde_json = \"1.0\"\n+unicode-segmentation = \"1.0.0\"\n+regex = \"1.0\"\n+term = \"0.6\"\n+diff = \"0.1\"\n+log = \"0.4\"\n+env_logger = \"0.6\"\n+getopts = \"0.2\"\n+derive-new = \"0.5\"\n+cargo_metadata = \"0.8\"\n+bytecount = \"0.6\"\n+unicode-width = \"0.1.5\"\n+unicode_categories = \"0.1.1\"\n+dirs = \"2.0.1\"\n+ignore = \"0.4.11\"\n+annotate-snippets = { version = \"0.8\", features = [\"color\"] }\n+structopt = \"0.3\"\n+rustfmt-config_proc_macro = { version = \"0.2\", path = \"config_proc_macro\" }\n+lazy_static = \"1.0.0\"\n+anyhow = \"1.0\"\n+thiserror = \"1.0\"\n+\n+# A noop dependency that changes in the Rust repository, it's a bit of a hack.\n+# See the `src/tools/rustc-workspace-hack/README.md` file in `rust-lang/rust`\n+# for more information.\n+rustc-workspace-hack = \"1.0.0\"\n+\n+# Rustc dependencies are loaded from the sysroot, Cargo doesn't know about them."}, {"sha": "37cb7474130c8086300ec3d2a95d6e0c3d9e3f52", "filename": "src/tools/rustfmt/Configurations.md", "status": "added", "additions": 2773, "deletions": 0, "changes": 2773, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2FConfigurations.md", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2FConfigurations.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2FConfigurations.md?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782", "patch": "@@ -0,0 +1,2773 @@\n+# Configuring Rustfmt\n+\n+Rustfmt is designed to be very configurable. You can create a TOML file called `rustfmt.toml` or `.rustfmt.toml`, place it in the project or any other parent directory and it will apply the options in that file. If none of these directories contain such a file, both your home directory and a directory called `rustfmt` in your [global config directory](https://docs.rs/dirs/1.0.4/dirs/fn.config_dir.html) (e.g. `.config/rustfmt/`) are checked as well.\n+\n+A possible content of `rustfmt.toml` or `.rustfmt.toml` might look like this:\n+\n+```toml\n+indent_style = \"Block\"\n+reorder_imports = false\n+```\n+\n+Each configuration option is either stable or unstable.\n+Stable options can be used directly, while unstable options are opt-in.\n+To enable unstable options, set `unstable_features = true` in `rustfmt.toml` or pass `--unstable-features` to rustfmt.\n+\n+# Configuration Options\n+\n+Below you find a detailed visual guide on all the supported configuration options of rustfmt:\n+\n+## `array_width` \n+\n+Maximum width of an array literal before falling back to vertical formatting.\n+\n+- **Default value**: `60`\n+- **Possible values**: any positive integer that is less than or equal to the value specified for [`max_width`](#max_width)\n+- **Stable**: Yes\n+\n+By default this option is set as a percentage of [`max_width`](#max_width) provided by [`use_small_heuristics`](#use_small_heuristics), but a value set directly for `array_width` will take precedence. \n+\n+See also [`max_width`](#max_width) and [`use_small_heuristics`](#use_small_heuristics)\n+\n+## `attr_fn_like_width` \n+\n+Maximum width of the args of a function-like attributes before falling back to vertical formatting.\n+\n+- **Default value**: `70`\n+- **Possible values**: any positive integer that is less than or equal to the value specified for [`max_width`](#max_width)\n+- **Stable**: Yes\n+\n+By default this option is set as a percentage of [`max_width`](#max_width) provided by [`use_small_heuristics`](#use_small_heuristics), but a value set directly for `attr_fn_like_width` will take precedence. \n+\n+See also [`max_width`](#max_width) and [`use_small_heuristics`](#use_small_heuristics)\n+\n+## `binop_separator`\n+\n+Where to put a binary operator when a binary expression goes multiline.\n+\n+- **Default value**: `\"Front\"`\n+- **Possible values**: `\"Front\"`, `\"Back\"`\n+- **Stable**: No (tracking issue: #3368)\n+\n+#### `\"Front\"` (default):\n+\n+```rust\n+fn main() {\n+    let or = foofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoo\n+        || barbarbarbarbarbarbarbarbarbarbarbarbarbarbarbar;\n+\n+    let sum = 123456789012345678901234567890\n+        + 123456789012345678901234567890\n+        + 123456789012345678901234567890;\n+\n+    let range = aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n+        ..bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb;\n+}\n+```\n+\n+#### `\"Back\"`:\n+\n+```rust\n+fn main() {\n+    let or = foofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoo ||\n+        barbarbarbarbarbarbarbarbarbarbarbarbarbarbarbar;\n+\n+    let sum = 123456789012345678901234567890 +\n+        123456789012345678901234567890 +\n+        123456789012345678901234567890;\n+\n+    let range = aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa..\n+        bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb;\n+}\n+```\n+\n+## `blank_lines_lower_bound`\n+\n+Minimum number of blank lines which must be put between items. If two items have fewer blank lines between\n+them, additional blank lines are inserted.\n+\n+- **Default value**: `0`\n+- **Possible values**: *unsigned integer*\n+- **Stable**: No (tracking issue: #3382)\n+\n+### Example\n+Original Code (rustfmt will not change it with the default value of `0`):\n+\n+```rust\n+#![rustfmt::skip]\n+\n+fn foo() {\n+    println!(\"a\");\n+}\n+fn bar() {\n+    println!(\"b\");\n+    println!(\"c\");\n+}\n+```\n+\n+#### `1`\n+```rust\n+fn foo() {\n+\n+    println!(\"a\");\n+}\n+\n+fn bar() {\n+\n+    println!(\"b\");\n+\n+    println!(\"c\");\n+}\n+```\n+\n+\n+## `blank_lines_upper_bound`\n+\n+Maximum number of blank lines which can be put between items. If more than this number of consecutive empty\n+lines are found, they are trimmed down to match this integer.\n+\n+- **Default value**: `1`\n+- **Possible values**: any non-negative integer\n+- **Stable**: No (tracking issue: #3381)\n+\n+### Example\n+Original Code:\n+\n+```rust\n+#![rustfmt::skip]\n+\n+fn foo() {\n+    println!(\"a\");\n+}\n+\n+\n+\n+fn bar() {\n+    println!(\"b\");\n+\n+\n+    println!(\"c\");\n+}\n+```\n+\n+#### `1` (default):\n+```rust\n+fn foo() {\n+    println!(\"a\");\n+}\n+\n+fn bar() {\n+    println!(\"b\");\n+\n+    println!(\"c\");\n+}\n+```\n+\n+#### `2`:\n+```rust\n+fn foo() {\n+    println!(\"a\");\n+}\n+\n+\n+fn bar() {\n+    println!(\"b\");\n+\n+\n+    println!(\"c\");\n+}\n+```\n+\n+See also: [`blank_lines_lower_bound`](#blank_lines_lower_bound)\n+\n+## `brace_style`\n+\n+Brace style for items\n+\n+- **Default value**: `\"SameLineWhere\"`\n+- **Possible values**: `\"AlwaysNextLine\"`, `\"PreferSameLine\"`, `\"SameLineWhere\"`\n+- **Stable**: No (tracking issue: #3376)\n+\n+### Functions\n+\n+#### `\"SameLineWhere\"` (default):\n+\n+```rust\n+fn lorem() {\n+    // body\n+}\n+\n+fn lorem(ipsum: usize) {\n+    // body\n+}\n+\n+fn lorem<T>(ipsum: T)\n+where\n+    T: Add + Sub + Mul + Div,\n+{\n+    // body\n+}\n+```\n+\n+#### `\"AlwaysNextLine\"`:\n+\n+```rust\n+fn lorem()\n+{\n+    // body\n+}\n+\n+fn lorem(ipsum: usize)\n+{\n+    // body\n+}\n+\n+fn lorem<T>(ipsum: T)\n+where\n+    T: Add + Sub + Mul + Div,\n+{\n+    // body\n+}\n+```\n+\n+#### `\"PreferSameLine\"`:\n+\n+```rust\n+fn lorem() {\n+    // body\n+}\n+\n+fn lorem(ipsum: usize) {\n+    // body\n+}\n+\n+fn lorem<T>(ipsum: T)\n+where\n+    T: Add + Sub + Mul + Div, {\n+    // body\n+}\n+```\n+\n+### Structs and enums\n+\n+#### `\"SameLineWhere\"` (default):\n+\n+```rust\n+struct Lorem {\n+    ipsum: bool,\n+}\n+\n+struct Dolor<T>\n+where\n+    T: Eq,\n+{\n+    sit: T,\n+}\n+```\n+\n+#### `\"AlwaysNextLine\"`:\n+\n+```rust\n+struct Lorem\n+{\n+    ipsum: bool,\n+}\n+\n+struct Dolor<T>\n+where\n+    T: Eq,\n+{\n+    sit: T,\n+}\n+```\n+\n+#### `\"PreferSameLine\"`:\n+\n+```rust\n+struct Lorem {\n+    ipsum: bool,\n+}\n+\n+struct Dolor<T>\n+where\n+    T: Eq, {\n+    sit: T,\n+}\n+```\n+\n+## `chain_width` \n+\n+Maximum width of a chain to fit on one line.\n+\n+- **Default value**: `60`\n+- **Possible values**: any positive integer that is less than or equal to the value specified for [`max_width`](#max_width)\n+- **Stable**: Yes\n+\n+By default this option is set as a percentage of [`max_width`](#max_width) provided by [`use_small_heuristics`](#use_small_heuristics), but a value set directly for `chain_width` will take precedence. \n+\n+See also [`max_width`](#max_width) and [`use_small_heuristics`](#use_small_heuristics)\n+\n+## `color`\n+\n+Whether to use colored output or not.\n+\n+- **Default value**: `\"Auto\"`\n+- **Possible values**: \"Auto\", \"Always\", \"Never\"\n+- **Stable**: No (tracking issue: #3385)\n+\n+## `combine_control_expr`\n+\n+Combine control expressions with function calls.\n+\n+- **Default value**: `true`\n+- **Possible values**: `true`, `false`\n+- **Stable**: No (tracking issue: #3369)\n+\n+#### `true` (default):\n+\n+```rust\n+fn example() {\n+    // If\n+    foo!(if x {\n+        foo();\n+    } else {\n+        bar();\n+    });\n+\n+    // IfLet\n+    foo!(if let Some(..) = x {\n+        foo();\n+    } else {\n+        bar();\n+    });\n+\n+    // While\n+    foo!(while x {\n+        foo();\n+        bar();\n+    });\n+\n+    // WhileLet\n+    foo!(while let Some(..) = x {\n+        foo();\n+        bar();\n+    });\n+\n+    // ForLoop\n+    foo!(for x in y {\n+        foo();\n+        bar();\n+    });\n+\n+    // Loop\n+    foo!(loop {\n+        foo();\n+        bar();\n+    });\n+}\n+```\n+\n+#### `false`:\n+\n+```rust\n+fn example() {\n+    // If\n+    foo!(\n+        if x {\n+            foo();\n+        } else {\n+            bar();\n+        }\n+    );\n+\n+    // IfLet\n+    foo!(\n+        if let Some(..) = x {\n+            foo();\n+        } else {\n+            bar();\n+        }\n+    );\n+\n+    // While\n+    foo!(\n+        while x {\n+            foo();\n+            bar();\n+        }\n+    );\n+\n+    // WhileLet\n+    foo!(\n+        while let Some(..) = x {\n+            foo();\n+            bar();\n+        }\n+    );\n+\n+    // ForLoop\n+    foo!(\n+        for x in y {\n+            foo();\n+            bar();\n+        }\n+    );\n+\n+    // Loop\n+    foo!(\n+        loop {\n+            foo();\n+            bar();\n+        }\n+    );\n+}\n+```\n+\n+## `comment_width`\n+\n+Maximum length of comments. No effect unless`wrap_comments = true`.\n+\n+- **Default value**: `80`\n+- **Possible values**: any positive integer\n+- **Stable**: No (tracking issue: #3349)\n+\n+**Note:** A value of `0` results in [`wrap_comments`](#wrap_comments) being applied regardless of a line's width.\n+\n+#### `80` (default; comments shorter than `comment_width`):\n+```rust\n+// Lorem ipsum dolor sit amet, consectetur adipiscing elit.\n+```\n+\n+#### `60` (comments longer than `comment_width`):\n+```rust\n+// Lorem ipsum dolor sit amet,\n+// consectetur adipiscing elit.\n+```\n+\n+See also [`wrap_comments`](#wrap_comments).\n+\n+## `condense_wildcard_suffixes`\n+\n+Replace strings of _ wildcards by a single .. in tuple patterns\n+\n+- **Default value**: `false`\n+- **Possible values**: `true`, `false`\n+- **Stable**: No (tracking issue: #3384)\n+\n+#### `false` (default):\n+\n+```rust\n+fn main() {\n+    let (lorem, ipsum, _, _) = (1, 2, 3, 4);\n+    let (lorem, ipsum, ..) = (1, 2, 3, 4);\n+}\n+```\n+\n+#### `true`:\n+\n+```rust\n+fn main() {\n+    let (lorem, ipsum, ..) = (1, 2, 3, 4);\n+}\n+```\n+\n+## `control_brace_style`\n+\n+Brace style for control flow constructs\n+\n+- **Default value**: `\"AlwaysSameLine\"`\n+- **Possible values**: `\"AlwaysNextLine\"`, `\"AlwaysSameLine\"`, `\"ClosingNextLine\"`\n+- **Stable**: No (tracking issue: #3377)\n+\n+#### `\"AlwaysSameLine\"` (default):\n+\n+```rust\n+fn main() {\n+    if lorem {\n+        println!(\"ipsum!\");\n+    } else {\n+        println!(\"dolor!\");\n+    }\n+}\n+```\n+\n+#### `\"AlwaysNextLine\"`:\n+\n+```rust\n+fn main() {\n+    if lorem\n+    {\n+        println!(\"ipsum!\");\n+    }\n+    else\n+    {\n+        println!(\"dolor!\");\n+    }\n+}\n+```\n+\n+#### `\"ClosingNextLine\"`:\n+\n+```rust\n+fn main() {\n+    if lorem {\n+        println!(\"ipsum!\");\n+    }\n+    else {\n+        println!(\"dolor!\");\n+    }\n+}\n+```\n+\n+## `disable_all_formatting`\n+\n+Don't reformat anything\n+\n+- **Default value**: `false`\n+- **Possible values**: `true`, `false`\n+- **Stable**: No (tracking issue: #3388)\n+\n+## `edition`\n+\n+Specifies which edition is used by the parser.\n+\n+- **Default value**: `\"2015\"`\n+- **Possible values**: `\"2015\"`, `\"2018\"`, `\"2021\"`\n+- **Stable**: Yes\n+\n+Rustfmt is able to pick up the edition used by reading the `Cargo.toml` file if executed\n+through the Cargo's formatting tool `cargo fmt`. Otherwise, the edition needs to be specified\n+in your config file:\n+\n+```toml\n+edition = \"2018\"\n+```\n+\n+## `empty_item_single_line`\n+\n+Put empty-body functions and impls on a single line\n+\n+- **Default value**: `true`\n+- **Possible values**: `true`, `false`\n+- **Stable**: No (tracking issue: #3356)\n+\n+#### `true` (default):\n+\n+```rust\n+fn lorem() {}\n+\n+impl Lorem {}\n+```\n+\n+#### `false`:\n+\n+```rust\n+fn lorem() {\n+}\n+\n+impl Lorem {\n+}\n+```\n+\n+See also [`brace_style`](#brace_style), [`control_brace_style`](#control_brace_style).\n+\n+\n+## `enum_discrim_align_threshold`\n+\n+The maximum length of enum variant having discriminant, that gets vertically aligned with others.\n+Variants without discriminants would be ignored for the purpose of alignment.\n+\n+Note that this is not how much whitespace is inserted, but instead the longest variant name that\n+doesn't get ignored when aligning.\n+\n+- **Default value** : 0\n+- **Possible values**: any positive integer\n+- **Stable**: No (tracking issue: #3372)\n+\n+#### `0` (default):\n+\n+```rust\n+enum Bar {\n+    A = 0,\n+    Bb = 1,\n+    RandomLongVariantGoesHere = 10,\n+    Ccc = 71,\n+}\n+\n+enum Bar {\n+    VeryLongVariantNameHereA = 0,\n+    VeryLongVariantNameHereBb = 1,\n+    VeryLongVariantNameHereCcc = 2,\n+}\n+```\n+\n+#### `20`:\n+\n+```rust\n+enum Foo {\n+    A   = 0,\n+    Bb  = 1,\n+    RandomLongVariantGoesHere = 10,\n+    Ccc = 2,\n+}\n+\n+enum Bar {\n+    VeryLongVariantNameHereA = 0,\n+    VeryLongVariantNameHereBb = 1,\n+    VeryLongVariantNameHereCcc = 2,\n+}\n+```\n+\n+\n+## `error_on_line_overflow`\n+\n+Error if Rustfmt is unable to get all lines within `max_width`, except for comments and string\n+literals. If this happens, then it is a bug in Rustfmt. You might be able to work around the bug by\n+refactoring your code to avoid long/complex expressions, usually by extracting a local variable or\n+using a shorter name.\n+\n+- **Default value**: `false`\n+- **Possible values**: `true`, `false`\n+- **Stable**: No (tracking issue: #3391)\n+\n+See also [`max_width`](#max_width).\n+\n+## `error_on_unformatted`\n+\n+Error if unable to get comments or string literals within `max_width`, or they are left with\n+trailing whitespaces.\n+\n+- **Default value**: `false`\n+- **Possible values**: `true`, `false`\n+- **Stable**: No (tracking issue: #3392)\n+\n+## `fn_args_layout`\n+\n+Control the layout of arguments in a function\n+\n+- **Default value**: `\"Tall\"`\n+- **Possible values**: `\"Compressed\"`, `\"Tall\"`, `\"Vertical\"`\n+- **Stable**: Yes\n+\n+#### `\"Tall\"` (default):\n+\n+```rust\n+trait Lorem {\n+    fn lorem(ipsum: Ipsum, dolor: Dolor, sit: Sit, amet: Amet);\n+\n+    fn lorem(ipsum: Ipsum, dolor: Dolor, sit: Sit, amet: Amet) {\n+        // body\n+    }\n+\n+    fn lorem(\n+        ipsum: Ipsum,\n+        dolor: Dolor,\n+        sit: Sit,\n+        amet: Amet,\n+        consectetur: Consectetur,\n+        adipiscing: Adipiscing,\n+        elit: Elit,\n+    );\n+\n+    fn lorem(\n+        ipsum: Ipsum,\n+        dolor: Dolor,\n+        sit: Sit,\n+        amet: Amet,\n+        consectetur: Consectetur,\n+        adipiscing: Adipiscing,\n+        elit: Elit,\n+    ) {\n+        // body\n+    }\n+}\n+```\n+\n+#### `\"Compressed\"`:\n+\n+```rust\n+trait Lorem {\n+    fn lorem(ipsum: Ipsum, dolor: Dolor, sit: Sit, amet: Amet);\n+\n+    fn lorem(ipsum: Ipsum, dolor: Dolor, sit: Sit, amet: Amet) {\n+        // body\n+    }\n+\n+    fn lorem(\n+        ipsum: Ipsum, dolor: Dolor, sit: Sit, amet: Amet, consectetur: Consectetur,\n+        adipiscing: Adipiscing, elit: Elit,\n+    );\n+\n+    fn lorem(\n+        ipsum: Ipsum, dolor: Dolor, sit: Sit, amet: Amet, consectetur: Consectetur,\n+        adipiscing: Adipiscing, elit: Elit,\n+    ) {\n+        // body\n+    }\n+}\n+```\n+\n+#### `\"Vertical\"`:\n+\n+```rust\n+trait Lorem {\n+    fn lorem(\n+        ipsum: Ipsum,\n+        dolor: Dolor,\n+        sit: Sit,\n+        amet: Amet,\n+    );\n+\n+    fn lorem(\n+        ipsum: Ipsum,\n+        dolor: Dolor,\n+        sit: Sit,\n+        amet: Amet,\n+    ) {\n+        // body\n+    }\n+\n+    fn lorem(\n+        ipsum: Ipsum,\n+        dolor: Dolor,\n+        sit: Sit,\n+        amet: Amet,\n+        consectetur: Consectetur,\n+        adipiscing: Adipiscing,\n+        elit: Elit,\n+    );\n+\n+    fn lorem(\n+        ipsum: Ipsum,\n+        dolor: Dolor,\n+        sit: Sit,\n+        amet: Amet,\n+        consectetur: Consectetur,\n+        adipiscing: Adipiscing,\n+        elit: Elit,\n+    ) {\n+        // body\n+    }\n+}\n+```\n+\n+## `fn_call_width` \n+\n+Maximum width of the args of a function call before falling back to vertical formatting.\n+\n+- **Default value**: `60`\n+- **Possible values**: any positive integer that is less than or equal to the value specified for [`max_width`](#max_width)\n+- **Stable**: Yes\n+\n+By default this option is set as a percentage of [`max_width`](#max_width) provided by [`use_small_heuristics`](#use_small_heuristics), but a value set directly for `fn_call_width` will take precedence. \n+\n+See also [`max_width`](#max_width) and [`use_small_heuristics`](#use_small_heuristics)\n+\n+## `fn_single_line`\n+\n+Put single-expression functions on a single line\n+\n+- **Default value**: `false`\n+- **Possible values**: `true`, `false`\n+- **Stable**: No (tracking issue: #3358)\n+\n+#### `false` (default):\n+\n+```rust\n+fn lorem() -> usize {\n+    42\n+}\n+\n+fn lorem() -> usize {\n+    let ipsum = 42;\n+    ipsum\n+}\n+```\n+\n+#### `true`:\n+\n+```rust\n+fn lorem() -> usize { 42 }\n+\n+fn lorem() -> usize {\n+    let ipsum = 42;\n+    ipsum\n+}\n+```\n+\n+See also [`control_brace_style`](#control_brace_style).\n+\n+\n+## `force_explicit_abi`\n+\n+Always print the abi for extern items\n+\n+- **Default value**: `true`\n+- **Possible values**: `true`, `false`\n+- **Stable**: Yes\n+\n+**Note:** Non-\"C\" ABIs are always printed. If `false` then \"C\" is removed.\n+\n+#### `true` (default):\n+\n+```rust\n+extern \"C\" {\n+    pub static lorem: c_int;\n+}\n+```\n+\n+#### `false`:\n+\n+```rust\n+extern {\n+    pub static lorem: c_int;\n+}\n+```\n+\n+## `force_multiline_blocks`\n+\n+Force multiline closure and match arm bodies to be wrapped in a block\n+\n+- **Default value**: `false`\n+- **Possible values**: `false`, `true`\n+- **Stable**: No (tracking issue: #3374)\n+\n+#### `false` (default):\n+\n+```rust\n+fn main() {\n+    result.and_then(|maybe_value| match maybe_value {\n+        None => foo(),\n+        Some(value) => bar(),\n+    });\n+\n+    match lorem {\n+        None => |ipsum| {\n+            println!(\"Hello World\");\n+        },\n+        Some(dolor) => foo(),\n+    }\n+}\n+```\n+\n+#### `true`:\n+\n+```rust\n+fn main() {\n+    result.and_then(|maybe_value| {\n+        match maybe_value {\n+            None => foo(),\n+            Some(value) => bar(),\n+        }\n+    });\n+\n+    match lorem {\n+        None => {\n+            |ipsum| {\n+                println!(\"Hello World\");\n+            }\n+        }\n+        Some(dolor) => foo(),\n+    }\n+}\n+```\n+\n+\n+## `format_code_in_doc_comments`\n+\n+Format code snippet included in doc comments.\n+\n+- **Default value**: `false`\n+- **Possible values**: `true`, `false`\n+- **Stable**: No (tracking issue: #3348)\n+\n+#### `false` (default):\n+\n+```rust\n+/// Adds one to the number given.\n+///\n+/// # Examples\n+///\n+/// ```rust\n+/// let five=5;\n+///\n+/// assert_eq!(\n+///     6,\n+///     add_one(5)\n+/// );\n+/// # fn add_one(x: i32) -> i32 {\n+/// #     x + 1\n+/// # }\n+/// ```\n+fn add_one(x: i32) -> i32 {\n+    x + 1\n+}\n+```\n+\n+#### `true`\n+\n+```rust\n+/// Adds one to the number given.\n+///\n+/// # Examples\n+///\n+/// ```rust\n+/// let five = 5;\n+///\n+/// assert_eq!(6, add_one(5));\n+/// # fn add_one(x: i32) -> i32 {\n+/// #     x + 1\n+/// # }\n+/// ```\n+fn add_one(x: i32) -> i32 {\n+    x + 1\n+}\n+```\n+\n+## `format_macro_matchers`\n+\n+Format the metavariable matching patterns in macros.\n+\n+- **Default value**: `false`\n+- **Possible values**: `true`, `false`\n+- **Stable**: No (tracking issue: #3354)\n+\n+#### `false` (default):\n+\n+```rust\n+macro_rules! foo {\n+    ($a: ident : $b: ty) => {\n+        $a(42): $b;\n+    };\n+    ($a: ident $b: ident $c: ident) => {\n+        $a = $b + $c;\n+    };\n+}\n+```\n+\n+#### `true`:\n+\n+```rust\n+macro_rules! foo {\n+    ($a:ident : $b:ty) => {\n+        $a(42): $b;\n+    };\n+    ($a:ident $b:ident $c:ident) => {\n+        $a = $b + $c;\n+    };\n+}\n+```\n+\n+See also [`format_macro_bodies`](#format_macro_bodies).\n+\n+\n+## `format_macro_bodies`\n+\n+Format the bodies of macros.\n+\n+- **Default value**: `true`\n+- **Possible values**: `true`, `false`\n+- **Stable**: No (tracking issue: #3355)\n+\n+#### `true` (default):\n+\n+```rust\n+macro_rules! foo {\n+    ($a: ident : $b: ty) => {\n+        $a(42): $b;\n+    };\n+    ($a: ident $b: ident $c: ident) => {\n+        $a = $b + $c;\n+    };\n+}\n+```\n+\n+#### `false`:\n+\n+```rust\n+macro_rules! foo {\n+    ($a: ident : $b: ty) => { $a(42): $b; };\n+    ($a: ident $b: ident $c: ident) => { $a=$b+$c; };\n+}\n+```\n+\n+See also [`format_macro_matchers`](#format_macro_matchers).\n+\n+\n+## `format_strings`\n+\n+Format string literals where necessary\n+\n+- **Default value**: `false`\n+- **Possible values**: `true`, `false`\n+- **Stable**: No (tracking issue: #3353)\n+\n+#### `false` (default):\n+\n+```rust\n+fn main() {\n+    let lorem = \"ipsum dolor sit amet consectetur adipiscing elit lorem ipsum dolor sit amet consectetur adipiscing\";\n+}\n+```\n+\n+#### `true`:\n+\n+```rust\n+fn main() {\n+    let lorem = \"ipsum dolor sit amet consectetur adipiscing elit lorem ipsum dolor sit amet \\\n+                 consectetur adipiscing\";\n+}\n+```\n+\n+See also [`max_width`](#max_width).\n+\n+## `hard_tabs`\n+\n+Use tab characters for indentation, spaces for alignment\n+\n+- **Default value**: `false`\n+- **Possible values**: `true`, `false`\n+- **Stable**: Yes\n+\n+#### `false` (default):\n+\n+```rust\n+fn lorem() -> usize {\n+    42 // spaces before 42\n+}\n+```\n+\n+#### `true`:\n+\n+```rust\n+fn lorem() -> usize {\n+\t42 // tabs before 42\n+}\n+```\n+\n+See also: [`tab_spaces`](#tab_spaces).\n+\n+\n+## `hide_parse_errors`\n+\n+Do not show parse errors if the parser failed to parse files.\n+\n+- **Default value**: `false`\n+- **Possible values**: `true`, `false`\n+- **Stable**: No (tracking issue: #3390)\n+\n+## `ignore`\n+\n+Skip formatting files and directories that match the specified pattern.\n+The pattern format is the same as [.gitignore](https://git-scm.com/docs/gitignore#_pattern_format). Be sure to use Unix/forwardslash `/` style  paths. This path style will work on all platforms. Windows style paths with backslashes `\\` are not supported.\n+\n+- **Default value**: format every file\n+- **Possible values**: See an example below\n+- **Stable**: No (tracking issue: #3395)\n+\n+### Example\n+\n+If you want to ignore specific files, put the following to your config file:\n+\n+```toml\n+ignore = [\n+    \"src/types.rs\",\n+    \"src/foo/bar.rs\",\n+]\n+```\n+\n+If you want to ignore every file under `examples/`, put the following to your config file:\n+\n+```toml\n+ignore = [\n+    \"examples\",\n+]\n+```\n+\n+If you want to ignore every file under the directory where you put your rustfmt.toml:\n+\n+```toml\n+ignore = [\"/\"]\n+```\n+\n+## `imports_indent`\n+\n+Indent style of imports\n+\n+- **Default Value**: `\"Block\"`\n+- **Possible values**: `\"Block\"`, `\"Visual\"`\n+- **Stable**: No (tracking issue: #3360)\n+\n+#### `\"Block\"` (default):\n+\n+```rust\n+use foo::{\n+    xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx, yyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy,\n+    zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz,\n+};\n+```\n+\n+#### `\"Visual\"`:\n+\n+```rust\n+use foo::{xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx, yyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy,\n+          zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz};\n+```\n+\n+See also: [`imports_layout`](#imports_layout).\n+\n+## `imports_layout`\n+\n+Item layout inside a imports block\n+\n+- **Default value**: \"Mixed\"\n+- **Possible values**: \"Horizontal\", \"HorizontalVertical\", \"Mixed\", \"Vertical\"\n+- **Stable**: No (tracking issue: #3361)\n+\n+#### `\"Mixed\"` (default):\n+\n+```rust\n+use foo::{xxxxxxxxxxxxxxxxxx, yyyyyyyyyyyyyyyyyy, zzzzzzzzzzzzzzzzzz};\n+\n+use foo::{\n+    aaaaaaaaaaaaaaaaaa, bbbbbbbbbbbbbbbbbb, cccccccccccccccccc, dddddddddddddddddd,\n+    eeeeeeeeeeeeeeeeee, ffffffffffffffffff,\n+};\n+```\n+\n+#### `\"Horizontal\"`:\n+\n+**Note**: This option forces all imports onto one line and may exceed `max_width`.\n+\n+```rust\n+use foo::{xxx, yyy, zzz};\n+\n+use foo::{aaa, bbb, ccc, ddd, eee, fff};\n+```\n+\n+#### `\"HorizontalVertical\"`:\n+\n+```rust\n+use foo::{xxxxxxxxxxxxxxxxxx, yyyyyyyyyyyyyyyyyy, zzzzzzzzzzzzzzzzzz};\n+\n+use foo::{\n+    aaaaaaaaaaaaaaaaaa,\n+    bbbbbbbbbbbbbbbbbb,\n+    cccccccccccccccccc,\n+    dddddddddddddddddd,\n+    eeeeeeeeeeeeeeeeee,\n+    ffffffffffffffffff,\n+};\n+```\n+\n+#### `\"Vertical\"`:\n+\n+```rust\n+use foo::{\n+    xxx,\n+    yyy,\n+    zzz,\n+};\n+\n+use foo::{\n+    aaa,\n+    bbb,\n+    ccc,\n+    ddd,\n+    eee,\n+    fff,\n+};\n+```\n+\n+## `indent_style`\n+\n+Indent on expressions or items.\n+\n+- **Default value**: `\"Block\"`\n+- **Possible values**: `\"Block\"`, `\"Visual\"`\n+- **Stable**: No (tracking issue: #3346)\n+\n+### Array\n+\n+#### `\"Block\"` (default):\n+\n+```rust\n+fn main() {\n+    let lorem = vec![\n+        \"ipsum\",\n+        \"dolor\",\n+        \"sit\",\n+        \"amet\",\n+        \"consectetur\",\n+        \"adipiscing\",\n+        \"elit\",\n+    ];\n+}\n+```\n+\n+#### `\"Visual\"`:\n+\n+```rust\n+fn main() {\n+    let lorem = vec![\"ipsum\",\n+                     \"dolor\",\n+                     \"sit\",\n+                     \"amet\",\n+                     \"consectetur\",\n+                     \"adipiscing\",\n+                     \"elit\"];\n+}\n+```\n+\n+### Control flow\n+\n+#### `\"Block\"` (default):\n+\n+```rust\n+fn main() {\n+    if lorem_ipsum\n+        && dolor_sit\n+        && amet_consectetur\n+        && lorem_sit\n+        && dolor_consectetur\n+        && amet_ipsum\n+        && lorem_consectetur\n+    {\n+        // ...\n+    }\n+}\n+```\n+\n+#### `\"Visual\"`:\n+\n+```rust\n+fn main() {\n+    if lorem_ipsum\n+       && dolor_sit\n+       && amet_consectetur\n+       && lorem_sit\n+       && dolor_consectetur\n+       && amet_ipsum\n+       && lorem_consectetur\n+    {\n+        // ...\n+    }\n+}\n+```\n+\n+See also: [`control_brace_style`](#control_brace_style).\n+\n+### Function arguments\n+\n+#### `\"Block\"` (default):\n+\n+```rust\n+fn lorem() {}\n+\n+fn lorem(ipsum: usize) {}\n+\n+fn lorem(\n+    ipsum: usize,\n+    dolor: usize,\n+    sit: usize,\n+    amet: usize,\n+    consectetur: usize,\n+    adipiscing: usize,\n+    elit: usize,\n+) {\n+    // body\n+}\n+```\n+\n+#### `\"Visual\"`:\n+\n+```rust\n+fn lorem() {}\n+\n+fn lorem(ipsum: usize) {}\n+\n+fn lorem(ipsum: usize,\n+         dolor: usize,\n+         sit: usize,\n+         amet: usize,\n+         consectetur: usize,\n+         adipiscing: usize,\n+         elit: usize) {\n+    // body\n+}\n+```\n+\n+### Function calls\n+\n+#### `\"Block\"` (default):\n+\n+```rust\n+fn main() {\n+    lorem(\n+        \"lorem\",\n+        \"ipsum\",\n+        \"dolor\",\n+        \"sit\",\n+        \"amet\",\n+        \"consectetur\",\n+        \"adipiscing\",\n+        \"elit\",\n+    );\n+}\n+```\n+\n+#### `\"Visual\"`:\n+\n+```rust\n+fn main() {\n+    lorem(\"lorem\",\n+          \"ipsum\",\n+          \"dolor\",\n+          \"sit\",\n+          \"amet\",\n+          \"consectetur\",\n+          \"adipiscing\",\n+          \"elit\");\n+}\n+```\n+\n+### Generics\n+\n+#### `\"Block\"` (default):\n+\n+```rust\n+fn lorem<\n+    Ipsum: Eq = usize,\n+    Dolor: Eq = usize,\n+    Sit: Eq = usize,\n+    Amet: Eq = usize,\n+    Adipiscing: Eq = usize,\n+    Consectetur: Eq = usize,\n+    Elit: Eq = usize,\n+>(\n+    ipsum: Ipsum,\n+    dolor: Dolor,\n+    sit: Sit,\n+    amet: Amet,\n+    adipiscing: Adipiscing,\n+    consectetur: Consectetur,\n+    elit: Elit,\n+) -> T {\n+    // body\n+}\n+```\n+\n+#### `\"Visual\"`:\n+\n+```rust\n+fn lorem<Ipsum: Eq = usize,\n+         Dolor: Eq = usize,\n+         Sit: Eq = usize,\n+         Amet: Eq = usize,\n+         Adipiscing: Eq = usize,\n+         Consectetur: Eq = usize,\n+         Elit: Eq = usize>(\n+    ipsum: Ipsum,\n+    dolor: Dolor,\n+    sit: Sit,\n+    amet: Amet,\n+    adipiscing: Adipiscing,\n+    consectetur: Consectetur,\n+    elit: Elit)\n+    -> T {\n+    // body\n+}\n+```\n+\n+#### Struct\n+\n+#### `\"Block\"` (default):\n+\n+```rust\n+fn main() {\n+    let lorem = Lorem {\n+        ipsum: dolor,\n+        sit: amet,\n+    };\n+}\n+```\n+\n+#### `\"Visual\"`:\n+\n+```rust\n+fn main() {\n+    let lorem = Lorem { ipsum: dolor,\n+                        sit: amet };\n+}\n+```\n+\n+See also: [`struct_lit_single_line`](#struct_lit_single_line), [`indent_style`](#indent_style).\n+\n+### Where predicates\n+\n+#### `\"Block\"` (default):\n+\n+```rust\n+fn lorem<Ipsum, Dolor, Sit, Amet>() -> T\n+where\n+    Ipsum: Eq,\n+    Dolor: Eq,\n+    Sit: Eq,\n+    Amet: Eq,\n+{\n+    // body\n+}\n+```\n+\n+#### `\"Visual\"`:\n+\n+```rust\n+fn lorem<Ipsum, Dolor, Sit, Amet>() -> T\n+    where Ipsum: Eq,\n+          Dolor: Eq,\n+          Sit: Eq,\n+          Amet: Eq\n+{\n+    // body\n+}\n+```\n+\n+## `inline_attribute_width`\n+\n+Write an item and its attribute on the same line if their combined width is below a threshold\n+\n+- **Default value**: 0\n+- **Possible values**: any positive integer\n+- **Stable**: No (tracking issue: #3343)\n+\n+### Example\n+\n+#### `0` (default):\n+```rust\n+#[cfg(feature = \"alloc\")]\n+use core::slice;\n+```\n+\n+#### `50`:\n+```rust\n+#[cfg(feature = \"alloc\")] use core::slice;\n+```\n+\n+## `license_template_path`\n+\n+Check whether beginnings of files match a license template.\n+\n+- **Default value**: `\"\"`\n+- **Possible values**: path to a license template file\n+- **Stable**: No (tracking issue: #3352)\n+\n+A license template is a plain text file which is matched literally against the\n+beginning of each source file, except for `{}`-delimited blocks, which are\n+matched as regular expressions. The following license template therefore\n+matches strings like `// Copyright 2017 The Rust Project Developers.`, `//\n+Copyright 2018 The Rust Project Developers.`, etc.:\n+\n+```\n+// Copyright {\\d+} The Rust Project Developers.\n+```\n+\n+`\\{`, `\\}` and `\\\\` match literal braces / backslashes.\n+\n+## `match_arm_blocks`\n+\n+Wrap the body of arms in blocks when it does not fit on the same line with the pattern of arms\n+\n+- **Default value**: `true`\n+- **Possible values**: `true`, `false`\n+- **Stable**: No (tracking issue: #3373)\n+\n+#### `true` (default):\n+\n+```rust\n+fn main() {\n+    match lorem {\n+        true => {\n+            foooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo(x)\n+        }\n+        false => println!(\"{}\", sit),\n+    }\n+}\n+```\n+\n+#### `false`:\n+\n+```rust\n+fn main() {\n+    match lorem {\n+        true =>\n+            foooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo(x),\n+        false => println!(\"{}\", sit),\n+    }\n+}\n+```\n+\n+See also: [`match_block_trailing_comma`](#match_block_trailing_comma).\n+\n+## `match_arm_leading_pipes`\n+\n+Controls whether to include a leading pipe on match arms\n+\n+- **Default value**: `Never`\n+- **Possible values**: `Always`, `Never`, `Preserve`\n+- **Stable**: Yes\n+\n+#### `Never` (default):\n+```rust\n+// Leading pipes are removed from this:\n+// fn foo() {\n+//     match foo {\n+//         | \"foo\" | \"bar\" => {}\n+//         | \"baz\"\n+//         | \"something relatively long\"\n+//         | \"something really really really realllllllllllllly long\" => println!(\"x\"),\n+//         | \"qux\" => println!(\"y\"),\n+//         _ => {}\n+//     }\n+// }\n+\n+// Becomes\n+fn foo() {\n+    match foo {\n+        \"foo\" | \"bar\" => {}\n+        \"baz\"\n+        | \"something relatively long\"\n+        | \"something really really really realllllllllllllly long\" => println!(\"x\"),\n+        \"qux\" => println!(\"y\"),\n+        _ => {}\n+    }\n+}\n+```\n+\n+#### `Always`:\n+```rust\n+// Leading pipes are emitted on all arms of this:\n+// fn foo() {\n+//     match foo {\n+//         \"foo\" | \"bar\" => {}\n+//         \"baz\"\n+//         | \"something relatively long\"\n+//         | \"something really really really realllllllllllllly long\" => println!(\"x\"),\n+//         \"qux\" => println!(\"y\"),\n+//         _ => {}\n+//     }\n+// }\n+\n+// Becomes:\n+fn foo() {\n+    match foo {\n+        | \"foo\" | \"bar\" => {}\n+        | \"baz\"\n+        | \"something relatively long\"\n+        | \"something really really really realllllllllllllly long\" => println!(\"x\"),\n+        | \"qux\" => println!(\"y\"),\n+        | _ => {}\n+    }\n+}\n+```\n+\n+#### `Preserve`:\n+```rust\n+fn foo() {\n+    match foo {\n+        | \"foo\" | \"bar\" => {}\n+        | \"baz\"\n+        | \"something relatively long\"\n+        | \"something really really really realllllllllllllly long\" => println!(\"x\"),\n+        | \"qux\" => println!(\"y\"),\n+        _ => {}\n+    }\n+\n+    match baz {\n+        \"qux\" => {}\n+        \"foo\" | \"bar\" => {}\n+        _ => {}\n+    }\n+}\n+```\n+\n+## `match_block_trailing_comma`\n+\n+Put a trailing comma after a block based match arm (non-block arms are not affected)\n+\n+- **Default value**: `false`\n+- **Possible values**: `true`, `false`\n+- **Stable**: No (tracking issue: #3380)\n+\n+#### `false` (default):\n+\n+```rust\n+fn main() {\n+    match lorem {\n+        Lorem::Ipsum => {\n+            println!(\"ipsum\");\n+        }\n+        Lorem::Dolor => println!(\"dolor\"),\n+    }\n+}\n+```\n+\n+#### `true`:\n+\n+```rust\n+fn main() {\n+    match lorem {\n+        Lorem::Ipsum => {\n+            println!(\"ipsum\");\n+        },\n+        Lorem::Dolor => println!(\"dolor\"),\n+    }\n+}\n+```\n+\n+See also: [`trailing_comma`](#trailing_comma), [`match_arm_blocks`](#match_arm_blocks).\n+\n+## `max_width`\n+\n+Maximum width of each line\n+\n+- **Default value**: `100`\n+- **Possible values**: any positive integer\n+- **Stable**: Yes\n+\n+See also [`error_on_line_overflow`](#error_on_line_overflow).\n+\n+## `merge_derives`\n+\n+Merge multiple derives into a single one.\n+\n+- **Default value**: `true`\n+- **Possible values**: `true`, `false`\n+- **Stable**: Yes\n+\n+#### `true` (default):\n+\n+```rust\n+#[derive(Eq, PartialEq, Debug, Copy, Clone)]\n+pub enum Foo {}\n+```\n+\n+#### `false`:\n+\n+```rust\n+#[derive(Eq, PartialEq)]\n+#[derive(Debug)]\n+#[derive(Copy, Clone)]\n+pub enum Foo {}\n+```\n+\n+## `imports_granularity`\n+\n+How imports should be grouped into `use` statements. Imports will be merged or split to the configured level of granularity.\n+\n+- **Default value**: `Preserve`\n+- **Possible values**: `Preserve`, `Crate`, `Module`, `Item`\n+- **Stable**: No\n+\n+#### `Preserve` (default):\n+\n+Do not change the granularity of any imports and preserve the original structure written by the developer.\n+\n+```rust\n+use foo::b;\n+use foo::b::{f, g};\n+use foo::{a, c, d::e};\n+use qux::{h, i};\n+```\n+\n+#### `Crate`:\n+\n+Merge imports from the same crate into a single `use` statement. Conversely, imports from different crates are split into separate statements.\n+\n+```rust\n+use foo::{\n+    a, b,\n+    b::{f, g},\n+    c,\n+    d::e,\n+};\n+use qux::{h, i};\n+```\n+\n+#### `Module`:\n+\n+Merge imports from the same module into a single `use` statement. Conversely, imports from different modules are split into separate statements.\n+\n+```rust\n+use foo::b::{f, g};\n+use foo::d::e;\n+use foo::{a, b, c};\n+use qux::{h, i};\n+```\n+\n+#### `Item`:\n+\n+Flatten imports so that each has its own `use` statement.\n+\n+```rust\n+use foo::a;\n+use foo::b;\n+use foo::b::f;\n+use foo::b::g;\n+use foo::c;\n+use foo::d::e;\n+use qux::h;\n+use qux::i;\n+```\n+\n+## `merge_imports`\n+\n+This option is deprecated. Use `imports_granularity = \"Crate\"` instead.\n+\n+- **Default value**: `false`\n+- **Possible values**: `true`, `false`\n+\n+#### `false` (default):\n+\n+```rust\n+use foo::{a, c, d};\n+use foo::{b, g};\n+use foo::{e, f};\n+```\n+\n+#### `true`:\n+\n+```rust\n+use foo::{a, b, c, d, e, f, g};\n+```\n+\n+\n+## `newline_style`\n+\n+Unix or Windows line endings\n+\n+- **Default value**: `\"Auto\"`\n+- **Possible values**: `\"Auto\"`, `\"Native\"`, `\"Unix\"`, `\"Windows\"`\n+- **Stable**: Yes\n+\n+#### `Auto` (default):\n+\n+The newline style is detected automatically on a per-file basis. Files\n+with mixed line endings will be converted to the first detected line\n+ending style.\n+\n+#### `Native`\n+\n+Line endings will be converted to `\\r\\n` on Windows and `\\n` on all\n+other platforms.\n+\n+#### `Unix`\n+\n+Line endings will be converted to `\\n`.\n+\n+#### `Windows`\n+\n+Line endings will be converted to `\\r\\n`.\n+\n+## `normalize_comments`\n+\n+Convert /* */ comments to // comments where possible\n+\n+- **Default value**: `false`\n+- **Possible values**: `true`, `false`\n+- **Stable**: No (tracking issue: #3350)\n+\n+#### `false` (default):\n+\n+```rust\n+// Lorem ipsum:\n+fn dolor() -> usize {}\n+\n+/* sit amet: */\n+fn adipiscing() -> usize {}\n+```\n+\n+#### `true`:\n+\n+```rust\n+// Lorem ipsum:\n+fn dolor() -> usize {}\n+\n+// sit amet:\n+fn adipiscing() -> usize {}\n+```\n+\n+## `normalize_doc_attributes`\n+\n+Convert `#![doc]` and `#[doc]` attributes to `//!` and `///` doc comments.\n+\n+- **Default value**: `false`\n+- **Possible values**: `true`, `false`\n+- **Stable**: No (tracking issue: #3351)\n+\n+#### `false` (default):\n+\n+```rust\n+#![doc = \"Example documentation\"]\n+\n+#[doc = \"Example item documentation\"]\n+pub enum Foo {}\n+```\n+\n+#### `true`:\n+\n+```rust\n+//! Example documentation\n+\n+/// Example item documentation\n+pub enum Foo {}\n+```\n+\n+## `overflow_delimited_expr`\n+\n+When structs, slices, arrays, and block/array-like macros are used as the last\n+argument in an expression list, allow them to overflow (like blocks/closures)\n+instead of being indented on a new line.\n+\n+- **Default value**: `false`\n+- **Possible values**: `true`, `false`\n+- **Stable**: No (tracking issue: #3370)\n+\n+#### `false` (default):\n+\n+```rust\n+fn example() {\n+    foo(ctx, |param| {\n+        action();\n+        foo(param)\n+    });\n+\n+    foo(\n+        ctx,\n+        Bar {\n+            x: value,\n+            y: value2,\n+        },\n+    );\n+\n+    foo(\n+        ctx,\n+        &[\n+            MAROON_TOMATOES,\n+            PURPLE_POTATOES,\n+            ORGANE_ORANGES,\n+            GREEN_PEARS,\n+            RED_APPLES,\n+        ],\n+    );\n+\n+    foo(\n+        ctx,\n+        vec![\n+            MAROON_TOMATOES,\n+            PURPLE_POTATOES,\n+            ORGANE_ORANGES,\n+            GREEN_PEARS,\n+            RED_APPLES,\n+        ],\n+    );\n+}\n+```\n+\n+#### `true`:\n+\n+```rust\n+fn example() {\n+    foo(ctx, |param| {\n+        action();\n+        foo(param)\n+    });\n+\n+    foo(ctx, Bar {\n+        x: value,\n+        y: value2,\n+    });\n+\n+    foo(ctx, &[\n+        MAROON_TOMATOES,\n+        PURPLE_POTATOES,\n+        ORGANE_ORANGES,\n+        GREEN_PEARS,\n+        RED_APPLES,\n+    ]);\n+\n+    foo(ctx, vec![\n+        MAROON_TOMATOES,\n+        PURPLE_POTATOES,\n+        ORGANE_ORANGES,\n+        GREEN_PEARS,\n+        RED_APPLES,\n+    ]);\n+}\n+```\n+\n+## `remove_nested_parens`\n+\n+Remove nested parens.\n+\n+- **Default value**: `true`,\n+- **Possible values**: `true`, `false`\n+- **Stable**: Yes\n+\n+\n+#### `true` (default):\n+```rust\n+fn main() {\n+    (foo());\n+}\n+```\n+\n+#### `false`:\n+```rust\n+fn main() {\n+    ((((foo()))));\n+}\n+```\n+\n+\n+## `reorder_impl_items`\n+\n+Reorder impl items. `type` and `const` are put first, then macros and methods.\n+\n+- **Default value**: `false`\n+- **Possible values**: `true`, `false`\n+- **Stable**: No (tracking issue: #3363)\n+\n+#### `false` (default)\n+\n+```rust\n+struct Dummy;\n+\n+impl Iterator for Dummy {\n+    fn next(&mut self) -> Option<Self::Item> {\n+        None\n+    }\n+\n+    type Item = i32;\n+}\n+```\n+\n+#### `true`\n+\n+```rust\n+struct Dummy;\n+\n+impl Iterator for Dummy {\n+    type Item = i32;\n+\n+    fn next(&mut self) -> Option<Self::Item> {\n+        None\n+    }\n+}\n+```\n+\n+## `reorder_imports`\n+\n+Reorder import and extern crate statements alphabetically in groups (a group is\n+separated by a newline).\n+\n+- **Default value**: `true`\n+- **Possible values**: `true`, `false`\n+- **Stable**: Yes\n+\n+#### `true` (default):\n+\n+```rust\n+use dolor;\n+use ipsum;\n+use lorem;\n+use sit;\n+```\n+\n+#### `false`:\n+\n+```rust\n+use lorem;\n+use ipsum;\n+use dolor;\n+use sit;\n+```\n+\n+## `group_imports`\n+\n+Controls the strategy for how imports are grouped together.\n+\n+- **Default value**: `Preserve`\n+- **Possible values**: `Preserve`, `StdExternalCrate`\n+- **Stable**: No\n+\n+#### `Preserve` (default):\n+\n+Preserve the source file's import groups.\n+\n+```rust\n+use super::update::convert_publish_payload;\n+use chrono::Utc;\n+\n+use alloc::alloc::Layout;\n+use juniper::{FieldError, FieldResult};\n+use uuid::Uuid;\n+\n+use std::sync::Arc;\n+\n+use broker::database::PooledConnection;\n+\n+use super::schema::{Context, Payload};\n+use crate::models::Event;\n+use core::f32;\n+```\n+\n+#### `StdExternalCrate`:\n+\n+Discard existing import groups, and create three groups for:\n+1. `std`, `core` and `alloc`,\n+2. external crates,\n+3. `self`, `super` and `crate` imports.\n+\n+```rust\n+use alloc::alloc::Layout;\n+use core::f32;\n+use std::sync::Arc;\n+\n+use broker::database::PooledConnection;\n+use chrono::Utc;\n+use juniper::{FieldError, FieldResult};\n+use uuid::Uuid;\n+\n+use super::schema::{Context, Payload};\n+use super::update::convert_publish_payload;\n+use crate::models::Event;\n+```\n+\n+## `reorder_modules`\n+\n+Reorder `mod` declarations alphabetically in group.\n+\n+- **Default value**: `true`\n+- **Possible values**: `true`, `false`\n+- **Stable**: Yes\n+\n+#### `true` (default)\n+\n+```rust\n+mod a;\n+mod b;\n+\n+mod dolor;\n+mod ipsum;\n+mod lorem;\n+mod sit;\n+```\n+\n+#### `false`\n+\n+```rust\n+mod b;\n+mod a;\n+\n+mod lorem;\n+mod ipsum;\n+mod dolor;\n+mod sit;\n+```\n+\n+**Note** `mod` with `#[macro_export]` will not be reordered since that could change the semantics\n+of the original source code.\n+\n+## `report_fixme`\n+\n+Report `FIXME` items in comments.\n+\n+- **Default value**: `\"Never\"`\n+- **Possible values**: `\"Always\"`, `\"Unnumbered\"`, `\"Never\"`\n+- **Stable**: No (tracking issue: #3394)\n+\n+Warns about any comments containing `FIXME` in them when set to `\"Always\"`. If\n+it contains a `#X` (with `X` being a number) in parentheses following the\n+`FIXME`, `\"Unnumbered\"` will ignore it.\n+\n+See also [`report_todo`](#report_todo).\n+\n+\n+## `report_todo`\n+\n+Report `TODO` items in comments.\n+\n+- **Default value**: `\"Never\"`\n+- **Possible values**: `\"Always\"`, `\"Unnumbered\"`, `\"Never\"`\n+- **Stable**: No (tracking issue: #3393)\n+\n+Warns about any comments containing `TODO` in them when set to `\"Always\"`. If\n+it contains a `#X` (with `X` being a number) in parentheses following the\n+`TODO`, `\"Unnumbered\"` will ignore it.\n+\n+See also [`report_fixme`](#report_fixme).\n+\n+## `required_version`\n+\n+Require a specific version of rustfmt. If you want to make sure that the\n+specific version of rustfmt is used in your CI, use this option.\n+\n+- **Default value**: `CARGO_PKG_VERSION`\n+- **Possible values**: any published version (e.g. `\"0.3.8\"`)\n+- **Stable**: No (tracking issue: #3386)\n+\n+## `skip_children`\n+\n+Don't reformat out of line modules\n+\n+- **Default value**: `false`\n+- **Possible values**: `true`, `false`\n+- **Stable**: No (tracking issue: #3389)\n+\n+## `single_line_if_else_max_width` \n+\n+Maximum line length for single line if-else expressions. A value of `0` (zero) results in if-else expressions always being broken into multiple lines. Note this occurs when `use_small_heuristics` is set to `Off`.\n+\n+- **Default value**: `50`\n+- **Possible values**: any positive integer that is less than or equal to the value specified for [`max_width`](#max_width)\n+- **Stable**: Yes\n+\n+By default this option is set as a percentage of [`max_width`](#max_width) provided by [`use_small_heuristics`](#use_small_heuristics), but a value set directly for `single_line_if_else_max_width` will take precedence. \n+\n+See also [`max_width`](#max_width) and [`use_small_heuristics`](#use_small_heuristics)\n+\n+## `space_after_colon`\n+\n+Leave a space after the colon.\n+\n+- **Default value**: `true`\n+- **Possible values**: `true`, `false`\n+- **Stable**: No (tracking issue: #3366)\n+\n+#### `true` (default):\n+\n+```rust\n+fn lorem<T: Eq>(t: T) {\n+    let lorem: Dolor = Lorem {\n+        ipsum: dolor,\n+        sit: amet,\n+    };\n+}\n+```\n+\n+#### `false`:\n+\n+```rust\n+fn lorem<T:Eq>(t:T) {\n+    let lorem:Dolor = Lorem {\n+        ipsum:dolor,\n+        sit:amet,\n+    };\n+}\n+```\n+\n+See also: [`space_before_colon`](#space_before_colon).\n+\n+## `space_before_colon`\n+\n+Leave a space before the colon.\n+\n+- **Default value**: `false`\n+- **Possible values**: `true`, `false`\n+- **Stable**: No (tracking issue: #3365)\n+\n+#### `false` (default):\n+\n+```rust\n+fn lorem<T: Eq>(t: T) {\n+    let lorem: Dolor = Lorem {\n+        ipsum: dolor,\n+        sit: amet,\n+    };\n+}\n+```\n+\n+#### `true`:\n+\n+```rust\n+fn lorem<T : Eq>(t : T) {\n+    let lorem : Dolor = Lorem {\n+        ipsum : dolor,\n+        sit : amet,\n+    };\n+}\n+```\n+\n+See also: [`space_after_colon`](#space_after_colon).\n+\n+## `spaces_around_ranges`\n+\n+Put spaces around the .., ..=, and ... range operators\n+\n+- **Default value**: `false`\n+- **Possible values**: `true`, `false`\n+- **Stable**: No (tracking issue: #3367)\n+\n+#### `false` (default):\n+\n+```rust\n+fn main() {\n+    let lorem = 0..10;\n+    let ipsum = 0..=10;\n+\n+    match lorem {\n+        1..5 => foo(),\n+        _ => bar,\n+    }\n+\n+    match lorem {\n+        1..=5 => foo(),\n+        _ => bar,\n+    }\n+\n+    match lorem {\n+        1...5 => foo(),\n+        _ => bar,\n+    }\n+}\n+```\n+\n+#### `true`:\n+\n+```rust\n+fn main() {\n+    let lorem = 0 .. 10;\n+    let ipsum = 0 ..= 10;\n+\n+    match lorem {\n+        1 .. 5 => foo(),\n+        _ => bar,\n+    }\n+\n+    match lorem {\n+        1 ..= 5 => foo(),\n+        _ => bar,\n+    }\n+\n+    match lorem {\n+        1 ... 5 => foo(),\n+        _ => bar,\n+    }\n+}\n+```\n+\n+## `struct_field_align_threshold`\n+\n+The maximum diff of width between struct fields to be aligned with each other.\n+\n+- **Default value** : 0\n+- **Possible values**: any non-negative integer\n+- **Stable**: No (tracking issue: #3371)\n+\n+#### `0` (default):\n+\n+```rust\n+struct Foo {\n+    x: u32,\n+    yy: u32,\n+    zzz: u32,\n+}\n+```\n+\n+#### `20`:\n+\n+```rust\n+struct Foo {\n+    x:   u32,\n+    yy:  u32,\n+    zzz: u32,\n+}\n+```\n+\n+## `struct_lit_single_line`\n+\n+Put small struct literals on a single line\n+\n+- **Default value**: `true`\n+- **Possible values**: `true`, `false`\n+- **Stable**: No (tracking issue: #3357)\n+\n+#### `true` (default):\n+\n+```rust\n+fn main() {\n+    let lorem = Lorem { foo: bar, baz: ofo };\n+}\n+```\n+\n+#### `false`:\n+\n+```rust\n+fn main() {\n+    let lorem = Lorem {\n+        foo: bar,\n+        baz: ofo,\n+    };\n+}\n+```\n+\n+See also: [`indent_style`](#indent_style).\n+\n+## `struct_lit_width` \n+\n+Maximum width in the body of a struct literal before falling back to vertical formatting. A value of `0` (zero) results in struct literals always being broken into multiple lines. Note this occurs when `use_small_heuristics` is set to `Off`.\n+\n+- **Default value**: `18`\n+- **Possible values**: any positive integer that is less than or equal to the value specified for [`max_width`](#max_width)\n+- **Stable**: Yes\n+\n+By default this option is set as a percentage of [`max_width`](#max_width) provided by [`use_small_heuristics`](#use_small_heuristics), but a value set directly for `struct_lit_width` will take precedence. \n+\n+See also [`max_width`](#max_width), [`use_small_heuristics`](#use_small_heuristics), and [`struct_lit_single_line`](#struct_lit_single_line)\n+\n+## `struct_variant_width` \n+\n+Maximum width in the body of a struct variant before falling back to vertical formatting. A value of `0` (zero) results in struct literals always being broken into multiple lines. Note this occurs when `use_small_heuristics` is set to `Off`.\n+\n+- **Default value**: `35`\n+- **Possible values**: any positive integer that is less than or equal to the value specified for [`max_width`](#max_width)\n+- **Stable**: Yes\n+\n+By default this option is set as a percentage of [`max_width`](#max_width) provided by [`use_small_heuristics`](#use_small_heuristics), but a value set directly for `struct_variant_width` will take precedence. \n+\n+See also [`max_width`](#max_width) and [`use_small_heuristics`](#use_small_heuristics)\n+\n+## `tab_spaces`\n+\n+Number of spaces per tab\n+\n+- **Default value**: `4`\n+- **Possible values**: any positive integer\n+- **Stable**: Yes\n+\n+#### `4` (default):\n+\n+```rust\n+fn lorem() {\n+    let ipsum = dolor();\n+    let sit = vec![\n+        \"amet consectetur adipiscing elit amet\",\n+        \"consectetur adipiscing elit amet consectetur.\",\n+    ];\n+}\n+```\n+\n+#### `2`:\n+\n+```rust\n+fn lorem() {\n+  let ipsum = dolor();\n+  let sit = vec![\n+    \"amet consectetur adipiscing elit amet\",\n+    \"consectetur adipiscing elit amet consectetur.\",\n+  ];\n+}\n+```\n+\n+See also: [`hard_tabs`](#hard_tabs).\n+\n+\n+## `trailing_comma`\n+\n+How to handle trailing commas for lists\n+\n+- **Default value**: `\"Vertical\"`\n+- **Possible values**: `\"Always\"`, `\"Never\"`, `\"Vertical\"`\n+- **Stable**: No (tracking issue: #3379)\n+\n+#### `\"Vertical\"` (default):\n+\n+```rust\n+fn main() {\n+    let Lorem { ipsum, dolor, sit } = amet;\n+    let Lorem {\n+        ipsum,\n+        dolor,\n+        sit,\n+        amet,\n+        consectetur,\n+        adipiscing,\n+    } = elit;\n+}\n+```\n+\n+#### `\"Always\"`:\n+\n+```rust\n+fn main() {\n+    let Lorem { ipsum, dolor, sit, } = amet;\n+    let Lorem {\n+        ipsum,\n+        dolor,\n+        sit,\n+        amet,\n+        consectetur,\n+        adipiscing,\n+    } = elit;\n+}\n+```\n+\n+#### `\"Never\"`:\n+\n+```rust\n+fn main() {\n+    let Lorem { ipsum, dolor, sit } = amet;\n+    let Lorem {\n+        ipsum,\n+        dolor,\n+        sit,\n+        amet,\n+        consectetur,\n+        adipiscing\n+    } = elit;\n+}\n+```\n+\n+See also: [`match_block_trailing_comma`](#match_block_trailing_comma).\n+\n+## `trailing_semicolon`\n+\n+Add trailing semicolon after break, continue and return\n+\n+- **Default value**: `true`\n+- **Possible values**: `true`, `false`\n+- **Stable**: No (tracking issue: #3378)\n+\n+#### `true` (default):\n+```rust\n+fn foo() -> usize {\n+    return 0;\n+}\n+```\n+\n+#### `false`:\n+```rust\n+fn foo() -> usize {\n+    return 0\n+}\n+```\n+\n+## `type_punctuation_density`\n+\n+Determines if `+` or `=` are wrapped in spaces in the punctuation of types\n+\n+- **Default value**: `\"Wide\"`\n+- **Possible values**: `\"Compressed\"`, `\"Wide\"`\n+- **Stable**: No (tracking issue: #3364)\n+\n+#### `\"Wide\"` (default):\n+\n+```rust\n+fn lorem<Ipsum: Dolor + Sit = Amet>() {\n+    // body\n+}\n+```\n+\n+#### `\"Compressed\"`:\n+\n+```rust\n+fn lorem<Ipsum: Dolor+Sit=Amet>() {\n+    // body\n+}\n+```\n+\n+## `unstable_features`\n+\n+Enable unstable features on the unstable channel.\n+\n+- **Default value**: `false`\n+- **Possible values**: `true`, `false`\n+- **Stable**: No (tracking issue: #3387)\n+\n+## `use_field_init_shorthand`\n+\n+Use field initialize shorthand if possible.\n+\n+- **Default value**: `false`\n+- **Possible values**: `true`, `false`\n+- **Stable**: Yes\n+\n+#### `false` (default):\n+\n+```rust\n+struct Foo {\n+    x: u32,\n+    y: u32,\n+    z: u32,\n+}\n+\n+fn main() {\n+    let x = 1;\n+    let y = 2;\n+    let z = 3;\n+    let a = Foo { x: x, y: y, z: z };\n+}\n+```\n+\n+#### `true`:\n+\n+```rust\n+struct Foo {\n+    x: u32,\n+    y: u32,\n+    z: u32,\n+}\n+\n+fn main() {\n+    let x = 1;\n+    let y = 2;\n+    let z = 3;\n+    let a = Foo { x, y, z };\n+}\n+```\n+\n+## `use_small_heuristics`\n+\n+This option can be used to simplify the management and bulk updates of the granular width configuration settings ([`fn_call_width`](#fn_call_width), [`attr_fn_like_width`](#attr_fn_like_width), [`struct_lit_width`](#struct_lit_width), [`struct_variant_width`](#struct_variant_width), [`array_width`](#array_width), [`chain_width`](#chain_width), [`single_line_if_else_max_width`](#single_line_if_else_max_width)), that respectively control when formatted constructs are multi-lined/vertical based on width.\n+\n+Note that explicitly provided values for the width configuration settings take precedence and override the calculated values determined by `use_small_heuristics`. \n+\n+- **Default value**: `\"Default\"`\n+- **Possible values**: `\"Default\"`, `\"Off\"`, `\"Max\"`\n+- **Stable**: Yes\n+\n+#### `Default` (default):\n+When `use_small_heuristics` is set to `Default`, the values for the granular width settings are calculated as a ratio of the value for `max_width`.\n+\n+The ratios are:\n+* [`fn_call_width`](#fn_call_width) - `60%`\n+* [`attr_fn_like_width`](#attr_fn_like_width) - `70%`\n+* [`struct_lit_width`](#struct_lit_width) - `18%`\n+* [`struct_variant_width`](#struct_variant_width) - `35%`\n+* [`array_width`](#array_width) - `60%`\n+* [`chain_width`](#chain_width) - `60%`\n+* [`single_line_if_else_max_width`](#single_line_if_else_max_width) - `50%`\n+\n+For example when `max_width` is set to `100`, the width settings are:\n+* `fn_call_width=60`\n+* `attr_fn_like_width=70`\n+* `struct_lit_width=18`\n+* `struct_variant_width=35`\n+* `array_width=60`\n+* `chain_width=60`\n+* `single_line_if_else_max_width=50`\n+\n+and when `max_width` is set to `200`:\n+* `fn_call_width=120`\n+* `attr_fn_like_width=140`\n+* `struct_lit_width=36`\n+* `struct_variant_width=70`\n+* `array_width=120`\n+* `chain_width=120`\n+* `single_line_if_else_max_width=100`\n+\n+```rust\n+enum Lorem {\n+    Ipsum,\n+    Dolor(bool),\n+    Sit { amet: Consectetur, adipiscing: Elit },\n+}\n+\n+fn main() {\n+    lorem(\n+        \"lorem\",\n+        \"ipsum\",\n+        \"dolor\",\n+        \"sit\",\n+        \"amet\",\n+        \"consectetur\",\n+        \"adipiscing\",\n+    );\n+\n+    let lorem = Lorem {\n+        ipsum: dolor,\n+        sit: amet,\n+    };\n+    let lorem = Lorem { ipsum: dolor };\n+\n+    let lorem = if ipsum { dolor } else { sit };\n+}\n+```\n+\n+#### `Off`:\n+When `use_small_heuristics` is set to `Off`, the granular width settings are functionally disabled and ignored. See the documentation for the respective width config options for specifics. \n+\n+```rust\n+enum Lorem {\n+    Ipsum,\n+    Dolor(bool),\n+    Sit {\n+        amet: Consectetur,\n+        adipiscing: Elit,\n+    },\n+}\n+\n+fn main() {\n+    lorem(\"lorem\", \"ipsum\", \"dolor\", \"sit\", \"amet\", \"consectetur\", \"adipiscing\");\n+\n+    let lorem = Lorem {\n+        ipsum: dolor,\n+        sit: amet,\n+    };\n+\n+    let lorem = if ipsum {\n+        dolor\n+    } else {\n+        sit\n+    };\n+}\n+```\n+\n+#### `Max`:\n+When `use_small_heuristics` is set to `Max`, then each granular width setting is set to the same value as `max_width`.\n+\n+So if `max_width` is set to `200`, then all the width settings are also set to `200`.\n+* `fn_call_width=200`\n+* `attr_fn_like_width=200`\n+* `struct_lit_width=200`\n+* `struct_variant_width=200`\n+* `array_width=200`\n+* `chain_width=200`\n+* `single_line_if_else_max_width=200`\n+\n+```rust\n+enum Lorem {\n+    Ipsum,\n+    Dolor(bool),\n+    Sit { amet: Consectetur, adipiscing: Elit },\n+}\n+\n+fn main() {\n+    lorem(\"lorem\", \"ipsum\", \"dolor\", \"sit\", \"amet\", \"consectetur\", \"adipiscing\");\n+\n+    let lorem = Lorem { ipsum: dolor, sit: amet };\n+\n+    let lorem = if ipsum { dolor } else { sit };\n+}\n+```\n+\n+\n+See also:\n+* [`max_width`](#max_width)\n+* [`fn_call_width`](#fn_call_width)\n+* [`attr_fn_like_width`](#attr_fn_like_width)\n+* [`struct_lit_width`](#struct_lit_width)\n+* [`struct_variant_width`](#struct_variant_width)\n+* [`array_width`](#array_width)\n+* [`chain_width`](#chain_width)\n+* [`single_line_if_else_max_width`](#single_line_if_else_max_width)\n+\n+## `use_try_shorthand`\n+\n+Replace uses of the try! macro by the ? shorthand\n+\n+- **Default value**: `false`\n+- **Possible values**: `true`, `false`\n+- **Stable**: Yes\n+\n+#### `false` (default):\n+\n+```rust\n+fn main() {\n+    let lorem = try!(ipsum.map(|dolor| dolor.sit()));\n+}\n+```\n+\n+#### `true`:\n+\n+```rust\n+fn main() {\n+    let lorem = ipsum.map(|dolor| dolor.sit())?;\n+}\n+```\n+\n+## `version`\n+\n+Which version of the formatting rules to use. `Version::One` is backwards-compatible\n+with Rustfmt 1.0. Other versions are only backwards compatible within a major\n+version number.\n+\n+- **Default value**: `One`\n+- **Possible values**: `One`, `Two`\n+- **Stable**: No (tracking issue: #3383)\n+\n+### Example\n+\n+```toml\n+version = \"Two\"\n+```\n+\n+## `where_single_line`\n+\n+Forces the `where` clause to be laid out on a single line.\n+\n+- **Default value**: `false`\n+- **Possible values**: `true`, `false`\n+- **Stable**: No (tracking issue: #3359)\n+\n+#### `false` (default):\n+\n+```rust\n+impl<T> Lorem for T\n+where\n+    Option<T>: Ipsum,\n+{\n+    // body\n+}\n+```\n+\n+#### `true`:\n+\n+```rust\n+impl<T> Lorem for T\n+where Option<T>: Ipsum\n+{\n+    // body\n+}\n+```\n+\n+See also [`brace_style`](#brace_style), [`control_brace_style`](#control_brace_style).\n+\n+\n+## `wrap_comments`\n+\n+Break comments to fit on the line\n+\n+- **Default value**: `false`\n+- **Possible values**: `true`, `false`\n+- **Stable**: No (tracking issue: #3347)\n+\n+#### `false` (default):\n+\n+```rust\n+// Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.\n+```\n+\n+#### `true`:\n+\n+```rust\n+// Lorem ipsum dolor sit amet, consectetur adipiscing elit,\n+// sed do eiusmod tempor incididunt ut labore et dolore\n+// magna aliqua. Ut enim ad minim veniam, quis nostrud\n+// exercitation ullamco laboris nisi ut aliquip ex ea\n+// commodo consequat.\n+```\n+\n+# Internal Options\n+\n+## `emit_mode`\n+\n+Internal option\n+\n+## `make_backup`\n+\n+Internal option, use `--backup`\n+\n+## `print_misformatted_file_names`\n+\n+Internal option, use `-l` or `--files-with-diff`"}, {"sha": "131f38dd06a2b74031117e4f692cf5edd3d86050", "filename": "src/tools/rustfmt/Contributing.md", "status": "added", "additions": 251, "deletions": 0, "changes": 251, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2FContributing.md", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2FContributing.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2FContributing.md?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782", "patch": "@@ -0,0 +1,251 @@\n+# Contributing\n+\n+There are many ways to contribute to Rustfmt. This document lays out what they\n+are and has information on how to get started. If you have any questions about\n+contributing or need help with anything, please ask in the WG-Rustfmt channel\n+on [Discord](https://discordapp.com/invite/rust-lang). Feel free to also ask questions\n+on issues, or file new issues specifically to get help.\n+\n+All contributors are expected to follow our [Code of\n+Conduct](CODE_OF_CONDUCT.md).\n+\n+## Test and file issues\n+\n+It would be really useful to have people use rustfmt on their projects and file\n+issues where it does something you don't expect.\n+\n+\n+## Create test cases\n+\n+Having a strong test suite for a tool like this is essential. It is very easy\n+to create regressions. Any tests you can add are very much appreciated.\n+\n+The tests can be run with `cargo test`. This does a number of things:\n+* runs the unit tests for a number of internal functions;\n+* makes sure that rustfmt run on every file in `./tests/source/` is equal to its\n+  associated file in `./tests/target/`;\n+* runs idempotence tests on the files in `./tests/target/`. These files should\n+  not be changed by rustfmt;\n+* checks that rustfmt's code is not changed by running on itself. This ensures\n+  that the project bootstraps.\n+\n+Creating a test is as easy as creating a new file in `./tests/source/` and an\n+equally named one in `./tests/target/`. If it is only required that rustfmt\n+leaves a piece of code unformatted, it may suffice to only create a target file.\n+\n+Whenever there's a discrepancy between the expected output when running tests, a\n+colourised diff will be printed so that the offending line(s) can quickly be\n+identified.\n+\n+Without explicit settings, the tests will be run using rustfmt's default\n+configuration. It is possible to run a test using non-default settings in several \n+ways. Firstly, you can include configuration parameters in comments at the top\n+of the file. For example: to use 3 spaces per tab, start your test with\n+`// rustfmt-tab_spaces: 3`. Just remember that the comment is part of the input,\n+so include in both the source and target files! It is also possible to\n+explicitly specify the name of the expected output file in the target directory.\n+Use `// rustfmt-target: filename.rs` for this. You can also specify a custom\n+configuration by using the `rustfmt-config` directive. Rustfmt will then use\n+that toml file located in `./tests/config/` for its configuration. Including\n+`// rustfmt-config: small_tabs.toml` will run your test with the configuration\n+file found at `./tests/config/small_tabs.toml`. The final option is used when the\n+test source file contains no configuration parameter comments. In this case, the\n+test harness looks for a configuration file with the same filename as the test\n+file in the `./tests/config/` directory, so a test source file named `test-indent.rs`\n+would need a configuration file named `test-indent.toml` in that directory. As an\n+example, the `issue-1111.rs` test file is configured by the file\n+`./tests/config/issue-1111.toml`.\n+\n+## Debugging\n+\n+Some `rewrite_*` methods use the `debug!` macro for printing useful information.\n+These messages can be printed by using the environment variable `RUST_LOG=rustfmt=DEBUG`.\n+These traces can be helpful in understanding which part of the code was used\n+and get a better grasp on the execution flow.\n+\n+## Hack!\n+\n+Here are some [good starting issues](https://github.com/rust-lang/rustfmt/issues?q=is%3Aopen+is%3Aissue+label%3Agood-first-issue).\n+\n+If you've found areas which need polish and don't have issues, please submit a\n+PR, don't feel there needs to be an issue.\n+\n+\n+### Guidelines\n+\n+Rustfmt bootstraps, that is part of its test suite is running itself on its\n+source code. So, basically, the only style guideline is that you must pass the\n+tests. That ensures that the Rustfmt source code adheres to our own conventions.\n+\n+Talking of tests, if you add a new feature or fix a bug, please also add a test.\n+It's really easy, see above for details. Please run `cargo test` before\n+submitting a PR to ensure your patch passes all tests, it's pretty quick.\n+\n+Rustfmt is post-1.0 and within major version releases we strive for backwards\n+compatibility (at least when using the default options). That means any code\n+which changes Rustfmt's output must be guarded by either an option or a version\n+check. The latter is implemented as an option called `option`. See the section on\n+[configuration](#Configuration) below.\n+\n+Please try to avoid leaving `TODO`s in the code. There are a few around, but I\n+wish there weren't. You can leave `FIXME`s, preferably with an issue number.\n+\n+\n+### Version-gate formatting changes\n+\n+A change that introduces a different code-formatting should be gated on the\n+`version` configuration. This is to ensure the formatting of the current major\n+release is preserved, while allowing fixes to be implemented for the next\n+release.\n+\n+This is done by conditionally guarding the change like so:\n+\n+```rust\n+if config.version() == Version::One { // if the current major release is 1.x\n+    // current formatting\n+} else {\n+    // new formatting\n+}\n+```\n+\n+This allows the user to apply the next formatting explicitly via the\n+configuration, while being stable by default.\n+\n+When the next major release is done, the code block of the previous formatting\n+can be deleted, e.g., the first block in the example above when going from `1.x`\n+to `2.x`.\n+\n+| Note: Only formatting changes with default options need to be gated. |\n+| --- |\n+\n+### A quick tour of Rustfmt\n+\n+Rustfmt is basically a pretty printer - that is, its mode of operation is to\n+take an AST (abstract syntax tree) and print it in a nice way (including staying\n+under the maximum permitted width for a line). In order to get that AST, we\n+first have to parse the source text, we use the Rust compiler's parser to do\n+that (see [src/lib.rs](src/lib.rs)). We shy away from doing anything too fancy, such as\n+algebraic approaches to pretty printing, instead relying on an heuristic\n+approach, 'manually' crafting a string for each AST node. This results in quite\n+a lot of code, but it is relatively simple.\n+\n+The AST is a tree view of source code. It carries all the semantic information\n+about the code, but not all of the syntax. In particular, we lose white space\n+and comments (although doc comments are preserved). Rustfmt uses a view of the\n+AST before macros are expanded, so there are still macro uses in the code. The\n+arguments to macros are not an AST, but raw tokens - this makes them harder to\n+format.\n+\n+There are different nodes for every kind of item and expression in Rust. For\n+more details see the source code in the compiler -\n+[ast.rs](https://dxr.mozilla.org/rust/source/src/libsyntax/ast.rs) - and/or the\n+[docs](https://doc.rust-lang.org/nightly/nightly-rustc/syntax/ast/index.html).\n+\n+Many nodes in the AST (but not all, annoyingly) have a `Span`. A `Span` is a\n+range in the source code, it can easily be converted to a snippet of source\n+text. When the AST does not contain enough information for us, we rely heavily\n+on `Span`s. For example, we can look between spans to try and find comments, or\n+parse a snippet to see how the user wrote their source code.\n+\n+The downside of using the AST is that we miss some information - primarily white\n+space and comments. White space is sometimes significant, although mostly we\n+want to ignore it and make our own. We strive to reproduce all comments, but\n+this is sometimes difficult. The crufty corners of Rustfmt are where we hack\n+around the absence of comments in the AST and try to recreate them as best we\n+can.\n+\n+Our primary tool here is to look between spans for text we've missed. For\n+example, in a function call `foo(a, b)`, we have spans for `a` and `b`, in this\n+case, there is only a comma and a single space between the end of `a` and the\n+start of `b`, so there is nothing much to do. But if we look at\n+`foo(a /* a comment */, b)`, then between `a` and `b` we find the comment.\n+\n+At a higher level, Rustfmt has machinery so that we account for text between\n+'top level' items. Then we can reproduce that text pretty much verbatim. We only\n+count spans we actually reformat, so if we can't format a span it is not missed\n+completely but is reproduced in the output without being formatted. This is\n+mostly handled in [src/missed_spans.rs](src/missed_spans.rs). See also `FmtVisitor::last_pos` in\n+[src/visitor.rs](src/visitor.rs).\n+\n+\n+#### Some important elements\n+\n+At the highest level, Rustfmt uses a `Visitor` implementation called `FmtVisitor`\n+to walk the AST. This is in [src/visitor.rs](src/visitor.rs). This is really just used to walk\n+items, rather than the bodies of functions. We also cover macros and attributes\n+here. Most methods of the visitor call out to `Rewrite` implementations that\n+then walk their own children.\n+\n+The `Rewrite` trait is defined in [src/rewrite.rs](src/rewrite.rs). It is implemented for many\n+things that can be rewritten, mostly AST nodes. It has a single function,\n+`rewrite`, which is called to rewrite `self` into an `Option<String>`. The\n+arguments are `width` which is the horizontal space we write into and `offset`\n+which is how much we are currently indented from the lhs of the page. We also\n+take a context which contains information used for parsing, the current block\n+indent, and a configuration (see below).\n+\n+##### Rewrite and Indent\n+\n+To understand the indents, consider\n+\n+```\n+impl Foo {\n+    fn foo(...) {\n+        bar(argument_one,\n+            baz());\n+    }\n+}\n+```\n+\n+When formatting the `bar` call we will format the arguments in order, after the\n+first one we know we are working on multiple lines (imagine it is longer than\n+written). So, when we come to the second argument, the indent we pass to\n+`rewrite` is 12, which puts us under the first argument. The current block\n+indent (stored in the context) is 8. The former is used for visual indenting\n+(when objects are vertically aligned with some marker), the latter is used for\n+block indenting (when objects are tabbed in from the lhs). The width available\n+for `baz()` will be the maximum width, minus the space used for indenting, minus\n+the space used for the `);`. (Note that actual argument formatting does not\n+quite work like this, but it's close enough).\n+\n+The `rewrite` function returns an `Option` - either we successfully rewrite and\n+return the rewritten string for the caller to use, or we fail to rewrite and\n+return `None`. This could be because Rustfmt encounters something it doesn't\n+know how to reformat, but more often it is because Rustfmt can't fit the item\n+into the required width. How to handle this is up to the caller. Often the\n+caller just gives up, ultimately relying on the missed spans system to paste in\n+the un-formatted source. A better solution (although not performed in many\n+places) is for the caller to shuffle around some of its other items to make\n+more width, then call the function again with more space.\n+\n+Since it is common for callers to bail out when a callee fails, we often use a\n+`?` operator to make this pattern more succinct.\n+\n+One way we might find out that we don't have enough space is when computing how much\n+space we have. Something like `available_space = budget - overhead`. Since\n+widths are unsized integers, this would cause underflow. Therefore we use\n+checked subtraction: `available_space = budget.checked_sub(overhead)?`.\n+`checked_sub` returns an `Option`, and if we would underflow `?` returns\n+`None`, otherwise, we proceed with the computed space.\n+\n+##### Rewrite of list-like expressions\n+\n+Much of the syntax in Rust is lists: lists of arguments, lists of fields, lists of\n+array elements, etc. We have some generic code to handle lists, including how to\n+space them in horizontal and vertical space, indentation, comments between\n+items, trailing separators, etc. However, since there are so many options, the\n+code is a bit complex. Look in [src/lists.rs](src/lists.rs). `write_list` is the key function,\n+and `ListFormatting` the key structure for configuration. You'll need to make a\n+`ListItems` for input, this is usually done using `itemize_list`.\n+\n+##### Configuration\n+\n+Rustfmt strives to be highly configurable. Often the first part of a patch is\n+creating a configuration option for the feature you are implementing. All\n+handling of configuration options is done in [src/config/mod.rs](src/config/mod.rs). Look for the\n+`create_config!` macro at the end of the file for all the options. The rest of\n+the file defines a bunch of enums used for options, and the machinery to produce\n+the config struct and parse a config file, etc. Checking an option is done by\n+accessing the correct field on the config struct, e.g., `config.max_width()`. Most\n+functions have a `Config`, or one can be accessed via a visitor or context of\n+some kind."}, {"sha": "00a7652aee0dcb10286f7ea9de0cfedfc6335e6c", "filename": "src/tools/rustfmt/Design.md", "status": "added", "additions": 184, "deletions": 0, "changes": 184, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2FDesign.md", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2FDesign.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2FDesign.md?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782", "patch": "@@ -0,0 +1,184 @@\n+# Some thoughts on the design of rustfmt\n+\n+## Use cases\n+\n+A formatting tool can be used in different ways and the different use cases can\n+affect the design of the tool. The use cases I'm particularly concerned with are:\n+\n+* running on a whole repo before check-in\n+  - in particular, to replace the `make tidy` pass on the Rust distro\n+* running on code from another project that you are adding to your own\n+* using for mass changes in code style over a project\n+\n+Some valid use cases for a formatting tool which I am explicitly not trying to\n+address (although it would be nice, if possible):\n+\n+* running 'as you type' in an IDE\n+* running on arbitrary snippets of code\n+* running on Rust-like code, specifically code which doesn't parse\n+* use as a pretty printer inside the compiler\n+* refactoring\n+* formatting totally unformatted source code\n+\n+\n+## Scope and vision\n+\n+I do not subscribe to the notion that a formatting tool should only change\n+whitespace. I believe that we should semantics preserving, but not necessarily\n+syntax preserving, i.e., we can change the AST of a program.\n+\n+I.e., we might change glob imports to list or single imports, re-order imports,\n+move bounds to where clauses, combine multiple impls into a single impl, etc.\n+\n+However, we will not change the names of variables or make any changes which\n+*could* change the semantics. To be ever so slightly formal, we might imagine\n+a compilers high level intermediate representation, we should strive to only\n+make changes which do not change the HIR, even if they do change the AST.\n+\n+I would like to be able to output refactoring scripts for making deeper changes\n+though. (E.g., renaming variables to satisfy our style guidelines).\n+\n+My long term goal is that all style lints can be moved from the compiler to\n+rustfmt and, as well as warning, can either fix problems or emit refactoring\n+scripts to do so.\n+\n+### Configurability\n+\n+I believe reformatting should be configurable to some extent. We should read in\n+options from a configuration file and reformat accordingly. We should supply at\n+least a config file which matches the Rust style guidelines.\n+\n+There should be multiple modes for running the tool. As well as simply replacing\n+each file, we should be able to show the user a list of the changes we would\n+make, or show a list of violations without corrections (the difference being\n+that there are multiple ways to satisfy a given set of style guidelines, and we\n+should distinguish violations from deviations from our own model).\n+\n+\n+## Implementation philosophy\n+\n+Some details of the philosophy behind the implementation.\n+\n+\n+### Operate on the AST\n+\n+A reformatting tool can be based on either the AST or a token stream (in Rust\n+this is actually a stream of token trees, but it's not a fundamental difference).\n+There are pros and cons to the two approaches. I have chosen to use the AST\n+approach. The primary reasons are that it allows us to do more sophisticated\n+manipulations, rather than just change whitespace, and it gives us more context\n+when making those changes.\n+\n+The advantage of the tokens approach is that you can operate on non-parsable\n+code. I don't care too much about that, it would be nice, but I think being able\n+to perform sophisticated transformations is more important. In the future, I hope to\n+(optionally) be able to use type information for informing reformatting too. One\n+specific case of unparsable code is macros. Using tokens is certainly easier\n+here, but I believe it is perfectly solvable with the AST approach. At the limit,\n+we can operate on just tokens in the macro case.\n+\n+I believe that there is not in fact that much difference between the two\n+approaches. Due to imperfect span information, under the AST approach, we\n+sometimes are reduced to examining tokens or do some re-lexing of our own. Under\n+the tokens approach, you need to implement your own (much simpler) parser. I\n+believe that as the tool gets more sophisticated, you end up doing more at the\n+token-level, or having an increasingly sophisticated parser, until at the limit\n+you have the same tool.\n+\n+However, I believe starting from the AST gets you more quickly to a usable and\n+useful tool.\n+\n+\n+### Heuristic rather than algorithmic\n+\n+Many formatting tools use a very general algorithmic or even algebraic tool for\n+pretty printing. This results in very elegant code, but I believe does not give\n+the best results. I prefer a more ad hoc approach where each expression/item is\n+formatted using custom rules. We hopefully don't end up with too much code due\n+to good old fashioned abstraction and code sharing. This will give a bigger code\n+base, but hopefully a better result.\n+\n+It also means that there will be some cases we can't format and we have to give\n+up. I think that is OK. Hopefully, they are rare enough that manually fixing them\n+is not painful. Better to have a tool that gives great code in 99% of cases and\n+fails in 1% than a tool which gives 50% great code and 50% ugly code, but never\n+fails.\n+\n+\n+### Incremental development\n+\n+I want rustfmt to be useful as soon as possible and to always be useful. I\n+specifically don't want to have to wait for a feature (or worse, the whole tool)\n+to be perfect before it is useful. The main ways this is achieved is to output\n+the source code where we can't yet reformat, be able to turn off new features\n+until they are ready, and the 'do no harm' principle (see next section).\n+\n+\n+### First, do no harm\n+\n+Until rustfmt is perfect, there will always be a trade-off between doing more and\n+doing existing things well. I want to err on the side of the latter.\n+Specifically, rustfmt should never take OK code and make it look worse. If we\n+can't make it better, we should leave it as is. That might mean being less\n+aggressive than we like or using configurability.\n+\n+\n+### Use the source code as guidance\n+\n+There are often multiple ways to format code and satisfy standards. Where this\n+is the case, we should use the source code as a hint for reformatting.\n+Furthermore, where the code has been formatted in a particular way that satisfies\n+the coding standard, it should not be changed (this is sometimes not possible or\n+not worthwhile due to uniformity being desirable, but it is a useful goal).\n+\n+\n+### Architecture details\n+\n+We use the AST from [syntex_syntax], an export of rustc's libsyntax. We use\n+syntex_syntax's visit module to walk the AST to find starting points for\n+reformatting. Eventually, we should reformat everything and we shouldn't need\n+the visit module. We keep track of the last formatted position in the code, and\n+when we reformat the next piece of code we make sure to output the span for all\n+the code in between (handled by missed_spans.rs).\n+\n+[syntex_syntax]: https://crates.io/crates/syntex_syntax\n+\n+We read in formatting configuration from a `rustfmt.toml` file if there is one.\n+The options and their defaults are defined in `config.rs`. A `Config` object is\n+passed throughout the formatting code, and each formatting routine looks there\n+for its configuration.\n+\n+Our visitor keeps track of the desired current indent due to blocks (\n+`block_indent`). Each `visit_*` method reformats code according to this indent,\n+`config.comment_width()` and `config.max_width()`. Most reformatting that is done \n+in the `visit_*` methods is a bit hacky and is meant to be temporary until it can \n+be done properly.\n+\n+There are a bunch of methods called `rewrite_*`. They do the bulk of the\n+reformatting. These take the AST node to be reformatted (this may not literally\n+be an AST node from syntex_syntax: there might be multiple parameters\n+describing a logical node), the current indent, and the current width budget.\n+They return a `String` (or sometimes an `Option<String>`) which formats the\n+code in the box given by the indent and width budget. If the method fails, it\n+returns `None` and the calling method then has to fallback in some way to give\n+the callee more space.\n+\n+So, in summary, to format a node, we calculate the width budget and then walk down\n+the tree from the node. At a leaf, we generate an actual string and then unwind,\n+combining these strings as we go back up the tree.\n+\n+For example, consider a method definition:\n+\n+```\n+    fn foo(a: A, b: B) {\n+        ...\n+    }\n+```\n+\n+We start at indent 4, the rewrite function for the whole function knows it must\n+write `fn foo(` before the arguments and `) {` after them, assuming the max width\n+is 100, it thus asks the rewrite argument list function to rewrite with an indent\n+of 11 and in a width of 86. Assuming that is possible (obviously in this case),\n+it returns a string for the arguments and it can make a string for the function\n+header. If the arguments couldn't be fitted in that space, we might try to\n+fallback to a hanging indent, so we try again with indent 8 and width 89."}, {"sha": "212ba1f3184810909ef2186137ec0d9a6aea4a6b", "filename": "src/tools/rustfmt/LICENSE-APACHE", "status": "added", "additions": 201, "deletions": 0, "changes": 201, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2FLICENSE-APACHE", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2FLICENSE-APACHE", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2FLICENSE-APACHE?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782", "patch": "@@ -0,0 +1,201 @@\n+                              Apache License\n+                        Version 2.0, January 2004\n+                     http://www.apache.org/licenses/\n+\n+TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION\n+\n+1. Definitions.\n+\n+   \"License\" shall mean the terms and conditions for use, reproduction,\n+   and distribution as defined by Sections 1 through 9 of this document.\n+\n+   \"Licensor\" shall mean the copyright owner or entity authorized by\n+   the copyright owner that is granting the License.\n+\n+   \"Legal Entity\" shall mean the union of the acting entity and all\n+   other entities that control, are controlled by, or are under common\n+   control with that entity. For the purposes of this definition,\n+   \"control\" means (i) the power, direct or indirect, to cause the\n+   direction or management of such entity, whether by contract or\n+   otherwise, or (ii) ownership of fifty percent (50%) or more of the\n+   outstanding shares, or (iii) beneficial ownership of such entity.\n+\n+   \"You\" (or \"Your\") shall mean an individual or Legal Entity\n+   exercising permissions granted by this License.\n+\n+   \"Source\" form shall mean the preferred form for making modifications,\n+   including but not limited to software source code, documentation\n+   source, and configuration files.\n+\n+   \"Object\" form shall mean any form resulting from mechanical\n+   transformation or translation of a Source form, including but\n+   not limited to compiled object code, generated documentation,\n+   and conversions to other media types.\n+\n+   \"Work\" shall mean the work of authorship, whether in Source or\n+   Object form, made available under the License, as indicated by a\n+   copyright notice that is included in or attached to the work\n+   (an example is provided in the Appendix below).\n+\n+   \"Derivative Works\" shall mean any work, whether in Source or Object\n+   form, that is based on (or derived from) the Work and for which the\n+   editorial revisions, annotations, elaborations, or other modifications\n+   represent, as a whole, an original work of authorship. For the purposes\n+   of this License, Derivative Works shall not include works that remain\n+   separable from, or merely link (or bind by name) to the interfaces of,\n+   the Work and Derivative Works thereof.\n+\n+   \"Contribution\" shall mean any work of authorship, including\n+   the original version of the Work and any modifications or additions\n+   to that Work or Derivative Works thereof, that is intentionally\n+   submitted to Licensor for inclusion in the Work by the copyright owner\n+   or by an individual or Legal Entity authorized to submit on behalf of\n+   the copyright owner. For the purposes of this definition, \"submitted\"\n+   means any form of electronic, verbal, or written communication sent\n+   to the Licensor or its representatives, including but not limited to\n+   communication on electronic mailing lists, source code control systems,\n+   and issue tracking systems that are managed by, or on behalf of, the\n+   Licensor for the purpose of discussing and improving the Work, but\n+   excluding communication that is conspicuously marked or otherwise\n+   designated in writing by the copyright owner as \"Not a Contribution.\"\n+\n+   \"Contributor\" shall mean Licensor and any individual or Legal Entity\n+   on behalf of whom a Contribution has been received by Licensor and\n+   subsequently incorporated within the Work.\n+\n+2. Grant of Copyright License. Subject to the terms and conditions of\n+   this License, each Contributor hereby grants to You a perpetual,\n+   worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n+   copyright license to reproduce, prepare Derivative Works of,\n+   publicly display, publicly perform, sublicense, and distribute the\n+   Work and such Derivative Works in Source or Object form.\n+\n+3. Grant of Patent License. Subject to the terms and conditions of\n+   this License, each Contributor hereby grants to You a perpetual,\n+   worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n+   (except as stated in this section) patent license to make, have made,\n+   use, offer to sell, sell, import, and otherwise transfer the Work,\n+   where such license applies only to those patent claims licensable\n+   by such Contributor that are necessarily infringed by their\n+   Contribution(s) alone or by combination of their Contribution(s)\n+   with the Work to which such Contribution(s) was submitted. If You\n+   institute patent litigation against any entity (including a\n+   cross-claim or counterclaim in a lawsuit) alleging that the Work\n+   or a Contribution incorporated within the Work constitutes direct\n+   or contributory patent infringement, then any patent licenses\n+   granted to You under this License for that Work shall terminate\n+   as of the date such litigation is filed.\n+\n+4. Redistribution. You may reproduce and distribute copies of the\n+   Work or Derivative Works thereof in any medium, with or without\n+   modifications, and in Source or Object form, provided that You\n+   meet the following conditions:\n+\n+   (a) You must give any other recipients of the Work or\n+       Derivative Works a copy of this License; and\n+\n+   (b) You must cause any modified files to carry prominent notices\n+       stating that You changed the files; and\n+\n+   (c) You must retain, in the Source form of any Derivative Works\n+       that You distribute, all copyright, patent, trademark, and\n+       attribution notices from the Source form of the Work,\n+       excluding those notices that do not pertain to any part of\n+       the Derivative Works; and\n+\n+   (d) If the Work includes a \"NOTICE\" text file as part of its\n+       distribution, then any Derivative Works that You distribute must\n+       include a readable copy of the attribution notices contained\n+       within such NOTICE file, excluding those notices that do not\n+       pertain to any part of the Derivative Works, in at least one\n+       of the following places: within a NOTICE text file distributed\n+       as part of the Derivative Works; within the Source form or\n+       documentation, if provided along with the Derivative Works; or,\n+       within a display generated by the Derivative Works, if and\n+       wherever such third-party notices normally appear. The contents\n+       of the NOTICE file are for informational purposes only and\n+       do not modify the License. You may add Your own attribution\n+       notices within Derivative Works that You distribute, alongside\n+       or as an addendum to the NOTICE text from the Work, provided\n+       that such additional attribution notices cannot be construed\n+       as modifying the License.\n+\n+   You may add Your own copyright statement to Your modifications and\n+   may provide additional or different license terms and conditions\n+   for use, reproduction, or distribution of Your modifications, or\n+   for any such Derivative Works as a whole, provided Your use,\n+   reproduction, and distribution of the Work otherwise complies with\n+   the conditions stated in this License.\n+\n+5. Submission of Contributions. Unless You explicitly state otherwise,\n+   any Contribution intentionally submitted for inclusion in the Work\n+   by You to the Licensor shall be under the terms and conditions of\n+   this License, without any additional terms or conditions.\n+   Notwithstanding the above, nothing herein shall supersede or modify\n+   the terms of any separate license agreement you may have executed\n+   with Licensor regarding such Contributions.\n+\n+6. Trademarks. This License does not grant permission to use the trade\n+   names, trademarks, service marks, or product names of the Licensor,\n+   except as required for reasonable and customary use in describing the\n+   origin of the Work and reproducing the content of the NOTICE file.\n+\n+7. Disclaimer of Warranty. Unless required by applicable law or\n+   agreed to in writing, Licensor provides the Work (and each\n+   Contributor provides its Contributions) on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n+   implied, including, without limitation, any warranties or conditions\n+   of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A\n+   PARTICULAR PURPOSE. You are solely responsible for determining the\n+   appropriateness of using or redistributing the Work and assume any\n+   risks associated with Your exercise of permissions under this License.\n+\n+8. Limitation of Liability. In no event and under no legal theory,\n+   whether in tort (including negligence), contract, or otherwise,\n+   unless required by applicable law (such as deliberate and grossly\n+   negligent acts) or agreed to in writing, shall any Contributor be\n+   liable to You for damages, including any direct, indirect, special,\n+   incidental, or consequential damages of any character arising as a\n+   result of this License or out of the use or inability to use the\n+   Work (including but not limited to damages for loss of goodwill,\n+   work stoppage, computer failure or malfunction, or any and all\n+   other commercial damages or losses), even if such Contributor\n+   has been advised of the possibility of such damages.\n+\n+9. Accepting Warranty or Additional Liability. While redistributing\n+   the Work or Derivative Works thereof, You may choose to offer,\n+   and charge a fee for, acceptance of support, warranty, indemnity,\n+   or other liability obligations and/or rights consistent with this\n+   License. However, in accepting such obligations, You may act only\n+   on Your own behalf and on Your sole responsibility, not on behalf\n+   of any other Contributor, and only if You agree to indemnify,\n+   defend, and hold each Contributor harmless for any liability\n+   incurred by, or claims asserted against, such Contributor by reason\n+   of your accepting any such warranty or additional liability.\n+\n+END OF TERMS AND CONDITIONS\n+\n+APPENDIX: How to apply the Apache License to your work.\n+\n+   To apply the Apache License to your work, attach the following\n+   boilerplate notice, with the fields enclosed by brackets \"[]\"\n+   replaced with your own identifying information. (Don't include\n+   the brackets!)  The text should be enclosed in the appropriate\n+   comment syntax for the file format. We also recommend that a\n+   file or class name and description of purpose be included on the\n+   same \"printed page\" as the copyright notice for easier\n+   identification within third-party archives.\n+\n+Copyright 2016-2021 The Rust Project Developers\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+\thttp://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License."}, {"sha": "1baa137f605b700051933fb00de4ab5c73977cde", "filename": "src/tools/rustfmt/LICENSE-MIT", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2FLICENSE-MIT", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2FLICENSE-MIT", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2FLICENSE-MIT?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782", "patch": "@@ -0,0 +1,25 @@\n+Copyright (c) 2016-2021 The Rust Project Developers\n+\n+Permission is hereby granted, free of charge, to any\n+person obtaining a copy of this software and associated\n+documentation files (the \"Software\"), to deal in the\n+Software without restriction, including without\n+limitation the rights to use, copy, modify, merge,\n+publish, distribute, sublicense, and/or sell copies of\n+the Software, and to permit persons to whom the Software\n+is furnished to do so, subject to the following\n+conditions:\n+\n+The above copyright notice and this permission notice\n+shall be included in all copies or substantial portions\n+of the Software.\n+\n+THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF\n+ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED\n+TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n+PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT\n+SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\n+CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n+OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR\n+IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n+DEALINGS IN THE SOFTWARE."}, {"sha": "597dd1205643db6f95ecde23e32a992574d623f7", "filename": "src/tools/rustfmt/Makefile.toml", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2FMakefile.toml", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2FMakefile.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2FMakefile.toml?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782", "patch": "@@ -0,0 +1,71 @@\n+[env]\n+CFG_RELEASE = { value = \"${CARGO_MAKE_RUST_VERSION}\", condition = { env_not_set = [\"CFG_RELEASE\"] } }\n+CFG_RELEASE_CHANNEL = { value = \"${CARGO_MAKE_RUST_CHANNEL}\", condition = { env_not_set = [\"CFG_RELEASE_CHANNEL\"] } }\n+\n+[tasks.build-bin]\n+command = \"cargo\"\n+args = [\n+  \"build\",\n+  \"--bin\",\n+  \"rustfmt\",\n+  \"--bin\",\n+  \"cargo-fmt\",\n+]\n+\n+[tasks.build-bins]\n+command = \"cargo\"\n+args = [\n+  \"build\",\n+  \"--bins\",\n+]\n+\n+[tasks.install]\n+command = \"cargo\"\n+args = [\n+  \"install\",\n+  \"--path\",\n+  \".\",\n+  \"--force\",\n+  \"--locked\", # Respect Cargo.lock\n+]\n+\n+[tasks.release]\n+command = \"cargo\"\n+args = [\n+  \"build\",\n+\t\"--release\",\n+]\n+\n+[tasks.test]\n+command = \"cargo\"\n+args = [\n+  \"test\",\n+]\n+\n+[tasks.test-all]\n+dependencies = [\"build-bin\"]\n+run_task = { name = [\"test\", \"test-ignored\"] }\n+\n+[tasks.test-ignored]\n+command = \"cargo\"\n+args = [\n+  \"test\",\n+\t\"--\",\n+\t\"--ignored\",\n+]\n+\n+[tasks.b]\n+alias = \"build\"\n+\n+[tasks.bb]\n+alias = \"build-bin\"\n+\n+[tasks.bins]\n+alias = \"build-bins\"\n+\n+[tasks.c]\n+alias = \"check\"\n+\n+[tasks.t]\n+alias = \"test\"\n+"}, {"sha": "9d86d52b122d8759dc0bbb3c4f7d258777ba853e", "filename": "src/tools/rustfmt/Processes.md", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2FProcesses.md", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2FProcesses.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2FProcesses.md?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782", "patch": "@@ -0,0 +1,57 @@\n+This document outlines processes regarding management of rustfmt.\n+\n+# Stabilising an Option\n+\n+In this Section, we describe how to stabilise an option of the rustfmt's configration.\n+\n+## Conditions\n+\n+- Is the default value correct ?\n+- The design and implementation of the option are sound and clean.\n+- The option is well tested, both in unit tests and, optimally, in real usage.\n+- There is no open bug about the option that prevents its use.\n+\n+## Steps\n+\n+Open a pull request that closes the tracking issue. The tracking issue is listed beside the option in `Configurations.md`.\n+\n+- Update the `Config` enum marking the option as stable.\n+- Update the the `Configuration.md` file marking the option as stable.\n+- Update `CHANGELOG.md` marking the option as stable.\n+\n+## After the stabilisation\n+\n+The option should remain backward-compatible with previous parameters of the option. For instance, if the option is an enum `enum Foo { Alice, Bob }` and the variant `Foo::Bob` is removed/renamed, existing use of the `Foo::Bob` variant should map to the new logic. Breaking changes can be applied under the condition they are version-gated.\n+\n+# Make a Release\n+\n+## 0. Update CHANGELOG.md\n+\n+## 1. Update Cargo.toml and Cargo.lock\n+\n+For example, 1.0.0 -> 1.0.1:\n+\n+```diff\n+-version = \"1.0.0\"\n++version = \"1.0.1\"\n+```\n+\n+## 2. Push the commit to the master branch\n+\n+E.g., https://github.com/rust-lang/rustfmt/commit/5274b49caa1a7db6ac10c76bf1a3d5710ccef569\n+\n+## 3. Create a release tag\n+\n+```sh\n+git tag -s v1.2.3 -m \"Release 1.2.3\"\n+```\n+\n+## 4. Publish to crates.io\n+\n+`cargo publish`\n+\n+## 5. Create a PR to rust-lang/rust to update the rustfmt submodule\n+\n+Note that if you are updating `rustc-ap-*` crates, then you need to update **every** submodules in the rust-lang/rust repository that depend on the crates to use the same version of those.\n+\n+As of 2019/05, there are two such crates: `rls` and `racer` (`racer` depends on `rustc-ap-syntax` and `rls` depends on `racer`, and `rls` is one of submodules of the rust-lang/rust repository)."}, {"sha": "7a97d31bab9c7ac70162cd1c066fa09ff14d2614", "filename": "src/tools/rustfmt/README.md", "status": "added", "additions": 234, "deletions": 0, "changes": 234, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2FREADME.md?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782", "patch": "@@ -0,0 +1,234 @@\n+# rustfmt [![Build Status](https://travis-ci.com/rust-lang/rustfmt.svg?branch=master)](https://travis-ci.com/rust-lang/rustfmt) [![Build Status](https://ci.appveyor.com/api/projects/status/github/rust-lang/rustfmt?svg=true)](https://ci.appveyor.com/project/rust-lang-libs/rustfmt) [![crates.io](https://img.shields.io/crates/v/rustfmt-nightly.svg)](https://crates.io/crates/rustfmt-nightly) [![Travis Configuration Status](https://img.shields.io/travis/davidalber/rustfmt-travis.svg?label=travis%20example)](https://travis-ci.org/davidalber/rustfmt-travis)\n+\n+A tool for formatting Rust code according to style guidelines.\n+\n+If you'd like to help out (and you should, it's a fun project!), see\n+[Contributing.md](Contributing.md) and our [Code of\n+Conduct](CODE_OF_CONDUCT.md).\n+\n+You can use rustfmt in Travis CI builds. We provide a minimal Travis CI\n+configuration (see [here](#checking-style-on-a-ci-server)) and verify its status\n+using another repository. The status of that repository's build is reported by\n+the \"travis example\" badge above.\n+\n+## Quick start\n+\n+You can run `rustfmt` with Rust 1.24 and above.\n+\n+### On the Stable toolchain\n+\n+To install:\n+\n+```sh\n+rustup component add rustfmt\n+```\n+\n+To run on a cargo project in the current working directory:\n+\n+```sh\n+cargo fmt\n+```\n+\n+### On the Nightly toolchain\n+\n+For the latest and greatest `rustfmt`, nightly is required.\n+\n+To install:\n+\n+```sh\n+rustup component add rustfmt --toolchain nightly\n+```\n+\n+To run on a cargo project in the current working directory:\n+\n+```sh\n+cargo +nightly fmt\n+```\n+\n+## Limitations\n+\n+Rustfmt tries to work on as much Rust code as possible, sometimes, the code\n+doesn't even need to compile! As we approach a 1.0 release we are also looking\n+to limit areas of instability; in particular, post-1.0, the formatting of most\n+code should not change as Rustfmt improves. However, there are some things that\n+Rustfmt can't do or can't do well (and thus where formatting might change\n+significantly, even post-1.0). We would like to reduce the list of limitations\n+over time.\n+\n+The following list enumerates areas where Rustfmt does not work or where the\n+stability guarantees do not apply (we don't make a distinction between the two\n+because in the future Rustfmt might work on code where it currently does not):\n+\n+* a program where any part of the program does not parse (parsing is an early\n+  stage of compilation and in Rust includes macro expansion).\n+* Macro declarations and uses (current status: some macro declarations and uses\n+  are formatted).\n+* Comments, including any AST node with a comment 'inside' (Rustfmt does not\n+  currently attempt to format comments, it does format code with comments inside, but that formatting may change in the future).\n+* Rust code in code blocks in comments.\n+* Any fragment of a program (i.e., stability guarantees only apply to whole\n+  programs, even where fragments of a program can be formatted today).\n+* Code containing non-ascii unicode characters (we believe Rustfmt mostly works\n+  here, but do not have the test coverage or experience to be 100% sure).\n+* Bugs in Rustfmt (like any software, Rustfmt has bugs, we do not consider bug\n+  fixes to break our stability guarantees).\n+\n+\n+## Installation\n+\n+```sh\n+rustup component add rustfmt\n+```\n+\n+## Installing from source\n+\n+To install from source (nightly required), first checkout to the tag or branch you want to install, then issue\n+\n+```sh\n+cargo install --path .\n+```\n+\n+This will install `rustfmt` in your `~/.cargo/bin`. Make sure to add `~/.cargo/bin` directory to\n+your PATH variable.\n+\n+\n+## Running\n+\n+You can run Rustfmt by just typing `rustfmt filename` if you used `cargo\n+install`. This runs rustfmt on the given file, if the file includes out of line\n+modules, then we reformat those too. So to run on a whole module or crate, you\n+just need to run on the root file (usually mod.rs or lib.rs). Rustfmt can also\n+read data from stdin. Alternatively, you can use `cargo fmt` to format all\n+binary and library targets of your crate.\n+\n+You can run `rustfmt --help` for information about available arguments.\n+\n+When running with `--check`, Rustfmt will exit with `0` if Rustfmt would not\n+make any formatting changes to the input, and `1` if Rustfmt would make changes.\n+In other modes, Rustfmt will exit with `1` if there was some error during\n+formatting (for example a parsing or internal error) and `0` if formatting\n+completed without error (whether or not changes were made).\n+\n+\n+\n+## Running Rustfmt from your editor\n+\n+* [Vim](https://github.com/rust-lang/rust.vim#formatting-with-rustfmt)\n+* [Emacs](https://github.com/rust-lang/rust-mode)\n+* [Sublime Text 3](https://packagecontrol.io/packages/RustFmt)\n+* [Atom](atom.md)\n+* Visual Studio Code using [vscode-rust](https://github.com/editor-rs/vscode-rust), [vsc-rustfmt](https://github.com/Connorcpu/vsc-rustfmt) or [rls_vscode](https://github.com/jonathandturner/rls_vscode) through RLS.\n+* [IntelliJ or CLion](intellij.md)\n+\n+\n+## Checking style on a CI server\n+\n+To keep your code base consistently formatted, it can be helpful to fail the CI build\n+when a pull request contains unformatted code. Using `--check` instructs\n+rustfmt to exit with an error code if the input is not formatted correctly.\n+It will also print any found differences. (Older versions of Rustfmt don't\n+support `--check`, use `--write-mode diff`).\n+\n+A minimal Travis setup could look like this (requires Rust 1.24.0 or greater):\n+\n+```yaml\n+language: rust\n+before_script:\n+- rustup component add rustfmt\n+script:\n+- cargo build\n+- cargo test\n+- cargo fmt --all -- --check\n+```\n+\n+See [this blog post](https://medium.com/@ag_dubs/enforcing-style-in-ci-for-rust-projects-18f6b09ec69d)\n+for more info.\n+\n+## How to build and test\n+\n+`cargo build` to build.\n+\n+`cargo test` to run all tests.\n+\n+To run rustfmt after this, use `cargo run --bin rustfmt -- filename`. See the\n+notes above on running rustfmt.\n+\n+\n+## Configuring Rustfmt\n+\n+Rustfmt is designed to be very configurable. You can create a TOML file called\n+`rustfmt.toml` or `.rustfmt.toml`, place it in the project or any other parent\n+directory and it will apply the options in that file. See `rustfmt\n+--help=config` for the options which are available, or if you prefer to see\n+visual style previews, [GitHub page](https://rust-lang.github.io/rustfmt/).\n+\n+By default, Rustfmt uses a style which conforms to the [Rust style guide][style\n+guide] that has been formalized through the [style RFC\n+process][fmt rfcs].\n+\n+Configuration options are either stable or unstable. Stable options can always\n+be used, while unstable ones are only available on a nightly toolchain, and opt-in.\n+See [GitHub page](https://rust-lang.github.io/rustfmt/) for details.\n+\n+### Rust's Editions\n+\n+Rustfmt is able to pick up the edition used by reading the `Cargo.toml` file if\n+executed through the Cargo's formatting tool `cargo fmt`. Otherwise, the edition\n+needs to be specified in `rustfmt.toml`, e.g., with `edition = \"2018\"`.\n+\n+## Tips\n+\n+* For things you do not want rustfmt to mangle, use `#[rustfmt::skip]`\n+* To prevent rustfmt from formatting a macro or an attribute,\n+  use `#[rustfmt::skip::macros(target_macro_name)]` or \n+  `#[rustfmt::skip::attributes(target_attribute_name)]`\n+\n+  Example:\n+\n+    ```rust\n+    #![rustfmt::skip::attributes(custom_attribute)]   \n+\n+    #[custom_attribute(formatting , here , should , be , Skipped)]\n+    #[rustfmt::skip::macros(html)]\n+    fn main() {\n+        let macro_result1 = html! { <div>\n+    Hello</div>\n+        }.to_string();\n+    ```\n+* When you run rustfmt, place a file named `rustfmt.toml` or `.rustfmt.toml` in\n+  target file directory or its parents to override the default settings of\n+  rustfmt. You can generate a file containing the default configuration with\n+  `rustfmt --print-config default rustfmt.toml` and customize as needed.\n+* After successful compilation, a `rustfmt` executable can be found in the\n+  target directory.\n+* If you're having issues compiling Rustfmt (or compile errors when trying to\n+  install), make sure you have the most recent version of Rust installed.\n+\n+* You can change the way rustfmt emits the changes with the --emit flag:\n+\n+  Example:\n+\n+  ```sh\n+  cargo fmt -- --emit files\n+  ```\n+\n+  Options:\n+\n+  | Flag |Description| Nightly Only |\n+  |:---:|:---:|:---:|\n+  | files | overwrites output to files | No |\n+  | stdout | writes output to stdout | No |\n+  | coverage | displays how much of the input file was processed | Yes |\n+  | checkstyle | emits in a checkstyle format | Yes |\n+  | json | emits diffs in a json format | Yes |\n+\n+## License\n+\n+Rustfmt is distributed under the terms of both the MIT license and the\n+Apache License (Version 2.0).\n+\n+See [LICENSE-APACHE](LICENSE-APACHE) and [LICENSE-MIT](LICENSE-MIT) for details.\n+\n+[rust]: https://github.com/rust-lang/rust\n+[fmt rfcs]: https://github.com/rust-lang-nursery/fmt-rfcs\n+[style guide]: https://github.com/rust-lang-nursery/fmt-rfcs/blob/master/guide/guide.md"}, {"sha": "7bfe696009face52be24d9f41c8942f27392bf3a", "filename": "src/tools/rustfmt/appveyor.yml", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Fappveyor.yml", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Fappveyor.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fappveyor.yml?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782", "patch": "@@ -0,0 +1,55 @@\n+# This is based on https://github.com/japaric/rust-everywhere/blob/master/appveyor.yml\r\n+# and modified (mainly removal of deployment) to suit rustfmt.\r\n+\r\n+environment:\r\n+  global:\r\n+    PROJECT_NAME: rustfmt\r\n+  matrix:\r\n+    # Stable channel\r\n+    # - TARGET: i686-pc-windows-gnu\r\n+    #   CHANNEL: stable\r\n+    # - TARGET: i686-pc-windows-msvc\r\n+    #   CHANNEL: stable\r\n+    # - TARGET: x86_64-pc-windows-gnu\r\n+    #   CHANNEL: stable\r\n+    # - TARGET: x86_64-pc-windows-msvc\r\n+    #   CHANNEL: stable\r\n+    # Beta channel\r\n+    # - TARGET: i686-pc-windows-gnu\r\n+    #   CHANNEL: beta\r\n+    # - TARGET: i686-pc-windows-msvc\r\n+    #   CHANNEL: beta\r\n+    # - TARGET: x86_64-pc-windows-gnu\r\n+    #   CHANNEL: beta\r\n+    # - TARGET: x86_64-pc-windows-msvc\r\n+    #   CHANNEL: beta\r\n+    # Nightly channel\r\n+    - TARGET: i686-pc-windows-gnu\r\n+      CHANNEL: nightly\r\n+    - TARGET: i686-pc-windows-msvc\r\n+      CHANNEL: nightly\r\n+    - TARGET: x86_64-pc-windows-gnu\r\n+      CHANNEL: nightly\r\n+    - TARGET: x86_64-pc-windows-msvc\r\n+      CHANNEL: nightly\r\n+\r\n+# Install Rust and Cargo\r\n+# (Based on from https://github.com/rust-lang/libc/blob/master/appveyor.yml)\r\n+install:\r\n+  - appveyor-retry appveyor DownloadFile https://win.rustup.rs/ -FileName rustup-init.exe\r\n+  - if \"%TARGET%\" == \"i686-pc-windows-gnu\" set PATH=%PATH%;C:\\msys64\\mingw32\\bin\r\n+  - if \"%TARGET%\" == \"x86_64-pc-windows-gnu\" set PATH=%PATH%;C:\\msys64\\mingw64\\bin\r\n+  - set PATH=%PATH%;C:\\Users\\appveyor\\.cargo\\bin\r\n+  - rustup-init.exe --default-host %TARGET% --default-toolchain %CHANNEL% -y\r\n+  - rustc -Vv\r\n+  - cargo -V\r\n+\r\n+# ???\r\n+build: false\r\n+\r\n+test_script:\r\n+  - set CFG_RELEASE_CHANNEL=nightly\r\n+  - set CFG_RELEASE=nightly\r\n+  - cargo build --verbose\r\n+  - cargo test\r\n+  - cargo test -- --ignored\r"}, {"sha": "f77ac1490721df68bd15cff8892517b24ae8aa85", "filename": "src/tools/rustfmt/atom.md", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Fatom.md", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Fatom.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fatom.md?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782", "patch": "@@ -0,0 +1,31 @@\n+# Running Rustfmt from Atom\n+\n+## RLS\n+\n+Rustfmt is included with the Rust Language Server, itself provided by [ide-rust](https://atom.io/packages/ide-rust).\n+\n+`apm install ide-rust`\n+\n+Once installed a file is formatted with `ctrl-shift-c` or `cmd-shift-c`, also available in context menu.\n+\n+## atom-beautify\n+\n+Another way is to install [Beautify](https://atom.io/packages/atom-beautify), you\n+can do this by running `apm install atom-beautify`.\n+\n+There are 2 settings that need to be configured in the atom beautifier configuration.\n+\n+-  Install rustfmt as per the [readme](README.md).\n+-  Open the atom beautifier settings\n+\n+   Go to Edit->Preferences. Click the packages on the left side and click on setting for atom-beautifier\n+\n+-  Set rustfmt as the beautifier\n+\n+   Find the setting labeled *Language Config - Rust - Default Beautifier* and make sure it is set to rustfmt as shown below. You can also set the beautifier to auto format on save here.\n+![image](https://cloud.githubusercontent.com/assets/6623285/11147685/c8ade16c-8a3d-11e5-9da5-bd3d998d97f9.png)\n+\n+-  Set the path to your rustfmt location\n+\n+   Find the setting labeled *Rust - Rustfmt Path*. This setting is towards the bottom and you will need to scroll a bit. Set it to the path for your rustfmt executable.\n+![image](https://cloud.githubusercontent.com/assets/6623285/11147718/f4d10224-8a3d-11e5-9f69-9e900cbe0278.png)"}, {"sha": "05ac0ce2f306fc4bcf4802242017887b31f8ca9e", "filename": "src/tools/rustfmt/bootstrap.sh", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Fbootstrap.sh", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Fbootstrap.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fbootstrap.sh?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782", "patch": "@@ -0,0 +1,17 @@\n+#!/bin/bash\n+\n+# Make sure you double check the diffs after running this script - with great\n+# power comes great responsibility.\n+# We deliberately avoid reformatting files with rustfmt comment directives.\n+\n+cargo build --release\n+\n+target/release/rustfmt src/lib.rs\n+target/release/rustfmt src/bin/main.rs\n+target/release/rustfmt src/cargo-fmt/main.rs\n+\n+for filename in tests/target/*.rs; do\n+    if ! grep -q \"rustfmt-\" \"$filename\"; then\n+        target/release/rustfmt $filename\n+    fi\n+done"}, {"sha": "e7b1e1b854c07025ac06e9391859c2c1c7fd63af", "filename": "src/tools/rustfmt/build.rs", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fbuild.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782", "patch": "@@ -0,0 +1,55 @@\n+use std::env;\n+use std::fs::File;\n+use std::io::Write;\n+use std::path::{Path, PathBuf};\n+use std::process::Command;\n+\n+fn main() {\n+    // Only check .git/HEAD dirty status if it exists - doing so when\n+    // building dependent crates may lead to false positives and rebuilds\n+    if Path::new(\".git/HEAD\").exists() {\n+        println!(\"cargo:rerun-if-changed=.git/HEAD\");\n+    }\n+\n+    println!(\"cargo:rerun-if-env-changed=CFG_RELEASE_CHANNEL\");\n+\n+    let out_dir = PathBuf::from(env::var_os(\"OUT_DIR\").unwrap());\n+\n+    File::create(out_dir.join(\"commit-info.txt\"))\n+        .unwrap()\n+        .write_all(commit_info().as_bytes())\n+        .unwrap();\n+}\n+\n+// Try to get hash and date of the last commit on a best effort basis. If anything goes wrong\n+// (git not installed or if this is not a git repository) just return an empty string.\n+fn commit_info() -> String {\n+    match (channel(), commit_hash(), commit_date()) {\n+        (channel, Some(hash), Some(date)) => format!(\"{} ({} {})\", channel, hash.trim_end(), date),\n+        _ => String::new(),\n+    }\n+}\n+\n+fn channel() -> String {\n+    if let Ok(channel) = env::var(\"CFG_RELEASE_CHANNEL\") {\n+        channel\n+    } else {\n+        \"nightly\".to_owned()\n+    }\n+}\n+\n+fn commit_hash() -> Option<String> {\n+    Command::new(\"git\")\n+        .args(&[\"rev-parse\", \"--short\", \"HEAD\"])\n+        .output()\n+        .ok()\n+        .and_then(|r| String::from_utf8(r.stdout).ok())\n+}\n+\n+fn commit_date() -> Option<String> {\n+    Command::new(\"git\")\n+        .args(&[\"log\", \"-1\", \"--date=short\", \"--pretty=format:%cd\"])\n+        .output()\n+        .ok()\n+        .and_then(|r| String::from_utf8(r.stdout).ok())\n+}"}, {"sha": "13a3ecaa1961cd99188bd49f0a7e650fce36f752", "filename": "src/tools/rustfmt/ci/integration.sh", "status": "added", "additions": 107, "deletions": 0, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Fci%2Fintegration.sh", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Fci%2Fintegration.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fci%2Fintegration.sh?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782", "patch": "@@ -0,0 +1,107 @@\n+#!/usr/bin/env bash\n+\n+set -ex\n+\n+: ${INTEGRATION?\"The INTEGRATION environment variable must be set.\"}\n+\n+# FIXME: this means we can get a stale cargo-fmt from a previous run.\n+#\n+# `which rustfmt` fails if rustfmt is not found. Since we don't install\n+# `rustfmt` via `rustup`, this is the case unless we manually install it. Once\n+# that happens, `cargo install --force` will be called, which installs\n+# `rustfmt`, `cargo-fmt`, etc to `~/.cargo/bin`. This directory is cached by\n+# travis (see `.travis.yml`'s \"cache\" key), such that build-bots that arrive\n+# here after the first installation will find `rustfmt` and won't need to build\n+# it again.\n+#\n+#which cargo-fmt || cargo install --force\n+CFG_RELEASE=nightly CFG_RELEASE_CHANNEL=nightly cargo install --path . --force \n+\n+echo \"Integration tests for: ${INTEGRATION}\"\n+cargo fmt -- --version\n+\n+# Checks that:\n+#\n+# * `cargo fmt --all` succeeds without any warnings or errors\n+# * `cargo fmt --all -- --check` after formatting returns success\n+# * `cargo test --all` still passes (formatting did not break the build)\n+function check_fmt_with_all_tests {\n+    check_fmt_base \"--all\"\n+    return $?\n+}\n+\n+# Checks that:\n+#\n+# * `cargo fmt --all` succeeds without any warnings or errors\n+# * `cargo fmt --all -- --check` after formatting returns success\n+# * `cargo test --lib` still passes (formatting did not break the build)\n+function check_fmt_with_lib_tests {\n+    check_fmt_base \"--lib\"\n+    return $?\n+}\n+\n+function check_fmt_base {\n+    local test_args=\"$1\"\n+    local build=$(cargo test $test_args 2>&1)\n+    if [[ \"$build\" =~ \"build failed\" ]] || [[ \"$build\" =~ \"test result: FAILED.\" ]]; then\n+          return 0\n+    fi\n+    touch rustfmt.toml\n+    cargo fmt --all -v |& tee rustfmt_output\n+    if [[ ${PIPESTATUS[0]} != 0 ]]; then\n+        cat rustfmt_output\n+        return 1\n+    fi\n+    cat rustfmt_output\n+    ! cat rustfmt_output | grep -q \"internal error\"\n+    if [[ $? != 0 ]]; then\n+        return 1\n+    fi\n+    ! cat rustfmt_output | grep -q \"warning\"\n+    if [[ $? != 0 ]]; then\n+        return 1\n+    fi\n+    ! cat rustfmt_output | grep -q \"Warning\"\n+    if [[ $? != 0 ]]; then\n+        return 1\n+    fi\n+    cargo fmt --all -- --check |& tee rustfmt_check_output\n+    if [[ ${PIPESTATUS[0]} != 0 ]]; then\n+        cat rustfmt_check_output\n+        return 1\n+    fi\n+    cargo test $test_args\n+    if [[ $? != 0 ]]; then\n+        return $?\n+    fi\n+}\n+\n+function show_head {\n+    local head=$(git rev-parse HEAD)\n+    echo \"Head commit of ${INTEGRATION}: $head\"\n+}\n+\n+case ${INTEGRATION} in\n+    cargo)\n+        git clone --depth=1 https://github.com/rust-lang/${INTEGRATION}.git\n+        cd ${INTEGRATION}\n+        show_head\n+        export CFG_DISABLE_CROSS_TESTS=1\n+        check_fmt_with_all_tests\n+        cd -\n+        ;;\n+    crater)\n+        git clone --depth=1 https://github.com/rust-lang-nursery/${INTEGRATION}.git\n+        cd ${INTEGRATION}\n+        show_head\n+        check_fmt_with_lib_tests\n+        cd -\n+        ;;\n+    *)\n+        git clone --depth=1 https://github.com/rust-lang-nursery/${INTEGRATION}.git\n+        cd ${INTEGRATION}\n+        show_head\n+        check_fmt_with_all_tests\n+        cd -\n+        ;;\n+esac"}, {"sha": "9f970225adb6a6ada5c22d46d02684b6b0f5525e", "filename": "src/tools/rustfmt/config_proc_macro/.gitignore", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Fconfig_proc_macro%2F.gitignore", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Fconfig_proc_macro%2F.gitignore", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fconfig_proc_macro%2F.gitignore?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782", "patch": "@@ -0,0 +1 @@\n+target/\n\\ No newline at end of file"}, {"sha": "abcf9654e5d77414d6da6356432b060543be71b2", "filename": "src/tools/rustfmt/config_proc_macro/Cargo.lock", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Fconfig_proc_macro%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Fconfig_proc_macro%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fconfig_proc_macro%2FCargo.lock?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782", "patch": "@@ -0,0 +1,68 @@\n+# This file is automatically @generated by Cargo.\n+# It is not intended for manual editing.\n+[[package]]\n+name = \"proc-macro2\"\n+version = \"1.0.3\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"unicode-xid 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n+[[package]]\n+name = \"quote\"\n+version = \"1.0.2\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"proc-macro2 1.0.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n+[[package]]\n+name = \"rustfmt-config_proc_macro\"\n+version = \"0.1.2\"\n+dependencies = [\n+ \"proc-macro2 1.0.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"quote 1.0.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde 1.0.99 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"syn 1.0.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n+[[package]]\n+name = \"serde\"\n+version = \"1.0.99\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"serde_derive 1.0.99 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n+[[package]]\n+name = \"serde_derive\"\n+version = \"1.0.99\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"proc-macro2 1.0.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"quote 1.0.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"syn 1.0.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n+[[package]]\n+name = \"syn\"\n+version = \"1.0.5\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"proc-macro2 1.0.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"quote 1.0.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"unicode-xid 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n+[[package]]\n+name = \"unicode-xid\"\n+version = \"0.2.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+\n+[metadata]\n+\"checksum proc-macro2 1.0.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"e98a83a9f9b331f54b924e68a66acb1bb35cb01fb0a23645139967abefb697e8\"\n+\"checksum quote 1.0.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"053a8c8bcc71fcce321828dc897a98ab9760bef03a4fc36693c231e5b3216cfe\"\n+\"checksum serde 1.0.99 (registry+https://github.com/rust-lang/crates.io-index)\" = \"fec2851eb56d010dc9a21b89ca53ee75e6528bab60c11e89d38390904982da9f\"\n+\"checksum serde_derive 1.0.99 (registry+https://github.com/rust-lang/crates.io-index)\" = \"cb4dc18c61206b08dc98216c98faa0232f4337e1e1b8574551d5bad29ea1b425\"\n+\"checksum syn 1.0.5 (registry+https://github.com/rust-lang/crates.io-index)\" = \"66850e97125af79138385e9b88339cbcd037e3f28ceab8c5ad98e64f0f1f80bf\"\n+\"checksum unicode-xid 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"826e7639553986605ec5979c7dd957c7895e93eabed50ab2ffa7f6128a75097c\""}, {"sha": "cc995571602b9fbeb0b3eaa354b54197ddb1584c", "filename": "src/tools/rustfmt/config_proc_macro/Cargo.toml", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Fconfig_proc_macro%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Fconfig_proc_macro%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fconfig_proc_macro%2FCargo.toml?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782", "patch": "@@ -0,0 +1,24 @@\n+[package]\n+name = \"rustfmt-config_proc_macro\"\n+version = \"0.2.0\"\n+authors = [\"topecongiro <seuchida@gmail.com>\"]\n+edition = \"2018\"\n+description = \"A collection of procedural macros for rustfmt\"\n+license = \"Apache-2.0/MIT\"\n+categories = [\"development-tools::procedural-macro-helpers\"]\n+repository = \"https://github.com/rust-lang/rustfmt\"\n+\n+[lib]\n+proc-macro = true\n+\n+[dependencies]\n+proc-macro2 = \"1.0\"\n+quote = \"1.0\"\n+syn = { version = \"1.0\", features = [\"full\", \"visit\"] }\n+\n+[dev-dependencies]\n+serde = { version = \"1.0\", features = [\"derive\"] }\n+\n+[features]\n+default = []\n+debug-with-rustfmt = []"}, {"sha": "0baba046f9e9149ecaddd32786dfac65a0fbc58b", "filename": "src/tools/rustfmt/config_proc_macro/src/attrs.rs", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Fconfig_proc_macro%2Fsrc%2Fattrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Fconfig_proc_macro%2Fsrc%2Fattrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fconfig_proc_macro%2Fsrc%2Fattrs.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782", "patch": "@@ -0,0 +1,57 @@\n+//! This module provides utilities for handling attributes on variants\n+//! of `config_type` enum. Currently there are two types of attributes\n+//! that could appear on the variants of `config_type` enum: `doc_hint`\n+//! and `value`. Both comes in the form of name-value pair whose value\n+//! is string literal.\n+\n+/// Returns the value of the first `doc_hint` attribute in the given slice or\n+/// `None` if `doc_hint` attribute is not available.\n+pub fn find_doc_hint(attrs: &[syn::Attribute]) -> Option<String> {\n+    attrs.iter().filter_map(doc_hint).next()\n+}\n+\n+/// Returns `true` if the given attribute is a `doc_hint` attribute.\n+pub fn is_doc_hint(attr: &syn::Attribute) -> bool {\n+    is_attr_name_value(attr, \"doc_hint\")\n+}\n+\n+/// Returns a string literal value if the given attribute is `doc_hint`\n+/// attribute or `None` otherwise.\n+pub fn doc_hint(attr: &syn::Attribute) -> Option<String> {\n+    get_name_value_str_lit(attr, \"doc_hint\")\n+}\n+\n+/// Returns the value of the first `value` attribute in the given slice or\n+/// `None` if `value` attribute is not available.\n+pub fn find_config_value(attrs: &[syn::Attribute]) -> Option<String> {\n+    attrs.iter().filter_map(config_value).next()\n+}\n+\n+/// Returns a string literal value if the given attribute is `value`\n+/// attribute or `None` otherwise.\n+pub fn config_value(attr: &syn::Attribute) -> Option<String> {\n+    get_name_value_str_lit(attr, \"value\")\n+}\n+\n+/// Returns `true` if the given attribute is a `value` attribute.\n+pub fn is_config_value(attr: &syn::Attribute) -> bool {\n+    is_attr_name_value(attr, \"value\")\n+}\n+\n+fn is_attr_name_value(attr: &syn::Attribute, name: &str) -> bool {\n+    attr.parse_meta().ok().map_or(false, |meta| match meta {\n+        syn::Meta::NameValue(syn::MetaNameValue { ref path, .. }) if path.is_ident(name) => true,\n+        _ => false,\n+    })\n+}\n+\n+fn get_name_value_str_lit(attr: &syn::Attribute, name: &str) -> Option<String> {\n+    attr.parse_meta().ok().and_then(|meta| match meta {\n+        syn::Meta::NameValue(syn::MetaNameValue {\n+            ref path,\n+            lit: syn::Lit::Str(ref lit_str),\n+            ..\n+        }) if path.is_ident(name) => Some(lit_str.value()),\n+        _ => None,\n+    })\n+}"}, {"sha": "93a78b8463ec58d9f098f5d77105ae8683c3dc9f", "filename": "src/tools/rustfmt/config_proc_macro/src/config_type.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Fconfig_proc_macro%2Fsrc%2Fconfig_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Fconfig_proc_macro%2Fsrc%2Fconfig_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fconfig_proc_macro%2Fsrc%2Fconfig_type.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782", "patch": "@@ -0,0 +1,15 @@\n+use proc_macro2::TokenStream;\n+\n+use crate::item_enum::define_config_type_on_enum;\n+use crate::item_struct::define_config_type_on_struct;\n+\n+/// Defines `config_type` on enum or struct.\n+// FIXME: Implement this on struct.\n+pub fn define_config_type(input: &syn::Item) -> TokenStream {\n+    match input {\n+        syn::Item::Struct(st) => define_config_type_on_struct(st),\n+        syn::Item::Enum(en) => define_config_type_on_enum(en),\n+        _ => panic!(\"Expected enum or struct\"),\n+    }\n+    .unwrap()\n+}"}, {"sha": "dcee77a8549c5b9cf9beacd47663cb39d177c4ce", "filename": "src/tools/rustfmt/config_proc_macro/src/item_enum.rs", "status": "added", "additions": 208, "deletions": 0, "changes": 208, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Fconfig_proc_macro%2Fsrc%2Fitem_enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Fconfig_proc_macro%2Fsrc%2Fitem_enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fconfig_proc_macro%2Fsrc%2Fitem_enum.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782", "patch": "@@ -0,0 +1,208 @@\n+use proc_macro2::TokenStream;\n+use quote::quote;\n+\n+use crate::attrs::*;\n+use crate::utils::*;\n+\n+type Variants = syn::punctuated::Punctuated<syn::Variant, syn::Token![,]>;\n+\n+/// Defines and implements `config_type` enum.\n+pub fn define_config_type_on_enum(em: &syn::ItemEnum) -> syn::Result<TokenStream> {\n+    let syn::ItemEnum {\n+        vis,\n+        enum_token,\n+        ident,\n+        generics,\n+        variants,\n+        ..\n+    } = em;\n+\n+    let mod_name_str = format!(\"__define_config_type_on_enum_{}\", ident);\n+    let mod_name = syn::Ident::new(&mod_name_str, ident.span());\n+    let variants = fold_quote(variants.iter().map(process_variant), |meta| quote!(#meta,));\n+\n+    let impl_doc_hint = impl_doc_hint(&em.ident, &em.variants);\n+    let impl_from_str = impl_from_str(&em.ident, &em.variants);\n+    let impl_display = impl_display(&em.ident, &em.variants);\n+    let impl_serde = impl_serde(&em.ident, &em.variants);\n+    let impl_deserialize = impl_deserialize(&em.ident, &em.variants);\n+\n+    Ok(quote! {\n+        #[allow(non_snake_case)]\n+        mod #mod_name {\n+            #[derive(Debug, Copy, Clone, Eq, PartialEq)]\n+            pub #enum_token #ident #generics { #variants }\n+            #impl_display\n+            #impl_doc_hint\n+            #impl_from_str\n+            #impl_serde\n+            #impl_deserialize\n+        }\n+        #vis use #mod_name::#ident;\n+    })\n+}\n+\n+/// Remove attributes specific to `config_proc_macro` from enum variant fields.\n+fn process_variant(variant: &syn::Variant) -> TokenStream {\n+    let metas = variant\n+        .attrs\n+        .iter()\n+        .filter(|attr| !is_doc_hint(attr) && !is_config_value(attr));\n+    let attrs = fold_quote(metas, |meta| quote!(#meta));\n+    let syn::Variant { ident, fields, .. } = variant;\n+    quote!(#attrs #ident #fields)\n+}\n+\n+fn impl_doc_hint(ident: &syn::Ident, variants: &Variants) -> TokenStream {\n+    let doc_hint = variants\n+        .iter()\n+        .map(doc_hint_of_variant)\n+        .collect::<Vec<_>>()\n+        .join(\"|\");\n+    let doc_hint = format!(\"[{}]\", doc_hint);\n+    quote! {\n+        use crate::config::ConfigType;\n+        impl ConfigType for #ident {\n+            fn doc_hint() -> String {\n+                #doc_hint.to_owned()\n+            }\n+        }\n+    }\n+}\n+\n+fn impl_display(ident: &syn::Ident, variants: &Variants) -> TokenStream {\n+    let vs = variants\n+        .iter()\n+        .filter(|v| is_unit(v))\n+        .map(|v| (config_value_of_variant(v), &v.ident));\n+    let match_patterns = fold_quote(vs, |(s, v)| {\n+        quote! {\n+            #ident::#v => write!(f, \"{}\", #s),\n+        }\n+    });\n+    quote! {\n+        use std::fmt;\n+        impl fmt::Display for #ident {\n+            fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+                match self {\n+                    #match_patterns\n+                    _ => unimplemented!(),\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+fn impl_from_str(ident: &syn::Ident, variants: &Variants) -> TokenStream {\n+    let vs = variants\n+        .iter()\n+        .filter(|v| is_unit(v))\n+        .map(|v| (config_value_of_variant(v), &v.ident));\n+    let if_patterns = fold_quote(vs, |(s, v)| {\n+        quote! {\n+            if #s.eq_ignore_ascii_case(s) {\n+                return Ok(#ident::#v);\n+            }\n+        }\n+    });\n+    let mut err_msg = String::from(\"Bad variant, expected one of:\");\n+    for v in variants.iter().filter(|v| is_unit(v)) {\n+        err_msg.push_str(&format!(\" `{}`\", v.ident));\n+    }\n+\n+    quote! {\n+        impl ::std::str::FromStr for #ident {\n+            type Err = &'static str;\n+\n+            fn from_str(s: &str) -> Result<Self, Self::Err> {\n+                #if_patterns\n+                return Err(#err_msg);\n+            }\n+        }\n+    }\n+}\n+\n+fn doc_hint_of_variant(variant: &syn::Variant) -> String {\n+    find_doc_hint(&variant.attrs).unwrap_or(variant.ident.to_string())\n+}\n+\n+fn config_value_of_variant(variant: &syn::Variant) -> String {\n+    find_config_value(&variant.attrs).unwrap_or(variant.ident.to_string())\n+}\n+\n+fn impl_serde(ident: &syn::Ident, variants: &Variants) -> TokenStream {\n+    let arms = fold_quote(variants.iter(), |v| {\n+        let v_ident = &v.ident;\n+        let pattern = match v.fields {\n+            syn::Fields::Named(..) => quote!(#ident::v_ident{..}),\n+            syn::Fields::Unnamed(..) => quote!(#ident::#v_ident(..)),\n+            syn::Fields::Unit => quote!(#ident::#v_ident),\n+        };\n+        let option_value = config_value_of_variant(v);\n+        quote! {\n+            #pattern => serializer.serialize_str(&#option_value),\n+        }\n+    });\n+\n+    quote! {\n+        impl ::serde::ser::Serialize for #ident {\n+            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n+            where\n+                S: ::serde::ser::Serializer,\n+            {\n+                use serde::ser::Error;\n+                match self {\n+                    #arms\n+                    _ => Err(S::Error::custom(format!(\"Cannot serialize {:?}\", self))),\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+// Currently only unit variants are supported.\n+fn impl_deserialize(ident: &syn::Ident, variants: &Variants) -> TokenStream {\n+    let supported_vs = variants.iter().filter(|v| is_unit(v));\n+    let if_patterns = fold_quote(supported_vs, |v| {\n+        let config_value = config_value_of_variant(v);\n+        let variant_ident = &v.ident;\n+        quote! {\n+            if #config_value.eq_ignore_ascii_case(s) {\n+                return Ok(#ident::#variant_ident);\n+            }\n+        }\n+    });\n+\n+    let supported_vs = variants.iter().filter(|v| is_unit(v));\n+    let allowed = fold_quote(supported_vs.map(config_value_of_variant), |s| quote!(#s,));\n+\n+    quote! {\n+        impl<'de> serde::de::Deserialize<'de> for #ident {\n+            fn deserialize<D>(d: D) -> Result<Self, D::Error>\n+            where\n+                D: serde::Deserializer<'de>,\n+            {\n+                use serde::de::{Error, Visitor};\n+                use std::marker::PhantomData;\n+                use std::fmt;\n+                struct StringOnly<T>(PhantomData<T>);\n+                impl<'de, T> Visitor<'de> for StringOnly<T>\n+                where T: serde::Deserializer<'de> {\n+                    type Value = String;\n+                    fn expecting(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {\n+                        formatter.write_str(\"string\")\n+                    }\n+                    fn visit_str<E>(self, value: &str) -> Result<String, E> {\n+                        Ok(String::from(value))\n+                    }\n+                }\n+                let s = &d.deserialize_string(StringOnly::<D>(PhantomData))?;\n+\n+                #if_patterns\n+\n+                static ALLOWED: &'static[&str] = &[#allowed];\n+                Err(D::Error::unknown_variant(&s, ALLOWED))\n+            }\n+        }\n+    }\n+}"}, {"sha": "f03ff7e30d82ef67adec6abe43f995f3bb7de9ee", "filename": "src/tools/rustfmt/config_proc_macro/src/item_struct.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Fconfig_proc_macro%2Fsrc%2Fitem_struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Fconfig_proc_macro%2Fsrc%2Fitem_struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fconfig_proc_macro%2Fsrc%2Fitem_struct.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782", "patch": "@@ -0,0 +1,5 @@\n+use proc_macro2::TokenStream;\n+\n+pub fn define_config_type_on_struct(_st: &syn::ItemStruct) -> syn::Result<TokenStream> {\n+    unimplemented!()\n+}"}, {"sha": "78e7e098ed9e17cf1de271c9c637cf41fbb9158c", "filename": "src/tools/rustfmt/config_proc_macro/src/lib.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Fconfig_proc_macro%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Fconfig_proc_macro%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fconfig_proc_macro%2Fsrc%2Flib.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782", "patch": "@@ -0,0 +1,25 @@\n+//! This crate provides a derive macro for `ConfigType`.\n+\n+#![recursion_limit = \"256\"]\n+\n+mod attrs;\n+mod config_type;\n+mod item_enum;\n+mod item_struct;\n+mod utils;\n+\n+use proc_macro::TokenStream;\n+use syn::parse_macro_input;\n+\n+#[proc_macro_attribute]\n+pub fn config_type(_args: TokenStream, input: TokenStream) -> TokenStream {\n+    let input = parse_macro_input!(input as syn::Item);\n+    let output = config_type::define_config_type(&input);\n+\n+    #[cfg(feature = \"debug-with-rustfmt\")]\n+    {\n+        utils::debug_with_rustfmt(&output);\n+    }\n+\n+    TokenStream::from(output)\n+}"}, {"sha": "5b68d2748490f53f41bf70be1d42d828d18f9f1d", "filename": "src/tools/rustfmt/config_proc_macro/src/utils.rs", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Fconfig_proc_macro%2Fsrc%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Fconfig_proc_macro%2Fsrc%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fconfig_proc_macro%2Fsrc%2Futils.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782", "patch": "@@ -0,0 +1,52 @@\n+use proc_macro2::TokenStream;\n+use quote::{quote, ToTokens};\n+\n+pub fn fold_quote<F, I, T>(input: impl Iterator<Item = I>, f: F) -> TokenStream\n+where\n+    F: Fn(I) -> T,\n+    T: ToTokens,\n+{\n+    input.fold(quote! {}, |acc, x| {\n+        let y = f(x);\n+        quote! { #acc #y }\n+    })\n+}\n+\n+pub fn is_unit(v: &syn::Variant) -> bool {\n+    match v.fields {\n+        syn::Fields::Unit => true,\n+        _ => false,\n+    }\n+}\n+\n+#[cfg(feature = \"debug-with-rustfmt\")]\n+/// Pretty-print the output of proc macro using rustfmt.\n+pub fn debug_with_rustfmt(input: &TokenStream) {\n+    use std::io::Write;\n+    use std::process::{Command, Stdio};\n+    use std::env;\n+    use std::ffi::OsStr;\n+\n+    let rustfmt_var = env::var_os(\"RUSTFMT\");\n+    let rustfmt = match &rustfmt_var {\n+        Some(rustfmt) => rustfmt,\n+        None => OsStr::new(\"rustfmt\"),\n+    };\n+    let mut child = Command::new(rustfmt)\n+        .stdin(Stdio::piped())\n+        .stdout(Stdio::piped())\n+        .spawn()\n+        .expect(\"Failed to spawn rustfmt in stdio mode\");\n+    {\n+        let stdin = child.stdin.as_mut().expect(\"Failed to get stdin\");\n+        stdin\n+            .write_all(format!(\"{}\", input).as_bytes())\n+            .expect(\"Failed to write to stdin\");\n+    }\n+    let rustfmt_output = child.wait_with_output().expect(\"rustfmt has failed\");\n+\n+    eprintln!(\n+        \"{}\",\n+        String::from_utf8(rustfmt_output.stdout).expect(\"rustfmt returned non-UTF8 string\")\n+    );\n+}"}, {"sha": "940a8a0c251e45ea2fc65b1b3edbab9aa8244884", "filename": "src/tools/rustfmt/config_proc_macro/tests/smoke.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Fconfig_proc_macro%2Ftests%2Fsmoke.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Fconfig_proc_macro%2Ftests%2Fsmoke.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fconfig_proc_macro%2Ftests%2Fsmoke.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782", "patch": "@@ -0,0 +1,20 @@\n+pub mod config {\n+    pub trait ConfigType: Sized {\n+        fn doc_hint() -> String;\n+    }\n+}\n+\n+#[allow(dead_code)]\n+#[allow(unused_imports)]\n+mod tests {\n+    use rustfmt_config_proc_macro::config_type;\n+\n+    #[config_type]\n+    enum Bar {\n+        Foo,\n+        Bar,\n+        #[doc_hint = \"foo_bar\"]\n+        FooBar,\n+        FooFoo(i32),\n+    }\n+}"}, {"sha": "2a12da3881f0573ba2566453b9123239663ffe97", "filename": "src/tools/rustfmt/docs/index.html", "status": "added", "additions": 191, "deletions": 0, "changes": 191, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Fdocs%2Findex.html", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Fdocs%2Findex.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fdocs%2Findex.html?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782", "patch": "@@ -0,0 +1,191 @@\n+<!doctype html>\n+<html>\n+    <head>\n+      <meta name=\"viewport\" content=\"width=device-width\">\n+      <link rel=\"stylesheet\" href=\"https://cdnjs.cloudflare.com/ajax/libs/github-markdown-css/3.0.1/github-markdown.css\" />\n+      <script src=\"https://cdn.jsdelivr.net/npm/marked/marked.min.js\"></script>\n+      <script src=\"https://cdn.jsdelivr.net/npm/vue@2.6.10/dist/vue.js\"></script>\n+      <script src=\"https://cdnjs.cloudflare.com/ajax/libs/axios/0.18.0/axios.min.js\"></script>\n+      <style>\n+        @media (max-width: 767px) {\n+          .markdown-body {\n+            padding: 15px;\n+          }\n+\n+          #search {\n+            max-width: 85%;\n+          }\n+        }\n+        body {\n+          overflow: scroll;\n+        }\n+        .markdown-body {\n+          box-sizing: border-box;\n+          min-width: 200px;\n+          max-width: 980px;\n+          margin: 0 auto;\n+          padding: 45px;\n+        }\n+        #search {\n+          border: 1px solid #d1d5da;\n+          padding-left: 30px;\n+          overflow: hidden;\n+        }\n+        .searchCondition {\n+          display: flex;\n+          flex-wrap: wrap;\n+        }\n+        .searchCondition > div {\n+          margin-right: 30px;\n+        }\n+      </style>\n+    </head>\n+    <body>\n+        <div id=\"app\">\n+          <article class=\"markdown-body\">\n+            <div class=\"searchCondition\">\n+              <div>\n+                <form style=\"display:flex;\">\n+                  <label for=\"search\" style=\"margin-right: 3px;\" >search:</label>\n+                  <div style=\"position: relative;\">\n+                    <input id=\"search\" placeholder=\"Search all options\" v-model=\"searchCondition\">\n+                    <svg style=\"position: absolute; left: 8px; top: 7px;\" class=\"octicon octicon-search subnav-search-icon\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\">\n+                      <path fill-rule=\"evenodd\" d=\"M15.7 13.3l-3.81-3.83A5.93 5.93 0 0 0 13 6c0-3.31-2.69-6-6-6S1 2.69 1 6s2.69 6 6 6c1.3 0 2.48-.41 3.47-1.11l3.83 3.81c.19.2.45.3.7.3.25 0 .52-.09.7-.3a.996.996 0 0 0 0-1.41v.01zM7 10.7c-2.59 0-4.7-2.11-4.7-4.7 0-2.59 2.11-4.7 4.7-4.7 2.59 0 4.7 2.11 4.7 4.7 0 2.59-2.11 4.7-4.7 4.7z\"></path>\n+                    </svg>\n+                  </div>\n+                </form>\n+              </div>\n+              <div>\n+                  <label for=\"stable\">stable: </label>\n+                  <input type=\"checkbox\" id=\"stable\" v-model=\"shouldStable\">\n+              </div>\n+            </div>\n+            <div v-html=\"aboutHtml\"></div>\n+            <div v-html=\"configurationAboutHtml\"></div>\n+            <div v-html=\"outputHtml\"></div>\n+          </article>\n+        </div>\n+        <script>\n+            const ConfigurationMdUrl = 'https://raw.githubusercontent.com/rust-lang/rustfmt/master/Configurations.md';\n+            const UrlHash = window.location.hash.replace(/^#/, '');\n+            new Vue({\n+              el: '#app',\n+              data() {\n+                const configurationDescriptions = [];\n+                configurationDescriptions.links = {};\n+                return {\n+                  aboutHtml: '',\n+                  configurationAboutHtml: '',\n+                  searchCondition: UrlHash,\n+                  configurationDescriptions,\n+                  shouldStable: false\n+                }\n+              },\n+              computed: {\n+                outputHtml() {\n+                  const ast = this.configurationDescriptions\n+                                  .filter(({ head, text, stable }) => {\n+                                    \n+                                    if (\n+                                      text.includes(this.searchCondition) === false &&\n+                                      head.includes(this.searchCondition) === false\n+                                    ) {\n+                                      return false;\n+                                    }\n+                                    return (this.shouldStable)\n+                                      ? stable === true\n+                                      : true;\n+                                  })\n+                                  .reduce((stack, { value }) => {\n+                                    return stack.concat(value);\n+                                  }, []);\n+                  ast.links = {};\n+                  return marked.parser(ast);\n+                }\n+              },\n+              created: async function() {\n+                const res = await axios.get(ConfigurationMdUrl);\n+                const { \n+                  about,\n+                  configurationAbout,\n+                  configurationDescriptions\n+                } = parseMarkdownAst(res.data);\n+                this.aboutHtml = marked.parser(about);\n+                this.configurationAboutHtml = marked.parser(configurationAbout);\n+                this.configurationDescriptions = configurationDescriptions;\n+              },\n+              mounted() {\n+                if (UrlHash === '') return;\n+                const interval = setInterval(() => {\n+                  const target = document.querySelector(`#${UrlHash}`);\n+                  if (target != null) {\n+                    target.scrollIntoView(true);\n+                    clearInterval(interval);\n+                  }\n+                }, 100);\n+              }\n+            });\n+            const extractDepthOnes = (ast) => {\n+              return ast.reduce((stack, next) => {\n+                if (next.depth === 1) {\n+                  stack.push([]);\n+                }\n+                const lastIndex = stack.length - 1;\n+                stack[lastIndex].push(next);\n+                return stack;\n+              }, []);\n+            }\n+            const extractDepthTwos = (ast) => {\n+              return ast.map((elem) => {\n+                return elem.reduce((stack, next) => {\n+                  if (next.depth === 2) {\n+                    stack.push([]);\n+                  }\n+                  const lastIndex = stack.length - 1;\n+                  stack[lastIndex].push(next);\n+                  return stack;\n+                }, \n+                [[]]);\n+              });\n+            }\n+            const createHeadAndValue = (ast) => {\n+              return ast.map((elem) => {\n+                return elem.map((val) => {\n+                  return {\n+                    head: val[0].text,\n+                    value: val,\n+                    stable: val.some((elem) => {\n+                      return !!elem.text && elem.text.includes(\"**Stable**: Yes\")\n+                    }),\n+                    text: val.reduce((result, next) => {\n+                      return next.text != null\n+                        ? `${result} ${next.text}`\n+                        : result;\n+                    }, '')\n+                  }\n+                });\n+              })\n+            }\n+            const parseMarkdownAst = (rawMarkdown) => {\n+              const ast = marked.lexer(rawMarkdown);\n+              const depthOnes = extractDepthOnes(ast);\n+              const depthTwos = extractDepthTwos(depthOnes);\n+              const [\n+                abouts, configurations\n+              ] = createHeadAndValue(depthTwos);\n+              const about = abouts[0].value;\n+              about.links = {};\n+              const [\n+                configurationAbout, ...configurationDescriptions\n+              ] = configurations;\n+              configurationAbout.value.links = {};\n+              \n+              return {\n+                about,\n+                configurationAbout: configurationAbout.value,\n+                configurationDescriptions\n+              };\n+            }\n+        </script>\n+    </body>\n+</html>\n\\ No newline at end of file"}, {"sha": "7aea6222b8bc5f7a8168857e36b7b501b225b267", "filename": "src/tools/rustfmt/intellij.md", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Fintellij.md", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Fintellij.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fintellij.md?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782", "patch": "@@ -0,0 +1,26 @@\n+# Running Rustfmt from IntelliJ or CLion\n+\n+## Installation\n+\n+- Install [CLion](https://www.jetbrains.com/clion/), [IntelliJ Ultimate or CE](https://www.jetbrains.com/idea/) through the direct download link or using the [JetBrains Toolbox](https://www.jetbrains.com/toolbox/).\n+  CLion provides a built-in debugger interface but its not free like IntelliJ CE - which does not provide the debugger interface. (IntelliJ seems to lack the toolchain for that, see this discussion [intellij-rust/issues/535](https://github.com/intellij-rust/intellij-rust/issues/535))\n+  \n+- Install the [Rust Plugin](https://intellij-rust.github.io/) by navigating to File -> Settings -> Plugins and press \"Install JetBrains Plugin\"\n+  ![plugins](https://user-images.githubusercontent.com/1133787/47240861-f40af680-d3e9-11e8-9b82-cdd5c8d5f5b8.png)\n+\n+- Press \"Install\" on the rust plugin\n+  ![install rust](https://user-images.githubusercontent.com/1133787/47240803-c0c86780-d3e9-11e8-9265-22f735e4d7ed.png)\n+  \n+- Restart CLion/IntelliJ\n+\n+## Configuration\n+\n+- Open the settings window (File -> Settings) and search for \"reformat\"\n+  ![keymap](https://user-images.githubusercontent.com/1133787/47240922-2ae10c80-d3ea-11e8-9d8f-c798d9749240.png)\n+- Right-click on \"Reformat File with Rustfmt\" and assign a keyboard shortcut\n+\n+  ![shortcut_window](https://user-images.githubusercontent.com/1133787/47240981-5b28ab00-d3ea-11e8-882e-8b864164db74.png)\n+- Press \"OK\"\n+  ![shortcut_after](https://user-images.githubusercontent.com/1133787/47241000-6976c700-d3ea-11e8-9342-50ebc2f9f97b.png)\n+  \n+- Done. You can now use rustfmt in an opened *.rs file with your previously specified shortcut"}, {"sha": "f976fa68e4c7de6d0afe45caeed50bede6a78022", "filename": "src/tools/rustfmt/legacy-rustfmt.toml", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Flegacy-rustfmt.toml", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Flegacy-rustfmt.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Flegacy-rustfmt.toml?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782", "patch": "@@ -0,0 +1,2 @@\n+indent_style = \"Visual\"\n+combine_control_expr = false"}, {"sha": "7c9d02d933d088626047c84c988f2b8b188280e7", "filename": "src/tools/rustfmt/rust-toolchain", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Frust-toolchain", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Frust-toolchain", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Frust-toolchain?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782", "patch": "@@ -0,0 +1,3 @@\n+[toolchain]\n+channel = \"nightly-2021-05-13\"\n+components = [\"rustc-dev\"]"}, {"sha": "eccd5f9bd19ee6fd1a3d1991aafa1d35919c4d61", "filename": "src/tools/rustfmt/rustfmt.toml", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Frustfmt.toml", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Frustfmt.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Frustfmt.toml?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782", "patch": "@@ -0,0 +1,3 @@\n+error_on_line_overflow = true\n+error_on_unformatted = true\n+version = \"Two\""}, {"sha": "c5ffb074ba554cfaa6f919d40fd2f579bf643129", "filename": "src/tools/rustfmt/src/attr.rs", "status": "added", "additions": 534, "deletions": 0, "changes": 534, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Fsrc%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Fsrc%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fsrc%2Fattr.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782", "patch": "@@ -0,0 +1,534 @@\n+//! Format attributes and meta items.\n+\n+use rustc_ast::ast;\n+use rustc_ast::AstLike;\n+use rustc_span::{symbol::sym, Span, Symbol};\n+\n+use self::doc_comment::DocCommentFormatter;\n+use crate::comment::{contains_comment, rewrite_doc_comment, CommentStyle};\n+use crate::config::lists::*;\n+use crate::config::IndentStyle;\n+use crate::expr::rewrite_literal;\n+use crate::lists::{definitive_tactic, itemize_list, write_list, ListFormatting, Separator};\n+use crate::overflow;\n+use crate::rewrite::{Rewrite, RewriteContext};\n+use crate::shape::Shape;\n+use crate::types::{rewrite_path, PathContext};\n+use crate::utils::{count_newlines, mk_sp};\n+\n+mod doc_comment;\n+\n+pub(crate) fn contains_name(attrs: &[ast::Attribute], name: Symbol) -> bool {\n+    attrs.iter().any(|attr| attr.has_name(name))\n+}\n+\n+pub(crate) fn first_attr_value_str_by_name(\n+    attrs: &[ast::Attribute],\n+    name: Symbol,\n+) -> Option<Symbol> {\n+    attrs\n+        .iter()\n+        .find(|attr| attr.has_name(name))\n+        .and_then(|attr| attr.value_str())\n+}\n+\n+/// Returns attributes on the given statement.\n+pub(crate) fn get_attrs_from_stmt(stmt: &ast::Stmt) -> &[ast::Attribute] {\n+    stmt.attrs()\n+}\n+\n+pub(crate) fn get_span_without_attrs(stmt: &ast::Stmt) -> Span {\n+    match stmt.kind {\n+        ast::StmtKind::Local(ref local) => local.span,\n+        ast::StmtKind::Item(ref item) => item.span,\n+        ast::StmtKind::Expr(ref expr) | ast::StmtKind::Semi(ref expr) => expr.span,\n+        ast::StmtKind::MacCall(ref mac_stmt) => mac_stmt.mac.span(),\n+        ast::StmtKind::Empty => stmt.span,\n+    }\n+}\n+\n+/// Returns attributes that are within `outer_span`.\n+pub(crate) fn filter_inline_attrs(\n+    attrs: &[ast::Attribute],\n+    outer_span: Span,\n+) -> Vec<ast::Attribute> {\n+    attrs\n+        .iter()\n+        .filter(|a| outer_span.lo() <= a.span.lo() && a.span.hi() <= outer_span.hi())\n+        .cloned()\n+        .collect()\n+}\n+\n+fn is_derive(attr: &ast::Attribute) -> bool {\n+    attr.has_name(sym::derive)\n+}\n+\n+// The shape of the arguments to a function-like attribute.\n+fn argument_shape(\n+    left: usize,\n+    right: usize,\n+    combine: bool,\n+    shape: Shape,\n+    context: &RewriteContext<'_>,\n+) -> Option<Shape> {\n+    match context.config.indent_style() {\n+        IndentStyle::Block => {\n+            if combine {\n+                shape.offset_left(left)\n+            } else {\n+                Some(\n+                    shape\n+                        .block_indent(context.config.tab_spaces())\n+                        .with_max_width(context.config),\n+                )\n+            }\n+        }\n+        IndentStyle::Visual => shape\n+            .visual_indent(0)\n+            .shrink_left(left)\n+            .and_then(|s| s.sub_width(right)),\n+    }\n+}\n+\n+fn format_derive(\n+    derives: &[ast::Attribute],\n+    shape: Shape,\n+    context: &RewriteContext<'_>,\n+) -> Option<String> {\n+    // Collect all items from all attributes\n+    let all_items = derives\n+        .iter()\n+        .map(|attr| {\n+            // Parse the derive items and extract the span for each item; if any\n+            // attribute is not parseable, none of the attributes will be\n+            // reformatted.\n+            let item_spans = attr.meta_item_list().map(|meta_item_list| {\n+                meta_item_list\n+                    .into_iter()\n+                    .map(|nested_meta_item| nested_meta_item.span())\n+            })?;\n+\n+            let items = itemize_list(\n+                context.snippet_provider,\n+                item_spans,\n+                \")\",\n+                \",\",\n+                |span| span.lo(),\n+                |span| span.hi(),\n+                |span| Some(context.snippet(*span).to_owned()),\n+                attr.span.lo(),\n+                attr.span.hi(),\n+                false,\n+            );\n+\n+            Some(items)\n+        })\n+        // Fail if any attribute failed.\n+        .collect::<Option<Vec<_>>>()?\n+        // Collect the results into a single, flat, Vec.\n+        .into_iter()\n+        .flatten()\n+        .collect::<Vec<_>>();\n+\n+    // Collect formatting parameters.\n+    let prefix = attr_prefix(&derives[0]);\n+    let argument_shape = argument_shape(\n+        \"[derive()]\".len() + prefix.len(),\n+        \")]\".len(),\n+        false,\n+        shape,\n+        context,\n+    )?;\n+    let one_line_shape = shape\n+        .offset_left(\"[derive()]\".len() + prefix.len())?\n+        .sub_width(\"()]\".len())?;\n+    let one_line_budget = one_line_shape.width;\n+\n+    let tactic = definitive_tactic(\n+        &all_items,\n+        ListTactic::HorizontalVertical,\n+        Separator::Comma,\n+        argument_shape.width,\n+    );\n+    let trailing_separator = match context.config.indent_style() {\n+        // We always add the trailing comma and remove it if it is not needed.\n+        IndentStyle::Block => SeparatorTactic::Always,\n+        IndentStyle::Visual => SeparatorTactic::Never,\n+    };\n+\n+    // Format the collection of items.\n+    let fmt = ListFormatting::new(argument_shape, context.config)\n+        .tactic(tactic)\n+        .trailing_separator(trailing_separator)\n+        .ends_with_newline(false);\n+    let item_str = write_list(&all_items, &fmt)?;\n+\n+    debug!(\"item_str: '{}'\", item_str);\n+\n+    // Determine if the result will be nested, i.e. if we're using the block\n+    // indent style and either the items are on multiple lines or we've exceeded\n+    // our budget to fit on a single line.\n+    let nested = context.config.indent_style() == IndentStyle::Block\n+        && (item_str.contains('\\n') || item_str.len() > one_line_budget);\n+\n+    // Format the final result.\n+    let mut result = String::with_capacity(128);\n+    result.push_str(prefix);\n+    result.push_str(\"[derive(\");\n+    if nested {\n+        let nested_indent = argument_shape.indent.to_string_with_newline(context.config);\n+        result.push_str(&nested_indent);\n+        result.push_str(&item_str);\n+        result.push_str(&shape.indent.to_string_with_newline(context.config));\n+    } else if let SeparatorTactic::Always = context.config.trailing_comma() {\n+        // Retain the trailing comma.\n+        result.push_str(&item_str);\n+    } else if item_str.ends_with(\",\") {\n+        // Remove the trailing comma.\n+        result.push_str(&item_str[..item_str.len() - 1]);\n+    } else {\n+        result.push_str(&item_str);\n+    }\n+    result.push_str(\")]\");\n+\n+    Some(result)\n+}\n+\n+/// Returns the first group of attributes that fills the given predicate.\n+/// We consider two doc comments are in different group if they are separated by normal comments.\n+fn take_while_with_pred<'a, P>(\n+    context: &RewriteContext<'_>,\n+    attrs: &'a [ast::Attribute],\n+    pred: P,\n+) -> &'a [ast::Attribute]\n+where\n+    P: Fn(&ast::Attribute) -> bool,\n+{\n+    let mut len = 0;\n+    let mut iter = attrs.iter().peekable();\n+\n+    while let Some(attr) = iter.next() {\n+        if pred(attr) {\n+            len += 1;\n+        } else {\n+            break;\n+        }\n+        if let Some(next_attr) = iter.peek() {\n+            // Extract comments between two attributes.\n+            let span_between_attr = mk_sp(attr.span.hi(), next_attr.span.lo());\n+            let snippet = context.snippet(span_between_attr);\n+            if count_newlines(snippet) >= 2 || snippet.contains('/') {\n+                break;\n+            }\n+        }\n+    }\n+\n+    &attrs[..len]\n+}\n+\n+/// Rewrite the any doc comments which come before any other attributes.\n+fn rewrite_initial_doc_comments(\n+    context: &RewriteContext<'_>,\n+    attrs: &[ast::Attribute],\n+    shape: Shape,\n+) -> Option<(usize, Option<String>)> {\n+    if attrs.is_empty() {\n+        return Some((0, None));\n+    }\n+    // Rewrite doc comments\n+    let sugared_docs = take_while_with_pred(context, attrs, |a| a.is_doc_comment());\n+    if !sugared_docs.is_empty() {\n+        let snippet = sugared_docs\n+            .iter()\n+            .map(|a| context.snippet(a.span))\n+            .collect::<Vec<_>>()\n+            .join(\"\\n\");\n+        return Some((\n+            sugared_docs.len(),\n+            Some(rewrite_doc_comment(\n+                &snippet,\n+                shape.comment(context.config),\n+                context.config,\n+            )?),\n+        ));\n+    }\n+\n+    Some((0, None))\n+}\n+\n+impl Rewrite for ast::NestedMetaItem {\n+    fn rewrite(&self, context: &RewriteContext<'_>, shape: Shape) -> Option<String> {\n+        match self {\n+            ast::NestedMetaItem::MetaItem(ref meta_item) => meta_item.rewrite(context, shape),\n+            ast::NestedMetaItem::Literal(ref l) => rewrite_literal(context, l, shape),\n+        }\n+    }\n+}\n+\n+fn has_newlines_before_after_comment(comment: &str) -> (&str, &str) {\n+    // Look at before and after comment and see if there are any empty lines.\n+    let comment_begin = comment.find('/');\n+    let len = comment_begin.unwrap_or_else(|| comment.len());\n+    let mlb = count_newlines(&comment[..len]) > 1;\n+    let mla = if comment_begin.is_none() {\n+        mlb\n+    } else {\n+        comment\n+            .chars()\n+            .rev()\n+            .take_while(|c| c.is_whitespace())\n+            .filter(|&c| c == '\\n')\n+            .count()\n+            > 1\n+    };\n+    (if mlb { \"\\n\" } else { \"\" }, if mla { \"\\n\" } else { \"\" })\n+}\n+\n+impl Rewrite for ast::MetaItem {\n+    fn rewrite(&self, context: &RewriteContext<'_>, shape: Shape) -> Option<String> {\n+        Some(match self.kind {\n+            ast::MetaItemKind::Word => {\n+                rewrite_path(context, PathContext::Type, None, &self.path, shape)?\n+            }\n+            ast::MetaItemKind::List(ref list) => {\n+                let path = rewrite_path(context, PathContext::Type, None, &self.path, shape)?;\n+                let has_trailing_comma = crate::expr::span_ends_with_comma(context, self.span);\n+                overflow::rewrite_with_parens(\n+                    context,\n+                    &path,\n+                    list.iter(),\n+                    // 1 = \"]\"\n+                    shape.sub_width(1)?,\n+                    self.span,\n+                    context.config.attr_fn_like_width(),\n+                    Some(if has_trailing_comma {\n+                        SeparatorTactic::Always\n+                    } else {\n+                        SeparatorTactic::Never\n+                    }),\n+                )?\n+            }\n+            ast::MetaItemKind::NameValue(ref literal) => {\n+                let path = rewrite_path(context, PathContext::Type, None, &self.path, shape)?;\n+                // 3 = ` = `\n+                let lit_shape = shape.shrink_left(path.len() + 3)?;\n+                // `rewrite_literal` returns `None` when `literal` exceeds max\n+                // width. Since a literal is basically unformattable unless it\n+                // is a string literal (and only if `format_strings` is set),\n+                // we might be better off ignoring the fact that the attribute\n+                // is longer than the max width and continue on formatting.\n+                // See #2479 for example.\n+                let value = rewrite_literal(context, literal, lit_shape)\n+                    .unwrap_or_else(|| context.snippet(literal.span).to_owned());\n+                format!(\"{} = {}\", path, value)\n+            }\n+        })\n+    }\n+}\n+\n+impl Rewrite for ast::Attribute {\n+    fn rewrite(&self, context: &RewriteContext<'_>, shape: Shape) -> Option<String> {\n+        let snippet = context.snippet(self.span);\n+        if self.is_doc_comment() {\n+            rewrite_doc_comment(snippet, shape.comment(context.config), context.config)\n+        } else {\n+            let should_skip = self\n+                .ident()\n+                .map(|s| context.skip_context.skip_attribute(&s.name.as_str()))\n+                .unwrap_or(false);\n+            let prefix = attr_prefix(self);\n+\n+            if should_skip || contains_comment(snippet) {\n+                return Some(snippet.to_owned());\n+            }\n+\n+            if let Some(ref meta) = self.meta() {\n+                // This attribute is possibly a doc attribute needing normalization to a doc comment\n+                if context.config.normalize_doc_attributes() && meta.has_name(sym::doc) {\n+                    if let Some(ref literal) = meta.value_str() {\n+                        let comment_style = match self.style {\n+                            ast::AttrStyle::Inner => CommentStyle::Doc,\n+                            ast::AttrStyle::Outer => CommentStyle::TripleSlash,\n+                        };\n+\n+                        let literal_str = literal.as_str();\n+                        let doc_comment_formatter =\n+                            DocCommentFormatter::new(&*literal_str, comment_style);\n+                        let doc_comment = format!(\"{}\", doc_comment_formatter);\n+                        return rewrite_doc_comment(\n+                            &doc_comment,\n+                            shape.comment(context.config),\n+                            context.config,\n+                        );\n+                    }\n+                }\n+\n+                // 1 = `[`\n+                let shape = shape.offset_left(prefix.len() + 1)?;\n+                Some(\n+                    meta.rewrite(context, shape)\n+                        .map_or_else(|| snippet.to_owned(), |rw| format!(\"{}[{}]\", prefix, rw)),\n+                )\n+            } else {\n+                Some(snippet.to_owned())\n+            }\n+        }\n+    }\n+}\n+\n+impl Rewrite for [ast::Attribute] {\n+    fn rewrite(&self, context: &RewriteContext<'_>, shape: Shape) -> Option<String> {\n+        if self.is_empty() {\n+            return Some(String::new());\n+        }\n+\n+        // The current remaining attributes.\n+        let mut attrs = self;\n+        let mut result = String::new();\n+\n+        // This is not just a simple map because we need to handle doc comments\n+        // (where we take as many doc comment attributes as possible) and possibly\n+        // merging derives into a single attribute.\n+        loop {\n+            if attrs.is_empty() {\n+                return Some(result);\n+            }\n+\n+            // Handle doc comments.\n+            let (doc_comment_len, doc_comment_str) =\n+                rewrite_initial_doc_comments(context, attrs, shape)?;\n+            if doc_comment_len > 0 {\n+                let doc_comment_str = doc_comment_str.expect(\"doc comments, but no result\");\n+                result.push_str(&doc_comment_str);\n+\n+                let missing_span = attrs\n+                    .get(doc_comment_len)\n+                    .map(|next| mk_sp(attrs[doc_comment_len - 1].span.hi(), next.span.lo()));\n+                if let Some(missing_span) = missing_span {\n+                    let snippet = context.snippet(missing_span);\n+                    let (mla, mlb) = has_newlines_before_after_comment(snippet);\n+                    let comment = crate::comment::recover_missing_comment_in_span(\n+                        missing_span,\n+                        shape.with_max_width(context.config),\n+                        context,\n+                        0,\n+                    )?;\n+                    let comment = if comment.is_empty() {\n+                        format!(\"\\n{}\", mlb)\n+                    } else {\n+                        format!(\"{}{}\\n{}\", mla, comment, mlb)\n+                    };\n+                    result.push_str(&comment);\n+                    result.push_str(&shape.indent.to_string(context.config));\n+                }\n+\n+                attrs = &attrs[doc_comment_len..];\n+\n+                continue;\n+            }\n+\n+            // Handle derives if we will merge them.\n+            if context.config.merge_derives() && is_derive(&attrs[0]) {\n+                let derives = take_while_with_pred(context, attrs, is_derive);\n+                let derive_str = format_derive(derives, shape, context)?;\n+                result.push_str(&derive_str);\n+\n+                let missing_span = attrs\n+                    .get(derives.len())\n+                    .map(|next| mk_sp(attrs[derives.len() - 1].span.hi(), next.span.lo()));\n+                if let Some(missing_span) = missing_span {\n+                    let comment = crate::comment::recover_missing_comment_in_span(\n+                        missing_span,\n+                        shape.with_max_width(context.config),\n+                        context,\n+                        0,\n+                    )?;\n+                    result.push_str(&comment);\n+                    if let Some(next) = attrs.get(derives.len()) {\n+                        if next.is_doc_comment() {\n+                            let snippet = context.snippet(missing_span);\n+                            let (_, mlb) = has_newlines_before_after_comment(snippet);\n+                            result.push_str(&mlb);\n+                        }\n+                    }\n+                    result.push('\\n');\n+                    result.push_str(&shape.indent.to_string(context.config));\n+                }\n+\n+                attrs = &attrs[derives.len()..];\n+\n+                continue;\n+            }\n+\n+            // If we get here, then we have a regular attribute, just handle one\n+            // at a time.\n+\n+            let formatted_attr = attrs[0].rewrite(context, shape)?;\n+            result.push_str(&formatted_attr);\n+\n+            let missing_span = attrs\n+                .get(1)\n+                .map(|next| mk_sp(attrs[0].span.hi(), next.span.lo()));\n+            if let Some(missing_span) = missing_span {\n+                let comment = crate::comment::recover_missing_comment_in_span(\n+                    missing_span,\n+                    shape.with_max_width(context.config),\n+                    context,\n+                    0,\n+                )?;\n+                result.push_str(&comment);\n+                if let Some(next) = attrs.get(1) {\n+                    if next.is_doc_comment() {\n+                        let snippet = context.snippet(missing_span);\n+                        let (_, mlb) = has_newlines_before_after_comment(snippet);\n+                        result.push_str(&mlb);\n+                    }\n+                }\n+                result.push('\\n');\n+                result.push_str(&shape.indent.to_string(context.config));\n+            }\n+\n+            attrs = &attrs[1..];\n+        }\n+    }\n+}\n+\n+fn attr_prefix(attr: &ast::Attribute) -> &'static str {\n+    match attr.style {\n+        ast::AttrStyle::Inner => \"#!\",\n+        ast::AttrStyle::Outer => \"#\",\n+    }\n+}\n+\n+pub(crate) trait MetaVisitor<'ast> {\n+    fn visit_meta_item(&mut self, meta_item: &'ast ast::MetaItem) {\n+        match meta_item.kind {\n+            ast::MetaItemKind::Word => self.visit_meta_word(meta_item),\n+            ast::MetaItemKind::List(ref list) => self.visit_meta_list(meta_item, list),\n+            ast::MetaItemKind::NameValue(ref lit) => self.visit_meta_name_value(meta_item, lit),\n+        }\n+    }\n+\n+    fn visit_meta_list(\n+        &mut self,\n+        _meta_item: &'ast ast::MetaItem,\n+        list: &'ast [ast::NestedMetaItem],\n+    ) {\n+        for nm in list {\n+            self.visit_nested_meta_item(nm);\n+        }\n+    }\n+\n+    fn visit_meta_word(&mut self, _meta_item: &'ast ast::MetaItem) {}\n+\n+    fn visit_meta_name_value(&mut self, _meta_item: &'ast ast::MetaItem, _lit: &'ast ast::Lit) {}\n+\n+    fn visit_nested_meta_item(&mut self, nm: &'ast ast::NestedMetaItem) {\n+        match nm {\n+            ast::NestedMetaItem::MetaItem(ref meta_item) => self.visit_meta_item(meta_item),\n+            ast::NestedMetaItem::Literal(ref lit) => self.visit_literal(lit),\n+        }\n+    }\n+\n+    fn visit_literal(&mut self, _lit: &'ast ast::Lit) {}\n+}"}, {"sha": "c3dcb84c9488d53b001f5febb9c8803039f9a27c", "filename": "src/tools/rustfmt/src/attr/doc_comment.rs", "status": "added", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Fsrc%2Fattr%2Fdoc_comment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Fsrc%2Fattr%2Fdoc_comment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fsrc%2Fattr%2Fdoc_comment.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782", "patch": "@@ -0,0 +1,83 @@\n+use crate::comment::CommentStyle;\n+use std::fmt::{self, Display};\n+\n+/// Formats a string as a doc comment using the given [`CommentStyle`].\n+#[derive(new)]\n+pub(super) struct DocCommentFormatter<'a> {\n+    literal: &'a str,\n+    style: CommentStyle<'a>,\n+}\n+\n+impl Display for DocCommentFormatter<'_> {\n+    fn fmt(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        let opener = self.style.opener().trim_end();\n+        let mut lines = self.literal.lines().peekable();\n+\n+        // Handle `#[doc = \"\"]`.\n+        if lines.peek().is_none() {\n+            return write!(formatter, \"{}\", opener);\n+        }\n+\n+        while let Some(line) = lines.next() {\n+            let is_last_line = lines.peek().is_none();\n+            if is_last_line {\n+                write!(formatter, \"{}{}\", opener, line)?;\n+            } else {\n+                writeln!(formatter, \"{}{}\", opener, line)?;\n+            }\n+        }\n+        Ok(())\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+\n+    #[test]\n+    fn literal_controls_leading_spaces() {\n+        test_doc_comment_is_formatted_correctly(\n+            \"    Lorem ipsum\",\n+            \"///    Lorem ipsum\",\n+            CommentStyle::TripleSlash,\n+        );\n+    }\n+\n+    #[test]\n+    fn single_line_doc_comment_is_formatted_correctly() {\n+        test_doc_comment_is_formatted_correctly(\n+            \"Lorem ipsum\",\n+            \"///Lorem ipsum\",\n+            CommentStyle::TripleSlash,\n+        );\n+    }\n+\n+    #[test]\n+    fn multi_line_doc_comment_is_formatted_correctly() {\n+        test_doc_comment_is_formatted_correctly(\n+            \"Lorem ipsum\\nDolor sit amet\",\n+            \"///Lorem ipsum\\n///Dolor sit amet\",\n+            CommentStyle::TripleSlash,\n+        );\n+    }\n+\n+    #[test]\n+    fn whitespace_within_lines_is_preserved() {\n+        test_doc_comment_is_formatted_correctly(\n+            \" Lorem ipsum \\n Dolor sit amet \",\n+            \"/// Lorem ipsum \\n/// Dolor sit amet \",\n+            CommentStyle::TripleSlash,\n+        );\n+    }\n+\n+    fn test_doc_comment_is_formatted_correctly(\n+        literal: &str,\n+        expected_comment: &str,\n+        style: CommentStyle<'_>,\n+    ) {\n+        assert_eq!(\n+            expected_comment,\n+            format!(\"{}\", DocCommentFormatter::new(&literal, style))\n+        );\n+    }\n+}"}, {"sha": "56b07222212f899ca47ed017b7286f3661639f3c", "filename": "src/tools/rustfmt/src/bin/main.rs", "status": "added", "additions": 705, "deletions": 0, "changes": 705, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Fsrc%2Fbin%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Fsrc%2Fbin%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fsrc%2Fbin%2Fmain.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782", "patch": "@@ -0,0 +1,705 @@\n+use anyhow::{format_err, Result};\n+\n+use io::Error as IoError;\n+use thiserror::Error;\n+\n+use rustfmt_nightly as rustfmt;\n+\n+use std::collections::HashMap;\n+use std::env;\n+use std::fs::File;\n+use std::io::{self, stdout, Read, Write};\n+use std::path::{Path, PathBuf};\n+use std::str::FromStr;\n+\n+use getopts::{Matches, Options};\n+\n+use crate::rustfmt::{\n+    load_config, CliOptions, Color, Config, Edition, EmitMode, FileLines, FileName,\n+    FormatReportFormatterBuilder, Input, Session, Verbosity,\n+};\n+\n+fn main() {\n+    env_logger::init();\n+    let opts = make_opts();\n+\n+    let exit_code = match execute(&opts) {\n+        Ok(code) => code,\n+        Err(e) => {\n+            eprintln!(\"{}\", e.to_string());\n+            1\n+        }\n+    };\n+    // Make sure standard output is flushed before we exit.\n+    std::io::stdout().flush().unwrap();\n+\n+    // Exit with given exit code.\n+    //\n+    // NOTE: this immediately terminates the process without doing any cleanup,\n+    // so make sure to finish all necessary cleanup before this is called.\n+    std::process::exit(exit_code);\n+}\n+\n+/// Rustfmt operations.\n+enum Operation {\n+    /// Format files and their child modules.\n+    Format {\n+        files: Vec<PathBuf>,\n+        minimal_config_path: Option<String>,\n+    },\n+    /// Print the help message.\n+    Help(HelpOp),\n+    /// Print version information\n+    Version,\n+    /// Output default config to a file, or stdout if None\n+    ConfigOutputDefault { path: Option<String> },\n+    /// Output current config (as if formatting to a file) to stdout\n+    ConfigOutputCurrent { path: Option<String> },\n+    /// No file specified, read from stdin\n+    Stdin { input: String },\n+}\n+\n+/// Rustfmt operations errors.\n+#[derive(Error, Debug)]\n+pub enum OperationError {\n+    /// An unknown help topic was requested.\n+    #[error(\"Unknown help topic: `{0}`.\")]\n+    UnknownHelpTopic(String),\n+    /// An unknown print-config option was requested.\n+    #[error(\"Unknown print-config option: `{0}`.\")]\n+    UnknownPrintConfigTopic(String),\n+    /// Attempt to generate a minimal config from standard input.\n+    #[error(\"The `--print-config=minimal` option doesn't work with standard input.\")]\n+    MinimalPathWithStdin,\n+    /// An io error during reading or writing.\n+    #[error(\"{0}\")]\n+    IoError(IoError),\n+    /// Attempt to use --check with stdin, which isn't currently\n+    /// supported.\n+    #[error(\"The `--check` option is not supported with standard input.\")]\n+    CheckWithStdin,\n+    /// Attempt to use --emit=json with stdin, which isn't currently\n+    /// supported.\n+    #[error(\"Using `--emit` other than stdout is not supported with standard input.\")]\n+    EmitWithStdin,\n+}\n+\n+impl From<IoError> for OperationError {\n+    fn from(e: IoError) -> OperationError {\n+        OperationError::IoError(e)\n+    }\n+}\n+\n+/// Arguments to `--help`\n+enum HelpOp {\n+    None,\n+    Config,\n+    FileLines,\n+}\n+\n+fn make_opts() -> Options {\n+    let mut opts = Options::new();\n+\n+    opts.optflag(\n+        \"\",\n+        \"check\",\n+        \"Run in 'check' mode. Exits with 0 if input is formatted correctly. Exits \\\n+         with 1 and prints a diff if formatting is required.\",\n+    );\n+    let is_nightly = is_nightly();\n+    let emit_opts = if is_nightly {\n+        \"[files|stdout|coverage|checkstyle|json]\"\n+    } else {\n+        \"[files|stdout]\"\n+    };\n+    opts.optopt(\"\", \"emit\", \"What data to emit and how\", emit_opts);\n+    opts.optflag(\"\", \"backup\", \"Backup any modified files.\");\n+    opts.optopt(\n+        \"\",\n+        \"config-path\",\n+        \"Recursively searches the given path for the rustfmt.toml config file. If not \\\n+         found reverts to the input file path\",\n+        \"[Path for the configuration file]\",\n+    );\n+    opts.optopt(\"\", \"edition\", \"Rust edition to use\", \"[2015|2018]\");\n+    opts.optopt(\n+        \"\",\n+        \"color\",\n+        \"Use colored output (if supported)\",\n+        \"[always|never|auto]\",\n+    );\n+    opts.optopt(\n+        \"\",\n+        \"print-config\",\n+        \"Dumps a default or minimal config to PATH. A minimal config is the \\\n+         subset of the current config file used for formatting the current program. \\\n+         `current` writes to stdout current config as if formatting the file at PATH.\",\n+        \"[default|minimal|current] PATH\",\n+    );\n+    opts.optflag(\n+        \"l\",\n+        \"files-with-diff\",\n+        \"Prints the names of mismatched files that were formatted. Prints the names of \\\n+         files that would be formated when used with `--check` mode. \",\n+    );\n+    opts.optmulti(\n+        \"\",\n+        \"config\",\n+        \"Set options from command line. These settings take priority over .rustfmt.toml\",\n+        \"[key1=val1,key2=val2...]\",\n+    );\n+\n+    if is_nightly {\n+        opts.optflag(\n+            \"\",\n+            \"unstable-features\",\n+            \"Enables unstable features. Only available on nightly channel.\",\n+        );\n+        opts.optopt(\n+            \"\",\n+            \"file-lines\",\n+            \"Format specified line ranges. Run with `--help=file-lines` for \\\n+             more detail (unstable).\",\n+            \"JSON\",\n+        );\n+        opts.optflag(\n+            \"\",\n+            \"error-on-unformatted\",\n+            \"Error if unable to get comments or string literals within max_width, \\\n+             or they are left with trailing whitespaces (unstable).\",\n+        );\n+        opts.optflag(\n+            \"\",\n+            \"skip-children\",\n+            \"Don't reformat child modules (unstable).\",\n+        );\n+    }\n+\n+    opts.optflag(\"v\", \"verbose\", \"Print verbose output\");\n+    opts.optflag(\"q\", \"quiet\", \"Print less output\");\n+    opts.optflag(\"V\", \"version\", \"Show version information\");\n+    opts.optflagopt(\n+        \"h\",\n+        \"help\",\n+        \"Show this message or help about a specific topic: `config` or `file-lines`\",\n+        \"=TOPIC\",\n+    );\n+\n+    opts\n+}\n+\n+fn is_nightly() -> bool {\n+    option_env!(\"CFG_RELEASE_CHANNEL\").map_or(true, |c| c == \"nightly\" || c == \"dev\")\n+}\n+\n+// Returned i32 is an exit code\n+fn execute(opts: &Options) -> Result<i32> {\n+    let matches = opts.parse(env::args().skip(1))?;\n+    let options = GetOptsOptions::from_matches(&matches)?;\n+\n+    match determine_operation(&matches)? {\n+        Operation::Help(HelpOp::None) => {\n+            print_usage_to_stdout(opts, \"\");\n+            Ok(0)\n+        }\n+        Operation::Help(HelpOp::Config) => {\n+            Config::print_docs(&mut stdout(), options.unstable_features);\n+            Ok(0)\n+        }\n+        Operation::Help(HelpOp::FileLines) => {\n+            print_help_file_lines();\n+            Ok(0)\n+        }\n+        Operation::Version => {\n+            print_version();\n+            Ok(0)\n+        }\n+        Operation::ConfigOutputDefault { path } => {\n+            let toml = Config::default().all_options().to_toml()?;\n+            if let Some(path) = path {\n+                let mut file = File::create(path)?;\n+                file.write_all(toml.as_bytes())?;\n+            } else {\n+                io::stdout().write_all(toml.as_bytes())?;\n+            }\n+            Ok(0)\n+        }\n+        Operation::ConfigOutputCurrent { path } => {\n+            let path = match path {\n+                Some(path) => path,\n+                None => return Err(format_err!(\"PATH required for `--print-config current`\")),\n+            };\n+\n+            let file = PathBuf::from(path);\n+            let file = file.canonicalize().unwrap_or(file);\n+\n+            let (config, _) = load_config(Some(file.parent().unwrap()), Some(options))?;\n+            let toml = config.all_options().to_toml()?;\n+            io::stdout().write_all(toml.as_bytes())?;\n+\n+            Ok(0)\n+        }\n+        Operation::Stdin { input } => format_string(input, options),\n+        Operation::Format {\n+            files,\n+            minimal_config_path,\n+        } => format(files, minimal_config_path, &options),\n+    }\n+}\n+\n+fn format_string(input: String, options: GetOptsOptions) -> Result<i32> {\n+    // try to read config from local directory\n+    let (mut config, _) = load_config(Some(Path::new(\".\")), Some(options.clone()))?;\n+\n+    if options.check {\n+        return Err(OperationError::CheckWithStdin.into());\n+    }\n+    if let Some(emit_mode) = options.emit_mode {\n+        if emit_mode != EmitMode::Stdout {\n+            return Err(OperationError::EmitWithStdin.into());\n+        }\n+    }\n+    // emit mode is always Stdout for Stdin.\n+    config.set().emit_mode(EmitMode::Stdout);\n+    config.set().verbose(Verbosity::Quiet);\n+\n+    // parse file_lines\n+    config.set().file_lines(options.file_lines);\n+    for f in config.file_lines().files() {\n+        match *f {\n+            FileName::Stdin => {}\n+            _ => eprintln!(\"Warning: Extra file listed in file_lines option '{}'\", f),\n+        }\n+    }\n+\n+    let out = &mut stdout();\n+    let mut session = Session::new(config, Some(out));\n+    format_and_emit_report(&mut session, Input::Text(input));\n+\n+    let exit_code = if session.has_operational_errors() || session.has_parsing_errors() {\n+        1\n+    } else {\n+        0\n+    };\n+    Ok(exit_code)\n+}\n+\n+fn format(\n+    files: Vec<PathBuf>,\n+    minimal_config_path: Option<String>,\n+    options: &GetOptsOptions,\n+) -> Result<i32> {\n+    options.verify_file_lines(&files);\n+    let (config, config_path) = load_config(None, Some(options.clone()))?;\n+\n+    if config.verbose() == Verbosity::Verbose {\n+        if let Some(path) = config_path.as_ref() {\n+            println!(\"Using rustfmt config file {}\", path.display());\n+        }\n+    }\n+\n+    let out = &mut stdout();\n+    let mut session = Session::new(config, Some(out));\n+\n+    for file in files {\n+        if !file.exists() {\n+            eprintln!(\"Error: file `{}` does not exist\", file.to_str().unwrap());\n+            session.add_operational_error();\n+        } else if file.is_dir() {\n+            eprintln!(\"Error: `{}` is a directory\", file.to_str().unwrap());\n+            session.add_operational_error();\n+        } else {\n+            // Check the file directory if the config-path could not be read or not provided\n+            if config_path.is_none() {\n+                let (local_config, config_path) =\n+                    load_config(Some(file.parent().unwrap()), Some(options.clone()))?;\n+                if local_config.verbose() == Verbosity::Verbose {\n+                    if let Some(path) = config_path {\n+                        println!(\n+                            \"Using rustfmt config file {} for {}\",\n+                            path.display(),\n+                            file.display()\n+                        );\n+                    }\n+                }\n+\n+                session.override_config(local_config, |sess| {\n+                    format_and_emit_report(sess, Input::File(file))\n+                });\n+            } else {\n+                format_and_emit_report(&mut session, Input::File(file));\n+            }\n+        }\n+    }\n+\n+    // If we were given a path via dump-minimal-config, output any options\n+    // that were used during formatting as TOML.\n+    if let Some(path) = minimal_config_path {\n+        let mut file = File::create(path)?;\n+        let toml = session.config.used_options().to_toml()?;\n+        file.write_all(toml.as_bytes())?;\n+    }\n+\n+    let exit_code = if session.has_operational_errors()\n+        || session.has_parsing_errors()\n+        || ((session.has_diff() || session.has_check_errors()) && options.check)\n+    {\n+        1\n+    } else {\n+        0\n+    };\n+    Ok(exit_code)\n+}\n+\n+fn format_and_emit_report<T: Write>(session: &mut Session<'_, T>, input: Input) {\n+    match session.format(input) {\n+        Ok(report) => {\n+            if report.has_warnings() {\n+                eprintln!(\n+                    \"{}\",\n+                    FormatReportFormatterBuilder::new(&report)\n+                        .enable_colors(should_print_with_colors(session))\n+                        .build()\n+                );\n+            }\n+        }\n+        Err(msg) => {\n+            eprintln!(\"Error writing files: {}\", msg);\n+            session.add_operational_error();\n+        }\n+    }\n+}\n+\n+fn should_print_with_colors<T: Write>(session: &mut Session<'_, T>) -> bool {\n+    match term::stderr() {\n+        Some(ref t)\n+            if session.config.color().use_colored_tty()\n+                && t.supports_color()\n+                && t.supports_attr(term::Attr::Bold) =>\n+        {\n+            true\n+        }\n+        _ => false,\n+    }\n+}\n+\n+fn print_usage_to_stdout(opts: &Options, reason: &str) {\n+    let sep = if reason.is_empty() {\n+        String::new()\n+    } else {\n+        format!(\"{}\\n\\n\", reason)\n+    };\n+    let msg = format!(\n+        \"{}Format Rust code\\n\\nusage: {} [options] <file>...\",\n+        sep,\n+        env::args_os().next().unwrap().to_string_lossy()\n+    );\n+    println!(\"{}\", opts.usage(&msg));\n+}\n+\n+fn print_help_file_lines() {\n+    println!(\n+        \"If you want to restrict reformatting to specific sets of lines, you can\n+use the `--file-lines` option. Its argument is a JSON array of objects\n+with `file` and `range` properties, where `file` is a file name, and\n+`range` is an array representing a range of lines like `[7,13]`. Ranges\n+are 1-based and inclusive of both end points. Specifying an empty array\n+will result in no files being formatted. For example,\n+\n+```\n+rustfmt --file-lines '[\n+    {{\\\"file\\\":\\\"src/lib.rs\\\",\\\"range\\\":[7,13]}},\n+    {{\\\"file\\\":\\\"src/lib.rs\\\",\\\"range\\\":[21,29]}},\n+    {{\\\"file\\\":\\\"src/foo.rs\\\",\\\"range\\\":[10,11]}},\n+    {{\\\"file\\\":\\\"src/foo.rs\\\",\\\"range\\\":[15,15]}}]'\n+```\n+\n+would format lines `7-13` and `21-29` of `src/lib.rs`, and lines `10-11`,\n+and `15` of `src/foo.rs`. No other files would be formatted, even if they\n+are included as out of line modules from `src/lib.rs`.\"\n+    );\n+}\n+\n+fn print_version() {\n+    let version_info = format!(\n+        \"{}-{}\",\n+        option_env!(\"CARGO_PKG_VERSION\").unwrap_or(\"unknown\"),\n+        include_str!(concat!(env!(\"OUT_DIR\"), \"/commit-info.txt\"))\n+    );\n+\n+    println!(\"rustfmt {}\", version_info);\n+}\n+\n+fn determine_operation(matches: &Matches) -> Result<Operation, OperationError> {\n+    if matches.opt_present(\"h\") {\n+        let topic = matches.opt_str(\"h\");\n+        if topic == None {\n+            return Ok(Operation::Help(HelpOp::None));\n+        } else if topic == Some(\"config\".to_owned()) {\n+            return Ok(Operation::Help(HelpOp::Config));\n+        } else if topic == Some(\"file-lines\".to_owned()) {\n+            return Ok(Operation::Help(HelpOp::FileLines));\n+        } else {\n+            return Err(OperationError::UnknownHelpTopic(topic.unwrap()));\n+        }\n+    }\n+    let mut free_matches = matches.free.iter();\n+\n+    let mut minimal_config_path = None;\n+    if let Some(kind) = matches.opt_str(\"print-config\") {\n+        let path = free_matches.next().cloned();\n+        match kind.as_str() {\n+            \"default\" => return Ok(Operation::ConfigOutputDefault { path }),\n+            \"current\" => return Ok(Operation::ConfigOutputCurrent { path }),\n+            \"minimal\" => {\n+                minimal_config_path = path;\n+                if minimal_config_path.is_none() {\n+                    eprintln!(\"WARNING: PATH required for `--print-config minimal`.\");\n+                }\n+            }\n+            _ => {\n+                return Err(OperationError::UnknownPrintConfigTopic(kind));\n+            }\n+        }\n+    }\n+\n+    if matches.opt_present(\"version\") {\n+        return Ok(Operation::Version);\n+    }\n+\n+    let files: Vec<_> = free_matches\n+        .map(|s| {\n+            let p = PathBuf::from(s);\n+            // we will do comparison later, so here tries to canonicalize first\n+            // to get the expected behavior.\n+            p.canonicalize().unwrap_or(p)\n+        })\n+        .collect();\n+\n+    // if no file argument is supplied, read from stdin\n+    if files.is_empty() {\n+        if minimal_config_path.is_some() {\n+            return Err(OperationError::MinimalPathWithStdin);\n+        }\n+        let mut buffer = String::new();\n+        io::stdin().read_to_string(&mut buffer)?;\n+\n+        return Ok(Operation::Stdin { input: buffer });\n+    }\n+\n+    Ok(Operation::Format {\n+        files,\n+        minimal_config_path,\n+    })\n+}\n+\n+const STABLE_EMIT_MODES: [EmitMode; 3] = [EmitMode::Files, EmitMode::Stdout, EmitMode::Diff];\n+\n+/// Parsed command line options.\n+#[derive(Clone, Debug, Default)]\n+struct GetOptsOptions {\n+    skip_children: Option<bool>,\n+    quiet: bool,\n+    verbose: bool,\n+    config_path: Option<PathBuf>,\n+    inline_config: HashMap<String, String>,\n+    emit_mode: Option<EmitMode>,\n+    backup: bool,\n+    check: bool,\n+    edition: Option<Edition>,\n+    color: Option<Color>,\n+    file_lines: FileLines, // Default is all lines in all files.\n+    unstable_features: bool,\n+    error_on_unformatted: Option<bool>,\n+    print_misformatted_file_names: bool,\n+}\n+\n+impl GetOptsOptions {\n+    pub fn from_matches(matches: &Matches) -> Result<GetOptsOptions> {\n+        let mut options = GetOptsOptions::default();\n+        options.verbose = matches.opt_present(\"verbose\");\n+        options.quiet = matches.opt_present(\"quiet\");\n+        if options.verbose && options.quiet {\n+            return Err(format_err!(\"Can't use both `--verbose` and `--quiet`\"));\n+        }\n+\n+        let rust_nightly = is_nightly();\n+\n+        if rust_nightly {\n+            options.unstable_features = matches.opt_present(\"unstable-features\");\n+\n+            if options.unstable_features {\n+                if matches.opt_present(\"skip-children\") {\n+                    options.skip_children = Some(true);\n+                }\n+                if matches.opt_present(\"error-on-unformatted\") {\n+                    options.error_on_unformatted = Some(true);\n+                }\n+                if let Some(ref file_lines) = matches.opt_str(\"file-lines\") {\n+                    options.file_lines = file_lines.parse()?;\n+                }\n+            } else {\n+                let mut unstable_options = vec![];\n+                if matches.opt_present(\"skip-children\") {\n+                    unstable_options.push(\"`--skip-children`\");\n+                }\n+                if matches.opt_present(\"error-on-unformatted\") {\n+                    unstable_options.push(\"`--error-on-unformatted`\");\n+                }\n+                if matches.opt_present(\"file-lines\") {\n+                    unstable_options.push(\"`--file-lines`\");\n+                }\n+                if !unstable_options.is_empty() {\n+                    let s = if unstable_options.len() == 1 { \"\" } else { \"s\" };\n+                    return Err(format_err!(\n+                        \"Unstable option{} ({}) used without `--unstable-features`\",\n+                        s,\n+                        unstable_options.join(\", \"),\n+                    ));\n+                }\n+            }\n+        }\n+\n+        options.config_path = matches.opt_str(\"config-path\").map(PathBuf::from);\n+\n+        options.inline_config = matches\n+            .opt_strs(\"config\")\n+            .iter()\n+            .flat_map(|config| config.split(','))\n+            .map(\n+                |key_val| match key_val.char_indices().find(|(_, ch)| *ch == '=') {\n+                    Some((middle, _)) => {\n+                        let (key, val) = (&key_val[..middle], &key_val[middle + 1..]);\n+                        if !Config::is_valid_key_val(key, val) {\n+                            Err(format_err!(\"invalid key=val pair: `{}`\", key_val))\n+                        } else {\n+                            Ok((key.to_string(), val.to_string()))\n+                        }\n+                    }\n+\n+                    None => Err(format_err!(\n+                        \"--config expects comma-separated list of key=val pairs, found `{}`\",\n+                        key_val\n+                    )),\n+                },\n+            )\n+            .collect::<Result<HashMap<_, _>, _>>()?;\n+\n+        options.check = matches.opt_present(\"check\");\n+        if let Some(ref emit_str) = matches.opt_str(\"emit\") {\n+            if options.check {\n+                return Err(format_err!(\"Invalid to use `--emit` and `--check`\"));\n+            }\n+\n+            options.emit_mode = Some(emit_mode_from_emit_str(emit_str)?);\n+        }\n+\n+        if let Some(ref edition_str) = matches.opt_str(\"edition\") {\n+            options.edition = Some(edition_from_edition_str(edition_str)?);\n+        }\n+\n+        if matches.opt_present(\"backup\") {\n+            options.backup = true;\n+        }\n+\n+        if matches.opt_present(\"files-with-diff\") {\n+            options.print_misformatted_file_names = true;\n+        }\n+\n+        if !rust_nightly {\n+            if let Some(ref emit_mode) = options.emit_mode {\n+                if !STABLE_EMIT_MODES.contains(emit_mode) {\n+                    return Err(format_err!(\n+                        \"Invalid value for `--emit` - using an unstable \\\n+                         value without `--unstable-features`\",\n+                    ));\n+                }\n+            }\n+        }\n+\n+        if let Some(ref color) = matches.opt_str(\"color\") {\n+            match Color::from_str(color) {\n+                Ok(color) => options.color = Some(color),\n+                _ => return Err(format_err!(\"Invalid color: {}\", color)),\n+            }\n+        }\n+\n+        Ok(options)\n+    }\n+\n+    fn verify_file_lines(&self, files: &[PathBuf]) {\n+        for f in self.file_lines.files() {\n+            match *f {\n+                FileName::Real(ref f) if files.contains(f) => {}\n+                FileName::Real(_) => {\n+                    eprintln!(\"Warning: Extra file listed in file_lines option '{}'\", f)\n+                }\n+                FileName::Stdin => eprintln!(\"Warning: Not a file '{}'\", f),\n+            }\n+        }\n+    }\n+}\n+\n+impl CliOptions for GetOptsOptions {\n+    fn apply_to(self, config: &mut Config) {\n+        if self.verbose {\n+            config.set().verbose(Verbosity::Verbose);\n+        } else if self.quiet {\n+            config.set().verbose(Verbosity::Quiet);\n+        } else {\n+            config.set().verbose(Verbosity::Normal);\n+        }\n+        config.set().file_lines(self.file_lines);\n+        config.set().unstable_features(self.unstable_features);\n+        if let Some(skip_children) = self.skip_children {\n+            config.set().skip_children(skip_children);\n+        }\n+        if let Some(error_on_unformatted) = self.error_on_unformatted {\n+            config.set().error_on_unformatted(error_on_unformatted);\n+        }\n+        if let Some(edition) = self.edition {\n+            config.set().edition(edition);\n+        }\n+        if self.check {\n+            config.set().emit_mode(EmitMode::Diff);\n+        } else if let Some(emit_mode) = self.emit_mode {\n+            config.set().emit_mode(emit_mode);\n+        }\n+        if self.backup {\n+            config.set().make_backup(true);\n+        }\n+        if let Some(color) = self.color {\n+            config.set().color(color);\n+        }\n+        if self.print_misformatted_file_names {\n+            config.set().print_misformatted_file_names(true);\n+        }\n+\n+        for (key, val) in self.inline_config {\n+            config.override_value(&key, &val);\n+        }\n+    }\n+\n+    fn config_path(&self) -> Option<&Path> {\n+        self.config_path.as_deref()\n+    }\n+}\n+\n+fn edition_from_edition_str(edition_str: &str) -> Result<Edition> {\n+    match edition_str {\n+        \"2015\" => Ok(Edition::Edition2015),\n+        \"2018\" => Ok(Edition::Edition2018),\n+        _ => Err(format_err!(\"Invalid value for `--edition`\")),\n+    }\n+}\n+\n+fn emit_mode_from_emit_str(emit_str: &str) -> Result<EmitMode> {\n+    match emit_str {\n+        \"files\" => Ok(EmitMode::Files),\n+        \"stdout\" => Ok(EmitMode::Stdout),\n+        \"coverage\" => Ok(EmitMode::Coverage),\n+        \"checkstyle\" => Ok(EmitMode::Checkstyle),\n+        \"json\" => Ok(EmitMode::Json),\n+        _ => Err(format_err!(\"Invalid value for `--emit`\")),\n+    }\n+}"}, {"sha": "9062a2952ec1a30d0ba5d96e7c67b86cd73216cd", "filename": "src/tools/rustfmt/src/cargo-fmt/main.rs", "status": "added", "additions": 760, "deletions": 0, "changes": 760, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Fsrc%2Fcargo-fmt%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Fsrc%2Fcargo-fmt%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fsrc%2Fcargo-fmt%2Fmain.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782", "patch": "@@ -0,0 +1,760 @@\n+// Inspired by Paul Woolcock's cargo-fmt (https://github.com/pwoolcoc/cargo-fmt/).\n+\n+#![deny(warnings)]\n+\n+use std::cmp::Ordering;\n+use std::collections::{BTreeMap, BTreeSet};\n+use std::env;\n+use std::ffi::OsStr;\n+use std::fs;\n+use std::hash::{Hash, Hasher};\n+use std::io::{self, Write};\n+use std::iter::FromIterator;\n+use std::path::{Path, PathBuf};\n+use std::process::Command;\n+use std::str;\n+\n+use structopt::StructOpt;\n+\n+#[derive(StructOpt, Debug)]\n+#[structopt(\n+    bin_name = \"cargo fmt\",\n+    about = \"This utility formats all bin and lib files of \\\n+             the current crate using rustfmt.\"\n+)]\n+pub struct Opts {\n+    /// No output printed to stdout\n+    #[structopt(short = \"q\", long = \"quiet\")]\n+    quiet: bool,\n+\n+    /// Use verbose output\n+    #[structopt(short = \"v\", long = \"verbose\")]\n+    verbose: bool,\n+\n+    /// Print rustfmt version and exit\n+    #[structopt(long = \"version\")]\n+    version: bool,\n+\n+    /// Specify package to format (only usable in workspaces)\n+    #[structopt(short = \"p\", long = \"package\", value_name = \"package\")]\n+    packages: Vec<String>,\n+\n+    /// Specify path to Cargo.toml\n+    #[structopt(long = \"manifest-path\", value_name = \"manifest-path\")]\n+    manifest_path: Option<String>,\n+\n+    /// Specify message-format: short|json|human\n+    #[structopt(long = \"message-format\", value_name = \"message-format\")]\n+    message_format: Option<String>,\n+\n+    /// Options passed to rustfmt\n+    // 'raw = true' to make `--` explicit.\n+    #[structopt(name = \"rustfmt_options\", raw(true))]\n+    rustfmt_options: Vec<String>,\n+\n+    /// Format all packages (only usable in workspaces)\n+    #[structopt(long = \"all\")]\n+    format_all: bool,\n+}\n+\n+fn main() {\n+    let exit_status = execute();\n+    std::io::stdout().flush().unwrap();\n+    std::process::exit(exit_status);\n+}\n+\n+const SUCCESS: i32 = 0;\n+const FAILURE: i32 = 1;\n+\n+fn execute() -> i32 {\n+    // Drop extra `fmt` argument provided by `cargo`.\n+    let mut found_fmt = false;\n+    let args = env::args().filter(|x| {\n+        if found_fmt {\n+            true\n+        } else {\n+            found_fmt = x == \"fmt\";\n+            x != \"fmt\"\n+        }\n+    });\n+\n+    let opts = Opts::from_iter(args);\n+\n+    let verbosity = match (opts.verbose, opts.quiet) {\n+        (false, false) => Verbosity::Normal,\n+        (false, true) => Verbosity::Quiet,\n+        (true, false) => Verbosity::Verbose,\n+        (true, true) => {\n+            print_usage_to_stderr(\"quiet mode and verbose mode are not compatible\");\n+            return FAILURE;\n+        }\n+    };\n+\n+    if opts.version {\n+        return handle_command_status(get_rustfmt_info(&[String::from(\"--version\")]));\n+    }\n+    if opts.rustfmt_options.iter().any(|s| {\n+        [\"--print-config\", \"-h\", \"--help\", \"-V\", \"--version\"].contains(&s.as_str())\n+            || s.starts_with(\"--help=\")\n+            || s.starts_with(\"--print-config=\")\n+    }) {\n+        return handle_command_status(get_rustfmt_info(&opts.rustfmt_options));\n+    }\n+\n+    let strategy = CargoFmtStrategy::from_opts(&opts);\n+    let mut rustfmt_args = opts.rustfmt_options;\n+    if let Some(message_format) = opts.message_format {\n+        if let Err(msg) = convert_message_format_to_rustfmt_args(&message_format, &mut rustfmt_args)\n+        {\n+            print_usage_to_stderr(&msg);\n+            return FAILURE;\n+        }\n+    }\n+\n+    if let Some(specified_manifest_path) = opts.manifest_path {\n+        if !specified_manifest_path.ends_with(\"Cargo.toml\") {\n+            print_usage_to_stderr(\"the manifest-path must be a path to a Cargo.toml file\");\n+            return FAILURE;\n+        }\n+        let manifest_path = PathBuf::from(specified_manifest_path);\n+        handle_command_status(format_crate(\n+            verbosity,\n+            &strategy,\n+            rustfmt_args,\n+            Some(&manifest_path),\n+        ))\n+    } else {\n+        handle_command_status(format_crate(verbosity, &strategy, rustfmt_args, None))\n+    }\n+}\n+\n+fn rustfmt_command() -> Command {\n+    let rustfmt_var = env::var_os(\"RUSTFMT\");\n+    let rustfmt = match &rustfmt_var {\n+        Some(rustfmt) => rustfmt,\n+        None => OsStr::new(\"rustfmt\"),\n+    };\n+    Command::new(rustfmt)\n+}\n+\n+fn convert_message_format_to_rustfmt_args(\n+    message_format: &str,\n+    rustfmt_args: &mut Vec<String>,\n+) -> Result<(), String> {\n+    let mut contains_emit_mode = false;\n+    let mut contains_check = false;\n+    let mut contains_list_files = false;\n+    for arg in rustfmt_args.iter() {\n+        if arg.starts_with(\"--emit\") {\n+            contains_emit_mode = true;\n+        }\n+        if arg == \"--check\" {\n+            contains_check = true;\n+        }\n+        if arg == \"-l\" || arg == \"--files-with-diff\" {\n+            contains_list_files = true;\n+        }\n+    }\n+    match message_format {\n+        \"short\" => {\n+            if !contains_list_files {\n+                rustfmt_args.push(String::from(\"-l\"));\n+            }\n+            Ok(())\n+        }\n+        \"json\" => {\n+            if contains_emit_mode {\n+                return Err(String::from(\n+                    \"cannot include --emit arg when --message-format is set to json\",\n+                ));\n+            }\n+            if contains_check {\n+                return Err(String::from(\n+                    \"cannot include --check arg when --message-format is set to json\",\n+                ));\n+            }\n+            rustfmt_args.push(String::from(\"--emit\"));\n+            rustfmt_args.push(String::from(\"json\"));\n+            Ok(())\n+        }\n+        \"human\" => Ok(()),\n+        _ => {\n+            return Err(format!(\n+                \"invalid --message-format value: {}. Allowed values are: short|json|human\",\n+                message_format\n+            ));\n+        }\n+    }\n+}\n+\n+fn print_usage_to_stderr(reason: &str) {\n+    eprintln!(\"{}\", reason);\n+    let app = Opts::clap();\n+    app.after_help(\"\")\n+        .write_help(&mut io::stderr())\n+        .expect(\"failed to write to stderr\");\n+}\n+\n+#[derive(Debug, Clone, Copy, PartialEq)]\n+pub enum Verbosity {\n+    Verbose,\n+    Normal,\n+    Quiet,\n+}\n+\n+fn handle_command_status(status: Result<i32, io::Error>) -> i32 {\n+    match status {\n+        Err(e) => {\n+            print_usage_to_stderr(&e.to_string());\n+            FAILURE\n+        }\n+        Ok(status) => status,\n+    }\n+}\n+\n+fn get_rustfmt_info(args: &[String]) -> Result<i32, io::Error> {\n+    let mut command = rustfmt_command()\n+        .stdout(std::process::Stdio::inherit())\n+        .args(args)\n+        .spawn()\n+        .map_err(|e| match e.kind() {\n+            io::ErrorKind::NotFound => io::Error::new(\n+                io::ErrorKind::Other,\n+                \"Could not run rustfmt, please make sure it is in your PATH.\",\n+            ),\n+            _ => e,\n+        })?;\n+    let result = command.wait()?;\n+    if result.success() {\n+        Ok(SUCCESS)\n+    } else {\n+        Ok(result.code().unwrap_or(SUCCESS))\n+    }\n+}\n+\n+fn format_crate(\n+    verbosity: Verbosity,\n+    strategy: &CargoFmtStrategy,\n+    rustfmt_args: Vec<String>,\n+    manifest_path: Option<&Path>,\n+) -> Result<i32, io::Error> {\n+    let targets = get_targets(strategy, manifest_path)?;\n+\n+    // Currently only bin and lib files get formatted.\n+    run_rustfmt(&targets, &rustfmt_args, verbosity)\n+}\n+\n+/// Target uses a `path` field for equality and hashing.\n+#[derive(Debug)]\n+pub struct Target {\n+    /// A path to the main source file of the target.\n+    path: PathBuf,\n+    /// A kind of target (e.g., lib, bin, example, ...).\n+    kind: String,\n+    /// Rust edition for this target.\n+    edition: String,\n+}\n+\n+impl Target {\n+    pub fn from_target(target: &cargo_metadata::Target) -> Self {\n+        let path = PathBuf::from(&target.src_path);\n+        let canonicalized = fs::canonicalize(&path).unwrap_or(path);\n+\n+        Target {\n+            path: canonicalized,\n+            kind: target.kind[0].clone(),\n+            edition: target.edition.clone(),\n+        }\n+    }\n+}\n+\n+impl PartialEq for Target {\n+    fn eq(&self, other: &Target) -> bool {\n+        self.path == other.path\n+    }\n+}\n+\n+impl PartialOrd for Target {\n+    fn partial_cmp(&self, other: &Target) -> Option<Ordering> {\n+        Some(self.path.cmp(&other.path))\n+    }\n+}\n+\n+impl Ord for Target {\n+    fn cmp(&self, other: &Target) -> Ordering {\n+        self.path.cmp(&other.path)\n+    }\n+}\n+\n+impl Eq for Target {}\n+\n+impl Hash for Target {\n+    fn hash<H: Hasher>(&self, state: &mut H) {\n+        self.path.hash(state);\n+    }\n+}\n+\n+#[derive(Debug, PartialEq, Eq)]\n+pub enum CargoFmtStrategy {\n+    /// Format every packages and dependencies.\n+    All,\n+    /// Format packages that are specified by the command line argument.\n+    Some(Vec<String>),\n+    /// Format the root packages only.\n+    Root,\n+}\n+\n+impl CargoFmtStrategy {\n+    pub fn from_opts(opts: &Opts) -> CargoFmtStrategy {\n+        match (opts.format_all, opts.packages.is_empty()) {\n+            (false, true) => CargoFmtStrategy::Root,\n+            (true, _) => CargoFmtStrategy::All,\n+            (false, false) => CargoFmtStrategy::Some(opts.packages.clone()),\n+        }\n+    }\n+}\n+\n+/// Based on the specified `CargoFmtStrategy`, returns a set of main source files.\n+fn get_targets(\n+    strategy: &CargoFmtStrategy,\n+    manifest_path: Option<&Path>,\n+) -> Result<BTreeSet<Target>, io::Error> {\n+    let mut targets = BTreeSet::new();\n+\n+    match *strategy {\n+        CargoFmtStrategy::Root => get_targets_root_only(manifest_path, &mut targets)?,\n+        CargoFmtStrategy::All => {\n+            get_targets_recursive(manifest_path, &mut targets, &mut BTreeSet::new())?\n+        }\n+        CargoFmtStrategy::Some(ref hitlist) => {\n+            get_targets_with_hitlist(manifest_path, hitlist, &mut targets)?\n+        }\n+    }\n+\n+    if targets.is_empty() {\n+        Err(io::Error::new(\n+            io::ErrorKind::Other,\n+            \"Failed to find targets\".to_owned(),\n+        ))\n+    } else {\n+        Ok(targets)\n+    }\n+}\n+\n+fn get_targets_root_only(\n+    manifest_path: Option<&Path>,\n+    targets: &mut BTreeSet<Target>,\n+) -> Result<(), io::Error> {\n+    let metadata = get_cargo_metadata(manifest_path, false)?;\n+    let workspace_root_path = PathBuf::from(&metadata.workspace_root).canonicalize()?;\n+    let (in_workspace_root, current_dir_manifest) = if let Some(target_manifest) = manifest_path {\n+        (\n+            workspace_root_path == target_manifest,\n+            target_manifest.canonicalize()?,\n+        )\n+    } else {\n+        let current_dir = env::current_dir()?.canonicalize()?;\n+        (\n+            workspace_root_path == current_dir,\n+            current_dir.join(\"Cargo.toml\"),\n+        )\n+    };\n+\n+    let package_targets = match metadata.packages.len() {\n+        1 => metadata.packages.into_iter().next().unwrap().targets,\n+        _ => metadata\n+            .packages\n+            .into_iter()\n+            .filter(|p| {\n+                in_workspace_root\n+                    || PathBuf::from(&p.manifest_path)\n+                        .canonicalize()\n+                        .unwrap_or_default()\n+                        == current_dir_manifest\n+            })\n+            .map(|p| p.targets)\n+            .flatten()\n+            .collect(),\n+    };\n+\n+    for target in package_targets {\n+        targets.insert(Target::from_target(&target));\n+    }\n+\n+    Ok(())\n+}\n+\n+fn get_targets_recursive(\n+    manifest_path: Option<&Path>,\n+    mut targets: &mut BTreeSet<Target>,\n+    visited: &mut BTreeSet<String>,\n+) -> Result<(), io::Error> {\n+    let metadata = get_cargo_metadata(manifest_path, false)?;\n+    let metadata_with_deps = get_cargo_metadata(manifest_path, true)?;\n+\n+    for package in metadata.packages {\n+        add_targets(&package.targets, &mut targets);\n+\n+        // Look for local dependencies.\n+        for dependency in package.dependencies {\n+            if dependency.source.is_some() || visited.contains(&dependency.name) {\n+                continue;\n+            }\n+\n+            let dependency_package = metadata_with_deps\n+                .packages\n+                .iter()\n+                .find(|p| p.name == dependency.name && p.source.is_none());\n+            let manifest_path = if dependency_package.is_some() {\n+                PathBuf::from(&dependency_package.unwrap().manifest_path)\n+            } else {\n+                let mut package_manifest_path = PathBuf::from(&package.manifest_path);\n+                package_manifest_path.pop();\n+                package_manifest_path.push(&dependency.name);\n+                package_manifest_path.push(\"Cargo.toml\");\n+                package_manifest_path\n+            };\n+\n+            if manifest_path.exists() {\n+                visited.insert(dependency.name);\n+                get_targets_recursive(Some(&manifest_path), &mut targets, visited)?;\n+            }\n+        }\n+    }\n+\n+    Ok(())\n+}\n+\n+fn get_targets_with_hitlist(\n+    manifest_path: Option<&Path>,\n+    hitlist: &[String],\n+    targets: &mut BTreeSet<Target>,\n+) -> Result<(), io::Error> {\n+    let metadata = get_cargo_metadata(manifest_path, false)?;\n+\n+    let mut workspace_hitlist: BTreeSet<&String> = BTreeSet::from_iter(hitlist);\n+\n+    for package in metadata.packages {\n+        if workspace_hitlist.remove(&package.name) {\n+            for target in package.targets {\n+                targets.insert(Target::from_target(&target));\n+            }\n+        }\n+    }\n+\n+    if workspace_hitlist.is_empty() {\n+        Ok(())\n+    } else {\n+        let package = workspace_hitlist.iter().next().unwrap();\n+        Err(io::Error::new(\n+            io::ErrorKind::InvalidInput,\n+            format!(\"package `{}` is not a member of the workspace\", package),\n+        ))\n+    }\n+}\n+\n+fn add_targets(target_paths: &[cargo_metadata::Target], targets: &mut BTreeSet<Target>) {\n+    for target in target_paths {\n+        targets.insert(Target::from_target(target));\n+    }\n+}\n+\n+fn run_rustfmt(\n+    targets: &BTreeSet<Target>,\n+    fmt_args: &[String],\n+    verbosity: Verbosity,\n+) -> Result<i32, io::Error> {\n+    let by_edition = targets\n+        .iter()\n+        .inspect(|t| {\n+            if verbosity == Verbosity::Verbose {\n+                println!(\"[{} ({})] {:?}\", t.kind, t.edition, t.path)\n+            }\n+        })\n+        .fold(BTreeMap::new(), |mut h, t| {\n+            h.entry(&t.edition).or_insert_with(Vec::new).push(&t.path);\n+            h\n+        });\n+\n+    let mut status = vec![];\n+    for (edition, files) in by_edition {\n+        let stdout = if verbosity == Verbosity::Quiet {\n+            std::process::Stdio::null()\n+        } else {\n+            std::process::Stdio::inherit()\n+        };\n+\n+        if verbosity == Verbosity::Verbose {\n+            print!(\"rustfmt\");\n+            print!(\" --edition {}\", edition);\n+            fmt_args.iter().for_each(|f| print!(\" {}\", f));\n+            files.iter().for_each(|f| print!(\" {}\", f.display()));\n+            println!();\n+        }\n+\n+        let mut command = rustfmt_command()\n+            .stdout(stdout)\n+            .args(files)\n+            .args(&[\"--edition\", edition])\n+            .args(fmt_args)\n+            .spawn()\n+            .map_err(|e| match e.kind() {\n+                io::ErrorKind::NotFound => io::Error::new(\n+                    io::ErrorKind::Other,\n+                    \"Could not run rustfmt, please make sure it is in your PATH.\",\n+                ),\n+                _ => e,\n+            })?;\n+\n+        status.push(command.wait()?);\n+    }\n+\n+    Ok(status\n+        .iter()\n+        .filter_map(|s| if s.success() { None } else { s.code() })\n+        .next()\n+        .unwrap_or(SUCCESS))\n+}\n+\n+fn get_cargo_metadata(\n+    manifest_path: Option<&Path>,\n+    include_deps: bool,\n+) -> Result<cargo_metadata::Metadata, io::Error> {\n+    let mut cmd = cargo_metadata::MetadataCommand::new();\n+    if !include_deps {\n+        cmd.no_deps();\n+    }\n+    if let Some(manifest_path) = manifest_path {\n+        cmd.manifest_path(manifest_path);\n+    }\n+    cmd.other_options(&[String::from(\"--offline\")]);\n+\n+    match cmd.exec() {\n+        Ok(metadata) => Ok(metadata),\n+        Err(_) => {\n+            cmd.other_options(vec![]);\n+            match cmd.exec() {\n+                Ok(metadata) => Ok(metadata),\n+                Err(error) => Err(io::Error::new(io::ErrorKind::Other, error.to_string())),\n+            }\n+        }\n+    }\n+}\n+\n+#[cfg(test)]\n+mod cargo_fmt_tests {\n+    use super::*;\n+\n+    #[test]\n+    fn default_options() {\n+        let empty: Vec<String> = vec![];\n+        let o = Opts::from_iter(&empty);\n+        assert_eq!(false, o.quiet);\n+        assert_eq!(false, o.verbose);\n+        assert_eq!(false, o.version);\n+        assert_eq!(empty, o.packages);\n+        assert_eq!(empty, o.rustfmt_options);\n+        assert_eq!(false, o.format_all);\n+        assert_eq!(None, o.manifest_path);\n+        assert_eq!(None, o.message_format);\n+    }\n+\n+    #[test]\n+    fn good_options() {\n+        let o = Opts::from_iter(&[\n+            \"test\",\n+            \"-q\",\n+            \"-p\",\n+            \"p1\",\n+            \"-p\",\n+            \"p2\",\n+            \"--message-format\",\n+            \"short\",\n+            \"--\",\n+            \"--edition\",\n+            \"2018\",\n+        ]);\n+        assert_eq!(true, o.quiet);\n+        assert_eq!(false, o.verbose);\n+        assert_eq!(false, o.version);\n+        assert_eq!(vec![\"p1\", \"p2\"], o.packages);\n+        assert_eq!(vec![\"--edition\", \"2018\"], o.rustfmt_options);\n+        assert_eq!(false, o.format_all);\n+        assert_eq!(Some(String::from(\"short\")), o.message_format);\n+    }\n+\n+    #[test]\n+    fn unexpected_option() {\n+        assert!(\n+            Opts::clap()\n+                .get_matches_from_safe(&[\"test\", \"unexpected\"])\n+                .is_err()\n+        );\n+    }\n+\n+    #[test]\n+    fn unexpected_flag() {\n+        assert!(\n+            Opts::clap()\n+                .get_matches_from_safe(&[\"test\", \"--flag\"])\n+                .is_err()\n+        );\n+    }\n+\n+    #[test]\n+    fn mandatory_separator() {\n+        assert!(\n+            Opts::clap()\n+                .get_matches_from_safe(&[\"test\", \"--check\"])\n+                .is_err()\n+        );\n+        assert!(\n+            !Opts::clap()\n+                .get_matches_from_safe(&[\"test\", \"--\", \"--check\"])\n+                .is_err()\n+        );\n+    }\n+\n+    #[test]\n+    fn multiple_packages_one_by_one() {\n+        let o = Opts::from_iter(&[\n+            \"test\",\n+            \"-p\",\n+            \"package1\",\n+            \"--package\",\n+            \"package2\",\n+            \"-p\",\n+            \"package3\",\n+        ]);\n+        assert_eq!(3, o.packages.len());\n+    }\n+\n+    #[test]\n+    fn multiple_packages_grouped() {\n+        let o = Opts::from_iter(&[\n+            \"test\",\n+            \"--package\",\n+            \"package1\",\n+            \"package2\",\n+            \"-p\",\n+            \"package3\",\n+            \"package4\",\n+        ]);\n+        assert_eq!(4, o.packages.len());\n+    }\n+\n+    #[test]\n+    fn empty_packages_1() {\n+        assert!(Opts::clap().get_matches_from_safe(&[\"test\", \"-p\"]).is_err());\n+    }\n+\n+    #[test]\n+    fn empty_packages_2() {\n+        assert!(\n+            Opts::clap()\n+                .get_matches_from_safe(&[\"test\", \"-p\", \"--\", \"--check\"])\n+                .is_err()\n+        );\n+    }\n+\n+    #[test]\n+    fn empty_packages_3() {\n+        assert!(\n+            Opts::clap()\n+                .get_matches_from_safe(&[\"test\", \"-p\", \"--verbose\"])\n+                .is_err()\n+        );\n+    }\n+\n+    #[test]\n+    fn empty_packages_4() {\n+        assert!(\n+            Opts::clap()\n+                .get_matches_from_safe(&[\"test\", \"-p\", \"--check\"])\n+                .is_err()\n+        );\n+    }\n+\n+    mod convert_message_format_to_rustfmt_args_tests {\n+        use super::*;\n+\n+        #[test]\n+        fn invalid_message_format() {\n+            assert_eq!(\n+                convert_message_format_to_rustfmt_args(\"awesome\", &mut vec![]),\n+                Err(String::from(\n+                    \"invalid --message-format value: awesome. Allowed values are: short|json|human\"\n+                )),\n+            );\n+        }\n+\n+        #[test]\n+        fn json_message_format_and_check_arg() {\n+            let mut args = vec![String::from(\"--check\")];\n+            assert_eq!(\n+                convert_message_format_to_rustfmt_args(\"json\", &mut args),\n+                Err(String::from(\n+                    \"cannot include --check arg when --message-format is set to json\"\n+                )),\n+            );\n+        }\n+\n+        #[test]\n+        fn json_message_format_and_emit_arg() {\n+            let mut args = vec![String::from(\"--emit\"), String::from(\"checkstyle\")];\n+            assert_eq!(\n+                convert_message_format_to_rustfmt_args(\"json\", &mut args),\n+                Err(String::from(\n+                    \"cannot include --emit arg when --message-format is set to json\"\n+                )),\n+            );\n+        }\n+\n+        #[test]\n+        fn json_message_format() {\n+            let mut args = vec![String::from(\"--edition\"), String::from(\"2018\")];\n+            assert!(convert_message_format_to_rustfmt_args(\"json\", &mut args).is_ok());\n+            assert_eq!(\n+                args,\n+                vec![\n+                    String::from(\"--edition\"),\n+                    String::from(\"2018\"),\n+                    String::from(\"--emit\"),\n+                    String::from(\"json\")\n+                ]\n+            );\n+        }\n+\n+        #[test]\n+        fn human_message_format() {\n+            let exp_args = vec![String::from(\"--emit\"), String::from(\"json\")];\n+            let mut act_args = exp_args.clone();\n+            assert!(convert_message_format_to_rustfmt_args(\"human\", &mut act_args).is_ok());\n+            assert_eq!(act_args, exp_args);\n+        }\n+\n+        #[test]\n+        fn short_message_format() {\n+            let mut args = vec![String::from(\"--check\")];\n+            assert!(convert_message_format_to_rustfmt_args(\"short\", &mut args).is_ok());\n+            assert_eq!(args, vec![String::from(\"--check\"), String::from(\"-l\")]);\n+        }\n+\n+        #[test]\n+        fn short_message_format_included_short_list_files_flag() {\n+            let mut args = vec![String::from(\"--check\"), String::from(\"-l\")];\n+            assert!(convert_message_format_to_rustfmt_args(\"short\", &mut args).is_ok());\n+            assert_eq!(args, vec![String::from(\"--check\"), String::from(\"-l\")]);\n+        }\n+\n+        #[test]\n+        fn short_message_format_included_long_list_files_flag() {\n+            let mut args = vec![String::from(\"--check\"), String::from(\"--files-with-diff\")];\n+            assert!(convert_message_format_to_rustfmt_args(\"short\", &mut args).is_ok());\n+            assert_eq!(\n+                args,\n+                vec![String::from(\"--check\"), String::from(\"--files-with-diff\")]\n+            );\n+        }\n+    }\n+}"}, {"sha": "8053f0e8fecc10f14d2f88e7ea68ca2a6a56a287", "filename": "src/tools/rustfmt/src/chains.rs", "status": "added", "additions": 891, "deletions": 0, "changes": 891, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Fsrc%2Fchains.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Fsrc%2Fchains.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fsrc%2Fchains.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782", "patch": "@@ -0,0 +1,891 @@\n+//! Formatting of chained expressions, i.e., expressions that are chained by\n+//! dots: struct and enum field access, method calls, and try shorthand (`?`).\n+//!\n+//! Instead of walking these subexpressions one-by-one, as is our usual strategy\n+//! for expression formatting, we collect maximal sequences of these expressions\n+//! and handle them simultaneously.\n+//!\n+//! Whenever possible, the entire chain is put on a single line. If that fails,\n+//! we put each subexpression on a separate, much like the (default) function\n+//! argument function argument strategy.\n+//!\n+//! Depends on config options: `chain_indent` is the indent to use for\n+//! blocks in the parent/root/base of the chain (and the rest of the chain's\n+//! alignment).\n+//! E.g., `let foo = { aaaa; bbb; ccc }.bar.baz();`, we would layout for the\n+//! following values of `chain_indent`:\n+//! Block:\n+//!\n+//! ```text\n+//! let foo = {\n+//!     aaaa;\n+//!     bbb;\n+//!     ccc\n+//! }.bar\n+//!     .baz();\n+//! ```\n+//!\n+//! Visual:\n+//!\n+//! ```text\n+//! let foo = {\n+//!               aaaa;\n+//!               bbb;\n+//!               ccc\n+//!           }\n+//!           .bar\n+//!           .baz();\n+//! ```\n+//!\n+//! If the first item in the chain is a block expression, we align the dots with\n+//! the braces.\n+//! Block:\n+//!\n+//! ```text\n+//! let a = foo.bar\n+//!     .baz()\n+//!     .qux\n+//! ```\n+//!\n+//! Visual:\n+//!\n+//! ```text\n+//! let a = foo.bar\n+//!            .baz()\n+//!            .qux\n+//! ```\n+\n+use std::borrow::Cow;\n+use std::cmp::min;\n+\n+use rustc_ast::{ast, ptr};\n+use rustc_span::{symbol, BytePos, Span};\n+\n+use crate::comment::{rewrite_comment, CharClasses, FullCodeCharKind, RichChar};\n+use crate::config::{IndentStyle, Version};\n+use crate::expr::rewrite_call;\n+use crate::lists::extract_pre_comment;\n+use crate::macros::convert_try_mac;\n+use crate::rewrite::{Rewrite, RewriteContext};\n+use crate::shape::Shape;\n+use crate::source_map::SpanUtils;\n+use crate::utils::{\n+    self, first_line_width, last_line_extendable, last_line_width, mk_sp, rewrite_ident,\n+    trimmed_last_line_width, wrap_str,\n+};\n+\n+pub(crate) fn rewrite_chain(\n+    expr: &ast::Expr,\n+    context: &RewriteContext<'_>,\n+    shape: Shape,\n+) -> Option<String> {\n+    let chain = Chain::from_ast(expr, context);\n+    debug!(\"rewrite_chain {:?} {:?}\", chain, shape);\n+\n+    // If this is just an expression with some `?`s, then format it trivially and\n+    // return early.\n+    if chain.children.is_empty() {\n+        return chain.parent.rewrite(context, shape);\n+    }\n+\n+    chain.rewrite(context, shape)\n+}\n+\n+#[derive(Debug)]\n+enum CommentPosition {\n+    Back,\n+    Top,\n+}\n+\n+// An expression plus trailing `?`s to be formatted together.\n+#[derive(Debug)]\n+struct ChainItem {\n+    kind: ChainItemKind,\n+    tries: usize,\n+    span: Span,\n+}\n+\n+// FIXME: we can't use a reference here because to convert `try!` to `?` we\n+// synthesise the AST node. However, I think we could use `Cow` and that\n+// would remove a lot of cloning.\n+#[derive(Debug)]\n+enum ChainItemKind {\n+    Parent(ast::Expr),\n+    MethodCall(\n+        ast::PathSegment,\n+        Vec<ast::GenericArg>,\n+        Vec<ptr::P<ast::Expr>>,\n+    ),\n+    StructField(symbol::Ident),\n+    TupleField(symbol::Ident, bool),\n+    Await,\n+    Comment(String, CommentPosition),\n+}\n+\n+impl ChainItemKind {\n+    fn is_block_like(&self, context: &RewriteContext<'_>, reps: &str) -> bool {\n+        match self {\n+            ChainItemKind::Parent(ref expr) => utils::is_block_expr(context, expr, reps),\n+            ChainItemKind::MethodCall(..)\n+            | ChainItemKind::StructField(..)\n+            | ChainItemKind::TupleField(..)\n+            | ChainItemKind::Await\n+            | ChainItemKind::Comment(..) => false,\n+        }\n+    }\n+\n+    fn is_tup_field_access(expr: &ast::Expr) -> bool {\n+        match expr.kind {\n+            ast::ExprKind::Field(_, ref field) => {\n+                field.name.to_string().chars().all(|c| c.is_digit(10))\n+            }\n+            _ => false,\n+        }\n+    }\n+\n+    fn from_ast(context: &RewriteContext<'_>, expr: &ast::Expr) -> (ChainItemKind, Span) {\n+        let (kind, span) = match expr.kind {\n+            ast::ExprKind::MethodCall(ref segment, ref expressions, _) => {\n+                let types = if let Some(ref generic_args) = segment.args {\n+                    if let ast::GenericArgs::AngleBracketed(ref data) = **generic_args {\n+                        data.args\n+                            .iter()\n+                            .filter_map(|x| match x {\n+                                ast::AngleBracketedArg::Arg(ref generic_arg) => {\n+                                    Some(generic_arg.clone())\n+                                }\n+                                _ => None,\n+                            })\n+                            .collect::<Vec<_>>()\n+                    } else {\n+                        vec![]\n+                    }\n+                } else {\n+                    vec![]\n+                };\n+                let span = mk_sp(expressions[0].span.hi(), expr.span.hi());\n+                let kind = ChainItemKind::MethodCall(segment.clone(), types, expressions.clone());\n+                (kind, span)\n+            }\n+            ast::ExprKind::Field(ref nested, field) => {\n+                let kind = if Self::is_tup_field_access(expr) {\n+                    ChainItemKind::TupleField(field, Self::is_tup_field_access(nested))\n+                } else {\n+                    ChainItemKind::StructField(field)\n+                };\n+                let span = mk_sp(nested.span.hi(), field.span.hi());\n+                (kind, span)\n+            }\n+            ast::ExprKind::Await(ref nested) => {\n+                let span = mk_sp(nested.span.hi(), expr.span.hi());\n+                (ChainItemKind::Await, span)\n+            }\n+            _ => return (ChainItemKind::Parent(expr.clone()), expr.span),\n+        };\n+\n+        // Remove comments from the span.\n+        let lo = context.snippet_provider.span_before(span, \".\");\n+        (kind, mk_sp(lo, span.hi()))\n+    }\n+}\n+\n+impl Rewrite for ChainItem {\n+    fn rewrite(&self, context: &RewriteContext<'_>, shape: Shape) -> Option<String> {\n+        let shape = shape.sub_width(self.tries)?;\n+        let rewrite = match self.kind {\n+            ChainItemKind::Parent(ref expr) => expr.rewrite(context, shape)?,\n+            ChainItemKind::MethodCall(ref segment, ref types, ref exprs) => {\n+                Self::rewrite_method_call(segment.ident, types, exprs, self.span, context, shape)?\n+            }\n+            ChainItemKind::StructField(ident) => format!(\".{}\", rewrite_ident(context, ident)),\n+            ChainItemKind::TupleField(ident, nested) => format!(\n+                \"{}.{}\",\n+                if nested && context.config.version() == Version::One {\n+                    \" \"\n+                } else {\n+                    \"\"\n+                },\n+                rewrite_ident(context, ident)\n+            ),\n+            ChainItemKind::Await => \".await\".to_owned(),\n+            ChainItemKind::Comment(ref comment, _) => {\n+                rewrite_comment(comment, false, shape, context.config)?\n+            }\n+        };\n+        Some(format!(\"{}{}\", rewrite, \"?\".repeat(self.tries)))\n+    }\n+}\n+\n+impl ChainItem {\n+    fn new(context: &RewriteContext<'_>, expr: &ast::Expr, tries: usize) -> ChainItem {\n+        let (kind, span) = ChainItemKind::from_ast(context, expr);\n+        ChainItem { kind, tries, span }\n+    }\n+\n+    fn comment(span: Span, comment: String, pos: CommentPosition) -> ChainItem {\n+        ChainItem {\n+            kind: ChainItemKind::Comment(comment, pos),\n+            tries: 0,\n+            span,\n+        }\n+    }\n+\n+    fn is_comment(&self) -> bool {\n+        match self.kind {\n+            ChainItemKind::Comment(..) => true,\n+            _ => false,\n+        }\n+    }\n+\n+    fn rewrite_method_call(\n+        method_name: symbol::Ident,\n+        types: &[ast::GenericArg],\n+        args: &[ptr::P<ast::Expr>],\n+        span: Span,\n+        context: &RewriteContext<'_>,\n+        shape: Shape,\n+    ) -> Option<String> {\n+        let type_str = if types.is_empty() {\n+            String::new()\n+        } else {\n+            let type_list = types\n+                .iter()\n+                .map(|ty| ty.rewrite(context, shape))\n+                .collect::<Option<Vec<_>>>()?;\n+\n+            format!(\"::<{}>\", type_list.join(\", \"))\n+        };\n+        let callee_str = format!(\".{}{}\", rewrite_ident(context, method_name), type_str);\n+        rewrite_call(context, &callee_str, &args[1..], span, shape)\n+    }\n+}\n+\n+#[derive(Debug)]\n+struct Chain {\n+    parent: ChainItem,\n+    children: Vec<ChainItem>,\n+}\n+\n+impl Chain {\n+    fn from_ast(expr: &ast::Expr, context: &RewriteContext<'_>) -> Chain {\n+        let subexpr_list = Self::make_subexpr_list(expr, context);\n+\n+        // Un-parse the expression tree into ChainItems\n+        let mut rev_children = vec![];\n+        let mut sub_tries = 0;\n+        for subexpr in &subexpr_list {\n+            match subexpr.kind {\n+                ast::ExprKind::Try(_) => sub_tries += 1,\n+                _ => {\n+                    rev_children.push(ChainItem::new(context, subexpr, sub_tries));\n+                    sub_tries = 0;\n+                }\n+            }\n+        }\n+\n+        fn is_tries(s: &str) -> bool {\n+            s.chars().all(|c| c == '?')\n+        }\n+\n+        fn is_post_comment(s: &str) -> bool {\n+            let comment_start_index = s.chars().position(|c| c == '/');\n+            if comment_start_index.is_none() {\n+                return false;\n+            }\n+\n+            let newline_index = s.chars().position(|c| c == '\\n');\n+            if newline_index.is_none() {\n+                return true;\n+            }\n+\n+            comment_start_index.unwrap() < newline_index.unwrap()\n+        }\n+\n+        fn handle_post_comment(\n+            post_comment_span: Span,\n+            post_comment_snippet: &str,\n+            prev_span_end: &mut BytePos,\n+            children: &mut Vec<ChainItem>,\n+        ) {\n+            let white_spaces: &[_] = &[' ', '\\t'];\n+            if post_comment_snippet\n+                .trim_matches(white_spaces)\n+                .starts_with('\\n')\n+            {\n+                // No post comment.\n+                return;\n+            }\n+            let trimmed_snippet = trim_tries(post_comment_snippet);\n+            if is_post_comment(&trimmed_snippet) {\n+                children.push(ChainItem::comment(\n+                    post_comment_span,\n+                    trimmed_snippet.trim().to_owned(),\n+                    CommentPosition::Back,\n+                ));\n+                *prev_span_end = post_comment_span.hi();\n+            }\n+        }\n+\n+        let parent = rev_children.pop().unwrap();\n+        let mut children = vec![];\n+        let mut prev_span_end = parent.span.hi();\n+        let mut iter = rev_children.into_iter().rev().peekable();\n+        if let Some(first_chain_item) = iter.peek() {\n+            let comment_span = mk_sp(prev_span_end, first_chain_item.span.lo());\n+            let comment_snippet = context.snippet(comment_span);\n+            if !is_tries(comment_snippet.trim()) {\n+                handle_post_comment(\n+                    comment_span,\n+                    comment_snippet,\n+                    &mut prev_span_end,\n+                    &mut children,\n+                );\n+            }\n+        }\n+        while let Some(chain_item) = iter.next() {\n+            let comment_snippet = context.snippet(chain_item.span);\n+            // FIXME: Figure out the way to get a correct span when converting `try!` to `?`.\n+            let handle_comment =\n+                !(context.config.use_try_shorthand() || is_tries(comment_snippet.trim()));\n+\n+            // Pre-comment\n+            if handle_comment {\n+                let pre_comment_span = mk_sp(prev_span_end, chain_item.span.lo());\n+                let pre_comment_snippet = trim_tries(context.snippet(pre_comment_span));\n+                let (pre_comment, _) = extract_pre_comment(&pre_comment_snippet);\n+                match pre_comment {\n+                    Some(ref comment) if !comment.is_empty() => {\n+                        children.push(ChainItem::comment(\n+                            pre_comment_span,\n+                            comment.to_owned(),\n+                            CommentPosition::Top,\n+                        ));\n+                    }\n+                    _ => (),\n+                }\n+            }\n+\n+            prev_span_end = chain_item.span.hi();\n+            children.push(chain_item);\n+\n+            // Post-comment\n+            if !handle_comment || iter.peek().is_none() {\n+                continue;\n+            }\n+\n+            let next_lo = iter.peek().unwrap().span.lo();\n+            let post_comment_span = mk_sp(prev_span_end, next_lo);\n+            let post_comment_snippet = context.snippet(post_comment_span);\n+            handle_post_comment(\n+                post_comment_span,\n+                post_comment_snippet,\n+                &mut prev_span_end,\n+                &mut children,\n+            );\n+        }\n+\n+        Chain { parent, children }\n+    }\n+\n+    // Returns a Vec of the prefixes of the chain.\n+    // E.g., for input `a.b.c` we return [`a.b.c`, `a.b`, 'a']\n+    fn make_subexpr_list(expr: &ast::Expr, context: &RewriteContext<'_>) -> Vec<ast::Expr> {\n+        let mut subexpr_list = vec![expr.clone()];\n+\n+        while let Some(subexpr) = Self::pop_expr_chain(subexpr_list.last().unwrap(), context) {\n+            subexpr_list.push(subexpr.clone());\n+        }\n+\n+        subexpr_list\n+    }\n+\n+    // Returns the expression's subexpression, if it exists. When the subexpr\n+    // is a try! macro, we'll convert it to shorthand when the option is set.\n+    fn pop_expr_chain(expr: &ast::Expr, context: &RewriteContext<'_>) -> Option<ast::Expr> {\n+        match expr.kind {\n+            ast::ExprKind::MethodCall(_, ref expressions, _) => {\n+                Some(Self::convert_try(&expressions[0], context))\n+            }\n+            ast::ExprKind::Field(ref subexpr, _)\n+            | ast::ExprKind::Try(ref subexpr)\n+            | ast::ExprKind::Await(ref subexpr) => Some(Self::convert_try(subexpr, context)),\n+            _ => None,\n+        }\n+    }\n+\n+    fn convert_try(expr: &ast::Expr, context: &RewriteContext<'_>) -> ast::Expr {\n+        match expr.kind {\n+            ast::ExprKind::MacCall(ref mac) if context.config.use_try_shorthand() => {\n+                if let Some(subexpr) = convert_try_mac(mac, context) {\n+                    subexpr\n+                } else {\n+                    expr.clone()\n+                }\n+            }\n+            _ => expr.clone(),\n+        }\n+    }\n+}\n+\n+impl Rewrite for Chain {\n+    fn rewrite(&self, context: &RewriteContext<'_>, shape: Shape) -> Option<String> {\n+        debug!(\"rewrite chain {:?} {:?}\", self, shape);\n+\n+        let mut formatter = match context.config.indent_style() {\n+            IndentStyle::Block => {\n+                Box::new(ChainFormatterBlock::new(self)) as Box<dyn ChainFormatter>\n+            }\n+            IndentStyle::Visual => {\n+                Box::new(ChainFormatterVisual::new(self)) as Box<dyn ChainFormatter>\n+            }\n+        };\n+\n+        formatter.format_root(&self.parent, context, shape)?;\n+        if let Some(result) = formatter.pure_root() {\n+            return wrap_str(result, context.config.max_width(), shape);\n+        }\n+\n+        // Decide how to layout the rest of the chain.\n+        let child_shape = formatter.child_shape(context, shape)?;\n+\n+        formatter.format_children(context, child_shape)?;\n+        formatter.format_last_child(context, shape, child_shape)?;\n+\n+        let result = formatter.join_rewrites(context, child_shape)?;\n+        wrap_str(result, context.config.max_width(), shape)\n+    }\n+}\n+\n+// There are a few types for formatting chains. This is because there is a lot\n+// in common between formatting with block vs visual indent, but they are\n+// different enough that branching on the indent all over the place gets ugly.\n+// Anything that can format a chain is a ChainFormatter.\n+trait ChainFormatter {\n+    // Parent is the first item in the chain, e.g., `foo` in `foo.bar.baz()`.\n+    // Root is the parent plus any other chain items placed on the first line to\n+    // avoid an orphan. E.g.,\n+    // ```text\n+    // foo.bar\n+    //     .baz()\n+    // ```\n+    // If `bar` were not part of the root, then foo would be orphaned and 'float'.\n+    fn format_root(\n+        &mut self,\n+        parent: &ChainItem,\n+        context: &RewriteContext<'_>,\n+        shape: Shape,\n+    ) -> Option<()>;\n+    fn child_shape(&self, context: &RewriteContext<'_>, shape: Shape) -> Option<Shape>;\n+    fn format_children(&mut self, context: &RewriteContext<'_>, child_shape: Shape) -> Option<()>;\n+    fn format_last_child(\n+        &mut self,\n+        context: &RewriteContext<'_>,\n+        shape: Shape,\n+        child_shape: Shape,\n+    ) -> Option<()>;\n+    fn join_rewrites(&self, context: &RewriteContext<'_>, child_shape: Shape) -> Option<String>;\n+    // Returns `Some` if the chain is only a root, None otherwise.\n+    fn pure_root(&mut self) -> Option<String>;\n+}\n+\n+// Data and behaviour that is shared by both chain formatters. The concrete\n+// formatters can delegate much behaviour to `ChainFormatterShared`.\n+struct ChainFormatterShared<'a> {\n+    // The current working set of child items.\n+    children: &'a [ChainItem],\n+    // The current rewrites of items (includes trailing `?`s, but not any way to\n+    // connect the rewrites together).\n+    rewrites: Vec<String>,\n+    // Whether the chain can fit on one line.\n+    fits_single_line: bool,\n+    // The number of children in the chain. This is not equal to `self.children.len()`\n+    // because `self.children` will change size as we process the chain.\n+    child_count: usize,\n+}\n+\n+impl<'a> ChainFormatterShared<'a> {\n+    fn new(chain: &'a Chain) -> ChainFormatterShared<'a> {\n+        ChainFormatterShared {\n+            children: &chain.children,\n+            rewrites: Vec::with_capacity(chain.children.len() + 1),\n+            fits_single_line: false,\n+            child_count: chain.children.len(),\n+        }\n+    }\n+\n+    fn pure_root(&mut self) -> Option<String> {\n+        if self.children.is_empty() {\n+            assert_eq!(self.rewrites.len(), 1);\n+            Some(self.rewrites.pop().unwrap())\n+        } else {\n+            None\n+        }\n+    }\n+\n+    // Rewrite the last child. The last child of a chain requires special treatment. We need to\n+    // know whether 'overflowing' the last child make a better formatting:\n+    //\n+    // A chain with overflowing the last child:\n+    // ```text\n+    // parent.child1.child2.last_child(\n+    //     a,\n+    //     b,\n+    //     c,\n+    // )\n+    // ```\n+    //\n+    // A chain without overflowing the last child (in vertical layout):\n+    // ```text\n+    // parent\n+    //     .child1\n+    //     .child2\n+    //     .last_child(a, b, c)\n+    // ```\n+    //\n+    // In particular, overflowing is effective when the last child is a method with a multi-lined\n+    // block-like argument (e.g., closure):\n+    // ```text\n+    // parent.child1.child2.last_child(|a, b, c| {\n+    //     let x = foo(a, b, c);\n+    //     let y = bar(a, b, c);\n+    //\n+    //     // ...\n+    //\n+    //     result\n+    // })\n+    // ```\n+    fn format_last_child(\n+        &mut self,\n+        may_extend: bool,\n+        context: &RewriteContext<'_>,\n+        shape: Shape,\n+        child_shape: Shape,\n+    ) -> Option<()> {\n+        let last = self.children.last()?;\n+        let extendable = may_extend && last_line_extendable(&self.rewrites[0]);\n+        let prev_last_line_width = last_line_width(&self.rewrites[0]);\n+\n+        // Total of all items excluding the last.\n+        let almost_total = if extendable {\n+            prev_last_line_width\n+        } else {\n+            self.rewrites\n+                .iter()\n+                .map(|rw| utils::unicode_str_width(&rw))\n+                .sum()\n+        } + last.tries;\n+        let one_line_budget = if self.child_count == 1 {\n+            shape.width\n+        } else {\n+            min(shape.width, context.config.chain_width())\n+        }\n+        .saturating_sub(almost_total);\n+\n+        let all_in_one_line = !self.children.iter().any(ChainItem::is_comment)\n+            && self.rewrites.iter().all(|s| !s.contains('\\n'))\n+            && one_line_budget > 0;\n+        let last_shape = if all_in_one_line {\n+            shape.sub_width(last.tries)?\n+        } else if extendable {\n+            child_shape.sub_width(last.tries)?\n+        } else {\n+            child_shape.sub_width(shape.rhs_overhead(context.config) + last.tries)?\n+        };\n+\n+        let mut last_subexpr_str = None;\n+        if all_in_one_line || extendable {\n+            // First we try to 'overflow' the last child and see if it looks better than using\n+            // vertical layout.\n+            let one_line_shape = if context.use_block_indent() {\n+                last_shape.offset_left(almost_total)\n+            } else {\n+                last_shape\n+                    .visual_indent(almost_total)\n+                    .sub_width(almost_total)\n+            };\n+\n+            if let Some(one_line_shape) = one_line_shape {\n+                if let Some(rw) = last.rewrite(context, one_line_shape) {\n+                    // We allow overflowing here only if both of the following conditions match:\n+                    // 1. The entire chain fits in a single line except the last child.\n+                    // 2. `last_child_str.lines().count() >= 5`.\n+                    let line_count = rw.lines().count();\n+                    let could_fit_single_line = first_line_width(&rw) <= one_line_budget;\n+                    if could_fit_single_line && line_count >= 5 {\n+                        last_subexpr_str = Some(rw);\n+                        self.fits_single_line = all_in_one_line;\n+                    } else {\n+                        // We could not know whether overflowing is better than using vertical\n+                        // layout, just by looking at the overflowed rewrite. Now we rewrite the\n+                        // last child on its own line, and compare two rewrites to choose which is\n+                        // better.\n+                        let last_shape = child_shape\n+                            .sub_width(shape.rhs_overhead(context.config) + last.tries)?;\n+                        match last.rewrite(context, last_shape) {\n+                            Some(ref new_rw) if !could_fit_single_line => {\n+                                last_subexpr_str = Some(new_rw.clone());\n+                            }\n+                            Some(ref new_rw) if new_rw.lines().count() >= line_count => {\n+                                last_subexpr_str = Some(rw);\n+                                self.fits_single_line = could_fit_single_line && all_in_one_line;\n+                            }\n+                            new_rw @ Some(..) => {\n+                                last_subexpr_str = new_rw;\n+                            }\n+                            _ => {\n+                                last_subexpr_str = Some(rw);\n+                                self.fits_single_line = could_fit_single_line && all_in_one_line;\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        let last_shape = if context.use_block_indent() {\n+            last_shape\n+        } else {\n+            child_shape.sub_width(shape.rhs_overhead(context.config) + last.tries)?\n+        };\n+\n+        last_subexpr_str = last_subexpr_str.or_else(|| last.rewrite(context, last_shape));\n+        self.rewrites.push(last_subexpr_str?);\n+        Some(())\n+    }\n+\n+    fn join_rewrites(&self, context: &RewriteContext<'_>, child_shape: Shape) -> Option<String> {\n+        let connector = if self.fits_single_line {\n+            // Yay, we can put everything on one line.\n+            Cow::from(\"\")\n+        } else {\n+            // Use new lines.\n+            if context.force_one_line_chain.get() {\n+                return None;\n+            }\n+            child_shape.to_string_with_newline(context.config)\n+        };\n+\n+        let mut rewrite_iter = self.rewrites.iter();\n+        let mut result = rewrite_iter.next().unwrap().clone();\n+        let children_iter = self.children.iter();\n+        let iter = rewrite_iter.zip(children_iter);\n+\n+        for (rewrite, chain_item) in iter {\n+            match chain_item.kind {\n+                ChainItemKind::Comment(_, CommentPosition::Back) => result.push(' '),\n+                ChainItemKind::Comment(_, CommentPosition::Top) => result.push_str(&connector),\n+                _ => result.push_str(&connector),\n+            }\n+            result.push_str(&rewrite);\n+        }\n+\n+        Some(result)\n+    }\n+}\n+\n+// Formats a chain using block indent.\n+struct ChainFormatterBlock<'a> {\n+    shared: ChainFormatterShared<'a>,\n+    root_ends_with_block: bool,\n+}\n+\n+impl<'a> ChainFormatterBlock<'a> {\n+    fn new(chain: &'a Chain) -> ChainFormatterBlock<'a> {\n+        ChainFormatterBlock {\n+            shared: ChainFormatterShared::new(chain),\n+            root_ends_with_block: false,\n+        }\n+    }\n+}\n+\n+impl<'a> ChainFormatter for ChainFormatterBlock<'a> {\n+    fn format_root(\n+        &mut self,\n+        parent: &ChainItem,\n+        context: &RewriteContext<'_>,\n+        shape: Shape,\n+    ) -> Option<()> {\n+        let mut root_rewrite: String = parent.rewrite(context, shape)?;\n+\n+        let mut root_ends_with_block = parent.kind.is_block_like(context, &root_rewrite);\n+        let tab_width = context.config.tab_spaces().saturating_sub(shape.offset);\n+\n+        while root_rewrite.len() <= tab_width && !root_rewrite.contains('\\n') {\n+            let item = &self.shared.children[0];\n+            if let ChainItemKind::Comment(..) = item.kind {\n+                break;\n+            }\n+            let shape = shape.offset_left(root_rewrite.len())?;\n+            match &item.rewrite(context, shape) {\n+                Some(rewrite) => root_rewrite.push_str(rewrite),\n+                None => break,\n+            }\n+\n+            root_ends_with_block = last_line_extendable(&root_rewrite);\n+\n+            self.shared.children = &self.shared.children[1..];\n+            if self.shared.children.is_empty() {\n+                break;\n+            }\n+        }\n+        self.shared.rewrites.push(root_rewrite);\n+        self.root_ends_with_block = root_ends_with_block;\n+        Some(())\n+    }\n+\n+    fn child_shape(&self, context: &RewriteContext<'_>, shape: Shape) -> Option<Shape> {\n+        Some(\n+            if self.root_ends_with_block {\n+                shape.block_indent(0)\n+            } else {\n+                shape.block_indent(context.config.tab_spaces())\n+            }\n+            .with_max_width(context.config),\n+        )\n+    }\n+\n+    fn format_children(&mut self, context: &RewriteContext<'_>, child_shape: Shape) -> Option<()> {\n+        for item in &self.shared.children[..self.shared.children.len() - 1] {\n+            let rewrite = item.rewrite(context, child_shape)?;\n+            self.shared.rewrites.push(rewrite);\n+        }\n+        Some(())\n+    }\n+\n+    fn format_last_child(\n+        &mut self,\n+        context: &RewriteContext<'_>,\n+        shape: Shape,\n+        child_shape: Shape,\n+    ) -> Option<()> {\n+        self.shared\n+            .format_last_child(true, context, shape, child_shape)\n+    }\n+\n+    fn join_rewrites(&self, context: &RewriteContext<'_>, child_shape: Shape) -> Option<String> {\n+        self.shared.join_rewrites(context, child_shape)\n+    }\n+\n+    fn pure_root(&mut self) -> Option<String> {\n+        self.shared.pure_root()\n+    }\n+}\n+\n+// Format a chain using visual indent.\n+struct ChainFormatterVisual<'a> {\n+    shared: ChainFormatterShared<'a>,\n+    // The extra offset from the chain's shape to the position of the `.`\n+    offset: usize,\n+}\n+\n+impl<'a> ChainFormatterVisual<'a> {\n+    fn new(chain: &'a Chain) -> ChainFormatterVisual<'a> {\n+        ChainFormatterVisual {\n+            shared: ChainFormatterShared::new(chain),\n+            offset: 0,\n+        }\n+    }\n+}\n+\n+impl<'a> ChainFormatter for ChainFormatterVisual<'a> {\n+    fn format_root(\n+        &mut self,\n+        parent: &ChainItem,\n+        context: &RewriteContext<'_>,\n+        shape: Shape,\n+    ) -> Option<()> {\n+        let parent_shape = shape.visual_indent(0);\n+        let mut root_rewrite = parent.rewrite(context, parent_shape)?;\n+        let multiline = root_rewrite.contains('\\n');\n+        self.offset = if multiline {\n+            last_line_width(&root_rewrite).saturating_sub(shape.used_width())\n+        } else {\n+            trimmed_last_line_width(&root_rewrite)\n+        };\n+\n+        if !multiline || parent.kind.is_block_like(context, &root_rewrite) {\n+            let item = &self.shared.children[0];\n+            if let ChainItemKind::Comment(..) = item.kind {\n+                self.shared.rewrites.push(root_rewrite);\n+                return Some(());\n+            }\n+            let child_shape = parent_shape\n+                .visual_indent(self.offset)\n+                .sub_width(self.offset)?;\n+            let rewrite = item.rewrite(context, child_shape)?;\n+            match wrap_str(rewrite, context.config.max_width(), shape) {\n+                Some(rewrite) => root_rewrite.push_str(&rewrite),\n+                None => {\n+                    // We couldn't fit in at the visual indent, try the last\n+                    // indent.\n+                    let rewrite = item.rewrite(context, parent_shape)?;\n+                    root_rewrite.push_str(&rewrite);\n+                    self.offset = 0;\n+                }\n+            }\n+\n+            self.shared.children = &self.shared.children[1..];\n+        }\n+\n+        self.shared.rewrites.push(root_rewrite);\n+        Some(())\n+    }\n+\n+    fn child_shape(&self, context: &RewriteContext<'_>, shape: Shape) -> Option<Shape> {\n+        shape\n+            .with_max_width(context.config)\n+            .offset_left(self.offset)\n+            .map(|s| s.visual_indent(0))\n+    }\n+\n+    fn format_children(&mut self, context: &RewriteContext<'_>, child_shape: Shape) -> Option<()> {\n+        for item in &self.shared.children[..self.shared.children.len() - 1] {\n+            let rewrite = item.rewrite(context, child_shape)?;\n+            self.shared.rewrites.push(rewrite);\n+        }\n+        Some(())\n+    }\n+\n+    fn format_last_child(\n+        &mut self,\n+        context: &RewriteContext<'_>,\n+        shape: Shape,\n+        child_shape: Shape,\n+    ) -> Option<()> {\n+        self.shared\n+            .format_last_child(false, context, shape, child_shape)\n+    }\n+\n+    fn join_rewrites(&self, context: &RewriteContext<'_>, child_shape: Shape) -> Option<String> {\n+        self.shared.join_rewrites(context, child_shape)\n+    }\n+\n+    fn pure_root(&mut self) -> Option<String> {\n+        self.shared.pure_root()\n+    }\n+}\n+\n+/// Removes try operators (`?`s) that appear in the given string. If removing\n+/// them leaves an empty line, remove that line as well unless it is the first\n+/// line (we need the first newline for detecting pre/post comment).\n+fn trim_tries(s: &str) -> String {\n+    let mut result = String::with_capacity(s.len());\n+    let mut line_buffer = String::with_capacity(s.len());\n+    for (kind, rich_char) in CharClasses::new(s.chars()) {\n+        match rich_char.get_char() {\n+            '\\n' => {\n+                if result.is_empty() || !line_buffer.trim().is_empty() {\n+                    result.push_str(&line_buffer);\n+                    result.push('\\n')\n+                }\n+                line_buffer.clear();\n+            }\n+            '?' if kind == FullCodeCharKind::Normal => continue,\n+            c => line_buffer.push(c),\n+        }\n+    }\n+    if !line_buffer.trim().is_empty() {\n+        result.push_str(&line_buffer);\n+    }\n+    result\n+}"}, {"sha": "3d65077ddc2091289a050cddf44af67328a0b727", "filename": "src/tools/rustfmt/src/closures.rs", "status": "added", "additions": 429, "deletions": 0, "changes": 429, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Fsrc%2Fclosures.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Fsrc%2Fclosures.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fsrc%2Fclosures.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782", "patch": "@@ -0,0 +1,429 @@\n+use rustc_ast::{ast, ptr};\n+use rustc_span::Span;\n+\n+use crate::attr::get_attrs_from_stmt;\n+use crate::config::lists::*;\n+use crate::config::Version;\n+use crate::expr::{block_contains_comment, is_simple_block, is_unsafe_block, rewrite_cond};\n+use crate::items::{span_hi_for_param, span_lo_for_param};\n+use crate::lists::{definitive_tactic, itemize_list, write_list, ListFormatting, Separator};\n+use crate::overflow::OverflowableItem;\n+use crate::rewrite::{Rewrite, RewriteContext};\n+use crate::shape::Shape;\n+use crate::source_map::SpanUtils;\n+use crate::utils::{last_line_width, left_most_sub_expr, stmt_expr, NodeIdExt};\n+\n+// This module is pretty messy because of the rules around closures and blocks:\n+// FIXME - the below is probably no longer true in full.\n+//   * if there is a return type, then there must be braces,\n+//   * given a closure with braces, whether that is parsed to give an inner block\n+//     or not depends on if there is a return type and if there are statements\n+//     in that block,\n+//   * if the first expression in the body ends with a block (i.e., is a\n+//     statement without needing a semi-colon), then adding or removing braces\n+//     can change whether it is treated as an expression or statement.\n+\n+pub(crate) fn rewrite_closure(\n+    capture: ast::CaptureBy,\n+    is_async: &ast::Async,\n+    movability: ast::Movability,\n+    fn_decl: &ast::FnDecl,\n+    body: &ast::Expr,\n+    span: Span,\n+    context: &RewriteContext<'_>,\n+    shape: Shape,\n+) -> Option<String> {\n+    debug!(\"rewrite_closure {:?}\", body);\n+\n+    let (prefix, extra_offset) = rewrite_closure_fn_decl(\n+        capture, is_async, movability, fn_decl, body, span, context, shape,\n+    )?;\n+    // 1 = space between `|...|` and body.\n+    let body_shape = shape.offset_left(extra_offset)?;\n+\n+    if let ast::ExprKind::Block(ref block, _) = body.kind {\n+        // The body of the closure is an empty block.\n+        if block.stmts.is_empty() && !block_contains_comment(context, block) {\n+            return body\n+                .rewrite(context, shape)\n+                .map(|s| format!(\"{} {}\", prefix, s));\n+        }\n+\n+        let result = match fn_decl.output {\n+            ast::FnRetTy::Default(_) if !context.inside_macro() => {\n+                try_rewrite_without_block(body, &prefix, context, shape, body_shape)\n+            }\n+            _ => None,\n+        };\n+\n+        result.or_else(|| {\n+            // Either we require a block, or tried without and failed.\n+            rewrite_closure_block(block, &prefix, context, body_shape)\n+        })\n+    } else {\n+        rewrite_closure_expr(body, &prefix, context, body_shape).or_else(|| {\n+            // The closure originally had a non-block expression, but we can't fit on\n+            // one line, so we'll insert a block.\n+            rewrite_closure_with_block(body, &prefix, context, body_shape)\n+        })\n+    }\n+}\n+\n+fn try_rewrite_without_block(\n+    expr: &ast::Expr,\n+    prefix: &str,\n+    context: &RewriteContext<'_>,\n+    shape: Shape,\n+    body_shape: Shape,\n+) -> Option<String> {\n+    let expr = get_inner_expr(expr, prefix, context);\n+\n+    if is_block_closure_forced(context, expr) {\n+        rewrite_closure_with_block(expr, prefix, context, shape)\n+    } else {\n+        rewrite_closure_expr(expr, prefix, context, body_shape)\n+    }\n+}\n+\n+fn get_inner_expr<'a>(\n+    expr: &'a ast::Expr,\n+    prefix: &str,\n+    context: &RewriteContext<'_>,\n+) -> &'a ast::Expr {\n+    if let ast::ExprKind::Block(ref block, _) = expr.kind {\n+        if !needs_block(block, prefix, context) {\n+            // block.stmts.len() == 1 except with `|| {{}}`;\n+            // https://github.com/rust-lang/rustfmt/issues/3844\n+            if let Some(expr) = block.stmts.first().and_then(stmt_expr) {\n+                return get_inner_expr(expr, prefix, context);\n+            }\n+        }\n+    }\n+\n+    expr\n+}\n+\n+// Figure out if a block is necessary.\n+fn needs_block(block: &ast::Block, prefix: &str, context: &RewriteContext<'_>) -> bool {\n+    let has_attributes = block.stmts.first().map_or(false, |first_stmt| {\n+        !get_attrs_from_stmt(first_stmt).is_empty()\n+    });\n+\n+    is_unsafe_block(block)\n+        || block.stmts.len() > 1\n+        || has_attributes\n+        || block_contains_comment(context, block)\n+        || prefix.contains('\\n')\n+}\n+\n+fn veto_block(e: &ast::Expr) -> bool {\n+    match e.kind {\n+        ast::ExprKind::Call(..)\n+        | ast::ExprKind::Binary(..)\n+        | ast::ExprKind::Cast(..)\n+        | ast::ExprKind::Type(..)\n+        | ast::ExprKind::Assign(..)\n+        | ast::ExprKind::AssignOp(..)\n+        | ast::ExprKind::Field(..)\n+        | ast::ExprKind::Index(..)\n+        | ast::ExprKind::Range(..)\n+        | ast::ExprKind::Try(..) => true,\n+        _ => false,\n+    }\n+}\n+\n+// Rewrite closure with a single expression wrapping its body with block.\n+// || { #[attr] foo() } -> Block { #[attr] foo() }\n+fn rewrite_closure_with_block(\n+    body: &ast::Expr,\n+    prefix: &str,\n+    context: &RewriteContext<'_>,\n+    shape: Shape,\n+) -> Option<String> {\n+    let left_most = left_most_sub_expr(body);\n+    let veto_block = veto_block(body) && !expr_requires_semi_to_be_stmt(left_most);\n+    if veto_block {\n+        return None;\n+    }\n+\n+    let block = ast::Block {\n+        stmts: vec![ast::Stmt {\n+            id: ast::NodeId::root(),\n+            kind: ast::StmtKind::Expr(ptr::P(body.clone())),\n+            span: body.span,\n+        }],\n+        id: ast::NodeId::root(),\n+        rules: ast::BlockCheckMode::Default,\n+        tokens: None,\n+        span: body\n+            .attrs\n+            .first()\n+            .map(|attr| attr.span.to(body.span))\n+            .unwrap_or(body.span),\n+    };\n+    let block = crate::expr::rewrite_block_with_visitor(\n+        context,\n+        \"\",\n+        &block,\n+        Some(&body.attrs),\n+        None,\n+        shape,\n+        false,\n+    )?;\n+    Some(format!(\"{} {}\", prefix, block))\n+}\n+\n+// Rewrite closure with a single expression without wrapping its body with block.\n+fn rewrite_closure_expr(\n+    expr: &ast::Expr,\n+    prefix: &str,\n+    context: &RewriteContext<'_>,\n+    shape: Shape,\n+) -> Option<String> {\n+    fn allow_multi_line(expr: &ast::Expr) -> bool {\n+        match expr.kind {\n+            ast::ExprKind::Match(..)\n+            | ast::ExprKind::Async(..)\n+            | ast::ExprKind::Block(..)\n+            | ast::ExprKind::TryBlock(..)\n+            | ast::ExprKind::Loop(..)\n+            | ast::ExprKind::Struct(..) => true,\n+\n+            ast::ExprKind::AddrOf(_, _, ref expr)\n+            | ast::ExprKind::Box(ref expr)\n+            | ast::ExprKind::Try(ref expr)\n+            | ast::ExprKind::Unary(_, ref expr)\n+            | ast::ExprKind::Cast(ref expr, _) => allow_multi_line(expr),\n+\n+            _ => false,\n+        }\n+    }\n+\n+    // When rewriting closure's body without block, we require it to fit in a single line\n+    // unless it is a block-like expression or we are inside macro call.\n+    let veto_multiline = (!allow_multi_line(expr) && !context.inside_macro())\n+        || context.config.force_multiline_blocks();\n+    expr.rewrite(context, shape)\n+        .and_then(|rw| {\n+            if veto_multiline && rw.contains('\\n') {\n+                None\n+            } else {\n+                Some(rw)\n+            }\n+        })\n+        .map(|rw| format!(\"{} {}\", prefix, rw))\n+}\n+\n+// Rewrite closure whose body is block.\n+fn rewrite_closure_block(\n+    block: &ast::Block,\n+    prefix: &str,\n+    context: &RewriteContext<'_>,\n+    shape: Shape,\n+) -> Option<String> {\n+    Some(format!(\"{} {}\", prefix, block.rewrite(context, shape)?))\n+}\n+\n+// Return type is (prefix, extra_offset)\n+fn rewrite_closure_fn_decl(\n+    capture: ast::CaptureBy,\n+    asyncness: &ast::Async,\n+    movability: ast::Movability,\n+    fn_decl: &ast::FnDecl,\n+    body: &ast::Expr,\n+    span: Span,\n+    context: &RewriteContext<'_>,\n+    shape: Shape,\n+) -> Option<(String, usize)> {\n+    let is_async = if asyncness.is_async() { \"async \" } else { \"\" };\n+    let mover = if capture == ast::CaptureBy::Value {\n+        \"move \"\n+    } else {\n+        \"\"\n+    };\n+    let immovable = if movability == ast::Movability::Static {\n+        \"static \"\n+    } else {\n+        \"\"\n+    };\n+    // 4 = \"|| {\".len(), which is overconservative when the closure consists of\n+    // a single expression.\n+    let nested_shape = shape\n+        .shrink_left(is_async.len() + mover.len() + immovable.len())?\n+        .sub_width(4)?;\n+\n+    // 1 = |\n+    let param_offset = nested_shape.indent + 1;\n+    let param_shape = nested_shape.offset_left(1)?.visual_indent(0);\n+    let ret_str = fn_decl.output.rewrite(context, param_shape)?;\n+\n+    let param_items = itemize_list(\n+        context.snippet_provider,\n+        fn_decl.inputs.iter(),\n+        \"|\",\n+        \",\",\n+        |param| span_lo_for_param(param),\n+        |param| span_hi_for_param(context, param),\n+        |param| param.rewrite(context, param_shape),\n+        context.snippet_provider.span_after(span, \"|\"),\n+        body.span.lo(),\n+        false,\n+    );\n+    let item_vec = param_items.collect::<Vec<_>>();\n+    // 1 = space between parameters and return type.\n+    let horizontal_budget = nested_shape.width.saturating_sub(ret_str.len() + 1);\n+    let tactic = definitive_tactic(\n+        &item_vec,\n+        ListTactic::HorizontalVertical,\n+        Separator::Comma,\n+        horizontal_budget,\n+    );\n+    let param_shape = match tactic {\n+        DefinitiveListTactic::Horizontal => param_shape.sub_width(ret_str.len() + 1)?,\n+        _ => param_shape,\n+    };\n+\n+    let fmt = ListFormatting::new(param_shape, context.config)\n+        .tactic(tactic)\n+        .preserve_newline(true);\n+    let list_str = write_list(&item_vec, &fmt)?;\n+    let mut prefix = format!(\"{}{}{}|{}|\", is_async, immovable, mover, list_str);\n+\n+    if !ret_str.is_empty() {\n+        if prefix.contains('\\n') {\n+            prefix.push('\\n');\n+            prefix.push_str(&param_offset.to_string(context.config));\n+        } else {\n+            prefix.push(' ');\n+        }\n+        prefix.push_str(&ret_str);\n+    }\n+    // 1 = space between `|...|` and body.\n+    let extra_offset = last_line_width(&prefix) + 1;\n+\n+    Some((prefix, extra_offset))\n+}\n+\n+// Rewriting closure which is placed at the end of the function call's arg.\n+// Returns `None` if the reformatted closure 'looks bad'.\n+pub(crate) fn rewrite_last_closure(\n+    context: &RewriteContext<'_>,\n+    expr: &ast::Expr,\n+    shape: Shape,\n+) -> Option<String> {\n+    if let ast::ExprKind::Closure(capture, ref is_async, movability, ref fn_decl, ref body, _) =\n+        expr.kind\n+    {\n+        let body = match body.kind {\n+            ast::ExprKind::Block(ref block, _)\n+                if !is_unsafe_block(block)\n+                    && !context.inside_macro()\n+                    && is_simple_block(context, block, Some(&body.attrs)) =>\n+            {\n+                stmt_expr(&block.stmts[0]).unwrap_or(body)\n+            }\n+            _ => body,\n+        };\n+        let (prefix, extra_offset) = rewrite_closure_fn_decl(\n+            capture, is_async, movability, fn_decl, body, expr.span, context, shape,\n+        )?;\n+        // If the closure goes multi line before its body, do not overflow the closure.\n+        if prefix.contains('\\n') {\n+            return None;\n+        }\n+\n+        let body_shape = shape.offset_left(extra_offset)?;\n+\n+        // We force to use block for the body of the closure for certain kinds of expressions.\n+        if is_block_closure_forced(context, body) {\n+            return rewrite_closure_with_block(body, &prefix, context, body_shape).and_then(\n+                |body_str| {\n+                    match fn_decl.output {\n+                        ast::FnRetTy::Default(..) if body_str.lines().count() <= 7 => {\n+                            // If the expression can fit in a single line, we need not force block\n+                            // closure.  However, if the closure has a return type, then we must\n+                            // keep the blocks.\n+                            match rewrite_closure_expr(body, &prefix, context, shape) {\n+                                Some(ref single_line_body_str)\n+                                    if !single_line_body_str.contains('\\n') =>\n+                                {\n+                                    Some(single_line_body_str.clone())\n+                                }\n+                                _ => Some(body_str),\n+                            }\n+                        }\n+                        _ => Some(body_str),\n+                    }\n+                },\n+            );\n+        }\n+\n+        // When overflowing the closure which consists of a single control flow expression,\n+        // force to use block if its condition uses multi line.\n+        let is_multi_lined_cond = rewrite_cond(context, body, body_shape).map_or(false, |cond| {\n+            cond.contains('\\n') || cond.len() > body_shape.width\n+        });\n+        if is_multi_lined_cond {\n+            return rewrite_closure_with_block(body, &prefix, context, body_shape);\n+        }\n+\n+        // Seems fine, just format the closure in usual manner.\n+        return expr.rewrite(context, shape);\n+    }\n+    None\n+}\n+\n+/// Returns `true` if the given vector of arguments has more than one `ast::ExprKind::Closure`.\n+pub(crate) fn args_have_many_closure(args: &[OverflowableItem<'_>]) -> bool {\n+    args.iter()\n+        .filter_map(OverflowableItem::to_expr)\n+        .filter(|expr| match expr.kind {\n+            ast::ExprKind::Closure(..) => true,\n+            _ => false,\n+        })\n+        .count()\n+        > 1\n+}\n+\n+fn is_block_closure_forced(context: &RewriteContext<'_>, expr: &ast::Expr) -> bool {\n+    // If we are inside macro, we do not want to add or remove block from closure body.\n+    if context.inside_macro() {\n+        false\n+    } else {\n+        is_block_closure_forced_inner(expr, context.config.version())\n+    }\n+}\n+\n+fn is_block_closure_forced_inner(expr: &ast::Expr, version: Version) -> bool {\n+    match expr.kind {\n+        ast::ExprKind::If(..) | ast::ExprKind::While(..) | ast::ExprKind::ForLoop(..) => true,\n+        ast::ExprKind::Loop(..) if version == Version::Two => true,\n+        ast::ExprKind::AddrOf(_, _, ref expr)\n+        | ast::ExprKind::Box(ref expr)\n+        | ast::ExprKind::Try(ref expr)\n+        | ast::ExprKind::Unary(_, ref expr)\n+        | ast::ExprKind::Cast(ref expr, _) => is_block_closure_forced_inner(expr, version),\n+        _ => false,\n+    }\n+}\n+\n+/// Does this expression require a semicolon to be treated\n+/// as a statement? The negation of this: 'can this expression\n+/// be used as a statement without a semicolon' -- is used\n+/// as an early-bail-out in the parser so that, for instance,\n+///     if true {...} else {...}\n+///      |x| 5\n+/// isn't parsed as (if true {...} else {...} | x) | 5\n+// From https://github.com/rust-lang/rust/blob/master/src/libsyntax/parse/classify.rs.\n+fn expr_requires_semi_to_be_stmt(e: &ast::Expr) -> bool {\n+    match e.kind {\n+        ast::ExprKind::If(..)\n+        | ast::ExprKind::Match(..)\n+        | ast::ExprKind::Block(..)\n+        | ast::ExprKind::While(..)\n+        | ast::ExprKind::Loop(..)\n+        | ast::ExprKind::ForLoop(..)\n+        | ast::ExprKind::TryBlock(..) => false,\n+        _ => true,\n+    }\n+}"}, {"sha": "c71302fdd182bc91c39372638ad6d34d02daa3f1", "filename": "src/tools/rustfmt/src/comment.rs", "status": "added", "additions": 1920, "deletions": 0, "changes": 1920, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Fsrc%2Fcomment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Fsrc%2Fcomment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fsrc%2Fcomment.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782", "patch": "@@ -0,0 +1,1920 @@\n+// Formatting and tools for comments.\n+\n+use std::{self, borrow::Cow, iter};\n+\n+use itertools::{multipeek, MultiPeek};\n+use rustc_span::Span;\n+\n+use crate::config::Config;\n+use crate::rewrite::RewriteContext;\n+use crate::shape::{Indent, Shape};\n+use crate::string::{rewrite_string, StringFormat};\n+use crate::utils::{\n+    count_newlines, first_line_width, last_line_width, trim_left_preserve_layout, unicode_str_width,\n+};\n+use crate::{ErrorKind, FormattingError};\n+\n+fn is_custom_comment(comment: &str) -> bool {\n+    if !comment.starts_with(\"//\") {\n+        false\n+    } else if let Some(c) = comment.chars().nth(2) {\n+        !c.is_alphanumeric() && !c.is_whitespace()\n+    } else {\n+        false\n+    }\n+}\n+\n+#[derive(Copy, Clone, PartialEq, Eq)]\n+pub(crate) enum CommentStyle<'a> {\n+    DoubleSlash,\n+    TripleSlash,\n+    Doc,\n+    SingleBullet,\n+    DoubleBullet,\n+    Exclamation,\n+    Custom(&'a str),\n+}\n+\n+fn custom_opener(s: &str) -> &str {\n+    s.lines().next().map_or(\"\", |first_line| {\n+        first_line\n+            .find(' ')\n+            .map_or(first_line, |space_index| &first_line[0..=space_index])\n+    })\n+}\n+\n+impl<'a> CommentStyle<'a> {\n+    /// Returns `true` if the commenting style covers a line only.\n+    pub(crate) fn is_line_comment(&self) -> bool {\n+        match *self {\n+            CommentStyle::DoubleSlash\n+            | CommentStyle::TripleSlash\n+            | CommentStyle::Doc\n+            | CommentStyle::Custom(_) => true,\n+            _ => false,\n+        }\n+    }\n+\n+    /// Returns `true` if the commenting style can span over multiple lines.\n+    pub(crate) fn is_block_comment(&self) -> bool {\n+        match *self {\n+            CommentStyle::SingleBullet | CommentStyle::DoubleBullet | CommentStyle::Exclamation => {\n+                true\n+            }\n+            _ => false,\n+        }\n+    }\n+\n+    /// Returns `true` if the commenting style is for documentation.\n+    pub(crate) fn is_doc_comment(&self) -> bool {\n+        match *self {\n+            CommentStyle::TripleSlash | CommentStyle::Doc => true,\n+            _ => false,\n+        }\n+    }\n+\n+    pub(crate) fn opener(&self) -> &'a str {\n+        match *self {\n+            CommentStyle::DoubleSlash => \"// \",\n+            CommentStyle::TripleSlash => \"/// \",\n+            CommentStyle::Doc => \"//! \",\n+            CommentStyle::SingleBullet => \"/* \",\n+            CommentStyle::DoubleBullet => \"/** \",\n+            CommentStyle::Exclamation => \"/*! \",\n+            CommentStyle::Custom(opener) => opener,\n+        }\n+    }\n+\n+    pub(crate) fn closer(&self) -> &'a str {\n+        match *self {\n+            CommentStyle::DoubleSlash\n+            | CommentStyle::TripleSlash\n+            | CommentStyle::Custom(..)\n+            | CommentStyle::Doc => \"\",\n+            CommentStyle::SingleBullet | CommentStyle::DoubleBullet | CommentStyle::Exclamation => {\n+                \" */\"\n+            }\n+        }\n+    }\n+\n+    pub(crate) fn line_start(&self) -> &'a str {\n+        match *self {\n+            CommentStyle::DoubleSlash => \"// \",\n+            CommentStyle::TripleSlash => \"/// \",\n+            CommentStyle::Doc => \"//! \",\n+            CommentStyle::SingleBullet | CommentStyle::DoubleBullet | CommentStyle::Exclamation => {\n+                \" * \"\n+            }\n+            CommentStyle::Custom(opener) => opener,\n+        }\n+    }\n+\n+    pub(crate) fn to_str_tuplet(&self) -> (&'a str, &'a str, &'a str) {\n+        (self.opener(), self.closer(), self.line_start())\n+    }\n+}\n+\n+pub(crate) fn comment_style(orig: &str, normalize_comments: bool) -> CommentStyle<'_> {\n+    if !normalize_comments {\n+        if orig.starts_with(\"/**\") && !orig.starts_with(\"/**/\") {\n+            CommentStyle::DoubleBullet\n+        } else if orig.starts_with(\"/*!\") {\n+            CommentStyle::Exclamation\n+        } else if orig.starts_with(\"/*\") {\n+            CommentStyle::SingleBullet\n+        } else if orig.starts_with(\"///\") && orig.chars().nth(3).map_or(true, |c| c != '/') {\n+            CommentStyle::TripleSlash\n+        } else if orig.starts_with(\"//!\") {\n+            CommentStyle::Doc\n+        } else if is_custom_comment(orig) {\n+            CommentStyle::Custom(custom_opener(orig))\n+        } else {\n+            CommentStyle::DoubleSlash\n+        }\n+    } else if (orig.starts_with(\"///\") && orig.chars().nth(3).map_or(true, |c| c != '/'))\n+        || (orig.starts_with(\"/**\") && !orig.starts_with(\"/**/\"))\n+    {\n+        CommentStyle::TripleSlash\n+    } else if orig.starts_with(\"//!\") || orig.starts_with(\"/*!\") {\n+        CommentStyle::Doc\n+    } else if is_custom_comment(orig) {\n+        CommentStyle::Custom(custom_opener(orig))\n+    } else {\n+        CommentStyle::DoubleSlash\n+    }\n+}\n+\n+/// Returns true if the last line of the passed string finishes with a block-comment.\n+pub(crate) fn is_last_comment_block(s: &str) -> bool {\n+    s.trim_end().ends_with(\"*/\")\n+}\n+\n+/// Combine `prev_str` and `next_str` into a single `String`. `span` may contain\n+/// comments between two strings. If there are such comments, then that will be\n+/// recovered. If `allow_extend` is true and there is no comment between the two\n+/// strings, then they will be put on a single line as long as doing so does not\n+/// exceed max width.\n+pub(crate) fn combine_strs_with_missing_comments(\n+    context: &RewriteContext<'_>,\n+    prev_str: &str,\n+    next_str: &str,\n+    span: Span,\n+    shape: Shape,\n+    allow_extend: bool,\n+) -> Option<String> {\n+    trace!(\n+        \"combine_strs_with_missing_comments `{}` `{}` {:?} {:?}\",\n+        prev_str,\n+        next_str,\n+        span,\n+        shape\n+    );\n+\n+    let mut result =\n+        String::with_capacity(prev_str.len() + next_str.len() + shape.indent.width() + 128);\n+    result.push_str(prev_str);\n+    let mut allow_one_line = !prev_str.contains('\\n') && !next_str.contains('\\n');\n+    let first_sep = if prev_str.is_empty() || next_str.is_empty() {\n+        \"\"\n+    } else {\n+        \" \"\n+    };\n+    let mut one_line_width =\n+        last_line_width(prev_str) + first_line_width(next_str) + first_sep.len();\n+\n+    let config = context.config;\n+    let indent = shape.indent;\n+    let missing_comment = rewrite_missing_comment(span, shape, context)?;\n+\n+    if missing_comment.is_empty() {\n+        if allow_extend && prev_str.len() + first_sep.len() + next_str.len() <= shape.width {\n+            result.push_str(first_sep);\n+        } else if !prev_str.is_empty() {\n+            result.push_str(&indent.to_string_with_newline(config))\n+        }\n+        result.push_str(next_str);\n+        return Some(result);\n+    }\n+\n+    // We have a missing comment between the first expression and the second expression.\n+\n+    // Peek the the original source code and find out whether there is a newline between the first\n+    // expression and the second expression or the missing comment. We will preserve the original\n+    // layout whenever possible.\n+    let original_snippet = context.snippet(span);\n+    let prefer_same_line = if let Some(pos) = original_snippet.find('/') {\n+        !original_snippet[..pos].contains('\\n')\n+    } else {\n+        !original_snippet.contains('\\n')\n+    };\n+\n+    one_line_width -= first_sep.len();\n+    let first_sep = if prev_str.is_empty() || missing_comment.is_empty() {\n+        Cow::from(\"\")\n+    } else {\n+        let one_line_width = last_line_width(prev_str) + first_line_width(&missing_comment) + 1;\n+        if prefer_same_line && one_line_width <= shape.width {\n+            Cow::from(\" \")\n+        } else {\n+            indent.to_string_with_newline(config)\n+        }\n+    };\n+    result.push_str(&first_sep);\n+    result.push_str(&missing_comment);\n+\n+    let second_sep = if missing_comment.is_empty() || next_str.is_empty() {\n+        Cow::from(\"\")\n+    } else if missing_comment.starts_with(\"//\") {\n+        indent.to_string_with_newline(config)\n+    } else {\n+        one_line_width += missing_comment.len() + first_sep.len() + 1;\n+        allow_one_line &= !missing_comment.starts_with(\"//\") && !missing_comment.contains('\\n');\n+        if prefer_same_line && allow_one_line && one_line_width <= shape.width {\n+            Cow::from(\" \")\n+        } else {\n+            indent.to_string_with_newline(config)\n+        }\n+    };\n+    result.push_str(&second_sep);\n+    result.push_str(next_str);\n+\n+    Some(result)\n+}\n+\n+pub(crate) fn rewrite_doc_comment(orig: &str, shape: Shape, config: &Config) -> Option<String> {\n+    identify_comment(orig, false, shape, config, true)\n+}\n+\n+pub(crate) fn rewrite_comment(\n+    orig: &str,\n+    block_style: bool,\n+    shape: Shape,\n+    config: &Config,\n+) -> Option<String> {\n+    identify_comment(orig, block_style, shape, config, false)\n+}\n+\n+fn identify_comment(\n+    orig: &str,\n+    block_style: bool,\n+    shape: Shape,\n+    config: &Config,\n+    is_doc_comment: bool,\n+) -> Option<String> {\n+    let style = comment_style(orig, false);\n+\n+    // Computes the byte length of line taking into account a newline if the line is part of a\n+    // paragraph.\n+    fn compute_len(orig: &str, line: &str) -> usize {\n+        if orig.len() > line.len() {\n+            if orig.as_bytes()[line.len()] == b'\\r' {\n+                line.len() + 2\n+            } else {\n+                line.len() + 1\n+            }\n+        } else {\n+            line.len()\n+        }\n+    }\n+\n+    // Get the first group of line comments having the same commenting style.\n+    //\n+    // Returns a tuple with:\n+    // - a boolean indicating if there is a blank line\n+    // - a number indicating the size of the first group of comments\n+    fn consume_same_line_comments(\n+        style: CommentStyle<'_>,\n+        orig: &str,\n+        line_start: &str,\n+    ) -> (bool, usize) {\n+        let mut first_group_ending = 0;\n+        let mut hbl = false;\n+\n+        for line in orig.lines() {\n+            let trimmed_line = line.trim_start();\n+            if trimmed_line.is_empty() {\n+                hbl = true;\n+                break;\n+            } else if trimmed_line.starts_with(line_start)\n+                || comment_style(trimmed_line, false) == style\n+            {\n+                first_group_ending += compute_len(&orig[first_group_ending..], line);\n+            } else {\n+                break;\n+            }\n+        }\n+        (hbl, first_group_ending)\n+    }\n+\n+    let (has_bare_lines, first_group_ending) = match style {\n+        CommentStyle::DoubleSlash | CommentStyle::TripleSlash | CommentStyle::Doc => {\n+            let line_start = style.line_start().trim_start();\n+            consume_same_line_comments(style, orig, line_start)\n+        }\n+        CommentStyle::Custom(opener) => {\n+            let trimmed_opener = opener.trim_end();\n+            consume_same_line_comments(style, orig, trimmed_opener)\n+        }\n+        // for a block comment, search for the closing symbol\n+        CommentStyle::DoubleBullet | CommentStyle::SingleBullet | CommentStyle::Exclamation => {\n+            let closer = style.closer().trim_start();\n+            let mut count = orig.matches(closer).count();\n+            let mut closing_symbol_offset = 0;\n+            let mut hbl = false;\n+            let mut first = true;\n+            for line in orig.lines() {\n+                closing_symbol_offset += compute_len(&orig[closing_symbol_offset..], line);\n+                let mut trimmed_line = line.trim_start();\n+                if !trimmed_line.starts_with('*')\n+                    && !trimmed_line.starts_with(\"//\")\n+                    && !trimmed_line.starts_with(\"/*\")\n+                {\n+                    hbl = true;\n+                }\n+\n+                // Remove opener from consideration when searching for closer\n+                if first {\n+                    let opener = style.opener().trim_end();\n+                    trimmed_line = &trimmed_line[opener.len()..];\n+                    first = false;\n+                }\n+                if trimmed_line.ends_with(closer) {\n+                    count -= 1;\n+                    if count == 0 {\n+                        break;\n+                    }\n+                }\n+            }\n+            (hbl, closing_symbol_offset)\n+        }\n+    };\n+\n+    let (first_group, rest) = orig.split_at(first_group_ending);\n+    let rewritten_first_group =\n+        if !config.normalize_comments() && has_bare_lines && style.is_block_comment() {\n+            trim_left_preserve_layout(first_group, shape.indent, config)?\n+        } else if !config.normalize_comments()\n+            && !config.wrap_comments()\n+            && !config.format_code_in_doc_comments()\n+        {\n+            light_rewrite_comment(first_group, shape.indent, config, is_doc_comment)\n+        } else {\n+            rewrite_comment_inner(\n+                first_group,\n+                block_style,\n+                style,\n+                shape,\n+                config,\n+                is_doc_comment || style.is_doc_comment(),\n+            )?\n+        };\n+    if rest.is_empty() {\n+        Some(rewritten_first_group)\n+    } else {\n+        identify_comment(\n+            rest.trim_start(),\n+            block_style,\n+            shape,\n+            config,\n+            is_doc_comment,\n+        )\n+        .map(|rest_str| {\n+            format!(\n+                \"{}\\n{}{}{}\",\n+                rewritten_first_group,\n+                // insert back the blank line\n+                if has_bare_lines && style.is_line_comment() {\n+                    \"\\n\"\n+                } else {\n+                    \"\"\n+                },\n+                shape.indent.to_string(config),\n+                rest_str\n+            )\n+        })\n+    }\n+}\n+\n+/// Attributes for code blocks in rustdoc.\n+/// See https://doc.rust-lang.org/rustdoc/print.html#attributes\n+enum CodeBlockAttribute {\n+    Rust,\n+    Ignore,\n+    Text,\n+    ShouldPanic,\n+    NoRun,\n+    CompileFail,\n+}\n+\n+impl CodeBlockAttribute {\n+    fn new(attribute: &str) -> CodeBlockAttribute {\n+        match attribute {\n+            \"rust\" | \"\" => CodeBlockAttribute::Rust,\n+            \"ignore\" => CodeBlockAttribute::Ignore,\n+            \"text\" => CodeBlockAttribute::Text,\n+            \"should_panic\" => CodeBlockAttribute::ShouldPanic,\n+            \"no_run\" => CodeBlockAttribute::NoRun,\n+            \"compile_fail\" => CodeBlockAttribute::CompileFail,\n+            _ => CodeBlockAttribute::Text,\n+        }\n+    }\n+}\n+\n+/// Block that is formatted as an item.\n+///\n+/// An item starts with either a star `*` or a dash `-`. Different level of indentation are\n+/// handled by shrinking the shape accordingly.\n+struct ItemizedBlock {\n+    /// the lines that are identified as part of an itemized block\n+    lines: Vec<String>,\n+    /// the number of whitespaces up to the item sigil\n+    indent: usize,\n+    /// the string that marks the start of an item\n+    opener: String,\n+    /// sequence of whitespaces to prefix new lines that are part of the item\n+    line_start: String,\n+}\n+\n+impl ItemizedBlock {\n+    /// Returns `true` if the line is formatted as an item\n+    fn is_itemized_line(line: &str) -> bool {\n+        let trimmed = line.trim_start();\n+        trimmed.starts_with(\"* \") || trimmed.starts_with(\"- \")\n+    }\n+\n+    /// Creates a new ItemizedBlock described with the given line.\n+    /// The `is_itemized_line` needs to be called first.\n+    fn new(line: &str) -> ItemizedBlock {\n+        let space_to_sigil = line.chars().take_while(|c| c.is_whitespace()).count();\n+        let indent = space_to_sigil + 2;\n+        ItemizedBlock {\n+            lines: vec![line[indent..].to_string()],\n+            indent,\n+            opener: line[..indent].to_string(),\n+            line_start: \" \".repeat(indent),\n+        }\n+    }\n+\n+    /// Returns a `StringFormat` used for formatting the content of an item.\n+    fn create_string_format<'a>(&'a self, fmt: &'a StringFormat<'_>) -> StringFormat<'a> {\n+        StringFormat {\n+            opener: \"\",\n+            closer: \"\",\n+            line_start: \"\",\n+            line_end: \"\",\n+            shape: Shape::legacy(fmt.shape.width.saturating_sub(self.indent), Indent::empty()),\n+            trim_end: true,\n+            config: fmt.config,\n+        }\n+    }\n+\n+    /// Returns `true` if the line is part of the current itemized block.\n+    /// If it is, then it is added to the internal lines list.\n+    fn add_line(&mut self, line: &str) -> bool {\n+        if !ItemizedBlock::is_itemized_line(line)\n+            && self.indent <= line.chars().take_while(|c| c.is_whitespace()).count()\n+        {\n+            self.lines.push(line.to_string());\n+            return true;\n+        }\n+        false\n+    }\n+\n+    /// Returns the block as a string, with each line trimmed at the start.\n+    fn trimmed_block_as_string(&self) -> String {\n+        self.lines\n+            .iter()\n+            .map(|line| format!(\"{} \", line.trim_start()))\n+            .collect::<String>()\n+    }\n+\n+    /// Returns the block as a string under its original form.\n+    fn original_block_as_string(&self) -> String {\n+        self.lines.join(\"\\n\")\n+    }\n+}\n+\n+struct CommentRewrite<'a> {\n+    result: String,\n+    code_block_buffer: String,\n+    is_prev_line_multi_line: bool,\n+    code_block_attr: Option<CodeBlockAttribute>,\n+    item_block: Option<ItemizedBlock>,\n+    comment_line_separator: String,\n+    indent_str: String,\n+    max_width: usize,\n+    fmt_indent: Indent,\n+    fmt: StringFormat<'a>,\n+\n+    opener: String,\n+    closer: String,\n+    line_start: String,\n+}\n+\n+impl<'a> CommentRewrite<'a> {\n+    fn new(\n+        orig: &'a str,\n+        block_style: bool,\n+        shape: Shape,\n+        config: &'a Config,\n+    ) -> CommentRewrite<'a> {\n+        let (opener, closer, line_start) = if block_style {\n+            CommentStyle::SingleBullet.to_str_tuplet()\n+        } else {\n+            comment_style(orig, config.normalize_comments()).to_str_tuplet()\n+        };\n+\n+        let max_width = shape\n+            .width\n+            .checked_sub(closer.len() + opener.len())\n+            .unwrap_or(1);\n+        let indent_str = shape.indent.to_string_with_newline(config).to_string();\n+\n+        let mut cr = CommentRewrite {\n+            result: String::with_capacity(orig.len() * 2),\n+            code_block_buffer: String::with_capacity(128),\n+            is_prev_line_multi_line: false,\n+            code_block_attr: None,\n+            item_block: None,\n+            comment_line_separator: format!(\"{}{}\", indent_str, line_start),\n+            max_width,\n+            indent_str,\n+            fmt_indent: shape.indent,\n+\n+            fmt: StringFormat {\n+                opener: \"\",\n+                closer: \"\",\n+                line_start,\n+                line_end: \"\",\n+                shape: Shape::legacy(max_width, shape.indent),\n+                trim_end: true,\n+                config,\n+            },\n+\n+            opener: opener.to_owned(),\n+            closer: closer.to_owned(),\n+            line_start: line_start.to_owned(),\n+        };\n+        cr.result.push_str(opener);\n+        cr\n+    }\n+\n+    fn join_block(s: &str, sep: &str) -> String {\n+        let mut result = String::with_capacity(s.len() + 128);\n+        let mut iter = s.lines().peekable();\n+        while let Some(line) = iter.next() {\n+            result.push_str(line);\n+            result.push_str(match iter.peek() {\n+                Some(next_line) if next_line.is_empty() => sep.trim_end(),\n+                Some(..) => &sep,\n+                None => \"\",\n+            });\n+        }\n+        result\n+    }\n+\n+    fn finish(mut self) -> String {\n+        if !self.code_block_buffer.is_empty() {\n+            // There is a code block that is not properly enclosed by backticks.\n+            // We will leave them untouched.\n+            self.result.push_str(&self.comment_line_separator);\n+            self.result.push_str(&Self::join_block(\n+                &trim_custom_comment_prefix(&self.code_block_buffer),\n+                &self.comment_line_separator,\n+            ));\n+        }\n+\n+        if let Some(ref ib) = self.item_block {\n+            // the last few lines are part of an itemized block\n+            self.fmt.shape = Shape::legacy(self.max_width, self.fmt_indent);\n+            let item_fmt = ib.create_string_format(&self.fmt);\n+            self.result.push_str(&self.comment_line_separator);\n+            self.result.push_str(&ib.opener);\n+            match rewrite_string(\n+                &ib.trimmed_block_as_string(),\n+                &item_fmt,\n+                self.max_width.saturating_sub(ib.indent),\n+            ) {\n+                Some(s) => self.result.push_str(&Self::join_block(\n+                    &s,\n+                    &format!(\"{}{}\", self.comment_line_separator, ib.line_start),\n+                )),\n+                None => self.result.push_str(&Self::join_block(\n+                    &ib.original_block_as_string(),\n+                    &self.comment_line_separator,\n+                )),\n+            };\n+        }\n+\n+        self.result.push_str(&self.closer);\n+        if self.result.ends_with(&self.opener) && self.opener.ends_with(' ') {\n+            // Trailing space.\n+            self.result.pop();\n+        }\n+\n+        self.result\n+    }\n+\n+    fn handle_line(\n+        &mut self,\n+        orig: &'a str,\n+        i: usize,\n+        line: &'a str,\n+        has_leading_whitespace: bool,\n+    ) -> bool {\n+        let is_last = i == count_newlines(orig);\n+\n+        if let Some(ref mut ib) = self.item_block {\n+            if ib.add_line(&line) {\n+                return false;\n+            }\n+            self.is_prev_line_multi_line = false;\n+            self.fmt.shape = Shape::legacy(self.max_width, self.fmt_indent);\n+            let item_fmt = ib.create_string_format(&self.fmt);\n+            self.result.push_str(&self.comment_line_separator);\n+            self.result.push_str(&ib.opener);\n+            match rewrite_string(\n+                &ib.trimmed_block_as_string(),\n+                &item_fmt,\n+                self.max_width.saturating_sub(ib.indent),\n+            ) {\n+                Some(s) => self.result.push_str(&Self::join_block(\n+                    &s,\n+                    &format!(\"{}{}\", self.comment_line_separator, ib.line_start),\n+                )),\n+                None => self.result.push_str(&Self::join_block(\n+                    &ib.original_block_as_string(),\n+                    &self.comment_line_separator,\n+                )),\n+            };\n+        } else if self.code_block_attr.is_some() {\n+            if line.starts_with(\"```\") {\n+                let code_block = match self.code_block_attr.as_ref().unwrap() {\n+                    CodeBlockAttribute::Ignore | CodeBlockAttribute::Text => {\n+                        trim_custom_comment_prefix(&self.code_block_buffer)\n+                    }\n+                    _ if self.code_block_buffer.is_empty() => String::new(),\n+                    _ => {\n+                        let mut config = self.fmt.config.clone();\n+                        config.set().wrap_comments(false);\n+                        if config.format_code_in_doc_comments() {\n+                            if let Some(s) =\n+                                crate::format_code_block(&self.code_block_buffer, &config, false)\n+                            {\n+                                trim_custom_comment_prefix(&s.snippet)\n+                            } else {\n+                                trim_custom_comment_prefix(&self.code_block_buffer)\n+                            }\n+                        } else {\n+                            trim_custom_comment_prefix(&self.code_block_buffer)\n+                        }\n+                    }\n+                };\n+                if !code_block.is_empty() {\n+                    self.result.push_str(&self.comment_line_separator);\n+                    self.result\n+                        .push_str(&Self::join_block(&code_block, &self.comment_line_separator));\n+                }\n+                self.code_block_buffer.clear();\n+                self.result.push_str(&self.comment_line_separator);\n+                self.result.push_str(line);\n+                self.code_block_attr = None;\n+            } else {\n+                self.code_block_buffer\n+                    .push_str(&hide_sharp_behind_comment(line));\n+                self.code_block_buffer.push('\\n');\n+            }\n+            return false;\n+        }\n+\n+        self.code_block_attr = None;\n+        self.item_block = None;\n+        if line.starts_with(\"```\") {\n+            self.code_block_attr = Some(CodeBlockAttribute::new(&line[3..]))\n+        } else if self.fmt.config.wrap_comments() && ItemizedBlock::is_itemized_line(&line) {\n+            let ib = ItemizedBlock::new(&line);\n+            self.item_block = Some(ib);\n+            return false;\n+        }\n+\n+        if self.result == self.opener {\n+            let force_leading_whitespace = &self.opener == \"/* \" && count_newlines(orig) == 0;\n+            if !has_leading_whitespace && !force_leading_whitespace && self.result.ends_with(' ') {\n+                self.result.pop();\n+            }\n+            if line.is_empty() {\n+                return false;\n+            }\n+        } else if self.is_prev_line_multi_line && !line.is_empty() {\n+            self.result.push(' ')\n+        } else if is_last && line.is_empty() {\n+            // trailing blank lines are unwanted\n+            if !self.closer.is_empty() {\n+                self.result.push_str(&self.indent_str);\n+            }\n+            return true;\n+        } else {\n+            self.result.push_str(&self.comment_line_separator);\n+            if !has_leading_whitespace && self.result.ends_with(' ') {\n+                self.result.pop();\n+            }\n+        }\n+\n+        if self.fmt.config.wrap_comments()\n+            && unicode_str_width(line) > self.fmt.shape.width\n+            && !has_url(line)\n+        {\n+            match rewrite_string(line, &self.fmt, self.max_width) {\n+                Some(ref s) => {\n+                    self.is_prev_line_multi_line = s.contains('\\n');\n+                    self.result.push_str(s);\n+                }\n+                None if self.is_prev_line_multi_line => {\n+                    // We failed to put the current `line` next to the previous `line`.\n+                    // Remove the trailing space, then start rewrite on the next line.\n+                    self.result.pop();\n+                    self.result.push_str(&self.comment_line_separator);\n+                    self.fmt.shape = Shape::legacy(self.max_width, self.fmt_indent);\n+                    match rewrite_string(line, &self.fmt, self.max_width) {\n+                        Some(ref s) => {\n+                            self.is_prev_line_multi_line = s.contains('\\n');\n+                            self.result.push_str(s);\n+                        }\n+                        None => {\n+                            self.is_prev_line_multi_line = false;\n+                            self.result.push_str(line);\n+                        }\n+                    }\n+                }\n+                None => {\n+                    self.is_prev_line_multi_line = false;\n+                    self.result.push_str(line);\n+                }\n+            }\n+\n+            self.fmt.shape = if self.is_prev_line_multi_line {\n+                // 1 = \" \"\n+                let offset = 1 + last_line_width(&self.result) - self.line_start.len();\n+                Shape {\n+                    width: self.max_width.saturating_sub(offset),\n+                    indent: self.fmt_indent,\n+                    offset: self.fmt.shape.offset + offset,\n+                }\n+            } else {\n+                Shape::legacy(self.max_width, self.fmt_indent)\n+            };\n+        } else {\n+            if line.is_empty() && self.result.ends_with(' ') && !is_last {\n+                // Remove space if this is an empty comment or a doc comment.\n+                self.result.pop();\n+            }\n+            self.result.push_str(line);\n+            self.fmt.shape = Shape::legacy(self.max_width, self.fmt_indent);\n+            self.is_prev_line_multi_line = false;\n+        }\n+\n+        false\n+    }\n+}\n+\n+fn rewrite_comment_inner(\n+    orig: &str,\n+    block_style: bool,\n+    style: CommentStyle<'_>,\n+    shape: Shape,\n+    config: &Config,\n+    is_doc_comment: bool,\n+) -> Option<String> {\n+    let mut rewriter = CommentRewrite::new(orig, block_style, shape, config);\n+\n+    let line_breaks = count_newlines(orig.trim_end());\n+    let lines = orig\n+        .lines()\n+        .enumerate()\n+        .map(|(i, mut line)| {\n+            line = trim_end_unless_two_whitespaces(line.trim_start(), is_doc_comment);\n+            // Drop old closer.\n+            if i == line_breaks && line.ends_with(\"*/\") && !line.starts_with(\"//\") {\n+                line = line[..(line.len() - 2)].trim_end();\n+            }\n+\n+            line\n+        })\n+        .map(|s| left_trim_comment_line(s, &style))\n+        .map(|(line, has_leading_whitespace)| {\n+            if orig.starts_with(\"/*\") && line_breaks == 0 {\n+                (\n+                    line.trim_start(),\n+                    has_leading_whitespace || config.normalize_comments(),\n+                )\n+            } else {\n+                (line, has_leading_whitespace || config.normalize_comments())\n+            }\n+        });\n+\n+    for (i, (line, has_leading_whitespace)) in lines.enumerate() {\n+        if rewriter.handle_line(orig, i, line, has_leading_whitespace) {\n+            break;\n+        }\n+    }\n+\n+    Some(rewriter.finish())\n+}\n+\n+const RUSTFMT_CUSTOM_COMMENT_PREFIX: &str = \"//#### \";\n+\n+fn hide_sharp_behind_comment(s: &str) -> Cow<'_, str> {\n+    let s_trimmed = s.trim();\n+    if s_trimmed.starts_with(\"# \") || s_trimmed == \"#\" {\n+        Cow::from(format!(\"{}{}\", RUSTFMT_CUSTOM_COMMENT_PREFIX, s))\n+    } else {\n+        Cow::from(s)\n+    }\n+}\n+\n+fn trim_custom_comment_prefix(s: &str) -> String {\n+    s.lines()\n+        .map(|line| {\n+            let left_trimmed = line.trim_start();\n+            if left_trimmed.starts_with(RUSTFMT_CUSTOM_COMMENT_PREFIX) {\n+                left_trimmed.trim_start_matches(RUSTFMT_CUSTOM_COMMENT_PREFIX)\n+            } else {\n+                line\n+            }\n+        })\n+        .collect::<Vec<_>>()\n+        .join(\"\\n\")\n+}\n+\n+/// Returns `true` if the given string MAY include URLs or alike.\n+fn has_url(s: &str) -> bool {\n+    // This function may return false positive, but should get its job done in most cases.\n+    s.contains(\"https://\") || s.contains(\"http://\") || s.contains(\"ftp://\") || s.contains(\"file://\")\n+}\n+\n+/// Given the span, rewrite the missing comment inside it if available.\n+/// Note that the given span must only include comments (or leading/trailing whitespaces).\n+pub(crate) fn rewrite_missing_comment(\n+    span: Span,\n+    shape: Shape,\n+    context: &RewriteContext<'_>,\n+) -> Option<String> {\n+    let missing_snippet = context.snippet(span);\n+    let trimmed_snippet = missing_snippet.trim();\n+    // check the span starts with a comment\n+    let pos = trimmed_snippet.find('/');\n+    if !trimmed_snippet.is_empty() && pos.is_some() {\n+        rewrite_comment(trimmed_snippet, false, shape, context.config)\n+    } else {\n+        Some(String::new())\n+    }\n+}\n+\n+/// Recover the missing comments in the specified span, if available.\n+/// The layout of the comments will be preserved as long as it does not break the code\n+/// and its total width does not exceed the max width.\n+pub(crate) fn recover_missing_comment_in_span(\n+    span: Span,\n+    shape: Shape,\n+    context: &RewriteContext<'_>,\n+    used_width: usize,\n+) -> Option<String> {\n+    let missing_comment = rewrite_missing_comment(span, shape, context)?;\n+    if missing_comment.is_empty() {\n+        Some(String::new())\n+    } else {\n+        let missing_snippet = context.snippet(span);\n+        let pos = missing_snippet.find('/')?;\n+        // 1 = ` `\n+        let total_width = missing_comment.len() + used_width + 1;\n+        let force_new_line_before_comment =\n+            missing_snippet[..pos].contains('\\n') || total_width > context.config.max_width();\n+        let sep = if force_new_line_before_comment {\n+            shape.indent.to_string_with_newline(context.config)\n+        } else {\n+            Cow::from(\" \")\n+        };\n+        Some(format!(\"{}{}\", sep, missing_comment))\n+    }\n+}\n+\n+/// Trim trailing whitespaces unless they consist of two or more whitespaces.\n+fn trim_end_unless_two_whitespaces(s: &str, is_doc_comment: bool) -> &str {\n+    if is_doc_comment && s.ends_with(\"  \") {\n+        s\n+    } else {\n+        s.trim_end()\n+    }\n+}\n+\n+/// Trims whitespace and aligns to indent, but otherwise does not change comments.\n+fn light_rewrite_comment(\n+    orig: &str,\n+    offset: Indent,\n+    config: &Config,\n+    is_doc_comment: bool,\n+) -> String {\n+    let lines: Vec<&str> = orig\n+        .lines()\n+        .map(|l| {\n+            // This is basically just l.trim(), but in the case that a line starts\n+            // with `*` we want to leave one space before it, so it aligns with the\n+            // `*` in `/*`.\n+            let first_non_whitespace = l.find(|c| !char::is_whitespace(c));\n+            let left_trimmed = if let Some(fnw) = first_non_whitespace {\n+                if l.as_bytes()[fnw] == b'*' && fnw > 0 {\n+                    &l[fnw - 1..]\n+                } else {\n+                    &l[fnw..]\n+                }\n+            } else {\n+                \"\"\n+            };\n+            // Preserve markdown's double-space line break syntax in doc comment.\n+            trim_end_unless_two_whitespaces(left_trimmed, is_doc_comment)\n+        })\n+        .collect();\n+    lines.join(&format!(\"\\n{}\", offset.to_string(config)))\n+}\n+\n+/// Trims comment characters and possibly a single space from the left of a string.\n+/// Does not trim all whitespace. If a single space is trimmed from the left of the string,\n+/// this function returns true.\n+fn left_trim_comment_line<'a>(line: &'a str, style: &CommentStyle<'_>) -> (&'a str, bool) {\n+    if line.starts_with(\"//! \")\n+        || line.starts_with(\"/// \")\n+        || line.starts_with(\"/*! \")\n+        || line.starts_with(\"/** \")\n+    {\n+        (&line[4..], true)\n+    } else if let CommentStyle::Custom(opener) = *style {\n+        if line.starts_with(opener) {\n+            (&line[opener.len()..], true)\n+        } else {\n+            (&line[opener.trim_end().len()..], false)\n+        }\n+    } else if line.starts_with(\"/* \")\n+        || line.starts_with(\"// \")\n+        || line.starts_with(\"//!\")\n+        || line.starts_with(\"///\")\n+        || line.starts_with(\"** \")\n+        || line.starts_with(\"/*!\")\n+        || (line.starts_with(\"/**\") && !line.starts_with(\"/**/\"))\n+    {\n+        (&line[3..], line.chars().nth(2).unwrap() == ' ')\n+    } else if line.starts_with(\"/*\")\n+        || line.starts_with(\"* \")\n+        || line.starts_with(\"//\")\n+        || line.starts_with(\"**\")\n+    {\n+        (&line[2..], line.chars().nth(1).unwrap() == ' ')\n+    } else if line.starts_with('*') {\n+        (&line[1..], false)\n+    } else {\n+        (line, line.starts_with(' '))\n+    }\n+}\n+\n+pub(crate) trait FindUncommented {\n+    fn find_uncommented(&self, pat: &str) -> Option<usize>;\n+    fn find_last_uncommented(&self, pat: &str) -> Option<usize>;\n+}\n+\n+impl FindUncommented for str {\n+    fn find_uncommented(&self, pat: &str) -> Option<usize> {\n+        let mut needle_iter = pat.chars();\n+        for (kind, (i, b)) in CharClasses::new(self.char_indices()) {\n+            match needle_iter.next() {\n+                None => {\n+                    return Some(i - pat.len());\n+                }\n+                Some(c) => match kind {\n+                    FullCodeCharKind::Normal | FullCodeCharKind::InString if b == c => {}\n+                    _ => {\n+                        needle_iter = pat.chars();\n+                    }\n+                },\n+            }\n+        }\n+\n+        // Handle case where the pattern is a suffix of the search string\n+        match needle_iter.next() {\n+            Some(_) => None,\n+            None => Some(self.len() - pat.len()),\n+        }\n+    }\n+\n+    fn find_last_uncommented(&self, pat: &str) -> Option<usize> {\n+        if let Some(left) = self.find_uncommented(pat) {\n+            let mut result = left;\n+            // add 1 to use find_last_uncommented for &str after pat\n+            while let Some(next) = self[(result + 1)..].find_last_uncommented(pat) {\n+                result += next + 1;\n+            }\n+            Some(result)\n+        } else {\n+            None\n+        }\n+    }\n+}\n+\n+// Returns the first byte position after the first comment. The given string\n+// is expected to be prefixed by a comment, including delimiters.\n+// Good: `/* /* inner */ outer */ code();`\n+// Bad:  `code(); // hello\\n world!`\n+pub(crate) fn find_comment_end(s: &str) -> Option<usize> {\n+    let mut iter = CharClasses::new(s.char_indices());\n+    for (kind, (i, _c)) in &mut iter {\n+        if kind == FullCodeCharKind::Normal || kind == FullCodeCharKind::InString {\n+            return Some(i);\n+        }\n+    }\n+\n+    // Handle case where the comment ends at the end of `s`.\n+    if iter.status == CharClassesStatus::Normal {\n+        Some(s.len())\n+    } else {\n+        None\n+    }\n+}\n+\n+/// Returns `true` if text contains any comment.\n+pub(crate) fn contains_comment(text: &str) -> bool {\n+    CharClasses::new(text.chars()).any(|(kind, _)| kind.is_comment())\n+}\n+\n+pub(crate) struct CharClasses<T>\n+where\n+    T: Iterator,\n+    T::Item: RichChar,\n+{\n+    base: MultiPeek<T>,\n+    status: CharClassesStatus,\n+}\n+\n+pub(crate) trait RichChar {\n+    fn get_char(&self) -> char;\n+}\n+\n+impl RichChar for char {\n+    fn get_char(&self) -> char {\n+        *self\n+    }\n+}\n+\n+impl RichChar for (usize, char) {\n+    fn get_char(&self) -> char {\n+        self.1\n+    }\n+}\n+\n+#[derive(PartialEq, Eq, Debug, Clone, Copy)]\n+enum CharClassesStatus {\n+    Normal,\n+    /// Character is within a string\n+    LitString,\n+    LitStringEscape,\n+    /// Character is within a raw string\n+    LitRawString(u32),\n+    RawStringPrefix(u32),\n+    RawStringSuffix(u32),\n+    LitChar,\n+    LitCharEscape,\n+    /// Character inside a block comment, with the integer indicating the nesting deepness of the\n+    /// comment\n+    BlockComment(u32),\n+    /// Character inside a block-commented string, with the integer indicating the nesting deepness\n+    /// of the comment\n+    StringInBlockComment(u32),\n+    /// Status when the '/' has been consumed, but not yet the '*', deepness is\n+    /// the new deepness (after the comment opening).\n+    BlockCommentOpening(u32),\n+    /// Status when the '*' has been consumed, but not yet the '/', deepness is\n+    /// the new deepness (after the comment closing).\n+    BlockCommentClosing(u32),\n+    /// Character is within a line comment\n+    LineComment,\n+}\n+\n+/// Distinguish between functional part of code and comments\n+#[derive(PartialEq, Eq, Debug, Clone, Copy)]\n+pub(crate) enum CodeCharKind {\n+    Normal,\n+    Comment,\n+}\n+\n+/// Distinguish between functional part of code and comments,\n+/// describing opening and closing of comments for ease when chunking\n+/// code from tagged characters\n+#[derive(PartialEq, Eq, Debug, Clone, Copy)]\n+pub(crate) enum FullCodeCharKind {\n+    Normal,\n+    /// The first character of a comment, there is only one for a comment (always '/')\n+    StartComment,\n+    /// Any character inside a comment including the second character of comment\n+    /// marks (\"//\", \"/*\")\n+    InComment,\n+    /// Last character of a comment, '\\n' for a line comment, '/' for a block comment.\n+    EndComment,\n+    /// Start of a mutlitine string inside a comment\n+    StartStringCommented,\n+    /// End of a mutlitine string inside a comment\n+    EndStringCommented,\n+    /// Inside a commented string\n+    InStringCommented,\n+    /// Start of a mutlitine string\n+    StartString,\n+    /// End of a mutlitine string\n+    EndString,\n+    /// Inside a string.\n+    InString,\n+}\n+\n+impl FullCodeCharKind {\n+    pub(crate) fn is_comment(self) -> bool {\n+        match self {\n+            FullCodeCharKind::StartComment\n+            | FullCodeCharKind::InComment\n+            | FullCodeCharKind::EndComment\n+            | FullCodeCharKind::StartStringCommented\n+            | FullCodeCharKind::InStringCommented\n+            | FullCodeCharKind::EndStringCommented => true,\n+            _ => false,\n+        }\n+    }\n+\n+    /// Returns true if the character is inside a comment\n+    pub(crate) fn inside_comment(self) -> bool {\n+        match self {\n+            FullCodeCharKind::InComment\n+            | FullCodeCharKind::StartStringCommented\n+            | FullCodeCharKind::InStringCommented\n+            | FullCodeCharKind::EndStringCommented => true,\n+            _ => false,\n+        }\n+    }\n+\n+    pub(crate) fn is_string(self) -> bool {\n+        self == FullCodeCharKind::InString || self == FullCodeCharKind::StartString\n+    }\n+\n+    /// Returns true if the character is within a commented string\n+    pub(crate) fn is_commented_string(self) -> bool {\n+        self == FullCodeCharKind::InStringCommented\n+            || self == FullCodeCharKind::StartStringCommented\n+    }\n+\n+    fn to_codecharkind(self) -> CodeCharKind {\n+        if self.is_comment() {\n+            CodeCharKind::Comment\n+        } else {\n+            CodeCharKind::Normal\n+        }\n+    }\n+}\n+\n+impl<T> CharClasses<T>\n+where\n+    T: Iterator,\n+    T::Item: RichChar,\n+{\n+    pub(crate) fn new(base: T) -> CharClasses<T> {\n+        CharClasses {\n+            base: multipeek(base),\n+            status: CharClassesStatus::Normal,\n+        }\n+    }\n+}\n+\n+fn is_raw_string_suffix<T>(iter: &mut MultiPeek<T>, count: u32) -> bool\n+where\n+    T: Iterator,\n+    T::Item: RichChar,\n+{\n+    for _ in 0..count {\n+        match iter.peek() {\n+            Some(c) if c.get_char() == '#' => continue,\n+            _ => return false,\n+        }\n+    }\n+    true\n+}\n+\n+impl<T> Iterator for CharClasses<T>\n+where\n+    T: Iterator,\n+    T::Item: RichChar,\n+{\n+    type Item = (FullCodeCharKind, T::Item);\n+\n+    fn next(&mut self) -> Option<(FullCodeCharKind, T::Item)> {\n+        let item = self.base.next()?;\n+        let chr = item.get_char();\n+        let mut char_kind = FullCodeCharKind::Normal;\n+        self.status = match self.status {\n+            CharClassesStatus::LitRawString(sharps) => {\n+                char_kind = FullCodeCharKind::InString;\n+                match chr {\n+                    '\"' => {\n+                        if sharps == 0 {\n+                            char_kind = FullCodeCharKind::Normal;\n+                            CharClassesStatus::Normal\n+                        } else if is_raw_string_suffix(&mut self.base, sharps) {\n+                            CharClassesStatus::RawStringSuffix(sharps)\n+                        } else {\n+                            CharClassesStatus::LitRawString(sharps)\n+                        }\n+                    }\n+                    _ => CharClassesStatus::LitRawString(sharps),\n+                }\n+            }\n+            CharClassesStatus::RawStringPrefix(sharps) => {\n+                char_kind = FullCodeCharKind::InString;\n+                match chr {\n+                    '#' => CharClassesStatus::RawStringPrefix(sharps + 1),\n+                    '\"' => CharClassesStatus::LitRawString(sharps),\n+                    _ => CharClassesStatus::Normal, // Unreachable.\n+                }\n+            }\n+            CharClassesStatus::RawStringSuffix(sharps) => {\n+                match chr {\n+                    '#' => {\n+                        if sharps == 1 {\n+                            CharClassesStatus::Normal\n+                        } else {\n+                            char_kind = FullCodeCharKind::InString;\n+                            CharClassesStatus::RawStringSuffix(sharps - 1)\n+                        }\n+                    }\n+                    _ => CharClassesStatus::Normal, // Unreachable\n+                }\n+            }\n+            CharClassesStatus::LitString => {\n+                char_kind = FullCodeCharKind::InString;\n+                match chr {\n+                    '\"' => CharClassesStatus::Normal,\n+                    '\\\\' => CharClassesStatus::LitStringEscape,\n+                    _ => CharClassesStatus::LitString,\n+                }\n+            }\n+            CharClassesStatus::LitStringEscape => {\n+                char_kind = FullCodeCharKind::InString;\n+                CharClassesStatus::LitString\n+            }\n+            CharClassesStatus::LitChar => match chr {\n+                '\\\\' => CharClassesStatus::LitCharEscape,\n+                '\\'' => CharClassesStatus::Normal,\n+                _ => CharClassesStatus::LitChar,\n+            },\n+            CharClassesStatus::LitCharEscape => CharClassesStatus::LitChar,\n+            CharClassesStatus::Normal => match chr {\n+                'r' => match self.base.peek().map(RichChar::get_char) {\n+                    Some('#') | Some('\"') => {\n+                        char_kind = FullCodeCharKind::InString;\n+                        CharClassesStatus::RawStringPrefix(0)\n+                    }\n+                    _ => CharClassesStatus::Normal,\n+                },\n+                '\"' => {\n+                    char_kind = FullCodeCharKind::InString;\n+                    CharClassesStatus::LitString\n+                }\n+                '\\'' => {\n+                    // HACK: Work around mut borrow.\n+                    match self.base.peek() {\n+                        Some(next) if next.get_char() == '\\\\' => {\n+                            self.status = CharClassesStatus::LitChar;\n+                            return Some((char_kind, item));\n+                        }\n+                        _ => (),\n+                    }\n+\n+                    match self.base.peek() {\n+                        Some(next) if next.get_char() == '\\'' => CharClassesStatus::LitChar,\n+                        _ => CharClassesStatus::Normal,\n+                    }\n+                }\n+                '/' => match self.base.peek() {\n+                    Some(next) if next.get_char() == '*' => {\n+                        self.status = CharClassesStatus::BlockCommentOpening(1);\n+                        return Some((FullCodeCharKind::StartComment, item));\n+                    }\n+                    Some(next) if next.get_char() == '/' => {\n+                        self.status = CharClassesStatus::LineComment;\n+                        return Some((FullCodeCharKind::StartComment, item));\n+                    }\n+                    _ => CharClassesStatus::Normal,\n+                },\n+                _ => CharClassesStatus::Normal,\n+            },\n+            CharClassesStatus::StringInBlockComment(deepness) => {\n+                char_kind = FullCodeCharKind::InStringCommented;\n+                if chr == '\"' {\n+                    CharClassesStatus::BlockComment(deepness)\n+                } else if chr == '*' && self.base.peek().map(RichChar::get_char) == Some('/') {\n+                    char_kind = FullCodeCharKind::InComment;\n+                    CharClassesStatus::BlockCommentClosing(deepness - 1)\n+                } else {\n+                    CharClassesStatus::StringInBlockComment(deepness)\n+                }\n+            }\n+            CharClassesStatus::BlockComment(deepness) => {\n+                assert_ne!(deepness, 0);\n+                char_kind = FullCodeCharKind::InComment;\n+                match self.base.peek() {\n+                    Some(next) if next.get_char() == '/' && chr == '*' => {\n+                        CharClassesStatus::BlockCommentClosing(deepness - 1)\n+                    }\n+                    Some(next) if next.get_char() == '*' && chr == '/' => {\n+                        CharClassesStatus::BlockCommentOpening(deepness + 1)\n+                    }\n+                    _ if chr == '\"' => CharClassesStatus::StringInBlockComment(deepness),\n+                    _ => self.status,\n+                }\n+            }\n+            CharClassesStatus::BlockCommentOpening(deepness) => {\n+                assert_eq!(chr, '*');\n+                self.status = CharClassesStatus::BlockComment(deepness);\n+                return Some((FullCodeCharKind::InComment, item));\n+            }\n+            CharClassesStatus::BlockCommentClosing(deepness) => {\n+                assert_eq!(chr, '/');\n+                if deepness == 0 {\n+                    self.status = CharClassesStatus::Normal;\n+                    return Some((FullCodeCharKind::EndComment, item));\n+                } else {\n+                    self.status = CharClassesStatus::BlockComment(deepness);\n+                    return Some((FullCodeCharKind::InComment, item));\n+                }\n+            }\n+            CharClassesStatus::LineComment => match chr {\n+                '\\n' => {\n+                    self.status = CharClassesStatus::Normal;\n+                    return Some((FullCodeCharKind::EndComment, item));\n+                }\n+                _ => {\n+                    self.status = CharClassesStatus::LineComment;\n+                    return Some((FullCodeCharKind::InComment, item));\n+                }\n+            },\n+        };\n+        Some((char_kind, item))\n+    }\n+}\n+\n+/// An iterator over the lines of a string, paired with the char kind at the\n+/// end of the line.\n+pub(crate) struct LineClasses<'a> {\n+    base: iter::Peekable<CharClasses<std::str::Chars<'a>>>,\n+    kind: FullCodeCharKind,\n+}\n+\n+impl<'a> LineClasses<'a> {\n+    pub(crate) fn new(s: &'a str) -> Self {\n+        LineClasses {\n+            base: CharClasses::new(s.chars()).peekable(),\n+            kind: FullCodeCharKind::Normal,\n+        }\n+    }\n+}\n+\n+impl<'a> Iterator for LineClasses<'a> {\n+    type Item = (FullCodeCharKind, String);\n+\n+    fn next(&mut self) -> Option<Self::Item> {\n+        self.base.peek()?;\n+\n+        let mut line = String::new();\n+\n+        let start_kind = match self.base.peek() {\n+            Some((kind, _)) => *kind,\n+            None => unreachable!(),\n+        };\n+\n+        while let Some((kind, c)) = self.base.next() {\n+            // needed to set the kind of the ending character on the last line\n+            self.kind = kind;\n+            if c == '\\n' {\n+                self.kind = match (start_kind, kind) {\n+                    (FullCodeCharKind::Normal, FullCodeCharKind::InString) => {\n+                        FullCodeCharKind::StartString\n+                    }\n+                    (FullCodeCharKind::InString, FullCodeCharKind::Normal) => {\n+                        FullCodeCharKind::EndString\n+                    }\n+                    (FullCodeCharKind::InComment, FullCodeCharKind::InStringCommented) => {\n+                        FullCodeCharKind::StartStringCommented\n+                    }\n+                    (FullCodeCharKind::InStringCommented, FullCodeCharKind::InComment) => {\n+                        FullCodeCharKind::EndStringCommented\n+                    }\n+                    _ => kind,\n+                };\n+                break;\n+            }\n+            line.push(c);\n+        }\n+\n+        // Workaround for CRLF newline.\n+        if line.ends_with('\\r') {\n+            line.pop();\n+        }\n+\n+        Some((self.kind, line))\n+    }\n+}\n+\n+/// Iterator over functional and commented parts of a string. Any part of a string is either\n+/// functional code, either *one* block comment, either *one* line comment. Whitespace between\n+/// comments is functional code. Line comments contain their ending newlines.\n+struct UngroupedCommentCodeSlices<'a> {\n+    slice: &'a str,\n+    iter: iter::Peekable<CharClasses<std::str::CharIndices<'a>>>,\n+}\n+\n+impl<'a> UngroupedCommentCodeSlices<'a> {\n+    fn new(code: &'a str) -> UngroupedCommentCodeSlices<'a> {\n+        UngroupedCommentCodeSlices {\n+            slice: code,\n+            iter: CharClasses::new(code.char_indices()).peekable(),\n+        }\n+    }\n+}\n+\n+impl<'a> Iterator for UngroupedCommentCodeSlices<'a> {\n+    type Item = (CodeCharKind, usize, &'a str);\n+\n+    fn next(&mut self) -> Option<Self::Item> {\n+        let (kind, (start_idx, _)) = self.iter.next()?;\n+        match kind {\n+            FullCodeCharKind::Normal | FullCodeCharKind::InString => {\n+                // Consume all the Normal code\n+                while let Some(&(char_kind, _)) = self.iter.peek() {\n+                    if char_kind.is_comment() {\n+                        break;\n+                    }\n+                    let _ = self.iter.next();\n+                }\n+            }\n+            FullCodeCharKind::StartComment => {\n+                // Consume the whole comment\n+                loop {\n+                    match self.iter.next() {\n+                        Some((kind, ..)) if kind.inside_comment() => continue,\n+                        _ => break,\n+                    }\n+                }\n+            }\n+            _ => panic!(),\n+        }\n+        let slice = match self.iter.peek() {\n+            Some(&(_, (end_idx, _))) => &self.slice[start_idx..end_idx],\n+            None => &self.slice[start_idx..],\n+        };\n+        Some((\n+            if kind.is_comment() {\n+                CodeCharKind::Comment\n+            } else {\n+                CodeCharKind::Normal\n+            },\n+            start_idx,\n+            slice,\n+        ))\n+    }\n+}\n+\n+/// Iterator over an alternating sequence of functional and commented parts of\n+/// a string. The first item is always a, possibly zero length, subslice of\n+/// functional text. Line style comments contain their ending newlines.\n+pub(crate) struct CommentCodeSlices<'a> {\n+    slice: &'a str,\n+    last_slice_kind: CodeCharKind,\n+    last_slice_end: usize,\n+}\n+\n+impl<'a> CommentCodeSlices<'a> {\n+    pub(crate) fn new(slice: &'a str) -> CommentCodeSlices<'a> {\n+        CommentCodeSlices {\n+            slice,\n+            last_slice_kind: CodeCharKind::Comment,\n+            last_slice_end: 0,\n+        }\n+    }\n+}\n+\n+impl<'a> Iterator for CommentCodeSlices<'a> {\n+    type Item = (CodeCharKind, usize, &'a str);\n+\n+    fn next(&mut self) -> Option<Self::Item> {\n+        if self.last_slice_end == self.slice.len() {\n+            return None;\n+        }\n+\n+        let mut sub_slice_end = self.last_slice_end;\n+        let mut first_whitespace = None;\n+        let subslice = &self.slice[self.last_slice_end..];\n+        let mut iter = CharClasses::new(subslice.char_indices());\n+\n+        for (kind, (i, c)) in &mut iter {\n+            let is_comment_connector = self.last_slice_kind == CodeCharKind::Normal\n+                && &subslice[..2] == \"//\"\n+                && [' ', '\\t'].contains(&c);\n+\n+            if is_comment_connector && first_whitespace.is_none() {\n+                first_whitespace = Some(i);\n+            }\n+\n+            if kind.to_codecharkind() == self.last_slice_kind && !is_comment_connector {\n+                let last_index = match first_whitespace {\n+                    Some(j) => j,\n+                    None => i,\n+                };\n+                sub_slice_end = self.last_slice_end + last_index;\n+                break;\n+            }\n+\n+            if !is_comment_connector {\n+                first_whitespace = None;\n+            }\n+        }\n+\n+        if let (None, true) = (iter.next(), sub_slice_end == self.last_slice_end) {\n+            // This was the last subslice.\n+            sub_slice_end = match first_whitespace {\n+                Some(i) => self.last_slice_end + i,\n+                None => self.slice.len(),\n+            };\n+        }\n+\n+        let kind = match self.last_slice_kind {\n+            CodeCharKind::Comment => CodeCharKind::Normal,\n+            CodeCharKind::Normal => CodeCharKind::Comment,\n+        };\n+        let res = (\n+            kind,\n+            self.last_slice_end,\n+            &self.slice[self.last_slice_end..sub_slice_end],\n+        );\n+        self.last_slice_end = sub_slice_end;\n+        self.last_slice_kind = kind;\n+\n+        Some(res)\n+    }\n+}\n+\n+/// Checks is `new` didn't miss any comment from `span`, if it removed any, return previous text\n+/// (if it fits in the width/offset, else return `None`), else return `new`\n+pub(crate) fn recover_comment_removed(\n+    new: String,\n+    span: Span,\n+    context: &RewriteContext<'_>,\n+) -> Option<String> {\n+    let snippet = context.snippet(span);\n+    if snippet != new && changed_comment_content(snippet, &new) {\n+        // We missed some comments. Warn and keep the original text.\n+        if context.config.error_on_unformatted() {\n+            context.report.append(\n+                context.parse_sess.span_to_filename(span),\n+                vec![FormattingError::from_span(\n+                    span,\n+                    &context.parse_sess,\n+                    ErrorKind::LostComment,\n+                )],\n+            );\n+        }\n+        Some(snippet.to_owned())\n+    } else {\n+        Some(new)\n+    }\n+}\n+\n+pub(crate) fn filter_normal_code(code: &str) -> String {\n+    let mut buffer = String::with_capacity(code.len());\n+    LineClasses::new(code).for_each(|(kind, line)| match kind {\n+        FullCodeCharKind::Normal\n+        | FullCodeCharKind::StartString\n+        | FullCodeCharKind::InString\n+        | FullCodeCharKind::EndString => {\n+            buffer.push_str(&line);\n+            buffer.push('\\n');\n+        }\n+        _ => (),\n+    });\n+    if !code.ends_with('\\n') && buffer.ends_with('\\n') {\n+        buffer.pop();\n+    }\n+    buffer\n+}\n+\n+/// Returns `true` if the two strings of code have the same payload of comments.\n+/// The payload of comments is everything in the string except:\n+/// - actual code (not comments),\n+/// - comment start/end marks,\n+/// - whitespace,\n+/// - '*' at the beginning of lines in block comments.\n+fn changed_comment_content(orig: &str, new: &str) -> bool {\n+    // Cannot write this as a fn since we cannot return types containing closures.\n+    let code_comment_content = |code| {\n+        let slices = UngroupedCommentCodeSlices::new(code);\n+        slices\n+            .filter(|&(ref kind, _, _)| *kind == CodeCharKind::Comment)\n+            .flat_map(|(_, _, s)| CommentReducer::new(s))\n+    };\n+    let res = code_comment_content(orig).ne(code_comment_content(new));\n+    debug!(\n+        \"comment::changed_comment_content: {}\\norig: '{}'\\nnew: '{}'\\nraw_old: {}\\nraw_new: {}\",\n+        res,\n+        orig,\n+        new,\n+        code_comment_content(orig).collect::<String>(),\n+        code_comment_content(new).collect::<String>()\n+    );\n+    res\n+}\n+\n+/// Iterator over the 'payload' characters of a comment.\n+/// It skips whitespace, comment start/end marks, and '*' at the beginning of lines.\n+/// The comment must be one comment, ie not more than one start mark (no multiple line comments,\n+/// for example).\n+struct CommentReducer<'a> {\n+    is_block: bool,\n+    at_start_line: bool,\n+    iter: std::str::Chars<'a>,\n+}\n+\n+impl<'a> CommentReducer<'a> {\n+    fn new(comment: &'a str) -> CommentReducer<'a> {\n+        let is_block = comment.starts_with(\"/*\");\n+        let comment = remove_comment_header(comment);\n+        CommentReducer {\n+            is_block,\n+            // There are no supplementary '*' on the first line.\n+            at_start_line: false,\n+            iter: comment.chars(),\n+        }\n+    }\n+}\n+\n+impl<'a> Iterator for CommentReducer<'a> {\n+    type Item = char;\n+\n+    fn next(&mut self) -> Option<Self::Item> {\n+        loop {\n+            let mut c = self.iter.next()?;\n+            if self.is_block && self.at_start_line {\n+                while c.is_whitespace() {\n+                    c = self.iter.next()?;\n+                }\n+                // Ignore leading '*'.\n+                if c == '*' {\n+                    c = self.iter.next()?;\n+                }\n+            } else if c == '\\n' {\n+                self.at_start_line = true;\n+            }\n+            if !c.is_whitespace() {\n+                return Some(c);\n+            }\n+        }\n+    }\n+}\n+\n+fn remove_comment_header(comment: &str) -> &str {\n+    if comment.starts_with(\"///\") || comment.starts_with(\"//!\") {\n+        &comment[3..]\n+    } else if comment.starts_with(\"//\") {\n+        &comment[2..]\n+    } else if (comment.starts_with(\"/**\") && !comment.starts_with(\"/**/\"))\n+        || comment.starts_with(\"/*!\")\n+    {\n+        &comment[3..comment.len() - 2]\n+    } else {\n+        assert!(\n+            comment.starts_with(\"/*\"),\n+            \"string '{}' is not a comment\",\n+            comment\n+        );\n+        &comment[2..comment.len() - 2]\n+    }\n+}\n+\n+#[cfg(test)]\n+mod test {\n+    use super::*;\n+    use crate::shape::{Indent, Shape};\n+\n+    #[test]\n+    fn char_classes() {\n+        let mut iter = CharClasses::new(\"//\\n\\n\".chars());\n+\n+        assert_eq!((FullCodeCharKind::StartComment, '/'), iter.next().unwrap());\n+        assert_eq!((FullCodeCharKind::InComment, '/'), iter.next().unwrap());\n+        assert_eq!((FullCodeCharKind::EndComment, '\\n'), iter.next().unwrap());\n+        assert_eq!((FullCodeCharKind::Normal, '\\n'), iter.next().unwrap());\n+        assert_eq!(None, iter.next());\n+    }\n+\n+    #[test]\n+    fn comment_code_slices() {\n+        let input = \"code(); /* test */ 1 + 1\";\n+        let mut iter = CommentCodeSlices::new(input);\n+\n+        assert_eq!((CodeCharKind::Normal, 0, \"code(); \"), iter.next().unwrap());\n+        assert_eq!(\n+            (CodeCharKind::Comment, 8, \"/* test */\"),\n+            iter.next().unwrap()\n+        );\n+        assert_eq!((CodeCharKind::Normal, 18, \" 1 + 1\"), iter.next().unwrap());\n+        assert_eq!(None, iter.next());\n+    }\n+\n+    #[test]\n+    fn comment_code_slices_two() {\n+        let input = \"// comment\\n    test();\";\n+        let mut iter = CommentCodeSlices::new(input);\n+\n+        assert_eq!((CodeCharKind::Normal, 0, \"\"), iter.next().unwrap());\n+        assert_eq!(\n+            (CodeCharKind::Comment, 0, \"// comment\\n\"),\n+            iter.next().unwrap()\n+        );\n+        assert_eq!(\n+            (CodeCharKind::Normal, 11, \"    test();\"),\n+            iter.next().unwrap()\n+        );\n+        assert_eq!(None, iter.next());\n+    }\n+\n+    #[test]\n+    fn comment_code_slices_three() {\n+        let input = \"1 // comment\\n    // comment2\\n\\n\";\n+        let mut iter = CommentCodeSlices::new(input);\n+\n+        assert_eq!((CodeCharKind::Normal, 0, \"1 \"), iter.next().unwrap());\n+        assert_eq!(\n+            (CodeCharKind::Comment, 2, \"// comment\\n    // comment2\\n\"),\n+            iter.next().unwrap()\n+        );\n+        assert_eq!((CodeCharKind::Normal, 29, \"\\n\"), iter.next().unwrap());\n+        assert_eq!(None, iter.next());\n+    }\n+\n+    #[test]\n+    #[rustfmt::skip]\n+    fn format_doc_comments() {\n+        let mut wrap_normalize_config: crate::config::Config = Default::default();\n+        wrap_normalize_config.set().wrap_comments(true);\n+        wrap_normalize_config.set().normalize_comments(true);\n+\n+        let mut wrap_config: crate::config::Config = Default::default();\n+        wrap_config.set().wrap_comments(true);\n+\n+        let comment = rewrite_comment(\" //test\",\n+                                      true,\n+                                      Shape::legacy(100, Indent::new(0, 100)),\n+                                      &wrap_normalize_config).unwrap();\n+        assert_eq!(\"/* test */\", comment);\n+\n+        let comment = rewrite_comment(\"// comment on a\",\n+                                      false,\n+                                      Shape::legacy(10, Indent::empty()),\n+                                      &wrap_normalize_config).unwrap();\n+        assert_eq!(\"// comment\\n// on a\", comment);\n+\n+        let comment = rewrite_comment(\"//  A multi line comment\\n             // between args.\",\n+                                      false,\n+                                      Shape::legacy(60, Indent::new(0, 12)),\n+                                      &wrap_normalize_config).unwrap();\n+        assert_eq!(\"//  A multi line comment\\n            // between args.\", comment);\n+\n+        let input = \"// comment\";\n+        let expected =\n+            \"/* comment */\";\n+        let comment = rewrite_comment(input,\n+                                      true,\n+                                      Shape::legacy(9, Indent::new(0, 69)),\n+                                      &wrap_normalize_config).unwrap();\n+        assert_eq!(expected, comment);\n+\n+        let comment = rewrite_comment(\"/*   trimmed    */\",\n+                                      true,\n+                                      Shape::legacy(100, Indent::new(0, 100)),\n+                                      &wrap_normalize_config).unwrap();\n+        assert_eq!(\"/* trimmed */\", comment);\n+\n+        // Check that different comment style are properly recognised.\n+        let comment = rewrite_comment(r#\"/// test1\n+                                         /// test2\n+                                         /*\n+                                          * test3\n+                                          */\"#,\n+                                      false,\n+                                      Shape::legacy(100, Indent::new(0, 0)),\n+                                      &wrap_normalize_config).unwrap();\n+        assert_eq!(\"/// test1\\n/// test2\\n// test3\", comment);\n+\n+        // Check that the blank line marks the end of a commented paragraph.\n+        let comment = rewrite_comment(r#\"// test1\n+\n+                                         // test2\"#,\n+                                      false,\n+                                      Shape::legacy(100, Indent::new(0, 0)),\n+                                      &wrap_normalize_config).unwrap();\n+        assert_eq!(\"// test1\\n\\n// test2\", comment);\n+\n+        // Check that the blank line marks the end of a custom-commented paragraph.\n+        let comment = rewrite_comment(r#\"//@ test1\n+\n+                                         //@ test2\"#,\n+                                      false,\n+                                      Shape::legacy(100, Indent::new(0, 0)),\n+                                      &wrap_normalize_config).unwrap();\n+        assert_eq!(\"//@ test1\\n\\n//@ test2\", comment);\n+\n+        // Check that bare lines are just indented but otherwise left unchanged.\n+        let comment = rewrite_comment(r#\"// test1\n+                                         /*\n+                                           a bare line!\n+\n+                                                another bare line!\n+                                          */\"#,\n+                                      false,\n+                                      Shape::legacy(100, Indent::new(0, 0)),\n+                                      &wrap_config).unwrap();\n+        assert_eq!(\"// test1\\n/*\\n a bare line!\\n\\n      another bare line!\\n*/\", comment);\n+    }\n+\n+    // This is probably intended to be a non-test fn, but it is not used.\n+    // We should keep this around unless it helps us test stuff to remove it.\n+    fn uncommented(text: &str) -> String {\n+        CharClasses::new(text.chars())\n+            .filter_map(|(s, c)| match s {\n+                FullCodeCharKind::Normal | FullCodeCharKind::InString => Some(c),\n+                _ => None,\n+            })\n+            .collect()\n+    }\n+\n+    #[test]\n+    fn test_uncommented() {\n+        assert_eq!(&uncommented(\"abc/*...*/\"), \"abc\");\n+        assert_eq!(\n+            &uncommented(\"// .... /* \\n../* /* *** / */ */a/* // */c\\n\"),\n+            \"..ac\\n\"\n+        );\n+        assert_eq!(&uncommented(\"abc \\\" /* */\\\" qsdf\"), \"abc \\\" /* */\\\" qsdf\");\n+    }\n+\n+    #[test]\n+    fn test_contains_comment() {\n+        assert_eq!(contains_comment(\"abc\"), false);\n+        assert_eq!(contains_comment(\"abc // qsdf\"), true);\n+        assert_eq!(contains_comment(\"abc /* kqsdf\"), true);\n+        assert_eq!(contains_comment(\"abc \\\" /* */\\\" qsdf\"), false);\n+    }\n+\n+    #[test]\n+    fn test_find_uncommented() {\n+        fn check(haystack: &str, needle: &str, expected: Option<usize>) {\n+            assert_eq!(expected, haystack.find_uncommented(needle));\n+        }\n+\n+        check(\"/*/ */test\", \"test\", Some(6));\n+        check(\"//test\\ntest\", \"test\", Some(7));\n+        check(\"/* comment only */\", \"whatever\", None);\n+        check(\n+            \"/* comment */ some text /* more commentary */ result\",\n+            \"result\",\n+            Some(46),\n+        );\n+        check(\"sup // sup\", \"p\", Some(2));\n+        check(\"sup\", \"x\", None);\n+        check(r#\"\u03c0? /**/ \u03c0 is nice!\"#, r#\"\u03c0 is nice\"#, Some(9));\n+        check(\"/*sup yo? \\n sup*/ sup\", \"p\", Some(20));\n+        check(\"hel/*lohello*/lo\", \"hello\", None);\n+        check(\"acb\", \"ab\", None);\n+        check(\",/*A*/ \", \",\", Some(0));\n+        check(\"abc\", \"abc\", Some(0));\n+        check(\"/* abc */\", \"abc\", None);\n+        check(\"/**/abc/* */\", \"abc\", Some(4));\n+        check(\"\\\"/* abc */\\\"\", \"abc\", Some(4));\n+        check(\"\\\"/* abc\", \"abc\", Some(4));\n+    }\n+\n+    #[test]\n+    fn test_filter_normal_code() {\n+        let s = r#\"\n+fn main() {\n+    println!(\"hello, world\");\n+}\n+\"#;\n+        assert_eq!(s, filter_normal_code(s));\n+        let s_with_comment = r#\"\n+fn main() {\n+    // hello, world\n+    println!(\"hello, world\");\n+}\n+\"#;\n+        assert_eq!(s, filter_normal_code(s_with_comment));\n+    }\n+}"}, {"sha": "2f567b2552106b91d86fdcb459c4500a77c0058c", "filename": "src/tools/rustfmt/src/config/config_type.rs", "status": "added", "additions": 448, "deletions": 0, "changes": 448, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Fsrc%2Fconfig%2Fconfig_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Fsrc%2Fconfig%2Fconfig_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fsrc%2Fconfig%2Fconfig_type.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782", "patch": "@@ -0,0 +1,448 @@\n+use crate::config::file_lines::FileLines;\n+use crate::config::options::{IgnoreList, WidthHeuristics};\n+\n+/// Trait for types that can be used in `Config`.\n+pub(crate) trait ConfigType: Sized {\n+    /// Returns hint text for use in `Config::print_docs()`. For enum types, this is a\n+    /// pipe-separated list of variants; for other types it returns \"<type>\".\n+    fn doc_hint() -> String;\n+}\n+\n+impl ConfigType for bool {\n+    fn doc_hint() -> String {\n+        String::from(\"<boolean>\")\n+    }\n+}\n+\n+impl ConfigType for usize {\n+    fn doc_hint() -> String {\n+        String::from(\"<unsigned integer>\")\n+    }\n+}\n+\n+impl ConfigType for isize {\n+    fn doc_hint() -> String {\n+        String::from(\"<signed integer>\")\n+    }\n+}\n+\n+impl ConfigType for String {\n+    fn doc_hint() -> String {\n+        String::from(\"<string>\")\n+    }\n+}\n+\n+impl ConfigType for FileLines {\n+    fn doc_hint() -> String {\n+        String::from(\"<json>\")\n+    }\n+}\n+\n+impl ConfigType for WidthHeuristics {\n+    fn doc_hint() -> String {\n+        String::new()\n+    }\n+}\n+\n+impl ConfigType for IgnoreList {\n+    fn doc_hint() -> String {\n+        String::from(\"[<string>,..]\")\n+    }\n+}\n+\n+macro_rules! create_config {\n+    ($($i:ident: $ty:ty, $def:expr, $stb:expr, $( $dstring:expr ),+ );+ $(;)*) => (\n+        #[cfg(test)]\n+        use std::collections::HashSet;\n+        use std::io::Write;\n+\n+        use serde::{Deserialize, Serialize};\n+\n+        #[derive(Clone)]\n+        #[allow(unreachable_pub)]\n+        pub struct Config {\n+            // if a license_template_path has been specified, successfully read, parsed and compiled\n+            // into a regex, it will be stored here\n+            pub license_template: Option<Regex>,\n+            // For each config item, we store a bool indicating whether it has\n+            // been accessed and the value, and a bool whether the option was\n+            // manually initialised, or taken from the default,\n+            $($i: (Cell<bool>, bool, $ty, bool)),+\n+        }\n+\n+        // Just like the Config struct but with each property wrapped\n+        // as Option<T>. This is used to parse a rustfmt.toml that doesn't\n+        // specify all properties of `Config`.\n+        // We first parse into `PartialConfig`, then create a default `Config`\n+        // and overwrite the properties with corresponding values from `PartialConfig`.\n+        #[derive(Deserialize, Serialize, Clone)]\n+        #[allow(unreachable_pub)]\n+        pub struct PartialConfig {\n+            $(pub $i: Option<$ty>),+\n+        }\n+\n+        // Macro hygiene won't allow us to make `set_$i()` methods on Config\n+        // for each item, so this struct is used to give the API to set values:\n+        // `config.set().option(false)`. It's pretty ugly. Consider replacing\n+        // with `config.set_option(false)` if we ever get a stable/usable\n+        // `concat_idents!()`.\n+        #[allow(unreachable_pub)]\n+        pub struct ConfigSetter<'a>(&'a mut Config);\n+\n+        impl<'a> ConfigSetter<'a> {\n+            $(\n+            #[allow(unreachable_pub)]\n+            pub fn $i(&mut self, value: $ty) {\n+                (self.0).$i.2 = value;\n+                match stringify!($i) {\n+                    \"max_width\"\n+                    | \"use_small_heuristics\"\n+                    | \"fn_call_width\"\n+                    | \"single_line_if_else_max_width\"\n+                    | \"attr_fn_like_width\"\n+                    | \"struct_lit_width\"\n+                    | \"struct_variant_width\"\n+                    | \"array_width\"\n+                    | \"chain_width\" => self.0.set_heuristics(),\n+                    \"license_template_path\" => self.0.set_license_template(),\n+                    \"merge_imports\" => self.0.set_merge_imports(),\n+                    &_ => (),\n+                }\n+            }\n+            )+\n+        }\n+\n+        // Query each option, returns true if the user set the option, false if\n+        // a default was used.\n+        #[allow(unreachable_pub)]\n+        pub struct ConfigWasSet<'a>(&'a Config);\n+\n+        impl<'a> ConfigWasSet<'a> {\n+            $(\n+            #[allow(unreachable_pub)]\n+            pub fn $i(&self) -> bool {\n+                (self.0).$i.1\n+            }\n+            )+\n+        }\n+\n+        impl Config {\n+            $(\n+            #[allow(unreachable_pub)]\n+            pub fn $i(&self) -> $ty {\n+                self.$i.0.set(true);\n+                self.$i.2.clone()\n+            }\n+            )+\n+\n+            #[allow(unreachable_pub)]\n+            pub fn set(&mut self) -> ConfigSetter<'_> {\n+                ConfigSetter(self)\n+            }\n+\n+            #[allow(unreachable_pub)]\n+            pub fn was_set(&self) -> ConfigWasSet<'_> {\n+                ConfigWasSet(self)\n+            }\n+\n+            fn fill_from_parsed_config(mut self, parsed: PartialConfig, dir: &Path) -> Config {\n+            $(\n+                if let Some(val) = parsed.$i {\n+                    if self.$i.3 {\n+                        self.$i.1 = true;\n+                        self.$i.2 = val;\n+                    } else {\n+                        if crate::is_nightly_channel!() {\n+                            self.$i.1 = true;\n+                            self.$i.2 = val;\n+                        } else {\n+                            eprintln!(\"Warning: can't set `{} = {:?}`, unstable features are only \\\n+                                       available in nightly channel.\", stringify!($i), val);\n+                        }\n+                    }\n+                }\n+            )+\n+                self.set_heuristics();\n+                self.set_license_template();\n+                self.set_ignore(dir);\n+                self.set_merge_imports();\n+                self\n+            }\n+\n+            /// Returns a hash set initialized with every user-facing config option name.\n+            #[cfg(test)]\n+            pub(crate) fn hash_set() -> HashSet<String> {\n+                let mut hash_set = HashSet::new();\n+                $(\n+                    hash_set.insert(stringify!($i).to_owned());\n+                )+\n+                hash_set\n+            }\n+\n+            pub(crate) fn is_valid_name(name: &str) -> bool {\n+                match name {\n+                    $(\n+                        stringify!($i) => true,\n+                    )+\n+                        _ => false,\n+                }\n+            }\n+\n+            #[allow(unreachable_pub)]\n+            pub fn is_valid_key_val(key: &str, val: &str) -> bool {\n+                match key {\n+                    $(\n+                        stringify!($i) => val.parse::<$ty>().is_ok(),\n+                    )+\n+                        _ => false,\n+                }\n+            }\n+\n+            #[allow(unreachable_pub)]\n+            pub fn used_options(&self) -> PartialConfig {\n+                PartialConfig {\n+                    $(\n+                        $i: if self.$i.0.get() {\n+                                Some(self.$i.2.clone())\n+                            } else {\n+                                None\n+                            },\n+                    )+\n+                }\n+            }\n+\n+            #[allow(unreachable_pub)]\n+            pub fn all_options(&self) -> PartialConfig {\n+                PartialConfig {\n+                    $(\n+                        $i: Some(self.$i.2.clone()),\n+                    )+\n+                }\n+            }\n+\n+            #[allow(unreachable_pub)]\n+            pub fn override_value(&mut self, key: &str, val: &str)\n+            {\n+                match key {\n+                    $(\n+                        stringify!($i) => {\n+                            self.$i.1 = true;\n+                            self.$i.2 = val.parse::<$ty>()\n+                                .expect(&format!(\"Failed to parse override for {} (\\\"{}\\\") as a {}\",\n+                                                 stringify!($i),\n+                                                 val,\n+                                                 stringify!($ty)));\n+                        }\n+                    )+\n+                    _ => panic!(\"Unknown config key in override: {}\", key)\n+                }\n+\n+                match key {\n+                    \"max_width\"\n+                    | \"use_small_heuristics\"\n+                    | \"fn_call_width\"\n+                    | \"single_line_if_else_max_width\"\n+                    | \"attr_fn_like_width\"\n+                    | \"struct_lit_width\"\n+                    | \"struct_variant_width\"\n+                    | \"array_width\"\n+                    | \"chain_width\" => self.set_heuristics(),\n+                    \"license_template_path\" => self.set_license_template(),\n+                    \"merge_imports\" => self.set_merge_imports(),\n+                    &_ => (),\n+                }\n+            }\n+\n+            #[allow(unreachable_pub)]\n+            pub fn is_hidden_option(name: &str) -> bool {\n+                const HIDE_OPTIONS: [&str; 5] =\n+                    [\"verbose\", \"verbose_diff\", \"file_lines\", \"width_heuristics\", \"merge_imports\"];\n+                HIDE_OPTIONS.contains(&name)\n+            }\n+\n+            #[allow(unreachable_pub)]\n+            pub fn print_docs(out: &mut dyn Write, include_unstable: bool) {\n+                use std::cmp;\n+                let max = 0;\n+                $( let max = cmp::max(max, stringify!($i).len()+1); )+\n+                let space_str = \" \".repeat(max);\n+                writeln!(out, \"Configuration Options:\").unwrap();\n+                $(\n+                    if $stb || include_unstable {\n+                        let name_raw = stringify!($i);\n+\n+                        if !Config::is_hidden_option(name_raw) {\n+                            let mut name_out = String::with_capacity(max);\n+                            for _ in name_raw.len()..max-1 {\n+                                name_out.push(' ')\n+                            }\n+                            name_out.push_str(name_raw);\n+                            name_out.push(' ');\n+                            let mut default_str = format!(\"{}\", $def);\n+                            if default_str.is_empty() {\n+                                default_str = String::from(\"\\\"\\\"\");\n+                            }\n+                            writeln!(out,\n+                                    \"{}{} Default: {}{}\",\n+                                    name_out,\n+                                    <$ty>::doc_hint(),\n+                                    default_str,\n+                                    if !$stb { \" (unstable)\" } else { \"\" }).unwrap();\n+                            $(\n+                                writeln!(out, \"{}{}\", space_str, $dstring).unwrap();\n+                            )+\n+                            writeln!(out).unwrap();\n+                        }\n+                    }\n+                )+\n+            }\n+\n+            fn set_width_heuristics(&mut self, heuristics: WidthHeuristics) {\n+                let max_width = self.max_width.2;\n+                let get_width_value = |\n+                    was_set: bool,\n+                    override_value: usize,\n+                    heuristic_value: usize,\n+                    config_key: &str,\n+                | -> usize {\n+                    if !was_set {\n+                        return heuristic_value;\n+                    }\n+                    if override_value > max_width {\n+                        eprintln!(\n+                            \"`{0}` cannot have a value that exceeds `max_width`. \\\n+                            `{0}` will be set to the same value as `max_width`\",\n+                            config_key,\n+                        );\n+                        return max_width;\n+                    }\n+                    override_value\n+                };\n+\n+                let fn_call_width = get_width_value(\n+                    self.was_set().fn_call_width(),\n+                    self.fn_call_width.2,\n+                    heuristics.fn_call_width,\n+                    \"fn_call_width\",\n+                );\n+                self.fn_call_width.2 = fn_call_width;\n+\n+                let attr_fn_like_width = get_width_value(\n+                    self.was_set().attr_fn_like_width(),\n+                    self.attr_fn_like_width.2,\n+                    heuristics.attr_fn_like_width,\n+                    \"attr_fn_like_width\",\n+                );\n+                self.attr_fn_like_width.2 = attr_fn_like_width;\n+\n+                let struct_lit_width = get_width_value(\n+                    self.was_set().struct_lit_width(),\n+                    self.struct_lit_width.2,\n+                    heuristics.struct_lit_width,\n+                    \"struct_lit_width\",\n+                );\n+                self.struct_lit_width.2 = struct_lit_width;\n+\n+                let struct_variant_width = get_width_value(\n+                    self.was_set().struct_variant_width(),\n+                    self.struct_variant_width.2,\n+                    heuristics.struct_variant_width,\n+                    \"struct_variant_width\",\n+                );\n+                self.struct_variant_width.2 = struct_variant_width;\n+\n+                let array_width = get_width_value(\n+                    self.was_set().array_width(),\n+                    self.array_width.2,\n+                    heuristics.array_width,\n+                    \"array_width\",\n+                );\n+                self.array_width.2 = array_width;\n+\n+                let chain_width = get_width_value(\n+                    self.was_set().chain_width(),\n+                    self.chain_width.2,\n+                    heuristics.chain_width,\n+                    \"chain_width\",\n+                );\n+                self.chain_width.2 = chain_width;\n+\n+                let single_line_if_else_max_width = get_width_value(\n+                    self.was_set().single_line_if_else_max_width(),\n+                    self.single_line_if_else_max_width.2,\n+                    heuristics.single_line_if_else_max_width,\n+                    \"single_line_if_else_max_width\",\n+                );\n+                self.single_line_if_else_max_width.2 = single_line_if_else_max_width;\n+            }\n+\n+            fn set_heuristics(&mut self) {\n+                let max_width = self.max_width.2;\n+                match self.use_small_heuristics.2 {\n+                    Heuristics::Default =>\n+                        self.set_width_heuristics(WidthHeuristics::scaled(max_width)),\n+                    Heuristics::Max => self.set_width_heuristics(WidthHeuristics::set(max_width)),\n+                    Heuristics::Off => self.set_width_heuristics(WidthHeuristics::null()),\n+                };\n+            }\n+\n+            fn set_license_template(&mut self) {\n+                if self.was_set().license_template_path() {\n+                    let lt_path = self.license_template_path();\n+                    if lt_path.len() > 0 {\n+                        match license::load_and_compile_template(&lt_path) {\n+                            Ok(re) => self.license_template = Some(re),\n+                            Err(msg) => eprintln!(\"Warning for license template file {:?}: {}\",\n+                                                lt_path, msg),\n+                        }\n+                    } else {\n+                        self.license_template = None;\n+                    }\n+                }\n+            }\n+\n+            fn set_ignore(&mut self, dir: &Path) {\n+                self.ignore.2.add_prefix(dir);\n+            }\n+\n+            fn set_merge_imports(&mut self) {\n+                if self.was_set().merge_imports() {\n+                    eprintln!(\n+                        \"Warning: the `merge_imports` option is deprecated. \\\n+                        Use `imports_granularity=Crate` instead\"\n+                    );\n+                    if !self.was_set().imports_granularity() {\n+                        self.imports_granularity.2 = if self.merge_imports() {\n+                            ImportGranularity::Crate\n+                        } else {\n+                            ImportGranularity::Preserve\n+                        };\n+                    }\n+                }\n+            }\n+\n+            #[allow(unreachable_pub)]\n+            /// Returns `true` if the config key was explicitly set and is the default value.\n+            pub fn is_default(&self, key: &str) -> bool {\n+                $(\n+                    if let stringify!($i) = key {\n+                        return self.$i.1 && self.$i.2 == $def;\n+                    }\n+                 )+\n+                false\n+            }\n+        }\n+\n+        // Template for the default configuration\n+        impl Default for Config {\n+            fn default() -> Config {\n+                Config {\n+                    license_template: None,\n+                    $(\n+                        $i: (Cell::new(false), false, $def, $stb),\n+                    )+\n+                }\n+            }\n+        }\n+    )\n+}"}, {"sha": "22dd091cb51011d6ff5a59b8d4be4bb3b61b98fc", "filename": "src/tools/rustfmt/src/config/file_lines.rs", "status": "added", "additions": 440, "deletions": 0, "changes": 440, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Fsrc%2Fconfig%2Ffile_lines.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Fsrc%2Fconfig%2Ffile_lines.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fsrc%2Fconfig%2Ffile_lines.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782", "patch": "@@ -0,0 +1,440 @@\n+//! This module contains types and functions to support formatting specific line ranges.\n+\n+use itertools::Itertools;\n+use std::collections::HashMap;\n+use std::path::PathBuf;\n+use std::{cmp, fmt, iter, str};\n+\n+use rustc_data_structures::sync::Lrc;\n+use rustc_span::{self, SourceFile};\n+use serde::{ser, Deserialize, Deserializer, Serialize, Serializer};\n+use serde_json as json;\n+use thiserror::Error;\n+\n+/// A range of lines in a file, inclusive of both ends.\n+pub struct LineRange {\n+    pub file: Lrc<SourceFile>,\n+    pub lo: usize,\n+    pub hi: usize,\n+}\n+\n+/// Defines the name of an input - either a file or stdin.\n+#[derive(Clone, Debug, Eq, PartialEq, Hash, Ord, PartialOrd)]\n+pub enum FileName {\n+    Real(PathBuf),\n+    Stdin,\n+}\n+\n+impl From<rustc_span::FileName> for FileName {\n+    fn from(name: rustc_span::FileName) -> FileName {\n+        match name {\n+            rustc_span::FileName::Real(rustc_span::RealFileName::LocalPath(p)) => FileName::Real(p),\n+            rustc_span::FileName::Custom(ref f) if f == \"stdin\" => FileName::Stdin,\n+            _ => unreachable!(),\n+        }\n+    }\n+}\n+\n+impl fmt::Display for FileName {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        match self {\n+            FileName::Real(p) => write!(f, \"{}\", p.to_str().unwrap()),\n+            FileName::Stdin => write!(f, \"stdin\"),\n+        }\n+    }\n+}\n+\n+impl<'de> Deserialize<'de> for FileName {\n+    fn deserialize<D>(deserializer: D) -> Result<FileName, D::Error>\n+    where\n+        D: Deserializer<'de>,\n+    {\n+        let s = String::deserialize(deserializer)?;\n+        if s == \"stdin\" {\n+            Ok(FileName::Stdin)\n+        } else {\n+            Ok(FileName::Real(s.into()))\n+        }\n+    }\n+}\n+\n+impl Serialize for FileName {\n+    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n+    where\n+        S: Serializer,\n+    {\n+        let s = match self {\n+            FileName::Stdin => Ok(\"stdin\"),\n+            FileName::Real(path) => path\n+                .to_str()\n+                .ok_or_else(|| ser::Error::custom(\"path can't be serialized as UTF-8 string\")),\n+        };\n+\n+        s.and_then(|s| serializer.serialize_str(s))\n+    }\n+}\n+\n+impl LineRange {\n+    pub fn file_name(&self) -> FileName {\n+        self.file.name.clone().into()\n+    }\n+}\n+\n+/// A range that is inclusive of both ends.\n+#[derive(Clone, Copy, Debug, Eq, PartialEq, PartialOrd, Ord, Deserialize)]\n+pub struct Range {\n+    lo: usize,\n+    hi: usize,\n+}\n+\n+impl<'a> From<&'a LineRange> for Range {\n+    fn from(range: &'a LineRange) -> Range {\n+        Range::new(range.lo, range.hi)\n+    }\n+}\n+\n+impl fmt::Display for Range {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        write!(f, \"{}..{}\", self.lo, self.hi)\n+    }\n+}\n+\n+impl Range {\n+    pub fn new(lo: usize, hi: usize) -> Range {\n+        Range { lo, hi }\n+    }\n+\n+    fn is_empty(self) -> bool {\n+        self.lo > self.hi\n+    }\n+\n+    #[allow(dead_code)]\n+    fn contains(self, other: Range) -> bool {\n+        if other.is_empty() {\n+            true\n+        } else {\n+            !self.is_empty() && self.lo <= other.lo && self.hi >= other.hi\n+        }\n+    }\n+\n+    fn intersects(self, other: Range) -> bool {\n+        if self.is_empty() || other.is_empty() {\n+            false\n+        } else {\n+            (self.lo <= other.hi && other.hi <= self.hi)\n+                || (other.lo <= self.hi && self.hi <= other.hi)\n+        }\n+    }\n+\n+    fn adjacent_to(self, other: Range) -> bool {\n+        if self.is_empty() || other.is_empty() {\n+            false\n+        } else {\n+            self.hi + 1 == other.lo || other.hi + 1 == self.lo\n+        }\n+    }\n+\n+    /// Returns a new `Range` with lines from `self` and `other` if they were adjacent or\n+    /// intersect; returns `None` otherwise.\n+    fn merge(self, other: Range) -> Option<Range> {\n+        if self.adjacent_to(other) || self.intersects(other) {\n+            Some(Range::new(\n+                cmp::min(self.lo, other.lo),\n+                cmp::max(self.hi, other.hi),\n+            ))\n+        } else {\n+            None\n+        }\n+    }\n+}\n+\n+/// A set of lines in files.\n+///\n+/// It is represented as a multimap keyed on file names, with values a collection of\n+/// non-overlapping ranges sorted by their start point. An inner `None` is interpreted to mean all\n+/// lines in all files.\n+#[derive(Clone, Debug, Default, PartialEq)]\n+pub struct FileLines(Option<HashMap<FileName, Vec<Range>>>);\n+\n+impl fmt::Display for FileLines {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        match &self.0 {\n+            None => write!(f, \"None\")?,\n+            Some(map) => {\n+                for (file_name, ranges) in map.iter() {\n+                    write!(f, \"{}: \", file_name)?;\n+                    write!(f, \"{}\\n\", ranges.iter().format(\", \"))?;\n+                }\n+            }\n+        };\n+        Ok(())\n+    }\n+}\n+\n+/// Normalizes the ranges so that the invariants for `FileLines` hold: ranges are non-overlapping,\n+/// and ordered by their start point.\n+fn normalize_ranges(ranges: &mut HashMap<FileName, Vec<Range>>) {\n+    for ranges in ranges.values_mut() {\n+        ranges.sort();\n+        let mut result = vec![];\n+        let mut iter = ranges.iter_mut().peekable();\n+        while let Some(next) = iter.next() {\n+            let mut next = *next;\n+            while let Some(&&mut peek) = iter.peek() {\n+                if let Some(merged) = next.merge(peek) {\n+                    iter.next().unwrap();\n+                    next = merged;\n+                } else {\n+                    break;\n+                }\n+            }\n+            result.push(next)\n+        }\n+        *ranges = result;\n+    }\n+}\n+\n+impl FileLines {\n+    /// Creates a `FileLines` that contains all lines in all files.\n+    pub(crate) fn all() -> FileLines {\n+        FileLines(None)\n+    }\n+\n+    /// Returns `true` if this `FileLines` contains all lines in all files.\n+    pub(crate) fn is_all(&self) -> bool {\n+        self.0.is_none()\n+    }\n+\n+    pub fn from_ranges(mut ranges: HashMap<FileName, Vec<Range>>) -> FileLines {\n+        normalize_ranges(&mut ranges);\n+        FileLines(Some(ranges))\n+    }\n+\n+    /// Returns an iterator over the files contained in `self`.\n+    pub fn files(&self) -> Files<'_> {\n+        Files(self.0.as_ref().map(HashMap::keys))\n+    }\n+\n+    /// Returns JSON representation as accepted by the `--file-lines JSON` arg.\n+    pub fn to_json_spans(&self) -> Vec<JsonSpan> {\n+        match &self.0 {\n+            None => vec![],\n+            Some(file_ranges) => file_ranges\n+                .iter()\n+                .flat_map(|(file, ranges)| ranges.iter().map(move |r| (file, r)))\n+                .map(|(file, range)| JsonSpan {\n+                    file: file.to_owned(),\n+                    range: (range.lo, range.hi),\n+                })\n+                .collect(),\n+        }\n+    }\n+\n+    /// Returns `true` if `self` includes all lines in all files. Otherwise runs `f` on all ranges\n+    /// in the designated file (if any) and returns true if `f` ever does.\n+    fn file_range_matches<F>(&self, file_name: &FileName, f: F) -> bool\n+    where\n+        F: FnMut(&Range) -> bool,\n+    {\n+        let map = match self.0 {\n+            // `None` means \"all lines in all files\".\n+            None => return true,\n+            Some(ref map) => map,\n+        };\n+\n+        match canonicalize_path_string(file_name).and_then(|file| map.get(&file)) {\n+            Some(ranges) => ranges.iter().any(f),\n+            None => false,\n+        }\n+    }\n+\n+    /// Returns `true` if `range` is fully contained in `self`.\n+    #[allow(dead_code)]\n+    pub(crate) fn contains(&self, range: &LineRange) -> bool {\n+        self.file_range_matches(&range.file_name(), |r| r.contains(Range::from(range)))\n+    }\n+\n+    /// Returns `true` if any lines in `range` are in `self`.\n+    pub(crate) fn intersects(&self, range: &LineRange) -> bool {\n+        self.file_range_matches(&range.file_name(), |r| r.intersects(Range::from(range)))\n+    }\n+\n+    /// Returns `true` if `line` from `file_name` is in `self`.\n+    pub(crate) fn contains_line(&self, file_name: &FileName, line: usize) -> bool {\n+        self.file_range_matches(file_name, |r| r.lo <= line && r.hi >= line)\n+    }\n+\n+    /// Returns `true` if all the lines between `lo` and `hi` from `file_name` are in `self`.\n+    pub(crate) fn contains_range(&self, file_name: &FileName, lo: usize, hi: usize) -> bool {\n+        self.file_range_matches(file_name, |r| r.contains(Range::new(lo, hi)))\n+    }\n+}\n+\n+/// `FileLines` files iterator.\n+pub struct Files<'a>(Option<::std::collections::hash_map::Keys<'a, FileName, Vec<Range>>>);\n+\n+impl<'a> iter::Iterator for Files<'a> {\n+    type Item = &'a FileName;\n+\n+    fn next(&mut self) -> Option<&'a FileName> {\n+        self.0.as_mut().and_then(Iterator::next)\n+    }\n+}\n+\n+fn canonicalize_path_string(file: &FileName) -> Option<FileName> {\n+    match *file {\n+        FileName::Real(ref path) => path.canonicalize().ok().map(FileName::Real),\n+        _ => Some(file.clone()),\n+    }\n+}\n+\n+#[derive(Error, Debug)]\n+pub enum FileLinesError {\n+    #[error(\"{0}\")]\n+    Json(json::Error),\n+    #[error(\"Can't canonicalize {0}\")]\n+    CannotCanonicalize(FileName),\n+}\n+\n+// This impl is needed for `Config::override_value` to work for use in tests.\n+impl str::FromStr for FileLines {\n+    type Err = FileLinesError;\n+\n+    fn from_str(s: &str) -> Result<FileLines, Self::Err> {\n+        let v: Vec<JsonSpan> = json::from_str(s).map_err(FileLinesError::Json)?;\n+        let mut m = HashMap::new();\n+        for js in v {\n+            let (s, r) = JsonSpan::into_tuple(js)?;\n+            m.entry(s).or_insert_with(|| vec![]).push(r);\n+        }\n+        Ok(FileLines::from_ranges(m))\n+    }\n+}\n+\n+// For JSON decoding.\n+#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Debug, Deserialize, Serialize)]\n+pub struct JsonSpan {\n+    file: FileName,\n+    range: (usize, usize),\n+}\n+\n+impl JsonSpan {\n+    fn into_tuple(self) -> Result<(FileName, Range), FileLinesError> {\n+        let (lo, hi) = self.range;\n+        let canonical = canonicalize_path_string(&self.file)\n+            .ok_or_else(|| FileLinesError::CannotCanonicalize(self.file))?;\n+        Ok((canonical, Range::new(lo, hi)))\n+    }\n+}\n+\n+// This impl is needed for inclusion in the `Config` struct. We don't have a toml representation\n+// for `FileLines`, so it will just panic instead.\n+impl<'de> ::serde::de::Deserialize<'de> for FileLines {\n+    fn deserialize<D>(_: D) -> Result<Self, D::Error>\n+    where\n+        D: ::serde::de::Deserializer<'de>,\n+    {\n+        panic!(\n+            \"FileLines cannot be deserialized from a project rustfmt.toml file: please \\\n+             specify it via the `--file-lines` option instead\"\n+        );\n+    }\n+}\n+\n+// We also want to avoid attempting to serialize a FileLines to toml. The\n+// `Config` struct should ensure this impl is never reached.\n+impl ::serde::ser::Serialize for FileLines {\n+    fn serialize<S>(&self, _: S) -> Result<S::Ok, S::Error>\n+    where\n+        S: ::serde::ser::Serializer,\n+    {\n+        unreachable!(\"FileLines cannot be serialized. This is a rustfmt bug.\");\n+    }\n+}\n+\n+#[cfg(test)]\n+mod test {\n+    use super::Range;\n+\n+    #[test]\n+    fn test_range_intersects() {\n+        assert!(Range::new(1, 2).intersects(Range::new(1, 1)));\n+        assert!(Range::new(1, 2).intersects(Range::new(2, 2)));\n+        assert!(!Range::new(1, 2).intersects(Range::new(0, 0)));\n+        assert!(!Range::new(1, 2).intersects(Range::new(3, 10)));\n+        assert!(!Range::new(1, 3).intersects(Range::new(5, 5)));\n+    }\n+\n+    #[test]\n+    fn test_range_adjacent_to() {\n+        assert!(!Range::new(1, 2).adjacent_to(Range::new(1, 1)));\n+        assert!(!Range::new(1, 2).adjacent_to(Range::new(2, 2)));\n+        assert!(Range::new(1, 2).adjacent_to(Range::new(0, 0)));\n+        assert!(Range::new(1, 2).adjacent_to(Range::new(3, 10)));\n+        assert!(!Range::new(1, 3).adjacent_to(Range::new(5, 5)));\n+    }\n+\n+    #[test]\n+    fn test_range_contains() {\n+        assert!(Range::new(1, 2).contains(Range::new(1, 1)));\n+        assert!(Range::new(1, 2).contains(Range::new(2, 2)));\n+        assert!(!Range::new(1, 2).contains(Range::new(0, 0)));\n+        assert!(!Range::new(1, 2).contains(Range::new(3, 10)));\n+    }\n+\n+    #[test]\n+    fn test_range_merge() {\n+        assert_eq!(None, Range::new(1, 3).merge(Range::new(5, 5)));\n+        assert_eq!(None, Range::new(4, 7).merge(Range::new(0, 1)));\n+        assert_eq!(\n+            Some(Range::new(3, 7)),\n+            Range::new(3, 5).merge(Range::new(4, 7))\n+        );\n+        assert_eq!(\n+            Some(Range::new(3, 7)),\n+            Range::new(3, 5).merge(Range::new(5, 7))\n+        );\n+        assert_eq!(\n+            Some(Range::new(3, 7)),\n+            Range::new(3, 5).merge(Range::new(6, 7))\n+        );\n+        assert_eq!(\n+            Some(Range::new(3, 7)),\n+            Range::new(3, 7).merge(Range::new(4, 5))\n+        );\n+    }\n+\n+    use super::json::{self, json};\n+    use super::{FileLines, FileName};\n+    use std::{collections::HashMap, path::PathBuf};\n+\n+    #[test]\n+    fn file_lines_to_json() {\n+        let ranges: HashMap<FileName, Vec<Range>> = [\n+            (\n+                FileName::Real(PathBuf::from(\"src/main.rs\")),\n+                vec![Range::new(1, 3), Range::new(5, 7)],\n+            ),\n+            (\n+                FileName::Real(PathBuf::from(\"src/lib.rs\")),\n+                vec![Range::new(1, 7)],\n+            ),\n+        ]\n+        .iter()\n+        .cloned()\n+        .collect();\n+\n+        let file_lines = FileLines::from_ranges(ranges);\n+        let mut spans = file_lines.to_json_spans();\n+        spans.sort();\n+        let json = json::to_value(&spans).unwrap();\n+        assert_eq!(\n+            json,\n+            json! {[\n+                {\"file\": \"src/lib.rs\",  \"range\": [1, 7]},\n+                {\"file\": \"src/main.rs\", \"range\": [1, 3]},\n+                {\"file\": \"src/main.rs\", \"range\": [5, 7]},\n+            ]}\n+        );\n+    }\n+}"}, {"sha": "121a1b1c151f4cc1d3f42531e3ed302d01cc7a0e", "filename": "src/tools/rustfmt/src/config/license.rs", "status": "added", "additions": 266, "deletions": 0, "changes": 266, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Fsrc%2Fconfig%2Flicense.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Fsrc%2Fconfig%2Flicense.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fsrc%2Fconfig%2Flicense.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782", "patch": "@@ -0,0 +1,266 @@\n+use std::fmt;\n+use std::fs::File;\n+use std::io;\n+use std::io::Read;\n+\n+use regex;\n+use regex::Regex;\n+\n+#[derive(Debug)]\n+pub(crate) enum LicenseError {\n+    IO(io::Error),\n+    Regex(regex::Error),\n+    Parse(String),\n+}\n+\n+impl fmt::Display for LicenseError {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        match *self {\n+            LicenseError::IO(ref err) => err.fmt(f),\n+            LicenseError::Regex(ref err) => err.fmt(f),\n+            LicenseError::Parse(ref err) => write!(f, \"parsing failed, {}\", err),\n+        }\n+    }\n+}\n+\n+impl From<io::Error> for LicenseError {\n+    fn from(err: io::Error) -> LicenseError {\n+        LicenseError::IO(err)\n+    }\n+}\n+\n+impl From<regex::Error> for LicenseError {\n+    fn from(err: regex::Error) -> LicenseError {\n+        LicenseError::Regex(err)\n+    }\n+}\n+\n+// the template is parsed using a state machine\n+enum ParsingState {\n+    Lit,\n+    LitEsc,\n+    // the u32 keeps track of brace nesting\n+    Re(u32),\n+    ReEsc(u32),\n+    Abort(String),\n+}\n+\n+use self::ParsingState::*;\n+\n+pub(crate) struct TemplateParser {\n+    parsed: String,\n+    buffer: String,\n+    state: ParsingState,\n+    linum: u32,\n+    open_brace_line: u32,\n+}\n+\n+impl TemplateParser {\n+    fn new() -> Self {\n+        Self {\n+            parsed: \"^\".to_owned(),\n+            buffer: String::new(),\n+            state: Lit,\n+            linum: 1,\n+            // keeps track of last line on which a regex placeholder was started\n+            open_brace_line: 0,\n+        }\n+    }\n+\n+    /// Converts a license template into a string which can be turned into a regex.\n+    ///\n+    /// The license template could use regex syntax directly, but that would require a lot of manual\n+    /// escaping, which is inconvenient. It is therefore literal by default, with optional regex\n+    /// subparts delimited by `{` and `}`. Additionally:\n+    ///\n+    /// - to insert literal `{`, `}` or `\\`, escape it with `\\`\n+    /// - an empty regex placeholder (`{}`) is shorthand for `{.*?}`\n+    ///\n+    /// This function parses this input format and builds a properly escaped *string* representation\n+    /// of the equivalent regular expression. It **does not** however guarantee that the returned\n+    /// string is a syntactically valid regular expression.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```text\n+    /// assert_eq!(\n+    ///     TemplateParser::parse(\n+    ///         r\"\n+    /// // Copyright {\\d+} The \\} Rust \\\\ Project \\{ Developers. See the {([A-Z]+)}\n+    /// // file at the top-level directory of this distribution and at\n+    /// // {}.\n+    /// //\n+    /// // Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+    /// // http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+    /// // <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+    /// // option. This file may not be copied, modified, or distributed\n+    /// // except according to those terms.\n+    /// \"\n+    ///     ).unwrap(),\n+    ///     r\"^\n+    /// // Copyright \\d+ The \\} Rust \\\\ Project \\{ Developers\\. See the ([A-Z]+)\n+    /// // file at the top\\-level directory of this distribution and at\n+    /// // .*?\\.\n+    /// //\n+    /// // Licensed under the Apache License, Version 2\\.0 <LICENSE\\-APACHE or\n+    /// // http://www\\.apache\\.org/licenses/LICENSE\\-2\\.0> or the MIT license\n+    /// // <LICENSE\\-MIT or http://opensource\\.org/licenses/MIT>, at your\n+    /// // option\\. This file may not be copied, modified, or distributed\n+    /// // except according to those terms\\.\n+    /// \"\n+    /// );\n+    /// ```\n+    pub(crate) fn parse(template: &str) -> Result<String, LicenseError> {\n+        let mut parser = Self::new();\n+        for chr in template.chars() {\n+            if chr == '\\n' {\n+                parser.linum += 1;\n+            }\n+            parser.state = match parser.state {\n+                Lit => parser.trans_from_lit(chr),\n+                LitEsc => parser.trans_from_litesc(chr),\n+                Re(brace_nesting) => parser.trans_from_re(chr, brace_nesting),\n+                ReEsc(brace_nesting) => parser.trans_from_reesc(chr, brace_nesting),\n+                Abort(msg) => return Err(LicenseError::Parse(msg)),\n+            };\n+        }\n+        // check if we've ended parsing in a valid state\n+        match parser.state {\n+            Abort(msg) => return Err(LicenseError::Parse(msg)),\n+            Re(_) | ReEsc(_) => {\n+                return Err(LicenseError::Parse(format!(\n+                    \"escape or balance opening brace on l. {}\",\n+                    parser.open_brace_line\n+                )));\n+            }\n+            LitEsc => {\n+                return Err(LicenseError::Parse(format!(\n+                    \"incomplete escape sequence on l. {}\",\n+                    parser.linum\n+                )));\n+            }\n+            _ => (),\n+        }\n+        parser.parsed.push_str(&regex::escape(&parser.buffer));\n+\n+        Ok(parser.parsed)\n+    }\n+\n+    fn trans_from_lit(&mut self, chr: char) -> ParsingState {\n+        match chr {\n+            '{' => {\n+                self.parsed.push_str(&regex::escape(&self.buffer));\n+                self.buffer.clear();\n+                self.open_brace_line = self.linum;\n+                Re(1)\n+            }\n+            '}' => Abort(format!(\n+                \"escape or balance closing brace on l. {}\",\n+                self.linum\n+            )),\n+            '\\\\' => LitEsc,\n+            _ => {\n+                self.buffer.push(chr);\n+                Lit\n+            }\n+        }\n+    }\n+\n+    fn trans_from_litesc(&mut self, chr: char) -> ParsingState {\n+        self.buffer.push(chr);\n+        Lit\n+    }\n+\n+    fn trans_from_re(&mut self, chr: char, brace_nesting: u32) -> ParsingState {\n+        match chr {\n+            '{' => {\n+                self.buffer.push(chr);\n+                Re(brace_nesting + 1)\n+            }\n+            '}' => {\n+                match brace_nesting {\n+                    1 => {\n+                        // default regex for empty placeholder {}\n+                        if self.buffer.is_empty() {\n+                            self.parsed.push_str(\".*?\");\n+                        } else {\n+                            self.parsed.push_str(&self.buffer);\n+                        }\n+                        self.buffer.clear();\n+                        Lit\n+                    }\n+                    _ => {\n+                        self.buffer.push(chr);\n+                        Re(brace_nesting - 1)\n+                    }\n+                }\n+            }\n+            '\\\\' => {\n+                self.buffer.push(chr);\n+                ReEsc(brace_nesting)\n+            }\n+            _ => {\n+                self.buffer.push(chr);\n+                Re(brace_nesting)\n+            }\n+        }\n+    }\n+\n+    fn trans_from_reesc(&mut self, chr: char, brace_nesting: u32) -> ParsingState {\n+        self.buffer.push(chr);\n+        Re(brace_nesting)\n+    }\n+}\n+\n+pub(crate) fn load_and_compile_template(path: &str) -> Result<Regex, LicenseError> {\n+    let mut lt_file = File::open(&path)?;\n+    let mut lt_str = String::new();\n+    lt_file.read_to_string(&mut lt_str)?;\n+    let lt_parsed = TemplateParser::parse(&lt_str)?;\n+    Ok(Regex::new(&lt_parsed)?)\n+}\n+\n+#[cfg(test)]\n+mod test {\n+    use super::TemplateParser;\n+\n+    #[test]\n+    fn test_parse_license_template() {\n+        assert_eq!(\n+            TemplateParser::parse(\"literal (.*)\").unwrap(),\n+            r\"^literal \\(\\.\\*\\)\"\n+        );\n+        assert_eq!(\n+            TemplateParser::parse(r\"escaping \\}\").unwrap(),\n+            r\"^escaping \\}\"\n+        );\n+        assert!(TemplateParser::parse(\"unbalanced } without escape\").is_err());\n+        assert_eq!(\n+            TemplateParser::parse(r\"{\\d+} place{-?}holder{s?}\").unwrap(),\n+            r\"^\\d+ place-?holders?\"\n+        );\n+        assert_eq!(TemplateParser::parse(\"default {}\").unwrap(), \"^default .*?\");\n+        assert_eq!(\n+            TemplateParser::parse(r\"unbalanced nested braces {\\{{3}}\").unwrap(),\n+            r\"^unbalanced nested braces \\{{3}\"\n+        );\n+        assert_eq!(\n+            &TemplateParser::parse(\"parsing error }\")\n+                .unwrap_err()\n+                .to_string(),\n+            \"parsing failed, escape or balance closing brace on l. 1\"\n+        );\n+        assert_eq!(\n+            &TemplateParser::parse(\"parsing error {\\nsecond line\")\n+                .unwrap_err()\n+                .to_string(),\n+            \"parsing failed, escape or balance opening brace on l. 1\"\n+        );\n+        assert_eq!(\n+            &TemplateParser::parse(r\"parsing error \\\")\n+                .unwrap_err()\n+                .to_string(),\n+            \"parsing failed, incomplete escape sequence on l. 1\"\n+        );\n+    }\n+}"}, {"sha": "11cb17068fb4aef9dc61b08520ab34cfb0630e49", "filename": "src/tools/rustfmt/src/config/lists.rs", "status": "added", "additions": 92, "deletions": 0, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Fsrc%2Fconfig%2Flists.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Fsrc%2Fconfig%2Flists.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fsrc%2Fconfig%2Flists.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782", "patch": "@@ -0,0 +1,92 @@\n+//! Configuration options related to rewriting a list.\n+\n+use rustfmt_config_proc_macro::config_type;\n+\n+use crate::config::IndentStyle;\n+\n+/// The definitive formatting tactic for lists.\n+#[derive(Eq, PartialEq, Debug, Copy, Clone)]\n+pub enum DefinitiveListTactic {\n+    Vertical,\n+    Horizontal,\n+    Mixed,\n+    /// Special case tactic for `format!()`, `write!()` style macros.\n+    SpecialMacro(usize),\n+}\n+\n+impl DefinitiveListTactic {\n+    pub fn ends_with_newline(&self, indent_style: IndentStyle) -> bool {\n+        match indent_style {\n+            IndentStyle::Block => *self != DefinitiveListTactic::Horizontal,\n+            IndentStyle::Visual => false,\n+        }\n+    }\n+}\n+\n+/// Formatting tactic for lists. This will be cast down to a\n+/// `DefinitiveListTactic` depending on the number and length of the items and\n+/// their comments.\n+#[config_type]\n+pub enum ListTactic {\n+    /// One item per row.\n+    Vertical,\n+    /// All items on one row.\n+    Horizontal,\n+    /// Try Horizontal layout, if that fails then vertical.\n+    HorizontalVertical,\n+    /// HorizontalVertical with a soft limit of n characters.\n+    LimitedHorizontalVertical(usize),\n+    /// Pack as many items as possible per row over (possibly) many rows.\n+    Mixed,\n+}\n+\n+#[config_type]\n+pub enum SeparatorTactic {\n+    Always,\n+    Never,\n+    Vertical,\n+}\n+\n+impl SeparatorTactic {\n+    pub fn from_bool(b: bool) -> SeparatorTactic {\n+        if b {\n+            SeparatorTactic::Always\n+        } else {\n+            SeparatorTactic::Never\n+        }\n+    }\n+}\n+\n+/// Where to put separator.\n+#[config_type]\n+pub enum SeparatorPlace {\n+    Front,\n+    Back,\n+}\n+\n+impl SeparatorPlace {\n+    pub fn is_front(self) -> bool {\n+        self == SeparatorPlace::Front\n+    }\n+\n+    pub fn is_back(self) -> bool {\n+        self == SeparatorPlace::Back\n+    }\n+\n+    pub fn from_tactic(\n+        default: SeparatorPlace,\n+        tactic: DefinitiveListTactic,\n+        sep: &str,\n+    ) -> SeparatorPlace {\n+        match tactic {\n+            DefinitiveListTactic::Vertical => default,\n+            _ => {\n+                if sep == \",\" {\n+                    SeparatorPlace::Back\n+                } else {\n+                    default\n+                }\n+            }\n+        }\n+    }\n+}"}, {"sha": "8c04363b1fd4b95125fd2c1506215ba72bbfd9bb", "filename": "src/tools/rustfmt/src/config/mod.rs", "status": "added", "additions": 963, "deletions": 0, "changes": 963, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Fsrc%2Fconfig%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Fsrc%2Fconfig%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fsrc%2Fconfig%2Fmod.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782", "patch": "@@ -0,0 +1,963 @@\n+use std::cell::Cell;\n+use std::default::Default;\n+use std::fs::File;\n+use std::io::{Error, ErrorKind, Read};\n+use std::path::{Path, PathBuf};\n+use std::{env, fs};\n+\n+use regex::Regex;\n+use thiserror::Error;\n+\n+use crate::config::config_type::ConfigType;\n+#[allow(unreachable_pub)]\n+pub use crate::config::file_lines::{FileLines, FileName, Range};\n+#[allow(unreachable_pub)]\n+pub use crate::config::lists::*;\n+#[allow(unreachable_pub)]\n+pub use crate::config::options::*;\n+\n+#[macro_use]\n+pub(crate) mod config_type;\n+#[macro_use]\n+pub(crate) mod options;\n+\n+pub(crate) mod file_lines;\n+pub(crate) mod license;\n+pub(crate) mod lists;\n+\n+// This macro defines configuration options used in rustfmt. Each option\n+// is defined as follows:\n+//\n+// `name: value type, default value, is stable, description;`\n+create_config! {\n+    // Fundamental stuff\n+    max_width: usize, 100, true, \"Maximum width of each line\";\n+    hard_tabs: bool, false, true, \"Use tab characters for indentation, spaces for alignment\";\n+    tab_spaces: usize, 4, true, \"Number of spaces per tab\";\n+    newline_style: NewlineStyle, NewlineStyle::Auto, true, \"Unix or Windows line endings\";\n+    indent_style: IndentStyle, IndentStyle::Block, false, \"How do we indent expressions or items\";\n+\n+    // Width Heuristics\n+    use_small_heuristics: Heuristics, Heuristics::Default, true, \"Whether to use different \\\n+        formatting for items and expressions if they satisfy a heuristic notion of 'small'\";\n+    width_heuristics: WidthHeuristics, WidthHeuristics::scaled(100), false,\n+        \"'small' heuristic values\";\n+    fn_call_width: usize, 60, true, \"Maximum width of the args of a function call before \\\n+        falling back to vertical formatting.\";\n+    attr_fn_like_width: usize, 70, true, \"Maximum width of the args of a function-like \\\n+        attributes before falling back to vertical formatting.\";\n+    struct_lit_width: usize, 18, true, \"Maximum width in the body of a struct lit before \\\n+        falling back to vertical formatting.\";\n+    struct_variant_width: usize, 35, true, \"Maximum width in the body of a struct variant before \\\n+        falling back to vertical formatting.\";\n+    array_width: usize, 60, true,  \"Maximum width of an array literal before falling \\\n+        back to vertical formatting.\";\n+    chain_width: usize, 60, true, \"Maximum length of a chain to fit on a single line.\";\n+    single_line_if_else_max_width: usize, 50, true, \"Maximum line length for single line if-else \\\n+        expressions. A value of zero means always break if-else expressions.\";\n+\n+    // Comments. macros, and strings\n+    wrap_comments: bool, false, false, \"Break comments to fit on the line\";\n+    format_code_in_doc_comments: bool, false, false, \"Format the code snippet in doc comments.\";\n+    comment_width: usize, 80, false,\n+        \"Maximum length of comments. No effect unless wrap_comments = true\";\n+    normalize_comments: bool, false, false, \"Convert /* */ comments to // comments where possible\";\n+    normalize_doc_attributes: bool, false, false, \"Normalize doc attributes as doc comments\";\n+    license_template_path: String, String::default(), false,\n+        \"Beginning of file must match license template\";\n+    format_strings: bool, false, false, \"Format string literals where necessary\";\n+    format_macro_matchers: bool, false, false,\n+        \"Format the metavariable matching patterns in macros\";\n+    format_macro_bodies: bool, true, false, \"Format the bodies of macros\";\n+\n+    // Single line expressions and items\n+    empty_item_single_line: bool, true, false,\n+        \"Put empty-body functions and impls on a single line\";\n+    struct_lit_single_line: bool, true, false,\n+        \"Put small struct literals on a single line\";\n+    fn_single_line: bool, false, false, \"Put single-expression functions on a single line\";\n+    where_single_line: bool, false, false, \"Force where-clauses to be on a single line\";\n+\n+    // Imports\n+    imports_indent: IndentStyle, IndentStyle::Block, false, \"Indent of imports\";\n+    imports_layout: ListTactic, ListTactic::Mixed, false, \"Item layout inside a import block\";\n+    imports_granularity: ImportGranularity, ImportGranularity::Preserve, false,\n+        \"Merge or split imports to the provided granularity\";\n+    group_imports: GroupImportsTactic, GroupImportsTactic::Preserve, false,\n+        \"Controls the strategy for how imports are grouped together\";\n+    merge_imports: bool, false, false, \"(deprecated: use imports_granularity instead)\";\n+\n+    // Ordering\n+    reorder_imports: bool, true, true, \"Reorder import and extern crate statements alphabetically\";\n+    reorder_modules: bool, true, true, \"Reorder module statements alphabetically in group\";\n+    reorder_impl_items: bool, false, false, \"Reorder impl items\";\n+\n+    // Spaces around punctuation\n+    type_punctuation_density: TypeDensity, TypeDensity::Wide, false,\n+        \"Determines if '+' or '=' are wrapped in spaces in the punctuation of types\";\n+    space_before_colon: bool, false, false, \"Leave a space before the colon\";\n+    space_after_colon: bool, true, false, \"Leave a space after the colon\";\n+    spaces_around_ranges: bool, false, false, \"Put spaces around the  .. and ..= range operators\";\n+    binop_separator: SeparatorPlace, SeparatorPlace::Front, false,\n+        \"Where to put a binary operator when a binary expression goes multiline\";\n+\n+    // Misc.\n+    remove_nested_parens: bool, true, true, \"Remove nested parens\";\n+    combine_control_expr: bool, true, false, \"Combine control expressions with function calls\";\n+    overflow_delimited_expr: bool, false, false,\n+        \"Allow trailing bracket/brace delimited expressions to overflow\";\n+    struct_field_align_threshold: usize, 0, false,\n+        \"Align struct fields if their diffs fits within threshold\";\n+    enum_discrim_align_threshold: usize, 0, false,\n+        \"Align enum variants discrims, if their diffs fit within threshold\";\n+    match_arm_blocks: bool, true, false, \"Wrap the body of arms in blocks when it does not fit on \\\n+        the same line with the pattern of arms\";\n+    match_arm_leading_pipes: MatchArmLeadingPipe, MatchArmLeadingPipe::Never, true,\n+        \"Determines whether leading pipes are emitted on match arms\";\n+    force_multiline_blocks: bool, false, false,\n+        \"Force multiline closure bodies and match arms to be wrapped in a block\";\n+    fn_args_layout: Density, Density::Tall, true,\n+        \"Control the layout of arguments in a function\";\n+    brace_style: BraceStyle, BraceStyle::SameLineWhere, false, \"Brace style for items\";\n+    control_brace_style: ControlBraceStyle, ControlBraceStyle::AlwaysSameLine, false,\n+        \"Brace style for control flow constructs\";\n+    trailing_semicolon: bool, true, false,\n+        \"Add trailing semicolon after break, continue and return\";\n+    trailing_comma: SeparatorTactic, SeparatorTactic::Vertical, false,\n+        \"How to handle trailing commas for lists\";\n+    match_block_trailing_comma: bool, false, false,\n+        \"Put a trailing comma after a block based match arm (non-block arms are not affected)\";\n+    blank_lines_upper_bound: usize, 1, false,\n+        \"Maximum number of blank lines which can be put between items\";\n+    blank_lines_lower_bound: usize, 0, false,\n+        \"Minimum number of blank lines which must be put between items\";\n+    edition: Edition, Edition::Edition2015, true, \"The edition of the parser (RFC 2052)\";\n+    version: Version, Version::One, false, \"Version of formatting rules\";\n+    inline_attribute_width: usize, 0, false,\n+        \"Write an item and its attribute on the same line \\\n+        if their combined width is below a threshold\";\n+\n+    // Options that can change the source code beyond whitespace/blocks (somewhat linty things)\n+    merge_derives: bool, true, true, \"Merge multiple `#[derive(...)]` into a single one\";\n+    use_try_shorthand: bool, false, true, \"Replace uses of the try! macro by the ? shorthand\";\n+    use_field_init_shorthand: bool, false, true, \"Use field initialization shorthand if possible\";\n+    force_explicit_abi: bool, true, true, \"Always print the abi for extern items\";\n+    condense_wildcard_suffixes: bool, false, false, \"Replace strings of _ wildcards by a single .. \\\n+                                                     in tuple patterns\";\n+\n+    // Control options (changes the operation of rustfmt, rather than the formatting)\n+    color: Color, Color::Auto, false,\n+        \"What Color option to use when none is supplied: Always, Never, Auto\";\n+    required_version: String, env!(\"CARGO_PKG_VERSION\").to_owned(), false,\n+        \"Require a specific version of rustfmt\";\n+    unstable_features: bool, false, false,\n+            \"Enables unstable features. Only available on nightly channel\";\n+    disable_all_formatting: bool, false, false, \"Don't reformat anything\";\n+    skip_children: bool, false, false, \"Don't reformat out of line modules\";\n+    hide_parse_errors: bool, false, false, \"Hide errors from the parser\";\n+    error_on_line_overflow: bool, false, false, \"Error if unable to get all lines within max_width\";\n+    error_on_unformatted: bool, false, false,\n+        \"Error if unable to get comments or string literals within max_width, \\\n+         or they are left with trailing whitespaces\";\n+    report_todo: ReportTactic, ReportTactic::Never, false,\n+        \"Report all, none or unnumbered occurrences of TODO in source file comments\";\n+    report_fixme: ReportTactic, ReportTactic::Never, false,\n+        \"Report all, none or unnumbered occurrences of FIXME in source file comments\";\n+    ignore: IgnoreList, IgnoreList::default(), false,\n+        \"Skip formatting the specified files and directories\";\n+\n+    // Not user-facing\n+    verbose: Verbosity, Verbosity::Normal, false, \"How much to information to emit to the user\";\n+    file_lines: FileLines, FileLines::all(), false,\n+        \"Lines to format; this is not supported in rustfmt.toml, and can only be specified \\\n+         via the --file-lines option\";\n+    emit_mode: EmitMode, EmitMode::Files, false,\n+        \"What emit Mode to use when none is supplied\";\n+    make_backup: bool, false, false, \"Backup changed files\";\n+    print_misformatted_file_names: bool, false, true,\n+        \"Prints the names of mismatched files that were formatted. Prints the names of \\\n+         files that would be formated when used with `--check` mode. \";\n+}\n+\n+#[derive(Error, Debug)]\n+#[error(\"Could not output config: {0}\")]\n+pub struct ToTomlError(toml::ser::Error);\n+\n+impl PartialConfig {\n+    pub fn to_toml(&self) -> Result<String, ToTomlError> {\n+        // Non-user-facing options can't be specified in TOML\n+        let mut cloned = self.clone();\n+        cloned.file_lines = None;\n+        cloned.verbose = None;\n+        cloned.width_heuristics = None;\n+        cloned.print_misformatted_file_names = None;\n+        cloned.merge_imports = None;\n+\n+        ::toml::to_string(&cloned).map_err(ToTomlError)\n+    }\n+}\n+\n+impl Config {\n+    pub(crate) fn version_meets_requirement(&self) -> bool {\n+        if self.was_set().required_version() {\n+            let version = env!(\"CARGO_PKG_VERSION\");\n+            let required_version = self.required_version();\n+            if version != required_version {\n+                println!(\n+                    \"Error: rustfmt version ({}) doesn't match the required version ({})\",\n+                    version, required_version,\n+                );\n+                return false;\n+            }\n+        }\n+\n+        true\n+    }\n+\n+    /// Constructs a `Config` from the toml file specified at `file_path`.\n+    ///\n+    /// This method only looks at the provided path, for a method that\n+    /// searches parents for a `rustfmt.toml` see `from_resolved_toml_path`.\n+    ///\n+    /// Returns a `Config` if the config could be read and parsed from\n+    /// the file, otherwise errors.\n+    pub(super) fn from_toml_path(file_path: &Path) -> Result<Config, Error> {\n+        let mut file = File::open(&file_path)?;\n+        let mut toml = String::new();\n+        file.read_to_string(&mut toml)?;\n+        Config::from_toml(&toml, file_path.parent().unwrap())\n+            .map_err(|err| Error::new(ErrorKind::InvalidData, err))\n+    }\n+\n+    /// Resolves the config for input in `dir`.\n+    ///\n+    /// Searches for `rustfmt.toml` beginning with `dir`, and\n+    /// recursively checking parents of `dir` if no config file is found.\n+    /// If no config file exists in `dir` or in any parent, a\n+    /// default `Config` will be returned (and the returned path will be empty).\n+    ///\n+    /// Returns the `Config` to use, and the path of the project file if there was\n+    /// one.\n+    pub(super) fn from_resolved_toml_path(dir: &Path) -> Result<(Config, Option<PathBuf>), Error> {\n+        /// Try to find a project file in the given directory and its parents.\n+        /// Returns the path of a the nearest project file if one exists,\n+        /// or `None` if no project file was found.\n+        fn resolve_project_file(dir: &Path) -> Result<Option<PathBuf>, Error> {\n+            let mut current = if dir.is_relative() {\n+                env::current_dir()?.join(dir)\n+            } else {\n+                dir.to_path_buf()\n+            };\n+\n+            current = fs::canonicalize(current)?;\n+\n+            loop {\n+                match get_toml_path(&current) {\n+                    Ok(Some(path)) => return Ok(Some(path)),\n+                    Err(e) => return Err(e),\n+                    _ => (),\n+                }\n+\n+                // If the current directory has no parent, we're done searching.\n+                if !current.pop() {\n+                    break;\n+                }\n+            }\n+\n+            // If nothing was found, check in the home directory.\n+            if let Some(home_dir) = dirs::home_dir() {\n+                if let Some(path) = get_toml_path(&home_dir)? {\n+                    return Ok(Some(path));\n+                }\n+            }\n+\n+            // If none was found ther either, check in the user's configuration directory.\n+            if let Some(mut config_dir) = dirs::config_dir() {\n+                config_dir.push(\"rustfmt\");\n+                if let Some(path) = get_toml_path(&config_dir)? {\n+                    return Ok(Some(path));\n+                }\n+            }\n+\n+            Ok(None)\n+        }\n+\n+        match resolve_project_file(dir)? {\n+            None => Ok((Config::default(), None)),\n+            Some(path) => Config::from_toml_path(&path).map(|config| (config, Some(path))),\n+        }\n+    }\n+\n+    pub(crate) fn from_toml(toml: &str, dir: &Path) -> Result<Config, String> {\n+        let parsed: ::toml::Value = toml\n+            .parse()\n+            .map_err(|e| format!(\"Could not parse TOML: {}\", e))?;\n+        let mut err = String::new();\n+        let table = parsed\n+            .as_table()\n+            .ok_or_else(|| String::from(\"Parsed config was not table\"))?;\n+        for key in table.keys() {\n+            if !Config::is_valid_name(key) {\n+                let msg = &format!(\"Warning: Unknown configuration option `{}`\\n\", key);\n+                err.push_str(msg)\n+            }\n+        }\n+        match parsed.try_into() {\n+            Ok(parsed_config) => {\n+                if !err.is_empty() {\n+                    eprint!(\"{}\", err);\n+                }\n+                Ok(Config::default().fill_from_parsed_config(parsed_config, dir))\n+            }\n+            Err(e) => {\n+                err.push_str(\"Error: Decoding config file failed:\\n\");\n+                err.push_str(format!(\"{}\\n\", e).as_str());\n+                err.push_str(\"Please check your config file.\");\n+                Err(err)\n+            }\n+        }\n+    }\n+}\n+\n+/// Loads a config by checking the client-supplied options and if appropriate, the\n+/// file system (including searching the file system for overrides).\n+pub fn load_config<O: CliOptions>(\n+    file_path: Option<&Path>,\n+    options: Option<O>,\n+) -> Result<(Config, Option<PathBuf>), Error> {\n+    let over_ride = match options {\n+        Some(ref opts) => config_path(opts)?,\n+        None => None,\n+    };\n+\n+    let result = if let Some(over_ride) = over_ride {\n+        Config::from_toml_path(over_ride.as_ref()).map(|p| (p, Some(over_ride.to_owned())))\n+    } else if let Some(file_path) = file_path {\n+        Config::from_resolved_toml_path(file_path)\n+    } else {\n+        Ok((Config::default(), None))\n+    };\n+\n+    result.map(|(mut c, p)| {\n+        if let Some(options) = options {\n+            options.apply_to(&mut c);\n+        }\n+        (c, p)\n+    })\n+}\n+\n+// Check for the presence of known config file names (`rustfmt.toml, `.rustfmt.toml`) in `dir`\n+//\n+// Return the path if a config file exists, empty if no file exists, and Error for IO errors\n+fn get_toml_path(dir: &Path) -> Result<Option<PathBuf>, Error> {\n+    const CONFIG_FILE_NAMES: [&str; 2] = [\".rustfmt.toml\", \"rustfmt.toml\"];\n+    for config_file_name in &CONFIG_FILE_NAMES {\n+        let config_file = dir.join(config_file_name);\n+        match fs::metadata(&config_file) {\n+            // Only return if it's a file to handle the unlikely situation of a directory named\n+            // `rustfmt.toml`.\n+            Ok(ref md) if md.is_file() => return Ok(Some(config_file)),\n+            // Return the error if it's something other than `NotFound`; otherwise we didn't\n+            // find the project file yet, and continue searching.\n+            Err(e) => {\n+                if e.kind() != ErrorKind::NotFound {\n+                    return Err(e);\n+                }\n+            }\n+            _ => {}\n+        }\n+    }\n+    Ok(None)\n+}\n+\n+fn config_path(options: &dyn CliOptions) -> Result<Option<PathBuf>, Error> {\n+    let config_path_not_found = |path: &str| -> Result<Option<PathBuf>, Error> {\n+        Err(Error::new(\n+            ErrorKind::NotFound,\n+            format!(\n+                \"Error: unable to find a config file for the given path: `{}`\",\n+                path\n+            ),\n+        ))\n+    };\n+\n+    // Read the config_path and convert to parent dir if a file is provided.\n+    // If a config file cannot be found from the given path, return error.\n+    match options.config_path() {\n+        Some(path) if !path.exists() => config_path_not_found(path.to_str().unwrap()),\n+        Some(path) if path.is_dir() => {\n+            let config_file_path = get_toml_path(path)?;\n+            if config_file_path.is_some() {\n+                Ok(config_file_path)\n+            } else {\n+                config_path_not_found(path.to_str().unwrap())\n+            }\n+        }\n+        path => Ok(path.map(ToOwned::to_owned)),\n+    }\n+}\n+\n+#[cfg(test)]\n+mod test {\n+    use super::*;\n+    use std::str;\n+\n+    #[allow(dead_code)]\n+    mod mock {\n+        use super::super::*;\n+\n+        create_config! {\n+            // Options that are used by the generated functions\n+            max_width: usize, 100, true, \"Maximum width of each line\";\n+            license_template_path: String, String::default(), false,\n+                \"Beginning of file must match license template\";\n+            required_version: String, env!(\"CARGO_PKG_VERSION\").to_owned(), false,\n+                \"Require a specific version of rustfmt.\";\n+            ignore: IgnoreList, IgnoreList::default(), false,\n+                \"Skip formatting the specified files and directories.\";\n+            verbose: Verbosity, Verbosity::Normal, false,\n+                \"How much to information to emit to the user\";\n+            file_lines: FileLines, FileLines::all(), false,\n+                \"Lines to format; this is not supported in rustfmt.toml, and can only be specified \\\n+                    via the --file-lines option\";\n+\n+            // merge_imports deprecation\n+            imports_granularity: ImportGranularity, ImportGranularity::Preserve, false,\n+                \"Merge imports\";\n+            merge_imports: bool, false, false, \"(deprecated: use imports_granularity instead)\";\n+\n+            // Width Heuristics\n+            use_small_heuristics: Heuristics, Heuristics::Default, true,\n+                \"Whether to use different formatting for items and \\\n+                 expressions if they satisfy a heuristic notion of 'small'.\";\n+            width_heuristics: WidthHeuristics, WidthHeuristics::scaled(100), false,\n+                \"'small' heuristic values\";\n+\n+            fn_call_width: usize, 60, true, \"Maximum width of the args of a function call before \\\n+                falling back to vertical formatting.\";\n+            attr_fn_like_width: usize, 70, true, \"Maximum width of the args of a function-like \\\n+                attributes before falling back to vertical formatting.\";\n+            struct_lit_width: usize, 18, true, \"Maximum width in the body of a struct lit before \\\n+                falling back to vertical formatting.\";\n+            struct_variant_width: usize, 35, true, \"Maximum width in the body of a struct \\\n+                variant before falling back to vertical formatting.\";\n+            array_width: usize, 60, true,  \"Maximum width of an array literal before falling \\\n+                back to vertical formatting.\";\n+            chain_width: usize, 60, true, \"Maximum length of a chain to fit on a single line.\";\n+            single_line_if_else_max_width: usize, 50, true, \"Maximum line length for single \\\n+                line if-else expressions. A value of zero means always break if-else expressions.\";\n+\n+            // Options that are used by the tests\n+            stable_option: bool, false, true, \"A stable option\";\n+            unstable_option: bool, false, false, \"An unstable option\";\n+        }\n+    }\n+\n+    #[test]\n+    fn test_config_set() {\n+        let mut config = Config::default();\n+        config.set().verbose(Verbosity::Quiet);\n+        assert_eq!(config.verbose(), Verbosity::Quiet);\n+        config.set().verbose(Verbosity::Normal);\n+        assert_eq!(config.verbose(), Verbosity::Normal);\n+    }\n+\n+    #[test]\n+    fn test_config_used_to_toml() {\n+        let config = Config::default();\n+\n+        let merge_derives = config.merge_derives();\n+        let skip_children = config.skip_children();\n+\n+        let used_options = config.used_options();\n+        let toml = used_options.to_toml().unwrap();\n+        assert_eq!(\n+            toml,\n+            format!(\n+                \"merge_derives = {}\\nskip_children = {}\\n\",\n+                merge_derives, skip_children,\n+            )\n+        );\n+    }\n+\n+    #[test]\n+    fn test_was_set() {\n+        let config = Config::from_toml(\"hard_tabs = true\", Path::new(\"\")).unwrap();\n+\n+        assert_eq!(config.was_set().hard_tabs(), true);\n+        assert_eq!(config.was_set().verbose(), false);\n+    }\n+\n+    #[test]\n+    fn test_print_docs_exclude_unstable() {\n+        use self::mock::Config;\n+\n+        let mut output = Vec::new();\n+        Config::print_docs(&mut output, false);\n+\n+        let s = str::from_utf8(&output).unwrap();\n+\n+        assert_eq!(s.contains(\"stable_option\"), true);\n+        assert_eq!(s.contains(\"unstable_option\"), false);\n+        assert_eq!(s.contains(\"(unstable)\"), false);\n+    }\n+\n+    #[test]\n+    fn test_print_docs_include_unstable() {\n+        use self::mock::Config;\n+\n+        let mut output = Vec::new();\n+        Config::print_docs(&mut output, true);\n+\n+        let s = str::from_utf8(&output).unwrap();\n+        assert_eq!(s.contains(\"stable_option\"), true);\n+        assert_eq!(s.contains(\"unstable_option\"), true);\n+        assert_eq!(s.contains(\"(unstable)\"), true);\n+    }\n+\n+    #[test]\n+    fn test_empty_string_license_template_path() {\n+        let toml = r#\"license_template_path = \"\"\"#;\n+        let config = Config::from_toml(toml, Path::new(\"\")).unwrap();\n+        assert!(config.license_template.is_none());\n+    }\n+\n+    #[test]\n+    fn test_valid_license_template_path() {\n+        if !crate::is_nightly_channel!() {\n+            return;\n+        }\n+        let toml = r#\"license_template_path = \"tests/license-template/lt.txt\"\"#;\n+        let config = Config::from_toml(toml, Path::new(\"\")).unwrap();\n+        assert!(config.license_template.is_some());\n+    }\n+\n+    #[test]\n+    fn test_override_existing_license_with_no_license() {\n+        if !crate::is_nightly_channel!() {\n+            return;\n+        }\n+        let toml = r#\"license_template_path = \"tests/license-template/lt.txt\"\"#;\n+        let mut config = Config::from_toml(toml, Path::new(\"\")).unwrap();\n+        assert!(config.license_template.is_some());\n+        config.override_value(\"license_template_path\", \"\");\n+        assert!(config.license_template.is_none());\n+    }\n+\n+    #[test]\n+    fn test_dump_default_config() {\n+        let default_config = format!(\n+            r#\"max_width = 100\n+hard_tabs = false\n+tab_spaces = 4\n+newline_style = \"Auto\"\n+indent_style = \"Block\"\n+use_small_heuristics = \"Default\"\n+fn_call_width = 60\n+attr_fn_like_width = 70\n+struct_lit_width = 18\n+struct_variant_width = 35\n+array_width = 60\n+chain_width = 60\n+single_line_if_else_max_width = 50\n+wrap_comments = false\n+format_code_in_doc_comments = false\n+comment_width = 80\n+normalize_comments = false\n+normalize_doc_attributes = false\n+license_template_path = \"\"\n+format_strings = false\n+format_macro_matchers = false\n+format_macro_bodies = true\n+empty_item_single_line = true\n+struct_lit_single_line = true\n+fn_single_line = false\n+where_single_line = false\n+imports_indent = \"Block\"\n+imports_layout = \"Mixed\"\n+imports_granularity = \"Preserve\"\n+group_imports = \"Preserve\"\n+reorder_imports = true\n+reorder_modules = true\n+reorder_impl_items = false\n+type_punctuation_density = \"Wide\"\n+space_before_colon = false\n+space_after_colon = true\n+spaces_around_ranges = false\n+binop_separator = \"Front\"\n+remove_nested_parens = true\n+combine_control_expr = true\n+overflow_delimited_expr = false\n+struct_field_align_threshold = 0\n+enum_discrim_align_threshold = 0\n+match_arm_blocks = true\n+match_arm_leading_pipes = \"Never\"\n+force_multiline_blocks = false\n+fn_args_layout = \"Tall\"\n+brace_style = \"SameLineWhere\"\n+control_brace_style = \"AlwaysSameLine\"\n+trailing_semicolon = true\n+trailing_comma = \"Vertical\"\n+match_block_trailing_comma = false\n+blank_lines_upper_bound = 1\n+blank_lines_lower_bound = 0\n+edition = \"2015\"\n+version = \"One\"\n+inline_attribute_width = 0\n+merge_derives = true\n+use_try_shorthand = false\n+use_field_init_shorthand = false\n+force_explicit_abi = true\n+condense_wildcard_suffixes = false\n+color = \"Auto\"\n+required_version = \"{}\"\n+unstable_features = false\n+disable_all_formatting = false\n+skip_children = false\n+hide_parse_errors = false\n+error_on_line_overflow = false\n+error_on_unformatted = false\n+report_todo = \"Never\"\n+report_fixme = \"Never\"\n+ignore = []\n+emit_mode = \"Files\"\n+make_backup = false\n+\"#,\n+            env!(\"CARGO_PKG_VERSION\")\n+        );\n+        let toml = Config::default().all_options().to_toml().unwrap();\n+        assert_eq!(&toml, &default_config);\n+    }\n+\n+    // FIXME(#2183): these tests cannot be run in parallel because they use env vars.\n+    // #[test]\n+    // fn test_as_not_nightly_channel() {\n+    //     let mut config = Config::default();\n+    //     assert_eq!(config.was_set().unstable_features(), false);\n+    //     config.set().unstable_features(true);\n+    //     assert_eq!(config.was_set().unstable_features(), false);\n+    // }\n+\n+    // #[test]\n+    // fn test_as_nightly_channel() {\n+    //     let v = ::std::env::var(\"CFG_RELEASE_CHANNEL\").unwrap_or(String::from(\"\"));\n+    //     ::std::env::set_var(\"CFG_RELEASE_CHANNEL\", \"nightly\");\n+    //     let mut config = Config::default();\n+    //     config.set().unstable_features(true);\n+    //     assert_eq!(config.was_set().unstable_features(), false);\n+    //     config.set().unstable_features(true);\n+    //     assert_eq!(config.unstable_features(), true);\n+    //     ::std::env::set_var(\"CFG_RELEASE_CHANNEL\", v);\n+    // }\n+\n+    // #[test]\n+    // fn test_unstable_from_toml() {\n+    //     let mut config = Config::from_toml(\"unstable_features = true\").unwrap();\n+    //     assert_eq!(config.was_set().unstable_features(), false);\n+    //     let v = ::std::env::var(\"CFG_RELEASE_CHANNEL\").unwrap_or(String::from(\"\"));\n+    //     ::std::env::set_var(\"CFG_RELEASE_CHANNEL\", \"nightly\");\n+    //     config = Config::from_toml(\"unstable_features = true\").unwrap();\n+    //     assert_eq!(config.was_set().unstable_features(), true);\n+    //     assert_eq!(config.unstable_features(), true);\n+    //     ::std::env::set_var(\"CFG_RELEASE_CHANNEL\", v);\n+    // }\n+\n+    #[cfg(test)]\n+    mod deprecated_option_merge_imports {\n+        use super::*;\n+\n+        #[test]\n+        fn test_old_option_set() {\n+            if !crate::is_nightly_channel!() {\n+                return;\n+            }\n+            let toml = r#\"\n+                unstable_features = true\n+                merge_imports = true\n+            \"#;\n+            let config = Config::from_toml(toml, Path::new(\"\")).unwrap();\n+            assert_eq!(config.imports_granularity(), ImportGranularity::Crate);\n+        }\n+\n+        #[test]\n+        fn test_both_set() {\n+            if !crate::is_nightly_channel!() {\n+                return;\n+            }\n+            let toml = r#\"\n+                unstable_features = true\n+                merge_imports = true\n+                imports_granularity = \"Preserve\"\n+            \"#;\n+            let config = Config::from_toml(toml, Path::new(\"\")).unwrap();\n+            assert_eq!(config.imports_granularity(), ImportGranularity::Preserve);\n+        }\n+\n+        #[test]\n+        fn test_new_overridden() {\n+            if !crate::is_nightly_channel!() {\n+                return;\n+            }\n+            let toml = r#\"\n+                unstable_features = true\n+                merge_imports = true\n+            \"#;\n+            let mut config = Config::from_toml(toml, Path::new(\"\")).unwrap();\n+            config.override_value(\"imports_granularity\", \"Preserve\");\n+            assert_eq!(config.imports_granularity(), ImportGranularity::Preserve);\n+        }\n+\n+        #[test]\n+        fn test_old_overridden() {\n+            if !crate::is_nightly_channel!() {\n+                return;\n+            }\n+            let toml = r#\"\n+                unstable_features = true\n+                imports_granularity = \"Module\"\n+            \"#;\n+            let mut config = Config::from_toml(toml, Path::new(\"\")).unwrap();\n+            config.override_value(\"merge_imports\", \"true\");\n+            // no effect: the new option always takes precedence\n+            assert_eq!(config.imports_granularity(), ImportGranularity::Module);\n+        }\n+    }\n+\n+    #[cfg(test)]\n+    mod use_small_heuristics {\n+        use super::*;\n+\n+        #[test]\n+        fn test_default_sets_correct_widths() {\n+            let toml = r#\"\n+                use_small_heuristics = \"Default\"\n+                max_width = 200\n+            \"#;\n+            let config = Config::from_toml(toml, Path::new(\"\")).unwrap();\n+            assert_eq!(config.array_width(), 120);\n+            assert_eq!(config.attr_fn_like_width(), 140);\n+            assert_eq!(config.chain_width(), 120);\n+            assert_eq!(config.fn_call_width(), 120);\n+            assert_eq!(config.single_line_if_else_max_width(), 100);\n+            assert_eq!(config.struct_lit_width(), 36);\n+            assert_eq!(config.struct_variant_width(), 70);\n+        }\n+\n+        #[test]\n+        fn test_max_sets_correct_widths() {\n+            let toml = r#\"\n+                use_small_heuristics = \"Max\"\n+                max_width = 120\n+            \"#;\n+            let config = Config::from_toml(toml, Path::new(\"\")).unwrap();\n+            assert_eq!(config.array_width(), 120);\n+            assert_eq!(config.attr_fn_like_width(), 120);\n+            assert_eq!(config.chain_width(), 120);\n+            assert_eq!(config.fn_call_width(), 120);\n+            assert_eq!(config.single_line_if_else_max_width(), 120);\n+            assert_eq!(config.struct_lit_width(), 120);\n+            assert_eq!(config.struct_variant_width(), 120);\n+        }\n+\n+        #[test]\n+        fn test_off_sets_correct_widths() {\n+            let toml = r#\"\n+                use_small_heuristics = \"Off\"\n+                max_width = 100\n+            \"#;\n+            let config = Config::from_toml(toml, Path::new(\"\")).unwrap();\n+            assert_eq!(config.array_width(), usize::max_value());\n+            assert_eq!(config.attr_fn_like_width(), usize::max_value());\n+            assert_eq!(config.chain_width(), usize::max_value());\n+            assert_eq!(config.fn_call_width(), usize::max_value());\n+            assert_eq!(config.single_line_if_else_max_width(), 0);\n+            assert_eq!(config.struct_lit_width(), 0);\n+            assert_eq!(config.struct_variant_width(), 0);\n+        }\n+\n+        #[test]\n+        fn test_override_works_with_default() {\n+            let toml = r#\"\n+                use_small_heuristics = \"Default\"\n+                array_width = 20\n+                attr_fn_like_width = 40\n+                chain_width = 20\n+                fn_call_width = 90\n+                single_line_if_else_max_width = 40\n+                struct_lit_width = 30\n+                struct_variant_width = 34\n+            \"#;\n+            let config = Config::from_toml(toml, Path::new(\"\")).unwrap();\n+            assert_eq!(config.array_width(), 20);\n+            assert_eq!(config.attr_fn_like_width(), 40);\n+            assert_eq!(config.chain_width(), 20);\n+            assert_eq!(config.fn_call_width(), 90);\n+            assert_eq!(config.single_line_if_else_max_width(), 40);\n+            assert_eq!(config.struct_lit_width(), 30);\n+            assert_eq!(config.struct_variant_width(), 34);\n+        }\n+\n+        #[test]\n+        fn test_override_with_max() {\n+            let toml = r#\"\n+                use_small_heuristics = \"Max\"\n+                array_width = 20\n+                attr_fn_like_width = 40\n+                chain_width = 20\n+                fn_call_width = 90\n+                single_line_if_else_max_width = 40\n+                struct_lit_width = 30\n+                struct_variant_width = 34\n+            \"#;\n+            let config = Config::from_toml(toml, Path::new(\"\")).unwrap();\n+            assert_eq!(config.array_width(), 20);\n+            assert_eq!(config.attr_fn_like_width(), 40);\n+            assert_eq!(config.chain_width(), 20);\n+            assert_eq!(config.fn_call_width(), 90);\n+            assert_eq!(config.single_line_if_else_max_width(), 40);\n+            assert_eq!(config.struct_lit_width(), 30);\n+            assert_eq!(config.struct_variant_width(), 34);\n+        }\n+\n+        #[test]\n+        fn test_override_with_off() {\n+            let toml = r#\"\n+                use_small_heuristics = \"Off\"\n+                array_width = 20\n+                attr_fn_like_width = 40\n+                chain_width = 20\n+                fn_call_width = 90\n+                single_line_if_else_max_width = 40\n+                struct_lit_width = 30\n+                struct_variant_width = 34\n+            \"#;\n+            let config = Config::from_toml(toml, Path::new(\"\")).unwrap();\n+            assert_eq!(config.array_width(), 20);\n+            assert_eq!(config.attr_fn_like_width(), 40);\n+            assert_eq!(config.chain_width(), 20);\n+            assert_eq!(config.fn_call_width(), 90);\n+            assert_eq!(config.single_line_if_else_max_width(), 40);\n+            assert_eq!(config.struct_lit_width(), 30);\n+            assert_eq!(config.struct_variant_width(), 34);\n+        }\n+\n+        #[test]\n+        fn test_fn_call_width_config_exceeds_max_width() {\n+            let toml = r#\"\n+                max_width = 90\n+                fn_call_width = 95\n+            \"#;\n+            let config = Config::from_toml(toml, Path::new(\"\")).unwrap();\n+            assert_eq!(config.fn_call_width(), 90);\n+        }\n+\n+        #[test]\n+        fn test_attr_fn_like_width_config_exceeds_max_width() {\n+            let toml = r#\"\n+                max_width = 80\n+                attr_fn_like_width = 90\n+            \"#;\n+            let config = Config::from_toml(toml, Path::new(\"\")).unwrap();\n+            assert_eq!(config.attr_fn_like_width(), 80);\n+        }\n+\n+        #[test]\n+        fn test_struct_lit_config_exceeds_max_width() {\n+            let toml = r#\"\n+                max_width = 78\n+                struct_lit_width = 90\n+            \"#;\n+            let config = Config::from_toml(toml, Path::new(\"\")).unwrap();\n+            assert_eq!(config.struct_lit_width(), 78);\n+        }\n+\n+        #[test]\n+        fn test_struct_variant_width_config_exceeds_max_width() {\n+            let toml = r#\"\n+                max_width = 80\n+                struct_variant_width = 90\n+            \"#;\n+            let config = Config::from_toml(toml, Path::new(\"\")).unwrap();\n+            assert_eq!(config.struct_variant_width(), 80);\n+        }\n+\n+        #[test]\n+        fn test_array_width_config_exceeds_max_width() {\n+            let toml = r#\"\n+                max_width = 60\n+                array_width = 80\n+            \"#;\n+            let config = Config::from_toml(toml, Path::new(\"\")).unwrap();\n+            assert_eq!(config.array_width(), 60);\n+        }\n+\n+        #[test]\n+        fn test_chain_width_config_exceeds_max_width() {\n+            let toml = r#\"\n+                max_width = 80\n+                chain_width = 90\n+            \"#;\n+            let config = Config::from_toml(toml, Path::new(\"\")).unwrap();\n+            assert_eq!(config.chain_width(), 80);\n+        }\n+\n+        #[test]\n+        fn test_single_line_if_else_max_width_config_exceeds_max_width() {\n+            let toml = r#\"\n+                max_width = 70\n+                single_line_if_else_max_width = 90\n+            \"#;\n+            let config = Config::from_toml(toml, Path::new(\"\")).unwrap();\n+            assert_eq!(config.single_line_if_else_max_width(), 70);\n+        }\n+\n+        #[test]\n+        fn test_override_fn_call_width_exceeds_max_width() {\n+            let mut config = Config::default();\n+            config.override_value(\"fn_call_width\", \"101\");\n+            assert_eq!(config.fn_call_width(), 100);\n+        }\n+\n+        #[test]\n+        fn test_override_attr_fn_like_width_exceeds_max_width() {\n+            let mut config = Config::default();\n+            config.override_value(\"attr_fn_like_width\", \"101\");\n+            assert_eq!(config.attr_fn_like_width(), 100);\n+        }\n+\n+        #[test]\n+        fn test_override_struct_lit_exceeds_max_width() {\n+            let mut config = Config::default();\n+            config.override_value(\"struct_lit_width\", \"101\");\n+            assert_eq!(config.struct_lit_width(), 100);\n+        }\n+\n+        #[test]\n+        fn test_override_struct_variant_width_exceeds_max_width() {\n+            let mut config = Config::default();\n+            config.override_value(\"struct_variant_width\", \"101\");\n+            assert_eq!(config.struct_variant_width(), 100);\n+        }\n+\n+        #[test]\n+        fn test_override_array_width_exceeds_max_width() {\n+            let mut config = Config::default();\n+            config.override_value(\"array_width\", \"101\");\n+            assert_eq!(config.array_width(), 100);\n+        }\n+\n+        #[test]\n+        fn test_override_chain_width_exceeds_max_width() {\n+            let mut config = Config::default();\n+            config.override_value(\"chain_width\", \"101\");\n+            assert_eq!(config.chain_width(), 100);\n+        }\n+\n+        #[test]\n+        fn test_override_single_line_if_else_max_width_exceeds_max_width() {\n+            let mut config = Config::default();\n+            config.override_value(\"single_line_if_else_max_width\", \"101\");\n+            assert_eq!(config.single_line_if_else_max_width(), 100);\n+        }\n+    }\n+}"}, {"sha": "3b91021813c16a164df655535c8ecbfb28f26915", "filename": "src/tools/rustfmt/src/config/options.rs", "status": "added", "additions": 444, "deletions": 0, "changes": 444, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Fsrc%2Fconfig%2Foptions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Fsrc%2Fconfig%2Foptions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fsrc%2Fconfig%2Foptions.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782", "patch": "@@ -0,0 +1,444 @@\n+use std::collections::{hash_set, HashSet};\n+use std::fmt;\n+use std::path::{Path, PathBuf};\n+use std::str::FromStr;\n+\n+use itertools::Itertools;\n+use rustfmt_config_proc_macro::config_type;\n+use serde::de::{SeqAccess, Visitor};\n+use serde::ser::SerializeSeq;\n+use serde::{Deserialize, Deserializer, Serialize, Serializer};\n+\n+use crate::config::lists::*;\n+use crate::config::Config;\n+\n+#[config_type]\n+pub enum NewlineStyle {\n+    /// Auto-detect based on the raw source input.\n+    Auto,\n+    /// Force CRLF (`\\r\\n`).\n+    Windows,\n+    /// Force CR (`\\n).\n+    Unix,\n+    /// `\\r\\n` in Windows, `\\n`` on other platforms.\n+    Native,\n+}\n+\n+#[config_type]\n+/// Where to put the opening brace of items (`fn`, `impl`, etc.).\n+pub enum BraceStyle {\n+    /// Put the opening brace on the next line.\n+    AlwaysNextLine,\n+    /// Put the opening brace on the same line, if possible.\n+    PreferSameLine,\n+    /// Prefer the same line except where there is a where-clause, in which\n+    /// case force the brace to be put on the next line.\n+    SameLineWhere,\n+}\n+\n+#[config_type]\n+/// Where to put the opening brace of conditional expressions (`if`, `match`, etc.).\n+pub enum ControlBraceStyle {\n+    /// K&R style, Rust community default\n+    AlwaysSameLine,\n+    /// Stroustrup style\n+    ClosingNextLine,\n+    /// Allman style\n+    AlwaysNextLine,\n+}\n+\n+#[config_type]\n+/// How to indent.\n+pub enum IndentStyle {\n+    /// First line on the same line as the opening brace, all lines aligned with\n+    /// the first line.\n+    Visual,\n+    /// First line is on a new line and all lines align with **block** indent.\n+    Block,\n+}\n+\n+#[config_type]\n+/// How to place a list-like items.\n+/// FIXME: Issue-3581: this should be renamed to ItemsLayout when publishing 2.0\n+pub enum Density {\n+    /// Fit as much on one line as possible.\n+    Compressed,\n+    /// Items are placed horizontally if sufficient space, vertically otherwise.\n+    Tall,\n+    /// Place every item on a separate line.\n+    Vertical,\n+}\n+\n+#[config_type]\n+/// Spacing around type combinators.\n+pub enum TypeDensity {\n+    /// No spaces around \"=\" and \"+\"\n+    Compressed,\n+    /// Spaces around \" = \" and \" + \"\n+    Wide,\n+}\n+\n+#[config_type]\n+/// Heuristic settings that can be used to simply\n+/// the configuration of the granular width configurations\n+/// like `struct_lit_width`, `array_width`, etc.\n+pub enum Heuristics {\n+    /// Turn off any heuristics\n+    Off,\n+    /// Turn on max heuristics\n+    Max,\n+    /// Use scaled values based on the value of `max_width`\n+    Default,\n+}\n+\n+impl Density {\n+    pub fn to_list_tactic(self, len: usize) -> ListTactic {\n+        match self {\n+            Density::Compressed => ListTactic::Mixed,\n+            Density::Tall => ListTactic::HorizontalVertical,\n+            Density::Vertical if len == 1 => ListTactic::Horizontal,\n+            Density::Vertical => ListTactic::Vertical,\n+        }\n+    }\n+}\n+\n+#[config_type]\n+/// Configuration for import groups, i.e. sets of imports separated by newlines.\n+pub enum GroupImportsTactic {\n+    /// Keep groups as they are.\n+    Preserve,\n+    /// Discard existing groups, and create new groups for\n+    ///  1. `std` / `core` / `alloc` imports\n+    ///  2. other imports\n+    ///  3. `self` / `crate` / `super` imports\n+    StdExternalCrate,\n+}\n+\n+#[config_type]\n+/// How to merge imports.\n+pub enum ImportGranularity {\n+    /// Do not merge imports.\n+    Preserve,\n+    /// Use one `use` statement per crate.\n+    Crate,\n+    /// Use one `use` statement per module.\n+    Module,\n+    /// Use one `use` statement per imported item.\n+    Item,\n+}\n+\n+#[config_type]\n+pub enum ReportTactic {\n+    Always,\n+    Unnumbered,\n+    Never,\n+}\n+\n+/// What Rustfmt should emit. Mostly corresponds to the `--emit` command line\n+/// option.\n+#[config_type]\n+pub enum EmitMode {\n+    /// Emits to files.\n+    Files,\n+    /// Writes the output to stdout.\n+    Stdout,\n+    /// Displays how much of the input file was processed\n+    Coverage,\n+    /// Unfancy stdout\n+    Checkstyle,\n+    /// Writes the resulting diffs in a JSON format. Returns an empty array\n+    /// `[]` if there were no diffs.\n+    Json,\n+    /// Output the changed lines (for internal value only)\n+    ModifiedLines,\n+    /// Checks if a diff can be generated. If so, rustfmt outputs a diff and\n+    /// quits with exit code 1.\n+    /// This option is designed to be run in CI where a non-zero exit signifies\n+    /// non-standard code formatting. Used for `--check`.\n+    Diff,\n+}\n+\n+/// Client-preference for coloured output.\n+#[config_type]\n+pub enum Color {\n+    /// Always use color, whether it is a piped or terminal output\n+    Always,\n+    /// Never use color\n+    Never,\n+    /// Automatically use color, if supported by terminal\n+    Auto,\n+}\n+\n+#[config_type]\n+/// rustfmt format style version.\n+pub enum Version {\n+    /// 1.x.y. When specified, rustfmt will format in the same style as 1.0.0.\n+    One,\n+    /// 2.x.y. When specified, rustfmt will format in the the latest style.\n+    Two,\n+}\n+\n+impl Color {\n+    /// Whether we should use a coloured terminal.\n+    pub fn use_colored_tty(self) -> bool {\n+        match self {\n+            Color::Always | Color::Auto => true,\n+            Color::Never => false,\n+        }\n+    }\n+}\n+\n+/// How chatty should Rustfmt be?\n+#[config_type]\n+pub enum Verbosity {\n+    /// Emit more.\n+    Verbose,\n+    /// Default.\n+    Normal,\n+    /// Emit as little as possible.\n+    Quiet,\n+}\n+\n+#[derive(Deserialize, Serialize, Clone, Debug, PartialEq)]\n+pub struct WidthHeuristics {\n+    // Maximum width of the args of a function call before falling back\n+    // to vertical formatting.\n+    pub fn_call_width: usize,\n+    // Maximum width of the args of a function-like attributes before falling\n+    // back to vertical formatting.\n+    pub attr_fn_like_width: usize,\n+    // Maximum width in the body of a struct lit before falling back to\n+    // vertical formatting.\n+    pub struct_lit_width: usize,\n+    // Maximum width in the body of a struct variant before falling back\n+    // to vertical formatting.\n+    pub struct_variant_width: usize,\n+    // Maximum width of an array literal before falling back to vertical\n+    // formatting.\n+    pub array_width: usize,\n+    // Maximum length of a chain to fit on a single line.\n+    pub chain_width: usize,\n+    // Maximum line length for single line if-else expressions. A value\n+    // of zero means always break if-else expressions.\n+    pub single_line_if_else_max_width: usize,\n+}\n+\n+impl fmt::Display for WidthHeuristics {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        write!(f, \"{:?}\", self)\n+    }\n+}\n+\n+impl WidthHeuristics {\n+    // Using this WidthHeuristics means we ignore heuristics.\n+    pub fn null() -> WidthHeuristics {\n+        WidthHeuristics {\n+            fn_call_width: usize::max_value(),\n+            attr_fn_like_width: usize::max_value(),\n+            struct_lit_width: 0,\n+            struct_variant_width: 0,\n+            array_width: usize::max_value(),\n+            chain_width: usize::max_value(),\n+            single_line_if_else_max_width: 0,\n+        }\n+    }\n+\n+    pub fn set(max_width: usize) -> WidthHeuristics {\n+        WidthHeuristics {\n+            fn_call_width: max_width,\n+            attr_fn_like_width: max_width,\n+            struct_lit_width: max_width,\n+            struct_variant_width: max_width,\n+            array_width: max_width,\n+            chain_width: max_width,\n+            single_line_if_else_max_width: max_width,\n+        }\n+    }\n+\n+    // scale the default WidthHeuristics according to max_width\n+    pub fn scaled(max_width: usize) -> WidthHeuristics {\n+        const DEFAULT_MAX_WIDTH: usize = 100;\n+        let max_width_ratio = if max_width > DEFAULT_MAX_WIDTH {\n+            let ratio = max_width as f32 / DEFAULT_MAX_WIDTH as f32;\n+            // round to the closest 0.1\n+            (ratio * 10.0).round() / 10.0\n+        } else {\n+            1.0\n+        };\n+        WidthHeuristics {\n+            fn_call_width: (60.0 * max_width_ratio).round() as usize,\n+            attr_fn_like_width: (70.0 * max_width_ratio).round() as usize,\n+            struct_lit_width: (18.0 * max_width_ratio).round() as usize,\n+            struct_variant_width: (35.0 * max_width_ratio).round() as usize,\n+            array_width: (60.0 * max_width_ratio).round() as usize,\n+            chain_width: (60.0 * max_width_ratio).round() as usize,\n+            single_line_if_else_max_width: (50.0 * max_width_ratio).round() as usize,\n+        }\n+    }\n+}\n+\n+impl ::std::str::FromStr for WidthHeuristics {\n+    type Err = &'static str;\n+\n+    fn from_str(_: &str) -> Result<Self, Self::Err> {\n+        Err(\"WidthHeuristics is not parsable\")\n+    }\n+}\n+\n+impl Default for EmitMode {\n+    fn default() -> EmitMode {\n+        EmitMode::Files\n+    }\n+}\n+\n+/// A set of directories, files and modules that rustfmt should ignore.\n+#[derive(Default, Clone, Debug, PartialEq)]\n+pub struct IgnoreList {\n+    /// A set of path specified in rustfmt.toml.\n+    path_set: HashSet<PathBuf>,\n+    /// A path to rustfmt.toml.\n+    rustfmt_toml_path: PathBuf,\n+}\n+\n+impl fmt::Display for IgnoreList {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        write!(\n+            f,\n+            \"[{}]\",\n+            self.path_set\n+                .iter()\n+                .format_with(\", \", |path, f| f(&format_args!(\n+                    \"{}\",\n+                    path.to_string_lossy()\n+                )))\n+        )\n+    }\n+}\n+\n+impl Serialize for IgnoreList {\n+    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n+    where\n+        S: Serializer,\n+    {\n+        let mut seq = serializer.serialize_seq(Some(self.path_set.len()))?;\n+        for e in &self.path_set {\n+            seq.serialize_element(e)?;\n+        }\n+        seq.end()\n+    }\n+}\n+\n+impl<'de> Deserialize<'de> for IgnoreList {\n+    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n+    where\n+        D: Deserializer<'de>,\n+    {\n+        struct HashSetVisitor;\n+        impl<'v> Visitor<'v> for HashSetVisitor {\n+            type Value = HashSet<PathBuf>;\n+\n+            fn expecting(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {\n+                formatter.write_str(\"a sequence of path\")\n+            }\n+\n+            fn visit_seq<A>(self, mut seq: A) -> Result<Self::Value, A::Error>\n+            where\n+                A: SeqAccess<'v>,\n+            {\n+                let mut path_set = HashSet::new();\n+                while let Some(elem) = seq.next_element()? {\n+                    path_set.insert(elem);\n+                }\n+                Ok(path_set)\n+            }\n+        }\n+        Ok(IgnoreList {\n+            path_set: deserializer.deserialize_seq(HashSetVisitor)?,\n+            rustfmt_toml_path: PathBuf::new(),\n+        })\n+    }\n+}\n+\n+impl<'a> IntoIterator for &'a IgnoreList {\n+    type Item = &'a PathBuf;\n+    type IntoIter = hash_set::Iter<'a, PathBuf>;\n+\n+    fn into_iter(self) -> Self::IntoIter {\n+        self.path_set.iter()\n+    }\n+}\n+\n+impl IgnoreList {\n+    pub fn add_prefix(&mut self, dir: &Path) {\n+        self.rustfmt_toml_path = dir.to_path_buf();\n+    }\n+\n+    pub fn rustfmt_toml_path(&self) -> &Path {\n+        &self.rustfmt_toml_path\n+    }\n+}\n+\n+impl FromStr for IgnoreList {\n+    type Err = &'static str;\n+\n+    fn from_str(_: &str) -> Result<Self, Self::Err> {\n+        Err(\"IgnoreList is not parsable\")\n+    }\n+}\n+\n+/// Maps client-supplied options to Rustfmt's internals, mostly overriding\n+/// values in a config with values from the command line.\n+pub trait CliOptions {\n+    fn apply_to(self, config: &mut Config);\n+    fn config_path(&self) -> Option<&Path>;\n+}\n+\n+/// The edition of the syntax and semntics of code (RFC 2052).\n+#[config_type]\n+pub enum Edition {\n+    #[value = \"2015\"]\n+    #[doc_hint = \"2015\"]\n+    /// Edition 2015.\n+    Edition2015,\n+    #[value = \"2018\"]\n+    #[doc_hint = \"2018\"]\n+    /// Edition 2018.\n+    Edition2018,\n+    #[value = \"2021\"]\n+    #[doc_hint = \"2021\"]\n+    /// Edition 2021.\n+    Edition2021,\n+}\n+\n+impl Default for Edition {\n+    fn default() -> Edition {\n+        Edition::Edition2015\n+    }\n+}\n+\n+impl From<Edition> for rustc_span::edition::Edition {\n+    fn from(edition: Edition) -> Self {\n+        match edition {\n+            Edition::Edition2015 => Self::Edition2015,\n+            Edition::Edition2018 => Self::Edition2018,\n+            Edition::Edition2021 => Self::Edition2021,\n+        }\n+    }\n+}\n+\n+impl PartialOrd for Edition {\n+    fn partial_cmp(&self, other: &Edition) -> Option<std::cmp::Ordering> {\n+        rustc_span::edition::Edition::partial_cmp(&(*self).into(), &(*other).into())\n+    }\n+}\n+\n+/// Controls how rustfmt should handle leading pipes on match arms.\n+#[config_type]\n+pub enum MatchArmLeadingPipe {\n+    /// Place leading pipes on all match arms\n+    Always,\n+    /// Never emit leading pipes on match arms\n+    Never,\n+    /// Preserve any existing leading pipes\n+    Preserve,\n+}"}, {"sha": "f5a0497425145ff6d413e6a19ec2759400e3e340", "filename": "src/tools/rustfmt/src/coverage.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Fsrc%2Fcoverage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Fsrc%2Fcoverage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fsrc%2Fcoverage.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782", "patch": "@@ -0,0 +1,15 @@\n+use crate::{Config, EmitMode};\n+use std::borrow::Cow;\n+\n+pub(crate) fn transform_missing_snippet<'a>(config: &Config, string: &'a str) -> Cow<'a, str> {\n+    match config.emit_mode() {\n+        EmitMode::Coverage => Cow::from(replace_chars(string)),\n+        _ => Cow::from(string),\n+    }\n+}\n+\n+fn replace_chars(s: &str) -> String {\n+    s.chars()\n+        .map(|ch| if ch.is_whitespace() { ch } else { 'X' })\n+        .collect()\n+}"}, {"sha": "dc2c99a301e38bd2a03abdd98ea7fc8b524ea82d", "filename": "src/tools/rustfmt/src/emitter.rs", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Fsrc%2Femitter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Fsrc%2Femitter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fsrc%2Femitter.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782", "patch": "@@ -0,0 +1,52 @@\n+pub(crate) use self::checkstyle::*;\n+pub(crate) use self::diff::*;\n+pub(crate) use self::files::*;\n+pub(crate) use self::files_with_backup::*;\n+pub(crate) use self::json::*;\n+pub(crate) use self::modified_lines::*;\n+pub(crate) use self::stdout::*;\n+use crate::FileName;\n+use std::io::{self, Write};\n+use std::path::Path;\n+\n+mod checkstyle;\n+mod diff;\n+mod files;\n+mod files_with_backup;\n+mod json;\n+mod modified_lines;\n+mod stdout;\n+\n+pub(crate) struct FormattedFile<'a> {\n+    pub(crate) filename: &'a FileName,\n+    pub(crate) original_text: &'a str,\n+    pub(crate) formatted_text: &'a str,\n+}\n+\n+#[derive(Debug, Default, Clone)]\n+pub(crate) struct EmitterResult {\n+    pub(crate) has_diff: bool,\n+}\n+\n+pub(crate) trait Emitter {\n+    fn emit_formatted_file(\n+        &mut self,\n+        output: &mut dyn Write,\n+        formatted_file: FormattedFile<'_>,\n+    ) -> Result<EmitterResult, io::Error>;\n+\n+    fn emit_header(&self, _output: &mut dyn Write) -> Result<(), io::Error> {\n+        Ok(())\n+    }\n+\n+    fn emit_footer(&self, _output: &mut dyn Write) -> Result<(), io::Error> {\n+        Ok(())\n+    }\n+}\n+\n+fn ensure_real_path(filename: &FileName) -> &Path {\n+    match *filename {\n+        FileName::Real(ref path) => path,\n+        _ => panic!(\"cannot format `{}` and emit to files\", filename),\n+    }\n+}"}, {"sha": "4448214f3ff2cd1ac4c2fd7e519ca8342c436289", "filename": "src/tools/rustfmt/src/emitter/checkstyle.rs", "status": "added", "additions": 148, "deletions": 0, "changes": 148, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Fsrc%2Femitter%2Fcheckstyle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Fsrc%2Femitter%2Fcheckstyle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fsrc%2Femitter%2Fcheckstyle.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782", "patch": "@@ -0,0 +1,148 @@\n+use self::xml::XmlEscaped;\n+use super::*;\n+use crate::rustfmt_diff::{make_diff, DiffLine, Mismatch};\n+use std::io::{self, Write};\n+use std::path::Path;\n+\n+mod xml;\n+\n+#[derive(Debug, Default)]\n+pub(crate) struct CheckstyleEmitter;\n+\n+impl Emitter for CheckstyleEmitter {\n+    fn emit_header(&self, output: &mut dyn Write) -> Result<(), io::Error> {\n+        writeln!(output, r#\"<?xml version=\"1.0\" encoding=\"utf-8\"?>\"#)?;\n+        write!(output, r#\"<checkstyle version=\"4.3\">\"#)?;\n+        Ok(())\n+    }\n+\n+    fn emit_footer(&self, output: &mut dyn Write) -> Result<(), io::Error> {\n+        writeln!(output, \"</checkstyle>\")\n+    }\n+\n+    fn emit_formatted_file(\n+        &mut self,\n+        output: &mut dyn Write,\n+        FormattedFile {\n+            filename,\n+            original_text,\n+            formatted_text,\n+        }: FormattedFile<'_>,\n+    ) -> Result<EmitterResult, io::Error> {\n+        const CONTEXT_SIZE: usize = 0;\n+        let filename = ensure_real_path(filename);\n+        let diff = make_diff(original_text, formatted_text, CONTEXT_SIZE);\n+        output_checkstyle_file(output, filename, diff)?;\n+        Ok(EmitterResult::default())\n+    }\n+}\n+\n+pub(crate) fn output_checkstyle_file<T>(\n+    mut writer: T,\n+    filename: &Path,\n+    diff: Vec<Mismatch>,\n+) -> Result<(), io::Error>\n+where\n+    T: Write,\n+{\n+    write!(writer, r#\"<file name=\"{}\">\"#, filename.display())?;\n+    for mismatch in diff {\n+        let begin_line = mismatch.line_number;\n+        let mut current_line;\n+        let mut line_counter = 0;\n+        for line in mismatch.lines {\n+            // Do nothing with `DiffLine::Context` and `DiffLine::Resulting`.\n+            if let DiffLine::Expected(message) = line {\n+                current_line = begin_line + line_counter;\n+                line_counter += 1;\n+                write!(\n+                    writer,\n+                    r#\"<error line=\"{}\" severity=\"warning\" message=\"Should be `{}`\" />\"#,\n+                    current_line,\n+                    XmlEscaped(&message)\n+                )?;\n+            }\n+        }\n+    }\n+    write!(writer, \"</file>\")?;\n+    Ok(())\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+    use std::path::PathBuf;\n+\n+    #[test]\n+    fn emits_empty_record_on_file_with_no_mismatches() {\n+        let file_name = \"src/well_formatted.rs\";\n+        let mut writer = Vec::new();\n+        let _ = output_checkstyle_file(&mut writer, &PathBuf::from(file_name), vec![]);\n+        assert_eq!(\n+            &writer[..],\n+            format!(r#\"<file name=\"{}\"></file>\"#, file_name).as_bytes()\n+        );\n+    }\n+\n+    // https://github.com/rust-lang/rustfmt/issues/1636\n+    #[test]\n+    fn emits_single_xml_tree_containing_all_files() {\n+        let bin_file = \"src/bin.rs\";\n+        let bin_original = vec![\"fn main() {\", \"println!(\\\"Hello, world!\\\");\", \"}\"];\n+        let bin_formatted = vec![\"fn main() {\", \"    println!(\\\"Hello, world!\\\");\", \"}\"];\n+        let lib_file = \"src/lib.rs\";\n+        let lib_original = vec![\"fn greet() {\", \"println!(\\\"Greetings!\\\");\", \"}\"];\n+        let lib_formatted = vec![\"fn greet() {\", \"    println!(\\\"Greetings!\\\");\", \"}\"];\n+        let mut writer = Vec::new();\n+        let mut emitter = CheckstyleEmitter::default();\n+        let _ = emitter.emit_header(&mut writer);\n+        let _ = emitter\n+            .emit_formatted_file(\n+                &mut writer,\n+                FormattedFile {\n+                    filename: &FileName::Real(PathBuf::from(bin_file)),\n+                    original_text: &bin_original.join(\"\\n\"),\n+                    formatted_text: &bin_formatted.join(\"\\n\"),\n+                },\n+            )\n+            .unwrap();\n+        let _ = emitter\n+            .emit_formatted_file(\n+                &mut writer,\n+                FormattedFile {\n+                    filename: &FileName::Real(PathBuf::from(lib_file)),\n+                    original_text: &lib_original.join(\"\\n\"),\n+                    formatted_text: &lib_formatted.join(\"\\n\"),\n+                },\n+            )\n+            .unwrap();\n+        let _ = emitter.emit_footer(&mut writer);\n+        let exp_bin_xml = vec![\n+            format!(r#\"<file name=\"{}\">\"#, bin_file),\n+            format!(\n+                r#\"<error line=\"2\" severity=\"warning\" message=\"Should be `{}`\" />\"#,\n+                XmlEscaped(&r#\"    println!(\"Hello, world!\");\"#),\n+            ),\n+            String::from(\"</file>\"),\n+        ];\n+        let exp_lib_xml = vec![\n+            format!(r#\"<file name=\"{}\">\"#, lib_file),\n+            format!(\n+                r#\"<error line=\"2\" severity=\"warning\" message=\"Should be `{}`\" />\"#,\n+                XmlEscaped(&r#\"    println!(\"Greetings!\");\"#),\n+            ),\n+            String::from(\"</file>\"),\n+        ];\n+        assert_eq!(\n+            String::from_utf8(writer).unwrap(),\n+            vec![\n+                r#\"<?xml version=\"1.0\" encoding=\"utf-8\"?>\"#,\n+                \"\\n\",\n+                r#\"<checkstyle version=\"4.3\">\"#,\n+                &format!(\"{}{}\", exp_bin_xml.join(\"\"), exp_lib_xml.join(\"\")),\n+                \"</checkstyle>\\n\",\n+            ]\n+            .join(\"\"),\n+        );\n+    }\n+}"}, {"sha": "f251aabe8785fc713efece22ad519bec7c0ceafb", "filename": "src/tools/rustfmt/src/emitter/checkstyle/xml.rs", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Fsrc%2Femitter%2Fcheckstyle%2Fxml.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Fsrc%2Femitter%2Fcheckstyle%2Fxml.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fsrc%2Femitter%2Fcheckstyle%2Fxml.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782", "patch": "@@ -0,0 +1,52 @@\n+use std::fmt::{self, Display};\n+\n+/// Convert special characters into XML entities.\n+/// This is needed for checkstyle output.\n+pub(super) struct XmlEscaped<'a>(pub(super) &'a str);\n+\n+impl<'a> Display for XmlEscaped<'a> {\n+    fn fmt(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        for char in self.0.chars() {\n+            match char {\n+                '<' => write!(formatter, \"&lt;\"),\n+                '>' => write!(formatter, \"&gt;\"),\n+                '\"' => write!(formatter, \"&quot;\"),\n+                '\\'' => write!(formatter, \"&apos;\"),\n+                '&' => write!(formatter, \"&amp;\"),\n+                _ => write!(formatter, \"{}\", char),\n+            }?;\n+        }\n+\n+        Ok(())\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+\n+    #[test]\n+    fn special_characters_are_escaped() {\n+        assert_eq!(\n+            \"&lt;&gt;&quot;&apos;&amp;\",\n+            format!(\"{}\", XmlEscaped(r#\"<>\"'&\"#)),\n+        );\n+    }\n+\n+    #[test]\n+    fn special_characters_are_escaped_in_string_with_other_characters() {\n+        assert_eq!(\n+            \"The quick brown &quot;\ud83e\udd8a&quot; jumps &lt;over&gt; the lazy \ud83d\udc36\",\n+            format!(\n+                \"{}\",\n+                XmlEscaped(r#\"The quick brown \"\ud83e\udd8a\" jumps <over> the lazy \ud83d\udc36\"#)\n+            ),\n+        );\n+    }\n+\n+    #[test]\n+    fn other_characters_are_not_escaped() {\n+        let string = \"The quick brown \ud83e\udd8a jumps over the lazy \ud83d\udc36\";\n+        assert_eq!(string, format!(\"{}\", XmlEscaped(string)));\n+    }\n+}"}, {"sha": "9be4fb28f993ffdc986a48118867d9a3fad85ef2", "filename": "src/tools/rustfmt/src/emitter/diff.rs", "status": "added", "additions": 138, "deletions": 0, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Fsrc%2Femitter%2Fdiff.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Fsrc%2Femitter%2Fdiff.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fsrc%2Femitter%2Fdiff.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782", "patch": "@@ -0,0 +1,138 @@\n+use super::*;\n+use crate::config::Config;\n+use crate::rustfmt_diff::{make_diff, print_diff};\n+\n+pub(crate) struct DiffEmitter {\n+    config: Config,\n+}\n+\n+impl DiffEmitter {\n+    pub(crate) fn new(config: Config) -> Self {\n+        Self { config }\n+    }\n+}\n+\n+impl Emitter for DiffEmitter {\n+    fn emit_formatted_file(\n+        &mut self,\n+        output: &mut dyn Write,\n+        FormattedFile {\n+            filename,\n+            original_text,\n+            formatted_text,\n+        }: FormattedFile<'_>,\n+    ) -> Result<EmitterResult, io::Error> {\n+        const CONTEXT_SIZE: usize = 3;\n+        let mismatch = make_diff(&original_text, formatted_text, CONTEXT_SIZE);\n+        let has_diff = !mismatch.is_empty();\n+\n+        if has_diff {\n+            if self.config.print_misformatted_file_names() {\n+                writeln!(output, \"{}\", ensure_real_path(filename).display())?;\n+            } else {\n+                print_diff(\n+                    mismatch,\n+                    |line_num| format!(\"Diff in {} at line {}:\", filename, line_num),\n+                    &self.config,\n+                );\n+            }\n+        } else if original_text != formatted_text {\n+            // This occurs when the only difference between the original and formatted values\n+            // is the newline style. This happens because The make_diff function compares the\n+            // original and formatted values line by line, independent of line endings.\n+            let file_path = ensure_real_path(filename);\n+            writeln!(output, \"Incorrect newline style in {}\", file_path.display())?;\n+            return Ok(EmitterResult { has_diff: true });\n+        }\n+\n+        return Ok(EmitterResult { has_diff });\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+    use crate::config::Config;\n+    use crate::FileName;\n+    use std::path::PathBuf;\n+\n+    #[test]\n+    fn does_not_print_when_no_files_reformatted() {\n+        let mut writer = Vec::new();\n+        let config = Config::default();\n+        let mut emitter = DiffEmitter::new(config);\n+        let result = emitter\n+            .emit_formatted_file(\n+                &mut writer,\n+                FormattedFile {\n+                    filename: &FileName::Real(PathBuf::from(\"src/lib.rs\")),\n+                    original_text: \"fn empty() {}\\n\",\n+                    formatted_text: \"fn empty() {}\\n\",\n+                },\n+            )\n+            .unwrap();\n+        assert_eq!(result.has_diff, false);\n+        assert_eq!(writer.len(), 0);\n+    }\n+\n+    #[test]\n+    fn prints_file_names_when_config_is_enabled() {\n+        let bin_file = \"src/bin.rs\";\n+        let bin_original = \"fn main() {\\nprintln!(\\\"Hello, world!\\\");\\n}\";\n+        let bin_formatted = \"fn main() {\\n    println!(\\\"Hello, world!\\\");\\n}\";\n+        let lib_file = \"src/lib.rs\";\n+        let lib_original = \"fn greet() {\\nprintln!(\\\"Greetings!\\\");\\n}\";\n+        let lib_formatted = \"fn greet() {\\n    println!(\\\"Greetings!\\\");\\n}\";\n+\n+        let mut writer = Vec::new();\n+        let mut config = Config::default();\n+        config.set().print_misformatted_file_names(true);\n+        let mut emitter = DiffEmitter::new(config);\n+        let _ = emitter\n+            .emit_formatted_file(\n+                &mut writer,\n+                FormattedFile {\n+                    filename: &FileName::Real(PathBuf::from(bin_file)),\n+                    original_text: bin_original,\n+                    formatted_text: bin_formatted,\n+                },\n+            )\n+            .unwrap();\n+        let _ = emitter\n+            .emit_formatted_file(\n+                &mut writer,\n+                FormattedFile {\n+                    filename: &FileName::Real(PathBuf::from(lib_file)),\n+                    original_text: lib_original,\n+                    formatted_text: lib_formatted,\n+                },\n+            )\n+            .unwrap();\n+\n+        assert_eq!(\n+            String::from_utf8(writer).unwrap(),\n+            format!(\"{}\\n{}\\n\", bin_file, lib_file),\n+        )\n+    }\n+\n+    #[test]\n+    fn prints_newline_message_with_only_newline_style_diff() {\n+        let mut writer = Vec::new();\n+        let config = Config::default();\n+        let mut emitter = DiffEmitter::new(config);\n+        let _ = emitter\n+            .emit_formatted_file(\n+                &mut writer,\n+                FormattedFile {\n+                    filename: &FileName::Real(PathBuf::from(\"src/lib.rs\")),\n+                    original_text: \"fn empty() {}\\n\",\n+                    formatted_text: \"fn empty() {}\\r\\n\",\n+                },\n+            )\n+            .unwrap();\n+        assert_eq!(\n+            String::from_utf8(writer).unwrap(),\n+            String::from(\"Incorrect newline style in src/lib.rs\\n\")\n+        );\n+    }\n+}"}, {"sha": "6360b73ee615e084b0a3c64ee46a70e0102c6789", "filename": "src/tools/rustfmt/src/emitter/files.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Fsrc%2Femitter%2Ffiles.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Fsrc%2Femitter%2Ffiles.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fsrc%2Femitter%2Ffiles.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782", "patch": "@@ -0,0 +1,37 @@\n+use super::*;\n+use std::fs;\n+\n+#[derive(Debug, Default)]\n+pub(crate) struct FilesEmitter {\n+    print_misformatted_file_names: bool,\n+}\n+\n+impl FilesEmitter {\n+    pub(crate) fn new(print_misformatted_file_names: bool) -> Self {\n+        Self {\n+            print_misformatted_file_names,\n+        }\n+    }\n+}\n+\n+impl Emitter for FilesEmitter {\n+    fn emit_formatted_file(\n+        &mut self,\n+        output: &mut dyn Write,\n+        FormattedFile {\n+            filename,\n+            original_text,\n+            formatted_text,\n+        }: FormattedFile<'_>,\n+    ) -> Result<EmitterResult, io::Error> {\n+        // Write text directly over original file if there is a diff.\n+        let filename = ensure_real_path(filename);\n+        if original_text != formatted_text {\n+            fs::write(filename, formatted_text)?;\n+            if self.print_misformatted_file_names {\n+                writeln!(output, \"{}\", filename.display())?;\n+            }\n+        }\n+        Ok(EmitterResult::default())\n+    }\n+}"}, {"sha": "4c15f6fa5ec7ac61530858e535b25dd5843014aa", "filename": "src/tools/rustfmt/src/emitter/files_with_backup.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Fsrc%2Femitter%2Ffiles_with_backup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Fsrc%2Femitter%2Ffiles_with_backup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fsrc%2Femitter%2Ffiles_with_backup.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782", "patch": "@@ -0,0 +1,31 @@\n+use super::*;\n+use std::fs;\n+\n+#[derive(Debug, Default)]\n+pub(crate) struct FilesWithBackupEmitter;\n+\n+impl Emitter for FilesWithBackupEmitter {\n+    fn emit_formatted_file(\n+        &mut self,\n+        _output: &mut dyn Write,\n+        FormattedFile {\n+            filename,\n+            original_text,\n+            formatted_text,\n+        }: FormattedFile<'_>,\n+    ) -> Result<EmitterResult, io::Error> {\n+        let filename = ensure_real_path(filename);\n+        if original_text != formatted_text {\n+            // Do a little dance to make writing safer - write to a temp file\n+            // rename the original to a .bk, then rename the temp file to the\n+            // original.\n+            let tmp_name = filename.with_extension(\"tmp\");\n+            let bk_name = filename.with_extension(\"bk\");\n+\n+            fs::write(&tmp_name, formatted_text)?;\n+            fs::rename(filename, bk_name)?;\n+            fs::rename(tmp_name, filename)?;\n+        }\n+        Ok(EmitterResult::default())\n+    }\n+}"}, {"sha": "269dd2d4daf57d81aa9fa23e73a11702bf35e62d", "filename": "src/tools/rustfmt/src/emitter/json.rs", "status": "added", "additions": 349, "deletions": 0, "changes": 349, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Fsrc%2Femitter%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Fsrc%2Femitter%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fsrc%2Femitter%2Fjson.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782", "patch": "@@ -0,0 +1,349 @@\n+use super::*;\n+use crate::rustfmt_diff::{make_diff, DiffLine, Mismatch};\n+use serde::Serialize;\n+use serde_json::to_string as to_json_string;\n+use std::io::{self, Write};\n+use std::path::Path;\n+\n+#[derive(Debug, Default)]\n+pub(crate) struct JsonEmitter {\n+    num_files: u32,\n+}\n+\n+#[derive(Debug, Default, Serialize)]\n+struct MismatchedBlock {\n+    original_begin_line: u32,\n+    original_end_line: u32,\n+    expected_begin_line: u32,\n+    expected_end_line: u32,\n+    original: String,\n+    expected: String,\n+}\n+\n+#[derive(Debug, Default, Serialize)]\n+struct MismatchedFile {\n+    name: String,\n+    mismatches: Vec<MismatchedBlock>,\n+}\n+\n+impl Emitter for JsonEmitter {\n+    fn emit_header(&self, output: &mut dyn Write) -> Result<(), io::Error> {\n+        write!(output, \"[\")?;\n+        Ok(())\n+    }\n+\n+    fn emit_footer(&self, output: &mut dyn Write) -> Result<(), io::Error> {\n+        write!(output, \"]\")?;\n+        Ok(())\n+    }\n+\n+    fn emit_formatted_file(\n+        &mut self,\n+        output: &mut dyn Write,\n+        FormattedFile {\n+            filename,\n+            original_text,\n+            formatted_text,\n+        }: FormattedFile<'_>,\n+    ) -> Result<EmitterResult, io::Error> {\n+        const CONTEXT_SIZE: usize = 0;\n+        let filename = ensure_real_path(filename);\n+        let diff = make_diff(original_text, formatted_text, CONTEXT_SIZE);\n+        let has_diff = !diff.is_empty();\n+\n+        if has_diff {\n+            output_json_file(output, filename, diff, self.num_files)?;\n+            self.num_files += 1;\n+        }\n+\n+        Ok(EmitterResult { has_diff })\n+    }\n+}\n+\n+fn output_json_file<T>(\n+    mut writer: T,\n+    filename: &Path,\n+    diff: Vec<Mismatch>,\n+    num_emitted_files: u32,\n+) -> Result<(), io::Error>\n+where\n+    T: Write,\n+{\n+    let mut mismatches = vec![];\n+    for mismatch in diff {\n+        let original_begin_line = mismatch.line_number_orig;\n+        let expected_begin_line = mismatch.line_number;\n+        let mut original_end_line = original_begin_line;\n+        let mut expected_end_line = expected_begin_line;\n+        let mut original_line_counter = 0;\n+        let mut expected_line_counter = 0;\n+        let mut original_lines = vec![];\n+        let mut expected_lines = vec![];\n+\n+        for line in mismatch.lines {\n+            match line {\n+                DiffLine::Expected(msg) => {\n+                    expected_end_line = expected_begin_line + expected_line_counter;\n+                    expected_line_counter += 1;\n+                    expected_lines.push(msg)\n+                }\n+                DiffLine::Resulting(msg) => {\n+                    original_end_line = original_begin_line + original_line_counter;\n+                    original_line_counter += 1;\n+                    original_lines.push(msg)\n+                }\n+                DiffLine::Context(_) => continue,\n+            }\n+        }\n+\n+        mismatches.push(MismatchedBlock {\n+            original_begin_line,\n+            original_end_line,\n+            expected_begin_line,\n+            expected_end_line,\n+            original: original_lines.join(\"\\n\"),\n+            expected: expected_lines.join(\"\\n\"),\n+        });\n+    }\n+    let json = to_json_string(&MismatchedFile {\n+        name: String::from(filename.to_str().unwrap()),\n+        mismatches,\n+    })?;\n+    let prefix = if num_emitted_files > 0 { \",\" } else { \"\" };\n+    write!(writer, \"{}{}\", prefix, &json)?;\n+    Ok(())\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+    use crate::FileName;\n+    use std::path::PathBuf;\n+\n+    #[test]\n+    fn expected_line_range_correct_when_single_line_split() {\n+        let file = \"foo/bar.rs\";\n+        let mismatched_file = MismatchedFile {\n+            name: String::from(file),\n+            mismatches: vec![MismatchedBlock {\n+                original_begin_line: 79,\n+                original_end_line: 79,\n+                expected_begin_line: 79,\n+                expected_end_line: 82,\n+                original: String::from(\"fn Foo<T>() where T: Bar {\"),\n+                expected: String::from(\"fn Foo<T>()\\nwhere\\n    T: Bar,\\n{\"),\n+            }],\n+        };\n+        let mismatch = Mismatch {\n+            line_number: 79,\n+            line_number_orig: 79,\n+            lines: vec![\n+                DiffLine::Resulting(String::from(\"fn Foo<T>() where T: Bar {\")),\n+                DiffLine::Expected(String::from(\"fn Foo<T>()\")),\n+                DiffLine::Expected(String::from(\"where\")),\n+                DiffLine::Expected(String::from(\"    T: Bar,\")),\n+                DiffLine::Expected(String::from(\"{\")),\n+            ],\n+        };\n+\n+        let mut writer = Vec::new();\n+        let exp_json = to_json_string(&mismatched_file).unwrap();\n+        let _ = output_json_file(&mut writer, &PathBuf::from(file), vec![mismatch], 0);\n+        assert_eq!(&writer[..], format!(\"{}\", exp_json).as_bytes());\n+    }\n+\n+    #[test]\n+    fn context_lines_ignored() {\n+        let file = \"src/lib.rs\";\n+        let mismatched_file = MismatchedFile {\n+            name: String::from(file),\n+            mismatches: vec![MismatchedBlock {\n+                original_begin_line: 5,\n+                original_end_line: 5,\n+                expected_begin_line: 5,\n+                expected_end_line: 5,\n+                original: String::from(\n+                    \"fn foo(_x: &u64) -> Option<&(dyn::std::error::Error + 'static)> {\",\n+                ),\n+                expected: String::from(\n+                    \"fn foo(_x: &u64) -> Option<&(dyn ::std::error::Error + 'static)> {\",\n+                ),\n+            }],\n+        };\n+        let mismatch = Mismatch {\n+            line_number: 5,\n+            line_number_orig: 5,\n+            lines: vec![\n+                DiffLine::Context(String::new()),\n+                DiffLine::Resulting(String::from(\n+                    \"fn foo(_x: &u64) -> Option<&(dyn::std::error::Error + 'static)> {\",\n+                )),\n+                DiffLine::Context(String::new()),\n+                DiffLine::Expected(String::from(\n+                    \"fn foo(_x: &u64) -> Option<&(dyn ::std::error::Error + 'static)> {\",\n+                )),\n+                DiffLine::Context(String::new()),\n+            ],\n+        };\n+\n+        let mut writer = Vec::new();\n+        let exp_json = to_json_string(&mismatched_file).unwrap();\n+        let _ = output_json_file(&mut writer, &PathBuf::from(file), vec![mismatch], 0);\n+        assert_eq!(&writer[..], format!(\"{}\", exp_json).as_bytes());\n+    }\n+\n+    #[test]\n+    fn emits_empty_array_on_no_diffs() {\n+        let mut writer = Vec::new();\n+        let mut emitter = JsonEmitter::default();\n+        let _ = emitter.emit_header(&mut writer);\n+        let result = emitter\n+            .emit_formatted_file(\n+                &mut writer,\n+                FormattedFile {\n+                    filename: &FileName::Real(PathBuf::from(\"src/lib.rs\")),\n+                    original_text: \"fn empty() {}\\n\",\n+                    formatted_text: \"fn empty() {}\\n\",\n+                },\n+            )\n+            .unwrap();\n+        let _ = emitter.emit_footer(&mut writer);\n+        assert_eq!(result.has_diff, false);\n+        assert_eq!(&writer[..], \"[]\".as_bytes());\n+    }\n+\n+    #[test]\n+    fn emits_array_with_files_with_diffs() {\n+        let file_name = \"src/bin.rs\";\n+        let original = vec![\n+            \"fn main() {\",\n+            \"println!(\\\"Hello, world!\\\");\",\n+            \"}\",\n+            \"\",\n+            \"#[cfg(test)]\",\n+            \"mod tests {\",\n+            \"#[test]\",\n+            \"fn it_works() {\",\n+            \"    assert_eq!(2 + 2, 4);\",\n+            \"}\",\n+            \"}\",\n+        ];\n+        let formatted = vec![\n+            \"fn main() {\",\n+            \"    println!(\\\"Hello, world!\\\");\",\n+            \"}\",\n+            \"\",\n+            \"#[cfg(test)]\",\n+            \"mod tests {\",\n+            \"    #[test]\",\n+            \"    fn it_works() {\",\n+            \"        assert_eq!(2 + 2, 4);\",\n+            \"    }\",\n+            \"}\",\n+        ];\n+        let mut writer = Vec::new();\n+        let mut emitter = JsonEmitter::default();\n+        let _ = emitter.emit_header(&mut writer);\n+        let result = emitter\n+            .emit_formatted_file(\n+                &mut writer,\n+                FormattedFile {\n+                    filename: &FileName::Real(PathBuf::from(file_name)),\n+                    original_text: &original.join(\"\\n\"),\n+                    formatted_text: &formatted.join(\"\\n\"),\n+                },\n+            )\n+            .unwrap();\n+        let _ = emitter.emit_footer(&mut writer);\n+        let exp_json = to_json_string(&MismatchedFile {\n+            name: String::from(file_name),\n+            mismatches: vec![\n+                MismatchedBlock {\n+                    original_begin_line: 2,\n+                    original_end_line: 2,\n+                    expected_begin_line: 2,\n+                    expected_end_line: 2,\n+                    original: String::from(\"println!(\\\"Hello, world!\\\");\"),\n+                    expected: String::from(\"    println!(\\\"Hello, world!\\\");\"),\n+                },\n+                MismatchedBlock {\n+                    original_begin_line: 7,\n+                    original_end_line: 10,\n+                    expected_begin_line: 7,\n+                    expected_end_line: 10,\n+                    original: String::from(\n+                        \"#[test]\\nfn it_works() {\\n    assert_eq!(2 + 2, 4);\\n}\",\n+                    ),\n+                    expected: String::from(\n+                        \"    #[test]\\n    fn it_works() {\\n        assert_eq!(2 + 2, 4);\\n    }\",\n+                    ),\n+                },\n+            ],\n+        })\n+        .unwrap();\n+        assert_eq!(result.has_diff, true);\n+        assert_eq!(&writer[..], format!(\"[{}]\", exp_json).as_bytes());\n+    }\n+\n+    #[test]\n+    fn emits_valid_json_with_multiple_files() {\n+        let bin_file = \"src/bin.rs\";\n+        let bin_original = vec![\"fn main() {\", \"println!(\\\"Hello, world!\\\");\", \"}\"];\n+        let bin_formatted = vec![\"fn main() {\", \"    println!(\\\"Hello, world!\\\");\", \"}\"];\n+        let lib_file = \"src/lib.rs\";\n+        let lib_original = vec![\"fn greet() {\", \"println!(\\\"Greetings!\\\");\", \"}\"];\n+        let lib_formatted = vec![\"fn greet() {\", \"    println!(\\\"Greetings!\\\");\", \"}\"];\n+        let mut writer = Vec::new();\n+        let mut emitter = JsonEmitter::default();\n+        let _ = emitter.emit_header(&mut writer);\n+        let _ = emitter\n+            .emit_formatted_file(\n+                &mut writer,\n+                FormattedFile {\n+                    filename: &FileName::Real(PathBuf::from(bin_file)),\n+                    original_text: &bin_original.join(\"\\n\"),\n+                    formatted_text: &bin_formatted.join(\"\\n\"),\n+                },\n+            )\n+            .unwrap();\n+        let _ = emitter\n+            .emit_formatted_file(\n+                &mut writer,\n+                FormattedFile {\n+                    filename: &FileName::Real(PathBuf::from(lib_file)),\n+                    original_text: &lib_original.join(\"\\n\"),\n+                    formatted_text: &lib_formatted.join(\"\\n\"),\n+                },\n+            )\n+            .unwrap();\n+        let _ = emitter.emit_footer(&mut writer);\n+        let exp_bin_json = to_json_string(&MismatchedFile {\n+            name: String::from(bin_file),\n+            mismatches: vec![MismatchedBlock {\n+                original_begin_line: 2,\n+                original_end_line: 2,\n+                expected_begin_line: 2,\n+                expected_end_line: 2,\n+                original: String::from(\"println!(\\\"Hello, world!\\\");\"),\n+                expected: String::from(\"    println!(\\\"Hello, world!\\\");\"),\n+            }],\n+        })\n+        .unwrap();\n+        let exp_lib_json = to_json_string(&MismatchedFile {\n+            name: String::from(lib_file),\n+            mismatches: vec![MismatchedBlock {\n+                original_begin_line: 2,\n+                original_end_line: 2,\n+                expected_begin_line: 2,\n+                expected_end_line: 2,\n+                original: String::from(\"println!(\\\"Greetings!\\\");\"),\n+                expected: String::from(\"    println!(\\\"Greetings!\\\");\"),\n+            }],\n+        })\n+        .unwrap();\n+        assert_eq!(\n+            &writer[..],\n+            format!(\"[{},{}]\", exp_bin_json, exp_lib_json).as_bytes()\n+        );\n+    }\n+}"}, {"sha": "94ff570a8a9cb2d3a1ae59f01bc59d08827e3cd3", "filename": "src/tools/rustfmt/src/emitter/modified_lines.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Fsrc%2Femitter%2Fmodified_lines.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Fsrc%2Femitter%2Fmodified_lines.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fsrc%2Femitter%2Fmodified_lines.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782", "patch": "@@ -0,0 +1,24 @@\n+use super::*;\n+use crate::rustfmt_diff::{make_diff, ModifiedLines};\n+use std::io::Write;\n+\n+#[derive(Debug, Default)]\n+pub(crate) struct ModifiedLinesEmitter;\n+\n+impl Emitter for ModifiedLinesEmitter {\n+    fn emit_formatted_file(\n+        &mut self,\n+        output: &mut dyn Write,\n+        FormattedFile {\n+            original_text,\n+            formatted_text,\n+            ..\n+        }: FormattedFile<'_>,\n+    ) -> Result<EmitterResult, io::Error> {\n+        const CONTEXT_SIZE: usize = 0;\n+        let mismatch = make_diff(original_text, formatted_text, CONTEXT_SIZE);\n+        let has_diff = !mismatch.is_empty();\n+        write!(output, \"{}\", ModifiedLines::from(mismatch))?;\n+        Ok(EmitterResult { has_diff })\n+    }\n+}"}, {"sha": "9fddd515e49218d061c36dffb4921076368b372c", "filename": "src/tools/rustfmt/src/emitter/stdout.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Fsrc%2Femitter%2Fstdout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Fsrc%2Femitter%2Fstdout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fsrc%2Femitter%2Fstdout.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782", "patch": "@@ -0,0 +1,32 @@\n+use super::*;\n+use crate::config::Verbosity;\n+use std::io::Write;\n+\n+#[derive(Debug)]\n+pub(crate) struct StdoutEmitter {\n+    verbosity: Verbosity,\n+}\n+\n+impl StdoutEmitter {\n+    pub(crate) fn new(verbosity: Verbosity) -> Self {\n+        Self { verbosity }\n+    }\n+}\n+\n+impl Emitter for StdoutEmitter {\n+    fn emit_formatted_file(\n+        &mut self,\n+        output: &mut dyn Write,\n+        FormattedFile {\n+            filename,\n+            formatted_text,\n+            ..\n+        }: FormattedFile<'_>,\n+    ) -> Result<EmitterResult, io::Error> {\n+        if self.verbosity != Verbosity::Quiet {\n+            writeln!(output, \"{}:\\n\", filename)?;\n+        }\n+        write!(output, \"{}\", formatted_text)?;\n+        Ok(EmitterResult::default())\n+    }\n+}"}, {"sha": "ced382c4915a1b056e6a43d7a559ba6f4f40d4e6", "filename": "src/tools/rustfmt/src/expr.rs", "status": "added", "additions": 2076, "deletions": 0, "changes": 2076, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fsrc%2Fexpr.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782", "patch": "@@ -0,0 +1,2076 @@\n+use std::borrow::Cow;\n+use std::cmp::min;\n+\n+use itertools::Itertools;\n+use rustc_ast::token::{DelimToken, LitKind};\n+use rustc_ast::{ast, ptr};\n+use rustc_span::{BytePos, Span};\n+\n+use crate::chains::rewrite_chain;\n+use crate::closures;\n+use crate::comment::{\n+    combine_strs_with_missing_comments, contains_comment, recover_comment_removed, rewrite_comment,\n+    rewrite_missing_comment, CharClasses, FindUncommented,\n+};\n+use crate::config::lists::*;\n+use crate::config::{Config, ControlBraceStyle, IndentStyle, Version};\n+use crate::lists::{\n+    definitive_tactic, itemize_list, shape_for_tactic, struct_lit_formatting, struct_lit_shape,\n+    struct_lit_tactic, write_list, ListFormatting, Separator,\n+};\n+use crate::macros::{rewrite_macro, MacroPosition};\n+use crate::matches::rewrite_match;\n+use crate::overflow::{self, IntoOverflowableItem, OverflowableItem};\n+use crate::pairs::{rewrite_all_pairs, rewrite_pair, PairParts};\n+use crate::rewrite::{Rewrite, RewriteContext};\n+use crate::shape::{Indent, Shape};\n+use crate::source_map::{LineRangeUtils, SpanUtils};\n+use crate::spanned::Spanned;\n+use crate::string::{rewrite_string, StringFormat};\n+use crate::types::{rewrite_path, PathContext};\n+use crate::utils::{\n+    colon_spaces, contains_skip, count_newlines, first_line_ends_with, inner_attributes,\n+    last_line_extendable, last_line_width, mk_sp, outer_attributes, semicolon_for_expr,\n+    unicode_str_width, wrap_str,\n+};\n+use crate::vertical::rewrite_with_alignment;\n+use crate::visitor::FmtVisitor;\n+\n+impl Rewrite for ast::Expr {\n+    fn rewrite(&self, context: &RewriteContext<'_>, shape: Shape) -> Option<String> {\n+        format_expr(self, ExprType::SubExpression, context, shape)\n+    }\n+}\n+\n+#[derive(Copy, Clone, PartialEq)]\n+pub(crate) enum ExprType {\n+    Statement,\n+    SubExpression,\n+}\n+\n+pub(crate) fn format_expr(\n+    expr: &ast::Expr,\n+    expr_type: ExprType,\n+    context: &RewriteContext<'_>,\n+    shape: Shape,\n+) -> Option<String> {\n+    skip_out_of_file_lines_range!(context, expr.span);\n+\n+    if contains_skip(&*expr.attrs) {\n+        return Some(context.snippet(expr.span()).to_owned());\n+    }\n+    let shape = if expr_type == ExprType::Statement && semicolon_for_expr(context, expr) {\n+        shape.sub_width(1)?\n+    } else {\n+        shape\n+    };\n+\n+    let expr_rw = match expr.kind {\n+        ast::ExprKind::Array(ref expr_vec) => rewrite_array(\n+            \"\",\n+            expr_vec.iter(),\n+            expr.span,\n+            context,\n+            shape,\n+            choose_separator_tactic(context, expr.span),\n+            None,\n+        ),\n+        ast::ExprKind::Lit(ref l) => {\n+            if let Some(expr_rw) = rewrite_literal(context, l, shape) {\n+                Some(expr_rw)\n+            } else {\n+                if let LitKind::StrRaw(_) = l.token.kind {\n+                    Some(context.snippet(l.span).trim().into())\n+                } else {\n+                    None\n+                }\n+            }\n+        }\n+        ast::ExprKind::Call(ref callee, ref args) => {\n+            let inner_span = mk_sp(callee.span.hi(), expr.span.hi());\n+            let callee_str = callee.rewrite(context, shape)?;\n+            rewrite_call(context, &callee_str, args, inner_span, shape)\n+        }\n+        ast::ExprKind::Paren(ref subexpr) => rewrite_paren(context, subexpr, shape, expr.span),\n+        ast::ExprKind::Binary(op, ref lhs, ref rhs) => {\n+            // FIXME: format comments between operands and operator\n+            rewrite_all_pairs(expr, shape, context).or_else(|| {\n+                rewrite_pair(\n+                    &**lhs,\n+                    &**rhs,\n+                    PairParts::infix(&format!(\" {} \", context.snippet(op.span))),\n+                    context,\n+                    shape,\n+                    context.config.binop_separator(),\n+                )\n+            })\n+        }\n+        ast::ExprKind::Unary(op, ref subexpr) => rewrite_unary_op(context, op, subexpr, shape),\n+        ast::ExprKind::Struct(ref struct_expr) => {\n+            let ast::StructExpr { fields, path, rest } = &**struct_expr;\n+            rewrite_struct_lit(context, path, fields, rest, &expr.attrs, expr.span, shape)\n+        }\n+        ast::ExprKind::Tup(ref items) => {\n+            rewrite_tuple(context, items.iter(), expr.span, shape, items.len() == 1)\n+        }\n+        ast::ExprKind::Let(..) => None,\n+        ast::ExprKind::If(..)\n+        | ast::ExprKind::ForLoop(..)\n+        | ast::ExprKind::Loop(..)\n+        | ast::ExprKind::While(..) => to_control_flow(expr, expr_type)\n+            .and_then(|control_flow| control_flow.rewrite(context, shape)),\n+        ast::ExprKind::ConstBlock(ref anon_const) => {\n+            Some(format!(\"const {}\", anon_const.rewrite(context, shape)?))\n+        }\n+        ast::ExprKind::Block(ref block, opt_label) => {\n+            match expr_type {\n+                ExprType::Statement => {\n+                    if is_unsafe_block(block) {\n+                        rewrite_block(block, Some(&expr.attrs), opt_label, context, shape)\n+                    } else if let rw @ Some(_) =\n+                        rewrite_empty_block(context, block, Some(&expr.attrs), opt_label, \"\", shape)\n+                    {\n+                        // Rewrite block without trying to put it in a single line.\n+                        rw\n+                    } else {\n+                        let prefix = block_prefix(context, block, shape)?;\n+\n+                        rewrite_block_with_visitor(\n+                            context,\n+                            &prefix,\n+                            block,\n+                            Some(&expr.attrs),\n+                            opt_label,\n+                            shape,\n+                            true,\n+                        )\n+                    }\n+                }\n+                ExprType::SubExpression => {\n+                    rewrite_block(block, Some(&expr.attrs), opt_label, context, shape)\n+                }\n+            }\n+        }\n+        ast::ExprKind::Match(ref cond, ref arms) => {\n+            rewrite_match(context, cond, arms, shape, expr.span, &expr.attrs)\n+        }\n+        ast::ExprKind::Path(ref qself, ref path) => {\n+            rewrite_path(context, PathContext::Expr, qself.as_ref(), path, shape)\n+        }\n+        ast::ExprKind::Assign(ref lhs, ref rhs, _) => {\n+            rewrite_assignment(context, lhs, rhs, None, shape)\n+        }\n+        ast::ExprKind::AssignOp(ref op, ref lhs, ref rhs) => {\n+            rewrite_assignment(context, lhs, rhs, Some(op), shape)\n+        }\n+        ast::ExprKind::Continue(ref opt_label) => {\n+            let id_str = match *opt_label {\n+                Some(label) => format!(\" {}\", label.ident),\n+                None => String::new(),\n+            };\n+            Some(format!(\"continue{}\", id_str))\n+        }\n+        ast::ExprKind::Break(ref opt_label, ref opt_expr) => {\n+            let id_str = match *opt_label {\n+                Some(label) => format!(\" {}\", label.ident),\n+                None => String::new(),\n+            };\n+\n+            if let Some(ref expr) = *opt_expr {\n+                rewrite_unary_prefix(context, &format!(\"break{} \", id_str), &**expr, shape)\n+            } else {\n+                Some(format!(\"break{}\", id_str))\n+            }\n+        }\n+        ast::ExprKind::Yield(ref opt_expr) => {\n+            if let Some(ref expr) = *opt_expr {\n+                rewrite_unary_prefix(context, \"yield \", &**expr, shape)\n+            } else {\n+                Some(\"yield\".to_string())\n+            }\n+        }\n+        ast::ExprKind::Closure(capture, ref is_async, movability, ref fn_decl, ref body, _) => {\n+            closures::rewrite_closure(\n+                capture, is_async, movability, fn_decl, body, expr.span, context, shape,\n+            )\n+        }\n+        ast::ExprKind::Try(..) | ast::ExprKind::Field(..) | ast::ExprKind::MethodCall(..) => {\n+            rewrite_chain(expr, context, shape)\n+        }\n+        ast::ExprKind::MacCall(ref mac) => {\n+            rewrite_macro(mac, None, context, shape, MacroPosition::Expression).or_else(|| {\n+                wrap_str(\n+                    context.snippet(expr.span).to_owned(),\n+                    context.config.max_width(),\n+                    shape,\n+                )\n+            })\n+        }\n+        ast::ExprKind::Ret(None) => Some(\"return\".to_owned()),\n+        ast::ExprKind::Ret(Some(ref expr)) => {\n+            rewrite_unary_prefix(context, \"return \", &**expr, shape)\n+        }\n+        ast::ExprKind::Box(ref expr) => rewrite_unary_prefix(context, \"box \", &**expr, shape),\n+        ast::ExprKind::AddrOf(borrow_kind, mutability, ref expr) => {\n+            rewrite_expr_addrof(context, borrow_kind, mutability, expr, shape)\n+        }\n+        ast::ExprKind::Cast(ref expr, ref ty) => rewrite_pair(\n+            &**expr,\n+            &**ty,\n+            PairParts::infix(\" as \"),\n+            context,\n+            shape,\n+            SeparatorPlace::Front,\n+        ),\n+        ast::ExprKind::Type(ref expr, ref ty) => rewrite_pair(\n+            &**expr,\n+            &**ty,\n+            PairParts::infix(\": \"),\n+            context,\n+            shape,\n+            SeparatorPlace::Back,\n+        ),\n+        ast::ExprKind::Index(ref expr, ref index) => {\n+            rewrite_index(&**expr, &**index, context, shape)\n+        }\n+        ast::ExprKind::Repeat(ref expr, ref repeats) => rewrite_pair(\n+            &**expr,\n+            &*repeats.value,\n+            PairParts::new(\"[\", \"; \", \"]\"),\n+            context,\n+            shape,\n+            SeparatorPlace::Back,\n+        ),\n+        ast::ExprKind::Range(ref lhs, ref rhs, limits) => {\n+            let delim = match limits {\n+                ast::RangeLimits::HalfOpen => \"..\",\n+                ast::RangeLimits::Closed => \"..=\",\n+            };\n+\n+            fn needs_space_before_range(context: &RewriteContext<'_>, lhs: &ast::Expr) -> bool {\n+                match lhs.kind {\n+                    ast::ExprKind::Lit(ref lit) => match lit.kind {\n+                        ast::LitKind::Float(_, ast::LitFloatType::Unsuffixed) => {\n+                            context.snippet(lit.span).ends_with('.')\n+                        }\n+                        _ => false,\n+                    },\n+                    ast::ExprKind::Unary(_, ref expr) => needs_space_before_range(context, &expr),\n+                    _ => false,\n+                }\n+            }\n+\n+            fn needs_space_after_range(rhs: &ast::Expr) -> bool {\n+                match rhs.kind {\n+                    // Don't format `.. ..` into `....`, which is invalid.\n+                    //\n+                    // This check is unnecessary for `lhs`, because a range\n+                    // starting from another range needs parentheses as `(x ..) ..`\n+                    // (`x .. ..` is a range from `x` to `..`).\n+                    ast::ExprKind::Range(None, _, _) => true,\n+                    _ => false,\n+                }\n+            }\n+\n+            let default_sp_delim = |lhs: Option<&ast::Expr>, rhs: Option<&ast::Expr>| {\n+                let space_if = |b: bool| if b { \" \" } else { \"\" };\n+\n+                format!(\n+                    \"{}{}{}\",\n+                    lhs.map_or(\"\", |lhs| space_if(needs_space_before_range(context, lhs))),\n+                    delim,\n+                    rhs.map_or(\"\", |rhs| space_if(needs_space_after_range(rhs))),\n+                )\n+            };\n+\n+            match (lhs.as_ref().map(|x| &**x), rhs.as_ref().map(|x| &**x)) {\n+                (Some(lhs), Some(rhs)) => {\n+                    let sp_delim = if context.config.spaces_around_ranges() {\n+                        format!(\" {} \", delim)\n+                    } else {\n+                        default_sp_delim(Some(lhs), Some(rhs))\n+                    };\n+                    rewrite_pair(\n+                        &*lhs,\n+                        &*rhs,\n+                        PairParts::infix(&sp_delim),\n+                        context,\n+                        shape,\n+                        context.config.binop_separator(),\n+                    )\n+                }\n+                (None, Some(rhs)) => {\n+                    let sp_delim = if context.config.spaces_around_ranges() {\n+                        format!(\"{} \", delim)\n+                    } else {\n+                        default_sp_delim(None, Some(rhs))\n+                    };\n+                    rewrite_unary_prefix(context, &sp_delim, &*rhs, shape)\n+                }\n+                (Some(lhs), None) => {\n+                    let sp_delim = if context.config.spaces_around_ranges() {\n+                        format!(\" {}\", delim)\n+                    } else {\n+                        default_sp_delim(Some(lhs), None)\n+                    };\n+                    rewrite_unary_suffix(context, &sp_delim, &*lhs, shape)\n+                }\n+                (None, None) => Some(delim.to_owned()),\n+            }\n+        }\n+        // We do not format these expressions yet, but they should still\n+        // satisfy our width restrictions.\n+        // Style Guide RFC for InlineAsm variant pending\n+        // https://github.com/rust-dev-tools/fmt-rfcs/issues/152\n+        ast::ExprKind::LlvmInlineAsm(..) | ast::ExprKind::InlineAsm(..) => {\n+            Some(context.snippet(expr.span).to_owned())\n+        }\n+        ast::ExprKind::TryBlock(ref block) => {\n+            if let rw @ Some(_) =\n+                rewrite_single_line_block(context, \"try \", block, Some(&expr.attrs), None, shape)\n+            {\n+                rw\n+            } else {\n+                // 9 = `try `\n+                let budget = shape.width.saturating_sub(9);\n+                Some(format!(\n+                    \"{}{}\",\n+                    \"try \",\n+                    rewrite_block(\n+                        block,\n+                        Some(&expr.attrs),\n+                        None,\n+                        context,\n+                        Shape::legacy(budget, shape.indent)\n+                    )?\n+                ))\n+            }\n+        }\n+        ast::ExprKind::Async(capture_by, _node_id, ref block) => {\n+            let mover = if capture_by == ast::CaptureBy::Value {\n+                \"move \"\n+            } else {\n+                \"\"\n+            };\n+            if let rw @ Some(_) = rewrite_single_line_block(\n+                context,\n+                format!(\"{}{}\", \"async \", mover).as_str(),\n+                block,\n+                Some(&expr.attrs),\n+                None,\n+                shape,\n+            ) {\n+                rw\n+            } else {\n+                // 6 = `async `\n+                let budget = shape.width.saturating_sub(6);\n+                Some(format!(\n+                    \"{}{}{}\",\n+                    \"async \",\n+                    mover,\n+                    rewrite_block(\n+                        block,\n+                        Some(&expr.attrs),\n+                        None,\n+                        context,\n+                        Shape::legacy(budget, shape.indent)\n+                    )?\n+                ))\n+            }\n+        }\n+        ast::ExprKind::Await(_) => rewrite_chain(expr, context, shape),\n+        ast::ExprKind::Underscore => Some(\"_\".to_owned()),\n+        ast::ExprKind::Err => None,\n+    };\n+\n+    expr_rw\n+        .and_then(|expr_str| recover_comment_removed(expr_str, expr.span, context))\n+        .and_then(|expr_str| {\n+            let attrs = outer_attributes(&expr.attrs);\n+            let attrs_str = attrs.rewrite(context, shape)?;\n+            let span = mk_sp(\n+                attrs.last().map_or(expr.span.lo(), |attr| attr.span.hi()),\n+                expr.span.lo(),\n+            );\n+            combine_strs_with_missing_comments(context, &attrs_str, &expr_str, span, shape, false)\n+        })\n+}\n+\n+pub(crate) fn rewrite_array<'a, T: 'a + IntoOverflowableItem<'a>>(\n+    name: &'a str,\n+    exprs: impl Iterator<Item = &'a T>,\n+    span: Span,\n+    context: &'a RewriteContext<'_>,\n+    shape: Shape,\n+    force_separator_tactic: Option<SeparatorTactic>,\n+    delim_token: Option<DelimToken>,\n+) -> Option<String> {\n+    overflow::rewrite_with_square_brackets(\n+        context,\n+        name,\n+        exprs,\n+        shape,\n+        span,\n+        force_separator_tactic,\n+        delim_token,\n+    )\n+}\n+\n+fn rewrite_empty_block(\n+    context: &RewriteContext<'_>,\n+    block: &ast::Block,\n+    attrs: Option<&[ast::Attribute]>,\n+    label: Option<ast::Label>,\n+    prefix: &str,\n+    shape: Shape,\n+) -> Option<String> {\n+    if block_has_statements(&block) {\n+        return None;\n+    }\n+\n+    let label_str = rewrite_label(label);\n+    if attrs.map_or(false, |a| !inner_attributes(a).is_empty()) {\n+        return None;\n+    }\n+\n+    if !block_contains_comment(context, block) && shape.width >= 2 {\n+        return Some(format!(\"{}{}{{}}\", prefix, label_str));\n+    }\n+\n+    // If a block contains only a single-line comment, then leave it on one line.\n+    let user_str = context.snippet(block.span);\n+    let user_str = user_str.trim();\n+    if user_str.starts_with('{') && user_str.ends_with('}') {\n+        let comment_str = user_str[1..user_str.len() - 1].trim();\n+        if block.stmts.is_empty()\n+            && !comment_str.contains('\\n')\n+            && !comment_str.starts_with(\"//\")\n+            && comment_str.len() + 4 <= shape.width\n+        {\n+            return Some(format!(\"{}{}{{ {} }}\", prefix, label_str, comment_str));\n+        }\n+    }\n+\n+    None\n+}\n+\n+fn block_prefix(context: &RewriteContext<'_>, block: &ast::Block, shape: Shape) -> Option<String> {\n+    Some(match block.rules {\n+        ast::BlockCheckMode::Unsafe(..) => {\n+            let snippet = context.snippet(block.span);\n+            let open_pos = snippet.find_uncommented(\"{\")?;\n+            // Extract comment between unsafe and block start.\n+            let trimmed = &snippet[6..open_pos].trim();\n+\n+            if !trimmed.is_empty() {\n+                // 9 = \"unsafe  {\".len(), 7 = \"unsafe \".len()\n+                let budget = shape.width.checked_sub(9)?;\n+                format!(\n+                    \"unsafe {} \",\n+                    rewrite_comment(\n+                        trimmed,\n+                        true,\n+                        Shape::legacy(budget, shape.indent + 7),\n+                        context.config,\n+                    )?\n+                )\n+            } else {\n+                \"unsafe \".to_owned()\n+            }\n+        }\n+        ast::BlockCheckMode::Default => String::new(),\n+    })\n+}\n+\n+fn rewrite_single_line_block(\n+    context: &RewriteContext<'_>,\n+    prefix: &str,\n+    block: &ast::Block,\n+    attrs: Option<&[ast::Attribute]>,\n+    label: Option<ast::Label>,\n+    shape: Shape,\n+) -> Option<String> {\n+    if is_simple_block(context, block, attrs) {\n+        let expr_shape = shape.offset_left(last_line_width(prefix))?;\n+        let expr_str = block.stmts[0].rewrite(context, expr_shape)?;\n+        let label_str = rewrite_label(label);\n+        let result = format!(\"{}{}{{ {} }}\", prefix, label_str, expr_str);\n+        if result.len() <= shape.width && !result.contains('\\n') {\n+            return Some(result);\n+        }\n+    }\n+    None\n+}\n+\n+pub(crate) fn rewrite_block_with_visitor(\n+    context: &RewriteContext<'_>,\n+    prefix: &str,\n+    block: &ast::Block,\n+    attrs: Option<&[ast::Attribute]>,\n+    label: Option<ast::Label>,\n+    shape: Shape,\n+    has_braces: bool,\n+) -> Option<String> {\n+    if let rw @ Some(_) = rewrite_empty_block(context, block, attrs, label, prefix, shape) {\n+        return rw;\n+    }\n+\n+    let mut visitor = FmtVisitor::from_context(context);\n+    visitor.block_indent = shape.indent;\n+    visitor.is_if_else_block = context.is_if_else_block();\n+    match (block.rules, label) {\n+        (ast::BlockCheckMode::Unsafe(..), _) | (ast::BlockCheckMode::Default, Some(_)) => {\n+            let snippet = context.snippet(block.span);\n+            let open_pos = snippet.find_uncommented(\"{\")?;\n+            visitor.last_pos = block.span.lo() + BytePos(open_pos as u32)\n+        }\n+        (ast::BlockCheckMode::Default, None) => visitor.last_pos = block.span.lo(),\n+    }\n+\n+    let inner_attrs = attrs.map(inner_attributes);\n+    let label_str = rewrite_label(label);\n+    visitor.visit_block(block, inner_attrs.as_ref().map(|a| &**a), has_braces);\n+    let visitor_context = visitor.get_context();\n+    context\n+        .skipped_range\n+        .borrow_mut()\n+        .append(&mut visitor_context.skipped_range.borrow_mut());\n+    Some(format!(\"{}{}{}\", prefix, label_str, visitor.buffer))\n+}\n+\n+impl Rewrite for ast::Block {\n+    fn rewrite(&self, context: &RewriteContext<'_>, shape: Shape) -> Option<String> {\n+        rewrite_block(self, None, None, context, shape)\n+    }\n+}\n+\n+fn rewrite_block(\n+    block: &ast::Block,\n+    attrs: Option<&[ast::Attribute]>,\n+    label: Option<ast::Label>,\n+    context: &RewriteContext<'_>,\n+    shape: Shape,\n+) -> Option<String> {\n+    let prefix = block_prefix(context, block, shape)?;\n+\n+    // shape.width is used only for the single line case: either the empty block `{}`,\n+    // or an unsafe expression `unsafe { e }`.\n+    if let rw @ Some(_) = rewrite_empty_block(context, block, attrs, label, &prefix, shape) {\n+        return rw;\n+    }\n+\n+    let result = rewrite_block_with_visitor(context, &prefix, block, attrs, label, shape, true);\n+    if let Some(ref result_str) = result {\n+        if result_str.lines().count() <= 3 {\n+            if let rw @ Some(_) =\n+                rewrite_single_line_block(context, &prefix, block, attrs, label, shape)\n+            {\n+                return rw;\n+            }\n+        }\n+    }\n+\n+    result\n+}\n+\n+// Rewrite condition if the given expression has one.\n+pub(crate) fn rewrite_cond(\n+    context: &RewriteContext<'_>,\n+    expr: &ast::Expr,\n+    shape: Shape,\n+) -> Option<String> {\n+    match expr.kind {\n+        ast::ExprKind::Match(ref cond, _) => {\n+            // `match `cond` {`\n+            let cond_shape = match context.config.indent_style() {\n+                IndentStyle::Visual => shape.shrink_left(6).and_then(|s| s.sub_width(2))?,\n+                IndentStyle::Block => shape.offset_left(8)?,\n+            };\n+            cond.rewrite(context, cond_shape)\n+        }\n+        _ => to_control_flow(expr, ExprType::SubExpression).and_then(|control_flow| {\n+            let alt_block_sep =\n+                String::from(\"\\n\") + &shape.indent.block_only().to_string(context.config);\n+            control_flow\n+                .rewrite_cond(context, shape, &alt_block_sep)\n+                .and_then(|rw| Some(rw.0))\n+        }),\n+    }\n+}\n+\n+// Abstraction over control flow expressions\n+#[derive(Debug)]\n+struct ControlFlow<'a> {\n+    cond: Option<&'a ast::Expr>,\n+    block: &'a ast::Block,\n+    else_block: Option<&'a ast::Expr>,\n+    label: Option<ast::Label>,\n+    pat: Option<&'a ast::Pat>,\n+    keyword: &'a str,\n+    matcher: &'a str,\n+    connector: &'a str,\n+    allow_single_line: bool,\n+    // HACK: `true` if this is an `if` expression in an `else if`.\n+    nested_if: bool,\n+    span: Span,\n+}\n+\n+fn extract_pats_and_cond(expr: &ast::Expr) -> (Option<&ast::Pat>, &ast::Expr) {\n+    match expr.kind {\n+        ast::ExprKind::Let(ref pat, ref cond) => (Some(pat), cond),\n+        _ => (None, expr),\n+    }\n+}\n+\n+// FIXME: Refactor this.\n+fn to_control_flow(expr: &ast::Expr, expr_type: ExprType) -> Option<ControlFlow<'_>> {\n+    match expr.kind {\n+        ast::ExprKind::If(ref cond, ref if_block, ref else_block) => {\n+            let (pat, cond) = extract_pats_and_cond(cond);\n+            Some(ControlFlow::new_if(\n+                cond,\n+                pat,\n+                if_block,\n+                else_block.as_ref().map(|e| &**e),\n+                expr_type == ExprType::SubExpression,\n+                false,\n+                expr.span,\n+            ))\n+        }\n+        ast::ExprKind::ForLoop(ref pat, ref cond, ref block, label) => {\n+            Some(ControlFlow::new_for(pat, cond, block, label, expr.span))\n+        }\n+        ast::ExprKind::Loop(ref block, label) => {\n+            Some(ControlFlow::new_loop(block, label, expr.span))\n+        }\n+        ast::ExprKind::While(ref cond, ref block, label) => {\n+            let (pat, cond) = extract_pats_and_cond(cond);\n+            Some(ControlFlow::new_while(pat, cond, block, label, expr.span))\n+        }\n+        _ => None,\n+    }\n+}\n+\n+fn choose_matcher(pat: Option<&ast::Pat>) -> &'static str {\n+    pat.map_or(\"\", |_| \"let\")\n+}\n+\n+impl<'a> ControlFlow<'a> {\n+    fn new_if(\n+        cond: &'a ast::Expr,\n+        pat: Option<&'a ast::Pat>,\n+        block: &'a ast::Block,\n+        else_block: Option<&'a ast::Expr>,\n+        allow_single_line: bool,\n+        nested_if: bool,\n+        span: Span,\n+    ) -> ControlFlow<'a> {\n+        let matcher = choose_matcher(pat);\n+        ControlFlow {\n+            cond: Some(cond),\n+            block,\n+            else_block,\n+            label: None,\n+            pat,\n+            keyword: \"if\",\n+            matcher,\n+            connector: \" =\",\n+            allow_single_line,\n+            nested_if,\n+            span,\n+        }\n+    }\n+\n+    fn new_loop(block: &'a ast::Block, label: Option<ast::Label>, span: Span) -> ControlFlow<'a> {\n+        ControlFlow {\n+            cond: None,\n+            block,\n+            else_block: None,\n+            label,\n+            pat: None,\n+            keyword: \"loop\",\n+            matcher: \"\",\n+            connector: \"\",\n+            allow_single_line: false,\n+            nested_if: false,\n+            span,\n+        }\n+    }\n+\n+    fn new_while(\n+        pat: Option<&'a ast::Pat>,\n+        cond: &'a ast::Expr,\n+        block: &'a ast::Block,\n+        label: Option<ast::Label>,\n+        span: Span,\n+    ) -> ControlFlow<'a> {\n+        let matcher = choose_matcher(pat);\n+        ControlFlow {\n+            cond: Some(cond),\n+            block,\n+            else_block: None,\n+            label,\n+            pat,\n+            keyword: \"while\",\n+            matcher,\n+            connector: \" =\",\n+            allow_single_line: false,\n+            nested_if: false,\n+            span,\n+        }\n+    }\n+\n+    fn new_for(\n+        pat: &'a ast::Pat,\n+        cond: &'a ast::Expr,\n+        block: &'a ast::Block,\n+        label: Option<ast::Label>,\n+        span: Span,\n+    ) -> ControlFlow<'a> {\n+        ControlFlow {\n+            cond: Some(cond),\n+            block,\n+            else_block: None,\n+            label,\n+            pat: Some(pat),\n+            keyword: \"for\",\n+            matcher: \"\",\n+            connector: \" in\",\n+            allow_single_line: false,\n+            nested_if: false,\n+            span,\n+        }\n+    }\n+\n+    fn rewrite_single_line(\n+        &self,\n+        pat_expr_str: &str,\n+        context: &RewriteContext<'_>,\n+        width: usize,\n+    ) -> Option<String> {\n+        assert!(self.allow_single_line);\n+        let else_block = self.else_block?;\n+        let fixed_cost = self.keyword.len() + \"  {  } else {  }\".len();\n+\n+        if let ast::ExprKind::Block(ref else_node, _) = else_block.kind {\n+            if !is_simple_block(context, self.block, None)\n+                || !is_simple_block(context, else_node, None)\n+                || pat_expr_str.contains('\\n')\n+            {\n+                return None;\n+            }\n+\n+            let new_width = width.checked_sub(pat_expr_str.len() + fixed_cost)?;\n+            let expr = &self.block.stmts[0];\n+            let if_str = expr.rewrite(context, Shape::legacy(new_width, Indent::empty()))?;\n+\n+            let new_width = new_width.checked_sub(if_str.len())?;\n+            let else_expr = &else_node.stmts[0];\n+            let else_str = else_expr.rewrite(context, Shape::legacy(new_width, Indent::empty()))?;\n+\n+            if if_str.contains('\\n') || else_str.contains('\\n') {\n+                return None;\n+            }\n+\n+            let result = format!(\n+                \"{} {} {{ {} }} else {{ {} }}\",\n+                self.keyword, pat_expr_str, if_str, else_str\n+            );\n+\n+            if result.len() <= width {\n+                return Some(result);\n+            }\n+        }\n+\n+        None\n+    }\n+}\n+\n+/// Returns `true` if the last line of pat_str has leading whitespace and it is wider than the\n+/// shape's indent.\n+fn last_line_offsetted(start_column: usize, pat_str: &str) -> bool {\n+    let mut leading_whitespaces = 0;\n+    for c in pat_str.chars().rev() {\n+        match c {\n+            '\\n' => break,\n+            _ if c.is_whitespace() => leading_whitespaces += 1,\n+            _ => leading_whitespaces = 0,\n+        }\n+    }\n+    leading_whitespaces > start_column\n+}\n+\n+impl<'a> ControlFlow<'a> {\n+    fn rewrite_pat_expr(\n+        &self,\n+        context: &RewriteContext<'_>,\n+        expr: &ast::Expr,\n+        shape: Shape,\n+        offset: usize,\n+    ) -> Option<String> {\n+        debug!(\"rewrite_pat_expr {:?} {:?} {:?}\", shape, self.pat, expr);\n+\n+        let cond_shape = shape.offset_left(offset)?;\n+        if let Some(pat) = self.pat {\n+            let matcher = if self.matcher.is_empty() {\n+                self.matcher.to_owned()\n+            } else {\n+                format!(\"{} \", self.matcher)\n+            };\n+            let pat_shape = cond_shape\n+                .offset_left(matcher.len())?\n+                .sub_width(self.connector.len())?;\n+            let pat_string = pat.rewrite(context, pat_shape)?;\n+            let comments_lo = context\n+                .snippet_provider\n+                .span_after(self.span, self.connector.trim());\n+            let comments_span = mk_sp(comments_lo, expr.span.lo());\n+            return rewrite_assign_rhs_with_comments(\n+                context,\n+                &format!(\"{}{}{}\", matcher, pat_string, self.connector),\n+                expr,\n+                cond_shape,\n+                RhsTactics::Default,\n+                comments_span,\n+                true,\n+            );\n+        }\n+\n+        let expr_rw = expr.rewrite(context, cond_shape);\n+        // The expression may (partially) fit on the current line.\n+        // We do not allow splitting between `if` and condition.\n+        if self.keyword == \"if\" || expr_rw.is_some() {\n+            return expr_rw;\n+        }\n+\n+        // The expression won't fit on the current line, jump to next.\n+        let nested_shape = shape\n+            .block_indent(context.config.tab_spaces())\n+            .with_max_width(context.config);\n+        let nested_indent_str = nested_shape.indent.to_string_with_newline(context.config);\n+        expr.rewrite(context, nested_shape)\n+            .map(|expr_rw| format!(\"{}{}\", nested_indent_str, expr_rw))\n+    }\n+\n+    fn rewrite_cond(\n+        &self,\n+        context: &RewriteContext<'_>,\n+        shape: Shape,\n+        alt_block_sep: &str,\n+    ) -> Option<(String, usize)> {\n+        // Do not take the rhs overhead from the upper expressions into account\n+        // when rewriting pattern.\n+        let new_width = context.budget(shape.used_width());\n+        let fresh_shape = Shape {\n+            width: new_width,\n+            ..shape\n+        };\n+        let constr_shape = if self.nested_if {\n+            // We are part of an if-elseif-else chain. Our constraints are tightened.\n+            // 7 = \"} else \" .len()\n+            fresh_shape.offset_left(7)?\n+        } else {\n+            fresh_shape\n+        };\n+\n+        let label_string = rewrite_label(self.label);\n+        // 1 = space after keyword.\n+        let offset = self.keyword.len() + label_string.len() + 1;\n+\n+        let pat_expr_string = match self.cond {\n+            Some(cond) => self.rewrite_pat_expr(context, cond, constr_shape, offset)?,\n+            None => String::new(),\n+        };\n+\n+        let brace_overhead =\n+            if context.config.control_brace_style() != ControlBraceStyle::AlwaysNextLine {\n+                // 2 = ` {`\n+                2\n+            } else {\n+                0\n+            };\n+        let one_line_budget = context\n+            .config\n+            .max_width()\n+            .saturating_sub(constr_shape.used_width() + offset + brace_overhead);\n+        let force_newline_brace = (pat_expr_string.contains('\\n')\n+            || pat_expr_string.len() > one_line_budget)\n+            && (!last_line_extendable(&pat_expr_string)\n+                || last_line_offsetted(shape.used_width(), &pat_expr_string));\n+\n+        // Try to format if-else on single line.\n+        if self.allow_single_line && context.config.single_line_if_else_max_width() > 0 {\n+            let trial = self.rewrite_single_line(&pat_expr_string, context, shape.width);\n+\n+            if let Some(cond_str) = trial {\n+                if cond_str.len() <= context.config.single_line_if_else_max_width() {\n+                    return Some((cond_str, 0));\n+                }\n+            }\n+        }\n+\n+        let cond_span = if let Some(cond) = self.cond {\n+            cond.span\n+        } else {\n+            mk_sp(self.block.span.lo(), self.block.span.lo())\n+        };\n+\n+        // `for event in event`\n+        // Do not include label in the span.\n+        let lo = self\n+            .label\n+            .map_or(self.span.lo(), |label| label.ident.span.hi());\n+        let between_kwd_cond = mk_sp(\n+            context\n+                .snippet_provider\n+                .span_after(mk_sp(lo, self.span.hi()), self.keyword.trim()),\n+            if self.pat.is_none() {\n+                cond_span.lo()\n+            } else if self.matcher.is_empty() {\n+                self.pat.unwrap().span.lo()\n+            } else {\n+                context\n+                    .snippet_provider\n+                    .span_before(self.span, self.matcher.trim())\n+            },\n+        );\n+\n+        let between_kwd_cond_comment = extract_comment(between_kwd_cond, context, shape);\n+\n+        let after_cond_comment =\n+            extract_comment(mk_sp(cond_span.hi(), self.block.span.lo()), context, shape);\n+\n+        let block_sep = if self.cond.is_none() && between_kwd_cond_comment.is_some() {\n+            \"\"\n+        } else if context.config.control_brace_style() == ControlBraceStyle::AlwaysNextLine\n+            || force_newline_brace\n+        {\n+            alt_block_sep\n+        } else {\n+            \" \"\n+        };\n+\n+        let used_width = if pat_expr_string.contains('\\n') {\n+            last_line_width(&pat_expr_string)\n+        } else {\n+            // 2 = spaces after keyword and condition.\n+            label_string.len() + self.keyword.len() + pat_expr_string.len() + 2\n+        };\n+\n+        Some((\n+            format!(\n+                \"{}{}{}{}{}\",\n+                label_string,\n+                self.keyword,\n+                between_kwd_cond_comment.as_ref().map_or(\n+                    if pat_expr_string.is_empty() || pat_expr_string.starts_with('\\n') {\n+                        \"\"\n+                    } else {\n+                        \" \"\n+                    },\n+                    |s| &**s,\n+                ),\n+                pat_expr_string,\n+                after_cond_comment.as_ref().map_or(block_sep, |s| &**s)\n+            ),\n+            used_width,\n+        ))\n+    }\n+}\n+\n+impl<'a> Rewrite for ControlFlow<'a> {\n+    fn rewrite(&self, context: &RewriteContext<'_>, shape: Shape) -> Option<String> {\n+        debug!(\"ControlFlow::rewrite {:?} {:?}\", self, shape);\n+\n+        let alt_block_sep = &shape.indent.to_string_with_newline(context.config);\n+        let (cond_str, used_width) = self.rewrite_cond(context, shape, alt_block_sep)?;\n+        // If `used_width` is 0, it indicates that whole control flow is written in a single line.\n+        if used_width == 0 {\n+            return Some(cond_str);\n+        }\n+\n+        let block_width = shape.width.saturating_sub(used_width);\n+        // This is used only for the empty block case: `{}`. So, we use 1 if we know\n+        // we should avoid the single line case.\n+        let block_width = if self.else_block.is_some() || self.nested_if {\n+            min(1, block_width)\n+        } else {\n+            block_width\n+        };\n+        let block_shape = Shape {\n+            width: block_width,\n+            ..shape\n+        };\n+        let block_str = {\n+            let old_val = context.is_if_else_block.replace(self.else_block.is_some());\n+            let result =\n+                rewrite_block_with_visitor(context, \"\", self.block, None, None, block_shape, true);\n+            context.is_if_else_block.replace(old_val);\n+            result?\n+        };\n+\n+        let mut result = format!(\"{}{}\", cond_str, block_str);\n+\n+        if let Some(else_block) = self.else_block {\n+            let shape = Shape::indented(shape.indent, context.config);\n+            let mut last_in_chain = false;\n+            let rewrite = match else_block.kind {\n+                // If the else expression is another if-else expression, prevent it\n+                // from being formatted on a single line.\n+                // Note how we're passing the original shape, as the\n+                // cost of \"else\" should not cascade.\n+                ast::ExprKind::If(ref cond, ref if_block, ref next_else_block) => {\n+                    let (pats, cond) = extract_pats_and_cond(cond);\n+                    ControlFlow::new_if(\n+                        cond,\n+                        pats,\n+                        if_block,\n+                        next_else_block.as_ref().map(|e| &**e),\n+                        false,\n+                        true,\n+                        mk_sp(else_block.span.lo(), self.span.hi()),\n+                    )\n+                    .rewrite(context, shape)\n+                }\n+                _ => {\n+                    last_in_chain = true;\n+                    // When rewriting a block, the width is only used for single line\n+                    // blocks, passing 1 lets us avoid that.\n+                    let else_shape = Shape {\n+                        width: min(1, shape.width),\n+                        ..shape\n+                    };\n+                    format_expr(else_block, ExprType::Statement, context, else_shape)\n+                }\n+            };\n+\n+            let between_kwd_else_block = mk_sp(\n+                self.block.span.hi(),\n+                context\n+                    .snippet_provider\n+                    .span_before(mk_sp(self.block.span.hi(), else_block.span.lo()), \"else\"),\n+            );\n+            let between_kwd_else_block_comment =\n+                extract_comment(between_kwd_else_block, context, shape);\n+\n+            let after_else = mk_sp(\n+                context\n+                    .snippet_provider\n+                    .span_after(mk_sp(self.block.span.hi(), else_block.span.lo()), \"else\"),\n+                else_block.span.lo(),\n+            );\n+            let after_else_comment = extract_comment(after_else, context, shape);\n+\n+            let between_sep = match context.config.control_brace_style() {\n+                ControlBraceStyle::AlwaysNextLine | ControlBraceStyle::ClosingNextLine => {\n+                    &*alt_block_sep\n+                }\n+                ControlBraceStyle::AlwaysSameLine => \" \",\n+            };\n+            let after_sep = match context.config.control_brace_style() {\n+                ControlBraceStyle::AlwaysNextLine if last_in_chain => &*alt_block_sep,\n+                _ => \" \",\n+            };\n+\n+            result.push_str(&format!(\n+                \"{}else{}\",\n+                between_kwd_else_block_comment\n+                    .as_ref()\n+                    .map_or(between_sep, |s| &**s),\n+                after_else_comment.as_ref().map_or(after_sep, |s| &**s),\n+            ));\n+            result.push_str(&rewrite?);\n+        }\n+\n+        Some(result)\n+    }\n+}\n+\n+fn rewrite_label(opt_label: Option<ast::Label>) -> Cow<'static, str> {\n+    match opt_label {\n+        Some(label) => Cow::from(format!(\"{}: \", label.ident)),\n+        None => Cow::from(\"\"),\n+    }\n+}\n+\n+fn extract_comment(span: Span, context: &RewriteContext<'_>, shape: Shape) -> Option<String> {\n+    match rewrite_missing_comment(span, shape, context) {\n+        Some(ref comment) if !comment.is_empty() => Some(format!(\n+            \"{indent}{}{indent}\",\n+            comment,\n+            indent = shape.indent.to_string_with_newline(context.config)\n+        )),\n+        _ => None,\n+    }\n+}\n+\n+pub(crate) fn block_contains_comment(context: &RewriteContext<'_>, block: &ast::Block) -> bool {\n+    contains_comment(context.snippet(block.span))\n+}\n+\n+// Checks that a block contains no statements, an expression and no comments or\n+// attributes.\n+// FIXME: incorrectly returns false when comment is contained completely within\n+// the expression.\n+pub(crate) fn is_simple_block(\n+    context: &RewriteContext<'_>,\n+    block: &ast::Block,\n+    attrs: Option<&[ast::Attribute]>,\n+) -> bool {\n+    block.stmts.len() == 1\n+        && stmt_is_expr(&block.stmts[0])\n+        && !block_contains_comment(context, block)\n+        && attrs.map_or(true, |a| a.is_empty())\n+}\n+\n+/// Checks whether a block contains at most one statement or expression, and no\n+/// comments or attributes.\n+pub(crate) fn is_simple_block_stmt(\n+    context: &RewriteContext<'_>,\n+    block: &ast::Block,\n+    attrs: Option<&[ast::Attribute]>,\n+) -> bool {\n+    block.stmts.len() <= 1\n+        && !block_contains_comment(context, block)\n+        && attrs.map_or(true, |a| a.is_empty())\n+}\n+\n+fn block_has_statements(block: &ast::Block) -> bool {\n+    block\n+        .stmts\n+        .iter()\n+        .any(|stmt| !matches!(stmt.kind, ast::StmtKind::Empty))\n+}\n+\n+/// Checks whether a block contains no statements, expressions, comments, or\n+/// inner attributes.\n+pub(crate) fn is_empty_block(\n+    context: &RewriteContext<'_>,\n+    block: &ast::Block,\n+    attrs: Option<&[ast::Attribute]>,\n+) -> bool {\n+    !block_has_statements(&block)\n+        && !block_contains_comment(context, block)\n+        && attrs.map_or(true, |a| inner_attributes(a).is_empty())\n+}\n+\n+pub(crate) fn stmt_is_expr(stmt: &ast::Stmt) -> bool {\n+    match stmt.kind {\n+        ast::StmtKind::Expr(..) => true,\n+        _ => false,\n+    }\n+}\n+\n+pub(crate) fn is_unsafe_block(block: &ast::Block) -> bool {\n+    if let ast::BlockCheckMode::Unsafe(..) = block.rules {\n+        true\n+    } else {\n+        false\n+    }\n+}\n+\n+pub(crate) fn rewrite_literal(\n+    context: &RewriteContext<'_>,\n+    l: &ast::Lit,\n+    shape: Shape,\n+) -> Option<String> {\n+    match l.kind {\n+        ast::LitKind::Str(_, ast::StrStyle::Cooked) => rewrite_string_lit(context, l.span, shape),\n+        _ => wrap_str(\n+            context.snippet(l.span).to_owned(),\n+            context.config.max_width(),\n+            shape,\n+        ),\n+    }\n+}\n+\n+fn rewrite_string_lit(context: &RewriteContext<'_>, span: Span, shape: Shape) -> Option<String> {\n+    let string_lit = context.snippet(span);\n+\n+    if !context.config.format_strings() {\n+        if string_lit\n+            .lines()\n+            .dropping_back(1)\n+            .all(|line| line.ends_with('\\\\'))\n+            && context.config.version() == Version::Two\n+        {\n+            return Some(string_lit.to_owned());\n+        } else {\n+            return wrap_str(string_lit.to_owned(), context.config.max_width(), shape);\n+        }\n+    }\n+\n+    // Remove the quote characters.\n+    let str_lit = &string_lit[1..string_lit.len() - 1];\n+\n+    rewrite_string(\n+        str_lit,\n+        &StringFormat::new(shape.visual_indent(0), context.config),\n+        shape.width.saturating_sub(2),\n+    )\n+}\n+\n+fn choose_separator_tactic(context: &RewriteContext<'_>, span: Span) -> Option<SeparatorTactic> {\n+    if context.inside_macro() {\n+        if span_ends_with_comma(context, span) {\n+            Some(SeparatorTactic::Always)\n+        } else {\n+            Some(SeparatorTactic::Never)\n+        }\n+    } else {\n+        None\n+    }\n+}\n+\n+pub(crate) fn rewrite_call(\n+    context: &RewriteContext<'_>,\n+    callee: &str,\n+    args: &[ptr::P<ast::Expr>],\n+    span: Span,\n+    shape: Shape,\n+) -> Option<String> {\n+    overflow::rewrite_with_parens(\n+        context,\n+        callee,\n+        args.iter(),\n+        shape,\n+        span,\n+        context.config.fn_call_width(),\n+        choose_separator_tactic(context, span),\n+    )\n+}\n+\n+pub(crate) fn is_simple_expr(expr: &ast::Expr) -> bool {\n+    match expr.kind {\n+        ast::ExprKind::Lit(..) => true,\n+        ast::ExprKind::Path(ref qself, ref path) => qself.is_none() && path.segments.len() <= 1,\n+        ast::ExprKind::AddrOf(_, _, ref expr)\n+        | ast::ExprKind::Box(ref expr)\n+        | ast::ExprKind::Cast(ref expr, _)\n+        | ast::ExprKind::Field(ref expr, _)\n+        | ast::ExprKind::Try(ref expr)\n+        | ast::ExprKind::Unary(_, ref expr) => is_simple_expr(expr),\n+        ast::ExprKind::Index(ref lhs, ref rhs) => is_simple_expr(lhs) && is_simple_expr(rhs),\n+        ast::ExprKind::Repeat(ref lhs, ref rhs) => {\n+            is_simple_expr(lhs) && is_simple_expr(&*rhs.value)\n+        }\n+        _ => false,\n+    }\n+}\n+\n+pub(crate) fn is_every_expr_simple(lists: &[OverflowableItem<'_>]) -> bool {\n+    lists.iter().all(OverflowableItem::is_simple)\n+}\n+\n+pub(crate) fn can_be_overflowed_expr(\n+    context: &RewriteContext<'_>,\n+    expr: &ast::Expr,\n+    args_len: usize,\n+) -> bool {\n+    match expr.kind {\n+        _ if !expr.attrs.is_empty() => false,\n+        ast::ExprKind::Match(..) => {\n+            (context.use_block_indent() && args_len == 1)\n+                || (context.config.indent_style() == IndentStyle::Visual && args_len > 1)\n+                || context.config.overflow_delimited_expr()\n+        }\n+        ast::ExprKind::If(..)\n+        | ast::ExprKind::ForLoop(..)\n+        | ast::ExprKind::Loop(..)\n+        | ast::ExprKind::While(..) => {\n+            context.config.combine_control_expr() && context.use_block_indent() && args_len == 1\n+        }\n+\n+        // Handle always block-like expressions\n+        ast::ExprKind::Async(..) | ast::ExprKind::Block(..) | ast::ExprKind::Closure(..) => true,\n+\n+        // Handle `[]` and `{}`-like expressions\n+        ast::ExprKind::Array(..) | ast::ExprKind::Struct(..) => {\n+            context.config.overflow_delimited_expr()\n+                || (context.use_block_indent() && args_len == 1)\n+        }\n+        ast::ExprKind::MacCall(ref mac) => {\n+            match (\n+                rustc_ast::ast::MacDelimiter::from_token(mac.args.delim()),\n+                context.config.overflow_delimited_expr(),\n+            ) {\n+                (Some(ast::MacDelimiter::Bracket), true)\n+                | (Some(ast::MacDelimiter::Brace), true) => true,\n+                _ => context.use_block_indent() && args_len == 1,\n+            }\n+        }\n+\n+        // Handle parenthetical expressions\n+        ast::ExprKind::Call(..) | ast::ExprKind::MethodCall(..) | ast::ExprKind::Tup(..) => {\n+            context.use_block_indent() && args_len == 1\n+        }\n+\n+        // Handle unary-like expressions\n+        ast::ExprKind::AddrOf(_, _, ref expr)\n+        | ast::ExprKind::Box(ref expr)\n+        | ast::ExprKind::Try(ref expr)\n+        | ast::ExprKind::Unary(_, ref expr)\n+        | ast::ExprKind::Cast(ref expr, _) => can_be_overflowed_expr(context, expr, args_len),\n+        _ => false,\n+    }\n+}\n+\n+pub(crate) fn is_nested_call(expr: &ast::Expr) -> bool {\n+    match expr.kind {\n+        ast::ExprKind::Call(..) | ast::ExprKind::MacCall(..) => true,\n+        ast::ExprKind::AddrOf(_, _, ref expr)\n+        | ast::ExprKind::Box(ref expr)\n+        | ast::ExprKind::Try(ref expr)\n+        | ast::ExprKind::Unary(_, ref expr)\n+        | ast::ExprKind::Cast(ref expr, _) => is_nested_call(expr),\n+        _ => false,\n+    }\n+}\n+\n+/// Returns `true` if a function call or a method call represented by the given span ends with a\n+/// trailing comma. This function is used when rewriting macro, as adding or removing a trailing\n+/// comma from macro can potentially break the code.\n+pub(crate) fn span_ends_with_comma(context: &RewriteContext<'_>, span: Span) -> bool {\n+    let mut result: bool = Default::default();\n+    let mut prev_char: char = Default::default();\n+    let closing_delimiters = &[')', '}', ']'];\n+\n+    for (kind, c) in CharClasses::new(context.snippet(span).chars()) {\n+        match c {\n+            _ if kind.is_comment() || c.is_whitespace() => continue,\n+            c if closing_delimiters.contains(&c) => {\n+                result &= !closing_delimiters.contains(&prev_char);\n+            }\n+            ',' => result = true,\n+            _ => result = false,\n+        }\n+        prev_char = c;\n+    }\n+\n+    result\n+}\n+\n+fn rewrite_paren(\n+    context: &RewriteContext<'_>,\n+    mut subexpr: &ast::Expr,\n+    shape: Shape,\n+    mut span: Span,\n+) -> Option<String> {\n+    debug!(\"rewrite_paren, shape: {:?}\", shape);\n+\n+    // Extract comments within parens.\n+    let mut pre_span;\n+    let mut post_span;\n+    let mut pre_comment;\n+    let mut post_comment;\n+    let remove_nested_parens = context.config.remove_nested_parens();\n+    loop {\n+        // 1 = \"(\" or \")\"\n+        pre_span = mk_sp(span.lo() + BytePos(1), subexpr.span.lo());\n+        post_span = mk_sp(subexpr.span.hi(), span.hi() - BytePos(1));\n+        pre_comment = rewrite_missing_comment(pre_span, shape, context)?;\n+        post_comment = rewrite_missing_comment(post_span, shape, context)?;\n+\n+        // Remove nested parens if there are no comments.\n+        if let ast::ExprKind::Paren(ref subsubexpr) = subexpr.kind {\n+            if remove_nested_parens && pre_comment.is_empty() && post_comment.is_empty() {\n+                span = subexpr.span;\n+                subexpr = subsubexpr;\n+                continue;\n+            }\n+        }\n+\n+        break;\n+    }\n+\n+    // 1 = `(` and `)`\n+    let sub_shape = shape.offset_left(1)?.sub_width(1)?;\n+    let subexpr_str = subexpr.rewrite(context, sub_shape)?;\n+    let fits_single_line = !pre_comment.contains(\"//\") && !post_comment.contains(\"//\");\n+    if fits_single_line {\n+        Some(format!(\"({}{}{})\", pre_comment, subexpr_str, post_comment))\n+    } else {\n+        rewrite_paren_in_multi_line(context, subexpr, shape, pre_span, post_span)\n+    }\n+}\n+\n+fn rewrite_paren_in_multi_line(\n+    context: &RewriteContext<'_>,\n+    subexpr: &ast::Expr,\n+    shape: Shape,\n+    pre_span: Span,\n+    post_span: Span,\n+) -> Option<String> {\n+    let nested_indent = shape.indent.block_indent(context.config);\n+    let nested_shape = Shape::indented(nested_indent, context.config);\n+    let pre_comment = rewrite_missing_comment(pre_span, nested_shape, context)?;\n+    let post_comment = rewrite_missing_comment(post_span, nested_shape, context)?;\n+    let subexpr_str = subexpr.rewrite(context, nested_shape)?;\n+\n+    let mut result = String::with_capacity(subexpr_str.len() * 2);\n+    result.push('(');\n+    if !pre_comment.is_empty() {\n+        result.push_str(&nested_indent.to_string_with_newline(context.config));\n+        result.push_str(&pre_comment);\n+    }\n+    result.push_str(&nested_indent.to_string_with_newline(context.config));\n+    result.push_str(&subexpr_str);\n+    if !post_comment.is_empty() {\n+        result.push_str(&nested_indent.to_string_with_newline(context.config));\n+        result.push_str(&post_comment);\n+    }\n+    result.push_str(&shape.indent.to_string_with_newline(context.config));\n+    result.push(')');\n+\n+    Some(result)\n+}\n+\n+fn rewrite_index(\n+    expr: &ast::Expr,\n+    index: &ast::Expr,\n+    context: &RewriteContext<'_>,\n+    shape: Shape,\n+) -> Option<String> {\n+    let expr_str = expr.rewrite(context, shape)?;\n+\n+    let offset = last_line_width(&expr_str) + 1;\n+    let rhs_overhead = shape.rhs_overhead(context.config);\n+    let index_shape = if expr_str.contains('\\n') {\n+        Shape::legacy(context.config.max_width(), shape.indent)\n+            .offset_left(offset)\n+            .and_then(|shape| shape.sub_width(1 + rhs_overhead))\n+    } else {\n+        match context.config.indent_style() {\n+            IndentStyle::Block => shape\n+                .offset_left(offset)\n+                .and_then(|shape| shape.sub_width(1)),\n+            IndentStyle::Visual => shape.visual_indent(offset).sub_width(offset + 1),\n+        }\n+    };\n+    let orig_index_rw = index_shape.and_then(|s| index.rewrite(context, s));\n+\n+    // Return if index fits in a single line.\n+    match orig_index_rw {\n+        Some(ref index_str) if !index_str.contains('\\n') => {\n+            return Some(format!(\"{}[{}]\", expr_str, index_str));\n+        }\n+        _ => (),\n+    }\n+\n+    // Try putting index on the next line and see if it fits in a single line.\n+    let indent = shape.indent.block_indent(context.config);\n+    let index_shape = Shape::indented(indent, context.config).offset_left(1)?;\n+    let index_shape = index_shape.sub_width(1 + rhs_overhead)?;\n+    let new_index_rw = index.rewrite(context, index_shape);\n+    match (orig_index_rw, new_index_rw) {\n+        (_, Some(ref new_index_str)) if !new_index_str.contains('\\n') => Some(format!(\n+            \"{}{}[{}]\",\n+            expr_str,\n+            indent.to_string_with_newline(context.config),\n+            new_index_str,\n+        )),\n+        (None, Some(ref new_index_str)) => Some(format!(\n+            \"{}{}[{}]\",\n+            expr_str,\n+            indent.to_string_with_newline(context.config),\n+            new_index_str,\n+        )),\n+        (Some(ref index_str), _) => Some(format!(\"{}[{}]\", expr_str, index_str)),\n+        _ => None,\n+    }\n+}\n+\n+fn struct_lit_can_be_aligned(fields: &[ast::ExprField], has_base: bool) -> bool {\n+    !has_base && fields.iter().all(|field| !field.is_shorthand)\n+}\n+\n+fn rewrite_struct_lit<'a>(\n+    context: &RewriteContext<'_>,\n+    path: &ast::Path,\n+    fields: &'a [ast::ExprField],\n+    struct_rest: &ast::StructRest,\n+    attrs: &[ast::Attribute],\n+    span: Span,\n+    shape: Shape,\n+) -> Option<String> {\n+    debug!(\"rewrite_struct_lit: shape {:?}\", shape);\n+\n+    enum StructLitField<'a> {\n+        Regular(&'a ast::ExprField),\n+        Base(&'a ast::Expr),\n+        Rest(&'a Span),\n+    }\n+\n+    // 2 = \" {\".len()\n+    let path_shape = shape.sub_width(2)?;\n+    let path_str = rewrite_path(context, PathContext::Expr, None, path, path_shape)?;\n+\n+    let has_base = match struct_rest {\n+        ast::StructRest::None if fields.is_empty() => return Some(format!(\"{} {{}}\", path_str)),\n+        ast::StructRest::Rest(_) if fields.is_empty() => {\n+            return Some(format!(\"{} {{ .. }}\", path_str));\n+        }\n+        ast::StructRest::Base(_) => true,\n+        _ => false,\n+    };\n+\n+    // Foo { a: Foo } - indent is +3, width is -5.\n+    let (h_shape, v_shape) = struct_lit_shape(shape, context, path_str.len() + 3, 2)?;\n+\n+    let one_line_width = h_shape.map_or(0, |shape| shape.width);\n+    let body_lo = context.snippet_provider.span_after(span, \"{\");\n+    let fields_str = if struct_lit_can_be_aligned(fields, has_base)\n+        && context.config.struct_field_align_threshold() > 0\n+    {\n+        rewrite_with_alignment(\n+            fields,\n+            context,\n+            v_shape,\n+            mk_sp(body_lo, span.hi()),\n+            one_line_width,\n+        )?\n+    } else {\n+        let field_iter = fields.iter().map(StructLitField::Regular).chain(\n+            match struct_rest {\n+                ast::StructRest::Base(expr) => Some(StructLitField::Base(&**expr)),\n+                ast::StructRest::Rest(span) => Some(StructLitField::Rest(span)),\n+                ast::StructRest::None => None,\n+            }\n+            .into_iter(),\n+        );\n+\n+        let span_lo = |item: &StructLitField<'_>| match *item {\n+            StructLitField::Regular(field) => field.span().lo(),\n+            StructLitField::Base(expr) => {\n+                let last_field_hi = fields.last().map_or(span.lo(), |field| field.span.hi());\n+                let snippet = context.snippet(mk_sp(last_field_hi, expr.span.lo()));\n+                let pos = snippet.find_uncommented(\"..\").unwrap();\n+                last_field_hi + BytePos(pos as u32)\n+            }\n+            StructLitField::Rest(span) => span.lo(),\n+        };\n+        let span_hi = |item: &StructLitField<'_>| match *item {\n+            StructLitField::Regular(field) => field.span().hi(),\n+            StructLitField::Base(expr) => expr.span.hi(),\n+            StructLitField::Rest(span) => span.hi(),\n+        };\n+        let rewrite = |item: &StructLitField<'_>| match *item {\n+            StructLitField::Regular(field) => {\n+                // The 1 taken from the v_budget is for the comma.\n+                rewrite_field(context, field, v_shape.sub_width(1)?, 0)\n+            }\n+            StructLitField::Base(expr) => {\n+                // 2 = ..\n+                expr.rewrite(context, v_shape.offset_left(2)?)\n+                    .map(|s| format!(\"..{}\", s))\n+            }\n+            StructLitField::Rest(_) => Some(\"..\".to_owned()),\n+        };\n+\n+        let items = itemize_list(\n+            context.snippet_provider,\n+            field_iter,\n+            \"}\",\n+            \",\",\n+            span_lo,\n+            span_hi,\n+            rewrite,\n+            body_lo,\n+            span.hi(),\n+            false,\n+        );\n+        let item_vec = items.collect::<Vec<_>>();\n+\n+        let tactic = struct_lit_tactic(h_shape, context, &item_vec);\n+        let nested_shape = shape_for_tactic(tactic, h_shape, v_shape);\n+\n+        let ends_with_comma = span_ends_with_comma(context, span);\n+        let force_no_trailing_comma = context.inside_macro() && !ends_with_comma;\n+\n+        let fmt = struct_lit_formatting(\n+            nested_shape,\n+            tactic,\n+            context,\n+            force_no_trailing_comma\n+                || has_base\n+                || !context.use_block_indent()\n+                || matches!(struct_rest, ast::StructRest::Rest(_)),\n+        );\n+\n+        write_list(&item_vec, &fmt)?\n+    };\n+\n+    let fields_str =\n+        wrap_struct_field(context, &attrs, &fields_str, shape, v_shape, one_line_width)?;\n+    Some(format!(\"{} {{{}}}\", path_str, fields_str))\n+\n+    // FIXME if context.config.indent_style() == Visual, but we run out\n+    // of space, we should fall back to BlockIndent.\n+}\n+\n+pub(crate) fn wrap_struct_field(\n+    context: &RewriteContext<'_>,\n+    attrs: &[ast::Attribute],\n+    fields_str: &str,\n+    shape: Shape,\n+    nested_shape: Shape,\n+    one_line_width: usize,\n+) -> Option<String> {\n+    let should_vertical = context.config.indent_style() == IndentStyle::Block\n+        && (fields_str.contains('\\n')\n+            || !context.config.struct_lit_single_line()\n+            || fields_str.len() > one_line_width);\n+\n+    let inner_attrs = &inner_attributes(attrs);\n+    if inner_attrs.is_empty() {\n+        if should_vertical {\n+            Some(format!(\n+                \"{}{}{}\",\n+                nested_shape.indent.to_string_with_newline(context.config),\n+                fields_str,\n+                shape.indent.to_string_with_newline(context.config)\n+            ))\n+        } else {\n+            // One liner or visual indent.\n+            Some(format!(\" {} \", fields_str))\n+        }\n+    } else {\n+        Some(format!(\n+            \"{}{}{}{}{}\",\n+            nested_shape.indent.to_string_with_newline(context.config),\n+            inner_attrs.rewrite(context, shape)?,\n+            nested_shape.indent.to_string_with_newline(context.config),\n+            fields_str,\n+            shape.indent.to_string_with_newline(context.config)\n+        ))\n+    }\n+}\n+\n+pub(crate) fn struct_lit_field_separator(config: &Config) -> &str {\n+    colon_spaces(config)\n+}\n+\n+pub(crate) fn rewrite_field(\n+    context: &RewriteContext<'_>,\n+    field: &ast::ExprField,\n+    shape: Shape,\n+    prefix_max_width: usize,\n+) -> Option<String> {\n+    if contains_skip(&field.attrs) {\n+        return Some(context.snippet(field.span()).to_owned());\n+    }\n+    let mut attrs_str = field.attrs.rewrite(context, shape)?;\n+    if !attrs_str.is_empty() {\n+        attrs_str.push_str(&shape.indent.to_string_with_newline(context.config));\n+    };\n+    let name = context.snippet(field.ident.span);\n+    if field.is_shorthand {\n+        Some(attrs_str + name)\n+    } else {\n+        let mut separator = String::from(struct_lit_field_separator(context.config));\n+        for _ in 0..prefix_max_width.saturating_sub(name.len()) {\n+            separator.push(' ');\n+        }\n+        let overhead = name.len() + separator.len();\n+        let expr_shape = shape.offset_left(overhead)?;\n+        let expr = field.expr.rewrite(context, expr_shape);\n+\n+        match expr {\n+            Some(ref e) if e.as_str() == name && context.config.use_field_init_shorthand() => {\n+                Some(attrs_str + name)\n+            }\n+            Some(e) => Some(format!(\"{}{}{}{}\", attrs_str, name, separator, e)),\n+            None => {\n+                let expr_offset = shape.indent.block_indent(context.config);\n+                let expr = field\n+                    .expr\n+                    .rewrite(context, Shape::indented(expr_offset, context.config));\n+                expr.map(|s| {\n+                    format!(\n+                        \"{}{}:\\n{}{}\",\n+                        attrs_str,\n+                        name,\n+                        expr_offset.to_string(context.config),\n+                        s\n+                    )\n+                })\n+            }\n+        }\n+    }\n+}\n+\n+fn rewrite_tuple_in_visual_indent_style<'a, T: 'a + IntoOverflowableItem<'a>>(\n+    context: &RewriteContext<'_>,\n+    mut items: impl Iterator<Item = &'a T>,\n+    span: Span,\n+    shape: Shape,\n+    is_singleton_tuple: bool,\n+) -> Option<String> {\n+    // In case of length 1, need a trailing comma\n+    debug!(\"rewrite_tuple_in_visual_indent_style {:?}\", shape);\n+    if is_singleton_tuple {\n+        // 3 = \"(\" + \",)\"\n+        let nested_shape = shape.sub_width(3)?.visual_indent(1);\n+        return items\n+            .next()\n+            .unwrap()\n+            .rewrite(context, nested_shape)\n+            .map(|s| format!(\"({},)\", s));\n+    }\n+\n+    let list_lo = context.snippet_provider.span_after(span, \"(\");\n+    let nested_shape = shape.sub_width(2)?.visual_indent(1);\n+    let items = itemize_list(\n+        context.snippet_provider,\n+        items,\n+        \")\",\n+        \",\",\n+        |item| item.span().lo(),\n+        |item| item.span().hi(),\n+        |item| item.rewrite(context, nested_shape),\n+        list_lo,\n+        span.hi() - BytePos(1),\n+        false,\n+    );\n+    let item_vec: Vec<_> = items.collect();\n+    let tactic = definitive_tactic(\n+        &item_vec,\n+        ListTactic::HorizontalVertical,\n+        Separator::Comma,\n+        nested_shape.width,\n+    );\n+    let fmt = ListFormatting::new(nested_shape, context.config)\n+        .tactic(tactic)\n+        .ends_with_newline(false);\n+    let list_str = write_list(&item_vec, &fmt)?;\n+\n+    Some(format!(\"({})\", list_str))\n+}\n+\n+pub(crate) fn rewrite_tuple<'a, T: 'a + IntoOverflowableItem<'a>>(\n+    context: &'a RewriteContext<'_>,\n+    items: impl Iterator<Item = &'a T>,\n+    span: Span,\n+    shape: Shape,\n+    is_singleton_tuple: bool,\n+) -> Option<String> {\n+    debug!(\"rewrite_tuple {:?}\", shape);\n+    if context.use_block_indent() {\n+        // We use the same rule as function calls for rewriting tuples.\n+        let force_tactic = if context.inside_macro() {\n+            if span_ends_with_comma(context, span) {\n+                Some(SeparatorTactic::Always)\n+            } else {\n+                Some(SeparatorTactic::Never)\n+            }\n+        } else if is_singleton_tuple {\n+            Some(SeparatorTactic::Always)\n+        } else {\n+            None\n+        };\n+        overflow::rewrite_with_parens(\n+            context,\n+            \"\",\n+            items,\n+            shape,\n+            span,\n+            context.config.fn_call_width(),\n+            force_tactic,\n+        )\n+    } else {\n+        rewrite_tuple_in_visual_indent_style(context, items, span, shape, is_singleton_tuple)\n+    }\n+}\n+\n+pub(crate) fn rewrite_unary_prefix<R: Rewrite>(\n+    context: &RewriteContext<'_>,\n+    prefix: &str,\n+    rewrite: &R,\n+    shape: Shape,\n+) -> Option<String> {\n+    rewrite\n+        .rewrite(context, shape.offset_left(prefix.len())?)\n+        .map(|r| format!(\"{}{}\", prefix, r))\n+}\n+\n+// FIXME: this is probably not correct for multi-line Rewrites. we should\n+// subtract suffix.len() from the last line budget, not the first!\n+pub(crate) fn rewrite_unary_suffix<R: Rewrite>(\n+    context: &RewriteContext<'_>,\n+    suffix: &str,\n+    rewrite: &R,\n+    shape: Shape,\n+) -> Option<String> {\n+    rewrite\n+        .rewrite(context, shape.sub_width(suffix.len())?)\n+        .map(|mut r| {\n+            r.push_str(suffix);\n+            r\n+        })\n+}\n+\n+fn rewrite_unary_op(\n+    context: &RewriteContext<'_>,\n+    op: ast::UnOp,\n+    expr: &ast::Expr,\n+    shape: Shape,\n+) -> Option<String> {\n+    // For some reason, an UnOp is not spanned like BinOp!\n+    rewrite_unary_prefix(context, ast::UnOp::to_string(op), expr, shape)\n+}\n+\n+fn rewrite_assignment(\n+    context: &RewriteContext<'_>,\n+    lhs: &ast::Expr,\n+    rhs: &ast::Expr,\n+    op: Option<&ast::BinOp>,\n+    shape: Shape,\n+) -> Option<String> {\n+    let operator_str = match op {\n+        Some(op) => context.snippet(op.span),\n+        None => \"=\",\n+    };\n+\n+    // 1 = space between lhs and operator.\n+    let lhs_shape = shape.sub_width(operator_str.len() + 1)?;\n+    let lhs_str = format!(\"{} {}\", lhs.rewrite(context, lhs_shape)?, operator_str);\n+\n+    rewrite_assign_rhs(context, lhs_str, rhs, shape)\n+}\n+\n+/// Controls where to put the rhs.\n+#[derive(Debug, Copy, Clone, PartialEq, Eq)]\n+pub(crate) enum RhsTactics {\n+    /// Use heuristics.\n+    Default,\n+    /// Put the rhs on the next line if it uses multiple line, without extra indentation.\n+    ForceNextLineWithoutIndent,\n+    /// Allow overflowing max width if neither `Default` nor `ForceNextLineWithoutIndent`\n+    /// did not work.\n+    AllowOverflow,\n+}\n+\n+// The left hand side must contain everything up to, and including, the\n+// assignment operator.\n+pub(crate) fn rewrite_assign_rhs<S: Into<String>, R: Rewrite>(\n+    context: &RewriteContext<'_>,\n+    lhs: S,\n+    ex: &R,\n+    shape: Shape,\n+) -> Option<String> {\n+    rewrite_assign_rhs_with(context, lhs, ex, shape, RhsTactics::Default)\n+}\n+\n+pub(crate) fn rewrite_assign_rhs_expr<R: Rewrite>(\n+    context: &RewriteContext<'_>,\n+    lhs: &str,\n+    ex: &R,\n+    shape: Shape,\n+    rhs_tactics: RhsTactics,\n+) -> Option<String> {\n+    let last_line_width = last_line_width(&lhs).saturating_sub(if lhs.contains('\\n') {\n+        shape.indent.width()\n+    } else {\n+        0\n+    });\n+    // 1 = space between operator and rhs.\n+    let orig_shape = shape.offset_left(last_line_width + 1).unwrap_or(Shape {\n+        width: 0,\n+        offset: shape.offset + last_line_width + 1,\n+        ..shape\n+    });\n+    let has_rhs_comment = if let Some(offset) = lhs.find_last_uncommented(\"=\") {\n+        lhs.trim_end().len() > offset + 1\n+    } else {\n+        false\n+    };\n+\n+    choose_rhs(\n+        context,\n+        ex,\n+        orig_shape,\n+        ex.rewrite(context, orig_shape),\n+        rhs_tactics,\n+        has_rhs_comment,\n+    )\n+}\n+\n+pub(crate) fn rewrite_assign_rhs_with<S: Into<String>, R: Rewrite>(\n+    context: &RewriteContext<'_>,\n+    lhs: S,\n+    ex: &R,\n+    shape: Shape,\n+    rhs_tactics: RhsTactics,\n+) -> Option<String> {\n+    let lhs = lhs.into();\n+    let rhs = rewrite_assign_rhs_expr(context, &lhs, ex, shape, rhs_tactics)?;\n+    Some(lhs + &rhs)\n+}\n+\n+pub(crate) fn rewrite_assign_rhs_with_comments<S: Into<String>, R: Rewrite>(\n+    context: &RewriteContext<'_>,\n+    lhs: S,\n+    ex: &R,\n+    shape: Shape,\n+    rhs_tactics: RhsTactics,\n+    between_span: Span,\n+    allow_extend: bool,\n+) -> Option<String> {\n+    let lhs = lhs.into();\n+    let contains_comment = contains_comment(context.snippet(between_span));\n+    let shape = if contains_comment {\n+        shape.block_left(context.config.tab_spaces())?\n+    } else {\n+        shape\n+    };\n+    let rhs = rewrite_assign_rhs_expr(context, &lhs, ex, shape, rhs_tactics)?;\n+\n+    if contains_comment {\n+        let rhs = rhs.trim_start();\n+        combine_strs_with_missing_comments(context, &lhs, &rhs, between_span, shape, allow_extend)\n+    } else {\n+        Some(lhs + &rhs)\n+    }\n+}\n+\n+fn choose_rhs<R: Rewrite>(\n+    context: &RewriteContext<'_>,\n+    expr: &R,\n+    shape: Shape,\n+    orig_rhs: Option<String>,\n+    rhs_tactics: RhsTactics,\n+    has_rhs_comment: bool,\n+) -> Option<String> {\n+    match orig_rhs {\n+        Some(ref new_str)\n+            if !new_str.contains('\\n') && unicode_str_width(new_str) <= shape.width =>\n+        {\n+            Some(format!(\" {}\", new_str))\n+        }\n+        _ => {\n+            // Expression did not fit on the same line as the identifier.\n+            // Try splitting the line and see if that works better.\n+            let new_shape = shape_from_rhs_tactic(context, shape, rhs_tactics)?;\n+            let new_rhs = expr.rewrite(context, new_shape);\n+            let new_indent_str = &shape\n+                .indent\n+                .block_indent(context.config)\n+                .to_string_with_newline(context.config);\n+            let before_space_str = if has_rhs_comment { \"\" } else { \" \" };\n+\n+            match (orig_rhs, new_rhs) {\n+                (Some(ref orig_rhs), Some(ref new_rhs))\n+                    if wrap_str(new_rhs.clone(), context.config.max_width(), new_shape)\n+                        .is_none() =>\n+                {\n+                    Some(format!(\"{}{}\", before_space_str, orig_rhs))\n+                }\n+                (Some(ref orig_rhs), Some(ref new_rhs))\n+                    if prefer_next_line(orig_rhs, new_rhs, rhs_tactics) =>\n+                {\n+                    Some(format!(\"{}{}\", new_indent_str, new_rhs))\n+                }\n+                (None, Some(ref new_rhs)) => Some(format!(\"{}{}\", new_indent_str, new_rhs)),\n+                (None, None) if rhs_tactics == RhsTactics::AllowOverflow => {\n+                    let shape = shape.infinite_width();\n+                    expr.rewrite(context, shape)\n+                        .map(|s| format!(\"{}{}\", before_space_str, s))\n+                }\n+                (None, None) => None,\n+                (Some(orig_rhs), _) => Some(format!(\"{}{}\", before_space_str, orig_rhs)),\n+            }\n+        }\n+    }\n+}\n+\n+fn shape_from_rhs_tactic(\n+    context: &RewriteContext<'_>,\n+    shape: Shape,\n+    rhs_tactic: RhsTactics,\n+) -> Option<Shape> {\n+    match rhs_tactic {\n+        RhsTactics::ForceNextLineWithoutIndent => shape\n+            .with_max_width(context.config)\n+            .sub_width(shape.indent.width()),\n+        RhsTactics::Default | RhsTactics::AllowOverflow => {\n+            Shape::indented(shape.indent.block_indent(context.config), context.config)\n+                .sub_width(shape.rhs_overhead(context.config))\n+        }\n+    }\n+}\n+\n+/// Returns true if formatting next_line_rhs is better on a new line when compared to the\n+/// original's line formatting.\n+///\n+/// It is considered better if:\n+/// 1. the tactic is ForceNextLineWithoutIndent\n+/// 2. next_line_rhs doesn't have newlines\n+/// 3. the original line has more newlines than next_line_rhs\n+/// 4. the original formatting of the first line ends with `(`, `{`, or `[` and next_line_rhs\n+///    doesn't\n+pub(crate) fn prefer_next_line(\n+    orig_rhs: &str,\n+    next_line_rhs: &str,\n+    rhs_tactics: RhsTactics,\n+) -> bool {\n+    rhs_tactics == RhsTactics::ForceNextLineWithoutIndent\n+        || !next_line_rhs.contains('\\n')\n+        || count_newlines(orig_rhs) > count_newlines(next_line_rhs) + 1\n+        || first_line_ends_with(orig_rhs, '(') && !first_line_ends_with(next_line_rhs, '(')\n+        || first_line_ends_with(orig_rhs, '{') && !first_line_ends_with(next_line_rhs, '{')\n+        || first_line_ends_with(orig_rhs, '[') && !first_line_ends_with(next_line_rhs, '[')\n+}\n+\n+fn rewrite_expr_addrof(\n+    context: &RewriteContext<'_>,\n+    borrow_kind: ast::BorrowKind,\n+    mutability: ast::Mutability,\n+    expr: &ast::Expr,\n+    shape: Shape,\n+) -> Option<String> {\n+    let operator_str = match (mutability, borrow_kind) {\n+        (ast::Mutability::Not, ast::BorrowKind::Ref) => \"&\",\n+        (ast::Mutability::Not, ast::BorrowKind::Raw) => \"&raw const \",\n+        (ast::Mutability::Mut, ast::BorrowKind::Ref) => \"&mut \",\n+        (ast::Mutability::Mut, ast::BorrowKind::Raw) => \"&raw mut \",\n+    };\n+    rewrite_unary_prefix(context, operator_str, expr, shape)\n+}\n+\n+pub(crate) fn is_method_call(expr: &ast::Expr) -> bool {\n+    match expr.kind {\n+        ast::ExprKind::MethodCall(..) => true,\n+        ast::ExprKind::AddrOf(_, _, ref expr)\n+        | ast::ExprKind::Box(ref expr)\n+        | ast::ExprKind::Cast(ref expr, _)\n+        | ast::ExprKind::Try(ref expr)\n+        | ast::ExprKind::Unary(_, ref expr) => is_method_call(expr),\n+        _ => false,\n+    }\n+}\n+\n+#[cfg(test)]\n+mod test {\n+    use super::last_line_offsetted;\n+\n+    #[test]\n+    fn test_last_line_offsetted() {\n+        let lines = \"one\\n    two\";\n+        assert_eq!(last_line_offsetted(2, lines), true);\n+        assert_eq!(last_line_offsetted(4, lines), false);\n+        assert_eq!(last_line_offsetted(6, lines), false);\n+\n+        let lines = \"one    two\";\n+        assert_eq!(last_line_offsetted(2, lines), false);\n+        assert_eq!(last_line_offsetted(0, lines), false);\n+\n+        let lines = \"\\ntwo\";\n+        assert_eq!(last_line_offsetted(2, lines), false);\n+        assert_eq!(last_line_offsetted(0, lines), false);\n+\n+        let lines = \"one\\n    two      three\";\n+        assert_eq!(last_line_offsetted(2, lines), true);\n+        let lines = \"one\\n two      three\";\n+        assert_eq!(last_line_offsetted(2, lines), false);\n+    }\n+}"}, {"sha": "c751932273b0a8f27c494f25799a49a9dfc08f33", "filename": "src/tools/rustfmt/src/format-diff/main.rs", "status": "added", "additions": 280, "deletions": 0, "changes": 280, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Fsrc%2Fformat-diff%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Fsrc%2Fformat-diff%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fsrc%2Fformat-diff%2Fmain.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782", "patch": "@@ -0,0 +1,280 @@\n+// Inspired by Clang's clang-format-diff:\n+//\n+// https://github.com/llvm-mirror/clang/blob/master/tools/clang-format/clang-format-diff.py\n+\n+#![deny(warnings)]\n+\n+#[macro_use]\n+extern crate log;\n+\n+use serde::{Deserialize, Serialize};\n+use serde_json as json;\n+use thiserror::Error;\n+\n+use std::collections::HashSet;\n+use std::env;\n+use std::ffi::OsStr;\n+use std::io::{self, BufRead};\n+use std::process;\n+\n+use regex::Regex;\n+\n+use structopt::clap::AppSettings;\n+use structopt::StructOpt;\n+\n+/// The default pattern of files to format.\n+///\n+/// We only want to format rust files by default.\n+const DEFAULT_PATTERN: &str = r\".*\\.rs\";\n+\n+#[derive(Error, Debug)]\n+enum FormatDiffError {\n+    #[error(\"{0}\")]\n+    IncorrectOptions(#[from] getopts::Fail),\n+    #[error(\"{0}\")]\n+    IncorrectFilter(#[from] regex::Error),\n+    #[error(\"{0}\")]\n+    IoError(#[from] io::Error),\n+}\n+\n+#[derive(StructOpt, Debug)]\n+#[structopt(\n+    name = \"rustfmt-format-diff\",\n+    setting = AppSettings::DisableVersion,\n+    setting = AppSettings::NextLineHelp\n+)]\n+pub struct Opts {\n+    /// Skip the smallest prefix containing NUMBER slashes\n+    #[structopt(\n+        short = \"p\",\n+        long = \"skip-prefix\",\n+        value_name = \"NUMBER\",\n+        default_value = \"0\"\n+    )]\n+    skip_prefix: u32,\n+\n+    /// Custom pattern selecting file paths to reformat\n+    #[structopt(\n+        short = \"f\",\n+        long = \"filter\",\n+        value_name = \"PATTERN\",\n+        default_value = DEFAULT_PATTERN\n+    )]\n+    filter: String,\n+}\n+\n+fn main() {\n+    env_logger::init();\n+    let opts = Opts::from_args();\n+    if let Err(e) = run(opts) {\n+        println!(\"{}\", e);\n+        Opts::clap().print_help().expect(\"cannot write to stdout\");\n+        process::exit(1);\n+    }\n+}\n+\n+#[derive(Debug, Eq, PartialEq, Serialize, Deserialize)]\n+struct Range {\n+    file: String,\n+    range: [u32; 2],\n+}\n+\n+fn run(opts: Opts) -> Result<(), FormatDiffError> {\n+    let (files, ranges) = scan_diff(io::stdin(), opts.skip_prefix, &opts.filter)?;\n+    run_rustfmt(&files, &ranges)\n+}\n+\n+fn run_rustfmt(files: &HashSet<String>, ranges: &[Range]) -> Result<(), FormatDiffError> {\n+    if files.is_empty() || ranges.is_empty() {\n+        debug!(\"No files to format found\");\n+        return Ok(());\n+    }\n+\n+    let ranges_as_json = json::to_string(ranges).unwrap();\n+\n+    debug!(\"Files: {:?}\", files);\n+    debug!(\"Ranges: {:?}\", ranges);\n+\n+    let rustfmt_var = env::var_os(\"RUSTFMT\");\n+    let rustfmt = match &rustfmt_var {\n+        Some(rustfmt) => rustfmt,\n+        None => OsStr::new(\"rustfmt\"),\n+    };\n+    let exit_status = process::Command::new(rustfmt)\n+        .args(files)\n+        .arg(\"--file-lines\")\n+        .arg(ranges_as_json)\n+        .status()?;\n+\n+    if !exit_status.success() {\n+        return Err(FormatDiffError::IoError(io::Error::new(\n+            io::ErrorKind::Other,\n+            format!(\"rustfmt failed with {}\", exit_status),\n+        )));\n+    }\n+    Ok(())\n+}\n+\n+/// Scans a diff from `from`, and returns the set of files found, and the ranges\n+/// in those files.\n+fn scan_diff<R>(\n+    from: R,\n+    skip_prefix: u32,\n+    file_filter: &str,\n+) -> Result<(HashSet<String>, Vec<Range>), FormatDiffError>\n+where\n+    R: io::Read,\n+{\n+    let diff_pattern = format!(r\"^\\+\\+\\+\\s(?:.*?/){{{}}}(\\S*)\", skip_prefix);\n+    let diff_pattern = Regex::new(&diff_pattern).unwrap();\n+\n+    let lines_pattern = Regex::new(r\"^@@.*\\+(\\d+)(,(\\d+))?\").unwrap();\n+\n+    let file_filter = Regex::new(&format!(\"^{}$\", file_filter))?;\n+\n+    let mut current_file = None;\n+\n+    let mut files = HashSet::new();\n+    let mut ranges = vec![];\n+    for line in io::BufReader::new(from).lines() {\n+        let line = line.unwrap();\n+\n+        if let Some(captures) = diff_pattern.captures(&line) {\n+            current_file = Some(captures.get(1).unwrap().as_str().to_owned());\n+        }\n+\n+        let file = match current_file {\n+            Some(ref f) => &**f,\n+            None => continue,\n+        };\n+\n+        // FIXME(emilio): We could avoid this most of the time if needed, but\n+        // it's not clear it's worth it.\n+        if !file_filter.is_match(file) {\n+            continue;\n+        }\n+\n+        let lines_captures = match lines_pattern.captures(&line) {\n+            Some(captures) => captures,\n+            None => continue,\n+        };\n+\n+        let start_line = lines_captures\n+            .get(1)\n+            .unwrap()\n+            .as_str()\n+            .parse::<u32>()\n+            .unwrap();\n+        let line_count = match lines_captures.get(3) {\n+            Some(line_count) => line_count.as_str().parse::<u32>().unwrap(),\n+            None => 1,\n+        };\n+\n+        if line_count == 0 {\n+            continue;\n+        }\n+\n+        let end_line = start_line + line_count - 1;\n+        files.insert(file.to_owned());\n+        ranges.push(Range {\n+            file: file.to_owned(),\n+            range: [start_line, end_line],\n+        });\n+    }\n+\n+    Ok((files, ranges))\n+}\n+\n+#[test]\n+fn scan_simple_git_diff() {\n+    const DIFF: &str = include_str!(\"test/bindgen.diff\");\n+    let (files, ranges) = scan_diff(DIFF.as_bytes(), 1, r\".*\\.rs\").expect(\"scan_diff failed?\");\n+\n+    assert!(\n+        files.contains(\"src/ir/traversal.rs\"),\n+        \"Should've matched the filter\"\n+    );\n+\n+    assert!(\n+        !files.contains(\"tests/headers/anon_enum.hpp\"),\n+        \"Shouldn't have matched the filter\"\n+    );\n+\n+    assert_eq!(\n+        &ranges,\n+        &[\n+            Range {\n+                file: \"src/ir/item.rs\".to_owned(),\n+                range: [148, 158],\n+            },\n+            Range {\n+                file: \"src/ir/item.rs\".to_owned(),\n+                range: [160, 170],\n+            },\n+            Range {\n+                file: \"src/ir/traversal.rs\".to_owned(),\n+                range: [9, 16],\n+            },\n+            Range {\n+                file: \"src/ir/traversal.rs\".to_owned(),\n+                range: [35, 43],\n+            },\n+        ]\n+    );\n+}\n+\n+#[cfg(test)]\n+mod cmd_line_tests {\n+    use super::*;\n+\n+    #[test]\n+    fn default_options() {\n+        let empty: Vec<String> = vec![];\n+        let o = Opts::from_iter(&empty);\n+        assert_eq!(DEFAULT_PATTERN, o.filter);\n+        assert_eq!(0, o.skip_prefix);\n+    }\n+\n+    #[test]\n+    fn good_options() {\n+        let o = Opts::from_iter(&[\"test\", \"-p\", \"10\", \"-f\", r\".*\\.hs\"]);\n+        assert_eq!(r\".*\\.hs\", o.filter);\n+        assert_eq!(10, o.skip_prefix);\n+    }\n+\n+    #[test]\n+    fn unexpected_option() {\n+        assert!(\n+            Opts::clap()\n+                .get_matches_from_safe(&[\"test\", \"unexpected\"])\n+                .is_err()\n+        );\n+    }\n+\n+    #[test]\n+    fn unexpected_flag() {\n+        assert!(\n+            Opts::clap()\n+                .get_matches_from_safe(&[\"test\", \"--flag\"])\n+                .is_err()\n+        );\n+    }\n+\n+    #[test]\n+    fn overridden_option() {\n+        assert!(\n+            Opts::clap()\n+                .get_matches_from_safe(&[\"test\", \"-p\", \"10\", \"-p\", \"20\"])\n+                .is_err()\n+        );\n+    }\n+\n+    #[test]\n+    fn negative_filter() {\n+        assert!(\n+            Opts::clap()\n+                .get_matches_from_safe(&[\"test\", \"-p\", \"-1\"])\n+                .is_err()\n+        );\n+    }\n+}"}, {"sha": "d2fd379f471654699ec84c3f7ce628243023f1b9", "filename": "src/tools/rustfmt/src/format-diff/test/bindgen.diff", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Fsrc%2Fformat-diff%2Ftest%2Fbindgen.diff", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Fsrc%2Fformat-diff%2Ftest%2Fbindgen.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fsrc%2Fformat-diff%2Ftest%2Fbindgen.diff?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782", "patch": "@@ -0,0 +1,67 @@\n+diff --git a/src/ir/item.rs b/src/ir/item.rs\n+index 7f3afefb..90d15e96 100644\n+--- a/src/ir/item.rs\n++++ b/src/ir/item.rs\n+@@ -148,7 +148,11 @@ impl<'a, 'b> Iterator for ItemAncestorsIter<'a, 'b>\n+ impl AsTemplateParam for ItemId {\n+     type Extra = ();\n+ \n+-    fn as_template_param(&self, ctx: &BindgenContext, _: &()) -> Option<ItemId> {\n++    fn as_template_param(\n++        &self,\n++        ctx: &BindgenContext,\n++        _: &(),\n++    ) -> Option<ItemId> {\n+         ctx.resolve_item(*self).as_template_param(ctx, &())\n+     }\n+ }\n+@@ -156,7 +160,11 @@ impl AsTemplateParam for ItemId {\n+ impl AsTemplateParam for Item {\n+     type Extra = ();\n+ \n+-    fn as_template_param(&self, ctx: &BindgenContext, _: &()) -> Option<ItemId> {\n++    fn as_template_param(\n++        &self,\n++        ctx: &BindgenContext,\n++        _: &(),\n++    ) -> Option<ItemId> {\n+         self.kind.as_template_param(ctx, self)\n+     }\n+ }\n+diff --git a/src/ir/traversal.rs b/src/ir/traversal.rs\n+index 762a3e2d..b9c9dd4e 100644\n+--- a/src/ir/traversal.rs\n++++ b/src/ir/traversal.rs\n+@@ -9,6 +9,8 @@ use std::collections::{BTreeMap, VecDeque};\n+ ///\n+ ///   from --> to\n+ ///\n++/// Random content to generate a diff.\n++///\n+ /// The `from` is left implicit: it is the concrete `Trace` implementer which\n+ /// yielded this outgoing edge.\n+ #[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]\n+@@ -33,7 +35,9 @@ impl Into<ItemId> for Edge {\n+     }\n+ }\n+ \n+-/// The kind of edge reference. This is useful when we wish to only consider\n++/// The kind of edge reference.\n++///\n++/// This is useful when we wish to only consider\n+ /// certain kinds of edges for a particular traversal or analysis.\n+ #[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]\n+ pub enum EdgeKind {\n+diff --git a/tests/headers/anon_enum.hpp b/tests/headers/anon_enum.hpp\n+index 1961fe6c..34759df3 100644\n+--- a/tests/headers/anon_enum.hpp\n++++ b/tests/headers/anon_enum.hpp\n+@@ -1,7 +1,7 @@\n+ struct Test {\n+   int foo;\n+   float bar;\n+-  enum { T_NONE };\n++  enum { T_NONE, T_SOME };\n+ };\n+ \n+ typedef enum {"}, {"sha": "c820259256c4724d0cd335573ab5b8de49e6ad05", "filename": "src/tools/rustfmt/src/format_report_formatter.rs", "status": "added", "additions": 150, "deletions": 0, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Fsrc%2Fformat_report_formatter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Fsrc%2Fformat_report_formatter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fsrc%2Fformat_report_formatter.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782", "patch": "@@ -0,0 +1,150 @@\n+use crate::formatting::FormattingError;\n+use crate::{ErrorKind, FormatReport};\n+use annotate_snippets::display_list::{DisplayList, FormatOptions};\n+use annotate_snippets::snippet::{Annotation, AnnotationType, Slice, Snippet, SourceAnnotation};\n+use std::fmt::{self, Display};\n+\n+/// A builder for [`FormatReportFormatter`].\n+pub struct FormatReportFormatterBuilder<'a> {\n+    report: &'a FormatReport,\n+    enable_colors: bool,\n+}\n+\n+impl<'a> FormatReportFormatterBuilder<'a> {\n+    /// Creates a new [`FormatReportFormatterBuilder`].\n+    pub fn new(report: &'a FormatReport) -> Self {\n+        Self {\n+            report,\n+            enable_colors: false,\n+        }\n+    }\n+\n+    /// Enables colors and formatting in the output.\n+    pub fn enable_colors(self, enable_colors: bool) -> Self {\n+        Self {\n+            enable_colors,\n+            ..self\n+        }\n+    }\n+\n+    /// Creates a new [`FormatReportFormatter`] from the settings in this builder.\n+    pub fn build(self) -> FormatReportFormatter<'a> {\n+        FormatReportFormatter {\n+            report: self.report,\n+            enable_colors: self.enable_colors,\n+        }\n+    }\n+}\n+\n+/// Formats the warnings/errors in a [`FormatReport`].\n+///\n+/// Can be created using a [`FormatReportFormatterBuilder`].\n+pub struct FormatReportFormatter<'a> {\n+    report: &'a FormatReport,\n+    enable_colors: bool,\n+}\n+\n+impl<'a> Display for FormatReportFormatter<'a> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        let errors_by_file = &self.report.internal.borrow().0;\n+\n+        let opt = FormatOptions {\n+            color: self.enable_colors,\n+            ..Default::default()\n+        };\n+\n+        for (file, errors) in errors_by_file {\n+            for error in errors {\n+                let error_kind = error.kind.to_string();\n+                let title = Some(Annotation {\n+                    id: if error.is_internal() {\n+                        Some(\"internal\")\n+                    } else {\n+                        None\n+                    },\n+                    label: Some(&error_kind),\n+                    annotation_type: error_kind_to_snippet_annotation_type(&error.kind),\n+                });\n+\n+                let message_suffix = error.msg_suffix();\n+                let footer = if !message_suffix.is_empty() {\n+                    Some(Annotation {\n+                        id: None,\n+                        label: Some(message_suffix),\n+                        annotation_type: AnnotationType::Note,\n+                    })\n+                } else {\n+                    None\n+                };\n+\n+                let origin = format!(\"{}:{}\", file, error.line);\n+                let slice = Slice {\n+                    source: &error.line_buffer.clone(),\n+                    line_start: error.line,\n+                    origin: Some(origin.as_str()),\n+                    fold: false,\n+                    annotations: slice_annotation(error).into_iter().collect(),\n+                };\n+\n+                let snippet = Snippet {\n+                    title,\n+                    footer: footer.into_iter().collect(),\n+                    slices: vec![slice],\n+                    opt,\n+                };\n+                writeln!(f, \"{}\\n\", DisplayList::from(snippet))?;\n+            }\n+        }\n+\n+        if !errors_by_file.is_empty() {\n+            let label = format!(\n+                \"rustfmt has failed to format. See previous {} errors.\",\n+                self.report.warning_count()\n+            );\n+            let snippet = Snippet {\n+                title: Some(Annotation {\n+                    id: None,\n+                    label: Some(&label),\n+                    annotation_type: AnnotationType::Warning,\n+                }),\n+                footer: Vec::new(),\n+                slices: Vec::new(),\n+                opt,\n+            };\n+            writeln!(f, \"{}\", DisplayList::from(snippet))?;\n+        }\n+\n+        Ok(())\n+    }\n+}\n+\n+fn slice_annotation(error: &FormattingError) -> Option<SourceAnnotation<'_>> {\n+    let (range_start, range_length) = error.format_len();\n+    let range_end = range_start + range_length;\n+\n+    if range_length > 0 {\n+        Some(SourceAnnotation {\n+            annotation_type: AnnotationType::Error,\n+            range: (range_start, range_end),\n+            label: \"\",\n+        })\n+    } else {\n+        None\n+    }\n+}\n+\n+fn error_kind_to_snippet_annotation_type(error_kind: &ErrorKind) -> AnnotationType {\n+    match error_kind {\n+        ErrorKind::LineOverflow(..)\n+        | ErrorKind::TrailingWhitespace\n+        | ErrorKind::IoError(_)\n+        | ErrorKind::ModuleResolutionError(_)\n+        | ErrorKind::ParseError\n+        | ErrorKind::LostComment\n+        | ErrorKind::LicenseCheck\n+        | ErrorKind::BadAttr\n+        | ErrorKind::InvalidGlobPattern(_)\n+        | ErrorKind::VersionMismatch => AnnotationType::Error,\n+        ErrorKind::BadIssue(_) | ErrorKind::DeprecatedAttr => AnnotationType::Warning,\n+    }\n+}"}, {"sha": "b69ecdc5cb8ae2985065bf54c5872d0528f1ac69", "filename": "src/tools/rustfmt/src/formatting.rs", "status": "added", "additions": 610, "deletions": 0, "changes": 610, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Fsrc%2Fformatting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Fsrc%2Fformatting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fsrc%2Fformatting.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782", "patch": "@@ -0,0 +1,610 @@\n+// High level formatting functions.\n+\n+use std::collections::HashMap;\n+use std::io::{self, Write};\n+use std::time::{Duration, Instant};\n+\n+use rustc_ast::ast;\n+use rustc_span::Span;\n+\n+use self::newline_style::apply_newline_style;\n+use crate::comment::{CharClasses, FullCodeCharKind};\n+use crate::config::{Config, FileName, Verbosity};\n+use crate::issues::BadIssueSeeker;\n+use crate::modules::Module;\n+use crate::syntux::parser::{DirectoryOwnership, Parser, ParserError};\n+use crate::syntux::session::ParseSess;\n+use crate::utils::count_newlines;\n+use crate::visitor::FmtVisitor;\n+use crate::{modules, source_file, ErrorKind, FormatReport, Input, Session};\n+\n+mod newline_style;\n+\n+// A map of the files of a crate, with their new content\n+pub(crate) type SourceFile = Vec<FileRecord>;\n+pub(crate) type FileRecord = (FileName, String);\n+\n+impl<'b, T: Write + 'b> Session<'b, T> {\n+    pub(crate) fn format_input_inner(\n+        &mut self,\n+        input: Input,\n+        is_macro_def: bool,\n+    ) -> Result<FormatReport, ErrorKind> {\n+        if !self.config.version_meets_requirement() {\n+            return Err(ErrorKind::VersionMismatch);\n+        }\n+\n+        rustc_span::with_session_globals(self.config.edition().into(), || {\n+            if self.config.disable_all_formatting() {\n+                // When the input is from stdin, echo back the input.\n+                if let Input::Text(ref buf) = input {\n+                    if let Err(e) = io::stdout().write_all(buf.as_bytes()) {\n+                        return Err(From::from(e));\n+                    }\n+                }\n+                return Ok(FormatReport::new());\n+            }\n+\n+            let config = &self.config.clone();\n+            let format_result = format_project(input, config, self, is_macro_def);\n+\n+            format_result.map(|report| {\n+                self.errors.add(&report.internal.borrow().1);\n+                report\n+            })\n+        })\n+    }\n+}\n+\n+// Format an entire crate (or subset of the module tree).\n+fn format_project<T: FormatHandler>(\n+    input: Input,\n+    config: &Config,\n+    handler: &mut T,\n+    is_macro_def: bool,\n+) -> Result<FormatReport, ErrorKind> {\n+    let mut timer = Timer::start();\n+\n+    let main_file = input.file_name();\n+    let input_is_stdin = main_file == FileName::Stdin;\n+\n+    let parse_session = ParseSess::new(config)?;\n+    if config.skip_children() && parse_session.ignore_file(&main_file) {\n+        return Ok(FormatReport::new());\n+    }\n+\n+    // Parse the crate.\n+    let mut report = FormatReport::new();\n+    let directory_ownership = input.to_directory_ownership();\n+    let krate = match Parser::parse_crate(input, &parse_session) {\n+        Ok(krate) => krate,\n+        // Surface parse error via Session (errors are merged there from report)\n+        Err(e) => {\n+            let forbid_verbose = input_is_stdin || e != ParserError::ParsePanicError;\n+            should_emit_verbose(forbid_verbose, config, || {\n+                eprintln!(\"The Rust parser panicked\");\n+            });\n+            report.add_parsing_error();\n+            return Ok(report);\n+        }\n+    };\n+\n+    let mut context = FormatContext::new(&krate, report, parse_session, config, handler);\n+    let files = modules::ModResolver::new(\n+        &context.parse_session,\n+        directory_ownership.unwrap_or(DirectoryOwnership::UnownedViaBlock),\n+        !input_is_stdin && !config.skip_children(),\n+    )\n+    .visit_crate(&krate)?;\n+\n+    timer = timer.done_parsing();\n+\n+    // Suppress error output if we have to do any further parsing.\n+    context.parse_session.set_silent_emitter();\n+\n+    for (path, module) in files {\n+        let should_ignore = !input_is_stdin && context.ignore_file(&path);\n+        if (config.skip_children() && path != main_file) || should_ignore {\n+            continue;\n+        }\n+        should_emit_verbose(input_is_stdin, config, || println!(\"Formatting {}\", path));\n+        context.format_file(path, &module, is_macro_def)?;\n+    }\n+    timer = timer.done_formatting();\n+\n+    should_emit_verbose(input_is_stdin, config, || {\n+        println!(\n+            \"Spent {0:.3} secs in the parsing phase, and {1:.3} secs in the formatting phase\",\n+            timer.get_parse_time(),\n+            timer.get_format_time(),\n+        )\n+    });\n+\n+    Ok(context.report)\n+}\n+\n+// Used for formatting files.\n+#[derive(new)]\n+struct FormatContext<'a, T: FormatHandler> {\n+    krate: &'a ast::Crate,\n+    report: FormatReport,\n+    parse_session: ParseSess,\n+    config: &'a Config,\n+    handler: &'a mut T,\n+}\n+\n+impl<'a, T: FormatHandler + 'a> FormatContext<'a, T> {\n+    fn ignore_file(&self, path: &FileName) -> bool {\n+        self.parse_session.ignore_file(path)\n+    }\n+\n+    // Formats a single file/module.\n+    fn format_file(\n+        &mut self,\n+        path: FileName,\n+        module: &Module<'_>,\n+        is_macro_def: bool,\n+    ) -> Result<(), ErrorKind> {\n+        let snippet_provider = self.parse_session.snippet_provider(module.span);\n+        let mut visitor = FmtVisitor::from_parse_sess(\n+            &self.parse_session,\n+            &self.config,\n+            &snippet_provider,\n+            self.report.clone(),\n+        );\n+        visitor.skip_context.update_with_attrs(&self.krate.attrs);\n+        visitor.is_macro_def = is_macro_def;\n+        visitor.last_pos = snippet_provider.start_pos();\n+        visitor.skip_empty_lines(snippet_provider.end_pos());\n+        visitor.format_separate_mod(module, snippet_provider.end_pos());\n+\n+        debug_assert_eq!(\n+            visitor.line_number,\n+            count_newlines(&visitor.buffer),\n+            \"failed in format_file visitor.buffer:\\n {:?}\",\n+            &visitor.buffer\n+        );\n+\n+        // For some reason, the source_map does not include terminating\n+        // newlines so we must add one on for each file. This is sad.\n+        source_file::append_newline(&mut visitor.buffer);\n+\n+        format_lines(\n+            &mut visitor.buffer,\n+            &path,\n+            &visitor.skipped_range.borrow(),\n+            &self.config,\n+            &self.report,\n+        );\n+\n+        apply_newline_style(\n+            self.config.newline_style(),\n+            &mut visitor.buffer,\n+            snippet_provider.entire_snippet(),\n+        );\n+\n+        if visitor.macro_rewrite_failure {\n+            self.report.add_macro_format_failure();\n+        }\n+        self.report\n+            .add_non_formatted_ranges(visitor.skipped_range.borrow().clone());\n+\n+        self.handler.handle_formatted_file(\n+            &self.parse_session,\n+            path,\n+            visitor.buffer.to_owned(),\n+            &mut self.report,\n+        )\n+    }\n+}\n+\n+// Handle the results of formatting.\n+trait FormatHandler {\n+    fn handle_formatted_file(\n+        &mut self,\n+        parse_session: &ParseSess,\n+        path: FileName,\n+        result: String,\n+        report: &mut FormatReport,\n+    ) -> Result<(), ErrorKind>;\n+}\n+\n+impl<'b, T: Write + 'b> FormatHandler for Session<'b, T> {\n+    // Called for each formatted file.\n+    fn handle_formatted_file(\n+        &mut self,\n+        parse_session: &ParseSess,\n+        path: FileName,\n+        result: String,\n+        report: &mut FormatReport,\n+    ) -> Result<(), ErrorKind> {\n+        if let Some(ref mut out) = self.out {\n+            match source_file::write_file(\n+                Some(parse_session),\n+                &path,\n+                &result,\n+                out,\n+                &mut *self.emitter,\n+                self.config.newline_style(),\n+            ) {\n+                Ok(ref result) if result.has_diff => report.add_diff(),\n+                Err(e) => {\n+                    // Create a new error with path_str to help users see which files failed\n+                    let err_msg = format!(\"{}: {}\", path, e);\n+                    return Err(io::Error::new(e.kind(), err_msg).into());\n+                }\n+                _ => {}\n+            }\n+        }\n+\n+        self.source_file.push((path, result));\n+        Ok(())\n+    }\n+}\n+\n+pub(crate) struct FormattingError {\n+    pub(crate) line: usize,\n+    pub(crate) kind: ErrorKind,\n+    is_comment: bool,\n+    is_string: bool,\n+    pub(crate) line_buffer: String,\n+}\n+\n+impl FormattingError {\n+    pub(crate) fn from_span(\n+        span: Span,\n+        parse_sess: &ParseSess,\n+        kind: ErrorKind,\n+    ) -> FormattingError {\n+        FormattingError {\n+            line: parse_sess.line_of_byte_pos(span.lo()),\n+            is_comment: kind.is_comment(),\n+            kind,\n+            is_string: false,\n+            line_buffer: parse_sess.span_to_first_line_string(span),\n+        }\n+    }\n+\n+    pub(crate) fn is_internal(&self) -> bool {\n+        match self.kind {\n+            ErrorKind::LineOverflow(..)\n+            | ErrorKind::TrailingWhitespace\n+            | ErrorKind::IoError(_)\n+            | ErrorKind::ParseError\n+            | ErrorKind::LostComment => true,\n+            _ => false,\n+        }\n+    }\n+\n+    pub(crate) fn msg_suffix(&self) -> &str {\n+        if self.is_comment || self.is_string {\n+            \"set `error_on_unformatted = false` to suppress \\\n+             the warning against comments or string literals\\n\"\n+        } else {\n+            \"\"\n+        }\n+    }\n+\n+    // (space, target)\n+    pub(crate) fn format_len(&self) -> (usize, usize) {\n+        match self.kind {\n+            ErrorKind::LineOverflow(found, max) => (max, found - max),\n+            ErrorKind::TrailingWhitespace\n+            | ErrorKind::DeprecatedAttr\n+            | ErrorKind::BadIssue(_)\n+            | ErrorKind::BadAttr\n+            | ErrorKind::LostComment\n+            | ErrorKind::LicenseCheck => {\n+                let trailing_ws_start = self\n+                    .line_buffer\n+                    .rfind(|c: char| !c.is_whitespace())\n+                    .map(|pos| pos + 1)\n+                    .unwrap_or(0);\n+                (\n+                    trailing_ws_start,\n+                    self.line_buffer.len() - trailing_ws_start,\n+                )\n+            }\n+            _ => unreachable!(),\n+        }\n+    }\n+}\n+\n+pub(crate) type FormatErrorMap = HashMap<FileName, Vec<FormattingError>>;\n+\n+#[derive(Default, Debug, PartialEq)]\n+pub(crate) struct ReportedErrors {\n+    // Encountered e.g., an IO error.\n+    pub(crate) has_operational_errors: bool,\n+\n+    // Failed to reformat code because of parsing errors.\n+    pub(crate) has_parsing_errors: bool,\n+\n+    // Code is valid, but it is impossible to format it properly.\n+    pub(crate) has_formatting_errors: bool,\n+\n+    // Code contains macro call that was unable to format.\n+    pub(crate) has_macro_format_failure: bool,\n+\n+    // Failed a check, such as the license check or other opt-in checking.\n+    pub(crate) has_check_errors: bool,\n+\n+    /// Formatted code differs from existing code (--check only).\n+    pub(crate) has_diff: bool,\n+\n+    /// Formatted code missed something, like lost comments or extra trailing space\n+    pub(crate) has_unformatted_code_errors: bool,\n+}\n+\n+impl ReportedErrors {\n+    /// Combine two summaries together.\n+    pub(crate) fn add(&mut self, other: &ReportedErrors) {\n+        self.has_operational_errors |= other.has_operational_errors;\n+        self.has_parsing_errors |= other.has_parsing_errors;\n+        self.has_formatting_errors |= other.has_formatting_errors;\n+        self.has_macro_format_failure |= other.has_macro_format_failure;\n+        self.has_check_errors |= other.has_check_errors;\n+        self.has_diff |= other.has_diff;\n+        self.has_unformatted_code_errors |= other.has_unformatted_code_errors;\n+    }\n+}\n+\n+#[derive(Clone, Copy, Debug)]\n+enum Timer {\n+    Disabled,\n+    Initialized(Instant),\n+    DoneParsing(Instant, Instant),\n+    DoneFormatting(Instant, Instant, Instant),\n+}\n+\n+impl Timer {\n+    fn start() -> Timer {\n+        if cfg!(target_arch = \"wasm32\") {\n+            Timer::Disabled\n+        } else {\n+            Timer::Initialized(Instant::now())\n+        }\n+    }\n+    fn done_parsing(self) -> Self {\n+        match self {\n+            Timer::Disabled => Timer::Disabled,\n+            Timer::Initialized(init_time) => Timer::DoneParsing(init_time, Instant::now()),\n+            _ => panic!(\"Timer can only transition to DoneParsing from Initialized state\"),\n+        }\n+    }\n+\n+    fn done_formatting(self) -> Self {\n+        match self {\n+            Timer::Disabled => Timer::Disabled,\n+            Timer::DoneParsing(init_time, parse_time) => {\n+                Timer::DoneFormatting(init_time, parse_time, Instant::now())\n+            }\n+            _ => panic!(\"Timer can only transition to DoneFormatting from DoneParsing state\"),\n+        }\n+    }\n+\n+    /// Returns the time it took to parse the source files in seconds.\n+    fn get_parse_time(&self) -> f32 {\n+        match *self {\n+            Timer::Disabled => panic!(\"this platform cannot time execution\"),\n+            Timer::DoneParsing(init, parse_time) | Timer::DoneFormatting(init, parse_time, _) => {\n+                // This should never underflow since `Instant::now()` guarantees monotonicity.\n+                Self::duration_to_f32(parse_time.duration_since(init))\n+            }\n+            Timer::Initialized(..) => unreachable!(),\n+        }\n+    }\n+\n+    /// Returns the time it took to go from the parsed AST to the formatted output. Parsing time is\n+    /// not included.\n+    fn get_format_time(&self) -> f32 {\n+        match *self {\n+            Timer::Disabled => panic!(\"this platform cannot time execution\"),\n+            Timer::DoneFormatting(_init, parse_time, format_time) => {\n+                Self::duration_to_f32(format_time.duration_since(parse_time))\n+            }\n+            Timer::DoneParsing(..) | Timer::Initialized(..) => unreachable!(),\n+        }\n+    }\n+\n+    fn duration_to_f32(d: Duration) -> f32 {\n+        d.as_secs() as f32 + d.subsec_nanos() as f32 / 1_000_000_000f32\n+    }\n+}\n+\n+// Formatting done on a char by char or line by line basis.\n+// FIXME(#20): other stuff for parity with make tidy.\n+fn format_lines(\n+    text: &mut String,\n+    name: &FileName,\n+    skipped_range: &[(usize, usize)],\n+    config: &Config,\n+    report: &FormatReport,\n+) {\n+    let mut formatter = FormatLines::new(name, skipped_range, config);\n+    formatter.check_license(text);\n+    formatter.iterate(text);\n+\n+    if formatter.newline_count > 1 {\n+        debug!(\"track truncate: {} {}\", text.len(), formatter.newline_count);\n+        let line = text.len() - formatter.newline_count + 1;\n+        text.truncate(line);\n+    }\n+\n+    report.append(name.clone(), formatter.errors);\n+}\n+\n+struct FormatLines<'a> {\n+    name: &'a FileName,\n+    skipped_range: &'a [(usize, usize)],\n+    last_was_space: bool,\n+    line_len: usize,\n+    cur_line: usize,\n+    newline_count: usize,\n+    errors: Vec<FormattingError>,\n+    issue_seeker: BadIssueSeeker,\n+    line_buffer: String,\n+    current_line_contains_string_literal: bool,\n+    format_line: bool,\n+    allow_issue_seek: bool,\n+    config: &'a Config,\n+}\n+\n+impl<'a> FormatLines<'a> {\n+    fn new(\n+        name: &'a FileName,\n+        skipped_range: &'a [(usize, usize)],\n+        config: &'a Config,\n+    ) -> FormatLines<'a> {\n+        let issue_seeker = BadIssueSeeker::new(config.report_todo(), config.report_fixme());\n+        FormatLines {\n+            name,\n+            skipped_range,\n+            last_was_space: false,\n+            line_len: 0,\n+            cur_line: 1,\n+            newline_count: 0,\n+            errors: vec![],\n+            allow_issue_seek: !issue_seeker.is_disabled(),\n+            issue_seeker,\n+            line_buffer: String::with_capacity(config.max_width() * 2),\n+            current_line_contains_string_literal: false,\n+            format_line: config.file_lines().contains_line(name, 1),\n+            config,\n+        }\n+    }\n+\n+    fn check_license(&mut self, text: &mut String) {\n+        if let Some(ref license_template) = self.config.license_template {\n+            if !license_template.is_match(text) {\n+                self.errors.push(FormattingError {\n+                    line: self.cur_line,\n+                    kind: ErrorKind::LicenseCheck,\n+                    is_comment: false,\n+                    is_string: false,\n+                    line_buffer: String::new(),\n+                });\n+            }\n+        }\n+    }\n+\n+    // Iterate over the chars in the file map.\n+    fn iterate(&mut self, text: &mut String) {\n+        for (kind, c) in CharClasses::new(text.chars()) {\n+            if c == '\\r' {\n+                continue;\n+            }\n+\n+            if self.allow_issue_seek && self.format_line {\n+                // Add warnings for bad todos/ fixmes\n+                if let Some(issue) = self.issue_seeker.inspect(c) {\n+                    self.push_err(ErrorKind::BadIssue(issue), false, false);\n+                }\n+            }\n+\n+            if c == '\\n' {\n+                self.new_line(kind);\n+            } else {\n+                self.char(c, kind);\n+            }\n+        }\n+    }\n+\n+    fn new_line(&mut self, kind: FullCodeCharKind) {\n+        if self.format_line {\n+            // Check for (and record) trailing whitespace.\n+            if self.last_was_space {\n+                if self.should_report_error(kind, &ErrorKind::TrailingWhitespace)\n+                    && !self.is_skipped_line()\n+                {\n+                    self.push_err(\n+                        ErrorKind::TrailingWhitespace,\n+                        kind.is_comment(),\n+                        kind.is_string(),\n+                    );\n+                }\n+                self.line_len -= 1;\n+            }\n+\n+            // Check for any line width errors we couldn't correct.\n+            let error_kind = ErrorKind::LineOverflow(self.line_len, self.config.max_width());\n+            if self.line_len > self.config.max_width()\n+                && !self.is_skipped_line()\n+                && self.should_report_error(kind, &error_kind)\n+            {\n+                let is_string = self.current_line_contains_string_literal;\n+                self.push_err(error_kind, kind.is_comment(), is_string);\n+            }\n+        }\n+\n+        self.line_len = 0;\n+        self.cur_line += 1;\n+        self.format_line = self\n+            .config\n+            .file_lines()\n+            .contains_line(self.name, self.cur_line);\n+        self.newline_count += 1;\n+        self.last_was_space = false;\n+        self.line_buffer.clear();\n+        self.current_line_contains_string_literal = false;\n+    }\n+\n+    fn char(&mut self, c: char, kind: FullCodeCharKind) {\n+        self.newline_count = 0;\n+        self.line_len += if c == '\\t' {\n+            self.config.tab_spaces()\n+        } else {\n+            1\n+        };\n+        self.last_was_space = c.is_whitespace();\n+        self.line_buffer.push(c);\n+        if kind.is_string() {\n+            self.current_line_contains_string_literal = true;\n+        }\n+    }\n+\n+    fn push_err(&mut self, kind: ErrorKind, is_comment: bool, is_string: bool) {\n+        self.errors.push(FormattingError {\n+            line: self.cur_line,\n+            kind,\n+            is_comment,\n+            is_string,\n+            line_buffer: self.line_buffer.clone(),\n+        });\n+    }\n+\n+    fn should_report_error(&self, char_kind: FullCodeCharKind, error_kind: &ErrorKind) -> bool {\n+        let allow_error_report = if char_kind.is_comment()\n+            || self.current_line_contains_string_literal\n+            || error_kind.is_comment()\n+        {\n+            self.config.error_on_unformatted()\n+        } else {\n+            true\n+        };\n+\n+        match error_kind {\n+            ErrorKind::LineOverflow(..) => {\n+                self.config.error_on_line_overflow() && allow_error_report\n+            }\n+            ErrorKind::TrailingWhitespace | ErrorKind::LostComment => allow_error_report,\n+            _ => true,\n+        }\n+    }\n+\n+    /// Returns `true` if the line with the given line number was skipped by `#[rustfmt::skip]`.\n+    fn is_skipped_line(&self) -> bool {\n+        self.skipped_range\n+            .iter()\n+            .any(|&(lo, hi)| lo <= self.cur_line && self.cur_line <= hi)\n+    }\n+}\n+\n+fn should_emit_verbose<F>(forbid_verbose_output: bool, config: &Config, f: F)\n+where\n+    F: Fn(),\n+{\n+    if config.verbose() == Verbosity::Verbose && !forbid_verbose_output {\n+        f();\n+    }\n+}"}, {"sha": "ac62009490001ab8d5101cf6d2ddfd419e4c3f0b", "filename": "src/tools/rustfmt/src/formatting/newline_style.rs", "status": "added", "additions": 250, "deletions": 0, "changes": 250, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Fsrc%2Fformatting%2Fnewline_style.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Fsrc%2Fformatting%2Fnewline_style.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fsrc%2Fformatting%2Fnewline_style.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782", "patch": "@@ -0,0 +1,250 @@\n+use crate::NewlineStyle;\n+\n+/// Apply this newline style to the formatted text. When the style is set\n+/// to `Auto`, the `raw_input_text` is used to detect the existing line\n+/// endings.\n+///\n+/// If the style is set to `Auto` and `raw_input_text` contains no\n+/// newlines, the `Native` style will be used.\n+pub(crate) fn apply_newline_style(\n+    newline_style: NewlineStyle,\n+    formatted_text: &mut String,\n+    raw_input_text: &str,\n+) {\n+    *formatted_text = match effective_newline_style(newline_style, raw_input_text) {\n+        EffectiveNewlineStyle::Windows => convert_to_windows_newlines(formatted_text),\n+        EffectiveNewlineStyle::Unix => convert_to_unix_newlines(formatted_text),\n+    }\n+}\n+\n+#[derive(Debug, Copy, Clone, PartialEq, Eq)]\n+enum EffectiveNewlineStyle {\n+    Windows,\n+    Unix,\n+}\n+\n+fn effective_newline_style(\n+    newline_style: NewlineStyle,\n+    raw_input_text: &str,\n+) -> EffectiveNewlineStyle {\n+    match newline_style {\n+        NewlineStyle::Auto => auto_detect_newline_style(raw_input_text),\n+        NewlineStyle::Native => native_newline_style(),\n+        NewlineStyle::Windows => EffectiveNewlineStyle::Windows,\n+        NewlineStyle::Unix => EffectiveNewlineStyle::Unix,\n+    }\n+}\n+\n+const LINE_FEED: char = '\\n';\n+const CARRIAGE_RETURN: char = '\\r';\n+const WINDOWS_NEWLINE: &str = \"\\r\\n\";\n+const UNIX_NEWLINE: &str = \"\\n\";\n+\n+fn auto_detect_newline_style(raw_input_text: &str) -> EffectiveNewlineStyle {\n+    let first_line_feed_pos = raw_input_text.chars().position(|ch| ch == LINE_FEED);\n+    match first_line_feed_pos {\n+        Some(first_line_feed_pos) => {\n+            let char_before_line_feed_pos = first_line_feed_pos.saturating_sub(1);\n+            let char_before_line_feed = raw_input_text.chars().nth(char_before_line_feed_pos);\n+            match char_before_line_feed {\n+                Some(CARRIAGE_RETURN) => EffectiveNewlineStyle::Windows,\n+                _ => EffectiveNewlineStyle::Unix,\n+            }\n+        }\n+        None => native_newline_style(),\n+    }\n+}\n+\n+fn native_newline_style() -> EffectiveNewlineStyle {\n+    if cfg!(windows) {\n+        EffectiveNewlineStyle::Windows\n+    } else {\n+        EffectiveNewlineStyle::Unix\n+    }\n+}\n+\n+fn convert_to_windows_newlines(formatted_text: &String) -> String {\n+    let mut transformed = String::with_capacity(2 * formatted_text.capacity());\n+    let mut chars = formatted_text.chars().peekable();\n+    while let Some(current_char) = chars.next() {\n+        let next_char = chars.peek();\n+        match current_char {\n+            LINE_FEED => transformed.push_str(WINDOWS_NEWLINE),\n+            CARRIAGE_RETURN if next_char == Some(&LINE_FEED) => {}\n+            current_char => transformed.push(current_char),\n+        }\n+    }\n+    transformed\n+}\n+\n+fn convert_to_unix_newlines(formatted_text: &String) -> String {\n+    formatted_text.replace(WINDOWS_NEWLINE, UNIX_NEWLINE)\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+\n+    #[test]\n+    fn auto_detects_unix_newlines() {\n+        assert_eq!(\n+            EffectiveNewlineStyle::Unix,\n+            auto_detect_newline_style(\"One\\nTwo\\nThree\")\n+        );\n+    }\n+\n+    #[test]\n+    fn auto_detects_windows_newlines() {\n+        assert_eq!(\n+            EffectiveNewlineStyle::Windows,\n+            auto_detect_newline_style(\"One\\r\\nTwo\\r\\nThree\")\n+        );\n+    }\n+\n+    #[test]\n+    fn auto_detects_windows_newlines_with_multibyte_char_on_first_line() {\n+        assert_eq!(\n+            EffectiveNewlineStyle::Windows,\n+            auto_detect_newline_style(\"A \ud83c\udfa2 of a first line\\r\\nTwo\\r\\nThree\")\n+        );\n+    }\n+\n+    #[test]\n+    fn falls_back_to_native_newlines_if_no_newlines_are_found() {\n+        let expected_newline_style = if cfg!(windows) {\n+            EffectiveNewlineStyle::Windows\n+        } else {\n+            EffectiveNewlineStyle::Unix\n+        };\n+        assert_eq!(\n+            expected_newline_style,\n+            auto_detect_newline_style(\"One Two Three\")\n+        );\n+    }\n+\n+    #[test]\n+    fn auto_detects_and_applies_unix_newlines() {\n+        let formatted_text = \"One\\nTwo\\nThree\";\n+        let raw_input_text = \"One\\nTwo\\nThree\";\n+\n+        let mut out = String::from(formatted_text);\n+        apply_newline_style(NewlineStyle::Auto, &mut out, raw_input_text);\n+        assert_eq!(\"One\\nTwo\\nThree\", &out, \"auto should detect 'lf'\");\n+    }\n+\n+    #[test]\n+    fn auto_detects_and_applies_windows_newlines() {\n+        let formatted_text = \"One\\nTwo\\nThree\";\n+        let raw_input_text = \"One\\r\\nTwo\\r\\nThree\";\n+\n+        let mut out = String::from(formatted_text);\n+        apply_newline_style(NewlineStyle::Auto, &mut out, raw_input_text);\n+        assert_eq!(\"One\\r\\nTwo\\r\\nThree\", &out, \"auto should detect 'crlf'\");\n+    }\n+\n+    #[test]\n+    fn auto_detects_and_applies_native_newlines() {\n+        let formatted_text = \"One\\nTwo\\nThree\";\n+        let raw_input_text = \"One Two Three\";\n+\n+        let mut out = String::from(formatted_text);\n+        apply_newline_style(NewlineStyle::Auto, &mut out, raw_input_text);\n+\n+        if cfg!(windows) {\n+            assert_eq!(\n+                \"One\\r\\nTwo\\r\\nThree\", &out,\n+                \"auto-native-windows should detect 'crlf'\"\n+            );\n+        } else {\n+            assert_eq!(\n+                \"One\\nTwo\\nThree\", &out,\n+                \"auto-native-unix should detect 'lf'\"\n+            );\n+        }\n+    }\n+\n+    #[test]\n+    fn applies_unix_newlines() {\n+        test_newlines_are_applied_correctly(\n+            \"One\\r\\nTwo\\nThree\",\n+            \"One\\nTwo\\nThree\",\n+            NewlineStyle::Unix,\n+        );\n+    }\n+\n+    #[test]\n+    fn applying_unix_newlines_changes_nothing_for_unix_newlines() {\n+        let formatted_text = \"One\\nTwo\\nThree\";\n+        test_newlines_are_applied_correctly(formatted_text, formatted_text, NewlineStyle::Unix);\n+    }\n+\n+    #[test]\n+    fn applies_unix_newlines_to_string_with_unix_and_windows_newlines() {\n+        test_newlines_are_applied_correctly(\n+            \"One\\r\\nTwo\\r\\nThree\\nFour\",\n+            \"One\\nTwo\\nThree\\nFour\",\n+            NewlineStyle::Unix,\n+        );\n+    }\n+\n+    #[test]\n+    fn applies_windows_newlines_to_string_with_unix_and_windows_newlines() {\n+        test_newlines_are_applied_correctly(\n+            \"One\\nTwo\\nThree\\r\\nFour\",\n+            \"One\\r\\nTwo\\r\\nThree\\r\\nFour\",\n+            NewlineStyle::Windows,\n+        );\n+    }\n+\n+    #[test]\n+    fn applying_windows_newlines_changes_nothing_for_windows_newlines() {\n+        let formatted_text = \"One\\r\\nTwo\\r\\nThree\";\n+        test_newlines_are_applied_correctly(formatted_text, formatted_text, NewlineStyle::Windows);\n+    }\n+\n+    #[test]\n+    fn keeps_carriage_returns_when_applying_windows_newlines_to_str_with_unix_newlines() {\n+        test_newlines_are_applied_correctly(\n+            \"One\\nTwo\\nThree\\rDrei\",\n+            \"One\\r\\nTwo\\r\\nThree\\rDrei\",\n+            NewlineStyle::Windows,\n+        );\n+    }\n+\n+    #[test]\n+    fn keeps_carriage_returns_when_applying_unix_newlines_to_str_with_unix_newlines() {\n+        test_newlines_are_applied_correctly(\n+            \"One\\nTwo\\nThree\\rDrei\",\n+            \"One\\nTwo\\nThree\\rDrei\",\n+            NewlineStyle::Unix,\n+        );\n+    }\n+\n+    #[test]\n+    fn keeps_carriage_returns_when_applying_windows_newlines_to_str_with_windows_newlines() {\n+        test_newlines_are_applied_correctly(\n+            \"One\\r\\nTwo\\r\\nThree\\rDrei\",\n+            \"One\\r\\nTwo\\r\\nThree\\rDrei\",\n+            NewlineStyle::Windows,\n+        );\n+    }\n+\n+    #[test]\n+    fn keeps_carriage_returns_when_applying_unix_newlines_to_str_with_windows_newlines() {\n+        test_newlines_are_applied_correctly(\n+            \"One\\r\\nTwo\\r\\nThree\\rDrei\",\n+            \"One\\nTwo\\nThree\\rDrei\",\n+            NewlineStyle::Unix,\n+        );\n+    }\n+\n+    fn test_newlines_are_applied_correctly(\n+        input: &str,\n+        expected: &str,\n+        newline_style: NewlineStyle,\n+    ) {\n+        let mut out = String::from(input);\n+        apply_newline_style(newline_style, &mut out, input);\n+        assert_eq!(expected, &out);\n+    }\n+}"}, {"sha": "16f5d1dd4f234fe17091843ebcfa8133bacffaaa", "filename": "src/tools/rustfmt/src/git-rustfmt/main.rs", "status": "added", "additions": 192, "deletions": 0, "changes": 192, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Fsrc%2Fgit-rustfmt%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Fsrc%2Fgit-rustfmt%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fsrc%2Fgit-rustfmt%2Fmain.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782", "patch": "@@ -0,0 +1,192 @@\n+#[macro_use]\n+extern crate log;\n+\n+use std::env;\n+use std::io::stdout;\n+use std::path::{Path, PathBuf};\n+use std::process::Command;\n+use std::str::FromStr;\n+\n+use getopts::{Matches, Options};\n+use rustfmt_nightly as rustfmt;\n+\n+use crate::rustfmt::{load_config, CliOptions, FormatReportFormatterBuilder, Input, Session};\n+\n+fn prune_files(files: Vec<&str>) -> Vec<&str> {\n+    let prefixes: Vec<_> = files\n+        .iter()\n+        .filter(|f| f.ends_with(\"mod.rs\") || f.ends_with(\"lib.rs\"))\n+        .map(|f| &f[..f.len() - 6])\n+        .collect();\n+\n+    let mut pruned_prefixes = vec![];\n+    for p1 in prefixes {\n+        if p1.starts_with(\"src/bin/\") || pruned_prefixes.iter().all(|p2| !p1.starts_with(p2)) {\n+            pruned_prefixes.push(p1);\n+        }\n+    }\n+    debug!(\"prefixes: {:?}\", pruned_prefixes);\n+\n+    files\n+        .into_iter()\n+        .filter(|f| {\n+            if f.ends_with(\"mod.rs\") || f.ends_with(\"lib.rs\") || f.starts_with(\"src/bin/\") {\n+                return true;\n+            }\n+            pruned_prefixes.iter().all(|pp| !f.starts_with(pp))\n+        })\n+        .collect()\n+}\n+\n+fn git_diff(commits: &str) -> String {\n+    let mut cmd = Command::new(\"git\");\n+    cmd.arg(\"diff\");\n+    if commits != \"0\" {\n+        cmd.arg(format!(\"HEAD~{}\", commits));\n+    }\n+    let output = cmd.output().expect(\"Couldn't execute `git diff`\");\n+    String::from_utf8_lossy(&output.stdout).into_owned()\n+}\n+\n+fn get_files(input: &str) -> Vec<&str> {\n+    input\n+        .lines()\n+        .filter(|line| line.starts_with(\"+++ b/\") && line.ends_with(\".rs\"))\n+        .map(|line| &line[6..])\n+        .collect()\n+}\n+\n+fn fmt_files(files: &[&str]) -> i32 {\n+    let (config, _) =\n+        load_config::<NullOptions>(Some(Path::new(\".\")), None).expect(\"couldn't load config\");\n+\n+    let mut exit_code = 0;\n+    let mut out = stdout();\n+    let mut session = Session::new(config, Some(&mut out));\n+    for file in files {\n+        let report = session.format(Input::File(PathBuf::from(file))).unwrap();\n+        if report.has_warnings() {\n+            eprintln!(\"{}\", FormatReportFormatterBuilder::new(&report).build());\n+        }\n+        if !session.has_no_errors() {\n+            exit_code = 1;\n+        }\n+    }\n+    exit_code\n+}\n+\n+struct NullOptions;\n+\n+impl CliOptions for NullOptions {\n+    fn apply_to(self, _: &mut rustfmt::Config) {\n+        unreachable!();\n+    }\n+    fn config_path(&self) -> Option<&Path> {\n+        unreachable!();\n+    }\n+}\n+\n+fn uncommitted_files() -> Vec<String> {\n+    let mut cmd = Command::new(\"git\");\n+    cmd.arg(\"ls-files\");\n+    cmd.arg(\"--others\");\n+    cmd.arg(\"--modified\");\n+    cmd.arg(\"--exclude-standard\");\n+    let output = cmd.output().expect(\"Couldn't execute Git\");\n+    let stdout = String::from_utf8_lossy(&output.stdout);\n+    stdout\n+        .lines()\n+        .filter(|s| s.ends_with(\".rs\"))\n+        .map(std::borrow::ToOwned::to_owned)\n+        .collect()\n+}\n+\n+fn check_uncommitted() {\n+    let uncommitted = uncommitted_files();\n+    debug!(\"uncommitted files: {:?}\", uncommitted);\n+    if !uncommitted.is_empty() {\n+        println!(\"Found untracked changes:\");\n+        for f in &uncommitted {\n+            println!(\"  {}\", f);\n+        }\n+        println!(\"Commit your work, or run with `-u`.\");\n+        println!(\"Exiting.\");\n+        std::process::exit(1);\n+    }\n+}\n+\n+fn make_opts() -> Options {\n+    let mut opts = Options::new();\n+    opts.optflag(\"h\", \"help\", \"show this message\");\n+    opts.optflag(\"c\", \"check\", \"check only, don't format (unimplemented)\");\n+    opts.optflag(\"u\", \"uncommitted\", \"format uncommitted files\");\n+    opts\n+}\n+\n+struct Config {\n+    commits: String,\n+    uncommitted: bool,\n+}\n+\n+impl Config {\n+    fn from_args(matches: &Matches, opts: &Options) -> Config {\n+        // `--help` display help message and quit\n+        if matches.opt_present(\"h\") {\n+            let message = format!(\n+                \"\\nusage: {} <commits> [options]\\n\\n\\\n+                 commits: number of commits to format, default: 1\",\n+                env::args_os().next().unwrap().to_string_lossy()\n+            );\n+            println!(\"{}\", opts.usage(&message));\n+            std::process::exit(0);\n+        }\n+\n+        let mut config = Config {\n+            commits: \"1\".to_owned(),\n+            uncommitted: false,\n+        };\n+\n+        if matches.opt_present(\"c\") {\n+            unimplemented!();\n+        }\n+\n+        if matches.opt_present(\"u\") {\n+            config.uncommitted = true;\n+        }\n+\n+        if matches.free.len() > 1 {\n+            panic!(\"unknown arguments, use `-h` for usage\");\n+        }\n+        if matches.free.len() == 1 {\n+            let commits = matches.free[0].trim();\n+            if u32::from_str(commits).is_err() {\n+                panic!(\"Couldn't parse number of commits\");\n+            }\n+            config.commits = commits.to_owned();\n+        }\n+\n+        config\n+    }\n+}\n+\n+fn main() {\n+    env_logger::init();\n+\n+    let opts = make_opts();\n+    let matches = opts\n+        .parse(env::args().skip(1))\n+        .expect(\"Couldn't parse command line\");\n+    let config = Config::from_args(&matches, &opts);\n+\n+    if !config.uncommitted {\n+        check_uncommitted();\n+    }\n+\n+    let stdout = git_diff(&config.commits);\n+    let files = get_files(&stdout);\n+    debug!(\"files: {:?}\", files);\n+    let files = prune_files(files);\n+    debug!(\"pruned files: {:?}\", files);\n+    let exit_code = fmt_files(&files);\n+    std::process::exit(exit_code);\n+}"}, {"sha": "d8974e12b8f5f4fe07742214ec1f28f2e41ddae2", "filename": "src/tools/rustfmt/src/ignore_path.rs", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Fsrc%2Fignore_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Fsrc%2Fignore_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fsrc%2Fignore_path.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "0f635fe1ccb3584210a21debfaa5f423384f556a", "filename": "src/tools/rustfmt/src/imports.rs", "status": "added", "additions": 1210, "deletions": 0, "changes": 1210, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Fsrc%2Fimports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Fsrc%2Fimports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fsrc%2Fimports.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "d369b75541ef90fa2756bde652dad1c8073f64ba", "filename": "src/tools/rustfmt/src/issues.rs", "status": "added", "additions": 317, "deletions": 0, "changes": 317, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Fsrc%2Fissues.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Fsrc%2Fissues.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fsrc%2Fissues.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "ecbd0bd12ec6efd7c05c98e7defca1c2270672c2", "filename": "src/tools/rustfmt/src/items.rs", "status": "added", "additions": 3291, "deletions": 0, "changes": 3291, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Fsrc%2Fitems.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Fsrc%2Fitems.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fsrc%2Fitems.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "8a798777e0e80c32d2a2b8c57a180cd9e7f70643", "filename": "src/tools/rustfmt/src/lib.rs", "status": "added", "additions": 670, "deletions": 0, "changes": 670, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fsrc%2Flib.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "ccf8f784c04545c90e6d35ffe55d89453685c6cf", "filename": "src/tools/rustfmt/src/lists.rs", "status": "added", "additions": 930, "deletions": 0, "changes": 930, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Fsrc%2Flists.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Fsrc%2Flists.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fsrc%2Flists.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "bf4769b34aa84a7554f5b0c4144626c64cc47c80", "filename": "src/tools/rustfmt/src/macros.rs", "status": "added", "additions": 1612, "deletions": 0, "changes": 1612, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Fsrc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Fsrc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fsrc%2Fmacros.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "f33fedce92da55ff86a3ec270e2d39e3c2b0137a", "filename": "src/tools/rustfmt/src/matches.rs", "status": "added", "additions": 596, "deletions": 0, "changes": 596, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Fsrc%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Fsrc%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fsrc%2Fmatches.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "17b11ed6cf49cd69c2d6afc62891048bd18a52bc", "filename": "src/tools/rustfmt/src/missed_spans.rs", "status": "added", "additions": 361, "deletions": 0, "changes": 361, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Fsrc%2Fmissed_spans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Fsrc%2Fmissed_spans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fsrc%2Fmissed_spans.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "c3f44068601359dadc6295de990d30abf134e210", "filename": "src/tools/rustfmt/src/modules.rs", "status": "added", "additions": 552, "deletions": 0, "changes": 552, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Fsrc%2Fmodules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Fsrc%2Fmodules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fsrc%2Fmodules.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "d5acf3f1cbcb46aee36f0237b3ac1592f34e380e", "filename": "src/tools/rustfmt/src/modules/visitor.rs", "status": "added", "additions": 108, "deletions": 0, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Fsrc%2Fmodules%2Fvisitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Fsrc%2Fmodules%2Fvisitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fsrc%2Fmodules%2Fvisitor.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "d670b0a41e8186ac40abb7a322bf38acfd81ae64", "filename": "src/tools/rustfmt/src/overflow.rs", "status": "added", "additions": 786, "deletions": 0, "changes": 786, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Fsrc%2Foverflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Fsrc%2Foverflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fsrc%2Foverflow.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "0f3d5e8f878ba7d7f08883e95c40262bf2d8adfa", "filename": "src/tools/rustfmt/src/pairs.rs", "status": "added", "additions": 318, "deletions": 0, "changes": 318, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Fsrc%2Fpairs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Fsrc%2Fpairs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fsrc%2Fpairs.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "6824fc661ba72581d7d7fe869d6e7dc8175a3235", "filename": "src/tools/rustfmt/src/patterns.rs", "status": "added", "additions": 525, "deletions": 0, "changes": 525, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Fsrc%2Fpatterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Fsrc%2Fpatterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fsrc%2Fpatterns.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "948247b3c9700e7732408be7d8f8ba367c1c53c0", "filename": "src/tools/rustfmt/src/release_channel.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Fsrc%2Frelease_channel.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Fsrc%2Frelease_channel.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fsrc%2Frelease_channel.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "ac65ff2c1086e853edfd5e10ac355fe93631657c", "filename": "src/tools/rustfmt/src/reorder.rs", "status": "added", "additions": 332, "deletions": 0, "changes": 332, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Fsrc%2Freorder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Fsrc%2Freorder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fsrc%2Freorder.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "c8abe70141b5c90665b11ca7f0f0628869f7c060", "filename": "src/tools/rustfmt/src/rewrite.rs", "status": "added", "additions": 98, "deletions": 0, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Fsrc%2Frewrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Fsrc%2Frewrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fsrc%2Frewrite.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "fc2c7d06e264ef269a2fc2a26f4916ba7d4159d0", "filename": "src/tools/rustfmt/src/rustfmt_diff.rs", "status": "added", "additions": 403, "deletions": 0, "changes": 403, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Fsrc%2Frustfmt_diff.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Fsrc%2Frustfmt_diff.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fsrc%2Frustfmt_diff.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "4376fd12b526005706f526bcc3252446f8cf74c0", "filename": "src/tools/rustfmt/src/shape.rs", "status": "added", "additions": 373, "deletions": 0, "changes": 373, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Fsrc%2Fshape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Fsrc%2Fshape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fsrc%2Fshape.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "6c500635a9551dec165511d10f05a1d4b85b3d53", "filename": "src/tools/rustfmt/src/skip.rs", "status": "added", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Fsrc%2Fskip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Fsrc%2Fskip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fsrc%2Fskip.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "5a9a2cbd80c7ec3132e93c054fc7ed1849dd10be", "filename": "src/tools/rustfmt/src/source_file.rs", "status": "added", "additions": 105, "deletions": 0, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Fsrc%2Fsource_file.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Fsrc%2Fsource_file.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fsrc%2Fsource_file.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "76e0d24cf1eb6d325cb2201e7f179888f25fbace", "filename": "src/tools/rustfmt/src/source_map.rs", "status": "added", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Fsrc%2Fsource_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Fsrc%2Fsource_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fsrc%2Fsource_map.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "7e3786b7cd94cd344660863b9f083a3d0e89b9e2", "filename": "src/tools/rustfmt/src/spanned.rs", "status": "added", "additions": 206, "deletions": 0, "changes": 206, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Fsrc%2Fspanned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Fsrc%2Fspanned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fsrc%2Fspanned.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "0b3854425ea5fe816a1c871755c7f1a21a3029bf", "filename": "src/tools/rustfmt/src/stmt.rs", "status": "added", "additions": 116, "deletions": 0, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Fsrc%2Fstmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Fsrc%2Fstmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fsrc%2Fstmt.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "080c4f17788237879a01a27657b5d1bbe05562e8", "filename": "src/tools/rustfmt/src/string.rs", "status": "added", "additions": 691, "deletions": 0, "changes": 691, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Fsrc%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Fsrc%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fsrc%2Fstring.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "845576bd8d8bb1ea5015db3c864fefcb0194b22e", "filename": "src/tools/rustfmt/src/syntux.rs", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Fsrc%2Fsyntux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Fsrc%2Fsyntux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fsrc%2Fsyntux.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "0b94749f3c6f4a04721965e8d043a50885ed0f83", "filename": "src/tools/rustfmt/src/syntux/parser.rs", "status": "added", "additions": 263, "deletions": 0, "changes": 263, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Fsrc%2Fsyntux%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Fsrc%2Fsyntux%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fsrc%2Fsyntux%2Fparser.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "870f0acfe395c527bd0e0a6fee9c833073e766ba", "filename": "src/tools/rustfmt/src/syntux/session.rs", "status": "added", "additions": 463, "deletions": 0, "changes": 463, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Fsrc%2Fsyntux%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Fsrc%2Fsyntux%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fsrc%2Fsyntux%2Fsession.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "ef7dd0ddcd123b6c2abbbff3e5d4afd7e1036f80", "filename": "src/tools/rustfmt/src/test/configuration_snippet.rs", "status": "added", "additions": 287, "deletions": 0, "changes": 287, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Fsrc%2Ftest%2Fconfiguration_snippet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Fsrc%2Ftest%2Fconfiguration_snippet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fsrc%2Ftest%2Fconfiguration_snippet.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "ce56a223f2b04d671431bec25fdb41a0d84e521c", "filename": "src/tools/rustfmt/src/test/mod.rs", "status": "added", "additions": 905, "deletions": 0, "changes": 905, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Fsrc%2Ftest%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Fsrc%2Ftest%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fsrc%2Ftest%2Fmod.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "ae4a4f94d928011563e8c12cad61d5bfcdaaac64", "filename": "src/tools/rustfmt/src/test/parser.rs", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Fsrc%2Ftest%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Fsrc%2Ftest%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fsrc%2Ftest%2Fparser.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "cda17e13eebb0593dd145ad1f856e8cef81883b3", "filename": "src/tools/rustfmt/src/types.rs", "status": "added", "additions": 1051, "deletions": 0, "changes": 1051, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fsrc%2Ftypes.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "d3c349fb701e18050e574a9d35e69debf5845799", "filename": "src/tools/rustfmt/src/utils.rs", "status": "added", "additions": 706, "deletions": 0, "changes": 706, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Fsrc%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Fsrc%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fsrc%2Futils.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "c4208848c6c2ab3ad6bbaf5414109ca7f5cba5dd", "filename": "src/tools/rustfmt/src/vertical.rs", "status": "added", "additions": 285, "deletions": 0, "changes": 285, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Fsrc%2Fvertical.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Fsrc%2Fvertical.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fsrc%2Fvertical.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "079568630cf52f42fd107964bbbb3cdf4dd45b0c", "filename": "src/tools/rustfmt/src/visitor.rs", "status": "added", "additions": 1075, "deletions": 0, "changes": 1075, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Fsrc%2Fvisitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Fsrc%2Fvisitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fsrc%2Fvisitor.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "5493b09e4aa63a177f809837070a353e5ca2a13f", "filename": "src/tools/rustfmt/tests/cargo-fmt/main.rs", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fcargo-fmt%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fcargo-fmt%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fcargo-fmt%2Fmain.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "c7ad93bafe36c0080f9361212af31837849fbbc5", "filename": "src/tools/rustfmt/tests/config/disable_all_formatting.toml", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fconfig%2Fdisable_all_formatting.toml", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fconfig%2Fdisable_all_formatting.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fconfig%2Fdisable_all_formatting.toml?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "44148a2d3c3ed6bc75e28e1c55eec63f4d720698", "filename": "src/tools/rustfmt/tests/config/issue-1111.toml", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fconfig%2Fissue-1111.toml", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fconfig%2Fissue-1111.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fconfig%2Fissue-1111.toml?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "11c9dca8a06c969f05c1f42fc7abd8f0d64c341a", "filename": "src/tools/rustfmt/tests/config/issue-2641.toml", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fconfig%2Fissue-2641.toml", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fconfig%2Fissue-2641.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fconfig%2Fissue-2641.toml?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "6ca52aee32265683fd20a5380034449edd608e7a", "filename": "src/tools/rustfmt/tests/config/issue-3779.toml", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fconfig%2Fissue-3779.toml", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fconfig%2Fissue-3779.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fconfig%2Fissue-3779.toml?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "74ee8b010dd054ec1bdf80f0ca81f87a67cbf669", "filename": "src/tools/rustfmt/tests/config/issue-3802.toml", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fconfig%2Fissue-3802.toml", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fconfig%2Fissue-3802.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fconfig%2Fissue-3802.toml?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "f52930d50b61e2dcf59e298aebfe40eab76918fb", "filename": "src/tools/rustfmt/tests/config/skip_children.toml", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fconfig%2Fskip_children.toml", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fconfig%2Fskip_children.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fconfig%2Fskip_children.toml?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "35c8fd8646765754a9329e2420df43b4f30f5a1d", "filename": "src/tools/rustfmt/tests/config/small_tabs.toml", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fconfig%2Fsmall_tabs.toml", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fconfig%2Fsmall_tabs.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fconfig%2Fsmall_tabs.toml?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "10940039e8eabf279d1bb9504bd493a59410d85a", "filename": "src/tools/rustfmt/tests/coverage/source/comments.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fcoverage%2Fsource%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fcoverage%2Fsource%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fcoverage%2Fsource%2Fcomments.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "95e7b4705e3a0e0cb8906d0c13f0d18b93cd052a", "filename": "src/tools/rustfmt/tests/coverage/target/comments.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fcoverage%2Ftarget%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fcoverage%2Ftarget%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fcoverage%2Ftarget%2Fcomments.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "ea4390371a09adad8f9b2cc69af1ee917afb0b54", "filename": "src/tools/rustfmt/tests/license-template/lt.txt", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Flicense-template%2Flt.txt", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Flicense-template%2Flt.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Flicense-template%2Flt.txt?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "7709c8484642d1b9703f53d388a5c277493ba27b", "filename": "src/tools/rustfmt/tests/parser/issue-4126/invalid.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fparser%2Fissue-4126%2Finvalid.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fparser%2Fissue-4126%2Finvalid.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fparser%2Fissue-4126%2Finvalid.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "aac63e3557fea6498a40a441631968da1d2a825c", "filename": "src/tools/rustfmt/tests/parser/issue-4126/lib.rs", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fparser%2Fissue-4126%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fparser%2Fissue-4126%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fparser%2Fissue-4126%2Flib.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "ff30235f076b3fde71fba6ceafa0f510e0006261", "filename": "src/tools/rustfmt/tests/parser/issue_4418.rs", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fparser%2Fissue_4418.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fparser%2Fissue_4418.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fparser%2Fissue_4418.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "2c2c81c91d1967f268105dcb3024380a8eb2a595", "filename": "src/tools/rustfmt/tests/parser/unclosed-delims/issue_4466.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fparser%2Funclosed-delims%2Fissue_4466.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fparser%2Funclosed-delims%2Fissue_4466.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fparser%2Funclosed-delims%2Fissue_4466.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "8effb1c6fcab640f997c8975b9ce0ed034f96d36", "filename": "src/tools/rustfmt/tests/rustfmt/main.rs", "status": "added", "additions": 108, "deletions": 0, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Frustfmt%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Frustfmt%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Frustfmt%2Fmain.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "77fb2919edbd133b5b3b04ef8ad78329fa04a320", "filename": "src/tools/rustfmt/tests/source/alignment_2633/block_style.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Falignment_2633%2Fblock_style.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Falignment_2633%2Fblock_style.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Falignment_2633%2Fblock_style.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "f34cc621e64c0f372245b5e06a1e5c3448886c38", "filename": "src/tools/rustfmt/tests/source/alignment_2633/visual_style.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Falignment_2633%2Fvisual_style.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Falignment_2633%2Fvisual_style.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Falignment_2633%2Fvisual_style.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "87372b2793fc13ce05dcb0e2fd92a4caddd37459", "filename": "src/tools/rustfmt/tests/source/array_comment.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Farray_comment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Farray_comment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Farray_comment.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "71de325566dd56877b030a0384e8f649e5cb9482", "filename": "src/tools/rustfmt/tests/source/assignment.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fassignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fassignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fassignment.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "464f428c7f9a15a87108df52d0b03cc9c0ba208f", "filename": "src/tools/rustfmt/tests/source/associated-types-bounds-wrapping.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fassociated-types-bounds-wrapping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fassociated-types-bounds-wrapping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fassociated-types-bounds-wrapping.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "8572778a5a534449436739c476623d35e4272c1e", "filename": "src/tools/rustfmt/tests/source/associated_type_bounds.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fassociated_type_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fassociated_type_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fassociated_type_bounds.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "3de51a084d260f39458ce22ee1fe72d39b8abe6b", "filename": "src/tools/rustfmt/tests/source/async_block.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fasync_block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fasync_block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fasync_block.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "c63cf5b0f51e1dc8834bdf3139802a0b37e18179", "filename": "src/tools/rustfmt/tests/source/async_fn.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fasync_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fasync_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fasync_fn.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "d45fba5522436ce6d6a5b3287d86d5259482cd76", "filename": "src/tools/rustfmt/tests/source/attrib.rs", "status": "added", "additions": 234, "deletions": 0, "changes": 234, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fattrib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fattrib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fattrib.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "f71e6515c429ecd4b848b14a28f29fcafd01e714", "filename": "src/tools/rustfmt/tests/source/big-impl-block.rs", "status": "added", "additions": 123, "deletions": 0, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fbig-impl-block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fbig-impl-block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fbig-impl-block.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "7d906ac37f998e76c31c3db1fec4277d4c7e17a9", "filename": "src/tools/rustfmt/tests/source/big-impl-visual.rs", "status": "added", "additions": 106, "deletions": 0, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fbig-impl-visual.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fbig-impl-visual.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fbig-impl-visual.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "f7502931d9693ef88c37dcd0e1f1fad6269c5bf8", "filename": "src/tools/rustfmt/tests/source/binary-expr.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fbinary-expr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fbinary-expr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fbinary-expr.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "c01d8a0784556d93b4b6af8c00f8aecf5906ce4a", "filename": "src/tools/rustfmt/tests/source/break-and-continue.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fbreak-and-continue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fbreak-and-continue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fbreak-and-continue.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "541db1dc90c226889569ce151bc51b6c6b629b95", "filename": "src/tools/rustfmt/tests/source/catch.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fcatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fcatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fcatch.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "ebae2bd28540806c6d9645b08964a654919c4604", "filename": "src/tools/rustfmt/tests/source/cfg_if/detect/arch/aarch64.rs", "status": "added", "additions": 106, "deletions": 0, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fcfg_if%2Fdetect%2Farch%2Faarch64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fcfg_if%2Fdetect%2Farch%2Faarch64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fcfg_if%2Fdetect%2Farch%2Faarch64.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "b2626bf2923b6660cbf5fde8d502fabd71ac14be", "filename": "src/tools/rustfmt/tests/source/cfg_if/detect/arch/arm.rs", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fcfg_if%2Fdetect%2Farch%2Farm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fcfg_if%2Fdetect%2Farch%2Farm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fcfg_if%2Fdetect%2Farch%2Farm.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "f4381b811cdf2462f11e3934cdf27a534bf61d70", "filename": "src/tools/rustfmt/tests/source/cfg_if/detect/arch/mips.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fcfg_if%2Fdetect%2Farch%2Fmips.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fcfg_if%2Fdetect%2Farch%2Fmips.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fcfg_if%2Fdetect%2Farch%2Fmips.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "2663bc68ba980cd4a8ec71ad3f69a3f5c7f32a4b", "filename": "src/tools/rustfmt/tests/source/cfg_if/detect/arch/mips64.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fcfg_if%2Fdetect%2Farch%2Fmips64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fcfg_if%2Fdetect%2Farch%2Fmips64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fcfg_if%2Fdetect%2Farch%2Fmips64.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "a342dc1aacc0ccb2fa03a0812b38615d6846750f", "filename": "src/tools/rustfmt/tests/source/cfg_if/detect/arch/powerpc.rs", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fcfg_if%2Fdetect%2Farch%2Fpowerpc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fcfg_if%2Fdetect%2Farch%2Fpowerpc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fcfg_if%2Fdetect%2Farch%2Fpowerpc.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "2e82c569252ac9608f48475ec92346ff53c6fd5d", "filename": "src/tools/rustfmt/tests/source/cfg_if/detect/arch/powerpc64.rs", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fcfg_if%2Fdetect%2Farch%2Fpowerpc64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fcfg_if%2Fdetect%2Farch%2Fpowerpc64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fcfg_if%2Fdetect%2Farch%2Fpowerpc64.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "50d5cfa87c4c8c2a892271bd17045edadc5a391c", "filename": "src/tools/rustfmt/tests/source/cfg_if/detect/arch/x86.rs", "status": "added", "additions": 348, "deletions": 0, "changes": 348, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fcfg_if%2Fdetect%2Farch%2Fx86.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fcfg_if%2Fdetect%2Farch%2Fx86.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fcfg_if%2Fdetect%2Farch%2Fx86.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "578f0b16b742ae5eb16ffc1b99f41c6b88dcf2cc", "filename": "src/tools/rustfmt/tests/source/cfg_if/detect/bit.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fcfg_if%2Fdetect%2Fbit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fcfg_if%2Fdetect%2Fbit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fcfg_if%2Fdetect%2Fbit.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "92bc4b58d167771726e22e5c2418a1eebbccc602", "filename": "src/tools/rustfmt/tests/source/cfg_if/detect/cache.rs", "status": "added", "additions": 164, "deletions": 0, "changes": 164, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fcfg_if%2Fdetect%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fcfg_if%2Fdetect%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fcfg_if%2Fdetect%2Fcache.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "6769757ed93319f76e44aa726c24cf1c2b40d4f6", "filename": "src/tools/rustfmt/tests/source/cfg_if/detect/error_macros.rs", "status": "added", "additions": 150, "deletions": 0, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fcfg_if%2Fdetect%2Ferror_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fcfg_if%2Fdetect%2Ferror_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fcfg_if%2Fdetect%2Ferror_macros.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "f446e88eedc8ca1174cd80919e8dd22cee5771b3", "filename": "src/tools/rustfmt/tests/source/cfg_if/detect/mod.rs", "status": "added", "additions": 85, "deletions": 0, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fcfg_if%2Fdetect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fcfg_if%2Fdetect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fcfg_if%2Fdetect%2Fmod.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "dfb8c87707f08c17194088baeae82ec73c145019", "filename": "src/tools/rustfmt/tests/source/cfg_if/detect/os/aarch64.rs", "status": "added", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fcfg_if%2Fdetect%2Fos%2Faarch64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fcfg_if%2Fdetect%2Fos%2Faarch64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fcfg_if%2Fdetect%2Fos%2Faarch64.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "910d2f33b390469372271dd00acf449aff2a8c9a", "filename": "src/tools/rustfmt/tests/source/cfg_if/detect/os/freebsd/aarch64.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fcfg_if%2Fdetect%2Fos%2Ffreebsd%2Faarch64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fcfg_if%2Fdetect%2Fos%2Ffreebsd%2Faarch64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fcfg_if%2Fdetect%2Fos%2Ffreebsd%2Faarch64.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "e13847dcbd8951039cd279842388a64a99c78af2", "filename": "src/tools/rustfmt/tests/source/cfg_if/detect/os/freebsd/arm.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fcfg_if%2Fdetect%2Fos%2Ffreebsd%2Farm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fcfg_if%2Fdetect%2Fos%2Ffreebsd%2Farm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fcfg_if%2Fdetect%2Fos%2Ffreebsd%2Farm.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "a2bac7676014d94a92f2284858e75ac4db8bd834", "filename": "src/tools/rustfmt/tests/source/cfg_if/detect/os/freebsd/auxvec.rs", "status": "added", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fcfg_if%2Fdetect%2Fos%2Ffreebsd%2Fauxvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fcfg_if%2Fdetect%2Fos%2Ffreebsd%2Fauxvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fcfg_if%2Fdetect%2Fos%2Ffreebsd%2Fauxvec.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "1a5338a3555958c559a1dc247b7b64ea85f47be5", "filename": "src/tools/rustfmt/tests/source/cfg_if/detect/os/freebsd/mod.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fcfg_if%2Fdetect%2Fos%2Ffreebsd%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fcfg_if%2Fdetect%2Fos%2Ffreebsd%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fcfg_if%2Fdetect%2Fos%2Ffreebsd%2Fmod.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "c7f761d4d60585a41a3fdfbc667d0cbbfd4c0c99", "filename": "src/tools/rustfmt/tests/source/cfg_if/detect/os/freebsd/powerpc.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fcfg_if%2Fdetect%2Fos%2Ffreebsd%2Fpowerpc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fcfg_if%2Fdetect%2Fos%2Ffreebsd%2Fpowerpc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fcfg_if%2Fdetect%2Fos%2Ffreebsd%2Fpowerpc.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "f7dc0f0222e5941cd9a88b240aaabba940573e7e", "filename": "src/tools/rustfmt/tests/source/cfg_if/detect/os/linux/aarch64.rs", "status": "added", "additions": 157, "deletions": 0, "changes": 157, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fcfg_if%2Fdetect%2Fos%2Flinux%2Faarch64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fcfg_if%2Fdetect%2Fos%2Flinux%2Faarch64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fcfg_if%2Fdetect%2Fos%2Flinux%2Faarch64.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "0d58a847cd626e1c4778e78b1f8a7599f650fe6a", "filename": "src/tools/rustfmt/tests/source/cfg_if/detect/os/linux/arm.rs", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fcfg_if%2Fdetect%2Fos%2Flinux%2Farm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fcfg_if%2Fdetect%2Fos%2Flinux%2Farm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fcfg_if%2Fdetect%2Fos%2Flinux%2Farm.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "07b6432eafd9871668057dbc4753163b3d627cae", "filename": "src/tools/rustfmt/tests/source/cfg_if/detect/os/linux/auxvec.rs", "status": "added", "additions": 307, "deletions": 0, "changes": 307, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fcfg_if%2Fdetect%2Fos%2Flinux%2Fauxvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fcfg_if%2Fdetect%2Fos%2Flinux%2Fauxvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fcfg_if%2Fdetect%2Fos%2Flinux%2Fauxvec.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "b3168578537fc1ba08c8e55fc7ca2b06085e8248", "filename": "src/tools/rustfmt/tests/source/cfg_if/detect/os/linux/cpuinfo.rs", "status": "added", "additions": 301, "deletions": 0, "changes": 301, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fcfg_if%2Fdetect%2Fos%2Flinux%2Fcpuinfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fcfg_if%2Fdetect%2Fos%2Flinux%2Fcpuinfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fcfg_if%2Fdetect%2Fos%2Flinux%2Fcpuinfo.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "c0a5fb2e5d887983e67609d9faf54669055acd65", "filename": "src/tools/rustfmt/tests/source/cfg_if/detect/os/linux/mips.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fcfg_if%2Fdetect%2Fos%2Flinux%2Fmips.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fcfg_if%2Fdetect%2Fos%2Flinux%2Fmips.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fcfg_if%2Fdetect%2Fos%2Flinux%2Fmips.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "e02d5e6dcda7a54b15218032a4b1522e021139b4", "filename": "src/tools/rustfmt/tests/source/cfg_if/detect/os/linux/mod.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fcfg_if%2Fdetect%2Fos%2Flinux%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fcfg_if%2Fdetect%2Fos%2Flinux%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fcfg_if%2Fdetect%2Fos%2Flinux%2Fmod.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "1c08a58443db892362448cd1e6cbb6a9370a304e", "filename": "src/tools/rustfmt/tests/source/cfg_if/detect/os/linux/powerpc.rs", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fcfg_if%2Fdetect%2Fos%2Flinux%2Fpowerpc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fcfg_if%2Fdetect%2Fos%2Flinux%2Fpowerpc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fcfg_if%2Fdetect%2Fos%2Flinux%2Fpowerpc.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "23e399ea790740b0ed97f2a9ccd2bd2693af00c1", "filename": "src/tools/rustfmt/tests/source/cfg_if/detect/os/other.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fcfg_if%2Fdetect%2Fos%2Fother.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fcfg_if%2Fdetect%2Fos%2Fother.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fcfg_if%2Fdetect%2Fos%2Fother.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "9257b8a4be636fea96ef1c3eeb910081fd02136b", "filename": "src/tools/rustfmt/tests/source/cfg_if/detect/os/x86.rs", "status": "added", "additions": 375, "deletions": 0, "changes": 375, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fcfg_if%2Fdetect%2Fos%2Fx86.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fcfg_if%2Fdetect%2Fos%2Fx86.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fcfg_if%2Fdetect%2Fos%2Fx86.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "8b3bb304f1c83d3436dd1c325a952f8dbb86c4e2", "filename": "src/tools/rustfmt/tests/source/cfg_if/lib.rs", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fcfg_if%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fcfg_if%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fcfg_if%2Flib.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "b630e7ff383aa9867c447b86b2f7b0a5fb251613", "filename": "src/tools/rustfmt/tests/source/cfg_if/mod.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fcfg_if%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fcfg_if%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fcfg_if%2Fmod.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "5b6b5f438370a13caab5aa710d2fb4d3cae7b417", "filename": "src/tools/rustfmt/tests/source/cfg_mod/bar.rs", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fcfg_mod%2Fbar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fcfg_mod%2Fbar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fcfg_mod%2Fbar.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "0f8c0a3a7ac0f47f59595d9ac0fe23af15e2d66f", "filename": "src/tools/rustfmt/tests/source/cfg_mod/dir/dir1/dir2/wasm32.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fcfg_mod%2Fdir%2Fdir1%2Fdir2%2Fwasm32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fcfg_mod%2Fdir%2Fdir1%2Fdir2%2Fwasm32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fcfg_mod%2Fdir%2Fdir1%2Fdir2%2Fwasm32.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "0f8c0a3a7ac0f47f59595d9ac0fe23af15e2d66f", "filename": "src/tools/rustfmt/tests/source/cfg_mod/dir/dir1/dir3/wasm32.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fcfg_mod%2Fdir%2Fdir1%2Fdir3%2Fwasm32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fcfg_mod%2Fdir%2Fdir1%2Fdir3%2Fwasm32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fcfg_mod%2Fdir%2Fdir1%2Fdir3%2Fwasm32.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "de4ce55ef6ff17bf118fbdd863ddc63619df9ca7", "filename": "src/tools/rustfmt/tests/source/cfg_mod/foo.rs", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fcfg_mod%2Ffoo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fcfg_mod%2Ffoo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fcfg_mod%2Ffoo.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "45ba86f11b3f5e8ed23a51306af22ab42a2d850f", "filename": "src/tools/rustfmt/tests/source/cfg_mod/mod.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fcfg_mod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fcfg_mod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fcfg_mod%2Fmod.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "0b5c04d21920271ac05bc7d4fd4c7d4c95b2c37b", "filename": "src/tools/rustfmt/tests/source/cfg_mod/other.rs", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fcfg_mod%2Fother.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fcfg_mod%2Fother.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fcfg_mod%2Fother.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "3741e53fd4e8ef451c33889ffcb29fb52697af50", "filename": "src/tools/rustfmt/tests/source/cfg_mod/wasm32.rs", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fcfg_mod%2Fwasm32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fcfg_mod%2Fwasm32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fcfg_mod%2Fwasm32.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "20a96311e34142fbf6b790d4e047a8e56dc7d075", "filename": "src/tools/rustfmt/tests/source/chains-visual.rs", "status": "added", "additions": 158, "deletions": 0, "changes": 158, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fchains-visual.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fchains-visual.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fchains-visual.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "c77f5bac4cb21b58316ef7b1ef462b6ad26880f4", "filename": "src/tools/rustfmt/tests/source/chains.rs", "status": "added", "additions": 266, "deletions": 0, "changes": 266, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fchains.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fchains.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fchains.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "91160711b89099785c51657f04442a853c5bc06d", "filename": "src/tools/rustfmt/tests/source/chains_with_comment.rs", "status": "added", "additions": 121, "deletions": 0, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fchains_with_comment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fchains_with_comment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fchains_with_comment.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "b3ddfb51263b4443a54b187bf478263cd8413bad", "filename": "src/tools/rustfmt/tests/source/closure-block-inside-macro.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fclosure-block-inside-macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fclosure-block-inside-macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fclosure-block-inside-macro.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "e93cc3fb40f59f55b21d46594e01a3513c22d908", "filename": "src/tools/rustfmt/tests/source/closure.rs", "status": "added", "additions": 213, "deletions": 0, "changes": 213, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fclosure.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "b6ce5267fcb1d3594e2ada500e9e8660dfd01b1f", "filename": "src/tools/rustfmt/tests/source/comment.rs", "status": "added", "additions": 90, "deletions": 0, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fcomment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fcomment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fcomment.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "d68bb5483dc837f4553e63a2a4f7001d0a013485", "filename": "src/tools/rustfmt/tests/source/comment2.rs", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fcomment2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fcomment2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fcomment2.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "f19a85863344738ff0d81d112480fed661bd2969", "filename": "src/tools/rustfmt/tests/source/comment3.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fcomment3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fcomment3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fcomment3.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "f53a8a4a1fe02eb6bef9c50021bd6ba2d6807f28", "filename": "src/tools/rustfmt/tests/source/comment4.rs", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fcomment4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fcomment4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fcomment4.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "2835d8b2578564de09d1e9bf536d5c2949b4fdfb", "filename": "src/tools/rustfmt/tests/source/comment5.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fcomment5.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fcomment5.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fcomment5.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "e5d72113ce61f59ebe356c1977c536d027c9eecb", "filename": "src/tools/rustfmt/tests/source/comment6.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fcomment6.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fcomment6.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fcomment6.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "7a65f762f6c92929f377b4f37915d0fbddcba0fe", "filename": "src/tools/rustfmt/tests/source/comment_crlf_newline.rs", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fcomment_crlf_newline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fcomment_crlf_newline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fcomment_crlf_newline.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "c6058a55b0aeed72d6f3d3df4078ca270b4e2685", "filename": "src/tools/rustfmt/tests/source/configs/blank_lines_lower_bound/1.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Fblank_lines_lower_bound%2F1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Fblank_lines_lower_bound%2F1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Fblank_lines_lower_bound%2F1.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "d3bd9ac09aa6d6a0e105e5cb1a3d02fd1a23f8b8", "filename": "src/tools/rustfmt/tests/source/configs/brace_style/fn_always_next_line.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Fbrace_style%2Ffn_always_next_line.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Fbrace_style%2Ffn_always_next_line.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Fbrace_style%2Ffn_always_next_line.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "78a4495243d882925383b56056050086de3b4ada", "filename": "src/tools/rustfmt/tests/source/configs/brace_style/fn_prefer_same_line.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Fbrace_style%2Ffn_prefer_same_line.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Fbrace_style%2Ffn_prefer_same_line.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Fbrace_style%2Ffn_prefer_same_line.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "3b78932e1776ab10ba75e274ee0337cfbc40e511", "filename": "src/tools/rustfmt/tests/source/configs/brace_style/fn_same_line_where.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Fbrace_style%2Ffn_same_line_where.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Fbrace_style%2Ffn_same_line_where.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Fbrace_style%2Ffn_same_line_where.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "0cc19b34da7ef8dc726d95f7dcb50e204ca3a052", "filename": "src/tools/rustfmt/tests/source/configs/brace_style/item_always_next_line.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Fbrace_style%2Fitem_always_next_line.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Fbrace_style%2Fitem_always_next_line.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Fbrace_style%2Fitem_always_next_line.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "4412bc869a268bb230eafec8a83637f5d28bf32b", "filename": "src/tools/rustfmt/tests/source/configs/brace_style/item_prefer_same_line.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Fbrace_style%2Fitem_prefer_same_line.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Fbrace_style%2Fitem_prefer_same_line.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Fbrace_style%2Fitem_prefer_same_line.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "b8e69147dc5a8159600c1ae6c3304a9d8086483c", "filename": "src/tools/rustfmt/tests/source/configs/brace_style/item_same_line_where.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Fbrace_style%2Fitem_same_line_where.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Fbrace_style%2Fitem_same_line_where.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Fbrace_style%2Fitem_same_line_where.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "2d16d66aec12df04ba4ee7e55ee4808529488138", "filename": "src/tools/rustfmt/tests/source/configs/chain_width/always.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Fchain_width%2Falways.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Fchain_width%2Falways.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Fchain_width%2Falways.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "26f9354537a35e78733049d1e59670638149cff6", "filename": "src/tools/rustfmt/tests/source/configs/chain_width/small.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Fchain_width%2Fsmall.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Fchain_width%2Fsmall.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Fchain_width%2Fsmall.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "fffc81dd5d6da77a5569b04ccb05b61dbee59567", "filename": "src/tools/rustfmt/tests/source/configs/chain_width/tiny.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Fchain_width%2Ftiny.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Fchain_width%2Ftiny.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Fchain_width%2Ftiny.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "36187ce0af4cbb7861a819671ac334abfc8ab902", "filename": "src/tools/rustfmt/tests/source/configs/comment_width/above.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Fcomment_width%2Fabove.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Fcomment_width%2Fabove.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Fcomment_width%2Fabove.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "abbc5930c4ce1124ce9c1cf0f05690d116a26eb7", "filename": "src/tools/rustfmt/tests/source/configs/comment_width/below.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Fcomment_width%2Fbelow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Fcomment_width%2Fbelow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Fcomment_width%2Fbelow.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "c86e71c28981b178d7d2b949b3e00d3dd5138ae4", "filename": "src/tools/rustfmt/tests/source/configs/comment_width/ignore.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Fcomment_width%2Fignore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Fcomment_width%2Fignore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Fcomment_width%2Fignore.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "3b967f35a8e8faedf72da4bf90a7eb653b21a663", "filename": "src/tools/rustfmt/tests/source/configs/condense_wildcard_suffixes/false.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Fcondense_wildcard_suffixes%2Ffalse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Fcondense_wildcard_suffixes%2Ffalse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Fcondense_wildcard_suffixes%2Ffalse.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "3798a6b9902043e5b1112ad323bf392d2e05becb", "filename": "src/tools/rustfmt/tests/source/configs/condense_wildcard_suffixes/true.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Fcondense_wildcard_suffixes%2Ftrue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Fcondense_wildcard_suffixes%2Ftrue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Fcondense_wildcard_suffixes%2Ftrue.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "c4ddad9ce273463426a83f00ff10d18ae408b7e8", "filename": "src/tools/rustfmt/tests/source/configs/control_brace_style/always_next_line.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Fcontrol_brace_style%2Falways_next_line.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Fcontrol_brace_style%2Falways_next_line.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Fcontrol_brace_style%2Falways_next_line.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "a9c699d27e3e22fe3e2545c20e501303487d4398", "filename": "src/tools/rustfmt/tests/source/configs/control_brace_style/always_same_line.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Fcontrol_brace_style%2Falways_same_line.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Fcontrol_brace_style%2Falways_same_line.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Fcontrol_brace_style%2Falways_same_line.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "1a74a28f26a9f6240b245a5dc5d40b008317775e", "filename": "src/tools/rustfmt/tests/source/configs/control_brace_style/closing_next_line.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Fcontrol_brace_style%2Fclosing_next_line.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Fcontrol_brace_style%2Fclosing_next_line.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Fcontrol_brace_style%2Fclosing_next_line.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "834ca7a3c89e58b57be2dda5e259842e138511af", "filename": "src/tools/rustfmt/tests/source/configs/disable_all_formatting/false.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Fdisable_all_formatting%2Ffalse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Fdisable_all_formatting%2Ffalse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Fdisable_all_formatting%2Ffalse.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "56955bf384d6b2b7df5bfcb556ddc80a4902e507", "filename": "src/tools/rustfmt/tests/source/configs/disable_all_formatting/true.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Fdisable_all_formatting%2Ftrue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Fdisable_all_formatting%2Ftrue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Fdisable_all_formatting%2Ftrue.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "9bfb2b964eaa32a26b8341ce609d558154eaf078", "filename": "src/tools/rustfmt/tests/source/configs/empty_item_single_line/false.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Fempty_item_single_line%2Ffalse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Fempty_item_single_line%2Ffalse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Fempty_item_single_line%2Ffalse.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "8af8b88ffff83f8bc8a58c5a6dc144798eff3283", "filename": "src/tools/rustfmt/tests/source/configs/empty_item_single_line/true.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Fempty_item_single_line%2Ftrue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Fempty_item_single_line%2Ftrue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Fempty_item_single_line%2Ftrue.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "796e47c384ba54908dee83dad1874ad37aad1063", "filename": "src/tools/rustfmt/tests/source/configs/enum_discrim_align_threshold/40.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Fenum_discrim_align_threshold%2F40.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Fenum_discrim_align_threshold%2F40.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Fenum_discrim_align_threshold%2F40.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "fa70ae78352f991a536520f137eed88cf7353b1a", "filename": "src/tools/rustfmt/tests/source/configs/error_on_line_overflow/false.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Ferror_on_line_overflow%2Ffalse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Ferror_on_line_overflow%2Ffalse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Ferror_on_line_overflow%2Ffalse.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "66a371c259f0c9d52850157017a08a3df51f33b6", "filename": "src/tools/rustfmt/tests/source/configs/fn_args_layout/compressed.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Ffn_args_layout%2Fcompressed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Ffn_args_layout%2Fcompressed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Ffn_args_layout%2Fcompressed.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "f11e86fd3139c1beade1b48da8838d509f11c8b1", "filename": "src/tools/rustfmt/tests/source/configs/fn_args_layout/tall.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Ffn_args_layout%2Ftall.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Ffn_args_layout%2Ftall.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Ffn_args_layout%2Ftall.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "a23cc025225fbabba80ad0b62acbadc420308b3b", "filename": "src/tools/rustfmt/tests/source/configs/fn_args_layout/vertical.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Ffn_args_layout%2Fvertical.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Ffn_args_layout%2Fvertical.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Ffn_args_layout%2Fvertical.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "3d092f0c0bf5a5d4dd23896c0a116112c8b9da49", "filename": "src/tools/rustfmt/tests/source/configs/fn_single_line/false.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Ffn_single_line%2Ffalse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Ffn_single_line%2Ffalse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Ffn_single_line%2Ffalse.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "3cb0fdedf0b61d4c6a75ce5cc5069d22b87bec67", "filename": "src/tools/rustfmt/tests/source/configs/fn_single_line/true.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Ffn_single_line%2Ftrue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Ffn_single_line%2Ftrue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Ffn_single_line%2Ftrue.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "3c48f8e0c78dba9a3e7ebc8781e5a6d338197997", "filename": "src/tools/rustfmt/tests/source/configs/force_explicit_abi/false.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Fforce_explicit_abi%2Ffalse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Fforce_explicit_abi%2Ffalse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Fforce_explicit_abi%2Ffalse.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "e5ff6cf7dd7e1fd3762e331456e52153a94ae8a3", "filename": "src/tools/rustfmt/tests/source/configs/force_explicit_abi/true.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Fforce_explicit_abi%2Ftrue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Fforce_explicit_abi%2Ftrue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Fforce_explicit_abi%2Ftrue.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "b97e348e5da12a0be98855d7d1b4373e65f896d1", "filename": "src/tools/rustfmt/tests/source/configs/force_multiline_block/false.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Fforce_multiline_block%2Ffalse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Fforce_multiline_block%2Ffalse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Fforce_multiline_block%2Ffalse.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "db9d3de46141ecac6581c1b09ca1a3af269332cb", "filename": "src/tools/rustfmt/tests/source/configs/force_multiline_block/true.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Fforce_multiline_block%2Ftrue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Fforce_multiline_block%2Ftrue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Fforce_multiline_block%2Ftrue.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "d618a1ac3f9b25b7eb3ac1ab950f2412b5e5ebd3", "filename": "src/tools/rustfmt/tests/source/configs/format_macro_bodies/false.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Fformat_macro_bodies%2Ffalse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Fformat_macro_bodies%2Ffalse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Fformat_macro_bodies%2Ffalse.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "b254b82d719312c985bb8029f6201c1f130c89a4", "filename": "src/tools/rustfmt/tests/source/configs/format_macro_bodies/true.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Fformat_macro_bodies%2Ftrue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Fformat_macro_bodies%2Ftrue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Fformat_macro_bodies%2Ftrue.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "a721bb55c23a26e1e956f6c885019eb204b74e6a", "filename": "src/tools/rustfmt/tests/source/configs/format_macro_matchers/false.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Fformat_macro_matchers%2Ffalse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Fformat_macro_matchers%2Ffalse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Fformat_macro_matchers%2Ffalse.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "fa0442e228ac8ef91ef90f493d5527f2f404788e", "filename": "src/tools/rustfmt/tests/source/configs/format_macro_matchers/true.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Fformat_macro_matchers%2Ftrue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Fformat_macro_matchers%2Ftrue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Fformat_macro_matchers%2Ftrue.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "ecca0d7d1fca583c1fd6bdfda680bc588800e88a", "filename": "src/tools/rustfmt/tests/source/configs/format_strings/false.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Fformat_strings%2Ffalse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Fformat_strings%2Ffalse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Fformat_strings%2Ffalse.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "337314478212e57bb5a01c192f43d8b70fe22aa1", "filename": "src/tools/rustfmt/tests/source/configs/format_strings/true.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Fformat_strings%2Ftrue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Fformat_strings%2Ftrue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Fformat_strings%2Ftrue.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "ea7f6280a64af5a5848eb409f6e5748db0865b7b", "filename": "src/tools/rustfmt/tests/source/configs/group_imports/StdExternalCrate-merge_imports.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Fgroup_imports%2FStdExternalCrate-merge_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Fgroup_imports%2FStdExternalCrate-merge_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Fgroup_imports%2FStdExternalCrate-merge_imports.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "08f4e07b704e6edf0e3ab3dbd5a962a7c7e161b2", "filename": "src/tools/rustfmt/tests/source/configs/group_imports/StdExternalCrate-nested.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Fgroup_imports%2FStdExternalCrate-nested.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Fgroup_imports%2FStdExternalCrate-nested.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Fgroup_imports%2FStdExternalCrate-nested.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "08c9a72ae61e0ebc1577b20d1632ed10c0226c16", "filename": "src/tools/rustfmt/tests/source/configs/group_imports/StdExternalCrate-no_reorder.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Fgroup_imports%2FStdExternalCrate-no_reorder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Fgroup_imports%2FStdExternalCrate-no_reorder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Fgroup_imports%2FStdExternalCrate-no_reorder.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "d49c8941e6d5628ec5620a9056bd2a1f13d1f3c0", "filename": "src/tools/rustfmt/tests/source/configs/group_imports/StdExternalCrate.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Fgroup_imports%2FStdExternalCrate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Fgroup_imports%2FStdExternalCrate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Fgroup_imports%2FStdExternalCrate.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "bf92162b4240a1a44a65522952a8ca24cb8f38eb", "filename": "src/tools/rustfmt/tests/source/configs/hard_tabs/false.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Fhard_tabs%2Ffalse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Fhard_tabs%2Ffalse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Fhard_tabs%2Ffalse.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "738922a4dfb0400451874fa7a74ab76e13f0733f", "filename": "src/tools/rustfmt/tests/source/configs/hard_tabs/true.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Fhard_tabs%2Ftrue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Fhard_tabs%2Ftrue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Fhard_tabs%2Ftrue.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "477c4aa1684b756a1d28c84b92de007de79c44ea", "filename": "src/tools/rustfmt/tests/source/configs/imports_layout/merge_mixed.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Fimports_layout%2Fmerge_mixed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Fimports_layout%2Fmerge_mixed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Fimports_layout%2Fmerge_mixed.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "4d2d280a16bc5aca82ca1be6ac7220c7c3f53e83", "filename": "src/tools/rustfmt/tests/source/configs/indent_style/block_args.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Findent_style%2Fblock_args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Findent_style%2Fblock_args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Findent_style%2Fblock_args.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "8404f65f471c3608096375a6baf859eb73ea535a", "filename": "src/tools/rustfmt/tests/source/configs/indent_style/block_array.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Findent_style%2Fblock_array.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Findent_style%2Fblock_array.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Findent_style%2Fblock_array.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "c82b6b8e38f8316a373fd236be816c18ad63b969", "filename": "src/tools/rustfmt/tests/source/configs/indent_style/block_call.rs", "status": "added", "additions": 133, "deletions": 0, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Findent_style%2Fblock_call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Findent_style%2Fblock_call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Findent_style%2Fblock_call.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "41d91469114c9afec7971da29a9635027bdb109c", "filename": "src/tools/rustfmt/tests/source/configs/indent_style/block_chain.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Findent_style%2Fblock_chain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Findent_style%2Fblock_chain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Findent_style%2Fblock_chain.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "2cf17be56eff2e2b75a515169308e1b851bd78cd", "filename": "src/tools/rustfmt/tests/source/configs/indent_style/block_generic.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Findent_style%2Fblock_generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Findent_style%2Fblock_generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Findent_style%2Fblock_generic.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "47a6994f40ca29322a9c2ad0a558d55bede5febd", "filename": "src/tools/rustfmt/tests/source/configs/indent_style/block_struct_lit.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Findent_style%2Fblock_struct_lit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Findent_style%2Fblock_struct_lit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Findent_style%2Fblock_struct_lit.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "6d48ea742fc78e10175449586a89b3878451f602", "filename": "src/tools/rustfmt/tests/source/configs/indent_style/block_trailing_comma_call/one.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Findent_style%2Fblock_trailing_comma_call%2Fone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Findent_style%2Fblock_trailing_comma_call%2Fone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Findent_style%2Fblock_trailing_comma_call%2Fone.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "7a62d722c6e00432246321c15abec02bd22df7fc", "filename": "src/tools/rustfmt/tests/source/configs/indent_style/block_trailing_comma_call/two.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Findent_style%2Fblock_trailing_comma_call%2Ftwo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Findent_style%2Fblock_trailing_comma_call%2Ftwo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Findent_style%2Fblock_trailing_comma_call%2Ftwo.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "450491f02705e39a1a8355bca09568c849f68fe1", "filename": "src/tools/rustfmt/tests/source/configs/indent_style/block_where_pred.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Findent_style%2Fblock_where_pred.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Findent_style%2Fblock_where_pred.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Findent_style%2Fblock_where_pred.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "f08f5c64460a7c7c4c818e6d7d745f9bedadbaaa", "filename": "src/tools/rustfmt/tests/source/configs/indent_style/default.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Findent_style%2Fdefault.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Findent_style%2Fdefault.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Findent_style%2Fdefault.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "012840be28dccb7bba867e2d26d0073de836f6e9", "filename": "src/tools/rustfmt/tests/source/configs/indent_style/rfc_where.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Findent_style%2Frfc_where.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Findent_style%2Frfc_where.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Findent_style%2Frfc_where.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "5aa28a62b9cef0324a279a9f7c53181a04b5b9b0", "filename": "src/tools/rustfmt/tests/source/configs/indent_style/visual_args.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Findent_style%2Fvisual_args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Findent_style%2Fvisual_args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Findent_style%2Fvisual_args.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "05bbf00b1d27d5acec8136683fd5ca9c42b32376", "filename": "src/tools/rustfmt/tests/source/configs/indent_style/visual_array.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Findent_style%2Fvisual_array.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Findent_style%2Fvisual_array.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Findent_style%2Fvisual_array.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "9a679d6bb4c98d863dcdbb2c08fc7745fe5188fc", "filename": "src/tools/rustfmt/tests/source/configs/indent_style/visual_call.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Findent_style%2Fvisual_call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Findent_style%2Fvisual_call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Findent_style%2Fvisual_call.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "b74948753980354d1424e5468121e4ffac2be237", "filename": "src/tools/rustfmt/tests/source/configs/indent_style/visual_chain.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Findent_style%2Fvisual_chain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Findent_style%2Fvisual_chain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Findent_style%2Fvisual_chain.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "1f910d32d87a06746a7a951893346ce4a4da4b25", "filename": "src/tools/rustfmt/tests/source/configs/indent_style/visual_generics.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Findent_style%2Fvisual_generics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Findent_style%2Fvisual_generics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Findent_style%2Fvisual_generics.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "45538e70482d28bd6dd45d85dd1733d0229b1bf5", "filename": "src/tools/rustfmt/tests/source/configs/indent_style/visual_struct_lit.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Findent_style%2Fvisual_struct_lit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Findent_style%2Fvisual_struct_lit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Findent_style%2Fvisual_struct_lit.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "9738d397dbf6305182ad58152cbf74fcf5b3d4a5", "filename": "src/tools/rustfmt/tests/source/configs/indent_style/visual_trailing_comma.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Findent_style%2Fvisual_trailing_comma.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Findent_style%2Fvisual_trailing_comma.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Findent_style%2Fvisual_trailing_comma.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "055806b68629e18a4808c87e96b092fda68c4faf", "filename": "src/tools/rustfmt/tests/source/configs/indent_style/visual_where_pred.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Findent_style%2Fvisual_where_pred.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Findent_style%2Fvisual_where_pred.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Findent_style%2Fvisual_where_pred.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "53e37e13c4f2bfac9545df94c524a76c32fbd870", "filename": "src/tools/rustfmt/tests/source/configs/match_arm_blocks/false.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Fmatch_arm_blocks%2Ffalse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Fmatch_arm_blocks%2Ffalse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Fmatch_arm_blocks%2Ffalse.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "a452b13cd27db3aeb874b074cc4d68846c118f90", "filename": "src/tools/rustfmt/tests/source/configs/match_arm_blocks/true.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Fmatch_arm_blocks%2Ftrue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Fmatch_arm_blocks%2Ftrue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Fmatch_arm_blocks%2Ftrue.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "162d812d8cffc3e71af362c24f721853c61ad71d", "filename": "src/tools/rustfmt/tests/source/configs/match_arm_leading_pipes/always.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Fmatch_arm_leading_pipes%2Falways.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Fmatch_arm_leading_pipes%2Falways.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Fmatch_arm_leading_pipes%2Falways.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "8a68fe21407ee1ef51435d62cbc540619d4ef8af", "filename": "src/tools/rustfmt/tests/source/configs/match_arm_leading_pipes/never.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Fmatch_arm_leading_pipes%2Fnever.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Fmatch_arm_leading_pipes%2Fnever.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Fmatch_arm_leading_pipes%2Fnever.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "ea303e857def5a4ac393d042f1bf3f8bd278ebc3", "filename": "src/tools/rustfmt/tests/source/configs/match_arm_leading_pipes/preserve.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Fmatch_arm_leading_pipes%2Fpreserve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Fmatch_arm_leading_pipes%2Fpreserve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Fmatch_arm_leading_pipes%2Fpreserve.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "70e02955fb01d4345614ed7f56bc82d7e0ef2976", "filename": "src/tools/rustfmt/tests/source/configs/match_block_trailing_comma/false.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Fmatch_block_trailing_comma%2Ffalse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Fmatch_block_trailing_comma%2Ffalse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Fmatch_block_trailing_comma%2Ffalse.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "b9af3d47202fc1e1aa36591455b194fdfb9e7f01", "filename": "src/tools/rustfmt/tests/source/configs/match_block_trailing_comma/true.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Fmatch_block_trailing_comma%2Ftrue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Fmatch_block_trailing_comma%2Ftrue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Fmatch_block_trailing_comma%2Ftrue.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "18b8443f0d7bb586465bfc12826e7e27a54eabc1", "filename": "src/tools/rustfmt/tests/source/configs/merge_derives/true.rs", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Fmerge_derives%2Ftrue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Fmerge_derives%2Ftrue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Fmerge_derives%2Ftrue.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "488962ed9362d52c6060d589620fa8ad48a6811a", "filename": "src/tools/rustfmt/tests/source/configs/normalize_comments/false.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Fnormalize_comments%2Ffalse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Fnormalize_comments%2Ffalse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Fnormalize_comments%2Ffalse.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "c74a9808e61db4bc19313e116c55c4a520b365d8", "filename": "src/tools/rustfmt/tests/source/configs/normalize_comments/true.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Fnormalize_comments%2Ftrue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Fnormalize_comments%2Ftrue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Fnormalize_comments%2Ftrue.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "f8eb64273c3d664fda0461d8a8f2448d34dc6a83", "filename": "src/tools/rustfmt/tests/source/configs/normalize_doc_attributes/false.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Fnormalize_doc_attributes%2Ffalse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Fnormalize_doc_attributes%2Ffalse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Fnormalize_doc_attributes%2Ffalse.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "894c00a4dc058874ea069b3bc60ce8e2228b6e05", "filename": "src/tools/rustfmt/tests/source/configs/normalize_doc_attributes/true.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Fnormalize_doc_attributes%2Ftrue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Fnormalize_doc_attributes%2Ftrue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Fnormalize_doc_attributes%2Ftrue.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "87aed09c14a08bff58e315545b2c22da2bfb351c", "filename": "src/tools/rustfmt/tests/source/configs/remove_nested_parens/remove_nested_parens.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Fremove_nested_parens%2Fremove_nested_parens.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Fremove_nested_parens%2Fremove_nested_parens.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Fremove_nested_parens%2Fremove_nested_parens.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "beb99f0fb8e6ab755bc33135c24f686fb573642e", "filename": "src/tools/rustfmt/tests/source/configs/reorder_impl_items/false.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Freorder_impl_items%2Ffalse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Freorder_impl_items%2Ffalse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Freorder_impl_items%2Ffalse.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "612b1c84abdfb1e253086f8935cb02f1786f80e5", "filename": "src/tools/rustfmt/tests/source/configs/reorder_impl_items/true.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Freorder_impl_items%2Ftrue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Freorder_impl_items%2Ftrue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Freorder_impl_items%2Ftrue.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "4b85684dc013d0a087c7a09eb2a2a78ff334ad57", "filename": "src/tools/rustfmt/tests/source/configs/reorder_imports/false.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Freorder_imports%2Ffalse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Freorder_imports%2Ffalse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Freorder_imports%2Ffalse.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "2a40f6d069f9375ed1f6be508bf3ce34ea87b8e6", "filename": "src/tools/rustfmt/tests/source/configs/reorder_imports/true.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Freorder_imports%2Ftrue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Freorder_imports%2Ftrue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Freorder_imports%2Ftrue.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "8b137891791fe96927ad78e64b0aad7bded08bdc", "filename": "src/tools/rustfmt/tests/source/configs/reorder_modules/dolor/mod.rs", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Freorder_modules%2Fdolor%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Freorder_modules%2Fdolor%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Freorder_modules%2Fdolor%2Fmod.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "56b1aa03ed795f9a690bc34bf1cbe30a7c8468b8", "filename": "src/tools/rustfmt/tests/source/configs/reorder_modules/false.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Freorder_modules%2Ffalse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Freorder_modules%2Ffalse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Freorder_modules%2Ffalse.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "8b137891791fe96927ad78e64b0aad7bded08bdc", "filename": "src/tools/rustfmt/tests/source/configs/reorder_modules/ipsum/mod.rs", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Freorder_modules%2Fipsum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Freorder_modules%2Fipsum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Freorder_modules%2Fipsum%2Fmod.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "8b137891791fe96927ad78e64b0aad7bded08bdc", "filename": "src/tools/rustfmt/tests/source/configs/reorder_modules/lorem/mod.rs", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Freorder_modules%2Florem%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Freorder_modules%2Florem%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Freorder_modules%2Florem%2Fmod.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "8b137891791fe96927ad78e64b0aad7bded08bdc", "filename": "src/tools/rustfmt/tests/source/configs/reorder_modules/sit/mod.rs", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Freorder_modules%2Fsit%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Freorder_modules%2Fsit%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Freorder_modules%2Fsit%2Fmod.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "79b0ab1e35546ad25c94363bd272c219ff2bf219", "filename": "src/tools/rustfmt/tests/source/configs/reorder_modules/true.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Freorder_modules%2Ftrue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Freorder_modules%2Ftrue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Freorder_modules%2Ftrue.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "d7ff6cdb8290ee1cc59460ad245d23605bafb30f", "filename": "src/tools/rustfmt/tests/source/configs/skip_children/foo/mod.rs", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Fskip_children%2Ffoo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Fskip_children%2Ffoo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Fskip_children%2Ffoo%2Fmod.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "e51889dd4c91f159ebf7dedcd04f4f6a829151ca", "filename": "src/tools/rustfmt/tests/source/configs/skip_children/true.rs", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Fskip_children%2Ftrue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Fskip_children%2Ftrue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Fskip_children%2Ftrue.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "0a597602528a4caf931433d27ae09dc3c9066708", "filename": "src/tools/rustfmt/tests/source/configs/space_before_colon/true.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Fspace_before_colon%2Ftrue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Fspace_before_colon%2Ftrue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Fspace_before_colon%2Ftrue.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "1878c68a5a0c4c3b1630fce5ae52e11b96e14778", "filename": "src/tools/rustfmt/tests/source/configs/spaces_around_ranges/false.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Fspaces_around_ranges%2Ffalse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Fspaces_around_ranges%2Ffalse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Fspaces_around_ranges%2Ffalse.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "0eadfb2851579ba855ec504b520071e8d2573b7d", "filename": "src/tools/rustfmt/tests/source/configs/spaces_around_ranges/true.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Fspaces_around_ranges%2Ftrue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Fspaces_around_ranges%2Ftrue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Fspaces_around_ranges%2Ftrue.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "81253c460376c2339e5d8fde614f1bc69a5f3b7c", "filename": "src/tools/rustfmt/tests/source/configs/struct_field_align_threshold/20.rs", "status": "added", "additions": 383, "deletions": 0, "changes": 383, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Fstruct_field_align_threshold%2F20.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Fstruct_field_align_threshold%2F20.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Fstruct_field_align_threshold%2F20.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "17cad8dde290d1cf68943588c39ab26cfac9b4ea", "filename": "src/tools/rustfmt/tests/source/configs/struct_lit_single_line/false.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Fstruct_lit_single_line%2Ffalse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Fstruct_lit_single_line%2Ffalse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Fstruct_lit_single_line%2Ffalse.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "5c2667bc2c792d07214643db3a7382b6d29029af", "filename": "src/tools/rustfmt/tests/source/configs/tab_spaces/2.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Ftab_spaces%2F2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Ftab_spaces%2F2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Ftab_spaces%2F2.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "da61bbd42a7c75267c9a7731406b4ff92712487e", "filename": "src/tools/rustfmt/tests/source/configs/tab_spaces/4.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Ftab_spaces%2F4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Ftab_spaces%2F4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Ftab_spaces%2F4.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "57e874cd822c66e2ebcd67b9009da4c5fdc40438", "filename": "src/tools/rustfmt/tests/source/configs/trailing_comma/always.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Ftrailing_comma%2Falways.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Ftrailing_comma%2Falways.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Ftrailing_comma%2Falways.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "4da3b996f2994fdf3f7020e5b704f6a433108e84", "filename": "src/tools/rustfmt/tests/source/configs/trailing_comma/never.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Ftrailing_comma%2Fnever.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Ftrailing_comma%2Fnever.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Ftrailing_comma%2Fnever.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "c903e82215891302512fdeaba10c2c7960e13d10", "filename": "src/tools/rustfmt/tests/source/configs/trailing_comma/vertical.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Ftrailing_comma%2Fvertical.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Ftrailing_comma%2Fvertical.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Ftrailing_comma%2Fvertical.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "223b9a2f0f0221101f483a90db2bbe839883d48e", "filename": "src/tools/rustfmt/tests/source/configs/type_punctuation_density/compressed.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Ftype_punctuation_density%2Fcompressed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Ftype_punctuation_density%2Fcompressed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Ftype_punctuation_density%2Fcompressed.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "fe0c0816701b5c299027466ab0cc12fc8c15cc35", "filename": "src/tools/rustfmt/tests/source/configs/type_punctuation_density/wide.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Ftype_punctuation_density%2Fwide.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Ftype_punctuation_density%2Fwide.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Ftype_punctuation_density%2Fwide.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "4c2eb1de179c813f969e01bd2e1420dafd0b3cbf", "filename": "src/tools/rustfmt/tests/source/configs/use_field_init_shorthand/false.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Fuse_field_init_shorthand%2Ffalse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Fuse_field_init_shorthand%2Ffalse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Fuse_field_init_shorthand%2Ffalse.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "dcde28d74e0f1d6186d6644ec022498b245dc682", "filename": "src/tools/rustfmt/tests/source/configs/use_field_init_shorthand/true.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Fuse_field_init_shorthand%2Ftrue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Fuse_field_init_shorthand%2Ftrue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Fuse_field_init_shorthand%2Ftrue.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "68bc40271a1d4fa86a7b32684d8a50224fb7ec11", "filename": "src/tools/rustfmt/tests/source/configs/use_small_heuristics/default.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Fuse_small_heuristics%2Fdefault.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Fuse_small_heuristics%2Fdefault.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Fuse_small_heuristics%2Fdefault.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "8d30932e2c24d5cfc1a67b3108d97759d690becf", "filename": "src/tools/rustfmt/tests/source/configs/use_small_heuristics/max.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Fuse_small_heuristics%2Fmax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Fuse_small_heuristics%2Fmax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Fuse_small_heuristics%2Fmax.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "f76392d2404bed7ac7a3d455109234525a076a56", "filename": "src/tools/rustfmt/tests/source/configs/use_small_heuristics/off.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Fuse_small_heuristics%2Foff.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Fuse_small_heuristics%2Foff.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Fuse_small_heuristics%2Foff.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "de7f8b4a5e248e100354baade46c0cf1af90026d", "filename": "src/tools/rustfmt/tests/source/configs/use_try_shorthand/false.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Fuse_try_shorthand%2Ffalse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Fuse_try_shorthand%2Ffalse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Fuse_try_shorthand%2Ffalse.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "9015ec41e5e49474a14a3f707fab1a221caa61cc", "filename": "src/tools/rustfmt/tests/source/configs/use_try_shorthand/true.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Fuse_try_shorthand%2Ftrue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Fuse_try_shorthand%2Ftrue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Fuse_try_shorthand%2Ftrue.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "9de98283b5e5dcd6afb0805f6de98c02ddf80917", "filename": "src/tools/rustfmt/tests/source/configs/where_single_line/true.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Fwhere_single_line%2Ftrue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Fwhere_single_line%2Ftrue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Fwhere_single_line%2Ftrue.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "48ecd88accbf91d509def947d021d12cb7cd0b9c", "filename": "src/tools/rustfmt/tests/source/configs/wrap_comments/false.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Fwrap_comments%2Ffalse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Fwrap_comments%2Ffalse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Fwrap_comments%2Ffalse.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "39a79a4cacc4685a70ec777c0de9c3bb91f51826", "filename": "src/tools/rustfmt/tests/source/configs/wrap_comments/true.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Fwrap_comments%2Ftrue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Fwrap_comments%2Ftrue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconfigs%2Fwrap_comments%2Ftrue.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "01b764dbe45df7bd30055dd25cbe416e6b7d62fd", "filename": "src/tools/rustfmt/tests/source/const_generics.rs", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconst_generics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconst_generics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fconst_generics.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "9079fb46c0cd7d6a1e5683fe8cfceb7add9b15f7", "filename": "src/tools/rustfmt/tests/source/control-brace-style-always-next-line.rs", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fcontrol-brace-style-always-next-line.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fcontrol-brace-style-always-next-line.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fcontrol-brace-style-always-next-line.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "45111aaab08cde3892b52061803c886eebe45d1b", "filename": "src/tools/rustfmt/tests/source/control-brace-style-always-same-line.rs", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fcontrol-brace-style-always-same-line.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fcontrol-brace-style-always-same-line.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fcontrol-brace-style-always-same-line.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "dde88c6e95520732b9121b88ea5455e8467cd0a6", "filename": "src/tools/rustfmt/tests/source/doc-attrib.rs", "status": "added", "additions": 118, "deletions": 0, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fdoc-attrib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fdoc-attrib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fdoc-attrib.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}, {"sha": "e74ceefd195888fb0c7cebd8185d90bab051d329", "filename": "src/tools/rustfmt/tests/source/doc-comment-with-example.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fdoc-comment-with-example.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2d45c0d4b2d44789000ebec6d702cc27db19782/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fdoc-comment-with-example.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Ftests%2Fsource%2Fdoc-comment-with-example.rs?ref=b2d45c0d4b2d44789000ebec6d702cc27db19782"}]}