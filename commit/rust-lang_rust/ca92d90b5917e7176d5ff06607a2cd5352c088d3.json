{"sha": "ca92d90b5917e7176d5ff06607a2cd5352c088d3", "node_id": "C_kwDOAAsO6NoAKGNhOTJkOTBiNTkxN2U3MTc2ZDVmZjA2NjA3YTJjZDUzNTJjMDg4ZDM", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-11-15T06:43:28Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-11-15T06:43:28Z"}, "message": "Auto merge of #104428 - matthiaskrgr:rollup-jo3078i, r=matthiaskrgr\n\nRollup of 13 pull requests\n\nSuccessful merges:\n\n - #103842 (Adding Fuchsia compiler testing script, docs)\n - #104354 (Remove leading newlines from `NonZero*` doc examples)\n - #104372 (Update compiler-builtins)\n - #104380 (rustdoc: remove unused CSS `code { opacity: 1 }`)\n - #104381 (Remove dead NoneError diagnostic handling)\n - #104383 (Remove unused symbols and diagnostic items)\n - #104391 (Deriving cleanups)\n - #104403 (Specify language of code comment to generate document)\n - #104404 (Fix missing minification for static files)\n - #104413 ([llvm-wrapper] adapt for LLVM API change)\n - #104415 (rustdoc: fix corner case in search keyboard commands)\n - #104422 (Fix suggest associated call syntax)\n - #104426 (Add test for #102154)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "b34e3c368642c150f3c81bc98d45d57353480bbc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b34e3c368642c150f3c81bc98d45d57353480bbc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ca92d90b5917e7176d5ff06607a2cd5352c088d3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ca92d90b5917e7176d5ff06607a2cd5352c088d3", "html_url": "https://github.com/rust-lang/rust/commit/ca92d90b5917e7176d5ff06607a2cd5352c088d3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ca92d90b5917e7176d5ff06607a2cd5352c088d3/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "101e1822c3e54e63996c8aaa014d55716f3937eb", "url": "https://api.github.com/repos/rust-lang/rust/commits/101e1822c3e54e63996c8aaa014d55716f3937eb", "html_url": "https://github.com/rust-lang/rust/commit/101e1822c3e54e63996c8aaa014d55716f3937eb"}, {"sha": "7c7cb7182f8b2211005d3f82126e5f45e270ad21", "url": "https://api.github.com/repos/rust-lang/rust/commits/7c7cb7182f8b2211005d3f82126e5f45e270ad21", "html_url": "https://github.com/rust-lang/rust/commit/7c7cb7182f8b2211005d3f82126e5f45e270ad21"}], "stats": {"total": 1795, "additions": 1445, "deletions": 350}, "files": [{"sha": "2cbab90aa61a2ca9b657661095b8d0054ff378bb", "filename": "compiler/rustc_ast/src/ast.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ca92d90b5917e7176d5ff06607a2cd5352c088d3/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca92d90b5917e7176d5ff06607a2cd5352c088d3/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fast.rs?ref=ca92d90b5917e7176d5ff06607a2cd5352c088d3", "patch": "@@ -392,15 +392,7 @@ pub struct Generics {\n impl Default for Generics {\n     /// Creates an instance of `Generics`.\n     fn default() -> Generics {\n-        Generics {\n-            params: Vec::new(),\n-            where_clause: WhereClause {\n-                has_where_token: false,\n-                predicates: Vec::new(),\n-                span: DUMMY_SP,\n-            },\n-            span: DUMMY_SP,\n-        }\n+        Generics { params: Vec::new(), where_clause: Default::default(), span: DUMMY_SP }\n     }\n }\n \n@@ -415,6 +407,12 @@ pub struct WhereClause {\n     pub span: Span,\n }\n \n+impl Default for WhereClause {\n+    fn default() -> WhereClause {\n+        WhereClause { has_where_token: false, predicates: Vec::new(), span: DUMMY_SP }\n+    }\n+}\n+\n /// A single predicate in a where-clause.\n #[derive(Clone, Encodable, Decodable, Debug)]\n pub enum WherePredicate {"}, {"sha": "240167146e1f134c08cf93a1fe4514c53ff41a42", "filename": "compiler/rustc_builtin_macros/src/deriving/bounds.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ca92d90b5917e7176d5ff06607a2cd5352c088d3/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fbounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca92d90b5917e7176d5ff06607a2cd5352c088d3/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fbounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fbounds.rs?ref=ca92d90b5917e7176d5ff06607a2cd5352c088d3", "patch": "@@ -1,4 +1,3 @@\n-use crate::deriving::generic::ty::*;\n use crate::deriving::generic::*;\n use crate::deriving::path_std;\n \n@@ -19,7 +18,6 @@ pub fn expand_deriving_copy(\n         path: path_std!(marker::Copy),\n         skip_path_as_bound: false,\n         additional_bounds: Vec::new(),\n-        generics: Bounds::empty(),\n         supports_unions: true,\n         methods: Vec::new(),\n         associated_types: Vec::new(),"}, {"sha": "2f19fbcac7d72299f4d3218760960e765b803868", "filename": "compiler/rustc_builtin_macros/src/deriving/clone.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ca92d90b5917e7176d5ff06607a2cd5352c088d3/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca92d90b5917e7176d5ff06607a2cd5352c088d3/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fclone.rs?ref=ca92d90b5917e7176d5ff06607a2cd5352c088d3", "patch": "@@ -75,7 +75,6 @@ pub fn expand_deriving_clone(\n         path: path_std!(clone::Clone),\n         skip_path_as_bound: false,\n         additional_bounds: bounds,\n-        generics: Bounds::empty(),\n         supports_unions: true,\n         methods: vec![MethodDef {\n             name: sym::clone,"}, {"sha": "a0b836171bea995b3cbe3424c619ddc81e465d9f", "filename": "compiler/rustc_builtin_macros/src/deriving/cmp/eq.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ca92d90b5917e7176d5ff06607a2cd5352c088d3/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Feq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca92d90b5917e7176d5ff06607a2cd5352c088d3/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Feq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Feq.rs?ref=ca92d90b5917e7176d5ff06607a2cd5352c088d3", "patch": "@@ -28,7 +28,6 @@ pub fn expand_deriving_eq(\n         path: path_std!(cmp::Eq),\n         skip_path_as_bound: false,\n         additional_bounds: Vec::new(),\n-        generics: Bounds::empty(),\n         supports_unions: true,\n         methods: vec![MethodDef {\n             name: sym::assert_receiver_is_total_eq,"}, {"sha": "52780981248b9b8ba13eff913a6977e5bc1f45c6", "filename": "compiler/rustc_builtin_macros/src/deriving/cmp/ord.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ca92d90b5917e7176d5ff06607a2cd5352c088d3/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Ford.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca92d90b5917e7176d5ff06607a2cd5352c088d3/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Ford.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Ford.rs?ref=ca92d90b5917e7176d5ff06607a2cd5352c088d3", "patch": "@@ -22,7 +22,6 @@ pub fn expand_deriving_ord(\n         path: path_std!(cmp::Ord),\n         skip_path_as_bound: false,\n         additional_bounds: Vec::new(),\n-        generics: Bounds::empty(),\n         supports_unions: false,\n         methods: vec![MethodDef {\n             name: sym::cmp,"}, {"sha": "34de4a620b462b67d47a1332c22dfbbbdac4073e", "filename": "compiler/rustc_builtin_macros/src/deriving/cmp/partial_eq.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ca92d90b5917e7176d5ff06607a2cd5352c088d3/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Fpartial_eq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca92d90b5917e7176d5ff06607a2cd5352c088d3/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Fpartial_eq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Fpartial_eq.rs?ref=ca92d90b5917e7176d5ff06607a2cd5352c088d3", "patch": "@@ -86,7 +86,6 @@ pub fn expand_deriving_partial_eq(\n         path: path_std!(cmp::PartialEq),\n         skip_path_as_bound: false,\n         additional_bounds: Vec::new(),\n-        generics: Bounds::empty(),\n         supports_unions: false,\n         methods,\n         associated_types: Vec::new(),"}, {"sha": "6cc8f26df559c2b33d18782a5e62cc14c9d82d18", "filename": "compiler/rustc_builtin_macros/src/deriving/cmp/partial_ord.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ca92d90b5917e7176d5ff06607a2cd5352c088d3/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Fpartial_ord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca92d90b5917e7176d5ff06607a2cd5352c088d3/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Fpartial_ord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Fpartial_ord.rs?ref=ca92d90b5917e7176d5ff06607a2cd5352c088d3", "patch": "@@ -40,7 +40,6 @@ pub fn expand_deriving_partial_ord(\n         path: path_std!(cmp::PartialOrd),\n         skip_path_as_bound: false,\n         additional_bounds: vec![],\n-        generics: Bounds::empty(),\n         supports_unions: false,\n         methods: vec![partial_cmp_def],\n         associated_types: Vec::new(),"}, {"sha": "544d971b27a5d9473a375d0c2b692a16912fac6a", "filename": "compiler/rustc_builtin_macros/src/deriving/debug.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ca92d90b5917e7176d5ff06607a2cd5352c088d3/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdebug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca92d90b5917e7176d5ff06607a2cd5352c088d3/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdebug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdebug.rs?ref=ca92d90b5917e7176d5ff06607a2cd5352c088d3", "patch": "@@ -23,7 +23,6 @@ pub fn expand_deriving_debug(\n         path: path_std!(fmt::Debug),\n         skip_path_as_bound: false,\n         additional_bounds: Vec::new(),\n-        generics: Bounds::empty(),\n         supports_unions: false,\n         methods: vec![MethodDef {\n             name: sym::fmt,"}, {"sha": "6d14875a9832293f7d238fdd7e525c385b57326a", "filename": "compiler/rustc_builtin_macros/src/deriving/decodable.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ca92d90b5917e7176d5ff06607a2cd5352c088d3/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdecodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca92d90b5917e7176d5ff06607a2cd5352c088d3/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdecodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdecodable.rs?ref=ca92d90b5917e7176d5ff06607a2cd5352c088d3", "patch": "@@ -26,7 +26,6 @@ pub fn expand_deriving_rustc_decodable(\n         path: Path::new_(vec![krate, sym::Decodable], vec![], PathKind::Global),\n         skip_path_as_bound: false,\n         additional_bounds: Vec::new(),\n-        generics: Bounds::empty(),\n         supports_unions: false,\n         methods: vec![MethodDef {\n             name: sym::decode,"}, {"sha": "93f297ad88b5fc4dfc371512fee69a9ea99bce33", "filename": "compiler/rustc_builtin_macros/src/deriving/default.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ca92d90b5917e7176d5ff06607a2cd5352c088d3/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdefault.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca92d90b5917e7176d5ff06607a2cd5352c088d3/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdefault.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdefault.rs?ref=ca92d90b5917e7176d5ff06607a2cd5352c088d3", "patch": "@@ -27,7 +27,6 @@ pub fn expand_deriving_default(\n         path: Path::new(vec![kw::Default, sym::Default]),\n         skip_path_as_bound: has_a_default_variant(item),\n         additional_bounds: Vec::new(),\n-        generics: Bounds::empty(),\n         supports_unions: false,\n         methods: vec![MethodDef {\n             name: kw::Default,"}, {"sha": "9a46ca815372653ab4696303896d31ea5a34cd5e", "filename": "compiler/rustc_builtin_macros/src/deriving/encodable.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ca92d90b5917e7176d5ff06607a2cd5352c088d3/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fencodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca92d90b5917e7176d5ff06607a2cd5352c088d3/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fencodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fencodable.rs?ref=ca92d90b5917e7176d5ff06607a2cd5352c088d3", "patch": "@@ -110,7 +110,6 @@ pub fn expand_deriving_rustc_encodable(\n         path: Path::new_(vec![krate, sym::Encodable], vec![], PathKind::Global),\n         skip_path_as_bound: false,\n         additional_bounds: Vec::new(),\n-        generics: Bounds::empty(),\n         supports_unions: false,\n         methods: vec![MethodDef {\n             name: sym::encode,"}, {"sha": "f48c49f411ce822c02222c6107b616044cb41507", "filename": "compiler/rustc_builtin_macros/src/deriving/generic/mod.rs", "status": "modified", "additions": 31, "deletions": 38, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/ca92d90b5917e7176d5ff06607a2cd5352c088d3/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca92d90b5917e7176d5ff06607a2cd5352c088d3/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs?ref=ca92d90b5917e7176d5ff06607a2cd5352c088d3", "patch": "@@ -195,9 +195,6 @@ pub struct TraitDef<'a> {\n     /// other than the current trait\n     pub additional_bounds: Vec<Ty>,\n \n-    /// Any extra lifetimes and/or bounds, e.g., `D: serialize::Decoder`\n-    pub generics: Bounds,\n-\n     /// Can this trait be derived for unions?\n     pub supports_unions: bool,\n \n@@ -583,19 +580,21 @@ impl<'a> TraitDef<'a> {\n             })\n         });\n \n-        let Generics { mut params, mut where_clause, .. } =\n-            self.generics.to_generics(cx, self.span, type_ident, generics);\n+        let mut where_clause = ast::WhereClause::default();\n         where_clause.span = generics.where_clause.span;\n         let ctxt = self.span.ctxt();\n         let span = generics.span.with_ctxt(ctxt);\n \n         // Create the generic parameters\n-        params.extend(generics.params.iter().map(|param| match &param.kind {\n-            GenericParamKind::Lifetime { .. } => param.clone(),\n-            GenericParamKind::Type { .. } => {\n-                // I don't think this can be moved out of the loop, since\n-                // a GenericBound requires an ast id\n-                let bounds: Vec<_> =\n+        let params: Vec<_> = generics\n+            .params\n+            .iter()\n+            .map(|param| match &param.kind {\n+                GenericParamKind::Lifetime { .. } => param.clone(),\n+                GenericParamKind::Type { .. } => {\n+                    // I don't think this can be moved out of the loop, since\n+                    // a GenericBound requires an ast id\n+                    let bounds: Vec<_> =\n                     // extra restrictions on the generics parameters to the\n                     // type being derived upon\n                     self.additional_bounds.iter().map(|p| {\n@@ -608,21 +607,22 @@ impl<'a> TraitDef<'a> {\n                         param.bounds.iter().cloned()\n                     ).collect();\n \n-                cx.typaram(param.ident.span.with_ctxt(ctxt), param.ident, bounds, None)\n-            }\n-            GenericParamKind::Const { ty, kw_span, .. } => {\n-                let const_nodefault_kind = GenericParamKind::Const {\n-                    ty: ty.clone(),\n-                    kw_span: kw_span.with_ctxt(ctxt),\n-\n-                    // We can't have default values inside impl block\n-                    default: None,\n-                };\n-                let mut param_clone = param.clone();\n-                param_clone.kind = const_nodefault_kind;\n-                param_clone\n-            }\n-        }));\n+                    cx.typaram(param.ident.span.with_ctxt(ctxt), param.ident, bounds, None)\n+                }\n+                GenericParamKind::Const { ty, kw_span, .. } => {\n+                    let const_nodefault_kind = GenericParamKind::Const {\n+                        ty: ty.clone(),\n+                        kw_span: kw_span.with_ctxt(ctxt),\n+\n+                        // We can't have default values inside impl block\n+                        default: None,\n+                    };\n+                    let mut param_clone = param.clone();\n+                    param_clone.kind = const_nodefault_kind;\n+                    param_clone\n+                }\n+            })\n+            .collect();\n \n         // and similarly for where clauses\n         where_clause.predicates.extend(generics.where_clause.predicates.iter().map(|clause| {\n@@ -1062,18 +1062,15 @@ impl<'a> MethodDef<'a> {\n                 trait_.create_struct_field_access_fields(cx, selflike_args, struct_def, true);\n             mk_body(cx, selflike_fields)\n         } else {\n-            // Neither packed nor copy. Need to use ref patterns.\n+            // Packed and not copy. Need to use ref patterns.\n             let prefixes: Vec<_> =\n                 (0..selflike_args.len()).map(|i| format!(\"__self_{}\", i)).collect();\n-            let addr_of = always_copy;\n-            let selflike_fields =\n-                trait_.create_struct_pattern_fields(cx, struct_def, &prefixes, addr_of);\n+            let selflike_fields = trait_.create_struct_pattern_fields(cx, struct_def, &prefixes);\n             let mut body = mk_body(cx, selflike_fields);\n \n             let struct_path = cx.path(span, vec![Ident::new(kw::SelfUpper, type_ident.span)]);\n-            let by_ref = ByRef::from(is_packed && !always_copy);\n             let patterns =\n-                trait_.create_struct_patterns(cx, struct_path, struct_def, &prefixes, by_ref);\n+                trait_.create_struct_patterns(cx, struct_path, struct_def, &prefixes, ByRef::Yes);\n \n             // Do the let-destructuring.\n             let mut stmts: Vec<_> = iter::zip(selflike_args, patterns)\n@@ -1254,9 +1251,7 @@ impl<'a> MethodDef<'a> {\n                 // A single arm has form (&VariantK, &VariantK, ...) => BodyK\n                 // (see \"Final wrinkle\" note below for why.)\n \n-                let addr_of = false; // because enums can't be repr(packed)\n-                let fields =\n-                    trait_.create_struct_pattern_fields(cx, &variant.data, &prefixes, addr_of);\n+                let fields = trait_.create_struct_pattern_fields(cx, &variant.data, &prefixes);\n \n                 let sp = variant.span.with_ctxt(trait_.span.ctxt());\n                 let variant_path = cx.path(sp, vec![type_ident, variant.ident]);\n@@ -1519,15 +1514,13 @@ impl<'a> TraitDef<'a> {\n         cx: &mut ExtCtxt<'_>,\n         struct_def: &'a VariantData,\n         prefixes: &[String],\n-        addr_of: bool,\n     ) -> Vec<FieldInfo> {\n         self.create_fields(struct_def, |i, _struct_field, sp| {\n             prefixes\n                 .iter()\n                 .map(|prefix| {\n                     let ident = self.mk_pattern_ident(prefix, i);\n-                    let expr = cx.expr_path(cx.path_ident(sp, ident));\n-                    if addr_of { cx.expr_addr_of(sp, expr) } else { expr }\n+                    cx.expr_path(cx.path_ident(sp, ident))\n                 })\n                 .collect()\n         })"}, {"sha": "c136bb7141ab9eef3f4b0896e20fc08a47816503", "filename": "compiler/rustc_builtin_macros/src/deriving/hash.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ca92d90b5917e7176d5ff06607a2cd5352c088d3/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca92d90b5917e7176d5ff06607a2cd5352c088d3/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fhash.rs?ref=ca92d90b5917e7176d5ff06607a2cd5352c088d3", "patch": "@@ -25,7 +25,6 @@ pub fn expand_deriving_hash(\n         path,\n         skip_path_as_bound: false,\n         additional_bounds: Vec::new(),\n-        generics: Bounds::empty(),\n         supports_unions: false,\n         methods: vec![MethodDef {\n             name: sym::hash,"}, {"sha": "edfe12963dc635adaa85b413d0fe441c8b4e73e9", "filename": "compiler/rustc_hir_typeck/src/method/suggest.rs", "status": "modified", "additions": 171, "deletions": 145, "changes": 316, "blob_url": "https://github.com/rust-lang/rust/blob/ca92d90b5917e7176d5ff06607a2cd5352c088d3/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca92d90b5917e7176d5ff06607a2cd5352c088d3/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs?ref=ca92d90b5917e7176d5ff06607a2cd5352c088d3", "patch": "@@ -20,11 +20,10 @@ use rustc_infer::infer::{\n };\n use rustc_middle::infer::unify_key::{ConstVariableOrigin, ConstVariableOriginKind};\n use rustc_middle::traits::util::supertraits;\n+use rustc_middle::ty::fast_reject::DeepRejectCtxt;\n use rustc_middle::ty::fast_reject::{simplify_type, TreatParams};\n use rustc_middle::ty::print::with_crate_prefix;\n-use rustc_middle::ty::{\n-    self, DefIdTree, GenericArg, GenericArgKind, ToPredicate, Ty, TyCtxt, TypeVisitable,\n-};\n+use rustc_middle::ty::{self, DefIdTree, GenericArgKind, ToPredicate, Ty, TyCtxt, TypeVisitable};\n use rustc_middle::ty::{IsSuggestable, ToPolyTraitRef};\n use rustc_span::symbol::{kw, sym, Ident};\n use rustc_span::Symbol;\n@@ -263,15 +262,15 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             }) => {\n                 let tcx = self.tcx;\n \n-                let actual = self.resolve_vars_if_possible(rcvr_ty);\n-                let ty_str = self.ty_to_string(actual);\n+                let rcvr_ty = self.resolve_vars_if_possible(rcvr_ty);\n+                let ty_str = self.ty_to_string(rcvr_ty);\n                 let is_method = mode == Mode::MethodCall;\n                 let item_kind = if is_method {\n                     \"method\"\n-                } else if actual.is_enum() {\n+                } else if rcvr_ty.is_enum() {\n                     \"variant or associated item\"\n                 } else {\n-                    match (item_name.as_str().chars().next(), actual.is_fresh_ty()) {\n+                    match (item_name.as_str().chars().next(), rcvr_ty.is_fresh_ty()) {\n                         (Some(name), false) if name.is_lowercase() => \"function or associated item\",\n                         (Some(_), false) => \"associated item\",\n                         (Some(_), true) | (None, false) => \"variant or associated item\",\n@@ -280,19 +279,19 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 };\n \n                 if self.suggest_wrapping_range_with_parens(\n-                    tcx, actual, source, span, item_name, &ty_str,\n+                    tcx, rcvr_ty, source, span, item_name, &ty_str,\n                 ) || self.suggest_constraining_numerical_ty(\n-                    tcx, actual, source, span, item_kind, item_name, &ty_str,\n+                    tcx, rcvr_ty, source, span, item_kind, item_name, &ty_str,\n                 ) {\n                     return None;\n                 }\n                 span = item_name.span;\n \n                 // Don't show generic arguments when the method can't be found in any implementation (#81576).\n                 let mut ty_str_reported = ty_str.clone();\n-                if let ty::Adt(_, generics) = actual.kind() {\n+                if let ty::Adt(_, generics) = rcvr_ty.kind() {\n                     if generics.len() > 0 {\n-                        let mut autoderef = self.autoderef(span, actual);\n+                        let mut autoderef = self.autoderef(span, rcvr_ty);\n                         let candidate_found = autoderef.any(|(ty, _)| {\n                             if let ty::Adt(adt_def, _) = ty.kind() {\n                                 self.tcx\n@@ -321,16 +320,16 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     \"no {} named `{}` found for {} `{}` in the current scope\",\n                     item_kind,\n                     item_name,\n-                    actual.prefix_string(self.tcx),\n+                    rcvr_ty.prefix_string(self.tcx),\n                     ty_str_reported,\n                 );\n-                if actual.references_error() {\n+                if rcvr_ty.references_error() {\n                     err.downgrade_to_delayed_bug();\n                 }\n \n                 if let Mode::MethodCall = mode && let SelfSource::MethodCall(cal) = source {\n                     self.suggest_await_before_method(\n-                        &mut err, item_name, actual, cal, span,\n+                        &mut err, item_name, rcvr_ty, cal, span,\n                     );\n                 }\n                 if let Some(span) = tcx.resolutions(()).confused_type_with_std_module.get(&span) {\n@@ -341,7 +340,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         Applicability::MachineApplicable,\n                     );\n                 }\n-                if let ty::RawPtr(_) = &actual.kind() {\n+                if let ty::RawPtr(_) = &rcvr_ty.kind() {\n                     err.note(\n                         \"try using `<*const T>::as_ref()` to get a reference to the \\\n                          type behind the pointer: https://doc.rust-lang.org/std/\\\n@@ -353,7 +352,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     );\n                 }\n \n-                let ty_span = match actual.kind() {\n+                let ty_span = match rcvr_ty.kind() {\n                     ty::Param(param_type) => Some(\n                         param_type.span_from_generics(self.tcx, self.body_id.owner.to_def_id()),\n                     ),\n@@ -365,7 +364,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         span,\n                         format!(\n                             \"{item_kind} `{item_name}` not found for this {}\",\n-                            actual.prefix_string(self.tcx)\n+                            rcvr_ty.prefix_string(self.tcx)\n                         ),\n                     );\n                 }\n@@ -398,122 +397,15 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     custom_span_label = true;\n                 }\n                 if static_candidates.len() == 1 {\n-                    let mut has_unsuggestable_args = false;\n-                    let ty_str = if let Some(CandidateSource::Impl(impl_did)) =\n-                        static_candidates.get(0)\n-                    {\n-                        // When the \"method\" is resolved through dereferencing, we really want the\n-                        // original type that has the associated function for accurate suggestions.\n-                        // (#61411)\n-                        let ty = tcx.at(span).type_of(*impl_did);\n-                        match (&ty.peel_refs().kind(), &actual.peel_refs().kind()) {\n-                            (ty::Adt(def, _), ty::Adt(def_actual, substs)) if def == def_actual => {\n-                                // If there are any inferred arguments, (`{integer}`), we should replace\n-                                // them with underscores to allow the compiler to infer them\n-                                let infer_substs: Vec<GenericArg<'_>> = substs\n-                                    .into_iter()\n-                                    .map(|arg| {\n-                                        if !arg.is_suggestable(tcx, true) {\n-                                            has_unsuggestable_args = true;\n-                                            match arg.unpack() {\n-                                            GenericArgKind::Lifetime(_) => self\n-                                                .next_region_var(RegionVariableOrigin::MiscVariable(\n-                                                    rustc_span::DUMMY_SP,\n-                                                ))\n-                                                .into(),\n-                                            GenericArgKind::Type(_) => self\n-                                                .next_ty_var(TypeVariableOrigin {\n-                                                    span: rustc_span::DUMMY_SP,\n-                                                    kind: TypeVariableOriginKind::MiscVariable,\n-                                                })\n-                                                .into(),\n-                                            GenericArgKind::Const(arg) => self\n-                                                .next_const_var(\n-                                                    arg.ty(),\n-                                                    ConstVariableOrigin {\n-                                                        span: rustc_span::DUMMY_SP,\n-                                                        kind: ConstVariableOriginKind::MiscVariable,\n-                                                    },\n-                                                )\n-                                                .into(),\n-                                            }\n-                                        } else {\n-                                            arg\n-                                        }\n-                                    })\n-                                    .collect::<Vec<_>>();\n-\n-                                tcx.value_path_str_with_substs(\n-                                    def_actual.did(),\n-                                    tcx.intern_substs(&infer_substs),\n-                                )\n-                            }\n-                            _ => self.ty_to_value_string(ty.peel_refs()),\n-                        }\n-                    } else {\n-                        self.ty_to_value_string(actual.peel_refs())\n-                    };\n-                    if let SelfSource::MethodCall(_) = source {\n-                        let first_arg = if let Some(CandidateSource::Impl(impl_did)) = static_candidates.get(0) &&\n-                            let Some(assoc) = self.associated_value(*impl_did, item_name) {\n-                            let sig = self.tcx.fn_sig(assoc.def_id);\n-                            if let Some(first) = sig.inputs().skip_binder().get(0) {\n-                                if first.peel_refs() == rcvr_ty.peel_refs() {\n-                                    None\n-                                } else {\n-                                    Some(if first.is_region_ptr() {\n-                                        if first.is_mutable_ptr() { \"&mut \" } else { \"&\" }\n-                                    } else {\n-                                        \"\"\n-                                    })\n-                                }\n-                            } else {\n-                                None\n-                            }\n-                        } else {\n-                            None\n-                        };\n-                        let mut applicability = Applicability::MachineApplicable;\n-                        let args = if let Some((receiver, args)) = args {\n-                            // The first arg is the same kind as the receiver\n-                            let explicit_args = if first_arg.is_some() {\n-                                std::iter::once(receiver).chain(args.iter()).collect::<Vec<_>>()\n-                            } else {\n-                                // There is no `Self` kind to infer the arguments from\n-                                if has_unsuggestable_args {\n-                                    applicability = Applicability::HasPlaceholders;\n-                                }\n-                                args.iter().collect()\n-                            };\n-                            format!(\n-                                \"({}{})\",\n-                                first_arg.unwrap_or(\"\"),\n-                                explicit_args\n-                                    .iter()\n-                                    .map(|arg| tcx\n-                                        .sess\n-                                        .source_map()\n-                                        .span_to_snippet(arg.span)\n-                                        .unwrap_or_else(|_| {\n-                                            applicability = Applicability::HasPlaceholders;\n-                                            \"_\".to_owned()\n-                                        }))\n-                                    .collect::<Vec<_>>()\n-                                    .join(\", \"),\n-                            )\n-                        } else {\n-                            applicability = Applicability::HasPlaceholders;\n-                            \"(...)\".to_owned()\n-                        };\n-                        err.span_suggestion(\n-                            sugg_span,\n-                            \"use associated function syntax instead\",\n-                            format!(\"{}::{}{}\", ty_str, item_name, args),\n-                            applicability,\n-                        );\n-                    } else {\n-                        err.help(&format!(\"try with `{}::{}`\", ty_str, item_name,));\n-                    }\n+                    self.suggest_associated_call_syntax(\n+                        &mut err,\n+                        &static_candidates,\n+                        rcvr_ty,\n+                        source,\n+                        item_name,\n+                        args,\n+                        sugg_span,\n+                    );\n \n                     report_candidates(span, &mut err, &mut static_candidates, sugg_span);\n                 } else if static_candidates.len() > 1 {\n@@ -523,7 +415,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 let mut bound_spans = vec![];\n                 let mut restrict_type_params = false;\n                 let mut unsatisfied_bounds = false;\n-                if item_name.name == sym::count && self.is_slice_ty(actual, span) {\n+                if item_name.name == sym::count && self.is_slice_ty(rcvr_ty, span) {\n                     let msg = \"consider using `len` instead\";\n                     if let SelfSource::MethodCall(_expr) = source {\n                         err.span_suggestion_short(\n@@ -537,7 +429,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     }\n                     if let Some(iterator_trait) = self.tcx.get_diagnostic_item(sym::Iterator) {\n                         let iterator_trait = self.tcx.def_path_str(iterator_trait);\n-                        err.note(&format!(\"`count` is defined on `{iterator_trait}`, which `{actual}` does not implement\"));\n+                        err.note(&format!(\"`count` is defined on `{iterator_trait}`, which `{rcvr_ty}` does not implement\"));\n                     }\n                 } else if !unsatisfied_predicates.is_empty() {\n                     let mut type_params = FxHashMap::default();\n@@ -876,7 +768,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             .map(|(_, path)| path)\n                             .collect::<Vec<_>>()\n                             .join(\"\\n\");\n-                        let actual_prefix = actual.prefix_string(self.tcx);\n+                        let actual_prefix = rcvr_ty.prefix_string(self.tcx);\n                         info!(\"unimplemented_traits.len() == {}\", unimplemented_traits.len());\n                         let (primary_message, label) =\n                             if unimplemented_traits.len() == 1 && unimplemented_traits_only {\n@@ -885,7 +777,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                     .next()\n                                     .map(|(_, (trait_ref, obligation))| {\n                                         if trait_ref.self_ty().references_error()\n-                                            || actual.references_error()\n+                                            || rcvr_ty.references_error()\n                                         {\n                                             // Avoid crashing.\n                                             return (None, None);\n@@ -921,7 +813,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 let label_span_not_found = |err: &mut Diagnostic| {\n                     if unsatisfied_predicates.is_empty() {\n                         err.span_label(span, format!(\"{item_kind} not found in `{ty_str}`\"));\n-                        let is_string_or_ref_str = match actual.kind() {\n+                        let is_string_or_ref_str = match rcvr_ty.kind() {\n                             ty::Ref(_, ty, _) => {\n                                 ty.is_str()\n                                     || matches!(\n@@ -957,7 +849,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                                 // different from the received one\n                                                 // So we avoid suggestion method with Box<Self>\n                                                 // for instance\n-                                                self.tcx.at(span).type_of(*def_id) != actual\n+                                                self.tcx.at(span).type_of(*def_id) != rcvr_ty\n                                                     && self.tcx.at(span).type_of(*def_id) != rcvr_ty\n                                             }\n                                             (Mode::Path, false, _) => true,\n@@ -1017,18 +909,20 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 // Don't suggest (for example) `expr.field.clone()` if `expr.clone()`\n                 // can't be called due to `typeof(expr): Clone` not holding.\n                 if unsatisfied_predicates.is_empty() {\n-                    self.suggest_calling_method_on_field(&mut err, source, span, actual, item_name);\n+                    self.suggest_calling_method_on_field(\n+                        &mut err, source, span, rcvr_ty, item_name,\n+                    );\n                 }\n \n-                self.check_for_inner_self(&mut err, source, span, actual, item_name);\n+                self.check_for_inner_self(&mut err, source, span, rcvr_ty, item_name);\n \n                 bound_spans.sort();\n                 bound_spans.dedup();\n                 for (span, msg) in bound_spans.into_iter() {\n                     err.span_label(span, &msg);\n                 }\n \n-                if actual.is_numeric() && actual.is_fresh() || restrict_type_params {\n+                if rcvr_ty.is_numeric() && rcvr_ty.is_fresh() || restrict_type_params {\n                 } else {\n                     self.suggest_traits_to_import(\n                         &mut err,\n@@ -1046,8 +940,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n                 // Don't emit a suggestion if we found an actual method\n                 // that had unsatisfied trait bounds\n-                if unsatisfied_predicates.is_empty() && actual.is_enum() {\n-                    let adt_def = actual.ty_adt_def().expect(\"enum is not an ADT\");\n+                if unsatisfied_predicates.is_empty() && rcvr_ty.is_enum() {\n+                    let adt_def = rcvr_ty.ty_adt_def().expect(\"enum is not an ADT\");\n                     if let Some(suggestion) = lev_distance::find_best_match_for_name(\n                         &adt_def.variants().iter().map(|s| s.name).collect::<Vec<_>>(),\n                         item_name.name,\n@@ -1062,7 +956,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     }\n                 }\n \n-                if item_name.name == sym::as_str && actual.peel_refs().is_str() {\n+                if item_name.name == sym::as_str && rcvr_ty.peel_refs().is_str() {\n                     let msg = \"remove this method call\";\n                     let mut fallback_span = true;\n                     if let SelfSource::MethodCall(expr) = source {\n@@ -1178,6 +1072,138 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         None\n     }\n \n+    /// Suggest calling `Ty::method` if `.method()` isn't found because the method\n+    /// doesn't take a `self` receiver.\n+    fn suggest_associated_call_syntax(\n+        &self,\n+        err: &mut Diagnostic,\n+        static_candidates: &Vec<CandidateSource>,\n+        rcvr_ty: Ty<'tcx>,\n+        source: SelfSource<'tcx>,\n+        item_name: Ident,\n+        args: Option<(&hir::Expr<'tcx>, &[hir::Expr<'tcx>])>,\n+        sugg_span: Span,\n+    ) {\n+        let mut has_unsuggestable_args = false;\n+        let ty_str = if let Some(CandidateSource::Impl(impl_did)) = static_candidates.get(0) {\n+            // When the \"method\" is resolved through dereferencing, we really want the\n+            // original type that has the associated function for accurate suggestions.\n+            // (#61411)\n+            let impl_ty = self.tcx.type_of(*impl_did);\n+            let target_ty = self\n+                .autoderef(sugg_span, rcvr_ty)\n+                .find(|(rcvr_ty, _)| {\n+                    DeepRejectCtxt { treat_obligation_params: TreatParams::AsInfer }\n+                        .types_may_unify(*rcvr_ty, impl_ty)\n+                })\n+                .map_or(impl_ty, |(ty, _)| ty)\n+                .peel_refs();\n+            if let ty::Adt(def, substs) = target_ty.kind() {\n+                // If there are any inferred arguments, (`{integer}`), we should replace\n+                // them with underscores to allow the compiler to infer them\n+                let infer_substs = self.tcx.mk_substs(substs.into_iter().map(|arg| {\n+                    if !arg.is_suggestable(self.tcx, true) {\n+                        has_unsuggestable_args = true;\n+                        match arg.unpack() {\n+                            GenericArgKind::Lifetime(_) => self\n+                                .next_region_var(RegionVariableOrigin::MiscVariable(\n+                                    rustc_span::DUMMY_SP,\n+                                ))\n+                                .into(),\n+                            GenericArgKind::Type(_) => self\n+                                .next_ty_var(TypeVariableOrigin {\n+                                    span: rustc_span::DUMMY_SP,\n+                                    kind: TypeVariableOriginKind::MiscVariable,\n+                                })\n+                                .into(),\n+                            GenericArgKind::Const(arg) => self\n+                                .next_const_var(\n+                                    arg.ty(),\n+                                    ConstVariableOrigin {\n+                                        span: rustc_span::DUMMY_SP,\n+                                        kind: ConstVariableOriginKind::MiscVariable,\n+                                    },\n+                                )\n+                                .into(),\n+                        }\n+                    } else {\n+                        arg\n+                    }\n+                }));\n+\n+                self.tcx.value_path_str_with_substs(def.did(), infer_substs)\n+            } else {\n+                self.ty_to_value_string(target_ty)\n+            }\n+        } else {\n+            self.ty_to_value_string(rcvr_ty.peel_refs())\n+        };\n+        if let SelfSource::MethodCall(_) = source {\n+            let first_arg = if let Some(CandidateSource::Impl(impl_did)) = static_candidates.get(0)\n+                && let Some(assoc) = self.associated_value(*impl_did, item_name)\n+                && assoc.kind == ty::AssocKind::Fn\n+            {\n+                let sig = self.tcx.fn_sig(assoc.def_id);\n+                if let Some(first) = sig.inputs().skip_binder().get(0) {\n+                    if first.peel_refs() == rcvr_ty.peel_refs() {\n+                        None\n+                    } else {\n+                        Some(if first.is_region_ptr() {\n+                            if first.is_mutable_ptr() { \"&mut \" } else { \"&\" }\n+                        } else {\n+                            \"\"\n+                        })\n+                    }\n+                } else {\n+                    None\n+                }\n+            } else {\n+                None\n+            };\n+            let mut applicability = Applicability::MachineApplicable;\n+            let args = if let Some((receiver, args)) = args {\n+                // The first arg is the same kind as the receiver\n+                let explicit_args = if first_arg.is_some() {\n+                    std::iter::once(receiver).chain(args.iter()).collect::<Vec<_>>()\n+                } else {\n+                    // There is no `Self` kind to infer the arguments from\n+                    if has_unsuggestable_args {\n+                        applicability = Applicability::HasPlaceholders;\n+                    }\n+                    args.iter().collect()\n+                };\n+                format!(\n+                    \"({}{})\",\n+                    first_arg.unwrap_or(\"\"),\n+                    explicit_args\n+                        .iter()\n+                        .map(|arg| self\n+                            .tcx\n+                            .sess\n+                            .source_map()\n+                            .span_to_snippet(arg.span)\n+                            .unwrap_or_else(|_| {\n+                                applicability = Applicability::HasPlaceholders;\n+                                \"_\".to_owned()\n+                            }))\n+                        .collect::<Vec<_>>()\n+                        .join(\", \"),\n+                )\n+            } else {\n+                applicability = Applicability::HasPlaceholders;\n+                \"(...)\".to_owned()\n+            };\n+            err.span_suggestion(\n+                sugg_span,\n+                \"use associated function syntax instead\",\n+                format!(\"{}::{}{}\", ty_str, item_name, args),\n+                applicability,\n+            );\n+        } else {\n+            err.help(&format!(\"try with `{}::{}`\", ty_str, item_name,));\n+        }\n+    }\n+\n     /// Suggest calling a field with a type that implements the `Fn*` traits instead of a method with\n     /// the same name as the field i.e. `(a.my_fn_ptr)(10)` instead of `a.my_fn_ptr(10)`.\n     fn suggest_calling_field_as_fn("}, {"sha": "c8939256bbbf6856724beacad7a4760bd9ee3463", "filename": "compiler/rustc_lint/src/let_underscore.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ca92d90b5917e7176d5ff06607a2cd5352c088d3/compiler%2Frustc_lint%2Fsrc%2Flet_underscore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca92d90b5917e7176d5ff06607a2cd5352c088d3/compiler%2Frustc_lint%2Fsrc%2Flet_underscore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Flet_underscore.rs?ref=ca92d90b5917e7176d5ff06607a2cd5352c088d3", "patch": "@@ -11,7 +11,8 @@ declare_lint! {\n     /// scope.\n     ///\n     /// ### Example\n-    /// ```\n+    ///\n+    /// ```rust\n     /// struct SomeStruct;\n     /// impl Drop for SomeStruct {\n     ///     fn drop(&mut self) {"}, {"sha": "85c520a7911f3dde738c01cd5e7454980dc263da", "filename": "compiler/rustc_llvm/llvm-wrapper/RustWrapper.cpp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ca92d90b5917e7176d5ff06607a2cd5352c088d3/compiler%2Frustc_llvm%2Fllvm-wrapper%2FRustWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/ca92d90b5917e7176d5ff06607a2cd5352c088d3/compiler%2Frustc_llvm%2Fllvm-wrapper%2FRustWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_llvm%2Fllvm-wrapper%2FRustWrapper.cpp?ref=ca92d90b5917e7176d5ff06607a2cd5352c088d3", "patch": "@@ -9,7 +9,7 @@\n #include \"llvm/IR/IntrinsicsARM.h\"\n #include \"llvm/IR/Mangler.h\"\n #if LLVM_VERSION_GE(16, 0)\n-#include \"llvm/IR/ModRef.h\"\n+#include \"llvm/Support/ModRef.h\"\n #endif\n #include \"llvm/Object/Archive.h\"\n #include \"llvm/Object/COFFImportFile.h\""}, {"sha": "bad6d58790708859b1e82fe95df0fd52ef73825f", "filename": "compiler/rustc_span/src/symbol.rs", "status": "modified", "additions": 1, "deletions": 52, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/ca92d90b5917e7176d5ff06607a2cd5352c088d3/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca92d90b5917e7176d5ff06607a2cd5352c088d3/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs?ref=ca92d90b5917e7176d5ff06607a2cd5352c088d3", "patch": "@@ -170,8 +170,6 @@ symbols! {\n         Count,\n         Cow,\n         Debug,\n-        DebugStruct,\n-        DebugTuple,\n         Decodable,\n         Decoder,\n         DecorateLint,\n@@ -190,9 +188,6 @@ symbols! {\n         Error,\n         File,\n         FileType,\n-        Fn,\n-        FnMut,\n-        FnOnce,\n         FormatSpec,\n         Formatter,\n         From,\n@@ -211,7 +206,6 @@ symbols! {\n         Input,\n         Into,\n         IntoDiagnostic,\n-        IntoFuture,\n         IntoIterator,\n         IoRead,\n         IoWrite,\n@@ -256,7 +250,6 @@ symbols! {\n         Pointer,\n         Poll,\n         ProcMacro,\n-        ProcMacroHack,\n         ProceduralMasqueradeDummyType,\n         Range,\n         RangeFrom,\n@@ -332,7 +325,6 @@ symbols! {\n         abi_vectorcall,\n         abi_x86_interrupt,\n         abort,\n-        aborts,\n         add,\n         add_assign,\n         add_with_overflow,\n@@ -344,7 +336,6 @@ symbols! {\n         align,\n         align_offset,\n         alignment,\n-        alignstack,\n         all,\n         alloc,\n         alloc_error_handler,\n@@ -433,7 +424,6 @@ symbols! {\n         bool,\n         borrowck_graphviz_format,\n         borrowck_graphviz_postflow,\n-        borrowck_graphviz_preflow,\n         box_free,\n         box_patterns,\n         box_syntax,\n@@ -462,15 +452,13 @@ symbols! {\n         cfg_doctest,\n         cfg_eval,\n         cfg_hide,\n-        cfg_macro,\n         cfg_panic,\n         cfg_sanitize,\n         cfg_target_abi,\n         cfg_target_compact,\n         cfg_target_feature,\n         cfg_target_has_atomic,\n         cfg_target_has_atomic_equal_alignment,\n-        cfg_target_has_atomic_load_store,\n         cfg_target_thread_local,\n         cfg_target_vendor,\n         cfg_version,\n@@ -495,19 +483,15 @@ symbols! {\n         cold,\n         collapse_debuginfo,\n         column,\n-        column_macro,\n-        compare_and_swap,\n         compare_exchange,\n         compare_exchange_weak,\n         compile_error,\n-        compile_error_macro,\n         compiler,\n         compiler_builtins,\n         compiler_fence,\n         concat,\n         concat_bytes,\n         concat_idents,\n-        concat_macro,\n         conservative_impl_trait,\n         console,\n         const_allocate,\n@@ -528,7 +512,6 @@ symbols! {\n         const_fn_unsize,\n         const_for,\n         const_format_args,\n-        const_generic_defaults,\n         const_generics,\n         const_generics_defaults,\n         const_if_match,\n@@ -547,22 +530,19 @@ symbols! {\n         const_trait,\n         const_trait_bound_opt_out,\n         const_trait_impl,\n-        const_transmute,\n         const_try,\n         constant,\n         constructor,\n-        contents,\n         context,\n-        convert,\n         copy,\n         copy_closures,\n         copy_nonoverlapping,\n         copysignf32,\n         copysignf64,\n         core,\n-        core_intrinsics,\n         core_panic,\n         core_panic_2015_macro,\n+        core_panic_2021_macro,\n         core_panic_macro,\n         cosf32,\n         cosf64,\n@@ -598,7 +578,6 @@ symbols! {\n         debug_assertions,\n         debug_struct,\n         debug_struct_fields_finish,\n-        debug_trait_builder,\n         debug_tuple,\n         debug_tuple_fields_finish,\n         debugger_visualizer,\n@@ -630,7 +609,6 @@ symbols! {\n         discriminant_type,\n         discriminant_value,\n         dispatch_from_dyn,\n-        display_trait,\n         div,\n         div_assign,\n         doc,\n@@ -661,7 +639,6 @@ symbols! {\n         dyn_star,\n         dyn_trait,\n         e,\n-        edition_macro_pats,\n         edition_panic,\n         eh_catch_typeinfo,\n         eh_personality,\n@@ -674,7 +651,6 @@ symbols! {\n         encode,\n         end,\n         env,\n-        env_macro,\n         eprint_macro,\n         eprintln_macro,\n         eq,\n@@ -724,9 +700,7 @@ symbols! {\n         field,\n         field_init_shorthand,\n         file,\n-        file_macro,\n         fill,\n-        finish,\n         flags,\n         float,\n         float_to_int_unchecked,\n@@ -735,8 +709,6 @@ symbols! {\n         fmaf32,\n         fmaf64,\n         fmt,\n-        fmt_as_str,\n-        fmt_internals,\n         fmul_fast,\n         fn_align,\n         fn_must_use,\n@@ -751,7 +723,6 @@ symbols! {\n         format_args_macro,\n         format_args_nl,\n         format_macro,\n-        fp,\n         freeze,\n         freg,\n         frem_fast,\n@@ -814,7 +785,6 @@ symbols! {\n         ignore,\n         impl_header_lifetime_elision,\n         impl_lint_pass,\n-        impl_macros,\n         impl_trait_in_bindings,\n         impl_trait_in_fn_trait_return,\n         implied_by,\n@@ -826,7 +796,6 @@ symbols! {\n         include,\n         include_bytes,\n         include_bytes_macro,\n-        include_macro,\n         include_str,\n         include_str_macro,\n         inclusive_range_syntax,\n@@ -844,7 +813,6 @@ symbols! {\n         instruction_set,\n         integer_: \"integer\",\n         integral,\n-        intel,\n         into_future,\n         into_iter,\n         intra_doc_pointers,\n@@ -881,7 +849,6 @@ symbols! {\n         lifetimes,\n         likely,\n         line,\n-        line_macro,\n         link,\n         link_args,\n         link_cfg,\n@@ -926,7 +893,6 @@ symbols! {\n         masked,\n         match_beginning_vert,\n         match_default_bindings,\n-        matches_macro,\n         maxnumf32,\n         maxnumf64,\n         may_dangle,\n@@ -965,7 +931,6 @@ symbols! {\n         modifiers,\n         module,\n         module_path,\n-        module_path_macro,\n         more_qualified_paths,\n         more_struct_aliases,\n         movbe_target_feature,\n@@ -1035,7 +1000,6 @@ symbols! {\n         non_exhaustive,\n         non_exhaustive_omitted_patterns_lint,\n         non_modrs_mods,\n-        none_error,\n         nontemporal_store,\n         noop_method_borrow,\n         noop_method_clone,\n@@ -1060,7 +1024,6 @@ symbols! {\n         optin_builtin_traits,\n         option,\n         option_env,\n-        option_env_macro,\n         options,\n         or,\n         or_patterns,\n@@ -1103,7 +1066,6 @@ symbols! {\n         plugins,\n         pointee_trait,\n         pointer,\n-        pointer_trait_fmt,\n         poll,\n         position,\n         post_dash_lto: \"post-lto\",\n@@ -1130,7 +1092,6 @@ symbols! {\n         proc_dash_macro: \"proc-macro\",\n         proc_macro,\n         proc_macro_attribute,\n-        proc_macro_def_site,\n         proc_macro_derive,\n         proc_macro_expr,\n         proc_macro_gen,\n@@ -1231,9 +1192,6 @@ symbols! {\n         rust_cold_cc,\n         rust_eh_catch_typeinfo,\n         rust_eh_personality,\n-        rust_eh_register_frames,\n-        rust_eh_unregister_frames,\n-        rust_oom,\n         rustc,\n         rustc_allocator,\n         rustc_allocator_zeroed,\n@@ -1306,7 +1264,6 @@ symbols! {\n         rustc_serialize,\n         rustc_skip_array_during_method_dispatch,\n         rustc_specialization_trait,\n-        rustc_stable,\n         rustc_std_internal_symbol,\n         rustc_strict_coherence,\n         rustc_symbol_name,\n@@ -1434,7 +1391,6 @@ symbols! {\n         static_recursion,\n         staticlib,\n         std,\n-        std_inject,\n         std_panic,\n         std_panic_2015_macro,\n         std_panic_macro,\n@@ -1449,7 +1405,6 @@ symbols! {\n         str_trim_start,\n         strict_provenance,\n         stringify,\n-        stringify_macro,\n         struct_field_attributes,\n         struct_inherit,\n         struct_variant,\n@@ -1477,10 +1432,8 @@ symbols! {\n         target_has_atomic_load_store,\n         target_os,\n         target_pointer_width,\n-        target_target_vendor,\n         target_thread_local,\n         target_vendor,\n-        task,\n         tbm_target_feature,\n         termination,\n         termination_trait,\n@@ -1492,7 +1445,6 @@ symbols! {\n         test_removed_feature,\n         test_runner,\n         test_unstable_lint,\n-        then_with,\n         thread,\n         thread_local,\n         thread_local_macro,\n@@ -1524,7 +1476,6 @@ symbols! {\n         try_trait_v2,\n         tt,\n         tuple,\n-        tuple_from_req,\n         tuple_indexing,\n         tuple_trait,\n         two_phase,\n@@ -1568,7 +1519,6 @@ symbols! {\n         unreachable_2015,\n         unreachable_2015_macro,\n         unreachable_2021,\n-        unreachable_2021_macro,\n         unreachable_code,\n         unreachable_display,\n         unreachable_macro,\n@@ -1587,7 +1537,6 @@ symbols! {\n                           from crates.io via `Cargo.toml` instead?\",\n         untagged_unions,\n         unused_imports,\n-        unused_qualifications,\n         unwind,\n         unwind_attributes,\n         unwind_safe_trait,"}, {"sha": "41b252a82651cb7799e318baa346c03af1401b64", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 8, "deletions": 35, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/ca92d90b5917e7176d5ff06607a2cd5352c088d3/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca92d90b5917e7176d5ff06607a2cd5352c088d3/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=ca92d90b5917e7176d5ff06607a2cd5352c088d3", "patch": "@@ -650,41 +650,14 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                                 ))\n                         );\n \n-                        if is_try_conversion {\n-                            let none_error = self\n-                                .tcx\n-                                .get_diagnostic_item(sym::none_error)\n-                                .map(|def_id| tcx.type_of(def_id));\n-                            let should_convert_option_to_result =\n-                                Some(trait_ref.skip_binder().substs.type_at(1)) == none_error;\n-                            let should_convert_result_to_option =\n-                                Some(trait_ref.self_ty().skip_binder()) == none_error;\n-                            if should_convert_option_to_result {\n-                                err.span_suggestion_verbose(\n-                                    span.shrink_to_lo(),\n-                                    \"consider converting the `Option<T>` into a `Result<T, _>` \\\n-                                     using `Option::ok_or` or `Option::ok_or_else`\",\n-                                    \".ok_or_else(|| /* error value */)\",\n-                                    Applicability::HasPlaceholders,\n-                                );\n-                            } else if should_convert_result_to_option {\n-                                err.span_suggestion_verbose(\n-                                    span.shrink_to_lo(),\n-                                    \"consider converting the `Result<T, _>` into an `Option<T>` \\\n-                                     using `Result::ok`\",\n-                                    \".ok()\",\n-                                    Applicability::MachineApplicable,\n-                                );\n-                            }\n-                            if let Some(ret_span) = self.return_type_span(&obligation) {\n-                                err.span_label(\n-                                    ret_span,\n-                                    &format!(\n-                                        \"expected `{}` because of this\",\n-                                        trait_ref.skip_binder().self_ty()\n-                                    ),\n-                                );\n-                            }\n+                        if is_try_conversion && let Some(ret_span) = self.return_type_span(&obligation) {\n+                            err.span_label(\n+                                ret_span,\n+                                &format!(\n+                                    \"expected `{}` because of this\",\n+                                    trait_ref.skip_binder().self_ty()\n+                                ),\n+                            );\n                         }\n \n                         if Some(trait_ref.def_id()) == tcx.lang_items().tuple_trait() {"}, {"sha": "2adc968bd469276929609a7a50ceba0e544a1103", "filename": "library/core/src/fmt/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ca92d90b5917e7176d5ff06607a2cd5352c088d3/library%2Fcore%2Fsrc%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca92d90b5917e7176d5ff06607a2cd5352c088d3/library%2Fcore%2Fsrc%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Ffmt%2Fmod.rs?ref=ca92d90b5917e7176d5ff06607a2cd5352c088d3", "patch": "@@ -1054,7 +1054,6 @@ pub trait UpperHex {\n pub trait Pointer {\n     /// Formats the value using the given formatter.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[rustc_diagnostic_item = \"pointer_trait_fmt\"]\n     fn fmt(&self, f: &mut Formatter<'_>) -> Result;\n }\n "}, {"sha": "34247c058450851402a6160af94d653010fb8842", "filename": "library/core/src/macros/mod.rs", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ca92d90b5917e7176d5ff06607a2cd5352c088d3/library%2Fcore%2Fsrc%2Fmacros%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca92d90b5917e7176d5ff06607a2cd5352c088d3/library%2Fcore%2Fsrc%2Fmacros%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fmacros%2Fmod.rs?ref=ca92d90b5917e7176d5ff06607a2cd5352c088d3", "patch": "@@ -338,7 +338,6 @@ pub macro debug_assert_matches($($arg:tt)*) {\n /// ```\n #[macro_export]\n #[stable(feature = \"matches_macro\", since = \"1.42.0\")]\n-#[cfg_attr(not(test), rustc_diagnostic_item = \"matches_macro\")]\n macro_rules! matches {\n     ($expression:expr, $(|)? $( $pattern:pat_param )|+ $( if $guard: expr )? $(,)?) => {\n         match $expression {\n@@ -820,7 +819,6 @@ pub(crate) mod builtin {\n     #[stable(feature = \"compile_error_macro\", since = \"1.20.0\")]\n     #[rustc_builtin_macro]\n     #[macro_export]\n-    #[cfg_attr(not(test), rustc_diagnostic_item = \"compile_error_macro\")]\n     macro_rules! compile_error {\n         ($msg:expr $(,)?) => {{ /* compiler built-in */ }};\n     }\n@@ -944,7 +942,6 @@ pub(crate) mod builtin {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[rustc_builtin_macro]\n     #[macro_export]\n-    #[cfg_attr(not(test), rustc_diagnostic_item = \"env_macro\")]\n     macro_rules! env {\n         ($name:expr $(,)?) => {{ /* compiler built-in */ }};\n         ($name:expr, $error_msg:expr $(,)?) => {{ /* compiler built-in */ }};\n@@ -973,7 +970,6 @@ pub(crate) mod builtin {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[rustc_builtin_macro]\n     #[macro_export]\n-    #[cfg_attr(not(test), rustc_diagnostic_item = \"option_env_macro\")]\n     macro_rules! option_env {\n         ($name:expr $(,)?) => {{ /* compiler built-in */ }};\n     }\n@@ -1058,7 +1054,6 @@ pub(crate) mod builtin {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[rustc_builtin_macro]\n     #[macro_export]\n-    #[cfg_attr(not(test), rustc_diagnostic_item = \"concat_macro\")]\n     macro_rules! concat {\n         ($($e:expr),* $(,)?) => {{ /* compiler built-in */ }};\n     }\n@@ -1084,7 +1079,6 @@ pub(crate) mod builtin {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[rustc_builtin_macro]\n     #[macro_export]\n-    #[cfg_attr(not(test), rustc_diagnostic_item = \"line_macro\")]\n     macro_rules! line {\n         () => {\n             /* compiler built-in */\n@@ -1124,7 +1118,6 @@ pub(crate) mod builtin {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[rustc_builtin_macro]\n     #[macro_export]\n-    #[cfg_attr(not(test), rustc_diagnostic_item = \"column_macro\")]\n     macro_rules! column {\n         () => {\n             /* compiler built-in */\n@@ -1150,7 +1143,6 @@ pub(crate) mod builtin {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[rustc_builtin_macro]\n     #[macro_export]\n-    #[cfg_attr(not(test), rustc_diagnostic_item = \"file_macro\")]\n     macro_rules! file {\n         () => {\n             /* compiler built-in */\n@@ -1175,7 +1167,6 @@ pub(crate) mod builtin {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[rustc_builtin_macro]\n     #[macro_export]\n-    #[cfg_attr(not(test), rustc_diagnostic_item = \"stringify_macro\")]\n     macro_rules! stringify {\n         ($($t:tt)*) => {\n             /* compiler built-in */\n@@ -1282,7 +1273,6 @@ pub(crate) mod builtin {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[rustc_builtin_macro]\n     #[macro_export]\n-    #[cfg_attr(not(test), rustc_diagnostic_item = \"module_path_macro\")]\n     macro_rules! module_path {\n         () => {\n             /* compiler built-in */\n@@ -1316,7 +1306,6 @@ pub(crate) mod builtin {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[rustc_builtin_macro]\n     #[macro_export]\n-    #[cfg_attr(not(test), rustc_diagnostic_item = \"cfg_macro\")]\n     macro_rules! cfg {\n         ($($cfg:tt)*) => {\n             /* compiler built-in */\n@@ -1367,7 +1356,6 @@ pub(crate) mod builtin {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[rustc_builtin_macro]\n     #[macro_export]\n-    #[cfg_attr(not(test), rustc_diagnostic_item = \"include_macro\")]\n     macro_rules! include {\n         ($file:expr $(,)?) => {{ /* compiler built-in */ }};\n     }"}, {"sha": "6a417b54daa93ff7ca2b43cf5a58aeddf13e9511", "filename": "library/core/src/num/nonzero.rs", "status": "modified", "additions": 6, "deletions": 20, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/ca92d90b5917e7176d5ff06607a2cd5352c088d3/library%2Fcore%2Fsrc%2Fnum%2Fnonzero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca92d90b5917e7176d5ff06607a2cd5352c088d3/library%2Fcore%2Fsrc%2Fnum%2Fnonzero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fnonzero.rs?ref=ca92d90b5917e7176d5ff06607a2cd5352c088d3", "patch": "@@ -321,7 +321,6 @@ macro_rules! nonzero_unsigned_operations {\n                 ///\n                 /// ```\n                 #[doc = concat!(\"# use std::num::\", stringify!($Ty), \";\")]\n-                ///\n                 /// # fn main() { test().unwrap(); }\n                 /// # fn test() -> Option<()> {\n                 #[doc = concat!(\"let one = \", stringify!($Ty), \"::new(1)?;\")]\n@@ -356,7 +355,6 @@ macro_rules! nonzero_unsigned_operations {\n                 ///\n                 /// ```\n                 #[doc = concat!(\"# use std::num::\", stringify!($Ty), \";\")]\n-                ///\n                 /// # fn main() { test().unwrap(); }\n                 /// # fn test() -> Option<()> {\n                 #[doc = concat!(\"let one = \", stringify!($Ty), \"::new(1)?;\")]\n@@ -391,8 +389,8 @@ macro_rules! nonzero_unsigned_operations {\n                 ///\n                 /// ```\n                 /// #![feature(nonzero_ops)]\n-                #[doc = concat!(\"# use std::num::\", stringify!($Ty), \";\")]\n                 ///\n+                #[doc = concat!(\"# use std::num::\", stringify!($Ty), \";\")]\n                 /// # fn main() { test().unwrap(); }\n                 /// # fn test() -> Option<()> {\n                 #[doc = concat!(\"let one = \", stringify!($Ty), \"::new(1)?;\")]\n@@ -420,7 +418,6 @@ macro_rules! nonzero_unsigned_operations {\n                 ///\n                 /// ```\n                 #[doc = concat!(\"# use std::num::\", stringify!($Ty), \";\")]\n-                ///\n                 /// # fn main() { test().unwrap(); }\n                 /// # fn test() -> Option<()> {\n                 #[doc = concat!(\"let two = \", stringify!($Ty), \"::new(2)?;\")]\n@@ -461,7 +458,6 @@ macro_rules! nonzero_unsigned_operations {\n                 ///\n                 /// ```\n                 #[doc = concat!(\"# use std::num::\", stringify!($Ty), \";\")]\n-                ///\n                 #[doc = concat!(\"assert_eq!(\", stringify!($Ty), \"::new(7).unwrap().ilog2(), 2);\")]\n                 #[doc = concat!(\"assert_eq!(\", stringify!($Ty), \"::new(8).unwrap().ilog2(), 3);\")]\n                 #[doc = concat!(\"assert_eq!(\", stringify!($Ty), \"::new(9).unwrap().ilog2(), 3);\")]\n@@ -486,7 +482,6 @@ macro_rules! nonzero_unsigned_operations {\n                 ///\n                 /// ```\n                 #[doc = concat!(\"# use std::num::\", stringify!($Ty), \";\")]\n-                ///\n                 #[doc = concat!(\"assert_eq!(\", stringify!($Ty), \"::new(99).unwrap().ilog10(), 1);\")]\n                 #[doc = concat!(\"assert_eq!(\", stringify!($Ty), \"::new(100).unwrap().ilog10(), 2);\")]\n                 #[doc = concat!(\"assert_eq!(\", stringify!($Ty), \"::new(101).unwrap().ilog10(), 2);\")]\n@@ -526,7 +521,6 @@ macro_rules! nonzero_signed_operations {\n                 ///\n                 /// ```\n                 #[doc = concat!(\"# use std::num::\", stringify!($Ty), \";\")]\n-                ///\n                 /// # fn main() { test().unwrap(); }\n                 /// # fn test() -> Option<()> {\n                 #[doc = concat!(\"let pos = \", stringify!($Ty), \"::new(1)?;\")]\n@@ -556,7 +550,6 @@ macro_rules! nonzero_signed_operations {\n                 ///\n                 /// ```\n                 #[doc = concat!(\"# use std::num::\", stringify!($Ty), \";\")]\n-                ///\n                 /// # fn main() { test().unwrap(); }\n                 /// # fn test() -> Option<()> {\n                 #[doc = concat!(\"let pos = \", stringify!($Ty), \"::new(1)?;\")]\n@@ -591,7 +584,6 @@ macro_rules! nonzero_signed_operations {\n                 ///\n                 /// ```\n                 #[doc = concat!(\"# use std::num::\", stringify!($Ty), \";\")]\n-                ///\n                 /// # fn main() { test().unwrap(); }\n                 /// # fn test() -> Option<()> {\n                 #[doc = concat!(\"let pos = \", stringify!($Ty), \"::new(1)?;\")]\n@@ -626,7 +618,6 @@ macro_rules! nonzero_signed_operations {\n                 ///\n                 /// ```\n                 #[doc = concat!(\"# use std::num::\", stringify!($Ty), \";\")]\n-                ///\n                 /// # fn main() { test().unwrap(); }\n                 /// # fn test() -> Option<()> {\n                 #[doc = concat!(\"let pos = \", stringify!($Ty), \"::new(1)?;\")]\n@@ -662,7 +653,6 @@ macro_rules! nonzero_signed_operations {\n                 ///\n                 /// ```\n                 #[doc = concat!(\"# use std::num::\", stringify!($Ty), \";\")]\n-                ///\n                 /// # fn main() { test().unwrap(); }\n                 /// # fn test() -> Option<()> {\n                 #[doc = concat!(\"let pos = \", stringify!($Ty), \"::new(1)?;\")]\n@@ -905,7 +895,6 @@ macro_rules! nonzero_unsigned_signed_operations {\n                 ///\n                 /// ```\n                 #[doc = concat!(\"# use std::num::\", stringify!($Ty), \";\")]\n-                ///\n                 /// # fn main() { test().unwrap(); }\n                 /// # fn test() -> Option<()> {\n                 #[doc = concat!(\"let two = \", stringify!($Ty), \"::new(2)?;\")]\n@@ -941,7 +930,6 @@ macro_rules! nonzero_unsigned_signed_operations {\n                 ///\n                 /// ```\n                 #[doc = concat!(\"# use std::num::\", stringify!($Ty), \";\")]\n-                ///\n                 /// # fn main() { test().unwrap(); }\n                 /// # fn test() -> Option<()> {\n                 #[doc = concat!(\"let two = \", stringify!($Ty), \"::new(2)?;\")]\n@@ -986,8 +974,8 @@ macro_rules! nonzero_unsigned_signed_operations {\n                 ///\n                 /// ```\n                 /// #![feature(nonzero_ops)]\n-                #[doc = concat!(\"# use std::num::\", stringify!($Ty), \";\")]\n                 ///\n+                #[doc = concat!(\"# use std::num::\", stringify!($Ty), \";\")]\n                 /// # fn main() { test().unwrap(); }\n                 /// # fn test() -> Option<()> {\n                 #[doc = concat!(\"let two = \", stringify!($Ty), \"::new(2)?;\")]\n@@ -1014,7 +1002,6 @@ macro_rules! nonzero_unsigned_signed_operations {\n                 ///\n                 /// ```\n                 #[doc = concat!(\"# use std::num::\", stringify!($Ty), \";\")]\n-                ///\n                 /// # fn main() { test().unwrap(); }\n                 /// # fn test() -> Option<()> {\n                 #[doc = concat!(\"let three = \", stringify!($Ty), \"::new(3)?;\")]\n@@ -1058,7 +1045,6 @@ macro_rules! nonzero_unsigned_signed_operations {\n                 ///\n                 /// ```\n                 #[doc = concat!(\"# use std::num::\", stringify!($Ty), \";\")]\n-                ///\n                 /// # fn main() { test().unwrap(); }\n                 /// # fn test() -> Option<()> {\n                 #[doc = concat!(\"let three = \", stringify!($Ty), \"::new(3)?;\")]\n@@ -1162,8 +1148,8 @@ macro_rules! nonzero_min_max_unsigned {\n                 ///\n                 /// ```\n                 /// #![feature(nonzero_min_max)]\n-                #[doc = concat!(\"# use std::num::\", stringify!($Ty), \";\")]\n                 ///\n+                #[doc = concat!(\"# use std::num::\", stringify!($Ty), \";\")]\n                 #[doc = concat!(\"assert_eq!(\", stringify!($Ty), \"::MIN.get(), 1\", stringify!($Int), \");\")]\n                 /// ```\n                 #[unstable(feature = \"nonzero_min_max\", issue = \"89065\")]\n@@ -1177,8 +1163,8 @@ macro_rules! nonzero_min_max_unsigned {\n                 ///\n                 /// ```\n                 /// #![feature(nonzero_min_max)]\n-                #[doc = concat!(\"# use std::num::\", stringify!($Ty), \";\")]\n                 ///\n+                #[doc = concat!(\"# use std::num::\", stringify!($Ty), \";\")]\n                 #[doc = concat!(\"assert_eq!(\", stringify!($Ty), \"::MAX.get(), \", stringify!($Int), \"::MAX);\")]\n                 /// ```\n                 #[unstable(feature = \"nonzero_min_max\", issue = \"89065\")]\n@@ -1204,8 +1190,8 @@ macro_rules! nonzero_min_max_signed {\n                 ///\n                 /// ```\n                 /// #![feature(nonzero_min_max)]\n-                #[doc = concat!(\"# use std::num::\", stringify!($Ty), \";\")]\n                 ///\n+                #[doc = concat!(\"# use std::num::\", stringify!($Ty), \";\")]\n                 #[doc = concat!(\"assert_eq!(\", stringify!($Ty), \"::MIN.get(), \", stringify!($Int), \"::MIN);\")]\n                 /// ```\n                 #[unstable(feature = \"nonzero_min_max\", issue = \"89065\")]\n@@ -1223,8 +1209,8 @@ macro_rules! nonzero_min_max_signed {\n                 ///\n                 /// ```\n                 /// #![feature(nonzero_min_max)]\n-                #[doc = concat!(\"# use std::num::\", stringify!($Ty), \";\")]\n                 ///\n+                #[doc = concat!(\"# use std::num::\", stringify!($Ty), \";\")]\n                 #[doc = concat!(\"assert_eq!(\", stringify!($Ty), \"::MAX.get(), \", stringify!($Int), \"::MAX);\")]\n                 /// ```\n                 #[unstable(feature = \"nonzero_min_max\", issue = \"89065\")]"}, {"sha": "127b047db9192510521f49fe0279cabe79a918c8", "filename": "library/core/src/ops/function.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ca92d90b5917e7176d5ff06607a2cd5352c088d3/library%2Fcore%2Fsrc%2Fops%2Ffunction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca92d90b5917e7176d5ff06607a2cd5352c088d3/library%2Fcore%2Fsrc%2Fops%2Ffunction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fops%2Ffunction.rs?ref=ca92d90b5917e7176d5ff06607a2cd5352c088d3", "patch": "@@ -57,7 +57,6 @@ use crate::marker::Tuple;\n #[cfg(bootstrap)]\n #[lang = \"fn\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[rustc_diagnostic_item = \"Fn\"]\n #[rustc_paren_sugar]\n #[rustc_on_unimplemented(\n     on(\n@@ -138,7 +137,6 @@ pub trait Fn<Args>: FnMut<Args> {\n #[cfg(not(bootstrap))]\n #[lang = \"fn\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[rustc_diagnostic_item = \"Fn\"]\n #[rustc_paren_sugar]\n #[rustc_on_unimplemented(\n     on(\n@@ -227,7 +225,6 @@ pub trait Fn<Args: Tuple>: FnMut<Args> {\n #[cfg(bootstrap)]\n #[lang = \"fn_mut\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[rustc_diagnostic_item = \"FnMut\"]\n #[rustc_paren_sugar]\n #[rustc_on_unimplemented(\n     on(\n@@ -316,7 +313,6 @@ pub trait FnMut<Args>: FnOnce<Args> {\n #[cfg(not(bootstrap))]\n #[lang = \"fn_mut\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[rustc_diagnostic_item = \"FnMut\"]\n #[rustc_paren_sugar]\n #[rustc_on_unimplemented(\n     on(\n@@ -397,7 +393,6 @@ pub trait FnMut<Args: Tuple>: FnOnce<Args> {\n #[cfg(bootstrap)]\n #[lang = \"fn_once\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[rustc_diagnostic_item = \"FnOnce\"]\n #[rustc_paren_sugar]\n #[rustc_on_unimplemented(\n     on(\n@@ -483,7 +478,6 @@ pub trait FnOnce<Args> {\n #[cfg(not(bootstrap))]\n #[lang = \"fn_once\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[rustc_diagnostic_item = \"FnOnce\"]\n #[rustc_paren_sugar]\n #[rustc_on_unimplemented(\n     on("}, {"sha": "461b70c32f36e75016c15f505efb441147cb9cde", "filename": "library/core/src/panic.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ca92d90b5917e7176d5ff06607a2cd5352c088d3/library%2Fcore%2Fsrc%2Fpanic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca92d90b5917e7176d5ff06607a2cd5352c088d3/library%2Fcore%2Fsrc%2Fpanic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fpanic.rs?ref=ca92d90b5917e7176d5ff06607a2cd5352c088d3", "patch": "@@ -80,7 +80,6 @@ pub macro unreachable_2015 {\n #[doc(hidden)]\n #[unstable(feature = \"edition_panic\", issue = \"none\", reason = \"use unreachable!() instead\")]\n #[allow_internal_unstable(core_panic)]\n-#[rustc_diagnostic_item = \"unreachable_2021_macro\"]\n #[rustc_macro_transparency = \"semitransparent\"]\n pub macro unreachable_2021 {\n     () => ("}, {"sha": "c10bfde4ddf79c946d4b9623356cf2b639f5d3fd", "filename": "library/std/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ca92d90b5917e7176d5ff06607a2cd5352c088d3/library%2Fstd%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/ca92d90b5917e7176d5ff06607a2cd5352c088d3/library%2Fstd%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2FCargo.toml?ref=ca92d90b5917e7176d5ff06607a2cd5352c088d3", "patch": "@@ -16,7 +16,7 @@ panic_unwind = { path = \"../panic_unwind\", optional = true }\n panic_abort = { path = \"../panic_abort\" }\n core = { path = \"../core\" }\n libc = { version = \"0.2.135\", default-features = false, features = ['rustc-dep-of-std'] }\n-compiler_builtins = { version = \"0.1.73\" }\n+compiler_builtins = { version = \"0.1.82\" }\n profiler_builtins = { path = \"../profiler_builtins\", optional = true }\n unwind = { path = \"../unwind\" }\n hashbrown = { version = \"0.12\", default-features = false, features = ['rustc-dep-of-std'] }"}, {"sha": "5453853e1381abacf285cb10cc786a4e26af4cb6", "filename": "library/std/src/net/ip_addr.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ca92d90b5917e7176d5ff06607a2cd5352c088d3/library%2Fstd%2Fsrc%2Fnet%2Fip_addr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca92d90b5917e7176d5ff06607a2cd5352c088d3/library%2Fstd%2Fsrc%2Fnet%2Fip_addr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fnet%2Fip_addr.rs?ref=ca92d90b5917e7176d5ff06607a2cd5352c088d3", "patch": "@@ -73,7 +73,6 @@ pub enum IpAddr {\n /// assert!(\"0xcb.0x0.0x71.0x00\".parse::<Ipv4Addr>().is_err()); // all octets are in hex\n /// ```\n #[derive(Copy, Clone, PartialEq, Eq, Hash)]\n-#[cfg_attr(not(test), rustc_diagnostic_item = \"Ipv4Addr\")]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Ipv4Addr {\n     octets: [u8; 4],\n@@ -156,7 +155,6 @@ pub struct Ipv4Addr {\n /// assert_eq!(localhost.is_loopback(), true);\n /// ```\n #[derive(Copy, Clone, PartialEq, Eq, Hash)]\n-#[cfg_attr(not(test), rustc_diagnostic_item = \"Ipv6Addr\")]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Ipv6Addr {\n     octets: [u8; 16],"}, {"sha": "a2708d16947f0c92ed302106fba70382792eee2f", "filename": "src/ci/docker/scripts/fuchsia-test-runner.py", "status": "added", "additions": 1041, "deletions": 0, "changes": 1041, "blob_url": "https://github.com/rust-lang/rust/blob/ca92d90b5917e7176d5ff06607a2cd5352c088d3/src%2Fci%2Fdocker%2Fscripts%2Ffuchsia-test-runner.py", "raw_url": "https://github.com/rust-lang/rust/raw/ca92d90b5917e7176d5ff06607a2cd5352c088d3/src%2Fci%2Fdocker%2Fscripts%2Ffuchsia-test-runner.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fscripts%2Ffuchsia-test-runner.py?ref=ca92d90b5917e7176d5ff06607a2cd5352c088d3", "patch": "@@ -0,0 +1,1041 @@\n+#!/usr/bin/env python3\n+\n+\"\"\"\n+The Rust toolchain test runner for Fuchsia.\n+\n+For instructions on running the compiler test suite, see\n+https://doc.rust-lang.org/stable/rustc/platform-support/fuchsia.html#aarch64-fuchsia-and-x86_64-fuchsia\n+\"\"\"\n+\n+import argparse\n+from dataclasses import dataclass\n+import glob\n+import hashlib\n+import json\n+import os\n+import platform\n+import re\n+import shutil\n+import signal\n+import subprocess\n+import sys\n+from typing import ClassVar, List\n+\n+\n+@dataclass\n+class TestEnvironment:\n+    rust_dir: str\n+    sdk_dir: str\n+    target_arch: str\n+    package_server_pid: int = None\n+    emu_addr: str = None\n+    libstd_name: str = None\n+    libtest_name: str = None\n+    verbose: bool = False\n+\n+    @staticmethod\n+    def tmp_dir():\n+        tmp_dir = os.environ.get(\"TEST_TOOLCHAIN_TMP_DIR\")\n+        if tmp_dir is not None:\n+            return os.path.abspath(tmp_dir)\n+        return os.path.join(os.path.dirname(__file__), \"tmp~\")\n+\n+    @classmethod\n+    def env_file_path(cls):\n+        return os.path.join(cls.tmp_dir(), \"test_env.json\")\n+\n+    @classmethod\n+    def from_args(cls, args):\n+        return cls(\n+            os.path.abspath(args.rust),\n+            os.path.abspath(args.sdk),\n+            args.target_arch,\n+            verbose=args.verbose,\n+        )\n+\n+    @classmethod\n+    def read_from_file(cls):\n+        with open(cls.env_file_path(), encoding=\"utf-8\") as f:\n+            test_env = json.loads(f.read())\n+            return cls(\n+                test_env[\"rust_dir\"],\n+                test_env[\"sdk_dir\"],\n+                test_env[\"target_arch\"],\n+                libstd_name=test_env[\"libstd_name\"],\n+                libtest_name=test_env[\"libtest_name\"],\n+                emu_addr=test_env[\"emu_addr\"],\n+                package_server_pid=test_env[\"package_server_pid\"],\n+                verbose=test_env[\"verbose\"],\n+            )\n+\n+    def image_name(self):\n+        if self.target_arch == \"x64\":\n+            return \"qemu-x64\"\n+        if self.target_arch == \"arm64\":\n+            return \"qemu-arm64\"\n+        raise Exception(f\"Unrecognized target architecture {self.target_arch}\")\n+\n+    def write_to_file(self):\n+        with open(self.env_file_path(), \"w\", encoding=\"utf-8\") as f:\n+            f.write(json.dumps(self.__dict__))\n+\n+    def ssh_dir(self):\n+        return os.path.join(self.tmp_dir(), \"ssh\")\n+\n+    def ssh_keyfile_path(self):\n+        return os.path.join(self.ssh_dir(), \"fuchsia_ed25519\")\n+\n+    def ssh_authfile_path(self):\n+        return os.path.join(self.ssh_dir(), \"fuchsia_authorized_keys\")\n+\n+    def vdl_output_path(self):\n+        return os.path.join(self.tmp_dir(), \"vdl_output\")\n+\n+    def package_server_log_path(self):\n+        return os.path.join(self.tmp_dir(), \"package_server_log\")\n+\n+    def emulator_log_path(self):\n+        return os.path.join(self.tmp_dir(), \"emulator_log\")\n+\n+    def packages_dir(self):\n+        return os.path.join(self.tmp_dir(), \"packages\")\n+\n+    def output_dir(self):\n+        return os.path.join(self.tmp_dir(), \"output\")\n+\n+    TEST_REPO_NAME: ClassVar[str] = \"rust-testing\"\n+\n+    def repo_dir(self):\n+        return os.path.join(self.tmp_dir(), self.TEST_REPO_NAME)\n+\n+    def rustlib_dir(self):\n+        if self.target_arch == \"x64\":\n+            return \"x86_64-fuchsia\"\n+        if self.target_arch == \"arm64\":\n+            return \"aarch64-fuchsia\"\n+        raise Exception(f\"Unrecognized target architecture {self.target_arch}\")\n+\n+    def libs_dir(self):\n+        return os.path.join(\n+            self.rust_dir,\n+            \"lib\",\n+        )\n+\n+    def rustlibs_dir(self):\n+        return os.path.join(\n+            self.libs_dir(),\n+            \"rustlib\",\n+            self.rustlib_dir(),\n+            \"lib\",\n+        )\n+\n+    def sdk_arch(self):\n+        machine = platform.machine()\n+        if machine == \"x86_64\":\n+            return \"x64\"\n+        if machine == \"arm\":\n+            return \"a64\"\n+        raise Exception(f\"Unrecognized host architecture {machine}\")\n+\n+    def tool_path(self, tool):\n+        return os.path.join(self.sdk_dir, \"tools\", self.sdk_arch(), tool)\n+\n+    def host_arch_triple(self):\n+        machine = platform.machine()\n+        if machine == \"x86_64\":\n+            return \"x86_64-unknown-linux-gnu\"\n+        if machine == \"arm\":\n+            return \"aarch64-unknown-linux-gnu\"\n+        raise Exception(f\"Unrecognized host architecture {machine}\")\n+\n+    def zxdb_script_path(self):\n+        return os.path.join(self.tmp_dir(), \"zxdb_script\")\n+\n+    def log_info(self, msg):\n+        print(msg)\n+\n+    def log_debug(self, msg):\n+        if self.verbose:\n+            print(msg)\n+\n+    def subprocess_output(self):\n+        if self.verbose:\n+            return sys.stdout\n+        return subprocess.DEVNULL\n+\n+    def ffx_daemon_log_path(self):\n+        return os.path.join(self.tmp_dir(), \"ffx_daemon_log\")\n+\n+    def ffx_isolate_dir(self):\n+        return os.path.join(self.tmp_dir(), \"ffx_isolate\")\n+\n+    def ffx_home_dir(self):\n+        return os.path.join(self.ffx_isolate_dir(), \"user-home\")\n+\n+    def ffx_tmp_dir(self):\n+        return os.path.join(self.ffx_isolate_dir(), \"tmp\")\n+\n+    def ffx_log_dir(self):\n+        return os.path.join(self.ffx_isolate_dir(), \"log\")\n+\n+    def ffx_user_config_dir(self):\n+        return os.path.join(self.ffx_xdg_config_home(), \"Fuchsia\", \"ffx\", \"config\")\n+\n+    def ffx_user_config_path(self):\n+        return os.path.join(self.ffx_user_config_dir(), \"config.json\")\n+\n+    def ffx_xdg_config_home(self):\n+        if platform.system() == \"Darwin\":\n+            return os.path.join(self.ffx_home_dir(), \"Library\", \"Preferences\")\n+        return os.path.join(self.ffx_home_dir(), \".local\", \"share\")\n+\n+    def ffx_ascendd_path(self):\n+        return os.path.join(self.ffx_tmp_dir(), \"ascendd\")\n+\n+    def start_ffx_isolation(self):\n+        # Most of this is translated directly from ffx's isolate library\n+        os.mkdir(self.ffx_isolate_dir())\n+        os.mkdir(self.ffx_home_dir())\n+        os.mkdir(self.ffx_tmp_dir())\n+        os.mkdir(self.ffx_log_dir())\n+\n+        fuchsia_dir = os.path.join(self.ffx_home_dir(), \".fuchsia\")\n+        os.mkdir(fuchsia_dir)\n+\n+        fuchsia_debug_dir = os.path.join(fuchsia_dir, \"debug\")\n+        os.mkdir(fuchsia_debug_dir)\n+\n+        metrics_dir = os.path.join(fuchsia_dir, \"metrics\")\n+        os.mkdir(metrics_dir)\n+\n+        analytics_path = os.path.join(metrics_dir, \"analytics-status\")\n+        with open(analytics_path, \"w\", encoding=\"utf-8\") as analytics_file:\n+            print(\"0\", file=analytics_file)\n+\n+        ffx_path = os.path.join(metrics_dir, \"ffx\")\n+        with open(ffx_path, \"w\", encoding=\"utf-8\") as ffx_file:\n+            print(\"1\", file=ffx_file)\n+\n+        os.makedirs(self.ffx_user_config_dir())\n+\n+        with open(\n+            self.ffx_user_config_path(), \"w\", encoding=\"utf-8\"\n+        ) as config_json_file:\n+            user_config_for_test = {\n+                \"log\": {\n+                    \"enabled\": True,\n+                    \"dir\": self.ffx_log_dir(),\n+                },\n+                \"overnet\": {\n+                    \"socket\": self.ffx_ascendd_path(),\n+                },\n+                \"ssh\": {\n+                    \"pub\": self.ssh_authfile_path(),\n+                    \"priv\": self.ssh_keyfile_path(),\n+                },\n+                \"test\": {\n+                    \"is_isolated\": True,\n+                    \"experimental_structured_output\": True,\n+                },\n+            }\n+            print(json.dumps(user_config_for_test), file=config_json_file)\n+\n+        ffx_env_path = os.path.join(self.ffx_user_config_dir(), \".ffx_env\")\n+        with open(ffx_env_path, \"w\", encoding=\"utf-8\") as ffx_env_file:\n+            ffx_env_config_for_test = {\n+                \"user\": self.ffx_user_config_path(),\n+                \"build\": None,\n+                \"global\": None,\n+            }\n+            print(json.dumps(ffx_env_config_for_test), file=ffx_env_file)\n+\n+        # Start ffx daemon\n+        # We want this to be a long-running process that persists after the script finishes\n+        # pylint: disable=consider-using-with\n+        with open(\n+            self.ffx_daemon_log_path(), \"w\", encoding=\"utf-8\"\n+        ) as ffx_daemon_log_file:\n+            subprocess.Popen(\n+                [\n+                    self.tool_path(\"ffx\"),\n+                    \"--config\",\n+                    self.ffx_user_config_path(),\n+                    \"daemon\",\n+                    \"start\",\n+                ],\n+                env=self.ffx_cmd_env(),\n+                stdout=ffx_daemon_log_file,\n+                stderr=ffx_daemon_log_file,\n+            )\n+\n+    def ffx_cmd_env(self):\n+        result = {\n+            \"HOME\": self.ffx_home_dir(),\n+            \"XDG_CONFIG_HOME\": self.ffx_xdg_config_home(),\n+            \"ASCENDD\": self.ffx_ascendd_path(),\n+            \"FUCHSIA_SSH_KEY\": self.ssh_keyfile_path(),\n+            # We want to use our own specified temp directory\n+            \"TMP\": self.tmp_dir(),\n+            \"TEMP\": self.tmp_dir(),\n+            \"TMPDIR\": self.tmp_dir(),\n+            \"TEMPDIR\": self.tmp_dir(),\n+        }\n+\n+        return result\n+\n+    def stop_ffx_isolation(self):\n+        subprocess.check_call(\n+            [\n+                self.tool_path(\"ffx\"),\n+                \"--config\",\n+                self.ffx_user_config_path(),\n+                \"daemon\",\n+                \"stop\",\n+            ],\n+            env=self.ffx_cmd_env(),\n+            stdout=self.subprocess_output(),\n+            stderr=self.subprocess_output(),\n+        )\n+\n+    def start(self):\n+        \"\"\"Sets up the testing environment and prepares to run tests.\n+\n+        Args:\n+            args: The command-line arguments to this command.\n+\n+        During setup, this function will:\n+        - Locate necessary shared libraries\n+        - Create a new temp directory (this is where all temporary files are stored)\n+        - Start an emulator\n+        - Start an update server\n+        - Create a new package repo and register it with the emulator\n+        - Write test environment settings to a temporary file\n+        \"\"\"\n+\n+        # Initialize temp directory\n+        if not os.path.exists(self.tmp_dir()):\n+            os.mkdir(self.tmp_dir())\n+        elif len(os.listdir(self.tmp_dir())) != 0:\n+            raise Exception(f\"Temp directory is not clean (in {self.tmp_dir()})\")\n+\n+        os.mkdir(self.ssh_dir())\n+        os.mkdir(self.output_dir())\n+\n+        # Find libstd and libtest\n+        libstd_paths = glob.glob(os.path.join(self.rustlibs_dir(), \"libstd-*.so\"))\n+        libtest_paths = glob.glob(os.path.join(self.rustlibs_dir(), \"libtest-*.so\"))\n+\n+        if not libstd_paths:\n+            raise Exception(f\"Failed to locate libstd (in {self.rustlibs_dir()})\")\n+\n+        if not libtest_paths:\n+            raise Exception(f\"Failed to locate libtest (in {self.rustlibs_dir()})\")\n+\n+        self.libstd_name = os.path.basename(libstd_paths[0])\n+        self.libtest_name = os.path.basename(libtest_paths[0])\n+\n+        # Generate SSH keys for the emulator to use\n+        self.log_info(\"Generating SSH keys...\")\n+        subprocess.check_call(\n+            [\n+                \"ssh-keygen\",\n+                \"-N\",\n+                \"\",\n+                \"-t\",\n+                \"ed25519\",\n+                \"-f\",\n+                self.ssh_keyfile_path(),\n+                \"-C\",\n+                \"Generated by test_toolchain.py\",\n+            ],\n+            stdout=self.subprocess_output(),\n+            stderr=self.subprocess_output(),\n+        )\n+        authfile_contents = subprocess.check_output(\n+            [\n+                \"ssh-keygen\",\n+                \"-y\",\n+                \"-f\",\n+                self.ssh_keyfile_path(),\n+            ],\n+            stderr=self.subprocess_output(),\n+        )\n+        with open(self.ssh_authfile_path(), \"wb\") as authfile:\n+            authfile.write(authfile_contents)\n+\n+        # Start ffx isolation\n+        self.log_info(\"Starting ffx isolation...\")\n+        self.start_ffx_isolation()\n+\n+        # Start emulator (this will generate the vdl output)\n+        self.log_info(\"Starting emulator...\")\n+        subprocess.check_call(\n+            [\n+                self.tool_path(\"fvdl\"),\n+                \"--sdk\",\n+                \"start\",\n+                \"--tuntap\",\n+                \"--headless\",\n+                \"--nointeractive\",\n+                \"--ssh\",\n+                self.ssh_dir(),\n+                \"--vdl-output\",\n+                self.vdl_output_path(),\n+                \"--emulator-log\",\n+                self.emulator_log_path(),\n+                \"--image-name\",\n+                self.image_name(),\n+            ],\n+            stdout=self.subprocess_output(),\n+            stderr=self.subprocess_output(),\n+        )\n+\n+        # Parse vdl output for relevant information\n+        with open(self.vdl_output_path(), encoding=\"utf-8\") as f:\n+            vdl_content = f.read()\n+            matches = re.search(\n+                r'network_address:\\s+\"\\[([0-9a-f]{1,4}:(:[0-9a-f]{1,4}){4}%qemu)\\]\"',\n+                vdl_content,\n+            )\n+            self.emu_addr = matches.group(1)\n+\n+        # Create new package repo\n+        self.log_info(\"Creating package repo...\")\n+        subprocess.check_call(\n+            [\n+                self.tool_path(\"pm\"),\n+                \"newrepo\",\n+                \"-repo\",\n+                self.repo_dir(),\n+            ],\n+            stdout=self.subprocess_output(),\n+            stderr=self.subprocess_output(),\n+        )\n+\n+        # Start package server\n+        self.log_info(\"Starting package server...\")\n+        with open(\n+            self.package_server_log_path(), \"w\", encoding=\"utf-8\"\n+        ) as package_server_log:\n+            # We want this to be a long-running process that persists after the script finishes\n+            # pylint: disable=consider-using-with\n+            self.package_server_pid = subprocess.Popen(\n+                [\n+                    self.tool_path(\"pm\"),\n+                    \"serve\",\n+                    \"-vt\",\n+                    \"-repo\",\n+                    self.repo_dir(),\n+                    \"-l\",\n+                    \":8084\",\n+                ],\n+                stdout=package_server_log,\n+                stderr=package_server_log,\n+            ).pid\n+\n+        # Register package server with emulator\n+        self.log_info(\"Registering package server...\")\n+        ssh_client = subprocess.check_output(\n+            [\n+                \"ssh\",\n+                \"-i\",\n+                self.ssh_keyfile_path(),\n+                \"-o\",\n+                \"StrictHostKeyChecking=accept-new\",\n+                self.emu_addr,\n+                \"-f\",\n+                \"echo $SSH_CLIENT\",\n+            ],\n+            text=True,\n+        )\n+        repo_addr = ssh_client.split()[0].replace(\"%\", \"%25\")\n+        repo_url = f\"http://[{repo_addr}]:8084/config.json\"\n+        subprocess.check_call(\n+            [\n+                \"ssh\",\n+                \"-i\",\n+                self.ssh_keyfile_path(),\n+                \"-o\",\n+                \"StrictHostKeyChecking=accept-new\",\n+                self.emu_addr,\n+                \"-f\",\n+                f\"pkgctl repo add url -f 1 -n {self.TEST_REPO_NAME} {repo_url}\",\n+            ],\n+            stdout=self.subprocess_output(),\n+            stderr=self.subprocess_output(),\n+        )\n+\n+        # Write to file\n+        self.write_to_file()\n+\n+        self.log_info(\"Success! Your environment is ready to run tests.\")\n+\n+    # FIXME: shardify this\n+    # `facet` statement required for TCP testing via\n+    # protocol `fuchsia.posix.socket.Provider`. See\n+    # https://fuchsia.dev/fuchsia-src/development/testing/components/test_runner_framework?hl=en#legacy_non-hermetic_tests\n+    CML_TEMPLATE: ClassVar[\n+        str\n+    ] = \"\"\"\n+    {{\n+        program: {{\n+            runner: \"elf_test_runner\",\n+            binary: \"bin/{exe_name}\",\n+            forward_stderr_to: \"log\",\n+            forward_stdout_to: \"log\",\n+            environ: [{env_vars}\n+            ]\n+        }},\n+        capabilities: [\n+            {{ protocol: \"fuchsia.test.Suite\" }},\n+        ],\n+        expose: [\n+            {{\n+                protocol: \"fuchsia.test.Suite\",\n+                from: \"self\",\n+            }},\n+        ],\n+        use: [\n+            {{ storage: \"data\", path: \"/data\" }},\n+            {{ protocol: [ \"fuchsia.process.Launcher\" ] }},\n+            {{ protocol: [ \"fuchsia.posix.socket.Provider\" ] }}\n+        ],\n+        facets: {{\n+            \"fuchsia.test\": {{ type: \"system\" }},\n+        }},\n+    }}\n+    \"\"\"\n+\n+    MANIFEST_TEMPLATE = \"\"\"\n+    meta/package={package_dir}/meta/package\n+    meta/{package_name}.cm={package_dir}/meta/{package_name}.cm\n+    bin/{exe_name}={bin_path}\n+    lib/{libstd_name}={rust_dir}/lib/rustlib/{rustlib_dir}/lib/{libstd_name}\n+    lib/{libtest_name}={rust_dir}/lib/rustlib/{rustlib_dir}/lib/{libtest_name}\n+    lib/ld.so.1={sdk_dir}/arch/{target_arch}/sysroot/lib/libc.so\n+    lib/libzircon.so={sdk_dir}/arch/{target_arch}/sysroot/lib/libzircon.so\n+    lib/libfdio.so={sdk_dir}/arch/{target_arch}/lib/libfdio.so\n+    \"\"\"\n+\n+    TEST_ENV_VARS: ClassVar[List[str]] = [\n+        \"TEST_EXEC_ENV\",\n+        \"RUST_MIN_STACK\",\n+        \"RUST_BACKTRACE\",\n+        \"RUST_NEWRT\",\n+        \"RUST_LOG\",\n+        \"RUST_TEST_THREADS\",\n+    ]\n+\n+    def run(self, args):\n+        \"\"\"Runs the requested test in the testing environment.\n+\n+        Args:\n+        args: The command-line arguments to this command.\n+        Returns:\n+        The return code of the test (0 for success, else failure).\n+\n+        To run a test, this function will:\n+        - Create, compile, archive, and publish a test package\n+        - Run the test package on the emulator\n+        - Forward the test's stdout and stderr as this script's stdout and stderr\n+        \"\"\"\n+\n+        bin_path = os.path.abspath(args.bin_path)\n+\n+        # Build a unique, deterministic name for the test using the name of the\n+        # binary and the last 6 hex digits of the hash of the full path\n+        def path_checksum(path):\n+            m = hashlib.sha256()\n+            m.update(path.encode(\"utf-8\"))\n+            return m.hexdigest()[0:6]\n+\n+        base_name = os.path.basename(os.path.dirname(args.bin_path))\n+        exe_name = base_name.lower().replace(\".\", \"_\")\n+        package_name = f\"{exe_name}_{path_checksum(bin_path)}\"\n+\n+        package_dir = os.path.join(self.packages_dir(), package_name)\n+        cml_path = os.path.join(package_dir, \"meta\", f\"{package_name}.cml\")\n+        cm_path = os.path.join(package_dir, \"meta\", f\"{package_name}.cm\")\n+        manifest_path = os.path.join(package_dir, f\"{package_name}.manifest\")\n+        far_path = os.path.join(package_dir, f\"{package_name}-0.far\")\n+\n+        shared_libs = args.shared_libs[: args.n]\n+        arguments = args.shared_libs[args.n :]\n+\n+        test_output_dir = os.path.join(self.output_dir(), package_name)\n+\n+        # Clean and create temporary output directory\n+        if os.path.exists(test_output_dir):\n+            shutil.rmtree(test_output_dir)\n+\n+        os.mkdir(test_output_dir)\n+\n+        # Open log file\n+        log_path = os.path.join(test_output_dir, \"log\")\n+        with open(log_path, \"w\", encoding=\"utf-8\") as log_file:\n+\n+            def log(msg):\n+                print(msg, file=log_file)\n+                log_file.flush()\n+\n+            log(f\"Bin path: {bin_path}\")\n+\n+            log(\"Setting up package...\")\n+\n+            # Set up package\n+            subprocess.check_call(\n+                [\n+                    self.tool_path(\"pm\"),\n+                    \"-o\",\n+                    package_dir,\n+                    \"-n\",\n+                    package_name,\n+                    \"init\",\n+                ],\n+                stdout=log_file,\n+                stderr=log_file,\n+            )\n+\n+            log(\"Writing CML...\")\n+\n+            # Write and compile CML\n+            with open(cml_path, \"w\", encoding=\"utf-8\") as cml:\n+                # Collect environment variables\n+                env_vars = \"\"\n+                for var_name in self.TEST_ENV_VARS:\n+                    var_value = os.getenv(var_name)\n+                    if var_value is not None:\n+                        env_vars += f'\\n            \"{var_name}={var_value}\",'\n+\n+                # Default to no backtrace for test suite\n+                if os.getenv(\"RUST_BACKTRACE\") == None:\n+                    env_vars += f'\\n            \"RUST_BACKTRACE=0\",'\n+\n+                cml.write(\n+                    self.CML_TEMPLATE.format(env_vars=env_vars, exe_name=exe_name)\n+                )\n+\n+            log(\"Compiling CML...\")\n+\n+            subprocess.check_call(\n+                [\n+                    self.tool_path(\"cmc\"),\n+                    \"compile\",\n+                    cml_path,\n+                    \"--includepath\",\n+                    \".\",\n+                    \"--output\",\n+                    cm_path,\n+                ],\n+                stdout=log_file,\n+                stderr=log_file,\n+            )\n+\n+            log(\"Writing manifest...\")\n+\n+            # Write, build, and archive manifest\n+            with open(manifest_path, \"w\", encoding=\"utf-8\") as manifest:\n+                manifest.write(\n+                    self.MANIFEST_TEMPLATE.format(\n+                        bin_path=bin_path,\n+                        exe_name=exe_name,\n+                        package_dir=package_dir,\n+                        package_name=package_name,\n+                        rust_dir=self.rust_dir,\n+                        rustlib_dir=self.rustlib_dir(),\n+                        sdk_dir=self.sdk_dir,\n+                        libstd_name=self.libstd_name,\n+                        libtest_name=self.libtest_name,\n+                        target_arch=self.target_arch,\n+                    )\n+                )\n+                for shared_lib in shared_libs:\n+                    manifest.write(f\"lib/{os.path.basename(shared_lib)}={shared_lib}\\n\")\n+\n+            log(\"Compiling and archiving manifest...\")\n+\n+            subprocess.check_call(\n+                [\n+                    self.tool_path(\"pm\"),\n+                    \"-o\",\n+                    package_dir,\n+                    \"-m\",\n+                    manifest_path,\n+                    \"build\",\n+                ],\n+                stdout=log_file,\n+                stderr=log_file,\n+            )\n+            subprocess.check_call(\n+                [\n+                    self.tool_path(\"pm\"),\n+                    \"-o\",\n+                    package_dir,\n+                    \"-m\",\n+                    manifest_path,\n+                    \"archive\",\n+                ],\n+                stdout=log_file,\n+                stderr=log_file,\n+            )\n+\n+            log(\"Publishing package to repo...\")\n+\n+            # Publish package to repo\n+            subprocess.check_call(\n+                [\n+                    self.tool_path(\"pm\"),\n+                    \"publish\",\n+                    \"-a\",\n+                    \"-repo\",\n+                    self.repo_dir(),\n+                    \"-f\",\n+                    far_path,\n+                ],\n+                stdout=log_file,\n+                stderr=log_file,\n+            )\n+\n+            log(\"Running ffx test...\")\n+\n+            # Run test on emulator\n+            subprocess.run(\n+                [\n+                    self.tool_path(\"ffx\"),\n+                    \"--config\",\n+                    self.ffx_user_config_path(),\n+                    \"test\",\n+                    \"run\",\n+                    f\"fuchsia-pkg://{self.TEST_REPO_NAME}/{package_name}#meta/{package_name}.cm\",\n+                    \"--min-severity-logs\",\n+                    \"TRACE\",\n+                    \"--output-directory\",\n+                    test_output_dir,\n+                    \"--\",\n+                ]\n+                + arguments,\n+                env=self.ffx_cmd_env(),\n+                check=False,\n+                stdout=log_file,\n+                stderr=log_file,\n+            )\n+\n+            log(\"Reporting test suite output...\")\n+\n+            # Read test suite output\n+            run_summary_path = os.path.join(test_output_dir, \"run_summary.json\")\n+            if os.path.exists(run_summary_path):\n+                with open(run_summary_path, encoding=\"utf-8\") as f:\n+                    run_summary = json.loads(f.read())\n+\n+                suite = run_summary[\"data\"][\"suites\"][0]\n+                case = suite[\"cases\"][0]\n+\n+                return_code = 0 if case[\"outcome\"] == \"PASSED\" else 1\n+\n+                artifacts = case[\"artifacts\"]\n+                artifact_dir = case[\"artifact_dir\"]\n+                stdout_path = None\n+                stderr_path = None\n+\n+                for path, artifact in artifacts.items():\n+                    artifact_path = os.path.join(test_output_dir, artifact_dir, path)\n+                    artifact_type = artifact[\"artifact_type\"]\n+\n+                    if artifact_type == \"STDERR\":\n+                        stderr_path = artifact_path\n+                    elif artifact_type == \"STDOUT\":\n+                        stdout_path = artifact_path\n+\n+                if stdout_path is not None and os.path.exists(stdout_path):\n+                    with open(stdout_path, encoding=\"utf-8\") as f:\n+                        print(f.read(), file=sys.stdout, end=\"\")\n+\n+                if stderr_path is not None and os.path.exists(stderr_path):\n+                    with open(stderr_path, encoding=\"utf-8\") as f:\n+                        print(f.read(), file=sys.stderr, end=\"\")\n+            else:\n+                log(\"Failed to open test run summary\")\n+                return_code = 254\n+\n+            log(\"Done!\")\n+\n+        return return_code\n+\n+    def stop(self):\n+        \"\"\"Shuts down and cleans up the testing environment.\n+\n+        Args:\n+        args: The command-line arguments to this command.\n+        Returns:\n+        The return code of the test (0 for success, else failure).\n+\n+        During cleanup, this function will stop the emulator, package server, and\n+        update server, then delete all temporary files. If an error is encountered\n+        while stopping any running processes, the temporary files will not be deleted.\n+        Passing --delete-tmp will force the process to delete the files anyway.\n+        \"\"\"\n+\n+        self.log_debug(\"Reporting logs...\")\n+\n+        # Print test log files\n+        for test_dir in os.listdir(self.output_dir()):\n+            log_path = os.path.join(self.output_dir(), test_dir, \"log\")\n+            self.log_debug(f\"\\n---- Logs for test '{test_dir}' ----\\n\")\n+            if os.path.exists(log_path):\n+                with open(log_path, encoding=\"utf-8\") as log:\n+                    self.log_debug(log.read())\n+            else:\n+                self.log_debug(\"No logs found\")\n+\n+        # Print the emulator log\n+        self.log_debug(\"\\n---- Emulator logs ----\\n\")\n+        if os.path.exists(self.emulator_log_path()):\n+            with open(self.emulator_log_path(), encoding=\"utf-8\") as log:\n+                self.log_debug(log.read())\n+        else:\n+            self.log_debug(\"No emulator logs found\")\n+\n+        # Print the package server log\n+        self.log_debug(\"\\n---- Package server log ----\\n\")\n+        if os.path.exists(self.package_server_log_path()):\n+            with open(self.package_server_log_path(), encoding=\"utf-8\") as log:\n+                self.log_debug(log.read())\n+        else:\n+            self.log_debug(\"No package server log found\")\n+\n+        # Print the ffx daemon log\n+        self.log_debug(\"\\n---- ffx daemon log ----\\n\")\n+        if os.path.exists(self.ffx_daemon_log_path()):\n+            with open(self.ffx_daemon_log_path(), encoding=\"utf-8\") as log:\n+                self.log_debug(log.read())\n+        else:\n+            self.log_debug(\"No ffx daemon log found\")\n+\n+        # Stop package server\n+        self.log_info(\"Stopping package server...\")\n+        os.kill(self.package_server_pid, signal.SIGTERM)\n+\n+        # Shut down the emulator\n+        self.log_info(\"Stopping emulator...\")\n+        subprocess.check_call(\n+            [\n+                self.tool_path(\"fvdl\"),\n+                \"--sdk\",\n+                \"kill\",\n+                \"--launched-proto\",\n+                self.vdl_output_path(),\n+            ],\n+            stdout=self.subprocess_output(),\n+            stderr=self.subprocess_output(),\n+        )\n+\n+        # Stop ffx isolation\n+        self.log_info(\"Stopping ffx isolation...\")\n+        self.stop_ffx_isolation()\n+\n+    def delete_tmp(self):\n+        # Remove temporary files\n+        self.log_info(\"Deleting temporary files...\")\n+        shutil.rmtree(self.tmp_dir(), ignore_errors=True)\n+\n+    def debug(self, args):\n+        command = [\n+            self.tool_path(\"ffx\"),\n+            \"--config\",\n+            self.ffx_user_config_path(),\n+            \"debug\",\n+            \"connect\",\n+            \"--\",\n+            \"--build-id-dir\",\n+            os.path.join(self.sdk_dir, \".build-id\"),\n+            \"--build-id-dir\",\n+            os.path.join(self.libs_dir(), \".build-id\"),\n+        ]\n+\n+        # Add rust source if it's available\n+        if args.rust_src is not None:\n+            command += [\n+                \"--build-dir\",\n+                args.rust_src,\n+            ]\n+\n+        # Add fuchsia source if it's available\n+        if args.fuchsia_src is not None:\n+            command += [\n+                \"--build-dir\",\n+                os.path.join(args.fuchsia_src, \"out\", \"default\"),\n+            ]\n+\n+        # Load debug symbols for the test binary and automatically attach\n+        if args.test is not None:\n+            if args.rust_src is None:\n+                raise Exception(\n+                    \"A Rust source path is required with the `test` argument\"\n+                )\n+\n+            test_name = os.path.splitext(os.path.basename(args.test))[0]\n+\n+            build_dir = os.path.join(\n+                args.rust_src,\n+                \"fuchsia-build\",\n+                self.host_arch_triple(),\n+            )\n+            test_dir = os.path.join(\n+                build_dir,\n+                \"test\",\n+                os.path.dirname(args.test),\n+                test_name,\n+            )\n+\n+            with open(self.zxdb_script_path(), mode=\"w\", encoding=\"utf-8\") as f:\n+                print(f\"attach {test_name[:31]}\", file=f)\n+\n+            command += [\n+                \"--symbol-path\",\n+                test_dir,\n+                \"-S\",\n+                self.zxdb_script_path(),\n+            ]\n+\n+        # Add any other zxdb arguments the user passed\n+        if args.zxdb_args is not None:\n+            command += args.zxdb_args\n+\n+        # Connect to the running emulator with zxdb\n+        subprocess.run(command, env=self.ffx_cmd_env(), check=False)\n+\n+\n+def start(args):\n+    test_env = TestEnvironment.from_args(args)\n+    test_env.start()\n+    return 0\n+\n+\n+def run(args):\n+    test_env = TestEnvironment.read_from_file()\n+    return test_env.run(args)\n+\n+\n+def stop(args):\n+    test_env = TestEnvironment.read_from_file()\n+    test_env.stop()\n+    if not args.no_delete:\n+        test_env.delete_tmp()\n+    return 0\n+\n+\n+def delete_tmp(args):\n+    del args\n+    test_env = TestEnvironment.read_from_file()\n+    test_env.delete_tmp()\n+    return 0\n+\n+\n+def debug(args):\n+    test_env = TestEnvironment.read_from_file()\n+    test_env.debug(args)\n+    return 0\n+\n+\n+def main():\n+    parser = argparse.ArgumentParser()\n+\n+    def print_help(args):\n+        del args\n+        parser.print_help()\n+        return 0\n+\n+    parser.set_defaults(func=print_help)\n+\n+    subparsers = parser.add_subparsers(help=\"valid sub-commands\")\n+\n+    start_parser = subparsers.add_parser(\n+        \"start\", help=\"initializes the testing environment\"\n+    )\n+    start_parser.add_argument(\n+        \"--rust\",\n+        help=\"the directory of the installed Rust compiler for Fuchsia\",\n+        required=True,\n+    )\n+    start_parser.add_argument(\n+        \"--sdk\",\n+        help=\"the directory of the fuchsia SDK\",\n+        required=True,\n+    )\n+    start_parser.add_argument(\n+        \"--verbose\",\n+        help=\"prints more output from executed processes\",\n+        action=\"store_true\",\n+    )\n+    start_parser.add_argument(\n+        \"--target-arch\",\n+        help=\"the architecture of the image to test\",\n+        required=True,\n+    )\n+    start_parser.set_defaults(func=start)\n+\n+    run_parser = subparsers.add_parser(\n+        \"run\", help=\"run a test in the testing environment\"\n+    )\n+    run_parser.add_argument(\n+        \"n\", help=\"the number of shared libs passed along with the executable\", type=int\n+    )\n+    run_parser.add_argument(\"bin_path\", help=\"path to the binary to run\")\n+    run_parser.add_argument(\n+        \"shared_libs\",\n+        help=\"the shared libs passed along with the binary\",\n+        nargs=argparse.REMAINDER,\n+    )\n+    run_parser.set_defaults(func=run)\n+\n+    stop_parser = subparsers.add_parser(\n+        \"stop\", help=\"shuts down and cleans up the testing environment\"\n+    )\n+    stop_parser.add_argument(\n+        \"--no-delete\",\n+        default=False,\n+        action=\"store_true\",\n+        help=\"don't delete temporary files after stopping\",\n+    )\n+    stop_parser.set_defaults(func=stop)\n+\n+    delete_parser = subparsers.add_parser(\n+        \"delete-tmp\",\n+        help=\"deletes temporary files after the testing environment has been manually cleaned up\",\n+    )\n+    delete_parser.set_defaults(func=delete_tmp)\n+\n+    debug_parser = subparsers.add_parser(\n+        \"debug\",\n+        help=\"connect to the active testing environment with zxdb\",\n+    )\n+    debug_parser.add_argument(\n+        \"--rust-src\",\n+        default=None,\n+        help=\"the path to the Rust source being tested\",\n+    )\n+    debug_parser.add_argument(\n+        \"--fuchsia-src\",\n+        default=None,\n+        help=\"the path to the Fuchsia source\",\n+    )\n+    debug_parser.add_argument(\n+        \"--test\",\n+        default=None,\n+        help=\"the path to the test to debug (e.g. ui/box/new.rs)\",\n+    )\n+    debug_parser.add_argument(\n+        \"zxdb_args\",\n+        default=None,\n+        nargs=argparse.REMAINDER,\n+        help=\"any additional arguments to pass to zxdb\",\n+    )\n+    debug_parser.set_defaults(func=debug)\n+\n+    args = parser.parse_args()\n+    return args.func(args)\n+\n+\n+if __name__ == \"__main__\":\n+    sys.exit(main())"}, {"sha": "62cad19d0ec3328a1793196e8c0301470cfb3af8", "filename": "src/doc/rustc/src/platform-support/fuchsia.md", "status": "modified", "additions": 54, "deletions": 2, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/ca92d90b5917e7176d5ff06607a2cd5352c088d3/src%2Fdoc%2Frustc%2Fsrc%2Fplatform-support%2Ffuchsia.md", "raw_url": "https://github.com/rust-lang/rust/raw/ca92d90b5917e7176d5ff06607a2cd5352c088d3/src%2Fdoc%2Frustc%2Fsrc%2Fplatform-support%2Ffuchsia.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Fplatform-support%2Ffuchsia.md?ref=ca92d90b5917e7176d5ff06607a2cd5352c088d3", "patch": "@@ -641,8 +641,60 @@ available on the [Fuchsia devsite].\n \n ### Running the compiler test suite\n \n-Running the Rust test suite on Fuchsia is [not currently supported], but work is\n-underway to enable it.\n+Pre-requisites for running the Rust test suite on Fuchsia are:\n+1. Checkout of Rust source.\n+1. Setup of `config-env.sh` and `config.toml` from \"[Targeting Fuchsia with a compiler built from source](#targeting-fuchsia-with-a-compiler-built-from-source)\".\n+1. Download of the Fuchsia SDK. Minimum supported SDK version is [9.20220726.1.1](https://chrome-infra-packages.appspot.com/p/fuchsia/sdk/core/linux-amd64/+/version:9.20220726.1.1)\n+\n+Interfacing with the Fuchsia emulator is handled by our test runner script located\n+at `${RUST_SRC_PATH}/src/ci/docker/scripts/fuchsia-test-runner.py`.\n+\n+We start by activating our Fuchsia test environment. From a terminal:\n+\n+**Issue command from ${RUST_SRC_PATH}**\n+```sh\n+src/ci/docker/scripts/fuchsia-test-runner.py start\n+    --rust .\n+    --sdk ${SDK_PATH}\n+    --target-arch {x64,arm64}\n+```\n+\n+Next, for ease of commands, we copy `config-env.sh` and `config.toml` into our Rust source\n+code path, `${RUST_SRC_PATH}`.\n+\n+From there, we utilize `x.py` to run our tests, using the test runner script to\n+run the tests on our emulator. To run the full `src/test/ui` test suite:\n+\n+**Run from ${RUST_SRC_PATH}**\n+```sh\n+( \\\n+    source config-env.sh &&                                                   \\\n+    ./x.py                                                                    \\\n+    --config config.toml                                                      \\\n+    --stage=2                                                                 \\\n+    test src/test/ui                                                          \\\n+    --target x86_64-fuchsia                                                   \\\n+    --run=always --jobs 1                                                     \\\n+    --test-args --target-rustcflags -L                                        \\\n+    --test-args --target-rustcflags ${SDK_PATH}/arch/{x64|arm64}/sysroot/lib  \\\n+    --test-args --target-rustcflags -L                                        \\\n+    --test-args --target-rustcflags ${SDK_PATH}/arch/{x64|arm64}/lib          \\\n+    --test-args --target-rustcflags -Cpanic=abort                             \\\n+    --test-args --target-rustcflags -Zpanic_abort_tests                       \\\n+    --test-args --remote-test-client                                          \\\n+    --test-args src/ci/docker/scripts/fuchsia-test-runner.py                  \\\n+)\n+```\n+\n+*Note: The test suite cannot be run in parallel at the moment, so `x.py`\n+must be run with `--jobs 1` to ensure only one test runs at a time.*\n+\n+When finished, stop the test environment:\n+\n+**Issue command from ${RUST_SRC_PATH}**\n+```sh\n+src/ci/docker/scripts/fuchsia-test-runner.py stop\n+```\n \n ## Debugging\n "}, {"sha": "d195c9cf6f9ff4b7997a782caeade9d2b2653284", "filename": "src/librustdoc/html/static/css/rustdoc.css", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ca92d90b5917e7176d5ff06607a2cd5352c088d3/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css", "raw_url": "https://github.com/rust-lang/rust/raw/ca92d90b5917e7176d5ff06607a2cd5352c088d3/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css?ref=ca92d90b5917e7176d5ff06607a2cd5352c088d3", "patch": "@@ -1262,10 +1262,6 @@ h3.variant {\n \tmargin-left: 24px;\n }\n \n-:target > code, :target > .code-header {\n-\topacity: 1;\n-}\n-\n :target {\n \tpadding-right: 3px;\n \tbackground-color: var(--target-background-color);"}, {"sha": "4999bb35994879c6823ea63aa00e192cbba93cea", "filename": "src/librustdoc/html/static/js/search.js", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ca92d90b5917e7176d5ff06607a2cd5352c088d3/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fsearch.js", "raw_url": "https://github.com/rust-lang/rust/raw/ca92d90b5917e7176d5ff06607a2cd5352c088d3/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fsearch.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fsearch.js?ref=ca92d90b5917e7176d5ff06607a2cd5352c088d3", "patch": "@@ -1491,6 +1491,7 @@ function initSearch(rawSearchIndex) {\n         const target = searchState.focusedByTab[searchState.currentTab] ||\n             document.querySelectorAll(\".search-results.active a\").item(0) ||\n             document.querySelectorAll(\"#titles > button\").item(searchState.currentTab);\n+        searchState.focusedByTab[searchState.currentTab] = null;\n         if (target) {\n             target.focus();\n         }"}, {"sha": "b4d4150cddbb8829658d75c19b5fb33d75beb3dd", "filename": "src/librustdoc/html/static_files.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ca92d90b5917e7176d5ff06607a2cd5352c088d3/src%2Flibrustdoc%2Fhtml%2Fstatic_files.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca92d90b5917e7176d5ff06607a2cd5352c088d3/src%2Flibrustdoc%2Fhtml%2Fstatic_files.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic_files.rs?ref=ca92d90b5917e7176d5ff06607a2cd5352c088d3", "patch": "@@ -19,9 +19,13 @@ impl StaticFile {\n     }\n \n     pub(crate) fn minified(&self) -> Vec<u8> {\n-        if self.filename.ends_with(\".css\") {\n+        let extension = match self.filename.extension() {\n+            Some(e) => e,\n+            None => return self.bytes.to_owned(),\n+        };\n+        if extension == \"css\" {\n             minifier::css::minify(str::from_utf8(self.bytes).unwrap()).unwrap().to_string().into()\n-        } else if self.filename.ends_with(\".js\") {\n+        } else if extension == \"js\" {\n             minifier::js::minify(str::from_utf8(self.bytes).unwrap()).to_string().into()\n         } else {\n             self.bytes.to_owned()"}, {"sha": "be642fc49971f22f4d01c8d5ecc9df0df15ec9ff", "filename": "src/test/rustdoc-gui/search-keyboard.goml", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/ca92d90b5917e7176d5ff06607a2cd5352c088d3/src%2Ftest%2Frustdoc-gui%2Fsearch-keyboard.goml", "raw_url": "https://github.com/rust-lang/rust/raw/ca92d90b5917e7176d5ff06607a2cd5352c088d3/src%2Ftest%2Frustdoc-gui%2Fsearch-keyboard.goml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-gui%2Fsearch-keyboard.goml?ref=ca92d90b5917e7176d5ff06607a2cd5352c088d3", "patch": "@@ -0,0 +1,28 @@\n+// Checks that the search tab results work correctly with function signature syntax\n+// First, try a search-by-name\n+goto: \"file://\" + |DOC_PATH| + \"/test_docs/index.html\"\n+write: (\".search-input\", \"Foo\")\n+// To be SURE that the search will be run.\n+press-key: 'Enter'\n+// Waiting for the search results to appear...\n+wait-for: \"#titles\"\n+\n+// Now use the keyboard commands to switch to the third result.\n+press-key: \"ArrowDown\"\n+press-key: \"ArrowDown\"\n+press-key: \"ArrowDown\"\n+assert: \".search-results.active > a:focus:nth-of-type(3)\"\n+\n+// Now switch to the second tab, then back to the first one, then arrow back up.\n+press-key: \"ArrowRight\"\n+assert: \".search-results.active:nth-of-type(2) > a:focus:nth-of-type(1)\"\n+press-key: \"ArrowLeft\"\n+assert: \".search-results.active:nth-of-type(1) > a:focus:nth-of-type(3)\"\n+press-key: \"ArrowUp\"\n+assert: \".search-results.active > a:focus:nth-of-type(2)\"\n+press-key: \"ArrowUp\"\n+assert: \".search-results.active > a:focus:nth-of-type(1)\"\n+press-key: \"ArrowUp\"\n+assert: \".search-input:focus\"\n+press-key: \"ArrowDown\"\n+assert: \".search-results.active > a:focus:nth-of-type(1)\""}, {"sha": "b36f270806ff33aa4b9ca1136f1d520be65a922f", "filename": "src/test/rustdoc/issue-102154.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/ca92d90b5917e7176d5ff06607a2cd5352c088d3/src%2Ftest%2Frustdoc%2Fissue-102154.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca92d90b5917e7176d5ff06607a2cd5352c088d3/src%2Ftest%2Frustdoc%2Fissue-102154.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fissue-102154.rs?ref=ca92d90b5917e7176d5ff06607a2cd5352c088d3", "patch": "@@ -0,0 +1,13 @@\n+trait A<Y, N> {\n+    type B;\n+}\n+type MaybeBox<T> = <T as A<T, Box<T>>>::B;\n+struct P {\n+    t: MaybeBox<P>\n+}\n+impl<Y, N> A<Y, N> for P {\n+    type B = N;\n+}\n+fn main() {\n+    let t: MaybeBox<P>;\n+}"}, {"sha": "06cf243f1b4fa9293e4469bb5f58921880e03ec7", "filename": "src/test/ui/suggestions/dont-suggest-ufcs-for-const.rs", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ca92d90b5917e7176d5ff06607a2cd5352c088d3/src%2Ftest%2Fui%2Fsuggestions%2Fdont-suggest-ufcs-for-const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca92d90b5917e7176d5ff06607a2cd5352c088d3/src%2Ftest%2Fui%2Fsuggestions%2Fdont-suggest-ufcs-for-const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fdont-suggest-ufcs-for-const.rs?ref=ca92d90b5917e7176d5ff06607a2cd5352c088d3", "patch": "@@ -0,0 +1,4 @@\n+fn main() {\n+    1_u32.MAX();\n+    //~^ ERROR no method named `MAX` found for type `u32` in the current scope\n+}"}, {"sha": "04e0511d788ed160de56b1f6f05689d2527d315d", "filename": "src/test/ui/suggestions/dont-suggest-ufcs-for-const.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/ca92d90b5917e7176d5ff06607a2cd5352c088d3/src%2Ftest%2Fui%2Fsuggestions%2Fdont-suggest-ufcs-for-const.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ca92d90b5917e7176d5ff06607a2cd5352c088d3/src%2Ftest%2Fui%2Fsuggestions%2Fdont-suggest-ufcs-for-const.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fdont-suggest-ufcs-for-const.stderr?ref=ca92d90b5917e7176d5ff06607a2cd5352c088d3", "patch": "@@ -0,0 +1,15 @@\n+error[E0599]: no method named `MAX` found for type `u32` in the current scope\n+  --> $DIR/dont-suggest-ufcs-for-const.rs:2:11\n+   |\n+LL |     1_u32.MAX();\n+   |     ------^^^--\n+   |     |     |\n+   |     |     this is an associated function, not a method\n+   |     help: use associated function syntax instead: `u32::MAX()`\n+   |\n+   = note: found the following associated functions; to be used as methods, functions must have a `self` parameter\n+   = note: the candidate is defined in an impl for the type `u32`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0599`."}, {"sha": "8d96cf590c39881580492456617070a236e5bc5e", "filename": "src/test/ui/suggestions/suggest-assoc-fn-call-deref.fixed", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/ca92d90b5917e7176d5ff06607a2cd5352c088d3/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-assoc-fn-call-deref.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/ca92d90b5917e7176d5ff06607a2cd5352c088d3/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-assoc-fn-call-deref.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-assoc-fn-call-deref.fixed?ref=ca92d90b5917e7176d5ff06607a2cd5352c088d3", "patch": "@@ -0,0 +1,15 @@\n+// run-rustfix\n+\n+#![allow(unused)]\n+\n+struct Foo<T>(T);\n+\n+impl<T> Foo<T> {\n+    fn test() -> i32 { 1 }\n+}\n+\n+fn main() {\n+    let x = Box::new(Foo(1i32));\n+    Foo::<i32>::test();\n+    //~^ ERROR no method named `test` found for struct `Box<Foo<i32>>` in the current scope\n+}"}, {"sha": "186901f75a84ba992527e5026ca23624991c51dd", "filename": "src/test/ui/suggestions/suggest-assoc-fn-call-deref.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/ca92d90b5917e7176d5ff06607a2cd5352c088d3/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-assoc-fn-call-deref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca92d90b5917e7176d5ff06607a2cd5352c088d3/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-assoc-fn-call-deref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-assoc-fn-call-deref.rs?ref=ca92d90b5917e7176d5ff06607a2cd5352c088d3", "patch": "@@ -0,0 +1,15 @@\n+// run-rustfix\n+\n+#![allow(unused)]\n+\n+struct Foo<T>(T);\n+\n+impl<T> Foo<T> {\n+    fn test() -> i32 { 1 }\n+}\n+\n+fn main() {\n+    let x = Box::new(Foo(1i32));\n+    x.test();\n+    //~^ ERROR no method named `test` found for struct `Box<Foo<i32>>` in the current scope\n+}"}, {"sha": "00fb96f032668087dd2385c471c38f5b5b1f4a8a", "filename": "src/test/ui/suggestions/suggest-assoc-fn-call-deref.stderr", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/ca92d90b5917e7176d5ff06607a2cd5352c088d3/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-assoc-fn-call-deref.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ca92d90b5917e7176d5ff06607a2cd5352c088d3/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-assoc-fn-call-deref.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-assoc-fn-call-deref.stderr?ref=ca92d90b5917e7176d5ff06607a2cd5352c088d3", "patch": "@@ -0,0 +1,19 @@\n+error[E0599]: no method named `test` found for struct `Box<Foo<i32>>` in the current scope\n+  --> $DIR/suggest-assoc-fn-call-deref.rs:13:7\n+   |\n+LL |     x.test();\n+   |     --^^^^--\n+   |     | |\n+   |     | this is an associated function, not a method\n+   |     help: use associated function syntax instead: `Foo::<i32>::test()`\n+   |\n+   = note: found the following associated functions; to be used as methods, functions must have a `self` parameter\n+note: the candidate is defined in an impl for the type `Foo<T>`\n+  --> $DIR/suggest-assoc-fn-call-deref.rs:8:5\n+   |\n+LL |     fn test() -> i32 { 1 }\n+   |     ^^^^^^^^^^^^^^^^\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0599`."}, {"sha": "d13b34a66cca783ea01a70426ca6316af8684471", "filename": "src/tools/clippy/clippy_utils/src/macros.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ca92d90b5917e7176d5ff06607a2cd5352c088d3/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca92d90b5917e7176d5ff06607a2cd5352c088d3/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fmacros.rs?ref=ca92d90b5917e7176d5ff06607a2cd5352c088d3", "patch": "@@ -199,12 +199,12 @@ pub fn first_node_in_macro(cx: &LateContext<'_>, node: &impl HirNode) -> Option<\n pub fn is_panic(cx: &LateContext<'_>, def_id: DefId) -> bool {\n     let Some(name) = cx.tcx.get_diagnostic_name(def_id) else { return false };\n     matches!(\n-        name.as_str(),\n-        \"core_panic_macro\"\n-            | \"std_panic_macro\"\n-            | \"core_panic_2015_macro\"\n-            | \"std_panic_2015_macro\"\n-            | \"core_panic_2021_macro\"\n+        name,\n+        sym::core_panic_macro\n+            | sym::std_panic_macro\n+            | sym::core_panic_2015_macro\n+            | sym::std_panic_2015_macro\n+            | sym::core_panic_2021_macro\n     )\n }\n "}]}