{"sha": "2e888d0341e81de1744b257c25b012c2c148f0ba", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJlODg4ZDAzNDFlODFkZTE3NDRiMjU3YzI1YjAxMmMyYzE0OGYwYmE=", "commit": {"author": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2015-01-13T03:24:37Z"}, "committer": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2015-01-24T13:33:50Z"}, "message": "Add the span of the operator itself to ast::BinOp.", "tree": {"sha": "c1d2c0cfdd93246cd88388f2a93ef83471ff1423", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c1d2c0cfdd93246cd88388f2a93ef83471ff1423"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2e888d0341e81de1744b257c25b012c2c148f0ba", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2e888d0341e81de1744b257c25b012c2c148f0ba", "html_url": "https://github.com/rust-lang/rust/commit/2e888d0341e81de1744b257c25b012c2c148f0ba", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2e888d0341e81de1744b257c25b012c2c148f0ba/comments", "author": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4be79d6acde9eed3a9b5281a46f385bcb4ce736c", "url": "https://api.github.com/repos/rust-lang/rust/commits/4be79d6acde9eed3a9b5281a46f385bcb4ce736c", "html_url": "https://github.com/rust-lang/rust/commit/4be79d6acde9eed3a9b5281a46f385bcb4ce736c"}], "stats": {"total": 134, "additions": 69, "deletions": 65}, "files": [{"sha": "9a7b7e0eb942ad357f37609e6a599fe3b58119a6", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/2e888d0341e81de1744b257c25b012c2c148f0ba/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e888d0341e81de1744b257c25b012c2c148f0ba/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=2e888d0341e81de1744b257c25b012c2c148f0ba", "patch": "@@ -44,7 +44,7 @@ use std::{i8, i16, i32, i64, u8, u16, u32, u64, f32, f64};\n use syntax::{abi, ast, ast_map};\n use syntax::ast_util::is_shift_binop;\n use syntax::attr::{self, AttrMetaMethods};\n-use syntax::codemap::{Span, DUMMY_SP};\n+use syntax::codemap::{self, Span, DUMMY_SP};\n use syntax::parse::token;\n use syntax::ast::{TyIs, TyUs, TyI8, TyU8, TyI16, TyU16, TyI32, TyU32, TyI64, TyU64};\n use syntax::ast_util;\n@@ -185,7 +185,7 @@ impl LintPass for TypeLimits {\n                                  \"comparison is useless due to type limits\");\n                 }\n \n-                if is_shift_binop(binop) {\n+                if is_shift_binop(binop.node) {\n                     let opt_ty_bits = match ty::expr_ty(cx.tcx, &**l).sty {\n                         ty::ty_int(t) => Some(int_ty_bits(t, cx.sess().target.int_type)),\n                         ty::ty_uint(t) => Some(uint_ty_bits(t, cx.sess().target.uint_type)),\n@@ -272,7 +272,7 @@ impl LintPass for TypeLimits {\n \n         fn is_valid<T:cmp::PartialOrd>(binop: ast::BinOp, v: T,\n                                 min: T, max: T) -> bool {\n-            match binop {\n+            match binop.node {\n                 ast::BiLt => v >  min && v <= max,\n                 ast::BiLe => v >= min && v <  max,\n                 ast::BiGt => v >= min && v <  max,\n@@ -283,13 +283,13 @@ impl LintPass for TypeLimits {\n         }\n \n         fn rev_binop(binop: ast::BinOp) -> ast::BinOp {\n-            match binop {\n+            codemap::respan(binop.span, match binop.node {\n                 ast::BiLt => ast::BiGt,\n                 ast::BiLe => ast::BiGe,\n                 ast::BiGt => ast::BiLt,\n                 ast::BiGe => ast::BiLe,\n-                _ => binop\n-            }\n+                _ => return binop\n+            })\n         }\n \n         // for int & uint, be conservative with the warnings, so that the\n@@ -382,7 +382,7 @@ impl LintPass for TypeLimits {\n         }\n \n         fn is_comparison(binop: ast::BinOp) -> bool {\n-            match binop {\n+            match binop.node {\n                 ast::BiEq | ast::BiLt | ast::BiLe |\n                 ast::BiNe | ast::BiGe | ast::BiGt => true,\n                 _ => false"}, {"sha": "6162f61fde1c7f4b5ae43877c183bc7ab0ba4dd0", "filename": "src/librustc/middle/cfg/construct.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2e888d0341e81de1744b257c25b012c2c148f0ba/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e888d0341e81de1744b257c25b012c2c148f0ba/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs?ref=2e888d0341e81de1744b257c25b012c2c148f0ba", "patch": "@@ -372,7 +372,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n                 expr_exit\n             }\n \n-            ast::ExprBinary(op, ref l, ref r) if ast_util::lazy_binop(op) => {\n+            ast::ExprBinary(op, ref l, ref r) if ast_util::lazy_binop(op.node) => {\n                 //\n                 //     [pred]\n                 //       |"}, {"sha": "c2533c1a9c688bde51530240c2441904166860e6", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2e888d0341e81de1744b257c25b012c2c148f0ba/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e888d0341e81de1744b257c25b012c2c148f0ba/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=2e888d0341e81de1744b257c25b012c2c148f0ba", "patch": "@@ -400,7 +400,7 @@ pub fn eval_const_expr_partial(tcx: &ty::ctxt, e: &Expr) -> Result<const_val, St\n         match (eval_const_expr_partial(tcx, &**a),\n                eval_const_expr_partial(tcx, &**b)) {\n           (Ok(const_float(a)), Ok(const_float(b))) => {\n-            match op {\n+            match op.node {\n               ast::BiAdd => Ok(const_float(a + b)),\n               ast::BiSub => Ok(const_float(a - b)),\n               ast::BiMul => Ok(const_float(a * b)),\n@@ -416,7 +416,7 @@ pub fn eval_const_expr_partial(tcx: &ty::ctxt, e: &Expr) -> Result<const_val, St\n             }\n           }\n           (Ok(const_int(a)), Ok(const_int(b))) => {\n-            match op {\n+            match op.node {\n               ast::BiAdd => Ok(const_int(a + b)),\n               ast::BiSub => Ok(const_int(a - b)),\n               ast::BiMul => Ok(const_int(a * b)),\n@@ -443,7 +443,7 @@ pub fn eval_const_expr_partial(tcx: &ty::ctxt, e: &Expr) -> Result<const_val, St\n             }\n           }\n           (Ok(const_uint(a)), Ok(const_uint(b))) => {\n-            match op {\n+            match op.node {\n               ast::BiAdd => Ok(const_uint(a + b)),\n               ast::BiSub => Ok(const_uint(a - b)),\n               ast::BiMul => Ok(const_uint(a * b)),\n@@ -471,21 +471,21 @@ pub fn eval_const_expr_partial(tcx: &ty::ctxt, e: &Expr) -> Result<const_val, St\n           }\n           // shifts can have any integral type as their rhs\n           (Ok(const_int(a)), Ok(const_uint(b))) => {\n-            match op {\n+            match op.node {\n               ast::BiShl => Ok(const_int(a << b as uint)),\n               ast::BiShr => Ok(const_int(a >> b as uint)),\n               _ => Err(\"can't do this op on an int and uint\".to_string())\n             }\n           }\n           (Ok(const_uint(a)), Ok(const_int(b))) => {\n-            match op {\n+            match op.node {\n               ast::BiShl => Ok(const_uint(a << b as uint)),\n               ast::BiShr => Ok(const_uint(a >> b as uint)),\n               _ => Err(\"can't do this op on a uint and int\".to_string())\n             }\n           }\n           (Ok(const_bool(a)), Ok(const_bool(b))) => {\n-            Ok(const_bool(match op {\n+            Ok(const_bool(match op.node {\n               ast::BiAnd => a && b,\n               ast::BiOr => a || b,\n               ast::BiBitXor => a ^ b,"}, {"sha": "d9ab86deb3b7c4454fe2f27b916182d8ac80165d", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2e888d0341e81de1744b257c25b012c2c148f0ba/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e888d0341e81de1744b257c25b012c2c148f0ba/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=2e888d0341e81de1744b257c25b012c2c148f0ba", "patch": "@@ -568,7 +568,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n             }\n \n             ast::ExprBinary(op, ref lhs, ref rhs) => {\n-                let pass_args = if ast_util::is_by_value_binop(op) {\n+                let pass_args = if ast_util::is_by_value_binop(op.node) {\n                     PassArgs::ByValue\n                 } else {\n                     PassArgs::ByRef"}, {"sha": "c08af95f139963a34ee836f728838a45fe9afcd0", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2e888d0341e81de1744b257c25b012c2c148f0ba/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e888d0341e81de1744b257c25b012c2c148f0ba/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=2e888d0341e81de1744b257c25b012c2c148f0ba", "patch": "@@ -504,7 +504,7 @@ fn visit_expr(ir: &mut IrMaps, expr: &Expr) {\n         ir.add_live_node_for_node(expr.id, ExprNode(expr.span));\n         visit::walk_expr(ir, expr);\n       }\n-      ast::ExprBinary(op, _, _) if ast_util::lazy_binop(op) => {\n+      ast::ExprBinary(op, _, _) if ast_util::lazy_binop(op.node) => {\n         ir.add_live_node_for_node(expr.id, ExprNode(expr.span));\n         visit::walk_expr(ir, expr);\n       }\n@@ -1177,7 +1177,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n             self.propagate_through_exprs(&exprs[], succ)\n           }\n \n-          ast::ExprBinary(op, ref l, ref r) if ast_util::lazy_binop(op) => {\n+          ast::ExprBinary(op, ref l, ref r) if ast_util::lazy_binop(op.node) => {\n             let r_succ = self.propagate_through_expr(&**r, succ);\n \n             let ln = self.live_node(expr.id, expr.span);"}, {"sha": "67c0e52d6649a6da95e5abb27b5f8bd1e7f77418", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2e888d0341e81de1744b257c25b012c2c148f0ba/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e888d0341e81de1744b257c25b012c2c148f0ba/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=2e888d0341e81de1744b257c25b012c2c148f0ba", "patch": "@@ -22,7 +22,7 @@ use util::nodemap::{FnvHashMap, FnvHashSet, NodeMap};\n use util::common::can_reach;\n \n use std::cell::RefCell;\n-use syntax::codemap::Span;\n+use syntax::codemap::{self, Span};\n use syntax::{ast, visit};\n use syntax::ast::{Block, Item, FnDecl, NodeId, Arm, Pat, Stmt, Expr, Local};\n use syntax::ast_util::{stmt_id};\n@@ -496,8 +496,8 @@ fn resolve_expr(visitor: &mut RegionResolutionVisitor, expr: &ast::Expr) {\n             // scopes, meaning that temporaries cannot outlive them.\n             // This ensures fixed size stacks.\n \n-            ast::ExprBinary(ast::BiAnd, _, ref r) |\n-            ast::ExprBinary(ast::BiOr, _, ref r) => {\n+            ast::ExprBinary(codemap::Spanned { node: ast::BiAnd, .. }, _, ref r) |\n+            ast::ExprBinary(codemap::Spanned { node: ast::BiOr, .. }, _, ref r) => {\n                 // For shortcircuiting operators, mark the RHS as a terminating\n                 // scope since it only executes conditionally.\n                 terminating(r.id);"}, {"sha": "bae41b78c08a4de7da71767c9a80cd57e0bc9bfb", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2e888d0341e81de1744b257c25b012c2c148f0ba/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e888d0341e81de1744b257c25b012c2c148f0ba/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=2e888d0341e81de1744b257c25b012c2c148f0ba", "patch": "@@ -5716,7 +5716,7 @@ pub fn is_binopable<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>, op: ast::BinOp) -> bool\n     static opcat_mod: int = 8;\n \n     fn opcat(op: ast::BinOp) -> int {\n-        match op {\n+        match op.node {\n           ast::BiAdd => opcat_add,\n           ast::BiSub => opcat_sub,\n           ast::BiMul => opcat_mult,"}, {"sha": "65a7fbf60a5d8e395ab2addc58ea8f43de07e0c2", "filename": "src/librustc_back/svh.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2e888d0341e81de1744b257c25b012c2c148f0ba/src%2Flibrustc_back%2Fsvh.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e888d0341e81de1744b257c25b012c2c148f0ba/src%2Flibrustc_back%2Fsvh.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Fsvh.rs?ref=2e888d0341e81de1744b257c25b012c2c148f0ba", "patch": "@@ -231,7 +231,7 @@ mod svh_visitor {\n         SawExprCall,\n         SawExprMethodCall,\n         SawExprTup,\n-        SawExprBinary(ast::BinOp),\n+        SawExprBinary(ast::BinOp_),\n         SawExprUnary(ast::UnOp),\n         SawExprLit(ast::Lit_),\n         SawExprCast,\n@@ -241,7 +241,7 @@ mod svh_visitor {\n         SawExprClosure,\n         SawExprBlock,\n         SawExprAssign,\n-        SawExprAssignOp(ast::BinOp),\n+        SawExprAssignOp(ast::BinOp_),\n         SawExprIndex,\n         SawExprRange,\n         SawExprPath,\n@@ -262,7 +262,7 @@ mod svh_visitor {\n             ExprCall(..)             => SawExprCall,\n             ExprMethodCall(..)       => SawExprMethodCall,\n             ExprTup(..)              => SawExprTup,\n-            ExprBinary(op, _, _)     => SawExprBinary(op),\n+            ExprBinary(op, _, _)     => SawExprBinary(op.node),\n             ExprUnary(op, _)         => SawExprUnary(op),\n             ExprLit(ref lit)         => SawExprLit(lit.node.clone()),\n             ExprCast(..)             => SawExprCast,\n@@ -273,7 +273,7 @@ mod svh_visitor {\n             ExprClosure(..)          => SawExprClosure,\n             ExprBlock(..)            => SawExprBlock,\n             ExprAssign(..)           => SawExprAssign,\n-            ExprAssignOp(op, _, _)   => SawExprAssignOp(op),\n+            ExprAssignOp(op, _, _)   => SawExprAssignOp(op.node),\n             ExprField(_, id)         => SawExprField(content(id.node)),\n             ExprTupField(_, id)      => SawExprTupField(id.node),\n             ExprIndex(..)            => SawExprIndex,"}, {"sha": "4c1fdc6140ec07a4b73728630dbb3ad8d732ea57", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2e888d0341e81de1744b257c25b012c2c148f0ba/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e888d0341e81de1744b257c25b012c2c148f0ba/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=2e888d0341e81de1744b257c25b012c2c148f0ba", "patch": "@@ -540,7 +540,7 @@ pub fn compare_scalar_types<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n                                         lhs: ValueRef,\n                                         rhs: ValueRef,\n                                         t: Ty<'tcx>,\n-                                        op: ast::BinOp)\n+                                        op: ast::BinOp_)\n                                         -> Result<'blk, 'tcx> {\n     let f = |&: a| Result::new(cx, compare_scalar_values(cx, lhs, rhs, a, op));\n \n@@ -561,7 +561,7 @@ pub fn compare_scalar_values<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n                                          lhs: ValueRef,\n                                          rhs: ValueRef,\n                                          nt: scalar_type,\n-                                         op: ast::BinOp)\n+                                         op: ast::BinOp_)\n                                          -> ValueRef {\n     let _icx = push_ctxt(\"compare_scalar_values\");\n     fn die(cx: Block) -> ! {\n@@ -635,7 +635,7 @@ pub fn compare_simd_types<'blk, 'tcx>(\n                            not supported for floating point SIMD types\")\n         },\n         ty::ty_uint(_) | ty::ty_int(_) => {\n-            let cmp = match op {\n+            let cmp = match op.node {\n                 ast::BiEq => llvm::IntEQ,\n                 ast::BiNe => llvm::IntNE,\n                 ast::BiLt => llvm::IntSLT,\n@@ -823,7 +823,7 @@ pub fn cast_shift_rhs<F, G>(op: ast::BinOp,\n     G: FnOnce(ValueRef, Type) -> ValueRef,\n {\n     // Shifts may have any size int on the rhs\n-    if ast_util::is_shift_binop(op) {\n+    if ast_util::is_shift_binop(op.node) {\n         let mut rhs_llty = val_ty(rhs);\n         let mut lhs_llty = val_ty(lhs);\n         if rhs_llty.kind() == Vector { rhs_llty = rhs_llty.element_type() }\n@@ -852,7 +852,7 @@ pub fn fail_if_zero_or_overflows<'blk, 'tcx>(\n                                 rhs: ValueRef,\n                                 rhs_t: Ty<'tcx>)\n                                 -> Block<'blk, 'tcx> {\n-    let (zero_text, overflow_text) = if divrem == ast::BiDiv {\n+    let (zero_text, overflow_text) = if divrem.node == ast::BiDiv {\n         (\"attempted to divide by zero\",\n          \"attempted to divide with overflow\")\n     } else {"}, {"sha": "ba3af53a9160a4030c8a8bdc320bcddb9eef061b", "filename": "src/librustc_trans/trans/consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2e888d0341e81de1744b257c25b012c2c148f0ba/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e888d0341e81de1744b257c25b012c2c148f0ba/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs?ref=2e888d0341e81de1744b257c25b012c2c148f0ba", "patch": "@@ -310,7 +310,7 @@ fn const_expr_unadjusted(cx: &CrateContext, e: &ast::Expr) -> ValueRef {\n             let ty = ty::expr_ty(cx.tcx(), &**e1);\n             let is_float = ty::type_is_fp(ty);\n             let signed = ty::type_is_signed(ty);\n-            return match b {\n+            return match b.node {\n               ast::BiAdd   => {\n                 if is_float { llvm::LLVMConstFAdd(te1, te2) }\n                 else        { llvm::LLVMConstAdd(te1, te2) }"}, {"sha": "f0b491bdea848d4a7400a7a73694f4fcbd3b03eb", "filename": "src/librustc_trans/trans/expr.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2e888d0341e81de1744b257c25b012c2c148f0ba/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e888d0341e81de1744b257c25b012c2c148f0ba/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs?ref=2e888d0341e81de1744b257c25b012c2c148f0ba", "patch": "@@ -1132,7 +1132,7 @@ fn trans_rvalue_dps_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             let rhs_datum = unpack_datum!(bcx, trans(bcx, &**rhs));\n             trans_overloaded_op(bcx, expr, MethodCall::expr(expr.id), lhs,\n                                 vec![(rhs_datum, rhs.id)], Some(dest),\n-                                !ast_util::is_by_value_binop(op)).bcx\n+                                !ast_util::is_by_value_binop(op.node)).bcx\n         }\n         ast::ExprUnary(op, ref subexpr) => {\n             // if not overloaded, would be RvalueDatumExpr\n@@ -1676,7 +1676,7 @@ fn trans_eager_binop<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let binop_debug_loc = binop_expr.debug_loc();\n \n     let mut bcx = bcx;\n-    let val = match op {\n+    let val = match op.node {\n       ast::BiAdd => {\n         if is_float {\n             FAdd(bcx, lhs, rhs, binop_debug_loc)\n@@ -1739,7 +1739,7 @@ fn trans_eager_binop<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n       }\n       ast::BiEq | ast::BiNe | ast::BiLt | ast::BiGe | ast::BiLe | ast::BiGt => {\n         if ty::type_is_scalar(rhs_t) {\n-            unpack_result!(bcx, base::compare_scalar_types(bcx, lhs, rhs, rhs_t, op))\n+            unpack_result!(bcx, base::compare_scalar_types(bcx, lhs, rhs, rhs_t, op.node))\n         } else if is_simd {\n             base::compare_simd_types(bcx, lhs, rhs, intype, ty::simd_size(tcx, lhs_t), op)\n         } else {\n@@ -1811,7 +1811,7 @@ fn trans_binary<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     // if overloaded, would be RvalueDpsExpr\n     assert!(!ccx.tcx().method_map.borrow().contains_key(&MethodCall::expr(expr.id)));\n \n-    match op {\n+    match op.node {\n         ast::BiAnd => {\n             trans_lazy_binop(bcx, expr, lazy_and, lhs, rhs)\n         }"}, {"sha": "a9f81d3a26632b98727d6f805586d1e2cb710d40", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/2e888d0341e81de1744b257c25b012c2c148f0ba/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e888d0341e81de1744b257c25b012c2c148f0ba/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=2e888d0341e81de1744b257c25b012c2c148f0ba", "patch": "@@ -2859,7 +2859,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n         let lhs_t = structurally_resolved_type(fcx, lhs.span,\n                                                fcx.expr_ty(&*lhs));\n \n-        if ty::type_is_integral(lhs_t) && ast_util::is_shift_binop(op) {\n+        if ty::type_is_integral(lhs_t) && ast_util::is_shift_binop(op.node) {\n             // Shift is a special case: rhs must be uint, no matter what lhs is\n             check_expr(fcx, &**rhs);\n             let rhs_ty = fcx.expr_ty(&**rhs);\n@@ -2887,7 +2887,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n             demand::suptype(fcx, expr.span, tvar, lhs_t);\n             check_expr_has_type(fcx, &**rhs, tvar);\n \n-            let result_t = match op {\n+            let result_t = match op.node {\n                 ast::BiEq | ast::BiNe | ast::BiLt | ast::BiLe | ast::BiGe |\n                 ast::BiGt => {\n                     if ty::type_is_simd(tcx, lhs_t) {\n@@ -2898,7 +2898,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                                              operation `{}` not \\\n                                              supported for floating \\\n                                              point SIMD vector `{}`\",\n-                                            ast_util::binop_to_string(op),\n+                                            ast_util::binop_to_string(op.node),\n                                             actual)\n                                 },\n                                 lhs_t,\n@@ -2919,7 +2919,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n             return;\n         }\n \n-        if op == ast::BiOr || op == ast::BiAnd {\n+        if op.node == ast::BiOr || op.node == ast::BiAnd {\n             // This is an error; one of the operands must have the wrong\n             // type\n             fcx.write_error(expr.id);\n@@ -2928,7 +2928,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                                    |actual| {\n                     format!(\"binary operation `{}` cannot be applied \\\n                              to type `{}`\",\n-                            ast_util::binop_to_string(op),\n+                            ast_util::binop_to_string(op.node),\n                             actual)\n                 },\n                 lhs_t,\n@@ -2945,7 +2945,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                                                  operation `{}=` \\\n                                                  cannot be applied to \\\n                                                  type `{}`\",\n-                                                ast_util::binop_to_string(op),\n+                                                ast_util::binop_to_string(op.node),\n                                                 actual)\n                                    },\n                                    lhs_t,\n@@ -2968,7 +2968,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                                   rhs: &P<ast::Expr>) -> Ty<'tcx> {\n         let tcx = fcx.ccx.tcx;\n         let lang = &tcx.lang_items;\n-        let (name, trait_did) = match op {\n+        let (name, trait_did) = match op.node {\n             ast::BiAdd => (\"add\", lang.add_trait()),\n             ast::BiSub => (\"sub\", lang.sub_trait()),\n             ast::BiMul => (\"mul\", lang.mul_trait()),\n@@ -2994,10 +2994,10 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                          trait_did, lhs_expr, Some(rhs), || {\n             fcx.type_error_message(ex.span, |actual| {\n                 format!(\"binary operation `{}` cannot be applied to type `{}`\",\n-                        ast_util::binop_to_string(op),\n+                        ast_util::binop_to_string(op.node),\n                         actual)\n             }, lhs_resolved_t, None)\n-        }, if ast_util::is_by_value_binop(op) { AutorefArgs::No } else { AutorefArgs::Yes })\n+        }, if ast_util::is_by_value_binop(op.node) { AutorefArgs::No } else { AutorefArgs::Yes })\n     }\n \n     fn check_user_unop<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,"}, {"sha": "af5250805b7c608679437d0ec0985c0de1587ac8", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2e888d0341e81de1744b257c25b012c2c148f0ba/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e888d0341e81de1744b257c25b012c2c148f0ba/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=2e888d0341e81de1744b257c25b012c2c148f0ba", "patch": "@@ -564,7 +564,7 @@ fn visit_expr(rcx: &mut Rcx, expr: &ast::Expr) {\n         },\n \n         ast::ExprBinary(op, ref lhs, ref rhs) if has_method_map => {\n-            let implicitly_ref_args = !ast_util::is_by_value_binop(op);\n+            let implicitly_ref_args = !ast_util::is_by_value_binop(op.node);\n \n             // As `expr_method_call`, but the call is via an\n             // overloaded op.  Note that we (sadly) currently use an"}, {"sha": "25a30b5e8e2ee41751338bd5d4ef063b55f178c3", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2e888d0341e81de1744b257c25b012c2c148f0ba/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e888d0341e81de1744b257c25b012c2c148f0ba/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=2e888d0341e81de1744b257c25b012c2c148f0ba", "patch": "@@ -13,7 +13,7 @@\n pub use self::AsmDialect::*;\n pub use self::AttrStyle::*;\n pub use self::BindingMode::*;\n-pub use self::BinOp::*;\n+pub use self::BinOp_::*;\n pub use self::BlockCheckMode::*;\n pub use self::CaptureClause::*;\n pub use self::Decl_::*;\n@@ -582,7 +582,7 @@ pub enum Mutability {\n }\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Show, Copy)]\n-pub enum BinOp {\n+pub enum BinOp_ {\n     BiAdd,\n     BiSub,\n     BiMul,\n@@ -603,6 +603,8 @@ pub enum BinOp {\n     BiGt,\n }\n \n+pub type BinOp = Spanned<BinOp_>;\n+\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Show, Copy)]\n pub enum UnOp {\n     UnUniq,"}, {"sha": "5aeea47ac60dc4b56d9d634765d1296c3bf6120d", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2e888d0341e81de1744b257c25b012c2c148f0ba/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e888d0341e81de1744b257c25b012c2c148f0ba/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=2e888d0341e81de1744b257c25b012c2c148f0ba", "patch": "@@ -46,7 +46,7 @@ pub fn stmt_id(s: &Stmt) -> NodeId {\n     }\n }\n \n-pub fn binop_to_string(op: BinOp) -> &'static str {\n+pub fn binop_to_string(op: BinOp_) -> &'static str {\n     match op {\n         BiAdd => \"+\",\n         BiSub => \"-\",\n@@ -69,31 +69,31 @@ pub fn binop_to_string(op: BinOp) -> &'static str {\n     }\n }\n \n-pub fn lazy_binop(b: BinOp) -> bool {\n+pub fn lazy_binop(b: BinOp_) -> bool {\n     match b {\n       BiAnd => true,\n       BiOr => true,\n       _ => false\n     }\n }\n \n-pub fn is_shift_binop(b: BinOp) -> bool {\n+pub fn is_shift_binop(b: BinOp_) -> bool {\n     match b {\n       BiShl => true,\n       BiShr => true,\n       _ => false\n     }\n }\n \n-pub fn is_comparison_binop(b: BinOp) -> bool {\n+pub fn is_comparison_binop(b: BinOp_) -> bool {\n     match b {\n         BiEq | BiLt | BiLe | BiNe | BiGt | BiGe => true,\n         _ => false\n     }\n }\n \n /// Returns `true` if the binary operator takes its arguments by value\n-pub fn is_by_value_binop(b: BinOp) -> bool {\n+pub fn is_by_value_binop(b: BinOp_) -> bool {\n     match b {\n         BiAdd | BiSub | BiMul | BiDiv | BiRem | BiBitXor | BiBitAnd | BiBitOr | BiShl | BiShr => {\n             true\n@@ -319,7 +319,7 @@ pub fn struct_field_visibility(field: ast::StructField) -> Visibility {\n }\n \n /// Maps a binary operator to its precedence\n-pub fn operator_prec(op: ast::BinOp) -> usize {\n+pub fn operator_prec(op: ast::BinOp_) -> usize {\n   match op {\n       // 'as' sits here with 12\n       BiMul | BiDiv | BiRem     => 11us,"}, {"sha": "2b3a72126831e7d8a3ae69def8692ade112586e5", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2e888d0341e81de1744b257c25b012c2c148f0ba/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e888d0341e81de1744b257c25b012c2c148f0ba/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=2e888d0341e81de1744b257c25b012c2c148f0ba", "patch": "@@ -106,7 +106,7 @@ pub trait AstBuilder {\n     fn expr_ident(&self, span: Span, id: ast::Ident) -> P<ast::Expr>;\n \n     fn expr_self(&self, span: Span) -> P<ast::Expr>;\n-    fn expr_binary(&self, sp: Span, op: ast::BinOp,\n+    fn expr_binary(&self, sp: Span, op: ast::BinOp_,\n                    lhs: P<ast::Expr>, rhs: P<ast::Expr>) -> P<ast::Expr>;\n     fn expr_deref(&self, sp: Span, e: P<ast::Expr>) -> P<ast::Expr>;\n     fn expr_unary(&self, sp: Span, op: ast::UnOp, e: P<ast::Expr>) -> P<ast::Expr>;\n@@ -561,9 +561,9 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n         self.expr_ident(span, special_idents::self_)\n     }\n \n-    fn expr_binary(&self, sp: Span, op: ast::BinOp,\n+    fn expr_binary(&self, sp: Span, op: ast::BinOp_,\n                    lhs: P<ast::Expr>, rhs: P<ast::Expr>) -> P<ast::Expr> {\n-        self.expr(sp, ast::ExprBinary(op, lhs, rhs))\n+        self.expr(sp, ast::ExprBinary(Spanned { node: op, span: sp }, lhs, rhs))\n     }\n \n     fn expr_deref(&self, sp: Span, e: P<ast::Expr>) -> P<ast::Expr> {"}, {"sha": "f8812f4d28dc7ad5c8cca5b1ab04a28c9e37bd22", "filename": "src/libsyntax/ext/deriving/generic/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2e888d0341e81de1744b257c25b012c2c148f0ba/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e888d0341e81de1744b257c25b012c2c148f0ba/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs?ref=2e888d0341e81de1744b257c25b012c2c148f0ba", "patch": "@@ -1449,7 +1449,7 @@ pub fn cs_same_method_fold<F>(use_foldl: bool,\n /// Use a given binop to combine the result of calling the derived method\n /// on all the fields.\n #[inline]\n-pub fn cs_binop(binop: ast::BinOp, base: P<Expr>,\n+pub fn cs_binop(binop: ast::BinOp_, base: P<Expr>,\n                 enum_nonmatch_f: EnumNonMatchCollapsedFunc,\n                 cx: &mut ExtCtxt, trait_span: Span,\n                 substructure: &Substructure) -> P<Expr> {"}, {"sha": "15254988ce02695344a993acb9e7d3cbdce123d9", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2e888d0341e81de1744b257c25b012c2c148f0ba/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e888d0341e81de1744b257c25b012c2c148f0ba/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=2e888d0341e81de1744b257c25b012c2c148f0ba", "patch": "@@ -2840,6 +2840,7 @@ impl<'a> Parser<'a> {\n \n         self.expected_tokens.push(TokenType::Operator);\n \n+        let cur_op_span = self.span;\n         let cur_opt = self.token.to_binop();\n         match cur_opt {\n             Some(cur_op) => {\n@@ -2853,7 +2854,7 @@ impl<'a> Parser<'a> {\n                     let rhs = self.parse_more_binops(expr, cur_prec + 1);\n                     let lhs_span = lhs.span;\n                     let rhs_span = rhs.span;\n-                    let binary = self.mk_binary(cur_op, lhs, rhs);\n+                    let binary = self.mk_binary(codemap::respan(cur_op_span, cur_op), lhs, rhs);\n                     let bin = self.mk_expr(lhs_span.lo, rhs_span.hi, binary);\n                     self.parse_more_binops(bin, min_prec)\n                 } else {\n@@ -2877,14 +2878,14 @@ impl<'a> Parser<'a> {\n     /// Produce an error if comparison operators are chained (RFC #558).\n     /// We only need to check lhs, not rhs, because all comparison ops\n     /// have same precedence and are left-associative\n-    fn check_no_chained_comparison(&mut self, lhs: &Expr, outer_op: ast::BinOp) {\n+    fn check_no_chained_comparison(&mut self, lhs: &Expr, outer_op: ast::BinOp_) {\n         debug_assert!(ast_util::is_comparison_binop(outer_op));\n         match lhs.node {\n-            ExprBinary(op, _, _) if ast_util::is_comparison_binop(op) => {\n+            ExprBinary(op, _, _) if ast_util::is_comparison_binop(op.node) => {\n                 let op_span = self.span;\n                 self.span_err(op_span,\n                     \"Chained comparison operators require parentheses\");\n-                if op == BiLt && outer_op == BiGt {\n+                if op.node == BiLt && outer_op == BiGt {\n                     self.span_help(op_span,\n                         \"use ::< instead of < if you meant to specify type arguments\");\n                 }\n@@ -2919,6 +2920,7 @@ impl<'a> Parser<'a> {\n \n     pub fn parse_assign_expr_with(&mut self, lhs: P<Expr>) -> P<Expr> {\n         let restrictions = self.restrictions & RESTRICTION_NO_STRUCT_LITERAL;\n+        let op_span = self.span;\n         match self.token {\n           token::Eq => {\n               self.bump();\n@@ -2942,7 +2944,7 @@ impl<'a> Parser<'a> {\n               };\n               let rhs_span = rhs.span;\n               let span = lhs.span;\n-              let assign_op = self.mk_assign_op(aop, lhs, rhs);\n+              let assign_op = self.mk_assign_op(codemap::respan(op_span, aop), lhs, rhs);\n               self.mk_expr(span.lo, rhs_span.hi, assign_op)\n           }\n           // A range expression, either `expr..expr` or `expr..`."}, {"sha": "ac694afac6bf729e92f41c1026bfe999b4ce6238", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2e888d0341e81de1744b257c25b012c2c148f0ba/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e888d0341e81de1744b257c25b012c2c148f0ba/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=2e888d0341e81de1744b257c25b012c2c148f0ba", "patch": "@@ -249,7 +249,7 @@ impl Token {\n     }\n \n     /// Maps a token to its corresponding binary operator.\n-    pub fn to_binop(&self) -> Option<ast::BinOp> {\n+    pub fn to_binop(&self) -> Option<ast::BinOp_> {\n         match *self {\n             BinOp(Star)     => Some(ast::BiMul),\n             BinOp(Slash)    => Some(ast::BiDiv),"}, {"sha": "1026f4cb3235d0714af2011152255ad9904cbb1f", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2e888d0341e81de1744b257c25b012c2c148f0ba/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e888d0341e81de1744b257c25b012c2c148f0ba/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=2e888d0341e81de1744b257c25b012c2c148f0ba", "patch": "@@ -1618,7 +1618,7 @@ impl<'a> State<'a> {\n                          rhs: &ast::Expr) -> IoResult<()> {\n         try!(self.print_expr(lhs));\n         try!(space(&mut self.s));\n-        try!(self.word_space(ast_util::binop_to_string(op)));\n+        try!(self.word_space(ast_util::binop_to_string(op.node)));\n         self.print_expr(rhs)\n     }\n \n@@ -1786,7 +1786,7 @@ impl<'a> State<'a> {\n             ast::ExprAssignOp(op, ref lhs, ref rhs) => {\n                 try!(self.print_expr(&**lhs));\n                 try!(space(&mut self.s));\n-                try!(word(&mut self.s, ast_util::binop_to_string(op)));\n+                try!(word(&mut self.s, ast_util::binop_to_string(op.node)));\n                 try!(self.word_space(\"=\"));\n                 try!(self.print_expr(&**rhs));\n             }"}]}