{"sha": "f0afdc35d2cd5e6cdbcf24d89e3fdcc1f9837486", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYwYWZkYzM1ZDJjZDVlNmNkYmNmMjRkODllM2ZkY2MxZjk4Mzc0ODY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-03-28T10:35:11Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-03-28T10:35:11Z"}, "message": "Auto merge of #1263 - RalfJung:shims-limit, r=RalfJung\n\nLimit shims to libstd where possible\n\nAlso organize them better by category.\nFixes https://github.com/rust-lang/miri/issues/1181 (by making mmap not callable from user code)", "tree": {"sha": "a56b705e384bb43682782bfdc62323dc84683b3b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a56b705e384bb43682782bfdc62323dc84683b3b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f0afdc35d2cd5e6cdbcf24d89e3fdcc1f9837486", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f0afdc35d2cd5e6cdbcf24d89e3fdcc1f9837486", "html_url": "https://github.com/rust-lang/rust/commit/f0afdc35d2cd5e6cdbcf24d89e3fdcc1f9837486", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f0afdc35d2cd5e6cdbcf24d89e3fdcc1f9837486/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b67dbca5d0d7c3b9f1d78fd26af41d0182eb7b5c", "url": "https://api.github.com/repos/rust-lang/rust/commits/b67dbca5d0d7c3b9f1d78fd26af41d0182eb7b5c", "html_url": "https://github.com/rust-lang/rust/commit/b67dbca5d0d7c3b9f1d78fd26af41d0182eb7b5c"}, {"sha": "6ab82f5d35d8505f2e65eebeed56d7eeb62d754e", "url": "https://api.github.com/repos/rust-lang/rust/commits/6ab82f5d35d8505f2e65eebeed56d7eeb62d754e", "html_url": "https://github.com/rust-lang/rust/commit/6ab82f5d35d8505f2e65eebeed56d7eeb62d754e"}], "stats": {"total": 394, "additions": 198, "deletions": 196}, "files": [{"sha": "8e379065b07eb68a3fba7f045e35c0dfc17befd6", "filename": "src/helpers.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f0afdc35d2cd5e6cdbcf24d89e3fdcc1f9837486/src%2Fhelpers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0afdc35d2cd5e6cdbcf24d89e3fdcc1f9837486/src%2Fhelpers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fhelpers.rs?ref=f0afdc35d2cd5e6cdbcf24d89e3fdcc1f9837486", "patch": "@@ -81,6 +81,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n     /// Helper function to get a `libc` constant as an `i32`.\n     fn eval_libc_i32(&mut self, name: &str) -> InterpResult<'tcx, i32> {\n+        // TODO: Cache the result.\n         self.eval_libc(name)?.to_i32()\n     }\n "}, {"sha": "c92e338ef7e02b97cb9de348a27d94c77021d162", "filename": "src/shims/foreign_items.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/f0afdc35d2cd5e6cdbcf24d89e3fdcc1f9837486/src%2Fshims%2Fforeign_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0afdc35d2cd5e6cdbcf24d89e3fdcc1f9837486/src%2Fshims%2Fforeign_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fforeign_items.rs?ref=f0afdc35d2cd5e6cdbcf24d89e3fdcc1f9837486", "patch": "@@ -196,6 +196,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         // Here we dispatch all the shims for foreign functions. If you have a platform specific\n         // shim, add it to the corresponding submodule.\n         match link_name {\n+            // Standard C allocation\n             \"malloc\" => {\n                 let size = this.read_scalar(args[0])?.to_machine_usize(this)?;\n                 let res = this.malloc(size, /*zero_init:*/ false, MiriMemoryKind::C);\n@@ -220,6 +221,9 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 this.write_scalar(res, dest)?;\n             }\n \n+            // Rust allocation\n+            // (Usually these would be forwarded to to `#[global_allocator]`; we instead implement a generic\n+            // allocation that also checks that all conditions are met, such as not permitting zero-sized allocations.)\n             \"__rust_alloc\" => {\n                 let size = this.read_scalar(args[0])?.to_machine_usize(this)?;\n                 let align = this.read_scalar(args[1])?.to_machine_usize(this)?;\n@@ -274,6 +278,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 this.write_scalar(new_ptr, dest)?;\n             }\n \n+            // C memory handling functions\n             \"memcmp\" => {\n                 let left = this.read_scalar(args[0])?.not_undef()?;\n                 let right = this.read_scalar(args[1])?.not_undef()?;\n@@ -293,7 +298,6 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n                 this.write_scalar(Scalar::from_int(result, Size::from_bits(32)), dest)?;\n             }\n-\n             \"memrchr\" => {\n                 let ptr = this.read_scalar(args[0])?.not_undef()?;\n                 let val = this.read_scalar(args[1])?.to_i32()? as u8;\n@@ -311,7 +315,6 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                     this.write_null(dest)?;\n                 }\n             }\n-\n             \"memchr\" => {\n                 let ptr = this.read_scalar(args[0])?.not_undef()?;\n                 let val = this.read_scalar(args[1])?.to_i32()? as u8;\n@@ -328,7 +331,6 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                     this.write_null(dest)?;\n                 }\n             }\n-\n             \"strlen\" => {\n                 let ptr = this.read_scalar(args[0])?.not_undef()?;\n                 let n = this.memory.read_c_str(ptr)?.len();\n@@ -358,11 +360,12 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 };\n                 this.write_scalar(Scalar::from_u32(f.to_bits()), dest)?;\n             }\n-            // underscore case for windows\n             | \"_hypotf\"\n             | \"hypotf\"\n             | \"atan2f\"\n             => {\n+                // underscore case for windows, here and below\n+                // (see https://docs.microsoft.com/en-us/cpp/c-runtime-library/reference/floating-point-primitives?view=vs-2019)\n                 // FIXME: Using host floats.\n                 let f1 = f32::from_bits(this.read_scalar(args[0])?.to_u32()?);\n                 let f2 = f32::from_bits(this.read_scalar(args[1])?.to_u32()?);\n@@ -373,7 +376,6 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 };\n                 this.write_scalar(Scalar::from_u32(n.to_bits()), dest)?;\n             }\n-\n             | \"cbrt\"\n             | \"cosh\"\n             | \"sinh\"\n@@ -396,8 +398,6 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 };\n                 this.write_scalar(Scalar::from_u64(f.to_bits()), dest)?;\n             }\n-            // underscore case for windows, here and below\n-            // (see https://docs.microsoft.com/en-us/cpp/c-runtime-library/reference/floating-point-primitives?view=vs-2019)\n             | \"_hypot\"\n             | \"hypot\"\n             | \"atan2\"\n@@ -412,11 +412,11 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 };\n                 this.write_scalar(Scalar::from_u64(n.to_bits()), dest)?;\n             }\n-            // For radix-2 (binary) systems, `ldexp` and `scalbn` are the same.\n             | \"_ldexp\"\n             | \"ldexp\"\n             | \"scalbn\"\n             => {\n+                // For radix-2 (binary) systems, `ldexp` and `scalbn` are the same.\n                 let x = this.read_scalar(args[0])?.to_f64()?;\n                 let exp = this.read_scalar(args[1])?.to_i32()?;\n \n@@ -434,6 +434,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 this.write_scalar(Scalar::from_f64(res), dest)?;\n             }\n \n+            // Target-specific shims\n             _ => match this.tcx.sess.target.target.target_os.as_str() {\n                 \"linux\" | \"macos\" => return posix::EvalContextExt::emulate_foreign_item_by_name(this, link_name, args, dest, ret),\n                 \"windows\" => return windows::EvalContextExt::emulate_foreign_item_by_name(this, link_name, args, dest, ret),"}, {"sha": "ce23bc4c972f6214afddf8f2d3dccfdd07d99088", "filename": "src/shims/foreign_items/posix.rs", "status": "modified", "additions": 53, "deletions": 92, "changes": 145, "blob_url": "https://github.com/rust-lang/rust/blob/f0afdc35d2cd5e6cdbcf24d89e3fdcc1f9837486/src%2Fshims%2Fforeign_items%2Fposix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0afdc35d2cd5e6cdbcf24d89e3fdcc1f9837486/src%2Fshims%2Fforeign_items%2Fposix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fforeign_items%2Fposix.rs?ref=f0afdc35d2cd5e6cdbcf24d89e3fdcc1f9837486", "patch": "@@ -24,22 +24,18 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 let result = this.getenv(args[0])?;\n                 this.write_scalar(result, dest)?;\n             }\n-\n             \"unsetenv\" => {\n                 let result = this.unsetenv(args[0])?;\n                 this.write_scalar(Scalar::from_int(result, dest.layout.size), dest)?;\n             }\n-\n             \"setenv\" => {\n                 let result = this.setenv(args[0], args[1])?;\n                 this.write_scalar(Scalar::from_int(result, dest.layout.size), dest)?;\n             }\n-\n             \"getcwd\" => {\n                 let result = this.getcwd(args[0], args[1])?;\n                 this.write_scalar(result, dest)?;\n             }\n-\n             \"chdir\" => {\n                 let result = this.chdir(args[0])?;\n                 this.write_scalar(Scalar::from_int(result, dest.layout.size), dest)?;\n@@ -50,17 +46,14 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 let result = this.open(args[0], args[1])?;\n                 this.write_scalar(Scalar::from_int(result, dest.layout.size), dest)?;\n             }\n-\n             \"fcntl\" => {\n                 let result = this.fcntl(args[0], args[1], args.get(2).cloned())?;\n                 this.write_scalar(Scalar::from_int(result, dest.layout.size), dest)?;\n             }\n-\n             \"read\" => {\n                 let result = this.read(args[0], args[1], args[2])?;\n                 this.write_scalar(Scalar::from_int(result, dest.layout.size), dest)?;\n             }\n-\n             \"write\" => {\n                 let fd = this.read_scalar(args[0])?.to_i32()?;\n                 let buf = this.read_scalar(args[1])?.not_undef()?;\n@@ -94,43 +87,36 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 // Now, `result` is the value we return back to the program.\n                 this.write_scalar(Scalar::from_int(result, dest.layout.size), dest)?;\n             }\n-\n             \"unlink\" => {\n                 let result = this.unlink(args[0])?;\n                 this.write_scalar(Scalar::from_int(result, dest.layout.size), dest)?;\n             }\n-\n             \"symlink\" => {\n                 let result = this.symlink(args[0], args[1])?;\n                 this.write_scalar(Scalar::from_int(result, dest.layout.size), dest)?;\n             }\n-\n             \"rename\" => {\n                 let result = this.rename(args[0], args[1])?;\n                 this.write_scalar(Scalar::from_int(result, dest.layout.size), dest)?;\n             }\n-\n             \"mkdir\" => {\n                 let result = this.mkdir(args[0], args[1])?;\n                 this.write_scalar(Scalar::from_int(result, dest.layout.size), dest)?;\n             }\n-\n             \"rmdir\" => {\n                 let result = this.rmdir(args[0])?;\n                 this.write_scalar(Scalar::from_int(result, dest.layout.size), dest)?;\n             }\n-\n             \"closedir\" => {\n                 let result = this.closedir(args[0])?;\n                 this.write_scalar(Scalar::from_int(result, dest.layout.size), dest)?;\n             }\n-\n             \"lseek\" | \"lseek64\" => {\n                 let result = this.lseek64(args[0], args[1], args[2])?;\n                 this.write_scalar(Scalar::from_int(result, dest.layout.size), dest)?;\n             }\n \n-            // Other shims\n+            // Allocation\n             \"posix_memalign\" => {\n                 let ret = this.deref_operand(args[0])?;\n                 let align = this.read_scalar(args[1])?.to_machine_usize(this)?;\n@@ -159,6 +145,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 this.write_null(dest)?;\n             }\n \n+            // Dynamic symbol loading\n             \"dlsym\" => {\n                 let _handle = this.read_scalar(args[0])?;\n                 let symbol = this.read_scalar(args[1])?.not_undef()?;\n@@ -173,7 +160,30 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 }\n             }\n \n-            // Hook pthread calls that go to the thread-local storage memory subsystem.\n+            // Querying system information\n+            \"sysconf\" => {\n+                let name = this.read_scalar(args[0])?.to_i32()?;\n+\n+                let sysconfs = &[\n+                    (\"_SC_PAGESIZE\", Scalar::from_int(PAGE_SIZE, dest.layout.size)),\n+                    (\"_SC_NPROCESSORS_ONLN\", Scalar::from_int(NUM_CPUS, dest.layout.size)),\n+                ];\n+                let mut result = None;\n+                for &(sysconf_name, value) in sysconfs {\n+                    let sysconf_name = this.eval_libc_i32(sysconf_name)?;\n+                    if sysconf_name == name {\n+                        result = Some(value);\n+                        break;\n+                    }\n+                }\n+                if let Some(result) = result {\n+                    this.write_scalar(result, dest)?;\n+                } else {\n+                    throw_unsup_format!(\"unimplemented sysconf name: {}\", name)\n+                }\n+            }\n+\n+            // Thread-local storage\n             \"pthread_key_create\" => {\n                 let key_place = this.deref_operand(args[0])?;\n \n@@ -220,36 +230,36 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 this.write_null(dest)?;\n             }\n \n-            // Stack size/address stuff.\n-            | \"pthread_attr_init\"\n-            | \"pthread_attr_destroy\"\n-            | \"pthread_self\"\n-            | \"pthread_attr_setstacksize\" => {\n-                this.write_null(dest)?;\n+            // Better error for attempts to create a thread\n+            \"pthread_create\" => {\n+                throw_unsup_format!(\"Miri does not support threading\");\n             }\n-            \"pthread_attr_getstack\" => {\n-                let addr_place = this.deref_operand(args[1])?;\n-                let size_place = this.deref_operand(args[2])?;\n \n-                this.write_scalar(\n-                    Scalar::from_uint(STACK_ADDR, addr_place.layout.size),\n-                    addr_place.into(),\n-                )?;\n-                this.write_scalar(\n-                    Scalar::from_uint(STACK_SIZE, size_place.layout.size),\n-                    size_place.into(),\n-                )?;\n-\n-                // Return success (`0`).\n+            // Miscellaneous\n+            \"isatty\" => {\n+                let _fd = this.read_scalar(args[0])?.to_i32()?;\n+                // \"returns 1 if fd is an open file descriptor referring to a terminal; otherwise 0 is returned, and errno is set to indicate the error\"\n+                // FIXME: we just say nothing is a terminal.\n+                let enotty = this.eval_libc(\"ENOTTY\")?;\n+                this.set_last_error(enotty)?;\n                 this.write_null(dest)?;\n             }\n-\n-            // We don't support threading.\n-            \"pthread_create\" => {\n-                throw_unsup_format!(\"Miri does not support threading\");\n+            \"pthread_atfork\" => {\n+                let _prepare = this.read_scalar(args[0])?.not_undef()?;\n+                let _parent = this.read_scalar(args[1])?.not_undef()?;\n+                let _child = this.read_scalar(args[1])?.not_undef()?;\n+                // We do not support forking, so there is nothing to do here.\n+                this.write_null(dest)?;\n             }\n \n-            // Stub out calls for condvar, mutex and rwlock, to just return `0`.\n+            // Incomplete shims that we \"stub out\" just to get pre-main initialziation code to work.\n+            // These shims are enabled only when the caller is in the standard library.\n+            | \"pthread_attr_init\"\n+            | \"pthread_attr_destroy\"\n+            | \"pthread_self\"\n+            | \"pthread_attr_setstacksize\" if this.frame().instance.to_string().starts_with(\"std::sys::unix::\") => {\n+                this.write_null(dest)?;\n+            }\n             | \"pthread_mutexattr_init\"\n             | \"pthread_mutexattr_settype\"\n             | \"pthread_mutex_init\"\n@@ -265,68 +275,19 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             | \"pthread_condattr_setclock\"\n             | \"pthread_cond_init\"\n             | \"pthread_condattr_destroy\"\n-            | \"pthread_cond_destroy\"\n+            | \"pthread_cond_destroy\" if this.frame().instance.to_string().starts_with(\"std::sys::unix::\")\n             => {\n                 this.write_null(dest)?;\n             }\n-\n-            // We don't support fork so we don't have to do anything for atfork.\n-            \"pthread_atfork\" => {\n-                this.write_null(dest)?;\n-            }\n-\n-            // Some things needed for `sys::thread` initialization to go through.\n             | \"signal\"\n             | \"sigaction\"\n             | \"sigaltstack\"\n+            | \"mprotect\" if this.frame().instance.to_string().starts_with(\"std::sys::unix::\")\n             => {\n-                this.write_scalar(Scalar::from_int(0, dest.layout.size), dest)?;\n-            }\n-\n-            \"sysconf\" => {\n-                let name = this.read_scalar(args[0])?.to_i32()?;\n-\n-                trace!(\"sysconf() called with name {}\", name);\n-                // TODO: Cache the sysconf integers via Miri's global cache.\n-                let sysconfs = &[\n-                    (\"_SC_PAGESIZE\", Scalar::from_int(PAGE_SIZE, dest.layout.size)),\n-                    (\"_SC_GETPW_R_SIZE_MAX\", Scalar::from_int(-1, dest.layout.size)),\n-                    (\"_SC_NPROCESSORS_ONLN\", Scalar::from_int(NUM_CPUS, dest.layout.size)),\n-                ];\n-                let mut result = None;\n-                for &(sysconf_name, value) in sysconfs {\n-                    let sysconf_name = this.eval_libc_i32(sysconf_name)?;\n-                    if sysconf_name == name {\n-                        result = Some(value);\n-                        break;\n-                    }\n-                }\n-                if let Some(result) = result {\n-                    this.write_scalar(result, dest)?;\n-                } else {\n-                    throw_unsup_format!(\"unimplemented sysconf name: {}\", name)\n-                }\n-            }\n-\n-            \"isatty\" => {\n-                this.write_null(dest)?;\n-            }\n-\n-            \"posix_fadvise\" => {\n-                // fadvise is only informational, we can ignore it.\n-                this.write_null(dest)?;\n-            }\n-\n-            \"mmap\" => {\n-                // This is a horrible hack, but since the guard page mechanism calls mmap and expects a particular return value, we just give it that value.\n-                let addr = this.read_scalar(args[0])?.not_undef()?;\n-                this.write_scalar(addr, dest)?;\n-            }\n-\n-            \"mprotect\" => {\n                 this.write_null(dest)?;\n             }\n \n+            // Platform-specific shims\n             _ => {\n                 match this.tcx.sess.target.target.target_os.as_str() {\n                     \"linux\" => return linux::EvalContextExt::emulate_foreign_item_by_name(this, link_name, args, dest, ret),"}, {"sha": "88a18e3e75f97fc946490ac2a60187e8db0689a2", "filename": "src/shims/foreign_items/posix/linux.rs", "status": "modified", "additions": 46, "deletions": 19, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/f0afdc35d2cd5e6cdbcf24d89e3fdcc1f9837486/src%2Fshims%2Fforeign_items%2Fposix%2Flinux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0afdc35d2cd5e6cdbcf24d89e3fdcc1f9837486/src%2Fshims%2Fforeign_items%2Fposix%2Flinux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fforeign_items%2Fposix%2Flinux.rs?ref=f0afdc35d2cd5e6cdbcf24d89e3fdcc1f9837486", "patch": "@@ -13,47 +13,65 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         let this = self.eval_context_mut();\n \n         match link_name {\n+            // errno\n             \"__errno_location\" => {\n                 let errno_place = this.machine.last_error.unwrap();\n                 this.write_scalar(errno_place.to_ref().to_scalar()?, dest)?;\n             }\n \n             // File related shims (but also see \"syscall\" below for statx)\n-\n-            // The only reason this is not in the `posix` module is because the `macos` item has a\n-            // different name.\n+            // These symbols have different names on Linux and macOS, which is the only reason they are not\n+            // in the `posix` module.\n             \"close\" => {\n                 let result = this.close(args[0])?;\n                 this.write_scalar(Scalar::from_int(result, dest.layout.size), dest)?;\n             }\n-\n-            // The only reason this is not in the `posix` module is because the `macos` item has a\n-            // different name.\n             \"opendir\" => {\n                 let result = this.opendir(args[0])?;\n                 this.write_scalar(result, dest)?;\n             }\n-\n-            // The `macos` module has a parallel foreign item, `readdir_r`, which uses a different\n-            // struct layout.\n             \"readdir64_r\" => {\n                 let result = this.linux_readdir64_r(args[0], args[1], args[2])?;\n                 this.write_scalar(Scalar::from_int(result, dest.layout.size), dest)?;\n             }\n+            // Linux-only\n+            \"posix_fadvise\" => {\n+                let _fd = this.read_scalar(args[0])?.to_i32()?;\n+                let _offset = this.read_scalar(args[1])?.to_machine_isize(this)?;\n+                let _len = this.read_scalar(args[2])?.to_machine_isize(this)?;\n+                let _advice = this.read_scalar(args[3])?.to_i32()?;\n+                // fadvise is only informational, we can ignore it.\n+                this.write_null(dest)?;\n+            }\n \n             // Time related shims\n-\n-            // This is a POSIX function but it has only been tested on linux.\n             \"clock_gettime\" => {\n+                // This is a POSIX function but it has only been tested on linux.\n                 let result = this.clock_gettime(args[0], args[1])?;\n                 this.write_scalar(Scalar::from_int(result, dest.layout.size), dest)?;\n             }\n \n-            // Other shims\n-            \"pthread_getattr_np\" => {\n+            // Querying system information\n+            \"pthread_attr_getstack\" => {\n+                // We don't support \"pthread_attr_setstack\", so we just pretend all stacks have the same values here.\n+                let _attr_place = this.deref_operand(args[0])?;\n+                let addr_place = this.deref_operand(args[1])?;\n+                let size_place = this.deref_operand(args[2])?;\n+\n+                this.write_scalar(\n+                    Scalar::from_uint(STACK_ADDR, addr_place.layout.size),\n+                    addr_place.into(),\n+                )?;\n+                this.write_scalar(\n+                    Scalar::from_uint(STACK_SIZE, size_place.layout.size),\n+                    size_place.into(),\n+                )?;\n+\n+                // Return success (`0`).\n                 this.write_null(dest)?;\n             }\n \n+            // Dynamically invoked syscalls\n             \"syscall\" => {\n                 let sys_getrandom = this\n                     .eval_libc(\"SYS_getrandom\")?\n@@ -67,31 +85,40 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                     // `libc::syscall(NR_GETRANDOM, buf.as_mut_ptr(), buf.len(), GRND_NONBLOCK)`\n                     // is called if a `HashMap` is created the regular way (e.g. HashMap<K, V>).\n                     id if id == sys_getrandom => {\n-                        // The first argument is the syscall id,\n-                        // so skip over it.\n+                        // The first argument is the syscall id, so skip over it.\n                         getrandom(this, &args[1..], dest)?;\n                     }\n                     // `statx` is used by `libstd` to retrieve metadata information on `linux`\n                     // instead of using `stat`,`lstat` or `fstat` as on `macos`.\n                     id if id == sys_statx => {\n-                        // The first argument is the syscall id,\n-                        // so skip over it.\n+                        // The first argument is the syscall id, so skip over it.\n                         let result = this.linux_statx(args[1], args[2], args[3], args[4], args[5])?;\n                         this.write_scalar(Scalar::from_int(result, dest.layout.size), dest)?;\n                     }\n                     id => throw_unsup_format!(\"miri does not support syscall ID {}\", id),\n                 }\n             }\n \n+            // Miscelanneous\n             \"getrandom\" => {\n                 getrandom(this, args, dest)?;\n             }\n-\n             \"sched_getaffinity\" => {\n-                // Return an error; `num_cpus` then falls back to `sysconf`.\n+                let _pid = this.read_scalar(args[0])?.to_i32()?;\n+                let _cpusetsize = this.read_scalar(args[1])?.to_machine_usize(this)?;\n+                let _mask = this.deref_operand(args[2])?;\n+                // FIXME: we just return an error; `num_cpus` then falls back to `sysconf`.\n+                let einval = this.eval_libc(\"EINVAL\")?;\n+                this.set_last_error(einval)?;\n                 this.write_scalar(Scalar::from_int(-1, dest.layout.size), dest)?;\n             }\n \n+            // Incomplete shims that we \"stub out\" just to get pre-main initialziation code to work.\n+            // These shims are enabled only when the caller is in the standard library.\n+            \"pthread_getattr_np\" if this.frame().instance.to_string().starts_with(\"std::sys::unix::\") => {\n+                this.write_null(dest)?;\n+            }\n+\n             _ => throw_unsup_format!(\"can't call foreign function: {}\", link_name),\n         };\n "}, {"sha": "2261b1c4cfb978aa1031abaee876e5f0925b8451", "filename": "src/shims/foreign_items/posix/macos.rs", "status": "modified", "additions": 23, "deletions": 28, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/f0afdc35d2cd5e6cdbcf24d89e3fdcc1f9837486/src%2Fshims%2Fforeign_items%2Fposix%2Fmacos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0afdc35d2cd5e6cdbcf24d89e3fdcc1f9837486/src%2Fshims%2Fforeign_items%2Fposix%2Fmacos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fforeign_items%2Fposix%2Fmacos.rs?ref=f0afdc35d2cd5e6cdbcf24d89e3fdcc1f9837486", "patch": "@@ -13,44 +13,33 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         let this = self.eval_context_mut();\n \n         match link_name {\n+            // errno\n             \"__error\" => {\n                 let errno_place = this.machine.last_error.unwrap();\n                 this.write_scalar(errno_place.to_ref().to_scalar()?, dest)?;\n             }\n \n             // File related shims\n-\n-            // The only reason this is not in the `posix` module is because the `linux` item has a\n-            // different name.\n             \"close$NOCANCEL\" => {\n                 let result = this.close(args[0])?;\n                 this.write_scalar(Scalar::from_int(result, dest.layout.size), dest)?;\n             }\n-\n             \"stat$INODE64\" => {\n                 let result = this.macos_stat(args[0], args[1])?;\n                 this.write_scalar(Scalar::from_int(result, dest.layout.size), dest)?;\n             }\n-\n             \"lstat$INODE64\" => {\n                 let result = this.macos_lstat(args[0], args[1])?;\n                 this.write_scalar(Scalar::from_int(result, dest.layout.size), dest)?;\n             }\n-\n             \"fstat$INODE64\" => {\n                 let result = this.macos_fstat(args[0], args[1])?;\n                 this.write_scalar(Scalar::from_int(result, dest.layout.size), dest)?;\n             }\n-\n-            // The only reason this is not in the `posix` module is because the `linux` item has a\n-            // different name.\n             \"opendir$INODE64\" => {\n                 let result = this.opendir(args[0])?;\n                 this.write_scalar(result, dest)?;\n             }\n-\n-            // The `linux` module has a parallel foreign item, `readdir64_r`, which uses a\n-            // different struct layout.\n             \"readdir_r$INODE64\" => {\n                 let result = this.macos_readdir_r(args[0], args[1], args[2])?;\n                 this.write_scalar(Scalar::from_int(result, dest.layout.size), dest)?;\n@@ -71,34 +60,40 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 this.write_scalar(Scalar::from_uint(result, dest.layout.size), dest)?;\n             }\n \n-            // Other shims\n-            \"pthread_attr_get_np\" => {\n-                this.write_null(dest)?;\n-            }\n-\n-            \"pthread_get_stackaddr_np\" => {\n-                let stack_addr = Scalar::from_uint(STACK_ADDR, dest.layout.size);\n-                this.write_scalar(stack_addr, dest)?;\n+            // Access to command-line arguments\n+            \"_NSGetArgc\" => {\n+                this.write_scalar(this.machine.argc.expect(\"machine must be initialized\"), dest)?;\n             }\n-\n-            \"pthread_get_stacksize_np\" => {\n-                let stack_size = Scalar::from_uint(STACK_SIZE, dest.layout.size);\n-                this.write_scalar(stack_size, dest)?;\n+            \"_NSGetArgv\" => {\n+                this.write_scalar(this.machine.argv.expect(\"machine must be initialized\"), dest)?;\n             }\n \n+            // Thread-local storage\n             \"_tlv_atexit\" => {\n                 let dtor = this.read_scalar(args[0])?.not_undef()?;\n                 let dtor = this.memory.get_fn(dtor)?.as_instance()?;\n                 let data = this.read_scalar(args[1])?.not_undef()?;\n                 this.machine.tls.set_global_dtor(dtor, data)?;\n             }\n \n-            \"_NSGetArgc\" => {\n-                this.write_scalar(this.machine.argc.expect(\"machine must be initialized\"), dest)?;\n+            // Querying system information\n+            \"pthread_get_stackaddr_np\" => {\n+                let _thread = this.read_scalar(args[0])?.not_undef()?;\n+                let stack_addr = Scalar::from_uint(STACK_ADDR, dest.layout.size);\n+                this.write_scalar(stack_addr, dest)?;\n+            }\n+            \"pthread_get_stacksize_np\" => {\n+                let _thread = this.read_scalar(args[0])?.not_undef()?;\n+                let stack_size = Scalar::from_uint(STACK_SIZE, dest.layout.size);\n+                this.write_scalar(stack_size, dest)?;\n             }\n \n-            \"_NSGetArgv\" => {\n-                this.write_scalar(this.machine.argv.expect(\"machine must be initialized\"), dest)?;\n+            // Incomplete shims that we \"stub out\" just to get pre-main initialziation code to work.\n+            // These shims are enabled only when the caller is in the standard library.\n+            \"mmap\" if this.frame().instance.to_string().starts_with(\"std::sys::unix::\") => {\n+                // This is a horrible hack, but since the guard page mechanism calls mmap and expects a particular return value, we just give it that value.\n+                let addr = this.read_scalar(args[0])?.not_undef()?;\n+                this.write_scalar(addr, dest)?;\n             }\n \n             _ => throw_unsup_format!(\"can't call foreign function: {}\", link_name),"}, {"sha": "9a626fe75e03e36f3080053800e369826cd91b4c", "filename": "src/shims/foreign_items/windows.rs", "status": "modified", "additions": 66, "deletions": 49, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/f0afdc35d2cd5e6cdbcf24d89e3fdcc1f9837486/src%2Fshims%2Fforeign_items%2Fwindows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0afdc35d2cd5e6cdbcf24d89e3fdcc1f9837486/src%2Fshims%2Fforeign_items%2Fwindows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fforeign_items%2Fwindows.rs?ref=f0afdc35d2cd5e6cdbcf24d89e3fdcc1f9837486", "patch": "@@ -14,12 +14,11 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     ) -> InterpResult<'tcx, bool> {\n         let this = self.eval_context_mut();\n \n+        // Windows API stubs.\n+        // HANDLE = isize\n+        // DWORD = ULONG = u32\n+        // BOOL = i32\n         match link_name {\n-            // Windows API stubs.\n-            // HANDLE = isize\n-            // DWORD = ULONG = u32\n-            // BOOL = i32\n-\n             // Environment related shims\n             \"GetEnvironmentVariableW\" => {\n                 let result = this.GetEnvironmentVariableW(args[0], args[1], args[2])?;\n@@ -42,6 +41,12 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             }\n \n             // File related shims\n+            \"GetStdHandle\" => {\n+                let which = this.read_scalar(args[0])?.to_i32()?;\n+                // We just make this the identity function, so we know later in `WriteFile`\n+                // which one it is.\n+                this.write_scalar(Scalar::from_int(which, this.pointer_size()), dest)?;\n+            }\n             \"WriteFile\" => {\n                 let handle = this.read_scalar(args[0])?.to_machine_isize(this)?;\n                 let buf = this.read_scalar(args[1])?.not_undef()?;\n@@ -61,9 +66,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                     };\n                     res.ok().map(|n| n as u32)\n                 } else {\n-                    eprintln!(\"Miri: Ignored output to handle {}\", handle);\n-                    // Pretend it all went well.\n-                    Some(n)\n+                    throw_unsup_format!(\"on Windows, writing to anything except stdout/stderr is not supported\")\n                 };\n                 // If there was no error, write back how much was written.\n                 if let Some(n) = written {\n@@ -76,11 +79,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 )?;\n             }\n \n-            // Other shims\n-            \"GetProcessHeap\" => {\n-                // Just fake a HANDLE\n-                this.write_scalar(Scalar::from_int(1, this.pointer_size()), dest)?;\n-            }\n+            // Allocation\n             \"HeapAlloc\" => {\n                 let _handle = this.read_scalar(args[0])?.to_machine_isize(this)?;\n                 let flags = this.read_scalar(args[1])?.to_u32()?;\n@@ -105,6 +104,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 this.write_scalar(res, dest)?;\n             }\n \n+            // errno\n             \"SetLastError\" => {\n                 this.set_last_error(this.read_scalar(args[0])?.not_undef()?)?;\n             }\n@@ -113,30 +113,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 this.write_scalar(last_error, dest)?;\n             }\n \n-            \"AddVectoredExceptionHandler\" => {\n-                // Any non zero value works for the stdlib. This is just used for stack overflows anyway.\n-                this.write_scalar(Scalar::from_int(1, dest.layout.size), dest)?;\n-            }\n-\n-            | \"InitializeCriticalSection\"\n-            | \"EnterCriticalSection\"\n-            | \"LeaveCriticalSection\"\n-            | \"DeleteCriticalSection\"\n-            => {\n-                // Nothing to do, not even a return value.\n-                // (Windows locks are reentrant, and we have only 1 thread,\n-                // so not doing any futher checks here is at least not incorrect.)\n-            }\n-\n-            | \"GetModuleHandleW\"\n-            | \"GetProcAddress\"\n-            | \"GetConsoleScreenBufferInfo\"\n-            | \"SetConsoleTextAttribute\"\n-            => {\n-                // Pretend these do not exist / nothing happened, by returning zero.\n-                this.write_null(dest)?;\n-            }\n-\n+            // Querying system information\n             \"GetSystemInfo\" => {\n                 let system_info = this.deref_operand(args[0])?;\n                 // Initialize with `0`.\n@@ -150,6 +127,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 this.write_scalar(Scalar::from_int(NUM_CPUS, dword_size), num_cpus.into())?;\n             }\n \n+            // Thread-local storage\n             \"TlsAlloc\" => {\n                 // This just creates a key; Windows does not natively support TLS destructors.\n \n@@ -170,33 +148,72 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 // Return success (`1`).\n                 this.write_scalar(Scalar::from_int(1, dest.layout.size), dest)?;\n             }\n-            \"GetStdHandle\" => {\n-                let which = this.read_scalar(args[0])?.to_i32()?;\n-                // We just make this the identity function, so we know later in `WriteFile`\n-                // which one it is.\n-                this.write_scalar(Scalar::from_int(which, this.pointer_size()), dest)?;\n-            }\n-            \"GetConsoleMode\" => {\n-                // Everything is a pipe.\n-                this.write_null(dest)?;\n-            }\n+\n+            // Access to command-line arguments\n             \"GetCommandLineW\" => {\n                 this.write_scalar(\n                     this.machine.cmd_line.expect(\"machine must be initialized\"),\n                     dest,\n                 )?;\n             }\n-            // The actual name of 'RtlGenRandom'\n+\n+            // Miscellaneous\n             \"SystemFunction036\" => {\n+                // The actual name of 'RtlGenRandom'\n                 let ptr = this.read_scalar(args[0])?.not_undef()?;\n                 let len = this.read_scalar(args[1])?.to_u32()?;\n                 this.gen_random(ptr, len.into())?;\n                 this.write_scalar(Scalar::from_bool(true), dest)?;\n             }\n-            // We don't support threading.\n+            \"GetConsoleScreenBufferInfo\" => {\n+                // `term` needs this, so we fake it.\n+                let _console = this.read_scalar(args[0])?.to_machine_isize(this)?;\n+                let _buffer_info = this.deref_operand(args[1])?;\n+                // Indicate an error.\n+                // FIXME: we should set last_error, but to what?\n+                this.write_null(dest)?;\n+            }\n+            \"GetConsoleMode\" => {\n+                // Windows \"isatty\" (in libtest) needs this, so we fake it.\n+                let _console = this.read_scalar(args[0])?.to_machine_isize(this)?;\n+                let _mode = this.deref_operand(args[1])?;\n+                // Indicate an error.\n+                // FIXME: we should set last_error, but to what?\n+                this.write_null(dest)?;\n+            }\n+\n+            // Better error for attempts to create a thread\n             \"CreateThread\" => {\n                 throw_unsup_format!(\"Miri does not support threading\");\n             }\n+\n+            // Incomplete shims that we \"stub out\" just to get pre-main initialziation code to work.\n+            // These shims are enabled only when the caller is in the standard library.\n+            \"GetProcessHeap\" if this.frame().instance.to_string().starts_with(\"std::sys::windows::\") => {\n+                // Just fake a HANDLE\n+                this.write_scalar(Scalar::from_int(1, this.pointer_size()), dest)?;\n+            }\n+            | \"GetModuleHandleW\"\n+            | \"GetProcAddress\"\n+            | \"SetConsoleTextAttribute\" if this.frame().instance.to_string().starts_with(\"std::sys::windows::\")\n+            => {\n+                // Pretend these do not exist / nothing happened, by returning zero.\n+                this.write_null(dest)?;\n+            }\n+            \"AddVectoredExceptionHandler\" if this.frame().instance.to_string().starts_with(\"std::sys::windows::\") => {\n+                // Any non zero value works for the stdlib. This is just used for stack overflows anyway.\n+                this.write_scalar(Scalar::from_int(1, dest.layout.size), dest)?;\n+            }\n+            | \"InitializeCriticalSection\"\n+            | \"EnterCriticalSection\"\n+            | \"LeaveCriticalSection\"\n+            | \"DeleteCriticalSection\" if this.frame().instance.to_string().starts_with(\"std::sys::windows::\")\n+            => {\n+                // Nothing to do, not even a return value.\n+                // (Windows locks are reentrant, and we have only 1 thread,\n+                // so not doing any futher checks here is at least not incorrect.)\n+            }\n+\n             _ => throw_unsup_format!(\"can't call foreign function: {}\", link_name),\n         }\n "}]}