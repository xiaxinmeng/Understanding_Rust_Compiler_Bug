{"sha": "fab2532ef949a08e16b621259a91d1ff37165665", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZhYjI1MzJlZjk0OWEwOGUxNmI2MjEyNTlhOTFkMWZmMzcxNjU2NjU=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-04-25T11:39:00Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-11-17T16:25:31Z"}, "message": "rustc_trans: move const & lvalue access helpers from adt.", "tree": {"sha": "dfe68e812b7696dbf81d0b61174a423d0f5972d9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dfe68e812b7696dbf81d0b61174a423d0f5972d9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fab2532ef949a08e16b621259a91d1ff37165665", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fab2532ef949a08e16b621259a91d1ff37165665", "html_url": "https://github.com/rust-lang/rust/commit/fab2532ef949a08e16b621259a91d1ff37165665", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fab2532ef949a08e16b621259a91d1ff37165665/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "aabfed5e0c84211005c1cb2ecec2206a574a5146", "url": "https://api.github.com/repos/rust-lang/rust/commits/aabfed5e0c84211005c1cb2ecec2206a574a5146", "html_url": "https://github.com/rust-lang/rust/commit/aabfed5e0c84211005c1cb2ecec2206a574a5146"}], "stats": {"total": 580, "additions": 251, "deletions": 329}, "files": [{"sha": "cdf66a0835df07879038de2cb784ccd97421f6ed", "filename": "src/librustc_trans/adt.rs", "status": "modified", "additions": 60, "deletions": 241, "changes": 301, "blob_url": "https://github.com/rust-lang/rust/blob/fab2532ef949a08e16b621259a91d1ff37165665/src%2Flibrustc_trans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fab2532ef949a08e16b621259a91d1ff37165665/src%2Flibrustc_trans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fadt.rs?ref=fab2532ef949a08e16b621259a91d1ff37165665", "patch": "@@ -41,52 +41,15 @@\n //!   used unboxed and any field can have pointers (including mutable)\n //!   taken to it, implementing them for Rust seems difficult.\n \n-use std;\n-\n-use llvm::{ValueRef, True, IntEQ, IntNE};\n use rustc::ty::{self, Ty};\n use rustc::ty::layout::{self, LayoutTyper};\n-use common::*;\n-use builder::Builder;\n-use base;\n+\n+use context::CrateContext;\n use machine;\n use monomorphize;\n use type_::Type;\n use type_of;\n \n-use mir::lvalue::Alignment;\n-\n-/// Given an enum, struct, closure, or tuple, extracts fields.\n-/// Treats closures as a struct with one variant.\n-/// `empty_if_no_variants` is a switch to deal with empty enums.\n-/// If true, `variant_index` is disregarded and an empty Vec returned in this case.\n-pub fn compute_fields<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>,\n-                                variant_index: usize,\n-                                empty_if_no_variants: bool) -> Vec<Ty<'tcx>> {\n-    match t.sty {\n-        ty::TyAdt(ref def, _) if def.variants.len() == 0 && empty_if_no_variants => {\n-            Vec::default()\n-        },\n-        ty::TyAdt(ref def, ref substs) => {\n-            def.variants[variant_index].fields.iter().map(|f| {\n-                monomorphize::field_ty(cx.tcx(), substs, f)\n-            }).collect::<Vec<_>>()\n-        },\n-        ty::TyTuple(fields, _) => fields.to_vec(),\n-        ty::TyClosure(def_id, substs) => {\n-            if variant_index > 0 { bug!(\"{} is a closure, which only has one variant\", t);}\n-            substs.upvar_tys(def_id, cx.tcx()).collect()\n-        },\n-        ty::TyGenerator(def_id, substs, _) => {\n-            if variant_index > 0 { bug!(\"{} is a generator, which only has one variant\", t);}\n-            substs.field_tys(def_id, cx.tcx()).map(|t| {\n-                cx.tcx().fully_normalize_associated_types_in(&t)\n-            }).collect()\n-        },\n-        _ => bug!(\"{} is not a type that can have fields.\", t)\n-    }\n-}\n-\n /// LLVM-level types are a little complicated.\n ///\n /// C-like enums need to be actual ints, not wrapped in a struct,\n@@ -119,8 +82,8 @@ pub fn finish_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                     (nndiscr, nonnull, nonnull.packed),\n                 _ => unreachable!()\n             };\n-            let fields = compute_fields(cx, t, nonnull_variant_index as usize, true);\n-            llty.set_struct_body(&struct_llfields(cx, &fields, nonnull_variant),\n+            llty.set_struct_body(&struct_llfields(cx, t, nonnull_variant_index as usize,\n+                                                  nonnull_variant, None),\n                                  packed)\n         },\n         _ => bug!(\"This function cannot handle {} with layout {:#?}\", t, l)\n@@ -148,10 +111,9 @@ fn generic_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             }\n         }\n         layout::StructWrappedNullablePointer { nndiscr, ref nonnull, .. } => {\n-            let fields = compute_fields(cx, t, nndiscr as usize, false);\n             match name {\n                 None => {\n-                    Type::struct_(cx, &struct_llfields(cx, &fields, nonnull),\n+                    Type::struct_(cx, &struct_llfields(cx, t, nndiscr as usize, nonnull, None),\n                                   nonnull.packed)\n                 }\n                 Some(name) => {\n@@ -160,17 +122,12 @@ fn generic_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             }\n         }\n         layout::Univariant { ref variant, .. } => {\n-            // Note that this case also handles empty enums.\n-            // Thus the true as the final parameter here.\n-            let fields = compute_fields(cx, t, 0, true);\n             match name {\n                 None => {\n-                    let fields = struct_llfields(cx, &fields, &variant);\n-                    Type::struct_(cx, &fields, variant.packed)\n+                    Type::struct_(cx, &struct_llfields(cx, t, 0, &variant, None),\n+                                  variant.packed)\n                 }\n                 Some(name) => {\n-                    // Hypothesis: named_struct's can never need a\n-                    // drop flag. (... needs validation.)\n                     Type::named_struct(cx, name)\n                 }\n             }\n@@ -205,7 +162,7 @@ fn generic_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             let size = size.bytes();\n             let align = align.abi();\n             let primitive_align = primitive_align.abi();\n-            assert!(align <= std::u32::MAX as u64);\n+            assert!(align <= ::std::u32::MAX as u64);\n             let discr_ty = Type::from_integer(cx, discr);\n             let discr_size = discr.size().bytes();\n             let padded_discr_size = roundup(discr_size, align as u32);\n@@ -246,46 +203,82 @@ fn union_fill(cx: &CrateContext, size: u64, align: u64) -> Type {\n     }\n }\n \n-\n-// Double index to account for padding (FieldPath already uses `Struct::memory_index`)\n-fn struct_llfields_path(discrfield: &layout::FieldPath) -> Vec<usize> {\n-    discrfield.iter().map(|&i| (i as usize) << 1).collect::<Vec<_>>()\n-}\n-\n-\n // Lookup `Struct::memory_index` and double it to account for padding\n pub fn struct_llfields_index(variant: &layout::Struct, index: usize) -> usize {\n     (variant.memory_index[index] as usize) << 1\n }\n \n-\n-pub fn struct_llfields<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, field_tys: &Vec<Ty<'tcx>>,\n-                             variant: &layout::Struct) -> Vec<Type> {\n+pub fn struct_llfields<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n+                                 t: Ty<'tcx>,\n+                                 variant_index: usize,\n+                                 variant: &layout::Struct,\n+                                 discr: Option<Ty<'tcx>>) -> Vec<Type> {\n+    let field_count = match t.sty {\n+        ty::TyAdt(ref def, _) if def.variants.len() == 0 => return vec![],\n+        ty::TyAdt(ref def, _) => {\n+            discr.is_some() as usize + def.variants[variant_index].fields.len()\n+        },\n+        ty::TyTuple(fields, _) => fields.len(),\n+        ty::TyClosure(def_id, substs) => {\n+            if variant_index > 0 { bug!(\"{} is a closure, which only has one variant\", t);}\n+            substs.upvar_tys(def_id, cx.tcx()).count()\n+        },\n+        ty::TyGenerator(def_id, substs, _) => {\n+            if variant_index > 0 { bug!(\"{} is a generator, which only has one variant\", t);}\n+            substs.field_tys(def_id, cx.tcx()).count()\n+        },\n+        _ => bug!(\"{} is not a type that can have fields.\", t)\n+    };\n     debug!(\"struct_llfields: variant: {:?}\", variant);\n     let mut first_field = true;\n     let mut min_offset = 0;\n-    let mut result: Vec<Type> = Vec::with_capacity(field_tys.len() * 2);\n+    let mut result: Vec<Type> = Vec::with_capacity(field_count * 2);\n     let field_iter = variant.field_index_by_increasing_offset().map(|i| {\n-        (i, field_tys[i as usize], variant.offsets[i as usize].bytes()) });\n+        (i, match t.sty {\n+            ty::TyAdt(..) if i == 0 && discr.is_some() => discr.unwrap(),\n+            ty::TyAdt(ref def, ref substs) => {\n+                monomorphize::field_ty(cx.tcx(), substs,\n+                    &def.variants[variant_index].fields[i as usize - discr.is_some() as usize])\n+            },\n+            ty::TyTuple(fields, _) => fields[i as usize],\n+            ty::TyClosure(def_id, substs) => {\n+                substs.upvar_tys(def_id, cx.tcx()).nth(i).unwrap()\n+            },\n+            ty::TyGenerator(def_id, substs, _) => {\n+                let ty = substs.field_tys(def_id, cx.tcx()).nth(i).unwrap();\n+                cx.tcx().normalize_associated_type(&ty)\n+            },\n+            _ => bug!()\n+        }, variant.offsets[i as usize].bytes())\n+    });\n     for (index, ty, target_offset) in field_iter {\n+        assert!(target_offset >= min_offset);\n+        let padding_bytes = target_offset - min_offset;\n         if first_field {\n             debug!(\"struct_llfields: {} ty: {} min_offset: {} target_offset: {}\",\n                 index, ty, min_offset, target_offset);\n+            assert_eq!(padding_bytes, 0);\n             first_field = false;\n         } else {\n-            assert!(target_offset >= min_offset);\n-            let padding_bytes = if variant.packed { 0 } else { target_offset - min_offset };\n             result.push(Type::array(&Type::i8(cx), padding_bytes));\n             debug!(\"struct_llfields: {} ty: {} pad_bytes: {} min_offset: {} target_offset: {}\",\n                 index, ty, padding_bytes, min_offset, target_offset);\n         }\n         let llty = type_of::in_memory_type_of(cx, ty);\n         result.push(llty);\n         let layout = cx.layout_of(ty);\n+        if variant.packed {\n+            assert_eq!(padding_bytes, 0);\n+        } else {\n+            let field_align = layout.align(cx);\n+            assert!(field_align.abi() <= variant.align.abi(),\n+                    \"non-packed type has field with larger align ({}): {:#?}\",\n+                    field_align.abi(), variant);\n+        }\n         let target_size = layout.size(&cx.tcx().data_layout).bytes();\n         min_offset = target_offset + target_size;\n     }\n-    if variant.sized && !field_tys.is_empty() {\n+    if variant.sized && field_count > 0 {\n         if variant.stride().bytes() < min_offset {\n             bug!(\"variant: {:?} stride: {} min_offset: {}\", variant, variant.stride().bytes(),\n             min_offset);\n@@ -294,7 +287,7 @@ pub fn struct_llfields<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, field_tys: &Vec<Ty\n         debug!(\"struct_llfields: pad_bytes: {} min_offset: {} min_size: {} stride: {}\\n\",\n                padding_bytes, min_offset, variant.min_size.bytes(), variant.stride().bytes());\n         result.push(Type::array(&Type::i8(cx), padding_bytes));\n-        assert!(result.len() == (field_tys.len() * 2));\n+        assert!(result.len() == (field_count * 2));\n     } else {\n         debug!(\"struct_llfields: min_offset: {} min_size: {} stride: {}\\n\",\n                min_offset, variant.min_size.bytes(), variant.stride().bytes());\n@@ -310,138 +303,6 @@ pub fn is_discr_signed<'tcx>(l: &layout::Layout) -> bool {\n     }\n }\n \n-/// Obtain the actual discriminant of a value.\n-pub fn trans_get_discr<'a, 'tcx>(\n-    bcx: &Builder<'a, 'tcx>,\n-    t: Ty<'tcx>,\n-    scrutinee: ValueRef,\n-    alignment: Alignment,\n-    cast_to: Option<Type>,\n-    range_assert: bool\n-) -> ValueRef {\n-    debug!(\"trans_get_discr t: {:?}\", t);\n-    let l = bcx.ccx.layout_of(t);\n-\n-    let val = match *l {\n-        layout::CEnum { discr, min, max, .. } => {\n-            load_discr(bcx, discr, scrutinee, alignment, min, max, range_assert)\n-        }\n-        layout::General { discr, ref variants, .. } => {\n-            let ptr = bcx.struct_gep(scrutinee, 0);\n-            load_discr(bcx, discr, ptr, alignment,\n-                       0, variants.len() as u64 - 1,\n-                       range_assert)\n-        }\n-        layout::Univariant { .. } | layout::UntaggedUnion { .. } => C_u8(bcx.ccx, 0),\n-        layout::RawNullablePointer { nndiscr, .. } => {\n-            let cmp = if nndiscr == 0 { IntEQ } else { IntNE };\n-            let discr = bcx.load(scrutinee, alignment.to_align());\n-            bcx.icmp(cmp, discr, C_null(val_ty(discr)))\n-        }\n-        layout::StructWrappedNullablePointer { nndiscr, ref discrfield, .. } => {\n-            struct_wrapped_nullable_bitdiscr(bcx, nndiscr, discrfield, scrutinee, alignment)\n-        },\n-        _ => bug!(\"{} is not an enum\", t)\n-    };\n-    match cast_to {\n-        None => val,\n-        Some(llty) => bcx.intcast(val, llty, is_discr_signed(&l))\n-    }\n-}\n-\n-fn struct_wrapped_nullable_bitdiscr(\n-    bcx: &Builder,\n-    nndiscr: u64,\n-    discrfield: &layout::FieldPath,\n-    scrutinee: ValueRef,\n-    alignment: Alignment,\n-) -> ValueRef {\n-    let path = struct_llfields_path(discrfield);\n-    let llptrptr = bcx.gepi(scrutinee, &path);\n-    let llptr = bcx.load(llptrptr, alignment.to_align());\n-    let cmp = if nndiscr == 0 { IntEQ } else { IntNE };\n-    bcx.icmp(cmp, llptr, C_null(val_ty(llptr)))\n-}\n-\n-/// Helper for cases where the discriminant is simply loaded.\n-fn load_discr(bcx: &Builder, ity: layout::Integer, ptr: ValueRef,\n-              alignment: Alignment, min: u64, max: u64,\n-              range_assert: bool)\n-    -> ValueRef {\n-    let llty = Type::from_integer(bcx.ccx, ity);\n-    assert_eq!(val_ty(ptr), llty.ptr_to());\n-    let bits = ity.size().bits();\n-    assert!(bits <= 64);\n-    let bits = bits as usize;\n-    let mask = !0u64 >> (64 - bits);\n-    // For a (max) discr of -1, max will be `-1 as usize`, which overflows.\n-    // However, that is fine here (it would still represent the full range),\n-    if max.wrapping_add(1) & mask == min & mask || !range_assert {\n-        // i.e., if the range is everything.  The lo==hi case would be\n-        // rejected by the LLVM verifier (it would mean either an\n-        // empty set, which is impossible, or the entire range of the\n-        // type, which is pointless).\n-        bcx.load(ptr, alignment.to_align())\n-    } else {\n-        // llvm::ConstantRange can deal with ranges that wrap around,\n-        // so an overflow on (max + 1) is fine.\n-        bcx.load_range_assert(ptr, min, max.wrapping_add(1), /* signed: */ True,\n-                              alignment.to_align())\n-    }\n-}\n-\n-/// Set the discriminant for a new value of the given case of the given\n-/// representation.\n-pub fn trans_set_discr<'a, 'tcx>(bcx: &Builder<'a, 'tcx>, t: Ty<'tcx>, val: ValueRef, to: u64) {\n-    let l = bcx.ccx.layout_of(t);\n-    match *l {\n-        layout::CEnum{ discr, min, max, .. } => {\n-            assert_discr_in_range(min, max, to);\n-            bcx.store(C_int(Type::from_integer(bcx.ccx, discr), to as i64),\n-                  val, None);\n-        }\n-        layout::General{ discr, .. } => {\n-            bcx.store(C_int(Type::from_integer(bcx.ccx, discr), to as i64),\n-                  bcx.struct_gep(val, 0), None);\n-        }\n-        layout::Univariant { .. }\n-        | layout::UntaggedUnion { .. }\n-        | layout::Vector { .. } => {\n-            assert_eq!(to, 0);\n-        }\n-        layout::RawNullablePointer { nndiscr, .. } => {\n-            if to != nndiscr {\n-                let llptrty = val_ty(val).element_type();\n-                bcx.store(C_null(llptrty), val, None);\n-            }\n-        }\n-        layout::StructWrappedNullablePointer { nndiscr, ref discrfield, ref nonnull, .. } => {\n-            if to != nndiscr {\n-                if target_sets_discr_via_memset(bcx) {\n-                    // Issue #34427: As workaround for LLVM bug on\n-                    // ARM, use memset of 0 on whole struct rather\n-                    // than storing null to single target field.\n-                    let llptr = bcx.pointercast(val, Type::i8(bcx.ccx).ptr_to());\n-                    let fill_byte = C_u8(bcx.ccx, 0);\n-                    let size = C_usize(bcx.ccx, nonnull.stride().bytes());\n-                    let align = C_i32(bcx.ccx, nonnull.align.abi() as i32);\n-                    base::call_memset(bcx, llptr, fill_byte, size, align, false);\n-                } else {\n-                    let path = struct_llfields_path(discrfield);\n-                    let llptrptr = bcx.gepi(val, &path);\n-                    let llptrty = val_ty(llptrptr).element_type();\n-                    bcx.store(C_null(llptrty), llptrptr, None);\n-                }\n-            }\n-        }\n-        _ => bug!(\"Cannot handle {} represented as {:#?}\", t, l)\n-    }\n-}\n-\n-fn target_sets_discr_via_memset<'a, 'tcx>(bcx: &Builder<'a, 'tcx>) -> bool {\n-    bcx.sess().target.target.arch == \"arm\" || bcx.sess().target.target.arch == \"aarch64\"\n-}\n-\n pub fn assert_discr_in_range<D: PartialOrd>(min: D, max: D, discr: D) {\n     if min <= max {\n         assert!(min <= discr && discr <= max)\n@@ -453,45 +314,3 @@ pub fn assert_discr_in_range<D: PartialOrd>(min: D, max: D, discr: D) {\n // FIXME this utility routine should be somewhere more general\n #[inline]\n fn roundup(x: u64, a: u32) -> u64 { let a = a as u64; ((x + (a - 1)) / a) * a }\n-\n-/// Extract a field of a constant value, as appropriate for its\n-/// representation.\n-///\n-/// (Not to be confused with `common::const_get_elt`, which operates on\n-/// raw LLVM-level structs and arrays.)\n-pub fn const_get_field<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>,\n-                       val: ValueRef,\n-                       ix: usize) -> ValueRef {\n-    let l = ccx.layout_of(t);\n-    match *l {\n-        layout::CEnum { .. } => bug!(\"element access in C-like enum const\"),\n-        layout::Univariant { ref variant, .. } => {\n-            const_struct_field(val, variant.memory_index[ix] as usize)\n-        }\n-        layout::Vector { .. } => const_struct_field(val, ix),\n-        layout::UntaggedUnion { .. } => const_struct_field(val, 0),\n-        _ => bug!(\"{} does not have fields.\", t)\n-    }\n-}\n-\n-/// Extract field of struct-like const, skipping our alignment padding.\n-fn const_struct_field(val: ValueRef, ix: usize) -> ValueRef {\n-    // Get the ix-th non-undef element of the struct.\n-    let mut real_ix = 0; // actual position in the struct\n-    let mut ix = ix; // logical index relative to real_ix\n-    let mut field;\n-    loop {\n-        loop {\n-            field = const_get_elt(val, &[real_ix]);\n-            if !is_undef(field) {\n-                break;\n-            }\n-            real_ix = real_ix + 1;\n-        }\n-        if ix == 0 {\n-            return field;\n-        }\n-        ix = ix - 1;\n-        real_ix = real_ix + 1;\n-    }\n-}"}, {"sha": "daeb0dd680ff0aee9708a2c2960b751667226725", "filename": "src/librustc_trans/intrinsic.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fab2532ef949a08e16b621259a91d1ff37165665/src%2Flibrustc_trans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fab2532ef949a08e16b621259a91d1ff37165665/src%2Flibrustc_trans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fintrinsic.rs?ref=fab2532ef949a08e16b621259a91d1ff37165665", "patch": "@@ -15,7 +15,6 @@ use libc;\n use llvm;\n use llvm::{ValueRef};\n use abi::{Abi, FnType};\n-use adt;\n use mir::lvalue::{LvalueRef, Alignment};\n use base::*;\n use common::*;\n@@ -379,10 +378,10 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n \n         \"discriminant_value\" => {\n             let val_ty = substs.type_at(0);\n+            let adt_val = LvalueRef::new_sized_ty(llargs[0], val_ty, Alignment::AbiAligned);\n             match val_ty.sty {\n                 ty::TyAdt(adt, ..) if adt.is_enum() => {\n-                    adt::trans_get_discr(bcx, val_ty, llargs[0], Alignment::AbiAligned,\n-                                         Some(llret_ty), true)\n+                    adt_val.trans_get_discr(bcx, ret_ty)\n                 }\n                 _ => C_null(llret_ty)\n             }"}, {"sha": "67fdc1e640a95f1ace7e96149b1c556cd7c3dbf3", "filename": "src/librustc_trans/mir/constant.rs", "status": "modified", "additions": 26, "deletions": 2, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/fab2532ef949a08e16b621259a91d1ff37165665/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fab2532ef949a08e16b621259a91d1ff37165665/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fconstant.rs?ref=fab2532ef949a08e16b621259a91d1ff37165665", "patch": "@@ -462,8 +462,32 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n                         }\n                     }\n                     mir::ProjectionElem::Field(ref field, _) => {\n-                        let llprojected = adt::const_get_field(self.ccx, tr_base.ty, base.llval,\n-                                                               field.index());\n+                        // Extract field of struct-like const, skipping our alignment padding.\n+                        let mut ix = field.index();\n+                        let layout = self.ccx.layout_of(tr_base.ty);\n+                        if let layout::Univariant { ref variant, .. } = *layout {\n+                            ix = variant.memory_index[ix] as usize;\n+                        }\n+\n+                        // Get the ix-th non-undef element of the struct.\n+                        let mut real_ix = 0; // actual position in the struct\n+                        let mut ix = ix; // logical index relative to real_ix\n+                        let mut llprojected;\n+                        loop {\n+                            loop {\n+                                llprojected = const_get_elt(base.llval, &[real_ix]);\n+                                if !is_undef(llprojected) {\n+                                    break;\n+                                }\n+                                real_ix = real_ix + 1;\n+                            }\n+                            if ix == 0 {\n+                                break;\n+                            }\n+                            ix = ix - 1;\n+                            real_ix = real_ix + 1;\n+                        }\n+\n                         let llextra = if !has_metadata {\n                             ptr::null_mut()\n                         } else {"}, {"sha": "5faaef6ebff4293f4999fd69b47af925233d6560", "filename": "src/librustc_trans/mir/lvalue.rs", "status": "modified", "additions": 158, "deletions": 67, "changes": 225, "blob_url": "https://github.com/rust-lang/rust/blob/fab2532ef949a08e16b621259a91d1ff37165665/src%2Flibrustc_trans%2Fmir%2Flvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fab2532ef949a08e16b621259a91d1ff37165665/src%2Flibrustc_trans%2Fmir%2Flvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Flvalue.rs?ref=fab2532ef949a08e16b621259a91d1ff37165665", "patch": "@@ -8,15 +8,16 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use llvm::ValueRef;\n+use llvm::{self, ValueRef};\n use rustc::ty::{self, Ty, TypeFoldable};\n use rustc::ty::layout::{self, LayoutTyper};\n use rustc::mir;\n use rustc::mir::tcx::LvalueTy;\n use rustc_data_structures::indexed_vec::Idx;\n use adt;\n+use base;\n use builder::Builder;\n-use common::{self, CrateContext, C_usize};\n+use common::{self, CrateContext, C_usize, C_u8, C_i32, C_int, C_null, val_ty};\n use consts;\n use machine;\n use type_of;\n@@ -70,6 +71,10 @@ impl Alignment {\n     }\n }\n \n+fn target_sets_discr_via_memset<'a, 'tcx>(bcx: &Builder<'a, 'tcx>) -> bool {\n+    bcx.sess().target.target.arch == \"arm\" || bcx.sess().target.target.arch == \"aarch64\"\n+}\n+\n #[derive(Copy, Clone, Debug)]\n pub struct LvalueRef<'tcx> {\n     /// Pointer to the contents of the lvalue\n@@ -121,23 +126,56 @@ impl<'a, 'tcx> LvalueRef<'tcx> {\n         !self.llextra.is_null()\n     }\n \n-    fn struct_field_ptr(\n-        self,\n-        bcx: &Builder<'a, 'tcx>,\n-        st: &layout::Struct,\n-        fields: &Vec<Ty<'tcx>>,\n-        ix: usize,\n-        needs_cast: bool\n-    ) -> (ValueRef, Alignment) {\n-        let fty = fields[ix];\n+    /// Access a field, at a point when the value's case is known.\n+    pub fn trans_field_ptr(self, bcx: &Builder<'a, 'tcx>, ix: usize) -> (ValueRef, Alignment) {\n         let ccx = bcx.ccx;\n+        let mut l = ccx.layout_of(self.ty.to_ty(bcx.tcx()));\n+        match self.ty {\n+            LvalueTy::Ty { .. } => {}\n+            LvalueTy::Downcast { variant_index, .. } => {\n+                l = l.for_variant(variant_index)\n+            }\n+        }\n+        let fty = l.field(ccx, ix).ty;\n+        let mut ix = ix;\n+        let st = match *l {\n+            layout::Vector { .. } => {\n+                return (bcx.struct_gep(self.llval, ix), self.alignment);\n+            }\n+            layout::UntaggedUnion { ref variants } => {\n+                let ty = type_of::in_memory_type_of(ccx, fty);\n+                return (bcx.pointercast(self.llval, ty.ptr_to()),\n+                    self.alignment | Alignment::from_packed(variants.packed));\n+            }\n+            layout::RawNullablePointer { nndiscr, .. } |\n+            layout::StructWrappedNullablePointer { nndiscr,  .. }\n+                if l.variant_index.unwrap() as u64 != nndiscr => {\n+                // The unit-like case might have a nonzero number of unit-like fields.\n+                // (e.d., Result of Either with (), as one side.)\n+                let ty = type_of::type_of(ccx, fty);\n+                assert_eq!(machine::llsize_of_alloc(ccx, ty), 0);\n+                return (bcx.pointercast(self.llval, ty.ptr_to()), Alignment::Packed);\n+            }\n+            layout::RawNullablePointer { .. } => {\n+                let ty = type_of::type_of(ccx, fty);\n+                return (bcx.pointercast(self.llval, ty.ptr_to()), self.alignment);\n+            }\n+            layout::Univariant { ref variant, .. } => variant,\n+            layout::StructWrappedNullablePointer { ref nonnull, .. } => nonnull,\n+            layout::General { ref variants, .. } => {\n+                ix += 1;\n+                &variants[l.variant_index.unwrap()]\n+            }\n+            _ => bug!(\"element access in type without elements: {} represented as {:#?}\", l.ty, l)\n+        };\n \n         let alignment = self.alignment | Alignment::from_packed(st.packed);\n \n-        let llfields = adt::struct_llfields(ccx, fields, st);\n-        let ptr_val = if needs_cast {\n-            let real_ty = Type::struct_(ccx, &llfields[..], st.packed);\n-            bcx.pointercast(self.llval, real_ty.ptr_to())\n+        let ptr_val = if let layout::General { discr, .. } = *l {\n+            let variant_ty = Type::struct_(ccx,\n+                &adt::struct_llfields(ccx, l.ty, l.variant_index.unwrap(), st,\n+                                      Some(discr.to_ty(&bcx.tcx(), false))), st.packed);\n+            bcx.pointercast(self.llval, variant_ty.ptr_to())\n         } else {\n             self.llval\n         };\n@@ -147,7 +185,7 @@ impl<'a, 'tcx> LvalueRef<'tcx> {\n         //   * Packed struct - There is no alignment padding\n         //   * Field is sized - pointer is properly aligned already\n         if st.offsets[ix] == layout::Size::from_bytes(0) || st.packed ||\n-            bcx.ccx.shared().type_is_sized(fty)\n+            ccx.shared().type_is_sized(fty)\n         {\n             return (bcx.struct_gep(\n                     ptr_val, adt::struct_llfields_index(st, ix)), alignment);\n@@ -189,7 +227,7 @@ impl<'a, 'tcx> LvalueRef<'tcx> {\n \n \n         let offset = st.offsets[ix].bytes();\n-        let unaligned_offset = C_usize(bcx.ccx, offset);\n+        let unaligned_offset = C_usize(ccx, offset);\n \n         // Get the alignment of the field\n         let (_, align) = glue::size_and_align_of_dst(bcx, fty, meta);\n@@ -200,77 +238,130 @@ impl<'a, 'tcx> LvalueRef<'tcx> {\n         //   (unaligned offset + (align - 1)) & -align\n \n         // Calculate offset\n-        let align_sub_1 = bcx.sub(align, C_usize(bcx.ccx, 1));\n+        let align_sub_1 = bcx.sub(align, C_usize(ccx, 1u64));\n         let offset = bcx.and(bcx.add(unaligned_offset, align_sub_1),\n         bcx.neg(align));\n \n         debug!(\"struct_field_ptr: DST field offset: {:?}\", Value(offset));\n \n         // Cast and adjust pointer\n-        let byte_ptr = bcx.pointercast(ptr_val, Type::i8p(bcx.ccx));\n+        let byte_ptr = bcx.pointercast(ptr_val, Type::i8p(ccx));\n         let byte_ptr = bcx.gep(byte_ptr, &[offset]);\n \n         // Finally, cast back to the type expected\n-        let ll_fty = type_of::in_memory_type_of(bcx.ccx, fty);\n+        let ll_fty = type_of::in_memory_type_of(ccx, fty);\n         debug!(\"struct_field_ptr: Field type is {:?}\", ll_fty);\n         (bcx.pointercast(byte_ptr, ll_fty.ptr_to()), alignment)\n     }\n \n-    /// Access a field, at a point when the value's case is known.\n-    pub fn trans_field_ptr(self, bcx: &Builder<'a, 'tcx>, ix: usize) -> (ValueRef, Alignment) {\n-        let discr = match self.ty {\n-            LvalueTy::Ty { .. } => 0,\n-            LvalueTy::Downcast { variant_index, .. } => variant_index,\n-        };\n-        let t = self.ty.to_ty(bcx.tcx());\n-        let l = bcx.ccx.layout_of(t);\n-        // Note: if this ever needs to generate conditionals (e.g., if we\n-        // decide to do some kind of cdr-coding-like non-unique repr\n-        // someday), it will need to return a possibly-new bcx as well.\n-        match *l {\n-            layout::Univariant { ref variant, .. } => {\n-                assert_eq!(discr, 0);\n-                self.struct_field_ptr(bcx, &variant,\n-                    &adt::compute_fields(bcx.ccx, t, 0, false), ix, false)\n+    // Double index to account for padding (FieldPath already uses `Struct::memory_index`)\n+    fn gepi_struct_llfields_path(self, bcx: &Builder, discrfield: &layout::FieldPath) -> ValueRef {\n+        let path = discrfield.iter().map(|&i| (i as usize) << 1).collect::<Vec<_>>();\n+        bcx.gepi(self.llval, &path)\n+    }\n+\n+    /// Helper for cases where the discriminant is simply loaded.\n+    fn load_discr(self, bcx: &Builder, ity: layout::Integer, ptr: ValueRef,\n+                  min: u64, max: u64) -> ValueRef {\n+        let llty = Type::from_integer(bcx.ccx, ity);\n+        assert_eq!(val_ty(ptr), llty.ptr_to());\n+        let bits = ity.size().bits();\n+        assert!(bits <= 64);\n+        let bits = bits as usize;\n+        let mask = !0u64 >> (64 - bits);\n+        // For a (max) discr of -1, max will be `-1 as usize`, which overflows.\n+        // However, that is fine here (it would still represent the full range),\n+        if max.wrapping_add(1) & mask == min & mask {\n+            // i.e., if the range is everything.  The lo==hi case would be\n+            // rejected by the LLVM verifier (it would mean either an\n+            // empty set, which is impossible, or the entire range of the\n+            // type, which is pointless).\n+            bcx.load(ptr, self.alignment.to_align())\n+        } else {\n+            // llvm::ConstantRange can deal with ranges that wrap around,\n+            // so an overflow on (max + 1) is fine.\n+            bcx.load_range_assert(ptr, min, max.wrapping_add(1), /* signed: */ llvm::True,\n+                                  self.alignment.to_align())\n+        }\n+    }\n+\n+    /// Obtain the actual discriminant of a value.\n+    pub fn trans_get_discr(self, bcx: &Builder<'a, 'tcx>, cast_to: Ty<'tcx>) -> ValueRef {\n+        let l = bcx.ccx.layout_of(self.ty.to_ty(bcx.tcx()));\n+\n+        let val = match *l {\n+            layout::CEnum { discr, min, max, .. } => {\n+                self.load_discr(bcx, discr, self.llval, min, max)\n             }\n-            layout::Vector { count, .. } => {\n-                assert_eq!(discr, 0);\n-                assert!((ix as u64) < count);\n-                (bcx.struct_gep(self.llval, ix), self.alignment)\n+            layout::General { discr, ref variants, .. } => {\n+                let ptr = bcx.struct_gep(self.llval, 0);\n+                self.load_discr(bcx, discr, ptr, 0, variants.len() as u64 - 1)\n             }\n-            layout::General { discr: d, ref variants, .. } => {\n-                let mut fields = adt::compute_fields(bcx.ccx, t, discr, false);\n-                fields.insert(0, d.to_ty(&bcx.tcx(), false));\n-                self.struct_field_ptr(bcx, &variants[discr], &fields, ix + 1, true)\n+            layout::Univariant { .. } | layout::UntaggedUnion { .. } => C_u8(bcx.ccx, 0),\n+            layout::RawNullablePointer { nndiscr, .. } => {\n+                let cmp = if nndiscr == 0 { llvm::IntEQ } else { llvm::IntNE };\n+                let discr = bcx.load(self.llval, self.alignment.to_align());\n+                bcx.icmp(cmp, discr, C_null(val_ty(discr)))\n             }\n-            layout::UntaggedUnion { ref variants } => {\n-                let fields = adt::compute_fields(bcx.ccx, t, 0, false);\n-                let ty = type_of::in_memory_type_of(bcx.ccx, fields[ix]);\n-                (bcx.pointercast(self.llval, ty.ptr_to()),\n-                 self.alignment | Alignment::from_packed(variants.packed))\n+            layout::StructWrappedNullablePointer { nndiscr, ref discrfield, .. } => {\n+                let llptrptr = self.gepi_struct_llfields_path(bcx, discrfield);\n+                let llptr = bcx.load(llptrptr, self.alignment.to_align());\n+                let cmp = if nndiscr == 0 { llvm::IntEQ } else { llvm::IntNE };\n+                bcx.icmp(cmp, llptr, C_null(val_ty(llptr)))\n+            },\n+            _ => bug!(\"{} is not an enum\", l.ty)\n+        };\n+        let cast_to = type_of::immediate_type_of(bcx.ccx, cast_to);\n+        bcx.intcast(val, cast_to, adt::is_discr_signed(&l))\n+    }\n+\n+    /// Set the discriminant for a new value of the given case of the given\n+    /// representation.\n+    pub fn trans_set_discr(&self, bcx: &Builder<'a, 'tcx>, variant_index: usize) {\n+        let l = bcx.ccx.layout_of(self.ty.to_ty(bcx.tcx()));\n+        let to = l.ty.ty_adt_def().unwrap()\n+            .discriminant_for_variant(bcx.tcx(), variant_index)\n+            .to_u128_unchecked() as u64;\n+        match *l {\n+            layout::CEnum { discr, min, max, .. } => {\n+                adt::assert_discr_in_range(min, max, to);\n+                bcx.store(C_int(Type::from_integer(bcx.ccx, discr), to as i64),\n+                    self.llval, self.alignment.to_align());\n             }\n-            layout::RawNullablePointer { nndiscr, .. } |\n-            layout::StructWrappedNullablePointer { nndiscr,  .. } if discr as u64 != nndiscr => {\n-                let nullfields = adt::compute_fields(bcx.ccx, t, (1-nndiscr) as usize, false);\n-                // The unit-like case might have a nonzero number of unit-like fields.\n-                // (e.d., Result of Either with (), as one side.)\n-                let ty = type_of::type_of(bcx.ccx, nullfields[ix]);\n-                assert_eq!(machine::llsize_of_alloc(bcx.ccx, ty), 0);\n-                (bcx.pointercast(self.llval, ty.ptr_to()), Alignment::Packed)\n+            layout::General { discr, .. } => {\n+                bcx.store(C_int(Type::from_integer(bcx.ccx, discr), to as i64),\n+                    bcx.struct_gep(self.llval, 0), self.alignment.to_align());\n+            }\n+            layout::Univariant { .. }\n+            | layout::UntaggedUnion { .. }\n+            | layout::Vector { .. } => {\n+                assert_eq!(to, 0);\n             }\n             layout::RawNullablePointer { nndiscr, .. } => {\n-                let nnty = adt::compute_fields(bcx.ccx, t, nndiscr as usize, false)[0];\n-                assert_eq!(ix, 0);\n-                assert_eq!(discr as u64, nndiscr);\n-                let ty = type_of::type_of(bcx.ccx, nnty);\n-                (bcx.pointercast(self.llval, ty.ptr_to()), self.alignment)\n+                if to != nndiscr {\n+                    let llptrty = val_ty(self.llval).element_type();\n+                    bcx.store(C_null(llptrty), self.llval, self.alignment.to_align());\n+                }\n             }\n-            layout::StructWrappedNullablePointer { ref nonnull, nndiscr, .. } => {\n-                assert_eq!(discr as u64, nndiscr);\n-                self.struct_field_ptr(bcx, &nonnull,\n-                     &adt::compute_fields(bcx.ccx, t, discr, false), ix, false)\n+            layout::StructWrappedNullablePointer { nndiscr, ref discrfield, ref nonnull, .. } => {\n+                if to != nndiscr {\n+                    if target_sets_discr_via_memset(bcx) {\n+                        // Issue #34427: As workaround for LLVM bug on\n+                        // ARM, use memset of 0 on whole struct rather\n+                        // than storing null to single target field.\n+                        let llptr = bcx.pointercast(self.llval, Type::i8(bcx.ccx).ptr_to());\n+                        let fill_byte = C_u8(bcx.ccx, 0);\n+                        let size = C_usize(bcx.ccx, nonnull.stride().bytes());\n+                        let align = C_i32(bcx.ccx, nonnull.align.abi() as i32);\n+                        base::call_memset(bcx, llptr, fill_byte, size, align, false);\n+                    } else {\n+                        let llptrptr = self.gepi_struct_llfields_path(bcx, discrfield);\n+                        let llptrty = val_ty(llptrptr).element_type();\n+                        bcx.store(C_null(llptrty), llptrptr, self.alignment.to_align());\n+                    }\n+                }\n             }\n-            _ => bug!(\"element access in type without elements: {} represented as {:#?}\", t, l)\n+            _ => bug!(\"Cannot handle {} represented as {:#?}\", l.ty, l)\n         }\n     }\n "}, {"sha": "bc263fd60a25c7e84d02b6bb7366d93eefa3d4ec", "filename": "src/librustc_trans/mir/rvalue.rs", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/fab2532ef949a08e16b621259a91d1ff37165665/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fab2532ef949a08e16b621259a91d1ff37165665/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Frvalue.rs?ref=fab2532ef949a08e16b621259a91d1ff37165665", "patch": "@@ -139,10 +139,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n             mir::Rvalue::Aggregate(ref kind, ref operands) => {\n                 match **kind {\n                     mir::AggregateKind::Adt(adt_def, variant_index, substs, active_field_index) => {\n-                        let discr = adt_def.discriminant_for_variant(bcx.tcx(), variant_index)\n-                           .to_u128_unchecked() as u64;\n-                        let dest_ty = dest.ty.to_ty(bcx.tcx());\n-                        adt::trans_set_discr(&bcx, dest_ty, dest.llval, discr);\n+                        dest.trans_set_discr(&bcx, variant_index);\n                         for (i, operand) in operands.iter().enumerate() {\n                             let op = self.trans_operand(&bcx, operand);\n                             // Do not generate stores and GEPis for zero-sized fields.\n@@ -451,12 +448,9 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n             }\n \n             mir::Rvalue::Discriminant(ref lvalue) => {\n-                let discr_lvalue = self.trans_lvalue(&bcx, lvalue);\n-                let enum_ty = discr_lvalue.ty.to_ty(bcx.tcx());\n                 let discr_ty = rvalue.ty(&*self.mir, bcx.tcx());\n-                let discr_type = type_of::immediate_type_of(bcx.ccx, discr_ty);\n-                let discr = adt::trans_get_discr(&bcx, enum_ty, discr_lvalue.llval,\n-                                                  discr_lvalue.alignment, Some(discr_type), true);\n+                let discr =  self.trans_lvalue(&bcx, lvalue)\n+                    .trans_get_discr(&bcx, discr_ty);\n                 (bcx, OperandRef {\n                     val: OperandValue::Immediate(discr),\n                     ty: discr_ty"}, {"sha": "6e9b1f36c2cab5c701bd08594a68b0594407153e", "filename": "src/librustc_trans/mir/statement.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/fab2532ef949a08e16b621259a91d1ff37165665/src%2Flibrustc_trans%2Fmir%2Fstatement.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fab2532ef949a08e16b621259a91d1ff37165665/src%2Flibrustc_trans%2Fmir%2Fstatement.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fstatement.rs?ref=fab2532ef949a08e16b621259a91d1ff37165665", "patch": "@@ -17,7 +17,6 @@ use builder::Builder;\n \n use super::MirContext;\n use super::LocalRef;\n-use super::super::adt;\n \n impl<'a, 'tcx> MirContext<'a, 'tcx> {\n     pub fn trans_statement(&mut self,\n@@ -59,12 +58,8 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                 }\n             }\n             mir::StatementKind::SetDiscriminant{ref lvalue, variant_index} => {\n-                let ty = self.monomorphized_lvalue_ty(lvalue);\n-                let lvalue_transed = self.trans_lvalue(&bcx, lvalue);\n-                adt::trans_set_discr(&bcx,\n-                    ty,\n-                    lvalue_transed.llval,\n-                    variant_index as u64);\n+                self.trans_lvalue(&bcx, lvalue)\n+                    .trans_set_discr(&bcx, variant_index);\n                 bcx\n             }\n             mir::StatementKind::StorageLive(local) => {"}]}