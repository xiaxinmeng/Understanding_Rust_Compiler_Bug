{"sha": "937f629535f38c655267f1ed21ce6830f592f5df", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkzN2Y2Mjk1MzVmMzhjNjU1MjY3ZjFlZDIxY2U2ODMwZjU5MmY1ZGY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-01-08T12:34:20Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-01-08T12:34:20Z"}, "message": "Auto merge of #80653 - jryans:doc-deref-recursive, r=jyn514,GuillaumeGomez\n\nRecursively document methods via `Deref` traits\n\nThis changes `rustdoc` to recursively follow `Deref` targets so that methods from all levels are added to the rendered output. This implementation displays the methods from all levels in the expanded state with separate sections for each level.\n\n![image](https://user-images.githubusercontent.com/279572/103482863-46723b00-4ddb-11eb-972b-c463351a425c.png)\n\nFixes https://github.com/rust-lang/rust/issues/26207\nFixes https://github.com/rust-lang/rust/issues/53038\nFixes https://github.com/rust-lang/rust/issues/71640\n\nr? `@jyn514`", "tree": {"sha": "099dcda1cc0c4a0e7ccc55607172de593a04889a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/099dcda1cc0c4a0e7ccc55607172de593a04889a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/937f629535f38c655267f1ed21ce6830f592f5df", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/937f629535f38c655267f1ed21ce6830f592f5df", "html_url": "https://github.com/rust-lang/rust/commit/937f629535f38c655267f1ed21ce6830f592f5df", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/937f629535f38c655267f1ed21ce6830f592f5df/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3d8608a8638fabc46e83acc0626d4cf2782f0702", "url": "https://api.github.com/repos/rust-lang/rust/commits/3d8608a8638fabc46e83acc0626d4cf2782f0702", "html_url": "https://github.com/rust-lang/rust/commit/3d8608a8638fabc46e83acc0626d4cf2782f0702"}, {"sha": "ea946071ddd5e0cf395eb910253bc1622dcd1f6c", "url": "https://api.github.com/repos/rust-lang/rust/commits/ea946071ddd5e0cf395eb910253bc1622dcd1f6c", "html_url": "https://github.com/rust-lang/rust/commit/ea946071ddd5e0cf395eb910253bc1622dcd1f6c"}], "stats": {"total": 398, "additions": 276, "deletions": 122}, "files": [{"sha": "33639055b59efdea3e7662d81c2111b4b284b28d", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/937f629535f38c655267f1ed21ce6830f592f5df/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/937f629535f38c655267f1ed21ce6830f592f5df/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=937f629535f38c655267f1ed21ce6830f592f5df", "patch": "@@ -1322,7 +1322,6 @@ fn init_id_map() -> FxHashMap<String, usize> {\n     map.insert(\"trait-implementations\".to_owned(), 1);\n     map.insert(\"synthetic-implementations\".to_owned(), 1);\n     map.insert(\"blanket-implementations\".to_owned(), 1);\n-    map.insert(\"deref-methods\".to_owned(), 1);\n     map\n }\n "}, {"sha": "e90e26f20e3477f5ad641ff72a74e45592965da5", "filename": "src/librustdoc/html/render/mod.rs", "status": "modified", "additions": 123, "deletions": 83, "changes": 206, "blob_url": "https://github.com/rust-lang/rust/blob/937f629535f38c655267f1ed21ce6830f592f5df/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/937f629535f38c655267f1ed21ce6830f592f5df/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs?ref=937f629535f38c655267f1ed21ce6830f592f5df", "patch": "@@ -115,6 +115,9 @@ crate struct Context<'tcx> {\n     crate render_redirect_pages: bool,\n     /// The map used to ensure all generated 'id=' attributes are unique.\n     id_map: Rc<RefCell<IdMap>>,\n+    /// Tracks section IDs for `Deref` targets so they match in both the main\n+    /// body and the sidebar.\n+    deref_id_map: Rc<RefCell<FxHashMap<DefId, String>>>,\n     crate shared: Arc<SharedContext<'tcx>>,\n     all: Rc<RefCell<AllTypes>>,\n     /// Storage for the errors produced while generating documentation so they\n@@ -372,7 +375,6 @@ crate fn initial_ids() -> Vec<String> {\n         \"implementors-list\",\n         \"synthetic-implementors-list\",\n         \"methods\",\n-        \"deref-methods\",\n         \"implementations\",\n     ]\n     .iter()\n@@ -506,6 +508,7 @@ impl<'tcx> FormatRenderer<'tcx> for Context<'tcx> {\n             dst,\n             render_redirect_pages: false,\n             id_map: Rc::new(RefCell::new(id_map)),\n+            deref_id_map: Rc::new(RefCell::new(FxHashMap::default())),\n             shared: Arc::new(scx),\n             all: Rc::new(RefCell::new(AllTypes::new())),\n             errors: Rc::new(receiver),\n@@ -3517,14 +3520,18 @@ fn render_assoc_items(\n                 RenderMode::Normal\n             }\n             AssocItemRender::DerefFor { trait_, type_, deref_mut_ } => {\n+                let id =\n+                    cx.derive_id(small_url_encode(&format!(\"deref-methods-{:#}\", type_.print())));\n+                cx.deref_id_map.borrow_mut().insert(type_.def_id().unwrap(), id.clone());\n                 write!(\n                     w,\n-                    \"<h2 id=\\\"deref-methods\\\" class=\\\"small-section-header\\\">\\\n-                         Methods from {}&lt;Target = {}&gt;\\\n-                         <a href=\\\"#deref-methods\\\" class=\\\"anchor\\\"></a>\\\n+                    \"<h2 id=\\\"{id}\\\" class=\\\"small-section-header\\\">\\\n+                         Methods from {trait_}&lt;Target = {type_}&gt;\\\n+                         <a href=\\\"#{id}\\\" class=\\\"anchor\\\"></a>\\\n                      </h2>\",\n-                    trait_.print(),\n-                    type_.print()\n+                    id = id,\n+                    trait_ = trait_.print(),\n+                    type_ = type_.print(),\n                 );\n                 RenderMode::ForDeref { mut_: deref_mut_ }\n             }\n@@ -3548,9 +3555,6 @@ fn render_assoc_items(\n             );\n         }\n     }\n-    if let AssocItemRender::DerefFor { .. } = what {\n-        return;\n-    }\n     if !traits.is_empty() {\n         let deref_impl =\n             traits.iter().find(|t| t.inner_impl().trait_.def_id() == cache.deref_trait_did);\n@@ -3560,6 +3564,12 @@ fn render_assoc_items(\n             render_deref_methods(w, cx, impl_, containing_item, has_deref_mut, cache);\n         }\n \n+        // If we were already one level into rendering deref methods, we don't want to render\n+        // anything after recursing into any further deref methods above.\n+        if let AssocItemRender::DerefFor { .. } = what {\n+            return;\n+        }\n+\n         let (synthetic, concrete): (Vec<&&Impl>, Vec<&&Impl>) =\n             traits.iter().partition(|t| t.inner_impl().synthetic);\n         let (blanket_impl, concrete): (Vec<&&Impl>, _) =\n@@ -3631,6 +3641,13 @@ fn render_deref_methods(\n     let what =\n         AssocItemRender::DerefFor { trait_: deref_type, type_: real_target, deref_mut_: deref_mut };\n     if let Some(did) = target.def_id() {\n+        if let Some(type_did) = impl_.inner_impl().for_.def_id() {\n+            // `impl Deref<Target = S> for S`\n+            if did == type_did {\n+                // Avoid infinite cycles\n+                return;\n+            }\n+        }\n         render_assoc_items(w, cx, container_item, did, what, cache);\n     } else {\n         if let Some(prim) = target.primitive_type() {\n@@ -4165,14 +4182,14 @@ fn print_sidebar(cx: &Context<'_>, it: &clean::Item, buffer: &mut Buffer, cache:\n         );\n     }\n     match *it.kind {\n-        clean::StructItem(ref s) => sidebar_struct(buffer, it, s),\n-        clean::TraitItem(ref t) => sidebar_trait(buffer, it, t),\n-        clean::PrimitiveItem(_) => sidebar_primitive(buffer, it),\n-        clean::UnionItem(ref u) => sidebar_union(buffer, it, u),\n-        clean::EnumItem(ref e) => sidebar_enum(buffer, it, e),\n-        clean::TypedefItem(_, _) => sidebar_typedef(buffer, it),\n+        clean::StructItem(ref s) => sidebar_struct(cx, buffer, it, s),\n+        clean::TraitItem(ref t) => sidebar_trait(cx, buffer, it, t),\n+        clean::PrimitiveItem(_) => sidebar_primitive(cx, buffer, it),\n+        clean::UnionItem(ref u) => sidebar_union(cx, buffer, it, u),\n+        clean::EnumItem(ref e) => sidebar_enum(cx, buffer, it, e),\n+        clean::TypedefItem(_, _) => sidebar_typedef(cx, buffer, it),\n         clean::ModuleItem(ref m) => sidebar_module(buffer, &m.items),\n-        clean::ForeignTypeItem => sidebar_foreign_type(buffer, it),\n+        clean::ForeignTypeItem => sidebar_foreign_type(cx, buffer, it),\n         _ => (),\n     }\n \n@@ -4273,7 +4290,7 @@ fn small_url_encode(s: &str) -> String {\n         .replace(\"\\\"\", \"%22\")\n }\n \n-fn sidebar_assoc_items(it: &clean::Item) -> String {\n+fn sidebar_assoc_items(cx: &Context<'_>, it: &clean::Item) -> String {\n     let mut out = String::new();\n     let c = cache();\n     if let Some(v) = c.impls.get(&it.def_id) {\n@@ -4303,58 +4320,7 @@ fn sidebar_assoc_items(it: &clean::Item) -> String {\n                 .filter(|i| i.inner_impl().trait_.is_some())\n                 .find(|i| i.inner_impl().trait_.def_id() == c.deref_trait_did)\n             {\n-                debug!(\"found Deref: {:?}\", impl_);\n-                if let Some((target, real_target)) =\n-                    impl_.inner_impl().items.iter().find_map(|item| match *item.kind {\n-                        clean::TypedefItem(ref t, true) => Some(match *t {\n-                            clean::Typedef { item_type: Some(ref type_), .. } => (type_, &t.type_),\n-                            _ => (&t.type_, &t.type_),\n-                        }),\n-                        _ => None,\n-                    })\n-                {\n-                    debug!(\"found target, real_target: {:?} {:?}\", target, real_target);\n-                    let deref_mut = v\n-                        .iter()\n-                        .filter(|i| i.inner_impl().trait_.is_some())\n-                        .any(|i| i.inner_impl().trait_.def_id() == c.deref_mut_trait_did);\n-                    let inner_impl = target\n-                        .def_id()\n-                        .or_else(|| {\n-                            target\n-                                .primitive_type()\n-                                .and_then(|prim| c.primitive_locations.get(&prim).cloned())\n-                        })\n-                        .and_then(|did| c.impls.get(&did));\n-                    if let Some(impls) = inner_impl {\n-                        debug!(\"found inner_impl: {:?}\", impls);\n-                        out.push_str(\"<a class=\\\"sidebar-title\\\" href=\\\"#deref-methods\\\">\");\n-                        out.push_str(&format!(\n-                            \"Methods from {}&lt;Target={}&gt;\",\n-                            Escape(&format!(\n-                                \"{:#}\",\n-                                impl_.inner_impl().trait_.as_ref().unwrap().print()\n-                            )),\n-                            Escape(&format!(\"{:#}\", real_target.print()))\n-                        ));\n-                        out.push_str(\"</a>\");\n-                        let mut ret = impls\n-                            .iter()\n-                            .filter(|i| i.inner_impl().trait_.is_none())\n-                            .flat_map(|i| {\n-                                get_methods(i.inner_impl(), true, &mut used_links, deref_mut)\n-                            })\n-                            .collect::<Vec<_>>();\n-                        // We want links' order to be reproducible so we don't use unstable sort.\n-                        ret.sort();\n-                        if !ret.is_empty() {\n-                            out.push_str(&format!(\n-                                \"<div class=\\\"sidebar-links\\\">{}</div>\",\n-                                ret.join(\"\")\n-                            ));\n-                        }\n-                    }\n-                }\n+                out.push_str(&sidebar_deref_methods(cx, impl_, v));\n             }\n             let format_impls = |impls: Vec<&Impl>| {\n                 let mut links = FxHashSet::default();\n@@ -4422,7 +4388,81 @@ fn sidebar_assoc_items(it: &clean::Item) -> String {\n     out\n }\n \n-fn sidebar_struct(buf: &mut Buffer, it: &clean::Item, s: &clean::Struct) {\n+fn sidebar_deref_methods(cx: &Context<'_>, impl_: &Impl, v: &Vec<Impl>) -> String {\n+    let mut out = String::new();\n+    let c = cache();\n+\n+    debug!(\"found Deref: {:?}\", impl_);\n+    if let Some((target, real_target)) =\n+        impl_.inner_impl().items.iter().find_map(|item| match *item.kind {\n+            clean::TypedefItem(ref t, true) => Some(match *t {\n+                clean::Typedef { item_type: Some(ref type_), .. } => (type_, &t.type_),\n+                _ => (&t.type_, &t.type_),\n+            }),\n+            _ => None,\n+        })\n+    {\n+        debug!(\"found target, real_target: {:?} {:?}\", target, real_target);\n+        let deref_mut = v\n+            .iter()\n+            .filter(|i| i.inner_impl().trait_.is_some())\n+            .any(|i| i.inner_impl().trait_.def_id() == c.deref_mut_trait_did);\n+        let inner_impl = target\n+            .def_id()\n+            .or_else(|| {\n+                target.primitive_type().and_then(|prim| c.primitive_locations.get(&prim).cloned())\n+            })\n+            .and_then(|did| c.impls.get(&did));\n+        if let Some(impls) = inner_impl {\n+            debug!(\"found inner_impl: {:?}\", impls);\n+            let mut used_links = FxHashSet::default();\n+            let mut ret = impls\n+                .iter()\n+                .filter(|i| i.inner_impl().trait_.is_none())\n+                .flat_map(|i| get_methods(i.inner_impl(), true, &mut used_links, deref_mut))\n+                .collect::<Vec<_>>();\n+            if !ret.is_empty() {\n+                let deref_id_map = cx.deref_id_map.borrow();\n+                let id = deref_id_map\n+                    .get(&real_target.def_id().unwrap())\n+                    .expect(\"Deref section without derived id\");\n+                out.push_str(&format!(\n+                    \"<a class=\\\"sidebar-title\\\" href=\\\"#{}\\\">Methods from {}&lt;Target={}&gt;</a>\",\n+                    id,\n+                    Escape(&format!(\"{:#}\", impl_.inner_impl().trait_.as_ref().unwrap().print())),\n+                    Escape(&format!(\"{:#}\", real_target.print())),\n+                ));\n+                // We want links' order to be reproducible so we don't use unstable sort.\n+                ret.sort();\n+                out.push_str(&format!(\"<div class=\\\"sidebar-links\\\">{}</div>\", ret.join(\"\")));\n+            }\n+        }\n+\n+        // Recurse into any further impls that might exist for `target`\n+        if let Some(target_did) = target.def_id() {\n+            if let Some(target_impls) = c.impls.get(&target_did) {\n+                if let Some(target_deref_impl) = target_impls\n+                    .iter()\n+                    .filter(|i| i.inner_impl().trait_.is_some())\n+                    .find(|i| i.inner_impl().trait_.def_id() == c.deref_trait_did)\n+                {\n+                    if let Some(type_did) = impl_.inner_impl().for_.def_id() {\n+                        // `impl Deref<Target = S> for S`\n+                        if target_did == type_did {\n+                            // Avoid infinite cycles\n+                            return out;\n+                        }\n+                    }\n+                    out.push_str(&sidebar_deref_methods(cx, target_deref_impl, target_impls));\n+                }\n+            }\n+        }\n+    }\n+\n+    out\n+}\n+\n+fn sidebar_struct(cx: &Context<'_>, buf: &mut Buffer, it: &clean::Item, s: &clean::Struct) {\n     let mut sidebar = String::new();\n     let fields = get_struct_fields_name(&s.fields);\n \n@@ -4436,7 +4476,7 @@ fn sidebar_struct(buf: &mut Buffer, it: &clean::Item, s: &clean::Struct) {\n         }\n     }\n \n-    sidebar.push_str(&sidebar_assoc_items(it));\n+    sidebar.push_str(&sidebar_assoc_items(cx, it));\n \n     if !sidebar.is_empty() {\n         write!(buf, \"<div class=\\\"block items\\\">{}</div>\", sidebar);\n@@ -4467,7 +4507,7 @@ fn is_negative_impl(i: &clean::Impl) -> bool {\n     i.polarity == Some(clean::ImplPolarity::Negative)\n }\n \n-fn sidebar_trait(buf: &mut Buffer, it: &clean::Item, t: &clean::Trait) {\n+fn sidebar_trait(cx: &Context<'_>, buf: &mut Buffer, it: &clean::Item, t: &clean::Trait) {\n     let mut sidebar = String::new();\n \n     let mut types = t\n@@ -4567,7 +4607,7 @@ fn sidebar_trait(buf: &mut Buffer, it: &clean::Item, t: &clean::Trait) {\n         }\n     }\n \n-    sidebar.push_str(&sidebar_assoc_items(it));\n+    sidebar.push_str(&sidebar_assoc_items(cx, it));\n \n     sidebar.push_str(\"<a class=\\\"sidebar-title\\\" href=\\\"#implementors\\\">Implementors</a>\");\n     if t.is_auto {\n@@ -4580,16 +4620,16 @@ fn sidebar_trait(buf: &mut Buffer, it: &clean::Item, t: &clean::Trait) {\n     write!(buf, \"<div class=\\\"block items\\\">{}</div>\", sidebar)\n }\n \n-fn sidebar_primitive(buf: &mut Buffer, it: &clean::Item) {\n-    let sidebar = sidebar_assoc_items(it);\n+fn sidebar_primitive(cx: &Context<'_>, buf: &mut Buffer, it: &clean::Item) {\n+    let sidebar = sidebar_assoc_items(cx, it);\n \n     if !sidebar.is_empty() {\n         write!(buf, \"<div class=\\\"block items\\\">{}</div>\", sidebar);\n     }\n }\n \n-fn sidebar_typedef(buf: &mut Buffer, it: &clean::Item) {\n-    let sidebar = sidebar_assoc_items(it);\n+fn sidebar_typedef(cx: &Context<'_>, buf: &mut Buffer, it: &clean::Item) {\n+    let sidebar = sidebar_assoc_items(cx, it);\n \n     if !sidebar.is_empty() {\n         write!(buf, \"<div class=\\\"block items\\\">{}</div>\", sidebar);\n@@ -4611,7 +4651,7 @@ fn get_struct_fields_name(fields: &[clean::Item]) -> String {\n     fields.join(\"\")\n }\n \n-fn sidebar_union(buf: &mut Buffer, it: &clean::Item, u: &clean::Union) {\n+fn sidebar_union(cx: &Context<'_>, buf: &mut Buffer, it: &clean::Item, u: &clean::Union) {\n     let mut sidebar = String::new();\n     let fields = get_struct_fields_name(&u.fields);\n \n@@ -4623,14 +4663,14 @@ fn sidebar_union(buf: &mut Buffer, it: &clean::Item, u: &clean::Union) {\n         ));\n     }\n \n-    sidebar.push_str(&sidebar_assoc_items(it));\n+    sidebar.push_str(&sidebar_assoc_items(cx, it));\n \n     if !sidebar.is_empty() {\n         write!(buf, \"<div class=\\\"block items\\\">{}</div>\", sidebar);\n     }\n }\n \n-fn sidebar_enum(buf: &mut Buffer, it: &clean::Item, e: &clean::Enum) {\n+fn sidebar_enum(cx: &Context<'_>, buf: &mut Buffer, it: &clean::Item, e: &clean::Enum) {\n     let mut sidebar = String::new();\n \n     let mut variants = e\n@@ -4650,7 +4690,7 @@ fn sidebar_enum(buf: &mut Buffer, it: &clean::Item, e: &clean::Enum) {\n         ));\n     }\n \n-    sidebar.push_str(&sidebar_assoc_items(it));\n+    sidebar.push_str(&sidebar_assoc_items(cx, it));\n \n     if !sidebar.is_empty() {\n         write!(buf, \"<div class=\\\"block items\\\">{}</div>\", sidebar);\n@@ -4739,8 +4779,8 @@ fn sidebar_module(buf: &mut Buffer, items: &[clean::Item]) {\n     }\n }\n \n-fn sidebar_foreign_type(buf: &mut Buffer, it: &clean::Item) {\n-    let sidebar = sidebar_assoc_items(it);\n+fn sidebar_foreign_type(cx: &Context<'_>, buf: &mut Buffer, it: &clean::Item) {\n+    let sidebar = sidebar_assoc_items(cx, it);\n     if !sidebar.is_empty() {\n         write!(buf, \"<div class=\\\"block items\\\">{}</div>\", sidebar);\n     }"}, {"sha": "7b5e9e5905f334372eadb979d930c92d81ddf81b", "filename": "src/librustdoc/passes/collect_trait_impls.rs", "status": "modified", "additions": 64, "deletions": 36, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/937f629535f38c655267f1ed21ce6830f592f5df/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/937f629535f38c655267f1ed21ce6830f592f5df/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs?ref=937f629535f38c655267f1ed21ce6830f592f5df", "patch": "@@ -3,7 +3,7 @@ use crate::clean::*;\n use crate::core::DocContext;\n use crate::fold::DocFolder;\n \n-use rustc_data_structures::fx::FxHashSet;\n+use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_hir::def_id::{DefId, LOCAL_CRATE};\n use rustc_middle::ty::DefIdTree;\n use rustc_span::symbol::sym;\n@@ -54,39 +54,6 @@ crate fn collect_trait_impls(krate: Crate, cx: &DocContext<'_>) -> Crate {\n         }\n     }\n \n-    let mut cleaner = BadImplStripper { prims, items: crate_items };\n-\n-    // scan through included items ahead of time to splice in Deref targets to the \"valid\" sets\n-    for it in &new_items {\n-        if let ImplItem(Impl { ref for_, ref trait_, ref items, .. }) = *it.kind {\n-            if cleaner.keep_item(for_) && trait_.def_id() == cx.tcx.lang_items().deref_trait() {\n-                let target = items\n-                    .iter()\n-                    .find_map(|item| match *item.kind {\n-                        TypedefItem(ref t, true) => Some(&t.type_),\n-                        _ => None,\n-                    })\n-                    .expect(\"Deref impl without Target type\");\n-\n-                if let Some(prim) = target.primitive_type() {\n-                    cleaner.prims.insert(prim);\n-                } else if let Some(did) = target.def_id() {\n-                    cleaner.items.insert(did);\n-                }\n-            }\n-        }\n-    }\n-\n-    new_items.retain(|it| {\n-        if let ImplItem(Impl { ref for_, ref trait_, ref blanket_impl, .. }) = *it.kind {\n-            cleaner.keep_item(for_)\n-                || trait_.as_ref().map_or(false, |t| cleaner.keep_item(t))\n-                || blanket_impl.is_some()\n-        } else {\n-            true\n-        }\n-    });\n-\n     // `tcx.crates()` doesn't include the local crate, and `tcx.all_trait_implementations`\n     // doesn't work with it anyway, so pull them from the HIR map instead\n     for &trait_did in cx.tcx.all_traits(LOCAL_CRATE).iter() {\n@@ -123,6 +90,63 @@ crate fn collect_trait_impls(krate: Crate, cx: &DocContext<'_>) -> Crate {\n         }\n     }\n \n+    let mut cleaner = BadImplStripper { prims, items: crate_items };\n+\n+    let mut type_did_to_deref_target: FxHashMap<DefId, &Type> = FxHashMap::default();\n+    // Gather all type to `Deref` target edges.\n+    for it in &new_items {\n+        if let ImplItem(Impl { ref for_, ref trait_, ref items, .. }) = *it.kind {\n+            if trait_.def_id() == cx.tcx.lang_items().deref_trait() {\n+                let target = items.iter().find_map(|item| match *item.kind {\n+                    TypedefItem(ref t, true) => Some(&t.type_),\n+                    _ => None,\n+                });\n+                if let (Some(for_did), Some(target)) = (for_.def_id(), target) {\n+                    type_did_to_deref_target.insert(for_did, target);\n+                }\n+            }\n+        }\n+    }\n+    // Follow all `Deref` targets of included items and recursively add them as valid\n+    fn add_deref_target(\n+        map: &FxHashMap<DefId, &Type>,\n+        cleaner: &mut BadImplStripper,\n+        type_did: &DefId,\n+    ) {\n+        if let Some(target) = map.get(type_did) {\n+            debug!(\"add_deref_target: type {:?}, target {:?}\", type_did, target);\n+            if let Some(target_prim) = target.primitive_type() {\n+                cleaner.prims.insert(target_prim);\n+            } else if let Some(target_did) = target.def_id() {\n+                // `impl Deref<Target = S> for S`\n+                if target_did == *type_did {\n+                    // Avoid infinite cycles\n+                    return;\n+                }\n+                cleaner.items.insert(target_did);\n+                add_deref_target(map, cleaner, &target_did);\n+            }\n+        }\n+    }\n+    for type_did in type_did_to_deref_target.keys() {\n+        // Since only the `DefId` portion of the `Type` instances is known to be same for both the\n+        // `Deref` target type and the impl for type positions, this map of types is keyed by\n+        // `DefId` and for convenience uses a special cleaner that accepts `DefId`s directly.\n+        if cleaner.keep_impl_with_def_id(type_did) {\n+            add_deref_target(&type_did_to_deref_target, &mut cleaner, type_did);\n+        }\n+    }\n+\n+    new_items.retain(|it| {\n+        if let ImplItem(Impl { ref for_, ref trait_, ref blanket_impl, .. }) = *it.kind {\n+            cleaner.keep_impl(for_)\n+                || trait_.as_ref().map_or(false, |t| cleaner.keep_impl(t))\n+                || blanket_impl.is_some()\n+        } else {\n+            true\n+        }\n+    });\n+\n     if let Some(ref mut it) = krate.module {\n         if let ModuleItem(Module { ref mut items, .. }) = *it.kind {\n             items.extend(synth.impls);\n@@ -192,16 +216,20 @@ struct BadImplStripper {\n }\n \n impl BadImplStripper {\n-    fn keep_item(&self, ty: &Type) -> bool {\n+    fn keep_impl(&self, ty: &Type) -> bool {\n         if let Generic(_) = ty {\n             // keep impls made on generics\n             true\n         } else if let Some(prim) = ty.primitive_type() {\n             self.prims.contains(&prim)\n         } else if let Some(did) = ty.def_id() {\n-            self.items.contains(&did)\n+            self.keep_impl_with_def_id(&did)\n         } else {\n             false\n         }\n     }\n+\n+    fn keep_impl_with_def_id(&self, did: &DefId) -> bool {\n+        self.items.contains(did)\n+    }\n }"}, {"sha": "4cb518cbbbd5c14fd0057c91a03a71b0ffe0f582", "filename": "src/test/rustdoc-ui/deref-recursive-cycle.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/937f629535f38c655267f1ed21ce6830f592f5df/src%2Ftest%2Frustdoc-ui%2Fderef-recursive-cycle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/937f629535f38c655267f1ed21ce6830f592f5df/src%2Ftest%2Frustdoc-ui%2Fderef-recursive-cycle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fderef-recursive-cycle.rs?ref=937f629535f38c655267f1ed21ce6830f592f5df", "patch": "@@ -0,0 +1,17 @@\n+// check-pass\n+// #26207: Ensure `Deref` cycles are properly handled without errors.\n+\n+#[derive(Copy, Clone)]\n+struct S;\n+\n+impl std::ops::Deref for S {\n+    type Target = S;\n+\n+    fn deref(&self) -> &S {\n+        self\n+    }\n+}\n+\n+fn main() {\n+    let s: S = *******S;\n+}"}, {"sha": "759e881aab4159f16ad1bd8a6770753386fceaad", "filename": "src/test/rustdoc/deref-recursive-pathbuf.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/937f629535f38c655267f1ed21ce6830f592f5df/src%2Ftest%2Frustdoc%2Fderef-recursive-pathbuf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/937f629535f38c655267f1ed21ce6830f592f5df/src%2Ftest%2Frustdoc%2Fderef-recursive-pathbuf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fderef-recursive-pathbuf.rs?ref=937f629535f38c655267f1ed21ce6830f592f5df", "patch": "@@ -0,0 +1,26 @@\n+// ignore-tidy-linelength\n+\n+// #26207: Show all methods reachable via Deref impls, recursing through multiple dereferencing\n+// levels and across multiple crates.\n+\n+// @has 'foo/struct.Foo.html'\n+// @has '-' '//*[@id=\"deref-methods-PathBuf\"]' 'Methods from Deref<Target = PathBuf>'\n+// @has '-' '//*[@class=\"impl-items\"]//*[@id=\"method.as_path\"]' 'pub fn as_path(&self)'\n+// @has '-' '//*[@id=\"deref-methods-Path\"]' 'Methods from Deref<Target = Path>'\n+// @has '-' '//*[@class=\"impl-items\"]//*[@id=\"method.exists\"]' 'pub fn exists(&self)'\n+// @has '-' '//*[@class=\"sidebar-title\"][@href=\"#deref-methods-PathBuf\"]' 'Methods from Deref<Target=PathBuf>'\n+// @has '-' '//*[@class=\"sidebar-links\"]/a[@href=\"#method.as_path\"]' 'as_path'\n+// @has '-' '//*[@class=\"sidebar-title\"][@href=\"#deref-methods-Path\"]' 'Methods from Deref<Target=Path>'\n+// @has '-' '//*[@class=\"sidebar-links\"]/a[@href=\"#method.exists\"]' 'exists'\n+\n+#![crate_name = \"foo\"]\n+\n+use std::ops::Deref;\n+use std::path::PathBuf;\n+\n+pub struct Foo(PathBuf);\n+\n+impl Deref for Foo {\n+    type Target = PathBuf;\n+    fn deref(&self) -> &PathBuf { &self.0 }\n+}"}, {"sha": "5aef87c38cd276e724de6956cdd9cf2399767dc1", "filename": "src/test/rustdoc/deref-recursive.rs", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/937f629535f38c655267f1ed21ce6830f592f5df/src%2Ftest%2Frustdoc%2Fderef-recursive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/937f629535f38c655267f1ed21ce6830f592f5df/src%2Ftest%2Frustdoc%2Fderef-recursive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fderef-recursive.rs?ref=937f629535f38c655267f1ed21ce6830f592f5df", "patch": "@@ -0,0 +1,42 @@\n+// ignore-tidy-linelength\n+\n+// #26207: Show all methods reachable via Deref impls, recursing through multiple dereferencing\n+// levels if needed.\n+\n+// @has 'foo/struct.Foo.html'\n+// @has '-' '//*[@id=\"deref-methods-Bar\"]' 'Methods from Deref<Target = Bar>'\n+// @has '-' '//*[@class=\"impl-items\"]//*[@id=\"method.bar\"]' 'pub fn bar(&self)'\n+// @has '-' '//*[@id=\"deref-methods-Baz\"]' 'Methods from Deref<Target = Baz>'\n+// @has '-' '//*[@class=\"impl-items\"]//*[@id=\"method.baz\"]' 'pub fn baz(&self)'\n+// @has '-' '//*[@class=\"sidebar-title\"][@href=\"#deref-methods-Bar\"]' 'Methods from Deref<Target=Bar>'\n+// @has '-' '//*[@class=\"sidebar-links\"]/a[@href=\"#method.bar\"]' 'bar'\n+// @has '-' '//*[@class=\"sidebar-title\"][@href=\"#deref-methods-Baz\"]' 'Methods from Deref<Target=Baz>'\n+// @has '-' '//*[@class=\"sidebar-links\"]/a[@href=\"#method.baz\"]' 'baz'\n+\n+#![crate_name = \"foo\"]\n+\n+use std::ops::Deref;\n+\n+pub struct Foo(Bar);\n+pub struct Bar(Baz);\n+pub struct Baz;\n+\n+impl Deref for Foo {\n+    type Target = Bar;\n+    fn deref(&self) -> &Bar { &self.0 }\n+}\n+\n+impl Deref for Bar {\n+    type Target = Baz;\n+    fn deref(&self) -> &Baz { &self.0 }\n+}\n+\n+impl Bar {\n+    /// This appears under `Foo` methods\n+    pub fn bar(&self) {}\n+}\n+\n+impl Baz {\n+    /// This should also appear in `Foo` methods when recursing\n+    pub fn baz(&self) {}\n+}"}, {"sha": "589f133b975a509046fa9c0cda4e3430fd63d8d2", "filename": "src/test/rustdoc/deref-typedef.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/937f629535f38c655267f1ed21ce6830f592f5df/src%2Ftest%2Frustdoc%2Fderef-typedef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/937f629535f38c655267f1ed21ce6830f592f5df/src%2Ftest%2Frustdoc%2Fderef-typedef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fderef-typedef.rs?ref=937f629535f38c655267f1ed21ce6830f592f5df", "patch": "@@ -1,12 +1,14 @@\n+// ignore-tidy-linelength\n+\n #![crate_name = \"foo\"]\n \n // @has 'foo/struct.Bar.html'\n-// @has '-' '//*[@id=\"deref-methods\"]' 'Methods from Deref<Target = FooJ>'\n+// @has '-' '//*[@id=\"deref-methods-FooJ\"]' 'Methods from Deref<Target = FooJ>'\n // @has '-' '//*[@class=\"impl-items\"]//*[@id=\"method.foo_a\"]' 'pub fn foo_a(&self)'\n // @has '-' '//*[@class=\"impl-items\"]//*[@id=\"method.foo_b\"]' 'pub fn foo_b(&self)'\n // @has '-' '//*[@class=\"impl-items\"]//*[@id=\"method.foo_c\"]' 'pub fn foo_c(&self)'\n // @has '-' '//*[@class=\"impl-items\"]//*[@id=\"method.foo_j\"]' 'pub fn foo_j(&self)'\n-// @has '-' '//*[@class=\"sidebar-title\"]' 'Methods from Deref<Target=FooJ>'\n+// @has '-' '//*[@class=\"sidebar-title\"][@href=\"#deref-methods-FooJ\"]' 'Methods from Deref<Target=FooJ>'\n // @has '-' '//*[@class=\"sidebar-links\"]/a[@href=\"#method.foo_a\"]' 'foo_a'\n // @has '-' '//*[@class=\"sidebar-links\"]/a[@href=\"#method.foo_b\"]' 'foo_b'\n // @has '-' '//*[@class=\"sidebar-links\"]/a[@href=\"#method.foo_c\"]' 'foo_c'"}]}