{"sha": "21d4e063bca7d9f5a5d0f705e0f11092cbf2cf98", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIxZDRlMDYzYmNhN2Q5ZjVhNWQwZjcwNWUwZjExMDkyY2JmMmNmOTg=", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2020-02-11T18:46:31Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2020-03-14T13:15:14Z"}, "message": "Mode ProjectionCache to its own module.", "tree": {"sha": "1952fcac5d74ea23eebbc8e2a7e89ea6106da38d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1952fcac5d74ea23eebbc8e2a7e89ea6106da38d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/21d4e063bca7d9f5a5d0f705e0f11092cbf2cf98", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/21d4e063bca7d9f5a5d0f705e0f11092cbf2cf98", "html_url": "https://github.com/rust-lang/rust/commit/21d4e063bca7d9f5a5d0f705e0f11092cbf2cf98", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/21d4e063bca7d9f5a5d0f705e0f11092cbf2cf98/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "796ca64e9ad95a8cba0f2ab8d252fb4c5b5fb9b4", "url": "https://api.github.com/repos/rust-lang/rust/commits/796ca64e9ad95a8cba0f2ab8d252fb4c5b5fb9b4", "html_url": "https://github.com/rust-lang/rust/commit/796ca64e9ad95a8cba0f2ab8d252fb4c5b5fb9b4"}], "stats": {"total": 382, "additions": 198, "deletions": 184}, "files": [{"sha": "9f7d019e8fd692989535c4947aeb7949263aeb65", "filename": "src/librustc_infer/traits/mod.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/21d4e063bca7d9f5a5d0f705e0f11092cbf2cf98/src%2Flibrustc_infer%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21d4e063bca7d9f5a5d0f705e0f11092cbf2cf98/src%2Flibrustc_infer%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Ftraits%2Fmod.rs?ref=21d4e063bca7d9f5a5d0f705e0f11092cbf2cf98", "patch": "@@ -13,6 +13,7 @@ pub mod misc;\n mod object_safety;\n mod on_unimplemented;\n mod project;\n+mod projection_cache;\n pub mod query;\n mod select;\n mod specialize;\n@@ -49,11 +50,14 @@ pub use self::object_safety::is_vtable_safe_method;\n pub use self::object_safety::MethodViolationCode;\n pub use self::object_safety::ObjectSafetyViolation;\n pub use self::on_unimplemented::{OnUnimplementedDirective, OnUnimplementedNote};\n-pub use self::project::MismatchedProjectionTypes;\n pub use self::project::{\n     normalize, normalize_projection_type, normalize_to, poly_project_and_unify_type,\n };\n-pub use self::project::{Normalized, ProjectionCache, ProjectionCacheSnapshot, Reveal};\n+pub use self::projection_cache::MismatchedProjectionTypes;\n+pub use self::projection_cache::{\n+    Normalized, ProjectionCache, ProjectionCacheEntry, ProjectionCacheKey, ProjectionCacheSnapshot,\n+    Reveal,\n+};\n pub use self::select::{EvaluationCache, SelectionCache, SelectionContext};\n pub use self::select::{EvaluationResult, IntercrateAmbiguityCause, OverflowError};\n pub use self::specialize::find_associated_item;"}, {"sha": "551b8618af1f522a6055f6776fcc7bc82c891bcf", "filename": "src/librustc_infer/traits/project.rs", "status": "modified", "additions": 3, "deletions": 177, "changes": 180, "blob_url": "https://github.com/rust-lang/rust/blob/21d4e063bca7d9f5a5d0f705e0f11092cbf2cf98/src%2Flibrustc_infer%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21d4e063bca7d9f5a5d0f705e0f11092cbf2cf98/src%2Flibrustc_infer%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Ftraits%2Fproject.rs?ref=21d4e063bca7d9f5a5d0f705e0f11092cbf2cf98", "patch": "@@ -1,15 +1,18 @@\n //! Code for projecting associated types out of trait references.\n \n use super::elaborate_predicates;\n+use super::projection_cache::NormalizedTy;\n use super::specialization_graph;\n use super::translate_substs;\n use super::util;\n+use super::MismatchedProjectionTypes;\n use super::Obligation;\n use super::ObligationCause;\n use super::PredicateObligation;\n use super::Selection;\n use super::SelectionContext;\n use super::SelectionError;\n+use super::{Normalized, ProjectionCacheEntry, ProjectionCacheKey};\n use super::{VtableClosureData, VtableFnPointerData, VtableGeneratorData, VtableImplData};\n \n use crate::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n@@ -18,7 +21,6 @@ use rustc::ty::fold::{TypeFoldable, TypeFolder};\n use rustc::ty::subst::{InternalSubsts, Subst};\n use rustc::ty::{self, ToPolyTraitRef, ToPredicate, Ty, TyCtxt, WithConstness};\n use rustc_ast::ast::Ident;\n-use rustc_data_structures::snapshot_map::{Snapshot, SnapshotMap};\n use rustc_hir::def_id::DefId;\n use rustc_span::symbol::sym;\n use rustc_span::DUMMY_SP;\n@@ -41,11 +43,6 @@ pub enum ProjectionTyError<'tcx> {\n     TraitSelectionError(SelectionError<'tcx>),\n }\n \n-#[derive(Clone)]\n-pub struct MismatchedProjectionTypes<'tcx> {\n-    pub err: ty::error::TypeError<'tcx>,\n-}\n-\n #[derive(PartialEq, Eq, Debug)]\n enum ProjectionTyCandidate<'tcx> {\n     // from a where-clause in the env or object type\n@@ -393,20 +390,6 @@ impl<'a, 'b, 'tcx> TypeFolder<'tcx> for AssocTypeNormalizer<'a, 'b, 'tcx> {\n     }\n }\n \n-#[derive(Clone, TypeFoldable)]\n-pub struct Normalized<'tcx, T> {\n-    pub value: T,\n-    pub obligations: Vec<PredicateObligation<'tcx>>,\n-}\n-\n-pub type NormalizedTy<'tcx> = Normalized<'tcx, Ty<'tcx>>;\n-\n-impl<'tcx, T> Normalized<'tcx, T> {\n-    pub fn with<U>(self, value: U) -> Normalized<'tcx, U> {\n-        Normalized { value, obligations: self.obligations }\n-    }\n-}\n-\n /// The guts of `normalize`: normalize a specific projection like `<T\n /// as Trait>::Item`. The result is always a type (and possibly\n /// additional obligations). If ambiguity arises, which implies that\n@@ -1500,47 +1483,6 @@ fn assoc_ty_def(\n     }\n }\n \n-// # Cache\n-\n-/// The projection cache. Unlike the standard caches, this can include\n-/// infcx-dependent type variables, therefore we have to roll the\n-/// cache back each time we roll a snapshot back, to avoid assumptions\n-/// on yet-unresolved inference variables. Types with placeholder\n-/// regions also have to be removed when the respective snapshot ends.\n-///\n-/// Because of that, projection cache entries can be \"stranded\" and left\n-/// inaccessible when type variables inside the key are resolved. We make no\n-/// attempt to recover or remove \"stranded\" entries, but rather let them be\n-/// (for the lifetime of the infcx).\n-///\n-/// Entries in the projection cache might contain inference variables\n-/// that will be resolved by obligations on the projection cache entry (e.g.,\n-/// when a type parameter in the associated type is constrained through\n-/// an \"RFC 447\" projection on the impl).\n-///\n-/// When working with a fulfillment context, the derived obligations of each\n-/// projection cache entry will be registered on the fulfillcx, so any users\n-/// that can wait for a fulfillcx fixed point need not care about this. However,\n-/// users that don't wait for a fixed point (e.g., trait evaluation) have to\n-/// resolve the obligations themselves to make sure the projected result is\n-/// ok and avoid issues like #43132.\n-///\n-/// If that is done, after evaluation the obligations, it is a good idea to\n-/// call `ProjectionCache::complete` to make sure the obligations won't be\n-/// re-evaluated and avoid an exponential worst-case.\n-//\n-// FIXME: we probably also want some sort of cross-infcx cache here to\n-// reduce the amount of duplication. Let's see what we get with the Chalk reforms.\n-#[derive(Default)]\n-pub struct ProjectionCache<'tcx> {\n-    map: SnapshotMap<ProjectionCacheKey<'tcx>, ProjectionCacheEntry<'tcx>>,\n-}\n-\n-#[derive(Copy, Clone, Debug, Hash, PartialEq, Eq)]\n-pub struct ProjectionCacheKey<'tcx> {\n-    ty: ty::ProjectionTy<'tcx>,\n-}\n-\n impl<'cx, 'tcx> ProjectionCacheKey<'tcx> {\n     pub fn from_poly_projection_predicate(\n         selcx: &mut SelectionContext<'cx, 'tcx>,\n@@ -1558,119 +1500,3 @@ impl<'cx, 'tcx> ProjectionCacheKey<'tcx> {\n         })\n     }\n }\n-\n-#[derive(Clone, Debug)]\n-enum ProjectionCacheEntry<'tcx> {\n-    InProgress,\n-    Ambiguous,\n-    Error,\n-    NormalizedTy(NormalizedTy<'tcx>),\n-}\n-\n-// N.B., intentionally not Clone\n-pub struct ProjectionCacheSnapshot {\n-    snapshot: Snapshot,\n-}\n-\n-impl<'tcx> ProjectionCache<'tcx> {\n-    pub fn clear(&mut self) {\n-        self.map.clear();\n-    }\n-\n-    pub fn snapshot(&mut self) -> ProjectionCacheSnapshot {\n-        ProjectionCacheSnapshot { snapshot: self.map.snapshot() }\n-    }\n-\n-    pub fn rollback_to(&mut self, snapshot: ProjectionCacheSnapshot) {\n-        self.map.rollback_to(snapshot.snapshot);\n-    }\n-\n-    pub fn rollback_placeholder(&mut self, snapshot: &ProjectionCacheSnapshot) {\n-        self.map.partial_rollback(&snapshot.snapshot, &|k| k.ty.has_re_placeholders());\n-    }\n-\n-    pub fn commit(&mut self, snapshot: ProjectionCacheSnapshot) {\n-        self.map.commit(snapshot.snapshot);\n-    }\n-\n-    /// Try to start normalize `key`; returns an error if\n-    /// normalization already occurred (this error corresponds to a\n-    /// cache hit, so it's actually a good thing).\n-    fn try_start(\n-        &mut self,\n-        key: ProjectionCacheKey<'tcx>,\n-    ) -> Result<(), ProjectionCacheEntry<'tcx>> {\n-        if let Some(entry) = self.map.get(&key) {\n-            return Err(entry.clone());\n-        }\n-\n-        self.map.insert(key, ProjectionCacheEntry::InProgress);\n-        Ok(())\n-    }\n-\n-    /// Indicates that `key` was normalized to `value`.\n-    fn insert_ty(&mut self, key: ProjectionCacheKey<'tcx>, value: NormalizedTy<'tcx>) {\n-        debug!(\n-            \"ProjectionCacheEntry::insert_ty: adding cache entry: key={:?}, value={:?}\",\n-            key, value\n-        );\n-        let fresh_key = self.map.insert(key, ProjectionCacheEntry::NormalizedTy(value));\n-        assert!(!fresh_key, \"never started projecting `{:?}`\", key);\n-    }\n-\n-    /// Mark the relevant projection cache key as having its derived obligations\n-    /// complete, so they won't have to be re-computed (this is OK to do in a\n-    /// snapshot - if the snapshot is rolled back, the obligations will be\n-    /// marked as incomplete again).\n-    pub fn complete(&mut self, key: ProjectionCacheKey<'tcx>) {\n-        let ty = match self.map.get(&key) {\n-            Some(&ProjectionCacheEntry::NormalizedTy(ref ty)) => {\n-                debug!(\"ProjectionCacheEntry::complete({:?}) - completing {:?}\", key, ty);\n-                ty.value\n-            }\n-            ref value => {\n-                // Type inference could \"strand behind\" old cache entries. Leave\n-                // them alone for now.\n-                debug!(\"ProjectionCacheEntry::complete({:?}) - ignoring {:?}\", key, value);\n-                return;\n-            }\n-        };\n-\n-        self.map.insert(\n-            key,\n-            ProjectionCacheEntry::NormalizedTy(Normalized { value: ty, obligations: vec![] }),\n-        );\n-    }\n-\n-    /// A specialized version of `complete` for when the key's value is known\n-    /// to be a NormalizedTy.\n-    pub fn complete_normalized(&mut self, key: ProjectionCacheKey<'tcx>, ty: &NormalizedTy<'tcx>) {\n-        // We want to insert `ty` with no obligations. If the existing value\n-        // already has no obligations (as is common) we don't insert anything.\n-        if !ty.obligations.is_empty() {\n-            self.map.insert(\n-                key,\n-                ProjectionCacheEntry::NormalizedTy(Normalized {\n-                    value: ty.value,\n-                    obligations: vec![],\n-                }),\n-            );\n-        }\n-    }\n-\n-    /// Indicates that trying to normalize `key` resulted in\n-    /// ambiguity. No point in trying it again then until we gain more\n-    /// type information (in which case, the \"fully resolved\" key will\n-    /// be different).\n-    fn ambiguous(&mut self, key: ProjectionCacheKey<'tcx>) {\n-        let fresh = self.map.insert(key, ProjectionCacheEntry::Ambiguous);\n-        assert!(!fresh, \"never started projecting `{:?}`\", key);\n-    }\n-\n-    /// Indicates that trying to normalize `key` resulted in\n-    /// error.\n-    fn error(&mut self, key: ProjectionCacheKey<'tcx>) {\n-        let fresh = self.map.insert(key, ProjectionCacheEntry::Error);\n-        assert!(!fresh, \"never started projecting `{:?}`\", key);\n-    }\n-}"}, {"sha": "fb7b5fdb8eacb37974afff2441096085c4edf5ba", "filename": "src/librustc_infer/traits/projection_cache.rs", "status": "added", "additions": 185, "deletions": 0, "changes": 185, "blob_url": "https://github.com/rust-lang/rust/blob/21d4e063bca7d9f5a5d0f705e0f11092cbf2cf98/src%2Flibrustc_infer%2Ftraits%2Fprojection_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21d4e063bca7d9f5a5d0f705e0f11092cbf2cf98/src%2Flibrustc_infer%2Ftraits%2Fprojection_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Ftraits%2Fprojection_cache.rs?ref=21d4e063bca7d9f5a5d0f705e0f11092cbf2cf98", "patch": "@@ -0,0 +1,185 @@\n+//! Code for projecting associated types out of trait references.\n+\n+use super::PredicateObligation;\n+\n+use rustc::ty::fold::TypeFoldable;\n+use rustc::ty::{self, Ty};\n+use rustc_data_structures::snapshot_map::{Snapshot, SnapshotMap};\n+\n+pub use rustc::traits::Reveal;\n+\n+#[derive(Clone)]\n+pub struct MismatchedProjectionTypes<'tcx> {\n+    pub err: ty::error::TypeError<'tcx>,\n+}\n+\n+#[derive(Clone, TypeFoldable)]\n+pub struct Normalized<'tcx, T> {\n+    pub value: T,\n+    pub obligations: Vec<PredicateObligation<'tcx>>,\n+}\n+\n+pub type NormalizedTy<'tcx> = Normalized<'tcx, Ty<'tcx>>;\n+\n+impl<'tcx, T> Normalized<'tcx, T> {\n+    pub fn with<U>(self, value: U) -> Normalized<'tcx, U> {\n+        Normalized { value: value, obligations: self.obligations }\n+    }\n+}\n+\n+// # Cache\n+\n+/// The projection cache. Unlike the standard caches, this can include\n+/// infcx-dependent type variables, therefore we have to roll the\n+/// cache back each time we roll a snapshot back, to avoid assumptions\n+/// on yet-unresolved inference variables. Types with placeholder\n+/// regions also have to be removed when the respective snapshot ends.\n+///\n+/// Because of that, projection cache entries can be \"stranded\" and left\n+/// inaccessible when type variables inside the key are resolved. We make no\n+/// attempt to recover or remove \"stranded\" entries, but rather let them be\n+/// (for the lifetime of the infcx).\n+///\n+/// Entries in the projection cache might contain inference variables\n+/// that will be resolved by obligations on the projection cache entry (e.g.,\n+/// when a type parameter in the associated type is constrained through\n+/// an \"RFC 447\" projection on the impl).\n+///\n+/// When working with a fulfillment context, the derived obligations of each\n+/// projection cache entry will be registered on the fulfillcx, so any users\n+/// that can wait for a fulfillcx fixed point need not care about this. However,\n+/// users that don't wait for a fixed point (e.g., trait evaluation) have to\n+/// resolve the obligations themselves to make sure the projected result is\n+/// ok and avoid issues like #43132.\n+///\n+/// If that is done, after evaluation the obligations, it is a good idea to\n+/// call `ProjectionCache::complete` to make sure the obligations won't be\n+/// re-evaluated and avoid an exponential worst-case.\n+//\n+// FIXME: we probably also want some sort of cross-infcx cache here to\n+// reduce the amount of duplication. Let's see what we get with the Chalk reforms.\n+#[derive(Default)]\n+pub struct ProjectionCache<'tcx> {\n+    map: SnapshotMap<ProjectionCacheKey<'tcx>, ProjectionCacheEntry<'tcx>>,\n+}\n+\n+#[derive(Copy, Clone, Debug, Hash, PartialEq, Eq)]\n+pub struct ProjectionCacheKey<'tcx> {\n+    pub ty: ty::ProjectionTy<'tcx>,\n+}\n+\n+#[derive(Clone, Debug)]\n+pub enum ProjectionCacheEntry<'tcx> {\n+    InProgress,\n+    Ambiguous,\n+    Error,\n+    NormalizedTy(NormalizedTy<'tcx>),\n+}\n+\n+// N.B., intentionally not Clone\n+pub struct ProjectionCacheSnapshot {\n+    snapshot: Snapshot,\n+}\n+\n+impl<'tcx> ProjectionCache<'tcx> {\n+    pub fn clear(&mut self) {\n+        self.map.clear();\n+    }\n+\n+    pub fn snapshot(&mut self) -> ProjectionCacheSnapshot {\n+        ProjectionCacheSnapshot { snapshot: self.map.snapshot() }\n+    }\n+\n+    pub fn rollback_to(&mut self, snapshot: ProjectionCacheSnapshot) {\n+        self.map.rollback_to(snapshot.snapshot);\n+    }\n+\n+    pub fn rollback_placeholder(&mut self, snapshot: &ProjectionCacheSnapshot) {\n+        self.map.partial_rollback(&snapshot.snapshot, &|k| k.ty.has_re_placeholders());\n+    }\n+\n+    pub fn commit(&mut self, snapshot: ProjectionCacheSnapshot) {\n+        self.map.commit(snapshot.snapshot);\n+    }\n+\n+    /// Try to start normalize `key`; returns an error if\n+    /// normalization already occurred (this error corresponds to a\n+    /// cache hit, so it's actually a good thing).\n+    pub fn try_start(\n+        &mut self,\n+        key: ProjectionCacheKey<'tcx>,\n+    ) -> Result<(), ProjectionCacheEntry<'tcx>> {\n+        if let Some(entry) = self.map.get(&key) {\n+            return Err(entry.clone());\n+        }\n+\n+        self.map.insert(key, ProjectionCacheEntry::InProgress);\n+        Ok(())\n+    }\n+\n+    /// Indicates that `key` was normalized to `value`.\n+    pub fn insert_ty(&mut self, key: ProjectionCacheKey<'tcx>, value: NormalizedTy<'tcx>) {\n+        debug!(\n+            \"ProjectionCacheEntry::insert_ty: adding cache entry: key={:?}, value={:?}\",\n+            key, value\n+        );\n+        let fresh_key = self.map.insert(key, ProjectionCacheEntry::NormalizedTy(value));\n+        assert!(!fresh_key, \"never started projecting `{:?}`\", key);\n+    }\n+\n+    /// Mark the relevant projection cache key as having its derived obligations\n+    /// complete, so they won't have to be re-computed (this is OK to do in a\n+    /// snapshot - if the snapshot is rolled back, the obligations will be\n+    /// marked as incomplete again).\n+    pub fn complete(&mut self, key: ProjectionCacheKey<'tcx>) {\n+        let ty = match self.map.get(&key) {\n+            Some(&ProjectionCacheEntry::NormalizedTy(ref ty)) => {\n+                debug!(\"ProjectionCacheEntry::complete({:?}) - completing {:?}\", key, ty);\n+                ty.value\n+            }\n+            ref value => {\n+                // Type inference could \"strand behind\" old cache entries. Leave\n+                // them alone for now.\n+                debug!(\"ProjectionCacheEntry::complete({:?}) - ignoring {:?}\", key, value);\n+                return;\n+            }\n+        };\n+\n+        self.map.insert(\n+            key,\n+            ProjectionCacheEntry::NormalizedTy(Normalized { value: ty, obligations: vec![] }),\n+        );\n+    }\n+\n+    /// A specialized version of `complete` for when the key's value is known\n+    /// to be a NormalizedTy.\n+    pub fn complete_normalized(&mut self, key: ProjectionCacheKey<'tcx>, ty: &NormalizedTy<'tcx>) {\n+        // We want to insert `ty` with no obligations. If the existing value\n+        // already has no obligations (as is common) we don't insert anything.\n+        if !ty.obligations.is_empty() {\n+            self.map.insert(\n+                key,\n+                ProjectionCacheEntry::NormalizedTy(Normalized {\n+                    value: ty.value,\n+                    obligations: vec![],\n+                }),\n+            );\n+        }\n+    }\n+\n+    /// Indicates that trying to normalize `key` resulted in\n+    /// ambiguity. No point in trying it again then until we gain more\n+    /// type information (in which case, the \"fully resolved\" key will\n+    /// be different).\n+    pub fn ambiguous(&mut self, key: ProjectionCacheKey<'tcx>) {\n+        let fresh = self.map.insert(key, ProjectionCacheEntry::Ambiguous);\n+        assert!(!fresh, \"never started projecting `{:?}`\", key);\n+    }\n+\n+    /// Indicates that trying to normalize `key` resulted in\n+    /// error.\n+    pub fn error(&mut self, key: ProjectionCacheKey<'tcx>) {\n+        let fresh = self.map.insert(key, ProjectionCacheEntry::Error);\n+        assert!(!fresh, \"never started projecting `{:?}`\", key);\n+    }\n+}"}, {"sha": "365bf9e295b56a95e01e8f89ad4d1b78e84a6a92", "filename": "src/librustc_infer/traits/query/normalize.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/21d4e063bca7d9f5a5d0f705e0f11092cbf2cf98/src%2Flibrustc_infer%2Ftraits%2Fquery%2Fnormalize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21d4e063bca7d9f5a5d0f705e0f11092cbf2cf98/src%2Flibrustc_infer%2Ftraits%2Fquery%2Fnormalize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Ftraits%2Fquery%2Fnormalize.rs?ref=21d4e063bca7d9f5a5d0f705e0f11092cbf2cf98", "patch": "@@ -5,7 +5,7 @@\n use crate::infer::at::At;\n use crate::infer::canonical::OriginalQueryValues;\n use crate::infer::{InferCtxt, InferOk};\n-use crate::traits::project::Normalized;\n+use crate::traits::Normalized;\n use crate::traits::{Obligation, ObligationCause, PredicateObligation, Reveal};\n use rustc::ty::fold::{TypeFoldable, TypeFolder};\n use rustc::ty::subst::Subst;"}, {"sha": "12f39b12c7268b18a5960322f6821a2f709bba03", "filename": "src/librustc_infer/traits/select.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/21d4e063bca7d9f5a5d0f705e0f11092cbf2cf98/src%2Flibrustc_infer%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21d4e063bca7d9f5a5d0f705e0f11092cbf2cf98/src%2Flibrustc_infer%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Ftraits%2Fselect.rs?ref=21d4e063bca7d9f5a5d0f705e0f11092cbf2cf98", "patch": "@@ -9,9 +9,7 @@ use self::SelectionCandidate::*;\n \n use super::coherence::{self, Conflict};\n use super::project;\n-use super::project::{\n-    normalize_with_depth, normalize_with_depth_to, Normalized, ProjectionCacheKey,\n-};\n+use super::project::{normalize_with_depth, normalize_with_depth_to};\n use super::util;\n use super::util::{closure_trait_ref_and_return_type, predicate_for_trait_def};\n use super::wf;\n@@ -21,6 +19,7 @@ use super::SelectionResult;\n use super::TraitNotObjectSafe;\n use super::TraitQueryMode;\n use super::{BuiltinDerivedObligation, ImplDerivedObligation, ObligationCauseCode};\n+use super::{Normalized, ProjectionCacheKey};\n use super::{ObjectCastObligation, Obligation};\n use super::{ObligationCause, PredicateObligation, TraitObligation};\n use super::{OutputTypeParameterMismatch, Overflow, SelectionError, Unimplemented};"}, {"sha": "a164995255a9dfed331afb8144b770a64839466e", "filename": "src/librustc_infer/traits/structural_impls.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/21d4e063bca7d9f5a5d0f705e0f11092cbf2cf98/src%2Flibrustc_infer%2Ftraits%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21d4e063bca7d9f5a5d0f705e0f11092cbf2cf98/src%2Flibrustc_infer%2Ftraits%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Ftraits%2Fstructural_impls.rs?ref=21d4e063bca7d9f5a5d0f705e0f11092cbf2cf98", "patch": "@@ -1,5 +1,5 @@\n use crate::traits;\n-use crate::traits::project::Normalized;\n+use crate::traits::Normalized;\n use rustc::ty;\n use rustc::ty::fold::{TypeFoldable, TypeFolder, TypeVisitor};\n "}]}