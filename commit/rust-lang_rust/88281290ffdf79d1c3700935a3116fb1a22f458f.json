{"sha": "88281290ffdf79d1c3700935a3116fb1a22f458f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg4MjgxMjkwZmZkZjc5ZDFjMzcwMDkzNWEzMTE2ZmIxYTIyZjQ1OGY=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-12-31T02:57:48Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2014-01-03T22:02:01Z"}, "message": "librustc: Remove `@mut` support from the typechecker and borrow checker", "tree": {"sha": "0f9c80d8fb0da39f1f132f80adc454c17e7c81fb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0f9c80d8fb0da39f1f132f80adc454c17e7c81fb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/88281290ffdf79d1c3700935a3116fb1a22f458f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/88281290ffdf79d1c3700935a3116fb1a22f458f", "html_url": "https://github.com/rust-lang/rust/commit/88281290ffdf79d1c3700935a3116fb1a22f458f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/88281290ffdf79d1c3700935a3116fb1a22f458f/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9b35ae75d2e275e6dbc4b93061f7b16c4efb5b19", "url": "https://api.github.com/repos/rust-lang/rust/commits/9b35ae75d2e275e6dbc4b93061f7b16c4efb5b19", "html_url": "https://github.com/rust-lang/rust/commit/9b35ae75d2e275e6dbc4b93061f7b16c4efb5b19"}], "stats": {"total": 634, "additions": 171, "deletions": 463}, "files": [{"sha": "02bcabbf3e633df7b4681cea9322d94fe3041477", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/88281290ffdf79d1c3700935a3116fb1a22f458f/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88281290ffdf79d1c3700935a3116fb1a22f458f/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=88281290ffdf79d1c3700935a3116fb1a22f458f", "patch": "@@ -295,7 +295,7 @@ pub fn phase_3_run_analysis_passes(sess: Session,\n          middle::liveness::check_crate(ty_cx, method_map,\n                                        capture_map, crate));\n \n-    let (root_map, write_guard_map) =\n+    let root_map =\n         time(time_passes, \"borrow checking\", (), |_|\n              middle::borrowck::check_crate(ty_cx, method_map,\n                                            moves_map, moved_variables_set,\n@@ -330,7 +330,6 @@ pub fn phase_3_run_analysis_passes(sess: Session,\n             root_map: root_map,\n             method_map: method_map,\n             vtable_map: vtable_map,\n-            write_guard_map: write_guard_map,\n             capture_map: capture_map\n         },\n         reachable: reachable_map"}, {"sha": "f0cb4533968855352a5d13f352aea658ce68b60f", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/88281290ffdf79d1c3700935a3116fb1a22f458f/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88281290ffdf79d1c3700935a3116fb1a22f458f/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=88281290ffdf79d1c3700935a3116fb1a22f458f", "patch": "@@ -342,7 +342,7 @@ fn parse_ty(st: &mut PState, conv: conv_did) -> ty::t {\n         let did = parse_def(st, TypeParameter, |x,y| conv(x,y));\n         return ty::mk_self(st.tcx, did);\n       }\n-      '@' => return ty::mk_box(st.tcx, parse_mt(st, |x,y| conv(x,y))),\n+      '@' => return ty::mk_box(st.tcx, parse_ty(st, |x,y| conv(x,y))),\n       '~' => return ty::mk_uniq(st.tcx, parse_mt(st, |x,y| conv(x,y))),\n       '*' => return ty::mk_ptr(st.tcx, parse_mt(st, |x,y| conv(x,y))),\n       '&' => {"}, {"sha": "2ba4038e5b4404a89e6b9143f8eeb911baa07929", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/88281290ffdf79d1c3700935a3116fb1a22f458f/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88281290ffdf79d1c3700935a3116fb1a22f458f/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=88281290ffdf79d1c3700935a3116fb1a22f458f", "patch": "@@ -292,7 +292,7 @@ fn enc_sty(w: &mut MemWriter, cx: @ctxt, st: &ty::sty) {\n             for t in ts.iter() { enc_ty(w, cx, *t); }\n             mywrite!(w, \"]\");\n         }\n-        ty::ty_box(mt) => { mywrite!(w, \"@\"); enc_mt(w, cx, mt); }\n+        ty::ty_box(typ) => { mywrite!(w, \"@\"); enc_ty(w, cx, typ); }\n         ty::ty_uniq(mt) => { mywrite!(w, \"~\"); enc_mt(w, cx, mt); }\n         ty::ty_ptr(mt) => { mywrite!(w, \"*\"); enc_mt(w, cx, mt); }\n         ty::ty_rptr(r, mt) => {"}, {"sha": "2e18b9a7244822581e705a1b397d76f937519389", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/88281290ffdf79d1c3700935a3116fb1a22f458f/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88281290ffdf79d1c3700935a3116fb1a22f458f/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=88281290ffdf79d1c3700935a3116fb1a22f458f", "patch": "@@ -55,7 +55,6 @@ pub struct Maps {\n     root_map: middle::borrowck::root_map,\n     method_map: middle::typeck::method_map,\n     vtable_map: middle::typeck::vtable_map,\n-    write_guard_map: middle::borrowck::write_guard_map,\n     capture_map: middle::moves::CaptureMap,\n }\n "}, {"sha": "c26efbcb498962e29b7d16274d9b05f37e31fe7d", "filename": "src/librustc/middle/borrowck/check_loans.rs", "status": "modified", "additions": 6, "deletions": 16, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/88281290ffdf79d1c3700935a3116fb1a22f458f/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88281290ffdf79d1c3700935a3116fb1a22f458f/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs?ref=88281290ffdf79d1c3700935a3116fb1a22f458f", "patch": "@@ -368,11 +368,15 @@ impl<'a> CheckLoanCtxt<'a> {\n                         cmt = b;\n                     }\n \n+                    mc::cat_deref(_, _, mc::gc_ptr) => {\n+                        assert_eq!(cmt.mutbl, mc::McImmutable);\n+                        return;\n+                    }\n+\n                     mc::cat_rvalue(..) |\n                     mc::cat_static_item |\n                     mc::cat_copied_upvar(..) |\n                     mc::cat_deref(_, _, mc::unsafe_ptr(..)) |\n-                    mc::cat_deref(_, _, mc::gc_ptr(..)) |\n                     mc::cat_deref(_, _, mc::region_ptr(..)) => {\n                         assert_eq!(cmt.mutbl, mc::McDeclared);\n                         return;\n@@ -411,20 +415,6 @@ impl<'a> CheckLoanCtxt<'a> {\n                     check_for_aliasability_violation(this, expr, b);\n                 }\n \n-                mc::cat_deref(_, deref_count, mc::gc_ptr(ast::MutMutable)) => {\n-                    // Dynamically check writes to `@mut`\n-\n-                    let key = root_map_key {\n-                        id: guarantor.id,\n-                        derefs: deref_count\n-                    };\n-                    debug!(\"Inserting write guard at {:?}\", key);\n-                    let mut write_guard_map = this.bccx\n-                                                  .write_guard_map\n-                                                  .borrow_mut();\n-                    write_guard_map.get().insert(key);\n-                }\n-\n                 _ => {}\n             }\n \n@@ -455,7 +445,7 @@ impl<'a> CheckLoanCtxt<'a> {\n                     mc::cat_self(..) |\n                     mc::cat_deref(_, _, mc::unsafe_ptr(..)) |\n                     mc::cat_static_item(..) |\n-                    mc::cat_deref(_, _, mc::gc_ptr(_)) |\n+                    mc::cat_deref(_, _, mc::gc_ptr) |\n                     mc::cat_deref(_, _, mc::region_ptr(MutImmutable, _)) => {\n                         // Aliasability is independent of base cmt\n                         match cmt.freely_aliasable() {"}, {"sha": "3b16d7e7e1c63c4eba7748729391f9cbf2e0d855", "filename": "src/librustc/middle/borrowck/gather_loans/gather_moves.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/88281290ffdf79d1c3700935a3116fb1a22f458f/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88281290ffdf79d1c3700935a3116fb1a22f458f/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fgather_moves.rs?ref=88281290ffdf79d1c3700935a3116fb1a22f458f", "patch": "@@ -102,7 +102,7 @@ fn check_is_legal_to_move_from(bccx: &BorrowckCtxt,\n                                cmt: mc::cmt) -> bool {\n     match cmt.cat {\n         mc::cat_deref(_, _, mc::region_ptr(..)) |\n-        mc::cat_deref(_, _, mc::gc_ptr(..)) |\n+        mc::cat_deref(_, _, mc::gc_ptr) |\n         mc::cat_deref(_, _, mc::unsafe_ptr(..)) |\n         mc::cat_stack_upvar(..) |\n         mc::cat_copied_upvar(mc::CopiedUpvar { onceness: ast::Many, .. }) => {"}, {"sha": "9a56ec52cce289140cd6a27f49b51f9e4a13ae12", "filename": "src/librustc/middle/borrowck/gather_loans/lifetime.rs", "status": "modified", "additions": 5, "deletions": 40, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/88281290ffdf79d1c3700935a3116fb1a22f458f/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Flifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88281290ffdf79d1c3700935a3116fb1a22f458f/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Flifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Flifetime.rs?ref=88281290ffdf79d1c3700935a3116fb1a22f458f", "patch": "@@ -16,10 +16,8 @@\n use middle::borrowck::*;\n use mc = middle::mem_categorization;\n use middle::ty;\n-use syntax::ast::{MutImmutable, MutMutable};\n use syntax::ast;\n use syntax::codemap::Span;\n-use util::ppaux::{note_and_explain_region};\n \n type R = Result<(),()>;\n \n@@ -89,12 +87,11 @@ impl<'a> GuaranteeLifetimeContext<'a> {\n                 Ok(())\n             }\n \n-            mc::cat_deref(base, derefs, mc::gc_ptr(ptr_mutbl)) => {\n+            mc::cat_deref(base, derefs, mc::gc_ptr) => {\n                 let base_scope = self.scope(base);\n \n                 // L-Deref-Managed-Imm-User-Root\n                 let omit_root = (\n-                    ptr_mutbl == MutImmutable &&\n                     self.bccx.is_subregion_of(self.loan_region, base_scope) &&\n                     self.is_rvalue_or_immutable(base) &&\n                     !self.is_moved(base)\n@@ -103,7 +100,7 @@ impl<'a> GuaranteeLifetimeContext<'a> {\n                 if !omit_root {\n                     // L-Deref-Managed-Imm-Compiler-Root\n                     // L-Deref-Managed-Mut-Compiler-Root\n-                    self.check_root(cmt, base, derefs, ptr_mutbl, discr_scope)\n+                    self.check_root(cmt, base, derefs, discr_scope)\n                 } else {\n                     debug!(\"omitting root, base={}, base_scope={:?}\",\n                            base.repr(self.tcx()), base_scope);\n@@ -192,14 +189,12 @@ impl<'a> GuaranteeLifetimeContext<'a> {\n                   cmt_deref: mc::cmt,\n                   cmt_base: mc::cmt,\n                   derefs: uint,\n-                  ptr_mutbl: ast::Mutability,\n                   discr_scope: Option<ast::NodeId>) -> R {\n-        debug!(\"check_root(cmt_deref={}, cmt_base={}, derefs={:?}, ptr_mutbl={:?}, \\\n+        debug!(\"check_root(cmt_deref={}, cmt_base={}, derefs={:?}, \\\n                 discr_scope={:?})\",\n                cmt_deref.repr(self.tcx()),\n                cmt_base.repr(self.tcx()),\n                derefs,\n-               ptr_mutbl,\n                discr_scope);\n \n         // Make sure that the loan does not exceed the maximum time\n@@ -235,19 +230,6 @@ impl<'a> GuaranteeLifetimeContext<'a> {\n             }\n         };\n \n-        // If we are borrowing the inside of an `@mut` box,\n-        // we need to dynamically mark it to prevent incompatible\n-        // borrows from happening later.\n-        let opt_dyna = match ptr_mutbl {\n-            MutImmutable => None,\n-            MutMutable => {\n-                match self.loan_mutbl {\n-                    MutableMutability => Some(DynaMut),\n-                    ImmutableMutability | ConstMutability => Some(DynaImm)\n-                }\n-            }\n-        };\n-\n         // FIXME(#3511) grow to the nearest cleanup scope---this can\n         // cause observable errors if freezing!\n         if !self.bccx.tcx.region_maps.is_cleanup_scope(root_scope) {\n@@ -256,29 +238,12 @@ impl<'a> GuaranteeLifetimeContext<'a> {\n             let cleanup_scope =\n                 self.bccx.tcx.region_maps.cleanup_scope(root_scope);\n \n-            if opt_dyna.is_some() {\n-                self.tcx().sess.span_warn(\n-                    self.span,\n-                    format!(\"Dynamic freeze scope artifically extended \\\n-                          (see Issue \\\\#6248)\"));\n-                note_and_explain_region(\n-                    self.bccx.tcx,\n-                    \"managed value only needs to be frozen for \",\n-                    ty::ReScope(root_scope),\n-                    \"...\");\n-                note_and_explain_region(\n-                    self.bccx.tcx,\n-                    \"...but due to Issue #6248, it will be frozen for \",\n-                    ty::ReScope(cleanup_scope),\n-                    \"\");\n-            }\n-\n             root_scope = cleanup_scope;\n         }\n \n         // Add a record of what is required\n         let rm_key = root_map_key {id: cmt_deref.id, derefs: derefs};\n-        let root_info = RootInfo {scope: root_scope, freeze: opt_dyna};\n+        let root_info = RootInfo {scope: root_scope};\n \n         let mut root_map = self.bccx.root_map.borrow_mut();\n         root_map.get().insert(rm_key, root_info);\n@@ -357,7 +322,7 @@ impl<'a> GuaranteeLifetimeContext<'a> {\n             }\n             mc::cat_downcast(cmt) |\n             mc::cat_deref(cmt, _, mc::uniq_ptr) |\n-            mc::cat_deref(cmt, _, mc::gc_ptr(..)) |\n+            mc::cat_deref(cmt, _, mc::gc_ptr) |\n             mc::cat_interior(cmt, _) |\n             mc::cat_stack_upvar(cmt) |\n             mc::cat_discr(cmt, _) => {"}, {"sha": "50b437e95d5d16f5e94064a99b6fb9f6bd556bf7", "filename": "src/librustc/middle/borrowck/gather_loans/restrictions.rs", "status": "modified", "additions": 1, "deletions": 49, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/88281290ffdf79d1c3700935a3116fb1a22f458f/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Frestrictions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88281290ffdf79d1c3700935a3116fb1a22f458f/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Frestrictions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Frestrictions.rs?ref=88281290ffdf79d1c3700935a3116fb1a22f458f", "patch": "@@ -132,59 +132,11 @@ impl<'a> RestrictionsContext<'a> {\n                 Safe\n             }\n \n-            mc::cat_deref(_, _, mc::gc_ptr(MutImmutable)) => {\n+            mc::cat_deref(_, _, mc::gc_ptr) => {\n                 // R-Deref-Imm-Managed\n                 Safe\n             }\n \n-            mc::cat_deref(cmt_base, _, pk @ mc::gc_ptr(MutMutable)) => {\n-                // R-Deref-Managed-Borrowed\n-                //\n-                // Technically, no restrictions are *necessary* here.\n-                // The validity of the borrow is guaranteed\n-                // dynamically.  However, nonetheless we add a\n-                // restriction to make a \"best effort\" to report\n-                // static errors. For example, if there is code like\n-                //\n-                //    let v = @mut ~[1, 2, 3];\n-                //    for e in v.iter() {\n-                //        v.push(e + 1);\n-                //    }\n-                //\n-                // Then the code below would add restrictions on `*v`,\n-                // which means that an error would be reported\n-                // here. This of course is not perfect. For example,\n-                // a function like the following would not report an error\n-                // at compile-time but would fail dynamically:\n-                //\n-                //    let v = @mut ~[1, 2, 3];\n-                //    let w = v;\n-                //    for e in v.iter() {\n-                //        w.push(e + 1);\n-                //    }\n-                //\n-                // In addition, we only add a restriction for those cases\n-                // where we can construct a sensible loan path, so an\n-                // example like the following will fail dynamically:\n-                //\n-                //    impl V {\n-                //      fn get_list(&self) -> @mut ~[int];\n-                //    }\n-                //    ...\n-                //    let v: &V = ...;\n-                //    for e in v.get_list().iter() {\n-                //        v.get_list().push(e + 1);\n-                //    }\n-                match opt_loan_path(cmt_base) {\n-                    None => Safe,\n-                    Some(lp_base) => {\n-                        let lp = @LpExtend(lp_base, cmt.mutbl, LpDeref(pk));\n-                        SafeIf(lp, ~[Restriction {loan_path: lp,\n-                                                  set: restrictions}])\n-                    }\n-                }\n-            }\n-\n             mc::cat_deref(cmt_base, _, pk @ mc::region_ptr(MutMutable, lt)) => {\n                 // R-Deref-Mut-Borrowed\n                 if !self.bccx.is_subregion_of(self.loan_region, lt) {"}, {"sha": "6193c6fc898822c24874d41e5f9a0a78bd1ec35c", "filename": "src/librustc/middle/borrowck/mod.rs", "status": "modified", "additions": 12, "deletions": 45, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/88281290ffdf79d1c3700935a3116fb1a22f458f/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88281290ffdf79d1c3700935a3116fb1a22f458f/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs?ref=88281290ffdf79d1c3700935a3116fb1a22f458f", "patch": "@@ -20,7 +20,7 @@ use middle::dataflow::DataFlowOperator;\n use util::ppaux::{note_and_explain_region, Repr, UserString};\n \n use std::cell::{Cell, RefCell};\n-use std::hashmap::{HashSet, HashMap};\n+use std::hashmap::HashMap;\n use std::ops::{BitOr, BitAnd};\n use std::result::{Result};\n use syntax::ast;\n@@ -67,22 +67,20 @@ impl Visitor<()> for BorrowckCtxt {\n     }\n }\n \n-pub fn check_crate(\n-    tcx: ty::ctxt,\n-    method_map: typeck::method_map,\n-    moves_map: moves::MovesMap,\n-    moved_variables_set: moves::MovedVariablesSet,\n-    capture_map: moves::CaptureMap,\n-    crate: &ast::Crate) -> (root_map, write_guard_map)\n-{\n+pub fn check_crate(tcx: ty::ctxt,\n+                   method_map: typeck::method_map,\n+                   moves_map: moves::MovesMap,\n+                   moved_variables_set: moves::MovedVariablesSet,\n+                   capture_map: moves::CaptureMap,\n+                   crate: &ast::Crate)\n+                   -> root_map {\n     let mut bccx = BorrowckCtxt {\n         tcx: tcx,\n         method_map: method_map,\n         moves_map: moves_map,\n         moved_variables_set: moved_variables_set,\n         capture_map: capture_map,\n         root_map: root_map(),\n-        write_guard_map: @RefCell::new(HashSet::new()),\n         stats: @BorrowStats {\n             loaned_paths_same: Cell::new(0),\n             loaned_paths_imm: Cell::new(0),\n@@ -106,7 +104,7 @@ pub fn check_crate(\n                  make_stat(bccx, bccx.stats.stable_paths.get()));\n     }\n \n-    return (bccx.root_map, bccx.write_guard_map);\n+    return bccx.root_map;\n \n     fn make_stat(bccx: &mut BorrowckCtxt, stat: uint) -> ~str {\n         let stat_f = stat as f64;\n@@ -171,7 +169,6 @@ pub struct BorrowckCtxt {\n     moved_variables_set: moves::MovedVariablesSet,\n     capture_map: moves::CaptureMap,\n     root_map: root_map,\n-    write_guard_map: write_guard_map,\n \n     // Statistics:\n     stats: @BorrowStats\n@@ -213,10 +210,6 @@ pub struct root_map_key {\n     derefs: uint\n }\n \n-// A set containing IDs of expressions of gc'd type that need to have a write\n-// guard.\n-pub type write_guard_map = @RefCell<HashSet<root_map_key>>;\n-\n pub type BckResult<T> = Result<T, BckError>;\n \n #[deriving(Eq)]\n@@ -402,7 +395,6 @@ impl BitAnd<RestrictionSet,RestrictionSet> for RestrictionSet {\n \n pub struct RootInfo {\n     scope: ast::NodeId,\n-    freeze: Option<DynaFreezeKind> // Some() if we should freeze box at runtime\n }\n \n pub type root_map = @RefCell<HashMap<root_map_key, RootInfo>>;\n@@ -411,20 +403,6 @@ pub fn root_map() -> root_map {\n     return @RefCell::new(HashMap::new());\n }\n \n-pub enum DynaFreezeKind {\n-    DynaImm,\n-    DynaMut\n-}\n-\n-impl ToStr for DynaFreezeKind {\n-    fn to_str(&self) -> ~str {\n-        match *self {\n-            DynaMut => ~\"mutable\",\n-            DynaImm => ~\"immutable\"\n-        }\n-    }\n-}\n-\n ///////////////////////////////////////////////////////////////////////////\n // Errors\n \n@@ -691,20 +669,9 @@ impl BorrowckCtxt {\n                     span,\n                     format!(\"{} in an aliasable location\", prefix));\n             }\n-            mc::AliasableManaged(ast::MutMutable) => {\n-                // FIXME(#6269) reborrow @mut to &mut\n-                self.tcx.sess.span_err(\n-                    span,\n-                    format!(\"{} in a `@mut` pointer; \\\n-                          try borrowing as `&mut` first\", prefix));\n-            }\n-            mc::AliasableManaged(m) => {\n-                self.tcx.sess.span_err(\n-                    span,\n-                    format!(\"{} in a `@{}` pointer; \\\n-                          try an `@mut` instead\",\n-                         prefix,\n-                         self.mut_to_keyword(m)));\n+            mc::AliasableManaged => {\n+                self.tcx.sess.span_err(span, format!(\"{} in a `@` pointer\",\n+                                                     prefix))\n             }\n             mc::AliasableBorrowed(m) => {\n                 self.tcx.sess.span_err("}, {"sha": "e7dddd18aeefb4919cb1f9ab3ed053a93ea2bdbd", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/88281290ffdf79d1c3700935a3116fb1a22f458f/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88281290ffdf79d1c3700935a3116fb1a22f458f/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=88281290ffdf79d1c3700935a3116fb1a22f458f", "patch": "@@ -20,7 +20,7 @@ use syntax::visit::Visitor;\n use syntax::ast::*;\n \n use std::cell::RefCell;\n-use std::hashmap::{HashMap, HashSet};\n+use std::hashmap::HashMap;\n \n //\n // This pass classifies expressions by their constant-ness.\n@@ -132,7 +132,6 @@ pub fn lookup_variant_by_id(tcx: ty::ctxt,\n             root_map: @RefCell::new(HashMap::new()),\n             method_map: @RefCell::new(HashMap::new()),\n             vtable_map: @RefCell::new(HashMap::new()),\n-            write_guard_map: @RefCell::new(HashSet::new()),\n             capture_map: @RefCell::new(HashMap::new())\n         };\n         let e = match csearch::maybe_get_item_ast(tcx, enum_def,\n@@ -186,7 +185,6 @@ pub fn lookup_const_by_id(tcx: ty::ctxt, def_id: ast::DefId)\n             root_map: @RefCell::new(HashMap::new()),\n             method_map: @RefCell::new(HashMap::new()),\n             vtable_map: @RefCell::new(HashMap::new()),\n-            write_guard_map: @RefCell::new(HashSet::new()),\n             capture_map: @RefCell::new(HashMap::new())\n         };\n         let e = match csearch::maybe_get_item_ast(tcx, def_id,"}, {"sha": "8e86fa4611f2b15f4a7def3fbc870221ba864aa7", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 9, "deletions": 15, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/88281290ffdf79d1c3700935a3116fb1a22f458f/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88281290ffdf79d1c3700935a3116fb1a22f458f/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=88281290ffdf79d1c3700935a3116fb1a22f458f", "patch": "@@ -207,7 +207,7 @@ pub fn collect_language_items(crate: &ast::Crate,\n }\n \n lets_do_this! {\n-    There are 43 lang items.\n+    There are 37 lang items.\n \n //  ID, Variant name,                    Name,                      Method name;\n     0,  FreezeTraitLangItem,             \"freeze\",                  freeze_trait;\n@@ -243,24 +243,18 @@ lets_do_this! {\n     26, ExchangeFreeFnLangItem,          \"exchange_free\",           exchange_free_fn;\n     27, MallocFnLangItem,                \"malloc\",                  malloc_fn;\n     28, FreeFnLangItem,                  \"free\",                    free_fn;\n-    29, BorrowAsImmFnLangItem,           \"borrow_as_imm\",           borrow_as_imm_fn;\n-    30, BorrowAsMutFnLangItem,           \"borrow_as_mut\",           borrow_as_mut_fn;\n-    31, ReturnToMutFnLangItem,           \"return_to_mut\",           return_to_mut_fn;\n-    32, CheckNotBorrowedFnLangItem,      \"check_not_borrowed\",      check_not_borrowed_fn;\n-    33, StrDupUniqFnLangItem,            \"strdup_uniq\",             strdup_uniq_fn;\n-    34, RecordBorrowFnLangItem,          \"record_borrow\",           record_borrow_fn;\n-    35, UnrecordBorrowFnLangItem,        \"unrecord_borrow\",         unrecord_borrow_fn;\n+    29, StrDupUniqFnLangItem,            \"strdup_uniq\",             strdup_uniq_fn;\n \n-    36, StartFnLangItem,                 \"start\",                   start_fn;\n+    30, StartFnLangItem,                 \"start\",                   start_fn;\n \n-    37, TyDescStructLangItem,            \"ty_desc\",                 ty_desc;\n-    38, TyVisitorTraitLangItem,          \"ty_visitor\",              ty_visitor;\n-    39, OpaqueStructLangItem,            \"opaque\",                  opaque;\n+    31, TyDescStructLangItem,            \"ty_desc\",                 ty_desc;\n+    32, TyVisitorTraitLangItem,          \"ty_visitor\",              ty_visitor;\n+    33, OpaqueStructLangItem,            \"opaque\",                  opaque;\n \n-    40, EventLoopFactoryLangItem,        \"event_loop_factory\",      event_loop_factory;\n+    34, EventLoopFactoryLangItem,        \"event_loop_factory\",      event_loop_factory;\n \n-    41, TypeIdLangItem,                  \"type_id\",                 type_id;\n+    35, TypeIdLangItem,                  \"type_id\",                 type_id;\n \n-    42, EhPersonalityLangItem,           \"eh_personality\",          eh_personality_fn;\n+    36, EhPersonalityLangItem,           \"eh_personality\",          eh_personality_fn;\n }\n "}, {"sha": "8459581dba49ab4db0861f6fb2ad86ede35ef82b", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/88281290ffdf79d1c3700935a3116fb1a22f458f/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88281290ffdf79d1c3700935a3116fb1a22f458f/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=88281290ffdf79d1c3700935a3116fb1a22f458f", "patch": "@@ -85,7 +85,7 @@ pub struct CopiedUpvar {\n #[deriving(Eq, IterBytes)]\n pub enum PointerKind {\n     uniq_ptr,\n-    gc_ptr(ast::Mutability),\n+    gc_ptr,\n     region_ptr(ast::Mutability, ty::Region),\n     unsafe_ptr(ast::Mutability)\n }\n@@ -178,17 +178,11 @@ pub fn opt_deref_kind(t: ty::t) -> Option<deref_kind> {\n             Some(deref_ptr(region_ptr(ast::MutImmutable, r)))\n         }\n \n-        ty::ty_box(ref mt) |\n-        ty::ty_evec(ref mt, ty::vstore_box) => {\n-            Some(deref_ptr(gc_ptr(mt.mutbl)))\n-        }\n-\n-        ty::ty_trait(_, _, ty::BoxTraitStore, m, _) => {\n-            Some(deref_ptr(gc_ptr(m)))\n-        }\n-\n+        ty::ty_box(_) |\n+        ty::ty_evec(_, ty::vstore_box) |\n+        ty::ty_trait(_, _, ty::BoxTraitStore, _, _) |\n         ty::ty_estr(ty::vstore_box) => {\n-            Some(deref_ptr(gc_ptr(ast::MutImmutable)))\n+            Some(deref_ptr(gc_ptr))\n         }\n \n         ty::ty_ptr(ref mt) => {\n@@ -681,7 +675,10 @@ impl mem_categorization_ctxt {\n                     uniq_ptr => {\n                         base_cmt.mutbl.inherit()\n                     }\n-                    gc_ptr(m) | region_ptr(m, _) | unsafe_ptr(m) => {\n+                    gc_ptr => {\n+                        McImmutable\n+                    }\n+                    region_ptr(m, _) | unsafe_ptr(m) => {\n                         MutabilityCategory::from_mutbl(m)\n                     }\n                 };\n@@ -759,12 +756,15 @@ impl mem_categorization_ctxt {\n             // for unique ptrs, we inherit mutability from the\n             // owning reference.\n             let m = match ptr {\n-              uniq_ptr => {\n-                base_cmt.mutbl.inherit()\n-              }\n-              gc_ptr(m) | region_ptr(m, _) | unsafe_ptr(m) => {\n-                MutabilityCategory::from_mutbl(m)\n-              }\n+                uniq_ptr => {\n+                    base_cmt.mutbl.inherit()\n+                }\n+                gc_ptr => {\n+                    McImmutable\n+                }\n+                region_ptr(m, _) | unsafe_ptr(m) => {\n+                    MutabilityCategory::from_mutbl(m)\n+                }\n             };\n \n             // the deref is explicit in the resulting cmt\n@@ -1103,7 +1103,7 @@ pub fn field_mutbl(tcx: ty::ctxt,\n }\n \n pub enum AliasableReason {\n-    AliasableManaged(ast::Mutability),\n+    AliasableManaged,\n     AliasableBorrowed(ast::Mutability),\n     AliasableOther\n }\n@@ -1122,7 +1122,7 @@ impl cmt_ {\n             cat_self(..) |\n             cat_arg(..) |\n             cat_deref(_, _, unsafe_ptr(..)) |\n-            cat_deref(_, _, gc_ptr(..)) |\n+            cat_deref(_, _, gc_ptr) |\n             cat_deref(_, _, region_ptr(..)) => {\n                 self\n             }\n@@ -1166,8 +1166,8 @@ impl cmt_ {\n                 Some(AliasableOther)\n             }\n \n-            cat_deref(_, _, gc_ptr(m)) => {\n-                Some(AliasableManaged(m))\n+            cat_deref(_, _, gc_ptr) => {\n+                Some(AliasableManaged)\n             }\n \n             cat_deref(_, _, region_ptr(m @ MutImmutable, _)) => {\n@@ -1229,7 +1229,7 @@ impl Repr for categorization {\n pub fn ptr_sigil(ptr: PointerKind) -> ~str {\n     match ptr {\n         uniq_ptr => ~\"~\",\n-        gc_ptr(_) => ~\"@\",\n+        gc_ptr => ~\"@\",\n         region_ptr(_, _) => ~\"&\",\n         unsafe_ptr(_) => ~\"*\"\n     }"}, {"sha": "973d2003ecb99b763eda789adb546deffb103e7a", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 1, "deletions": 59, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/88281290ffdf79d1c3700935a3116fb1a22f458f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88281290ffdf79d1c3700935a3116fb1a22f458f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=88281290ffdf79d1c3700935a3116fb1a22f458f", "patch": "@@ -22,12 +22,10 @@ use middle::trans::base;\n use middle::trans::build;\n use middle::trans::datum;\n use middle::trans::glue;\n-use middle::trans::write_guard;\n use middle::trans::debuginfo;\n use middle::ty::substs;\n use middle::ty;\n use middle::typeck;\n-use middle::borrowck::root_map_key;\n use util::ppaux::Repr;\n \n use middle::trans::type_::Type;\n@@ -363,27 +361,6 @@ impl CleanupFunction for ImmediateTypeDroppingCleanupFunction {\n     }\n }\n \n-/// A cleanup function that releases a write guard, returning a value to\n-/// mutable status.\n-pub struct WriteGuardReleasingCleanupFunction {\n-    root_key: root_map_key,\n-    frozen_val_ref: ValueRef,\n-    bits_val_ref: ValueRef,\n-    filename_val: ValueRef,\n-    line_val: ValueRef,\n-}\n-\n-impl CleanupFunction for WriteGuardReleasingCleanupFunction {\n-    fn clean(&self, bcx: @Block) -> @Block {\n-        write_guard::return_to_mut(bcx,\n-                                   self.root_key,\n-                                   self.frozen_val_ref,\n-                                   self.bits_val_ref,\n-                                   self.filename_val,\n-                                   self.line_val)\n-    }\n-}\n-\n /// A cleanup function that frees some memory in the garbage-collected heap.\n pub struct GCHeapFreeingCleanupFunction {\n     ptr: ValueRef,\n@@ -527,42 +504,7 @@ pub fn add_clean_temp_mem_in_scope_(bcx: @Block, scope_id: Option<ast::NodeId>,\n         grow_scope_clean(scope_info);\n     })\n }\n-pub fn add_clean_return_to_mut(bcx: @Block,\n-                               scope_id: ast::NodeId,\n-                               root_key: root_map_key,\n-                               frozen_val_ref: ValueRef,\n-                               bits_val_ref: ValueRef,\n-                               filename_val: ValueRef,\n-                               line_val: ValueRef) {\n-    //! When an `@mut` has been frozen, we have to\n-    //! call the lang-item `return_to_mut` when the\n-    //! freeze goes out of scope. We need to pass\n-    //! in both the value which was frozen (`frozen_val`) and\n-    //! the value (`bits_val_ref`) which was returned when the\n-    //! box was frozen initially. Here, both `frozen_val_ref` and\n-    //! `bits_val_ref` are in fact pointers to stack slots.\n-\n-    debug!(\"add_clean_return_to_mut({}, {}, {})\",\n-           bcx.to_str(),\n-           bcx.val_to_str(frozen_val_ref),\n-           bcx.val_to_str(bits_val_ref));\n-    in_scope_cx(bcx, Some(scope_id), |scope_info| {\n-        {\n-            let mut cleanups = scope_info.cleanups.borrow_mut();\n-            cleanups.get().push(clean_temp(\n-                    frozen_val_ref,\n-                    @WriteGuardReleasingCleanupFunction {\n-                        root_key: root_key,\n-                        frozen_val_ref: frozen_val_ref,\n-                        bits_val_ref: bits_val_ref,\n-                        filename_val: filename_val,\n-                        line_val: line_val,\n-                    } as @CleanupFunction,\n-                    normal_exit_only));\n-        }\n-        grow_scope_clean(scope_info);\n-    })\n-}\n+\n pub fn add_clean_free(cx: @Block, ptr: ValueRef, heap: heap) {\n     let free_fn = match heap {\n         heap_managed | heap_managed_unique => {"}, {"sha": "f57f31a56f458aa90269dd6aa035487895ca2cf6", "filename": "src/librustc/middle/trans/datum.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/88281290ffdf79d1c3700935a3116fb1a22f458f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88281290ffdf79d1c3700935a3116fb1a22f458f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs?ref=88281290ffdf79d1c3700935a3116fb1a22f458f", "patch": "@@ -552,7 +552,7 @@ impl Datum {\n          * by-ref datum of type T, pointing at the contents. */\n \n         let (content_ty, header) = match ty::get(self.ty).sty {\n-            ty::ty_box(mt) => (mt.ty, true),\n+            ty::ty_box(typ) => (typ, true),\n             ty::ty_uniq(mt) => (mt.ty, false),\n             ty::ty_evec(_, ty::vstore_uniq) | ty::ty_estr(ty::vstore_uniq) => {\n                 let unit_ty = ty::sequence_element_type(bcx.tcx(), self.ty);"}, {"sha": "49577a1395390bd12fea4e8125cd2662a850fb7c", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/88281290ffdf79d1c3700935a3116fb1a22f458f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88281290ffdf79d1c3700935a3116fb1a22f458f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=88281290ffdf79d1c3700935a3116fb1a22f458f", "patch": "@@ -2142,8 +2142,8 @@ fn type_metadata(cx: &CrateContext,\n         ty::ty_enum(def_id, _) => {\n             prepare_enum_metadata(cx, t, def_id, usage_site_span).finalize(cx)\n         },\n-        ty::ty_box(ref mt) => {\n-            create_pointer_to_box_metadata(cx, t, mt.ty)\n+        ty::ty_box(typ) => {\n+            create_pointer_to_box_metadata(cx, t, typ)\n         },\n         ty::ty_evec(ref mt, ref vstore) => {\n             match *vstore {"}, {"sha": "6cece563a82529e15d12fc87b25b86d3855c7ea0", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 4, "deletions": 10, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/88281290ffdf79d1c3700935a3116fb1a22f458f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88281290ffdf79d1c3700935a3116fb1a22f458f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=88281290ffdf79d1c3700935a3116fb1a22f458f", "patch": "@@ -378,18 +378,12 @@ pub fn trans_to_datum(bcx: @Block, expr: &ast::Expr) -> DatumBlock {\n         let source_data = Load(bcx, source_data_ptr); // always a ptr\n         let target_data = match source_store {\n             ty::BoxTraitStore(..) => {\n-                // For deref of @T or @mut T, create a dummy datum and\n-                // use the datum's deref method. This is more work\n-                // than just calling GEPi ourselves, but it ensures\n-                // that any write guards will be appropriate\n-                // processed.  Note that we don't know the type T, so\n+                // For deref of @T, create a dummy datum and use the datum's\n+                // deref method. This is more work than just calling GEPi\n+                // ourselves. Note that we don't know the type T, so\n                 // just substitute `i8`-- it doesn't really matter for\n                 // our purposes right now.\n-                let source_ty =\n-                    ty::mk_box(tcx,\n-                               ty::mt {\n-                                   ty: ty::mk_i8(),\n-                                   mutbl: source_mutbl});\n+                let source_ty = ty::mk_box(tcx, ty::mk_i8());\n                 let source_datum =\n                     Datum {val: source_data,\n                            ty: source_ty,"}, {"sha": "85efd2d40d045e8edf78fe4fe68cdfdd0822e685", "filename": "src/librustc/middle/trans/glue.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/88281290ffdf79d1c3700935a3116fb1a22f458f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88281290ffdf79d1c3700935a3116fb1a22f458f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs?ref=88281290ffdf79d1c3700935a3116fb1a22f458f", "patch": "@@ -157,7 +157,10 @@ pub fn simplified_glue_type(tcx: ty::ctxt, field: uint, t: ty::t) -> ty::t {\n     if (field == abi::tydesc_field_free_glue ||\n         field == abi::tydesc_field_drop_glue) {\n         match ty::get(t).sty {\n-          ty::ty_box(mt) |\n+          ty::ty_box(typ)\n+          if ! ty::type_needs_drop(tcx, typ) =>\n+          return ty::mk_imm_box(tcx, ty::mk_u32()),\n+\n           ty::ty_evec(mt, ty::vstore_box)\n           if ! ty::type_needs_drop(tcx, mt.ty) =>\n           return ty::mk_imm_box(tcx, ty::mk_u32()),\n@@ -356,10 +359,10 @@ pub fn make_free_glue(bcx: @Block, v: ValueRef, t: ty::t) -> @Block {\n     // NB: v0 is an *alias* of type t here, not a direct value.\n     let _icx = push_ctxt(\"make_free_glue\");\n     match ty::get(t).sty {\n-      ty::ty_box(body_mt) => {\n+      ty::ty_box(body_ty) => {\n         let v = Load(bcx, v);\n         let body = GEPi(bcx, v, [0u, abi::box_field_body]);\n-        let bcx = drop_ty(bcx, body, body_mt.ty);\n+        let bcx = drop_ty(bcx, body, body_ty);\n         trans_free(bcx, v)\n       }\n       ty::ty_opaque_box => {"}, {"sha": "f0ec7fb75dd82bf7a2e43d7d5bcd5f01de9b37b4", "filename": "src/librustc/middle/trans/reflect.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/88281290ffdf79d1c3700935a3116fb1a22f458f/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88281290ffdf79d1c3700935a3116fb1a22f458f/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs?ref=88281290ffdf79d1c3700935a3116fb1a22f458f", "patch": "@@ -189,8 +189,11 @@ impl Reflector {\n                   self.visit(~\"evec_\" + name, extra)\n               }\n           }\n-          ty::ty_box(ref mt) => {\n-              let extra = self.c_mt(mt);\n+          ty::ty_box(typ) => {\n+              let extra = self.c_mt(&ty::mt {\n+                  ty: typ,\n+                  mutbl: ast::MutImmutable,\n+              });\n               self.visit(\"box\", extra)\n           }\n           ty::ty_uniq(ref mt) => {"}, {"sha": "e5f946213f321579bebeb408f11ebfc38a0455de", "filename": "src/librustc/middle/trans/type_of.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/88281290ffdf79d1c3700935a3116fb1a22f458f/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88281290ffdf79d1c3700935a3116fb1a22f458f/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs?ref=88281290ffdf79d1c3700935a3116fb1a22f458f", "patch": "@@ -236,8 +236,8 @@ pub fn type_of(cx: &CrateContext, t: ty::t) -> Type {\n           let v_ty = Type::vec(cx.sess.targ_cfg.arch, &e_ty);\n           Type::smart_ptr(cx, &v_ty).ptr_to()\n       }\n-      ty::ty_box(ref mt) => {\n-          let ty = type_of(cx, mt.ty);\n+      ty::ty_box(typ) => {\n+          let ty = type_of(cx, typ);\n           Type::smart_ptr(cx, &ty).ptr_to()\n       }\n       ty::ty_opaque_box => Type::opaque_box(cx).ptr_to(),"}, {"sha": "d7c952a38f681968c348269b3c1106f0afc85a96", "filename": "src/librustc/middle/trans/write_guard.rs", "status": "modified", "additions": 8, "deletions": 139, "changes": 147, "blob_url": "https://github.com/rust-lang/rust/blob/88281290ffdf79d1c3700935a3116fb1a22f458f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fwrite_guard.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88281290ffdf79d1c3700935a3116fb1a22f458f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fwrite_guard.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fwrite_guard.rs?ref=88281290ffdf79d1c3700935a3116fb1a22f458f", "patch": "@@ -15,26 +15,15 @@\n //! `RUST_LOG=rustc::middle::trans::write_guard`).\n \n \n-use lib::llvm::ValueRef;\n-use middle::borrowck::{RootInfo, root_map_key, DynaImm, DynaMut};\n-use middle::lang_items::CheckNotBorrowedFnLangItem;\n-use middle::lang_items::{BorrowAsImmFnLangItem, BorrowAsMutFnLangItem};\n-use middle::lang_items::{RecordBorrowFnLangItem, UnrecordBorrowFnLangItem};\n-use middle::lang_items::ReturnToMutFnLangItem;\n+use middle::borrowck::{RootInfo, root_map_key};\n use middle::trans::base::*;\n-use middle::trans::build::*;\n-use middle::trans::callee;\n use middle::trans::common::*;\n use middle::trans::datum::*;\n-use middle::trans::expr;\n-use middle::ty;\n use syntax::codemap::Span;\n use syntax::ast;\n \n-use middle::trans::type_::Type;\n-\n pub fn root_and_write_guard(datum: &Datum,\n-                            mut bcx: @Block,\n+                            bcx: @Block,\n                             span: Span,\n                             expr_id: ast::NodeId,\n                             derefs: uint) -> @Block {\n@@ -45,69 +34,16 @@ pub fn root_and_write_guard(datum: &Datum,\n     //\n     // (Note: root'd values are always boxes)\n     let ccx = bcx.ccx();\n-    bcx = {\n-        let root_map = ccx.maps.root_map.borrow();\n-        match root_map.get().find(&key) {\n-            None => bcx,\n-            Some(&root_info) => root(datum, bcx, span, key, root_info)\n-        }\n-    };\n-\n-    // Perform the write guard, if necessary.\n-    //\n-    // (Note: write-guarded values are always boxes)\n-    let write_guard_map = ccx.maps.write_guard_map.borrow();\n-    if write_guard_map.get().contains(&key) {\n-        perform_write_guard(datum, bcx, span)\n-    } else {\n-        bcx\n+    let root_map = ccx.maps.root_map.borrow();\n+    match root_map.get().find(&key) {\n+        None => bcx,\n+        Some(&root_info) => root(datum, bcx, span, key, root_info)\n     }\n }\n \n-pub fn return_to_mut(mut bcx: @Block,\n-                     root_key: root_map_key,\n-                     frozen_val_ref: ValueRef,\n-                     bits_val_ref: ValueRef,\n-                     filename_val: ValueRef,\n-                     line_val: ValueRef) -> @Block {\n-    debug!(\"write_guard::return_to_mut(root_key={:?}, {}, {}, {})\",\n-           root_key,\n-           bcx.to_str(),\n-           bcx.val_to_str(frozen_val_ref),\n-           bcx.val_to_str(bits_val_ref));\n-\n-    let box_ptr = Load(bcx, PointerCast(bcx, frozen_val_ref, Type::i8p().ptr_to()));\n-\n-    let bits_val = Load(bcx, bits_val_ref);\n-\n-    if bcx.tcx().sess.debug_borrows() {\n-        bcx = callee::trans_lang_call( bcx,\n-            langcall(bcx, None, \"unborrow\", UnrecordBorrowFnLangItem),\n-            [\n-                box_ptr,\n-                bits_val,\n-                filename_val,\n-                line_val\n-            ],\n-            Some(expr::Ignore)).bcx;\n-    }\n-\n-    callee::trans_lang_call(\n-        bcx,\n-        langcall(bcx, None, \"unborrow\", ReturnToMutFnLangItem),\n-        [\n-            box_ptr,\n-            bits_val,\n-            filename_val,\n-            line_val\n-        ],\n-        Some(expr::Ignore)\n-    ).bcx\n-}\n-\n fn root(datum: &Datum,\n-        mut bcx: @Block,\n-        span: Span,\n+        bcx: @Block,\n+        _: Span,\n         root_key: root_map_key,\n         root_info: RootInfo) -> @Block {\n     //! In some cases, borrowck will decide that an @T/@[]/@str\n@@ -129,73 +65,6 @@ fn root(datum: &Datum,\n                                 scratch.val,\n                                 scratch.ty);\n \n-    // Now, consider also freezing it.\n-    match root_info.freeze {\n-        None => {}\n-        Some(freeze_kind) => {\n-            let (filename, line) = filename_and_line_num_from_span(bcx, span);\n-\n-            // in this case, we don't have to zero, because\n-            // scratch.val will be NULL should the cleanup get\n-            // called without the freezing actually occurring, and\n-            // return_to_mut checks for this condition.\n-            let scratch_bits = scratch_datum(bcx, ty::mk_uint(),\n-                                             \"__write_guard_bits\", false);\n-\n-            let freeze_item = match freeze_kind {\n-                DynaImm => BorrowAsImmFnLangItem,\n-                DynaMut => BorrowAsMutFnLangItem,\n-            };\n-\n-            let box_ptr = Load(bcx, PointerCast(bcx, scratch.val, Type::i8p().ptr_to()));\n-\n-            let llresult = unpack_result!(bcx, callee::trans_lang_call(\n-                bcx,\n-                langcall(bcx, Some(span), \"freeze\", freeze_item),\n-                [\n-                    box_ptr,\n-                    filename,\n-                    line\n-                ],\n-                Some(expr::SaveIn(scratch_bits.val))));\n-\n-            if bcx.tcx().sess.debug_borrows() {\n-                bcx = callee::trans_lang_call(\n-                    bcx,\n-                    langcall(bcx, Some(span), \"freeze\", RecordBorrowFnLangItem),\n-                    [\n-                        box_ptr,\n-                        llresult,\n-                        filename,\n-                        line\n-                    ],\n-                    Some(expr::Ignore)).bcx;\n-            }\n-\n-            add_clean_return_to_mut(cleanup_bcx,\n-                                    root_info.scope,\n-                                    root_key,\n-                                    scratch.val,\n-                                    scratch_bits.val,\n-                                    filename,\n-                                    line);\n-        }\n-    }\n-\n     bcx\n }\n \n-fn perform_write_guard(datum: &Datum,\n-                       bcx: @Block,\n-                       span: Span) -> @Block {\n-    debug!(\"perform_write_guard\");\n-\n-    let llval = datum.to_value_llval(bcx);\n-    let (filename, line) = filename_and_line_num_from_span(bcx, span);\n-\n-    callee::trans_lang_call(\n-        bcx,\n-        langcall(bcx, Some(span), \"write guard\", CheckNotBorrowedFnLangItem),\n-        [PointerCast(bcx, llval, Type::i8p()), filename, line],\n-        Some(expr::Ignore)).bcx\n-}"}, {"sha": "79eb26091dcbb93974272c20f78a06e244361c21", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 25, "deletions": 13, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/88281290ffdf79d1c3700935a3116fb1a22f458f/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88281290ffdf79d1c3700935a3116fb1a22f458f/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=88281290ffdf79d1c3700935a3116fb1a22f458f", "patch": "@@ -637,7 +637,7 @@ pub enum sty {\n     ty_float(ast::float_ty),\n     ty_estr(vstore),\n     ty_enum(DefId, substs),\n-    ty_box(mt),\n+    ty_box(t),\n     ty_uniq(mt),\n     ty_evec(mt, vstore),\n     ty_ptr(mt),\n@@ -1102,8 +1102,9 @@ pub fn mk_t(cx: ctxt, st: sty) -> t {\n               _ => {}\n           }\n       }\n-      &ty_box(ref m) | &ty_uniq(ref m) | &ty_evec(ref m, _) |\n-      &ty_ptr(ref m) | &ty_unboxed_vec(ref m) => {\n+      &ty_box(ref tt) => flags |= get(*tt).flags,\n+      &ty_uniq(ref m) | &ty_evec(ref m, _) | &ty_ptr(ref m) |\n+      &ty_unboxed_vec(ref m) => {\n         flags |= get(m.ty).flags;\n       }\n       &ty_rptr(r, ref m) => {\n@@ -1242,10 +1243,10 @@ pub fn mk_enum(cx: ctxt, did: ast::DefId, substs: substs) -> t {\n     mk_t(cx, ty_enum(did, substs))\n }\n \n-pub fn mk_box(cx: ctxt, tm: mt) -> t { mk_t(cx, ty_box(tm)) }\n+pub fn mk_box(cx: ctxt, ty: t) -> t { mk_t(cx, ty_box(ty)) }\n \n pub fn mk_imm_box(cx: ctxt, ty: t) -> t {\n-    mk_box(cx, mt {ty: ty, mutbl: ast::MutImmutable})\n+    mk_box(cx, ty)\n }\n \n pub fn mk_uniq(cx: ctxt, tm: mt) -> t { mk_t(cx, ty_uniq(tm)) }\n@@ -1368,8 +1369,11 @@ pub fn maybe_walk_ty(ty: t, f: |t| -> bool) {\n       ty_estr(_) | ty_type | ty_opaque_box | ty_self(_) |\n       ty_opaque_closure_ptr(_) | ty_infer(_) | ty_param(_) | ty_err => {\n       }\n-      ty_box(ref tm) | ty_evec(ref tm, _) | ty_unboxed_vec(ref tm) |\n-      ty_ptr(ref tm) | ty_rptr(_, ref tm) | ty_uniq(ref tm) => {\n+      ty_box(ref ty) => {\n+        maybe_walk_ty(*ty, f);\n+      }\n+      ty_evec(ref tm, _) | ty_unboxed_vec(ref tm) | ty_ptr(ref tm) |\n+      ty_rptr(_, ref tm) | ty_uniq(ref tm) => {\n         maybe_walk_ty(tm.ty, f);\n       }\n       ty_enum(_, ref substs) | ty_struct(_, ref substs) |\n@@ -2035,8 +2039,8 @@ pub fn type_contents(cx: ctxt, ty: t) -> TypeContents {\n                 closure_contents(cx, c)\n             }\n \n-            ty_box(mt) => {\n-                tc_mt(cx, mt, cache).managed_pointer()\n+            ty_box(typ) => {\n+                tc_ty(cx, typ, cache).managed_pointer()\n             }\n \n             ty_trait(_, _, store, mutbl, bounds) => {\n@@ -2334,7 +2338,9 @@ pub fn is_instantiable(cx: ctxt, r_ty: t) -> bool {\n             ty_unboxed_vec(_) => {\n                 false\n             }\n-            ty_box(ref mt) |\n+            ty_box(typ) => {\n+                type_requires(cx, seen, r_ty, typ)\n+            }\n             ty_uniq(ref mt) |\n             ty_rptr(_, ref mt) => {\n                 type_requires(cx, seen, r_ty, mt.ty)\n@@ -2610,7 +2616,14 @@ pub fn deref(cx: ctxt, t: t, explicit: bool) -> Option<mt> {\n \n pub fn deref_sty(cx: ctxt, sty: &sty, explicit: bool) -> Option<mt> {\n     match *sty {\n-      ty_rptr(_, mt) | ty_box(mt) | ty_uniq(mt) => {\n+      ty_box(typ) => {\n+        Some(mt {\n+          ty: typ,\n+          mutbl: ast::MutImmutable,\n+        })\n+      }\n+\n+      ty_rptr(_, mt) | ty_uniq(mt) => {\n         Some(mt)\n       }\n \n@@ -4818,9 +4831,8 @@ pub fn hash_crate_independent(tcx: ctxt, t: t, local_hash: @str) -> u64 {\n                 hash.input([8]);\n                 did(&mut hash, d);\n             }\n-            ty_box(m) => {\n+            ty_box(_) => {\n                 hash.input([9]);\n-                mt(&mut hash, m);\n             }\n             ty_uniq(m) => {\n                 hash.input([10]);"}, {"sha": "06a3152056fb1d5c96cb33772f794ede4d6b6946", "filename": "src/librustc/middle/ty_fold.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/88281290ffdf79d1c3700935a3116fb1a22f458f/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88281290ffdf79d1c3700935a3116fb1a22f458f/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty_fold.rs?ref=88281290ffdf79d1c3700935a3116fb1a22f458f", "patch": "@@ -140,8 +140,8 @@ pub fn super_fold_mt<T:TypeFolder>(this: &mut T,\n pub fn super_fold_sty<T:TypeFolder>(this: &mut T,\n                                     sty: &ty::sty) -> ty::sty {\n     match *sty {\n-        ty::ty_box(ref tm) => {\n-            ty::ty_box(this.fold_mt(tm))\n+        ty::ty_box(typ) => {\n+            ty::ty_box(this.fold_ty(typ))\n         }\n         ty::ty_uniq(ref tm) => {\n             ty::ty_uniq(this.fold_mt(tm))"}, {"sha": "24c4b3399bcc53671a28cfcd7aa076b265f077d1", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/88281290ffdf79d1c3700935a3116fb1a22f458f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88281290ffdf79d1c3700935a3116fb1a22f458f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=88281290ffdf79d1c3700935a3116fb1a22f458f", "patch": "@@ -402,8 +402,9 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:RegionScope>(\n       ast::ty_nil => ty::mk_nil(),\n       ast::ty_bot => ty::mk_bot(),\n       ast::ty_box(ref mt) => {\n-        mk_pointer(this, rscope, mt, ty::vstore_box,\n-                   |tmt| ty::mk_box(tcx, tmt))\n+        let mt = ast::mt { ty: mt.ty, mutbl: ast::MutImmutable };\n+        mk_pointer(this, rscope, &mt, ty::vstore_box,\n+                   |tmt| ty::mk_box(tcx, tmt.ty))\n       }\n       ast::ty_uniq(ty) => {\n         let mt = ast::mt { ty: ty, mutbl: ast::MutImmutable };\n@@ -689,10 +690,8 @@ fn ty_of_method_or_bare_fn<AC:AstConv>(\n                                  ty::mt {ty: self_info.untransformed_self_ty,\n                                          mutbl: mutability}))\n             }\n-            ast::sty_box(mutability) => {\n-                Some(ty::mk_box(this.tcx(),\n-                                ty::mt {ty: self_info.untransformed_self_ty,\n-                                        mutbl: mutability}))\n+            ast::sty_box(_) => {\n+                Some(ty::mk_box(this.tcx(), self_info.untransformed_self_ty))\n             }\n             ast::sty_uniq(_) => {\n                 Some(ty::mk_uniq(this.tcx(),"}, {"sha": "a7f83a41da675aed894193273db22ff0412703f4", "filename": "src/librustc/middle/typeck/check/_match.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/88281290ffdf79d1c3700935a3116fb1a22f458f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88281290ffdf79d1c3700935a3116fb1a22f458f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs?ref=88281290ffdf79d1c3700935a3116fb1a22f458f", "patch": "@@ -667,19 +667,19 @@ pub fn check_pointer_pat(pcx: &pat_ctxt,\n                          span: Span,\n                          expected: ty::t) {\n     let fcx = pcx.fcx;\n-    let check_inner: |ty::mt| = |e_inner| {\n-        check_pat(pcx, inner, e_inner.ty);\n+    let check_inner: |ty::t| = |e_inner| {\n+        check_pat(pcx, inner, e_inner);\n         fcx.write_ty(pat_id, expected);\n     };\n     match *structure_of(fcx, span, expected) {\n         ty::ty_box(e_inner) if pointer_kind == Managed => {\n             check_inner(e_inner);\n         }\n         ty::ty_uniq(e_inner) if pointer_kind == Send => {\n-            check_inner(e_inner);\n+            check_inner(e_inner.ty);\n         }\n         ty::ty_rptr(_, e_inner) if pointer_kind == Borrowed => {\n-            check_inner(e_inner);\n+            check_inner(e_inner.ty);\n         }\n         _ => {\n             check_pat(pcx, inner, ty::mk_err());"}, {"sha": "e1ecd919da8187f683bf30de4fb9b1c0fff1dd70", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/88281290ffdf79d1c3700935a3116fb1a22f458f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88281290ffdf79d1c3700935a3116fb1a22f458f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=88281290ffdf79d1c3700935a3116fb1a22f458f", "patch": "@@ -1092,9 +1092,9 @@ impl<'a> LookupContext<'a> {\n                                      substs, RegionTraitStore(r), mt.mutbl,\n                                      ty::EmptyBuiltinBounds())\n                     }\n-                    ty::ty_box(mt) => { // must be sty_box\n+                    ty::ty_box(_) => { // must be sty_box\n                         ty::mk_trait(self.tcx(), trait_def_id,\n-                                     substs, BoxTraitStore, mt.mutbl,\n+                                     substs, BoxTraitStore, ast::MutImmutable,\n                                      ty::EmptyBuiltinBounds())\n                     }\n                     ty::ty_uniq(mt) => { // must be sty_uniq\n@@ -1224,9 +1224,8 @@ impl<'a> LookupContext<'a> {\n             sty_box(m) => {\n                 debug!(\"(is relevant?) explicit self is a box\");\n                 match ty::get(rcvr_ty).sty {\n-                    ty::ty_box(mt) => {\n-                        mutability_matches(mt.mutbl, m) &&\n-                        rcvr_matches_ty(self.fcx, mt.ty, candidate)\n+                    ty::ty_box(typ) => {\n+                        rcvr_matches_ty(self.fcx, typ, candidate)\n                     }\n \n                     ty::ty_trait(self_did, _, BoxTraitStore, self_m, _) => {"}, {"sha": "dde55f320bc260f90e63a301798cb54d92b9c55a", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 14, "deletions": 6, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/88281290ffdf79d1c3700935a3116fb1a22f458f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88281290ffdf79d1c3700935a3116fb1a22f458f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=88281290ffdf79d1c3700935a3116fb1a22f458f", "patch": "@@ -1330,8 +1330,7 @@ pub fn do_autoderef(fcx: @FnCtxt, sp: Span, t: ty::t) -> (ty::t, uint) {\n \n         // Some extra checks to detect weird cycles and so forth:\n         match *sty {\n-            ty::ty_box(inner) | ty::ty_uniq(inner) |\n-            ty::ty_rptr(_, inner) => {\n+            ty::ty_box(inner) => {\n                 match ty::get(t1).sty {\n                     ty::ty_infer(ty::TyVar(v1)) => {\n                         ty::occurs_check(fcx.ccx.tcx, sp, v1,\n@@ -1340,6 +1339,15 @@ pub fn do_autoderef(fcx: @FnCtxt, sp: Span, t: ty::t) -> (ty::t, uint) {\n                     _ => ()\n                 }\n             }\n+            ty::ty_uniq(inner) | ty::ty_rptr(_, inner) => {\n+                match ty::get(t1).sty {\n+                    ty::ty_infer(ty::TyVar(v1)) => {\n+                        ty::occurs_check(fcx.ccx.tcx, sp, v1,\n+                                         ty::mk_box(fcx.ccx.tcx, inner.ty));\n+                    }\n+                    _ => ()\n+                }\n+            }\n             ty::ty_enum(ref did, _) => {\n                 // Watch out for a type like `enum t = @t`.  Such a\n                 // type would otherwise infinitely auto-deref.  Only\n@@ -2734,7 +2742,8 @@ pub fn check_expr_with_unifier(fcx: @FnCtxt,\n         let exp_inner = unpack_expected(fcx, expected, |sty| {\n             match unop {\n               ast::UnBox(_) | ast::UnUniq => match *sty {\n-                ty::ty_box(ref mt) | ty::ty_uniq(ref mt) => Some(mt.ty),\n+                ty::ty_box(ty) => Some(ty),\n+                ty::ty_uniq(ref mt) => Some(mt.ty),\n                 _ => None\n               },\n               ast::UnNot | ast::UnNeg => expected,\n@@ -2746,9 +2755,8 @@ pub fn check_expr_with_unifier(fcx: @FnCtxt,\n         if !ty::type_is_error(oprnd_t) &&\n               !ty::type_is_bot(oprnd_t) {\n             match unop {\n-                ast::UnBox(mutbl) => {\n-                    oprnd_t = ty::mk_box(tcx,\n-                                         ty::mt {ty: oprnd_t, mutbl: mutbl});\n+                ast::UnBox(_) => {\n+                    oprnd_t = ty::mk_box(tcx, oprnd_t)\n                 }\n                 ast::UnUniq => {\n                     oprnd_t = ty::mk_uniq(tcx,"}, {"sha": "fcf219323e1ccffab64a9bb995802458a16a3e37", "filename": "src/librustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 18, "deletions": 6, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/88281290ffdf79d1c3700935a3116fb1a22f458f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88281290ffdf79d1c3700935a3116fb1a22f458f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=88281290ffdf79d1c3700935a3116fb1a22f458f", "patch": "@@ -582,17 +582,29 @@ pub fn early_resolve_expr(ex: @ast::Expr,\n               let ty = structurally_resolved_type(fcx, ex.span,\n                                                   fcx.expr_ty(src));\n               match (&ty::get(ty).sty, store) {\n-                  (&ty::ty_box(mt), ty::BoxTraitStore) |\n+                  (&ty::ty_box(..), ty::BoxTraitStore)\n+                    if !mutability_allowed(ast::MutImmutable,\n+                                           target_mutbl) => {\n+                      fcx.tcx().sess.span_err(ex.span,\n+                                              format!(\"types differ in mutability\"));\n+                  }\n+\n                   (&ty::ty_uniq(mt), ty::UniqTraitStore) |\n                   (&ty::ty_rptr(_, mt), ty::RegionTraitStore(..))\n                     if !mutability_allowed(mt.mutbl, target_mutbl) => {\n                       fcx.tcx().sess.span_err(ex.span,\n                                               format!(\"types differ in mutability\"));\n                   }\n \n-                  (&ty::ty_box(mt), ty::BoxTraitStore) |\n-                  (&ty::ty_uniq(mt), ty::UniqTraitStore) |\n-                  (&ty::ty_rptr(_, mt), ty::RegionTraitStore(..)) => {\n+                  (&ty::ty_box(..), ty::BoxTraitStore) |\n+                  (&ty::ty_uniq(..), ty::UniqTraitStore) |\n+                  (&ty::ty_rptr(..), ty::RegionTraitStore(..)) => {\n+                    let typ = match (&ty::get(ty).sty) {\n+                        &ty::ty_box(typ) => typ,\n+                        &ty::ty_uniq(mt) | &ty::ty_rptr(_, mt) => mt.ty,\n+                        _ => fail!(\"shouldn't get here\"),\n+                    };\n+\n                       let location_info =\n                           &location_info_for_expr(ex);\n                       let vcx = fcx.vtable_context();\n@@ -601,7 +613,7 @@ pub fn early_resolve_expr(ex: @ast::Expr,\n                           substs: ty::substs {\n                               tps: target_substs.tps.clone(),\n                               regions: target_substs.regions.clone(),\n-                              self_ty: Some(mt.ty)\n+                              self_ty: Some(typ)\n                           }\n                       };\n \n@@ -614,7 +626,7 @@ pub fn early_resolve_expr(ex: @ast::Expr,\n                                                      location_info,\n                                                      None,\n                                                      &param_bounds,\n-                                                     mt.ty,\n+                                                     typ,\n                                                      is_early);\n \n                       if !is_early {"}, {"sha": "6e82456e95dbfc2469a59b102b638f1fa4f46cd2", "filename": "src/librustc/middle/typeck/infer/coercion.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/88281290ffdf79d1c3700935a3116fb1a22f458f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88281290ffdf79d1c3700935a3116fb1a22f458f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs?ref=88281290ffdf79d1c3700935a3116fb1a22f458f", "patch": "@@ -241,7 +241,7 @@ impl Coerce {\n         let r_borrow = self.infcx.next_region_var(Coercion(self.trace));\n \n         let inner_ty = match *sty_a {\n-            ty::ty_box(mt_a) => mt_a.ty,\n+            ty::ty_box(typ) => typ,\n             ty::ty_uniq(mt_a) => mt_a.ty,\n             ty::ty_rptr(_, mt_a) => mt_a.ty,\n             _ => {"}, {"sha": "8d949cc1bc909e45a27337f56891128f6ed60e98", "filename": "src/librustc/middle/typeck/infer/combine.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/88281290ffdf79d1c3700935a3116fb1a22f458f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88281290ffdf79d1c3700935a3116fb1a22f458f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs?ref=88281290ffdf79d1c3700935a3116fb1a22f458f", "patch": "@@ -515,8 +515,8 @@ pub fn super_tys<C:Combine>(this: &C, a: ty::t, b: ty::t) -> cres<ty::t> {\n             Ok(ty::mk_struct(tcx, a_id, substs))\n       }\n \n-      (&ty::ty_box(ref a_mt), &ty::ty_box(ref b_mt)) => {\n-        this.mts(a_mt, b_mt).and_then(|mt| Ok(ty::mk_box(tcx, mt)))\n+      (&ty::ty_box(a_inner), &ty::ty_box(b_inner)) => {\n+        this.tys(a_inner, b_inner).and_then(|typ| Ok(ty::mk_box(tcx, typ)))\n       }\n \n       (&ty::ty_uniq(ref a_mt), &ty::ty_uniq(ref b_mt)) => {"}, {"sha": "7be5791c074060425fd7d0beea313a2e6d819ea1", "filename": "src/librustc/middle/typeck/variance.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/88281290ffdf79d1c3700935a3116fb1a22f458f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88281290ffdf79d1c3700935a3116fb1a22f458f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs?ref=88281290ffdf79d1c3700935a3116fb1a22f458f", "patch": "@@ -637,7 +637,10 @@ impl<'a> ConstraintContext<'a> {\n                 self.add_constraints_from_mt(mt, variance);\n             }\n \n-            ty::ty_box(ref mt) |\n+            ty::ty_box(typ) => {\n+                self.add_constraints_from_ty(typ, variance);\n+            }\n+\n             ty::ty_uniq(ref mt) |\n             ty::ty_ptr(ref mt) => {\n                 self.add_constraints_from_mt(mt, variance);"}, {"sha": "6a346eac425b71b56d514542fa2f9208d3f81332", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/88281290ffdf79d1c3700935a3116fb1a22f458f/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88281290ffdf79d1c3700935a3116fb1a22f458f/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=88281290ffdf79d1c3700935a3116fb1a22f458f", "patch": "@@ -454,7 +454,7 @@ pub fn ty_to_str(cx: ctxt, typ: t) -> ~str {\n       ty_uint(ast::ty_u) => ~\"uint\",\n       ty_uint(t) => ast_util::uint_ty_to_str(t),\n       ty_float(t) => ast_util::float_ty_to_str(t),\n-      ty_box(ref tm) => ~\"@\" + mt_to_str(cx, tm),\n+      ty_box(typ) => ~\"@\" + ty_to_str(cx, typ),\n       ty_uniq(ref tm) => ~\"~\" + mt_to_str(cx, tm),\n       ty_ptr(ref tm) => ~\"*\" + mt_to_str(cx, tm),\n       ty_rptr(r, ref tm) => {"}, {"sha": "8a5a1d2426cb6f51805f8c15cec6b25677788df2", "filename": "src/libsyntax/ast_map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/88281290ffdf79d1c3700935a3116fb1a22f458f/src%2Flibsyntax%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88281290ffdf79d1c3700935a3116fb1a22f458f/src%2Flibsyntax%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map.rs?ref=88281290ffdf79d1c3700935a3116fb1a22f458f", "patch": "@@ -95,7 +95,7 @@ pub fn path_elt_to_str(pe: path_elt, itr: @ident_interner) -> ~str {\n fn pretty_ty(ty: &Ty, itr: @ident_interner, out: &mut ~str) {\n     let (prefix, subty) = match ty.node {\n         ty_uniq(ty) => (\"$UP$\", &*ty),\n-        ty_box(mt { ty, .. }) => (\"$SP$\", &*ty),\n+        ty_box(ty) => (\"$SP$\", &*ty),\n         ty_ptr(mt { ty, mutbl }) => (if mutbl == MutMutable {\"$RPmut$\"} else {\"$RP$\"},\n                                      &*ty),\n         ty_rptr(_, mt { ty, mutbl }) => (if mutbl == MutMutable {\"$BPmut$\"} else {\"$BP$\"},"}]}