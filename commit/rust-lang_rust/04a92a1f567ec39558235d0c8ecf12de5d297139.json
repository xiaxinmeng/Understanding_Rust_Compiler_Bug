{"sha": "04a92a1f567ec39558235d0c8ecf12de5d297139", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA0YTkyYTFmNTY3ZWMzOTU1ODIzNWQwYzhlY2YxMmRlNWQyOTcxMzk=", "commit": {"author": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2016-09-24T17:45:59Z"}, "committer": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2016-10-26T19:41:17Z"}, "message": "un-break the `construct_witness` logic\n\nFixes #35609.", "tree": {"sha": "c16fc7aa900b1dfde12161a0c8677092945d64f2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c16fc7aa900b1dfde12161a0c8677092945d64f2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/04a92a1f567ec39558235d0c8ecf12de5d297139", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/04a92a1f567ec39558235d0c8ecf12de5d297139", "html_url": "https://github.com/rust-lang/rust/commit/04a92a1f567ec39558235d0c8ecf12de5d297139", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/04a92a1f567ec39558235d0c8ecf12de5d297139/comments", "author": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "committer": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "abae5e7e258f256cbdb4fa2a58f58ecb095ba626", "url": "https://api.github.com/repos/rust-lang/rust/commits/abae5e7e258f256cbdb4fa2a58f58ecb095ba626", "html_url": "https://github.com/rust-lang/rust/commit/abae5e7e258f256cbdb4fa2a58f58ecb095ba626"}], "stats": {"total": 440, "additions": 290, "deletions": 150}, "files": [{"sha": "2a11f22ca59c6a106b0bdc675aa1fdc507e63c0f", "filename": "src/librustc_const_eval/_match.rs", "status": "modified", "additions": 185, "deletions": 148, "changes": 333, "blob_url": "https://github.com/rust-lang/rust/blob/04a92a1f567ec39558235d0c8ecf12de5d297139/src%2Flibrustc_const_eval%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04a92a1f567ec39558235d0c8ecf12de5d297139/src%2Flibrustc_const_eval%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2F_match.rs?ref=04a92a1f567ec39558235d0c8ecf12de5d297139", "patch": "@@ -171,7 +171,7 @@ impl Constructor {\n #[derive(Clone, PartialEq)]\n pub enum Usefulness {\n     Useful,\n-    UsefulWithWitness(Vec<P<Pat>>),\n+    UsefulWithWitness(Vec<Witness>),\n     NotUseful\n }\n \n@@ -181,6 +181,13 @@ pub enum WitnessPreference {\n     LeaveOutWitness\n }\n \n+#[derive(Copy, Clone, Debug)]\n+struct PatternContext<'tcx> {\n+    ty: Ty<'tcx>,\n+    max_slice_length: usize,\n+}\n+\n+\n fn const_val_to_expr(value: &ConstVal) -> P<hir::Expr> {\n     let node = match value {\n         &ConstVal::Bool(b) => ast::LitKind::Bool(b),\n@@ -194,93 +201,126 @@ fn const_val_to_expr(value: &ConstVal) -> P<hir::Expr> {\n     })\n }\n \n-/// Constructs a partial witness for a pattern given a list of\n-/// patterns expanded by the specialization step.\n-///\n-/// When a pattern P is discovered to be useful, this function is used bottom-up\n-/// to reconstruct a complete witness, e.g. a pattern P' that covers a subset\n-/// of values, V, where each value in that set is not covered by any previously\n-/// used patterns and is covered by the pattern P'. Examples:\n-///\n-/// left_ty: tuple of 3 elements\n-/// pats: [10, 20, _]           => (10, 20, _)\n-///\n-/// left_ty: struct X { a: (bool, &'static str), b: usize}\n-/// pats: [(false, \"foo\"), 42]  => X { a: (false, \"foo\"), b: 42 }\n-fn construct_witness<'a,'tcx>(cx: &MatchCheckCtxt<'a,'tcx>, ctor: &Constructor,\n-                              pats: Vec<&Pat>, left_ty: Ty<'tcx>) -> P<Pat> {\n-    let pats_len = pats.len();\n-    let mut pats = pats.into_iter().map(|p| P((*p).clone()));\n-    let pat = match left_ty.sty {\n-        ty::TyTuple(..) => PatKind::Tuple(pats.collect(), None),\n+/// A stack of patterns in reverse order of construction\n+#[derive(Clone, PartialEq, Eq)]\n+pub struct Witness(Vec<P<Pat>>);\n \n-        ty::TyAdt(adt, _) => {\n-            let v = ctor.variant_for_adt(adt);\n-            match v.ctor_kind {\n-                CtorKind::Fictive => {\n-                    let field_pats: hir::HirVec<_> = v.fields.iter()\n-                        .zip(pats)\n-                        .filter(|&(_, ref pat)| pat.node != PatKind::Wild)\n-                        .map(|(field, pat)| Spanned {\n-                            span: DUMMY_SP,\n-                            node: hir::FieldPat {\n-                                name: field.name,\n-                                pat: pat,\n-                                is_shorthand: false,\n-                            }\n-                        }).collect();\n-                    let has_more_fields = field_pats.len() < pats_len;\n-                    PatKind::Struct(def_to_path(cx.tcx, v.did), field_pats, has_more_fields)\n-                }\n-                CtorKind::Fn => {\n-                    PatKind::TupleStruct(def_to_path(cx.tcx, v.did), pats.collect(), None)\n-                }\n-                CtorKind::Const => {\n-                    PatKind::Path(None, def_to_path(cx.tcx, v.did))\n-                }\n-            }\n-        }\n+impl Witness {\n+    pub fn single_pattern(&self) -> &Pat {\n+        assert_eq!(self.0.len(), 1);\n+        &self.0[0]\n+    }\n \n-        ty::TyRef(_, ty::TypeAndMut { mutbl, .. }) => {\n-            assert_eq!(pats_len, 1);\n-            PatKind::Ref(pats.nth(0).unwrap(), mutbl)\n-        }\n+    fn push_wild_constructor<'a, 'tcx>(\n+        mut self,\n+        cx: &MatchCheckCtxt<'a, 'tcx>,\n+        ctor: &Constructor,\n+        ty: Ty<'tcx>)\n+        -> Self\n+    {\n+        let arity = constructor_arity(cx, ctor, ty);\n+        self.0.extend(repeat(DUMMY_WILD_PAT).take(arity).map(|p| P(p.clone())));\n+        self.apply_constructor(cx, ctor, ty)\n+    }\n \n-        ty::TySlice(_) => match ctor {\n-            &Slice(n) => {\n-                assert_eq!(pats_len, n);\n-                PatKind::Slice(pats.collect(), None, hir::HirVec::new())\n-            },\n-            _ => unreachable!()\n-        },\n \n-        ty::TyArray(_, len) => {\n-            assert_eq!(pats_len, len);\n-            PatKind::Slice(pats.collect(), None, hir::HirVec::new())\n-        }\n+    /// Constructs a partial witness for a pattern given a list of\n+    /// patterns expanded by the specialization step.\n+    ///\n+    /// When a pattern P is discovered to be useful, this function is used bottom-up\n+    /// to reconstruct a complete witness, e.g. a pattern P' that covers a subset\n+    /// of values, V, where each value in that set is not covered by any previously\n+    /// used patterns and is covered by the pattern P'. Examples:\n+    ///\n+    /// left_ty: tuple of 3 elements\n+    /// pats: [10, 20, _]           => (10, 20, _)\n+    ///\n+    /// left_ty: struct X { a: (bool, &'static str), b: usize}\n+    /// pats: [(false, \"foo\"), 42]  => X { a: (false, \"foo\"), b: 42 }\n+    fn apply_constructor<'a, 'tcx>(\n+        mut self,\n+        cx: &MatchCheckCtxt<'a,'tcx>,\n+        ctor: &Constructor,\n+        ty: Ty<'tcx>)\n+        -> Self\n+    {\n+        let arity = constructor_arity(cx, ctor, ty);\n+        let pat = {\n+            let len = self.0.len();\n+            let mut pats = self.0.drain(len-arity..).rev();\n+\n+            match ty.sty {\n+                ty::TyTuple(..) => PatKind::Tuple(pats.collect(), None),\n+\n+                ty::TyAdt(adt, _) => {\n+                    let v = ctor.variant_for_adt(adt);\n+                    match v.ctor_kind {\n+                        CtorKind::Fictive => {\n+                            let field_pats: hir::HirVec<_> = v.fields.iter()\n+                                .zip(pats)\n+                                .filter(|&(_, ref pat)| pat.node != PatKind::Wild)\n+                                .map(|(field, pat)| Spanned {\n+                                    span: DUMMY_SP,\n+                                    node: hir::FieldPat {\n+                                        name: field.name,\n+                                        pat: pat,\n+                                        is_shorthand: false,\n+                                    }\n+                                }).collect();\n+                            let has_more_fields = field_pats.len() < arity;\n+                            PatKind::Struct(\n+                                def_to_path(cx.tcx, v.did), field_pats, has_more_fields)\n+                        }\n+                        CtorKind::Fn => {\n+                            PatKind::TupleStruct(\n+                                def_to_path(cx.tcx, v.did), pats.collect(), None)\n+                        }\n+                        CtorKind::Const => {\n+                            PatKind::Path(None, def_to_path(cx.tcx, v.did))\n+                        }\n+                    }\n+                }\n+\n+                ty::TyRef(_, ty::TypeAndMut { mutbl, .. }) => {\n+                    PatKind::Ref(pats.nth(0).unwrap(), mutbl)\n+                }\n+\n+                ty::TySlice(_) | ty::TyArray(..) => {\n+                    PatKind::Slice(pats.collect(), None, hir::HirVec::new())\n+                }\n \n-        _ => {\n-            match *ctor {\n-                ConstantValue(ref v) => PatKind::Lit(const_val_to_expr(v)),\n-                _ => PatKind::Wild,\n+                _ => {\n+                    match *ctor {\n+                        ConstantValue(ref v) => PatKind::Lit(const_val_to_expr(v)),\n+                        _ => PatKind::Wild,\n+                    }\n+                }\n             }\n-        }\n-    };\n+        };\n \n-    P(hir::Pat {\n-        id: DUMMY_NODE_ID,\n-        node: pat,\n-        span: DUMMY_SP\n-    })\n+        self.0.push(P(hir::Pat {\n+            id: DUMMY_NODE_ID,\n+            node: pat,\n+            span: DUMMY_SP\n+        }));\n+\n+        self\n+    }\n }\n \n-fn missing_constructors(cx: &MatchCheckCtxt, &Matrix(ref rows): &Matrix,\n-                       left_ty: Ty, max_slice_length: usize) -> Vec<Constructor> {\n-    let used_constructors: Vec<Constructor> = rows.iter()\n-        .flat_map(|row| pat_constructors(cx, row[0], left_ty, max_slice_length))\n+/// Return the set of constructors from the same type as the first column of `matrix`,\n+/// that are matched only by wildcard patterns from that first column.\n+///\n+/// Therefore, if there is some pattern that is unmatched by `matrix`, it will\n+/// still be unmatched if the first constructor is replaced by any of the constructors\n+/// in the return value.\n+fn missing_constructors(cx: &MatchCheckCtxt, matrix: &Matrix,\n+                        pcx: PatternContext) -> Vec<Constructor> {\n+    let used_constructors: Vec<Constructor> =\n+        matrix.0.iter()\n+        .flat_map(|row| pat_constructors(cx, row[0], pcx).unwrap_or(vec![]))\n         .collect();\n-    all_constructors(cx, left_ty, max_slice_length)\n-        .into_iter()\n+    all_constructors(cx, pcx).into_iter()\n         .filter(|c| !used_constructors.contains(c))\n         .collect()\n }\n@@ -289,13 +329,12 @@ fn missing_constructors(cx: &MatchCheckCtxt, &Matrix(ref rows): &Matrix,\n /// values of type `left_ty`. For vectors, this would normally be an infinite set\n /// but is instead bounded by the maximum fixed length of slice patterns in\n /// the column of patterns being analyzed.\n-fn all_constructors(_cx: &MatchCheckCtxt, left_ty: Ty,\n-                    max_slice_length: usize) -> Vec<Constructor> {\n-    match left_ty.sty {\n+fn all_constructors(_cx: &MatchCheckCtxt, pcx: PatternContext) -> Vec<Constructor> {\n+    match pcx.ty.sty {\n         ty::TyBool =>\n             [true, false].iter().map(|b| ConstantValue(ConstVal::Bool(*b))).collect(),\n         ty::TySlice(_) =>\n-            (0..max_slice_length+1).map(|length| Slice(length)).collect(),\n+            (0..pcx.max_slice_length+1).map(|length| Slice(length)).collect(),\n         ty::TyAdt(def, _) if def.is_enum() =>\n             def.variants.iter().map(|v| Variant(v.did)).collect(),\n         _ => vec![Single]\n@@ -324,52 +363,47 @@ pub fn is_useful<'a, 'tcx>(cx: &MatchCheckCtxt<'a, 'tcx>,\n     debug!(\"is_useful({:?}, {:?})\", matrix, v);\n     if rows.is_empty() {\n         return match witness {\n-            ConstructWitness => UsefulWithWitness(vec!()),\n+            ConstructWitness => UsefulWithWitness(vec![Witness(\n+                repeat(DUMMY_WILD_PAT).take(v.len()).map(|p| P(p.clone())).collect()\n+            )]),\n             LeaveOutWitness => Useful\n         };\n     }\n     if rows[0].is_empty() {\n         return NotUseful;\n     }\n     assert!(rows.iter().all(|r| r.len() == v.len()));\n-    let left_ty = match rows.iter().filter_map(|r| r[0].pattern_ty).next()\n-        .or_else(|| v[0].pattern_ty)\n-    {\n-        Some(ty) => ty,\n-        None => {\n-            // all patterns are wildcards - we can pick any type we want\n-            cx.tcx.types.bool\n-        }\n+\n+    let pcx = PatternContext {\n+        ty: match rows.iter().filter_map(|r| r[0].pattern_ty).next()\n+            .or_else(|| v[0].pattern_ty)\n+        {\n+            Some(ty) => ty,\n+            None => {\n+                // all patterns are wildcards - we can pick any type we want\n+                cx.tcx.types.bool\n+            }\n+        },\n+        max_slice_length: rows.iter().filter_map(|row| match row[0].pat.node {\n+            PatKind::Slice(ref before, _, ref after) => Some(before.len() + after.len()),\n+            _ => None\n+        }).max().map_or(0, |v| v + 1)\n     };\n \n-    let max_slice_length = rows.iter().filter_map(|row| match row[0].pat.node {\n-        PatKind::Slice(ref before, _, ref after) => Some(before.len() + after.len()),\n-        _ => None\n-    }).max().map_or(0, |v| v + 1);\n+    debug!(\"is_useful: pcx={:?}, expanding {:?}\", pcx, v[0]);\n \n-    let constructors = pat_constructors(cx, v[0], left_ty, max_slice_length);\n-    debug!(\"is_useful - pat_constructors = {:?} left_ty = {:?}\", constructors,\n-           left_ty);\n-    if constructors.is_empty() {\n-        let constructors = missing_constructors(cx, matrix, left_ty, max_slice_length);\n+    if let Some(constructors) = pat_constructors(cx, v[0], pcx) {\n+        debug!(\"is_useful - expanding constructors: {:?}\", constructors);\n+        constructors.into_iter().map(|c|\n+            is_useful_specialized(cx, matrix, v, c.clone(), pcx.ty, witness)\n+        ).find(|result| result != &NotUseful).unwrap_or(NotUseful)\n+    } else {\n+        debug!(\"is_useful - expanding wildcard\");\n+        let constructors = missing_constructors(cx, matrix, pcx);\n         debug!(\"is_useful - missing_constructors = {:?}\", constructors);\n         if constructors.is_empty() {\n-            all_constructors(cx, left_ty, max_slice_length).into_iter().map(|c| {\n-                match is_useful_specialized(cx, matrix, v, c.clone(), left_ty, witness) {\n-                    UsefulWithWitness(pats) => UsefulWithWitness({\n-                        let arity = constructor_arity(cx, &c, left_ty);\n-                        let mut result = {\n-                            let pat_slice = &pats[..];\n-                            let subpats: Vec<_> = (0..arity).map(|i| {\n-                                pat_slice.get(i).map_or(DUMMY_WILD_PAT, |p| &**p)\n-                            }).collect();\n-                            vec![construct_witness(cx, &c, subpats, left_ty)]\n-                        };\n-                        result.extend(pats.into_iter().skip(arity));\n-                        result\n-                    }),\n-                    result => result\n-                }\n+            all_constructors(cx, pcx).into_iter().map(|c| {\n+                is_useful_specialized(cx, matrix, v, c.clone(), pcx.ty, witness)\n             }).find(|result| result != &NotUseful).unwrap_or(NotUseful)\n         } else {\n             let matrix = rows.iter().filter_map(|r| {\n@@ -380,21 +414,15 @@ pub fn is_useful<'a, 'tcx>(cx: &MatchCheckCtxt<'a, 'tcx>,\n             }).collect();\n             match is_useful(cx, &matrix, &v[1..], witness) {\n                 UsefulWithWitness(pats) => {\n-                    let mut new_pats: Vec<_> = constructors.into_iter().map(|constructor| {\n-                        let arity = constructor_arity(cx, &constructor, left_ty);\n-                        let wild_pats = vec![DUMMY_WILD_PAT; arity];\n-                        construct_witness(cx, &constructor, wild_pats, left_ty)\n-                    }).collect();\n-                    new_pats.extend(pats);\n-                    UsefulWithWitness(new_pats)\n-                },\n+                    UsefulWithWitness(pats.into_iter().flat_map(|witness| {\n+                        constructors.iter().map(move |ctor| {\n+                            witness.clone().push_wild_constructor(cx, ctor, pcx.ty)\n+                        })\n+                    }).collect())\n+                }\n                 result => result\n             }\n         }\n-    } else {\n-        constructors.into_iter().map(|c|\n-            is_useful_specialized(cx, matrix, v, c.clone(), left_ty, witness)\n-        ).find(|result| result != &NotUseful).unwrap_or(NotUseful)\n     }\n }\n \n@@ -411,7 +439,14 @@ fn is_useful_specialized<'a, 'tcx>(\n         specialize(cx, &r[..], &ctor, 0, arity)\n     }).collect());\n     match specialize(cx, v, &ctor, 0, arity) {\n-        Some(v) => is_useful(cx, &matrix, &v[..], witness),\n+        Some(v) => match is_useful(cx, &matrix, &v[..], witness) {\n+            UsefulWithWitness(witnesses) => UsefulWithWitness(\n+                witnesses.into_iter()\n+                    .map(|witness| witness.apply_constructor(cx, &ctor, lty))\n+                    .collect()\n+            ),\n+            result => result\n+        },\n         None => NotUseful\n     }\n }\n@@ -423,41 +458,43 @@ fn is_useful_specialized<'a, 'tcx>(\n /// Slice patterns, however, can match slices of different lengths. For instance,\n /// `[a, b, ..tail]` can match a slice of length 2, 3, 4 and so on.\n ///\n-/// On the other hand, a wild pattern and an identifier pattern cannot be\n-/// specialized in any way.\n-fn pat_constructors(cx: &MatchCheckCtxt, p: Pattern,\n-                    left_ty: Ty, max_slice_length: usize) -> Vec<Constructor> {\n+/// Returns None in case of a catch-all, which can't be specialized.\n+fn pat_constructors(cx: &MatchCheckCtxt,\n+                    p: Pattern,\n+                    pcx: PatternContext)\n+                    -> Option<Vec<Constructor>>\n+{\n     let pat = p.as_raw();\n     match pat.node {\n         PatKind::Struct(..) | PatKind::TupleStruct(..) | PatKind::Path(..) =>\n             match cx.tcx.expect_def(pat.id) {\n-                Def::Variant(id) | Def::VariantCtor(id, _) => vec![Variant(id)],\n+                Def::Variant(id) | Def::VariantCtor(id, _) => Some(vec![Variant(id)]),\n                 Def::Struct(..) | Def::StructCtor(..) | Def::Union(..) |\n-                Def::TyAlias(..) | Def::AssociatedTy(..) => vec![Single],\n+                Def::TyAlias(..) | Def::AssociatedTy(..) => Some(vec![Single]),\n                 Def::Const(..) | Def::AssociatedConst(..) =>\n                     span_bug!(p.span(), \"const pattern should've been rewritten\"),\n                 def => span_bug!(p.span(), \"pat_constructors: unexpected definition {:?}\", def),\n             },\n         PatKind::Lit(ref expr) =>\n-            vec![ConstantValue(eval_const_expr(cx.tcx, &expr))],\n+            Some(vec![ConstantValue(eval_const_expr(cx.tcx, &expr))]),\n         PatKind::Range(ref lo, ref hi) =>\n-            vec![ConstantRange(eval_const_expr(cx.tcx, &lo), eval_const_expr(cx.tcx, &hi))],\n+            Some(vec![ConstantRange(eval_const_expr(cx.tcx, &lo), eval_const_expr(cx.tcx, &hi))]),\n         PatKind::Slice(ref before, ref slice, ref after) =>\n-            match left_ty.sty {\n-                ty::TyArray(..) => vec![Single],\n+            match pcx.ty.sty {\n+                ty::TyArray(..) => Some(vec![Single]),\n                 ty::TySlice(_) if slice.is_some() => {\n-                    (before.len() + after.len()..max_slice_length+1)\n-                        .map(|length| Slice(length))\n-                        .collect()\n+                    Some((before.len() + after.len()..pcx.max_slice_length+1)\n+                         .map(|length| Slice(length))\n+                         .collect())\n                 }\n-                ty::TySlice(_) => vec!(Slice(before.len() + after.len())),\n+                ty::TySlice(_) => Some(vec!(Slice(before.len() + after.len()))),\n                 _ => span_bug!(pat.span, \"pat_constructors: unexpected \\\n-                                          slice pattern type {:?}\", left_ty)\n+                                          slice pattern type {:?}\", pcx.ty)\n             },\n         PatKind::Box(..) | PatKind::Tuple(..) | PatKind::Ref(..) =>\n-            vec![Single],\n+            Some(vec![Single]),\n         PatKind::Binding(..) | PatKind::Wild =>\n-            vec![],\n+            None,\n     }\n }\n \n@@ -466,7 +503,7 @@ fn pat_constructors(cx: &MatchCheckCtxt, p: Pattern,\n ///\n /// For instance, a tuple pattern (_, 42, Some([])) has the arity of 3.\n /// A struct pattern's arity is the number of fields it contains, etc.\n-pub fn constructor_arity(_cx: &MatchCheckCtxt, ctor: &Constructor, ty: Ty) -> usize {\n+fn constructor_arity(_cx: &MatchCheckCtxt, ctor: &Constructor, ty: Ty) -> usize {\n     debug!(\"constructor_arity({:?}, {:?})\", ctor, ty);\n     match ty.sty {\n         ty::TyTuple(ref fs) => fs.len(),\n@@ -685,7 +722,7 @@ fn specialize<'a, 'b, 'tcx>(\n \n pub fn is_refutable<A, F>(cx: &MatchCheckCtxt, pat: &Pat, refutable: F)\n                           -> Option<A> where\n-    F: FnOnce(&Pat) -> A,\n+    F: FnOnce(&Witness) -> A,\n {\n     let pats = Matrix(vec!(vec!(wrap_pat(cx, pat))));\n     match is_useful(cx, &pats, &[DUMMY_WILD_PATTERN], ConstructWitness) {"}, {"sha": "d7ce3253af546a1086106ff031a2fec7a35fc300", "filename": "src/librustc_const_eval/check_match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/04a92a1f567ec39558235d0c8ecf12de5d297139/src%2Flibrustc_const_eval%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04a92a1f567ec39558235d0c8ecf12de5d297139/src%2Flibrustc_const_eval%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fcheck_match.rs?ref=04a92a1f567ec39558235d0c8ecf12de5d297139", "patch": "@@ -297,7 +297,7 @@ fn check_exhaustive<'a, 'tcx>(cx: &MatchCheckCtxt<'a, 'tcx>,\n             let witnesses = if pats.is_empty() {\n                 vec![DUMMY_WILD_PAT]\n             } else {\n-                pats.iter().map(|w| &**w).collect()\n+                pats.iter().map(|w| w.single_pattern()).collect()\n             };\n             match source {\n                 hir::MatchSource::ForLoopDesugar => {\n@@ -484,7 +484,7 @@ fn check_irrefutable(cx: &MatchCheckCtxt, pat: &Pat, is_fn_arg: bool) {\n     };\n \n     is_refutable(cx, pat, |uncovered_pat| {\n-        let pattern_string = pat_to_string(uncovered_pat);\n+        let pattern_string = pat_to_string(uncovered_pat.single_pattern());\n         struct_span_err!(cx.tcx.sess, pat.span, E0005,\n             \"refutable pattern in {}: `{}` not covered\",\n             origin,"}, {"sha": "6497f69035dec96497fa8736964f1f8becd3966f", "filename": "src/test/ui/check_match/issue-35609.rs", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/04a92a1f567ec39558235d0c8ecf12de5d297139/src%2Ftest%2Fui%2Fcheck_match%2Fissue-35609.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04a92a1f567ec39558235d0c8ecf12de5d297139/src%2Ftest%2Fui%2Fcheck_match%2Fissue-35609.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcheck_match%2Fissue-35609.rs?ref=04a92a1f567ec39558235d0c8ecf12de5d297139", "patch": "@@ -0,0 +1,53 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+enum Enum {\n+    A, B, C, D, E, F\n+}\n+use Enum::*;\n+\n+struct S(Enum, ());\n+struct Sd { x: Enum, y: () }\n+\n+fn main() {\n+    match (A, ()) {\n+        (A, _) => {}\n+    }\n+\n+    match (A, A) {\n+        (_, A) => {}\n+    }\n+\n+    match ((A, ()), ()) {\n+        ((A, ()), _) => {}\n+    }\n+\n+    match ((A, ()), A) {\n+        ((A, ()), _) => {}\n+    }\n+\n+    match ((A, ()), ()) {\n+        ((A, _), _) => {}\n+    }\n+\n+\n+    match S(A, ()) {\n+        S(A, _) => {}\n+    }\n+\n+    match (Sd { x: A, y: () }) {\n+        Sd { x: A, y: _ } => {}\n+    }\n+\n+    match Some(A) {\n+        Some(A) => (),\n+        None => ()\n+    }\n+}"}, {"sha": "66069c7a86a344a25a7c26cdce8bb5c842756f47", "filename": "src/test/ui/check_match/issue-35609.stderr", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/04a92a1f567ec39558235d0c8ecf12de5d297139/src%2Ftest%2Fui%2Fcheck_match%2Fissue-35609.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/04a92a1f567ec39558235d0c8ecf12de5d297139/src%2Ftest%2Fui%2Fcheck_match%2Fissue-35609.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcheck_match%2Fissue-35609.stderr?ref=04a92a1f567ec39558235d0c8ecf12de5d297139", "patch": "@@ -0,0 +1,50 @@\n+error[E0004]: non-exhaustive patterns: `(B, _)`, `(C, _)`, `(D, _)` and 2 more not covered\n+  --> $DIR/issue-35609.rs:20:11\n+   |\n+20 |     match (A, ()) {\n+   |           ^^^^^^^ patterns `(B, _)`, `(C, _)`, `(D, _)` and 2 more not covered\n+\n+error[E0004]: non-exhaustive patterns: `(A, B)`, `(B, B)`, `(C, B)` and 27 more not covered\n+  --> $DIR/issue-35609.rs:24:11\n+   |\n+24 |     match (A, A) {\n+   |           ^^^^^^ patterns `(A, B)`, `(B, B)`, `(C, B)` and 27 more not covered\n+\n+error[E0004]: non-exhaustive patterns: `((B, _), _)`, `((C, _), _)`, `((D, _), _)` and 2 more not covered\n+  --> $DIR/issue-35609.rs:28:11\n+   |\n+28 |     match ((A, ()), ()) {\n+   |           ^^^^^^^^^^^^^ patterns `((B, _), _)`, `((C, _), _)`, `((D, _), _)` and 2 more not covered\n+\n+error[E0004]: non-exhaustive patterns: `((B, _), _)`, `((C, _), _)`, `((D, _), _)` and 2 more not covered\n+  --> $DIR/issue-35609.rs:32:11\n+   |\n+32 |     match ((A, ()), A) {\n+   |           ^^^^^^^^^^^^ patterns `((B, _), _)`, `((C, _), _)`, `((D, _), _)` and 2 more not covered\n+\n+error[E0004]: non-exhaustive patterns: `((B, _), _)`, `((C, _), _)`, `((D, _), _)` and 2 more not covered\n+  --> $DIR/issue-35609.rs:36:11\n+   |\n+36 |     match ((A, ()), ()) {\n+   |           ^^^^^^^^^^^^^ patterns `((B, _), _)`, `((C, _), _)`, `((D, _), _)` and 2 more not covered\n+\n+error[E0004]: non-exhaustive patterns: `S(B, _)`, `S(C, _)`, `S(D, _)` and 2 more not covered\n+  --> $DIR/issue-35609.rs:41:11\n+   |\n+41 |     match S(A, ()) {\n+   |           ^^^^^^^^ patterns `S(B, _)`, `S(C, _)`, `S(D, _)` and 2 more not covered\n+\n+error[E0004]: non-exhaustive patterns: `Sd { x: B, .. }`, `Sd { x: C, .. }`, `Sd { x: D, .. }` and 2 more not covered\n+  --> $DIR/issue-35609.rs:45:11\n+   |\n+45 |     match (Sd { x: A, y: () }) {\n+   |           ^^^^^^^^^^^^^^^^^^^^ patterns `Sd { x: B, .. }`, `Sd { x: C, .. }`, `Sd { x: D, .. }` and 2 more not covered\n+\n+error[E0004]: non-exhaustive patterns: `Some(B)`, `Some(C)`, `Some(D)` and 2 more not covered\n+  --> $DIR/issue-35609.rs:49:11\n+   |\n+49 |     match Some(A) {\n+   |           ^^^^^^^ patterns `Some(B)`, `Some(C)`, `Some(D)` and 2 more not covered\n+\n+error: aborting due to 8 previous errors\n+"}]}