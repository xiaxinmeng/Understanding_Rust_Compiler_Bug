{"sha": "e98ea52762e7ecf492b3a1880deb78610ef22996", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU5OGVhNTI3NjJlN2VjZjQ5MmIzYTE4ODBkZWI3ODYxMGVmMjI5OTY=", "commit": {"author": {"name": "Ashley Mannix", "email": "ashleymannix@live.com.au", "date": "2019-05-01T07:19:41Z"}, "committer": {"name": "Ashley Mannix", "email": "ashleymannix@live.com.au", "date": "2019-07-07T23:56:02Z"}, "message": "add key and value methods to DebugMap", "tree": {"sha": "2f6503b9256b12a67fb8d4286415ad9b661ef381", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2f6503b9256b12a67fb8d4286415ad9b661ef381"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e98ea52762e7ecf492b3a1880deb78610ef22996", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e98ea52762e7ecf492b3a1880deb78610ef22996", "html_url": "https://github.com/rust-lang/rust/commit/e98ea52762e7ecf492b3a1880deb78610ef22996", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e98ea52762e7ecf492b3a1880deb78610ef22996/comments", "author": {"login": "KodrAus", "id": 6721458, "node_id": "MDQ6VXNlcjY3MjE0NTg=", "avatar_url": "https://avatars.githubusercontent.com/u/6721458?v=4", "gravatar_id": "", "url": "https://api.github.com/users/KodrAus", "html_url": "https://github.com/KodrAus", "followers_url": "https://api.github.com/users/KodrAus/followers", "following_url": "https://api.github.com/users/KodrAus/following{/other_user}", "gists_url": "https://api.github.com/users/KodrAus/gists{/gist_id}", "starred_url": "https://api.github.com/users/KodrAus/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/KodrAus/subscriptions", "organizations_url": "https://api.github.com/users/KodrAus/orgs", "repos_url": "https://api.github.com/users/KodrAus/repos", "events_url": "https://api.github.com/users/KodrAus/events{/privacy}", "received_events_url": "https://api.github.com/users/KodrAus/received_events", "type": "User", "site_admin": false}, "committer": {"login": "KodrAus", "id": 6721458, "node_id": "MDQ6VXNlcjY3MjE0NTg=", "avatar_url": "https://avatars.githubusercontent.com/u/6721458?v=4", "gravatar_id": "", "url": "https://api.github.com/users/KodrAus", "html_url": "https://github.com/KodrAus", "followers_url": "https://api.github.com/users/KodrAus/followers", "following_url": "https://api.github.com/users/KodrAus/following{/other_user}", "gists_url": "https://api.github.com/users/KodrAus/gists{/gist_id}", "starred_url": "https://api.github.com/users/KodrAus/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/KodrAus/subscriptions", "organizations_url": "https://api.github.com/users/KodrAus/orgs", "repos_url": "https://api.github.com/users/KodrAus/repos", "events_url": "https://api.github.com/users/KodrAus/events{/privacy}", "received_events_url": "https://api.github.com/users/KodrAus/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d3e2cec29225a46298ec4ebf082f34ebd7cfeecf", "url": "https://api.github.com/repos/rust-lang/rust/commits/d3e2cec29225a46298ec4ebf082f34ebd7cfeecf", "html_url": "https://github.com/rust-lang/rust/commit/d3e2cec29225a46298ec4ebf082f34ebd7cfeecf"}], "stats": {"total": 261, "additions": 236, "deletions": 25}, "files": [{"sha": "ae839bf2ac32b7d96c419045d2a436554ae6445a", "filename": "src/doc/unstable-book/src/library-features/debug-map-key-value.md", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e98ea52762e7ecf492b3a1880deb78610ef22996/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fdebug-map-key-value.md", "raw_url": "https://github.com/rust-lang/rust/raw/e98ea52762e7ecf492b3a1880deb78610ef22996/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fdebug-map-key-value.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fdebug-map-key-value.md?ref=e98ea52762e7ecf492b3a1880deb78610ef22996", "patch": "@@ -0,0 +1,9 @@\n+# `debug_map_key_value`\n+\n+The tracking issue for this feature is: [#62482]\n+\n+[#62482]: https://github.com/rust-lang/rust/issues/62482\n+\n+------------------------\n+\n+Add the methods `key` and `value` to `DebugMap` so that an entry can be formatted across multiple calls without additional buffering."}, {"sha": "abc97aacbb95a2f48218a2993439a7258bc7788f", "filename": "src/libcore/fmt/builders.rs", "status": "modified", "additions": 141, "deletions": 17, "changes": 158, "blob_url": "https://github.com/rust-lang/rust/blob/e98ea52762e7ecf492b3a1880deb78610ef22996/src%2Flibcore%2Ffmt%2Fbuilders.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e98ea52762e7ecf492b3a1880deb78610ef22996/src%2Flibcore%2Ffmt%2Fbuilders.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fbuilders.rs?ref=e98ea52762e7ecf492b3a1880deb78610ef22996", "patch": "@@ -1,37 +1,50 @@\n use crate::fmt;\n \n-struct PadAdapter<'a> {\n-    buf: &'a mut (dyn fmt::Write + 'a),\n+struct PadAdapter<'buf, 'state> {\n+    buf: &'buf mut (dyn fmt::Write + 'buf),\n+    state: &'state mut PadAdapterState,\n+}\n+\n+struct PadAdapterState {\n     on_newline: bool,\n }\n \n-impl<'a> PadAdapter<'a> {\n-    fn wrap<'b, 'c: 'a+'b>(fmt: &'c mut fmt::Formatter<'_>, slot: &'b mut Option<Self>)\n-                        -> fmt::Formatter<'b> {\n+impl Default for PadAdapterState {\n+    fn default() -> Self {\n+        PadAdapterState {\n+            on_newline: true,\n+        }\n+    }\n+}\n+\n+impl<'buf, 'state> PadAdapter<'buf, 'state> {\n+    fn wrap<'slot, 'fmt: 'buf+'slot>(fmt: &'fmt mut fmt::Formatter<'_>,\n+                                     slot: &'slot mut Option<Self>,\n+                                     state: &'state mut PadAdapterState) -> fmt::Formatter<'slot> {\n         fmt.wrap_buf(move |buf| {\n             *slot = Some(PadAdapter {\n                 buf,\n-                on_newline: true,\n+                state,\n             });\n             slot.as_mut().unwrap()\n         })\n     }\n }\n \n-impl fmt::Write for PadAdapter<'_> {\n+impl fmt::Write for PadAdapter<'_, '_> {\n     fn write_str(&mut self, mut s: &str) -> fmt::Result {\n         while !s.is_empty() {\n-            if self.on_newline {\n+            if self.state.on_newline {\n                 self.buf.write_str(\"    \")?;\n             }\n \n             let split = match s.find('\\n') {\n                 Some(pos) => {\n-                    self.on_newline = true;\n+                    self.state.on_newline = true;\n                     pos + 1\n                 }\n                 None => {\n-                    self.on_newline = false;\n+                    self.state.on_newline = false;\n                     s.len()\n                 }\n             };\n@@ -133,7 +146,8 @@ impl<'a, 'b: 'a> DebugStruct<'a, 'b> {\n                     self.fmt.write_str(\" {\\n\")?;\n                 }\n                 let mut slot = None;\n-                let mut writer = PadAdapter::wrap(&mut self.fmt, &mut slot);\n+                let mut state = Default::default();\n+                let mut writer = PadAdapter::wrap(&mut self.fmt, &mut slot, &mut state);\n                 writer.write_str(name)?;\n                 writer.write_str(\": \")?;\n                 value.fmt(&mut writer)?;\n@@ -279,7 +293,8 @@ impl<'a, 'b: 'a> DebugTuple<'a, 'b> {\n                     self.fmt.write_str(\"(\\n\")?;\n                 }\n                 let mut slot = None;\n-                let mut writer = PadAdapter::wrap(&mut self.fmt, &mut slot);\n+                let mut state = Default::default();\n+                let mut writer = PadAdapter::wrap(&mut self.fmt, &mut slot, &mut state);\n                 value.fmt(&mut writer)?;\n                 writer.write_str(\",\\n\")\n             } else {\n@@ -349,7 +364,8 @@ impl<'a, 'b: 'a> DebugInner<'a, 'b> {\n                     self.fmt.write_str(\"\\n\")?;\n                 }\n                 let mut slot = None;\n-                let mut writer = PadAdapter::wrap(&mut self.fmt, &mut slot);\n+                let mut state = Default::default();\n+                let mut writer = PadAdapter::wrap(&mut self.fmt, &mut slot, &mut state);\n                 entry.fmt(&mut writer)?;\n                 writer.write_str(\",\\n\")\n             } else {\n@@ -676,6 +692,9 @@ pub struct DebugMap<'a, 'b: 'a> {\n     fmt: &'a mut fmt::Formatter<'b>,\n     result: fmt::Result,\n     has_fields: bool,\n+    has_key: bool,\n+    // The state of newlines is tracked between keys and values\n+    state: PadAdapterState,\n }\n \n pub fn debug_map_new<'a, 'b>(fmt: &'a mut fmt::Formatter<'b>) -> DebugMap<'a, 'b> {\n@@ -684,6 +703,8 @@ pub fn debug_map_new<'a, 'b>(fmt: &'a mut fmt::Formatter<'b>) -> DebugMap<'a, 'b\n         fmt,\n         result,\n         has_fields: false,\n+        has_key: false,\n+        state: Default::default(),\n     }\n }\n \n@@ -712,25 +733,121 @@ impl<'a, 'b: 'a> DebugMap<'a, 'b> {\n     /// ```\n     #[stable(feature = \"debug_builders\", since = \"1.2.0\")]\n     pub fn entry(&mut self, key: &dyn fmt::Debug, value: &dyn fmt::Debug) -> &mut DebugMap<'a, 'b> {\n+        self.key(key).value(value)\n+    }\n+\n+    /// Adds the key part of a new entry to the map output.\n+    ///\n+    /// This method, together with `value`, is an alternative to `entry` that\n+    /// can be used when the complete entry isn't known upfront. Prefer the `entry`\n+    /// method when it's possible to use.\n+    ///\n+    /// # Panics\n+    ///\n+    /// `key` must be called before `value` and each call to `key` must be followed\n+    /// by a corresponding call to `value`. Otherwise this method will panic.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::fmt;\n+    ///\n+    /// struct Foo(Vec<(String, i32)>);\n+    ///\n+    /// impl fmt::Debug for Foo {\n+    ///     fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n+    ///         fmt.debug_map()\n+    ///            .key(&\"whole\").value(&self.0) // We add the \"whole\" entry.\n+    ///            .finish()\n+    ///     }\n+    /// }\n+    ///\n+    /// assert_eq!(\n+    ///     format!(\"{:?}\", Foo(vec![(\"A\".to_string(), 10), (\"B\".to_string(), 11)])),\n+    ///     \"{\\\"whole\\\": [(\\\"A\\\", 10), (\\\"B\\\", 11)]}\",\n+    /// );\n+    /// ```\n+    #[unstable(feature = \"debug_map_key_value\",\n+               reason = \"recently added\",\n+               issue = \"62482\")]\n+    pub fn key(&mut self, key: &dyn fmt::Debug) -> &mut DebugMap<'a, 'b> {\n+        assert!(!self.has_key, \"attempted to begin a new map entry \\\n+                                without completing the previous one\");\n+\n         self.result = self.result.and_then(|_| {\n             if self.is_pretty() {\n                 if !self.has_fields {\n                     self.fmt.write_str(\"\\n\")?;\n                 }\n                 let mut slot = None;\n-                let mut writer = PadAdapter::wrap(&mut self.fmt, &mut slot);\n+                self.state = Default::default();\n+                let mut writer = PadAdapter::wrap(&mut self.fmt, &mut slot, &mut self.state);\n                 key.fmt(&mut writer)?;\n                 writer.write_str(\": \")?;\n-                value.fmt(&mut writer)?;\n-                writer.write_str(\",\\n\")\n             } else {\n                 if self.has_fields {\n                     self.fmt.write_str(\", \")?\n                 }\n                 key.fmt(self.fmt)?;\n                 self.fmt.write_str(\": \")?;\n-                value.fmt(self.fmt)\n             }\n+\n+            self.has_key = true;\n+            Ok(())\n+        });\n+\n+        self\n+    }\n+\n+    /// Adds the value part of a new entry to the map output.\n+    ///\n+    /// This method, together with `key`, is an alternative to `entry` that\n+    /// can be used when the complete entry isn't known upfront. Prefer the `entry`\n+    /// method when it's possible to use.\n+    ///\n+    /// # Panics\n+    ///\n+    /// `key` must be called before `value` and each call to `key` must be followed\n+    /// by a corresponding call to `value`. Otherwise this method will panic.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::fmt;\n+    ///\n+    /// struct Foo(Vec<(String, i32)>);\n+    ///\n+    /// impl fmt::Debug for Foo {\n+    ///     fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n+    ///         fmt.debug_map()\n+    ///            .key(&\"whole\").value(&self.0) // We add the \"whole\" entry.\n+    ///            .finish()\n+    ///     }\n+    /// }\n+    ///\n+    /// assert_eq!(\n+    ///     format!(\"{:?}\", Foo(vec![(\"A\".to_string(), 10), (\"B\".to_string(), 11)])),\n+    ///     \"{\\\"whole\\\": [(\\\"A\\\", 10), (\\\"B\\\", 11)]}\",\n+    /// );\n+    /// ```\n+    #[unstable(feature = \"debug_map_key_value\",\n+               reason = \"recently added\",\n+               issue = \"62482\")]\n+    pub fn value(&mut self, value: &dyn fmt::Debug) -> &mut DebugMap<'a, 'b> {\n+        assert!(self.has_key, \"attempted to format a map value before its key\");\n+\n+        self.result = self.result.and_then(|_| {\n+            if self.is_pretty() {\n+                let mut slot = None;\n+                let mut writer = PadAdapter::wrap(&mut self.fmt, &mut slot, &mut self.state);\n+                value.fmt(&mut writer)?;\n+                writer.write_str(\",\\n\")?;\n+            } else {\n+                value.fmt(self.fmt)?;\n+            }\n+\n+            self.has_key = false;\n+            Ok(())\n         });\n \n         self.has_fields = true;\n@@ -775,6 +892,11 @@ impl<'a, 'b: 'a> DebugMap<'a, 'b> {\n \n     /// Finishes output and returns any error encountered.\n     ///\n+    /// # Panics\n+    ///\n+    /// `key` must be called before `value` and each call to `key` must be followed\n+    /// by a corresponding call to `value`. Otherwise this method will panic.\n+    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -797,6 +919,8 @@ impl<'a, 'b: 'a> DebugMap<'a, 'b> {\n     /// ```\n     #[stable(feature = \"debug_builders\", since = \"1.2.0\")]\n     pub fn finish(&mut self) -> fmt::Result {\n+        assert!(!self.has_key, \"attempted to finish a map with a partial entry\");\n+\n         self.result.and_then(|_| self.fmt.write_str(\"}\"))\n     }\n "}, {"sha": "200659b91bb4ec696697e0423347c4fbb720cb3c", "filename": "src/libcore/tests/fmt/builders.rs", "status": "modified", "additions": 85, "deletions": 8, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/e98ea52762e7ecf492b3a1880deb78610ef22996/src%2Flibcore%2Ftests%2Ffmt%2Fbuilders.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e98ea52762e7ecf492b3a1880deb78610ef22996/src%2Flibcore%2Ftests%2Ffmt%2Fbuilders.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Ffmt%2Fbuilders.rs?ref=e98ea52762e7ecf492b3a1880deb78610ef22996", "patch": "@@ -211,29 +211,42 @@ mod debug_map {\n \n     #[test]\n     fn test_single() {\n-        struct Foo;\n+        struct Entry;\n \n-        impl fmt::Debug for Foo {\n+        impl fmt::Debug for Entry {\n             fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n                 fmt.debug_map()\n                     .entry(&\"bar\", &true)\n                     .finish()\n             }\n         }\n \n-        assert_eq!(\"{\\\"bar\\\": true}\", format!(\"{:?}\", Foo));\n+        struct KeyValue;\n+\n+        impl fmt::Debug for KeyValue {\n+            fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n+                fmt.debug_map()\n+                    .key(&\"bar\").value(&true)\n+                    .finish()\n+            }\n+        }\n+\n+        assert_eq!(format!(\"{:?}\", Entry), format!(\"{:?}\", KeyValue));\n+        assert_eq!(format!(\"{:#?}\", Entry), format!(\"{:#?}\", KeyValue));\n+\n+        assert_eq!(\"{\\\"bar\\\": true}\", format!(\"{:?}\", Entry));\n         assert_eq!(\n \"{\n     \\\"bar\\\": true,\n }\",\n-                   format!(\"{:#?}\", Foo));\n+                   format!(\"{:#?}\", Entry));\n     }\n \n     #[test]\n     fn test_multiple() {\n-        struct Foo;\n+        struct Entry;\n \n-        impl fmt::Debug for Foo {\n+        impl fmt::Debug for Entry {\n             fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n                 fmt.debug_map()\n                     .entry(&\"bar\", &true)\n@@ -242,13 +255,27 @@ mod debug_map {\n             }\n         }\n \n-        assert_eq!(\"{\\\"bar\\\": true, 10: 10/20}\", format!(\"{:?}\", Foo));\n+        struct KeyValue;\n+\n+        impl fmt::Debug for KeyValue {\n+            fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n+                fmt.debug_map()\n+                    .key(&\"bar\").value(&true)\n+                    .key(&10).value(&format_args!(\"{}/{}\", 10, 20))\n+                    .finish()\n+            }\n+        }\n+\n+        assert_eq!(format!(\"{:?}\", Entry), format!(\"{:?}\", KeyValue));\n+        assert_eq!(format!(\"{:#?}\", Entry), format!(\"{:#?}\", KeyValue));\n+\n+        assert_eq!(\"{\\\"bar\\\": true, 10: 10/20}\", format!(\"{:?}\", Entry));\n         assert_eq!(\n \"{\n     \\\"bar\\\": true,\n     10: 10/20,\n }\",\n-                   format!(\"{:#?}\", Foo));\n+                   format!(\"{:#?}\", Entry));\n     }\n \n     #[test]\n@@ -291,6 +318,56 @@ mod debug_map {\n }\",\n                    format!(\"{:#?}\", Bar));\n     }\n+\n+    #[test]\n+    #[should_panic]\n+    fn test_invalid_key_when_entry_is_incomplete() {\n+        struct Foo;\n+\n+        impl fmt::Debug for Foo {\n+            fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n+                fmt.debug_map()\n+                    .key(&\"bar\")\n+                    .key(&\"invalid\")\n+                    .finish()\n+            }\n+        }\n+\n+        format!(\"{:?}\", Foo);\n+    }\n+\n+    #[test]\n+    #[should_panic]\n+    fn test_invalid_finish_incomplete_entry() {\n+        struct Foo;\n+\n+        impl fmt::Debug for Foo {\n+            fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n+                fmt.debug_map()\n+                    .key(&\"bar\")\n+                    .finish()\n+            }\n+        }\n+\n+        format!(\"{:?}\", Foo);\n+    }\n+\n+    #[test]\n+    #[should_panic]\n+    fn test_invalid_value_before_key() {\n+        struct Foo;\n+\n+        impl fmt::Debug for Foo {\n+            fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n+                fmt.debug_map()\n+                    .value(&\"invalid\")\n+                    .key(&\"bar\")\n+                    .finish()\n+            }\n+        }\n+\n+        format!(\"{:?}\", Foo);\n+    }\n }\n \n mod debug_set {"}, {"sha": "4b48d1225902b808e3aee7dde9edb2fc2baa844e", "filename": "src/libcore/tests/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e98ea52762e7ecf492b3a1880deb78610ef22996/src%2Flibcore%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e98ea52762e7ecf492b3a1880deb78610ef22996/src%2Flibcore%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Flib.rs?ref=e98ea52762e7ecf492b3a1880deb78610ef22996", "patch": "@@ -3,6 +3,7 @@\n #![feature(cell_update)]\n #![feature(core_private_bignum)]\n #![feature(core_private_diy_float)]\n+#![feature(debug_map_key_value)]\n #![feature(dec2flt)]\n #![feature(euclidean_division)]\n #![feature(exact_size_is_empty)]"}]}