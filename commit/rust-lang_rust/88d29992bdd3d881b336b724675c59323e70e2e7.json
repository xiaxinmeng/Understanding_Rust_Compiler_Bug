{"sha": "88d29992bdd3d881b336b724675c59323e70e2e7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg4ZDI5OTkyYmRkM2Q4ODFiMzM2YjcyNDY3NWM1OTMyM2U3MGUyZTc=", "commit": {"author": {"name": "Nicholas Nethercote", "email": "nnethercote@mozilla.com", "date": "2019-05-17T00:44:51Z"}, "committer": {"name": "Nicholas Nethercote", "email": "nnethercote@mozilla.com", "date": "2019-05-20T04:46:55Z"}, "message": "Remove `Symbol::gensym()`.", "tree": {"sha": "b0f2bd78bad101b6d3dd332ffbc0a2ceb9daa972", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b0f2bd78bad101b6d3dd332ffbc0a2ceb9daa972"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/88d29992bdd3d881b336b724675c59323e70e2e7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/88d29992bdd3d881b336b724675c59323e70e2e7", "html_url": "https://github.com/rust-lang/rust/commit/88d29992bdd3d881b336b724675c59323e70e2e7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/88d29992bdd3d881b336b724675c59323e70e2e7/comments", "author": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e57c0dbeb72cf631930429a20badd41290bb0608", "url": "https://api.github.com/repos/rust-lang/rust/commits/e57c0dbeb72cf631930429a20badd41290bb0608", "html_url": "https://github.com/rust-lang/rust/commit/e57c0dbeb72cf631930429a20badd41290bb0608"}], "stats": {"total": 95, "additions": 52, "deletions": 43}, "files": [{"sha": "6931b3542f7614c25a7314e7dbbd107da9f27697", "filename": "src/librustc_allocator/expand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/88d29992bdd3d881b336b724675c59323e70e2e7/src%2Flibrustc_allocator%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88d29992bdd3d881b336b724675c59323e70e2e7/src%2Flibrustc_allocator%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_allocator%2Fexpand.rs?ref=88d29992bdd3d881b336b724675c59323e70e2e7", "patch": "@@ -140,7 +140,7 @@ impl MutVisitor for ExpandAllocatorDirectives<'_> {\n \n         // Generate the submodule itself\n         let name = f.kind.fn_name(\"allocator_abi\");\n-        let allocator_abi = Ident::with_empty_ctxt(Symbol::gensym(&name));\n+        let allocator_abi = Ident::from_str(&name).gensym();\n         let module = f.cx.item_mod(span, span, allocator_abi, Vec::new(), items);\n         let module = f.cx.monotonic_expander().flat_map_item(module).pop().unwrap();\n "}, {"sha": "3b58a99d19fe00b8389af4716511bd535327ec32", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/88d29992bdd3d881b336b724675c59323e70e2e7/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88d29992bdd3d881b336b724675c59323e70e2e7/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=88d29992bdd3d881b336b724675c59323e70e2e7", "patch": "@@ -314,7 +314,7 @@ impl<'a> Resolver<'a> {\n                             Ident::new(keywords::SelfLower.name(), new_span)\n                         ),\n                         kind: ast::UseTreeKind::Simple(\n-                            Some(Ident::new(Name::gensym(\"__dummy\"), new_span)),\n+                            Some(Ident::from_str_and_span(\"__dummy\", new_span).gensym()),\n                             ast::DUMMY_NODE_ID,\n                             ast::DUMMY_NODE_ID,\n                         ),"}, {"sha": "c988dc61bec449034082097b18c8ab4e7582a311", "filename": "src/libsyntax/diagnostics/plugin.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/88d29992bdd3d881b336b724675c59323e70e2e7/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88d29992bdd3d881b336b724675c59323e70e2e7/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs?ref=88d29992bdd3d881b336b724675c59323e70e2e7", "patch": "@@ -7,7 +7,7 @@ use crate::ext::base::{ExtCtxt, MacEager, MacResult};\n use crate::ext::build::AstBuilder;\n use crate::parse::token;\n use crate::ptr::P;\n-use crate::symbol::{keywords, Symbol};\n+use crate::symbol::keywords;\n use crate::tokenstream::{TokenTree};\n \n use smallvec::smallvec;\n@@ -121,13 +121,13 @@ pub fn expand_register_diagnostic<'cx>(ecx: &'cx mut ExtCtxt<'_>,\n \n     let span = span.apply_mark(ecx.current_expansion.mark);\n \n-    let sym = Ident::new(Symbol::gensym(&format!(\"__register_diagnostic_{}\", code)), span);\n+    let name = Ident::from_str_and_span(&format!(\"__register_diagnostic_{}\", code), span).gensym();\n \n     MacEager::items(smallvec![\n         ecx.item_mod(\n             span,\n             span,\n-            sym,\n+            name,\n             vec![],\n             vec![],\n         )"}, {"sha": "672b7b4285522b1a13ba1911510257d0f80db99a", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/88d29992bdd3d881b336b724675c59323e70e2e7/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88d29992bdd3d881b336b724675c59323e70e2e7/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=88d29992bdd3d881b336b724675c59323e70e2e7", "patch": "@@ -252,8 +252,8 @@ pub fn compile(\n     def: &ast::Item,\n     edition: Edition\n ) -> SyntaxExtension {\n-    let lhs_nm = ast::Ident::with_empty_ctxt(Symbol::gensym(\"lhs\"));\n-    let rhs_nm = ast::Ident::with_empty_ctxt(Symbol::gensym(\"rhs\"));\n+    let lhs_nm = ast::Ident::from_str(\"lhs\").gensym();\n+    let rhs_nm = ast::Ident::from_str(\"rhs\").gensym();\n \n     // Parse the macro_rules! invocation\n     let body = match def.node {"}, {"sha": "1be7986ad53cd92665335e4d5c8ae1875cc658e3", "filename": "src/libsyntax/std_inject.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/88d29992bdd3d881b336b724675c59323e70e2e7/src%2Flibsyntax%2Fstd_inject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88d29992bdd3d881b336b724675c59323e70e2e7/src%2Flibsyntax%2Fstd_inject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fstd_inject.rs?ref=88d29992bdd3d881b336b724675c59323e70e2e7", "patch": "@@ -2,7 +2,7 @@ use crate::ast;\n use crate::attr;\n use crate::edition::Edition;\n use crate::ext::hygiene::{Mark, SyntaxContext};\n-use crate::symbol::{Symbol, keywords, sym};\n+use crate::symbol::{Ident, Symbol, keywords, sym};\n use crate::source_map::{ExpnInfo, MacroAttribute, dummy_spanned, hygiene, respan};\n use crate::ptr::P;\n use crate::tokenstream::TokenStream;\n@@ -66,10 +66,12 @@ pub fn maybe_inject_crates_ref(\n     for orig_name_str in names.iter().rev() {\n         // HACK(eddyb) gensym the injected crates on the Rust 2018 edition,\n         // so they don't accidentally interfere with the new import paths.\n+        let orig_name_sym = Symbol::intern(orig_name_str);\n+        let orig_name_ident = Ident::with_empty_ctxt(orig_name_sym);\n         let (rename, orig_name) = if rust_2018 {\n-            (Symbol::gensym(orig_name_str), Some(Symbol::intern(orig_name_str)))\n+            (orig_name_ident.gensym(), Some(orig_name_sym))\n         } else {\n-            (Symbol::intern(orig_name_str), None)\n+            (orig_name_ident, None)\n         };\n         krate.module.items.insert(0, P(ast::Item {\n             attrs: vec![attr::mk_attr_outer(\n@@ -79,7 +81,7 @@ pub fn maybe_inject_crates_ref(\n             )],\n             vis: dummy_spanned(ast::VisibilityKind::Inherited),\n             node: ast::ItemKind::ExternCrate(alt_std_name.or(orig_name)),\n-            ident: ast::Ident::with_empty_ctxt(rename),\n+            ident: rename,\n             id: ast::DUMMY_NODE_ID,\n             span: DUMMY_SP,\n             tokens: None,"}, {"sha": "3dc7aad945939da2a34587643e9873606b5f35da", "filename": "src/libsyntax/test.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/88d29992bdd3d881b336b724675c59323e70e2e7/src%2Flibsyntax%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88d29992bdd3d881b336b724675c59323e70e2e7/src%2Flibsyntax%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftest.rs?ref=88d29992bdd3d881b336b724675c59323e70e2e7", "patch": "@@ -232,11 +232,11 @@ fn mk_reexport_mod(cx: &mut TestCtxt<'_>,\n         items,\n     };\n \n-    let sym = Ident::with_empty_ctxt(Symbol::gensym(\"__test_reexports\"));\n+    let name = Ident::from_str(\"__test_reexports\").gensym();\n     let parent = if parent == ast::DUMMY_NODE_ID { ast::CRATE_NODE_ID } else { parent };\n     cx.ext_cx.current_expansion.mark = cx.ext_cx.resolver.get_module_scope(parent);\n     let it = cx.ext_cx.monotonic_expander().flat_map_item(P(ast::Item {\n-        ident: sym,\n+        ident: name,\n         attrs: Vec::new(),\n         id: ast::DUMMY_NODE_ID,\n         node: ast::ItemKind::Mod(reexport_mod),\n@@ -245,7 +245,7 @@ fn mk_reexport_mod(cx: &mut TestCtxt<'_>,\n         tokens: None,\n     })).pop().unwrap();\n \n-    (it, sym)\n+    (it, name)\n }\n \n /// Crawl over the crate, inserting test reexports and the test main function\n@@ -373,9 +373,10 @@ fn mk_main(cx: &mut TestCtxt<'_>) -> P<ast::Item> {\n                            main_body);\n \n     // Honor the reexport_test_harness_main attribute\n-    let main_id = Ident::new(\n-        cx.reexport_test_harness_main.unwrap_or(Symbol::gensym(\"main\")),\n-        sp);\n+    let main_id = match cx.reexport_test_harness_main {\n+        Some(sym) => Ident::new(sym, sp),\n+        None => Ident::from_str_and_span(\"main\", sp).gensym(),\n+    };\n \n     P(ast::Item {\n         ident: main_id,"}, {"sha": "200445d12488007102b6f7adc1cbca1ff0bc52a1", "filename": "src/libsyntax_ext/proc_macro_decls.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/88d29992bdd3d881b336b724675c59323e70e2e7/src%2Flibsyntax_ext%2Fproc_macro_decls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88d29992bdd3d881b336b724675c59323e70e2e7/src%2Flibsyntax_ext%2Fproc_macro_decls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fproc_macro_decls.rs?ref=88d29992bdd3d881b336b724675c59323e70e2e7", "patch": "@@ -429,7 +429,7 @@ fn mk_decls(\n     let module = cx.item_mod(\n         span,\n         span,\n-        ast::Ident::with_empty_ctxt(Symbol::gensym(\"decls\")),\n+        ast::Ident::from_str(\"decls\").gensym(),\n         vec![doc_hidden],\n         vec![krate, decls_static],\n     ).map(|mut i| {"}, {"sha": "fb99be0fe33f3e71e40baecd9e3706e6bbadba5e", "filename": "src/libsyntax_pos/symbol.rs", "status": "modified", "additions": 31, "deletions": 25, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/88d29992bdd3d881b336b724675c59323e70e2e7/src%2Flibsyntax_pos%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88d29992bdd3d881b336b724675c59323e70e2e7/src%2Flibsyntax_pos%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Fsymbol.rs?ref=88d29992bdd3d881b336b724675c59323e70e2e7", "patch": "@@ -630,10 +630,12 @@ pub struct Ident {\n \n impl Ident {\n     #[inline]\n+    /// Constructs a new identifier from a symbol and a span.\n     pub const fn new(name: Symbol, span: Span) -> Ident {\n         Ident { name, span }\n     }\n \n+    /// Constructs a new identifier with an empty syntax context.\n     #[inline]\n     pub const fn with_empty_ctxt(name: Symbol) -> Ident {\n         Ident::new(name, DUMMY_SP)\n@@ -644,11 +646,16 @@ impl Ident {\n         Ident::with_empty_ctxt(string.as_symbol())\n     }\n \n-    /// Maps a string to an identifier with an empty syntax context.\n+    /// Maps a string to an identifier with an empty span.\n     pub fn from_str(string: &str) -> Ident {\n         Ident::with_empty_ctxt(Symbol::intern(string))\n     }\n \n+    /// Maps a string and a span to an identifier.\n+    pub fn from_str_and_span(string: &str, span: Span) -> Ident {\n+        Ident::new(Symbol::intern(string), span)\n+    }\n+\n     /// Replaces `lo` and `hi` with those from `span`, but keep hygiene context.\n     pub fn with_span_pos(self, span: Span) -> Ident {\n         Ident::new(self.name, span.with_ctxt(self.span.ctxt()))\n@@ -676,11 +683,14 @@ impl Ident {\n         Ident::new(self.name, self.span.modern_and_legacy())\n     }\n \n+    /// Transforms an identifier into one with the same name, but gensymed.\n     pub fn gensym(self) -> Ident {\n         let name = with_interner(|interner| interner.gensymed(self.name));\n         Ident::new(name, self.span)\n     }\n \n+    /// Transforms an underscore identifier into one with the same name, but\n+    /// gensymed. Leaves non-underscore identifiers unchanged.\n     pub fn gensym_if_underscore(self) -> Ident {\n         if self.name == keywords::Underscore.name() { self.gensym() } else { self }\n     }\n@@ -742,30 +752,34 @@ impl Decodable for Ident {\n         Ok(if !string.starts_with('#') {\n             Ident::from_str(&string)\n         } else { // FIXME(jseyfried): intercrate hygiene\n-            Ident::with_empty_ctxt(Symbol::gensym(&string[1..]))\n+            Ident::from_str(&string[1..]).gensym()\n         })\n     }\n }\n \n /// A symbol is an interned or gensymed string. A gensym is a symbol that is\n-/// never equal to any other symbol. E.g.:\n-/// ```\n-/// assert_eq!(Symbol::intern(\"x\"), Symbol::intern(\"x\"))\n-/// assert_ne!(Symbol::gensym(\"x\"), Symbol::intern(\"x\"))\n-/// assert_ne!(Symbol::gensym(\"x\"), Symbol::gensym(\"x\"))\n-/// ```\n+/// never equal to any other symbol.\n+///\n /// Conceptually, a gensym can be thought of as a normal symbol with an\n /// invisible unique suffix. Gensyms are useful when creating new identifiers\n /// that must not match any existing identifiers, e.g. during macro expansion\n-/// and syntax desugaring.\n+/// and syntax desugaring. Because gensyms should always be identifiers, all\n+/// gensym operations are on `Ident` rather than `Symbol`. (Indeed, in the\n+/// future the gensym-ness may be moved from `Symbol` to hygiene data.)\n ///\n-/// Internally, a Symbol is implemented as an index, and all operations\n+/// Examples:\n+/// ```\n+/// assert_eq!(Ident::from_str(\"x\"), Ident::from_str(\"x\"))\n+/// assert_ne!(Ident::from_str(\"x\").gensym(), Ident::from_str(\"x\"))\n+/// assert_ne!(Ident::from_str(\"x\").gensym(), Ident::from_str(\"x\").gensym())\n+/// ```\n+/// Internally, a symbol is implemented as an index, and all operations\n /// (including hashing, equality, and ordering) operate on that index. The use\n /// of `newtype_index!` means that `Option<Symbol>` only takes up 4 bytes,\n /// because `newtype_index!` reserves the last 256 values for tagging purposes.\n ///\n-/// Note that `Symbol` cannot directly be a `newtype_index!` because it implements\n-/// `fmt::Debug`, `Encodable`, and `Decodable` in special ways.\n+/// Note that `Symbol` cannot directly be a `newtype_index!` because it\n+/// implements `fmt::Debug`, `Encodable`, and `Decodable` in special ways.\n #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\n pub struct Symbol(SymbolIndex);\n \n@@ -783,11 +797,6 @@ impl Symbol {\n         with_interner(|interner| interner.intern(string))\n     }\n \n-    /// Gensyms a new `usize`, using the current interner.\n-    pub fn gensym(string: &str) -> Self {\n-        with_interner(|interner| interner.gensym(string))\n-    }\n-\n     pub fn as_str(self) -> LocalInternedString {\n         with_interner(|interner| unsafe {\n             LocalInternedString {\n@@ -895,11 +904,6 @@ impl Interner {\n         }\n     }\n \n-    fn gensym(&mut self, string: &str) -> Symbol {\n-        let symbol = self.intern(string);\n-        self.gensymed(symbol)\n-    }\n-\n     fn gensymed(&mut self, symbol: Symbol) -> Symbol {\n         self.gensyms.push(symbol);\n         Symbol::new(SymbolIndex::MAX_AS_U32 - self.gensyms.len() as u32 + 1)\n@@ -1267,11 +1271,13 @@ mod tests {\n         assert_eq!(i.intern(\"cat\"), Symbol::new(1));\n         // dog is still at zero\n         assert_eq!(i.intern(\"dog\"), Symbol::new(0));\n-        assert_eq!(i.gensym(\"zebra\"), Symbol::new(SymbolIndex::MAX_AS_U32));\n+        let z = i.intern(\"zebra\");\n+        assert_eq!(i.gensymed(z), Symbol::new(SymbolIndex::MAX_AS_U32));\n         // gensym of same string gets new number:\n-        assert_eq!(i.gensym(\"zebra\"), Symbol::new(SymbolIndex::MAX_AS_U32 - 1));\n+        assert_eq!(i.gensymed(z), Symbol::new(SymbolIndex::MAX_AS_U32 - 1));\n         // gensym of *existing* string gets new number:\n-        assert_eq!(i.gensym(\"dog\"), Symbol::new(SymbolIndex::MAX_AS_U32 - 2));\n+        let d = i.intern(\"dog\");\n+        assert_eq!(i.gensymed(d), Symbol::new(SymbolIndex::MAX_AS_U32 - 2));\n     }\n \n     #[test]"}]}