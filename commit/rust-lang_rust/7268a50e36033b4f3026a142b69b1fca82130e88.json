{"sha": "7268a50e36033b4f3026a142b69b1fca82130e88", "node_id": "MDY6Q29tbWl0NzI0NzEyOjcyNjhhNTBlMzYwMzNiNGYzMDI2YTE0MmI2OWIxZmNhODIxMzBlODg=", "commit": {"author": {"name": "Seiichi Uchida", "email": "seuchida@gmail.com", "date": "2017-08-06T13:56:51Z"}, "committer": {"name": "topecongiro", "email": "seuchida@gmail.com", "date": "2017-08-09T07:36:41Z"}, "message": "Handle prefix and suffix try operators differently", "tree": {"sha": "1699af70799c1882a621bb108b0d149137bacc02", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1699af70799c1882a621bb108b0d149137bacc02"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7268a50e36033b4f3026a142b69b1fca82130e88", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7268a50e36033b4f3026a142b69b1fca82130e88", "html_url": "https://github.com/rust-lang/rust/commit/7268a50e36033b4f3026a142b69b1fca82130e88", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7268a50e36033b4f3026a142b69b1fca82130e88/comments", "author": {"login": "topecongiro", "id": 21980157, "node_id": "MDQ6VXNlcjIxOTgwMTU3", "avatar_url": "https://avatars.githubusercontent.com/u/21980157?v=4", "gravatar_id": "", "url": "https://api.github.com/users/topecongiro", "html_url": "https://github.com/topecongiro", "followers_url": "https://api.github.com/users/topecongiro/followers", "following_url": "https://api.github.com/users/topecongiro/following{/other_user}", "gists_url": "https://api.github.com/users/topecongiro/gists{/gist_id}", "starred_url": "https://api.github.com/users/topecongiro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/topecongiro/subscriptions", "organizations_url": "https://api.github.com/users/topecongiro/orgs", "repos_url": "https://api.github.com/users/topecongiro/repos", "events_url": "https://api.github.com/users/topecongiro/events{/privacy}", "received_events_url": "https://api.github.com/users/topecongiro/received_events", "type": "User", "site_admin": false}, "committer": {"login": "topecongiro", "id": 21980157, "node_id": "MDQ6VXNlcjIxOTgwMTU3", "avatar_url": "https://avatars.githubusercontent.com/u/21980157?v=4", "gravatar_id": "", "url": "https://api.github.com/users/topecongiro", "html_url": "https://github.com/topecongiro", "followers_url": "https://api.github.com/users/topecongiro/followers", "following_url": "https://api.github.com/users/topecongiro/following{/other_user}", "gists_url": "https://api.github.com/users/topecongiro/gists{/gist_id}", "starred_url": "https://api.github.com/users/topecongiro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/topecongiro/subscriptions", "organizations_url": "https://api.github.com/users/topecongiro/orgs", "repos_url": "https://api.github.com/users/topecongiro/repos", "events_url": "https://api.github.com/users/topecongiro/events{/privacy}", "received_events_url": "https://api.github.com/users/topecongiro/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2c293bd01bcf832ba5e190789322935329d6ccd4", "url": "https://api.github.com/repos/rust-lang/rust/commits/2c293bd01bcf832ba5e190789322935329d6ccd4", "html_url": "https://github.com/rust-lang/rust/commit/2c293bd01bcf832ba5e190789322935329d6ccd4"}], "stats": {"total": 112, "additions": 50, "deletions": 62}, "files": [{"sha": "2e2ce293fdb31dc04d148897fe786645654af459", "filename": "src/chains.rs", "status": "modified", "additions": 49, "deletions": 59, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/7268a50e36033b4f3026a142b69b1fca82130e88/src%2Fchains.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7268a50e36033b4f3026a142b69b1fca82130e88/src%2Fchains.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fchains.rs?ref=7268a50e36033b4f3026a142b69b1fca82130e88", "patch": "@@ -98,13 +98,8 @@ pub fn rewrite_chain(expr: &ast::Expr, context: &RewriteContext, shape: Shape) -\n     if chain_only_try(&subexpr_list) {\n         return rewrite_try(&parent, subexpr_list.len(), context, shape);\n     }\n-    let trailing_try_num = subexpr_list\n-        .iter()\n-        .take_while(|e| match e.node {\n-            ast::ExprKind::Try(..) => true,\n-            _ => false,\n-        })\n-        .count();\n+    let suffix_try_num = subexpr_list.iter().take_while(|e| is_try(e)).count();\n+    let prefix_try_num = subexpr_list.iter().rev().take_while(|e| is_try(e)).count();\n \n     // Parent is the first item in the chain, e.g., `foo` in `foo.bar.baz()`.\n     let parent_shape = if is_block_expr(context, &parent, \"\\n\") {\n@@ -115,23 +110,19 @@ pub fn rewrite_chain(expr: &ast::Expr, context: &RewriteContext, shape: Shape) -\n     } else {\n         shape\n     };\n-    let parent_rewrite = try_opt!(parent.rewrite(context, parent_shape));\n+    let parent_rewrite = try_opt!(\n+        parent\n+            .rewrite(context, parent_shape)\n+            .map(|parent_rw| parent_rw + &repeat_try(prefix_try_num))\n+    );\n     let parent_rewrite_contains_newline = parent_rewrite.contains('\\n');\n     let is_small_parent = parent_rewrite.len() <= context.config.tab_spaces();\n \n     // Decide how to layout the rest of the chain. `extend` is true if we can\n     // put the first non-parent item on the same line as the parent.\n-    let first_subexpr_is_try = subexpr_list.last().map_or(false, is_try);\n     let (nested_shape, extend) = if !parent_rewrite_contains_newline && is_continuable(&parent) {\n-        let nested_shape = if first_subexpr_is_try {\n-            parent_shape\n-                .block_indent(context.config.tab_spaces())\n-                .with_max_width(context.config)\n-        } else {\n-            chain_indent(context, shape.add_offset(parent_rewrite.len()))\n-        };\n         (\n-            nested_shape,\n+            chain_indent(context, shape.add_offset(parent_rewrite.len())),\n             context.config.chain_indent() == IndentStyle::Visual || is_small_parent,\n         )\n     } else if is_block_expr(context, &parent, &parent_rewrite) {\n@@ -171,9 +162,11 @@ pub fn rewrite_chain(expr: &ast::Expr, context: &RewriteContext, shape: Shape) -\n         other_child_shape\n     );\n \n-    let child_shape_iter = Some(first_child_shape).into_iter().chain(\n-        ::std::iter::repeat(other_child_shape).take(subexpr_list.len() - 1),\n-    );\n+    let child_shape_iter = Some(first_child_shape)\n+        .into_iter()\n+        .chain(iter::repeat(other_child_shape));\n+    let subexpr_num = subexpr_list.len();\n+    let subexpr_list = &subexpr_list[suffix_try_num..subexpr_num - prefix_try_num];\n     let iter = subexpr_list.iter().rev().zip(child_shape_iter);\n     let mut rewrites = try_opt!(\n         iter.map(|(e, shape)| {\n@@ -182,8 +175,8 @@ pub fn rewrite_chain(expr: &ast::Expr, context: &RewriteContext, shape: Shape) -\n     );\n \n     // Total of all items excluding the last.\n-    let last_non_try_index = rewrites.len() - (1 + trailing_try_num);\n-    let almost_total = rewrites[..last_non_try_index]\n+    let rewrites_len = rewrites.len();\n+    let almost_total = rewrites[0..(rewrites_len - 1)]\n         .iter()\n         .fold(0, |a, b| a + first_line_width(b)) + parent_rewrite.len();\n     let one_line_len =\n@@ -198,7 +191,7 @@ pub fn rewrite_chain(expr: &ast::Expr, context: &RewriteContext, shape: Shape) -\n         } else {\n             false\n         }\n-    } else if context.config.take_source_hints() && subexpr_list.len() > 1 {\n+    } else if context.config.take_source_hints() && rewrites.len() > 1 {\n         // Look at the source code. Unless all chain elements start on the same\n         // line, we won't consider putting them on a single line either.\n         let last_span = context.snippet(mk_sp(subexpr_list[1].span.hi, total_span.hi));\n@@ -213,7 +206,7 @@ pub fn rewrite_chain(expr: &ast::Expr, context: &RewriteContext, shape: Shape) -\n     let mut fits_single_line = !veto_single_line && almost_total <= shape.width;\n     if fits_single_line {\n         let len = rewrites.len();\n-        let (init, last) = rewrites.split_at_mut(len - (1 + trailing_try_num));\n+        let (init, last) = rewrites.split_at_mut(len - 1);\n         fits_single_line = init.iter().all(|s| !s.contains('\\n'));\n \n         if fits_single_line {\n@@ -242,7 +235,8 @@ pub fn rewrite_chain(expr: &ast::Expr, context: &RewriteContext, shape: Shape) -\n     // Try overflowing the last element if we are using block indent and it goes multi line\n     // or it fits in a single line but goes over the max width.\n     if !fits_single_line && context.use_block_indent() {\n-        let (init, last) = rewrites.split_at_mut(last_non_try_index);\n+        let last_expr_index = rewrites.len() - 1;\n+        let (init, last) = rewrites.split_at_mut(last_expr_index);\n         let almost_single_line = init.iter().all(|s| !s.contains('\\n'));\n         if almost_single_line && last[0].contains('\\n') {\n             let overflow_shape = Shape {\n@@ -251,7 +245,7 @@ pub fn rewrite_chain(expr: &ast::Expr, context: &RewriteContext, shape: Shape) -\n             };\n             fits_single_line = rewrite_last_child_with_overflow(\n                 context,\n-                &subexpr_list[trailing_try_num],\n+                &subexpr_list[0],\n                 overflow_shape,\n                 total_span,\n                 almost_total,\n@@ -281,42 +275,36 @@ pub fn rewrite_chain(expr: &ast::Expr, context: &RewriteContext, shape: Shape) -\n         extend,\n     );\n \n-    if is_small_parent && rewrites.len() > 1 {\n+    let result = if is_small_parent && rewrites.len() > 1 {\n         let second_connector = choose_first_connector(\n             context,\n             &rewrites[0],\n             &rewrites[1],\n             &connector,\n-            &subexpr_list[0..subexpr_list.len() - 1],\n+            &subexpr_list[..subexpr_num - 1],\n             false,\n         );\n-        wrap_str(\n-            format!(\n-                \"{}{}{}{}{}\",\n-                parent_rewrite,\n-                first_connector,\n-                rewrites[0],\n-                second_connector,\n-                join_rewrites(\n-                    &rewrites[1..],\n-                    &subexpr_list[0..subexpr_list.len() - 1],\n-                    &connector,\n-                )\n-            ),\n-            context.config.max_width(),\n-            shape,\n+        format!(\n+            \"{}{}{}{}{}\",\n+            parent_rewrite,\n+            first_connector,\n+            rewrites[0],\n+            second_connector,\n+            join_rewrites(&rewrites[1..], &subexpr_list[..subexpr_num - 1], &connector)\n         )\n     } else {\n-        wrap_str(\n-            format!(\n-                \"{}{}{}\",\n-                parent_rewrite,\n-                first_connector,\n-                join_rewrites(&rewrites, &subexpr_list, &connector)\n-            ),\n-            context.config.max_width(),\n-            shape,\n+        format!(\n+            \"{}{}{}\",\n+            parent_rewrite,\n+            first_connector,\n+            join_rewrites(&rewrites, &subexpr_list, &connector)\n         )\n+    };\n+    let result = format!(\"{}{}\", result, repeat_try(suffix_try_num));\n+    if context.config.chain_indent() == IndentStyle::Block {\n+        Some(result)\n+    } else {\n+        wrap_str(result, context.config.max_width(), shape)\n     }\n }\n \n@@ -355,18 +343,18 @@ fn rewrite_last_child_with_overflow(\n     false\n }\n \n-pub fn rewrite_try(\n+fn repeat_try(try_count: usize) -> String {\n+    iter::repeat(\"?\").take(try_count).collect::<String>()\n+}\n+\n+fn rewrite_try(\n     expr: &ast::Expr,\n     try_count: usize,\n     context: &RewriteContext,\n     shape: Shape,\n ) -> Option<String> {\n     let sub_expr = try_opt!(expr.rewrite(context, try_opt!(shape.sub_width(try_count))));\n-    Some(format!(\n-        \"{}{}\",\n-        sub_expr,\n-        iter::repeat(\"?\").take(try_count).collect::<String>()\n-    ))\n+    Some(format!(\"{}{}\", sub_expr, repeat_try(try_count)))\n }\n \n fn join_rewrites(rewrites: &[String], subexps: &[ast::Expr], connector: &str) -> String {\n@@ -426,7 +414,9 @@ fn make_subexpr_list(expr: &ast::Expr, context: &RewriteContext) -> (ast::Expr,\n fn chain_indent(context: &RewriteContext, shape: Shape) -> Shape {\n     match context.config.chain_indent() {\n         IndentStyle::Visual => shape.visual_indent(0),\n-        IndentStyle::Block => shape.block_indent(context.config.tab_spaces()),\n+        IndentStyle::Block => shape\n+            .block_indent(context.config.tab_spaces())\n+            .with_max_width(context.config),\n     }\n }\n "}, {"sha": "7d29e1e2321e0fac7cf924d964506422bc5d48d3", "filename": "tests/target/match.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7268a50e36033b4f3026a142b69b1fca82130e88/tests%2Ftarget%2Fmatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7268a50e36033b4f3026a142b69b1fca82130e88/tests%2Ftarget%2Fmatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fmatch.rs?ref=7268a50e36033b4f3026a142b69b1fca82130e88", "patch": "@@ -389,9 +389,7 @@ fn issue1395() {\n \n fn issue1456() {\n     Ok(Recording {\n-        artists: match reader\n-            .evaluate(\".//mb:recording/mb:artist-credit/mb:name-credit\")?\n-        {\n+        artists: match reader.evaluate(\".//mb:recording/mb:artist-credit/mb:name-credit\")? {\n             Nodeset(nodeset) => {\n                 let res: Result<Vec<ArtistRef>, ReadError> = nodeset\n                     .iter()"}]}