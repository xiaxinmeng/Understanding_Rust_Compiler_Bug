{"sha": "19f1ff5c7063dac772c1d324d11661393a3b5f7e", "node_id": "C_kwDOAAsO6NoAKDE5ZjFmZjVjNzA2M2RhYzc3MmMxZDMyNGQxMTY2MTM5M2EzYjVmN2U", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2022-01-03T15:00:45Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2022-01-03T15:00:45Z"}, "message": "give `resolve_derive_ident` a more robust api", "tree": {"sha": "71164b3d782fb9a22adca7bdbf1eefec4fb6255d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/71164b3d782fb9a22adca7bdbf1eefec4fb6255d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/19f1ff5c7063dac772c1d324d11661393a3b5f7e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/19f1ff5c7063dac772c1d324d11661393a3b5f7e", "html_url": "https://github.com/rust-lang/rust/commit/19f1ff5c7063dac772c1d324d11661393a3b5f7e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/19f1ff5c7063dac772c1d324d11661393a3b5f7e/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "44b0fe8ec7360fcf78bf0a0b77d3394d48cc83f1", "url": "https://api.github.com/repos/rust-lang/rust/commits/44b0fe8ec7360fcf78bf0a0b77d3394d48cc83f1", "html_url": "https://github.com/rust-lang/rust/commit/44b0fe8ec7360fcf78bf0a0b77d3394d48cc83f1"}], "stats": {"total": 61, "additions": 39, "deletions": 22}, "files": [{"sha": "b685d260815d4033ad31756e6b5bcf089b98246a", "filename": "crates/hir/src/semantics.rs", "status": "modified", "additions": 22, "deletions": 15, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/19f1ff5c7063dac772c1d324d11661393a3b5f7e/crates%2Fhir%2Fsrc%2Fsemantics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19f1ff5c7063dac772c1d324d11661393a3b5f7e/crates%2Fhir%2Fsrc%2Fsemantics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fsemantics.rs?ref=19f1ff5c7063dac772c1d324d11661393a3b5f7e", "patch": "@@ -356,8 +356,12 @@ impl<'db, DB: HirDatabase> Semantics<'db, DB> {\n         self.imp.resolve_bind_pat_to_const(pat)\n     }\n \n-    pub fn resolve_derive_ident(&self, ident: &ast::Ident) -> Option<PathResolution> {\n-        self.imp.resolve_derive_ident(ident)\n+    pub fn resolve_derive_ident(\n+        &self,\n+        derive: &ast::Attr,\n+        ident: &ast::Ident,\n+    ) -> Option<PathResolution> {\n+        self.imp.resolve_derive_ident(derive, ident)\n     }\n \n     // FIXME: use this instead?\n@@ -900,23 +904,26 @@ impl<'db> SemanticsImpl<'db> {\n         self.analyze(pat.syntax()).resolve_bind_pat_to_const(self.db, pat)\n     }\n \n-    fn resolve_derive_ident(&self, ident: &ast::Ident) -> Option<PathResolution> {\n+    fn resolve_derive_ident(\n+        &self,\n+        derive: &ast::Attr,\n+        ident: &ast::Ident,\n+    ) -> Option<PathResolution> {\n+        debug_assert!(ident.syntax().parent().and_then(ast::TokenTree::cast).is_some());\n+        debug_assert!(ident.syntax().ancestors().any(|anc| anc == *derive.syntax()));\n         // derive macros are always at depth 2, tokentree -> meta -> attribute\n         let syntax = ident.syntax();\n-        let attr = syntax.ancestors().nth(2).and_then(ast::Attr::cast)?;\n \n-        let tt = attr.token_tree()?;\n-        if !tt.syntax().text_range().contains_range(ident.syntax().text_range()) {\n-            return None;\n-        }\n-\n-        let file = self.find_file(attr.syntax());\n-        let adt = attr.syntax().parent().and_then(ast::Adt::cast)?;\n+        let tt = derive.token_tree()?;\n+        let file = self.find_file(derive.syntax());\n+        let adt = derive.syntax().parent().and_then(ast::Adt::cast)?;\n \n         let res = self.with_ctx(|ctx| {\n-            let attr_def = ctx.attr_to_def(file.with_value(attr.clone()))?;\n-            let derives = ctx\n-                .attr_to_derive_macro_call(file.with_value(&adt), file.with_value(attr.clone()))?;\n+            let attr_def = ctx.attr_to_def(file.with_value(derive.clone()))?;\n+            let derives = ctx.attr_to_derive_macro_call(\n+                file.with_value(&adt),\n+                file.with_value(derive.clone()),\n+            )?;\n \n             let mut derive_paths = attr_def.parse_path_comma_token_tree()?;\n \n@@ -951,7 +958,7 @@ impl<'db> SemanticsImpl<'db> {\n         match res {\n             Either::Left(path) => resolve_hir_path(\n                 self.db,\n-                &self.scope(attr.syntax()).resolver,\n+                &self.scope(derive.syntax()).resolver,\n                 &Path::from_known_path(path, []),\n             )\n             .filter(|res| matches!(res, PathResolution::Def(ModuleDef::Module(_)))),"}, {"sha": "688f181d9160ae07ff3215bf36d931722e5bceb0", "filename": "crates/ide/src/syntax_highlighting/highlight.rs", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/19f1ff5c7063dac772c1d324d11661393a3b5f7e/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Fhighlight.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19f1ff5c7063dac772c1d324d11661393a3b5f7e/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Fhighlight.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Fhighlight.rs?ref=19f1ff5c7063dac772c1d324d11661393a3b5f7e", "patch": "@@ -39,11 +39,17 @@ pub(super) fn token(\n         INT_NUMBER | FLOAT_NUMBER => HlTag::NumericLiteral.into(),\n         BYTE => HlTag::ByteLiteral.into(),\n         CHAR => HlTag::CharLiteral.into(),\n-        IDENT if parent_matches::<ast::TokenTree>(&token) => {\n-            match sema.resolve_derive_ident(&ast::Ident::cast(token).unwrap()) {\n-                Some(res) => highlight_def(sema, krate, Definition::from(res)),\n-                None => HlTag::None.into(),\n-            }\n+        IDENT => {\n+            let tt = ast::TokenTree::cast(token.parent()?)?;\n+            let ident = ast::Ident::cast(token)?;\n+            // from this point on we are inside a token tree, this only happens for identifiers\n+            // that were not mapped down into macro invocations\n+            (|| {\n+                let attr = tt.parent_meta()?.parent_attr()?;\n+                let res = sema.resolve_derive_ident(&attr, &ident)?;\n+                Some(highlight_def(sema, krate, Definition::from(res)))\n+            })()\n+            .unwrap_or_else(|| HlTag::None.into())\n         }\n         p if p.is_punct() => punctuation(sema, token, p),\n         k if k.is_keyword() => keyword(sema, token, k)?,"}, {"sha": "1501c4eda53aa9a4bb495d3473388b87193dc934", "filename": "crates/ide_db/src/defs.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/19f1ff5c7063dac772c1d324d11661393a3b5f7e/crates%2Fide_db%2Fsrc%2Fdefs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19f1ff5c7063dac772c1d324d11661393a3b5f7e/crates%2Fide_db%2Fsrc%2Fdefs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fdefs.rs?ref=19f1ff5c7063dac772c1d324d11661393a3b5f7e", "patch": "@@ -55,8 +55,12 @@ impl Definition {\n             let attr = ast::TokenTree::cast(parent.clone())\n                 .and_then(|tt| tt.parent_meta())\n                 .and_then(|meta| meta.parent_attr());\n-            if let Some(_) = attr {\n-                return sema.resolve_derive_ident(&ident).map(Into::into).into_iter().collect();\n+            if let Some(attr) = attr {\n+                return sema\n+                    .resolve_derive_ident(&attr, &ident)\n+                    .map(Into::into)\n+                    .into_iter()\n+                    .collect();\n             }\n         }\n         Self::from_node(sema, &parent)"}]}