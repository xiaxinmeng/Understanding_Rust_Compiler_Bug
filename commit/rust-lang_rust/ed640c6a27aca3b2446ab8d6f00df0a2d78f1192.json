{"sha": "ed640c6a27aca3b2446ab8d6f00df0a2d78f1192", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVkNjQwYzZhMjdhY2EzYjI0NDZhYjhkNmYwMGRmMGEyZDc4ZjExOTI=", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2019-11-09T16:44:11Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2019-11-10T11:21:05Z"}, "message": "Merge hir::Mutability into ast::Mutability.", "tree": {"sha": "16c570be6f3cdb3cb4d20dde9588d59d00ed502b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/16c570be6f3cdb3cb4d20dde9588d59d00ed502b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ed640c6a27aca3b2446ab8d6f00df0a2d78f1192", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ed640c6a27aca3b2446ab8d6f00df0a2d78f1192", "html_url": "https://github.com/rust-lang/rust/commit/ed640c6a27aca3b2446ab8d6f00df0a2d78f1192", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ed640c6a27aca3b2446ab8d6f00df0a2d78f1192/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "57a5f92bef4b459005920f1aeff05a52c7e356b0", "url": "https://api.github.com/repos/rust-lang/rust/commits/57a5f92bef4b459005920f1aeff05a52c7e356b0", "html_url": "https://github.com/rust-lang/rust/commit/57a5f92bef4b459005920f1aeff05a52c7e356b0"}], "stats": {"total": 451, "additions": 218, "deletions": 233}, "files": [{"sha": "a22db239d282913ba14950322d027f8b2c273618", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ed640c6a27aca3b2446ab8d6f00df0a2d78f1192/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed640c6a27aca3b2446ab8d6f00df0a2d78f1192/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=ed640c6a27aca3b2446ab8d6f00df0a2d78f1192", "patch": "@@ -2077,13 +2077,6 @@ impl<'a> LoweringContext<'a> {\n         }, ids)\n     }\n \n-    fn lower_mutability(&mut self, m: Mutability) -> hir::Mutability {\n-        match m {\n-            Mutability::Mutable => hir::MutMutable,\n-            Mutability::Immutable => hir::MutImmutable,\n-        }\n-    }\n-\n     fn lower_fn_params_to_names(&mut self, decl: &FnDecl) -> hir::HirVec<Ident> {\n         // Skip the `...` (`CVarArgs`) trailing arguments from the AST,\n         // as they are not explicit in HIR/Ty function signatures.\n@@ -2653,7 +2646,7 @@ impl<'a> LoweringContext<'a> {\n     fn lower_mt(&mut self, mt: &MutTy, itctx: ImplTraitContext<'_>) -> hir::MutTy {\n         hir::MutTy {\n             ty: self.lower_ty(&mt.ty, itctx),\n-            mutbl: self.lower_mutability(mt.mutbl),\n+            mutbl: mt.mutbl,\n         }\n     }\n \n@@ -2754,7 +2747,7 @@ impl<'a> LoweringContext<'a> {\n             }\n             PatKind::Box(ref inner) => hir::PatKind::Box(self.lower_pat(inner)),\n             PatKind::Ref(ref inner, mutbl) => {\n-                hir::PatKind::Ref(self.lower_pat(inner), self.lower_mutability(mutbl))\n+                hir::PatKind::Ref(self.lower_pat(inner), mutbl)\n             }\n             PatKind::Range(ref e1, ref e2, Spanned { node: ref end, .. }) => hir::PatKind::Range(\n                 P(self.lower_expr(e1)),"}, {"sha": "74a2be8cf56cf00061da3a3b6534a1c3198502fc", "filename": "src/librustc/hir/lowering/expr.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ed640c6a27aca3b2446ab8d6f00df0a2d78f1192/src%2Flibrustc%2Fhir%2Flowering%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed640c6a27aca3b2446ab8d6f00df0a2d78f1192/src%2Flibrustc%2Fhir%2Flowering%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering%2Fexpr.rs?ref=ed640c6a27aca3b2446ab8d6f00df0a2d78f1192", "patch": "@@ -64,7 +64,6 @@ impl LoweringContext<'_> {\n                 hir::ExprKind::Type(expr, self.lower_ty(ty, ImplTraitContext::disallowed()))\n             }\n             ExprKind::AddrOf(m, ref ohs) => {\n-                let m = self.lower_mutability(m);\n                 let ohs = P(self.lower_expr(ohs));\n                 hir::ExprKind::AddrOf(m, ohs)\n             }\n@@ -1350,7 +1349,7 @@ impl LoweringContext<'_> {\n     }\n \n     fn expr_mut_addr_of(&mut self, span: Span, e: P<hir::Expr>) -> hir::Expr {\n-        self.expr(span, hir::ExprKind::AddrOf(hir::MutMutable, e), ThinVec::new())\n+        self.expr(span, hir::ExprKind::AddrOf(hir::Mutability::Mutable, e), ThinVec::new())\n     }\n \n     fn expr_unit(&mut self, sp: Span) -> hir::Expr {"}, {"sha": "10c2342919ec27afa3eb2d49e787d88113f8e303", "filename": "src/librustc/hir/lowering/item.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ed640c6a27aca3b2446ab8d6f00df0a2d78f1192/src%2Flibrustc%2Fhir%2Flowering%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed640c6a27aca3b2446ab8d6f00df0a2d78f1192/src%2Flibrustc%2Fhir%2Flowering%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering%2Fitem.rs?ref=ed640c6a27aca3b2446ab8d6f00df0a2d78f1192", "patch": "@@ -289,7 +289,7 @@ impl LoweringContext<'_> {\n                             ImplTraitContext::Disallowed(ImplTraitPosition::Binding)\n                         }\n                     ),\n-                    self.lower_mutability(m),\n+                    m,\n                     self.lower_const_body(e),\n                 )\n             }\n@@ -719,7 +719,7 @@ impl LoweringContext<'_> {\n                 }\n                 ForeignItemKind::Static(ref t, m) => {\n                     hir::ForeignItemKind::Static(\n-                        self.lower_ty(t, ImplTraitContext::disallowed()), self.lower_mutability(m))\n+                        self.lower_ty(t, ImplTraitContext::disallowed()), m)\n                 }\n                 ForeignItemKind::Ty => hir::ForeignItemKind::Type,\n                 ForeignItemKind::Macro(_) => panic!(\"macro shouldn't exist here\"),"}, {"sha": "43f1844b9538fea0b6755cfd8e0e0a46eed67691", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 1, "deletions": 32, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/ed640c6a27aca3b2446ab8d6f00df0a2d78f1192/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed640c6a27aca3b2446ab8d6f00df0a2d78f1192/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=ed640c6a27aca3b2446ab8d6f00df0a2d78f1192", "patch": "@@ -5,7 +5,6 @@\n pub use self::BlockCheckMode::*;\n pub use self::CaptureClause::*;\n pub use self::FunctionRetTy::*;\n-pub use self::Mutability::*;\n pub use self::PrimTy::*;\n pub use self::UnOp::*;\n pub use self::UnsafeSource::*;\n@@ -23,6 +22,7 @@ use syntax_pos::{Span, DUMMY_SP, MultiSpan};\n use syntax::source_map::Spanned;\n use syntax::ast::{self, CrateSugar, Ident, Name, NodeId, AsmDialect};\n use syntax::ast::{Attribute, Label, LitKind, StrStyle, FloatTy, IntTy, UintTy};\n+pub use syntax::ast::Mutability;\n use syntax::attr::{InlineAttr, OptimizeAttr};\n use syntax::symbol::{Symbol, kw};\n use syntax::tokenstream::TokenStream;\n@@ -1053,37 +1053,6 @@ pub enum PatKind {\n     Slice(HirVec<P<Pat>>, Option<P<Pat>>, HirVec<P<Pat>>),\n }\n \n-#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, HashStable,\n-         RustcEncodable, RustcDecodable, Hash, Debug)]\n-pub enum Mutability {\n-    MutMutable,\n-    MutImmutable,\n-}\n-\n-impl Mutability {\n-    /// Returns `MutMutable` only if both `self` and `other` are mutable.\n-    pub fn and(self, other: Self) -> Self {\n-        match self {\n-            MutMutable => other,\n-            MutImmutable => MutImmutable,\n-        }\n-    }\n-\n-    pub fn invert(self) -> Self {\n-        match self {\n-            MutMutable => MutImmutable,\n-            MutImmutable => MutMutable,\n-        }\n-    }\n-\n-    pub fn prefix_str(&self) -> &'static str {\n-        match self {\n-            MutMutable => \"mut \",\n-            MutImmutable => \"\",\n-        }\n-    }\n-}\n-\n #[derive(Copy, Clone, PartialEq, RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub enum BinOpKind {\n     /// The `+` operator (addition)."}, {"sha": "c2bd998d5e9981a75ceeced61c1e5c69e9f9b6cb", "filename": "src/librustc/hir/pat_util.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ed640c6a27aca3b2446ab8d6f00df0a2d78f1192/src%2Flibrustc%2Fhir%2Fpat_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed640c6a27aca3b2446ab8d6f00df0a2d78f1192/src%2Flibrustc%2Fhir%2Fpat_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fpat_util.rs?ref=ed640c6a27aca3b2446ab8d6f00df0a2d78f1192", "patch": "@@ -169,10 +169,10 @@ impl hir::Pat {\n         self.each_binding(|annotation, _, _, _| {\n             match annotation {\n                 hir::BindingAnnotation::Ref => match result {\n-                    None | Some(hir::MutImmutable) => result = Some(hir::MutImmutable),\n+                    None | Some(hir::Mutability::Immutable) => result = Some(hir::Mutability::Immutable),\n                     _ => {}\n                 }\n-                hir::BindingAnnotation::RefMut => result = Some(hir::MutMutable),\n+                hir::BindingAnnotation::RefMut => result = Some(hir::Mutability::Mutable),\n                 _ => {}\n             }\n         });"}, {"sha": "d460e23ec6794433040306346b625421063fb15e", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ed640c6a27aca3b2446ab8d6f00df0a2d78f1192/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed640c6a27aca3b2446ab8d6f00df0a2d78f1192/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=ed640c6a27aca3b2446ab8d6f00df0a2d78f1192", "patch": "@@ -295,8 +295,8 @@ impl<'a> State<'a> {\n             hir::TyKind::Ptr(ref mt) => {\n                 self.s.word(\"*\");\n                 match mt.mutbl {\n-                    hir::MutMutable => self.word_nbsp(\"mut\"),\n-                    hir::MutImmutable => self.word_nbsp(\"const\"),\n+                    hir::Mutability::Mutable => self.word_nbsp(\"mut\"),\n+                    hir::Mutability::Immutable => self.word_nbsp(\"const\"),\n                 }\n                 self.print_type(&mt.ty);\n             }\n@@ -390,7 +390,7 @@ impl<'a> State<'a> {\n             }\n             hir::ForeignItemKind::Static(ref t, m) => {\n                 self.head(visibility_qualified(&item.vis, \"static\"));\n-                if m == hir::MutMutable {\n+                if m == hir::Mutability::Mutable {\n                     self.word_space(\"mut\");\n                 }\n                 self.print_ident(item.ident);\n@@ -506,7 +506,7 @@ impl<'a> State<'a> {\n             }\n             hir::ItemKind::Static(ref ty, m, expr) => {\n                 self.head(visibility_qualified(&item.vis, \"static\"));\n-                if m == hir::MutMutable {\n+                if m == hir::Mutability::Mutable {\n                     self.word_space(\"mut\");\n                 }\n                 self.print_ident(item.ident);\n@@ -1628,11 +1628,11 @@ impl<'a> State<'a> {\n                 match binding_mode {\n                     hir::BindingAnnotation::Ref => {\n                         self.word_nbsp(\"ref\");\n-                        self.print_mutability(hir::MutImmutable);\n+                        self.print_mutability(hir::Mutability::Immutable);\n                     }\n                     hir::BindingAnnotation::RefMut => {\n                         self.word_nbsp(\"ref\");\n-                        self.print_mutability(hir::MutMutable);\n+                        self.print_mutability(hir::Mutability::Mutable);\n                     }\n                     hir::BindingAnnotation::Unannotated => {}\n                     hir::BindingAnnotation::Mutable => {\n@@ -2061,8 +2061,8 @@ impl<'a> State<'a> {\n \n     pub fn print_mutability(&mut self, mutbl: hir::Mutability) {\n         match mutbl {\n-            hir::MutMutable => self.word_nbsp(\"mut\"),\n-            hir::MutImmutable => {},\n+            hir::Mutability::Mutable => self.word_nbsp(\"mut\"),\n+            hir::Mutability::Immutable => {},\n         }\n     }\n "}, {"sha": "1c5f86f480147cd1b78d2e73637fd5278aeb6072", "filename": "src/librustc/lint/internal.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed640c6a27aca3b2446ab8d6f00df0a2d78f1192/src%2Flibrustc%2Flint%2Finternal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed640c6a27aca3b2446ab8d6f00df0a2d78f1192/src%2Flibrustc%2Flint%2Finternal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Finternal.rs?ref=ed640c6a27aca3b2446ab8d6f00df0a2d78f1192", "patch": "@@ -131,7 +131,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TyTyKind {\n                     }\n                 }\n             }\n-            TyKind::Rptr(_, MutTy { ty: inner_ty, mutbl: Mutability::MutImmutable }) => {\n+            TyKind::Rptr(_, MutTy { ty: inner_ty, mutbl: Mutability::Immutable }) => {\n                 if let Some(impl_did) = cx.tcx.impl_of_method(ty.hir_id.owner_def_id()) {\n                     if cx.tcx.impl_trait_ref(impl_did).is_some() {\n                         return;"}, {"sha": "3510fe4d12359d967f55942e918644cf375201c1", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ed640c6a27aca3b2446ab8d6f00df0a2d78f1192/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed640c6a27aca3b2446ab8d6f00df0a2d78f1192/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=ed640c6a27aca3b2446ab8d6f00df0a2d78f1192", "patch": "@@ -67,7 +67,7 @@ use crate::ty::adjustment;\n use crate::ty::{self, DefIdTree, Ty, TyCtxt};\n use crate::ty::fold::TypeFoldable;\n \n-use crate::hir::{MutImmutable, MutMutable, PatKind};\n+use crate::hir::{Mutability, PatKind};\n use crate::hir::pat_util::EnumerateAndAdjustIterator;\n use crate::hir;\n use syntax::ast::{self, Name};\n@@ -226,8 +226,8 @@ pub type McResult<T> = Result<T, ()>;\n impl MutabilityCategory {\n     pub fn from_mutbl(m: hir::Mutability) -> MutabilityCategory {\n         let ret = match m {\n-            MutImmutable => McImmutable,\n-            MutMutable => McDeclared\n+            Mutability::Immutable => McImmutable,\n+            Mutability::Mutable => McDeclared\n         };\n         debug!(\"MutabilityCategory::{}({:?}) => {:?}\",\n                \"from_mutbl\", m, ret);\n@@ -274,7 +274,7 @@ impl MutabilityCategory {\n                     let bm = *tables.pat_binding_modes()\n                                     .get(p.hir_id)\n                                     .expect(\"missing binding mode\");\n-                    if bm == ty::BindByValue(hir::MutMutable) {\n+                    if bm == ty::BindByValue(Mutability::Mutable) {\n                         McDeclared\n                     } else {\n                         McImmutable\n@@ -663,8 +663,8 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n                     span,\n                     cat,\n                     mutbl: match self.tcx.static_mutability(def_id).unwrap() {\n-                        hir::MutImmutable => McImmutable,\n-                        hir::MutMutable => McDeclared,\n+                        Mutability::Immutable => McImmutable,\n+                        Mutability::Mutable => McDeclared,\n                     },\n                     ty:expr_ty,\n                     note: NoteNone"}, {"sha": "220362868abdf41f7912fee671bac7dae89fbfb0", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ed640c6a27aca3b2446ab8d6f00df0a2d78f1192/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed640c6a27aca3b2446ab8d6f00df0a2d78f1192/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=ed640c6a27aca3b2446ab8d6f00df0a2d78f1192", "patch": "@@ -491,8 +491,8 @@ pub enum Mutability {\n impl From<Mutability> for hir::Mutability {\n     fn from(m: Mutability) -> Self {\n         match m {\n-            Mutability::Mut => hir::MutMutable,\n-            Mutability::Not => hir::MutImmutable,\n+            Mutability::Mut => hir::Mutability::Mutable,\n+            Mutability::Not => hir::Mutability::Immutable,\n         }\n     }\n }"}, {"sha": "c65f2b0478670a29a1bfb81eaa0ecd8ffaf54925", "filename": "src/librustc/mir/tcx.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ed640c6a27aca3b2446ab8d6f00df0a2d78f1192/src%2Flibrustc%2Fmir%2Ftcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed640c6a27aca3b2446ab8d6f00df0a2d78f1192/src%2Flibrustc%2Fmir%2Ftcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Ftcx.rs?ref=ed640c6a27aca3b2446ab8d6f00df0a2d78f1192", "patch": "@@ -276,17 +276,17 @@ impl<'tcx> BinOp {\n impl BorrowKind {\n     pub fn to_mutbl_lossy(self) -> hir::Mutability {\n         match self {\n-            BorrowKind::Mut { .. } => hir::MutMutable,\n-            BorrowKind::Shared => hir::MutImmutable,\n+            BorrowKind::Mut { .. } => hir::Mutability::Mutable,\n+            BorrowKind::Shared => hir::Mutability::Immutable,\n \n             // We have no type corresponding to a unique imm borrow, so\n             // use `&mut`. It gives all the capabilities of an `&uniq`\n             // and hence is a safe \"over approximation\".\n-            BorrowKind::Unique => hir::MutMutable,\n+            BorrowKind::Unique => hir::Mutability::Mutable,\n \n             // We have no type corresponding to a shallow borrow, so use\n             // `&` as an approximation.\n-            BorrowKind::Shallow => hir::MutImmutable,\n+            BorrowKind::Shallow => hir::Mutability::Immutable,\n         }\n     }\n }"}, {"sha": "f77db9621351ef6341399361d944bcd70b85f1fd", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ed640c6a27aca3b2446ab8d6f00df0a2d78f1192/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed640c6a27aca3b2446ab8d6f00df0a2d78f1192/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=ed640c6a27aca3b2446ab8d6f00df0a2d78f1192", "patch": "@@ -1385,8 +1385,8 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n \n             if let ty::Ref(region, t_type, mutability) = trait_ref.skip_binder().self_ty().kind {\n                 let trait_type = match mutability {\n-                    hir::Mutability::MutMutable => self.tcx.mk_imm_ref(region, t_type),\n-                    hir::Mutability::MutImmutable => self.tcx.mk_mut_ref(region, t_type),\n+                    hir::Mutability::Mutable => self.tcx.mk_imm_ref(region, t_type),\n+                    hir::Mutability::Immutable => self.tcx.mk_mut_ref(region, t_type),\n                 };\n \n                 let substs = self.tcx.mk_substs_trait(&trait_type, &[]);\n@@ -1403,7 +1403,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     let sp = self.tcx.sess.source_map()\n                         .span_take_while(span, |c| c.is_whitespace() || *c == '&');\n                     if points_at_arg &&\n-                        mutability == hir::Mutability::MutImmutable &&\n+                        mutability == hir::Mutability::Immutable &&\n                         refs_number > 0\n                     {\n                         err.span_suggestion("}, {"sha": "f5ac1533d060b3e2397cde3e5d579deb8d3bc139", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ed640c6a27aca3b2446ab8d6f00df0a2d78f1192/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed640c6a27aca3b2446ab8d6f00df0a2d78f1192/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=ed640c6a27aca3b2446ab8d6f00df0a2d78f1192", "patch": "@@ -2652,7 +2652,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             | ty::Char\n             | ty::RawPtr(..)\n             | ty::Never\n-            | ty::Ref(_, _, hir::MutImmutable) => {\n+            | ty::Ref(_, _, hir::Mutability::Immutable) => {\n                 // Implementations provided in libcore\n                 None\n             }\n@@ -2663,7 +2663,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             | ty::Generator(..)\n             | ty::GeneratorWitness(..)\n             | ty::Foreign(..)\n-            | ty::Ref(_, _, hir::MutMutable) => None,\n+            | ty::Ref(_, _, hir::Mutability::Mutable) => None,\n \n             ty::Array(element_ty, _) => {\n                 // (*) binder moved here"}, {"sha": "f5ab1eb38c3c6e32a6dc23b0be6b4710c7e22b88", "filename": "src/librustc/ty/adjustment.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ed640c6a27aca3b2446ab8d6f00df0a2d78f1192/src%2Flibrustc%2Fty%2Fadjustment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed640c6a27aca3b2446ab8d6f00df0a2d78f1192/src%2Flibrustc%2Fty%2Fadjustment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fadjustment.rs?ref=ed640c6a27aca3b2446ab8d6f00df0a2d78f1192", "patch": "@@ -109,8 +109,8 @@ pub struct OverloadedDeref<'tcx> {\n impl<'tcx> OverloadedDeref<'tcx> {\n     pub fn method_call(&self, tcx: TyCtxt<'tcx>, source: Ty<'tcx>) -> (DefId, SubstsRef<'tcx>) {\n         let trait_def_id = match self.mutbl {\n-            hir::MutImmutable => tcx.lang_items().deref_trait(),\n-            hir::MutMutable => tcx.lang_items().deref_mut_trait()\n+            hir::Mutability::Immutable => tcx.lang_items().deref_trait(),\n+            hir::Mutability::Mutable => tcx.lang_items().deref_mut_trait()\n         };\n         let method_def_id = tcx.associated_items(trait_def_id.unwrap())\n             .find(|m| m.kind == ty::AssocKind::Method).unwrap().def_id;\n@@ -145,8 +145,8 @@ pub enum AutoBorrowMutability {\n impl From<AutoBorrowMutability> for hir::Mutability {\n     fn from(m: AutoBorrowMutability) -> Self {\n         match m {\n-            AutoBorrowMutability::Mutable { .. } => hir::MutMutable,\n-            AutoBorrowMutability::Immutable => hir::MutImmutable,\n+            AutoBorrowMutability::Mutable { .. } => hir::Mutability::Mutable,\n+            AutoBorrowMutability::Immutable => hir::Mutability::Immutable,\n         }\n     }\n }"}, {"sha": "905d7abb7828c7eb8b4a15bea2f50fe458b6d8d4", "filename": "src/librustc/ty/binding.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ed640c6a27aca3b2446ab8d6f00df0a2d78f1192/src%2Flibrustc%2Fty%2Fbinding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed640c6a27aca3b2446ab8d6f00df0a2d78f1192/src%2Flibrustc%2Fty%2Fbinding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fbinding.rs?ref=ed640c6a27aca3b2446ab8d6f00df0a2d78f1192", "patch": "@@ -13,10 +13,10 @@ CloneTypeFoldableAndLiftImpls! { BindingMode, }\n impl BindingMode {\n     pub fn convert(ba: BindingAnnotation) -> BindingMode {\n         match ba {\n-            Unannotated => BindingMode::BindByValue(Mutability::MutImmutable),\n-            Mutable => BindingMode::BindByValue(Mutability::MutMutable),\n-            Ref => BindingMode::BindByReference(Mutability::MutImmutable),\n-            RefMut => BindingMode::BindByReference(Mutability::MutMutable),\n+            Unannotated => BindingMode::BindByValue(Mutability::Immutable),\n+            Mutable => BindingMode::BindByValue(Mutability::Mutable),\n+            Ref => BindingMode::BindByReference(Mutability::Immutable),\n+            RefMut => BindingMode::BindByReference(Mutability::Mutable),\n         }\n     }\n }"}, {"sha": "55f85809a406d7a3ca6570f90430e5ea5232e345", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ed640c6a27aca3b2446ab8d6f00df0a2d78f1192/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed640c6a27aca3b2446ab8d6f00df0a2d78f1192/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=ed640c6a27aca3b2446ab8d6f00df0a2d78f1192", "patch": "@@ -2410,22 +2410,22 @@ impl<'tcx> TyCtxt<'tcx> {\n \n     #[inline]\n     pub fn mk_mut_ref(self, r: Region<'tcx>, ty: Ty<'tcx>) -> Ty<'tcx> {\n-        self.mk_ref(r, TypeAndMut {ty: ty, mutbl: hir::MutMutable})\n+        self.mk_ref(r, TypeAndMut {ty: ty, mutbl: hir::Mutability::Mutable})\n     }\n \n     #[inline]\n     pub fn mk_imm_ref(self, r: Region<'tcx>, ty: Ty<'tcx>) -> Ty<'tcx> {\n-        self.mk_ref(r, TypeAndMut {ty: ty, mutbl: hir::MutImmutable})\n+        self.mk_ref(r, TypeAndMut {ty: ty, mutbl: hir::Mutability::Immutable})\n     }\n \n     #[inline]\n     pub fn mk_mut_ptr(self, ty: Ty<'tcx>) -> Ty<'tcx> {\n-        self.mk_ptr(TypeAndMut {ty: ty, mutbl: hir::MutMutable})\n+        self.mk_ptr(TypeAndMut {ty: ty, mutbl: hir::Mutability::Mutable})\n     }\n \n     #[inline]\n     pub fn mk_imm_ptr(self, ty: Ty<'tcx>) -> Ty<'tcx> {\n-        self.mk_ptr(TypeAndMut {ty: ty, mutbl: hir::MutImmutable})\n+        self.mk_ptr(TypeAndMut {ty: ty, mutbl: hir::Mutability::Immutable})\n     }\n \n     #[inline]"}, {"sha": "c61d559af53f5867db3b641a4c2b515aa4ed9255", "filename": "src/librustc/ty/error.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed640c6a27aca3b2446ab8d6f00df0a2d78f1192/src%2Flibrustc%2Fty%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed640c6a27aca3b2446ab8d6f00df0a2d78f1192/src%2Flibrustc%2Fty%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ferror.rs?ref=ed640c6a27aca3b2446ab8d6f00df0a2d78f1192", "patch": "@@ -211,7 +211,7 @@ impl<'tcx> ty::TyS<'tcx> {\n                    region.to_string() != \"'_\"     //... or a complex type\n                 {\n                     format!(\"{}reference\", match mutbl {\n-                        hir::Mutability::MutMutable => \"mutable \",\n+                        hir::Mutability::Mutable => \"mutable \",\n                         _ => \"\"\n                     }).into()\n                 } else {"}, {"sha": "e5f22277f8e31bb25cbc5c8664ee30c04afdf95c", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ed640c6a27aca3b2446ab8d6f00df0a2d78f1192/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed640c6a27aca3b2446ab8d6f00df0a2d78f1192/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=ed640c6a27aca3b2446ab8d6f00df0a2d78f1192", "patch": "@@ -2221,12 +2221,12 @@ where\n                 let tcx = cx.tcx();\n                 let is_freeze = ty.is_freeze(tcx, cx.param_env(), DUMMY_SP);\n                 let kind = match mt {\n-                    hir::MutImmutable => if is_freeze {\n+                    hir::Mutability::Immutable => if is_freeze {\n                         PointerKind::Frozen\n                     } else {\n                         PointerKind::Shared\n                     },\n-                    hir::MutMutable => {\n+                    hir::Mutability::Mutable => {\n                         // Previously we would only emit noalias annotations for LLVM >= 6 or in\n                         // panic=abort mode. That was deemed right, as prior versions had many bugs\n                         // in conjunction with unwinding, but later versions didn\u2019t seem to have"}, {"sha": "e4ed1cd198e528700d1d13bdf22cead8e320db29", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ed640c6a27aca3b2446ab8d6f00df0a2d78f1192/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed640c6a27aca3b2446ab8d6f00df0a2d78f1192/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=ed640c6a27aca3b2446ab8d6f00df0a2d78f1192", "patch": "@@ -2693,8 +2693,8 @@ impl<'tcx> TyS<'tcx> {\n impl BorrowKind {\n     pub fn from_mutbl(m: hir::Mutability) -> BorrowKind {\n         match m {\n-            hir::MutMutable => MutBorrow,\n-            hir::MutImmutable => ImmBorrow,\n+            hir::Mutability::Mutable => MutBorrow,\n+            hir::Mutability::Immutable => ImmBorrow,\n         }\n     }\n \n@@ -2704,13 +2704,13 @@ impl BorrowKind {\n     /// question.\n     pub fn to_mutbl_lossy(self) -> hir::Mutability {\n         match self {\n-            MutBorrow => hir::MutMutable,\n-            ImmBorrow => hir::MutImmutable,\n+            MutBorrow => hir::Mutability::Mutable,\n+            ImmBorrow => hir::Mutability::Immutable,\n \n             // We have no type corresponding to a unique imm borrow, so\n             // use `&mut`. It gives all the capabilities of an `&uniq`\n             // and hence is a safe \"over approximation\".\n-            UniqueImmBorrow => hir::MutMutable,\n+            UniqueImmBorrow => hir::Mutability::Mutable,\n         }\n     }\n "}, {"sha": "0389218b61d24d165eb3792ab87fe0b962ba6de5", "filename": "src/librustc/ty/print/obsolete.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ed640c6a27aca3b2446ab8d6f00df0a2d78f1192/src%2Flibrustc%2Fty%2Fprint%2Fobsolete.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed640c6a27aca3b2446ab8d6f00df0a2d78f1192/src%2Flibrustc%2Fty%2Fprint%2Fobsolete.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fprint%2Fobsolete.rs?ref=ed640c6a27aca3b2446ab8d6f00df0a2d78f1192", "patch": "@@ -60,8 +60,8 @@ impl DefPathBasedNames<'tcx> {\n             ty::RawPtr(ty::TypeAndMut { ty: inner_type, mutbl }) => {\n                 output.push('*');\n                 match mutbl {\n-                    hir::MutImmutable => output.push_str(\"const \"),\n-                    hir::MutMutable => output.push_str(\"mut \"),\n+                    hir::Mutability::Immutable => output.push_str(\"const \"),\n+                    hir::Mutability::Mutable => output.push_str(\"mut \"),\n                 }\n \n                 self.push_type_name(inner_type, output, debug);"}, {"sha": "568f18f48be20b3b1a86092f38d96f429ee816b4", "filename": "src/librustc/ty/print/pretty.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ed640c6a27aca3b2446ab8d6f00df0a2d78f1192/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed640c6a27aca3b2446ab8d6f00df0a2d78f1192/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs?ref=ed640c6a27aca3b2446ab8d6f00df0a2d78f1192", "patch": "@@ -471,8 +471,8 @@ pub trait PrettyPrinter<'tcx>:\n             ty::Float(t) => p!(write(\"{}\", t.name_str())),\n             ty::RawPtr(ref tm) => {\n                 p!(write(\"*{} \", match tm.mutbl {\n-                    hir::MutMutable => \"mut\",\n-                    hir::MutImmutable => \"const\",\n+                    hir::Mutability::Mutable => \"mut\",\n+                    hir::Mutability::Immutable => \"const\",\n                 }));\n                 p!(print(tm.ty))\n             }"}, {"sha": "9b5cdc489a8b5330fb5031f31afb6c5b7095238b", "filename": "src/librustc/ty/relate.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ed640c6a27aca3b2446ab8d6f00df0a2d78f1192/src%2Flibrustc%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed640c6a27aca3b2446ab8d6f00df0a2d78f1192/src%2Flibrustc%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Frelate.rs?ref=ed640c6a27aca3b2446ab8d6f00df0a2d78f1192", "patch": "@@ -121,8 +121,8 @@ impl<'tcx> Relate<'tcx> for ty::TypeAndMut<'tcx> {\n         } else {\n             let mutbl = a.mutbl;\n             let variance = match mutbl {\n-                ast::Mutability::MutImmutable => ty::Covariant,\n-                ast::Mutability::MutMutable => ty::Invariant,\n+                ast::Mutability::Immutable => ty::Covariant,\n+                ast::Mutability::Mutable => ty::Invariant,\n             };\n             let ty = relation.relate_with_variance(variance, &a.ty, &b.ty)?;\n             Ok(ty::TypeAndMut { ty, mutbl })"}, {"sha": "422e48f34de4908981db17cad1a95f4e73639263", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ed640c6a27aca3b2446ab8d6f00df0a2d78f1192/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed640c6a27aca3b2446ab8d6f00df0a2d78f1192/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=ed640c6a27aca3b2446ab8d6f00df0a2d78f1192", "patch": "@@ -1839,8 +1839,8 @@ impl<'tcx> TyS<'tcx> {\n     #[inline]\n     pub fn is_mutable_ptr(&self) -> bool {\n         match self.kind {\n-            RawPtr(TypeAndMut { mutbl: hir::Mutability::MutMutable, .. }) |\n-            Ref(_, _, hir::Mutability::MutMutable) => true,\n+            RawPtr(TypeAndMut { mutbl: hir::Mutability::Mutable, .. }) |\n+            Ref(_, _, hir::Mutability::Mutable) => true,\n             _ => false\n         }\n     }\n@@ -2030,7 +2030,7 @@ impl<'tcx> TyS<'tcx> {\n             Adt(def, _) if def.is_box() => {\n                 Some(TypeAndMut {\n                     ty: self.boxed_ty(),\n-                    mutbl: hir::MutImmutable,\n+                    mutbl: hir::Mutability::Immutable,\n                 })\n             },\n             Ref(_, ty, mutbl) => Some(TypeAndMut { ty, mutbl }),"}, {"sha": "d46320abff2ad795c6a2ff048393b98c736f1c80", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ed640c6a27aca3b2446ab8d6f00df0a2d78f1192/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed640c6a27aca3b2446ab8d6f00df0a2d78f1192/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=ed640c6a27aca3b2446ab8d6f00df0a2d78f1192", "patch": "@@ -184,7 +184,7 @@ impl<'tcx> ty::ParamEnv<'tcx> {\n                 // Now libcore provides that impl.\n                 ty::Uint(_) | ty::Int(_) | ty::Bool | ty::Float(_) |\n                 ty::Char | ty::RawPtr(..) | ty::Never |\n-                ty::Ref(_, _, hir::MutImmutable) => return Ok(()),\n+                ty::Ref(_, _, hir::Mutability::Immutable) => return Ok(()),\n \n                 ty::Adt(adt, substs) => (adt, substs),\n \n@@ -680,7 +680,7 @@ impl<'tcx> TyCtxt<'tcx> {\n \n     /// Returns `true` if the node pointed to by `def_id` is a mutable `static` item.\n     pub fn is_mutable_static(&self, def_id: DefId) -> bool {\n-        self.static_mutability(def_id) == Some(hir::MutMutable)\n+        self.static_mutability(def_id) == Some(hir::Mutability::Mutable)\n     }\n \n     /// Expands the given impl trait type, stopping if the type is recursive."}, {"sha": "e1ce7f622e2ef15a02278fecaafe4141c01796e0", "filename": "src/librustc_codegen_llvm/intrinsic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed640c6a27aca3b2446ab8d6f00df0a2d78f1192/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed640c6a27aca3b2446ab8d6f00df0a2d78f1192/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs?ref=ed640c6a27aca3b2446ab8d6f00df0a2d78f1192", "patch": "@@ -1573,7 +1573,7 @@ fn generic_simd_intrinsic(\n         // The second argument must be a simd vector with an element type that's a pointer\n         // to the element type of the first argument\n         let (pointer_count, underlying_ty) = match arg_tys[1].simd_type(tcx).kind {\n-            ty::RawPtr(p) if p.ty == in_elem && p.mutbl == hir::MutMutable\n+            ty::RawPtr(p) if p.ty == in_elem && p.mutbl == hir::Mutability::Mutable\n                 => (ptr_count(arg_tys[1].simd_type(tcx)),\n                     non_ptr(arg_tys[1].simd_type(tcx))),\n             _ => {"}, {"sha": "8ff08e832dc17ded74ec18b341dfc89937f3d17a", "filename": "src/librustc_codegen_ssa/debuginfo/type_names.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ed640c6a27aca3b2446ab8d6f00df0a2d78f1192/src%2Flibrustc_codegen_ssa%2Fdebuginfo%2Ftype_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed640c6a27aca3b2446ab8d6f00df0a2d78f1192/src%2Flibrustc_codegen_ssa%2Fdebuginfo%2Ftype_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fdebuginfo%2Ftype_names.rs?ref=ed640c6a27aca3b2446ab8d6f00df0a2d78f1192", "patch": "@@ -62,8 +62,8 @@ pub fn push_debuginfo_type_name<'tcx>(\n                 output.push('*');\n             }\n             match mutbl {\n-                hir::MutImmutable => output.push_str(\"const \"),\n-                hir::MutMutable => output.push_str(\"mut \"),\n+                hir::Mutability::Immutable => output.push_str(\"const \"),\n+                hir::Mutability::Mutable => output.push_str(\"mut \"),\n             }\n \n             push_debuginfo_type_name(tcx, inner_type, true, output, visited);"}, {"sha": "1dfcc21f3903ddd674ad2c1e9361d55e35d6055a", "filename": "src/librustc_codegen_utils/symbol_names/v0.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ed640c6a27aca3b2446ab8d6f00df0a2d78f1192/src%2Flibrustc_codegen_utils%2Fsymbol_names%2Fv0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed640c6a27aca3b2446ab8d6f00df0a2d78f1192/src%2Flibrustc_codegen_utils%2Fsymbol_names%2Fv0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_utils%2Fsymbol_names%2Fv0.rs?ref=ed640c6a27aca3b2446ab8d6f00df0a2d78f1192", "patch": "@@ -373,8 +373,8 @@ impl Printer<'tcx> for SymbolMangler<'tcx> {\n \n             ty::Ref(r, ty, mutbl) => {\n                 self.push(match mutbl {\n-                    hir::MutImmutable => \"R\",\n-                    hir::MutMutable => \"Q\",\n+                    hir::Mutability::Immutable => \"R\",\n+                    hir::Mutability::Mutable => \"Q\",\n                 });\n                 if *r != ty::ReErased {\n                     self = r.print(self)?;\n@@ -384,8 +384,8 @@ impl Printer<'tcx> for SymbolMangler<'tcx> {\n \n             ty::RawPtr(mt) => {\n                 self.push(match mt.mutbl {\n-                    hir::MutImmutable => \"P\",\n-                    hir::MutMutable => \"O\",\n+                    hir::Mutability::Immutable => \"P\",\n+                    hir::Mutability::Mutable => \"O\",\n                 });\n                 self = mt.ty.print(self)?;\n             }"}, {"sha": "38624034022f0bc81f5959304512efb9afe6d250", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ed640c6a27aca3b2446ab8d6f00df0a2d78f1192/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed640c6a27aca3b2446ab8d6f00df0a2d78f1192/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=ed640c6a27aca3b2446ab8d6f00df0a2d78f1192", "patch": "@@ -926,8 +926,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MutableTransmutes {\n                    consider instead using an UnsafeCell\";\n         match get_transmute_from_to(cx, expr).map(|(ty1, ty2)| (&ty1.kind, &ty2.kind)) {\n             Some((&ty::Ref(_, _, from_mt), &ty::Ref(_, _, to_mt))) => {\n-                if to_mt == hir::Mutability::MutMutable &&\n-                   from_mt == hir::Mutability::MutImmutable {\n+                if to_mt == hir::Mutability::Mutable &&\n+                   from_mt == hir::Mutability::Immutable {\n                     cx.span_lint(MUTABLE_TRANSMUTES, expr.span, msg);\n                 }\n             }"}, {"sha": "7cebf2512d64521286ff4316d63f1fdcee854c57", "filename": "src/librustc_metadata/rmeta/decoder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ed640c6a27aca3b2446ab8d6f00df0a2d78f1192/src%2Flibrustc_metadata%2Frmeta%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed640c6a27aca3b2446ab8d6f00df0a2d78f1192/src%2Flibrustc_metadata%2Frmeta%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frmeta%2Fdecoder.rs?ref=ed640c6a27aca3b2446ab8d6f00df0a2d78f1192", "patch": "@@ -1236,9 +1236,9 @@ impl<'a, 'tcx> CrateMetadata {\n     fn static_mutability(&self, id: DefIndex) -> Option<hir::Mutability> {\n         match self.kind(id) {\n             EntryKind::ImmStatic |\n-            EntryKind::ForeignImmStatic => Some(hir::MutImmutable),\n+            EntryKind::ForeignImmStatic => Some(hir::Mutability::Immutable),\n             EntryKind::MutStatic |\n-            EntryKind::ForeignMutStatic => Some(hir::MutMutable),\n+            EntryKind::ForeignMutStatic => Some(hir::Mutability::Mutable),\n             _ => None,\n         }\n     }"}, {"sha": "908561f55fd8fabc56f220fbbada5ccdca9bd07e", "filename": "src/librustc_metadata/rmeta/encoder.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ed640c6a27aca3b2446ab8d6f00df0a2d78f1192/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed640c6a27aca3b2446ab8d6f00df0a2d78f1192/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs?ref=ed640c6a27aca3b2446ab8d6f00df0a2d78f1192", "patch": "@@ -1086,8 +1086,8 @@ impl EncodeContext<'tcx> {\n         debug!(\"EncodeContext::encode_info_for_item({:?})\", def_id);\n \n         record!(self.per_def.kind[def_id] <- match item.kind {\n-            hir::ItemKind::Static(_, hir::MutMutable, _) => EntryKind::MutStatic,\n-            hir::ItemKind::Static(_, hir::MutImmutable, _) => EntryKind::ImmStatic,\n+            hir::ItemKind::Static(_, hir::Mutability::Mutable, _) => EntryKind::MutStatic,\n+            hir::ItemKind::Static(_, hir::Mutability::Immutable, _) => EntryKind::ImmStatic,\n             hir::ItemKind::Const(_, body_id) => {\n                 let mir = self.tcx.at(item.span).mir_const_qualif(def_id);\n                 EntryKind::Const(\n@@ -1571,8 +1571,8 @@ impl EncodeContext<'tcx> {\n                 };\n                 EntryKind::ForeignFn(self.lazy(data))\n             }\n-            hir::ForeignItemKind::Static(_, hir::MutMutable) => EntryKind::ForeignMutStatic,\n-            hir::ForeignItemKind::Static(_, hir::MutImmutable) => EntryKind::ForeignImmStatic,\n+            hir::ForeignItemKind::Static(_, hir::Mutability::Mutable) => EntryKind::ForeignMutStatic,\n+            hir::ForeignItemKind::Static(_, hir::Mutability::Immutable) => EntryKind::ForeignImmStatic,\n             hir::ForeignItemKind::Type => EntryKind::ForeignType,\n         });\n         record!(self.per_def.visibility[def_id] <-"}, {"sha": "0d3b35a228c5fbe09203cfa4fa6c8ddf2b12aa55", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ed640c6a27aca3b2446ab8d6f00df0a2d78f1192/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed640c6a27aca3b2446ab8d6f00df0a2d78f1192/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=ed640c6a27aca3b2446ab8d6f00df0a2d78f1192", "patch": "@@ -137,7 +137,7 @@ fn do_mir_borrowck<'a, 'tcx>(\n             };\n             let bm = *tables.pat_binding_modes().get(var_hir_id)\n                 .expect(\"missing binding mode\");\n-            if bm == ty::BindByValue(hir::MutMutable) {\n+            if bm == ty::BindByValue(hir::Mutability::Mutable) {\n                 upvar.mutability = Mutability::Mut;\n             }\n             upvar\n@@ -2118,10 +2118,10 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                             ty::Ref(_, _, mutbl) => {\n                                 match mutbl {\n                                     // Shared borrowed data is never mutable\n-                                    hir::MutImmutable => Err(place),\n+                                    hir::Mutability::Immutable => Err(place),\n                                     // Mutably borrowed data is mutable, but only if we have a\n                                     // unique path to the `&mut`\n-                                    hir::MutMutable => {\n+                                    hir::Mutability::Mutable => {\n                                         let mode = match self.is_upvar_field_projection(place) {\n                                             Some(field)\n                                                 if self.upvars[field.index()].by_ref =>\n@@ -2141,10 +2141,10 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                             ty::RawPtr(tnm) => {\n                                 match tnm.mutbl {\n                                     // `*const` raw pointers are not mutable\n-                                    hir::MutImmutable => Err(place),\n+                                    hir::Mutability::Immutable => Err(place),\n                                     // `*mut` raw pointers are always mutable, regardless of\n                                     // context. The users have to check by themselves.\n-                                    hir::MutMutable => {\n+                                    hir::Mutability::Mutable => {\n                                         Ok(RootPlace {\n                                             place_base: place.base,\n                                             place_projection: place.projection,"}, {"sha": "11e89de810e5b1ac51d9bec631c7ef51fc03743e", "filename": "src/librustc_mir/borrow_check/mutability_errors.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ed640c6a27aca3b2446ab8d6f00df0a2d78f1192/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed640c6a27aca3b2446ab8d6f00df0a2d78f1192/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs?ref=ed640c6a27aca3b2446ab8d6f00df0a2d78f1192", "patch": "@@ -271,7 +271,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                         // we have an explicit self. Do the same thing in this case and check\n                         // for a `self: &mut Self` to suggest removing the `&mut`.\n                         if let ty::Ref(\n-                            _, _, hir::Mutability::MutMutable\n+                            _, _, hir::Mutability::Mutable\n                         ) = local_decl.ty.kind {\n                             true\n                         } else {\n@@ -593,7 +593,7 @@ fn suggest_ampmut<'tcx>(\n     }\n \n     let ty_mut = local_decl.ty.builtin_deref(true).unwrap();\n-    assert_eq!(ty_mut.mutbl, hir::MutImmutable);\n+    assert_eq!(ty_mut.mutbl, hir::Mutability::Immutable);\n     (highlight_span,\n      if local_decl.ty.is_region_ptr() {\n          format!(\"&mut {}\", ty_mut.ty)\n@@ -629,7 +629,7 @@ fn annotate_struct_field(\n             // we can expect a field that is an immutable reference to a type.\n             if let hir::Node::Field(field) = node {\n                 if let hir::TyKind::Rptr(lifetime, hir::MutTy {\n-                    mutbl: hir::Mutability::MutImmutable,\n+                    mutbl: hir::Mutability::Immutable,\n                     ref ty\n                 }) = field.ty.kind {\n                     // Get the snippets in two parts - the named lifetime (if there is one) and"}, {"sha": "37fc0b09e5b9fd058b1e951eba3d9145cd6123ee", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ed640c6a27aca3b2446ab8d6f00df0a2d78f1192/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed640c6a27aca3b2446ab8d6f00df0a2d78f1192/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=ed640c6a27aca3b2446ab8d6f00df0a2d78f1192", "patch": "@@ -2138,7 +2138,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                         let ty_from = match op.ty(body, tcx).kind {\n                             ty::RawPtr(ty::TypeAndMut {\n                                 ty: ty_from,\n-                                mutbl: hir::MutMutable,\n+                                mutbl: hir::Mutability::Mutable,\n                             }) => ty_from,\n                             _ => {\n                                 span_mirbug!(\n@@ -2153,7 +2153,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                         let ty_to = match ty.kind {\n                             ty::RawPtr(ty::TypeAndMut {\n                                 ty: ty_to,\n-                                mutbl: hir::MutImmutable,\n+                                mutbl: hir::Mutability::Immutable,\n                             }) => ty_to,\n                             _ => {\n                                 span_mirbug!(\n@@ -2187,7 +2187,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n \n                         let opt_ty_elem = match ty_from.kind {\n                             ty::RawPtr(\n-                                ty::TypeAndMut { mutbl: hir::MutImmutable, ty: array_ty }\n+                                ty::TypeAndMut { mutbl: hir::Mutability::Immutable, ty: array_ty }\n                             ) => {\n                                 match array_ty.kind {\n                                     ty::Array(ty_elem, _) => Some(ty_elem),\n@@ -2212,7 +2212,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n \n                         let ty_to = match ty.kind {\n                             ty::RawPtr(\n-                                ty::TypeAndMut { mutbl: hir::MutImmutable, ty: ty_to }\n+                                ty::TypeAndMut { mutbl: hir::Mutability::Immutable, ty: ty_to }\n                             ) => {\n                                 ty_to\n                             }\n@@ -2250,7 +2250,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                         let cast_ty_to = CastTy::from_ty(ty);\n                         match (cast_ty_from, cast_ty_to) {\n                             (Some(CastTy::RPtr(ref_tm)), Some(CastTy::Ptr(ptr_tm))) => {\n-                                if let hir::MutMutable = ptr_tm.mutbl {\n+                                if let hir::Mutability::Mutable = ptr_tm.mutbl {\n                                     if let Err(terr) = self.eq_types(\n                                         ref_tm.ty,\n                                         ptr_tm.ty,\n@@ -2504,13 +2504,13 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                             });\n \n                             match mutbl {\n-                                hir::Mutability::MutImmutable => {\n+                                hir::Mutability::Immutable => {\n                                     // Immutable reference. We don't need the base\n                                     // to be valid for the entire lifetime of\n                                     // the borrow.\n                                     break;\n                                 }\n-                                hir::Mutability::MutMutable => {\n+                                hir::Mutability::Mutable => {\n                                     // Mutable reference. We *do* need the base\n                                     // to be valid, because after the base becomes\n                                     // invalid, someone else can use our mutable deref."}, {"sha": "f0d2927ba45e70af68034f845718d23260b51607", "filename": "src/librustc_mir/borrow_check/place_ext.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed640c6a27aca3b2446ab8d6f00df0a2d78f1192/src%2Flibrustc_mir%2Fborrow_check%2Fplace_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed640c6a27aca3b2446ab8d6f00df0a2d78f1192/src%2Flibrustc_mir%2Fborrow_check%2Fplace_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fplace_ext.rs?ref=ed640c6a27aca3b2446ab8d6f00df0a2d78f1192", "patch": "@@ -57,7 +57,7 @@ impl<'tcx> PlaceExt<'tcx> for Place<'tcx> {\n \n             if *elem == ProjectionElem::Deref {\n                 let ty = Place::ty_from(&self.base, proj_base, body, tcx).ty;\n-                if let ty::RawPtr(..) | ty::Ref(_, _, hir::MutImmutable) = ty.kind {\n+                if let ty::RawPtr(..) | ty::Ref(_, _, hir::Mutability::Immutable) = ty.kind {\n                     // For both derefs of raw pointers and `&T`\n                     // references, the original path is `Copy` and\n                     // therefore not significant.  In particular,"}, {"sha": "36586e80ee0f0f614b4f66675f96a4e353b7b905", "filename": "src/librustc_mir/borrow_check/places_conflict.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ed640c6a27aca3b2446ab8d6f00df0a2d78f1192/src%2Flibrustc_mir%2Fborrow_check%2Fplaces_conflict.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed640c6a27aca3b2446ab8d6f00df0a2d78f1192/src%2Flibrustc_mir%2Fborrow_check%2Fplaces_conflict.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fplaces_conflict.rs?ref=ed640c6a27aca3b2446ab8d6f00df0a2d78f1192", "patch": "@@ -246,11 +246,11 @@ fn place_components_conflict<'tcx>(\n                     debug!(\"borrow_conflicts_with_place: shallow access behind ptr\");\n                     return false;\n                 }\n-                (ProjectionElem::Deref, ty::Ref(_, _, hir::MutImmutable), _) => {\n+                (ProjectionElem::Deref, ty::Ref(_, _, hir::Mutability::Immutable), _) => {\n                     // Shouldn't be tracked\n                     bug!(\"Tracking borrow behind shared reference.\");\n                 }\n-                (ProjectionElem::Deref, ty::Ref(_, _, hir::MutMutable), AccessDepth::Drop) => {\n+                (ProjectionElem::Deref, ty::Ref(_, _, hir::Mutability::Mutable), AccessDepth::Drop) => {\n                     // Values behind a mutable reference are not access either by dropping a\n                     // value, or by StorageDead\n                     debug!(\"borrow_conflicts_with_place: drop access behind ptr\");"}, {"sha": "57833cac9cb44a9a88982cacd99f95f9c5490bf5", "filename": "src/librustc_mir/borrow_check/prefixes.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ed640c6a27aca3b2446ab8d6f00df0a2d78f1192/src%2Flibrustc_mir%2Fborrow_check%2Fprefixes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed640c6a27aca3b2446ab8d6f00df0a2d78f1192/src%2Flibrustc_mir%2Fborrow_check%2Fprefixes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fprefixes.rs?ref=ed640c6a27aca3b2446ab8d6f00df0a2d78f1192", "patch": "@@ -149,7 +149,7 @@ impl<'cx, 'tcx> Iterator for Prefixes<'cx, 'tcx> {\n                         ty::Ref(\n                             _, /*rgn*/\n                             _, /*ty*/\n-                            hir::MutImmutable\n+                            hir::Mutability::Immutable\n                             ) => {\n                             // don't continue traversing over derefs of raw pointers or shared\n                             // borrows.\n@@ -160,7 +160,7 @@ impl<'cx, 'tcx> Iterator for Prefixes<'cx, 'tcx> {\n                         ty::Ref(\n                             _, /*rgn*/\n                             _, /*ty*/\n-                            hir::MutMutable,\n+                            hir::Mutability::Mutable,\n                             ) => {\n                             self.next = Some(PlaceRef {\n                                 base: cursor.base,"}, {"sha": "fb605bb2b557b9e5defd21e5d4bedcc832ff41e1", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed640c6a27aca3b2446ab8d6f00df0a2d78f1192/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed640c6a27aca3b2446ab8d6f00df0a2d78f1192/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=ed640c6a27aca3b2446ab8d6f00df0a2d78f1192", "patch": "@@ -581,7 +581,7 @@ where\n                 if let hir::PatKind::Binding(_, _, ident, _) = pat.kind {\n                     debuginfo.debug_name = ident.name;\n                     if let Some(&bm) = hir.tables.pat_binding_modes().get(pat.hir_id) {\n-                        if bm == ty::BindByValue(hir::MutMutable) {\n+                        if bm == ty::BindByValue(hir::Mutability::Mutable) {\n                             mutability = Mutability::Mut;\n                         } else {\n                             mutability = Mutability::Not;"}, {"sha": "2ff690b7ccc9f179a76f6d1f5c570cb408eee9c1", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ed640c6a27aca3b2446ab8d6f00df0a2d78f1192/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed640c6a27aca3b2446ab8d6f00df0a2d78f1192/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=ed640c6a27aca3b2446ab8d6f00df0a2d78f1192", "patch": "@@ -860,8 +860,8 @@ impl ToBorrowKind for AutoBorrowMutability {\n impl ToBorrowKind for hir::Mutability {\n     fn to_borrow_kind(&self) -> BorrowKind {\n         match *self {\n-            hir::MutMutable => BorrowKind::Mut { allow_two_phase_borrow: false },\n-            hir::MutImmutable => BorrowKind::Shared,\n+            hir::Mutability::Mutable => BorrowKind::Mut { allow_two_phase_borrow: false },\n+            hir::Mutability::Immutable => BorrowKind::Shared,\n         }\n     }\n }\n@@ -1013,7 +1013,7 @@ fn convert_var(\n                         let ref_closure_ty = cx.tcx.mk_ref(region,\n                                                            ty::TypeAndMut {\n                                                                ty: closure_ty,\n-                                                               mutbl: hir::MutImmutable,\n+                                                               mutbl: hir::Mutability::Immutable,\n                                                            });\n                         Expr {\n                             ty: closure_ty,\n@@ -1034,7 +1034,7 @@ fn convert_var(\n                         let ref_closure_ty = cx.tcx.mk_ref(region,\n                                                            ty::TypeAndMut {\n                                                                ty: closure_ty,\n-                                                               mutbl: hir::MutMutable,\n+                                                               mutbl: hir::Mutability::Mutable,\n                                                            });\n                         Expr {\n                             ty: closure_ty,"}, {"sha": "52af8c13e78bedfc4aa633f100650c3be4fef223", "filename": "src/librustc_mir/hair/pattern/check_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed640c6a27aca3b2446ab8d6f00df0a2d78f1192/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed640c6a27aca3b2446ab8d6f00df0a2d78f1192/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs?ref=ed640c6a27aca3b2446ab8d6f00df0a2d78f1192", "patch": "@@ -351,7 +351,7 @@ fn check_for_bindings_named_same_as_variants(cx: &MatchVisitor<'_, '_>, pat: &Pa\n     pat.walk(|p| {\n         if let hir::PatKind::Binding(_, _, ident, None) = p.kind {\n             if let Some(&bm) = cx.tables.pat_binding_modes().get(p.hir_id) {\n-                if bm != ty::BindByValue(hir::MutImmutable) {\n+                if bm != ty::BindByValue(hir::Mutability::Immutable) {\n                     // Nothing to check.\n                     return true;\n                 }"}, {"sha": "0885c9578294d82030bfd39543582759d324ea0a", "filename": "src/librustc_mir/hair/pattern/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ed640c6a27aca3b2446ab8d6f00df0a2d78f1192/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed640c6a27aca3b2446ab8d6f00df0a2d78f1192/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs?ref=ed640c6a27aca3b2446ab8d6f00df0a2d78f1192", "patch": "@@ -591,14 +591,14 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n                 let bm = *self.tables.pat_binding_modes().get(pat.hir_id)\n                                                          .expect(\"missing binding mode\");\n                 let (mutability, mode) = match bm {\n-                    ty::BindByValue(hir::MutMutable) =>\n+                    ty::BindByValue(hir::Mutability::Mutable) =>\n                         (Mutability::Mut, BindingMode::ByValue),\n-                    ty::BindByValue(hir::MutImmutable) =>\n+                    ty::BindByValue(hir::Mutability::Immutable) =>\n                         (Mutability::Not, BindingMode::ByValue),\n-                    ty::BindByReference(hir::MutMutable) =>\n+                    ty::BindByReference(hir::Mutability::Mutable) =>\n                         (Mutability::Not, BindingMode::ByRef(\n                             BorrowKind::Mut { allow_two_phase_borrow: false })),\n-                    ty::BindByReference(hir::MutImmutable) =>\n+                    ty::BindByReference(hir::Mutability::Immutable) =>\n                         (Mutability::Not, BindingMode::ByRef(\n                             BorrowKind::Shared)),\n                 };"}, {"sha": "68bb0a3e435df1c386b5bfe37d08e2bd58c5eace", "filename": "src/librustc_mir/interpret/intern.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ed640c6a27aca3b2446ab8d6f00df0a2d78f1192/src%2Flibrustc_mir%2Finterpret%2Fintern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed640c6a27aca3b2446ab8d6f00df0a2d78f1192/src%2Flibrustc_mir%2Finterpret%2Fintern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintern.rs?ref=ed640c6a27aca3b2446ab8d6f00df0a2d78f1192", "patch": "@@ -214,16 +214,16 @@ for\n                 // const qualification enforces it. We can lift it in the future.\n                 match (self.mode, mutability) {\n                     // immutable references are fine everywhere\n-                    (_, hir::Mutability::MutImmutable) => {},\n+                    (_, hir::Mutability::Immutable) => {},\n                     // all is \"good and well\" in the unsoundness of `static mut`\n \n                     // mutable references are ok in `static`. Either they are treated as immutable\n                     // because they are behind an immutable one, or they are behind an `UnsafeCell`\n                     // and thus ok.\n-                    (InternMode::Static, hir::Mutability::MutMutable) => {},\n+                    (InternMode::Static, hir::Mutability::Mutable) => {},\n                     // we statically prevent `&mut T` via `const_qualif` and double check this here\n-                    (InternMode::ConstBase, hir::Mutability::MutMutable) |\n-                    (InternMode::Const, hir::Mutability::MutMutable) => {\n+                    (InternMode::ConstBase, hir::Mutability::Mutable) |\n+                    (InternMode::Const, hir::Mutability::Mutable) => {\n                         match referenced_ty.kind {\n                             ty::Array(_, n)\n                                 if n.eval_usize(self.ecx.tcx.tcx, self.ecx.param_env) == 0 => {}\n@@ -241,7 +241,7 @@ for\n                     // If there's an immutable reference or we are inside a static, then our\n                     // mutable reference is equivalent to an immutable one. As an example:\n                     // `&&mut Foo` is semantically equivalent to `&&Foo`\n-                    (Mutability::Mutable, hir::Mutability::MutMutable) => Mutability::Mutable,\n+                    (Mutability::Mutable, hir::Mutability::Mutable) => Mutability::Mutable,\n                     _ => Mutability::Immutable,\n                 };\n                 // Recursing behind references changes the intern mode for constants in order to\n@@ -273,9 +273,9 @@ pub fn intern_const_alloc_recursive(\n ) -> InterpResult<'tcx> {\n     let tcx = ecx.tcx;\n     let (base_mutability, base_intern_mode) = match place_mut {\n-        Some(hir::Mutability::MutImmutable) => (Mutability::Immutable, InternMode::Static),\n+        Some(hir::Mutability::Immutable) => (Mutability::Immutable, InternMode::Static),\n         // `static mut` doesn't care about interior mutability, it's mutable anyway\n-        Some(hir::Mutability::MutMutable) => (Mutability::Mutable, InternMode::Static),\n+        Some(hir::Mutability::Mutable) => (Mutability::Mutable, InternMode::Static),\n         // consts, promoteds. FIXME: what about array lengths, array initializers?\n         None => (Mutability::Immutable, InternMode::ConstBase),\n     };"}, {"sha": "2913d6e59eb3f21e7b17703b38c09175ab2b1920", "filename": "src/librustc_mir/shim.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ed640c6a27aca3b2446ab8d6f00df0a2d78f1192/src%2Flibrustc_mir%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed640c6a27aca3b2446ab8d6f00df0a2d78f1192/src%2Flibrustc_mir%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fshim.rs?ref=ed640c6a27aca3b2446ab8d6f00df0a2d78f1192", "patch": "@@ -456,7 +456,7 @@ impl CloneShimBuilder<'tcx> {\n             Mutability::Not,\n             tcx.mk_ref(tcx.lifetimes.re_erased, ty::TypeAndMut {\n                 ty,\n-                mutbl: hir::Mutability::MutImmutable,\n+                mutbl: hir::Mutability::Immutable,\n             })\n         );\n \n@@ -736,7 +736,7 @@ fn build_call_shim<'tcx>(\n                 Mutability::Not,\n                 tcx.mk_ref(tcx.lifetimes.re_erased, ty::TypeAndMut {\n                     ty: sig.inputs()[0],\n-                    mutbl: hir::Mutability::MutMutable\n+                    mutbl: hir::Mutability::Mutable\n                 }),\n                 span\n             ));"}, {"sha": "a5b711e75a603e01535d1bde8c7d74bfe312be10", "filename": "src/librustc_mir/transform/check_consts/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ed640c6a27aca3b2446ab8d6f00df0a2d78f1192/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed640c6a27aca3b2446ab8d6f00df0a2d78f1192/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fmod.rs?ref=ed640c6a27aca3b2446ab8d6f00df0a2d78f1192", "patch": "@@ -82,8 +82,8 @@ impl ConstKind {\n \n             HirKind::Const => ConstKind::Const,\n \n-            HirKind::Static(hir::MutImmutable) => ConstKind::Static,\n-            HirKind::Static(hir::MutMutable) => ConstKind::StaticMut,\n+            HirKind::Static(hir::Mutability::Immutable) => ConstKind::Static,\n+            HirKind::Static(hir::Mutability::Mutable) => ConstKind::StaticMut,\n         };\n \n         Some(mode)"}, {"sha": "1170e7cc2d8857c594d2271429356aa397ebb275", "filename": "src/librustc_mir/transform/generator.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ed640c6a27aca3b2446ab8d6f00df0a2d78f1192/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed640c6a27aca3b2446ab8d6f00df0a2d78f1192/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs?ref=ed640c6a27aca3b2446ab8d6f00df0a2d78f1192", "patch": "@@ -392,7 +392,7 @@ fn make_generator_state_argument_indirect<'tcx>(\n \n     let ref_gen_ty = tcx.mk_ref(region, ty::TypeAndMut {\n         ty: gen_ty,\n-        mutbl: hir::MutMutable\n+        mutbl: hir::Mutability::Mutable\n     });\n \n     // Replace the by value generator argument\n@@ -977,7 +977,7 @@ fn create_generator_drop_shim<'tcx>(\n         mutability: Mutability::Mut,\n         ty: tcx.mk_ptr(ty::TypeAndMut {\n             ty: gen_ty,\n-            mutbl: hir::Mutability::MutMutable,\n+            mutbl: hir::Mutability::Mutable,\n         }),\n         user_ty: UserTypeProjections::none(),\n         name: None,"}, {"sha": "39720af4cb5d60f26053b1055a99a69981036a7f", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ed640c6a27aca3b2446ab8d6f00df0a2d78f1192/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed640c6a27aca3b2446ab8d6f00df0a2d78f1192/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=ed640c6a27aca3b2446ab8d6f00df0a2d78f1192", "patch": "@@ -1367,8 +1367,8 @@ fn determine_mode(tcx: TyCtxt<'_>, hir_id: HirId, def_id: DefId) -> Mode {\n         hir::BodyOwnerKind::Fn if tcx.is_const_fn(def_id) => Mode::ConstFn,\n         hir::BodyOwnerKind::Fn => Mode::NonConstFn,\n         hir::BodyOwnerKind::Const => Mode::Const,\n-        hir::BodyOwnerKind::Static(hir::MutImmutable) => Mode::Static,\n-        hir::BodyOwnerKind::Static(hir::MutMutable) => Mode::StaticMut,\n+        hir::BodyOwnerKind::Static(hir::Mutability::Immutable) => Mode::Static,\n+        hir::BodyOwnerKind::Static(hir::Mutability::Mutable) => Mode::StaticMut,\n     }\n }\n "}, {"sha": "83bde5ed34eaeca6f080407088b17b28bd70de8d", "filename": "src/librustc_mir/transform/qualify_min_const_fn.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed640c6a27aca3b2446ab8d6f00df0a2d78f1192/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed640c6a27aca3b2446ab8d6f00df0a2d78f1192/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs?ref=ed640c6a27aca3b2446ab8d6f00df0a2d78f1192", "patch": "@@ -80,7 +80,7 @@ pub fn is_min_const_fn(tcx: TyCtxt<'tcx>, def_id: DefId, body: &'a Body<'tcx>) -\n fn check_ty(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>, span: Span, fn_def_id: DefId) -> McfResult {\n     for ty in ty.walk() {\n         match ty.kind {\n-            ty::Ref(_, _, hir::Mutability::MutMutable) => return Err((\n+            ty::Ref(_, _, hir::Mutability::Mutable) => return Err((\n                 span,\n                 \"mutable references in const fn are unstable\".into(),\n             )),"}, {"sha": "67e5bfafafd12fe7f1223382ebb877c4891d68e4", "filename": "src/librustc_mir/util/elaborate_drops.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ed640c6a27aca3b2446ab8d6f00df0a2d78f1192/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed640c6a27aca3b2446ab8d6f00df0a2d78f1192/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs?ref=ed640c6a27aca3b2446ab8d6f00df0a2d78f1192", "patch": "@@ -521,7 +521,7 @@ where\n \n         let ref_ty = tcx.mk_ref(tcx.lifetimes.re_erased, ty::TypeAndMut {\n             ty,\n-            mutbl: hir::Mutability::MutMutable\n+            mutbl: hir::Mutability::Mutable\n         });\n         let ref_place = self.new_temp(ref_ty);\n         let unit_temp = Place::from(self.new_temp(tcx.mk_unit()));\n@@ -580,7 +580,7 @@ where\n \n         let ref_ty = tcx.mk_ref(tcx.lifetimes.re_erased, ty::TypeAndMut {\n             ty: ety,\n-            mutbl: hir::Mutability::MutMutable\n+            mutbl: hir::Mutability::Mutable\n         });\n         let ptr = &Place::from(self.new_temp(ref_ty));\n         let can_go = &Place::from(self.new_temp(tcx.types.bool));"}, {"sha": "3ad68d4a9dfa668c511590954f5432c9194b77b1", "filename": "src/librustc_traits/chalk_context/program_clauses/builtin.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ed640c6a27aca3b2446ab8d6f00df0a2d78f1192/src%2Flibrustc_traits%2Fchalk_context%2Fprogram_clauses%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed640c6a27aca3b2446ab8d6f00df0a2d78f1192/src%2Flibrustc_traits%2Fchalk_context%2Fprogram_clauses%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fchalk_context%2Fprogram_clauses%2Fbuiltin.rs?ref=ed640c6a27aca3b2446ab8d6f00df0a2d78f1192", "patch": "@@ -243,7 +243,7 @@ crate fn assemble_builtin_copy_clone_impls<'tcx>(\n         ty::Float(..) |\n         ty::RawPtr(..) |\n         ty::Never |\n-        ty::Ref(_, _, hir::MutImmutable) => (),\n+        ty::Ref(_, _, hir::Mutability::Immutable) => (),\n \n         // Non parametric primitive types.\n         ty::Infer(ty::IntVar(_)) |\n@@ -319,7 +319,7 @@ crate fn assemble_builtin_copy_clone_impls<'tcx>(\n         ty::Generator(..) |\n         ty::Str |\n         ty::Slice(..) |\n-        ty::Ref(_, _, hir::MutMutable) => (),\n+        ty::Ref(_, _, hir::Mutability::Mutable) => (),\n \n         ty::Bound(..) |\n         ty::GeneratorWitness(..) |"}, {"sha": "6a35f9b84525824cfe4efba9cff3c2faa340f275", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ed640c6a27aca3b2446ab8d6f00df0a2d78f1192/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed640c6a27aca3b2446ab8d6f00df0a2d78f1192/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=ed640c6a27aca3b2446ab8d6f00df0a2d78f1192", "patch": "@@ -430,8 +430,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let contains_ref_bindings = arms.iter()\n             .filter_map(|a| a.pat.contains_explicit_ref_binding())\n             .max_by_key(|m| match *m {\n-                hir::MutMutable => 1,\n-                hir::MutImmutable => 0,\n+                hir::Mutability::Mutable => 1,\n+                hir::Mutability::Immutable => 0,\n             });\n \n         if let Some(m) = contains_ref_bindings {"}, {"sha": "c195e91a52be7a0655d16c6bd38415711e1a497f", "filename": "src/librustc_typeck/check/callee.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ed640c6a27aca3b2446ab8d6f00df0a2d78f1192/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed640c6a27aca3b2446ab8d6f00df0a2d78f1192/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs?ref=ed640c6a27aca3b2446ab8d6f00df0a2d78f1192", "patch": "@@ -215,8 +215,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 if borrow {\n                     if let ty::Ref(region, _, mutbl) = method.sig.inputs()[0].kind {\n                         let mutbl = match mutbl {\n-                            hir::MutImmutable => AutoBorrowMutability::Immutable,\n-                            hir::MutMutable => AutoBorrowMutability::Mutable {\n+                            hir::Mutability::Immutable => AutoBorrowMutability::Immutable,\n+                            hir::Mutability::Mutable => AutoBorrowMutability::Mutable {\n                                 // For initial two-phase borrow\n                                 // deployment, conservatively omit\n                                 // overloaded function call ops."}, {"sha": "81732ed4ba347d677f2640cc635b717dd33ffa18", "filename": "src/librustc_typeck/check/cast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed640c6a27aca3b2446ab8d6f00df0a2d78f1192/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed640c6a27aca3b2446ab8d6f00df0a2d78f1192/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs?ref=ed640c6a27aca3b2446ab8d6f00df0a2d78f1192", "patch": "@@ -627,7 +627,7 @@ impl<'a, 'tcx> CastCheck<'tcx> {\n     ) -> Result<CastKind, CastError> {\n         // array-ptr-cast.\n \n-        if m_expr.mutbl == hir::MutImmutable && m_cast.mutbl == hir::MutImmutable {\n+        if m_expr.mutbl == hir::Mutability::Immutable && m_cast.mutbl == hir::Mutability::Immutable {\n             if let ty::Array(ety, _) = m_expr.ty.kind {\n                 // Due to the limitations of LLVM global constants,\n                 // region pointers end up pointing at copies of"}, {"sha": "a105755ca9aac3470e81f551fef3a63b7823d7fd", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ed640c6a27aca3b2446ab8d6f00df0a2d78f1192/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed640c6a27aca3b2446ab8d6f00df0a2d78f1192/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=ed640c6a27aca3b2446ab8d6f00df0a2d78f1192", "patch": "@@ -99,10 +99,10 @@ fn coerce_mutbls<'tcx>(from_mutbl: hir::Mutability,\n                        to_mutbl: hir::Mutability)\n                        -> RelateResult<'tcx, ()> {\n     match (from_mutbl, to_mutbl) {\n-        (hir::MutMutable, hir::MutMutable) |\n-        (hir::MutImmutable, hir::MutImmutable) |\n-        (hir::MutMutable, hir::MutImmutable) => Ok(()),\n-        (hir::MutImmutable, hir::MutMutable) => Err(TypeError::Mutability),\n+        (hir::Mutability::Mutable, hir::Mutability::Mutable) |\n+        (hir::Mutability::Immutable, hir::Mutability::Immutable) |\n+        (hir::Mutability::Mutable, hir::Mutability::Immutable) => Ok(()),\n+        (hir::Mutability::Immutable, hir::Mutability::Mutable) => Err(TypeError::Mutability),\n     }\n }\n \n@@ -410,7 +410,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n             }\n         };\n \n-        if ty == a && mt_a.mutbl == hir::MutImmutable && autoderef.step_count() == 1 {\n+        if ty == a && mt_a.mutbl == hir::Mutability::Immutable && autoderef.step_count() == 1 {\n             // As a special case, if we would produce `&'a *x`, that's\n             // a total no-op. We end up with the type `&'a T` just as\n             // we started with.  In that case, just skip it\n@@ -422,7 +422,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n             // `self.x` both have `&mut `type would be a move of\n             // `self.x`, but we auto-coerce it to `foo(&mut *self.x)`,\n             // which is a borrow.\n-            assert_eq!(mt_b.mutbl, hir::MutImmutable); // can only coerce &T -> &U\n+            assert_eq!(mt_b.mutbl, hir::Mutability::Immutable); // can only coerce &T -> &U\n             return success(vec![], ty, obligations);\n         }\n \n@@ -439,8 +439,8 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n             _ => span_bug!(span, \"expected a ref type, got {:?}\", ty),\n         };\n         let mutbl = match mt_b.mutbl {\n-            hir::MutImmutable => AutoBorrowMutability::Immutable,\n-            hir::MutMutable => AutoBorrowMutability::Mutable {\n+            hir::Mutability::Immutable => AutoBorrowMutability::Immutable,\n+            hir::Mutability::Mutable => AutoBorrowMutability::Mutable {\n                 allow_two_phase_borrow: self.allow_two_phase,\n             }\n         };\n@@ -485,8 +485,8 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n                 let coercion = Coercion(self.cause.span);\n                 let r_borrow = self.next_region_var(coercion);\n                 let mutbl = match mutbl_b {\n-                    hir::MutImmutable => AutoBorrowMutability::Immutable,\n-                    hir::MutMutable => AutoBorrowMutability::Mutable {\n+                    hir::Mutability::Immutable => AutoBorrowMutability::Immutable,\n+                    hir::Mutability::Mutable => AutoBorrowMutability::Mutable {\n                         // We don't allow two-phase borrows here, at least for initial\n                         // implementation. If it happens that this coercion is a function argument,\n                         // the reborrow in coerce_borrowed_ptr will pick it up."}, {"sha": "2f0b1c358f08dc8a9e2143ca137994e1f9467f62", "filename": "src/librustc_typeck/check/compare_method.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ed640c6a27aca3b2446ab8d6f00df0a2d78f1192/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed640c6a27aca3b2446ab8d6f00df0a2d78f1192/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs?ref=ed640c6a27aca3b2446ab8d6f00df0a2d78f1192", "patch": "@@ -532,8 +532,8 @@ fn compare_self_type<'tcx>(\n             let can_eq_self = |ty| infcx.can_eq(param_env, untransformed_self_ty, ty).is_ok();\n             match ExplicitSelf::determine(self_arg_ty, can_eq_self) {\n                 ExplicitSelf::ByValue => \"self\".to_owned(),\n-                ExplicitSelf::ByReference(_, hir::MutImmutable) => \"&self\".to_owned(),\n-                ExplicitSelf::ByReference(_, hir::MutMutable) => \"&mut self\".to_owned(),\n+                ExplicitSelf::ByReference(_, hir::Mutability::Immutable) => \"&self\".to_owned(),\n+                ExplicitSelf::ByReference(_, hir::Mutability::Mutable) => \"&mut self\".to_owned(),\n                 _ => format!(\"self: {}\", self_arg_ty)\n             }\n         })"}, {"sha": "5d9b3a8fba4d77e613f63ee23cdd65145ef265b4", "filename": "src/librustc_typeck/check/demand.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ed640c6a27aca3b2446ab8d6f00df0a2d78f1192/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed640c6a27aca3b2446ab8d6f00df0a2d78f1192/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs?ref=ed640c6a27aca3b2446ab8d6f00df0a2d78f1192", "patch": "@@ -398,10 +398,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 // bar(&x); // error, expected &mut\n                 // ```\n                 let ref_ty = match mutability {\n-                    hir::Mutability::MutMutable => {\n+                    hir::Mutability::Mutable => {\n                         self.tcx.mk_mut_ref(self.tcx.mk_region(ty::ReStatic), checked_ty)\n                     }\n-                    hir::Mutability::MutImmutable => {\n+                    hir::Mutability::Immutable => {\n                         self.tcx.mk_imm_ref(self.tcx.mk_region(ty::ReStatic), checked_ty)\n                     }\n                 };\n@@ -451,7 +451,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         })) = self.tcx.hir().find(\n                             self.tcx.hir().get_parent_node(expr.hir_id),\n                         ) {\n-                            if mutability == hir::Mutability::MutMutable {\n+                            if mutability == hir::Mutability::Mutable {\n                                 // Found the following case:\n                                 // fn foo(opt: &mut Option<String>){ opt = None }\n                                 //                                   ---   ^^^^\n@@ -470,12 +470,12 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         }\n \n                         return Some(match mutability {\n-                            hir::Mutability::MutMutable => (\n+                            hir::Mutability::Mutable => (\n                                 sp,\n                                 \"consider mutably borrowing here\",\n                                 format!(\"{}&mut {}\", field_name, sugg_expr),\n                             ),\n-                            hir::Mutability::MutImmutable => (\n+                            hir::Mutability::Immutable => (\n                                 sp,\n                                 \"consider borrowing here\",\n                                 format!(\"{}&{}\", field_name, sugg_expr),"}, {"sha": "cfe36b57c2da18ab86ec90627cca99477136bd7c", "filename": "src/librustc_typeck/check/expr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ed640c6a27aca3b2446ab8d6f00df0a2d78f1192/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed640c6a27aca3b2446ab8d6f00df0a2d78f1192/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs?ref=ed640c6a27aca3b2446ab8d6f00df0a2d78f1192", "patch": "@@ -363,8 +363,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         let method = self.register_infer_ok_obligations(ok);\n                         if let ty::Ref(region, _, mutbl) = method.sig.inputs()[0].kind {\n                             let mutbl = match mutbl {\n-                                hir::MutImmutable => AutoBorrowMutability::Immutable,\n-                                hir::MutMutable => AutoBorrowMutability::Mutable {\n+                                hir::Mutability::Immutable => AutoBorrowMutability::Immutable,\n+                                hir::Mutability::Mutable => AutoBorrowMutability::Mutable {\n                                     // (It shouldn't actually matter for unary ops whether\n                                     // we enable two-phase borrows or not, since a unary\n                                     // op has no additional operands.)"}, {"sha": "1a1b98f582ff2c8a37189936f30a77e9d32d3bef", "filename": "src/librustc_typeck/check/intrinsic.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/ed640c6a27aca3b2446ab8d6f00df0a2d78f1192/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed640c6a27aca3b2446ab8d6f00df0a2d78f1192/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs?ref=ed640c6a27aca3b2446ab8d6f00df0a2d78f1192", "patch": "@@ -172,7 +172,7 @@ pub fn check_intrinsic_type(tcx: TyCtxt<'_>, it: &hir::ForeignItem) {\n             \"prefetch_read_instruction\" | \"prefetch_write_instruction\" => {\n                 (1, vec![tcx.mk_ptr(ty::TypeAndMut {\n                           ty: param(0),\n-                          mutbl: hir::MutImmutable\n+                          mutbl: hir::Mutability::Immutable\n                          }), tcx.types.i32],\n                     tcx.mk_unit())\n             }\n@@ -188,25 +188,25 @@ pub fn check_intrinsic_type(tcx: TyCtxt<'_>, it: &hir::ForeignItem) {\n                vec![\n                   tcx.mk_ptr(ty::TypeAndMut {\n                       ty: param(0),\n-                      mutbl: hir::MutImmutable\n+                      mutbl: hir::Mutability::Immutable\n                   }),\n                   tcx.types.isize\n                ],\n                tcx.mk_ptr(ty::TypeAndMut {\n                    ty: param(0),\n-                   mutbl: hir::MutImmutable\n+                   mutbl: hir::Mutability::Immutable\n                }))\n             }\n             \"copy\" | \"copy_nonoverlapping\" => {\n               (1,\n                vec![\n                   tcx.mk_ptr(ty::TypeAndMut {\n                       ty: param(0),\n-                      mutbl: hir::MutImmutable\n+                      mutbl: hir::Mutability::Immutable\n                   }),\n                   tcx.mk_ptr(ty::TypeAndMut {\n                       ty: param(0),\n-                      mutbl: hir::MutMutable\n+                      mutbl: hir::Mutability::Mutable\n                   }),\n                   tcx.types.usize,\n                ],\n@@ -217,11 +217,11 @@ pub fn check_intrinsic_type(tcx: TyCtxt<'_>, it: &hir::ForeignItem) {\n                vec![\n                   tcx.mk_ptr(ty::TypeAndMut {\n                       ty: param(0),\n-                      mutbl: hir::MutMutable\n+                      mutbl: hir::Mutability::Mutable\n                   }),\n                   tcx.mk_ptr(ty::TypeAndMut {\n                       ty: param(0),\n-                      mutbl: hir::MutImmutable\n+                      mutbl: hir::Mutability::Immutable\n                   }),\n                   tcx.types.usize,\n                ],\n@@ -232,7 +232,7 @@ pub fn check_intrinsic_type(tcx: TyCtxt<'_>, it: &hir::ForeignItem) {\n                vec![\n                   tcx.mk_ptr(ty::TypeAndMut {\n                       ty: param(0),\n-                      mutbl: hir::MutMutable\n+                      mutbl: hir::Mutability::Mutable\n                   }),\n                   tcx.types.u8,\n                   tcx.types.usize,\n@@ -357,14 +357,14 @@ pub fn check_intrinsic_type(tcx: TyCtxt<'_>, it: &hir::ForeignItem) {\n             }\n \n             \"va_start\" | \"va_end\" => {\n-                match mk_va_list_ty(hir::MutMutable) {\n+                match mk_va_list_ty(hir::Mutability::Mutable) {\n                     Some((va_list_ref_ty, _)) => (0, vec![va_list_ref_ty], tcx.mk_unit()),\n                     None => bug!(\"`va_list` language item needed for C-variadic intrinsics\")\n                 }\n             }\n \n             \"va_copy\" => {\n-                match mk_va_list_ty(hir::MutImmutable) {\n+                match mk_va_list_ty(hir::Mutability::Immutable) {\n                     Some((va_list_ref_ty, va_list_ty)) => {\n                         let va_list_ptr_ty = tcx.mk_mut_ptr(va_list_ty);\n                         (0, vec![va_list_ptr_ty, va_list_ref_ty], tcx.mk_unit())\n@@ -374,7 +374,7 @@ pub fn check_intrinsic_type(tcx: TyCtxt<'_>, it: &hir::ForeignItem) {\n             }\n \n             \"va_arg\" => {\n-                match mk_va_list_ty(hir::MutMutable) {\n+                match mk_va_list_ty(hir::Mutability::Mutable) {\n                     Some((va_list_ref_ty, _)) => (1, vec![va_list_ref_ty], param(0)),\n                     None => bug!(\"`va_list` language item needed for C-variadic intrinsics\")\n                 }"}, {"sha": "4bdab84faf1235ee1bdc13e3ed94f1ccd9b63e87", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ed640c6a27aca3b2446ab8d6f00df0a2d78f1192/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed640c6a27aca3b2446ab8d6f00df0a2d78f1192/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=ed640c6a27aca3b2446ab8d6f00df0a2d78f1192", "patch": "@@ -131,7 +131,7 @@ impl<'a, 'tcx> ConfirmContext<'a, 'tcx> {\n             sig: method_sig,\n         };\n \n-        if let Some(hir::MutMutable) = pick.autoref {\n+        if let Some(hir::Mutability::Mutable) = pick.autoref {\n             self.convert_place_derefs_to_mutable();\n         }\n \n@@ -172,8 +172,8 @@ impl<'a, 'tcx> ConfirmContext<'a, 'tcx> {\n                 ty: target\n             });\n             let mutbl = match mutbl {\n-                hir::MutImmutable => AutoBorrowMutability::Immutable,\n-                hir::MutMutable => AutoBorrowMutability::Mutable {\n+                hir::Mutability::Immutable => AutoBorrowMutability::Immutable,\n+                hir::Mutability::Mutable => AutoBorrowMutability::Mutable {\n                     // Method call receivers are the primary use case\n                     // for two-phase borrows.\n                     allow_two_phase_borrow: AllowTwoPhase::Yes,\n@@ -554,8 +554,8 @@ impl<'a, 'tcx> ConfirmContext<'a, 'tcx> {\n                 if let Adjust::Borrow(AutoBorrow::Ref(..)) = adjustment.kind {\n                     debug!(\"convert_place_op_to_mutable: converting autoref {:?}\", adjustment);\n                     let mutbl = match mutbl {\n-                        hir::MutImmutable => AutoBorrowMutability::Immutable,\n-                        hir::MutMutable => AutoBorrowMutability::Mutable {\n+                        hir::Mutability::Immutable => AutoBorrowMutability::Immutable,\n+                        hir::Mutability::Mutable => AutoBorrowMutability::Mutable {\n                             // For initial two-phase borrow\n                             // deployment, conservatively omit\n                             // overloaded operators."}, {"sha": "7ea7dba5a2822185ce8a41ad99bfa337d85602dd", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ed640c6a27aca3b2446ab8d6f00df0a2d78f1192/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed640c6a27aca3b2446ab8d6f00df0a2d78f1192/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=ed640c6a27aca3b2446ab8d6f00df0a2d78f1192", "patch": "@@ -606,11 +606,11 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n                 let lang_def_id = lang_items.slice_u8_alloc_impl();\n                 self.assemble_inherent_impl_for_primitive(lang_def_id);\n             }\n-            ty::RawPtr(ty::TypeAndMut { ty: _, mutbl: hir::MutImmutable }) => {\n+            ty::RawPtr(ty::TypeAndMut { ty: _, mutbl: hir::Mutability::Immutable }) => {\n                 let lang_def_id = lang_items.const_ptr_impl();\n                 self.assemble_inherent_impl_for_primitive(lang_def_id);\n             }\n-            ty::RawPtr(ty::TypeAndMut { ty: _, mutbl: hir::MutMutable }) => {\n+            ty::RawPtr(ty::TypeAndMut { ty: _, mutbl: hir::Mutability::Mutable }) => {\n                 let lang_def_id = lang_items.mut_ptr_impl();\n                 self.assemble_inherent_impl_for_primitive(lang_def_id);\n             }\n@@ -1045,8 +1045,8 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n                         span_bug!(self.span, \"{:?} was applicable but now isn't?\", step.self_ty)\n                     });\n                 self.pick_by_value_method(step, self_ty).or_else(|| {\n-                self.pick_autorefd_method(step, self_ty, hir::MutImmutable).or_else(|| {\n-                self.pick_autorefd_method(step, self_ty, hir::MutMutable)\n+                self.pick_autorefd_method(step, self_ty, hir::Mutability::Immutable).or_else(|| {\n+                self.pick_autorefd_method(step, self_ty, hir::Mutability::Mutable)\n             })})})\n             .next()\n     }"}, {"sha": "098300f1740bcd988666c4d4c06e0288dd06d5a2", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ed640c6a27aca3b2446ab8d6f00df0a2d78f1192/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed640c6a27aca3b2446ab8d6f00df0a2d78f1192/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=ed640c6a27aca3b2446ab8d6f00df0a2d78f1192", "patch": "@@ -387,8 +387,8 @@ pub enum Needs {\n impl Needs {\n     fn maybe_mut_place(m: hir::Mutability) -> Self {\n         match m {\n-            hir::MutMutable => Needs::MutPlace,\n-            hir::MutImmutable => Needs::None,\n+            hir::Mutability::Mutable => Needs::MutPlace,\n+            hir::Mutability::Immutable => Needs::None,\n         }\n     }\n }\n@@ -1281,7 +1281,7 @@ fn check_fn<'a, 'tcx>(\n                         ty::Ref(region, ty, mutbl) => match ty.kind {\n                             ty::Adt(ref adt, _) => {\n                                 adt.did == panic_info_did &&\n-                                    mutbl == hir::Mutability::MutImmutable &&\n+                                    mutbl == hir::Mutability::Immutable &&\n                                     *region != RegionKind::ReStatic\n                             },\n                             _ => false,\n@@ -3197,8 +3197,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 let mut adjustments = autoderef.adjust_steps(self, needs);\n                 if let ty::Ref(region, _, r_mutbl) = method.sig.inputs()[0].kind {\n                     let mutbl = match r_mutbl {\n-                        hir::MutImmutable => AutoBorrowMutability::Immutable,\n-                        hir::MutMutable => AutoBorrowMutability::Mutable {\n+                        hir::Mutability::Immutable => AutoBorrowMutability::Immutable,\n+                        hir::Mutability::Mutable => AutoBorrowMutability::Mutable {\n                             // Indexing can be desugared to a method call,\n                             // so maybe we could use two-phase here.\n                             // See the documentation of AllowTwoPhase for why that's"}, {"sha": "81a3159790559551e7c0c6d152f4ce4939386bfa", "filename": "src/librustc_typeck/check/op.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ed640c6a27aca3b2446ab8d6f00df0a2d78f1192/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed640c6a27aca3b2446ab8d6f00df0a2d78f1192/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fop.rs?ref=ed640c6a27aca3b2446ab8d6f00df0a2d78f1192", "patch": "@@ -204,8 +204,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 if is_assign == IsAssign::Yes || by_ref_binop {\n                     if let ty::Ref(region, _, mutbl) = method.sig.inputs()[0].kind {\n                         let mutbl = match mutbl {\n-                            hir::MutImmutable => AutoBorrowMutability::Immutable,\n-                            hir::MutMutable => AutoBorrowMutability::Mutable {\n+                            hir::Mutability::Immutable => AutoBorrowMutability::Immutable,\n+                            hir::Mutability::Mutable => AutoBorrowMutability::Mutable {\n                                 // Allow two-phase borrows for binops in initial deployment\n                                 // since they desugar to methods\n                                 allow_two_phase_borrow: AllowTwoPhase::Yes,\n@@ -221,8 +221,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 if by_ref_binop {\n                     if let ty::Ref(region, _, mutbl) = method.sig.inputs()[1].kind {\n                         let mutbl = match mutbl {\n-                            hir::MutImmutable => AutoBorrowMutability::Immutable,\n-                            hir::MutMutable => AutoBorrowMutability::Mutable {\n+                            hir::Mutability::Immutable => AutoBorrowMutability::Immutable,\n+                            hir::Mutability::Mutable => AutoBorrowMutability::Mutable {\n                                 // Allow two-phase borrows for binops in initial deployment\n                                 // since they desugar to methods\n                                 allow_two_phase_borrow: AllowTwoPhase::Yes,"}, {"sha": "a4c9862bc742d70f4d02ed5d089e6d1c6f503b83", "filename": "src/librustc_typeck/check/pat.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ed640c6a27aca3b2446ab8d6f00df0a2d78f1192/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed640c6a27aca3b2446ab8d6f00df0a2d78f1192/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs?ref=ed640c6a27aca3b2446ab8d6f00df0a2d78f1192", "patch": "@@ -30,7 +30,7 @@ https://doc.rust-lang.org/reference/types.html#trait-objects\";\n \n impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     pub fn check_pat_top(&self, pat: &'tcx Pat, expected: Ty<'tcx>, discrim_span: Option<Span>) {\n-        let def_bm = BindingMode::BindByValue(hir::Mutability::MutImmutable);\n+        let def_bm = BindingMode::BindByValue(hir::Mutability::Immutable);\n         self.check_pat(pat, expected, def_bm, discrim_span);\n     }\n \n@@ -194,7 +194,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             //\n             // See issue #46688.\n             let def_bm = match pat.kind {\n-                PatKind::Ref(..) => ty::BindByValue(hir::MutImmutable),\n+                PatKind::Ref(..) => ty::BindByValue(hir::Mutability::Immutable),\n                 _ => def_bm,\n             };\n             (expected, def_bm)\n@@ -275,10 +275,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 // (depending on whether we observe `&` or `&mut`).\n                 ty::BindByValue(_) |\n                 // When `ref mut`, stay a `ref mut` (on `&mut`) or downgrade to `ref` (on `&`).\n-                ty::BindByReference(hir::Mutability::MutMutable) => inner_mutability,\n+                ty::BindByReference(hir::Mutability::Mutable) => inner_mutability,\n                 // Once a `ref`, always a `ref`.\n                 // This is because a `& &mut` cannot mutate the underlying value.\n-                ty::BindByReference(m @ hir::Mutability::MutImmutable) => m,\n+                ty::BindByReference(m @ hir::Mutability::Immutable) => m,\n             });\n         }\n "}, {"sha": "d613abc435288e57a63eae2203e38d351af6cab3", "filename": "src/librustc_typeck/coherence/builtin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed640c6a27aca3b2446ab8d6f00df0a2d78f1192/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed640c6a27aca3b2446ab8d6f00df0a2d78f1192/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs?ref=ed640c6a27aca3b2446ab8d6f00df0a2d78f1192", "patch": "@@ -358,7 +358,7 @@ pub fn coerce_unsized_info<'tcx>(tcx: TyCtxt<'tcx>, impl_did: DefId) -> CoerceUn\n         let check_mutbl = |mt_a: ty::TypeAndMut<'tcx>,\n                            mt_b: ty::TypeAndMut<'tcx>,\n                            mk_ptr: &dyn Fn(Ty<'tcx>) -> Ty<'tcx>| {\n-            if (mt_a.mutbl, mt_b.mutbl) == (hir::MutImmutable, hir::MutMutable) {\n+            if (mt_a.mutbl, mt_b.mutbl) == (hir::Mutability::Immutable, hir::Mutability::Mutable) {\n                 infcx.report_mismatched_types(&cause,\n                                               mk_ptr(mt_b.ty),\n                                               target,"}, {"sha": "5daa8f5d3191b1640b69097d7fb575ec257b7ccb", "filename": "src/librustc_typeck/coherence/inherent_impls.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ed640c6a27aca3b2446ab8d6f00df0a2d78f1192/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed640c6a27aca3b2446ab8d6f00df0a2d78f1192/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls.rs?ref=ed640c6a27aca3b2446ab8d6f00df0a2d78f1192", "patch": "@@ -107,15 +107,15 @@ impl ItemLikeVisitor<'v> for InherentCollect<'tcx> {\n                                           \"[T]\",\n                                           item.span);\n             }\n-            ty::RawPtr(ty::TypeAndMut { ty: _, mutbl: hir::MutImmutable }) => {\n+            ty::RawPtr(ty::TypeAndMut { ty: _, mutbl: hir::Mutability::Immutable }) => {\n                 self.check_primitive_impl(def_id,\n                                           lang_items.const_ptr_impl(),\n                                           None,\n                                           \"const_ptr\",\n                                           \"*const T\",\n                                           item.span);\n             }\n-            ty::RawPtr(ty::TypeAndMut { ty: _, mutbl: hir::MutMutable }) => {\n+            ty::RawPtr(ty::TypeAndMut { ty: _, mutbl: hir::Mutability::Mutable }) => {\n                 self.check_primitive_impl(def_id,\n                                           lang_items.mut_ptr_impl(),\n                                           None,"}, {"sha": "1e1be72221fcb052001404735101bd8909a776bb", "filename": "src/librustc_typeck/variance/constraints.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ed640c6a27aca3b2446ab8d6f00df0a2d78f1192/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed640c6a27aca3b2446ab8d6f00df0a2d78f1192/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs?ref=ed640c6a27aca3b2446ab8d6f00df0a2d78f1192", "patch": "@@ -454,12 +454,12 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n                                mt: &ty::TypeAndMut<'tcx>,\n                                variance: VarianceTermPtr<'a>) {\n         match mt.mutbl {\n-            hir::MutMutable => {\n+            hir::Mutability::Mutable => {\n                 let invar = self.invariant(variance);\n                 self.add_constraints_from_ty(current, mt.ty, invar);\n             }\n \n-            hir::MutImmutable => {\n+            hir::Mutability::Immutable => {\n                 self.add_constraints_from_ty(current, mt.ty, variance);\n             }\n         }"}, {"sha": "97f41fdc5ba463f9c83f6d6c1ff97415dcafbebc", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ed640c6a27aca3b2446ab8d6f00df0a2d78f1192/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed640c6a27aca3b2446ab8d6f00df0a2d78f1192/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=ed640c6a27aca3b2446ab8d6f00df0a2d78f1192", "patch": "@@ -3859,8 +3859,8 @@ pub enum Mutability {\n impl Clean<Mutability> for hir::Mutability {\n     fn clean(&self, _: &DocContext<'_>) -> Mutability {\n         match self {\n-            &hir::MutMutable => Mutable,\n-            &hir::MutImmutable => Immutable,\n+            &hir::Mutability::Mutable => Mutable,\n+            &hir::Mutability::Immutable => Immutable,\n         }\n     }\n }"}, {"sha": "b0f83f03f626bc9c86f7769dfc451f8222bb7785", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/ed640c6a27aca3b2446ab8d6f00df0a2d78f1192/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed640c6a27aca3b2446ab8d6f00df0a2d78f1192/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=ed640c6a27aca3b2446ab8d6f00df0a2d78f1192", "patch": "@@ -733,6 +733,30 @@ pub enum Mutability {\n     Immutable,\n }\n \n+impl Mutability {\n+    /// Returns `MutMutable` only if both `self` and `other` are mutable.\n+    pub fn and(self, other: Self) -> Self {\n+        match self {\n+            Mutability::Mutable => other,\n+            Mutability::Immutable => Mutability::Immutable,\n+        }\n+    }\n+\n+    pub fn invert(self) -> Self {\n+        match self {\n+            Mutability::Mutable => Mutability::Immutable,\n+            Mutability::Immutable => Mutability::Mutable,\n+        }\n+    }\n+\n+    pub fn prefix_str(&self) -> &'static str {\n+        match self {\n+            Mutability::Mutable => \"mut \",\n+            Mutability::Immutable => \"\",\n+        }\n+    }\n+}\n+\n #[derive(Clone, PartialEq, RustcEncodable, RustcDecodable, Debug, Copy)]\n pub enum BinOpKind {\n     /// The `+` operator (addition)"}]}