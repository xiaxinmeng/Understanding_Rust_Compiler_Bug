{"sha": "a0d2862ca41013337d07743c5e0831fe1fbddc99", "node_id": "C_kwDOAAsO6NoAKGEwZDI4NjJjYTQxMDEzMzM3ZDA3NzQzYzVlMDgzMWZlMWZiZGRjOTk", "commit": {"author": {"name": "Dylan DPC", "email": "99973273+Dylan-DPC@users.noreply.github.com", "date": "2022-03-29T20:46:34Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-03-29T20:46:34Z"}, "message": "Rollup merge of #95386 - compiler-errors:try-wrapping, r=oli-obk\n\nSuggest wrapping patterns in enum variants\n\nStructured suggestion to wrap a pattern in a single-field enum or struct:\n\n```diff\n struct A;\n\n enum B {\n   A(A),\n }\n\n fn main(b: B) {\n   match b {\n-    A => {}\n+    B::A(A) => {}\n   }\n }\n```\n\nHalf of #94942, the other half I'm not exactly sure how to fix.\n\nAlso includes two drive-by changes (that I am open to splitting out into another PR, but thought they could be rolled up into this one):\n- 07776c111f07b887cd46b752870cd3fd76b2ba7c: Makes sure not to suggest wrapping if it doesn't have tuple field constructor (i.e. has named fields)\n- 8f2bbb18fd53e5008bb488302dbd354577698ede: Also suggest wrapping expressions in a tuple struct (not just enum variants)", "tree": {"sha": "f28161a748323926631c797d0ebb9d18ec0a47ab", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f28161a748323926631c797d0ebb9d18ec0a47ab"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a0d2862ca41013337d07743c5e0831fe1fbddc99", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJiQ3ArCRBK7hj4Ov3rIwAA7dAIAAhXQEv3cbENSxhLu3YpPhKs\nI6IMsdu5CLMegOmxGbYQQbMHiOdHar2h0YYQE8sLr/Qog9gN8bj/jewkkmfKwZZU\nngyhXgjTBFoySFSfvdTqvcgc6TKLBTipFsGt4nsIv9m0jX7BjoKPsPuYV8wnzN3E\nWEC19Q/9Rz8+AmIbdWrCIhgRVnfcBWCkz4GAaVeY+lmhomMKVHJ/B/XcT3HB6Dgl\nuyNyrC1FGK2OZeppkV0oVqx9JY+5Zgcq9QQcwfApyBdiS1yT/ry8qKOHnvSEcnod\n4RumSkjGRt62DMGhHhutxDOIJdkZV9DiNhNp2aPQ2Jv/T+0D+zkajljgoSd5dbM=\n=LBS9\n-----END PGP SIGNATURE-----\n", "payload": "tree f28161a748323926631c797d0ebb9d18ec0a47ab\nparent 3208ed7b21b8b8f035b8a6bb3172be0763cf45ab\nparent fc289a07960b652632f5b050b4a865975f356694\nauthor Dylan DPC <99973273+Dylan-DPC@users.noreply.github.com> 1648586794 +0200\ncommitter GitHub <noreply@github.com> 1648586794 +0200\n\nRollup merge of #95386 - compiler-errors:try-wrapping, r=oli-obk\n\nSuggest wrapping patterns in enum variants\n\nStructured suggestion to wrap a pattern in a single-field enum or struct:\n\n```diff\n struct A;\n\n enum B {\n   A(A),\n }\n\n fn main(b: B) {\n   match b {\n-    A => {}\n+    B::A(A) => {}\n   }\n }\n```\n\nHalf of #94942, the other half I'm not exactly sure how to fix.\n\nAlso includes two drive-by changes (that I am open to splitting out into another PR, but thought they could be rolled up into this one):\n- 07776c111f07b887cd46b752870cd3fd76b2ba7c: Makes sure not to suggest wrapping if it doesn't have tuple field constructor (i.e. has named fields)\n- 8f2bbb18fd53e5008bb488302dbd354577698ede: Also suggest wrapping expressions in a tuple struct (not just enum variants)\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a0d2862ca41013337d07743c5e0831fe1fbddc99", "html_url": "https://github.com/rust-lang/rust/commit/a0d2862ca41013337d07743c5e0831fe1fbddc99", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a0d2862ca41013337d07743c5e0831fe1fbddc99/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3208ed7b21b8b8f035b8a6bb3172be0763cf45ab", "url": "https://api.github.com/repos/rust-lang/rust/commits/3208ed7b21b8b8f035b8a6bb3172be0763cf45ab", "html_url": "https://github.com/rust-lang/rust/commit/3208ed7b21b8b8f035b8a6bb3172be0763cf45ab"}, {"sha": "fc289a07960b652632f5b050b4a865975f356694", "url": "https://api.github.com/repos/rust-lang/rust/commits/fc289a07960b652632f5b050b4a865975f356694", "html_url": "https://github.com/rust-lang/rust/commit/fc289a07960b652632f5b050b4a865975f356694"}], "stats": {"total": 249, "additions": 243, "deletions": 6}, "files": [{"sha": "6e007b181f2c2b1682c6a9d282edfbd12a578fbc", "filename": "compiler/rustc_infer/src/infer/error_reporting/mod.rs", "status": "modified", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/a0d2862ca41013337d07743c5e0831fe1fbddc99/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0d2862ca41013337d07743c5e0831fe1fbddc99/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=a0d2862ca41013337d07743c5e0831fe1fbddc99", "patch": "@@ -65,6 +65,7 @@ use rustc_hir::def_id::DefId;\n use rustc_hir::lang_items::LangItem;\n use rustc_hir::{Item, ItemKind, Node};\n use rustc_middle::dep_graph::DepContext;\n+use rustc_middle::ty::print::with_no_trimmed_paths;\n use rustc_middle::ty::{\n     self,\n     error::TypeError,\n@@ -1736,6 +1737,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             };\n \n             if should_suggest_fixes {\n+                self.suggest_tuple_pattern(cause, &exp_found, diag);\n                 self.suggest_as_ref_where_appropriate(span, &exp_found, diag);\n                 self.suggest_accessing_field_where_appropriate(cause, &exp_found, diag);\n                 self.suggest_await_on_expect_found(cause, span, &exp_found, diag);\n@@ -1766,6 +1768,73 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         self.note_error_origin(diag, cause, exp_found, terr);\n     }\n \n+    fn suggest_tuple_pattern(\n+        &self,\n+        cause: &ObligationCause<'tcx>,\n+        exp_found: &ty::error::ExpectedFound<Ty<'tcx>>,\n+        diag: &mut Diagnostic,\n+    ) {\n+        // Heavily inspired by `FnCtxt::suggest_compatible_variants`, with\n+        // some modifications due to that being in typeck and this being in infer.\n+        if let ObligationCauseCode::Pattern { .. } = cause.code() {\n+            if let ty::Adt(expected_adt, substs) = exp_found.expected.kind() {\n+                let compatible_variants: Vec<_> = expected_adt\n+                    .variants()\n+                    .iter()\n+                    .filter(|variant| {\n+                        variant.fields.len() == 1 && variant.ctor_kind == hir::def::CtorKind::Fn\n+                    })\n+                    .filter_map(|variant| {\n+                        let sole_field = &variant.fields[0];\n+                        let sole_field_ty = sole_field.ty(self.tcx, substs);\n+                        if same_type_modulo_infer(sole_field_ty, exp_found.found) {\n+                            let variant_path =\n+                                with_no_trimmed_paths!(self.tcx.def_path_str(variant.def_id));\n+                            // FIXME #56861: DRYer prelude filtering\n+                            if let Some(path) = variant_path.strip_prefix(\"std::prelude::\") {\n+                                if let Some((_, path)) = path.split_once(\"::\") {\n+                                    return Some(path.to_string());\n+                                }\n+                            }\n+                            Some(variant_path)\n+                        } else {\n+                            None\n+                        }\n+                    })\n+                    .collect();\n+                match &compatible_variants[..] {\n+                    [] => {}\n+                    [variant] => {\n+                        diag.multipart_suggestion_verbose(\n+                            &format!(\"try wrapping the pattern in `{}`\", variant),\n+                            vec![\n+                                (cause.span.shrink_to_lo(), format!(\"{}(\", variant)),\n+                                (cause.span.shrink_to_hi(), \")\".to_string()),\n+                            ],\n+                            Applicability::MaybeIncorrect,\n+                        );\n+                    }\n+                    _ => {\n+                        // More than one matching variant.\n+                        diag.multipart_suggestions(\n+                            &format!(\n+                                \"try wrapping the pattern in a variant of `{}`\",\n+                                self.tcx.def_path_str(expected_adt.did())\n+                            ),\n+                            compatible_variants.into_iter().map(|variant| {\n+                                vec![\n+                                    (cause.span.shrink_to_lo(), format!(\"{}(\", variant)),\n+                                    (cause.span.shrink_to_hi(), \")\".to_string()),\n+                                ]\n+                            }),\n+                            Applicability::MaybeIncorrect,\n+                        );\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n     pub fn get_impl_future_output_ty(&self, ty: Ty<'tcx>) -> Option<Binder<'tcx, Ty<'tcx>>> {\n         if let ty::Opaque(def_id, substs) = ty.kind() {\n             let future_trait = self.tcx.require_lang_item(LangItem::Future, None);"}, {"sha": "7f5ab8e4f42fa844ede6aa0a472d7d64b033bc9d", "filename": "compiler/rustc_typeck/src/check/demand.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a0d2862ca41013337d07743c5e0831fe1fbddc99/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0d2862ca41013337d07743c5e0831fe1fbddc99/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdemand.rs?ref=a0d2862ca41013337d07743c5e0831fe1fbddc99", "patch": "@@ -268,10 +268,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         expr_ty: Ty<'tcx>,\n     ) {\n         if let ty::Adt(expected_adt, substs) = expected.kind() {\n-            if !expected_adt.is_enum() {\n-                return;\n-            }\n-\n             // If the expression is of type () and it's the return expression of a block,\n             // we suggest adding a separate return expression instead.\n             // (To avoid things like suggesting `Ok(while .. { .. })`.)\n@@ -336,7 +332,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             let compatible_variants: Vec<String> = expected_adt\n                 .variants()\n                 .iter()\n-                .filter(|variant| variant.fields.len() == 1)\n+                .filter(|variant| {\n+                    variant.fields.len() == 1 && variant.ctor_kind == hir::def::CtorKind::Fn\n+                })\n                 .filter_map(|variant| {\n                     let sole_field = &variant.fields[0];\n                     let sole_field_ty = sole_field.ty(self.tcx, substs);"}, {"sha": "09e12dab2d3fc6533f48419777c03aa47333974b", "filename": "src/test/ui/did_you_mean/compatible-variants-in-pat.rs", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/a0d2862ca41013337d07743c5e0831fe1fbddc99/src%2Ftest%2Fui%2Fdid_you_mean%2Fcompatible-variants-in-pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0d2862ca41013337d07743c5e0831fe1fbddc99/src%2Ftest%2Fui%2Fdid_you_mean%2Fcompatible-variants-in-pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdid_you_mean%2Fcompatible-variants-in-pat.rs?ref=a0d2862ca41013337d07743c5e0831fe1fbddc99", "patch": "@@ -0,0 +1,41 @@\n+enum Foo {\n+    Bar(Bar),\n+}\n+struct Bar {\n+    x: i32,\n+}\n+\n+fn a(f: Foo) {\n+    match f {\n+        Bar { x } => {\n+            //~^ ERROR mismatched types\n+            //~| HELP try wrapping\n+        }\n+    }\n+}\n+\n+struct S;\n+\n+fn b(s: Option<S>) {\n+    match s {\n+        S => {\n+            //~^ ERROR mismatched types\n+            //~| HELP try wrapping\n+            //~| HELP introduce a new binding instead\n+        }\n+        _ => {}\n+    }\n+}\n+\n+fn c(s: Result<S, S>) {\n+    match s {\n+        S => {\n+            //~^ ERROR mismatched types\n+            //~| HELP try wrapping\n+            //~| HELP introduce a new binding instead\n+        }\n+        _ => {}\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "a4c77e08efe1996908742b9489997610cb76ec2b", "filename": "src/test/ui/did_you_mean/compatible-variants-in-pat.stderr", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/a0d2862ca41013337d07743c5e0831fe1fbddc99/src%2Ftest%2Fui%2Fdid_you_mean%2Fcompatible-variants-in-pat.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a0d2862ca41013337d07743c5e0831fe1fbddc99/src%2Ftest%2Fui%2Fdid_you_mean%2Fcompatible-variants-in-pat.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdid_you_mean%2Fcompatible-variants-in-pat.stderr?ref=a0d2862ca41013337d07743c5e0831fe1fbddc99", "patch": "@@ -0,0 +1,68 @@\n+error[E0308]: mismatched types\n+  --> $DIR/compatible-variants-in-pat.rs:10:9\n+   |\n+LL |     match f {\n+   |           - this expression has type `Foo`\n+LL |         Bar { x } => {\n+   |         ^^^^^^^^^ expected enum `Foo`, found struct `Bar`\n+   |\n+help: try wrapping the pattern in `Foo::Bar`\n+   |\n+LL |         Foo::Bar(Bar { x }) => {\n+   |         +++++++++         +\n+\n+error[E0308]: mismatched types\n+  --> $DIR/compatible-variants-in-pat.rs:21:9\n+   |\n+LL | struct S;\n+   | --------- unit struct defined here\n+...\n+LL |     match s {\n+   |           - this expression has type `Option<S>`\n+LL |         S => {\n+   |         ^\n+   |         |\n+   |         expected enum `Option`, found struct `S`\n+   |         `S` is interpreted as a unit struct, not a new binding\n+   |\n+   = note: expected enum `Option<S>`\n+            found struct `S`\n+help: try wrapping the pattern in `Some`\n+   |\n+LL |         Some(S) => {\n+   |         +++++ +\n+help: introduce a new binding instead\n+   |\n+LL |         other_s => {\n+   |         ~~~~~~~\n+\n+error[E0308]: mismatched types\n+  --> $DIR/compatible-variants-in-pat.rs:32:9\n+   |\n+LL | struct S;\n+   | --------- unit struct defined here\n+...\n+LL |     match s {\n+   |           - this expression has type `Result<S, S>`\n+LL |         S => {\n+   |         ^\n+   |         |\n+   |         expected enum `Result`, found struct `S`\n+   |         `S` is interpreted as a unit struct, not a new binding\n+   |\n+   = note: expected enum `Result<S, S>`\n+            found struct `S`\n+help: try wrapping the pattern in a variant of `Result`\n+   |\n+LL |         Ok(S) => {\n+   |         +++ +\n+LL |         Err(S) => {\n+   |         ++++ +\n+help: introduce a new binding instead\n+   |\n+LL |         other_s => {\n+   |         ~~~~~~~\n+\n+error: aborting due to 3 previous errors\n+\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "5d7c611980f1c8165bdc2a2e4daa3206d487eb0d", "filename": "src/test/ui/did_you_mean/compatible-variants.rs", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/a0d2862ca41013337d07743c5e0831fe1fbddc99/src%2Ftest%2Fui%2Fdid_you_mean%2Fcompatible-variants.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0d2862ca41013337d07743c5e0831fe1fbddc99/src%2Ftest%2Fui%2Fdid_you_mean%2Fcompatible-variants.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdid_you_mean%2Fcompatible-variants.rs?ref=a0d2862ca41013337d07743c5e0831fe1fbddc99", "patch": "@@ -64,3 +64,27 @@ fn main() {\n     //~^ ERROR mismatched types\n     //~| HELP try wrapping\n }\n+\n+enum A {\n+    B { b: B},\n+}\n+\n+struct A2(B);\n+\n+enum B {\n+    Fst,\n+    Snd,\n+}\n+\n+fn foo() {\n+    // We don't want to suggest `A::B(B::Fst)` here.\n+    let a: A = B::Fst;\n+    //~^ ERROR mismatched types\n+}\n+\n+fn bar() {\n+    // But we _do_ want to suggest `A2(B::Fst)` here!\n+    let a: A2 = B::Fst;\n+    //~^ ERROR mismatched types\n+    //~| HELP try wrapping\n+}"}, {"sha": "a8cb5d6d3e8491495bd3bb681f90a35899931e4f", "filename": "src/test/ui/did_you_mean/compatible-variants.stderr", "status": "modified", "additions": 22, "deletions": 1, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/a0d2862ca41013337d07743c5e0831fe1fbddc99/src%2Ftest%2Fui%2Fdid_you_mean%2Fcompatible-variants.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a0d2862ca41013337d07743c5e0831fe1fbddc99/src%2Ftest%2Fui%2Fdid_you_mean%2Fcompatible-variants.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdid_you_mean%2Fcompatible-variants.stderr?ref=a0d2862ca41013337d07743c5e0831fe1fbddc99", "patch": "@@ -190,6 +190,27 @@ help: try wrapping the expression in `Some`\n LL |     let _ = Foo { bar: Some(bar) };\n    |                   ++++++++++   +\n \n-error: aborting due to 11 previous errors\n+error[E0308]: mismatched types\n+  --> $DIR/compatible-variants.rs:81:16\n+   |\n+LL |     let a: A = B::Fst;\n+   |            -   ^^^^^^ expected enum `A`, found enum `B`\n+   |            |\n+   |            expected due to this\n+\n+error[E0308]: mismatched types\n+  --> $DIR/compatible-variants.rs:87:17\n+   |\n+LL |     let a: A2 = B::Fst;\n+   |            --   ^^^^^^ expected struct `A2`, found enum `B`\n+   |            |\n+   |            expected due to this\n+   |\n+help: try wrapping the expression in `A2`\n+   |\n+LL |     let a: A2 = A2(B::Fst);\n+   |                 +++      +\n+\n+error: aborting due to 13 previous errors\n \n For more information about this error, try `rustc --explain E0308`."}, {"sha": "4b027eba2c25ea43ed1b2f456669847b6b45b989", "filename": "src/test/ui/issues/issue-12552.stderr", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a0d2862ca41013337d07743c5e0831fe1fbddc99/src%2Ftest%2Fui%2Fissues%2Fissue-12552.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a0d2862ca41013337d07743c5e0831fe1fbddc99/src%2Ftest%2Fui%2Fissues%2Fissue-12552.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-12552.stderr?ref=a0d2862ca41013337d07743c5e0831fe1fbddc99", "patch": "@@ -8,6 +8,10 @@ LL |     Some(k) => match k {\n    |\n    = note: expected enum `Result<_, {integer}>`\n               found enum `Option<_>`\n+help: try wrapping the pattern in `Ok`\n+   |\n+LL |     Ok(Some(k)) => match k {\n+   |     +++       +\n \n error[E0308]: mismatched types\n   --> $DIR/issue-12552.rs:9:5\n@@ -20,6 +24,10 @@ LL |     None => ()\n    |\n    = note: expected enum `Result<_, {integer}>`\n               found enum `Option<_>`\n+help: try wrapping the pattern in `Ok`\n+   |\n+LL |     Ok(None) => ()\n+   |     +++    +\n \n error: aborting due to 2 previous errors\n "}, {"sha": "29ba44f136afa48b41a334d4cc87088b63df1819", "filename": "src/test/ui/issues/issue-3680.stderr", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a0d2862ca41013337d07743c5e0831fe1fbddc99/src%2Ftest%2Fui%2Fissues%2Fissue-3680.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a0d2862ca41013337d07743c5e0831fe1fbddc99/src%2Ftest%2Fui%2Fissues%2Fissue-3680.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-3680.stderr?ref=a0d2862ca41013337d07743c5e0831fe1fbddc99", "patch": "@@ -8,6 +8,10 @@ LL |         Err(_) => ()\n    |\n    = note: expected enum `Option<_>`\n               found enum `Result<_, _>`\n+help: try wrapping the pattern in `Some`\n+   |\n+LL |         Some(Err(_)) => ()\n+   |         +++++      +\n \n error: aborting due to previous error\n "}, {"sha": "9d5b8d9d3fc1b9f08ba4566a337fc8ce5a3cdb85", "filename": "src/test/ui/issues/issue-5358-1.stderr", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a0d2862ca41013337d07743c5e0831fe1fbddc99/src%2Ftest%2Fui%2Fissues%2Fissue-5358-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a0d2862ca41013337d07743c5e0831fe1fbddc99/src%2Ftest%2Fui%2Fissues%2Fissue-5358-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-5358-1.stderr?ref=a0d2862ca41013337d07743c5e0831fe1fbddc99", "patch": "@@ -8,6 +8,10 @@ LL |         Either::Right(_) => {}\n    |\n    = note: expected struct `S`\n                 found enum `Either<_, _>`\n+help: try wrapping the pattern in `S`\n+   |\n+LL |         S(Either::Right(_)) => {}\n+   |         ++                +\n help: you might have meant to use field `0` whose type is `Either<usize, usize>`\n    |\n LL |     match S(Either::Left(5)).0 {"}]}