{"sha": "229bee3c38376b99d7d483e20fa97ec774e8a2bd", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIyOWJlZTNjMzgzNzZiOTlkN2Q0ODNlMjBmYTk3ZWM3NzRlOGEyYmQ=", "commit": {"author": {"name": "Jimmy Brisson", "email": "theotherjimmy@gmail.com", "date": "2017-10-16T22:18:02Z"}, "committer": {"name": "Jimmy Brisson", "email": "theotherjimmy@gmail.com", "date": "2017-10-16T22:25:04Z"}, "message": "Rename `read_node_index` to `try_mark_green_and_read` in plumbing\n\nThis should limit the availability of `try_mark_green_and_read` making\nit harder to abuse.", "tree": {"sha": "71a225c4681ff9905b372d21d52e6c99ad9949b7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/71a225c4681ff9905b372d21d52e6c99ad9949b7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/229bee3c38376b99d7d483e20fa97ec774e8a2bd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/229bee3c38376b99d7d483e20fa97ec774e8a2bd", "html_url": "https://github.com/rust-lang/rust/commit/229bee3c38376b99d7d483e20fa97ec774e8a2bd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/229bee3c38376b99d7d483e20fa97ec774e8a2bd/comments", "author": {"login": "theotherjimmy", "id": 685409, "node_id": "MDQ6VXNlcjY4NTQwOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/685409?v=4", "gravatar_id": "", "url": "https://api.github.com/users/theotherjimmy", "html_url": "https://github.com/theotherjimmy", "followers_url": "https://api.github.com/users/theotherjimmy/followers", "following_url": "https://api.github.com/users/theotherjimmy/following{/other_user}", "gists_url": "https://api.github.com/users/theotherjimmy/gists{/gist_id}", "starred_url": "https://api.github.com/users/theotherjimmy/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/theotherjimmy/subscriptions", "organizations_url": "https://api.github.com/users/theotherjimmy/orgs", "repos_url": "https://api.github.com/users/theotherjimmy/repos", "events_url": "https://api.github.com/users/theotherjimmy/events{/privacy}", "received_events_url": "https://api.github.com/users/theotherjimmy/received_events", "type": "User", "site_admin": false}, "committer": {"login": "theotherjimmy", "id": 685409, "node_id": "MDQ6VXNlcjY4NTQwOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/685409?v=4", "gravatar_id": "", "url": "https://api.github.com/users/theotherjimmy", "html_url": "https://github.com/theotherjimmy", "followers_url": "https://api.github.com/users/theotherjimmy/followers", "following_url": "https://api.github.com/users/theotherjimmy/following{/other_user}", "gists_url": "https://api.github.com/users/theotherjimmy/gists{/gist_id}", "starred_url": "https://api.github.com/users/theotherjimmy/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/theotherjimmy/subscriptions", "organizations_url": "https://api.github.com/users/theotherjimmy/orgs", "repos_url": "https://api.github.com/users/theotherjimmy/repos", "events_url": "https://api.github.com/users/theotherjimmy/events{/privacy}", "received_events_url": "https://api.github.com/users/theotherjimmy/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "549f8553dc487359b066c6857f7e4996e832d033", "url": "https://api.github.com/repos/rust-lang/rust/commits/549f8553dc487359b066c6857f7e4996e832d033", "html_url": "https://github.com/rust-lang/rust/commit/549f8553dc487359b066c6857f7e4996e832d033"}], "stats": {"total": 76, "additions": 38, "deletions": 38}, "files": [{"sha": "8aff042955c170f54f2dd28f1b1b900b2301797a", "filename": "src/librustc/dep_graph/graph.rs", "status": "modified", "additions": 0, "deletions": 34, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/229bee3c38376b99d7d483e20fa97ec774e8a2bd/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/229bee3c38376b99d7d483e20fa97ec774e8a2bd/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fgraph.rs?ref=229bee3c38376b99d7d483e20fa97ec774e8a2bd", "patch": "@@ -427,40 +427,6 @@ impl DepGraph {\n         self.data.as_ref().and_then(|data| data.colors.borrow().get(dep_node).cloned())\n     }\n \n-    /// Try to read a node index for the node dep_node.\n-    /// A node will have an index, when it's already been marked green, or when we can mark it\n-    /// green. This function will mark the current task as a reader of the specified node, when\n-    /// the a node index can be found for that node.\n-    pub fn read_node_index(&self, tcx: TyCtxt, dep_node: &DepNode) -> Option<DepNodeIndex> {\n-        match self.node_color(dep_node) {\n-            Some(DepNodeColor::Green(dep_node_index)) => {\n-                self.read_index(dep_node_index);\n-                Some(dep_node_index)\n-            }\n-            Some(DepNodeColor::Red) => {\n-                None\n-            }\n-            None => {\n-                // try_mark_green (called below) will panic when full incremental\n-                // compilation is disabled. If that's the case, we can't try to mark nodes\n-                // as green anyway, so we can safely return None here.\n-                if !self.is_fully_enabled() {\n-                    return None;\n-                }\n-                match self.try_mark_green(tcx, &dep_node) {\n-                    Some(dep_node_index) => {\n-                        debug_assert!(tcx.dep_graph.is_green(dep_node_index));\n-                        tcx.dep_graph.read_index(dep_node_index);\n-                        Some(dep_node_index)\n-                    }\n-                    None => {\n-                        None\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n     pub fn try_mark_green(&self,\n                           tcx: TyCtxt,\n                           dep_node: &DepNode)"}, {"sha": "be12f443782c2a6cbd39139525d6d3f944911db8", "filename": "src/librustc/ty/maps/plumbing.rs", "status": "modified", "additions": 38, "deletions": 4, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/229bee3c38376b99d7d483e20fa97ec774e8a2bd/src%2Flibrustc%2Fty%2Fmaps%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/229bee3c38376b99d7d483e20fa97ec774e8a2bd/src%2Flibrustc%2Fty%2Fmaps%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fplumbing.rs?ref=229bee3c38376b99d7d483e20fa97ec774e8a2bd", "patch": "@@ -12,7 +12,7 @@\n //! that generate the actual methods on tcx which find and execute the\n //! provider, manage the caches, and so forth.\n \n-use dep_graph::{DepNodeIndex, DepNode, DepKind};\n+use dep_graph::{DepNodeIndex, DepNode, DepKind, DepNodeColor};\n use errors::{Diagnostic, DiagnosticBuilder};\n use ty::{TyCtxt};\n use ty::maps::Query; // NB: actually generated by the macros in this file\n@@ -133,6 +133,40 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n \n         Ok(result)\n     }\n+\n+    /// Try to read a node index for the node dep_node.\n+    /// A node will have an index, when it's already been marked green, or when we can mark it\n+    /// green. This function will mark the current task as a reader of the specified node, when\n+    /// the a node index can be found for that node.\n+    pub(super) fn try_mark_green_and_read(self, dep_node: &DepNode) -> Option<DepNodeIndex> {\n+        match self.dep_graph.node_color(dep_node) {\n+            Some(DepNodeColor::Green(dep_node_index)) => {\n+                self.dep_graph.read_index(dep_node_index);\n+                Some(dep_node_index)\n+            }\n+            Some(DepNodeColor::Red) => {\n+                None\n+            }\n+            None => {\n+                // try_mark_green (called below) will panic when full incremental\n+                // compilation is disabled. If that's the case, we can't try to mark nodes\n+                // as green anyway, so we can safely return None here.\n+                if !self.dep_graph.is_fully_enabled() {\n+                    return None;\n+                }\n+                match self.dep_graph.try_mark_green(self, &dep_node) {\n+                    Some(dep_node_index) => {\n+                        debug_assert!(self.dep_graph.is_green(dep_node_index));\n+                        self.dep_graph.read_index(dep_node_index);\n+                        Some(dep_node_index)\n+                    }\n+                    None => {\n+                        None\n+                    }\n+                }\n+            }\n+        }\n+    }\n }\n \n // If enabled, send a message to the profile-queries thread\n@@ -309,7 +343,7 @@ macro_rules! define_maps {\n                 }\n \n                 if !dep_node.kind.is_input() {\n-                    if let Some(dep_node_index) = tcx.dep_graph.read_node_index(tcx, &dep_node) {\n+                    if let Some(dep_node_index) = tcx.try_mark_green_and_read(&dep_node) {\n                         profq_msg!(tcx, ProfileQueriesMsg::CacheHit);\n                         return Self::load_from_disk_and_cache_in_memory(tcx,\n                                                                         key,\n@@ -340,8 +374,8 @@ macro_rules! define_maps {\n                 // Ensuring an \"input\" or anonymous query makes no sense\n                 assert!(!dep_node.kind.is_anon());\n                 assert!(!dep_node.kind.is_input());\n-                if tcx.dep_graph.read_node_index(tcx, &dep_node).is_none() {\n-                    // A None return from `read_node_index` means that this is either\n+                if tcx.try_mark_green_and_read(&dep_node).is_none() {\n+                    // A None return from `try_mark_green_and_read` means that this is either\n                     // a new dep node or that the dep node has already been marked red.\n                     // Either way, we can't call `dep_graph.read()` as we don't have the\n                     // DepNodeIndex. We must invoke the query itself. The performance cost"}]}