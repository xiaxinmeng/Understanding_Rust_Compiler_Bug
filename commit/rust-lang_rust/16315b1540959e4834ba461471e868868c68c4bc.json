{"sha": "16315b1540959e4834ba461471e868868c68c4bc", "node_id": "C_kwDOAAsO6NoAKDE2MzE1YjE1NDA5NTllNDgzNGJhNDYxNDcxZTg2ODg2OGM2OGM0YmM", "commit": {"author": {"name": "Andy Wang", "email": "cbeuw.andy@gmail.com", "date": "2022-01-17T17:40:17Z"}, "committer": {"name": "Andy Wang", "email": "cbeuw.andy@gmail.com", "date": "2022-06-06T18:15:20Z"}, "message": "Add test cases", "tree": {"sha": "dde46160dcdad0bad7c0fbf6196556b450dd6a6f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dde46160dcdad0bad7c0fbf6196556b450dd6a6f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/16315b1540959e4834ba461471e868868c68c4bc", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQGzBAABCgAdFiEE7dcbcBMl24/h63ldGBtJ+fOPM3QFAmKeRDgACgkQGBtJ+fOP\nM3RqnAv+IJMO+qBBnR6gbgAvIb8omq+mgHT2x6h7Bqgxto3I11QEH+C1vOxKlCmG\nRvpbVcYklb3dlvqYO/Mtq3nhH+3eazZvPArDUqWmyJOUSfCWith2DpDK2gTaCbZo\n3+RBMmL4pwGYyKjPFKPp1OvXT++Q/udO1coE61vMEhoBqU13KP5O1yLqmHdv4Hs1\n7FrqzRrBLIk0k8/V8GrGi/phbSmUeWNIOKijgRetljLHkRsuH8HFZ45zOTlC1l75\ntdD3GPi6zL3V7GMtEwOpXnQwOVWERgFEMDmFxDN7Xa4z0hrtNZsSVChork/FAKUX\n7bfJKYMBhwKAcXNpGOJxVlx/JPkWm97/oa+K30UyXMrh4q7N+APsOOooxMB21zIU\nEFaZoicpy0Qm7wpnYL2FAiWSIi9Xu93gjtvkSjzoOV21db+EOu2ZOLFmsTPyY3/k\nVmxvORYd7aw4p4X1PHF4wpGHjYOY3e+YLyh9dsQVnVViwcv6b5IMTnLthQAL4vC0\nWJPNkUNL\n=OYcE\n-----END PGP SIGNATURE-----", "payload": "tree dde46160dcdad0bad7c0fbf6196556b450dd6a6f\nparent 8d36e8b32c800e6227ab2ffa7fb64729313e10a1\nauthor Andy Wang <cbeuw.andy@gmail.com> 1642441217 +0000\ncommitter Andy Wang <cbeuw.andy@gmail.com> 1654539320 +0100\n\nAdd test cases\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/16315b1540959e4834ba461471e868868c68c4bc", "html_url": "https://github.com/rust-lang/rust/commit/16315b1540959e4834ba461471e868868c68c4bc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/16315b1540959e4834ba461471e868868c68c4bc/comments", "author": {"login": "cbeuw", "id": 7034308, "node_id": "MDQ6VXNlcjcwMzQzMDg=", "avatar_url": "https://avatars.githubusercontent.com/u/7034308?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cbeuw", "html_url": "https://github.com/cbeuw", "followers_url": "https://api.github.com/users/cbeuw/followers", "following_url": "https://api.github.com/users/cbeuw/following{/other_user}", "gists_url": "https://api.github.com/users/cbeuw/gists{/gist_id}", "starred_url": "https://api.github.com/users/cbeuw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cbeuw/subscriptions", "organizations_url": "https://api.github.com/users/cbeuw/orgs", "repos_url": "https://api.github.com/users/cbeuw/repos", "events_url": "https://api.github.com/users/cbeuw/events{/privacy}", "received_events_url": "https://api.github.com/users/cbeuw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cbeuw", "id": 7034308, "node_id": "MDQ6VXNlcjcwMzQzMDg=", "avatar_url": "https://avatars.githubusercontent.com/u/7034308?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cbeuw", "html_url": "https://github.com/cbeuw", "followers_url": "https://api.github.com/users/cbeuw/followers", "following_url": "https://api.github.com/users/cbeuw/following{/other_user}", "gists_url": "https://api.github.com/users/cbeuw/gists{/gist_id}", "starred_url": "https://api.github.com/users/cbeuw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cbeuw/subscriptions", "organizations_url": "https://api.github.com/users/cbeuw/orgs", "repos_url": "https://api.github.com/users/cbeuw/repos", "events_url": "https://api.github.com/users/cbeuw/events{/privacy}", "received_events_url": "https://api.github.com/users/cbeuw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8d36e8b32c800e6227ab2ffa7fb64729313e10a1", "url": "https://api.github.com/repos/rust-lang/rust/commits/8d36e8b32c800e6227ab2ffa7fb64729313e10a1", "html_url": "https://github.com/rust-lang/rust/commit/8d36e8b32c800e6227ab2ffa7fb64729313e10a1"}], "stats": {"total": 259, "additions": 259, "deletions": 0}, "files": [{"sha": "bd3d1de7c23e220a2dc17bb72e0d761b4611d80a", "filename": "tests/run-pass/concurrency/weak_memory.rs", "status": "added", "additions": 257, "deletions": 0, "changes": 257, "blob_url": "https://github.com/rust-lang/rust/blob/16315b1540959e4834ba461471e868868c68c4bc/tests%2Frun-pass%2Fconcurrency%2Fweak_memory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16315b1540959e4834ba461471e868868c68c4bc/tests%2Frun-pass%2Fconcurrency%2Fweak_memory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fconcurrency%2Fweak_memory.rs?ref=16315b1540959e4834ba461471e868868c68c4bc", "patch": "@@ -0,0 +1,257 @@\n+// ignore-windows: Concurrency on Windows is not supported yet.\n+// compile-flags: -Zmiri-ignore-leaks -Zmiri-disable-stacked-borrows\n+\n+// Weak memory emulation tests. All of the following test if\n+// our weak memory emulation produces any inconsistent execution outcomes\n+//\n+// Due to the random nature of choosing valid stores, it is always\n+// possible that our tests spuriously succeeds: even though our weak\n+// memory emulation code has incorrectly identified a store in\n+// modification order as being valid, it may be never chosen by\n+// the RNG and never observed in our tests.\n+//\n+// To mitigate this, each test is ran enough times such that the chance\n+// of spurious success is very low. These tests never supriously fail.\n+//\n+// Note that we can't effectively test whether our weak memory emulation\n+// can produce *all* consistent execution outcomes. This may be possible\n+// if Miri's scheduler is sufficiently random and explores all possible\n+// interleavings of our small test cases after a reasonable number of runs.\n+// However, since Miri's scheduler is not even pre-emptive, there will\n+// always be possible interleavings (and possible execution outcomes),\n+// that can never be observed regardless of how weak memory emulation is\n+// implemented.\n+\n+// Test cases and their consistent outcomes are from\n+// http://svr-pes20-cppmem.cl.cam.ac.uk/cppmem/\n+// Based on\n+// M. Batty, S. Owens, S. Sarkar, P. Sewell and T. Weber,\n+// \"Mathematizing C++ concurrency\", ACM SIGPLAN Notices, vol. 46, no. 1, pp. 55-66, 2011.\n+// Available: https://ss265.host.cs.st-andrews.ac.uk/papers/n3132.pdf.\n+\n+use std::sync::atomic::Ordering::*;\n+use std::sync::atomic::{fence, AtomicUsize};\n+use std::thread::{spawn, yield_now};\n+\n+#[derive(Copy, Clone)]\n+struct EvilSend<T>(pub T);\n+\n+unsafe impl<T> Send for EvilSend<T> {}\n+unsafe impl<T> Sync for EvilSend<T> {}\n+\n+// We can't create static items because we need to run each test\n+// multiple tests\n+fn static_atomic(val: usize) -> &'static AtomicUsize {\n+    let ret = Box::leak(Box::new(AtomicUsize::new(val)));\n+    // A workaround to put the initialisation value in the store buffer\n+    ret.store(val, Relaxed);\n+    ret\n+}\n+\n+// Spins and yields until until acquires a pre-determined value\n+fn acquires_value(loc: &AtomicUsize, val: usize) -> usize {\n+    while loc.load(Acquire) != val {\n+        yield_now();\n+    }\n+    val\n+}\n+\n+fn reads_value(loc: &AtomicUsize, val: usize) -> usize {\n+    while loc.load(Relaxed) != val {\n+        yield_now();\n+    }\n+    val\n+}\n+\n+// https://plv.mpi-sws.org/scfix/paper.pdf\n+// 2.2 Second Problem: SC Fences are Too Weak\n+fn test_rwc_syncs() {\n+    /*\n+    int main() {\n+        atomic_int x = 0;\n+        atomic_int y = 0;\n+\n+        {{{ x.store(1,mo_relaxed);\n+        ||| { r1=x.load(mo_relaxed).readsvalue(1);\n+              fence(mo_seq_cst);\n+              r2=y.load(mo_relaxed); }\n+        ||| { y.store(1,mo_relaxed);\n+              fence(mo_seq_cst);\n+              r3=x.load(mo_relaxed); }\n+        }}}\n+        return 0;\n+    }\n+    */\n+    let x = static_atomic(0);\n+    let y = static_atomic(0);\n+\n+    let j1 = spawn(move || {\n+        x.store(1, Relaxed);\n+    });\n+\n+    let j2 = spawn(move || {\n+        reads_value(&x, 1);\n+        fence(SeqCst);\n+        y.load(Relaxed)\n+    });\n+\n+    let j3 = spawn(move || {\n+        y.store(1, Relaxed);\n+        fence(SeqCst);\n+        x.load(Relaxed)\n+    });\n+\n+    j1.join().unwrap();\n+    let b = j2.join().unwrap();\n+    let c = j3.join().unwrap();\n+\n+    assert_ne!((b, c), (0, 0));\n+}\n+\n+fn test_corr() {\n+    let x = static_atomic(0);\n+    let y = static_atomic(0);\n+\n+    let j1 = spawn(move || {\n+        x.store(1, Relaxed);\n+        x.store(2, Relaxed);\n+    });\n+\n+    let j2 = spawn(move || {\n+        let r2 = x.load(Relaxed); // -------------------------------------+\n+        y.store(1, Release); // ---------------------+                    |\n+        r2 //                                        |                    |\n+    }); //                                           |                    |\n+    //                                               |synchronizes-with   |happens-before\n+    let j3 = spawn(move || { //                      |                    |\n+        acquires_value(&y, 1); // <------------------+                    |\n+        x.load(Relaxed) // <----------------------------------------------+\n+        // The two reads on x are ordered by hb, so they cannot observe values\n+        // differently from the modification order. If the first read observed\n+        // 2, then the second read must observe 2 as well.\n+    });\n+\n+    j1.join().unwrap();\n+    let r2 = j2.join().unwrap();\n+    let r3 = j3.join().unwrap();\n+    if r2 == 2 {\n+        assert_eq!(r3, 2);\n+    }\n+}\n+\n+fn test_wrc() {\n+    let x = static_atomic(0);\n+    let y = static_atomic(0);\n+\n+    let j1 = spawn(move || {\n+        x.store(1, Release); // ---------------------+---------------------+\n+    }); //                                           |                     |\n+    //                                               |synchronizes-with    |\n+    let j2 = spawn(move || { //                      |                     |\n+        acquires_value(&x, 1); // <------------------+                     |\n+        y.store(1, Release); // ---------------------+                     |happens-before\n+    }); //                                           |                     |\n+    //                                               |synchronizes-with    |\n+    let j3 = spawn(move || { //                      |                     |\n+        acquires_value(&y, 1); // <------------------+                     |\n+        x.load(Relaxed) // <-----------------------------------------------+\n+    });\n+\n+    j1.join().unwrap();\n+    j2.join().unwrap();\n+    let r3 = j3.join().unwrap();\n+\n+    assert_eq!(r3, 1);\n+}\n+\n+fn test_message_passing() {\n+    let mut var = 0u32;\n+    let ptr = &mut var as *mut u32;\n+    let x = EvilSend(ptr);\n+    let y = static_atomic(0);\n+\n+    let j1 = spawn(move || {\n+        unsafe { *x.0 = 1 }; // -----------------------------------------+\n+        y.store(1, Release); // ---------------------+                   |\n+    }); //                                           |                   |\n+    //                                               |synchronizes-with  | happens-before\n+    let j2 = spawn(move || { //                      |                   |\n+        acquires_value(&y, 1); // <------------------+                   |\n+        unsafe { *x.0 } // <---------------------------------------------+\n+    });\n+\n+    j1.join().unwrap();\n+    let r2 = j2.join().unwrap();\n+\n+    assert_eq!(r2, 1);\n+}\n+\n+// LB+acq_rel+acq_rel\n+fn test_load_buffering_acq_rel() {\n+    let x = static_atomic(0);\n+    let y = static_atomic(0);\n+    let j1 = spawn(move || {\n+        let r1 = x.load(Acquire);\n+        y.store(1, Release);\n+        r1\n+    });\n+\n+    let j2 = spawn(move || {\n+        let r2 = y.load(Acquire);\n+        x.store(1, Release);\n+        r2\n+    });\n+\n+    let r1 = j1.join().unwrap();\n+    let r2 = j2.join().unwrap();\n+\n+    // 3 consistent outcomes: (0,0), (0,1), (1,0)\n+    assert_ne!((r1, r2), (1, 1));\n+}\n+\n+fn test_mixed_access() {\n+    /*\n+    int main() {\n+      atomic_int x = 0;\n+      {{{\n+        x.store(1, mo_relaxed);\n+      }}}\n+\n+      x.store(2, mo_relaxed);\n+\n+      {{{\n+        r1 = x.load(mo_relaxed);\n+      }}}\n+\n+      return 0;\n+    }\n+        */\n+    let x = static_atomic(0);\n+\n+    spawn(move || {\n+        x.store(1, Relaxed);\n+    })\n+    .join()\n+    .unwrap();\n+\n+    x.store(2, Relaxed);\n+\n+    let r2 = spawn(move || x.load(Relaxed)).join().unwrap();\n+\n+    assert_eq!(r2, 2);\n+}\n+\n+pub fn main() {\n+    // TODO: does this make chances of spurious success\n+    // \"sufficiently low\"? This also takes a long time to run,\n+    // prehaps each function should be its own test case so they\n+    // can be run in parallel\n+    for _ in 0..500 {\n+        test_mixed_access();\n+        test_load_buffering_acq_rel();\n+        test_message_passing();\n+        test_wrc();\n+        test_corr();\n+        test_rwc_syncs();\n+    }\n+}"}, {"sha": "03676519d4f1c052581dee9227a650c2a4b8d782", "filename": "tests/run-pass/concurrency/weak_memory.stderr", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/16315b1540959e4834ba461471e868868c68c4bc/tests%2Frun-pass%2Fconcurrency%2Fweak_memory.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/16315b1540959e4834ba461471e868868c68c4bc/tests%2Frun-pass%2Fconcurrency%2Fweak_memory.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fconcurrency%2Fweak_memory.stderr?ref=16315b1540959e4834ba461471e868868c68c4bc", "patch": "@@ -0,0 +1,2 @@\n+warning: thread support is experimental and incomplete: weak memory effects are not emulated.\n+"}]}