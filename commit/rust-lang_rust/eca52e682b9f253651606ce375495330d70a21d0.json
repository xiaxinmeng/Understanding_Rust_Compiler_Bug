{"sha": "eca52e682b9f253651606ce375495330d70a21d0", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVjYTUyZTY4MmI5ZjI1MzY1MTYwNmNlMzc1NDk1MzMwZDcwYTIxZDA=", "commit": {"author": {"name": "Daniel Micay", "email": "danielmicay@gmail.com", "date": "2013-11-08T09:28:29Z"}, "committer": {"name": "Daniel Micay", "email": "danielmicay@gmail.com", "date": "2013-11-08T09:47:06Z"}, "message": "tutorial: rewrite the section vectors/strings\n\nThis section desperately needs to be expanded, but removing the\nmisleading/incorrect information is a priority.\n\nManaged vectors/strings are not covered, as they are feature-gated and\nare only a micro-optimization to avoid double-indirection.\n\nCloses #6882", "tree": {"sha": "29b60ad926566871920fcc1fcf77d985d5fde7d5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/29b60ad926566871920fcc1fcf77d985d5fde7d5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/eca52e682b9f253651606ce375495330d70a21d0", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/eca52e682b9f253651606ce375495330d70a21d0", "html_url": "https://github.com/rust-lang/rust/commit/eca52e682b9f253651606ce375495330d70a21d0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/eca52e682b9f253651606ce375495330d70a21d0/comments", "author": {"login": "thestinger", "id": 1505226, "node_id": "MDQ6VXNlcjE1MDUyMjY=", "avatar_url": "https://avatars.githubusercontent.com/u/1505226?v=4", "gravatar_id": "", "url": "https://api.github.com/users/thestinger", "html_url": "https://github.com/thestinger", "followers_url": "https://api.github.com/users/thestinger/followers", "following_url": "https://api.github.com/users/thestinger/following{/other_user}", "gists_url": "https://api.github.com/users/thestinger/gists{/gist_id}", "starred_url": "https://api.github.com/users/thestinger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/thestinger/subscriptions", "organizations_url": "https://api.github.com/users/thestinger/orgs", "repos_url": "https://api.github.com/users/thestinger/repos", "events_url": "https://api.github.com/users/thestinger/events{/privacy}", "received_events_url": "https://api.github.com/users/thestinger/received_events", "type": "User", "site_admin": false}, "committer": {"login": "thestinger", "id": 1505226, "node_id": "MDQ6VXNlcjE1MDUyMjY=", "avatar_url": "https://avatars.githubusercontent.com/u/1505226?v=4", "gravatar_id": "", "url": "https://api.github.com/users/thestinger", "html_url": "https://github.com/thestinger", "followers_url": "https://api.github.com/users/thestinger/followers", "following_url": "https://api.github.com/users/thestinger/following{/other_user}", "gists_url": "https://api.github.com/users/thestinger/gists{/gist_id}", "starred_url": "https://api.github.com/users/thestinger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/thestinger/subscriptions", "organizations_url": "https://api.github.com/users/thestinger/orgs", "repos_url": "https://api.github.com/users/thestinger/repos", "events_url": "https://api.github.com/users/thestinger/events{/privacy}", "received_events_url": "https://api.github.com/users/thestinger/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "03f30515f4c8ca91dc7ceba3628f6eb1b3259ac5", "url": "https://api.github.com/repos/rust-lang/rust/commits/03f30515f4c8ca91dc7ceba3628f6eb1b3259ac5", "html_url": "https://github.com/rust-lang/rust/commit/03f30515f4c8ca91dc7ceba3628f6eb1b3259ac5"}], "stats": {"total": 197, "additions": 64, "deletions": 133}, "files": [{"sha": "8a18ca70c7e33402a3cfc97a9620dcdbf978f827", "filename": "doc/tutorial.md", "status": "modified", "additions": 64, "deletions": 133, "changes": 197, "blob_url": "https://github.com/rust-lang/rust/blob/eca52e682b9f253651606ce375495330d70a21d0/doc%2Ftutorial.md", "raw_url": "https://github.com/rust-lang/rust/raw/eca52e682b9f253651606ce375495330d70a21d0/doc%2Ftutorial.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial.md?ref=eca52e682b9f253651606ce375495330d70a21d0", "patch": "@@ -1240,58 +1240,80 @@ The indexing operator (`[]`) also auto-dereferences.\n \n # Vectors and strings\n \n-A vector is a contiguous section of memory containing zero or more\n-values of the same type. Like other types in Rust, vectors can be\n-stored on the stack, the local heap, or the exchange heap. Borrowed\n-pointers to vectors are also called 'slices'.\n+A vector is a contiguous block of memory containing zero or more values of the\n+same type. Rust also supports vector reference types, called slices, which are\n+a view into a block of memory represented as a pointer and a length.\n+\n+Strings are represented as vectors of `u8`, with the guarantee of containing a\n+valid UTF-8 sequence.\n+\n+Fixed-size vectors are an unboxed block of memory, with the element length as\n+part of the type. A fixed-size vector owns the elements it contains, so the\n+elements are mutable if the vector is mutable. Fixed-size strings do not exist.\n \n ~~~\n-# enum Crayon {\n-#     Almond, AntiqueBrass, Apricot,\n-#     Aquamarine, Asparagus, AtomicTangerine,\n-#     BananaMania, Beaver, Bittersweet,\n-#     Black, BlizzardBlue, Blue\n-# }\n-// A fixed-size stack vector\n-let stack_crayons: [Crayon, ..3] = [Almond, AntiqueBrass, Apricot];\n+// A fixed-size vector\n+let numbers = [1, 2, 3];\n+let more_numbers = numbers;\n \n-// A borrowed pointer to stack-allocated vector\n-let stack_crayons: &[Crayon] = &[Aquamarine, Asparagus, AtomicTangerine];\n+// The type of a fixed-size vector is written as `[Type, ..length]`\n+let five_zeroes: [int, ..5] = [0, ..5];\n+~~~\n \n-// A local heap (managed) vector of crayons\n-let local_crayons: @[Crayon] = @[BananaMania, Beaver, Bittersweet];\n+A unique vector is dynamically sized, and has a destructor to clean up\n+allocated memory on the heap. A unique vector owns the elements it contains, so\n+the elements are mutable if the vector is mutable.\n \n-// An exchange heap (owned) vector of crayons\n-let exchange_crayons: ~[Crayon] = ~[Black, BlizzardBlue, Blue];\n ~~~\n+// A dynamically sized vector (unique vector)\n+let mut numbers = ~[1, 2, 3];\n+numbers.push(4);\n+numbers.push(5);\n \n-The `+` operator means concatenation when applied to vector types.\n+// The type of a unique vector is written as ~[int]\n+let more_numbers: ~[int] = numbers;\n \n-~~~~\n-# enum Crayon { Almond, AntiqueBrass, Apricot,\n-#               Aquamarine, Asparagus, AtomicTangerine,\n-#               BananaMania, Beaver, Bittersweet };\n-# impl Clone for Crayon {\n-#     fn clone(&self) -> Crayon {\n-#         *self\n-#     }\n-# }\n+// The original `numbers` value can no longer be used, due to move semantics.\n \n-let my_crayons = ~[Almond, AntiqueBrass, Apricot];\n-let your_crayons = ~[BananaMania, Beaver, Bittersweet];\n+let mut string = ~\"fo\";\n+string.push_char('o');\n+~~~\n \n-// Add two vectors to create a new one\n-let our_crayons = my_crayons + your_crayons;\n+Slices are similar to fixed-size vectors, but the length is not part of the\n+type. They simply point into a block of memory and do not have ownership over\n+the elements.\n \n-// .push_all() will append to a vector, provided it lives in a mutable slot\n-let mut my_crayons = my_crayons;\n-my_crayons.push_all(your_crayons);\n-~~~~\n+~~~\n+// A slice\n+let xs = &[1, 2, 3];\n \n-> ***Note:*** The above examples of vector addition use owned\n-> vectors. Some operations on slices and stack vectors are\n-> not yet well-supported. Owned vectors are often the most\n-> usable.\n+// Slices have their type written as &[int]\n+let ys: &[int] = xs;\n+\n+// Other vector types coerce to slices\n+let three = [1, 2, 3];\n+let zs: &[int] = three;\n+\n+// An unadorned string literal is an immutable string slice\n+let string = \"foobar\";\n+\n+// A string slice type is written as &str\n+let view: &str = string.slice(0, 3);\n+~~~\n+\n+Mutable slices also exist, just as there are mutable references. However, there\n+are no mutable string slices. Strings are a multi-byte encoding (UTF-8) of\n+Unicode code points, so they cannot be freely mutated without the ability to\n+alter the length.\n+\n+~~~\n+let mut xs = [1, 2, 3];\n+let view = xs.mut_slice(0, 2);\n+view[0] = 5;\n+\n+// The type of a mutable slice is written as &mut [T]\n+let ys: &mut [int] = &mut [1, 2, 3];\n+~~~\n \n Square brackets denote indexing into a vector:\n \n@@ -1319,103 +1341,12 @@ let score = match numbers {\n };\n ~~~~\n \n-The elements of a vector _inherit the mutability of the vector_,\n-and as such, individual elements may not be reassigned when the\n-vector lives in an immutable slot.\n-\n-~~~ {.xfail-test}\n-# enum Crayon { Almond, AntiqueBrass, Apricot,\n-#               Aquamarine, Asparagus, AtomicTangerine,\n-#               BananaMania, Beaver, Bittersweet };\n-let crayons: ~[Crayon] = ~[BananaMania, Beaver, Bittersweet];\n-\n-crayons[0] = Apricot; // ERROR: Can't assign to immutable vector\n-~~~\n-\n-Moving it into a mutable slot makes the elements assignable.\n-\n-~~~\n-# enum Crayon { Almond, AntiqueBrass, Apricot,\n-#               Aquamarine, Asparagus, AtomicTangerine,\n-#               BananaMania, Beaver, Bittersweet };\n-let crayons: ~[Crayon] = ~[BananaMania, Beaver, Bittersweet];\n-\n-// Put the vector into a mutable slot\n-let mut mutable_crayons = crayons;\n-\n-// Now it's mutable to the bone\n-mutable_crayons[0] = Apricot;\n-~~~\n-\n-This is a simple example of Rust's _dual-mode data structures_, also\n-referred to as _freezing and thawing_.\n-\n-Strings are implemented with vectors of `u8`, though they have a\n-distinct type. They support most of the same allocation options as\n-vectors, though the string literal without a storage sigil (for\n-example, `\"foo\"`) is treated differently than a comparable vector\n-(`[foo]`).  Whereas plain vectors are stack-allocated fixed-length\n-vectors, plain strings are borrowed pointers to read-only (static)\n-memory. All strings are immutable.\n-\n-~~~\n-// A plain string is a slice to read-only (static) memory\n-let stack_crayons: &str = \"Almond, AntiqueBrass, Apricot\";\n-\n-// The same thing, but with the `&`\n-let stack_crayons: &str = &\"Aquamarine, Asparagus, AtomicTangerine\";\n-\n-// A local heap (managed) string\n-let local_crayons: @str = @\"BananaMania, Beaver, Bittersweet\";\n-\n-// An exchange heap (owned) string\n-let exchange_crayons: ~str = ~\"Black, BlizzardBlue, Blue\";\n-~~~\n-\n-Both vectors and strings support a number of useful\n-[methods](#methods), defined in [`std::vec`]\n-and [`std::str`]. Here are some examples.\n+Both vectors and strings support a number of useful [methods](#methods),\n+defined in [`std::vec`] and [`std::str`].\n \n [`std::vec`]: std/vec/index.html\n [`std::str`]: std/str/index.html\n \n-~~~\n-# enum Crayon {\n-#     Almond, AntiqueBrass, Apricot,\n-#     Aquamarine, Asparagus, AtomicTangerine,\n-#     BananaMania, Beaver, Bittersweet\n-# }\n-# fn unwrap_crayon(c: Crayon) -> int { 0 }\n-# fn eat_crayon_wax(i: int) { }\n-# fn store_crayon_in_nasal_cavity(i: uint, c: Crayon) { }\n-# fn crayon_to_str(c: Crayon) -> &str { \"\" }\n-\n-let crayons = [Almond, AntiqueBrass, Apricot];\n-\n-// Check the length of the vector\n-assert!(crayons.len() == 3);\n-assert!(!crayons.is_empty());\n-\n-// Iterate over a vector, obtaining a pointer to each element\n-// (`for` is explained in the container/iterator tutorial)\n-for crayon in crayons.iter() {\n-    let delicious_crayon_wax = unwrap_crayon(*crayon);\n-    eat_crayon_wax(delicious_crayon_wax);\n-}\n-\n-// Map vector elements\n-let crayon_names = crayons.map(|v| crayon_to_str(*v));\n-let favorite_crayon_name = crayon_names[0];\n-\n-// Remove whitespace from before and after the string\n-let new_favorite_crayon_name = favorite_crayon_name.trim();\n-\n-if favorite_crayon_name.len() > 5 {\n-   // Create a substring\n-   println(favorite_crayon_name.slice_chars(0, 5));\n-}\n-~~~\n-\n # Closures\n \n Named functions, like those we've seen so far, may not refer to local"}]}