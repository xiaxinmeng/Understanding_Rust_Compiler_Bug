{"sha": "0f7d81754db66d46ee9aa033735a1ee5c1daa44d", "node_id": "C_kwDOAAsO6NoAKDBmN2Q4MTc1NGRiNjZkNDZlZTlhYTAzMzczNWExZWU1YzFkYWE0NGQ", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-11-22T01:35:57Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-11-22T01:35:57Z"}, "message": "Auto merge of #104696 - matthiaskrgr:rollup-gi1pdb0, r=matthiaskrgr\n\nRollup of 11 pull requests\n\nSuccessful merges:\n\n - #103396 (Pin::new_unchecked: discuss pinning closure captures)\n - #104416 (Fix using `include_bytes` in pattern position)\n - #104557 (Add a test case for async dyn* traits)\n - #104559 (Split `MacArgs` in two.)\n - #104597 (Probe + better error messsage for `need_migrate_deref_output_trait_object`)\n - #104656 (Move tests)\n - #104657 (Do not check transmute if has non region infer)\n - #104663 (rustdoc: factor out common button CSS)\n - #104666 (Migrate alias search result to CSS variables)\n - #104674 (Make negative_impl and negative_impl_exists take the right types)\n - #104692 (Update test's cfg-if dependency to 1.0)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "c0cef180629e78a575f600b2b7f29ce825387675", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c0cef180629e78a575f600b2b7f29ce825387675"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0f7d81754db66d46ee9aa033735a1ee5c1daa44d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0f7d81754db66d46ee9aa033735a1ee5c1daa44d", "html_url": "https://github.com/rust-lang/rust/commit/0f7d81754db66d46ee9aa033735a1ee5c1daa44d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0f7d81754db66d46ee9aa033735a1ee5c1daa44d/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "28a53cdb4695b71cb9ee39959df88542056479cd", "url": "https://api.github.com/repos/rust-lang/rust/commits/28a53cdb4695b71cb9ee39959df88542056479cd", "html_url": "https://github.com/rust-lang/rust/commit/28a53cdb4695b71cb9ee39959df88542056479cd"}, {"sha": "04e8ebe3f2b4f87968eb1b661f3886662dad6028", "url": "https://api.github.com/repos/rust-lang/rust/commits/04e8ebe3f2b4f87968eb1b661f3886662dad6028", "html_url": "https://github.com/rust-lang/rust/commit/04e8ebe3f2b4f87968eb1b661f3886662dad6028"}], "stats": {"total": 855, "additions": 496, "deletions": 359}, "files": [{"sha": "b8ec667fda2399bf5dd2eabdaceaac1c88d2097a", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0f7d81754db66d46ee9aa033735a1ee5c1daa44d/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/0f7d81754db66d46ee9aa033735a1ee5c1daa44d/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=0f7d81754db66d46ee9aa033735a1ee5c1daa44d", "patch": "@@ -498,10 +498,6 @@ name = \"cfg-if\"\n version = \"0.1.10\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"4785bdd1c96b2a846b2bd7cc02e86b6b3dbf14e7e53446c4f54c92a361040822\"\n-dependencies = [\n- \"compiler_builtins\",\n- \"rustc-std-workspace-core\",\n-]\n \n [[package]]\n name = \"cfg-if\"\n@@ -4934,7 +4930,7 @@ dependencies = [\n name = \"test\"\n version = \"0.0.0\"\n dependencies = [\n- \"cfg-if 0.1.10\",\n+ \"cfg-if 1.0.0\",\n  \"core\",\n  \"getopts\",\n  \"libc\","}, {"sha": "fa745a8e08b95db68f74e9c3f343eaa8abd1e717", "filename": "compiler/rustc_ast/src/ast.rs", "status": "modified", "additions": 57, "deletions": 46, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/0f7d81754db66d46ee9aa033735a1ee5c1daa44d/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f7d81754db66d46ee9aa033735a1ee5c1daa44d/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fast.rs?ref=0f7d81754db66d46ee9aa033735a1ee5c1daa44d", "patch": "@@ -1544,55 +1544,48 @@ pub enum ClosureBinder {\n #[derive(Clone, Encodable, Decodable, Debug)]\n pub struct MacCall {\n     pub path: Path,\n-    pub args: P<MacArgs>,\n+    pub args: P<DelimArgs>,\n     pub prior_type_ascription: Option<(Span, bool)>,\n }\n \n impl MacCall {\n     pub fn span(&self) -> Span {\n-        self.path.span.to(self.args.span().unwrap_or(self.path.span))\n+        self.path.span.to(self.args.dspan.entire())\n     }\n }\n \n-/// Arguments passed to an attribute or a function-like macro.\n+/// Arguments passed to an attribute macro.\n #[derive(Clone, Encodable, Decodable, Debug)]\n-pub enum MacArgs {\n-    /// No arguments - `#[attr]`.\n+pub enum AttrArgs {\n+    /// No arguments: `#[attr]`.\n     Empty,\n-    /// Delimited arguments - `#[attr()/[]/{}]` or `mac!()/[]/{}`.\n-    Delimited(DelimSpan, MacDelimiter, TokenStream),\n-    /// Arguments of a key-value attribute - `#[attr = \"value\"]`.\n+    /// Delimited arguments: `#[attr()/[]/{}]`.\n+    Delimited(DelimArgs),\n+    /// Arguments of a key-value attribute: `#[attr = \"value\"]`.\n     Eq(\n         /// Span of the `=` token.\n         Span,\n         /// The \"value\".\n-        MacArgsEq,\n+        AttrArgsEq,\n     ),\n }\n \n-// The RHS of a `MacArgs::Eq` starts out as an expression. Once macro expansion\n-// is completed, all cases end up either as a literal, which is the form used\n-// after lowering to HIR, or as an error.\n+// The RHS of an `AttrArgs::Eq` starts out as an expression. Once macro\n+// expansion is completed, all cases end up either as a literal, which is the\n+// form used after lowering to HIR, or as an error.\n #[derive(Clone, Encodable, Decodable, Debug)]\n-pub enum MacArgsEq {\n+pub enum AttrArgsEq {\n     Ast(P<Expr>),\n     Hir(Lit),\n }\n \n-impl MacArgs {\n-    pub fn delim(&self) -> Option<Delimiter> {\n-        match self {\n-            MacArgs::Delimited(_, delim, _) => Some(delim.to_token()),\n-            MacArgs::Empty | MacArgs::Eq(..) => None,\n-        }\n-    }\n-\n+impl AttrArgs {\n     pub fn span(&self) -> Option<Span> {\n         match self {\n-            MacArgs::Empty => None,\n-            MacArgs::Delimited(dspan, ..) => Some(dspan.entire()),\n-            MacArgs::Eq(eq_span, MacArgsEq::Ast(expr)) => Some(eq_span.to(expr.span)),\n-            MacArgs::Eq(_, MacArgsEq::Hir(lit)) => {\n+            AttrArgs::Empty => None,\n+            AttrArgs::Delimited(args) => Some(args.dspan.entire()),\n+            AttrArgs::Eq(eq_span, AttrArgsEq::Ast(expr)) => Some(eq_span.to(expr.span)),\n+            AttrArgs::Eq(_, AttrArgsEq::Hir(lit)) => {\n                 unreachable!(\"in literal form when getting span: {:?}\", lit);\n             }\n         }\n@@ -1602,46 +1595,64 @@ impl MacArgs {\n     /// Proc macros see these tokens, for example.\n     pub fn inner_tokens(&self) -> TokenStream {\n         match self {\n-            MacArgs::Empty => TokenStream::default(),\n-            MacArgs::Delimited(.., tokens) => tokens.clone(),\n-            MacArgs::Eq(_, MacArgsEq::Ast(expr)) => TokenStream::from_ast(expr),\n-            MacArgs::Eq(_, MacArgsEq::Hir(lit)) => {\n+            AttrArgs::Empty => TokenStream::default(),\n+            AttrArgs::Delimited(args) => args.tokens.clone(),\n+            AttrArgs::Eq(_, AttrArgsEq::Ast(expr)) => TokenStream::from_ast(expr),\n+            AttrArgs::Eq(_, AttrArgsEq::Hir(lit)) => {\n                 unreachable!(\"in literal form when getting inner tokens: {:?}\", lit)\n             }\n         }\n     }\n-\n-    /// Whether a macro with these arguments needs a semicolon\n-    /// when used as a standalone item or statement.\n-    pub fn need_semicolon(&self) -> bool {\n-        !matches!(self, MacArgs::Delimited(_, MacDelimiter::Brace, _))\n-    }\n }\n \n-impl<CTX> HashStable<CTX> for MacArgs\n+impl<CTX> HashStable<CTX> for AttrArgs\n where\n     CTX: crate::HashStableContext,\n {\n     fn hash_stable(&self, ctx: &mut CTX, hasher: &mut StableHasher) {\n         mem::discriminant(self).hash_stable(ctx, hasher);\n         match self {\n-            MacArgs::Empty => {}\n-            MacArgs::Delimited(dspan, delim, tokens) => {\n-                dspan.hash_stable(ctx, hasher);\n-                delim.hash_stable(ctx, hasher);\n-                tokens.hash_stable(ctx, hasher);\n-            }\n-            MacArgs::Eq(_eq_span, MacArgsEq::Ast(expr)) => {\n+            AttrArgs::Empty => {}\n+            AttrArgs::Delimited(args) => args.hash_stable(ctx, hasher),\n+            AttrArgs::Eq(_eq_span, AttrArgsEq::Ast(expr)) => {\n                 unreachable!(\"hash_stable {:?}\", expr);\n             }\n-            MacArgs::Eq(eq_span, MacArgsEq::Hir(lit)) => {\n+            AttrArgs::Eq(eq_span, AttrArgsEq::Hir(lit)) => {\n                 eq_span.hash_stable(ctx, hasher);\n                 lit.hash_stable(ctx, hasher);\n             }\n         }\n     }\n }\n \n+/// Delimited arguments, as used in `#[attr()/[]/{}]` or `mac!()/[]/{}`.\n+#[derive(Clone, Encodable, Decodable, Debug)]\n+pub struct DelimArgs {\n+    pub dspan: DelimSpan,\n+    pub delim: MacDelimiter,\n+    pub tokens: TokenStream,\n+}\n+\n+impl DelimArgs {\n+    /// Whether a macro with these arguments needs a semicolon\n+    /// when used as a standalone item or statement.\n+    pub fn need_semicolon(&self) -> bool {\n+        !matches!(self, DelimArgs { delim: MacDelimiter::Brace, .. })\n+    }\n+}\n+\n+impl<CTX> HashStable<CTX> for DelimArgs\n+where\n+    CTX: crate::HashStableContext,\n+{\n+    fn hash_stable(&self, ctx: &mut CTX, hasher: &mut StableHasher) {\n+        let DelimArgs { dspan, delim, tokens } = self;\n+        dspan.hash_stable(ctx, hasher);\n+        delim.hash_stable(ctx, hasher);\n+        tokens.hash_stable(ctx, hasher);\n+    }\n+}\n+\n #[derive(Copy, Clone, PartialEq, Eq, Encodable, Decodable, Debug, HashStable_Generic)]\n pub enum MacDelimiter {\n     Parenthesis,\n@@ -1671,7 +1682,7 @@ impl MacDelimiter {\n /// Represents a macro definition.\n #[derive(Clone, Encodable, Decodable, Debug, HashStable_Generic)]\n pub struct MacroDef {\n-    pub body: P<MacArgs>,\n+    pub body: P<DelimArgs>,\n     /// `true` if macro was defined with `macro_rules`.\n     pub macro_rules: bool,\n }\n@@ -2534,7 +2545,7 @@ impl<D: Decoder> Decodable<D> for AttrId {\n #[derive(Clone, Encodable, Decodable, Debug, HashStable_Generic)]\n pub struct AttrItem {\n     pub path: Path,\n-    pub args: MacArgs,\n+    pub args: AttrArgs,\n     pub tokens: Option<LazyAttrTokenStream>,\n }\n "}, {"sha": "2f7c7a29492814a9d037d9db46633a56d4682dc0", "filename": "compiler/rustc_ast/src/attr/mod.rs", "status": "modified", "additions": 28, "deletions": 26, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/0f7d81754db66d46ee9aa033735a1ee5c1daa44d/compiler%2Frustc_ast%2Fsrc%2Fattr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f7d81754db66d46ee9aa033735a1ee5c1daa44d/compiler%2Frustc_ast%2Fsrc%2Fattr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fattr%2Fmod.rs?ref=0f7d81754db66d46ee9aa033735a1ee5c1daa44d", "patch": "@@ -1,9 +1,9 @@\n //! Functions dealing with attributes and meta items.\n \n use crate::ast;\n-use crate::ast::{AttrId, AttrItem, AttrKind, AttrStyle, Attribute};\n-use crate::ast::{Lit, LitKind};\n-use crate::ast::{MacArgs, MacArgsEq, MacDelimiter, MetaItem, MetaItemKind, NestedMetaItem};\n+use crate::ast::{AttrArgs, AttrArgsEq, AttrId, AttrItem, AttrKind, AttrStyle, Attribute};\n+use crate::ast::{DelimArgs, Lit, LitKind};\n+use crate::ast::{MacDelimiter, MetaItem, MetaItemKind, NestedMetaItem};\n use crate::ast::{Path, PathSegment};\n use crate::ptr::P;\n use crate::token::{self, CommentKind, Delimiter, Token};\n@@ -158,7 +158,7 @@ impl Attribute {\n \n     pub fn is_word(&self) -> bool {\n         if let AttrKind::Normal(normal) = &self.kind {\n-            matches!(normal.item.args, MacArgs::Empty)\n+            matches!(normal.item.args, AttrArgs::Empty)\n         } else {\n             false\n         }\n@@ -223,13 +223,13 @@ impl AttrItem {\n     pub fn meta(&self, span: Span) -> Option<MetaItem> {\n         Some(MetaItem {\n             path: self.path.clone(),\n-            kind: MetaItemKind::from_mac_args(&self.args)?,\n+            kind: MetaItemKind::from_attr_args(&self.args)?,\n             span,\n         })\n     }\n \n     pub fn meta_kind(&self) -> Option<MetaItemKind> {\n-        MetaItemKind::from_mac_args(&self.args)\n+        MetaItemKind::from_attr_args(&self.args)\n     }\n }\n \n@@ -390,7 +390,7 @@ pub fn mk_attr(\n     g: &AttrIdGenerator,\n     style: AttrStyle,\n     path: Path,\n-    args: MacArgs,\n+    args: AttrArgs,\n     span: Span,\n ) -> Attribute {\n     mk_attr_from_item(g, AttrItem { path, args, tokens: None }, None, style, span)\n@@ -413,12 +413,12 @@ pub fn mk_attr_from_item(\n \n /// Returns an inner attribute with the given value and span.\n pub fn mk_attr_inner(g: &AttrIdGenerator, item: MetaItem) -> Attribute {\n-    mk_attr(g, AttrStyle::Inner, item.path, item.kind.mac_args(item.span), item.span)\n+    mk_attr(g, AttrStyle::Inner, item.path, item.kind.attr_args(item.span), item.span)\n }\n \n /// Returns an outer attribute with the given value and span.\n pub fn mk_attr_outer(g: &AttrIdGenerator, item: MetaItem) -> Attribute {\n-    mk_attr(g, AttrStyle::Outer, item.path, item.kind.mac_args(item.span), item.span)\n+    mk_attr(g, AttrStyle::Outer, item.path, item.kind.attr_args(item.span), item.span)\n }\n \n pub fn mk_doc_comment(\n@@ -524,9 +524,9 @@ impl MetaItemKind {\n         }\n     }\n \n-    pub fn mac_args(&self, span: Span) -> MacArgs {\n+    pub fn attr_args(&self, span: Span) -> AttrArgs {\n         match self {\n-            MetaItemKind::Word => MacArgs::Empty,\n+            MetaItemKind::Word => AttrArgs::Empty,\n             MetaItemKind::NameValue(lit) => {\n                 let expr = P(ast::Expr {\n                     id: ast::DUMMY_NODE_ID,\n@@ -535,7 +535,7 @@ impl MetaItemKind {\n                     attrs: ast::AttrVec::new(),\n                     tokens: None,\n                 });\n-                MacArgs::Eq(span, MacArgsEq::Ast(expr))\n+                AttrArgs::Eq(span, AttrArgsEq::Ast(expr))\n             }\n             MetaItemKind::List(list) => {\n                 let mut tts = Vec::new();\n@@ -545,11 +545,11 @@ impl MetaItemKind {\n                     }\n                     tts.extend(item.token_trees())\n                 }\n-                MacArgs::Delimited(\n-                    DelimSpan::from_single(span),\n-                    MacDelimiter::Parenthesis,\n-                    TokenStream::new(tts),\n-                )\n+                AttrArgs::Delimited(DelimArgs {\n+                    dspan: DelimSpan::from_single(span),\n+                    delim: MacDelimiter::Parenthesis,\n+                    tokens: TokenStream::new(tts),\n+                })\n             }\n         }\n     }\n@@ -608,20 +608,22 @@ impl MetaItemKind {\n         }\n     }\n \n-    fn from_mac_args(args: &MacArgs) -> Option<MetaItemKind> {\n+    fn from_attr_args(args: &AttrArgs) -> Option<MetaItemKind> {\n         match args {\n-            MacArgs::Empty => Some(MetaItemKind::Word),\n-            MacArgs::Delimited(_, MacDelimiter::Parenthesis, tokens) => {\n-                MetaItemKind::list_from_tokens(tokens.clone())\n-            }\n-            MacArgs::Delimited(..) => None,\n-            MacArgs::Eq(_, MacArgsEq::Ast(expr)) => match expr.kind {\n+            AttrArgs::Empty => Some(MetaItemKind::Word),\n+            AttrArgs::Delimited(DelimArgs {\n+                dspan: _,\n+                delim: MacDelimiter::Parenthesis,\n+                tokens,\n+            }) => MetaItemKind::list_from_tokens(tokens.clone()),\n+            AttrArgs::Delimited(..) => None,\n+            AttrArgs::Eq(_, AttrArgsEq::Ast(expr)) => match expr.kind {\n                 ast::ExprKind::Lit(token_lit) => Some(MetaItemKind::NameValue(\n-                    Lit::from_token_lit(token_lit, expr.span).expect(\"token_lit in from_mac_args\"),\n+                    Lit::from_token_lit(token_lit, expr.span).expect(\"token_lit in from_attr_args\"),\n                 )),\n                 _ => None,\n             },\n-            MacArgs::Eq(_, MacArgsEq::Hir(lit)) => Some(MetaItemKind::NameValue(lit.clone())),\n+            AttrArgs::Eq(_, AttrArgsEq::Hir(lit)) => Some(MetaItemKind::NameValue(lit.clone())),\n         }\n     }\n "}, {"sha": "4e1dcb2842f67cf0c7d13004ec0d16360d9ff24e", "filename": "compiler/rustc_ast/src/mut_visit.rs", "status": "modified", "additions": 16, "deletions": 12, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/0f7d81754db66d46ee9aa033735a1ee5c1daa44d/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f7d81754db66d46ee9aa033735a1ee5c1daa44d/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs?ref=0f7d81754db66d46ee9aa033735a1ee5c1daa44d", "patch": "@@ -367,23 +367,27 @@ pub fn visit_fn_sig<T: MutVisitor>(FnSig { header, decl, span }: &mut FnSig, vis\n }\n \n // No `noop_` prefix because there isn't a corresponding method in `MutVisitor`.\n-pub fn visit_mac_args<T: MutVisitor>(args: &mut MacArgs, vis: &mut T) {\n+pub fn visit_attr_args<T: MutVisitor>(args: &mut AttrArgs, vis: &mut T) {\n     match args {\n-        MacArgs::Empty => {}\n-        MacArgs::Delimited(dspan, _delim, tokens) => {\n-            visit_delim_span(dspan, vis);\n-            visit_tts(tokens, vis);\n-        }\n-        MacArgs::Eq(eq_span, MacArgsEq::Ast(expr)) => {\n+        AttrArgs::Empty => {}\n+        AttrArgs::Delimited(args) => visit_delim_args(args, vis),\n+        AttrArgs::Eq(eq_span, AttrArgsEq::Ast(expr)) => {\n             vis.visit_span(eq_span);\n             vis.visit_expr(expr);\n         }\n-        MacArgs::Eq(_, MacArgsEq::Hir(lit)) => {\n+        AttrArgs::Eq(_, AttrArgsEq::Hir(lit)) => {\n             unreachable!(\"in literal form when visiting mac args eq: {:?}\", lit)\n         }\n     }\n }\n \n+// No `noop_` prefix because there isn't a corresponding method in `MutVisitor`.\n+pub fn visit_delim_args<T: MutVisitor>(args: &mut DelimArgs, vis: &mut T) {\n+    let DelimArgs { dspan, delim: _, tokens } = args;\n+    visit_delim_span(dspan, vis);\n+    visit_tts(tokens, vis);\n+}\n+\n pub fn visit_delim_span<T: MutVisitor>(dspan: &mut DelimSpan, vis: &mut T) {\n     vis.visit_span(&mut dspan.open);\n     vis.visit_span(&mut dspan.close);\n@@ -601,7 +605,7 @@ pub fn noop_visit_attribute<T: MutVisitor>(attr: &mut Attribute, vis: &mut T) {\n             let NormalAttr { item: AttrItem { path, args, tokens }, tokens: attr_tokens } =\n                 &mut **normal;\n             vis.visit_path(path);\n-            visit_mac_args(args, vis);\n+            visit_attr_args(args, vis);\n             visit_lazy_tts(tokens, vis);\n             visit_lazy_tts(attr_tokens, vis);\n         }\n@@ -613,12 +617,12 @@ pub fn noop_visit_attribute<T: MutVisitor>(attr: &mut Attribute, vis: &mut T) {\n pub fn noop_visit_mac<T: MutVisitor>(mac: &mut MacCall, vis: &mut T) {\n     let MacCall { path, args, prior_type_ascription: _ } = mac;\n     vis.visit_path(path);\n-    visit_mac_args(args, vis);\n+    visit_delim_args(args, vis);\n }\n \n pub fn noop_visit_macro_def<T: MutVisitor>(macro_def: &mut MacroDef, vis: &mut T) {\n     let MacroDef { body, macro_rules: _ } = macro_def;\n-    visit_mac_args(body, vis);\n+    visit_delim_args(body, vis);\n }\n \n pub fn noop_visit_meta_list_item<T: MutVisitor>(li: &mut NestedMetaItem, vis: &mut T) {\n@@ -792,7 +796,7 @@ pub fn visit_nonterminal<T: MutVisitor>(nt: &mut token::Nonterminal, vis: &mut T\n         token::NtMeta(item) => {\n             let AttrItem { path, args, tokens } = item.deref_mut();\n             vis.visit_path(path);\n-            visit_mac_args(args, vis);\n+            visit_attr_args(args, vis);\n             visit_lazy_tts(tokens, vis);\n         }\n         token::NtPath(path) => vis.visit_path(path),"}, {"sha": "5c69e53521275bfbf91585cea786bcb362661c26", "filename": "compiler/rustc_ast/src/visit.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0f7d81754db66d46ee9aa033735a1ee5c1daa44d/compiler%2Frustc_ast%2Fsrc%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f7d81754db66d46ee9aa033735a1ee5c1daa44d/compiler%2Frustc_ast%2Fsrc%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fvisit.rs?ref=0f7d81754db66d46ee9aa033735a1ee5c1daa44d", "patch": "@@ -926,17 +926,17 @@ pub fn walk_vis<'a, V: Visitor<'a>>(visitor: &mut V, vis: &'a Visibility) {\n \n pub fn walk_attribute<'a, V: Visitor<'a>>(visitor: &mut V, attr: &'a Attribute) {\n     match &attr.kind {\n-        AttrKind::Normal(normal) => walk_mac_args(visitor, &normal.item.args),\n+        AttrKind::Normal(normal) => walk_attr_args(visitor, &normal.item.args),\n         AttrKind::DocComment(..) => {}\n     }\n }\n \n-pub fn walk_mac_args<'a, V: Visitor<'a>>(visitor: &mut V, args: &'a MacArgs) {\n+pub fn walk_attr_args<'a, V: Visitor<'a>>(visitor: &mut V, args: &'a AttrArgs) {\n     match args {\n-        MacArgs::Empty => {}\n-        MacArgs::Delimited(_dspan, _delim, _tokens) => {}\n-        MacArgs::Eq(_eq_span, MacArgsEq::Ast(expr)) => visitor.visit_expr(expr),\n-        MacArgs::Eq(_, MacArgsEq::Hir(lit)) => {\n+        AttrArgs::Empty => {}\n+        AttrArgs::Delimited(_) => {}\n+        AttrArgs::Eq(_eq_span, AttrArgsEq::Ast(expr)) => visitor.visit_expr(expr),\n+        AttrArgs::Eq(_, AttrArgsEq::Hir(lit)) => {\n             unreachable!(\"in literal form when walking mac args eq: {:?}\", lit)\n         }\n     }"}, {"sha": "3ab42497d6d4f0938a92362b4acf484fc03e748f", "filename": "compiler/rustc_ast_lowering/src/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f7d81754db66d46ee9aa033735a1ee5c1daa44d/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f7d81754db66d46ee9aa033735a1ee5c1daa44d/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs?ref=0f7d81754db66d46ee9aa033735a1ee5c1daa44d", "patch": "@@ -671,7 +671,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                     kind: AttrKind::Normal(ptr::P(NormalAttr {\n                         item: AttrItem {\n                             path: Path::from_ident(Ident::new(sym::track_caller, span)),\n-                            args: MacArgs::Empty,\n+                            args: AttrArgs::Empty,\n                             tokens: None,\n                         },\n                         tokens: None,"}, {"sha": "99b3ac864ddfd5d17deebfdc700a80149fb696f2", "filename": "compiler/rustc_ast_lowering/src/item.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f7d81754db66d46ee9aa033735a1ee5c1daa44d/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f7d81754db66d46ee9aa033735a1ee5c1daa44d/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs?ref=0f7d81754db66d46ee9aa033735a1ee5c1daa44d", "patch": "@@ -470,7 +470,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 hir::ItemKind::TraitAlias(generics, bounds)\n             }\n             ItemKind::MacroDef(MacroDef { ref body, macro_rules }) => {\n-                let body = P(self.lower_mac_args(body));\n+                let body = P(self.lower_delim_args(body));\n                 let macro_kind = self.resolver.decl_macro_kind(self.local_def_id(id));\n                 hir::ItemKind::Macro(ast::MacroDef { body, macro_rules }, macro_kind)\n             }"}, {"sha": "ce81a0ae9596b31c331279f19abb4cac80eac6cf", "filename": "compiler/rustc_ast_lowering/src/lib.rs", "status": "modified", "additions": 11, "deletions": 25, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/0f7d81754db66d46ee9aa033735a1ee5c1daa44d/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f7d81754db66d46ee9aa033735a1ee5c1daa44d/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs?ref=0f7d81754db66d46ee9aa033735a1ee5c1daa44d", "patch": "@@ -911,7 +911,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             AttrKind::Normal(ref normal) => AttrKind::Normal(P(NormalAttr {\n                 item: AttrItem {\n                     path: normal.item.path.clone(),\n-                    args: self.lower_mac_args(&normal.item.args),\n+                    args: self.lower_attr_args(&normal.item.args),\n                     tokens: None,\n                 },\n                 tokens: None,\n@@ -931,32 +931,14 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         }\n     }\n \n-    fn lower_mac_args(&self, args: &MacArgs) -> MacArgs {\n+    fn lower_attr_args(&self, args: &AttrArgs) -> AttrArgs {\n         match *args {\n-            MacArgs::Empty => MacArgs::Empty,\n-            MacArgs::Delimited(dspan, delim, ref tokens) => {\n-                // This is either a non-key-value attribute, or a `macro_rules!` body.\n-                // We either not have any nonterminals present (in the case of an attribute),\n-                // or have tokens available for all nonterminals in the case of a nested\n-                // `macro_rules`: e.g:\n-                //\n-                // ```rust\n-                // macro_rules! outer {\n-                //     ($e:expr) => {\n-                //         macro_rules! inner {\n-                //             () => { $e }\n-                //         }\n-                //     }\n-                // }\n-                // ```\n-                //\n-                // In both cases, we don't want to synthesize any tokens\n-                MacArgs::Delimited(dspan, delim, tokens.flattened())\n-            }\n+            AttrArgs::Empty => AttrArgs::Empty,\n+            AttrArgs::Delimited(ref args) => AttrArgs::Delimited(self.lower_delim_args(args)),\n             // This is an inert key-value attribute - it will never be visible to macros\n             // after it gets lowered to HIR. Therefore, we can extract literals to handle\n             // nonterminals in `#[doc]` (e.g. `#[doc = $e]`).\n-            MacArgs::Eq(eq_span, MacArgsEq::Ast(ref expr)) => {\n+            AttrArgs::Eq(eq_span, AttrArgsEq::Ast(ref expr)) => {\n                 // In valid code the value always ends up as a single literal. Otherwise, a dummy\n                 // literal suffices because the error is handled elsewhere.\n                 let lit = if let ExprKind::Lit(token_lit) = expr.kind {\n@@ -975,14 +957,18 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                         span: DUMMY_SP,\n                     }\n                 };\n-                MacArgs::Eq(eq_span, MacArgsEq::Hir(lit))\n+                AttrArgs::Eq(eq_span, AttrArgsEq::Hir(lit))\n             }\n-            MacArgs::Eq(_, MacArgsEq::Hir(ref lit)) => {\n+            AttrArgs::Eq(_, AttrArgsEq::Hir(ref lit)) => {\n                 unreachable!(\"in literal form when lowering mac args eq: {:?}\", lit)\n             }\n         }\n     }\n \n+    fn lower_delim_args(&self, args: &DelimArgs) -> DelimArgs {\n+        DelimArgs { dspan: args.dspan, delim: args.delim, tokens: args.tokens.flattened() }\n+    }\n+\n     /// Given an associated type constraint like one of these:\n     ///\n     /// ```ignore (illustrative)"}, {"sha": "991f6e0ba224340024055395ae91454109117a40", "filename": "compiler/rustc_ast_pretty/src/pprust/state.rs", "status": "modified", "additions": 17, "deletions": 23, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/0f7d81754db66d46ee9aa033735a1ee5c1daa44d/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f7d81754db66d46ee9aa033735a1ee5c1daa44d/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs?ref=0f7d81754db66d46ee9aa033735a1ee5c1daa44d", "patch": "@@ -11,10 +11,9 @@ use rustc_ast::tokenstream::{TokenStream, TokenTree};\n use rustc_ast::util::classify;\n use rustc_ast::util::comments::{gather_comments, Comment, CommentStyle};\n use rustc_ast::util::parser;\n-use rustc_ast::{self as ast, BlockCheckMode, Mutability, PatKind, RangeEnd, RangeSyntax};\n-use rustc_ast::{attr, BindingAnnotation, ByRef, Term};\n-use rustc_ast::{GenericArg, MacArgs, MacArgsEq};\n-use rustc_ast::{GenericBound, SelfKind, TraitBoundModifier};\n+use rustc_ast::{self as ast, AttrArgs, AttrArgsEq, BlockCheckMode, Mutability, PatKind};\n+use rustc_ast::{attr, BindingAnnotation, ByRef, DelimArgs, RangeEnd, RangeSyntax, Term};\n+use rustc_ast::{GenericArg, GenericBound, SelfKind, TraitBoundModifier};\n use rustc_ast::{InlineAsmOperand, InlineAsmRegOrRegClass};\n use rustc_ast::{InlineAsmOptions, InlineAsmTemplatePiece};\n use rustc_span::edition::Edition;\n@@ -466,26 +465,26 @@ pub trait PrintState<'a>: std::ops::Deref<Target = pp::Printer> + std::ops::Dere\n     fn print_attr_item(&mut self, item: &ast::AttrItem, span: Span) {\n         self.ibox(0);\n         match &item.args {\n-            MacArgs::Delimited(_, delim, tokens) => self.print_mac_common(\n+            AttrArgs::Delimited(DelimArgs { dspan: _, delim, tokens }) => self.print_mac_common(\n                 Some(MacHeader::Path(&item.path)),\n                 false,\n                 None,\n-                Some(delim.to_token()),\n+                delim.to_token(),\n                 tokens,\n                 true,\n                 span,\n             ),\n-            MacArgs::Empty => {\n+            AttrArgs::Empty => {\n                 self.print_path(&item.path, false, 0);\n             }\n-            MacArgs::Eq(_, MacArgsEq::Ast(expr)) => {\n+            AttrArgs::Eq(_, AttrArgsEq::Ast(expr)) => {\n                 self.print_path(&item.path, false, 0);\n                 self.space();\n                 self.word_space(\"=\");\n                 let token_str = self.expr_to_string(expr);\n                 self.word(token_str);\n             }\n-            MacArgs::Eq(_, MacArgsEq::Hir(lit)) => {\n+            AttrArgs::Eq(_, AttrArgsEq::Hir(lit)) => {\n                 self.print_path(&item.path, false, 0);\n                 self.space();\n                 self.word_space(\"=\");\n@@ -544,7 +543,7 @@ pub trait PrintState<'a>: std::ops::Deref<Target = pp::Printer> + std::ops::Dere\n                     None,\n                     false,\n                     None,\n-                    Some(*delim),\n+                    *delim,\n                     tts,\n                     convert_dollar_crate,\n                     dspan.entire(),\n@@ -570,12 +569,12 @@ pub trait PrintState<'a>: std::ops::Deref<Target = pp::Printer> + std::ops::Dere\n         header: Option<MacHeader<'_>>,\n         has_bang: bool,\n         ident: Option<Ident>,\n-        delim: Option<Delimiter>,\n+        delim: Delimiter,\n         tts: &TokenStream,\n         convert_dollar_crate: bool,\n         span: Span,\n     ) {\n-        if delim == Some(Delimiter::Brace) {\n+        if delim == Delimiter::Brace {\n             self.cbox(INDENT_UNIT);\n         }\n         match header {\n@@ -591,7 +590,7 @@ pub trait PrintState<'a>: std::ops::Deref<Target = pp::Printer> + std::ops::Dere\n             self.print_ident(ident);\n         }\n         match delim {\n-            Some(Delimiter::Brace) => {\n+            Delimiter::Brace => {\n                 if header.is_some() || has_bang || ident.is_some() {\n                     self.nbsp();\n                 }\n@@ -605,7 +604,7 @@ pub trait PrintState<'a>: std::ops::Deref<Target = pp::Printer> + std::ops::Dere\n                 let empty = tts.is_empty();\n                 self.bclose(span, empty);\n             }\n-            Some(delim) => {\n+            delim => {\n                 let token_str = self.token_kind_to_string(&token::OpenDelim(delim));\n                 self.word(token_str);\n                 self.ibox(0);\n@@ -614,11 +613,6 @@ pub trait PrintState<'a>: std::ops::Deref<Target = pp::Printer> + std::ops::Dere\n                 let token_str = self.token_kind_to_string(&token::CloseDelim(delim));\n                 self.word(token_str);\n             }\n-            None => {\n-                self.ibox(0);\n-                self.print_tts(tts, convert_dollar_crate);\n-                self.end();\n-            }\n         }\n     }\n \n@@ -639,8 +633,8 @@ pub trait PrintState<'a>: std::ops::Deref<Target = pp::Printer> + std::ops::Dere\n             Some(MacHeader::Keyword(kw)),\n             has_bang,\n             Some(*ident),\n-            macro_def.body.delim(),\n-            &macro_def.body.inner_tokens(),\n+            macro_def.body.delim.to_token(),\n+            &macro_def.body.tokens.clone(),\n             true,\n             sp,\n         );\n@@ -1230,8 +1224,8 @@ impl<'a> State<'a> {\n             Some(MacHeader::Path(&m.path)),\n             true,\n             None,\n-            m.args.delim(),\n-            &m.args.inner_tokens(),\n+            m.args.delim.to_token(),\n+            &m.args.tokens.clone(),\n             true,\n             m.span(),\n         );"}, {"sha": "8555c3593b3339f1d7a490d662de358d14b660e1", "filename": "compiler/rustc_builtin_macros/src/assert.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0f7d81754db66d46ee9aa033735a1ee5c1daa44d/compiler%2Frustc_builtin_macros%2Fsrc%2Fassert.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f7d81754db66d46ee9aa033735a1ee5c1daa44d/compiler%2Frustc_builtin_macros%2Fsrc%2Fassert.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fassert.rs?ref=0f7d81754db66d46ee9aa033735a1ee5c1daa44d", "patch": "@@ -4,7 +4,7 @@ use crate::edition_panic::use_panic_2021;\n use rustc_ast::ptr::P;\n use rustc_ast::token;\n use rustc_ast::tokenstream::{DelimSpan, TokenStream};\n-use rustc_ast::{Expr, ExprKind, MacArgs, MacCall, MacDelimiter, Path, PathSegment, UnOp};\n+use rustc_ast::{DelimArgs, Expr, ExprKind, MacCall, MacDelimiter, Path, PathSegment, UnOp};\n use rustc_ast_pretty::pprust;\n use rustc_errors::{Applicability, PResult};\n use rustc_expand::base::{DummyResult, ExtCtxt, MacEager, MacResult};\n@@ -54,11 +54,11 @@ pub fn expand_assert<'cx>(\n             call_site_span,\n             ExprKind::MacCall(P(MacCall {\n                 path: panic_path(),\n-                args: P(MacArgs::Delimited(\n-                    DelimSpan::from_single(call_site_span),\n-                    MacDelimiter::Parenthesis,\n+                args: P(DelimArgs {\n+                    dspan: DelimSpan::from_single(call_site_span),\n+                    delim: MacDelimiter::Parenthesis,\n                     tokens,\n-                )),\n+                }),\n                 prior_type_ascription: None,\n             })),\n         );"}, {"sha": "220b7a8ad0fcd236b3fb369ae2abfaebc7a0916f", "filename": "compiler/rustc_builtin_macros/src/assert/context.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0f7d81754db66d46ee9aa033735a1ee5c1daa44d/compiler%2Frustc_builtin_macros%2Fsrc%2Fassert%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f7d81754db66d46ee9aa033735a1ee5c1daa44d/compiler%2Frustc_builtin_macros%2Fsrc%2Fassert%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fassert%2Fcontext.rs?ref=0f7d81754db66d46ee9aa033735a1ee5c1daa44d", "patch": "@@ -3,7 +3,7 @@ use rustc_ast::{\n     ptr::P,\n     token,\n     tokenstream::{DelimSpan, TokenStream, TokenTree},\n-    BinOpKind, BorrowKind, Expr, ExprKind, ItemKind, MacArgs, MacCall, MacDelimiter, MethodCall,\n+    BinOpKind, BorrowKind, DelimArgs, Expr, ExprKind, ItemKind, MacCall, MacDelimiter, MethodCall,\n     Mutability, Path, PathSegment, Stmt, StructRest, UnOp, UseTree, UseTreeKind, DUMMY_NODE_ID,\n };\n use rustc_ast_pretty::pprust;\n@@ -181,11 +181,11 @@ impl<'cx, 'a> Context<'cx, 'a> {\n             self.span,\n             ExprKind::MacCall(P(MacCall {\n                 path: panic_path,\n-                args: P(MacArgs::Delimited(\n-                    DelimSpan::from_single(self.span),\n-                    MacDelimiter::Parenthesis,\n-                    initial.into_iter().chain(captures).collect::<TokenStream>(),\n-                )),\n+                args: P(DelimArgs {\n+                    dspan: DelimSpan::from_single(self.span),\n+                    delim: MacDelimiter::Parenthesis,\n+                    tokens: initial.into_iter().chain(captures).collect::<TokenStream>(),\n+                }),\n                 prior_type_ascription: None,\n             })),\n         )"}, {"sha": "cae648cd11aff98dd8275acddb908459ff14c4a5", "filename": "compiler/rustc_builtin_macros/src/edition_panic.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0f7d81754db66d46ee9aa033735a1ee5c1daa44d/compiler%2Frustc_builtin_macros%2Fsrc%2Fedition_panic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f7d81754db66d46ee9aa033735a1ee5c1daa44d/compiler%2Frustc_builtin_macros%2Fsrc%2Fedition_panic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fedition_panic.rs?ref=0f7d81754db66d46ee9aa033735a1ee5c1daa44d", "patch": "@@ -58,11 +58,11 @@ fn expand<'cx>(\n                         .collect(),\n                     tokens: None,\n                 },\n-                args: P(MacArgs::Delimited(\n-                    DelimSpan::from_single(sp),\n-                    MacDelimiter::Parenthesis,\n-                    tts,\n-                )),\n+                args: P(DelimArgs {\n+                    dspan: DelimSpan::from_single(sp),\n+                    delim: MacDelimiter::Parenthesis,\n+                    tokens: tts,\n+                }),\n                 prior_type_ascription: None,\n             })),\n         ),"}, {"sha": "bdcd53349492ccb98945ee4a41a8fe5c39e8adda", "filename": "compiler/rustc_expand/src/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f7d81754db66d46ee9aa033735a1ee5c1daa44d/compiler%2Frustc_expand%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f7d81754db66d46ee9aa033735a1ee5c1daa44d/compiler%2Frustc_expand%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fbase.rs?ref=0f7d81754db66d46ee9aa033735a1ee5c1daa44d", "patch": "@@ -507,7 +507,7 @@ impl MacResult for MacEager {\n             return Some(p);\n         }\n         if let Some(e) = self.expr {\n-            if let ast::ExprKind::Lit(_) = e.kind {\n+            if matches!(e.kind, ast::ExprKind::Lit(_) | ast::ExprKind::IncludedBytes(_)) {\n                 return Some(P(ast::Pat {\n                     id: ast::DUMMY_NODE_ID,\n                     span: e.span,"}, {"sha": "15dcc584738fba7d4346d7c6b04f85313ab7b8e9", "filename": "compiler/rustc_expand/src/expand.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0f7d81754db66d46ee9aa033735a1ee5c1daa44d/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f7d81754db66d46ee9aa033735a1ee5c1daa44d/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs?ref=0f7d81754db66d46ee9aa033735a1ee5c1daa44d", "patch": "@@ -11,9 +11,9 @@ use rustc_ast::ptr::P;\n use rustc_ast::token::{self, Delimiter};\n use rustc_ast::tokenstream::TokenStream;\n use rustc_ast::visit::{self, AssocCtxt, Visitor};\n-use rustc_ast::{AssocItemKind, AstNodeWrapper, AttrStyle, AttrVec, ExprKind, ForeignItemKind};\n-use rustc_ast::{HasAttrs, HasNodeId};\n-use rustc_ast::{Inline, ItemKind, MacArgs, MacStmtStyle, MetaItemKind, ModKind};\n+use rustc_ast::{AssocItemKind, AstNodeWrapper, AttrArgs, AttrStyle, AttrVec, ExprKind};\n+use rustc_ast::{ForeignItemKind, HasAttrs, HasNodeId};\n+use rustc_ast::{Inline, ItemKind, MacStmtStyle, MetaItemKind, ModKind};\n use rustc_ast::{NestedMetaItem, NodeId, PatKind, StmtKind, TyKind};\n use rustc_ast_pretty::pprust;\n use rustc_data_structures::map_in_place::MapInPlace;\n@@ -654,15 +654,15 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n         ExpandResult::Ready(match invoc.kind {\n             InvocationKind::Bang { mac, .. } => match ext {\n                 SyntaxExtensionKind::Bang(expander) => {\n-                    let Ok(tok_result) = expander.expand(self.cx, span, mac.args.inner_tokens()) else {\n+                    let Ok(tok_result) = expander.expand(self.cx, span, mac.args.tokens.clone()) else {\n                         return ExpandResult::Ready(fragment_kind.dummy(span));\n                     };\n                     self.parse_ast_fragment(tok_result, fragment_kind, &mac.path, span)\n                 }\n                 SyntaxExtensionKind::LegacyBang(expander) => {\n                     let prev = self.cx.current_expansion.prior_type_ascription;\n                     self.cx.current_expansion.prior_type_ascription = mac.prior_type_ascription;\n-                    let tok_result = expander.expand(self.cx, span, mac.args.inner_tokens());\n+                    let tok_result = expander.expand(self.cx, span, mac.args.tokens.clone());\n                     let result = if let Some(result) = fragment_kind.make_from(tok_result) {\n                         result\n                     } else {\n@@ -706,7 +706,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                         _ => item.to_tokens(),\n                     };\n                     let attr_item = attr.unwrap_normal_item();\n-                    if let MacArgs::Eq(..) = attr_item.args {\n+                    if let AttrArgs::Eq(..) = attr_item.args {\n                         self.cx.span_err(span, \"key-value macro attributes are not supported\");\n                     }\n                     let inner_tokens = attr_item.args.inner_tokens();"}, {"sha": "5da410e41a7d9a69b37787f740ceef1841fee6e2", "filename": "compiler/rustc_expand/src/mbe/macro_rules.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f7d81754db66d46ee9aa033735a1ee5c1daa44d/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f7d81754db66d46ee9aa033735a1ee5c1daa44d/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs?ref=0f7d81754db66d46ee9aa033735a1ee5c1daa44d", "patch": "@@ -577,7 +577,7 @@ pub fn compile_declarative_macro(\n \n     // Parse the macro_rules! invocation\n     let (macro_rules, body) = match &def.kind {\n-        ast::ItemKind::MacroDef(def) => (def.macro_rules, def.body.inner_tokens()),\n+        ast::ItemKind::MacroDef(def) => (def.macro_rules, def.body.tokens.clone()),\n         _ => unreachable!(),\n     };\n "}, {"sha": "e49f112bf20a69a2ec01c6d29f346ae9504d3d47", "filename": "compiler/rustc_expand/src/parse/tests.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f7d81754db66d46ee9aa033735a1ee5c1daa44d/compiler%2Frustc_expand%2Fsrc%2Fparse%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f7d81754db66d46ee9aa033735a1ee5c1daa44d/compiler%2Frustc_expand%2Fsrc%2Fparse%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fparse%2Ftests.rs?ref=0f7d81754db66d46ee9aa033735a1ee5c1daa44d", "patch": "@@ -291,7 +291,7 @@ fn ttdelim_span() {\n         .unwrap();\n \n         let tts: Vec<_> = match expr.kind {\n-            ast::ExprKind::MacCall(ref mac) => mac.args.inner_tokens().into_trees().collect(),\n+            ast::ExprKind::MacCall(ref mac) => mac.args.tokens.clone().into_trees().collect(),\n             _ => panic!(\"not a macro\"),\n         };\n "}, {"sha": "03bb5c1dfe45fbe9b2bdba1317858280237a0783", "filename": "compiler/rustc_expand/src/placeholders.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0f7d81754db66d46ee9aa033735a1ee5c1daa44d/compiler%2Frustc_expand%2Fsrc%2Fplaceholders.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f7d81754db66d46ee9aa033735a1ee5c1daa44d/compiler%2Frustc_expand%2Fsrc%2Fplaceholders.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fplaceholders.rs?ref=0f7d81754db66d46ee9aa033735a1ee5c1daa44d", "patch": "@@ -16,7 +16,11 @@ pub fn placeholder(\n     fn mac_placeholder() -> P<ast::MacCall> {\n         P(ast::MacCall {\n             path: ast::Path { span: DUMMY_SP, segments: ThinVec::new(), tokens: None },\n-            args: P(ast::MacArgs::Empty),\n+            args: P(ast::DelimArgs {\n+                dspan: ast::tokenstream::DelimSpan::dummy(),\n+                delim: ast::MacDelimiter::Parenthesis,\n+                tokens: ast::tokenstream::TokenStream::new(Vec::new()),\n+            }),\n             prior_type_ascription: None,\n         })\n     }"}, {"sha": "c2dc14024655aeba39308b9efad08977356f5580", "filename": "compiler/rustc_hir_typeck/src/intrinsicck.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0f7d81754db66d46ee9aa033735a1ee5c1daa44d/compiler%2Frustc_hir_typeck%2Fsrc%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f7d81754db66d46ee9aa033735a1ee5c1daa44d/compiler%2Frustc_hir_typeck%2Fsrc%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fintrinsicck.rs?ref=0f7d81754db66d46ee9aa033735a1ee5c1daa44d", "patch": "@@ -3,7 +3,7 @@ use rustc_errors::struct_span_err;\n use rustc_hir as hir;\n use rustc_index::vec::Idx;\n use rustc_middle::ty::layout::{LayoutError, SizeSkeleton};\n-use rustc_middle::ty::{self, Ty, TyCtxt};\n+use rustc_middle::ty::{self, Ty, TyCtxt, TypeVisitable};\n use rustc_target::abi::{Pointer, VariantIdx};\n \n use super::FnCtxt;\n@@ -46,7 +46,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let from = normalize(from);\n         let to = normalize(to);\n         trace!(?from, ?to);\n-\n+        if from.has_non_region_infer() || to.has_non_region_infer() {\n+            tcx.sess.delay_span_bug(span, \"argument to transmute has inference variables\");\n+            return;\n+        }\n         // Transmutes that are only changing lifetimes are always ok.\n         if from == to {\n             return;"}, {"sha": "8c779579a4f1dc435bb306ac8c9076e0b52de349", "filename": "compiler/rustc_lint/src/builtin.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0f7d81754db66d46ee9aa033735a1ee5c1daa44d/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f7d81754db66d46ee9aa033735a1ee5c1daa44d/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs?ref=0f7d81754db66d46ee9aa033735a1ee5c1daa44d", "patch": "@@ -2030,10 +2030,10 @@ impl KeywordIdents {\n \n impl EarlyLintPass for KeywordIdents {\n     fn check_mac_def(&mut self, cx: &EarlyContext<'_>, mac_def: &ast::MacroDef) {\n-        self.check_tokens(cx, mac_def.body.inner_tokens());\n+        self.check_tokens(cx, mac_def.body.tokens.clone());\n     }\n     fn check_mac(&mut self, cx: &EarlyContext<'_>, mac: &ast::MacCall) {\n-        self.check_tokens(cx, mac.args.inner_tokens());\n+        self.check_tokens(cx, mac.args.tokens.clone());\n     }\n     fn check_ident(&mut self, cx: &EarlyContext<'_>, ident: Ident) {\n         self.check_ident_token(cx, UnderMacro(false), ident);"}, {"sha": "ba6a3aeb20935d5cbbbc2d3528c0079ac502e59c", "filename": "compiler/rustc_metadata/src/rmeta/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f7d81754db66d46ee9aa033735a1ee5c1daa44d/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f7d81754db66d46ee9aa033735a1ee5c1daa44d/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs?ref=0f7d81754db66d46ee9aa033735a1ee5c1daa44d", "patch": "@@ -400,7 +400,7 @@ define_tables! {\n     assoc_container: Table<DefIndex, ty::AssocItemContainer>,\n     // Slot is full when macro is macro_rules.\n     macro_rules: Table<DefIndex, ()>,\n-    macro_definition: Table<DefIndex, LazyValue<ast::MacArgs>>,\n+    macro_definition: Table<DefIndex, LazyValue<ast::DelimArgs>>,\n     proc_macro: Table<DefIndex, MacroKind>,\n     module_reexports: Table<DefIndex, LazyArray<ModChild>>,\n     deduced_param_attrs: Table<DefIndex, LazyArray<DeducedParamAttrs>>,"}, {"sha": "d6025248081dbcb33f724eb88acb7c1bf74647b6", "filename": "compiler/rustc_middle/src/ty/parameterized.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f7d81754db66d46ee9aa033735a1ee5c1daa44d/compiler%2Frustc_middle%2Fsrc%2Fty%2Fparameterized.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f7d81754db66d46ee9aa033735a1ee5c1daa44d/compiler%2Frustc_middle%2Fsrc%2Fty%2Fparameterized.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fparameterized.rs?ref=0f7d81754db66d46ee9aa033735a1ee5c1daa44d", "patch": "@@ -70,7 +70,7 @@ trivially_parameterized_over_tcx! {\n     ty::adjustment::CoerceUnsizedInfo,\n     ty::fast_reject::SimplifiedTypeGen<DefId>,\n     rustc_ast::Attribute,\n-    rustc_ast::MacArgs,\n+    rustc_ast::DelimArgs,\n     rustc_attr::ConstStability,\n     rustc_attr::DefaultBodyStability,\n     rustc_attr::Deprecation,"}, {"sha": "b49a01d75ed547fa6fde8ef302336fe7b844b2aa", "filename": "compiler/rustc_parse/src/lib.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0f7d81754db66d46ee9aa033735a1ee5c1daa44d/compiler%2Frustc_parse%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f7d81754db66d46ee9aa033735a1ee5c1daa44d/compiler%2Frustc_parse%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Flib.rs?ref=0f7d81754db66d46ee9aa033735a1ee5c1daa44d", "patch": "@@ -15,8 +15,7 @@ extern crate tracing;\n use rustc_ast as ast;\n use rustc_ast::token;\n use rustc_ast::tokenstream::TokenStream;\n-use rustc_ast::Attribute;\n-use rustc_ast::{AttrItem, MetaItem};\n+use rustc_ast::{AttrItem, Attribute, MetaItem};\n use rustc_ast_pretty::pprust;\n use rustc_data_structures::sync::Lrc;\n use rustc_errors::{Applicability, Diagnostic, FatalError, Level, PResult};\n@@ -257,10 +256,12 @@ pub fn parse_cfg_attr(\n     parse_sess: &ParseSess,\n ) -> Option<(MetaItem, Vec<(AttrItem, Span)>)> {\n     match attr.get_normal_item().args {\n-        ast::MacArgs::Delimited(dspan, delim, ref tts) if !tts.is_empty() => {\n+        ast::AttrArgs::Delimited(ast::DelimArgs { dspan, delim, ref tokens })\n+            if !tokens.is_empty() =>\n+        {\n             let msg = \"wrong `cfg_attr` delimiters\";\n             crate::validate_attr::check_meta_bad_delim(parse_sess, dspan, delim, msg);\n-            match parse_in(parse_sess, tts.clone(), \"`cfg_attr` input\", |p| p.parse_cfg_attr()) {\n+            match parse_in(parse_sess, tokens.clone(), \"`cfg_attr` input\", |p| p.parse_cfg_attr()) {\n                 Ok(r) => return Some(r),\n                 Err(mut e) => {\n                     e.help(&format!(\"the valid syntax is `{}`\", CFG_ATTR_GRAMMAR_HELP))"}, {"sha": "ba73fbd3e12fb724d29dc7d3e667119b94058a05", "filename": "compiler/rustc_parse/src/parser/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f7d81754db66d46ee9aa033735a1ee5c1daa44d/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f7d81754db66d46ee9aa033735a1ee5c1daa44d/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs?ref=0f7d81754db66d46ee9aa033735a1ee5c1daa44d", "patch": "@@ -1501,7 +1501,7 @@ impl<'a> Parser<'a> {\n             let lo = path.span;\n             let mac = P(MacCall {\n                 path,\n-                args: self.parse_mac_args()?,\n+                args: self.parse_delim_args()?,\n                 prior_type_ascription: self.last_type_ascription,\n             });\n             (lo.to(self.prev_token.span), ExprKind::MacCall(mac))"}, {"sha": "20b01f554f27a254c469d2e050a5cb42a079e883", "filename": "compiler/rustc_parse/src/parser/item.rs", "status": "modified", "additions": 9, "deletions": 12, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/0f7d81754db66d46ee9aa033735a1ee5c1daa44d/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f7d81754db66d46ee9aa033735a1ee5c1daa44d/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs?ref=0f7d81754db66d46ee9aa033735a1ee5c1daa44d", "patch": "@@ -13,7 +13,7 @@ use rustc_ast::{Async, Const, Defaultness, IsAuto, Mutability, Unsafe, UseTree,\n use rustc_ast::{BindingAnnotation, Block, FnDecl, FnSig, Param, SelfKind};\n use rustc_ast::{EnumDef, FieldDef, Generics, TraitRef, Ty, TyKind, Variant, VariantData};\n use rustc_ast::{FnHeader, ForeignItem, Path, PathSegment, Visibility, VisibilityKind};\n-use rustc_ast::{MacArgs, MacCall, MacDelimiter};\n+use rustc_ast::{MacCall, MacDelimiter};\n use rustc_ast_pretty::pprust;\n use rustc_errors::{struct_span_err, Applicability, IntoDiagnostic, PResult, StashKey};\n use rustc_span::edition::Edition;\n@@ -471,7 +471,7 @@ impl<'a> Parser<'a> {\n     fn parse_item_macro(&mut self, vis: &Visibility) -> PResult<'a, MacCall> {\n         let path = self.parse_path(PathStyle::Mod)?; // `foo::bar`\n         self.expect(&token::Not)?; // `!`\n-        match self.parse_mac_args() {\n+        match self.parse_delim_args() {\n             // `( .. )` or `[ .. ]` (followed by `;`), or `{ .. }`.\n             Ok(args) => {\n                 self.eat_semi_for_macro_if_needed(&args);\n@@ -1867,7 +1867,7 @@ impl<'a> Parser<'a> {\n     fn parse_item_decl_macro(&mut self, lo: Span) -> PResult<'a, ItemInfo> {\n         let ident = self.parse_ident()?;\n         let body = if self.check(&token::OpenDelim(Delimiter::Brace)) {\n-            self.parse_mac_args()? // `MacBody`\n+            self.parse_delim_args()? // `MacBody`\n         } else if self.check(&token::OpenDelim(Delimiter::Parenthesis)) {\n             let params = self.parse_token_tree(); // `MacParams`\n             let pspan = params.span();\n@@ -1880,7 +1880,7 @@ impl<'a> Parser<'a> {\n             let arrow = TokenTree::token_alone(token::FatArrow, pspan.between(bspan)); // `=>`\n             let tokens = TokenStream::new(vec![params, arrow, body]);\n             let dspan = DelimSpan::from_pair(pspan.shrink_to_lo(), bspan.shrink_to_hi());\n-            P(MacArgs::Delimited(dspan, MacDelimiter::Brace, tokens))\n+            P(DelimArgs { dspan, delim: MacDelimiter::Brace, tokens })\n         } else {\n             return self.unexpected();\n         };\n@@ -1935,7 +1935,7 @@ impl<'a> Parser<'a> {\n                 .emit();\n         }\n \n-        let body = self.parse_mac_args()?;\n+        let body = self.parse_delim_args()?;\n         self.eat_semi_for_macro_if_needed(&body);\n         self.complain_if_pub_macro(vis, true);\n \n@@ -1974,14 +1974,14 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    fn eat_semi_for_macro_if_needed(&mut self, args: &MacArgs) {\n+    fn eat_semi_for_macro_if_needed(&mut self, args: &DelimArgs) {\n         if args.need_semicolon() && !self.eat(&token::Semi) {\n             self.report_invalid_macro_expansion_item(args);\n         }\n     }\n \n-    fn report_invalid_macro_expansion_item(&self, args: &MacArgs) {\n-        let span = args.span().expect(\"undelimited macro call\");\n+    fn report_invalid_macro_expansion_item(&self, args: &DelimArgs) {\n+        let span = args.dspan.entire();\n         let mut err = self.struct_span_err(\n             span,\n             \"macros that expand to items must be delimited with braces or followed by a semicolon\",\n@@ -1990,10 +1990,7 @@ impl<'a> Parser<'a> {\n         // macros within the same crate (that we can fix), which is sad.\n         if !span.from_expansion() {\n             if self.unclosed_delims.is_empty() {\n-                let DelimSpan { open, close } = match args {\n-                    MacArgs::Empty | MacArgs::Eq(..) => unreachable!(),\n-                    MacArgs::Delimited(dspan, ..) => *dspan,\n-                };\n+                let DelimSpan { open, close } = args.dspan;\n                 err.multipart_suggestion(\n                     \"change the delimiters to curly braces\",\n                     vec![(open, \"{\".to_string()), (close, '}'.to_string())],"}, {"sha": "8878c404c58f4014500238a0353ca2abfc106f6d", "filename": "compiler/rustc_parse/src/parser/mod.rs", "status": "modified", "additions": 32, "deletions": 31, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/0f7d81754db66d46ee9aa033735a1ee5c1daa44d/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f7d81754db66d46ee9aa033735a1ee5c1daa44d/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs?ref=0f7d81754db66d46ee9aa033735a1ee5c1daa44d", "patch": "@@ -25,8 +25,8 @@ use rustc_ast::tokenstream::{TokenStream, TokenTree};\n use rustc_ast::util::case::Case;\n use rustc_ast::AttrId;\n use rustc_ast::DUMMY_NODE_ID;\n-use rustc_ast::{self as ast, AnonConst, AttrStyle, AttrVec, Const, Extern};\n-use rustc_ast::{Async, Expr, ExprKind, MacArgs, MacArgsEq, MacDelimiter, Mutability, StrLit};\n+use rustc_ast::{self as ast, AnonConst, AttrStyle, AttrVec, Const, DelimArgs, Extern};\n+use rustc_ast::{Async, AttrArgs, AttrArgsEq, Expr, ExprKind, MacDelimiter, Mutability, StrLit};\n use rustc_ast::{HasAttrs, HasTokens, Unsafe, Visibility, VisibilityKind};\n use rustc_ast_pretty::pprust;\n use rustc_data_structures::fx::FxHashMap;\n@@ -1249,39 +1249,40 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    fn parse_mac_args(&mut self) -> PResult<'a, P<MacArgs>> {\n-        self.parse_mac_args_common(true).map(P)\n+    fn parse_delim_args(&mut self) -> PResult<'a, P<DelimArgs>> {\n+        if let Some(args) = self.parse_delim_args_inner() { Ok(P(args)) } else { self.unexpected() }\n     }\n \n-    fn parse_attr_args(&mut self) -> PResult<'a, MacArgs> {\n-        self.parse_mac_args_common(false)\n+    fn parse_attr_args(&mut self) -> PResult<'a, AttrArgs> {\n+        Ok(if let Some(args) = self.parse_delim_args_inner() {\n+            AttrArgs::Delimited(args)\n+        } else {\n+            if self.eat(&token::Eq) {\n+                let eq_span = self.prev_token.span;\n+                AttrArgs::Eq(eq_span, AttrArgsEq::Ast(self.parse_expr_force_collect()?))\n+            } else {\n+                AttrArgs::Empty\n+            }\n+        })\n     }\n \n-    fn parse_mac_args_common(&mut self, delimited_only: bool) -> PResult<'a, MacArgs> {\n-        Ok(\n-            if self.check(&token::OpenDelim(Delimiter::Parenthesis))\n-                || self.check(&token::OpenDelim(Delimiter::Bracket))\n-                || self.check(&token::OpenDelim(Delimiter::Brace))\n-            {\n-                match self.parse_token_tree() {\n-                    TokenTree::Delimited(dspan, delim, tokens) =>\n-                    // We've confirmed above that there is a delimiter so unwrapping is OK.\n-                    {\n-                        MacArgs::Delimited(dspan, MacDelimiter::from_token(delim).unwrap(), tokens)\n-                    }\n-                    _ => unreachable!(),\n-                }\n-            } else if !delimited_only {\n-                if self.eat(&token::Eq) {\n-                    let eq_span = self.prev_token.span;\n-                    MacArgs::Eq(eq_span, MacArgsEq::Ast(self.parse_expr_force_collect()?))\n-                } else {\n-                    MacArgs::Empty\n-                }\n-            } else {\n-                return self.unexpected();\n-            },\n-        )\n+    fn parse_delim_args_inner(&mut self) -> Option<DelimArgs> {\n+        if self.check(&token::OpenDelim(Delimiter::Parenthesis))\n+            || self.check(&token::OpenDelim(Delimiter::Bracket))\n+            || self.check(&token::OpenDelim(Delimiter::Brace))\n+        {\n+            match self.parse_token_tree() {\n+                // We've confirmed above that there is a delimiter so unwrapping is OK.\n+                TokenTree::Delimited(dspan, delim, tokens) => Some(DelimArgs {\n+                    dspan,\n+                    delim: MacDelimiter::from_token(delim).unwrap(),\n+                    tokens,\n+                }),\n+                _ => unreachable!(),\n+            }\n+        } else {\n+            None\n+        }\n     }\n \n     fn parse_or_use_outer_attributes("}, {"sha": "bf52febb1076d3a0d9844e48cde0020cbe81643b", "filename": "compiler/rustc_parse/src/parser/pat.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f7d81754db66d46ee9aa033735a1ee5c1daa44d/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f7d81754db66d46ee9aa033735a1ee5c1daa44d/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpat.rs?ref=0f7d81754db66d46ee9aa033735a1ee5c1daa44d", "patch": "@@ -693,7 +693,7 @@ impl<'a> Parser<'a> {\n     /// Parse macro invocation\n     fn parse_pat_mac_invoc(&mut self, path: Path) -> PResult<'a, PatKind> {\n         self.bump();\n-        let args = self.parse_mac_args()?;\n+        let args = self.parse_delim_args()?;\n         let mac = P(MacCall { path, args, prior_type_ascription: self.last_type_ascription });\n         Ok(PatKind::MacCall(mac))\n     }"}, {"sha": "73de86820d852847da4e60f4b3e093da5a305947", "filename": "compiler/rustc_parse/src/parser/stmt.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0f7d81754db66d46ee9aa033735a1ee5c1daa44d/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fstmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f7d81754db66d46ee9aa033735a1ee5c1daa44d/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fstmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fstmt.rs?ref=0f7d81754db66d46ee9aa033735a1ee5c1daa44d", "patch": "@@ -167,14 +167,13 @@ impl<'a> Parser<'a> {\n     /// Parses a statement macro `mac!(args)` provided a `path` representing `mac`.\n     /// At this point, the `!` token after the path has already been eaten.\n     fn parse_stmt_mac(&mut self, lo: Span, attrs: AttrVec, path: ast::Path) -> PResult<'a, Stmt> {\n-        let args = self.parse_mac_args()?;\n-        let delim = args.delim();\n+        let args = self.parse_delim_args()?;\n+        let delim = args.delim.to_token();\n         let hi = self.prev_token.span;\n \n         let style = match delim {\n-            Some(Delimiter::Brace) => MacStmtStyle::Braces,\n-            Some(_) => MacStmtStyle::NoBraces,\n-            None => unreachable!(),\n+            Delimiter::Brace => MacStmtStyle::Braces,\n+            _ => MacStmtStyle::NoBraces,\n         };\n \n         let mac = P(MacCall { path, args, prior_type_ascription: self.last_type_ascription });"}, {"sha": "fecf67cb596edfa2e6bc047586f55c3d153f9182", "filename": "compiler/rustc_parse/src/parser/ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f7d81754db66d46ee9aa033735a1ee5c1daa44d/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f7d81754db66d46ee9aa033735a1ee5c1daa44d/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fty.rs?ref=0f7d81754db66d46ee9aa033735a1ee5c1daa44d", "patch": "@@ -665,7 +665,7 @@ impl<'a> Parser<'a> {\n             // Macro invocation in type position\n             Ok(TyKind::MacCall(P(MacCall {\n                 path,\n-                args: self.parse_mac_args()?,\n+                args: self.parse_delim_args()?,\n                 prior_type_ascription: self.last_type_ascription,\n             })))\n         } else if allow_plus == AllowPlus::Yes && self.check_plus() {"}, {"sha": "e2f95d74a3d2293c6cb7dba3e3c917798655a8ea", "filename": "compiler/rustc_parse/src/validate_attr.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/0f7d81754db66d46ee9aa033735a1ee5c1daa44d/compiler%2Frustc_parse%2Fsrc%2Fvalidate_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f7d81754db66d46ee9aa033735a1ee5c1daa44d/compiler%2Frustc_parse%2Fsrc%2Fvalidate_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fvalidate_attr.rs?ref=0f7d81754db66d46ee9aa033735a1ee5c1daa44d", "patch": "@@ -3,7 +3,8 @@\n use crate::parse_in;\n \n use rustc_ast::tokenstream::DelimSpan;\n-use rustc_ast::{self as ast, Attribute, MacArgs, MacArgsEq, MacDelimiter, MetaItem, MetaItemKind};\n+use rustc_ast::MetaItemKind;\n+use rustc_ast::{self as ast, AttrArgs, AttrArgsEq, Attribute, DelimArgs, MacDelimiter, MetaItem};\n use rustc_ast_pretty::pprust;\n use rustc_errors::{Applicability, FatalError, PResult};\n use rustc_feature::{AttributeTemplate, BuiltinAttribute, BUILTIN_ATTRIBUTE_MAP};\n@@ -24,7 +25,7 @@ pub fn check_meta(sess: &ParseSess, attr: &Attribute) {\n         Some(BuiltinAttribute { name, template, .. }) if *name != sym::rustc_dummy => {\n             check_builtin_attribute(sess, attr, *name, *template)\n         }\n-        _ if let MacArgs::Eq(..) = attr.get_normal_item().args => {\n+        _ if let AttrArgs::Eq(..) = attr.get_normal_item().args => {\n             // All key-value attributes are restricted to meta-item syntax.\n             parse_meta(sess, attr)\n                 .map_err(|mut err| {\n@@ -42,13 +43,13 @@ pub fn parse_meta<'a>(sess: &'a ParseSess, attr: &Attribute) -> PResult<'a, Meta\n         span: attr.span,\n         path: item.path.clone(),\n         kind: match &item.args {\n-            MacArgs::Empty => MetaItemKind::Word,\n-            MacArgs::Delimited(dspan, delim, t) => {\n+            AttrArgs::Empty => MetaItemKind::Word,\n+            AttrArgs::Delimited(DelimArgs { dspan, delim, tokens }) => {\n                 check_meta_bad_delim(sess, *dspan, *delim, \"wrong meta list delimiters\");\n-                let nmis = parse_in(sess, t.clone(), \"meta list\", |p| p.parse_meta_seq_top())?;\n+                let nmis = parse_in(sess, tokens.clone(), \"meta list\", |p| p.parse_meta_seq_top())?;\n                 MetaItemKind::List(nmis)\n             }\n-            MacArgs::Eq(_, MacArgsEq::Ast(expr)) => {\n+            AttrArgs::Eq(_, AttrArgsEq::Ast(expr)) => {\n                 if let ast::ExprKind::Lit(token_lit) = expr.kind\n                     && let Ok(lit) = ast::Lit::from_token_lit(token_lit, expr.span)\n                 {\n@@ -78,7 +79,7 @@ pub fn parse_meta<'a>(sess: &'a ParseSess, attr: &Attribute) -> PResult<'a, Meta\n                     return Err(err);\n                 }\n             }\n-            MacArgs::Eq(_, MacArgsEq::Hir(lit)) => MetaItemKind::NameValue(lit.clone()),\n+            AttrArgs::Eq(_, AttrArgsEq::Hir(lit)) => MetaItemKind::NameValue(lit.clone()),\n         },\n     })\n }"}, {"sha": "1ef77e06b4874901129299d4a1cc86f130b74c8f", "filename": "compiler/rustc_trait_selection/src/traits/coherence.rs", "status": "modified", "additions": 10, "deletions": 16, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/0f7d81754db66d46ee9aa033735a1ee5c1daa44d/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f7d81754db66d46ee9aa033735a1ee5c1daa44d/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs?ref=0f7d81754db66d46ee9aa033735a1ee5c1daa44d", "patch": "@@ -162,8 +162,8 @@ fn overlap_within_probe<'cx, 'tcx>(\n     let infcx = selcx.infcx();\n \n     if overlap_mode.use_negative_impl() {\n-        if negative_impl(selcx, impl1_def_id, impl2_def_id)\n-            || negative_impl(selcx, impl2_def_id, impl1_def_id)\n+        if negative_impl(infcx.tcx, impl1_def_id, impl2_def_id)\n+            || negative_impl(infcx.tcx, impl2_def_id, impl1_def_id)\n         {\n             return None;\n         }\n@@ -279,13 +279,8 @@ fn implicit_negative<'cx, 'tcx>(\n \n /// Given impl1 and impl2 check if both impls are never satisfied by a common type (including\n /// where-clauses) If so, return true, they are disjoint and false otherwise.\n-fn negative_impl<'cx, 'tcx>(\n-    selcx: &mut SelectionContext<'cx, 'tcx>,\n-    impl1_def_id: DefId,\n-    impl2_def_id: DefId,\n-) -> bool {\n+fn negative_impl<'tcx>(tcx: TyCtxt<'tcx>, impl1_def_id: DefId, impl2_def_id: DefId) -> bool {\n     debug!(\"negative_impl(impl1_def_id={:?}, impl2_def_id={:?})\", impl1_def_id, impl2_def_id);\n-    let tcx = selcx.infcx().tcx;\n \n     // Create an infcx, taking the predicates of impl1 as assumptions:\n     let infcx = tcx.infer_ctxt().build();\n@@ -332,11 +327,10 @@ fn equate<'tcx>(\n         return true;\n     };\n \n-    let selcx = &mut SelectionContext::new(&infcx);\n     let opt_failing_obligation = obligations\n         .into_iter()\n         .chain(more_obligations)\n-        .find(|o| negative_impl_exists(selcx, o, body_def_id));\n+        .find(|o| negative_impl_exists(infcx, o, body_def_id));\n \n     if let Some(failing_obligation) = opt_failing_obligation {\n         debug!(\"overlap: obligation unsatisfiable {:?}\", failing_obligation);\n@@ -347,19 +341,19 @@ fn equate<'tcx>(\n }\n \n /// Try to prove that a negative impl exist for the given obligation and its super predicates.\n-#[instrument(level = \"debug\", skip(selcx))]\n-fn negative_impl_exists<'cx, 'tcx>(\n-    selcx: &SelectionContext<'cx, 'tcx>,\n+#[instrument(level = \"debug\", skip(infcx))]\n+fn negative_impl_exists<'tcx>(\n+    infcx: &InferCtxt<'tcx>,\n     o: &PredicateObligation<'tcx>,\n     body_def_id: DefId,\n ) -> bool {\n-    if resolve_negative_obligation(selcx.infcx().fork(), o, body_def_id) {\n+    if resolve_negative_obligation(infcx.fork(), o, body_def_id) {\n         return true;\n     }\n \n     // Try to prove a negative obligation exists for super predicates\n-    for o in util::elaborate_predicates(selcx.tcx(), iter::once(o.predicate)) {\n-        if resolve_negative_obligation(selcx.infcx().fork(), &o, body_def_id) {\n+    for o in util::elaborate_predicates(infcx.tcx, iter::once(o.predicate)) {\n+        if resolve_negative_obligation(infcx.fork(), &o, body_def_id) {\n             return true;\n         }\n     }"}, {"sha": "3b107d9570f149fbe53f77aa3b8ec7c37f9d81d1", "filename": "compiler/rustc_trait_selection/src/traits/select/candidate_assembly.rs", "status": "modified", "additions": 27, "deletions": 32, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/0f7d81754db66d46ee9aa033735a1ee5c1daa44d/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f7d81754db66d46ee9aa033735a1ee5c1daa44d/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs?ref=0f7d81754db66d46ee9aa033735a1ee5c1daa44d", "patch": "@@ -8,7 +8,6 @@\n use hir::LangItem;\n use rustc_errors::DelayDm;\n use rustc_hir as hir;\n-use rustc_hir::def_id::DefId;\n use rustc_infer::traits::ObligationCause;\n use rustc_infer::traits::{Obligation, SelectionError, TraitObligation};\n use rustc_lint_defs::builtin::DEREF_INTO_DYN_SUPERTRAIT;\n@@ -707,7 +706,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         ty: Ty<'tcx>,\n         param_env: ty::ParamEnv<'tcx>,\n         cause: &ObligationCause<'tcx>,\n-    ) -> Option<(Ty<'tcx>, DefId)> {\n+    ) -> Option<ty::PolyExistentialTraitRef<'tcx>> {\n         let tcx = self.tcx();\n         if tcx.features().trait_upcasting {\n             return None;\n@@ -726,27 +725,25 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             return None;\n         }\n \n-        let ty = traits::normalize_projection_type(\n-            self,\n-            param_env,\n-            ty::ProjectionTy {\n-                item_def_id: tcx.lang_items().deref_target()?,\n-                substs: trait_ref.substs,\n-            },\n-            cause.clone(),\n-            0,\n-            // We're *intentionally* throwing these away,\n-            // since we don't actually use them.\n-            &mut vec![],\n-        )\n-        .ty()\n-        .unwrap();\n-\n-        if let ty::Dynamic(data, ..) = ty.kind() {\n-            Some((ty, data.principal_def_id()?))\n-        } else {\n-            None\n-        }\n+        self.infcx.probe(|_| {\n+            let ty = traits::normalize_projection_type(\n+                self,\n+                param_env,\n+                ty::ProjectionTy {\n+                    item_def_id: tcx.lang_items().deref_target()?,\n+                    substs: trait_ref.substs,\n+                },\n+                cause.clone(),\n+                0,\n+                // We're *intentionally* throwing these away,\n+                // since we don't actually use them.\n+                &mut vec![],\n+            )\n+            .ty()\n+            .unwrap();\n+\n+            if let ty::Dynamic(data, ..) = ty.kind() { data.principal() } else { None }\n+        })\n     }\n \n     /// Searches for unsizing that might apply to `obligation`.\n@@ -808,21 +805,19 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                         let principal_a = data_a.principal().unwrap();\n                         let target_trait_did = principal_def_id_b.unwrap();\n                         let source_trait_ref = principal_a.with_self_ty(self.tcx(), source);\n-                        if let Some((deref_output_ty, deref_output_trait_did)) = self\n-                            .need_migrate_deref_output_trait_object(\n-                                source,\n-                                obligation.param_env,\n-                                &obligation.cause,\n-                            )\n-                        {\n-                            if deref_output_trait_did == target_trait_did {\n+                        if let Some(deref_trait_ref) = self.need_migrate_deref_output_trait_object(\n+                            source,\n+                            obligation.param_env,\n+                            &obligation.cause,\n+                        ) {\n+                            if deref_trait_ref.def_id() == target_trait_did {\n                                 self.tcx().struct_span_lint_hir(\n                                     DEREF_INTO_DYN_SUPERTRAIT,\n                                     obligation.cause.body_id,\n                                     obligation.cause.span,\n                                     DelayDm(|| format!(\n                                         \"`{}` implements `Deref` with supertrait `{}` as output\",\n-                                        source, deref_output_ty\n+                                        source, deref_trait_ref\n                                     )),\n                                     |lint| lint,\n                                 );"}, {"sha": "4524fa4c48d2b8a062f1cf2d2b0cb9cdfa2da323", "filename": "library/core/src/pin.rs", "status": "modified", "additions": 55, "deletions": 2, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/0f7d81754db66d46ee9aa033735a1ee5c1daa44d/library%2Fcore%2Fsrc%2Fpin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f7d81754db66d46ee9aa033735a1ee5c1daa44d/library%2Fcore%2Fsrc%2Fpin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fpin.rs?ref=0f7d81754db66d46ee9aa033735a1ee5c1daa44d", "patch": "@@ -543,7 +543,7 @@ impl<P: Deref> Pin<P> {\n     ///         let p: Pin<&mut T> = Pin::new_unchecked(&mut a);\n     ///         // This should mean the pointee `a` can never move again.\n     ///     }\n-    ///     mem::swap(&mut a, &mut b);\n+    ///     mem::swap(&mut a, &mut b); // Potential UB down the road \u26a0\ufe0f\n     ///     // The address of `a` changed to `b`'s stack slot, so `a` got moved even\n     ///     // though we have previously pinned it! We have violated the pinning API contract.\n     /// }\n@@ -563,13 +563,66 @@ impl<P: Deref> Pin<P> {\n     ///         // This should mean the pointee can never move again.\n     ///     }\n     ///     drop(pinned);\n-    ///     let content = Rc::get_mut(&mut x).unwrap();\n+    ///     let content = Rc::get_mut(&mut x).unwrap(); // Potential UB down the road \u26a0\ufe0f\n     ///     // Now, if `x` was the only reference, we have a mutable reference to\n     ///     // data that we pinned above, which we could use to move it as we have\n     ///     // seen in the previous example. We have violated the pinning API contract.\n     ///  }\n     ///  ```\n     ///\n+    /// ## Pinning of closure captures\n+    ///\n+    /// Particular care is required when using `Pin::new_unchecked` in a closure:\n+    /// `Pin::new_unchecked(&mut var)` where `var` is a by-value (moved) closure capture\n+    /// implicitly makes the promise that the closure itself is pinned, and that *all* uses\n+    /// of this closure capture respect that pinning.\n+    /// ```\n+    /// use std::pin::Pin;\n+    /// use std::task::Context;\n+    /// use std::future::Future;\n+    ///\n+    /// fn move_pinned_closure(mut x: impl Future, cx: &mut Context<'_>) {\n+    ///     // Create a closure that moves `x`, and then internally uses it in a pinned way.\n+    ///     let mut closure = move || unsafe {\n+    ///         let _ignore = Pin::new_unchecked(&mut x).poll(cx);\n+    ///     };\n+    ///     // Call the closure, so the future can assume it has been pinned.\n+    ///     closure();\n+    ///     // Move the closure somewhere else. This also moves `x`!\n+    ///     let mut moved = closure;\n+    ///     // Calling it again means we polled the future from two different locations,\n+    ///     // violating the pinning API contract.\n+    ///     moved(); // Potential UB \u26a0\ufe0f\n+    /// }\n+    /// ```\n+    /// When passing a closure to another API, it might be moving the closure any time, so\n+    /// `Pin::new_unchecked` on closure captures may only be used if the API explicitly documents\n+    /// that the closure is pinned.\n+    ///\n+    /// The better alternative is to avoid all that trouble and do the pinning in the outer function\n+    /// instead (here using the unstable `pin` macro):\n+    /// ```\n+    /// #![feature(pin_macro)]\n+    /// use std::pin::pin;\n+    /// use std::task::Context;\n+    /// use std::future::Future;\n+    ///\n+    /// fn move_pinned_closure(mut x: impl Future, cx: &mut Context<'_>) {\n+    ///     let mut x = pin!(x);\n+    ///     // Create a closure that captures `x: Pin<&mut _>`, which is safe to move.\n+    ///     let mut closure = move || {\n+    ///         let _ignore = x.as_mut().poll(cx);\n+    ///     };\n+    ///     // Call the closure, so the future can assume it has been pinned.\n+    ///     closure();\n+    ///     // Move the closure somewhere else.\n+    ///     let mut moved = closure;\n+    ///     // Calling it again here is fine (except that we might be polling a future that already\n+    ///     // returned `Poll::Ready`, but that is a separate problem).\n+    ///     moved();\n+    /// }\n+    /// ```\n+    ///\n     /// [`mem::swap`]: crate::mem::swap\n     #[lang = \"new_unchecked\"]\n     #[inline(always)]"}, {"sha": "61b6f33bce0207119bdef3753da805e4735c0b0f", "filename": "library/test/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f7d81754db66d46ee9aa033735a1ee5c1daa44d/library%2Ftest%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/0f7d81754db66d46ee9aa033735a1ee5c1daa44d/library%2Ftest%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Ftest%2FCargo.toml?ref=0f7d81754db66d46ee9aa033735a1ee5c1daa44d", "patch": "@@ -7,7 +7,7 @@ edition = \"2021\"\n crate-type = [\"dylib\", \"rlib\"]\n \n [dependencies]\n-cfg-if = { version = \"0.1.8\", features = ['rustc-dep-of-std'] }\n+cfg-if = { version = \"1.0\", features = ['rustc-dep-of-std'] }\n getopts = { version = \"0.2.21\", features = ['rustc-dep-of-std'] }\n std = { path = \"../std\" }\n core = { path = \"../core\" }"}, {"sha": "35e2720fdff897f8bcbe66da633ad652a9996dca", "filename": "src/librustdoc/clean/utils.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f7d81754db66d46ee9aa033735a1ee5c1daa44d/src%2Flibrustdoc%2Fclean%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f7d81754db66d46ee9aa033735a1ee5c1daa44d/src%2Flibrustdoc%2Fclean%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Futils.rs?ref=0f7d81754db66d46ee9aa033735a1ee5c1daa44d", "patch": "@@ -580,7 +580,7 @@ pub(super) fn display_macro_source(\n     def_id: DefId,\n     vis: ty::Visibility<DefId>,\n ) -> String {\n-    let tts: Vec<_> = def.body.inner_tokens().into_trees().collect();\n+    let tts: Vec<_> = def.body.tokens.clone().into_trees().collect();\n     // Extract the spans of all matchers. They represent the \"interface\" of the macro.\n     let matchers = tts.chunks(4).map(|arm| &arm[0]);\n "}, {"sha": "2335f3ff1ce96a3c3026f900c5c11c5708c45a9f", "filename": "src/librustdoc/html/static/css/rustdoc.css", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/0f7d81754db66d46ee9aa033735a1ee5c1daa44d/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css", "raw_url": "https://github.com/rust-lang/rust/raw/0f7d81754db66d46ee9aa033735a1ee5c1daa44d/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css?ref=0f7d81754db66d46ee9aa033735a1ee5c1daa44d", "patch": "@@ -290,20 +290,21 @@ p:last-child {\n button {\n \t/* Buttons on Safari have different default padding than other platforms. Make them the same. */\n \tpadding: 1px 6px;\n+\t/* Opinionated tweak: use pointer cursor as clickability signifier. */\n+\tcursor: pointer;\n }\n \n+/* end tweaks for normalize.css 8 */\n+\n button#toggle-all-docs {\n \tpadding: 0;\n \tbackground: none;\n \tborder: none;\n-\tcursor: pointer;\n \t/* iOS button gradient: https://stackoverflow.com/q/5438567 */\n \t-webkit-appearance: none;\n \topacity: 1;\n }\n \n-/* end tweaks for normalize.css 8 */\n-\n .rustdoc {\n \tdisplay: flex;\n \tflex-direction: row;\n@@ -906,6 +907,13 @@ so that we can apply CSS-filters to change the arrow color in themes */\n \tbackground-color: var(--search-result-link-focus-background-color);\n }\n \n+.search-results .result-name span.alias {\n+\tcolor: var(--search-results-alias-color);\n+}\n+.search-results .result-name span.grey {\n+\tcolor: var(--search-results-grey-color);\n+}\n+\n .popover {\n \tposition: absolute;\n \tright: 0;\n@@ -1305,7 +1313,6 @@ a.test-arrow:hover {\n #titles > button {\n \ttext-align: center;\n \tfont-size: 1.125rem;\n-\tcursor: pointer;\n \tborder: 0;\n \tborder-top: 2px solid;\n \tflex: 1;\n@@ -1345,7 +1352,6 @@ a.test-arrow:hover {\n \tfont-weight: bold;\n \tbackground: none;\n \tcolor: inherit;\n-\tcursor: pointer;\n \ttext-align: center;\n \tborder: none;\n \toutline: none;\n@@ -1367,7 +1373,6 @@ a.test-arrow:hover {\n \n #settings-menu > a, #help-button > a, #copy-path {\n \twidth: 33px;\n-\tcursor: pointer;\n \tline-height: 1.5;\n }\n \n@@ -1796,7 +1801,6 @@ in storage.js\n \t\tz-index: 10;\n \t\tborder-top-right-radius: 3px;\n \t\tborder-bottom-right-radius: 3px;\n-\t\tcursor: pointer;\n \t\tborder: 1px solid;\n \t\tborder-left: 0;\n \t}\n@@ -1967,7 +1971,6 @@ in storage.js\n \tposition: absolute;\n \ttop: 0.25em;\n \tz-index: 1;\n-\tcursor: pointer;\n \tpadding: 0;\n \tbackground: none;\n \tborder: none;"}, {"sha": "eb66377670c6bc1b8c2b3f7134a8a3e9383b0ad6", "filename": "src/librustdoc/html/static/css/themes/ayu.css", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0f7d81754db66d46ee9aa033735a1ee5c1daa44d/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Fthemes%2Fayu.css", "raw_url": "https://github.com/rust-lang/rust/raw/0f7d81754db66d46ee9aa033735a1ee5c1daa44d/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Fthemes%2Fayu.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Fthemes%2Fayu.css?ref=0f7d81754db66d46ee9aa033735a1ee5c1daa44d", "patch": "@@ -41,9 +41,11 @@ Original by Dempfi (https://github.com/dempfi/ayu)\n \t--sidebar-current-link-background-color: transparent;\n \t--search-result-link-focus-background-color: #3c3c3c;\n \t--search-result-border-color: #aaa3;\n+\t--search-color: #fff;\n+\t--search-results-alias-color: #c5c5c5;\n+\t--search-results-grey-color: #999;\n \t--stab-background-color: #314559;\n \t--stab-code-color: #e6e1cf;\n-\t--search-color: #fff;\n \t--code-highlight-kw-color: #ff7733;\n \t--code-highlight-kw-2-color: #ff7733;\n \t--code-highlight-lifetime-color: #ff7733;\n@@ -202,13 +204,6 @@ pre.rust .kw-2, pre.rust .prelude-ty {}\n \tfilter: invert(100);\n }\n \n-.search-results .result-name span.alias {\n-\tcolor: #c5c5c5;\n-}\n-.search-results .result-name span.grey {\n-\tcolor: #999;\n-}\n-\n #source-sidebar > .title {\n \tcolor: #fff;\n }"}, {"sha": "44598a6b77866b142f68498840c095064ee96eb2", "filename": "src/librustdoc/html/static/css/themes/dark.css", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0f7d81754db66d46ee9aa033735a1ee5c1daa44d/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Fthemes%2Fdark.css", "raw_url": "https://github.com/rust-lang/rust/raw/0f7d81754db66d46ee9aa033735a1ee5c1daa44d/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Fthemes%2Fdark.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Fthemes%2Fdark.css?ref=0f7d81754db66d46ee9aa033735a1ee5c1daa44d", "patch": "@@ -36,9 +36,11 @@\n \t--sidebar-current-link-background-color: #444;\n \t--search-result-link-focus-background-color: #616161;\n \t--search-result-border-color: #aaa3;\n+\t--search-color: #111;\n+\t--search-results-alias-color: #fff;\n+\t--search-results-grey-color: #ccc;\n \t--stab-background-color: #314559;\n \t--stab-code-color: #e6e1cf;\n-\t--search-color: #111;\n \t--code-highlight-kw-color: #ab8ac1;\n \t--code-highlight-kw-2-color: #769acb;\n \t--code-highlight-lifetime-color: #d97f26;\n@@ -103,13 +105,6 @@ details.rustdoc-toggle > summary::before {\n \tcolor: #888;\n }\n \n-.search-results .result-name span.alias {\n-\tcolor: #fff;\n-}\n-.search-results .result-name span.grey {\n-\tcolor: #ccc;\n-}\n-\n #source-sidebar div.files > a:hover, details.dir-entry summary:hover,\n #source-sidebar div.files > a:focus, details.dir-entry summary:focus {\n \tbackground-color: #444;"}, {"sha": "f0db14fd59f53aa82e19862ba991b2811259edf3", "filename": "src/librustdoc/html/static/css/themes/light.css", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0f7d81754db66d46ee9aa033735a1ee5c1daa44d/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Fthemes%2Flight.css", "raw_url": "https://github.com/rust-lang/rust/raw/0f7d81754db66d46ee9aa033735a1ee5c1daa44d/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Fthemes%2Flight.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Fthemes%2Flight.css?ref=0f7d81754db66d46ee9aa033735a1ee5c1daa44d", "patch": "@@ -36,9 +36,11 @@\n \t--sidebar-current-link-background-color: #fff;\n \t--search-result-link-focus-background-color: #ccc;\n \t--search-result-border-color: #aaa3;\n+\t--search-color: #000;\n+\t--search-results-alias-color: #000;\n+\t--search-results-grey-color: #999;\n \t--stab-background-color: #fff5d6;\n \t--stab-code-color: #000;\n-\t--search-color: #000;\n \t--code-highlight-kw-color: #8959a8;\n \t--code-highlight-kw-2-color: #4271ae;\n \t--code-highlight-lifetime-color: #b76514;\n@@ -96,13 +98,6 @@ body.source .example-wrap pre.rust a {\n \tcolor: #888;\n }\n \n-.search-results .result-name span.alias {\n-\tcolor: #000;\n-}\n-.search-results .result-name span.grey {\n-\tcolor: #999;\n-}\n-\n #source-sidebar div.files > a:hover, details.dir-entry summary:hover,\n #source-sidebar div.files > a:focus, details.dir-entry summary:focus {\n \tbackground-color: #E0E0E0;"}, {"sha": "b2e91cb81fba7495b9e79a1a67204f28263796c9", "filename": "src/test/rustdoc-gui/cursor.goml", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/0f7d81754db66d46ee9aa033735a1ee5c1daa44d/src%2Ftest%2Frustdoc-gui%2Fcursor.goml", "raw_url": "https://github.com/rust-lang/rust/raw/0f7d81754db66d46ee9aa033735a1ee5c1daa44d/src%2Ftest%2Frustdoc-gui%2Fcursor.goml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-gui%2Fcursor.goml?ref=0f7d81754db66d46ee9aa033735a1ee5c1daa44d", "patch": "@@ -0,0 +1,24 @@\n+// This test ensures that several clickable items actually have the pointer cursor.\n+goto: \"file://\" + |DOC_PATH| + \"/lib2/struct.Foo.html\"\n+\n+// the `[+]/[-]` button\n+assert-css: (\"#toggle-all-docs\", {\"cursor\": \"pointer\"})\n+\n+// the button next to the path header\n+assert-css: (\"#copy-path\", {\"cursor\": \"pointer\"})\n+\n+// the search tabs\n+write: (\".search-input\", \"Foo\")\n+// To be SURE that the search will be run.\n+press-key: 'Enter'\n+// Waiting for the search results to appear...\n+wait-for: \"#titles\"\n+assert-css: (\"#titles > button\", {\"cursor\": \"pointer\"})\n+\n+// mobile sidebar toggle button\n+size: (500, 700)\n+assert-css: (\".sidebar-menu-toggle\", {\"cursor\": \"pointer\"})\n+\n+// the sidebar toggle button on the source code pages\n+goto: \"file://\" + |DOC_PATH| + \"/src/lib2/lib.rs.html\"\n+assert-css: (\"#sidebar-toggle > button\", {\"cursor\": \"pointer\"})"}, {"sha": "dde43b1c980af213c641f351bdcb5cdf76481493", "filename": "src/test/rustdoc-gui/search-result-color.goml", "status": "modified", "additions": 36, "deletions": 17, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/0f7d81754db66d46ee9aa033735a1ee5c1daa44d/src%2Ftest%2Frustdoc-gui%2Fsearch-result-color.goml", "raw_url": "https://github.com/rust-lang/rust/raw/0f7d81754db66d46ee9aa033735a1ee5c1daa44d/src%2Ftest%2Frustdoc-gui%2Fsearch-result-color.goml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-gui%2Fsearch-result-color.goml?ref=0f7d81754db66d46ee9aa033735a1ee5c1daa44d", "patch": "@@ -366,23 +366,42 @@ assert-css: (\n     {\"color\": \"rgb(0, 0, 0)\", \"background-color\": \"rgba(0, 0, 0, 0)\"},\n )\n \n-// Check the alias more specifically in the dark theme.\n+// Check the alias.\n goto: \"file://\" + |DOC_PATH| + \"/test_docs/index.html\"\n-// We set the theme so we're sure that the correct values will be used, whatever the computer\n-// this test is running on.\n-local-storage: {\n-    \"rustdoc-theme\": \"dark\",\n-    \"rustdoc-use-system-theme\": \"false\",\n-}\n // If the text isn't displayed, the browser doesn't compute color style correctly...\n show-text: true\n-// We reload the page so the local storage settings are being used.\n-reload:\n-write: (\".search-input\", \"thisisanalias\")\n-// To be SURE that the search will be run.\n-press-key: 'Enter'\n-// Waiting for the search results to appear...\n-wait-for: \"#titles\"\n-// Checking that the colors for the alias element are the ones expected.\n-assert-css: (\".result-name > .alias\", {\"color\": \"rgb(255, 255, 255)\"})\n-assert-css: (\".result-name > .alias > .grey\", {\"color\": \"rgb(204, 204, 204)\"})\n+\n+define-function: (\n+    \"check-alias\",\n+    (theme, alias, grey),\n+    [\n+        (\"local-storage\", {\"rustdoc-theme\": |theme|, \"rustdoc-use-system-theme\": \"false\"}),\n+        (\"reload\"),\n+        (\"write\", (\".search-input\", \"thisisanalias\")),\n+        // To be SURE that the search will be run.\n+        (\"press-key\", 'Enter'),\n+        // Waiting for the search results to appear...\n+        (\"wait-for\", \"#titles\"),\n+        // Checking that the colors for the alias element are the ones expected.\n+        (\"assert-css\", (\".result-name > .alias\", {\"color\": |alias|})),\n+        (\"assert-css\", (\".result-name > .alias > .grey\", {\"color\": |grey|})),\n+        // Leave the search results to prevent reloading with an already filled search input.\n+        (\"press-key\", \"Escape\"),\n+    ],\n+)\n+\n+call-function: (\"check-alias\", {\n+    \"theme\": \"ayu\",\n+    \"alias\": \"rgb(197, 197, 197)\",\n+    \"grey\": \"rgb(153, 153, 153)\",\n+})\n+call-function: (\"check-alias\", {\n+    \"theme\": \"dark\",\n+    \"alias\": \"rgb(255, 255, 255)\",\n+    \"grey\": \"rgb(204, 204, 204)\",\n+})\n+call-function: (\"check-alias\", {\n+    \"theme\": \"light\",\n+    \"alias\": \"rgb(0, 0, 0)\",\n+    \"grey\": \"rgb(153, 153, 153)\",\n+})"}, {"sha": "2a8a1eaa6d3a3054ad5c5494ed28039a3d7a91ad", "filename": "src/test/ui/associated-consts/issue-58022.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/0f7d81754db66d46ee9aa033735a1ee5c1daa44d/src%2Ftest%2Fui%2Fassociated-consts%2Fissue-58022.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f7d81754db66d46ee9aa033735a1ee5c1daa44d/src%2Ftest%2Fui%2Fassociated-consts%2Fissue-58022.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-consts%2Fissue-58022.rs?ref=0f7d81754db66d46ee9aa033735a1ee5c1daa44d", "previous_filename": "src/test/ui/issues/issue-58022.rs"}, {"sha": "56d85c066a8d8cc822046f05befab39572192e04", "filename": "src/test/ui/associated-consts/issue-58022.stderr", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/0f7d81754db66d46ee9aa033735a1ee5c1daa44d/src%2Ftest%2Fui%2Fassociated-consts%2Fissue-58022.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0f7d81754db66d46ee9aa033735a1ee5c1daa44d/src%2Ftest%2Fui%2Fassociated-consts%2Fissue-58022.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-consts%2Fissue-58022.stderr?ref=0f7d81754db66d46ee9aa033735a1ee5c1daa44d", "previous_filename": "src/test/ui/issues/issue-58022.stderr"}, {"sha": "01fd1c48cf803aec17d14a15309095b848f93ff6", "filename": "src/test/ui/consts/issue-104609.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0f7d81754db66d46ee9aa033735a1ee5c1daa44d/src%2Ftest%2Fui%2Fconsts%2Fissue-104609.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f7d81754db66d46ee9aa033735a1ee5c1daa44d/src%2Ftest%2Fui%2Fconsts%2Fissue-104609.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fissue-104609.rs?ref=0f7d81754db66d46ee9aa033735a1ee5c1daa44d", "patch": "@@ -0,0 +1,10 @@\n+fn foo() {\n+    oops;\n+    //~^ ERROR: cannot find value `oops` in this scope\n+}\n+\n+unsafe fn bar() {\n+    std::mem::transmute::<_, *mut _>(1_u8);\n+}\n+\n+fn main() {}"}, {"sha": "00360c44d610bcc757c748bf1bf405d0ceea8be8", "filename": "src/test/ui/consts/issue-104609.stderr", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0f7d81754db66d46ee9aa033735a1ee5c1daa44d/src%2Ftest%2Fui%2Fconsts%2Fissue-104609.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0f7d81754db66d46ee9aa033735a1ee5c1daa44d/src%2Ftest%2Fui%2Fconsts%2Fissue-104609.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fissue-104609.stderr?ref=0f7d81754db66d46ee9aa033735a1ee5c1daa44d", "patch": "@@ -0,0 +1,9 @@\n+error[E0425]: cannot find value `oops` in this scope\n+  --> $DIR/issue-104609.rs:2:5\n+   |\n+LL |     oops;\n+   |     ^^^^ not found in this scope\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0425`."}, {"sha": "9b27133b4936de5bc2bc5ddb81273d6173faf3b6", "filename": "src/test/ui/dyn-star/dyn-async-trait.rs", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/0f7d81754db66d46ee9aa033735a1ee5c1daa44d/src%2Ftest%2Fui%2Fdyn-star%2Fdyn-async-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f7d81754db66d46ee9aa033735a1ee5c1daa44d/src%2Ftest%2Fui%2Fdyn-star%2Fdyn-async-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdyn-star%2Fdyn-async-trait.rs?ref=0f7d81754db66d46ee9aa033735a1ee5c1daa44d", "patch": "@@ -0,0 +1,36 @@\n+// check-pass\n+// edition: 2021\n+\n+// This test case is meant to demonstrate how close we can get to async\n+// functions in dyn traits with the current level of dyn* support.\n+\n+#![feature(dyn_star)]\n+#![allow(incomplete_features)]\n+\n+use std::future::Future;\n+\n+trait DynAsyncCounter {\n+    fn increment<'a>(&'a mut self) -> dyn* Future<Output = usize> + 'a;\n+}\n+\n+struct MyCounter {\n+    count: usize,\n+}\n+\n+impl DynAsyncCounter for MyCounter {\n+    fn increment<'a>(&'a mut self) -> dyn* Future<Output = usize> + 'a {\n+        Box::pin(async {\n+            self.count += 1;\n+            self.count\n+        })\n+    }\n+}\n+\n+async fn do_counter(counter: &mut dyn DynAsyncCounter) -> usize {\n+    counter.increment().await\n+}\n+\n+fn main() {\n+    let mut counter = MyCounter { count: 0 };\n+    let _ = do_counter(&mut counter);\n+}"}, {"sha": "c970163fcab2c65281b2f4bfbff92c28b87b1260", "filename": "src/test/ui/impl-trait/issue-35668.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/0f7d81754db66d46ee9aa033735a1ee5c1daa44d/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-35668.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f7d81754db66d46ee9aa033735a1ee5c1daa44d/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-35668.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-35668.rs?ref=0f7d81754db66d46ee9aa033735a1ee5c1daa44d", "previous_filename": "src/test/ui/issues/issue-35668.rs"}, {"sha": "84add5799abaea44f3b2725cbdd720aa1d41ab4a", "filename": "src/test/ui/impl-trait/issue-35668.stderr", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/0f7d81754db66d46ee9aa033735a1ee5c1daa44d/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-35668.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0f7d81754db66d46ee9aa033735a1ee5c1daa44d/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-35668.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-35668.stderr?ref=0f7d81754db66d46ee9aa033735a1ee5c1daa44d", "previous_filename": "src/test/ui/issues/issue-35668.stderr"}, {"sha": "c8c172f0e2f7f419f0e1d40c9b5a9cdc3174fe9f", "filename": "src/test/ui/impl-trait/issue-49556.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/0f7d81754db66d46ee9aa033735a1ee5c1daa44d/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-49556.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f7d81754db66d46ee9aa033735a1ee5c1daa44d/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-49556.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-49556.rs?ref=0f7d81754db66d46ee9aa033735a1ee5c1daa44d", "previous_filename": "src/test/ui/issues/issue-49556.rs"}, {"sha": "11629690ecc5e27ac51880a80e699b529ab2a68e", "filename": "src/test/ui/nll/issue-57843.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/0f7d81754db66d46ee9aa033735a1ee5c1daa44d/src%2Ftest%2Fui%2Fnll%2Fissue-57843.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f7d81754db66d46ee9aa033735a1ee5c1daa44d/src%2Ftest%2Fui%2Fnll%2Fissue-57843.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fissue-57843.rs?ref=0f7d81754db66d46ee9aa033735a1ee5c1daa44d", "previous_filename": "src/test/ui/issues/issue-57843.rs"}, {"sha": "2ab49ec61cf597ef187b72d897312e9ffd112962", "filename": "src/test/ui/nll/issue-57843.stderr", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/0f7d81754db66d46ee9aa033735a1ee5c1daa44d/src%2Ftest%2Fui%2Fnll%2Fissue-57843.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0f7d81754db66d46ee9aa033735a1ee5c1daa44d/src%2Ftest%2Fui%2Fnll%2Fissue-57843.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fissue-57843.stderr?ref=0f7d81754db66d46ee9aa033735a1ee5c1daa44d", "previous_filename": "src/test/ui/issues/issue-57843.stderr"}, {"sha": "710039d79e77b2cd741664fdecb5f305e1443c41", "filename": "src/test/ui/privacy/issue-75906.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/0f7d81754db66d46ee9aa033735a1ee5c1daa44d/src%2Ftest%2Fui%2Fprivacy%2Fissue-75906.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f7d81754db66d46ee9aa033735a1ee5c1daa44d/src%2Ftest%2Fui%2Fprivacy%2Fissue-75906.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprivacy%2Fissue-75906.rs?ref=0f7d81754db66d46ee9aa033735a1ee5c1daa44d", "previous_filename": "src/test/ui/issues/issue-75906.rs"}, {"sha": "4c6a68646adc8b79f88d589220e2e9175acbacb5", "filename": "src/test/ui/privacy/issue-75906.stderr", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/0f7d81754db66d46ee9aa033735a1ee5c1daa44d/src%2Ftest%2Fui%2Fprivacy%2Fissue-75906.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0f7d81754db66d46ee9aa033735a1ee5c1daa44d/src%2Ftest%2Fui%2Fprivacy%2Fissue-75906.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprivacy%2Fissue-75906.stderr?ref=0f7d81754db66d46ee9aa033735a1ee5c1daa44d", "previous_filename": "src/test/ui/issues/issue-75906.stderr"}, {"sha": "901b3a951023c3505bbc3d3a952b9cb045765b83", "filename": "src/test/ui/proc-macro/expand-expr.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0f7d81754db66d46ee9aa033735a1ee5c1daa44d/src%2Ftest%2Fui%2Fproc-macro%2Fexpand-expr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f7d81754db66d46ee9aa033735a1ee5c1daa44d/src%2Ftest%2Fui%2Fproc-macro%2Fexpand-expr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fexpand-expr.rs?ref=0f7d81754db66d46ee9aa033735a1ee5c1daa44d", "patch": "@@ -123,4 +123,10 @@ expand_expr_fail!(echo_pm!(arbitrary_expression() + \"etc\"));\n \n const _: u32 = recursive_expand!(); //~ ERROR: recursion limit reached while expanding `recursive_expand!`\n \n-fn main() {}\n+fn main() {\n+    // https://github.com/rust-lang/rust/issues/104414\n+    match b\"Included file contents\\n\" {\n+        include_bytes!(\"auxiliary/included-file.txt\") => (),\n+        _ => panic!(\"include_bytes! in pattern\"),\n+    }\n+}"}, {"sha": "b52343adaee7108d37023ed50299abc5ab7a37ca", "filename": "src/test/ui/resolve/issue-60057.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/0f7d81754db66d46ee9aa033735a1ee5c1daa44d/src%2Ftest%2Fui%2Fresolve%2Fissue-60057.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f7d81754db66d46ee9aa033735a1ee5c1daa44d/src%2Ftest%2Fui%2Fresolve%2Fissue-60057.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fissue-60057.rs?ref=0f7d81754db66d46ee9aa033735a1ee5c1daa44d", "previous_filename": "src/test/ui/issues/issue-60057.rs"}, {"sha": "4d915fcd9fe3d0c7f09f04866e6f5ab0c3b98fee", "filename": "src/test/ui/resolve/issue-60057.stderr", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/0f7d81754db66d46ee9aa033735a1ee5c1daa44d/src%2Ftest%2Fui%2Fresolve%2Fissue-60057.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0f7d81754db66d46ee9aa033735a1ee5c1daa44d/src%2Ftest%2Fui%2Fresolve%2Fissue-60057.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fissue-60057.stderr?ref=0f7d81754db66d46ee9aa033735a1ee5c1daa44d", "previous_filename": "src/test/ui/issues/issue-60057.stderr"}, {"sha": "5f5a2574bab037739a29210a52a926a4bbcafb57", "filename": "src/test/ui/traits/trait-upcasting/migrate-lint-deny.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f7d81754db66d46ee9aa033735a1ee5c1daa44d/src%2Ftest%2Fui%2Ftraits%2Ftrait-upcasting%2Fmigrate-lint-deny.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f7d81754db66d46ee9aa033735a1ee5c1daa44d/src%2Ftest%2Fui%2Ftraits%2Ftrait-upcasting%2Fmigrate-lint-deny.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Ftrait-upcasting%2Fmigrate-lint-deny.rs?ref=0f7d81754db66d46ee9aa033735a1ee5c1daa44d", "patch": "@@ -18,7 +18,7 @@ fn take_a(_: &dyn A) {}\n \n fn whoops(b: &dyn B) {\n     take_a(b)\n-    //~^ ERROR `dyn B` implements `Deref` with supertrait `(dyn A + 'static)` as output\n+    //~^ ERROR `dyn B` implements `Deref` with supertrait `A` as output\n     //~^^ WARN this was previously accepted by the compiler but is being phased out;\n }\n "}, {"sha": "41381a3ffd1c607b53d5cba4c6fb82853ecb0cd6", "filename": "src/test/ui/traits/trait-upcasting/migrate-lint-deny.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f7d81754db66d46ee9aa033735a1ee5c1daa44d/src%2Ftest%2Fui%2Ftraits%2Ftrait-upcasting%2Fmigrate-lint-deny.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0f7d81754db66d46ee9aa033735a1ee5c1daa44d/src%2Ftest%2Fui%2Ftraits%2Ftrait-upcasting%2Fmigrate-lint-deny.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Ftrait-upcasting%2Fmigrate-lint-deny.stderr?ref=0f7d81754db66d46ee9aa033735a1ee5c1daa44d", "patch": "@@ -1,4 +1,4 @@\n-error: `dyn B` implements `Deref` with supertrait `(dyn A + 'static)` as output\n+error: `dyn B` implements `Deref` with supertrait `A` as output\n   --> $DIR/migrate-lint-deny.rs:20:12\n    |\n LL |     take_a(b)"}, {"sha": "c77e364c3b83c8dde428f06489a042919788dba5", "filename": "src/test/ui/typeof/issue-29184.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/0f7d81754db66d46ee9aa033735a1ee5c1daa44d/src%2Ftest%2Fui%2Ftypeof%2Fissue-29184.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f7d81754db66d46ee9aa033735a1ee5c1daa44d/src%2Ftest%2Fui%2Ftypeof%2Fissue-29184.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftypeof%2Fissue-29184.rs?ref=0f7d81754db66d46ee9aa033735a1ee5c1daa44d", "previous_filename": "src/test/ui/issues/issue-29184.rs"}, {"sha": "75b6c64f2ced3f281ef36abf999697b8f5d1212a", "filename": "src/test/ui/typeof/issue-29184.stderr", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/0f7d81754db66d46ee9aa033735a1ee5c1daa44d/src%2Ftest%2Fui%2Ftypeof%2Fissue-29184.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0f7d81754db66d46ee9aa033735a1ee5c1daa44d/src%2Ftest%2Fui%2Ftypeof%2Fissue-29184.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftypeof%2Fissue-29184.stderr?ref=0f7d81754db66d46ee9aa033735a1ee5c1daa44d", "previous_filename": "src/test/ui/issues/issue-29184.stderr"}, {"sha": "1740b238343c83b5513be22015172785c98685f4", "filename": "src/test/ui/typeof/issue-42060.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/0f7d81754db66d46ee9aa033735a1ee5c1daa44d/src%2Ftest%2Fui%2Ftypeof%2Fissue-42060.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f7d81754db66d46ee9aa033735a1ee5c1daa44d/src%2Ftest%2Fui%2Ftypeof%2Fissue-42060.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftypeof%2Fissue-42060.rs?ref=0f7d81754db66d46ee9aa033735a1ee5c1daa44d", "previous_filename": "src/test/ui/issues/issue-42060.rs"}, {"sha": "effcbe4d7f3e868121aaf41d2f2f0a262e267727", "filename": "src/test/ui/typeof/issue-42060.stderr", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/0f7d81754db66d46ee9aa033735a1ee5c1daa44d/src%2Ftest%2Fui%2Ftypeof%2Fissue-42060.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0f7d81754db66d46ee9aa033735a1ee5c1daa44d/src%2Ftest%2Fui%2Ftypeof%2Fissue-42060.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftypeof%2Fissue-42060.stderr?ref=0f7d81754db66d46ee9aa033735a1ee5c1daa44d", "previous_filename": "src/test/ui/issues/issue-42060.stderr"}, {"sha": "b2fe0386f945dd82f8531f7643a6e5c06869f75f", "filename": "src/tools/clippy/clippy_lints/src/crate_in_macro_def.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f7d81754db66d46ee9aa033735a1ee5c1daa44d/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcrate_in_macro_def.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f7d81754db66d46ee9aa033735a1ee5c1daa44d/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcrate_in_macro_def.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcrate_in_macro_def.rs?ref=0f7d81754db66d46ee9aa033735a1ee5c1daa44d", "patch": "@@ -55,7 +55,7 @@ impl EarlyLintPass for CrateInMacroDef {\n         if_chain! {\n             if item.attrs.iter().any(is_macro_export);\n             if let ItemKind::MacroDef(macro_def) = &item.kind;\n-            let tts = macro_def.body.inner_tokens();\n+            let tts = macro_def.body.tokens.clone();\n             if let Some(span) = contains_unhygienic_crate_reference(&tts);\n             then {\n                 span_lint_and_sugg("}, {"sha": "87b378bfd1982517ad2d9e53b600c71ff1e5ff14", "filename": "src/tools/clippy/clippy_utils/src/ast_utils.rs", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/0f7d81754db66d46ee9aa033735a1ee5c1daa44d/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fast_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f7d81754db66d46ee9aa033735a1ee5c1daa44d/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fast_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fast_utils.rs?ref=0f7d81754db66d46ee9aa033735a1ee5c1daa44d", "patch": "@@ -388,7 +388,7 @@ pub fn eq_item_kind(l: &ItemKind, r: &ItemKind) -> bool {\n                 && over(li, ri, |l, r| eq_item(l, r, eq_assoc_item_kind))\n         },\n         (MacCall(l), MacCall(r)) => eq_mac_call(l, r),\n-        (MacroDef(l), MacroDef(r)) => l.macro_rules == r.macro_rules && eq_mac_args(&l.body, &r.body),\n+        (MacroDef(l), MacroDef(r)) => l.macro_rules == r.macro_rules && eq_delim_args(&l.body, &r.body),\n         _ => false,\n     }\n }\n@@ -709,26 +709,30 @@ pub fn eq_assoc_constraint(l: &AssocConstraint, r: &AssocConstraint) -> bool {\n }\n \n pub fn eq_mac_call(l: &MacCall, r: &MacCall) -> bool {\n-    eq_path(&l.path, &r.path) && eq_mac_args(&l.args, &r.args)\n+    eq_path(&l.path, &r.path) && eq_delim_args(&l.args, &r.args)\n }\n \n pub fn eq_attr(l: &Attribute, r: &Attribute) -> bool {\n     use AttrKind::*;\n     l.style == r.style\n         && match (&l.kind, &r.kind) {\n             (DocComment(l1, l2), DocComment(r1, r2)) => l1 == r1 && l2 == r2,\n-            (Normal(l), Normal(r)) => eq_path(&l.item.path, &r.item.path) && eq_mac_args(&l.item.args, &r.item.args),\n+            (Normal(l), Normal(r)) => eq_path(&l.item.path, &r.item.path) && eq_attr_args(&l.item.args, &r.item.args),\n             _ => false,\n         }\n }\n \n-pub fn eq_mac_args(l: &MacArgs, r: &MacArgs) -> bool {\n-    use MacArgs::*;\n+pub fn eq_attr_args(l: &AttrArgs, r: &AttrArgs) -> bool {\n+    use AttrArgs::*;\n     match (l, r) {\n         (Empty, Empty) => true,\n-        (Delimited(_, ld, lts), Delimited(_, rd, rts)) => ld == rd && lts.eq_unspanned(rts),\n-        (Eq(_, MacArgsEq::Ast(le)), Eq(_, MacArgsEq::Ast(re))) => eq_expr(le, re),\n-        (Eq(_, MacArgsEq::Hir(ll)), Eq(_, MacArgsEq::Hir(rl))) => ll.kind == rl.kind,\n+        (Delimited(la), Delimited(ra)) => eq_delim_args(la, ra),\n+        (Eq(_, AttrArgsEq::Ast(le)), Eq(_, AttrArgsEq::Ast(re))) => eq_expr(le, re),\n+        (Eq(_, AttrArgsEq::Hir(ll)), Eq(_, AttrArgsEq::Hir(rl))) => ll.kind == rl.kind,\n         _ => false,\n     }\n }\n+\n+pub fn eq_delim_args(l: &DelimArgs, r: &DelimArgs) -> bool {\n+    l.delim == r.delim && l.tokens.eq_unspanned(&r.tokens)\n+}"}, {"sha": "d5611082f01030048acbfca4e587271d777a3d8a", "filename": "src/tools/rustfmt/src/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f7d81754db66d46ee9aa033735a1ee5c1daa44d/src%2Ftools%2Frustfmt%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f7d81754db66d46ee9aa033735a1ee5c1daa44d/src%2Ftools%2Frustfmt%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fsrc%2Fexpr.rs?ref=0f7d81754db66d46ee9aa033735a1ee5c1daa44d", "patch": "@@ -1341,7 +1341,7 @@ pub(crate) fn can_be_overflowed_expr(\n         }\n         ast::ExprKind::MacCall(ref mac) => {\n             match (\n-                rustc_ast::ast::MacDelimiter::from_token(mac.args.delim().unwrap()),\n+                rustc_ast::ast::MacDelimiter::from_token(mac.args.delim.to_token()),\n                 context.config.overflow_delimited_expr(),\n             ) {\n                 (Some(ast::MacDelimiter::Bracket), true)"}, {"sha": "df949388037880dfbf3dbde847b83807561b1269", "filename": "src/tools/rustfmt/src/macros.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0f7d81754db66d46ee9aa033735a1ee5c1daa44d/src%2Ftools%2Frustfmt%2Fsrc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f7d81754db66d46ee9aa033735a1ee5c1daa44d/src%2Ftools%2Frustfmt%2Fsrc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fsrc%2Fmacros.rs?ref=0f7d81754db66d46ee9aa033735a1ee5c1daa44d", "patch": "@@ -208,7 +208,7 @@ fn rewrite_macro_inner(\n         original_style\n     };\n \n-    let ts = mac.args.inner_tokens();\n+    let ts = mac.args.tokens.clone();\n     let has_comment = contains_comment(context.snippet(mac.span()));\n     if ts.is_empty() && !has_comment {\n         return match style {\n@@ -392,7 +392,7 @@ pub(crate) fn rewrite_macro_def(\n         return snippet;\n     }\n \n-    let ts = def.body.inner_tokens();\n+    let ts = def.body.tokens.clone();\n     let mut parser = MacroParser::new(ts.into_trees());\n     let parsed_def = match parser.parse() {\n         Some(def) => def,\n@@ -1087,7 +1087,7 @@ pub(crate) fn convert_try_mac(\n ) -> Option<ast::Expr> {\n     let path = &pprust::path_to_string(&mac.path);\n     if path == \"try\" || path == \"r#try\" {\n-        let ts = mac.args.inner_tokens();\n+        let ts = mac.args.tokens.clone();\n \n         Some(ast::Expr {\n             id: ast::NodeId::root(), // dummy value"}, {"sha": "01edfab36547cc615f6f0f8e2e3a7de60cc78d9d", "filename": "src/tools/rustfmt/src/parse/macros/asm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f7d81754db66d46ee9aa033735a1ee5c1daa44d/src%2Ftools%2Frustfmt%2Fsrc%2Fparse%2Fmacros%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f7d81754db66d46ee9aa033735a1ee5c1daa44d/src%2Ftools%2Frustfmt%2Fsrc%2Fparse%2Fmacros%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fsrc%2Fparse%2Fmacros%2Fasm.rs?ref=0f7d81754db66d46ee9aa033735a1ee5c1daa44d", "patch": "@@ -5,7 +5,7 @@ use crate::rewrite::RewriteContext;\n \n #[allow(dead_code)]\n pub(crate) fn parse_asm(context: &RewriteContext<'_>, mac: &ast::MacCall) -> Option<AsmArgs> {\n-    let ts = mac.args.inner_tokens();\n+    let ts = mac.args.tokens.clone();\n     let mut parser = super::build_parser(context, ts);\n     parse_asm_args(&mut parser, context.parse_sess.inner(), mac.span(), false).ok()\n }"}, {"sha": "ace1a76b3fe7d12babfb0530b105279e7b81abe2", "filename": "src/tools/rustfmt/src/parse/macros/cfg_if.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f7d81754db66d46ee9aa033735a1ee5c1daa44d/src%2Ftools%2Frustfmt%2Fsrc%2Fparse%2Fmacros%2Fcfg_if.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f7d81754db66d46ee9aa033735a1ee5c1daa44d/src%2Ftools%2Frustfmt%2Fsrc%2Fparse%2Fmacros%2Fcfg_if.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fsrc%2Fparse%2Fmacros%2Fcfg_if.rs?ref=0f7d81754db66d46ee9aa033735a1ee5c1daa44d", "patch": "@@ -23,7 +23,7 @@ fn parse_cfg_if_inner<'a>(\n     sess: &'a ParseSess,\n     mac: &'a ast::MacCall,\n ) -> Result<Vec<ast::Item>, &'static str> {\n-    let ts = mac.args.inner_tokens();\n+    let ts = mac.args.tokens.clone();\n     let mut parser = build_stream_parser(sess.inner(), ts);\n \n     let mut items = vec![];"}, {"sha": "ee326e190ffa2aa312e11b5997f134b2ac5ea456", "filename": "src/tools/tidy/src/ui_tests.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f7d81754db66d46ee9aa033735a1ee5c1daa44d/src%2Ftools%2Ftidy%2Fsrc%2Fui_tests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f7d81754db66d46ee9aa033735a1ee5c1daa44d/src%2Ftools%2Ftidy%2Fsrc%2Fui_tests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Fui_tests.rs?ref=0f7d81754db66d46ee9aa033735a1ee5c1daa44d", "patch": "@@ -10,7 +10,7 @@ use std::path::Path;\n const ENTRY_LIMIT: usize = 1000;\n // FIXME: The following limits should be reduced eventually.\n const ROOT_ENTRY_LIMIT: usize = 939;\n-const ISSUES_ENTRY_LIMIT: usize = 2085;\n+const ISSUES_ENTRY_LIMIT: usize = 2070;\n \n fn check_entries(path: &Path, bad: &mut bool) {\n     for dir in Walk::new(&path.join(\"test/ui\")) {"}]}