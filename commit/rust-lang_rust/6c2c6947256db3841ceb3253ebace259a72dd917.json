{"sha": "6c2c6947256db3841ceb3253ebace259a72dd917", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZjMmM2OTQ3MjU2ZGIzODQxY2ViMzI1M2ViYWNlMjU5YTcyZGQ5MTc=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2012-10-05T17:36:21Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2012-10-06T02:06:20Z"}, "message": "Rewrite the communication-between-tasks section completely.", "tree": {"sha": "742bb26589bf5d72a9bee0e17617981c98013a38", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/742bb26589bf5d72a9bee0e17617981c98013a38"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6c2c6947256db3841ceb3253ebace259a72dd917", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6c2c6947256db3841ceb3253ebace259a72dd917", "html_url": "https://github.com/rust-lang/rust/commit/6c2c6947256db3841ceb3253ebace259a72dd917", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6c2c6947256db3841ceb3253ebace259a72dd917/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "46371e107634ba9e8947cc1c45cecd8b24328e88", "url": "https://api.github.com/repos/rust-lang/rust/commits/46371e107634ba9e8947cc1c45cecd8b24328e88", "html_url": "https://github.com/rust-lang/rust/commit/46371e107634ba9e8947cc1c45cecd8b24328e88"}], "stats": {"total": 63, "additions": 15, "deletions": 48}, "files": [{"sha": "8e0a03865533a432f90e3bd8844452173dbddcc0", "filename": "doc/rust.md", "status": "modified", "additions": 15, "deletions": 48, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/6c2c6947256db3841ceb3253ebace259a72dd917/doc%2Frust.md", "raw_url": "https://github.com/rust-lang/rust/raw/6c2c6947256db3841ceb3253ebace259a72dd917/doc%2Frust.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Frust.md?ref=6c2c6947256db3841ceb3253ebace259a72dd917", "patch": "@@ -2832,54 +2832,21 @@ exploiting.]\n \n ### Communication between tasks\n \n-With the exception of *unsafe* blocks, Rust tasks are isolated from\n-interfering with one another's memory directly. Instead of manipulating shared\n-storage, Rust tasks communicate with one another using a typed, asynchronous,\n-simplex message-passing system.\n-\n-A _port_ is a communication endpoint that can *receive* messages. Ports\n-receive messages from channels.\n-\n-A _channel_ is a communication endpoint that can *send* messages. Channels\n-send messages to ports.\n-\n-Each port is implicitly boxed and mutable; as such a port has a unique\n-per-task identity and cannot be replicated or transmitted. If a port value is\n-copied, both copies refer to the *same* port. New ports can be\n-constructed dynamically and stored in data structures.\n-\n-Each channel is bound to a port when the channel is constructed, so the\n-destination port for a channel must exist before the channel itself. A channel\n-cannot be rebound to a different port from the one it was constructed with.\n-\n-Channels are weak: a channel does not keep the port it is bound to\n-alive. Ports are owned by their allocating task and cannot be sent over\n-channels; if a task dies its ports die with it, and all channels bound to\n-those ports no longer function. Messages sent to a channel connected to a dead\n-port will be dropped.\n-\n-Channels are immutable types with meaning known to the runtime; channels can\n-be sent over channels.\n-\n-Many channels can be bound to the same port, but each channel is bound to a\n-single port. In other words, channels and ports exist in an N:1 relationship,\n-N channels to 1 port. ^[It may help to remember nautical terminology\n-when differentiating channels from ports.  Many different waterways --\n-channels -- may lead to the same port.]\n-\n-Each port and channel can carry only one type of message. The message type is\n-encoded as a parameter of the channel or port type. The message type of a\n-channel is equal to the message type of the port it is bound to. The types of\n-messages must satisfy the `send` built-in trait.\n-\n-Messages are generally sent asynchronously, with optional\n-rate-limiting on the transmit side.  Each port contains a message\n-queue and sending a message over a channel merely means inserting it\n-into the associated port's queue; message receipt is the\n-responsibility of the receiving task.\n-\n-Messages are sent on channels and received on ports using standard library\n-functions.\n+Rust tasks are isolated and generally unable to interfere with one another's memory directly,\n+except through [`unsafe` code](#unsafe-code).\n+All contact between tasks is mediated by safe forms of ownership transfer,\n+and data races on memory are prohibited by the type system.\n+\n+Inter-task communication and co-ordination facilities are provided in the standard library.\n+These include:\n+  - synchronous and asynchronous communication channels with various communication topologies\n+  - read-only and read-write shared variables with various safe mutual exclusion patterns\n+  - simple locks and semaphores\n+\n+When such facilities carry values, the values are restricted to the [`Send` type-kind](#type-kinds).\n+Restricting communication interfaces to this kind ensures that no borrowed or managed pointers move between tasks.\n+Thus access to an entire data structure can be mediated through its owning \"root\" value;\n+no further locking or copying is required to avoid data races within the substructure of such a value.\n \n \n ### Task lifecycle"}]}