{"sha": "5a2b590ec0d6f1de5e44c00adb6638c05da6a265", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVhMmI1OTBlYzBkNmYxZGU1ZTQ0YzAwYWRiNjYzOGMwNWRhNmEyNjU=", "commit": {"author": {"name": "Keith Yeung", "email": "kungfukeith11@gmail.com", "date": "2018-03-03T04:42:37Z"}, "committer": {"name": "Keith Yeung", "email": "kungfukeith11@gmail.com", "date": "2018-04-28T08:55:25Z"}, "message": "Track unused mutable variables across closures", "tree": {"sha": "3579f5ab38f1e495c3eaac3011f920732f2c05b1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3579f5ab38f1e495c3eaac3011f920732f2c05b1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5a2b590ec0d6f1de5e44c00adb6638c05da6a265", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5a2b590ec0d6f1de5e44c00adb6638c05da6a265", "html_url": "https://github.com/rust-lang/rust/commit/5a2b590ec0d6f1de5e44c00adb6638c05da6a265", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5a2b590ec0d6f1de5e44c00adb6638c05da6a265/comments", "author": {"login": "KiChjang", "id": 3248587, "node_id": "MDQ6VXNlcjMyNDg1ODc=", "avatar_url": "https://avatars.githubusercontent.com/u/3248587?v=4", "gravatar_id": "", "url": "https://api.github.com/users/KiChjang", "html_url": "https://github.com/KiChjang", "followers_url": "https://api.github.com/users/KiChjang/followers", "following_url": "https://api.github.com/users/KiChjang/following{/other_user}", "gists_url": "https://api.github.com/users/KiChjang/gists{/gist_id}", "starred_url": "https://api.github.com/users/KiChjang/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/KiChjang/subscriptions", "organizations_url": "https://api.github.com/users/KiChjang/orgs", "repos_url": "https://api.github.com/users/KiChjang/repos", "events_url": "https://api.github.com/users/KiChjang/events{/privacy}", "received_events_url": "https://api.github.com/users/KiChjang/received_events", "type": "User", "site_admin": false}, "committer": {"login": "KiChjang", "id": 3248587, "node_id": "MDQ6VXNlcjMyNDg1ODc=", "avatar_url": "https://avatars.githubusercontent.com/u/3248587?v=4", "gravatar_id": "", "url": "https://api.github.com/users/KiChjang", "html_url": "https://github.com/KiChjang", "followers_url": "https://api.github.com/users/KiChjang/followers", "following_url": "https://api.github.com/users/KiChjang/following{/other_user}", "gists_url": "https://api.github.com/users/KiChjang/gists{/gist_id}", "starred_url": "https://api.github.com/users/KiChjang/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/KiChjang/subscriptions", "organizations_url": "https://api.github.com/users/KiChjang/orgs", "repos_url": "https://api.github.com/users/KiChjang/repos", "events_url": "https://api.github.com/users/KiChjang/events{/privacy}", "received_events_url": "https://api.github.com/users/KiChjang/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3e423d05863ec7c02f6e1efebed5480a3211755e", "url": "https://api.github.com/repos/rust-lang/rust/commits/3e423d05863ec7c02f6e1efebed5480a3211755e", "html_url": "https://github.com/rust-lang/rust/commit/3e423d05863ec7c02f6e1efebed5480a3211755e"}], "stats": {"total": 238, "additions": 189, "deletions": 49}, "files": [{"sha": "437626ff5369abd40814b959d38b2cb2b8a434d6", "filename": "src/librustc/ich/impls_mir.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5a2b590ec0d6f1de5e44c00adb6638c05da6a265/src%2Flibrustc%2Fich%2Fimpls_mir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a2b590ec0d6f1de5e44c00adb6638c05da6a265/src%2Flibrustc%2Fich%2Fimpls_mir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_mir.rs?ref=5a2b590ec0d6f1de5e44c00adb6638c05da6a265", "patch": "@@ -563,6 +563,11 @@ impl<'a, 'gcx> HashStable<StableHashingContext<'a>> for mir::Literal<'gcx> {\n \n impl_stable_hash_for!(struct mir::Location { block, statement_index });\n \n+impl_stable_hash_for!(struct mir::BorrowCheckResult<'tcx> {\n+    closure_requirements,\n+    used_mut_upvars\n+});\n+\n impl_stable_hash_for!(struct mir::ClosureRegionRequirements<'tcx> {\n     num_external_vids,\n     outlives_requirements"}, {"sha": "7b6389072b7b2f91f7281b9e58c2b93f1e775575", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5a2b590ec0d6f1de5e44c00adb6638c05da6a265/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a2b590ec0d6f1de5e44c00adb6638c05da6a265/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=5a2b590ec0d6f1de5e44c00adb6638c05da6a265", "patch": "@@ -21,6 +21,7 @@ use rustc_data_structures::indexed_vec::{IndexVec, Idx};\n use rustc_data_structures::control_flow_graph::dominators::{Dominators, dominators};\n use rustc_data_structures::control_flow_graph::{GraphPredecessors, GraphSuccessors};\n use rustc_data_structures::control_flow_graph::ControlFlowGraph;\n+use rustc_data_structures::small_vec::SmallVec;\n use rustc_serialize as serialize;\n use hir::def::CtorKind;\n use hir::def_id::DefId;\n@@ -2043,6 +2044,12 @@ pub struct GeneratorLayout<'tcx> {\n     pub fields: Vec<LocalDecl<'tcx>>,\n }\n \n+#[derive(Clone, Debug, RustcEncodable, RustcDecodable)]\n+pub struct BorrowCheckResult<'gcx> {\n+    pub closure_requirements: Option<ClosureRegionRequirements<'gcx>>,\n+    pub used_mut_upvars: SmallVec<[Field; 8]>,\n+}\n+\n /// After we borrow check a closure, we are left with various\n /// requirements that we have inferred between the free regions that\n /// appear in the closure's signature or on its field types.  These"}, {"sha": "d89846a75ef51a8050c0af043e60045f2830666f", "filename": "src/librustc/ty/maps/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5a2b590ec0d6f1de5e44c00adb6638c05da6a265/src%2Flibrustc%2Fty%2Fmaps%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a2b590ec0d6f1de5e44c00adb6638c05da6a265/src%2Flibrustc%2Fty%2Fmaps%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fmod.rs?ref=5a2b590ec0d6f1de5e44c00adb6638c05da6a265", "patch": "@@ -211,7 +211,7 @@ define_maps! { <'tcx>\n \n     /// Borrow checks the function body. If this is a closure, returns\n     /// additional requirements that the closure's creator must verify.\n-    [] fn mir_borrowck: MirBorrowCheck(DefId) -> Option<mir::ClosureRegionRequirements<'tcx>>,\n+    [] fn mir_borrowck: MirBorrowCheck(DefId) -> mir::BorrowCheckResult<'tcx>,\n \n     /// Gets a complete map from all types to their inherent impls.\n     /// Not meant to be used directly outside of coherence."}, {"sha": "ea628cefd3e1c8d0b6691f274f33e545d547ec56", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 74, "deletions": 29, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/5a2b590ec0d6f1de5e44c00adb6638c05da6a265/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a2b590ec0d6f1de5e44c00adb6638c05da6a265/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=5a2b590ec0d6f1de5e44c00adb6638c05da6a265", "patch": "@@ -18,15 +18,16 @@ use rustc::infer::InferCtxt;\n use rustc::ty::{self, ParamEnv, TyCtxt};\n use rustc::ty::maps::Providers;\n use rustc::lint::builtin::UNUSED_MUT;\n-use rustc::mir::{AssertMessage, BasicBlock, BorrowKind, ClearCrossCrate, Local};\n-use rustc::mir::{Location, Place, Mir, Mutability, Operand, Projection, ProjectionElem};\n-use rustc::mir::{Rvalue, Field, Statement, StatementKind, Terminator, TerminatorKind};\n-use rustc::mir::ClosureRegionRequirements;\n+use rustc::mir::{AssertMessage, AggregateKind, BasicBlock, BorrowCheckResult, BorrowKind};\n+use rustc::mir::{ClearCrossCrate, Local, Location, Place, Mir, Mutability, Operand};\n+use rustc::mir::{Projection, ProjectionElem, Rvalue, Field, Statement, StatementKind};\n+use rustc::mir::{Terminator, TerminatorKind};\n \n use rustc_data_structures::control_flow_graph::dominators::Dominators;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::indexed_set::IdxSetBuf;\n use rustc_data_structures::indexed_vec::Idx;\n+use rustc_data_structures::small_vec::SmallVec;\n \n use std::rc::Rc;\n \n@@ -70,12 +71,15 @@ pub fn provide(providers: &mut Providers) {\n fn mir_borrowck<'a, 'tcx>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     def_id: DefId,\n-) -> Option<ClosureRegionRequirements<'tcx>> {\n+) -> BorrowCheckResult<'tcx> {\n     let input_mir = tcx.mir_validated(def_id);\n     debug!(\"run query mir_borrowck: {}\", tcx.item_path_str(def_id));\n \n     if !tcx.has_attr(def_id, \"rustc_mir_borrowck\") && !tcx.use_mir_borrowck() {\n-        return None;\n+        return BorrowCheckResult {\n+            closure_requirements: None,\n+            used_mut_upvars: SmallVec::new(),\n+        };\n     }\n \n     let opt_closure_req = tcx.infer_ctxt().enter(|infcx| {\n@@ -91,7 +95,7 @@ fn do_mir_borrowck<'a, 'gcx, 'tcx>(\n     infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n     input_mir: &Mir<'gcx>,\n     def_id: DefId,\n-) -> Option<ClosureRegionRequirements<'gcx>> {\n+) -> BorrowCheckResult<'gcx> {\n     let tcx = infcx.tcx;\n     let attributes = tcx.get_attrs(def_id);\n     let param_env = tcx.param_env(def_id);\n@@ -239,6 +243,7 @@ fn do_mir_borrowck<'a, 'gcx, 'tcx>(\n         moved_error_reported: FxHashSet(),\n         nonlexical_regioncx: opt_regioncx,\n         used_mut: FxHashSet(),\n+        used_mut_upvars: SmallVec::new(),\n         nonlexical_cause_info: None,\n         borrow_set,\n         dominators,\n@@ -254,7 +259,28 @@ fn do_mir_borrowck<'a, 'gcx, 'tcx>(\n \n     mbcx.analyze_results(&mut state); // entry point for DataflowResultsConsumer\n \n-    opt_closure_req\n+    debug!(\"mbcx.used_mut: {:?}\", mbcx.used_mut);\n+\n+    for local in mbcx.mir.mut_vars_iter().filter(|local| !mbcx.used_mut.contains(local)) {\n+        if let ClearCrossCrate::Set(ref vsi) = mbcx.mir.visibility_scope_info {\n+            let source_info = mbcx.mir.local_decls[local].source_info;\n+            let mut_span = tcx.sess.codemap().span_until_non_whitespace(source_info.span);\n+\n+            tcx.struct_span_lint_node(\n+                UNUSED_MUT,\n+                vsi[source_info.scope].lint_root,\n+                source_info.span,\n+                \"variable does not need to be mutable\"\n+            )\n+            .span_suggestion_short(mut_span, \"remove this `mut`\", \"\".to_owned())\n+            .emit();\n+        }\n+    }\n+\n+    BorrowCheckResult {\n+        closure_requirements: opt_closure_req,\n+        used_mut_upvars: mbcx.used_mut_upvars,\n+    }\n }\n \n #[allow(dead_code)]\n@@ -292,6 +318,9 @@ pub struct MirBorrowckCtxt<'cx, 'gcx: 'tcx, 'tcx: 'cx> {\n     /// This field keeps track of all the local variables that are declared mut and are mutated.\n     /// Used for the warning issued by an unused mutable local variable.\n     used_mut: FxHashSet<Local>,\n+    /// If the function we're checking is a closure, then we'll need to report back the list of\n+    /// mutable upvars that have been used. This field keeps track of them.\n+    used_mut_upvars: SmallVec<[Field; 8]>,\n     /// Non-lexical region inference context, if NLL is enabled.  This\n     /// contains the results from region inference and lets us e.g.\n     /// find out which CFG points are contained in each borrow region.\n@@ -439,22 +468,6 @@ impl<'cx, 'gcx, 'tcx> DataflowResultsConsumer<'cx, 'tcx> for MirBorrowckCtxt<'cx\n \n         self.check_activations(location, span, flow_state);\n \n-        for local in self.mir.mut_vars_iter().filter(|local| !self.used_mut.contains(local)) {\n-            if let ClearCrossCrate::Set(ref vsi) = self.mir.visibility_scope_info {\n-                let source_info = self.mir.local_decls[local].source_info;\n-                let mut_span = self.tcx.sess.codemap().span_until_non_whitespace(source_info.span);\n-\n-                self.tcx.struct_span_lint_node(\n-                    UNUSED_MUT,\n-                    vsi[source_info.scope].lint_root,\n-                    source_info.span,\n-                    \"variable does not need to be mutable\"\n-                )\n-                .span_suggestion_short(mut_span, \"remove this `mut`\", \"\".to_owned())\n-                .emit();\n-            }\n-        }\n-\n         match term.kind {\n             TerminatorKind::SwitchInt {\n                 ref discr,\n@@ -1118,9 +1131,33 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 // `NullOp::Box`?\n             }\n \n-            Rvalue::Aggregate(ref _aggregate_kind, ref operands) => for operand in operands {\n-                self.consume_operand(context, (operand, span), flow_state);\n-            },\n+            Rvalue::Aggregate(ref aggregate_kind, ref operands) => {\n+                // We need to report back the list of mutable upvars that were\n+                // moved into the closure and subsequently used by the closure,\n+                // in order to populate our used_mut set.\n+                if let AggregateKind::Closure(def_id, _) = &**aggregate_kind {\n+                    let BorrowCheckResult { used_mut_upvars, .. } = self.tcx.mir_borrowck(*def_id);\n+                    for field in used_mut_upvars {\n+                        match operands[field.index()] {\n+                            Operand::Move(Place::Local(local)) => {\n+                                self.used_mut.insert(local);\n+                            }\n+                            Operand::Move(Place::Projection(ref proj)) => {\n+                                if let Some(field) = self.is_upvar_field_projection(&proj.base) {\n+                                    self.used_mut_upvars.push(field);\n+                                }\n+                            }\n+                            Operand::Move(Place::Static(..)) |\n+                            Operand::Copy(..) |\n+                            Operand::Constant(..) => {}\n+                        }\n+                    }\n+                }\n+\n+                for operand in operands {\n+                    self.consume_operand(context, (operand, span), flow_state);\n+                }\n+            }\n         }\n     }\n \n@@ -1652,8 +1689,16 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 err.emit();\n             },\n             Reservation(WriteKind::Mutate) | Write(WriteKind::Mutate) => {\n-                if let Place::Local(local) = *place {\n-                    self.used_mut.insert(local);\n+                match place {\n+                    Place::Local(local) => {\n+                        self.used_mut.insert(*local);\n+                    }\n+                    Place::Projection(ref proj) => {\n+                        if let Some(field) = self.is_upvar_field_projection(&proj.base) {\n+                            self.used_mut_upvars.push(field);\n+                        }\n+                    }\n+                    Place::Static(..) => {}\n                 }\n                 if let Err(place_err) = self.is_mutable(place, is_local_mutation_allowed) {\n                     error_reported = true;"}, {"sha": "a811b2c147e98d392a696490f6455622e1718637", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5a2b590ec0d6f1de5e44c00adb6638c05da6a265/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a2b590ec0d6f1de5e44c00adb6638c05da6a265/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=5a2b590ec0d6f1de5e44c00adb6638c05da6a265", "patch": "@@ -1426,7 +1426,9 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n             // these extra requirements are basically like where\n             // clauses on the struct.\n             AggregateKind::Closure(def_id, substs) => {\n-                if let Some(closure_region_requirements) = tcx.mir_borrowck(*def_id) {\n+                if let Some(closure_region_requirements) =\n+                    tcx.mir_borrowck(*def_id).closure_requirements\n+                {\n                     closure_region_requirements.apply_requirements(\n                         self.infcx,\n                         self.body_id,"}, {"sha": "14d836074dca377123a891ccae19858d03dab41c", "filename": "src/test/compile-fail/lint-unused-mut-variables.rs", "status": "modified", "additions": 43, "deletions": 18, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/5a2b590ec0d6f1de5e44c00adb6638c05da6a265/src%2Ftest%2Fcompile-fail%2Flint-unused-mut-variables.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a2b590ec0d6f1de5e44c00adb6638c05da6a265/src%2Ftest%2Fcompile-fail%2Flint-unused-mut-variables.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-unused-mut-variables.rs?ref=5a2b590ec0d6f1de5e44c00adb6638c05da6a265", "patch": "@@ -8,6 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// revisions: lexical nll\n+#![cfg_attr(nll, feature(nll))]\n+\n // Exercise the unused_mut attribute in some positive and negative cases\n \n #![allow(unused_assignments)]\n@@ -18,53 +21,68 @@\n \n fn main() {\n     // negative cases\n-    let mut a = 3; //~ ERROR: variable does not need to be mutable\n-    let mut a = 2; //~ ERROR: variable does not need to be mutable\n-    let mut b = 3; //~ ERROR: variable does not need to be mutable\n-    let mut a = vec![3]; //~ ERROR: variable does not need to be mutable\n-    let (mut a, b) = (1, 2); //~ ERROR: variable does not need to be mutable\n-    let mut a; //~ ERROR: variable does not need to be mutable\n+    let mut a = 3; //[lexical]~ ERROR: variable does not need to be mutable\n+                   //[nll]~^ ERROR: variable does not need to be mutable\n+    let mut a = 2; //[lexical]~ ERROR: variable does not need to be mutable\n+                   //[nll]~^ ERROR: variable does not need to be mutable\n+    let mut b = 3; //[lexical]~ ERROR: variable does not need to be mutable\n+                   //[nll]~^ ERROR: variable does not need to be mutable\n+    let mut a = vec![3]; //[lexical]~ ERROR: variable does not need to be mutable\n+                         //[nll]~^ ERROR: variable does not need to be mutable\n+    let (mut a, b) = (1, 2); //[lexical]~ ERROR: variable does not need to be mutable\n+                             //[nll]~^ ERROR: variable does not need to be mutable\n+    let mut a; //[lexical]~ ERROR: variable does not need to be mutable\n+               //[nll]~^ ERROR: variable does not need to be mutable\n     a = 3;\n \n-    let mut b; //~ ERROR: variable does not need to be mutable\n+    let mut b; //[lexical]~ ERROR: variable does not need to be mutable\n+               //[nll]~^ ERROR: variable does not need to be mutable\n     if true {\n         b = 3;\n     } else {\n         b = 4;\n     }\n \n     match 30 {\n-        mut x => {} //~ ERROR: variable does not need to be mutable\n+        mut x => {} //[lexical]~ ERROR: variable does not need to be mutable\n+                    //[nll]~^ ERROR: variable does not need to be mutable\n     }\n     match (30, 2) {\n-      (mut x, 1) | //~ ERROR: variable does not need to be mutable\n+      (mut x, 1) | //[lexical]~ ERROR: variable does not need to be mutable\n+                   //[nll]~^ ERROR: variable does not need to be mutable\n       (mut x, 2) |\n       (mut x, 3) => {\n       }\n       _ => {}\n     }\n \n-    let x = |mut y: isize| 10; //~ ERROR: variable does not need to be mutable\n-    fn what(mut foo: isize) {} //~ ERROR: variable does not need to be mutable\n+    let x = |mut y: isize| 10; //[lexical]~ ERROR: variable does not need to be mutable\n+                               //[nll]~^ ERROR: variable does not need to be mutable\n+    fn what(mut foo: isize) {} //[lexical]~ ERROR: variable does not need to be mutable\n+                               //[nll]~^ ERROR: variable does not need to be mutable\n \n-    let mut a = &mut 5; //~ ERROR: variable does not need to be mutable\n+    let mut a = &mut 5; //[lexical]~ ERROR: variable does not need to be mutable\n+                        //[nll]~^ ERROR: variable does not need to be mutable\n     *a = 4;\n \n     let mut a = 5;\n-    let mut b = (&mut a,);\n-    *b.0 = 4; //~^ ERROR: variable does not need to be mutable\n+    let mut b = (&mut a,); //[lexical]~ ERROR: variable does not need to be mutable\n+    *b.0 = 4;              //[nll]~^ ERROR: variable does not need to be mutable\n \n-    let mut x = &mut 1; //~ ERROR: variable does not need to be mutable\n+    let mut x = &mut 1; //[lexical]~ ERROR: variable does not need to be mutable\n+                        //[nll]~^ ERROR: variable does not need to be mutable\n     let mut f = || {\n       *x += 1;\n     };\n     f();\n \n     fn mut_ref_arg(mut arg : &mut [u8]) -> &mut [u8] {\n-        &mut arg[..] //~^ ERROR: variable does not need to be mutable\n+        &mut arg[..] //[lexical]~^ ERROR: variable does not need to be mutable\n+                     //[nll]~^^ ERROR: variable does not need to be mutable\n     }\n \n-    let mut v : &mut Vec<()> = &mut vec![]; //~ ERROR: variable does not need to be mutable\n+    let mut v : &mut Vec<()> = &mut vec![]; //[lexical]~ ERROR: variable does not need to be mutable\n+                                            //[nll]~^ ERROR: variable does not need to be mutable\n     v.push(());\n \n     // positive cases\n@@ -76,6 +94,12 @@ fn main() {\n     callback(|| {\n         a.push(3);\n     });\n+    let mut a = Vec::new();\n+    callback(|| {\n+        callback(|| {\n+            a.push(3);\n+        });\n+    });\n     let (mut a, b) = (1, 2);\n     a = 34;\n \n@@ -116,5 +140,6 @@ fn foo(mut a: isize) {\n fn bar() {\n     #[allow(unused_mut)]\n     let mut a = 3;\n-    let mut b = vec![2]; //~ ERROR: variable does not need to be mutable\n+    let mut b = vec![2]; //[lexical]~ ERROR: variable does not need to be mutable\n+                         //[nll]~^ ERROR: variable does not need to be mutable\n }"}, {"sha": "7f1b6ed1701683d316d41f75254a09c5e7056080", "filename": "src/test/run-pass/borrowck/borrowck-unused-mut-locals.rs", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/5a2b590ec0d6f1de5e44c00adb6638c05da6a265/src%2Ftest%2Frun-pass%2Fborrowck%2Fborrowck-unused-mut-locals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a2b590ec0d6f1de5e44c00adb6638c05da6a265/src%2Ftest%2Frun-pass%2Fborrowck%2Fborrowck-unused-mut-locals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck%2Fborrowck-unused-mut-locals.rs?ref=5a2b590ec0d6f1de5e44c00adb6638c05da6a265", "patch": "@@ -0,0 +1,56 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(nll)]\n+#![deny(unused_mut)]\n+\n+#[derive(Debug)]\n+struct A {}\n+\n+fn init_a() -> A {\n+    A {}\n+}\n+\n+#[derive(Debug)]\n+struct B<'a> {\n+    ed: &'a mut A,\n+}\n+\n+fn init_b<'a>(ed: &'a mut A) -> B<'a> {\n+    B { ed }\n+}\n+\n+#[derive(Debug)]\n+struct C<'a> {\n+    pd: &'a mut B<'a>,\n+}\n+\n+fn init_c<'a>(pd: &'a mut B<'a>) -> C<'a> {\n+    C { pd }\n+}\n+\n+#[derive(Debug)]\n+struct D<'a> {\n+    sd: &'a mut C<'a>,\n+}\n+\n+fn init_d<'a>(sd: &'a mut C<'a>) -> D<'a> {\n+    D { sd }\n+}\n+\n+fn main() {\n+    let mut a = init_a();\n+    let mut b = init_b(&mut a);\n+    let mut c = init_c(&mut b);\n+\n+    let d = init_d(&mut c);\n+\n+    println!(\"{:?}\", d)\n+}"}]}