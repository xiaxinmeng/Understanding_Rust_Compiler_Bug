{"sha": "cb498cc40d78f8a9bce42b116abb3f4dd8d03335", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNiNDk4Y2M0MGQ3OGY4YTliY2U0MmIxMTZhYmIzZjRkZDhkMDMzMzU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-03-01T08:36:35Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-03-01T08:36:35Z"}, "message": "auto merge of #12627 : alexcrichton/rust/issue-12623, r=brson\n\nThis helps prevent the unfortunate interleavings found in #12623.", "tree": {"sha": "b05531e2ff19c094db02ec0893524a21af92507b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b05531e2ff19c094db02ec0893524a21af92507b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cb498cc40d78f8a9bce42b116abb3f4dd8d03335", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cb498cc40d78f8a9bce42b116abb3f4dd8d03335", "html_url": "https://github.com/rust-lang/rust/commit/cb498cc40d78f8a9bce42b116abb3f4dd8d03335", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cb498cc40d78f8a9bce42b116abb3f4dd8d03335/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "567201e13be53d2d0e8dc4ea769ddf7b907c1ba3", "url": "https://api.github.com/repos/rust-lang/rust/commits/567201e13be53d2d0e8dc4ea769ddf7b907c1ba3", "html_url": "https://github.com/rust-lang/rust/commit/567201e13be53d2d0e8dc4ea769ddf7b907c1ba3"}, {"sha": "0e1a860789896fd2e6331648f1268c5b2cdb3573", "url": "https://api.github.com/repos/rust-lang/rust/commits/0e1a860789896fd2e6331648f1268c5b2cdb3573", "html_url": "https://github.com/rust-lang/rust/commit/0e1a860789896fd2e6331648f1268c5b2cdb3573"}], "stats": {"total": 271, "additions": 155, "deletions": 116}, "files": [{"sha": "cd7d39e4688108797bf1ca8e7ddf15e439705e6c", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/cb498cc40d78f8a9bce42b116abb3f4dd8d03335/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb498cc40d78f8a9bce42b116abb3f4dd8d03335/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=cb498cc40d78f8a9bce42b116abb3f4dd8d03335", "patch": "@@ -930,7 +930,7 @@ pub fn build_session(sopts: @session::Options,\n                      -> Session {\n     let codemap = @codemap::CodeMap::new();\n     let diagnostic_handler =\n-        diagnostic::mk_handler();\n+        diagnostic::default_handler();\n     let span_diagnostic_handler =\n         diagnostic::mk_span_handler(diagnostic_handler, codemap);\n \n@@ -1148,7 +1148,8 @@ pub fn build_output_filenames(input: &Input,\n }\n \n pub fn early_error(msg: &str) -> ! {\n-    diagnostic::DefaultEmitter.emit(None, msg, diagnostic::Fatal);\n+    let mut emitter = diagnostic::EmitterWriter::stderr();\n+    emitter.emit(None, msg, diagnostic::Fatal);\n     fail!(diagnostic::FatalError);\n }\n "}, {"sha": "c5b4147f090c8b0388636a66f7b9a1411edaf047", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/cb498cc40d78f8a9bce42b116abb3f4dd8d03335/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb498cc40d78f8a9bce42b116abb3f4dd8d03335/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=cb498cc40d78f8a9bce42b116abb3f4dd8d03335", "patch": "@@ -384,7 +384,8 @@ pub fn monitor(f: proc()) {\n         Err(value) => {\n             // Task failed without emitting a fatal diagnostic\n             if !value.is::<diagnostic::FatalError>() {\n-                diagnostic::DefaultEmitter.emit(\n+                let mut emitter = diagnostic::EmitterWriter::stderr();\n+                emitter.emit(\n                     None,\n                     diagnostic::ice_msg(\"unexpected failure\"),\n                     diagnostic::Error);\n@@ -394,9 +395,7 @@ pub fn monitor(f: proc()) {\n                      this is a bug\",\n                 ];\n                 for note in xs.iter() {\n-                    diagnostic::DefaultEmitter.emit(None,\n-                                                    *note,\n-                                                    diagnostic::Note)\n+                    emitter.emit(None, *note, diagnostic::Note)\n                 }\n \n                 println!(\"{}\", r.read_to_str());"}, {"sha": "26650d22fe9b8fca420ee0f20239df819f2018b0", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cb498cc40d78f8a9bce42b116abb3f4dd8d03335/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb498cc40d78f8a9bce42b116abb3f4dd8d03335/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=cb498cc40d78f8a9bce42b116abb3f4dd8d03335", "patch": "@@ -58,7 +58,7 @@ fn get_ast_and_resolve(cpath: &Path,\n     };\n \n \n-    let diagnostic_handler = syntax::diagnostic::mk_handler();\n+    let diagnostic_handler = syntax::diagnostic::default_handler();\n     let span_diagnostic_handler =\n         syntax::diagnostic::mk_span_handler(diagnostic_handler, parsesess.cm);\n "}, {"sha": "8f90a39539a8780cd72a528070411259f32b17e8", "filename": "src/librustdoc/html/highlight.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cb498cc40d78f8a9bce42b116abb3f4dd8d03335/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb498cc40d78f8a9bce42b116abb3f4dd8d03335/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs?ref=cb498cc40d78f8a9bce42b116abb3f4dd8d03335", "patch": "@@ -28,7 +28,7 @@ use t = syntax::parse::token;\n /// Highlights some source code, returning the HTML output.\n pub fn highlight(src: &str) -> ~str {\n     let sess = parse::new_parse_sess();\n-    let handler = diagnostic::mk_handler();\n+    let handler = diagnostic::default_handler();\n     let span_handler = diagnostic::mk_span_handler(handler, sess.cm);\n     let fm = parse::string_to_filemap(sess, src.to_owned(), ~\"<stdin>\");\n "}, {"sha": "f97dd98e4578298622a5266722d1f3b4a14aa89e", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 31, "deletions": 4, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/cb498cc40d78f8a9bce42b116abb3f4dd8d03335/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb498cc40d78f8a9bce42b116abb3f4dd8d03335/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=cb498cc40d78f8a9bce42b116abb3f4dd8d03335", "patch": "@@ -25,6 +25,7 @@ use rustc::metadata::creader::Loader;\n use getopts;\n use syntax::diagnostic;\n use syntax::parse;\n+use syntax::codemap::CodeMap;\n \n use core;\n use clean;\n@@ -35,7 +36,6 @@ use passes;\n use visit_ast::RustdocVisitor;\n \n pub fn run(input: &str, matches: &getopts::Matches) -> int {\n-    let parsesess = parse::new_parse_sess();\n     let input_path = Path::new(input);\n     let input = driver::FileInput(input_path.clone());\n     let libs = matches.opt_strs(\"L\").map(|s| Path::new(s.as_slice()));\n@@ -49,9 +49,12 @@ pub fn run(input: &str, matches: &getopts::Matches) -> int {\n     };\n \n \n-    let diagnostic_handler = diagnostic::mk_handler();\n+    let cm = @CodeMap::new();\n+    let diagnostic_handler = diagnostic::default_handler();\n     let span_diagnostic_handler =\n-        diagnostic::mk_span_handler(diagnostic_handler, parsesess.cm);\n+        diagnostic::mk_span_handler(diagnostic_handler, cm);\n+    let parsesess = parse::new_parse_sess_special_handler(span_diagnostic_handler,\n+                                                          cm);\n \n     let sess = driver::build_session_(sessopts,\n                                       Some(input_path),\n@@ -112,7 +115,30 @@ fn runtest(test: &str, cratename: &str, libs: HashSet<Path>, should_fail: bool)\n         .. (*session::basic_options()).clone()\n     };\n \n-    let diagnostic_handler = diagnostic::mk_handler();\n+    // Shuffle around a few input and output handles here. We're going to pass\n+    // an explicit handle into rustc to collect output messages, but we also\n+    // want to catch the error message that rustc prints when it fails.\n+    //\n+    // We take our task-local stderr (likely set by the test runner), and move\n+    // it into another task. This helper task then acts as a sink for both the\n+    // stderr of this task and stderr of rustc itself, copying all the info onto\n+    // the stderr channel we originally started with.\n+    //\n+    // The basic idea is to not use a default_handler() for rustc, and then also\n+    // not print things by default to the actual stderr.\n+    let (p, c) = Chan::new();\n+    let w1 = io::ChanWriter::new(c);\n+    let w2 = w1.clone();\n+    let old = io::stdio::set_stderr(~w1);\n+    spawn(proc() {\n+        let mut p = io::PortReader::new(p);\n+        let mut err = old.unwrap_or(~io::stderr() as ~Writer);\n+        io::util::copy(&mut p, &mut err).unwrap();\n+    });\n+    let emitter = diagnostic::EmitterWriter::new(~w2);\n+\n+    // Compile the code\n+    let diagnostic_handler = diagnostic::mk_handler(~emitter);\n     let span_diagnostic_handler =\n         diagnostic::mk_span_handler(diagnostic_handler, parsesess.cm);\n \n@@ -126,6 +152,7 @@ fn runtest(test: &str, cratename: &str, libs: HashSet<Path>, should_fail: bool)\n     let cfg = driver::build_configuration(sess);\n     driver::compile_input(sess, cfg, &input, &out, &None);\n \n+    // Run the code!\n     let exe = outdir.path().join(\"rust_out\");\n     let out = Process::output(exe.as_str().unwrap(), []);\n     match out {"}, {"sha": "affeb86f782a3890d97e45305f32fe81fc11c9f7", "filename": "src/libsyntax/diagnostic.rs", "status": "modified", "additions": 109, "deletions": 101, "changes": 210, "blob_url": "https://github.com/rust-lang/rust/blob/cb498cc40d78f8a9bce42b116abb3f4dd8d03335/src%2Flibsyntax%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb498cc40d78f8a9bce42b116abb3f4dd8d03335/src%2Flibsyntax%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic.rs?ref=cb498cc40d78f8a9bce42b116abb3f4dd8d03335", "patch": "@@ -11,12 +11,10 @@\n use codemap::{Pos, Span};\n use codemap;\n \n-use std::cell::Cell;\n+use std::cell::{RefCell, Cell};\n use std::fmt;\n-use std::io::stdio::StdWriter;\n use std::io;\n use std::iter::range;\n-use std::local_data;\n use term;\n \n static BUG_REPORT_URL: &'static str =\n@@ -25,9 +23,9 @@ static BUG_REPORT_URL: &'static str =\n static MAX_LINES: uint = 6u;\n \n pub trait Emitter {\n-    fn emit(&self, cmsp: Option<(&codemap::CodeMap, Span)>,\n+    fn emit(&mut self, cmsp: Option<(&codemap::CodeMap, Span)>,\n             msg: &str, lvl: Level);\n-    fn custom_emit(&self, cm: &codemap::CodeMap,\n+    fn custom_emit(&mut self, cm: &codemap::CodeMap,\n                    sp: Span, msg: &str, lvl: Level);\n }\n \n@@ -78,16 +76,16 @@ impl SpanHandler {\n // others log errors for later reporting.\n pub struct Handler {\n     err_count: Cell<uint>,\n-    emit: DefaultEmitter,\n+    emit: RefCell<~Emitter>,\n }\n \n impl Handler {\n     pub fn fatal(&self, msg: &str) -> ! {\n-        self.emit.emit(None, msg, Fatal);\n+        self.emit.borrow_mut().get().emit(None, msg, Fatal);\n         fail!(FatalError);\n     }\n     pub fn err(&self, msg: &str) {\n-        self.emit.emit(None, msg, Error);\n+        self.emit.borrow_mut().get().emit(None, msg, Error);\n         self.bump_err_count();\n     }\n     pub fn bump_err_count(&self) {\n@@ -112,10 +110,10 @@ impl Handler {\n         self.fatal(s);\n     }\n     pub fn warn(&self, msg: &str) {\n-        self.emit.emit(None, msg, Warning);\n+        self.emit.borrow_mut().get().emit(None, msg, Warning);\n     }\n     pub fn note(&self, msg: &str) {\n-        self.emit.emit(None, msg, Note);\n+        self.emit.borrow_mut().get().emit(None, msg, Note);\n     }\n     pub fn bug(&self, msg: &str) -> ! {\n         self.fatal(ice_msg(msg));\n@@ -127,11 +125,11 @@ impl Handler {\n                 cmsp: Option<(&codemap::CodeMap, Span)>,\n                 msg: &str,\n                 lvl: Level) {\n-        self.emit.emit(cmsp, msg, lvl);\n+        self.emit.borrow_mut().get().emit(cmsp, msg, lvl);\n     }\n     pub fn custom_emit(&self, cm: &codemap::CodeMap,\n                        sp: Span, msg: &str, lvl: Level) {\n-        self.emit.custom_emit(cm, sp, msg, lvl);\n+        self.emit.borrow_mut().get().custom_emit(cm, sp, msg, lvl);\n     }\n }\n \n@@ -148,10 +146,14 @@ pub fn mk_span_handler(handler: @Handler, cm: @codemap::CodeMap)\n     }\n }\n \n-pub fn mk_handler() -> @Handler {\n+pub fn default_handler() -> @Handler {\n+    mk_handler(~EmitterWriter::stderr())\n+}\n+\n+pub fn mk_handler(e: ~Emitter) -> @Handler {\n     @Handler {\n         err_count: Cell::new(0),\n-        emit: DefaultEmitter,\n+        emit: RefCell::new(e),\n     }\n }\n \n@@ -185,73 +187,79 @@ impl Level {\n     }\n }\n \n-fn print_maybe_styled(msg: &str, color: term::attr::Attr) -> io::IoResult<()> {\n-    local_data_key!(tls_terminal: Option<term::Terminal<StdWriter>>)\n-\n-\n-    fn is_stderr_screen() -> bool {\n-        use std::libc;\n-        unsafe { libc::isatty(libc::STDERR_FILENO) != 0 }\n-    }\n-    fn write_pretty<T: Writer>(term: &mut term::Terminal<T>, s: &str,\n-                               c: term::attr::Attr) -> io::IoResult<()> {\n-        try!(term.attr(c));\n-        try!(term.write(s.as_bytes()));\n-        try!(term.reset());\n-        Ok(())\n-    }\n-\n-    if is_stderr_screen() {\n-        local_data::get_mut(tls_terminal, |term| {\n-            match term {\n-                Some(term) => {\n-                    match *term {\n-                        Some(ref mut term) => write_pretty(term, msg, color),\n-                        None => io::stderr().write(msg.as_bytes())\n-                    }\n-                }\n-                None => {\n-                    let (t, ret) = match term::Terminal::new(io::stderr()) {\n-                        Ok(mut term) => {\n-                            let r = write_pretty(&mut term, msg, color);\n-                            (Some(term), r)\n-                        }\n-                        Err(_) => {\n-                            (None, io::stderr().write(msg.as_bytes()))\n-                        }\n-                    };\n-                    local_data::set(tls_terminal, t);\n-                    ret\n-                }\n-            }\n-        })\n-    } else {\n-        io::stderr().write(msg.as_bytes())\n+fn print_maybe_styled(w: &mut EmitterWriter,\n+                      msg: &str,\n+                      color: term::attr::Attr) -> io::IoResult<()> {\n+    match w.dst {\n+        Terminal(ref mut t) => {\n+            try!(t.attr(color));\n+            try!(t.write_str(msg));\n+            try!(t.reset());\n+            Ok(())\n+        }\n+        Raw(ref mut w) => {\n+            w.write_str(msg)\n+        }\n     }\n }\n \n-fn print_diagnostic(topic: &str, lvl: Level, msg: &str) -> io::IoResult<()> {\n+fn print_diagnostic(dst: &mut EmitterWriter,\n+                    topic: &str, lvl: Level, msg: &str) -> io::IoResult<()> {\n     if !topic.is_empty() {\n-        let mut stderr = io::stderr();\n-        try!(write!(&mut stderr as &mut io::Writer, \"{} \", topic));\n+        try!(write!(&mut dst.dst, \"{} \", topic));\n     }\n \n-    try!(print_maybe_styled(format!(\"{}: \", lvl.to_str()),\n-                              term::attr::ForegroundColor(lvl.color())));\n-    try!(print_maybe_styled(format!(\"{}\\n\", msg), term::attr::Bold));\n+    try!(print_maybe_styled(dst, format!(\"{}: \", lvl.to_str()),\n+                            term::attr::ForegroundColor(lvl.color())));\n+    try!(print_maybe_styled(dst, format!(\"{}\\n\", msg), term::attr::Bold));\n     Ok(())\n }\n \n-pub struct DefaultEmitter;\n+pub struct EmitterWriter {\n+    priv dst: Destination,\n+}\n+\n+enum Destination {\n+    Terminal(term::Terminal<io::stdio::StdWriter>),\n+    Raw(~Writer),\n+}\n+\n+impl EmitterWriter {\n+    pub fn stderr() -> EmitterWriter {\n+        let stderr = io::stderr();\n+        if stderr.isatty() {\n+            let dst = match term::Terminal::new(stderr) {\n+                Ok(t) => Terminal(t),\n+                Err(..) => Raw(~io::stderr()),\n+            };\n+            EmitterWriter { dst: dst }\n+        } else {\n+            EmitterWriter { dst: Raw(~stderr) }\n+        }\n+    }\n+\n+    pub fn new(dst: ~Writer) -> EmitterWriter {\n+        EmitterWriter { dst: Raw(dst) }\n+    }\n+}\n+\n+impl Writer for Destination {\n+    fn write(&mut self, bytes: &[u8]) -> io::IoResult<()> {\n+        match *self {\n+            Terminal(ref mut t) => t.write(bytes),\n+            Raw(ref mut w) => w.write(bytes),\n+        }\n+    }\n+}\n \n-impl Emitter for DefaultEmitter {\n-    fn emit(&self,\n+impl Emitter for EmitterWriter {\n+    fn emit(&mut self,\n             cmsp: Option<(&codemap::CodeMap, Span)>,\n             msg: &str,\n             lvl: Level) {\n         let error = match cmsp {\n-            Some((cm, sp)) => emit(cm, sp, msg, lvl, false),\n-            None => print_diagnostic(\"\", lvl, msg),\n+            Some((cm, sp)) => emit(self, cm, sp, msg, lvl, false),\n+            None => print_diagnostic(self, \"\", lvl, msg),\n         };\n \n         match error {\n@@ -260,16 +268,16 @@ impl Emitter for DefaultEmitter {\n         }\n     }\n \n-    fn custom_emit(&self, cm: &codemap::CodeMap,\n+    fn custom_emit(&mut self, cm: &codemap::CodeMap,\n                    sp: Span, msg: &str, lvl: Level) {\n-        match emit(cm, sp, msg, lvl, true) {\n+        match emit(self, cm, sp, msg, lvl, true) {\n             Ok(()) => {}\n             Err(e) => fail!(\"failed to print diagnostics: {}\", e),\n         }\n     }\n }\n \n-fn emit(cm: &codemap::CodeMap, sp: Span,\n+fn emit(dst: &mut EmitterWriter, cm: &codemap::CodeMap, sp: Span,\n         msg: &str, lvl: Level, custom: bool) -> io::IoResult<()> {\n     let ss = cm.span_to_str(sp);\n     let lines = cm.span_to_lines(sp);\n@@ -279,22 +287,21 @@ fn emit(cm: &codemap::CodeMap, sp: Span,\n         // the span)\n         let span_end = Span { lo: sp.hi, hi: sp.hi, expn_info: sp.expn_info};\n         let ses = cm.span_to_str(span_end);\n-        try!(print_diagnostic(ses, lvl, msg));\n-        try!(custom_highlight_lines(cm, sp, lvl, lines));\n+        try!(print_diagnostic(dst, ses, lvl, msg));\n+        try!(custom_highlight_lines(dst, cm, sp, lvl, lines));\n     } else {\n-        try!(print_diagnostic(ss, lvl, msg));\n-        try!(highlight_lines(cm, sp, lvl, lines));\n+        try!(print_diagnostic(dst, ss, lvl, msg));\n+        try!(highlight_lines(dst, cm, sp, lvl, lines));\n     }\n-    print_macro_backtrace(cm, sp)\n+    print_macro_backtrace(dst, cm, sp)\n }\n \n-fn highlight_lines(cm: &codemap::CodeMap,\n+fn highlight_lines(err: &mut EmitterWriter,\n+                   cm: &codemap::CodeMap,\n                    sp: Span,\n                    lvl: Level,\n                    lines: &codemap::FileLines) -> io::IoResult<()> {\n     let fm = lines.file;\n-    let mut err = io::stderr();\n-    let err = &mut err as &mut io::Writer;\n \n     let mut elided = false;\n     let mut display_lines = lines.lines.as_slice();\n@@ -304,13 +311,13 @@ fn highlight_lines(cm: &codemap::CodeMap,\n     }\n     // Print the offending lines\n     for line in display_lines.iter() {\n-        try!(write!(err, \"{}:{} {}\\n\", fm.name, *line + 1,\n-                      fm.get_line(*line as int)));\n+        try!(write!(&mut err.dst, \"{}:{} {}\\n\", fm.name, *line + 1,\n+                    fm.get_line(*line as int)));\n     }\n     if elided {\n         let last_line = display_lines[display_lines.len() - 1u];\n         let s = format!(\"{}:{} \", fm.name, last_line + 1u);\n-        try!(write!(err, \"{0:1$}...\\n\", \"\", s.len()));\n+        try!(write!(&mut err.dst, \"{0:1$}...\\n\", \"\", s.len()));\n     }\n \n     // FIXME (#3260)\n@@ -342,16 +349,16 @@ fn highlight_lines(cm: &codemap::CodeMap,\n                 _ => s.push_char(' '),\n             };\n         }\n-        try!(write!(err, \"{}\", s));\n+        try!(write!(&mut err.dst, \"{}\", s));\n         let mut s = ~\"^\";\n         let hi = cm.lookup_char_pos(sp.hi);\n         if hi.col != lo.col {\n             // the ^ already takes up one space\n             let num_squigglies = hi.col.to_uint()-lo.col.to_uint()-1u;\n             for _ in range(0, num_squigglies) { s.push_char('~'); }\n         }\n-        try!(print_maybe_styled(s + \"\\n\",\n-                                  term::attr::ForegroundColor(lvl.color())));\n+        try!(print_maybe_styled(err, s + \"\\n\",\n+                                term::attr::ForegroundColor(lvl.color())));\n     }\n     Ok(())\n }\n@@ -362,26 +369,25 @@ fn highlight_lines(cm: &codemap::CodeMap,\n // than 6 lines), `custom_highlight_lines` will print the first line, then\n // dot dot dot, then last line, whereas `highlight_lines` prints the first\n // six lines.\n-fn custom_highlight_lines(cm: &codemap::CodeMap,\n+fn custom_highlight_lines(w: &mut EmitterWriter,\n+                          cm: &codemap::CodeMap,\n                           sp: Span,\n                           lvl: Level,\n                           lines: &codemap::FileLines) -> io::IoResult<()> {\n     let fm = lines.file;\n-    let mut err = io::stderr();\n-    let err = &mut err as &mut io::Writer;\n \n     let lines = lines.lines.as_slice();\n     if lines.len() > MAX_LINES {\n-        try!(write!(err, \"{}:{} {}\\n\", fm.name,\n-                      lines[0] + 1, fm.get_line(lines[0] as int)));\n-        try!(write!(err, \"...\\n\"));\n+        try!(write!(&mut w.dst, \"{}:{} {}\\n\", fm.name,\n+                    lines[0] + 1, fm.get_line(lines[0] as int)));\n+        try!(write!(&mut w.dst, \"...\\n\"));\n         let last_line = lines[lines.len()-1];\n-        try!(write!(err, \"{}:{} {}\\n\", fm.name,\n-                      last_line + 1, fm.get_line(last_line as int)));\n+        try!(write!(&mut w.dst, \"{}:{} {}\\n\", fm.name,\n+                    last_line + 1, fm.get_line(last_line as int)));\n     } else {\n         for line in lines.iter() {\n-            try!(write!(err, \"{}:{} {}\\n\", fm.name,\n-                          *line + 1, fm.get_line(*line as int)));\n+            try!(write!(&mut w.dst, \"{}:{} {}\\n\", fm.name,\n+                        *line + 1, fm.get_line(*line as int)));\n         }\n     }\n     let last_line_start = format!(\"{}:{} \", fm.name, lines[lines.len()-1]+1);\n@@ -391,22 +397,24 @@ fn custom_highlight_lines(cm: &codemap::CodeMap,\n     let mut s = ~\"\";\n     for _ in range(0, skip) { s.push_char(' '); }\n     s.push_char('^');\n-    print_maybe_styled(s + \"\\n\", term::attr::ForegroundColor(lvl.color()))\n+    print_maybe_styled(w, s + \"\\n\", term::attr::ForegroundColor(lvl.color()))\n }\n \n-fn print_macro_backtrace(cm: &codemap::CodeMap, sp: Span) -> io::IoResult<()> {\n+fn print_macro_backtrace(w: &mut EmitterWriter,\n+                         cm: &codemap::CodeMap,\n+                         sp: Span) -> io::IoResult<()> {\n     for ei in sp.expn_info.iter() {\n         let ss = ei.callee.span.as_ref().map_or(~\"\", |span| cm.span_to_str(*span));\n         let (pre, post) = match ei.callee.format {\n             codemap::MacroAttribute => (\"#[\", \"]\"),\n             codemap::MacroBang => (\"\", \"!\")\n         };\n-        try!(print_diagnostic(ss, Note,\n-                                format!(\"in expansion of {}{}{}\", pre,\n-                                        ei.callee.name, post)));\n+        try!(print_diagnostic(w, ss, Note,\n+                              format!(\"in expansion of {}{}{}\", pre,\n+                                      ei.callee.name, post)));\n         let ss = cm.span_to_str(ei.call_site);\n-        try!(print_diagnostic(ss, Note, \"expansion site\"));\n-        try!(print_macro_backtrace(cm, ei.call_site));\n+        try!(print_diagnostic(w, ss, Note, \"expansion site\"));\n+        try!(print_macro_backtrace(w, cm, ei.call_site));\n     }\n     Ok(())\n }"}, {"sha": "87706df5e31d0be25133a4796e6c38aa518d0e67", "filename": "src/libsyntax/parse/lexer.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cb498cc40d78f8a9bce42b116abb3f4dd8d03335/src%2Flibsyntax%2Fparse%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb498cc40d78f8a9bce42b116abb3f4dd8d03335/src%2Flibsyntax%2Fparse%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer.rs?ref=cb498cc40d78f8a9bce42b116abb3f4dd8d03335", "patch": "@@ -1004,6 +1004,7 @@ mod test {\n     use diagnostic;\n     use parse::token;\n     use parse::token::{str_to_ident};\n+    use std::io::util;\n \n     // represents a testing reader (incl. both reader and interner)\n     struct Env {\n@@ -1014,7 +1015,10 @@ mod test {\n     fn setup(teststr: ~str) -> Env {\n         let cm = CodeMap::new();\n         let fm = cm.new_filemap(~\"zebra.rs\", teststr);\n-        let span_handler = diagnostic::mk_span_handler(diagnostic::mk_handler(), @cm);\n+        let writer = ~util::NullWriter;\n+        let emitter = diagnostic::EmitterWriter::new(writer);\n+        let handler = diagnostic::mk_handler(~emitter);\n+        let span_handler = diagnostic::mk_span_handler(handler, @cm);\n         Env {\n             string_reader: new_string_reader(span_handler,fm)\n         }"}, {"sha": "8f45f9114845316578d8acd592fa741e980eb47c", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cb498cc40d78f8a9bce42b116abb3f4dd8d03335/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb498cc40d78f8a9bce42b116abb3f4dd8d03335/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=cb498cc40d78f8a9bce42b116abb3f4dd8d03335", "patch": "@@ -14,7 +14,7 @@\n use ast;\n use codemap::{Span, CodeMap, FileMap};\n use codemap;\n-use diagnostic::{SpanHandler, mk_span_handler, mk_handler};\n+use diagnostic::{SpanHandler, mk_span_handler, default_handler};\n use parse::attr::ParserAttr;\n use parse::parser::Parser;\n \n@@ -49,7 +49,7 @@ pub fn new_parse_sess() -> @ParseSess {\n     let cm = @CodeMap::new();\n     @ParseSess {\n         cm: cm,\n-        span_diagnostic: mk_span_handler(mk_handler(), cm),\n+        span_diagnostic: mk_span_handler(default_handler(), cm),\n         included_mod_stack: RefCell::new(~[]),\n     }\n }"}]}