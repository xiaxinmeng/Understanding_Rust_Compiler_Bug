{"sha": "3b3594044327ea6a426e0b95dd3ffee725089430", "node_id": "C_kwDOAAsO6NoAKDNiMzU5NDA0NDMyN2VhNmE0MjZlMGI5NWRkM2ZmZWU3MjUwODk0MzA", "commit": {"author": {"name": "Antoni Boucher", "email": "bouanto@zoho.com", "date": "2022-05-14T21:36:37Z"}, "committer": {"name": "Antoni Boucher", "email": "bouanto@zoho.com", "date": "2022-06-07T02:08:07Z"}, "message": "Implement more SIMD", "tree": {"sha": "1861b76af4fcd78afd957b2bf65fe4fdf69739c7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1861b76af4fcd78afd957b2bf65fe4fdf69739c7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3b3594044327ea6a426e0b95dd3ffee725089430", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3b3594044327ea6a426e0b95dd3ffee725089430", "html_url": "https://github.com/rust-lang/rust/commit/3b3594044327ea6a426e0b95dd3ffee725089430", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3b3594044327ea6a426e0b95dd3ffee725089430/comments", "author": {"login": "antoyo", "id": 584972, "node_id": "MDQ6VXNlcjU4NDk3Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/584972?v=4", "gravatar_id": "", "url": "https://api.github.com/users/antoyo", "html_url": "https://github.com/antoyo", "followers_url": "https://api.github.com/users/antoyo/followers", "following_url": "https://api.github.com/users/antoyo/following{/other_user}", "gists_url": "https://api.github.com/users/antoyo/gists{/gist_id}", "starred_url": "https://api.github.com/users/antoyo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/antoyo/subscriptions", "organizations_url": "https://api.github.com/users/antoyo/orgs", "repos_url": "https://api.github.com/users/antoyo/repos", "events_url": "https://api.github.com/users/antoyo/events{/privacy}", "received_events_url": "https://api.github.com/users/antoyo/received_events", "type": "User", "site_admin": false}, "committer": {"login": "antoyo", "id": 584972, "node_id": "MDQ6VXNlcjU4NDk3Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/584972?v=4", "gravatar_id": "", "url": "https://api.github.com/users/antoyo", "html_url": "https://github.com/antoyo", "followers_url": "https://api.github.com/users/antoyo/followers", "following_url": "https://api.github.com/users/antoyo/following{/other_user}", "gists_url": "https://api.github.com/users/antoyo/gists{/gist_id}", "starred_url": "https://api.github.com/users/antoyo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/antoyo/subscriptions", "organizations_url": "https://api.github.com/users/antoyo/orgs", "repos_url": "https://api.github.com/users/antoyo/repos", "events_url": "https://api.github.com/users/antoyo/events{/privacy}", "received_events_url": "https://api.github.com/users/antoyo/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e8dca3e87d164d2806098c462c6ce41301341f68", "url": "https://api.github.com/repos/rust-lang/rust/commits/e8dca3e87d164d2806098c462c6ce41301341f68", "html_url": "https://github.com/rust-lang/rust/commit/e8dca3e87d164d2806098c462c6ce41301341f68"}], "stats": {"total": 247, "additions": 111, "deletions": 136}, "files": [{"sha": "0e41bec8b76281a6be602d19f6259fe7f039edf3", "filename": "Cargo.toml", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3b3594044327ea6a426e0b95dd3ffee725089430/Cargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/3b3594044327ea6a426e0b95dd3ffee725089430/Cargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.toml?ref=3b3594044327ea6a426e0b95dd3ffee725089430", "patch": "@@ -22,10 +22,10 @@ default = [\"master\"]\n master = [\"gccjit/master\"]\n \n [dependencies]\n-gccjit = { git = \"https://github.com/antoyo/gccjit.rs\" }\n+#gccjit = { git = \"https://github.com/antoyo/gccjit.rs\" }\n \n # Local copy.\n-#gccjit = { path = \"../gccjit.rs\" }\n+gccjit = { path = \"../gccjit.rs\" }\n \n target-lexicon = \"0.10.0\"\n "}, {"sha": "e7adf29fed8e91fb50f432d96007a7d8bd9e0436", "filename": "src/builder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3b3594044327ea6a426e0b95dd3ffee725089430/src%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b3594044327ea6a426e0b95dd3ffee725089430/src%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbuilder.rs?ref=3b3594044327ea6a426e0b95dd3ffee725089430", "patch": "@@ -1409,7 +1409,7 @@ impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n     }\n \n     #[cfg(not(feature=\"master\"))]\n-    pub fn vector_reduce<F>(&mut self, src: RValue<'gcc>, op: F) -> RValue<'gcc>\n+    pub fn vector_reduce<F>(&mut self, _src: RValue<'gcc>, _op: F) -> RValue<'gcc>\n     where F: Fn(RValue<'gcc>, RValue<'gcc>, &'gcc Context<'gcc>) -> RValue<'gcc>\n     {\n         unimplemented!();"}, {"sha": "6b78157410b068e804f971ddc7f14cd9f103b52b", "filename": "src/intrinsic/llvm.rs", "status": "modified", "additions": 83, "deletions": 28, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/3b3594044327ea6a426e0b95dd3ffee725089430/src%2Fintrinsic%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b3594044327ea6a426e0b95dd3ffee725089430/src%2Fintrinsic%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintrinsic%2Fllvm.rs?ref=3b3594044327ea6a426e0b95dd3ffee725089430", "patch": "@@ -75,38 +75,38 @@ pub fn adjust_intrinsic_arguments<'a, 'b, 'gcc, 'tcx>(builder: &Builder<'a, 'gcc\n                 \"__builtin_ia32_pternlogd512_mask\" | \"__builtin_ia32_pternlogd256_mask\"\n                     | \"__builtin_ia32_pternlogd128_mask\" | \"__builtin_ia32_pternlogq512_mask\"\n                     | \"__builtin_ia32_pternlogq256_mask\" | \"__builtin_ia32_pternlogq128_mask\" => {\n-                        let mut new_args = args.to_vec();\n-                        let arg5_type = gcc_func.get_param_type(4);\n-                        let minus_one = builder.context.new_rvalue_from_int(arg5_type, -1);\n-                        new_args.push(minus_one);\n-                        args = new_args.into();\n-                    },\n-                    \"__builtin_ia32_vfmaddps512_mask\" | \"__builtin_ia32_vfmaddpd512_mask\" => {\n-                        let mut new_args = args.to_vec();\n+                    let mut new_args = args.to_vec();\n+                    let arg5_type = gcc_func.get_param_type(4);\n+                    let minus_one = builder.context.new_rvalue_from_int(arg5_type, -1);\n+                    new_args.push(minus_one);\n+                    args = new_args.into();\n+                },\n+                \"__builtin_ia32_vfmaddps512_mask\" | \"__builtin_ia32_vfmaddpd512_mask\" => {\n+                    let mut new_args = args.to_vec();\n \n-                        let mut last_arg = None;\n-                        if args.len() == 4 {\n-                            last_arg = new_args.pop();\n-                        }\n+                    let mut last_arg = None;\n+                    if args.len() == 4 {\n+                        last_arg = new_args.pop();\n+                    }\n \n-                        let arg4_type = gcc_func.get_param_type(3);\n-                        let minus_one = builder.context.new_rvalue_from_int(arg4_type, -1);\n-                        new_args.push(minus_one);\n+                    let arg4_type = gcc_func.get_param_type(3);\n+                    let minus_one = builder.context.new_rvalue_from_int(arg4_type, -1);\n+                    new_args.push(minus_one);\n \n-                        if args.len() == 3 {\n-                            // Both llvm.fma.v16f32 and llvm.x86.avx512.vfmadd.ps.512 maps to\n-                            // the same GCC intrinsic, but the former has 3 parameters and the\n-                            // latter has 4 so it doesn't require this additional argument.\n-                            let arg5_type = gcc_func.get_param_type(4);\n-                            new_args.push(builder.context.new_rvalue_from_int(arg5_type, 4));\n-                        }\n+                    if args.len() == 3 {\n+                        // Both llvm.fma.v16f32 and llvm.x86.avx512.vfmadd.ps.512 maps to\n+                        // the same GCC intrinsic, but the former has 3 parameters and the\n+                        // latter has 4 so it doesn't require this additional argument.\n+                        let arg5_type = gcc_func.get_param_type(4);\n+                        new_args.push(builder.context.new_rvalue_from_int(arg5_type, 4));\n+                    }\n \n-                        if let Some(last_arg) = last_arg {\n-                            new_args.push(last_arg);\n-                        }\n+                    if let Some(last_arg) = last_arg {\n+                        new_args.push(last_arg);\n+                    }\n \n-                        args = new_args.into();\n-                    },\n+                    args = new_args.into();\n+                },\n                     \"__builtin_ia32_addps512_mask\" | \"__builtin_ia32_addpd512_mask\"\n                         | \"__builtin_ia32_subps512_mask\" | \"__builtin_ia32_subpd512_mask\"\n                         | \"__builtin_ia32_mulps512_mask\" | \"__builtin_ia32_mulpd512_mask\"\n@@ -131,6 +131,18 @@ pub fn adjust_intrinsic_arguments<'a, 'b, 'gcc, 'tcx>(builder: &Builder<'a, 'gcc\n                         new_args.push(last_arg);\n                         args = new_args.into();\n                     },\n+                    \"__builtin_ia32_cvtdq2ps512_mask\" | \"__builtin_ia32_cvtudq2ps512_mask\" => {\n+                        let mut new_args = args.to_vec();\n+                        let last_arg = new_args.pop().expect(\"last arg\");\n+                        let arg2_type = gcc_func.get_param_type(1);\n+                        let undefined = builder.current_func().new_local(None, arg2_type, \"undefined_for_intrinsic\").to_rvalue();\n+                        new_args.push(undefined);\n+                        let arg3_type = gcc_func.get_param_type(2);\n+                        let minus_one = builder.context.new_rvalue_from_int(arg3_type, -1);\n+                        new_args.push(minus_one);\n+                        new_args.push(last_arg);\n+                        args = new_args.into();\n+                    },\n                     _ => (),\n         }\n     }\n@@ -149,7 +161,8 @@ pub fn ignore_arg_cast(func_name: &str, index: usize, args_len: usize) -> bool {\n             | \"__builtin_ia32_subps512_mask\" | \"__builtin_ia32_subpd512_mask\"\n             | \"__builtin_ia32_mulps512_mask\" | \"__builtin_ia32_mulpd512_mask\"\n             | \"__builtin_ia32_divps512_mask\" | \"__builtin_ia32_divpd512_mask\"\n-            | \"__builtin_ia32_vfmaddsubps512_mask\" | \"__builtin_ia32_vfmaddsubpd512_mask\" => {\n+            | \"__builtin_ia32_vfmaddsubps512_mask\" | \"__builtin_ia32_vfmaddsubpd512_mask\"\n+            | \"__builtin_ia32_cvtdq2ps512_mask\" | \"__builtin_ia32_cvtudq2ps512_mask\" => {\n                 if index == args_len - 1 {\n                     return true;\n                 }\n@@ -221,6 +234,48 @@ pub fn intrinsic<'gcc, 'tcx>(name: &str, cx: &CodegenCx<'gcc, 'tcx>) -> Function\n         \"llvm.x86.avx512.div.pd.512\" => \"__builtin_ia32_divpd512_mask\",\n         \"llvm.x86.avx512.vfmadd.ps.512\" => \"__builtin_ia32_vfmaddps512_mask\",\n         \"llvm.x86.avx512.vfmadd.pd.512\" => \"__builtin_ia32_vfmaddpd512_mask\",\n+        \"llvm.x86.avx512.sitofp.round.v16f32.v16i32\" => \"__builtin_ia32_cvtdq2ps512_mask\",\n+        \"llvm.x86.avx512.uitofp.round.v16f32.v16i32\" => \"__builtin_ia32_cvtudq2ps512_mask\",\n+        \"llvm.x86.avx512.mask.cvttps2dq.256\" => \"__builtin_ia32_cvttps2dq256_mask\",\n+        \"llvm.x86.avx512.mask.cvttps2dq.128\" => \"__builtin_ia32_cvttps2dq128_mask\",\n+        \"llvm.x86.avx512.mask.cvttpd2dq.256\" => \"__builtin_ia32_cvttpd2dq256_mask\",\n+        \"llvm.x86.avx512.mask.compress.d.512\" => \"__builtin_ia32_compresssi512_mask\",\n+        \"llvm.x86.avx512.mask.compress.d.256\" => \"__builtin_ia32_compresssi256_mask\",\n+        \"llvm.x86.avx512.mask.compress.d.128\" => \"__builtin_ia32_compresssi128_mask\",\n+        \"llvm.x86.avx512.mask.compress.q.512\" => \"__builtin_ia32_compressdi512_mask\",\n+        \"llvm.x86.avx512.mask.compress.q.256\" => \"__builtin_ia32_compressdi256_mask\",\n+        \"llvm.x86.avx512.mask.compress.q.128\" => \"__builtin_ia32_compressdi128_mask\",\n+        \"llvm.x86.avx512.mask.compress.ps.512\" => \"__builtin_ia32_compresssf512_mask\",\n+        \"llvm.x86.avx512.mask.compress.ps.256\" => \"__builtin_ia32_compresssf256_mask\",\n+        \"llvm.x86.avx512.mask.compress.ps.128\" => \"__builtin_ia32_compresssf128_mask\",\n+        \"llvm.x86.avx512.mask.compress.pd.512\" => \"__builtin_ia32_compressdf512_mask\",\n+        \"llvm.x86.avx512.mask.compress.pd.256\" => \"__builtin_ia32_compressdf256_mask\",\n+        \"llvm.x86.avx512.mask.compress.pd.128\" => \"__builtin_ia32_compressdf128_mask\",\n+        \"llvm.x86.avx512.mask.compress.store.d.512\" => \"\",\n+        \"llvm.x86.avx512.mask.compress.store.d.256\" => \"\",\n+        \"llvm.x86.avx512.mask.compress.store.d.128\" => \"\",\n+        \"llvm.x86.avx512.mask.compress.store.q.512\" => \"\",\n+        \"llvm.x86.avx512.mask.compress.store.q.256\" => \"\",\n+        \"llvm.x86.avx512.mask.compress.store.q.128\" => \"\",\n+        \"llvm.x86.avx512.mask.compress.store.ps.512\" => \"\",\n+        \"llvm.x86.avx512.mask.compress.store.ps.256\" => \"\",\n+        \"llvm.x86.avx512.mask.compress.store.ps.128\" => \"\",\n+        \"llvm.x86.avx512.mask.compress.store.pd.512\" => \"\",\n+        \"llvm.x86.avx512.mask.compress.store.pd.256\" => \"\",\n+        \"llvm.x86.avx512.mask.compress.store.pd.128\" => \"\",\n+        \"llvm.x86.avx512.mask.expand.d.512\" => \"\",\n+        \"llvm.x86.avx512.mask.expand.d.256\" => \"\",\n+        \"llvm.x86.avx512.mask.expand.d.128\" => \"\",\n+        \"llvm.x86.avx512.mask.expand.q.512\" => \"\",\n+        \"\" => \"\",\n+        \"\" => \"\",\n+        \"\" => \"\",\n+        \"\" => \"\",\n+        \"\" => \"\",\n+        \"\" => \"\",\n+        \"\" => \"\",\n+        \"\" => \"\",\n+        \"\" => \"\",\n \n         // The above doc points to unknown builtins for the following, so override them:\n         \"llvm.x86.avx2.gather.d.d\" => \"__builtin_ia32_gathersiv4si\","}, {"sha": "a6cf99c62fff9d96813e32dc380e579ee82c8d0e", "filename": "src/intrinsic/simd.rs", "status": "modified", "additions": 25, "deletions": 105, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/3b3594044327ea6a426e0b95dd3ffee725089430/src%2Fintrinsic%2Fsimd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b3594044327ea6a426e0b95dd3ffee725089430/src%2Fintrinsic%2Fsimd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintrinsic%2Fsimd.rs?ref=3b3594044327ea6a426e0b95dd3ffee725089430", "patch": "@@ -1,5 +1,3 @@\n-use std::cmp::Ordering;\n-\n use gccjit::{BinaryOp, RValue, Type, ToRValue};\n use rustc_codegen_ssa::base::compare_simd_types;\n use rustc_codegen_ssa::common::{TypeKind, span_invalid_monomorphization_error};\n@@ -309,117 +307,37 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(bx: &mut Builder<'a, 'gcc, 'tcx>,\n \n         enum Style {\n             Float,\n-            Int(/* is signed? */ bool),\n+            Int,\n             Unsupported,\n         }\n \n-        let (in_style, in_width) = match in_elem.kind() {\n-            // vectors of pointer-sized integers should've been\n-            // disallowed before here, so this unwrap is safe.\n-            ty::Int(i) => (\n-                Style::Int(true),\n-                i.normalize(bx.tcx().sess.target.pointer_width).bit_width().unwrap(),\n-            ),\n-            ty::Uint(u) => (\n-                Style::Int(false),\n-                u.normalize(bx.tcx().sess.target.pointer_width).bit_width().unwrap(),\n-            ),\n-            ty::Float(f) => (Style::Float, f.bit_width()),\n-            _ => (Style::Unsupported, 0),\n-        };\n-        let (out_style, out_width) = match out_elem.kind() {\n-            ty::Int(i) => (\n-                Style::Int(true),\n-                i.normalize(bx.tcx().sess.target.pointer_width).bit_width().unwrap(),\n-            ),\n-            ty::Uint(u) => (\n-                Style::Int(false),\n-                u.normalize(bx.tcx().sess.target.pointer_width).bit_width().unwrap(),\n-            ),\n-            ty::Float(f) => (Style::Float, f.bit_width()),\n-            _ => (Style::Unsupported, 0),\n-        };\n-\n-        let extend = |in_type, out_type| {\n-            let vector_type = bx.context.new_vector_type(out_type, 8);\n-            let vector = args[0].immediate();\n-            let array_type = bx.context.new_array_type(None, in_type, 8);\n-            // TODO(antoyo): switch to using new_vector_access or __builtin_convertvector for vector casting.\n-            let array = bx.context.new_bitcast(None, vector, array_type);\n-\n-            let cast_vec_element = |index| {\n-                let index = bx.context.new_rvalue_from_int(bx.int_type, index);\n-                bx.context.new_cast(None, bx.context.new_array_access(None, array, index).to_rvalue(), out_type)\n+        let in_style =\n+            match in_elem.kind() {\n+                ty::Int(_) | ty::Uint(_) => Style::Int,\n+                ty::Float(_) => Style::Float,\n+                 _ => Style::Unsupported,\n             };\n \n-            bx.context.new_rvalue_from_vector(None, vector_type, &[\n-                cast_vec_element(0),\n-                cast_vec_element(1),\n-                cast_vec_element(2),\n-                cast_vec_element(3),\n-                cast_vec_element(4),\n-                cast_vec_element(5),\n-                cast_vec_element(6),\n-                cast_vec_element(7),\n-            ])\n-        };\n+        let out_style =\n+            match out_elem.kind() {\n+                ty::Int(_) | ty::Uint(_) => Style::Int,\n+                ty::Float(_) => Style::Float,\n+                 _ => Style::Unsupported,\n+            };\n \n         match (in_style, out_style) {\n-            (Style::Int(in_is_signed), Style::Int(_)) => {\n-                return Ok(match in_width.cmp(&out_width) {\n-                    Ordering::Greater => bx.trunc(args[0].immediate(), llret_ty),\n-                    Ordering::Equal => args[0].immediate(),\n-                    Ordering::Less => {\n-                        if in_is_signed {\n-                            match (in_width, out_width) {\n-                                // FIXME(antoyo): the function _mm_cvtepi8_epi16 should directly\n-                                // call an intrinsic equivalent to __builtin_ia32_pmovsxbw128 so that\n-                                // we can generate a call to it.\n-                                (8, 16) => extend(bx.i8_type, bx.i16_type),\n-                                (8, 32) => extend(bx.i8_type, bx.i32_type),\n-                                (8, 64) => extend(bx.i8_type, bx.i64_type),\n-                                (16, 32) => extend(bx.i16_type, bx.i32_type),\n-                                (32, 64) => extend(bx.i32_type, bx.i64_type),\n-                                (16, 64) => extend(bx.i16_type, bx.i64_type),\n-                                _ => unimplemented!(\"in: {}, out: {}\", in_width, out_width),\n-                            }\n-                        } else {\n-                            match (in_width, out_width) {\n-                                (8, 16) => extend(bx.u8_type, bx.u16_type),\n-                                (8, 32) => extend(bx.u8_type, bx.u32_type),\n-                                (8, 64) => extend(bx.u8_type, bx.u64_type),\n-                                (16, 32) => extend(bx.u16_type, bx.u32_type),\n-                                (16, 64) => extend(bx.u16_type, bx.u64_type),\n-                                (32, 64) => extend(bx.u32_type, bx.u64_type),\n-                                _ => unimplemented!(\"in: {}, out: {}\", in_width, out_width),\n-                            }\n-                        }\n-                    }\n-                });\n-            }\n-            (Style::Int(_), Style::Float) => {\n-                // TODO: add support for internal functions in libgccjit to get access to IFN_VEC_CONVERT which is\n-                // doing like __builtin_convertvector?\n-                // Or maybe provide convert_vector as an API since it might not easy to get the\n-                // types of internal functions.\n-                unimplemented!();\n-            }\n-            (Style::Float, Style::Int(_)) => {\n-                unimplemented!();\n-            }\n-            (Style::Float, Style::Float) => {\n-                unimplemented!();\n-            }\n-            _ => { /* Unsupported. Fallthrough. */ }\n+            (Style::Unsupported, Style::Unsupported) => {\n+                require!(\n+                    false,\n+                    \"unsupported cast from `{}` with element `{}` to `{}` with element `{}`\",\n+                    in_ty,\n+                    in_elem,\n+                    ret_ty,\n+                    out_elem\n+                );\n+            },\n+            _ => return Ok(bx.context.convert_vector(None, args[0].immediate(), llret_ty)),\n         }\n-        require!(\n-            false,\n-            \"unsupported cast from `{}` with element `{}` to `{}` with element `{}`\",\n-            in_ty,\n-            in_elem,\n-            ret_ty,\n-            out_elem\n-        );\n     }\n \n     macro_rules! arith_binary {\n@@ -590,6 +508,8 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(bx: &mut Builder<'a, 'gcc, 'tcx>,\n                 );\n             }\n         };\n+        // TODO(antoyo): don't use target specific builtins here.\n+        // Not sure how easy it would be to avoid theme here.\n         let builtin_name =\n             match (signed, is_add, in_len, elem_width) {\n                 (true, true, 32, 8) => \"__builtin_ia32_paddsb256\", // TODO(antoyo): cast arguments to unsigned."}]}