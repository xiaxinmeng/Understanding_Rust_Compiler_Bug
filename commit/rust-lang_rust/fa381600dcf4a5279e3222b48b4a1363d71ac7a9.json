{"sha": "fa381600dcf4a5279e3222b48b4a1363d71ac7a9", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZhMzgxNjAwZGNmNGE1Mjc5ZTMyMjJiNDhiNGExMzYzZDcxYWM3YTk=", "commit": {"author": {"name": "Aman Arora", "email": "me@aman-arora.com", "date": "2020-11-01T21:39:47Z"}, "committer": {"name": "Aman Arora", "email": "me@aman-arora.com", "date": "2020-11-11T01:58:56Z"}, "message": "Handle `let _ = x` patterns in closure liveness analysis", "tree": {"sha": "8e6e844576f855ed10289454703be6a1d1319b2d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8e6e844576f855ed10289454703be6a1d1319b2d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fa381600dcf4a5279e3222b48b4a1363d71ac7a9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fa381600dcf4a5279e3222b48b4a1363d71ac7a9", "html_url": "https://github.com/rust-lang/rust/commit/fa381600dcf4a5279e3222b48b4a1363d71ac7a9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fa381600dcf4a5279e3222b48b4a1363d71ac7a9/comments", "author": {"login": "arora-aman", "id": 4193035, "node_id": "MDQ6VXNlcjQxOTMwMzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4193035?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arora-aman", "html_url": "https://github.com/arora-aman", "followers_url": "https://api.github.com/users/arora-aman/followers", "following_url": "https://api.github.com/users/arora-aman/following{/other_user}", "gists_url": "https://api.github.com/users/arora-aman/gists{/gist_id}", "starred_url": "https://api.github.com/users/arora-aman/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arora-aman/subscriptions", "organizations_url": "https://api.github.com/users/arora-aman/orgs", "repos_url": "https://api.github.com/users/arora-aman/repos", "events_url": "https://api.github.com/users/arora-aman/events{/privacy}", "received_events_url": "https://api.github.com/users/arora-aman/received_events", "type": "User", "site_admin": false}, "committer": {"login": "arora-aman", "id": 4193035, "node_id": "MDQ6VXNlcjQxOTMwMzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4193035?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arora-aman", "html_url": "https://github.com/arora-aman", "followers_url": "https://api.github.com/users/arora-aman/followers", "following_url": "https://api.github.com/users/arora-aman/following{/other_user}", "gists_url": "https://api.github.com/users/arora-aman/gists{/gist_id}", "starred_url": "https://api.github.com/users/arora-aman/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arora-aman/subscriptions", "organizations_url": "https://api.github.com/users/arora-aman/orgs", "repos_url": "https://api.github.com/users/arora-aman/repos", "events_url": "https://api.github.com/users/arora-aman/events{/privacy}", "received_events_url": "https://api.github.com/users/arora-aman/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "825e9e45d14694d23fde29fdab2b02d9973a4eb3", "url": "https://api.github.com/repos/rust-lang/rust/commits/825e9e45d14694d23fde29fdab2b02d9973a4eb3", "html_url": "https://github.com/rust-lang/rust/commit/825e9e45d14694d23fde29fdab2b02d9973a4eb3"}], "stats": {"total": 69, "additions": 49, "deletions": 20}, "files": [{"sha": "debb873beb93b9fbc90affa78a20036e4c302bde", "filename": "compiler/rustc_passes/src/liveness.rs", "status": "modified", "additions": 49, "deletions": 20, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/fa381600dcf4a5279e3222b48b4a1363d71ac7a9/compiler%2Frustc_passes%2Fsrc%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa381600dcf4a5279e3222b48b4a1363d71ac7a9/compiler%2Frustc_passes%2Fsrc%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fliveness.rs?ref=fa381600dcf4a5279e3222b48b4a1363d71ac7a9", "patch": "@@ -317,19 +317,20 @@ impl<'tcx> Visitor<'tcx> for IrMaps<'tcx> {\n         // swap in a new set of IR maps for this body\n         let mut maps = IrMaps::new(self.tcx);\n         let hir_id = maps.tcx.hir().body_owner(body.id());\n-        let def_id = maps.tcx.hir().local_def_id(hir_id);\n+        let local_def_id = maps.tcx.hir().local_def_id(hir_id);\n+        let def_id = local_def_id.to_def_id();\n \n         // Don't run unused pass for #[derive()]\n-        if let Some(parent) = self.tcx.parent(def_id.to_def_id()) {\n+        if let Some(parent) = self.tcx.parent(def_id) {\n             if let DefKind::Impl = self.tcx.def_kind(parent.expect_local()) {\n                 if self.tcx.has_attr(parent, sym::automatically_derived) {\n                     return;\n                 }\n             }\n         }\n \n-        if let Some(upvars) = maps.tcx.upvars_mentioned(def_id) {\n-            for (&var_hir_id, _upvar) in upvars {\n+        if let Some(captures) = maps.tcx.typeck(local_def_id).closure_captures.get(&def_id) {\n+            for &var_hir_id in captures.keys() {\n                 let var_name = maps.tcx.hir().name(var_hir_id);\n                 maps.add_variable(Upvar(var_hir_id, var_name));\n             }\n@@ -340,7 +341,7 @@ impl<'tcx> Visitor<'tcx> for IrMaps<'tcx> {\n         intravisit::walk_body(&mut maps, body);\n \n         // compute liveness\n-        let mut lsets = Liveness::new(&mut maps, def_id);\n+        let mut lsets = Liveness::new(&mut maps, local_def_id);\n         let entry_ln = lsets.compute(&body, hir_id);\n         lsets.log_liveness(entry_ln, body.id().hir_id);\n \n@@ -397,10 +398,18 @@ impl<'tcx> Visitor<'tcx> for IrMaps<'tcx> {\n                 // construction site.\n                 let mut call_caps = Vec::new();\n                 let closure_def_id = self.tcx.hir().local_def_id(expr.hir_id);\n-                if let Some(upvars) = self.tcx.upvars_mentioned(closure_def_id) {\n-                    call_caps.extend(upvars.iter().map(|(&var_id, upvar)| {\n+                if let Some(captures) = self\n+                    .tcx\n+                    .typeck(closure_def_id)\n+                    .closure_captures\n+                    .get(&closure_def_id.to_def_id())\n+                {\n+                    // If closure captures is Some, upvars_mentioned must also be Some\n+                    let upvars = self.tcx.upvars_mentioned(closure_def_id).unwrap();\n+                    call_caps.extend(captures.keys().map(|var_id| {\n+                        let upvar = upvars[var_id];\n                         let upvar_ln = self.add_live_node(UpvarNode(upvar.span));\n-                        CaptureInfo { ln: upvar_ln, var_hid: var_id }\n+                        CaptureInfo { ln: upvar_ln, var_hid: *var_id }\n                     }));\n                 }\n                 self.set_captures(expr.hir_id, call_caps);\n@@ -564,6 +573,7 @@ struct Liveness<'a, 'tcx> {\n     typeck_results: &'a ty::TypeckResults<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n     upvars: Option<&'tcx FxIndexMap<hir::HirId, hir::Upvar>>,\n+    closure_captures: Option<&'tcx FxIndexMap<hir::HirId, ty::UpvarId>>,\n     successors: IndexVec<LiveNode, Option<LiveNode>>,\n     rwu_table: RWUTable,\n \n@@ -587,6 +597,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n         let typeck_results = ir.tcx.typeck(body_owner);\n         let param_env = ir.tcx.param_env(body_owner);\n         let upvars = ir.tcx.upvars_mentioned(body_owner);\n+        let closure_captures = typeck_results.closure_captures.get(&body_owner.to_def_id());\n \n         let closure_ln = ir.add_live_node(ClosureNode);\n         let exit_ln = ir.add_live_node(ExitNode);\n@@ -600,6 +611,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n             typeck_results,\n             param_env,\n             upvars,\n+            closure_captures,\n             successors: IndexVec::from_elem_n(None, num_live_nodes),\n             rwu_table: RWUTable::new(num_live_nodes * num_vars),\n             closure_ln,\n@@ -850,14 +862,13 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n         // if they are live on the entry to the closure, since only the closure\n         // itself can access them on subsequent calls.\n \n-        if let Some(upvars) = self.upvars {\n+        if let Some(closure_captures) = self.closure_captures {\n             // Mark upvars captured by reference as used after closure exits.\n-            for (&var_hir_id, upvar) in upvars.iter().rev() {\n-                let upvar_id = ty::UpvarId {\n-                    var_path: ty::UpvarPath { hir_id: var_hir_id },\n-                    closure_expr_id: self.body_owner,\n-                };\n-                match self.typeck_results.upvar_capture(upvar_id) {\n+            // Since closure_captures is Some, upvars must exists too.\n+            let upvars = self.upvars.unwrap();\n+            for (&var_hir_id, upvar_id) in closure_captures {\n+                let upvar = upvars[&var_hir_id];\n+                match self.typeck_results.upvar_capture(*upvar_id) {\n                     ty::UpvarCapture::ByRef(_) => {\n                         let var = self.variable(var_hir_id, upvar.span);\n                         self.acc(self.exit_ln, var, ACC_READ | ACC_USE);\n@@ -869,7 +880,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n \n         let succ = self.propagate_through_expr(&body.value, self.exit_ln);\n \n-        if self.upvars.is_none() {\n+        if self.closure_captures.is_none() {\n             // Either not a closure, or closure without any captured variables.\n             // No need to determine liveness of captured variables, since there\n             // are none.\n@@ -1341,7 +1352,21 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n         acc: u32,\n     ) -> LiveNode {\n         match path.res {\n-            Res::Local(hid) => self.access_var(hir_id, hid, succ, acc, path.span),\n+            Res::Local(hid) => {\n+                let in_upvars = self.upvars.map_or(false, |u| u.contains_key(&hid));\n+                let in_captures = self.closure_captures.map_or(false, |c| c.contains_key(&hid));\n+\n+                match (in_upvars, in_captures) {\n+                    (false, _) | (true, true) => self.access_var(hir_id, hid, succ, acc, path.span),\n+                    (true, false) => {\n+                        // This case is possible when with RFC-2229, a wild pattern\n+                        // is used within a closure.\n+                        // eg: `let _ = x`. The closure doesn't capture x here,\n+                        // even though it's mentioned in the closure.\n+                        succ\n+                    }\n+                }\n+            }\n             _ => succ,\n         }\n     }\n@@ -1531,11 +1556,15 @@ impl<'tcx> Liveness<'_, 'tcx> {\n     }\n \n     fn warn_about_unused_upvars(&self, entry_ln: LiveNode) {\n-        let upvars = match self.upvars {\n+        let closure_captures = match self.closure_captures {\n             None => return,\n-            Some(upvars) => upvars,\n+            Some(closure_captures) => closure_captures,\n         };\n-        for (&var_hir_id, upvar) in upvars.iter() {\n+\n+        // If closure_captures is Some(), upvars must be Some() too.\n+        let upvars = self.upvars.unwrap();\n+        for &var_hir_id in closure_captures.keys() {\n+            let upvar = upvars[&var_hir_id];\n             let var = self.variable(var_hir_id, upvar.span);\n             let upvar_id = ty::UpvarId {\n                 var_path: ty::UpvarPath { hir_id: var_hir_id },"}]}