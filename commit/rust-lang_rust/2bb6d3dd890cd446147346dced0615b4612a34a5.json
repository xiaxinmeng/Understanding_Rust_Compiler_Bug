{"sha": "2bb6d3dd890cd446147346dced0615b4612a34a5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJiYjZkM2RkODkwY2Q0NDYxNDczNDZkY2VkMDYxNWI0NjEyYTM0YTU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-08-07T15:42:35Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-08-07T15:42:35Z"}, "message": "Auto merge of #43713 - arielb1:legacy-dataflow, r=eddyb\n\nrustc::middle::dataflow - visit the CFG in RPO\n\nWe used to propagate bits in node-id order, which sometimes caused an\nexcessive number of iterations, especially when macros were present. As\neveryone knows, visiting the CFG in RPO bounds the number of iterators\nby 1 plus the depth of the most deeply nested loop (times the height of\nthe lattice, which is 1).\n\nI have no idea how this affects borrowck perf in the non-worst-case, so it's probably a good idea to not roll this up so we can see the effects.\n\nFixes #43704.\n\nr? @eddyb", "tree": {"sha": "7a5e9ed05c71139a60379458bad4de7dca1aac74", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7a5e9ed05c71139a60379458bad4de7dca1aac74"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2bb6d3dd890cd446147346dced0615b4612a34a5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2bb6d3dd890cd446147346dced0615b4612a34a5", "html_url": "https://github.com/rust-lang/rust/commit/2bb6d3dd890cd446147346dced0615b4612a34a5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2bb6d3dd890cd446147346dced0615b4612a34a5/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e8f558543bf2c8e9c056443c144ca9c3ff98f0f3", "url": "https://api.github.com/repos/rust-lang/rust/commits/e8f558543bf2c8e9c056443c144ca9c3ff98f0f3", "html_url": "https://github.com/rust-lang/rust/commit/e8f558543bf2c8e9c056443c144ca9c3ff98f0f3"}, {"sha": "4e3a0b636fffdf9d514420681dc60ecbca221f42", "url": "https://api.github.com/repos/rust-lang/rust/commits/4e3a0b636fffdf9d514420681dc60ecbca221f42", "html_url": "https://github.com/rust-lang/rust/commit/4e3a0b636fffdf9d514420681dc60ecbca221f42"}], "stats": {"total": 96, "additions": 92, "deletions": 4}, "files": [{"sha": "d394c0f0c8734c1b3caba9108862254b81535a01", "filename": "src/librustc/middle/dataflow.rs", "status": "modified", "additions": 13, "deletions": 4, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/2bb6d3dd890cd446147346dced0615b4612a34a5/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bb6d3dd890cd446147346dced0615b4612a34a5/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdataflow.rs?ref=2bb6d3dd890cd446147346dced0615b4612a34a5", "patch": "@@ -22,6 +22,9 @@ use std::mem;\n use std::usize;\n use syntax::ast;\n use syntax::print::pprust::PrintState;\n+\n+use rustc_data_structures::graph::OUTGOING;\n+\n use util::nodemap::NodeMap;\n use hir;\n use hir::intravisit::{self, IdRange};\n@@ -523,12 +526,16 @@ impl<'a, 'tcx, O:DataFlowOperator+Clone+'static> DataFlowContext<'a, 'tcx, O> {\n                 changed: true\n             };\n \n+            let nodes_po = cfg.graph.nodes_in_postorder(OUTGOING, cfg.entry);\n             let mut temp = vec![0; words_per_id];\n+            let mut num_passes = 0;\n             while propcx.changed {\n+                num_passes += 1;\n                 propcx.changed = false;\n                 propcx.reset(&mut temp);\n-                propcx.walk_cfg(cfg, &mut temp);\n+                propcx.walk_cfg(cfg, &nodes_po, &mut temp);\n             }\n+            debug!(\"finished in {} iterations\", num_passes);\n         }\n \n         debug!(\"Dataflow result for {}:\", self.analysis_name);\n@@ -543,12 +550,15 @@ impl<'a, 'tcx, O:DataFlowOperator+Clone+'static> DataFlowContext<'a, 'tcx, O> {\n impl<'a, 'b, 'tcx, O:DataFlowOperator> PropagationContext<'a, 'b, 'tcx, O> {\n     fn walk_cfg(&mut self,\n                 cfg: &cfg::CFG,\n+                nodes_po: &[CFGIndex],\n                 in_out: &mut [usize]) {\n         debug!(\"DataFlowContext::walk_cfg(in_out={}) {}\",\n                bits_to_string(in_out), self.dfcx.analysis_name);\n         assert!(self.dfcx.bits_per_id > 0);\n \n-        cfg.graph.each_node(|node_index, node| {\n+        // Iterate over nodes in reverse postorder\n+        for &node_index in nodes_po.iter().rev() {\n+            let node = cfg.graph.node(node_index);\n             debug!(\"DataFlowContext::walk_cfg idx={:?} id={} begin in_out={}\",\n                    node_index, node.data.id(), bits_to_string(in_out));\n \n@@ -563,8 +573,7 @@ impl<'a, 'b, 'tcx, O:DataFlowOperator> PropagationContext<'a, 'b, 'tcx, O> {\n \n             // Propagate state on-exit from node into its successors.\n             self.propagate_bits_into_graph_successors_of(in_out, cfg, node_index);\n-            true // continue to next node\n-        });\n+        }\n     }\n \n     fn reset(&mut self, bits: &mut [usize]) {"}, {"sha": "f562ae0e3b84d2641f9e99a1781b806fcd294dc0", "filename": "src/librustc_data_structures/graph/mod.rs", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/2bb6d3dd890cd446147346dced0615b4612a34a5/src%2Flibrustc_data_structures%2Fgraph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bb6d3dd890cd446147346dced0615b4612a34a5/src%2Flibrustc_data_structures%2Fgraph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fgraph%2Fmod.rs?ref=2bb6d3dd890cd446147346dced0615b4612a34a5", "patch": "@@ -308,6 +308,42 @@ impl<N: Debug, E: Debug> Graph<N, E> {\n         DepthFirstTraversal::with_start_node(self, start, direction)\n     }\n \n+    pub fn nodes_in_postorder<'a>(&'a self,\n+                                  direction: Direction,\n+                                  entry_node: NodeIndex)\n+                                  -> Vec<NodeIndex>\n+    {\n+        let mut visited = BitVector::new(self.len_nodes());\n+        let mut stack = vec![];\n+        let mut result = Vec::with_capacity(self.len_nodes());\n+        let mut push_node = |stack: &mut Vec<_>, node: NodeIndex| {\n+            if visited.insert(node.0) {\n+                stack.push((node, self.adjacent_edges(node, direction)));\n+            }\n+        };\n+\n+        for node in Some(entry_node).into_iter()\n+            .chain(self.enumerated_nodes().map(|(node, _)| node))\n+        {\n+            push_node(&mut stack, node);\n+            while let Some((node, mut iter)) = stack.pop() {\n+                if let Some((_, child)) = iter.next() {\n+                    let target = child.source_or_target(direction);\n+                    // the current node needs more processing, so\n+                    // add it back to the stack\n+                    stack.push((node, iter));\n+                    // and then push the new node\n+                    push_node(&mut stack, target);\n+                } else {\n+                    result.push(node);\n+                }\n+            }\n+        }\n+\n+        assert_eq!(result.len(), self.len_nodes());\n+        result\n+    }\n+\n     /// Whether or not a node can be reached from itself.\n     pub fn is_node_cyclic(&self, starting_node_index: NodeIndex) -> bool {\n         // This is similar to depth traversal below, but we"}, {"sha": "b6a0d4cff5a38608dbdb7f8d452ad634a078b8ef", "filename": "src/librustc_data_structures/graph/tests.rs", "status": "modified", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/2bb6d3dd890cd446147346dced0615b4612a34a5/src%2Flibrustc_data_structures%2Fgraph%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bb6d3dd890cd446147346dced0615b4612a34a5/src%2Flibrustc_data_structures%2Fgraph%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fgraph%2Ftests.rs?ref=2bb6d3dd890cd446147346dced0615b4612a34a5", "patch": "@@ -175,3 +175,46 @@ fn is_node_cyclic_b() {\n     let graph = create_graph_with_cycle();\n     assert!(graph.is_node_cyclic(NodeIndex(1)));\n }\n+\n+#[test]\n+fn nodes_in_postorder() {\n+    let expected = vec![\n+        (\"A\", vec![\"C\", \"E\", \"D\", \"B\", \"A\", \"F\"]),\n+        (\"B\", vec![\"C\", \"E\", \"D\", \"B\", \"A\", \"F\"]),\n+        (\"C\", vec![\"C\", \"E\", \"D\", \"B\", \"A\", \"F\"]),\n+        (\"D\", vec![\"C\", \"E\", \"D\", \"B\", \"A\", \"F\"]),\n+        (\"E\", vec![\"C\", \"E\", \"D\", \"B\", \"A\", \"F\"]),\n+        (\"F\", vec![\"C\", \"E\", \"D\", \"B\", \"F\", \"A\"])\n+    ];\n+\n+    let graph = create_graph();\n+\n+    for ((idx, node), &(node_name, ref expected))\n+        in graph.enumerated_nodes().zip(&expected)\n+    {\n+        assert_eq!(node.data, node_name);\n+        assert_eq!(expected,\n+                   &graph.nodes_in_postorder(OUTGOING, idx)\n+                   .into_iter().map(|idx| *graph.node_data(idx))\n+                   .collect::<Vec<&str>>());\n+    }\n+\n+    let expected = vec![\n+        (\"A\", vec![\"D\", \"C\", \"B\", \"A\"]),\n+        (\"B\", vec![\"D\", \"C\", \"B\", \"A\"]),\n+        (\"C\", vec![\"B\", \"D\", \"C\", \"A\"]),\n+        (\"D\", vec![\"C\", \"B\", \"D\", \"A\"]),\n+    ];\n+\n+    let graph = create_graph_with_cycle();\n+\n+    for ((idx, node), &(node_name, ref expected))\n+        in graph.enumerated_nodes().zip(&expected)\n+    {\n+        assert_eq!(node.data, node_name);\n+        assert_eq!(expected,\n+                   &graph.nodes_in_postorder(OUTGOING, idx)\n+                   .into_iter().map(|idx| *graph.node_data(idx))\n+                   .collect::<Vec<&str>>());\n+    }\n+}"}]}