{"sha": "a9cd294cf2775441e713c7ee2918b728733b99f5", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE5Y2QyOTRjZjI3NzU0NDFlNzEzYzdlZTI5MThiNzI4NzMzYjk5ZjU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-10-22T14:40:20Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-10-22T14:40:20Z"}, "message": "Auto merge of #77720 - matthewjasper:fix-trait-ices, r=nikomatsakis\n\nFix trait solving ICEs\n\n- Selection candidates that are known to be applicable are preferred\n  over candidates that are not.\n- Don't ICE if a projection/object candidate is no longer applicable\n  (this can happen due to cycles in normalization)\n- Normalize supertraits when finding trait object candidates\n\nCloses #77653\nCloses #77656\n\nr? `@nikomatsakis`", "tree": {"sha": "e51c982b0fb305f639a6b5bd59c43a20c267a407", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e51c982b0fb305f639a6b5bd59c43a20c267a407"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a9cd294cf2775441e713c7ee2918b728733b99f5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a9cd294cf2775441e713c7ee2918b728733b99f5", "html_url": "https://github.com/rust-lang/rust/commit/a9cd294cf2775441e713c7ee2918b728733b99f5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a9cd294cf2775441e713c7ee2918b728733b99f5/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "500ddc5efda9d4b0c8f90b654d220ffc9e24ecb5", "url": "https://api.github.com/repos/rust-lang/rust/commits/500ddc5efda9d4b0c8f90b654d220ffc9e24ecb5", "html_url": "https://github.com/rust-lang/rust/commit/500ddc5efda9d4b0c8f90b654d220ffc9e24ecb5"}, {"sha": "50dde2e4d842a65f4c04bd8e27626ba6f1656849", "url": "https://api.github.com/repos/rust-lang/rust/commits/50dde2e4d842a65f4c04bd8e27626ba6f1656849", "html_url": "https://github.com/rust-lang/rust/commit/50dde2e4d842a65f4c04bd8e27626ba6f1656849"}], "stats": {"total": 227, "additions": 141, "deletions": 86}, "files": [{"sha": "c570ad3273d4e3dcbd81c12911dd908c53b93ed6", "filename": "compiler/rustc_middle/src/traits/select.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a9cd294cf2775441e713c7ee2918b728733b99f5/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cd294cf2775441e713c7ee2918b728733b99f5/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fselect.rs?ref=a9cd294cf2775441e713c7ee2918b728733b99f5", "patch": "@@ -127,7 +127,10 @@ pub enum SelectionCandidate<'tcx> {\n \n     TraitAliasCandidate(DefId),\n \n-    ObjectCandidate,\n+    /// Matching `dyn Trait` with a supertrait of `Trait`. The index is the\n+    /// position in the iterator returned by\n+    /// `rustc_infer::traits::util::supertraits`.\n+    ObjectCandidate(usize),\n \n     BuiltinObjectCandidate,\n "}, {"sha": "b0bfb4ad173719c791a3f228f87997aac1c11a50", "filename": "compiler/rustc_trait_selection/src/traits/select/candidate_assembly.rs", "status": "modified", "additions": 17, "deletions": 11, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/a9cd294cf2775441e713c7ee2918b728733b99f5/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cd294cf2775441e713c7ee2918b728733b99f5/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs?ref=a9cd294cf2775441e713c7ee2918b728733b99f5", "patch": "@@ -642,24 +642,30 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n             debug!(?poly_trait_ref, \"assemble_candidates_from_object_ty\");\n \n+            let poly_trait_predicate = self.infcx().resolve_vars_if_possible(&obligation.predicate);\n+            let placeholder_trait_predicate =\n+                self.infcx().replace_bound_vars_with_placeholders(&poly_trait_predicate);\n+\n             // Count only those upcast versions that match the trait-ref\n             // we are looking for. Specifically, do not only check for the\n             // correct trait, but also the correct type parameters.\n             // For example, we may be trying to upcast `Foo` to `Bar<i32>`,\n             // but `Foo` is declared as `trait Foo: Bar<u32>`.\n-            let upcast_trait_refs = util::supertraits(self.tcx(), poly_trait_ref)\n-                .filter(|upcast_trait_ref| {\n-                    self.infcx\n-                        .probe(|_| self.match_poly_trait_ref(obligation, *upcast_trait_ref).is_ok())\n+            let candidate_supertraits = util::supertraits(self.tcx(), poly_trait_ref)\n+                .enumerate()\n+                .filter(|&(_, upcast_trait_ref)| {\n+                    self.infcx.probe(|_| {\n+                        self.match_normalize_trait_ref(\n+                            obligation,\n+                            upcast_trait_ref,\n+                            placeholder_trait_predicate.trait_ref,\n+                        )\n+                        .is_ok()\n+                    })\n                 })\n-                .count();\n+                .map(|(idx, _)| ObjectCandidate(idx));\n \n-            if upcast_trait_refs > 1 {\n-                // Can be upcast in many ways; need more type information.\n-                candidates.ambiguous = true;\n-            } else if upcast_trait_refs == 1 {\n-                candidates.vec.push(ObjectCandidate);\n-            }\n+            candidates.vec.extend(candidate_supertraits);\n         })\n     }\n "}, {"sha": "872b8e85f563fa1bbcd191b1628298a91159ef13", "filename": "compiler/rustc_trait_selection/src/traits/select/confirmation.rs", "status": "modified", "additions": 44, "deletions": 53, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/a9cd294cf2775441e713c7ee2918b728733b99f5/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cd294cf2775441e713c7ee2918b728733b99f5/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs?ref=a9cd294cf2775441e713c7ee2918b728733b99f5", "patch": "@@ -69,10 +69,15 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             }\n \n             ProjectionCandidate(idx) => {\n-                let obligations = self.confirm_projection_candidate(obligation, idx);\n+                let obligations = self.confirm_projection_candidate(obligation, idx)?;\n                 Ok(ImplSource::Param(obligations))\n             }\n \n+            ObjectCandidate(idx) => {\n+                let data = self.confirm_object_candidate(obligation, idx)?;\n+                Ok(ImplSource::Object(data))\n+            }\n+\n             ClosureCandidate => {\n                 let vtable_closure = self.confirm_closure_candidate(obligation)?;\n                 Ok(ImplSource::Closure(vtable_closure))\n@@ -97,11 +102,6 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 Ok(ImplSource::TraitAlias(data))\n             }\n \n-            ObjectCandidate => {\n-                let data = self.confirm_object_candidate(obligation);\n-                Ok(ImplSource::Object(data))\n-            }\n-\n             BuiltinObjectCandidate => {\n                 // This indicates something like `Trait + Send: Send`. In this case, we know that\n                 // this holds because that's what the object type is telling us, and there's really\n@@ -120,7 +120,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         &mut self,\n         obligation: &TraitObligation<'tcx>,\n         idx: usize,\n-    ) -> Vec<PredicateObligation<'tcx>> {\n+    ) -> Result<Vec<PredicateObligation<'tcx>>, SelectionError<'tcx>> {\n         self.infcx.commit_unconditionally(|_| {\n             let tcx = self.tcx();\n \n@@ -148,19 +148,13 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 &mut obligations,\n             );\n \n-            obligations.extend(\n+            obligations.extend(self.infcx.commit_if_ok(|_| {\n                 self.infcx\n                     .at(&obligation.cause, obligation.param_env)\n                     .sup(placeholder_trait_predicate.trait_ref.to_poly_trait_ref(), candidate)\n                     .map(|InferOk { obligations, .. }| obligations)\n-                    .unwrap_or_else(|_| {\n-                        bug!(\n-                            \"Projection bound `{:?}` was applicable to `{:?}` but now is not\",\n-                            candidate,\n-                            obligation\n-                        );\n-                    }),\n-            );\n+                    .map_err(|_| Unimplemented)\n+            })?);\n \n             if let ty::Projection(..) = placeholder_self_ty.kind() {\n                 for predicate in tcx.predicates_of(def_id).instantiate_own(tcx, substs).predicates {\n@@ -181,7 +175,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 }\n             }\n \n-            obligations\n+            Ok(obligations)\n         })\n     }\n \n@@ -371,9 +365,10 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     fn confirm_object_candidate(\n         &mut self,\n         obligation: &TraitObligation<'tcx>,\n-    ) -> ImplSourceObjectData<'tcx, PredicateObligation<'tcx>> {\n-        debug!(?obligation, \"confirm_object_candidate\");\n+        index: usize,\n+    ) -> Result<ImplSourceObjectData<'tcx, PredicateObligation<'tcx>>, SelectionError<'tcx>> {\n         let tcx = self.tcx();\n+        debug!(?obligation, ?index, \"confirm_object_candidate\");\n \n         let trait_predicate =\n             self.infcx.replace_bound_vars_with_placeholders(&obligation.predicate);\n@@ -399,43 +394,39 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             })\n             .with_self_ty(self.tcx(), self_ty);\n \n-        let mut upcast_trait_ref = None;\n         let mut nested = vec![];\n-        let vtable_base;\n \n-        {\n-            // We want to find the first supertrait in the list of\n-            // supertraits that we can unify with, and do that\n-            // unification. We know that there is exactly one in the list\n-            // where we can unify, because otherwise select would have\n-            // reported an ambiguity. (When we do find a match, also\n-            // record it for later.)\n-            let nonmatching = util::supertraits(tcx, ty::Binder::dummy(object_trait_ref))\n-                .take_while(|&t| {\n-                    match self.infcx.commit_if_ok(|_| {\n-                        self.infcx\n-                            .at(&obligation.cause, obligation.param_env)\n-                            .sup(obligation_trait_ref, t)\n-                            .map(|InferOk { obligations, .. }| obligations)\n-                            .map_err(|_| ())\n-                    }) {\n-                        Ok(obligations) => {\n-                            upcast_trait_ref = Some(t);\n-                            nested.extend(obligations);\n-                            false\n-                        }\n-                        Err(_) => true,\n-                    }\n-                });\n+        let mut supertraits = util::supertraits(tcx, ty::Binder::dummy(object_trait_ref));\n \n-            // Additionally, for each of the non-matching predicates that\n-            // we pass over, we sum up the set of number of vtable\n-            // entries, so that we can compute the offset for the selected\n-            // trait.\n-            vtable_base = nonmatching.map(|t| super::util::count_own_vtable_entries(tcx, t)).sum();\n-        }\n+        // For each of the non-matching predicates that\n+        // we pass over, we sum up the set of number of vtable\n+        // entries, so that we can compute the offset for the selected\n+        // trait.\n+        let vtable_base = supertraits\n+            .by_ref()\n+            .take(index)\n+            .map(|t| super::util::count_own_vtable_entries(tcx, t))\n+            .sum();\n+\n+        let unnormalized_upcast_trait_ref =\n+            supertraits.next().expect(\"supertraits iterator no longer has as many elements\");\n+\n+        let upcast_trait_ref = normalize_with_depth_to(\n+            self,\n+            obligation.param_env,\n+            obligation.cause.clone(),\n+            obligation.recursion_depth + 1,\n+            &unnormalized_upcast_trait_ref,\n+            &mut nested,\n+        );\n \n-        let upcast_trait_ref = upcast_trait_ref.unwrap();\n+        nested.extend(self.infcx.commit_if_ok(|_| {\n+            self.infcx\n+                .at(&obligation.cause, obligation.param_env)\n+                .sup(obligation_trait_ref, upcast_trait_ref)\n+                .map(|InferOk { obligations, .. }| obligations)\n+                .map_err(|_| Unimplemented)\n+        })?);\n \n         // Check supertraits hold. This is so that their associated type bounds\n         // will be checked in the code below.\n@@ -501,7 +492,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         }\n \n         debug!(?nested, \"object nested obligations\");\n-        ImplSourceObjectData { upcast_trait_ref, vtable_base, nested }\n+        Ok(ImplSourceObjectData { upcast_trait_ref, vtable_base, nested })\n     }\n \n     fn confirm_fn_pointer_candidate("}, {"sha": "4cc4bc0acdab68923116058b5c4b1b15ccb9af6c", "filename": "compiler/rustc_trait_selection/src/traits/select/mod.rs", "status": "modified", "additions": 14, "deletions": 21, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/a9cd294cf2775441e713c7ee2918b728733b99f5/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cd294cf2775441e713c7ee2918b728733b99f5/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs?ref=a9cd294cf2775441e713c7ee2918b728733b99f5", "patch": "@@ -518,12 +518,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                             result\n                         }\n                         Ok(Ok(None)) => Ok(EvaluatedToAmbig),\n-                        // EvaluatedToRecur might also be acceptable here, but use\n-                        // Unknown for now because it means that we won't dismiss a\n-                        // selection candidate solely because it has a projection\n-                        // cycle. This is closest to the previous behavior of\n-                        // immediately erroring.\n-                        Ok(Err(project::InProgress)) => Ok(EvaluatedToUnknown),\n+                        Ok(Err(project::InProgress)) => Ok(EvaluatedToRecur),\n                         Err(_) => Ok(EvaluatedToErr),\n                     }\n                 }\n@@ -1179,7 +1174,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 if let ty::PredicateAtom::Trait(pred, _) = bound_predicate.skip_binder() {\n                     let bound = bound_predicate.rebind(pred.trait_ref);\n                     if self.infcx.probe(|_| {\n-                        match self.match_projection(\n+                        match self.match_normalize_trait_ref(\n                             obligation,\n                             bound,\n                             placeholder_trait_predicate.trait_ref,\n@@ -1207,7 +1202,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     /// Equates the trait in `obligation` with trait bound. If the two traits\n     /// can be equated and the normalized trait bound doesn't contain inference\n     /// variables or placeholders, the normalized bound is returned.\n-    fn match_projection(\n+    fn match_normalize_trait_ref(\n         &mut self,\n         obligation: &TraitObligation<'tcx>,\n         trait_bound: ty::PolyTraitRef<'tcx>,\n@@ -1357,10 +1352,10 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 | BuiltinUnsizeCandidate\n                 | BuiltinCandidate { .. }\n                 | TraitAliasCandidate(..)\n-                | ObjectCandidate\n+                | ObjectCandidate(_)\n                 | ProjectionCandidate(_),\n             ) => !is_global(cand),\n-            (ObjectCandidate | ProjectionCandidate(_), ParamCandidate(ref cand)) => {\n+            (ObjectCandidate(_) | ProjectionCandidate(_), ParamCandidate(ref cand)) => {\n                 // Prefer these to a global where-clause bound\n                 // (see issue #50825).\n                 is_global(cand)\n@@ -1381,20 +1376,20 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 is_global(cand) && other.evaluation.must_apply_modulo_regions()\n             }\n \n-            (ProjectionCandidate(i), ProjectionCandidate(j)) => {\n-                // Arbitrarily pick the first candidate for backwards\n+            (ProjectionCandidate(i), ProjectionCandidate(j))\n+            | (ObjectCandidate(i), ObjectCandidate(j)) => {\n+                // Arbitrarily pick the lower numbered candidate for backwards\n                 // compatibility reasons. Don't let this affect inference.\n-                i > j && !needs_infer\n+                i < j && !needs_infer\n             }\n-            (ObjectCandidate, ObjectCandidate) => bug!(\"Duplicate object candidate\"),\n-            (ObjectCandidate, ProjectionCandidate(_))\n-            | (ProjectionCandidate(_), ObjectCandidate) => {\n+            (ObjectCandidate(_), ProjectionCandidate(_))\n+            | (ProjectionCandidate(_), ObjectCandidate(_)) => {\n                 bug!(\"Have both object and projection candidate\")\n             }\n \n             // Arbitrarily give projection and object candidates priority.\n             (\n-                ObjectCandidate | ProjectionCandidate(_),\n+                ObjectCandidate(_) | ProjectionCandidate(_),\n                 ImplCandidate(..)\n                 | ClosureCandidate\n                 | GeneratorCandidate\n@@ -1414,7 +1409,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 | BuiltinUnsizeCandidate\n                 | BuiltinCandidate { .. }\n                 | TraitAliasCandidate(..),\n-                ObjectCandidate | ProjectionCandidate(_),\n+                ObjectCandidate(_) | ProjectionCandidate(_),\n             ) => false,\n \n             (&ImplCandidate(other_def), &ImplCandidate(victim_def)) => {\n@@ -1890,9 +1885,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n     /// Normalize `where_clause_trait_ref` and try to match it against\n     /// `obligation`. If successful, return any predicates that\n-    /// result from the normalization. Normalization is necessary\n-    /// because where-clauses are stored in the parameter environment\n-    /// unnormalized.\n+    /// result from the normalization.\n     fn match_where_clause_trait_ref(\n         &mut self,\n         obligation: &TraitObligation<'tcx>,"}, {"sha": "9c1a488e9517534e671a4a3067c86734ccbd5158", "filename": "src/test/ui/associated-types/normalization-probe-cycle.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/a9cd294cf2775441e713c7ee2918b728733b99f5/src%2Ftest%2Fui%2Fassociated-types%2Fnormalization-probe-cycle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cd294cf2775441e713c7ee2918b728733b99f5/src%2Ftest%2Fui%2Fassociated-types%2Fnormalization-probe-cycle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fnormalization-probe-cycle.rs?ref=a9cd294cf2775441e713c7ee2918b728733b99f5", "patch": "@@ -0,0 +1,25 @@\n+// Regression test for #77656\n+\n+// check-pass\n+\n+trait Value: PartialOrd {}\n+\n+impl<T: PartialOrd> Value for T {}\n+\n+trait Distance\n+where\n+    Self: PartialOrd<<Self as Distance>::Value>,\n+    Self: PartialOrd,\n+{\n+    type Value: Value;\n+}\n+\n+impl<T: Value> Distance for T {\n+    type Value = T;\n+}\n+\n+trait Proximity<T = Self> {\n+    type Distance: Distance;\n+}\n+\n+fn main() {}"}, {"sha": "021a93eacff1f1caef3933149d34f0ce7e6f7994", "filename": "src/test/ui/traits/normalize-super-trait.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/a9cd294cf2775441e713c7ee2918b728733b99f5/src%2Ftest%2Fui%2Ftraits%2Fnormalize-super-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cd294cf2775441e713c7ee2918b728733b99f5/src%2Ftest%2Fui%2Ftraits%2Fnormalize-super-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fnormalize-super-trait.rs?ref=a9cd294cf2775441e713c7ee2918b728733b99f5", "patch": "@@ -0,0 +1,37 @@\n+// Regression test for #77653\n+// When monomorphizing `f` we need to prove `dyn Derived<()>: Base<()>`. This\n+// requires us to normalize the `Base<<() as Proj>::S>` to `Base<()>` when\n+// comparing the supertrait `Derived<()>` to the expected trait.\n+\n+// build-pass\n+\n+trait Proj {\n+    type S;\n+}\n+\n+impl Proj for () {\n+    type S = ();\n+}\n+\n+impl Proj for i32 {\n+    type S = i32;\n+}\n+\n+trait Base<T> {\n+    fn is_base(&self);\n+}\n+\n+trait Derived<B: Proj>: Base<B::S> + Base<()> {\n+    fn is_derived(&self);\n+}\n+\n+fn f<P: Proj>(obj: &dyn Derived<P>) {\n+    obj.is_derived();\n+    Base::<P::S>::is_base(obj);\n+    Base::<()>::is_base(obj);\n+}\n+\n+fn main() {\n+    let x: fn(_) = f::<()>;\n+    let x: fn(_) = f::<i32>;\n+}"}]}