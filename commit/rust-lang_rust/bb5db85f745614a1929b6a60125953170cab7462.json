{"sha": "bb5db85f745614a1929b6a60125953170cab7462", "node_id": "C_kwDOAAsO6NoAKGJiNWRiODVmNzQ1NjE0YTE5MjliNmE2MDEyNTk1MzE3MGNhYjc0NjI", "commit": {"author": {"name": "Nick Cameron", "email": "nrc@ncameron.org", "date": "2021-12-15T16:17:16Z"}, "committer": {"name": "Nick Cameron", "email": "nrc@ncameron.org", "date": "2022-06-06T11:10:13Z"}, "message": "Add the Provider api to core::any\n\nSigned-off-by: Nick Cameron <nrc@ncameron.org>", "tree": {"sha": "b3961a761b67e729c7c80151a461cb5e4c59adfa", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b3961a761b67e729c7c80151a461cb5e4c59adfa"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bb5db85f745614a1929b6a60125953170cab7462", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bb5db85f745614a1929b6a60125953170cab7462", "html_url": "https://github.com/rust-lang/rust/commit/bb5db85f745614a1929b6a60125953170cab7462", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bb5db85f745614a1929b6a60125953170cab7462/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6609c6734de4df43e24d7672f8ae8786ecc8047e", "url": "https://api.github.com/repos/rust-lang/rust/commits/6609c6734de4df43e24d7672f8ae8786ecc8047e", "html_url": "https://github.com/rust-lang/rust/commit/6609c6734de4df43e24d7672f8ae8786ecc8047e"}], "stats": {"total": 296, "additions": 293, "deletions": 3}, "files": [{"sha": "1ca4e813443eb6da1cdaa481bea2b468cc8b2cea", "filename": "library/core/src/any.rs", "status": "modified", "additions": 270, "deletions": 3, "changes": 273, "blob_url": "https://github.com/rust-lang/rust/blob/bb5db85f745614a1929b6a60125953170cab7462/library%2Fcore%2Fsrc%2Fany.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb5db85f745614a1929b6a60125953170cab7462/library%2Fcore%2Fsrc%2Fany.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fany.rs?ref=bb5db85f745614a1929b6a60125953170cab7462", "patch": "@@ -1,5 +1,9 @@\n-//! This module implements the `Any` trait, which enables dynamic typing\n-//! of any `'static` type through runtime reflection.\n+//! This module contains the `Any` trait, which enables dynamic typing\n+//! of any `'static` type through runtime reflection. It also contains the\n+//! `Provider` trait and accompanying API, which enable trait objects to provide\n+//! data based on typed requests, an alternate form of runtime reflection.\n+//!\n+//! # `Any` and `TypeId`\n //!\n //! `Any` itself can be used to get a `TypeId`, and has more features when used\n //! as a trait object. As `&dyn Any` (a borrowed trait object), it has the `is`\n@@ -37,7 +41,7 @@\n //! assert_eq!(boxed_id, TypeId::of::<Box<dyn Any>>());\n //! ```\n //!\n-//! # Examples\n+//! ## Examples\n //!\n //! Consider a situation where we want to log out a value passed to a function.\n //! We know the value we're working on implements Debug, but we don't know its\n@@ -81,11 +85,76 @@\n //!     do_work(&my_i8);\n //! }\n //! ```\n+//!\n+//! # `Provider` and `Demand`\n+//!\n+//! `Provider` and the associated APIs support generic, type-driven access to data, and a mechanism\n+//! for implementers to provide such data. The key parts of the interface are the `Provider`\n+//! trait for objects which can provide data, and the [`request_value`] and [`request_ref`]\n+//! functions for requesting data from an object which implements `Provider`. Note that end users\n+//! should not call `request_*` directly, they are helper functions for intermediate implementers\n+//! to use to implement a user-facing interface.\n+//!\n+//! Typically, a data provider is a trait object of a trait which extends `Provider`. A user will\n+//! request data from the trait object by specifying the type.\n+//!\n+//! ## Data flow\n+//!\n+//! * A user requests an object, which is delegated to `request_value` or `request_ref`\n+//! * `request_*` creates a `Demand` object and passes it to `Provider::provide`\n+//! * The object provider's implementation of `Provider::provide` tries providing values of\n+//!   different types using `Demand::provide_*`. If the type matches the type requested by\n+//!   the user, it will be stored in the `Demand` object.\n+//! * `request_*` unpacks the `Demand` object and returns any stored value to the user.\n+//!\n+//! ## Examples\n+//!\n+//! ```\n+//! # #![allow(incomplete_features)]\n+//! # #![feature(provide_any)]\n+//! # #![feature(trait_upcasting)]\n+//! use std::any::{Provider, Demand, request_ref};\n+//!\n+//! // Definition of MyTrait\n+//! trait MyTrait: Provider {\n+//!     // ...\n+//! }\n+//!\n+//! // Methods on `MyTrait` trait objects.\n+//! impl dyn MyTrait + '_ {\n+//!     /// Common case: get a reference to a field of the error.\n+//!     pub fn get_context_ref<T: ?Sized + 'static>(&self) -> Option<&T> {\n+//!         request_ref::<T>(self)\n+//!     }\n+//! }\n+//!\n+//! // Downstream implementation of `MyTrait` and `Provider`.\n+//! # struct SomeConcreteType { some_string: String }\n+//! impl MyTrait for SomeConcreteType {\n+//!     // ...\n+//! }\n+//!\n+//! impl Provider for SomeConcreteType {\n+//!     fn provide<'a>(&'a self, req: &mut Demand<'a>) {\n+//!         req.provide_ref::<String>(&self.some_string);\n+//!     }\n+//! }\n+//!\n+//! // Downstream usage of `MyTrait`.\n+//! fn use_my_trait(obj: &dyn MyTrait) {\n+//!     // Request a &String from obj.\n+//!     let _ = obj.get_context_ref::<String>().unwrap();\n+//! }\n+//! ```\n+//!\n+//! In this example, if the concrete type of `obj` in `use_my_trait` is `SomeConcreteType`, then\n+//! the `get_context_ref` call will return a reference to `obj.some_string`.\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n use crate::fmt;\n use crate::intrinsics;\n+use crate::mem::transmute;\n \n ///////////////////////////////////////////////////////////////////////////////\n // Any trait\n@@ -700,3 +769,201 @@ pub const fn type_name<T: ?Sized>() -> &'static str {\n pub const fn type_name_of_val<T: ?Sized>(_val: &T) -> &'static str {\n     type_name::<T>()\n }\n+\n+///////////////////////////////////////////////////////////////////////////////\n+// Provider trait\n+///////////////////////////////////////////////////////////////////////////////\n+\n+/// Trait implemented by a type which can dynamically provide values based on type.\n+#[unstable(feature = \"provide_any\", issue = \"none\")]\n+pub trait Provider {\n+    /// Object providers should implement this method to provide *all* values they are able to\n+    /// provide using `req`.\n+    #[unstable(feature = \"provide_any\", issue = \"none\")]\n+    fn provide<'a>(&'a self, req: &mut Demand<'a>);\n+}\n+\n+/// Request a value from the `Provider`.\n+#[unstable(feature = \"provide_any\", issue = \"none\")]\n+pub fn request_value<'a, T: 'static>(provider: &'a dyn Provider) -> Option<T> {\n+    request_by_type_tag::<'a, tags::Value<T>>(provider)\n+}\n+\n+/// Request a reference from the `Provider`.\n+#[unstable(feature = \"provide_any\", issue = \"none\")]\n+pub fn request_ref<'a, T: ?Sized + 'static>(provider: &'a dyn Provider) -> Option<&'a T> {\n+    request_by_type_tag::<'a, tags::Ref<tags::MaybeSizedValue<T>>>(provider)\n+}\n+\n+/// Request a specific value by tag from the `Provider`.\n+fn request_by_type_tag<'a, I>(provider: &'a dyn Provider) -> Option<I::Reified>\n+where\n+    I: tags::Type<'a>,\n+{\n+    let mut tagged = TaggedOption::<'a, I>(None);\n+    provider.provide(tagged.as_demand());\n+    tagged.0\n+}\n+\n+///////////////////////////////////////////////////////////////////////////////\n+// Demand and its methods\n+///////////////////////////////////////////////////////////////////////////////\n+\n+/// A helper object for providing objects by type.\n+///\n+/// An object provider provides values by calling this type's provide methods.\n+#[allow(missing_debug_implementations)]\n+#[unstable(feature = \"provide_any\", issue = \"none\")]\n+// SAFETY: `TaggedOption::as_demand` relies on this precise definition.\n+#[repr(transparent)]\n+pub struct Demand<'a>(dyn Erased<'a> + 'a);\n+\n+impl<'a> Demand<'a> {\n+    /// Provide a value or other type with only static lifetimes.\n+    #[unstable(feature = \"provide_any\", issue = \"none\")]\n+    pub fn provide_value<T, F>(&mut self, fulfil: F) -> &mut Self\n+    where\n+        T: 'static,\n+        F: FnOnce() -> T,\n+    {\n+        self.provide_with::<tags::Value<T>, F>(fulfil)\n+    }\n+\n+    /// Provide a reference, note that the referee type must be bounded by `'static`, but may be unsized.\n+    #[unstable(feature = \"provide_any\", issue = \"none\")]\n+    pub fn provide_ref<T: ?Sized + 'static>(&mut self, value: &'a T) -> &mut Self {\n+        self.provide::<tags::Ref<tags::MaybeSizedValue<T>>>(value)\n+    }\n+\n+    /// Provide a value with the given `Type` tag.\n+    fn provide<I>(&mut self, value: I::Reified) -> &mut Self\n+    where\n+        I: tags::Type<'a>,\n+    {\n+        if let Some(res @ TaggedOption(None)) = self.0.downcast_mut::<I>() {\n+            res.0 = Some(value);\n+        }\n+        self\n+    }\n+\n+    /// Provide a value with the given `Type` tag, using a closure to prevent unnecessary work.\n+    fn provide_with<I, F>(&mut self, fulfil: F) -> &mut Self\n+    where\n+        I: tags::Type<'a>,\n+        F: FnOnce() -> I::Reified,\n+    {\n+        if let Some(res @ TaggedOption(None)) = self.0.downcast_mut::<I>() {\n+            res.0 = Some(fulfil());\n+        }\n+        self\n+    }\n+}\n+\n+///////////////////////////////////////////////////////////////////////////////\n+// Type tags\n+///////////////////////////////////////////////////////////////////////////////\n+\n+mod tags {\n+    //! Type tags are used to identify a type using a separate value. This module includes type tags\n+    //! for some very common types.\n+    //!\n+    //! Many users of the provider APIs will not need to use type tags at all. But if you want to\n+    //! use them with more complex types (typically those including lifetime parameters), you will\n+    //! need to write your own tags.\n+\n+    use crate::marker::PhantomData;\n+\n+    /// This trait is implemented by specific tag types in order to allow\n+    /// describing a type which can be requested for a given lifetime `'a`.\n+    ///\n+    /// A few example implementations for type-driven tags can be found in this\n+    /// module, although crates may also implement their own tags for more\n+    /// complex types with internal lifetimes.\n+    pub trait Type<'a>: Sized + 'static {\n+        /// The type of values which may be tagged by this tag for the given\n+        /// lifetime.\n+        type Reified: 'a;\n+    }\n+\n+    /// Similar to the [`Type`] trait, but represents a type which may be unsized (i.e., has a\n+    /// `'Sized` bound). E.g., `str`.\n+    pub trait MaybeSizedType<'a>: Sized + 'static {\n+        type Reified: 'a + ?Sized;\n+    }\n+\n+    impl<'a, T: Type<'a>> MaybeSizedType<'a> for T {\n+        type Reified = T::Reified;\n+    }\n+\n+    /// Type-based tag for types bounded by `'static`, i.e., with no borrowed element.\n+    #[derive(Debug)]\n+    pub struct Value<T: 'static>(PhantomData<T>);\n+\n+    impl<'a, T: 'static> Type<'a> for Value<T> {\n+        type Reified = T;\n+    }\n+\n+    /// Type-based tag similar to [`Value`] but which may be unsized (i.e., has a `'Sized` bound).\n+    #[derive(Debug)]\n+    pub struct MaybeSizedValue<T: ?Sized + 'static>(PhantomData<T>);\n+\n+    impl<'a, T: ?Sized + 'static> MaybeSizedType<'a> for MaybeSizedValue<T> {\n+        type Reified = T;\n+    }\n+\n+    /// Type-based tag for `&'a T` types.\n+    #[derive(Debug)]\n+    pub struct Ref<I>(PhantomData<I>);\n+\n+    impl<'a, I: MaybeSizedType<'a>> Type<'a> for Ref<I> {\n+        type Reified = &'a I::Reified;\n+    }\n+}\n+\n+/// An `Option` with a type tag `I`.\n+///\n+/// Since this struct implements `Erased`, the type can be erased to make a dynamically typed\n+/// option. The type can be checked dynamically using `Erased::tag_id` and since this is statically\n+/// checked for the concrete type, there is some degree of type safety.\n+#[repr(transparent)]\n+struct TaggedOption<'a, I: tags::Type<'a>>(Option<I::Reified>);\n+\n+impl<'a, I: tags::Type<'a>> TaggedOption<'a, I> {\n+    fn as_demand(&mut self) -> &mut Demand<'a> {\n+        // SAFETY: transmuting `&mut (dyn Erased<'a> + 'a)` to `&mut Demand<'a>` is safe since\n+        // `Demand` is repr(transparent) and holds only a `dyn Erased<'a> + 'a`.\n+        unsafe { transmute(self as &mut (dyn Erased<'a> + 'a)) }\n+    }\n+}\n+\n+/// Represents a type-erased but identifiable object.\n+///\n+/// This trait is exclusively implemented by the `TaggedOption` type.\n+trait Erased<'a>: 'a {\n+    /// The `TypeId` of the erased type.\n+    fn tag_id(&self) -> TypeId;\n+}\n+\n+impl<'a, I: tags::Type<'a>> Erased<'a> for TaggedOption<'a, I> {\n+    fn tag_id(&self) -> TypeId {\n+        TypeId::of::<I>()\n+    }\n+}\n+\n+#[unstable(feature = \"provide_any\", issue = \"none\")]\n+impl<'a> dyn Erased<'a> {\n+    /// Returns some reference to the dynamic value if it is tagged with `I`,\n+    /// or `None` if it isn't.\n+    #[inline]\n+    fn downcast_mut<I>(&mut self) -> Option<&mut TaggedOption<'a, I>>\n+    where\n+        I: tags::Type<'a>,\n+    {\n+        if self.tag_id() == TypeId::of::<I>() {\n+            // SAFETY: Just checked whether we're pointing to an I.\n+            Some(unsafe { &mut *(self as *mut Self as *mut TaggedOption<'a, I>) })\n+        } else {\n+            None\n+        }\n+    }\n+}"}, {"sha": "bf38207065faf579f09b1e72a7ed2cdb3e83b56f", "filename": "library/core/tests/any.rs", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/bb5db85f745614a1929b6a60125953170cab7462/library%2Fcore%2Ftests%2Fany.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb5db85f745614a1929b6a60125953170cab7462/library%2Fcore%2Ftests%2Fany.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fany.rs?ref=bb5db85f745614a1929b6a60125953170cab7462", "patch": "@@ -130,3 +130,25 @@ fn distinct_type_names() {\n \n     assert_ne!(type_name_of_val(Velocity), type_name_of_val(Velocity(0.0, -9.8)),);\n }\n+\n+// Test the `Provider` API.\n+\n+struct SomeConcreteType {\n+    some_string: String,\n+}\n+\n+impl Provider for SomeConcreteType {\n+    fn provide<'a>(&'a self, req: &mut Demand<'a>) {\n+        req.provide_ref::<String>(&self.some_string)\n+            .provide_value::<String, _>(|| \"bye\".to_owned());\n+    }\n+}\n+\n+#[test]\n+fn test_provider() {\n+    let obj: &dyn Provider = &SomeConcreteType { some_string: \"hello\".to_owned() };\n+\n+    assert_eq!(&**request_ref::<String>(obj).unwrap(), \"hello\");\n+    assert_eq!(&*request_value::<String>(obj).unwrap(), \"bye\");\n+    assert_eq!(request_value::<u8>(obj), None);\n+}"}, {"sha": "d16c265d41a971dbc8f13af9172db2303d885291", "filename": "library/core/tests/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bb5db85f745614a1929b6a60125953170cab7462/library%2Fcore%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb5db85f745614a1929b6a60125953170cab7462/library%2Fcore%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Flib.rs?ref=bb5db85f745614a1929b6a60125953170cab7462", "patch": "@@ -97,6 +97,7 @@\n #![feature(const_slice_from_ref)]\n #![feature(waker_getters)]\n #![feature(slice_flatten)]\n+#![feature(provide_any)]\n #![deny(unsafe_op_in_unsafe_fn)]\n \n extern crate test;"}]}