{"sha": "30ed544948dc12b487e6c307bf76c43785841f8a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMwZWQ1NDQ5NDhkYzEyYjQ4N2U2YzMwN2JmNzZjNDM3ODU4NDFmOGE=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-10-31T01:54:11Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-10-31T01:54:11Z"}, "message": "Rollup merge of #65979 - spastorino:crate-metadata-mutexes, r=Mark-Simulacrum\n\nSwitch CrateMetadata's source_map_import_info from RwLock to Once", "tree": {"sha": "8cb7e61f451d177cfbca4238d78b9b39ca334073", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8cb7e61f451d177cfbca4238d78b9b39ca334073"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/30ed544948dc12b487e6c307bf76c43785841f8a", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJduj7DCRBK7hj4Ov3rIwAAdHIIABvRMIVVV0e/phVTT7JGfmkv\nF54BQLk/nWbGS+AfGQlAdHg5z0/+357SZiDmi1Oj9mf19Z0yfWpCcIMUNYjKY6vE\nneJEdquwe0vxSqfnHTVTyXBh0mu5NFzAr2RpjKiGEoZ7u/rL6I7UCQy9xQxjQyBr\nN+rcIuYfzXpEFvgifAIvNH89nqYBOOuHjJCaPogDBpyDyFbYqd7n0olk/93NVfUe\nv6jGhyX3NRd3v15iLiNVz0oZKtpNgVPN3AujH/MSBosaYrS1UxEhaKudUROMaNo2\ndbh8TvsocjnC2YemRJcasn4YlHnJgjiJ0gdGQzYSoId6r2/jTui5flfc59sZz3Y=\n=dSGP\n-----END PGP SIGNATURE-----\n", "payload": "tree 8cb7e61f451d177cfbca4238d78b9b39ca334073\nparent 60fa6d8ac258400a3b4da72019f5edda7e513dbe\nparent 12273cb7f66f463683ad4d6c54b17afe0b7d8422\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1572486851 +0100\ncommitter GitHub <noreply@github.com> 1572486851 +0100\n\nRollup merge of #65979 - spastorino:crate-metadata-mutexes, r=Mark-Simulacrum\n\nSwitch CrateMetadata's source_map_import_info from RwLock to Once\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/30ed544948dc12b487e6c307bf76c43785841f8a", "html_url": "https://github.com/rust-lang/rust/commit/30ed544948dc12b487e6c307bf76c43785841f8a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/30ed544948dc12b487e6c307bf76c43785841f8a/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "60fa6d8ac258400a3b4da72019f5edda7e513dbe", "url": "https://api.github.com/repos/rust-lang/rust/commits/60fa6d8ac258400a3b4da72019f5edda7e513dbe", "html_url": "https://github.com/rust-lang/rust/commit/60fa6d8ac258400a3b4da72019f5edda7e513dbe"}, {"sha": "12273cb7f66f463683ad4d6c54b17afe0b7d8422", "url": "https://api.github.com/repos/rust-lang/rust/commits/12273cb7f66f463683ad4d6c54b17afe0b7d8422", "html_url": "https://github.com/rust-lang/rust/commit/12273cb7f66f463683ad4d6c54b17afe0b7d8422"}], "stats": {"total": 167, "additions": 75, "deletions": 92}, "files": [{"sha": "d111471f53d7d80ad863ca0840423acf914238a2", "filename": "src/librustc_data_structures/sync.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/30ed544948dc12b487e6c307bf76c43785841f8a/src%2Flibrustc_data_structures%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30ed544948dc12b487e6c307bf76c43785841f8a/src%2Flibrustc_data_structures%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fsync.rs?ref=30ed544948dc12b487e6c307bf76c43785841f8a", "patch": "@@ -497,13 +497,15 @@ impl<T> Once<T> {\n     /// If the value was already initialized the closure is not called and `false` is returned,\n     /// otherwise if the value from the closure initializes the inner value, `true` is returned\n     #[inline]\n-    pub fn init_locking<F: FnOnce() -> T>(&self, f: F) -> bool {\n-        let mut lock = self.0.lock();\n-        if lock.is_some() {\n-            return false;\n+    pub fn init_locking<F: FnOnce() -> T>(&self, f: F) -> &T {\n+        {\n+            let mut lock = self.0.lock();\n+            if lock.is_none() {\n+                *lock = Some(f());\n+            }\n         }\n-        *lock = Some(f());\n-        true\n+\n+        self.borrow()\n     }\n \n     /// Tries to initialize the inner value by calling the closure without ensuring that no-one"}, {"sha": "540b06b3a8be99e692201836c32fc11a7b1ca0b8", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/30ed544948dc12b487e6c307bf76c43785841f8a/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30ed544948dc12b487e6c307bf76c43785841f8a/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=30ed544948dc12b487e6c307bf76c43785841f8a", "patch": "@@ -3,7 +3,7 @@\n use crate::cstore::{self, CStore, MetadataBlob};\n use crate::locator::{self, CratePaths};\n use crate::schema::{CrateRoot, CrateDep};\n-use rustc_data_structures::sync::{RwLock, Lock, AtomicCell};\n+use rustc_data_structures::sync::{Lock, Once, AtomicCell};\n \n use rustc::hir::def_id::CrateNum;\n use rustc_data_structures::svh::Svh;\n@@ -249,7 +249,7 @@ impl<'a> CrateLoader<'a> {\n             cnum_map,\n             cnum,\n             dependencies: Lock::new(dependencies),\n-            source_map_import_info: RwLock::new(vec![]),\n+            source_map_import_info: Once::new(),\n             alloc_decoding_state: AllocDecodingState::new(interpret_alloc_index),\n             dep_kind: Lock::new(dep_kind),\n             source,"}, {"sha": "8dfc921c95b3d1205848148a491c2c5b345802a4", "filename": "src/librustc_metadata/cstore.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/30ed544948dc12b487e6c307bf76c43785841f8a/src%2Flibrustc_metadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30ed544948dc12b487e6c307bf76c43785841f8a/src%2Flibrustc_metadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore.rs?ref=30ed544948dc12b487e6c307bf76c43785841f8a", "patch": "@@ -9,7 +9,7 @@ use rustc::middle::cstore::{CrateSource, DepKind, ExternCrate};\n use rustc::mir::interpret::AllocDecodingState;\n use rustc_index::vec::IndexVec;\n use rustc::util::nodemap::FxHashMap;\n-use rustc_data_structures::sync::{Lrc, RwLock, Lock, MetadataRef, AtomicCell};\n+use rustc_data_structures::sync::{Lrc, Lock, MetadataRef, Once, AtomicCell};\n use syntax::ast;\n use syntax::edition::Edition;\n use syntax_expand::base::SyntaxExtension;\n@@ -62,7 +62,7 @@ crate struct CrateMetadata {\n     /// Proc macro descriptions for this crate, if it's a proc macro crate.\n     crate raw_proc_macros: Option<&'static [ProcMacro]>,\n     /// Source maps for code from the crate.\n-    crate source_map_import_info: RwLock<Vec<ImportedSourceFile>>,\n+    crate source_map_import_info: Once<Vec<ImportedSourceFile>>,\n     /// Used for decoding interpret::AllocIds in a cached & thread-safe manner.\n     crate alloc_decoding_state: AllocDecodingState,\n     /// The `DepNodeIndex` of the `DepNode` representing this upstream crate."}, {"sha": "c5954e1ea1d9830e2433ef64e8e4bff57e16abb0", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 63, "deletions": 82, "changes": 145, "blob_url": "https://github.com/rust-lang/rust/blob/30ed544948dc12b487e6c307bf76c43785841f8a/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30ed544948dc12b487e6c307bf76c43785841f8a/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=30ed544948dc12b487e6c307bf76c43785841f8a", "patch": "@@ -5,7 +5,7 @@ use crate::schema::*;\n use crate::table::{FixedSizeEncoding, PerDefTable};\n \n use rustc_index::vec::IndexVec;\n-use rustc_data_structures::sync::{Lrc, ReadGuard};\n+use rustc_data_structures::sync::Lrc;\n use rustc::hir::map::{DefKey, DefPath, DefPathData, DefPathHash};\n use rustc::hir;\n use rustc::middle::cstore::{LinkagePreference, NativeLibrary, ForeignModule};\n@@ -664,7 +664,7 @@ impl<'a, 'tcx> CrateMetadata {\n         tcx: TyCtxt<'tcx>,\n     ) -> ty::GenericPredicates<'tcx> {\n         self.root.per_def.predicates.get(self, item_id).unwrap().decode((self, tcx))\n-}\n+    }\n \n     crate fn get_predicates_defined_on(\n         &self,\n@@ -1290,87 +1290,68 @@ impl<'a, 'tcx> CrateMetadata {\n     fn imported_source_files(\n         &'a self,\n         local_source_map: &source_map::SourceMap,\n-    ) -> ReadGuard<'a, Vec<cstore::ImportedSourceFile>> {\n-        {\n-            let source_files = self.source_map_import_info.borrow();\n-            if !source_files.is_empty() {\n-                return source_files;\n-            }\n-        }\n-\n-        // Lock the source_map_import_info to ensure this only happens once\n-        let mut source_map_import_info = self.source_map_import_info.borrow_mut();\n-\n-        if !source_map_import_info.is_empty() {\n-            drop(source_map_import_info);\n-            return self.source_map_import_info.borrow();\n-        }\n-\n-        let external_source_map = self.root.source_map.decode(self);\n-\n-        let imported_source_files = external_source_map.map(|source_file_to_import| {\n-            // We can't reuse an existing SourceFile, so allocate a new one\n-            // containing the information we need.\n-            let syntax_pos::SourceFile { name,\n-                                      name_was_remapped,\n-                                      src_hash,\n-                                      start_pos,\n-                                      end_pos,\n-                                      mut lines,\n-                                      mut multibyte_chars,\n-                                      mut non_narrow_chars,\n-                                      mut normalized_pos,\n-                                      name_hash,\n-                                      .. } = source_file_to_import;\n-\n-            let source_length = (end_pos - start_pos).to_usize();\n-\n-            // Translate line-start positions and multibyte character\n-            // position into frame of reference local to file.\n-            // `SourceMap::new_imported_source_file()` will then translate those\n-            // coordinates to their new global frame of reference when the\n-            // offset of the SourceFile is known.\n-            for pos in &mut lines {\n-                *pos = *pos - start_pos;\n-            }\n-            for mbc in &mut multibyte_chars {\n-                mbc.pos = mbc.pos - start_pos;\n-            }\n-            for swc in &mut non_narrow_chars {\n-                *swc = *swc - start_pos;\n-            }\n-            for np in &mut normalized_pos {\n-                np.pos = np.pos - start_pos;\n-            }\n-\n-            let local_version = local_source_map.new_imported_source_file(name,\n-                                                                   name_was_remapped,\n-                                                                   self.cnum.as_u32(),\n-                                                                   src_hash,\n-                                                                   name_hash,\n-                                                                   source_length,\n-                                                                   lines,\n-                                                                   multibyte_chars,\n-                                                                   non_narrow_chars,\n-                                                                   normalized_pos);\n-            debug!(\"CrateMetaData::imported_source_files alloc \\\n-                    source_file {:?} original (start_pos {:?} end_pos {:?}) \\\n-                    translated (start_pos {:?} end_pos {:?})\",\n-                   local_version.name, start_pos, end_pos,\n-                   local_version.start_pos, local_version.end_pos);\n-\n-            cstore::ImportedSourceFile {\n-                original_start_pos: start_pos,\n-                original_end_pos: end_pos,\n-                translated_source_file: local_version,\n-            }\n-        }).collect();\n-\n-        *source_map_import_info = imported_source_files;\n-        drop(source_map_import_info);\n+    ) -> &[cstore::ImportedSourceFile] {\n+        self.source_map_import_info.init_locking(|| {\n+            let external_source_map = self.root.source_map.decode(self);\n+\n+            external_source_map.map(|source_file_to_import| {\n+                // We can't reuse an existing SourceFile, so allocate a new one\n+                // containing the information we need.\n+                let syntax_pos::SourceFile { name,\n+                                          name_was_remapped,\n+                                          src_hash,\n+                                          start_pos,\n+                                          end_pos,\n+                                          mut lines,\n+                                          mut multibyte_chars,\n+                                          mut non_narrow_chars,\n+                                          mut normalized_pos,\n+                                          name_hash,\n+                                          .. } = source_file_to_import;\n+\n+                let source_length = (end_pos - start_pos).to_usize();\n+\n+                // Translate line-start positions and multibyte character\n+                // position into frame of reference local to file.\n+                // `SourceMap::new_imported_source_file()` will then translate those\n+                // coordinates to their new global frame of reference when the\n+                // offset of the SourceFile is known.\n+                for pos in &mut lines {\n+                    *pos = *pos - start_pos;\n+                }\n+                for mbc in &mut multibyte_chars {\n+                    mbc.pos = mbc.pos - start_pos;\n+                }\n+                for swc in &mut non_narrow_chars {\n+                    *swc = *swc - start_pos;\n+                }\n+                for np in &mut normalized_pos {\n+                    np.pos = np.pos - start_pos;\n+                }\n \n-        // This shouldn't borrow twice, but there is no way to downgrade RefMut to Ref.\n-        self.source_map_import_info.borrow()\n+                let local_version = local_source_map.new_imported_source_file(name,\n+                                                                       name_was_remapped,\n+                                                                       self.cnum.as_u32(),\n+                                                                       src_hash,\n+                                                                       name_hash,\n+                                                                       source_length,\n+                                                                       lines,\n+                                                                       multibyte_chars,\n+                                                                       non_narrow_chars,\n+                                                                       normalized_pos);\n+                debug!(\"CrateMetaData::imported_source_files alloc \\\n+                        source_file {:?} original (start_pos {:?} end_pos {:?}) \\\n+                        translated (start_pos {:?} end_pos {:?})\",\n+                       local_version.name, start_pos, end_pos,\n+                       local_version.start_pos, local_version.end_pos);\n+\n+                cstore::ImportedSourceFile {\n+                    original_start_pos: start_pos,\n+                    original_end_pos: end_pos,\n+                    translated_source_file: local_version,\n+                }\n+            }).collect()\n+        })\n     }\n \n     /// Get the `DepNodeIndex` corresponding this crate. The result of this"}]}