{"sha": "d2d25a5be0c45b8aa247a3d0b6c7fda12e9ede9a", "node_id": "C_kwDOAAsO6NoAKGQyZDI1YTViZTBjNDViOGFhMjQ3YTNkMGI2YzdmZGExMmU5ZWRlOWE", "commit": {"author": {"name": "Santiago Pastorino", "email": "spastorino@gmail.com", "date": "2022-01-21T15:53:50Z"}, "committer": {"name": "Santiago Pastorino", "email": "spastorino@gmail.com", "date": "2022-01-21T21:22:21Z"}, "message": "Implement stable with negative coherence mode", "tree": {"sha": "5731d6d3b7d40248050ebfbf90fc38212ac42200", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5731d6d3b7d40248050ebfbf90fc38212ac42200"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d2d25a5be0c45b8aa247a3d0b6c7fda12e9ede9a", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEF0ntrgrd9qf9uuThgTGiTgx5768FAmHrJA4ACgkQgTGiTgx5\n7685NhAAvGaTBsssUxuwO7MEpaav9QiB+IZKfcY2bVXYwUGiTieJsihWV9p1TEm+\nTOeEGnnsh2TAUD1O8ZoDThVSkKXVt9NByXOQcIAKkAje1Fp8WNopiasiHxXyf0oM\nEefUTHn8ytrUmNUbvbXJ+6cJPK+OOl0jZRrbZur/sGO77cn/qVKKK84XBeULSwC2\nc6wYxviluziCKEPHMhlxzjFfCyCr0YzCrnhrgqPSsLI5TtzfgH0wSykPi+fQ2UV6\nf54q5Z8abWViMYDQ35BfzDkduNM4Ab3Gf+cjsBrd9VgevEAKc2NtZIGFQU9jmDez\nnW2Db8dQWk8gxNL4QD/YnFfoiimwmr0glI1p26KVnrfa3lkkAkugdEAg8z4V+aAn\nkagLc1fzTDMvX2NXy/AdRlY4u+t/znFzVi9sHDQSdeuwgqUd1PxhaFE2D5rP9/a4\nRzwgCmI9C4zCb/2Vya8IBFyHOl171GcSj06cYJaBnwfzwxtp0iuQoWvLh1RaC4AH\nmRfQTQpQhwxf8XxWD/cChbpS9HFo1pf7QcaFgZZy/9gFUBHsPHIlYL03FwI+LEqK\nySb8TRXZLjam0KGRr4kd5FyuQP7gmknw1aQqdtVXOdXxriRq9oGyKtK/cnBH5PQZ\nMe0W3cXgAzFGQbH65dYvKqENnB7uCOZPz0nedYeUDj5wT9x8wLs=\n=Ss+7\n-----END PGP SIGNATURE-----", "payload": "tree 5731d6d3b7d40248050ebfbf90fc38212ac42200\nparent c2890ed426aaef4b680848e793a2a741e517a6cc\nauthor Santiago Pastorino <spastorino@gmail.com> 1642780430 -0300\ncommitter Santiago Pastorino <spastorino@gmail.com> 1642800141 -0300\n\nImplement stable with negative coherence mode\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d2d25a5be0c45b8aa247a3d0b6c7fda12e9ede9a", "html_url": "https://github.com/rust-lang/rust/commit/d2d25a5be0c45b8aa247a3d0b6c7fda12e9ede9a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d2d25a5be0c45b8aa247a3d0b6c7fda12e9ede9a/comments", "author": {"login": "spastorino", "id": 52642, "node_id": "MDQ6VXNlcjUyNjQy", "avatar_url": "https://avatars.githubusercontent.com/u/52642?v=4", "gravatar_id": "", "url": "https://api.github.com/users/spastorino", "html_url": "https://github.com/spastorino", "followers_url": "https://api.github.com/users/spastorino/followers", "following_url": "https://api.github.com/users/spastorino/following{/other_user}", "gists_url": "https://api.github.com/users/spastorino/gists{/gist_id}", "starred_url": "https://api.github.com/users/spastorino/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/spastorino/subscriptions", "organizations_url": "https://api.github.com/users/spastorino/orgs", "repos_url": "https://api.github.com/users/spastorino/repos", "events_url": "https://api.github.com/users/spastorino/events{/privacy}", "received_events_url": "https://api.github.com/users/spastorino/received_events", "type": "User", "site_admin": false}, "committer": {"login": "spastorino", "id": 52642, "node_id": "MDQ6VXNlcjUyNjQy", "avatar_url": "https://avatars.githubusercontent.com/u/52642?v=4", "gravatar_id": "", "url": "https://api.github.com/users/spastorino", "html_url": "https://github.com/spastorino", "followers_url": "https://api.github.com/users/spastorino/followers", "following_url": "https://api.github.com/users/spastorino/following{/other_user}", "gists_url": "https://api.github.com/users/spastorino/gists{/gist_id}", "starred_url": "https://api.github.com/users/spastorino/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/spastorino/subscriptions", "organizations_url": "https://api.github.com/users/spastorino/orgs", "repos_url": "https://api.github.com/users/spastorino/repos", "events_url": "https://api.github.com/users/spastorino/events{/privacy}", "received_events_url": "https://api.github.com/users/spastorino/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c2890ed426aaef4b680848e793a2a741e517a6cc", "url": "https://api.github.com/repos/rust-lang/rust/commits/c2890ed426aaef4b680848e793a2a741e517a6cc", "html_url": "https://github.com/rust-lang/rust/commit/c2890ed426aaef4b680848e793a2a741e517a6cc"}], "stats": {"total": 127, "additions": 123, "deletions": 4}, "files": [{"sha": "0e643ff59983497d18f48db28dc9d12ca0cdc72d", "filename": "compiler/rustc_feature/src/builtin_attrs.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d2d25a5be0c45b8aa247a3d0b6c7fda12e9ede9a/compiler%2Frustc_feature%2Fsrc%2Fbuiltin_attrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2d25a5be0c45b8aa247a3d0b6c7fda12e9ede9a/compiler%2Frustc_feature%2Fsrc%2Fbuiltin_attrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_feature%2Fsrc%2Fbuiltin_attrs.rs?ref=d2d25a5be0c45b8aa247a3d0b6c7fda12e9ede9a", "patch": "@@ -697,6 +697,7 @@ pub const BUILTIN_ATTRIBUTES: &[BuiltinAttribute] = &[\n     rustc_attr!(TEST, rustc_capture_analysis, Normal, template!(Word), WarnFollowing),\n     rustc_attr!(TEST, rustc_insignificant_dtor, Normal, template!(Word), WarnFollowing),\n     rustc_attr!(TEST, rustc_strict_coherence, Normal, template!(Word), WarnFollowing),\n+    rustc_attr!(TEST, rustc_with_negative_coherence, Normal, template!(Word), WarnFollowing),\n     rustc_attr!(TEST, rustc_variance, Normal, template!(Word), WarnFollowing),\n     rustc_attr!(TEST, rustc_layout, Normal, template!(List: \"field1, field2, ...\"), WarnFollowing),\n     rustc_attr!(TEST, rustc_regions, Normal, template!(Word), WarnFollowing),"}, {"sha": "7e0ce89be67fc8b55589803ca1214f5ea662095e", "filename": "compiler/rustc_span/src/symbol.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d2d25a5be0c45b8aa247a3d0b6c7fda12e9ede9a/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2d25a5be0c45b8aa247a3d0b6c7fda12e9ede9a/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs?ref=d2d25a5be0c45b8aa247a3d0b6c7fda12e9ede9a", "patch": "@@ -1203,6 +1203,7 @@ symbols! {\n         rustc_trivial_field_reads,\n         rustc_unsafe_specialization_marker,\n         rustc_variance,\n+        rustc_with_negative_coherence,\n         rustdoc,\n         rustdoc_internals,\n         rustfmt,"}, {"sha": "42b7139c0069894ca2d1db2ec6967984702ada2b", "filename": "compiler/rustc_trait_selection/src/traits/coherence.rs", "status": "modified", "additions": 95, "deletions": 4, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/d2d25a5be0c45b8aa247a3d0b6c7fda12e9ede9a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2d25a5be0c45b8aa247a3d0b6c7fda12e9ede9a/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs?ref=d2d25a5be0c45b8aa247a3d0b6c7fda12e9ede9a", "patch": "@@ -7,9 +7,11 @@\n use crate::infer::{CombinedSnapshot, InferOk, TyCtxtInferExt};\n use crate::traits::query::evaluate_obligation::InferCtxtExt;\n use crate::traits::select::IntercrateAmbiguityCause;\n+use crate::traits::util::impl_trait_ref_and_oblig;\n use crate::traits::SkipLeakCheck;\n use crate::traits::{\n-    self, Normalized, Obligation, ObligationCause, PredicateObligation, SelectionContext,\n+    self, FulfillmentContext, Normalized, Obligation, ObligationCause, PredicateObligation,\n+    SelectionContext,\n };\n use rustc_hir::def_id::{DefId, LOCAL_CRATE};\n use rustc_middle::ty::fast_reject::{self, SimplifyParams, StripReferences};\n@@ -137,6 +139,7 @@ fn with_fresh_ty_vars<'cx, 'tcx>(\n \n enum OverlapMode {\n     Stable,\n+    WithNegative,\n     Strict,\n }\n \n@@ -147,8 +150,16 @@ fn overlap_mode<'tcx>(tcx: TyCtxt<'tcx>, impl1_def_id: DefId, impl2_def_id: DefI\n         bug!(\"Use strict coherence on both impls\",);\n     }\n \n+    if tcx.has_attr(impl1_def_id, sym::rustc_with_negative_coherence)\n+        != tcx.has_attr(impl2_def_id, sym::rustc_with_negative_coherence)\n+    {\n+        bug!(\"Use with negative coherence on both impls\",);\n+    }\n+\n     if tcx.has_attr(impl1_def_id, sym::rustc_strict_coherence) {\n         OverlapMode::Strict\n+    } else if tcx.has_attr(impl1_def_id, sym::rustc_with_negative_coherence) {\n+        OverlapMode::WithNegative\n     } else {\n         OverlapMode::Stable\n     }\n@@ -188,9 +199,25 @@ fn overlap_within_probe<'cx, 'tcx>(\n     let impl1_header = with_fresh_ty_vars(selcx, param_env, impl1_def_id);\n     let impl2_header = with_fresh_ty_vars(selcx, param_env, impl2_def_id);\n \n-    let overlap_mode = overlap_mode(tcx, impl1_def_id, impl2_def_id);\n-    if stable_disjoint(selcx, param_env, &impl1_header, impl2_header, overlap_mode) {\n-        return None;\n+    match overlap_mode(tcx, impl1_def_id, impl2_def_id) {\n+        OverlapMode::Stable => {\n+            if stable_disjoint(selcx, param_env, &impl1_header, impl2_header, OverlapMode::Stable) {\n+                return None;\n+            }\n+        }\n+        OverlapMode::Strict => {\n+            if stable_disjoint(selcx, param_env, &impl1_header, impl2_header, OverlapMode::Strict) {\n+                return None;\n+            }\n+        }\n+        OverlapMode::WithNegative => {\n+            if stable_disjoint(selcx, param_env, &impl1_header, impl2_header, OverlapMode::Stable)\n+                || explicit_disjoint(selcx, impl1_def_id, impl2_def_id)\n+                || explicit_disjoint(selcx, impl2_def_id, impl1_def_id)\n+            {\n+                return None;\n+            }\n+        }\n     }\n \n     if !skip_leak_check.is_yes() {\n@@ -280,6 +307,7 @@ fn stable_disjoint<'cx, 'tcx>(\n                     loose_check(selcx, o) || tcx.features().negative_impls && strict_check(selcx, o)\n                 }\n                 OverlapMode::Strict => strict_check(selcx, o),\n+                OverlapMode::WithNegative => loose_check(selcx, o),\n             }\n         });\n     // FIXME: the call to `selcx.predicate_may_hold_fatal` above should be ported\n@@ -294,6 +322,69 @@ fn stable_disjoint<'cx, 'tcx>(\n     }\n }\n \n+/// Given impl1 and impl2 check if both impls are never satisfied by a common type (including\n+/// where-clauses) If so, return true, they are disjoint and false otherwise.\n+fn explicit_disjoint<'cx, 'tcx>(\n+    selcx: &mut SelectionContext<'cx, 'tcx>,\n+    impl1_def_id: DefId,\n+    impl2_def_id: DefId,\n+) -> bool {\n+    let tcx = selcx.infcx().tcx;\n+\n+    // create a parameter environment corresponding to a (placeholder) instantiation of impl1\n+    let impl1_env = tcx.param_env(impl1_def_id);\n+    let impl1_trait_ref = tcx.impl_trait_ref(impl1_def_id).unwrap();\n+\n+    // Create an infcx, taking the predicates of impl1 as assumptions:\n+    tcx.infer_ctxt().enter(|infcx| {\n+        // Normalize the trait reference. The WF rules ought to ensure\n+        // that this always succeeds.\n+        let impl1_trait_ref = match traits::fully_normalize(\n+            &infcx,\n+            FulfillmentContext::new(),\n+            ObligationCause::dummy(),\n+            impl1_env,\n+            impl1_trait_ref,\n+        ) {\n+            Ok(impl1_trait_ref) => impl1_trait_ref,\n+            Err(err) => {\n+                bug!(\"failed to fully normalize {:?}: {:?}\", impl1_trait_ref, err);\n+            }\n+        };\n+\n+        // Attempt to prove that impl2 applies, given all of the above.\n+        let selcx = &mut SelectionContext::new(&infcx);\n+        let impl2_substs = infcx.fresh_substs_for_item(DUMMY_SP, impl2_def_id);\n+        let (impl2_trait_ref, obligations) =\n+            impl_trait_ref_and_oblig(selcx, impl1_env, impl2_def_id, impl2_substs);\n+\n+        // do the impls unify? If not, not disjoint.\n+        let more_obligations = match infcx\n+            .at(&ObligationCause::dummy(), impl1_env)\n+            .eq(impl1_trait_ref, impl2_trait_ref)\n+        {\n+            Ok(InferOk { obligations, .. }) => obligations,\n+            Err(_) => {\n+                debug!(\n+                    \"explicit_disjoint: {:?} does not unify with {:?}\",\n+                    impl1_trait_ref, impl2_trait_ref\n+                );\n+                return false;\n+            }\n+        };\n+\n+        let opt_failing_obligation =\n+            obligations.into_iter().chain(more_obligations).find(|o| strict_check(selcx, o));\n+\n+        if let Some(failing_obligation) = opt_failing_obligation {\n+            debug!(\"overlap: obligation unsatisfiable {:?}\", failing_obligation);\n+            true\n+        } else {\n+            false\n+        }\n+    })\n+}\n+\n fn loose_check<'cx, 'tcx>(\n     selcx: &mut SelectionContext<'cx, 'tcx>,\n     o: &PredicateObligation<'tcx>,"}, {"sha": "f71df1b87fcda367ca59e71e60106e48cb6d9a0f", "filename": "src/test/ui/coherence/auxiliary/option_future.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d2d25a5be0c45b8aa247a3d0b6c7fda12e9ede9a/src%2Ftest%2Fui%2Fcoherence%2Fauxiliary%2Foption_future.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2d25a5be0c45b8aa247a3d0b6c7fda12e9ede9a/src%2Ftest%2Fui%2Fcoherence%2Fauxiliary%2Foption_future.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcoherence%2Fauxiliary%2Foption_future.rs?ref=d2d25a5be0c45b8aa247a3d0b6c7fda12e9ede9a", "patch": "@@ -0,0 +1,8 @@\n+#![crate_type = \"lib\"]\n+#![feature(negative_impls)]\n+#![feature(rustc_attrs)]\n+\n+pub trait Future {}\n+\n+#[rustc_with_negative_coherence]\n+impl<E> !Future for Option<E> where E: Sized {}"}, {"sha": "1f47b5ba46e411158d39814bf710cf03b55d1f32", "filename": "src/test/ui/coherence/coherence-overlap-negative-trait2.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d2d25a5be0c45b8aa247a3d0b6c7fda12e9ede9a/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-overlap-negative-trait2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2d25a5be0c45b8aa247a3d0b6c7fda12e9ede9a/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-overlap-negative-trait2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcoherence%2Fcoherence-overlap-negative-trait2.rs?ref=d2d25a5be0c45b8aa247a3d0b6c7fda12e9ede9a", "patch": "@@ -0,0 +1,18 @@\n+// check-pass\n+// aux-build:option_future.rs\n+//\n+// Check that if we promise to not impl what would overlap it doesn't actually overlap\n+\n+#![feature(rustc_attrs)]\n+\n+extern crate option_future as lib;\n+use lib::Future;\n+\n+trait Termination {}\n+\n+#[rustc_with_negative_coherence]\n+impl<E> Termination for Option<E> where E: Sized {}\n+#[rustc_with_negative_coherence]\n+impl<F> Termination for F where F: Future + Sized {}\n+\n+fn main() {}"}]}