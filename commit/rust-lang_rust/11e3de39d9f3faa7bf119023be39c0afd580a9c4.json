{"sha": "11e3de39d9f3faa7bf119023be39c0afd580a9c4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjExZTNkZTM5ZDlmM2ZhYTdiZjExOTAyM2JlMzljMGFmZDU4MGE5YzQ=", "commit": {"author": {"name": "Ulrik Sverdrup", "email": "bluss@users.noreply.github.com", "date": "2016-01-06T14:43:33Z"}, "committer": {"name": "Ulrik Sverdrup", "email": "bluss@users.noreply.github.com", "date": "2016-01-12T20:57:04Z"}, "message": "Add fast path for ASCII in UTF-8 validation\n\nThis speeds up the ascii case (and long stretches of ascii in otherwise\nmixed UTF-8 data) when checking UTF-8 validity.\n\nBenchmark results suggest that on purely ASCII input, we can improve\nthroughput (megabytes verified / second) by a factor of 13 to 14!\nOn xml and mostly english language input (en.wikipedia xml dump),\nthroughput increases by a factor 7.\n\nOn mostly non-ASCII input, performance increases slightly or is the\nsame.\n\nThe UTF-8 validation is rewritten to use indexed access; since all\naccess is preceded by a (mandatory for validation) length check, they\nare statically elided by llvm and this formulation is in fact the best\nfor performance. A previous version had losses due to slice to iterator\nconversions.\n\nA large credit to Bj\u00f6rn Steinbrink who improved this patch immensely,\nwriting this second version.\n\nBenchmark results on x86-64 (Sandy Bridge) compiled with -C opt-level=3.\n\nOld code is `regular`, this PR is called `fast`.\n\nDatasets:\n\n- `ascii` is just ascii (2.5 kB)\n- `cyr` is cyrillic script with ascii spaces (5 kB)\n- `dewik10` is 10MB of a de.wikipedia xml dump\n- `enwik10` is 100MB of an en.wikipedia xml dump\n- `jawik10` is 10MB of a ja.wikipedia xml dump\n\n```\ntest from_utf8_ascii_fast        ... bench:         140 ns/iter (+/- 4) = 18221 MB/s\ntest from_utf8_ascii_regular     ... bench:       1,932 ns/iter (+/- 19) = 1320 MB/s\ntest from_utf8_cyr_fast          ... bench:      10,025 ns/iter (+/- 245) = 511 MB/s\ntest from_utf8_cyr_regular       ... bench:      12,250 ns/iter (+/- 437) = 418 MB/s\ntest from_utf8_dewik10_fast      ... bench:   6,017,909 ns/iter (+/- 105,755) = 1740 MB/s\ntest from_utf8_dewik10_regular   ... bench:  11,669,493 ns/iter (+/- 264,045) = 891 MB/s\ntest from_utf8_enwik8_fast       ... bench:  14,085,692 ns/iter (+/- 1,643,316) = 7000 MB/s\ntest from_utf8_enwik8_regular    ... bench:  93,657,410 ns/iter (+/- 5,353,353) = 1000 MB/s\ntest from_utf8_jawik10_fast      ... bench:  29,154,073 ns/iter (+/- 4,659,534) = 340 MB/s\ntest from_utf8_jawik10_regular   ... bench:  29,112,917 ns/iter (+/- 2,475,123) = 340 MB/s\n```\n\nCo-authored-by: Bj\u00f6rn Steinbrink <bsteinbr@gmail.com>", "tree": {"sha": "64091b48da5a9d0dad5da88c0ad28962e2548b80", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/64091b48da5a9d0dad5da88c0ad28962e2548b80"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/11e3de39d9f3faa7bf119023be39c0afd580a9c4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/11e3de39d9f3faa7bf119023be39c0afd580a9c4", "html_url": "https://github.com/rust-lang/rust/commit/11e3de39d9f3faa7bf119023be39c0afd580a9c4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/11e3de39d9f3faa7bf119023be39c0afd580a9c4/comments", "author": {"login": "bluss", "id": 3209739, "node_id": "MDQ6VXNlcjMyMDk3Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/3209739?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bluss", "html_url": "https://github.com/bluss", "followers_url": "https://api.github.com/users/bluss/followers", "following_url": "https://api.github.com/users/bluss/following{/other_user}", "gists_url": "https://api.github.com/users/bluss/gists{/gist_id}", "starred_url": "https://api.github.com/users/bluss/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bluss/subscriptions", "organizations_url": "https://api.github.com/users/bluss/orgs", "repos_url": "https://api.github.com/users/bluss/repos", "events_url": "https://api.github.com/users/bluss/events{/privacy}", "received_events_url": "https://api.github.com/users/bluss/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bluss", "id": 3209739, "node_id": "MDQ6VXNlcjMyMDk3Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/3209739?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bluss", "html_url": "https://github.com/bluss", "followers_url": "https://api.github.com/users/bluss/followers", "following_url": "https://api.github.com/users/bluss/following{/other_user}", "gists_url": "https://api.github.com/users/bluss/gists{/gist_id}", "starred_url": "https://api.github.com/users/bluss/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bluss/subscriptions", "organizations_url": "https://api.github.com/users/bluss/orgs", "repos_url": "https://api.github.com/users/bluss/repos", "events_url": "https://api.github.com/users/bluss/events{/privacy}", "received_events_url": "https://api.github.com/users/bluss/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "42c3ef8f9fd4b0dd1f881c49323bad456163f202", "url": "https://api.github.com/repos/rust-lang/rust/commits/42c3ef8f9fd4b0dd1f881c49323bad456163f202", "html_url": "https://github.com/rust-lang/rust/commit/42c3ef8f9fd4b0dd1f881c49323bad456163f202"}], "stats": {"total": 96, "additions": 69, "deletions": 27}, "files": [{"sha": "ab831de65167a9462a621643fde49033cd2d70a1", "filename": "src/libcollectionstest/str.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/11e3de39d9f3faa7bf119023be39c0afd580a9c4/src%2Flibcollectionstest%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11e3de39d9f3faa7bf119023be39c0afd580a9c4/src%2Flibcollectionstest%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Fstr.rs?ref=11e3de39d9f3faa7bf119023be39c0afd580a9c4", "patch": "@@ -470,6 +470,18 @@ fn test_is_utf8() {\n     assert!(from_utf8(&[0xF4, 0x8F, 0xBF, 0xBF]).is_ok());\n }\n \n+#[test]\n+fn from_utf8_mostly_ascii() {\n+    // deny invalid bytes embedded in long stretches of ascii\n+    for i in 32..64 {\n+        let mut data = [0; 128];\n+        data[i] = 0xC0;\n+        assert!(from_utf8(&data).is_err());\n+        data[i] = 0xC2;\n+        assert!(from_utf8(&data).is_err());\n+    }\n+}\n+\n #[test]\n fn test_is_utf16() {\n     use rustc_unicode::str::is_utf16;"}, {"sha": "64c21836b000322756bd068a196939c631f0cd8a", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 57, "deletions": 27, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/11e3de39d9f3faa7bf119023be39c0afd580a9c4/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11e3de39d9f3faa7bf119023be39c0afd580a9c4/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=11e3de39d9f3faa7bf119023be39c0afd580a9c4", "patch": "@@ -32,6 +32,7 @@ use option::Option::{self, None, Some};\n use raw::{Repr, Slice};\n use result::Result::{self, Ok, Err};\n use slice::{self, SliceExt};\n+use usize;\n \n pub mod pattern;\n \n@@ -240,7 +241,7 @@ impl Utf8Error {\n /// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn from_utf8(v: &[u8]) -> Result<&str, Utf8Error> {\n-    try!(run_utf8_validation_iterator(&mut v.iter()));\n+    try!(run_utf8_validation(v));\n     Ok(unsafe { from_utf8_unchecked(v) })\n }\n \n@@ -1074,46 +1075,44 @@ unsafe fn cmp_slice(a: &str, b: &str, len: usize) -> i32 {\n }\n \n /*\n-Section: Misc\n+Section: UTF-8 validation\n */\n \n+// use truncation to fit u64 into usize\n+const NONASCII_MASK: usize = 0x80808080_80808080u64 as usize;\n+\n+/// Return `true` if any byte in the word `x` is nonascii (>= 128).\n+#[inline]\n+fn contains_nonascii(x: usize) -> bool {\n+    (x & NONASCII_MASK) != 0\n+}\n+\n /// Walk through `iter` checking that it's a valid UTF-8 sequence,\n /// returning `true` in that case, or, if it is invalid, `false` with\n /// `iter` reset such that it is pointing at the first byte in the\n /// invalid sequence.\n #[inline(always)]\n-fn run_utf8_validation_iterator(iter: &mut slice::Iter<u8>)\n-                                -> Result<(), Utf8Error> {\n-    let whole = iter.as_slice();\n-    loop {\n-        // save the current thing we're pointing at.\n-        let old = iter.clone();\n-\n-        // restore the iterator we had at the start of this codepoint.\n+fn run_utf8_validation(v: &[u8]) -> Result<(), Utf8Error> {\n+    let mut offset = 0;\n+    let len = v.len();\n+    while offset < len {\n+        let old_offset = offset;\n         macro_rules! err { () => {{\n-            *iter = old.clone();\n             return Err(Utf8Error {\n-                valid_up_to: whole.len() - iter.as_slice().len()\n+                valid_up_to: old_offset\n             })\n         }}}\n \n-        macro_rules! next { () => {\n-            match iter.next() {\n-                Some(a) => *a,\n-                // we needed data, but there was none: error!\n-                None => err!(),\n+        macro_rules! next { () => {{\n+            offset += 1;\n+            // we needed data, but there was none: error!\n+            if offset >= len {\n+                err!()\n             }\n-        }}\n-\n-        let first = match iter.next() {\n-            Some(&b) => b,\n-            // we're at the end of the iterator and a codepoint\n-            // boundary at the same time, so this string is valid.\n-            None => return Ok(())\n-        };\n+            v[offset]\n+        }}}\n \n-        // ASCII characters are always valid, so only large\n-        // bytes need more examination.\n+        let first = v[offset];\n         if first >= 128 {\n             let w = UTF8_CHAR_WIDTH[first as usize];\n             let second = next!();\n@@ -1156,8 +1155,39 @@ fn run_utf8_validation_iterator(iter: &mut slice::Iter<u8>)\n                 }\n                 _ => err!()\n             }\n+            offset += 1;\n+        } else {\n+            // Ascii case, try to skip forward quickly.\n+            let ptr = v.as_ptr();\n+            let align = (ptr as usize + offset) & (usize::BYTES - 1);\n+            if align == 0 {\n+                // When the pointer is aligned, read 2 words of data per iteration\n+                // until we find a word containing a non-ascii byte.\n+                while offset <= len - 2 * usize::BYTES {\n+                    unsafe {\n+                        let u = *(ptr.offset(offset as isize) as *const usize);\n+                        let v = *(ptr.offset((offset + usize::BYTES) as isize) as *const usize);\n+\n+                        // break if there is a nonascii byte\n+                        let zu = contains_nonascii(u);\n+                        let zv = contains_nonascii(v);\n+                        if zu || zv {\n+                            break;\n+                        }\n+                    }\n+                    offset += usize::BYTES * 2;\n+                }\n+                // step from the point where the wordwise loop stopped\n+                while offset < len && v[offset] < 128 {\n+                    offset += 1;\n+                }\n+            } else {\n+                offset += 1;\n+            }\n         }\n     }\n+\n+    Ok(())\n }\n \n // https://tools.ietf.org/html/rfc3629"}]}