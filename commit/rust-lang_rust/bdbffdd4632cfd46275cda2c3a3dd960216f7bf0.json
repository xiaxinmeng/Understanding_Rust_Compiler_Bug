{"sha": "bdbffdd4632cfd46275cda2c3a3dd960216f7bf0", "node_id": "C_kwDOAAsO6NoAKGJkYmZmZGQ0NjMyY2ZkNDYyNzVjZGEyYzNhM2RkOTYwMjE2ZjdiZjA", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2022-06-27T12:39:44Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2022-06-27T12:39:44Z"}, "message": "fix: Fix completions for locals not working properly inside macro calls", "tree": {"sha": "3e11ee0126ebe492af61ef4a006a428d6ade0fd2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3e11ee0126ebe492af61ef4a006a428d6ade0fd2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bdbffdd4632cfd46275cda2c3a3dd960216f7bf0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bdbffdd4632cfd46275cda2c3a3dd960216f7bf0", "html_url": "https://github.com/rust-lang/rust/commit/bdbffdd4632cfd46275cda2c3a3dd960216f7bf0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bdbffdd4632cfd46275cda2c3a3dd960216f7bf0/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b74e96f509baf0be70281c55f14cb18fefbc6b22", "url": "https://api.github.com/repos/rust-lang/rust/commits/b74e96f509baf0be70281c55f14cb18fefbc6b22", "html_url": "https://github.com/rust-lang/rust/commit/b74e96f509baf0be70281c55f14cb18fefbc6b22"}], "stats": {"total": 64, "additions": 45, "deletions": 19}, "files": [{"sha": "9bdde5e6e0f1c7329942e221da970964b80961e2", "filename": "crates/hir/src/source_analyzer.rs", "status": "modified", "additions": 12, "deletions": 18, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/bdbffdd4632cfd46275cda2c3a3dd960216f7bf0/crates%2Fhir%2Fsrc%2Fsource_analyzer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdbffdd4632cfd46275cda2c3a3dd960216f7bf0/crates%2Fhir%2Fsrc%2Fsource_analyzer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fsource_analyzer.rs?ref=bdbffdd4632cfd46275cda2c3a3dd960216f7bf0", "patch": "@@ -67,10 +67,7 @@ impl SourceAnalyzer {\n         let scopes = db.expr_scopes(def);\n         let scope = match offset {\n             None => scope_for(&scopes, &source_map, node),\n-            Some(offset) => {\n-                let file_id = node.file_id.original_file(db.upcast());\n-                scope_for_offset(db, &scopes, &source_map, InFile::new(file_id.into(), offset))\n-            }\n+            Some(offset) => scope_for_offset(db, &scopes, &source_map, node.file_id, offset),\n         };\n         let resolver = resolver_for_scope(db.upcast(), def, scope);\n         SourceAnalyzer {\n@@ -91,10 +88,7 @@ impl SourceAnalyzer {\n         let scopes = db.expr_scopes(def);\n         let scope = match offset {\n             None => scope_for(&scopes, &source_map, node),\n-            Some(offset) => {\n-                let file_id = node.file_id.original_file(db.upcast());\n-                scope_for_offset(db, &scopes, &source_map, InFile::new(file_id.into(), offset))\n-            }\n+            Some(offset) => scope_for_offset(db, &scopes, &source_map, node.file_id, offset),\n         };\n         let resolver = resolver_for_scope(db.upcast(), def, scope);\n         SourceAnalyzer { resolver, def: Some((def, body, source_map)), infer: None, file_id }\n@@ -585,14 +579,15 @@ fn scope_for_offset(\n     db: &dyn HirDatabase,\n     scopes: &ExprScopes,\n     source_map: &BodySourceMap,\n-    offset: InFile<TextSize>,\n+    from_file: HirFileId,\n+    offset: TextSize,\n ) -> Option<ScopeId> {\n     scopes\n         .scope_by_expr()\n         .iter()\n         .filter_map(|(id, scope)| {\n             let InFile { file_id, value } = source_map.expr_syntax(*id).ok()?;\n-            if offset.file_id == file_id {\n+            if from_file == file_id {\n                 let root = db.parse_or_expand(file_id)?;\n                 let node = value.to_node(&root);\n                 return Some((node.syntax().text_range(), scope));\n@@ -602,17 +597,15 @@ fn scope_for_offset(\n             let source = iter::successors(file_id.call_node(db.upcast()), |it| {\n                 it.file_id.call_node(db.upcast())\n             })\n-            .find(|it| it.file_id == offset.file_id)\n+            .find(|it| it.file_id == from_file)\n             .filter(|it| it.value.kind() == SyntaxKind::MACRO_CALL)?;\n             Some((source.value.text_range(), scope))\n         })\n-        .filter(|(expr_range, _scope)| {\n-            expr_range.start() <= offset.value && offset.value <= expr_range.end()\n-        })\n+        .filter(|(expr_range, _scope)| expr_range.start() <= offset && offset <= expr_range.end())\n         // find containing scope\n         .min_by_key(|(expr_range, _scope)| expr_range.len())\n         .map(|(expr_range, scope)| {\n-            adjust(db, scopes, source_map, expr_range, offset).unwrap_or(*scope)\n+            adjust(db, scopes, source_map, expr_range, from_file, offset).unwrap_or(*scope)\n         })\n }\n \n@@ -623,23 +616,24 @@ fn adjust(\n     scopes: &ExprScopes,\n     source_map: &BodySourceMap,\n     expr_range: TextRange,\n-    offset: InFile<TextSize>,\n+    from_file: HirFileId,\n+    offset: TextSize,\n ) -> Option<ScopeId> {\n     let child_scopes = scopes\n         .scope_by_expr()\n         .iter()\n         .filter_map(|(id, scope)| {\n             let source = source_map.expr_syntax(*id).ok()?;\n             // FIXME: correctly handle macro expansion\n-            if source.file_id != offset.file_id {\n+            if source.file_id != from_file {\n                 return None;\n             }\n             let root = source.file_syntax(db.upcast());\n             let node = source.value.to_node(&root);\n             Some((node.syntax().text_range(), scope))\n         })\n         .filter(|&(range, _)| {\n-            range.start() <= offset.value && expr_range.contains_range(range) && range != expr_range\n+            range.start() <= offset && expr_range.contains_range(range) && range != expr_range\n         });\n \n     child_scopes"}, {"sha": "b371c978808fd99fdb62d097fa8369332f344a45", "filename": "crates/ide-completion/src/context.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bdbffdd4632cfd46275cda2c3a3dd960216f7bf0/crates%2Fide-completion%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdbffdd4632cfd46275cda2c3a3dd960216f7bf0/crates%2Fide-completion%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcontext.rs?ref=bdbffdd4632cfd46275cda2c3a3dd960216f7bf0", "patch": "@@ -506,7 +506,11 @@ impl<'a> CompletionContext<'a> {\n \n         let original_token = original_file.syntax().token_at_offset(offset).left_biased()?;\n         let token = sema.descend_into_macros_single(original_token.clone());\n-        let scope = sema.scope_at_offset(&token.parent()?, offset)?;\n+\n+        // adjust for macro input, this still fails if there is no token written yet\n+        let scope_offset = if original_token == token { offset } else { token.text_range().end() };\n+        let scope = sema.scope_at_offset(&token.parent()?, scope_offset)?;\n+\n         let krate = scope.krate();\n         let module = scope.module();\n "}, {"sha": "39cb41485b1cfa5273801c0765d609434829e3c6", "filename": "crates/ide-completion/src/tests/special.rs", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/bdbffdd4632cfd46275cda2c3a3dd960216f7bf0/crates%2Fide-completion%2Fsrc%2Ftests%2Fspecial.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdbffdd4632cfd46275cda2c3a3dd960216f7bf0/crates%2Fide-completion%2Fsrc%2Ftests%2Fspecial.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Ftests%2Fspecial.rs?ref=bdbffdd4632cfd46275cda2c3a3dd960216f7bf0", "patch": "@@ -782,3 +782,31 @@ fn main() {\n         \"#]],\n     )\n }\n+\n+#[test]\n+fn completes_locals_from_macros() {\n+    check(\n+        r#\"\n+\n+macro_rules! x {\n+    ($x:ident, $expr:expr) => {\n+        let $x = 0;\n+        $expr\n+    };\n+}\n+fn main() {\n+    x! {\n+        foobar, {\n+            f$0\n+        }\n+    };\n+}\n+\"#,\n+        expect![[r#\"\n+            fn main() fn()\n+            lc foobar i32\n+            ma x!(\u2026)  macro_rules! x\n+            bt u32\n+        \"#]],\n+    )\n+}"}]}