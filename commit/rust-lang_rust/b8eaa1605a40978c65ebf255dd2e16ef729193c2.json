{"sha": "b8eaa1605a40978c65ebf255dd2e16ef729193c2", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI4ZWFhMTYwNWE0MDk3OGM2NWViZjI1NWRkMmUxNmVmNzI5MTkzYzI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-11-11T20:39:49Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-11-11T20:39:49Z"}, "message": "Auto merge of #29778 - Manishearth:rollup, r=Manishearth\n\n- Successful merges: #29677, #29772, #29775, #29777\n- Failed merges:", "tree": {"sha": "bde0eeb635074e44db96dc29f546138aa7a732e5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bde0eeb635074e44db96dc29f546138aa7a732e5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b8eaa1605a40978c65ebf255dd2e16ef729193c2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b8eaa1605a40978c65ebf255dd2e16ef729193c2", "html_url": "https://github.com/rust-lang/rust/commit/b8eaa1605a40978c65ebf255dd2e16ef729193c2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b8eaa1605a40978c65ebf255dd2e16ef729193c2/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f1f5c04c07f2e888c43cb577810659a7c1d87a00", "url": "https://api.github.com/repos/rust-lang/rust/commits/f1f5c04c07f2e888c43cb577810659a7c1d87a00", "html_url": "https://github.com/rust-lang/rust/commit/f1f5c04c07f2e888c43cb577810659a7c1d87a00"}, {"sha": "26705657e4c5e65af270352cc296290cd2108e3f", "url": "https://api.github.com/repos/rust-lang/rust/commits/26705657e4c5e65af270352cc296290cd2108e3f", "html_url": "https://github.com/rust-lang/rust/commit/26705657e4c5e65af270352cc296290cd2108e3f"}], "stats": {"total": 169, "additions": 113, "deletions": 56}, "files": [{"sha": "579232e5a5dff93bc0347bf6c92ed8c8c9d0ade4", "filename": "src/libcore/macros.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b8eaa1605a40978c65ebf255dd2e16ef729193c2/src%2Flibcore%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8eaa1605a40978c65ebf255dd2e16ef729193c2/src%2Flibcore%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmacros.rs?ref=b8eaa1605a40978c65ebf255dd2e16ef729193c2", "patch": "@@ -308,27 +308,27 @@ macro_rules! unreachable {\n ///\n /// ```\n /// # trait Foo {\n-/// #     fn foo(&self);\n /// #     fn bar(&self);\n+/// #     fn baz(&self);\n /// # }\n /// struct MyStruct;\n ///\n /// impl Foo for MyStruct {\n-///     fn foo(&self) {\n+///     fn bar(&self) {\n ///         // implementation goes here\n ///     }\n ///\n-///     fn bar(&self) {\n-///         // let's not worry about implementing bar() for now\n+///     fn baz(&self) {\n+///         // let's not worry about implementing baz() for now\n ///         unimplemented!();\n ///     }\n /// }\n ///\n /// fn main() {\n ///     let s = MyStruct;\n-///     s.foo();\n+///     s.bar();\n ///\n-///     // we aren't even using bar() yet, so this is fine.\n+///     // we aren't even using baz() yet, so this is fine.\n /// }\n /// ```\n #[macro_export]"}, {"sha": "80062b371a3c2e2728554b274cce39e7e1daccb1", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 19, "deletions": 7, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/b8eaa1605a40978c65ebf255dd2e16ef729193c2/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8eaa1605a40978c65ebf255dd2e16ef729193c2/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=b8eaa1605a40978c65ebf255dd2e16ef729193c2", "patch": "@@ -153,7 +153,7 @@ pub enum ResolutionError<'a> {\n     /// error E0413: declaration shadows an enum variant or unit-like struct in scope\n     DeclarationShadowsEnumVariantOrUnitLikeStruct(Name),\n     /// error E0414: only irrefutable patterns allowed here\n-    OnlyIrrefutablePatternsAllowedHere,\n+    OnlyIrrefutablePatternsAllowedHere(DefId, Name),\n     /// error E0415: identifier is bound more than once in this parameter list\n     IdentifierBoundMoreThanOnceInParameterList(&'a str),\n     /// error E0416: identifier is bound more than once in the same pattern\n@@ -283,8 +283,19 @@ fn resolve_error<'b, 'a:'b, 'tcx:'a>(resolver: &'b Resolver<'a, 'tcx>, span: syn\n                           scope\",\n                          name);\n         },\n-        ResolutionError::OnlyIrrefutablePatternsAllowedHere => {\n+        ResolutionError::OnlyIrrefutablePatternsAllowedHere(did, name) => {\n             span_err!(resolver.session, span, E0414, \"only irrefutable patterns allowed here\");\n+            resolver.session.span_note(span, \"there already is a constant in scope \\\n+                                               sharing the same name as this pattern\");\n+            if let Some(sp) = resolver.ast_map.span_if_local(did) {\n+                resolver.session.span_note(sp, \"constant defined here\");\n+            }\n+            if let Some(directive) = resolver.current_module\n+                                             .import_resolutions\n+                                             .borrow().get(&name) {\n+                let item = resolver.ast_map.expect_item(directive.value_id);\n+                resolver.session.span_note(item.span, \"constant imported here\");\n+            }\n         },\n         ResolutionError::IdentifierBoundMoreThanOnceInParameterList(identifier) => {\n             span_err!(resolver.session, span, E0415,\n@@ -632,7 +643,7 @@ enum NameSearchType {\n #[derive(Copy, Clone)]\n enum BareIdentifierPatternResolution {\n     FoundStructOrEnumVariant(Def, LastPrivate),\n-    FoundConst(Def, LastPrivate),\n+    FoundConst(Def, LastPrivate, Name),\n     BareIdentifierPatternUnresolved\n }\n \n@@ -2685,7 +2696,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                     renamed)\n                             );\n                         }\n-                        FoundConst(def, lp) if const_ok => {\n+                        FoundConst(def, lp, _) if const_ok => {\n                             debug!(\"(resolving pattern) resolving `{}` to \\\n                                     constant\",\n                                    renamed);\n@@ -2700,11 +2711,12 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                 depth: 0\n                             });\n                         }\n-                        FoundConst(..) => {\n+                        FoundConst(def, _, name) => {\n                             resolve_error(\n                                 self,\n                                 pattern.span,\n-                                ResolutionError::OnlyIrrefutablePatternsAllowedHere\n+                                ResolutionError::OnlyIrrefutablePatternsAllowedHere(def.def_id(),\n+                                                                                    name)\n                             );\n                         }\n                         BareIdentifierPatternUnresolved => {\n@@ -2929,7 +2941,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                 return FoundStructOrEnumVariant(def, LastMod(AllPublic));\n                             }\n                             def @ DefConst(..) | def @ DefAssociatedConst(..) => {\n-                                return FoundConst(def, LastMod(AllPublic));\n+                                return FoundConst(def, LastMod(AllPublic), name);\n                             }\n                             DefStatic(..) => {\n                                 resolve_error(self,"}, {"sha": "2d7178bd55c394f3ea0c881cb8b1a1754444817a", "filename": "src/librustc_typeck/diagnostics.rs", "status": "modified", "additions": 22, "deletions": 1, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/b8eaa1605a40978c65ebf255dd2e16ef729193c2/src%2Flibrustc_typeck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8eaa1605a40978c65ebf255dd2e16ef729193c2/src%2Flibrustc_typeck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fdiagnostics.rs?ref=b8eaa1605a40978c65ebf255dd2e16ef729193c2", "patch": "@@ -2677,6 +2677,28 @@ defined. For more information see the [opt-in builtin traits RFC](https://github\n .com/rust-lang/rfcs/blob/master/text/0019-opt-in-builtin-traits.md).\n \"##,\n \n+E0321: r##\"\n+A cross-crate opt-out trait was implemented on something which wasn't a struct\n+or enum type. Erroneous code example:\n+\n+```\n+#![feature(optin_builtin_traits)]\n+\n+struct Foo;\n+\n+impl !Sync for Foo {}\n+\n+unsafe impl Send for &'static Foo {\n+// error: cross-crate traits with a default impl, like `core::marker::Send`,\n+//        can only be implemented for a struct/enum type, not\n+//        `&'static Foo`\n+```\n+\n+Only structs and enums are permitted to impl Send, Sync, and other opt-out\n+trait, and the struct or enum must be local to the current crate. So, for\n+example, `unsafe impl Send for Rc<Foo>` is not allowed.\n+\"##,\n+\n E0322: r##\"\n The `Sized` trait is a special trait built-in to the compiler for types with a\n constant size known at compile-time. This trait is automatically implemented\n@@ -3463,7 +3485,6 @@ register_diagnostics! {\n //  E0246, // invalid recursive type\n //  E0319, // trait impls for defaulted traits allowed just for structs/enums\n     E0320, // recursive overflow during dropck\n-    E0321, // extended coherence rules for defaulted traits violated\n     E0328, // cannot implement Unsize explicitly\n     E0374, // the trait `CoerceUnsized` may only be implemented for a coercion\n            // between structures with one field being coerced, none found"}, {"sha": "42fd2321f011dc4bd09dae14ce3492bb28ab1189", "filename": "src/libstd/ffi/c_str.rs", "status": "modified", "additions": 32, "deletions": 40, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/b8eaa1605a40978c65ebf255dd2e16ef729193c2/src%2Flibstd%2Fffi%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8eaa1605a40978c65ebf255dd2e16ef729193c2/src%2Flibstd%2Fffi%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fffi%2Fc_str.rs?ref=b8eaa1605a40978c65ebf255dd2e16ef729193c2", "patch": "@@ -21,6 +21,7 @@ use libc;\n use mem;\n use ops::Deref;\n use option::Option::{self, Some, None};\n+use os::raw::c_char;\n use result::Result::{self, Ok, Err};\n use slice;\n use str::{self, Utf8Error};\n@@ -36,23 +37,20 @@ use vec::Vec;\n ///\n /// A `CString` is created from either a byte slice or a byte vector. After\n /// being created, a `CString` predominately inherits all of its methods from\n-/// the `Deref` implementation to `[libc::c_char]`. Note that the underlying\n-/// array is represented as an array of `libc::c_char` as opposed to `u8`. A\n-/// `u8` slice can be obtained with the `as_bytes` method.  Slices produced from\n-/// a `CString` do *not* contain the trailing nul terminator unless otherwise\n-/// specified.\n+/// the `Deref` implementation to `[c_char]`. Note that the underlying array\n+/// is represented as an array of `c_char` as opposed to `u8`. A `u8` slice\n+/// can be obtained with the `as_bytes` method.  Slices produced from a `CString`\n+/// do *not* contain the trailing nul terminator unless otherwise specified.\n ///\n /// # Examples\n ///\n /// ```no_run\n-/// # #![feature(libc)]\n-/// # extern crate libc;\n /// # fn main() {\n /// use std::ffi::CString;\n-/// use libc;\n+/// use std::os::raw::c_char;\n ///\n /// extern {\n-///     fn my_printer(s: *const libc::c_char);\n+///     fn my_printer(s: *const c_char);\n /// }\n ///\n /// let c_to_print = CString::new(\"Hello, world!\").unwrap();\n@@ -83,11 +81,10 @@ pub struct CString {\n /// Inspecting a foreign C string\n ///\n /// ```no_run\n-/// # #![feature(libc)]\n-/// extern crate libc;\n /// use std::ffi::CStr;\n+/// use std::os::raw::c_char;\n ///\n-/// extern { fn my_string() -> *const libc::c_char; }\n+/// extern { fn my_string() -> *const c_char; }\n ///\n /// fn main() {\n ///     unsafe {\n@@ -100,12 +97,11 @@ pub struct CString {\n /// Passing a Rust-originating C string\n ///\n /// ```no_run\n-/// # #![feature(libc)]\n-/// extern crate libc;\n /// use std::ffi::{CString, CStr};\n+/// use std::os::raw::c_char;\n ///\n /// fn work(data: &CStr) {\n-///     extern { fn work_with(data: *const libc::c_char); }\n+///     extern { fn work_with(data: *const c_char); }\n ///\n ///     unsafe { work_with(data.as_ptr()) }\n /// }\n@@ -119,11 +115,10 @@ pub struct CString {\n /// Converting a foreign C string into a Rust `String`\n ///\n /// ```no_run\n-/// # #![feature(libc)]\n-/// extern crate libc;\n /// use std::ffi::CStr;\n+/// use std::os::raw::c_char;\n ///\n-/// extern { fn my_string() -> *const libc::c_char; }\n+/// extern { fn my_string() -> *const c_char; }\n ///\n /// fn my_string_safe() -> String {\n ///     unsafe {\n@@ -139,10 +134,10 @@ pub struct CString {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct CStr {\n     // FIXME: this should not be represented with a DST slice but rather with\n-    //        just a raw `libc::c_char` along with some form of marker to make\n+    //        just a raw `c_char` along with some form of marker to make\n     //        this an unsized type. Essentially `sizeof(&CStr)` should be the\n     //        same as `sizeof(&c_char)` but `CStr` should be an unsized type.\n-    inner: [libc::c_char]\n+    inner: [c_char]\n }\n \n /// An error returned from `CString::new` to indicate that a nul byte was found\n@@ -169,11 +164,10 @@ impl CString {\n     /// # Examples\n     ///\n     /// ```no_run\n-    /// # #![feature(libc)]\n-    /// extern crate libc;\n     /// use std::ffi::CString;\n+    /// use std::os::raw::c_char;\n     ///\n-    /// extern { fn puts(s: *const libc::c_char); }\n+    /// extern { fn puts(s: *const c_char); }\n     ///\n     /// fn main() {\n     ///     let to_print = CString::new(\"Hello!\").unwrap();\n@@ -220,7 +214,7 @@ impl CString {\n     #[unstable(feature = \"cstr_memory2\", reason = \"recently added\",\n                issue = \"27769\")]\n     #[deprecated(since = \"1.4.0\", reason = \"renamed to from_raw\")]\n-    pub unsafe fn from_ptr(ptr: *const libc::c_char) -> CString {\n+    pub unsafe fn from_ptr(ptr: *const c_char) -> CString {\n         CString::from_raw(ptr as *mut _)\n     }\n \n@@ -230,7 +224,7 @@ impl CString {\n     /// `into_raw`. The length of the string will be recalculated\n     /// using the pointer.\n     #[stable(feature = \"cstr_memory\", since = \"1.4.0\")]\n-    pub unsafe fn from_raw(ptr: *mut libc::c_char) -> CString {\n+    pub unsafe fn from_raw(ptr: *mut c_char) -> CString {\n         let len = libc::strlen(ptr) + 1; // Including the NUL byte\n         let slice = slice::from_raw_parts(ptr, len as usize);\n         CString { inner: mem::transmute(slice) }\n@@ -247,7 +241,7 @@ impl CString {\n     #[unstable(feature = \"cstr_memory2\", reason = \"recently added\",\n                issue = \"27769\")]\n     #[deprecated(since = \"1.4.0\", reason = \"renamed to into_raw\")]\n-    pub fn into_ptr(self) -> *const libc::c_char {\n+    pub fn into_ptr(self) -> *const c_char {\n         self.into_raw() as *const _\n     }\n \n@@ -260,8 +254,8 @@ impl CString {\n     ///\n     /// Failure to call `from_raw` will lead to a memory leak.\n     #[stable(feature = \"cstr_memory\", since = \"1.4.0\")]\n-    pub fn into_raw(self) -> *mut libc::c_char {\n-        Box::into_raw(self.inner) as *mut libc::c_char\n+    pub fn into_raw(self) -> *mut c_char {\n+        Box::into_raw(self.inner) as *mut c_char\n     }\n \n     /// Converts the `CString` into a `String` if it contains valid Unicode data.\n@@ -426,15 +420,13 @@ impl CStr {\n     /// # Examples\n     ///\n     /// ```no_run\n-    /// # #![feature(libc)]\n-    /// # extern crate libc;\n     /// # fn main() {\n     /// use std::ffi::CStr;\n+    /// use std::os::raw::c_char;\n     /// use std::str;\n-    /// use libc;\n     ///\n     /// extern {\n-    ///     fn my_string() -> *const libc::c_char;\n+    ///     fn my_string() -> *const c_char;\n     /// }\n     ///\n     /// unsafe {\n@@ -445,7 +437,7 @@ impl CStr {\n     /// # }\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub unsafe fn from_ptr<'a>(ptr: *const libc::c_char) -> &'a CStr {\n+    pub unsafe fn from_ptr<'a>(ptr: *const c_char) -> &'a CStr {\n         let len = libc::strlen(ptr);\n         mem::transmute(slice::from_raw_parts(ptr, len as usize + 1))\n     }\n@@ -456,7 +448,7 @@ impl CStr {\n     /// to a contiguous region of memory terminated with a 0 byte to represent\n     /// the end of the string.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn as_ptr(&self) -> *const libc::c_char {\n+    pub fn as_ptr(&self) -> *const c_char {\n         self.inner.as_ptr()\n     }\n \n@@ -560,14 +552,14 @@ impl ToOwned for CStr {\n mod tests {\n     use prelude::v1::*;\n     use super::*;\n-    use libc;\n+    use os::raw::c_char;\n     use borrow::Cow::{Borrowed, Owned};\n     use hash::{SipHasher, Hash, Hasher};\n \n     #[test]\n     fn c_to_rust() {\n         let data = b\"123\\0\";\n-        let ptr = data.as_ptr() as *const libc::c_char;\n+        let ptr = data.as_ptr() as *const c_char;\n         unsafe {\n             assert_eq!(CStr::from_ptr(ptr).to_bytes(), b\"123\");\n             assert_eq!(CStr::from_ptr(ptr).to_bytes_with_nul(), b\"123\\0\");\n@@ -616,13 +608,13 @@ mod tests {\n     #[test]\n     fn to_str() {\n         let data = b\"123\\xE2\\x80\\xA6\\0\";\n-        let ptr = data.as_ptr() as *const libc::c_char;\n+        let ptr = data.as_ptr() as *const c_char;\n         unsafe {\n             assert_eq!(CStr::from_ptr(ptr).to_str(), Ok(\"123\u2026\"));\n             assert_eq!(CStr::from_ptr(ptr).to_string_lossy(), Borrowed(\"123\u2026\"));\n         }\n         let data = b\"123\\xE2\\0\";\n-        let ptr = data.as_ptr() as *const libc::c_char;\n+        let ptr = data.as_ptr() as *const c_char;\n         unsafe {\n             assert!(CStr::from_ptr(ptr).to_str().is_err());\n             assert_eq!(CStr::from_ptr(ptr).to_string_lossy(), Owned::<str>(format!(\"123\\u{FFFD}\")));\n@@ -632,7 +624,7 @@ mod tests {\n     #[test]\n     fn to_owned() {\n         let data = b\"123\\0\";\n-        let ptr = data.as_ptr() as *const libc::c_char;\n+        let ptr = data.as_ptr() as *const c_char;\n \n         let owned = unsafe { CStr::from_ptr(ptr).to_owned() };\n         assert_eq!(owned.as_bytes_with_nul(), data);\n@@ -641,7 +633,7 @@ mod tests {\n     #[test]\n     fn equal_hash() {\n         let data = b\"123\\xE2\\xFA\\xA6\\0\";\n-        let ptr = data.as_ptr() as *const libc::c_char;\n+        let ptr = data.as_ptr() as *const c_char;\n         let cstr: &'static CStr = unsafe { CStr::from_ptr(ptr) };\n \n         let mut s = SipHasher::new_with_keys(0, 0);"}, {"sha": "17d6b2605c62831c7300491b4a824f3f90bb79cd", "filename": "src/libstd/os/raw.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b8eaa1605a40978c65ebf255dd2e16ef729193c2/src%2Flibstd%2Fos%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8eaa1605a40978c65ebf255dd2e16ef729193c2/src%2Flibstd%2Fos%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos%2Fraw.rs?ref=b8eaa1605a40978c65ebf255dd2e16ef729193c2", "patch": "@@ -12,9 +12,13 @@\n \n #![stable(feature = \"raw_os\", since = \"1.1.0\")]\n \n-#[cfg(any(target_arch = \"aarch64\", target_os = \"android\"))]\n+#[cfg(any(target_os = \"android\",\n+          all(target_os = \"linux\", any(target_arch = \"aarch64\",\n+                                       target_arch = \"arm\"))))]\n #[stable(feature = \"raw_os\", since = \"1.1.0\")] pub type c_char = u8;\n-#[cfg(not(any(target_arch = \"aarch64\", target_os = \"android\")))]\n+#[cfg(not(any(target_os = \"android\",\n+              all(target_os = \"linux\", any(target_arch = \"aarch64\",\n+                                           target_arch = \"arm\")))))]\n #[stable(feature = \"raw_os\", since = \"1.1.0\")] pub type c_char = i8;\n #[stable(feature = \"raw_os\", since = \"1.1.0\")] pub type c_schar = i8;\n #[stable(feature = \"raw_os\", since = \"1.1.0\")] pub type c_uchar = u8;"}, {"sha": "2d345d9142b0bd70f025254d7c77ff53d15e3b44", "filename": "src/test/compile-fail/const-pattern-irrefutable.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/b8eaa1605a40978c65ebf255dd2e16ef729193c2/src%2Ftest%2Fcompile-fail%2Fconst-pattern-irrefutable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8eaa1605a40978c65ebf255dd2e16ef729193c2/src%2Ftest%2Fcompile-fail%2Fconst-pattern-irrefutable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconst-pattern-irrefutable.rs?ref=b8eaa1605a40978c65ebf255dd2e16ef729193c2", "patch": "@@ -0,0 +1,28 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+mod foo {\n+    const b: u8 = 2; //~ NOTE constant defined here\n+    const d: u8 = 2; //~ NOTE constant defined here\n+}\n+\n+use foo::b as c; //~ NOTE constant imported here\n+use foo::d; //~ NOTE constant imported here\n+\n+const a: u8 = 2; //~ NOTE constant defined here\n+\n+fn main() {\n+    let a = 4; //~ ERROR only irrefutable\n+               //~^ NOTE there already is a constant in scope\n+    let c = 4; //~ ERROR only irrefutable\n+               //~^ NOTE there already is a constant in scope\n+    let d = 4; //~ ERROR only irrefutable\n+               //~^ NOTE there already is a constant in scope\n+}"}]}