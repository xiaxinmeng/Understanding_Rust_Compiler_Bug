{"sha": "ebec55406ba94faf8b2cd23b27a8f74df97d1ca4", "node_id": "MDY6Q29tbWl0NzI0NzEyOmViZWM1NTQwNmJhOTRmYWY4YjJjZDIzYjI3YThmNzRkZjk3ZDFjYTQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-11-21T14:08:47Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-11-21T14:08:47Z"}, "message": "Auto merge of #37824 - jseyfried:symbols, r=eddyb\n\nClean up `ast::Attribute`, `ast::CrateConfig`, and string interning\n\nThis PR\n - removes `ast::Attribute_` (changing `Attribute` from `Spanned<Attribute_>` to a struct),\n - moves a `MetaItem`'s name from the `MetaItemKind` variants to a field of `MetaItem`,\n - avoids needlessly wrapping `ast::MetaItem` with `P`,\n - moves string interning into `syntax::symbol` (`ast::Name` is a reexport of `symbol::Symbol` for now),\n - replaces `InternedString` with `Symbol` in the AST, HIR, and various other places, and\n - refactors `ast::CrateConfig` from a `Vec` to a `HashSet`.\n\nr? @eddyb", "tree": {"sha": "446c06caed20d58ba039ba0e7739a89a136e74aa", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/446c06caed20d58ba039ba0e7739a89a136e74aa"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4", "html_url": "https://github.com/rust-lang/rust/commit/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "59b87b3975c97820b32ba6ebee8eac2a13ab883b", "url": "https://api.github.com/repos/rust-lang/rust/commits/59b87b3975c97820b32ba6ebee8eac2a13ab883b", "html_url": "https://github.com/rust-lang/rust/commit/59b87b3975c97820b32ba6ebee8eac2a13ab883b"}, {"sha": "a8e86f0f816c9666915c73e80969dbf85a5afd56", "url": "https://api.github.com/repos/rust-lang/rust/commits/a8e86f0f816c9666915c73e80969dbf85a5afd56", "html_url": "https://github.com/rust-lang/rust/commit/a8e86f0f816c9666915c73e80969dbf85a5afd56"}], "stats": {"total": 3348, "additions": 1519, "deletions": 1829}, "files": [{"sha": "1ae906e0aa4e013016661fda77517168ec7903d1", "filename": "src/libproc_macro_plugin/qquote.rs", "status": "modified", "additions": 28, "deletions": 24, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibproc_macro_plugin%2Fqquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibproc_macro_plugin%2Fqquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro_plugin%2Fqquote.rs?ref=ebec55406ba94faf8b2cd23b27a8f74df97d1ca4", "patch": "@@ -34,8 +34,9 @@ use syntax::codemap::Span;\n use syntax::ext::base::*;\n use syntax::ext::base;\n use syntax::ext::proc_macro_shim::build_block_emitter;\n-use syntax::parse::token::{self, Token, gensym_ident, str_to_ident};\n+use syntax::parse::token::{self, Token};\n use syntax::print::pprust;\n+use syntax::symbol::Symbol;\n use syntax::tokenstream::{TokenTree, TokenStream};\n \n // ____________________________________________________________________________________________\n@@ -124,7 +125,7 @@ fn qquote_iter<'cx>(cx: &'cx mut ExtCtxt, depth: i64, ts: TokenStream) -> (Bindi\n                     } // produce an error or something first\n                     let exp = vec![exp.unwrap().to_owned()];\n                     debug!(\"RHS: {:?}\", exp.clone());\n-                    let new_id = gensym_ident(\"tmp\");\n+                    let new_id = Ident::with_empty_ctxt(Symbol::gensym(\"tmp\"));\n                     debug!(\"RHS TS: {:?}\", TokenStream::from_tts(exp.clone()));\n                     debug!(\"RHS TS TT: {:?}\", TokenStream::from_tts(exp.clone()).to_vec());\n                     bindings.push((new_id, TokenStream::from_tts(exp)));\n@@ -179,7 +180,7 @@ fn unravel_concats(tss: Vec<TokenStream>) -> TokenStream {\n     };\n \n     while let Some(ts) = pushes.pop() {\n-        output = build_fn_call(str_to_ident(\"concat\"),\n+        output = build_fn_call(Ident::from_str(\"concat\"),\n                                concat(concat(ts,\n                                              from_tokens(vec![Token::Comma])),\n                                       output));\n@@ -209,18 +210,19 @@ fn convert_complex_tts<'cx>(cx: &'cx mut ExtCtxt, tts: Vec<QTT>) -> (Bindings, T\n             // FIXME handle sequence repetition tokens\n             QTT::QDL(qdl) => {\n                 debug!(\"  QDL: {:?} \", qdl.tts);\n-                let new_id = gensym_ident(\"qdl_tmp\");\n+                let new_id = Ident::with_empty_ctxt(Symbol::gensym(\"qdl_tmp\"));\n                 let mut cct_rec = convert_complex_tts(cx, qdl.tts);\n                 bindings.append(&mut cct_rec.0);\n                 bindings.push((new_id, cct_rec.1));\n \n                 let sep = build_delim_tok(qdl.delim);\n \n-                pushes.push(build_mod_call(vec![str_to_ident(\"proc_macro_tokens\"),\n-                                               str_to_ident(\"build\"),\n-                                               str_to_ident(\"build_delimited\")],\n-                                          concat(from_tokens(vec![Token::Ident(new_id)]),\n-                                                 concat(lex(\",\"), sep))));\n+                pushes.push(build_mod_call(\n+                    vec![Ident::from_str(\"proc_macro_tokens\"),\n+                         Ident::from_str(\"build\"),\n+                         Ident::from_str(\"build_delimited\")],\n+                    concat(from_tokens(vec![Token::Ident(new_id)]), concat(lex(\",\"), sep)),\n+                ));\n             }\n             QTT::QIdent(t) => {\n                 pushes.push(TokenStream::from_tts(vec![t]));\n@@ -250,13 +252,13 @@ fn unravel(binds: Bindings) -> TokenStream {\n \n /// Checks if the Ident is `unquote`.\n fn is_unquote(id: Ident) -> bool {\n-    let qq = str_to_ident(\"unquote\");\n+    let qq = Ident::from_str(\"unquote\");\n     id.name == qq.name  // We disregard context; unquote is _reserved_\n }\n \n /// Checks if the Ident is `quote`.\n fn is_qquote(id: Ident) -> bool {\n-    let qq = str_to_ident(\"qquote\");\n+    let qq = Ident::from_str(\"qquote\");\n     id.name == qq.name  // We disregard context; qquote is _reserved_\n }\n \n@@ -266,7 +268,8 @@ mod int_build {\n \n     use syntax::ast::{self, Ident};\n     use syntax::codemap::{DUMMY_SP};\n-    use syntax::parse::token::{self, Token, keywords, str_to_ident};\n+    use syntax::parse::token::{self, Token, Lit};\n+    use syntax::symbol::keywords;\n     use syntax::tokenstream::{TokenTree, TokenStream};\n \n     // ____________________________________________________________________________________________\n@@ -277,19 +280,19 @@ mod int_build {\n                build_paren_delimited(build_vec(build_token_tt(t))))\n     }\n \n-    pub fn emit_lit(l: token::Lit, n: Option<ast::Name>) -> TokenStream {\n+    pub fn emit_lit(l: Lit, n: Option<ast::Name>) -> TokenStream {\n         let suf = match n {\n-            Some(n) => format!(\"Some(ast::Name({}))\", n.0),\n+            Some(n) => format!(\"Some(ast::Name({}))\", n.as_u32()),\n             None => \"None\".to_string(),\n         };\n \n         let lit = match l {\n-            token::Lit::Byte(n) => format!(\"Lit::Byte(token::intern(\\\"{}\\\"))\", n.to_string()),\n-            token::Lit::Char(n) => format!(\"Lit::Char(token::intern(\\\"{}\\\"))\", n.to_string()),\n-            token::Lit::Integer(n) => format!(\"Lit::Integer(token::intern(\\\"{}\\\"))\", n.to_string()),\n-            token::Lit::Float(n) => format!(\"Lit::Float(token::intern(\\\"{}\\\"))\", n.to_string()),\n-            token::Lit::Str_(n) => format!(\"Lit::Str_(token::intern(\\\"{}\\\"))\", n.to_string()),\n-            token::Lit::ByteStr(n) => format!(\"Lit::ByteStr(token::intern(\\\"{}\\\"))\", n.to_string()),\n+            Lit::Byte(n) => format!(\"Lit::Byte(Symbol::intern(\\\"{}\\\"))\", n.to_string()),\n+            Lit::Char(n) => format!(\"Lit::Char(Symbol::intern(\\\"{}\\\"))\", n.to_string()),\n+            Lit::Float(n) => format!(\"Lit::Float(Symbol::intern(\\\"{}\\\"))\", n.to_string()),\n+            Lit::Str_(n) => format!(\"Lit::Str_(Symbol::intern(\\\"{}\\\"))\", n.to_string()),\n+            Lit::Integer(n) => format!(\"Lit::Integer(Symbol::intern(\\\"{}\\\"))\", n.to_string()),\n+            Lit::ByteStr(n) => format!(\"Lit::ByteStr(Symbol::intern(\\\"{}\\\"))\", n.to_string()),\n             _ => panic!(\"Unsupported literal\"),\n         };\n \n@@ -388,9 +391,10 @@ mod int_build {\n             Token::Underscore => lex(\"_\"),\n             Token::Literal(lit, sfx) => emit_lit(lit, sfx),\n             // fix ident expansion information... somehow\n-            Token::Ident(ident) => lex(&format!(\"Token::Ident(str_to_ident(\\\"{}\\\"))\", ident.name)),\n-            Token::Lifetime(ident) => lex(&format!(\"Token::Ident(str_to_ident(\\\"{}\\\"))\",\n-                                                   ident.name)),\n+            Token::Ident(ident) =>\n+                lex(&format!(\"Token::Ident(Ident::from_str(\\\"{}\\\"))\", ident.name)),\n+            Token::Lifetime(ident) =>\n+                lex(&format!(\"Token::Ident(Ident::from_str(\\\"{}\\\"))\", ident.name)),\n             _ => panic!(\"Unhandled case!\"),\n         }\n     }\n@@ -408,7 +412,7 @@ mod int_build {\n \n     /// Takes `input` and returns `vec![input]`.\n     pub fn build_vec(ts: TokenStream) -> TokenStream {\n-        build_mac_call(str_to_ident(\"vec\"), ts)\n+        build_mac_call(Ident::from_str(\"vec\"), ts)\n         // tts.clone().to_owned()\n     }\n "}, {"sha": "d39aba0aa7787a26854decbcca1675dbee84b9f3", "filename": "src/libproc_macro_tokens/build.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibproc_macro_tokens%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibproc_macro_tokens%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro_tokens%2Fbuild.rs?ref=ebec55406ba94faf8b2cd23b27a8f74df97d1ca4", "patch": "@@ -13,7 +13,8 @@ extern crate syntax_pos;\n \n use syntax::ast::Ident;\n use syntax::codemap::DUMMY_SP;\n-use syntax::parse::token::{self, Token, keywords, str_to_ident};\n+use syntax::parse::token::{self, Token};\n+use syntax::symbol::keywords;\n use syntax::tokenstream::{self, TokenTree, TokenStream};\n use std::rc::Rc;\n \n@@ -43,13 +44,13 @@ pub fn ident_eq(tident: &TokenTree, id: Ident) -> bool {\n \n /// Convert a `&str` into a Token.\n pub fn str_to_token_ident(s: &str) -> Token {\n-    Token::Ident(str_to_ident(s))\n+    Token::Ident(Ident::from_str(s))\n }\n \n /// Converts a keyword (from `syntax::parse::token::keywords`) into a Token that\n /// corresponds to it.\n pub fn keyword_to_token_ident(kw: keywords::Keyword) -> Token {\n-    Token::Ident(str_to_ident(&kw.name().as_str()[..]))\n+    Token::Ident(Ident::from_str(&kw.name().as_str()[..]))\n }\n \n // ____________________________________________________________________________________________"}, {"sha": "abc35634d15f456e21372a311f77bff177392a6e", "filename": "src/librustc/hir/check_attr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibrustc%2Fhir%2Fcheck_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibrustc%2Fhir%2Fcheck_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fcheck_attr.rs?ref=ebec55406ba94faf8b2cd23b27a8f74df97d1ca4", "patch": "@@ -64,7 +64,7 @@ impl<'a> CheckAttrVisitor<'a> {\n                 None => continue,\n             };\n \n-            let (message, label) = match &*name {\n+            let (message, label) = match &*name.as_str() {\n                 \"C\" => {\n                     conflicting_reprs += 1;\n                     if target != Target::Struct &&\n@@ -120,7 +120,7 @@ impl<'a> CheckAttrVisitor<'a> {\n     }\n \n     fn check_attribute(&self, attr: &ast::Attribute, target: Target) {\n-        let name: &str = &attr.name();\n+        let name: &str = &attr.name().as_str();\n         match name {\n             \"inline\" => self.check_inline(attr, target),\n             \"repr\" => self.check_repr(attr, target),"}, {"sha": "9547e09afe0035a6942c1caca56b38afa2e28897", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=ebec55406ba94faf8b2cd23b27a8f74df97d1ca4", "patch": "@@ -53,8 +53,8 @@ use syntax::ast::*;\n use syntax::errors;\n use syntax::ptr::P;\n use syntax::codemap::{respan, Spanned};\n-use syntax::parse::token;\n use syntax::std_inject;\n+use syntax::symbol::{Symbol, keywords};\n use syntax::visit::{self, Visitor};\n use syntax_pos::Span;\n \n@@ -149,7 +149,7 @@ impl<'a> LoweringContext<'a> {\n     }\n \n     fn str_to_ident(&self, s: &'static str) -> Name {\n-        token::gensym(s)\n+        Symbol::gensym(s)\n     }\n \n     fn with_parent_def<T, F>(&mut self, parent_id: NodeId, f: F) -> T\n@@ -400,8 +400,8 @@ impl<'a> LoweringContext<'a> {\n         // Don't expose `Self` (recovered \"keyword used as ident\" parse error).\n         // `rustc::ty` expects `Self` to be only used for a trait's `Self`.\n         // Instead, use gensym(\"Self\") to create a distinct name that looks the same.\n-        if name == token::keywords::SelfType.name() {\n-            name = token::gensym(\"Self\");\n+        if name == keywords::SelfType.name() {\n+            name = Symbol::gensym(\"Self\");\n         }\n \n         hir::TyParam {\n@@ -540,7 +540,7 @@ impl<'a> LoweringContext<'a> {\n         hir::StructField {\n             span: f.span,\n             id: f.id,\n-            name: f.ident.map(|ident| ident.name).unwrap_or(token::intern(&index.to_string())),\n+            name: f.ident.map(|ident| ident.name).unwrap_or(Symbol::intern(&index.to_string())),\n             vis: self.lower_visibility(&f.vis),\n             ty: self.lower_ty(&f.ty),\n             attrs: self.lower_attrs(&f.attrs),\n@@ -1189,7 +1189,7 @@ impl<'a> LoweringContext<'a> {\n                                                                           e.span,\n                                                                           hir::PopUnstableBlock,\n                                                                           ThinVec::new());\n-                                this.field(token::intern(s), signal_block, ast_expr.span)\n+                                this.field(Symbol::intern(s), signal_block, ast_expr.span)\n                             }).collect();\n                             let attrs = ast_expr.attrs.clone();\n \n@@ -1953,9 +1953,9 @@ impl<'a> LoweringContext<'a> {\n     fn std_path_components(&mut self, components: &[&str]) -> Vec<Name> {\n         let mut v = Vec::new();\n         if let Some(s) = self.crate_root {\n-            v.push(token::intern(s));\n+            v.push(Symbol::intern(s));\n         }\n-        v.extend(components.iter().map(|s| token::intern(s)));\n+        v.extend(components.iter().map(|s| Symbol::intern(s)));\n         return v;\n     }\n "}, {"sha": "7486d954c480233fde7058411c821c964a26a25f", "filename": "src/librustc/hir/map/def_collector.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs?ref=ebec55406ba94faf8b2cd23b27a8f74df97d1ca4", "patch": "@@ -19,7 +19,7 @@ use middle::cstore::InlinedItem;\n use syntax::ast::*;\n use syntax::ext::hygiene::Mark;\n use syntax::visit;\n-use syntax::parse::token::{self, keywords};\n+use syntax::symbol::{Symbol, keywords};\n \n /// Creates def ids for nodes in the HIR.\n pub struct DefCollector<'a> {\n@@ -169,7 +169,7 @@ impl<'a> visit::Visitor for DefCollector<'a> {\n                         this.with_parent(variant_def_index, |this| {\n                             for (index, field) in v.node.data.fields().iter().enumerate() {\n                                 let name = field.ident.map(|ident| ident.name)\n-                                    .unwrap_or_else(|| token::intern(&index.to_string()));\n+                                    .unwrap_or_else(|| Symbol::intern(&index.to_string()));\n                                 this.create_def(field.id, DefPathData::Field(name.as_str()));\n                             }\n \n@@ -188,7 +188,7 @@ impl<'a> visit::Visitor for DefCollector<'a> {\n \n                     for (index, field) in struct_def.fields().iter().enumerate() {\n                         let name = field.ident.map(|ident| ident.name.as_str())\n-                            .unwrap_or(token::intern(&index.to_string()).as_str());\n+                            .unwrap_or(Symbol::intern(&index.to_string()).as_str());\n                         this.create_def(field.id, DefPathData::Field(name));\n                     }\n                 }"}, {"sha": "83d3627d8e61643e4b3b4f88ea56d40ef1fe0f8f", "filename": "src/librustc/hir/map/definitions.rs", "status": "modified", "additions": 19, "deletions": 38, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs?ref=ebec55406ba94faf8b2cd23b27a8f74df97d1ca4", "patch": "@@ -14,7 +14,7 @@ use std::fmt::Write;\n use std::hash::{Hash, Hasher};\n use std::collections::hash_map::DefaultHasher;\n use syntax::ast;\n-use syntax::parse::token::{self, InternedString};\n+use syntax::symbol::{Symbol, InternedString};\n use ty::TyCtxt;\n use util::nodemap::NodeMap;\n \n@@ -115,9 +115,9 @@ impl DefPath {\n     pub fn to_string(&self, tcx: TyCtxt) -> String {\n         let mut s = String::with_capacity(self.data.len() * 16);\n \n-        s.push_str(&tcx.original_crate_name(self.krate));\n+        s.push_str(&tcx.original_crate_name(self.krate).as_str());\n         s.push_str(\"/\");\n-        s.push_str(&tcx.crate_disambiguator(self.krate));\n+        s.push_str(&tcx.crate_disambiguator(self.krate).as_str());\n \n         for component in &self.data {\n             write!(s,\n@@ -137,8 +137,8 @@ impl DefPath {\n     }\n \n     pub fn deterministic_hash_to<H: Hasher>(&self, tcx: TyCtxt, state: &mut H) {\n-        tcx.original_crate_name(self.krate).hash(state);\n-        tcx.crate_disambiguator(self.krate).hash(state);\n+        tcx.original_crate_name(self.krate).as_str().hash(state);\n+        tcx.crate_disambiguator(self.krate).as_str().hash(state);\n         self.data.hash(state);\n     }\n }\n@@ -328,7 +328,7 @@ impl DefPathData {\n             LifetimeDef(ref name) |\n             EnumVariant(ref name) |\n             Binding(ref name) |\n-            Field(ref name) => Some(token::intern(name)),\n+            Field(ref name) => Some(Symbol::intern(name)),\n \n             Impl |\n             CrateRoot |\n@@ -343,7 +343,7 @@ impl DefPathData {\n \n     pub fn as_interned_str(&self) -> InternedString {\n         use self::DefPathData::*;\n-        match *self {\n+        let s = match *self {\n             TypeNs(ref name) |\n             ValueNs(ref name) |\n             Module(ref name) |\n@@ -353,43 +353,24 @@ impl DefPathData {\n             EnumVariant(ref name) |\n             Binding(ref name) |\n             Field(ref name) => {\n-                name.clone()\n-            }\n-\n-            Impl => {\n-                InternedString::new(\"{{impl}}\")\n+                return name.clone();\n             }\n \n             // note that this does not show up in user printouts\n-            CrateRoot => {\n-                InternedString::new(\"{{root}}\")\n-            }\n+            CrateRoot => \"{{root}}\",\n \n             // note that this does not show up in user printouts\n-            InlinedRoot(_) => {\n-                InternedString::new(\"{{inlined-root}}\")\n-            }\n-\n-            Misc => {\n-                InternedString::new(\"{{?}}\")\n-            }\n-\n-            ClosureExpr => {\n-                InternedString::new(\"{{closure}}\")\n-            }\n-\n-            StructCtor => {\n-                InternedString::new(\"{{constructor}}\")\n-            }\n-\n-            Initializer => {\n-                InternedString::new(\"{{initializer}}\")\n-            }\n+            InlinedRoot(_) => \"{{inlined-root}}\",\n+\n+            Impl => \"{{impl}}\",\n+            Misc => \"{{?}}\",\n+            ClosureExpr => \"{{closure}}\",\n+            StructCtor => \"{{constructor}}\",\n+            Initializer => \"{{initializer}}\",\n+            ImplTrait => \"{{impl-Trait}}\",\n+        };\n \n-            ImplTrait => {\n-                InternedString::new(\"{{impl-Trait}}\")\n-            }\n-        }\n+        Symbol::intern(s).as_str()\n     }\n \n     pub fn to_string(&self) -> String {"}, {"sha": "a90577b34261c4e7c8338052aac83f4823511dda", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=ebec55406ba94faf8b2cd23b27a8f74df97d1ca4", "patch": "@@ -765,7 +765,7 @@ impl<'a, 'ast> NodesMatchingSuffix<'a, 'ast> {\n                 None => return false,\n                 Some((node_id, name)) => (node_id, name),\n             };\n-            if &part[..] != mod_name.as_str() {\n+            if mod_name != &**part {\n                 return false;\n             }\n             cursor = self.map.get_parent(mod_id);\n@@ -803,8 +803,7 @@ impl<'a, 'ast> NodesMatchingSuffix<'a, 'ast> {\n     // We are looking at some node `n` with a given name and parent\n     // id; do their names match what I am seeking?\n     fn matches_names(&self, parent_of_n: NodeId, name: Name) -> bool {\n-        name.as_str() == &self.item_name[..] &&\n-            self.suffix_matches(parent_of_n)\n+        name == &**self.item_name && self.suffix_matches(parent_of_n)\n     }\n }\n "}, {"sha": "b5f892f0ff7ace30a831ece6e506eb33fa001a65", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=ebec55406ba94faf8b2cd23b27a8f74df97d1ca4", "patch": "@@ -40,8 +40,8 @@ use syntax::codemap::{self, respan, Spanned};\n use syntax::abi::Abi;\n use syntax::ast::{Name, NodeId, DUMMY_NODE_ID, AsmDialect};\n use syntax::ast::{Attribute, Lit, StrStyle, FloatTy, IntTy, UintTy, MetaItem};\n-use syntax::parse::token::{keywords, InternedString};\n use syntax::ptr::P;\n+use syntax::symbol::{Symbol, keywords};\n use syntax::tokenstream::TokenTree;\n use syntax::util::ThinVec;\n \n@@ -1163,18 +1163,18 @@ pub enum Ty_ {\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct InlineAsmOutput {\n-    pub constraint: InternedString,\n+    pub constraint: Symbol,\n     pub is_rw: bool,\n     pub is_indirect: bool,\n }\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct InlineAsm {\n-    pub asm: InternedString,\n+    pub asm: Symbol,\n     pub asm_str_style: StrStyle,\n     pub outputs: HirVec<InlineAsmOutput>,\n-    pub inputs: HirVec<InternedString>,\n-    pub clobbers: HirVec<InternedString>,\n+    pub inputs: HirVec<Symbol>,\n+    pub clobbers: HirVec<Symbol>,\n     pub volatile: bool,\n     pub alignstack: bool,\n     pub dialect: AsmDialect,"}, {"sha": "b9d1d7e4efbb986a91e3348c06fa13f760287f14", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=ebec55406ba94faf8b2cd23b27a8f74df97d1ca4", "patch": "@@ -13,13 +13,14 @@ pub use self::AnnNode::*;\n use syntax::abi::Abi;\n use syntax::ast;\n use syntax::codemap::{CodeMap, Spanned};\n-use syntax::parse::token::{self, keywords, BinOpToken};\n+use syntax::parse::token::{self, BinOpToken};\n use syntax::parse::lexer::comments;\n use syntax::print::pp::{self, break_offset, word, space, hardbreak};\n use syntax::print::pp::{Breaks, eof};\n use syntax::print::pp::Breaks::{Consistent, Inconsistent};\n use syntax::print::pprust::{self as ast_pp, PrintState};\n use syntax::ptr::P;\n+use syntax::symbol::keywords;\n use syntax_pos::{self, BytePos};\n use errors;\n \n@@ -1499,19 +1500,19 @@ impl<'a> State<'a> {\n             hir::ExprInlineAsm(ref a, ref outputs, ref inputs) => {\n                 word(&mut self.s, \"asm!\")?;\n                 self.popen()?;\n-                self.print_string(&a.asm, a.asm_str_style)?;\n+                self.print_string(&a.asm.as_str(), a.asm_str_style)?;\n                 self.word_space(\":\")?;\n \n                 let mut out_idx = 0;\n                 self.commasep(Inconsistent, &a.outputs, |s, out| {\n-                    let mut ch = out.constraint.chars();\n+                    let constraint = out.constraint.as_str();\n+                    let mut ch = constraint.chars();\n                     match ch.next() {\n                         Some('=') if out.is_rw => {\n                             s.print_string(&format!(\"+{}\", ch.as_str()),\n                                            ast::StrStyle::Cooked)?\n                         }\n-                        _ => s.print_string(&out.constraint,\n-                                            ast::StrStyle::Cooked)?,\n+                        _ => s.print_string(&constraint, ast::StrStyle::Cooked)?,\n                     }\n                     s.popen()?;\n                     s.print_expr(&outputs[out_idx])?;\n@@ -1524,7 +1525,7 @@ impl<'a> State<'a> {\n \n                 let mut in_idx = 0;\n                 self.commasep(Inconsistent, &a.inputs, |s, co| {\n-                    s.print_string(&co, ast::StrStyle::Cooked)?;\n+                    s.print_string(&co.as_str(), ast::StrStyle::Cooked)?;\n                     s.popen()?;\n                     s.print_expr(&inputs[in_idx])?;\n                     s.pclose()?;\n@@ -1535,7 +1536,7 @@ impl<'a> State<'a> {\n                 self.word_space(\":\")?;\n \n                 self.commasep(Inconsistent, &a.clobbers, |s, co| {\n-                    s.print_string(&co, ast::StrStyle::Cooked)?;\n+                    s.print_string(&co.as_str(), ast::StrStyle::Cooked)?;\n                     Ok(())\n                 })?;\n "}, {"sha": "8db09d0b73d32485d1e2ba0f48f56e26f4a48a4c", "filename": "src/librustc/infer/error_reporting.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibrustc%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibrustc%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting.rs?ref=ebec55406ba94faf8b2cd23b27a8f74df97d1ca4", "patch": "@@ -91,8 +91,8 @@ use std::cell::{Cell, RefCell};\n use std::char::from_u32;\n use std::fmt;\n use syntax::ast;\n-use syntax::parse::token;\n use syntax::ptr::P;\n+use syntax::symbol::Symbol;\n use syntax_pos::{self, Pos, Span};\n use errors::DiagnosticBuilder;\n \n@@ -1219,7 +1219,7 @@ impl<'a, 'gcx, 'tcx> Rebuilder<'a, 'gcx, 'tcx> {\n                 names.push(lt_name);\n             }\n             names.sort();\n-            let name = token::intern(&names[0]);\n+            let name = Symbol::intern(&names[0]);\n             return (name_to_dummy_lifetime(name), Kept);\n         }\n         return (self.life_giver.give_lifetime(), Fresh);\n@@ -1931,7 +1931,7 @@ impl LifeGiver {\n             let mut s = String::from(\"'\");\n             s.push_str(&num_to_string(self.counter.get()));\n             if !self.taken.contains(&s) {\n-                lifetime = name_to_dummy_lifetime(token::intern(&s[..]));\n+                lifetime = name_to_dummy_lifetime(Symbol::intern(&s));\n                 self.generated.borrow_mut().push(lifetime);\n                 break;\n             }"}, {"sha": "4a082944010b2838fb73d12cc26d84f9d7bea0eb", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 8, "deletions": 14, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=ebec55406ba94faf8b2cd23b27a8f74df97d1ca4", "patch": "@@ -40,7 +40,6 @@ use std::default::Default as StdDefault;\n use std::mem;\n use std::fmt;\n use syntax::attr;\n-use syntax::parse::token::InternedString;\n use syntax::ast;\n use syntax_pos::{MultiSpan, Span};\n use errors::{self, Diagnostic, DiagnosticBuilder};\n@@ -384,8 +383,7 @@ macro_rules! run_lints { ($cx:expr, $f:ident, $ps:ident, $($args:expr),*) => ({\n /// Parse the lint attributes into a vector, with `Err`s for malformed lint\n /// attributes. Writing this as an iterator is an enormous mess.\n // See also the hir version just below.\n-pub fn gather_attrs(attrs: &[ast::Attribute])\n-                    -> Vec<Result<(InternedString, Level, Span), Span>> {\n+pub fn gather_attrs(attrs: &[ast::Attribute]) -> Vec<Result<(ast::Name, Level, Span), Span>> {\n     let mut out = vec![];\n     for attr in attrs {\n         let r = gather_attr(attr);\n@@ -394,18 +392,17 @@ pub fn gather_attrs(attrs: &[ast::Attribute])\n     out\n }\n \n-pub fn gather_attr(attr: &ast::Attribute)\n-                   -> Vec<Result<(InternedString, Level, Span), Span>> {\n+pub fn gather_attr(attr: &ast::Attribute) -> Vec<Result<(ast::Name, Level, Span), Span>> {\n     let mut out = vec![];\n \n-    let level = match Level::from_str(&attr.name()) {\n+    let level = match Level::from_str(&attr.name().as_str()) {\n         None => return out,\n         Some(lvl) => lvl,\n     };\n \n     attr::mark_used(attr);\n \n-    let meta = &attr.node.value;\n+    let meta = &attr.value;\n     let metas = if let Some(metas) = meta.meta_item_list() {\n         metas\n     } else {\n@@ -414,9 +411,7 @@ pub fn gather_attr(attr: &ast::Attribute)\n     };\n \n     for li in metas {\n-        out.push(li.word().map_or(Err(li.span), |word| {\n-            Ok((word.name().clone(), level, word.span))\n-        }));\n+        out.push(li.word().map_or(Err(li.span), |word| Ok((word.name(), level, word.span))));\n     }\n \n     out\n@@ -629,10 +624,10 @@ pub trait LintContext: Sized {\n                     continue;\n                 }\n                 Ok((lint_name, level, span)) => {\n-                    match self.lints().find_lint(&lint_name, &self.sess(), Some(span)) {\n+                    match self.lints().find_lint(&lint_name.as_str(), &self.sess(), Some(span)) {\n                         Ok(lint_id) => vec![(lint_id, level, span)],\n                         Err(FindLintError::NotFound) => {\n-                            match self.lints().lint_groups.get(&lint_name[..]) {\n+                            match self.lints().lint_groups.get(&*lint_name.as_str()) {\n                                 Some(&(ref v, _)) => v.iter()\n                                                       .map(|lint_id: &LintId|\n                                                            (*lint_id, level, span))\n@@ -1193,8 +1188,7 @@ fn check_lint_name_attribute(cx: &LateContext, attr: &ast::Attribute) {\n                 continue;\n             }\n             Ok((lint_name, _, span)) => {\n-                match check_lint_name(&cx.lints,\n-                                      &lint_name[..]) {\n+                match check_lint_name(&cx.lints, &lint_name.as_str()) {\n                     CheckLintNameResult::Ok => (),\n                     CheckLintNameResult::Warning(ref msg) => {\n                         cx.span_lint(builtin::RENAMED_AND_REMOVED_LINTS,"}, {"sha": "9677082a43a3c2d03dcef9faa383e804abc54c8b", "filename": "src/librustc/middle/const_val.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibrustc%2Fmiddle%2Fconst_val.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibrustc%2Fmiddle%2Fconst_val.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_val.rs?ref=ebec55406ba94faf8b2cd23b27a8f74df97d1ca4", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use syntax::parse::token::InternedString;\n+use syntax::symbol::InternedString;\n use syntax::ast;\n use std::rc::Rc;\n use hir::def_id::DefId;"}, {"sha": "168aba774333e99c1cf0af4284efe91f49f9f104", "filename": "src/librustc/middle/cstore.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcstore.rs?ref=ebec55406ba94faf8b2cd23b27a8f74df97d1ca4", "patch": "@@ -39,7 +39,7 @@ use syntax::ast;\n use syntax::attr;\n use syntax::ext::base::SyntaxExtension;\n use syntax::ptr::P;\n-use syntax::parse::token::InternedString;\n+use syntax::symbol::Symbol;\n use syntax_pos::Span;\n use rustc_back::target::Target;\n use hir;\n@@ -52,7 +52,7 @@ pub use self::NativeLibraryKind::{NativeStatic, NativeFramework, NativeUnknown};\n \n #[derive(Clone, Debug)]\n pub struct LinkMeta {\n-    pub crate_name: String,\n+    pub crate_name: Symbol,\n     pub crate_hash: Svh,\n }\n \n@@ -92,8 +92,8 @@ pub enum NativeLibraryKind {\n #[derive(Clone, Hash, RustcEncodable, RustcDecodable)]\n pub struct NativeLibrary {\n     pub kind: NativeLibraryKind,\n-    pub name: String,\n-    pub cfg: Option<P<ast::MetaItem>>,\n+    pub name: Symbol,\n+    pub cfg: Option<ast::MetaItem>,\n }\n \n /// The data we save and restore about an inlined item or method.  This is not\n@@ -205,11 +205,11 @@ pub trait CrateStore<'tcx> {\n     fn extern_crate(&self, cnum: CrateNum) -> Option<ExternCrate>;\n     /// The name of the crate as it is referred to in source code of the current\n     /// crate.\n-    fn crate_name(&self, cnum: CrateNum) -> InternedString;\n+    fn crate_name(&self, cnum: CrateNum) -> Symbol;\n     /// The name of the crate as it is stored in the crate's metadata.\n-    fn original_crate_name(&self, cnum: CrateNum) -> InternedString;\n+    fn original_crate_name(&self, cnum: CrateNum) -> Symbol;\n     fn crate_hash(&self, cnum: CrateNum) -> Svh;\n-    fn crate_disambiguator(&self, cnum: CrateNum) -> InternedString;\n+    fn crate_disambiguator(&self, cnum: CrateNum) -> Symbol;\n     fn plugin_registrar_fn(&self, cnum: CrateNum) -> Option<DefId>;\n     fn native_libraries(&self, cnum: CrateNum) -> Vec<NativeLibrary>;\n     fn reachable_ids(&self, cnum: CrateNum) -> Vec<DefId>;\n@@ -375,13 +375,13 @@ impl<'tcx> CrateStore<'tcx> for DummyCrateStore {\n         bug!(\"panic_strategy\")\n     }\n     fn extern_crate(&self, cnum: CrateNum) -> Option<ExternCrate> { bug!(\"extern_crate\") }\n-    fn crate_name(&self, cnum: CrateNum) -> InternedString { bug!(\"crate_name\") }\n-    fn original_crate_name(&self, cnum: CrateNum) -> InternedString {\n+    fn crate_name(&self, cnum: CrateNum) -> Symbol { bug!(\"crate_name\") }\n+    fn original_crate_name(&self, cnum: CrateNum) -> Symbol {\n         bug!(\"original_crate_name\")\n     }\n     fn crate_hash(&self, cnum: CrateNum) -> Svh { bug!(\"crate_hash\") }\n     fn crate_disambiguator(&self, cnum: CrateNum)\n-                           -> InternedString { bug!(\"crate_disambiguator\") }\n+                           -> Symbol { bug!(\"crate_disambiguator\") }\n     fn plugin_registrar_fn(&self, cnum: CrateNum) -> Option<DefId>\n         { bug!(\"plugin_registrar_fn\") }\n     fn native_libraries(&self, cnum: CrateNum) -> Vec<NativeLibrary>"}, {"sha": "f47eab013c2b216a4789e40e54d1031c10132340", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=ebec55406ba94faf8b2cd23b27a8f74df97d1ca4", "patch": "@@ -309,8 +309,7 @@ fn has_allow_dead_code_or_lang_attr(attrs: &[ast::Attribute]) -> bool {\n     let dead_code = lint::builtin::DEAD_CODE.name_lower();\n     for attr in lint::gather_attrs(attrs) {\n         match attr {\n-            Ok((ref name, lint::Allow, _))\n-                if &name[..] == dead_code => return true,\n+            Ok((name, lint::Allow, _)) if name == &*dead_code => return true,\n             _ => (),\n         }\n     }\n@@ -499,8 +498,7 @@ impl<'a, 'tcx> DeadVisitor<'a, 'tcx> {\n                       span: syntax_pos::Span,\n                       name: ast::Name,\n                       node_type: &str) {\n-        let name = name.as_str();\n-        if !name.starts_with(\"_\") {\n+        if !name.as_str().starts_with(\"_\") {\n             self.tcx\n                 .sess\n                 .add_lint(lint::builtin::DEAD_CODE,"}, {"sha": "65aedae347a8d0cd4538f6d824f1c7d495448e35", "filename": "src/librustc/middle/entry.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibrustc%2Fmiddle%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibrustc%2Fmiddle%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fentry.rs?ref=ebec55406ba94faf8b2cd23b27a8f74df97d1ca4", "patch": "@@ -92,7 +92,7 @@ fn entry_point_type(item: &Item, at_root: bool) -> EntryPointType {\n                 EntryPointType::Start\n             } else if attr::contains_name(&item.attrs, \"main\") {\n                 EntryPointType::MainAttr\n-            } else if item.name.as_str() == \"main\" {\n+            } else if item.name == \"main\" {\n                 if at_root {\n                     // This is a top-level function so can be 'main'\n                     EntryPointType::MainNamed"}, {"sha": "80cf64865abea7043ded3f20e2c5575c52a85d49", "filename": "src/librustc/middle/intrinsicck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs?ref=ebec55406ba94faf8b2cd23b27a8f74df97d1ca4", "patch": "@@ -55,7 +55,7 @@ impl<'a, 'gcx, 'tcx> ExprVisitor<'a, 'gcx, 'tcx> {\n             ty::TyFnDef(.., ref bfty) => bfty.abi == RustIntrinsic,\n             _ => return false\n         };\n-        intrinsic && self.infcx.tcx.item_name(def_id).as_str() == \"transmute\"\n+        intrinsic && self.infcx.tcx.item_name(def_id) == \"transmute\"\n     }\n \n     fn check_transmute(&self, span: Span, from: Ty<'gcx>, to: Ty<'gcx>, id: ast::NodeId) {"}, {"sha": "5af9a2f02742effbe3d4a5663a4fd177b654a7ed", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=ebec55406ba94faf8b2cd23b27a8f74df97d1ca4", "patch": "@@ -30,7 +30,7 @@ use middle::weak_lang_items;\n use util::nodemap::FxHashMap;\n \n use syntax::ast;\n-use syntax::parse::token::InternedString;\n+use syntax::symbol::Symbol;\n use hir::itemlikevisit::ItemLikeVisitor;\n use hir;\n \n@@ -152,15 +152,15 @@ struct LanguageItemCollector<'a, 'tcx: 'a> {\n impl<'a, 'v, 'tcx> ItemLikeVisitor<'v> for LanguageItemCollector<'a, 'tcx> {\n     fn visit_item(&mut self, item: &hir::Item) {\n         if let Some(value) = extract(&item.attrs) {\n-            let item_index = self.item_refs.get(&value[..]).cloned();\n+            let item_index = self.item_refs.get(&*value.as_str()).cloned();\n \n             if let Some(item_index) = item_index {\n                 self.collect_item(item_index, self.ast_map.local_def_id(item.id))\n             } else {\n                 let span = self.ast_map.span(item.id);\n                 span_err!(self.session, span, E0522,\n                           \"definition of an unknown language item: `{}`.\",\n-                          &value[..]);\n+                          value);\n             }\n         }\n     }\n@@ -243,12 +243,10 @@ impl<'a, 'tcx> LanguageItemCollector<'a, 'tcx> {\n     }\n }\n \n-pub fn extract(attrs: &[ast::Attribute]) -> Option<InternedString> {\n+pub fn extract(attrs: &[ast::Attribute]) -> Option<Symbol> {\n     for attribute in attrs {\n         match attribute.value_str() {\n-            Some(ref value) if attribute.check_name(\"lang\") => {\n-                return Some(value.clone());\n-            }\n+            Some(value) if attribute.check_name(\"lang\") => return Some(value),\n             _ => {}\n         }\n     }"}, {"sha": "cf53fcf2dac86658b82a24721743fdd5d397e42b", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=ebec55406ba94faf8b2cd23b27a8f74df97d1ca4", "patch": "@@ -123,8 +123,8 @@ use std::io::prelude::*;\n use std::io;\n use std::rc::Rc;\n use syntax::ast::{self, NodeId};\n-use syntax::parse::token::keywords;\n use syntax::ptr::P;\n+use syntax::symbol::keywords;\n use syntax_pos::Span;\n \n use hir::Expr;"}, {"sha": "7f89461a3f4b6823718ec24788f9f06381747f6d", "filename": "src/librustc/middle/recursion_limit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibrustc%2Fmiddle%2Frecursion_limit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibrustc%2Fmiddle%2Frecursion_limit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Frecursion_limit.rs?ref=ebec55406ba94faf8b2cd23b27a8f74df97d1ca4", "patch": "@@ -25,7 +25,7 @@ pub fn update_recursion_limit(sess: &Session, krate: &ast::Crate) {\n         }\n \n         if let Some(s) = attr.value_str() {\n-            if let Some(n) = s.parse().ok() {\n+            if let Some(n) = s.as_str().parse().ok() {\n                 sess.recursion_limit.set(n);\n                 return;\n             }"}, {"sha": "a0043d0a886208c5e475d1cf75fa92a876a4ad7b", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=ebec55406ba94faf8b2cd23b27a8f74df97d1ca4", "patch": "@@ -27,7 +27,7 @@ use middle::region;\n use ty;\n use std::mem::replace;\n use syntax::ast;\n-use syntax::parse::token::keywords;\n+use syntax::symbol::keywords;\n use syntax_pos::Span;\n use util::nodemap::NodeMap;\n "}, {"sha": "86a89eff3a476a9cd5c54a8432250738ba642a2d", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=ebec55406ba94faf8b2cd23b27a8f74df97d1ca4", "patch": "@@ -21,7 +21,7 @@ use hir::def::Def;\n use hir::def_id::{CrateNum, CRATE_DEF_INDEX, DefId, DefIndex, LOCAL_CRATE};\n use ty::{self, TyCtxt, AdtKind};\n use middle::privacy::AccessLevels;\n-use syntax::parse::token::InternedString;\n+use syntax::symbol::Symbol;\n use syntax_pos::{Span, DUMMY_SP};\n use syntax::ast;\n use syntax::ast::{NodeId, Attribute};\n@@ -36,7 +36,6 @@ use hir::pat_util::EnumerateAndAdjustIterator;\n \n use std::mem::replace;\n use std::cmp::Ordering;\n-use std::ops::Deref;\n \n #[derive(RustcEncodable, RustcDecodable, PartialEq, PartialOrd, Clone, Copy, Debug, Eq, Hash)]\n pub enum StabilityLevel {\n@@ -151,10 +150,11 @@ impl<'a, 'tcx: 'a> Annotator<'a, 'tcx> {\n \n                 // Check if deprecated_since < stable_since. If it is,\n                 // this is *almost surely* an accident.\n-                if let (&Some(attr::RustcDeprecation {since: ref dep_since, ..}),\n-                        &attr::Stable {since: ref stab_since}) = (&stab.rustc_depr, &stab.level) {\n+                if let (&Some(attr::RustcDeprecation {since: dep_since, ..}),\n+                        &attr::Stable {since: stab_since}) = (&stab.rustc_depr, &stab.level) {\n                     // Explicit version of iter::order::lt to handle parse errors properly\n-                    for (dep_v, stab_v) in dep_since.split(\".\").zip(stab_since.split(\".\")) {\n+                    for (dep_v, stab_v) in\n+                            dep_since.as_str().split(\".\").zip(stab_since.as_str().split(\".\")) {\n                         if let (Ok(dep_v), Ok(stab_v)) = (dep_v.parse::<u64>(), stab_v.parse()) {\n                             match dep_v.cmp(&stab_v) {\n                                 Ordering::Less => {\n@@ -356,7 +356,7 @@ impl<'a, 'tcx> Index<'tcx> {\n /// features and possibly prints errors. Returns a list of all\n /// features used.\n pub fn check_unstable_api_usage<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>)\n-                                          -> FxHashMap<InternedString, attr::StabilityLevel> {\n+                                          -> FxHashMap<Symbol, attr::StabilityLevel> {\n     let _task = tcx.dep_graph.in_task(DepNode::StabilityCheck);\n     let ref active_lib_features = tcx.sess.features.borrow().declared_lib_features;\n \n@@ -376,8 +376,8 @@ pub fn check_unstable_api_usage<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>)\n \n struct Checker<'a, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    active_features: FxHashSet<InternedString>,\n-    used_features: FxHashMap<InternedString, attr::StabilityLevel>,\n+    active_features: FxHashSet<Symbol>,\n+    used_features: FxHashMap<Symbol, attr::StabilityLevel>,\n     // Within a block where feature gate checking can be skipped.\n     in_skip_block: u32,\n }\n@@ -407,10 +407,10 @@ impl<'a, 'tcx> Checker<'a, 'tcx> {\n                 if !self.active_features.contains(feature) {\n                     let msg = match *reason {\n                         Some(ref r) => format!(\"use of unstable library feature '{}': {}\",\n-                                               &feature, &r),\n+                                               &feature.as_str(), &r),\n                         None => format!(\"use of unstable library feature '{}'\", &feature)\n                     };\n-                    emit_feature_err(&self.tcx.sess.parse_sess, &feature, span,\n+                    emit_feature_err(&self.tcx.sess.parse_sess, &feature.as_str(), span,\n                                      GateIssue::Library(Some(issue)), &msg);\n                 }\n             }\n@@ -455,7 +455,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n         // When compiling with --test we don't enforce stability on the\n         // compiler-generated test module, demarcated with `DUMMY_SP` plus the\n         // name `__test`\n-        if item.span == DUMMY_SP && item.name.as_str() == \"__test\" { return }\n+        if item.span == DUMMY_SP && item.name == \"__test\" { return }\n \n         check_item(self.tcx, item, true,\n                    &mut |id, sp, stab, depr| self.check(id, sp, stab, depr));\n@@ -735,18 +735,18 @@ impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n /// were expected to be library features), and the list of features used from\n /// libraries, identify activated features that don't exist and error about them.\n pub fn check_unused_or_stable_features(sess: &Session,\n-                                       lib_features_used: &FxHashMap<InternedString,\n+                                       lib_features_used: &FxHashMap<Symbol,\n                                                                      attr::StabilityLevel>) {\n     let ref declared_lib_features = sess.features.borrow().declared_lib_features;\n-    let mut remaining_lib_features: FxHashMap<InternedString, Span>\n+    let mut remaining_lib_features: FxHashMap<Symbol, Span>\n         = declared_lib_features.clone().into_iter().collect();\n \n     fn format_stable_since_msg(version: &str) -> String {\n         format!(\"this feature has been stable since {}. Attribute no longer needed\", version)\n     }\n \n     for &(ref stable_lang_feature, span) in &sess.features.borrow().declared_stable_lang_features {\n-        let version = find_lang_feature_accepted_version(stable_lang_feature.deref())\n+        let version = find_lang_feature_accepted_version(&stable_lang_feature.as_str())\n             .expect(\"unexpectedly couldn't find version feature was stabilized\");\n         sess.add_lint(lint::builtin::STABLE_FEATURES,\n                       ast::CRATE_NODE_ID,\n@@ -761,7 +761,7 @@ pub fn check_unused_or_stable_features(sess: &Session,\n                     sess.add_lint(lint::builtin::STABLE_FEATURES,\n                                   ast::CRATE_NODE_ID,\n                                   span,\n-                                  format_stable_since_msg(version.deref()));\n+                                  format_stable_since_msg(&version.as_str()));\n                 }\n             }\n             None => ( /* used but undeclared, handled during the previous ast visit */ )"}, {"sha": "ec6971d596b14cfa54bd16a13191dc84ab89be4b", "filename": "src/librustc/middle/weak_lang_items.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibrustc%2Fmiddle%2Fweak_lang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibrustc%2Fmiddle%2Fweak_lang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fweak_lang_items.rs?ref=ebec55406ba94faf8b2cd23b27a8f74df97d1ca4", "patch": "@@ -16,7 +16,7 @@ use middle::lang_items;\n \n use rustc_back::PanicStrategy;\n use syntax::ast;\n-use syntax::parse::token::InternedString;\n+use syntax::symbol::Symbol;\n use syntax_pos::Span;\n use hir::intravisit::Visitor;\n use hir::intravisit;\n@@ -55,10 +55,10 @@ pub fn check_crate(krate: &hir::Crate,\n     verify(sess, items);\n }\n \n-pub fn link_name(attrs: &[ast::Attribute]) -> Option<InternedString> {\n+pub fn link_name(attrs: &[ast::Attribute]) -> Option<Symbol> {\n     lang_items::extract(attrs).and_then(|name| {\n-        $(if &name[..] == stringify!($name) {\n-            Some(InternedString::new(stringify!($sym)))\n+        $(if name == stringify!($name) {\n+            Some(Symbol::intern(stringify!($sym)))\n         } else)* {\n             None\n         }\n@@ -126,7 +126,7 @@ impl<'a> Context<'a> {\n impl<'a, 'v> Visitor<'v> for Context<'a> {\n     fn visit_foreign_item(&mut self, i: &hir::ForeignItem) {\n         if let Some(lang_item) = lang_items::extract(&i.attrs) {\n-            self.register(&lang_item, i.span);\n+            self.register(&lang_item.as_str(), i.span);\n         }\n         intravisit::walk_foreign_item(self, i)\n     }"}, {"sha": "103e2a949df19a24177df00930985a4f650441fc", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 33, "deletions": 46, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=ebec55406ba94faf8b2cd23b27a8f74df97d1ca4", "patch": "@@ -25,9 +25,8 @@ use lint;\n use middle::cstore;\n \n use syntax::ast::{self, IntTy, UintTy};\n-use syntax::attr;\n use syntax::parse;\n-use syntax::parse::token::InternedString;\n+use syntax::symbol::Symbol;\n use syntax::feature_gate::UnstableFeatures;\n \n use errors::{ColorConfig, FatalError, Handler};\n@@ -41,6 +40,7 @@ use std::collections::btree_map::Values as BTreeMapValuesIter;\n use std::fmt;\n use std::hash::Hasher;\n use std::collections::hash_map::DefaultHasher;\n+use std::collections::HashSet;\n use std::iter::FromIterator;\n use std::path::PathBuf;\n \n@@ -927,8 +927,6 @@ pub fn default_lib_output() -> CrateType {\n }\n \n pub fn default_configuration(sess: &Session) -> ast::CrateConfig {\n-    use syntax::parse::token::intern_and_get_ident as intern;\n-\n     let end = &sess.target.target.target_endian;\n     let arch = &sess.target.target.arch;\n     let wordsz = &sess.target.target.target_pointer_width;\n@@ -938,55 +936,46 @@ pub fn default_configuration(sess: &Session) -> ast::CrateConfig {\n     let max_atomic_width = sess.target.target.max_atomic_width();\n \n     let fam = if let Some(ref fam) = sess.target.target.options.target_family {\n-        intern(fam)\n+        Symbol::intern(fam)\n     } else if sess.target.target.options.is_like_windows {\n-        InternedString::new(\"windows\")\n+        Symbol::intern(\"windows\")\n     } else {\n-        InternedString::new(\"unix\")\n+        Symbol::intern(\"unix\")\n     };\n \n-    let mk = attr::mk_name_value_item_str;\n-    let mut ret = vec![ // Target bindings.\n-        mk(InternedString::new(\"target_os\"), intern(os)),\n-        mk(InternedString::new(\"target_family\"), fam.clone()),\n-        mk(InternedString::new(\"target_arch\"), intern(arch)),\n-        mk(InternedString::new(\"target_endian\"), intern(end)),\n-        mk(InternedString::new(\"target_pointer_width\"), intern(wordsz)),\n-        mk(InternedString::new(\"target_env\"), intern(env)),\n-        mk(InternedString::new(\"target_vendor\"), intern(vendor)),\n-    ];\n-    match &fam[..] {\n-        \"windows\" | \"unix\" => ret.push(attr::mk_word_item(fam)),\n-        _ => (),\n+    let mut ret = HashSet::new();\n+    // Target bindings.\n+    ret.insert((Symbol::intern(\"target_os\"), Some(Symbol::intern(os))));\n+    ret.insert((Symbol::intern(\"target_family\"), Some(fam)));\n+    ret.insert((Symbol::intern(\"target_arch\"), Some(Symbol::intern(arch))));\n+    ret.insert((Symbol::intern(\"target_endian\"), Some(Symbol::intern(end))));\n+    ret.insert((Symbol::intern(\"target_pointer_width\"), Some(Symbol::intern(wordsz))));\n+    ret.insert((Symbol::intern(\"target_env\"), Some(Symbol::intern(env))));\n+    ret.insert((Symbol::intern(\"target_vendor\"), Some(Symbol::intern(vendor))));\n+    if fam == \"windows\" || fam == \"unix\" {\n+        ret.insert((fam, None));\n     }\n     if sess.target.target.options.has_elf_tls {\n-        ret.push(attr::mk_word_item(InternedString::new(\"target_thread_local\")));\n+        ret.insert((Symbol::intern(\"target_thread_local\"), None));\n     }\n     for &i in &[8, 16, 32, 64, 128] {\n         if i <= max_atomic_width {\n             let s = i.to_string();\n-            ret.push(mk(InternedString::new(\"target_has_atomic\"), intern(&s)));\n+            ret.insert((Symbol::intern(\"target_has_atomic\"), Some(Symbol::intern(&s))));\n             if &s == wordsz {\n-                ret.push(mk(InternedString::new(\"target_has_atomic\"), intern(\"ptr\")));\n+                ret.insert((Symbol::intern(\"target_has_atomic\"), Some(Symbol::intern(\"ptr\"))));\n             }\n         }\n     }\n     if sess.opts.debug_assertions {\n-        ret.push(attr::mk_word_item(InternedString::new(\"debug_assertions\")));\n+        ret.insert((Symbol::intern(\"debug_assertions\"), None));\n     }\n     if sess.opts.crate_types.contains(&CrateTypeProcMacro) {\n-        ret.push(attr::mk_word_item(InternedString::new(\"proc_macro\")));\n+        ret.insert((Symbol::intern(\"proc_macro\"), None));\n     }\n     return ret;\n }\n \n-pub fn append_configuration(cfg: &mut ast::CrateConfig,\n-                            name: InternedString) {\n-    if !cfg.iter().any(|mi| mi.name() == name) {\n-        cfg.push(attr::mk_word_item(name))\n-    }\n-}\n-\n pub fn build_configuration(sess: &Session,\n                            mut user_cfg: ast::CrateConfig)\n                            -> ast::CrateConfig {\n@@ -995,11 +984,10 @@ pub fn build_configuration(sess: &Session,\n     let default_cfg = default_configuration(sess);\n     // If the user wants a test runner, then add the test cfg\n     if sess.opts.test {\n-        append_configuration(&mut user_cfg, InternedString::new(\"test\"))\n+        user_cfg.insert((Symbol::intern(\"test\"), None));\n     }\n-    let mut v = user_cfg.into_iter().collect::<Vec<_>>();\n-    v.extend_from_slice(&default_cfg[..]);\n-    v\n+    user_cfg.extend(default_cfg.iter().cloned());\n+    user_cfg\n }\n \n pub fn build_target_config(opts: &Options, sp: &Handler) -> Config {\n@@ -1245,11 +1233,14 @@ pub fn parse_cfgspecs(cfgspecs: Vec<String> ) -> ast::CrateConfig {\n         let meta_item = panictry!(parser.parse_meta_item());\n \n         if !parser.reader.is_eof() {\n-            early_error(ErrorOutputType::default(), &format!(\"invalid --cfg argument: {}\",\n-                                                             s))\n+            early_error(ErrorOutputType::default(), &format!(\"invalid --cfg argument: {}\", s))\n+        } else if meta_item.is_meta_item_list() {\n+            let msg =\n+                format!(\"invalid predicate in --cfg command line argument: `{}`\", meta_item.name());\n+            early_error(ErrorOutputType::default(), &msg)\n         }\n \n-        meta_item\n+        (meta_item.name(), meta_item.value_str())\n     }).collect::<ast::CrateConfig>()\n }\n \n@@ -1773,9 +1764,7 @@ mod tests {\n     use std::rc::Rc;\n     use super::{OutputType, OutputTypes, Externs};\n     use rustc_back::PanicStrategy;\n-    use syntax::{ast, attr};\n-    use syntax::parse::token::InternedString;\n-    use syntax::codemap::dummy_spanned;\n+    use syntax::symbol::Symbol;\n \n     fn optgroups() -> Vec<OptGroup> {\n         super::rustc_optgroups().into_iter()\n@@ -1804,9 +1793,7 @@ mod tests {\n         let (sessopts, cfg) = build_session_options_and_crate_config(matches);\n         let sess = build_session(sessopts, &dep_graph, None, registry, Rc::new(DummyCrateStore));\n         let cfg = build_configuration(&sess, cfg);\n-        assert!(attr::contains(&cfg, &dummy_spanned(ast::MetaItemKind::Word({\n-            InternedString::new(\"test\")\n-        }))));\n+        assert!(cfg.contains(&(Symbol::intern(\"test\"), None)));\n     }\n \n     // When the user supplies --test and --cfg test, don't implicitly add\n@@ -1827,7 +1814,7 @@ mod tests {\n         let sess = build_session(sessopts, &dep_graph, None, registry,\n                                  Rc::new(DummyCrateStore));\n         let cfg = build_configuration(&sess, cfg);\n-        let mut test_items = cfg.iter().filter(|m| m.name() == \"test\");\n+        let mut test_items = cfg.iter().filter(|&&(name, _)| name == \"test\");\n         assert!(test_items.next().is_some());\n         assert!(test_items.next().is_none());\n     }"}, {"sha": "9577a25b3f83099769a13165d522c3915c287a55", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=ebec55406ba94faf8b2cd23b27a8f74df97d1ca4", "patch": "@@ -28,7 +28,7 @@ use syntax::json::JsonEmitter;\n use syntax::feature_gate;\n use syntax::parse;\n use syntax::parse::ParseSess;\n-use syntax::parse::token;\n+use syntax::symbol::Symbol;\n use syntax::{ast, codemap};\n use syntax::feature_gate::AttributeType;\n use syntax_pos::{Span, MultiSpan};\n@@ -89,7 +89,7 @@ pub struct Session {\n     // forms a unique global identifier for the crate. It is used to allow\n     // multiple crates with the same name to coexist. See the\n     // trans::back::symbol_names module for more information.\n-    pub crate_disambiguator: RefCell<token::InternedString>,\n+    pub crate_disambiguator: RefCell<Symbol>,\n     pub features: RefCell<feature_gate::Features>,\n \n     /// The maximum recursion limit for potentially infinitely recursive\n@@ -129,8 +129,8 @@ pub struct PerfStats {\n }\n \n impl Session {\n-    pub fn local_crate_disambiguator(&self) -> token::InternedString {\n-        self.crate_disambiguator.borrow().clone()\n+    pub fn local_crate_disambiguator(&self) -> Symbol {\n+        *self.crate_disambiguator.borrow()\n     }\n     pub fn struct_span_warn<'a, S: Into<MultiSpan>>(&'a self,\n                                                     sp: S,\n@@ -610,7 +610,7 @@ pub fn build_session_(sopts: config::Options,\n         plugin_attributes: RefCell::new(Vec::new()),\n         crate_types: RefCell::new(Vec::new()),\n         dependency_formats: RefCell::new(FxHashMap()),\n-        crate_disambiguator: RefCell::new(token::intern(\"\").as_str()),\n+        crate_disambiguator: RefCell::new(Symbol::intern(\"\")),\n         features: RefCell::new(feature_gate::Features::new()),\n         recursion_limit: Cell::new(64),\n         next_node_id: Cell::new(NodeId::new(1)),"}, {"sha": "21009711cb18ae61a17cf486142d75a5d6b609f8", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=ebec55406ba94faf8b2cd23b27a8f74df97d1ca4", "patch": "@@ -246,12 +246,13 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 let err_sp = item.meta().span.substitute_dummy(span);\n                 let def = self.tcx.lookup_trait_def(trait_ref.def_id);\n                 let trait_str = def.trait_ref.to_string();\n-                if let Some(ref istring) = item.value_str() {\n+                if let Some(istring) = item.value_str() {\n+                    let istring = &*istring.as_str();\n                     let generic_map = def.generics.types.iter().map(|param| {\n                         (param.name.as_str().to_string(),\n                          trait_ref.substs.type_for_def(param).to_string())\n                     }).collect::<FxHashMap<String, String>>();\n-                    let parser = Parser::new(&istring);\n+                    let parser = Parser::new(istring);\n                     let mut errored = false;\n                     let err: String = parser.filter_map(|p| {\n                         match p {"}, {"sha": "76bead99343a7f01daa0b586ce348c2fcdcd7483", "filename": "src/librustc/traits/project.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibrustc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibrustc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fproject.rs?ref=ebec55406ba94faf8b2cd23b27a8f74df97d1ca4", "patch": "@@ -26,8 +26,8 @@ use super::util;\n use hir::def_id::DefId;\n use infer::InferOk;\n use rustc_data_structures::snapshot_map::{Snapshot, SnapshotMap};\n-use syntax::parse::token;\n use syntax::ast;\n+use syntax::symbol::Symbol;\n use ty::subst::Subst;\n use ty::{self, ToPredicate, ToPolyTraitRef, Ty, TyCtxt};\n use ty::fold::{TypeFoldable, TypeFolder};\n@@ -1245,7 +1245,7 @@ fn confirm_callable_candidate<'cx, 'gcx, 'tcx>(\n     let predicate = ty::Binder(ty::ProjectionPredicate { // (1) recreate binder here\n         projection_ty: ty::ProjectionTy {\n             trait_ref: trait_ref,\n-            item_name: token::intern(FN_OUTPUT_NAME),\n+            item_name: Symbol::intern(FN_OUTPUT_NAME),\n         },\n         ty: ret_type\n     });"}, {"sha": "20855c46b68002453844f0b2169ba979b4d242cf", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=ebec55406ba94faf8b2cd23b27a8f74df97d1ca4", "patch": "@@ -49,7 +49,7 @@ use std::rc::Rc;\n use std::iter;\n use syntax::ast::{self, Name, NodeId};\n use syntax::attr;\n-use syntax::parse::token::{self, keywords};\n+use syntax::symbol::{Symbol, keywords};\n \n use hir;\n \n@@ -561,7 +561,7 @@ pub struct GlobalCtxt<'tcx> {\n \n     /// The definite name of the current crate after taking into account\n     /// attributes, commandline parameters, etc.\n-    pub crate_name: token::InternedString,\n+    pub crate_name: Symbol,\n \n     /// Data layout specification for the current target.\n     pub data_layout: TargetDataLayout,\n@@ -574,7 +574,7 @@ pub struct GlobalCtxt<'tcx> {\n \n     /// Map from function to the `#[derive]` mode that it's defining. Only used\n     /// by `proc-macro` crates.\n-    pub derive_macros: RefCell<NodeMap<token::InternedString>>,\n+    pub derive_macros: RefCell<NodeMap<Symbol>>,\n }\n \n impl<'tcx> GlobalCtxt<'tcx> {\n@@ -588,23 +588,23 @@ impl<'tcx> GlobalCtxt<'tcx> {\n }\n \n impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n-    pub fn crate_name(self, cnum: CrateNum) -> token::InternedString {\n+    pub fn crate_name(self, cnum: CrateNum) -> Symbol {\n         if cnum == LOCAL_CRATE {\n-            self.crate_name.clone()\n+            self.crate_name\n         } else {\n             self.sess.cstore.crate_name(cnum)\n         }\n     }\n \n-    pub fn original_crate_name(self, cnum: CrateNum) -> token::InternedString {\n+    pub fn original_crate_name(self, cnum: CrateNum) -> Symbol {\n         if cnum == LOCAL_CRATE {\n             self.crate_name.clone()\n         } else {\n             self.sess.cstore.original_crate_name(cnum)\n         }\n     }\n \n-    pub fn crate_disambiguator(self, cnum: CrateNum) -> token::InternedString {\n+    pub fn crate_disambiguator(self, cnum: CrateNum) -> Symbol {\n         if cnum == LOCAL_CRATE {\n             self.sess.local_crate_disambiguator()\n         } else {\n@@ -835,7 +835,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             custom_coerce_unsized_kinds: RefCell::new(DefIdMap()),\n             cast_kinds: RefCell::new(NodeMap()),\n             fragment_infos: RefCell::new(DefIdMap()),\n-            crate_name: token::intern_and_get_ident(crate_name),\n+            crate_name: Symbol::intern(crate_name),\n             data_layout: data_layout,\n             layout_cache: RefCell::new(FxHashMap()),\n             layout_depth: Cell::new(0),"}, {"sha": "b93a8698f603c1196a130ca4e1041b55ea1c7afd", "filename": "src/librustc/ty/item_path.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibrustc%2Fty%2Fitem_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibrustc%2Fty%2Fitem_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fitem_path.rs?ref=ebec55406ba94faf8b2cd23b27a8f74df97d1ca4", "patch": "@@ -12,7 +12,7 @@ use hir::map::DefPathData;\n use hir::def_id::{CrateNum, DefId, CRATE_DEF_INDEX, LOCAL_CRATE};\n use ty::{self, Ty, TyCtxt};\n use syntax::ast;\n-use syntax::parse::token;\n+use syntax::symbol::Symbol;\n \n use std::cell::Cell;\n \n@@ -94,14 +94,14 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                     if let Some(extern_crate_def_id) = opt_extern_crate {\n                         self.push_item_path(buffer, extern_crate_def_id);\n                     } else {\n-                        buffer.push(&self.crate_name(cnum));\n+                        buffer.push(&self.crate_name(cnum).as_str());\n                     }\n                 }\n             }\n             RootMode::Absolute => {\n                 // In absolute mode, just write the crate name\n                 // unconditionally.\n-                buffer.push(&self.original_crate_name(cnum));\n+                buffer.push(&self.original_crate_name(cnum).as_str());\n             }\n         }\n     }\n@@ -126,7 +126,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                         return true;\n                     }\n                     None => {\n-                        buffer.push(&self.crate_name(cur_def.krate));\n+                        buffer.push(&self.crate_name(cur_def.krate).as_str());\n                         cur_path.iter().rev().map(|segment| buffer.push(&segment.as_str())).count();\n                         return true;\n                     }\n@@ -136,7 +136,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n \n             cur_path.push(self.sess.cstore.def_key(cur_def)\n                               .disambiguated_data.data.get_opt_name().unwrap_or_else(||\n-                token::intern(\"<unnamed>\")));\n+                Symbol::intern(\"<unnamed>\")));\n             match visible_parent_map.get(&cur_def) {\n                 Some(&def) => cur_def = def,\n                 None => return false,"}, {"sha": "e94e93158c47a2de9d3f2b8e464fdb10a1c78e82", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=ebec55406ba94faf8b2cd23b27a8f74df97d1ca4", "patch": "@@ -44,7 +44,7 @@ use std::vec::IntoIter;\n use std::mem;\n use syntax::ast::{self, Name, NodeId};\n use syntax::attr;\n-use syntax::parse::token::{self, InternedString};\n+use syntax::symbol::{Symbol, InternedString};\n use syntax_pos::{DUMMY_SP, Span};\n \n use rustc_const_math::ConstInt;\n@@ -2344,7 +2344,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         if let Some(id) = self.map.as_local_node_id(id) {\n             self.map.name(id)\n         } else if id.index == CRATE_DEF_INDEX {\n-            token::intern(&self.sess.cstore.original_crate_name(id.krate))\n+            self.sess.cstore.original_crate_name(id.krate)\n         } else {\n             let def_key = self.sess.cstore.def_key(id);\n             // The name of a StructCtor is that of its struct parent.\n@@ -2747,7 +2747,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n \n     /// Looks up the span of `impl_did` if the impl is local; otherwise returns `Err`\n     /// with the name of the crate containing the impl.\n-    pub fn span_of_impl(self, impl_did: DefId) -> Result<Span, InternedString> {\n+    pub fn span_of_impl(self, impl_did: DefId) -> Result<Span, Symbol> {\n         if impl_did.is_local() {\n             let node_id = self.map.as_local_node_id(impl_did).unwrap();\n             Ok(self.map.span(node_id))"}, {"sha": "81896ecfb53411446b42aa2bc17e7b5ab70f4f76", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=ebec55406ba94faf8b2cd23b27a8f74df97d1ca4", "patch": "@@ -23,7 +23,7 @@ use std::fmt;\n use std::ops;\n use syntax::abi;\n use syntax::ast::{self, Name};\n-use syntax::parse::token::{keywords, InternedString};\n+use syntax::symbol::{keywords, InternedString};\n \n use serialize;\n "}, {"sha": "d04825d560444facbc47d19960a4fb9b0b26f306", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=ebec55406ba94faf8b2cd23b27a8f74df97d1ca4", "patch": "@@ -25,8 +25,8 @@ use std::fmt;\n use std::usize;\n \n use syntax::abi::Abi;\n-use syntax::parse::token;\n use syntax::ast::CRATE_NODE_ID;\n+use syntax::symbol::Symbol;\n use hir;\n \n pub fn verbose() -> bool {\n@@ -284,7 +284,7 @@ fn in_binder<'a, 'gcx, 'tcx, T, U>(f: &mut fmt::Formatter,\n             ty::BrAnon(_) |\n             ty::BrFresh(_) |\n             ty::BrEnv => {\n-                let name = token::intern(\"'r\");\n+                let name = Symbol::intern(\"'r\");\n                 let _ = write!(f, \"{}\", name);\n                 ty::BrNamed(tcx.map.local_def_id(CRATE_NODE_ID),\n                             name,"}, {"sha": "916d17dcc91deff5b598dd9d7f5f7dab7a3c915b", "filename": "src/librustc_borrowck/borrowck/mir/dataflow/sanity_check.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fsanity_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fsanity_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fsanity_check.rs?ref=ebec55406ba94faf8b2cd23b27a8f74df97d1ca4", "patch": "@@ -169,7 +169,7 @@ fn is_rustc_peek<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                 {\n                     let name = tcx.item_name(def_id);\n                     if abi == Abi::RustIntrinsic || abi == Abi::PlatformIntrinsic {\n-                        if name.as_str() == \"rustc_peek\" {\n+                        if name == \"rustc_peek\" {\n                             return Some((args, source_info.span));\n                         }\n                     }"}, {"sha": "9035c2ab3c236e05cf85fb26813a69dab174bbee", "filename": "src/librustc_borrowck/borrowck/mir/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fmod.rs?ref=ebec55406ba94faf8b2cd23b27a8f74df97d1ca4", "patch": "@@ -11,7 +11,6 @@\n use borrowck::BorrowckCtxt;\n \n use syntax::ast::{self, MetaItem};\n-use syntax::ptr::P;\n use syntax_pos::{Span, DUMMY_SP};\n \n use rustc::hir;\n@@ -35,7 +34,7 @@ use self::dataflow::{MaybeInitializedLvals, MaybeUninitializedLvals};\n use self::dataflow::{DefinitelyInitializedLvals};\n use self::gather_moves::{MoveData, MovePathIndex, LookupResult};\n \n-fn has_rustc_mir_with(attrs: &[ast::Attribute], name: &str) -> Option<P<MetaItem>> {\n+fn has_rustc_mir_with(attrs: &[ast::Attribute], name: &str) -> Option<MetaItem> {\n     for attr in attrs {\n         if attr.check_name(\"rustc_mir\") {\n             let items = attr.meta_item_list();"}, {"sha": "c265fa97e2957d2b094ad7f7d8e9c59d8b7d0acf", "filename": "src/librustc_const_eval/eval.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibrustc_const_eval%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibrustc_const_eval%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Feval.rs?ref=ebec55406ba94faf8b2cd23b27a8f74df97d1ca4", "patch": "@@ -1221,7 +1221,7 @@ fn lit_to_const<'a, 'tcx>(lit: &ast::LitKind,\n     use syntax::ast::*;\n     use syntax::ast::LitIntType::*;\n     match *lit {\n-        LitKind::Str(ref s, _) => Ok(Str((*s).clone())),\n+        LitKind::Str(ref s, _) => Ok(Str(s.as_str())),\n         LitKind::ByteStr(ref data) => Ok(ByteStr(data.clone())),\n         LitKind::Byte(n) => Ok(Integral(U8(n))),\n         LitKind::Int(n, Signed(ity)) => {\n@@ -1249,15 +1249,15 @@ fn lit_to_const<'a, 'tcx>(lit: &ast::LitKind,\n             infer(Infer(n), tcx, &ty::TyUint(ity)).map(Integral)\n         },\n \n-        LitKind::Float(ref n, fty) => {\n-            parse_float(n, Some(fty)).map(Float)\n+        LitKind::Float(n, fty) => {\n+            parse_float(&n.as_str(), Some(fty)).map(Float)\n         }\n-        LitKind::FloatUnsuffixed(ref n) => {\n+        LitKind::FloatUnsuffixed(n) => {\n             let fty_hint = match ty_hint.map(|t| &t.sty) {\n                 Some(&ty::TyFloat(fty)) => Some(fty),\n                 _ => None\n             };\n-            parse_float(n, fty_hint).map(Float)\n+            parse_float(&n.as_str(), fty_hint).map(Float)\n         }\n         LitKind::Bool(b) => Ok(Bool(b)),\n         LitKind::Char(c) => Ok(Char(c)),"}, {"sha": "228119e6cc7da46206696a7bf6452a38361182cc", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 4, "deletions": 15, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=ebec55406ba94faf8b2cd23b27a8f74df97d1ca4", "patch": "@@ -53,7 +53,8 @@ use std::path::{Path, PathBuf};\n use syntax::{ast, diagnostics, visit};\n use syntax::attr;\n use syntax::ext::base::ExtCtxt;\n-use syntax::parse::{self, PResult, token};\n+use syntax::parse::{self, PResult};\n+use syntax::symbol::Symbol;\n use syntax::util::node_count::NodeCounter;\n use syntax;\n use syntax_ext;\n@@ -210,9 +211,6 @@ pub fn compile_input(sess: &Session,\n                 tcx.print_debug_stats();\n             }\n \n-            // Discard interned strings as they are no longer required.\n-            token::clear_ident_interner();\n-\n             Ok((outputs, trans))\n         })??\n     };\n@@ -563,8 +561,7 @@ pub fn phase_2_configure_and_expand<'a, F>(sess: &Session,\n     *sess.features.borrow_mut() = features;\n \n     *sess.crate_types.borrow_mut() = collect_crate_types(sess, &krate.attrs);\n-    *sess.crate_disambiguator.borrow_mut() =\n-        token::intern(&compute_crate_disambiguator(sess)).as_str();\n+    *sess.crate_disambiguator.borrow_mut() = Symbol::intern(&compute_crate_disambiguator(sess));\n \n     time(time_passes, \"recursion limit\", || {\n         middle::recursion_limit::update_recursion_limit(sess, &krate);\n@@ -1107,7 +1104,7 @@ pub fn phase_6_link_output(sess: &Session,\n                            outputs: &OutputFilenames) {\n     time(sess.time_passes(),\n          \"linking\",\n-         || link::link_binary(sess, trans, outputs, &trans.link.crate_name));\n+         || link::link_binary(sess, trans, outputs, &trans.link.crate_name.as_str()));\n }\n \n fn escape_dep_filename(filename: &str) -> String {\n@@ -1358,11 +1355,3 @@ pub fn build_output_filenames(input: &Input,\n         }\n     }\n }\n-\n-// For use by the `rusti` project (https://github.com/murarth/rusti).\n-pub fn reset_thread_local_state() {\n-    // These may be left in an incoherent state after a previous compile.\n-    syntax::ext::hygiene::reset_hygiene_data();\n-    // `clear_ident_interner` can be used to free memory, but it does not restore the initial state.\n-    token::reset_ident_interner();\n-}"}, {"sha": "a0863e0d29422b7dbbf214e0f3372f3f8f1053d9", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 20, "deletions": 45, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=ebec55406ba94faf8b2cd23b27a8f74df97d1ca4", "patch": "@@ -95,12 +95,11 @@ use std::str;\n use std::sync::{Arc, Mutex};\n use std::thread;\n \n-use syntax::{ast, json};\n+use syntax::ast;\n use syntax::codemap::{CodeMap, FileLoader, RealFileLoader};\n use syntax::feature_gate::{GatedCfg, UnstableFeatures};\n use syntax::parse::{self, PResult};\n-use syntax_pos::MultiSpan;\n-use errors::emitter::Emitter;\n+use syntax_pos::{DUMMY_SP, MultiSpan};\n \n #[cfg(test)]\n pub mod test;\n@@ -374,37 +373,11 @@ fn handle_explain(code: &str,\n     }\n }\n \n-fn check_cfg(cfg: &ast::CrateConfig,\n-             output: ErrorOutputType) {\n-    let emitter: Box<Emitter> = match output {\n-        config::ErrorOutputType::HumanReadable(color_config) => {\n-            Box::new(errors::emitter::EmitterWriter::stderr(color_config, None))\n-        }\n-        config::ErrorOutputType::Json => Box::new(json::JsonEmitter::basic()),\n-    };\n-    let handler = errors::Handler::with_emitter(true, false, emitter);\n-\n-    let mut saw_invalid_predicate = false;\n-    for item in cfg.iter() {\n-        if item.is_meta_item_list() {\n-            saw_invalid_predicate = true;\n-            handler.emit(&MultiSpan::new(),\n-                         &format!(\"invalid predicate in --cfg command line argument: `{}`\",\n-                                  item.name()),\n-                            errors::Level::Fatal);\n-        }\n-    }\n-\n-    if saw_invalid_predicate {\n-        panic!(errors::FatalError);\n-    }\n-}\n-\n impl<'a> CompilerCalls<'a> for RustcDefaultCalls {\n     fn early_callback(&mut self,\n                       matches: &getopts::Matches,\n                       _: &config::Options,\n-                      cfg: &ast::CrateConfig,\n+                      _: &ast::CrateConfig,\n                       descriptions: &errors::registry::Registry,\n                       output: ErrorOutputType)\n                       -> Compilation {\n@@ -413,7 +386,6 @@ impl<'a> CompilerCalls<'a> for RustcDefaultCalls {\n             return Compilation::Stop;\n         }\n \n-        check_cfg(cfg, output);\n         Compilation::Continue\n     }\n \n@@ -640,24 +612,27 @@ impl RustcDefaultCalls {\n                     let allow_unstable_cfg = UnstableFeatures::from_environment()\n                         .is_nightly_build();\n \n-                    for cfg in &sess.parse_sess.config {\n-                        if !allow_unstable_cfg && GatedCfg::gate(cfg).is_some() {\n+                    let mut cfgs = Vec::new();\n+                    for &(name, ref value) in sess.parse_sess.config.iter() {\n+                        let gated_cfg = GatedCfg::gate(&ast::MetaItem {\n+                            name: name,\n+                            node: ast::MetaItemKind::Word,\n+                            span: DUMMY_SP,\n+                        });\n+                        if !allow_unstable_cfg && gated_cfg.is_some() {\n                             continue;\n                         }\n \n-                        if cfg.is_word() {\n-                            println!(\"{}\", cfg.name());\n-                        } else if let Some(s) = cfg.value_str() {\n-                            println!(\"{}=\\\"{}\\\"\", cfg.name(), s);\n-                        } else if cfg.is_meta_item_list() {\n-                            // Right now there are not and should not be any\n-                            // MetaItemKind::List items in the configuration returned by\n-                            // `build_configuration`.\n-                            panic!(\"Found an unexpected list in cfg attribute '{}'!\", cfg.name())\n+                        cfgs.push(if let &Some(ref value) = value {\n+                            format!(\"{}=\\\"{}\\\"\", name, value)\n                         } else {\n-                            // There also shouldn't be literals.\n-                            panic!(\"Found an unexpected literal in cfg attribute '{}'!\", cfg.name())\n-                        }\n+                            format!(\"{}\", name)\n+                        });\n+                    }\n+\n+                    cfgs.sort();\n+                    for cfg in cfgs {\n+                        println!(\"{}\", cfg);\n                     }\n                 }\n                 PrintRequest::TargetCPUs => {"}, {"sha": "6c99c9d71b81585da2090b0be656b88873703bf5", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=ebec55406ba94faf8b2cd23b27a8f74df97d1ca4", "patch": "@@ -450,15 +450,15 @@ impl<'ast> PrinterSupport<'ast> for HygieneAnnotation<'ast> {\n impl<'ast> pprust::PpAnn for HygieneAnnotation<'ast> {\n     fn post(&self, s: &mut pprust::State, node: pprust::AnnNode) -> io::Result<()> {\n         match node {\n-            pprust::NodeIdent(&ast::Ident { name: ast::Name(nm), ctxt }) => {\n+            pprust::NodeIdent(&ast::Ident { name, ctxt }) => {\n                 pp::space(&mut s.s)?;\n                 // FIXME #16420: this doesn't display the connections\n                 // between syntax contexts\n-                s.synth_comment(format!(\"{}{:?}\", nm, ctxt))\n+                s.synth_comment(format!(\"{}{:?}\", name.as_u32(), ctxt))\n             }\n-            pprust::NodeName(&ast::Name(nm)) => {\n+            pprust::NodeName(&name) => {\n                 pp::space(&mut s.s)?;\n-                s.synth_comment(nm.to_string())\n+                s.synth_comment(name.as_u32().to_string())\n             }\n             _ => Ok(()),\n         }"}, {"sha": "876323d599e857bc3f30f867b3c07b36a84daab3", "filename": "src/librustc_driver/target_features.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibrustc_driver%2Ftarget_features.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibrustc_driver%2Ftarget_features.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftarget_features.rs?ref=ebec55406ba94faf8b2cd23b27a8f74df97d1ca4", "patch": "@@ -8,13 +8,12 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use syntax::{ast, attr};\n+use syntax::ast;\n use llvm::LLVMRustHasFeature;\n use rustc::session::Session;\n use rustc_trans::back::write::create_target_machine;\n use syntax::feature_gate::UnstableFeatures;\n-use syntax::parse::token::InternedString;\n-use syntax::parse::token::intern_and_get_ident as intern;\n+use syntax::symbol::Symbol;\n use libc::c_char;\n \n // WARNING: the features must be known to LLVM or the feature\n@@ -41,11 +40,11 @@ pub fn add_configuration(cfg: &mut ast::CrateConfig, sess: &Session) {\n         _ => &[],\n     };\n \n-    let tf = InternedString::new(\"target_feature\");\n+    let tf = Symbol::intern(\"target_feature\");\n     for feat in whitelist {\n         assert_eq!(feat.chars().last(), Some('\\0'));\n         if unsafe { LLVMRustHasFeature(target_machine, feat.as_ptr() as *const c_char) } {\n-            cfg.push(attr::mk_name_value_item_str(tf.clone(), intern(&feat[..feat.len() - 1])))\n+            cfg.insert((tf, Some(Symbol::intern(&feat[..feat.len() - 1]))));\n         }\n     }\n \n@@ -74,6 +73,6 @@ pub fn add_configuration(cfg: &mut ast::CrateConfig, sess: &Session) {\n     }\n \n     if crt_static {\n-        cfg.push(attr::mk_name_value_item_str(tf.clone(), intern(\"crt-static\")));\n+        cfg.insert((tf, Some(Symbol::intern(\"crt-static\"))));\n     }\n }"}, {"sha": "a4f0e2903847765b197d0685564fda2bc83b9919", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=ebec55406ba94faf8b2cd23b27a8f74df97d1ca4", "patch": "@@ -34,8 +34,8 @@ use syntax::codemap::CodeMap;\n use errors;\n use errors::emitter::Emitter;\n use errors::{Level, DiagnosticBuilder};\n-use syntax::parse::token;\n use syntax::feature_gate::UnstableFeatures;\n+use syntax::symbol::Symbol;\n \n use rustc::hir;\n \n@@ -288,11 +288,11 @@ impl<'a, 'gcx, 'tcx> Env<'a, 'gcx, 'tcx> {\n \n     pub fn t_param(&self, index: u32) -> Ty<'tcx> {\n         let name = format!(\"T{}\", index);\n-        self.infcx.tcx.mk_param(index, token::intern(&name[..]))\n+        self.infcx.tcx.mk_param(index, Symbol::intern(&name[..]))\n     }\n \n     pub fn re_early_bound(&self, index: u32, name: &'static str) -> &'tcx ty::Region {\n-        let name = token::intern(name);\n+        let name = Symbol::intern(name);\n         self.infcx.tcx.mk_region(ty::ReEarlyBound(ty::EarlyBoundRegion {\n             index: index,\n             name: name,"}, {"sha": "87e6b2befdc3281fcbbb9359c11bf499d4eaccfd", "filename": "src/librustc_incremental/assert_dep_graph.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibrustc_incremental%2Fassert_dep_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibrustc_incremental%2Fassert_dep_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fassert_dep_graph.rs?ref=ebec55406ba94faf8b2cd23b27a8f74df97d1ca4", "patch": "@@ -57,7 +57,6 @@ use std::env;\n use std::fs::File;\n use std::io::Write;\n use syntax::ast;\n-use syntax::parse::token::InternedString;\n use syntax_pos::Span;\n use {ATTR_IF_THIS_CHANGED, ATTR_THEN_THIS_WOULD_NEED};\n \n@@ -97,7 +96,7 @@ pub fn assert_dep_graph<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n }\n \n type Sources = Vec<(Span, DefId, DepNode<DefId>)>;\n-type Targets = Vec<(Span, InternedString, ast::NodeId, DepNode<DefId>)>;\n+type Targets = Vec<(Span, ast::Name, ast::NodeId, DepNode<DefId>)>;\n \n struct IfThisChanged<'a, 'tcx:'a> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n@@ -106,7 +105,7 @@ struct IfThisChanged<'a, 'tcx:'a> {\n }\n \n impl<'a, 'tcx> IfThisChanged<'a, 'tcx> {\n-    fn argument(&self, attr: &ast::Attribute) -> Option<InternedString> {\n+    fn argument(&self, attr: &ast::Attribute) -> Option<ast::Name> {\n         let mut value = None;\n         for list_item in attr.meta_item_list().unwrap_or_default() {\n             match list_item.word() {\n@@ -127,8 +126,8 @@ impl<'a, 'tcx> IfThisChanged<'a, 'tcx> {\n                 let dep_node_interned = self.argument(attr);\n                 let dep_node = match dep_node_interned {\n                     None => DepNode::Hir(def_id),\n-                    Some(ref n) => {\n-                        match DepNode::from_label_string(&n[..], def_id) {\n+                    Some(n) => {\n+                        match DepNode::from_label_string(&n.as_str(), def_id) {\n                             Ok(n) => n,\n                             Err(()) => {\n                                 self.tcx.sess.span_fatal(\n@@ -142,8 +141,8 @@ impl<'a, 'tcx> IfThisChanged<'a, 'tcx> {\n             } else if attr.check_name(ATTR_THEN_THIS_WOULD_NEED) {\n                 let dep_node_interned = self.argument(attr);\n                 let dep_node = match dep_node_interned {\n-                    Some(ref n) => {\n-                        match DepNode::from_label_string(&n[..], def_id) {\n+                    Some(n) => {\n+                        match DepNode::from_label_string(&n.as_str(), def_id) {\n                             Ok(n) => n,\n                             Err(()) => {\n                                 self.tcx.sess.span_fatal(\n@@ -159,7 +158,7 @@ impl<'a, 'tcx> IfThisChanged<'a, 'tcx> {\n                     }\n                 };\n                 self.then_this_would_need.push((attr.span,\n-                                                dep_node_interned.clone().unwrap(),\n+                                                dep_node_interned.unwrap(),\n                                                 node_id,\n                                                 dep_node));\n             }"}, {"sha": "250ef061e5109305f9ff50ed1dde0db074685a43", "filename": "src/librustc_incremental/calculate_svh/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibrustc_incremental%2Fcalculate_svh%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibrustc_incremental%2Fcalculate_svh%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fcalculate_svh%2Fmod.rs?ref=ebec55406ba94faf8b2cd23b27a8f74df97d1ca4", "patch": "@@ -172,8 +172,8 @@ impl<'a, 'tcx> HashItemsVisitor<'a, 'tcx> {\n \n         let crate_disambiguator = self.tcx.sess.local_crate_disambiguator();\n         \"crate_disambiguator\".hash(&mut crate_state);\n-        crate_disambiguator.len().hash(&mut crate_state);\n-        crate_disambiguator.hash(&mut crate_state);\n+        crate_disambiguator.as_str().len().hash(&mut crate_state);\n+        crate_disambiguator.as_str().hash(&mut crate_state);\n \n         // add each item (in some deterministic order) to the overall\n         // crate hash."}, {"sha": "4bad264ac8749d7c0b71ef12564d51d75c3cc52f", "filename": "src/librustc_incremental/calculate_svh/svh_visitor.rs", "status": "modified", "additions": 30, "deletions": 24, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibrustc_incremental%2Fcalculate_svh%2Fsvh_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibrustc_incremental%2Fcalculate_svh%2Fsvh_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fcalculate_svh%2Fsvh_visitor.rs?ref=ebec55406ba94faf8b2cd23b27a8f74df97d1ca4", "patch": "@@ -18,6 +18,7 @@ use syntax::abi::Abi;\n use syntax::ast::{self, Name, NodeId};\n use syntax::attr;\n use syntax::parse::token;\n+use syntax::symbol::{Symbol, InternedString};\n use syntax_pos::{Span, NO_EXPANSION, COMMAND_LINE_EXPN, BytePos};\n use syntax::tokenstream;\n use rustc::hir;\n@@ -169,8 +170,8 @@ enum SawAbiComponent<'a> {\n \n     // FIXME (#14132): should we include (some function of)\n     // ident.ctxt as well?\n-    SawIdent(token::InternedString),\n-    SawStructDef(token::InternedString),\n+    SawIdent(InternedString),\n+    SawStructDef(InternedString),\n \n     SawLifetime,\n     SawLifetimeDef(usize),\n@@ -232,11 +233,11 @@ enum SawAbiComponent<'a> {\n #[derive(Hash)]\n enum SawExprComponent<'a> {\n \n-    SawExprLoop(Option<token::InternedString>),\n-    SawExprField(token::InternedString),\n+    SawExprLoop(Option<InternedString>),\n+    SawExprField(InternedString),\n     SawExprTupField(usize),\n-    SawExprBreak(Option<token::InternedString>),\n-    SawExprAgain(Option<token::InternedString>),\n+    SawExprBreak(Option<InternedString>),\n+    SawExprAgain(Option<InternedString>),\n \n     SawExprBox,\n     SawExprArray,\n@@ -246,6 +247,8 @@ enum SawExprComponent<'a> {\n     SawExprBinary(hir::BinOp_),\n     SawExprUnary(hir::UnOp),\n     SawExprLit(ast::LitKind),\n+    SawExprLitStr(InternedString, ast::StrStyle),\n+    SawExprLitFloat(InternedString, Option<ast::FloatTy>),\n     SawExprCast,\n     SawExprType,\n     SawExprIf,\n@@ -314,7 +317,7 @@ fn saw_expr<'a>(node: &'a Expr_,\n         ExprUnary(op, _)         => {\n             (SawExprUnary(op), unop_can_panic_at_runtime(op))\n         }\n-        ExprLit(ref lit)         => (SawExprLit(lit.node.clone()), false),\n+        ExprLit(ref lit)         => (saw_lit(lit), false),\n         ExprCast(..)             => (SawExprCast, false),\n         ExprType(..)             => (SawExprType, false),\n         ExprIf(..)               => (SawExprIf, false),\n@@ -341,6 +344,15 @@ fn saw_expr<'a>(node: &'a Expr_,\n     }\n }\n \n+fn saw_lit(lit: &ast::Lit) -> SawExprComponent<'static> {\n+    match lit.node {\n+        ast::LitKind::Str(s, style) => SawExprLitStr(s.as_str(), style),\n+        ast::LitKind::Float(s, ty) => SawExprLitFloat(s.as_str(), Some(ty)),\n+        ast::LitKind::FloatUnsuffixed(s) => SawExprLitFloat(s.as_str(), None),\n+        ref node @ _ => SawExprLit(node.clone()),\n+    }\n+}\n+\n #[derive(Hash)]\n enum SawItemComponent {\n     SawItemExternCrate,\n@@ -874,22 +886,16 @@ impl<'a, 'hash, 'tcx> StrictVersionHashVisitor<'a, 'hash, 'tcx> {\n \n         // ignoring span information, it doesn't matter here\n         self.hash_discriminant(&meta_item.node);\n+        meta_item.name.as_str().len().hash(self.st);\n+        meta_item.name.as_str().hash(self.st);\n+\n         match meta_item.node {\n-            ast::MetaItemKind::Word(ref s) => {\n-                s.len().hash(self.st);\n-                s.hash(self.st);\n-            }\n-            ast::MetaItemKind::NameValue(ref s, ref lit) => {\n-                s.len().hash(self.st);\n-                s.hash(self.st);\n-                lit.node.hash(self.st);\n-            }\n-            ast::MetaItemKind::List(ref s, ref items) => {\n-                s.len().hash(self.st);\n-                s.hash(self.st);\n+            ast::MetaItemKind::Word => {}\n+            ast::MetaItemKind::NameValue(ref lit) => saw_lit(lit).hash(self.st),\n+            ast::MetaItemKind::List(ref items) => {\n                 // Sort subitems so the hash does not depend on their order\n                 let indices = self.indices_sorted_by(&items, |p| {\n-                    (p.name(), fnv::hash(&p.literal().map(|i| &i.node)))\n+                    (p.name().map(Symbol::as_str), fnv::hash(&p.literal().map(saw_lit)))\n                 });\n                 items.len().hash(self.st);\n                 for (index, &item_index) in indices.iter().enumerate() {\n@@ -901,7 +907,7 @@ impl<'a, 'hash, 'tcx> StrictVersionHashVisitor<'a, 'hash, 'tcx> {\n                             self.hash_meta_item(meta_item);\n                         }\n                         ast::NestedMetaItemKind::Literal(ref lit) => {\n-                            lit.node.hash(self.st);\n+                            saw_lit(lit).hash(self.st);\n                         }\n                     }\n                 }\n@@ -914,11 +920,11 @@ impl<'a, 'hash, 'tcx> StrictVersionHashVisitor<'a, 'hash, 'tcx> {\n         let indices = self.indices_sorted_by(attributes, |attr| attr.name());\n \n         for i in indices {\n-            let attr = &attributes[i].node;\n+            let attr = &attributes[i];\n             if !attr.is_sugared_doc &&\n-               !IGNORED_ATTRIBUTES.contains(&&*attr.value.name()) {\n+               !IGNORED_ATTRIBUTES.contains(&&*attr.value.name().as_str()) {\n                 SawAttribute(attr.style).hash(self.st);\n-                self.hash_meta_item(&*attr.value);\n+                self.hash_meta_item(&attr.value);\n             }\n         }\n     }"}, {"sha": "546feb212243aca2c3d629ae8a7e89345356481d", "filename": "src/librustc_incremental/persist/directory.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibrustc_incremental%2Fpersist%2Fdirectory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibrustc_incremental%2Fpersist%2Fdirectory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fdirectory.rs?ref=ebec55406ba94faf8b2cd23b27a8f74df97d1ca4", "patch": "@@ -84,8 +84,8 @@ impl DefIdDirectory {\n             assert_eq!(old_info.krate, krate);\n             let old_name: &str = &old_info.name;\n             let old_disambiguator: &str = &old_info.disambiguator;\n-            let new_name: &str = &tcx.crate_name(krate);\n-            let new_disambiguator: &str = &tcx.crate_disambiguator(krate);\n+            let new_name: &str = &tcx.crate_name(krate).as_str();\n+            let new_disambiguator: &str = &tcx.crate_disambiguator(krate).as_str();\n             old_name == new_name && old_disambiguator == new_disambiguator\n         }\n     }\n@@ -99,8 +99,8 @@ impl DefIdDirectory {\n         let new_krates: HashMap<_, _> =\n             once(LOCAL_CRATE)\n             .chain(tcx.sess.cstore.crates())\n-            .map(|krate| (make_key(&tcx.crate_name(krate),\n-                                   &tcx.crate_disambiguator(krate)), krate))\n+            .map(|krate| (make_key(&tcx.crate_name(krate).as_str(),\n+                                   &tcx.crate_disambiguator(krate).as_str()), krate))\n             .collect();\n \n         let ids = self.paths.iter()"}, {"sha": "85c35bf79ce81347a4273e82b83200d94fc301b9", "filename": "src/librustc_incremental/persist/dirty_clean.rs", "status": "modified", "additions": 3, "deletions": 11, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs?ref=ebec55406ba94faf8b2cd23b27a8f74df97d1ca4", "patch": "@@ -48,7 +48,6 @@ use rustc::hir::def_id::DefId;\n use rustc::hir::itemlikevisit::ItemLikeVisitor;\n use syntax::ast::{self, Attribute, NestedMetaItem};\n use rustc_data_structures::fx::{FxHashSet, FxHashMap};\n-use syntax::parse::token::InternedString;\n use syntax_pos::Span;\n use rustc::ty::TyCtxt;\n use ich::Fingerprint;\n@@ -88,12 +87,11 @@ pub struct DirtyCleanVisitor<'a, 'tcx:'a> {\n }\n \n impl<'a, 'tcx> DirtyCleanVisitor<'a, 'tcx> {\n-\n     fn dep_node(&self, attr: &Attribute, def_id: DefId) -> DepNode<DefId> {\n         for item in attr.meta_item_list().unwrap_or(&[]) {\n             if item.check_name(LABEL) {\n                 let value = expect_associated_value(self.tcx, item);\n-                match DepNode::from_label_string(&value[..], def_id) {\n+                match DepNode::from_label_string(&value.as_str(), def_id) {\n                     Ok(def_id) => return def_id,\n                     Err(()) => {\n                         self.tcx.sess.span_fatal(\n@@ -276,13 +274,7 @@ fn check_config(tcx: TyCtxt, attr: &ast::Attribute) -> bool {\n         if item.check_name(CFG) {\n             let value = expect_associated_value(tcx, item);\n             debug!(\"check_config: searching for cfg {:?}\", value);\n-            for cfg in &config[..] {\n-                if cfg.check_name(&value[..]) {\n-                    debug!(\"check_config: matched {:?}\", cfg);\n-                    return true;\n-                }\n-            }\n-            return false;\n+            return config.contains(&(value, None));\n         }\n     }\n \n@@ -291,7 +283,7 @@ fn check_config(tcx: TyCtxt, attr: &ast::Attribute) -> bool {\n         &format!(\"no cfg attribute\"));\n }\n \n-fn expect_associated_value(tcx: TyCtxt, item: &NestedMetaItem) -> InternedString {\n+fn expect_associated_value(tcx: TyCtxt, item: &NestedMetaItem) -> ast::Name {\n     if let Some(value) = item.value_str() {\n         value\n     } else {"}, {"sha": "26181dbaf50ff243b0501514c03abe059f4d5570", "filename": "src/librustc_incremental/persist/fs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibrustc_incremental%2Fpersist%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibrustc_incremental%2Fpersist%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Ffs.rs?ref=ebec55406ba94faf8b2cd23b27a8f74df97d1ca4", "patch": "@@ -604,7 +604,7 @@ fn string_to_timestamp(s: &str) -> Result<SystemTime, ()> {\n }\n \n fn crate_path_tcx(tcx: TyCtxt, cnum: CrateNum) -> PathBuf {\n-    crate_path(tcx.sess, &tcx.crate_name(cnum), &tcx.crate_disambiguator(cnum))\n+    crate_path(tcx.sess, &tcx.crate_name(cnum).as_str(), &tcx.crate_disambiguator(cnum).as_str())\n }\n \n /// Finds the session directory containing the correct metadata hashes file for"}, {"sha": "4440cb41dc5f20051a8a4c883d4d41a1185f6bfc", "filename": "src/librustc_lint/bad_style.rs", "status": "modified", "additions": 10, "deletions": 19, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibrustc_lint%2Fbad_style.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibrustc_lint%2Fbad_style.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbad_style.rs?ref=ebec55406ba94faf8b2cd23b27a8f74df97d1ca4", "patch": "@@ -81,19 +81,12 @@ impl NonCamelCaseTypes {\n                 .concat()\n         }\n \n-        let s = name.as_str();\n-\n         if !is_camel_case(name) {\n-            let c = to_camel_case(&s);\n+            let c = to_camel_case(&name.as_str());\n             let m = if c.is_empty() {\n-                format!(\"{} `{}` should have a camel case name such as `CamelCase`\",\n-                        sort,\n-                        s)\n+                format!(\"{} `{}` should have a camel case name such as `CamelCase`\", sort, name)\n             } else {\n-                format!(\"{} `{}` should have a camel case name such as `{}`\",\n-                        sort,\n-                        s,\n-                        c)\n+                format!(\"{} `{}` should have a camel case name such as `{}`\", sort, name, c)\n             };\n             cx.span_lint(NON_CAMEL_CASE_TYPES, span, &m[..]);\n         }\n@@ -241,8 +234,8 @@ impl LateLintPass for NonSnakeCase {\n             .and_then(|at| at.value_str().map(|s| (at, s)));\n         if let Some(ref name) = cx.tcx.sess.opts.crate_name {\n             self.check_snake_case(cx, \"crate\", name, None);\n-        } else if let Some((attr, ref name)) = attr_crate_name {\n-            self.check_snake_case(cx, \"crate\", name, Some(attr.span));\n+        } else if let Some((attr, name)) = attr_crate_name {\n+            self.check_snake_case(cx, \"crate\", &name.as_str(), Some(attr.span));\n         }\n     }\n \n@@ -326,21 +319,19 @@ pub struct NonUpperCaseGlobals;\n \n impl NonUpperCaseGlobals {\n     fn check_upper_case(cx: &LateContext, sort: &str, name: ast::Name, span: Span) {\n-        let s = name.as_str();\n-\n-        if s.chars().any(|c| c.is_lowercase()) {\n-            let uc = NonSnakeCase::to_snake_case(&s).to_uppercase();\n-            if uc != &s[..] {\n+        if name.as_str().chars().any(|c| c.is_lowercase()) {\n+            let uc = NonSnakeCase::to_snake_case(&name.as_str()).to_uppercase();\n+            if name != &*uc {\n                 cx.span_lint(NON_UPPER_CASE_GLOBALS,\n                              span,\n                              &format!(\"{} `{}` should have an upper case name such as `{}`\",\n                                       sort,\n-                                      s,\n+                                      name,\n                                       uc));\n             } else {\n                 cx.span_lint(NON_UPPER_CASE_GLOBALS,\n                              span,\n-                             &format!(\"{} `{}` should have an upper case name\", sort, s));\n+                             &format!(\"{} `{}` should have an upper case name\", sort, name));\n             }\n         }\n     }"}, {"sha": "0b2ae58852300806d9ec81392a42a0d183c27d53", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=ebec55406ba94faf8b2cd23b27a8f74df97d1ca4", "patch": "@@ -45,6 +45,7 @@ use std::collections::HashSet;\n use syntax::ast;\n use syntax::attr;\n use syntax::feature_gate::{AttributeGate, AttributeType, Stability, deprecated_attributes};\n+use syntax::symbol::Symbol;\n use syntax_pos::Span;\n \n use rustc::hir::{self, PatKind};\n@@ -633,20 +634,20 @@ impl Deprecated {\n             stability: &Option<&attr::Stability>,\n             deprecation: &Option<stability::DeprecationEntry>) {\n         // Deprecated attributes apply in-crate and cross-crate.\n-        if let Some(&attr::Stability{rustc_depr: Some(attr::RustcDeprecation{ref reason, ..}), ..})\n+        if let Some(&attr::Stability{rustc_depr: Some(attr::RustcDeprecation{reason, ..}), ..})\n                 = *stability {\n-            output(cx, DEPRECATED, span, Some(&reason))\n+            output(cx, DEPRECATED, span, Some(reason))\n         } else if let Some(ref depr_entry) = *deprecation {\n             if let Some(parent_depr) = cx.tcx.lookup_deprecation_entry(self.parent_def(cx)) {\n                 if parent_depr.same_origin(depr_entry) {\n                     return;\n                 }\n             }\n \n-            output(cx, DEPRECATED, span, depr_entry.attr.note.as_ref().map(|x| &**x))\n+            output(cx, DEPRECATED, span, depr_entry.attr.note)\n         }\n \n-        fn output(cx: &LateContext, lint: &'static Lint, span: Span, note: Option<&str>) {\n+        fn output(cx: &LateContext, lint: &'static Lint, span: Span, note: Option<Symbol>) {\n             let msg = if let Some(note) = note {\n                 format!(\"use of deprecated item: {}\", note)\n             } else {\n@@ -772,9 +773,9 @@ impl LintPass for DeprecatedAttr {\n \n impl EarlyLintPass for DeprecatedAttr {\n     fn check_attribute(&mut self, cx: &EarlyContext, attr: &ast::Attribute) {\n-        let name = &*attr.name();\n+        let name = attr.name();\n         for &&(n, _, ref g) in &self.depr_attrs {\n-            if n == name {\n+            if name == n {\n                 if let &AttributeGate::Gated(Stability::Deprecated(link),\n                                              ref name,\n                                              ref reason,\n@@ -1228,7 +1229,7 @@ impl LateLintPass for MutableTransmutes {\n                 ty::TyFnDef(.., ref bfty) if bfty.abi == RustIntrinsic => (),\n                 _ => return false,\n             }\n-            cx.tcx.item_name(def_id).as_str() == \"transmute\"\n+            cx.tcx.item_name(def_id) == \"transmute\"\n         }\n     }\n }"}, {"sha": "8aa5e9e0a9460afb18d08531d44fc44577a0f1f7", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=ebec55406ba94faf8b2cd23b27a8f74df97d1ca4", "patch": "@@ -219,9 +219,9 @@ impl LateLintPass for TypeLimits {\n                     ty::TyFloat(t) => {\n                         let (min, max) = float_ty_range(t);\n                         let lit_val: f64 = match lit.node {\n-                            ast::LitKind::Float(ref v, _) |\n-                            ast::LitKind::FloatUnsuffixed(ref v) => {\n-                                match v.parse() {\n+                            ast::LitKind::Float(v, _) |\n+                            ast::LitKind::FloatUnsuffixed(v) => {\n+                                match v.as_str().parse() {\n                                     Ok(f) => f,\n                                     Err(_) => return,\n                                 }"}, {"sha": "fa452017f0cf1d7fecbdb7a1ddbdc6fcf4ae3e97", "filename": "src/librustc_lint/unused.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibrustc_lint%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibrustc_lint%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Funused.rs?ref=ebec55406ba94faf8b2cd23b27a8f74df97d1ca4", "patch": "@@ -20,7 +20,7 @@ use std::collections::hash_map::Entry::{Occupied, Vacant};\n use syntax::ast;\n use syntax::attr;\n use syntax::feature_gate::{BUILTIN_ATTRIBUTES, AttributeType};\n-use syntax::parse::token::keywords;\n+use syntax::symbol::keywords;\n use syntax::ptr::P;\n use syntax_pos::Span;\n \n@@ -48,7 +48,7 @@ impl UnusedMut {\n                 let name = path1.node;\n                 if let hir::BindByValue(hir::MutMutable) = mode {\n                     if !name.as_str().starts_with(\"_\") {\n-                        match mutables.entry(name.0 as usize) {\n+                        match mutables.entry(name) {\n                             Vacant(entry) => {\n                                 entry.insert(vec![id]);\n                             }\n@@ -162,7 +162,7 @@ impl LateLintPass for UnusedResults {\n                     // check for #[must_use=\"...\"]\n                     if let Some(s) = attr.value_str() {\n                         msg.push_str(\": \");\n-                        msg.push_str(&s);\n+                        msg.push_str(&s.as_str());\n                     }\n                     cx.span_lint(UNUSED_MUST_USE, sp, &msg);\n                     return true;\n@@ -274,10 +274,10 @@ impl LateLintPass for UnusedAttributes {\n             // Has a plugin registered this attribute as one which must be used at\n             // the crate level?\n             let plugin_crate = plugin_attributes.iter()\n-                .find(|&&(ref x, t)| &*attr.name() == x && AttributeType::CrateLevel == t)\n+                .find(|&&(ref x, t)| attr.name() == &**x && AttributeType::CrateLevel == t)\n                 .is_some();\n             if known_crate || plugin_crate {\n-                let msg = match attr.node.style {\n+                let msg = match attr.style {\n                     ast::AttrStyle::Outer => {\n                         \"crate-level attribute should be an inner attribute: add an exclamation \\\n                          mark: #![foo]\""}, {"sha": "269fb1dcea4c20840252eb3d4c1dd2fa04b9833e", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 37, "deletions": 40, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=ebec55406ba94faf8b2cd23b27a8f74df97d1ca4", "patch": "@@ -37,7 +37,7 @@ use syntax::abi::Abi;\n use syntax::attr;\n use syntax::ext::base::SyntaxExtension;\n use syntax::feature_gate::{self, GateIssue};\n-use syntax::parse::token::{InternedString, intern};\n+use syntax::symbol::Symbol;\n use syntax_pos::{Span, DUMMY_SP};\n use log;\n \n@@ -52,7 +52,7 @@ pub struct CrateLoader<'a> {\n     cstore: &'a CStore,\n     next_crate_num: CrateNum,\n     foreign_item_map: FxHashMap<String, Vec<ast::NodeId>>,\n-    local_crate_name: String,\n+    local_crate_name: Symbol,\n }\n \n fn dump_crates(cstore: &CStore) {\n@@ -70,8 +70,8 @@ fn dump_crates(cstore: &CStore) {\n \n #[derive(Debug)]\n struct ExternCrateInfo {\n-    ident: String,\n-    name: String,\n+    ident: Symbol,\n+    name: Symbol,\n     id: ast::NodeId,\n     dep_kind: DepKind,\n }\n@@ -80,7 +80,7 @@ fn register_native_lib(sess: &Session,\n                        cstore: &CStore,\n                        span: Option<Span>,\n                        lib: NativeLibrary) {\n-    if lib.name.is_empty() {\n+    if lib.name.as_str().is_empty() {\n         match span {\n             Some(span) => {\n                 struct_span_err!(sess, span, E0454,\n@@ -147,7 +147,7 @@ impl<'a> CrateLoader<'a> {\n             cstore: cstore,\n             next_crate_num: cstore.next_crate_num(),\n             foreign_item_map: FxHashMap(),\n-            local_crate_name: local_crate_name.to_owned(),\n+            local_crate_name: Symbol::intern(local_crate_name),\n         }\n     }\n \n@@ -160,12 +160,12 @@ impl<'a> CrateLoader<'a> {\n                     Some(name) => {\n                         validate_crate_name(Some(self.sess), &name.as_str(),\n                                             Some(i.span));\n-                        name.to_string()\n+                        name\n                     }\n-                    None => i.ident.to_string(),\n+                    None => i.ident.name,\n                 };\n                 Some(ExternCrateInfo {\n-                    ident: i.ident.to_string(),\n+                    ident: i.ident.name,\n                     name: name,\n                     id: i.id,\n                     dep_kind: if attr::contains_name(&i.attrs, \"no_link\") {\n@@ -179,7 +179,7 @@ impl<'a> CrateLoader<'a> {\n         }\n     }\n \n-    fn existing_match(&self, name: &str, hash: Option<&Svh>, kind: PathKind)\n+    fn existing_match(&self, name: Symbol, hash: Option<&Svh>, kind: PathKind)\n                       -> Option<CrateNum> {\n         let mut ret = None;\n         self.cstore.iter_crate_data(|cnum, data| {\n@@ -201,7 +201,7 @@ impl<'a> CrateLoader<'a> {\n             // `source` stores paths which are normalized which may be different\n             // from the strings on the command line.\n             let source = self.cstore.used_crate_source(cnum);\n-            if let Some(locs) = self.sess.opts.externs.get(name) {\n+            if let Some(locs) = self.sess.opts.externs.get(&*name.as_str()) {\n                 let found = locs.iter().any(|l| {\n                     let l = fs::canonicalize(l).ok();\n                     source.dylib.as_ref().map(|p| &p.0) == l.as_ref() ||\n@@ -233,7 +233,7 @@ impl<'a> CrateLoader<'a> {\n                                   root: &CrateRoot) {\n         // Check for (potential) conflicts with the local crate\n         if self.local_crate_name == root.name &&\n-           self.sess.local_crate_disambiguator() == &root.disambiguator[..] {\n+           self.sess.local_crate_disambiguator() == root.disambiguator {\n             span_fatal!(self.sess, span, E0519,\n                         \"the current crate is indistinguishable from one of its \\\n                          dependencies: it has the same crate-name `{}` and was \\\n@@ -258,8 +258,8 @@ impl<'a> CrateLoader<'a> {\n \n     fn register_crate(&mut self,\n                       root: &Option<CratePaths>,\n-                      ident: &str,\n-                      name: &str,\n+                      ident: Symbol,\n+                      name: Symbol,\n                       span: Span,\n                       lib: Library,\n                       dep_kind: DepKind)\n@@ -290,7 +290,7 @@ impl<'a> CrateLoader<'a> {\n         let cnum_map = self.resolve_crate_deps(root, &crate_root, &metadata, cnum, span, dep_kind);\n \n         let cmeta = Rc::new(cstore::CrateMetadata {\n-            name: name.to_string(),\n+            name: name,\n             extern_crate: Cell::new(None),\n             key_map: metadata.load_key_map(crate_root.index),\n             proc_macros: crate_root.macro_derive_registrar.map(|_| {\n@@ -314,8 +314,8 @@ impl<'a> CrateLoader<'a> {\n \n     fn resolve_crate(&mut self,\n                      root: &Option<CratePaths>,\n-                     ident: &str,\n-                     name: &str,\n+                     ident: Symbol,\n+                     name: Symbol,\n                      hash: Option<&Svh>,\n                      span: Span,\n                      path_kind: PathKind,\n@@ -459,13 +459,12 @@ impl<'a> CrateLoader<'a> {\n         let deps = crate_root.crate_deps.decode(metadata);\n         let map: FxHashMap<_, _> = deps.enumerate().map(|(crate_num, dep)| {\n             debug!(\"resolving dep crate {} hash: `{}`\", dep.name, dep.hash);\n-            let dep_name = &dep.name.as_str();\n             let dep_kind = match dep_kind {\n                 DepKind::MacrosOnly => DepKind::MacrosOnly,\n                 _ => dep.kind,\n             };\n             let (local_cnum, ..) = self.resolve_crate(\n-                root, dep_name, dep_name, Some(&dep.hash), span, PathKind::Dependency, dep_kind,\n+                root, dep.name, dep.name, Some(&dep.hash), span, PathKind::Dependency, dep_kind,\n             );\n             (CrateNum::new(crate_num + 1), local_cnum)\n         }).collect();\n@@ -485,13 +484,11 @@ impl<'a> CrateLoader<'a> {\n         let target_triple = &self.sess.opts.target_triple[..];\n         let is_cross = target_triple != config::host_triple();\n         let mut target_only = false;\n-        let ident = info.ident.clone();\n-        let name = info.name.clone();\n         let mut locate_ctxt = locator::Context {\n             sess: self.sess,\n             span: span,\n-            ident: &ident[..],\n-            crate_name: &name[..],\n+            ident: info.ident,\n+            crate_name: info.name,\n             hash: None,\n             filesearch: self.sess.host_filesearch(PathKind::Crate),\n             target: &self.sess.host,\n@@ -585,11 +582,11 @@ impl<'a> CrateLoader<'a> {\n                                       trait_name: &str,\n                                       expand: fn(TokenStream) -> TokenStream,\n                                       attributes: &[&'static str]) {\n-                let attrs = attributes.iter().map(|s| InternedString::new(s)).collect();\n+                let attrs = attributes.iter().cloned().map(Symbol::intern).collect();\n                 let derive = SyntaxExtension::CustomDerive(\n                     Box::new(CustomDerive::new(expand, attrs))\n                 );\n-                self.0.push((intern(trait_name), Rc::new(derive)));\n+                self.0.push((Symbol::intern(trait_name), Rc::new(derive)));\n             }\n         }\n \n@@ -607,8 +604,8 @@ impl<'a> CrateLoader<'a> {\n     pub fn find_plugin_registrar(&mut self, span: Span, name: &str)\n                                  -> Option<(PathBuf, Svh, DefIndex)> {\n         let ekrate = self.read_extension_crate(span, &ExternCrateInfo {\n-             name: name.to_string(),\n-             ident: name.to_string(),\n+             name: Symbol::intern(name),\n+             ident: Symbol::intern(name),\n              id: ast::DUMMY_NODE_ID,\n              dep_kind: DepKind::MacrosOnly,\n         });\n@@ -645,7 +642,7 @@ impl<'a> CrateLoader<'a> {\n         let libs = self.cstore.get_used_libraries();\n         for (foreign_lib, list) in self.foreign_item_map.iter() {\n             let is_static = libs.borrow().iter().any(|lib| {\n-                *foreign_lib == lib.name && lib.kind == cstore::NativeStatic\n+                lib.name == &**foreign_lib && lib.kind == cstore::NativeStatic\n             });\n             if is_static {\n                 for id in list {\n@@ -708,8 +705,8 @@ impl<'a> CrateLoader<'a> {\n         // in terms of everyone has a compatible panic runtime format, that's\n         // performed later as part of the `dependency_format` module.\n         let name = match desired_strategy {\n-            PanicStrategy::Unwind => \"panic_unwind\",\n-            PanicStrategy::Abort => \"panic_abort\",\n+            PanicStrategy::Unwind => Symbol::intern(\"panic_unwind\"),\n+            PanicStrategy::Abort => Symbol::intern(\"panic_abort\"),\n         };\n         info!(\"panic runtime not found -- loading {}\", name);\n \n@@ -791,9 +788,9 @@ impl<'a> CrateLoader<'a> {\n         // * Staticlibs and Rust dylibs use system malloc\n         // * Rust dylibs used as dependencies to rust use jemalloc\n         let name = if need_lib_alloc && !self.sess.opts.cg.prefer_dynamic {\n-            &self.sess.target.target.options.lib_allocation_crate\n+            Symbol::intern(&self.sess.target.target.options.lib_allocation_crate)\n         } else {\n-            &self.sess.target.target.options.exe_allocation_crate\n+            Symbol::intern(&self.sess.target.target.options.exe_allocation_crate)\n         };\n         let dep_kind = DepKind::Implicit;\n         let (cnum, data) =\n@@ -855,8 +852,8 @@ impl<'a> CrateLoader<'a> {\n impl<'a> CrateLoader<'a> {\n     pub fn preprocess(&mut self, krate: &ast::Crate) {\n         for attr in krate.attrs.iter().filter(|m| m.name() == \"link_args\") {\n-            if let Some(ref linkarg) = attr.value_str() {\n-                self.cstore.add_used_link_args(&linkarg);\n+            if let Some(linkarg) = attr.value_str() {\n+                self.cstore.add_used_link_args(&linkarg.as_str());\n             }\n         }\n     }\n@@ -869,7 +866,7 @@ impl<'a> CrateLoader<'a> {\n         // First, add all of the custom #[link_args] attributes\n         for m in i.attrs.iter().filter(|a| a.check_name(\"link_args\")) {\n             if let Some(linkarg) = m.value_str() {\n-                self.cstore.add_used_link_args(&linkarg);\n+                self.cstore.add_used_link_args(&linkarg.as_str());\n             }\n         }\n \n@@ -881,7 +878,7 @@ impl<'a> CrateLoader<'a> {\n             };\n             let kind = items.iter().find(|k| {\n                 k.check_name(\"kind\")\n-            }).and_then(|a| a.value_str());\n+            }).and_then(|a| a.value_str()).map(Symbol::as_str);\n             let kind = match kind.as_ref().map(|s| &s[..]) {\n                 Some(\"static\") => cstore::NativeStatic,\n                 Some(\"dylib\") => cstore::NativeUnknown,\n@@ -903,7 +900,7 @@ impl<'a> CrateLoader<'a> {\n                     struct_span_err!(self.sess, m.span, E0459,\n                                      \"#[link(...)] specified without `name = \\\"foo\\\"`\")\n                         .span_label(m.span, &format!(\"missing `name` argument\")).emit();\n-                    InternedString::new(\"foo\")\n+                    Symbol::intern(\"foo\")\n                 }\n             };\n             let cfg = items.iter().find(|k| {\n@@ -913,7 +910,7 @@ impl<'a> CrateLoader<'a> {\n                 list[0].meta_item().unwrap().clone()\n             });\n             let lib = NativeLibrary {\n-                name: n.to_string(),\n+                name: n,\n                 kind: kind,\n                 cfg: cfg,\n             };\n@@ -944,7 +941,7 @@ impl<'a> middle::cstore::CrateLoader for CrateLoader<'a> {\n \n         for &(ref name, kind) in &self.sess.opts.libs {\n             let lib = NativeLibrary {\n-                name: name.clone(),\n+                name: Symbol::intern(name),\n                 kind: kind,\n                 cfg: None,\n             };\n@@ -962,7 +959,7 @@ impl<'a> middle::cstore::CrateLoader for CrateLoader<'a> {\n \n         let info = self.extract_crate_info(item).unwrap();\n         let (cnum, ..) = self.resolve_crate(\n-            &None, &info.ident, &info.name, None, item.span, PathKind::Crate, info.dep_kind,\n+            &None, info.ident, info.name, None, item.span, PathKind::Crate, info.dep_kind,\n         );\n \n         let def_id = definitions.opt_local_def_id(item.id).unwrap();"}, {"sha": "ce47b936ddc0ebc17db0994fea3e5ff43e8e71e5", "filename": "src/librustc_metadata/cstore.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibrustc_metadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibrustc_metadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore.rs?ref=ebec55406ba94faf8b2cd23b27a8f74df97d1ca4", "patch": "@@ -29,6 +29,7 @@ use std::path::PathBuf;\n use flate::Bytes;\n use syntax::{ast, attr};\n use syntax::ext::base::SyntaxExtension;\n+use syntax::symbol::Symbol;\n use syntax_pos;\n \n pub use rustc::middle::cstore::{NativeLibrary, LinkagePreference};\n@@ -58,7 +59,7 @@ pub struct ImportedFileMap {\n }\n \n pub struct CrateMetadata {\n-    pub name: String,\n+    pub name: Symbol,\n \n     /// Information about the extern crate that caused this crate to\n     /// be loaded. If this is `None`, then the crate was injected\n@@ -213,7 +214,7 @@ impl CStore {\n     }\n \n     pub fn add_used_library(&self, lib: NativeLibrary) {\n-        assert!(!lib.name.is_empty());\n+        assert!(!lib.name.as_str().is_empty());\n         self.used_libraries.borrow_mut().push(lib);\n     }\n \n@@ -249,14 +250,14 @@ impl CStore {\n }\n \n impl CrateMetadata {\n-    pub fn name(&self) -> &str {\n-        &self.root.name\n+    pub fn name(&self) -> Symbol {\n+        self.root.name\n     }\n     pub fn hash(&self) -> Svh {\n         self.root.hash\n     }\n-    pub fn disambiguator(&self) -> &str {\n-        &self.root.disambiguator\n+    pub fn disambiguator(&self) -> Symbol {\n+        self.root.disambiguator\n     }\n \n     pub fn is_staged_api(&self) -> bool {"}, {"sha": "407166203de87b4f12dc263e39a439f21cc6ce5e", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=ebec55406ba94faf8b2cd23b27a8f74df97d1ca4", "patch": "@@ -31,7 +31,8 @@ use rustc_back::PanicStrategy;\n use std::path::PathBuf;\n use syntax::ast;\n use syntax::attr;\n-use syntax::parse::{token, new_parser_from_source_str};\n+use syntax::parse::new_parser_from_source_str;\n+use syntax::symbol::Symbol;\n use syntax_pos::mk_sp;\n use rustc::hir::svh::Svh;\n use rustc_back::target::Target;\n@@ -262,14 +263,14 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n         self.get_crate_data(cnum).panic_strategy()\n     }\n \n-    fn crate_name(&self, cnum: CrateNum) -> token::InternedString\n+    fn crate_name(&self, cnum: CrateNum) -> Symbol\n     {\n-        token::intern_and_get_ident(&self.get_crate_data(cnum).name[..])\n+        self.get_crate_data(cnum).name\n     }\n \n-    fn original_crate_name(&self, cnum: CrateNum) -> token::InternedString\n+    fn original_crate_name(&self, cnum: CrateNum) -> Symbol\n     {\n-        token::intern_and_get_ident(&self.get_crate_data(cnum).name())\n+        self.get_crate_data(cnum).name()\n     }\n \n     fn extern_crate(&self, cnum: CrateNum) -> Option<ExternCrate>\n@@ -282,9 +283,9 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n         self.get_crate_hash(cnum)\n     }\n \n-    fn crate_disambiguator(&self, cnum: CrateNum) -> token::InternedString\n+    fn crate_disambiguator(&self, cnum: CrateNum) -> Symbol\n     {\n-        token::intern_and_get_ident(&self.get_crate_data(cnum).disambiguator())\n+        self.get_crate_data(cnum).disambiguator()\n     }\n \n     fn plugin_registrar_fn(&self, cnum: CrateNum) -> Option<DefId>"}, {"sha": "fb1314992c094d0596ab1618c618a69e112383ec", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=ebec55406ba94faf8b2cd23b27a8f74df97d1ca4", "patch": "@@ -934,7 +934,7 @@ impl<'a, 'tcx> CrateMetadata {\n             .decode(self)\n             .map(|mut attr| {\n                 // Need new unique IDs: old thread-local IDs won't map to new threads.\n-                attr.node.id = attr::mk_attr_id();\n+                attr.id = attr::mk_attr_id();\n                 attr\n             })\n             .collect()"}, {"sha": "2f4b0d5c87b0dc6fb1df552a8df4200897d804d6", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=ebec55406ba94faf8b2cd23b27a8f74df97d1ca4", "patch": "@@ -34,7 +34,7 @@ use std::rc::Rc;\n use std::u32;\n use syntax::ast::{self, CRATE_NODE_ID};\n use syntax::attr;\n-use syntax;\n+use syntax::symbol::Symbol;\n use syntax_pos;\n \n use rustc::hir::{self, PatKind};\n@@ -600,7 +600,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             if let PatKind::Binding(_, ref path1, _) = arg.pat.node {\n                 path1.node\n             } else {\n-                syntax::parse::token::intern(\"\")\n+                Symbol::intern(\"\")\n             }\n         }))\n     }\n@@ -1119,7 +1119,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         let deps = get_ordered_deps(self.cstore);\n         self.lazy_seq(deps.iter().map(|&(_, ref dep)| {\n             CrateDep {\n-                name: syntax::parse::token::intern(dep.name()),\n+                name: dep.name(),\n                 hash: dep.hash(),\n                 kind: dep.dep_kind.get(),\n             }\n@@ -1279,10 +1279,10 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         let is_proc_macro = tcx.sess.crate_types.borrow().contains(&CrateTypeProcMacro);\n         let root = self.lazy(&CrateRoot {\n             rustc_version: rustc_version(),\n-            name: link_meta.crate_name.clone(),\n+            name: link_meta.crate_name,\n             triple: tcx.sess.opts.target_triple.clone(),\n             hash: link_meta.crate_hash,\n-            disambiguator: tcx.sess.local_crate_disambiguator().to_string(),\n+            disambiguator: tcx.sess.local_crate_disambiguator(),\n             panic_strategy: tcx.sess.panic_strategy(),\n             plugin_registrar_fn: tcx.sess\n                 .plugin_registrar_fn"}, {"sha": "f5196f7ea8428470783899cb9a514bb8580cb6f1", "filename": "src/librustc_metadata/locator.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibrustc_metadata%2Flocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibrustc_metadata%2Flocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Flocator.rs?ref=ebec55406ba94faf8b2cd23b27a8f74df97d1ca4", "patch": "@@ -227,6 +227,7 @@ use rustc_llvm as llvm;\n use rustc_llvm::{False, ObjectFile, mk_section_iter};\n use rustc_llvm::archive_ro::ArchiveRO;\n use errors::DiagnosticBuilder;\n+use syntax::symbol::Symbol;\n use syntax_pos::Span;\n use rustc_back::target::Target;\n \n@@ -249,8 +250,8 @@ pub struct CrateMismatch {\n pub struct Context<'a> {\n     pub sess: &'a Session,\n     pub span: Span,\n-    pub ident: &'a str,\n-    pub crate_name: &'a str,\n+    pub ident: Symbol,\n+    pub crate_name: Symbol,\n     pub hash: Option<&'a Svh>,\n     // points to either self.sess.target.target or self.sess.host, must match triple\n     pub target: &'a Target,\n@@ -422,7 +423,7 @@ impl<'a> Context<'a> {\n         // must be loaded via -L plus some filtering.\n         if self.hash.is_none() {\n             self.should_match_name = false;\n-            if let Some(s) = self.sess.opts.externs.get(self.crate_name) {\n+            if let Some(s) = self.sess.opts.externs.get(&self.crate_name.as_str()) {\n                 return self.find_commandline_library(s.iter());\n             }\n             self.should_match_name = true;\n@@ -533,7 +534,7 @@ impl<'a> Context<'a> {\n                     if let Some((ref p, _)) = lib.rlib {\n                         err.note(&format!(\"path: {}\", p.display()));\n                     }\n-                    note_crate_name(&mut err, &lib.metadata.get_root().name);\n+                    note_crate_name(&mut err, &lib.metadata.get_root().name.as_str());\n                 }\n                 err.emit();\n                 None"}, {"sha": "e11719dc40f2a83aa1ccfdb2047ec46fbabf0397", "filename": "src/librustc_metadata/schema.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibrustc_metadata%2Fschema.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibrustc_metadata%2Fschema.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fschema.rs?ref=ebec55406ba94faf8b2cd23b27a8f74df97d1ca4", "patch": "@@ -22,6 +22,7 @@ use rustc_back::PanicStrategy;\n \n use rustc_serialize as serialize;\n use syntax::{ast, attr};\n+use syntax::symbol::Symbol;\n use syntax_pos::{self, Span};\n \n use std::marker::PhantomData;\n@@ -163,10 +164,10 @@ pub enum LazyState {\n #[derive(RustcEncodable, RustcDecodable)]\n pub struct CrateRoot {\n     pub rustc_version: String,\n-    pub name: String,\n+    pub name: Symbol,\n     pub triple: String,\n     pub hash: hir::svh::Svh,\n-    pub disambiguator: String,\n+    pub disambiguator: Symbol,\n     pub panic_strategy: PanicStrategy,\n     pub plugin_registrar_fn: Option<DefIndex>,\n     pub macro_derive_registrar: Option<DefIndex>,"}, {"sha": "d281b2a32d045619b08460aa394a904b8d2bb92e", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=ebec55406ba94faf8b2cd23b27a8f74df97d1ca4", "patch": "@@ -18,7 +18,7 @@ use rustc::util::nodemap::NodeMap;\n use rustc::hir;\n use syntax::abi::Abi;\n use syntax::ast;\n-use syntax::parse::token::keywords;\n+use syntax::symbol::keywords;\n use syntax_pos::Span;\n \n use rustc_data_structures::indexed_vec::{IndexVec, Idx};"}, {"sha": "cfeac606f03d0c45cb8264a2ad1b6e78076b09c7", "filename": "src/librustc_mir/hair/cx/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs?ref=ebec55406ba94faf8b2cd23b27a8f74df97d1ca4", "patch": "@@ -28,7 +28,7 @@ use rustc::hir::map::blocks::FnLikeNode;\n use rustc::infer::InferCtxt;\n use rustc::ty::subst::Subst;\n use rustc::ty::{self, Ty, TyCtxt};\n-use syntax::parse::token;\n+use syntax::symbol::{Symbol, InternedString};\n use rustc::hir;\n use rustc_const_math::{ConstInt, ConstUsize};\n \n@@ -120,7 +120,7 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n         self.tcx.mk_nil()\n     }\n \n-    pub fn str_literal(&mut self, value: token::InternedString) -> Literal<'tcx> {\n+    pub fn str_literal(&mut self, value: InternedString) -> Literal<'tcx> {\n         Literal::Value { value: ConstVal::Str(value) }\n     }\n \n@@ -144,7 +144,7 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n                         self_ty: Ty<'tcx>,\n                         params: &[Ty<'tcx>])\n                         -> (Ty<'tcx>, Literal<'tcx>) {\n-        let method_name = token::intern(method_name);\n+        let method_name = Symbol::intern(method_name);\n         let substs = self.tcx.mk_substs_trait(self_ty, params);\n         for item in self.tcx.associated_items(trait_def_id) {\n             if item.kind == ty::AssociatedKind::Method && item.name == method_name {"}, {"sha": "89c3efaafcdcc912af23a799d47c09b756b6eff9", "filename": "src/librustc_passes/ast_validation.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibrustc_passes%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibrustc_passes%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fast_validation.rs?ref=ebec55406ba94faf8b2cd23b27a8f74df97d1ca4", "patch": "@@ -21,7 +21,8 @@ use rustc::session::Session;\n use syntax::ast::*;\n use syntax::attr;\n use syntax::codemap::Spanned;\n-use syntax::parse::token::{self, keywords};\n+use syntax::parse::token;\n+use syntax::symbol::keywords;\n use syntax::visit::{self, Visitor};\n use syntax_pos::Span;\n use errors;\n@@ -39,7 +40,7 @@ impl<'a> AstValidator<'a> {\n         if label.name == keywords::StaticLifetime.name() {\n             self.err_handler().span_err(span, &format!(\"invalid label name `{}`\", label.name));\n         }\n-        if label.name.as_str() == \"'_\" {\n+        if label.name == \"'_\" {\n             self.session.add_lint(lint::builtin::LIFETIME_UNDERSCORE,\n                                   id,\n                                   span,\n@@ -89,7 +90,7 @@ impl<'a> AstValidator<'a> {\n \n impl<'a> Visitor for AstValidator<'a> {\n     fn visit_lifetime(&mut self, lt: &Lifetime) {\n-        if lt.name.as_str() == \"'_\" {\n+        if lt.name == \"'_\" {\n             self.session.add_lint(lint::builtin::LIFETIME_UNDERSCORE,\n                                   lt.id,\n                                   lt.span,"}, {"sha": "dafb7bc6e60996d67482cb982f4e83b19071e9cf", "filename": "src/librustc_passes/hir_stats.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibrustc_passes%2Fhir_stats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibrustc_passes%2Fhir_stats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fhir_stats.rs?ref=ebec55406ba94faf8b2cd23b27a8f74df97d1ca4", "patch": "@@ -240,7 +240,7 @@ impl<'v> hir_visit::Visitor<'v> for StatCollector<'v> {\n         hir_visit::walk_assoc_type_binding(self, type_binding)\n     }\n     fn visit_attribute(&mut self, attr: &'v ast::Attribute) {\n-        self.record(\"Attribute\", Id::Attr(attr.node.id), attr);\n+        self.record(\"Attribute\", Id::Attr(attr.id), attr);\n     }\n     fn visit_macro_def(&mut self, macro_def: &'v hir::MacroDef) {\n         self.record(\"MacroDef\", Id::Node(macro_def.id), macro_def);"}, {"sha": "1bfc445fca98d72ca4f7c8f03a92b63dda875fc1", "filename": "src/librustc_plugin/load.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibrustc_plugin%2Fload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibrustc_plugin%2Fload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_plugin%2Fload.rs?ref=ebec55406ba94faf8b2cd23b27a8f74df97d1ca4", "patch": "@@ -69,9 +69,9 @@ pub fn load_plugins(sess: &Session,\n             for plugin in plugins {\n                 // plugins must have a name and can't be key = value\n                 match plugin.name() {\n-                    Some(ref name) if !plugin.is_value_str() => {\n+                    Some(name) if !plugin.is_value_str() => {\n                         let args = plugin.meta_item_list().map(ToOwned::to_owned);\n-                        loader.load_plugin(plugin.span, name, args.unwrap_or_default());\n+                        loader.load_plugin(plugin.span, &name.as_str(), args.unwrap_or_default());\n                     },\n                     _ => call_malformed_plugin_attribute(sess, attr.span),\n                 }"}, {"sha": "fe2f9713d1beb29ae0cafd35af921d9fb1711572", "filename": "src/librustc_plugin/registry.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibrustc_plugin%2Fregistry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibrustc_plugin%2Fregistry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_plugin%2Fregistry.rs?ref=ebec55406ba94faf8b2cd23b27a8f74df97d1ca4", "patch": "@@ -17,7 +17,7 @@ use rustc::mir::transform::MirMapPass;\n \n use syntax::ext::base::{SyntaxExtension, NamedSyntaxExtension, NormalTT, IdentTT};\n use syntax::ext::base::MacroExpanderFn;\n-use syntax::parse::token;\n+use syntax::symbol::Symbol;\n use syntax::ast;\n use syntax::feature_gate::AttributeType;\n use syntax_pos::Span;\n@@ -101,7 +101,7 @@ impl<'a> Registry<'a> {\n     ///\n     /// This is the most general hook into `libsyntax`'s expansion behavior.\n     pub fn register_syntax_extension(&mut self, name: ast::Name, extension: SyntaxExtension) {\n-        if name.as_str() == \"macro_rules\" {\n+        if name == \"macro_rules\" {\n             panic!(\"user-defined macros may not be named `macro_rules`\");\n         }\n         self.syntax_exts.push((name, match extension {\n@@ -121,7 +121,7 @@ impl<'a> Registry<'a> {\n     /// It builds for you a `NormalTT` that calls `expander`,\n     /// and also takes care of interning the macro's name.\n     pub fn register_macro(&mut self, name: &str, expander: MacroExpanderFn) {\n-        self.register_syntax_extension(token::intern(name),\n+        self.register_syntax_extension(Symbol::intern(name),\n                                        NormalTT(Box::new(expander), None, false));\n     }\n "}, {"sha": "ff2f25a12fc8607874a99d4c945a6a59eb38233e", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=ebec55406ba94faf8b2cd23b27a8f74df97d1ca4", "patch": "@@ -31,7 +31,6 @@ use std::rc::Rc;\n \n use syntax::ast::Name;\n use syntax::attr;\n-use syntax::parse::token;\n \n use syntax::ast::{self, Block, ForeignItem, ForeignItemKind, Item, ItemKind};\n use syntax::ast::{Mutability, StmtKind, TraitItem, TraitItemKind};\n@@ -41,7 +40,7 @@ use syntax::ext::base::Determinacy::Undetermined;\n use syntax::ext::expand::mark_tts;\n use syntax::ext::hygiene::Mark;\n use syntax::ext::tt::macro_rules;\n-use syntax::parse::token::keywords;\n+use syntax::symbol::keywords;\n use syntax::visit::{self, Visitor};\n \n use syntax_pos::{Span, DUMMY_SP};\n@@ -139,7 +138,7 @@ impl<'b> Resolver<'b> {\n                 match view_path.node {\n                     ViewPathSimple(binding, ref full_path) => {\n                         let mut source = full_path.segments.last().unwrap().identifier;\n-                        let source_name = source.name.as_str();\n+                        let source_name = source.name;\n                         if source_name == \"mod\" || source_name == \"self\" {\n                             resolve_error(self,\n                                           view_path.span,\n@@ -607,7 +606,7 @@ impl<'b> Resolver<'b> {\n             if attr.check_name(\"macro_escape\") {\n                 let msg = \"macro_escape is a deprecated synonym for macro_use\";\n                 let mut err = self.session.struct_span_warn(attr.span, msg);\n-                if let ast::AttrStyle::Inner = attr.node.style {\n+                if let ast::AttrStyle::Inner = attr.style {\n                     err.help(\"consider an outer attribute, #[macro_use] mod ...\").emit();\n                 } else {\n                     err.emit();\n@@ -632,7 +631,7 @@ impl<'b> Resolver<'b> {\n                 match attr.meta_item_list() {\n                     Some(names) => for attr in names {\n                         if let Some(word) = attr.word() {\n-                            imports.imports.push((token::intern(&word.name()), attr.span()));\n+                            imports.imports.push((word.name(), attr.span()));\n                         } else {\n                             span_err!(self.session, attr.span(), E0466, \"bad macro import\");\n                         }\n@@ -646,7 +645,7 @@ impl<'b> Resolver<'b> {\n                 if let Some(names) = attr.meta_item_list() {\n                     for attr in names {\n                         if let Some(word) = attr.word() {\n-                            imports.reexports.push((token::intern(&word.name()), attr.span()));\n+                            imports.reexports.push((word.name(), attr.span()));\n                         } else {\n                             bad_macro_reexport(self, attr.span());\n                         }"}, {"sha": "c72ba7bb6876607ddc41b05295dea45eaae651b4", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 12, "deletions": 14, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=ebec55406ba94faf8b2cd23b27a8f74df97d1ca4", "patch": "@@ -57,7 +57,7 @@ use syntax::ext::hygiene::{Mark, SyntaxContext};\n use syntax::ast::{self, FloatTy};\n use syntax::ast::{CRATE_NODE_ID, Name, NodeId, Ident, SpannedIdent, IntTy, UintTy};\n use syntax::ext::base::SyntaxExtension;\n-use syntax::parse::token::{self, keywords};\n+use syntax::symbol::{Symbol, keywords};\n use syntax::util::lev_distance::find_best_match_for_name;\n \n use syntax::visit::{self, FnKind, Visitor};\n@@ -90,7 +90,7 @@ mod resolve_imports;\n \n enum SuggestionType {\n     Macro(String),\n-    Function(token::InternedString),\n+    Function(Symbol),\n     NotFound,\n }\n \n@@ -1039,7 +1039,7 @@ impl PrimitiveTypeTable {\n     }\n \n     fn intern(&mut self, string: &str, primitive_type: PrimTy) {\n-        self.primitive_types.insert(token::intern(string), primitive_type);\n+        self.primitive_types.insert(Symbol::intern(string), primitive_type);\n     }\n }\n \n@@ -1460,7 +1460,6 @@ impl<'a> Resolver<'a> {\n             let name = module_path[index].name;\n             match self.resolve_name_in_module(search_module, name, TypeNS, false, span) {\n                 Failed(_) => {\n-                    let segment_name = name.as_str();\n                     let module_name = module_to_string(search_module);\n                     let msg = if \"???\" == &module_name {\n                         let current_module = self.current_module;\n@@ -1478,10 +1477,10 @@ impl<'a> Resolver<'a> {\n \n                                 format!(\"Did you mean `{}{}`?\", prefix, path_str)\n                             }\n-                            None => format!(\"Maybe a missing `extern crate {};`?\", segment_name),\n+                            None => format!(\"Maybe a missing `extern crate {};`?\", name),\n                         }\n                     } else {\n-                        format!(\"Could not find `{}` in `{}`\", segment_name, module_name)\n+                        format!(\"Could not find `{}` in `{}`\", name, module_name)\n                     };\n \n                     return Failed(span.map(|span| (span, msg)));\n@@ -1649,7 +1648,7 @@ impl<'a> Resolver<'a> {\n     /// grammar: (SELF MOD_SEP ) ? (SUPER MOD_SEP) *\n     fn resolve_module_prefix(&mut self, module_path: &[Ident], span: Option<Span>)\n                              -> ResolveResult<ModulePrefixResult<'a>> {\n-        if &*module_path[0].name.as_str() == \"$crate\" {\n+        if module_path[0].name == \"$crate\" {\n             return Success(PrefixFound(self.resolve_crate_var(module_path[0].ctxt), 1));\n         }\n \n@@ -1665,7 +1664,7 @@ impl<'a> Resolver<'a> {\n             self.module_map[&self.current_module.normal_ancestor_id.unwrap()];\n \n         // Now loop through all the `super`s we find.\n-        while i < module_path.len() && \"super\" == module_path[i].name.as_str() {\n+        while i < module_path.len() && module_path[i].name == \"super\" {\n             debug!(\"(resolving module prefix) resolving `super` at {}\",\n                    module_to_string(&containing_module));\n             if let Some(parent) = containing_module.parent {\n@@ -2633,7 +2632,7 @@ impl<'a> Resolver<'a> {\n         let qualified_binding = self.resolve_module_relative_path(span, segments, namespace);\n         match (qualified_binding, unqualified_def) {\n             (Ok(binding), Some(ref ud)) if binding.def() == ud.def &&\n-                                           segments[0].identifier.name.as_str() != \"$crate\" => {\n+                                           segments[0].identifier.name != \"$crate\" => {\n                 self.session\n                     .add_lint(lint::builtin::UNUSED_QUALIFICATIONS,\n                               id,\n@@ -2879,7 +2878,7 @@ impl<'a> Resolver<'a> {\n     }\n \n     fn find_best_match(&mut self, name: &str) -> SuggestionType {\n-        if let Some(macro_name) = self.macro_names.iter().find(|n| n.as_str() == name) {\n+        if let Some(macro_name) = self.macro_names.iter().find(|&n| n == &name) {\n             return SuggestionType::Macro(format!(\"{}!\", macro_name));\n         }\n \n@@ -2889,7 +2888,7 @@ impl<'a> Resolver<'a> {\n                     .flat_map(|rib| rib.bindings.keys().map(|ident| &ident.name));\n \n         if let Some(found) = find_best_match_for_name(names, name, None) {\n-            if name != found {\n+            if found != name {\n                 return SuggestionType::Function(found);\n             }\n         } SuggestionType::NotFound\n@@ -2998,8 +2997,7 @@ impl<'a> Resolver<'a> {\n                                 false // Stop advancing\n                             });\n \n-                            if method_scope &&\n-                                    &path_name[..] == keywords::SelfValue.name().as_str() {\n+                            if method_scope && keywords::SelfValue.name() == &*path_name {\n                                 resolve_error(self,\n                                               expr.span,\n                                               ResolutionError::SelfNotAvailableInStaticMethod);\n@@ -3604,7 +3602,7 @@ fn module_to_string(module: Module) -> String {\n             }\n         } else {\n             // danger, shouldn't be ident?\n-            names.push(token::str_to_ident(\"<opaque>\"));\n+            names.push(Ident::from_str(\"<opaque>\"));\n             collect_mod(names, module.parent.unwrap());\n         }\n     }"}, {"sha": "62adf382a69add955ddddc8125e83a7785f9124f", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=ebec55406ba94faf8b2cd23b27a8f74df97d1ca4", "patch": "@@ -27,7 +27,6 @@ use syntax::ext::expand::Expansion;\n use syntax::ext::hygiene::Mark;\n use syntax::ext::tt::macro_rules;\n use syntax::fold::Folder;\n-use syntax::parse::token::intern;\n use syntax::ptr::P;\n use syntax::util::lev_distance::find_best_match_for_name;\n use syntax::visit::Visitor;\n@@ -116,7 +115,7 @@ impl<'a> base::Resolver for Resolver<'a> {\n         impl<'a, 'b> Folder for EliminateCrateVar<'a, 'b> {\n             fn fold_path(&mut self, mut path: ast::Path) -> ast::Path {\n                 let ident = path.segments[0].identifier;\n-                if &ident.name.as_str() == \"$crate\" {\n+                if ident.name == \"$crate\" {\n                     path.global = true;\n                     let module = self.0.resolve_crate_var(ident.ctxt);\n                     if module.is_local() {\n@@ -152,7 +151,7 @@ impl<'a> base::Resolver for Resolver<'a> {\n     }\n \n     fn add_macro(&mut self, scope: Mark, mut def: ast::MacroDef, export: bool) {\n-        if &def.ident.name.as_str() == \"macro_rules\" {\n+        if def.ident.name == \"macro_rules\" {\n             self.session.span_err(def.span, \"user-defined macros may not be named `macro_rules`\");\n         }\n \n@@ -207,8 +206,7 @@ impl<'a> base::Resolver for Resolver<'a> {\n \n     fn find_attr_invoc(&mut self, attrs: &mut Vec<ast::Attribute>) -> Option<ast::Attribute> {\n         for i in 0..attrs.len() {\n-            let name = intern(&attrs[i].name());\n-            match self.builtin_macros.get(&name).cloned() {\n+            match self.builtin_macros.get(&attrs[i].name()).cloned() {\n                 Some(binding) => match *self.get_macro(binding) {\n                     MultiModifier(..) | MultiDecorator(..) | SyntaxExtension::AttrProcMacro(..) => {\n                         return Some(attrs.remove(i))"}, {"sha": "87b2b88fe33fccb7dac9494aecc7a86ac805cf97", "filename": "src/librustc_save_analysis/dump_visitor.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdump_visitor.rs?ref=ebec55406ba94faf8b2cd23b27a8f74df97d1ca4", "patch": "@@ -39,7 +39,8 @@ use std::collections::hash_map::DefaultHasher;\n use std::hash::*;\n \n use syntax::ast::{self, NodeId, PatKind, Attribute, CRATE_NODE_ID};\n-use syntax::parse::token::{self, keywords};\n+use syntax::parse::token;\n+use syntax::symbol::keywords;\n use syntax::visit::{self, Visitor};\n use syntax::print::pprust::{path_to_string, ty_to_string, bounds_to_string, generics_to_string};\n use syntax::ptr::P;"}, {"sha": "bd5da588a864d2228f91eccabfc43e4000b9d2aa", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=ebec55406ba94faf8b2cd23b27a8f74df97d1ca4", "patch": "@@ -54,7 +54,8 @@ use std::path::{Path, PathBuf};\n \n use syntax::ast::{self, NodeId, PatKind, Attribute, CRATE_NODE_ID};\n use syntax::parse::lexer::comments::strip_doc_comment_decoration;\n-use syntax::parse::token::{self, keywords, InternedString};\n+use syntax::parse::token;\n+use syntax::symbol::{Symbol, keywords};\n use syntax::visit::{self, Visitor};\n use syntax::print::pprust::{ty_to_string, arg_to_string};\n use syntax::codemap::MacroAttribute;\n@@ -119,7 +120,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                 }\n             };\n             result.push(CrateData {\n-                name: (&self.tcx.sess.cstore.crate_name(n)[..]).to_owned(),\n+                name: self.tcx.sess.cstore.crate_name(n).to_string(),\n                 number: n.as_u32(),\n                 span: span,\n             });\n@@ -728,16 +729,16 @@ impl Visitor for PathCollector {\n }\n \n fn docs_for_attrs(attrs: &[Attribute]) -> String {\n-    let doc = InternedString::new(\"doc\");\n+    let doc = Symbol::intern(\"doc\");\n     let mut result = String::new();\n \n     for attr in attrs {\n         if attr.name() == doc {\n-            if let Some(ref val) = attr.value_str() {\n-                if attr.node.is_sugared_doc {\n-                    result.push_str(&strip_doc_comment_decoration(val));\n+            if let Some(val) = attr.value_str() {\n+                if attr.is_sugared_doc {\n+                    result.push_str(&strip_doc_comment_decoration(&val.as_str()));\n                 } else {\n-                    result.push_str(val);\n+                    result.push_str(&val.as_str());\n                 }\n                 result.push('\\n');\n             }"}, {"sha": "e06aefd865f1ba6486c1dadf5ab4bb10081f0f84", "filename": "src/librustc_save_analysis/span_utils.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibrustc_save_analysis%2Fspan_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibrustc_save_analysis%2Fspan_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fspan_utils.rs?ref=ebec55406ba94faf8b2cd23b27a8f74df97d1ca4", "patch": "@@ -18,7 +18,8 @@ use std::path::Path;\n \n use syntax::ast;\n use syntax::parse::lexer::{self, Reader, StringReader};\n-use syntax::parse::token::{self, keywords, Token};\n+use syntax::parse::token::{self, Token};\n+use syntax::symbol::keywords;\n use syntax_pos::*;\n \n #[derive(Clone)]"}, {"sha": "665e12cbe87955e624cfeb2ef7e5b03e297718db", "filename": "src/librustc_trans/asm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibrustc_trans%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibrustc_trans%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fasm.rs?ref=ebec55406ba94faf8b2cd23b27a8f74df97d1ca4", "patch": "@@ -88,7 +88,7 @@ pub fn trans_inline_asm<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         AsmDialect::Intel => llvm::AsmDialect::Intel,\n     };\n \n-    let asm = CString::new(ia.asm.as_bytes()).unwrap();\n+    let asm = CString::new(ia.asm.as_str().as_bytes()).unwrap();\n     let constraint_cstr = CString::new(all_constraints).unwrap();\n     let r = InlineAsmCall(bcx,\n                           asm.as_ptr(),"}, {"sha": "898e65ce391e609dd295dc29971a85cb09075f42", "filename": "src/librustc_trans/assert_module_sources.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibrustc_trans%2Fassert_module_sources.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibrustc_trans%2Fassert_module_sources.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fassert_module_sources.rs?ref=ebec55406ba94faf8b2cd23b27a8f74df97d1ca4", "patch": "@@ -29,7 +29,6 @@\n \n use rustc::ty::TyCtxt;\n use syntax::ast;\n-use syntax::parse::token::InternedString;\n \n use {ModuleSource, ModuleTranslation};\n \n@@ -77,7 +76,7 @@ impl<'a, 'tcx> AssertModuleSource<'a, 'tcx> {\n         }\n \n         let mname = self.field(attr, MODULE);\n-        let mtrans = self.modules.iter().find(|mtrans| &mtrans.name[..] == &mname[..]);\n+        let mtrans = self.modules.iter().find(|mtrans| *mtrans.name == *mname.as_str());\n         let mtrans = match mtrans {\n             Some(m) => m,\n             None => {\n@@ -113,7 +112,7 @@ impl<'a, 'tcx> AssertModuleSource<'a, 'tcx> {\n         }\n     }\n \n-    fn field(&self, attr: &ast::Attribute, name: &str) -> InternedString {\n+    fn field(&self, attr: &ast::Attribute, name: &str) -> ast::Name {\n         for item in attr.meta_item_list().unwrap_or(&[]) {\n             if item.check_name(name) {\n                 if let Some(value) = item.value_str() {\n@@ -137,7 +136,7 @@ impl<'a, 'tcx> AssertModuleSource<'a, 'tcx> {\n         let config = &self.tcx.sess.parse_sess.config;\n         let value = self.field(attr, CFG);\n         debug!(\"check_config(config={:?}, value={:?})\", config, value);\n-        if config.iter().any(|c| c.check_name(&value[..])) {\n+        if config.iter().any(|&(name, _)| name == value) {\n             debug!(\"check_config: matched\");\n             return true;\n         }"}, {"sha": "d0339775a78a1e7f72c09b60a67f100038781aca", "filename": "src/librustc_trans/back/link.rs", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibrustc_trans%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibrustc_trans%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flink.rs?ref=ebec55406ba94faf8b2cd23b27a8f74df97d1ca4", "patch": "@@ -44,6 +44,7 @@ use std::str;\n use flate;\n use syntax::ast;\n use syntax::attr;\n+use syntax::symbol::Symbol;\n use syntax_pos::Span;\n \n // RLIB LLVM-BYTECODE OBJECT LAYOUT\n@@ -93,8 +94,8 @@ pub fn find_crate_name(sess: Option<&Session>,\n \n     if let Some(sess) = sess {\n         if let Some(ref s) = sess.opts.crate_name {\n-            if let Some((attr, ref name)) = attr_crate_name {\n-                if *s != &name[..] {\n+            if let Some((attr, name)) = attr_crate_name {\n+                if name != &**s {\n                     let msg = format!(\"--crate-name and #[crate_name] are \\\n                                        required to match, but `{}` != `{}`\",\n                                       s, name);\n@@ -130,7 +131,7 @@ pub fn build_link_meta(incremental_hashes_map: &IncrementalHashesMap,\n                        name: &str)\n                        -> LinkMeta {\n     let r = LinkMeta {\n-        crate_name: name.to_owned(),\n+        crate_name: Symbol::intern(name),\n         crate_hash: Svh::new(incremental_hashes_map[&DepNode::Krate].to_smaller_hash()),\n     };\n     info!(\"{:?}\", r);\n@@ -429,7 +430,7 @@ fn link_rlib<'a>(sess: &'a Session,\n             NativeLibraryKind::NativeFramework |\n             NativeLibraryKind::NativeUnknown => continue,\n         }\n-        ab.add_native_library(&lib.name);\n+        ab.add_native_library(&lib.name.as_str());\n     }\n \n     // After adding all files to the archive, we need to update the\n@@ -615,7 +616,7 @@ fn link_staticlib(sess: &Session, objects: &[PathBuf], out_filename: &Path,\n         let skip_object_files = native_libs.iter().any(|lib| {\n             lib.kind == NativeLibraryKind::NativeStatic && !relevant_lib(sess, lib)\n         });\n-        ab.add_rlib(path, &name, sess.lto(), skip_object_files).unwrap();\n+        ab.add_rlib(path, &name.as_str(), sess.lto(), skip_object_files).unwrap();\n \n         all_native_libs.extend(sess.cstore.native_libraries(cnum));\n     });\n@@ -934,15 +935,15 @@ fn add_local_native_libraries(cmd: &mut Linker, sess: &Session) {\n         // don't otherwise explicitly reference them. This can occur for\n         // libraries which are just providing bindings, libraries with generic\n         // functions, etc.\n-        cmd.link_whole_staticlib(&l.name, &search_path);\n+        cmd.link_whole_staticlib(&l.name.as_str(), &search_path);\n     }\n \n     cmd.hint_dynamic();\n \n     for lib in others {\n         match lib.kind {\n-            NativeLibraryKind::NativeUnknown => cmd.link_dylib(&lib.name),\n-            NativeLibraryKind::NativeFramework => cmd.link_framework(&lib.name),\n+            NativeLibraryKind::NativeUnknown => cmd.link_dylib(&lib.name.as_str()),\n+            NativeLibraryKind::NativeFramework => cmd.link_framework(&lib.name.as_str()),\n             NativeLibraryKind::NativeStatic => bug!(),\n         }\n     }\n@@ -1185,8 +1186,8 @@ fn add_upstream_native_libraries(cmd: &mut Linker, sess: &Session) {\n                 continue\n             }\n             match lib.kind {\n-                NativeLibraryKind::NativeUnknown => cmd.link_dylib(&lib.name),\n-                NativeLibraryKind::NativeFramework => cmd.link_framework(&lib.name),\n+                NativeLibraryKind::NativeUnknown => cmd.link_dylib(&lib.name.as_str()),\n+                NativeLibraryKind::NativeFramework => cmd.link_framework(&lib.name.as_str()),\n \n                 // ignore statically included native libraries here as we've\n                 // already included them when we included the rust library"}, {"sha": "ff40cfda5ff7cb7a865622a3f8c6c69431e068c9", "filename": "src/librustc_trans/back/symbol_names.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibrustc_trans%2Fback%2Fsymbol_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibrustc_trans%2Fback%2Fsymbol_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fsymbol_names.rs?ref=ebec55406ba94faf8b2cd23b27a8f74df97d1ca4", "patch": "@@ -113,7 +113,7 @@ use rustc::hir::map::definitions::{DefPath, DefPathData};\n use rustc::util::common::record_time;\n \n use syntax::attr;\n-use syntax::parse::token::{self, InternedString};\n+use syntax::symbol::{Symbol, InternedString};\n \n fn get_symbol_hash<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n \n@@ -275,7 +275,7 @@ impl ItemPathBuffer for SymbolPathBuffer {\n     }\n \n     fn push(&mut self, text: &str) {\n-        self.names.push(token::intern(text).as_str());\n+        self.names.push(Symbol::intern(text).as_str());\n     }\n }\n \n@@ -288,7 +288,7 @@ pub fn exported_name_from_type_and_prefix<'a, 'tcx>(scx: &SharedCrateContext<'a,\n         krate: LOCAL_CRATE,\n     };\n     let hash = get_symbol_hash(scx, &empty_def_path, t, None);\n-    let path = [token::intern_and_get_ident(prefix)];\n+    let path = [Symbol::intern(prefix).as_str()];\n     mangle(path.iter().cloned(), &hash)\n }\n "}, {"sha": "78a676d30337c1e113c440ffc0ad6d1a8cdb8114", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=ebec55406ba94faf8b2cd23b27a8f74df97d1ca4", "patch": "@@ -1128,11 +1128,11 @@ pub fn set_link_section(ccx: &CrateContext,\n                         llval: ValueRef,\n                         attrs: &[ast::Attribute]) {\n     if let Some(sect) = attr::first_attr_value_str_by_name(attrs, \"link_section\") {\n-        if contains_null(&sect) {\n+        if contains_null(&sect.as_str()) {\n             ccx.sess().fatal(&format!(\"Illegal null byte in link_section value: `{}`\", &sect));\n         }\n         unsafe {\n-            let buf = CString::new(sect.as_bytes()).unwrap();\n+            let buf = CString::new(sect.as_str().as_bytes()).unwrap();\n             llvm::LLVMSetSection(llval, buf.as_ptr());\n         }\n     }"}, {"sha": "5c7b004375ed4b778aacf20c16d945633d061b8a", "filename": "src/librustc_trans/collector.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibrustc_trans%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibrustc_trans%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcollector.rs?ref=ebec55406ba94faf8b2cd23b27a8f74df97d1ca4", "patch": "@@ -663,7 +663,7 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n                                                 -> bool {\n             (bare_fn_ty.abi == Abi::RustIntrinsic ||\n              bare_fn_ty.abi == Abi::PlatformIntrinsic) &&\n-            tcx.item_name(def_id).as_str() == \"drop_in_place\"\n+            tcx.item_name(def_id) == \"drop_in_place\"\n         }\n     }\n }"}, {"sha": "29925d964da253d4b7a26ae008b72575bbf920a1", "filename": "src/librustc_trans/common.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibrustc_trans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibrustc_trans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcommon.rs?ref=ebec55406ba94faf8b2cd23b27a8f74df97d1ca4", "patch": "@@ -52,8 +52,7 @@ use std::ffi::CString;\n use std::cell::{Cell, RefCell, Ref};\n \n use syntax::ast;\n-use syntax::parse::token::InternedString;\n-use syntax::parse::token;\n+use syntax::symbol::{Symbol, InternedString};\n use syntax_pos::{DUMMY_SP, Span};\n \n pub use context::{CrateContext, SharedCrateContext};\n@@ -225,7 +224,7 @@ impl<'a, 'tcx> VariantInfo<'tcx> {\n                 VariantInfo {\n                     discr: Disr(0),\n                     fields: v.iter().enumerate().map(|(i, &t)| {\n-                        Field(token::intern(&i.to_string()), t)\n+                        Field(Symbol::intern(&i.to_string()), t)\n                     }).collect()\n                 }\n             }"}, {"sha": "4186721c122acdd839829c26b40c153f652e950b", "filename": "src/librustc_trans/consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibrustc_trans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibrustc_trans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fconsts.rs?ref=ebec55406ba94faf8b2cd23b27a8f74df97d1ca4", "patch": "@@ -123,7 +123,7 @@ pub fn get_static(ccx: &CrateContext, def_id: DefId) -> ValueRef {\n                     // extern \"C\" fn() from being non-null, so we can't just declare a\n                     // static and call it a day. Some linkages (like weak) will make it such\n                     // that the static actually has a null value.\n-                    let linkage = match base::llvm_linkage_by_name(&name) {\n+                    let linkage = match base::llvm_linkage_by_name(&name.as_str()) {\n                         Some(linkage) => linkage,\n                         None => {\n                             ccx.sess().span_fatal(span, \"invalid linkage specified\");"}, {"sha": "771c5ef6d9d28c019b45bdecc93be31b3d8293ad", "filename": "src/librustc_trans/context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibrustc_trans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibrustc_trans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcontext.rs?ref=ebec55406ba94faf8b2cd23b27a8f74df97d1ca4", "patch": "@@ -42,7 +42,7 @@ use std::ptr;\n use std::rc::Rc;\n use std::str;\n use syntax::ast;\n-use syntax::parse::token::InternedString;\n+use syntax::symbol::InternedString;\n use abi::FnType;\n \n pub struct Stats {"}, {"sha": "5d01ca892b316c4c9849cacafb0c79f84e0937f1", "filename": "src/librustc_trans/debuginfo/metadata.rs", "status": "modified", "additions": 17, "deletions": 29, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs?ref=ebec55406ba94faf8b2cd23b27a8f74df97d1ca4", "patch": "@@ -44,10 +44,8 @@ use std::ffi::CString;\n use std::fmt::Write;\n use std::path::Path;\n use std::ptr;\n-use std::rc::Rc;\n-use syntax::util::interner::Interner;\n use syntax::ast;\n-use syntax::parse::token;\n+use syntax::symbol::{Interner, InternedString};\n use syntax_pos::{self, Span};\n \n \n@@ -117,9 +115,8 @@ impl<'tcx> TypeMap<'tcx> {\n                                         unique_type_id: UniqueTypeId,\n                                         metadata: DIType) {\n         if self.unique_id_to_metadata.insert(unique_type_id, metadata).is_some() {\n-            let unique_type_id_str = self.get_unique_type_id_as_string(unique_type_id);\n             bug!(\"Type metadata for unique id '{}' is already in the TypeMap!\",\n-                 &unique_type_id_str[..]);\n+                 self.get_unique_type_id_as_string(unique_type_id));\n         }\n     }\n \n@@ -133,7 +130,7 @@ impl<'tcx> TypeMap<'tcx> {\n \n     // Get the string representation of a UniqueTypeId. This method will fail if\n     // the id is unknown.\n-    fn get_unique_type_id_as_string(&self, unique_type_id: UniqueTypeId) -> Rc<str> {\n+    fn get_unique_type_id_as_string(&self, unique_type_id: UniqueTypeId) -> &str {\n         let UniqueTypeId(interner_key) = unique_type_id;\n         self.unique_id_interner.get(interner_key)\n     }\n@@ -182,7 +179,7 @@ impl<'tcx> TypeMap<'tcx> {\n                                               -> UniqueTypeId {\n         let enum_type_id = self.get_unique_type_id_of_type(cx, enum_type);\n         let enum_variant_type_id = format!(\"{}::{}\",\n-                                           &self.get_unique_type_id_as_string(enum_type_id),\n+                                           self.get_unique_type_id_as_string(enum_type_id),\n                                            variant_name);\n         let interner_key = self.unique_id_interner.intern(&enum_variant_type_id);\n         UniqueTypeId(interner_key)\n@@ -623,29 +620,25 @@ pub fn type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             let metadata_for_uid = match type_map.find_metadata_for_unique_id(unique_type_id) {\n                 Some(metadata) => metadata,\n                 None => {\n-                    let unique_type_id_str =\n-                        type_map.get_unique_type_id_as_string(unique_type_id);\n                     span_bug!(usage_site_span,\n                               \"Expected type metadata for unique \\\n                                type id '{}' to already be in \\\n                                the debuginfo::TypeMap but it \\\n                                was not. (Ty = {})\",\n-                              &unique_type_id_str[..],\n+                              type_map.get_unique_type_id_as_string(unique_type_id),\n                               t);\n                 }\n             };\n \n             match type_map.find_metadata_for_type(t) {\n                 Some(metadata) => {\n                     if metadata != metadata_for_uid {\n-                        let unique_type_id_str =\n-                            type_map.get_unique_type_id_as_string(unique_type_id);\n                         span_bug!(usage_site_span,\n                                   \"Mismatch between Ty and \\\n                                    UniqueTypeId maps in \\\n                                    debuginfo::TypeMap. \\\n                                    UniqueTypeId={}, Ty={}\",\n-                                  &unique_type_id_str[..],\n+                                  type_map.get_unique_type_id_as_string(unique_type_id),\n                                   t);\n                     }\n                 }\n@@ -809,7 +802,7 @@ pub fn compile_unit_metadata(scc: &SharedCrateContext,\n     };\n \n     fn fallback_path(scc: &SharedCrateContext) -> CString {\n-        CString::new(scc.link_meta().crate_name.clone()).unwrap()\n+        CString::new(scc.link_meta().crate_name.to_string()).unwrap()\n     }\n }\n \n@@ -1526,13 +1519,10 @@ fn prepare_enum_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     let enum_llvm_type = type_of::type_of(cx, enum_type);\n     let (enum_type_size, enum_type_align) = size_and_align_of(cx, enum_llvm_type);\n \n-    let unique_type_id_str = debug_context(cx)\n-                             .type_map\n-                             .borrow()\n-                             .get_unique_type_id_as_string(unique_type_id);\n-\n     let enum_name = CString::new(enum_name).unwrap();\n-    let unique_type_id_str = CString::new(unique_type_id_str.as_bytes()).unwrap();\n+    let unique_type_id_str = CString::new(\n+        debug_context(cx).type_map.borrow().get_unique_type_id_as_string(unique_type_id).as_bytes()\n+    ).unwrap();\n     let enum_metadata = unsafe {\n         llvm::LLVMRustDIBuilderCreateUnionType(\n         DIB(cx),\n@@ -1566,7 +1556,7 @@ fn prepare_enum_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n \n     fn get_enum_discriminant_name(cx: &CrateContext,\n                                   def_id: DefId)\n-                                  -> token::InternedString {\n+                                  -> InternedString {\n         cx.tcx().item_name(def_id).as_str()\n     }\n }\n@@ -1669,11 +1659,10 @@ fn create_struct_stub(cx: &CrateContext,\n                    -> DICompositeType {\n     let (struct_size, struct_align) = size_and_align_of(cx, struct_llvm_type);\n \n-    let unique_type_id_str = debug_context(cx).type_map\n-                                              .borrow()\n-                                              .get_unique_type_id_as_string(unique_type_id);\n     let name = CString::new(struct_type_name).unwrap();\n-    let unique_type_id = CString::new(unique_type_id_str.as_bytes()).unwrap();\n+    let unique_type_id = CString::new(\n+        debug_context(cx).type_map.borrow().get_unique_type_id_as_string(unique_type_id).as_bytes()\n+    ).unwrap();\n     let metadata_stub = unsafe {\n         // LLVMRustDIBuilderCreateStructType() wants an empty array. A null\n         // pointer will lead to hard to trace and debug LLVM assertions\n@@ -1707,11 +1696,10 @@ fn create_union_stub(cx: &CrateContext,\n                    -> DICompositeType {\n     let (union_size, union_align) = size_and_align_of(cx, union_llvm_type);\n \n-    let unique_type_id_str = debug_context(cx).type_map\n-                                              .borrow()\n-                                              .get_unique_type_id_as_string(unique_type_id);\n     let name = CString::new(union_type_name).unwrap();\n-    let unique_type_id = CString::new(unique_type_id_str.as_bytes()).unwrap();\n+    let unique_type_id = CString::new(\n+        debug_context(cx).type_map.borrow().get_unique_type_id_as_string(unique_type_id).as_bytes()\n+    ).unwrap();\n     let metadata_stub = unsafe {\n         // LLVMRustDIBuilderCreateUnionType() wants an empty array. A null\n         // pointer will lead to hard to trace and debug LLVM assertions"}, {"sha": "a0477c9fc1eee2ea93c9759edad86b4d0750e341", "filename": "src/librustc_trans/debuginfo/namespace.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibrustc_trans%2Fdebuginfo%2Fnamespace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibrustc_trans%2Fdebuginfo%2Fnamespace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fnamespace.rs?ref=ebec55406ba94faf8b2cd23b27a8f74df97d1ca4", "patch": "@@ -35,7 +35,7 @@ pub fn mangled_name_of_item(ccx: &CrateContext, def_id: DefId, extra: &str) -> S\n         }\n \n         let name = match def_key.disambiguated_data.data {\n-            DefPathData::CrateRoot => ccx.tcx().crate_name(def_id.krate),\n+            DefPathData::CrateRoot => ccx.tcx().crate_name(def_id.krate).as_str(),\n             data => data.as_interned_str()\n         };\n \n@@ -64,7 +64,7 @@ pub fn item_namespace(ccx: &CrateContext, def_id: DefId) -> DIScope {\n     });\n \n     let namespace_name = match def_key.disambiguated_data.data {\n-        DefPathData::CrateRoot => ccx.tcx().crate_name(def_id.krate),\n+        DefPathData::CrateRoot => ccx.tcx().crate_name(def_id.krate).as_str(),\n         data => data.as_interned_str()\n     };\n "}, {"sha": "fce1ce561055507c42a5d15d04785122232c0090", "filename": "src/librustc_trans/debuginfo/type_names.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibrustc_trans%2Fdebuginfo%2Ftype_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibrustc_trans%2Fdebuginfo%2Ftype_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Ftype_names.rs?ref=ebec55406ba94faf8b2cd23b27a8f74df97d1ca4", "patch": "@@ -156,7 +156,7 @@ pub fn push_debuginfo_type_name<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                       qualified: bool,\n                       output: &mut String) {\n         if qualified {\n-            output.push_str(&cx.tcx().crate_name(def_id.krate));\n+            output.push_str(&cx.tcx().crate_name(def_id.krate).as_str());\n             for path_element in cx.tcx().def_path(def_id).data {\n                 output.push_str(\"::\");\n                 output.push_str(&path_element.data.as_interned_str());"}, {"sha": "016a76a72531b4c783292281927e621e605029c4", "filename": "src/librustc_trans/intrinsic.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibrustc_trans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibrustc_trans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fintrinsic.rs?ref=ebec55406ba94faf8b2cd23b27a8f74df97d1ca4", "patch": "@@ -30,7 +30,7 @@ use rustc::ty::{self, Ty};\n use Disr;\n use rustc::hir;\n use syntax::ast;\n-use syntax::parse::token;\n+use syntax::symbol::Symbol;\n \n use rustc::session::Session;\n use syntax_pos::{Span, DUMMY_SP};\n@@ -107,7 +107,7 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n     let sig = tcx.erase_late_bound_regions_and_normalize(&fty.sig);\n     let arg_tys = sig.inputs;\n     let ret_ty = sig.output;\n-    let name = tcx.item_name(def_id).as_str();\n+    let name = &*tcx.item_name(def_id).as_str();\n \n     let span = match call_debug_location {\n         DebugLoc::ScopeAt(_, span) => span,\n@@ -123,15 +123,15 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n         Call(bcx, llfn, &[], call_debug_location);\n         Unreachable(bcx);\n         return Result::new(bcx, C_undef(Type::nil(ccx).ptr_to()));\n-    } else if &name[..] == \"unreachable\" {\n+    } else if name == \"unreachable\" {\n         Unreachable(bcx);\n         return Result::new(bcx, C_nil(ccx));\n     }\n \n     let llret_ty = type_of::type_of(ccx, ret_ty);\n \n-    let simple = get_simple_intrinsic(ccx, &name);\n-    let llval = match (simple, &name[..]) {\n+    let simple = get_simple_intrinsic(ccx, name);\n+    let llval = match (simple, name) {\n         (Some(llfn), _) => {\n             Call(bcx, llfn, &llargs, call_debug_location)\n         }\n@@ -208,7 +208,7 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n         }\n         (_, \"type_name\") => {\n             let tp_ty = substs.type_at(0);\n-            let ty_name = token::intern_and_get_ident(&tp_ty.to_string());\n+            let ty_name = Symbol::intern(&tp_ty.to_string()).as_str();\n             C_str_slice(ccx, ty_name)\n         }\n         (_, \"type_id\") => {\n@@ -340,7 +340,7 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n             let sty = &arg_tys[0].sty;\n             match int_type_width_signed(sty, ccx) {\n                 Some((width, signed)) =>\n-                    match &*name {\n+                    match name {\n                         \"ctlz\" => count_zeros_intrinsic(bcx, &format!(\"llvm.ctlz.i{}\", width),\n                                                         llargs[0], call_debug_location),\n                         \"cttz\" => count_zeros_intrinsic(bcx, &format!(\"llvm.cttz.i{}\", width),\n@@ -394,7 +394,7 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n             let sty = &arg_tys[0].sty;\n             match float_type_width(sty) {\n                 Some(_width) =>\n-                    match &*name {\n+                    match name {\n                         \"fadd_fast\" => FAddFast(bcx, llargs[0], llargs[1], call_debug_location),\n                         \"fsub_fast\" => FSubFast(bcx, llargs[0], llargs[1], call_debug_location),\n                         \"fmul_fast\" => FMulFast(bcx, llargs[0], llargs[1], call_debug_location),"}, {"sha": "29e6f6af416bcead29174057122ef460d6c69b38", "filename": "src/librustc_trans/mir/block.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fblock.rs?ref=ebec55406ba94faf8b2cd23b27a8f74df97d1ca4", "patch": "@@ -30,7 +30,7 @@ use glue;\n use type_::Type;\n \n use rustc_data_structures::fx::FxHashMap;\n-use syntax::parse::token;\n+use syntax::symbol::Symbol;\n \n use super::{MirContext, LocalRef};\n use super::analyze::CleanupKind;\n@@ -324,7 +324,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n \n                 // Get the location information.\n                 let loc = bcx.sess().codemap().lookup_char_pos(span.lo);\n-                let filename = token::intern_and_get_ident(&loc.file.name);\n+                let filename = Symbol::intern(&loc.file.name).as_str();\n                 let filename = C_str_slice(bcx.ccx(), filename);\n                 let line = C_u32(bcx.ccx(), loc.line as u32);\n \n@@ -354,7 +354,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                          const_err)\n                     }\n                     mir::AssertMessage::Math(ref err) => {\n-                        let msg_str = token::intern_and_get_ident(err.description());\n+                        let msg_str = Symbol::intern(err.description()).as_str();\n                         let msg_str = C_str_slice(bcx.ccx(), msg_str);\n                         let msg_file_line = C_struct(bcx.ccx(),\n                                                      &[msg_str, filename, line],"}, {"sha": "12cbfcef7d26b17cc50f2a699cfac7c55da2bc6a", "filename": "src/librustc_trans/mir/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fmod.rs?ref=ebec55406ba94faf8b2cd23b27a8f74df97d1ca4", "patch": "@@ -21,7 +21,7 @@ use machine;\n use type_of;\n \n use syntax_pos::{DUMMY_SP, NO_EXPANSION, COMMAND_LINE_EXPN, BytePos};\n-use syntax::parse::token::keywords;\n+use syntax::symbol::keywords;\n \n use std::cell::Ref;\n use std::iter;"}, {"sha": "a36960993e47148a13d4d2aefabda75038cd61ae", "filename": "src/librustc_trans/partitioning.rs", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibrustc_trans%2Fpartitioning.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibrustc_trans%2Fpartitioning.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fpartitioning.rs?ref=ebec55406ba94faf8b2cd23b27a8f74df97d1ca4", "patch": "@@ -132,7 +132,7 @@ use std::sync::Arc;\n use std::collections::hash_map::DefaultHasher;\n use symbol_map::SymbolMap;\n use syntax::ast::NodeId;\n-use syntax::parse::token::{self, InternedString};\n+use syntax::symbol::{Symbol, InternedString};\n use trans_item::TransItem;\n use util::nodemap::{FxHashMap, FxHashSet};\n \n@@ -272,7 +272,7 @@ pub fn partition<'a, 'tcx, I>(scx: &SharedCrateContext<'a, 'tcx>,\n     // If the partitioning should produce a fixed count of codegen units, merge\n     // until that count is reached.\n     if let PartitioningStrategy::FixedUnitCount(count) = strategy {\n-        merge_codegen_units(&mut initial_partitioning, count, &tcx.crate_name[..]);\n+        merge_codegen_units(&mut initial_partitioning, count, &tcx.crate_name.as_str());\n \n         debug_dump(scx, \"POST MERGING:\", initial_partitioning.codegen_units.iter());\n     }\n@@ -320,7 +320,7 @@ fn place_root_translation_items<'a, 'tcx, I>(scx: &SharedCrateContext<'a, 'tcx>,\n \n             let codegen_unit_name = match characteristic_def_id {\n                 Some(def_id) => compute_codegen_unit_name(tcx, def_id, is_volatile),\n-                None => InternedString::new(FALLBACK_CODEGEN_UNIT),\n+                None => Symbol::intern(FALLBACK_CODEGEN_UNIT).as_str(),\n             };\n \n             let make_codegen_unit = || {\n@@ -365,7 +365,7 @@ fn place_root_translation_items<'a, 'tcx, I>(scx: &SharedCrateContext<'a, 'tcx>,\n     // always ensure we have at least one CGU; otherwise, if we have a\n     // crate with just types (for example), we could wind up with no CGU\n     if codegen_units.is_empty() {\n-        let codegen_unit_name = InternedString::new(FALLBACK_CODEGEN_UNIT);\n+        let codegen_unit_name = Symbol::intern(FALLBACK_CODEGEN_UNIT).as_str();\n         codegen_units.entry(codegen_unit_name.clone())\n                      .or_insert_with(|| CodegenUnit::empty(codegen_unit_name.clone()));\n     }\n@@ -523,7 +523,7 @@ fn compute_codegen_unit_name<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let mut mod_path = String::with_capacity(64);\n \n     let def_path = tcx.def_path(def_id);\n-    mod_path.push_str(&tcx.crate_name(def_path.krate));\n+    mod_path.push_str(&tcx.crate_name(def_path.krate).as_str());\n \n     for part in tcx.def_path(def_id)\n                    .data\n@@ -542,14 +542,11 @@ fn compute_codegen_unit_name<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         mod_path.push_str(\".volatile\");\n     }\n \n-    return token::intern_and_get_ident(&mod_path[..]);\n+    return Symbol::intern(&mod_path[..]).as_str();\n }\n \n fn numbered_codegen_unit_name(crate_name: &str, index: usize) -> InternedString {\n-    token::intern_and_get_ident(&format!(\"{}{}{}\",\n-        crate_name,\n-        NUMBERED_CODEGEN_UNIT_MARKER,\n-        index)[..])\n+    Symbol::intern(&format!(\"{}{}{}\", crate_name, NUMBERED_CODEGEN_UNIT_MARKER, index)).as_str()\n }\n \n fn debug_dump<'a, 'b, 'tcx, I>(scx: &SharedCrateContext<'a, 'tcx>,"}, {"sha": "f2d1e375793b3bf08754e9ef77143764cfb1418e", "filename": "src/librustc_trans/trans_item.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibrustc_trans%2Ftrans_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibrustc_trans%2Ftrans_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans_item.rs?ref=ebec55406ba94faf8b2cd23b27a8f74df97d1ca4", "patch": "@@ -285,7 +285,7 @@ impl<'a, 'tcx> TransItem<'tcx> {\n \n         let attributes = tcx.get_attrs(def_id);\n         if let Some(name) = attr::first_attr_value_str_by_name(&attributes, \"linkage\") {\n-            if let Some(linkage) = base::llvm_linkage_by_name(&name) {\n+            if let Some(linkage) = base::llvm_linkage_by_name(&name.as_str()) {\n                 Some(linkage)\n             } else {\n                 let span = tcx.map.span_if_local(def_id);\n@@ -531,7 +531,7 @@ impl<'a, 'tcx> DefPathBasedNames<'a, 'tcx> {\n \n         // some_crate::\n         if !(self.omit_local_crate_name && def_id.is_local()) {\n-            output.push_str(&self.tcx.crate_name(def_path.krate));\n+            output.push_str(&self.tcx.crate_name(def_path.krate).as_str());\n             output.push_str(\"::\");\n         }\n "}, {"sha": "c5db8bc8cedc769d152913c6f8edc05d4348dbb5", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=ebec55406ba94faf8b2cd23b27a8f74df97d1ca4", "patch": "@@ -71,7 +71,7 @@ use util::nodemap::{NodeMap, FxHashSet};\n use std::cell::RefCell;\n use syntax::{abi, ast};\n use syntax::feature_gate::{GateIssue, emit_feature_err};\n-use syntax::parse::token::{self, keywords};\n+use syntax::symbol::{Symbol, keywords};\n use syntax_pos::{Span, Pos};\n use errors::DiagnosticBuilder;\n \n@@ -645,7 +645,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         };\n \n         let output_binding = ConvertedBinding {\n-            item_name: token::intern(FN_OUTPUT_NAME),\n+            item_name: Symbol::intern(FN_OUTPUT_NAME),\n             ty: output,\n             span: output_span\n         };\n@@ -1252,7 +1252,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         if bounds.len() > 1 {\n             let spans = bounds.iter().map(|b| {\n                 self.tcx().associated_items(b.def_id()).find(|item| {\n-                    item.kind == ty::AssociatedKind::Type && item.name.as_str() == assoc_name\n+                    item.kind == ty::AssociatedKind::Type && item.name == assoc_name\n                 })\n                 .and_then(|item| self.tcx().map.as_local_node_id(item.def_id))\n                 .and_then(|node_id| self.tcx().map.opt_span(node_id))"}, {"sha": "e72dba858c562160dbc42da65d4a53cc8f60109e", "filename": "src/librustc_typeck/check/autoderef.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs?ref=ebec55406ba94faf8b2cd23b27a8f74df97d1ca4", "patch": "@@ -20,7 +20,7 @@ use rustc::ty::{LvaluePreference, NoPreference, PreferMutLvalue};\n use rustc::hir;\n \n use syntax_pos::Span;\n-use syntax::parse::token;\n+use syntax::symbol::Symbol;\n \n #[derive(Copy, Clone, Debug)]\n enum AutoderefKind {\n@@ -120,7 +120,7 @@ impl<'a, 'gcx, 'tcx> Autoderef<'a, 'gcx, 'tcx> {\n         let normalized = traits::normalize_projection_type(&mut selcx,\n                                                            ty::ProjectionTy {\n                                                                trait_ref: trait_ref,\n-                                                               item_name: token::intern(\"Target\"),\n+                                                               item_name: Symbol::intern(\"Target\"),\n                                                            },\n                                                            cause,\n                                                            0);\n@@ -198,7 +198,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             (PreferMutLvalue, Some(trait_did)) => {\n                 self.lookup_method_in_trait(span,\n                                             base_expr,\n-                                            token::intern(\"deref_mut\"),\n+                                            Symbol::intern(\"deref_mut\"),\n                                             trait_did,\n                                             base_ty,\n                                             None)\n@@ -211,7 +211,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             (None, Some(trait_did)) => {\n                 self.lookup_method_in_trait(span,\n                                             base_expr,\n-                                            token::intern(\"deref\"),\n+                                            Symbol::intern(\"deref\"),\n                                             trait_did,\n                                             base_ty,\n                                             None)"}, {"sha": "548f37cea06bcf9a2415c62a3533e4d091804b4c", "filename": "src/librustc_typeck/check/callee.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs?ref=ebec55406ba94faf8b2cd23b27a8f74df97d1ca4", "patch": "@@ -16,7 +16,7 @@ use hir::def_id::{DefId, LOCAL_CRATE};\n use hir::print;\n use rustc::{infer, traits};\n use rustc::ty::{self, LvaluePreference, Ty};\n-use syntax::parse::token;\n+use syntax::symbol::Symbol;\n use syntax::ptr::P;\n use syntax_pos::Span;\n \n@@ -160,9 +160,9 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                   -> Option<ty::MethodCallee<'tcx>> {\n         // Try the options that are least restrictive on the caller first.\n         for &(opt_trait_def_id, method_name) in\n-            &[(self.tcx.lang_items.fn_trait(), token::intern(\"call\")),\n-              (self.tcx.lang_items.fn_mut_trait(), token::intern(\"call_mut\")),\n-              (self.tcx.lang_items.fn_once_trait(), token::intern(\"call_once\"))] {\n+            &[(self.tcx.lang_items.fn_trait(), Symbol::intern(\"call\")),\n+              (self.tcx.lang_items.fn_mut_trait(), Symbol::intern(\"call_mut\")),\n+              (self.tcx.lang_items.fn_once_trait(), Symbol::intern(\"call_once\"))] {\n             let trait_def_id = match opt_trait_def_id {\n                 Some(def_id) => def_id,\n                 None => continue,"}, {"sha": "a07573a7b9eab08c9578f7bfa36d835b412dc060", "filename": "src/librustc_typeck/check/intrinsic.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs?ref=ebec55406ba94faf8b2cd23b27a8f74df97d1ca4", "patch": "@@ -21,7 +21,7 @@ use {CrateCtxt, require_same_types};\n \n use syntax::abi::Abi;\n use syntax::ast;\n-use syntax::parse::token;\n+use syntax::symbol::Symbol;\n use syntax_pos::Span;\n \n use rustc::hir;\n@@ -75,7 +75,7 @@ fn equate_intrinsic_type<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n /// and in libcore/intrinsics.rs\n pub fn check_intrinsic_type(ccx: &CrateCtxt, it: &hir::ForeignItem) {\n     fn param<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>, n: u32) -> Ty<'tcx> {\n-        let name = token::intern(&format!(\"P{}\", n));\n+        let name = Symbol::intern(&format!(\"P{}\", n));\n         ccx.tcx.mk_param(n, name)\n     }\n \n@@ -326,7 +326,7 @@ pub fn check_intrinsic_type(ccx: &CrateCtxt, it: &hir::ForeignItem) {\n pub fn check_platform_intrinsic_type(ccx: &CrateCtxt,\n                                      it: &hir::ForeignItem) {\n     let param = |n| {\n-        let name = token::intern(&format!(\"P{}\", n));\n+        let name = Symbol::intern(&format!(\"P{}\", n));\n         ccx.tcx.mk_param(n, name)\n     };\n "}, {"sha": "bd34e993e1e86a984a65e413a19e57a2a8d6b6e6", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=ebec55406ba94faf8b2cd23b27a8f74df97d1ca4", "patch": "@@ -342,7 +342,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         let def = pick.item.def();\n         if let probe::InherentImplPick = pick.kind {\n             if !pick.item.vis.is_accessible_from(self.body_id, &self.tcx.map) {\n-                let msg = format!(\"{} `{}` is private\", def.kind_name(), &method_name.as_str());\n+                let msg = format!(\"{} `{}` is private\", def.kind_name(), method_name);\n                 self.tcx.sess.span_err(span, &msg);\n             }\n         }"}, {"sha": "734aa99dbeafafb99582f6880c72fae5b63f0b22", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=ebec55406ba94faf8b2cd23b27a8f74df97d1ca4", "patch": "@@ -115,8 +115,8 @@ use syntax::ast;\n use syntax::attr;\n use syntax::codemap::{self, original_sp, Spanned};\n use syntax::feature_gate::{GateIssue, emit_feature_err};\n-use syntax::parse::token::{self, InternedString, keywords};\n use syntax::ptr::P;\n+use syntax::symbol::{Symbol, InternedString, keywords};\n use syntax::util::lev_distance::find_best_match_for_name;\n use syntax_pos::{self, BytePos, Span};\n \n@@ -931,7 +931,8 @@ fn check_on_unimplemented<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     if let Some(ref attr) = item.attrs.iter().find(|a| {\n         a.check_name(\"rustc_on_unimplemented\")\n     }) {\n-        if let Some(ref istring) = attr.value_str() {\n+        if let Some(istring) = attr.value_str() {\n+            let istring = istring.as_str();\n             let parser = Parser::new(&istring);\n             let types = &generics.types;\n             for token in parser {\n@@ -942,7 +943,7 @@ fn check_on_unimplemented<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                         Position::ArgumentNamed(s) if s == \"Self\" => (),\n                         // So is `{A}` if A is a type parameter\n                         Position::ArgumentNamed(s) => match types.iter().find(|t| {\n-                            t.name.as_str() == s\n+                            t.name == s\n                         }) {\n                             Some(_) => (),\n                             None => {\n@@ -2369,7 +2370,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             (PreferMutLvalue, Some(trait_did)) => {\n                 self.lookup_method_in_trait_adjusted(expr.span,\n                                                      Some(&base_expr),\n-                                                     token::intern(\"index_mut\"),\n+                                                     Symbol::intern(\"index_mut\"),\n                                                      trait_did,\n                                                      autoderefs,\n                                                      unsize,\n@@ -2384,7 +2385,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             (None, Some(trait_did)) => {\n                 self.lookup_method_in_trait_adjusted(expr.span,\n                                                      Some(&base_expr),\n-                                                     token::intern(\"index\"),\n+                                                     Symbol::intern(\"index\"),\n                                                      trait_did,\n                                                      autoderefs,\n                                                      unsize,\n@@ -3027,7 +3028,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     fn suggest_field_name(variant: ty::VariantDef<'tcx>,\n                           field: &Spanned<ast::Name>,\n                           skip : Vec<InternedString>)\n-                          -> Option<InternedString> {\n+                          -> Option<Symbol> {\n         let name = field.node.as_str();\n         let names = variant.fields.iter().filter_map(|field| {\n             // ignore already set fields and private fields from non-local crates\n@@ -3126,7 +3127,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 ty::TyAdt(adt, ..) if adt.is_enum() => {\n                     struct_span_err!(self.tcx.sess, field.name.span, E0559,\n                                     \"{} `{}::{}` has no field named `{}`\",\n-                                    kind_name, actual, variant.name.as_str(), field.name.node)\n+                                    kind_name, actual, variant.name, field.name.node)\n                 }\n                 _ => {\n                     struct_span_err!(self.tcx.sess, field.name.span, E0560,\n@@ -3146,7 +3147,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             match ty.sty {\n                 ty::TyAdt(adt, ..) if adt.is_enum() => {\n                     err.span_label(field.name.span, &format!(\"`{}::{}` does not have this field\",\n-                                                             ty, variant.name.as_str()));\n+                                                             ty, variant.name));\n                 }\n                 _ => {\n                     err.span_label(field.name.span, &format!(\"`{}` does not have this field\", ty));"}, {"sha": "adb8c6be42bc1ed6ed861e1e00b3c44938491f7b", "filename": "src/librustc_typeck/check/op.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fop.rs?ref=ebec55406ba94faf8b2cd23b27a8f74df97d1ca4", "patch": "@@ -14,7 +14,7 @@ use super::FnCtxt;\n use hir::def_id::DefId;\n use rustc::ty::{Ty, TypeFoldable, PreferMutLvalue};\n use syntax::ast;\n-use syntax::parse::token;\n+use syntax::symbol::Symbol;\n use rustc::hir;\n \n impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n@@ -182,7 +182,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         let rhs_ty_var = self.next_ty_var();\n \n         let return_ty = match self.lookup_op_method(expr, lhs_ty, vec![rhs_ty_var],\n-                                                    token::intern(name), trait_def_id,\n+                                                    Symbol::intern(name), trait_def_id,\n                                                     lhs_expr) {\n             Ok(return_ty) => return_ty,\n             Err(()) => {\n@@ -248,9 +248,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                            -> Ty<'tcx>\n     {\n         assert!(op.is_by_value());\n-        match self.lookup_op_method(ex, operand_ty, vec![],\n-                                    token::intern(mname), trait_did,\n-                                    operand_expr) {\n+        let mname = Symbol::intern(mname);\n+        match self.lookup_op_method(ex, operand_ty, vec![], mname, trait_did, operand_expr) {\n             Ok(t) => t,\n             Err(()) => {\n                 self.type_error_message(ex.span, |actual| {"}, {"sha": "48d79a3ba4c87bb7b5fd932e0abbf7bb6f22d9ab", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=ebec55406ba94faf8b2cd23b27a8f74df97d1ca4", "patch": "@@ -79,7 +79,7 @@ use rustc_const_math::ConstInt;\n use std::cell::RefCell;\n \n use syntax::{abi, ast, attr};\n-use syntax::parse::token::{self, keywords};\n+use syntax::symbol::{Symbol, keywords};\n use syntax_pos::Span;\n \n use rustc::hir::{self, map as hir_map, print as pprust};\n@@ -585,7 +585,7 @@ fn convert_closure<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     let upvar_decls : Vec<_> = tcx.with_freevars(node_id, |fv| {\n         fv.iter().enumerate().map(|(i, _)| ty::TypeParameterDef {\n             index: (base_generics.count() as u32) + (i as u32),\n-            name: token::intern(\"<upvar>\"),\n+            name: Symbol::intern(\"<upvar>\"),\n             def_id: def_id,\n             default_def_id: base_def_id,\n             default: None,"}, {"sha": "2cc1882ce3eae3411adaf179d03132f1127d51af", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=ebec55406ba94faf8b2cd23b27a8f74df97d1ca4", "patch": "@@ -24,9 +24,9 @@ use syntax::abi::Abi;\n use syntax::ast;\n use syntax::attr;\n use syntax::codemap::Spanned;\n-use syntax::parse::token::keywords;\n use syntax::ptr::P;\n use syntax::print::pprust as syntax_pprust;\n+use syntax::symbol::keywords;\n use syntax_pos::{self, DUMMY_SP, Pos};\n \n use rustc_trans::back::link;\n@@ -242,7 +242,7 @@ impl Clean<ExternalCrate> for CrateNum {\n             }\n         });\n         ExternalCrate {\n-            name: (&cx.sess().cstore.crate_name(self.0)[..]).to_owned(),\n+            name: cx.sess().cstore.crate_name(self.0).to_string(),\n             attrs: cx.sess().cstore.item_attrs(root).clean(cx),\n             primitives: primitives,\n         }\n@@ -2577,7 +2577,7 @@ impl Clean<Vec<Item>> for doctree::Import {\n         // #[doc(no_inline)] attribute is present.\n         // Don't inline doc(hidden) imports so they can be stripped at a later stage.\n         let denied = self.vis != hir::Public || self.attrs.iter().any(|a| {\n-            &a.name()[..] == \"doc\" && match a.meta_item_list() {\n+            a.name() == \"doc\" && match a.meta_item_list() {\n                 Some(l) => attr::list_contains_name(l, \"no_inline\") ||\n                            attr::list_contains_name(l, \"hidden\"),\n                 None => false,"}, {"sha": "bb07efdd9e7231d161d085968b02dbf38e1c199b", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 33, "deletions": 84, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=ebec55406ba94faf8b2cd23b27a8f74df97d1ca4", "patch": "@@ -14,71 +14,43 @@ pub use self::TyParamBound::*;\n pub use self::UnsafeSource::*;\n pub use self::ViewPath_::*;\n pub use self::PathParameters::*;\n+pub use symbol::Symbol as Name;\n pub use util::ThinVec;\n \n use syntax_pos::{mk_sp, Span, DUMMY_SP, ExpnId};\n use codemap::{respan, Spanned};\n use abi::Abi;\n use ext::hygiene::SyntaxContext;\n-use parse::token::{self, keywords, InternedString};\n use print::pprust;\n use ptr::P;\n+use symbol::{Symbol, keywords};\n use tokenstream::{TokenTree};\n \n+use std::collections::HashSet;\n use std::fmt;\n use std::rc::Rc;\n use std::u32;\n \n use serialize::{self, Encodable, Decodable, Encoder, Decoder};\n \n-/// A name is a part of an identifier, representing a string or gensym. It's\n-/// the result of interning.\n-#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\n-pub struct Name(pub u32);\n-\n /// An identifier contains a Name (index into the interner\n /// table) and a SyntaxContext to track renaming and\n /// macro expansion per Flatt et al., \"Macros That Work Together\"\n #[derive(Clone, Copy, PartialEq, Eq, Hash)]\n pub struct Ident {\n-    pub name: Name,\n+    pub name: Symbol,\n     pub ctxt: SyntaxContext\n }\n \n-impl Name {\n-    pub fn as_str(self) -> token::InternedString {\n-        token::InternedString::new_from_name(self)\n-    }\n-}\n-\n-impl fmt::Debug for Name {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"{}({})\", self, self.0)\n-    }\n-}\n-\n-impl fmt::Display for Name {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        fmt::Display::fmt(&self.as_str(), f)\n-    }\n-}\n-\n-impl Encodable for Name {\n-    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n-        s.emit_str(&self.as_str())\n-    }\n-}\n-\n-impl Decodable for Name {\n-    fn decode<D: Decoder>(d: &mut D) -> Result<Name, D::Error> {\n-        Ok(token::intern(&d.read_str()?))\n-    }\n-}\n-\n impl Ident {\n     pub const fn with_empty_ctxt(name: Name) -> Ident {\n         Ident { name: name, ctxt: SyntaxContext::empty() }\n     }\n+\n+   /// Maps a string to an identifier with an empty syntax context.\n+   pub fn from_str(s: &str) -> Ident {\n+       Ident::with_empty_ctxt(Symbol::intern(s))\n+   }\n }\n \n impl fmt::Debug for Ident {\n@@ -401,7 +373,7 @@ impl Generics {\n     }\n     pub fn span_for_name(&self, name: &str) -> Option<Span> {\n         for t in &self.ty_params {\n-            if t.ident.name.as_str() == name {\n+            if t.ident.name == name {\n                 return Some(t.span);\n             }\n         }\n@@ -479,7 +451,7 @@ pub struct WhereEqPredicate {\n \n /// The set of MetaItems that define the compilation environment of the crate,\n /// used to drive conditional compilation\n-pub type CrateConfig = Vec<P<MetaItem>>;\n+pub type CrateConfig = HashSet<(Name, Option<Symbol>)>;\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct Crate {\n@@ -498,7 +470,7 @@ pub type NestedMetaItem = Spanned<NestedMetaItemKind>;\n #[derive(Clone, Eq, RustcEncodable, RustcDecodable, Hash, Debug, PartialEq)]\n pub enum NestedMetaItemKind {\n     /// A full MetaItem, for recursive meta items.\n-    MetaItem(P<MetaItem>),\n+    MetaItem(MetaItem),\n     /// A literal.\n     ///\n     /// E.g. \"foo\", 64, true\n@@ -508,53 +480,30 @@ pub enum NestedMetaItemKind {\n /// A spanned compile-time attribute item.\n ///\n /// E.g. `#[test]`, `#[derive(..)]` or `#[feature = \"foo\"]`\n-pub type MetaItem = Spanned<MetaItemKind>;\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+pub struct MetaItem {\n+    pub name: Name,\n+    pub node: MetaItemKind,\n+    pub span: Span,\n+}\n \n /// A compile-time attribute item.\n ///\n /// E.g. `#[test]`, `#[derive(..)]` or `#[feature = \"foo\"]`\n-#[derive(Clone, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub enum MetaItemKind {\n     /// Word meta item.\n     ///\n     /// E.g. `test` as in `#[test]`\n-    Word(InternedString),\n+    Word,\n     /// List meta item.\n     ///\n     /// E.g. `derive(..)` as in `#[derive(..)]`\n-    List(InternedString, Vec<NestedMetaItem>),\n+    List(Vec<NestedMetaItem>),\n     /// Name value meta item.\n     ///\n     /// E.g. `feature = \"foo\"` as in `#[feature = \"foo\"]`\n-    NameValue(InternedString, Lit),\n-}\n-\n-// can't be derived because the MetaItemKind::List requires an unordered comparison\n-impl PartialEq for MetaItemKind {\n-    fn eq(&self, other: &MetaItemKind) -> bool {\n-        use self::MetaItemKind::*;\n-        match *self {\n-            Word(ref ns) => match *other {\n-                Word(ref no) => (*ns) == (*no),\n-                _ => false\n-            },\n-            List(ref ns, ref miss) => match *other {\n-                List(ref no, ref miso) => {\n-                    ns == no &&\n-                        miss.iter().all(|mi| {\n-                            miso.iter().any(|x| x.node == mi.node)\n-                        })\n-                }\n-                _ => false\n-            },\n-            NameValue(ref ns, ref vs) => match *other {\n-                NameValue(ref no, ref vo) => {\n-                    (*ns) == (*no) && vs.node == vo.node\n-                }\n-                _ => false\n-            },\n-        }\n-    }\n+    NameValue(Lit)\n }\n \n /// A Block (`{ .. }`).\n@@ -1149,7 +1098,7 @@ pub enum LitIntType {\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub enum LitKind {\n     /// A string literal (`\"foo\"`)\n-    Str(InternedString, StrStyle),\n+    Str(Symbol, StrStyle),\n     /// A byte string (`b\"foo\"`)\n     ByteStr(Rc<Vec<u8>>),\n     /// A byte char (`b'f'`)\n@@ -1159,9 +1108,9 @@ pub enum LitKind {\n     /// An integer literal (`1`)\n     Int(u64, LitIntType),\n     /// A float literal (`1f64` or `1E10f64`)\n-    Float(InternedString, FloatTy),\n+    Float(Symbol, FloatTy),\n     /// A float literal without a suffix (`1.0 or 1.0E10`)\n-    FloatUnsuffixed(InternedString),\n+    FloatUnsuffixed(Symbol),\n     /// A boolean literal\n     Bool(bool),\n }\n@@ -1493,7 +1442,7 @@ pub enum AsmDialect {\n /// E.g. `\"={eax}\"(result)` as in `asm!(\"mov eax, 2\" : \"={eax}\"(result) : : : \"intel\")``\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct InlineAsmOutput {\n-    pub constraint: InternedString,\n+    pub constraint: Symbol,\n     pub expr: P<Expr>,\n     pub is_rw: bool,\n     pub is_indirect: bool,\n@@ -1504,11 +1453,11 @@ pub struct InlineAsmOutput {\n /// E.g. `asm!(\"NOP\");`\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct InlineAsm {\n-    pub asm: InternedString,\n+    pub asm: Symbol,\n     pub asm_str_style: StrStyle,\n     pub outputs: Vec<InlineAsmOutput>,\n-    pub inputs: Vec<(InternedString, P<Expr>)>,\n-    pub clobbers: Vec<InternedString>,\n+    pub inputs: Vec<(Symbol, P<Expr>)>,\n+    pub clobbers: Vec<Symbol>,\n     pub volatile: bool,\n     pub alignstack: bool,\n     pub dialect: AsmDialect,\n@@ -1755,8 +1704,6 @@ impl ViewPath_ {\n     }\n }\n \n-/// Meta-data associated with an item\n-pub type Attribute = Spanned<Attribute_>;\n \n /// Distinguishes between Attributes that decorate items and Attributes that\n /// are contained as statements within items. These two cases need to be\n@@ -1770,13 +1717,15 @@ pub enum AttrStyle {\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n pub struct AttrId(pub usize);\n \n+/// Meta-data associated with an item\n /// Doc-comments are promoted to attributes that have is_sugared_doc = true\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n-pub struct Attribute_ {\n+pub struct Attribute {\n     pub id: AttrId,\n     pub style: AttrStyle,\n-    pub value: P<MetaItem>,\n+    pub value: MetaItem,\n     pub is_sugared_doc: bool,\n+    pub span: Span,\n }\n \n /// TraitRef's appear in impls."}, {"sha": "45c120e0b95ca44daa6fc7445707efd986e822f6", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 107, "deletions": 126, "changes": 233, "blob_url": "https://github.com/rust-lang/rust/blob/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=ebec55406ba94faf8b2cd23b27a8f74df97d1ca4", "patch": "@@ -15,17 +15,17 @@ pub use self::ReprAttr::*;\n pub use self::IntType::*;\n \n use ast;\n-use ast::{AttrId, Attribute, Attribute_};\n+use ast::{AttrId, Attribute, Name};\n use ast::{MetaItem, MetaItemKind, NestedMetaItem, NestedMetaItemKind};\n use ast::{Lit, Expr, Item, Local, Stmt, StmtKind};\n-use codemap::{respan, spanned, dummy_spanned};\n+use codemap::{spanned, dummy_spanned, mk_sp};\n use syntax_pos::{Span, BytePos, DUMMY_SP};\n use errors::Handler;\n use feature_gate::{Features, GatedCfg};\n use parse::lexer::comments::{doc_comment_style, strip_doc_comment_decoration};\n-use parse::token::InternedString;\n-use parse::{ParseSess, token};\n+use parse::ParseSess;\n use ptr::P;\n+use symbol::Symbol;\n use util::ThinVec;\n \n use std::cell::{RefCell, Cell};\n@@ -37,8 +37,8 @@ thread_local! {\n }\n \n enum AttrError {\n-    MultipleItem(InternedString),\n-    UnknownMetaItem(InternedString),\n+    MultipleItem(Name),\n+    UnknownMetaItem(Name),\n     MissingSince,\n     MissingFeature,\n     MultipleStabilityLevels,\n@@ -61,7 +61,7 @@ fn handle_errors(diag: &Handler, span: Span, error: AttrError) {\n \n pub fn mark_used(attr: &Attribute) {\n     debug!(\"Marking {:?} as used.\", attr);\n-    let AttrId(id) = attr.node.id;\n+    let AttrId(id) = attr.id;\n     USED_ATTRS.with(|slot| {\n         let idx = (id / 64) as usize;\n         let shift = id % 64;\n@@ -73,7 +73,7 @@ pub fn mark_used(attr: &Attribute) {\n }\n \n pub fn is_used(attr: &Attribute) -> bool {\n-    let AttrId(id) = attr.node.id;\n+    let AttrId(id) = attr.id;\n     USED_ATTRS.with(|slot| {\n         let idx = (id / 64) as usize;\n         let shift = id % 64;\n@@ -84,7 +84,7 @@ pub fn is_used(attr: &Attribute) -> bool {\n \n pub fn mark_known(attr: &Attribute) {\n     debug!(\"Marking {:?} as known.\", attr);\n-    let AttrId(id) = attr.node.id;\n+    let AttrId(id) = attr.id;\n     KNOWN_ATTRS.with(|slot| {\n         let idx = (id / 64) as usize;\n         let shift = id % 64;\n@@ -96,7 +96,7 @@ pub fn mark_known(attr: &Attribute) {\n }\n \n pub fn is_known(attr: &Attribute) -> bool {\n-    let AttrId(id) = attr.node.id;\n+    let AttrId(id) = attr.id;\n     KNOWN_ATTRS.with(|slot| {\n         let idx = (id / 64) as usize;\n         let shift = id % 64;\n@@ -107,7 +107,7 @@ pub fn is_known(attr: &Attribute) -> bool {\n \n impl NestedMetaItem {\n     /// Returns the MetaItem if self is a NestedMetaItemKind::MetaItem.\n-    pub fn meta_item(&self) -> Option<&P<MetaItem>> {\n+    pub fn meta_item(&self) -> Option<&MetaItem> {\n         match self.node {\n             NestedMetaItemKind::MetaItem(ref item) => Some(&item),\n             _ => None\n@@ -134,18 +134,18 @@ impl NestedMetaItem {\n \n     /// Returns the name of the meta item, e.g. `foo` in `#[foo]`,\n     /// `#[foo=\"bar\"]` and `#[foo(bar)]`, if self is a MetaItem\n-    pub fn name(&self) -> Option<InternedString> {\n+    pub fn name(&self) -> Option<Name> {\n         self.meta_item().and_then(|meta_item| Some(meta_item.name()))\n     }\n \n     /// Gets the string value if self is a MetaItem and the MetaItem is a\n     /// MetaItemKind::NameValue variant containing a string, otherwise None.\n-    pub fn value_str(&self) -> Option<InternedString> {\n+    pub fn value_str(&self) -> Option<Symbol> {\n         self.meta_item().and_then(|meta_item| meta_item.value_str())\n     }\n \n     /// Returns a MetaItem if self is a MetaItem with Kind Word.\n-    pub fn word(&self) -> Option<&P<MetaItem>> {\n+    pub fn word(&self) -> Option<&MetaItem> {\n         self.meta_item().and_then(|meta_item| if meta_item.is_word() {\n             Some(meta_item)\n         } else {\n@@ -186,16 +186,16 @@ impl NestedMetaItem {\n \n impl Attribute {\n     pub fn check_name(&self, name: &str) -> bool {\n-        let matches = name == &self.name()[..];\n+        let matches = self.name() == name;\n         if matches {\n             mark_used(self);\n         }\n         matches\n     }\n \n-    pub fn name(&self) -> InternedString { self.meta().name() }\n+    pub fn name(&self) -> Name { self.meta().name() }\n \n-    pub fn value_str(&self) -> Option<InternedString> {\n+    pub fn value_str(&self) -> Option<Symbol> {\n         self.meta().value_str()\n     }\n \n@@ -218,17 +218,13 @@ impl Attribute {\n }\n \n impl MetaItem {\n-    pub fn name(&self) -> InternedString {\n-        match self.node {\n-            MetaItemKind::Word(ref n) => (*n).clone(),\n-            MetaItemKind::NameValue(ref n, _) => (*n).clone(),\n-            MetaItemKind::List(ref n, _) => (*n).clone(),\n-        }\n+    pub fn name(&self) -> Name {\n+        self.name\n     }\n \n-    pub fn value_str(&self) -> Option<InternedString> {\n+    pub fn value_str(&self) -> Option<Symbol> {\n         match self.node {\n-            MetaItemKind::NameValue(_, ref v) => {\n+            MetaItemKind::NameValue(ref v) => {\n                 match v.node {\n                     ast::LitKind::Str(ref s, _) => Some((*s).clone()),\n                     _ => None,\n@@ -240,22 +236,22 @@ impl MetaItem {\n \n     pub fn meta_item_list(&self) -> Option<&[NestedMetaItem]> {\n         match self.node {\n-            MetaItemKind::List(_, ref l) => Some(&l[..]),\n+            MetaItemKind::List(ref l) => Some(&l[..]),\n             _ => None\n         }\n     }\n \n     pub fn is_word(&self) -> bool {\n         match self.node {\n-            MetaItemKind::Word(_) => true,\n+            MetaItemKind::Word => true,\n             _ => false,\n         }\n     }\n \n     pub fn span(&self) -> Span { self.span }\n \n     pub fn check_name(&self, name: &str) -> bool {\n-        name == &self.name()[..]\n+        self.name() == name\n     }\n \n     pub fn is_value_str(&self) -> bool {\n@@ -270,7 +266,7 @@ impl MetaItem {\n impl Attribute {\n     /// Extract the MetaItem from inside this Attribute.\n     pub fn meta(&self) -> &MetaItem {\n-        &self.node.value\n+        &self.value\n     }\n \n     /// Convert self to a normal #[doc=\"foo\"] comment, if it is a\n@@ -279,16 +275,15 @@ impl Attribute {\n     pub fn with_desugared_doc<T, F>(&self, f: F) -> T where\n         F: FnOnce(&Attribute) -> T,\n     {\n-        if self.node.is_sugared_doc {\n+        if self.is_sugared_doc {\n             let comment = self.value_str().unwrap();\n             let meta = mk_name_value_item_str(\n-                InternedString::new(\"doc\"),\n-                token::intern_and_get_ident(&strip_doc_comment_decoration(\n-                        &comment)));\n-            if self.node.style == ast::AttrStyle::Outer {\n-                f(&mk_attr_outer(self.node.id, meta))\n+                Symbol::intern(\"doc\"),\n+                Symbol::intern(&strip_doc_comment_decoration(&comment.as_str())));\n+            if self.style == ast::AttrStyle::Outer {\n+                f(&mk_attr_outer(self.id, meta))\n             } else {\n-                f(&mk_attr_inner(self.node.id, meta))\n+                f(&mk_attr_inner(self.id, meta))\n             }\n         } else {\n             f(self)\n@@ -298,41 +293,37 @@ impl Attribute {\n \n /* Constructors */\n \n-pub fn mk_name_value_item_str(name: InternedString, value: InternedString)\n-                              -> P<MetaItem> {\n+pub fn mk_name_value_item_str(name: Name, value: Symbol) -> MetaItem {\n     let value_lit = dummy_spanned(ast::LitKind::Str(value, ast::StrStyle::Cooked));\n     mk_spanned_name_value_item(DUMMY_SP, name, value_lit)\n }\n \n-pub fn mk_name_value_item(name: InternedString, value: ast::Lit)\n-                          -> P<MetaItem> {\n+pub fn mk_name_value_item(name: Name, value: ast::Lit) -> MetaItem {\n     mk_spanned_name_value_item(DUMMY_SP, name, value)\n }\n \n-pub fn mk_list_item(name: InternedString, items: Vec<NestedMetaItem>) -> P<MetaItem> {\n+pub fn mk_list_item(name: Name, items: Vec<NestedMetaItem>) -> MetaItem {\n     mk_spanned_list_item(DUMMY_SP, name, items)\n }\n \n-pub fn mk_list_word_item(name: InternedString) -> ast::NestedMetaItem {\n+pub fn mk_list_word_item(name: Name) -> ast::NestedMetaItem {\n     dummy_spanned(NestedMetaItemKind::MetaItem(mk_spanned_word_item(DUMMY_SP, name)))\n }\n \n-pub fn mk_word_item(name: InternedString) -> P<MetaItem> {\n+pub fn mk_word_item(name: Name) -> MetaItem {\n     mk_spanned_word_item(DUMMY_SP, name)\n }\n \n-pub fn mk_spanned_name_value_item(sp: Span, name: InternedString, value: ast::Lit)\n-                          -> P<MetaItem> {\n-    P(respan(sp, MetaItemKind::NameValue(name, value)))\n+pub fn mk_spanned_name_value_item(sp: Span, name: Name, value: ast::Lit) -> MetaItem {\n+    MetaItem { span: sp, name: name, node: MetaItemKind::NameValue(value) }\n }\n \n-pub fn mk_spanned_list_item(sp: Span, name: InternedString, items: Vec<NestedMetaItem>)\n-                            -> P<MetaItem> {\n-    P(respan(sp, MetaItemKind::List(name, items)))\n+pub fn mk_spanned_list_item(sp: Span, name: Name, items: Vec<NestedMetaItem>) -> MetaItem {\n+    MetaItem { span: sp, name: name, node: MetaItemKind::List(items) }\n }\n \n-pub fn mk_spanned_word_item(sp: Span, name: InternedString) -> P<MetaItem> {\n-    P(respan(sp, MetaItemKind::Word(name)))\n+pub fn mk_spanned_word_item(sp: Span, name: Name) -> MetaItem {\n+    MetaItem { span: sp, name: name, node: MetaItemKind::Word }\n }\n \n \n@@ -349,71 +340,63 @@ pub fn mk_attr_id() -> AttrId {\n }\n \n /// Returns an inner attribute with the given value.\n-pub fn mk_attr_inner(id: AttrId, item: P<MetaItem>) -> Attribute {\n+pub fn mk_attr_inner(id: AttrId, item: MetaItem) -> Attribute {\n     mk_spanned_attr_inner(DUMMY_SP, id, item)\n }\n \n /// Returns an innter attribute with the given value and span.\n-pub fn mk_spanned_attr_inner(sp: Span, id: AttrId, item: P<MetaItem>) -> Attribute {\n-    respan(sp,\n-           Attribute_ {\n-            id: id,\n-            style: ast::AttrStyle::Inner,\n-            value: item,\n-            is_sugared_doc: false,\n-          })\n+pub fn mk_spanned_attr_inner(sp: Span, id: AttrId, item: MetaItem) -> Attribute {\n+    Attribute {\n+        id: id,\n+        style: ast::AttrStyle::Inner,\n+        value: item,\n+        is_sugared_doc: false,\n+        span: sp,\n+    }\n }\n \n \n /// Returns an outer attribute with the given value.\n-pub fn mk_attr_outer(id: AttrId, item: P<MetaItem>) -> Attribute {\n+pub fn mk_attr_outer(id: AttrId, item: MetaItem) -> Attribute {\n     mk_spanned_attr_outer(DUMMY_SP, id, item)\n }\n \n /// Returns an outer attribute with the given value and span.\n-pub fn mk_spanned_attr_outer(sp: Span, id: AttrId, item: P<MetaItem>) -> Attribute {\n-    respan(sp,\n-           Attribute_ {\n-            id: id,\n-            style: ast::AttrStyle::Outer,\n-            value: item,\n-            is_sugared_doc: false,\n-          })\n+pub fn mk_spanned_attr_outer(sp: Span, id: AttrId, item: MetaItem) -> Attribute {\n+    Attribute {\n+        id: id,\n+        style: ast::AttrStyle::Outer,\n+        value: item,\n+        is_sugared_doc: false,\n+        span: sp,\n+    }\n }\n \n-pub fn mk_doc_attr_outer(id: AttrId, item: P<MetaItem>, is_sugared_doc: bool) -> Attribute {\n-    dummy_spanned(Attribute_ {\n+pub fn mk_doc_attr_outer(id: AttrId, item: MetaItem, is_sugared_doc: bool) -> Attribute {\n+    Attribute {\n         id: id,\n         style: ast::AttrStyle::Outer,\n         value: item,\n         is_sugared_doc: is_sugared_doc,\n-    })\n+        span: DUMMY_SP,\n+    }\n }\n \n-pub fn mk_sugared_doc_attr(id: AttrId, text: InternedString, lo: BytePos,\n-                           hi: BytePos)\n+pub fn mk_sugared_doc_attr(id: AttrId, text: Symbol, lo: BytePos, hi: BytePos)\n                            -> Attribute {\n-    let style = doc_comment_style(&text);\n+    let style = doc_comment_style(&text.as_str());\n     let lit = spanned(lo, hi, ast::LitKind::Str(text, ast::StrStyle::Cooked));\n-    let attr = Attribute_ {\n+    Attribute {\n         id: id,\n         style: style,\n-        value: P(spanned(lo, hi, MetaItemKind::NameValue(InternedString::new(\"doc\"), lit))),\n-        is_sugared_doc: true\n-    };\n-    spanned(lo, hi, attr)\n-}\n-\n-/* Searching */\n-/// Check if `needle` occurs in `haystack` by a structural\n-/// comparison. This is slightly subtle, and relies on ignoring the\n-/// span included in the `==` comparison a plain MetaItem.\n-pub fn contains(haystack: &[P<MetaItem>], needle: &MetaItem) -> bool {\n-    debug!(\"attr::contains (name={})\", needle.name());\n-    haystack.iter().any(|item| {\n-        debug!(\"  testing: {}\", item.name());\n-        item.node == needle.node\n-    })\n+        value: MetaItem {\n+            span: mk_sp(lo, hi),\n+            name: Symbol::intern(\"doc\"),\n+            node: MetaItemKind::NameValue(lit),\n+        },\n+        is_sugared_doc: true,\n+        span: mk_sp(lo, hi),\n+    }\n }\n \n pub fn list_contains_name(items: &[NestedMetaItem], name: &str) -> bool {\n@@ -432,15 +415,13 @@ pub fn contains_name(attrs: &[Attribute], name: &str) -> bool {\n     })\n }\n \n-pub fn first_attr_value_str_by_name(attrs: &[Attribute], name: &str)\n-                                 -> Option<InternedString> {\n+pub fn first_attr_value_str_by_name(attrs: &[Attribute], name: &str) -> Option<Symbol> {\n     attrs.iter()\n         .find(|at| at.check_name(name))\n         .and_then(|at| at.value_str())\n }\n \n-pub fn last_meta_item_value_str_by_name(items: &[P<MetaItem>], name: &str)\n-                                     -> Option<InternedString> {\n+pub fn last_meta_item_value_str_by_name(items: &[MetaItem], name: &str) -> Option<Symbol> {\n     items.iter()\n          .rev()\n          .find(|mi| mi.check_name(name))\n@@ -449,12 +430,12 @@ pub fn last_meta_item_value_str_by_name(items: &[P<MetaItem>], name: &str)\n \n /* Higher-level applications */\n \n-pub fn find_crate_name(attrs: &[Attribute]) -> Option<InternedString> {\n+pub fn find_crate_name(attrs: &[Attribute]) -> Option<Symbol> {\n     first_attr_value_str_by_name(attrs, \"crate_name\")\n }\n \n /// Find the value of #[export_name=*] attribute and check its validity.\n-pub fn find_export_name_attr(diag: &Handler, attrs: &[Attribute]) -> Option<InternedString> {\n+pub fn find_export_name_attr(diag: &Handler, attrs: &[Attribute]) -> Option<Symbol> {\n     attrs.iter().fold(None, |ia,attr| {\n         if attr.check_name(\"export_name\") {\n             if let s@Some(_) = attr.value_str() {\n@@ -488,13 +469,14 @@ pub enum InlineAttr {\n \n /// Determine what `#[inline]` attribute is present in `attrs`, if any.\n pub fn find_inline_attr(diagnostic: Option<&Handler>, attrs: &[Attribute]) -> InlineAttr {\n-    attrs.iter().fold(InlineAttr::None, |ia,attr| {\n-        match attr.node.value.node {\n-            MetaItemKind::Word(ref n) if n == \"inline\" => {\n+    attrs.iter().fold(InlineAttr::None, |ia, attr| {\n+        match attr.value.node {\n+            _ if attr.value.name != \"inline\" => ia,\n+            MetaItemKind::Word => {\n                 mark_used(attr);\n                 InlineAttr::Hint\n             }\n-            MetaItemKind::List(ref n, ref items) if n == \"inline\" => {\n+            MetaItemKind::List(ref items) => {\n                 mark_used(attr);\n                 if items.len() != 1 {\n                     diagnostic.map(|d|{ span_err!(d, attr.span, E0534, \"expected one argument\"); });\n@@ -527,7 +509,7 @@ pub fn requests_inline(attrs: &[Attribute]) -> bool {\n /// Tests if a cfg-pattern matches the cfg set\n pub fn cfg_matches(cfg: &ast::MetaItem, sess: &ParseSess, features: Option<&Features>) -> bool {\n     match cfg.node {\n-        ast::MetaItemKind::List(ref pred, ref mis) => {\n+        ast::MetaItemKind::List(ref mis) => {\n             for mi in mis.iter() {\n                 if !mi.is_meta_item() {\n                     handle_errors(&sess.span_diagnostic, mi.span, AttrError::UnsupportedLiteral);\n@@ -537,7 +519,7 @@ pub fn cfg_matches(cfg: &ast::MetaItem, sess: &ParseSess, features: Option<&Feat\n \n             // The unwraps below may look dangerous, but we've already asserted\n             // that they won't fail with the loop above.\n-            match &pred[..] {\n+            match &*cfg.name.as_str() {\n                 \"any\" => mis.iter().any(|mi| {\n                     cfg_matches(mi.meta_item().unwrap(), sess, features)\n                 }),\n@@ -558,11 +540,11 @@ pub fn cfg_matches(cfg: &ast::MetaItem, sess: &ParseSess, features: Option<&Feat\n                 }\n             }\n         },\n-        ast::MetaItemKind::Word(_) | ast::MetaItemKind::NameValue(..) => {\n+        ast::MetaItemKind::Word | ast::MetaItemKind::NameValue(..) => {\n             if let (Some(feats), Some(gated_cfg)) = (features, GatedCfg::gate(cfg)) {\n                 gated_cfg.check_and_emit(sess, feats);\n             }\n-            contains(&sess.config, cfg)\n+            sess.config.contains(&(cfg.name(), cfg.value_str()))\n         }\n     }\n }\n@@ -571,28 +553,28 @@ pub fn cfg_matches(cfg: &ast::MetaItem, sess: &ParseSess, features: Option<&Feat\n #[derive(RustcEncodable, RustcDecodable, Clone, Debug, PartialEq, Eq, Hash)]\n pub struct Stability {\n     pub level: StabilityLevel,\n-    pub feature: InternedString,\n+    pub feature: Symbol,\n     pub rustc_depr: Option<RustcDeprecation>,\n }\n \n /// The available stability levels.\n #[derive(RustcEncodable, RustcDecodable, PartialEq, PartialOrd, Clone, Debug, Eq, Hash)]\n pub enum StabilityLevel {\n     // Reason for the current stability level and the relevant rust-lang issue\n-    Unstable { reason: Option<InternedString>, issue: u32 },\n-    Stable { since: InternedString },\n+    Unstable { reason: Option<Symbol>, issue: u32 },\n+    Stable { since: Symbol },\n }\n \n #[derive(RustcEncodable, RustcDecodable, PartialEq, PartialOrd, Clone, Debug, Eq, Hash)]\n pub struct RustcDeprecation {\n-    pub since: InternedString,\n-    pub reason: InternedString,\n+    pub since: Symbol,\n+    pub reason: Symbol,\n }\n \n #[derive(RustcEncodable, RustcDecodable, PartialEq, PartialOrd, Clone, Debug, Eq, Hash)]\n pub struct Deprecation {\n-    pub since: Option<InternedString>,\n-    pub note: Option<InternedString>,\n+    pub since: Option<Symbol>,\n+    pub note: Option<Symbol>,\n }\n \n impl StabilityLevel {\n@@ -611,15 +593,14 @@ fn find_stability_generic<'a, I>(diagnostic: &Handler,\n \n     'outer: for attr in attrs_iter {\n         let tag = attr.name();\n-        let tag = &*tag;\n         if tag != \"rustc_deprecated\" && tag != \"unstable\" && tag != \"stable\" {\n             continue // not a stability level\n         }\n \n         mark_used(attr);\n \n         if let Some(metas) = attr.meta_item_list() {\n-            let get = |meta: &MetaItem, item: &mut Option<InternedString>| {\n+            let get = |meta: &MetaItem, item: &mut Option<Symbol>| {\n                 if item.is_some() {\n                     handle_errors(diagnostic, meta.span, AttrError::MultipleItem(meta.name()));\n                     return false\n@@ -633,7 +614,7 @@ fn find_stability_generic<'a, I>(diagnostic: &Handler,\n                 }\n             };\n \n-            match tag {\n+            match &*tag.as_str() {\n                 \"rustc_deprecated\" => {\n                     if rustc_depr.is_some() {\n                         span_err!(diagnostic, item_sp, E0540,\n@@ -645,7 +626,7 @@ fn find_stability_generic<'a, I>(diagnostic: &Handler,\n                     let mut reason = None;\n                     for meta in metas {\n                         if let Some(mi) = meta.meta_item() {\n-                            match &*mi.name() {\n+                            match &*mi.name().as_str() {\n                                 \"since\" => if !get(mi, &mut since) { continue 'outer },\n                                 \"reason\" => if !get(mi, &mut reason) { continue 'outer },\n                                 _ => {\n@@ -688,7 +669,7 @@ fn find_stability_generic<'a, I>(diagnostic: &Handler,\n                     let mut issue = None;\n                     for meta in metas {\n                         if let Some(mi) = meta.meta_item() {\n-                            match &*mi.name() {\n+                            match &*mi.name().as_str() {\n                                 \"feature\" => if !get(mi, &mut feature) { continue 'outer },\n                                 \"reason\" => if !get(mi, &mut reason) { continue 'outer },\n                                 \"issue\" => if !get(mi, &mut issue) { continue 'outer },\n@@ -710,7 +691,7 @@ fn find_stability_generic<'a, I>(diagnostic: &Handler,\n                                 level: Unstable {\n                                     reason: reason,\n                                     issue: {\n-                                        if let Ok(issue) = issue.parse() {\n+                                        if let Ok(issue) = issue.as_str().parse() {\n                                             issue\n                                         } else {\n                                             span_err!(diagnostic, attr.span(), E0545,\n@@ -743,7 +724,7 @@ fn find_stability_generic<'a, I>(diagnostic: &Handler,\n                     let mut since = None;\n                     for meta in metas {\n                         if let NestedMetaItemKind::MetaItem(ref mi) = meta.node {\n-                            match &*mi.name() {\n+                            match &*mi.name().as_str() {\n                                 \"feature\" => if !get(mi, &mut feature) { continue 'outer },\n                                 \"since\" => if !get(mi, &mut since) { continue 'outer },\n                                 _ => {\n@@ -821,7 +802,7 @@ fn find_deprecation_generic<'a, I>(diagnostic: &Handler,\n         }\n \n         depr = if let Some(metas) = attr.meta_item_list() {\n-            let get = |meta: &MetaItem, item: &mut Option<InternedString>| {\n+            let get = |meta: &MetaItem, item: &mut Option<Symbol>| {\n                 if item.is_some() {\n                     handle_errors(diagnostic, meta.span, AttrError::MultipleItem(meta.name()));\n                     return false\n@@ -839,7 +820,7 @@ fn find_deprecation_generic<'a, I>(diagnostic: &Handler,\n             let mut note = None;\n             for meta in metas {\n                 if let NestedMetaItemKind::MetaItem(ref mi) = meta.node {\n-                    match &*mi.name() {\n+                    match &*mi.name().as_str() {\n                         \"since\" => if !get(mi, &mut since) { continue 'outer },\n                         \"note\" => if !get(mi, &mut note) { continue 'outer },\n                         _ => {\n@@ -875,7 +856,7 @@ pub fn find_deprecation(diagnostic: &Handler, attrs: &[Attribute],\n     find_deprecation_generic(diagnostic, attrs.iter(), item_sp)\n }\n \n-pub fn require_unique_names(diagnostic: &Handler, metas: &[P<MetaItem>]) {\n+pub fn require_unique_names(diagnostic: &Handler, metas: &[MetaItem]) {\n     let mut set = HashSet::new();\n     for meta in metas {\n         let name = meta.name();\n@@ -896,8 +877,8 @@ pub fn require_unique_names(diagnostic: &Handler, metas: &[P<MetaItem>]) {\n /// structure layout, and `packed` to remove padding.\n pub fn find_repr_attrs(diagnostic: &Handler, attr: &Attribute) -> Vec<ReprAttr> {\n     let mut acc = Vec::new();\n-    match attr.node.value.node {\n-        ast::MetaItemKind::List(ref s, ref items) if s == \"repr\" => {\n+    match attr.value.node {\n+        ast::MetaItemKind::List(ref items) if attr.value.name == \"repr\" => {\n             mark_used(attr);\n             for item in items {\n                 if !item.is_meta_item() {\n@@ -906,7 +887,7 @@ pub fn find_repr_attrs(diagnostic: &Handler, attr: &Attribute) -> Vec<ReprAttr>\n                 }\n \n                 if let Some(mi) = item.word() {\n-                    let word = &*mi.name();\n+                    let word = &*mi.name().as_str();\n                     let hint = match word {\n                         // Can't use \"extern\" because it's not a lexical identifier.\n                         \"C\" => Some(ReprExtern),"}, {"sha": "3cdfa718eabae2a7f85568b8c3dea57bc42cd494", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=ebec55406ba94faf8b2cd23b27a8f74df97d1ca4", "patch": "@@ -871,6 +871,7 @@ impl CodeMapper for CodeMap {\n #[cfg(test)]\n mod tests {\n     use super::*;\n+    use symbol::keywords;\n     use std::rc::Rc;\n \n     #[test]\n@@ -1097,10 +1098,9 @@ mod tests {\n     #[test]\n     fn t11() {\n         // Test span_to_expanded_string works with expansion\n-        use ast::Name;\n         let cm = init_code_map();\n         let root = Span { lo: BytePos(0), hi: BytePos(11), expn_id: NO_EXPANSION };\n-        let format = ExpnFormat::MacroBang(Name(0u32));\n+        let format = ExpnFormat::MacroBang(keywords::Invalid.name());\n         let callee = NameAndSpan { format: format,\n                                    allow_internal_unstable: false,\n                                    span: None };\n@@ -1197,11 +1197,9 @@ mod tests {\n     fn init_expansion_chain(cm: &CodeMap) -> Span {\n         // Creates an expansion chain containing two recursive calls\n         // root -> expA -> expA -> expB -> expB -> end\n-        use ast::Name;\n-\n         let root = Span { lo: BytePos(0), hi: BytePos(11), expn_id: NO_EXPANSION };\n \n-        let format_root = ExpnFormat::MacroBang(Name(0u32));\n+        let format_root = ExpnFormat::MacroBang(keywords::Invalid.name());\n         let callee_root = NameAndSpan { format: format_root,\n                                         allow_internal_unstable: false,\n                                         span: Some(root) };\n@@ -1210,7 +1208,7 @@ mod tests {\n         let id_a1 = cm.record_expansion(info_a1);\n         let span_a1 = Span { lo: BytePos(12), hi: BytePos(23), expn_id: id_a1 };\n \n-        let format_a = ExpnFormat::MacroBang(Name(1u32));\n+        let format_a = ExpnFormat::MacroBang(keywords::As.name());\n         let callee_a = NameAndSpan { format: format_a,\n                                       allow_internal_unstable: false,\n                                       span: Some(span_a1) };\n@@ -1223,7 +1221,7 @@ mod tests {\n         let id_b1 = cm.record_expansion(info_b1);\n         let span_b1 = Span { lo: BytePos(25), hi: BytePos(36), expn_id: id_b1 };\n \n-        let format_b = ExpnFormat::MacroBang(Name(2u32));\n+        let format_b = ExpnFormat::MacroBang(keywords::Box.name());\n         let callee_b = NameAndSpan { format: format_b,\n                                      allow_internal_unstable: false,\n                                      span: None };"}, {"sha": "89eea3f6f8b288790ed0648bc293db97f15f9228", "filename": "src/libsyntax/config.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibsyntax%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibsyntax%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fconfig.rs?ref=ebec55406ba94faf8b2cd23b27a8f74df97d1ca4", "patch": "@@ -12,7 +12,7 @@ use attr::HasAttrs;\n use feature_gate::{feature_err, EXPLAIN_STMT_ATTR_SYNTAX, Features, get_features, GateIssue};\n use {fold, attr};\n use ast;\n-use codemap::{Spanned, respan};\n+use codemap::Spanned;\n use parse::ParseSess;\n use ptr::P;\n \n@@ -106,12 +106,13 @@ impl<'a> StripUnconfigured<'a> {\n         match (cfg.meta_item(), mi.meta_item()) {\n             (Some(cfg), Some(mi)) =>\n                 if cfg_matches(&cfg, self.sess, self.features) {\n-                    self.process_cfg_attr(respan(mi.span, ast::Attribute_ {\n+                    self.process_cfg_attr(ast::Attribute {\n                         id: attr::mk_attr_id(),\n-                        style: attr.node.style,\n+                        style: attr.style,\n                         value: mi.clone(),\n                         is_sugared_doc: false,\n-                    }))\n+                        span: mi.span,\n+                    })\n                 } else {\n                     None\n                 },\n@@ -131,8 +132,8 @@ impl<'a> StripUnconfigured<'a> {\n                 return false;\n             }\n \n-            let mis = match attr.node.value.node {\n-                ast::MetaItemKind::List(_, ref mis) if is_cfg(&attr) => mis,\n+            let mis = match attr.value.node {\n+                ast::MetaItemKind::List(ref mis) if is_cfg(&attr) => mis,\n                 _ => return true\n             };\n \n@@ -160,7 +161,7 @@ impl<'a> StripUnconfigured<'a> {\n                                           attr.span,\n                                           GateIssue::Language,\n                                           EXPLAIN_STMT_ATTR_SYNTAX);\n-                if attr.node.is_sugared_doc {\n+                if attr.is_sugared_doc {\n                     err.help(\"`///` is for documentation comments. For a plain comment, use `//`.\");\n                 }\n                 err.emit();"}, {"sha": "fe5cb87ad59b5c89370490754c45576b6bcad900", "filename": "src/libsyntax/diagnostics/plugin.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs?ref=ebec55406ba94faf8b2cd23b27a8f74df97d1ca4", "patch": "@@ -19,6 +19,7 @@ use ext::base::{ExtCtxt, MacEager, MacResult};\n use ext::build::AstBuilder;\n use parse::token;\n use ptr::P;\n+use symbol::Symbol;\n use tokenstream::{TokenTree};\n use util::small_vector::SmallVector;\n \n@@ -141,7 +142,7 @@ pub fn expand_register_diagnostic<'cx>(ecx: &'cx mut ExtCtxt,\n             ));\n         }\n     });\n-    let sym = Ident::with_empty_ctxt(token::gensym(&format!(\n+    let sym = Ident::with_empty_ctxt(Symbol::gensym(&format!(\n         \"__register_diagnostic_{}\", code\n     )));\n     MacEager::items(SmallVector::many(vec![\n@@ -194,11 +195,11 @@ pub fn expand_build_diagnostic_array<'cx>(ecx: &'cx mut ExtCtxt,\n     let (count, expr) =\n         with_registered_diagnostics(|diagnostics| {\n             let descriptions: Vec<P<ast::Expr>> =\n-                diagnostics.iter().filter_map(|(code, info)| {\n+                diagnostics.iter().filter_map(|(&code, info)| {\n                     info.description.map(|description| {\n                         ecx.expr_tuple(span, vec![\n-                            ecx.expr_str(span, code.as_str()),\n-                            ecx.expr_str(span, description.as_str())\n+                            ecx.expr_str(span, code),\n+                            ecx.expr_str(span, description)\n                         ])\n                     })\n                 }).collect();"}, {"sha": "93ca1948ed84b878b2e2b57b627b133d5129abeb", "filename": "src/libsyntax/entry.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibsyntax%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibsyntax%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fentry.rs?ref=ebec55406ba94faf8b2cd23b27a8f74df97d1ca4", "patch": "@@ -28,7 +28,7 @@ pub fn entry_point_type(item: &Item, depth: usize) -> EntryPointType {\n                 EntryPointType::Start\n             } else if attr::contains_name(&item.attrs, \"main\") {\n                 EntryPointType::MainAttr\n-            } else if item.ident.name.as_str() == \"main\" {\n+            } else if item.ident.name == \"main\" {\n                 if depth == 1 {\n                     // This is a top-level function so can be 'main'\n                     EntryPointType::MainNamed"}, {"sha": "ddf4cf11f204810ff6340d48f8c30c17235b87af", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=ebec55406ba94faf8b2cd23b27a8f74df97d1ca4", "patch": "@@ -20,8 +20,8 @@ use ext::hygiene::Mark;\n use fold::{self, Folder};\n use parse::{self, parser};\n use parse::token;\n-use parse::token::{InternedString, str_to_ident};\n use ptr::P;\n+use symbol::Symbol;\n use util::small_vector::SmallVector;\n \n use std::path::PathBuf;\n@@ -643,7 +643,7 @@ impl<'a> ExtCtxt<'a> {\n         loop {\n             if self.codemap().with_expn_info(expn_id, |info| {\n                 info.map_or(None, |i| {\n-                    if i.callee.name().as_str() == \"include\" {\n+                    if i.callee.name() == \"include\" {\n                         // Stop going up the backtrace once include! is encountered\n                         return None;\n                     }\n@@ -735,7 +735,7 @@ impl<'a> ExtCtxt<'a> {\n         self.ecfg.trace_mac = x\n     }\n     pub fn ident_of(&self, st: &str) -> ast::Ident {\n-        str_to_ident(st)\n+        ast::Ident::from_str(st)\n     }\n     pub fn std_path(&self, components: &[&str]) -> Vec<ast::Ident> {\n         let mut v = Vec::new();\n@@ -746,15 +746,15 @@ impl<'a> ExtCtxt<'a> {\n         return v\n     }\n     pub fn name_of(&self, st: &str) -> ast::Name {\n-        token::intern(st)\n+        Symbol::intern(st)\n     }\n }\n \n /// Extract a string literal from the macro expanded version of `expr`,\n /// emitting `err_msg` if `expr` is not a string literal. This does not stop\n /// compilation on error, merely emits a non-fatal error and returns None.\n pub fn expr_to_spanned_string(cx: &mut ExtCtxt, expr: P<ast::Expr>, err_msg: &str)\n-                              -> Option<Spanned<(InternedString, ast::StrStyle)>> {\n+                              -> Option<Spanned<(Symbol, ast::StrStyle)>> {\n     // Update `expr.span`'s expn_id now in case expr is an `include!` macro invocation.\n     let expr = expr.map(|mut expr| {\n         expr.span.expn_id = cx.backtrace();\n@@ -765,7 +765,7 @@ pub fn expr_to_spanned_string(cx: &mut ExtCtxt, expr: P<ast::Expr>, err_msg: &st\n     let expr = cx.expander().fold_expr(expr);\n     match expr.node {\n         ast::ExprKind::Lit(ref l) => match l.node {\n-            ast::LitKind::Str(ref s, style) => return Some(respan(expr.span, (s.clone(), style))),\n+            ast::LitKind::Str(s, style) => return Some(respan(expr.span, (s, style))),\n             _ => cx.span_err(l.span, err_msg)\n         },\n         _ => cx.span_err(expr.span, err_msg)\n@@ -774,7 +774,7 @@ pub fn expr_to_spanned_string(cx: &mut ExtCtxt, expr: P<ast::Expr>, err_msg: &st\n }\n \n pub fn expr_to_string(cx: &mut ExtCtxt, expr: P<ast::Expr>, err_msg: &str)\n-                      -> Option<(InternedString, ast::StrStyle)> {\n+                      -> Option<(Symbol, ast::StrStyle)> {\n     expr_to_spanned_string(cx, expr, err_msg).map(|s| s.node)\n }\n "}, {"sha": "324afc20051d4461d3e29d8c58ad34ae812d6e5d", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 21, "deletions": 24, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=ebec55406ba94faf8b2cd23b27a8f74df97d1ca4", "patch": "@@ -14,8 +14,8 @@ use attr;\n use syntax_pos::{Span, DUMMY_SP, Pos};\n use codemap::{dummy_spanned, respan, Spanned};\n use ext::base::ExtCtxt;\n-use parse::token::{self, keywords, InternedString};\n use ptr::P;\n+use symbol::{Symbol, keywords};\n \n // Transitional reexports so qquote can find the paths it is looking for\n mod syntax {\n@@ -149,7 +149,7 @@ pub trait AstBuilder {\n     fn expr_vec(&self, sp: Span, exprs: Vec<P<ast::Expr>>) -> P<ast::Expr>;\n     fn expr_vec_ng(&self, sp: Span) -> P<ast::Expr>;\n     fn expr_vec_slice(&self, sp: Span, exprs: Vec<P<ast::Expr>>) -> P<ast::Expr>;\n-    fn expr_str(&self, sp: Span, s: InternedString) -> P<ast::Expr>;\n+    fn expr_str(&self, sp: Span, s: Symbol) -> P<ast::Expr>;\n \n     fn expr_some(&self, sp: Span, expr: P<ast::Expr>) -> P<ast::Expr>;\n     fn expr_none(&self, sp: Span) -> P<ast::Expr>;\n@@ -158,7 +158,7 @@ pub trait AstBuilder {\n \n     fn expr_tuple(&self, sp: Span, exprs: Vec<P<ast::Expr>>) -> P<ast::Expr>;\n \n-    fn expr_fail(&self, span: Span, msg: InternedString) -> P<ast::Expr>;\n+    fn expr_fail(&self, span: Span, msg: Symbol) -> P<ast::Expr>;\n     fn expr_unreachable(&self, span: Span) -> P<ast::Expr>;\n \n     fn expr_ok(&self, span: Span, expr: P<ast::Expr>) -> P<ast::Expr>;\n@@ -275,22 +275,22 @@ pub trait AstBuilder {\n                     generics: Generics) -> P<ast::Item>;\n     fn item_ty(&self, span: Span, name: Ident, ty: P<ast::Ty>) -> P<ast::Item>;\n \n-    fn attribute(&self, sp: Span, mi: P<ast::MetaItem>) -> ast::Attribute;\n+    fn attribute(&self, sp: Span, mi: ast::MetaItem) -> ast::Attribute;\n \n-    fn meta_word(&self, sp: Span, w: InternedString) -> P<ast::MetaItem>;\n+    fn meta_word(&self, sp: Span, w: ast::Name) -> ast::MetaItem;\n \n-    fn meta_list_item_word(&self, sp: Span, w: InternedString) -> ast::NestedMetaItem;\n+    fn meta_list_item_word(&self, sp: Span, w: ast::Name) -> ast::NestedMetaItem;\n \n     fn meta_list(&self,\n                  sp: Span,\n-                 name: InternedString,\n+                 name: ast::Name,\n                  mis: Vec<ast::NestedMetaItem> )\n-                 -> P<ast::MetaItem>;\n+                 -> ast::MetaItem;\n     fn meta_name_value(&self,\n                        sp: Span,\n-                       name: InternedString,\n+                       name: ast::Name,\n                        value: ast::LitKind)\n-                       -> P<ast::MetaItem>;\n+                       -> ast::MetaItem;\n \n     fn item_use(&self, sp: Span,\n                 vis: ast::Visibility, vp: P<ast::ViewPath>) -> P<ast::Item>;\n@@ -755,7 +755,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n     fn expr_vec_slice(&self, sp: Span, exprs: Vec<P<ast::Expr>>) -> P<ast::Expr> {\n         self.expr_addr_of(sp, self.expr_vec(sp, exprs))\n     }\n-    fn expr_str(&self, sp: Span, s: InternedString) -> P<ast::Expr> {\n+    fn expr_str(&self, sp: Span, s: Symbol) -> P<ast::Expr> {\n         self.expr_lit(sp, ast::LitKind::Str(s, ast::StrStyle::Cooked))\n     }\n \n@@ -785,10 +785,9 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n         self.expr(sp, ast::ExprKind::Tup(exprs))\n     }\n \n-    fn expr_fail(&self, span: Span, msg: InternedString) -> P<ast::Expr> {\n+    fn expr_fail(&self, span: Span, msg: Symbol) -> P<ast::Expr> {\n         let loc = self.codemap().lookup_char_pos(span.lo);\n-        let expr_file = self.expr_str(span,\n-                                      token::intern_and_get_ident(&loc.file.name));\n+        let expr_file = self.expr_str(span, Symbol::intern(&loc.file.name));\n         let expr_line = self.expr_u32(span, loc.line as u32);\n         let expr_file_line_tuple = self.expr_tuple(span, vec![expr_file, expr_line]);\n         let expr_file_line_ptr = self.expr_addr_of(span, expr_file_line_tuple);\n@@ -801,9 +800,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n     }\n \n     fn expr_unreachable(&self, span: Span) -> P<ast::Expr> {\n-        self.expr_fail(span,\n-                       InternedString::new(\n-                           \"internal error: entered unreachable code\"))\n+        self.expr_fail(span, Symbol::intern(\"internal error: entered unreachable code\"))\n     }\n \n     fn expr_ok(&self, sp: Span, expr: P<ast::Expr>) -> P<ast::Expr> {\n@@ -1146,25 +1143,25 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n         self.item_ty_poly(span, name, ty, Generics::default())\n     }\n \n-    fn attribute(&self, sp: Span, mi: P<ast::MetaItem>) -> ast::Attribute {\n+    fn attribute(&self, sp: Span, mi: ast::MetaItem) -> ast::Attribute {\n         attr::mk_spanned_attr_outer(sp, attr::mk_attr_id(), mi)\n     }\n \n-    fn meta_word(&self, sp: Span, w: InternedString) -> P<ast::MetaItem> {\n+    fn meta_word(&self, sp: Span, w: ast::Name) -> ast::MetaItem {\n         attr::mk_spanned_word_item(sp, w)\n     }\n \n-    fn meta_list_item_word(&self, sp: Span, w: InternedString) -> ast::NestedMetaItem {\n+    fn meta_list_item_word(&self, sp: Span, w: ast::Name) -> ast::NestedMetaItem {\n         respan(sp, ast::NestedMetaItemKind::MetaItem(attr::mk_spanned_word_item(sp, w)))\n     }\n \n-    fn meta_list(&self, sp: Span, name: InternedString, mis: Vec<ast::NestedMetaItem>)\n-                 -> P<ast::MetaItem> {\n+    fn meta_list(&self, sp: Span, name: ast::Name, mis: Vec<ast::NestedMetaItem>)\n+                 -> ast::MetaItem {\n         attr::mk_spanned_list_item(sp, name, mis)\n     }\n \n-    fn meta_name_value(&self, sp: Span, name: InternedString, value: ast::LitKind)\n-                       -> P<ast::MetaItem> {\n+    fn meta_name_value(&self, sp: Span, name: ast::Name, value: ast::LitKind)\n+                       -> ast::MetaItem {\n         attr::mk_spanned_name_value_item(sp, name, respan(sp, value))\n     }\n "}, {"sha": "844fb77e29d79fa70753ef0e2b5c567c1163eeff", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=ebec55406ba94faf8b2cd23b27a8f74df97d1ca4", "patch": "@@ -23,10 +23,11 @@ use fold;\n use fold::*;\n use parse::{ParseSess, PResult, lexer};\n use parse::parser::Parser;\n-use parse::token::{self, intern, keywords};\n+use parse::token;\n use print::pprust;\n use ptr::P;\n use std_inject;\n+use symbol::keywords;\n use tokenstream::{TokenTree, TokenStream};\n use util::small_vector::SmallVector;\n use visit::Visitor;\n@@ -190,7 +191,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n     pub fn expand_crate(&mut self, mut krate: ast::Crate) -> ast::Crate {\n         self.cx.crate_root = std_inject::injected_crate_name(&krate);\n         let mut module = ModuleData {\n-            mod_path: vec![token::str_to_ident(&self.cx.ecfg.crate_name)],\n+            mod_path: vec![Ident::from_str(&self.cx.ecfg.crate_name)],\n             directory: PathBuf::from(self.cx.codemap().span_to_filename(krate.span)),\n         };\n         module.directory.pop();\n@@ -246,7 +247,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                     self.cx.resolver.resolve_macro(scope, &mac.node.path, force)\n                 }\n                 InvocationKind::Attr { ref attr, .. } => {\n-                    let ident = ast::Ident::with_empty_ctxt(intern(&*attr.name()));\n+                    let ident = Ident::with_empty_ctxt(attr.name());\n                     let path = ast::Path::from_ident(attr.span, ident);\n                     self.cx.resolver.resolve_macro(scope, &path, force)\n                 }\n@@ -341,7 +342,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n         };\n \n         attr::mark_used(&attr);\n-        let name = intern(&attr.name());\n+        let name = attr.name();\n         self.cx.bt_push(ExpnInfo {\n             call_site: attr.span,\n             callee: NameAndSpan {\n@@ -353,12 +354,12 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n \n         match *ext {\n             MultiModifier(ref mac) => {\n-                let item = mac.expand(self.cx, attr.span, &attr.node.value, item);\n+                let item = mac.expand(self.cx, attr.span, &attr.value, item);\n                 kind.expect_from_annotatables(item)\n             }\n             MultiDecorator(ref mac) => {\n                 let mut items = Vec::new();\n-                mac.expand(self.cx, attr.span, &attr.node.value, &item,\n+                mac.expand(self.cx, attr.span, &attr.value, &item,\n                            &mut |item| items.push(item));\n                 items.push(item);\n                 kind.expect_from_annotatables(items)\n@@ -779,7 +780,7 @@ impl<'a, 'b> Folder for InvocationCollector<'a, 'b> {\n                 if inline_module {\n                     if let Some(path) = attr::first_attr_value_str_by_name(&item.attrs, \"path\") {\n                         self.cx.current_expansion.no_noninline_mod = false;\n-                        module.directory.push(&*path);\n+                        module.directory.push(&*path.as_str());\n                     } else {\n                         module.directory.push(&*item.ident.name.as_str());\n                     }"}, {"sha": "4fe57a8345e94e707c71192c0f5f0f3bb8b06cbf", "filename": "src/libsyntax/ext/placeholders.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibsyntax%2Fext%2Fplaceholders.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibsyntax%2Fext%2Fplaceholders.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fplaceholders.rs?ref=ebec55406ba94faf8b2cd23b27a8f74df97d1ca4", "patch": "@@ -13,8 +13,8 @@ use codemap::{DUMMY_SP, dummy_spanned};\n use ext::base::ExtCtxt;\n use ext::expand::{Expansion, ExpansionKind};\n use fold::*;\n-use parse::token::{intern, keywords};\n use ptr::P;\n+use symbol::{Symbol, keywords};\n use util::move_map::MoveMap;\n use util::small_vector::SmallVector;\n \n@@ -227,7 +227,7 @@ pub fn reconstructed_macro_rules(def: &ast::MacroDef) -> Expansion {\n                     span: DUMMY_SP,\n                     global: false,\n                     segments: vec![ast::PathSegment {\n-                        identifier: ast::Ident::with_empty_ctxt(intern(\"macro_rules\")),\n+                        identifier: ast::Ident::with_empty_ctxt(Symbol::intern(\"macro_rules\")),\n                         parameters: ast::PathParameters::none(),\n                     }],\n                 },"}, {"sha": "21ce89a6dd5be7d54ec78a3d4dde8a87082e2048", "filename": "src/libsyntax/ext/proc_macro_shim.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibsyntax%2Fext%2Fproc_macro_shim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibsyntax%2Fext%2Fproc_macro_shim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fproc_macro_shim.rs?ref=ebec55406ba94faf8b2cd23b27a8f74df97d1ca4", "patch": "@@ -66,6 +66,7 @@ pub mod prelude {\n     pub use ast::Ident;\n     pub use codemap::{DUMMY_SP, Span};\n     pub use ext::base::{ExtCtxt, MacResult};\n-    pub use parse::token::{self, Token, DelimToken, keywords, str_to_ident};\n+    pub use parse::token::{self, Token, DelimToken};\n+    pub use symbol::keywords;\n     pub use tokenstream::{TokenTree, TokenStream};\n }"}, {"sha": "aa777a19a9bcba047fe91ca30f841f19f38be83d", "filename": "src/libsyntax/ext/quote.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibsyntax%2Fext%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibsyntax%2Fext%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fquote.rs?ref=ebec55406ba94faf8b2cd23b27a8f74df97d1ca4", "patch": "@@ -33,6 +33,7 @@ pub mod rt {\n     use parse::{self, token, classify};\n     use ptr::P;\n     use std::rc::Rc;\n+    use symbol::Symbol;\n \n     use tokenstream::{self, TokenTree};\n \n@@ -211,7 +212,7 @@ pub mod rt {\n     impl_to_tokens_slice! { P<ast::Item>, [] }\n     impl_to_tokens_slice! { ast::Arg, [TokenTree::Token(DUMMY_SP, token::Comma)] }\n \n-    impl ToTokens for P<ast::MetaItem> {\n+    impl ToTokens for ast::MetaItem {\n         fn to_tokens(&self, _cx: &ExtCtxt) -> Vec<TokenTree> {\n             let nt = token::NtMeta(self.clone());\n             vec![TokenTree::Token(DUMMY_SP, token::Interpolated(Rc::new(nt)))]\n@@ -223,13 +224,13 @@ pub mod rt {\n             let mut r = vec![];\n             // FIXME: The spans could be better\n             r.push(TokenTree::Token(self.span, token::Pound));\n-            if self.node.style == ast::AttrStyle::Inner {\n+            if self.style == ast::AttrStyle::Inner {\n                 r.push(TokenTree::Token(self.span, token::Not));\n             }\n             r.push(TokenTree::Delimited(self.span, Rc::new(tokenstream::Delimited {\n                 delim: token::Bracket,\n                 open_span: self.span,\n-                tts: self.node.value.to_tokens(cx),\n+                tts: self.value.to_tokens(cx),\n                 close_span: self.span,\n             })));\n             r\n@@ -238,8 +239,7 @@ pub mod rt {\n \n     impl ToTokens for str {\n         fn to_tokens(&self, cx: &ExtCtxt) -> Vec<TokenTree> {\n-            let lit = ast::LitKind::Str(\n-                token::intern_and_get_ident(self), ast::StrStyle::Cooked);\n+            let lit = ast::LitKind::Str(Symbol::intern(self), ast::StrStyle::Cooked);\n             dummy_spanned(lit).to_tokens(cx)\n         }\n     }\n@@ -405,7 +405,7 @@ pub fn parse_block_panic(parser: &mut Parser) -> P<Block> {\n     panictry!(parser.parse_block())\n }\n \n-pub fn parse_meta_item_panic(parser: &mut Parser) -> P<ast::MetaItem> {\n+pub fn parse_meta_item_panic(parser: &mut Parser) -> ast::MetaItem {\n     panictry!(parser.parse_meta_item())\n }\n \n@@ -527,17 +527,17 @@ pub fn expand_quote_matcher(cx: &mut ExtCtxt,\n     base::MacEager::expr(expanded)\n }\n \n-fn ids_ext(strs: Vec<String> ) -> Vec<ast::Ident> {\n-    strs.iter().map(|str| str_to_ident(&(*str))).collect()\n+fn ids_ext(strs: Vec<String>) -> Vec<ast::Ident> {\n+    strs.iter().map(|s| ast::Ident::from_str(s)).collect()\n }\n \n-fn id_ext(str: &str) -> ast::Ident {\n-    str_to_ident(str)\n+fn id_ext(s: &str) -> ast::Ident {\n+    ast::Ident::from_str(s)\n }\n \n // Lift an ident to the expr that evaluates to that ident.\n fn mk_ident(cx: &ExtCtxt, sp: Span, ident: ast::Ident) -> P<ast::Expr> {\n-    let e_str = cx.expr_str(sp, ident.name.as_str());\n+    let e_str = cx.expr_str(sp, ident.name);\n     cx.expr_method_call(sp,\n                         cx.expr_ident(sp, id_ext(\"ext_cx\")),\n                         id_ext(\"ident_of\"),\n@@ -546,7 +546,7 @@ fn mk_ident(cx: &ExtCtxt, sp: Span, ident: ast::Ident) -> P<ast::Expr> {\n \n // Lift a name to the expr that evaluates to that name\n fn mk_name(cx: &ExtCtxt, sp: Span, ident: ast::Ident) -> P<ast::Expr> {\n-    let e_str = cx.expr_str(sp, ident.name.as_str());\n+    let e_str = cx.expr_str(sp, ident.name);\n     cx.expr_method_call(sp,\n                         cx.expr_ident(sp, id_ext(\"ext_cx\")),\n                         id_ext(\"name_of\"),"}, {"sha": "320d49b64634c9f5c840b7aa3901a38cc8f1e91d", "filename": "src/libsyntax/ext/source_util.rs", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibsyntax%2Fext%2Fsource_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibsyntax%2Fext%2Fsource_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fsource_util.rs?ref=ebec55406ba94faf8b2cd23b27a8f74df97d1ca4", "patch": "@@ -17,6 +17,7 @@ use parse::token;\n use parse;\n use print::pprust;\n use ptr::P;\n+use symbol::Symbol;\n use tokenstream;\n use util::small_vector::SmallVector;\n \n@@ -60,15 +61,13 @@ pub fn expand_file(cx: &mut ExtCtxt, sp: Span, tts: &[tokenstream::TokenTree])\n \n     let topmost = cx.expansion_cause();\n     let loc = cx.codemap().lookup_char_pos(topmost.lo);\n-    let filename = token::intern_and_get_ident(&loc.file.name);\n-    base::MacEager::expr(cx.expr_str(topmost, filename))\n+    base::MacEager::expr(cx.expr_str(topmost, Symbol::intern(&loc.file.name)))\n }\n \n pub fn expand_stringify(cx: &mut ExtCtxt, sp: Span, tts: &[tokenstream::TokenTree])\n                         -> Box<base::MacResult+'static> {\n     let s = pprust::tts_to_string(tts);\n-    base::MacEager::expr(cx.expr_str(sp,\n-                                   token::intern_and_get_ident(&s[..])))\n+    base::MacEager::expr(cx.expr_str(sp, Symbol::intern(&s)))\n }\n \n pub fn expand_mod(cx: &mut ExtCtxt, sp: Span, tts: &[tokenstream::TokenTree])\n@@ -77,9 +76,7 @@ pub fn expand_mod(cx: &mut ExtCtxt, sp: Span, tts: &[tokenstream::TokenTree])\n     let mod_path = &cx.current_expansion.module.mod_path;\n     let string = mod_path.iter().map(|x| x.to_string()).collect::<Vec<String>>().join(\"::\");\n \n-    base::MacEager::expr(cx.expr_str(\n-            sp,\n-            token::intern_and_get_ident(&string[..])))\n+    base::MacEager::expr(cx.expr_str(sp, Symbol::intern(&string)))\n }\n \n /// include! : parse the given file as an expr\n@@ -144,10 +141,9 @@ pub fn expand_include_str(cx: &mut ExtCtxt, sp: Span, tts: &[tokenstream::TokenT\n             // Add this input file to the code map to make it available as\n             // dependency information\n             let filename = format!(\"{}\", file.display());\n-            let interned = token::intern_and_get_ident(&src[..]);\n             cx.codemap().new_filemap_and_lines(&filename, None, &src);\n \n-            base::MacEager::expr(cx.expr_str(sp, interned))\n+            base::MacEager::expr(cx.expr_str(sp, Symbol::intern(&src)))\n         }\n         Err(_) => {\n             cx.span_err(sp,"}, {"sha": "59b8b50e88cb61b6b139ff9632d24049b143772b", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=ebec55406ba94faf8b2cd23b27a8f74df97d1ca4", "patch": "@@ -20,9 +20,10 @@ use ext::tt::macro_parser::{parse, parse_failure_msg};\n use parse::ParseSess;\n use parse::lexer::new_tt_reader;\n use parse::parser::{Parser, Restrictions};\n-use parse::token::{self, gensym_ident, NtTT, Token};\n+use parse::token::{self, NtTT, Token};\n use parse::token::Token::*;\n use print;\n+use symbol::Symbol;\n use tokenstream::{self, TokenTree};\n \n use std::collections::{HashMap};\n@@ -187,16 +188,16 @@ impl IdentMacroExpander for MacroRulesExpander {\n \n /// Converts a `macro_rules!` invocation into a syntax extension.\n pub fn compile(sess: &ParseSess, def: &ast::MacroDef) -> SyntaxExtension {\n-    let lhs_nm =  gensym_ident(\"lhs\");\n-    let rhs_nm =  gensym_ident(\"rhs\");\n+    let lhs_nm = ast::Ident::with_empty_ctxt(Symbol::gensym(\"lhs\"));\n+    let rhs_nm = ast::Ident::with_empty_ctxt(Symbol::gensym(\"rhs\"));\n \n     // The pattern that macro_rules matches.\n     // The grammar for macro_rules! is:\n     // $( $lhs:tt => $rhs:tt );+\n     // ...quasiquoting this would be nice.\n     // These spans won't matter, anyways\n-    let match_lhs_tok = MatchNt(lhs_nm, token::str_to_ident(\"tt\"));\n-    let match_rhs_tok = MatchNt(rhs_nm, token::str_to_ident(\"tt\"));\n+    let match_lhs_tok = MatchNt(lhs_nm, ast::Ident::from_str(\"tt\"));\n+    let match_rhs_tok = MatchNt(rhs_nm, ast::Ident::from_str(\"tt\"));\n     let argument_gram = vec![\n         TokenTree::Sequence(DUMMY_SP, Rc::new(tokenstream::SequenceRepetition {\n             tts: vec![\n@@ -790,17 +791,16 @@ fn is_in_follow(tok: &Token, frag: &str) -> Result<bool, (String, &'static str)>\n             \"pat\" => {\n                 match *tok {\n                     FatArrow | Comma | Eq | BinOp(token::Or) => Ok(true),\n-                    Ident(i) if (i.name.as_str() == \"if\" ||\n-                                 i.name.as_str() == \"in\") => Ok(true),\n+                    Ident(i) if i.name == \"if\" || i.name == \"in\" => Ok(true),\n                     _ => Ok(false)\n                 }\n             },\n             \"path\" | \"ty\" => {\n                 match *tok {\n                     OpenDelim(token::DelimToken::Brace) | OpenDelim(token::DelimToken::Bracket) |\n                     Comma | FatArrow | Colon | Eq | Gt | Semi | BinOp(token::Or) => Ok(true),\n-                    MatchNt(_, ref frag) if frag.name.as_str() == \"block\" => Ok(true),\n-                    Ident(i) if i.name.as_str() == \"as\" || i.name.as_str() == \"where\" => Ok(true),\n+                    MatchNt(_, ref frag) if frag.name == \"block\" => Ok(true),\n+                    Ident(i) if i.name == \"as\" || i.name == \"where\" => Ok(true),\n                     _ => Ok(false)\n                 }\n             },"}, {"sha": "16d4adf170589921512f31da58604a3bb8e364dd", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=ebec55406ba94faf8b2cd23b27a8f74df97d1ca4", "patch": "@@ -33,7 +33,7 @@ use syntax_pos::Span;\n use errors::{DiagnosticBuilder, Handler};\n use visit::{self, FnKind, Visitor};\n use parse::ParseSess;\n-use parse::token::InternedString;\n+use symbol::Symbol;\n \n use std::ascii::AsciiExt;\n use std::env;\n@@ -59,9 +59,9 @@ macro_rules! declare_features {\n         /// A set of features to be used by later passes.\n         pub struct Features {\n             /// #![feature] attrs for stable language features, for error reporting\n-            pub declared_stable_lang_features: Vec<(InternedString, Span)>,\n+            pub declared_stable_lang_features: Vec<(Symbol, Span)>,\n             /// #![feature] attrs for non-language (library) features\n-            pub declared_lib_features: Vec<(InternedString, Span)>,\n+            pub declared_lib_features: Vec<(Symbol, Span)>,\n             $(pub $feature: bool),+\n         }\n \n@@ -755,7 +755,7 @@ pub struct GatedCfg {\n \n impl GatedCfg {\n     pub fn gate(cfg: &ast::MetaItem) -> Option<GatedCfg> {\n-        let name = cfg.name();\n+        let name = &*cfg.name().as_str();\n         GATED_CFGS.iter()\n                   .position(|info| info.0 == name)\n                   .map(|idx| {\n@@ -802,7 +802,7 @@ macro_rules! gate_feature {\n impl<'a> Context<'a> {\n     fn check_attribute(&self, attr: &ast::Attribute, is_macro: bool) {\n         debug!(\"check_attribute(attr = {:?})\", attr);\n-        let name = &*attr.name();\n+        let name = &*attr.name().as_str();\n         for &(n, ty, ref gateage) in BUILTIN_ATTRIBUTES {\n             if n == name {\n                 if let &Gated(_, ref name, ref desc, ref has_feature) = gateage {\n@@ -989,11 +989,11 @@ fn contains_novel_literal(item: &ast::MetaItem) -> bool {\n     use ast::NestedMetaItemKind::*;\n \n     match item.node {\n-        Word(..) => false,\n-        NameValue(_, ref lit) => !lit.node.is_str(),\n-        List(_, ref list) => list.iter().any(|li| {\n+        Word => false,\n+        NameValue(ref lit) => !lit.node.is_str(),\n+        List(ref list) => list.iter().any(|li| {\n             match li.node {\n-                MetaItem(ref mi) => contains_novel_literal(&**mi),\n+                MetaItem(ref mi) => contains_novel_literal(&mi),\n                 Literal(_) => true,\n             }\n         }),\n@@ -1011,7 +1011,7 @@ impl<'a> Visitor for PostExpansionVisitor<'a> {\n             self.context.check_attribute(attr, false);\n         }\n \n-        if contains_novel_literal(&*(attr.node.value)) {\n+        if contains_novel_literal(&attr.value) {\n             gate_feature_post!(&self, attr_literals, attr.span,\n                                \"non-string literals in attributes, or string \\\n                                literals in top-level positions, are experimental\");\n@@ -1119,9 +1119,8 @@ impl<'a> Visitor for PostExpansionVisitor<'a> {\n     }\n \n     fn visit_foreign_item(&mut self, i: &ast::ForeignItem) {\n-        let links_to_llvm = match attr::first_attr_value_str_by_name(&i.attrs,\n-                                                                     \"link_name\") {\n-            Some(val) => val.starts_with(\"llvm.\"),\n+        let links_to_llvm = match attr::first_attr_value_str_by_name(&i.attrs, \"link_name\") {\n+            Some(val) => val.as_str().starts_with(\"llvm.\"),\n             _ => false\n         };\n         if links_to_llvm {"}, {"sha": "ff0255a2f21f23f2d255949c53f8f842030c0334", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 25, "deletions": 28, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=ebec55406ba94faf8b2cd23b27a8f74df97d1ca4", "patch": "@@ -22,8 +22,9 @@ use ast::*;\n use ast;\n use syntax_pos::Span;\n use codemap::{Spanned, respan};\n-use parse::token::{self, keywords};\n+use parse::token;\n use ptr::P;\n+use symbol::keywords;\n use tokenstream::*;\n use util::small_vector::SmallVector;\n use util::move_map::MoveMap;\n@@ -43,15 +44,15 @@ pub trait Folder : Sized {\n         noop_fold_crate(c, self)\n     }\n \n-    fn fold_meta_items(&mut self, meta_items: Vec<P<MetaItem>>) -> Vec<P<MetaItem>> {\n+    fn fold_meta_items(&mut self, meta_items: Vec<MetaItem>) -> Vec<MetaItem> {\n         noop_fold_meta_items(meta_items, self)\n     }\n \n     fn fold_meta_list_item(&mut self, list_item: NestedMetaItem) -> NestedMetaItem {\n         noop_fold_meta_list_item(list_item, self)\n     }\n \n-    fn fold_meta_item(&mut self, meta_item: P<MetaItem>) -> P<MetaItem> {\n+    fn fold_meta_item(&mut self, meta_item: MetaItem) -> MetaItem {\n         noop_fold_meta_item(meta_item, self)\n     }\n \n@@ -293,8 +294,7 @@ pub trait Folder : Sized {\n     }\n }\n \n-pub fn noop_fold_meta_items<T: Folder>(meta_items: Vec<P<MetaItem>>, fld: &mut T)\n-                                       -> Vec<P<MetaItem>> {\n+pub fn noop_fold_meta_items<T: Folder>(meta_items: Vec<MetaItem>, fld: &mut T) -> Vec<MetaItem> {\n     meta_items.move_map(|x| fld.fold_meta_item(x))\n }\n \n@@ -486,16 +486,13 @@ pub fn noop_fold_local<T: Folder>(l: P<Local>, fld: &mut T) -> P<Local> {\n     })\n }\n \n-pub fn noop_fold_attribute<T: Folder>(at: Attribute, fld: &mut T) -> Option<Attribute> {\n-    let Spanned {node: Attribute_ {id, style, value, is_sugared_doc}, span} = at;\n-    Some(Spanned {\n-        node: Attribute_ {\n-            id: id,\n-            style: style,\n-            value: fld.fold_meta_item(value),\n-            is_sugared_doc: is_sugared_doc\n-        },\n-        span: fld.new_span(span)\n+pub fn noop_fold_attribute<T: Folder>(attr: Attribute, fld: &mut T) -> Option<Attribute> {\n+    Some(Attribute {\n+        id: attr.id,\n+        style: attr.style,\n+        value: fld.fold_meta_item(attr.value),\n+        is_sugared_doc: attr.is_sugared_doc,\n+        span: fld.new_span(attr.span),\n     })\n }\n \n@@ -522,17 +519,18 @@ pub fn noop_fold_meta_list_item<T: Folder>(li: NestedMetaItem, fld: &mut T)\n     }\n }\n \n-pub fn noop_fold_meta_item<T: Folder>(mi: P<MetaItem>, fld: &mut T) -> P<MetaItem> {\n-    mi.map(|Spanned {node, span}| Spanned {\n-        node: match node {\n-            MetaItemKind::Word(id) => MetaItemKind::Word(id),\n-            MetaItemKind::List(id, mis) => {\n-                MetaItemKind::List(id, mis.move_map(|e| fld.fold_meta_list_item(e)))\n-            }\n-            MetaItemKind::NameValue(id, s) => MetaItemKind::NameValue(id, s)\n+pub fn noop_fold_meta_item<T: Folder>(mi: MetaItem, fld: &mut T) -> MetaItem {\n+    MetaItem {\n+        name: mi.name,\n+        node: match mi.node {\n+            MetaItemKind::Word => MetaItemKind::Word,\n+            MetaItemKind::List(mis) => {\n+                MetaItemKind::List(mis.move_map(|e| fld.fold_meta_list_item(e)))\n+            },\n+            MetaItemKind::NameValue(s) => MetaItemKind::NameValue(s),\n         },\n-        span: fld.new_span(span)\n-    })\n+        span: fld.new_span(mi.span)\n+    }\n }\n \n pub fn noop_fold_arg<T: Folder>(Arg {id, pat, ty}: Arg, fld: &mut T) -> Arg {\n@@ -1334,9 +1332,8 @@ pub fn noop_fold_vis<T: Folder>(vis: Visibility, folder: &mut T) -> Visibility {\n #[cfg(test)]\n mod tests {\n     use std::io;\n-    use ast;\n+    use ast::{self, Ident};\n     use util::parser_testing::{string_to_crate, matches_codepattern};\n-    use parse::token;\n     use print::pprust;\n     use fold;\n     use super::*;\n@@ -1352,7 +1349,7 @@ mod tests {\n \n     impl Folder for ToZzIdentFolder {\n         fn fold_ident(&mut self, _: ast::Ident) -> ast::Ident {\n-            token::str_to_ident(\"zz\")\n+            Ident::from_str(\"zz\")\n         }\n         fn fold_mac(&mut self, mac: ast::Mac) -> ast::Mac {\n             fold::noop_fold_mac(mac, self)"}, {"sha": "5a1b0d4005e17e12f14303a9dfe0e2b08dcc4dfb", "filename": "src/libsyntax/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibsyntax%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibsyntax%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Flib.rs?ref=ebec55406ba94faf8b2cd23b27a8f74df97d1ca4", "patch": "@@ -27,6 +27,7 @@\n #![feature(associated_consts)]\n #![feature(const_fn)]\n #![feature(libc)]\n+#![feature(optin_builtin_traits)]\n #![feature(rustc_private)]\n #![feature(staged_api)]\n #![feature(str_escape)]\n@@ -83,7 +84,6 @@ pub mod diagnostics {\n pub mod diagnostic_list;\n \n pub mod util {\n-    pub mod interner;\n     pub mod lev_distance;\n     pub mod node_count;\n     pub mod parser;\n@@ -118,6 +118,7 @@ pub mod ptr;\n pub mod show_span;\n pub mod std_inject;\n pub mod str;\n+pub mod symbol;\n pub mod test;\n pub mod tokenstream;\n pub mod visit;"}, {"sha": "ded676da3c6761baa0adb4c3cc273836ca375b22", "filename": "src/libsyntax/parse/attr.rs", "status": "modified", "additions": 22, "deletions": 39, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibsyntax%2Fparse%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibsyntax%2Fparse%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fattr.rs?ref=ebec55406ba94faf8b2cd23b27a8f74df97d1ca4", "patch": "@@ -11,12 +11,11 @@\n use attr;\n use ast;\n use syntax_pos::{mk_sp, Span};\n-use codemap::{spanned, Spanned};\n+use codemap::spanned;\n use parse::common::SeqSep;\n use parse::PResult;\n use parse::token;\n use parse::parser::{Parser, TokenType};\n-use ptr::P;\n \n #[derive(PartialEq, Eq, Debug)]\n enum InnerAttributeParsePolicy<'a> {\n@@ -49,13 +48,9 @@ impl<'a> Parser<'a> {\n                     just_parsed_doc_comment = false;\n                 }\n                 token::DocComment(s) => {\n-                    let attr = ::attr::mk_sugared_doc_attr(\n-                        attr::mk_attr_id(),\n-                        self.id_to_interned_str(ast::Ident::with_empty_ctxt(s)),\n-                        self.span.lo,\n-                        self.span.hi\n-                    );\n-                    if attr.node.style != ast::AttrStyle::Outer {\n+                    let Span { lo, hi, .. } = self.span;\n+                    let attr = attr::mk_sugared_doc_attr(attr::mk_attr_id(), s, lo, hi);\n+                    if attr.style != ast::AttrStyle::Outer {\n                         let mut err = self.fatal(\"expected outer doc comment\");\n                         err.note(\"inner doc comments like this (starting with \\\n                                   `//!` or `/*!`) can only appear before items\");\n@@ -145,14 +140,12 @@ impl<'a> Parser<'a> {\n             style = ast::AttrStyle::Inner;\n         }\n \n-        Ok(Spanned {\n+        Ok(ast::Attribute {\n+            id: attr::mk_attr_id(),\n+            style: style,\n+            value: value,\n+            is_sugared_doc: false,\n             span: span,\n-            node: ast::Attribute_ {\n-                id: attr::mk_attr_id(),\n-                style: style,\n-                value: value,\n-                is_sugared_doc: false,\n-            },\n         })\n     }\n \n@@ -172,15 +165,14 @@ impl<'a> Parser<'a> {\n                     }\n \n                     let attr = self.parse_attribute(true)?;\n-                    assert!(attr.node.style == ast::AttrStyle::Inner);\n+                    assert!(attr.style == ast::AttrStyle::Inner);\n                     attrs.push(attr);\n                 }\n                 token::DocComment(s) => {\n                     // we need to get the position of this token before we bump.\n                     let Span { lo, hi, .. } = self.span;\n-                    let str = self.id_to_interned_str(ast::Ident::with_empty_ctxt(s));\n-                    let attr = attr::mk_sugared_doc_attr(attr::mk_attr_id(), str, lo, hi);\n-                    if attr.node.style == ast::AttrStyle::Inner {\n+                    let attr = attr::mk_sugared_doc_attr(attr::mk_attr_id(), s, lo, hi);\n+                    if attr.style == ast::AttrStyle::Inner {\n                         attrs.push(attr);\n                         self.bump();\n                     } else {\n@@ -213,7 +205,7 @@ impl<'a> Parser<'a> {\n     ///\n     /// meta_item : IDENT ( '=' UNSUFFIXED_LIT | '(' meta_item_inner? ')' )? ;\n     /// meta_item_inner : (meta_item | UNSUFFIXED_LIT) (',' meta_item_inner)? ;\n-    pub fn parse_meta_item(&mut self) -> PResult<'a, P<ast::MetaItem>> {\n+    pub fn parse_meta_item(&mut self) -> PResult<'a, ast::MetaItem> {\n         let nt_meta = match self.token {\n             token::Interpolated(ref nt) => match **nt {\n                 token::NtMeta(ref e) => Some(e.clone()),\n@@ -229,24 +221,15 @@ impl<'a> Parser<'a> {\n \n         let lo = self.span.lo;\n         let ident = self.parse_ident()?;\n-        let name = self.id_to_interned_str(ident);\n-        match self.token {\n-            token::Eq => {\n-                self.bump();\n-                let lit = self.parse_unsuffixed_lit()?;\n-                let hi = self.prev_span.hi;\n-                Ok(P(spanned(lo, hi, ast::MetaItemKind::NameValue(name, lit))))\n-            }\n-            token::OpenDelim(token::Paren) => {\n-                let inner_items = self.parse_meta_seq()?;\n-                let hi = self.prev_span.hi;\n-                Ok(P(spanned(lo, hi, ast::MetaItemKind::List(name, inner_items))))\n-            }\n-            _ => {\n-                let hi = self.prev_span.hi;\n-                Ok(P(spanned(lo, hi, ast::MetaItemKind::Word(name))))\n-            }\n-        }\n+        let node = if self.eat(&token::Eq) {\n+            ast::MetaItemKind::NameValue(self.parse_unsuffixed_lit()?)\n+        } else if self.token == token::OpenDelim(token::Paren) {\n+            ast::MetaItemKind::List(self.parse_meta_seq()?)\n+        } else {\n+            ast::MetaItemKind::Word\n+        };\n+        let hi = self.prev_span.hi;\n+        Ok(ast::MetaItem { name: ident.name, node: node, span: mk_sp(lo, hi) })\n     }\n \n     /// matches meta_item_inner : (meta_item | UNSUFFIXED_LIT) ;"}, {"sha": "681dec0ab564d1c922cf60320583f43314e06331", "filename": "src/libsyntax/parse/lexer/mod.rs", "status": "modified", "additions": 38, "deletions": 36, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=ebec55406ba94faf8b2cd23b27a8f74df97d1ca4", "patch": "@@ -8,13 +8,14 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use ast;\n+use ast::{self, Ident};\n use syntax_pos::{self, BytePos, CharPos, Pos, Span};\n use codemap::CodeMap;\n use errors::{FatalError, Handler, DiagnosticBuilder};\n use ext::tt::transcribe::tt_next_token;\n-use parse::token::{self, keywords, str_to_ident};\n+use parse::token;\n use str::char_at;\n+use symbol::{Symbol, keywords};\n use rustc_unicode::property::Pattern_White_Space;\n \n use std::borrow::Cow;\n@@ -350,13 +351,13 @@ impl<'a> StringReader<'a> {\n     /// single-byte delimiter).\n     pub fn name_from(&self, start: BytePos) -> ast::Name {\n         debug!(\"taking an ident from {:?} to {:?}\", start, self.pos);\n-        self.with_str_from(start, token::intern)\n+        self.with_str_from(start, Symbol::intern)\n     }\n \n     /// As name_from, with an explicit endpoint.\n     pub fn name_from_to(&self, start: BytePos, end: BytePos) -> ast::Name {\n         debug!(\"taking an ident from {:?} to {:?}\", start, end);\n-        self.with_str_from_to(start, end, token::intern)\n+        self.with_str_from_to(start, end, Symbol::intern)\n     }\n \n     /// Calls `f` with a string slice of the source text spanning from `start`\n@@ -492,7 +493,7 @@ impl<'a> StringReader<'a> {\n             if string == \"_\" {\n                 None\n             } else {\n-                Some(token::intern(string))\n+                Some(Symbol::intern(string))\n             }\n         })\n     }\n@@ -540,7 +541,7 @@ impl<'a> StringReader<'a> {\n                         self.with_str_from(start_bpos, |string| {\n                             // comments with only more \"/\"s are not doc comments\n                             let tok = if is_doc_comment(string) {\n-                                token::DocComment(token::intern(string))\n+                                token::DocComment(Symbol::intern(string))\n                             } else {\n                                 token::Comment\n                             };\n@@ -669,7 +670,7 @@ impl<'a> StringReader<'a> {\n                 } else {\n                     string.into()\n                 };\n-                token::DocComment(token::intern(&string[..]))\n+                token::DocComment(Symbol::intern(&string[..]))\n             } else {\n                 token::Comment\n             };\n@@ -758,7 +759,7 @@ impl<'a> StringReader<'a> {\n             self.err_span_(start_bpos,\n                            self.pos,\n                            \"no valid digits found for number\");\n-            return token::Integer(token::intern(\"0\"));\n+            return token::Integer(Symbol::intern(\"0\"));\n         }\n \n         // might be a float, but don't be greedy if this is actually an\n@@ -1097,7 +1098,7 @@ impl<'a> StringReader<'a> {\n                     token::Underscore\n                 } else {\n                     // FIXME: perform NFKC normalization here. (Issue #2253)\n-                    token::Ident(str_to_ident(string))\n+                    token::Ident(Ident::from_str(string))\n                 }\n             }));\n         }\n@@ -1277,13 +1278,13 @@ impl<'a> StringReader<'a> {\n                     // expansion purposes. See #12512 for the gory details of why\n                     // this is necessary.\n                     let ident = self.with_str_from(start, |lifetime_name| {\n-                        str_to_ident(&format!(\"'{}\", lifetime_name))\n+                        Ident::from_str(&format!(\"'{}\", lifetime_name))\n                     });\n \n                     // Conjure up a \"keyword checking ident\" to make sure that\n                     // the lifetime name is not a keyword.\n                     let keyword_checking_ident = self.with_str_from(start, |lifetime_name| {\n-                        str_to_ident(lifetime_name)\n+                        Ident::from_str(lifetime_name)\n                     });\n                     let keyword_checking_token = &token::Ident(keyword_checking_ident);\n                     let last_bpos = self.pos;\n@@ -1310,7 +1311,7 @@ impl<'a> StringReader<'a> {\n                 let id = if valid {\n                     self.name_from(start)\n                 } else {\n-                    token::intern(\"0\")\n+                    Symbol::intern(\"0\")\n                 };\n                 self.bump(); // advance ch past token\n                 let suffix = self.scan_optional_raw_name();\n@@ -1352,7 +1353,7 @@ impl<'a> StringReader<'a> {\n                 let id = if valid {\n                     self.name_from(start_bpos + BytePos(1))\n                 } else {\n-                    token::intern(\"??\")\n+                    Symbol::intern(\"??\")\n                 };\n                 self.bump();\n                 let suffix = self.scan_optional_raw_name();\n@@ -1424,7 +1425,7 @@ impl<'a> StringReader<'a> {\n                 let id = if valid {\n                     self.name_from_to(content_start_bpos, content_end_bpos)\n                 } else {\n-                    token::intern(\"??\")\n+                    Symbol::intern(\"??\")\n                 };\n                 let suffix = self.scan_optional_raw_name();\n                 return Ok(token::Literal(token::StrRaw(id, hash_count), suffix));\n@@ -1551,7 +1552,7 @@ impl<'a> StringReader<'a> {\n         let id = if valid {\n             self.name_from(start)\n         } else {\n-            token::intern(\"?\")\n+            Symbol::intern(\"?\")\n         };\n         self.bump(); // advance ch past token\n         return token::Byte(id);\n@@ -1584,7 +1585,7 @@ impl<'a> StringReader<'a> {\n         let id = if valid {\n             self.name_from(start)\n         } else {\n-            token::intern(\"??\")\n+            Symbol::intern(\"??\")\n         };\n         self.bump();\n         return token::ByteStr(id);\n@@ -1700,11 +1701,12 @@ fn ident_continue(c: Option<char>) -> bool {\n mod tests {\n     use super::*;\n \n+    use ast::Ident;\n+    use symbol::Symbol;\n     use syntax_pos::{BytePos, Span, NO_EXPANSION};\n     use codemap::CodeMap;\n     use errors;\n     use parse::token;\n-    use parse::token::str_to_ident;\n     use std::io;\n     use std::rc::Rc;\n \n@@ -1732,7 +1734,7 @@ mod tests {\n                                       &sh,\n                                       \"/* my source file */ fn main() { println!(\\\"zebra\\\"); }\\n\"\n                                           .to_string());\n-        let id = str_to_ident(\"fn\");\n+        let id = Ident::from_str(\"fn\");\n         assert_eq!(string_reader.next_token().tok, token::Comment);\n         assert_eq!(string_reader.next_token().tok, token::Whitespace);\n         let tok1 = string_reader.next_token();\n@@ -1751,7 +1753,7 @@ mod tests {\n         // read another token:\n         let tok3 = string_reader.next_token();\n         let tok4 = TokenAndSpan {\n-            tok: token::Ident(str_to_ident(\"main\")),\n+            tok: token::Ident(Ident::from_str(\"main\")),\n             sp: Span {\n                 lo: BytePos(24),\n                 hi: BytePos(28),\n@@ -1773,7 +1775,7 @@ mod tests {\n \n     // make the identifier by looking up the string in the interner\n     fn mk_ident(id: &str) -> token::Token {\n-        token::Ident(str_to_ident(id))\n+        token::Ident(Ident::from_str(id))\n     }\n \n     #[test]\n@@ -1813,31 +1815,31 @@ mod tests {\n         let cm = Rc::new(CodeMap::new());\n         let sh = mk_sh(cm.clone());\n         assert_eq!(setup(&cm, &sh, \"'a'\".to_string()).next_token().tok,\n-                   token::Literal(token::Char(token::intern(\"a\")), None));\n+                   token::Literal(token::Char(Symbol::intern(\"a\")), None));\n     }\n \n     #[test]\n     fn character_space() {\n         let cm = Rc::new(CodeMap::new());\n         let sh = mk_sh(cm.clone());\n         assert_eq!(setup(&cm, &sh, \"' '\".to_string()).next_token().tok,\n-                   token::Literal(token::Char(token::intern(\" \")), None));\n+                   token::Literal(token::Char(Symbol::intern(\" \")), None));\n     }\n \n     #[test]\n     fn character_escaped() {\n         let cm = Rc::new(CodeMap::new());\n         let sh = mk_sh(cm.clone());\n         assert_eq!(setup(&cm, &sh, \"'\\\\n'\".to_string()).next_token().tok,\n-                   token::Literal(token::Char(token::intern(\"\\\\n\")), None));\n+                   token::Literal(token::Char(Symbol::intern(\"\\\\n\")), None));\n     }\n \n     #[test]\n     fn lifetime_name() {\n         let cm = Rc::new(CodeMap::new());\n         let sh = mk_sh(cm.clone());\n         assert_eq!(setup(&cm, &sh, \"'abc\".to_string()).next_token().tok,\n-                   token::Lifetime(token::str_to_ident(\"'abc\")));\n+                   token::Lifetime(Ident::from_str(\"'abc\")));\n     }\n \n     #[test]\n@@ -1847,7 +1849,7 @@ mod tests {\n         assert_eq!(setup(&cm, &sh, \"r###\\\"\\\"#a\\\\b\\x00c\\\"\\\"###\".to_string())\n                        .next_token()\n                        .tok,\n-                   token::Literal(token::StrRaw(token::intern(\"\\\"#a\\\\b\\x00c\\\"\"), 3), None));\n+                   token::Literal(token::StrRaw(Symbol::intern(\"\\\"#a\\\\b\\x00c\\\"\"), 3), None));\n     }\n \n     #[test]\n@@ -1857,11 +1859,11 @@ mod tests {\n         macro_rules! test {\n             ($input: expr, $tok_type: ident, $tok_contents: expr) => {{\n                 assert_eq!(setup(&cm, &sh, format!(\"{}suffix\", $input)).next_token().tok,\n-                           token::Literal(token::$tok_type(token::intern($tok_contents)),\n-                                          Some(token::intern(\"suffix\"))));\n+                           token::Literal(token::$tok_type(Symbol::intern($tok_contents)),\n+                                          Some(Symbol::intern(\"suffix\"))));\n                 // with a whitespace separator:\n                 assert_eq!(setup(&cm, &sh, format!(\"{} suffix\", $input)).next_token().tok,\n-                           token::Literal(token::$tok_type(token::intern($tok_contents)),\n+                           token::Literal(token::$tok_type(Symbol::intern($tok_contents)),\n                                           None));\n             }}\n         }\n@@ -1877,14 +1879,14 @@ mod tests {\n         test!(\"1.0e10\", Float, \"1.0e10\");\n \n         assert_eq!(setup(&cm, &sh, \"2us\".to_string()).next_token().tok,\n-                   token::Literal(token::Integer(token::intern(\"2\")),\n-                                  Some(token::intern(\"us\"))));\n+                   token::Literal(token::Integer(Symbol::intern(\"2\")),\n+                                  Some(Symbol::intern(\"us\"))));\n         assert_eq!(setup(&cm, &sh, \"r###\\\"raw\\\"###suffix\".to_string()).next_token().tok,\n-                   token::Literal(token::StrRaw(token::intern(\"raw\"), 3),\n-                                  Some(token::intern(\"suffix\"))));\n+                   token::Literal(token::StrRaw(Symbol::intern(\"raw\"), 3),\n+                                  Some(Symbol::intern(\"suffix\"))));\n         assert_eq!(setup(&cm, &sh, \"br###\\\"raw\\\"###suffix\".to_string()).next_token().tok,\n-                   token::Literal(token::ByteStrRaw(token::intern(\"raw\"), 3),\n-                                  Some(token::intern(\"suffix\"))));\n+                   token::Literal(token::ByteStrRaw(Symbol::intern(\"raw\"), 3),\n+                                  Some(Symbol::intern(\"suffix\"))));\n     }\n \n     #[test]\n@@ -1904,7 +1906,7 @@ mod tests {\n             _ => panic!(\"expected a comment!\"),\n         }\n         assert_eq!(lexer.next_token().tok,\n-                   token::Literal(token::Char(token::intern(\"a\")), None));\n+                   token::Literal(token::Char(Symbol::intern(\"a\")), None));\n     }\n \n     #[test]\n@@ -1917,6 +1919,6 @@ mod tests {\n         assert_eq!(comment.sp, ::syntax_pos::mk_sp(BytePos(0), BytePos(7)));\n         assert_eq!(lexer.next_token().tok, token::Whitespace);\n         assert_eq!(lexer.next_token().tok,\n-                   token::DocComment(token::intern(\"/// test\")));\n+                   token::DocComment(Symbol::intern(\"/// test\")));\n     }\n }"}, {"sha": "be340a5b5aa93e0a9fca53629de5bfe931f30aa3", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 48, "deletions": 55, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=ebec55406ba94faf8b2cd23b27a8f74df97d1ca4", "patch": "@@ -16,12 +16,13 @@ use syntax_pos::{self, Span, FileMap};\n use errors::{Handler, ColorConfig, DiagnosticBuilder};\n use feature_gate::UnstableFeatures;\n use parse::parser::Parser;\n-use parse::token::InternedString;\n use ptr::P;\n use str::char_at;\n+use symbol::Symbol;\n use tokenstream;\n \n use std::cell::RefCell;\n+use std::collections::HashSet;\n use std::iter;\n use std::path::{Path, PathBuf};\n use std::rc::Rc;\n@@ -64,7 +65,7 @@ impl ParseSess {\n         ParseSess {\n             span_diagnostic: handler,\n             unstable_features: UnstableFeatures::from_environment(),\n-            config: Vec::new(),\n+            config: HashSet::new(),\n             included_mod_stack: RefCell::new(vec![]),\n             code_map: code_map\n         }\n@@ -116,7 +117,7 @@ pub fn parse_item_from_source_str<'a>(name: String, source: String, sess: &'a Pa\n }\n \n pub fn parse_meta_from_source_str<'a>(name: String, source: String, sess: &'a ParseSess)\n-                                      -> PResult<'a, P<ast::MetaItem>> {\n+                                      -> PResult<'a, ast::MetaItem> {\n     new_parser_from_source_str(sess, name, source).parse_meta_item()\n }\n \n@@ -371,13 +372,18 @@ fn looks_like_width_suffix(first_chars: &[char], s: &str) -> bool {\n         s[1..].chars().all(|c| '0' <= c && c <= '9')\n }\n \n-fn filtered_float_lit(data: token::InternedString, suffix: Option<&str>,\n-                      sd: &Handler, sp: Span) -> ast::LitKind {\n+fn filtered_float_lit(data: Symbol, suffix: Option<Symbol>, sd: &Handler, sp: Span)\n+                      -> ast::LitKind {\n     debug!(\"filtered_float_lit: {}, {:?}\", data, suffix);\n-    match suffix.as_ref().map(|s| &**s) {\n-        Some(\"f32\") => ast::LitKind::Float(data, ast::FloatTy::F32),\n-        Some(\"f64\") => ast::LitKind::Float(data, ast::FloatTy::F64),\n-        Some(suf) => {\n+    let suffix = match suffix {\n+        Some(suffix) => suffix,\n+        None => return ast::LitKind::FloatUnsuffixed(data),\n+    };\n+\n+    match &*suffix.as_str() {\n+        \"f32\" => ast::LitKind::Float(data, ast::FloatTy::F32),\n+        \"f64\" => ast::LitKind::Float(data, ast::FloatTy::F64),\n+        suf => {\n             if suf.len() >= 2 && looks_like_width_suffix(&['f'], suf) {\n                 // if it looks like a width, lets try to be helpful.\n                 sd.struct_span_err(sp, &format!(\"invalid width `{}` for float literal\", &suf[1..]))\n@@ -391,16 +397,13 @@ fn filtered_float_lit(data: token::InternedString, suffix: Option<&str>,\n \n             ast::LitKind::FloatUnsuffixed(data)\n         }\n-        None => ast::LitKind::FloatUnsuffixed(data)\n     }\n }\n-pub fn float_lit(s: &str, suffix: Option<InternedString>,\n-                 sd: &Handler, sp: Span) -> ast::LitKind {\n+pub fn float_lit(s: &str, suffix: Option<Symbol>, sd: &Handler, sp: Span) -> ast::LitKind {\n     debug!(\"float_lit: {:?}, {:?}\", s, suffix);\n     // FIXME #2252: bounds checking float literals is deferred until trans\n     let s = s.chars().filter(|&c| c != '_').collect::<String>();\n-    let data = token::intern_and_get_ident(&s);\n-    filtered_float_lit(data, suffix.as_ref().map(|s| &**s), sd, sp)\n+    filtered_float_lit(Symbol::intern(&s), suffix, sd, sp)\n }\n \n /// Parse a string representing a byte literal into its final form. Similar to `char_lit`\n@@ -495,11 +498,7 @@ pub fn byte_str_lit(lit: &str) -> Rc<Vec<u8>> {\n     Rc::new(res)\n }\n \n-pub fn integer_lit(s: &str,\n-                   suffix: Option<InternedString>,\n-                   sd: &Handler,\n-                   sp: Span)\n-                   -> ast::LitKind {\n+pub fn integer_lit(s: &str, suffix: Option<Symbol>, sd: &Handler, sp: Span) -> ast::LitKind {\n     // s can only be ascii, byte indexing is fine\n \n     let s2 = s.chars().filter(|&c| c != '_').collect::<String>();\n@@ -521,26 +520,25 @@ pub fn integer_lit(s: &str,\n     }\n \n     // 1f64 and 2f32 etc. are valid float literals.\n-    if let Some(ref suf) = suffix {\n-        if looks_like_width_suffix(&['f'], suf) {\n+    if let Some(suf) = suffix {\n+        if looks_like_width_suffix(&['f'], &suf.as_str()) {\n             match base {\n                 16 => sd.span_err(sp, \"hexadecimal float literal is not supported\"),\n                 8 => sd.span_err(sp, \"octal float literal is not supported\"),\n                 2 => sd.span_err(sp, \"binary float literal is not supported\"),\n                 _ => ()\n             }\n-            let ident = token::intern_and_get_ident(&s);\n-            return filtered_float_lit(ident, Some(&suf), sd, sp)\n+            return filtered_float_lit(Symbol::intern(&s), Some(suf), sd, sp)\n         }\n     }\n \n     if base != 10 {\n         s = &s[2..];\n     }\n \n-    if let Some(ref suf) = suffix {\n-        if suf.is_empty() { sd.span_bug(sp, \"found empty literal suffix in Some\")}\n-        ty = match &**suf {\n+    if let Some(suf) = suffix {\n+        if suf.as_str().is_empty() { sd.span_bug(sp, \"found empty literal suffix in Some\")}\n+        ty = match &*suf.as_str() {\n             \"isize\" => ast::LitIntType::Signed(ast::IntTy::Is),\n             \"i8\"  => ast::LitIntType::Signed(ast::IntTy::I8),\n             \"i16\" => ast::LitIntType::Signed(ast::IntTy::I16),\n@@ -551,7 +549,7 @@ pub fn integer_lit(s: &str,\n             \"u16\" => ast::LitIntType::Unsigned(ast::UintTy::U16),\n             \"u32\" => ast::LitIntType::Unsigned(ast::UintTy::U32),\n             \"u64\" => ast::LitIntType::Unsigned(ast::UintTy::U64),\n-            _ => {\n+            suf => {\n                 // i<digits> and u<digits> look like widths, so lets\n                 // give an error message along those lines\n                 if looks_like_width_suffix(&['i', 'u'], suf) {\n@@ -599,12 +597,11 @@ mod tests {\n     use std::rc::Rc;\n     use syntax_pos::{self, Span, BytePos, Pos, NO_EXPANSION};\n     use codemap::Spanned;\n-    use ast::{self, PatKind};\n+    use ast::{self, Ident, PatKind};\n     use abi::Abi;\n     use attr::first_attr_value_str_by_name;\n     use parse;\n     use parse::parser::Parser;\n-    use parse::token::{str_to_ident};\n     use print::pprust::item_to_string;\n     use ptr::P;\n     use tokenstream::{self, TokenTree};\n@@ -626,7 +623,7 @@ mod tests {\n                         global: false,\n                         segments: vec![\n                             ast::PathSegment {\n-                                identifier: str_to_ident(\"a\"),\n+                                identifier: Ident::from_str(\"a\"),\n                                 parameters: ast::PathParameters::none(),\n                             }\n                         ],\n@@ -645,11 +642,11 @@ mod tests {\n                             global: true,\n                             segments: vec![\n                                 ast::PathSegment {\n-                                    identifier: str_to_ident(\"a\"),\n+                                    identifier: Ident::from_str(\"a\"),\n                                     parameters: ast::PathParameters::none(),\n                                 },\n                                 ast::PathSegment {\n-                                    identifier: str_to_ident(\"b\"),\n+                                    identifier: Ident::from_str(\"b\"),\n                                     parameters: ast::PathParameters::none(),\n                                 }\n                             ]\n@@ -678,8 +675,8 @@ mod tests {\n                 Some(&TokenTree::Token(_, token::Ident(name_zip))),\n                 Some(&TokenTree::Delimited(_, ref macro_delimed)),\n             )\n-            if name_macro_rules.name.as_str() == \"macro_rules\"\n-            && name_zip.name.as_str() == \"zip\" => {\n+            if name_macro_rules.name == \"macro_rules\"\n+            && name_zip.name == \"zip\" => {\n                 let tts = &macro_delimed.tts[..];\n                 match (tts.len(), tts.get(0), tts.get(1), tts.get(2)) {\n                     (\n@@ -696,8 +693,7 @@ mod tests {\n                                 Some(&TokenTree::Token(_, token::Dollar)),\n                                 Some(&TokenTree::Token(_, token::Ident(ident))),\n                             )\n-                            if first_delimed.delim == token::Paren\n-                            && ident.name.as_str() == \"a\" => {},\n+                            if first_delimed.delim == token::Paren && ident.name == \"a\" => {},\n                             _ => panic!(\"value 3: {:?}\", **first_delimed),\n                         }\n                         let tts = &second_delimed.tts[..];\n@@ -708,7 +704,7 @@ mod tests {\n                                 Some(&TokenTree::Token(_, token::Ident(ident))),\n                             )\n                             if second_delimed.delim == token::Paren\n-                            && ident.name.as_str() == \"a\" => {},\n+                            && ident.name == \"a\" => {},\n                             _ => panic!(\"value 4: {:?}\", **second_delimed),\n                         }\n                     },\n@@ -724,17 +720,17 @@ mod tests {\n         let tts = string_to_tts(\"fn a (b : i32) { b; }\".to_string());\n \n         let expected = vec![\n-            TokenTree::Token(sp(0, 2), token::Ident(str_to_ident(\"fn\"))),\n-            TokenTree::Token(sp(3, 4), token::Ident(str_to_ident(\"a\"))),\n+            TokenTree::Token(sp(0, 2), token::Ident(Ident::from_str(\"fn\"))),\n+            TokenTree::Token(sp(3, 4), token::Ident(Ident::from_str(\"a\"))),\n             TokenTree::Delimited(\n                 sp(5, 14),\n                 Rc::new(tokenstream::Delimited {\n                     delim: token::DelimToken::Paren,\n                     open_span: sp(5, 6),\n                     tts: vec![\n-                        TokenTree::Token(sp(6, 7), token::Ident(str_to_ident(\"b\"))),\n+                        TokenTree::Token(sp(6, 7), token::Ident(Ident::from_str(\"b\"))),\n                         TokenTree::Token(sp(8, 9), token::Colon),\n-                        TokenTree::Token(sp(10, 13), token::Ident(str_to_ident(\"i32\"))),\n+                        TokenTree::Token(sp(10, 13), token::Ident(Ident::from_str(\"i32\"))),\n                     ],\n                     close_span: sp(13, 14),\n                 })),\n@@ -744,7 +740,7 @@ mod tests {\n                     delim: token::DelimToken::Brace,\n                     open_span: sp(15, 16),\n                     tts: vec![\n-                        TokenTree::Token(sp(17, 18), token::Ident(str_to_ident(\"b\"))),\n+                        TokenTree::Token(sp(17, 18), token::Ident(Ident::from_str(\"b\"))),\n                         TokenTree::Token(sp(18, 19), token::Semi),\n                     ],\n                     close_span: sp(20, 21),\n@@ -765,7 +761,7 @@ mod tests {\n                             global: false,\n                             segments: vec![\n                                 ast::PathSegment {\n-                                    identifier: str_to_ident(\"d\"),\n+                                    identifier: Ident::from_str(\"d\"),\n                                     parameters: ast::PathParameters::none(),\n                                 }\n                             ],\n@@ -788,7 +784,7 @@ mod tests {\n                                global:false,\n                                segments: vec![\n                                 ast::PathSegment {\n-                                    identifier: str_to_ident(\"b\"),\n+                                    identifier: Ident::from_str(\"b\"),\n                                     parameters: ast::PathParameters::none(),\n                                 }\n                                ],\n@@ -812,7 +808,7 @@ mod tests {\n                 id: ast::DUMMY_NODE_ID,\n                 node: PatKind::Ident(ast::BindingMode::ByValue(ast::Mutability::Immutable),\n                                     Spanned{ span:sp(0, 1),\n-                                             node: str_to_ident(\"b\")\n+                                             node: Ident::from_str(\"b\")\n                     },\n                                     None),\n                 span: sp(0,1)}));\n@@ -824,7 +820,7 @@ mod tests {\n         // this test depends on the intern order of \"fn\" and \"i32\"\n         assert_eq!(string_to_item(\"fn a (b : i32) { b; }\".to_string()),\n                   Some(\n-                      P(ast::Item{ident:str_to_ident(\"a\"),\n+                      P(ast::Item{ident:Ident::from_str(\"a\"),\n                             attrs:Vec::new(),\n                             id: ast::DUMMY_NODE_ID,\n                             node: ast::ItemKind::Fn(P(ast::FnDecl {\n@@ -835,8 +831,7 @@ mod tests {\n                                         global:false,\n                                         segments: vec![\n                                             ast::PathSegment {\n-                                                identifier:\n-                                                    str_to_ident(\"i32\"),\n+                                                identifier: Ident::from_str(\"i32\"),\n                                                 parameters: ast::PathParameters::none(),\n                                             }\n                                         ],\n@@ -849,7 +844,7 @@ mod tests {\n                                             ast::BindingMode::ByValue(ast::Mutability::Immutable),\n                                                 Spanned{\n                                                     span: sp(6,7),\n-                                                    node: str_to_ident(\"b\")},\n+                                                    node: Ident::from_str(\"b\")},\n                                                 None\n                                                     ),\n                                             span: sp(6,7)\n@@ -884,9 +879,7 @@ mod tests {\n                                                         global:false,\n                                                         segments: vec![\n                                                             ast::PathSegment {\n-                                                                identifier:\n-                                                                str_to_ident(\n-                                                                    \"b\"),\n+                                                                identifier: Ident::from_str(\"b\"),\n                                                                 parameters:\n                                                                 ast::PathParameters::none(),\n                                                             }\n@@ -998,20 +991,20 @@ mod tests {\n         let item = parse_item_from_source_str(name.clone(), source, &sess)\n             .unwrap().unwrap();\n         let doc = first_attr_value_str_by_name(&item.attrs, \"doc\").unwrap();\n-        assert_eq!(&doc[..], \"/// doc comment\");\n+        assert_eq!(doc, \"/// doc comment\");\n \n         let source = \"/// doc comment\\r\\n/// line 2\\r\\nfn foo() {}\".to_string();\n         let item = parse_item_from_source_str(name.clone(), source, &sess)\n             .unwrap().unwrap();\n-        let docs = item.attrs.iter().filter(|a| &*a.name() == \"doc\")\n+        let docs = item.attrs.iter().filter(|a| a.name() == \"doc\")\n                     .map(|a| a.value_str().unwrap().to_string()).collect::<Vec<_>>();\n         let b: &[_] = &[\"/// doc comment\".to_string(), \"/// line 2\".to_string()];\n         assert_eq!(&docs[..], b);\n \n         let source = \"/** doc comment\\r\\n *  with CRLF */\\r\\nfn foo() {}\".to_string();\n         let item = parse_item_from_source_str(name, source, &sess).unwrap().unwrap();\n         let doc = first_attr_value_str_by_name(&item.attrs, \"doc\").unwrap();\n-        assert_eq!(&doc[..], \"/** doc comment\\n *  with CRLF */\");\n+        assert_eq!(doc, \"/** doc comment\\n *  with CRLF */\");\n     }\n \n     #[test]"}, {"sha": "4997e464c2bf533987d9c6ca86cb81431835279a", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 27, "deletions": 48, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=ebec55406ba94faf8b2cd23b27a8f74df97d1ca4", "patch": "@@ -48,13 +48,14 @@ use parse::classify;\n use parse::common::SeqSep;\n use parse::lexer::{Reader, TokenAndSpan};\n use parse::obsolete::ObsoleteSyntax;\n-use parse::token::{self, intern, keywords, MatchNt, SubstNt, InternedString};\n+use parse::token::{self, MatchNt, SubstNt};\n use parse::{new_sub_parser_from_file, ParseSess};\n use util::parser::{AssocOp, Fixity};\n use print::pprust;\n use ptr::P;\n use parse::PResult;\n use tokenstream::{self, Delimited, SequenceRepetition, TokenTree};\n+use symbol::{Symbol, keywords};\n use util::ThinVec;\n \n use std::collections::HashSet;\n@@ -998,10 +999,6 @@ impl<'a> Parser<'a> {\n         &self.sess.span_diagnostic\n     }\n \n-    pub fn id_to_interned_str(&mut self, id: Ident) -> InternedString {\n-        id.name.as_str()\n-    }\n-\n     /// Is the current token one of the keywords that signals a bare function\n     /// type?\n     pub fn token_is_bare_fn_keyword(&mut self) -> bool {\n@@ -1523,34 +1520,28 @@ impl<'a> Parser<'a> {\n                     // float literals, so all the handling is done\n                     // internally.\n                     token::Integer(s) => {\n-                        (false, parse::integer_lit(&s.as_str(),\n-                                                   suf.as_ref().map(|s| s.as_str()),\n-                                                   &self.sess.span_diagnostic,\n-                                                   self.span))\n+                        let diag = &self.sess.span_diagnostic;\n+                        (false, parse::integer_lit(&s.as_str(), suf, diag, self.span))\n                     }\n                     token::Float(s) => {\n-                        (false, parse::float_lit(&s.as_str(),\n-                                                 suf.as_ref().map(|s| s.as_str()),\n-                                                  &self.sess.span_diagnostic,\n-                                                 self.span))\n+                        let diag = &self.sess.span_diagnostic;\n+                        (false, parse::float_lit(&s.as_str(), suf, diag, self.span))\n                     }\n \n                     token::Str_(s) => {\n-                        (true,\n-                         LitKind::Str(token::intern_and_get_ident(&parse::str_lit(&s.as_str())),\n-                                      ast::StrStyle::Cooked))\n+                        let s = Symbol::intern(&parse::str_lit(&s.as_str()));\n+                        (true, LitKind::Str(s, ast::StrStyle::Cooked))\n                     }\n                     token::StrRaw(s, n) => {\n-                        (true,\n-                         LitKind::Str(\n-                            token::intern_and_get_ident(&parse::raw_str_lit(&s.as_str())),\n-                            ast::StrStyle::Raw(n)))\n+                        let s = Symbol::intern(&parse::raw_str_lit(&s.as_str()));\n+                        (true, LitKind::Str(s, ast::StrStyle::Raw(n)))\n+                    }\n+                    token::ByteStr(i) => {\n+                        (true, LitKind::ByteStr(parse::byte_str_lit(&i.as_str())))\n+                    }\n+                    token::ByteStrRaw(i, _) => {\n+                        (true, LitKind::ByteStr(Rc::new(i.to_string().into_bytes())))\n                     }\n-                    token::ByteStr(i) =>\n-                        (true, LitKind::ByteStr(parse::byte_str_lit(&i.as_str()))),\n-                    token::ByteStrRaw(i, _) =>\n-                        (true,\n-                         LitKind::ByteStr(Rc::new(i.to_string().into_bytes()))),\n                 };\n \n                 if suffix_illegal {\n@@ -2544,7 +2535,7 @@ impl<'a> Parser<'a> {\n                     let prev_span = self.prev_span;\n                     let fstr = n.as_str();\n                     let mut err = self.diagnostic().struct_span_err(prev_span,\n-                        &format!(\"unexpected token: `{}`\", n.as_str()));\n+                        &format!(\"unexpected token: `{}`\", n));\n                     if fstr.chars().all(|x| \"0123456789.\".contains(x)) {\n                         let float = match fstr.parse::<f64>().ok() {\n                             Some(f) => f,\n@@ -2627,7 +2618,7 @@ impl<'a> Parser<'a> {\n                                       })));\n                 } else if self.token.is_keyword(keywords::Crate) {\n                     let ident = match self.token {\n-                        token::Ident(id) => ast::Ident { name: token::intern(\"$crate\"), ..id },\n+                        token::Ident(id) => ast::Ident { name: Symbol::intern(\"$crate\"), ..id },\n                         _ => unreachable!(),\n                     };\n                     self.bump();\n@@ -3751,9 +3742,7 @@ impl<'a> Parser<'a> {\n     /// Emit an expected item after attributes error.\n     fn expected_item_err(&self, attrs: &[Attribute]) {\n         let message = match attrs.last() {\n-            Some(&Attribute { node: ast::Attribute_ { is_sugared_doc: true, .. }, .. }) => {\n-                \"expected item after doc comment\"\n-            }\n+            Some(&Attribute { is_sugared_doc: true, .. }) => \"expected item after doc comment\",\n             _ => \"expected item after attributes\",\n         };\n \n@@ -4837,7 +4826,7 @@ impl<'a> Parser<'a> {\n             Visibility::Inherited => (),\n             _ => {\n                 let is_macro_rules: bool = match self.token {\n-                    token::Ident(sid) => sid.name == intern(\"macro_rules\"),\n+                    token::Ident(sid) => sid.name == Symbol::intern(\"macro_rules\"),\n                     _ => false,\n                 };\n                 if is_macro_rules {\n@@ -5304,17 +5293,16 @@ impl<'a> Parser<'a> {\n \n     fn push_directory(&mut self, id: Ident, attrs: &[Attribute]) -> Restrictions {\n         if let Some(path) = ::attr::first_attr_value_str_by_name(attrs, \"path\") {\n-            self.directory.push(&*path);\n+            self.directory.push(&*path.as_str());\n             self.restrictions - Restrictions::NO_NONINLINE_MOD\n         } else {\n-            let default_path = self.id_to_interned_str(id);\n-            self.directory.push(&*default_path);\n+            self.directory.push(&*id.name.as_str());\n             self.restrictions\n         }\n     }\n \n     pub fn submod_path_from_attr(attrs: &[ast::Attribute], dir_path: &Path) -> Option<PathBuf> {\n-        ::attr::first_attr_value_str_by_name(attrs, \"path\").map(|d| dir_path.join(&*d))\n+        ::attr::first_attr_value_str_by_name(attrs, \"path\").map(|d| dir_path.join(&*d.as_str()))\n     }\n \n     /// Returns either a path to a module, or .\n@@ -6128,26 +6116,17 @@ impl<'a> Parser<'a> {\n         })\n     }\n \n-    pub fn parse_optional_str(&mut self)\n-                              -> Option<(InternedString,\n-                                         ast::StrStyle,\n-                                         Option<ast::Name>)> {\n+    pub fn parse_optional_str(&mut self) -> Option<(Symbol, ast::StrStyle, Option<ast::Name>)> {\n         let ret = match self.token {\n-            token::Literal(token::Str_(s), suf) => {\n-                let s = self.id_to_interned_str(ast::Ident::with_empty_ctxt(s));\n-                (s, ast::StrStyle::Cooked, suf)\n-            }\n-            token::Literal(token::StrRaw(s, n), suf) => {\n-                let s = self.id_to_interned_str(ast::Ident::with_empty_ctxt(s));\n-                (s, ast::StrStyle::Raw(n), suf)\n-            }\n+            token::Literal(token::Str_(s), suf) => (s, ast::StrStyle::Cooked, suf),\n+            token::Literal(token::StrRaw(s, n), suf) => (s, ast::StrStyle::Raw(n), suf),\n             _ => return None\n         };\n         self.bump();\n         Some(ret)\n     }\n \n-    pub fn parse_str(&mut self) -> PResult<'a, (InternedString, StrStyle)> {\n+    pub fn parse_str(&mut self) -> PResult<'a, (Symbol, StrStyle)> {\n         match self.parse_optional_str() {\n             Some((s, style, suf)) => {\n                 let sp = self.prev_span;"}, {"sha": "8ac39dd462e7cbf254667b21f5e12ae21329d352", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 2, "deletions": 272, "changes": 274, "blob_url": "https://github.com/rust-lang/rust/blob/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=ebec55406ba94faf8b2cd23b27a8f74df97d1ca4", "patch": "@@ -16,13 +16,10 @@ pub use self::Token::*;\n \n use ast::{self};\n use ptr::P;\n-use util::interner::Interner;\n+use symbol::keywords;\n use tokenstream;\n \n-use serialize::{Decodable, Decoder, Encodable, Encoder};\n-use std::cell::RefCell;\n use std::fmt;\n-use std::ops::Deref;\n use std::rc::Rc;\n \n #[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Eq, Hash, Debug, Copy)]\n@@ -301,7 +298,7 @@ pub enum Nonterminal {\n     NtTy(P<ast::Ty>),\n     NtIdent(ast::SpannedIdent),\n     /// Stuff inside brackets for attributes\n-    NtMeta(P<ast::MetaItem>),\n+    NtMeta(ast::MetaItem),\n     NtPath(ast::Path),\n     NtTT(tokenstream::TokenTree),\n     // These are not exposed to macros, but are used by quasiquote.\n@@ -335,270 +332,3 @@ impl fmt::Debug for Nonterminal {\n         }\n     }\n }\n-\n-// In this macro, there is the requirement that the name (the number) must be monotonically\n-// increasing by one in the special identifiers, starting at 0; the same holds for the keywords,\n-// except starting from the next number instead of zero.\n-macro_rules! declare_keywords {(\n-    $( ($index: expr, $konst: ident, $string: expr) )*\n-) => {\n-    pub mod keywords {\n-        use ast;\n-        #[derive(Clone, Copy, PartialEq, Eq)]\n-        pub struct Keyword {\n-            ident: ast::Ident,\n-        }\n-        impl Keyword {\n-            #[inline] pub fn ident(self) -> ast::Ident { self.ident }\n-            #[inline] pub fn name(self) -> ast::Name { self.ident.name }\n-        }\n-        $(\n-            #[allow(non_upper_case_globals)]\n-            pub const $konst: Keyword = Keyword {\n-                ident: ast::Ident::with_empty_ctxt(ast::Name($index))\n-            };\n-        )*\n-    }\n-\n-    fn mk_fresh_ident_interner() -> IdentInterner {\n-        Interner::prefill(&[$($string,)*])\n-    }\n-}}\n-\n-// NB: leaving holes in the ident table is bad! a different ident will get\n-// interned with the id from the hole, but it will be between the min and max\n-// of the reserved words, and thus tagged as \"reserved\".\n-// After modifying this list adjust `is_strict_keyword`/`is_reserved_keyword`,\n-// this should be rarely necessary though if the keywords are kept in alphabetic order.\n-declare_keywords! {\n-    // Invalid identifier\n-    (0,  Invalid,        \"\")\n-\n-    // Strict keywords used in the language.\n-    (1,  As,             \"as\")\n-    (2,  Box,            \"box\")\n-    (3,  Break,          \"break\")\n-    (4,  Const,          \"const\")\n-    (5,  Continue,       \"continue\")\n-    (6,  Crate,          \"crate\")\n-    (7,  Else,           \"else\")\n-    (8,  Enum,           \"enum\")\n-    (9,  Extern,         \"extern\")\n-    (10, False,          \"false\")\n-    (11, Fn,             \"fn\")\n-    (12, For,            \"for\")\n-    (13, If,             \"if\")\n-    (14, Impl,           \"impl\")\n-    (15, In,             \"in\")\n-    (16, Let,            \"let\")\n-    (17, Loop,           \"loop\")\n-    (18, Match,          \"match\")\n-    (19, Mod,            \"mod\")\n-    (20, Move,           \"move\")\n-    (21, Mut,            \"mut\")\n-    (22, Pub,            \"pub\")\n-    (23, Ref,            \"ref\")\n-    (24, Return,         \"return\")\n-    (25, SelfValue,      \"self\")\n-    (26, SelfType,       \"Self\")\n-    (27, Static,         \"static\")\n-    (28, Struct,         \"struct\")\n-    (29, Super,          \"super\")\n-    (30, Trait,          \"trait\")\n-    (31, True,           \"true\")\n-    (32, Type,           \"type\")\n-    (33, Unsafe,         \"unsafe\")\n-    (34, Use,            \"use\")\n-    (35, Where,          \"where\")\n-    (36, While,          \"while\")\n-\n-    // Keywords reserved for future use.\n-    (37, Abstract,       \"abstract\")\n-    (38, Alignof,        \"alignof\")\n-    (39, Become,         \"become\")\n-    (40, Do,             \"do\")\n-    (41, Final,          \"final\")\n-    (42, Macro,          \"macro\")\n-    (43, Offsetof,       \"offsetof\")\n-    (44, Override,       \"override\")\n-    (45, Priv,           \"priv\")\n-    (46, Proc,           \"proc\")\n-    (47, Pure,           \"pure\")\n-    (48, Sizeof,         \"sizeof\")\n-    (49, Typeof,         \"typeof\")\n-    (50, Unsized,        \"unsized\")\n-    (51, Virtual,        \"virtual\")\n-    (52, Yield,          \"yield\")\n-\n-    // Weak keywords, have special meaning only in specific contexts.\n-    (53, Default,        \"default\")\n-    (54, StaticLifetime, \"'static\")\n-    (55, Union,          \"union\")\n-}\n-\n-// looks like we can get rid of this completely...\n-pub type IdentInterner = Interner;\n-\n-// if an interner exists in TLS, return it. Otherwise, prepare a\n-// fresh one.\n-// FIXME(eddyb) #8726 This should probably use a thread-local reference.\n-pub fn with_ident_interner<T, F: FnOnce(&mut IdentInterner) -> T>(f: F) -> T {\n-    thread_local!(static KEY: RefCell<IdentInterner> = {\n-        RefCell::new(mk_fresh_ident_interner())\n-    });\n-    KEY.with(|interner| f(&mut *interner.borrow_mut()))\n-}\n-\n-/// Reset the ident interner to its initial state.\n-pub fn reset_ident_interner() {\n-    with_ident_interner(|interner| *interner = mk_fresh_ident_interner());\n-}\n-\n-pub fn clear_ident_interner() {\n-    with_ident_interner(|interner| *interner = IdentInterner::new());\n-}\n-\n-/// Represents a string stored in the thread-local interner. Because the\n-/// interner lives for the life of the thread, this can be safely treated as an\n-/// immortal string, as long as it never crosses between threads.\n-///\n-/// FIXME(pcwalton): You must be careful about what you do in the destructors\n-/// of objects stored in TLS, because they may run after the interner is\n-/// destroyed. In particular, they must not access string contents. This can\n-/// be fixed in the future by just leaking all strings until thread death\n-/// somehow.\n-#[derive(Clone, PartialEq, Hash, PartialOrd, Eq, Ord)]\n-pub struct InternedString {\n-    string: Rc<str>,\n-}\n-\n-impl InternedString {\n-    #[inline]\n-    pub fn new(string: &'static str) -> InternedString {\n-        InternedString {\n-            string: Rc::__from_str(string),\n-        }\n-    }\n-\n-    #[inline]\n-    pub fn new_from_name(name: ast::Name) -> InternedString {\n-        with_ident_interner(|interner| InternedString { string: interner.get(name) })\n-    }\n-}\n-\n-impl Deref for InternedString {\n-    type Target = str;\n-\n-    fn deref(&self) -> &str { &self.string }\n-}\n-\n-impl fmt::Debug for InternedString {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        fmt::Debug::fmt(&self.string, f)\n-    }\n-}\n-\n-impl fmt::Display for InternedString {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        fmt::Display::fmt(&self.string, f)\n-    }\n-}\n-\n-impl<'a> PartialEq<&'a str> for InternedString {\n-    #[inline(always)]\n-    fn eq(&self, other: & &'a str) -> bool {\n-        PartialEq::eq(&self.string[..], *other)\n-    }\n-    #[inline(always)]\n-    fn ne(&self, other: & &'a str) -> bool {\n-        PartialEq::ne(&self.string[..], *other)\n-    }\n-}\n-\n-impl<'a> PartialEq<InternedString> for &'a str {\n-    #[inline(always)]\n-    fn eq(&self, other: &InternedString) -> bool {\n-        PartialEq::eq(*self, &other.string[..])\n-    }\n-    #[inline(always)]\n-    fn ne(&self, other: &InternedString) -> bool {\n-        PartialEq::ne(*self, &other.string[..])\n-    }\n-}\n-\n-impl PartialEq<str> for InternedString {\n-    #[inline(always)]\n-    fn eq(&self, other: &str) -> bool {\n-        PartialEq::eq(&self.string[..], other)\n-    }\n-    #[inline(always)]\n-    fn ne(&self, other: &str) -> bool {\n-        PartialEq::ne(&self.string[..], other)\n-    }\n-}\n-\n-impl PartialEq<InternedString> for str {\n-    #[inline(always)]\n-    fn eq(&self, other: &InternedString) -> bool {\n-        PartialEq::eq(self, &other.string[..])\n-    }\n-    #[inline(always)]\n-    fn ne(&self, other: &InternedString) -> bool {\n-        PartialEq::ne(self, &other.string[..])\n-    }\n-}\n-\n-impl Decodable for InternedString {\n-    fn decode<D: Decoder>(d: &mut D) -> Result<InternedString, D::Error> {\n-        Ok(intern(&d.read_str()?).as_str())\n-    }\n-}\n-\n-impl Encodable for InternedString {\n-    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n-        s.emit_str(&self.string)\n-    }\n-}\n-\n-/// Interns and returns the string contents of an identifier, using the\n-/// thread-local interner.\n-#[inline]\n-pub fn intern_and_get_ident(s: &str) -> InternedString {\n-    intern(s).as_str()\n-}\n-\n-/// Maps a string to its interned representation.\n-#[inline]\n-pub fn intern(s: &str) -> ast::Name {\n-    with_ident_interner(|interner| interner.intern(s))\n-}\n-\n-/// gensym's a new usize, using the current interner.\n-#[inline]\n-pub fn gensym(s: &str) -> ast::Name {\n-    with_ident_interner(|interner| interner.gensym(s))\n-}\n-\n-/// Maps a string to an identifier with an empty syntax context.\n-#[inline]\n-pub fn str_to_ident(s: &str) -> ast::Ident {\n-    ast::Ident::with_empty_ctxt(intern(s))\n-}\n-\n-/// Maps a string to a gensym'ed identifier.\n-#[inline]\n-pub fn gensym_ident(s: &str) -> ast::Ident {\n-    ast::Ident::with_empty_ctxt(gensym(s))\n-}\n-\n-// create a fresh name that maps to the same string as the old one.\n-// note that this guarantees that str_ptr_eq(ident_to_string(src),interner_get(fresh_name(src)));\n-// that is, that the new name and the old one are connected to ptr_eq strings.\n-pub fn fresh_name(src: ast::Ident) -> ast::Name {\n-    with_ident_interner(|interner| interner.gensym_copy(src.name))\n-    // following: debug version. Could work in final except that it's incompatible with\n-    // good error messages and uses of struct names in ambiguous could-be-binding\n-    // locations. Also definitely destroys the guarantee given above about ptr_eq.\n-    /*let num = rand::thread_rng().gen_uint_range(0,0xffff);\n-    gensym(format!(\"{}_{}\",ident_to_string(src),num))*/\n-}"}, {"sha": "3820f5ea90ccc6e147e835b9515f63a12f8164dc", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 27, "deletions": 30, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=ebec55406ba94faf8b2cd23b27a8f74df97d1ca4", "patch": "@@ -19,14 +19,15 @@ use attr;\n use codemap::{self, CodeMap};\n use syntax_pos::{self, BytePos};\n use errors;\n-use parse::token::{self, keywords, BinOpToken, Token, InternedString};\n+use parse::token::{self, BinOpToken, Token};\n use parse::lexer::comments;\n use parse;\n use print::pp::{self, break_offset, word, space, zerobreak, hardbreak};\n use print::pp::{Breaks, eof};\n use print::pp::Breaks::{Consistent, Inconsistent};\n use ptr::P;\n use std_inject;\n+use symbol::{Symbol, keywords};\n use tokenstream::{self, TokenTree};\n \n use std::ascii;\n@@ -119,14 +120,13 @@ pub fn print_crate<'a>(cm: &'a CodeMap,\n         // of the feature gate, so we fake them up here.\n \n         // #![feature(prelude_import)]\n-        let prelude_import_meta = attr::mk_list_word_item(InternedString::new(\"prelude_import\"));\n-        let list = attr::mk_list_item(InternedString::new(\"feature\"),\n-                                      vec![prelude_import_meta]);\n+        let prelude_import_meta = attr::mk_list_word_item(Symbol::intern(\"prelude_import\"));\n+        let list = attr::mk_list_item(Symbol::intern(\"feature\"), vec![prelude_import_meta]);\n         let fake_attr = attr::mk_attr_inner(attr::mk_attr_id(), list);\n         try!(s.print_attribute(&fake_attr));\n \n         // #![no_std]\n-        let no_std_meta = attr::mk_word_item(InternedString::new(\"no_std\"));\n+        let no_std_meta = attr::mk_word_item(Symbol::intern(\"no_std\"));\n         let fake_attr = attr::mk_attr_inner(attr::mk_attr_id(), no_std_meta);\n         try!(s.print_attribute(&fake_attr));\n     }\n@@ -630,7 +630,7 @@ pub trait PrintState<'a> {\n             _ => ()\n         }\n         match lit.node {\n-            ast::LitKind::Str(ref st, style) => self.print_string(&st, style),\n+            ast::LitKind::Str(st, style) => self.print_string(&st.as_str(), style),\n             ast::LitKind::Byte(byte) => {\n                 let mut res = String::from(\"b'\");\n                 res.extend(ascii::escape_default(byte).map(|c| c as char));\n@@ -664,7 +664,7 @@ pub trait PrintState<'a> {\n                          &f,\n                          t.ty_to_string()))\n             }\n-            ast::LitKind::FloatUnsuffixed(ref f) => word(self.writer(), &f[..]),\n+            ast::LitKind::FloatUnsuffixed(ref f) => word(self.writer(), &f.as_str()),\n             ast::LitKind::Bool(val) => {\n                 if val { word(self.writer(), \"true\") } else { word(self.writer(), \"false\") }\n             }\n@@ -727,7 +727,7 @@ pub trait PrintState<'a> {\n                               trailing_hardbreak: bool) -> io::Result<()> {\n         let mut count = 0;\n         for attr in attrs {\n-            if attr.node.style == kind {\n+            if attr.style == kind {\n                 try!(self.print_attribute_inline(attr, is_inline));\n                 if is_inline {\n                     try!(self.nbsp());\n@@ -751,11 +751,11 @@ pub trait PrintState<'a> {\n             try!(self.hardbreak_if_not_bol());\n         }\n         try!(self.maybe_print_comment(attr.span.lo));\n-        if attr.node.is_sugared_doc {\n-            try!(word(self.writer(), &attr.value_str().unwrap()));\n+        if attr.is_sugared_doc {\n+            try!(word(self.writer(), &attr.value_str().unwrap().as_str()));\n             hardbreak(self.writer())\n         } else {\n-            match attr.node.style {\n+            match attr.style {\n                 ast::AttrStyle::Inner => try!(word(self.writer(), \"#![\")),\n                 ast::AttrStyle::Outer => try!(word(self.writer(), \"#[\")),\n             }\n@@ -778,16 +778,16 @@ pub trait PrintState<'a> {\n     fn print_meta_item(&mut self, item: &ast::MetaItem) -> io::Result<()> {\n         try!(self.ibox(INDENT_UNIT));\n         match item.node {\n-            ast::MetaItemKind::Word(ref name) => {\n-                try!(word(self.writer(), &name));\n+            ast::MetaItemKind::Word => {\n+                try!(word(self.writer(), &item.name.as_str()));\n             }\n-            ast::MetaItemKind::NameValue(ref name, ref value) => {\n-                try!(self.word_space(&name[..]));\n+            ast::MetaItemKind::NameValue(ref value) => {\n+                try!(self.word_space(&item.name.as_str()));\n                 try!(self.word_space(\"=\"));\n                 try!(self.print_literal(value));\n             }\n-            ast::MetaItemKind::List(ref name, ref items) => {\n-                try!(word(self.writer(), &name));\n+            ast::MetaItemKind::List(ref items) => {\n+                try!(word(self.writer(), &item.name.as_str()));\n                 try!(self.popen());\n                 try!(self.commasep(Consistent,\n                               &items[..],\n@@ -2220,19 +2220,18 @@ impl<'a> State<'a> {\n             ast::ExprKind::InlineAsm(ref a) => {\n                 try!(word(&mut self.s, \"asm!\"));\n                 try!(self.popen());\n-                try!(self.print_string(&a.asm, a.asm_str_style));\n+                try!(self.print_string(&a.asm.as_str(), a.asm_str_style));\n                 try!(self.word_space(\":\"));\n \n-                try!(self.commasep(Inconsistent, &a.outputs,\n-                                   |s, out| {\n-                    let mut ch = out.constraint.chars();\n+                try!(self.commasep(Inconsistent, &a.outputs, |s, out| {\n+                    let constraint = out.constraint.as_str();\n+                    let mut ch = constraint.chars();\n                     match ch.next() {\n                         Some('=') if out.is_rw => {\n                             try!(s.print_string(&format!(\"+{}\", ch.as_str()),\n                                            ast::StrStyle::Cooked))\n                         }\n-                        _ => try!(s.print_string(&out.constraint,\n-                                            ast::StrStyle::Cooked))\n+                        _ => try!(s.print_string(&constraint, ast::StrStyle::Cooked))\n                     }\n                     try!(s.popen());\n                     try!(s.print_expr(&out.expr));\n@@ -2242,9 +2241,8 @@ impl<'a> State<'a> {\n                 try!(space(&mut self.s));\n                 try!(self.word_space(\":\"));\n \n-                try!(self.commasep(Inconsistent, &a.inputs,\n-                                   |s, &(ref co, ref o)| {\n-                    try!(s.print_string(&co, ast::StrStyle::Cooked));\n+                try!(self.commasep(Inconsistent, &a.inputs, |s, &(co, ref o)| {\n+                    try!(s.print_string(&co.as_str(), ast::StrStyle::Cooked));\n                     try!(s.popen());\n                     try!(s.print_expr(&o));\n                     try!(s.pclose());\n@@ -2255,7 +2253,7 @@ impl<'a> State<'a> {\n \n                 try!(self.commasep(Inconsistent, &a.clobbers,\n                                    |s, co| {\n-                    try!(s.print_string(&co, ast::StrStyle::Cooked));\n+                    try!(s.print_string(&co.as_str(), ast::StrStyle::Cooked));\n                     Ok(())\n                 }));\n \n@@ -3082,12 +3080,11 @@ mod tests {\n \n     use ast;\n     use codemap;\n-    use parse::token;\n     use syntax_pos;\n \n     #[test]\n     fn test_fun_to_string() {\n-        let abba_ident = token::str_to_ident(\"abba\");\n+        let abba_ident = ast::Ident::from_str(\"abba\");\n \n         let decl = ast::FnDecl {\n             inputs: Vec::new(),\n@@ -3103,7 +3100,7 @@ mod tests {\n \n     #[test]\n     fn test_variant_to_string() {\n-        let ident = token::str_to_ident(\"principal_skinner\");\n+        let ident = ast::Ident::from_str(\"principal_skinner\");\n \n         let var = codemap::respan(syntax_pos::DUMMY_SP, ast::Variant_ {\n             name: ident,"}, {"sha": "6a291ad9c408a372ed1dbd9b7af1b8c59f9a0335", "filename": "src/libsyntax/std_inject.rs", "status": "modified", "additions": 14, "deletions": 15, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibsyntax%2Fstd_inject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibsyntax%2Fstd_inject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fstd_inject.rs?ref=ebec55406ba94faf8b2cd23b27a8f74df97d1ca4", "patch": "@@ -10,10 +10,10 @@\n \n use ast;\n use attr;\n+use symbol::{Symbol, keywords};\n use syntax_pos::{DUMMY_SP, Span};\n use codemap::{self, ExpnInfo, NameAndSpan, MacroAttribute};\n-use parse::token::{intern, InternedString, keywords};\n-use parse::{token, ParseSess};\n+use parse::ParseSess;\n use ptr::P;\n \n /// Craft a span that will be ignored by the stability lint's\n@@ -23,7 +23,7 @@ fn ignored_span(sess: &ParseSess, sp: Span) -> Span {\n     let info = ExpnInfo {\n         call_site: DUMMY_SP,\n         callee: NameAndSpan {\n-            format: MacroAttribute(intern(\"std_inject\")),\n+            format: MacroAttribute(Symbol::intern(\"std_inject\")),\n             span: None,\n             allow_internal_unstable: true,\n         }\n@@ -53,37 +53,36 @@ pub fn maybe_inject_crates_ref(sess: &ParseSess,\n         None => return krate,\n     };\n \n-    let crate_name = token::intern(&alt_std_name.unwrap_or(name.to_string()));\n+    let crate_name = Symbol::intern(&alt_std_name.unwrap_or(name.to_string()));\n \n     krate.module.items.insert(0, P(ast::Item {\n         attrs: vec![attr::mk_attr_outer(attr::mk_attr_id(),\n-                                        attr::mk_word_item(InternedString::new(\"macro_use\")))],\n+                                        attr::mk_word_item(Symbol::intern(\"macro_use\")))],\n         vis: ast::Visibility::Inherited,\n         node: ast::ItemKind::ExternCrate(Some(crate_name)),\n-        ident: token::str_to_ident(name),\n+        ident: ast::Ident::from_str(name),\n         id: ast::DUMMY_NODE_ID,\n         span: DUMMY_SP,\n     }));\n \n     let span = ignored_span(sess, DUMMY_SP);\n     krate.module.items.insert(0, P(ast::Item {\n         attrs: vec![ast::Attribute {\n-            node: ast::Attribute_ {\n-                style: ast::AttrStyle::Outer,\n-                value: P(ast::MetaItem {\n-                    node: ast::MetaItemKind::Word(token::intern_and_get_ident(\"prelude_import\")),\n-                    span: span,\n-                }),\n-                id: attr::mk_attr_id(),\n-                is_sugared_doc: false,\n+            style: ast::AttrStyle::Outer,\n+            value: ast::MetaItem {\n+                name: Symbol::intern(\"prelude_import\"),\n+                node: ast::MetaItemKind::Word,\n+                span: span,\n             },\n+            id: attr::mk_attr_id(),\n+            is_sugared_doc: false,\n             span: span,\n         }],\n         vis: ast::Visibility::Inherited,\n         node: ast::ItemKind::Use(P(codemap::dummy_spanned(ast::ViewPathGlob(ast::Path {\n             global: false,\n             segments: vec![name, \"prelude\", \"v1\"].into_iter().map(|name| ast::PathSegment {\n-                identifier: token::str_to_ident(name),\n+                identifier: ast::Ident::from_str(name),\n                 parameters: ast::PathParameters::none(),\n             }).collect(),\n             span: span,"}, {"sha": "fe9a176179ce67aebc42f13398c418b104c7f4cd", "filename": "src/libsyntax/symbol.rs", "status": "added", "additions": 303, "deletions": 0, "changes": 303, "blob_url": "https://github.com/rust-lang/rust/blob/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibsyntax%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibsyntax%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fsymbol.rs?ref=ebec55406ba94faf8b2cd23b27a8f74df97d1ca4", "patch": "@@ -0,0 +1,303 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! An \"interner\" is a data structure that associates values with usize tags and\n+//! allows bidirectional lookup; i.e. given a value, one can easily find the\n+//! type, and vice versa.\n+\n+use serialize::{Decodable, Decoder, Encodable, Encoder};\n+use std::cell::RefCell;\n+use std::collections::HashMap;\n+use std::fmt;\n+\n+/// A symbol is an interned or gensymed string.\n+#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\n+pub struct Symbol(u32);\n+\n+// The interner in thread-local, so `Symbol` shouldn't move between threads.\n+impl !Send for Symbol { }\n+\n+impl Symbol {\n+    /// Maps a string to its interned representation.\n+    pub fn intern(string: &str) -> Self {\n+        with_interner(|interner| interner.intern(string))\n+    }\n+\n+    /// gensym's a new usize, using the current interner.\n+    pub fn gensym(string: &str) -> Self {\n+        with_interner(|interner| interner.gensym(string))\n+    }\n+\n+    pub fn as_str(self) -> InternedString {\n+        with_interner(|interner| unsafe {\n+            InternedString {\n+                string: ::std::mem::transmute::<&str, &str>(interner.get(self))\n+            }\n+        })\n+    }\n+\n+    pub fn as_u32(self) -> u32 {\n+        self.0\n+    }\n+}\n+\n+impl fmt::Debug for Symbol {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"{}({})\", self, self.0)\n+    }\n+}\n+\n+impl fmt::Display for Symbol {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        fmt::Display::fmt(&self.as_str(), f)\n+    }\n+}\n+\n+impl Encodable for Symbol {\n+    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n+        s.emit_str(&self.as_str())\n+    }\n+}\n+\n+impl Decodable for Symbol {\n+    fn decode<D: Decoder>(d: &mut D) -> Result<Symbol, D::Error> {\n+        Ok(Symbol::intern(&d.read_str()?))\n+    }\n+}\n+\n+impl<'a> PartialEq<&'a str> for Symbol {\n+    fn eq(&self, other: &&str) -> bool {\n+        *self.as_str() == **other\n+    }\n+}\n+\n+#[derive(Default)]\n+pub struct Interner {\n+    names: HashMap<Box<str>, Symbol>,\n+    strings: Vec<Box<str>>,\n+}\n+\n+impl Interner {\n+    pub fn new() -> Self {\n+        Interner::default()\n+    }\n+\n+    fn prefill(init: &[&str]) -> Self {\n+        let mut this = Interner::new();\n+        for &string in init {\n+            this.intern(string);\n+        }\n+        this\n+    }\n+\n+    pub fn intern(&mut self, string: &str) -> Symbol {\n+        if let Some(&name) = self.names.get(string) {\n+            return name;\n+        }\n+\n+        let name = Symbol(self.strings.len() as u32);\n+        let string = string.to_string().into_boxed_str();\n+        self.strings.push(string.clone());\n+        self.names.insert(string, name);\n+        name\n+    }\n+\n+    fn gensym(&mut self, string: &str) -> Symbol {\n+        let gensym = Symbol(self.strings.len() as u32);\n+        // leave out of `names` to avoid colliding\n+        self.strings.push(string.to_string().into_boxed_str());\n+        gensym\n+    }\n+\n+    pub fn get(&self, name: Symbol) -> &str {\n+        &self.strings[name.0 as usize]\n+    }\n+}\n+\n+// In this macro, there is the requirement that the name (the number) must be monotonically\n+// increasing by one in the special identifiers, starting at 0; the same holds for the keywords,\n+// except starting from the next number instead of zero.\n+macro_rules! declare_keywords {(\n+    $( ($index: expr, $konst: ident, $string: expr) )*\n+) => {\n+    pub mod keywords {\n+        use ast;\n+        #[derive(Clone, Copy, PartialEq, Eq)]\n+        pub struct Keyword {\n+            ident: ast::Ident,\n+        }\n+        impl Keyword {\n+            #[inline] pub fn ident(self) -> ast::Ident { self.ident }\n+            #[inline] pub fn name(self) -> ast::Name { self.ident.name }\n+        }\n+        $(\n+            #[allow(non_upper_case_globals)]\n+            pub const $konst: Keyword = Keyword {\n+                ident: ast::Ident::with_empty_ctxt(ast::Name($index))\n+            };\n+        )*\n+    }\n+\n+    impl Interner {\n+        fn fresh() -> Self {\n+            Interner::prefill(&[$($string,)*])\n+        }\n+    }\n+}}\n+\n+// NB: leaving holes in the ident table is bad! a different ident will get\n+// interned with the id from the hole, but it will be between the min and max\n+// of the reserved words, and thus tagged as \"reserved\".\n+// After modifying this list adjust `is_strict_keyword`/`is_reserved_keyword`,\n+// this should be rarely necessary though if the keywords are kept in alphabetic order.\n+declare_keywords! {\n+    // Invalid identifier\n+    (0,  Invalid,        \"\")\n+\n+    // Strict keywords used in the language.\n+    (1,  As,             \"as\")\n+    (2,  Box,            \"box\")\n+    (3,  Break,          \"break\")\n+    (4,  Const,          \"const\")\n+    (5,  Continue,       \"continue\")\n+    (6,  Crate,          \"crate\")\n+    (7,  Else,           \"else\")\n+    (8,  Enum,           \"enum\")\n+    (9,  Extern,         \"extern\")\n+    (10, False,          \"false\")\n+    (11, Fn,             \"fn\")\n+    (12, For,            \"for\")\n+    (13, If,             \"if\")\n+    (14, Impl,           \"impl\")\n+    (15, In,             \"in\")\n+    (16, Let,            \"let\")\n+    (17, Loop,           \"loop\")\n+    (18, Match,          \"match\")\n+    (19, Mod,            \"mod\")\n+    (20, Move,           \"move\")\n+    (21, Mut,            \"mut\")\n+    (22, Pub,            \"pub\")\n+    (23, Ref,            \"ref\")\n+    (24, Return,         \"return\")\n+    (25, SelfValue,      \"self\")\n+    (26, SelfType,       \"Self\")\n+    (27, Static,         \"static\")\n+    (28, Struct,         \"struct\")\n+    (29, Super,          \"super\")\n+    (30, Trait,          \"trait\")\n+    (31, True,           \"true\")\n+    (32, Type,           \"type\")\n+    (33, Unsafe,         \"unsafe\")\n+    (34, Use,            \"use\")\n+    (35, Where,          \"where\")\n+    (36, While,          \"while\")\n+\n+    // Keywords reserved for future use.\n+    (37, Abstract,       \"abstract\")\n+    (38, Alignof,        \"alignof\")\n+    (39, Become,         \"become\")\n+    (40, Do,             \"do\")\n+    (41, Final,          \"final\")\n+    (42, Macro,          \"macro\")\n+    (43, Offsetof,       \"offsetof\")\n+    (44, Override,       \"override\")\n+    (45, Priv,           \"priv\")\n+    (46, Proc,           \"proc\")\n+    (47, Pure,           \"pure\")\n+    (48, Sizeof,         \"sizeof\")\n+    (49, Typeof,         \"typeof\")\n+    (50, Unsized,        \"unsized\")\n+    (51, Virtual,        \"virtual\")\n+    (52, Yield,          \"yield\")\n+\n+    // Weak keywords, have special meaning only in specific contexts.\n+    (53, Default,        \"default\")\n+    (54, StaticLifetime, \"'static\")\n+    (55, Union,          \"union\")\n+}\n+\n+// If an interner exists in TLS, return it. Otherwise, prepare a fresh one.\n+fn with_interner<T, F: FnOnce(&mut Interner) -> T>(f: F) -> T {\n+    thread_local!(static INTERNER: RefCell<Interner> = {\n+        RefCell::new(Interner::fresh())\n+    });\n+    INTERNER.with(|interner| f(&mut *interner.borrow_mut()))\n+}\n+\n+/// Represents a string stored in the thread-local interner. Because the\n+/// interner lives for the life of the thread, this can be safely treated as an\n+/// immortal string, as long as it never crosses between threads.\n+///\n+/// FIXME(pcwalton): You must be careful about what you do in the destructors\n+/// of objects stored in TLS, because they may run after the interner is\n+/// destroyed. In particular, they must not access string contents. This can\n+/// be fixed in the future by just leaking all strings until thread death\n+/// somehow.\n+#[derive(Clone, PartialEq, Hash, PartialOrd, Eq, Ord)]\n+pub struct InternedString {\n+    string: &'static str,\n+}\n+\n+impl !Send for InternedString { }\n+\n+impl ::std::ops::Deref for InternedString {\n+    type Target = str;\n+    fn deref(&self) -> &str { self.string }\n+}\n+\n+impl fmt::Debug for InternedString {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        fmt::Debug::fmt(self.string, f)\n+    }\n+}\n+\n+impl fmt::Display for InternedString {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        fmt::Display::fmt(self.string, f)\n+    }\n+}\n+\n+impl Decodable for InternedString {\n+    fn decode<D: Decoder>(d: &mut D) -> Result<InternedString, D::Error> {\n+        Ok(Symbol::intern(&d.read_str()?).as_str())\n+    }\n+}\n+\n+impl Encodable for InternedString {\n+    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n+        s.emit_str(self.string)\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+    use ast::Name;\n+\n+    #[test]\n+    fn interner_tests() {\n+        let mut i: Interner = Interner::new();\n+        // first one is zero:\n+        assert_eq!(i.intern(\"dog\"), Name(0));\n+        // re-use gets the same entry:\n+        assert_eq!(i.intern (\"dog\"), Name(0));\n+        // different string gets a different #:\n+        assert_eq!(i.intern(\"cat\"), Name(1));\n+        assert_eq!(i.intern(\"cat\"), Name(1));\n+        // dog is still at zero\n+        assert_eq!(i.intern(\"dog\"), Name(0));\n+        // gensym gets 3\n+        assert_eq!(i.gensym(\"zebra\"), Name(2));\n+        // gensym of same string gets new number :\n+        assert_eq!(i.gensym(\"zebra\"), Name(3));\n+        // gensym of *existing* string gets new number:\n+        assert_eq!(i.gensym(\"dog\"), Name(4));\n+    }\n+}"}, {"sha": "4de3baf7d14fb27aaa240724903e35ecd2ab91a3", "filename": "src/libsyntax/test.rs", "status": "modified", "additions": 42, "deletions": 38, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibsyntax%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibsyntax%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftest.rs?ref=ebec55406ba94faf8b2cd23b27a8f74df97d1ca4", "patch": "@@ -34,21 +34,21 @@ use ext::expand::ExpansionConfig;\n use fold::Folder;\n use util::move_map::MoveMap;\n use fold;\n-use parse::token::{intern, keywords, InternedString};\n use parse::{token, ParseSess};\n use print::pprust;\n-use ast;\n+use ast::{self, Ident};\n use ptr::P;\n+use symbol::{self, Symbol, keywords};\n use util::small_vector::SmallVector;\n \n enum ShouldPanic {\n     No,\n-    Yes(Option<InternedString>),\n+    Yes(Option<Symbol>),\n }\n \n struct Test {\n     span: Span,\n-    path: Vec<ast::Ident> ,\n+    path: Vec<Ident> ,\n     bench: bool,\n     ignore: bool,\n     should_panic: ShouldPanic\n@@ -57,14 +57,14 @@ struct Test {\n struct TestCtxt<'a> {\n     sess: &'a ParseSess,\n     span_diagnostic: &'a errors::Handler,\n-    path: Vec<ast::Ident>,\n+    path: Vec<Ident>,\n     ext_cx: ExtCtxt<'a>,\n     testfns: Vec<Test>,\n-    reexport_test_harness_main: Option<InternedString>,\n+    reexport_test_harness_main: Option<Symbol>,\n     is_test_crate: bool,\n \n     // top-level re-export submodule, filled out after folding is finished\n-    toplevel_reexport: Option<ast::Ident>,\n+    toplevel_reexport: Option<Ident>,\n }\n \n // Traverse the crate, collecting all the test functions, eliding any\n@@ -91,10 +91,10 @@ pub fn modify_for_testing(sess: &ParseSess,\n \n struct TestHarnessGenerator<'a> {\n     cx: TestCtxt<'a>,\n-    tests: Vec<ast::Ident>,\n+    tests: Vec<Ident>,\n \n     // submodule name, gensym'd identifier for re-exports\n-    tested_submods: Vec<(ast::Ident, ast::Ident)>,\n+    tested_submods: Vec<(Ident, Ident)>,\n }\n \n impl<'a> fold::Folder for TestHarnessGenerator<'a> {\n@@ -191,8 +191,8 @@ impl fold::Folder for EntryPointCleaner {\n             EntryPointType::MainAttr |\n             EntryPointType::Start =>\n                 folded.map(|ast::Item {id, ident, attrs, node, vis, span}| {\n-                    let allow_str = InternedString::new(\"allow\");\n-                    let dead_code_str = InternedString::new(\"dead_code\");\n+                    let allow_str = Symbol::intern(\"allow\");\n+                    let dead_code_str = Symbol::intern(\"dead_code\");\n                     let word_vec = vec![attr::mk_list_word_item(dead_code_str)];\n                     let allow_dead_code_item = attr::mk_list_item(allow_str, word_vec);\n                     let allow_dead_code = attr::mk_attr_outer(attr::mk_attr_id(),\n@@ -222,15 +222,18 @@ impl fold::Folder for EntryPointCleaner {\n     fn fold_mac(&mut self, mac: ast::Mac) -> ast::Mac { mac }\n }\n \n-fn mk_reexport_mod(cx: &mut TestCtxt, parent: ast::NodeId, tests: Vec<ast::Ident>,\n-                   tested_submods: Vec<(ast::Ident, ast::Ident)>) -> (P<ast::Item>, ast::Ident) {\n-    let super_ = token::str_to_ident(\"super\");\n+fn mk_reexport_mod(cx: &mut TestCtxt,\n+                   parent: ast::NodeId,\n+                   tests: Vec<Ident>,\n+                   tested_submods: Vec<(Ident, Ident)>)\n+                   -> (P<ast::Item>, Ident) {\n+    let super_ = Ident::from_str(\"super\");\n \n     // Generate imports with `#[allow(private_in_public)]` to work around issue #36768.\n     let allow_private_in_public = cx.ext_cx.attribute(DUMMY_SP, cx.ext_cx.meta_list(\n         DUMMY_SP,\n-        InternedString::new(\"allow\"),\n-        vec![cx.ext_cx.meta_list_item_word(DUMMY_SP, InternedString::new(\"private_in_public\"))],\n+        Symbol::intern(\"allow\"),\n+        vec![cx.ext_cx.meta_list_item_word(DUMMY_SP, Symbol::intern(\"private_in_public\"))],\n     ));\n     let items = tests.into_iter().map(|r| {\n         cx.ext_cx.item_use_simple(DUMMY_SP, ast::Visibility::Public,\n@@ -247,7 +250,7 @@ fn mk_reexport_mod(cx: &mut TestCtxt, parent: ast::NodeId, tests: Vec<ast::Ident\n         items: items,\n     };\n \n-    let sym = token::gensym_ident(\"__test_reexports\");\n+    let sym = Ident::with_empty_ctxt(Symbol::gensym(\"__test_reexports\"));\n     let parent = if parent == ast::DUMMY_NODE_ID { ast::CRATE_NODE_ID } else { parent };\n     cx.ext_cx.current_expansion.mark = cx.ext_cx.resolver.get_module_scope(parent);\n     let it = cx.ext_cx.monotonic_expander().fold_item(P(ast::Item {\n@@ -264,7 +267,7 @@ fn mk_reexport_mod(cx: &mut TestCtxt, parent: ast::NodeId, tests: Vec<ast::Ident\n \n fn generate_test_harness(sess: &ParseSess,\n                          resolver: &mut Resolver,\n-                         reexport_test_harness_main: Option<InternedString>,\n+                         reexport_test_harness_main: Option<Symbol>,\n                          krate: ast::Crate,\n                          sd: &errors::Handler) -> ast::Crate {\n     // Remove the entry points\n@@ -286,7 +289,7 @@ fn generate_test_harness(sess: &ParseSess,\n     cx.ext_cx.bt_push(ExpnInfo {\n         call_site: DUMMY_SP,\n         callee: NameAndSpan {\n-            format: MacroAttribute(intern(\"test\")),\n+            format: MacroAttribute(Symbol::intern(\"test\")),\n             span: None,\n             allow_internal_unstable: false,\n         }\n@@ -306,7 +309,7 @@ fn ignored_span(cx: &TestCtxt, sp: Span) -> Span {\n     let info = ExpnInfo {\n         call_site: DUMMY_SP,\n         callee: NameAndSpan {\n-            format: MacroAttribute(intern(\"test\")),\n+            format: MacroAttribute(Symbol::intern(\"test\")),\n             span: None,\n             allow_internal_unstable: true,\n         }\n@@ -456,7 +459,7 @@ mod __test {\n */\n \n fn mk_std(cx: &TestCtxt) -> P<ast::Item> {\n-    let id_test = token::str_to_ident(\"test\");\n+    let id_test = Ident::from_str(\"test\");\n     let (vi, vis, ident) = if cx.is_test_crate {\n         (ast::ItemKind::Use(\n             P(nospan(ast::ViewPathSimple(id_test,\n@@ -487,16 +490,17 @@ fn mk_main(cx: &mut TestCtxt) -> P<ast::Item> {\n     let ecx = &cx.ext_cx;\n \n     // test::test_main_static\n-    let test_main_path = ecx.path(sp, vec![token::str_to_ident(\"test\"),\n-                                           token::str_to_ident(\"test_main_static\")]);\n+    let test_main_path =\n+        ecx.path(sp, vec![Ident::from_str(\"test\"), Ident::from_str(\"test_main_static\")]);\n+\n     // test::test_main_static(...)\n     let test_main_path_expr = ecx.expr_path(test_main_path);\n-    let tests_ident_expr = ecx.expr_ident(sp, token::str_to_ident(\"TESTS\"));\n+    let tests_ident_expr = ecx.expr_ident(sp, Ident::from_str(\"TESTS\"));\n     let call_test_main = ecx.expr_call(sp, test_main_path_expr,\n                                        vec![tests_ident_expr]);\n     let call_test_main = ecx.stmt_expr(call_test_main);\n     // #![main]\n-    let main_meta = ecx.meta_word(sp, token::intern_and_get_ident(\"main\"));\n+    let main_meta = ecx.meta_word(sp, Symbol::intern(\"main\"));\n     let main_attr = ecx.attribute(sp, main_meta);\n     // pub fn main() { ... }\n     let main_ret_ty = ecx.ty(sp, ast::TyKind::Tup(vec![]));\n@@ -506,7 +510,7 @@ fn mk_main(cx: &mut TestCtxt) -> P<ast::Item> {\n                            dummy_spanned(ast::Constness::NotConst),\n                            ::abi::Abi::Rust, ast::Generics::default(), main_body);\n     let main = P(ast::Item {\n-        ident: token::str_to_ident(\"main\"),\n+        ident: Ident::from_str(\"main\"),\n         attrs: vec![main_attr],\n         id: ast::DUMMY_NODE_ID,\n         node: main,\n@@ -533,7 +537,7 @@ fn mk_test_module(cx: &mut TestCtxt) -> (P<ast::Item>, Option<P<ast::Item>>) {\n         items: vec![import, mainfn, tests],\n     };\n     let item_ = ast::ItemKind::Mod(testmod);\n-    let mod_ident = token::gensym_ident(\"__test\");\n+    let mod_ident = Ident::with_empty_ctxt(Symbol::gensym(\"__test\"));\n \n     let mut expander = cx.ext_cx.monotonic_expander();\n     let item = expander.fold_item(P(ast::Item {\n@@ -544,13 +548,13 @@ fn mk_test_module(cx: &mut TestCtxt) -> (P<ast::Item>, Option<P<ast::Item>>) {\n         vis: ast::Visibility::Public,\n         span: DUMMY_SP,\n     })).pop().unwrap();\n-    let reexport = cx.reexport_test_harness_main.as_ref().map(|s| {\n+    let reexport = cx.reexport_test_harness_main.map(|s| {\n         // building `use <ident> = __test::main`\n-        let reexport_ident = token::str_to_ident(&s);\n+        let reexport_ident = Ident::with_empty_ctxt(s);\n \n         let use_path =\n             nospan(ast::ViewPathSimple(reexport_ident,\n-                                       path_node(vec![mod_ident, token::str_to_ident(\"main\")])));\n+                                       path_node(vec![mod_ident, Ident::from_str(\"main\")])));\n \n         expander.fold_item(P(ast::Item {\n             id: ast::DUMMY_NODE_ID,\n@@ -571,7 +575,7 @@ fn nospan<T>(t: T) -> codemap::Spanned<T> {\n     codemap::Spanned { node: t, span: DUMMY_SP }\n }\n \n-fn path_node(ids: Vec<ast::Ident> ) -> ast::Path {\n+fn path_node(ids: Vec<Ident>) -> ast::Path {\n     ast::Path {\n         span: DUMMY_SP,\n         global: false,\n@@ -582,7 +586,7 @@ fn path_node(ids: Vec<ast::Ident> ) -> ast::Path {\n     }\n }\n \n-fn path_name_i(idents: &[ast::Ident]) -> String {\n+fn path_name_i(idents: &[Ident]) -> String {\n     // FIXME: Bad copies (#2543 -- same for everything else that says \"bad\")\n     idents.iter().map(|i| i.to_string()).collect::<Vec<String>>().join(\"::\")\n }\n@@ -614,7 +618,7 @@ fn mk_tests(cx: &TestCtxt) -> P<ast::Item> {\n \n fn is_test_crate(krate: &ast::Crate) -> bool {\n     match attr::find_crate_name(&krate.attrs) {\n-        Some(ref s) if \"test\" == &s[..] => true,\n+        Some(s) if \"test\" == &*s.as_str() => true,\n         _ => false\n     }\n }\n@@ -660,7 +664,7 @@ fn mk_test_desc_and_fn_rec(cx: &TestCtxt, test: &Test) -> P<ast::Expr> {\n \n     // path to the #[test] function: \"foo::bar::baz\"\n     let path_string = path_name_i(&path[..]);\n-    let name_expr = ecx.expr_str(span, token::intern_and_get_ident(&path_string[..]));\n+    let name_expr = ecx.expr_str(span, Symbol::intern(&path_string));\n \n     // self::test::StaticTestName($name_expr)\n     let name_expr = ecx.expr_call(span,\n@@ -673,10 +677,10 @@ fn mk_test_desc_and_fn_rec(cx: &TestCtxt, test: &Test) -> P<ast::Expr> {\n     };\n     let fail_expr = match test.should_panic {\n         ShouldPanic::No => ecx.expr_path(should_panic_path(\"No\")),\n-        ShouldPanic::Yes(ref msg) => {\n-            match *msg {\n-                Some(ref msg) => {\n-                    let msg = ecx.expr_str(span, msg.clone());\n+        ShouldPanic::Yes(msg) => {\n+            match msg {\n+                Some(msg) => {\n+                    let msg = ecx.expr_str(span, msg);\n                     let path = should_panic_path(\"YesWithMessage\");\n                     ecx.expr_call(span, ecx.expr_path(path), vec![msg])\n                 }"}, {"sha": "0d5dcaf339feb086f6dddabb627cf161cce958cb", "filename": "src/libsyntax/tokenstream.rs", "status": "modified", "additions": 23, "deletions": 19, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibsyntax%2Ftokenstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibsyntax%2Ftokenstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftokenstream.rs?ref=ebec55406ba94faf8b2cd23b27a8f74df97d1ca4", "patch": "@@ -34,6 +34,7 @@ use parse::lexer;\n use parse;\n use parse::token::{self, Token, Lit, Nonterminal};\n use print::pprust;\n+use symbol::Symbol;\n \n use std::fmt;\n use std::iter::*;\n@@ -173,10 +174,10 @@ impl TokenTree {\n                 TokenTree::Delimited(sp, Rc::new(Delimited {\n                     delim: token::Bracket,\n                     open_span: sp,\n-                    tts: vec![TokenTree::Token(sp, token::Ident(token::str_to_ident(\"doc\"))),\n+                    tts: vec![TokenTree::Token(sp, token::Ident(ast::Ident::from_str(\"doc\"))),\n                               TokenTree::Token(sp, token::Eq),\n                               TokenTree::Token(sp, token::Literal(\n-                                  token::StrRaw(token::intern(&stripped), num_of_hashes), None))],\n+                                  token::StrRaw(Symbol::intern(&stripped), num_of_hashes), None))],\n                     close_span: sp,\n                 }))\n             }\n@@ -295,15 +296,15 @@ impl TokenTree {\n     pub fn maybe_str(&self) -> Option<ast::Lit> {\n         match *self {\n             TokenTree::Token(sp, Token::Literal(Lit::Str_(s), _)) => {\n-                let l = LitKind::Str(token::intern_and_get_ident(&parse::str_lit(&s.as_str())),\n+                let l = LitKind::Str(Symbol::intern(&parse::str_lit(&s.as_str())),\n                                      ast::StrStyle::Cooked);\n                 Some(Spanned {\n                     node: l,\n                     span: sp,\n                 })\n             }\n             TokenTree::Token(sp, Token::Literal(Lit::StrRaw(s, n), _)) => {\n-                let l = LitKind::Str(token::intern_and_get_ident(&parse::raw_str_lit(&s.as_str())),\n+                let l = LitKind::Str(Symbol::intern(&parse::raw_str_lit(&s.as_str())),\n                                      ast::StrStyle::Raw(n));\n                 Some(Spanned {\n                     node: l,\n@@ -871,8 +872,9 @@ impl Index<usize> for InternalTS {\n #[cfg(test)]\n mod tests {\n     use super::*;\n+    use syntax::ast::Ident;\n     use syntax_pos::{Span, BytePos, NO_EXPANSION, DUMMY_SP};\n-    use parse::token::{self, str_to_ident, Token};\n+    use parse::token::{self, Token};\n     use util::parser_testing::string_to_tts;\n     use std::rc::Rc;\n \n@@ -967,15 +969,17 @@ mod tests {\n         let test_res = TokenStream::from_tts(string_to_tts(\"foo::bar::baz\".to_string()))\n             .slice(2..3);\n         let test_eqs = TokenStream::from_tts(vec![TokenTree::Token(sp(5,8),\n-                                                    token::Ident(str_to_ident(\"bar\")))]);\n+                                                    token::Ident(Ident::from_str(\"bar\")))]);\n         assert_eq!(test_res, test_eqs)\n     }\n \n     #[test]\n     fn test_is_empty() {\n         let test0 = TokenStream::from_tts(Vec::new());\n-        let test1 = TokenStream::from_tts(vec![TokenTree::Token(sp(0, 1),\n-                                                                Token::Ident(str_to_ident(\"a\")))]);\n+        let test1 = TokenStream::from_tts(\n+            vec![TokenTree::Token(sp(0, 1), Token::Ident(Ident::from_str(\"a\")))]\n+        );\n+\n         let test2 = TokenStream::from_tts(string_to_tts(\"foo(bar::baz)\".to_string()));\n \n         assert_eq!(test0.is_empty(), true);\n@@ -1035,20 +1039,20 @@ mod tests {\n         assert_eq!(test0, None);\n \n         let test1_expected = TokenStream::from_tts(vec![TokenTree::Token(sp(1, 4),\n-                                                        token::Ident(str_to_ident(\"bar\"))),\n+                                                        token::Ident(Ident::from_str(\"bar\"))),\n                                        TokenTree::Token(sp(4, 6), token::ModSep),\n                                        TokenTree::Token(sp(6, 9),\n-                                                        token::Ident(str_to_ident(\"baz\")))]);\n+                                                        token::Ident(Ident::from_str(\"baz\")))]);\n         assert_eq!(test1, Some(test1_expected));\n \n         let test2_expected = TokenStream::from_tts(vec![TokenTree::Token(sp(1, 4),\n-                                                        token::Ident(str_to_ident(\"foo\"))),\n+                                                        token::Ident(Ident::from_str(\"foo\"))),\n                                        TokenTree::Token(sp(4, 5), token::Comma),\n                                        TokenTree::Token(sp(5, 8),\n-                                                        token::Ident(str_to_ident(\"bar\"))),\n+                                                        token::Ident(Ident::from_str(\"bar\"))),\n                                        TokenTree::Token(sp(8, 9), token::Comma),\n                                        TokenTree::Token(sp(9, 12),\n-                                                        token::Ident(str_to_ident(\"baz\")))]);\n+                                                        token::Ident(Ident::from_str(\"baz\")))]);\n         assert_eq!(test2, Some(test2_expected));\n \n         assert_eq!(test3, None);\n@@ -1069,7 +1073,7 @@ mod tests {\n \n         assert_eq!(test0, None);\n         assert_eq!(test1, None);\n-        assert_eq!(test2, Some(str_to_ident(\"foo\")));\n+        assert_eq!(test2, Some(Ident::from_str(\"foo\")));\n         assert_eq!(test3, None);\n         assert_eq!(test4, None);\n     }\n@@ -1079,9 +1083,9 @@ mod tests {\n         let test0 = as_paren_delimited_stream(string_to_tts(\"foo,bar,\".to_string()));\n         let test1 = as_paren_delimited_stream(string_to_tts(\"baz(foo,bar)\".to_string()));\n \n-        let test0_tts = vec![TokenTree::Token(sp(0, 3), token::Ident(str_to_ident(\"foo\"))),\n+        let test0_tts = vec![TokenTree::Token(sp(0, 3), token::Ident(Ident::from_str(\"foo\"))),\n                              TokenTree::Token(sp(3, 4), token::Comma),\n-                             TokenTree::Token(sp(4, 7), token::Ident(str_to_ident(\"bar\"))),\n+                             TokenTree::Token(sp(4, 7), token::Ident(Ident::from_str(\"bar\"))),\n                              TokenTree::Token(sp(7, 8), token::Comma)];\n         let test0_stream = TokenStream::from_tts(vec![TokenTree::Delimited(sp(0, 8),\n                                                                Rc::new(Delimited {\n@@ -1094,11 +1098,11 @@ mod tests {\n         assert_eq!(test0, test0_stream);\n \n \n-        let test1_tts = vec![TokenTree::Token(sp(4, 7), token::Ident(str_to_ident(\"foo\"))),\n+        let test1_tts = vec![TokenTree::Token(sp(4, 7), token::Ident(Ident::from_str(\"foo\"))),\n                              TokenTree::Token(sp(7, 8), token::Comma),\n-                             TokenTree::Token(sp(8, 11), token::Ident(str_to_ident(\"bar\")))];\n+                             TokenTree::Token(sp(8, 11), token::Ident(Ident::from_str(\"bar\")))];\n \n-        let test1_parse = vec![TokenTree::Token(sp(0, 3), token::Ident(str_to_ident(\"baz\"))),\n+        let test1_parse = vec![TokenTree::Token(sp(0, 3), token::Ident(Ident::from_str(\"baz\"))),\n                                TokenTree::Delimited(sp(3, 12),\n                                                     Rc::new(Delimited {\n                                                         delim: token::DelimToken::Paren,"}, {"sha": "f56c6cedcd18678e4971d48d96b8392a0c6280a0", "filename": "src/libsyntax/util/interner.rs", "status": "removed", "additions": 0, "deletions": 111, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/59b87b3975c97820b32ba6ebee8eac2a13ab883b/src%2Flibsyntax%2Futil%2Finterner.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59b87b3975c97820b32ba6ebee8eac2a13ab883b/src%2Flibsyntax%2Futil%2Finterner.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Finterner.rs?ref=59b87b3975c97820b32ba6ebee8eac2a13ab883b", "patch": "@@ -1,111 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! An \"interner\" is a data structure that associates values with usize tags and\n-//! allows bidirectional lookup; i.e. given a value, one can easily find the\n-//! type, and vice versa.\n-\n-use ast::Name;\n-\n-use std::collections::HashMap;\n-use std::rc::Rc;\n-\n-#[derive(Default)]\n-pub struct Interner {\n-    names: HashMap<Rc<str>, Name>,\n-    strings: Vec<Rc<str>>,\n-}\n-\n-/// When traits can extend traits, we should extend index<Name,T> to get []\n-impl Interner {\n-    pub fn new() -> Self {\n-        Interner::default()\n-    }\n-\n-    pub fn prefill(init: &[&str]) -> Self {\n-        let mut this = Interner::new();\n-        for &string in init {\n-            this.intern(string);\n-        }\n-        this\n-    }\n-\n-    pub fn intern(&mut self, string: &str) -> Name {\n-        if let Some(&name) = self.names.get(string) {\n-            return name;\n-        }\n-\n-        let name = Name(self.strings.len() as u32);\n-        let string = Rc::__from_str(string);\n-        self.strings.push(string.clone());\n-        self.names.insert(string, name);\n-        name\n-    }\n-\n-    pub fn gensym(&mut self, string: &str) -> Name {\n-        let gensym = Name(self.strings.len() as u32);\n-        // leave out of `names` to avoid colliding\n-        self.strings.push(Rc::__from_str(string));\n-        gensym\n-    }\n-\n-    /// Create a gensym with the same name as an existing entry.\n-    pub fn gensym_copy(&mut self, name: Name) -> Name {\n-        let gensym = Name(self.strings.len() as u32);\n-        // leave out of `names` to avoid colliding\n-        let string = self.strings[name.0 as usize].clone();\n-        self.strings.push(string);\n-        gensym\n-    }\n-\n-    pub fn get(&self, name: Name) -> Rc<str> {\n-        self.strings[name.0 as usize].clone()\n-    }\n-\n-    pub fn find(&self, string: &str) -> Option<Name> {\n-        self.names.get(string).cloned()\n-    }\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    use super::*;\n-    use ast::Name;\n-\n-    #[test]\n-    fn interner_tests() {\n-        let mut i: Interner = Interner::new();\n-        // first one is zero:\n-        assert_eq!(i.intern(\"dog\"), Name(0));\n-        // re-use gets the same entry:\n-        assert_eq!(i.intern (\"dog\"), Name(0));\n-        // different string gets a different #:\n-        assert_eq!(i.intern(\"cat\"), Name(1));\n-        assert_eq!(i.intern(\"cat\"), Name(1));\n-        // dog is still at zero\n-        assert_eq!(i.intern(\"dog\"), Name(0));\n-        // gensym gets 3\n-        assert_eq!(i.gensym(\"zebra\"), Name(2));\n-        // gensym of same string gets new number :\n-        assert_eq!(i.gensym(\"zebra\"), Name(3));\n-        // gensym of *existing* string gets new number:\n-        assert_eq!(i.gensym(\"dog\"), Name(4));\n-        // gensym tests again with gensym_copy:\n-        assert_eq!(i.gensym_copy(Name(2)), Name(5));\n-        assert_eq!(&*i.get(Name(5)), \"zebra\");\n-        assert_eq!(i.gensym_copy(Name(2)), Name(6));\n-        assert_eq!(&*i.get(Name(6)), \"zebra\");\n-        assert_eq!(&*i.get(Name(0)), \"dog\");\n-        assert_eq!(&*i.get(Name(1)), \"cat\");\n-        assert_eq!(&*i.get(Name(2)), \"zebra\");\n-        assert_eq!(&*i.get(Name(3)), \"zebra\");\n-        assert_eq!(&*i.get(Name(4)), \"dog\");\n-    }\n-}"}, {"sha": "a6fff2d707469ffd2d4d1607dfb658b62b4a1139", "filename": "src/libsyntax/util/lev_distance.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibsyntax%2Futil%2Flev_distance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibsyntax%2Futil%2Flev_distance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Flev_distance.rs?ref=ebec55406ba94faf8b2cd23b27a8f74df97d1ca4", "patch": "@@ -8,9 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use ast::Name;\n use std::cmp;\n-use parse::token::InternedString;\n+use symbol::Symbol;\n \n /// To find the Levenshtein distance between two strings\n pub fn lev_distance(a: &str, b: &str) -> usize {\n@@ -48,14 +47,14 @@ pub fn lev_distance(a: &str, b: &str) -> usize {\n /// to one-third of the given word\n pub fn find_best_match_for_name<'a, T>(iter_names: T,\n                                        lookup: &str,\n-                                       dist: Option<usize>) -> Option<InternedString>\n-    where T: Iterator<Item = &'a Name> {\n+                                       dist: Option<usize>) -> Option<Symbol>\n+    where T: Iterator<Item = &'a Symbol> {\n     let max_dist = dist.map_or_else(|| cmp::max(lookup.len(), 3) / 3, |d| d);\n     iter_names\n-    .filter_map(|name| {\n+    .filter_map(|&name| {\n         let dist = lev_distance(lookup, &name.as_str());\n         match dist <= max_dist {    // filter the unwanted cases\n-            true => Some((name.as_str(), dist)),\n+            true => Some((name, dist)),\n             false => None,\n         }\n     })"}, {"sha": "ce24fe1eb61e241d6eee5830c982e01b49c20638", "filename": "src/libsyntax/util/parser.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibsyntax%2Futil%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibsyntax%2Futil%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Fparser.rs?ref=ebec55406ba94faf8b2cd23b27a8f74df97d1ca4", "patch": "@@ -7,7 +7,8 @@\n // <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n-use parse::token::{Token, BinOpToken, keywords};\n+use parse::token::{Token, BinOpToken};\n+use symbol::keywords;\n use ast::BinOpKind;\n \n /// Associative operator with precedence."}, {"sha": "e703dc6b4191c50f933fa82e98777eb9cbf189fe", "filename": "src/libsyntax/util/parser_testing.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibsyntax%2Futil%2Fparser_testing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibsyntax%2Futil%2Fparser_testing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Fparser_testing.rs?ref=ebec55406ba94faf8b2cd23b27a8f74df97d1ca4", "patch": "@@ -8,11 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use ast;\n+use ast::{self, Ident};\n use parse::{ParseSess,PResult,filemap_to_tts};\n use parse::{lexer, new_parser_from_source_str};\n use parse::parser::Parser;\n-use parse::token;\n use ptr::P;\n use tokenstream;\n use std::iter::Peekable;\n@@ -78,9 +77,9 @@ pub fn string_to_pat(source_str: String) -> P<ast::Pat> {\n     })\n }\n \n-/// Convert a vector of strings to a vector of ast::Ident's\n-pub fn strs_to_idents(ids: Vec<&str> ) -> Vec<ast::Ident> {\n-    ids.iter().map(|u| token::str_to_ident(*u)).collect()\n+/// Convert a vector of strings to a vector of Ident's\n+pub fn strs_to_idents(ids: Vec<&str> ) -> Vec<Ident> {\n+    ids.iter().map(|u| Ident::from_str(*u)).collect()\n }\n \n /// Does the given string match the pattern? whitespace in the first string"}, {"sha": "a5e083f926a07ad97184355a2604f2c73ee4726a", "filename": "src/libsyntax_ext/asm.rs", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibsyntax_ext%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibsyntax_ext%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fasm.rs?ref=ebec55406ba94faf8b2cd23b27a8f74df97d1ca4", "patch": "@@ -17,9 +17,9 @@ use syntax::codemap;\n use syntax::ext::base;\n use syntax::ext::base::*;\n use syntax::feature_gate;\n-use syntax::parse::token::intern;\n use syntax::parse::{self, token};\n use syntax::ptr::P;\n+use syntax::symbol::Symbol;\n use syntax::ast::AsmDialect;\n use syntax_pos::Span;\n use syntax::tokenstream;\n@@ -73,7 +73,7 @@ pub fn expand_asm<'cx>(cx: &'cx mut ExtCtxt,\n         })\n         .unwrap_or(tts.len());\n     let mut p = cx.new_parser_from_tts(&tts[first_colon..]);\n-    let mut asm = token::InternedString::new(\"\");\n+    let mut asm = Symbol::intern(\"\");\n     let mut asm_str_style = None;\n     let mut outputs = Vec::new();\n     let mut inputs = Vec::new();\n@@ -135,11 +135,12 @@ pub fn expand_asm<'cx>(cx: &'cx mut ExtCtxt,\n                     // It's the opposite of '=&' which means that the memory\n                     // cannot be shared with any other operand (usually when\n                     // a register is clobbered early.)\n-                    let mut ch = constraint.chars();\n+                    let constraint_str = constraint.as_str();\n+                    let mut ch = constraint_str.chars();\n                     let output = match ch.next() {\n                         Some('=') => None,\n                         Some('+') => {\n-                            Some(token::intern_and_get_ident(&format!(\"={}\", ch.as_str())))\n+                            Some(Symbol::intern(&format!(\"={}\", ch.as_str())))\n                         }\n                         _ => {\n                             cx.span_err(span, \"output operand constraint lacks '=' or '+'\");\n@@ -148,9 +149,9 @@ pub fn expand_asm<'cx>(cx: &'cx mut ExtCtxt,\n                     };\n \n                     let is_rw = output.is_some();\n-                    let is_indirect = constraint.contains(\"*\");\n+                    let is_indirect = constraint_str.contains(\"*\");\n                     outputs.push(ast::InlineAsmOutput {\n-                        constraint: output.unwrap_or(constraint.clone()),\n+                        constraint: output.unwrap_or(constraint),\n                         expr: out,\n                         is_rw: is_rw,\n                         is_indirect: is_indirect,\n@@ -166,9 +167,9 @@ pub fn expand_asm<'cx>(cx: &'cx mut ExtCtxt,\n \n                     let (constraint, _str_style) = panictry!(p.parse_str());\n \n-                    if constraint.starts_with(\"=\") {\n+                    if constraint.as_str().starts_with(\"=\") {\n                         cx.span_err(p.prev_span, \"input operand constraint contains '='\");\n-                    } else if constraint.starts_with(\"+\") {\n+                    } else if constraint.as_str().starts_with(\"+\") {\n                         cx.span_err(p.prev_span, \"input operand constraint contains '+'\");\n                     }\n \n@@ -190,7 +191,7 @@ pub fn expand_asm<'cx>(cx: &'cx mut ExtCtxt,\n \n                     if OPTIONS.iter().any(|&opt| s == opt) {\n                         cx.span_warn(p.prev_span, \"expected a clobber, found an option\");\n-                    } else if s.starts_with(\"{\") || s.ends_with(\"}\") {\n+                    } else if s.as_str().starts_with(\"{\") || s.as_str().ends_with(\"}\") {\n                         cx.span_err(p.prev_span, \"clobber should not be surrounded by braces\");\n                     }\n \n@@ -242,7 +243,7 @@ pub fn expand_asm<'cx>(cx: &'cx mut ExtCtxt,\n     let expn_id = cx.codemap().record_expansion(codemap::ExpnInfo {\n         call_site: sp,\n         callee: codemap::NameAndSpan {\n-            format: codemap::MacroBang(intern(\"asm\")),\n+            format: codemap::MacroBang(Symbol::intern(\"asm\")),\n             span: None,\n             allow_internal_unstable: false,\n         },\n@@ -251,7 +252,7 @@ pub fn expand_asm<'cx>(cx: &'cx mut ExtCtxt,\n     MacEager::expr(P(ast::Expr {\n         id: ast::DUMMY_NODE_ID,\n         node: ast::ExprKind::InlineAsm(P(ast::InlineAsm {\n-            asm: token::intern_and_get_ident(&asm),\n+            asm: asm,\n             asm_str_style: asm_str_style.unwrap(),\n             outputs: outputs,\n             inputs: inputs,"}, {"sha": "bfe18dc4060c929820c2a6c363bf213c84193846", "filename": "src/libsyntax_ext/concat.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibsyntax_ext%2Fconcat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibsyntax_ext%2Fconcat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fconcat.rs?ref=ebec55406ba94faf8b2cd23b27a8f74df97d1ca4", "patch": "@@ -11,7 +11,7 @@\n use syntax::ast;\n use syntax::ext::base;\n use syntax::ext::build::AstBuilder;\n-use syntax::parse::token;\n+use syntax::symbol::Symbol;\n use syntax_pos;\n use syntax::tokenstream;\n \n@@ -33,7 +33,7 @@ pub fn expand_syntax_ext(cx: &mut base::ExtCtxt,\n                     ast::LitKind::Str(ref s, _) |\n                     ast::LitKind::Float(ref s, _) |\n                     ast::LitKind::FloatUnsuffixed(ref s) => {\n-                        accumulator.push_str(&s);\n+                        accumulator.push_str(&s.as_str());\n                     }\n                     ast::LitKind::Char(c) => {\n                         accumulator.push(c);\n@@ -57,5 +57,5 @@ pub fn expand_syntax_ext(cx: &mut base::ExtCtxt,\n             }\n         }\n     }\n-    base::MacEager::expr(cx.expr_str(sp, token::intern_and_get_ident(&accumulator[..])))\n+    base::MacEager::expr(cx.expr_str(sp, Symbol::intern(&accumulator)))\n }"}, {"sha": "b26e33eb384dc0017fc942a16ec9e62e0bf9e6c7", "filename": "src/libsyntax_ext/concat_idents.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibsyntax_ext%2Fconcat_idents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibsyntax_ext%2Fconcat_idents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fconcat_idents.rs?ref=ebec55406ba94faf8b2cd23b27a8f74df97d1ca4", "patch": "@@ -13,7 +13,6 @@ use syntax::ext::base::*;\n use syntax::ext::base;\n use syntax::feature_gate;\n use syntax::parse::token;\n-use syntax::parse::token::str_to_ident;\n use syntax::ptr::P;\n use syntax_pos::Span;\n use syntax::tokenstream::TokenTree;\n@@ -51,7 +50,7 @@ pub fn expand_syntax_ext<'cx>(cx: &'cx mut ExtCtxt,\n             }\n         }\n     }\n-    let res = str_to_ident(&res_str);\n+    let res = ast::Ident::from_str(&res_str);\n \n     struct Result {\n         ident: ast::Ident,"}, {"sha": "d14b59d6c70e2f20bdaa0dde1ab1706501c10e22", "filename": "src/libsyntax_ext/deriving/clone.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibsyntax_ext%2Fderiving%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibsyntax_ext%2Fderiving%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fclone.rs?ref=ebec55406ba94faf8b2cd23b27a8f74df97d1ca4", "patch": "@@ -15,8 +15,8 @@ use syntax::ast::{self, Expr, Generics, ItemKind, MetaItem, VariantData};\n use syntax::attr;\n use syntax::ext::base::{Annotatable, ExtCtxt};\n use syntax::ext::build::AstBuilder;\n-use syntax::parse::token::{keywords, InternedString};\n use syntax::ptr::P;\n+use syntax::symbol::{Symbol, keywords};\n use syntax_pos::Span;\n \n pub fn expand_deriving_clone(cx: &mut ExtCtxt,\n@@ -74,7 +74,7 @@ pub fn expand_deriving_clone(cx: &mut ExtCtxt,\n         _ => cx.span_bug(span, \"#[derive(Clone)] on trait item or impl item\"),\n     }\n \n-    let inline = cx.meta_word(span, InternedString::new(\"inline\"));\n+    let inline = cx.meta_word(span, Symbol::intern(\"inline\"));\n     let attrs = vec![cx.attribute(span, inline)];\n     let trait_def = TraitDef {\n         span: span,"}, {"sha": "6ab5987a159cad3983df2818414950279f52523f", "filename": "src/libsyntax_ext/deriving/cmp/eq.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Feq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Feq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Feq.rs?ref=ebec55406ba94faf8b2cd23b27a8f74df97d1ca4", "patch": "@@ -14,18 +14,18 @@ use deriving::generic::ty::*;\n use syntax::ast::{self, Expr, MetaItem};\n use syntax::ext::base::{Annotatable, ExtCtxt};\n use syntax::ext::build::AstBuilder;\n-use syntax::parse::token::InternedString;\n use syntax::ptr::P;\n+use syntax::symbol::Symbol;\n use syntax_pos::Span;\n \n pub fn expand_deriving_eq(cx: &mut ExtCtxt,\n                           span: Span,\n                           mitem: &MetaItem,\n                           item: &Annotatable,\n                           push: &mut FnMut(Annotatable)) {\n-    let inline = cx.meta_word(span, InternedString::new(\"inline\"));\n-    let hidden = cx.meta_list_item_word(span, InternedString::new(\"hidden\"));\n-    let doc = cx.meta_list(span, InternedString::new(\"doc\"), vec![hidden]);\n+    let inline = cx.meta_word(span, Symbol::intern(\"inline\"));\n+    let hidden = cx.meta_list_item_word(span, Symbol::intern(\"hidden\"));\n+    let doc = cx.meta_list(span, Symbol::intern(\"doc\"), vec![hidden]);\n     let attrs = vec![cx.attribute(span, inline), cx.attribute(span, doc)];\n     let trait_def = TraitDef {\n         span: span,"}, {"sha": "9fc3d997585d711abfbc3fb2403a554c0bfc1deb", "filename": "src/libsyntax_ext/deriving/cmp/ord.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Ford.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Ford.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Ford.rs?ref=ebec55406ba94faf8b2cd23b27a8f74df97d1ca4", "patch": "@@ -14,16 +14,16 @@ use deriving::generic::ty::*;\n use syntax::ast::{self, Expr, MetaItem};\n use syntax::ext::base::{Annotatable, ExtCtxt};\n use syntax::ext::build::AstBuilder;\n-use syntax::parse::token::InternedString;\n use syntax::ptr::P;\n+use syntax::symbol::Symbol;\n use syntax_pos::Span;\n \n pub fn expand_deriving_ord(cx: &mut ExtCtxt,\n                            span: Span,\n                            mitem: &MetaItem,\n                            item: &Annotatable,\n                            push: &mut FnMut(Annotatable)) {\n-    let inline = cx.meta_word(span, InternedString::new(\"inline\"));\n+    let inline = cx.meta_word(span, Symbol::intern(\"inline\"));\n     let attrs = vec![cx.attribute(span, inline)];\n     let trait_def = TraitDef {\n         span: span,"}, {"sha": "f2a050ce971edc76d414d9998ccfaa70d0a414f7", "filename": "src/libsyntax_ext/deriving/cmp/partial_eq.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Fpartial_eq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Fpartial_eq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Fpartial_eq.rs?ref=ebec55406ba94faf8b2cd23b27a8f74df97d1ca4", "patch": "@@ -14,8 +14,8 @@ use deriving::generic::ty::*;\n use syntax::ast::{BinOpKind, Expr, MetaItem};\n use syntax::ext::base::{Annotatable, ExtCtxt};\n use syntax::ext::build::AstBuilder;\n-use syntax::parse::token::InternedString;\n use syntax::ptr::P;\n+use syntax::symbol::Symbol;\n use syntax_pos::Span;\n \n pub fn expand_deriving_partial_eq(cx: &mut ExtCtxt,\n@@ -64,7 +64,7 @@ pub fn expand_deriving_partial_eq(cx: &mut ExtCtxt,\n \n     macro_rules! md {\n         ($name:expr, $f:ident) => { {\n-            let inline = cx.meta_word(span, InternedString::new(\"inline\"));\n+            let inline = cx.meta_word(span, Symbol::intern(\"inline\"));\n             let attrs = vec![cx.attribute(span, inline)];\n             MethodDef {\n                 name: $name,"}, {"sha": "ce4d549d696f4d344fb3f2e938f9e370db456fb8", "filename": "src/libsyntax_ext/deriving/cmp/partial_ord.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Fpartial_ord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Fpartial_ord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Fpartial_ord.rs?ref=ebec55406ba94faf8b2cd23b27a8f74df97d1ca4", "patch": "@@ -16,8 +16,8 @@ use deriving::generic::ty::*;\n use syntax::ast::{self, BinOpKind, Expr, MetaItem};\n use syntax::ext::base::{Annotatable, ExtCtxt};\n use syntax::ext::build::AstBuilder;\n-use syntax::parse::token::InternedString;\n use syntax::ptr::P;\n+use syntax::symbol::Symbol;\n use syntax_pos::Span;\n \n pub fn expand_deriving_partial_ord(cx: &mut ExtCtxt,\n@@ -27,7 +27,7 @@ pub fn expand_deriving_partial_ord(cx: &mut ExtCtxt,\n                                    push: &mut FnMut(Annotatable)) {\n     macro_rules! md {\n         ($name:expr, $op:expr, $equal:expr) => { {\n-            let inline = cx.meta_word(span, InternedString::new(\"inline\"));\n+            let inline = cx.meta_word(span, Symbol::intern(\"inline\"));\n             let attrs = vec![cx.attribute(span, inline)];\n             MethodDef {\n                 name: $name,\n@@ -51,7 +51,7 @@ pub fn expand_deriving_partial_ord(cx: &mut ExtCtxt,\n                                     vec![Box::new(ordering_ty)],\n                                     true));\n \n-    let inline = cx.meta_word(span, InternedString::new(\"inline\"));\n+    let inline = cx.meta_word(span, Symbol::intern(\"inline\"));\n     let attrs = vec![cx.attribute(span, inline)];\n \n     let partial_cmp_def = MethodDef {"}, {"sha": "1076a6a6d63a5bef4e90c8816dc9304af46c4b8d", "filename": "src/libsyntax_ext/deriving/custom.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibsyntax_ext%2Fderiving%2Fcustom.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibsyntax_ext%2Fderiving%2Fcustom.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fcustom.rs?ref=ebec55406ba94faf8b2cd23b27a8f74df97d1ca4", "patch": "@@ -17,10 +17,9 @@ use syntax::attr::{mark_used, mark_known};\n use syntax::codemap::Span;\n use syntax::ext::base::*;\n use syntax::fold::Folder;\n-use syntax::parse::token::InternedString;\n use syntax::visit::Visitor;\n \n-struct MarkAttrs<'a>(&'a [InternedString]);\n+struct MarkAttrs<'a>(&'a [ast::Name]);\n \n impl<'a> Visitor for MarkAttrs<'a> {\n     fn visit_attribute(&mut self, attr: &Attribute) {\n@@ -33,13 +32,11 @@ impl<'a> Visitor for MarkAttrs<'a> {\n \n pub struct CustomDerive {\n     inner: fn(TokenStream) -> TokenStream,\n-    attrs: Vec<InternedString>,\n+    attrs: Vec<ast::Name>,\n }\n \n impl CustomDerive {\n-    pub fn new(inner: fn(TokenStream) -> TokenStream,\n-               attrs: Vec<InternedString>)\n-               -> CustomDerive {\n+    pub fn new(inner: fn(TokenStream) -> TokenStream, attrs: Vec<ast::Name>) -> CustomDerive {\n         CustomDerive { inner: inner, attrs: attrs }\n     }\n }"}, {"sha": "a767716466cb15d13e1902ecccf1fa4a97a73064", "filename": "src/libsyntax_ext/deriving/debug.rs", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibsyntax_ext%2Fderiving%2Fdebug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibsyntax_ext%2Fderiving%2Fdebug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fdebug.rs?ref=ebec55406ba94faf8b2cd23b27a8f74df97d1ca4", "patch": "@@ -11,11 +11,10 @@\n use deriving::generic::*;\n use deriving::generic::ty::*;\n \n-use syntax::ast;\n+use syntax::ast::{self, Ident};\n use syntax::ast::{Expr, MetaItem};\n use syntax::ext::base::{Annotatable, ExtCtxt};\n use syntax::ext::build::AstBuilder;\n-use syntax::parse::token;\n use syntax::ptr::P;\n use syntax_pos::{DUMMY_SP, Span};\n \n@@ -69,9 +68,8 @@ fn show_substructure(cx: &mut ExtCtxt, span: Span, substr: &Substructure) -> P<E\n \n     // We want to make sure we have the expn_id set so that we can use unstable methods\n     let span = Span { expn_id: cx.backtrace(), ..span };\n-    let name = cx.expr_lit(span,\n-                           ast::LitKind::Str(ident.name.as_str(), ast::StrStyle::Cooked));\n-    let builder = token::str_to_ident(\"builder\");\n+    let name = cx.expr_lit(span, ast::LitKind::Str(ident.name, ast::StrStyle::Cooked));\n+    let builder = Ident::from_str(\"builder\");\n     let builder_expr = cx.expr_ident(span, builder.clone());\n \n     let fmt = substr.nonself_args[0].clone();\n@@ -83,7 +81,7 @@ fn show_substructure(cx: &mut ExtCtxt, span: Span, substr: &Substructure) -> P<E\n             if !is_struct {\n                 // tuple struct/\"normal\" variant\n                 let expr =\n-                    cx.expr_method_call(span, fmt, token::str_to_ident(\"debug_tuple\"), vec![name]);\n+                    cx.expr_method_call(span, fmt, Ident::from_str(\"debug_tuple\"), vec![name]);\n                 stmts.push(cx.stmt_let(DUMMY_SP, true, builder, expr));\n \n                 for field in fields {\n@@ -93,7 +91,7 @@ fn show_substructure(cx: &mut ExtCtxt, span: Span, substr: &Substructure) -> P<E\n \n                     let expr = cx.expr_method_call(span,\n                                                    builder_expr.clone(),\n-                                                   token::str_to_ident(\"field\"),\n+                                                   Ident::from_str(\"field\"),\n                                                    vec![field]);\n \n                     // Use `let _ = expr;` to avoid triggering the\n@@ -103,20 +101,20 @@ fn show_substructure(cx: &mut ExtCtxt, span: Span, substr: &Substructure) -> P<E\n             } else {\n                 // normal struct/struct variant\n                 let expr =\n-                    cx.expr_method_call(span, fmt, token::str_to_ident(\"debug_struct\"), vec![name]);\n+                    cx.expr_method_call(span, fmt, Ident::from_str(\"debug_struct\"), vec![name]);\n                 stmts.push(cx.stmt_let(DUMMY_SP, true, builder, expr));\n \n                 for field in fields {\n                     let name = cx.expr_lit(field.span,\n-                                           ast::LitKind::Str(field.name.unwrap().name.as_str(),\n+                                           ast::LitKind::Str(field.name.unwrap().name,\n                                                              ast::StrStyle::Cooked));\n \n                     // Use double indirection to make sure this works for unsized types\n                     let field = cx.expr_addr_of(field.span, field.self_.clone());\n                     let field = cx.expr_addr_of(field.span, field);\n                     let expr = cx.expr_method_call(span,\n                                                    builder_expr.clone(),\n-                                                   token::str_to_ident(\"field\"),\n+                                                   Ident::from_str(\"field\"),\n                                                    vec![name, field]);\n                     stmts.push(stmt_let_undescore(cx, span, expr));\n                 }\n@@ -126,7 +124,7 @@ fn show_substructure(cx: &mut ExtCtxt, span: Span, substr: &Substructure) -> P<E\n         _ => unreachable!(),\n     };\n \n-    let expr = cx.expr_method_call(span, builder_expr, token::str_to_ident(\"finish\"), vec![]);\n+    let expr = cx.expr_method_call(span, builder_expr, Ident::from_str(\"finish\"), vec![]);\n \n     stmts.push(cx.stmt_expr(expr));\n     let block = cx.block(span, stmts);"}, {"sha": "e2634c60dcaad0cd8f16ab3e824c8a54e8b7ccbb", "filename": "src/libsyntax_ext/deriving/decodable.rs", "status": "modified", "additions": 7, "deletions": 11, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibsyntax_ext%2Fderiving%2Fdecodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibsyntax_ext%2Fderiving%2Fdecodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fdecodable.rs?ref=ebec55406ba94faf8b2cd23b27a8f74df97d1ca4", "patch": "@@ -18,9 +18,8 @@ use syntax::ast;\n use syntax::ast::{Expr, MetaItem, Mutability};\n use syntax::ext::base::{Annotatable, ExtCtxt};\n use syntax::ext::build::AstBuilder;\n-use syntax::parse::token::InternedString;\n-use syntax::parse::token;\n use syntax::ptr::P;\n+use syntax::symbol::Symbol;\n use syntax_pos::Span;\n \n pub fn expand_deriving_rustc_decodable(cx: &mut ExtCtxt,\n@@ -131,7 +130,7 @@ fn decodable_substructure(cx: &mut ExtCtxt,\n             cx.expr_method_call(trait_span,\n                                 decoder,\n                                 cx.ident_of(\"read_struct\"),\n-                                vec![cx.expr_str(trait_span, substr.type_ident.name.as_str()),\n+                                vec![cx.expr_str(trait_span, substr.type_ident.name),\n                                      cx.expr_usize(trait_span, nfields),\n                                      cx.lambda1(trait_span, result, blkarg)])\n         }\n@@ -143,7 +142,7 @@ fn decodable_substructure(cx: &mut ExtCtxt,\n             let rvariant_arg = cx.ident_of(\"read_enum_variant_arg\");\n \n             for (i, &(ident, v_span, ref parts)) in fields.iter().enumerate() {\n-                variants.push(cx.expr_str(v_span, ident.name.as_str()));\n+                variants.push(cx.expr_str(v_span, ident.name));\n \n                 let path = cx.path(trait_span, vec![substr.type_ident, ident]);\n                 let decoded = decode_static_fields(cx, v_span, path, parts, |cx, span, _, field| {\n@@ -175,7 +174,7 @@ fn decodable_substructure(cx: &mut ExtCtxt,\n             cx.expr_method_call(trait_span,\n                                 decoder,\n                                 cx.ident_of(\"read_enum\"),\n-                                vec![cx.expr_str(trait_span, substr.type_ident.name.as_str()),\n+                                vec![cx.expr_str(trait_span, substr.type_ident.name),\n                                      cx.lambda1(trait_span, result, blkarg)])\n         }\n         _ => cx.bug(\"expected StaticEnum or StaticStruct in derive(Decodable)\"),\n@@ -191,7 +190,7 @@ fn decode_static_fields<F>(cx: &mut ExtCtxt,\n                            fields: &StaticFields,\n                            mut getarg: F)\n                            -> P<Expr>\n-    where F: FnMut(&mut ExtCtxt, Span, InternedString, usize) -> P<Expr>\n+    where F: FnMut(&mut ExtCtxt, Span, Symbol, usize) -> P<Expr>\n {\n     match *fields {\n         Unnamed(ref fields, is_tuple) => {\n@@ -202,10 +201,7 @@ fn decode_static_fields<F>(cx: &mut ExtCtxt,\n                 let fields = fields.iter()\n                     .enumerate()\n                     .map(|(i, &span)| {\n-                        getarg(cx,\n-                               span,\n-                               token::intern_and_get_ident(&format!(\"_field{}\", i)),\n-                               i)\n+                        getarg(cx, span, Symbol::intern(&format!(\"_field{}\", i)), i)\n                     })\n                     .collect();\n \n@@ -217,7 +213,7 @@ fn decode_static_fields<F>(cx: &mut ExtCtxt,\n             let fields = fields.iter()\n                 .enumerate()\n                 .map(|(i, &(ident, span))| {\n-                    let arg = getarg(cx, span, ident.name.as_str(), i);\n+                    let arg = getarg(cx, span, ident.name, i);\n                     cx.field_imm(span, ident, arg)\n                 })\n                 .collect();"}, {"sha": "69391f48c2288dd512119c79d23412b5423b53ba", "filename": "src/libsyntax_ext/deriving/default.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibsyntax_ext%2Fderiving%2Fdefault.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibsyntax_ext%2Fderiving%2Fdefault.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fdefault.rs?ref=ebec55406ba94faf8b2cd23b27a8f74df97d1ca4", "patch": "@@ -14,16 +14,16 @@ use deriving::generic::ty::*;\n use syntax::ast::{Expr, MetaItem};\n use syntax::ext::base::{Annotatable, ExtCtxt};\n use syntax::ext::build::AstBuilder;\n-use syntax::parse::token::InternedString;\n use syntax::ptr::P;\n+use syntax::symbol::Symbol;\n use syntax_pos::Span;\n \n pub fn expand_deriving_default(cx: &mut ExtCtxt,\n                                span: Span,\n                                mitem: &MetaItem,\n                                item: &Annotatable,\n                                push: &mut FnMut(Annotatable)) {\n-    let inline = cx.meta_word(span, InternedString::new(\"inline\"));\n+    let inline = cx.meta_word(span, Symbol::intern(\"inline\"));\n     let attrs = vec![cx.attribute(span, inline)];\n     let trait_def = TraitDef {\n         span: span,"}, {"sha": "092738ab8a03d372333f6272ae608e775cc9d617", "filename": "src/libsyntax_ext/deriving/encodable.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibsyntax_ext%2Fderiving%2Fencodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibsyntax_ext%2Fderiving%2Fencodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fencodable.rs?ref=ebec55406ba94faf8b2cd23b27a8f74df97d1ca4", "patch": "@@ -95,8 +95,8 @@ use deriving::generic::ty::*;\n use syntax::ast::{Expr, ExprKind, MetaItem, Mutability};\n use syntax::ext::base::{Annotatable, ExtCtxt};\n use syntax::ext::build::AstBuilder;\n-use syntax::parse::token;\n use syntax::ptr::P;\n+use syntax::symbol::Symbol;\n use syntax_pos::Span;\n \n pub fn expand_deriving_rustc_encodable(cx: &mut ExtCtxt,\n@@ -192,8 +192,8 @@ fn encodable_substructure(cx: &mut ExtCtxt,\n             let mut stmts = Vec::new();\n             for (i, &FieldInfo { name, ref self_, span, .. }) in fields.iter().enumerate() {\n                 let name = match name {\n-                    Some(id) => id.name.as_str(),\n-                    None => token::intern_and_get_ident(&format!(\"_field{}\", i)),\n+                    Some(id) => id.name,\n+                    None => Symbol::intern(&format!(\"_field{}\", i)),\n                 };\n                 let self_ref = cx.expr_addr_of(span, self_.clone());\n                 let enc = cx.expr_call(span, fn_path.clone(), vec![self_ref, blkencoder.clone()]);\n@@ -226,7 +226,7 @@ fn encodable_substructure(cx: &mut ExtCtxt,\n             cx.expr_method_call(trait_span,\n                                 encoder,\n                                 cx.ident_of(\"emit_struct\"),\n-                                vec![cx.expr_str(trait_span, substr.type_ident.name.as_str()),\n+                                vec![cx.expr_str(trait_span, substr.type_ident.name),\n                                      cx.expr_usize(trait_span, fields.len()),\n                                      blk])\n         }\n@@ -265,7 +265,7 @@ fn encodable_substructure(cx: &mut ExtCtxt,\n             }\n \n             let blk = cx.lambda_stmts_1(trait_span, stmts, blkarg);\n-            let name = cx.expr_str(trait_span, variant.node.name.name.as_str());\n+            let name = cx.expr_str(trait_span, variant.node.name.name);\n             let call = cx.expr_method_call(trait_span,\n                                            blkencoder,\n                                            cx.ident_of(\"emit_enum_variant\"),\n@@ -277,8 +277,7 @@ fn encodable_substructure(cx: &mut ExtCtxt,\n             let ret = cx.expr_method_call(trait_span,\n                                           encoder,\n                                           cx.ident_of(\"emit_enum\"),\n-                                          vec![cx.expr_str(trait_span,\n-                                                           substr.type_ident.name.as_str()),\n+                                          vec![cx.expr_str(trait_span ,substr.type_ident.name),\n                                                blk]);\n             cx.expr_block(cx.block(trait_span, vec![me, cx.stmt_expr(ret)]))\n         }"}, {"sha": "63cd7678321ef832686b8f68fe827d064e8839dd", "filename": "src/libsyntax_ext/deriving/generic/mod.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs?ref=ebec55406ba94faf8b2cd23b27a8f74df97d1ca4", "patch": "@@ -198,8 +198,8 @@ use syntax::ext::base::{Annotatable, ExtCtxt};\n use syntax::ext::build::AstBuilder;\n use syntax::codemap::{self, dummy_spanned, respan};\n use syntax::util::move_map::MoveMap;\n-use syntax::parse::token::{InternedString, keywords};\n use syntax::ptr::P;\n+use syntax::symbol::{Symbol, keywords};\n use syntax_pos::{DUMMY_SP, Span};\n use errors::Handler;\n \n@@ -442,7 +442,7 @@ impl<'a> TraitDef<'a> {\n                 attrs.extend(item.attrs\n                     .iter()\n                     .filter(|a| {\n-                        match &a.name()[..] {\n+                        match &*a.name().as_str() {\n                             \"allow\" | \"warn\" | \"deny\" | \"forbid\" | \"stable\" | \"unstable\" => true,\n                             _ => false,\n                         }\n@@ -639,15 +639,15 @@ impl<'a> TraitDef<'a> {\n \n         let attr = cx.attribute(self.span,\n                                 cx.meta_word(self.span,\n-                                             InternedString::new(\"automatically_derived\")));\n+                                             Symbol::intern(\"automatically_derived\")));\n         // Just mark it now since we know that it'll end up used downstream\n         attr::mark_used(&attr);\n         let opt_trait_ref = Some(trait_ref);\n-        let unused_qual = cx.attribute(self.span,\n-                                       cx.meta_list(self.span,\n-                                                    InternedString::new(\"allow\"),\n-                                                    vec![cx.meta_list_item_word(self.span,\n-                                           InternedString::new(\"unused_qualifications\"))]));\n+        let unused_qual = {\n+            let word = cx.meta_list_item_word(self.span, Symbol::intern(\"unused_qualifications\"));\n+            cx.attribute(self.span, cx.meta_list(self.span, Symbol::intern(\"allow\"), vec![word]))\n+        };\n+\n         let mut a = vec![attr, unused_qual];\n         a.extend(self.attributes.iter().cloned());\n "}, {"sha": "535d7de19e341aa5432f89d3a57512cd21f19f08", "filename": "src/libsyntax_ext/deriving/mod.rs", "status": "modified", "additions": 28, "deletions": 32, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs?ref=ebec55406ba94faf8b2cd23b27a8f74df97d1ca4", "patch": "@@ -16,8 +16,8 @@ use syntax::codemap;\n use syntax::ext::base::{Annotatable, ExtCtxt, SyntaxExtension};\n use syntax::ext::build::AstBuilder;\n use syntax::feature_gate::{self, emit_feature_err};\n-use syntax::parse::token::{intern, intern_and_get_ident};\n use syntax::ptr::P;\n+use syntax::symbol::Symbol;\n use syntax_pos::Span;\n \n macro_rules! pathvec {\n@@ -80,7 +80,7 @@ fn allow_unstable(cx: &mut ExtCtxt, span: Span, attr_name: &str) -> Span {\n         expn_id: cx.codemap().record_expansion(codemap::ExpnInfo {\n             call_site: span,\n             callee: codemap::NameAndSpan {\n-                format: codemap::MacroAttribute(intern(attr_name)),\n+                format: codemap::MacroAttribute(Symbol::intern(attr_name)),\n                 span: Some(span),\n                 allow_internal_unstable: true,\n             },\n@@ -105,17 +105,18 @@ pub fn expand_derive(cx: &mut ExtCtxt,\n         }\n     };\n \n+    let derive = Symbol::intern(\"derive\");\n     let mut derive_attrs = Vec::new();\n     item = item.map_attrs(|attrs| {\n-        let partition = attrs.into_iter().partition(|attr| &attr.name() == \"derive\");\n+        let partition = attrs.into_iter().partition(|attr| attr.name() == derive);\n         derive_attrs = partition.0;\n         partition.1\n     });\n \n     // Expand `#[derive]`s after other attribute macro invocations.\n     if cx.resolver.find_attr_invoc(&mut item.attrs.clone()).is_some() {\n         return vec![Annotatable::Item(item.map_attrs(|mut attrs| {\n-            attrs.push(cx.attribute(span, P(mitem.clone())));\n+            attrs.push(cx.attribute(span, mitem.clone()));\n             attrs.extend(derive_attrs);\n             attrs\n         }))];\n@@ -135,7 +136,7 @@ pub fn expand_derive(cx: &mut ExtCtxt,\n \n     let mut traits = get_traits(mitem, cx);\n     for derive_attr in derive_attrs {\n-        traits.extend(get_traits(&derive_attr.node.value, cx));\n+        traits.extend(get_traits(&derive_attr.value, cx));\n     }\n \n     // First, weed out malformed #[derive]\n@@ -158,9 +159,8 @@ pub fn expand_derive(cx: &mut ExtCtxt,\n         let tword = titem.word().unwrap();\n         let tname = tword.name();\n \n-        if is_builtin_trait(&tname) || {\n-            let derive_mode =\n-                ast::Path::from_ident(titem.span, ast::Ident::with_empty_ctxt(intern(&tname)));\n+        if is_builtin_trait(tname) || {\n+            let derive_mode = ast::Path::from_ident(titem.span, ast::Ident::with_empty_ctxt(tname));\n             cx.resolver.resolve_macro(cx.current_expansion.mark, &derive_mode, false).map(|ext| {\n                 if let SyntaxExtension::CustomDerive(_) = *ext { true } else { false }\n             }).unwrap_or(false)\n@@ -176,7 +176,7 @@ pub fn expand_derive(cx: &mut ExtCtxt,\n                                            feature_gate::EXPLAIN_CUSTOM_DERIVE);\n         } else {\n             cx.span_warn(titem.span, feature_gate::EXPLAIN_DEPR_CUSTOM_DERIVE);\n-            let name = intern_and_get_ident(&format!(\"derive_{}\", tname));\n+            let name = Symbol::intern(&format!(\"derive_{}\", tname));\n             let mitem = cx.meta_word(titem.span, name);\n             new_attributes.push(cx.attribute(mitem.span, mitem));\n         }\n@@ -186,9 +186,7 @@ pub fn expand_derive(cx: &mut ExtCtxt,\n         item = item.map(|mut i| {\n             i.attrs.extend(new_attributes);\n             if traits.len() > 0 {\n-                let list = cx.meta_list(mitem.span,\n-                                        intern_and_get_ident(\"derive\"),\n-                                        traits);\n+                let list = cx.meta_list(mitem.span, derive, traits);\n                 i.attrs.push(cx.attribute(mitem.span, list));\n             }\n             i\n@@ -217,7 +215,7 @@ pub fn expand_derive(cx: &mut ExtCtxt,\n     let macros_11_derive = traits.iter()\n                                  .cloned()\n                                  .enumerate()\n-                                 .filter(|&(_, ref name)| !is_builtin_trait(&name.name().unwrap()))\n+                                 .filter(|&(_, ref name)| !is_builtin_trait(name.name().unwrap()))\n                                  .next();\n     if let Some((i, titem)) = macros_11_derive {\n         if !cx.ecfg.features.unwrap().proc_macro {\n@@ -226,24 +224,20 @@ pub fn expand_derive(cx: &mut ExtCtxt,\n             emit_feature_err(cx.parse_sess, \"proc_macro\", titem.span, issue, msg);\n         }\n \n-        let tname = ast::Ident::with_empty_ctxt(intern(&titem.name().unwrap()));\n+        let tname = ast::Ident::with_empty_ctxt(titem.name().unwrap());\n         let path = ast::Path::from_ident(titem.span, tname);\n         let ext = cx.resolver.resolve_macro(cx.current_expansion.mark, &path, false).unwrap();\n \n         traits.remove(i);\n         if traits.len() > 0 {\n             item = item.map(|mut i| {\n-                let list = cx.meta_list(mitem.span,\n-                                        intern_and_get_ident(\"derive\"),\n-                                        traits);\n+                let list = cx.meta_list(mitem.span, derive, traits);\n                 i.attrs.push(cx.attribute(mitem.span, list));\n                 i\n             });\n         }\n         let titem = cx.meta_list_item_word(titem.span, titem.name().unwrap());\n-        let mitem = cx.meta_list(titem.span,\n-                                 intern_and_get_ident(\"derive\"),\n-                                 vec![titem]);\n+        let mitem = cx.meta_list(titem.span, derive, vec![titem]);\n         let item = Annotatable::Item(item);\n         if let SyntaxExtension::CustomDerive(ref ext) = *ext {\n             return ext.expand(cx, mitem.span, &mitem, item);\n@@ -257,9 +251,10 @@ pub fn expand_derive(cx: &mut ExtCtxt,\n \n     // RFC #1445. `#[derive(PartialEq, Eq)]` adds a (trusted)\n     // `#[structural_match]` attribute.\n-    if traits.iter().filter_map(|t| t.name()).any(|t| t == \"PartialEq\") &&\n-       traits.iter().filter_map(|t| t.name()).any(|t| t == \"Eq\") {\n-        let structural_match = intern_and_get_ident(\"structural_match\");\n+    let (partial_eq, eq) = (Symbol::intern(\"PartialEq\"), Symbol::intern(\"Eq\"));\n+    if traits.iter().any(|t| t.name() == Some(partial_eq)) &&\n+       traits.iter().any(|t| t.name() == Some(eq)) {\n+        let structural_match = Symbol::intern(\"structural_match\");\n         let span = allow_unstable(cx, span, \"derive(PartialEq, Eq)\");\n         let meta = cx.meta_word(span, structural_match);\n         item = item.map(|mut i| {\n@@ -272,9 +267,10 @@ pub fn expand_derive(cx: &mut ExtCtxt,\n     // the same as the copy implementation.\n     //\n     // Add a marker attribute here picked up during #[derive(Clone)]\n-    if traits.iter().filter_map(|t| t.name()).any(|t| t == \"Clone\") &&\n-       traits.iter().filter_map(|t| t.name()).any(|t| t == \"Copy\") {\n-        let marker = intern_and_get_ident(\"rustc_copy_clone_marker\");\n+    let (copy, clone) = (Symbol::intern(\"Copy\"), Symbol::intern(\"Clone\"));\n+    if traits.iter().any(|t| t.name() == Some(clone)) &&\n+       traits.iter().any(|t| t.name() == Some(copy)) {\n+        let marker = Symbol::intern(\"rustc_copy_clone_marker\");\n         let span = allow_unstable(cx, span, \"derive(Copy, Clone)\");\n         let meta = cx.meta_word(span, marker);\n         item = item.map(|mut i| {\n@@ -286,14 +282,14 @@ pub fn expand_derive(cx: &mut ExtCtxt,\n     let mut items = Vec::new();\n     for titem in traits.iter() {\n         let tname = titem.word().unwrap().name();\n-        let name = intern_and_get_ident(&format!(\"derive({})\", tname));\n+        let name = Symbol::intern(&format!(\"derive({})\", tname));\n         let mitem = cx.meta_word(titem.span, name);\n \n         let span = Span {\n             expn_id: cx.codemap().record_expansion(codemap::ExpnInfo {\n                 call_site: titem.span,\n                 callee: codemap::NameAndSpan {\n-                    format: codemap::MacroAttribute(intern(&format!(\"derive({})\", tname))),\n+                    format: codemap::MacroAttribute(Symbol::intern(&format!(\"derive({})\", tname))),\n                     span: Some(titem.span),\n                     allow_internal_unstable: true,\n                 },\n@@ -302,7 +298,7 @@ pub fn expand_derive(cx: &mut ExtCtxt,\n         };\n \n         let my_item = Annotatable::Item(item);\n-        expand_builtin(&tname, cx, span, &mitem, &my_item, &mut |a| {\n+        expand_builtin(&tname.as_str(), cx, span, &mitem, &my_item, &mut |a| {\n             items.push(a);\n         });\n         item = my_item.expect_item();\n@@ -314,8 +310,8 @@ pub fn expand_derive(cx: &mut ExtCtxt,\n \n macro_rules! derive_traits {\n     ($( $name:expr => $func:path, )+) => {\n-        pub fn is_builtin_trait(name: &str) -> bool {\n-            match name {\n+        pub fn is_builtin_trait(name: ast::Name) -> bool {\n+            match &*name.as_str() {\n                 $( $name )|+ => true,\n                 _ => false,\n             }\n@@ -412,7 +408,7 @@ fn call_intrinsic(cx: &ExtCtxt,\n     span.expn_id = cx.codemap().record_expansion(codemap::ExpnInfo {\n         call_site: span,\n         callee: codemap::NameAndSpan {\n-            format: codemap::MacroAttribute(intern(\"derive\")),\n+            format: codemap::MacroAttribute(Symbol::intern(\"derive\")),\n             span: Some(span),\n             allow_internal_unstable: true,\n         },"}, {"sha": "ecf0a8f377ea3dc3c81f220cc3688020525778bf", "filename": "src/libsyntax_ext/env.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibsyntax_ext%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibsyntax_ext%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fenv.rs?ref=ebec55406ba94faf8b2cd23b27a8f74df97d1ca4", "patch": "@@ -17,7 +17,7 @@ use syntax::ast;\n use syntax::ext::base::*;\n use syntax::ext::base;\n use syntax::ext::build::AstBuilder;\n-use syntax::parse::token;\n+use syntax::symbol::Symbol;\n use syntax_pos::Span;\n use syntax::tokenstream;\n \n@@ -32,7 +32,7 @@ pub fn expand_option_env<'cx>(cx: &'cx mut ExtCtxt,\n         Some(v) => v,\n     };\n \n-    let e = match env::var(&var[..]) {\n+    let e = match env::var(&*var.as_str()) {\n         Err(..) => {\n             cx.expr_path(cx.path_all(sp,\n                                      true,\n@@ -49,7 +49,7 @@ pub fn expand_option_env<'cx>(cx: &'cx mut ExtCtxt,\n         Ok(s) => {\n             cx.expr_call_global(sp,\n                                 cx.std_path(&[\"option\", \"Option\", \"Some\"]),\n-                                vec![cx.expr_str(sp, token::intern_and_get_ident(&s[..]))])\n+                                vec![cx.expr_str(sp, Symbol::intern(&s))])\n         }\n     };\n     MacEager::expr(e)\n@@ -73,7 +73,7 @@ pub fn expand_env<'cx>(cx: &'cx mut ExtCtxt,\n         Some((v, _style)) => v,\n     };\n     let msg = match exprs.next() {\n-        None => token::intern_and_get_ident(&format!(\"environment variable `{}` not defined\", var)),\n+        None => Symbol::intern(&format!(\"environment variable `{}` not defined\", var)),\n         Some(second) => {\n             match expr_to_string(cx, second, \"expected string literal\") {\n                 None => return DummyResult::expr(sp),\n@@ -87,12 +87,12 @@ pub fn expand_env<'cx>(cx: &'cx mut ExtCtxt,\n         return DummyResult::expr(sp);\n     }\n \n-    let e = match env::var(&var[..]) {\n+    let e = match env::var(&*var.as_str()) {\n         Err(_) => {\n-            cx.span_err(sp, &msg);\n+            cx.span_err(sp, &msg.as_str());\n             cx.expr_usize(sp, 0)\n         }\n-        Ok(s) => cx.expr_str(sp, token::intern_and_get_ident(&s)),\n+        Ok(s) => cx.expr_str(sp, Symbol::intern(&s)),\n     };\n     MacEager::expr(e)\n }"}, {"sha": "d2afa08cadaf4efb40b16f32b46996a9078dc06a", "filename": "src/libsyntax_ext/format.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibsyntax_ext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibsyntax_ext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fformat.rs?ref=ebec55406ba94faf8b2cd23b27a8f74df97d1ca4", "patch": "@@ -17,8 +17,9 @@ use syntax::ast;\n use syntax::ext::base::*;\n use syntax::ext::base;\n use syntax::ext::build::AstBuilder;\n-use syntax::parse::token::{self, keywords};\n+use syntax::parse::token;\n use syntax::ptr::P;\n+use syntax::symbol::{Symbol, keywords};\n use syntax_pos::{Span, DUMMY_SP};\n use syntax::tokenstream;\n \n@@ -369,7 +370,7 @@ impl<'a, 'b> Context<'a, 'b> {\n     /// Translate the accumulated string literals to a literal expression\n     fn trans_literal_string(&mut self) -> P<ast::Expr> {\n         let sp = self.fmtsp;\n-        let s = token::intern_and_get_ident(&self.literal);\n+        let s = Symbol::intern(&self.literal);\n         self.literal.clear();\n         self.ecx.expr_str(sp, s)\n     }\n@@ -727,7 +728,8 @@ pub fn expand_preparsed_format_args(ecx: &mut ExtCtxt,\n         fmtsp: fmt.span,\n     };\n \n-    let mut parser = parse::Parser::new(&fmt.node.0);\n+    let fmt_str = &*fmt.node.0.as_str();\n+    let mut parser = parse::Parser::new(fmt_str);\n     let mut pieces = vec![];\n \n     loop {\n@@ -808,7 +810,6 @@ pub fn expand_preparsed_format_args(ecx: &mut ExtCtxt,\n         // Decide if we want to look for foreign formatting directives.\n         if args_used < args_unused {\n             use super::format_foreign as foreign;\n-            let fmt_str = &fmt.node.0[..];\n \n             // The set of foreign substitutions we've explained.  This prevents spamming the user\n             // with `%d should be written as {}` over and over again."}, {"sha": "e83fd55cd714bfe5032e593fd66e880d2d4b9040", "filename": "src/libsyntax_ext/lib.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibsyntax_ext%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibsyntax_ext%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Flib.rs?ref=ebec55406ba94faf8b2cd23b27a8f74df97d1ca4", "patch": "@@ -53,7 +53,7 @@ use std::rc::Rc;\n use syntax::ast;\n use syntax::ext::base::{MacroExpanderFn, NormalTT, IdentTT, MultiModifier, NamedSyntaxExtension};\n use syntax::ext::tt::macro_rules::MacroRulesExpander;\n-use syntax::parse::token::intern;\n+use syntax::symbol::Symbol;\n \n pub fn register_builtins(resolver: &mut syntax::ext::base::Resolver,\n                          user_exts: Vec<NamedSyntaxExtension>,\n@@ -62,11 +62,11 @@ pub fn register_builtins(resolver: &mut syntax::ext::base::Resolver,\n         resolver.add_ext(ast::Ident::with_empty_ctxt(name), Rc::new(ext));\n     };\n \n-    register(intern(\"macro_rules\"), IdentTT(Box::new(MacroRulesExpander), None, false));\n+    register(Symbol::intern(\"macro_rules\"), IdentTT(Box::new(MacroRulesExpander), None, false));\n \n     macro_rules! register {\n         ($( $name:ident: $f:expr, )*) => { $(\n-            register(intern(stringify!($name)),\n+            register(Symbol::intern(stringify!($name)),\n                      NormalTT(Box::new($f as MacroExpanderFn), None, false));\n         )* }\n     }\n@@ -112,9 +112,10 @@ pub fn register_builtins(resolver: &mut syntax::ext::base::Resolver,\n     }\n \n     // format_args uses `unstable` things internally.\n-    register(intern(\"format_args\"), NormalTT(Box::new(format::expand_format_args), None, true));\n+    register(Symbol::intern(\"format_args\"),\n+             NormalTT(Box::new(format::expand_format_args), None, true));\n \n-    register(intern(\"derive\"), MultiModifier(Box::new(deriving::expand_derive)));\n+    register(Symbol::intern(\"derive\"), MultiModifier(Box::new(deriving::expand_derive)));\n \n     for (name, ext) in user_exts {\n         register(name, ext);"}, {"sha": "bbdbda701ae8eba464d48f88f7a9f6b9e33e8d16", "filename": "src/libsyntax_ext/proc_macro_registrar.rs", "status": "modified", "additions": 14, "deletions": 15, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibsyntax_ext%2Fproc_macro_registrar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibsyntax_ext%2Fproc_macro_registrar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fproc_macro_registrar.rs?ref=ebec55406ba94faf8b2cd23b27a8f74df97d1ca4", "patch": "@@ -17,20 +17,20 @@ use syntax::ext::base::ExtCtxt;\n use syntax::ext::build::AstBuilder;\n use syntax::ext::expand::ExpansionConfig;\n use syntax::parse::ParseSess;\n-use syntax::parse::token::{self, InternedString};\n use syntax::feature_gate::Features;\n use syntax::fold::Folder;\n use syntax::ptr::P;\n+use syntax::symbol::Symbol;\n use syntax_pos::{Span, DUMMY_SP};\n use syntax::visit::{self, Visitor};\n \n use deriving;\n \n struct CustomDerive {\n-    trait_name: InternedString,\n+    trait_name: ast::Name,\n     function_name: Ident,\n     span: Span,\n-    attrs: Vec<InternedString>,\n+    attrs: Vec<ast::Name>,\n }\n \n struct CollectCustomDerives<'a> {\n@@ -183,7 +183,7 @@ impl<'a> Visitor for CollectCustomDerives<'a> {\n             self.handler.span_err(trait_attr.span(), \"must only be one word\");\n         }\n \n-        if deriving::is_builtin_trait(&trait_name) {\n+        if deriving::is_builtin_trait(trait_name) {\n             self.handler.span_err(trait_attr.span(),\n                                   \"cannot override a built-in #[derive] mode\");\n         }\n@@ -271,29 +271,29 @@ fn mk_registrar(cx: &mut ExtCtxt,\n     let eid = cx.codemap().record_expansion(ExpnInfo {\n         call_site: DUMMY_SP,\n         callee: NameAndSpan {\n-            format: MacroAttribute(token::intern(\"proc_macro\")),\n+            format: MacroAttribute(Symbol::intern(\"proc_macro\")),\n             span: None,\n             allow_internal_unstable: true,\n         }\n     });\n     let span = Span { expn_id: eid, ..DUMMY_SP };\n \n-    let proc_macro = token::str_to_ident(\"proc_macro\");\n+    let proc_macro = Ident::from_str(\"proc_macro\");\n     let krate = cx.item(span,\n                         proc_macro,\n                         Vec::new(),\n                         ast::ItemKind::ExternCrate(None));\n \n-    let __internal = token::str_to_ident(\"__internal\");\n-    let registry = token::str_to_ident(\"Registry\");\n-    let registrar = token::str_to_ident(\"registrar\");\n-    let register_custom_derive = token::str_to_ident(\"register_custom_derive\");\n+    let __internal = Ident::from_str(\"__internal\");\n+    let registry = Ident::from_str(\"Registry\");\n+    let registrar = Ident::from_str(\"registrar\");\n+    let register_custom_derive = Ident::from_str(\"register_custom_derive\");\n     let stmts = custom_derives.iter().map(|cd| {\n         let path = cx.path_global(cd.span, vec![cd.function_name]);\n-        let trait_name = cx.expr_str(cd.span, cd.trait_name.clone());\n+        let trait_name = cx.expr_str(cd.span, cd.trait_name);\n         let attrs = cx.expr_vec_slice(\n             span,\n-            cd.attrs.iter().map(|s| cx.expr_str(cd.span, s.clone())).collect::<Vec<_>>()\n+            cd.attrs.iter().map(|&s| cx.expr_str(cd.span, s)).collect::<Vec<_>>()\n         );\n         (path, trait_name, attrs)\n     }).map(|(path, trait_name, attrs)| {\n@@ -316,15 +316,14 @@ fn mk_registrar(cx: &mut ExtCtxt,\n                           cx.ty(span, ast::TyKind::Tup(Vec::new())),\n                           cx.block(span, stmts));\n \n-    let derive_registrar = token::intern_and_get_ident(\"rustc_derive_registrar\");\n-    let derive_registrar = cx.meta_word(span, derive_registrar);\n+    let derive_registrar = cx.meta_word(span, Symbol::intern(\"rustc_derive_registrar\"));\n     let derive_registrar = cx.attribute(span, derive_registrar);\n     let func = func.map(|mut i| {\n         i.attrs.push(derive_registrar);\n         i.vis = ast::Visibility::Public;\n         i\n     });\n-    let ident = ast::Ident::with_empty_ctxt(token::gensym(\"registrar\"));\n+    let ident = ast::Ident::with_empty_ctxt(Symbol::gensym(\"registrar\"));\n     let module = cx.item_mod(span, span, ident, Vec::new(), vec![krate, func]).map(|mut i| {\n         i.vis = ast::Visibility::Public;\n         i"}, {"sha": "48be8e0c53c2ed2c41363da6e7c843efb8053135", "filename": "src/libsyntax_ext/trace_macros.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibsyntax_ext%2Ftrace_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Flibsyntax_ext%2Ftrace_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Ftrace_macros.rs?ref=ebec55406ba94faf8b2cd23b27a8f74df97d1ca4", "patch": "@@ -11,7 +11,7 @@\n use syntax::ext::base::ExtCtxt;\n use syntax::ext::base;\n use syntax::feature_gate;\n-use syntax::parse::token::keywords;\n+use syntax::symbol::keywords;\n use syntax_pos::Span;\n use syntax::tokenstream::TokenTree;\n "}, {"sha": "8647797270f9a841f5092b974faf0ec745509cbb", "filename": "src/test/compile-fail-fulldeps/auxiliary/lint_plugin_test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Ftest%2Fcompile-fail-fulldeps%2Fauxiliary%2Flint_plugin_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Ftest%2Fcompile-fail-fulldeps%2Fauxiliary%2Flint_plugin_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fauxiliary%2Flint_plugin_test.rs?ref=ebec55406ba94faf8b2cd23b27a8f74df97d1ca4", "patch": "@@ -36,7 +36,7 @@ impl LintPass for Pass {\n \n impl EarlyLintPass for Pass {\n     fn check_item(&mut self, cx: &EarlyContext, it: &ast::Item) {\n-        if it.ident.name.as_str() == \"lintme\" {\n+        if it.ident.name == \"lintme\" {\n             cx.span_lint(TEST_LINT, it.span, \"item is named 'lintme'\");\n         }\n     }"}, {"sha": "dc88bfc40595f4401da5db5c86f16c2eede12ccd", "filename": "src/test/compile-fail-fulldeps/auxiliary/macro_crate_test.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Ftest%2Fcompile-fail-fulldeps%2Fauxiliary%2Fmacro_crate_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Ftest%2Fcompile-fail-fulldeps%2Fauxiliary%2Fmacro_crate_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fauxiliary%2Fmacro_crate_test.rs?ref=ebec55406ba94faf8b2cd23b27a8f74df97d1ca4", "patch": "@@ -19,8 +19,9 @@ extern crate rustc_plugin;\n \n use syntax::ast::{self, Item, MetaItem, ItemKind};\n use syntax::ext::base::*;\n-use syntax::parse::{self, token};\n+use syntax::parse;\n use syntax::ptr::P;\n+use syntax::symbol::Symbol;\n use syntax::tokenstream::TokenTree;\n use syntax_pos::Span;\n use rustc_plugin::Registry;\n@@ -34,11 +35,11 @@ pub fn plugin_registrar(reg: &mut Registry) {\n     reg.register_macro(\"make_a_1\", expand_make_a_1);\n     reg.register_macro(\"identity\", expand_identity);\n     reg.register_syntax_extension(\n-        token::intern(\"into_multi_foo\"),\n+        Symbol::intern(\"into_multi_foo\"),\n         // FIXME (#22405): Replace `Box::new` with `box` here when/if possible.\n         MultiModifier(Box::new(expand_into_foo_multi)));\n     reg.register_syntax_extension(\n-        token::intern(\"duplicate\"),\n+        Symbol::intern(\"duplicate\"),\n         // FIXME (#22405): Replace `Box::new` with `box` here when/if possible.\n         MultiDecorator(Box::new(expand_duplicate)));\n }\n@@ -102,9 +103,9 @@ fn expand_duplicate(cx: &mut ExtCtxt,\n                     push: &mut FnMut(Annotatable))\n {\n     let copy_name = match mi.node {\n-        ast::MetaItemKind::List(_, ref xs) => {\n+        ast::MetaItemKind::List(ref xs) => {\n             if let Some(word) = xs[0].word() {\n-                token::str_to_ident(&word.name())\n+                ast::Ident::with_empty_ctxt(word.name())\n             } else {\n                 cx.span_err(mi.span, \"Expected word\");\n                 return;"}, {"sha": "8acab3369e48fb3ef3ba71b3c45160eaf2750970", "filename": "src/test/compile-fail-fulldeps/qquote.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Ftest%2Fcompile-fail-fulldeps%2Fqquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Ftest%2Fcompile-fail-fulldeps%2Fqquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fqquote.rs?ref=ebec55406ba94faf8b2cd23b27a8f74df97d1ca4", "patch": "@@ -16,8 +16,8 @@ extern crate syntax;\n extern crate syntax_pos;\n \n use syntax::ast;\n-use syntax::parse;\n use syntax::print::pprust;\n+use syntax::symbol::Symbol;\n use syntax_pos::DUMMY_SP;\n \n fn main() {\n@@ -30,7 +30,7 @@ fn main() {\n     cx.bt_push(syntax::codemap::ExpnInfo {\n         call_site: DUMMY_SP,\n         callee: syntax::codemap::NameAndSpan {\n-            format: syntax::codemap::MacroBang(parse::token::intern(\"\")),\n+            format: syntax::codemap::MacroBang(Symbol::intern(\"\")),\n             allow_internal_unstable: false,\n             span: None,\n         }"}, {"sha": "092adbf29e340cd52394c00e169fdb4dd746544f", "filename": "src/test/parse-fail/attr-bad-meta.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Ftest%2Fparse-fail%2Fattr-bad-meta.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Ftest%2Fparse-fail%2Fattr-bad-meta.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fattr-bad-meta.rs?ref=ebec55406ba94faf8b2cd23b27a8f74df97d1ca4", "patch": "@@ -10,7 +10,7 @@\n \n // compile-flags: -Z parse-only\n \n-// error-pattern:expected `]`\n+// error-pattern:expected one of `=` or `]`\n \n // asterisk is bogus\n #[attr*]"}, {"sha": "d692bb519c149ec33c24269302f268505e24f507", "filename": "src/test/run-fail-fulldeps/qquote.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Ftest%2Frun-fail-fulldeps%2Fqquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Ftest%2Frun-fail-fulldeps%2Fqquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail-fulldeps%2Fqquote.rs?ref=ebec55406ba94faf8b2cd23b27a8f74df97d1ca4", "patch": "@@ -19,8 +19,8 @@ extern crate syntax_pos;\n \n use syntax::ast;\n use syntax::codemap;\n-use syntax::parse;\n use syntax::print::pprust;\n+use syntax::symbol::Symbol;\n use syntax_pos::DUMMY_SP;\n \n fn main() {\n@@ -33,7 +33,7 @@ fn main() {\n     cx.bt_push(syntax::codemap::ExpnInfo {\n         call_site: DUMMY_SP,\n         callee: syntax::codemap::NameAndSpan {\n-            format: syntax::codemap::MacroBang(parse::token::intern(\"\")),\n+            format: syntax::codemap::MacroBang(Symbol::intern(\"\")),\n             allow_internal_unstable: false,\n             span: None,\n         }"}, {"sha": "0336fe277c51f8eb6f064d6e248d1f0d00e26653", "filename": "src/test/run-make/issue-19371/foo.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Ftest%2Frun-make%2Fissue-19371%2Ffoo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Ftest%2Frun-make%2Fissue-19371%2Ffoo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fissue-19371%2Ffoo.rs?ref=ebec55406ba94faf8b2cd23b27a8f74df97d1ca4", "patch": "@@ -25,6 +25,7 @@ use rustc_driver::driver::{compile_input, CompileController, anon_src};\n use rustc_metadata::cstore::CStore;\n use rustc_errors::registry::Registry;\n \n+use std::collections::HashSet;\n use std::path::PathBuf;\n use std::rc::Rc;\n \n@@ -65,7 +66,7 @@ fn basic_sess(sysroot: PathBuf) -> (Session, Rc<CStore>) {\n \n fn compile(code: String, output: PathBuf, sysroot: PathBuf) {\n     let (sess, cstore) = basic_sess(sysroot);\n-    let cfg = build_configuration(&sess, vec![]);\n+    let cfg = build_configuration(&sess, HashSet::new());\n     let control = CompileController::basic();\n     let input = Input::Str { name: anon_src(), input: code };\n     compile_input(&sess, &cstore, &input, &None, &Some(output), None, &control);"}, {"sha": "664bb9da89a5765fa19fb4dd4a94f3f5930dcd06", "filename": "src/test/run-pass-fulldeps/auxiliary/cond_noprelude_plugin.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fcond_noprelude_plugin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fcond_noprelude_plugin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fcond_noprelude_plugin.rs?ref=ebec55406ba94faf8b2cd23b27a8f74df97d1ca4", "patch": "@@ -20,10 +20,10 @@ extern crate syntax;\n \n use proc_macro_tokens::build::ident_eq;\n \n+use syntax::ast::Ident;\n use syntax::ext::base::{ExtCtxt, MacResult};\n use syntax::ext::proc_macro_shim::build_block_emitter;\n use syntax::tokenstream::{TokenTree, TokenStream};\n-use syntax::parse::token::str_to_ident;\n use syntax::codemap::Span;\n \n use rustc_plugin::Registry;\n@@ -57,7 +57,7 @@ fn cond_rec(input: TokenStream) -> TokenStream {\n   let test: TokenStream = clause.slice(0..1);\n   let rhs: TokenStream = clause.slice_from(1..);\n \n-  if ident_eq(&test[0], str_to_ident(\"else\")) || rest.is_empty() {\n+  if ident_eq(&test[0], Ident::from_str(\"else\")) || rest.is_empty() {\n     qquote!({unquote(rhs)})\n   } else {\n     qquote!({if unquote(test) { unquote(rhs) } else { cond!(unquote(rest)) } })"}, {"sha": "31a5f5968bab6addf652bb73bf1a9fb834826497", "filename": "src/test/run-pass-fulldeps/auxiliary/cond_plugin.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fcond_plugin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fcond_plugin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fcond_plugin.rs?ref=ebec55406ba94faf8b2cd23b27a8f74df97d1ca4", "patch": "@@ -26,7 +26,7 @@ use syntax::ast::Ident;\n use syntax::codemap::{DUMMY_SP, Span};\n use syntax::ext::proc_macro_shim::build_block_emitter;\n use syntax::ext::base::{ExtCtxt, MacResult};\n-use syntax::parse::token::{self, Token, DelimToken, keywords, str_to_ident};\n+use syntax::parse::token::{self, Token, DelimToken};\n use syntax::tokenstream::{TokenTree, TokenStream};\n \n #[plugin_registrar]\n@@ -58,7 +58,7 @@ fn cond_rec(input: TokenStream) -> TokenStream {\n   let test: TokenStream = clause.slice(0..1);\n   let rhs: TokenStream = clause.slice_from(1..);\n \n-  if ident_eq(&test[0], str_to_ident(\"else\")) || rest.is_empty() {\n+  if ident_eq(&test[0], Ident::from_str(\"else\")) || rest.is_empty() {\n     qquote!({unquote(rhs)})\n   } else {\n     qquote!({if unquote(test) { unquote(rhs) } else { cond!(unquote(rest)) } })"}, {"sha": "6a2d159a4bdd96e774025f72df238e7ddac836ae", "filename": "src/test/run-pass-fulldeps/auxiliary/cond_prelude_plugin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fcond_prelude_plugin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fcond_prelude_plugin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fcond_prelude_plugin.rs?ref=ebec55406ba94faf8b2cd23b27a8f74df97d1ca4", "patch": "@@ -52,7 +52,7 @@ fn cond_rec(input: TokenStream) -> TokenStream {\n   let test: TokenStream = clause.slice(0..1);\n   let rhs: TokenStream = clause.slice_from(1..);\n \n-  if ident_eq(&test[0], str_to_ident(\"else\")) || rest.is_empty() {\n+  if ident_eq(&test[0], Ident::from_str(\"else\")) || rest.is_empty() {\n     qquote!({unquote(rhs)})\n   } else {\n     qquote!({if unquote(test) { unquote(rhs) } else { cond!(unquote(rest)) } })"}, {"sha": "63dbd4d5bed047a7ffe0039210a0e49c5ffe2f1d", "filename": "src/test/run-pass-fulldeps/auxiliary/custom_derive_partial_eq.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fcustom_derive_partial_eq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fcustom_derive_partial_eq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fcustom_derive_partial_eq.rs?ref=ebec55406ba94faf8b2cd23b27a8f74df97d1ca4", "patch": "@@ -25,12 +25,12 @@ use syntax::ast::*;\n use syntax::codemap::Span;\n use syntax::ext::base::*;\n use syntax::ext::build::AstBuilder;\n-use syntax::parse::token::{intern, InternedString};\n+use syntax::symbol::Symbol;\n use syntax::ptr::P;\n \n #[plugin_registrar]\n pub fn plugin_registrar(reg: &mut Registry) {\n-    reg.register_syntax_extension(intern(\"derive_CustomPartialEq\"),\n+    reg.register_syntax_extension(Symbol::intern(\"derive_CustomPartialEq\"),\n                                   MultiDecorator(Box::new(expand_deriving_partial_eq)));\n }\n \n@@ -52,7 +52,7 @@ fn expand_deriving_partial_eq(cx: &mut ExtCtxt, span: Span, mitem: &MetaItem, it\n                 substr)\n     }\n \n-    let inline = cx.meta_word(span, InternedString::new(\"inline\"));\n+    let inline = cx.meta_word(span, Symbol::intern(\"inline\"));\n     let attrs = vec![cx.attribute(span, inline)];\n     let methods = vec![MethodDef {\n         name: \"eq\","}, {"sha": "07f7d6bad7bf2b40967b8830f4bdc380dafcd0cc", "filename": "src/test/run-pass-fulldeps/auxiliary/custom_derive_plugin.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fcustom_derive_plugin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fcustom_derive_plugin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fcustom_derive_plugin.rs?ref=ebec55406ba94faf8b2cd23b27a8f74df97d1ca4", "patch": "@@ -23,7 +23,7 @@ extern crate rustc_plugin;\n use syntax::ast;\n use syntax::ext::base::{MultiDecorator, ExtCtxt, Annotatable};\n use syntax::ext::build::AstBuilder;\n-use syntax::parse::token;\n+use syntax::symbol::Symbol;\n use syntax_ext::deriving::generic::{cs_fold, TraitDef, MethodDef, combine_substructure};\n use syntax_ext::deriving::generic::ty::{Literal, LifetimeBounds, Path, borrowed_explicit_self};\n use syntax_pos::Span;\n@@ -32,7 +32,7 @@ use rustc_plugin::Registry;\n #[plugin_registrar]\n pub fn plugin_registrar(reg: &mut Registry) {\n     reg.register_syntax_extension(\n-        token::intern(\"derive_TotalSum\"),\n+        Symbol::intern(\"derive_TotalSum\"),\n         MultiDecorator(box expand));\n }\n \n@@ -66,7 +66,7 @@ fn expand(cx: &mut ExtCtxt,\n                             |cx, span, subexpr, field, _| {\n                                 cx.expr_binary(span, ast::BinOpKind::Add, subexpr,\n                                     cx.expr_method_call(span, field,\n-                                        token::str_to_ident(\"total_sum\"), vec![]))\n+                                        ast::Ident::from_str(\"total_sum\"), vec![]))\n                             },\n                             zero,\n                             box |cx, span, _, _| { cx.span_bug(span, \"wtf??\"); },"}, {"sha": "50b16a0e26fb49b79a951e0b8d019a73e5012aa9", "filename": "src/test/run-pass-fulldeps/auxiliary/custom_derive_plugin_attr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fcustom_derive_plugin_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fcustom_derive_plugin_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fcustom_derive_plugin_attr.rs?ref=ebec55406ba94faf8b2cd23b27a8f74df97d1ca4", "patch": "@@ -23,7 +23,7 @@ extern crate rustc_plugin;\n use syntax::ast;\n use syntax::ext::base::{MultiDecorator, ExtCtxt, Annotatable};\n use syntax::ext::build::AstBuilder;\n-use syntax::parse::token;\n+use syntax::symbol::Symbol;\n use syntax::ptr::P;\n use syntax_ext::deriving::generic::{TraitDef, MethodDef, combine_substructure};\n use syntax_ext::deriving::generic::{Substructure, Struct, EnumMatching};\n@@ -34,7 +34,7 @@ use rustc_plugin::Registry;\n #[plugin_registrar]\n pub fn plugin_registrar(reg: &mut Registry) {\n     reg.register_syntax_extension(\n-        token::intern(\"derive_TotalSum\"),\n+        Symbol::intern(\"derive_TotalSum\"),\n         MultiDecorator(box expand));\n }\n "}, {"sha": "8647797270f9a841f5092b974faf0ec745509cbb", "filename": "src/test/run-pass-fulldeps/auxiliary/lint_plugin_test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Flint_plugin_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Flint_plugin_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Flint_plugin_test.rs?ref=ebec55406ba94faf8b2cd23b27a8f74df97d1ca4", "patch": "@@ -36,7 +36,7 @@ impl LintPass for Pass {\n \n impl EarlyLintPass for Pass {\n     fn check_item(&mut self, cx: &EarlyContext, it: &ast::Item) {\n-        if it.ident.name.as_str() == \"lintme\" {\n+        if it.ident.name == \"lintme\" {\n             cx.span_lint(TEST_LINT, it.span, \"item is named 'lintme'\");\n         }\n     }"}, {"sha": "29cc6b7db94741c4b44b1f0b5e66a65cea1a5b0a", "filename": "src/test/run-pass-fulldeps/auxiliary/macro_crate_test.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fmacro_crate_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fmacro_crate_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fmacro_crate_test.rs?ref=ebec55406ba94faf8b2cd23b27a8f74df97d1ca4", "patch": "@@ -23,6 +23,7 @@ use syntax::ext::base::*;\n use syntax::ext::quote::rt::ToTokens;\n use syntax::parse::{self, token};\n use syntax::ptr::P;\n+use syntax::symbol::Symbol;\n use syntax::tokenstream::TokenTree;\n use syntax_pos::Span;\n use rustc_plugin::Registry;\n@@ -36,15 +37,15 @@ pub fn plugin_registrar(reg: &mut Registry) {\n     reg.register_macro(\"make_a_1\", expand_make_a_1);\n     reg.register_macro(\"identity\", expand_identity);\n     reg.register_syntax_extension(\n-        token::intern(\"into_multi_foo\"),\n+        Symbol::intern(\"into_multi_foo\"),\n         // FIXME (#22405): Replace `Box::new` with `box` here when/if possible.\n         MultiModifier(Box::new(expand_into_foo_multi)));\n     reg.register_syntax_extension(\n-        token::intern(\"duplicate\"),\n+        Symbol::intern(\"duplicate\"),\n         // FIXME (#22405): Replace `Box::new` with `box` here when/if possible.\n         MultiDecorator(Box::new(expand_duplicate)));\n     reg.register_syntax_extension(\n-        token::intern(\"caller\"),\n+        Symbol::intern(\"caller\"),\n         // FIXME (#22405): Replace `Box::new` with `box` here when/if possible.\n         MultiDecorator(Box::new(expand_caller)));\n }\n@@ -108,9 +109,9 @@ fn expand_duplicate(cx: &mut ExtCtxt,\n                     it: &Annotatable,\n                     push: &mut FnMut(Annotatable)) {\n     let copy_name = match mi.node {\n-        ast::MetaItemKind::List(_, ref xs) => {\n+        ast::MetaItemKind::List(ref xs) => {\n             if let Some(word) = xs[0].word() {\n-                token::str_to_ident(&word.name())\n+                ast::Ident::with_empty_ctxt(word.name())\n             } else {\n                 cx.span_err(mi.span, \"Expected word\");\n                 return;\n@@ -179,7 +180,7 @@ fn expand_caller(cx: &mut ExtCtxt,\n         }\n \n         let fn_name = match list[0].name() {\n-            Some(name) => token::str_to_ident(&name),\n+            Some(name) => ast::Ident::with_empty_ctxt(name),\n             None => cx.span_fatal(list[0].span(), \"First parameter must be an ident.\")\n         };\n "}, {"sha": "ba2af77cdb297f75c2cbc2e6e66c6ee08c4031d3", "filename": "src/test/run-pass-fulldeps/auxiliary/plugin_args.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fplugin_args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fplugin_args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fplugin_args.rs?ref=ebec55406ba94faf8b2cd23b27a8f74df97d1ca4", "patch": "@@ -22,9 +22,9 @@ use std::borrow::ToOwned;\n use syntax::ast;\n use syntax::ext::build::AstBuilder;\n use syntax::ext::base::{TTMacroExpander, ExtCtxt, MacResult, MacEager, NormalTT};\n-use syntax::parse::token;\n use syntax::print::pprust;\n use syntax::ptr::P;\n+use syntax::symbol::Symbol;\n use syntax_pos::Span;\n use syntax::tokenstream;\n use rustc_plugin::Registry;\n@@ -40,15 +40,14 @@ impl TTMacroExpander for Expander {\n                    _: &[tokenstream::TokenTree]) -> Box<MacResult+'cx> {\n         let args = self.args.iter().map(|i| pprust::meta_list_item_to_string(i))\n             .collect::<Vec<_>>().join(\", \");\n-        let interned = token::intern_and_get_ident(&args[..]);\n-        MacEager::expr(ecx.expr_str(sp, interned))\n+        MacEager::expr(ecx.expr_str(sp, Symbol::intern(&args)))\n     }\n }\n \n #[plugin_registrar]\n pub fn plugin_registrar(reg: &mut Registry) {\n     let args = reg.args().to_owned();\n-    reg.register_syntax_extension(token::intern(\"plugin_args\"),\n+    reg.register_syntax_extension(Symbol::intern(\"plugin_args\"),\n         // FIXME (#22405): Replace `Box::new` with `box` here when/if possible.\n         NormalTT(Box::new(Expander { args: args, }), None, false));\n }"}, {"sha": "f97fb04aadf6ab2149c47be89aaaa677d9e54f0a", "filename": "src/test/run-pass-fulldeps/auxiliary/proc_macro_def.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fproc_macro_def.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fproc_macro_def.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fproc_macro_def.rs?ref=ebec55406ba94faf8b2cd23b27a8f74df97d1ca4", "patch": "@@ -18,18 +18,19 @@ use proc_macro_tokens::prelude::*;\n use rustc_plugin::Registry;\n use syntax::ext::base::SyntaxExtension;\n use syntax::ext::proc_macro_shim::prelude::*;\n+use syntax::symbol::Symbol;\n \n #[plugin_registrar]\n pub fn plugin_registrar(reg: &mut Registry) {\n-    reg.register_syntax_extension(token::intern(\"attr_tru\"),\n+    reg.register_syntax_extension(Symbol::intern(\"attr_tru\"),\n                                   SyntaxExtension::AttrProcMacro(Box::new(attr_tru)));\n-    reg.register_syntax_extension(token::intern(\"attr_identity\"),\n+    reg.register_syntax_extension(Symbol::intern(\"attr_identity\"),\n                                   SyntaxExtension::AttrProcMacro(Box::new(attr_identity)));\n-    reg.register_syntax_extension(token::intern(\"tru\"),\n+    reg.register_syntax_extension(Symbol::intern(\"tru\"),\n                                   SyntaxExtension::ProcMacro(Box::new(tru)));\n-    reg.register_syntax_extension(token::intern(\"ret_tru\"),\n+    reg.register_syntax_extension(Symbol::intern(\"ret_tru\"),\n                                   SyntaxExtension::ProcMacro(Box::new(ret_tru)));\n-    reg.register_syntax_extension(token::intern(\"identity\"),\n+    reg.register_syntax_extension(Symbol::intern(\"identity\"),\n                                   SyntaxExtension::ProcMacro(Box::new(identity)));\n }\n "}, {"sha": "2b3857048f36732acc33f5c524aa8cd6f7fa978c", "filename": "src/test/run-pass-fulldeps/auxiliary/procedural_mbe_matching.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fprocedural_mbe_matching.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fprocedural_mbe_matching.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fprocedural_mbe_matching.rs?ref=ebec55406ba94faf8b2cd23b27a8f74df97d1ca4", "patch": "@@ -18,8 +18,8 @@ extern crate syntax_pos;\n extern crate rustc;\n extern crate rustc_plugin;\n \n-use syntax::parse::token::{str_to_ident, NtExpr, NtPat};\n-use syntax::ast::{Pat};\n+use syntax::parse::token::{NtExpr, NtPat};\n+use syntax::ast::{Ident, Pat};\n use syntax::tokenstream::{TokenTree};\n use syntax::ext::base::{ExtCtxt, MacResult, MacEager};\n use syntax::ext::build::AstBuilder;\n@@ -44,12 +44,12 @@ fn expand_mbe_matches(cx: &mut ExtCtxt, _: Span, args: &[TokenTree])\n         }\n     };\n \n-    let matched_nt = match *map[&str_to_ident(\"matched\")] {\n+    let matched_nt = match *map[&Ident::from_str(\"matched\")] {\n         MatchedNonterminal(ref nt) => nt.clone(),\n         _ => unreachable!(),\n     };\n \n-    let mac_expr = match (&*matched_nt, &*map[&str_to_ident(\"pat\")]) {\n+    let mac_expr = match (&*matched_nt, &*map[&Ident::from_str(\"pat\")]) {\n         (&NtExpr(ref matched_expr), &MatchedSeq(ref pats, seq_sp)) => {\n             let pats: Vec<P<Pat>> = pats.iter().map(|pat_nt| {\n                 match **pat_nt {"}, {"sha": "948b20c14771fa48aaf5c60d9e09366daaf75263", "filename": "src/test/run-pass-fulldeps/macro-quote-1.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Ftest%2Frun-pass-fulldeps%2Fmacro-quote-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Ftest%2Frun-pass-fulldeps%2Fmacro-quote-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fmacro-quote-1.rs?ref=ebec55406ba94faf8b2cd23b27a8f74df97d1ca4", "patch": "@@ -18,9 +18,6 @@ extern crate proc_macro_tokens;\n use proc_macro_tokens::prelude::*;\n \n extern crate syntax;\n-use syntax::ast::Ident;\n-use syntax::codemap::DUMMY_SP;\n-use syntax::parse::token::{self, Token, keywords, str_to_ident};\n \n fn main() {\n     let lex_true = lex(\"true\");"}, {"sha": "b4ed57192ccf69647015b18639b858c7d7d574df", "filename": "src/test/run-pass-fulldeps/qquote.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Ftest%2Frun-pass-fulldeps%2Fqquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebec55406ba94faf8b2cd23b27a8f74df97d1ca4/src%2Ftest%2Frun-pass-fulldeps%2Fqquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fqquote.rs?ref=ebec55406ba94faf8b2cd23b27a8f74df97d1ca4", "patch": "@@ -16,7 +16,7 @@ extern crate syntax;\n extern crate syntax_pos;\n \n use syntax::print::pprust::*;\n-use syntax::parse::token::intern;\n+use syntax::symbol::Symbol;\n use syntax_pos::DUMMY_SP;\n \n fn main() {\n@@ -29,7 +29,7 @@ fn main() {\n     cx.bt_push(syntax::codemap::ExpnInfo {\n         call_site: DUMMY_SP,\n         callee: syntax::codemap::NameAndSpan {\n-            format: syntax::codemap::MacroBang(intern(\"\")),\n+            format: syntax::codemap::MacroBang(Symbol::intern(\"\")),\n             allow_internal_unstable: false,\n             span: None,\n         }\n@@ -97,7 +97,7 @@ fn main() {\n     // quote_meta_item!\n \n     let meta = quote_meta_item!(cx, cfg(foo = \"bar\"));\n-    check!(meta_item_to_string, meta, *quote_meta_item!(cx, $meta); r#\"cfg(foo = \"bar\")\"#);\n+    check!(meta_item_to_string, meta, quote_meta_item!(cx, $meta); r#\"cfg(foo = \"bar\")\"#);\n \n     let attr = quote_attr!(cx, #![$meta]);\n     check!(attribute_to_string, attr; r#\"#![cfg(foo = \"bar\")]\"#);"}]}