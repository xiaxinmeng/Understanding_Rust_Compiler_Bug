{"sha": "736348ac41b00657bd8d5d6b8acae1eeef9985c7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjczNjM0OGFjNDFiMDA2NTdiZDhkNWQ2YjhhY2FlMWVlZWY5OTg1Yzc=", "commit": {"author": {"name": "mark", "email": "markm@cs.wisc.edu", "date": "2019-12-21T05:59:31Z"}, "committer": {"name": "mark", "email": "markm@cs.wisc.edu", "date": "2020-01-13T01:38:43Z"}, "message": "Move a bunch of methods to inherent impl MirBorrowckCtxt", "tree": {"sha": "96d6ec820c0299bf84d413bac49569f79e5ca7f2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/96d6ec820c0299bf84d413bac49569f79e5ca7f2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/736348ac41b00657bd8d5d6b8acae1eeef9985c7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/736348ac41b00657bd8d5d6b8acae1eeef9985c7", "html_url": "https://github.com/rust-lang/rust/commit/736348ac41b00657bd8d5d6b8acae1eeef9985c7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/736348ac41b00657bd8d5d6b8acae1eeef9985c7/comments", "author": {"login": "mark-i-m", "id": 8827840, "node_id": "MDQ6VXNlcjg4Mjc4NDA=", "avatar_url": "https://avatars.githubusercontent.com/u/8827840?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mark-i-m", "html_url": "https://github.com/mark-i-m", "followers_url": "https://api.github.com/users/mark-i-m/followers", "following_url": "https://api.github.com/users/mark-i-m/following{/other_user}", "gists_url": "https://api.github.com/users/mark-i-m/gists{/gist_id}", "starred_url": "https://api.github.com/users/mark-i-m/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mark-i-m/subscriptions", "organizations_url": "https://api.github.com/users/mark-i-m/orgs", "repos_url": "https://api.github.com/users/mark-i-m/repos", "events_url": "https://api.github.com/users/mark-i-m/events{/privacy}", "received_events_url": "https://api.github.com/users/mark-i-m/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mark-i-m", "id": 8827840, "node_id": "MDQ6VXNlcjg4Mjc4NDA=", "avatar_url": "https://avatars.githubusercontent.com/u/8827840?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mark-i-m", "html_url": "https://github.com/mark-i-m", "followers_url": "https://api.github.com/users/mark-i-m/followers", "following_url": "https://api.github.com/users/mark-i-m/following{/other_user}", "gists_url": "https://api.github.com/users/mark-i-m/gists{/gist_id}", "starred_url": "https://api.github.com/users/mark-i-m/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mark-i-m/subscriptions", "organizations_url": "https://api.github.com/users/mark-i-m/orgs", "repos_url": "https://api.github.com/users/mark-i-m/repos", "events_url": "https://api.github.com/users/mark-i-m/events{/privacy}", "received_events_url": "https://api.github.com/users/mark-i-m/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c3e74f347e44e3a54f6ff094ef8b741589d69ab5", "url": "https://api.github.com/repos/rust-lang/rust/commits/c3e74f347e44e3a54f6ff094ef8b741589d69ab5", "html_url": "https://github.com/rust-lang/rust/commit/c3e74f347e44e3a54f6ff094ef8b741589d69ab5"}], "stats": {"total": 275, "additions": 130, "deletions": 145}, "files": [{"sha": "45c6c845cd156a3b6e8f3c3f6761b7eb59411377", "filename": "src/librustc_mir/borrow_check/diagnostics/explain_borrow.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/736348ac41b00657bd8d5d6b8acae1eeef9985c7/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fexplain_borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/736348ac41b00657bd8d5d6b8acae1eeef9985c7/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fexplain_borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fexplain_borrow.rs?ref=736348ac41b00657bd8d5d6b8acae1eeef9985c7", "patch": "@@ -274,9 +274,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         );\n \n         let mut renctx = RegionErrorNamingCtx::new();\n-        let outlived_fr_name =\n-            self.nonlexical_regioncx.give_region_a_name(self, &mut renctx, outlived_region);\n-        // TODO(mark-i-m): just return the region and let the caller name it\n+        let outlived_fr_name = self.give_region_a_name(&mut renctx, outlived_region);\n \n         (category, from_closure, span, outlived_fr_name)\n     }\n@@ -357,7 +355,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             }\n \n             None => {\n-                if let Some(region) = regioncx.to_error_region_vid(borrow_region_vid) {\n+                if let Some(region) = self.to_error_region_vid(borrow_region_vid) {\n                     let (category, from_closure, span, region_name) =\n                         self.free_region_constraint_info(borrow_region_vid, region);\n                     if let Some(region_name) = region_name {"}, {"sha": "be067fcf4f2615b187a6a8e68a3ba31080c03076", "filename": "src/librustc_mir/borrow_check/diagnostics/outlives_suggestion.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/736348ac41b00657bd8d5d6b8acae1eeef9985c7/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Foutlives_suggestion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/736348ac41b00657bd8d5d6b8acae1eeef9985c7/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Foutlives_suggestion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Foutlives_suggestion.rs?ref=736348ac41b00657bd8d5d6b8acae1eeef9985c7", "patch": "@@ -80,9 +80,7 @@ impl OutlivesSuggestionBuilder {\n         renctx: &mut RegionErrorNamingCtx,\n         region: RegionVid,\n     ) -> Option<RegionName> {\n-        mbcx.nonlexical_regioncx\n-            .give_region_a_name(mbcx, renctx, region)\n-            .filter(Self::region_name_is_suggestable)\n+        mbcx.give_region_a_name(renctx, region).filter(Self::region_name_is_suggestable)\n     }\n \n     /// Compiles a list of all suggestions to be printed in the final big suggestion."}, {"sha": "b0be82164d876af0270fb62e72abf4d528ce53cd", "filename": "src/librustc_mir/borrow_check/diagnostics/region_errors.rs", "status": "modified", "additions": 73, "deletions": 71, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/736348ac41b00657bd8d5d6b8acae1eeef9985c7/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fregion_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/736348ac41b00657bd8d5d6b8acae1eeef9985c7/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fregion_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fregion_errors.rs?ref=736348ac41b00657bd8d5d6b8acae1eeef9985c7", "patch": "@@ -1,8 +1,6 @@\n //! Error reporting machinery for lifetime errors.\n \n-use rustc::infer::{\n-    error_reporting::nice_region_error::NiceRegionError, InferCtxt, NLLRegionVariableOrigin,\n-};\n+use rustc::infer::{error_reporting::nice_region_error::NiceRegionError, NLLRegionVariableOrigin};\n use rustc::mir::ConstraintCategory;\n use rustc::ty::{self, RegionVid, Ty};\n use rustc_errors::{Applicability, DiagnosticBuilder};\n@@ -14,7 +12,7 @@ use crate::util::borrowck_errors;\n \n use crate::borrow_check::{\n     nll::ConstraintDescription,\n-    region_infer::{values::RegionElement, RegionInferenceContext, TypeTest},\n+    region_infer::{values::RegionElement, TypeTest},\n     universal_regions::DefiningTy,\n     MirBorrowckCtxt,\n };\n@@ -104,26 +102,28 @@ pub struct ErrorConstraintInfo {\n     pub(super) span: Span,\n }\n \n-impl<'tcx> RegionInferenceContext<'tcx> {\n+impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n     /// Converts a region inference variable into a `ty::Region` that\n     /// we can use for error reporting. If `r` is universally bound,\n     /// then we use the name that we have on record for it. If `r` is\n     /// existentially bound, then we check its inferred value and try\n     /// to find a good name from that. Returns `None` if we can't find\n     /// one (e.g., this is just some random part of the CFG).\n-    pub fn to_error_region(&self, r: RegionVid) -> Option<ty::Region<'tcx>> {\n-        self.to_error_region_vid(r).and_then(|r| self.definitions[r].external_name)\n+    // TODO(mark-i-m): make this private when we move report_region_errors here...\n+    crate fn to_error_region(&self, r: RegionVid) -> Option<ty::Region<'tcx>> {\n+        self.to_error_region_vid(r)\n+            .and_then(|r| self.nonlexical_regioncx.definitions[r].external_name)\n     }\n \n-    /// Returns the [RegionVid] corresponding to the region returned by\n+    /// Returns the `RegionVid` corresponding to the region returned by\n     /// `to_error_region`.\n-    pub fn to_error_region_vid(&self, r: RegionVid) -> Option<RegionVid> {\n-        if self.universal_regions.is_universal_region(r) {\n+    pub(super) fn to_error_region_vid(&self, r: RegionVid) -> Option<RegionVid> {\n+        if self.nonlexical_regioncx.universal_regions.is_universal_region(r) {\n             Some(r)\n         } else {\n-            let r_scc = self.constraint_sccs.scc(r);\n-            let upper_bound = self.universal_upper_bound(r);\n-            if self.scc_values.contains(r_scc, upper_bound) {\n+            let r_scc = self.nonlexical_regioncx.constraint_sccs.scc(r);\n+            let upper_bound = self.nonlexical_regioncx.universal_upper_bound(r);\n+            if self.nonlexical_regioncx.scc_values.contains(r_scc, upper_bound) {\n                 self.to_error_region_vid(upper_bound)\n             } else {\n                 None\n@@ -132,11 +132,13 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     }\n \n     /// Returns `true` if a closure is inferred to be an `FnMut` closure.\n-    crate fn is_closure_fn_mut(&self, infcx: &InferCtxt<'_, 'tcx>, fr: RegionVid) -> bool {\n+    fn is_closure_fn_mut(&self, fr: RegionVid) -> bool {\n         if let Some(ty::ReFree(free_region)) = self.to_error_region(fr) {\n             if let ty::BoundRegion::BrEnv = free_region.bound_region {\n-                if let DefiningTy::Closure(def_id, substs) = self.universal_regions.defining_ty {\n-                    let closure_kind_ty = substs.as_closure().kind_ty(def_id, infcx.tcx);\n+                if let DefiningTy::Closure(def_id, substs) =\n+                    self.nonlexical_regioncx.universal_regions.defining_ty\n+                {\n+                    let closure_kind_ty = substs.as_closure().kind_ty(def_id, self.infcx.tcx);\n                     return Some(ty::ClosureKind::FnMut) == closure_kind_ty.to_opt_closure_kind();\n                 }\n             }\n@@ -153,34 +155,35 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// ```\n     ///\n     /// Here we would be invoked with `fr = 'a` and `outlived_fr = `'b`.\n-    pub(in crate::borrow_check) fn report_error<'a>(\n-        &'a self,\n-        mbcx: &MirBorrowckCtxt<'a, 'tcx>,\n+    pub(in crate::borrow_check) fn report_error(\n+        &mut self,\n         fr: RegionVid,\n         fr_origin: NLLRegionVariableOrigin,\n         outlived_fr: RegionVid,\n         outlives_suggestion: &mut OutlivesSuggestionBuilder,\n         renctx: &mut RegionErrorNamingCtx,\n-    ) -> DiagnosticBuilder<'a> {\n+    ) {\n         debug!(\"report_error(fr={:?}, outlived_fr={:?})\", fr, outlived_fr);\n \n-        let (category, _, span) = self.best_blame_constraint(&mbcx.body, fr, fr_origin, |r| {\n-            self.provides_universal_region(r, fr, outlived_fr)\n-        });\n+        let (category, _, span) =\n+            self.nonlexical_regioncx.best_blame_constraint(&self.body, fr, fr_origin, |r| {\n+                self.nonlexical_regioncx.provides_universal_region(r, fr, outlived_fr)\n+            });\n \n         debug!(\"report_error: category={:?} {:?}\", category, span);\n         // Check if we can use one of the \"nice region errors\".\n         if let (Some(f), Some(o)) = (self.to_error_region(fr), self.to_error_region(outlived_fr)) {\n-            let tables = mbcx.infcx.tcx.typeck_tables_of(mbcx.mir_def_id);\n-            let nice = NiceRegionError::new_from_span(mbcx.infcx, span, o, f, Some(tables));\n+            let tables = self.infcx.tcx.typeck_tables_of(self.mir_def_id);\n+            let nice = NiceRegionError::new_from_span(self.infcx, span, o, f, Some(tables));\n             if let Some(diag) = nice.try_report_from_nll() {\n-                return diag;\n+                diag.buffer(&mut self.errors_buffer);\n+                return;\n             }\n         }\n \n         let (fr_is_local, outlived_fr_is_local): (bool, bool) = (\n-            self.universal_regions.is_local_free_region(fr),\n-            self.universal_regions.is_local_free_region(outlived_fr),\n+            self.nonlexical_regioncx.universal_regions.is_local_free_region(fr),\n+            self.nonlexical_regioncx.universal_regions.is_local_free_region(outlived_fr),\n         );\n \n         debug!(\n@@ -197,28 +200,30 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             span,\n         };\n \n-        match (category, fr_is_local, outlived_fr_is_local) {\n-            (ConstraintCategory::Return, true, false) if self.is_closure_fn_mut(mbcx.infcx, fr) => {\n-                self.report_fnmut_error(mbcx, &errci, renctx)\n+        let diag = match (category, fr_is_local, outlived_fr_is_local) {\n+            (ConstraintCategory::Return, true, false) if self.is_closure_fn_mut(fr) => {\n+                self.report_fnmut_error(&errci, renctx)\n             }\n             (ConstraintCategory::Assignment, true, false)\n             | (ConstraintCategory::CallArgument, true, false) => {\n-                let mut db = self.report_escaping_data_error(mbcx, &errci, renctx);\n+                let mut db = self.report_escaping_data_error(&errci, renctx);\n \n-                outlives_suggestion.intermediate_suggestion(mbcx, &errci, renctx, &mut db);\n+                outlives_suggestion.intermediate_suggestion(self, &errci, renctx, &mut db);\n                 outlives_suggestion.collect_constraint(fr, outlived_fr);\n \n                 db\n             }\n             _ => {\n-                let mut db = self.report_general_error(mbcx, &errci, renctx);\n+                let mut db = self.report_general_error(&errci, renctx);\n \n-                outlives_suggestion.intermediate_suggestion(mbcx, &errci, renctx, &mut db);\n+                outlives_suggestion.intermediate_suggestion(self, &errci, renctx, &mut db);\n                 outlives_suggestion.collect_constraint(fr, outlived_fr);\n \n                 db\n             }\n-        }\n+        };\n+\n+        diag.buffer(&mut self.errors_buffer);\n     }\n \n     /// Report a specialized error when `FnMut` closures return a reference to a captured variable.\n@@ -239,21 +244,21 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// ```\n     fn report_fnmut_error(\n         &self,\n-        mbcx: &MirBorrowckCtxt<'_, 'tcx>,\n         errci: &ErrorConstraintInfo,\n         renctx: &mut RegionErrorNamingCtx,\n-    ) -> DiagnosticBuilder<'_> {\n+    ) -> DiagnosticBuilder<'tcx> {\n         let ErrorConstraintInfo { outlived_fr, span, .. } = errci;\n \n-        let mut diag = mbcx\n+        let mut diag = self\n             .infcx\n             .tcx\n             .sess\n             .struct_span_err(*span, \"captured variable cannot escape `FnMut` closure body\");\n \n         // We should check if the return type of this closure is in fact a closure - in that\n         // case, we can special case the error further.\n-        let return_type_is_closure = self.universal_regions.unnormalized_output_ty.is_closure();\n+        let return_type_is_closure =\n+            self.nonlexical_regioncx.universal_regions.unnormalized_output_ty.is_closure();\n         let message = if return_type_is_closure {\n             \"returns a closure that contains a reference to a captured variable, which then \\\n              escapes the closure body\"\n@@ -263,7 +268,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n \n         diag.span_label(*span, message);\n \n-        match self.give_region_a_name(mbcx, renctx, *outlived_fr).unwrap().source {\n+        match self.give_region_a_name(renctx, *outlived_fr).unwrap().source {\n             RegionNameSource::NamedEarlyBoundRegion(fr_span)\n             | RegionNameSource::NamedFreeRegion(fr_span)\n             | RegionNameSource::SynthesizedFreeEnvRegion(fr_span, _)\n@@ -300,28 +305,27 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// ```\n     fn report_escaping_data_error(\n         &self,\n-        mbcx: &MirBorrowckCtxt<'_, 'tcx>,\n         errci: &ErrorConstraintInfo,\n         renctx: &mut RegionErrorNamingCtx,\n-    ) -> DiagnosticBuilder<'_> {\n+    ) -> DiagnosticBuilder<'tcx> {\n         let ErrorConstraintInfo { span, category, .. } = errci;\n \n-        let fr_name_and_span = self.get_var_name_and_span_for_region(\n-            mbcx.infcx.tcx,\n-            &mbcx.body,\n-            &mbcx.local_names,\n-            &mbcx.upvars,\n+        let fr_name_and_span = self.nonlexical_regioncx.get_var_name_and_span_for_region(\n+            self.infcx.tcx,\n+            &self.body,\n+            &self.local_names,\n+            &self.upvars,\n             errci.fr,\n         );\n-        let outlived_fr_name_and_span = self.get_var_name_and_span_for_region(\n-            mbcx.infcx.tcx,\n-            &mbcx.body,\n-            &mbcx.local_names,\n-            &mbcx.upvars,\n+        let outlived_fr_name_and_span = self.nonlexical_regioncx.get_var_name_and_span_for_region(\n+            self.infcx.tcx,\n+            &self.body,\n+            &self.local_names,\n+            &self.upvars,\n             errci.outlived_fr,\n         );\n \n-        let escapes_from = match self.universal_regions.defining_ty {\n+        let escapes_from = match self.nonlexical_regioncx.universal_regions.defining_ty {\n             DefiningTy::Closure(..) => \"closure\",\n             DefiningTy::Generator(..) => \"generator\",\n             DefiningTy::FnDef(..) => \"function\",\n@@ -335,14 +339,13 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             || escapes_from == \"const\"\n         {\n             return self.report_general_error(\n-                mbcx,\n                 &ErrorConstraintInfo { fr_is_local: true, outlived_fr_is_local: false, ..*errci },\n                 renctx,\n             );\n         }\n \n         let mut diag =\n-            borrowck_errors::borrowed_data_escapes_closure(mbcx.infcx.tcx, *span, escapes_from);\n+            borrowck_errors::borrowed_data_escapes_closure(self.infcx.tcx, *span, escapes_from);\n \n         if let Some((Some(outlived_fr_name), outlived_fr_span)) = outlived_fr_name_and_span {\n             diag.span_label(\n@@ -386,10 +389,9 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// ```\n     fn report_general_error(\n         &self,\n-        mbcx: &MirBorrowckCtxt<'_, 'tcx>,\n         errci: &ErrorConstraintInfo,\n         renctx: &mut RegionErrorNamingCtx,\n-    ) -> DiagnosticBuilder<'_> {\n+    ) -> DiagnosticBuilder<'tcx> {\n         let ErrorConstraintInfo {\n             fr,\n             fr_is_local,\n@@ -401,14 +403,14 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         } = errci;\n \n         let mut diag =\n-            mbcx.infcx.tcx.sess.struct_span_err(*span, \"lifetime may not live long enough\");\n+            self.infcx.tcx.sess.struct_span_err(*span, \"lifetime may not live long enough\");\n \n         let mir_def_name =\n-            if mbcx.infcx.tcx.is_closure(mbcx.mir_def_id) { \"closure\" } else { \"function\" };\n+            if self.infcx.tcx.is_closure(self.mir_def_id) { \"closure\" } else { \"function\" };\n \n-        let fr_name = self.give_region_a_name(mbcx, renctx, *fr).unwrap();\n+        let fr_name = self.give_region_a_name(renctx, *fr).unwrap();\n         fr_name.highlight_region_name(&mut diag);\n-        let outlived_fr_name = self.give_region_a_name(mbcx, renctx, *outlived_fr).unwrap();\n+        let outlived_fr_name = self.give_region_a_name(renctx, *outlived_fr).unwrap();\n         outlived_fr_name.highlight_region_name(&mut diag);\n \n         match (category, outlived_fr_is_local, fr_is_local) {\n@@ -435,7 +437,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             }\n         }\n \n-        self.add_static_impl_trait_suggestion(mbcx.infcx, &mut diag, *fr, fr_name, *outlived_fr);\n+        self.add_static_impl_trait_suggestion(&mut diag, *fr, fr_name, *outlived_fr);\n \n         diag\n     }\n@@ -451,8 +453,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// ```\n     fn add_static_impl_trait_suggestion(\n         &self,\n-        infcx: &InferCtxt<'_, 'tcx>,\n-        diag: &mut DiagnosticBuilder<'_>,\n+        diag: &mut DiagnosticBuilder<'tcx>,\n         fr: RegionVid,\n         // We need to pass `fr_name` - computing it again will label it twice.\n         fr_name: RegionName,\n@@ -461,20 +462,21 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         if let (Some(f), Some(ty::RegionKind::ReStatic)) =\n             (self.to_error_region(fr), self.to_error_region(outlived_fr))\n         {\n-            if let Some((ty::TyS { kind: ty::Opaque(did, substs), .. }, _)) = infcx\n+            if let Some((ty::TyS { kind: ty::Opaque(did, substs), .. }, _)) = self\n+                .infcx\n                 .tcx\n                 .is_suitable_region(f)\n                 .map(|r| r.def_id)\n-                .map(|id| infcx.tcx.return_type_impl_trait(id))\n+                .map(|id| self.infcx.tcx.return_type_impl_trait(id))\n                 .unwrap_or(None)\n             {\n                 // Check whether or not the impl trait return type is intended to capture\n                 // data with the static lifetime.\n                 //\n                 // eg. check for `impl Trait + 'static` instead of `impl Trait`.\n                 let has_static_predicate = {\n-                    let predicates_of = infcx.tcx.predicates_of(*did);\n-                    let bounds = predicates_of.instantiate(infcx.tcx, substs);\n+                    let predicates_of = self.infcx.tcx.predicates_of(*did);\n+                    let bounds = predicates_of.instantiate(self.infcx.tcx, substs);\n \n                     let mut found = false;\n                     for predicate in bounds.predicates {\n@@ -502,8 +504,8 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                     diag.help(&format!(\"consider replacing `{}` with `{}`\", fr_name, static_str));\n                 } else {\n                     // Otherwise, we should suggest adding a constraint on the return type.\n-                    let span = infcx.tcx.def_span(*did);\n-                    if let Ok(snippet) = infcx.tcx.sess.source_map().span_to_snippet(span) {\n+                    let span = self.infcx.tcx.def_span(*did);\n+                    if let Ok(snippet) = self.infcx.tcx.sess.source_map().span_to_snippet(span) {\n                         let suggestable_fr_name = if fr_name.was_named() {\n                             fr_name.to_string()\n                         } else {"}, {"sha": "e5dfb0f70eee24b9e568d2d9af807b6022c78d2e", "filename": "src/librustc_mir/borrow_check/diagnostics/region_name.rs", "status": "modified", "additions": 51, "deletions": 60, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/736348ac41b00657bd8d5d6b8acae1eeef9985c7/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fregion_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/736348ac41b00657bd8d5d6b8acae1eeef9985c7/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fregion_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fregion_name.rs?ref=736348ac41b00657bd8d5d6b8acae1eeef9985c7", "patch": "@@ -2,18 +2,15 @@ use std::fmt::{self, Display};\n \n use rustc::ty::print::RegionHighlightMode;\n use rustc::ty::subst::{GenericArgKind, SubstsRef};\n-use rustc::ty::{self, RegionVid, Ty, TyCtxt};\n+use rustc::ty::{self, RegionVid, Ty};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_errors::DiagnosticBuilder;\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n use rustc_span::symbol::kw;\n use rustc_span::{symbol::Symbol, Span, DUMMY_SP};\n \n-use crate::borrow_check::{\n-    nll::ToRegionVid, region_infer::RegionInferenceContext, universal_regions::DefiningTy,\n-    MirBorrowckCtxt,\n-};\n+use crate::borrow_check::{nll::ToRegionVid, universal_regions::DefiningTy, MirBorrowckCtxt};\n \n /// A name for a particular region used in emitting diagnostics. This name could be a generated\n /// name like `'1`, a name used by the user like `'a`, or a name like `'static`.\n@@ -161,7 +158,7 @@ impl Display for RegionName {\n     }\n }\n \n-impl<'tcx> RegionInferenceContext<'tcx> {\n+impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n     /// Maps from an internal MIR region vid to something that we can\n     /// report to the user. In some cases, the region vids will map\n     /// directly to lifetimes that the user has a name for (e.g.,\n@@ -189,24 +186,23 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// and then return the name `'1` for us to use.\n     crate fn give_region_a_name(\n         &self,\n-        mbcx: &MirBorrowckCtxt<'_, 'tcx>,\n         renctx: &mut RegionErrorNamingCtx,\n         fr: RegionVid,\n     ) -> Option<RegionName> {\n         debug!(\"give_region_a_name(fr={:?}, counter={:?})\", fr, renctx.counter);\n \n-        assert!(self.universal_regions.is_universal_region(fr));\n+        assert!(self.nonlexical_regioncx.universal_regions.is_universal_region(fr));\n \n         if let Some(value) = renctx.get(&fr) {\n             return Some(value.clone());\n         }\n \n         let value = self\n-            .give_name_from_error_region(mbcx, fr, renctx)\n-            .or_else(|| self.give_name_if_anonymous_region_appears_in_arguments(mbcx, fr, renctx))\n-            .or_else(|| self.give_name_if_anonymous_region_appears_in_upvars(mbcx, fr, renctx))\n-            .or_else(|| self.give_name_if_anonymous_region_appears_in_output(mbcx, fr, renctx))\n-            .or_else(|| self.give_name_if_anonymous_region_appears_in_yield_ty(mbcx, fr, renctx));\n+            .give_name_from_error_region(fr, renctx)\n+            .or_else(|| self.give_name_if_anonymous_region_appears_in_arguments(fr, renctx))\n+            .or_else(|| self.give_name_if_anonymous_region_appears_in_upvars(fr, renctx))\n+            .or_else(|| self.give_name_if_anonymous_region_appears_in_output(fr, renctx))\n+            .or_else(|| self.give_name_if_anonymous_region_appears_in_yield_ty(fr, renctx));\n \n         if let Some(ref value) = value {\n             renctx.insert(fr, value.clone());\n@@ -222,13 +218,12 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// named variants.\n     fn give_name_from_error_region(\n         &self,\n-        mbcx: &MirBorrowckCtxt<'_, 'tcx>,\n         fr: RegionVid,\n         renctx: &mut RegionErrorNamingCtx,\n     ) -> Option<RegionName> {\n         let error_region = self.to_error_region(fr)?;\n \n-        let tcx = mbcx.infcx.tcx;\n+        let tcx = self.infcx.tcx;\n \n         debug!(\"give_region_a_name: error_region = {:?}\", error_region);\n         match error_region {\n@@ -276,13 +271,13 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                 }\n \n                 ty::BoundRegion::BrEnv => {\n-                    let mir_hir_id = mbcx\n+                    let mir_hir_id = self\n                         .infcx\n                         .tcx\n                         .hir()\n-                        .as_local_hir_id(mbcx.mir_def_id)\n+                        .as_local_hir_id(self.mir_def_id)\n                         .expect(\"non-local mir\");\n-                    let def_ty = self.universal_regions.defining_ty;\n+                    let def_ty = self.nonlexical_regioncx.universal_regions.defining_ty;\n \n                     if let DefiningTy::Closure(def_id, substs) = def_ty {\n                         let args_span = if let hir::ExprKind::Closure(_, _, _, span, _) =\n@@ -346,38 +341,34 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// ```\n     fn give_name_if_anonymous_region_appears_in_arguments(\n         &self,\n-        mbcx: &MirBorrowckCtxt<'_, 'tcx>,\n         fr: RegionVid,\n         renctx: &mut RegionErrorNamingCtx,\n     ) -> Option<RegionName> {\n-        let implicit_inputs = self.universal_regions.defining_ty.implicit_inputs();\n-        let argument_index = self.get_argument_index_for_region(mbcx.infcx.tcx, fr)?;\n-\n-        let arg_ty =\n-            self.universal_regions.unnormalized_input_tys[implicit_inputs + argument_index];\n-        if let Some(region_name) = self.give_name_if_we_can_match_hir_ty_from_argument(\n-            mbcx,\n-            fr,\n-            arg_ty,\n-            argument_index,\n-            renctx,\n-        ) {\n+        let implicit_inputs =\n+            self.nonlexical_regioncx.universal_regions.defining_ty.implicit_inputs();\n+        let argument_index =\n+            self.nonlexical_regioncx.get_argument_index_for_region(self.infcx.tcx, fr)?;\n+\n+        let arg_ty = self.nonlexical_regioncx.universal_regions.unnormalized_input_tys\n+            [implicit_inputs + argument_index];\n+        if let Some(region_name) =\n+            self.give_name_if_we_can_match_hir_ty_from_argument(fr, arg_ty, argument_index, renctx)\n+        {\n             return Some(region_name);\n         }\n \n-        self.give_name_if_we_cannot_match_hir_ty(mbcx, fr, arg_ty, renctx)\n+        self.give_name_if_we_cannot_match_hir_ty(fr, arg_ty, renctx)\n     }\n \n     fn give_name_if_we_can_match_hir_ty_from_argument(\n         &self,\n-        mbcx: &MirBorrowckCtxt<'_, 'tcx>,\n         needle_fr: RegionVid,\n         argument_ty: Ty<'tcx>,\n         argument_index: usize,\n         renctx: &mut RegionErrorNamingCtx,\n     ) -> Option<RegionName> {\n-        let mir_hir_id = mbcx.infcx.tcx.hir().as_local_hir_id(mbcx.mir_def_id)?;\n-        let fn_decl = mbcx.infcx.tcx.hir().fn_decl_by_hir_id(mir_hir_id)?;\n+        let mir_hir_id = self.infcx.tcx.hir().as_local_hir_id(self.mir_def_id)?;\n+        let fn_decl = self.infcx.tcx.hir().fn_decl_by_hir_id(mir_hir_id)?;\n         let argument_hir_ty: &hir::Ty<'_> = fn_decl.inputs.get(argument_index)?;\n         match argument_hir_ty.kind {\n             // This indicates a variable with no type annotation, like\n@@ -388,7 +379,6 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             hir::TyKind::Infer => None,\n \n             _ => self.give_name_if_we_can_match_hir_ty(\n-                mbcx.infcx.tcx,\n                 needle_fr,\n                 argument_ty,\n                 argument_hir_ty,\n@@ -410,26 +400,27 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// ```\n     fn give_name_if_we_cannot_match_hir_ty(\n         &self,\n-        mbcx: &MirBorrowckCtxt<'_, 'tcx>,\n         needle_fr: RegionVid,\n         argument_ty: Ty<'tcx>,\n         renctx: &mut RegionErrorNamingCtx,\n     ) -> Option<RegionName> {\n         let counter = renctx.counter;\n         let mut highlight = RegionHighlightMode::default();\n         highlight.highlighting_region_vid(needle_fr, counter);\n-        let type_name = mbcx.infcx.extract_type_name(&argument_ty, Some(highlight)).0;\n+        let type_name = self.infcx.extract_type_name(&argument_ty, Some(highlight)).0;\n \n         debug!(\n             \"give_name_if_we_cannot_match_hir_ty: type_name={:?} needle_fr={:?}\",\n             type_name, needle_fr\n         );\n         let assigned_region_name = if type_name.find(&format!(\"'{}\", counter)).is_some() {\n             // Only add a label if we can confirm that a region was labelled.\n-            let argument_index = self.get_argument_index_for_region(mbcx.infcx.tcx, needle_fr)?;\n-            let (_, span) = self.get_argument_name_and_span_for_region(\n-                &mbcx.body,\n-                &mbcx.local_names,\n+            let argument_index = self\n+                .nonlexical_regioncx\n+                .get_argument_index_for_region(self.infcx.tcx, needle_fr)?;\n+            let (_, span) = self.nonlexical_regioncx.get_argument_name_and_span_for_region(\n+                &self.body,\n+                &self.local_names,\n                 argument_index,\n             );\n \n@@ -470,7 +461,6 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// to highlighting that closest type instead.\n     fn give_name_if_we_can_match_hir_ty(\n         &self,\n-        tcx: TyCtxt<'tcx>,\n         needle_fr: RegionVid,\n         argument_ty: Ty<'tcx>,\n         argument_hir_ty: &hir::Ty<'_>,\n@@ -495,7 +485,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                         let region_name = renctx.synthesize_region_name();\n \n                         // Just grab the first character, the `&`.\n-                        let source_map = tcx.sess.source_map();\n+                        let source_map = self.infcx.tcx.sess.source_map();\n                         let ampersand_span = source_map.start_point(hir_ty.span);\n \n                         return Some(RegionName {\n@@ -665,13 +655,16 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// ```\n     fn give_name_if_anonymous_region_appears_in_upvars(\n         &self,\n-        mbcx: &MirBorrowckCtxt<'_, 'tcx>,\n         fr: RegionVid,\n         renctx: &mut RegionErrorNamingCtx,\n     ) -> Option<RegionName> {\n-        let upvar_index = self.get_upvar_index_for_region(mbcx.infcx.tcx, fr)?;\n-        let (upvar_name, upvar_span) =\n-            self.get_upvar_name_and_span_for_region(mbcx.infcx.tcx, &mbcx.upvars, upvar_index);\n+        let upvar_index =\n+            self.nonlexical_regioncx.get_upvar_index_for_region(self.infcx.tcx, fr)?;\n+        let (upvar_name, upvar_span) = self.nonlexical_regioncx.get_upvar_name_and_span_for_region(\n+            self.infcx.tcx,\n+            &self.upvars,\n+            upvar_index,\n+        );\n         let region_name = renctx.synthesize_region_name();\n \n         Some(RegionName {\n@@ -686,23 +679,22 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// or be early bound (named, not in argument).\n     fn give_name_if_anonymous_region_appears_in_output(\n         &self,\n-        mbcx: &MirBorrowckCtxt<'_, 'tcx>,\n         fr: RegionVid,\n         renctx: &mut RegionErrorNamingCtx,\n     ) -> Option<RegionName> {\n-        let tcx = mbcx.infcx.tcx;\n+        let tcx = self.infcx.tcx;\n \n-        let return_ty = self.universal_regions.unnormalized_output_ty;\n+        let return_ty = self.nonlexical_regioncx.universal_regions.unnormalized_output_ty;\n         debug!(\"give_name_if_anonymous_region_appears_in_output: return_ty = {:?}\", return_ty);\n         if !tcx.any_free_region_meets(&return_ty, |r| r.to_region_vid() == fr) {\n             return None;\n         }\n \n         let mut highlight = RegionHighlightMode::default();\n         highlight.highlighting_region_vid(fr, renctx.counter);\n-        let type_name = mbcx.infcx.extract_type_name(&return_ty, Some(highlight)).0;\n+        let type_name = self.infcx.extract_type_name(&return_ty, Some(highlight)).0;\n \n-        let mir_hir_id = tcx.hir().as_local_hir_id(mbcx.mir_def_id).expect(\"non-local mir\");\n+        let mir_hir_id = tcx.hir().as_local_hir_id(self.mir_def_id).expect(\"non-local mir\");\n \n         let (return_span, mir_description) = match tcx.hir().get(mir_hir_id) {\n             hir::Node::Expr(hir::Expr {\n@@ -719,7 +711,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                 kind: hir::ImplItemKind::Method(method_sig, _),\n                 ..\n             }) => (method_sig.decl.output.span(), \"\"),\n-            _ => (mbcx.body.span, \"\"),\n+            _ => (self.body.span, \"\"),\n         };\n \n         Some(RegionName {\n@@ -737,32 +729,31 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n \n     fn give_name_if_anonymous_region_appears_in_yield_ty(\n         &self,\n-        mbcx: &MirBorrowckCtxt<'_, 'tcx>,\n         fr: RegionVid,\n         renctx: &mut RegionErrorNamingCtx,\n     ) -> Option<RegionName> {\n         // Note: generators from `async fn` yield `()`, so we don't have to\n         // worry about them here.\n-        let yield_ty = self.universal_regions.yield_ty?;\n+        let yield_ty = self.nonlexical_regioncx.universal_regions.yield_ty?;\n         debug!(\"give_name_if_anonymous_region_appears_in_yield_ty: yield_ty = {:?}\", yield_ty,);\n \n-        let tcx = mbcx.infcx.tcx;\n+        let tcx = self.infcx.tcx;\n \n         if !tcx.any_free_region_meets(&yield_ty, |r| r.to_region_vid() == fr) {\n             return None;\n         }\n \n         let mut highlight = RegionHighlightMode::default();\n         highlight.highlighting_region_vid(fr, renctx.counter);\n-        let type_name = mbcx.infcx.extract_type_name(&yield_ty, Some(highlight)).0;\n+        let type_name = self.infcx.extract_type_name(&yield_ty, Some(highlight)).0;\n \n-        let mir_hir_id = tcx.hir().as_local_hir_id(mbcx.mir_def_id).expect(\"non-local mir\");\n+        let mir_hir_id = tcx.hir().as_local_hir_id(self.mir_def_id).expect(\"non-local mir\");\n \n         let yield_span = match tcx.hir().get(mir_hir_id) {\n             hir::Node::Expr(hir::Expr {\n                 kind: hir::ExprKind::Closure(_, _, _, span, _), ..\n             }) => (tcx.sess.source_map().end_point(*span)),\n-            _ => mbcx.body.span,\n+            _ => self.body.span,\n         };\n \n         debug!("}, {"sha": "209df021ba0d12ce61f3bb1f25f812e2f14ac86a", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/736348ac41b00657bd8d5d6b8acae1eeef9985c7/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/736348ac41b00657bd8d5d6b8acae1eeef9985c7/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=736348ac41b00657bd8d5d6b8acae1eeef9985c7", "patch": "@@ -1471,16 +1471,15 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         // Iterate through all the errors, producing a diagnostic for each one. The diagnostics are\n         // buffered in the `MirBorrowckCtxt`.\n \n-        // FIXME(mark-i-m): Would be great to get rid of the naming context.\n+        // TODO(mark-i-m): Would be great to get rid of the naming context.\n         let mut region_naming = RegionErrorNamingCtx::new();\n         let mut outlives_suggestion = OutlivesSuggestionBuilder::default();\n \n         for nll_error in nll_errors.into_iter() {\n             match nll_error {\n                 RegionErrorKind::TypeTestError { type_test } => {\n                     // Try to convert the lower-bound region into something named we can print for the user.\n-                    let lower_bound_region =\n-                        self.nonlexical_regioncx.to_error_region(type_test.lower_bound);\n+                    let lower_bound_region = self.to_error_region(type_test.lower_bound);\n \n                     // Skip duplicate-ish errors.\n                     let type_test_span = type_test.locations.span(&self.body);\n@@ -1557,16 +1556,13 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n \n                 RegionErrorKind::RegionError { fr_origin, longer_fr, shorter_fr, is_reported } => {\n                     if is_reported {\n-                        let db = self.nonlexical_regioncx.report_error(\n-                            self,\n+                        self.report_error(\n                             longer_fr,\n                             fr_origin,\n                             shorter_fr,\n                             &mut outlives_suggestion,\n                             &mut region_naming,\n                         );\n-\n-                        db.buffer(&mut self.errors_buffer);\n                     } else {\n                         // We only report the first error, so as not to overwhelm the user. See\n                         // `RegRegionErrorKind` docs."}]}