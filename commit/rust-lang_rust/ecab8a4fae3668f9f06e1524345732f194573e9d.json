{"sha": "ecab8a4fae3668f9f06e1524345732f194573e9d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVjYWI4YTRmYWUzNjY4ZjlmMDZlMTUyNDM0NTczMmYxOTQ1NzNlOWQ=", "commit": {"author": {"name": "hyd-dev", "email": "yd-huang@outlook.com", "date": "2021-01-18T15:50:10Z"}, "committer": {"name": "hyd-dev", "email": "yd-huang@outlook.com", "date": "2021-01-24T15:48:06Z"}, "message": "Skip unit tests of `proc-macro` crates", "tree": {"sha": "aa55a6f5f4b97f38e73d78b84a6afe7fd4648c42", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/aa55a6f5f4b97f38e73d78b84a6afe7fd4648c42"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ecab8a4fae3668f9f06e1524345732f194573e9d", "comment_count": 0, "verification": {"verified": false, "reason": "no_user", "signature": "-----BEGIN PGP SIGNATURE-----\n\niIsEABYIADMWIQRJ2jPMDdiQ+U4U42Z0+n/VuNoUuAUCYA2WthUceWQtaHVhbmdA\nb3V0bG9vay5jb20ACgkQdPp/1bjaFLhzdwEAucF5cyYF1pzUscAl7esvfS41bvpK\nqawNsPE9tkurFKUA/32pJB1jx2jNbz3PdrtuSeTurhXen1HHLC22cx93EtgD\n=YpLg\n-----END PGP SIGNATURE-----", "payload": "tree aa55a6f5f4b97f38e73d78b84a6afe7fd4648c42\nparent eae95693d8ae5416cc24153a4055661116100467\nauthor hyd-dev <yd-huang@outlook.com> 1610985010 +0800\ncommitter hyd-dev <yd-huang@outlook.com> 1611503286 +0800\n\nSkip unit tests of `proc-macro` crates\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ecab8a4fae3668f9f06e1524345732f194573e9d", "html_url": "https://github.com/rust-lang/rust/commit/ecab8a4fae3668f9f06e1524345732f194573e9d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ecab8a4fae3668f9f06e1524345732f194573e9d/comments", "author": null, "committer": null, "parents": [{"sha": "eae95693d8ae5416cc24153a4055661116100467", "url": "https://api.github.com/repos/rust-lang/rust/commits/eae95693d8ae5416cc24153a4055661116100467", "html_url": "https://github.com/rust-lang/rust/commit/eae95693d8ae5416cc24153a4055661116100467"}], "stats": {"total": 78, "additions": 59, "deletions": 19}, "files": [{"sha": "b968b9df5918c4e6b173ce38178975a58512b3c8", "filename": "cargo-miri/bin.rs", "status": "modified", "additions": 59, "deletions": 19, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/ecab8a4fae3668f9f06e1524345732f194573e9d/cargo-miri%2Fbin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecab8a4fae3668f9f06e1524345732f194573e9d/cargo-miri%2Fbin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/cargo-miri%2Fbin.rs?ref=ecab8a4fae3668f9f06e1524345732f194573e9d", "patch": "@@ -37,9 +37,9 @@ enum MiriCommand {\n     Setup,\n }\n \n-/// The inforamtion Miri needs to run a crate. Stored as JSON when the crate is \"compiled\".\n+/// The information to run a crate with the given environment.\n #[derive(Serialize, Deserialize)]\n-struct CrateRunInfo {\n+struct CrateRunEnv {\n     /// The command-line arguments.\n     args: Vec<String>,\n     /// The environment.\n@@ -48,13 +48,22 @@ struct CrateRunInfo {\n     current_dir: OsString,\n }\n \n+/// The information Miri needs to run a crate. Stored as JSON when the crate is \"compiled\".\n+#[derive(Serialize, Deserialize)]\n+enum CrateRunInfo {\n+    /// Run it with the given environment.\n+    RunWith(CrateRunEnv),\n+    /// Skip it as Miri does not support interpreting such kind of crates.\n+    SkipProcMacroTest,\n+}\n+\n impl CrateRunInfo {\n     /// Gather all the information we need.\n     fn collect(args: env::Args) -> Self {\n         let args = args.collect();\n         let env = env::vars_os().collect();\n         let current_dir = env::current_dir().unwrap().into_os_string();\n-        CrateRunInfo { args, env, current_dir }\n+        Self::RunWith(CrateRunEnv { args, env, current_dir })\n     }\n \n     fn store(&self, filename: &Path) {\n@@ -90,6 +99,7 @@ fn has_arg_flag(name: &str) -> bool {\n     args.any(|val| val == name)\n }\n \n+/// Yields all values of command line flag `name`.\n struct ArgFlagValueIter<'a> {\n     args: TakeWhile<env::Args, fn(&String) -> bool>,\n     name: &'a str,\n@@ -455,14 +465,15 @@ fn phase_cargo_miri(mut args: env::Args) {\n     // This is needed to make the `CARGO_TARGET_*_RUNNER` env var do something,\n     // and it later helps us detect which crates are proc-macro/build-script\n     // (host crates) and which crates are needed for the program itself.\n-    let target = if let Some(target) = get_arg_flag_value(\"--target\") {\n+    let host = version_info().host;\n+    let target = get_arg_flag_value(\"--target\");\n+    let target = if let Some(ref target) = target {\n         target\n     } else {\n         // No target given. Pick default and tell cargo about it.\n-        let host = version_info().host;\n         cmd.arg(\"--target\");\n         cmd.arg(&host);\n-        host\n+        &host\n     };\n \n     // Forward all further arguments. We do some processing here because we want to\n@@ -514,17 +525,27 @@ fn phase_cargo_miri(mut args: env::Args) {\n     }\n     cmd.env(\"RUSTC_WRAPPER\", &cargo_miri_path);\n \n-    // Set the runner for the current target to us as well, so we can interpret the binaries.\n-    let runner_env_name = format!(\"CARGO_TARGET_{}_RUNNER\", target.to_uppercase().replace('-', \"_\"));\n-    cmd.env(&runner_env_name, &cargo_miri_path);\n+    let runner_env_name = |triple: &str| {\n+        format!(\"CARGO_TARGET_{}_RUNNER\", triple.to_uppercase().replace('-', \"_\"))\n+    };\n+    let host_runner_env_name = runner_env_name(&host);\n+    let target_runner_env_name = runner_env_name(target);\n+    // Set the target runner to us, so we can interpret the binaries.\n+    cmd.env(&target_runner_env_name, &cargo_miri_path);\n+    // Unit tests of `proc-macro` crates are run on the host, so we set the host runner to\n+    // us in order to skip them.\n+    cmd.env(&host_runner_env_name, &cargo_miri_path);\n \n     // Set rustdoc to us as well, so we can make it do nothing (see issue #584).\n     cmd.env(\"RUSTDOC\", &cargo_miri_path);\n \n     // Run cargo.\n     if verbose {\n         eprintln!(\"[cargo-miri miri] RUSTC_WRAPPER={:?}\", cargo_miri_path);\n-        eprintln!(\"[cargo-miri miri] {}={:?}\", runner_env_name, cargo_miri_path);\n+        eprintln!(\"[cargo-miri miri] {}={:?}\", target_runner_env_name, cargo_miri_path);\n+        if *target != host {\n+            eprintln!(\"[cargo-miri miri] {}={:?}\", host_runner_env_name, cargo_miri_path);\n+        }\n         eprintln!(\"[cargo-miri miri] RUSTDOC={:?}\", cargo_miri_path);\n         eprintln!(\"[cargo-miri miri] {:?}\", cmd);\n         cmd.env(\"MIRI_VERBOSE\", \"\"); // This makes the other phases verbose.\n@@ -587,23 +608,34 @@ fn phase_cargo_rustc(args: env::Args) {\n         _ => {},\n     }\n \n-    if !print && target_crate && is_runnable_crate() {\n-        // This is the binary or test crate that we want to interpret under Miri.\n-        // But we cannot run it here, as cargo invoked us as a compiler -- our stdin and stdout are not\n-        // like we want them.\n-        // Instead of compiling, we write JSON into the output file with all the relevant command-line flags\n-        // and environment variables; this is used when cargo calls us again in the CARGO_TARGET_RUNNER phase.\n-        let info = CrateRunInfo::collect(args);\n+    let store_json = |info: CrateRunInfo| {\n         let filename = out_filename(\"\", \"\");\n         if verbose {\n             eprintln!(\"[cargo-miri rustc] writing run info to `{}`\", filename.display());\n         }\n-\n         info.store(&filename);\n         // For Windows, do the same thing again with `.exe` appended to the filename.\n         // (Need to do this here as cargo moves that \"binary\" to a different place before running it.)\n         info.store(&out_filename(\"\", \".exe\"));\n+    };\n \n+    let runnable_crate = !print && is_runnable_crate();\n+\n+    if runnable_crate && target_crate {\n+        // This is the binary or test crate that we want to interpret under Miri.\n+        // But we cannot run it here, as cargo invoked us as a compiler -- our stdin and stdout are not\n+        // like we want them.\n+        // Instead of compiling, we write JSON into the output file with all the relevant command-line flags\n+        // and environment variables; this is used when cargo calls us again in the CARGO_TARGET_RUNNER phase.\n+        store_json(CrateRunInfo::collect(args));\n+        return;\n+    }\n+\n+    if runnable_crate && ArgFlagValueIter::new(\"--extern\").any(|krate| krate == \"proc_macro\") {\n+        // This is a \"runnable\" `proc-macro` crate (unit tests). We do not support\n+        // interpreting that under Miri now, so we write a JSON file to (display a\n+        // helpful message and) skip it in the runner phase.\n+        store_json(CrateRunInfo::SkipProcMacroTest);\n         return;\n     }\n \n@@ -671,8 +703,16 @@ fn phase_cargo_runner(binary: &Path, binary_args: env::Args) {\n     let file = File::open(&binary)\n         .unwrap_or_else(|_| show_error(format!(\"file {:?} not found or `cargo-miri` invoked incorrectly; please only invoke this binary through `cargo miri`\", binary)));\n     let file = BufReader::new(file);\n-    let info: CrateRunInfo = serde_json::from_reader(file)\n+\n+    let info = serde_json::from_reader(file)\n         .unwrap_or_else(|_| show_error(format!(\"file {:?} contains outdated or invalid JSON; try `cargo clean`\", binary)));\n+    let info = match info {\n+        CrateRunInfo::RunWith(info) => info,\n+        CrateRunInfo::SkipProcMacroTest => {\n+            eprintln!(\"Running unit tests of `proc-macro` crates is not currently supported by Miri.\");\n+            return;\n+        }\n+    };\n \n     // Set missing env vars. Looks like `build.rs` vars are still set at run-time, but\n     // `CARGO_BIN_EXE_*` are not. This means we can give the run-time environment precedence,"}]}