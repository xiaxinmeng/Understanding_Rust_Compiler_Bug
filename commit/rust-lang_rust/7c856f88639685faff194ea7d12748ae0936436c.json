{"sha": "7c856f88639685faff194ea7d12748ae0936436c", "node_id": "C_kwDOAAsO6NoAKDdjODU2Zjg4NjM5Njg1ZmFmZjE5NGVhN2QxMjc0OGFlMDkzNjQzNmM", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-08-18T01:54:28Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-08-18T02:02:20Z"}, "message": "move libc pthread tests into separate file", "tree": {"sha": "1ec2071534ae5a3553d0a0c5f10df03192737a3c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1ec2071534ae5a3553d0a0c5f10df03192737a3c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7c856f88639685faff194ea7d12748ae0936436c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7c856f88639685faff194ea7d12748ae0936436c", "html_url": "https://github.com/rust-lang/rust/commit/7c856f88639685faff194ea7d12748ae0936436c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7c856f88639685faff194ea7d12748ae0936436c/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "38002b624aaacbb05f2640d60975e1470dfe5c1a", "url": "https://api.github.com/repos/rust-lang/rust/commits/38002b624aaacbb05f2640d60975e1470dfe5c1a", "html_url": "https://github.com/rust-lang/rust/commit/38002b624aaacbb05f2640d60975e1470dfe5c1a"}], "stats": {"total": 252, "additions": 127, "deletions": 125}, "files": [{"sha": "a883a3d967a3c792136fee763e4070b7808415da", "filename": "tests/pass/shims/libc-misc.rs", "status": "renamed", "additions": 0, "deletions": 125, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/7c856f88639685faff194ea7d12748ae0936436c/tests%2Fpass%2Fshims%2Flibc-misc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c856f88639685faff194ea7d12748ae0936436c/tests%2Fpass%2Fshims%2Flibc-misc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fshims%2Flibc-misc.rs?ref=7c856f88639685faff194ea7d12748ae0936436c", "patch": "@@ -1,7 +1,6 @@\n //@ignore-target-windows: No libc on Windows\n //@compile-flags: -Zmiri-disable-isolation\n #![feature(io_error_more)]\n-#![feature(rustc_private)]\n \n use std::fs::{remove_file, File};\n use std::os::unix::io::AsRawFd;\n@@ -161,122 +160,6 @@ fn test_sync_file_range() {\n     assert_eq!(result_2, 0);\n }\n \n-fn test_mutex_libc_init_recursive() {\n-    unsafe {\n-        let mut attr: libc::pthread_mutexattr_t = std::mem::zeroed();\n-        assert_eq!(libc::pthread_mutexattr_init(&mut attr as *mut _), 0);\n-        assert_eq!(\n-            libc::pthread_mutexattr_settype(&mut attr as *mut _, libc::PTHREAD_MUTEX_RECURSIVE),\n-            0,\n-        );\n-        let mut mutex: libc::pthread_mutex_t = std::mem::zeroed();\n-        assert_eq!(libc::pthread_mutex_init(&mut mutex as *mut _, &mut attr as *mut _), 0);\n-        assert_eq!(libc::pthread_mutex_lock(&mut mutex as *mut _), 0);\n-        assert_eq!(libc::pthread_mutex_trylock(&mut mutex as *mut _), 0);\n-        assert_eq!(libc::pthread_mutex_unlock(&mut mutex as *mut _), 0);\n-        assert_eq!(libc::pthread_mutex_unlock(&mut mutex as *mut _), 0);\n-        assert_eq!(libc::pthread_mutex_trylock(&mut mutex as *mut _), 0);\n-        assert_eq!(libc::pthread_mutex_lock(&mut mutex as *mut _), 0);\n-        assert_eq!(libc::pthread_mutex_unlock(&mut mutex as *mut _), 0);\n-        assert_eq!(libc::pthread_mutex_unlock(&mut mutex as *mut _), 0);\n-        assert_eq!(libc::pthread_mutex_unlock(&mut mutex as *mut _), libc::EPERM);\n-        assert_eq!(libc::pthread_mutex_destroy(&mut mutex as *mut _), 0);\n-        assert_eq!(libc::pthread_mutexattr_destroy(&mut attr as *mut _), 0);\n-    }\n-}\n-\n-fn test_mutex_libc_init_normal() {\n-    unsafe {\n-        let mut mutexattr: libc::pthread_mutexattr_t = std::mem::zeroed();\n-        assert_eq!(\n-            libc::pthread_mutexattr_settype(&mut mutexattr as *mut _, 0x12345678),\n-            libc::EINVAL,\n-        );\n-        assert_eq!(\n-            libc::pthread_mutexattr_settype(&mut mutexattr as *mut _, libc::PTHREAD_MUTEX_NORMAL),\n-            0,\n-        );\n-        let mut mutex: libc::pthread_mutex_t = std::mem::zeroed();\n-        assert_eq!(libc::pthread_mutex_init(&mut mutex as *mut _, &mutexattr as *const _), 0);\n-        assert_eq!(libc::pthread_mutex_lock(&mut mutex as *mut _), 0);\n-        assert_eq!(libc::pthread_mutex_trylock(&mut mutex as *mut _), libc::EBUSY);\n-        assert_eq!(libc::pthread_mutex_unlock(&mut mutex as *mut _), 0);\n-        assert_eq!(libc::pthread_mutex_trylock(&mut mutex as *mut _), 0);\n-        assert_eq!(libc::pthread_mutex_unlock(&mut mutex as *mut _), 0);\n-        assert_eq!(libc::pthread_mutex_destroy(&mut mutex as *mut _), 0);\n-    }\n-}\n-\n-fn test_mutex_libc_init_errorcheck() {\n-    unsafe {\n-        let mut mutexattr: libc::pthread_mutexattr_t = std::mem::zeroed();\n-        assert_eq!(\n-            libc::pthread_mutexattr_settype(\n-                &mut mutexattr as *mut _,\n-                libc::PTHREAD_MUTEX_ERRORCHECK,\n-            ),\n-            0,\n-        );\n-        let mut mutex: libc::pthread_mutex_t = std::mem::zeroed();\n-        assert_eq!(libc::pthread_mutex_init(&mut mutex as *mut _, &mutexattr as *const _), 0);\n-        assert_eq!(libc::pthread_mutex_lock(&mut mutex as *mut _), 0);\n-        assert_eq!(libc::pthread_mutex_trylock(&mut mutex as *mut _), libc::EBUSY);\n-        assert_eq!(libc::pthread_mutex_lock(&mut mutex as *mut _), libc::EDEADLK);\n-        assert_eq!(libc::pthread_mutex_unlock(&mut mutex as *mut _), 0);\n-        assert_eq!(libc::pthread_mutex_trylock(&mut mutex as *mut _), 0);\n-        assert_eq!(libc::pthread_mutex_unlock(&mut mutex as *mut _), 0);\n-        assert_eq!(libc::pthread_mutex_unlock(&mut mutex as *mut _), libc::EPERM);\n-        assert_eq!(libc::pthread_mutex_destroy(&mut mutex as *mut _), 0);\n-    }\n-}\n-\n-// Only linux provides PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP,\n-// libc for macOS just has the default PTHREAD_MUTEX_INITIALIZER.\n-#[cfg(target_os = \"linux\")]\n-fn test_mutex_libc_static_initializer_recursive() {\n-    let mutex = std::cell::UnsafeCell::new(libc::PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP);\n-    unsafe {\n-        assert_eq!(libc::pthread_mutex_lock(mutex.get()), 0);\n-        assert_eq!(libc::pthread_mutex_trylock(mutex.get()), 0);\n-        assert_eq!(libc::pthread_mutex_unlock(mutex.get()), 0);\n-        assert_eq!(libc::pthread_mutex_unlock(mutex.get()), 0);\n-        assert_eq!(libc::pthread_mutex_trylock(mutex.get()), 0);\n-        assert_eq!(libc::pthread_mutex_lock(mutex.get()), 0);\n-        assert_eq!(libc::pthread_mutex_unlock(mutex.get()), 0);\n-        assert_eq!(libc::pthread_mutex_unlock(mutex.get()), 0);\n-        assert_eq!(libc::pthread_mutex_unlock(mutex.get()), libc::EPERM);\n-        assert_eq!(libc::pthread_mutex_destroy(mutex.get()), 0);\n-    }\n-}\n-\n-// Testing the behavior of std::sync::RwLock does not fully exercise the pthread rwlock shims, we\n-// need to go a layer deeper and test the behavior of the libc functions, because\n-// std::sys::unix::rwlock::RWLock itself keeps track of write_locked and num_readers.\n-fn test_rwlock_libc_static_initializer() {\n-    let rw = std::cell::UnsafeCell::new(libc::PTHREAD_RWLOCK_INITIALIZER);\n-    unsafe {\n-        assert_eq!(libc::pthread_rwlock_rdlock(rw.get()), 0);\n-        assert_eq!(libc::pthread_rwlock_rdlock(rw.get()), 0);\n-        assert_eq!(libc::pthread_rwlock_unlock(rw.get()), 0);\n-        assert_eq!(libc::pthread_rwlock_tryrdlock(rw.get()), 0);\n-        assert_eq!(libc::pthread_rwlock_unlock(rw.get()), 0);\n-        assert_eq!(libc::pthread_rwlock_trywrlock(rw.get()), libc::EBUSY);\n-        assert_eq!(libc::pthread_rwlock_unlock(rw.get()), 0);\n-\n-        assert_eq!(libc::pthread_rwlock_wrlock(rw.get()), 0);\n-        assert_eq!(libc::pthread_rwlock_tryrdlock(rw.get()), libc::EBUSY);\n-        assert_eq!(libc::pthread_rwlock_trywrlock(rw.get()), libc::EBUSY);\n-        assert_eq!(libc::pthread_rwlock_unlock(rw.get()), 0);\n-\n-        assert_eq!(libc::pthread_rwlock_trywrlock(rw.get()), 0);\n-        assert_eq!(libc::pthread_rwlock_tryrdlock(rw.get()), libc::EBUSY);\n-        assert_eq!(libc::pthread_rwlock_trywrlock(rw.get()), libc::EBUSY);\n-        assert_eq!(libc::pthread_rwlock_unlock(rw.get()), 0);\n-\n-        assert_eq!(libc::pthread_rwlock_destroy(rw.get()), 0);\n-    }\n-}\n-\n /// Tests whether each thread has its own `__errno_location`.\n fn test_thread_local_errno() {\n     #[cfg(target_os = \"linux\")]\n@@ -413,14 +296,6 @@ fn main() {\n     #[cfg(any(target_os = \"linux\"))]\n     test_sync_file_range();\n \n-    test_mutex_libc_init_recursive();\n-    test_mutex_libc_init_normal();\n-    test_mutex_libc_init_errorcheck();\n-    test_rwlock_libc_static_initializer();\n-\n-    #[cfg(any(target_os = \"linux\"))]\n-    test_mutex_libc_static_initializer_recursive();\n-\n     test_thread_local_errno();\n \n     #[cfg(any(target_os = \"linux\"))]", "previous_filename": "tests/pass/shims/libc.rs"}, {"sha": "d062eda7e90c8429264450904209f0601b2fbf30", "filename": "tests/pass/shims/pthreads.rs", "status": "added", "additions": 127, "deletions": 0, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/7c856f88639685faff194ea7d12748ae0936436c/tests%2Fpass%2Fshims%2Fpthreads.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c856f88639685faff194ea7d12748ae0936436c/tests%2Fpass%2Fshims%2Fpthreads.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fshims%2Fpthreads.rs?ref=7c856f88639685faff194ea7d12748ae0936436c", "patch": "@@ -0,0 +1,127 @@\n+//@ignore-target-windows: No libc on Windows\n+\n+fn main() {\n+    test_mutex_libc_init_recursive();\n+    test_mutex_libc_init_normal();\n+    test_mutex_libc_init_errorcheck();\n+    test_rwlock_libc_static_initializer();\n+\n+    #[cfg(any(target_os = \"linux\"))]\n+    test_mutex_libc_static_initializer_recursive();\n+}\n+\n+fn test_mutex_libc_init_recursive() {\n+    unsafe {\n+        let mut attr: libc::pthread_mutexattr_t = std::mem::zeroed();\n+        assert_eq!(libc::pthread_mutexattr_init(&mut attr as *mut _), 0);\n+        assert_eq!(\n+            libc::pthread_mutexattr_settype(&mut attr as *mut _, libc::PTHREAD_MUTEX_RECURSIVE),\n+            0,\n+        );\n+        let mut mutex: libc::pthread_mutex_t = std::mem::zeroed();\n+        assert_eq!(libc::pthread_mutex_init(&mut mutex as *mut _, &mut attr as *mut _), 0);\n+        assert_eq!(libc::pthread_mutex_lock(&mut mutex as *mut _), 0);\n+        assert_eq!(libc::pthread_mutex_trylock(&mut mutex as *mut _), 0);\n+        assert_eq!(libc::pthread_mutex_unlock(&mut mutex as *mut _), 0);\n+        assert_eq!(libc::pthread_mutex_unlock(&mut mutex as *mut _), 0);\n+        assert_eq!(libc::pthread_mutex_trylock(&mut mutex as *mut _), 0);\n+        assert_eq!(libc::pthread_mutex_lock(&mut mutex as *mut _), 0);\n+        assert_eq!(libc::pthread_mutex_unlock(&mut mutex as *mut _), 0);\n+        assert_eq!(libc::pthread_mutex_unlock(&mut mutex as *mut _), 0);\n+        assert_eq!(libc::pthread_mutex_unlock(&mut mutex as *mut _), libc::EPERM);\n+        assert_eq!(libc::pthread_mutex_destroy(&mut mutex as *mut _), 0);\n+        assert_eq!(libc::pthread_mutexattr_destroy(&mut attr as *mut _), 0);\n+    }\n+}\n+\n+fn test_mutex_libc_init_normal() {\n+    unsafe {\n+        let mut mutexattr: libc::pthread_mutexattr_t = std::mem::zeroed();\n+        assert_eq!(\n+            libc::pthread_mutexattr_settype(&mut mutexattr as *mut _, 0x12345678),\n+            libc::EINVAL,\n+        );\n+        assert_eq!(\n+            libc::pthread_mutexattr_settype(&mut mutexattr as *mut _, libc::PTHREAD_MUTEX_NORMAL),\n+            0,\n+        );\n+        let mut mutex: libc::pthread_mutex_t = std::mem::zeroed();\n+        assert_eq!(libc::pthread_mutex_init(&mut mutex as *mut _, &mutexattr as *const _), 0);\n+        assert_eq!(libc::pthread_mutex_lock(&mut mutex as *mut _), 0);\n+        assert_eq!(libc::pthread_mutex_trylock(&mut mutex as *mut _), libc::EBUSY);\n+        assert_eq!(libc::pthread_mutex_unlock(&mut mutex as *mut _), 0);\n+        assert_eq!(libc::pthread_mutex_trylock(&mut mutex as *mut _), 0);\n+        assert_eq!(libc::pthread_mutex_unlock(&mut mutex as *mut _), 0);\n+        assert_eq!(libc::pthread_mutex_destroy(&mut mutex as *mut _), 0);\n+    }\n+}\n+\n+fn test_mutex_libc_init_errorcheck() {\n+    unsafe {\n+        let mut mutexattr: libc::pthread_mutexattr_t = std::mem::zeroed();\n+        assert_eq!(\n+            libc::pthread_mutexattr_settype(\n+                &mut mutexattr as *mut _,\n+                libc::PTHREAD_MUTEX_ERRORCHECK,\n+            ),\n+            0,\n+        );\n+        let mut mutex: libc::pthread_mutex_t = std::mem::zeroed();\n+        assert_eq!(libc::pthread_mutex_init(&mut mutex as *mut _, &mutexattr as *const _), 0);\n+        assert_eq!(libc::pthread_mutex_lock(&mut mutex as *mut _), 0);\n+        assert_eq!(libc::pthread_mutex_trylock(&mut mutex as *mut _), libc::EBUSY);\n+        assert_eq!(libc::pthread_mutex_lock(&mut mutex as *mut _), libc::EDEADLK);\n+        assert_eq!(libc::pthread_mutex_unlock(&mut mutex as *mut _), 0);\n+        assert_eq!(libc::pthread_mutex_trylock(&mut mutex as *mut _), 0);\n+        assert_eq!(libc::pthread_mutex_unlock(&mut mutex as *mut _), 0);\n+        assert_eq!(libc::pthread_mutex_unlock(&mut mutex as *mut _), libc::EPERM);\n+        assert_eq!(libc::pthread_mutex_destroy(&mut mutex as *mut _), 0);\n+    }\n+}\n+\n+// Only linux provides PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP,\n+// libc for macOS just has the default PTHREAD_MUTEX_INITIALIZER.\n+#[cfg(target_os = \"linux\")]\n+fn test_mutex_libc_static_initializer_recursive() {\n+    let mutex = std::cell::UnsafeCell::new(libc::PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP);\n+    unsafe {\n+        assert_eq!(libc::pthread_mutex_lock(mutex.get()), 0);\n+        assert_eq!(libc::pthread_mutex_trylock(mutex.get()), 0);\n+        assert_eq!(libc::pthread_mutex_unlock(mutex.get()), 0);\n+        assert_eq!(libc::pthread_mutex_unlock(mutex.get()), 0);\n+        assert_eq!(libc::pthread_mutex_trylock(mutex.get()), 0);\n+        assert_eq!(libc::pthread_mutex_lock(mutex.get()), 0);\n+        assert_eq!(libc::pthread_mutex_unlock(mutex.get()), 0);\n+        assert_eq!(libc::pthread_mutex_unlock(mutex.get()), 0);\n+        assert_eq!(libc::pthread_mutex_unlock(mutex.get()), libc::EPERM);\n+        assert_eq!(libc::pthread_mutex_destroy(mutex.get()), 0);\n+    }\n+}\n+\n+// Testing the behavior of std::sync::RwLock does not fully exercise the pthread rwlock shims, we\n+// need to go a layer deeper and test the behavior of the libc functions, because\n+// std::sys::unix::rwlock::RWLock itself keeps track of write_locked and num_readers.\n+fn test_rwlock_libc_static_initializer() {\n+    let rw = std::cell::UnsafeCell::new(libc::PTHREAD_RWLOCK_INITIALIZER);\n+    unsafe {\n+        assert_eq!(libc::pthread_rwlock_rdlock(rw.get()), 0);\n+        assert_eq!(libc::pthread_rwlock_rdlock(rw.get()), 0);\n+        assert_eq!(libc::pthread_rwlock_unlock(rw.get()), 0);\n+        assert_eq!(libc::pthread_rwlock_tryrdlock(rw.get()), 0);\n+        assert_eq!(libc::pthread_rwlock_unlock(rw.get()), 0);\n+        assert_eq!(libc::pthread_rwlock_trywrlock(rw.get()), libc::EBUSY);\n+        assert_eq!(libc::pthread_rwlock_unlock(rw.get()), 0);\n+\n+        assert_eq!(libc::pthread_rwlock_wrlock(rw.get()), 0);\n+        assert_eq!(libc::pthread_rwlock_tryrdlock(rw.get()), libc::EBUSY);\n+        assert_eq!(libc::pthread_rwlock_trywrlock(rw.get()), libc::EBUSY);\n+        assert_eq!(libc::pthread_rwlock_unlock(rw.get()), 0);\n+\n+        assert_eq!(libc::pthread_rwlock_trywrlock(rw.get()), 0);\n+        assert_eq!(libc::pthread_rwlock_tryrdlock(rw.get()), libc::EBUSY);\n+        assert_eq!(libc::pthread_rwlock_trywrlock(rw.get()), libc::EBUSY);\n+        assert_eq!(libc::pthread_rwlock_unlock(rw.get()), 0);\n+\n+        assert_eq!(libc::pthread_rwlock_destroy(rw.get()), 0);\n+    }\n+}"}]}