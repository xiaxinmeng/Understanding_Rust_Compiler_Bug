{"sha": "94c19a18ae8ddf70d0c6a21b296e0858dc154d2a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk0YzE5YTE4YWU4ZGRmNzBkMGM2YTIxYjI5NmUwODU4ZGMxNTRkMmE=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-03-26T00:53:46Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-03-26T00:54:48Z"}, "message": "rustc: Look up names in \"use\"d crates", "tree": {"sha": "8f8a88da05e45ba03c48cf82f9670a9d00991b7a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8f8a88da05e45ba03c48cf82f9670a9d00991b7a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/94c19a18ae8ddf70d0c6a21b296e0858dc154d2a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/94c19a18ae8ddf70d0c6a21b296e0858dc154d2a", "html_url": "https://github.com/rust-lang/rust/commit/94c19a18ae8ddf70d0c6a21b296e0858dc154d2a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/94c19a18ae8ddf70d0c6a21b296e0858dc154d2a/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "661f1c541e86305a714ea2a27ec7b40ca241aa01", "url": "https://api.github.com/repos/rust-lang/rust/commits/661f1c541e86305a714ea2a27ec7b40ca241aa01", "html_url": "https://github.com/rust-lang/rust/commit/661f1c541e86305a714ea2a27ec7b40ca241aa01"}], "stats": {"total": 149, "additions": 138, "deletions": 11}, "files": [{"sha": "977b71864b8369fc071538a7a57e7f1f85aea488", "filename": "src/comp/front/creader.rs", "status": "modified", "additions": 119, "deletions": 5, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/94c19a18ae8ddf70d0c6a21b296e0858dc154d2a/src%2Fcomp%2Ffront%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94c19a18ae8ddf70d0c6a21b296e0858dc154d2a/src%2Fcomp%2Ffront%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fcreader.rs?ref=94c19a18ae8ddf70d0c6a21b296e0858dc154d2a", "patch": "@@ -8,6 +8,7 @@ import lib.llvm.llvmext;\n import lib.llvm.mk_object_file;\n import lib.llvm.mk_section_iter;\n import middle.fold;\n+import middle.metadata;\n import middle.ty;\n import middle.typeck;\n import back.x86;\n@@ -16,8 +17,11 @@ import util.common.span;\n \n import std._str;\n import std._vec;\n+import std.ebml;\n import std.fs;\n+import std.io;\n import std.option;\n+import std.option.none;\n import std.option.some;\n import std.os;\n import std.map.hashmap;\n@@ -30,6 +34,11 @@ type env = @rec(\n     mutable int next_crate_num\n );\n \n+tag resolve_result {\n+    rr_ok(ast.def_id);\n+    rr_not_found(vec[ast.ident], ast.ident);\n+}\n+\n // Type decoding\n \n // Compact string representation for ty.t values. API ty_str & parse_from_str.\n@@ -213,10 +222,96 @@ impure fn parse_ty_fn(@pstate st, str_def sd) -> tup(vec[ty.arg], @ty.t) {\n \n // Rust metadata parsing\n \n-// TODO\n+fn parse_def_id(str s) -> ast.def_id {\n+    ret tup(1, 0);  // TODO\n+}\n+\n+// Given a path and serialized crate metadata, returns the ID of the\n+// definition the path refers to.\n+impure fn resolve_path(vec[ast.ident] path, vec[u8] data) -> resolve_result {\n+    impure fn resolve_path_inner(vec[ast.ident] path, &ebml.reader ebml_r)\n+            -> resolve_result {\n+        auto i = 0u;\n+        auto len = _vec.len[ast.ident](path);\n+        while (i < len) {\n+            auto name = path.(i);\n+            auto last = i == len - 1u;\n+\n+            // Search this level for the identifier.\n+            auto found = false;\n+            while (ebml.bytes_left(ebml_r) > 0u && !found) {\n+                auto ebml_tag = ebml.peek(ebml_r);\n+                check ((ebml_tag.id == metadata.tag_paths_item) ||\n+                       (ebml_tag.id == metadata.tag_paths_mod));\n+\n+                ebml.move_to_first_child(ebml_r);\n+                auto did_opt = none[ast.def_id];\n+                auto name_opt = none[ast.ident];\n+                while (ebml.bytes_left(ebml_r) > 0u) {\n+                    auto inner_tag = ebml.peek(ebml_r);\n+                    if (inner_tag.id == metadata.tag_paths_name) {\n+                        ebml.move_to_first_child(ebml_r);\n+                        auto name_data = ebml.read_data(ebml_r);\n+                        ebml.move_to_parent(ebml_r);\n+                        auto nm = _str.unsafe_from_bytes(name_data);\n+                        name_opt = some[ast.ident](nm);\n+                    } else if (inner_tag.id == metadata.tag_items_def_id) {\n+                        ebml.move_to_first_child(ebml_r);\n+                        auto did_data = ebml.read_data(ebml_r);\n+                        ebml.move_to_parent(ebml_r);\n+                        auto did_str = _str.unsafe_from_bytes(did_data);\n+                        log \"did_str: \" + did_str;\n+                        did_opt = some[ast.def_id](parse_def_id(did_str));\n+                    }\n+                    ebml.move_to_next_sibling(ebml_r);\n+                }\n+                ebml.move_to_parent(ebml_r);\n+\n+                if (_str.eq(option.get[ast.ident](name_opt), name)) {\n+                    // Matched!\n+                    if (last) {\n+                        ret rr_ok(option.get[ast.def_id](did_opt));\n+                    }\n+\n+                    // Move to the module/item we found for the next iteration\n+                    // of the loop...\n+                    ebml.move_to_first_child(ebml_r);\n+                    found = true;\n+                }\n+\n+                ebml.move_to_next_sibling(ebml_r);\n+            }\n+\n+            if (!found) {\n+                auto prev = _vec.slice[ast.ident](path, 0u, i);\n+                ret rr_not_found(prev, name);\n+            }\n+\n+            i += 1u;\n+        }\n+\n+        fail;   // not reached\n+    }\n+\n+    auto io_r = io.new_reader_(io.new_byte_buf_reader(data));\n+    auto ebml_r = ebml.create_reader(io_r);\n+    while (ebml.bytes_left(ebml_r) > 0u) {\n+        auto ebml_tag = ebml.peek(ebml_r);\n+        log #fmt(\"outer ebml tag id: %u\", ebml_tag.id);\n+        if (ebml_tag.id == metadata.tag_paths) {\n+            ebml.move_to_first_child(ebml_r);\n+            ret resolve_path_inner(path, ebml_r);\n+        }\n+        ebml.move_to_next_sibling(ebml_r);\n+    }\n+\n+    log \"resolve_path(): no names in file\";\n+    fail;\n+}\n \n \n fn load_crate(session.session sess,\n+              int cnum,\n               ast.ident ident,\n               vec[str] library_search_paths) {\n     auto filename = parser.default_native_name(sess, ident);\n@@ -235,6 +330,8 @@ fn load_crate(session.session sess,\n                     auto cbuf = llvmext.LLVMGetSectionContents(si.llsi);\n                     auto csz = llvmext.LLVMGetSectionSize(si.llsi);\n                     auto cvbuf = cbuf as _vec.vbuf;\n+                    auto cvec = _vec.vec_from_vbuf[u8](cvbuf, csz);\n+                    sess.set_external_crate(cnum, cvec);\n                     ret;\n                 }\n                 llvmext.LLVMMoveToNextSection(si.llsi);\n@@ -252,8 +349,8 @@ fn fold_view_item_use(&env e, &span sp, ast.ident ident,\n         -> @ast.view_item {\n     auto cnum;\n     if (!e.crate_cache.contains_key(ident)) {\n-        load_crate(e.sess, ident, e.library_search_paths);\n         cnum = e.next_crate_num;\n+        load_crate(e.sess, cnum, ident, e.library_search_paths);\n         e.crate_cache.insert(ident, e.next_crate_num);\n         e.next_crate_num += 1;\n     } else {\n@@ -280,10 +377,27 @@ fn read_crates(session.session sess,\n     ret fold.fold_crate[env](e, fld, crate);\n }\n \n+\n+// Crate metadata queries\n+\n fn lookup_def(session.session sess, &span sp, int cnum, vec[ast.ident] path)\n-    -> ast.def {\n-  // FIXME: fill in.\n-  fail;\n+        -> ast.def {\n+    auto data = sess.get_external_crate(cnum);\n+\n+    auto did;\n+    alt (resolve_path(path, data)) {\n+        case (rr_ok(?di)) { did = di; }\n+        case (rr_not_found(?prev, ?name)) {\n+            sess.span_err(sp,\n+                #fmt(\"unbound name '%s' (no item named '%s' found in '%s')\",\n+                     _str.connect(path, \".\"), name, _str.connect(prev, \".\")));\n+            fail;\n+        }\n+    }\n+\n+    // TODO: Look up item type, use that to determine the type of def.\n+\n+    fail;\n }\n \n fn get_type(session.session sess, ast.def_id def) -> typeck.ty_and_params {"}, {"sha": "64da7ad05fd85f5aeb11c3879ad72f318c285571", "filename": "src/comp/rustc.rc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/94c19a18ae8ddf70d0c6a21b296e0858dc154d2a/src%2Fcomp%2Frustc.rc", "raw_url": "https://github.com/rust-lang/rust/raw/94c19a18ae8ddf70d0c6a21b296e0858dc154d2a/src%2Fcomp%2Frustc.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Frustc.rc?ref=94c19a18ae8ddf70d0c6a21b296e0858dc154d2a", "patch": "@@ -43,6 +43,7 @@ mod util {\n \n auth driver.rustc.main = impure;\n auth front.creader.load_crate = unsafe;\n+auth front.creader.lookup_def = impure;\n auth middle.metadata = unsafe;\n auth middle.trans = unsafe;\n auth middle.trans.copy_args_to_allocas = impure;"}, {"sha": "047218a33a60ff372f037f1fd2495b151cbafba1", "filename": "src/lib/ebml.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/94c19a18ae8ddf70d0c6a21b296e0858dc154d2a/src%2Flib%2Febml.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94c19a18ae8ddf70d0c6a21b296e0858dc154d2a/src%2Flib%2Febml.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Febml.rs?ref=94c19a18ae8ddf70d0c6a21b296e0858dc154d2a", "patch": "@@ -6,7 +6,7 @@ import option.none;\n import option.some;\n \n type ebml_tag = rec(uint id, uint size);\n-type ebml_state = rec(ebml_tag ebml_tag, uint pos);\n+type ebml_state = rec(ebml_tag ebml_tag, uint tag_pos, uint data_pos);\n \n // TODO: When we have module renaming, make \"reader\" and \"writer\" separate\n // modules within this file.\n@@ -56,8 +56,10 @@ impure fn create_reader(&io.reader r) -> reader {\n impure fn bytes_left(&reader r) -> uint {\n     auto pos = r.reader.tell();\n     alt (_vec.last[ebml_state](r.states)) {\n-        case (none[ebml_state])      { ret r.size - pos; }\n-        case (some[ebml_state](?st)) { ret st.pos + st.ebml_tag.size - pos; }\n+        case (none[ebml_state]) { ret r.size - pos; }\n+        case (some[ebml_state](?st)) {\n+            ret st.data_pos + st.ebml_tag.size - pos;\n+        }\n     }\n }\n \n@@ -69,9 +71,10 @@ impure fn read_tag(&reader r) -> ebml_tag {\n \n // Reads a tag and moves the cursor to its first child or data segment.\n impure fn move_to_first_child(&reader r) {\n-    auto pos = r.reader.tell();\n+    auto tag_pos = r.reader.tell();\n     auto t = read_tag(r);\n-    r.states += vec(rec(ebml_tag=t, pos=pos));\n+    auto data_pos = r.reader.tell();\n+    r.states += vec(rec(ebml_tag=t, tag_pos=tag_pos, data_pos=data_pos));\n }\n \n // Reads a tag and skips over its contents, moving to its next sibling.\n@@ -84,7 +87,7 @@ impure fn move_to_next_sibling(&reader r) {\n impure fn move_to_parent(&reader r) {\n     check (_vec.len[ebml_state](r.states) > 0u);\n     auto st = _vec.pop[ebml_state](r.states);\n-    r.reader.seek(st.pos as int, io.seek_set);\n+    r.reader.seek(st.tag_pos as int, io.seek_set);\n }\n \n // Reads the data segment of a tag."}, {"sha": "84de18157c10f455f1183312093c93a286e5fa1e", "filename": "src/lib/io.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/94c19a18ae8ddf70d0c6a21b296e0858dc154d2a/src%2Flib%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94c19a18ae8ddf70d0c6a21b296e0858dc154d2a/src%2Flib%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fio.rs?ref=94c19a18ae8ddf70d0c6a21b296e0858dc154d2a", "patch": "@@ -188,6 +188,11 @@ fn file_reader(str path) -> reader {\n     ret new_reader(FILE_buf_reader(f, true));\n }\n \n+// FIXME: Remove me once objects are exported.\n+fn new_reader_(buf_reader bufr) -> reader {\n+    ret new_reader(bufr);\n+}\n+\n \n // Byte buffer readers\n \n@@ -224,6 +229,10 @@ state obj byte_buf_reader(byte_buf bbuf) {\n     impure fn tell() -> uint { ret bbuf.pos; }\n }\n \n+fn new_byte_buf_reader(vec[u8] buf) -> byte_buf_reader {\n+    ret byte_buf_reader(@rec(buf=buf, mutable pos=0u));\n+}\n+\n \n // Writing\n "}]}