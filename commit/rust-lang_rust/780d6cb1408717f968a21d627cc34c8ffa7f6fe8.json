{"sha": "780d6cb1408717f968a21d627cc34c8ffa7f6fe8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc4MGQ2Y2IxNDA4NzE3Zjk2OGEyMWQ2MjdjYzM0YzhmZmE3ZjZmZTg=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2020-06-25T19:23:41Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2020-07-02T13:49:41Z"}, "message": "rustc_privacy: avoid using TypeckTables::empty for {Name,Type}PrivacyVisitor.", "tree": {"sha": "7fb840e65368edb4e2ccc7856d786068b96a31e5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7fb840e65368edb4e2ccc7856d786068b96a31e5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/780d6cb1408717f968a21d627cc34c8ffa7f6fe8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/780d6cb1408717f968a21d627cc34c8ffa7f6fe8", "html_url": "https://github.com/rust-lang/rust/commit/780d6cb1408717f968a21d627cc34c8ffa7f6fe8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/780d6cb1408717f968a21d627cc34c8ffa7f6fe8/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "883ece499fef22b4703f5b04133bb2beff08c794", "url": "https://api.github.com/repos/rust-lang/rust/commits/883ece499fef22b4703f5b04133bb2beff08c794", "html_url": "https://github.com/rust-lang/rust/commit/883ece499fef22b4703f5b04133bb2beff08c794"}], "stats": {"total": 156, "additions": 58, "deletions": 98}, "files": [{"sha": "de21365c5369af268742886e76c5b06189750fae", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 58, "deletions": 98, "changes": 156, "blob_url": "https://github.com/rust-lang/rust/blob/780d6cb1408717f968a21d627cc34c8ffa7f6fe8/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/780d6cb1408717f968a21d627cc34c8ffa7f6fe8/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=780d6cb1408717f968a21d627cc34c8ffa7f6fe8", "patch": "@@ -2,6 +2,7 @@\n #![feature(in_band_lifetimes)]\n #![feature(nll)]\n #![feature(or_patterns)]\n+#![cfg_attr(bootstrap, feature(track_caller))]\n #![recursion_limit = \"256\"]\n \n use rustc_attr as attr;\n@@ -345,17 +346,6 @@ fn def_id_visibility<'tcx>(\n     }\n }\n \n-// Set the correct `TypeckTables` for the given `item_id` (or an empty table if\n-// there is no `TypeckTables` for the item).\n-fn item_tables<'a, 'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    hir_id: hir::HirId,\n-    empty_tables: &'a ty::TypeckTables<'tcx>,\n-) -> &'a ty::TypeckTables<'tcx> {\n-    let def_id = tcx.hir().local_def_id(hir_id);\n-    if tcx.has_typeck_tables(def_id) { tcx.typeck_tables_of(def_id) } else { empty_tables }\n-}\n-\n fn min(vis1: ty::Visibility, vis2: ty::Visibility, tcx: TyCtxt<'_>) -> ty::Visibility {\n     if vis1.is_at_least(vis2, tcx) { vis2 } else { vis1 }\n }\n@@ -1029,14 +1019,21 @@ impl DefIdVisitor<'tcx> for ReachEverythingInTheInterfaceVisitor<'_, 'tcx> {\n /// This pass performs remaining checks for fields in struct expressions and patterns.\n //////////////////////////////////////////////////////////////////////////////////////\n \n-struct NamePrivacyVisitor<'a, 'tcx> {\n+struct NamePrivacyVisitor<'tcx> {\n     tcx: TyCtxt<'tcx>,\n-    tables: &'a ty::TypeckTables<'tcx>,\n+    maybe_typeck_tables: Option<&'tcx ty::TypeckTables<'tcx>>,\n     current_item: Option<hir::HirId>,\n-    empty_tables: &'a ty::TypeckTables<'tcx>,\n }\n \n-impl<'a, 'tcx> NamePrivacyVisitor<'a, 'tcx> {\n+impl<'tcx> NamePrivacyVisitor<'tcx> {\n+    /// Gets the type-checking side-tables for the current body.\n+    /// As this will ICE if called outside bodies, only call when working with\n+    /// `Expr` or `Pat` nodes (they are guaranteed to be found only in bodies).\n+    #[track_caller]\n+    fn tables(&self) -> &'tcx ty::TypeckTables<'tcx> {\n+        self.maybe_typeck_tables.expect(\"`NamePrivacyVisitor::tables` called outside of body\")\n+    }\n+\n     // Checks that a field in a struct constructor (expression or pattern) is accessible.\n     fn check_field(\n         &mut self,\n@@ -1072,7 +1069,7 @@ impl<'a, 'tcx> NamePrivacyVisitor<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> Visitor<'tcx> for NamePrivacyVisitor<'a, 'tcx> {\n+impl<'tcx> Visitor<'tcx> for NamePrivacyVisitor<'tcx> {\n     type Map = Map<'tcx>;\n \n     /// We want to visit items in the context of their containing\n@@ -1087,39 +1084,22 @@ impl<'a, 'tcx> Visitor<'tcx> for NamePrivacyVisitor<'a, 'tcx> {\n     }\n \n     fn visit_nested_body(&mut self, body: hir::BodyId) {\n-        let orig_tables = mem::replace(&mut self.tables, self.tcx.body_tables(body));\n+        let old_maybe_typeck_tables = self.maybe_typeck_tables.replace(self.tcx.body_tables(body));\n         let body = self.tcx.hir().body(body);\n         self.visit_body(body);\n-        self.tables = orig_tables;\n+        self.maybe_typeck_tables = old_maybe_typeck_tables;\n     }\n \n     fn visit_item(&mut self, item: &'tcx hir::Item<'tcx>) {\n-        let orig_current_item = mem::replace(&mut self.current_item, Some(item.hir_id));\n-        let orig_tables =\n-            mem::replace(&mut self.tables, item_tables(self.tcx, item.hir_id, self.empty_tables));\n+        let orig_current_item = self.current_item.replace(item.hir_id);\n         intravisit::walk_item(self, item);\n         self.current_item = orig_current_item;\n-        self.tables = orig_tables;\n-    }\n-\n-    fn visit_trait_item(&mut self, ti: &'tcx hir::TraitItem<'tcx>) {\n-        let orig_tables =\n-            mem::replace(&mut self.tables, item_tables(self.tcx, ti.hir_id, self.empty_tables));\n-        intravisit::walk_trait_item(self, ti);\n-        self.tables = orig_tables;\n-    }\n-\n-    fn visit_impl_item(&mut self, ii: &'tcx hir::ImplItem<'tcx>) {\n-        let orig_tables =\n-            mem::replace(&mut self.tables, item_tables(self.tcx, ii.hir_id, self.empty_tables));\n-        intravisit::walk_impl_item(self, ii);\n-        self.tables = orig_tables;\n     }\n \n     fn visit_expr(&mut self, expr: &'tcx hir::Expr<'tcx>) {\n         if let hir::ExprKind::Struct(ref qpath, fields, ref base) = expr.kind {\n-            let res = self.tables.qpath_res(qpath, expr.hir_id);\n-            let adt = self.tables.expr_ty(expr).ty_adt_def().unwrap();\n+            let res = self.tables().qpath_res(qpath, expr.hir_id);\n+            let adt = self.tables().expr_ty(expr).ty_adt_def().unwrap();\n             let variant = adt.variant_of_res(res);\n             if let Some(ref base) = *base {\n                 // If the expression uses FRU we need to make sure all the unmentioned fields\n@@ -1128,7 +1108,7 @@ impl<'a, 'tcx> Visitor<'tcx> for NamePrivacyVisitor<'a, 'tcx> {\n                 for (vf_index, variant_field) in variant.fields.iter().enumerate() {\n                     let field = fields\n                         .iter()\n-                        .find(|f| self.tcx.field_index(f.hir_id, self.tables) == vf_index);\n+                        .find(|f| self.tcx.field_index(f.hir_id, self.tables()) == vf_index);\n                     let (use_ctxt, span) = match field {\n                         Some(field) => (field.ident.span, field.span),\n                         None => (base.span, base.span),\n@@ -1138,7 +1118,7 @@ impl<'a, 'tcx> Visitor<'tcx> for NamePrivacyVisitor<'a, 'tcx> {\n             } else {\n                 for field in fields {\n                     let use_ctxt = field.ident.span;\n-                    let index = self.tcx.field_index(field.hir_id, self.tables);\n+                    let index = self.tcx.field_index(field.hir_id, self.tables());\n                     self.check_field(use_ctxt, field.span, adt, &variant.fields[index], false);\n                 }\n             }\n@@ -1149,12 +1129,12 @@ impl<'a, 'tcx> Visitor<'tcx> for NamePrivacyVisitor<'a, 'tcx> {\n \n     fn visit_pat(&mut self, pat: &'tcx hir::Pat<'tcx>) {\n         if let PatKind::Struct(ref qpath, fields, _) = pat.kind {\n-            let res = self.tables.qpath_res(qpath, pat.hir_id);\n-            let adt = self.tables.pat_ty(pat).ty_adt_def().unwrap();\n+            let res = self.tables().qpath_res(qpath, pat.hir_id);\n+            let adt = self.tables().pat_ty(pat).ty_adt_def().unwrap();\n             let variant = adt.variant_of_res(res);\n             for field in fields {\n                 let use_ctxt = field.ident.span;\n-                let index = self.tcx.field_index(field.hir_id, self.tables);\n+                let index = self.tcx.field_index(field.hir_id, self.tables());\n                 self.check_field(use_ctxt, field.span, adt, &variant.fields[index], false);\n             }\n         }\n@@ -1169,16 +1149,22 @@ impl<'a, 'tcx> Visitor<'tcx> for NamePrivacyVisitor<'a, 'tcx> {\n /// Checks are performed on \"semantic\" types regardless of names and their hygiene.\n ////////////////////////////////////////////////////////////////////////////////////////////\n \n-struct TypePrivacyVisitor<'a, 'tcx> {\n+struct TypePrivacyVisitor<'tcx> {\n     tcx: TyCtxt<'tcx>,\n-    tables: &'a ty::TypeckTables<'tcx>,\n+    maybe_typeck_tables: Option<&'tcx ty::TypeckTables<'tcx>>,\n     current_item: LocalDefId,\n-    in_body: bool,\n     span: Span,\n-    empty_tables: &'a ty::TypeckTables<'tcx>,\n }\n \n-impl<'a, 'tcx> TypePrivacyVisitor<'a, 'tcx> {\n+impl<'tcx> TypePrivacyVisitor<'tcx> {\n+    /// Gets the type-checking side-tables for the current body.\n+    /// As this will ICE if called outside bodies, only call when working with\n+    /// `Expr` or `Pat` nodes (they are guaranteed to be found only in bodies).\n+    #[track_caller]\n+    fn tables(&self) -> &'tcx ty::TypeckTables<'tcx> {\n+        self.maybe_typeck_tables.expect(\"`TypePrivacyVisitor::tables` called outside of body\")\n+    }\n+\n     fn item_is_accessible(&self, did: DefId) -> bool {\n         def_id_visibility(self.tcx, did)\n             .0\n@@ -1188,10 +1174,11 @@ impl<'a, 'tcx> TypePrivacyVisitor<'a, 'tcx> {\n     // Take node-id of an expression or pattern and check its type for privacy.\n     fn check_expr_pat_type(&mut self, id: hir::HirId, span: Span) -> bool {\n         self.span = span;\n-        if self.visit(self.tables.node_type(id)) || self.visit(self.tables.node_substs(id)) {\n+        let tables = self.tables();\n+        if self.visit(tables.node_type(id)) || self.visit(tables.node_substs(id)) {\n             return true;\n         }\n-        if let Some(adjustments) = self.tables.adjustments().get(id) {\n+        if let Some(adjustments) = tables.adjustments().get(id) {\n             for adjustment in adjustments {\n                 if self.visit(adjustment.target) {\n                     return true;\n@@ -1214,7 +1201,7 @@ impl<'a, 'tcx> TypePrivacyVisitor<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> Visitor<'tcx> for TypePrivacyVisitor<'a, 'tcx> {\n+impl<'tcx> Visitor<'tcx> for TypePrivacyVisitor<'tcx> {\n     type Map = Map<'tcx>;\n \n     /// We want to visit items in the context of their containing\n@@ -1229,19 +1216,17 @@ impl<'a, 'tcx> Visitor<'tcx> for TypePrivacyVisitor<'a, 'tcx> {\n     }\n \n     fn visit_nested_body(&mut self, body: hir::BodyId) {\n-        let orig_tables = mem::replace(&mut self.tables, self.tcx.body_tables(body));\n-        let orig_in_body = mem::replace(&mut self.in_body, true);\n+        let old_maybe_typeck_tables = self.maybe_typeck_tables.replace(self.tcx.body_tables(body));\n         let body = self.tcx.hir().body(body);\n         self.visit_body(body);\n-        self.tables = orig_tables;\n-        self.in_body = orig_in_body;\n+        self.maybe_typeck_tables = old_maybe_typeck_tables;\n     }\n \n     fn visit_ty(&mut self, hir_ty: &'tcx hir::Ty<'tcx>) {\n         self.span = hir_ty.span;\n-        if self.in_body {\n+        if let Some(tables) = self.maybe_typeck_tables {\n             // Types in bodies.\n-            if self.visit(self.tables.node_type(hir_ty.hir_id)) {\n+            if self.visit(tables.node_type(hir_ty.hir_id)) {\n                 return;\n             }\n         } else {\n@@ -1258,7 +1243,7 @@ impl<'a, 'tcx> Visitor<'tcx> for TypePrivacyVisitor<'a, 'tcx> {\n \n     fn visit_trait_ref(&mut self, trait_ref: &'tcx hir::TraitRef<'tcx>) {\n         self.span = trait_ref.path.span;\n-        if !self.in_body {\n+        if self.maybe_typeck_tables.is_none() {\n             // Avoid calling `hir_trait_to_predicates` in bodies, it will ICE.\n             // The traits' privacy in bodies is already checked as a part of trait object types.\n             let bounds = rustc_typeck::hir_trait_to_predicates(\n@@ -1304,7 +1289,7 @@ impl<'a, 'tcx> Visitor<'tcx> for TypePrivacyVisitor<'a, 'tcx> {\n             hir::ExprKind::MethodCall(_, span, _, _) => {\n                 // Method calls have to be checked specially.\n                 self.span = span;\n-                if let Some(def_id) = self.tables.type_dependent_def_id(expr.hir_id) {\n+                if let Some(def_id) = self.tables().type_dependent_def_id(expr.hir_id) {\n                     if self.visit(self.tcx.type_of(def_id)) {\n                         return;\n                     }\n@@ -1327,9 +1312,14 @@ impl<'a, 'tcx> Visitor<'tcx> for TypePrivacyVisitor<'a, 'tcx> {\n     // more code internal visibility at link time. (Access to private functions\n     // is already prohibited by type privacy for function types.)\n     fn visit_qpath(&mut self, qpath: &'tcx hir::QPath<'tcx>, id: hir::HirId, span: Span) {\n-        let def = match self.tables.qpath_res(qpath, id) {\n-            Res::Def(kind, def_id) => Some((kind, def_id)),\n-            _ => None,\n+        let def = match qpath {\n+            hir::QPath::Resolved(_, path) => match path.res {\n+                Res::Def(kind, def_id) => Some((kind, def_id)),\n+                _ => None,\n+            },\n+            hir::QPath::TypeRelative(..) => {\n+                self.maybe_typeck_tables.and_then(|tables| tables.type_dependent_def(id))\n+            }\n         };\n         let def = def.filter(|(kind, _)| match kind {\n             DefKind::AssocFn | DefKind::AssocConst | DefKind::AssocTy | DefKind::Static => true,\n@@ -1385,31 +1375,14 @@ impl<'a, 'tcx> Visitor<'tcx> for TypePrivacyVisitor<'a, 'tcx> {\n     fn visit_item(&mut self, item: &'tcx hir::Item<'tcx>) {\n         let orig_current_item =\n             mem::replace(&mut self.current_item, self.tcx.hir().local_def_id(item.hir_id));\n-        let orig_in_body = mem::replace(&mut self.in_body, false);\n-        let orig_tables =\n-            mem::replace(&mut self.tables, item_tables(self.tcx, item.hir_id, self.empty_tables));\n+        let old_maybe_typeck_tables = self.maybe_typeck_tables.take();\n         intravisit::walk_item(self, item);\n-        self.tables = orig_tables;\n-        self.in_body = orig_in_body;\n+        self.maybe_typeck_tables = old_maybe_typeck_tables;\n         self.current_item = orig_current_item;\n     }\n-\n-    fn visit_trait_item(&mut self, ti: &'tcx hir::TraitItem<'tcx>) {\n-        let orig_tables =\n-            mem::replace(&mut self.tables, item_tables(self.tcx, ti.hir_id, self.empty_tables));\n-        intravisit::walk_trait_item(self, ti);\n-        self.tables = orig_tables;\n-    }\n-\n-    fn visit_impl_item(&mut self, ii: &'tcx hir::ImplItem<'tcx>) {\n-        let orig_tables =\n-            mem::replace(&mut self.tables, item_tables(self.tcx, ii.hir_id, self.empty_tables));\n-        intravisit::walk_impl_item(self, ii);\n-        self.tables = orig_tables;\n-    }\n }\n \n-impl DefIdVisitor<'tcx> for TypePrivacyVisitor<'a, 'tcx> {\n+impl DefIdVisitor<'tcx> for TypePrivacyVisitor<'tcx> {\n     fn tcx(&self) -> TyCtxt<'tcx> {\n         self.tcx\n     }\n@@ -2066,29 +2039,16 @@ pub fn provide(providers: &mut Providers<'_>) {\n }\n \n fn check_mod_privacy(tcx: TyCtxt<'_>, module_def_id: LocalDefId) {\n-    let empty_tables = ty::TypeckTables::empty(None);\n-\n     // Check privacy of names not checked in previous compilation stages.\n-    let mut visitor = NamePrivacyVisitor {\n-        tcx,\n-        tables: &empty_tables,\n-        current_item: None,\n-        empty_tables: &empty_tables,\n-    };\n+    let mut visitor = NamePrivacyVisitor { tcx, maybe_typeck_tables: None, current_item: None };\n     let (module, span, hir_id) = tcx.hir().get_module(module_def_id);\n \n     intravisit::walk_mod(&mut visitor, module, hir_id);\n \n     // Check privacy of explicitly written types and traits as well as\n     // inferred types of expressions and patterns.\n-    let mut visitor = TypePrivacyVisitor {\n-        tcx,\n-        tables: &empty_tables,\n-        current_item: module_def_id,\n-        in_body: false,\n-        span,\n-        empty_tables: &empty_tables,\n-    };\n+    let mut visitor =\n+        TypePrivacyVisitor { tcx, maybe_typeck_tables: None, current_item: module_def_id, span };\n     intravisit::walk_mod(&mut visitor, module, hir_id);\n }\n "}]}