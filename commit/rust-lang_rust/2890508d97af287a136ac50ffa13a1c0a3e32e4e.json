{"sha": "2890508d97af287a136ac50ffa13a1c0a3e32e4e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI4OTA1MDhkOTdhZjI4N2ExMzZhYzUwZmZhMTNhMWMwYTNlMzJlNGU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-02-24T02:22:44Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-02-24T02:22:44Z"}, "message": "Auto merge of #21689 - FlaPer87:oibit-send-and-friends, r=nikomatsakis\n\nThis is one more step towards completing #13231\r\n\r\nThis series of commits add support for default trait implementations. The changes in this PR don't break existing code and they are expected to preserve the existing behavior in the compiler as far as built-in bounds checks go.\r\n\r\nThe PR adds negative implementations of `Send`/`Sync` for some types and it removes the special cases for `Send`/`Sync` during the trait obligations checks. That is, it now fully relies on the traits check rather than lang items.\r\n\r\nOnce this patch lands and a new snapshot is created, it'll be possible to add default impls for `Send` and `Sync` and remove entirely the use of `BuiltinBound::{BoundSend,BoundSync}` for positive implementations as well.\r\n\r\nThis PR also removes the restriction on negative implementations. That is, it is now possible to add negative implementations for traits other than `Send`/`Sync`", "tree": {"sha": "d4cba9bfc722d5fb7d44c74dfebde016c45130aa", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d4cba9bfc722d5fb7d44c74dfebde016c45130aa"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2890508d97af287a136ac50ffa13a1c0a3e32e4e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2890508d97af287a136ac50ffa13a1c0a3e32e4e", "html_url": "https://github.com/rust-lang/rust/commit/2890508d97af287a136ac50ffa13a1c0a3e32e4e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2890508d97af287a136ac50ffa13a1c0a3e32e4e/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c4fe7d6aea022330efb8d1b470cac030a859f8f5", "url": "https://api.github.com/repos/rust-lang/rust/commits/c4fe7d6aea022330efb8d1b470cac030a859f8f5", "html_url": "https://github.com/rust-lang/rust/commit/c4fe7d6aea022330efb8d1b470cac030a859f8f5"}, {"sha": "3dcc631dee7b2f4be3443b4bbc1dd916436d60ca", "url": "https://api.github.com/repos/rust-lang/rust/commits/3dcc631dee7b2f4be3443b4bbc1dd916436d60ca", "html_url": "https://github.com/rust-lang/rust/commit/3dcc631dee7b2f4be3443b4bbc1dd916436d60ca"}], "stats": {"total": 1384, "additions": 1208, "deletions": 176}, "files": [{"sha": "b8a22c30f9e1ed14a9146b22772af699adc45901", "filename": "src/libcore/cell.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2890508d97af287a136ac50ffa13a1c0a3e32e4e/src%2Flibcore%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2890508d97af287a136ac50ffa13a1c0a3e32e4e/src%2Flibcore%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcell.rs?ref=2890508d97af287a136ac50ffa13a1c0a3e32e4e", "patch": "@@ -144,7 +144,7 @@\n use clone::Clone;\n use cmp::PartialEq;\n use default::Default;\n-use marker::{Copy, Send};\n+use marker::{Copy, Send, Sync};\n use ops::{Deref, DerefMut, Drop};\n use option::Option;\n use option::Option::{None, Some};\n@@ -660,6 +660,8 @@ pub struct UnsafeCell<T> {\n     pub value: T,\n }\n \n+impl<T> !Sync for UnsafeCell<T> {}\n+\n impl<T> UnsafeCell<T> {\n     /// Construct a new instance of `UnsafeCell` which will wrap the specified\n     /// value."}, {"sha": "a9d699735908529c52614531693ecc54adacbed7", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2890508d97af287a136ac50ffa13a1c0a3e32e4e/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2890508d97af287a136ac50ffa13a1c0a3e32e4e/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=2890508d97af287a136ac50ffa13a1c0a3e32e4e", "patch": "@@ -68,6 +68,7 @@\n #![feature(staged_api)]\n #![feature(unboxed_closures)]\n #![feature(rustc_attrs)]\n+#![feature(optin_builtin_traits)]\n \n #[macro_use]\n mod macros;"}, {"sha": "6c934a998de2d4cb5d64ce35d135ce12f312bc0d", "filename": "src/libcore/marker.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2890508d97af287a136ac50ffa13a1c0a3e32e4e/src%2Flibcore%2Fmarker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2890508d97af287a136ac50ffa13a1c0a3e32e4e/src%2Flibcore%2Fmarker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmarker.rs?ref=2890508d97af287a136ac50ffa13a1c0a3e32e4e", "patch": "@@ -39,6 +39,10 @@ pub unsafe trait Send : MarkerTrait {\n     // empty.\n }\n \n+impl<T> !Send for *const T { }\n+impl<T> !Send for *mut T { }\n+impl !Send for Managed { }\n+\n /// Types with a constant size known at compile-time.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[lang=\"sized\"]\n@@ -204,6 +208,10 @@ pub unsafe trait Sync : MarkerTrait {\n     // Empty\n }\n \n+impl<T> !Sync for *const T { }\n+impl<T> !Sync for *mut T { }\n+impl !Sync for Managed { }\n+\n /// A type which is considered \"not POD\", meaning that it is not\n /// implicitly copyable. This is typically embedded in other types to\n /// ensure that they are never copied, even if they lack a destructor."}, {"sha": "5ee2f89018946b7af7487fc168a035f15ce6bf5d", "filename": "src/librustc/metadata/csearch.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2890508d97af287a136ac50ffa13a1c0a3e32e4e/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2890508d97af287a136ac50ffa13a1c0a3e32e4e/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcsearch.rs?ref=2890508d97af287a136ac50ffa13a1c0a3e32e4e", "patch": "@@ -410,3 +410,7 @@ pub fn is_associated_type(cstore: &cstore::CStore, def: ast::DefId) -> bool {\n     decoder::is_associated_type(&*cdata, def.node)\n }\n \n+pub fn is_default_trait(cstore: &cstore::CStore, def: ast::DefId) -> bool {\n+    let cdata = cstore.get_crate_data(def.krate);\n+    decoder::is_default_trait(&*cdata, def.node)\n+}"}, {"sha": "aeae101a1235c26a56d4bac0cc32010a6843c764", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 15, "deletions": 4, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/2890508d97af287a136ac50ffa13a1c0a3e32e4e/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2890508d97af287a136ac50ffa13a1c0a3e32e4e/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=2890508d97af287a136ac50ffa13a1c0a3e32e4e", "patch": "@@ -126,6 +126,7 @@ enum Family {\n     TupleVariant,          // v\n     StructVariant,         // V\n     Impl,                  // i\n+    DefaultImpl,              // d\n     Trait,                 // I\n     Struct,                // S\n     PublicField,           // g\n@@ -151,6 +152,7 @@ fn item_family(item: rbml::Doc) -> Family {\n       'v' => TupleVariant,\n       'V' => StructVariant,\n       'i' => Impl,\n+      'd' => DefaultImpl,\n       'I' => Trait,\n       'S' => Struct,\n       'g' => PublicField,\n@@ -355,9 +357,9 @@ fn item_to_def_like(item: rbml::Doc, did: ast::DefId, cnum: ast::CrateNum)\n             let enum_did = item_reqd_and_translated_parent_item(cnum, item);\n             DlDef(def::DefVariant(enum_did, did, false))\n         }\n-        Trait => DlDef(def::DefTrait(did)),\n+        Trait => DlDef(def::DefaultImpl(did)),\n         Enum => DlDef(def::DefTy(did, true)),\n-        Impl => DlImpl(did),\n+        Impl | DefaultImpl => DlImpl(did),\n         PublicField | InheritedField => DlField,\n     }\n }\n@@ -480,7 +482,7 @@ pub fn get_impl_trait<'tcx>(cdata: Cmd,\n     let item_doc = lookup_item(id, cdata.data());\n     let fam = item_family(item_doc);\n     match fam {\n-        Family::Impl => {\n+        Family::Impl | Family::DefaultImpl => {\n             reader::maybe_get_doc(item_doc, tag_item_trait_ref).map(|tp| {\n                 doc_trait_ref(tp, tcx, cdata)\n             })\n@@ -1356,7 +1358,7 @@ pub fn get_trait_of_item(cdata: Cmd, id: ast::NodeId, tcx: &ty::ctxt)\n     let parent_item_doc = lookup_item(parent_item_id.node, cdata.data());\n     match item_family(parent_item_doc) {\n         Trait => Some(item_def_id(parent_item_doc, cdata)),\n-        Impl => {\n+        Impl | DefaultImpl => {\n             reader::maybe_get_doc(parent_item_doc, tag_item_trait_ref)\n                 .map(|_| item_trait_ref(parent_item_doc, tcx, cdata).def_id)\n         }\n@@ -1561,3 +1563,12 @@ pub fn is_associated_type(cdata: Cmd, id: ast::NodeId) -> bool {\n         Some(item) => item_sort(item) == 't',\n     }\n }\n+\n+\n+pub fn is_default_trait<'tcx>(cdata: Cmd, id: ast::NodeId) -> bool {\n+    let item_doc = lookup_item(id, cdata.data());\n+    match item_family(item_doc) {\n+        Family::DefaultImpl => true,\n+        _ => false\n+    }\n+}"}, {"sha": "e0832bb683a1c9064963500c8c5387bcabaf5752", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2890508d97af287a136ac50ffa13a1c0a3e32e4e/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2890508d97af287a136ac50ffa13a1c0a3e32e4e/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=2890508d97af287a136ac50ffa13a1c0a3e32e4e", "patch": "@@ -1193,6 +1193,18 @@ fn encode_info_for_item(ecx: &EncodeContext,\n             None => {}\n         }\n       }\n+      ast::ItemDefaultImpl(unsafety, ref ast_trait_ref) => {\n+          add_to_index(item, rbml_w, index);\n+          rbml_w.start_tag(tag_items_data_item);\n+          encode_def_id(rbml_w, def_id);\n+          encode_family(rbml_w, 'd');\n+          encode_name(rbml_w, item.ident.name);\n+          encode_unsafety(rbml_w, unsafety);\n+\n+          let trait_ref = ty::node_id_to_trait_ref(tcx, ast_trait_ref.ref_id);\n+          encode_trait_ref(rbml_w, ecx, &*trait_ref, tag_item_trait_ref);\n+          rbml_w.end_tag();\n+      }\n       ast::ItemImpl(unsafety, polarity, _, ref opt_trait, ref ty, ref ast_items) => {\n         // We need to encode information about the default methods we\n         // have inherited, so we drive this based on the impl structure."}, {"sha": "e63901c21b270aa850b4e77e7b6af7138e975c87", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2890508d97af287a136ac50ffa13a1c0a3e32e4e/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2890508d97af287a136ac50ffa13a1c0a3e32e4e/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=2890508d97af287a136ac50ffa13a1c0a3e32e4e", "patch": "@@ -440,7 +440,7 @@ impl tr for def::Def {\n           def::DefVariant(e_did, v_did, is_s) => {\n             def::DefVariant(e_did.tr(dcx), v_did.tr(dcx), is_s)\n           },\n-          def::DefTrait(did) => def::DefTrait(did.tr(dcx)),\n+          def::DefaultImpl(did) => def::DefaultImpl(did.tr(dcx)),\n           def::DefTy(did, is_enum) => def::DefTy(did.tr(dcx), is_enum),\n           def::DefAssociatedTy(did) => def::DefAssociatedTy(did.tr(dcx)),\n           def::DefAssociatedPath(def::TyParamProvenance::FromSelf(did), ident) =>"}, {"sha": "009bfaf8728f8012e43e928e12f5d6e43d7e5d26", "filename": "src/librustc/middle/def.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2890508d97af287a136ac50ffa13a1c0a3e32e4e/src%2Flibrustc%2Fmiddle%2Fdef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2890508d97af287a136ac50ffa13a1c0a3e32e4e/src%2Flibrustc%2Fmiddle%2Fdef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdef.rs?ref=2890508d97af287a136ac50ffa13a1c0a3e32e4e", "patch": "@@ -38,7 +38,7 @@ pub enum Def {\n     // type `U` (indicated by the Ident).\n     // FIXME(#20301) -- should use Name\n     DefAssociatedPath(TyParamProvenance, ast::Ident),\n-    DefTrait(ast::DefId),\n+    DefaultImpl(ast::DefId),\n     DefPrimTy(ast::PrimTy),\n     DefTyParam(ParamSpace, u32, ast::DefId, ast::Name),\n     DefUse(ast::DefId),\n@@ -135,7 +135,7 @@ impl Def {\n             DefFn(id, _) | DefStaticMethod(id, _) | DefMod(id) |\n             DefForeignMod(id) | DefStatic(id, _) |\n             DefVariant(_, id, _) | DefTy(id, _) | DefAssociatedTy(id) |\n-            DefTyParam(_, _, id, _) | DefUse(id) | DefStruct(id) | DefTrait(id) |\n+            DefTyParam(_, _, id, _) | DefUse(id) | DefStruct(id) | DefaultImpl(id) |\n             DefMethod(id, _, _) | DefConst(id) |\n             DefAssociatedPath(TyParamProvenance::FromSelf(id), _) |\n             DefAssociatedPath(TyParamProvenance::FromParam(id), _) => {"}, {"sha": "5aa6be43002b56d2fa788b03071c6f8ebef35e76", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2890508d97af287a136ac50ffa13a1c0a3e32e4e/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2890508d97af287a136ac50ffa13a1c0a3e32e4e/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=2890508d97af287a136ac50ffa13a1c0a3e32e4e", "patch": "@@ -579,7 +579,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n                 Ok(self.cat_rvalue_node(id, span, expr_ty))\n           }\n           def::DefMod(_) | def::DefForeignMod(_) | def::DefUse(_) |\n-          def::DefTrait(_) | def::DefTy(..) | def::DefPrimTy(_) |\n+          def::DefaultImpl(_) | def::DefTy(..) | def::DefPrimTy(_) |\n           def::DefTyParam(..) | def::DefTyParamBinder(..) | def::DefRegion(_) |\n           def::DefLabel(_) | def::DefSelfTy(..) |\n           def::DefAssociatedTy(..) | def::DefAssociatedPath(..)=> {"}, {"sha": "550f4e39447f8252298a6a33fa41c7c9d6207adb", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2890508d97af287a136ac50ffa13a1c0a3e32e4e/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2890508d97af287a136ac50ffa13a1c0a3e32e4e/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=2890508d97af287a136ac50ffa13a1c0a3e32e4e", "patch": "@@ -290,7 +290,8 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n                     ast::ItemTy(..) | ast::ItemStatic(_, _, _) |\n                     ast::ItemMod(..) | ast::ItemForeignMod(..) |\n                     ast::ItemImpl(..) | ast::ItemTrait(..) |\n-                    ast::ItemStruct(..) | ast::ItemEnum(..) => {}\n+                    ast::ItemStruct(..) | ast::ItemEnum(..) |\n+                    ast::ItemDefaultImpl(..) => {}\n \n                     _ => {\n                         self.tcx.sess.span_bug(item.span,"}, {"sha": "bef98f5bd02beecb7a2199137f8c6a99dafb131d", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2890508d97af287a136ac50ffa13a1c0a3e32e4e/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2890508d97af287a136ac50ffa13a1c0a3e32e4e/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=2890508d97af287a136ac50ffa13a1c0a3e32e4e", "patch": "@@ -115,6 +115,7 @@ impl<'a, 'v> Visitor<'v> for LifetimeContext<'a> {\n                 ast::ItemUse(_) |\n                 ast::ItemMod(..) |\n                 ast::ItemMac(..) |\n+                ast::ItemDefaultImpl(..) |\n                 ast::ItemForeignMod(..) |\n                 ast::ItemStatic(..) |\n                 ast::ItemConst(..) => {\n@@ -168,7 +169,7 @@ impl<'a, 'v> Visitor<'v> for LifetimeContext<'a> {\n                 // if this path references a trait, then this will resolve to\n                 // a trait ref, which introduces a binding scope.\n                 match self.def_map.borrow().get(&id) {\n-                    Some(&def::DefTrait(..)) => {\n+                    Some(&def::DefaultImpl(..)) => {\n                         self.with(LateScope(&Vec::new(), self.scope), |_, this| {\n                             this.visit_path(path, id);\n                         });"}, {"sha": "8b836fd322e3cb8e99dbad196fe552e8fb7f6ccf", "filename": "src/librustc/middle/traits/mod.rs", "status": "modified", "additions": 42, "deletions": 3, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/2890508d97af287a136ac50ffa13a1c0a3e32e4e/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2890508d97af287a136ac50ffa13a1c0a3e32e4e/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs?ref=2890508d97af287a136ac50ffa13a1c0a3e32e4e", "patch": "@@ -221,6 +221,12 @@ pub enum Vtable<'tcx, N> {\n     /// Vtable identifying a particular impl.\n     VtableImpl(VtableImplData<'tcx, N>),\n \n+    /// Vtable for default trait implementations\n+    /// This carries the information and nested obligations with regards\n+    /// to a default implementation for a trait `Trait`. The nested obligations\n+    /// ensure the trait implementation holds for all the constituent types.\n+    VtableDefaultImpl(VtableDefaultImplData<N>),\n+\n     /// Successful resolution to an obligation provided by the caller\n     /// for some type parameter. The `Vec<N>` represents the\n     /// obligations incurred from normalizing the where-clause (if\n@@ -259,6 +265,12 @@ pub struct VtableImplData<'tcx, N> {\n     pub nested: subst::VecPerParamSpace<N>\n }\n \n+#[derive(Debug,Clone)]\n+pub struct VtableDefaultImplData<N> {\n+    pub trait_def_id: ast::DefId,\n+    pub nested: Vec<N>\n+}\n+\n #[derive(Debug,Clone)]\n pub struct VtableBuiltinData<N> {\n     pub nested: subst::VecPerParamSpace<N>\n@@ -513,17 +525,18 @@ impl<'tcx, N> Vtable<'tcx, N> {\n     pub fn iter_nested(&self) -> Iter<N> {\n         match *self {\n             VtableImpl(ref i) => i.iter_nested(),\n-            VtableFnPointer(..) => (&[]).iter(),\n-            VtableClosure(..) => (&[]).iter(),\n             VtableParam(ref n) => n.iter(),\n-            VtableObject(_) => (&[]).iter(),\n             VtableBuiltin(ref i) => i.iter_nested(),\n+            VtableObject(_) |\n+            VtableDefaultImpl(..) | VtableFnPointer(..) |\n+            VtableClosure(..) => (&[]).iter(),\n         }\n     }\n \n     pub fn map_nested<M, F>(&self, op: F) -> Vtable<'tcx, M> where F: FnMut(&N) -> M {\n         match *self {\n             VtableImpl(ref i) => VtableImpl(i.map_nested(op)),\n+            VtableDefaultImpl(ref t) => VtableDefaultImpl(t.map_nested(op)),\n             VtableFnPointer(ref sig) => VtableFnPointer((*sig).clone()),\n             VtableClosure(d, ref s) => VtableClosure(d, s.clone()),\n             VtableParam(ref n) => VtableParam(n.iter().map(op).collect()),\n@@ -539,6 +552,7 @@ impl<'tcx, N> Vtable<'tcx, N> {\n             VtableImpl(i) => VtableImpl(i.map_move_nested(op)),\n             VtableFnPointer(sig) => VtableFnPointer(sig),\n             VtableClosure(d, s) => VtableClosure(d, s),\n+            VtableDefaultImpl(t) => VtableDefaultImpl(t.map_move_nested(op)),\n             VtableParam(n) => VtableParam(n.into_iter().map(op).collect()),\n             VtableObject(p) => VtableObject(p),\n             VtableBuiltin(no) => VtableBuiltin(no.map_move_nested(op)),\n@@ -573,6 +587,31 @@ impl<'tcx, N> VtableImplData<'tcx, N> {\n     }\n }\n \n+impl<N> VtableDefaultImplData<N> {\n+    pub fn iter_nested(&self) -> Iter<N> {\n+        self.nested.iter()\n+    }\n+\n+    pub fn map_nested<M, F>(&self, op: F) -> VtableDefaultImplData<M> where\n+        F: FnMut(&N) -> M,\n+    {\n+        VtableDefaultImplData {\n+            trait_def_id: self.trait_def_id,\n+            nested: self.nested.iter().map(op).collect()\n+        }\n+    }\n+\n+    pub fn map_move_nested<M, F>(self, op: F) -> VtableDefaultImplData<M> where\n+        F: FnMut(N) -> M,\n+    {\n+        let VtableDefaultImplData { trait_def_id, nested } = self;\n+        VtableDefaultImplData {\n+            trait_def_id: trait_def_id,\n+            nested: nested.into_iter().map(op).collect()\n+        }\n+    }\n+}\n+\n impl<N> VtableBuiltinData<N> {\n     pub fn iter_nested(&self) -> Iter<N> {\n         self.nested.iter()"}, {"sha": "7d4febb38e678186ff6b5380f55e53ec20bb1a2c", "filename": "src/librustc/middle/traits/project.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2890508d97af287a136ac50ffa13a1c0a3e32e4e/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2890508d97af287a136ac50ffa13a1c0a3e32e4e/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs?ref=2890508d97af287a136ac50ffa13a1c0a3e32e4e", "patch": "@@ -709,6 +709,7 @@ fn assemble_candidates_from_impls<'cx,'tcx>(\n             // projection. And the projection where clause is handled\n             // in `assemble_candidates_from_param_env`.\n         }\n+        super::VtableDefaultImpl(..) |\n         super::VtableBuiltin(..) => {\n             // These traits have no associated types.\n             selcx.tcx().sess.span_bug("}, {"sha": "daf7e50e1bc9abee31e9c790378b88a31d52aec1", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 352, "deletions": 93, "changes": 445, "blob_url": "https://github.com/rust-lang/rust/blob/2890508d97af287a136ac50ffa13a1c0a3e32e4e/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2890508d97af287a136ac50ffa13a1c0a3e32e4e/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=2890508d97af287a136ac50ffa13a1c0a3e32e4e", "patch": "@@ -17,17 +17,17 @@ use self::SelectionCandidate::*;\n use self::BuiltinBoundConditions::*;\n use self::EvaluationResult::*;\n \n-use super::{DerivedObligationCause};\n-use super::{project};\n-use super::project::Normalized;\n+use super::DerivedObligationCause;\n+use super::project;\n+use super::project::{normalize_with_depth, Normalized};\n use super::{PredicateObligation, TraitObligation, ObligationCause};\n-use super::{ObligationCauseCode, BuiltinDerivedObligation};\n+use super::{ObligationCauseCode, BuiltinDerivedObligation, ImplDerivedObligation};\n use super::{SelectionError, Unimplemented, Overflow, OutputTypeParameterMismatch};\n use super::{Selection};\n use super::{SelectionResult};\n use super::{VtableBuiltin, VtableImpl, VtableParam, VtableClosure,\n-            VtableFnPointer, VtableObject};\n-use super::{VtableImplData, VtableObjectData, VtableBuiltinData};\n+            VtableFnPointer, VtableObject, VtableDefaultImpl};\n+use super::{VtableImplData, VtableObjectData, VtableBuiltinData, VtableDefaultImplData};\n use super::object_safety;\n use super::{util};\n \n@@ -136,6 +136,7 @@ enum SelectionCandidate<'tcx> {\n     BuiltinCandidate(ty::BuiltinBound),\n     ParamCandidate(ty::PolyTraitRef<'tcx>),\n     ImplCandidate(ast::DefId),\n+    DefaultImplCandidate(ast::DefId),\n \n     /// This is a trait matching with a projected type as `Self`, and\n     /// we found an applicable bound in the trait definition.\n@@ -151,6 +152,8 @@ enum SelectionCandidate<'tcx> {\n \n     ObjectCandidate,\n \n+    BuiltinObjectCandidate,\n+\n     ErrorCandidate,\n }\n \n@@ -818,31 +821,24 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 debug!(\"obligation self ty is {}\",\n                        obligation.predicate.0.self_ty().repr(self.tcx()));\n \n+                // User-defined copy impls are permitted, but only for\n+                // structs and enums.\n                 try!(self.assemble_candidates_from_impls(obligation, &mut candidates));\n \n+                // For other types, we'll use the builtin rules.\n                 try!(self.assemble_builtin_bound_candidates(ty::BoundCopy,\n                                                             stack,\n                                                             &mut candidates));\n             }\n-            Some(bound @ ty::BoundSend) |\n-            Some(bound @ ty::BoundSync) => {\n-                try!(self.assemble_candidates_from_impls(obligation, &mut candidates));\n-\n-                // No explicit impls were declared for this type, consider the fallback rules.\n-                if candidates.vec.is_empty() && !candidates.ambiguous {\n-                    try!(self.assemble_builtin_bound_candidates(bound, stack, &mut candidates));\n-                }\n-            }\n-\n             Some(bound @ ty::BoundSized) => {\n-                // Sized and Copy are always automatically computed.\n+                // Sized is never implementable by end-users, it is\n+                // always automatically computed.\n                 try!(self.assemble_builtin_bound_candidates(bound, stack, &mut candidates));\n             }\n \n+            Some(ty::BoundSend) |\n+            Some(ty::BoundSync) |\n             None => {\n-                // For the time being, we ignore user-defined impls for builtin-bounds, other than\n-                // `Copy`.\n-                // (And unboxed candidates only apply to the Fn/FnMut/etc traits.)\n                 try!(self.assemble_closure_candidates(obligation, &mut candidates));\n                 try!(self.assemble_fn_pointer_candidates(obligation, &mut candidates));\n                 try!(self.assemble_candidates_from_impls(obligation, &mut candidates));\n@@ -852,6 +848,11 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n         self.assemble_candidates_from_projected_tys(obligation, &mut candidates);\n         try!(self.assemble_candidates_from_caller_bounds(stack, &mut candidates));\n+        // Default implementations have lower priority, so we only\n+        // consider triggering a default if there is no other impl that can apply.\n+        if candidates.vec.len() == 0 {\n+            try!(self.assemble_candidates_from_default_impls(obligation, &mut candidates));\n+        }\n         debug!(\"candidate list size: {}\", candidates.vec.len());\n         Ok(candidates)\n     }\n@@ -1131,7 +1132,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         let self_ty = self.infcx.shallow_resolve(obligation.self_ty());\n         debug!(\"assemble_candidates_from_impls(self_ty={})\", self_ty.repr(self.tcx()));\n \n-        let all_impls = self.all_impls(obligation.predicate.def_id());\n+        let def_id = obligation.predicate.def_id();\n+        let all_impls = self.all_impls(def_id);\n         for &impl_def_id in &all_impls {\n             self.infcx.probe(|snapshot| {\n                 let (skol_obligation_trait_pred, skol_map) =\n@@ -1145,6 +1147,65 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 }\n             });\n         }\n+\n+        Ok(())\n+    }\n+\n+    fn assemble_candidates_from_default_impls(&mut self,\n+                                              obligation: &TraitObligation<'tcx>,\n+                                              candidates: &mut SelectionCandidateSet<'tcx>)\n+                                              -> Result<(), SelectionError<'tcx>>\n+    {\n+\n+        let self_ty = self.infcx.shallow_resolve(obligation.self_ty());\n+        debug!(\"assemble_candidates_from_default_impls(self_ty={})\", self_ty.repr(self.tcx()));\n+\n+        let def_id = obligation.predicate.def_id();\n+\n+        if ty::trait_has_default_impl(self.tcx(), def_id) {\n+            match self_ty.sty {\n+                ty::ty_trait(..) |\n+                ty::ty_param(..) |\n+                ty::ty_projection(..) => {\n+                    // In these cases, we don't know what the actual\n+                    // type is.  Therefore, we cannot break it down\n+                    // into its constituent types. So we don't\n+                    // consider the `..` impl but instead just add no\n+                    // candidates: this means that typeck will only\n+                    // succeed if there is another reason to believe\n+                    // that this obligation holds. That could be a\n+                    // where-clause or, in the case of an object type,\n+                    // it could be that the object type lists the\n+                    // trait (e.g. `Foo+Send : Send`). See\n+                    // `compile-fail/typeck-default-trait-impl-send-param.rs`\n+                    // for an example of a test case that exercises\n+                    // this path.\n+                }\n+                ty::ty_infer(ty::TyVar(_)) => {\n+                    // the defaulted impl might apply, we don't know\n+                    candidates.ambiguous = true;\n+                }\n+                _ => {\n+                    if self.constituent_types_for_ty(self_ty).is_some() {\n+                        candidates.vec.push(DefaultImplCandidate(def_id.clone()))\n+                    } else {\n+                        // We don't yet know what the constituent\n+                        // types are. So call it ambiguous for now,\n+                        // though this is a bit stronger than\n+                        // necessary: that is, we know that the\n+                        // defaulted impl applies, but we can't\n+                        // process the confirmation step without\n+                        // knowing the constituent types. (Anyway, in\n+                        // the particular case of defaulted impls, it\n+                        // doesn't really matter much either way,\n+                        // since we won't be aiding inference by\n+                        // processing the confirmation step.)\n+                        candidates.ambiguous = true;\n+                    }\n+                }\n+            }\n+        }\n+\n         Ok(())\n     }\n \n@@ -1171,6 +1232,18 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n         let poly_trait_ref = match self_ty.sty {\n             ty::ty_trait(ref data) => {\n+                match self.tcx().lang_items.to_builtin_kind(obligation.predicate.def_id()) {\n+                    Some(bound @ ty::BoundSend) | Some(bound @ ty::BoundSync) => {\n+                        if data.bounds.builtin_bounds.contains(&bound) {\n+                            debug!(\"assemble_candidates_from_object_ty: matched builtin bound, \\\n+                            pushing candidate\");\n+                            candidates.vec.push(BuiltinObjectCandidate);\n+                            return;\n+                        }\n+                    }\n+                    _ => {}\n+                }\n+\n                 data.principal_trait_ref_with_self_ty(self.tcx(), self_ty)\n             }\n             ty::ty_infer(ty::TyVar(_)) => {\n@@ -1258,6 +1331,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             (&ImplCandidate(..), &ParamCandidate(..)) |\n             (&ClosureCandidate(..), &ParamCandidate(..)) |\n             (&FnPointerCandidate(..), &ParamCandidate(..)) |\n+            (&BuiltinObjectCandidate(..), &ParamCandidate(_)) |\n             (&BuiltinCandidate(..), &ParamCandidate(..)) => {\n                 // We basically prefer always prefer to use a\n                 // where-clause over another option. Where clauses\n@@ -1267,6 +1341,12 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 // #18453.\n                 true\n             }\n+            (&DefaultImplCandidate(_), _) => {\n+                // Prefer other candidates over default implementations.\n+                self.tcx().sess.bug(\n+                    \"default implementations shouldn't be recorded \\\n+                     when there are other valid candidates\");\n+            }\n             (&ProjectionCandidate, &ParamCandidate(_)) => {\n                 // FIXME(#20297) -- this gives where clauses precedent\n                 // over projections. Really these are just two means\n@@ -1341,7 +1421,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 Ok(If(Vec::new()))\n             }\n \n-            ty::ty_uniq(referent_ty) => {  // Box<T>\n+            ty::ty_uniq(_) => {  // Box<T>\n                 match bound {\n                     ty::BoundCopy => {\n                         Err(Unimplemented)\n@@ -1351,24 +1431,20 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                         Ok(If(Vec::new()))\n                     }\n \n-                    ty::BoundSync |\n-                    ty::BoundSend => {\n-                        Ok(If(vec![referent_ty]))\n+                    ty::BoundSync | ty::BoundSend => {\n+                        self.tcx().sess.bug(\"Send/Sync shouldn't occur in builtin_bounds()\");\n                     }\n                 }\n             }\n \n             ty::ty_ptr(..) => {     // *const T, *mut T\n                 match bound {\n-                    ty::BoundCopy |\n-                    ty::BoundSized => {\n+                    ty::BoundCopy | ty::BoundSized => {\n                         Ok(If(Vec::new()))\n                     }\n \n-                    ty::BoundSync |\n-                    ty::BoundSend => {\n-                        // sync and send are not implemented for *const, *mut\n-                        Err(Unimplemented)\n+                    ty::BoundSync | ty::BoundSend => {\n+                        self.tcx().sess.bug(\"Send/Sync shouldn't occur in builtin_bounds()\");\n                     }\n                 }\n             }\n@@ -1378,7 +1454,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                     ty::BoundSized => {\n                         Err(Unimplemented)\n                     }\n-                    ty::BoundCopy | ty::BoundSync | ty::BoundSend => {\n+                    ty::BoundCopy => {\n                         if data.bounds.builtin_bounds.contains(&bound) {\n                             Ok(If(Vec::new()))\n                         } else {\n@@ -1397,10 +1473,13 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                             Err(Unimplemented)\n                         }\n                     }\n+                    ty::BoundSync | ty::BoundSend => {\n+                        self.tcx().sess.bug(\"Send/Sync shouldn't occur in builtin_bounds()\");\n+                    }\n                 }\n             }\n \n-            ty::ty_rptr(_, ty::mt { ty: referent_ty, mutbl }) => {\n+            ty::ty_rptr(_, ty::mt { ty: _, mutbl }) => {\n                 // &mut T or &T\n                 match bound {\n                     ty::BoundCopy => {\n@@ -1421,9 +1500,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                         Ok(If(Vec::new()))\n                     }\n \n-                    ty::BoundSync |\n-                    ty::BoundSend => {\n-                        Ok(If(vec![referent_ty]))\n+                    ty::BoundSync | ty::BoundSend => {\n+                        self.tcx().sess.bug(\"Send/Sync shouldn't occur in builtin_bounds()\");\n                     }\n                 }\n             }\n@@ -1452,23 +1530,20 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                         }\n                     }\n \n-                    ty::BoundSync |\n-                    ty::BoundSend => {\n-                        Ok(If(vec![element_ty]))\n+                    ty::BoundSync | ty::BoundSend => {\n+                        self.tcx().sess.bug(\"Send/Sync shouldn't occur in builtin_bounds()\");\n                     }\n                 }\n             }\n \n             ty::ty_str => {\n                 // Equivalent to [u8]\n                 match bound {\n-                    ty::BoundSync |\n-                    ty::BoundSend => {\n-                        Ok(If(Vec::new()))\n+                    ty::BoundSync | ty::BoundSend => {\n+                        self.tcx().sess.bug(\"Send/Sync shouldn't occur in builtin_bounds()\");\n                     }\n \n-                    ty::BoundCopy |\n-                    ty::BoundSized => {\n+                    ty::BoundCopy | ty::BoundSized => {\n                         Err(Unimplemented)\n                     }\n                 }\n@@ -1521,7 +1596,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                     ty::struct_fields(self.tcx(), def_id, substs).iter()\n                                                                  .map(|f| f.mt.ty)\n                                                                  .collect();\n-                nominal(self, bound, def_id, types)\n+                nominal(bound, types)\n             }\n \n             ty::ty_enum(def_id, substs) => {\n@@ -1531,7 +1606,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                     .flat_map(|variant| variant.args.iter())\n                     .cloned()\n                     .collect();\n-                nominal(self, bound, def_id, types)\n+                nominal(bound, types)\n             }\n \n             ty::ty_projection(_) |\n@@ -1556,15 +1631,18 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 // \"opened\" unsized/existential type (one that has\n                 // been dereferenced)\n                 match bound {\n-                    ty::BoundCopy |\n-                    ty::BoundSync |\n-                    ty::BoundSend => {\n+                    ty::BoundCopy => {\n                         Ok(If(vec!(ty)))\n                     }\n \n                     ty::BoundSized => {\n                         Err(Unimplemented)\n                     }\n+\n+                    ty::BoundSync |\n+                    ty::BoundSend => {\n+                        self.tcx().sess.bug(\"Send/Sync shouldn't occur in builtin_bounds()\");\n+                    }\n                 }\n             }\n             ty::ty_err => {\n@@ -1580,38 +1658,108 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             }\n         };\n \n-        fn nominal<'cx, 'tcx>(this: &mut SelectionContext<'cx, 'tcx>,\n-                              bound: ty::BuiltinBound,\n-                              def_id: ast::DefId,\n+        fn nominal<'cx, 'tcx>(bound: ty::BuiltinBound,\n                               types: Vec<Ty<'tcx>>)\n                               -> Result<BuiltinBoundConditions<'tcx>,SelectionError<'tcx>>\n         {\n             // First check for markers and other nonsense.\n-            let tcx = this.tcx();\n             match bound {\n-                ty::BoundSend => {\n-                    if Some(def_id) == tcx.lang_items.managed_bound() {\n-                        return Err(Unimplemented)\n-                    }\n-                }\n+                // Fallback to whatever user-defined impls exist in this case.\n+                ty::BoundCopy => Ok(ParameterBuiltin),\n \n-                ty::BoundCopy => {\n-                    return Ok(ParameterBuiltin)\n-                }\n+                // Sized if all the component types are sized.\n+                ty::BoundSized => Ok(If(types)),\n+\n+                // Shouldn't be coming through here.\n+                ty::BoundSend | ty::BoundSync => unreachable!(),\n+            }\n+        }\n+    }\n+\n+    /// For default impls, we need to break apart a type into its\n+    /// \"constituent types\" -- meaning, the types that it contains.\n+    ///\n+    /// Here are some (simple) examples:\n+    ///\n+    /// ```\n+    /// (i32, u32) -> [i32, u32]\n+    /// Foo where struct Foo { x: i32, y: u32 } -> [i32, u32]\n+    /// Bar<i32> where struct Bar<T> { x: T, y: u32 } -> [i32, u32]\n+    /// Zed<i32> where enum Zed { A(T), B(u32) } -> [i32, u32]\n+    /// ```\n+    fn constituent_types_for_ty(&self, t: Ty<'tcx>) -> Option<Vec<Ty<'tcx>>> {\n+        match t.sty {\n+            ty::ty_uint(_) |\n+            ty::ty_int(_) |\n+            ty::ty_bool |\n+            ty::ty_float(_) |\n+            ty::ty_bare_fn(..) |\n+            ty::ty_str |\n+            ty::ty_err |\n+            ty::ty_infer(ty::IntVar(_)) |\n+            ty::ty_infer(ty::FloatVar(_)) |\n+            ty::ty_char => {\n+                Some(Vec::new())\n+            }\n+\n+            ty::ty_trait(..) |\n+            ty::ty_param(..) |\n+            ty::ty_projection(..) |\n+            ty::ty_infer(ty::TyVar(_)) |\n+            ty::ty_infer(ty::FreshTy(_)) |\n+            ty::ty_infer(ty::FreshIntTy(_)) => {\n+                self.tcx().sess.bug(\n+                    &format!(\n+                        \"asked to assemble constituent types of unexpected type: {}\",\n+                        t.repr(self.tcx()))[]);\n+            }\n+\n+            ty::ty_uniq(referent_ty) => {  // Box<T>\n+                Some(vec![referent_ty])\n+            }\n+\n+            ty::ty_open(element_ty) => {Some(vec![element_ty])},\n+\n+            ty::ty_ptr(ty::mt { ty: element_ty, ..}) |\n+            ty::ty_rptr(_, ty::mt { ty: element_ty, ..}) => {\n+                Some(vec![element_ty])\n+            },\n \n-                ty::BoundSync => {\n-                    if\n-                        Some(def_id) == tcx.lang_items.managed_bound() ||\n-                        Some(def_id) == tcx.lang_items.unsafe_cell_type()\n-                    {\n-                        return Err(Unimplemented)\n+            ty::ty_vec(element_ty, _) => {\n+                Some(vec![element_ty])\n+            }\n+\n+            ty::ty_tup(ref tys) => {\n+                // (T1, ..., Tn) -- meets any bound that all of T1...Tn meet\n+                Some(tys.clone())\n+            }\n+\n+            ty::ty_closure(def_id, _, substs) => {\n+                assert_eq!(def_id.krate, ast::LOCAL_CRATE);\n+\n+                match self.closure_typer.closure_upvars(def_id, substs) {\n+                    Some(upvars) => {\n+                        Some(upvars.iter().map(|c| c.ty).collect())\n+                    }\n+                    None => {\n+                        None\n                     }\n                 }\n+            }\n \n-                ty::BoundSized => { }\n+            ty::ty_struct(def_id, substs) => {\n+                Some(ty::struct_fields(self.tcx(), def_id, substs).iter()\n+                     .map(|f| f.mt.ty)\n+                     .collect())\n             }\n \n-            Ok(If(types))\n+            ty::ty_enum(def_id, substs) => {\n+                Some(ty::substd_enum_variants(self.tcx(), def_id, substs)\n+                     .iter()\n+                     .flat_map(|variant| variant.args.iter())\n+                     .map(|&ty| ty)\n+                     .collect())\n+            }\n         }\n     }\n \n@@ -1647,6 +1795,11 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 Ok(VtableParam(obligations))\n             }\n \n+            DefaultImplCandidate(trait_def_id) => {\n+                let data = try!(self.confirm_default_impl_candidate(obligation, trait_def_id));\n+                Ok(VtableDefaultImpl(data))\n+            }\n+\n             ImplCandidate(impl_def_id) => {\n                 let vtable_impl =\n                     try!(self.confirm_impl_candidate(obligation, impl_def_id));\n@@ -1658,6 +1811,15 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 Ok(VtableClosure(closure_def_id, substs))\n             }\n \n+            BuiltinObjectCandidate => {\n+                // This indicates something like `(Trait+Send) :\n+                // Send`. In this case, we know that this holds\n+                // because that's what the object type is telling us,\n+                // and there's really no additional obligations to\n+                // prove and no types in particular to unify etc.\n+                Ok(VtableParam(Vec::new()))\n+            }\n+\n             ObjectCandidate => {\n                 let data = self.confirm_object_candidate(obligation);\n                 Ok(VtableObject(data))\n@@ -1779,6 +1941,99 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         VtableBuiltinData { nested: obligations }\n     }\n \n+    /// This handles the case where a `impl Foo for ..` impl is being used.\n+    /// The idea is that the impl applies to `X : Foo` if the following conditions are met:\n+    ///\n+    /// 1. For each constituent type `Y` in `X`, `Y : Foo` holds\n+    /// 2. For each where-clause `C` declared on `Foo`, `[Self => X] C` holds.\n+    fn confirm_default_impl_candidate(&mut self,\n+                                      obligation: &TraitObligation<'tcx>,\n+                                      impl_def_id: ast::DefId)\n+                              -> Result<VtableDefaultImplData<PredicateObligation<'tcx>>,\n+                                        SelectionError<'tcx>>\n+    {\n+        debug!(\"confirm_default_impl_candidate({}, {})\",\n+               obligation.repr(self.tcx()),\n+               impl_def_id.repr(self.tcx()));\n+\n+        let self_ty = self.infcx.shallow_resolve(obligation.predicate.0.self_ty());\n+        match self.constituent_types_for_ty(self_ty) {\n+            Some(types) => {\n+                Ok(self.vtable_default_impl(obligation, impl_def_id, types))\n+            }\n+            None => {\n+                self.tcx().sess.bug(\n+                    &format!(\n+                        \"asked to confirm default implementation for ambiguous type: {}\",\n+                        self_ty.repr(self.tcx()))[]);\n+            }\n+        }\n+    }\n+\n+    /// See `confirm_default_impl_candidate`\n+    fn vtable_default_impl(&mut self,\n+                           obligation: &TraitObligation<'tcx>,\n+                           trait_def_id: ast::DefId,\n+                           nested: Vec<Ty<'tcx>>)\n+                           -> VtableDefaultImplData<PredicateObligation<'tcx>>\n+    {\n+        let derived_cause = self.derived_cause(obligation, ImplDerivedObligation);\n+\n+        let obligations = nested.iter().map(|&nested_ty| {\n+            // the obligation might be higher-ranked, e.g. for<'a> &'a\n+            // int : Copy. In that case, we will wind up with\n+            // late-bound regions in the `nested` vector. So for each\n+            // one we instantiate to a skolemized region, do our work\n+            // to produce something like `&'0 int : Copy`, and then\n+            // re-bind it. This is a bit of busy-work but preserves\n+            // the invariant that we only manipulate free regions, not\n+            // bound ones.\n+            self.infcx.try(|snapshot| {\n+                let (skol_ty, skol_map) =\n+                    self.infcx().skolemize_late_bound_regions(&ty::Binder(nested_ty), snapshot);\n+                let skol_predicate =\n+                    util::predicate_for_default_trait_impl(\n+                        self.tcx(),\n+                        derived_cause.clone(),\n+                        trait_def_id,\n+                        obligation.recursion_depth + 1,\n+                        skol_ty);\n+                match skol_predicate {\n+                    Ok(skol_predicate) => Ok(self.infcx().plug_leaks(skol_map, snapshot,\n+                                                                     &skol_predicate)),\n+                    Err(ErrorReported) => Err(ErrorReported)\n+                }\n+            })\n+        }).collect::<Result<_, _>>();\n+\n+        let mut obligations = match obligations {\n+            Ok(o) => o,\n+            Err(ErrorReported) => Vec::new()\n+        };\n+\n+        let _: Result<(),()> = self.infcx.try(|snapshot| {\n+            let (_, skol_map) =\n+                self.infcx().skolemize_late_bound_regions(&obligation.predicate, snapshot);\n+\n+            let substs = obligation.predicate.to_poly_trait_ref().substs();\n+            let trait_obligations = self.impl_or_trait_obligations(obligation.cause.clone(),\n+                                                                   obligation.recursion_depth + 1,\n+                                                                   trait_def_id,\n+                                                                   substs,\n+                                                                   skol_map,\n+                                                                   snapshot);\n+            obligations.push_all(trait_obligations.as_slice());\n+            Ok(())\n+        });\n+\n+        debug!(\"vtable_default_impl_data: obligations={}\", obligations.repr(self.tcx()));\n+\n+        VtableDefaultImplData {\n+            trait_def_id: trait_def_id,\n+            nested: obligations\n+        }\n+    }\n+\n     fn confirm_impl_candidate(&mut self,\n                               obligation: &TraitObligation<'tcx>,\n                               impl_def_id: ast::DefId)\n@@ -1819,12 +2074,12 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                skol_map.repr(self.tcx()));\n \n         let mut impl_obligations =\n-            self.impl_obligations(cause,\n-                                 recursion_depth,\n-                                 impl_def_id,\n-                                 &substs.value,\n-                                 skol_map,\n-                                 snapshot);\n+            self.impl_or_trait_obligations(cause,\n+                                           recursion_depth,\n+                                           impl_def_id,\n+                                           &substs.value,\n+                                           skol_map,\n+                                           snapshot);\n \n         debug!(\"vtable_impl: impl_def_id={} impl_obligations={}\",\n                impl_def_id.repr(self.tcx()),\n@@ -2244,28 +2499,30 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         ty::Binder(trait_ref)\n     }\n \n-    fn impl_obligations(&mut self,\n-                        cause: ObligationCause<'tcx>,\n-                        recursion_depth: uint,\n-                        impl_def_id: ast::DefId,\n-                        impl_substs: &Substs<'tcx>,\n-                        skol_map: infer::SkolemizationMap,\n-                        snapshot: &infer::CombinedSnapshot)\n-                        -> VecPerParamSpace<PredicateObligation<'tcx>>\n+    /// Returns the obligations that are implied by instantiating an\n+    /// impl or trait. The obligations are substituted and fully\n+    /// normalized. This is used when confirming an impl or default\n+    /// impl.\n+    fn impl_or_trait_obligations(&mut self,\n+                                 cause: ObligationCause<'tcx>,\n+                                 recursion_depth: uint,\n+                                 def_id: ast::DefId, // of impl or trait\n+                                 substs: &Substs<'tcx>, // for impl or trait\n+                                 skol_map: infer::SkolemizationMap,\n+                                 snapshot: &infer::CombinedSnapshot)\n+                                 -> VecPerParamSpace<PredicateObligation<'tcx>>\n     {\n-        let impl_bounds = ty::lookup_predicates(self.tcx(), impl_def_id);\n-        let bounds = impl_bounds.instantiate(self.tcx(), impl_substs);\n-        let normalized_bounds =\n-            project::normalize_with_depth(self, cause.clone(), recursion_depth, &bounds);\n-        let normalized_bounds =\n-            self.infcx().plug_leaks(skol_map, snapshot, &normalized_bounds);\n-        let mut impl_obligations =\n+        let predicates = ty::lookup_predicates(self.tcx(), def_id);\n+        let predicates = predicates.instantiate(self.tcx(), substs);\n+        let predicates = normalize_with_depth(self, cause.clone(), recursion_depth, &predicates);\n+        let predicates = self.infcx().plug_leaks(skol_map, snapshot, &predicates);\n+        let mut obligations =\n             util::predicates_for_generics(self.tcx(),\n                                           cause,\n                                           recursion_depth,\n-                                          &normalized_bounds.value);\n-        impl_obligations.extend(TypeSpace, normalized_bounds.obligations.into_iter());\n-        impl_obligations\n+                                          &predicates.value);\n+        obligations.extend(TypeSpace, predicates.obligations.into_iter());\n+        obligations\n     }\n \n     #[allow(unused_comparisons)]\n@@ -2307,8 +2564,10 @@ impl<'tcx> Repr<'tcx> for SelectionCandidate<'tcx> {\n             PhantomFnCandidate => format!(\"PhantomFnCandidate\"),\n             ErrorCandidate => format!(\"ErrorCandidate\"),\n             BuiltinCandidate(b) => format!(\"BuiltinCandidate({:?})\", b),\n+            BuiltinObjectCandidate => format!(\"BuiltinObjectCandidate\"),\n             ParamCandidate(ref a) => format!(\"ParamCandidate({})\", a.repr(tcx)),\n             ImplCandidate(a) => format!(\"ImplCandidate({})\", a.repr(tcx)),\n+            DefaultImplCandidate(t) => format!(\"DefaultImplCandidate({:?})\", t),\n             ProjectionCandidate => format!(\"ProjectionCandidate\"),\n             FnPointerCandidate => format!(\"FnPointerCandidate\"),\n             ObjectCandidate => {"}, {"sha": "9b462e6be60dd57bf2b80d46fd57a1ea120344a8", "filename": "src/librustc/middle/traits/util.rs", "status": "modified", "additions": 42, "deletions": 6, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/2890508d97af287a136ac50ffa13a1c0a3e32e4e/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2890508d97af287a136ac50ffa13a1c0a3e32e4e/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs?ref=2890508d97af287a136ac50ffa13a1c0a3e32e4e", "patch": "@@ -20,7 +20,7 @@ use util::nodemap::FnvHashSet;\n use util::ppaux::Repr;\n \n use super::{Obligation, ObligationCause, PredicateObligation,\n-            VtableImpl, VtableParam, VtableImplData};\n+            VtableImpl, VtableParam, VtableImplData, VtableDefaultImplData};\n \n struct PredicateSet<'a,'tcx:'a> {\n     tcx: &'a ty::ctxt<'tcx>,\n@@ -323,6 +323,35 @@ pub fn trait_ref_for_builtin_bound<'tcx>(\n     }\n }\n \n+\n+pub fn predicate_for_trait_ref<'tcx>(\n+    cause: ObligationCause<'tcx>,\n+    trait_ref: Rc<ty::TraitRef<'tcx>>,\n+    recursion_depth: uint)\n+    -> Result<PredicateObligation<'tcx>, ErrorReported>\n+{\n+    Ok(Obligation {\n+        cause: cause,\n+        recursion_depth: recursion_depth,\n+        predicate: trait_ref.as_predicate(),\n+    })\n+}\n+\n+pub fn predicate_for_default_trait_impl<'tcx>(\n+    tcx: &ty::ctxt<'tcx>,\n+    cause: ObligationCause<'tcx>,\n+    trait_def_id: ast::DefId,\n+    recursion_depth: uint,\n+    param_ty: Ty<'tcx>)\n+    -> Result<PredicateObligation<'tcx>, ErrorReported>\n+{\n+    let trait_ref = Rc::new(ty::TraitRef {\n+        def_id: trait_def_id,\n+        substs: tcx.mk_substs(Substs::empty().with_self_ty(param_ty))\n+    });\n+    predicate_for_trait_ref(cause, trait_ref, recursion_depth)\n+}\n+\n pub fn predicate_for_builtin_bound<'tcx>(\n     tcx: &ty::ctxt<'tcx>,\n     cause: ObligationCause<'tcx>,\n@@ -332,11 +361,7 @@ pub fn predicate_for_builtin_bound<'tcx>(\n     -> Result<PredicateObligation<'tcx>, ErrorReported>\n {\n     let trait_ref = try!(trait_ref_for_builtin_bound(tcx, builtin_bound, param_ty));\n-    Ok(Obligation {\n-        cause: cause,\n-        recursion_depth: recursion_depth,\n-        predicate: trait_ref.as_predicate(),\n-    })\n+    predicate_for_trait_ref(cause, trait_ref, recursion_depth)\n }\n \n /// Cast a trait reference into a reference to one of its super\n@@ -444,6 +469,9 @@ impl<'tcx, N:Repr<'tcx>> Repr<'tcx> for super::Vtable<'tcx, N> {\n             super::VtableImpl(ref v) =>\n                 v.repr(tcx),\n \n+            super::VtableDefaultImpl(ref t) =>\n+                t.repr(tcx),\n+\n             super::VtableClosure(ref d, ref s) =>\n                 format!(\"VtableClosure({},{})\",\n                         d.repr(tcx),\n@@ -483,6 +511,14 @@ impl<'tcx, N:Repr<'tcx>> Repr<'tcx> for super::VtableBuiltinData<N> {\n     }\n }\n \n+impl<'tcx, N:Repr<'tcx>> Repr<'tcx> for super::VtableDefaultImplData<N> {\n+    fn repr(&self, tcx: &ty::ctxt<'tcx>) -> String {\n+        format!(\"VtableDefaultImplData(trait_def_id={}, nested={})\",\n+                self.trait_def_id.repr(tcx),\n+                self.nested.repr(tcx))\n+    }\n+}\n+\n impl<'tcx> Repr<'tcx> for super::VtableObjectData<'tcx> {\n     fn repr(&self, tcx: &ty::ctxt<'tcx>) -> String {\n         format!(\"VtableObject(object_ty={})\","}, {"sha": "a461297dd95534b3cff50054f351dc97894a9f9a", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 47, "deletions": 3, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/2890508d97af287a136ac50ffa13a1c0a3e32e4e/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2890508d97af287a136ac50ffa13a1c0a3e32e4e/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=2890508d97af287a136ac50ffa13a1c0a3e32e4e", "patch": "@@ -756,6 +756,9 @@ pub struct ctxt<'tcx> {\n     /// Maps a trait onto a list of impls of that trait.\n     pub trait_impls: RefCell<DefIdMap<Rc<RefCell<Vec<ast::DefId>>>>>,\n \n+    /// Maps a trait onto a list of *default* trait implementations\n+    default_trait_impls: RefCell<DefIdMap<ast::DefId>>,\n+\n     /// Maps a DefId of a type to a list of its inherent impls.\n     /// Contains implementations of methods that are inherent to a type.\n     /// Methods in these implementations don't need to be exported.\n@@ -2478,6 +2481,7 @@ pub fn mk_ctxt<'tcx>(s: Session,\n         destructor_for_type: RefCell::new(DefIdMap()),\n         destructors: RefCell::new(DefIdSet()),\n         trait_impls: RefCell::new(DefIdMap()),\n+        default_trait_impls: RefCell::new(DefIdMap()),\n         inherent_impls: RefCell::new(DefIdMap()),\n         impl_items: RefCell::new(DefIdMap()),\n         used_unsafe: RefCell::new(NodeSet()),\n@@ -5156,6 +5160,9 @@ pub fn impl_trait_ref<'tcx>(cx: &ctxt<'tcx>, id: ast::DefId)\n                                 &None => None\n                             }\n                         }\n+                        ast::ItemDefaultImpl(_, ref ast_trait_ref) => {\n+                            Some(ty::node_id_to_trait_ref(cx, ast_trait_ref.ref_id))\n+                        }\n                         _ => None\n                     }\n                 }\n@@ -5977,6 +5984,32 @@ pub fn item_variances(tcx: &ctxt, item_id: ast::DefId) -> Rc<ItemVariances> {\n         || Rc::new(csearch::get_item_variances(&tcx.sess.cstore, item_id)))\n }\n \n+pub fn trait_default_impl(tcx: &ctxt, trait_def_id: DefId) -> Option<ast::DefId> {\n+    match tcx.default_trait_impls.borrow().get(&trait_def_id) {\n+        Some(id) => Some(*id),\n+        None => None\n+    }\n+}\n+\n+pub fn trait_has_default_impl(tcx: &ctxt, trait_def_id: DefId) -> bool {\n+    match tcx.lang_items.to_builtin_kind(trait_def_id) {\n+        Some(BoundSend) | Some(BoundSync) => true,\n+        _ => tcx.default_trait_impls.borrow().contains_key(&trait_def_id)\n+    }\n+}\n+\n+/// Records a trait-to-implementation mapping.\n+pub fn record_default_trait_implementation(tcx: &ctxt,\n+                                           trait_def_id: DefId,\n+                                           impl_def_id: DefId) {\n+\n+    // We're using the latest implementation found as the reference one.\n+    // Duplicated implementations are caught and reported in the coherence\n+    // step.\n+    tcx.default_trait_impls.borrow_mut().insert(trait_def_id, impl_def_id);\n+}\n+\n+\n /// Records a trait-to-implementation mapping.\n pub fn record_trait_implementation(tcx: &ctxt,\n                                    trait_def_id: DefId,\n@@ -6059,11 +6092,22 @@ pub fn populate_implementations_for_trait_if_necessary(\n     }\n \n     csearch::each_implementation_for_trait(&tcx.sess.cstore, trait_id,\n-            |implementation_def_id| {\n+            |implementation_def_id|{\n         let impl_items = csearch::get_impl_items(&tcx.sess.cstore, implementation_def_id);\n \n-        // Record the trait->implementation mapping.\n-        record_trait_implementation(tcx, trait_id, implementation_def_id);\n+        if csearch::is_default_trait(&tcx.sess.cstore, implementation_def_id) {\n+            record_default_trait_implementation(tcx, trait_id,\n+                                                implementation_def_id);\n+            tcx.populated_external_traits.borrow_mut().insert(trait_id);\n+\n+            // Nothing else to do for default trait implementations since\n+            // they are not allowed to have type parameters, methods, or any\n+            // other item that could be associated to a trait implementation.\n+            return;\n+        } else {\n+            // Record the trait->implementation mapping.\n+            record_trait_implementation(tcx, trait_id, implementation_def_id);\n+        }\n \n         // For any methods that use a default implementation, add them to\n         // the map. This is a bit unfortunate."}, {"sha": "92b0ea905accf96e1dc831ce3fec05ec333e9dd9", "filename": "src/librustc/middle/ty_fold.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2890508d97af287a136ac50ffa13a1c0a3e32e4e/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2890508d97af287a136ac50ffa13a1c0a3e32e4e/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty_fold.rs?ref=2890508d97af287a136ac50ffa13a1c0a3e32e4e", "patch": "@@ -507,6 +507,15 @@ impl<'tcx, N: TypeFoldable<'tcx>> TypeFoldable<'tcx> for traits::VtableImplData<\n     }\n }\n \n+impl<'tcx, N: TypeFoldable<'tcx>> TypeFoldable<'tcx> for traits::VtableDefaultImplData<N> {\n+    fn fold_with<F:TypeFolder<'tcx>>(&self, folder: &mut F) -> traits::VtableDefaultImplData<N> {\n+        traits::VtableDefaultImplData {\n+            trait_def_id: self.trait_def_id,\n+            nested: self.nested.fold_with(folder),\n+        }\n+    }\n+}\n+\n impl<'tcx, N: TypeFoldable<'tcx>> TypeFoldable<'tcx> for traits::VtableBuiltinData<N> {\n     fn fold_with<F:TypeFolder<'tcx>>(&self, folder: &mut F) -> traits::VtableBuiltinData<N> {\n         traits::VtableBuiltinData {\n@@ -519,6 +528,7 @@ impl<'tcx, N: TypeFoldable<'tcx>> TypeFoldable<'tcx> for traits::Vtable<'tcx, N>\n     fn fold_with<F:TypeFolder<'tcx>>(&self, folder: &mut F) -> traits::Vtable<'tcx, N> {\n         match *self {\n             traits::VtableImpl(ref v) => traits::VtableImpl(v.fold_with(folder)),\n+            traits::VtableDefaultImpl(ref t) => traits::VtableDefaultImpl(t.fold_with(folder)),\n             traits::VtableClosure(d, ref s) => {\n                 traits::VtableClosure(d, s.fold_with(folder))\n             }"}, {"sha": "cdcc9850e423e3477d919246999a3deb5c2ee943", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2890508d97af287a136ac50ffa13a1c0a3e32e4e/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2890508d97af287a136ac50ffa13a1c0a3e32e4e/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=2890508d97af287a136ac50ffa13a1c0a3e32e4e", "patch": "@@ -206,7 +206,7 @@ impl<'a, 'tcx> Env<'a, 'tcx> {\n \n                 ast::ItemEnum(..) | ast::ItemStruct(..) |\n                 ast::ItemTrait(..) | ast::ItemImpl(..) |\n-                ast::ItemMac(..) => {\n+                ast::ItemMac(..) | ast::ItemDefaultImpl(..) => {\n                     None\n                 }\n "}, {"sha": "f0a640aa2e0e2c78a02785b6e723ed06b384ac0e", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2890508d97af287a136ac50ffa13a1c0a3e32e4e/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2890508d97af287a136ac50ffa13a1c0a3e32e4e/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=2890508d97af287a136ac50ffa13a1c0a3e32e4e", "patch": "@@ -209,7 +209,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for EmbargoVisitor<'a, 'tcx> {\n         match item.node {\n             // impls/extern blocks do not break the \"public chain\" because they\n             // cannot have visibility qualifiers on them anyway\n-            ast::ItemImpl(..) | ast::ItemForeignMod(..) => {}\n+            ast::ItemImpl(..) | ast::ItemDefaultImpl(..) | ast::ItemForeignMod(..) => {}\n \n             // Traits are a little special in that even if they themselves are\n             // not public they may still be exported.\n@@ -802,7 +802,7 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n             def::DefVariant(..) => ck(\"variant\"),\n             def::DefTy(_, false) => ck(\"type\"),\n             def::DefTy(_, true) => ck(\"enum\"),\n-            def::DefTrait(..) => ck(\"trait\"),\n+            def::DefaultImpl(..) => ck(\"trait\"),\n             def::DefStruct(..) => ck(\"struct\"),\n             def::DefMethod(_, Some(..), _) => ck(\"trait method\"),\n             def::DefMethod(..) => ck(\"method\"),\n@@ -1145,6 +1145,7 @@ impl<'a, 'tcx> SanePrivacyVisitor<'a, 'tcx> {\n                 }\n             }\n \n+            ast::ItemDefaultImpl(..) |\n             ast::ItemConst(..) | ast::ItemStatic(..) | ast::ItemStruct(..) |\n             ast::ItemFn(..) | ast::ItemMod(..) | ast::ItemTy(..) |\n             ast::ItemExternCrate(_) | ast::ItemUse(_) | ast::ItemMac(..) => {}\n@@ -1204,7 +1205,7 @@ impl<'a, 'tcx> SanePrivacyVisitor<'a, 'tcx> {\n                 }\n             }\n \n-            ast::ItemExternCrate(_) | ast::ItemUse(_) |\n+            ast::ItemDefaultImpl(..) | ast::ItemExternCrate(_) | ast::ItemUse(_) |\n             ast::ItemStatic(..) | ast::ItemConst(..) |\n             ast::ItemFn(..) | ast::ItemMod(..) | ast::ItemTy(..) |\n             ast::ItemMac(..) => {}"}, {"sha": "31f21a84f842b796f416fe356dc9842b012eae8c", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2890508d97af287a136ac50ffa13a1c0a3e32e4e/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2890508d97af287a136ac50ffa13a1c0a3e32e4e/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=2890508d97af287a136ac50ffa13a1c0a3e32e4e", "patch": "@@ -40,7 +40,7 @@ use syntax::ast::{Block, Crate};\n use syntax::ast::{DeclItem, DefId};\n use syntax::ast::{ForeignItem, ForeignItemFn, ForeignItemStatic};\n use syntax::ast::{Item, ItemConst, ItemEnum, ItemExternCrate, ItemFn};\n-use syntax::ast::{ItemForeignMod, ItemImpl, ItemMac, ItemMod, ItemStatic};\n+use syntax::ast::{ItemForeignMod, ItemImpl, ItemMac, ItemMod, ItemStatic, ItemDefaultImpl};\n use syntax::ast::{ItemStruct, ItemTrait, ItemTy, ItemUse};\n use syntax::ast::{MethodImplItem, Name, NamedField, NodeId};\n use syntax::ast::{PathListIdent, PathListMod};\n@@ -656,6 +656,7 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                 parent.clone()\n             }\n \n+            ItemDefaultImpl(_, _) |\n             ItemImpl(_, _, _, Some(_), _, _) => parent.clone(),\n \n             ItemTrait(_, _, _, ref items) => {\n@@ -735,7 +736,7 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                     self.trait_item_map.insert((name, def_id), kind);\n                 }\n \n-                name_bindings.define_type(DefTrait(def_id), sp, modifiers);\n+                name_bindings.define_type(DefaultImpl(def_id), sp, modifiers);\n                 parent.clone()\n             }\n             ItemMac(..) => parent.clone()\n@@ -917,7 +918,7 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n             }\n             child_name_bindings.define_value(def, DUMMY_SP, modifiers);\n           }\n-          DefTrait(def_id) => {\n+          DefaultImpl(def_id) => {\n               debug!(\"(building reduced graph for external \\\n                       crate) building type {}\", final_ident);\n "}, {"sha": "c38b8fc750281f0a6f07f93a836cb6f14a962cef", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/2890508d97af287a136ac50ffa13a1c0a3e32e4e/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2890508d97af287a136ac50ffa13a1c0a3e32e4e/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=2890508d97af287a136ac50ffa13a1c0a3e32e4e", "patch": "@@ -70,7 +70,7 @@ use syntax::ast::{ExprClosure, ExprLoop, ExprWhile, ExprMethodCall};\n use syntax::ast::{ExprPath, ExprQPath, ExprStruct, FnDecl};\n use syntax::ast::{ForeignItemFn, ForeignItemStatic, Generics};\n use syntax::ast::{Ident, ImplItem, Item, ItemConst, ItemEnum, ItemExternCrate};\n-use syntax::ast::{ItemFn, ItemForeignMod, ItemImpl, ItemMac, ItemMod, ItemStatic};\n+use syntax::ast::{ItemFn, ItemForeignMod, ItemImpl, ItemMac, ItemMod, ItemStatic, ItemDefaultImpl};\n use syntax::ast::{ItemStruct, ItemTrait, ItemTy, ItemUse};\n use syntax::ast::{Local, MethodImplItem, Mod, Name, NodeId};\n use syntax::ast::{Pat, PatEnum, PatIdent, PatLit};\n@@ -2840,6 +2840,9 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 });\n             }\n \n+            ItemDefaultImpl(_, ref trait_ref) => {\n+                self.resolve_trait_reference(item.id, trait_ref, TraitImplementation);\n+            }\n             ItemImpl(_, _,\n                      ref generics,\n                      ref implemented_traits,\n@@ -2986,7 +2989,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 // check for imports shadowing primitive types\n                 if let ast::ViewPathSimple(ident, _) = view_path.node {\n                     match self.def_map.borrow().get(&item.id) {\n-                        Some(&DefTy(..)) | Some(&DefStruct(..)) | Some(&DefTrait(..)) | None => {\n+                        Some(&DefTy(..)) | Some(&DefStruct(..)) | Some(&DefaultImpl(..)) | None => {\n                             self.check_if_primitive_type_name(ident.name, item.span);\n                         }\n                         _ => {}\n@@ -3196,7 +3199,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             }\n             Some(def) => {\n                 match def {\n-                    (DefTrait(_), _) => {\n+                    (DefaultImpl(_), _) => {\n                         debug!(\"(resolving trait) found trait def: {:?}\", def);\n                         self.record_def(trait_reference.ref_id, def);\n                     }\n@@ -4672,7 +4675,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                         None => continue\n                     };\n                     let trait_def_id = match def {\n-                        DefTrait(trait_def_id) => trait_def_id,\n+                        DefaultImpl(trait_def_id) => trait_def_id,\n                         _ => continue,\n                     };\n                     if self.trait_item_map.contains_key(&(name, trait_def_id)) {\n@@ -4688,7 +4691,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     Some(target) => target,\n                 };\n                 let did = match target.bindings.def_for_namespace(TypeNS) {\n-                    Some(DefTrait(trait_def_id)) => trait_def_id,\n+                    Some(DefaultImpl(trait_def_id)) => trait_def_id,\n                     Some(..) | None => continue,\n                 };\n                 if self.trait_item_map.contains_key(&(name, did)) {"}, {"sha": "591450a25956466978a6cb51fb5f0c5509e93870", "filename": "src/librustc_trans/save/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2890508d97af287a136ac50ffa13a1c0a3e32e4e/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2890508d97af287a136ac50ffa13a1c0a3e32e4e/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fmod.rs?ref=2890508d97af287a136ac50ffa13a1c0a3e32e4e", "patch": "@@ -239,7 +239,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n             def::DefTy(..) |\n             def::DefAssociatedTy(..) |\n             def::DefAssociatedPath(..) |\n-            def::DefTrait(_) => Some(recorder::TypeRef),\n+            def::DefaultImpl(_) => Some(recorder::TypeRef),\n             def::DefStatic(_, _) |\n             def::DefConst(_) |\n             def::DefLocal(_) |"}, {"sha": "a358a3d89e90c4eedd3e7df3f3a50478768b8c88", "filename": "src/librustc_trans/trans/callee.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2890508d97af287a136ac50ffa13a1c0a3e32e4e/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2890508d97af287a136ac50ffa13a1c0a3e32e4e/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs?ref=2890508d97af287a136ac50ffa13a1c0a3e32e4e", "patch": "@@ -207,7 +207,7 @@ fn trans<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, expr: &ast::Expr)\n             def::DefUpvar(..) => {\n                 datum_callee(bcx, ref_expr)\n             }\n-            def::DefMod(..) | def::DefForeignMod(..) | def::DefTrait(..) |\n+            def::DefMod(..) | def::DefForeignMod(..) | def::DefaultImpl(..) |\n             def::DefTy(..) | def::DefPrimTy(..) | def::DefAssociatedTy(..) |\n             def::DefUse(..) | def::DefTyParamBinder(..) |\n             def::DefRegion(..) | def::DefLabel(..) | def::DefTyParam(..) |"}, {"sha": "7644ecf2cfde69382f0b2c3694390181f5042435", "filename": "src/librustc_trans/trans/meth.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2890508d97af287a136ac50ffa13a1c0a3e32e4e/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2890508d97af287a136ac50ffa13a1c0a3e32e4e/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs?ref=2890508d97af287a136ac50ffa13a1c0a3e32e4e", "patch": "@@ -390,6 +390,7 @@ fn trans_monomorphized_callee<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             Callee { bcx: bcx, data: Fn(llfn) }\n         }\n         traits::VtableBuiltin(..) |\n+        traits::VtableDefaultImpl(..) |\n         traits::VtableParam(..) => {\n             bcx.sess().bug(\n                 &format!(\"resolved vtable bad vtable {} in trans\",\n@@ -714,6 +715,8 @@ pub fn get_vtable<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     let methods = traits::supertraits(tcx, trait_ref.clone()).flat_map(|trait_ref| {\n         let vtable = fulfill_obligation(ccx, DUMMY_SP, trait_ref.clone());\n         match vtable {\n+            // Should default trait error here?\n+            traits::VtableDefaultImpl(_) |\n             traits::VtableBuiltin(_) => {\n                 Vec::new().into_iter()\n             }"}, {"sha": "ff397d994304d4f2a83e5e4b31dc4cccfc3a0284", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2890508d97af287a136ac50ffa13a1c0a3e32e4e/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2890508d97af287a136ac50ffa13a1c0a3e32e4e/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=2890508d97af287a136ac50ffa13a1c0a3e32e4e", "patch": "@@ -617,7 +617,7 @@ pub fn instantiate_trait_ref<'tcx>(\n     -> Rc<ty::TraitRef<'tcx>>\n {\n     match ::lookup_def_tcx(this.tcx(), ast_trait_ref.path.span, ast_trait_ref.ref_id) {\n-        def::DefTrait(trait_def_id) => {\n+        def::DefaultImpl(trait_def_id) => {\n             let trait_ref = ast_path_to_trait_ref(this,\n                                                   rscope,\n                                                   trait_def_id,\n@@ -931,7 +931,7 @@ fn ast_ty_to_trait_ref<'tcx>(this: &AstConv<'tcx>,\n     match ty.node {\n         ast::TyPath(ref path, id) => {\n             match this.tcx().def_map.borrow().get(&id) {\n-                Some(&def::DefTrait(trait_def_id)) => {\n+                Some(&def::DefaultImpl(trait_def_id)) => {\n                     let mut projection_bounds = Vec::new();\n                     let trait_ref = object_path_to_poly_trait_ref(this,\n                                                                   rscope,\n@@ -1211,7 +1211,7 @@ pub fn ast_ty_to_ty<'tcx>(this: &AstConv<'tcx>,\n                     Some(&d) => d\n                 };\n                 match a_def {\n-                    def::DefTrait(trait_def_id) => {\n+                    def::DefaultImpl(trait_def_id) => {\n                         // N.B. this case overlaps somewhat with\n                         // TyObjectSum, see that fn for details\n                         let mut projection_bounds = Vec::new();\n@@ -1821,7 +1821,7 @@ pub fn partition_bounds<'a>(tcx: &ty::ctxt,\n         match *ast_bound {\n             ast::TraitTyParamBound(ref b, ast::TraitBoundModifier::None) => {\n                 match ::lookup_def_tcx(tcx, b.trait_ref.path.span, b.trait_ref.ref_id) {\n-                    def::DefTrait(trait_did) => {\n+                    def::DefaultImpl(trait_did) => {\n                         match trait_def_ids.get(&trait_did) {\n                             // Already seen this trait. We forbid\n                             // duplicates in the list (for some"}, {"sha": "26ba0fe8ed148230054fa8eba805580dcf1baa15", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2890508d97af287a136ac50ffa13a1c0a3e32e4e/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2890508d97af287a136ac50ffa13a1c0a3e32e4e/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=2890508d97af287a136ac50ffa13a1c0a3e32e4e", "patch": "@@ -435,7 +435,7 @@ pub fn check_pat_struct<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>, pat: &'tcx ast::Pat,\n \n     let def = tcx.def_map.borrow()[pat.id].clone();\n     let (enum_def_id, variant_def_id) = match def {\n-        def::DefTrait(_) => {\n+        def::DefaultImpl(_) => {\n             let name = pprust::path_to_string(path);\n             span_err!(tcx.sess, pat.span, E0168,\n                 \"use of trait `{}` in a struct pattern\", name);"}, {"sha": "9b1693cba1e99166c294fe33f484b32e1e218062", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2890508d97af287a136ac50ffa13a1c0a3e32e4e/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2890508d97af287a136ac50ffa13a1c0a3e32e4e/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=2890508d97af287a136ac50ffa13a1c0a3e32e4e", "patch": "@@ -330,7 +330,7 @@ pub fn all_traits<'a>(ccx: &'a CrateCtxt) -> AllTraits<'a> {\n                                cstore: &cstore::CStore,\n                                dl: decoder::DefLike) {\n             match dl {\n-                decoder::DlDef(def::DefTrait(did)) => {\n+                decoder::DlDef(def::DefaultImpl(did)) => {\n                     traits.push(TraitInfo::new(did));\n                 }\n                 decoder::DlDef(def::DefMod(did)) => {"}, {"sha": "81e72ef6326c7d47854486d433623c5f18ce2598", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2890508d97af287a136ac50ffa13a1c0a3e32e4e/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2890508d97af287a136ac50ffa13a1c0a3e32e4e/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=2890508d97af287a136ac50ffa13a1c0a3e32e4e", "patch": "@@ -3862,7 +3862,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                                           variant_id, &fields[..]);\n                 enum_id\n             }\n-            Some(def::DefTrait(def_id)) => {\n+            Some(def::DefaultImpl(def_id)) => {\n                 span_err!(tcx.sess, path.span, E0159,\n                     \"use of trait `{}` as a struct constructor\",\n                     pprust::path_to_string(path));\n@@ -4634,7 +4634,7 @@ fn type_scheme_and_predicates_for_def<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         def::DefStruct(id) | def::DefConst(id) => {\n             (ty::lookup_item_type(fcx.tcx(), id), ty::lookup_predicates(fcx.tcx(), id))\n         }\n-        def::DefTrait(_) |\n+        def::DefaultImpl(_) |\n         def::DefTy(..) |\n         def::DefAssociatedTy(..) |\n         def::DefAssociatedPath(..) |\n@@ -4738,7 +4738,7 @@ pub fn instantiate_path<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         def::DefTy(..) |\n         def::DefAssociatedTy(..) |\n         def::DefAssociatedPath(..) |\n-        def::DefTrait(..) |\n+        def::DefaultImpl(..) |\n         def::DefPrimTy(..) |\n         def::DefTyParam(..) => {\n             // Everything but the final segment should have no"}, {"sha": "399795c66567e3df49861e3ca14a9051d78161ca", "filename": "src/librustc_typeck/check/wf.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/2890508d97af287a136ac50ffa13a1c0a3e32e4e/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2890508d97af287a136ac50ffa13a1c0a3e32e4e/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs?ref=2890508d97af287a136ac50ffa13a1c0a3e32e4e", "patch": "@@ -83,12 +83,15 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n             }\n             ast::ItemImpl(_, ast::ImplPolarity::Negative, _, Some(ref tref), _, _) => {\n                 let trait_ref = ty::node_id_to_trait_ref(ccx.tcx, tref.ref_id);\n+                ty::populate_implementations_for_trait_if_necessary(ccx.tcx, trait_ref.def_id);\n                 match ccx.tcx.lang_items.to_builtin_kind(trait_ref.def_id) {\n                     Some(ty::BoundSend) | Some(ty::BoundSync) => {}\n                     Some(_) | None => {\n-                        span_err!(ccx.tcx.sess, item.span, E0192,\n-                            \"negative impls are currently \\\n-                                     allowed just for `Send` and `Sync`\")\n+                        if !ty::trait_has_default_impl(ccx.tcx, trait_ref.def_id) {\n+                            span_err!(ccx.tcx.sess, item.span, E0192,\n+                                      \"negative impls are only allowed for traits with \\\n+                                       default impls (e.g., `Send` and `Sync`)\")\n+                        }\n                     }\n                 }\n             }"}, {"sha": "d34a16a924f70cb725a542a4744888f728353e8d", "filename": "src/librustc_typeck/coherence/orphan.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2890508d97af287a136ac50ffa13a1c0a3e32e4e/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2890508d97af287a136ac50ffa13a1c0a3e32e4e/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs?ref=2890508d97af287a136ac50ffa13a1c0a3e32e4e", "patch": "@@ -96,6 +96,16 @@ impl<'cx, 'tcx,'v> visit::Visitor<'v> for OrphanChecker<'cx, 'tcx> {\n                     }\n                 }\n             }\n+            ast::ItemDefaultImpl(_, ref ast_trait_ref) => {\n+                // \"Trait\" impl\n+                debug!(\"coherence2::orphan check: default trait impl {}\", item.repr(self.tcx));\n+                let trait_ref = ty::node_id_to_trait_ref(self.tcx, ast_trait_ref.ref_id);\n+                if trait_ref.def_id.krate != ast::LOCAL_CRATE {\n+                    span_err!(self.tcx.sess, item.span, E0318,\n+                              \"cannot create default implementations for traits outside the \\\n+                               crate they're defined in; define a new trait instead.\");\n+                }\n+            }\n             _ => {\n                 // Not an impl\n             }"}, {"sha": "366e934b4ddce1e8d5165a3bb0dc95e90d26cd08", "filename": "src/librustc_typeck/coherence/overlap.rs", "status": "modified", "additions": 55, "deletions": 8, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/2890508d97af287a136ac50ffa13a1c0a3e32e4e/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2890508d97af287a136ac50ffa13a1c0a3e32e4e/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs?ref=2890508d97af287a136ac50ffa13a1c0a3e32e4e", "patch": "@@ -17,16 +17,22 @@ use middle::infer::{self, new_infer_ctxt};\n use syntax::ast::{DefId};\n use syntax::ast::{LOCAL_CRATE};\n use syntax::ast;\n-use syntax::codemap::{Span};\n+use syntax::ast_util;\n+use syntax::visit;\n+use syntax::codemap::Span;\n use util::ppaux::Repr;\n \n pub fn check(tcx: &ty::ctxt) {\n-    let overlap = OverlapChecker { tcx: tcx };\n+    let mut overlap = OverlapChecker { tcx: tcx };\n     overlap.check_for_overlapping_impls();\n+\n+    // this secondary walk specifically checks for impls of defaulted\n+    // traits, for which additional overlap rules exist\n+    visit::walk_crate(&mut overlap, tcx.map.krate());\n }\n \n struct OverlapChecker<'cx, 'tcx:'cx> {\n-    tcx: &'cx ty::ctxt<'tcx>\n+    tcx: &'cx ty::ctxt<'tcx>,\n }\n \n impl<'cx, 'tcx> OverlapChecker<'cx, 'tcx> {\n@@ -90,17 +96,28 @@ impl<'cx, 'tcx> OverlapChecker<'cx, 'tcx> {\n             return;\n         }\n \n-        span_err!(self.tcx.sess, self.span_of_impl(impl1_def_id), E0119,\n+        self.report_overlap_error(trait_def_id, impl1_def_id, impl2_def_id);\n+    }\n+\n+    fn report_overlap_error(&self, trait_def_id: ast::DefId,\n+                            impl1: ast::DefId, impl2: ast::DefId) {\n+\n+        span_err!(self.tcx.sess, self.span_of_impl(impl1), E0119,\n                   \"conflicting implementations for trait `{}`\",\n                   ty::item_path_str(self.tcx, trait_def_id));\n \n-        if impl2_def_id.krate == ast::LOCAL_CRATE {\n-            span_note!(self.tcx.sess, self.span_of_impl(impl2_def_id),\n+        self.report_overlap_note(impl1, impl2);\n+    }\n+\n+    fn report_overlap_note(&self, impl1: ast::DefId, impl2: ast::DefId) {\n+\n+        if impl2.krate == ast::LOCAL_CRATE {\n+            span_note!(self.tcx.sess, self.span_of_impl(impl2),\n                        \"note conflicting implementation here\");\n         } else {\n             let crate_store = &self.tcx.sess.cstore;\n-            let cdata = crate_store.get_crate_data(impl2_def_id.krate);\n-            span_note!(self.tcx.sess, self.span_of_impl(impl1_def_id),\n+            let cdata = crate_store.get_crate_data(impl2.krate);\n+            span_note!(self.tcx.sess, self.span_of_impl(impl1),\n                        \"conflicting implementation in crate `{}`\",\n                        cdata.name);\n         }\n@@ -111,3 +128,33 @@ impl<'cx, 'tcx> OverlapChecker<'cx, 'tcx> {\n         self.tcx.map.span(impl_did.node)\n     }\n }\n+\n+\n+impl<'cx, 'tcx,'v> visit::Visitor<'v> for OverlapChecker<'cx, 'tcx> {\n+    fn visit_item(&mut self, item: &'v ast::Item) {\n+        match item.node {\n+            ast::ItemDefaultImpl(_, _) => {\n+                let impl_def_id = ast_util::local_def(item.id);\n+                match ty::impl_trait_ref(self.tcx, impl_def_id) {\n+                    Some(ref trait_ref) => {\n+                        match ty::trait_default_impl(self.tcx, trait_ref.def_id) {\n+                            Some(other_impl) if other_impl != impl_def_id => {\n+                                self.report_overlap_error(trait_ref.def_id,\n+                                                          other_impl,\n+                                                          impl_def_id);\n+                            }\n+                            Some(_) => {}\n+                            None => {\n+                                self.tcx.sess.bug(\n+                                          &format!(\"no default implementation recorded for `{:?}`\",\n+                                          item)[]);\n+                            }\n+                        }\n+                    }\n+                    _ => {}\n+                }\n+            }\n+            _ => {}\n+        }\n+    }\n+}"}, {"sha": "353e8e097a897d64e22c9e4e714bbc44835e806d", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2890508d97af287a136ac50ffa13a1c0a3e32e4e/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2890508d97af287a136ac50ffa13a1c0a3e32e4e/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=2890508d97af287a136ac50ffa13a1c0a3e32e4e", "patch": "@@ -648,6 +648,12 @@ fn convert_item(ccx: &CollectCtxt, it: &ast::Item) {\n                                    predicates,\n                                    &enum_definition.variants);\n         },\n+        ast::ItemDefaultImpl(_, ref ast_trait_ref) => {\n+            let trait_ref = astconv::instantiate_trait_ref(ccx, &ExplicitRscope,\n+                                                           ast_trait_ref, None, None);\n+\n+            ty::record_default_trait_implementation(tcx, trait_ref.def_id, local_def(it.id))\n+        }\n         ast::ItemImpl(_, _,\n                       ref generics,\n                       ref opt_trait_ref,\n@@ -1141,6 +1147,7 @@ fn compute_type_scheme_of_item<'a,'tcx>(ccx: &CollectCtxt<'a,'tcx>,\n             let t = ty::mk_struct(tcx, local_def(it.id), tcx.mk_substs(substs));\n             ty::TypeScheme { ty: t, generics: ty_generics }\n         }\n+        ast::ItemDefaultImpl(..) |\n         ast::ItemTrait(..) |\n         ast::ItemImpl(..) |\n         ast::ItemMod(..) |\n@@ -1183,6 +1190,7 @@ fn convert_typed_item<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n         ast::ItemStruct(_, ref generics) => {\n             ty_generic_bounds_for_type_or_impl(ccx, &scheme.generics, generics)\n         }\n+        ast::ItemDefaultImpl(..) |\n         ast::ItemTrait(..) |\n         ast::ItemExternCrate(..) |\n         ast::ItemUse(..) |"}, {"sha": "6f363faef60396d58ce14004aec6413673b0d4a7", "filename": "src/librustc_typeck/diagnostics.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2890508d97af287a136ac50ffa13a1c0a3e32e4e/src%2Flibrustc_typeck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2890508d97af287a136ac50ffa13a1c0a3e32e4e/src%2Flibrustc_typeck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fdiagnostics.rs?ref=2890508d97af287a136ac50ffa13a1c0a3e32e4e", "patch": "@@ -171,7 +171,9 @@ register_diagnostics! {\n     E0247, // found module name used as a type\n     E0248, // found value name used as a type\n     E0249, // expected constant expr for array length\n-    E0250  // expected constant expr for array length\n+    E0250, // expected constant expr for array length\n+    E0318, // can't create default impls for traits outside their crates\n+    E0319  // trait impls for defaulted traits allowed just for structs/enums\n }\n \n __build_diagnostic_array! { DIAGNOSTICS }"}, {"sha": "93d9ce3df84ed7b0c747c9b3668141e3660b9c16", "filename": "src/librustc_typeck/variance.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2890508d97af287a136ac50ffa13a1c0a3e32e4e/src%2Flibrustc_typeck%2Fvariance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2890508d97af287a136ac50ffa13a1c0a3e32e4e/src%2Flibrustc_typeck%2Fvariance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance.rs?ref=2890508d97af287a136ac50ffa13a1c0a3e32e4e", "patch": "@@ -476,6 +476,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for TermsContext<'a, 'tcx> {\n \n             ast::ItemExternCrate(_) |\n             ast::ItemUse(_) |\n+            ast::ItemDefaultImpl(..) |\n             ast::ItemImpl(..) |\n             ast::ItemStatic(..) |\n             ast::ItemConst(..) |\n@@ -626,6 +627,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for ConstraintContext<'a, 'tcx> {\n             ast::ItemForeignMod(..) |\n             ast::ItemTy(..) |\n             ast::ItemImpl(..) |\n+            ast::ItemDefaultImpl(..) |\n             ast::ItemMac(..) => {\n             }\n         }"}, {"sha": "4cd6f6551d0885cd8e2448112a44b0e5c56ea55a", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2890508d97af287a136ac50ffa13a1c0a3e32e4e/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2890508d97af287a136ac50ffa13a1c0a3e32e4e/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=2890508d97af287a136ac50ffa13a1c0a3e32e4e", "patch": "@@ -69,7 +69,7 @@ fn try_inline_def(cx: &DocContext, tcx: &ty::ctxt,\n     let mut ret = Vec::new();\n     let did = def.def_id();\n     let inner = match def {\n-        def::DefTrait(did) => {\n+        def::DefaultImpl(did) => {\n             record_extern_fqn(cx, did, clean::TypeTrait);\n             clean::TraitItem(build_external_trait(cx, tcx, did))\n         }"}, {"sha": "d8ef3194e837e9d74ca639cf4f626a6ae5aba6c5", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2890508d97af287a136ac50ffa13a1c0a3e32e4e/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2890508d97af287a136ac50ffa13a1c0a3e32e4e/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=2890508d97af287a136ac50ffa13a1c0a3e32e4e", "patch": "@@ -2431,7 +2431,7 @@ fn register_def(cx: &DocContext, def: def::Def) -> ast::DefId {\n         def::DefFn(i, _) => (i, TypeFunction),\n         def::DefTy(i, false) => (i, TypeTypedef),\n         def::DefTy(i, true) => (i, TypeEnum),\n-        def::DefTrait(i) => (i, TypeTrait),\n+        def::DefaultImpl(i) => (i, TypeTrait),\n         def::DefStruct(i) => (i, TypeStruct),\n         def::DefMod(i) => (i, TypeModule),\n         def::DefStatic(i, _) => (i, TypeStatic),"}, {"sha": "8143926982f0168988bc92d27e08101cf1a46582", "filename": "src/librustdoc/doctree.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2890508d97af287a136ac50ffa13a1c0a3e32e4e/src%2Flibrustdoc%2Fdoctree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2890508d97af287a136ac50ffa13a1c0a3e32e4e/src%2Flibrustdoc%2Fdoctree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdoctree.rs?ref=2890508d97af287a136ac50ffa13a1c0a3e32e4e", "patch": "@@ -39,6 +39,7 @@ pub struct Module {\n     pub vis: ast::Visibility,\n     pub stab: Option<attr::Stability>,\n     pub impls: Vec<Impl>,\n+    pub def_traits: Vec<DefaultImpl>,\n     pub foreigns: Vec<ast::ForeignMod>,\n     pub macros: Vec<Macro>,\n     pub is_crate: bool,\n@@ -65,6 +66,7 @@ impl Module {\n             constants  : Vec::new(),\n             traits     : Vec::new(),\n             impls      : Vec::new(),\n+            def_traits : Vec::new(),\n             foreigns   : Vec::new(),\n             macros     : Vec::new(),\n             is_crate   : false,\n@@ -196,6 +198,12 @@ pub struct Impl {\n     pub id: ast::NodeId,\n }\n \n+pub struct DefaultImpl {\n+    pub unsafety: ast::Unsafety,\n+    pub trait_: ast::TraitRef,\n+    pub id: ast::NodeId,\n+}\n+\n pub struct Macro {\n     pub name: Ident,\n     pub id: ast::NodeId,"}, {"sha": "9f5e3be9e3229a71711e60e1dcdcf1d0dcc1215c", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2890508d97af287a136ac50ffa13a1c0a3e32e4e/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2890508d97af287a136ac50ffa13a1c0a3e32e4e/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=2890508d97af287a136ac50ffa13a1c0a3e32e4e", "patch": "@@ -358,6 +358,14 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                 };\n                 om.impls.push(i);\n             },\n+            ast::ItemDefaultImpl(unsafety, ref trait_ref) => {\n+                let i = DefaultImpl {\n+                    unsafety: unsafety,\n+                    trait_: trait_ref.clone(),\n+                    id: item.id\n+                };\n+                om.def_traits.push(i);\n+            }\n             ast::ItemForeignMod(ref fm) => {\n                 om.foreigns.push(fm.clone());\n             }"}, {"sha": "effaac52716340e2c0f77f4821b0de6d0f01a5e9", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2890508d97af287a136ac50ffa13a1c0a3e32e4e/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2890508d97af287a136ac50ffa13a1c0a3e32e4e/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=2890508d97af287a136ac50ffa13a1c0a3e32e4e", "patch": "@@ -1641,6 +1641,10 @@ pub enum Item_ {\n               Generics,\n               TyParamBounds,\n               Vec<TraitItem>),\n+\n+    // Default trait implementations\n+    // `impl Trait for ..`\n+    ItemDefaultImpl(Unsafety, TraitRef),\n     ItemImpl(Unsafety,\n              ImplPolarity,\n              Generics,\n@@ -1666,7 +1670,8 @@ impl Item_ {\n             ItemStruct(..) => \"struct\",\n             ItemTrait(..) => \"trait\",\n             ItemMac(..) |\n-            ItemImpl(..) => \"item\"\n+            ItemImpl(..) |\n+            ItemDefaultImpl(..) => \"item\"\n         }\n     }\n }"}, {"sha": "c33158193ce215a6c835df3798bed0694c5ce294", "filename": "src/libsyntax/ast_map/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2890508d97af287a136ac50ffa13a1c0a3e32e4e/src%2Flibsyntax%2Fast_map%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2890508d97af287a136ac50ffa13a1c0a3e32e4e/src%2Flibsyntax%2Fast_map%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map%2Fmod.rs?ref=2890508d97af287a136ac50ffa13a1c0a3e32e4e", "patch": "@@ -1044,6 +1044,7 @@ fn node_id_to_string(map: &Map, id: NodeId, include_id: bool) -> String {\n                 ItemStruct(..) => \"struct\",\n                 ItemTrait(..) => \"trait\",\n                 ItemImpl(..) => \"impl\",\n+                ItemDefaultImpl(..) => \"default impl\",\n                 ItemMac(..) => \"macro\"\n             };\n             format!(\"{} {}{}\", item_str, path_str, id_str)"}, {"sha": "f1228c1d36308a365d968d36ed34660fdd5d18bb", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2890508d97af287a136ac50ffa13a1c0a3e32e4e/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2890508d97af287a136ac50ffa13a1c0a3e32e4e/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=2890508d97af287a136ac50ffa13a1c0a3e32e4e", "patch": "@@ -252,8 +252,12 @@ pub fn name_to_dummy_lifetime(name: Name) -> Lifetime {\n /// hint of where they came from, (previously they would all just be\n /// listed as `__extensions__::method_name::hash`, with no indication\n /// of the type).\n-pub fn impl_pretty_name(trait_ref: &Option<TraitRef>, ty: &Ty) -> Ident {\n-    let mut pretty = pprust::ty_to_string(ty);\n+pub fn impl_pretty_name(trait_ref: &Option<TraitRef>, ty: Option<&Ty>) -> Ident {\n+    let mut pretty = match ty {\n+        Some(t) => pprust::ty_to_string(t),\n+        None => String::from_str(\"..\")\n+    };\n+\n     match *trait_ref {\n         Some(ref trait_ref) => {\n             pretty.push('.');"}, {"sha": "a36d3a155b8d86de2db26d46d15627bfba53e99d", "filename": "src/libsyntax/ext/deriving/generic/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2890508d97af287a136ac50ffa13a1c0a3e32e4e/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2890508d97af287a136ac50ffa13a1c0a3e32e4e/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs?ref=2890508d97af287a136ac50ffa13a1c0a3e32e4e", "patch": "@@ -498,7 +498,7 @@ impl<'a> TraitDef<'a> {\n         // Just mark it now since we know that it'll end up used downstream\n         attr::mark_used(&attr);\n         let opt_trait_ref = Some(trait_ref);\n-        let ident = ast_util::impl_pretty_name(&opt_trait_ref, &*self_type);\n+        let ident = ast_util::impl_pretty_name(&opt_trait_ref, Some(&*self_type));\n         let mut a = vec![attr];\n         a.extend(self.attributes.iter().cloned());\n         cx.item("}, {"sha": "dae830583c44b43ce2c9e0b2e9832d95a1942bd9", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2890508d97af287a136ac50ffa13a1c0a3e32e4e/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2890508d97af287a136ac50ffa13a1c0a3e32e4e/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=2890508d97af287a136ac50ffa13a1c0a3e32e4e", "patch": "@@ -999,6 +999,9 @@ pub fn noop_fold_item_underscore<T: Folder>(i: Item_, folder: &mut T) -> Item_ {\n             let struct_def = folder.fold_struct_def(struct_def);\n             ItemStruct(struct_def, folder.fold_generics(generics))\n         }\n+        ItemDefaultImpl(unsafety, ref trait_ref) => {\n+            ItemDefaultImpl(unsafety, folder.fold_trait_ref((*trait_ref).clone()))\n+        }\n         ItemImpl(unsafety, polarity, generics, ifce, ty, impl_items) => {\n             let new_impl_items = impl_items.into_iter().flat_map(|item| {\n                 folder.fold_impl_item(item).into_iter()\n@@ -1150,7 +1153,7 @@ pub fn noop_fold_item_simple<T: Folder>(Item {id, ident, attrs, node, vis, span}\n     let ident = match node {\n         // The node may have changed, recompute the \"pretty\" impl name.\n         ItemImpl(_, _, _, ref maybe_trait, ref ty, _) => {\n-            ast_util::impl_pretty_name(maybe_trait, &**ty)\n+            ast_util::impl_pretty_name(maybe_trait, Some(&**ty))\n         }\n         _ => ident\n     };"}, {"sha": "fec33eddb91c18756a46170bff4f9c57081c5a3c", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 27, "deletions": 14, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/2890508d97af287a136ac50ffa13a1c0a3e32e4e/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2890508d97af287a136ac50ffa13a1c0a3e32e4e/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=2890508d97af287a136ac50ffa13a1c0a3e32e4e", "patch": "@@ -31,7 +31,7 @@ use ast::{ExprVec, ExprWhile, ExprWhileLet, ExprForLoop, Field, FnDecl};\n use ast::{ForeignItem, ForeignItemStatic, ForeignItemFn, ForeignMod, FunctionRetTy};\n use ast::{Ident, Inherited, ImplItem, Item, Item_, ItemStatic};\n use ast::{ItemEnum, ItemFn, ItemForeignMod, ItemImpl, ItemConst};\n-use ast::{ItemMac, ItemMod, ItemStruct, ItemTrait, ItemTy};\n+use ast::{ItemMac, ItemMod, ItemStruct, ItemTrait, ItemTy, ItemDefaultImpl};\n use ast::{ItemExternCrate, ItemUse};\n use ast::{LifetimeDef, Lit, Lit_};\n use ast::{LitBool, LitChar, LitByte, LitBinary};\n@@ -4787,10 +4787,13 @@ impl<'a> Parser<'a> {\n         (impl_items, inner_attrs)\n     }\n \n-    /// Parses two variants (with the region/type params always optional):\n+    /// Parses items implementations variants\n     ///    impl<T> Foo { ... }\n-    ///    impl<T> ToString for ~[T] { ... }\n+    ///    impl<T> ToString for &'static T { ... }\n+    ///    impl Send for .. {}\n     fn parse_item_impl(&mut self, unsafety: ast::Unsafety) -> ItemInfo {\n+        let impl_span = self.span;\n+\n         // First, parse type parameters if necessary.\n         let mut generics = self.parse_generics();\n \n@@ -4811,7 +4814,7 @@ impl<'a> Parser<'a> {\n         // Parse traits, if necessary.\n         let opt_trait = if could_be_trait && self.eat_keyword(keywords::For) {\n             // New-style trait. Reinterpret the type as a trait.\n-            let opt_trait_ref = match ty.node {\n+            match ty.node {\n                 TyPath(ref path, node_id) => {\n                     Some(TraitRef {\n                         path: (*path).clone(),\n@@ -4822,10 +4825,7 @@ impl<'a> Parser<'a> {\n                     self.span_err(ty.span, \"not a trait\");\n                     None\n                 }\n-            };\n-\n-            ty = self.parse_ty_sum();\n-            opt_trait_ref\n+            }\n         } else {\n             match polarity {\n                 ast::ImplPolarity::Negative => {\n@@ -4838,14 +4838,27 @@ impl<'a> Parser<'a> {\n             None\n         };\n \n-        self.parse_where_clause(&mut generics);\n-        let (impl_items, attrs) = self.parse_impl_items();\n+        if self.eat(&token::DotDot) {\n+            if generics.is_parameterized() {\n+                self.span_err(impl_span, \"default trait implementations are not \\\n+                                          allowed to have genercis\");\n+            }\n \n-        let ident = ast_util::impl_pretty_name(&opt_trait, &*ty);\n+            self.expect(&token::OpenDelim(token::Brace));\n+            self.expect(&token::CloseDelim(token::Brace));\n+            (ast_util::impl_pretty_name(&opt_trait, None),\n+             ItemDefaultImpl(unsafety, opt_trait.unwrap()), None)\n+        } else {\n+            if opt_trait.is_some() {\n+                ty = self.parse_ty_sum();\n+            }\n+            self.parse_where_clause(&mut generics);\n+            let (impl_items, attrs) = self.parse_impl_items();\n \n-        (ident,\n-         ItemImpl(unsafety, polarity, generics, opt_trait, ty, impl_items),\n-         Some(attrs))\n+            (ast_util::impl_pretty_name(&opt_trait, Some(&*ty)),\n+             ItemImpl(unsafety, polarity, generics, opt_trait, ty, impl_items),\n+             Some(attrs))\n+        }\n     }\n \n     /// Parse a::B<String,i32>"}, {"sha": "869dad867ebc4f6c8d7fc45783410ac8b6e45a34", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2890508d97af287a136ac50ffa13a1c0a3e32e4e/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2890508d97af287a136ac50ffa13a1c0a3e32e4e/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=2890508d97af287a136ac50ffa13a1c0a3e32e4e", "patch": "@@ -926,6 +926,18 @@ impl<'a> State<'a> {\n                 try!(self.print_struct(&**struct_def, generics, item.ident, item.span));\n             }\n \n+            ast::ItemDefaultImpl(unsafety, ref trait_ref) => {\n+                try!(self.head(\"\"));\n+                try!(self.print_visibility(item.vis));\n+                try!(self.print_unsafety(unsafety));\n+                try!(self.word_nbsp(\"impl\"));\n+                try!(self.print_trait_ref(trait_ref));\n+                try!(space(&mut self.s));\n+                try!(self.word_space(\"for\"));\n+                try!(self.word_space(\"..\"));\n+                try!(self.bopen());\n+                try!(self.bclose(item.span));\n+            }\n             ast::ItemImpl(unsafety,\n                           polarity,\n                           ref generics,"}, {"sha": "412bf0fa22a00a37dd77567636fd9eeb40a4914e", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2890508d97af287a136ac50ffa13a1c0a3e32e4e/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2890508d97af287a136ac50ffa13a1c0a3e32e4e/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=2890508d97af287a136ac50ffa13a1c0a3e32e4e", "patch": "@@ -282,6 +282,9 @@ pub fn walk_item<'v, V: Visitor<'v>>(visitor: &mut V, item: &'v Item) {\n             visitor.visit_generics(type_parameters);\n             walk_enum_def(visitor, enum_definition, type_parameters)\n         }\n+        ItemDefaultImpl(_, ref trait_ref) => {\n+            visitor.visit_trait_ref(trait_ref)\n+        }\n         ItemImpl(_, _,\n                  ref type_parameters,\n                  ref trait_reference,"}, {"sha": "7cc07e926b267b4b27b97c82e2f7c2adfd47b046", "filename": "src/libtest/stats.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2890508d97af287a136ac50ffa13a1c0a3e32e4e/src%2Flibtest%2Fstats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2890508d97af287a136ac50ffa13a1c0a3e32e4e/src%2Flibtest%2Fstats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Fstats.rs?ref=2890508d97af287a136ac50ffa13a1c0a3e32e4e", "patch": "@@ -332,6 +332,7 @@ pub fn winsorize<T: Float + FromPrimitive>(samples: &mut [T], pct: T) {\n \n /// Returns a HashMap with the number of occurrences of every element in the\n /// sequence that the iterator exposes.\n+#[cfg(not(stage0))]\n pub fn freq_count<T, U>(iter: T) -> hash_map::HashMap<U, uint>\n   where T: Iterator<Item=U>, U: Eq + Clone + Hash\n {"}, {"sha": "6bcbefb904d9e6a510ec6120a94a40e80aeefa57", "filename": "src/test/compile-fail/coherence-default-trait-impl.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/2890508d97af287a136ac50ffa13a1c0a3e32e4e/src%2Ftest%2Fcompile-fail%2Fcoherence-default-trait-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2890508d97af287a136ac50ffa13a1c0a3e32e4e/src%2Ftest%2Fcompile-fail%2Fcoherence-default-trait-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcoherence-default-trait-impl.rs?ref=2890508d97af287a136ac50ffa13a1c0a3e32e4e", "patch": "@@ -0,0 +1,24 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-tidy-linelength\n+\n+#![feature(optin_builtin_traits)]\n+\n+use std::marker::MarkerTrait;\n+\n+trait MyTrait: MarkerTrait {}\n+\n+impl MyTrait for .. {}\n+\n+impl MyTrait for .. {}\n+//~^ ERROR conflicting implementations for trait `MyTrait`\n+\n+fn main() {}"}, {"sha": "3e132dcb11fa32a3188efc241446b407c469562e", "filename": "src/test/compile-fail/coherence-impls-builtin.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2890508d97af287a136ac50ffa13a1c0a3e32e4e/src%2Ftest%2Fcompile-fail%2Fcoherence-impls-builtin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2890508d97af287a136ac50ffa13a1c0a3e32e4e/src%2Ftest%2Fcompile-fail%2Fcoherence-impls-builtin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcoherence-impls-builtin.rs?ref=2890508d97af287a136ac50ffa13a1c0a3e32e4e", "patch": "@@ -34,6 +34,7 @@ unsafe impl Send for [MyType] {}\n \n unsafe impl Send for &'static [NotSync] {}\n //~^ ERROR builtin traits can only be implemented on structs or enums\n+//~^^ ERROR conflicting implementations for trait `core::marker::Send`\n \n fn is_send<T: Send>() {}\n "}, {"sha": "e8bc11317f2aadbd597b1a58228d0a61be3505a1", "filename": "src/test/compile-fail/recursion_limit.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2890508d97af287a136ac50ffa13a1c0a3e32e4e/src%2Ftest%2Fcompile-fail%2Frecursion_limit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2890508d97af287a136ac50ffa13a1c0a3e32e4e/src%2Ftest%2Fcompile-fail%2Frecursion_limit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Frecursion_limit.rs?ref=2890508d97af287a136ac50ffa13a1c0a3e32e4e", "patch": "@@ -47,4 +47,7 @@ fn main() {\n     //~^^^^ ERROR overflow evaluating\n     //~^^^^^ NOTE consider adding a `#![recursion_limit=\"20\"]` attribute to your crate\n     //~^^^^^^ NOTE required by `is_send`\n+    //~^^^^^^^ ERROR overflow evaluating\n+    //~^^^^^^^^ NOTE consider adding a `#![recursion_limit=\"20\"]` attribute to your crate\n+    //~^^^^^^^^^ NOTE required by `is_send`\n }"}, {"sha": "a33cd0edca5b480c6b7f7d00c71f1c437a864d2e", "filename": "src/test/compile-fail/syntaxt-default-trait-impls.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/2890508d97af287a136ac50ffa13a1c0a3e32e4e/src%2Ftest%2Fcompile-fail%2Fsyntaxt-default-trait-impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2890508d97af287a136ac50ffa13a1c0a3e32e4e/src%2Ftest%2Fcompile-fail%2Fsyntaxt-default-trait-impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fsyntaxt-default-trait-impls.rs?ref=2890508d97af287a136ac50ffa13a1c0a3e32e4e", "patch": "@@ -0,0 +1,18 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(optin_builtin_traits)]\n+\n+trait MyDefaultImpl {}\n+\n+impl<T> MyDefaultImpl for .. {}\n+//~^ ERROR default trait implementations are not allowed to have genercis\n+\n+fn main() {}"}, {"sha": "8a9d53731c545ca3788012d12d5cdc0d3a56f59a", "filename": "src/test/compile-fail/typeck-default-trait-impl-assoc-type.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/2890508d97af287a136ac50ffa13a1c0a3e32e4e/src%2Ftest%2Fcompile-fail%2Ftypeck-default-trait-impl-assoc-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2890508d97af287a136ac50ffa13a1c0a3e32e4e/src%2Ftest%2Fcompile-fail%2Ftypeck-default-trait-impl-assoc-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftypeck-default-trait-impl-assoc-type.rs?ref=2890508d97af287a136ac50ffa13a1c0a3e32e4e", "patch": "@@ -0,0 +1,25 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that we do not consider associated types to be sendable without\n+// some applicable trait bound (and we don't ICE).\n+\n+trait Trait {\n+    type AssocType;\n+    fn dummy(&self) { }\n+}\n+fn bar<T:Trait+Send>() {\n+    is_send::<T::AssocType>(); //~ ERROR not implemented\n+}\n+\n+fn is_send<T:Send>() {\n+}\n+\n+fn main() { }"}, {"sha": "0f3453da43137ef6892aed003a15005e7c0fed69", "filename": "src/test/compile-fail/typeck-default-trait-impl-constituent-types-2.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/2890508d97af287a136ac50ffa13a1c0a3e32e4e/src%2Ftest%2Fcompile-fail%2Ftypeck-default-trait-impl-constituent-types-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2890508d97af287a136ac50ffa13a1c0a3e32e4e/src%2Ftest%2Fcompile-fail%2Ftypeck-default-trait-impl-constituent-types-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftypeck-default-trait-impl-constituent-types-2.rs?ref=2890508d97af287a136ac50ffa13a1c0a3e32e4e", "patch": "@@ -0,0 +1,32 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(optin_builtin_traits)]\n+\n+use std::marker::MarkerTrait;\n+\n+trait MyTrait: MarkerTrait {}\n+\n+impl MyTrait for .. {}\n+\n+struct MyS;\n+\n+struct MyS2;\n+\n+impl !MyTrait for MyS2 {}\n+\n+fn is_mytrait<T: MyTrait>() {}\n+\n+fn main() {\n+    is_mytrait::<MyS>();\n+\n+    is_mytrait::<(MyS2, MyS)>();\n+    //~^ ERROR the trait `MyTrait` is not implemented for the type `MyS2`\n+}"}, {"sha": "524f467e017002c21a36e0f92530ffb5fa0c36e6", "filename": "src/test/compile-fail/typeck-default-trait-impl-constituent-types.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/2890508d97af287a136ac50ffa13a1c0a3e32e4e/src%2Ftest%2Fcompile-fail%2Ftypeck-default-trait-impl-constituent-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2890508d97af287a136ac50ffa13a1c0a3e32e4e/src%2Ftest%2Fcompile-fail%2Ftypeck-default-trait-impl-constituent-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftypeck-default-trait-impl-constituent-types.rs?ref=2890508d97af287a136ac50ffa13a1c0a3e32e4e", "patch": "@@ -0,0 +1,35 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(optin_builtin_traits)]\n+\n+use std::marker::MarkerTrait;\n+\n+trait MyTrait: MarkerTrait {}\n+\n+impl MyTrait for .. {}\n+impl<T> !MyTrait for *mut T {}\n+\n+struct MyS;\n+\n+struct MyS2;\n+\n+impl !MyTrait for MyS2 {}\n+\n+struct MyS3;\n+\n+fn is_mytrait<T: MyTrait>() {}\n+\n+fn main() {\n+    is_mytrait::<MyS>();\n+\n+    is_mytrait::<MyS2>();\n+    //~^ ERROR the trait `MyTrait` is not implemented for the type `MyS2`\n+}"}, {"sha": "db4d1fe485b32d33e13d15601d016f78930c01d4", "filename": "src/test/compile-fail/typeck-default-trait-impl-negation-send.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/2890508d97af287a136ac50ffa13a1c0a3e32e4e/src%2Ftest%2Fcompile-fail%2Ftypeck-default-trait-impl-negation-send.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2890508d97af287a136ac50ffa13a1c0a3e32e4e/src%2Ftest%2Fcompile-fail%2Ftypeck-default-trait-impl-negation-send.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftypeck-default-trait-impl-negation-send.rs?ref=2890508d97af287a136ac50ffa13a1c0a3e32e4e", "patch": "@@ -0,0 +1,31 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(optin_builtin_traits)]\n+\n+struct MySendable {\n+   t: *mut u8\n+}\n+\n+unsafe impl Send for MySendable {}\n+\n+struct MyNotSendable {\n+   t: *mut u8\n+}\n+\n+impl !Send for MyNotSendable {}\n+\n+fn is_send<T: Send>() {}\n+\n+fn main() {\n+    is_send::<MySendable>();\n+    is_send::<MyNotSendable>();\n+    //~^ ERROR the trait `core::marker::Send` is not implemented for the type `MyNotSendable`\n+}"}, {"sha": "d613589e7d77741b74ca333211c22e5c54a9ec9d", "filename": "src/test/compile-fail/typeck-default-trait-impl-negation-sync.rs", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/2890508d97af287a136ac50ffa13a1c0a3e32e4e/src%2Ftest%2Fcompile-fail%2Ftypeck-default-trait-impl-negation-sync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2890508d97af287a136ac50ffa13a1c0a3e32e4e/src%2Ftest%2Fcompile-fail%2Ftypeck-default-trait-impl-negation-sync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftypeck-default-trait-impl-negation-sync.rs?ref=2890508d97af287a136ac50ffa13a1c0a3e32e4e", "patch": "@@ -0,0 +1,50 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-tidy-linelength\n+\n+#![feature(optin_builtin_traits)]\n+\n+use std::marker::Managed;\n+use std::cell::UnsafeCell;\n+\n+struct MySync {\n+   t: *mut u8\n+}\n+\n+unsafe impl Sync for MySync {}\n+\n+struct MyNotSync {\n+   t: *mut u8\n+}\n+\n+impl !Sync for MyNotSync {}\n+\n+struct MyTypeWUnsafe {\n+   t: UnsafeCell<u8>\n+}\n+\n+struct MyTypeManaged {\n+   t: Managed\n+}\n+\n+fn is_sync<T: Sync>() {}\n+\n+fn main() {\n+    is_sync::<MySync>();\n+    is_sync::<MyNotSync>();\n+    //~^ ERROR the trait `core::marker::Sync` is not implemented for the type `MyNotSync`\n+\n+    is_sync::<MyTypeWUnsafe>();\n+    //~^ ERROR the trait `core::marker::Sync` is not implemented for the type `core::cell::UnsafeCell<u8>`\n+\n+    is_sync::<MyTypeManaged>();\n+    //~^ ERROR the trait `core::marker::Sync` is not implemented for the type `core::marker::Managed`\n+}"}, {"sha": "a1ca0e3e0fada28d79303481a32dedf925a282e1", "filename": "src/test/compile-fail/typeck-default-trait-impl-negation.rs", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/2890508d97af287a136ac50ffa13a1c0a3e32e4e/src%2Ftest%2Fcompile-fail%2Ftypeck-default-trait-impl-negation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2890508d97af287a136ac50ffa13a1c0a3e32e4e/src%2Ftest%2Fcompile-fail%2Ftypeck-default-trait-impl-negation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftypeck-default-trait-impl-negation.rs?ref=2890508d97af287a136ac50ffa13a1c0a3e32e4e", "patch": "@@ -0,0 +1,44 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(optin_builtin_traits)]\n+\n+use std::marker::MarkerTrait;\n+\n+trait MyTrait: MarkerTrait {}\n+\n+impl MyTrait for .. {}\n+\n+unsafe trait MyUnsafeTrait: MarkerTrait {}\n+\n+unsafe impl MyUnsafeTrait for .. {}\n+\n+struct ThisImplsTrait;\n+\n+impl !MyUnsafeTrait for ThisImplsTrait {}\n+\n+\n+struct ThisImplsUnsafeTrait;\n+\n+impl !MyTrait for ThisImplsUnsafeTrait {}\n+\n+fn is_my_trait<T: MyTrait>() {}\n+fn is_my_unsafe_trait<T: MyUnsafeTrait>() {}\n+\n+fn main() {\n+    is_my_trait::<ThisImplsTrait>();\n+    is_my_trait::<ThisImplsUnsafeTrait>();\n+    //~^ ERROR the trait `MyTrait` is not implemented for the type `ThisImplsUnsafeTrait`\n+\n+    is_my_unsafe_trait::<ThisImplsTrait>();\n+    //~^ ERROR the trait `MyUnsafeTrait` is not implemented for the type `ThisImplsTrait`\n+\n+    is_my_unsafe_trait::<ThisImplsUnsafeTrait>();\n+}"}, {"sha": "10ba8c74164830efeed897659da41a04faa5e99b", "filename": "src/test/compile-fail/typeck-default-trait-impl-outside-crate.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/2890508d97af287a136ac50ffa13a1c0a3e32e4e/src%2Ftest%2Fcompile-fail%2Ftypeck-default-trait-impl-outside-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2890508d97af287a136ac50ffa13a1c0a3e32e4e/src%2Ftest%2Fcompile-fail%2Ftypeck-default-trait-impl-outside-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftypeck-default-trait-impl-outside-crate.rs?ref=2890508d97af287a136ac50ffa13a1c0a3e32e4e", "patch": "@@ -0,0 +1,18 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-tidy-linelength\n+\n+#![feature(optin_builtin_traits)]\n+\n+impl Copy for .. {}\n+//~^ ERROR cannot create default implementations for traits outside the crate they're defined in; define a new trait instead.\n+\n+fn main() {}"}, {"sha": "4006eb2e83ed92383d1e755b09c398c2b24e459b", "filename": "src/test/compile-fail/typeck-default-trait-impl-precedence.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/2890508d97af287a136ac50ffa13a1c0a3e32e4e/src%2Ftest%2Fcompile-fail%2Ftypeck-default-trait-impl-precedence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2890508d97af287a136ac50ffa13a1c0a3e32e4e/src%2Ftest%2Fcompile-fail%2Ftypeck-default-trait-impl-precedence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftypeck-default-trait-impl-precedence.rs?ref=2890508d97af287a136ac50ffa13a1c0a3e32e4e", "patch": "@@ -0,0 +1,33 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that declaring that `&T` is `Defaulted` if `T:Signed` implies\n+// that other `&T` is NOT `Defaulted` if `T:Signed` does not hold. In\n+// other words, the `..` impl only applies if there are no existing\n+// impls whose types unify.\n+\n+#![feature(optin_builtin_traits)]\n+\n+use std::marker::MarkerTrait;\n+\n+trait Defaulted : MarkerTrait { }\n+impl Defaulted for .. { }\n+impl<'a,T:Signed> Defaulted for &'a T { }\n+impl<'a,T:Signed> Defaulted for &'a mut T { }\n+fn is_defaulted<T:Defaulted>() { }\n+\n+trait Signed : MarkerTrait { }\n+impl Signed for i32 { }\n+\n+fn main() {\n+    is_defaulted::<&'static i32>();\n+    is_defaulted::<&'static u32>();\n+    //~^ ERROR the trait `Signed` is not implemented for the type `u32`\n+}"}, {"sha": "185e9dcb3bd91d32217f85f18da308216471694c", "filename": "src/test/compile-fail/typeck-default-trait-impl-send-param.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/2890508d97af287a136ac50ffa13a1c0a3e32e4e/src%2Ftest%2Fcompile-fail%2Ftypeck-default-trait-impl-send-param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2890508d97af287a136ac50ffa13a1c0a3e32e4e/src%2Ftest%2Fcompile-fail%2Ftypeck-default-trait-impl-send-param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftypeck-default-trait-impl-send-param.rs?ref=2890508d97af287a136ac50ffa13a1c0a3e32e4e", "patch": "@@ -0,0 +1,21 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that we do not consider parameter types to be sendable without\n+// an explicit trait bound.\n+\n+fn foo<T>() {\n+    is_send::<T>() //~ ERROR not implemented\n+}\n+\n+fn is_send<T:Send>() {\n+}\n+\n+fn main() { }"}, {"sha": "4a6a77ac7b440950c3c7b4df4a337977ae1bb4cf", "filename": "src/test/compile-fail/typeck-default-trait-impl-superregion.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/2890508d97af287a136ac50ffa13a1c0a3e32e4e/src%2Ftest%2Fcompile-fail%2Ftypeck-default-trait-impl-superregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2890508d97af287a136ac50ffa13a1c0a3e32e4e/src%2Ftest%2Fcompile-fail%2Ftypeck-default-trait-impl-superregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftypeck-default-trait-impl-superregion.rs?ref=2890508d97af287a136ac50ffa13a1c0a3e32e4e", "patch": "@@ -0,0 +1,29 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that when a `..` impl applies, we also check that any\n+// supertrait conditions are met.\n+\n+#![feature(optin_builtin_traits)]\n+\n+use std::marker::MarkerTrait;\n+\n+trait MyTrait : 'static {}\n+\n+impl MyTrait for .. {}\n+\n+fn foo<T:MyTrait>() { }\n+\n+fn bar<'a>() {\n+    foo::<&'a ()>(); //~ ERROR does not fulfill the required lifetime\n+}\n+\n+fn main() {\n+}"}, {"sha": "7f24058e475facaae3e247488dae5a3e89d06299", "filename": "src/test/compile-fail/typeck-default-trait-impl-supertrait.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/2890508d97af287a136ac50ffa13a1c0a3e32e4e/src%2Ftest%2Fcompile-fail%2Ftypeck-default-trait-impl-supertrait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2890508d97af287a136ac50ffa13a1c0a3e32e4e/src%2Ftest%2Fcompile-fail%2Ftypeck-default-trait-impl-supertrait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftypeck-default-trait-impl-supertrait.rs?ref=2890508d97af287a136ac50ffa13a1c0a3e32e4e", "patch": "@@ -0,0 +1,31 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that when a `..` impl applies, we also check that any\n+// supertrait conditions are met.\n+\n+#![feature(optin_builtin_traits)]\n+\n+use std::marker::MarkerTrait;\n+\n+trait NotImplemented: MarkerTrait { }\n+\n+trait MyTrait : NotImplemented {}\n+\n+impl MyTrait for .. {}\n+\n+fn foo<T:MyTrait>() { bar::<T>() }\n+\n+fn bar<T:NotImplemented>() { }\n+\n+fn main() {\n+    foo::<i32>(); //~ ERROR the trait `NotImplemented` is not implemented for the type `i32`\n+    bar::<i64>(); //~ ERROR the trait `NotImplemented` is not implemented for the type `i64`\n+}"}, {"sha": "c970aaaf5d471ce69254c4338234d0ea206499db", "filename": "src/test/compile-fail/typeck-default-trait-impl-trait-where-clause.rs", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/2890508d97af287a136ac50ffa13a1c0a3e32e4e/src%2Ftest%2Fcompile-fail%2Ftypeck-default-trait-impl-trait-where-clause.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2890508d97af287a136ac50ffa13a1c0a3e32e4e/src%2Ftest%2Fcompile-fail%2Ftypeck-default-trait-impl-trait-where-clause.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftypeck-default-trait-impl-trait-where-clause.rs?ref=2890508d97af287a136ac50ffa13a1c0a3e32e4e", "patch": "@@ -0,0 +1,47 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-tidy-linelength\n+\n+// Test that when a `..` impl applies, we also check that any\n+// supertrait conditions are met.\n+\n+#![feature(optin_builtin_traits)]\n+\n+use std::marker::MarkerTrait;\n+\n+trait NotImplemented: MarkerTrait { }\n+\n+trait MyTrait: MarkerTrait\n+    where Option<Self> : NotImplemented\n+{}\n+\n+impl NotImplemented for i32 {}\n+\n+impl MyTrait for .. {}\n+\n+fn foo<T:MyTrait>() {\n+    bar::<Option<T>>()\n+    //~^ ERROR the trait `NotImplemented` is not implemented for the type `core::option::Option<T>`\n+    //\n+    // This should probably typecheck. This is #20671.\n+}\n+\n+fn bar<T:NotImplemented>() { }\n+\n+fn test() {\n+    bar::<Option<i32>>();\n+    //~^ ERROR the trait `NotImplemented` is not implemented for the type `core::option::Option<i32>`\n+}\n+\n+fn main() {\n+    foo::<i32>();\n+    //~^ ERROR the trait `NotImplemented` is not implemented for the type `core::option::Option<i32>`\n+}"}, {"sha": "57a394dc7f1ec746847641673a6ac0ef8fcf126c", "filename": "src/test/compile-fail/typeck-negative-impls-builtin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2890508d97af287a136ac50ffa13a1c0a3e32e4e/src%2Ftest%2Fcompile-fail%2Ftypeck-negative-impls-builtin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2890508d97af287a136ac50ffa13a1c0a3e32e4e/src%2Ftest%2Fcompile-fail%2Ftypeck-negative-impls-builtin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftypeck-negative-impls-builtin.rs?ref=2890508d97af287a136ac50ffa13a1c0a3e32e4e", "patch": "@@ -17,6 +17,6 @@ trait TestTrait {\n }\n \n impl !TestTrait for TestType {}\n-//~^ ERROR  negative impls are currently allowed just for `Send` and `Sync`\n+//~^ ERROR negative impls are only allowed for traits with default impls (e.g., `Send` and `Sync`)\n \n fn main() {}"}, {"sha": "a2e780d49b8eaac9e5f89cd0debfe19937bacf4b", "filename": "src/test/parse-fail/empty-impl-semicolon.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2890508d97af287a136ac50ffa13a1c0a3e32e4e/src%2Ftest%2Fparse-fail%2Fempty-impl-semicolon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2890508d97af287a136ac50ffa13a1c0a3e32e4e/src%2Ftest%2Fparse-fail%2Fempty-impl-semicolon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fempty-impl-semicolon.rs?ref=2890508d97af287a136ac50ffa13a1c0a3e32e4e", "patch": "@@ -8,4 +8,4 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-impl Foo; //~ ERROR expected one of `(`, `+`, `::`, `<`, `for`, `where`, or `{`, found `;`\n+impl Foo; //~ ERROR expected one of `(`, `+`, `..`, `::`, `<`, `for`, `where`, or `{`, found `;`"}, {"sha": "a8b2fa4e115be10543f9b86b77a8409115a6e048", "filename": "src/test/parse-fail/multitrait.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2890508d97af287a136ac50ffa13a1c0a3e32e4e/src%2Ftest%2Fparse-fail%2Fmultitrait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2890508d97af287a136ac50ffa13a1c0a3e32e4e/src%2Ftest%2Fparse-fail%2Fmultitrait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fmultitrait.rs?ref=2890508d97af287a136ac50ffa13a1c0a3e32e4e", "patch": "@@ -13,7 +13,7 @@ struct S {\n }\n \n impl Cmp, ToString for S {\n-//~^ ERROR: expected one of `(`, `+`, `::`, `<`, `for`, `where`, or `{`, found `,`\n+//~^ ERROR: expected one of `(`, `+`, `..`, `::`, `<`, `for`, `where`, or `{`, found `,`\n   fn eq(&&other: S) { false }\n   fn to_string(&self) -> String { \"hi\".to_string() }\n }"}, {"sha": "51447b225763b258258fcfc33efa992fcabc5a76", "filename": "src/test/parse-fail/trait-bounds-not-on-impl.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2890508d97af287a136ac50ffa13a1c0a3e32e4e/src%2Ftest%2Fparse-fail%2Ftrait-bounds-not-on-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2890508d97af287a136ac50ffa13a1c0a3e32e4e/src%2Ftest%2Fparse-fail%2Ftrait-bounds-not-on-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Ftrait-bounds-not-on-impl.rs?ref=2890508d97af287a136ac50ffa13a1c0a3e32e4e", "patch": "@@ -13,7 +13,9 @@ trait Foo {\n \n struct Bar;\n \n-impl Foo + Owned for Bar { //~ ERROR not a trait\n+impl Foo + Owned for Bar {\n+//~^ ERROR not a trait\n+//~^^ ERROR expected one of `..`, `where`, or `{`, found `Bar`\n }\n \n fn main() { }"}, {"sha": "d148bb15e99bc8d13e5c99408536a88f9d4be35a", "filename": "src/test/pretty/default-trait-impl.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/2890508d97af287a136ac50ffa13a1c0a3e32e4e/src%2Ftest%2Fpretty%2Fdefault-trait-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2890508d97af287a136ac50ffa13a1c0a3e32e4e/src%2Ftest%2Fpretty%2Fdefault-trait-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fdefault-trait-impl.rs?ref=2890508d97af287a136ac50ffa13a1c0a3e32e4e", "patch": "@@ -0,0 +1,21 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(optin_builtin_traits)]\n+\n+// pp-exact\n+\n+use std::marker::MarkerTrait;\n+\n+trait MyTrait: MarkerTrait { }\n+\n+impl MyTrait for .. { }\n+\n+pub fn main() { }"}]}