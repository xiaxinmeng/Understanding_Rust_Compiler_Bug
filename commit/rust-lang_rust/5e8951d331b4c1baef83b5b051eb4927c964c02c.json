{"sha": "5e8951d331b4c1baef83b5b051eb4927c964c02c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVlODk1MWQzMzFiNGMxYmFlZjgzYjViMDUxZWI0OTI3Yzk2NGMwMmM=", "commit": {"author": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-10-20T00:52:58Z"}, "committer": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-10-24T00:51:11Z"}, "message": "Clean up `CrateLoader::process_item`.", "tree": {"sha": "a66a04045279f5e4de88b2301472f6f4ec7a7498", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a66a04045279f5e4de88b2301472f6f4ec7a7498"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5e8951d331b4c1baef83b5b051eb4927c964c02c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5e8951d331b4c1baef83b5b051eb4927c964c02c", "html_url": "https://github.com/rust-lang/rust/commit/5e8951d331b4c1baef83b5b051eb4927c964c02c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5e8951d331b4c1baef83b5b051eb4927c964c02c/comments", "author": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9c514a1cc1d74ad3835311977e41c786ff60b7d3", "url": "https://api.github.com/repos/rust-lang/rust/commits/9c514a1cc1d74ad3835311977e41c786ff60b7d3", "html_url": "https://github.com/rust-lang/rust/commit/9c514a1cc1d74ad3835311977e41c786ff60b7d3"}], "stats": {"total": 103, "additions": 41, "deletions": 62}, "files": [{"sha": "a3a84f51780fb0850a19cdf51cde1a67f528c0a3", "filename": "src/librustc/middle/cstore.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/5e8951d331b4c1baef83b5b051eb4927c964c02c/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8951d331b4c1baef83b5b051eb4927c964c02c/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcstore.rs?ref=5e8951d331b4c1baef83b5b051eb4927c964c02c", "patch": "@@ -422,6 +422,15 @@ pub enum LoadedMacros {\n     ProcMacros(Vec<(ast::Name, SyntaxExtension)>),\n }\n \n+impl LoadedMacros {\n+    pub fn is_proc_macros(&self) -> bool {\n+        match *self {\n+            LoadedMacros::ProcMacros(_) => true,\n+            _ => false,\n+        }\n+    }\n+}\n+\n pub trait CrateLoader {\n     fn process_item(&mut self, item: &ast::Item, defs: &Definitions, load_macros: bool)\n                     -> Option<LoadedMacros>;"}, {"sha": "d160d29af7da38c28b4118f6d68eee79a74cc7e6", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 32, "deletions": 62, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/5e8951d331b4c1baef83b5b051eb4927c964c02c/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8951d331b4c1baef83b5b051eb4927c964c02c/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=5e8951d331b4c1baef83b5b051eb4927c964c02c", "patch": "@@ -120,11 +120,6 @@ struct ExtensionCrate {\n     metadata: PMDSource,\n     dylib: Option<PathBuf>,\n     target_only: bool,\n-\n-    ident: String,\n-    name: String,\n-    span: Span,\n-    should_link: bool,\n }\n \n enum PMDSource {\n@@ -479,7 +474,6 @@ impl<'a> CrateLoader<'a> {\n               info.id, info.name, info.ident, info.should_link);\n         let target_triple = &self.sess.opts.target_triple[..];\n         let is_cross = target_triple != config::host_triple();\n-        let mut should_link = info.should_link && !is_cross;\n         let mut target_only = false;\n         let ident = info.ident.clone();\n         let name = info.name.clone();\n@@ -506,7 +500,6 @@ impl<'a> CrateLoader<'a> {\n             // Try loading from target crates. This will abort later if we\n             // try to load a plugin registrar function,\n             target_only = true;\n-            should_link = info.should_link;\n \n             locate_ctxt.target = &self.sess.target.target;\n             locate_ctxt.triple = target_triple;\n@@ -536,16 +529,10 @@ impl<'a> CrateLoader<'a> {\n             metadata: metadata,\n             dylib: dylib.map(|p| p.0),\n             target_only: target_only,\n-            name: info.name.to_string(),\n-            ident: info.ident.to_string(),\n-            span: span,\n-            should_link: should_link,\n         }\n     }\n \n-    pub fn read_macros(&mut self, item: &ast::Item) -> LoadedMacros {\n-        let ci = self.extract_crate_info(item).unwrap();\n-        let ekrate = self.read_extension_crate(item.span, &ci);\n+    fn read_macros(&mut self, item: &ast::Item, ekrate: &ExtensionCrate) -> LoadedMacros {\n         let root = ekrate.metadata.get_root();\n         let source_name = format!(\"<{} macros>\", item.ident);\n         let mut macro_rules = Vec::new();\n@@ -604,14 +591,6 @@ impl<'a> CrateLoader<'a> {\n             assert_eq!(macro_rules.len(), 0);\n             LoadedMacros::ProcMacros(self.load_derive_macros(item, id, root.hash, dylib))\n         } else {\n-            // If this crate is not a proc-macro crate then we might be able to\n-            // register it with the local crate store to prevent loading the\n-            // metadata twice.\n-            //\n-            // If it's a proc-macro crate, though, then we definitely don't\n-            // want to register it with the local crate store as we're just\n-            // going to use it as we would a plugin.\n-            ekrate.register(self);\n             LoadedMacros::MacroRules(macro_rules)\n         }\n     }\n@@ -917,22 +896,6 @@ impl<'a> CrateLoader<'a> {\n     }\n }\n \n-impl ExtensionCrate {\n-    fn register(self, loader: &mut CrateLoader) {\n-        if !self.should_link {\n-            return\n-        }\n-\n-        let library = match self.metadata {\n-            PMDSource::Owned(lib) => lib,\n-            PMDSource::Registered(_) => return,\n-        };\n-\n-        // Register crate now to avoid double-reading metadata\n-        loader.register_crate(&None, &self.ident, &self.name, self.span, library, true);\n-    }\n-}\n-\n impl<'a> CrateLoader<'a> {\n     pub fn preprocess(&mut self, krate: &ast::Crate) {\n         for attr in krate.attrs.iter().filter(|m| m.name() == \"link_args\") {\n@@ -1029,37 +992,44 @@ impl<'a> middle::cstore::CrateLoader for CrateLoader<'a> {\n             _ => return None,\n         }\n \n-        let loaded_macros = if load_macros { Some(self.read_macros(item)) } else { None };\n+        let info = self.extract_crate_info(item).unwrap();\n+        let loaded_macros = if load_macros {\n+            let ekrate = self.read_extension_crate(item.span, &info);\n+            let loaded_macros = self.read_macros(item, &ekrate);\n \n-        // If this `extern crate` item has `#[macro_use]` then we can safely skip it.\n-        // These annotations were processed during macro expansion and are already loaded\n-        // (if necessary) into our crate store.\n-        //\n-        // Note that it's important we *don't* fall through below as some `#[macro_use]`\n-        // crates are explicitly not linked (e.g. macro crates) so we want to ensure\n-        // we avoid `resolve_crate` with those.\n-        if let Some(LoadedMacros::CustomDerives(..)) = loaded_macros {\n-            return loaded_macros;\n-        }\n+            // If this is a proc-macro crate or `#[no_link]` crate, it is only used at compile time,\n+            // so we return here to avoid registering the crate.\n+            if loaded_macros.is_proc_macros() || !info.should_link {\n+                return Some(loaded_macros);\n+            }\n \n-        if let Some(info) = self.extract_crate_info(item) {\n-            if !info.should_link {\n-                return loaded_macros;\n+            // Register crate now to avoid double-reading metadata\n+            if let PMDSource::Owned(lib) = ekrate.metadata {\n+                if ekrate.target_only || config::host_triple() == self.sess.opts.target_triple {\n+                    let ExternCrateInfo { ref ident, ref name, .. } = info;\n+                    self.register_crate(&None, ident, name, item.span, lib, true);\n+                }\n             }\n \n-            let (cnum, ..) = self.resolve_crate(\n-                &None, &info.ident, &info.name, None, item.span, PathKind::Crate, true,\n-            );\n+            Some(loaded_macros)\n+        } else {\n+            if !info.should_link {\n+                return None;\n+            }\n+            None\n+        };\n \n-            let def_id = definitions.opt_local_def_id(item.id).unwrap();\n-            let len = definitions.def_path(def_id.index).data.len();\n+        let (cnum, ..) = self.resolve_crate(\n+            &None, &info.ident, &info.name, None, item.span, PathKind::Crate, true,\n+        );\n \n-            let extern_crate =\n-                ExternCrate { def_id: def_id, span: item.span, direct: true, path_len: len };\n-            self.update_extern_crate(cnum, extern_crate, &mut FnvHashSet());\n+        let def_id = definitions.opt_local_def_id(item.id).unwrap();\n+        let len = definitions.def_path(def_id.index).data.len();\n \n-            self.cstore.add_extern_mod_stmt_cnum(info.id, cnum);\n-        }\n+        let extern_crate =\n+            ExternCrate { def_id: def_id, span: item.span, direct: true, path_len: len };\n+        self.update_extern_crate(cnum, extern_crate, &mut FnvHashSet());\n+        self.cstore.add_extern_mod_stmt_cnum(info.id, cnum);\n \n         loaded_macros\n     }"}]}