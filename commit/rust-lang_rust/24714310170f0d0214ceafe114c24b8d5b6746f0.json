{"sha": "24714310170f0d0214ceafe114c24b8d5b6746f0", "node_id": "C_kwDOAAsO6NoAKDI0NzE0MzEwMTcwZjBkMDIxNGNlYWZlMTE0YzI0YjhkNWI2NzQ2ZjA", "commit": {"author": {"name": "Jack Huey", "email": "31162821+jackh726@users.noreply.github.com", "date": "2022-06-28T04:08:35Z"}, "committer": {"name": "Jack Huey", "email": "31162821+jackh726@users.noreply.github.com", "date": "2022-07-08T00:48:51Z"}, "message": "Move is_free and is_free_or_static to Region, change resolve_var to resolve_region, and remove RootEmptyRegion", "tree": {"sha": "1910507909895fcb0ff484b30c8ade3da172a562", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1910507909895fcb0ff484b30c8ade3da172a562"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/24714310170f0d0214ceafe114c24b8d5b6746f0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/24714310170f0d0214ceafe114c24b8d5b6746f0", "html_url": "https://github.com/rust-lang/rust/commit/24714310170f0d0214ceafe114c24b8d5b6746f0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/24714310170f0d0214ceafe114c24b8d5b6746f0/comments", "author": {"login": "jackh726", "id": 31162821, "node_id": "MDQ6VXNlcjMxMTYyODIx", "avatar_url": "https://avatars.githubusercontent.com/u/31162821?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jackh726", "html_url": "https://github.com/jackh726", "followers_url": "https://api.github.com/users/jackh726/followers", "following_url": "https://api.github.com/users/jackh726/following{/other_user}", "gists_url": "https://api.github.com/users/jackh726/gists{/gist_id}", "starred_url": "https://api.github.com/users/jackh726/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jackh726/subscriptions", "organizations_url": "https://api.github.com/users/jackh726/orgs", "repos_url": "https://api.github.com/users/jackh726/repos", "events_url": "https://api.github.com/users/jackh726/events{/privacy}", "received_events_url": "https://api.github.com/users/jackh726/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jackh726", "id": 31162821, "node_id": "MDQ6VXNlcjMxMTYyODIx", "avatar_url": "https://avatars.githubusercontent.com/u/31162821?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jackh726", "html_url": "https://github.com/jackh726", "followers_url": "https://api.github.com/users/jackh726/followers", "following_url": "https://api.github.com/users/jackh726/following{/other_user}", "gists_url": "https://api.github.com/users/jackh726/gists{/gist_id}", "starred_url": "https://api.github.com/users/jackh726/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jackh726/subscriptions", "organizations_url": "https://api.github.com/users/jackh726/orgs", "repos_url": "https://api.github.com/users/jackh726/repos", "events_url": "https://api.github.com/users/jackh726/events{/privacy}", "received_events_url": "https://api.github.com/users/jackh726/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1517f5de01c445b5124b30f02257b02b4c5ef3b2", "url": "https://api.github.com/repos/rust-lang/rust/commits/1517f5de01c445b5124b30f02257b02b4c5ef3b2", "html_url": "https://github.com/rust-lang/rust/commit/1517f5de01c445b5124b30f02257b02b4c5ef3b2"}], "stats": {"total": 93, "additions": 43, "deletions": 50}, "files": [{"sha": "ea3602e8a056a52010bf6b269e8c47539a3aa5c6", "filename": "compiler/rustc_borrowck/src/region_infer/mod.rs", "status": "modified", "additions": 7, "deletions": 11, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/24714310170f0d0214ceafe114c24b8d5b6746f0/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24714310170f0d0214ceafe114c24b8d5b6746f0/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs?ref=24714310170f0d0214ceafe114c24b8d5b6746f0", "patch": "@@ -495,8 +495,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                     }\n                 }\n \n-                NllRegionVariableOrigin::RootEmptyRegion\n-                | NllRegionVariableOrigin::Existential { .. } => {\n+                NllRegionVariableOrigin::Existential { .. } => {\n                     // For existential, regions, nothing to do.\n                 }\n             }\n@@ -1410,8 +1409,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                     self.check_bound_universal_region(fr, placeholder, errors_buffer);\n                 }\n \n-                NllRegionVariableOrigin::RootEmptyRegion\n-                | NllRegionVariableOrigin::Existential { .. } => {\n+                NllRegionVariableOrigin::Existential { .. } => {\n                     // nothing to check here\n                 }\n             }\n@@ -1513,8 +1511,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                     self.check_bound_universal_region(fr, placeholder, errors_buffer);\n                 }\n \n-                NllRegionVariableOrigin::RootEmptyRegion\n-                | NllRegionVariableOrigin::Existential { .. } => {\n+                NllRegionVariableOrigin::Existential { .. } => {\n                     // nothing to check here\n                 }\n             }\n@@ -1788,9 +1785,9 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                 universe1.cannot_name(placeholder.universe)\n             }\n \n-            NllRegionVariableOrigin::RootEmptyRegion\n-            | NllRegionVariableOrigin::FreeRegion\n-            | NllRegionVariableOrigin::Existential { .. } => false,\n+            NllRegionVariableOrigin::FreeRegion | NllRegionVariableOrigin::Existential { .. } => {\n+                false\n+            }\n         }\n     }\n \n@@ -2152,8 +2149,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         let blame_source = match from_region_origin {\n             NllRegionVariableOrigin::FreeRegion\n             | NllRegionVariableOrigin::Existential { from_forall: false } => true,\n-            NllRegionVariableOrigin::RootEmptyRegion\n-            | NllRegionVariableOrigin::Placeholder(_)\n+            NllRegionVariableOrigin::Placeholder(_)\n             | NllRegionVariableOrigin::Existential { from_forall: true } => false,\n         };\n "}, {"sha": "2a7713bc4df3b6d1e8be939ef07799a5c412f820", "filename": "compiler/rustc_borrowck/src/universal_regions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24714310170f0d0214ceafe114c24b8d5b6746f0/compiler%2Frustc_borrowck%2Fsrc%2Funiversal_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24714310170f0d0214ceafe114c24b8d5b6746f0/compiler%2Frustc_borrowck%2Fsrc%2Funiversal_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Funiversal_regions.rs?ref=24714310170f0d0214ceafe114c24b8d5b6746f0", "patch": "@@ -503,7 +503,7 @@ impl<'cx, 'tcx> UniversalRegionsBuilder<'cx, 'tcx> {\n \n         let root_empty = self\n             .infcx\n-            .next_nll_region_var(NllRegionVariableOrigin::RootEmptyRegion)\n+            .next_nll_region_var(NllRegionVariableOrigin::Existential { from_forall: true })\n             .to_region_vid();\n \n         UniversalRegions {"}, {"sha": "d566634a49203b9272a9ed4802f51f3d2fd70d04", "filename": "compiler/rustc_infer/src/infer/free_regions.rs", "status": "modified", "additions": 5, "deletions": 19, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/24714310170f0d0214ceafe114c24b8d5b6746f0/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ffree_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24714310170f0d0214ceafe114c24b8d5b6746f0/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ffree_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ffree_regions.rs?ref=24714310170f0d0214ceafe114c24b8d5b6746f0", "patch": "@@ -4,7 +4,7 @@\n //! and use that to decide when one free region outlives another, and so forth.\n \n use rustc_data_structures::transitive_relation::TransitiveRelation;\n-use rustc_middle::ty::{self, Lift, Region, TyCtxt};\n+use rustc_middle::ty::{Lift, Region, TyCtxt};\n \n /// Combines a `FreeRegionMap` and a `TyCtxt`.\n ///\n@@ -49,7 +49,7 @@ impl<'tcx> FreeRegionMap<'tcx> {\n     // (with the exception that `'static: 'x` is not notable)\n     pub fn relate_regions(&mut self, sub: Region<'tcx>, sup: Region<'tcx>) {\n         debug!(\"relate_regions(sub={:?}, sup={:?})\", sub, sup);\n-        if self.is_free_or_static(sub) && self.is_free(sup) {\n+        if sub.is_free_or_static() && sup.is_free() {\n             self.relation.add(sub, sup)\n         }\n     }\n@@ -68,7 +68,7 @@ impl<'tcx> FreeRegionMap<'tcx> {\n         r_a: Region<'tcx>,\n         r_b: Region<'tcx>,\n     ) -> bool {\n-        assert!(self.is_free_or_static(r_a) && self.is_free_or_static(r_b));\n+        assert!(r_a.is_free_or_static() && r_b.is_free_or_static());\n         let re_static = tcx.lifetimes.re_static;\n         if self.check_relation(re_static, r_b) {\n             // `'a <= 'static` is always true, and not stored in the\n@@ -85,20 +85,6 @@ impl<'tcx> FreeRegionMap<'tcx> {\n         r_a == r_b || self.relation.contains(r_a, r_b)\n     }\n \n-    /// True for free regions other than `'static`.\n-    pub fn is_free(&self, r: Region<'_>) -> bool {\n-        matches!(*r, ty::ReEarlyBound(_) | ty::ReFree(_))\n-    }\n-\n-    /// True if `r` is a free region or static of the sort that this\n-    /// free region map can be used with.\n-    pub fn is_free_or_static(&self, r: Region<'_>) -> bool {\n-        match *r {\n-            ty::ReStatic => true,\n-            _ => self.is_free(r),\n-        }\n-    }\n-\n     /// Computes the least-upper-bound of two free regions. In some\n     /// cases, this is more conservative than necessary, in order to\n     /// avoid making arbitrary choices. See\n@@ -110,8 +96,8 @@ impl<'tcx> FreeRegionMap<'tcx> {\n         r_b: Region<'tcx>,\n     ) -> Region<'tcx> {\n         debug!(\"lub_free_regions(r_a={:?}, r_b={:?})\", r_a, r_b);\n-        assert!(self.is_free(r_a));\n-        assert!(self.is_free(r_b));\n+        assert!(r_a.is_free());\n+        assert!(r_b.is_free());\n         let result = if r_a == r_b {\n             r_a\n         } else {"}, {"sha": "3783cfb4cc5c85c85aaf53e674bdfb7916a95ba8", "filename": "compiler/rustc_infer/src/infer/lexical_region_resolve/mod.rs", "status": "modified", "additions": 15, "deletions": 13, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/24714310170f0d0214ceafe114c24b8d5b6746f0/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flexical_region_resolve%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24714310170f0d0214ceafe114c24b8d5b6746f0/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flexical_region_resolve%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flexical_region_resolve%2Fmod.rs?ref=24714310170f0d0214ceafe114c24b8d5b6746f0", "patch": "@@ -47,7 +47,6 @@ pub(crate) fn resolve<'tcx>(\n #[derive(Clone)]\n pub struct LexicalRegionResolutions<'tcx> {\n     pub(crate) values: IndexVec<RegionVid, VarValue<'tcx>>,\n-    pub(crate) error_region: ty::Region<'tcx>,\n }\n \n #[derive(Copy, Clone, Debug)]\n@@ -140,7 +139,6 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n     /// empty region. The `expansion` phase will grow this larger.\n     fn construct_var_data(&self, tcx: TyCtxt<'tcx>) -> LexicalRegionResolutions<'tcx> {\n         LexicalRegionResolutions {\n-            error_region: tcx.lifetimes.re_static,\n             values: IndexVec::from_fn_n(\n                 |vid| {\n                     let vid_universe = self.var_infos[vid].universe;\n@@ -310,7 +308,7 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n \n         // Check for the case where we know that `'b: 'static` -- in that case,\n         // `a <= b` for all `a`.\n-        let b_free_or_static = self.region_rels.free_regions.is_free_or_static(b);\n+        let b_free_or_static = b.is_free_or_static();\n         if b_free_or_static && sub_free_regions(tcx.lifetimes.re_static, b) {\n             return true;\n         }\n@@ -320,7 +318,7 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n         // `lub` relationship defined below, since sometimes the \"lub\"\n         // is actually the `postdom_upper_bound` (see\n         // `TransitiveRelation` for more details).\n-        let a_free_or_static = self.region_rels.free_regions.is_free_or_static(a);\n+        let a_free_or_static = a.is_free_or_static();\n         if a_free_or_static && b_free_or_static {\n             return sub_free_regions(a, b);\n         }\n@@ -864,10 +862,7 @@ impl<'tcx> LexicalRegionResolutions<'tcx> {\n     where\n         T: TypeFoldable<'tcx>,\n     {\n-        tcx.fold_regions(value, |r, _db| match *r {\n-            ty::ReVar(rid) => self.resolve_var(rid),\n-            _ => r,\n-        })\n+        tcx.fold_regions(value, |r, _db| self.resolve_region(tcx, r))\n     }\n \n     fn value(&self, rid: RegionVid) -> &VarValue<'tcx> {\n@@ -878,12 +873,19 @@ impl<'tcx> LexicalRegionResolutions<'tcx> {\n         &mut self.values[rid]\n     }\n \n-    pub fn resolve_var(&self, rid: RegionVid) -> ty::Region<'tcx> {\n-        let result = match self.values[rid] {\n-            VarValue::Value(r) => r,\n-            VarValue::ErrorValue => self.error_region,\n+    pub(crate) fn resolve_region(\n+        &self,\n+        tcx: TyCtxt<'tcx>,\n+        r: ty::Region<'tcx>,\n+    ) -> ty::Region<'tcx> {\n+        let result = match *r {\n+            ty::ReVar(rid) => match self.values[rid] {\n+                VarValue::Value(r) => r,\n+                VarValue::ErrorValue => tcx.lifetimes.re_static,\n+            },\n+            _ => r,\n         };\n-        debug!(\"resolve_var({:?}) = {:?}\", rid, result);\n+        debug!(\"resolve_region({:?}) = {:?}\", r, result);\n         result\n     }\n }"}, {"sha": "6e0f2d687437b6bc38324f1ddcc45385a3c2f65f", "filename": "compiler/rustc_infer/src/infer/mod.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/24714310170f0d0214ceafe114c24b8d5b6746f0/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24714310170f0d0214ceafe114c24b8d5b6746f0/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs?ref=24714310170f0d0214ceafe114c24b8d5b6746f0", "patch": "@@ -466,9 +466,6 @@ pub enum NllRegionVariableOrigin {\n     /// from a `for<'a> T` binder). Meant to represent \"any region\".\n     Placeholder(ty::PlaceholderRegion),\n \n-    /// The variable we create to represent `'empty(U0)`.\n-    RootEmptyRegion,\n-\n     Existential {\n         /// If this is true, then this variable was created to represent a lifetime\n         /// bound in a `for` binder. For example, it might have been created to\n@@ -1250,7 +1247,6 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         };\n \n         let lexical_region_resolutions = LexicalRegionResolutions {\n-            error_region: self.tcx.lifetimes.re_static,\n             values: rustc_index::vec::IndexVec::from_elem_n(\n                 crate::infer::lexical_region_resolve::VarValue::Value(self.tcx.lifetimes.re_erased),\n                 var_infos.len(),"}, {"sha": "3d99f0958f7f9a7220a0c8d946272b7520564ae5", "filename": "compiler/rustc_infer/src/infer/resolve.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/24714310170f0d0214ceafe114c24b8d5b6746f0/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24714310170f0d0214ceafe114c24b8d5b6746f0/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fresolve.rs?ref=24714310170f0d0214ceafe114c24b8d5b6746f0", "patch": "@@ -206,13 +206,13 @@ impl<'a, 'tcx> FallibleTypeFolder<'tcx> for FullTypeResolver<'a, 'tcx> {\n \n     fn try_fold_region(&mut self, r: ty::Region<'tcx>) -> Result<ty::Region<'tcx>, Self::Error> {\n         match *r {\n-            ty::ReVar(rid) => Ok(self\n+            ty::ReVar(_) => Ok(self\n                 .infcx\n                 .lexical_region_resolutions\n                 .borrow()\n                 .as_ref()\n                 .expect(\"region resolution not performed\")\n-                .resolve_var(rid)),\n+                .resolve_region(self.infcx.tcx, r)),\n             _ => Ok(r),\n         }\n     }"}, {"sha": "03e4319bbf1a8fa1ad1e212d80aadfbf37d3133c", "filename": "compiler/rustc_middle/src/ty/sty.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/24714310170f0d0214ceafe114c24b8d5b6746f0/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24714310170f0d0214ceafe114c24b8d5b6746f0/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs?ref=24714310170f0d0214ceafe114c24b8d5b6746f0", "patch": "@@ -1570,6 +1570,19 @@ impl<'tcx> Region<'tcx> {\n             _ => bug!(\"free_region_binding_scope invoked on inappropriate region: {:?}\", self),\n         }\n     }\n+\n+    /// True for free regions other than `'static`.\n+    pub fn is_free(self) -> bool {\n+        matches!(*self, ty::ReEarlyBound(_) | ty::ReFree(_))\n+    }\n+\n+    /// True if `self` is a free region or static.\n+    pub fn is_free_or_static(self) -> bool {\n+        match *self {\n+            ty::ReStatic => true,\n+            _ => self.is_free(),\n+        }\n+    }\n }\n \n /// Type utilities"}]}