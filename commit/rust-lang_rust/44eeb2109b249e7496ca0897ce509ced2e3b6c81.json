{"sha": "44eeb2109b249e7496ca0897ce509ced2e3b6c81", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ0ZWViMjEwOWIyNDllNzQ5NmNhMDg5N2NlNTA5Y2VkMmUzYjZjODE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-06-16T03:31:09Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-06-16T03:31:09Z"}, "message": "Auto merge of #42578 - estebank:recover-binop, r=nikomatsakis\n\nLearn to parse `a as usize < b`\n\nParsing `a as usize > b` always works, but `a as usize < b` was a\nparsing error because the parser would think the `<` started a generic\ntype argument for `usize`. The parser now attempts to parse as before,\nand if a DiagnosticError is returned, try to parse again as a type with\nno generic arguments. If this fails, return the original\n`DiagnosticError`.\n\nFix #22644.", "tree": {"sha": "12e53491ade7b4815bc59f7b83e29eda605a5685", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/12e53491ade7b4815bc59f7b83e29eda605a5685"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/44eeb2109b249e7496ca0897ce509ced2e3b6c81", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/44eeb2109b249e7496ca0897ce509ced2e3b6c81", "html_url": "https://github.com/rust-lang/rust/commit/44eeb2109b249e7496ca0897ce509ced2e3b6c81", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/44eeb2109b249e7496ca0897ce509ced2e3b6c81/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a3114961a1c6b8a16cd06a854d585377ac576d47", "url": "https://api.github.com/repos/rust-lang/rust/commits/a3114961a1c6b8a16cd06a854d585377ac576d47", "html_url": "https://github.com/rust-lang/rust/commit/a3114961a1c6b8a16cd06a854d585377ac576d47"}, {"sha": "ad260ffc884477686e8f6f52c97a417bf99e2f19", "url": "https://api.github.com/repos/rust-lang/rust/commits/ad260ffc884477686e8f6f52c97a417bf99e2f19", "html_url": "https://github.com/rust-lang/rust/commit/ad260ffc884477686e8f6f52c97a417bf99e2f19"}], "stats": {"total": 149, "additions": 140, "deletions": 9}, "files": [{"sha": "d7c21127474a49053b001133ce9f8e7ee8cf5b84", "filename": "src/librustc_errors/diagnostic.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/44eeb2109b249e7496ca0897ce509ced2e3b6c81/src%2Flibrustc_errors%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44eeb2109b249e7496ca0897ce509ced2e3b6c81/src%2Flibrustc_errors%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Fdiagnostic.rs?ref=44eeb2109b249e7496ca0897ce509ced2e3b6c81", "patch": "@@ -248,6 +248,10 @@ impl Diagnostic {\n         self.message.iter().map(|i| i.0.to_owned()).collect::<String>()\n     }\n \n+    pub fn set_message(&mut self, message: &str) {\n+        self.message = vec![(message.to_owned(), Style::NoStyle)];\n+    }\n+\n     pub fn styled_message(&self) -> &Vec<(String, Style)> {\n         &self.message\n     }"}, {"sha": "0b145c54f619c575bbc736f5d80104676faadd44", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 91, "deletions": 9, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/44eeb2109b249e7496ca0897ce509ced2e3b6c81/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44eeb2109b249e7496ca0897ce509ced2e3b6c81/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=44eeb2109b249e7496ca0897ce509ced2e3b6c81", "patch": "@@ -150,7 +150,7 @@ fn maybe_append(mut lhs: Vec<Attribute>, rhs: Option<Vec<Attribute>>)\n     lhs\n }\n \n-#[derive(PartialEq)]\n+#[derive(Clone, PartialEq)]\n enum PrevTokenKind {\n     DocComment,\n     Comma,\n@@ -162,6 +162,7 @@ enum PrevTokenKind {\n \n /* ident is handled by common.rs */\n \n+#[derive(Clone)]\n pub struct Parser<'a> {\n     pub sess: &'a ParseSess,\n     /// the current token:\n@@ -193,11 +194,13 @@ pub struct Parser<'a> {\n }\n \n \n+#[derive(Clone)]\n struct TokenCursor {\n     frame: TokenCursorFrame,\n     stack: Vec<TokenCursorFrame>,\n }\n \n+#[derive(Clone)]\n struct TokenCursorFrame {\n     delim: token::DelimToken,\n     span: Span,\n@@ -397,6 +400,7 @@ impl Error {\n     }\n }\n \n+#[derive(Debug)]\n pub enum LhsExpr {\n     NotYetParsed,\n     AttributesParsed(ThinVec<Attribute>),\n@@ -1721,7 +1725,7 @@ impl<'a> Parser<'a> {\n \n         let segments = match mode {\n             PathStyle::Type => {\n-                self.parse_path_segments_without_colons()?\n+                self.parse_path_segments_without_colons(true)?\n             }\n             PathStyle::Expr => {\n                 self.parse_path_segments_with_colons()?\n@@ -1742,6 +1746,16 @@ impl<'a> Parser<'a> {\n     /// bounds are permitted and whether `::` must precede type parameter\n     /// groups.\n     pub fn parse_path(&mut self, mode: PathStyle) -> PResult<'a, ast::Path> {\n+        self.parse_path_common(mode, true)\n+    }\n+\n+    pub fn parse_path_without_generics(&mut self, mode: PathStyle) -> PResult<'a, ast::Path> {\n+        self.parse_path_common(mode, false)\n+    }\n+\n+    fn parse_path_common(&mut self, mode: PathStyle, parse_generics: bool)\n+        -> PResult<'a, ast::Path>\n+    {\n         maybe_whole!(self, NtPath, |x| x);\n \n         let lo = self.meta_var_span.unwrap_or(self.span);\n@@ -1752,7 +1766,7 @@ impl<'a> Parser<'a> {\n         // A bound set is a set of type parameter bounds.\n         let mut segments = match mode {\n             PathStyle::Type => {\n-                self.parse_path_segments_without_colons()?\n+                self.parse_path_segments_without_colons(parse_generics)?\n             }\n             PathStyle::Expr => {\n                 self.parse_path_segments_with_colons()?\n@@ -1797,7 +1811,9 @@ impl<'a> Parser<'a> {\n     /// - `a::b<T,U>::c<V,W>`\n     /// - `a::b<T,U>::c(V) -> W`\n     /// - `a::b<T,U>::c(V)`\n-    pub fn parse_path_segments_without_colons(&mut self) -> PResult<'a, Vec<PathSegment>> {\n+    pub fn parse_path_segments_without_colons(&mut self, parse_generics: bool)\n+        -> PResult<'a, Vec<PathSegment>>\n+    {\n         let mut segments = Vec::new();\n         loop {\n             // First, parse an identifier.\n@@ -1816,7 +1832,7 @@ impl<'a> Parser<'a> {\n             }\n \n             // Parse types, optionally.\n-            let parameters = if self.eat_lt() {\n+            let parameters = if parse_generics && self.eat_lt() {\n                 let (lifetimes, types, bindings) = self.parse_generic_args()?;\n                 self.expect_gt()?;\n                 ast::AngleBracketedParameterData {\n@@ -2795,8 +2811,9 @@ impl<'a> Parser<'a> {\n             }\n             // Special cases:\n             if op == AssocOp::As {\n-                let rhs = self.parse_ty_no_plus()?;\n-                lhs = self.mk_expr(lhs_span.to(rhs.span), ExprKind::Cast(lhs, rhs), ThinVec::new());\n+                // Save the state of the parser before parsing type normally, in case there is a\n+                // LessThan comparison after this cast.\n+                lhs = self.parse_assoc_op_as(lhs, lhs_span)?;\n                 continue\n             } else if op == AssocOp::Colon {\n                 let rhs = self.parse_ty_no_plus()?;\n@@ -2894,11 +2911,74 @@ impl<'a> Parser<'a> {\n         Ok(lhs)\n     }\n \n+    fn parse_assoc_op_as(&mut self, lhs: P<Expr>, lhs_span: Span) -> PResult<'a, P<Expr>> {\n+        let rp = self.clone();\n+        match self.parse_ty_no_plus() {\n+            Ok(rhs) => {\n+                Ok(self.mk_expr(lhs_span.to(rhs.span),\n+                                ExprKind::Cast(lhs, rhs),\n+                                ThinVec::new()))\n+            }\n+            Err(mut err) => {\n+                let rp_err = self.clone();\n+                let sp = rp_err.span.clone();\n+\n+                // Rewind to before attempting to parse the type with generics, to get\n+                // arround #22644.\n+                mem::replace(self, rp);\n+                let lo = self.span;\n+                match self.parse_path_without_generics(PathStyle::Type) {\n+                    Ok(path) => {\n+                        // Successfully parsed the type leaving a `<` yet to parse\n+                        err.cancel();\n+                        let codemap = self.sess.codemap();\n+                        let suggestion_span = lhs_span.to(self.prev_span);\n+                        let suggestion = match codemap.span_to_snippet(suggestion_span) {\n+                            Ok(lstring) => format!(\"({})\", lstring),\n+                            _ => format!(\"(<expression> as <type>)\")\n+                        };\n+                        let warn_message = match codemap.span_to_snippet(self.prev_span) {\n+                            Ok(lstring) => format!(\"`{}`\", lstring),\n+                            _ => \"a type\".to_string(),\n+                        };\n+                        let msg = format!(\"`<` is interpreted as a start of generic \\\n+                                           arguments for {}, not a comparison\",\n+                                          warn_message);\n+                        let mut err = self.sess.span_diagnostic.struct_span_err(sp, &msg);\n+                        err.span_label(sp, \"interpreted as generic argument\");\n+                        err.span_label(self.span, \"not interpreted as comparison\");\n+                        err.span_suggestion(suggestion_span,\n+                                            \"if you want to compare the casted value then write:\",\n+                                            suggestion);\n+                        err.emit();\n+\n+                        let path = TyKind::Path(None, path);\n+                        let span = lo.to(self.prev_span);\n+                        let rhs = P(Ty { node: path, span: span, id: ast::DUMMY_NODE_ID });\n+                        // Letting the parser accept the recovered type to avoid further errors,\n+                        // but the code will still not compile due to the error emitted above.\n+                        Ok(self.mk_expr(lhs_span.to(rhs.span),\n+                                        ExprKind::Cast(lhs, rhs),\n+                                        ThinVec::new()))\n+                    }\n+                    Err(mut path_err) => {\n+                        // Still couldn't parse, return original error and parser state\n+                        path_err.cancel();\n+                        mem::replace(self, rp_err);\n+                        Err(err)\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n     /// Produce an error if comparison operators are chained (RFC #558).\n     /// We only need to check lhs, not rhs, because all comparison ops\n     /// have same precedence and are left-associative\n     fn check_no_chained_comparison(&mut self, lhs: &Expr, outer_op: &AssocOp) {\n-        debug_assert!(outer_op.is_comparison());\n+        debug_assert!(outer_op.is_comparison(),\n+                      \"check_no_chained_comparison: {:?} is not comparison\",\n+                      outer_op);\n         match lhs.node {\n             ExprKind::Binary(op, _, _) if op.node.is_comparison() => {\n                 // respan to include both operators\n@@ -2922,7 +3002,9 @@ impl<'a> Parser<'a> {\n     fn parse_prefix_range_expr(&mut self,\n                                already_parsed_attrs: Option<ThinVec<Attribute>>)\n                                -> PResult<'a, P<Expr>> {\n-        debug_assert!(self.token == token::DotDot || self.token == token::DotDotDot);\n+        debug_assert!(self.token == token::DotDot || self.token == token::DotDotDot,\n+                      \"parse_prefix_range_expr: token {:?} is not DotDot or DotDotDot\",\n+                      self.token);\n         let tok = self.token.clone();\n         let attrs = self.parse_or_use_outer_attributes(already_parsed_attrs)?;\n         let lo = self.span;"}, {"sha": "963482fc223f1befa6c0a518db4f9c8c4084efd4", "filename": "src/libsyntax/tokenstream.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/44eeb2109b249e7496ca0897ce509ced2e3b6c81/src%2Flibsyntax%2Ftokenstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44eeb2109b249e7496ca0897ce509ced2e3b6c81/src%2Flibsyntax%2Ftokenstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftokenstream.rs?ref=44eeb2109b249e7496ca0897ce509ced2e3b6c81", "patch": "@@ -227,14 +227,17 @@ impl TokenStream {\n     }\n }\n \n+#[derive(Clone)]\n pub struct Cursor(CursorKind);\n \n+#[derive(Clone)]\n enum CursorKind {\n     Empty,\n     Tree(TokenTree, bool /* consumed? */),\n     Stream(StreamCursor),\n }\n \n+#[derive(Clone)]\n struct StreamCursor {\n     stream: RcSlice<TokenStream>,\n     index: usize,"}, {"sha": "9269180396c5481ccaef648a9d640af194f5af37", "filename": "src/test/ui/issue-22644.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/44eeb2109b249e7496ca0897ce509ced2e3b6c81/src%2Ftest%2Fui%2Fissue-22644.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44eeb2109b249e7496ca0897ce509ced2e3b6c81/src%2Ftest%2Fui%2Fissue-22644.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-22644.rs?ref=44eeb2109b249e7496ca0897ce509ced2e3b6c81", "patch": "@@ -0,0 +1,18 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn main() {\n+    let a : u32 = 0;\n+    let b : usize = 0;\n+\n+    println!(\"{}\", a as usize > b);\n+    println!(\"{}\", a as usize < b);\n+    println!(\"{}\", a as usize < 4);\n+}"}, {"sha": "a22496357d9915f12528a5839f563744fdfff490", "filename": "src/test/ui/issue-22644.stderr", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/44eeb2109b249e7496ca0897ce509ced2e3b6c81/src%2Ftest%2Fui%2Fissue-22644.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/44eeb2109b249e7496ca0897ce509ced2e3b6c81/src%2Ftest%2Fui%2Fissue-22644.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-22644.stderr?ref=44eeb2109b249e7496ca0897ce509ced2e3b6c81", "patch": "@@ -0,0 +1,24 @@\n+error: `<` is interpreted as a start of generic arguments for `usize`, not a comparison\n+  --> $DIR/issue-22644.rs:16:33\n+   |\n+16 |     println!(\"{}\", a as usize < b);\n+   |                               - ^ interpreted as generic argument\n+   |                               |\n+   |                               not interpreted as comparison\n+   |\n+help: if you want to compare the casted value then write:\n+   |     println!(\"{}\", (a as usize) < b);\n+\n+error: `<` is interpreted as a start of generic arguments for `usize`, not a comparison\n+  --> $DIR/issue-22644.rs:17:33\n+   |\n+17 |     println!(\"{}\", a as usize < 4);\n+   |                               - ^ interpreted as generic argument\n+   |                               |\n+   |                               not interpreted as comparison\n+   |\n+help: if you want to compare the casted value then write:\n+   |     println!(\"{}\", (a as usize) < 4);\n+\n+error: aborting due to previous error(s)\n+"}]}