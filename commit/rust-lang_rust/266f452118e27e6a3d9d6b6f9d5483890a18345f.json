{"sha": "266f452118e27e6a3d9d6b6f9d5483890a18345f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI2NmY0NTIxMThlMjdlNmEzZDlkNmI2ZjlkNTQ4Mzg5MGExODM0NWY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-05-10T15:08:08Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-05-10T15:08:08Z"}, "message": "Auto merge of #85150 - Dylan-DPC:rollup-q26gbx3, r=Dylan-DPC\n\nRollup of 6 pull requests\n\nSuccessful merges:\n\n - #85050 (Fix suggestions for missing return type lifetime specifiers)\n - #85075 (Improve \"panic message is not a string literal\" warning)\n - #85096 (Make unchecked_{add,sub,mul} inherent methods unstably const)\n - #85112 (ensure failing promoteds in const/static bodies are handled correctly)\n - #85146 (Provide io::Seek::rewind)\n - #85147 (:arrow_up: rust-analyzer)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "f7c265a409313ccccae721461c059e78dc0d8eb0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f7c265a409313ccccae721461c059e78dc0d8eb0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/266f452118e27e6a3d9d6b6f9d5483890a18345f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/266f452118e27e6a3d9d6b6f9d5483890a18345f", "html_url": "https://github.com/rust-lang/rust/commit/266f452118e27e6a3d9d6b6f9d5483890a18345f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/266f452118e27e6a3d9d6b6f9d5483890a18345f/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "544d124b81fb54e1904b6cd53de9bf92b6b3d0b9", "url": "https://api.github.com/repos/rust-lang/rust/commits/544d124b81fb54e1904b6cd53de9bf92b6b3d0b9", "html_url": "https://github.com/rust-lang/rust/commit/544d124b81fb54e1904b6cd53de9bf92b6b3d0b9"}, {"sha": "e76340191edaa9a517db8e670a73ff24143aeb23", "url": "https://api.github.com/repos/rust-lang/rust/commits/e76340191edaa9a517db8e670a73ff24143aeb23", "html_url": "https://github.com/rust-lang/rust/commit/e76340191edaa9a517db8e670a73ff24143aeb23"}], "stats": {"total": 900, "additions": 707, "deletions": 193}, "files": [{"sha": "14ccced2c6a56678fd4e6f4ac2d5d34555a57c52", "filename": "compiler/rustc_errors/src/diagnostic.rs", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/266f452118e27e6a3d9d6b6f9d5483890a18345f/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/266f452118e27e6a3d9d6b6f9d5483890a18345f/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic.rs?ref=266f452118e27e6a3d9d6b6f9d5483890a18345f", "patch": "@@ -282,6 +282,22 @@ impl Diagnostic {\n         msg: &str,\n         suggestion: Vec<(Span, String)>,\n         applicability: Applicability,\n+    ) -> &mut Self {\n+        self.multipart_suggestion_with_style(\n+            msg,\n+            suggestion,\n+            applicability,\n+            SuggestionStyle::ShowCode,\n+        )\n+    }\n+\n+    /// [`Diagnostic::multipart_suggestion()`] but you can set the [`SuggestionStyle`].\n+    pub fn multipart_suggestion_with_style(\n+        &mut self,\n+        msg: &str,\n+        suggestion: Vec<(Span, String)>,\n+        applicability: Applicability,\n+        style: SuggestionStyle,\n     ) -> &mut Self {\n         assert!(!suggestion.is_empty());\n         self.suggestions.push(CodeSuggestion {\n@@ -292,7 +308,7 @@ impl Diagnostic {\n                     .collect(),\n             }],\n             msg: msg.to_owned(),\n-            style: SuggestionStyle::ShowCode,\n+            style,\n             applicability,\n             tool_metadata: Default::default(),\n         });"}, {"sha": "070bc3522a453c28cc59199bb086b585ab6e4d83", "filename": "compiler/rustc_lint/src/non_fmt_panic.rs", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/266f452118e27e6a3d9d6b6f9d5483890a18345f/compiler%2Frustc_lint%2Fsrc%2Fnon_fmt_panic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/266f452118e27e6a3d9d6b6f9d5483890a18345f/compiler%2Frustc_lint%2Fsrc%2Fnon_fmt_panic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fnon_fmt_panic.rs?ref=266f452118e27e6a3d9d6b6f9d5483890a18345f", "patch": "@@ -4,7 +4,7 @@ use rustc_errors::{pluralize, Applicability};\n use rustc_hir as hir;\n use rustc_middle::ty;\n use rustc_parse_format::{ParseMode, Parser, Piece};\n-use rustc_span::{sym, symbol::kw, InnerSpan, Span, Symbol};\n+use rustc_span::{hygiene, sym, symbol::kw, symbol::SymbolStr, InnerSpan, Span, Symbol};\n \n declare_lint! {\n     /// The `non_fmt_panic` lint detects `panic!(..)` invocations where the first\n@@ -67,7 +67,7 @@ fn check_panic<'tcx>(cx: &LateContext<'tcx>, f: &'tcx hir::Expr<'tcx>, arg: &'tc\n \n     // The argument is *not* a string literal.\n \n-    let (span, panic) = panic_call(cx, f);\n+    let (span, panic, symbol_str) = panic_call(cx, f);\n \n     // Find the span of the argument to `panic!()`, before expansion in the\n     // case of `panic!(some_macro!())`.\n@@ -95,7 +95,7 @@ fn check_panic<'tcx>(cx: &LateContext<'tcx>, f: &'tcx hir::Expr<'tcx>, arg: &'tc\n         }\n         if arg_macro.map_or(false, |id| cx.tcx.is_diagnostic_item(sym::format_macro, id)) {\n             // A case of `panic!(format!(..))`.\n-            l.note(\"the panic!() macro supports formatting, so there's no need for the format!() macro here\");\n+            l.note(format!(\"the {}!() macro supports formatting, so there's no need for the format!() macro here\", symbol_str).as_str());\n             if let Some((open, close, _)) = find_delimiters(cx, arg_span) {\n                 l.multipart_suggestion(\n                     \"remove the `format!(..)` macro call\",\n@@ -160,7 +160,7 @@ fn check_panic_str<'tcx>(\n         Parser::new(fmt.as_ref(), style, snippet.clone(), false, ParseMode::Format);\n     let n_arguments = (&mut fmt_parser).filter(|a| matches!(a, Piece::NextArgument(_))).count();\n \n-    let (span, _) = panic_call(cx, f);\n+    let (span, _, _) = panic_call(cx, f);\n \n     if n_arguments > 0 && fmt_parser.errors.is_empty() {\n         let arg_spans: Vec<_> = match &fmt_parser.arg_places[..] {\n@@ -230,7 +230,7 @@ fn find_delimiters<'tcx>(cx: &LateContext<'tcx>, span: Span) -> Option<(Span, Sp\n     ))\n }\n \n-fn panic_call<'tcx>(cx: &LateContext<'tcx>, f: &'tcx hir::Expr<'tcx>) -> (Span, Symbol) {\n+fn panic_call<'tcx>(cx: &LateContext<'tcx>, f: &'tcx hir::Expr<'tcx>) -> (Span, Symbol, SymbolStr) {\n     let mut expn = f.span.ctxt().outer_expn_data();\n \n     let mut panic_macro = kw::Empty;\n@@ -248,5 +248,10 @@ fn panic_call<'tcx>(cx: &LateContext<'tcx>, f: &'tcx hir::Expr<'tcx>) -> (Span,\n         }\n     }\n \n-    (expn.call_site, panic_macro)\n+    let macro_symbol = if let hygiene::ExpnKind::Macro(_, symbol) = expn.kind {\n+        symbol\n+    } else {\n+        Symbol::intern(\"panic\")\n+    };\n+    (expn.call_site, panic_macro, macro_symbol.as_str())\n }"}, {"sha": "fdde687d4866c57913ca31bcb8de7394f24b4ed8", "filename": "compiler/rustc_resolve/src/late/diagnostics.rs", "status": "modified", "additions": 191, "deletions": 143, "changes": 334, "blob_url": "https://github.com/rust-lang/rust/blob/266f452118e27e6a3d9d6b6f9d5483890a18345f/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/266f452118e27e6a3d9d6b6f9d5483890a18345f/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs?ref=266f452118e27e6a3d9d6b6f9d5483890a18345f", "patch": "@@ -9,7 +9,7 @@ use rustc_ast::visit::FnKind;\n use rustc_ast::{self as ast, Expr, ExprKind, Item, ItemKind, NodeId, Path, Ty, TyKind};\n use rustc_ast_pretty::pprust::path_segment_to_string;\n use rustc_data_structures::fx::FxHashSet;\n-use rustc_errors::{pluralize, struct_span_err, Applicability, DiagnosticBuilder};\n+use rustc_errors::{pluralize, struct_span_err, Applicability, DiagnosticBuilder, SuggestionStyle};\n use rustc_hir as hir;\n use rustc_hir::def::Namespace::{self, *};\n use rustc_hir::def::{self, CtorKind, CtorOf, DefKind};\n@@ -1687,12 +1687,12 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n impl<'tcx> LifetimeContext<'_, 'tcx> {\n     crate fn report_missing_lifetime_specifiers(\n         &self,\n-        span: Span,\n+        spans: Vec<Span>,\n         count: usize,\n     ) -> DiagnosticBuilder<'tcx> {\n         struct_span_err!(\n             self.tcx.sess,\n-            span,\n+            spans,\n             E0106,\n             \"missing lifetime specifier{}\",\n             pluralize!(count)\n@@ -1821,81 +1821,107 @@ impl<'tcx> LifetimeContext<'_, 'tcx> {\n     crate fn add_missing_lifetime_specifiers_label(\n         &self,\n         err: &mut DiagnosticBuilder<'_>,\n-        span: Span,\n-        count: usize,\n+        spans_with_counts: Vec<(Span, usize)>,\n         lifetime_names: &FxHashSet<Symbol>,\n         lifetime_spans: Vec<Span>,\n         params: &[ElisionFailureInfo],\n     ) {\n-        let snippet = self.tcx.sess.source_map().span_to_snippet(span).ok();\n-\n-        err.span_label(\n-            span,\n-            &format!(\n-                \"expected {} lifetime parameter{}\",\n-                if count == 1 { \"named\".to_string() } else { count.to_string() },\n-                pluralize!(count)\n-            ),\n-        );\n+        let snippets: Vec<Option<String>> = spans_with_counts\n+            .iter()\n+            .map(|(span, _)| self.tcx.sess.source_map().span_to_snippet(*span).ok())\n+            .collect();\n \n-        let suggest_existing = |err: &mut DiagnosticBuilder<'_>,\n-                                name: &str,\n-                                formatter: &dyn Fn(&str) -> String| {\n-            if let Some(MissingLifetimeSpot::HigherRanked { span: for_span, span_type }) =\n-                self.missing_named_lifetime_spots.iter().rev().next()\n-            {\n-                // When we have `struct S<'a>(&'a dyn Fn(&X) -> &X);` we want to not only suggest\n-                // using `'a`, but also introduce the concept of HRLTs by suggesting\n-                // `struct S<'a>(&'a dyn for<'b> Fn(&X) -> &'b X);`. (#72404)\n-                let mut introduce_suggestion = vec![];\n+        for (span, count) in &spans_with_counts {\n+            err.span_label(\n+                *span,\n+                format!(\n+                    \"expected {} lifetime parameter{}\",\n+                    if *count == 1 { \"named\".to_string() } else { count.to_string() },\n+                    pluralize!(*count),\n+                ),\n+            );\n+        }\n \n-                let a_to_z_repeat_n = |n| {\n-                    (b'a'..=b'z').map(move |c| {\n-                        let mut s = '\\''.to_string();\n-                        s.extend(std::iter::repeat(char::from(c)).take(n));\n-                        s\n-                    })\n-                };\n+        let suggest_existing =\n+            |err: &mut DiagnosticBuilder<'_>,\n+             name: &str,\n+             formatters: Vec<Option<Box<dyn Fn(&str) -> String>>>| {\n+                if let Some(MissingLifetimeSpot::HigherRanked { span: for_span, span_type }) =\n+                    self.missing_named_lifetime_spots.iter().rev().next()\n+                {\n+                    // When we have `struct S<'a>(&'a dyn Fn(&X) -> &X);` we want to not only suggest\n+                    // using `'a`, but also introduce the concept of HRLTs by suggesting\n+                    // `struct S<'a>(&'a dyn for<'b> Fn(&X) -> &'b X);`. (#72404)\n+                    let mut introduce_suggestion = vec![];\n+\n+                    let a_to_z_repeat_n = |n| {\n+                        (b'a'..=b'z').map(move |c| {\n+                            let mut s = '\\''.to_string();\n+                            s.extend(std::iter::repeat(char::from(c)).take(n));\n+                            s\n+                        })\n+                    };\n \n-                // If all single char lifetime names are present, we wrap around and double the chars.\n-                let lt_name = (1..)\n-                    .flat_map(a_to_z_repeat_n)\n-                    .find(|lt| !lifetime_names.contains(&Symbol::intern(&lt)))\n-                    .unwrap();\n-                let msg = format!(\n-                    \"consider making the {} lifetime-generic with a new `{}` lifetime\",\n-                    span_type.descr(),\n-                    lt_name,\n-                );\n-                err.note(\n-                    \"for more information on higher-ranked polymorphism, visit \\\n+                    // If all single char lifetime names are present, we wrap around and double the chars.\n+                    let lt_name = (1..)\n+                        .flat_map(a_to_z_repeat_n)\n+                        .find(|lt| !lifetime_names.contains(&Symbol::intern(&lt)))\n+                        .unwrap();\n+                    let msg = format!(\n+                        \"consider making the {} lifetime-generic with a new `{}` lifetime\",\n+                        span_type.descr(),\n+                        lt_name,\n+                    );\n+                    err.note(\n+                        \"for more information on higher-ranked polymorphism, visit \\\n                     https://doc.rust-lang.org/nomicon/hrtb.html\",\n-                );\n-                let for_sugg = span_type.suggestion(&lt_name);\n-                for param in params {\n-                    if let Ok(snippet) = self.tcx.sess.source_map().span_to_snippet(param.span) {\n-                        if snippet.starts_with('&') && !snippet.starts_with(\"&'\") {\n-                            introduce_suggestion\n-                                .push((param.span, format!(\"&{} {}\", lt_name, &snippet[1..])));\n-                        } else if let Some(stripped) = snippet.strip_prefix(\"&'_ \") {\n-                            introduce_suggestion\n-                                .push((param.span, format!(\"&{} {}\", lt_name, stripped)));\n+                    );\n+                    let for_sugg = span_type.suggestion(&lt_name);\n+                    for param in params {\n+                        if let Ok(snippet) = self.tcx.sess.source_map().span_to_snippet(param.span)\n+                        {\n+                            if snippet.starts_with('&') && !snippet.starts_with(\"&'\") {\n+                                introduce_suggestion\n+                                    .push((param.span, format!(\"&{} {}\", lt_name, &snippet[1..])));\n+                            } else if let Some(stripped) = snippet.strip_prefix(\"&'_ \") {\n+                                introduce_suggestion\n+                                    .push((param.span, format!(\"&{} {}\", lt_name, stripped)));\n+                            }\n+                        }\n+                    }\n+                    introduce_suggestion.push((*for_span, for_sugg));\n+                    for ((span, _), formatter) in spans_with_counts.iter().zip(formatters.iter()) {\n+                        if let Some(formatter) = formatter {\n+                            introduce_suggestion.push((*span, formatter(&lt_name)));\n                         }\n                     }\n+                    err.multipart_suggestion_with_style(\n+                        &msg,\n+                        introduce_suggestion,\n+                        Applicability::MaybeIncorrect,\n+                        SuggestionStyle::ShowAlways,\n+                    );\n                 }\n-                introduce_suggestion.push((*for_span, for_sugg));\n-                introduce_suggestion.push((span, formatter(&lt_name)));\n-                err.multipart_suggestion(&msg, introduce_suggestion, Applicability::MaybeIncorrect);\n-            }\n \n-            err.span_suggestion_verbose(\n-                span,\n-                &format!(\"consider using the `{}` lifetime\", lifetime_names.iter().next().unwrap()),\n-                formatter(name),\n-                Applicability::MaybeIncorrect,\n-            );\n-        };\n-        let suggest_new = |err: &mut DiagnosticBuilder<'_>, sugg: &str| {\n+                let spans_suggs: Vec<_> = formatters\n+                    .into_iter()\n+                    .zip(spans_with_counts.iter())\n+                    .filter_map(|(fmt, (span, _))| {\n+                        if let Some(formatter) = fmt { Some((formatter, span)) } else { None }\n+                    })\n+                    .map(|(formatter, span)| (*span, formatter(name)))\n+                    .collect();\n+                err.multipart_suggestion_with_style(\n+                    &format!(\n+                        \"consider using the `{}` lifetime\",\n+                        lifetime_names.iter().next().unwrap()\n+                    ),\n+                    spans_suggs,\n+                    Applicability::MaybeIncorrect,\n+                    SuggestionStyle::ShowAlways,\n+                );\n+            };\n+        let suggest_new = |err: &mut DiagnosticBuilder<'_>, suggs: Vec<Option<String>>| {\n             for missing in self.missing_named_lifetime_spots.iter().rev() {\n                 let mut introduce_suggestion = vec![];\n                 let msg;\n@@ -1940,38 +1966,44 @@ impl<'tcx> LifetimeContext<'_, 'tcx> {\n                         (*span, span_type.suggestion(\"'a\"))\n                     }\n                     MissingLifetimeSpot::Static => {\n-                        let (span, sugg) = match snippet.as_deref() {\n-                            Some(\"&\") => (span.shrink_to_hi(), \"'static \".to_owned()),\n-                            Some(\"'_\") => (span, \"'static\".to_owned()),\n-                            Some(snippet) if !snippet.ends_with('>') => {\n-                                if snippet == \"\" {\n-                                    (\n-                                        span,\n-                                        std::iter::repeat(\"'static\")\n-                                            .take(count)\n-                                            .collect::<Vec<_>>()\n-                                            .join(\", \"),\n-                                    )\n-                                } else {\n-                                    (\n-                                        span.shrink_to_hi(),\n-                                        format!(\n-                                            \"<{}>\",\n+                        let mut spans_suggs = Vec::new();\n+                        for ((span, count), snippet) in\n+                            spans_with_counts.iter().copied().zip(snippets.iter())\n+                        {\n+                            let (span, sugg) = match snippet.as_deref() {\n+                                Some(\"&\") => (span.shrink_to_hi(), \"'static \".to_owned()),\n+                                Some(\"'_\") => (span, \"'static\".to_owned()),\n+                                Some(snippet) if !snippet.ends_with('>') => {\n+                                    if snippet == \"\" {\n+                                        (\n+                                            span,\n                                             std::iter::repeat(\"'static\")\n                                                 .take(count)\n                                                 .collect::<Vec<_>>()\n-                                                .join(\", \")\n-                                        ),\n-                                    )\n+                                                .join(\", \"),\n+                                        )\n+                                    } else {\n+                                        (\n+                                            span.shrink_to_hi(),\n+                                            format!(\n+                                                \"<{}>\",\n+                                                std::iter::repeat(\"'static\")\n+                                                    .take(count)\n+                                                    .collect::<Vec<_>>()\n+                                                    .join(\", \")\n+                                            ),\n+                                        )\n+                                    }\n                                 }\n-                            }\n-                            _ => continue,\n-                        };\n-                        err.span_suggestion_verbose(\n-                            span,\n+                                _ => continue,\n+                            };\n+                            spans_suggs.push((span, sugg.to_string()));\n+                        }\n+                        err.multipart_suggestion_with_style(\n                             \"consider using the `'static` lifetime\",\n-                            sugg.to_string(),\n+                            spans_suggs,\n                             Applicability::MaybeIncorrect,\n+                            SuggestionStyle::ShowAlways,\n                         );\n                         continue;\n                     }\n@@ -1986,77 +2018,93 @@ impl<'tcx> LifetimeContext<'_, 'tcx> {\n                         }\n                     }\n                 }\n-                introduce_suggestion.push((span, sugg.to_string()));\n-                err.multipart_suggestion(&msg, introduce_suggestion, Applicability::MaybeIncorrect);\n+                for ((span, _), sugg) in spans_with_counts.iter().copied().zip(suggs.iter()) {\n+                    if let Some(sugg) = sugg {\n+                        introduce_suggestion.push((span, sugg.to_string()));\n+                    }\n+                }\n+                err.multipart_suggestion_with_style(\n+                    &msg,\n+                    introduce_suggestion,\n+                    Applicability::MaybeIncorrect,\n+                    SuggestionStyle::ShowAlways,\n+                );\n                 if should_break {\n                     break;\n                 }\n             }\n         };\n \n         let lifetime_names: Vec<_> = lifetime_names.iter().collect();\n-        match (&lifetime_names[..], snippet.as_deref()) {\n-            ([name], Some(\"&\")) => {\n-                suggest_existing(err, &name.as_str()[..], &|name| format!(\"&{} \", name));\n-            }\n-            ([name], Some(\"'_\")) => {\n-                suggest_existing(err, &name.as_str()[..], &|n| n.to_string());\n-            }\n-            ([name], Some(\"\")) => {\n-                suggest_existing(err, &name.as_str()[..], &|n| format!(\"{}, \", n).repeat(count));\n-            }\n-            ([name], Some(snippet)) if !snippet.ends_with('>') => {\n-                let f = |name: &str| {\n-                    format!(\n-                        \"{}<{}>\",\n-                        snippet,\n-                        std::iter::repeat(name.to_string())\n-                            .take(count)\n-                            .collect::<Vec<_>>()\n-                            .join(\", \")\n-                    )\n-                };\n-                suggest_existing(err, &name.as_str()[..], &f);\n-            }\n-            ([], Some(\"&\")) if count == 1 => {\n-                suggest_new(err, \"&'a \");\n-            }\n-            ([], Some(\"'_\")) if count == 1 => {\n-                suggest_new(err, \"'a\");\n+        match &lifetime_names[..] {\n+            [name] => {\n+                let mut suggs: Vec<Option<Box<dyn Fn(&str) -> String>>> = Vec::new();\n+                for (snippet, (_, count)) in snippets.iter().zip(spans_with_counts.iter().copied())\n+                {\n+                    suggs.push(match snippet.as_deref() {\n+                        Some(\"&\") => Some(Box::new(|name| format!(\"&{} \", name))),\n+                        Some(\"'_\") => Some(Box::new(|n| n.to_string())),\n+                        Some(\"\") => Some(Box::new(move |n| format!(\"{}, \", n).repeat(count))),\n+                        Some(snippet) if !snippet.ends_with('>') => Some(Box::new(move |name| {\n+                            format!(\n+                                \"{}<{}>\",\n+                                snippet,\n+                                std::iter::repeat(name.to_string())\n+                                    .take(count)\n+                                    .collect::<Vec<_>>()\n+                                    .join(\", \")\n+                            )\n+                        })),\n+                        _ => None,\n+                    });\n+                }\n+                suggest_existing(err, &name.as_str()[..], suggs);\n             }\n-            ([], Some(snippet)) if !snippet.ends_with('>') => {\n-                if snippet == \"\" {\n-                    // This happens when we have `type Bar<'a> = Foo<T>` where we point at the space\n-                    // before `T`. We will suggest `type Bar<'a> = Foo<'a, T>`.\n-                    suggest_new(\n-                        err,\n-                        &std::iter::repeat(\"'a, \").take(count).collect::<Vec<_>>().join(\"\"),\n-                    );\n-                } else {\n-                    suggest_new(\n-                        err,\n-                        &format!(\n+            [] => {\n+                let mut suggs = Vec::new();\n+                for (snippet, (_, count)) in\n+                    snippets.iter().cloned().zip(spans_with_counts.iter().copied())\n+                {\n+                    suggs.push(match snippet.as_deref() {\n+                        Some(\"&\") => Some(\"&'a \".to_string()),\n+                        Some(\"'_\") => Some(\"'a\".to_string()),\n+                        Some(\"\") => {\n+                            Some(std::iter::repeat(\"'a, \").take(count).collect::<Vec<_>>().join(\"\"))\n+                        }\n+                        Some(snippet) => Some(format!(\n                             \"{}<{}>\",\n                             snippet,\n-                            std::iter::repeat(\"'a\").take(count).collect::<Vec<_>>().join(\", \")\n-                        ),\n-                    );\n+                            std::iter::repeat(\"'a\").take(count).collect::<Vec<_>>().join(\", \"),\n+                        )),\n+                        None => None,\n+                    });\n                 }\n+                suggest_new(err, suggs);\n             }\n-            (lts, ..) if lts.len() > 1 => {\n+            lts if lts.len() > 1 => {\n                 err.span_note(lifetime_spans, \"these named lifetimes are available to use\");\n-                if Some(\"\") == snippet.as_deref() {\n+\n+                let mut spans_suggs: Vec<_> = Vec::new();\n+                for ((span, _), snippet) in spans_with_counts.iter().copied().zip(snippets.iter()) {\n+                    match snippet.as_deref() {\n+                        Some(\"\") => spans_suggs.push((span, \"'lifetime, \".to_string())),\n+                        Some(\"&\") => spans_suggs.push((span, \"&'lifetime \".to_string())),\n+                        _ => {}\n+                    }\n+                }\n+\n+                if spans_suggs.len() > 0 {\n                     // This happens when we have `Foo<T>` where we point at the space before `T`,\n                     // but this can be confusing so we give a suggestion with placeholders.\n-                    err.span_suggestion_verbose(\n-                        span,\n+                    err.multipart_suggestion_with_style(\n                         \"consider using one of the available lifetimes here\",\n-                        \"'lifetime, \".repeat(count),\n+                        spans_suggs,\n                         Applicability::HasPlaceholders,\n+                        SuggestionStyle::ShowAlways,\n                     );\n                 }\n             }\n-            _ => {}\n+            _ => unreachable!(),\n         }\n     }\n "}, {"sha": "e8d21af435887ad907d5f6ebac045b0fdda371c8", "filename": "compiler/rustc_resolve/src/late/lifetimes.rs", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/266f452118e27e6a3d9d6b6f9d5483890a18345f/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/266f452118e27e6a3d9d6b6f9d5483890a18345f/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs?ref=266f452118e27e6a3d9d6b6f9d5483890a18345f", "patch": "@@ -2956,7 +2956,6 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n             return;\n         }\n \n-        let span = lifetime_refs[0].span;\n         let mut late_depth = 0;\n         let mut scope = self.scope;\n         let mut lifetime_names = FxHashSet::default();\n@@ -3035,18 +3034,27 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n             }\n         };\n \n-        let mut err = self.report_missing_lifetime_specifiers(span, lifetime_refs.len());\n+        let mut spans: Vec<_> = lifetime_refs.iter().map(|lt| lt.span).collect();\n+        spans.sort();\n+        let mut spans_dedup = spans.clone();\n+        spans_dedup.dedup();\n+        let spans_with_counts: Vec<_> = spans_dedup\n+            .into_iter()\n+            .map(|sp| (sp, spans.iter().filter(|nsp| *nsp == &sp).count()))\n+            .collect();\n+\n+        let mut err = self.report_missing_lifetime_specifiers(spans.clone(), lifetime_refs.len());\n \n         if let Some(params) = error {\n             // If there's no lifetime available, suggest `'static`.\n             if self.report_elision_failure(&mut err, params) && lifetime_names.is_empty() {\n                 lifetime_names.insert(kw::StaticLifetime);\n             }\n         }\n+\n         self.add_missing_lifetime_specifiers_label(\n             &mut err,\n-            span,\n-            lifetime_refs.len(),\n+            spans_with_counts,\n             &lifetime_names,\n             lifetime_spans,\n             error.unwrap_or(&[]),"}, {"sha": "5e39e71252f5a1833a5f3e95a08489f560c6377b", "filename": "library/core/src/iter/range.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/266f452118e27e6a3d9d6b6f9d5483890a18345f/library%2Fcore%2Fsrc%2Fiter%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/266f452118e27e6a3d9d6b6f9d5483890a18345f/library%2Fcore%2Fsrc%2Fiter%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Frange.rs?ref=266f452118e27e6a3d9d6b6f9d5483890a18345f", "patch": "@@ -106,7 +106,7 @@ pub unsafe trait Step: Clone + PartialOrd + Sized {\n     /// For any `a` and `n`, where no overflow occurs:\n     ///\n     /// * `Step::forward_unchecked(a, n)` is equivalent to `Step::forward(a, n)`\n-    #[unstable(feature = \"unchecked_math\", reason = \"niche optimization path\", issue = \"none\")]\n+    #[unstable(feature = \"step_trait_ext\", reason = \"recently added\", issue = \"42168\")]\n     unsafe fn forward_unchecked(start: Self, count: usize) -> Self {\n         Step::forward(start, count)\n     }\n@@ -178,7 +178,7 @@ pub unsafe trait Step: Clone + PartialOrd + Sized {\n     /// For any `a` and `n`, where no overflow occurs:\n     ///\n     /// * `Step::backward_unchecked(a, n)` is equivalent to `Step::backward(a, n)`\n-    #[unstable(feature = \"unchecked_math\", reason = \"niche optimization path\", issue = \"none\")]\n+    #[unstable(feature = \"step_trait_ext\", reason = \"recently added\", issue = \"42168\")]\n     unsafe fn backward_unchecked(start: Self, count: usize) -> Self {\n         Step::backward(start, count)\n     }"}, {"sha": "6a4f2d5a544c1607630b4f8bcdd960fd084df1de", "filename": "library/core/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/266f452118e27e6a3d9d6b6f9d5483890a18345f/library%2Fcore%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/266f452118e27e6a3d9d6b6f9d5483890a18345f/library%2Fcore%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Flib.rs?ref=266f452118e27e6a3d9d6b6f9d5483890a18345f", "patch": "@@ -77,6 +77,7 @@\n #![feature(const_float_classify)]\n #![feature(const_float_bits_conv)]\n #![feature(const_int_unchecked_arith)]\n+#![feature(const_inherent_unchecked_arith)]\n #![feature(const_mut_refs)]\n #![feature(const_refs_to_cell)]\n #![feature(const_panic)]"}, {"sha": "47b2b30563c3a10c2332429be63da74ec6aad550", "filename": "library/core/src/num/int_macros.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/266f452118e27e6a3d9d6b6f9d5483890a18345f/library%2Fcore%2Fsrc%2Fnum%2Fint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/266f452118e27e6a3d9d6b6f9d5483890a18345f/library%2Fcore%2Fsrc%2Fnum%2Fint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fint_macros.rs?ref=266f452118e27e6a3d9d6b6f9d5483890a18345f", "patch": "@@ -412,12 +412,13 @@ macro_rules! int_impl {\n         #[unstable(\n             feature = \"unchecked_math\",\n             reason = \"niche optimization path\",\n-            issue = \"none\",\n+            issue = \"85122\",\n         )]\n         #[must_use = \"this returns the result of the operation, \\\n                       without modifying the original\"]\n+        #[rustc_const_unstable(feature = \"const_inherent_unchecked_arith\", issue = \"85122\")]\n         #[inline(always)]\n-        pub unsafe fn unchecked_add(self, rhs: Self) -> Self {\n+        pub const unsafe fn unchecked_add(self, rhs: Self) -> Self {\n             // SAFETY: the caller must uphold the safety contract for\n             // `unchecked_add`.\n             unsafe { intrinsics::unchecked_add(self, rhs) }\n@@ -450,12 +451,13 @@ macro_rules! int_impl {\n         #[unstable(\n             feature = \"unchecked_math\",\n             reason = \"niche optimization path\",\n-            issue = \"none\",\n+            issue = \"85122\",\n         )]\n         #[must_use = \"this returns the result of the operation, \\\n                       without modifying the original\"]\n+        #[rustc_const_unstable(feature = \"const_inherent_unchecked_arith\", issue = \"85122\")]\n         #[inline(always)]\n-        pub unsafe fn unchecked_sub(self, rhs: Self) -> Self {\n+        pub const unsafe fn unchecked_sub(self, rhs: Self) -> Self {\n             // SAFETY: the caller must uphold the safety contract for\n             // `unchecked_sub`.\n             unsafe { intrinsics::unchecked_sub(self, rhs) }\n@@ -488,12 +490,13 @@ macro_rules! int_impl {\n         #[unstable(\n             feature = \"unchecked_math\",\n             reason = \"niche optimization path\",\n-            issue = \"none\",\n+            issue = \"85122\",\n         )]\n         #[must_use = \"this returns the result of the operation, \\\n                       without modifying the original\"]\n+        #[rustc_const_unstable(feature = \"const_inherent_unchecked_arith\", issue = \"85122\")]\n         #[inline(always)]\n-        pub unsafe fn unchecked_mul(self, rhs: Self) -> Self {\n+        pub const unsafe fn unchecked_mul(self, rhs: Self) -> Self {\n             // SAFETY: the caller must uphold the safety contract for\n             // `unchecked_mul`.\n             unsafe { intrinsics::unchecked_mul(self, rhs) }"}, {"sha": "f9fd28b6a8c2487ab9c4e2f999c5c511644f5baa", "filename": "library/core/src/num/uint_macros.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/266f452118e27e6a3d9d6b6f9d5483890a18345f/library%2Fcore%2Fsrc%2Fnum%2Fuint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/266f452118e27e6a3d9d6b6f9d5483890a18345f/library%2Fcore%2Fsrc%2Fnum%2Fuint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fuint_macros.rs?ref=266f452118e27e6a3d9d6b6f9d5483890a18345f", "patch": "@@ -422,12 +422,13 @@ macro_rules! uint_impl {\n         #[unstable(\n             feature = \"unchecked_math\",\n             reason = \"niche optimization path\",\n-            issue = \"none\",\n+            issue = \"85122\",\n         )]\n         #[must_use = \"this returns the result of the operation, \\\n                       without modifying the original\"]\n+        #[rustc_const_unstable(feature = \"const_inherent_unchecked_arith\", issue = \"85122\")]\n         #[inline(always)]\n-        pub unsafe fn unchecked_add(self, rhs: Self) -> Self {\n+        pub const unsafe fn unchecked_add(self, rhs: Self) -> Self {\n             // SAFETY: the caller must uphold the safety contract for\n             // `unchecked_add`.\n             unsafe { intrinsics::unchecked_add(self, rhs) }\n@@ -460,12 +461,13 @@ macro_rules! uint_impl {\n         #[unstable(\n             feature = \"unchecked_math\",\n             reason = \"niche optimization path\",\n-            issue = \"none\",\n+            issue = \"85122\",\n         )]\n         #[must_use = \"this returns the result of the operation, \\\n                       without modifying the original\"]\n+        #[rustc_const_unstable(feature = \"const_inherent_unchecked_arith\", issue = \"85122\")]\n         #[inline(always)]\n-        pub unsafe fn unchecked_sub(self, rhs: Self) -> Self {\n+        pub const unsafe fn unchecked_sub(self, rhs: Self) -> Self {\n             // SAFETY: the caller must uphold the safety contract for\n             // `unchecked_sub`.\n             unsafe { intrinsics::unchecked_sub(self, rhs) }\n@@ -498,12 +500,13 @@ macro_rules! uint_impl {\n         #[unstable(\n             feature = \"unchecked_math\",\n             reason = \"niche optimization path\",\n-            issue = \"none\",\n+            issue = \"85122\",\n         )]\n         #[must_use = \"this returns the result of the operation, \\\n                       without modifying the original\"]\n+        #[rustc_const_unstable(feature = \"const_inherent_unchecked_arith\", issue = \"85122\")]\n         #[inline(always)]\n-        pub unsafe fn unchecked_mul(self, rhs: Self) -> Self {\n+        pub const unsafe fn unchecked_mul(self, rhs: Self) -> Self {\n             // SAFETY: the caller must uphold the safety contract for\n             // `unchecked_mul`.\n             unsafe { intrinsics::unchecked_mul(self, rhs) }"}, {"sha": "9f43379aff7878ab64a636f8f0411e8788120def", "filename": "library/std/src/io/mod.rs", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/266f452118e27e6a3d9d6b6f9d5483890a18345f/library%2Fstd%2Fsrc%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/266f452118e27e6a3d9d6b6f9d5483890a18345f/library%2Fstd%2Fsrc%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fmod.rs?ref=266f452118e27e6a3d9d6b6f9d5483890a18345f", "patch": "@@ -1663,10 +1663,47 @@ pub trait Seek {\n     ///\n     /// # Errors\n     ///\n+    /// Seeking can fail, for example becaue it might involve flushing a buffer.\n+    ///\n     /// Seeking to a negative offset is considered an error.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn seek(&mut self, pos: SeekFrom) -> Result<u64>;\n \n+    /// Rewind to the beginning of a stream.\n+    ///\n+    /// This is a convenience method, equivalent to `seek(SeekFrom::Start(0))`.\n+    ///\n+    /// # Errors\n+    ///\n+    /// Rewinding can fail, for example becaue it might involve flushing a buffer.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```no_run\n+    /// #![feature(seek_rewind)]\n+    /// use std::io::{Read, Seek, Write};\n+    /// use std::fs::OpenOptions;\n+    ///\n+    /// let mut f = OpenOptions::new()\n+    ///     .write(true)\n+    ///     .read(true)\n+    ///     .create(true)\n+    ///     .open(\"foo.txt\").unwrap();\n+    ///\n+    /// let hello = \"Hello!\\n\";\n+    /// write!(f, \"{}\", hello).unwrap();\n+    /// f.rewind().unwrap();\n+    ///\n+    /// let mut buf = String::new();\n+    /// f.read_to_string(&mut buf).unwrap();\n+    /// assert_eq!(&buf, hello);\n+    /// ```\n+    #[unstable(feature = \"seek_rewind\", issue = \"85149\")]\n+    fn rewind(&mut self) -> Result<()> {\n+        self.seek(SeekFrom::Start(0))?;\n+        Ok(())\n+    }\n+\n     /// Returns the length of this stream (in bytes).\n     ///\n     /// This method is implemented using up to three seek operations. If this"}, {"sha": "bee5a7cb3ba7255fce8b1c48f497be30b7f0a277", "filename": "src/test/ui/consts/const-eval/erroneous-const.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/266f452118e27e6a3d9d6b6f9d5483890a18345f/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Ferroneous-const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/266f452118e27e6a3d9d6b6f9d5483890a18345f/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Ferroneous-const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Ferroneous-const.rs?ref=266f452118e27e6a3d9d6b6f9d5483890a18345f", "patch": "@@ -10,6 +10,8 @@ impl<T> PrintName<T> {\n \n const fn no_codegen<T>() {\n     if false {\n+        // This bad constant is only used in dead code in a no-codegen function... and yet we still\n+        // must make sure that the build fails.\n         let _ = PrintName::<T>::VOID; //~ERROR could not evaluate static initializer\n     }\n }"}, {"sha": "7e2a60929c73d36a278389859fe79ade6c460f3e", "filename": "src/test/ui/consts/const-eval/erroneous-const.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/266f452118e27e6a3d9d6b6f9d5483890a18345f/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Ferroneous-const.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/266f452118e27e6a3d9d6b6f9d5483890a18345f/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Ferroneous-const.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Ferroneous-const.stderr?ref=266f452118e27e6a3d9d6b6f9d5483890a18345f", "patch": "@@ -27,16 +27,16 @@ LL | #![warn(const_err, unconditional_panic)]\n    = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n \n error[E0080]: could not evaluate static initializer\n-  --> $DIR/erroneous-const.rs:13:17\n+  --> $DIR/erroneous-const.rs:15:17\n    |\n LL |         let _ = PrintName::<T>::VOID;\n    |                 ^^^^^^^^^^^^^^^^^^^^\n    |                 |\n    |                 referenced constant has errors\n-   |                 inside `no_codegen::<i32>` at $DIR/erroneous-const.rs:13:17\n+   |                 inside `no_codegen::<i32>` at $DIR/erroneous-const.rs:15:17\n ...\n LL | pub static FOO: () = no_codegen::<i32>();\n-   |                      ------------------- inside `FOO` at $DIR/erroneous-const.rs:17:22\n+   |                      ------------------- inside `FOO` at $DIR/erroneous-const.rs:19:22\n \n error: aborting due to previous error; 2 warnings emitted\n "}, {"sha": "aa0f093bf6293c73f420d9d5412efec36492d49e", "filename": "src/test/ui/consts/const-eval/erroneous-const2.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/266f452118e27e6a3d9d6b6f9d5483890a18345f/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Ferroneous-const2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/266f452118e27e6a3d9d6b6f9d5483890a18345f/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Ferroneous-const2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Ferroneous-const2.rs?ref=266f452118e27e6a3d9d6b6f9d5483890a18345f", "patch": "@@ -0,0 +1,21 @@\n+//! Make sure we error on erroneous consts even if they are unused.\n+#![warn(const_err, unconditional_panic)]\n+\n+struct PrintName<T>(T);\n+impl<T> PrintName<T> {\n+    const VOID: () = [()][2]; //~WARN any use of this value will cause an error\n+    //~^ WARN this operation will panic at runtime\n+    //~| WARN this was previously accepted by the compiler but is being phased out\n+}\n+\n+pub static FOO: () = {\n+    if false {\n+        // This bad constant is only used in dead code in a static initializer... and yet we still\n+        // must make sure that the build fails.\n+        let _ = PrintName::<i32>::VOID; //~ERROR could not evaluate static initializer\n+    }\n+};\n+\n+fn main() {\n+    FOO\n+}"}, {"sha": "813d3ee249fb2be97deaafed153c9deb4ef0430f", "filename": "src/test/ui/consts/const-eval/erroneous-const2.stderr", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/266f452118e27e6a3d9d6b6f9d5483890a18345f/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Ferroneous-const2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/266f452118e27e6a3d9d6b6f9d5483890a18345f/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Ferroneous-const2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Ferroneous-const2.stderr?ref=266f452118e27e6a3d9d6b6f9d5483890a18345f", "patch": "@@ -0,0 +1,37 @@\n+warning: this operation will panic at runtime\n+  --> $DIR/erroneous-const2.rs:6:22\n+   |\n+LL |     const VOID: () = [()][2];\n+   |                      ^^^^^^^ index out of bounds: the length is 1 but the index is 2\n+   |\n+note: the lint level is defined here\n+  --> $DIR/erroneous-const2.rs:2:20\n+   |\n+LL | #![warn(const_err, unconditional_panic)]\n+   |                    ^^^^^^^^^^^^^^^^^^^\n+\n+warning: any use of this value will cause an error\n+  --> $DIR/erroneous-const2.rs:6:22\n+   |\n+LL |     const VOID: () = [()][2];\n+   |     -----------------^^^^^^^-\n+   |                      |\n+   |                      index out of bounds: the length is 1 but the index is 2\n+   |\n+note: the lint level is defined here\n+  --> $DIR/erroneous-const2.rs:2:9\n+   |\n+LL | #![warn(const_err, unconditional_panic)]\n+   |         ^^^^^^^^^\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n+\n+error[E0080]: could not evaluate static initializer\n+  --> $DIR/erroneous-const2.rs:15:17\n+   |\n+LL |         let _ = PrintName::<i32>::VOID;\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^ referenced constant has errors\n+\n+error: aborting due to previous error; 2 warnings emitted\n+\n+For more information about this error, try `rustc --explain E0080`."}, {"sha": "77e7d484071860fb5f979a1ed501a37040982d4d", "filename": "src/test/ui/consts/const-eval/promoted_errors.noopt.stderr", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/266f452118e27e6a3d9d6b6f9d5483890a18345f/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fpromoted_errors.noopt.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/266f452118e27e6a3d9d6b6f9d5483890a18345f/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fpromoted_errors.noopt.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fpromoted_errors.noopt.stderr?ref=266f452118e27e6a3d9d6b6f9d5483890a18345f", "patch": "@@ -1,12 +1,12 @@\n warning: any use of this value will cause an error\n-  --> $DIR/promoted_errors.rs:13:5\n+  --> $DIR/promoted_errors.rs:15:5\n    |\n LL |       0 - 1\n    |       ^^^^^\n    |       |\n    |       attempt to compute `0_u32 - 1_u32`, which would overflow\n-   |       inside `overflow` at $DIR/promoted_errors.rs:13:5\n-   |       inside `X` at $DIR/promoted_errors.rs:33:29\n+   |       inside `overflow` at $DIR/promoted_errors.rs:15:5\n+   |       inside `X` at $DIR/promoted_errors.rs:38:29\n ...\n LL | / const X: () = {\n LL | |     let _x: &'static u32 = &overflow();\n@@ -18,15 +18,15 @@ LL | | };\n    | |__-\n    |\n note: the lint level is defined here\n-  --> $DIR/promoted_errors.rs:9:9\n+  --> $DIR/promoted_errors.rs:11:9\n    |\n LL | #![warn(const_err, arithmetic_overflow, unconditional_panic)]\n    |         ^^^^^^^^^\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n \n warning: any use of this value will cause an error\n-  --> $DIR/promoted_errors.rs:33:28\n+  --> $DIR/promoted_errors.rs:38:28\n    |\n LL | / const X: () = {\n LL | |     let _x: &'static u32 = &overflow();"}, {"sha": "6b17346e6ecd1456f65c34ece14b1d3e522b834a", "filename": "src/test/ui/consts/const-eval/promoted_errors.opt.stderr", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/266f452118e27e6a3d9d6b6f9d5483890a18345f/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fpromoted_errors.opt.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/266f452118e27e6a3d9d6b6f9d5483890a18345f/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fpromoted_errors.opt.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fpromoted_errors.opt.stderr?ref=266f452118e27e6a3d9d6b6f9d5483890a18345f", "patch": "@@ -1,12 +1,12 @@\n warning: any use of this value will cause an error\n-  --> $DIR/promoted_errors.rs:18:5\n+  --> $DIR/promoted_errors.rs:20:5\n    |\n LL |       1 / 0\n    |       ^^^^^\n    |       |\n    |       attempt to divide `1_i32` by zero\n-   |       inside `div_by_zero1` at $DIR/promoted_errors.rs:18:5\n-   |       inside `X` at $DIR/promoted_errors.rs:36:29\n+   |       inside `div_by_zero1` at $DIR/promoted_errors.rs:20:5\n+   |       inside `X` at $DIR/promoted_errors.rs:41:29\n ...\n LL | / const X: () = {\n LL | |     let _x: &'static u32 = &overflow();\n@@ -18,15 +18,15 @@ LL | | };\n    | |__-\n    |\n note: the lint level is defined here\n-  --> $DIR/promoted_errors.rs:9:9\n+  --> $DIR/promoted_errors.rs:11:9\n    |\n LL | #![warn(const_err, arithmetic_overflow, unconditional_panic)]\n    |         ^^^^^^^^^\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n \n warning: any use of this value will cause an error\n-  --> $DIR/promoted_errors.rs:36:28\n+  --> $DIR/promoted_errors.rs:41:28\n    |\n LL | / const X: () = {\n LL | |     let _x: &'static u32 = &overflow();"}, {"sha": "77e7d484071860fb5f979a1ed501a37040982d4d", "filename": "src/test/ui/consts/const-eval/promoted_errors.opt_with_overflow_checks.stderr", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/266f452118e27e6a3d9d6b6f9d5483890a18345f/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fpromoted_errors.opt_with_overflow_checks.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/266f452118e27e6a3d9d6b6f9d5483890a18345f/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fpromoted_errors.opt_with_overflow_checks.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fpromoted_errors.opt_with_overflow_checks.stderr?ref=266f452118e27e6a3d9d6b6f9d5483890a18345f", "patch": "@@ -1,12 +1,12 @@\n warning: any use of this value will cause an error\n-  --> $DIR/promoted_errors.rs:13:5\n+  --> $DIR/promoted_errors.rs:15:5\n    |\n LL |       0 - 1\n    |       ^^^^^\n    |       |\n    |       attempt to compute `0_u32 - 1_u32`, which would overflow\n-   |       inside `overflow` at $DIR/promoted_errors.rs:13:5\n-   |       inside `X` at $DIR/promoted_errors.rs:33:29\n+   |       inside `overflow` at $DIR/promoted_errors.rs:15:5\n+   |       inside `X` at $DIR/promoted_errors.rs:38:29\n ...\n LL | / const X: () = {\n LL | |     let _x: &'static u32 = &overflow();\n@@ -18,15 +18,15 @@ LL | | };\n    | |__-\n    |\n note: the lint level is defined here\n-  --> $DIR/promoted_errors.rs:9:9\n+  --> $DIR/promoted_errors.rs:11:9\n    |\n LL | #![warn(const_err, arithmetic_overflow, unconditional_panic)]\n    |         ^^^^^^^^^\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #71800 <https://github.com/rust-lang/rust/issues/71800>\n \n warning: any use of this value will cause an error\n-  --> $DIR/promoted_errors.rs:33:28\n+  --> $DIR/promoted_errors.rs:38:28\n    |\n LL | / const X: () = {\n LL | |     let _x: &'static u32 = &overflow();"}, {"sha": "5bafea1ed46bdf1c4faa8cd048462869ab8dbec6", "filename": "src/test/ui/consts/const-eval/promoted_errors.rs", "status": "modified", "additions": 23, "deletions": 1, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/266f452118e27e6a3d9d6b6f9d5483890a18345f/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fpromoted_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/266f452118e27e6a3d9d6b6f9d5483890a18345f/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fpromoted_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fpromoted_errors.rs?ref=266f452118e27e6a3d9d6b6f9d5483890a18345f", "patch": "@@ -6,6 +6,8 @@\n // build-pass\n // ignore-pass (test emits codegen-time warnings and verifies that they are not errors)\n \n+//! This test ensures that when we promote code that fails to evaluate, the build still succeeds.\n+\n #![warn(const_err, arithmetic_overflow, unconditional_panic)]\n \n // The only way to have promoteds that fail is in `const fn` called from `const`/`static`.\n@@ -29,6 +31,9 @@ const fn oob() -> i32 {\n     [1, 2, 3][4]\n }\n \n+// An unused constant containing failing promoteds.\n+// This should work as long as `const_err` can be turned into just a warning;\n+// once it turns into a hard error, just remove `X`.\n const X: () = {\n     let _x: &'static u32 = &overflow();\n     //[opt_with_overflow_checks,noopt]~^ WARN any use of this value will cause an error\n@@ -41,4 +46,21 @@ const X: () = {\n     let _x: &'static i32 = &oob();\n };\n \n-fn main() {}\n+const fn mk_false() -> bool { false }\n+\n+// An actually used constant referencing failing promoteds in dead code.\n+// This needs to always work.\n+const Y: () = {\n+    if mk_false() {\n+        let _x: &'static u32 = &overflow();\n+        let _x: &'static i32 = &div_by_zero1();\n+        let _x: &'static i32 = &div_by_zero2();\n+        let _x: &'static i32 = &div_by_zero3();\n+        let _x: &'static i32 = &oob();\n+    }\n+    ()\n+};\n+\n+fn main() {\n+    let _y = Y;\n+}"}, {"sha": "77390aae2d688a0d87630bde952525821f62ad95", "filename": "src/test/ui/non-fmt-panic.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/266f452118e27e6a3d9d6b6f9d5483890a18345f/src%2Ftest%2Fui%2Fnon-fmt-panic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/266f452118e27e6a3d9d6b6f9d5483890a18345f/src%2Ftest%2Fui%2Fnon-fmt-panic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnon-fmt-panic.rs?ref=266f452118e27e6a3d9d6b6f9d5483890a18345f", "patch": "@@ -36,6 +36,8 @@ fn main() {\n     panic!(a!()); //~ WARN panic message is not a string literal\n \n     panic!(format!(\"{}\", 1)); //~ WARN panic message is not a string literal\n+    assert!(false, format!(\"{}\", 1)); //~ WARN panic message is not a string literal\n+    debug_assert!(false, format!(\"{}\", 1)); //~ WARN panic message is not a string literal\n \n     panic![123]; //~ WARN panic message is not a string literal\n     panic!{123}; //~ WARN panic message is not a string literal"}, {"sha": "3278eb5f0238e41db4b3b71a8731755c9b7dddaf", "filename": "src/test/ui/non-fmt-panic.stderr", "status": "modified", "additions": 29, "deletions": 3, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/266f452118e27e6a3d9d6b6f9d5483890a18345f/src%2Ftest%2Fui%2Fnon-fmt-panic.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/266f452118e27e6a3d9d6b6f9d5483890a18345f/src%2Ftest%2Fui%2Fnon-fmt-panic.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnon-fmt-panic.stderr?ref=266f452118e27e6a3d9d6b6f9d5483890a18345f", "patch": "@@ -213,7 +213,33 @@ LL |     panic!(\"{}\", 1);\n    |           --     --\n \n warning: panic message is not a string literal\n-  --> $DIR/non-fmt-panic.rs:40:12\n+  --> $DIR/non-fmt-panic.rs:39:20\n+   |\n+LL |     assert!(false, format!(\"{}\", 1));\n+   |                    ^^^^^^^^^^^^^^^^\n+   |\n+   = note: this is no longer accepted in Rust 2021\n+   = note: the assert!() macro supports formatting, so there's no need for the format!() macro here\n+help: remove the `format!(..)` macro call\n+   |\n+LL |     assert!(false, \"{}\", 1);\n+   |                   --     --\n+\n+warning: panic message is not a string literal\n+  --> $DIR/non-fmt-panic.rs:40:26\n+   |\n+LL |     debug_assert!(false, format!(\"{}\", 1));\n+   |                          ^^^^^^^^^^^^^^^^\n+   |\n+   = note: this is no longer accepted in Rust 2021\n+   = note: the debug_assert!() macro supports formatting, so there's no need for the format!() macro here\n+help: remove the `format!(..)` macro call\n+   |\n+LL |     debug_assert!(false, \"{}\", 1);\n+   |                         --     --\n+\n+warning: panic message is not a string literal\n+  --> $DIR/non-fmt-panic.rs:42:12\n    |\n LL |     panic![123];\n    |            ^^^\n@@ -229,7 +255,7 @@ LL |     std::panic::panic_any(123);\n    |     ^^^^^^^^^^^^^^^^^^^^^^   ^\n \n warning: panic message is not a string literal\n-  --> $DIR/non-fmt-panic.rs:41:12\n+  --> $DIR/non-fmt-panic.rs:43:12\n    |\n LL |     panic!{123};\n    |            ^^^\n@@ -244,5 +270,5 @@ help: or use std::panic::panic_any instead\n LL |     std::panic::panic_any(123);\n    |     ^^^^^^^^^^^^^^^^^^^^^^   ^\n \n-warning: 18 warnings emitted\n+warning: 20 warnings emitted\n "}, {"sha": "aa246aaa3d45efb3006632356d86dca41797ce79", "filename": "src/test/ui/suggestions/issue-84592.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/266f452118e27e6a3d9d6b6f9d5483890a18345f/src%2Ftest%2Fui%2Fsuggestions%2Fissue-84592.rs", "raw_url": "https://github.com/rust-lang/rust/raw/266f452118e27e6a3d9d6b6f9d5483890a18345f/src%2Ftest%2Fui%2Fsuggestions%2Fissue-84592.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fissue-84592.rs?ref=266f452118e27e6a3d9d6b6f9d5483890a18345f", "patch": "@@ -0,0 +1,17 @@\n+/* Checks whether issue #84592 has been resolved. The issue was\n+ * that in this example, there are two expected/missing lifetime\n+ * parameters with *different spans*, leading to incorrect\n+ * suggestions from rustc.\n+ */\n+\n+struct TwoLifetimes<'x, 'y> {\n+    x: &'x (),\n+    y: &'y (),\n+}\n+\n+fn two_lifetimes_needed(a: &(), b: &()) -> TwoLifetimes<'_, '_> {\n+//~^ ERROR missing lifetime specifiers [E0106]\n+    TwoLifetimes { x: &(), y: &() }\n+}\n+\n+fn main() {}"}, {"sha": "02f9241a6d2dae3fdbb5e13aa35870c777f2702f", "filename": "src/test/ui/suggestions/issue-84592.stderr", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/266f452118e27e6a3d9d6b6f9d5483890a18345f/src%2Ftest%2Fui%2Fsuggestions%2Fissue-84592.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/266f452118e27e6a3d9d6b6f9d5483890a18345f/src%2Ftest%2Fui%2Fsuggestions%2Fissue-84592.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fissue-84592.stderr?ref=266f452118e27e6a3d9d6b6f9d5483890a18345f", "patch": "@@ -0,0 +1,17 @@\n+error[E0106]: missing lifetime specifiers\n+  --> $DIR/issue-84592.rs:12:57\n+   |\n+LL | fn two_lifetimes_needed(a: &(), b: &()) -> TwoLifetimes<'_, '_> {\n+   |                            ---     ---                  ^^  ^^ expected named lifetime parameter\n+   |                                                         |\n+   |                                                         expected named lifetime parameter\n+   |\n+   = help: this function's return type contains a borrowed value, but the signature does not say whether it is borrowed from `a` or `b`\n+help: consider introducing a named lifetime parameter\n+   |\n+LL | fn two_lifetimes_needed<'a>(a: &'a (), b: &'a ()) -> TwoLifetimes<'a, 'a> {\n+   |                        ^^^^    ^^^^^^     ^^^^^^                  ^^  ^^\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0106`."}, {"sha": "a7a44b511db8de6b3b12dc917bf902a4f564caa8", "filename": "src/test/ui/suggestions/missing-lt-for-hrtb.stderr", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/266f452118e27e6a3d9d6b6f9d5483890a18345f/src%2Ftest%2Fui%2Fsuggestions%2Fmissing-lt-for-hrtb.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/266f452118e27e6a3d9d6b6f9d5483890a18345f/src%2Ftest%2Fui%2Fsuggestions%2Fmissing-lt-for-hrtb.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fmissing-lt-for-hrtb.stderr?ref=266f452118e27e6a3d9d6b6f9d5483890a18345f", "patch": "@@ -44,6 +44,10 @@ note: these named lifetimes are available to use\n    |\n LL | struct V<'a>(&'a dyn for<'b> Fn(&X) -> &X);\n    |          ^^              ^^\n+help: consider using one of the available lifetimes here\n+   |\n+LL | struct V<'a>(&'a dyn for<'b> Fn(&X) -> &'lifetime X);\n+   |                                        ^^^^^^^^^^\n \n error[E0106]: missing lifetime specifier\n   --> $DIR/missing-lt-for-hrtb.rs:5:41"}, {"sha": "ca336bbb056d5105847adb9c12be2fc39b0ac935", "filename": "src/test/ui/suggestions/return-elided-lifetime.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/266f452118e27e6a3d9d6b6f9d5483890a18345f/src%2Ftest%2Fui%2Fsuggestions%2Freturn-elided-lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/266f452118e27e6a3d9d6b6f9d5483890a18345f/src%2Ftest%2Fui%2Fsuggestions%2Freturn-elided-lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Freturn-elided-lifetime.rs?ref=266f452118e27e6a3d9d6b6f9d5483890a18345f", "patch": "@@ -0,0 +1,37 @@\n+/* Checks all four scenarios possible in report_elision_failure() of\n+ * rustc_resolve::late::lifetimes::LifetimeContext related to returning\n+ * borrowed values, in various configurations.\n+ */\n+\n+fn f1() -> &i32 { loop {} }\n+//~^ ERROR missing lifetime specifier [E0106]\n+fn f1_() -> (&i32, &i32) { loop {} }\n+//~^ ERROR missing lifetime specifier [E0106]\n+//~^^ ERROR missing lifetime specifier [E0106]\n+\n+fn f2(a: i32, b: i32) -> &i32 { loop {} }\n+//~^ ERROR missing lifetime specifier [E0106]\n+fn f2_(a: i32, b: i32) -> (&i32, &i32) { loop {} }\n+//~^ ERROR missing lifetime specifier [E0106]\n+//~^^ ERROR missing lifetime specifier [E0106]\n+\n+struct S<'a, 'b> { a: &'a i32, b: &'b i32 }\n+fn f3(s: &S) -> &i32 { loop {} }\n+//~^ ERROR missing lifetime specifier [E0106]\n+fn f3_(s: &S, t: &S) -> (&i32, &i32) { loop {} }\n+//~^ ERROR missing lifetime specifier [E0106]\n+//~^^ ERROR missing lifetime specifier [E0106]\n+\n+fn f4<'a, 'b>(a: &'a i32, b: &'b i32) -> &i32 { loop {} }\n+//~^ ERROR missing lifetime specifier [E0106]\n+fn f4_<'a, 'b>(a: &'a i32, b: &'b i32) -> (&i32, &i32) { loop {} }\n+//~^ ERROR missing lifetime specifier [E0106]\n+//~^^ ERROR missing lifetime specifier [E0106]\n+\n+fn f5<'a>(a: &'a i32, b: &i32) -> &i32 { loop {} }\n+//~^ ERROR missing lifetime specifier [E0106]\n+fn f5_<'a>(a: &'a i32, b: &i32) -> (&i32, &i32) { loop {} }\n+//~^ ERROR missing lifetime specifier [E0106]\n+//~^^ ERROR missing lifetime specifier [E0106]\n+\n+fn main() {}"}, {"sha": "888cd5e58abeca671718a7572b56fe0a53db8f53", "filename": "src/test/ui/suggestions/return-elided-lifetime.stderr", "status": "added", "additions": 198, "deletions": 0, "changes": 198, "blob_url": "https://github.com/rust-lang/rust/blob/266f452118e27e6a3d9d6b6f9d5483890a18345f/src%2Ftest%2Fui%2Fsuggestions%2Freturn-elided-lifetime.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/266f452118e27e6a3d9d6b6f9d5483890a18345f/src%2Ftest%2Fui%2Fsuggestions%2Freturn-elided-lifetime.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Freturn-elided-lifetime.stderr?ref=266f452118e27e6a3d9d6b6f9d5483890a18345f", "patch": "@@ -0,0 +1,198 @@\n+error[E0106]: missing lifetime specifier\n+  --> $DIR/return-elided-lifetime.rs:6:12\n+   |\n+LL | fn f1() -> &i32 { loop {} }\n+   |            ^ expected named lifetime parameter\n+   |\n+   = help: this function's return type contains a borrowed value, but there is no value for it to be borrowed from\n+help: consider using the `'static` lifetime\n+   |\n+LL | fn f1() -> &'static i32 { loop {} }\n+   |            ^^^^^^^^\n+\n+error[E0106]: missing lifetime specifier\n+  --> $DIR/return-elided-lifetime.rs:8:14\n+   |\n+LL | fn f1_() -> (&i32, &i32) { loop {} }\n+   |              ^ expected named lifetime parameter\n+   |\n+   = help: this function's return type contains a borrowed value, but there is no value for it to be borrowed from\n+help: consider using the `'static` lifetime\n+   |\n+LL | fn f1_() -> (&'static i32, &i32) { loop {} }\n+   |              ^^^^^^^^\n+\n+error[E0106]: missing lifetime specifier\n+  --> $DIR/return-elided-lifetime.rs:8:20\n+   |\n+LL | fn f1_() -> (&i32, &i32) { loop {} }\n+   |                    ^ expected named lifetime parameter\n+   |\n+   = help: this function's return type contains a borrowed value, but there is no value for it to be borrowed from\n+help: consider using the `'static` lifetime\n+   |\n+LL | fn f1_() -> (&i32, &'static i32) { loop {} }\n+   |                    ^^^^^^^^\n+\n+error[E0106]: missing lifetime specifier\n+  --> $DIR/return-elided-lifetime.rs:12:26\n+   |\n+LL | fn f2(a: i32, b: i32) -> &i32 { loop {} }\n+   |                          ^ expected named lifetime parameter\n+   |\n+   = help: this function's return type contains a borrowed value with an elided lifetime, but the lifetime cannot be derived from the arguments\n+help: consider using the `'static` lifetime\n+   |\n+LL | fn f2(a: i32, b: i32) -> &'static i32 { loop {} }\n+   |                          ^^^^^^^^\n+\n+error[E0106]: missing lifetime specifier\n+  --> $DIR/return-elided-lifetime.rs:14:28\n+   |\n+LL | fn f2_(a: i32, b: i32) -> (&i32, &i32) { loop {} }\n+   |                            ^ expected named lifetime parameter\n+   |\n+   = help: this function's return type contains a borrowed value with an elided lifetime, but the lifetime cannot be derived from the arguments\n+help: consider using the `'static` lifetime\n+   |\n+LL | fn f2_(a: i32, b: i32) -> (&'static i32, &i32) { loop {} }\n+   |                            ^^^^^^^^\n+\n+error[E0106]: missing lifetime specifier\n+  --> $DIR/return-elided-lifetime.rs:14:34\n+   |\n+LL | fn f2_(a: i32, b: i32) -> (&i32, &i32) { loop {} }\n+   |                                  ^ expected named lifetime parameter\n+   |\n+   = help: this function's return type contains a borrowed value with an elided lifetime, but the lifetime cannot be derived from the arguments\n+help: consider using the `'static` lifetime\n+   |\n+LL | fn f2_(a: i32, b: i32) -> (&i32, &'static i32) { loop {} }\n+   |                                  ^^^^^^^^\n+\n+error[E0106]: missing lifetime specifier\n+  --> $DIR/return-elided-lifetime.rs:19:17\n+   |\n+LL | fn f3(s: &S) -> &i32 { loop {} }\n+   |          --     ^ expected named lifetime parameter\n+   |\n+   = help: this function's return type contains a borrowed value, but the signature does not say which one of `s`'s 3 lifetimes it is borrowed from\n+help: consider introducing a named lifetime parameter\n+   |\n+LL | fn f3<'a>(s: &'a S) -> &'a i32 { loop {} }\n+   |      ^^^^    ^^^^^     ^^^\n+\n+error[E0106]: missing lifetime specifier\n+  --> $DIR/return-elided-lifetime.rs:21:26\n+   |\n+LL | fn f3_(s: &S, t: &S) -> (&i32, &i32) { loop {} }\n+   |           --     --      ^ expected named lifetime parameter\n+   |\n+   = help: this function's return type contains a borrowed value, but the signature does not say whether it is borrowed from one of `s`'s 3 lifetimes or one of `t`'s 3 lifetimes\n+help: consider introducing a named lifetime parameter\n+   |\n+LL | fn f3_<'a>(s: &'a S, t: &'a S) -> (&'a i32, &i32) { loop {} }\n+   |       ^^^^    ^^^^^     ^^^^^      ^^^\n+\n+error[E0106]: missing lifetime specifier\n+  --> $DIR/return-elided-lifetime.rs:21:32\n+   |\n+LL | fn f3_(s: &S, t: &S) -> (&i32, &i32) { loop {} }\n+   |           --     --            ^ expected named lifetime parameter\n+   |\n+   = help: this function's return type contains a borrowed value, but the signature does not say whether it is borrowed from one of `s`'s 3 lifetimes or one of `t`'s 3 lifetimes\n+help: consider introducing a named lifetime parameter\n+   |\n+LL | fn f3_<'a>(s: &'a S, t: &'a S) -> (&i32, &'a i32) { loop {} }\n+   |       ^^^^    ^^^^^     ^^^^^            ^^^\n+\n+error[E0106]: missing lifetime specifier\n+  --> $DIR/return-elided-lifetime.rs:25:42\n+   |\n+LL | fn f4<'a, 'b>(a: &'a i32, b: &'b i32) -> &i32 { loop {} }\n+   |                  -------     -------     ^ expected named lifetime parameter\n+   |\n+   = help: this function's return type contains a borrowed value, but the signature does not say whether it is borrowed from `a` or `b`\n+note: these named lifetimes are available to use\n+  --> $DIR/return-elided-lifetime.rs:25:7\n+   |\n+LL | fn f4<'a, 'b>(a: &'a i32, b: &'b i32) -> &i32 { loop {} }\n+   |       ^^  ^^\n+help: consider using one of the available lifetimes here\n+   |\n+LL | fn f4<'a, 'b>(a: &'a i32, b: &'b i32) -> &'lifetime i32 { loop {} }\n+   |                                          ^^^^^^^^^^\n+\n+error[E0106]: missing lifetime specifier\n+  --> $DIR/return-elided-lifetime.rs:27:44\n+   |\n+LL | fn f4_<'a, 'b>(a: &'a i32, b: &'b i32) -> (&i32, &i32) { loop {} }\n+   |                   -------     -------      ^ expected named lifetime parameter\n+   |\n+   = help: this function's return type contains a borrowed value, but the signature does not say whether it is borrowed from `a` or `b`\n+note: these named lifetimes are available to use\n+  --> $DIR/return-elided-lifetime.rs:27:8\n+   |\n+LL | fn f4_<'a, 'b>(a: &'a i32, b: &'b i32) -> (&i32, &i32) { loop {} }\n+   |        ^^  ^^\n+help: consider using one of the available lifetimes here\n+   |\n+LL | fn f4_<'a, 'b>(a: &'a i32, b: &'b i32) -> (&'lifetime i32, &i32) { loop {} }\n+   |                                            ^^^^^^^^^^\n+\n+error[E0106]: missing lifetime specifier\n+  --> $DIR/return-elided-lifetime.rs:27:50\n+   |\n+LL | fn f4_<'a, 'b>(a: &'a i32, b: &'b i32) -> (&i32, &i32) { loop {} }\n+   |                   -------     -------            ^ expected named lifetime parameter\n+   |\n+   = help: this function's return type contains a borrowed value, but the signature does not say whether it is borrowed from `a` or `b`\n+note: these named lifetimes are available to use\n+  --> $DIR/return-elided-lifetime.rs:27:8\n+   |\n+LL | fn f4_<'a, 'b>(a: &'a i32, b: &'b i32) -> (&i32, &i32) { loop {} }\n+   |        ^^  ^^\n+help: consider using one of the available lifetimes here\n+   |\n+LL | fn f4_<'a, 'b>(a: &'a i32, b: &'b i32) -> (&i32, &'lifetime i32) { loop {} }\n+   |                                                  ^^^^^^^^^^\n+\n+error[E0106]: missing lifetime specifier\n+  --> $DIR/return-elided-lifetime.rs:31:35\n+   |\n+LL | fn f5<'a>(a: &'a i32, b: &i32) -> &i32 { loop {} }\n+   |              -------     ----     ^ expected named lifetime parameter\n+   |\n+   = help: this function's return type contains a borrowed value, but the signature does not say whether it is borrowed from `a` or `b`\n+help: consider using the `'a` lifetime\n+   |\n+LL | fn f5<'a>(a: &'a i32, b: &i32) -> &'a i32 { loop {} }\n+   |                                   ^^^\n+\n+error[E0106]: missing lifetime specifier\n+  --> $DIR/return-elided-lifetime.rs:33:37\n+   |\n+LL | fn f5_<'a>(a: &'a i32, b: &i32) -> (&i32, &i32) { loop {} }\n+   |               -------     ----      ^ expected named lifetime parameter\n+   |\n+   = help: this function's return type contains a borrowed value, but the signature does not say whether it is borrowed from `a` or `b`\n+help: consider using the `'a` lifetime\n+   |\n+LL | fn f5_<'a>(a: &'a i32, b: &i32) -> (&'a i32, &i32) { loop {} }\n+   |                                     ^^^\n+\n+error[E0106]: missing lifetime specifier\n+  --> $DIR/return-elided-lifetime.rs:33:43\n+   |\n+LL | fn f5_<'a>(a: &'a i32, b: &i32) -> (&i32, &i32) { loop {} }\n+   |               -------     ----            ^ expected named lifetime parameter\n+   |\n+   = help: this function's return type contains a borrowed value, but the signature does not say whether it is borrowed from `a` or `b`\n+help: consider using the `'a` lifetime\n+   |\n+LL | fn f5_<'a>(a: &'a i32, b: &i32) -> (&i32, &'a i32) { loop {} }\n+   |                                           ^^^\n+\n+error: aborting due to 15 previous errors\n+\n+For more information about this error, try `rustc --explain E0106`."}, {"sha": "fd109fb587904cfecc1149e068814bfd38feb83c", "filename": "src/tools/rust-analyzer", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer?ref=266f452118e27e6a3d9d6b6f9d5483890a18345f", "patch": "@@ -1 +1 @@\n-Subproject commit eb741e895f1a73420a401f2495c711afe37d9d19\n+Subproject commit fd109fb587904cfecc1149e068814bfd38feb83c"}, {"sha": "a7e700b935e04b2a9df6fdca3b94642a9b18f54e", "filename": "src/tools/tidy/src/features.rs", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/266f452118e27e6a3d9d6b6f9d5483890a18345f/src%2Ftools%2Ftidy%2Fsrc%2Ffeatures.rs", "raw_url": "https://github.com/rust-lang/rust/raw/266f452118e27e6a3d9d6b6f9d5483890a18345f/src%2Ftools%2Ftidy%2Fsrc%2Ffeatures.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Ffeatures.rs?ref=266f452118e27e6a3d9d6b6f9d5483890a18345f", "patch": "@@ -51,6 +51,14 @@ pub struct Feature {\n     pub has_gate_test: bool,\n     pub tracking_issue: Option<NonZeroU32>,\n }\n+impl Feature {\n+    fn tracking_issue_display(&self) -> impl fmt::Display {\n+        match self.tracking_issue {\n+            None => \"none\".to_string(),\n+            Some(x) => x.to_string(),\n+        }\n+    }\n+}\n \n pub type Features = HashMap<String, Feature>;\n \n@@ -361,10 +369,12 @@ fn get_and_check_lib_features(\n                     if f.tracking_issue != s.tracking_issue && f.level != Status::Stable {\n                         tidy_error!(\n                             bad,\n-                            \"{}:{}: mismatches the `issue` in {}\",\n+                            \"{}:{}: `issue` \\\"{}\\\" mismatches the {} `issue` of \\\"{}\\\"\",\n                             file.display(),\n                             line,\n-                            display\n+                            f.tracking_issue_display(),\n+                            display,\n+                            s.tracking_issue_display(),\n                         );\n                     }\n                 }"}]}