{"sha": "f64c95600c0887dbb48a429a00700df47af75eaa", "node_id": "C_kwDOAAsO6NoAKGY2NGM5NTYwMGMwODg3ZGJiNDhhNDI5YTAwNzAwZGY0N2FmNzVlYWE", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-09-12T15:50:42Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-09-12T15:50:42Z"}, "message": "Auto merge of #13216 - DesmondWillowbrook:move_format_string_arg, r=DesmondWillowbrook\n\nNew assist: move_format_string_arg\n\nThe name might need some improving.\n\n```rust\nfn main() {\n    print!(\"{x + 1}\");\n}\n```\nto\n```rust\nfn main() {\n    print!(\"{}\"$0, x + 1);\n}\n```\n\nfixes #13180\n\nref to #5988 for similar work\n\n* extracted `format_like`'s parser to it's own module in `ide-db`\n* reworked the parser's API to be more direct\n* added assist to extract expressions in format args", "tree": {"sha": "6c9a12fb9a0bfc988258443a3a81f73b427792a0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6c9a12fb9a0bfc988258443a3a81f73b427792a0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f64c95600c0887dbb48a429a00700df47af75eaa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f64c95600c0887dbb48a429a00700df47af75eaa", "html_url": "https://github.com/rust-lang/rust/commit/f64c95600c0887dbb48a429a00700df47af75eaa", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f64c95600c0887dbb48a429a00700df47af75eaa/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b1a4ba3e84f021dd3e8eeaaca0eecaa758f8d32c", "url": "https://api.github.com/repos/rust-lang/rust/commits/b1a4ba3e84f021dd3e8eeaaca0eecaa758f8d32c", "html_url": "https://github.com/rust-lang/rust/commit/b1a4ba3e84f021dd3e8eeaaca0eecaa758f8d32c"}, {"sha": "54e9324e93646433e8404af106223890ef52105c", "url": "https://api.github.com/repos/rust-lang/rust/commits/54e9324e93646433e8404af106223890ef52105c", "html_url": "https://github.com/rust-lang/rust/commit/54e9324e93646433e8404af106223890ef52105c"}], "stats": {"total": 816, "additions": 581, "deletions": 235}, "files": [{"sha": "92b2fa79d717bda9deeecb4811de419160c89b55", "filename": "crates/ide-assists/src/handlers/move_format_string_arg.rs", "status": "added", "additions": 268, "deletions": 0, "changes": 268, "blob_url": "https://github.com/rust-lang/rust/blob/f64c95600c0887dbb48a429a00700df47af75eaa/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fmove_format_string_arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f64c95600c0887dbb48a429a00700df47af75eaa/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fmove_format_string_arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fmove_format_string_arg.rs?ref=f64c95600c0887dbb48a429a00700df47af75eaa", "patch": "@@ -0,0 +1,268 @@\n+use crate::{AssistContext, Assists};\n+use ide_db::{\n+    assists::{AssistId, AssistKind},\n+    syntax_helpers::{\n+        format_string::is_format_string,\n+        format_string_exprs::{parse_format_exprs, Arg},\n+    },\n+};\n+use itertools::Itertools;\n+use syntax::{ast, AstNode, AstToken, NodeOrToken, SyntaxKind::COMMA, TextRange};\n+\n+// Assist: move_format_string_arg\n+//\n+// Move an expression out of a format string.\n+//\n+// ```\n+// macro_rules! format_args {\n+//     ($lit:literal $(tt:tt)*) => { 0 },\n+// }\n+// macro_rules! print {\n+//     ($($arg:tt)*) => (std::io::_print(format_args!($($arg)*)));\n+// }\n+//\n+// fn main() {\n+//     print!(\"{x + 1}$0\");\n+// }\n+// ```\n+// ->\n+// ```\n+// macro_rules! format_args {\n+//     ($lit:literal $(tt:tt)*) => { 0 },\n+// }\n+// macro_rules! print {\n+//     ($($arg:tt)*) => (std::io::_print(format_args!($($arg)*)));\n+// }\n+//\n+// fn main() {\n+//     print!(\"{}\"$0, x + 1);\n+// }\n+// ```\n+\n+pub(crate) fn move_format_string_arg(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {\n+    let fmt_string = ctx.find_token_at_offset::<ast::String>()?;\n+    let tt = fmt_string.syntax().parent().and_then(ast::TokenTree::cast)?;\n+\n+    let expanded_t = ast::String::cast(\n+        ctx.sema.descend_into_macros_with_kind_preference(fmt_string.syntax().clone()),\n+    )?;\n+    if !is_format_string(&expanded_t) {\n+        return None;\n+    }\n+\n+    let (new_fmt, extracted_args) = parse_format_exprs(fmt_string.text()).ok()?;\n+    if extracted_args.is_empty() {\n+        return None;\n+    }\n+\n+    acc.add(\n+        AssistId(\n+            \"move_format_string_arg\",\n+            // if there aren't any expressions, then make the assist a RefactorExtract\n+            if extracted_args.iter().filter(|f| matches!(f, Arg::Expr(_))).count() == 0 {\n+                AssistKind::RefactorExtract\n+            } else {\n+                AssistKind::QuickFix\n+            },\n+        ),\n+        \"Extract format args\",\n+        tt.syntax().text_range(),\n+        |edit| {\n+            let fmt_range = fmt_string.syntax().text_range();\n+\n+            // Replace old format string with new format string whose arguments have been extracted\n+            edit.replace(fmt_range, new_fmt);\n+\n+            // Insert cursor at end of format string\n+            edit.insert(fmt_range.end(), \"$0\");\n+\n+            // Extract existing arguments in macro\n+            let tokens =\n+                tt.token_trees_and_tokens().filter_map(NodeOrToken::into_token).collect_vec();\n+\n+            let mut existing_args: Vec<String> = vec![];\n+\n+            let mut current_arg = String::new();\n+            if let [_opening_bracket, format_string, _args_start_comma, tokens @ .., end_bracket] =\n+                tokens.as_slice()\n+            {\n+                for t in tokens {\n+                    if t.kind() == COMMA {\n+                        existing_args.push(current_arg.trim().into());\n+                        current_arg.clear();\n+                    } else {\n+                        current_arg.push_str(t.text());\n+                    }\n+                }\n+                existing_args.push(current_arg.trim().into());\n+\n+                // delete everything after the format string till end bracket\n+                // we're going to insert the new arguments later\n+                edit.delete(TextRange::new(\n+                    format_string.text_range().end(),\n+                    end_bracket.text_range().start(),\n+                ));\n+            }\n+\n+            // Start building the new args\n+            let mut existing_args = existing_args.into_iter();\n+            let mut args = String::new();\n+\n+            let mut placeholder_idx = 1;\n+\n+            for extracted_args in extracted_args {\n+                // remove expr from format string\n+                args.push_str(\", \");\n+\n+                match extracted_args {\n+                    Arg::Ident(s) | Arg::Expr(s) => {\n+                        // insert arg\n+                        args.push_str(&s);\n+                    }\n+                    Arg::Placeholder => {\n+                        // try matching with existing argument\n+                        match existing_args.next() {\n+                            Some(ea) => {\n+                                args.push_str(&ea);\n+                            }\n+                            None => {\n+                                // insert placeholder\n+                                args.push_str(&format!(\"${placeholder_idx}\"));\n+                                placeholder_idx += 1;\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+\n+            // Insert new args\n+            edit.insert(fmt_range.end(), args);\n+        },\n+    );\n+\n+    Some(())\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+    use crate::tests::check_assist;\n+\n+    const MACRO_DECL: &'static str = r#\"\n+macro_rules! format_args {\n+    ($lit:literal $(tt:tt)*) => { 0 },\n+}\n+macro_rules! print {\n+    ($($arg:tt)*) => (std::io::_print(format_args!($($arg)*)));\n+}\n+\"#;\n+\n+    fn add_macro_decl(s: &'static str) -> String {\n+        MACRO_DECL.to_string() + s\n+    }\n+\n+    #[test]\n+    fn multiple_middle_arg() {\n+        check_assist(\n+            move_format_string_arg,\n+            &add_macro_decl(\n+                r#\"\n+fn main() {\n+    print!(\"{} {x + 1:b} {}$0\", y + 2, 2);\n+}\n+\"#,\n+            ),\n+            &add_macro_decl(\n+                r#\"\n+fn main() {\n+    print!(\"{} {:b} {}\"$0, y + 2, x + 1, 2);\n+}\n+\"#,\n+            ),\n+        );\n+    }\n+\n+    #[test]\n+    fn single_arg() {\n+        check_assist(\n+            move_format_string_arg,\n+            &add_macro_decl(\n+                r#\"\n+fn main() {\n+    print!(\"{obj.value:b}$0\",);\n+}\n+\"#,\n+            ),\n+            &add_macro_decl(\n+                r#\"\n+fn main() {\n+    print!(\"{:b}\"$0, obj.value);\n+}\n+\"#,\n+            ),\n+        );\n+    }\n+\n+    #[test]\n+    fn multiple_middle_placeholders_arg() {\n+        check_assist(\n+            move_format_string_arg,\n+            &add_macro_decl(\n+                r#\"\n+fn main() {\n+    print!(\"{} {x + 1:b} {} {}$0\", y + 2, 2);\n+}\n+\"#,\n+            ),\n+            &add_macro_decl(\n+                r#\"\n+fn main() {\n+    print!(\"{} {:b} {} {}\"$0, y + 2, x + 1, 2, $1);\n+}\n+\"#,\n+            ),\n+        );\n+    }\n+\n+    #[test]\n+    fn multiple_trailing_args() {\n+        check_assist(\n+            move_format_string_arg,\n+            &add_macro_decl(\n+                r#\"\n+fn main() {\n+    print!(\"{} {x + 1:b} {Struct(1, 2)}$0\", 1);\n+}\n+\"#,\n+            ),\n+            &add_macro_decl(\n+                r#\"\n+fn main() {\n+    print!(\"{} {:b} {}\"$0, 1, x + 1, Struct(1, 2));\n+}\n+\"#,\n+            ),\n+        );\n+    }\n+\n+    #[test]\n+    fn improper_commas() {\n+        check_assist(\n+            move_format_string_arg,\n+            &add_macro_decl(\n+                r#\"\n+fn main() {\n+    print!(\"{} {x + 1:b} {Struct(1, 2)}$0\", 1,);\n+}\n+\"#,\n+            ),\n+            &add_macro_decl(\n+                r#\"\n+fn main() {\n+    print!(\"{} {:b} {}\"$0, 1, x + 1, Struct(1, 2));\n+}\n+\"#,\n+            ),\n+        );\n+    }\n+}"}, {"sha": "812d22efbd797c42bc533d20c9a477207481aad6", "filename": "crates/ide-assists/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f64c95600c0887dbb48a429a00700df47af75eaa/crates%2Fide-assists%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f64c95600c0887dbb48a429a00700df47af75eaa/crates%2Fide-assists%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Flib.rs?ref=f64c95600c0887dbb48a429a00700df47af75eaa", "patch": "@@ -136,6 +136,7 @@ mod handlers {\n     mod flip_binexpr;\n     mod flip_comma;\n     mod flip_trait_bound;\n+    mod move_format_string_arg;\n     mod generate_constant;\n     mod generate_default_from_enum_variant;\n     mod generate_default_from_new;\n@@ -254,6 +255,7 @@ mod handlers {\n             merge_imports::merge_imports,\n             merge_match_arms::merge_match_arms,\n             move_bounds::move_bounds_to_where_clause,\n+            move_format_string_arg::move_format_string_arg,\n             move_guard::move_arm_cond_to_match_guard,\n             move_guard::move_guard_to_arm_body,\n             move_module_to_file::move_module_to_file,"}, {"sha": "3a696635afd275c8830781e30259f5944f71f2d1", "filename": "crates/ide-assists/src/tests/generated.rs", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/f64c95600c0887dbb48a429a00700df47af75eaa/crates%2Fide-assists%2Fsrc%2Ftests%2Fgenerated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f64c95600c0887dbb48a429a00700df47af75eaa/crates%2Fide-assists%2Fsrc%2Ftests%2Fgenerated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Ftests%2Fgenerated.rs?ref=f64c95600c0887dbb48a429a00700df47af75eaa", "patch": "@@ -1591,6 +1591,37 @@ fn apply<T, U, F>(f: F, x: T) -> U where F: FnOnce(T) -> U {\n     )\n }\n \n+#[test]\n+fn doctest_move_format_string_arg() {\n+    check_doc_test(\n+        \"move_format_string_arg\",\n+        r#####\"\n+macro_rules! format_args {\n+    ($lit:literal $(tt:tt)*) => { 0 },\n+}\n+macro_rules! print {\n+    ($($arg:tt)*) => (std::io::_print(format_args!($($arg)*)));\n+}\n+\n+fn main() {\n+    print!(\"{x + 1}$0\");\n+}\n+\"#####,\n+        r#####\"\n+macro_rules! format_args {\n+    ($lit:literal $(tt:tt)*) => { 0 },\n+}\n+macro_rules! print {\n+    ($($arg:tt)*) => (std::io::_print(format_args!($($arg)*)));\n+}\n+\n+fn main() {\n+    print!(\"{}\"$0, x + 1);\n+}\n+\"#####,\n+    )\n+}\n+\n #[test]\n fn doctest_move_from_mod_rs() {\n     check_doc_test("}, {"sha": "b43bdb9ab9d1a5b861b148195bfdee890c56192e", "filename": "crates/ide-completion/src/completions/postfix/format_like.rs", "status": "modified", "additions": 12, "deletions": 235, "changes": 247, "blob_url": "https://github.com/rust-lang/rust/blob/f64c95600c0887dbb48a429a00700df47af75eaa/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fpostfix%2Fformat_like.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f64c95600c0887dbb48a429a00700df47af75eaa/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fpostfix%2Fformat_like.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fpostfix%2Fformat_like.rs?ref=f64c95600c0887dbb48a429a00700df47af75eaa", "patch": "@@ -16,8 +16,11 @@\n //\n // image::https://user-images.githubusercontent.com/48062697/113020656-b560f500-917a-11eb-87de-02991f61beb8.gif[]\n \n-use ide_db::SnippetCap;\n-use syntax::ast::{self, AstToken};\n+use ide_db::{\n+    syntax_helpers::format_string_exprs::{parse_format_exprs, with_placeholders},\n+    SnippetCap,\n+};\n+use syntax::{ast, AstToken};\n \n use crate::{\n     completions::postfix::build_postfix_snippet_builder, context::CompletionContext, Completions,\n@@ -43,250 +46,24 @@ pub(crate) fn add_format_like_completions(\n     cap: SnippetCap,\n     receiver_text: &ast::String,\n ) {\n-    let input = match string_literal_contents(receiver_text) {\n-        // It's not a string literal, do not parse input.\n-        Some(input) => input,\n-        None => return,\n-    };\n-\n     let postfix_snippet = match build_postfix_snippet_builder(ctx, cap, dot_receiver) {\n         Some(it) => it,\n         None => return,\n     };\n-    let mut parser = FormatStrParser::new(input);\n \n-    if parser.parse().is_ok() {\n+    if let Ok((out, exprs)) = parse_format_exprs(receiver_text.text()) {\n+        let exprs = with_placeholders(exprs);\n         for (label, macro_name) in KINDS {\n-            let snippet = parser.to_suggestion(macro_name);\n+            let snippet = format!(r#\"{}({}, {})\"#, macro_name, out, exprs.join(\", \"));\n \n             postfix_snippet(label, macro_name, &snippet).add_to(acc);\n         }\n     }\n }\n \n-/// Checks whether provided item is a string literal.\n-fn string_literal_contents(item: &ast::String) -> Option<String> {\n-    let item = item.text();\n-    if item.len() >= 2 && item.starts_with('\\\"') && item.ends_with('\\\"') {\n-        return Some(item[1..item.len() - 1].to_owned());\n-    }\n-\n-    None\n-}\n-\n-/// Parser for a format-like string. It is more allowing in terms of string contents,\n-/// as we expect variable placeholders to be filled with expressions.\n-#[derive(Debug)]\n-pub(crate) struct FormatStrParser {\n-    input: String,\n-    output: String,\n-    extracted_expressions: Vec<String>,\n-    state: State,\n-    parsed: bool,\n-}\n-\n-#[derive(Debug, Clone, Copy, PartialEq)]\n-enum State {\n-    NotExpr,\n-    MaybeExpr,\n-    Expr,\n-    MaybeIncorrect,\n-    FormatOpts,\n-}\n-\n-impl FormatStrParser {\n-    pub(crate) fn new(input: String) -> Self {\n-        Self {\n-            input,\n-            output: String::new(),\n-            extracted_expressions: Vec::new(),\n-            state: State::NotExpr,\n-            parsed: false,\n-        }\n-    }\n-\n-    pub(crate) fn parse(&mut self) -> Result<(), ()> {\n-        let mut current_expr = String::new();\n-\n-        let mut placeholder_id = 1;\n-\n-        // Count of open braces inside of an expression.\n-        // We assume that user knows what they're doing, thus we treat it like a correct pattern, e.g.\n-        // \"{MyStruct { val_a: 0, val_b: 1 }}\".\n-        let mut inexpr_open_count = 0;\n-\n-        // We need to escape '\\' and '$'. See the comments on `get_receiver_text()` for detail.\n-        let mut chars = self.input.chars().peekable();\n-        while let Some(chr) = chars.next() {\n-            match (self.state, chr) {\n-                (State::NotExpr, '{') => {\n-                    self.output.push(chr);\n-                    self.state = State::MaybeExpr;\n-                }\n-                (State::NotExpr, '}') => {\n-                    self.output.push(chr);\n-                    self.state = State::MaybeIncorrect;\n-                }\n-                (State::NotExpr, _) => {\n-                    if matches!(chr, '\\\\' | '$') {\n-                        self.output.push('\\\\');\n-                    }\n-                    self.output.push(chr);\n-                }\n-                (State::MaybeIncorrect, '}') => {\n-                    // It's okay, we met \"}}\".\n-                    self.output.push(chr);\n-                    self.state = State::NotExpr;\n-                }\n-                (State::MaybeIncorrect, _) => {\n-                    // Error in the string.\n-                    return Err(());\n-                }\n-                (State::MaybeExpr, '{') => {\n-                    self.output.push(chr);\n-                    self.state = State::NotExpr;\n-                }\n-                (State::MaybeExpr, '}') => {\n-                    // This is an empty sequence '{}'. Replace it with placeholder.\n-                    self.output.push(chr);\n-                    self.extracted_expressions.push(format!(\"${}\", placeholder_id));\n-                    placeholder_id += 1;\n-                    self.state = State::NotExpr;\n-                }\n-                (State::MaybeExpr, _) => {\n-                    if matches!(chr, '\\\\' | '$') {\n-                        current_expr.push('\\\\');\n-                    }\n-                    current_expr.push(chr);\n-                    self.state = State::Expr;\n-                }\n-                (State::Expr, '}') => {\n-                    if inexpr_open_count == 0 {\n-                        self.output.push(chr);\n-                        self.extracted_expressions.push(current_expr.trim().into());\n-                        current_expr = String::new();\n-                        self.state = State::NotExpr;\n-                    } else {\n-                        // We're closing one brace met before inside of the expression.\n-                        current_expr.push(chr);\n-                        inexpr_open_count -= 1;\n-                    }\n-                }\n-                (State::Expr, ':') if chars.peek().copied() == Some(':') => {\n-                    // path separator\n-                    current_expr.push_str(\"::\");\n-                    chars.next();\n-                }\n-                (State::Expr, ':') => {\n-                    if inexpr_open_count == 0 {\n-                        // We're outside of braces, thus assume that it's a specifier, like \"{Some(value):?}\"\n-                        self.output.push(chr);\n-                        self.extracted_expressions.push(current_expr.trim().into());\n-                        current_expr = String::new();\n-                        self.state = State::FormatOpts;\n-                    } else {\n-                        // We're inside of braced expression, assume that it's a struct field name/value delimiter.\n-                        current_expr.push(chr);\n-                    }\n-                }\n-                (State::Expr, '{') => {\n-                    current_expr.push(chr);\n-                    inexpr_open_count += 1;\n-                }\n-                (State::Expr, _) => {\n-                    if matches!(chr, '\\\\' | '$') {\n-                        current_expr.push('\\\\');\n-                    }\n-                    current_expr.push(chr);\n-                }\n-                (State::FormatOpts, '}') => {\n-                    self.output.push(chr);\n-                    self.state = State::NotExpr;\n-                }\n-                (State::FormatOpts, _) => {\n-                    if matches!(chr, '\\\\' | '$') {\n-                        self.output.push('\\\\');\n-                    }\n-                    self.output.push(chr);\n-                }\n-            }\n-        }\n-\n-        if self.state != State::NotExpr {\n-            return Err(());\n-        }\n-\n-        self.parsed = true;\n-        Ok(())\n-    }\n-\n-    pub(crate) fn to_suggestion(&self, macro_name: &str) -> String {\n-        assert!(self.parsed, \"Attempt to get a suggestion from not parsed expression\");\n-\n-        let expressions_as_string = self.extracted_expressions.join(\", \");\n-        format!(r#\"{}(\"{}\", {})\"#, macro_name, self.output, expressions_as_string)\n-    }\n-}\n-\n #[cfg(test)]\n mod tests {\n     use super::*;\n-    use expect_test::{expect, Expect};\n-\n-    fn check(input: &str, expect: &Expect) {\n-        let mut parser = FormatStrParser::new((*input).to_owned());\n-        let outcome_repr = if parser.parse().is_ok() {\n-            // Parsing should be OK, expected repr is \"string; expr_1, expr_2\".\n-            if parser.extracted_expressions.is_empty() {\n-                parser.output\n-            } else {\n-                format!(\"{}; {}\", parser.output, parser.extracted_expressions.join(\", \"))\n-            }\n-        } else {\n-            // Parsing should fail, expected repr is \"-\".\n-            \"-\".to_owned()\n-        };\n-\n-        expect.assert_eq(&outcome_repr);\n-    }\n-\n-    #[test]\n-    fn format_str_parser() {\n-        let test_vector = &[\n-            (\"no expressions\", expect![[\"no expressions\"]]),\n-            (r\"no expressions with \\$0$1\", expect![r\"no expressions with \\\\\\$0\\$1\"]),\n-            (\"{expr} is {2 + 2}\", expect![[\"{} is {}; expr, 2 + 2\"]]),\n-            (\"{expr:?}\", expect![[\"{:?}; expr\"]]),\n-            (\"{expr:1$}\", expect![[r\"{:1\\$}; expr\"]]),\n-            (\"{$0}\", expect![[r\"{}; \\$0\"]]),\n-            (\"{malformed\", expect![[\"-\"]]),\n-            (\"malformed}\", expect![[\"-\"]]),\n-            (\"{{correct\", expect![[\"{{correct\"]]),\n-            (\"correct}}\", expect![[\"correct}}\"]]),\n-            (\"{correct}}}\", expect![[\"{}}}; correct\"]]),\n-            (\"{correct}}}}}\", expect![[\"{}}}}}; correct\"]]),\n-            (\"{incorrect}}\", expect![[\"-\"]]),\n-            (\"placeholders {} {}\", expect![[\"placeholders {} {}; $1, $2\"]]),\n-            (\"mixed {} {2 + 2} {}\", expect![[\"mixed {} {} {}; $1, 2 + 2, $2\"]]),\n-            (\n-                \"{SomeStruct { val_a: 0, val_b: 1 }}\",\n-                expect![[\"{}; SomeStruct { val_a: 0, val_b: 1 }\"]],\n-            ),\n-            (\"{expr:?} is {2.32f64:.5}\", expect![[\"{:?} is {:.5}; expr, 2.32f64\"]]),\n-            (\n-                \"{SomeStruct { val_a: 0, val_b: 1 }:?}\",\n-                expect![[\"{:?}; SomeStruct { val_a: 0, val_b: 1 }\"]],\n-            ),\n-            (\"{     2 + 2        }\", expect![[\"{}; 2 + 2\"]]),\n-            (\"{strsim::jaro_winkle(a)}\", expect![[\"{}; strsim::jaro_winkle(a)\"]]),\n-            (\"{foo::bar::baz()}\", expect![[\"{}; foo::bar::baz()\"]]),\n-            (\"{foo::bar():?}\", expect![[\"{:?}; foo::bar()\"]]),\n-        ];\n-\n-        for (input, output) in test_vector {\n-            check(input, output)\n-        }\n-    }\n \n     #[test]\n     fn test_into_suggestion() {\n@@ -302,10 +79,10 @@ mod tests {\n         ];\n \n         for (kind, input, output) in test_vector {\n-            let mut parser = FormatStrParser::new((*input).to_owned());\n-            parser.parse().expect(\"Parsing must succeed\");\n-\n-            assert_eq!(&parser.to_suggestion(*kind), output);\n+            let (parsed_string, exprs) = parse_format_exprs(input).unwrap();\n+            let exprs = with_placeholders(exprs);\n+            let snippet = format!(r#\"{}(\"{}\", {})\"#, kind, parsed_string, exprs.join(\", \"));\n+            assert_eq!(&snippet, output);\n         }\n     }\n }"}, {"sha": "e0bc0f89f0a1d14bdd54d384802ae8587311e41d", "filename": "crates/ide-db/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f64c95600c0887dbb48a429a00700df47af75eaa/crates%2Fide-db%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f64c95600c0887dbb48a429a00700df47af75eaa/crates%2Fide-db%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-db%2Fsrc%2Flib.rs?ref=f64c95600c0887dbb48a429a00700df47af75eaa", "patch": "@@ -38,6 +38,7 @@ pub mod syntax_helpers {\n     pub mod node_ext;\n     pub mod insert_whitespace_into_node;\n     pub mod format_string;\n+    pub mod format_string_exprs;\n \n     pub use parser::LexedStr;\n }"}, {"sha": "ac6c6e8feeea01e1b2ef90cc2c664fd0b1bb76fe", "filename": "crates/ide-db/src/syntax_helpers/format_string_exprs.rs", "status": "added", "additions": 267, "deletions": 0, "changes": 267, "blob_url": "https://github.com/rust-lang/rust/blob/f64c95600c0887dbb48a429a00700df47af75eaa/crates%2Fide-db%2Fsrc%2Fsyntax_helpers%2Fformat_string_exprs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f64c95600c0887dbb48a429a00700df47af75eaa/crates%2Fide-db%2Fsrc%2Fsyntax_helpers%2Fformat_string_exprs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-db%2Fsrc%2Fsyntax_helpers%2Fformat_string_exprs.rs?ref=f64c95600c0887dbb48a429a00700df47af75eaa", "patch": "@@ -0,0 +1,267 @@\n+//! Tools to work with expressions present in format string literals for the `format_args!` family of macros.\n+//! Primarily meant for assists and completions.\n+\n+/// Enum for represenging extraced format string args.\n+/// Can either be extracted expressions (which includes identifiers),\n+/// or placeholders `{}`.\n+#[derive(Debug, PartialEq, Eq)]\n+pub enum Arg {\n+    Placeholder,\n+    Ident(String),\n+    Expr(String),\n+}\n+\n+/**\n+ Add placeholders like `$1` and `$2` in place of [`Arg::Placeholder`],\n+ and unwraps the [`Arg::Ident`] and [`Arg::Expr`] enums.\n+ ```rust\n+ # use ide_db::syntax_helpers::format_string_exprs::*;\n+ assert_eq!(with_placeholders(vec![Arg::Ident(\"ident\".to_owned()), Arg::Placeholder, Arg::Expr(\"expr + 2\".to_owned())]), vec![\"ident\".to_owned(), \"$1\".to_owned(), \"expr + 2\".to_owned()])\n+ ```\n+*/\n+\n+pub fn with_placeholders(args: Vec<Arg>) -> Vec<String> {\n+    let mut placeholder_id = 1;\n+    args.into_iter()\n+        .map(move |a| match a {\n+            Arg::Expr(s) | Arg::Ident(s) => s,\n+            Arg::Placeholder => {\n+                let s = format!(\"${placeholder_id}\");\n+                placeholder_id += 1;\n+                s\n+            }\n+        })\n+        .collect()\n+}\n+\n+/**\n+ Parser for a format-like string. It is more allowing in terms of string contents,\n+ as we expect variable placeholders to be filled with expressions.\n+\n+ Built for completions and assists, and escapes `\\` and `$` in output.\n+ (See the comments on `get_receiver_text()` for detail.)\n+ Splits a format string that may contain expressions\n+ like\n+ ```rust\n+ assert_eq!(parse(\"{ident} {} {expr + 42} \").unwrap(), (\"{} {} {}\", vec![Arg::Ident(\"ident\"), Arg::Placeholder, Arg::Expr(\"expr + 42\")]));\n+ ```\n+*/\n+pub fn parse_format_exprs(input: &str) -> Result<(String, Vec<Arg>), ()> {\n+    #[derive(Debug, Clone, Copy, PartialEq)]\n+    enum State {\n+        NotArg,\n+        MaybeArg,\n+        Expr,\n+        Ident,\n+        MaybeIncorrect,\n+        FormatOpts,\n+    }\n+\n+    let mut state = State::NotArg;\n+    let mut current_expr = String::new();\n+    let mut extracted_expressions = Vec::new();\n+    let mut output = String::new();\n+\n+    // Count of open braces inside of an expression.\n+    // We assume that user knows what they're doing, thus we treat it like a correct pattern, e.g.\n+    // \"{MyStruct { val_a: 0, val_b: 1 }}\".\n+    let mut inexpr_open_count = 0;\n+\n+    let mut chars = input.chars().peekable();\n+    while let Some(chr) = chars.next() {\n+        match (state, chr) {\n+            (State::NotArg, '{') => {\n+                output.push(chr);\n+                state = State::MaybeArg;\n+            }\n+            (State::NotArg, '}') => {\n+                output.push(chr);\n+                state = State::MaybeIncorrect;\n+            }\n+            (State::NotArg, _) => {\n+                if matches!(chr, '\\\\' | '$') {\n+                    output.push('\\\\');\n+                }\n+                output.push(chr);\n+            }\n+            (State::MaybeIncorrect, '}') => {\n+                // It's okay, we met \"}}\".\n+                output.push(chr);\n+                state = State::NotArg;\n+            }\n+            (State::MaybeIncorrect, _) => {\n+                // Error in the string.\n+                return Err(());\n+            }\n+            // Escaped braces `{{`\n+            (State::MaybeArg, '{') => {\n+                output.push(chr);\n+                state = State::NotArg;\n+            }\n+            (State::MaybeArg, '}') => {\n+                // This is an empty sequence '{}'.\n+                output.push(chr);\n+                extracted_expressions.push(Arg::Placeholder);\n+                state = State::NotArg;\n+            }\n+            (State::MaybeArg, _) => {\n+                if matches!(chr, '\\\\' | '$') {\n+                    current_expr.push('\\\\');\n+                }\n+                current_expr.push(chr);\n+\n+                // While Rust uses the unicode sets of XID_start and XID_continue for Identifiers\n+                // this is probably the best we can do to avoid a false positive\n+                if chr.is_alphabetic() || chr == '_' {\n+                    state = State::Ident;\n+                } else {\n+                    state = State::Expr;\n+                }\n+            }\n+            (State::Ident | State::Expr, '}') => {\n+                if inexpr_open_count == 0 {\n+                    output.push(chr);\n+\n+                    if matches!(state, State::Expr) {\n+                        extracted_expressions.push(Arg::Expr(current_expr.trim().into()));\n+                    } else {\n+                        extracted_expressions.push(Arg::Ident(current_expr.trim().into()));\n+                    }\n+\n+                    current_expr = String::new();\n+                    state = State::NotArg;\n+                } else {\n+                    // We're closing one brace met before inside of the expression.\n+                    current_expr.push(chr);\n+                    inexpr_open_count -= 1;\n+                }\n+            }\n+            (State::Ident | State::Expr, ':') if matches!(chars.peek(), Some(':')) => {\n+                // path separator\n+                state = State::Expr;\n+                current_expr.push_str(\"::\");\n+                chars.next();\n+            }\n+            (State::Ident | State::Expr, ':') => {\n+                if inexpr_open_count == 0 {\n+                    // We're outside of braces, thus assume that it's a specifier, like \"{Some(value):?}\"\n+                    output.push(chr);\n+\n+                    if matches!(state, State::Expr) {\n+                        extracted_expressions.push(Arg::Expr(current_expr.trim().into()));\n+                    } else {\n+                        extracted_expressions.push(Arg::Ident(current_expr.trim().into()));\n+                    }\n+\n+                    current_expr = String::new();\n+                    state = State::FormatOpts;\n+                } else {\n+                    // We're inside of braced expression, assume that it's a struct field name/value delimiter.\n+                    current_expr.push(chr);\n+                }\n+            }\n+            (State::Ident | State::Expr, '{') => {\n+                state = State::Expr;\n+                current_expr.push(chr);\n+                inexpr_open_count += 1;\n+            }\n+            (State::Ident | State::Expr, _) => {\n+                if !(chr.is_alphanumeric() || chr == '_' || chr == '#') {\n+                    state = State::Expr;\n+                }\n+\n+                if matches!(chr, '\\\\' | '$') {\n+                    current_expr.push('\\\\');\n+                }\n+                current_expr.push(chr);\n+            }\n+            (State::FormatOpts, '}') => {\n+                output.push(chr);\n+                state = State::NotArg;\n+            }\n+            (State::FormatOpts, _) => {\n+                if matches!(chr, '\\\\' | '$') {\n+                    output.push('\\\\');\n+                }\n+                output.push(chr);\n+            }\n+        }\n+    }\n+\n+    if state != State::NotArg {\n+        return Err(());\n+    }\n+\n+    Ok((output, extracted_expressions))\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+    use expect_test::{expect, Expect};\n+\n+    fn check(input: &str, expect: &Expect) {\n+        let (output, exprs) = parse_format_exprs(input).unwrap_or((\"-\".to_string(), vec![]));\n+        let outcome_repr = if !exprs.is_empty() {\n+            format!(\"{}; {}\", output, with_placeholders(exprs).join(\", \"))\n+        } else {\n+            output\n+        };\n+\n+        expect.assert_eq(&outcome_repr);\n+    }\n+\n+    #[test]\n+    fn format_str_parser() {\n+        let test_vector = &[\n+            (\"no expressions\", expect![[\"no expressions\"]]),\n+            (r\"no expressions with \\$0$1\", expect![r\"no expressions with \\\\\\$0\\$1\"]),\n+            (\"{expr} is {2 + 2}\", expect![[\"{} is {}; expr, 2 + 2\"]]),\n+            (\"{expr:?}\", expect![[\"{:?}; expr\"]]),\n+            (\"{expr:1$}\", expect![[r\"{:1\\$}; expr\"]]),\n+            (\"{$0}\", expect![[r\"{}; \\$0\"]]),\n+            (\"{malformed\", expect![[\"-\"]]),\n+            (\"malformed}\", expect![[\"-\"]]),\n+            (\"{{correct\", expect![[\"{{correct\"]]),\n+            (\"correct}}\", expect![[\"correct}}\"]]),\n+            (\"{correct}}}\", expect![[\"{}}}; correct\"]]),\n+            (\"{correct}}}}}\", expect![[\"{}}}}}; correct\"]]),\n+            (\"{incorrect}}\", expect![[\"-\"]]),\n+            (\"placeholders {} {}\", expect![[\"placeholders {} {}; $1, $2\"]]),\n+            (\"mixed {} {2 + 2} {}\", expect![[\"mixed {} {} {}; $1, 2 + 2, $2\"]]),\n+            (\n+                \"{SomeStruct { val_a: 0, val_b: 1 }}\",\n+                expect![[\"{}; SomeStruct { val_a: 0, val_b: 1 }\"]],\n+            ),\n+            (\"{expr:?} is {2.32f64:.5}\", expect![[\"{:?} is {:.5}; expr, 2.32f64\"]]),\n+            (\n+                \"{SomeStruct { val_a: 0, val_b: 1 }:?}\",\n+                expect![[\"{:?}; SomeStruct { val_a: 0, val_b: 1 }\"]],\n+            ),\n+            (\"{     2 + 2        }\", expect![[\"{}; 2 + 2\"]]),\n+            (\"{strsim::jaro_winkle(a)}\", expect![[\"{}; strsim::jaro_winkle(a)\"]]),\n+            (\"{foo::bar::baz()}\", expect![[\"{}; foo::bar::baz()\"]]),\n+            (\"{foo::bar():?}\", expect![[\"{:?}; foo::bar()\"]]),\n+        ];\n+\n+        for (input, output) in test_vector {\n+            check(input, output)\n+        }\n+    }\n+\n+    #[test]\n+    fn arg_type() {\n+        assert_eq!(\n+            parse_format_exprs(\"{_ident} {r#raw_ident} {expr.obj} {name {thing: 42} } {}\")\n+                .unwrap()\n+                .1,\n+            vec![\n+                Arg::Ident(\"_ident\".to_owned()),\n+                Arg::Ident(\"r#raw_ident\".to_owned()),\n+                Arg::Expr(\"expr.obj\".to_owned()),\n+                Arg::Expr(\"name {thing: 42}\".to_owned()),\n+                Arg::Placeholder\n+            ]\n+        );\n+    }\n+}"}]}