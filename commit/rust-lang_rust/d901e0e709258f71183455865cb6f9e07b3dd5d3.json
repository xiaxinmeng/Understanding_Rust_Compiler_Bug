{"sha": "d901e0e709258f71183455865cb6f9e07b3dd5d3", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ5MDFlMGU3MDkyNThmNzExODM0NTU4NjVjYjZmOWUwN2IzZGQ1ZDM=", "commit": {"author": {"name": "vsrs", "email": "vit@conrlab.com", "date": "2020-05-16T08:57:41Z"}, "committer": {"name": "vsrs", "email": "vit@conrlab.com", "date": "2020-05-16T08:57:41Z"}, "message": "Reimplement ra_db::fixture::ParsedMeta\n\nin terms of test_utils::FixtureMeta", "tree": {"sha": "18c39839206d8c10bf2539cd0ae66162f02b3563", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/18c39839206d8c10bf2539cd0ae66162f02b3563"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d901e0e709258f71183455865cb6f9e07b3dd5d3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d901e0e709258f71183455865cb6f9e07b3dd5d3", "html_url": "https://github.com/rust-lang/rust/commit/d901e0e709258f71183455865cb6f9e07b3dd5d3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d901e0e709258f71183455865cb6f9e07b3dd5d3/comments", "author": {"login": "vsrs", "id": 62505555, "node_id": "MDQ6VXNlcjYyNTA1NTU1", "avatar_url": "https://avatars.githubusercontent.com/u/62505555?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vsrs", "html_url": "https://github.com/vsrs", "followers_url": "https://api.github.com/users/vsrs/followers", "following_url": "https://api.github.com/users/vsrs/following{/other_user}", "gists_url": "https://api.github.com/users/vsrs/gists{/gist_id}", "starred_url": "https://api.github.com/users/vsrs/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vsrs/subscriptions", "organizations_url": "https://api.github.com/users/vsrs/orgs", "repos_url": "https://api.github.com/users/vsrs/repos", "events_url": "https://api.github.com/users/vsrs/events{/privacy}", "received_events_url": "https://api.github.com/users/vsrs/received_events", "type": "User", "site_admin": false}, "committer": {"login": "vsrs", "id": 62505555, "node_id": "MDQ6VXNlcjYyNTA1NTU1", "avatar_url": "https://avatars.githubusercontent.com/u/62505555?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vsrs", "html_url": "https://github.com/vsrs", "followers_url": "https://api.github.com/users/vsrs/followers", "following_url": "https://api.github.com/users/vsrs/following{/other_user}", "gists_url": "https://api.github.com/users/vsrs/gists{/gist_id}", "starred_url": "https://api.github.com/users/vsrs/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vsrs/subscriptions", "organizations_url": "https://api.github.com/users/vsrs/orgs", "repos_url": "https://api.github.com/users/vsrs/repos", "events_url": "https://api.github.com/users/vsrs/events{/privacy}", "received_events_url": "https://api.github.com/users/vsrs/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "eeb98237d1cf5134ca3e41b85e1e9e07cab83c75", "url": "https://api.github.com/repos/rust-lang/rust/commits/eeb98237d1cf5134ca3e41b85e1e9e07cab83c75", "html_url": "https://github.com/rust-lang/rust/commit/eeb98237d1cf5134ca3e41b85e1e9e07cab83c75"}], "stats": {"total": 79, "additions": 28, "deletions": 51}, "files": [{"sha": "6e2c7ff725048627fb940165b1d7477d9dc37518", "filename": "crates/ra_db/src/fixture.rs", "status": "modified", "additions": 26, "deletions": 48, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/d901e0e709258f71183455865cb6f9e07b3dd5d3/crates%2Fra_db%2Fsrc%2Ffixture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d901e0e709258f71183455865cb6f9e07b3dd5d3/crates%2Fra_db%2Fsrc%2Ffixture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_db%2Fsrc%2Ffixture.rs?ref=d901e0e709258f71183455865cb6f9e07b3dd5d3", "patch": "@@ -49,7 +49,7 @@ use std::sync::Arc;\n \n use ra_cfg::CfgOptions;\n use rustc_hash::FxHashMap;\n-use test_utils::{extract_offset, parse_fixture, parse_single_fixture, CURSOR_MARKER};\n+use test_utils::{extract_offset, parse_fixture, parse_single_fixture, FixtureMeta, CURSOR_MARKER};\n \n use crate::{\n     input::CrateName, CrateGraph, CrateId, Edition, Env, FileId, FilePosition, RelativePathBuf,\n@@ -99,7 +99,7 @@ fn with_single_file(db: &mut dyn SourceDatabaseExt, ra_fixture: &str) -> FileId\n     let fixture = parse_single_fixture(ra_fixture);\n \n     let crate_graph = if let Some(entry) = fixture {\n-        let meta = match parse_meta(&entry.meta) {\n+        let meta = match ParsedMeta::from(&entry.parsed_meta) {\n             ParsedMeta::File(it) => it,\n             _ => panic!(\"with_single_file only support file meta\"),\n         };\n@@ -156,7 +156,7 @@ fn with_files(db: &mut dyn SourceDatabaseExt, fixture: &str) -> Option<FilePosit\n     let mut file_position = None;\n \n     for entry in fixture.iter() {\n-        let meta = match parse_meta(&entry.meta) {\n+        let meta = match ParsedMeta::from(&entry.parsed_meta) {\n             ParsedMeta::Root { path } => {\n                 let source_root = std::mem::replace(&mut source_root, SourceRoot::new_local());\n                 db.set_source_root(source_root_id, Arc::new(source_root));\n@@ -244,53 +244,31 @@ struct FileMeta {\n     env: Env,\n }\n \n-//- /lib.rs crate:foo deps:bar,baz cfg:foo=a,bar=b env:OUTDIR=path/to,OTHER=foo)\n-fn parse_meta(meta: &str) -> ParsedMeta {\n-    let components = meta.split_ascii_whitespace().collect::<Vec<_>>();\n-\n-    if components[0] == \"root\" {\n-        let path: RelativePathBuf = components[1].into();\n-        assert!(path.starts_with(\"/\") && path.ends_with(\"/\"));\n-        return ParsedMeta::Root { path };\n-    }\n-\n-    let path: RelativePathBuf = components[0].into();\n-    assert!(path.starts_with(\"/\"));\n-\n-    let mut krate = None;\n-    let mut deps = Vec::new();\n-    let mut edition = Edition::Edition2018;\n-    let mut cfg = CfgOptions::default();\n-    let mut env = Env::default();\n-    for component in components[1..].iter() {\n-        let (key, value) = split1(component, ':').unwrap();\n-        match key {\n-            \"crate\" => krate = Some(value.to_string()),\n-            \"deps\" => deps = value.split(',').map(|it| it.to_string()).collect(),\n-            \"edition\" => edition = Edition::from_str(&value).unwrap(),\n-            \"cfg\" => {\n-                for key in value.split(',') {\n-                    match split1(key, '=') {\n-                        None => cfg.insert_atom(key.into()),\n-                        Some((k, v)) => cfg.insert_key_value(k.into(), v.into()),\n-                    }\n-                }\n+impl From<&FixtureMeta> for ParsedMeta {\n+    fn from(meta: &FixtureMeta) -> Self {\n+        match meta {\n+            FixtureMeta::Root { path } => {\n+                // `Self::Root` causes a false warning: 'variant is never constructed: `Root` '\n+                // see https://github.com/rust-lang/rust/issues/69018\n+                ParsedMeta::Root { path: path.to_owned() }\n             }\n-            \"env\" => {\n-                for key in value.split(',') {\n-                    if let Some((k, v)) = split1(key, '=') {\n-                        env.set(k, v.into());\n+            FixtureMeta::File(f) => Self::File(FileMeta {\n+                path: f.path.to_owned().into(),\n+                krate: f.krate.to_owned().into(),\n+                deps: f.deps.to_owned(),\n+                cfg: f.cfg.to_owned(),\n+                edition: f\n+                    .edition\n+                    .as_ref()\n+                    .map_or(Edition::Edition2018, |v| Edition::from_str(&v).unwrap()),\n+                env: {\n+                    let mut env = Env::default();\n+                    for (k, v) in &f.env {\n+                        env.set(&k, v.to_owned());\n                     }\n-                }\n-            }\n-            _ => panic!(\"bad component: {:?}\", component),\n+                    env\n+                },\n+            }),\n         }\n     }\n-\n-    ParsedMeta::File(FileMeta { path, krate, deps, edition, cfg, env })\n-}\n-\n-fn split1(haystack: &str, delim: char) -> Option<(&str, &str)> {\n-    let idx = haystack.find(delim)?;\n-    Some((&haystack[..idx], &haystack[idx + delim.len_utf8()..]))\n }"}, {"sha": "0c367ce71a625a722bf7ab88112b6410d001df83", "filename": "crates/test_utils/src/lib.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d901e0e709258f71183455865cb6f9e07b3dd5d3/crates%2Ftest_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d901e0e709258f71183455865cb6f9e07b3dd5d3/crates%2Ftest_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Ftest_utils%2Fsrc%2Flib.rs?ref=d901e0e709258f71183455865cb6f9e07b3dd5d3", "patch": "@@ -16,10 +16,10 @@ use std::{\n \n pub use ra_cfg::CfgOptions;\n \n-use serde_json::Value;\n-use text_size::{TextRange, TextSize};\n pub use relative_path::{RelativePath, RelativePathBuf};\n pub use rustc_hash::FxHashMap;\n+use serde_json::Value;\n+use text_size::{TextRange, TextSize};\n \n pub use difference::Changeset as __Changeset;\n \n@@ -292,7 +292,6 @@ fn split1(haystack: &str, delim: char) -> Option<(&str, &str)> {\n     Some((&haystack[..idx], &haystack[idx + delim.len_utf8()..]))\n }\n \n-\n /// Adjusts the indentation of the first line to the minimum indentation of the rest of the lines.\n /// This allows fixtures to start off in a different indentation, e.g. to align the first line with\n /// the other lines visually:"}]}