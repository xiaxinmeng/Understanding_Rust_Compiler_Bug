{"sha": "cfa3fe5af339e724209b25715282adae0c61628f", "node_id": "C_kwDOAAsO6NoAKGNmYTNmZTVhZjMzOWU3MjQyMDliMjU3MTUyODJhZGFlMGM2MTYyOGY", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-12-31T19:54:10Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-12-31T19:54:10Z"}, "message": "Auto merge of #90637 - Mark-Simulacrum:liveness-btree, r=lqd\n\nStore liveness in interval sets for region inference\n\nOn the 100,000 line test case from https://github.com/rust-lang/rust/issues/90445, this reduces memory usage from 35 GB to 444 MB at peak (based on DHAT results, though with regular malloc), and yields a 9.4x speedup, with wall time going from 14.5 seconds to 1.5s. Performance results show that for the majority of real-world code this has little to no impact, but it's expected to generally scale better for auto-generated functions and other cases which stress this area of the compiler, as results on #90445 illustrate.\n\nThere may also be further room for improvement in future PRs making use of this data structures benefits over raw bitsets (which, at some level, are a less perfect fit for representing liveness, which is almost always composed of contiguous ranges, not point locations).\n\nFixes #90445.", "tree": {"sha": "3d218549efc64ca3257e885dea7b1aba99bdd574", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3d218549efc64ca3257e885dea7b1aba99bdd574"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cfa3fe5af339e724209b25715282adae0c61628f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cfa3fe5af339e724209b25715282adae0c61628f", "html_url": "https://github.com/rust-lang/rust/commit/cfa3fe5af339e724209b25715282adae0c61628f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cfa3fe5af339e724209b25715282adae0c61628f/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "984a6bf9c11b7356f696c685a145d7136fff051c", "url": "https://api.github.com/repos/rust-lang/rust/commits/984a6bf9c11b7356f696c685a145d7136fff051c", "html_url": "https://github.com/rust-lang/rust/commit/984a6bf9c11b7356f696c685a145d7136fff051c"}, {"sha": "4abb3283f38886bef53545e2065c21268362b2df", "url": "https://api.github.com/repos/rust-lang/rust/commits/4abb3283f38886bef53545e2065c21268362b2df", "html_url": "https://github.com/rust-lang/rust/commit/4abb3283f38886bef53545e2065c21268362b2df"}], "stats": {"total": 508, "additions": 491, "deletions": 17}, "files": [{"sha": "ffc83d80da154838444a751924434d98cd495d4d", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cfa3fe5af339e724209b25715282adae0c61628f/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/cfa3fe5af339e724209b25715282adae0c61628f/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=cfa3fe5af339e724209b25715282adae0c61628f", "patch": "@@ -3976,6 +3976,7 @@ dependencies = [\n  \"arrayvec\",\n  \"rustc_macros\",\n  \"rustc_serialize\",\n+ \"smallvec\",\n ]\n \n [[package]]"}, {"sha": "4a70535c63bea2fdddd690cc088e900f0a1f3919", "filename": "compiler/rustc_borrowck/src/region_infer/values.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/cfa3fe5af339e724209b25715282adae0c61628f/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fvalues.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfa3fe5af339e724209b25715282adae0c61628f/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fvalues.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fvalues.rs?ref=cfa3fe5af339e724209b25715282adae0c61628f", "patch": "@@ -1,5 +1,7 @@\n use rustc_data_structures::fx::FxIndexSet;\n-use rustc_index::bit_set::{HybridBitSet, SparseBitMatrix};\n+use rustc_index::bit_set::SparseBitMatrix;\n+use rustc_index::interval::IntervalSet;\n+use rustc_index::interval::SparseIntervalMatrix;\n use rustc_index::vec::Idx;\n use rustc_index::vec::IndexVec;\n use rustc_middle::mir::{BasicBlock, Body, Location};\n@@ -110,19 +112,19 @@ crate enum RegionElement {\n     PlaceholderRegion(ty::PlaceholderRegion),\n }\n \n-/// When we initially compute liveness, we use a bit matrix storing\n-/// points for each region-vid.\n+/// When we initially compute liveness, we use an interval matrix storing\n+/// liveness ranges for each region-vid.\n crate struct LivenessValues<N: Idx> {\n     elements: Rc<RegionValueElements>,\n-    points: SparseBitMatrix<N, PointIndex>,\n+    points: SparseIntervalMatrix<N, PointIndex>,\n }\n \n impl<N: Idx> LivenessValues<N> {\n     /// Creates a new set of \"region values\" that tracks causal information.\n     /// Each of the regions in num_region_variables will be initialized with an\n     /// empty set of points and no causal information.\n     crate fn new(elements: Rc<RegionValueElements>) -> Self {\n-        Self { points: SparseBitMatrix::new(elements.num_points), elements }\n+        Self { points: SparseIntervalMatrix::new(elements.num_points), elements }\n     }\n \n     /// Iterate through each region that has a value in this set.\n@@ -140,7 +142,7 @@ impl<N: Idx> LivenessValues<N> {\n \n     /// Adds all the elements in the given bit array into the given\n     /// region. Returns whether any of them are newly added.\n-    crate fn add_elements(&mut self, row: N, locations: &HybridBitSet<PointIndex>) -> bool {\n+    crate fn add_elements(&mut self, row: N, locations: &IntervalSet<PointIndex>) -> bool {\n         debug!(\"LivenessValues::add_elements(row={:?}, locations={:?})\", row, locations);\n         self.points.union_row(row, locations)\n     }\n@@ -153,7 +155,7 @@ impl<N: Idx> LivenessValues<N> {\n     /// Returns `true` if the region `r` contains the given element.\n     crate fn contains(&self, row: N, location: Location) -> bool {\n         let index = self.elements.point_from_location(location);\n-        self.points.contains(row, index)\n+        self.points.row(row).map_or(false, |r| r.contains(index))\n     }\n \n     /// Returns an iterator of all the elements contained by the region `r`\n@@ -221,7 +223,7 @@ impl PlaceholderIndices {\n crate struct RegionValues<N: Idx> {\n     elements: Rc<RegionValueElements>,\n     placeholder_indices: Rc<PlaceholderIndices>,\n-    points: SparseBitMatrix<N, PointIndex>,\n+    points: SparseIntervalMatrix<N, PointIndex>,\n     free_regions: SparseBitMatrix<N, RegionVid>,\n \n     /// Placeholders represent bound regions -- so something like `'a`\n@@ -241,7 +243,7 @@ impl<N: Idx> RegionValues<N> {\n         let num_placeholders = placeholder_indices.len();\n         Self {\n             elements: elements.clone(),\n-            points: SparseBitMatrix::new(elements.num_points),\n+            points: SparseIntervalMatrix::new(elements.num_points),\n             placeholder_indices: placeholder_indices.clone(),\n             free_regions: SparseBitMatrix::new(num_universal_regions),\n             placeholders: SparseBitMatrix::new(num_placeholders),"}, {"sha": "094af20f52efc9ad5573973169e7901284baac78", "filename": "compiler/rustc_borrowck/src/type_check/liveness/trace.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/cfa3fe5af339e724209b25715282adae0c61628f/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fliveness%2Ftrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfa3fe5af339e724209b25715282adae0c61628f/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fliveness%2Ftrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fliveness%2Ftrace.rs?ref=cfa3fe5af339e724209b25715282adae0c61628f", "patch": "@@ -1,5 +1,6 @@\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_index::bit_set::HybridBitSet;\n+use rustc_index::interval::IntervalSet;\n use rustc_infer::infer::canonical::QueryRegionConstraints;\n use rustc_middle::mir::{BasicBlock, Body, ConstraintCategory, Local, Location};\n use rustc_middle::ty::{Ty, TypeFoldable};\n@@ -105,12 +106,12 @@ struct LivenessResults<'me, 'typeck, 'flow, 'tcx> {\n \n     /// Points where the current variable is \"use live\" -- meaning\n     /// that there is a future \"full use\" that may use its value.\n-    use_live_at: HybridBitSet<PointIndex>,\n+    use_live_at: IntervalSet<PointIndex>,\n \n     /// Points where the current variable is \"drop live\" -- meaning\n     /// that there is no future \"full use\" that may use its value, but\n     /// there is a future drop.\n-    drop_live_at: HybridBitSet<PointIndex>,\n+    drop_live_at: IntervalSet<PointIndex>,\n \n     /// Locations where drops may occur.\n     drop_locations: Vec<Location>,\n@@ -125,8 +126,8 @@ impl<'me, 'typeck, 'flow, 'tcx> LivenessResults<'me, 'typeck, 'flow, 'tcx> {\n         LivenessResults {\n             cx,\n             defs: HybridBitSet::new_empty(num_points),\n-            use_live_at: HybridBitSet::new_empty(num_points),\n-            drop_live_at: HybridBitSet::new_empty(num_points),\n+            use_live_at: IntervalSet::new(num_points),\n+            drop_live_at: IntervalSet::new(num_points),\n             drop_locations: vec![],\n             stack: vec![],\n         }\n@@ -165,7 +166,7 @@ impl<'me, 'typeck, 'flow, 'tcx> LivenessResults<'me, 'typeck, 'flow, 'tcx> {\n         drop_used: Vec<(Local, Location)>,\n         live_locals: FxHashSet<Local>,\n     ) {\n-        let locations = HybridBitSet::new_empty(self.cx.elements.num_points());\n+        let locations = IntervalSet::new(self.cx.elements.num_points());\n \n         for (local, location) in drop_used {\n             if !live_locals.contains(&local) {\n@@ -456,7 +457,7 @@ impl<'tcx> LivenessContext<'_, '_, '_, 'tcx> {\n     fn add_use_live_facts_for(\n         &mut self,\n         value: impl TypeFoldable<'tcx>,\n-        live_at: &HybridBitSet<PointIndex>,\n+        live_at: &IntervalSet<PointIndex>,\n     ) {\n         debug!(\"add_use_live_facts_for(value={:?})\", value);\n \n@@ -473,7 +474,7 @@ impl<'tcx> LivenessContext<'_, '_, '_, 'tcx> {\n         dropped_local: Local,\n         dropped_ty: Ty<'tcx>,\n         drop_locations: &[Location],\n-        live_at: &HybridBitSet<PointIndex>,\n+        live_at: &IntervalSet<PointIndex>,\n     ) {\n         debug!(\n             \"add_drop_live_constraint(\\\n@@ -521,7 +522,7 @@ impl<'tcx> LivenessContext<'_, '_, '_, 'tcx> {\n         elements: &RegionValueElements,\n         typeck: &mut TypeChecker<'_, 'tcx>,\n         value: impl TypeFoldable<'tcx>,\n-        live_at: &HybridBitSet<PointIndex>,\n+        live_at: &IntervalSet<PointIndex>,\n     ) {\n         debug!(\"make_all_regions_live(value={:?})\", value);\n         debug!("}, {"sha": "89419bfce6f5bf86846713017ce68afab612aca1", "filename": "compiler/rustc_index/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cfa3fe5af339e724209b25715282adae0c61628f/compiler%2Frustc_index%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/cfa3fe5af339e724209b25715282adae0c61628f/compiler%2Frustc_index%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_index%2FCargo.toml?ref=cfa3fe5af339e724209b25715282adae0c61628f", "patch": "@@ -10,3 +10,4 @@ doctest = false\n arrayvec = { version = \"0.7\", default-features = false }\n rustc_serialize = { path = \"../rustc_serialize\" }\n rustc_macros = { path = \"../rustc_macros\" }\n+smallvec = \"1\""}, {"sha": "6da95053b116d2092e4bdaeef7f08fe2904c46be", "filename": "compiler/rustc_index/src/interval.rs", "status": "added", "additions": 269, "deletions": 0, "changes": 269, "blob_url": "https://github.com/rust-lang/rust/blob/cfa3fe5af339e724209b25715282adae0c61628f/compiler%2Frustc_index%2Fsrc%2Finterval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfa3fe5af339e724209b25715282adae0c61628f/compiler%2Frustc_index%2Fsrc%2Finterval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_index%2Fsrc%2Finterval.rs?ref=cfa3fe5af339e724209b25715282adae0c61628f", "patch": "@@ -0,0 +1,269 @@\n+use std::iter::Step;\n+use std::marker::PhantomData;\n+use std::ops::Bound;\n+use std::ops::RangeBounds;\n+\n+use crate::vec::Idx;\n+use crate::vec::IndexVec;\n+use smallvec::SmallVec;\n+\n+#[cfg(test)]\n+mod tests;\n+\n+/// Stores a set of intervals on the indices.\n+#[derive(Debug, Clone)]\n+pub struct IntervalSet<I> {\n+    // Start, end\n+    map: SmallVec<[(u32, u32); 4]>,\n+    domain: usize,\n+    _data: PhantomData<I>,\n+}\n+\n+#[inline]\n+fn inclusive_start<T: Idx>(range: impl RangeBounds<T>) -> u32 {\n+    match range.start_bound() {\n+        Bound::Included(start) => start.index() as u32,\n+        Bound::Excluded(start) => start.index() as u32 + 1,\n+        Bound::Unbounded => 0,\n+    }\n+}\n+\n+#[inline]\n+fn inclusive_end<T: Idx>(domain: usize, range: impl RangeBounds<T>) -> Option<u32> {\n+    let end = match range.end_bound() {\n+        Bound::Included(end) => end.index() as u32,\n+        Bound::Excluded(end) => end.index().checked_sub(1)? as u32,\n+        Bound::Unbounded => domain.checked_sub(1)? as u32,\n+    };\n+    Some(end)\n+}\n+\n+impl<I: Idx> IntervalSet<I> {\n+    pub fn new(domain: usize) -> IntervalSet<I> {\n+        IntervalSet { map: SmallVec::new(), domain, _data: PhantomData }\n+    }\n+\n+    pub fn clear(&mut self) {\n+        self.map.clear();\n+    }\n+\n+    pub fn iter(&self) -> impl Iterator<Item = I> + '_\n+    where\n+        I: Step,\n+    {\n+        self.iter_intervals().flatten()\n+    }\n+\n+    /// Iterates through intervals stored in the set, in order.\n+    pub fn iter_intervals(&self) -> impl Iterator<Item = std::ops::Range<I>> + '_\n+    where\n+        I: Step,\n+    {\n+        self.map.iter().map(|&(start, end)| I::new(start as usize)..I::new(end as usize + 1))\n+    }\n+\n+    /// Returns true if we increased the number of elements present.\n+    pub fn insert(&mut self, point: I) -> bool {\n+        self.insert_range(point..=point)\n+    }\n+\n+    /// Returns true if we increased the number of elements present.\n+    pub fn insert_range(&mut self, range: impl RangeBounds<I> + Clone) -> bool {\n+        let start = inclusive_start(range.clone());\n+        let Some(mut end) = inclusive_end(self.domain, range) else {\n+            // empty range\n+            return false;\n+        };\n+        if start > end {\n+            return false;\n+        }\n+\n+        loop {\n+            // This condition looks a bit weird, but actually makes sense.\n+            //\n+            // if r.0 == end + 1, then we're actually adjacent, so we want to\n+            // continue to the next range. We're looking here for the first\n+            // range which starts *non-adjacently* to our end.\n+            let next = self.map.partition_point(|r| r.0 <= end + 1);\n+            if let Some(last) = next.checked_sub(1) {\n+                let (prev_start, prev_end) = &mut self.map[last];\n+                if *prev_end + 1 >= start {\n+                    // If the start for the inserted range is adjacent to the\n+                    // end of the previous, we can extend the previous range.\n+                    if start < *prev_start {\n+                        // Our range starts before the one we found. We'll need\n+                        // to *remove* it, and then try again.\n+                        //\n+                        // FIXME: This is not so efficient; we may need to\n+                        // recurse a bunch of times here. Instead, it's probably\n+                        // better to do something like drain_filter(...) on the\n+                        // map to be able to delete or modify all the ranges in\n+                        // start..=end and then potentially re-insert a new\n+                        // range.\n+                        end = std::cmp::max(end, *prev_end);\n+                        self.map.remove(last);\n+                    } else {\n+                        // We overlap with the previous range, increase it to\n+                        // include us.\n+                        //\n+                        // Make sure we're actually going to *increase* it though --\n+                        // it may be that end is just inside the previously existing\n+                        // set.\n+                        return if end > *prev_end {\n+                            *prev_end = end;\n+                            true\n+                        } else {\n+                            false\n+                        };\n+                    }\n+                } else {\n+                    // Otherwise, we don't overlap, so just insert\n+                    self.map.insert(last + 1, (start, end));\n+                    return true;\n+                }\n+            } else {\n+                if self.map.is_empty() {\n+                    // Quite common in practice, and expensive to call memcpy\n+                    // with length zero.\n+                    self.map.push((start, end));\n+                } else {\n+                    self.map.insert(next, (start, end));\n+                }\n+                return true;\n+            }\n+        }\n+    }\n+\n+    pub fn contains(&self, needle: I) -> bool {\n+        let needle = needle.index() as u32;\n+        let last = match self.map.partition_point(|r| r.0 <= needle).checked_sub(1) {\n+            Some(idx) => idx,\n+            None => {\n+                // All ranges in the map start after the new range's end\n+                return false;\n+            }\n+        };\n+        let (_, prev_end) = &self.map[last];\n+        needle <= *prev_end\n+    }\n+\n+    pub fn superset(&self, other: &IntervalSet<I>) -> bool\n+    where\n+        I: Step,\n+    {\n+        // FIXME: Performance here is probably not great. We will be doing a lot\n+        // of pointless tree traversals.\n+        other.iter().all(|elem| self.contains(elem))\n+    }\n+\n+    pub fn is_empty(&self) -> bool {\n+        self.map.is_empty()\n+    }\n+\n+    /// Returns the maximum (last) element present in the set from `range`.\n+    pub fn last_set_in(&self, range: impl RangeBounds<I> + Clone) -> Option<I> {\n+        let start = inclusive_start(range.clone());\n+        let Some(end) = inclusive_end(self.domain, range) else {\n+            // empty range\n+            return None;\n+        };\n+        if start > end {\n+            return None;\n+        }\n+        let last = match self.map.partition_point(|r| r.0 <= end).checked_sub(1) {\n+            Some(idx) => idx,\n+            None => {\n+                // All ranges in the map start after the new range's end\n+                return None;\n+            }\n+        };\n+        let (_, prev_end) = &self.map[last];\n+        if start <= *prev_end { Some(I::new(std::cmp::min(*prev_end, end) as usize)) } else { None }\n+    }\n+\n+    pub fn insert_all(&mut self) {\n+        self.clear();\n+        self.map.push((0, self.domain.try_into().unwrap()));\n+    }\n+\n+    pub fn union(&mut self, other: &IntervalSet<I>) -> bool\n+    where\n+        I: Step,\n+    {\n+        assert_eq!(self.domain, other.domain);\n+        let mut did_insert = false;\n+        for range in other.iter_intervals() {\n+            did_insert |= self.insert_range(range);\n+        }\n+        did_insert\n+    }\n+}\n+\n+/// This data structure optimizes for cases where the stored bits in each row\n+/// are expected to be highly contiguous (long ranges of 1s or 0s), in contrast\n+/// to BitMatrix and SparseBitMatrix which are optimized for\n+/// \"random\"/non-contiguous bits and cheap(er) point queries at the expense of\n+/// memory usage.\n+#[derive(Clone)]\n+pub struct SparseIntervalMatrix<R, C>\n+where\n+    R: Idx,\n+    C: Idx,\n+{\n+    rows: IndexVec<R, IntervalSet<C>>,\n+    column_size: usize,\n+}\n+\n+impl<R: Idx, C: Step + Idx> SparseIntervalMatrix<R, C> {\n+    pub fn new(column_size: usize) -> SparseIntervalMatrix<R, C> {\n+        SparseIntervalMatrix { rows: IndexVec::new(), column_size }\n+    }\n+\n+    pub fn rows(&self) -> impl Iterator<Item = R> {\n+        self.rows.indices()\n+    }\n+\n+    pub fn row(&self, row: R) -> Option<&IntervalSet<C>> {\n+        self.rows.get(row)\n+    }\n+\n+    fn ensure_row(&mut self, row: R) -> &mut IntervalSet<C> {\n+        self.rows.ensure_contains_elem(row, || IntervalSet::new(self.column_size));\n+        &mut self.rows[row]\n+    }\n+\n+    pub fn union_row(&mut self, row: R, from: &IntervalSet<C>) -> bool\n+    where\n+        C: Step,\n+    {\n+        self.ensure_row(row).union(from)\n+    }\n+\n+    pub fn union_rows(&mut self, read: R, write: R) -> bool\n+    where\n+        C: Step,\n+    {\n+        if read == write || self.rows.get(read).is_none() {\n+            return false;\n+        }\n+        self.ensure_row(write);\n+        let (read_row, write_row) = self.rows.pick2_mut(read, write);\n+        write_row.union(read_row)\n+    }\n+\n+    pub fn insert_all_into_row(&mut self, row: R) {\n+        self.ensure_row(row).insert_all();\n+    }\n+\n+    pub fn insert_range(&mut self, row: R, range: impl RangeBounds<C> + Clone) {\n+        self.ensure_row(row).insert_range(range);\n+    }\n+\n+    pub fn insert(&mut self, row: R, point: C) -> bool {\n+        self.ensure_row(row).insert(point)\n+    }\n+\n+    pub fn contains(&self, row: R, point: C) -> bool {\n+        self.row(row).map_or(false, |r| r.contains(point))\n+    }\n+}"}, {"sha": "d90b449f3260919915f83dfcff69526bbc58d722", "filename": "compiler/rustc_index/src/interval/tests.rs", "status": "added", "additions": 199, "deletions": 0, "changes": 199, "blob_url": "https://github.com/rust-lang/rust/blob/cfa3fe5af339e724209b25715282adae0c61628f/compiler%2Frustc_index%2Fsrc%2Finterval%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfa3fe5af339e724209b25715282adae0c61628f/compiler%2Frustc_index%2Fsrc%2Finterval%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_index%2Fsrc%2Finterval%2Ftests.rs?ref=cfa3fe5af339e724209b25715282adae0c61628f", "patch": "@@ -0,0 +1,199 @@\n+use super::*;\n+\n+#[test]\n+fn insert_collapses() {\n+    let mut set = IntervalSet::<u32>::new(3000);\n+    set.insert_range(9831..=9837);\n+    set.insert_range(43..=9830);\n+    assert_eq!(set.iter_intervals().collect::<Vec<_>>(), [43..9838]);\n+}\n+\n+#[test]\n+fn contains() {\n+    let mut set = IntervalSet::new(300);\n+    set.insert(0u32);\n+    assert!(set.contains(0));\n+    set.insert_range(0..10);\n+    assert!(set.contains(9));\n+    assert!(!set.contains(10));\n+    set.insert_range(10..11);\n+    assert!(set.contains(10));\n+}\n+\n+#[test]\n+fn insert() {\n+    for i in 0..30usize {\n+        let mut set = IntervalSet::new(300);\n+        for j in i..30usize {\n+            set.insert(j);\n+            for k in i..j {\n+                assert!(set.contains(k));\n+            }\n+        }\n+    }\n+\n+    let mut set = IntervalSet::new(300);\n+    set.insert_range(0..1u32);\n+    assert!(set.contains(0), \"{:?}\", set.map);\n+    assert!(!set.contains(1));\n+    set.insert_range(1..1);\n+    assert!(set.contains(0));\n+    assert!(!set.contains(1));\n+\n+    let mut set = IntervalSet::new(300);\n+    set.insert_range(4..5u32);\n+    set.insert_range(5..10);\n+    assert_eq!(set.iter().collect::<Vec<_>>(), [4, 5, 6, 7, 8, 9]);\n+    set.insert_range(3..7);\n+    assert_eq!(set.iter().collect::<Vec<_>>(), [3, 4, 5, 6, 7, 8, 9]);\n+\n+    let mut set = IntervalSet::new(300);\n+    set.insert_range(0..10u32);\n+    set.insert_range(3..5);\n+    assert_eq!(set.iter().collect::<Vec<_>>(), [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]);\n+\n+    let mut set = IntervalSet::new(300);\n+    set.insert_range(0..10u32);\n+    set.insert_range(0..3);\n+    assert_eq!(set.iter().collect::<Vec<_>>(), [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]);\n+\n+    let mut set = IntervalSet::new(300);\n+    set.insert_range(0..10u32);\n+    set.insert_range(0..10);\n+    assert_eq!(set.iter().collect::<Vec<_>>(), [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]);\n+\n+    let mut set = IntervalSet::new(300);\n+    set.insert_range(0..10u32);\n+    set.insert_range(5..10);\n+    assert_eq!(set.iter().collect::<Vec<_>>(), [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]);\n+\n+    let mut set = IntervalSet::new(300);\n+    set.insert_range(0..10u32);\n+    set.insert_range(5..13);\n+    assert_eq!(set.iter().collect::<Vec<_>>(), [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]);\n+}\n+\n+#[test]\n+fn insert_range() {\n+    #[track_caller]\n+    fn check<R>(range: R)\n+    where\n+        R: RangeBounds<usize> + Clone + IntoIterator<Item = usize> + std::fmt::Debug,\n+    {\n+        let mut set = IntervalSet::new(300);\n+        set.insert_range(range.clone());\n+        for i in set.iter() {\n+            assert!(range.contains(&i));\n+        }\n+        for i in range.clone() {\n+            assert!(set.contains(i), \"A: {} in {:?}, inserted {:?}\", i, set, range);\n+        }\n+        set.insert_range(range.clone());\n+        for i in set.iter() {\n+            assert!(range.contains(&i), \"{} in {:?}\", i, set);\n+        }\n+        for i in range.clone() {\n+            assert!(set.contains(i), \"B: {} in {:?}, inserted {:?}\", i, set, range);\n+        }\n+    }\n+    check(10..10);\n+    check(10..100);\n+    check(10..30);\n+    check(0..5);\n+    check(0..250);\n+    check(200..250);\n+\n+    check(10..=10);\n+    check(10..=100);\n+    check(10..=30);\n+    check(0..=5);\n+    check(0..=250);\n+    check(200..=250);\n+\n+    for i in 0..30 {\n+        for j in i..30 {\n+            check(i..j);\n+            check(i..=j);\n+        }\n+    }\n+}\n+\n+#[test]\n+fn insert_range_dual() {\n+    let mut set = IntervalSet::<u32>::new(300);\n+    set.insert_range(0..3);\n+    assert_eq!(set.iter().collect::<Vec<_>>(), [0, 1, 2]);\n+    set.insert_range(5..7);\n+    assert_eq!(set.iter().collect::<Vec<_>>(), [0, 1, 2, 5, 6]);\n+    set.insert_range(3..4);\n+    assert_eq!(set.iter().collect::<Vec<_>>(), [0, 1, 2, 3, 5, 6]);\n+    set.insert_range(3..5);\n+    assert_eq!(set.iter().collect::<Vec<_>>(), [0, 1, 2, 3, 4, 5, 6]);\n+}\n+\n+#[test]\n+fn last_set_before_adjacent() {\n+    let mut set = IntervalSet::<u32>::new(300);\n+    set.insert_range(0..3);\n+    set.insert_range(3..5);\n+    assert_eq!(set.last_set_in(0..3), Some(2));\n+    assert_eq!(set.last_set_in(0..5), Some(4));\n+    assert_eq!(set.last_set_in(3..5), Some(4));\n+    set.insert_range(2..5);\n+    assert_eq!(set.last_set_in(0..3), Some(2));\n+    assert_eq!(set.last_set_in(0..5), Some(4));\n+    assert_eq!(set.last_set_in(3..5), Some(4));\n+}\n+\n+#[test]\n+fn last_set_in() {\n+    fn easy(set: &IntervalSet<usize>, needle: impl RangeBounds<usize>) -> Option<usize> {\n+        let mut last_leq = None;\n+        for e in set.iter() {\n+            if needle.contains(&e) {\n+                last_leq = Some(e);\n+            }\n+        }\n+        last_leq\n+    }\n+\n+    #[track_caller]\n+    fn cmp(set: &IntervalSet<usize>, needle: impl RangeBounds<usize> + Clone + std::fmt::Debug) {\n+        assert_eq!(\n+            set.last_set_in(needle.clone()),\n+            easy(set, needle.clone()),\n+            \"{:?} in {:?}\",\n+            needle,\n+            set\n+        );\n+    }\n+    let mut set = IntervalSet::new(300);\n+    cmp(&set, 50..=50);\n+    set.insert(64);\n+    cmp(&set, 64..=64);\n+    set.insert(64 - 1);\n+    cmp(&set, 0..=64 - 1);\n+    cmp(&set, 0..=5);\n+    cmp(&set, 10..100);\n+    set.insert(100);\n+    cmp(&set, 100..110);\n+    cmp(&set, 99..100);\n+    cmp(&set, 99..=100);\n+\n+    for i in 0..=30 {\n+        for j in i..=30 {\n+            for k in 0..30 {\n+                let mut set = IntervalSet::new(100);\n+                cmp(&set, ..j);\n+                cmp(&set, i..);\n+                cmp(&set, i..j);\n+                cmp(&set, i..=j);\n+                set.insert(k);\n+                cmp(&set, ..j);\n+                cmp(&set, i..);\n+                cmp(&set, i..j);\n+                cmp(&set, i..=j);\n+            }\n+        }\n+    }\n+}"}, {"sha": "359b1859c6889052f02776ee85509347d32beade", "filename": "compiler/rustc_index/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cfa3fe5af339e724209b25715282adae0c61628f/compiler%2Frustc_index%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfa3fe5af339e724209b25715282adae0c61628f/compiler%2Frustc_index%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_index%2Fsrc%2Flib.rs?ref=cfa3fe5af339e724209b25715282adae0c61628f", "patch": "@@ -7,6 +7,7 @@\n #![feature(let_else)]\n \n pub mod bit_set;\n+pub mod interval;\n pub mod vec;\n \n // FIXME(#56935): Work around ICEs during cross-compilation."}]}