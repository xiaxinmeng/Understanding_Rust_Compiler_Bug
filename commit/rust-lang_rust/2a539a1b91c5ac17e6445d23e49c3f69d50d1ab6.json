{"sha": "2a539a1b91c5ac17e6445d23e49c3f69d50d1ab6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJhNTM5YTFiOTFjNWFjMTdlNjQ0NWQyM2U0OWMzZjY5ZDUwZDFhYjY=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-02-14T07:24:15Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-02-14T07:24:15Z"}, "message": "Rollup merge of #58378 - alexcrichton:incremental-lto, r=michaelwoerister\n\nrustc: Implement incremental \"fat\" LTO\n\nCurrently the compiler will produce an error if both incremental\ncompilation and full fat LTO is requested. With recent changes and the\nadvent of incremental ThinLTO, however, all the hard work is already\ndone for us and it's actually not too bad to remove this error!\n\nThis commit updates the codegen backend to allow incremental full fat\nLTO. The semantics are that the input modules to LTO are all produce\nincrementally, but the final LTO step is always done unconditionally\nregardless of whether the inputs changed or not. The only real\nincremental win we could have here is if zero of the input modules\nchanged, but that's so rare it's unlikely to be worthwhile to implement\nsuch a code path.\n\ncc #57968\ncc rust-lang/cargo#6643", "tree": {"sha": "190f31969952487440ba3fdc4f9e54e03b6137e2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/190f31969952487440ba3fdc4f9e54e03b6137e2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2a539a1b91c5ac17e6445d23e49c3f69d50d1ab6", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJcZRefCRBK7hj4Ov3rIwAAdHIIAAmsCl2gKwO/zhQk4XiCbkwj\nGBAAWU6BiFhQ923siQ52GgHlUEVWmh3yTSJ2mDsrLwYDiT7dIszBsXkLh18SJ3oU\nBNqL9g0CJT7+heyB/ey8y6lHi1bw86RDxjHP5nPpJJUAo8QK5WhBGRsUbIX+KJ53\ndPVkYI3CY2BYMk5NuDDhWlU8FwLWHV3gV1PYfBNLIe3c21+keWPHsUfcItaAZPxN\nyJs5YHAXBYEVDuALxShzhxehHPoKvf/OpfkLylz8ZNAn2kkV35FyQqqHdWYrDKVt\nI6+9jzzevcb29IiqcG+QX8fv9rL8OzbgGQc/1a5dnfFh/Umyhx4MwGDsB2HNv0g=\n=DM3l\n-----END PGP SIGNATURE-----\n", "payload": "tree 190f31969952487440ba3fdc4f9e54e03b6137e2\nparent 0dbb867beb187119bd0bca1f05de6b00cd72f141\nparent e983b4f64ee6d919a60938b6e7371a66877f4a23\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1550129055 +0100\ncommitter GitHub <noreply@github.com> 1550129055 +0100\n\nRollup merge of #58378 - alexcrichton:incremental-lto, r=michaelwoerister\n\nrustc: Implement incremental \"fat\" LTO\n\nCurrently the compiler will produce an error if both incremental\ncompilation and full fat LTO is requested. With recent changes and the\nadvent of incremental ThinLTO, however, all the hard work is already\ndone for us and it's actually not too bad to remove this error!\n\nThis commit updates the codegen backend to allow incremental full fat\nLTO. The semantics are that the input modules to LTO are all produce\nincrementally, but the final LTO step is always done unconditionally\nregardless of whether the inputs changed or not. The only real\nincremental win we could have here is if zero of the input modules\nchanged, but that's so rare it's unlikely to be worthwhile to implement\nsuch a code path.\n\ncc #57968\ncc rust-lang/cargo#6643\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2a539a1b91c5ac17e6445d23e49c3f69d50d1ab6", "html_url": "https://github.com/rust-lang/rust/commit/2a539a1b91c5ac17e6445d23e49c3f69d50d1ab6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2a539a1b91c5ac17e6445d23e49c3f69d50d1ab6/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0dbb867beb187119bd0bca1f05de6b00cd72f141", "url": "https://api.github.com/repos/rust-lang/rust/commits/0dbb867beb187119bd0bca1f05de6b00cd72f141", "html_url": "https://github.com/rust-lang/rust/commit/0dbb867beb187119bd0bca1f05de6b00cd72f141"}, {"sha": "e983b4f64ee6d919a60938b6e7371a66877f4a23", "url": "https://api.github.com/repos/rust-lang/rust/commits/e983b4f64ee6d919a60938b6e7371a66877f4a23", "html_url": "https://github.com/rust-lang/rust/commit/e983b4f64ee6d919a60938b6e7371a66877f4a23"}], "stats": {"total": 329, "additions": 246, "deletions": 83}, "files": [{"sha": "833785f04076cb8c142ef4eedc28bbef7d32531a", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 1, "deletions": 15, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/2a539a1b91c5ac17e6445d23e49c3f69d50d1ab6/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a539a1b91c5ac17e6445d23e49c3f69d50d1ab6/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=2a539a1b91c5ac17e6445d23e49c3f69d50d1ab6", "patch": "@@ -9,7 +9,7 @@ use crate::lint;\n use crate::lint::builtin::BuiltinLintDiagnostics;\n use crate::middle::allocator::AllocatorKind;\n use crate::middle::dependency_format;\n-use crate::session::config::{OutputType, Lto};\n+use crate::session::config::OutputType;\n use crate::session::search_paths::{PathKind, SearchPath};\n use crate::util::nodemap::{FxHashMap, FxHashSet};\n use crate::util::common::{duration_to_secs_str, ErrorReported};\n@@ -1246,20 +1246,6 @@ pub fn build_session_(\n // If it is useful to have a Session available already for validating a\n // commandline argument, you can do so here.\n fn validate_commandline_args_with_session_available(sess: &Session) {\n-\n-    if sess.opts.incremental.is_some() {\n-        match sess.lto() {\n-            Lto::Thin |\n-            Lto::Fat => {\n-                sess.err(\"can't perform LTO when compiling incrementally\");\n-            }\n-            Lto::ThinLocal |\n-            Lto::No => {\n-                // This is fine\n-            }\n-        }\n-    }\n-\n     // Since we don't know if code in an rlib will be linked to statically or\n     // dynamically downstream, rustc generates `__imp_` symbols that help the\n     // MSVC linker deal with this lack of knowledge (#27438). Unfortunately,"}, {"sha": "fc3ab7f734a794b04d85b25e1804b6172b043597", "filename": "src/librustc_codegen_llvm/back/lto.rs", "status": "modified", "additions": 101, "deletions": 38, "changes": 139, "blob_url": "https://github.com/rust-lang/rust/blob/2a539a1b91c5ac17e6445d23e49c3f69d50d1ab6/src%2Flibrustc_codegen_llvm%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a539a1b91c5ac17e6445d23e49c3f69d50d1ab6/src%2Flibrustc_codegen_llvm%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Flto.rs?ref=2a539a1b91c5ac17e6445d23e49c3f69d50d1ab6", "patch": "@@ -1,6 +1,6 @@\n use back::bytecode::{DecodedBytecode, RLIB_BYTECODE_EXTENSION};\n use rustc_codegen_ssa::back::symbol_export;\n-use rustc_codegen_ssa::back::write::{ModuleConfig, CodegenContext, pre_lto_bitcode_filename};\n+use rustc_codegen_ssa::back::write::{ModuleConfig, CodegenContext, FatLTOInput};\n use rustc_codegen_ssa::back::lto::{SerializedModule, LtoModuleCodegen, ThinShared, ThinModule};\n use rustc_codegen_ssa::traits::*;\n use back::write::{self, DiagnosticHandlers, with_llvm_pmb, save_temp_bitcode, to_llvm_opt_settings};\n@@ -21,7 +21,6 @@ use rustc_codegen_ssa::{ModuleCodegen, ModuleKind};\n use libc;\n \n use std::ffi::{CStr, CString};\n-use std::fs;\n use std::ptr;\n use std::slice;\n use std::sync::Arc;\n@@ -133,7 +132,8 @@ fn prepare_lto(cgcx: &CodegenContext<LlvmCodegenBackend>,\n /// Performs fat LTO by merging all modules into a single one and returning it\n /// for further optimization.\n pub(crate) fn run_fat(cgcx: &CodegenContext<LlvmCodegenBackend>,\n-                      modules: Vec<ModuleCodegen<ModuleLlvm>>,\n+                      modules: Vec<FatLTOInput<LlvmCodegenBackend>>,\n+                      cached_modules: Vec<(SerializedModule<ModuleBuffer>, WorkProduct)>,\n                       timeline: &mut Timeline)\n     -> Result<LtoModuleCodegen<LlvmCodegenBackend>, FatalError>\n {\n@@ -142,7 +142,15 @@ pub(crate) fn run_fat(cgcx: &CodegenContext<LlvmCodegenBackend>,\n     let symbol_white_list = symbol_white_list.iter()\n                                              .map(|c| c.as_ptr())\n                                              .collect::<Vec<_>>();\n-    fat_lto(cgcx, &diag_handler, modules, upstream_modules, &symbol_white_list, timeline)\n+    fat_lto(\n+        cgcx,\n+        &diag_handler,\n+        modules,\n+        cached_modules,\n+        upstream_modules,\n+        &symbol_white_list,\n+        timeline,\n+    )\n }\n \n /// Performs thin LTO by performing necessary global analysis and returning two\n@@ -173,33 +181,17 @@ pub(crate) fn run_thin(cgcx: &CodegenContext<LlvmCodegenBackend>,\n }\n \n pub(crate) fn prepare_thin(\n-    cgcx: &CodegenContext<LlvmCodegenBackend>,\n     module: ModuleCodegen<ModuleLlvm>\n ) -> (String, ThinBuffer) {\n     let name = module.name.clone();\n     let buffer = ThinBuffer::new(module.module_llvm.llmod());\n-\n-    // We emit the module after having serialized it into a ThinBuffer\n-    // because only then it will contain the ThinLTO module summary.\n-    if let Some(ref incr_comp_session_dir) = cgcx.incr_comp_session_dir {\n-        if cgcx.config(module.kind).emit_pre_thin_lto_bc {\n-            let path = incr_comp_session_dir\n-                .join(pre_lto_bitcode_filename(&name));\n-\n-            fs::write(&path, buffer.data()).unwrap_or_else(|e| {\n-                panic!(\"Error writing pre-lto-bitcode file `{}`: {}\",\n-                       path.display(),\n-                       e);\n-            });\n-        }\n-    }\n-\n     (name, buffer)\n }\n \n fn fat_lto(cgcx: &CodegenContext<LlvmCodegenBackend>,\n            diag_handler: &Handler,\n-           mut modules: Vec<ModuleCodegen<ModuleLlvm>>,\n+           mut modules: Vec<FatLTOInput<LlvmCodegenBackend>>,\n+           cached_modules: Vec<(SerializedModule<ModuleBuffer>, WorkProduct)>,\n            mut serialized_modules: Vec<(SerializedModule<ModuleBuffer>, CString)>,\n            symbol_white_list: &[*const libc::c_char],\n            timeline: &mut Timeline)\n@@ -216,18 +208,53 @@ fn fat_lto(cgcx: &CodegenContext<LlvmCodegenBackend>,\n     // file copy operations in the backend work correctly. The only other kind\n     // of module here should be an allocator one, and if your crate is smaller\n     // than the allocator module then the size doesn't really matter anyway.\n-    let (_, costliest_module) = modules.iter()\n+    let costliest_module = modules.iter()\n         .enumerate()\n+        .filter_map(|(i, module)| {\n+            match module {\n+                FatLTOInput::InMemory(m) => Some((i, m)),\n+                FatLTOInput::Serialized { .. } => None,\n+            }\n+        })\n         .filter(|&(_, module)| module.kind == ModuleKind::Regular)\n         .map(|(i, module)| {\n             let cost = unsafe {\n                 llvm::LLVMRustModuleCost(module.module_llvm.llmod())\n             };\n             (cost, i)\n         })\n-        .max()\n-        .expect(\"must be codegen'ing at least one module\");\n-    let module = modules.remove(costliest_module);\n+        .max();\n+\n+    // If we found a costliest module, we're good to go. Otherwise all our\n+    // inputs were serialized which could happen in the case, for example, that\n+    // all our inputs were incrementally reread from the cache and we're just\n+    // re-executing the LTO passes. If that's the case deserialize the first\n+    // module and create a linker with it.\n+    let module: ModuleCodegen<ModuleLlvm> = match costliest_module {\n+        Some((_cost, i)) => {\n+            match modules.remove(i) {\n+                FatLTOInput::InMemory(m) => m,\n+                FatLTOInput::Serialized { .. } => unreachable!(),\n+            }\n+        }\n+        None => {\n+            let pos = modules.iter().position(|m| {\n+                match m {\n+                    FatLTOInput::InMemory(_) => false,\n+                    FatLTOInput::Serialized { .. } => true,\n+                }\n+            }).expect(\"must have at least one serialized module\");\n+            let (name, buffer) = match modules.remove(pos) {\n+                FatLTOInput::Serialized { name, buffer } => (name, buffer),\n+                FatLTOInput::InMemory(_) => unreachable!(),\n+            };\n+            ModuleCodegen {\n+                module_llvm: ModuleLlvm::parse(cgcx, &name, &buffer, diag_handler)?,\n+                name,\n+                kind: ModuleKind::Regular,\n+            }\n+        }\n+    };\n     let mut serialized_bitcode = Vec::new();\n     {\n         let (llcx, llmod) = {\n@@ -247,10 +274,20 @@ fn fat_lto(cgcx: &CodegenContext<LlvmCodegenBackend>,\n         // way we know of to do that is to serialize them to a string and them parse\n         // them later. Not great but hey, that's why it's \"fat\" LTO, right?\n         serialized_modules.extend(modules.into_iter().map(|module| {\n-            let buffer = ModuleBuffer::new(module.module_llvm.llmod());\n-            let llmod_id = CString::new(&module.name[..]).unwrap();\n-\n-            (SerializedModule::Local(buffer), llmod_id)\n+            match module {\n+                FatLTOInput::InMemory(module) => {\n+                    let buffer = ModuleBuffer::new(module.module_llvm.llmod());\n+                    let llmod_id = CString::new(&module.name[..]).unwrap();\n+                    (SerializedModule::Local(buffer), llmod_id)\n+                }\n+                FatLTOInput::Serialized { name, buffer } => {\n+                    let llmod_id = CString::new(name).unwrap();\n+                    (SerializedModule::Local(buffer), llmod_id)\n+                }\n+            }\n+        }));\n+        serialized_modules.extend(cached_modules.into_iter().map(|(buffer, wp)| {\n+            (buffer, CString::new(wp.cgu_name.clone()).unwrap())\n         }));\n \n         // For all serialized bitcode files we parse them and link them in as we did\n@@ -579,6 +616,16 @@ impl ModuleBuffer {\n             llvm::LLVMRustModuleBufferCreate(m)\n         })\n     }\n+\n+    pub fn parse<'a>(\n+        &self,\n+        name: &str,\n+        cx: &'a llvm::Context,\n+        handler: &Handler,\n+    ) -> Result<&'a llvm::Module, FatalError> {\n+        let name = CString::new(name).unwrap();\n+        parse_module(cx, &name, self.data(), handler)\n+    }\n }\n \n impl ModuleBufferMethods for ModuleBuffer {\n@@ -658,15 +705,12 @@ pub unsafe fn optimize_thin_module(\n     // crates but for locally codegened modules we may be able to reuse\n     // that LLVM Context and Module.\n     let llcx = llvm::LLVMRustContextCreate(cgcx.fewer_names);\n-    let llmod_raw = llvm::LLVMRustParseBitcodeForThinLTO(\n+    let llmod_raw = parse_module(\n         llcx,\n-        thin_module.data().as_ptr(),\n-        thin_module.data().len(),\n-        thin_module.shared.module_names[thin_module.idx].as_ptr(),\n-    ).ok_or_else(|| {\n-        let msg = \"failed to parse bitcode for thin LTO module\";\n-        write::llvm_err(&diag_handler, msg)\n-    })? as *const _;\n+        &thin_module.shared.module_names[thin_module.idx],\n+        thin_module.data(),\n+        &diag_handler,\n+    )? as *const _;\n     let module = ModuleCodegen {\n         module_llvm: ModuleLlvm {\n             llmod_raw,\n@@ -823,3 +867,22 @@ fn module_name_to_str(c_str: &CStr) -> &str {\n     c_str.to_str().unwrap_or_else(|e|\n         bug!(\"Encountered non-utf8 LLVM module name `{}`: {}\", c_str.to_string_lossy(), e))\n }\n+\n+fn parse_module<'a>(\n+    cx: &'a llvm::Context,\n+    name: &CStr,\n+    data: &[u8],\n+    diag_handler: &Handler,\n+) -> Result<&'a llvm::Module, FatalError> {\n+    unsafe {\n+        llvm::LLVMRustParseBitcodeForLTO(\n+            cx,\n+            data.as_ptr(),\n+            data.len(),\n+            name.as_ptr(),\n+        ).ok_or_else(|| {\n+            let msg = \"failed to parse bitcode for LTO module\";\n+            write::llvm_err(&diag_handler, msg)\n+        })\n+    }\n+}"}, {"sha": "b605badc153f0e27acb016aee6ac0b72f88e678b", "filename": "src/librustc_codegen_llvm/lib.rs", "status": "modified", "additions": 35, "deletions": 5, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/2a539a1b91c5ac17e6445d23e49c3f69d50d1ab6/src%2Flibrustc_codegen_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a539a1b91c5ac17e6445d23e49c3f69d50d1ab6/src%2Flibrustc_codegen_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Flib.rs?ref=2a539a1b91c5ac17e6445d23e49c3f69d50d1ab6", "patch": "@@ -54,7 +54,7 @@ extern crate tempfile;\n extern crate memmap;\n \n use rustc_codegen_ssa::traits::*;\n-use rustc_codegen_ssa::back::write::{CodegenContext, ModuleConfig};\n+use rustc_codegen_ssa::back::write::{CodegenContext, ModuleConfig, FatLTOInput};\n use rustc_codegen_ssa::back::lto::{SerializedModule, LtoModuleCodegen, ThinModule};\n use rustc_codegen_ssa::CompiledModule;\n use errors::{FatalError, Handler};\n@@ -165,10 +165,11 @@ impl WriteBackendMethods for LlvmCodegenBackend {\n     }\n     fn run_fat_lto(\n         cgcx: &CodegenContext<Self>,\n-        modules: Vec<ModuleCodegen<Self::Module>>,\n+        modules: Vec<FatLTOInput<Self>>,\n+        cached_modules: Vec<(SerializedModule<Self::ModuleBuffer>, WorkProduct)>,\n         timeline: &mut Timeline\n     ) -> Result<LtoModuleCodegen<Self>, FatalError> {\n-        back::lto::run_fat(cgcx, modules, timeline)\n+        back::lto::run_fat(cgcx, modules, cached_modules, timeline)\n     }\n     fn run_thin_lto(\n         cgcx: &CodegenContext<Self>,\n@@ -204,10 +205,14 @@ impl WriteBackendMethods for LlvmCodegenBackend {\n         back::write::codegen(cgcx, diag_handler, module, config, timeline)\n     }\n     fn prepare_thin(\n-        cgcx: &CodegenContext<Self>,\n         module: ModuleCodegen<Self::Module>\n     ) -> (String, Self::ThinBuffer) {\n-        back::lto::prepare_thin(cgcx, module)\n+        back::lto::prepare_thin(module)\n+    }\n+    fn serialize_module(\n+        module: ModuleCodegen<Self::Module>\n+    ) -> (String, Self::ModuleBuffer) {\n+        (module.name, back::lto::ModuleBuffer::new(module.module_llvm.llmod()))\n     }\n     fn run_lto_pass_manager(\n         cgcx: &CodegenContext<Self>,\n@@ -375,6 +380,31 @@ impl ModuleLlvm {\n         }\n     }\n \n+    fn parse(\n+        cgcx: &CodegenContext<LlvmCodegenBackend>,\n+        name: &str,\n+        buffer: &back::lto::ModuleBuffer,\n+        handler: &Handler,\n+    ) -> Result<Self, FatalError> {\n+        unsafe {\n+            let llcx = llvm::LLVMRustContextCreate(cgcx.fewer_names);\n+            let llmod_raw = buffer.parse(name, llcx, handler)?;\n+            let tm = match (cgcx.tm_factory.0)() {\n+                Ok(m) => m,\n+                Err(e) => {\n+                    handler.struct_err(&e).emit();\n+                    return Err(FatalError)\n+                }\n+            };\n+\n+            Ok(ModuleLlvm {\n+                llmod_raw,\n+                llcx,\n+                tm,\n+            })\n+        }\n+    }\n+\n     fn llmod(&self) -> &llvm::Module {\n         unsafe {\n             &*self.llmod_raw"}, {"sha": "52292f67b331dbe932f3fd1c93224714a35d829b", "filename": "src/librustc_codegen_llvm/llvm/ffi.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2a539a1b91c5ac17e6445d23e49c3f69d50d1ab6/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a539a1b91c5ac17e6445d23e49c3f69d50d1ab6/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs?ref=2a539a1b91c5ac17e6445d23e49c3f69d50d1ab6", "patch": "@@ -1804,7 +1804,7 @@ extern \"C\" {\n         CallbackPayload: *mut c_void,\n     );\n     pub fn LLVMRustFreeThinLTOData(Data: &'static mut ThinLTOData);\n-    pub fn LLVMRustParseBitcodeForThinLTO(\n+    pub fn LLVMRustParseBitcodeForLTO(\n         Context: &Context,\n         Data: *const u8,\n         len: usize,"}, {"sha": "20842553c266643de747763aa1da4d8fab528a79", "filename": "src/librustc_codegen_ssa/back/write.rs", "status": "modified", "additions": 58, "deletions": 17, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/2a539a1b91c5ac17e6445d23e49c3f69d50d1ab6/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a539a1b91c5ac17e6445d23e49c3f69d50d1ab6/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs?ref=2a539a1b91c5ac17e6445d23e49c3f69d50d1ab6", "patch": "@@ -41,7 +41,7 @@ use std::sync::mpsc::{channel, Sender, Receiver};\n use std::time::Instant;\n use std::thread;\n \n-const PRE_THIN_LTO_BC_EXT: &str = \"pre-thin-lto.bc\";\n+const PRE_LTO_BC_EXT: &str = \"pre-lto.bc\";\n \n /// Module-specific configuration for `optimize_and_codegen`.\n pub struct ModuleConfig {\n@@ -58,7 +58,7 @@ pub struct ModuleConfig {\n     pub pgo_use: String,\n \n     // Flags indicating which outputs to produce.\n-    pub emit_pre_thin_lto_bc: bool,\n+    pub emit_pre_lto_bc: bool,\n     pub emit_no_opt_bc: bool,\n     pub emit_bc: bool,\n     pub emit_bc_compressed: bool,\n@@ -96,7 +96,7 @@ impl ModuleConfig {\n             pgo_use: String::new(),\n \n             emit_no_opt_bc: false,\n-            emit_pre_thin_lto_bc: false,\n+            emit_pre_lto_bc: false,\n             emit_bc: false,\n             emit_bc_compressed: false,\n             emit_lto_bc: false,\n@@ -258,7 +258,7 @@ impl<B: WriteBackendMethods> CodegenContext<B> {\n \n fn generate_lto_work<B: ExtraBackendMethods>(\n     cgcx: &CodegenContext<B>,\n-    needs_fat_lto: Vec<ModuleCodegen<B::Module>>,\n+    needs_fat_lto: Vec<FatLTOInput<B>>,\n     needs_thin_lto: Vec<(String, B::ThinBuffer)>,\n     import_only_modules: Vec<(SerializedModule<B::ModuleBuffer>, WorkProduct)>\n ) -> Vec<(WorkItem<B>, u64)> {\n@@ -270,9 +270,13 @@ fn generate_lto_work<B: ExtraBackendMethods>(\n \n     let (lto_modules, copy_jobs) = if !needs_fat_lto.is_empty() {\n         assert!(needs_thin_lto.is_empty());\n-        assert!(import_only_modules.is_empty());\n-        let lto_module = B::run_fat_lto(cgcx, needs_fat_lto, &mut timeline)\n-            .unwrap_or_else(|e| e.raise());\n+        let lto_module = B::run_fat_lto(\n+            cgcx,\n+            needs_fat_lto,\n+            import_only_modules,\n+            &mut timeline,\n+        )\n+        .unwrap_or_else(|e| e.raise());\n         (vec![lto_module], vec![])\n     } else {\n         assert!(needs_fat_lto.is_empty());\n@@ -302,14 +306,14 @@ fn need_crate_bitcode_for_rlib(sess: &Session) -> bool {\n     sess.opts.output_types.contains_key(&OutputType::Exe)\n }\n \n-fn need_pre_thin_lto_bitcode_for_incr_comp(sess: &Session) -> bool {\n+fn need_pre_lto_bitcode_for_incr_comp(sess: &Session) -> bool {\n     if sess.opts.incremental.is_none() {\n         return false\n     }\n \n     match sess.lto() {\n-        Lto::Fat |\n         Lto::No => false,\n+        Lto::Fat |\n         Lto::Thin |\n         Lto::ThinLocal => true,\n     }\n@@ -375,7 +379,7 @@ pub fn start_async_codegen<B: ExtraBackendMethods>(\n     // Save all versions of the bytecode if we're saving our temporaries.\n     if sess.opts.cg.save_temps {\n         modules_config.emit_no_opt_bc = true;\n-        modules_config.emit_pre_thin_lto_bc = true;\n+        modules_config.emit_pre_lto_bc = true;\n         modules_config.emit_bc = true;\n         modules_config.emit_lto_bc = true;\n         metadata_config.emit_bc = true;\n@@ -390,8 +394,8 @@ pub fn start_async_codegen<B: ExtraBackendMethods>(\n         allocator_config.emit_bc_compressed = true;\n     }\n \n-    modules_config.emit_pre_thin_lto_bc =\n-        need_pre_thin_lto_bitcode_for_incr_comp(sess);\n+    modules_config.emit_pre_lto_bc =\n+        need_pre_lto_bitcode_for_incr_comp(sess);\n \n     modules_config.no_integrated_as = tcx.sess.opts.cg.no_integrated_as ||\n         tcx.sess.target.target.options.no_integrated_as;\n@@ -686,10 +690,18 @@ impl<B: WriteBackendMethods> WorkItem<B> {\n \n enum WorkItemResult<B: WriteBackendMethods> {\n     Compiled(CompiledModule),\n-    NeedsFatLTO(ModuleCodegen<B::Module>),\n+    NeedsFatLTO(FatLTOInput<B>),\n     NeedsThinLTO(String, B::ThinBuffer),\n }\n \n+pub enum FatLTOInput<B: WriteBackendMethods> {\n+    Serialized {\n+        name: String,\n+        buffer: B::ModuleBuffer,\n+    },\n+    InMemory(ModuleCodegen<B::Module>),\n+}\n+\n fn execute_work_item<B: ExtraBackendMethods>(\n     cgcx: &CodegenContext<B>,\n     work_item: WorkItem<B>,\n@@ -771,6 +783,15 @@ fn execute_optimize_work_item<B: ExtraBackendMethods>(\n         }\n     };\n \n+    // If we're doing some form of incremental LTO then we need to be sure to\n+    // save our module to disk first.\n+    let bitcode = if cgcx.config(module.kind).emit_pre_lto_bc {\n+        let filename = pre_lto_bitcode_filename(&module.name);\n+        cgcx.incr_comp_session_dir.as_ref().map(|path| path.join(&filename))\n+    } else {\n+        None\n+    };\n+\n     Ok(match lto_type {\n         ComputedLtoType::No => {\n             let module = unsafe {\n@@ -779,10 +800,30 @@ fn execute_optimize_work_item<B: ExtraBackendMethods>(\n             WorkItemResult::Compiled(module)\n         }\n         ComputedLtoType::Thin => {\n-            let (name, thin_buffer) = B::prepare_thin(cgcx, module);\n+            let (name, thin_buffer) = B::prepare_thin(module);\n+            if let Some(path) = bitcode {\n+                fs::write(&path, thin_buffer.data()).unwrap_or_else(|e| {\n+                    panic!(\"Error writing pre-lto-bitcode file `{}`: {}\",\n+                           path.display(),\n+                           e);\n+                });\n+            }\n             WorkItemResult::NeedsThinLTO(name, thin_buffer)\n         }\n-        ComputedLtoType::Fat => WorkItemResult::NeedsFatLTO(module),\n+        ComputedLtoType::Fat => {\n+            match bitcode {\n+                Some(path) => {\n+                    let (name, buffer) = B::serialize_module(module);\n+                    fs::write(&path, buffer.data()).unwrap_or_else(|e| {\n+                        panic!(\"Error writing pre-lto-bitcode file `{}`: {}\",\n+                               path.display(),\n+                               e);\n+                    });\n+                    WorkItemResult::NeedsFatLTO(FatLTOInput::Serialized { name, buffer })\n+                }\n+                None => WorkItemResult::NeedsFatLTO(FatLTOInput::InMemory(module)),\n+            }\n+        }\n     })\n }\n \n@@ -866,7 +907,7 @@ fn execute_lto_work_item<B: ExtraBackendMethods>(\n pub enum Message<B: WriteBackendMethods> {\n     Token(io::Result<Acquired>),\n     NeedsFatLTO {\n-        result: ModuleCodegen<B::Module>,\n+        result: FatLTOInput<B>,\n         worker_id: usize,\n     },\n     NeedsThinLTO {\n@@ -1877,7 +1918,7 @@ pub fn submit_pre_lto_module_to_llvm<B: ExtraBackendMethods>(\n }\n \n pub fn pre_lto_bitcode_filename(module_name: &str) -> String {\n-    format!(\"{}.{}\", module_name, PRE_THIN_LTO_BC_EXT)\n+    format!(\"{}.{}\", module_name, PRE_LTO_BC_EXT)\n }\n \n fn msvc_imps_needed(tcx: TyCtxt) -> bool {"}, {"sha": "d8fb7c608c8afb72890d0219217034c5a56f8bbd", "filename": "src/librustc_codegen_ssa/traits/write.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/2a539a1b91c5ac17e6445d23e49c3f69d50d1ab6/src%2Flibrustc_codegen_ssa%2Ftraits%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a539a1b91c5ac17e6445d23e49c3f69d50d1ab6/src%2Flibrustc_codegen_ssa%2Ftraits%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ftraits%2Fwrite.rs?ref=2a539a1b91c5ac17e6445d23e49c3f69d50d1ab6", "patch": "@@ -1,5 +1,5 @@\n use crate::back::lto::{LtoModuleCodegen, SerializedModule, ThinModule};\n-use crate::back::write::{CodegenContext, ModuleConfig};\n+use crate::back::write::{CodegenContext, ModuleConfig, FatLTOInput};\n use crate::{CompiledModule, ModuleCodegen};\n \n use rustc::dep_graph::WorkProduct;\n@@ -18,7 +18,8 @@ pub trait WriteBackendMethods: 'static + Sized + Clone {\n     /// for further optimization.\n     fn run_fat_lto(\n         cgcx: &CodegenContext<Self>,\n-        modules: Vec<ModuleCodegen<Self::Module>>,\n+        modules: Vec<FatLTOInput<Self>>,\n+        cached_modules: Vec<(SerializedModule<Self::ModuleBuffer>, WorkProduct)>,\n         timeline: &mut Timeline,\n     ) -> Result<LtoModuleCodegen<Self>, FatalError>;\n     /// Performs thin LTO by performing necessary global analysis and returning two\n@@ -51,9 +52,11 @@ pub trait WriteBackendMethods: 'static + Sized + Clone {\n         timeline: &mut Timeline,\n     ) -> Result<CompiledModule, FatalError>;\n     fn prepare_thin(\n-        cgcx: &CodegenContext<Self>,\n         module: ModuleCodegen<Self::Module>\n     ) -> (String, Self::ThinBuffer);\n+    fn serialize_module(\n+        module: ModuleCodegen<Self::Module>\n+    ) -> (String, Self::ModuleBuffer);\n     fn run_lto_pass_manager(\n         cgcx: &CodegenContext<Self>,\n         llmod: &ModuleCodegen<Self::Module>,"}, {"sha": "25595e14982aee0ec6f721ecc2beabcf2c4fd842", "filename": "src/rustllvm/PassWrapper.cpp", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2a539a1b91c5ac17e6445d23e49c3f69d50d1ab6/src%2Frustllvm%2FPassWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/2a539a1b91c5ac17e6445d23e49c3f69d50d1ab6/src%2Frustllvm%2FPassWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FPassWrapper.cpp?ref=2a539a1b91c5ac17e6445d23e49c3f69d50d1ab6", "patch": "@@ -1092,10 +1092,10 @@ LLVMRustThinLTOBufferLen(const LLVMRustThinLTOBuffer *Buffer) {\n // processing.  We'll call this once per module optimized through ThinLTO, and\n // it'll be called concurrently on many threads.\n extern \"C\" LLVMModuleRef\n-LLVMRustParseBitcodeForThinLTO(LLVMContextRef Context,\n-                               const char *data,\n-                               size_t len,\n-                               const char *identifier) {\n+LLVMRustParseBitcodeForLTO(LLVMContextRef Context,\n+                           const char *data,\n+                           size_t len,\n+                           const char *identifier) {\n   StringRef Data(data, len);\n   MemoryBufferRef Buffer(Data, identifier);\n   unwrap(Context)->enableDebugTypeODRUniquing();"}, {"sha": "2a3e3c2467cdc00e2d74f3652d2987549f043805", "filename": "src/test/incremental/lto.rs", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/2a539a1b91c5ac17e6445d23e49c3f69d50d1ab6/src%2Ftest%2Fincremental%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a539a1b91c5ac17e6445d23e49c3f69d50d1ab6/src%2Ftest%2Fincremental%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Flto.rs?ref=2a539a1b91c5ac17e6445d23e49c3f69d50d1ab6", "patch": "@@ -0,0 +1,40 @@\n+// no-prefer-dynamic\n+// revisions:rpass1 rpass2\n+// compile-flags: -C lto\n+\n+mod x {\n+    pub struct X {\n+        x: u32, y: u32,\n+    }\n+\n+    #[cfg(rpass1)]\n+    fn make() -> X {\n+        X { x: 22, y: 0 }\n+    }\n+\n+    #[cfg(rpass2)]\n+    fn make() -> X {\n+        X { x: 11, y: 11 }\n+    }\n+\n+    pub fn new() -> X {\n+        make()\n+    }\n+\n+    pub fn sum(x: &X) -> u32 {\n+        x.x + x.y\n+    }\n+}\n+\n+mod y {\n+    use x;\n+\n+    pub fn assert_sum() -> bool {\n+        let x = x::new();\n+        x::sum(&x) == 22\n+    }\n+}\n+\n+pub fn main() {\n+    y::assert_sum();\n+}"}]}