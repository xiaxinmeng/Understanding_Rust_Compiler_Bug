{"sha": "791ce0b7b5d03649bc9014d5b0abb78f3c6f2cfd", "node_id": "C_kwDOAAsO6NoAKDc5MWNlMGI3YjVkMDM2NDliYzkwMTRkNWIwYWJiNzhmM2M2ZjJjZmQ", "commit": {"author": {"name": "lcnr", "email": "rust@lcnr.de", "date": "2023-03-14T13:19:06Z"}, "committer": {"name": "lcnr", "email": "rust@lcnr.de", "date": "2023-03-21T08:57:20Z"}, "message": "remove some trait solver helpers\n\nthey add more complexity then they are worth. It's confusing\nwhich of these helpers should be used in which context.", "tree": {"sha": "4a321c50deba262c65a0dc552fbfaca8cc70de14", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4a321c50deba262c65a0dc552fbfaca8cc70de14"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/791ce0b7b5d03649bc9014d5b0abb78f3c6f2cfd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/791ce0b7b5d03649bc9014d5b0abb78f3c6f2cfd", "html_url": "https://github.com/rust-lang/rust/commit/791ce0b7b5d03649bc9014d5b0abb78f3c6f2cfd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/791ce0b7b5d03649bc9014d5b0abb78f3c6f2cfd/comments", "author": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "84c47b8279b39e165dfebeb529eb6d92592e4f8d", "url": "https://api.github.com/repos/rust-lang/rust/commits/84c47b8279b39e165dfebeb529eb6d92592e4f8d", "html_url": "https://github.com/rust-lang/rust/commit/84c47b8279b39e165dfebeb529eb6d92592e4f8d"}], "stats": {"total": 486, "additions": 198, "deletions": 288}, "files": [{"sha": "75a3dd0c0f3d6f953b157b8a0fceabe1deb8ab7c", "filename": "compiler/rustc_borrowck/src/diagnostics/conflict_errors.rs", "status": "modified", "additions": 7, "deletions": 14, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/791ce0b7b5d03649bc9014d5b0abb78f3c6f2cfd/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ce0b7b5d03649bc9014d5b0abb78f3c6f2cfd/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs?ref=791ce0b7b5d03649bc9014d5b0abb78f3c6f2cfd", "patch": "@@ -24,6 +24,7 @@ use rustc_span::hygiene::DesugaringKind;\n use rustc_span::symbol::{kw, sym};\n use rustc_span::{BytePos, Span, Symbol};\n use rustc_trait_selection::infer::InferCtxtExt;\n+use rustc_trait_selection::traits::ObligationCtxt;\n \n use crate::borrow_set::TwoPhaseActivation;\n use crate::borrowck_errors;\n@@ -760,20 +761,12 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         else { return; };\n         // Try to find predicates on *generic params* that would allow copying `ty`\n         let infcx = tcx.infer_ctxt().build();\n-        let copy_did = infcx.tcx.require_lang_item(LangItem::Copy, Some(span));\n-        let cause = ObligationCause::new(\n-            span,\n-            self.mir_def_id(),\n-            rustc_infer::traits::ObligationCauseCode::MiscObligation,\n-        );\n-        let errors = rustc_trait_selection::traits::fully_solve_bound(\n-            &infcx,\n-            cause,\n-            self.param_env,\n-            // Erase any region vids from the type, which may not be resolved\n-            infcx.tcx.erase_regions(ty),\n-            copy_did,\n-        );\n+        let ocx = ObligationCtxt::new(&infcx);\n+        let copy_did = tcx.require_lang_item(LangItem::Copy, Some(span));\n+        let cause = ObligationCause::misc(span, self.mir_def_id());\n+\n+        ocx.register_bound(cause, self.param_env, infcx.tcx.erase_regions(ty), copy_did);\n+        let errors = ocx.select_all_or_error();\n \n         // Only emit suggestion if all required predicates are on generic\n         let predicates: Result<Vec<_>, _> = errors"}, {"sha": "9f543b71c5fa4098c406e3b1fcfc3832e70d3524", "filename": "compiler/rustc_borrowck/src/diagnostics/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/791ce0b7b5d03649bc9014d5b0abb78f3c6f2cfd/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ce0b7b5d03649bc9014d5b0abb78f3c6f2cfd/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmod.rs?ref=791ce0b7b5d03649bc9014d5b0abb78f3c6f2cfd", "patch": "@@ -1078,7 +1078,6 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                                     self.param_env,\n                                     tcx.mk_imm_ref(tcx.lifetimes.re_erased, tcx.erase_regions(ty)),\n                                     def_id,\n-                                    DUMMY_SP,\n                                 )\n                             }\n                             _ => false,"}, {"sha": "6758cba2eed3485a6efeb82d0b98c2317cc26241", "filename": "compiler/rustc_const_eval/src/transform/check_consts/qualifs.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/791ce0b7b5d03649bc9014d5b0abb78f3c6f2cfd/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fqualifs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ce0b7b5d03649bc9014d5b0abb78f3c6f2cfd/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fqualifs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fqualifs.rs?ref=791ce0b7b5d03649bc9014d5b0abb78f3c6f2cfd", "patch": "@@ -9,7 +9,7 @@ use rustc_middle::mir;\n use rustc_middle::mir::*;\n use rustc_middle::ty::{self, subst::SubstsRef, AdtDef, Ty};\n use rustc_trait_selection::traits::{\n-    self, ImplSource, Obligation, ObligationCause, SelectionContext,\n+    self, ImplSource, Obligation, ObligationCause, ObligationCtxt, SelectionContext,\n };\n \n use super::ConstCx;\n@@ -184,7 +184,10 @@ impl Qualif for NeedsNonConstDrop {\n         }\n \n         // If we had any errors, then it's bad\n-        !traits::fully_solve_obligations(&infcx, impl_src.nested_obligations()).is_empty()\n+        let ocx = ObligationCtxt::new(&infcx);\n+        ocx.register_obligations(impl_src.nested_obligations());\n+        let errors = ocx.select_all_or_error();\n+        !errors.is_empty()\n     }\n \n     fn in_adt_inherently<'tcx>("}, {"sha": "f7aaa7a159ffa67977dc8862316a7a6f5267b7a5", "filename": "compiler/rustc_hir_analysis/src/check/intrinsic.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/791ce0b7b5d03649bc9014d5b0abb78f3c6f2cfd/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ce0b7b5d03649bc9014d5b0abb78f3c6f2cfd/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fintrinsic.rs?ref=791ce0b7b5d03649bc9014d5b0abb78f3c6f2cfd", "patch": "@@ -59,6 +59,7 @@ fn equate_intrinsic_type<'tcx>(\n         require_same_types(\n             tcx,\n             &cause,\n+            ty::ParamEnv::empty(), // FIXME: do all intrinsics have an empty param env?\n             tcx.mk_fn_ptr(tcx.fn_sig(it.owner_id).subst_identity()),\n             fty,\n         );"}, {"sha": "e57996a467640de8a530f83c94f472f08109ace8", "filename": "compiler/rustc_hir_analysis/src/coherence/builtin.rs", "status": "modified", "additions": 18, "deletions": 15, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/791ce0b7b5d03649bc9014d5b0abb78f3c6f2cfd/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ce0b7b5d03649bc9014d5b0abb78f3c6f2cfd/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Fbuiltin.rs?ref=791ce0b7b5d03649bc9014d5b0abb78f3c6f2cfd", "patch": "@@ -11,13 +11,14 @@ use rustc_hir::ItemKind;\n use rustc_infer::infer::outlives::env::OutlivesEnvironment;\n use rustc_infer::infer::{self, RegionResolutionError};\n use rustc_infer::infer::{DefineOpaqueTypes, TyCtxtInferExt};\n+use rustc_infer::traits::Obligation;\n use rustc_middle::ty::adjustment::CoerceUnsizedInfo;\n use rustc_middle::ty::{self, suggest_constraining_type_params, Ty, TyCtxt, TypeVisitableExt};\n use rustc_trait_selection::traits::error_reporting::TypeErrCtxtExt;\n use rustc_trait_selection::traits::misc::{\n     type_allowed_to_implement_copy, CopyImplementationError, InfringingFieldsReason,\n };\n-use rustc_trait_selection::traits::predicate_for_trait_def;\n+use rustc_trait_selection::traits::ObligationCtxt;\n use rustc_trait_selection::traits::{self, ObligationCause};\n use std::collections::BTreeMap;\n \n@@ -334,19 +335,19 @@ fn visit_implementation_of_dispatch_from_dyn(tcx: TyCtxt<'_>, impl_did: LocalDef\n                     ))\n                     .emit();\n             } else {\n-                let errors = traits::fully_solve_obligations(\n-                    &infcx,\n-                    coerced_fields.into_iter().map(|field| {\n-                        predicate_for_trait_def(\n-                            tcx,\n-                            param_env,\n-                            cause.clone(),\n+                let ocx = ObligationCtxt::new(&infcx);\n+                for field in coerced_fields {\n+                    ocx.register_obligation(Obligation::new(\n+                        tcx,\n+                        cause.clone(),\n+                        param_env,\n+                        ty::Binder::dummy(tcx.mk_trait_ref(\n                             dispatch_from_dyn_trait,\n-                            0,\n                             [field.ty(tcx, substs_a), field.ty(tcx, substs_b)],\n-                        )\n-                    }),\n-                );\n+                        )),\n+                    ));\n+                }\n+                let errors = ocx.select_all_or_error();\n                 if !errors.is_empty() {\n                     infcx.err_ctxt().report_fulfillment_errors(&errors);\n                 }\n@@ -583,10 +584,12 @@ pub fn coerce_unsized_info<'tcx>(tcx: TyCtxt<'tcx>, impl_did: DefId) -> CoerceUn\n     };\n \n     // Register an obligation for `A: Trait<B>`.\n+    let ocx = ObligationCtxt::new(&infcx);\n     let cause = traits::ObligationCause::misc(span, impl_did);\n-    let predicate =\n-        predicate_for_trait_def(tcx, param_env, cause, trait_def_id, 0, [source, target]);\n-    let errors = traits::fully_solve_obligation(&infcx, predicate);\n+    let obligation =\n+        Obligation::new(tcx, cause, param_env, tcx.mk_trait_ref(trait_def_id, [source, target]));\n+    ocx.register_obligation(obligation);\n+    let errors = ocx.select_all_or_error();\n     if !errors.is_empty() {\n         infcx.err_ctxt().report_fulfillment_errors(&errors);\n     }"}, {"sha": "bdd033c5f5f107df6a2f097fa192464056a8a221", "filename": "compiler/rustc_hir_analysis/src/hir_wf_check.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/791ce0b7b5d03649bc9014d5b0abb78f3c6f2cfd/compiler%2Frustc_hir_analysis%2Fsrc%2Fhir_wf_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ce0b7b5d03649bc9014d5b0abb78f3c6f2cfd/compiler%2Frustc_hir_analysis%2Fsrc%2Fhir_wf_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fhir_wf_check.rs?ref=791ce0b7b5d03649bc9014d5b0abb78f3c6f2cfd", "patch": "@@ -7,7 +7,7 @@ use rustc_infer::traits::{ObligationCause, WellFormedLoc};\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::{self, Region, TyCtxt, TypeFoldable, TypeFolder};\n use rustc_span::def_id::LocalDefId;\n-use rustc_trait_selection::traits;\n+use rustc_trait_selection::traits::{self, ObligationCtxt};\n \n pub fn provide(providers: &mut Providers) {\n     *providers = Providers { diagnostic_hir_wf_check, ..*providers };\n@@ -66,35 +66,35 @@ fn diagnostic_hir_wf_check<'tcx>(\n     impl<'tcx> Visitor<'tcx> for HirWfCheck<'tcx> {\n         fn visit_ty(&mut self, ty: &'tcx hir::Ty<'tcx>) {\n             let infcx = self.tcx.infer_ctxt().build();\n+            let ocx = ObligationCtxt::new(&infcx);\n+\n             let tcx_ty = self.icx.to_ty(ty).fold_with(&mut EraseAllBoundRegions { tcx: self.tcx });\n             let cause = traits::ObligationCause::new(\n                 ty.span,\n                 self.def_id,\n                 traits::ObligationCauseCode::WellFormed(None),\n             );\n-            let errors = traits::fully_solve_obligation(\n-                &infcx,\n-                traits::Obligation::new(\n-                    self.tcx,\n-                    cause,\n-                    self.param_env,\n-                    ty::Binder::dummy(ty::PredicateKind::WellFormed(tcx_ty.into())),\n-                ),\n-            );\n-            if !errors.is_empty() {\n-                debug!(\"Wf-check got errors for {:?}: {:?}\", ty, errors);\n-                for error in errors {\n-                    if error.obligation.predicate == self.predicate {\n-                        // Save the cause from the greatest depth - this corresponds\n-                        // to picking more-specific types (e.g. `MyStruct<u8>`)\n-                        // over less-specific types (e.g. `Option<MyStruct<u8>>`)\n-                        if self.depth >= self.cause_depth {\n-                            self.cause = Some(error.obligation.cause);\n-                            self.cause_depth = self.depth\n-                        }\n+\n+            ocx.register_obligation(traits::Obligation::new(\n+                self.tcx,\n+                cause,\n+                self.param_env,\n+                ty::PredicateKind::WellFormed(tcx_ty.into()),\n+            ));\n+\n+            for error in ocx.select_all_or_error() {\n+                debug!(\"Wf-check got error for {:?}: {:?}\", ty, error);\n+                if error.obligation.predicate == self.predicate {\n+                    // Save the cause from the greatest depth - this corresponds\n+                    // to picking more-specific types (e.g. `MyStruct<u8>`)\n+                    // over less-specific types (e.g. `Option<MyStruct<u8>>`)\n+                    if self.depth >= self.cause_depth {\n+                        self.cause = Some(error.obligation.cause);\n+                        self.cause_depth = self.depth\n                     }\n                 }\n             }\n+\n             self.depth += 1;\n             intravisit::walk_ty(self, ty);\n             self.depth -= 1;"}, {"sha": "a3d045c80d164adef39cd35daf8bb53bd3f7fc3d", "filename": "compiler/rustc_hir_analysis/src/lib.rs", "status": "modified", "additions": 16, "deletions": 17, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/791ce0b7b5d03649bc9014d5b0abb78f3c6f2cfd/compiler%2Frustc_hir_analysis%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ce0b7b5d03649bc9014d5b0abb78f3c6f2cfd/compiler%2Frustc_hir_analysis%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Flib.rs?ref=791ce0b7b5d03649bc9014d5b0abb78f3c6f2cfd", "patch": "@@ -102,7 +102,7 @@ use rustc_errors::ErrorGuaranteed;\n use rustc_errors::{DiagnosticMessage, SubdiagnosticMessage};\n use rustc_hir as hir;\n use rustc_hir::Node;\n-use rustc_infer::infer::{DefineOpaqueTypes, InferOk, TyCtxtInferExt};\n+use rustc_infer::infer::TyCtxtInferExt;\n use rustc_macros::fluent_messages;\n use rustc_middle::middle;\n use rustc_middle::ty::query::Providers;\n@@ -113,7 +113,7 @@ use rustc_span::def_id::{DefId, LocalDefId, CRATE_DEF_ID};\n use rustc_span::{symbol::sym, Span, DUMMY_SP};\n use rustc_target::spec::abi::Abi;\n use rustc_trait_selection::traits::error_reporting::TypeErrCtxtExt as _;\n-use rustc_trait_selection::traits::{self, ObligationCause, ObligationCauseCode};\n+use rustc_trait_selection::traits::{self, ObligationCause, ObligationCauseCode, ObligationCtxt};\n \n use std::ops::Not;\n \n@@ -160,24 +160,21 @@ fn require_c_abi_if_c_variadic(tcx: TyCtxt<'_>, decl: &hir::FnDecl<'_>, abi: Abi\n fn require_same_types<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     cause: &ObligationCause<'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n     expected: Ty<'tcx>,\n     actual: Ty<'tcx>,\n-) -> bool {\n+) {\n     let infcx = &tcx.infer_ctxt().build();\n-    let param_env = ty::ParamEnv::empty();\n-    let errors = match infcx.at(cause, param_env).eq(DefineOpaqueTypes::No, expected, actual) {\n-        Ok(InferOk { obligations, .. }) => traits::fully_solve_obligations(infcx, obligations),\n+    let ocx = ObligationCtxt::new(infcx);\n+    match ocx.eq(cause, param_env, expected, actual) {\n+        Ok(()) => {\n+            let errors = ocx.select_all_or_error();\n+            if !errors.is_empty() {\n+                infcx.err_ctxt().report_fulfillment_errors(&errors);\n+            }\n+        }\n         Err(err) => {\n             infcx.err_ctxt().report_mismatched_types(cause, expected, actual, err).emit();\n-            return false;\n-        }\n-    };\n-\n-    match &errors[..] {\n-        [] => true,\n-        errors => {\n-            infcx.err_ctxt().report_fulfillment_errors(errors);\n-            false\n         }\n     }\n }\n@@ -296,6 +293,8 @@ fn check_main_fn_ty(tcx: TyCtxt<'_>, main_def_id: DefId) {\n         return;\n     }\n \n+    // Main should have no WC, so empty param env is OK here.\n+    let param_env = ty::ParamEnv::empty();\n     let expected_return_type;\n     if let Some(term_did) = tcx.lang_items().termination() {\n         let return_ty = main_fnsig.output();\n@@ -306,8 +305,6 @@ fn check_main_fn_ty(tcx: TyCtxt<'_>, main_def_id: DefId) {\n         }\n         let return_ty = return_ty.skip_binder();\n         let infcx = tcx.infer_ctxt().build();\n-        // Main should have no WC, so empty param env is OK here.\n-        let param_env = ty::ParamEnv::empty();\n         let cause = traits::ObligationCause::new(\n             return_ty_span,\n             main_diagnostics_def_id,\n@@ -343,6 +340,7 @@ fn check_main_fn_ty(tcx: TyCtxt<'_>, main_def_id: DefId) {\n             main_diagnostics_def_id,\n             ObligationCauseCode::MainFunctionType,\n         ),\n+        param_env,\n         se_ty,\n         tcx.mk_fn_ptr(main_fnsig),\n     );\n@@ -417,6 +415,7 @@ fn check_start_fn_ty(tcx: TyCtxt<'_>, start_def_id: DefId) {\n                     start_def_id,\n                     ObligationCauseCode::StartFunctionType,\n                 ),\n+                ty::ParamEnv::empty(), // start should not have any where bounds.\n                 se_ty,\n                 tcx.mk_fn_ptr(tcx.fn_sig(start_def_id).subst_identity()),\n             );"}, {"sha": "5235710a2666e38e6e3af80c2e438b349efd8502", "filename": "compiler/rustc_hir_typeck/src/callee.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/791ce0b7b5d03649bc9014d5b0abb78f3c6f2cfd/compiler%2Frustc_hir_typeck%2Fsrc%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ce0b7b5d03649bc9014d5b0abb78f3c6f2cfd/compiler%2Frustc_hir_typeck%2Fsrc%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fcallee.rs?ref=791ce0b7b5d03649bc9014d5b0abb78f3c6f2cfd", "patch": "@@ -668,7 +668,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         if !self.maybe_suggest_bad_array_definition(&mut err, call_expr, callee_expr) {\n             if let Some((maybe_def, output_ty, _)) = self.extract_callable_info(callee_ty)\n-                && !self.type_is_sized_modulo_regions(self.param_env, output_ty, callee_expr.span)\n+                && !self.type_is_sized_modulo_regions(self.param_env, output_ty)\n             {\n                 let descr = match maybe_def {\n                     DefIdOrName::DefId(def_id) => self.tcx.def_descr(def_id),"}, {"sha": "d28b3b3ce7bbd11e0071d6ddfef6724763bf5858", "filename": "compiler/rustc_hir_typeck/src/cast.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/791ce0b7b5d03649bc9014d5b0abb78f3c6f2cfd/compiler%2Frustc_hir_typeck%2Fsrc%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ce0b7b5d03649bc9014d5b0abb78f3c6f2cfd/compiler%2Frustc_hir_typeck%2Fsrc%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fcast.rs?ref=791ce0b7b5d03649bc9014d5b0abb78f3c6f2cfd", "patch": "@@ -96,7 +96,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let t = self.resolve_vars_if_possible(t);\n         t.error_reported()?;\n \n-        if self.type_is_sized_modulo_regions(self.param_env, t, span) {\n+        if self.type_is_sized_modulo_regions(self.param_env, t) {\n             return Ok(Some(PointerKind::Thin));\n         }\n \n@@ -722,7 +722,7 @@ impl<'a, 'tcx> CastCheck<'tcx> {\n \n         debug!(\"check_cast({}, {:?} as {:?})\", self.expr.hir_id, self.expr_ty, self.cast_ty);\n \n-        if !fcx.type_is_sized_modulo_regions(fcx.param_env, self.cast_ty, self.span)\n+        if !fcx.type_is_sized_modulo_regions(fcx.param_env, self.cast_ty)\n             && !self.cast_ty.has_infer_types()\n         {\n             self.report_cast_to_unsized_type(fcx);"}, {"sha": "8fa3bcd68c3d3c1807d342594bebc512f3e7c834", "filename": "compiler/rustc_hir_typeck/src/coercion.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/791ce0b7b5d03649bc9014d5b0abb78f3c6f2cfd/compiler%2Frustc_hir_typeck%2Fsrc%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ce0b7b5d03649bc9014d5b0abb78f3c6f2cfd/compiler%2Frustc_hir_typeck%2Fsrc%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fcoercion.rs?ref=791ce0b7b5d03649bc9014d5b0abb78f3c6f2cfd", "patch": "@@ -46,7 +46,7 @@ use rustc_hir::Expr;\n use rustc_hir_analysis::astconv::AstConv;\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use rustc_infer::infer::{Coercion, DefineOpaqueTypes, InferOk, InferResult};\n-use rustc_infer::traits::Obligation;\n+use rustc_infer::traits::{Obligation, PredicateObligation};\n use rustc_middle::lint::in_external_macro;\n use rustc_middle::ty::adjustment::{\n     Adjust, Adjustment, AllowTwoPhase, AutoBorrow, AutoBorrowMutability, PointerCast,\n@@ -597,13 +597,11 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n         // and almost never more than 3. By using a SmallVec we avoid an\n         // allocation, at the (very small) cost of (occasionally) having to\n         // shift subsequent elements down when removing the front element.\n-        let mut queue: SmallVec<[_; 4]> = smallvec![traits::predicate_for_trait_def(\n+        let mut queue: SmallVec<[PredicateObligation<'tcx>; 4]> = smallvec![Obligation::new(\n             self.tcx,\n-            self.fcx.param_env,\n             cause,\n-            coerce_unsized_did,\n-            0,\n-            [coerce_source, coerce_target]\n+            self.fcx.param_env,\n+            self.tcx.mk_trait_ref(coerce_unsized_did, [coerce_source, coerce_target])\n         )];\n \n         let mut has_unsized_tuple_coercion = false;\n@@ -651,9 +649,9 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n                         let self_ty = trait_pred.skip_binder().self_ty();\n                         let unsize_ty = trait_pred.skip_binder().trait_ref.substs[1].expect_ty();\n                         debug!(\"coerce_unsized: ambiguous unsize case for {:?}\", trait_pred);\n-                        match (&self_ty.kind(), &unsize_ty.kind()) {\n-                            (ty::Infer(ty::TyVar(v)), ty::Dynamic(..))\n-                                if self.type_var_is_sized(*v) =>\n+                        match (self_ty.kind(), unsize_ty.kind()) {\n+                            (&ty::Infer(ty::TyVar(v)), ty::Dynamic(..))\n+                                if self.type_var_is_sized(v) =>\n                             {\n                                 debug!(\"coerce_unsized: have sized infer {:?}\", v);\n                                 coercion.obligations.push(obligation);"}, {"sha": "06e857ec3ca1d6b915a377eea5aae6d940797613", "filename": "compiler/rustc_hir_typeck/src/demand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/791ce0b7b5d03649bc9014d5b0abb78f3c6f2cfd/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ce0b7b5d03649bc9014d5b0abb78f3c6f2cfd/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs?ref=791ce0b7b5d03649bc9014d5b0abb78f3c6f2cfd", "patch": "@@ -1480,7 +1480,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n                     // For this suggestion to make sense, the type would need to be `Copy`,\n                     // or we have to be moving out of a `Box<T>`\n-                    if self.type_is_copy_modulo_regions(self.param_env, expected, sp)\n+                    if self.type_is_copy_modulo_regions(self.param_env, expected)\n                         // FIXME(compiler-errors): We can actually do this if the checked_ty is\n                         // `steps` layers of boxes, not just one, but this is easier and most likely.\n                         || (checked_ty.is_box() && steps == 1)"}, {"sha": "c62c1553d6f722c3b6c97f4cc35eeca4410fa442", "filename": "compiler/rustc_hir_typeck/src/expr_use_visitor.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/791ce0b7b5d03649bc9014d5b0abb78f3c6f2cfd/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ce0b7b5d03649bc9014d5b0abb78f3c6f2cfd/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr_use_visitor.rs?ref=791ce0b7b5d03649bc9014d5b0abb78f3c6f2cfd", "patch": "@@ -867,10 +867,7 @@ fn copy_or_move<'a, 'tcx>(\n     mc: &mc::MemCategorizationContext<'a, 'tcx>,\n     place_with_id: &PlaceWithHirId<'tcx>,\n ) -> ConsumeMode {\n-    if !mc.type_is_copy_modulo_regions(\n-        place_with_id.place.ty(),\n-        mc.tcx().hir().span(place_with_id.hir_id),\n-    ) {\n+    if !mc.type_is_copy_modulo_regions(place_with_id.place.ty()) {\n         ConsumeMode::Move\n     } else {\n         ConsumeMode::Copy"}, {"sha": "7273b93b67690f5d4014119cae483c3c8c17369c", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/suggestions.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/791ce0b7b5d03649bc9014d5b0abb78f3c6f2cfd/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ce0b7b5d03649bc9014d5b0abb78f3c6f2cfd/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fsuggestions.rs?ref=791ce0b7b5d03649bc9014d5b0abb78f3c6f2cfd", "patch": "@@ -1011,11 +1011,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let mut suggest_copied_or_cloned = || {\n             let expr_inner_ty = substs.type_at(0);\n             let expected_inner_ty = expected_substs.type_at(0);\n-            if let ty::Ref(_, ty, hir::Mutability::Not) = expr_inner_ty.kind()\n-                && self.can_eq(self.param_env, *ty, expected_inner_ty)\n+            if let &ty::Ref(_, ty, hir::Mutability::Not) = expr_inner_ty.kind()\n+                && self.can_eq(self.param_env, ty, expected_inner_ty)\n             {\n                 let def_path = self.tcx.def_path_str(adt_def.did());\n-                if self.type_is_copy_modulo_regions(self.param_env, *ty, expr.span) {\n+                if self.type_is_copy_modulo_regions(self.param_env, ty) {\n                     diag.span_suggestion_verbose(\n                         expr.span.shrink_to_hi(),\n                         format!(\n@@ -1029,9 +1029,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     && rustc_trait_selection::traits::type_known_to_meet_bound_modulo_regions(\n                         self,\n                         self.param_env,\n-                        *ty,\n+                        ty,\n                         clone_did,\n-                        expr.span\n                     )\n                 {\n                     diag.span_suggestion_verbose("}, {"sha": "95e5483abf3bd31211bf427f282d5ebd77aa784e", "filename": "compiler/rustc_hir_typeck/src/mem_categorization.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/791ce0b7b5d03649bc9014d5b0abb78f3c6f2cfd/compiler%2Frustc_hir_typeck%2Fsrc%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ce0b7b5d03649bc9014d5b0abb78f3c6f2cfd/compiler%2Frustc_hir_typeck%2Fsrc%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmem_categorization.rs?ref=791ce0b7b5d03649bc9014d5b0abb78f3c6f2cfd", "patch": "@@ -120,8 +120,8 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n         self.infcx.tcx\n     }\n \n-    pub(crate) fn type_is_copy_modulo_regions(&self, ty: Ty<'tcx>, span: Span) -> bool {\n-        self.infcx.type_is_copy_modulo_regions(self.param_env, ty, span)\n+    pub(crate) fn type_is_copy_modulo_regions(&self, ty: Ty<'tcx>) -> bool {\n+        self.infcx.type_is_copy_modulo_regions(self.param_env, ty)\n     }\n \n     fn resolve_vars_if_possible<T>(&self, value: T) -> T"}, {"sha": "8a83bb58573d3c2467b663ea3424562a6149be58", "filename": "compiler/rustc_hir_typeck/src/op.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/791ce0b7b5d03649bc9014d5b0abb78f3c6f2cfd/compiler%2Frustc_hir_typeck%2Fsrc%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ce0b7b5d03649bc9014d5b0abb78f3c6f2cfd/compiler%2Frustc_hir_typeck%2Fsrc%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fop.rs?ref=791ce0b7b5d03649bc9014d5b0abb78f3c6f2cfd", "patch": "@@ -21,7 +21,7 @@ use rustc_span::symbol::{sym, Ident};\n use rustc_span::Span;\n use rustc_trait_selection::infer::InferCtxtExt;\n use rustc_trait_selection::traits::error_reporting::suggestions::TypeErrCtxtExt as _;\n-use rustc_trait_selection::traits::{self, FulfillmentError};\n+use rustc_trait_selection::traits::{self, FulfillmentError, ObligationCtxt};\n use rustc_type_ir::sty::TyKind::*;\n \n impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n@@ -434,7 +434,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     if self.type_is_copy_modulo_regions(\n                         self.param_env,\n                         *lhs_deref_ty,\n-                        lhs_expr.span,\n                     ) {\n                         suggest_deref_binop(*lhs_deref_ty);\n                     }\n@@ -776,7 +775,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             (None, Some(trait_did)) => {\n                 let (obligation, _) =\n                     self.obligation_for_method(cause, trait_did, lhs_ty, Some(input_types));\n-                Err(rustc_trait_selection::traits::fully_solve_obligation(self, obligation))\n+                // FIXME: This should potentially just add the obligation to the `FnCtxt`\n+                let ocx = ObligationCtxt::new(&self.infcx);\n+                ocx.register_obligation(obligation);\n+                Err(ocx.select_all_or_error())\n             }\n         }\n     }"}, {"sha": "84fe21825d787f0985427d7aec4da6534c735c9f", "filename": "compiler/rustc_hir_typeck/src/upvar.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/791ce0b7b5d03649bc9014d5b0abb78f3c6f2cfd/compiler%2Frustc_hir_typeck%2Fsrc%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ce0b7b5d03649bc9014d5b0abb78f3c6f2cfd/compiler%2Frustc_hir_typeck%2Fsrc%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fupvar.rs?ref=791ce0b7b5d03649bc9014d5b0abb78f3c6f2cfd", "patch": "@@ -424,7 +424,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 // closures. We want to make sure any adjustment that might make us move the place into\n                 // the closure gets handled.\n                 let (place, capture_kind) =\n-                    restrict_precision_for_drop_types(self, place, capture_kind, usage_span);\n+                    restrict_precision_for_drop_types(self, place, capture_kind);\n \n                 capture_info.capture_kind = capture_kind;\n                 (place, capture_info)\n@@ -1822,9 +1822,8 @@ fn restrict_precision_for_drop_types<'a, 'tcx>(\n     fcx: &'a FnCtxt<'a, 'tcx>,\n     mut place: Place<'tcx>,\n     mut curr_mode: ty::UpvarCapture,\n-    span: Span,\n ) -> (Place<'tcx>, ty::UpvarCapture) {\n-    let is_copy_type = fcx.infcx.type_is_copy_modulo_regions(fcx.param_env, place.ty(), span);\n+    let is_copy_type = fcx.infcx.type_is_copy_modulo_regions(fcx.param_env, place.ty());\n \n     if let (false, UpvarCapture::ByValue) = (is_copy_type, curr_mode) {\n         for i in 0..place.projections.len() {"}, {"sha": "cb7711034ed632e508070059b49be5c191202bd0", "filename": "compiler/rustc_lint/src/for_loops_over_fallibles.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/791ce0b7b5d03649bc9014d5b0abb78f3c6f2cfd/compiler%2Frustc_lint%2Fsrc%2Ffor_loops_over_fallibles.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ce0b7b5d03649bc9014d5b0abb78f3c6f2cfd/compiler%2Frustc_lint%2Fsrc%2Ffor_loops_over_fallibles.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Ffor_loops_over_fallibles.rs?ref=791ce0b7b5d03649bc9014d5b0abb78f3c6f2cfd", "patch": "@@ -11,6 +11,7 @@ use rustc_hir as hir;\n use rustc_infer::{infer::TyCtxtInferExt, traits::ObligationCause};\n use rustc_middle::ty::{self, List};\n use rustc_span::{sym, Span};\n+use rustc_trait_selection::traits::ObligationCtxt;\n \n declare_lint! {\n     /// The `for_loops_over_fallibles` lint checks for `for` loops over `Option` or `Result` values.\n@@ -136,20 +137,23 @@ fn suggest_question_mark<'tcx>(\n \n     let ty = substs.type_at(0);\n     let infcx = cx.tcx.infer_ctxt().build();\n+    let ocx = ObligationCtxt::new(&infcx);\n+\n     let body_def_id = cx.tcx.hir().body_owner_def_id(body_id);\n     let cause = ObligationCause::new(\n         span,\n         body_def_id,\n         rustc_infer::traits::ObligationCauseCode::MiscObligation,\n     );\n-    let errors = rustc_trait_selection::traits::fully_solve_bound(\n-        &infcx,\n+\n+    ocx.register_bound(\n         cause,\n+        // FIXME: using the empty param env is wrong, should use the one from `body_id`.\n         ty::ParamEnv::empty(),\n         // Erase any region vids from the type, which may not be resolved\n         infcx.tcx.erase_regions(ty),\n         into_iterator_did,\n     );\n \n-    errors.is_empty()\n+    ocx.select_all_or_error().is_empty()\n }"}, {"sha": "6ba3ab097de53a23dcd9f9329d60bb2b96b5d78c", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/791ce0b7b5d03649bc9014d5b0abb78f3c6f2cfd/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ce0b7b5d03649bc9014d5b0abb78f3c6f2cfd/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=791ce0b7b5d03649bc9014d5b0abb78f3c6f2cfd", "patch": "@@ -1128,6 +1128,13 @@ impl<'tcx, T> ToPredicate<'tcx, T> for T {\n     }\n }\n \n+impl<'tcx> ToPredicate<'tcx> for PredicateKind<'tcx> {\n+    #[inline(always)]\n+    fn to_predicate(self, tcx: TyCtxt<'tcx>) -> Predicate<'tcx> {\n+        ty::Binder::dummy(self).to_predicate(tcx)\n+    }\n+}\n+\n impl<'tcx> ToPredicate<'tcx> for Binder<'tcx, PredicateKind<'tcx>> {\n     #[inline(always)]\n     fn to_predicate(self, tcx: TyCtxt<'tcx>) -> Predicate<'tcx> {\n@@ -1142,6 +1149,13 @@ impl<'tcx> ToPredicate<'tcx> for Clause<'tcx> {\n     }\n }\n \n+impl<'tcx> ToPredicate<'tcx> for TraitRef<'tcx> {\n+    #[inline(always)]\n+    fn to_predicate(self, tcx: TyCtxt<'tcx>) -> Predicate<'tcx> {\n+        ty::Binder::dummy(self).to_predicate(tcx)\n+    }\n+}\n+\n impl<'tcx> ToPredicate<'tcx> for Binder<'tcx, TraitRef<'tcx>> {\n     #[inline(always)]\n     fn to_predicate(self, tcx: TyCtxt<'tcx>) -> Predicate<'tcx> {"}, {"sha": "90d78658f968387b09ba1c54c219e90298e7c9f9", "filename": "compiler/rustc_mir_build/src/build/misc.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/791ce0b7b5d03649bc9014d5b0abb78f3c6f2cfd/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ce0b7b5d03649bc9014d5b0abb78f3c6f2cfd/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmisc.rs?ref=791ce0b7b5d03649bc9014d5b0abb78f3c6f2cfd", "patch": "@@ -5,7 +5,7 @@ use crate::build::Builder;\n \n use rustc_middle::mir::*;\n use rustc_middle::ty::{self, Ty};\n-use rustc_span::{Span, DUMMY_SP};\n+use rustc_span::Span;\n use rustc_trait_selection::infer::InferCtxtExt;\n \n impl<'a, 'tcx> Builder<'a, 'tcx> {\n@@ -66,7 +66,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     pub(crate) fn consume_by_copy_or_move(&self, place: Place<'tcx>) -> Operand<'tcx> {\n         let tcx = self.tcx;\n         let ty = place.ty(&self.local_decls, tcx).ty;\n-        if !self.infcx.type_is_copy_modulo_regions(self.param_env, ty, DUMMY_SP) {\n+        if !self.infcx.type_is_copy_modulo_regions(self.param_env, ty) {\n             Operand::Move(place)\n         } else {\n             Operand::Copy(place)"}, {"sha": "274c2f06137a33a8c9b9f32cbfff709274b48b6c", "filename": "compiler/rustc_mir_build/src/thir/pattern/const_to_pat.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/791ce0b7b5d03649bc9014d5b0abb78f3c6f2cfd/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fconst_to_pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ce0b7b5d03649bc9014d5b0abb78f3c6f2cfd/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fconst_to_pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fconst_to_pat.rs?ref=791ce0b7b5d03649bc9014d5b0abb78f3c6f2cfd", "patch": "@@ -1,14 +1,14 @@\n use rustc_hir as hir;\n use rustc_index::vec::Idx;\n use rustc_infer::infer::{InferCtxt, TyCtxtInferExt};\n+use rustc_infer::traits::Obligation;\n use rustc_middle::mir::{self, Field};\n use rustc_middle::thir::{FieldPat, Pat, PatKind};\n use rustc_middle::ty::{self, Ty, TyCtxt};\n use rustc_session::lint;\n use rustc_span::Span;\n-use rustc_trait_selection::traits::predicate_for_trait_def;\n use rustc_trait_selection::traits::query::evaluate_obligation::InferCtxtExt;\n-use rustc_trait_selection::traits::{self, ObligationCause, PredicateObligation};\n+use rustc_trait_selection::traits::{self, ObligationCause};\n \n use std::cell::Cell;\n \n@@ -189,17 +189,15 @@ impl<'tcx> ConstToPat<'tcx> {\n         // using `PartialEq::eq` in this scenario in the past.)\n         let partial_eq_trait_id =\n             self.tcx().require_lang_item(hir::LangItem::PartialEq, Some(self.span));\n-        let obligation: PredicateObligation<'_> = predicate_for_trait_def(\n+        let partial_eq_obligation = Obligation::new(\n             self.tcx(),\n+            ObligationCause::dummy(),\n             self.param_env,\n-            ObligationCause::misc(self.span, self.id.owner.def_id),\n-            partial_eq_trait_id,\n-            0,\n-            [ty, ty],\n+            self.tcx().mk_trait_ref(partial_eq_trait_id, [ty, ty]),\n         );\n-        // FIXME: should this call a `predicate_must_hold` variant instead?\n \n-        let has_impl = self.infcx.predicate_may_hold(&obligation);\n+        // FIXME: should this call a `predicate_must_hold` variant instead?\n+        let has_impl = self.infcx.predicate_may_hold(&partial_eq_obligation);\n \n         // Note: To fix rust-lang/rust#65466, we could just remove this type\n         // walk hack for function pointers, and unconditionally error"}, {"sha": "911cc0b88c406f6789f4630894d7a270a7fdb524", "filename": "compiler/rustc_trait_selection/src/infer.rs", "status": "modified", "additions": 8, "deletions": 27, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/791ce0b7b5d03649bc9014d5b0abb78f3c6f2cfd/compiler%2Frustc_trait_selection%2Fsrc%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ce0b7b5d03649bc9014d5b0abb78f3c6f2cfd/compiler%2Frustc_trait_selection%2Fsrc%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Finfer.rs?ref=791ce0b7b5d03649bc9014d5b0abb78f3c6f2cfd", "patch": "@@ -8,26 +8,16 @@ use rustc_middle::infer::canonical::{Canonical, CanonicalQueryResponse, QueryRes\n use rustc_middle::traits::query::Fallible;\n use rustc_middle::ty::{self, Ty, TyCtxt, TypeFoldable, TypeVisitableExt};\n use rustc_middle::ty::{GenericArg, ToPredicate};\n-use rustc_span::{Span, DUMMY_SP};\n+use rustc_span::DUMMY_SP;\n \n use std::fmt::Debug;\n \n pub use rustc_infer::infer::*;\n \n pub trait InferCtxtExt<'tcx> {\n-    fn type_is_copy_modulo_regions(\n-        &self,\n-        param_env: ty::ParamEnv<'tcx>,\n-        ty: Ty<'tcx>,\n-        span: Span,\n-    ) -> bool;\n+    fn type_is_copy_modulo_regions(&self, param_env: ty::ParamEnv<'tcx>, ty: Ty<'tcx>) -> bool;\n \n-    fn type_is_sized_modulo_regions(\n-        &self,\n-        param_env: ty::ParamEnv<'tcx>,\n-        ty: Ty<'tcx>,\n-        span: Span,\n-    ) -> bool;\n+    fn type_is_sized_modulo_regions(&self, param_env: ty::ParamEnv<'tcx>, ty: Ty<'tcx>) -> bool;\n \n     /// Check whether a `ty` implements given trait(trait_def_id).\n     /// The inputs are:\n@@ -46,13 +36,9 @@ pub trait InferCtxtExt<'tcx> {\n         param_env: ty::ParamEnv<'tcx>,\n     ) -> traits::EvaluationResult;\n }\n+\n impl<'tcx> InferCtxtExt<'tcx> for InferCtxt<'tcx> {\n-    fn type_is_copy_modulo_regions(\n-        &self,\n-        param_env: ty::ParamEnv<'tcx>,\n-        ty: Ty<'tcx>,\n-        span: Span,\n-    ) -> bool {\n+    fn type_is_copy_modulo_regions(&self, param_env: ty::ParamEnv<'tcx>, ty: Ty<'tcx>) -> bool {\n         let ty = self.resolve_vars_if_possible(ty);\n \n         if !(param_env, ty).needs_infer() {\n@@ -65,17 +51,12 @@ impl<'tcx> InferCtxtExt<'tcx> for InferCtxt<'tcx> {\n         // rightly refuses to work with inference variables, but\n         // moves_by_default has a cache, which we want to use in other\n         // cases.\n-        traits::type_known_to_meet_bound_modulo_regions(self, param_env, ty, copy_def_id, span)\n+        traits::type_known_to_meet_bound_modulo_regions(self, param_env, ty, copy_def_id)\n     }\n \n-    fn type_is_sized_modulo_regions(\n-        &self,\n-        param_env: ty::ParamEnv<'tcx>,\n-        ty: Ty<'tcx>,\n-        span: Span,\n-    ) -> bool {\n+    fn type_is_sized_modulo_regions(&self, param_env: ty::ParamEnv<'tcx>, ty: Ty<'tcx>) -> bool {\n         let lang_item = self.tcx.require_lang_item(LangItem::Sized, None);\n-        traits::type_known_to_meet_bound_modulo_regions(self, param_env, ty, lang_item, span)\n+        traits::type_known_to_meet_bound_modulo_regions(self, param_env, ty, lang_item)\n     }\n \n     #[instrument(level = \"debug\", skip(self, params), ret)]"}, {"sha": "dbf6775afc2fcc9610510a5a95bd2a35d94be730", "filename": "compiler/rustc_trait_selection/src/traits/auto_trait.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/791ce0b7b5d03649bc9014d5b0abb78f3c6f2cfd/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ce0b7b5d03649bc9014d5b0abb78f3c6f2cfd/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fauto_trait.rs?ref=791ce0b7b5d03649bc9014d5b0abb78f3c6f2cfd", "patch": "@@ -180,8 +180,9 @@ impl<'tcx> AutoTraitFinder<'tcx> {\n         // At this point, we already have all of the bounds we need. FulfillmentContext is used\n         // to store all of the necessary region/lifetime bounds in the InferContext, as well as\n         // an additional sanity check.\n-        let errors =\n-            super::fully_solve_bound(&infcx, ObligationCause::dummy(), full_env, ty, trait_did);\n+        let ocx = ObligationCtxt::new(&infcx);\n+        ocx.register_bound(ObligationCause::dummy(), full_env, ty, trait_did);\n+        let errors = ocx.select_all_or_error();\n         if !errors.is_empty() {\n             panic!(\"Unable to fulfill trait {:?} for '{:?}': {:?}\", trait_did, ty, errors);\n         }"}, {"sha": "572d20b5368b405243f39d426eec44fe01352eaa", "filename": "compiler/rustc_trait_selection/src/traits/coherence.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/791ce0b7b5d03649bc9014d5b0abb78f3c6f2cfd/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ce0b7b5d03649bc9014d5b0abb78f3c6f2cfd/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs?ref=791ce0b7b5d03649bc9014d5b0abb78f3c6f2cfd", "patch": "@@ -383,7 +383,10 @@ fn resolve_negative_obligation<'tcx>(\n     };\n \n     let param_env = o.param_env;\n-    if !super::fully_solve_obligation(&infcx, o).is_empty() {\n+    let ocx = ObligationCtxt::new(&infcx);\n+    ocx.register_obligation(o);\n+    let errors = ocx.select_all_or_error();\n+    if !errors.is_empty() {\n         return false;\n     }\n "}, {"sha": "b27a39290781af94dc6c9d251467592aaf769512", "filename": "compiler/rustc_trait_selection/src/traits/mod.rs", "status": "modified", "additions": 13, "deletions": 59, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/791ce0b7b5d03649bc9014d5b0abb78f3c6f2cfd/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ce0b7b5d03649bc9014d5b0abb78f3c6f2cfd/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs?ref=791ce0b7b5d03649bc9014d5b0abb78f3c6f2cfd", "patch": "@@ -30,7 +30,7 @@ use rustc_middle::ty::fold::TypeFoldable;\n use rustc_middle::ty::visit::{TypeVisitable, TypeVisitableExt};\n use rustc_middle::ty::{self, ToPredicate, Ty, TyCtxt, TypeSuperVisitable};\n use rustc_middle::ty::{InternalSubsts, SubstsRef};\n-use rustc_span::def_id::{DefId, CRATE_DEF_ID};\n+use rustc_span::def_id::DefId;\n use rustc_span::Span;\n \n use std::fmt::Debug;\n@@ -63,9 +63,7 @@ pub use self::util::{\n     elaborate_trait_ref, elaborate_trait_refs,\n };\n pub use self::util::{expand_trait_aliases, TraitAliasExpander};\n-pub use self::util::{\n-    get_vtable_index_of_object_method, impl_item_is_final, predicate_for_trait_def, upcast_choices,\n-};\n+pub use self::util::{get_vtable_index_of_object_method, impl_item_is_final, upcast_choices};\n pub use self::util::{\n     supertrait_def_ids, supertraits, transitive_bounds, transitive_bounds_that_define_assoc_type,\n     SupertraitDefIds, Supertraits,\n@@ -131,29 +129,23 @@ pub fn type_known_to_meet_bound_modulo_regions<'tcx>(\n     param_env: ty::ParamEnv<'tcx>,\n     ty: Ty<'tcx>,\n     def_id: DefId,\n-    span: Span,\n ) -> bool {\n     let trait_ref = ty::Binder::dummy(infcx.tcx.mk_trait_ref(def_id, [ty]));\n-    pred_known_to_hold_modulo_regions(infcx, param_env, trait_ref.without_const(), span)\n+    pred_known_to_hold_modulo_regions(infcx, param_env, trait_ref.without_const())\n }\n \n-#[instrument(level = \"debug\", skip(infcx, param_env, span, pred), ret)]\n+/// FIXME(@lcnr): this function doesn't seem right and shouldn't exist?\n+///\n+/// Ping me on zulip if you want to use this method and need help with finding\n+/// an appropriate replacement.\n+#[instrument(level = \"debug\", skip(infcx, param_env, pred), ret)]\n fn pred_known_to_hold_modulo_regions<'tcx>(\n     infcx: &InferCtxt<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n     pred: impl ToPredicate<'tcx> + TypeVisitable<TyCtxt<'tcx>>,\n-    span: Span,\n ) -> bool {\n     let has_non_region_infer = pred.has_non_region_infer();\n-    let obligation = Obligation {\n-        param_env,\n-        // We can use a dummy node-id here because we won't pay any mind\n-        // to region obligations that arise (there shouldn't really be any\n-        // anyhow).\n-        cause: ObligationCause::misc(span, CRATE_DEF_ID),\n-        recursion_depth: 0,\n-        predicate: pred.to_predicate(infcx.tcx),\n-    };\n+    let obligation = Obligation::new(infcx.tcx, ObligationCause::dummy(), param_env, pred);\n \n     let result = infcx.evaluate_obligation_no_overflow(&obligation);\n     debug!(?result);\n@@ -166,14 +158,13 @@ fn pred_known_to_hold_modulo_regions<'tcx>(\n         // this function's result remains infallible, we must confirm\n         // that guess. While imperfect, I believe this is sound.\n \n-        // FIXME(@lcnr): this function doesn't seem right.\n-        //\n         // The handling of regions in this area of the code is terrible,\n         // see issue #29149. We should be able to improve on this with\n         // NLL.\n-        let errors = fully_solve_obligation(infcx, obligation);\n-\n-        match &errors[..] {\n+        let ocx = ObligationCtxt::new(infcx);\n+        ocx.register_obligation(obligation);\n+        let errors = ocx.select_all_or_error();\n+        match errors.as_slice() {\n             [] => true,\n             errors => {\n                 debug!(?errors);\n@@ -389,43 +380,6 @@ where\n     Ok(resolved_value)\n }\n \n-/// Process an obligation (and any nested obligations that come from it) to\n-/// completion, returning any errors\n-pub fn fully_solve_obligation<'tcx>(\n-    infcx: &InferCtxt<'tcx>,\n-    obligation: PredicateObligation<'tcx>,\n-) -> Vec<FulfillmentError<'tcx>> {\n-    fully_solve_obligations(infcx, [obligation])\n-}\n-\n-/// Process a set of obligations (and any nested obligations that come from them)\n-/// to completion\n-pub fn fully_solve_obligations<'tcx>(\n-    infcx: &InferCtxt<'tcx>,\n-    obligations: impl IntoIterator<Item = PredicateObligation<'tcx>>,\n-) -> Vec<FulfillmentError<'tcx>> {\n-    let ocx = ObligationCtxt::new(infcx);\n-    ocx.register_obligations(obligations);\n-    ocx.select_all_or_error()\n-}\n-\n-/// Process a bound (and any nested obligations that come from it) to completion.\n-/// This is a convenience function for traits that have no generic arguments, such\n-/// as auto traits, and builtin traits like Copy or Sized.\n-pub fn fully_solve_bound<'tcx>(\n-    infcx: &InferCtxt<'tcx>,\n-    cause: ObligationCause<'tcx>,\n-    param_env: ty::ParamEnv<'tcx>,\n-    ty: Ty<'tcx>,\n-    bound: DefId,\n-) -> Vec<FulfillmentError<'tcx>> {\n-    let tcx = infcx.tcx;\n-    let trait_ref = tcx.mk_trait_ref(bound, [ty]);\n-    let obligation = Obligation::new(tcx, cause, param_env, ty::Binder::dummy(trait_ref));\n-\n-    fully_solve_obligation(infcx, obligation)\n-}\n-\n /// Normalizes the predicates and checks whether they hold in an empty environment. If this\n /// returns true, then either normalize encountered an error or one of the predicates did not\n /// hold. Used when creating vtables to check for unsatisfiable methods."}, {"sha": "bac02f2d38328adf0000ce59c97bc8082471b7ad", "filename": "compiler/rustc_trait_selection/src/traits/outlives_bounds.rs", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/791ce0b7b5d03649bc9014d5b0abb78f3c6f2cfd/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Foutlives_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ce0b7b5d03649bc9014d5b0abb78f3c6f2cfd/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Foutlives_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Foutlives_bounds.rs?ref=791ce0b7b5d03649bc9014d5b0abb78f3c6f2cfd", "patch": "@@ -1,7 +1,7 @@\n use crate::infer::InferCtxt;\n use crate::traits::query::type_op::{self, TypeOp, TypeOpOutput};\n use crate::traits::query::NoSolution;\n-use crate::traits::ObligationCause;\n+use crate::traits::{ObligationCause, ObligationCtxt};\n use rustc_data_structures::fx::FxIndexSet;\n use rustc_middle::ty::{self, ParamEnv, Ty};\n use rustc_span::def_id::LocalDefId;\n@@ -71,22 +71,23 @@ impl<'a, 'tcx: 'a> InferCtxtExt<'a, 'tcx> for InferCtxt<'tcx> {\n \n         if let Some(constraints) = constraints {\n             debug!(?constraints);\n+            if !constraints.member_constraints.is_empty() {\n+                span_bug!(span, \"{:#?}\", constraints.member_constraints);\n+            }\n+\n             // Instantiation may have produced new inference variables and constraints on those\n             // variables. Process these constraints.\n+            let ocx = ObligationCtxt::new(self);\n             let cause = ObligationCause::misc(span, body_id);\n-            let errors = super::fully_solve_obligations(\n-                self,\n-                constraints.outlives.iter().map(|constraint| {\n-                    self.query_outlives_constraint_to_obligation(\n-                        *constraint,\n-                        cause.clone(),\n-                        param_env,\n-                    )\n-                }),\n-            );\n-            if !constraints.member_constraints.is_empty() {\n-                span_bug!(span, \"{:#?}\", constraints.member_constraints);\n+            for &constraint in &constraints.outlives {\n+                ocx.register_obligation(self.query_outlives_constraint_to_obligation(\n+                    constraint,\n+                    cause.clone(),\n+                    param_env,\n+                ));\n             }\n+\n+            let errors = ocx.select_all_or_error();\n             if !errors.is_empty() {\n                 self.tcx.sess.delay_span_bug(\n                     span,"}, {"sha": "8f1b05c1190d5b875983e8cf93a336bbd460e4b7", "filename": "compiler/rustc_trait_selection/src/traits/query/type_op/custom.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/791ce0b7b5d03649bc9014d5b0abb78f3c6f2cfd/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Fcustom.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ce0b7b5d03649bc9014d5b0abb78f3c6f2cfd/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Fcustom.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Fcustom.rs?ref=791ce0b7b5d03649bc9014d5b0abb78f3c6f2cfd", "patch": "@@ -1,8 +1,8 @@\n use crate::infer::canonical::query_response;\n use crate::infer::{InferCtxt, InferOk};\n-use crate::traits;\n use crate::traits::query::type_op::TypeOpOutput;\n use crate::traits::query::Fallible;\n+use crate::traits::ObligationCtxt;\n use rustc_infer::infer::region_constraints::RegionConstraintData;\n use rustc_span::source_map::DUMMY_SP;\n \n@@ -73,7 +73,9 @@ pub fn scrape_region_constraints<'tcx, Op: super::TypeOp<'tcx, Output = R>, R>(\n     );\n \n     let InferOk { value, obligations } = infcx.commit_if_ok(|_| op())?;\n-    let errors = traits::fully_solve_obligations(infcx, obligations);\n+    let ocx = ObligationCtxt::new(infcx);\n+    ocx.register_obligations(obligations);\n+    let errors = ocx.select_all_or_error();\n     if !errors.is_empty() {\n         infcx.tcx.sess.diagnostic().delay_span_bug(\n             DUMMY_SP,\n@@ -82,9 +84,7 @@ pub fn scrape_region_constraints<'tcx, Op: super::TypeOp<'tcx, Output = R>, R>(\n     }\n \n     let region_obligations = infcx.take_registered_region_obligations();\n-\n     let region_constraint_data = infcx.take_and_reset_region_constraints();\n-\n     let region_constraints = query_response::make_query_region_constraints(\n         infcx.tcx,\n         region_obligations"}, {"sha": "eb354bc3f50c6386ceea3b2359ef995b01666da8", "filename": "compiler/rustc_trait_selection/src/traits/select/confirmation.rs", "status": "modified", "additions": 16, "deletions": 28, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/791ce0b7b5d03649bc9014d5b0abb78f3c6f2cfd/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ce0b7b5d03649bc9014d5b0abb78f3c6f2cfd/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs?ref=791ce0b7b5d03649bc9014d5b0abb78f3c6f2cfd", "patch": "@@ -18,7 +18,7 @@ use rustc_session::config::TraitSolver;\n use rustc_span::def_id::DefId;\n \n use crate::traits::project::{normalize_with_depth, normalize_with_depth_to};\n-use crate::traits::util::{self, closure_trait_ref_and_return_type, predicate_for_trait_def};\n+use crate::traits::util::{self, closure_trait_ref_and_return_type};\n use crate::traits::vtable::{\n     count_own_vtable_entries, prepare_vtable_segments, vtable_trait_first_method_offset,\n     VtblSegment,\n@@ -253,15 +253,13 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             };\n \n             let cause = obligation.derived_cause(BuiltinDerivedObligation);\n-            ensure_sufficient_stack(|| {\n-                self.collect_predicates_for_types(\n-                    obligation.param_env,\n-                    cause,\n-                    obligation.recursion_depth + 1,\n-                    trait_def,\n-                    nested,\n-                )\n-            })\n+            self.collect_predicates_for_types(\n+                obligation.param_env,\n+                cause,\n+                obligation.recursion_depth + 1,\n+                trait_def,\n+                nested,\n+            )\n         } else {\n             vec![]\n         };\n@@ -1118,14 +1116,11 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 nested.extend(obligations);\n \n                 // Construct the nested `TailField<T>: Unsize<TailField<U>>` predicate.\n-                nested.push(predicate_for_trait_def(\n+                let tail_unsize_obligation = obligation.with(\n                     tcx,\n-                    obligation.param_env,\n-                    obligation.cause.clone(),\n-                    obligation.predicate.def_id(),\n-                    obligation.recursion_depth + 1,\n-                    [source_tail, target_tail],\n-                ));\n+                    tcx.mk_trait_ref(obligation.predicate.def_id(), [source_tail, target_tail]),\n+                );\n+                nested.push(tail_unsize_obligation);\n             }\n \n             // `(.., T)` -> `(.., U)`\n@@ -1147,17 +1142,10 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                     .map_err(|_| Unimplemented)?;\n                 nested.extend(obligations);\n \n-                // Construct the nested `T: Unsize<U>` predicate.\n-                nested.push(ensure_sufficient_stack(|| {\n-                    predicate_for_trait_def(\n-                        tcx,\n-                        obligation.param_env,\n-                        obligation.cause.clone(),\n-                        obligation.predicate.def_id(),\n-                        obligation.recursion_depth + 1,\n-                        [a_last, b_last],\n-                    )\n-                }));\n+                // Add a nested `T: Unsize<U>` predicate.\n+                let last_unsize_obligation = obligation\n+                    .with(tcx, tcx.mk_trait_ref(obligation.predicate.def_id(), [a_last, b_last]));\n+                nested.push(last_unsize_obligation);\n             }\n \n             _ => bug!(\"source: {source}, target: {target}\"),"}, {"sha": "d9b2b7dbe1645d2c14bbf47b40b00c32a52bc9d2", "filename": "compiler/rustc_trait_selection/src/traits/select/mod.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/791ce0b7b5d03649bc9014d5b0abb78f3c6f2cfd/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ce0b7b5d03649bc9014d5b0abb78f3c6f2cfd/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs?ref=791ce0b7b5d03649bc9014d5b0abb78f3c6f2cfd", "patch": "@@ -17,7 +17,7 @@ use super::project;\n use super::project::normalize_with_depth_to;\n use super::project::ProjectionTyObligation;\n use super::util;\n-use super::util::{closure_trait_ref_and_return_type, predicate_for_trait_def};\n+use super::util::closure_trait_ref_and_return_type;\n use super::wf;\n use super::{\n     ErrorReporting, ImplDerivedObligation, ImplDerivedObligationCause, Normalized, Obligation,\n@@ -2440,15 +2440,14 @@ impl<'tcx> SelectionContext<'_, 'tcx> {\n                             placeholder_ty,\n                         )\n                     });\n-                let placeholder_obligation = predicate_for_trait_def(\n+\n+                let obligation = Obligation::new(\n                     self.tcx(),\n-                    param_env,\n                     cause.clone(),\n-                    trait_def_id,\n-                    recursion_depth,\n-                    [normalized_ty],\n+                    param_env,\n+                    self.tcx().mk_trait_ref(trait_def_id, [normalized_ty]),\n                 );\n-                obligations.push(placeholder_obligation);\n+                obligations.push(obligation);\n                 obligations\n             })\n             .collect()"}, {"sha": "00c9a35225881ad82f57cf26b3bf2c2999bf9733", "filename": "compiler/rustc_trait_selection/src/traits/util.rs", "status": "modified", "additions": 2, "deletions": 29, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/791ce0b7b5d03649bc9014d5b0abb78f3c6f2cfd/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ce0b7b5d03649bc9014d5b0abb78f3c6f2cfd/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Futil.rs?ref=791ce0b7b5d03649bc9014d5b0abb78f3c6f2cfd", "patch": "@@ -1,11 +1,11 @@\n use super::NormalizeExt;\n-use super::{Obligation, ObligationCause, PredicateObligation, SelectionContext};\n+use super::{ObligationCause, PredicateObligation, SelectionContext};\n use rustc_data_structures::fx::FxHashSet;\n use rustc_errors::Diagnostic;\n use rustc_hir::def_id::DefId;\n use rustc_infer::infer::InferOk;\n+use rustc_middle::ty::SubstsRef;\n use rustc_middle::ty::{self, ImplSubject, ToPredicate, Ty, TyCtxt, TypeVisitableExt};\n-use rustc_middle::ty::{GenericArg, SubstsRef};\n use rustc_span::Span;\n use smallvec::SmallVec;\n \n@@ -218,33 +218,6 @@ pub fn impl_subject_and_oblig<'a, 'tcx>(\n     (subject, impl_obligations)\n }\n \n-pub fn predicate_for_trait_ref<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    cause: ObligationCause<'tcx>,\n-    param_env: ty::ParamEnv<'tcx>,\n-    trait_ref: ty::TraitRef<'tcx>,\n-    recursion_depth: usize,\n-) -> PredicateObligation<'tcx> {\n-    Obligation {\n-        cause,\n-        param_env,\n-        recursion_depth,\n-        predicate: ty::Binder::dummy(trait_ref).without_const().to_predicate(tcx),\n-    }\n-}\n-\n-pub fn predicate_for_trait_def<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    param_env: ty::ParamEnv<'tcx>,\n-    cause: ObligationCause<'tcx>,\n-    trait_def_id: DefId,\n-    recursion_depth: usize,\n-    params: impl IntoIterator<Item: Into<GenericArg<'tcx>>>,\n-) -> PredicateObligation<'tcx> {\n-    let trait_ref = tcx.mk_trait_ref(trait_def_id, params);\n-    predicate_for_trait_ref(tcx, cause, param_env, trait_ref, recursion_depth)\n-}\n-\n /// Casts a trait reference into a reference to one of its super\n /// traits; returns `None` if `target_trait_def_id` is not a\n /// supertrait."}, {"sha": "3b1abdcb24f8f3c18eaf7cfdf6250231b35474d7", "filename": "compiler/rustc_ty_utils/src/common_traits.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/791ce0b7b5d03649bc9014d5b0abb78f3c6f2cfd/compiler%2Frustc_ty_utils%2Fsrc%2Fcommon_traits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ce0b7b5d03649bc9014d5b0abb78f3c6f2cfd/compiler%2Frustc_ty_utils%2Fsrc%2Fcommon_traits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Fcommon_traits.rs?ref=791ce0b7b5d03649bc9014d5b0abb78f3c6f2cfd", "patch": "@@ -3,7 +3,6 @@\n use rustc_hir::lang_items::LangItem;\n use rustc_infer::infer::TyCtxtInferExt;\n use rustc_middle::ty::{self, Ty, TyCtxt};\n-use rustc_span::DUMMY_SP;\n use rustc_trait_selection::traits;\n \n fn is_copy_raw<'tcx>(tcx: TyCtxt<'tcx>, query: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> bool {\n@@ -30,7 +29,7 @@ fn is_item_raw<'tcx>(\n     let (param_env, ty) = query.into_parts();\n     let trait_def_id = tcx.require_lang_item(item, None);\n     let infcx = tcx.infer_ctxt().build();\n-    traits::type_known_to_meet_bound_modulo_regions(&infcx, param_env, ty, trait_def_id, DUMMY_SP)\n+    traits::type_known_to_meet_bound_modulo_regions(&infcx, param_env, ty, trait_def_id)\n }\n \n pub(crate) fn provide(providers: &mut ty::query::Providers) {"}, {"sha": "ed0bd58c770c7566ca2847cc00fe9162fa73977c", "filename": "src/tools/clippy/clippy_lints/src/future_not_send.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/791ce0b7b5d03649bc9014d5b0abb78f3c6f2cfd/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffuture_not_send.rs", "raw_url": "https://github.com/rust-lang/rust/raw/791ce0b7b5d03649bc9014d5b0abb78f3c6f2cfd/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffuture_not_send.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffuture_not_send.rs?ref=791ce0b7b5d03649bc9014d5b0abb78f3c6f2cfd", "patch": "@@ -9,7 +9,7 @@ use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::def_id::LocalDefId;\n use rustc_span::{sym, Span};\n use rustc_trait_selection::traits::error_reporting::suggestions::TypeErrCtxtExt;\n-use rustc_trait_selection::traits::{self, FulfillmentError};\n+use rustc_trait_selection::traits::{self, FulfillmentError, ObligationCtxt};\n \n declare_clippy_lint! {\n     /// ### What it does\n@@ -79,8 +79,10 @@ impl<'tcx> LateLintPass<'tcx> for FutureNotSend {\n                 let send_trait = cx.tcx.get_diagnostic_item(sym::Send).unwrap();\n                 let span = decl.output.span();\n                 let infcx = cx.tcx.infer_ctxt().build();\n+                let ocx = ObligationCtxt::new(&infcx);\n                 let cause = traits::ObligationCause::misc(span, fn_def_id);\n-                let send_errors = traits::fully_solve_bound(&infcx, cause, cx.param_env, ret_ty, send_trait);\n+                ocx.register_bound(cause, cx.param_env, ret_ty, send_trait);\n+                let send_errors = ocx.select_all_or_error();\n                 if !send_errors.is_empty() {\n                     span_lint_and_then(\n                         cx,"}]}