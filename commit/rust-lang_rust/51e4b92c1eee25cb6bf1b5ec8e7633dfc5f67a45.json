{"sha": "51e4b92c1eee25cb6bf1b5ec8e7633dfc5f67a45", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUxZTRiOTJjMWVlZTI1Y2I2YmYxYjVlYzhlNzYzM2RmYzVmNjdhNDU=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-05-08T12:55:55Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-05-08T12:55:55Z"}, "message": "Merge #4375\n\n4375: Cleanup toolchain handling r=matklad a=matklad\n\nbors r+\n\ud83e\udd16\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "871ebe102579fd2c8a35d2d5df4ed18b27219fd6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/871ebe102579fd2c8a35d2d5df4ed18b27219fd6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/51e4b92c1eee25cb6bf1b5ec8e7633dfc5f67a45", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJetVbbCRBK7hj4Ov3rIwAAdHIIAJxSF8NOkz1LNnkua6rgLE0Z\n6Onw+oOrz7ndmtDe99VpHkQ0Iab3Wkf2Q2lL4Y2tCWBbOfaN5uBh+rLilksrqyzQ\n+RFyRZSdZsme+wH+RdnEZ317U6dYXyYC5a64GO1nP/8Mp48qB1k+sZTh27aHY7WY\nTu0WA/UKegSyIOmyQ7QYUa2yr7u5DUweS51YN9LKNnJ49NLgHfWZCH1u6HVHA/2e\nyl9m3+x3VmmaCfrnzqDbb5ilMlSNP4gdnQ4aX6GcSS95NEJtW1Hes7tFBWtwS5rt\nL8Cq0voZTmNcEoyEm4GrMhHm29A1mG5DXRq+02+2/ZAaItgT3Ls7jlrgLPZLJVA=\n=z1yR\n-----END PGP SIGNATURE-----\n", "payload": "tree 871ebe102579fd2c8a35d2d5df4ed18b27219fd6\nparent 8295a9340c1fbda805497035054ead0b10c0d88e\nparent ecff5dc141046c5b9e40639657247a05fb9b0344\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1588942555 +0000\ncommitter GitHub <noreply@github.com> 1588942555 +0000\n\nMerge #4375\n\n4375: Cleanup toolchain handling r=matklad a=matklad\n\nbors r+\n\ud83e\udd16\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/51e4b92c1eee25cb6bf1b5ec8e7633dfc5f67a45", "html_url": "https://github.com/rust-lang/rust/commit/51e4b92c1eee25cb6bf1b5ec8e7633dfc5f67a45", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/51e4b92c1eee25cb6bf1b5ec8e7633dfc5f67a45/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8295a9340c1fbda805497035054ead0b10c0d88e", "url": "https://api.github.com/repos/rust-lang/rust/commits/8295a9340c1fbda805497035054ead0b10c0d88e", "html_url": "https://github.com/rust-lang/rust/commit/8295a9340c1fbda805497035054ead0b10c0d88e"}, {"sha": "ecff5dc141046c5b9e40639657247a05fb9b0344", "url": "https://api.github.com/repos/rust-lang/rust/commits/ecff5dc141046c5b9e40639657247a05fb9b0344", "html_url": "https://github.com/rust-lang/rust/commit/ecff5dc141046c5b9e40639657247a05fb9b0344"}], "stats": {"total": 249, "additions": 108, "deletions": 141}, "files": [{"sha": "41855f22e85d62d6d8c8d282262e6d84c68f16be", "filename": "Cargo.lock", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/51e4b92c1eee25cb6bf1b5ec8e7633dfc5f67a45/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/51e4b92c1eee25cb6bf1b5ec8e7633dfc5f67a45/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=51e4b92c1eee25cb6bf1b5ec8e7633dfc5f67a45", "patch": "@@ -957,14 +957,6 @@ dependencies = [\n  \"test_utils\",\n ]\n \n-[[package]]\n-name = \"ra_env\"\n-version = \"0.1.0\"\n-dependencies = [\n- \"anyhow\",\n- \"home\",\n-]\n-\n [[package]]\n name = \"ra_flycheck\"\n version = \"0.1.0\"\n@@ -975,7 +967,7 @@ dependencies = [\n  \"jod-thread\",\n  \"log\",\n  \"lsp-types\",\n- \"ra_env\",\n+ \"ra_toolchain\",\n  \"serde_json\",\n ]\n \n@@ -1180,8 +1172,8 @@ dependencies = [\n  \"ra_arena\",\n  \"ra_cfg\",\n  \"ra_db\",\n- \"ra_env\",\n  \"ra_proc_macro\",\n+ \"ra_toolchain\",\n  \"rustc-hash\",\n  \"serde\",\n  \"serde_json\",\n@@ -1213,6 +1205,13 @@ dependencies = [\n  \"text-size\",\n ]\n \n+[[package]]\n+name = \"ra_toolchain\"\n+version = \"0.1.0\"\n+dependencies = [\n+ \"home\",\n+]\n+\n [[package]]\n name = \"ra_tt\"\n version = \"0.1.0\""}, {"sha": "413da19827e67a1944a00b6b86346362148c619e", "filename": "crates/ra_env/src/lib.rs", "status": "removed", "additions": 0, "deletions": 66, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/8295a9340c1fbda805497035054ead0b10c0d88e/crates%2Fra_env%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8295a9340c1fbda805497035054ead0b10c0d88e/crates%2Fra_env%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_env%2Fsrc%2Flib.rs?ref=8295a9340c1fbda805497035054ead0b10c0d88e", "patch": "@@ -1,66 +0,0 @@\n-//! This crate contains a single public function\n-//! [`get_path_for_executable`](fn.get_path_for_executable.html).\n-//! See docs there for more information.\n-\n-use anyhow::{bail, Result};\n-use std::env;\n-use std::path::{Path, PathBuf};\n-use std::process::Command;\n-\n-/// Return a `PathBuf` to use for the given executable.\n-///\n-/// E.g., `get_path_for_executable(\"cargo\")` may return just `cargo` if that\n-/// gives a valid Cargo executable; or it may return a full path to a valid\n-/// Cargo.\n-pub fn get_path_for_executable(executable_name: impl AsRef<str>) -> Result<PathBuf> {\n-    // The current implementation checks three places for an executable to use:\n-    // 1) Appropriate environment variable (erroring if this is set but not a usable executable)\n-    //      example: for cargo, this checks $CARGO environment variable; for rustc, $RUSTC; etc\n-    // 2) `<executable_name>`\n-    //      example: for cargo, this tries just `cargo`, which will succeed if `cargo` is on the $PATH\n-    // 3) `~/.cargo/bin/<executable_name>`\n-    //      example: for cargo, this tries ~/.cargo/bin/cargo\n-    //      It seems that this is a reasonable place to try for cargo, rustc, and rustup\n-    let executable_name = executable_name.as_ref();\n-    let env_var = executable_name.to_ascii_uppercase();\n-    if let Ok(path) = env::var(&env_var) {\n-        if is_valid_executable(&path) {\n-            Ok(path.into())\n-        } else {\n-            bail!(\n-                \"`{}` environment variable points to something that's not a valid executable\",\n-                env_var\n-            )\n-        }\n-    } else {\n-        if is_valid_executable(executable_name) {\n-            return Ok(executable_name.into());\n-        }\n-        if let Some(mut path) = ::home::home_dir() {\n-            path.push(\".cargo\");\n-            path.push(\"bin\");\n-            path.push(executable_name);\n-            if is_valid_executable(&path) {\n-                return Ok(path);\n-            }\n-        }\n-        // This error message may also be caused by $PATH or $CARGO/$RUSTC/etc not being set correctly\n-        // for VSCode, even if they are set correctly in a terminal.\n-        // On macOS in particular, launching VSCode from terminal with `code <dirname>` causes VSCode\n-        // to inherit environment variables including $PATH, $CARGO, $RUSTC, etc from that terminal;\n-        // but launching VSCode from Dock does not inherit environment variables from a terminal.\n-        // For more discussion, see #3118.\n-        bail!(\n-            \"Failed to find `{}` executable. Make sure `{}` is in `$PATH`, or set `${}` to point to a valid executable.\",\n-            executable_name, executable_name, env_var\n-        )\n-    }\n-}\n-\n-/// Does the given `Path` point to a usable executable?\n-///\n-/// (assumes the executable takes a `--version` switch and writes to stdout,\n-/// which is true for `cargo`, `rustc`, and `rustup`)\n-fn is_valid_executable(p: impl AsRef<Path>) -> bool {\n-    Command::new(p.as_ref()).arg(\"--version\").output().is_ok()\n-}"}, {"sha": "03e55714844b1bacc82da7a37c7c80633e3367e4", "filename": "crates/ra_flycheck/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/51e4b92c1eee25cb6bf1b5ec8e7633dfc5f67a45/crates%2Fra_flycheck%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/51e4b92c1eee25cb6bf1b5ec8e7633dfc5f67a45/crates%2Fra_flycheck%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_flycheck%2FCargo.toml?ref=51e4b92c1eee25cb6bf1b5ec8e7633dfc5f67a45", "patch": "@@ -14,7 +14,7 @@ log = \"0.4.8\"\n cargo_metadata = \"0.9.1\"\n serde_json = \"1.0.48\"\n jod-thread = \"0.1.1\"\n-ra_env = { path = \"../ra_env\" }\n+ra_toolchain = { path = \"../ra_toolchain\" }\n \n [dev-dependencies]\n insta = \"0.16.0\""}, {"sha": "68dcee2851d3191d08ddac39b0eb365f4f946a50", "filename": "crates/ra_flycheck/src/lib.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/51e4b92c1eee25cb6bf1b5ec8e7633dfc5f67a45/crates%2Fra_flycheck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51e4b92c1eee25cb6bf1b5ec8e7633dfc5f67a45/crates%2Fra_flycheck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_flycheck%2Fsrc%2Flib.rs?ref=51e4b92c1eee25cb6bf1b5ec8e7633dfc5f67a45", "patch": "@@ -16,7 +16,6 @@ use lsp_types::{\n     CodeAction, CodeActionOrCommand, Diagnostic, Url, WorkDoneProgress, WorkDoneProgressBegin,\n     WorkDoneProgressEnd, WorkDoneProgressReport,\n };\n-use ra_env::get_path_for_executable;\n \n use crate::conv::{map_rust_diagnostic_to_lsp, MappedRustDiagnostic};\n \n@@ -216,10 +215,10 @@ impl FlycheckThread {\n \n         let mut cmd = match &self.config {\n             FlycheckConfig::CargoCommand { command, all_targets, all_features, extra_args } => {\n-                let mut cmd = Command::new(get_path_for_executable(\"cargo\").unwrap());\n+                let mut cmd = Command::new(ra_toolchain::cargo());\n                 cmd.arg(command);\n-                cmd.args(&[\"--workspace\", \"--message-format=json\", \"--manifest-path\"]);\n-                cmd.arg(self.workspace_root.join(\"Cargo.toml\"));\n+                cmd.args(&[\"--workspace\", \"--message-format=json\", \"--manifest-path\"])\n+                    .arg(self.workspace_root.join(\"Cargo.toml\"));\n                 if *all_targets {\n                     cmd.arg(\"--all-targets\");\n                 }"}, {"sha": "a32a5daabde3ee180ce7c1e065e577b03b188013", "filename": "crates/ra_project_model/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/51e4b92c1eee25cb6bf1b5ec8e7633dfc5f67a45/crates%2Fra_project_model%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/51e4b92c1eee25cb6bf1b5ec8e7633dfc5f67a45/crates%2Fra_project_model%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_project_model%2FCargo.toml?ref=51e4b92c1eee25cb6bf1b5ec8e7633dfc5f67a45", "patch": "@@ -16,7 +16,7 @@ cargo_metadata = \"0.9.1\"\n ra_arena = { path = \"../ra_arena\" }\n ra_cfg = { path = \"../ra_cfg\" }\n ra_db = { path = \"../ra_db\" }\n-ra_env = { path = \"../ra_env\" }\n+ra_toolchain = { path = \"../ra_toolchain\" }\n ra_proc_macro =  { path = \"../ra_proc_macro\" }\n \n serde = { version = \"1.0.106\", features = [\"derive\"] }"}, {"sha": "082af4f9699d06b5ec86c9d50d9a191b0d25d7fe", "filename": "crates/ra_project_model/src/cargo_workspace.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/51e4b92c1eee25cb6bf1b5ec8e7633dfc5f67a45/crates%2Fra_project_model%2Fsrc%2Fcargo_workspace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51e4b92c1eee25cb6bf1b5ec8e7633dfc5f67a45/crates%2Fra_project_model%2Fsrc%2Fcargo_workspace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_project_model%2Fsrc%2Fcargo_workspace.rs?ref=51e4b92c1eee25cb6bf1b5ec8e7633dfc5f67a45", "patch": "@@ -11,7 +11,6 @@ use anyhow::{Context, Result};\n use cargo_metadata::{BuildScript, CargoOpt, Message, MetadataCommand, PackageId};\n use ra_arena::{Arena, Idx};\n use ra_db::Edition;\n-use ra_env::get_path_for_executable;\n use rustc_hash::FxHashMap;\n \n /// `CargoWorkspace` represents the logical structure of, well, a Cargo\n@@ -147,7 +146,7 @@ impl CargoWorkspace {\n         cargo_features: &CargoConfig,\n     ) -> Result<CargoWorkspace> {\n         let mut meta = MetadataCommand::new();\n-        meta.cargo_path(get_path_for_executable(\"cargo\")?);\n+        meta.cargo_path(ra_toolchain::cargo());\n         meta.manifest_path(cargo_toml);\n         if cargo_features.all_features {\n             meta.features(CargoOpt::AllFeatures);\n@@ -289,7 +288,7 @@ pub fn load_extern_resources(\n     cargo_toml: &Path,\n     cargo_features: &CargoConfig,\n ) -> Result<ExternResources> {\n-    let mut cmd = Command::new(get_path_for_executable(\"cargo\")?);\n+    let mut cmd = Command::new(ra_toolchain::cargo());\n     cmd.args(&[\"check\", \"--message-format=json\", \"--manifest-path\"]).arg(cargo_toml);\n     if cargo_features.all_features {\n         cmd.arg(\"--all-features\");"}, {"sha": "5a0a87ed7d44428df5655d23ba62427534e8b670", "filename": "crates/ra_project_model/src/lib.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/51e4b92c1eee25cb6bf1b5ec8e7633dfc5f67a45/crates%2Fra_project_model%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51e4b92c1eee25cb6bf1b5ec8e7633dfc5f67a45/crates%2Fra_project_model%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_project_model%2Fsrc%2Flib.rs?ref=51e4b92c1eee25cb6bf1b5ec8e7633dfc5f67a45", "patch": "@@ -8,13 +8,12 @@ use std::{\n     fs::{read_dir, File, ReadDir},\n     io::{self, BufReader},\n     path::{Path, PathBuf},\n-    process::Command,\n+    process::{Command, Output},\n };\n \n use anyhow::{bail, Context, Result};\n use ra_cfg::CfgOptions;\n use ra_db::{CrateGraph, CrateName, Edition, Env, ExternSource, ExternSourceId, FileId};\n-use ra_env::get_path_for_executable;\n use rustc_hash::FxHashMap;\n use serde_json::from_reader;\n \n@@ -568,25 +567,18 @@ pub fn get_rustc_cfg_options(target: Option<&String>) -> CfgOptions {\n         }\n     }\n \n-    match (|| -> Result<String> {\n+    let rustc_cfgs = || -> Result<String> {\n         // `cfg(test)` and `cfg(debug_assertion)` are handled outside, so we suppress them here.\n-        let mut cmd = Command::new(get_path_for_executable(\"rustc\")?);\n+        let mut cmd = Command::new(ra_toolchain::rustc());\n         cmd.args(&[\"--print\", \"cfg\", \"-O\"]);\n         if let Some(target) = target {\n             cmd.args(&[\"--target\", target.as_str()]);\n         }\n-        let output = cmd.output().context(\"Failed to get output from rustc --print cfg -O\")?;\n-        if !output.status.success() {\n-            bail!(\n-                \"rustc --print cfg -O exited with exit code ({})\",\n-                output\n-                    .status\n-                    .code()\n-                    .map_or(String::from(\"no exit code\"), |code| format!(\"{}\", code))\n-            );\n-        }\n+        let output = output(cmd)?;\n         Ok(String::from_utf8(output.stdout)?)\n-    })() {\n+    }();\n+\n+    match rustc_cfgs {\n         Ok(rustc_cfgs) => {\n             for line in rustc_cfgs.lines() {\n                 match line.find('=') {\n@@ -599,8 +591,16 @@ pub fn get_rustc_cfg_options(target: Option<&String>) -> CfgOptions {\n                 }\n             }\n         }\n-        Err(e) => log::error!(\"failed to get rustc cfgs: {}\", e),\n+        Err(e) => log::error!(\"failed to get rustc cfgs: {:#}\", e),\n     }\n \n     cfg_options\n }\n+\n+fn output(mut cmd: Command) -> Result<Output> {\n+    let output = cmd.output().with_context(|| format!(\"{:?} failed\", cmd))?;\n+    if !output.status.success() {\n+        bail!(\"{:?} failed, {}\", cmd, output.status)\n+    }\n+    Ok(output)\n+}"}, {"sha": "a8a196e64c963f68435babe2ec8d703f9b292032", "filename": "crates/ra_project_model/src/sysroot.rs", "status": "modified", "additions": 11, "deletions": 38, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/51e4b92c1eee25cb6bf1b5ec8e7633dfc5f67a45/crates%2Fra_project_model%2Fsrc%2Fsysroot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51e4b92c1eee25cb6bf1b5ec8e7633dfc5f67a45/crates%2Fra_project_model%2Fsrc%2Fsysroot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_project_model%2Fsrc%2Fsysroot.rs?ref=51e4b92c1eee25cb6bf1b5ec8e7633dfc5f67a45", "patch": "@@ -1,14 +1,15 @@\n //! FIXME: write short doc here\n \n-use anyhow::{bail, Context, Result};\n use std::{\n     env, ops,\n     path::{Path, PathBuf},\n-    process::{Command, Output},\n+    process::Command,\n };\n \n+use anyhow::{bail, Result};\n use ra_arena::{Arena, Idx};\n-use ra_env::get_path_for_executable;\n+\n+use crate::output;\n \n #[derive(Default, Debug, Clone)]\n pub struct Sysroot {\n@@ -85,50 +86,22 @@ impl Sysroot {\n     }\n }\n \n-fn create_command_text(program: &str, args: &[&str]) -> String {\n-    format!(\"{} {}\", program, args.join(\" \"))\n-}\n-\n-fn run_command_in_cargo_dir(\n-    cargo_toml: impl AsRef<Path>,\n-    program: impl AsRef<Path>,\n-    args: &[&str],\n-) -> Result<Output> {\n-    let program = program.as_ref().as_os_str().to_str().expect(\"Invalid Unicode in path\");\n-    let output = Command::new(program)\n-        .current_dir(cargo_toml.as_ref().parent().unwrap())\n-        .args(args)\n-        .output()\n-        .context(format!(\"{} failed\", create_command_text(program, args)))?;\n-    if !output.status.success() {\n-        match output.status.code() {\n-            Some(code) => bail!(\n-                \"failed to run the command: '{}' exited with code {}\",\n-                create_command_text(program, args),\n-                code\n-            ),\n-            None => bail!(\n-                \"failed to run the command: '{}' terminated by signal\",\n-                create_command_text(program, args)\n-            ),\n-        };\n-    }\n-    Ok(output)\n-}\n-\n fn get_or_install_rust_src(cargo_toml: &Path) -> Result<PathBuf> {\n     if let Ok(path) = env::var(\"RUST_SRC_PATH\") {\n         return Ok(path.into());\n     }\n-    let rustc = get_path_for_executable(\"rustc\")?;\n-    let rustc_output = run_command_in_cargo_dir(cargo_toml, &rustc, &[\"--print\", \"sysroot\"])?;\n+    let current_dir = cargo_toml.parent().unwrap();\n+    let mut rustc = Command::new(ra_toolchain::rustc());\n+    rustc.current_dir(current_dir).args(&[\"--print\", \"sysroot\"]);\n+    let rustc_output = output(rustc)?;\n     let stdout = String::from_utf8(rustc_output.stdout)?;\n     let sysroot_path = Path::new(stdout.trim());\n     let src_path = sysroot_path.join(\"lib/rustlib/src/rust/src\");\n \n     if !src_path.exists() {\n-        let rustup = get_path_for_executable(\"rustup\")?;\n-        run_command_in_cargo_dir(cargo_toml, &rustup, &[\"component\", \"add\", \"rust-src\"])?;\n+        let mut rustup = Command::new(ra_toolchain::rustup());\n+        rustup.current_dir(current_dir).args(&[\"component\", \"add\", \"rust-src\"]);\n+        let _output = output(rustup)?;\n     }\n     if !src_path.exists() {\n         bail!("}, {"sha": "1873fbe16783f8d33523f6d32399137c72e89e01", "filename": "crates/ra_toolchain/Cargo.toml", "status": "renamed", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/51e4b92c1eee25cb6bf1b5ec8e7633dfc5f67a45/crates%2Fra_toolchain%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/51e4b92c1eee25cb6bf1b5ec8e7633dfc5f67a45/crates%2Fra_toolchain%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_toolchain%2FCargo.toml?ref=51e4b92c1eee25cb6bf1b5ec8e7633dfc5f67a45", "patch": "@@ -1,9 +1,8 @@\n [package]\n edition = \"2018\"\n-name = \"ra_env\"\n+name = \"ra_toolchain\"\n version = \"0.1.0\"\n authors = [\"rust-analyzer developers\"]\n \n [dependencies]\n-anyhow = \"1.0.26\"\n home = \"0.5.3\"", "previous_filename": "crates/ra_env/Cargo.toml"}, {"sha": "3c307a0eace45e4be22bdb2b2eb8de6a91f2695c", "filename": "crates/ra_toolchain/src/lib.rs", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/51e4b92c1eee25cb6bf1b5ec8e7633dfc5f67a45/crates%2Fra_toolchain%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51e4b92c1eee25cb6bf1b5ec8e7633dfc5f67a45/crates%2Fra_toolchain%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_toolchain%2Fsrc%2Flib.rs?ref=51e4b92c1eee25cb6bf1b5ec8e7633dfc5f67a45", "patch": "@@ -0,0 +1,64 @@\n+//! This crate contains a single public function\n+//! [`get_path_for_executable`](fn.get_path_for_executable.html).\n+//! See docs there for more information.\n+use std::{env, iter, path::PathBuf};\n+\n+pub fn cargo() -> PathBuf {\n+    get_path_for_executable(\"cargo\")\n+}\n+\n+pub fn rustc() -> PathBuf {\n+    get_path_for_executable(\"rustc\")\n+}\n+\n+pub fn rustup() -> PathBuf {\n+    get_path_for_executable(\"rustup\")\n+}\n+\n+/// Return a `PathBuf` to use for the given executable.\n+///\n+/// E.g., `get_path_for_executable(\"cargo\")` may return just `cargo` if that\n+/// gives a valid Cargo executable; or it may return a full path to a valid\n+/// Cargo.\n+fn get_path_for_executable(executable_name: &'static str) -> PathBuf {\n+    // The current implementation checks three places for an executable to use:\n+    // 1) Appropriate environment variable (erroring if this is set but not a usable executable)\n+    //      example: for cargo, this checks $CARGO environment variable; for rustc, $RUSTC; etc\n+    // 2) `<executable_name>`\n+    //      example: for cargo, this tries just `cargo`, which will succeed if `cargo` is on the $PATH\n+    // 3) `~/.cargo/bin/<executable_name>`\n+    //      example: for cargo, this tries ~/.cargo/bin/cargo\n+    //      It seems that this is a reasonable place to try for cargo, rustc, and rustup\n+    let env_var = executable_name.to_ascii_uppercase();\n+    if let Some(path) = env::var_os(&env_var) {\n+        return path.into();\n+    }\n+\n+    if lookup_in_path(executable_name) {\n+        return executable_name.into();\n+    }\n+\n+    if let Some(mut path) = home::home_dir() {\n+        path.push(\".cargo\");\n+        path.push(\"bin\");\n+        path.push(executable_name);\n+        if path.is_file() {\n+            return path;\n+        }\n+    }\n+    executable_name.into()\n+}\n+\n+fn lookup_in_path(exec: &str) -> bool {\n+    let paths = env::var_os(\"PATH\").unwrap_or_default();\n+    let mut candidates = env::split_paths(&paths).flat_map(|path| {\n+        let candidate = path.join(&exec);\n+        let with_exe = if env::consts::EXE_EXTENSION == \"\" {\n+            None\n+        } else {\n+            Some(candidate.with_extension(env::consts::EXE_EXTENSION))\n+        };\n+        iter::once(candidate).chain(with_exe)\n+    });\n+    candidates.any(|it| it.is_file())\n+}"}]}