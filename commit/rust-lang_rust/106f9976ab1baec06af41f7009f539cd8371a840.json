{"sha": "106f9976ab1baec06af41f7009f539cd8371a840", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEwNmY5OTc2YWIxYmFlYzA2YWY0MWY3MDA5ZjUzOWNkODM3MWE4NDA=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-11-02T16:56:09Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-11-02T16:56:09Z"}, "message": "rustc: Implement typechecking, exhaustiveness checking, and borrow checking for pattern matching of tuple structs. r=nmatsakis\n\nConflicts:\n\n\tsrc/rustc/middle/typeck/check/alt.rs", "tree": {"sha": "8c9f1afbbba04dc89e519f785d8175b1b66964f7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8c9f1afbbba04dc89e519f785d8175b1b66964f7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/106f9976ab1baec06af41f7009f539cd8371a840", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/106f9976ab1baec06af41f7009f539cd8371a840", "html_url": "https://github.com/rust-lang/rust/commit/106f9976ab1baec06af41f7009f539cd8371a840", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/106f9976ab1baec06af41f7009f539cd8371a840/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b62844e755d36fddff303c0639303bb0f56c5d41", "url": "https://api.github.com/repos/rust-lang/rust/commits/b62844e755d36fddff303c0639303bb0f56c5d41", "html_url": "https://github.com/rust-lang/rust/commit/b62844e755d36fddff303c0639303bb0f56c5d41"}], "stats": {"total": 248, "additions": 177, "deletions": 71}, "files": [{"sha": "ccc2ca9888abd8592ac0628fe07bd135c005d3f5", "filename": "src/rustc/middle/borrowck.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/106f9976ab1baec06af41f7009f539cd8371a840/src%2Frustc%2Fmiddle%2Fborrowck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/106f9976ab1baec06af41f7009f539cd8371a840/src%2Frustc%2Fmiddle%2Fborrowck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fborrowck.rs?ref=106f9976ab1baec06af41f7009f539cd8371a840", "patch": "@@ -594,7 +594,7 @@ impl borrowck_ctxt {\n // mutable structure.\n fn inherent_mutability(ck: comp_kind) -> mutability {\n     match ck {\n-      comp_tuple | comp_variant(_)        => m_imm,\n-      comp_field(_, m) | comp_index(_, m) => m\n+      comp_tuple | comp_anon_field | comp_variant(_) => m_imm,\n+      comp_field(_, m) | comp_index(_, m)            => m\n     }\n }"}, {"sha": "b3023497220736375a69b6338b689a35f13b83d9", "filename": "src/rustc/middle/borrowck/loan.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/106f9976ab1baec06af41f7009f539cd8371a840/src%2Frustc%2Fmiddle%2Fborrowck%2Floan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/106f9976ab1baec06af41f7009f539cd8371a840/src%2Frustc%2Fmiddle%2Fborrowck%2Floan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fborrowck%2Floan.rs?ref=106f9976ab1baec06af41f7009f539cd8371a840", "patch": "@@ -116,7 +116,8 @@ impl LoanContext {\n             // overwritten and the component along with it.\n             self.loan_stable_comp(cmt, cmt_base, req_mutbl, m)\n           }\n-          cat_comp(cmt_base, comp_tuple) => {\n+          cat_comp(cmt_base, comp_tuple) |\n+          cat_comp(cmt_base, comp_anon_field) => {\n             // As above.\n             self.loan_stable_comp(cmt, cmt_base, req_mutbl, m_imm)\n           }"}, {"sha": "c27ceca055fdcd91cb39e15a403e6e8979a29f38", "filename": "src/rustc/middle/borrowck/preserve.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/106f9976ab1baec06af41f7009f539cd8371a840/src%2Frustc%2Fmiddle%2Fborrowck%2Fpreserve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/106f9976ab1baec06af41f7009f539cd8371a840/src%2Frustc%2Fmiddle%2Fborrowck%2Fpreserve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fborrowck%2Fpreserve.rs?ref=106f9976ab1baec06af41f7009f539cd8371a840", "patch": "@@ -119,7 +119,8 @@ priv impl &preserve_ctxt {\n           }\n           cat_comp(cmt_base, comp_field(*)) |\n           cat_comp(cmt_base, comp_index(*)) |\n-          cat_comp(cmt_base, comp_tuple) => {\n+          cat_comp(cmt_base, comp_tuple) |\n+          cat_comp(cmt_base, comp_anon_field) => {\n             // Most embedded components: if the base is stable, the\n             // type never changes.\n             self.preserve(cmt_base)"}, {"sha": "5b35ed98a837d0ea8fea3d29bf470060560187af", "filename": "src/rustc/middle/check_alt.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/106f9976ab1baec06af41f7009f539cd8371a840/src%2Frustc%2Fmiddle%2Fcheck_alt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/106f9976ab1baec06af41f7009f539cd8371a840/src%2Frustc%2Fmiddle%2Fcheck_alt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fcheck_alt.rs?ref=106f9976ab1baec06af41f7009f539cd8371a840", "patch": "@@ -355,6 +355,15 @@ fn specialize(tcx: ty::ctxt, r: ~[@pat], ctor_id: ctor, arity: uint,\n             Some(vec::append(args, vec::tail(r)))\n           }\n           def_variant(_, _) => None,\n+          def_class(*) => {\n+            // XXX: Is this right? --pcw\n+            let new_args;\n+            match args {\n+              Some(args) => new_args = args,\n+              None => new_args = vec::from_elem(arity, wild())\n+            }\n+            Some(vec::append(new_args, vec::tail(r)))\n+          }\n           _ => None\n         }\n       }"}, {"sha": "55bf41b573eb57d493ba960866770da7a34d5160", "filename": "src/rustc/middle/mem_categorization.rs", "status": "modified", "additions": 38, "deletions": 10, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/106f9976ab1baec06af41f7009f539cd8371a840/src%2Frustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/106f9976ab1baec06af41f7009f539cd8371a840/src%2Frustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fmem_categorization.rs?ref=106f9976ab1baec06af41f7009f539cd8371a840", "patch": "@@ -162,6 +162,8 @@ impl ptr_kind : cmp::Eq {\n // structure accessible without a dereference\":\n enum comp_kind {\n     comp_tuple,                  // elt in a tuple\n+    comp_anon_field,             // anonymous field (in e.g.\n+                                 // struct Foo(int, int);\n     comp_variant(ast::def_id),   // internals to a variant of given enum\n     comp_field(ast::ident,       // name of field\n                ast::mutability), // declared mutability of field\n@@ -178,6 +180,12 @@ impl comp_kind : cmp::Eq {\n                     _ => false\n                 }\n             }\n+            comp_anon_field => {\n+                match (*other) {\n+                    comp_anon_field => true,\n+                    _ => false\n+                }\n+            }\n             comp_variant(e0a) => {\n                 match (*other) {\n                     comp_variant(e0b) => e0a == e0b,\n@@ -775,6 +783,14 @@ impl &mem_categorization_ctxt {\n           ty: self.tcx.ty(elt)}\n     }\n \n+    fn cat_anon_struct_field<N: ast_node>(elt: N, cmt: cmt) -> cmt {\n+        @{id: elt.id(), span: elt.span(),\n+          cat: cat_comp(cmt, comp_anon_field),\n+          lp: cmt.lp.map(|l| @lp_comp(*l, comp_anon_field)),\n+          mutbl: cmt.mutbl, // imm iff in an immutable context\n+          ty: self.tcx.ty(elt)}\n+    }\n+\n     fn cat_method_ref(expr: @ast::expr, expr_ty: ty::t) -> cmt {\n         @{id:expr.id, span:expr.span,\n           cat:cat_special(sk_method), lp:None,\n@@ -834,16 +850,26 @@ impl &mem_categorization_ctxt {\n             // variant(*)\n           }\n           ast::pat_enum(_, Some(subpats)) => {\n-            // variant(x, y, z)\n-            let enum_did = match self.tcx.def_map.find(pat.id) {\n-              Some(ast::def_variant(enum_did, _)) => enum_did,\n-              e => tcx.sess.span_bug(pat.span,\n-                                     fmt!(\"resolved to %?, not variant\", e))\n-            };\n-\n-            for subpats.each |subpat| {\n-                let subcmt = self.cat_variant(*subpat, enum_did, cmt);\n-                self.cat_pattern(subcmt, *subpat, op);\n+            match self.tcx.def_map.find(pat.id) {\n+                Some(ast::def_variant(enum_did, _)) => {\n+                    // variant(x, y, z)\n+                    for subpats.each |subpat| {\n+                        let subcmt = self.cat_variant(*subpat, enum_did, cmt);\n+                        self.cat_pattern(subcmt, *subpat, op);\n+                    }\n+                }\n+                Some(ast::def_class(*)) => {\n+                    for subpats.each |subpat| {\n+                        let cmt_field = self.cat_anon_struct_field(*subpat,\n+                                                                   cmt);\n+                        self.cat_pattern(cmt_field, *subpat, op);\n+                    }\n+                }\n+                _ => {\n+                    self.tcx.sess.span_bug(\n+                        pat.span,\n+                        ~\"enum pattern didn't resolve to enum or struct\");\n+                }\n             }\n           }\n \n@@ -934,6 +960,7 @@ impl &mem_categorization_ctxt {\n           comp_field(fld, _) => self.tcx.sess.str_of(fld),\n           comp_index(*) => ~\"[]\",\n           comp_tuple => ~\"()\",\n+          comp_anon_field => ~\"<anonymous field>\",\n           comp_variant(_) => ~\"<enum>\"\n         }\n     }\n@@ -986,6 +1013,7 @@ impl &mem_categorization_ctxt {\n           }\n           cat_comp(_, comp_field(*)) => mut_str + ~\" field\",\n           cat_comp(_, comp_tuple) => ~\"tuple content\",\n+          cat_comp(_, comp_anon_field) => ~\"anonymous field\",\n           cat_comp(_, comp_variant(_)) => ~\"enum content\",\n           cat_comp(_, comp_index(t, _)) => {\n             match ty::get(t).sty {"}, {"sha": "a979c0d7b577b40d431b4b61c622ba1f7c67ccf7", "filename": "src/rustc/middle/resolve.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/106f9976ab1baec06af41f7009f539cd8371a840/src%2Frustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/106f9976ab1baec06af41f7009f539cd8371a840/src%2Frustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fresolve.rs?ref=106f9976ab1baec06af41f7009f539cd8371a840", "patch": "@@ -4286,9 +4286,10 @@ impl Resolver {\n                 }\n \n                 pat_ident(_, path, _) | pat_enum(path, _) => {\n-                    // These two must be enum variants.\n+                    // These two must be enum variants or structs.\n                     match self.resolve_path(path, ValueNS, false, visitor) {\n-                        Some(def @ def_variant(*)) => {\n+                        Some(def @ def_variant(*)) |\n+                                Some(def @ def_class(*)) => {\n                             self.record_def(pattern.id, def);\n                         }\n                         Some(_) => {"}, {"sha": "65f77cefd02bb608b7f699b83dd9c5ca5cdbc8d0", "filename": "src/rustc/middle/ty.rs", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/106f9976ab1baec06af41f7009f539cd8371a840/src%2Frustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/106f9976ab1baec06af41f7009f539cd8371a840/src%2Frustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fty.rs?ref=106f9976ab1baec06af41f7009f539cd8371a840", "patch": "@@ -3554,6 +3554,29 @@ fn ty_to_def_id(ty: t) -> Option<ast::def_id> {\n     }\n }\n \n+/// Returns the def ID of the constructor for the given tuple-like struct, or\n+/// None if the struct is not tuple-like. Fails if the given def ID does not\n+/// refer to a struct at all.\n+fn struct_ctor_id(cx: ctxt, struct_did: ast::def_id) -> Option<ast::def_id> {\n+    if struct_did.crate != ast::local_crate {\n+        // XXX: Cross-crate functionality.\n+        cx.sess.unimpl(~\"constructor ID of cross-crate tuple structs\");\n+    }\n+\n+    match cx.items.find(struct_did.node) {\n+        Some(ast_map::node_item(item, _)) => {\n+            match item.node {\n+                ast::item_class(struct_def, _) => {\n+                    struct_def.ctor_id.map(|ctor_id|\n+                        ast_util::local_def(*ctor_id))\n+                }\n+                _ => cx.sess.bug(~\"called struct_ctor_id on non-struct\")\n+            }\n+        }\n+        _ => cx.sess.bug(~\"called struct_ctor_id on non-struct\")\n+    }\n+}\n+\n // Enum information\n type variant_info = @{args: ~[t], ctor_ty: t, name: ast::ident,\n                       id: ast::def_id, disr_val: int};"}, {"sha": "5a62ad0461dc6cf602dafa4fe893422a861f22fb", "filename": "src/rustc/middle/typeck/check/alt.rs", "status": "modified", "additions": 87, "deletions": 55, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/106f9976ab1baec06af41f7009f539cd8371a840/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Falt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/106f9976ab1baec06af41f7009f539cd8371a840/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Falt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Falt.rs?ref=106f9976ab1baec06af41f7009f539cd8371a840", "patch": "@@ -123,70 +123,102 @@ fn check_pat_variant(pcx: pat_ctxt, pat: @ast::pat, path: @ast::path,\n     let fcx = pcx.fcx;\n     let tcx = pcx.fcx.ccx.tcx;\n \n-    // Lookup the enum and variant def ids:\n-    let v_def = lookup_def(pcx.fcx, path.span, pat.id);\n-    let v_def_ids = ast_util::variant_def_ids(v_def);\n-\n-    // Assign the pattern the type of the *enum*, not the variant.\n-    let enum_tpt = ty::lookup_item_type(tcx, v_def_ids.enm);\n-    instantiate_path(pcx.fcx, path, enum_tpt, pat.span, pat.id,\n-                     pcx.block_region);\n+    let arg_types, kind_name;\n \n     // structure_of requires type variables to be resolved.\n     // So when we pass in <expected>, it's an error if it\n     // contains type variables.\n \n-    // Take the enum type params out of `expected`.\n+    // Check to see whether this is an enum or a struct.\n     match structure_of(pcx.fcx, pat.span, expected) {\n-      ty::ty_enum(_, ref expected_substs) => {\n-        // check that the type of the value being matched is a subtype\n-        // of the type of the pattern:\n-        let pat_ty = fcx.node_ty(pat.id);\n-        demand::suptype(fcx, pat.span, pat_ty, expected);\n-\n-        // Get the expected types of the arguments.\n-        let arg_types = {\n-            let vinfo =\n-                ty::enum_variant_with_id(\n-                    tcx, v_def_ids.enm, v_def_ids.var);\n-            vinfo.args.map(|t| { ty::subst(tcx, expected_substs, *t) })\n-        };\n-        let arg_len = arg_types.len(), subpats_len = match subpats {\n-            None => arg_len,\n-            Some(ps) => ps.len()\n-        };\n-        if arg_len > 0 {\n-            // N-ary variant.\n-            if arg_len != subpats_len {\n-                let s = fmt!(\"this pattern has %u field%s, but the \\\n-                              corresponding variant has %u field%s\",\n-                             subpats_len,\n-                             if subpats_len == 1u { ~\"\" } else { ~\"s\" },\n-                             arg_len,\n-                             if arg_len == 1u { ~\"\" } else { ~\"s\" });\n-                tcx.sess.span_fatal(pat.span, s);\n-            }\n-\n-            do subpats.iter() |pats| {\n-                for vec::each2(*pats, arg_types) |subpat, arg_ty| {\n-                  check_pat(pcx, *subpat, *arg_ty);\n-                }\n+        ty::ty_enum(_, ref expected_substs) => {\n+            // Lookup the enum and variant def ids:\n+            let v_def = lookup_def(pcx.fcx, path.span, pat.id);\n+            let v_def_ids = ast_util::variant_def_ids(v_def);\n+\n+            // Assign the pattern the type of the *enum*, not the variant.\n+            let enum_tpt = ty::lookup_item_type(tcx, v_def_ids.enm);\n+            instantiate_path(pcx.fcx, path, enum_tpt, pat.span, pat.id,\n+                             pcx.block_region);\n+\n+            // check that the type of the value being matched is a subtype\n+            // of the type of the pattern:\n+            let pat_ty = fcx.node_ty(pat.id);\n+            demand::suptype(fcx, pat.span, pat_ty, expected);\n+\n+            // Get the expected types of the arguments.\n+            arg_types = {\n+                let vinfo =\n+                    ty::enum_variant_with_id(\n+                        tcx, v_def_ids.enm, v_def_ids.var);\n+                vinfo.args.map(|t| { ty::subst(tcx, expected_substs, *t) })\n             };\n-        } else if subpats_len > 0 {\n-            tcx.sess.span_fatal\n-                (pat.span, fmt!(\"this pattern has %u field%s, \\\n-                                 but the corresponding variant has no fields\",\n-                                subpats_len,\n-                                if subpats_len == 1u { ~\"\" }\n-                                else { ~\"s\" }));\n+\n+            kind_name = \"variant\";\n         }\n-      }\n-      _ => {\n+        ty::ty_class(struct_def_id, ref expected_substs) => {\n+            // Assign the pattern the type of the struct.\n+            let struct_tpt = ty::lookup_item_type(tcx, struct_def_id);\n+            instantiate_path(pcx.fcx, path, struct_tpt, pat.span, pat.id,\n+                             pcx.block_region);\n+\n+            // Check that the type of the value being matched is a subtype of\n+            // the type of the pattern.\n+            let pat_ty = fcx.node_ty(pat.id);\n+            demand::suptype(fcx, pat.span, pat_ty, expected);\n+\n+            // Get the expected types of the arguments.\n+            let class_fields = ty::class_items_as_fields(\n+                tcx, struct_def_id, expected_substs);\n+            arg_types = class_fields.map(|field| field.mt.ty);\n+\n+            kind_name = \"structure\";\n+        }\n+        _ => {\n+            tcx.sess.span_fatal(\n+                pat.span,\n+                fmt!(\"mismatched types: expected enum or structure but \\\n+                      found `%s`\",\n+                     fcx.infcx().ty_to_str(expected)));\n+        }\n+    }\n+\n+    let arg_len = arg_types.len();\n+\n+    // Count the number of subpatterns.\n+    let subpats_len;\n+    match subpats {\n+        None => subpats_len = arg_len,\n+        Some(subpats) => subpats_len = subpats.len()\n+    }\n+\n+    if arg_len > 0u {\n+        // N-ary variant.\n+        if arg_len != subpats_len {\n+            let s = fmt!(\"this pattern has %u field%s, but the corresponding \\\n+                          %s has %u field%s\",\n+                         subpats_len,\n+                         if subpats_len == 1u { ~\"\" } else { ~\"s\" },\n+                         kind_name,\n+                         arg_len,\n+                         if arg_len == 1u { ~\"\" } else { ~\"s\" });\n+            // XXX: This should not be fatal.\n+            tcx.sess.span_fatal(pat.span, s);\n+        }\n+\n+        do subpats.iter() |pats| {\n+            for vec::each2(*pats, arg_types) |subpat, arg_ty| {\n+              check_pat(pcx, *subpat, *arg_ty);\n+            }\n+        };\n+    } else if subpats_len > 0u {\n         tcx.sess.span_fatal\n-            (pat.span,\n-             fmt!(\"mismatched types: expected enum but found `%s`\",\n-                  fcx.infcx().ty_to_str(expected)));\n-      }\n+            (pat.span, fmt!(\"this pattern has %u field%s, but the \\\n+                             corresponding %s has no fields\",\n+                            subpats_len,\n+                            if subpats_len == 1u { ~\"\" }\n+                            else { ~\"s\" },\n+                            kind_name));\n     }\n }\n "}, {"sha": "a32d598686c8c24b21af9341a514b2415004467f", "filename": "src/test/compile-fail/tuple-struct-nonexhaustive.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/106f9976ab1baec06af41f7009f539cd8371a840/src%2Ftest%2Fcompile-fail%2Ftuple-struct-nonexhaustive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/106f9976ab1baec06af41f7009f539cd8371a840/src%2Ftest%2Fcompile-fail%2Ftuple-struct-nonexhaustive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftuple-struct-nonexhaustive.rs?ref=106f9976ab1baec06af41f7009f539cd8371a840", "patch": "@@ -0,0 +1,11 @@\n+struct Foo(int, int);\n+\n+fn main() {\n+    let x = Foo(1, 2);\n+    match x {   //~ ERROR non-exhaustive\n+        Foo(1, b) => io::println(fmt!(\"%d\", b)),\n+        Foo(2, b) => io::println(fmt!(\"%d\", b))\n+    }\n+}\n+\n+"}]}