{"sha": "b09803e8694b3ad83f988e30b4f0a3903ebe2632", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIwOTgwM2U4Njk0YjNhZDgzZjk4OGUzMGI0ZjBhMzkwM2ViZTI2MzI=", "commit": {"author": {"name": "Paul Dicker", "email": "pitdicker@gmail.com", "date": "2019-02-19T14:57:59Z"}, "committer": {"name": "Paul Dicker", "email": "pitdicker@gmail.com", "date": "2019-02-20T18:26:56Z"}, "message": "Address review comments", "tree": {"sha": "56374445596ed08f8fe050c568000d08239d803a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/56374445596ed08f8fe050c568000d08239d803a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b09803e8694b3ad83f988e30b4f0a3903ebe2632", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b09803e8694b3ad83f988e30b4f0a3903ebe2632", "html_url": "https://github.com/rust-lang/rust/commit/b09803e8694b3ad83f988e30b4f0a3903ebe2632", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b09803e8694b3ad83f988e30b4f0a3903ebe2632/comments", "author": {"login": "pitdicker", "id": 6255050, "node_id": "MDQ6VXNlcjYyNTUwNTA=", "avatar_url": "https://avatars.githubusercontent.com/u/6255050?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pitdicker", "html_url": "https://github.com/pitdicker", "followers_url": "https://api.github.com/users/pitdicker/followers", "following_url": "https://api.github.com/users/pitdicker/following{/other_user}", "gists_url": "https://api.github.com/users/pitdicker/gists{/gist_id}", "starred_url": "https://api.github.com/users/pitdicker/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pitdicker/subscriptions", "organizations_url": "https://api.github.com/users/pitdicker/orgs", "repos_url": "https://api.github.com/users/pitdicker/repos", "events_url": "https://api.github.com/users/pitdicker/events{/privacy}", "received_events_url": "https://api.github.com/users/pitdicker/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pitdicker", "id": 6255050, "node_id": "MDQ6VXNlcjYyNTUwNTA=", "avatar_url": "https://avatars.githubusercontent.com/u/6255050?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pitdicker", "html_url": "https://github.com/pitdicker", "followers_url": "https://api.github.com/users/pitdicker/followers", "following_url": "https://api.github.com/users/pitdicker/following{/other_user}", "gists_url": "https://api.github.com/users/pitdicker/gists{/gist_id}", "starred_url": "https://api.github.com/users/pitdicker/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pitdicker/subscriptions", "organizations_url": "https://api.github.com/users/pitdicker/orgs", "repos_url": "https://api.github.com/users/pitdicker/repos", "events_url": "https://api.github.com/users/pitdicker/events{/privacy}", "received_events_url": "https://api.github.com/users/pitdicker/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f411852add58637a3b8628a8f70146106bdc9719", "url": "https://api.github.com/repos/rust-lang/rust/commits/f411852add58637a3b8628a8f70146106bdc9719", "html_url": "https://github.com/rust-lang/rust/commit/f411852add58637a3b8628a8f70146106bdc9719"}], "stats": {"total": 58, "additions": 36, "deletions": 22}, "files": [{"sha": "6b9b36f6a924b7e7affcc92ba15aa3cd97d624f1", "filename": "src/libstd/sys/windows/stdio.rs", "status": "modified", "additions": 36, "deletions": 22, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/b09803e8694b3ad83f988e30b4f0a3903ebe2632/src%2Flibstd%2Fsys%2Fwindows%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b09803e8694b3ad83f988e30b4f0a3903ebe2632/src%2Flibstd%2Fsys%2Fwindows%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fstdio.rs?ref=b09803e8694b3ad83f988e30b4f0a3903ebe2632", "patch": "@@ -1,6 +1,7 @@\n #![unstable(issue = \"0\", feature = \"windows_stdio\")]\n \n use cell::Cell;\n+use char::decode_utf16;\n use cmp;\n use io;\n use ptr;\n@@ -64,22 +65,27 @@ fn write(handle_id: c::DWORD, data: &[u8]) -> io::Result<usize> {\n     //\n     // If the data is not valid UTF-8 we write out as many bytes as are valid.\n     // Only when there are no valid bytes (which will happen on the next call), return an error.\n-    let len = cmp::min(data.len(), MAX_BUFFER_SIZE);\n+    let len = cmp::min(data.len(), MAX_BUFFER_SIZE / 2);\n     let utf8 = match str::from_utf8(&data[..len]) {\n         Ok(s) => s,\n         Err(ref e) if e.valid_up_to() == 0 => {\n             return Err(io::Error::new(io::ErrorKind::InvalidData,\n-                \"Windows stdio in console mode does not support non-UTF-8 byte sequences; \\\n-                see https://github.com/rust-lang/rust/issues/23344\"))\n+                \"Windows stdio in console mode does not support writing non-UTF-8 byte sequences\"))\n         },\n         Err(e) => str::from_utf8(&data[..e.valid_up_to()]).unwrap(),\n     };\n-    let utf16 = utf8.encode_utf16().collect::<Vec<u16>>();\n+    let mut utf16 = [0u16; MAX_BUFFER_SIZE / 2];\n+    let mut len_utf16 = 0;\n+    for (chr, dest) in utf8.encode_utf16().zip(utf16.iter_mut()) {\n+        *dest = chr;\n+        len_utf16 += 1;\n+    }\n+    let utf16 = &utf16[..len_utf16];\n \n     let mut written = write_u16s(handle, &utf16)?;\n \n     // Figure out how many bytes of as UTF-8 were written away as UTF-16.\n-    if written >= utf16.len() {\n+    if written == utf16.len() {\n         Ok(utf8.len())\n     } else {\n         // Make sure we didn't end up writing only half of a surrogate pair (even though the chance\n@@ -90,7 +96,7 @@ fn write(handle_id: c::DWORD, data: &[u8]) -> io::Result<usize> {\n         let first_char_remaining = utf16[written];\n         if first_char_remaining >= 0xDCEE && first_char_remaining <= 0xDFFF { // low surrogate\n             // We just hope this works, and give up otherwise\n-            let _ = write_u16s(handle, &utf16[written..written]);\n+            let _ = write_u16s(handle, &utf16[written..written+1]);\n             written += 1;\n         }\n         // Calculate the number of bytes of `utf8` that were actually written.\n@@ -103,6 +109,7 @@ fn write(handle_id: c::DWORD, data: &[u8]) -> io::Result<usize> {\n                 _ => 3,\n             };\n         }\n+        debug_assert!(String::from_utf16(&utf16[..written]).unwrap() == utf8[..count]);\n         Ok(count)\n     }\n }\n@@ -137,7 +144,7 @@ impl Stdin {\n             return Ok(0);\n         } else if buf.len() < 4 {\n             return Err(io::Error::new(io::ErrorKind::InvalidInput,\n-                        \"Windows stdin in console mode does not support a buffer too small to; \\\n+                        \"Windows stdin in console mode does not support a buffer too small to \\\n                         guarantee holding one arbitrary UTF-8 character (4 bytes)\"))\n         }\n \n@@ -147,27 +154,14 @@ impl Stdin {\n         // lost.\n         let amount = cmp::min(buf.len() / 3, utf16_buf.len());\n         let read = self.read_u16s_fixup_surrogates(handle, &mut utf16_buf, amount)?;\n-        let utf16 = &utf16_buf[..read];\n \n-        // FIXME: it would be nice if we could directly decode into the buffer instead of doing an\n-        //        allocation.\n-        let data = match String::from_utf16(&utf16) {\n-            Ok(utf8) => utf8.into_bytes(),\n-            Err(..) => {\n-                // We can't really do any better than forget all data and return an error.\n-                return Err(io::Error::new(io::ErrorKind::InvalidData,\n-                    \"Windows stdin in console mode does not support non-UTF-16 input; \\\n-                    encountered unpaired surrogate\"))\n-            },\n-        };\n-        buf.copy_from_slice(&data);\n-        Ok(data.len())\n+        utf16_to_utf8(&utf16_buf[..read], buf)\n     }\n \n     // We assume that if the last `u16` is an unpaired surrogate they got sliced apart by our\n     // buffer size, and keep it around for the next read hoping to put them together.\n     // This is a best effort, and may not work if we are not the only reader on Stdin.\n-    pub fn read_u16s_fixup_surrogates(&self, handle: c::HANDLE, buf: &mut [u16], mut amount: usize)\n+    fn read_u16s_fixup_surrogates(&self, handle: c::HANDLE, buf: &mut [u16], mut amount: usize)\n         -> io::Result<usize>\n     {\n         // Insert possibly remaining unpaired surrogate from last read.\n@@ -223,6 +217,26 @@ fn read_u16s(handle: c::HANDLE, buf: &mut [u16]) -> io::Result<usize> {\n     Ok(amount as usize)\n }\n \n+#[allow(unused)]\n+fn utf16_to_utf8(utf16: &[u16], utf8: &mut [u8]) -> io::Result<usize> {\n+    let mut written = 0;\n+    for chr in decode_utf16(utf16.iter().cloned()) {\n+        match chr {\n+            Ok(chr) => {\n+                chr.encode_utf8(&mut utf8[written..]);\n+                written += chr.len_utf8();\n+            }\n+            Err(_) => {\n+                // We can't really do any better than forget all data and return an error.\n+                return Err(io::Error::new(io::ErrorKind::InvalidData,\n+                    \"Windows stdin in console mode does not support non-UTF-16 input; \\\n+                    encountered unpaired surrogate\"))\n+            }\n+        }\n+    }\n+    Ok(written)\n+}\n+\n impl Stdout {\n     pub fn new() -> io::Result<Stdout> {\n         Ok(Stdout)"}]}