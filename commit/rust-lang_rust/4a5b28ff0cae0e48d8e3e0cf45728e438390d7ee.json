{"sha": "4a5b28ff0cae0e48d8e3e0cf45728e438390d7ee", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRhNWIyOGZmMGNhZTBlNDhkOGUzZTBjZjQ1NzI4ZTQzODM5MGQ3ZWU=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-11-16T22:22:09Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-11-16T22:22:09Z"}, "message": "Stop tracking CodeMap offsets in the parse session. Big simplification", "tree": {"sha": "9c7d0bed694a4b1252eb69010f61f27dadc82887", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9c7d0bed694a4b1252eb69010f61f27dadc82887"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4a5b28ff0cae0e48d8e3e0cf45728e438390d7ee", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4a5b28ff0cae0e48d8e3e0cf45728e438390d7ee", "html_url": "https://github.com/rust-lang/rust/commit/4a5b28ff0cae0e48d8e3e0cf45728e438390d7ee", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4a5b28ff0cae0e48d8e3e0cf45728e438390d7ee/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2374154ded19a247be0053d71f5bcdd22b95462a", "url": "https://api.github.com/repos/rust-lang/rust/commits/2374154ded19a247be0053d71f5bcdd22b95462a", "html_url": "https://github.com/rust-lang/rust/commit/2374154ded19a247be0053d71f5bcdd22b95462a"}], "stats": {"total": 144, "additions": 48, "deletions": 96}, "files": [{"sha": "91aef76061e68f39b061e35864fcbfc5c07b06a3", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 17, "deletions": 26, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/4a5b28ff0cae0e48d8e3e0cf45728e438390d7ee/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a5b28ff0cae0e48d8e3e0cf45728e438390d7ee/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=4a5b28ff0cae0e48d8e3e0cf45728e438390d7ee", "patch": "@@ -201,25 +201,6 @@ pub struct FileMap {\n }\n \n pub impl FileMap {\n-    static fn new_w_substr(+filename: FileName, +substr: FileSubstr,\n-                           src: @~str,\n-                           +start_pos: BytePos)\n-        -> FileMap {\n-        return FileMap {\n-            name: filename, substr: substr, src: src,\n-            start_pos: start_pos,\n-            mut lines: ~[],\n-            multibyte_chars: DVec()\n-        };\n-    }\n-\n-    static fn new(+filename: FileName, src: @~str,\n-                  +start_pos: BytePos)\n-        -> FileMap {\n-        return FileMap::new_w_substr(filename, FssNone, src,\n-                                     start_pos);\n-    }\n-\n     fn next_line(&self, +pos: BytePos) {\n         self.lines.push(pos);\n     }\n@@ -262,20 +243,30 @@ pub impl CodeMap {\n         }\n     }\n \n-    pub fn add_filemap(&self, filemap: @FileMap) {\n-        let expected_byte_pos = if self.files.len() == 0 {\n+    fn new_filemap_w_substr(+filename: FileName, +substr: FileSubstr,\n+                            src: @~str) -> @FileMap {\n+        let start_pos = if self.files.len() == 0 {\n             0\n         } else {\n             let last_start = self.files.last().start_pos.to_uint();\n             let last_len = self.files.last().src.len();\n             last_start + last_len\n         };\n-        let actual_byte_pos = filemap.start_pos.to_uint();\n-        debug!(\"codemap: adding filemap: %s\", filemap.name);\n-        debug!(\"codemap: expected offset: %u\", expected_byte_pos);\n-        debug!(\"codemap: actual offset: %u\", actual_byte_pos);\n-        assert expected_byte_pos == actual_byte_pos;\n+\n+        let filemap = @FileMap {\n+            name: filename, substr: substr, src: src,\n+            start_pos: BytePos(start_pos),\n+            mut lines: ~[],\n+            multibyte_chars: DVec()\n+        };\n+\n         self.files.push(filemap);\n+\n+        return filemap;\n+    }\n+\n+    fn new_filemap(+filename: FileName, src: @~str) -> @FileMap {\n+        return self.new_filemap_w_substr(filename, FssNone, src);\n     }\n \n     pub fn mk_substr_filename(&self, sp: span) -> ~str {"}, {"sha": "93cfaadcbd378eed83c19a48d42dfd3b02a8f3c5", "filename": "src/libsyntax/ext/source_util.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4a5b28ff0cae0e48d8e3e0cf45728e438390d7ee/src%2Flibsyntax%2Fext%2Fsource_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a5b28ff0cae0e48d8e3e0cf45728e438390d7ee/src%2Flibsyntax%2Fext%2Fsource_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fsource_util.rs?ref=4a5b28ff0cae0e48d8e3e0cf45728e438390d7ee", "patch": "@@ -58,12 +58,11 @@ fn expand_include(cx: ext_ctxt, sp: span, arg: ast::mac_arg,\n                   _body: ast::mac_body) -> @ast::expr {\n     let args = get_mac_args(cx, sp, arg, 1u, option::Some(1u), ~\"include\");\n     let file = expr_to_str(cx, args[0], ~\"#include_str requires a string\");\n-    let (p, rdr) = parse::new_parser_etc_from_file(\n+    let p = parse::new_parser_from_file(\n         cx.parse_sess(), cx.cfg(),\n         &res_rel_file(cx, sp, &Path(file)),\n         parse::parser::SOURCE_FILE);\n     let e = p.parse_expr();\n-    parse::update_parse_sess_position(&cx.parse_sess(), &rdr);\n     return e;\n }\n "}, {"sha": "d824f9f8a0340cdd069aa233346f93a7205f1ce1", "filename": "src/libsyntax/parse.rs", "status": "modified", "additions": 23, "deletions": 58, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/4a5b28ff0cae0e48d8e3e0cf45728e438390d7ee/src%2Flibsyntax%2Fparse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a5b28ff0cae0e48d8e3e0cf45728e438390d7ee/src%2Flibsyntax%2Fparse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse.rs?ref=4a5b28ff0cae0e48d8e3e0cf45728e438390d7ee", "patch": "@@ -11,7 +11,6 @@ export parse_crate_from_source_str;\n export parse_expr_from_source_str, parse_item_from_source_str;\n export parse_stmt_from_source_str;\n export parse_from_source_str;\n-export update_parse_sess_position;\n \n use parser::Parser;\n use attr::parser_attr;\n@@ -28,8 +27,6 @@ type parse_sess = @{\n     mut next_id: node_id,\n     span_diagnostic: span_handler,\n     interner: @ident_interner,\n-    // must be kept up to date\n-    mut pos: BytePos\n };\n \n fn new_parse_sess(demitter: Option<emitter>) -> parse_sess {\n@@ -38,7 +35,6 @@ fn new_parse_sess(demitter: Option<emitter>) -> parse_sess {\n              mut next_id: 1,\n              span_diagnostic: mk_span_handler(mk_handler(demitter), cm),\n              interner: mk_ident_interner(),\n-             mut pos: BytePos(0)\n             };\n }\n \n@@ -48,7 +44,6 @@ fn new_parse_sess_special_handler(sh: span_handler, cm: @codemap::CodeMap)\n              mut next_id: 1,\n              span_diagnostic: sh,\n              interner: mk_ident_interner(),\n-             mut pos: BytePos(0)\n              };\n }\n \n@@ -66,14 +61,13 @@ fn parse_crate_from_file(input: &Path, cfg: ast::crate_cfg,\n \n fn parse_crate_from_crate_file(input: &Path, cfg: ast::crate_cfg,\n                                sess: parse_sess) -> @ast::crate {\n-    let (p, rdr) = new_parser_etc_from_file(sess, cfg, input,\n-                                            parser::CRATE_FILE);\n+    let p = new_parser_from_file(sess, cfg, input,\n+                                 parser::CRATE_FILE);\n     let lo = p.span.lo;\n     let prefix = input.dir_path();\n     let leading_attrs = p.parse_inner_attrs_and_next();\n     let { inner: crate_attrs, next: first_cdir_attr } = leading_attrs;\n     let cdirs = p.parse_crate_directives(token::EOF, first_cdir_attr);\n-    update_parse_sess_position(&sess, &rdr);\n     let cx = @{sess: sess, cfg: /* FIXME (#2543) */ copy p.cfg};\n     let companionmod = input.filestem().map(|s| Path(*s));\n     let (m, attrs) = eval::eval_crate_directives_to_mod(\n@@ -90,52 +84,47 @@ fn parse_crate_from_crate_file(input: &Path, cfg: ast::crate_cfg,\n \n fn parse_crate_from_source_file(input: &Path, cfg: ast::crate_cfg,\n                                 sess: parse_sess) -> @ast::crate {\n-    let (p, rdr) = new_parser_etc_from_file(sess, cfg, input,\n-                                            parser::SOURCE_FILE);\n+    let p = new_parser_from_file(sess, cfg, input,\n+                                 parser::SOURCE_FILE);\n     let r = p.parse_crate_mod(cfg);\n-    update_parse_sess_position(&sess, &rdr);\n     return r;\n }\n \n fn parse_crate_from_source_str(name: ~str, source: @~str, cfg: ast::crate_cfg,\n                                sess: parse_sess) -> @ast::crate {\n-    let (p, rdr) = new_parser_etc_from_source_str(sess, cfg, name,\n-                                                  codemap::FssNone, source);\n+    let p = new_parser_from_source_str(sess, cfg, name,\n+                                       codemap::FssNone, source);\n     let r = p.parse_crate_mod(cfg);\n     p.abort_if_errors();\n-    update_parse_sess_position(&sess, &rdr);\n     return r;\n }\n \n fn parse_expr_from_source_str(name: ~str, source: @~str, cfg: ast::crate_cfg,\n                               sess: parse_sess) -> @ast::expr {\n-    let (p, rdr) = new_parser_etc_from_source_str(sess, cfg, name,\n-                                                  codemap::FssNone, source);\n+    let p = new_parser_from_source_str(sess, cfg, name,\n+                                       codemap::FssNone, source);\n     let r = p.parse_expr();\n     p.abort_if_errors();\n-    update_parse_sess_position(&sess, &rdr);\n     return r;\n }\n \n fn parse_item_from_source_str(name: ~str, source: @~str, cfg: ast::crate_cfg,\n                               +attrs: ~[ast::attribute],\n                               sess: parse_sess) -> Option<@ast::item> {\n-    let (p, rdr) = new_parser_etc_from_source_str(sess, cfg, name,\n-                                                  codemap::FssNone, source);\n+    let p = new_parser_from_source_str(sess, cfg, name,\n+                                       codemap::FssNone, source);\n     let r = p.parse_item(attrs);\n     p.abort_if_errors();\n-    update_parse_sess_position(&sess, &rdr);\n     return r;\n }\n \n fn parse_stmt_from_source_str(name: ~str, source: @~str, cfg: ast::crate_cfg,\n                               +attrs: ~[ast::attribute],\n                               sess: parse_sess) -> @ast::stmt {\n-    let (p, rdr) = new_parser_etc_from_source_str(sess, cfg, name,\n-                                                  codemap::FssNone, source);\n+    let p = new_parser_from_source_str(sess, cfg, name,\n+                                       codemap::FssNone, source);\n     let r = p.parse_stmt(attrs);\n     p.abort_if_errors();\n-    update_parse_sess_position(&sess, &rdr);\n     return r;\n }\n \n@@ -145,14 +134,13 @@ fn parse_from_source_str<T>(f: fn (p: Parser) -> T,\n                             sess: parse_sess)\n     -> T\n {\n-    let (p, rdr) = new_parser_etc_from_source_str(sess, cfg, name, ss,\n-                                                  source);\n+    let p = new_parser_from_source_str(sess, cfg, name, ss,\n+                                       source);\n     let r = f(p);\n     if !p.reader.is_eof() {\n         p.reader.fatal(~\"expected end-of-string\");\n     }\n     p.abort_if_errors();\n-    update_parse_sess_position(&sess, &rdr);\n     move r\n }\n \n@@ -164,47 +152,28 @@ fn next_node_id(sess: parse_sess) -> node_id {\n     return rv;\n }\n \n-fn new_parser_etc_from_source_str(sess: parse_sess, cfg: ast::crate_cfg,\n-                                  +name: ~str, +ss: codemap::FileSubstr,\n-                                  source: @~str) -> (Parser, string_reader) {\n-    let ftype = parser::SOURCE_FILE;\n-    let filemap = @FileMap::new_w_substr\n-        (name, ss, source, sess.pos);\n-    sess.cm.add_filemap(filemap);\n-    let srdr = lexer::new_string_reader(sess.span_diagnostic, filemap,\n-                                        sess.interner);\n-    return (Parser(sess, cfg, srdr as reader, ftype), srdr);\n-}\n-\n fn new_parser_from_source_str(sess: parse_sess, cfg: ast::crate_cfg,\n                               +name: ~str, +ss: codemap::FileSubstr,\n                               source: @~str) -> Parser {\n-    let (p, _) = new_parser_etc_from_source_str(sess, cfg, name, ss, source);\n-    move p\n+    let ftype = parser::SOURCE_FILE;\n+    let filemap = sess.cm.new_filemap_w_substr(name, ss, source);\n+    let srdr = lexer::new_string_reader(sess.span_diagnostic, filemap,\n+                                        sess.interner);\n+    return Parser(sess, cfg, srdr as reader, ftype);\n }\n \n-\n-fn new_parser_etc_from_file(sess: parse_sess, cfg: ast::crate_cfg,\n-                            path: &Path, ftype: parser::file_type) ->\n-   (Parser, string_reader) {\n+fn new_parser_from_file(sess: parse_sess, cfg: ast::crate_cfg,\n+                        path: &Path, ftype: parser::file_type) -> Parser {\n     let res = io::read_whole_file_str(path);\n     match res {\n       result::Ok(_) => { /* Continue. */ }\n       result::Err(e) => sess.span_diagnostic.handler().fatal(e)\n     }\n     let src = @result::unwrap(res);\n-    let filemap = @FileMap::new(path.to_str(), src,\n-                                sess.pos);\n-    sess.cm.add_filemap(filemap);\n+    let filemap = sess.cm.new_filemap(path.to_str(), src);\n     let srdr = lexer::new_string_reader(sess.span_diagnostic, filemap,\n                                         sess.interner);\n-    return (Parser(sess, cfg, srdr as reader, ftype), srdr);\n-}\n-\n-fn new_parser_from_file(sess: parse_sess, cfg: ast::crate_cfg, path: &Path,\n-                        ftype: parser::file_type) -> Parser {\n-    let (p, _) = new_parser_etc_from_file(sess, cfg, path, ftype);\n-    move p\n+    return Parser(sess, cfg, srdr as reader, ftype);\n }\n \n fn new_parser_from_tt(sess: parse_sess, cfg: ast::crate_cfg,\n@@ -213,7 +182,3 @@ fn new_parser_from_tt(sess: parse_sess, cfg: ast::crate_cfg,\n                                     None, tt);\n     return Parser(sess, cfg, trdr as reader, parser::SOURCE_FILE)\n }\n-\n-fn update_parse_sess_position(sess: &parse_sess, r: &lexer::string_reader) {\n-    sess.pos = r.last_pos\n-}"}, {"sha": "2a8bbe3b6d86263fd56ddbc8ffefefc43f7c7f3b", "filename": "src/libsyntax/parse/comments.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4a5b28ff0cae0e48d8e3e0cf45728e438390d7ee/src%2Flibsyntax%2Fparse%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a5b28ff0cae0e48d8e3e0cf45728e438390d7ee/src%2Flibsyntax%2Fparse%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fcomments.rs?ref=4a5b28ff0cae0e48d8e3e0cf45728e438390d7ee", "patch": "@@ -292,7 +292,8 @@ fn gather_comments_and_literals(span_diagnostic: diagnostic::span_handler,\n    {cmnts: ~[cmnt], lits: ~[lit]} {\n     let src = @str::from_bytes(srdr.read_whole_stream());\n     let itr = parse::token::mk_fake_ident_interner();\n-    let filemap = @FileMap::new(path, src, BytePos(0));\n+    let cm = CodeMap::new();\n+    let filemap = cm.new_filemap(path, src);\n     let rdr = lexer::new_low_level_string_reader(\n         span_diagnostic, filemap, itr);\n "}, {"sha": "f08f195446442e417e5602391d5422afff9eb2f9", "filename": "src/libsyntax/parse/eval.rs", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/4a5b28ff0cae0e48d8e3e0cf45728e438390d7ee/src%2Flibsyntax%2Fparse%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a5b28ff0cae0e48d8e3e0cf45728e438390d7ee/src%2Flibsyntax%2Fparse%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Feval.rs?ref=4a5b28ff0cae0e48d8e3e0cf45728e438390d7ee", "patch": "@@ -1,4 +1,3 @@\n-use parse::update_parse_sess_position;\n use parser::{Parser, SOURCE_FILE};\n use attr::parser_attr;\n \n@@ -63,11 +62,10 @@ fn parse_companion_mod(cx: ctx, prefix: &Path, suffix: &Option<Path>)\n     let modpath = &companion_file(prefix, suffix);\n     if file_exists(modpath) {\n         debug!(\"found companion mod\");\n-        let (p0, r0) = new_parser_etc_from_file(cx.sess, cx.cfg,\n-                                                modpath, SOURCE_FILE);\n+        let p0 = new_parser_from_file(cx.sess, cx.cfg,\n+                                      modpath, SOURCE_FILE);\n         let inner_attrs = p0.parse_inner_attrs_and_next();\n         let m0 = p0.parse_mod_items(token::EOF, inner_attrs.next);\n-        update_parse_sess_position(&cx.sess, &r0);\n         return (m0.view_items, m0.items, inner_attrs.inner);\n     } else {\n         return (~[], ~[], ~[]);\n@@ -93,9 +91,9 @@ fn eval_crate_directive(cx: ctx, cdir: @ast::crate_directive, prefix: &Path,\n         } else {\n             prefix.push_many(file_path.components)\n         };\n-        let (p0, r0) =\n-            new_parser_etc_from_file(cx.sess, cx.cfg,\n-                                     &full_path, SOURCE_FILE);\n+        let p0 =\n+            new_parser_from_file(cx.sess, cx.cfg,\n+                                 &full_path, SOURCE_FILE);\n         let inner_attrs = p0.parse_inner_attrs_and_next();\n         let mod_attrs = vec::append(attrs, inner_attrs.inner);\n         let first_item_outer_attrs = inner_attrs.next;\n@@ -104,8 +102,6 @@ fn eval_crate_directive(cx: ctx, cdir: @ast::crate_directive, prefix: &Path,\n         let i = p0.mk_item(cdir.span.lo, cdir.span.hi,\n                            /* FIXME (#2543) */ copy id,\n                            ast::item_mod(m0), vis, mod_attrs);\n-        // Thread defids, chpos and byte_pos through the parsers\n-        update_parse_sess_position(&cx.sess, &r0);\n         items.push(i);\n       }\n       ast::cdir_dir_mod(vis, id, cdirs, attrs) => {"}]}