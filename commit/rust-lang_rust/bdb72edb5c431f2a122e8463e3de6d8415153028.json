{"sha": "bdb72edb5c431f2a122e8463e3de6d8415153028", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJkYjcyZWRiNWM0MzFmMmExMjJlODQ2M2UzZGU2ZDg0MTUxNTMwMjg=", "commit": {"author": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2017-09-27T11:23:45Z"}, "committer": {"name": "Ariel Ben-Yehuda", "email": "arielb1@mail.tau.ac.il", "date": "2017-11-26T14:12:42Z"}, "message": "make accesses to fields of packed structs unsafe\n\nTo handle packed structs with destructors (which you'll think are a rare\ncase, but the `#[repr(packed)] struct Packed<T>(T);` pattern is\never-popular, which requires handling packed structs with destructors to\navoid monomorphization-time errors), drops of subfields of packed\nstructs should drop a local move of the field instead of the original\none.\n\ncc #27060 - this should deal with that issue after codegen of drop glue\nis updated.\n\nThe new errors need to be changed to future-compatibility warnings, but\nI'll rather do a crater run first with them as errors to assess the\nimpact.", "tree": {"sha": "836c2a6961ed73e64b708b6b2544b653e4e2f1d5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/836c2a6961ed73e64b708b6b2544b653e4e2f1d5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bdb72edb5c431f2a122e8463e3de6d8415153028", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bdb72edb5c431f2a122e8463e3de6d8415153028", "html_url": "https://github.com/rust-lang/rust/commit/bdb72edb5c431f2a122e8463e3de6d8415153028", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bdb72edb5c431f2a122e8463e3de6d8415153028/comments", "author": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "c48650ec25d2e7e872912137e68496248743f1fe", "url": "https://api.github.com/repos/rust-lang/rust/commits/c48650ec25d2e7e872912137e68496248743f1fe", "html_url": "https://github.com/rust-lang/rust/commit/c48650ec25d2e7e872912137e68496248743f1fe"}], "stats": {"total": 179, "additions": 151, "deletions": 28}, "files": [{"sha": "8620fba973dac9f3be90fcf860af88eb5ebd51d1", "filename": "src/librustc_mir/transform/check_unsafety.rs", "status": "modified", "additions": 49, "deletions": 20, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/bdb72edb5c431f2a122e8463e3de6d8415153028/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdb72edb5c431f2a122e8463e3de6d8415153028/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs?ref=bdb72edb5c431f2a122e8463e3de6d8415153028", "patch": "@@ -12,7 +12,7 @@ use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::indexed_vec::IndexVec;\n \n use rustc::ty::maps::Providers;\n-use rustc::ty::{self, TyCtxt};\n+use rustc::ty::{self, Ty, TyCtxt};\n use rustc::hir;\n use rustc::hir::def_id::DefId;\n use rustc::lint::builtin::{SAFE_EXTERN_STATICS, UNUSED_UNSAFE};\n@@ -29,6 +29,9 @@ pub struct UnsafetyChecker<'a, 'tcx: 'a> {\n     visibility_scope_info: &'a IndexVec<VisibilityScope, VisibilityScopeInfo>,\n     violations: Vec<UnsafetyViolation>,\n     source_info: SourceInfo,\n+    // true if an a part of this *memory block* of this expression\n+    // is being borrowed, used for repr(packed) checking.\n+    need_check_packed: bool,\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n     used_unsafe: FxHashSet<ast::NodeId>,\n@@ -50,6 +53,7 @@ impl<'a, 'gcx, 'tcx> UnsafetyChecker<'a, 'tcx> {\n             },\n             tcx,\n             param_env,\n+            need_check_packed: false,\n             used_unsafe: FxHashSet(),\n             inherited_blocks: vec![],\n         }\n@@ -138,6 +142,14 @@ impl<'a, 'tcx> Visitor<'tcx> for UnsafetyChecker<'a, 'tcx> {\n                     lvalue: &Lvalue<'tcx>,\n                     context: LvalueContext<'tcx>,\n                     location: Location) {\n+        let old_need_check_packed = self.need_check_packed;\n+        if let LvalueContext::Borrow { .. } = context {\n+            let ty = lvalue.ty(self.mir, self.tcx).to_ty(self.tcx);\n+            if !self.has_align_1(ty) {\n+                self.need_check_packed = true;\n+            }\n+        }\n+\n         match lvalue {\n             &Lvalue::Projection(box Projection {\n                 ref base, ref elem\n@@ -151,31 +163,39 @@ impl<'a, 'tcx> Visitor<'tcx> for UnsafetyChecker<'a, 'tcx> {\n                         self.source_info = self.mir.local_decls[local].source_info;\n                     }\n                 }\n+                if let &ProjectionElem::Deref = elem {\n+                    self.need_check_packed = false;\n+                }\n                 let base_ty = base.ty(self.mir, self.tcx).to_ty(self.tcx);\n                 match base_ty.sty {\n                     ty::TyRawPtr(..) => {\n                         self.require_unsafe(\"dereference of raw pointer\")\n                     }\n-                    ty::TyAdt(adt, _) if adt.is_union() => {\n-                        if context == LvalueContext::Store ||\n-                            context == LvalueContext::Drop\n-                        {\n-                            let elem_ty = match elem {\n-                                &ProjectionElem::Field(_, ty) => ty,\n-                                _ => span_bug!(\n-                                    self.source_info.span,\n-                                    \"non-field projection {:?} from union?\",\n-                                    lvalue)\n-                            };\n-                            if elem_ty.moves_by_default(self.tcx, self.param_env,\n-                                                        self.source_info.span) {\n-                                self.require_unsafe(\n-                                    \"assignment to non-`Copy` union field\")\n+                    ty::TyAdt(adt, _) => {\n+                        if adt.is_union() {\n+                            if context == LvalueContext::Store ||\n+                                context == LvalueContext::Drop\n+                            {\n+                                let elem_ty = match elem {\n+                                    &ProjectionElem::Field(_, ty) => ty,\n+                                    _ => span_bug!(\n+                                        self.source_info.span,\n+                                        \"non-field projection {:?} from union?\",\n+                                        lvalue)\n+                                };\n+                                if elem_ty.moves_by_default(self.tcx, self.param_env,\n+                                                            self.source_info.span) {\n+                                    self.require_unsafe(\n+                                        \"assignment to non-`Copy` union field\")\n+                                } else {\n+                                    // write to non-move union, safe\n+                                }\n                             } else {\n-                                // write to non-move union, safe\n+                                self.require_unsafe(\"access to union field\")\n                             }\n-                        } else {\n-                            self.require_unsafe(\"access to union field\")\n+                        }\n+                        if adt.repr.packed() && self.need_check_packed {\n+                            self.require_unsafe(\"borrow of packed field\")\n                         }\n                     }\n                     _ => {}\n@@ -199,12 +219,21 @@ impl<'a, 'tcx> Visitor<'tcx> for UnsafetyChecker<'a, 'tcx> {\n                     }], &[]);\n                 }\n             }\n-        }\n+        };\n         self.super_lvalue(lvalue, context, location);\n+        self.need_check_packed = old_need_check_packed;\n     }\n }\n \n impl<'a, 'tcx> UnsafetyChecker<'a, 'tcx> {\n+\n+    fn has_align_1(&self, ty: Ty<'tcx>) -> bool {\n+        self.tcx.at(self.source_info.span)\n+            .layout_raw(self.param_env.and(ty))\n+            .map(|layout| layout.align.abi() == 1)\n+            .unwrap_or(false)\n+    }\n+\n     fn require_unsafe(&mut self,\n                       description: &'static str)\n     {"}, {"sha": "0ca259fd44d78020baf2fc30a883e3365b55ff2f", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 24, "deletions": 4, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/bdb72edb5c431f2a122e8463e3de6d8415153028/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdb72edb5c431f2a122e8463e3de6d8415153028/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=bdb72edb5c431f2a122e8463e3de6d8415153028", "patch": "@@ -13,7 +13,7 @@ use constrained_type_params::{identify_constrained_type_params, Parameter};\n \n use hir::def_id::DefId;\n use rustc::traits::{self, ObligationCauseCode};\n-use rustc::ty::{self, Ty, TyCtxt};\n+use rustc::ty::{self, Lift, Ty, TyCtxt};\n use rustc::ty::util::ExplicitSelf;\n use rustc::util::nodemap::{FxHashSet, FxHashMap};\n use rustc::middle::lang_items;\n@@ -224,10 +224,31 @@ impl<'a, 'gcx> CheckTypeWellFormedVisitor<'a, 'gcx> {\n     {\n         self.for_item(item).with_fcx(|fcx, this| {\n             let variants = lookup_fields(fcx);\n+            let def_id = fcx.tcx.hir.local_def_id(item.id);\n+            let packed = fcx.tcx.adt_def(def_id).repr.packed();\n \n             for variant in &variants {\n-                // For DST, all intermediate types must be sized.\n-                let unsized_len = if all_sized || variant.fields.is_empty() { 0 } else { 1 };\n+                // For DST, or when drop needs to copy things around, all\n+                // intermediate types must be sized.\n+                let needs_drop_copy = || {\n+                    packed && {\n+                        let ty = variant.fields.last().unwrap().ty;\n+                        let ty = fcx.tcx.erase_regions(&ty).lift_to_tcx(this.tcx)\n+                            .unwrap_or_else(|| {\n+                                span_bug!(item.span, \"inference variables in {:?}\", ty)\n+                            });\n+                        ty.needs_drop(this.tcx, this.tcx.param_env(def_id))\n+                    }\n+                };\n+                let unsized_len = if\n+                    all_sized ||\n+                    variant.fields.is_empty() ||\n+                    needs_drop_copy()\n+                {\n+                    0\n+                } else {\n+                    1\n+                };\n                 for field in &variant.fields[..variant.fields.len() - unsized_len] {\n                     fcx.register_bound(\n                         field.ty,\n@@ -246,7 +267,6 @@ impl<'a, 'gcx> CheckTypeWellFormedVisitor<'a, 'gcx> {\n                 }\n             }\n \n-            let def_id = fcx.tcx.hir.local_def_id(item.id);\n             let predicates = fcx.tcx.predicates_of(def_id).instantiate_identity(fcx.tcx);\n             let predicates = fcx.normalize_associated_types_in(item.span, &predicates);\n             this.check_where_clauses(fcx, item.span, &predicates);"}, {"sha": "a5c338c913c1b60ebb7ebfea4ce464cd94600841", "filename": "src/libsyntax_pos/span_encoding.rs", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/bdb72edb5c431f2a122e8463e3de6d8415153028/src%2Flibsyntax_pos%2Fspan_encoding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdb72edb5c431f2a122e8463e3de6d8415153028/src%2Flibsyntax_pos%2Fspan_encoding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Fspan_encoding.rs?ref=bdb72edb5c431f2a122e8463e3de6d8415153028", "patch": "@@ -19,16 +19,30 @@ use hygiene::SyntaxContext;\n \n use rustc_data_structures::fx::FxHashMap;\n use std::cell::RefCell;\n+use std::hash::{Hash, Hasher};\n \n /// A compressed span.\n /// Contains either fields of `SpanData` inline if they are small, or index into span interner.\n /// The primary goal of `Span` is to be as small as possible and fit into other structures\n /// (that's why it uses `packed` as well). Decoding speed is the second priority.\n /// See `SpanData` for the info on span fields in decoded representation.\n-#[derive(Clone, Copy, PartialEq, Eq, Hash)]\n+#[derive(Clone, Copy)]\n #[repr(packed)]\n pub struct Span(u32);\n \n+impl PartialEq for Span {\n+    #[inline]\n+    fn eq(&self, other: &Self) -> bool { ({self.0}) == ({other.0}) }\n+}\n+\n+impl Eq for Span {}\n+\n+impl Hash for Span {\n+    fn hash<H: Hasher>(&self, s: &mut H) {\n+        {self.0}.hash(s)\n+    }\n+}\n+\n /// Dummy span, both position and length are zero, syntax context is zero as well.\n /// This span is kept inline and encoded with format 0.\n pub const DUMMY_SP: Span = Span(0);"}, {"sha": "28180b05c8de8dcca986f5a6e34915d90f3df295", "filename": "src/test/compile-fail/issue-27060-2.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/bdb72edb5c431f2a122e8463e3de6d8415153028/src%2Ftest%2Fcompile-fail%2Fissue-27060-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdb72edb5c431f2a122e8463e3de6d8415153028/src%2Ftest%2Fcompile-fail%2Fissue-27060-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-27060-2.rs?ref=bdb72edb5c431f2a122e8463e3de6d8415153028", "patch": "@@ -0,0 +1,16 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#[repr(packed)]\n+pub struct Bad<T: ?Sized> {\n+    data: T, //~ ERROR `T: std::marker::Sized` is not satisfied\n+}\n+\n+fn main() {}"}, {"sha": "895d3b3fc84f3c43954400e3c7bb6cbd02b398a6", "filename": "src/test/compile-fail/issue-27060.rs", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/bdb72edb5c431f2a122e8463e3de6d8415153028/src%2Ftest%2Fcompile-fail%2Fissue-27060.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdb72edb5c431f2a122e8463e3de6d8415153028/src%2Ftest%2Fcompile-fail%2Fissue-27060.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-27060.rs?ref=bdb72edb5c431f2a122e8463e3de6d8415153028", "patch": "@@ -0,0 +1,40 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#[repr(packed)]\n+pub struct Good {\n+    data: &'static u32,\n+    data2: [&'static u32; 2],\n+    aligned: [u8; 32],\n+}\n+\n+#[repr(packed)]\n+pub struct JustArray {\n+    array: [u32]\n+}\n+\n+fn main() {\n+    let good = Good {\n+        data: &0,\n+        data2: [&0, &0],\n+        aligned: [0; 32]\n+    };\n+\n+    unsafe {\n+        let _ = &good.data; // ok\n+        let _ = &good.data2[0]; // ok\n+    }\n+\n+    let _ = &good.data; //~ ERROR borrow of packed field requires unsafe\n+    let _ = &good.data2[0]; //~ ERROR borrow of packed field requires unsafe\n+    let _ = &*good.data; // ok, behind a pointer\n+    let _ = &good.aligned; // ok, has align 1\n+    let _ = &good.aligned[2]; // ok, has align 1\n+}"}, {"sha": "3041c73afba8819ddbe2b500d9ea4a5400d3347d", "filename": "src/test/run-pass/packed-struct-borrow-element.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bdb72edb5c431f2a122e8463e3de6d8415153028/src%2Ftest%2Frun-pass%2Fpacked-struct-borrow-element.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdb72edb5c431f2a122e8463e3de6d8415153028/src%2Ftest%2Frun-pass%2Fpacked-struct-borrow-element.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpacked-struct-borrow-element.rs?ref=bdb72edb5c431f2a122e8463e3de6d8415153028", "patch": "@@ -17,7 +17,7 @@ struct Foo {\n \n pub fn main() {\n     let foo = Foo { bar: 1, baz: 2 };\n-    let brw = &foo.baz;\n+    let brw = unsafe { &foo.baz };\n \n     assert_eq!(*brw, 2);\n }"}, {"sha": "876b74a042f8e04705e8f8cdc7d223cc19270f98", "filename": "src/test/run-pass/packed-struct-optimized-enum.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bdb72edb5c431f2a122e8463e3de6d8415153028/src%2Ftest%2Frun-pass%2Fpacked-struct-optimized-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdb72edb5c431f2a122e8463e3de6d8415153028/src%2Ftest%2Frun-pass%2Fpacked-struct-optimized-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpacked-struct-optimized-enum.rs?ref=bdb72edb5c431f2a122e8463e3de6d8415153028", "patch": "@@ -9,8 +9,12 @@\n // except according to those terms.\n \n #[repr(packed)]\n-#[derive(Copy, Clone)]\n-struct Packed<T>(T);\n+struct Packed<T: Copy>(T);\n+\n+impl<T: Copy> Copy for Packed<T> {}\n+impl<T: Copy> Clone for Packed<T> {\n+    fn clone(&self) -> Self { *self }\n+}\n \n fn main() {\n     let one = (Some(Packed((&(), 0))), true);"}]}