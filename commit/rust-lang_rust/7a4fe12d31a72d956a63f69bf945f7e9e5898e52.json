{"sha": "7a4fe12d31a72d956a63f69bf945f7e9e5898e52", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdhNGZlMTJkMzFhNzJkOTU2YTYzZjY5YmY5NDVmN2U5ZTU4OThlNTI=", "commit": {"author": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2019-11-28T20:35:03Z"}, "committer": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2019-12-16T11:07:31Z"}, "message": "Rustup to rustc 1.41.0-nightly (e87a205c2 2019-11-27)", "tree": {"sha": "27f4383e18c4d767a14cdba833aef56b3596ad03", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/27f4383e18c4d767a14cdba833aef56b3596ad03"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7a4fe12d31a72d956a63f69bf945f7e9e5898e52", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7a4fe12d31a72d956a63f69bf945f7e9e5898e52", "html_url": "https://github.com/rust-lang/rust/commit/7a4fe12d31a72d956a63f69bf945f7e9e5898e52", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7a4fe12d31a72d956a63f69bf945f7e9e5898e52/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b86eb2e8ba3f442a2168406fc75e1f41cdc9ccc7", "url": "https://api.github.com/repos/rust-lang/rust/commits/b86eb2e8ba3f442a2168406fc75e1f41cdc9ccc7", "html_url": "https://github.com/rust-lang/rust/commit/b86eb2e8ba3f442a2168406fc75e1f41cdc9ccc7"}], "stats": {"total": 126, "additions": 72, "deletions": 54}, "files": [{"sha": "50cae4d46e2cadad722fd48208734b030d516883", "filename": "src/debuginfo/mod.rs", "status": "modified", "additions": 72, "deletions": 54, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/7a4fe12d31a72d956a63f69bf945f7e9e5898e52/src%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a4fe12d31a72d956a63f69bf945f7e9e5898e52/src%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdebuginfo%2Fmod.rs?ref=7a4fe12d31a72d956a63f69bf945f7e9e5898e52", "patch": "@@ -3,8 +3,9 @@ mod line_info;\n \n use crate::prelude::*;\n \n-use cranelift::codegen::ir::{StackSlots, ValueLoc};\n+use cranelift::codegen::ir::{StackSlots, ValueLabel, ValueLoc};\n use cranelift::codegen::isa::RegUnit;\n+use cranelift::codegen::ValueLocRange;\n \n use gimli::write::{\n     self, Address, AttributeValue, DwarfUnit, Expression, LineProgram, LineString, Location,\n@@ -228,22 +229,14 @@ impl<'a, 'tcx> FunctionDebugContext<'a, 'tcx> {\n         }\n     }\n \n-    fn define_local(&mut self, local: mir::Local) -> UnitEntryId {\n-        let local_decl = &self.mir.local_decls[local];\n-\n+    fn define_local(&mut self, name: String, ty: Ty<'tcx>) -> UnitEntryId {\n         let ty = self.debug_context.tcx.subst_and_normalize_erasing_regions(\n             self.instance.substs,\n             ty::ParamEnv::reveal_all(),\n-            &local_decl.ty,\n+            &ty,\n         );\n         let dw_ty = self.debug_context.dwarf_ty(ty);\n \n-        let name = if let Some(name) = local_decl.name {\n-            format!(\"{}{:?}\", name.as_str(), local)\n-        } else {\n-            format!(\"{:?}\", local)\n-        };\n-\n         let var_id = self\n             .debug_context\n             .dwarf\n@@ -280,57 +273,82 @@ impl<'a, 'tcx> FunctionDebugContext<'a, 'tcx> {\n         let value_labels_ranges = context.build_value_labels_ranges(isa).unwrap();\n \n         for (local, _local_decl) in self.mir.local_decls.iter_enumerated() {\n-            let var_id = self.define_local(local);\n-            let value_label = cranelift::codegen::ir::ValueLabel::from_u32(local.as_u32());\n-\n-            let location = match local_map[&local].inner() {\n-                CPlaceInner::Var(_) => {\n-                    if let Some(value_loc_ranges) = value_labels_ranges.get(&value_label) {\n-                        let loc_list = LocationList(\n-                            value_loc_ranges\n-                                .iter()\n-                                .map(|value_loc_range| Location::StartEnd {\n-                                    begin: Address::Symbol {\n-                                        symbol: self.symbol,\n-                                        addend: i64::from(value_loc_range.start),\n-                                    },\n-                                    end: Address::Symbol {\n-                                        symbol: self.symbol,\n-                                        addend: i64::from(value_loc_range.end),\n-                                    },\n-                                    data: Expression(\n-                                        translate_loc(value_loc_range.loc, &context.func.stack_slots).unwrap(),\n-                                    ),\n-                                })\n-                                .collect(),\n-                        );\n-                        let loc_list_id = self.debug_context.dwarf.unit.locations.add(loc_list);\n-\n-                        AttributeValue::LocationListRef(loc_list_id)\n-                    } else {\n-                        // FIXME set value labels for unused locals\n-\n-                        AttributeValue::Exprloc(Expression(vec![]))\n-                    }\n-                }\n-                CPlaceInner::Addr(_, _) => {\n-                    // FIXME implement this (used by arguments and returns)\n-\n-                    AttributeValue::Exprloc(Expression(vec![]))\n-                }\n-                CPlaceInner::Stack(stack_slot) => {\n-                    AttributeValue::Exprloc(Expression(translate_loc(ValueLoc::Stack(*stack_slot), &context.func.stack_slots).unwrap()))\n-                }\n-                CPlaceInner::NoPlace => AttributeValue::Exprloc(Expression(vec![])),\n-            };\n+            let var_id = self.define_local(format!(\"{:?}\", local), &self.mir.local_decls[local].ty);\n+\n+            let location = place_location(\n+                self,\n+                context,\n+                &local_map,\n+                &value_labels_ranges,\n+                Place {\n+                    base: PlaceBase::Local(local),\n+                    projection: ty::List::empty(),\n+                },\n+            );\n \n             let var_entry = self.debug_context.dwarf.unit.get_mut(var_id);\n             var_entry.set(gimli::DW_AT_location, location);\n         }\n+\n+        // FIXME create locals for all entries in mir.var_debug_info\n     }\n }\n \n+fn place_location<'a, 'tcx>(\n+    func_debug_ctx: &mut FunctionDebugContext<'a, 'tcx>,\n+    context: &Context,\n+    local_map: &HashMap<mir::Local, CPlace<'tcx>>,\n+    value_labels_ranges: &HashMap<ValueLabel, Vec<ValueLocRange>>,\n+    place: Place<'tcx>,\n+) -> AttributeValue {\n+    assert!(place.projection.is_empty()); // FIXME implement them\n+    let cplace = match place.base {\n+        PlaceBase::Local(local) => local_map[&local],\n+        PlaceBase::Static(_) => bug!(\"Unenforced invariant that the place is based on a Local violated: {:?}\", place),\n+    };\n+\n+    match cplace.inner() {\n+        CPlaceInner::Var(local) => {\n+            let value_label = cranelift::codegen::ir::ValueLabel::from_u32(local.as_u32());\n+            if let Some(value_loc_ranges) = value_labels_ranges.get(&value_label) {\n+                let loc_list = LocationList(\n+                    value_loc_ranges\n+                        .iter()\n+                        .map(|value_loc_range| Location::StartEnd {\n+                            begin: Address::Symbol {\n+                                symbol: func_debug_ctx.symbol,\n+                                addend: i64::from(value_loc_range.start),\n+                            },\n+                            end: Address::Symbol {\n+                                symbol: func_debug_ctx.symbol,\n+                                addend: i64::from(value_loc_range.end),\n+                            },\n+                            data: Expression(\n+                                translate_loc(value_loc_range.loc, &context.func.stack_slots).unwrap(),\n+                            ),\n+                        })\n+                        .collect(),\n+                );\n+                let loc_list_id = func_debug_ctx.debug_context.dwarf.unit.locations.add(loc_list);\n+\n+                AttributeValue::LocationListRef(loc_list_id)\n+            } else {\n+                // FIXME set value labels for unused locals\n+\n+                AttributeValue::Exprloc(Expression(vec![]))\n+            }\n+        }\n+        CPlaceInner::Addr(_, _) => {\n+            // FIXME implement this (used by arguments and returns)\n \n+            AttributeValue::Exprloc(Expression(vec![]))\n+        }\n+        CPlaceInner::Stack(stack_slot) => {\n+            AttributeValue::Exprloc(Expression(translate_loc(ValueLoc::Stack(*stack_slot), &context.func.stack_slots).unwrap()))\n+        }\n+        CPlaceInner::NoPlace => AttributeValue::Exprloc(Expression(vec![])),\n+    }\n+}\n \n \n "}]}