{"sha": "266b878334cecce3a0636ddbb95318f7a5669f45", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI2NmI4NzgzMzRjZWNjZTNhMDYzNmRkYmI5NTMxOGY3YTU2NjlmNDU=", "commit": {"author": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2019-08-14T02:09:28Z"}, "committer": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2019-08-21T18:52:38Z"}, "message": "clean up", "tree": {"sha": "a054efeba86505a5aded83093e392a4fbcfacde4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a054efeba86505a5aded83093e392a4fbcfacde4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/266b878334cecce3a0636ddbb95318f7a5669f45", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/266b878334cecce3a0636ddbb95318f7a5669f45", "html_url": "https://github.com/rust-lang/rust/commit/266b878334cecce3a0636ddbb95318f7a5669f45", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/266b878334cecce3a0636ddbb95318f7a5669f45/comments", "author": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "committer": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0e668e0496fcc13fa042be416b64ba6823669cca", "url": "https://api.github.com/repos/rust-lang/rust/commits/0e668e0496fcc13fa042be416b64ba6823669cca", "html_url": "https://github.com/rust-lang/rust/commit/0e668e0496fcc13fa042be416b64ba6823669cca"}], "stats": {"total": 230, "additions": 162, "deletions": 68}, "files": [{"sha": "b7615fef04909f90c801369c41bcf4ed7ce1c9ee", "filename": "src/librustc_errors/emitter.rs", "status": "modified", "additions": 157, "deletions": 63, "changes": 220, "blob_url": "https://github.com/rust-lang/rust/blob/266b878334cecce3a0636ddbb95318f7a5669f45/src%2Flibrustc_errors%2Femitter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/266b878334cecce3a0636ddbb95318f7a5669f45/src%2Flibrustc_errors%2Femitter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Femitter.rs?ref=266b878334cecce3a0636ddbb95318f7a5669f45", "patch": "@@ -57,6 +57,80 @@ impl HumanReadableErrorType {\n     }\n }\n \n+#[derive(Clone, Copy, Debug)]\n+struct Margin {\n+    pub whitespace_left: usize,\n+    pub span_left: usize,\n+    pub span_right: usize,\n+    pub line_len: usize,\n+    pub computed_left: usize,\n+    pub computed_right: usize,\n+    pub column_width: usize,\n+    pub label_right: usize,\n+}\n+\n+impl Margin {\n+    fn new(\n+        whitespace_left: usize,\n+        span_left: usize,\n+        span_right: usize,\n+        label_right: usize,\n+    ) -> Self {\n+        Margin {\n+            whitespace_left,\n+            span_left,\n+            span_right,\n+            line_len: 0,\n+            computed_left: 0,\n+            computed_right: 0,\n+            column_width: 140,\n+            label_right,\n+        }\n+    }\n+\n+    fn was_cut_left(&self) -> bool {\n+        self.computed_left > 0\n+    }\n+\n+    fn was_cut_right(&self) -> bool {\n+        self.computed_right < self.line_len\n+    }\n+\n+    fn compute(&mut self) {\n+        self.computed_left = if self.whitespace_left > 20 {\n+            self.whitespace_left - 16 // We want some padding.\n+        } else {\n+            0\n+        };\n+        self.computed_right = self.column_width + self.computed_left;\n+\n+        if self.computed_right - self.computed_left > self.column_width {\n+            // Trimming only whitespace isn't enough, let's get craftier.\n+            if self.label_right - self.whitespace_left <= self.column_width {\n+                self.computed_left = self.whitespace_left;\n+                self.computed_right = self.computed_left + self.column_width;\n+            } else if self.label_right - self.span_left - 20 <= self.column_width {\n+                self.computed_left = self.span_left - 20;\n+                self.computed_right = self.computed_left + self.column_width;\n+            } else if self.label_right - self.span_left <= self.column_width {\n+                self.computed_left = self.span_left;\n+                self.computed_right = self.computed_left + self.column_width;\n+            } else if self.span_right - self.span_left <= self.column_width {\n+                self.computed_left = self.span_left;\n+                self.computed_right = self.computed_left + self.column_width;\n+            } else { // mostly give up but still don't show the full line\n+                self.computed_left = self.span_left;\n+                self.computed_right = self.span_right;\n+            }\n+        }\n+        self.computed_left = std::cmp::min(self.computed_left, self.line_len);\n+        if self.computed_right > self.line_len {\n+            self.computed_right = self.line_len;\n+        }\n+        self.computed_right = std::cmp::min(self.computed_right, self.line_len);\n+    }\n+}\n+\n const ANONYMIZED_LINE_NUM: &str = \"LL\";\n \n /// Emitter trait for emitting errors.\n@@ -179,7 +253,6 @@ pub struct EmitterWriter {\n     sm: Option<Lrc<SourceMapperDyn>>,\n     short_message: bool,\n     teach: bool,\n-    strip_margin: bool,\n     ui_testing: bool,\n }\n \n@@ -202,7 +275,6 @@ impl EmitterWriter {\n             sm: source_map,\n             short_message,\n             teach,\n-            strip_margin: false,\n             ui_testing: false,\n         }\n     }\n@@ -219,7 +291,6 @@ impl EmitterWriter {\n             sm: source_map,\n             short_message,\n             teach,\n-            strip_margin: false,\n             ui_testing: false,\n         }\n     }\n@@ -244,8 +315,7 @@ impl EmitterWriter {\n         line: &Line,\n         width_offset: usize,\n         code_offset: usize,\n-        margin: usize,\n-        right_span_margin: usize\n+        mut margin: Margin,\n     ) -> Vec<(usize, Style)> {\n         // Draw:\n         //\n@@ -260,6 +330,7 @@ impl EmitterWriter {\n         //   |  | when there's too much wasted space to the left, we trim it to focus where it matters\n         //   |  vertical divider between the column number and the code\n         //   column number\n+\n         if line.line_index == 0 {\n             return Vec::new();\n         }\n@@ -271,26 +342,27 @@ impl EmitterWriter {\n \n         let line_offset = buffer.num_lines();\n \n-        let left_margin = std::cmp::min(margin, source_string.len());\n-        let right_margin = if source_string.len() > right_span_margin + 120 {\n-            right_span_margin + 120\n-        } else {\n-            source_string.len()\n-        };\n+        margin.line_len = source_string.len();\n+        margin.compute();\n         // Create the source line we will highlight.\n         buffer.puts(\n             line_offset,\n             code_offset,\n-            &source_string[left_margin..right_margin], // On long lines, we strip the source line\n+            // On long lines, we strip the source line\n+            &source_string[margin.computed_left..margin.computed_right],\n             Style::Quotation,\n         );\n-        if margin > 0 { // We have stripped some code/whitespace from the beginning, make it clear.\n+        if margin.was_cut_left() { // We have stripped some code/whitespace from the beginning, make it clear.\n             buffer.puts(line_offset, code_offset, \"...\", Style::LineNumber);\n         }\n-        if right_margin != source_string.len() {\n+        if margin.was_cut_right() {\n             // We have stripped some code after the right-most span end, make it clear we did so.\n-            let offset = code_offset + right_margin - left_margin;\n-            buffer.puts(line_offset, offset, \"...\", Style::LineNumber);\n+            buffer.puts(\n+                line_offset,\n+                margin.computed_right - margin.computed_left + code_offset,\n+                \"...\",\n+                Style::LineNumber,\n+            );\n         }\n         buffer.puts(line_offset, 0, &self.maybe_anonymized(line.line_index), Style::LineNumber);\n \n@@ -546,13 +618,13 @@ impl EmitterWriter {\n                                '_',\n                                line_offset + pos,\n                                width_offset + depth,\n-                               code_offset + annotation.start_col - margin,\n+                               code_offset + annotation.start_col - margin.computed_left,\n                                style);\n                 }\n                 _ if self.teach => {\n                     buffer.set_style_range(line_offset,\n-                                           code_offset + annotation.start_col - margin,\n-                                           code_offset + annotation.end_col - margin,\n+                                           code_offset + annotation.start_col - margin.computed_left,\n+                                           code_offset + annotation.end_col - margin.computed_left,\n                                            style,\n                                            annotation.is_primary);\n                 }\n@@ -582,7 +654,7 @@ impl EmitterWriter {\n             if pos > 1 && (annotation.has_label() || annotation.takes_space()) {\n                 for p in line_offset + 1..=line_offset + pos {\n                     buffer.putc(p,\n-                                code_offset + annotation.start_col - margin,\n+                                code_offset + annotation.start_col - margin.computed_left,\n                                 '|',\n                                 style);\n                 }\n@@ -626,9 +698,9 @@ impl EmitterWriter {\n                 Style::LabelSecondary\n             };\n             let (pos, col) = if pos == 0 {\n-                (pos + 1, annotation.end_col + 1 - margin)\n+                (pos + 1, annotation.end_col + 1 - margin.computed_left)\n             } else {\n-                (pos + 2, annotation.start_col - margin)\n+                (pos + 2, annotation.start_col - margin.computed_left)\n             };\n             if let Some(ref label) = annotation.label {\n                 buffer.puts(line_offset + pos,\n@@ -670,7 +742,7 @@ impl EmitterWriter {\n             };\n             for p in annotation.start_col..annotation.end_col {\n                 buffer.putc(line_offset + 1,\n-                            code_offset + p - margin,\n+                            code_offset + p - margin.computed_left,\n                             underline,\n                             style);\n             }\n@@ -1010,22 +1082,30 @@ impl EmitterWriter {\n                     let buffer_msg_line_offset = buffer.num_lines();\n \n                     buffer.prepend(buffer_msg_line_offset, \"--> \", Style::LineNumber);\n-                    buffer.append(buffer_msg_line_offset,\n-                                  &format!(\"{}:{}:{}\",\n-                                           loc.file.name,\n-                                           sm.doctest_offset_line(&loc.file.name, loc.line),\n-                                           loc.col.0 + 1),\n-                                  Style::LineAndColumn);\n+                    buffer.append(\n+                        buffer_msg_line_offset,\n+                        &format!(\n+                            \"{}:{}:{}\",\n+                            loc.file.name,\n+                            sm.doctest_offset_line(&loc.file.name, loc.line),\n+                            loc.col.0 + 1,\n+                        ),\n+                        Style::LineAndColumn,\n+                    );\n                     for _ in 0..max_line_num_len {\n                         buffer.prepend(buffer_msg_line_offset, \" \", Style::NoStyle);\n                     }\n                 } else {\n-                    buffer.prepend(0,\n-                                   &format!(\"{}:{}:{}: \",\n-                                            loc.file.name,\n-                                            sm.doctest_offset_line(&loc.file.name, loc.line),\n-                                            loc.col.0 + 1),\n-                                   Style::LineAndColumn);\n+                    buffer.prepend(\n+                        0,\n+                        &format!(\n+                            \"{}:{}:{}: \",\n+                            loc.file.name,\n+                            sm.doctest_offset_line(&loc.file.name, loc.line),\n+                            loc.col.0 + 1,\n+                        ),\n+                        Style::LineAndColumn,\n+                    );\n                 }\n             } else if !self.short_message {\n                 // remember where we are in the output buffer for easy reference\n@@ -1069,7 +1149,7 @@ impl EmitterWriter {\n                 let mut multilines = FxHashMap::default();\n \n                 // Get the left-side margin to remove it\n-                let mut margin = std::usize::MAX;\n+                let mut whitespace_margin = std::usize::MAX;\n                 for line_idx in 0..annotated_file.lines.len() {\n                     let file = annotated_file.file.clone();\n                     let line = &annotated_file.lines[line_idx];\n@@ -1079,14 +1159,15 @@ impl EmitterWriter {\n                             .take_while(|c| c.is_whitespace())\n                             .count();\n                         if source_string.chars().any(|c| !c.is_whitespace()) {\n-                            margin = std::cmp::min(margin, leading_whitespace);\n+                            whitespace_margin = std::cmp::min(\n+                                whitespace_margin,\n+                                leading_whitespace,\n+                            );\n                         }\n                     }\n                 }\n-                if margin >= 20 { // On errors with generous margins, trim it\n-                    margin = margin - 16; // Keep at least 4 spaces margin\n-                } else if margin == std::usize::MAX || !self.strip_margin {\n-                    margin = 0;\n+                if whitespace_margin == std::usize::MAX {\n+                    whitespace_margin = 0;\n                 }\n \n                 // Left-most column any visible span points at.\n@@ -1100,18 +1181,27 @@ impl EmitterWriter {\n                 if span_left_margin == std::usize::MAX {\n                     span_left_margin = 0;\n                 }\n-                if span_left_margin > 160 {\n-                    margin = std::cmp::max(margin, span_left_margin - 100);\n-                }\n \n                 // Right-most column any visible span points at.\n                 let mut span_right_margin = 0;\n+                let mut label_right_margin = 0;\n                 for line in &annotated_file.lines {\n                     for ann in &line.annotations {\n                         span_right_margin = std::cmp::max(span_right_margin, ann.start_col);\n                         span_right_margin = std::cmp::max(span_right_margin, ann.end_col);\n+                        label_right_margin = std::cmp::max(\n+                            label_right_margin,\n+                            // TODO: account for labels not in the same line\n+                            ann.end_col + ann.label.as_ref().map(|l| l.len() + 1).unwrap_or(0),\n+                        );\n                     }\n                 }\n+                let margin = Margin::new(\n+                    whitespace_margin,\n+                    span_left_margin,\n+                    span_right_margin,\n+                    label_right_margin,\n+                );\n \n                 // Next, output the annotate source for this file\n                 for line_idx in 0..annotated_file.lines.len() {\n@@ -1131,7 +1221,6 @@ impl EmitterWriter {\n                         width_offset,\n                         code_offset,\n                         margin,\n-                        span_right_margin,\n                     );\n \n                     let mut to_add = FxHashMap::default();\n@@ -1179,24 +1268,29 @@ impl EmitterWriter {\n \n                             let last_buffer_line_num = buffer.num_lines();\n \n-                            buffer.puts(last_buffer_line_num,\n-                                        0,\n-                                        &self.maybe_anonymized(annotated_file.lines[line_idx + 1]\n-                                                                             .line_index - 1),\n-                                        Style::LineNumber);\n-                            draw_col_separator(&mut buffer,\n-                                               last_buffer_line_num,\n-                                               1 + max_line_num_len);\n-                            let left_margin = std::cmp::min(margin, unannotated_line.len());\n-                            let right_margin = if unannotated_line.len() > span_right_margin + 120 {\n-                                span_right_margin + 120\n-                            } else {\n-                                unannotated_line.len()\n-                            };\n-                            buffer.puts(last_buffer_line_num,\n-                                        code_offset,\n-                                        &unannotated_line[left_margin..right_margin],\n-                                        Style::Quotation);\n+                            buffer.puts(\n+                                last_buffer_line_num,\n+                                0,\n+                                &self.maybe_anonymized(\n+                                    annotated_file.lines[line_idx + 1].line_index - 1,\n+                                ),\n+                                Style::LineNumber,\n+                            );\n+                            draw_col_separator(\n+                                &mut buffer,\n+                                last_buffer_line_num,\n+                                1 + max_line_num_len,\n+                            );\n+\n+                            let mut margin = margin;\n+                            margin.line_len = unannotated_line.len();\n+                            margin.compute();\n+                            buffer.puts(\n+                                last_buffer_line_num,\n+                                code_offset,\n+                                &unannotated_line[margin.computed_left..margin.computed_right],\n+                                Style::Quotation,\n+                            );\n \n                             for (depth, style) in &multilines {\n                                 draw_multiline_line(&mut buffer,"}, {"sha": "483c364752b7b7b0c8923eb60da66d33bea1a269", "filename": "src/test/ui/moves/moves-based-on-type-no-recursive-stack-closure.stderr", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/266b878334cecce3a0636ddbb95318f7a5669f45/src%2Ftest%2Fui%2Fmoves%2Fmoves-based-on-type-no-recursive-stack-closure.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/266b878334cecce3a0636ddbb95318f7a5669f45/src%2Ftest%2Fui%2Fmoves%2Fmoves-based-on-type-no-recursive-stack-closure.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmoves%2Fmoves-based-on-type-no-recursive-stack-closure.stderr?ref=266b878334cecce3a0636ddbb95318f7a5669f45", "patch": "@@ -1,11 +1,11 @@\n error[E0499]: cannot borrow `*f` as mutable more than once at a time\n   --> $DIR/moves-based-on-type-no-recursive-stack-closure.rs:20:27\n    |\n-LL | ...             (f.c)(f, true);\n-   |                 ----- ^ second mutable borrow occurs here\n-   |                 |\n-   |                 first mutable borrow occurs here\n-   |                 first borrow later used by call\n+LL |                     (f.c)(f, true);\n+   |                     ----- ^ second mutable borrow occurs here\n+   |                     |\n+   |                     first mutable borrow occurs here\n+   |                     first borrow later used by call\n \n error[E0382]: borrow of moved value: `f`\n   --> $DIR/moves-based-on-type-no-recursive-stack-closure.rs:32:5"}]}