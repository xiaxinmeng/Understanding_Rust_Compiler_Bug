{"sha": "befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "node_id": "C_kwDOAAsO6NoAKGJlZmM5NGU2OTFhZTM2YzJmYWQxMzRlMWNkZjQ4M2I3YmRlZWI3NGY", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-10-21T10:21:17Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-10-21T10:21:17Z"}, "message": "Auto merge of #2607 - RalfJung:rustup, r=RalfJung\n\nRustup", "tree": {"sha": "295eb20dddee89560f4e67c9fc14937611688207", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/295eb20dddee89560f4e67c9fc14937611688207"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "html_url": "https://github.com/rust-lang/rust/commit/befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "53e357748675b387b6d25fe563b960cb7a7a0aea", "url": "https://api.github.com/repos/rust-lang/rust/commits/53e357748675b387b6d25fe563b960cb7a7a0aea", "html_url": "https://github.com/rust-lang/rust/commit/53e357748675b387b6d25fe563b960cb7a7a0aea"}, {"sha": "bb911ce32aeef2d691af993d0a1696d8402998a9", "url": "https://api.github.com/repos/rust-lang/rust/commits/bb911ce32aeef2d691af993d0a1696d8402998a9", "html_url": "https://github.com/rust-lang/rust/commit/bb911ce32aeef2d691af993d0a1696d8402998a9"}], "stats": {"total": 114107, "additions": 68317, "deletions": 45790}, "files": [{"sha": "771cef6e4d0d630bd5e1f0b58b14e5845bb2b8c5", "filename": ".github/workflows/ci.yml", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/.github%2Fworkflows%2Fci.yml", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/.github%2Fworkflows%2Fci.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.github%2Fworkflows%2Fci.yml?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "patch": "@@ -297,7 +297,7 @@ jobs:\n             os: ubuntu-20.04-xl\n           - name: dist-x86_64-apple\n             env:\n-              SCRIPT: \"./x.py dist --host=x86_64-apple-darwin --target=x86_64-apple-darwin\"\n+              SCRIPT: \"./x.py dist bootstrap --include-default-paths --host=x86_64-apple-darwin --target=x86_64-apple-darwin\"\n               RUST_CONFIGURE_ARGS: \"--enable-full-tools --enable-sanitizers --enable-profiler --set rust.jemalloc --set llvm.ninja=false\"\n               RUSTC_RETRY_LINKER_ON_SEGFAULT: 1\n               MACOSX_DEPLOYMENT_TARGET: 10.7\n@@ -308,7 +308,7 @@ jobs:\n             os: macos-latest\n           - name: dist-apple-various\n             env:\n-              SCRIPT: \"./x.py dist --host='' --target=aarch64-apple-ios,x86_64-apple-ios,aarch64-apple-ios-sim\"\n+              SCRIPT: \"./x.py dist bootstrap --include-default-paths --host='' --target=aarch64-apple-ios,x86_64-apple-ios,aarch64-apple-ios-sim\"\n               RUST_CONFIGURE_ARGS: \"--enable-sanitizers --enable-profiler --set rust.jemalloc --set llvm.ninja=false\"\n               RUSTC_RETRY_LINKER_ON_SEGFAULT: 1\n               MACOSX_DEPLOYMENT_TARGET: 10.7\n@@ -318,7 +318,7 @@ jobs:\n             os: macos-latest\n           - name: dist-x86_64-apple-alt\n             env:\n-              SCRIPT: \"./x.py dist\"\n+              SCRIPT: \"./x.py dist bootstrap --include-default-paths\"\n               RUST_CONFIGURE_ARGS: \"--enable-extended --enable-profiler --set rust.jemalloc --set llvm.ninja=false\"\n               RUSTC_RETRY_LINKER_ON_SEGFAULT: 1\n               MACOSX_DEPLOYMENT_TARGET: 10.7\n@@ -350,7 +350,7 @@ jobs:\n             os: macos-latest\n           - name: dist-aarch64-apple\n             env:\n-              SCRIPT: \"./x.py dist --stage 2\"\n+              SCRIPT: \"./x.py dist bootstrap --include-default-paths --stage 2\"\n               RUST_CONFIGURE_ARGS: \"--build=x86_64-apple-darwin --host=aarch64-apple-darwin --target=aarch64-apple-darwin --enable-full-tools --enable-sanitizers --enable-profiler --disable-docs --set rust.jemalloc --set llvm.ninja=false\"\n               RUSTC_RETRY_LINKER_ON_SEGFAULT: 1\n               USE_XCODE_CLANG: 1\n@@ -424,33 +424,33 @@ jobs:\n           - name: dist-x86_64-msvc\n             env:\n               RUST_CONFIGURE_ARGS: \"--build=x86_64-pc-windows-msvc --host=x86_64-pc-windows-msvc --target=x86_64-pc-windows-msvc --enable-full-tools --enable-profiler\"\n-              SCRIPT: PGO_HOST=x86_64-pc-windows-msvc src/ci/pgo.sh python x.py dist\n+              SCRIPT: PGO_HOST=x86_64-pc-windows-msvc src/ci/pgo.sh python x.py dist bootstrap --include-default-paths\n               DIST_REQUIRE_ALL_TOOLS: 1\n             os: windows-latest-xl\n           - name: dist-i686-msvc\n             env:\n               RUST_CONFIGURE_ARGS: \"--build=i686-pc-windows-msvc --host=i686-pc-windows-msvc --target=i686-pc-windows-msvc,i586-pc-windows-msvc --enable-full-tools --enable-profiler\"\n-              SCRIPT: python x.py dist\n+              SCRIPT: python x.py dist bootstrap --include-default-paths\n               DIST_REQUIRE_ALL_TOOLS: 1\n             os: windows-latest-xl\n           - name: dist-aarch64-msvc\n             env:\n               RUST_CONFIGURE_ARGS: \"--build=x86_64-pc-windows-msvc --host=aarch64-pc-windows-msvc --enable-full-tools --enable-profiler\"\n-              SCRIPT: python x.py dist\n+              SCRIPT: python x.py dist bootstrap --include-default-paths\n               DIST_REQUIRE_ALL_TOOLS: 1\n               WINDOWS_SDK_20348_HACK: 1\n             os: windows-latest-xl\n           - name: dist-i686-mingw\n             env:\n               RUST_CONFIGURE_ARGS: \"--build=i686-pc-windows-gnu --enable-full-tools --enable-profiler --set llvm.allow-old-toolchain\"\n               NO_DOWNLOAD_CI_LLVM: 1\n-              SCRIPT: python x.py dist\n+              SCRIPT: python x.py dist bootstrap --include-default-paths\n               CUSTOM_MINGW: 1\n               DIST_REQUIRE_ALL_TOOLS: 1\n             os: windows-latest-xl\n           - name: dist-x86_64-mingw\n             env:\n-              SCRIPT: python x.py dist\n+              SCRIPT: python x.py dist bootstrap --include-default-paths\n               RUST_CONFIGURE_ARGS: \"--build=x86_64-pc-windows-gnu --enable-full-tools --enable-profiler --set llvm.allow-old-toolchain\"\n               NO_DOWNLOAD_CI_LLVM: 1\n               CUSTOM_MINGW: 1\n@@ -459,7 +459,7 @@ jobs:\n           - name: dist-x86_64-msvc-alt\n             env:\n               RUST_CONFIGURE_ARGS: \"--build=x86_64-pc-windows-msvc --enable-extended --enable-profiler\"\n-              SCRIPT: python x.py dist\n+              SCRIPT: python x.py dist bootstrap --include-default-paths\n             os: windows-latest-xl\n     timeout-minutes: 600\n     runs-on: \"${{ matrix.os }}\""}, {"sha": "11335879bd4a79774b44cd47b084e6294328eda1", "filename": "COPYRIGHT", "status": "modified", "additions": 271, "deletions": 161, "changes": 432, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/COPYRIGHT", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/COPYRIGHT", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/COPYRIGHT?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "patch": "@@ -23,65 +23,251 @@ The Rust Project includes packages written by third parties.\n The following third party packages are included, and carry\n their own copyright notices and license terms:\n \n-* LLVM. Code for this package is found in src/llvm-project.\n-\n-    Copyright (c) 2003-2013 University of Illinois at\n-    Urbana-Champaign.  All rights reserved.\n-\n-    Developed by:\n-\n-        LLVM Team\n-\n-        University of Illinois at Urbana-Champaign\n-\n-        http://llvm.org\n-\n-    Permission is hereby granted, free of charge, to any\n-    person obtaining a copy of this software and associated\n-    documentation files (the \"Software\"), to deal with the\n-    Software without restriction, including without\n-    limitation the rights to use, copy, modify, merge,\n-    publish, distribute, sublicense, and/or sell copies of\n-    the Software, and to permit persons to whom the Software\n-    is furnished to do so, subject to the following\n-    conditions:\n-\n-        * Redistributions of source code must retain the\n-          above copyright notice, this list of conditions\n-          and the following disclaimers.\n-\n-        * Redistributions in binary form must reproduce the\n-          above copyright notice, this list of conditions\n-          and the following disclaimers in the documentation\n-          and/or other materials provided with the\n-          distribution.\n-\n-        * Neither the names of the LLVM Team, University of\n-          Illinois at Urbana-Champaign, nor the names of its\n-          contributors may be used to endorse or promote\n-          products derived from this Software without\n-          specific prior written permission.\n-\n-    THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF\n-    ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED\n-    TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n-    PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT\n-    SHALL THE CONTRIBUTORS OR COPYRIGHT HOLDERS BE LIABLE\n-    FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n-    ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT\n-    OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n-    OTHER DEALINGS WITH THE SOFTWARE.\n-\n-* Additional libraries included in LLVM carry separate\n-  BSD-compatible licenses. See src/llvm-project/llvm/LICENSE.TXT\n-  for details.\n-\n-* compiler-rt, in src/compiler-rt is dual licensed under\n-  LLVM's license and MIT:\n-\n-    Copyright (c) 2009-2014 by the contributors listed in\n-    CREDITS.TXT\n-\n+* LLVM, located in src/llvm-project, is licensed under the following\n+  terms.\n+\n+    ==============================================================================\n+    The LLVM Project is under the Apache License v2.0 with LLVM Exceptions:\n+    ==============================================================================\n+\n+                                    Apache License\n+                              Version 2.0, January 2004\n+                            http://www.apache.org/licenses/\n+\n+        TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION\n+\n+        1. Definitions.\n+\n+          \"License\" shall mean the terms and conditions for use, reproduction,\n+          and distribution as defined by Sections 1 through 9 of this document.\n+\n+          \"Licensor\" shall mean the copyright owner or entity authorized by\n+          the copyright owner that is granting the License.\n+\n+          \"Legal Entity\" shall mean the union of the acting entity and all\n+          other entities that control, are controlled by, or are under common\n+          control with that entity. For the purposes of this definition,\n+          \"control\" means (i) the power, direct or indirect, to cause the\n+          direction or management of such entity, whether by contract or\n+          otherwise, or (ii) ownership of fifty percent (50%) or more of the\n+          outstanding shares, or (iii) beneficial ownership of such entity.\n+\n+          \"You\" (or \"Your\") shall mean an individual or Legal Entity\n+          exercising permissions granted by this License.\n+\n+          \"Source\" form shall mean the preferred form for making modifications,\n+          including but not limited to software source code, documentation\n+          source, and configuration files.\n+\n+          \"Object\" form shall mean any form resulting from mechanical\n+          transformation or translation of a Source form, including but\n+          not limited to compiled object code, generated documentation,\n+          and conversions to other media types.\n+\n+          \"Work\" shall mean the work of authorship, whether in Source or\n+          Object form, made available under the License, as indicated by a\n+          copyright notice that is included in or attached to the work\n+          (an example is provided in the Appendix below).\n+\n+          \"Derivative Works\" shall mean any work, whether in Source or Object\n+          form, that is based on (or derived from) the Work and for which the\n+          editorial revisions, annotations, elaborations, or other modifications\n+          represent, as a whole, an original work of authorship. For the purposes\n+          of this License, Derivative Works shall not include works that remain\n+          separable from, or merely link (or bind by name) to the interfaces of,\n+          the Work and Derivative Works thereof.\n+\n+          \"Contribution\" shall mean any work of authorship, including\n+          the original version of the Work and any modifications or additions\n+          to that Work or Derivative Works thereof, that is intentionally\n+          submitted to Licensor for inclusion in the Work by the copyright owner\n+          or by an individual or Legal Entity authorized to submit on behalf of\n+          the copyright owner. For the purposes of this definition, \"submitted\"\n+          means any form of electronic, verbal, or written communication sent\n+          to the Licensor or its representatives, including but not limited to\n+          communication on electronic mailing lists, source code control systems,\n+          and issue tracking systems that are managed by, or on behalf of, the\n+          Licensor for the purpose of discussing and improving the Work, but\n+          excluding communication that is conspicuously marked or otherwise\n+          designated in writing by the copyright owner as \"Not a Contribution.\"\n+\n+          \"Contributor\" shall mean Licensor and any individual or Legal Entity\n+          on behalf of whom a Contribution has been received by Licensor and\n+          subsequently incorporated within the Work.\n+\n+        2. Grant of Copyright License. Subject to the terms and conditions of\n+          this License, each Contributor hereby grants to You a perpetual,\n+          worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n+          copyright license to reproduce, prepare Derivative Works of,\n+          publicly display, publicly perform, sublicense, and distribute the\n+          Work and such Derivative Works in Source or Object form.\n+\n+        3. Grant of Patent License. Subject to the terms and conditions of\n+          this License, each Contributor hereby grants to You a perpetual,\n+          worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n+          (except as stated in this section) patent license to make, have made,\n+          use, offer to sell, sell, import, and otherwise transfer the Work,\n+          where such license applies only to those patent claims licensable\n+          by such Contributor that are necessarily infringed by their\n+          Contribution(s) alone or by combination of their Contribution(s)\n+          with the Work to which such Contribution(s) was submitted. If You\n+          institute patent litigation against any entity (including a\n+          cross-claim or counterclaim in a lawsuit) alleging that the Work\n+          or a Contribution incorporated within the Work constitutes direct\n+          or contributory patent infringement, then any patent licenses\n+          granted to You under this License for that Work shall terminate\n+          as of the date such litigation is filed.\n+\n+        4. Redistribution. You may reproduce and distribute copies of the\n+          Work or Derivative Works thereof in any medium, with or without\n+          modifications, and in Source or Object form, provided that You\n+          meet the following conditions:\n+\n+          (a) You must give any other recipients of the Work or\n+              Derivative Works a copy of this License; and\n+\n+          (b) You must cause any modified files to carry prominent notices\n+              stating that You changed the files; and\n+\n+          (c) You must retain, in the Source form of any Derivative Works\n+              that You distribute, all copyright, patent, trademark, and\n+              attribution notices from the Source form of the Work,\n+              excluding those notices that do not pertain to any part of\n+              the Derivative Works; and\n+\n+          (d) If the Work includes a \"NOTICE\" text file as part of its\n+              distribution, then any Derivative Works that You distribute must\n+              include a readable copy of the attribution notices contained\n+              within such NOTICE file, excluding those notices that do not\n+              pertain to any part of the Derivative Works, in at least one\n+              of the following places: within a NOTICE text file distributed\n+              as part of the Derivative Works; within the Source form or\n+              documentation, if provided along with the Derivative Works; or,\n+              within a display generated by the Derivative Works, if and\n+              wherever such third-party notices normally appear. The contents\n+              of the NOTICE file are for informational purposes only and\n+              do not modify the License. You may add Your own attribution\n+              notices within Derivative Works that You distribute, alongside\n+              or as an addendum to the NOTICE text from the Work, provided\n+              that such additional attribution notices cannot be construed\n+              as modifying the License.\n+\n+          You may add Your own copyright statement to Your modifications and\n+          may provide additional or different license terms and conditions\n+          for use, reproduction, or distribution of Your modifications, or\n+          for any such Derivative Works as a whole, provided Your use,\n+          reproduction, and distribution of the Work otherwise complies with\n+          the conditions stated in this License.\n+\n+        5. Submission of Contributions. Unless You explicitly state otherwise,\n+          any Contribution intentionally submitted for inclusion in the Work\n+          by You to the Licensor shall be under the terms and conditions of\n+          this License, without any additional terms or conditions.\n+          Notwithstanding the above, nothing herein shall supersede or modify\n+          the terms of any separate license agreement you may have executed\n+          with Licensor regarding such Contributions.\n+\n+        6. Trademarks. This License does not grant permission to use the trade\n+          names, trademarks, service marks, or product names of the Licensor,\n+          except as required for reasonable and customary use in describing the\n+          origin of the Work and reproducing the content of the NOTICE file.\n+\n+        7. Disclaimer of Warranty. Unless required by applicable law or\n+          agreed to in writing, Licensor provides the Work (and each\n+          Contributor provides its Contributions) on an \"AS IS\" BASIS,\n+          WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n+          implied, including, without limitation, any warranties or conditions\n+          of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A\n+          PARTICULAR PURPOSE. You are solely responsible for determining the\n+          appropriateness of using or redistributing the Work and assume any\n+          risks associated with Your exercise of permissions under this License.\n+\n+        8. Limitation of Liability. In no event and under no legal theory,\n+          whether in tort (including negligence), contract, or otherwise,\n+          unless required by applicable law (such as deliberate and grossly\n+          negligent acts) or agreed to in writing, shall any Contributor be\n+          liable to You for damages, including any direct, indirect, special,\n+          incidental, or consequential damages of any character arising as a\n+          result of this License or out of the use or inability to use the\n+          Work (including but not limited to damages for loss of goodwill,\n+          work stoppage, computer failure or malfunction, or any and all\n+          other commercial damages or losses), even if such Contributor\n+          has been advised of the possibility of such damages.\n+\n+        9. Accepting Warranty or Additional Liability. While redistributing\n+          the Work or Derivative Works thereof, You may choose to offer,\n+          and charge a fee for, acceptance of support, warranty, indemnity,\n+          or other liability obligations and/or rights consistent with this\n+          License. However, in accepting such obligations, You may act only\n+          on Your own behalf and on Your sole responsibility, not on behalf\n+          of any other Contributor, and only if You agree to indemnify,\n+          defend, and hold each Contributor harmless for any liability\n+          incurred by, or claims asserted against, such Contributor by reason\n+          of your accepting any such warranty or additional liability.\n+\n+        END OF TERMS AND CONDITIONS\n+\n+        APPENDIX: How to apply the Apache License to your work.\n+\n+          To apply the Apache License to your work, attach the following\n+          boilerplate notice, with the fields enclosed by brackets \"[]\"\n+          replaced with your own identifying information. (Don't include\n+          the brackets!)  The text should be enclosed in the appropriate\n+          comment syntax for the file format. We also recommend that a\n+          file or class name and description of purpose be included on the\n+          same \"printed page\" as the copyright notice for easier\n+          identification within third-party archives.\n+\n+        Copyright [yyyy] [name of copyright owner]\n+\n+        Licensed under the Apache License, Version 2.0 (the \"License\");\n+        you may not use this file except in compliance with the License.\n+        You may obtain a copy of the License at\n+\n+          http://www.apache.org/licenses/LICENSE-2.0\n+\n+        Unless required by applicable law or agreed to in writing, software\n+        distributed under the License is distributed on an \"AS IS\" BASIS,\n+        WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+        See the License for the specific language governing permissions and\n+        limitations under the License.\n+\n+\n+    ---- LLVM Exceptions to the Apache 2.0 License ----\n+\n+    As an exception, if, as a result of your compiling your source code, portions\n+    of this Software are embedded into an Object form of such source code, you\n+    may redistribute such embedded portions in such Object form without complying\n+    with the conditions of Sections 4(a), 4(b) and 4(d) of the License.\n+\n+    In addition, if you combine or link compiled forms of this Software with\n+    software that is licensed under the GPLv2 (\"Combined Software\") and if a\n+    court of competent jurisdiction determines that the patent provision (Section\n+    3), the indemnity provision (Section 9) or other Section of the License\n+    conflicts with the conditions of the GPLv2, you may retroactively and\n+    prospectively choose to deem waived or otherwise exclude such Section(s) of\n+    the License, but only in their entirety and only with respect to the Combined\n+    Software.\n+\n+    ==============================================================================\n+    Software from third parties included in the LLVM Project:\n+    ==============================================================================\n+    The LLVM Project contains third party software which is under different license\n+    terms. All such code will be identified clearly using at least one of two\n+    mechanisms:\n+    1) It will be in a separate directory tree with its own `LICENSE.txt` or\n+      `LICENSE` file at the top containing the specific license and restrictions\n+      which apply to that software, or\n+    2) It will contain specific license and restriction terms at the top of every\n+      file.\n+\n+    ==============================================================================\n+    Legacy LLVM License (https://llvm.org/docs/DeveloperPolicy.html#legacy):\n+    ==============================================================================\n+    University of Illinois/NCSA\n+    Open Source License\n+\n+    Copyright (c) 2003-2019 University of Illinois at Urbana-Champaign.\n     All rights reserved.\n \n     Developed by:\n@@ -92,70 +278,32 @@ their own copyright notices and license terms:\n \n         http://llvm.org\n \n-    Permission is hereby granted, free of charge, to any\n-    person obtaining a copy of this software and associated\n-    documentation files (the \"Software\"), to deal with the\n-    Software without restriction, including without\n-    limitation the rights to use, copy, modify, merge,\n-    publish, distribute, sublicense, and/or sell copies of\n-    the Software, and to permit persons to whom the Software\n-    is furnished to do so, subject to the following\n-    conditions:\n-\n-        * Redistributions of source code must retain the\n-          above copyright notice, this list of conditions\n-          and the following disclaimers.\n-\n-        * Redistributions in binary form must reproduce the\n-          above copyright notice, this list of conditions\n-          and the following disclaimers in the documentation\n-          and/or other materials provided with the\n-          distribution.\n-\n-        * Neither the names of the LLVM Team, University of\n-          Illinois at Urbana-Champaign, nor the names of its\n-          contributors may be used to endorse or promote\n-          products derived from this Software without\n-          specific prior written permission.\n-\n-    THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF\n-    ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED\n-    TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n-    PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT\n-    SHALL THE CONTRIBUTORS OR COPYRIGHT HOLDERS BE LIABLE\n-    FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n-    ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT\n-    OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n-    OTHER DEALINGS WITH THE SOFTWARE.\n-\n-    ========================================================\n-\n-    Copyright (c) 2009-2014 by the contributors listed in\n-    CREDITS.TXT\n-\n-    Permission is hereby granted, free of charge, to any\n-    person obtaining a copy of this software and associated\n-    documentation files (the \"Software\"), to deal in the\n-    Software without restriction, including without\n-    limitation the rights to use, copy, modify, merge,\n-    publish, distribute, sublicense, and/or sell copies of\n-    the Software, and to permit persons to whom the Software\n-    is furnished to do so, subject to the following\n-    conditions:\n-\n-    The above copyright notice and this permission notice\n-    shall be included in all copies or substantial portions\n-    of the Software.\n-\n-    THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF\n-    ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED\n-    TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n-    PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT\n-    SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\n-    CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n-    OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR\n-    IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n-    DEALINGS IN THE SOFTWARE.\n+    Permission is hereby granted, free of charge, to any person obtaining a copy of\n+    this software and associated documentation files (the \"Software\"), to deal with\n+    the Software without restriction, including without limitation the rights to\n+    use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\n+    of the Software, and to permit persons to whom the Software is furnished to do\n+    so, subject to the following conditions:\n+\n+        * Redistributions of source code must retain the above copyright notice,\n+          this list of conditions and the following disclaimers.\n+\n+        * Redistributions in binary form must reproduce the above copyright notice,\n+          this list of conditions and the following disclaimers in the\n+          documentation and/or other materials provided with the distribution.\n+\n+        * Neither the names of the LLVM Team, University of Illinois at\n+          Urbana-Champaign, nor the names of its contributors may be used to\n+          endorse or promote products derived from this Software without specific\n+          prior written permission.\n+\n+    THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\n+    FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE\n+    CONTRIBUTORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH THE\n+    SOFTWARE.\n \n * Portions of the FFI code for interacting with the native ABI\n   is derived from the Clay programming language, which carries\n@@ -191,41 +339,3 @@ their own copyright notices and license terms:\n     NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE\n     USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY\n     OF SUCH DAMAGE.\n-\n-* libbacktrace, under src/libbacktrace:\n-\n-    Copyright (C) 2012-2014 Free Software Foundation, Inc.\n-    Written by Ian Lance Taylor, Google.\n-\n-    Redistribution and use in source and binary forms, with\n-    or without modification, are permitted provided that the\n-    following conditions are met:\n-\n-        (1) Redistributions of source code must retain the\n-        above copyright notice, this list of conditions and\n-        the following disclaimer.\n-\n-        (2) Redistributions in binary form must reproduce\n-        the above copyright notice, this list of conditions\n-        and the following disclaimer in the documentation\n-        and/or other materials provided with the\n-        distribution.\n-\n-        (3) The name of the author may not be used to\n-        endorse or promote products derived from this\n-        software without specific prior written permission.\n-\n-    THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND\n-    ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n-    LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY\n-    AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN\n-    NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,\n-    INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n-    CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n-    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n-    USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n-    CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n-    CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n-    NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE\n-    USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY\n-    OF SUCH DAMAGE.  */"}, {"sha": "d5acab8139c982be60fa0ed507c3c56486ab0a0e", "filename": "Cargo.lock", "status": "modified", "additions": 115, "deletions": 67, "changes": 182, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "patch": "@@ -288,7 +288,7 @@ dependencies = [\n \n [[package]]\n name = \"cargo\"\n-version = \"0.66.0\"\n+version = \"0.67.0\"\n dependencies = [\n  \"anyhow\",\n  \"atty\",\n@@ -297,7 +297,7 @@ dependencies = [\n  \"cargo-test-macro\",\n  \"cargo-test-support\",\n  \"cargo-util\",\n- \"clap\",\n+ \"clap 4.0.15\",\n  \"crates-io\",\n  \"curl\",\n  \"curl-sys\",\n@@ -330,8 +330,10 @@ dependencies = [\n  \"pretty_env_logger\",\n  \"rustc-workspace-hack\",\n  \"rustfix\",\n+ \"same-file\",\n  \"semver\",\n  \"serde\",\n+ \"serde-value\",\n  \"serde_ignored\",\n  \"serde_json\",\n  \"shell-escape\",\n@@ -385,7 +387,7 @@ dependencies = [\n  \"directories\",\n  \"rustc-build-sysroot\",\n  \"rustc-workspace-hack\",\n- \"rustc_tools_util 0.2.1\",\n+ \"rustc_tools_util\",\n  \"rustc_version\",\n  \"serde\",\n  \"serde_json\",\n@@ -418,6 +420,7 @@ dependencies = [\n  \"anyhow\",\n  \"cargo-test-macro\",\n  \"cargo-util\",\n+ \"crates-io\",\n  \"filetime\",\n  \"flate2\",\n  \"git2\",\n@@ -436,7 +439,7 @@ dependencies = [\n \n [[package]]\n name = \"cargo-util\"\n-version = \"0.2.1\"\n+version = \"0.2.2\"\n dependencies = [\n  \"anyhow\",\n  \"core-foundation\",\n@@ -589,21 +592,34 @@ dependencies = [\n  \"atty\",\n  \"bitflags\",\n  \"clap_derive\",\n- \"clap_lex\",\n+ \"clap_lex 0.2.2\",\n  \"indexmap\",\n  \"once_cell\",\n  \"strsim\",\n  \"termcolor\",\n  \"textwrap\",\n ]\n \n+[[package]]\n+name = \"clap\"\n+version = \"4.0.15\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"6bf8832993da70a4c6d13c581f4463c2bdda27b9bf1c5498dc4365543abe6d6f\"\n+dependencies = [\n+ \"atty\",\n+ \"bitflags\",\n+ \"clap_lex 0.3.0\",\n+ \"strsim\",\n+ \"termcolor\",\n+]\n+\n [[package]]\n name = \"clap_complete\"\n version = \"3.1.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"df6f3613c0a3cddfd78b41b10203eb322cb29b600cbdf808a7d3db95691b8e25\"\n dependencies = [\n- \"clap\",\n+ \"clap 3.2.20\",\n ]\n \n [[package]]\n@@ -628,9 +644,18 @@ dependencies = [\n  \"os_str_bytes\",\n ]\n \n+[[package]]\n+name = \"clap_lex\"\n+version = \"0.3.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"0d4198f73e42b4936b35b5bb248d81d2b595ecb170da0bac7655c54eedfa8da8\"\n+dependencies = [\n+ \"os_str_bytes\",\n+]\n+\n [[package]]\n name = \"clippy\"\n-version = \"0.1.65\"\n+version = \"0.1.66\"\n dependencies = [\n  \"clippy_lints\",\n  \"clippy_utils\",\n@@ -645,7 +670,7 @@ dependencies = [\n  \"regex\",\n  \"rustc-semver\",\n  \"rustc-workspace-hack\",\n- \"rustc_tools_util 0.2.0\",\n+ \"rustc_tools_util\",\n  \"semver\",\n  \"serde\",\n  \"syn\",\n@@ -662,7 +687,7 @@ name = \"clippy_dev\"\n version = \"0.0.1\"\n dependencies = [\n  \"aho-corasick\",\n- \"clap\",\n+ \"clap 3.2.20\",\n  \"indoc\",\n  \"itertools\",\n  \"opener\",\n@@ -673,7 +698,7 @@ dependencies = [\n \n [[package]]\n name = \"clippy_lints\"\n-version = \"0.1.65\"\n+version = \"0.1.66\"\n dependencies = [\n  \"cargo_metadata 0.14.0\",\n  \"clippy_utils\",\n@@ -695,7 +720,7 @@ dependencies = [\n \n [[package]]\n name = \"clippy_utils\"\n-version = \"0.1.65\"\n+version = \"0.1.66\"\n dependencies = [\n  \"arrayvec\",\n  \"if_chain\",\n@@ -771,9 +796,9 @@ dependencies = [\n \n [[package]]\n name = \"compiler_builtins\"\n-version = \"0.1.79\"\n+version = \"0.1.82\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"4f873ce2bd3550b0b565f878b3d04ea8253f4259dc3d20223af2e1ba86f5ecca\"\n+checksum = \"18cd7635fea7bb481ea543b392789844c1ad581299da70184c7175ce3af76603\"\n dependencies = [\n  \"cc\",\n  \"rustc-std-workspace-core\",\n@@ -804,9 +829,9 @@ dependencies = [\n \n [[package]]\n name = \"compiletest_rs\"\n-version = \"0.8.0\"\n+version = \"0.9.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"262134ef87408da1ddfe45e33daa0ca43b75286d6b1076446e602d264cf9847e\"\n+checksum = \"70489bbb718aea4f92e5f48f2e3b5be670c2051de30e57cb6e5377b4aa08b372\"\n dependencies = [\n  \"diff\",\n  \"filetime\",\n@@ -1775,7 +1800,7 @@ name = \"installer\"\n version = \"0.0.0\"\n dependencies = [\n  \"anyhow\",\n- \"clap\",\n+ \"clap 3.2.20\",\n  \"flate2\",\n  \"lazy_static\",\n  \"num_cpus\",\n@@ -2118,7 +2143,7 @@ dependencies = [\n  \"ammonia\",\n  \"anyhow\",\n  \"chrono\",\n- \"clap\",\n+ \"clap 3.2.20\",\n  \"clap_complete\",\n  \"elasticlunr-rs\",\n  \"env_logger 0.9.0\",\n@@ -2387,6 +2412,15 @@ dependencies = [\n  \"vcpkg\",\n ]\n \n+[[package]]\n+name = \"ordered-float\"\n+version = \"2.10.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"7940cf2ca942593318d07fcf2596cdca60a85c9e7fab408a5e21a4f9dcd40d87\"\n+dependencies = [\n+ \"num-traits\",\n+]\n+\n [[package]]\n name = \"os_info\"\n version = \"3.5.0\"\n@@ -2618,9 +2652,9 @@ checksum = \"8b870d8c151b6f2fb93e84a13146138f05d02ed11c7e7c54f8826aaaf7c9f184\"\n \n [[package]]\n name = \"pkg-config\"\n-version = \"0.3.18\"\n+version = \"0.3.25\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"d36492546b6af1463394d46f0c834346f31548646f6ba10849802c9c9a27ac33\"\n+checksum = \"1df8c4ec4b0627e53bdf214615ad287367e482558cf84b109250b37464dc03ae\"\n \n [[package]]\n name = \"polonius-engine\"\n@@ -2687,11 +2721,11 @@ checksum = \"dbf0c48bc1d91375ae5c3cd81e3722dff1abcf81a30960240640d223f59fe0e5\"\n \n [[package]]\n name = \"proc-macro2\"\n-version = \"1.0.37\"\n+version = \"1.0.46\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"ec757218438d5fda206afc041538b2f6d889286160d649a86a24d37e1235afd1\"\n+checksum = \"94e2ef8dbfc347b10c094890f778ee2e36ca9bb4262e86dc99cd217e35f3470b\"\n dependencies = [\n- \"unicode-xid\",\n+ \"unicode-ident\",\n ]\n \n [[package]]\n@@ -2981,7 +3015,7 @@ dependencies = [\n name = \"rustbook\"\n version = \"0.1.0\"\n dependencies = [\n- \"clap\",\n+ \"clap 3.2.20\",\n  \"env_logger 0.7.1\",\n  \"mdbook\",\n ]\n@@ -3079,7 +3113,7 @@ name = \"rustc-workspace-hack\"\n version = \"1.0.0\"\n dependencies = [\n  \"bstr\",\n- \"clap\",\n+ \"clap 3.2.20\",\n  \"libz-sys\",\n  \"regex\",\n  \"serde_json\",\n@@ -3243,7 +3277,6 @@ dependencies = [\n  \"bitflags\",\n  \"cstr\",\n  \"libc\",\n- \"libloading\",\n  \"measureme\",\n  \"object 0.29.0\",\n  \"rustc-demangle\",\n@@ -3266,6 +3299,7 @@ dependencies = [\n  \"rustc_symbol_mangling\",\n  \"rustc_target\",\n  \"smallvec\",\n+ \"tempfile\",\n  \"tracing\",\n ]\n \n@@ -3375,6 +3409,7 @@ dependencies = [\n  \"rustc_errors\",\n  \"rustc_feature\",\n  \"rustc_hir\",\n+ \"rustc_hir_analysis\",\n  \"rustc_hir_pretty\",\n  \"rustc_interface\",\n  \"rustc_lint\",\n@@ -3388,7 +3423,6 @@ dependencies = [\n  \"rustc_session\",\n  \"rustc_span\",\n  \"rustc_target\",\n- \"rustc_typeck\",\n  \"serde_json\",\n  \"tracing\",\n  \"winapi\",\n@@ -3419,6 +3453,8 @@ version = \"0.0.0\"\n dependencies = [\n  \"annotate-snippets\",\n  \"atty\",\n+ \"rustc_ast\",\n+ \"rustc_ast_pretty\",\n  \"rustc_data_structures\",\n  \"rustc_error_messages\",\n  \"rustc_hir\",\n@@ -3493,6 +3529,34 @@ dependencies = [\n  \"tracing\",\n ]\n \n+[[package]]\n+name = \"rustc_hir_analysis\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"rustc_arena\",\n+ \"rustc_ast\",\n+ \"rustc_attr\",\n+ \"rustc_data_structures\",\n+ \"rustc_errors\",\n+ \"rustc_feature\",\n+ \"rustc_graphviz\",\n+ \"rustc_hir\",\n+ \"rustc_hir_pretty\",\n+ \"rustc_index\",\n+ \"rustc_infer\",\n+ \"rustc_lint\",\n+ \"rustc_macros\",\n+ \"rustc_middle\",\n+ \"rustc_serialize\",\n+ \"rustc_session\",\n+ \"rustc_span\",\n+ \"rustc_target\",\n+ \"rustc_trait_selection\",\n+ \"rustc_type_ir\",\n+ \"smallvec\",\n+ \"tracing\",\n+]\n+\n [[package]]\n name = \"rustc_hir_pretty\"\n version = \"0.0.0\"\n@@ -3572,6 +3636,7 @@ dependencies = [\n  \"rustc_errors\",\n  \"rustc_expand\",\n  \"rustc_hir\",\n+ \"rustc_hir_analysis\",\n  \"rustc_incremental\",\n  \"rustc_lint\",\n  \"rustc_macros\",\n@@ -3594,7 +3659,6 @@ dependencies = [\n  \"rustc_trait_selection\",\n  \"rustc_traits\",\n  \"rustc_ty_utils\",\n- \"rustc_typeck\",\n  \"smallvec\",\n  \"tracing\",\n  \"winapi\",\n@@ -3719,8 +3783,6 @@ dependencies = [\n  \"either\",\n  \"gsgdt\",\n  \"polonius-engine\",\n- \"rand 0.8.5\",\n- \"rand_xoshiro\",\n  \"rustc-rayon\",\n  \"rustc-rayon-core\",\n  \"rustc_apfloat\",\n@@ -3904,12 +3966,12 @@ dependencies = [\n  \"rustc_data_structures\",\n  \"rustc_errors\",\n  \"rustc_hir\",\n+ \"rustc_hir_analysis\",\n  \"rustc_macros\",\n  \"rustc_middle\",\n  \"rustc_session\",\n  \"rustc_span\",\n  \"rustc_trait_selection\",\n- \"rustc_typeck\",\n  \"tracing\",\n ]\n \n@@ -4090,6 +4152,7 @@ version = \"0.0.0\"\n dependencies = [\n  \"bitflags\",\n  \"rustc_data_structures\",\n+ \"rustc_feature\",\n  \"rustc_index\",\n  \"rustc_macros\",\n  \"rustc_serialize\",\n@@ -4098,10 +4161,6 @@ dependencies = [\n  \"tracing\",\n ]\n \n-[[package]]\n-name = \"rustc_tools_util\"\n-version = \"0.2.0\"\n-\n [[package]]\n name = \"rustc_tools_util\"\n version = \"0.2.1\"\n@@ -4171,6 +4230,8 @@ dependencies = [\n name = \"rustc_ty_utils\"\n version = \"0.0.0\"\n dependencies = [\n+ \"rand 0.8.5\",\n+ \"rand_xoshiro\",\n  \"rustc_data_structures\",\n  \"rustc_errors\",\n  \"rustc_hir\",\n@@ -4198,35 +4259,6 @@ dependencies = [\n  \"smallvec\",\n ]\n \n-[[package]]\n-name = \"rustc_typeck\"\n-version = \"0.0.0\"\n-dependencies = [\n- \"rustc_arena\",\n- \"rustc_ast\",\n- \"rustc_attr\",\n- \"rustc_data_structures\",\n- \"rustc_errors\",\n- \"rustc_feature\",\n- \"rustc_graphviz\",\n- \"rustc_hir\",\n- \"rustc_hir_pretty\",\n- \"rustc_index\",\n- \"rustc_infer\",\n- \"rustc_lint\",\n- \"rustc_macros\",\n- \"rustc_middle\",\n- \"rustc_serialize\",\n- \"rustc_session\",\n- \"rustc_span\",\n- \"rustc_target\",\n- \"rustc_trait_selection\",\n- \"rustc_ty_utils\",\n- \"rustc_type_ir\",\n- \"smallvec\",\n- \"tracing\",\n-]\n-\n [[package]]\n name = \"rustc_version\"\n version = \"0.4.0\"\n@@ -4310,7 +4342,7 @@ dependencies = [\n  \"anyhow\",\n  \"bytecount\",\n  \"cargo_metadata 0.14.0\",\n- \"clap\",\n+ \"clap 3.2.20\",\n  \"derive-new\",\n  \"diff\",\n  \"dirs\",\n@@ -4423,6 +4455,16 @@ dependencies = [\n  \"serde_derive\",\n ]\n \n+[[package]]\n+name = \"serde-value\"\n+version = \"0.7.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"f3a1a3341211875ef120e117ea7fd5228530ae7e7036a779fdc9117be6b3282c\"\n+dependencies = [\n+ \"ordered-float\",\n+ \"serde\",\n+]\n+\n [[package]]\n name = \"serde_derive\"\n version = \"1.0.143\"\n@@ -4677,13 +4719,13 @@ checksum = \"73473c0e59e6d5812c5dfe2a064a6444949f089e20eec9a2e5506596494e4623\"\n \n [[package]]\n name = \"syn\"\n-version = \"1.0.91\"\n+version = \"1.0.102\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"b683b2b825c8eef438b77c36a06dc262294da3d5a5813fac20da149241dcd44d\"\n+checksum = \"3fcd952facd492f9be3ef0d0b7032a6e442ee9b361d4acc2b1d0c4aaa5f613a1\"\n dependencies = [\n  \"proc-macro2\",\n  \"quote\",\n- \"unicode-xid\",\n+ \"unicode-ident\",\n ]\n \n [[package]]\n@@ -5173,6 +5215,12 @@ dependencies = [\n  \"matches\",\n ]\n \n+[[package]]\n+name = \"unicode-ident\"\n+version = \"1.0.5\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"6ceab39d59e4c9499d4e5a8ee0e2735b891bb7308ac83dfb4e80cad195c9f6f3\"\n+\n [[package]]\n name = \"unicode-normalization\"\n version = \"0.1.22\""}, {"sha": "fcbf968182504ed73cd72ad3ef6dfb1b70a2ddc3", "filename": "compiler/rustc_ast/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_ast%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_ast%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2FCargo.toml?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "patch": "@@ -4,7 +4,6 @@ version = \"0.0.0\"\n edition = \"2021\"\n \n [lib]\n-doctest = false\n \n [dependencies]\n bitflags = \"1.2.1\""}, {"sha": "7112c26757717c1044f63a2d21e571a0cbea3e9a", "filename": "compiler/rustc_ast/src/ast.rs", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fast.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "patch": "@@ -2060,8 +2060,11 @@ impl TyKind {\n     }\n \n     pub fn is_simple_path(&self) -> Option<Symbol> {\n-        if let TyKind::Path(None, Path { segments, .. }) = &self && segments.len() == 1 {\n-            Some(segments[0].ident.name)\n+        if let TyKind::Path(None, Path { segments, .. }) = &self\n+            && let [segment] = &segments[..]\n+            && segment.args.is_none()\n+        {\n+            Some(segment.ident.name)\n         } else {\n             None\n         }\n@@ -2953,7 +2956,7 @@ pub enum AssocItemKind {\n     /// An associated function.\n     Fn(Box<Fn>),\n     /// An associated type.\n-    TyAlias(Box<TyAlias>),\n+    Type(Box<TyAlias>),\n     /// A macro expanding to associated items.\n     MacCall(P<MacCall>),\n }\n@@ -2963,7 +2966,7 @@ impl AssocItemKind {\n         match *self {\n             Self::Const(defaultness, ..)\n             | Self::Fn(box Fn { defaultness, .. })\n-            | Self::TyAlias(box TyAlias { defaultness, .. }) => defaultness,\n+            | Self::Type(box TyAlias { defaultness, .. }) => defaultness,\n             Self::MacCall(..) => Defaultness::Final,\n         }\n     }\n@@ -2974,7 +2977,7 @@ impl From<AssocItemKind> for ItemKind {\n         match assoc_item_kind {\n             AssocItemKind::Const(a, b, c) => ItemKind::Const(a, b, c),\n             AssocItemKind::Fn(fn_kind) => ItemKind::Fn(fn_kind),\n-            AssocItemKind::TyAlias(ty_alias_kind) => ItemKind::TyAlias(ty_alias_kind),\n+            AssocItemKind::Type(ty_alias_kind) => ItemKind::TyAlias(ty_alias_kind),\n             AssocItemKind::MacCall(a) => ItemKind::MacCall(a),\n         }\n     }\n@@ -2987,7 +2990,7 @@ impl TryFrom<ItemKind> for AssocItemKind {\n         Ok(match item_kind {\n             ItemKind::Const(a, b, c) => AssocItemKind::Const(a, b, c),\n             ItemKind::Fn(fn_kind) => AssocItemKind::Fn(fn_kind),\n-            ItemKind::TyAlias(ty_alias_kind) => AssocItemKind::TyAlias(ty_alias_kind),\n+            ItemKind::TyAlias(ty_kind) => AssocItemKind::Type(ty_kind),\n             ItemKind::MacCall(a) => AssocItemKind::MacCall(a),\n             _ => return Err(item_kind),\n         })\n@@ -3039,14 +3042,13 @@ pub type ForeignItem = Item<ForeignItemKind>;\n mod size_asserts {\n     use super::*;\n     use rustc_data_structures::static_assert_size;\n-    // These are in alphabetical order, which is easy to maintain.\n+    // tidy-alphabetical-start\n     static_assert_size!(AssocItem, 104);\n     static_assert_size!(AssocItemKind, 32);\n     static_assert_size!(Attribute, 32);\n     static_assert_size!(Block, 48);\n     static_assert_size!(Expr, 104);\n     static_assert_size!(ExprKind, 72);\n-    #[cfg(not(bootstrap))]\n     static_assert_size!(Fn, 184);\n     static_assert_size!(ForeignItem, 96);\n     static_assert_size!(ForeignItemKind, 24);\n@@ -3061,11 +3063,12 @@ mod size_asserts {\n     static_assert_size!(Local, 72);\n     static_assert_size!(Param, 40);\n     static_assert_size!(Pat, 120);\n-    static_assert_size!(PatKind, 96);\n     static_assert_size!(Path, 40);\n     static_assert_size!(PathSegment, 24);\n+    static_assert_size!(PatKind, 96);\n     static_assert_size!(Stmt, 32);\n     static_assert_size!(StmtKind, 16);\n     static_assert_size!(Ty, 96);\n     static_assert_size!(TyKind, 72);\n+    // tidy-alphabetical-end\n }"}, {"sha": "eeb7e56e2b12448e3b465fd29cfd6c716a76b468", "filename": "compiler/rustc_ast/src/lib.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_ast%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_ast%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Flib.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "patch": "@@ -13,9 +13,7 @@\n #![feature(const_default_impls)]\n #![feature(const_trait_impl)]\n #![feature(if_let_guard)]\n-#![cfg_attr(bootstrap, feature(label_break_value))]\n #![feature(let_chains)]\n-#![cfg_attr(bootstrap, feature(let_else))]\n #![feature(min_specialization)]\n #![feature(negative_impls)]\n #![feature(slice_internals)]"}, {"sha": "25022a02f4bb7e4793e0c0b6d1e74711378f05f5", "filename": "compiler/rustc_ast/src/mut_visit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "patch": "@@ -1106,7 +1106,7 @@ pub fn noop_flat_map_assoc_item<T: MutVisitor>(\n             visit_fn_sig(sig, visitor);\n             visit_opt(body, |body| visitor.visit_block(body));\n         }\n-        AssocItemKind::TyAlias(box TyAlias {\n+        AssocItemKind::Type(box TyAlias {\n             defaultness,\n             generics,\n             where_clauses,"}, {"sha": "83b10d906e297980ff3b96095bbd1db7a6cd18eb", "filename": "compiler/rustc_ast/src/token.rs", "status": "modified", "additions": 24, "deletions": 25, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_ast%2Fsrc%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_ast%2Fsrc%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Ftoken.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "patch": "@@ -13,7 +13,7 @@ use rustc_span::symbol::{kw, sym};\n use rustc_span::symbol::{Ident, Symbol};\n use rustc_span::{self, edition::Edition, Span, DUMMY_SP};\n use std::borrow::Cow;\n-use std::{fmt, mem};\n+use std::fmt;\n \n #[derive(Clone, Copy, PartialEq, Encodable, Decodable, Debug, HashStable_Generic)]\n pub enum CommentKind {\n@@ -256,10 +256,6 @@ pub enum TokenKind {\n     Eof,\n }\n \n-// `TokenKind` is used a lot. Make sure it doesn't unintentionally get bigger.\n-#[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n-rustc_data_structures::static_assert_size!(TokenKind, 16);\n-\n #[derive(Clone, PartialEq, Encodable, Decodable, Debug, HashStable_Generic)]\n pub struct Token {\n     pub kind: TokenKind,\n@@ -335,11 +331,6 @@ impl Token {\n         Token::new(Ident(ident.name, ident.is_raw_guess()), ident.span)\n     }\n \n-    /// Return this token by value and leave a dummy token in its place.\n-    pub fn take(&mut self) -> Self {\n-        mem::replace(self, Token::dummy())\n-    }\n-\n     /// For interpolated tokens, returns a span of the fragment to which the interpolated\n     /// token refers. For all other tokens this is just a regular span.\n     /// It is particularly important to use this for identifiers and lifetimes\n@@ -354,17 +345,14 @@ impl Token {\n     }\n \n     pub fn is_op(&self) -> bool {\n-        !matches!(\n-            self.kind,\n-            OpenDelim(..)\n-                | CloseDelim(..)\n-                | Literal(..)\n-                | DocComment(..)\n-                | Ident(..)\n-                | Lifetime(..)\n-                | Interpolated(..)\n-                | Eof\n-        )\n+        match self.kind {\n+            Eq | Lt | Le | EqEq | Ne | Ge | Gt | AndAnd | OrOr | Not | Tilde | BinOp(_)\n+            | BinOpEq(_) | At | Dot | DotDot | DotDotDot | DotDotEq | Comma | Semi | Colon\n+            | ModSep | RArrow | LArrow | FatArrow | Pound | Dollar | Question | SingleQuote => true,\n+\n+            OpenDelim(..) | CloseDelim(..) | Literal(..) | DocComment(..) | Ident(..)\n+            | Lifetime(..) | Interpolated(..) | Eof => false,\n+        }\n     }\n \n     pub fn is_like_plus(&self) -> bool {\n@@ -733,6 +721,7 @@ impl Token {\n }\n \n impl PartialEq<TokenKind> for Token {\n+    #[inline]\n     fn eq(&self, rhs: &TokenKind) -> bool {\n         self.kind == *rhs\n     }\n@@ -756,10 +745,6 @@ pub enum Nonterminal {\n     NtVis(P<ast::Visibility>),\n }\n \n-// `Nonterminal` is used a lot. Make sure it doesn't unintentionally get bigger.\n-#[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n-rustc_data_structures::static_assert_size!(Nonterminal, 16);\n-\n #[derive(Debug, Copy, Clone, PartialEq, Encodable, Decodable)]\n pub enum NonterminalKind {\n     Item,\n@@ -898,3 +883,17 @@ where\n         panic!(\"interpolated tokens should not be present in the HIR\")\n     }\n }\n+\n+// Some types are used a lot. Make sure they don't unintentionally get bigger.\n+#[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n+mod size_asserts {\n+    use super::*;\n+    use rustc_data_structures::static_assert_size;\n+    // tidy-alphabetical-start\n+    static_assert_size!(Lit, 12);\n+    static_assert_size!(LitKind, 2);\n+    static_assert_size!(Nonterminal, 16);\n+    static_assert_size!(Token, 24);\n+    static_assert_size!(TokenKind, 16);\n+    // tidy-alphabetical-end\n+}"}, {"sha": "015f5c1ee8ae5ab817d7d081d212feeead02ea8f", "filename": "compiler/rustc_ast/src/tokenstream.rs", "status": "modified", "additions": 70, "deletions": 80, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_ast%2Fsrc%2Ftokenstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_ast%2Fsrc%2Ftokenstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Ftokenstream.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "patch": "@@ -47,10 +47,6 @@ pub enum TokenTree {\n     Delimited(DelimSpan, Delimiter, TokenStream),\n }\n \n-// This type is used a lot. Make sure it doesn't unintentionally get bigger.\n-#[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n-rustc_data_structures::static_assert_size!(TokenTree, 32);\n-\n // Ensure all fields of `TokenTree` is `Send` and `Sync`.\n #[cfg(parallel_compiler)]\n fn _dummy()\n@@ -249,12 +245,12 @@ impl AttrTokenStream {\n                                 // properly implemented - we always synthesize fake tokens,\n                                 // so we never reach this code.\n \n-                                let mut builder = TokenStreamBuilder::new();\n+                                let mut stream = TokenStream::default();\n                                 for inner_attr in inner_attrs {\n-                                    builder.push(inner_attr.tokens());\n+                                    stream.push_stream(inner_attr.tokens());\n                                 }\n-                                builder.push(delim_tokens.clone());\n-                                *tree = TokenTree::Delimited(*span, *delim, builder.build());\n+                                stream.push_stream(delim_tokens.clone());\n+                                *tree = TokenTree::Delimited(*span, *delim, stream);\n                                 found = true;\n                                 break;\n                             }\n@@ -308,13 +304,20 @@ pub struct AttributesData {\n #[derive(Clone, Debug, Default, Encodable, Decodable)]\n pub struct TokenStream(pub(crate) Lrc<Vec<TokenTree>>);\n \n-// `TokenStream` is used a lot. Make sure it doesn't unintentionally get bigger.\n-#[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n-rustc_data_structures::static_assert_size!(TokenStream, 8);\n-\n+/// Similar to `proc_macro::Spacing`, but for tokens.\n+///\n+/// Note that all `ast::TokenTree::Token` instances have a `Spacing`, but when\n+/// we convert to `proc_macro::TokenTree` for proc macros only `Punct`\n+/// `TokenTree`s have a `proc_macro::Spacing`.\n #[derive(Clone, Copy, Debug, PartialEq, Encodable, Decodable, HashStable_Generic)]\n pub enum Spacing {\n+    /// The token is not immediately followed by an operator token (as\n+    /// determined by `Token::is_op`). E.g. a `+` token is `Alone` in `+ =`,\n+    /// `+/*foo*/=`, `+ident`, and `+()`.\n     Alone,\n+\n+    /// The token is immediately followed by an operator token. E.g. a `+`\n+    /// token is `Joint` in `+=` and `++`.\n     Joint,\n }\n \n@@ -502,76 +505,49 @@ impl TokenStream {\n \n         self.trees().map(|tree| TokenStream::flatten_token_tree(tree)).collect()\n     }\n-}\n \n-// 99.5%+ of the time we have 1 or 2 elements in this vector.\n-#[derive(Clone)]\n-pub struct TokenStreamBuilder(SmallVec<[TokenStream; 2]>);\n-\n-impl TokenStreamBuilder {\n-    pub fn new() -> TokenStreamBuilder {\n-        TokenStreamBuilder(SmallVec::new())\n-    }\n-\n-    pub fn push(&mut self, stream: TokenStream) {\n-        self.0.push(stream);\n-    }\n-\n-    pub fn build(self) -> TokenStream {\n-        let mut streams = self.0;\n-        match streams.len() {\n-            0 => TokenStream::default(),\n-            1 => streams.pop().unwrap(),\n-            _ => {\n-                // We will extend the first stream in `streams` with the\n-                // elements from the subsequent streams. This requires using\n-                // `make_mut()` on the first stream, and in practice this\n-                // doesn't cause cloning 99.9% of the time.\n-                //\n-                // One very common use case is when `streams` has two elements,\n-                // where the first stream has any number of elements within\n-                // (often 1, but sometimes many more) and the second stream has\n-                // a single element within.\n-\n-                // Determine how much the first stream will be extended.\n-                // Needed to avoid quadratic blow up from on-the-fly\n-                // reallocations (#57735).\n-                let num_appends = streams.iter().skip(1).map(|ts| ts.len()).sum();\n-\n-                // Get the first stream, which will become the result stream.\n-                // If it's `None`, create an empty stream.\n-                let mut iter = streams.into_iter();\n-                let mut res_stream_lrc = iter.next().unwrap().0;\n-\n-                // Append the subsequent elements to the result stream, after\n-                // reserving space for them.\n-                let res_vec_mut = Lrc::make_mut(&mut res_stream_lrc);\n-                res_vec_mut.reserve(num_appends);\n-                for stream in iter {\n-                    let stream_iter = stream.0.iter().cloned();\n-\n-                    // If (a) `res_mut_vec` is not empty and the last tree\n-                    // within it is a token tree marked with `Joint`, and (b)\n-                    // `stream` is not empty and the first tree within it is a\n-                    // token tree, and (c) the two tokens can be glued\n-                    // together...\n-                    if let Some(TokenTree::Token(last_tok, Spacing::Joint)) = res_vec_mut.last()\n-                        && let Some(TokenTree::Token(tok, spacing)) = stream.0.first()\n-                        && let Some(glued_tok) = last_tok.glue(&tok)\n-                    {\n-                        // ...then overwrite the last token tree in\n-                        // `res_vec_mut` with the glued token, and skip the\n-                        // first token tree from `stream`.\n-                        *res_vec_mut.last_mut().unwrap() = TokenTree::Token(glued_tok, *spacing);\n-                        res_vec_mut.extend(stream_iter.skip(1));\n-                    } else {\n-                        // Append all of `stream`.\n-                        res_vec_mut.extend(stream_iter);\n-                    }\n-                }\n+    // If `vec` is not empty, try to glue `tt` onto its last token. The return\n+    // value indicates if gluing took place.\n+    fn try_glue_to_last(vec: &mut Vec<TokenTree>, tt: &TokenTree) -> bool {\n+        if let Some(TokenTree::Token(last_tok, Spacing::Joint)) = vec.last()\n+            && let TokenTree::Token(tok, spacing) = tt\n+            && let Some(glued_tok) = last_tok.glue(&tok)\n+        {\n+            // ...then overwrite the last token tree in `vec` with the\n+            // glued token, and skip the first token tree from `stream`.\n+            *vec.last_mut().unwrap() = TokenTree::Token(glued_tok, *spacing);\n+            true\n+        } else {\n+            false\n+        }\n+    }\n \n-                TokenStream(res_stream_lrc)\n-            }\n+    // Push `tt` onto the end of the stream, possibly gluing it to the last\n+    // token. Uses `make_mut` to maximize efficiency.\n+    pub fn push_tree(&mut self, tt: TokenTree) {\n+        let vec_mut = Lrc::make_mut(&mut self.0);\n+\n+        if Self::try_glue_to_last(vec_mut, &tt) {\n+            // nothing else to do\n+        } else {\n+            vec_mut.push(tt);\n+        }\n+    }\n+\n+    // Push `stream` onto the end of the stream, possibly gluing the first\n+    // token tree to the last token. (No other token trees will be glued.)\n+    // Uses `make_mut` to maximize efficiency.\n+    pub fn push_stream(&mut self, stream: TokenStream) {\n+        let vec_mut = Lrc::make_mut(&mut self.0);\n+\n+        let stream_iter = stream.0.iter().cloned();\n+\n+        if let Some(first) = stream.0.first() && Self::try_glue_to_last(vec_mut, first) {\n+            // Now skip the first token tree from `stream`.\n+            vec_mut.extend(stream_iter.skip(1));\n+        } else {\n+            // Append all of `stream`.\n+            vec_mut.extend(stream_iter);\n         }\n     }\n }\n@@ -664,3 +640,17 @@ impl DelimSpan {\n         self.open.with_hi(self.close.hi())\n     }\n }\n+\n+// Some types are used a lot. Make sure they don't unintentionally get bigger.\n+#[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n+mod size_asserts {\n+    use super::*;\n+    use rustc_data_structures::static_assert_size;\n+    // tidy-alphabetical-start\n+    static_assert_size!(AttrTokenStream, 8);\n+    static_assert_size!(AttrTokenTree, 32);\n+    static_assert_size!(LazyAttrTokenStream, 8);\n+    static_assert_size!(TokenStream, 8);\n+    static_assert_size!(TokenTree, 32);\n+    // tidy-alphabetical-end\n+}"}, {"sha": "e752cc7dc2dcd6ab34d398c8fd6f09670caccb12", "filename": "compiler/rustc_ast/src/visit.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_ast%2Fsrc%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_ast%2Fsrc%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fvisit.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "patch": "@@ -244,14 +244,12 @@ pub trait Visitor<'ast>: Sized {\n \n #[macro_export]\n macro_rules! walk_list {\n-    ($visitor: expr, $method: ident, $list: expr) => {\n-        for elem in $list {\n-            $visitor.$method(elem)\n-        }\n-    };\n-    ($visitor: expr, $method: ident, $list: expr, $($extra_args: expr),*) => {\n-        for elem in $list {\n-            $visitor.$method(elem, $($extra_args,)*)\n+    ($visitor: expr, $method: ident, $list: expr $(, $($extra_args: expr),* )?) => {\n+        {\n+            #[cfg_attr(not(bootstrap), allow(for_loops_over_fallibles))]\n+            for elem in $list {\n+                $visitor.$method(elem $(, $($extra_args,)* )?)\n+            }\n         }\n     }\n }\n@@ -685,7 +683,7 @@ pub fn walk_assoc_item<'a, V: Visitor<'a>>(visitor: &mut V, item: &'a AssocItem,\n             let kind = FnKind::Fn(FnCtxt::Assoc(ctxt), ident, sig, vis, generics, body.as_deref());\n             visitor.visit_fn(kind, span, id);\n         }\n-        AssocItemKind::TyAlias(box TyAlias { generics, bounds, ty, .. }) => {\n+        AssocItemKind::Type(box TyAlias { generics, bounds, ty, .. }) => {\n             visitor.visit_generics(generics);\n             walk_list!(visitor, visit_param_bound, bounds, BoundKind::Bound);\n             walk_list!(visitor, visit_ty, ty);"}, {"sha": "450cdf246b1502cdc084f30bc70dd220031eea85", "filename": "compiler/rustc_ast_lowering/src/asm.rs", "status": "modified", "additions": 5, "deletions": 18, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_ast_lowering%2Fsrc%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_ast_lowering%2Fsrc%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fasm.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "patch": "@@ -192,26 +192,13 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                         }\n                     }\n                     InlineAsmOperand::Sym { ref sym } => {\n-                        if !self.tcx.features().asm_sym {\n-                            feature_err(\n-                                &sess.parse_sess,\n-                                sym::asm_sym,\n-                                *op_sp,\n-                                \"sym operands for inline assembly are unstable\",\n-                            )\n-                            .emit();\n-                        }\n-\n                         let static_def_id = self\n                             .resolver\n                             .get_partial_res(sym.id)\n-                            .filter(|res| res.unresolved_segments() == 0)\n-                            .and_then(|res| {\n-                                if let Res::Def(DefKind::Static(_), def_id) = res.base_res() {\n-                                    Some(def_id)\n-                                } else {\n-                                    None\n-                                }\n+                            .and_then(|res| res.full_res())\n+                            .and_then(|res| match res {\n+                                Res::Def(DefKind::Static(_), def_id) => Some(def_id),\n+                                _ => None,\n                             });\n \n                         if let Some(def_id) = static_def_id {\n@@ -237,7 +224,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                             // Wrap the expression in an AnonConst.\n                             let parent_def_id = self.current_hir_id_owner;\n                             let node_id = self.next_node_id();\n-                            self.create_def(parent_def_id, node_id, DefPathData::AnonConst);\n+                            self.create_def(parent_def_id.def_id, node_id, DefPathData::AnonConst);\n                             let anon_const = AnonConst { id: node_id, value: P(expr) };\n                             hir::InlineAsmOperand::SymFn {\n                                 anon_const: self.lower_anon_const(&anon_const),"}, {"sha": "c6c85ffa84dd720a55a51305e9cb4f2e227e3ea0", "filename": "compiler/rustc_ast_lowering/src/errors.rs", "status": "modified", "additions": 28, "deletions": 5, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_ast_lowering%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_ast_lowering%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Ferrors.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "patch": "@@ -1,4 +1,7 @@\n-use rustc_errors::{fluent, AddToDiagnostic, Applicability, Diagnostic, DiagnosticArgFromDisplay};\n+use rustc_errors::{\n+    fluent, AddToDiagnostic, Applicability, Diagnostic, DiagnosticArgFromDisplay,\n+    SubdiagnosticMessage,\n+};\n use rustc_macros::{Diagnostic, Subdiagnostic};\n use rustc_span::{symbol::Ident, Span, Symbol};\n \n@@ -19,7 +22,10 @@ pub struct UseAngleBrackets {\n }\n \n impl AddToDiagnostic for UseAngleBrackets {\n-    fn add_to_diagnostic(self, diag: &mut Diagnostic) {\n+    fn add_to_diagnostic_with<F>(self, diag: &mut Diagnostic, _: F)\n+    where\n+        F: Fn(&mut Diagnostic, SubdiagnosticMessage) -> SubdiagnosticMessage,\n+    {\n         diag.multipart_suggestion(\n             fluent::ast_lowering::use_angle_brackets,\n             vec![(self.open_param, String::from(\"<\")), (self.close_param, String::from(\">\"))],\n@@ -29,14 +35,28 @@ impl AddToDiagnostic for UseAngleBrackets {\n }\n \n #[derive(Diagnostic)]\n-#[help]\n #[diag(ast_lowering::invalid_abi, code = \"E0703\")]\n+#[note]\n pub struct InvalidAbi {\n     #[primary_span]\n     #[label]\n     pub span: Span,\n     pub abi: Symbol,\n-    pub valid_abis: String,\n+    pub command: String,\n+    #[subdiagnostic]\n+    pub suggestion: Option<InvalidAbiSuggestion>,\n+}\n+\n+#[derive(Subdiagnostic)]\n+#[suggestion(\n+    ast_lowering::invalid_abi_suggestion,\n+    code = \"{suggestion}\",\n+    applicability = \"maybe-incorrect\"\n+)]\n+pub struct InvalidAbiSuggestion {\n+    #[primary_span]\n+    pub span: Span,\n+    pub suggestion: String,\n }\n \n #[derive(Diagnostic, Clone, Copy)]\n@@ -55,7 +75,10 @@ pub enum AssocTyParenthesesSub {\n }\n \n impl AddToDiagnostic for AssocTyParenthesesSub {\n-    fn add_to_diagnostic(self, diag: &mut Diagnostic) {\n+    fn add_to_diagnostic_with<F>(self, diag: &mut Diagnostic, _: F)\n+    where\n+        F: Fn(&mut Diagnostic, SubdiagnosticMessage) -> SubdiagnosticMessage,\n+    {\n         match self {\n             Self::Empty { parentheses_span } => diag.multipart_suggestion(\n                 fluent::ast_lowering::remove_parentheses,"}, {"sha": "ec9c3935020566aee76eeef1bf82fc9092125762", "filename": "compiler/rustc_ast_lowering/src/expr.rs", "status": "modified", "additions": 51, "deletions": 30, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "patch": "@@ -359,7 +359,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 let node_id = self.next_node_id();\n \n                 // Add a definition for the in-band const def.\n-                self.create_def(parent_def_id, node_id, DefPathData::AnonConst);\n+                self.create_def(parent_def_id.def_id, node_id, DefPathData::AnonConst);\n \n                 let anon_const = AnonConst { id: node_id, value: arg };\n                 generic_args.push(AngleBracketedArg::Arg(GenericArg::Const(anon_const)));\n@@ -387,32 +387,58 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         then: &Block,\n         else_opt: Option<&Expr>,\n     ) -> hir::ExprKind<'hir> {\n-        let lowered_cond = self.lower_expr(cond);\n-        let new_cond = self.manage_let_cond(lowered_cond);\n+        let lowered_cond = self.lower_cond(cond);\n         let then_expr = self.lower_block_expr(then);\n         if let Some(rslt) = else_opt {\n-            hir::ExprKind::If(new_cond, self.arena.alloc(then_expr), Some(self.lower_expr(rslt)))\n+            hir::ExprKind::If(\n+                lowered_cond,\n+                self.arena.alloc(then_expr),\n+                Some(self.lower_expr(rslt)),\n+            )\n         } else {\n-            hir::ExprKind::If(new_cond, self.arena.alloc(then_expr), None)\n+            hir::ExprKind::If(lowered_cond, self.arena.alloc(then_expr), None)\n         }\n     }\n \n-    // If `cond` kind is `let`, returns `let`. Otherwise, wraps and returns `cond`\n-    // in a temporary block.\n-    fn manage_let_cond(&mut self, cond: &'hir hir::Expr<'hir>) -> &'hir hir::Expr<'hir> {\n-        fn has_let_expr<'hir>(expr: &'hir hir::Expr<'hir>) -> bool {\n-            match expr.kind {\n-                hir::ExprKind::Binary(_, lhs, rhs) => has_let_expr(lhs) || has_let_expr(rhs),\n-                hir::ExprKind::Let(..) => true,\n+    // Lowers a condition (i.e. `cond` in `if cond` or `while cond`), wrapping it in a terminating scope\n+    // so that temporaries created in the condition don't live beyond it.\n+    fn lower_cond(&mut self, cond: &Expr) -> &'hir hir::Expr<'hir> {\n+        fn has_let_expr(expr: &Expr) -> bool {\n+            match &expr.kind {\n+                ExprKind::Binary(_, lhs, rhs) => has_let_expr(lhs) || has_let_expr(rhs),\n+                ExprKind::Let(..) => true,\n                 _ => false,\n             }\n         }\n-        if has_let_expr(cond) {\n-            cond\n-        } else {\n-            let reason = DesugaringKind::CondTemporary;\n-            let span_block = self.mark_span_with_reason(reason, cond.span, None);\n-            self.expr_drop_temps(span_block, cond, AttrVec::new())\n+\n+        // We have to take special care for `let` exprs in the condition, e.g. in\n+        // `if let pat = val` or `if foo && let pat = val`, as we _do_ want `val` to live beyond the\n+        // condition in this case.\n+        //\n+        // In order to mantain the drop behavior for the non `let` parts of the condition,\n+        // we still wrap them in terminating scopes, e.g. `if foo && let pat = val` essentially\n+        // gets transformed into `if { let _t = foo; _t } && let pat = val`\n+        match &cond.kind {\n+            ExprKind::Binary(op @ Spanned { node: ast::BinOpKind::And, .. }, lhs, rhs)\n+                if has_let_expr(cond) =>\n+            {\n+                let op = self.lower_binop(*op);\n+                let lhs = self.lower_cond(lhs);\n+                let rhs = self.lower_cond(rhs);\n+\n+                self.arena.alloc(self.expr(\n+                    cond.span,\n+                    hir::ExprKind::Binary(op, lhs, rhs),\n+                    AttrVec::new(),\n+                ))\n+            }\n+            ExprKind::Let(..) => self.lower_expr(cond),\n+            _ => {\n+                let cond = self.lower_expr(cond);\n+                let reason = DesugaringKind::CondTemporary;\n+                let span_block = self.mark_span_with_reason(reason, cond.span, None);\n+                self.expr_drop_temps(span_block, cond, AttrVec::new())\n+            }\n         }\n     }\n \n@@ -439,14 +465,13 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         body: &Block,\n         opt_label: Option<Label>,\n     ) -> hir::ExprKind<'hir> {\n-        let lowered_cond = self.with_loop_condition_scope(|t| t.lower_expr(cond));\n-        let new_cond = self.manage_let_cond(lowered_cond);\n+        let lowered_cond = self.with_loop_condition_scope(|t| t.lower_cond(cond));\n         let then = self.lower_block_expr(body);\n         let expr_break = self.expr_break(span, AttrVec::new());\n         let stmt_break = self.stmt_expr(span, expr_break);\n         let else_blk = self.block_all(span, arena_vec![self; stmt_break], None);\n         let else_expr = self.arena.alloc(self.expr_block(else_blk, AttrVec::new()));\n-        let if_kind = hir::ExprKind::If(new_cond, self.arena.alloc(then), Some(else_expr));\n+        let if_kind = hir::ExprKind::If(lowered_cond, self.arena.alloc(then), Some(else_expr));\n         let if_expr = self.expr(span, if_kind, AttrVec::new());\n         let block = self.block_expr(self.arena.alloc(if_expr));\n         let span = self.lower_span(span.with_hi(cond.span.hi()));\n@@ -1044,9 +1069,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         if let ExprKind::Path(qself, path) = &expr.kind {\n             // Does the path resolve to something disallowed in a tuple struct/variant pattern?\n             if let Some(partial_res) = self.resolver.get_partial_res(expr.id) {\n-                if partial_res.unresolved_segments() == 0\n-                    && !partial_res.base_res().expected_in_tuple_struct_pat()\n-                {\n+                if let Some(res) = partial_res.full_res() && !res.expected_in_tuple_struct_pat() {\n                     return None;\n                 }\n             }\n@@ -1066,9 +1089,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         if let ExprKind::Path(qself, path) = &expr.kind {\n             // Does the path resolve to something disallowed in a unit struct/variant pattern?\n             if let Some(partial_res) = self.resolver.get_partial_res(expr.id) {\n-                if partial_res.unresolved_segments() == 0\n-                    && !partial_res.base_res().expected_in_unit_struct_pat()\n-                {\n+                if let Some(res) = partial_res.full_res() && !res.expected_in_unit_struct_pat() {\n                     return None;\n                 }\n             }\n@@ -1609,11 +1630,11 @@ impl<'hir> LoweringContext<'_, 'hir> {\n     }\n \n     /// Desugar `ExprKind::Yeet` from: `do yeet <expr>` into:\n-    /// ```rust\n+    /// ```ignore(illustrative)\n     /// // If there is an enclosing `try {...}`:\n-    /// break 'catch_target FromResidual::from_residual(Yeet(residual)),\n+    /// break 'catch_target FromResidual::from_residual(Yeet(residual));\n     /// // Otherwise:\n-    /// return FromResidual::from_residual(Yeet(residual)),\n+    /// return FromResidual::from_residual(Yeet(residual));\n     /// ```\n     /// But to simplify this, there's a `from_yeet` lang item function which\n     /// handles the combined `FromResidual::from_residual(Yeet(residual))`."}, {"sha": "6d71679634331e90039ada4f32c9bd02cb0d67e3", "filename": "compiler/rustc_ast_lowering/src/index.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_ast_lowering%2Fsrc%2Findex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_ast_lowering%2Fsrc%2Findex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Findex.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "patch": "@@ -24,7 +24,7 @@ pub(super) struct NodeCollector<'a, 'hir> {\n     /// The parent of this node\n     parent_node: hir::ItemLocalId,\n \n-    owner: LocalDefId,\n+    owner: OwnerId,\n \n     definitions: &'a definitions::Definitions,\n }\n@@ -81,9 +81,9 @@ impl<'a, 'hir> NodeCollector<'a, 'hir> {\n                      current_dep_node_owner={} ({:?}), hir_id.owner={} ({:?})\",\n                     self.source_map.span_to_diagnostic_string(span),\n                     node,\n-                    self.definitions.def_path(self.owner).to_string_no_crate_verbose(),\n+                    self.definitions.def_path(self.owner.def_id).to_string_no_crate_verbose(),\n                     self.owner,\n-                    self.definitions.def_path(hir_id.owner).to_string_no_crate_verbose(),\n+                    self.definitions.def_path(hir_id.owner.def_id).to_string_no_crate_verbose(),\n                     hir_id.owner,\n                 )\n             }\n@@ -112,19 +112,19 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n \n     fn visit_nested_item(&mut self, item: ItemId) {\n         debug!(\"visit_nested_item: {:?}\", item);\n-        self.insert_nested(item.def_id);\n+        self.insert_nested(item.def_id.def_id);\n     }\n \n     fn visit_nested_trait_item(&mut self, item_id: TraitItemId) {\n-        self.insert_nested(item_id.def_id);\n+        self.insert_nested(item_id.def_id.def_id);\n     }\n \n     fn visit_nested_impl_item(&mut self, item_id: ImplItemId) {\n-        self.insert_nested(item_id.def_id);\n+        self.insert_nested(item_id.def_id.def_id);\n     }\n \n     fn visit_nested_foreign_item(&mut self, foreign_id: ForeignItemId) {\n-        self.insert_nested(foreign_id.def_id);\n+        self.insert_nested(foreign_id.def_id.def_id);\n     }\n \n     fn visit_nested_body(&mut self, id: BodyId) {"}, {"sha": "2117006df10f11d0fbca2573b8d2bb46772ea9fd", "filename": "compiler/rustc_ast_lowering/src/item.rs", "status": "modified", "additions": 58, "deletions": 31, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "patch": "@@ -1,4 +1,4 @@\n-use super::errors::{InvalidAbi, MisplacedRelaxTraitBound};\n+use super::errors::{InvalidAbi, InvalidAbiSuggestion, MisplacedRelaxTraitBound};\n use super::ResolverAstLoweringExt;\n use super::{Arena, AstOwner, ImplTraitContext, ImplTraitPosition};\n use super::{FnDeclKind, LoweringContext, ParamMode};\n@@ -14,9 +14,10 @@ use rustc_hir::def_id::{LocalDefId, CRATE_DEF_ID};\n use rustc_hir::PredicateOrigin;\n use rustc_index::vec::{Idx, IndexVec};\n use rustc_middle::ty::{DefIdTree, ResolverAstLowering, TyCtxt};\n+use rustc_span::lev_distance::find_best_match_for_name;\n use rustc_span::source_map::DesugaringKind;\n use rustc_span::symbol::{kw, sym, Ident};\n-use rustc_span::Span;\n+use rustc_span::{Span, Symbol};\n use rustc_target::spec::abi;\n use smallvec::{smallvec, SmallVec};\n \n@@ -67,7 +68,7 @@ impl<'a, 'hir> ItemLowerer<'a, 'hir> {\n             bodies: Vec::new(),\n             attrs: SortedMap::default(),\n             children: FxHashMap::default(),\n-            current_hir_id_owner: CRATE_DEF_ID,\n+            current_hir_id_owner: hir::CRATE_OWNER_ID,\n             item_local_id_counter: hir::ItemLocalId::new(0),\n             node_id_to_local_id: Default::default(),\n             local_id_to_def_id: SortedMap::new(),\n@@ -176,7 +177,8 @@ impl<'hir> LoweringContext<'_, 'hir> {\n     }\n \n     pub(super) fn lower_item_ref(&mut self, i: &Item) -> SmallVec<[hir::ItemId; 1]> {\n-        let mut node_ids = smallvec![hir::ItemId { def_id: self.local_def_id(i.id) }];\n+        let mut node_ids =\n+            smallvec![hir::ItemId { def_id: hir::OwnerId { def_id: self.local_def_id(i.id) } }];\n         if let ItemKind::Use(ref use_tree) = &i.kind {\n             self.lower_item_id_use_tree(use_tree, i.id, &mut node_ids);\n         }\n@@ -192,7 +194,9 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         match tree.kind {\n             UseTreeKind::Nested(ref nested_vec) => {\n                 for &(ref nested, id) in nested_vec {\n-                    vec.push(hir::ItemId { def_id: self.local_def_id(id) });\n+                    vec.push(hir::ItemId {\n+                        def_id: hir::OwnerId { def_id: self.local_def_id(id) },\n+                    });\n                     self.lower_item_id_use_tree(nested, id, vec);\n                 }\n             }\n@@ -201,7 +205,9 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 for (_, &id) in\n                     iter::zip(self.expect_full_res_from_use(base_id).skip(1), &[id1, id2])\n                 {\n-                    vec.push(hir::ItemId { def_id: self.local_def_id(id) });\n+                    vec.push(hir::ItemId {\n+                        def_id: hir::OwnerId { def_id: self.local_def_id(id) },\n+                    });\n                 }\n             }\n         }\n@@ -539,7 +545,11 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                     let ident = *ident;\n                     let mut path = path.clone();\n                     for seg in &mut path.segments {\n-                        seg.id = self.next_node_id();\n+                        // Give the cloned segment the same resolution information\n+                        // as the old one (this is needed for stability checking).\n+                        let new_id = self.next_node_id();\n+                        self.resolver.clone_res(seg.id, new_id);\n+                        seg.id = new_id;\n                     }\n                     let span = path.span;\n \n@@ -552,7 +562,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                         }\n \n                         let item = hir::Item {\n-                            def_id: new_id,\n+                            def_id: hir::OwnerId { def_id: new_id },\n                             ident: this.lower_ident(ident),\n                             kind,\n                             vis_span,\n@@ -608,7 +618,11 @@ impl<'hir> LoweringContext<'_, 'hir> {\n \n                     // Give the segments new node-ids since they are being cloned.\n                     for seg in &mut prefix.segments {\n-                        seg.id = self.next_node_id();\n+                        // Give the cloned segment the same resolution information\n+                        // as the old one (this is needed for stability checking).\n+                        let new_id = self.next_node_id();\n+                        self.resolver.clone_res(seg.id, new_id);\n+                        seg.id = new_id;\n                     }\n \n                     // Each `use` import is an item and thus are owners of the\n@@ -626,7 +640,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                         }\n \n                         let item = hir::Item {\n-                            def_id: new_hir_id,\n+                            def_id: hir::OwnerId { def_id: new_hir_id },\n                             ident: this.lower_ident(ident),\n                             kind,\n                             vis_span,\n@@ -688,7 +702,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n \n     fn lower_foreign_item_ref(&mut self, i: &ForeignItem) -> hir::ForeignItemRef {\n         hir::ForeignItemRef {\n-            id: hir::ForeignItemId { def_id: self.local_def_id(i.id) },\n+            id: hir::ForeignItemId { def_id: hir::OwnerId { def_id: self.local_def_id(i.id) } },\n             ident: self.lower_ident(i.ident),\n             span: self.lower_span(i.span),\n         }\n@@ -798,7 +812,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 );\n                 (generics, hir::TraitItemKind::Fn(sig, hir::TraitFn::Provided(body_id)), true)\n             }\n-            AssocItemKind::TyAlias(box TyAlias {\n+            AssocItemKind::Type(box TyAlias {\n                 ref generics,\n                 where_clauses,\n                 ref bounds,\n@@ -844,13 +858,13 @@ impl<'hir> LoweringContext<'_, 'hir> {\n     fn lower_trait_item_ref(&mut self, i: &AssocItem) -> hir::TraitItemRef {\n         let kind = match &i.kind {\n             AssocItemKind::Const(..) => hir::AssocItemKind::Const,\n-            AssocItemKind::TyAlias(..) => hir::AssocItemKind::Type,\n+            AssocItemKind::Type(..) => hir::AssocItemKind::Type,\n             AssocItemKind::Fn(box Fn { sig, .. }) => {\n                 hir::AssocItemKind::Fn { has_self: sig.decl.has_self() }\n             }\n             AssocItemKind::MacCall(..) => unimplemented!(),\n         };\n-        let id = hir::TraitItemId { def_id: self.local_def_id(i.id) };\n+        let id = hir::TraitItemId { def_id: hir::OwnerId { def_id: self.local_def_id(i.id) } };\n         hir::TraitItemRef {\n             id,\n             ident: self.lower_ident(i.ident),\n@@ -892,7 +906,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n \n                 (generics, hir::ImplItemKind::Fn(sig, body_id))\n             }\n-            AssocItemKind::TyAlias(box TyAlias { generics, where_clauses, ty, .. }) => {\n+            AssocItemKind::Type(box TyAlias { generics, where_clauses, ty, .. }) => {\n                 let mut generics = generics.clone();\n                 add_ty_alias_where_clause(&mut generics, *where_clauses, false);\n                 self.lower_generics(\n@@ -902,11 +916,11 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                     |this| match ty {\n                         None => {\n                             let ty = this.arena.alloc(this.ty(i.span, hir::TyKind::Err));\n-                            hir::ImplItemKind::TyAlias(ty)\n+                            hir::ImplItemKind::Type(ty)\n                         }\n                         Some(ty) => {\n                             let ty = this.lower_ty(ty, &ImplTraitContext::TypeAliasesOpaqueTy);\n-                            hir::ImplItemKind::TyAlias(ty)\n+                            hir::ImplItemKind::Type(ty)\n                         }\n                     },\n                 )\n@@ -930,18 +944,21 @@ impl<'hir> LoweringContext<'_, 'hir> {\n \n     fn lower_impl_item_ref(&mut self, i: &AssocItem) -> hir::ImplItemRef {\n         hir::ImplItemRef {\n-            id: hir::ImplItemId { def_id: self.local_def_id(i.id) },\n+            id: hir::ImplItemId { def_id: hir::OwnerId { def_id: self.local_def_id(i.id) } },\n             ident: self.lower_ident(i.ident),\n             span: self.lower_span(i.span),\n             kind: match &i.kind {\n                 AssocItemKind::Const(..) => hir::AssocItemKind::Const,\n-                AssocItemKind::TyAlias(..) => hir::AssocItemKind::Type,\n+                AssocItemKind::Type(..) => hir::AssocItemKind::Type,\n                 AssocItemKind::Fn(box Fn { sig, .. }) => {\n                     hir::AssocItemKind::Fn { has_self: sig.decl.has_self() }\n                 }\n                 AssocItemKind::MacCall(..) => unimplemented!(),\n             },\n-            trait_item_def_id: self.resolver.get_partial_res(i.id).map(|r| r.base_res().def_id()),\n+            trait_item_def_id: self\n+                .resolver\n+                .get_partial_res(i.id)\n+                .map(|r| r.expect_full_res().def_id()),\n         }\n     }\n \n@@ -1049,9 +1066,9 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         asyncness: Async,\n         body: Option<&Block>,\n     ) -> hir::BodyId {\n-        let closure_id = match asyncness {\n-            Async::Yes { closure_id, .. } => closure_id,\n-            Async::No => return self.lower_fn_body_block(span, decl, body),\n+        let (closure_id, body) = match (asyncness, body) {\n+            (Async::Yes { closure_id, .. }, Some(body)) => (closure_id, body),\n+            _ => return self.lower_fn_body_block(span, decl, body),\n         };\n \n         self.lower_body(|this| {\n@@ -1193,16 +1210,15 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 parameters.push(new_parameter);\n             }\n \n-            let body_span = body.map_or(span, |b| b.span);\n             let async_expr = this.make_async_expr(\n                 CaptureBy::Value,\n                 closure_id,\n                 None,\n-                body_span,\n+                body.span,\n                 hir::AsyncGeneratorKind::Fn,\n                 |this| {\n                     // Create a block from the user's function body:\n-                    let user_body = this.lower_block_expr_opt(body_span, body);\n+                    let user_body = this.lower_block_expr(body);\n \n                     // Transform into `drop-temps { <user-body> }`, an expression:\n                     let desugared_span =\n@@ -1234,7 +1250,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n \n             (\n                 this.arena.alloc_from_iter(parameters),\n-                this.expr(body_span, async_expr, AttrVec::new()),\n+                this.expr(body.span, async_expr, AttrVec::new()),\n             )\n         })\n     }\n@@ -1280,10 +1296,19 @@ impl<'hir> LoweringContext<'_, 'hir> {\n     }\n \n     fn error_on_invalid_abi(&self, abi: StrLit) {\n+        let abi_names = abi::enabled_names(self.tcx.features(), abi.span)\n+            .iter()\n+            .map(|s| Symbol::intern(s))\n+            .collect::<Vec<_>>();\n+        let suggested_name = find_best_match_for_name(&abi_names, abi.symbol_unescaped, None);\n         self.tcx.sess.emit_err(InvalidAbi {\n+            abi: abi.symbol_unescaped,\n             span: abi.span,\n-            abi: abi.symbol,\n-            valid_abis: abi::all_names().join(\", \"),\n+            suggestion: suggested_name.map(|suggested_name| InvalidAbiSuggestion {\n+                span: abi.span,\n+                suggestion: format!(\"\\\"{suggested_name}\\\"\"),\n+            }),\n+            command: \"rustc --print=calling-conventions\".to_string(),\n         });\n     }\n \n@@ -1335,9 +1360,9 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 match self\n                     .resolver\n                     .get_partial_res(bound_pred.bounded_ty.id)\n-                    .map(|d| (d.base_res(), d.unresolved_segments()))\n+                    .and_then(|r| r.full_res())\n                 {\n-                    Some((Res::Def(DefKind::TyParam, def_id), 0))\n+                    Some(Res::Def(DefKind::TyParam, def_id))\n                         if bound_pred.bound_generic_params.is_empty() =>\n                     {\n                         generics\n@@ -1464,6 +1489,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 let bounded_ty =\n                     self.ty_path(ty_id, param_span, hir::QPath::Resolved(None, ty_path));\n                 Some(hir::WherePredicate::BoundPredicate(hir::WhereBoundPredicate {\n+                    hir_id: self.next_id(),\n                     bounded_ty: self.arena.alloc(bounded_ty),\n                     bounds,\n                     span,\n@@ -1494,6 +1520,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 ref bounds,\n                 span,\n             }) => hir::WherePredicate::BoundPredicate(hir::WhereBoundPredicate {\n+                hir_id: self.next_id(),\n                 bound_generic_params: self.lower_generic_params(bound_generic_params),\n                 bounded_ty: self\n                     .lower_ty(bounded_ty, &ImplTraitContext::Disallowed(ImplTraitPosition::Type)),"}, {"sha": "427b71722abcc5cfc4cc8cb5668d6aefb8f0976a", "filename": "compiler/rustc_ast_lowering/src/lib.rs", "status": "modified", "additions": 77, "deletions": 51, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "patch": "@@ -32,7 +32,6 @@\n \n #![feature(box_patterns)]\n #![feature(let_chains)]\n-#![cfg_attr(bootstrap, feature(let_else))]\n #![feature(never_type)]\n #![recursion_limit = \"256\"]\n #![allow(rustc::potential_query_instability)]\n@@ -62,8 +61,8 @@ use rustc_hir::def_id::{LocalDefId, CRATE_DEF_ID};\n use rustc_hir::definitions::DefPathData;\n use rustc_hir::{ConstArg, GenericArg, ItemLocalId, ParamName, TraitCandidate};\n use rustc_index::vec::{Idx, IndexVec};\n-use rustc_middle::span_bug;\n use rustc_middle::ty::{ResolverAstLowering, TyCtxt};\n+use rustc_middle::{bug, span_bug};\n use rustc_session::parse::feature_err;\n use rustc_span::hygiene::MacroKind;\n use rustc_span::source_map::DesugaringKind;\n@@ -126,7 +125,7 @@ struct LoweringContext<'a, 'hir> {\n     is_in_trait_impl: bool,\n     is_in_dyn_type: bool,\n \n-    current_hir_id_owner: LocalDefId,\n+    current_hir_id_owner: hir::OwnerId,\n     item_local_id_counter: hir::ItemLocalId,\n     local_id_to_def_id: SortedMap<ItemLocalId, LocalDefId>,\n     trait_map: FxHashMap<ItemLocalId, Box<[TraitCandidate]>>,\n@@ -161,6 +160,10 @@ trait ResolverAstLoweringExt {\n     fn legacy_const_generic_args(&self, expr: &Expr) -> Option<Vec<usize>>;\n     fn get_partial_res(&self, id: NodeId) -> Option<PartialRes>;\n     fn get_import_res(&self, id: NodeId) -> PerNS<Option<Res<NodeId>>>;\n+    // Clones the resolution (if any) on 'source' and applies it\n+    // to 'target'. Used when desugaring a `UseTreeKind::Nested` to\n+    // multiple `UseTreeKind::Simple`s\n+    fn clone_res(&mut self, source: NodeId, target: NodeId);\n     fn get_label_res(&self, id: NodeId) -> Option<NodeId>;\n     fn get_lifetime_res(&self, id: NodeId) -> Option<LifetimeRes>;\n     fn take_extra_lifetime_params(&mut self, id: NodeId) -> Vec<(Ident, NodeId, LifetimeRes)>;\n@@ -176,12 +179,7 @@ impl ResolverAstLoweringExt for ResolverAstLowering {\n                 return None;\n             }\n \n-            let partial_res = self.partial_res_map.get(&expr.id)?;\n-            if partial_res.unresolved_segments() != 0 {\n-                return None;\n-            }\n-\n-            if let Res::Def(DefKind::Fn, def_id) = partial_res.base_res() {\n+            if let Res::Def(DefKind::Fn, def_id) = self.partial_res_map.get(&expr.id)?.full_res()? {\n                 // We only support cross-crate argument rewriting. Uses\n                 // within the same crate should be updated to use the new\n                 // const generics style.\n@@ -198,6 +196,12 @@ impl ResolverAstLoweringExt for ResolverAstLowering {\n         None\n     }\n \n+    fn clone_res(&mut self, source: NodeId, target: NodeId) {\n+        if let Some(res) = self.partial_res_map.get(&source) {\n+            self.partial_res_map.insert(target, *res);\n+        }\n+    }\n+\n     /// Obtains resolution for a `NodeId` with a single resolution.\n     fn get_partial_res(&self, id: NodeId) -> Option<PartialRes> {\n         self.partial_res_map.get(&id).copied()\n@@ -502,6 +506,17 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         start\n     }\n \n+    /// Given the id of some node in the AST, finds the `LocalDefId` associated with it by the name\n+    /// resolver (if any).\n+    fn orig_opt_local_def_id(&self, node: NodeId) -> Option<LocalDefId> {\n+        self.resolver.node_id_to_def_id.get(&node).map(|local_def_id| *local_def_id)\n+    }\n+\n+    fn orig_local_def_id(&self, node: NodeId) -> LocalDefId {\n+        self.orig_opt_local_def_id(node)\n+            .unwrap_or_else(|| panic!(\"no entry for node id: `{:?}`\", node))\n+    }\n+\n     /// Given the id of some node in the AST, finds the `LocalDefId` associated with it by the name\n     /// resolver (if any), after applying any remapping from `get_remapped_def_id`.\n     ///\n@@ -516,10 +531,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     /// we would create an opaque type `type FooReturn<'a1> = impl Debug + 'a1`.\n     /// When lowering the `Debug + 'a` bounds, we add a remapping to map `'a` to `'a1`.\n     fn opt_local_def_id(&self, node: NodeId) -> Option<LocalDefId> {\n-        self.resolver\n-            .node_id_to_def_id\n-            .get(&node)\n-            .map(|local_def_id| self.get_remapped_def_id(*local_def_id))\n+        self.orig_opt_local_def_id(node).map(|local_def_id| self.get_remapped_def_id(local_def_id))\n     }\n \n     fn local_def_id(&self, node: NodeId) -> LocalDefId {\n@@ -528,9 +540,9 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n \n     /// Get the previously recorded `to` local def id given the `from` local def id, obtained using\n     /// `generics_def_id_map` field.\n-    fn get_remapped_def_id(&self, mut local_def_id: LocalDefId) -> LocalDefId {\n+    fn get_remapped_def_id(&self, local_def_id: LocalDefId) -> LocalDefId {\n         // `generics_def_id_map` is a stack of mappings. As we go deeper in impl traits nesting we\n-        // push new mappings so we need to try first the latest mappings, hence `iter().rev()`.\n+        // push new mappings, so we first need to get the latest (innermost) mappings, hence `iter().rev()`.\n         //\n         // Consider:\n         //\n@@ -540,18 +552,13 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         //\n         // `[[fn#'b -> impl_trait#'b], [fn#'b -> impl_sized#'b]]`\n         //\n-        // for the opaque type generated on `impl Sized + 'b`, We want the result to be:\n-        // impl_sized#'b, so iterating forward is the wrong thing to do.\n-        for map in self.generics_def_id_map.iter().rev() {\n-            if let Some(r) = map.get(&local_def_id) {\n-                debug!(\"def_id_remapper: remapping from `{local_def_id:?}` to `{r:?}`\");\n-                local_def_id = *r;\n-            } else {\n-                debug!(\"def_id_remapper: no remapping for `{local_def_id:?}` found in map\");\n-            }\n-        }\n-\n-        local_def_id\n+        // for the opaque type generated on `impl Sized + 'b`, we want the result to be: impl_sized#'b.\n+        // So, if we were trying to find first from the start (outermost) would give the wrong result, impl_trait#'b.\n+        self.generics_def_id_map\n+            .iter()\n+            .rev()\n+            .find_map(|map| map.get(&local_def_id).map(|local_def_id| *local_def_id))\n+            .unwrap_or(local_def_id)\n     }\n \n     /// Freshen the `LoweringContext` and ready it to lower a nested item.\n@@ -572,7 +579,8 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         let current_node_ids = std::mem::take(&mut self.node_id_to_local_id);\n         let current_id_to_def_id = std::mem::take(&mut self.local_id_to_def_id);\n         let current_trait_map = std::mem::take(&mut self.trait_map);\n-        let current_owner = std::mem::replace(&mut self.current_hir_id_owner, def_id);\n+        let current_owner =\n+            std::mem::replace(&mut self.current_hir_id_owner, hir::OwnerId { def_id });\n         let current_local_counter =\n             std::mem::replace(&mut self.item_local_id_counter, hir::ItemLocalId::new(1));\n         let current_impl_trait_defs = std::mem::take(&mut self.impl_trait_defs);\n@@ -587,7 +595,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         debug_assert_eq!(_old, None);\n \n         let item = f(self);\n-        debug_assert_eq!(def_id, item.def_id());\n+        debug_assert_eq!(def_id, item.def_id().def_id);\n         // `f` should have consumed all the elements in these vectors when constructing `item`.\n         debug_assert!(self.impl_trait_defs.is_empty());\n         debug_assert!(self.impl_trait_bounds.is_empty());\n@@ -753,12 +761,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     }\n \n     fn expect_full_res(&mut self, id: NodeId) -> Res<NodeId> {\n-        self.resolver.get_partial_res(id).map_or(Res::Err, |pr| {\n-            if pr.unresolved_segments() != 0 {\n-                panic!(\"path not fully resolved: {:?}\", pr);\n-            }\n-            pr.base_res()\n-        })\n+        self.resolver.get_partial_res(id).map_or(Res::Err, |pr| pr.expect_full_res())\n     }\n \n     fn expect_full_res_from_use(&mut self, id: NodeId) -> impl Iterator<Item = Res<NodeId>> {\n@@ -786,7 +789,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     /// Mark a span as relative to the current owning item.\n     fn lower_span(&self, span: Span) -> Span {\n         if self.tcx.sess.opts.unstable_opts.incremental_relative_spans {\n-            span.with_parent(Some(self.current_hir_id_owner))\n+            span.with_parent(Some(self.current_hir_id_owner.def_id))\n         } else {\n             // Do not make spans relative when not using incremental compilation.\n             span\n@@ -812,7 +815,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             LifetimeRes::Fresh { param, .. } => {\n                 // Late resolution delegates to us the creation of the `LocalDefId`.\n                 let _def_id = self.create_def(\n-                    self.current_hir_id_owner,\n+                    self.current_hir_id_owner.def_id,\n                     param,\n                     DefPathData::LifetimeNs(kw::UnderscoreLifetime),\n                 );\n@@ -1060,9 +1063,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                     // Desugar `AssocTy: Bounds` into `AssocTy = impl Bounds`. We do this by\n                     // constructing the HIR for `impl bounds...` and then lowering that.\n \n-                    let parent_def_id = self.current_hir_id_owner;\n                     let impl_trait_node_id = self.next_node_id();\n-                    self.create_def(parent_def_id, impl_trait_node_id, DefPathData::ImplTrait);\n \n                     self.with_dyn_type_scope(false, |this| {\n                         let node_id = this.next_node_id();\n@@ -1140,8 +1141,11 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                     // type and value namespaces. If we resolved the path in the value namespace, we\n                     // transform it into a generic const argument.\n                     TyKind::Path(ref qself, ref path) => {\n-                        if let Some(partial_res) = self.resolver.get_partial_res(ty.id) {\n-                            let res = partial_res.base_res();\n+                        if let Some(res) = self\n+                            .resolver\n+                            .get_partial_res(ty.id)\n+                            .and_then(|partial_res| partial_res.full_res())\n+                        {\n                             if !res.matches_ns(Namespace::TypeNS) {\n                                 debug!(\n                                     \"lower_generic_arg: Lowering type argument as const argument: {:?}\",\n@@ -1154,7 +1158,11 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                                 let node_id = self.next_node_id();\n \n                                 // Add a definition for the in-band const def.\n-                                self.create_def(parent_def_id, node_id, DefPathData::AnonConst);\n+                                self.create_def(\n+                                    parent_def_id.def_id,\n+                                    node_id,\n+                                    DefPathData::AnonConst,\n+                                );\n \n                                 let span = self.lower_span(ty.span);\n                                 let path_expr = Expr {\n@@ -1204,8 +1212,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         // by `ty_path`.\n         if qself.is_none()\n             && let Some(partial_res) = self.resolver.get_partial_res(t.id)\n-            && partial_res.unresolved_segments() == 0\n-            && let Res::Def(DefKind::Trait | DefKind::TraitAlias, _) = partial_res.base_res()\n+            && let Some(Res::Def(DefKind::Trait | DefKind::TraitAlias, _)) = partial_res.full_res()\n         {\n             let (bounds, lifetime_bound) = self.with_dyn_type_scope(true, |this| {\n                 let poly_trait_ref = this.ast_arena.ptr.alloc(PolyTraitRef {\n@@ -1349,9 +1356,14 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                         def_node_id,\n                         bounds,\n                         false,\n-                        &ImplTraitContext::TypeAliasesOpaqueTy,\n+                        itctx,\n                     ),\n                     ImplTraitContext::Universal => {\n+                        self.create_def(\n+                            self.current_hir_id_owner.def_id,\n+                            def_node_id,\n+                            DefPathData::ImplTrait,\n+                        );\n                         let span = t.span;\n                         let ident = Ident::from_str_and_span(&pprust::ty_to_string(t), span);\n                         let (param, bounds, path) =\n@@ -1445,7 +1457,17 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         // frequently opened issues show.\n         let opaque_ty_span = self.mark_span_with_reason(DesugaringKind::OpaqueTy, span, None);\n \n-        let opaque_ty_def_id = self.local_def_id(opaque_ty_node_id);\n+        let opaque_ty_def_id = match origin {\n+            hir::OpaqueTyOrigin::TyAlias => self.create_def(\n+                self.current_hir_id_owner.def_id,\n+                opaque_ty_node_id,\n+                DefPathData::ImplTrait,\n+            ),\n+            hir::OpaqueTyOrigin::FnReturn(fn_def_id) => {\n+                self.create_def(fn_def_id, opaque_ty_node_id, DefPathData::ImplTrait)\n+            }\n+            hir::OpaqueTyOrigin::AsyncFn(..) => bug!(\"unreachable\"),\n+        };\n         debug!(?opaque_ty_def_id);\n \n         // Contains the new lifetime definitions created for the TAIT (if any).\n@@ -1551,7 +1573,11 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         debug!(?lifetimes);\n \n         // `impl Trait` now just becomes `Foo<'a, 'b, ..>`.\n-        hir::TyKind::OpaqueDef(hir::ItemId { def_id: opaque_ty_def_id }, lifetimes, in_trait)\n+        hir::TyKind::OpaqueDef(\n+            hir::ItemId { def_id: hir::OwnerId { def_id: opaque_ty_def_id } },\n+            lifetimes,\n+            in_trait,\n+        )\n     }\n \n     /// Registers a new opaque type with the proper `NodeId`s and\n@@ -1567,7 +1593,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         // Generate an `type Foo = impl Trait;` declaration.\n         trace!(\"registering opaque type with id {:#?}\", opaque_ty_id);\n         let opaque_ty_item = hir::Item {\n-            def_id: opaque_ty_id,\n+            def_id: hir::OwnerId { def_id: opaque_ty_id },\n             ident: Ident::empty(),\n             kind: opaque_ty_item_kind,\n             vis_span: self.lower_span(span.shrink_to_lo()),\n@@ -1610,7 +1636,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n \n                 LifetimeRes::Fresh { param, binder: _ } => {\n                     debug_assert_eq!(lifetime.ident.name, kw::UnderscoreLifetime);\n-                    if let Some(old_def_id) = self.opt_local_def_id(param) && remapping.get(&old_def_id).is_none() {\n+                    if let Some(old_def_id) = self.orig_opt_local_def_id(param) && remapping.get(&old_def_id).is_none() {\n                         let node_id = self.next_node_id();\n \n                         let new_def_id = self.create_def(\n@@ -1855,7 +1881,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         let extra_lifetime_params = self.resolver.take_extra_lifetime_params(opaque_ty_node_id);\n         debug!(?extra_lifetime_params);\n         for (ident, outer_node_id, outer_res) in extra_lifetime_params {\n-            let outer_def_id = self.local_def_id(outer_node_id);\n+            let outer_def_id = self.orig_local_def_id(outer_node_id);\n             let inner_node_id = self.next_node_id();\n \n             // Add a definition for the in scope lifetime def.\n@@ -2018,7 +2044,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         // async fn, so the *type parameters* are inherited.  It's\n         // only the lifetime parameters that we must supply.\n         let opaque_ty_ref = hir::TyKind::OpaqueDef(\n-            hir::ItemId { def_id: opaque_ty_def_id },\n+            hir::ItemId { def_id: hir::OwnerId { def_id: opaque_ty_def_id } },\n             generic_args,\n             in_trait,\n         );"}, {"sha": "1af1633b5244badd53899e8002d189de5a4bfda3", "filename": "compiler/rustc_ast_lowering/src/pat.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_ast_lowering%2Fsrc%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_ast_lowering%2Fsrc%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fpat.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "patch": "@@ -239,7 +239,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         ident: Ident,\n         lower_sub: impl FnOnce(&mut Self) -> Option<&'hir hir::Pat<'hir>>,\n     ) -> hir::PatKind<'hir> {\n-        match self.resolver.get_partial_res(p.id).map(|d| d.base_res()) {\n+        match self.resolver.get_partial_res(p.id).map(|d| d.expect_full_res()) {\n             // `None` can occur in body-less function signatures\n             res @ (None | Some(Res::Local(_))) => {\n                 let canonical_id = match res {"}, {"sha": "888776cccac2d0c752f7f68717a94c2825664f8a", "filename": "compiler/rustc_ast_lowering/src/path.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_ast_lowering%2Fsrc%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_ast_lowering%2Fsrc%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fpath.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "patch": "@@ -29,11 +29,13 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n \n         let partial_res =\n             self.resolver.get_partial_res(id).unwrap_or_else(|| PartialRes::new(Res::Err));\n+        let base_res = partial_res.base_res();\n+        let unresolved_segments = partial_res.unresolved_segments();\n \n         let path_span_lo = p.span.shrink_to_lo();\n-        let proj_start = p.segments.len() - partial_res.unresolved_segments();\n+        let proj_start = p.segments.len() - unresolved_segments;\n         let path = self.arena.alloc(hir::Path {\n-            res: self.lower_res(partial_res.base_res()),\n+            res: self.lower_res(base_res),\n             segments: self.arena.alloc_from_iter(p.segments[..proj_start].iter().enumerate().map(\n                 |(i, segment)| {\n                     let param_mode = match (qself_position, param_mode) {\n@@ -46,7 +48,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                         _ => param_mode,\n                     };\n \n-                    let parenthesized_generic_args = match partial_res.base_res() {\n+                    let parenthesized_generic_args = match base_res {\n                         // `a::b::Trait(Args)`\n                         Res::Def(DefKind::Trait, _) if i + 1 == proj_start => {\n                             ParenthesizedGenericArgs::Ok\n@@ -83,7 +85,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n \n         // Simple case, either no projections, or only fully-qualified.\n         // E.g., `std::mem::size_of` or `<I as Iterator>::Item`.\n-        if partial_res.unresolved_segments() == 0 {\n+        if unresolved_segments == 0 {\n             return hir::QPath::Resolved(qself, path);\n         }\n "}, {"sha": "f42aca685f60eaa46cdb5197b0351fac658c7079", "filename": "compiler/rustc_ast_passes/src/ast_validation.rs", "status": "modified", "additions": 43, "deletions": 21, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "patch": "@@ -38,6 +38,13 @@ enum SelfSemantic {\n     No,\n }\n \n+/// What is the context that prevents using `~const`?\n+enum DisallowTildeConstContext<'a> {\n+    TraitObject,\n+    ImplTrait,\n+    Fn(FnKind<'a>),\n+}\n+\n struct AstValidator<'a> {\n     session: &'a Session,\n \n@@ -56,7 +63,7 @@ struct AstValidator<'a> {\n     /// e.g., `impl Iterator<Item = impl Debug>`.\n     outer_impl_trait: Option<Span>,\n \n-    is_tilde_const_allowed: bool,\n+    disallow_tilde_const: Option<DisallowTildeConstContext<'a>>,\n \n     /// Used to ban `impl Trait` in path projections like `<impl Iterator>::Item`\n     /// or `Foo::Bar<impl Trait>`\n@@ -93,18 +100,26 @@ impl<'a> AstValidator<'a> {\n         self.is_impl_trait_banned = old;\n     }\n \n-    fn with_tilde_const(&mut self, allowed: bool, f: impl FnOnce(&mut Self)) {\n-        let old = mem::replace(&mut self.is_tilde_const_allowed, allowed);\n+    fn with_tilde_const(\n+        &mut self,\n+        disallowed: Option<DisallowTildeConstContext<'a>>,\n+        f: impl FnOnce(&mut Self),\n+    ) {\n+        let old = mem::replace(&mut self.disallow_tilde_const, disallowed);\n         f(self);\n-        self.is_tilde_const_allowed = old;\n+        self.disallow_tilde_const = old;\n     }\n \n     fn with_tilde_const_allowed(&mut self, f: impl FnOnce(&mut Self)) {\n-        self.with_tilde_const(true, f)\n+        self.with_tilde_const(None, f)\n     }\n \n-    fn with_banned_tilde_const(&mut self, f: impl FnOnce(&mut Self)) {\n-        self.with_tilde_const(false, f)\n+    fn with_banned_tilde_const(\n+        &mut self,\n+        ctx: DisallowTildeConstContext<'a>,\n+        f: impl FnOnce(&mut Self),\n+    ) {\n+        self.with_tilde_const(Some(ctx), f)\n     }\n \n     fn with_let_management(\n@@ -172,7 +187,7 @@ impl<'a> AstValidator<'a> {\n     fn with_impl_trait(&mut self, outer: Option<Span>, f: impl FnOnce(&mut Self)) {\n         let old = mem::replace(&mut self.outer_impl_trait, outer);\n         if outer.is_some() {\n-            self.with_banned_tilde_const(f);\n+            self.with_banned_tilde_const(DisallowTildeConstContext::ImplTrait, f);\n         } else {\n             f(self);\n         }\n@@ -197,7 +212,10 @@ impl<'a> AstValidator<'a> {\n             TyKind::ImplTrait(..) => {\n                 self.with_impl_trait(Some(t.span), |this| visit::walk_ty(this, t))\n             }\n-            TyKind::TraitObject(..) => self.with_banned_tilde_const(|this| visit::walk_ty(this, t)),\n+            TyKind::TraitObject(..) => self\n+                .with_banned_tilde_const(DisallowTildeConstContext::TraitObject, |this| {\n+                    visit::walk_ty(this, t)\n+                }),\n             TyKind::Path(ref qself, ref path) => {\n                 // We allow these:\n                 //  - `Option<impl Trait>`\n@@ -1411,13 +1429,15 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n                     );\n                     err.emit();\n                 }\n-                (_, TraitBoundModifier::MaybeConst) => {\n-                    if !self.is_tilde_const_allowed {\n-                        self.err_handler()\n-                            .struct_span_err(bound.span(), \"`~const` is not allowed here\")\n-                            .note(\"only allowed on bounds on traits' associated types and functions, const fns, const impls and its associated functions\")\n-                            .emit();\n-                    }\n+                (_, TraitBoundModifier::MaybeConst) if let Some(reason) = &self.disallow_tilde_const => {\n+                    let mut err = self.err_handler().struct_span_err(bound.span(), \"`~const` is not allowed here\");\n+                    match reason {\n+                        DisallowTildeConstContext::TraitObject => err.note(\"trait objects cannot have `~const` trait bounds\"),\n+                        DisallowTildeConstContext::ImplTrait => err.note(\"`impl Trait`s cannot have `~const` trait bounds\"),\n+                        DisallowTildeConstContext::Fn(FnKind::Closure(..)) => err.note(\"closures cannot have `~const` trait bounds\"),\n+                        DisallowTildeConstContext::Fn(FnKind::Fn(_, ident, ..)) => err.span_note(ident.span, \"this function is not `const`, so it cannot have `~const` trait bounds\"),\n+                    };\n+                    err.emit();\n                 }\n                 (_, TraitBoundModifier::MaybeConstMaybe) => {\n                     self.err_handler()\n@@ -1524,10 +1544,12 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n         }\n \n         let tilde_const_allowed =\n-            matches!(fk.header(), Some(FnHeader { constness: Const::Yes(_), .. }))\n+            matches!(fk.header(), Some(FnHeader { constness: ast::Const::Yes(_), .. }))\n                 || matches!(fk.ctxt(), Some(FnCtxt::Assoc(_)));\n \n-        self.with_tilde_const(tilde_const_allowed, |this| visit::walk_fn(this, fk));\n+        let disallowed = (!tilde_const_allowed).then(|| DisallowTildeConstContext::Fn(fk));\n+\n+        self.with_tilde_const(disallowed, |this| visit::walk_fn(this, fk));\n     }\n \n     fn visit_assoc_item(&mut self, item: &'a AssocItem, ctxt: AssocCtxt) {\n@@ -1557,7 +1579,7 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n                         });\n                     }\n                 }\n-                AssocItemKind::TyAlias(box TyAlias {\n+                AssocItemKind::Type(box TyAlias {\n                     generics,\n                     where_clauses,\n                     where_predicates_split,\n@@ -1596,7 +1618,7 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n         }\n \n         match item.kind {\n-            AssocItemKind::TyAlias(box TyAlias { ref generics, ref bounds, ref ty, .. })\n+            AssocItemKind::Type(box TyAlias { ref generics, ref bounds, ref ty, .. })\n                 if ctxt == AssocCtxt::Trait =>\n             {\n                 self.visit_vis(&item.vis);\n@@ -1771,7 +1793,7 @@ pub fn check_crate(session: &Session, krate: &Crate, lints: &mut LintBuffer) ->\n         in_const_trait_impl: false,\n         has_proc_macro_decls: false,\n         outer_impl_trait: None,\n-        is_tilde_const_allowed: false,\n+        disallow_tilde_const: None,\n         is_impl_trait_banned: false,\n         is_assoc_ty_bound_banned: false,\n         forbidden_let_reason: Some(ForbiddenLetReason::GenericForbidden),"}, {"sha": "ba2ed24fc08fc08095d240d45d6c90f334c6371c", "filename": "compiler/rustc_ast_passes/src/errors.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_ast_passes%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_ast_passes%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_passes%2Fsrc%2Ferrors.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "patch": "@@ -1,6 +1,6 @@\n //! Errors emitted by ast_passes.\n \n-use rustc_errors::{fluent, AddToDiagnostic, Applicability, Diagnostic};\n+use rustc_errors::{fluent, AddToDiagnostic, Applicability, Diagnostic, SubdiagnosticMessage};\n use rustc_macros::{Diagnostic, Subdiagnostic};\n use rustc_span::{Span, Symbol};\n \n@@ -17,7 +17,10 @@ pub struct ForbiddenLet {\n }\n \n impl AddToDiagnostic for ForbiddenLetReason {\n-    fn add_to_diagnostic(self, diag: &mut Diagnostic) {\n+    fn add_to_diagnostic_with<F>(self, diag: &mut Diagnostic, _: F)\n+    where\n+        F: Fn(&mut Diagnostic, SubdiagnosticMessage) -> SubdiagnosticMessage,\n+    {\n         match self {\n             Self::GenericForbidden => {}\n             Self::NotSupportedOr(span) => {\n@@ -228,7 +231,10 @@ pub struct ExternBlockSuggestion {\n }\n \n impl AddToDiagnostic for ExternBlockSuggestion {\n-    fn add_to_diagnostic(self, diag: &mut Diagnostic) {\n+    fn add_to_diagnostic_with<F>(self, diag: &mut Diagnostic, _: F)\n+    where\n+        F: Fn(&mut Diagnostic, SubdiagnosticMessage) -> SubdiagnosticMessage,\n+    {\n         let start_suggestion = if let Some(abi) = self.abi {\n             format!(\"extern \\\"{}\\\" {{\", abi)\n         } else {"}, {"sha": "0f11c1766528a004db5fc63a4b96441f8bd573b3", "filename": "compiler/rustc_ast_passes/src/feature_gate.rs", "status": "modified", "additions": 24, "deletions": 205, "changes": 229, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_ast_passes%2Fsrc%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_ast_passes%2Fsrc%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_passes%2Fsrc%2Ffeature_gate.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "patch": "@@ -3,13 +3,13 @@ use rustc_ast::visit::{self, AssocCtxt, FnCtxt, FnKind, Visitor};\n use rustc_ast::{AssocConstraint, AssocConstraintKind, NodeId};\n use rustc_ast::{PatKind, RangeEnd, VariantData};\n use rustc_errors::{struct_span_err, Applicability, StashKey};\n-use rustc_feature::Features;\n-use rustc_feature::{AttributeGate, BuiltinAttribute, BUILTIN_ATTRIBUTE_MAP};\n-use rustc_session::parse::{feature_err, feature_warn};\n+use rustc_feature::{AttributeGate, BuiltinAttribute, Features, GateIssue, BUILTIN_ATTRIBUTE_MAP};\n+use rustc_session::parse::{feature_err, feature_err_issue, feature_warn};\n use rustc_session::Session;\n use rustc_span::source_map::Spanned;\n use rustc_span::symbol::sym;\n use rustc_span::Span;\n+use rustc_target::spec::abi;\n \n macro_rules! gate_feature_fn {\n     ($visitor: expr, $has_feature: expr, $span: expr, $name: expr, $explain: expr, $help: expr) => {{\n@@ -84,210 +84,26 @@ impl<'a> PostExpansionVisitor<'a> {\n             }\n         }\n \n-        match symbol_unescaped.as_str() {\n-            // Stable\n-            \"Rust\" | \"C\" | \"cdecl\" | \"stdcall\" | \"fastcall\" | \"aapcs\" | \"win64\" | \"sysv64\"\n-            | \"system\" => {}\n-            \"rust-intrinsic\" => {\n-                gate_feature_post!(&self, intrinsics, span, \"intrinsics are subject to change\");\n-            }\n-            \"platform-intrinsic\" => {\n-                gate_feature_post!(\n-                    &self,\n-                    platform_intrinsics,\n-                    span,\n-                    \"platform intrinsics are experimental and possibly buggy\"\n-                );\n-            }\n-            \"vectorcall\" => {\n-                gate_feature_post!(\n-                    &self,\n-                    abi_vectorcall,\n-                    span,\n-                    \"vectorcall is experimental and subject to change\"\n-                );\n-            }\n-            \"thiscall\" => {\n-                gate_feature_post!(\n-                    &self,\n-                    abi_thiscall,\n-                    span,\n-                    \"thiscall is experimental and subject to change\"\n-                );\n-            }\n-            \"rust-call\" => {\n-                gate_feature_post!(\n-                    &self,\n-                    unboxed_closures,\n-                    span,\n-                    \"rust-call ABI is subject to change\"\n-                );\n-            }\n-            \"rust-cold\" => {\n-                gate_feature_post!(\n-                    &self,\n-                    rust_cold_cc,\n-                    span,\n-                    \"rust-cold is experimental and subject to change\"\n-                );\n-            }\n-            \"ptx-kernel\" => {\n-                gate_feature_post!(\n-                    &self,\n-                    abi_ptx,\n-                    span,\n-                    \"PTX ABIs are experimental and subject to change\"\n-                );\n-            }\n-            \"unadjusted\" => {\n-                gate_feature_post!(\n-                    &self,\n-                    abi_unadjusted,\n-                    span,\n-                    \"unadjusted ABI is an implementation detail and perma-unstable\"\n-                );\n-            }\n-            \"msp430-interrupt\" => {\n-                gate_feature_post!(\n-                    &self,\n-                    abi_msp430_interrupt,\n-                    span,\n-                    \"msp430-interrupt ABI is experimental and subject to change\"\n-                );\n-            }\n-            \"x86-interrupt\" => {\n-                gate_feature_post!(\n-                    &self,\n-                    abi_x86_interrupt,\n-                    span,\n-                    \"x86-interrupt ABI is experimental and subject to change\"\n-                );\n-            }\n-            \"amdgpu-kernel\" => {\n-                gate_feature_post!(\n-                    &self,\n-                    abi_amdgpu_kernel,\n-                    span,\n-                    \"amdgpu-kernel ABI is experimental and subject to change\"\n-                );\n-            }\n-            \"avr-interrupt\" | \"avr-non-blocking-interrupt\" => {\n-                gate_feature_post!(\n-                    &self,\n-                    abi_avr_interrupt,\n-                    span,\n-                    \"avr-interrupt and avr-non-blocking-interrupt ABIs are experimental and subject to change\"\n-                );\n-            }\n-            \"efiapi\" => {\n-                gate_feature_post!(\n-                    &self,\n-                    abi_efiapi,\n-                    span,\n-                    \"efiapi ABI is experimental and subject to change\"\n-                );\n-            }\n-            \"C-cmse-nonsecure-call\" => {\n-                gate_feature_post!(\n-                    &self,\n-                    abi_c_cmse_nonsecure_call,\n-                    span,\n-                    \"C-cmse-nonsecure-call ABI is experimental and subject to change\"\n-                );\n-            }\n-            \"C-unwind\" => {\n-                gate_feature_post!(\n-                    &self,\n-                    c_unwind,\n-                    span,\n-                    \"C-unwind ABI is experimental and subject to change\"\n-                );\n-            }\n-            \"stdcall-unwind\" => {\n-                gate_feature_post!(\n-                    &self,\n-                    c_unwind,\n-                    span,\n-                    \"stdcall-unwind ABI is experimental and subject to change\"\n-                );\n-            }\n-            \"system-unwind\" => {\n-                gate_feature_post!(\n-                    &self,\n-                    c_unwind,\n-                    span,\n-                    \"system-unwind ABI is experimental and subject to change\"\n-                );\n-            }\n-            \"thiscall-unwind\" => {\n-                gate_feature_post!(\n-                    &self,\n-                    c_unwind,\n-                    span,\n-                    \"thiscall-unwind ABI is experimental and subject to change\"\n-                );\n-            }\n-            \"cdecl-unwind\" => {\n-                gate_feature_post!(\n-                    &self,\n-                    c_unwind,\n-                    span,\n-                    \"cdecl-unwind ABI is experimental and subject to change\"\n-                );\n-            }\n-            \"fastcall-unwind\" => {\n-                gate_feature_post!(\n-                    &self,\n-                    c_unwind,\n+        match abi::is_enabled(&self.features, span, symbol_unescaped.as_str()) {\n+            Ok(()) => (),\n+            Err(abi::AbiDisabled::Unstable { feature, explain }) => {\n+                feature_err_issue(\n+                    &self.sess.parse_sess,\n+                    feature,\n                     span,\n-                    \"fastcall-unwind ABI is experimental and subject to change\"\n-                );\n-            }\n-            \"vectorcall-unwind\" => {\n-                gate_feature_post!(\n-                    &self,\n-                    c_unwind,\n-                    span,\n-                    \"vectorcall-unwind ABI is experimental and subject to change\"\n-                );\n-            }\n-            \"aapcs-unwind\" => {\n-                gate_feature_post!(\n-                    &self,\n-                    c_unwind,\n-                    span,\n-                    \"aapcs-unwind ABI is experimental and subject to change\"\n-                );\n-            }\n-            \"win64-unwind\" => {\n-                gate_feature_post!(\n-                    &self,\n-                    c_unwind,\n-                    span,\n-                    \"win64-unwind ABI is experimental and subject to change\"\n-                );\n-            }\n-            \"sysv64-unwind\" => {\n-                gate_feature_post!(\n-                    &self,\n-                    c_unwind,\n-                    span,\n-                    \"sysv64-unwind ABI is experimental and subject to change\"\n-                );\n-            }\n-            \"wasm\" => {\n-                gate_feature_post!(\n-                    &self,\n-                    wasm_abi,\n-                    span,\n-                    \"wasm ABI is experimental and subject to change\"\n-                );\n+                    GateIssue::Language,\n+                    explain,\n+                )\n+                .emit();\n             }\n-            abi => {\n+            Err(abi::AbiDisabled::Unrecognized) => {\n                 if self.sess.opts.pretty.map_or(true, |ppm| ppm.needs_hir()) {\n                     self.sess.parse_sess.span_diagnostic.delay_span_bug(\n                         span,\n-                        &format!(\"unrecognized ABI not caught in lowering: {}\", abi),\n+                        &format!(\n+                            \"unrecognized ABI not caught in lowering: {}\",\n+                            symbol_unescaped.as_str()\n+                        ),\n                     );\n                 }\n             }\n@@ -645,7 +461,7 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n                     if let PatKind::Range(Some(_), None, Spanned { .. }) = inner_pat.kind {\n                         gate_feature_post!(\n                             &self,\n-                            half_open_range_patterns,\n+                            half_open_range_patterns_in_slices,\n                             pat.span,\n                             \"`X..` patterns in slices are experimental\"\n                         );\n@@ -701,7 +517,7 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n     fn visit_assoc_item(&mut self, i: &'a ast::AssocItem, ctxt: AssocCtxt) {\n         let is_fn = match i.kind {\n             ast::AssocItemKind::Fn(_) => true,\n-            ast::AssocItemKind::TyAlias(box ast::TyAlias { ref ty, .. }) => {\n+            ast::AssocItemKind::Type(box ast::TyAlias { ref ty, .. }) => {\n                 if let (Some(_), AssocCtxt::Trait) = (ty, ctxt) {\n                     gate_feature_post!(\n                         &self,\n@@ -773,7 +589,10 @@ pub fn check_crate(krate: &ast::Crate, sess: &Session) {\n     gate_all!(generators, \"yield syntax is experimental\");\n     gate_all!(raw_ref_op, \"raw address of syntax is experimental\");\n     gate_all!(const_trait_impl, \"const trait impls are experimental\");\n-    gate_all!(half_open_range_patterns, \"half-open range patterns are unstable\");\n+    gate_all!(\n+        half_open_range_patterns_in_slices,\n+        \"half-open range patterns in slices are unstable\"\n+    );\n     gate_all!(inline_const, \"inline-const is experimental\");\n     gate_all!(inline_const_pat, \"inline-const in pattern position is experimental\");\n     gate_all!(associated_const_equality, \"associated const equality is incomplete\");"}, {"sha": "f58fffc917200a2bcd1d605c02c58f7622b8cbf1", "filename": "compiler/rustc_ast_passes/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_ast_passes%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_ast_passes%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_passes%2Fsrc%2Flib.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "patch": "@@ -9,7 +9,6 @@\n #![feature(if_let_guard)]\n #![feature(iter_is_partitioned)]\n #![feature(let_chains)]\n-#![cfg_attr(bootstrap, feature(let_else))]\n #![recursion_limit = \"256\"]\n \n #[macro_use]"}, {"sha": "a3e3e823b08eb5b677cafe36e84e8bbe2009cf42", "filename": "compiler/rustc_ast_pretty/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_ast_pretty%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_ast_pretty%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_pretty%2FCargo.toml?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "patch": "@@ -4,7 +4,6 @@ version = \"0.0.0\"\n edition = \"2021\"\n \n [lib]\n-doctest = false\n \n [dependencies]\n rustc_span = { path = \"../rustc_span\" }"}, {"sha": "159853c9e245984cb122bfac9191b84e685e3d99", "filename": "compiler/rustc_ast_pretty/src/pprust/state/item.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate%2Fitem.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "patch": "@@ -516,7 +516,7 @@ impl<'a> State<'a> {\n             ast::AssocItemKind::Const(def, ty, body) => {\n                 self.print_item_const(ident, None, ty, body.as_deref(), vis, *def);\n             }\n-            ast::AssocItemKind::TyAlias(box ast::TyAlias {\n+            ast::AssocItemKind::Type(box ast::TyAlias {\n                 defaultness,\n                 generics,\n                 where_clauses,"}, {"sha": "6349ddf31d10b515c14d50cc1f6ad43b81d6d1a3", "filename": "compiler/rustc_attr/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_attr%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_attr%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_attr%2FCargo.toml?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "patch": "@@ -4,7 +4,6 @@ version = \"0.0.0\"\n edition = \"2021\"\n \n [lib]\n-doctest = false\n \n [dependencies]\n rustc_ast_pretty = { path = \"../rustc_ast_pretty\" }"}, {"sha": "4580ffcc6d8be694004fcdcf3c1a673be14ee02e", "filename": "compiler/rustc_attr/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_attr%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_attr%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_attr%2Fsrc%2Flib.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "patch": "@@ -5,7 +5,6 @@\n //! to this crate.\n \n #![feature(let_chains)]\n-#![cfg_attr(bootstrap, feature(let_else))]\n #![deny(rustc::untranslatable_diagnostic)]\n #![deny(rustc::diagnostic_outside_of_impl)]\n "}, {"sha": "87c113f3e30b7399c9d1b050c469e9237b87f223", "filename": "compiler/rustc_borrowck/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_borrowck%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_borrowck%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2FCargo.toml?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "patch": "@@ -4,7 +4,6 @@ version = \"0.0.0\"\n edition = \"2021\"\n \n [lib]\n-doctest = false\n \n [dependencies]\n either = \"1.5.0\""}, {"sha": "f185e402fc6dee77ea3b749fc9a4400b7d9b5094", "filename": "compiler/rustc_borrowck/src/constraint_generation.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_borrowck%2Fsrc%2Fconstraint_generation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_borrowck%2Fsrc%2Fconstraint_generation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fconstraint_generation.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "patch": "@@ -14,8 +14,8 @@ use crate::{\n     places_conflict, region_infer::values::LivenessValues,\n };\n \n-pub(super) fn generate_constraints<'cx, 'tcx>(\n-    infcx: &InferCtxt<'cx, 'tcx>,\n+pub(super) fn generate_constraints<'tcx>(\n+    infcx: &InferCtxt<'tcx>,\n     liveness_constraints: &mut LivenessValues<RegionVid>,\n     all_facts: &mut Option<AllFacts>,\n     location_table: &LocationTable,\n@@ -37,16 +37,16 @@ pub(super) fn generate_constraints<'cx, 'tcx>(\n }\n \n /// 'cg = the duration of the constraint generation process itself.\n-struct ConstraintGeneration<'cg, 'cx, 'tcx> {\n-    infcx: &'cg InferCtxt<'cx, 'tcx>,\n+struct ConstraintGeneration<'cg, 'tcx> {\n+    infcx: &'cg InferCtxt<'tcx>,\n     all_facts: &'cg mut Option<AllFacts>,\n     location_table: &'cg LocationTable,\n     liveness_constraints: &'cg mut LivenessValues<RegionVid>,\n     borrow_set: &'cg BorrowSet<'tcx>,\n     body: &'cg Body<'tcx>,\n }\n \n-impl<'cg, 'cx, 'tcx> Visitor<'tcx> for ConstraintGeneration<'cg, 'cx, 'tcx> {\n+impl<'cg, 'tcx> Visitor<'tcx> for ConstraintGeneration<'cg, 'tcx> {\n     fn visit_basic_block_data(&mut self, bb: BasicBlock, data: &BasicBlockData<'tcx>) {\n         self.super_basic_block_data(bb, data);\n     }\n@@ -156,7 +156,7 @@ impl<'cg, 'cx, 'tcx> Visitor<'tcx> for ConstraintGeneration<'cg, 'cx, 'tcx> {\n     }\n }\n \n-impl<'cx, 'cg, 'tcx> ConstraintGeneration<'cx, 'cg, 'tcx> {\n+impl<'cx, 'tcx> ConstraintGeneration<'cx, 'tcx> {\n     /// Some variable with type `live_ty` is \"regular live\" at\n     /// `location` -- i.e., it may be used later. This means that all\n     /// regions appearing in the type `live_ty` must be live at"}, {"sha": "58aeb43ef976f0c74132b7ed48ec8b21e8886b29", "filename": "compiler/rustc_borrowck/src/constraints/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_borrowck%2Fsrc%2Fconstraints%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_borrowck%2Fsrc%2Fconstraints%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fconstraints%2Fmod.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "patch": "@@ -92,7 +92,7 @@ pub struct OutlivesConstraint<'tcx> {\n     pub span: Span,\n \n     /// What caused this constraint?\n-    pub category: ConstraintCategory<'tcx>,\n+    pub category: ConstraintCategory,\n \n     /// Variance diagnostic information\n     pub variance_info: VarianceDiagInfo<'tcx>,"}, {"sha": "b162095f8a6cdf0692738aaaa1fe3d4205782ca4", "filename": "compiler/rustc_borrowck/src/consumers.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_borrowck%2Fsrc%2Fconsumers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_borrowck%2Fsrc%2Fconsumers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fconsumers.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "patch": "@@ -31,9 +31,8 @@ pub fn get_body_with_borrowck_facts<'tcx>(\n     def: ty::WithOptConstParam<LocalDefId>,\n ) -> BodyWithBorrowckFacts<'tcx> {\n     let (input_body, promoted) = tcx.mir_promoted(def);\n-    tcx.infer_ctxt().with_opaque_type_inference(DefiningAnchor::Bind(def.did)).enter(|infcx| {\n-        let input_body: &Body<'_> = &input_body.borrow();\n-        let promoted: &IndexVec<_, _> = &promoted.borrow();\n-        *super::do_mir_borrowck(&infcx, input_body, promoted, true).1.unwrap()\n-    })\n+    let infcx = tcx.infer_ctxt().with_opaque_type_inference(DefiningAnchor::Bind(def.did)).build();\n+    let input_body: &Body<'_> = &input_body.borrow();\n+    let promoted: &IndexVec<_, _> = &promoted.borrow();\n+    *super::do_mir_borrowck(&infcx, input_body, promoted, true).1.unwrap()\n }"}, {"sha": "02071ed6b36662975346651590ec08d5e74fb17a", "filename": "compiler/rustc_borrowck/src/diagnostics/bound_region_errors.rs", "status": "modified", "additions": 58, "deletions": 94, "changes": 152, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fbound_region_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fbound_region_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fbound_region_errors.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "patch": "@@ -56,7 +56,7 @@ impl<'tcx> UniverseInfo<'tcx> {\n     ) {\n         match self.0 {\n             UniverseInfoInner::RelateTys { expected, found } => {\n-                let err = mbcx.infcx.report_mismatched_types(\n+                let err = mbcx.infcx.err_ctxt().report_mismatched_types(\n                     &cause,\n                     expected,\n                     found,\n@@ -238,20 +238,11 @@ impl<'tcx> TypeOpInfo<'tcx> for PredicateQuery<'tcx> {\n         placeholder_region: ty::Region<'tcx>,\n         error_region: Option<ty::Region<'tcx>>,\n     ) -> Option<DiagnosticBuilder<'tcx, ErrorGuaranteed>> {\n-        mbcx.infcx.tcx.infer_ctxt().enter_with_canonical(\n-            cause.span,\n-            &self.canonical_query,\n-            |ref infcx, key, _| {\n-                let mut fulfill_cx = <dyn TraitEngine<'_>>::new(infcx.tcx);\n-                type_op_prove_predicate_with_cause(infcx, &mut *fulfill_cx, key, cause);\n-                try_extract_error_from_fulfill_cx(\n-                    fulfill_cx,\n-                    infcx,\n-                    placeholder_region,\n-                    error_region,\n-                )\n-            },\n-        )\n+        let (ref infcx, key, _) =\n+            mbcx.infcx.tcx.infer_ctxt().build_with_canonical(cause.span, &self.canonical_query);\n+        let mut fulfill_cx = <dyn TraitEngine<'_>>::new(infcx.tcx);\n+        type_op_prove_predicate_with_cause(infcx, &mut *fulfill_cx, key, cause);\n+        try_extract_error_from_fulfill_cx(fulfill_cx, infcx, placeholder_region, error_region)\n     }\n }\n \n@@ -288,37 +279,24 @@ where\n         placeholder_region: ty::Region<'tcx>,\n         error_region: Option<ty::Region<'tcx>>,\n     ) -> Option<DiagnosticBuilder<'tcx, ErrorGuaranteed>> {\n-        mbcx.infcx.tcx.infer_ctxt().enter_with_canonical(\n-            cause.span,\n-            &self.canonical_query,\n-            |ref infcx, key, _| {\n-                let mut fulfill_cx = <dyn TraitEngine<'_>>::new(infcx.tcx);\n-\n-                let mut selcx = SelectionContext::new(infcx);\n-\n-                // FIXME(lqd): Unify and de-duplicate the following with the actual\n-                // `rustc_traits::type_op::type_op_normalize` query to allow the span we need in the\n-                // `ObligationCause`. The normalization results are currently different between\n-                // `AtExt::normalize` used in the query and `normalize` called below: the former fails\n-                // to normalize the `nll/relate_tys/impl-fn-ignore-binder-via-bottom.rs` test. Check\n-                // after #85499 lands to see if its fixes have erased this difference.\n-                let (param_env, value) = key.into_parts();\n-                let Normalized { value: _, obligations } = rustc_trait_selection::traits::normalize(\n-                    &mut selcx,\n-                    param_env,\n-                    cause,\n-                    value.value,\n-                );\n-                fulfill_cx.register_predicate_obligations(infcx, obligations);\n-\n-                try_extract_error_from_fulfill_cx(\n-                    fulfill_cx,\n-                    infcx,\n-                    placeholder_region,\n-                    error_region,\n-                )\n-            },\n-        )\n+        let (ref infcx, key, _) =\n+            mbcx.infcx.tcx.infer_ctxt().build_with_canonical(cause.span, &self.canonical_query);\n+        let mut fulfill_cx = <dyn TraitEngine<'_>>::new(infcx.tcx);\n+\n+        let mut selcx = SelectionContext::new(infcx);\n+\n+        // FIXME(lqd): Unify and de-duplicate the following with the actual\n+        // `rustc_traits::type_op::type_op_normalize` query to allow the span we need in the\n+        // `ObligationCause`. The normalization results are currently different between\n+        // `AtExt::normalize` used in the query and `normalize` called below: the former fails\n+        // to normalize the `nll/relate_tys/impl-fn-ignore-binder-via-bottom.rs` test. Check\n+        // after #85499 lands to see if its fixes have erased this difference.\n+        let (param_env, value) = key.into_parts();\n+        let Normalized { value: _, obligations } =\n+            rustc_trait_selection::traits::normalize(&mut selcx, param_env, cause, value.value);\n+        fulfill_cx.register_predicate_obligations(infcx, obligations);\n+\n+        try_extract_error_from_fulfill_cx(fulfill_cx, infcx, placeholder_region, error_region)\n     }\n }\n \n@@ -349,21 +327,11 @@ impl<'tcx> TypeOpInfo<'tcx> for AscribeUserTypeQuery<'tcx> {\n         placeholder_region: ty::Region<'tcx>,\n         error_region: Option<ty::Region<'tcx>>,\n     ) -> Option<DiagnosticBuilder<'tcx, ErrorGuaranteed>> {\n-        mbcx.infcx.tcx.infer_ctxt().enter_with_canonical(\n-            cause.span,\n-            &self.canonical_query,\n-            |ref infcx, key, _| {\n-                let mut fulfill_cx = <dyn TraitEngine<'_>>::new(infcx.tcx);\n-                type_op_ascribe_user_type_with_span(infcx, &mut *fulfill_cx, key, Some(cause.span))\n-                    .ok()?;\n-                try_extract_error_from_fulfill_cx(\n-                    fulfill_cx,\n-                    infcx,\n-                    placeholder_region,\n-                    error_region,\n-                )\n-            },\n-        )\n+        let (ref infcx, key, _) =\n+            mbcx.infcx.tcx.infer_ctxt().build_with_canonical(cause.span, &self.canonical_query);\n+        let mut fulfill_cx = <dyn TraitEngine<'_>>::new(infcx.tcx);\n+        type_op_ascribe_user_type_with_span(infcx, &mut *fulfill_cx, key, Some(cause.span)).ok()?;\n+        try_extract_error_from_fulfill_cx(fulfill_cx, infcx, placeholder_region, error_region)\n     }\n }\n \n@@ -407,7 +375,7 @@ impl<'tcx> TypeOpInfo<'tcx> for crate::type_check::InstantiateOpaqueType<'tcx> {\n #[instrument(skip(fulfill_cx, infcx), level = \"debug\")]\n fn try_extract_error_from_fulfill_cx<'tcx>(\n     mut fulfill_cx: Box<dyn TraitEngine<'tcx> + 'tcx>,\n-    infcx: &InferCtxt<'_, 'tcx>,\n+    infcx: &InferCtxt<'tcx>,\n     placeholder_region: ty::Region<'tcx>,\n     error_region: Option<ty::Region<'tcx>>,\n ) -> Option<DiagnosticBuilder<'tcx, ErrorGuaranteed>> {\n@@ -427,7 +395,7 @@ fn try_extract_error_from_fulfill_cx<'tcx>(\n }\n \n fn try_extract_error_from_region_constraints<'tcx>(\n-    infcx: &InferCtxt<'_, 'tcx>,\n+    infcx: &InferCtxt<'tcx>,\n     placeholder_region: ty::Region<'tcx>,\n     error_region: Option<ty::Region<'tcx>>,\n     region_constraints: &RegionConstraintData<'tcx>,\n@@ -449,42 +417,38 @@ fn try_extract_error_from_region_constraints<'tcx>(\n         })?;\n \n     debug!(?sub_region, \"cause = {:#?}\", cause);\n-    let nice_error = match (error_region, *sub_region) {\n-        (Some(error_region), ty::ReVar(vid)) => NiceRegionError::new(\n-            infcx,\n-            RegionResolutionError::SubSupConflict(\n-                vid,\n-                region_var_origin(vid),\n-                cause.clone(),\n-                error_region,\n-                cause.clone(),\n-                placeholder_region,\n-                vec![],\n-            ),\n-        ),\n-        (Some(error_region), _) => NiceRegionError::new(\n-            infcx,\n-            RegionResolutionError::ConcreteFailure(cause.clone(), error_region, placeholder_region),\n+    let error = match (error_region, *sub_region) {\n+        (Some(error_region), ty::ReVar(vid)) => RegionResolutionError::SubSupConflict(\n+            vid,\n+            region_var_origin(vid),\n+            cause.clone(),\n+            error_region,\n+            cause.clone(),\n+            placeholder_region,\n+            vec![],\n         ),\n+        (Some(error_region), _) => {\n+            RegionResolutionError::ConcreteFailure(cause.clone(), error_region, placeholder_region)\n+        }\n         // Note universe here is wrong...\n-        (None, ty::ReVar(vid)) => NiceRegionError::new(\n-            infcx,\n-            RegionResolutionError::UpperBoundUniverseConflict(\n-                vid,\n-                region_var_origin(vid),\n-                universe_of_region(vid),\n-                cause.clone(),\n-                placeholder_region,\n-            ),\n-        ),\n-        (None, _) => NiceRegionError::new(\n-            infcx,\n-            RegionResolutionError::ConcreteFailure(cause.clone(), sub_region, placeholder_region),\n+        (None, ty::ReVar(vid)) => RegionResolutionError::UpperBoundUniverseConflict(\n+            vid,\n+            region_var_origin(vid),\n+            universe_of_region(vid),\n+            cause.clone(),\n+            placeholder_region,\n         ),\n+        (None, _) => {\n+            RegionResolutionError::ConcreteFailure(cause.clone(), sub_region, placeholder_region)\n+        }\n     };\n-    nice_error.try_report_from_nll().or_else(|| {\n+    NiceRegionError::new(&infcx.err_ctxt(), error).try_report_from_nll().or_else(|| {\n         if let SubregionOrigin::Subtype(trace) = cause {\n-            Some(infcx.report_and_explain_type_error(*trace, TypeError::RegionsPlaceholderMismatch))\n+            Some(\n+                infcx\n+                    .err_ctxt()\n+                    .report_and_explain_type_error(*trace, TypeError::RegionsPlaceholderMismatch),\n+            )\n         } else {\n             None\n         }"}, {"sha": "3f5d9fb62066dad36c2319a4e1d322dceb7a3d1e", "filename": "compiler/rustc_borrowck/src/diagnostics/conflict_errors.rs", "status": "modified", "additions": 113, "deletions": 39, "changes": 152, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "patch": "@@ -198,7 +198,6 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                     move_span,\n                     move_spans,\n                     *moved_place,\n-                    Some(used_place),\n                     partially_str,\n                     loop_message,\n                     move_msg,\n@@ -369,6 +368,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         let mut visitor = ConditionVisitor { spans: &spans, name: &name, errors: vec![] };\n         visitor.visit_body(&body);\n \n+        let mut show_assign_sugg = false;\n         let isnt_initialized = if let InitializationRequiringAction::PartialAssignment\n         | InitializationRequiringAction::Assignment = desired_action\n         {\n@@ -396,6 +396,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             .count()\n             == 0\n         {\n+            show_assign_sugg = true;\n             \"isn't initialized\"\n         } else {\n             \"is possibly-uninitialized\"\n@@ -446,10 +447,84 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 }\n             }\n         }\n+\n         err.span_label(decl_span, \"binding declared here but left uninitialized\");\n+        if show_assign_sugg {\n+            struct LetVisitor {\n+                decl_span: Span,\n+                sugg_span: Option<Span>,\n+            }\n+\n+            impl<'v> Visitor<'v> for LetVisitor {\n+                fn visit_stmt(&mut self, ex: &'v hir::Stmt<'v>) {\n+                    if self.sugg_span.is_some() {\n+                        return;\n+                    }\n+                    if let hir::StmtKind::Local(hir::Local {\n+                            span, ty, init: None, ..\n+                        }) = &ex.kind && span.contains(self.decl_span) {\n+                            self.sugg_span = ty.map_or(Some(self.decl_span), |ty| Some(ty.span));\n+                    }\n+                    hir::intravisit::walk_stmt(self, ex);\n+                }\n+            }\n+\n+            let mut visitor = LetVisitor { decl_span, sugg_span: None };\n+            visitor.visit_body(&body);\n+            if let Some(span) = visitor.sugg_span {\n+                self.suggest_assign_value(&mut err, moved_place, span);\n+            }\n+        }\n         err\n     }\n \n+    fn suggest_assign_value(\n+        &self,\n+        err: &mut Diagnostic,\n+        moved_place: PlaceRef<'tcx>,\n+        sugg_span: Span,\n+    ) {\n+        let ty = moved_place.ty(self.body, self.infcx.tcx).ty;\n+        debug!(\"ty: {:?}, kind: {:?}\", ty, ty.kind());\n+\n+        let tcx = self.infcx.tcx;\n+        let implements_default = |ty, param_env| {\n+            let Some(default_trait) = tcx.get_diagnostic_item(sym::Default) else {\n+                return false;\n+            };\n+            // Regions are already solved, so we must use a fresh InferCtxt,\n+            // but the type has region variables, so erase those.\n+            tcx.infer_ctxt()\n+                .build()\n+                .type_implements_trait(\n+                    default_trait,\n+                    tcx.erase_regions(ty),\n+                    ty::List::empty(),\n+                    param_env,\n+                )\n+                .must_apply_modulo_regions()\n+        };\n+\n+        let assign_value = match ty.kind() {\n+            ty::Bool => \"false\",\n+            ty::Float(_) => \"0.0\",\n+            ty::Int(_) | ty::Uint(_) => \"0\",\n+            ty::Never | ty::Error(_) => \"\",\n+            ty::Adt(def, _) if Some(def.did()) == tcx.get_diagnostic_item(sym::Vec) => \"vec![]\",\n+            ty::Adt(_, _) if implements_default(ty, self.param_env) => \"Default::default()\",\n+            _ => \"todo!()\",\n+        };\n+\n+        if !assign_value.is_empty() {\n+            err.span_suggestion_verbose(\n+                sugg_span.shrink_to_hi(),\n+                format!(\"consider assigning a value\"),\n+                format!(\" = {}\", assign_value),\n+                Applicability::MaybeIncorrect,\n+            );\n+        }\n+    }\n+\n     fn suggest_borrow_fn_like(\n         &self,\n         err: &mut Diagnostic,\n@@ -537,41 +612,40 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             .and_then(|def_id| tcx.hir().get_generics(def_id))\n         else { return; };\n         // Try to find predicates on *generic params* that would allow copying `ty`\n-        let predicates: Result<Vec<_>, _> = tcx.infer_ctxt().enter(|infcx| {\n-            let mut fulfill_cx = <dyn rustc_infer::traits::TraitEngine<'_>>::new(infcx.tcx);\n+        let infcx = tcx.infer_ctxt().build();\n+        let mut fulfill_cx = <dyn rustc_infer::traits::TraitEngine<'_>>::new(infcx.tcx);\n \n-            let copy_did = infcx.tcx.lang_items().copy_trait().unwrap();\n-            let cause = ObligationCause::new(\n-                span,\n-                self.mir_hir_id(),\n-                rustc_infer::traits::ObligationCauseCode::MiscObligation,\n-            );\n-            fulfill_cx.register_bound(\n-                &infcx,\n-                self.param_env,\n-                // Erase any region vids from the type, which may not be resolved\n-                infcx.tcx.erase_regions(ty),\n-                copy_did,\n-                cause,\n-            );\n-            // Select all, including ambiguous predicates\n-            let errors = fulfill_cx.select_all_or_error(&infcx);\n-\n-            // Only emit suggestion if all required predicates are on generic\n-            errors\n-                .into_iter()\n-                .map(|err| match err.obligation.predicate.kind().skip_binder() {\n-                    PredicateKind::Trait(predicate) => match predicate.self_ty().kind() {\n-                        ty::Param(param_ty) => Ok((\n-                            generics.type_param(param_ty, tcx),\n-                            predicate.trait_ref.print_only_trait_path().to_string(),\n-                        )),\n-                        _ => Err(()),\n-                    },\n+        let copy_did = infcx.tcx.lang_items().copy_trait().unwrap();\n+        let cause = ObligationCause::new(\n+            span,\n+            self.mir_hir_id(),\n+            rustc_infer::traits::ObligationCauseCode::MiscObligation,\n+        );\n+        fulfill_cx.register_bound(\n+            &infcx,\n+            self.param_env,\n+            // Erase any region vids from the type, which may not be resolved\n+            infcx.tcx.erase_regions(ty),\n+            copy_did,\n+            cause,\n+        );\n+        // Select all, including ambiguous predicates\n+        let errors = fulfill_cx.select_all_or_error(&infcx);\n+\n+        // Only emit suggestion if all required predicates are on generic\n+        let predicates: Result<Vec<_>, _> = errors\n+            .into_iter()\n+            .map(|err| match err.obligation.predicate.kind().skip_binder() {\n+                PredicateKind::Trait(predicate) => match predicate.self_ty().kind() {\n+                    ty::Param(param_ty) => Ok((\n+                        generics.type_param(param_ty, tcx),\n+                        predicate.trait_ref.print_only_trait_path().to_string(),\n+                    )),\n                     _ => Err(()),\n-                })\n-                .collect()\n-        });\n+                },\n+                _ => Err(()),\n+            })\n+            .collect();\n \n         if let Ok(predicates) = predicates {\n             suggest_constraining_type_params(\n@@ -909,7 +983,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         err: &mut Diagnostic,\n         location: Location,\n         issued_borrow: &BorrowData<'tcx>,\n-        explanation: BorrowExplanation<'tcx>,\n+        explanation: BorrowExplanation,\n     ) {\n         let used_in_call = matches!(\n             explanation,\n@@ -1259,7 +1333,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         borrow: &BorrowData<'tcx>,\n         drop_span: Span,\n         borrow_spans: UseSpans<'tcx>,\n-        explanation: BorrowExplanation<'tcx>,\n+        explanation: BorrowExplanation,\n     ) -> DiagnosticBuilder<'cx, ErrorGuaranteed> {\n         debug!(\n             \"report_local_value_does_not_live_long_enough(\\\n@@ -1465,7 +1539,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         drop_span: Span,\n         borrow_spans: UseSpans<'tcx>,\n         proper_span: Span,\n-        explanation: BorrowExplanation<'tcx>,\n+        explanation: BorrowExplanation,\n     ) -> DiagnosticBuilder<'cx, ErrorGuaranteed> {\n         if let BorrowExplanation::MustBeValidFor { category, span, from_closure: false, .. } =\n             explanation\n@@ -1579,7 +1653,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         borrow: &BorrowData<'tcx>,\n         borrow_span: Span,\n         return_span: Span,\n-        category: ConstraintCategory<'tcx>,\n+        category: ConstraintCategory,\n         opt_place_desc: Option<&String>,\n     ) -> Option<DiagnosticBuilder<'cx, ErrorGuaranteed>> {\n         let return_kind = match category {\n@@ -1674,7 +1748,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         use_span: UseSpans<'tcx>,\n         var_span: Span,\n         fr_name: &RegionName,\n-        category: ConstraintCategory<'tcx>,\n+        category: ConstraintCategory,\n         constraint_span: Span,\n         captured_var: &str,\n     ) -> DiagnosticBuilder<'cx, ErrorGuaranteed> {"}, {"sha": "545237bb3920595401093d54860ffca06b46164c", "filename": "compiler/rustc_borrowck/src/diagnostics/explain_borrow.rs", "status": "modified", "additions": 29, "deletions": 139, "changes": 168, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fexplain_borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fexplain_borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fexplain_borrow.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "patch": "@@ -1,8 +1,5 @@\n //! Print diagnostics to explain why values are borrowed.\n \n-use std::collections::VecDeque;\n-\n-use rustc_data_structures::fx::FxHashSet;\n use rustc_errors::{Applicability, Diagnostic};\n use rustc_index::vec::IndexVec;\n use rustc_infer::infer::NllRegionVariableOrigin;\n@@ -24,7 +21,7 @@ use crate::{\n use super::{find_use, RegionName, UseSpans};\n \n #[derive(Debug)]\n-pub(crate) enum BorrowExplanation<'tcx> {\n+pub(crate) enum BorrowExplanation {\n     UsedLater(LaterUseKind, Span, Option<Span>),\n     UsedLaterInLoop(LaterUseKind, Span, Option<Span>),\n     UsedLaterWhenDropped {\n@@ -33,7 +30,7 @@ pub(crate) enum BorrowExplanation<'tcx> {\n         should_note_order: bool,\n     },\n     MustBeValidFor {\n-        category: ConstraintCategory<'tcx>,\n+        category: ConstraintCategory,\n         from_closure: bool,\n         span: Span,\n         region_name: RegionName,\n@@ -52,7 +49,7 @@ pub(crate) enum LaterUseKind {\n     Other,\n }\n \n-impl<'tcx> BorrowExplanation<'tcx> {\n+impl<'tcx> BorrowExplanation {\n     pub(crate) fn is_explained(&self) -> bool {\n         !matches!(self, BorrowExplanation::Unexplained)\n     }\n@@ -287,7 +284,7 @@ impl<'tcx> BorrowExplanation<'tcx> {\n     fn add_lifetime_bound_suggestion_to_diagnostic(\n         &self,\n         err: &mut Diagnostic,\n-        category: &ConstraintCategory<'tcx>,\n+        category: &ConstraintCategory,\n         span: Span,\n         region_name: &RegionName,\n     ) {\n@@ -319,7 +316,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         &self,\n         borrow_region: RegionVid,\n         outlived_region: RegionVid,\n-    ) -> (ConstraintCategory<'tcx>, bool, Span, Option<RegionName>, Vec<ExtraConstraintInfo>) {\n+    ) -> (ConstraintCategory, bool, Span, Option<RegionName>, Vec<ExtraConstraintInfo>) {\n         let (blame_constraint, extra_info) = self.regioncx.best_blame_constraint(\n             borrow_region,\n             NllRegionVariableOrigin::FreeRegion,\n@@ -351,27 +348,45 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         location: Location,\n         borrow: &BorrowData<'tcx>,\n         kind_place: Option<(WriteKind, Place<'tcx>)>,\n-    ) -> BorrowExplanation<'tcx> {\n+    ) -> BorrowExplanation {\n         let regioncx = &self.regioncx;\n         let body: &Body<'_> = &self.body;\n         let tcx = self.infcx.tcx;\n \n         let borrow_region_vid = borrow.region;\n         debug!(?borrow_region_vid);\n \n-        let region_sub = self.regioncx.find_sub_region_live_at(borrow_region_vid, location);\n+        let mut region_sub = self.regioncx.find_sub_region_live_at(borrow_region_vid, location);\n         debug!(?region_sub);\n \n-        match find_use::find(body, regioncx, tcx, region_sub, location) {\n+        let mut use_location = location;\n+        let mut use_in_later_iteration_of_loop = false;\n+\n+        if region_sub == borrow_region_vid {\n+            // When `region_sub` is the same as `borrow_region_vid` (the location where the borrow is\n+            // issued is the same location that invalidates the reference), this is likely a loop iteration\n+            // - in this case, try using the loop terminator location in `find_sub_region_live_at`.\n+            if let Some(loop_terminator_location) =\n+                regioncx.find_loop_terminator_location(borrow.region, body)\n+            {\n+                region_sub = self\n+                    .regioncx\n+                    .find_sub_region_live_at(borrow_region_vid, loop_terminator_location);\n+                debug!(\"explain_why_borrow_contains_point: region_sub in loop={:?}\", region_sub);\n+                use_location = loop_terminator_location;\n+                use_in_later_iteration_of_loop = true;\n+            }\n+        }\n+\n+        match find_use::find(body, regioncx, tcx, region_sub, use_location) {\n             Some(Cause::LiveVar(local, location)) => {\n                 let span = body.source_info(location).span;\n                 let spans = self\n                     .move_spans(Place::from(local).as_ref(), location)\n                     .or_else(|| self.borrow_spans(span, location));\n \n-                let borrow_location = location;\n-                if self.is_use_in_later_iteration_of_loop(borrow_location, location) {\n-                    let later_use = self.later_use_kind(borrow, spans, location);\n+                if use_in_later_iteration_of_loop {\n+                    let later_use = self.later_use_kind(borrow, spans, use_location);\n                     BorrowExplanation::UsedLaterInLoop(later_use.0, later_use.1, later_use.2)\n                 } else {\n                     // Check if the location represents a `FakeRead`, and adapt the error\n@@ -425,131 +440,6 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         }\n     }\n \n-    /// true if `borrow_location` can reach `use_location` by going through a loop and\n-    /// `use_location` is also inside of that loop\n-    fn is_use_in_later_iteration_of_loop(\n-        &self,\n-        borrow_location: Location,\n-        use_location: Location,\n-    ) -> bool {\n-        let back_edge = self.reach_through_backedge(borrow_location, use_location);\n-        back_edge.map_or(false, |back_edge| self.can_reach_head_of_loop(use_location, back_edge))\n-    }\n-\n-    /// Returns the outmost back edge if `from` location can reach `to` location passing through\n-    /// that back edge\n-    fn reach_through_backedge(&self, from: Location, to: Location) -> Option<Location> {\n-        let mut visited_locations = FxHashSet::default();\n-        let mut pending_locations = VecDeque::new();\n-        visited_locations.insert(from);\n-        pending_locations.push_back(from);\n-        debug!(\"reach_through_backedge: from={:?} to={:?}\", from, to,);\n-\n-        let mut outmost_back_edge = None;\n-        while let Some(location) = pending_locations.pop_front() {\n-            debug!(\n-                \"reach_through_backedge: location={:?} outmost_back_edge={:?}\n-                   pending_locations={:?} visited_locations={:?}\",\n-                location, outmost_back_edge, pending_locations, visited_locations\n-            );\n-\n-            if location == to && outmost_back_edge.is_some() {\n-                // We've managed to reach the use location\n-                debug!(\"reach_through_backedge: found!\");\n-                return outmost_back_edge;\n-            }\n-\n-            let block = &self.body.basic_blocks[location.block];\n-\n-            if location.statement_index < block.statements.len() {\n-                let successor = location.successor_within_block();\n-                if visited_locations.insert(successor) {\n-                    pending_locations.push_back(successor);\n-                }\n-            } else {\n-                pending_locations.extend(\n-                    block\n-                        .terminator()\n-                        .successors()\n-                        .map(|bb| Location { statement_index: 0, block: bb })\n-                        .filter(|s| visited_locations.insert(*s))\n-                        .map(|s| {\n-                            if self.is_back_edge(location, s) {\n-                                match outmost_back_edge {\n-                                    None => {\n-                                        outmost_back_edge = Some(location);\n-                                    }\n-\n-                                    Some(back_edge)\n-                                        if location.dominates(back_edge, &self.dominators) =>\n-                                    {\n-                                        outmost_back_edge = Some(location);\n-                                    }\n-\n-                                    Some(_) => {}\n-                                }\n-                            }\n-\n-                            s\n-                        }),\n-                );\n-            }\n-        }\n-\n-        None\n-    }\n-\n-    /// true if `from` location can reach `loop_head` location and `loop_head` dominates all the\n-    /// intermediate nodes\n-    fn can_reach_head_of_loop(&self, from: Location, loop_head: Location) -> bool {\n-        self.find_loop_head_dfs(from, loop_head, &mut FxHashSet::default())\n-    }\n-\n-    fn find_loop_head_dfs(\n-        &self,\n-        from: Location,\n-        loop_head: Location,\n-        visited_locations: &mut FxHashSet<Location>,\n-    ) -> bool {\n-        visited_locations.insert(from);\n-\n-        if from == loop_head {\n-            return true;\n-        }\n-\n-        if loop_head.dominates(from, &self.dominators) {\n-            let block = &self.body.basic_blocks[from.block];\n-\n-            if from.statement_index < block.statements.len() {\n-                let successor = from.successor_within_block();\n-\n-                if !visited_locations.contains(&successor)\n-                    && self.find_loop_head_dfs(successor, loop_head, visited_locations)\n-                {\n-                    return true;\n-                }\n-            } else {\n-                for bb in block.terminator().successors() {\n-                    let successor = Location { statement_index: 0, block: bb };\n-\n-                    if !visited_locations.contains(&successor)\n-                        && self.find_loop_head_dfs(successor, loop_head, visited_locations)\n-                    {\n-                        return true;\n-                    }\n-                }\n-            }\n-        }\n-\n-        false\n-    }\n-\n-    /// True if an edge `source -> target` is a backedge -- in other words, if the target\n-    /// dominates the source.\n-    fn is_back_edge(&self, source: Location, target: Location) -> bool {\n-        target.dominates(source, &self.dominators)\n-    }\n-\n     /// Determine how the borrow was later used.\n     /// First span returned points to the location of the conflicting use\n     /// Second span if `Some` is returned in the case of closures and points"}, {"sha": "534d9ecae6e6f0788d336bc7ac8b03110cc02482", "filename": "compiler/rustc_borrowck/src/diagnostics/mod.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmod.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "patch": "@@ -972,7 +972,6 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         move_span: Span,\n         move_spans: UseSpans<'tcx>,\n         moved_place: Place<'tcx>,\n-        used_place: Option<PlaceRef<'tcx>>,\n         partially_str: &str,\n         loop_message: &str,\n         move_msg: &str,\n@@ -1026,7 +1025,8 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                     if let Some((CallDesugaringKind::ForLoopIntoIter, _)) = desugaring {\n                         let ty = moved_place.ty(self.body, self.infcx.tcx).ty;\n                         let suggest = match self.infcx.tcx.get_diagnostic_item(sym::IntoIterator) {\n-                            Some(def_id) => self.infcx.tcx.infer_ctxt().enter(|infcx| {\n+                            Some(def_id) => {\n+                                let infcx = self.infcx.tcx.infer_ctxt().build();\n                                 type_known_to_meet_bound_modulo_regions(\n                                     &infcx,\n                                     self.param_env,\n@@ -1037,7 +1037,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                                     def_id,\n                                     DUMMY_SP,\n                                 )\n-                            }),\n+                            }\n                             _ => false,\n                         };\n                         if suggest {\n@@ -1060,9 +1060,11 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                                 place_name, partially_str, loop_message\n                             ),\n                         );\n-                        // If we have a `&mut` ref, we need to reborrow.\n-                        if let Some(ty::Ref(_, _, hir::Mutability::Mut)) = used_place\n-                            .map(|used_place| used_place.ty(self.body, self.infcx.tcx).ty.kind())\n+                        // If the moved place was a `&mut` ref, then we can\n+                        // suggest to reborrow it where it was moved, so it\n+                        // will still be valid by the time we get to the usage.\n+                        if let ty::Ref(_, _, hir::Mutability::Mut) =\n+                            moved_place.ty(self.body, self.infcx.tcx).ty.kind()\n                         {\n                             // If we are in a loop this will be suggested later.\n                             if !is_loop_move {"}, {"sha": "5a47f45677ecbfd1b546f4f74f5ec83e833687cf", "filename": "compiler/rustc_borrowck/src/diagnostics/move_errors.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmove_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmove_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmove_errors.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "patch": "@@ -401,7 +401,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n         };\n         if let Some(use_spans) = use_spans {\n             self.explain_captures(\n-                &mut err, span, span, use_spans, move_place, None, \"\", \"\", \"\", false, true,\n+                &mut err, span, span, use_spans, move_place, \"\", \"\", \"\", false, true,\n             );\n         }\n         err"}, {"sha": "8ad40c0aa0a5d032f3e2f5b9af56a6ee3cacc189", "filename": "compiler/rustc_borrowck/src/diagnostics/mutability_errors.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmutability_errors.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "patch": "@@ -932,7 +932,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                 let opt_suggestions = self\n                     .infcx\n                     .tcx\n-                    .typeck(path_segment.hir_id.owner)\n+                    .typeck(path_segment.hir_id.owner.def_id)\n                     .type_dependent_def_id(*hir_id)\n                     .and_then(|def_id| self.infcx.tcx.impl_of_method(def_id))\n                     .map(|def_id| self.infcx.tcx.associated_items(def_id))\n@@ -1032,7 +1032,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n         if look_at_return && hir.get_return_block(closure_id).is_some() {\n             // ...otherwise we are probably in the tail expression of the function, point at the\n             // return type.\n-            match hir.get_by_def_id(hir.get_parent_item(fn_call_id)) {\n+            match hir.get_by_def_id(hir.get_parent_item(fn_call_id).def_id) {\n                 hir::Node::Item(hir::Item { ident, kind: hir::ItemKind::Fn(sig, ..), .. })\n                 | hir::Node::TraitItem(hir::TraitItem {\n                     ident,"}, {"sha": "245ea07d120bc6c710dc7103fbfceedbeeaf3fb4", "filename": "compiler/rustc_borrowck/src/diagnostics/outlives_suggestion.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Foutlives_suggestion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Foutlives_suggestion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Foutlives_suggestion.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "patch": "@@ -161,7 +161,7 @@ impl OutlivesSuggestionBuilder {\n     pub(crate) fn intermediate_suggestion(\n         &mut self,\n         mbcx: &MirBorrowckCtxt<'_, '_>,\n-        errci: &ErrorConstraintInfo<'_>,\n+        errci: &ErrorConstraintInfo,\n         diag: &mut Diagnostic,\n     ) {\n         // Emit an intermediate note."}, {"sha": "b619537f31769b578fa98f8a35e13c20ad974fe9", "filename": "compiler/rustc_borrowck/src/diagnostics/region_errors.rs", "status": "modified", "additions": 22, "deletions": 14, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_errors.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "patch": "@@ -2,6 +2,7 @@\n #![deny(rustc::diagnostic_outside_of_impl)]\n //! Error reporting machinery for lifetime errors.\n \n+use either::Either;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_errors::{Applicability, Diagnostic, DiagnosticBuilder, ErrorGuaranteed, MultiSpan};\n use rustc_hir::def_id::DefId;\n@@ -16,7 +17,7 @@ use rustc_infer::infer::{\n     NllRegionVariableOrigin, RelateParamBound,\n };\n use rustc_middle::hir::place::PlaceBase;\n-use rustc_middle::mir::{ConstraintCategory, ReturnConstraint};\n+use rustc_middle::mir::{ConstraintCategory, ReturnConstraint, TerminatorKind};\n use rustc_middle::ty::subst::InternalSubsts;\n use rustc_middle::ty::Region;\n use rustc_middle::ty::TypeVisitor;\n@@ -39,7 +40,7 @@ use crate::{\n     MirBorrowckCtxt,\n };\n \n-impl<'tcx> ConstraintDescription for ConstraintCategory<'tcx> {\n+impl ConstraintDescription for ConstraintCategory {\n     fn description(&self) -> &'static str {\n         // Must end with a space. Allows for empty names to be provided.\n         match self {\n@@ -115,15 +116,15 @@ pub(crate) enum RegionErrorKind<'tcx> {\n \n /// Information about the various region constraints involved in a borrow checker error.\n #[derive(Clone, Debug)]\n-pub struct ErrorConstraintInfo<'tcx> {\n+pub struct ErrorConstraintInfo {\n     // fr: outlived_fr\n     pub(super) fr: RegionVid,\n     pub(super) fr_is_local: bool,\n     pub(super) outlived_fr: RegionVid,\n     pub(super) outlived_fr_is_local: bool,\n \n     // Category and span for best blame constraint\n-    pub(super) category: ConstraintCategory<'tcx>,\n+    pub(super) category: ConstraintCategory,\n     pub(super) span: Span,\n }\n \n@@ -186,7 +187,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                     if let Some(lower_bound_region) = lower_bound_region {\n                         let generic_ty = type_test.generic_kind.to_ty(self.infcx.tcx);\n                         let origin = RelateParamBound(type_test_span, generic_ty, None);\n-                        self.buffer_error(self.infcx.construct_generic_bound_failure(\n+                        self.buffer_error(self.infcx.err_ctxt().construct_generic_bound_failure(\n                             self.body.source.def_id().expect_local(),\n                             type_test_span,\n                             Some(origin),\n@@ -281,7 +282,8 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n         let tcx = self.infcx.tcx;\n         match tcx.hir().get_if_local(def_id) {\n             Some(Node::ImplItem(impl_item)) => {\n-                match tcx.hir().find_by_def_id(tcx.hir().get_parent_item(impl_item.hir_id())) {\n+                match tcx.hir().find_by_def_id(tcx.hir().get_parent_item(impl_item.hir_id()).def_id)\n+                {\n                     Some(Node::Item(Item {\n                         kind: ItemKind::Impl(hir::Impl { self_ty, .. }),\n                         ..\n@@ -291,7 +293,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n             }\n             Some(Node::TraitItem(trait_item)) => {\n                 let trait_did = tcx.hir().get_parent_item(trait_item.hir_id());\n-                match tcx.hir().find_by_def_id(trait_did) {\n+                match tcx.hir().find_by_def_id(trait_did.def_id) {\n                     Some(Node::Item(Item { kind: ItemKind::Trait(..), .. })) => {\n                         // The method being called is defined in the `trait`, but the `'static`\n                         // obligation comes from the `impl`. Find that `impl` so that we can point\n@@ -340,7 +342,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n     /// Report an error because the universal region `fr` was required to outlive\n     /// `outlived_fr` but it is not known to do so. For example:\n     ///\n-    /// ```compile_fail,E0312\n+    /// ```compile_fail\n     /// fn foo<'a, 'b>(x: &'a u32) -> &'b u32 { x }\n     /// ```\n     ///\n@@ -364,7 +366,8 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n \n         // Check if we can use one of the \"nice region errors\".\n         if let (Some(f), Some(o)) = (self.to_error_region(fr), self.to_error_region(outlived_fr)) {\n-            let nice = NiceRegionError::new_from_span(self.infcx, cause.span, o, f);\n+            let infer_err = self.infcx.err_ctxt();\n+            let nice = NiceRegionError::new_from_span(&infer_err, cause.span, o, f);\n             if let Some(diag) = nice.try_report_from_nll() {\n                 self.buffer_error(diag);\n                 return;\n@@ -496,7 +499,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n     /// ```\n     fn report_fnmut_error(\n         &self,\n-        errci: &ErrorConstraintInfo<'tcx>,\n+        errci: &ErrorConstraintInfo,\n         kind: ReturnConstraint,\n     ) -> DiagnosticBuilder<'tcx, ErrorGuaranteed> {\n         let ErrorConstraintInfo { outlived_fr, span, .. } = errci;\n@@ -569,7 +572,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n     #[instrument(level = \"debug\", skip(self))]\n     fn report_escaping_data_error(\n         &self,\n-        errci: &ErrorConstraintInfo<'tcx>,\n+        errci: &ErrorConstraintInfo,\n     ) -> DiagnosticBuilder<'tcx, ErrorGuaranteed> {\n         let ErrorConstraintInfo { span, category, .. } = errci;\n \n@@ -673,7 +676,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n     /// ```\n     fn report_general_error(\n         &self,\n-        errci: &ErrorConstraintInfo<'tcx>,\n+        errci: &ErrorConstraintInfo,\n     ) -> DiagnosticBuilder<'tcx, ErrorGuaranteed> {\n         let ErrorConstraintInfo {\n             fr,\n@@ -786,15 +789,20 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n         diag: &mut Diagnostic,\n         f: Region<'tcx>,\n         o: Region<'tcx>,\n-        category: &ConstraintCategory<'tcx>,\n+        category: &ConstraintCategory,\n     ) {\n         if !o.is_static() {\n             return;\n         }\n \n         let tcx = self.infcx.tcx;\n \n-        let instance = if let ConstraintCategory::CallArgument(Some(func_ty)) = category {\n+        let instance =\n+            if let ConstraintCategory::CallArgument(location) = category\n+                && let Either::Right(term) = self.body.stmt_at(*location)\n+                && let TerminatorKind::Call { func, .. } = &term.kind\n+        {\n+            let func_ty = func.ty(self.body, tcx);\n             let (fn_did, substs) = match func_ty.kind() {\n                 ty::FnDef(fn_did, substs) => (fn_did, substs),\n                 _ => return,"}, {"sha": "4d251cf7ac752ddbe89cfbbc6ee34e1e4d39b842", "filename": "compiler/rustc_borrowck/src/diagnostics/region_name.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_name.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "patch": "@@ -707,7 +707,8 @@ impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n                         hir::AsyncGeneratorKind::Block => \" of async block\",\n                         hir::AsyncGeneratorKind::Closure => \" of async closure\",\n                         hir::AsyncGeneratorKind::Fn => {\n-                            let parent_item = hir.get_by_def_id(hir.get_parent_item(mir_hir_id));\n+                            let parent_item =\n+                                hir.get_by_def_id(hir.get_parent_item(mir_hir_id).def_id);\n                             let output = &parent_item\n                                 .fn_decl()\n                                 .expect(\"generator lowered from async fn should be in fn\")\n@@ -863,15 +864,13 @@ impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n         };\n \n         let tcx = self.infcx.tcx;\n-        let body_parent_did = tcx.opt_parent(self.mir_def_id().to_def_id())?;\n-        if tcx.parent(region.def_id) != body_parent_did\n-            || tcx.def_kind(body_parent_did) != DefKind::Impl\n-        {\n+        let region_parent = tcx.parent(region.def_id);\n+        if tcx.def_kind(region_parent) != DefKind::Impl {\n             return None;\n         }\n \n         let mut found = false;\n-        tcx.fold_regions(tcx.type_of(body_parent_did), |r: ty::Region<'tcx>, _| {\n+        tcx.fold_regions(tcx.type_of(region_parent), |r: ty::Region<'tcx>, _| {\n             if *r == ty::ReEarlyBound(region) {\n                 found = true;\n             }"}, {"sha": "abfe253d43df7edbf41cfdbba0e7c3bd474a56ae", "filename": "compiler/rustc_borrowck/src/lib.rs", "status": "modified", "additions": 8, "deletions": 12, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "patch": "@@ -3,7 +3,6 @@\n #![allow(rustc::potential_query_instability)]\n #![feature(box_patterns)]\n #![feature(let_chains)]\n-#![cfg_attr(bootstrap, feature(let_else))]\n #![feature(min_specialization)]\n #![feature(never_type)]\n #![feature(rustc_attrs)]\n@@ -132,14 +131,11 @@ fn mir_borrowck<'tcx>(\n     debug!(\"run query mir_borrowck: {}\", tcx.def_path_str(def.did.to_def_id()));\n     let hir_owner = tcx.hir().local_def_id_to_hir_id(def.did).owner;\n \n-    let opt_closure_req = tcx\n-        .infer_ctxt()\n-        .with_opaque_type_inference(DefiningAnchor::Bind(hir_owner))\n-        .enter(|infcx| {\n-            let input_body: &Body<'_> = &input_body.borrow();\n-            let promoted: &IndexVec<_, _> = &promoted.borrow();\n-            do_mir_borrowck(&infcx, input_body, promoted, false).0\n-        });\n+    let infcx =\n+        tcx.infer_ctxt().with_opaque_type_inference(DefiningAnchor::Bind(hir_owner.def_id)).build();\n+    let input_body: &Body<'_> = &input_body.borrow();\n+    let promoted: &IndexVec<_, _> = &promoted.borrow();\n+    let opt_closure_req = do_mir_borrowck(&infcx, input_body, promoted, false).0;\n     debug!(\"mir_borrowck done\");\n \n     tcx.arena.alloc(opt_closure_req)\n@@ -151,8 +147,8 @@ fn mir_borrowck<'tcx>(\n /// region ids on which the borrow checking was performed together with Polonius\n /// facts.\n #[instrument(skip(infcx, input_body, input_promoted), fields(id=?input_body.source.with_opt_param().as_local().unwrap()), level = \"debug\")]\n-fn do_mir_borrowck<'a, 'tcx>(\n-    infcx: &InferCtxt<'a, 'tcx>,\n+fn do_mir_borrowck<'tcx>(\n+    infcx: &InferCtxt<'tcx>,\n     input_body: &Body<'tcx>,\n     input_promoted: &IndexVec<Promoted, Body<'tcx>>,\n     return_body_with_facts: bool,\n@@ -475,7 +471,7 @@ pub struct BodyWithBorrowckFacts<'tcx> {\n }\n \n struct MirBorrowckCtxt<'cx, 'tcx> {\n-    infcx: &'cx InferCtxt<'cx, 'tcx>,\n+    infcx: &'cx InferCtxt<'tcx>,\n     param_env: ParamEnv<'tcx>,\n     body: &'cx Body<'tcx>,\n     move_data: &'cx MoveData<'tcx>,"}, {"sha": "08fdd28eb01b7392e5a701d0e1ffc7e0b9221871", "filename": "compiler/rustc_borrowck/src/nll.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_borrowck%2Fsrc%2Fnll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_borrowck%2Fsrc%2Fnll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fnll.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "patch": "@@ -55,8 +55,8 @@ pub(crate) struct NllOutput<'tcx> {\n /// regions (e.g., region parameters) declared on the function. That set will need to be given to\n /// `compute_regions`.\n #[instrument(skip(infcx, param_env, body, promoted), level = \"debug\")]\n-pub(crate) fn replace_regions_in_mir<'cx, 'tcx>(\n-    infcx: &InferCtxt<'cx, 'tcx>,\n+pub(crate) fn replace_regions_in_mir<'tcx>(\n+    infcx: &InferCtxt<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n     body: &mut Body<'tcx>,\n     promoted: &mut IndexVec<Promoted, Body<'tcx>>,\n@@ -155,7 +155,7 @@ fn populate_polonius_move_facts(\n ///\n /// This may result in errors being reported.\n pub(crate) fn compute_regions<'cx, 'tcx>(\n-    infcx: &InferCtxt<'cx, 'tcx>,\n+    infcx: &InferCtxt<'tcx>,\n     universal_regions: UniversalRegions<'tcx>,\n     body: &Body<'tcx>,\n     promoted: &IndexVec<Promoted, Body<'tcx>>,\n@@ -318,8 +318,8 @@ pub(crate) fn compute_regions<'cx, 'tcx>(\n     }\n }\n \n-pub(super) fn dump_mir_results<'a, 'tcx>(\n-    infcx: &InferCtxt<'a, 'tcx>,\n+pub(super) fn dump_mir_results<'tcx>(\n+    infcx: &InferCtxt<'tcx>,\n     body: &Body<'tcx>,\n     regioncx: &RegionInferenceContext<'tcx>,\n     closure_region_requirements: &Option<ClosureRegionRequirements<'_>>,\n@@ -368,8 +368,8 @@ pub(super) fn dump_mir_results<'a, 'tcx>(\n     };\n }\n \n-pub(super) fn dump_annotation<'a, 'tcx>(\n-    infcx: &InferCtxt<'a, 'tcx>,\n+pub(super) fn dump_annotation<'tcx>(\n+    infcx: &InferCtxt<'tcx>,\n     body: &Body<'tcx>,\n     regioncx: &RegionInferenceContext<'tcx>,\n     closure_region_requirements: &Option<ClosureRegionRequirements<'_>>,"}, {"sha": "85b9bde2c81926a1ada3689149077a9b7d8c8d53", "filename": "compiler/rustc_borrowck/src/region_infer/mod.rs", "status": "modified", "additions": 36, "deletions": 15, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "patch": "@@ -15,7 +15,7 @@ use rustc_infer::infer::region_constraints::{GenericKind, VarInfos, VerifyBound,\n use rustc_infer::infer::{InferCtxt, NllRegionVariableOrigin, RegionVariableOrigin};\n use rustc_middle::mir::{\n     Body, ClosureOutlivesRequirement, ClosureOutlivesSubject, ClosureRegionRequirements,\n-    ConstraintCategory, Local, Location, ReturnConstraint,\n+    ConstraintCategory, Local, Location, ReturnConstraint, TerminatorKind,\n };\n use rustc_middle::traits::ObligationCause;\n use rustc_middle::traits::ObligationCauseCode;\n@@ -91,7 +91,7 @@ pub struct RegionInferenceContext<'tcx> {\n \n     /// Map closure bounds to a `Span` that should be used for error reporting.\n     closure_bounds_mapping:\n-        FxHashMap<Location, FxHashMap<(RegionVid, RegionVid), (ConstraintCategory<'tcx>, Span)>>,\n+        FxHashMap<Location, FxHashMap<(RegionVid, RegionVid), (ConstraintCategory, Span)>>,\n \n     /// Map universe indexes to information on why we created it.\n     universe_causes: FxHashMap<ty::UniverseIndex, UniverseInfo<'tcx>>,\n@@ -267,7 +267,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         member_constraints_in: MemberConstraintSet<'tcx, RegionVid>,\n         closure_bounds_mapping: FxHashMap<\n             Location,\n-            FxHashMap<(RegionVid, RegionVid), (ConstraintCategory<'tcx>, Span)>,\n+            FxHashMap<(RegionVid, RegionVid), (ConstraintCategory, Span)>,\n         >,\n         universe_causes: FxHashMap<ty::UniverseIndex, UniverseInfo<'tcx>>,\n         type_tests: Vec<TypeTest<'tcx>>,\n@@ -565,7 +565,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     #[instrument(skip(self, infcx, body, polonius_output), level = \"debug\")]\n     pub(super) fn solve(\n         &mut self,\n-        infcx: &InferCtxt<'_, 'tcx>,\n+        infcx: &InferCtxt<'tcx>,\n         param_env: ty::ParamEnv<'tcx>,\n         body: &Body<'tcx>,\n         polonius_output: Option<Rc<PoloniusOutput>>,\n@@ -835,7 +835,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// 'a`. See `TypeTest` for more details.\n     fn check_type_tests(\n         &self,\n-        infcx: &InferCtxt<'_, 'tcx>,\n+        infcx: &InferCtxt<'tcx>,\n         param_env: ty::ParamEnv<'tcx>,\n         body: &Body<'tcx>,\n         mut propagated_outlives_requirements: Option<&mut Vec<ClosureOutlivesRequirement<'tcx>>>,\n@@ -923,7 +923,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     #[instrument(level = \"debug\", skip(self, infcx, propagated_outlives_requirements))]\n     fn try_promote_type_test(\n         &self,\n-        infcx: &InferCtxt<'_, 'tcx>,\n+        infcx: &InferCtxt<'tcx>,\n         param_env: ty::ParamEnv<'tcx>,\n         body: &Body<'tcx>,\n         type_test: &TypeTest<'tcx>,\n@@ -1036,7 +1036,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     #[instrument(level = \"debug\", skip(self, infcx))]\n     fn try_promote_type_test_subject(\n         &self,\n-        infcx: &InferCtxt<'_, 'tcx>,\n+        infcx: &InferCtxt<'tcx>,\n         ty: Ty<'tcx>,\n     ) -> Option<ClosureOutlivesSubject<'tcx>> {\n         let tcx = infcx.tcx;\n@@ -1212,7 +1212,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// `point`.\n     fn eval_verify_bound(\n         &self,\n-        infcx: &InferCtxt<'_, 'tcx>,\n+        infcx: &InferCtxt<'tcx>,\n         param_env: ty::ParamEnv<'tcx>,\n         body: &Body<'tcx>,\n         generic_ty: Ty<'tcx>,\n@@ -1262,7 +1262,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n \n     fn eval_if_eq(\n         &self,\n-        infcx: &InferCtxt<'_, 'tcx>,\n+        infcx: &InferCtxt<'tcx>,\n         param_env: ty::ParamEnv<'tcx>,\n         generic_ty: Ty<'tcx>,\n         lower_bound: RegionVid,\n@@ -1398,7 +1398,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// whether any of the constraints were too strong. In particular,\n     /// we want to check for a case where a universally quantified\n     /// region exceeded its bounds. Consider:\n-    /// ```compile_fail,E0312\n+    /// ```compile_fail\n     /// fn foo<'a, 'b>(x: &'a u32) -> &'b u32 { x }\n     /// ```\n     /// In this case, returning `x` requires `&'a u32 <: &'b u32`\n@@ -1451,7 +1451,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// <https://smallcultfollowing.com/babysteps/blog/2019/01/17/polonius-and-region-errors/>\n     ///\n     /// In the canonical example\n-    /// ```compile_fail,E0312\n+    /// ```compile_fail\n     /// fn foo<'a, 'b>(x: &'a u32) -> &'b u32 { x }\n     /// ```\n     /// returning `x` requires `&'a u32 <: &'b u32` and hence we establish (transitively) a\n@@ -1718,7 +1718,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n \n     fn check_member_constraints(\n         &self,\n-        infcx: &InferCtxt<'_, 'tcx>,\n+        infcx: &InferCtxt<'tcx>,\n         errors_buffer: &mut RegionErrors<'tcx>,\n     ) {\n         let member_constraints = self.member_constraints.clone();\n@@ -1807,7 +1807,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     pub(crate) fn retrieve_closure_constraint_info(\n         &self,\n         constraint: OutlivesConstraint<'tcx>,\n-    ) -> Option<(ConstraintCategory<'tcx>, Span)> {\n+    ) -> Option<(ConstraintCategory, Span)> {\n         match constraint.locations {\n             Locations::All(_) => None,\n             Locations::Single(loc) => {\n@@ -1822,7 +1822,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         fr1: RegionVid,\n         fr1_origin: NllRegionVariableOrigin,\n         fr2: RegionVid,\n-    ) -> (ConstraintCategory<'tcx>, ObligationCause<'tcx>) {\n+    ) -> (ConstraintCategory, ObligationCause<'tcx>) {\n         let BlameConstraint { category, cause, .. } = self\n             .best_blame_constraint(fr1, fr1_origin, |r| self.provides_universal_region(r, fr1, fr2))\n             .0;\n@@ -2236,6 +2236,27 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     pub(crate) fn universe_info(&self, universe: ty::UniverseIndex) -> UniverseInfo<'tcx> {\n         self.universe_causes[&universe].clone()\n     }\n+\n+    /// Tries to find the terminator of the loop in which the region 'r' resides.\n+    /// Returns the location of the terminator if found.\n+    pub(crate) fn find_loop_terminator_location(\n+        &self,\n+        r: RegionVid,\n+        body: &Body<'_>,\n+    ) -> Option<Location> {\n+        let scc = self.constraint_sccs.scc(r.to_region_vid());\n+        let locations = self.scc_values.locations_outlived_by(scc);\n+        for location in locations {\n+            let bb = &body[location.block];\n+            if let Some(terminator) = &bb.terminator {\n+                // terminator of a loop should be TerminatorKind::FalseUnwind\n+                if let TerminatorKind::FalseUnwind { .. } = terminator.kind {\n+                    return Some(location);\n+                }\n+            }\n+        }\n+        None\n+    }\n }\n \n impl<'tcx> RegionDefinition<'tcx> {\n@@ -2341,7 +2362,7 @@ impl<'tcx> ClosureRegionRequirementsExt<'tcx> for ClosureRegionRequirements<'tcx\n \n #[derive(Clone, Debug)]\n pub struct BlameConstraint<'tcx> {\n-    pub category: ConstraintCategory<'tcx>,\n+    pub category: ConstraintCategory,\n     pub from_closure: bool,\n     pub cause: ObligationCause<'tcx>,\n     pub variance_info: ty::VarianceDiagInfo<'tcx>,"}, {"sha": "11a57ef26217476e2e712b0f1b58adaadcee486c", "filename": "compiler/rustc_borrowck/src/region_infer/opaque_types.rs", "status": "modified", "additions": 66, "deletions": 310, "changes": 376, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fopaque_types.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "patch": "@@ -2,22 +2,18 @@ use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::vec_map::VecMap;\n use rustc_hir::def_id::LocalDefId;\n use rustc_hir::OpaqueTyOrigin;\n-use rustc_infer::infer::error_reporting::unexpected_hidden_region_diagnostic;\n use rustc_infer::infer::TyCtxtInferExt as _;\n use rustc_infer::infer::{DefiningAnchor, InferCtxt};\n use rustc_infer::traits::{Obligation, ObligationCause, TraitEngine};\n-use rustc_middle::ty::fold::{TypeFolder, TypeSuperFoldable};\n-use rustc_middle::ty::subst::{GenericArg, GenericArgKind, InternalSubsts};\n+use rustc_middle::ty::subst::{GenericArgKind, InternalSubsts};\n use rustc_middle::ty::visit::TypeVisitable;\n use rustc_middle::ty::{\n     self, OpaqueHiddenType, OpaqueTypeKey, ToPredicate, Ty, TyCtxt, TypeFoldable,\n };\n use rustc_span::Span;\n-use rustc_trait_selection::traits::error_reporting::InferCtxtExt as _;\n+use rustc_trait_selection::traits::error_reporting::TypeErrCtxtExt as _;\n use rustc_trait_selection::traits::TraitEngineExt as _;\n \n-use crate::session_diagnostics::ConstNotUsedTraitAlias;\n-\n use super::RegionInferenceContext;\n \n impl<'tcx> RegionInferenceContext<'tcx> {\n@@ -63,7 +59,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     #[instrument(level = \"debug\", skip(self, infcx), ret)]\n     pub(crate) fn infer_opaque_types(\n         &self,\n-        infcx: &InferCtxt<'_, 'tcx>,\n+        infcx: &InferCtxt<'tcx>,\n         opaque_ty_decls: VecMap<OpaqueTypeKey<'tcx>, (OpaqueHiddenType<'tcx>, OpaqueTyOrigin)>,\n     ) -> VecMap<LocalDefId, OpaqueHiddenType<'tcx>> {\n         let mut result: VecMap<LocalDefId, OpaqueHiddenType<'tcx>> = VecMap::new();\n@@ -194,7 +190,7 @@ pub trait InferCtxtExt<'tcx> {\n     ) -> Ty<'tcx>;\n }\n \n-impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n+impl<'tcx> InferCtxtExt<'tcx> for InferCtxt<'tcx> {\n     /// Given the fully resolved, instantiated type for an opaque\n     /// type, i.e., the value of an inference variable like C1 or C2\n     /// (*), computes the \"definition type\" for an opaque type\n@@ -229,31 +225,9 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n             return self.tcx.ty_error();\n         }\n \n-        let OpaqueTypeKey { def_id, substs } = opaque_type_key;\n-\n-        // Use substs to build up a reverse map from regions to their\n-        // identity mappings. This is necessary because of `impl\n-        // Trait` lifetimes are computed by replacing existing\n-        // lifetimes with 'static and remapping only those used in the\n-        // `impl Trait` return type, resulting in the parameters\n-        // shifting.\n-        let id_substs = InternalSubsts::identity_for_item(self.tcx, def_id.to_def_id());\n-        debug!(?id_substs);\n-        let map: FxHashMap<GenericArg<'tcx>, GenericArg<'tcx>> =\n-            substs.iter().enumerate().map(|(index, subst)| (subst, id_substs[index])).collect();\n-        debug!(\"map = {:#?}\", map);\n-\n-        // Convert the type from the function into a type valid outside\n-        // the function, by replacing invalid regions with 'static,\n-        // after producing an error for each of them.\n-        let definition_ty = instantiated_ty.ty.fold_with(&mut ReverseMapper::new(\n-            self.tcx,\n-            opaque_type_key,\n-            map,\n-            instantiated_ty.ty,\n-            instantiated_ty.span,\n-        ));\n-        debug!(?definition_ty);\n+        let definition_ty = instantiated_ty\n+            .remap_generic_params_to_declaration_params(opaque_type_key, self.tcx, false, origin)\n+            .ty;\n \n         if !check_opaque_type_parameter_valid(\n             self.tcx,\n@@ -266,72 +240,72 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n \n         // Only check this for TAIT. RPIT already supports `src/test/ui/impl-trait/nested-return-type2.rs`\n         // on stable and we'd break that.\n-        if let OpaqueTyOrigin::TyAlias = origin {\n-            // This logic duplicates most of `check_opaque_meets_bounds`.\n-            // FIXME(oli-obk): Also do region checks here and then consider removing `check_opaque_meets_bounds` entirely.\n-            let param_env = self.tcx.param_env(def_id);\n-            let body_id = self.tcx.local_def_id_to_hir_id(def_id);\n-            // HACK This bubble is required for this tests to pass:\n-            // type-alias-impl-trait/issue-67844-nested-opaque.rs\n-            self.tcx.infer_ctxt().with_opaque_type_inference(DefiningAnchor::Bubble).enter(\n-                move |infcx| {\n-                    // Require the hidden type to be well-formed with only the generics of the opaque type.\n-                    // Defining use functions may have more bounds than the opaque type, which is ok, as long as the\n-                    // hidden type is well formed even without those bounds.\n-                    let predicate =\n-                        ty::Binder::dummy(ty::PredicateKind::WellFormed(definition_ty.into()))\n-                            .to_predicate(infcx.tcx);\n-                    let mut fulfillment_cx = <dyn TraitEngine<'tcx>>::new(infcx.tcx);\n+        let OpaqueTyOrigin::TyAlias = origin else {\n+            return definition_ty;\n+        };\n+        let def_id = opaque_type_key.def_id;\n+        // This logic duplicates most of `check_opaque_meets_bounds`.\n+        // FIXME(oli-obk): Also do region checks here and then consider removing `check_opaque_meets_bounds` entirely.\n+        let param_env = self.tcx.param_env(def_id);\n+        let body_id = self.tcx.local_def_id_to_hir_id(def_id);\n+        // HACK This bubble is required for this tests to pass:\n+        // type-alias-impl-trait/issue-67844-nested-opaque.rs\n+        let infcx =\n+            self.tcx.infer_ctxt().with_opaque_type_inference(DefiningAnchor::Bubble).build();\n+        // Require the hidden type to be well-formed with only the generics of the opaque type.\n+        // Defining use functions may have more bounds than the opaque type, which is ok, as long as the\n+        // hidden type is well formed even without those bounds.\n+        let predicate = ty::Binder::dummy(ty::PredicateKind::WellFormed(definition_ty.into()))\n+            .to_predicate(infcx.tcx);\n+        let mut fulfillment_cx = <dyn TraitEngine<'tcx>>::new(infcx.tcx);\n \n-                    // Require that the hidden type actually fulfills all the bounds of the opaque type, even without\n-                    // the bounds that the function supplies.\n-                    match infcx.register_hidden_type(\n-                        OpaqueTypeKey { def_id, substs: id_substs },\n-                        ObligationCause::misc(instantiated_ty.span, body_id),\n-                        param_env,\n+        let id_substs = InternalSubsts::identity_for_item(self.tcx, def_id.to_def_id());\n+\n+        // Require that the hidden type actually fulfills all the bounds of the opaque type, even without\n+        // the bounds that the function supplies.\n+        match infcx.register_hidden_type(\n+            OpaqueTypeKey { def_id, substs: id_substs },\n+            ObligationCause::misc(instantiated_ty.span, body_id),\n+            param_env,\n+            definition_ty,\n+            origin,\n+        ) {\n+            Ok(infer_ok) => {\n+                for obligation in infer_ok.obligations {\n+                    fulfillment_cx.register_predicate_obligation(&infcx, obligation);\n+                }\n+            }\n+            Err(err) => {\n+                infcx\n+                    .err_ctxt()\n+                    .report_mismatched_types(\n+                        &ObligationCause::misc(instantiated_ty.span, body_id),\n+                        self.tcx.mk_opaque(def_id.to_def_id(), id_substs),\n                         definition_ty,\n-                        origin,\n-                    ) {\n-                        Ok(infer_ok) => {\n-                            for obligation in infer_ok.obligations {\n-                                fulfillment_cx.register_predicate_obligation(&infcx, obligation);\n-                            }\n-                        }\n-                        Err(err) => {\n-                            infcx\n-                                .report_mismatched_types(\n-                                    &ObligationCause::misc(instantiated_ty.span, body_id),\n-                                    self.tcx.mk_opaque(def_id.to_def_id(), id_substs),\n-                                    definition_ty,\n-                                    err,\n-                                )\n-                                .emit();\n-                        }\n-                    }\n+                        err,\n+                    )\n+                    .emit();\n+            }\n+        }\n \n-                    fulfillment_cx.register_predicate_obligation(\n-                        &infcx,\n-                        Obligation::misc(instantiated_ty.span, body_id, param_env, predicate),\n-                    );\n+        fulfillment_cx.register_predicate_obligation(\n+            &infcx,\n+            Obligation::misc(instantiated_ty.span, body_id, param_env, predicate),\n+        );\n \n-                    // Check that all obligations are satisfied by the implementation's\n-                    // version.\n-                    let errors = fulfillment_cx.select_all_or_error(&infcx);\n+        // Check that all obligations are satisfied by the implementation's\n+        // version.\n+        let errors = fulfillment_cx.select_all_or_error(&infcx);\n \n-                    // This is still required for many(half of the tests in ui/type-alias-impl-trait)\n-                    // tests to pass\n-                    let _ = infcx.inner.borrow_mut().opaque_type_storage.take_opaque_types();\n+        // This is still required for many(half of the tests in ui/type-alias-impl-trait)\n+        // tests to pass\n+        let _ = infcx.inner.borrow_mut().opaque_type_storage.take_opaque_types();\n \n-                    if errors.is_empty() {\n-                        definition_ty\n-                    } else {\n-                        infcx.report_fulfillment_errors(&errors, None, false);\n-                        self.tcx.ty_error()\n-                    }\n-                },\n-            )\n-        } else {\n+        if errors.is_empty() {\n             definition_ty\n+        } else {\n+            infcx.err_ctxt().report_fulfillment_errors(&errors, None, false);\n+            self.tcx.ty_error()\n         }\n     }\n }\n@@ -427,221 +401,3 @@ fn check_opaque_type_parameter_valid(\n     }\n     true\n }\n-\n-struct ReverseMapper<'tcx> {\n-    tcx: TyCtxt<'tcx>,\n-\n-    key: ty::OpaqueTypeKey<'tcx>,\n-    map: FxHashMap<GenericArg<'tcx>, GenericArg<'tcx>>,\n-    do_not_error: bool,\n-\n-    /// initially `Some`, set to `None` once error has been reported\n-    hidden_ty: Option<Ty<'tcx>>,\n-\n-    /// Span of function being checked.\n-    span: Span,\n-}\n-\n-impl<'tcx> ReverseMapper<'tcx> {\n-    fn new(\n-        tcx: TyCtxt<'tcx>,\n-        key: ty::OpaqueTypeKey<'tcx>,\n-        map: FxHashMap<GenericArg<'tcx>, GenericArg<'tcx>>,\n-        hidden_ty: Ty<'tcx>,\n-        span: Span,\n-    ) -> Self {\n-        Self { tcx, key, map, do_not_error: false, hidden_ty: Some(hidden_ty), span }\n-    }\n-\n-    fn fold_kind_no_missing_regions_error(&mut self, kind: GenericArg<'tcx>) -> GenericArg<'tcx> {\n-        assert!(!self.do_not_error);\n-        self.do_not_error = true;\n-        let kind = kind.fold_with(self);\n-        self.do_not_error = false;\n-        kind\n-    }\n-\n-    fn fold_kind_normally(&mut self, kind: GenericArg<'tcx>) -> GenericArg<'tcx> {\n-        assert!(!self.do_not_error);\n-        kind.fold_with(self)\n-    }\n-}\n-\n-impl<'tcx> TypeFolder<'tcx> for ReverseMapper<'tcx> {\n-    fn tcx(&self) -> TyCtxt<'tcx> {\n-        self.tcx\n-    }\n-\n-    #[instrument(skip(self), level = \"debug\")]\n-    fn fold_region(&mut self, r: ty::Region<'tcx>) -> ty::Region<'tcx> {\n-        match *r {\n-            // Ignore bound regions and `'static` regions that appear in the\n-            // type, we only need to remap regions that reference lifetimes\n-            // from the function declaration.\n-            // This would ignore `'r` in a type like `for<'r> fn(&'r u32)`.\n-            ty::ReLateBound(..) | ty::ReStatic => return r,\n-\n-            // If regions have been erased (by writeback), don't try to unerase\n-            // them.\n-            ty::ReErased => return r,\n-\n-            // The regions that we expect from borrow checking.\n-            ty::ReEarlyBound(_) | ty::ReFree(_) => {}\n-\n-            ty::RePlaceholder(_) | ty::ReVar(_) => {\n-                // All of the regions in the type should either have been\n-                // erased by writeback, or mapped back to named regions by\n-                // borrow checking.\n-                bug!(\"unexpected region kind in opaque type: {:?}\", r);\n-            }\n-        }\n-\n-        let generics = self.tcx().generics_of(self.key.def_id);\n-        match self.map.get(&r.into()).map(|k| k.unpack()) {\n-            Some(GenericArgKind::Lifetime(r1)) => r1,\n-            Some(u) => panic!(\"region mapped to unexpected kind: {:?}\", u),\n-            None if self.do_not_error => self.tcx.lifetimes.re_static,\n-            None if generics.parent.is_some() => {\n-                if let Some(hidden_ty) = self.hidden_ty.take() {\n-                    unexpected_hidden_region_diagnostic(\n-                        self.tcx,\n-                        self.tcx.def_span(self.key.def_id),\n-                        hidden_ty,\n-                        r,\n-                        self.key,\n-                    )\n-                    .emit();\n-                }\n-                self.tcx.lifetimes.re_static\n-            }\n-            None => {\n-                self.tcx\n-                    .sess\n-                    .struct_span_err(self.span, \"non-defining opaque type use in defining scope\")\n-                    .span_label(\n-                        self.span,\n-                        format!(\n-                            \"lifetime `{}` is part of concrete type but not used in \\\n-                                 parameter list of the `impl Trait` type alias\",\n-                            r\n-                        ),\n-                    )\n-                    .emit();\n-\n-                self.tcx().lifetimes.re_static\n-            }\n-        }\n-    }\n-\n-    fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n-        match *ty.kind() {\n-            ty::Closure(def_id, substs) => {\n-                // I am a horrible monster and I pray for death. When\n-                // we encounter a closure here, it is always a closure\n-                // from within the function that we are currently\n-                // type-checking -- one that is now being encapsulated\n-                // in an opaque type. Ideally, we would\n-                // go through the types/lifetimes that it references\n-                // and treat them just like we would any other type,\n-                // which means we would error out if we find any\n-                // reference to a type/region that is not in the\n-                // \"reverse map\".\n-                //\n-                // **However,** in the case of closures, there is a\n-                // somewhat subtle (read: hacky) consideration. The\n-                // problem is that our closure types currently include\n-                // all the lifetime parameters declared on the\n-                // enclosing function, even if they are unused by the\n-                // closure itself. We can't readily filter them out,\n-                // so here we replace those values with `'empty`. This\n-                // can't really make a difference to the rest of the\n-                // compiler; those regions are ignored for the\n-                // outlives relation, and hence don't affect trait\n-                // selection or auto traits, and they are erased\n-                // during codegen.\n-\n-                let generics = self.tcx.generics_of(def_id);\n-                let substs = self.tcx.mk_substs(substs.iter().enumerate().map(|(index, kind)| {\n-                    if index < generics.parent_count {\n-                        // Accommodate missing regions in the parent kinds...\n-                        self.fold_kind_no_missing_regions_error(kind)\n-                    } else {\n-                        // ...but not elsewhere.\n-                        self.fold_kind_normally(kind)\n-                    }\n-                }));\n-\n-                self.tcx.mk_closure(def_id, substs)\n-            }\n-\n-            ty::Generator(def_id, substs, movability) => {\n-                let generics = self.tcx.generics_of(def_id);\n-                let substs = self.tcx.mk_substs(substs.iter().enumerate().map(|(index, kind)| {\n-                    if index < generics.parent_count {\n-                        // Accommodate missing regions in the parent kinds...\n-                        self.fold_kind_no_missing_regions_error(kind)\n-                    } else {\n-                        // ...but not elsewhere.\n-                        self.fold_kind_normally(kind)\n-                    }\n-                }));\n-\n-                self.tcx.mk_generator(def_id, substs, movability)\n-            }\n-\n-            ty::Param(param) => {\n-                // Look it up in the substitution list.\n-                match self.map.get(&ty.into()).map(|k| k.unpack()) {\n-                    // Found it in the substitution list; replace with the parameter from the\n-                    // opaque type.\n-                    Some(GenericArgKind::Type(t1)) => t1,\n-                    Some(u) => panic!(\"type mapped to unexpected kind: {:?}\", u),\n-                    None => {\n-                        debug!(?param, ?self.map);\n-                        self.tcx\n-                            .sess\n-                            .struct_span_err(\n-                                self.span,\n-                                &format!(\n-                                    \"type parameter `{}` is part of concrete type but not \\\n-                                          used in parameter list for the `impl Trait` type alias\",\n-                                    ty\n-                                ),\n-                            )\n-                            .emit();\n-\n-                        self.tcx().ty_error()\n-                    }\n-                }\n-            }\n-\n-            _ => ty.super_fold_with(self),\n-        }\n-    }\n-\n-    fn fold_const(&mut self, ct: ty::Const<'tcx>) -> ty::Const<'tcx> {\n-        trace!(\"checking const {:?}\", ct);\n-        // Find a const parameter\n-        match ct.kind() {\n-            ty::ConstKind::Param(..) => {\n-                // Look it up in the substitution list.\n-                match self.map.get(&ct.into()).map(|k| k.unpack()) {\n-                    // Found it in the substitution list, replace with the parameter from the\n-                    // opaque type.\n-                    Some(GenericArgKind::Const(c1)) => c1,\n-                    Some(u) => panic!(\"const mapped to unexpected kind: {:?}\", u),\n-                    None => {\n-                        self.tcx.sess.emit_err(ConstNotUsedTraitAlias {\n-                            ct: ct.to_string(),\n-                            span: self.span,\n-                        });\n-\n-                        self.tcx().const_error(ct.ty())\n-                    }\n-                }\n-            }\n-\n-            _ => ct,\n-        }\n-    }\n-}"}, {"sha": "f3023769081f205777cd4a238ae3cf31d24d4755", "filename": "compiler/rustc_borrowck/src/renumber.rs", "status": "modified", "additions": 5, "deletions": 27, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_borrowck%2Fsrc%2Frenumber.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_borrowck%2Fsrc%2Frenumber.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Frenumber.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "patch": "@@ -1,16 +1,16 @@\n use rustc_index::vec::IndexVec;\n use rustc_infer::infer::{InferCtxt, NllRegionVariableOrigin};\n use rustc_middle::mir::visit::{MutVisitor, TyContext};\n+use rustc_middle::mir::Constant;\n use rustc_middle::mir::{Body, Location, Promoted};\n-use rustc_middle::mir::{Constant, ConstantKind};\n use rustc_middle::ty::subst::SubstsRef;\n use rustc_middle::ty::{self, Ty, TyCtxt, TypeFoldable};\n \n /// Replaces all free regions appearing in the MIR with fresh\n /// inference variables, returning the number of variables created.\n #[instrument(skip(infcx, body, promoted), level = \"debug\")]\n pub fn renumber_mir<'tcx>(\n-    infcx: &InferCtxt<'_, 'tcx>,\n+    infcx: &InferCtxt<'tcx>,\n     body: &mut Body<'tcx>,\n     promoted: &mut IndexVec<Promoted, Body<'tcx>>,\n ) {\n@@ -28,7 +28,7 @@ pub fn renumber_mir<'tcx>(\n /// Replaces all regions appearing in `value` with fresh inference\n /// variables.\n #[instrument(skip(infcx), level = \"debug\")]\n-pub fn renumber_regions<'tcx, T>(infcx: &InferCtxt<'_, 'tcx>, value: T) -> T\n+pub fn renumber_regions<'tcx, T>(infcx: &InferCtxt<'tcx>, value: T) -> T\n where\n     T: TypeFoldable<'tcx>,\n {\n@@ -38,23 +38,8 @@ where\n     })\n }\n \n-// FIXME(valtrees): This function is necessary because `fold_regions`\n-// panics for mir constants in the visitor.\n-//\n-// Once `visit_mir_constant` is removed we can also remove this function\n-// and just use `renumber_regions`.\n-fn renumber_regions_in_mir_constant<'tcx>(\n-    infcx: &InferCtxt<'_, 'tcx>,\n-    value: ConstantKind<'tcx>,\n-) -> ConstantKind<'tcx> {\n-    infcx.tcx.super_fold_regions(value, |_region, _depth| {\n-        let origin = NllRegionVariableOrigin::Existential { from_forall: false };\n-        infcx.next_nll_region_var(origin)\n-    })\n-}\n-\n struct NllVisitor<'a, 'tcx> {\n-    infcx: &'a InferCtxt<'a, 'tcx>,\n+    infcx: &'a InferCtxt<'tcx>,\n }\n \n impl<'a, 'tcx> NllVisitor<'a, 'tcx> {\n@@ -64,13 +49,6 @@ impl<'a, 'tcx> NllVisitor<'a, 'tcx> {\n     {\n         renumber_regions(self.infcx, value)\n     }\n-\n-    fn renumber_regions_in_mir_constant(\n-        &mut self,\n-        value: ConstantKind<'tcx>,\n-    ) -> ConstantKind<'tcx> {\n-        renumber_regions_in_mir_constant(self.infcx, value)\n-    }\n }\n \n impl<'a, 'tcx> MutVisitor<'tcx> for NllVisitor<'a, 'tcx> {\n@@ -103,7 +81,7 @@ impl<'a, 'tcx> MutVisitor<'tcx> for NllVisitor<'a, 'tcx> {\n     #[instrument(skip(self), level = \"debug\")]\n     fn visit_constant(&mut self, constant: &mut Constant<'tcx>, _location: Location) {\n         let literal = constant.literal;\n-        constant.literal = self.renumber_regions_in_mir_constant(literal);\n+        constant.literal = self.renumber_regions(literal);\n         debug!(\"constant: {:#?}\", constant);\n     }\n }"}, {"sha": "ff667896eb1076244981405606ffa01ee5cc3141", "filename": "compiler/rustc_borrowck/src/session_diagnostics.rs", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_borrowck%2Fsrc%2Fsession_diagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_borrowck%2Fsrc%2Fsession_diagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fsession_diagnostics.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "patch": "@@ -52,15 +52,6 @@ pub(crate) struct VarNeedNotMut {\n     #[suggestion_short(applicability = \"machine-applicable\", code = \"\")]\n     pub span: Span,\n }\n-\n-#[derive(Diagnostic)]\n-#[diag(borrowck::const_not_used_in_type_alias)]\n-pub(crate) struct ConstNotUsedTraitAlias {\n-    pub ct: String,\n-    #[primary_span]\n-    pub span: Span,\n-}\n-\n #[derive(Diagnostic)]\n #[diag(borrowck::var_cannot_escape_closure)]\n #[note]"}, {"sha": "459ecfe17e3e7b43893a939499db0bdfc3461852", "filename": "compiler/rustc_borrowck/src/type_check/canonical.rs", "status": "modified", "additions": 11, "deletions": 16, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fcanonical.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fcanonical.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fcanonical.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "patch": "@@ -28,7 +28,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n     pub(super) fn fully_perform_op<R: fmt::Debug, Op>(\n         &mut self,\n         locations: Locations,\n-        category: ConstraintCategory<'tcx>,\n+        category: ConstraintCategory,\n         op: Op,\n     ) -> Fallible<R>\n     where\n@@ -52,11 +52,8 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                 Some(error_info) => error_info.to_universe_info(old_universe),\n                 None => UniverseInfo::other(),\n             };\n-            for u in old_universe..universe {\n-                self.borrowck_context\n-                    .constraints\n-                    .universe_causes\n-                    .insert(u + 1, universe_info.clone());\n+            for u in (old_universe + 1)..=universe {\n+                self.borrowck_context.constraints.universe_causes.insert(u, universe_info.clone());\n             }\n         }\n \n@@ -71,15 +68,13 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n     where\n         T: TypeFoldable<'tcx>,\n     {\n+        let old_universe = self.infcx.universe();\n+\n         let (instantiated, _) =\n             self.infcx.instantiate_canonical_with_fresh_inference_vars(span, canonical);\n \n-        for u in 0..canonical.max_universe.as_u32() {\n-            let info = UniverseInfo::other();\n-            self.borrowck_context\n-                .constraints\n-                .universe_causes\n-                .insert(ty::UniverseIndex::from_u32(u), info);\n+        for u in (old_universe + 1)..=self.infcx.universe() {\n+            self.borrowck_context.constraints.universe_causes.insert(u, UniverseInfo::other());\n         }\n \n         instantiated\n@@ -90,7 +85,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         &mut self,\n         trait_ref: ty::TraitRef<'tcx>,\n         locations: Locations,\n-        category: ConstraintCategory<'tcx>,\n+        category: ConstraintCategory,\n     ) {\n         self.prove_predicate(\n             ty::Binder::dummy(ty::PredicateKind::Trait(ty::TraitPredicate {\n@@ -129,7 +124,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         &mut self,\n         predicates: impl IntoIterator<Item = impl ToPredicate<'tcx>>,\n         locations: Locations,\n-        category: ConstraintCategory<'tcx>,\n+        category: ConstraintCategory,\n     ) {\n         for predicate in predicates {\n             let predicate = predicate.to_predicate(self.tcx());\n@@ -144,7 +139,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         &mut self,\n         predicate: ty::Predicate<'tcx>,\n         locations: Locations,\n-        category: ConstraintCategory<'tcx>,\n+        category: ConstraintCategory,\n     ) {\n         let param_env = self.param_env;\n         self.fully_perform_op(\n@@ -169,7 +164,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         &mut self,\n         value: T,\n         location: impl NormalizeLocation,\n-        category: ConstraintCategory<'tcx>,\n+        category: ConstraintCategory,\n     ) -> T\n     where\n         T: type_op::normalize::Normalizable<'tcx> + fmt::Display + Copy + 'tcx,"}, {"sha": "d7e5a118a2e0bb3902735d2fb6b7cc14e82137e9", "filename": "compiler/rustc_borrowck/src/type_check/constraint_conversion.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fconstraint_conversion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fconstraint_conversion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fconstraint_conversion.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "patch": "@@ -19,7 +19,7 @@ use crate::{\n };\n \n pub(crate) struct ConstraintConversion<'a, 'tcx> {\n-    infcx: &'a InferCtxt<'a, 'tcx>,\n+    infcx: &'a InferCtxt<'tcx>,\n     tcx: TyCtxt<'tcx>,\n     universal_regions: &'a UniversalRegions<'tcx>,\n     /// Each RBP `GK: 'a` is assumed to be true. These encode\n@@ -37,20 +37,20 @@ pub(crate) struct ConstraintConversion<'a, 'tcx> {\n     param_env: ty::ParamEnv<'tcx>,\n     locations: Locations,\n     span: Span,\n-    category: ConstraintCategory<'tcx>,\n+    category: ConstraintCategory,\n     constraints: &'a mut MirTypeckRegionConstraints<'tcx>,\n }\n \n impl<'a, 'tcx> ConstraintConversion<'a, 'tcx> {\n     pub(crate) fn new(\n-        infcx: &'a InferCtxt<'a, 'tcx>,\n+        infcx: &'a InferCtxt<'tcx>,\n         universal_regions: &'a UniversalRegions<'tcx>,\n         region_bound_pairs: &'a RegionBoundPairs<'tcx>,\n         implicit_region_bound: ty::Region<'tcx>,\n         param_env: ty::ParamEnv<'tcx>,\n         locations: Locations,\n         span: Span,\n-        category: ConstraintCategory<'tcx>,\n+        category: ConstraintCategory,\n         constraints: &'a mut MirTypeckRegionConstraints<'tcx>,\n     ) -> Self {\n         Self {\n@@ -175,7 +175,7 @@ impl<'a, 'tcx> ConstraintConversion<'a, 'tcx> {\n         &mut self,\n         sup: ty::RegionVid,\n         sub: ty::RegionVid,\n-        category: ConstraintCategory<'tcx>,\n+        category: ConstraintCategory,\n     ) {\n         let category = match self.category {\n             ConstraintCategory::Boring | ConstraintCategory::BoringNoLocation => category,\n@@ -203,7 +203,7 @@ impl<'a, 'b, 'tcx> TypeOutlivesDelegate<'tcx> for &'a mut ConstraintConversion<'\n         _origin: SubregionOrigin<'tcx>,\n         a: ty::Region<'tcx>,\n         b: ty::Region<'tcx>,\n-        constraint_category: ConstraintCategory<'tcx>,\n+        constraint_category: ConstraintCategory,\n     ) {\n         let b = self.to_region_vid(b);\n         let a = self.to_region_vid(a);"}, {"sha": "02909592637d8cb1c3bed880cf79b8fdf8a2224a", "filename": "compiler/rustc_borrowck/src/type_check/free_region_relations.rs", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Ffree_region_relations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Ffree_region_relations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Ffree_region_relations.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "patch": "@@ -8,7 +8,6 @@ use rustc_infer::infer::InferCtxt;\n use rustc_middle::mir::ConstraintCategory;\n use rustc_middle::traits::query::OutlivesBound;\n use rustc_middle::ty::{self, RegionVid, Ty};\n-use rustc_span::DUMMY_SP;\n use rustc_trait_selection::traits::query::type_op::{self, TypeOp};\n use std::rc::Rc;\n use type_op::TypeOpOutput;\n@@ -48,7 +47,7 @@ pub(crate) struct CreateResult<'tcx> {\n }\n \n pub(crate) fn create<'tcx>(\n-    infcx: &InferCtxt<'_, 'tcx>,\n+    infcx: &InferCtxt<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n     implicit_region_bound: ty::Region<'tcx>,\n     universal_regions: &Rc<UniversalRegions<'tcx>>,\n@@ -197,7 +196,7 @@ impl UniversalRegionRelations<'_> {\n }\n \n struct UniversalRegionRelationsBuilder<'this, 'tcx> {\n-    infcx: &'this InferCtxt<'this, 'tcx>,\n+    infcx: &'this InferCtxt<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n     universal_regions: Rc<UniversalRegions<'tcx>>,\n     implicit_region_bound: ty::Region<'tcx>,\n@@ -219,6 +218,7 @@ impl<'tcx> UniversalRegionRelationsBuilder<'_, 'tcx> {\n     }\n \n     pub(crate) fn create(mut self) -> CreateResult<'tcx> {\n+        let span = self.infcx.tcx.def_span(self.universal_regions.defining_ty.def_id());\n         let unnormalized_input_output_tys = self\n             .universal_regions\n             .unnormalized_input_tys\n@@ -250,7 +250,7 @@ impl<'tcx> UniversalRegionRelationsBuilder<'_, 'tcx> {\n                         self.infcx\n                             .tcx\n                             .sess\n-                            .delay_span_bug(DUMMY_SP, &format!(\"failed to normalize {:?}\", ty));\n+                            .delay_span_bug(span, &format!(\"failed to normalize {:?}\", ty));\n                         TypeOpOutput {\n                             output: self.infcx.tcx.ty_error(),\n                             constraints: None,\n@@ -301,8 +301,8 @@ impl<'tcx> UniversalRegionRelationsBuilder<'_, 'tcx> {\n                 &self.region_bound_pairs,\n                 self.implicit_region_bound,\n                 self.param_env,\n-                Locations::All(DUMMY_SP),\n-                DUMMY_SP,\n+                Locations::All(span),\n+                span,\n                 ConstraintCategory::Internal,\n                 &mut self.constraints,\n             )\n@@ -362,6 +362,11 @@ impl<'tcx> UniversalRegionRelationsBuilder<'_, 'tcx> {\n                     self.region_bound_pairs\n                         .insert(ty::OutlivesPredicate(GenericKind::Projection(projection_b), r_a));\n                 }\n+\n+                OutlivesBound::RegionSubOpaque(r_a, def_id, substs) => {\n+                    self.region_bound_pairs\n+                        .insert(ty::OutlivesPredicate(GenericKind::Opaque(def_id, substs), r_a));\n+                }\n             }\n         }\n     }"}, {"sha": "a66ddd27dbb2ee178b2fccfc6924e63fb7ee797a", "filename": "compiler/rustc_borrowck/src/type_check/input_output.rs", "status": "modified", "additions": 2, "deletions": 37, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Finput_output.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Finput_output.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Finput_output.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "patch": "@@ -7,16 +7,11 @@\n //! `RETURN_PLACE` the MIR arguments) are always fully normalized (and\n //! contain revealed `impl Trait` values).\n \n-use crate::type_check::constraint_conversion::ConstraintConversion;\n use rustc_index::vec::Idx;\n use rustc_infer::infer::LateBoundRegionConversionTime;\n use rustc_middle::mir::*;\n use rustc_middle::ty::Ty;\n use rustc_span::Span;\n-use rustc_span::DUMMY_SP;\n-use rustc_trait_selection::traits::query::type_op::{self, TypeOp};\n-use rustc_trait_selection::traits::query::Fallible;\n-use type_op::TypeOpOutput;\n \n use crate::universal_regions::UniversalRegions;\n \n@@ -185,7 +180,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         }\n     }\n \n-    #[instrument(skip(self, span), level = \"debug\")]\n+    #[instrument(skip(self), level = \"debug\")]\n     fn equate_normalized_input_or_output(&mut self, a: Ty<'tcx>, b: Ty<'tcx>, span: Span) {\n         if let Err(_) =\n             self.eq_types(a, b, Locations::All(span), ConstraintCategory::BoringNoLocation)\n@@ -194,13 +189,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n             // `rustc_traits::normalize_after_erasing_regions`. Ideally, we'd\n             // like to normalize *before* inserting into `local_decls`, but\n             // doing so ends up causing some other trouble.\n-            let b = match self.normalize_and_add_constraints(b) {\n-                Ok(n) => n,\n-                Err(_) => {\n-                    debug!(\"equate_inputs_and_outputs: NoSolution\");\n-                    b\n-                }\n-            };\n+            let b = self.normalize(b, Locations::All(span));\n \n             // Note: if we have to introduce new placeholders during normalization above, then we won't have\n             // added those universes to the universe info, which we would want in `relate_tys`.\n@@ -218,28 +207,4 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n             }\n         }\n     }\n-\n-    pub(crate) fn normalize_and_add_constraints(&mut self, t: Ty<'tcx>) -> Fallible<Ty<'tcx>> {\n-        let TypeOpOutput { output: norm_ty, constraints, .. } =\n-            self.param_env.and(type_op::normalize::Normalize::new(t)).fully_perform(self.infcx)?;\n-\n-        debug!(\"{:?} normalized to {:?}\", t, norm_ty);\n-\n-        for data in constraints {\n-            ConstraintConversion::new(\n-                self.infcx,\n-                &self.borrowck_context.universal_regions,\n-                &self.region_bound_pairs,\n-                self.implicit_region_bound,\n-                self.param_env,\n-                Locations::All(DUMMY_SP),\n-                DUMMY_SP,\n-                ConstraintCategory::Internal,\n-                &mut self.borrowck_context.constraints,\n-            )\n-            .convert_all(&*data);\n-        }\n-\n-        Ok(norm_ty)\n-    }\n }"}, {"sha": "00cacd515a1e2c469f1b4378497500aa1823a0fd", "filename": "compiler/rustc_borrowck/src/type_check/mod.rs", "status": "modified", "additions": 113, "deletions": 35, "changes": 148, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "patch": "@@ -123,7 +123,7 @@ mod relate_tys;\n /// - `move_data` -- move-data constructed when performing the maybe-init dataflow analysis\n /// - `elements` -- MIR region map\n pub(crate) fn type_check<'mir, 'tcx>(\n-    infcx: &InferCtxt<'_, 'tcx>,\n+    infcx: &InferCtxt<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n     body: &Body<'tcx>,\n     promoted: &IndexVec<Promoted, Body<'tcx>>,\n@@ -138,8 +138,6 @@ pub(crate) fn type_check<'mir, 'tcx>(\n     use_polonius: bool,\n ) -> MirTypeckResults<'tcx> {\n     let implicit_region_bound = infcx.tcx.mk_region(ty::ReVar(universal_regions.fr_fn_body));\n-    let mut universe_causes = FxHashMap::default();\n-    universe_causes.insert(ty::UniverseIndex::from_u32(0), UniverseInfo::other());\n     let mut constraints = MirTypeckRegionConstraints {\n         placeholder_indices: PlaceholderIndices::default(),\n         placeholder_index_to_region: IndexVec::default(),\n@@ -148,7 +146,7 @@ pub(crate) fn type_check<'mir, 'tcx>(\n         member_constraints: MemberConstraintSet::default(),\n         closure_bounds_mapping: Default::default(),\n         type_tests: Vec::default(),\n-        universe_causes,\n+        universe_causes: FxHashMap::default(),\n     };\n \n     let CreateResult {\n@@ -165,9 +163,8 @@ pub(crate) fn type_check<'mir, 'tcx>(\n \n     debug!(?normalized_inputs_and_output);\n \n-    for u in ty::UniverseIndex::ROOT..infcx.universe() {\n-        let info = UniverseInfo::other();\n-        constraints.universe_causes.insert(u, info);\n+    for u in ty::UniverseIndex::ROOT..=infcx.universe() {\n+        constraints.universe_causes.insert(u, UniverseInfo::other());\n     }\n \n     let mut borrowck_context = BorrowCheckContext {\n@@ -236,7 +233,7 @@ pub(crate) fn type_check<'mir, 'tcx>(\n                 .unwrap();\n             let mut hidden_type = infcx.resolve_vars_if_possible(decl.hidden_type);\n             trace!(\"finalized opaque type {:?} to {:#?}\", opaque_type_key, hidden_type.ty.kind());\n-            if hidden_type.has_infer_types_or_consts() {\n+            if hidden_type.has_non_region_infer() {\n                 infcx.tcx.sess.delay_span_bug(\n                     decl.hidden_type.span,\n                     &format!(\"could not resolve {:#?}\", hidden_type.ty.kind()),\n@@ -587,6 +584,7 @@ impl<'a, 'b, 'tcx> TypeVerifier<'a, 'b, 'tcx> {\n         // modify their locations.\n         let all_facts = &mut None;\n         let mut constraints = Default::default();\n+        let mut type_tests = Default::default();\n         let mut closure_bounds = Default::default();\n         let mut liveness_constraints =\n             LivenessValues::new(Rc::new(RegionValueElements::new(&promoted_body)));\n@@ -598,6 +596,7 @@ impl<'a, 'b, 'tcx> TypeVerifier<'a, 'b, 'tcx> {\n                 &mut this.cx.borrowck_context.constraints.outlives_constraints,\n                 &mut constraints,\n             );\n+            mem::swap(&mut this.cx.borrowck_context.constraints.type_tests, &mut type_tests);\n             mem::swap(\n                 &mut this.cx.borrowck_context.constraints.closure_bounds_mapping,\n                 &mut closure_bounds,\n@@ -622,6 +621,13 @@ impl<'a, 'b, 'tcx> TypeVerifier<'a, 'b, 'tcx> {\n         swap_constraints(self);\n \n         let locations = location.to_locations();\n+\n+        // Use location of promoted const in collected constraints\n+        for type_test in type_tests.iter() {\n+            let mut type_test = type_test.clone();\n+            type_test.locations = locations;\n+            self.cx.borrowck_context.constraints.type_tests.push(type_test)\n+        }\n         for constraint in constraints.outlives().iter() {\n             let mut constraint = constraint.clone();\n             constraint.locations = locations;\n@@ -876,7 +882,7 @@ impl<'a, 'b, 'tcx> TypeVerifier<'a, 'b, 'tcx> {\n /// way, it accrues region constraints -- these can later be used by\n /// NLL region checking.\n struct TypeChecker<'a, 'tcx> {\n-    infcx: &'a InferCtxt<'a, 'tcx>,\n+    infcx: &'a InferCtxt<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n     last_span: Span,\n     body: &'a Body<'tcx>,\n@@ -936,7 +942,7 @@ pub(crate) struct MirTypeckRegionConstraints<'tcx> {\n     pub(crate) member_constraints: MemberConstraintSet<'tcx, RegionVid>,\n \n     pub(crate) closure_bounds_mapping:\n-        FxHashMap<Location, FxHashMap<(RegionVid, RegionVid), (ConstraintCategory<'tcx>, Span)>>,\n+        FxHashMap<Location, FxHashMap<(RegionVid, RegionVid), (ConstraintCategory, Span)>>,\n \n     pub(crate) universe_causes: FxHashMap<ty::UniverseIndex, UniverseInfo<'tcx>>,\n \n@@ -946,7 +952,7 @@ pub(crate) struct MirTypeckRegionConstraints<'tcx> {\n impl<'tcx> MirTypeckRegionConstraints<'tcx> {\n     fn placeholder_region(\n         &mut self,\n-        infcx: &InferCtxt<'_, 'tcx>,\n+        infcx: &InferCtxt<'tcx>,\n         placeholder: ty::PlaceholderRegion,\n     ) -> ty::Region<'tcx> {\n         let placeholder_index = self.placeholder_indices.insert(placeholder);\n@@ -1030,7 +1036,7 @@ impl Locations {\n \n impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n     fn new(\n-        infcx: &'a InferCtxt<'a, 'tcx>,\n+        infcx: &'a InferCtxt<'tcx>,\n         body: &'a Body<'tcx>,\n         param_env: ty::ParamEnv<'tcx>,\n         region_bound_pairs: &'a RegionBoundPairs<'tcx>,\n@@ -1127,7 +1133,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n     fn push_region_constraints(\n         &mut self,\n         locations: Locations,\n-        category: ConstraintCategory<'tcx>,\n+        category: ConstraintCategory,\n         data: &QueryRegionConstraints<'tcx>,\n     ) {\n         debug!(\"constraints generated: {:#?}\", data);\n@@ -1152,7 +1158,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         sub: Ty<'tcx>,\n         sup: Ty<'tcx>,\n         locations: Locations,\n-        category: ConstraintCategory<'tcx>,\n+        category: ConstraintCategory,\n     ) -> Fallible<()> {\n         // Use this order of parameters because the sup type is usually the\n         // \"expected\" type in diagnostics.\n@@ -1165,7 +1171,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         expected: Ty<'tcx>,\n         found: Ty<'tcx>,\n         locations: Locations,\n-        category: ConstraintCategory<'tcx>,\n+        category: ConstraintCategory,\n     ) -> Fallible<()> {\n         self.relate_types(expected, ty::Variance::Invariant, found, locations, category)\n     }\n@@ -1177,7 +1183,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         v: ty::Variance,\n         user_ty: &UserTypeProjection,\n         locations: Locations,\n-        category: ConstraintCategory<'tcx>,\n+        category: ConstraintCategory,\n     ) -> Fallible<()> {\n         let annotated_type = self.user_type_annotations[user_ty.base].inferred_ty;\n         let mut curr_projected_ty = PlaceTy::from_ty(annotated_type);\n@@ -1612,19 +1618,12 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n             span_mirbug!(self, term, \"call to {:?} with wrong # of args\", sig);\n         }\n \n-        let func_ty = if let TerminatorKind::Call { func, .. } = &term.kind {\n-            Some(func.ty(body, self.infcx.tcx))\n-        } else {\n-            None\n-        };\n-        debug!(?func_ty);\n-\n         for (n, (fn_arg, op_arg)) in iter::zip(sig.inputs(), args).enumerate() {\n             let op_arg_ty = op_arg.ty(body, self.tcx());\n \n             let op_arg_ty = self.normalize(op_arg_ty, term_location);\n             let category = if from_hir_call {\n-                ConstraintCategory::CallArgument(func_ty)\n+                ConstraintCategory::CallArgument(term_location)\n             } else {\n                 ConstraintCategory::Boring\n             };\n@@ -2209,25 +2208,104 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                             }\n                         }\n                     }\n-\n-                    CastKind::Misc => {\n+                    CastKind::IntToInt => {\n                         let ty_from = op.ty(body, tcx);\n                         let cast_ty_from = CastTy::from_ty(ty_from);\n                         let cast_ty_to = CastTy::from_ty(*ty);\n-                        // Misc casts are either between floats and ints, or one ptr type to another.\n                         match (cast_ty_from, cast_ty_to) {\n-                            (\n-                                Some(CastTy::Int(_) | CastTy::Float),\n-                                Some(CastTy::Int(_) | CastTy::Float),\n-                            )\n-                            | (Some(CastTy::Ptr(_) | CastTy::FnPtr), Some(CastTy::Ptr(_))) => (),\n+                            (Some(CastTy::Int(_)), Some(CastTy::Int(_))) => (),\n                             _ => {\n                                 span_mirbug!(\n                                     self,\n                                     rvalue,\n-                                    \"Invalid Misc cast {:?} -> {:?}\",\n+                                    \"Invalid IntToInt cast {:?} -> {:?}\",\n                                     ty_from,\n-                                    ty,\n+                                    ty\n+                                )\n+                            }\n+                        }\n+                    }\n+                    CastKind::IntToFloat => {\n+                        let ty_from = op.ty(body, tcx);\n+                        let cast_ty_from = CastTy::from_ty(ty_from);\n+                        let cast_ty_to = CastTy::from_ty(*ty);\n+                        match (cast_ty_from, cast_ty_to) {\n+                            (Some(CastTy::Int(_)), Some(CastTy::Float)) => (),\n+                            _ => {\n+                                span_mirbug!(\n+                                    self,\n+                                    rvalue,\n+                                    \"Invalid IntToFloat cast {:?} -> {:?}\",\n+                                    ty_from,\n+                                    ty\n+                                )\n+                            }\n+                        }\n+                    }\n+                    CastKind::FloatToInt => {\n+                        let ty_from = op.ty(body, tcx);\n+                        let cast_ty_from = CastTy::from_ty(ty_from);\n+                        let cast_ty_to = CastTy::from_ty(*ty);\n+                        match (cast_ty_from, cast_ty_to) {\n+                            (Some(CastTy::Float), Some(CastTy::Int(_))) => (),\n+                            _ => {\n+                                span_mirbug!(\n+                                    self,\n+                                    rvalue,\n+                                    \"Invalid FloatToInt cast {:?} -> {:?}\",\n+                                    ty_from,\n+                                    ty\n+                                )\n+                            }\n+                        }\n+                    }\n+                    CastKind::FloatToFloat => {\n+                        let ty_from = op.ty(body, tcx);\n+                        let cast_ty_from = CastTy::from_ty(ty_from);\n+                        let cast_ty_to = CastTy::from_ty(*ty);\n+                        match (cast_ty_from, cast_ty_to) {\n+                            (Some(CastTy::Float), Some(CastTy::Float)) => (),\n+                            _ => {\n+                                span_mirbug!(\n+                                    self,\n+                                    rvalue,\n+                                    \"Invalid FloatToFloat cast {:?} -> {:?}\",\n+                                    ty_from,\n+                                    ty\n+                                )\n+                            }\n+                        }\n+                    }\n+                    CastKind::FnPtrToPtr => {\n+                        let ty_from = op.ty(body, tcx);\n+                        let cast_ty_from = CastTy::from_ty(ty_from);\n+                        let cast_ty_to = CastTy::from_ty(*ty);\n+                        match (cast_ty_from, cast_ty_to) {\n+                            (Some(CastTy::FnPtr), Some(CastTy::Ptr(_))) => (),\n+                            _ => {\n+                                span_mirbug!(\n+                                    self,\n+                                    rvalue,\n+                                    \"Invalid FnPtrToPtr cast {:?} -> {:?}\",\n+                                    ty_from,\n+                                    ty\n+                                )\n+                            }\n+                        }\n+                    }\n+                    CastKind::PtrToPtr => {\n+                        let ty_from = op.ty(body, tcx);\n+                        let cast_ty_from = CastTy::from_ty(ty_from);\n+                        let cast_ty_to = CastTy::from_ty(*ty);\n+                        match (cast_ty_from, cast_ty_to) {\n+                            (Some(CastTy::Ptr(_)), Some(CastTy::Ptr(_))) => (),\n+                            _ => {\n+                                span_mirbug!(\n+                                    self,\n+                                    rvalue,\n+                                    \"Invalid PtrToPtr cast {:?} -> {:?}\",\n+                                    ty_from,\n+                                    ty\n                                 )\n                             }\n                         }\n@@ -2744,7 +2822,7 @@ impl<'tcx> TypeOp<'tcx> for InstantiateOpaqueType<'tcx> {\n     /// constraints in our `InferCtxt`\n     type ErrorInfo = InstantiateOpaqueType<'tcx>;\n \n-    fn fully_perform(mut self, infcx: &InferCtxt<'_, 'tcx>) -> Fallible<TypeOpOutput<'tcx, Self>> {\n+    fn fully_perform(mut self, infcx: &InferCtxt<'tcx>) -> Fallible<TypeOpOutput<'tcx, Self>> {\n         let (mut output, region_constraints) = scrape_region_constraints(infcx, || {\n             Ok(InferOk { value: (), obligations: self.obligations.clone() })\n         })?;"}, {"sha": "b53360ea61bbfc0f7a39153758c6cce1a69edf22", "filename": "compiler/rustc_borrowck/src/type_check/relate_tys.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Frelate_tys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Frelate_tys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Frelate_tys.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "patch": "@@ -28,7 +28,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         v: ty::Variance,\n         b: Ty<'tcx>,\n         locations: Locations,\n-        category: ConstraintCategory<'tcx>,\n+        category: ConstraintCategory,\n     ) -> Fallible<()> {\n         TypeRelating::new(\n             self.infcx,\n@@ -45,7 +45,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         a: ty::SubstsRef<'tcx>,\n         b: ty::SubstsRef<'tcx>,\n         locations: Locations,\n-        category: ConstraintCategory<'tcx>,\n+        category: ConstraintCategory,\n     ) -> Fallible<()> {\n         TypeRelating::new(\n             self.infcx,\n@@ -64,7 +64,7 @@ struct NllTypeRelatingDelegate<'me, 'bccx, 'tcx> {\n     locations: Locations,\n \n     /// What category do we assign the resulting `'a: 'b` relationships?\n-    category: ConstraintCategory<'tcx>,\n+    category: ConstraintCategory,\n \n     /// Information so that error reporting knows what types we are relating\n     /// when reporting a bound region error.\n@@ -75,7 +75,7 @@ impl<'me, 'bccx, 'tcx> NllTypeRelatingDelegate<'me, 'bccx, 'tcx> {\n     fn new(\n         type_checker: &'me mut TypeChecker<'bccx, 'tcx>,\n         locations: Locations,\n-        category: ConstraintCategory<'tcx>,\n+        category: ConstraintCategory,\n         universe_info: UniverseInfo<'tcx>,\n     ) -> Self {\n         Self { type_checker, locations, category, universe_info }"}, {"sha": "2beb5e0ab5d20daf2c3e878c4462c0b71e571a78", "filename": "compiler/rustc_borrowck/src/universal_regions.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_borrowck%2Fsrc%2Funiversal_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_borrowck%2Fsrc%2Funiversal_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Funiversal_regions.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "patch": "@@ -219,7 +219,7 @@ impl<'tcx> UniversalRegions<'tcx> {\n     /// signature. This will also compute the relationships that are\n     /// known between those regions.\n     pub fn new(\n-        infcx: &InferCtxt<'_, 'tcx>,\n+        infcx: &InferCtxt<'tcx>,\n         mir_def: ty::WithOptConstParam<LocalDefId>,\n         param_env: ty::ParamEnv<'tcx>,\n     ) -> Self {\n@@ -382,7 +382,7 @@ impl<'tcx> UniversalRegions<'tcx> {\n }\n \n struct UniversalRegionsBuilder<'cx, 'tcx> {\n-    infcx: &'cx InferCtxt<'cx, 'tcx>,\n+    infcx: &'cx InferCtxt<'tcx>,\n     mir_def: ty::WithOptConstParam<LocalDefId>,\n     mir_hir_id: HirId,\n     param_env: ty::ParamEnv<'tcx>,\n@@ -414,7 +414,7 @@ impl<'cx, 'tcx> UniversalRegionsBuilder<'cx, 'tcx> {\n \n         let typeck_root_def_id = self.infcx.tcx.typeck_root_def_id(self.mir_def.did.to_def_id());\n \n-        // If this is is a 'root' body (not a closure/generator/inline const), then\n+        // If this is a 'root' body (not a closure/generator/inline const), then\n         // there are no extern regions, so the local regions start at the same\n         // position as the (empty) sub-list of extern regions\n         let first_local_index = if self.mir_def.did.to_def_id() == typeck_root_def_id {\n@@ -699,7 +699,7 @@ trait InferCtxtExt<'tcx> {\n     );\n }\n \n-impl<'cx, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'cx, 'tcx> {\n+impl<'tcx> InferCtxtExt<'tcx> for InferCtxt<'tcx> {\n     fn replace_free_regions_with_nll_infer_vars<T>(\n         &self,\n         origin: NllRegionVariableOrigin,"}, {"sha": "bb6839360262af885d807408c1a2d7ed4cdb78d5", "filename": "compiler/rustc_builtin_macros/src/assert/context.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_builtin_macros%2Fsrc%2Fassert%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_builtin_macros%2Fsrc%2Fassert%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fassert%2Fcontext.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "patch": "@@ -58,6 +58,7 @@ impl<'cx, 'a> Context<'cx, 'a> {\n     /// Builds the whole `assert!` expression. For example, `let elem = 1; assert!(elem == 1);` expands to:\n     ///\n     /// ```rust\n+    /// #![feature(generic_assert_internals)]\n     /// let elem = 1;\n     /// {\n     ///   #[allow(unused_imports)]\n@@ -70,7 +71,7 @@ impl<'cx, 'a> Context<'cx, 'a> {\n     ///       __local_bind0\n     ///     } == 1\n     ///   ) {\n-    ///     panic!(\"Assertion failed: elem == 1\\nWith captures:\\n  elem = {}\", __capture0)\n+    ///     panic!(\"Assertion failed: elem == 1\\nWith captures:\\n  elem = {:?}\", __capture0)\n     ///   }\n     /// }\n     /// ```"}, {"sha": "7bd344467d03213130aa32ae46fad4f47875d853", "filename": "compiler/rustc_builtin_macros/src/deriving/bounds.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fbounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fbounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fbounds.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "patch": "@@ -16,6 +16,7 @@ pub fn expand_deriving_copy(\n     let trait_def = TraitDef {\n         span,\n         path: path_std!(marker::Copy),\n+        skip_path_as_bound: false,\n         additional_bounds: Vec::new(),\n         generics: Bounds::empty(),\n         supports_unions: true,"}, {"sha": "fa8685f5f4e5650882fa957c2368faa80e0abc0e", "filename": "compiler/rustc_builtin_macros/src/deriving/clone.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fclone.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "patch": "@@ -72,6 +72,7 @@ pub fn expand_deriving_clone(\n     let trait_def = TraitDef {\n         span,\n         path: path_std!(clone::Clone),\n+        skip_path_as_bound: false,\n         additional_bounds: bounds,\n         generics: Bounds::empty(),\n         supports_unions: true,"}, {"sha": "eab67b0d354cf7dd18be1b785c514c4debe47517", "filename": "compiler/rustc_builtin_macros/src/deriving/cmp/eq.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Feq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Feq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Feq.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "patch": "@@ -25,6 +25,7 @@ pub fn expand_deriving_eq(\n     let trait_def = TraitDef {\n         span,\n         path: path_std!(cmp::Eq),\n+        skip_path_as_bound: false,\n         additional_bounds: Vec::new(),\n         generics: Bounds::empty(),\n         supports_unions: true,"}, {"sha": "7f117981a9a2fe73fdece52da04079838e815e0f", "filename": "compiler/rustc_builtin_macros/src/deriving/cmp/ord.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Ford.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Ford.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Ford.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "patch": "@@ -19,6 +19,7 @@ pub fn expand_deriving_ord(\n     let trait_def = TraitDef {\n         span,\n         path: path_std!(cmp::Ord),\n+        skip_path_as_bound: false,\n         additional_bounds: Vec::new(),\n         generics: Bounds::empty(),\n         supports_unions: false,"}, {"sha": "236cbccaf9fee6286494c1bfc08173c01f04716f", "filename": "compiler/rustc_builtin_macros/src/deriving/cmp/partial_eq.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Fpartial_eq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Fpartial_eq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Fpartial_eq.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "patch": "@@ -83,6 +83,7 @@ pub fn expand_deriving_partial_eq(\n     let trait_def = TraitDef {\n         span,\n         path: path_std!(cmp::PartialEq),\n+        skip_path_as_bound: false,\n         additional_bounds: Vec::new(),\n         generics: Bounds::empty(),\n         supports_unions: false,"}, {"sha": "4173403a1b84a4f4007d77aae5376ffc3e63a109", "filename": "compiler/rustc_builtin_macros/src/deriving/cmp/partial_ord.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Fpartial_ord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Fpartial_ord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fcmp%2Fpartial_ord.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "patch": "@@ -37,6 +37,7 @@ pub fn expand_deriving_partial_ord(\n     let trait_def = TraitDef {\n         span,\n         path: path_std!(cmp::PartialOrd),\n+        skip_path_as_bound: false,\n         additional_bounds: vec![],\n         generics: Bounds::empty(),\n         supports_unions: false,"}, {"sha": "2cf614ed9476c9435b50d7aaced16f097bb3cc39", "filename": "compiler/rustc_builtin_macros/src/deriving/debug.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdebug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdebug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdebug.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "patch": "@@ -20,6 +20,7 @@ pub fn expand_deriving_debug(\n     let trait_def = TraitDef {\n         span,\n         path: path_std!(fmt::Debug),\n+        skip_path_as_bound: false,\n         additional_bounds: Vec::new(),\n         generics: Bounds::empty(),\n         supports_unions: false,"}, {"sha": "d669f616802feda4bf06d489b3eaf7966977dd1a", "filename": "compiler/rustc_builtin_macros/src/deriving/decodable.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdecodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdecodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdecodable.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "patch": "@@ -23,6 +23,7 @@ pub fn expand_deriving_rustc_decodable(\n     let trait_def = TraitDef {\n         span,\n         path: Path::new_(vec![krate, sym::Decodable], vec![], PathKind::Global),\n+        skip_path_as_bound: false,\n         additional_bounds: Vec::new(),\n         generics: Bounds::empty(),\n         supports_unions: false,"}, {"sha": "17df9fb279ad6b808e57840c5d417e1639d8a144", "filename": "compiler/rustc_builtin_macros/src/deriving/default.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdefault.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdefault.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdefault.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "patch": "@@ -24,6 +24,7 @@ pub fn expand_deriving_default(\n     let trait_def = TraitDef {\n         span,\n         path: Path::new(vec![kw::Default, sym::Default]),\n+        skip_path_as_bound: has_a_default_variant(item),\n         additional_bounds: Vec::new(),\n         generics: Bounds::empty(),\n         supports_unions: false,\n@@ -262,3 +263,22 @@ impl<'a, 'b> rustc_ast::visit::Visitor<'a> for DetectNonVariantDefaultAttr<'a, '\n         }\n     }\n }\n+\n+fn has_a_default_variant(item: &Annotatable) -> bool {\n+    struct HasDefaultAttrOnVariant {\n+        found: bool,\n+    }\n+\n+    impl<'ast> rustc_ast::visit::Visitor<'ast> for HasDefaultAttrOnVariant {\n+        fn visit_variant(&mut self, v: &'ast rustc_ast::Variant) {\n+            if v.attrs.iter().any(|attr| attr.has_name(kw::Default)) {\n+                self.found = true;\n+            }\n+            // no need to subrecurse.\n+        }\n+    }\n+\n+    let mut visitor = HasDefaultAttrOnVariant { found: false };\n+    item.visit_with(&mut visitor);\n+    visitor.found\n+}"}, {"sha": "f83f58b97d38ffb3566af5ad883ca3984e69b2aa", "filename": "compiler/rustc_builtin_macros/src/deriving/encodable.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fencodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fencodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fencodable.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "patch": "@@ -107,6 +107,7 @@ pub fn expand_deriving_rustc_encodable(\n     let trait_def = TraitDef {\n         span,\n         path: Path::new_(vec![krate, sym::Encodable], vec![], PathKind::Global),\n+        skip_path_as_bound: false,\n         additional_bounds: Vec::new(),\n         generics: Bounds::empty(),\n         supports_unions: false,"}, {"sha": "16ee3aa89bb1237967b3a7a16e2c65bd447ca8de", "filename": "compiler/rustc_builtin_macros/src/deriving/generic/mod.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "patch": "@@ -174,6 +174,7 @@ use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_span::Span;\n use std::cell::RefCell;\n use std::iter;\n+use std::ops::Not;\n use std::vec;\n use thin_vec::thin_vec;\n use ty::{Bounds, Path, Ref, Self_, Ty};\n@@ -187,6 +188,9 @@ pub struct TraitDef<'a> {\n     /// Path of the trait, including any type parameters\n     pub path: Path,\n \n+    /// Whether to skip adding the current trait as a bound to the type parameters of the type.\n+    pub skip_path_as_bound: bool,\n+\n     /// Additional bounds required of any type parameters of the type,\n     /// other than the current trait\n     pub additional_bounds: Vec<Ty>,\n@@ -562,7 +566,7 @@ impl<'a> TraitDef<'a> {\n                     tokens: None,\n                 },\n                 attrs: ast::AttrVec::new(),\n-                kind: ast::AssocItemKind::TyAlias(Box::new(ast::TyAlias {\n+                kind: ast::AssocItemKind::Type(Box::new(ast::TyAlias {\n                     defaultness: ast::Defaultness::Final,\n                     generics: Generics::default(),\n                     where_clauses: (\n@@ -596,7 +600,7 @@ impl<'a> TraitDef<'a> {\n                         cx.trait_bound(p.to_path(cx, self.span, type_ident, generics))\n                     }).chain(\n                         // require the current trait\n-                        iter::once(cx.trait_bound(trait_path.clone()))\n+                        self.skip_path_as_bound.not().then(|| cx.trait_bound(trait_path.clone()))\n                     ).chain(\n                         // also add in any bounds from the declaration\n                         param.bounds.iter().cloned()\n@@ -1110,6 +1114,11 @@ impl<'a> MethodDef<'a> {\n     /// ```\n     /// is equivalent to:\n     /// ```\n+    /// #![feature(core_intrinsics)]\n+    /// enum A {\n+    ///     A1,\n+    ///     A2(i32)\n+    /// }\n     /// impl ::core::cmp::PartialEq for A {\n     ///     #[inline]\n     ///     fn eq(&self, other: &A) -> bool {"}, {"sha": "6e9d5f08b9443dd22cc0ec40d828e6070306f405", "filename": "compiler/rustc_builtin_macros/src/deriving/hash.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fhash.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "patch": "@@ -22,6 +22,7 @@ pub fn expand_deriving_hash(\n     let hash_trait_def = TraitDef {\n         span,\n         path,\n+        skip_path_as_bound: false,\n         additional_bounds: Vec::new(),\n         generics: Bounds::empty(),\n         supports_unions: false,"}, {"sha": "ee346047a0bc0c2fb54b7ef50bedd1f9e8ac2a01", "filename": "compiler/rustc_builtin_macros/src/deriving/mod.rs", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fmod.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "patch": "@@ -131,23 +131,27 @@ fn inject_impl_of_structural_trait(\n     // Create generics param list for where clauses and impl headers\n     let mut generics = generics.clone();\n \n+    let ctxt = span.ctxt();\n+\n     // Create the type of `self`.\n     //\n     // in addition, remove defaults from generic params (impls cannot have them).\n     let self_params: Vec<_> = generics\n         .params\n         .iter_mut()\n         .map(|param| match &mut param.kind {\n-            ast::GenericParamKind::Lifetime => {\n-                ast::GenericArg::Lifetime(cx.lifetime(span, param.ident))\n-            }\n+            ast::GenericParamKind::Lifetime => ast::GenericArg::Lifetime(\n+                cx.lifetime(param.ident.span.with_ctxt(ctxt), param.ident),\n+            ),\n             ast::GenericParamKind::Type { default } => {\n                 *default = None;\n-                ast::GenericArg::Type(cx.ty_ident(span, param.ident))\n+                ast::GenericArg::Type(cx.ty_ident(param.ident.span.with_ctxt(ctxt), param.ident))\n             }\n             ast::GenericParamKind::Const { ty: _, kw_span: _, default } => {\n                 *default = None;\n-                ast::GenericArg::Const(cx.const_ident(span, param.ident))\n+                ast::GenericArg::Const(\n+                    cx.const_ident(param.ident.span.with_ctxt(ctxt), param.ident),\n+                )\n             }\n         })\n         .collect();\n@@ -174,6 +178,8 @@ fn inject_impl_of_structural_trait(\n             })\n             .cloned(),\n     );\n+    // Mark as `automatically_derived` to avoid some silly lints.\n+    attrs.push(cx.attribute(cx.meta_word(span, sym::automatically_derived)));\n \n     let newitem = cx.item(\n         span,"}, {"sha": "8b07c110663572175c42f3da08ef5740f1ff639d", "filename": "compiler/rustc_builtin_macros/src/format.rs", "status": "modified", "additions": 638, "deletions": 1311, "changes": 1949, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "patch": "@@ -1,271 +1,42 @@\n-use ArgumentType::*;\n-use Position::*;\n-\n-use rustc_ast as ast;\n use rustc_ast::ptr::P;\n+use rustc_ast::token;\n use rustc_ast::tokenstream::TokenStream;\n-use rustc_ast::visit::{self, Visitor};\n-use rustc_ast::{token, BlockCheckMode, UnsafeSource};\n-use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+use rustc_ast::Expr;\n+use rustc_data_structures::fx::FxHashSet;\n use rustc_errors::{pluralize, Applicability, MultiSpan, PResult};\n use rustc_expand::base::{self, *};\n use rustc_parse_format as parse;\n-use rustc_span::symbol::{sym, Ident, Symbol};\n+use rustc_span::symbol::{Ident, Symbol};\n use rustc_span::{BytePos, InnerSpan, Span};\n-use smallvec::SmallVec;\n \n use rustc_lint_defs::builtin::NAMED_ARGUMENTS_USED_POSITIONALLY;\n use rustc_lint_defs::{BufferedEarlyLint, BuiltinLintDiagnostics, LintId};\n-use rustc_parse_format::Count;\n-use std::borrow::Cow;\n-use std::collections::hash_map::Entry;\n-\n-#[derive(PartialEq)]\n-enum ArgumentType {\n-    Placeholder(&'static str),\n-    Count,\n-}\n-\n-enum Position {\n-    Exact(usize),\n-    Capture(usize),\n-    Named(Symbol, InnerSpan),\n-}\n-\n-/// Indicates how positional named argument (i.e. an named argument which is used by position\n-/// instead of by name) is used in format string\n-/// * `Arg` is the actual argument to print\n-/// * `Width` is width format argument\n-/// * `Precision` is precion format argument\n-/// Example: `{Arg:Width$.Precision$}\n-#[derive(Debug, Eq, PartialEq)]\n-enum PositionalNamedArgType {\n-    Arg,\n-    Width,\n-    Precision,\n-}\n-\n-/// Contains information necessary to create a lint for a positional named argument\n-#[derive(Debug)]\n-struct PositionalNamedArg {\n-    ty: PositionalNamedArgType,\n-    /// The piece of the using this argument (multiple pieces can use the same argument)\n-    cur_piece: usize,\n-    /// The InnerSpan for in the string to be replaced with the named argument\n-    /// This will be None when the position is implicit\n-    inner_span_to_replace: Option<rustc_parse_format::InnerSpan>,\n-    /// The name to use instead of the position\n-    replacement: Symbol,\n-    /// The span for the positional named argument (so the lint can point a message to it)\n-    positional_named_arg_span: Span,\n-    has_formatting: bool,\n-}\n-\n-impl PositionalNamedArg {\n-    /// Determines:\n-    /// 1) span to be replaced with the name of the named argument and\n-    /// 2) span to be underlined for error messages\n-    fn get_positional_arg_spans(&self, cx: &Context<'_, '_>) -> (Option<Span>, Option<Span>) {\n-        if let Some(inner_span) = &self.inner_span_to_replace {\n-            let span =\n-                cx.fmtsp.from_inner(InnerSpan { start: inner_span.start, end: inner_span.end });\n-            (Some(span), Some(span))\n-        } else if self.ty == PositionalNamedArgType::Arg {\n-            // In the case of a named argument whose position is implicit, if the argument *has*\n-            // formatting, there will not be a span to replace. Instead, we insert the name after\n-            // the `{`, which will be the first character of arg_span. If the argument does *not*\n-            // have formatting, there may or may not be a span to replace. This is because\n-            // whitespace is allowed in arguments without formatting (such as `format!(\"{  }\", 1);`)\n-            // but is not allowed in arguments with formatting (an error will be generated in cases\n-            // like `format!(\"{ :1.1}\", 1.0f32);`.\n-            // For the message span, if there is formatting, we want to use the opening `{` and the\n-            // next character, which will the `:` indicating the start of formatting. If there is\n-            // not any formatting, we want to underline the entire span.\n-            cx.arg_spans.get(self.cur_piece).map_or((None, None), |arg_span| {\n-                if self.has_formatting {\n-                    (\n-                        Some(arg_span.with_lo(arg_span.lo() + BytePos(1)).shrink_to_lo()),\n-                        Some(arg_span.with_hi(arg_span.lo() + BytePos(2))),\n-                    )\n-                } else {\n-                    let replace_start = arg_span.lo() + BytePos(1);\n-                    let replace_end = arg_span.hi() - BytePos(1);\n-                    let to_replace = arg_span.with_lo(replace_start).with_hi(replace_end);\n-                    (Some(to_replace), Some(*arg_span))\n-                }\n-            })\n-        } else {\n-            (None, None)\n-        }\n-    }\n-}\n-\n-/// Encapsulates all the named arguments that have been used positionally\n-#[derive(Debug)]\n-struct PositionalNamedArgsLint {\n-    positional_named_args: Vec<PositionalNamedArg>,\n-}\n-\n-impl PositionalNamedArgsLint {\n-    /// For a given positional argument, check if the index is for a named argument.\n-    ///\n-    /// Since positional arguments are required to come before named arguments, if the positional\n-    /// index is greater than or equal to the start of named arguments, we know it's a named\n-    /// argument used positionally.\n-    ///\n-    /// Example:\n-    /// println!(\"{} {} {2}\", 0, a=1, b=2);\n-    ///\n-    /// In this case, the first piece (`{}`) would be ArgumentImplicitlyIs with an index of 0. The\n-    /// total number of arguments is 3 and the number of named arguments is 2, so the start of named\n-    /// arguments is index 1. Therefore, the index of 0 is okay.\n-    ///\n-    /// The second piece (`{}`) would be ArgumentImplicitlyIs with an index of 1, which is the start\n-    /// of named arguments, and so we should add a lint to use the named argument `a`.\n-    ///\n-    /// The third piece (`{2}`) would be ArgumentIs with an index of 2, which is greater than the\n-    /// start of named arguments, and so we should add a lint to use the named argument `b`.\n-    ///\n-    /// This same check also works for width and precision formatting when either or both are\n-    /// CountIsParam, which contains an index into the arguments.\n-    fn maybe_add_positional_named_arg(\n-        &mut self,\n-        arg: Option<&FormatArg>,\n-        ty: PositionalNamedArgType,\n-        cur_piece: usize,\n-        inner_span_to_replace: Option<rustc_parse_format::InnerSpan>,\n-        has_formatting: bool,\n-    ) {\n-        if let Some(arg) = arg {\n-            if let Some(name) = arg.name {\n-                self.push(name, ty, cur_piece, inner_span_to_replace, has_formatting)\n-            }\n-        }\n-    }\n \n-    /// Construct a PositionalNamedArg struct and push it into the vec of positional\n-    /// named arguments.\n-    fn push(\n-        &mut self,\n-        arg_name: Ident,\n-        ty: PositionalNamedArgType,\n-        cur_piece: usize,\n-        inner_span_to_replace: Option<rustc_parse_format::InnerSpan>,\n-        has_formatting: bool,\n-    ) {\n-        // In FormatSpec, `precision_span` starts at the leading `.`, which we want to keep in\n-        // the lint suggestion, so increment `start` by 1 when `PositionalArgumentType` is\n-        // `Precision`.\n-        let inner_span_to_replace = if ty == PositionalNamedArgType::Precision {\n-            inner_span_to_replace\n-                .map(|is| rustc_parse_format::InnerSpan { start: is.start + 1, end: is.end })\n-        } else {\n-            inner_span_to_replace\n-        };\n-        self.positional_named_args.push(PositionalNamedArg {\n-            ty,\n-            cur_piece,\n-            inner_span_to_replace,\n-            replacement: arg_name.name,\n-            positional_named_arg_span: arg_name.span,\n-            has_formatting,\n-        });\n-    }\n-}\n-\n-struct Context<'a, 'b> {\n-    ecx: &'a mut ExtCtxt<'b>,\n-    /// The macro's call site. References to unstable formatting internals must\n-    /// use this span to pass the stability checker.\n-    macsp: Span,\n-    /// The span of the format string literal.\n-    fmtsp: Span,\n-\n-    /// List of parsed argument expressions.\n-    /// Named expressions are resolved early, and are appended to the end of\n-    /// argument expressions.\n-    ///\n-    /// Example showing the various data structures in motion:\n-    ///\n-    /// * Original: `\"{foo:o} {:o} {foo:x} {0:x} {1:o} {:x} {1:x} {0:o}\"`\n-    /// * Implicit argument resolution: `\"{foo:o} {0:o} {foo:x} {0:x} {1:o} {1:x} {1:x} {0:o}\"`\n-    /// * Name resolution: `\"{2:o} {0:o} {2:x} {0:x} {1:o} {1:x} {1:x} {0:o}\"`\n-    /// * `arg_types` (in JSON): `[[0, 1, 0], [0, 1, 1], [0, 1]]`\n-    /// * `arg_unique_types` (in simplified JSON): `[[\"o\", \"x\"], [\"o\", \"x\"], [\"o\", \"x\"]]`\n-    /// * `names` (in JSON): `{\"foo\": 2}`\n-    args: Vec<FormatArg>,\n-    /// The number of arguments that were added by implicit capturing.\n-    num_captured_args: usize,\n-    /// Placeholder slot numbers indexed by argument.\n-    arg_types: Vec<Vec<usize>>,\n-    /// Unique format specs seen for each argument.\n-    arg_unique_types: Vec<Vec<ArgumentType>>,\n-    /// Map from named arguments to their resolved indices.\n-    names: FxHashMap<Symbol, usize>,\n-\n-    /// The latest consecutive literal strings, or empty if there weren't any.\n-    literal: String,\n+mod ast;\n+use ast::*;\n \n-    /// Collection of the compiled `rt::Argument` structures\n-    pieces: Vec<P<ast::Expr>>,\n-    /// Collection of string literals\n-    str_pieces: Vec<P<ast::Expr>>,\n-    /// Stays `true` if all formatting parameters are default (as in \"{}{}\").\n-    all_pieces_simple: bool,\n+mod expand;\n+use expand::expand_parsed_format_args;\n \n-    /// Mapping between positional argument references and indices into the\n-    /// final generated static argument array. We record the starting indices\n-    /// corresponding to each positional argument, and number of references\n-    /// consumed so far for each argument, to facilitate correct `Position`\n-    /// mapping in `build_piece`. In effect this can be seen as a \"flattened\"\n-    /// version of `arg_unique_types`.\n-    ///\n-    /// Again with the example described above in docstring for `args`:\n-    ///\n-    /// * `arg_index_map` (in JSON): `[[0, 1, 0], [2, 3, 3], [4, 5]]`\n-    arg_index_map: Vec<Vec<usize>>,\n+// The format_args!() macro is expanded in three steps:\n+//  1. First, `parse_args` will parse the `(literal, arg, arg, name=arg, name=arg)` syntax,\n+//     but doesn't parse the template (the literal) itself.\n+//  2. Second, `make_format_args` will parse the template, the format options, resolve argument references,\n+//     produce diagnostics, and turn the whole thing into a `FormatArgs` structure.\n+//  3. Finally, `expand_parsed_format_args` will turn that `FormatArgs` structure\n+//     into the expression that the macro expands to.\n \n-    /// Starting offset of count argument slots.\n-    count_args_index_offset: usize,\n+// See format/ast.rs for the FormatArgs structure and glossary.\n \n-    /// Count argument slots and tracking data structures.\n-    /// Count arguments are separately tracked for de-duplication in case\n-    /// multiple references are made to one argument. For example, in this\n-    /// format string:\n-    ///\n-    /// * Original: `\"{:.*} {:.foo$} {1:.*} {:.0$}\"`\n-    /// * Implicit argument resolution: `\"{1:.0$} {2:.foo$} {1:.3$} {4:.0$}\"`\n-    /// * Name resolution: `\"{1:.0$} {2:.5$} {1:.3$} {4:.0$}\"`\n-    /// * `count_positions` (in JSON): `{0: 0, 5: 1, 3: 2}`\n-    /// * `count_args`: `vec![0, 5, 3]`\n-    count_args: Vec<usize>,\n-    /// Relative slot numbers for count arguments.\n-    count_positions: FxHashMap<usize, usize>,\n-    /// Number of count slots assigned.\n-    count_positions_count: usize,\n-\n-    /// Current position of the implicit positional arg pointer, as if it\n-    /// still existed in this phase of processing.\n-    /// Used only for `all_pieces_simple` tracking in `build_piece`.\n-    curarg: usize,\n-    /// Current piece being evaluated, used for error reporting.\n-    curpiece: usize,\n-    /// Keep track of invalid references to positional arguments.\n-    invalid_refs: Vec<(usize, usize)>,\n-    /// Spans of all the formatting arguments, in order.\n-    arg_spans: Vec<Span>,\n-    /// All the formatting arguments that have formatting flags set, in order for diagnostics.\n-    arg_with_formatting: Vec<parse::FormatSpec<'a>>,\n-\n-    /// Whether this format string came from a string literal, as opposed to a macro.\n-    is_literal: bool,\n-    unused_names_lint: PositionalNamedArgsLint,\n-}\n-\n-pub struct FormatArg {\n-    expr: P<ast::Expr>,\n-    name: Option<Ident>,\n+// Only used in parse_args and report_invalid_references,\n+// to indicate how a referred argument was used.\n+#[derive(Clone, Copy, Debug, PartialEq, Eq)]\n+enum PositionUsedAs {\n+    Placeholder(Option<Span>),\n+    Precision,\n+    Width,\n }\n+use PositionUsedAs::*;\n \n /// Parses the arguments from the given list of tokens, returning the diagnostic\n /// if there's a parse error so we can continue parsing other format!\n@@ -274,15 +45,14 @@ pub struct FormatArg {\n /// If parsing succeeds, the return value is:\n ///\n /// ```text\n-/// Some((fmtstr, parsed arguments, index map for named arguments))\n+/// Ok((fmtstr, parsed arguments))\n /// ```\n fn parse_args<'a>(\n     ecx: &mut ExtCtxt<'a>,\n     sp: Span,\n     tts: TokenStream,\n-) -> PResult<'a, (P<ast::Expr>, Vec<FormatArg>, FxHashMap<Symbol, usize>)> {\n-    let mut args = Vec::<FormatArg>::new();\n-    let mut names = FxHashMap::<Symbol, usize>::default();\n+) -> PResult<'a, (P<Expr>, FormatArguments)> {\n+    let mut args = FormatArguments::new();\n \n     let mut p = ecx.new_parser_from_tts(tts);\n \n@@ -311,7 +81,6 @@ fn parse_args<'a>(\n     };\n \n     let mut first = true;\n-    let mut named = false;\n \n     while p.token != token::Eof {\n         if !p.eat(&token::Comma) {\n@@ -343,879 +112,54 @@ fn parse_args<'a>(\n         } // accept trailing commas\n         match p.token.ident() {\n             Some((ident, _)) if p.look_ahead(1, |t| *t == token::Eq) => {\n-                named = true;\n                 p.bump();\n                 p.expect(&token::Eq)?;\n-                let e = p.parse_expr()?;\n-                if let Some(&prev) = names.get(&ident.name) {\n-                    ecx.struct_span_err(e.span, &format!(\"duplicate argument named `{}`\", ident))\n-                        .span_label(args[prev].expr.span, \"previously here\")\n-                        .span_label(e.span, \"duplicate argument\")\n-                        .emit();\n+                let expr = p.parse_expr()?;\n+                if let Some((_, prev)) = args.by_name(ident.name) {\n+                    ecx.struct_span_err(\n+                        ident.span,\n+                        &format!(\"duplicate argument named `{}`\", ident),\n+                    )\n+                    .span_label(prev.kind.ident().unwrap().span, \"previously here\")\n+                    .span_label(ident.span, \"duplicate argument\")\n+                    .emit();\n                     continue;\n                 }\n-\n-                // Resolve names into slots early.\n-                // Since all the positional args are already seen at this point\n-                // if the input is valid, we can simply append to the positional\n-                // args. And remember the names.\n-                let slot = args.len();\n-                names.insert(ident.name, slot);\n-                args.push(FormatArg { expr: e, name: Some(ident) });\n+                args.add(FormatArgument { kind: FormatArgumentKind::Named(ident), expr });\n             }\n             _ => {\n-                let e = p.parse_expr()?;\n-                if named {\n+                let expr = p.parse_expr()?;\n+                if !args.named_args().is_empty() {\n                     let mut err = ecx.struct_span_err(\n-                        e.span,\n+                        expr.span,\n                         \"positional arguments cannot follow named arguments\",\n                     );\n-                    err.span_label(e.span, \"positional arguments must be before named arguments\");\n-                    for &pos in names.values() {\n-                        err.span_label(args[pos].expr.span, \"named argument\");\n+                    err.span_label(\n+                        expr.span,\n+                        \"positional arguments must be before named arguments\",\n+                    );\n+                    for arg in args.named_args() {\n+                        if let Some(name) = arg.kind.ident() {\n+                            err.span_label(name.span.to(arg.expr.span), \"named argument\");\n+                        }\n                     }\n                     err.emit();\n                 }\n-                args.push(FormatArg { expr: e, name: None });\n+                args.add(FormatArgument { kind: FormatArgumentKind::Normal, expr });\n             }\n         }\n     }\n-    Ok((fmtstr, args, names))\n+    Ok((fmtstr, args))\n }\n \n-impl<'a, 'b> Context<'a, 'b> {\n-    /// The number of arguments that were explicitly given.\n-    fn num_args(&self) -> usize {\n-        self.args.len() - self.num_captured_args\n-    }\n-\n-    fn resolve_name_inplace(&mut self, p: &mut parse::Piece<'_>) {\n-        // NOTE: the `unwrap_or` branch is needed in case of invalid format\n-        // arguments, e.g., `format_args!(\"{foo}\")`.\n-        let lookup = |s: &str| self.names.get(&Symbol::intern(s)).copied().unwrap_or(0);\n-\n-        match *p {\n-            parse::String(_) => {}\n-            parse::NextArgument(ref mut arg) => {\n-                if let parse::ArgumentNamed(s) = arg.position {\n-                    arg.position = parse::ArgumentIs(lookup(s));\n-                }\n-                if let parse::CountIsName(s, _) = arg.format.width {\n-                    arg.format.width = parse::CountIsParam(lookup(s));\n-                }\n-                if let parse::CountIsName(s, _) = arg.format.precision {\n-                    arg.format.precision = parse::CountIsParam(lookup(s));\n-                }\n-            }\n-        }\n-    }\n-\n-    /// Verifies one piece of a parse string, and remembers it if valid.\n-    /// All errors are not emitted as fatal so we can continue giving errors\n-    /// about this and possibly other format strings.\n-    fn verify_piece(&mut self, p: &parse::Piece<'a>) {\n-        match *p {\n-            parse::String(..) => {}\n-            parse::NextArgument(ref arg) => {\n-                // width/precision first, if they have implicit positional\n-                // parameters it makes more sense to consume them first.\n-                self.verify_count(\n-                    arg.format.width,\n-                    &arg.format.width_span,\n-                    PositionalNamedArgType::Width,\n-                );\n-                self.verify_count(\n-                    arg.format.precision,\n-                    &arg.format.precision_span,\n-                    PositionalNamedArgType::Precision,\n-                );\n-\n-                let has_precision = arg.format.precision != Count::CountImplied;\n-                let has_width = arg.format.width != Count::CountImplied;\n-\n-                if has_precision || has_width {\n-                    // push before named params are resolved to aid diagnostics\n-                    self.arg_with_formatting.push(arg.format);\n-                }\n-\n-                // argument second, if it's an implicit positional parameter\n-                // it's written second, so it should come after width/precision.\n-                let pos = match arg.position {\n-                    parse::ArgumentIs(i) => {\n-                        self.unused_names_lint.maybe_add_positional_named_arg(\n-                            self.args.get(i),\n-                            PositionalNamedArgType::Arg,\n-                            self.curpiece,\n-                            Some(arg.position_span),\n-                            has_precision || has_width,\n-                        );\n-\n-                        Exact(i)\n-                    }\n-                    parse::ArgumentImplicitlyIs(i) => {\n-                        self.unused_names_lint.maybe_add_positional_named_arg(\n-                            self.args.get(i),\n-                            PositionalNamedArgType::Arg,\n-                            self.curpiece,\n-                            None,\n-                            has_precision || has_width,\n-                        );\n-                        Exact(i)\n-                    }\n-                    parse::ArgumentNamed(s) => {\n-                        let symbol = Symbol::intern(s);\n-                        let span = arg.position_span;\n-                        Named(symbol, InnerSpan::new(span.start, span.end))\n-                    }\n-                };\n-\n-                let ty = Placeholder(match arg.format.ty {\n-                    \"\" => \"Display\",\n-                    \"?\" => \"Debug\",\n-                    \"e\" => \"LowerExp\",\n-                    \"E\" => \"UpperExp\",\n-                    \"o\" => \"Octal\",\n-                    \"p\" => \"Pointer\",\n-                    \"b\" => \"Binary\",\n-                    \"x\" => \"LowerHex\",\n-                    \"X\" => \"UpperHex\",\n-                    _ => {\n-                        let fmtsp = self.fmtsp;\n-                        let sp = arg\n-                            .format\n-                            .ty_span\n-                            .map(|sp| fmtsp.from_inner(InnerSpan::new(sp.start, sp.end)));\n-                        let mut err = self.ecx.struct_span_err(\n-                            sp.unwrap_or(fmtsp),\n-                            &format!(\"unknown format trait `{}`\", arg.format.ty),\n-                        );\n-                        err.note(\n-                            \"the only appropriate formatting traits are:\\n\\\n-                                - ``, which uses the `Display` trait\\n\\\n-                                - `?`, which uses the `Debug` trait\\n\\\n-                                - `e`, which uses the `LowerExp` trait\\n\\\n-                                - `E`, which uses the `UpperExp` trait\\n\\\n-                                - `o`, which uses the `Octal` trait\\n\\\n-                                - `p`, which uses the `Pointer` trait\\n\\\n-                                - `b`, which uses the `Binary` trait\\n\\\n-                                - `x`, which uses the `LowerHex` trait\\n\\\n-                                - `X`, which uses the `UpperHex` trait\",\n-                        );\n-                        if let Some(sp) = sp {\n-                            for (fmt, name) in &[\n-                                (\"\", \"Display\"),\n-                                (\"?\", \"Debug\"),\n-                                (\"e\", \"LowerExp\"),\n-                                (\"E\", \"UpperExp\"),\n-                                (\"o\", \"Octal\"),\n-                                (\"p\", \"Pointer\"),\n-                                (\"b\", \"Binary\"),\n-                                (\"x\", \"LowerHex\"),\n-                                (\"X\", \"UpperHex\"),\n-                            ] {\n-                                // FIXME: rustfix (`run-rustfix`) fails to apply suggestions.\n-                                // > \"Cannot replace slice of data that was already replaced\"\n-                                err.tool_only_span_suggestion(\n-                                    sp,\n-                                    &format!(\"use the `{}` trait\", name),\n-                                    *fmt,\n-                                    Applicability::MaybeIncorrect,\n-                                );\n-                            }\n-                        }\n-                        err.emit();\n-                        \"<invalid>\"\n-                    }\n-                });\n-                self.verify_arg_type(pos, ty);\n-                self.curpiece += 1;\n-            }\n-        }\n-    }\n-\n-    fn verify_count(\n-        &mut self,\n-        c: parse::Count<'_>,\n-        inner_span: &Option<rustc_parse_format::InnerSpan>,\n-        named_arg_type: PositionalNamedArgType,\n-    ) {\n-        match c {\n-            parse::CountImplied | parse::CountIs(..) => {}\n-            parse::CountIsParam(i) | parse::CountIsStar(i) => {\n-                self.unused_names_lint.maybe_add_positional_named_arg(\n-                    self.args.get(i),\n-                    named_arg_type,\n-                    self.curpiece,\n-                    *inner_span,\n-                    true,\n-                );\n-                self.verify_arg_type(Exact(i), Count);\n-            }\n-            parse::CountIsName(s, span) => {\n-                self.verify_arg_type(\n-                    Named(Symbol::intern(s), InnerSpan::new(span.start, span.end)),\n-                    Count,\n-                );\n-            }\n-        }\n-    }\n-\n-    fn describe_num_args(&self) -> Cow<'_, str> {\n-        match self.num_args() {\n-            0 => \"no arguments were given\".into(),\n-            1 => \"there is 1 argument\".into(),\n-            x => format!(\"there are {} arguments\", x).into(),\n-        }\n-    }\n-\n-    /// Handle invalid references to positional arguments. Output different\n-    /// errors for the case where all arguments are positional and for when\n-    /// there are named arguments or numbered positional arguments in the\n-    /// format string.\n-    fn report_invalid_references(&self, numbered_position_args: bool) {\n-        let mut e;\n-        let sp = if !self.arg_spans.is_empty() {\n-            // Point at the formatting arguments.\n-            MultiSpan::from_spans(self.arg_spans.clone())\n-        } else {\n-            MultiSpan::from_span(self.fmtsp)\n-        };\n-        let refs =\n-            self.invalid_refs.iter().map(|(r, pos)| (r.to_string(), self.arg_spans.get(*pos)));\n-\n-        let mut zero_based_note = false;\n-\n-        let count = self.pieces.len()\n-            + self\n-                .arg_with_formatting\n-                .iter()\n-                .filter(|fmt| matches!(fmt.precision, parse::CountIsStar(_)))\n-                .count();\n-        if self.names.is_empty() && !numbered_position_args && count != self.num_args() {\n-            e = self.ecx.struct_span_err(\n-                sp,\n-                &format!(\n-                    \"{} positional argument{} in format string, but {}\",\n-                    count,\n-                    pluralize!(count),\n-                    self.describe_num_args(),\n-                ),\n-            );\n-            for arg in &self.args {\n-                // Point at the arguments that will be formatted.\n-                e.span_label(arg.expr.span, \"\");\n-            }\n-        } else {\n-            let (mut refs, spans): (Vec<_>, Vec<_>) = refs.unzip();\n-            // Avoid `invalid reference to positional arguments 7 and 7 (there is 1 argument)`\n-            // for `println!(\"{7:7$}\", 1);`\n-            refs.sort();\n-            refs.dedup();\n-            let spans: Vec<_> = spans.into_iter().filter_map(|sp| sp.copied()).collect();\n-            let sp = if self.arg_spans.is_empty() || spans.is_empty() {\n-                MultiSpan::from_span(self.fmtsp)\n-            } else {\n-                MultiSpan::from_spans(spans)\n-            };\n-            let arg_list = if refs.len() == 1 {\n-                format!(\"argument {}\", refs[0])\n-            } else {\n-                let reg = refs.pop().unwrap();\n-                format!(\"arguments {head} and {tail}\", head = refs.join(\", \"), tail = reg)\n-            };\n-\n-            e = self.ecx.struct_span_err(\n-                sp,\n-                &format!(\n-                    \"invalid reference to positional {} ({})\",\n-                    arg_list,\n-                    self.describe_num_args()\n-                ),\n-            );\n-            zero_based_note = true;\n-        };\n-\n-        for fmt in &self.arg_with_formatting {\n-            if let Some(span) = fmt.precision_span {\n-                let span = self.fmtsp.from_inner(InnerSpan::new(span.start, span.end));\n-                match fmt.precision {\n-                    parse::CountIsParam(pos) if pos >= self.num_args() => {\n-                        e.span_label(\n-                            span,\n-                            &format!(\n-                                \"this precision flag expects an `usize` argument at position {}, \\\n-                             but {}\",\n-                                pos,\n-                                self.describe_num_args(),\n-                            ),\n-                        );\n-                        zero_based_note = true;\n-                    }\n-                    parse::CountIsStar(pos) => {\n-                        let count = self.pieces.len()\n-                            + self\n-                                .arg_with_formatting\n-                                .iter()\n-                                .filter(|fmt| matches!(fmt.precision, parse::CountIsStar(_)))\n-                                .count();\n-                        e.span_label(\n-                            span,\n-                            &format!(\n-                            \"this precision flag adds an extra required argument at position {}, \\\n-                             which is why there {} expected\",\n-                            pos,\n-                            if count == 1 {\n-                                \"is 1 argument\".to_string()\n-                            } else {\n-                                format!(\"are {} arguments\", count)\n-                            },\n-                        ),\n-                        );\n-                        if let Some(arg) = self.args.get(pos) {\n-                            e.span_label(\n-                                arg.expr.span,\n-                                \"this parameter corresponds to the precision flag\",\n-                            );\n-                        }\n-                        zero_based_note = true;\n-                    }\n-                    _ => {}\n-                }\n-            }\n-            if let Some(span) = fmt.width_span {\n-                let span = self.fmtsp.from_inner(InnerSpan::new(span.start, span.end));\n-                match fmt.width {\n-                    parse::CountIsParam(pos) if pos >= self.num_args() => {\n-                        e.span_label(\n-                            span,\n-                            &format!(\n-                                \"this width flag expects an `usize` argument at position {}, \\\n-                             but {}\",\n-                                pos,\n-                                self.describe_num_args(),\n-                            ),\n-                        );\n-                        zero_based_note = true;\n-                    }\n-                    _ => {}\n-                }\n-            }\n-        }\n-        if zero_based_note {\n-            e.note(\"positional arguments are zero-based\");\n-        }\n-        if !self.arg_with_formatting.is_empty() {\n-            e.note(\n-                \"for information about formatting flags, visit \\\n-                    https://doc.rust-lang.org/std/fmt/index.html\",\n-            );\n-        }\n-\n-        e.emit();\n-    }\n-\n-    /// Actually verifies and tracks a given format placeholder\n-    /// (a.k.a. argument).\n-    fn verify_arg_type(&mut self, arg: Position, ty: ArgumentType) {\n-        if let Exact(arg) = arg {\n-            if arg >= self.num_args() {\n-                self.invalid_refs.push((arg, self.curpiece));\n-                return;\n-            }\n-        }\n-\n-        match arg {\n-            Exact(arg) | Capture(arg) => {\n-                match ty {\n-                    Placeholder(_) => {\n-                        // record every (position, type) combination only once\n-                        let seen_ty = &mut self.arg_unique_types[arg];\n-                        let i = seen_ty.iter().position(|x| *x == ty).unwrap_or_else(|| {\n-                            let i = seen_ty.len();\n-                            seen_ty.push(ty);\n-                            i\n-                        });\n-                        self.arg_types[arg].push(i);\n-                    }\n-                    Count => {\n-                        if let Entry::Vacant(e) = self.count_positions.entry(arg) {\n-                            let i = self.count_positions_count;\n-                            e.insert(i);\n-                            self.count_args.push(arg);\n-                            self.count_positions_count += 1;\n-                        }\n-                    }\n-                }\n-            }\n-\n-            Named(name, span) => {\n-                match self.names.get(&name) {\n-                    Some(&idx) => {\n-                        // Treat as positional arg.\n-                        self.verify_arg_type(Capture(idx), ty)\n-                    }\n-                    None => {\n-                        // For the moment capturing variables from format strings expanded from macros is\n-                        // disabled (see RFC #2795)\n-                        if self.is_literal {\n-                            // Treat this name as a variable to capture from the surrounding scope\n-                            let idx = self.args.len();\n-                            self.arg_types.push(Vec::new());\n-                            self.arg_unique_types.push(Vec::new());\n-                            let span = if self.is_literal {\n-                                self.fmtsp.from_inner(span)\n-                            } else {\n-                                self.fmtsp\n-                            };\n-                            self.num_captured_args += 1;\n-                            self.args.push(FormatArg {\n-                                expr: self.ecx.expr_ident(span, Ident::new(name, span)),\n-                                name: Some(Ident::new(name, span)),\n-                            });\n-                            self.names.insert(name, idx);\n-                            self.verify_arg_type(Capture(idx), ty)\n-                        } else {\n-                            let msg = format!(\"there is no argument named `{}`\", name);\n-                            let sp = if self.is_literal {\n-                                self.fmtsp.from_inner(span)\n-                            } else {\n-                                self.fmtsp\n-                            };\n-                            let mut err = self.ecx.struct_span_err(sp, &msg);\n-\n-                            err.note(&format!(\n-                                \"did you intend to capture a variable `{}` from \\\n-                                 the surrounding scope?\",\n-                                name\n-                            ));\n-                            err.note(\n-                                \"to avoid ambiguity, `format_args!` cannot capture variables \\\n-                                 when the format string is expanded from a macro\",\n-                            );\n-\n-                            err.emit();\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n-    /// Builds the mapping between format placeholders and argument objects.\n-    fn build_index_map(&mut self) {\n-        // NOTE: Keep the ordering the same as `into_expr`'s expansion would do!\n-        let args_len = self.args.len();\n-        self.arg_index_map.reserve(args_len);\n-\n-        let mut sofar = 0usize;\n-\n-        // Map the arguments\n-        for i in 0..args_len {\n-            let arg_types = &self.arg_types[i];\n-            let arg_offsets = arg_types.iter().map(|offset| sofar + *offset).collect::<Vec<_>>();\n-            self.arg_index_map.push(arg_offsets);\n-            sofar += self.arg_unique_types[i].len();\n-        }\n-\n-        // Record starting index for counts, which appear just after arguments\n-        self.count_args_index_offset = sofar;\n-    }\n-\n-    fn rtpath(ecx: &ExtCtxt<'_>, s: Symbol) -> Vec<Ident> {\n-        ecx.std_path(&[sym::fmt, sym::rt, sym::v1, s])\n-    }\n-\n-    fn build_count(&self, c: parse::Count<'_>) -> P<ast::Expr> {\n-        let sp = self.macsp;\n-        let count = |c, arg| {\n-            let mut path = Context::rtpath(self.ecx, sym::Count);\n-            path.push(Ident::new(c, sp));\n-            match arg {\n-                Some(arg) => self.ecx.expr_call_global(sp, path, vec![arg]),\n-                None => self.ecx.expr_path(self.ecx.path_global(sp, path)),\n-            }\n-        };\n-        match c {\n-            parse::CountIs(i) => count(sym::Is, Some(self.ecx.expr_usize(sp, i))),\n-            parse::CountIsParam(i) | parse::CountIsStar(i) => {\n-                // This needs mapping too, as `i` is referring to a macro\n-                // argument. If `i` is not found in `count_positions` then\n-                // the error had already been emitted elsewhere.\n-                let i = self.count_positions.get(&i).cloned().unwrap_or(0)\n-                    + self.count_args_index_offset;\n-                count(sym::Param, Some(self.ecx.expr_usize(sp, i)))\n-            }\n-            parse::CountImplied => count(sym::Implied, None),\n-            // should never be the case, names are already resolved\n-            parse::CountIsName(..) => panic!(\"should never happen\"),\n-        }\n-    }\n-\n-    /// Build a literal expression from the accumulated string literals\n-    fn build_literal_string(&mut self) -> P<ast::Expr> {\n-        let sp = self.fmtsp;\n-        let s = Symbol::intern(&self.literal);\n-        self.literal.clear();\n-        self.ecx.expr_str(sp, s)\n-    }\n-\n-    /// Builds a static `rt::Argument` from a `parse::Piece` or append\n-    /// to the `literal` string.\n-    fn build_piece(\n-        &mut self,\n-        piece: &parse::Piece<'a>,\n-        arg_index_consumed: &mut Vec<usize>,\n-    ) -> Option<P<ast::Expr>> {\n-        let sp = self.macsp;\n-        match *piece {\n-            parse::String(s) => {\n-                self.literal.push_str(s);\n-                None\n-            }\n-            parse::NextArgument(ref arg) => {\n-                // Build the position\n-                let pos = {\n-                    match arg.position {\n-                        parse::ArgumentIs(i, ..) | parse::ArgumentImplicitlyIs(i) => {\n-                            // Map to index in final generated argument array\n-                            // in case of multiple types specified\n-                            let arg_idx = match arg_index_consumed.get_mut(i) {\n-                                None => 0, // error already emitted elsewhere\n-                                Some(offset) => {\n-                                    let idx_map = &self.arg_index_map[i];\n-                                    // unwrap_or branch: error already emitted elsewhere\n-                                    let arg_idx = *idx_map.get(*offset).unwrap_or(&0);\n-                                    *offset += 1;\n-                                    arg_idx\n-                                }\n-                            };\n-                            self.ecx.expr_usize(sp, arg_idx)\n-                        }\n-\n-                        // should never be the case, because names are already\n-                        // resolved.\n-                        parse::ArgumentNamed(..) => panic!(\"should never happen\"),\n-                    }\n-                };\n-\n-                let simple_arg = parse::Argument {\n-                    position: {\n-                        // We don't have ArgumentNext any more, so we have to\n-                        // track the current argument ourselves.\n-                        let i = self.curarg;\n-                        self.curarg += 1;\n-                        parse::ArgumentIs(i)\n-                    },\n-                    position_span: arg.position_span,\n-                    format: parse::FormatSpec {\n-                        fill: None,\n-                        align: parse::AlignUnknown,\n-                        flags: 0,\n-                        precision: parse::CountImplied,\n-                        precision_span: arg.format.precision_span,\n-                        width: parse::CountImplied,\n-                        width_span: arg.format.width_span,\n-                        ty: arg.format.ty,\n-                        ty_span: arg.format.ty_span,\n-                    },\n-                };\n-\n-                let fill = arg.format.fill.unwrap_or(' ');\n-                let pos_simple = arg.position.index() == simple_arg.position.index();\n-\n-                if !pos_simple || arg.format != simple_arg.format {\n-                    self.all_pieces_simple = false;\n-                }\n-\n-                // Build the format\n-                let fill = self.ecx.expr_char(sp, fill);\n-                let align = |name| {\n-                    let mut p = Context::rtpath(self.ecx, sym::Alignment);\n-                    p.push(Ident::new(name, sp));\n-                    self.ecx.path_global(sp, p)\n-                };\n-                let align = match arg.format.align {\n-                    parse::AlignLeft => align(sym::Left),\n-                    parse::AlignRight => align(sym::Right),\n-                    parse::AlignCenter => align(sym::Center),\n-                    parse::AlignUnknown => align(sym::Unknown),\n-                };\n-                let align = self.ecx.expr_path(align);\n-                let flags = self.ecx.expr_u32(sp, arg.format.flags);\n-                let prec = self.build_count(arg.format.precision);\n-                let width = self.build_count(arg.format.width);\n-                let path = self.ecx.path_global(sp, Context::rtpath(self.ecx, sym::FormatSpec));\n-                let fmt = self.ecx.expr_struct(\n-                    sp,\n-                    path,\n-                    vec![\n-                        self.ecx.field_imm(sp, Ident::new(sym::fill, sp), fill),\n-                        self.ecx.field_imm(sp, Ident::new(sym::align, sp), align),\n-                        self.ecx.field_imm(sp, Ident::new(sym::flags, sp), flags),\n-                        self.ecx.field_imm(sp, Ident::new(sym::precision, sp), prec),\n-                        self.ecx.field_imm(sp, Ident::new(sym::width, sp), width),\n-                    ],\n-                );\n-\n-                let path = self.ecx.path_global(sp, Context::rtpath(self.ecx, sym::Argument));\n-                Some(self.ecx.expr_struct(\n-                    sp,\n-                    path,\n-                    vec![\n-                        self.ecx.field_imm(sp, Ident::new(sym::position, sp), pos),\n-                        self.ecx.field_imm(sp, Ident::new(sym::format, sp), fmt),\n-                    ],\n-                ))\n-            }\n-        }\n-    }\n-\n-    /// Actually builds the expression which the format_args! block will be\n-    /// expanded to.\n-    fn into_expr(self) -> P<ast::Expr> {\n-        let mut original_args = self.args;\n-        let mut fmt_args = Vec::with_capacity(\n-            self.arg_unique_types.iter().map(|v| v.len()).sum::<usize>() + self.count_args.len(),\n-        );\n-\n-        // First, build up the static array which will become our precompiled\n-        // format \"string\"\n-        let pieces = self.ecx.expr_array_ref(self.fmtsp, self.str_pieces);\n-\n-        // We need to construct a &[ArgumentV1] to pass into the fmt::Arguments\n-        // constructor. In general the expressions in this slice might be\n-        // permuted from their order in original_args (such as in the case of\n-        // \"{1} {0}\"), or may have multiple entries referring to the same\n-        // element of original_args (\"{0} {0}\").\n-        //\n-        // The following vector has one item per element of our output slice,\n-        // identifying the index of which element of original_args it's passing,\n-        // and that argument's type.\n-        let mut fmt_arg_index_and_ty = SmallVec::<[(usize, &ArgumentType); 8]>::new();\n-        for (i, unique_types) in self.arg_unique_types.iter().enumerate() {\n-            fmt_arg_index_and_ty.extend(unique_types.iter().map(|ty| (i, ty)));\n-        }\n-        fmt_arg_index_and_ty.extend(self.count_args.iter().map(|&i| (i, &Count)));\n-\n-        // Figure out whether there are permuted or repeated elements. If not,\n-        // we can generate simpler code.\n-        //\n-        // The sequence has no indices out of order or repeated if: for every\n-        // adjacent pair of elements, the first one's index is less than the\n-        // second one's index.\n-        let nicely_ordered =\n-            fmt_arg_index_and_ty.array_windows().all(|[(i, _i_ty), (j, _j_ty)]| i < j);\n-\n-        // We want to emit:\n-        //\n-        //     [ArgumentV1::new(&$arg0, \u2026), ArgumentV1::new(&$arg1, \u2026), \u2026]\n-        //\n-        // However, it's only legal to do so if $arg0, $arg1, \u2026 were written in\n-        // exactly that order by the programmer. When arguments are permuted, we\n-        // want them evaluated in the order written by the programmer, not in\n-        // the order provided to fmt::Arguments. When arguments are repeated, we\n-        // want the expression evaluated only once.\n-        //\n-        // Further, if any arg _after the first one_ contains a yield point such\n-        // as `await` or `yield`, the above short form is inconvenient for the\n-        // caller because it would keep a temporary of type ArgumentV1 alive\n-        // across the yield point. ArgumentV1 can't implement Send since it\n-        // holds a type-erased arbitrary type.\n-        //\n-        // Thus in the not nicely ordered case, and in the yielding case, we\n-        // emit the following instead:\n-        //\n-        //     match (&$arg0, &$arg1, \u2026) {\n-        //         args => [ArgumentV1::new(args.$i, \u2026), ArgumentV1::new(args.$j, \u2026), \u2026]\n-        //     }\n-        //\n-        // for the sequence of indices $i, $j, \u2026 governed by fmt_arg_index_and_ty.\n-        // This more verbose representation ensures that all arguments are\n-        // evaluated a single time each, in the order written by the programmer,\n-        // and that the surrounding future/generator (if any) is Send whenever\n-        // possible.\n-        let no_need_for_match = nicely_ordered\n-            && !original_args.iter().skip(1).any(|arg| may_contain_yield_point(&arg.expr));\n-\n-        for (arg_index, arg_ty) in fmt_arg_index_and_ty {\n-            let e = &mut original_args[arg_index].expr;\n-            let span = e.span;\n-            let arg = if no_need_for_match {\n-                let expansion_span = e.span.with_ctxt(self.macsp.ctxt());\n-                // The indices are strictly ordered so e has not been taken yet.\n-                self.ecx.expr_addr_of(expansion_span, P(e.take()))\n-            } else {\n-                let def_site = self.ecx.with_def_site_ctxt(span);\n-                let args_tuple = self.ecx.expr_ident(def_site, Ident::new(sym::args, def_site));\n-                let member = Ident::new(sym::integer(arg_index), def_site);\n-                self.ecx.expr(def_site, ast::ExprKind::Field(args_tuple, member))\n-            };\n-            fmt_args.push(Context::format_arg(self.ecx, self.macsp, span, arg_ty, arg));\n-        }\n-\n-        let args_array = self.ecx.expr_array(self.macsp, fmt_args);\n-        let args_slice = self.ecx.expr_addr_of(\n-            self.macsp,\n-            if no_need_for_match {\n-                args_array\n-            } else {\n-                // In the !no_need_for_match case, none of the exprs were moved\n-                // away in the previous loop.\n-                //\n-                // This uses the arg span for `&arg` so that borrowck errors\n-                // point to the specific expression passed to the macro (the\n-                // span is otherwise unavailable in the MIR used by borrowck).\n-                let heads = original_args\n-                    .into_iter()\n-                    .map(|arg| {\n-                        self.ecx.expr_addr_of(arg.expr.span.with_ctxt(self.macsp.ctxt()), arg.expr)\n-                    })\n-                    .collect();\n-\n-                let pat = self.ecx.pat_ident(self.macsp, Ident::new(sym::args, self.macsp));\n-                let arm = self.ecx.arm(self.macsp, pat, args_array);\n-                let head = self.ecx.expr(self.macsp, ast::ExprKind::Tup(heads));\n-                self.ecx.expr_match(self.macsp, head, vec![arm])\n-            },\n-        );\n-\n-        // Now create the fmt::Arguments struct with all our locals we created.\n-        let (fn_name, fn_args) = if self.all_pieces_simple {\n-            (\"new_v1\", vec![pieces, args_slice])\n-        } else {\n-            // Build up the static array which will store our precompiled\n-            // nonstandard placeholders, if there are any.\n-            let fmt = self.ecx.expr_array_ref(self.macsp, self.pieces);\n-\n-            let path = self.ecx.std_path(&[sym::fmt, sym::UnsafeArg, sym::new]);\n-            let unsafe_arg = self.ecx.expr_call_global(self.macsp, path, Vec::new());\n-            let unsafe_expr = self.ecx.expr_block(P(ast::Block {\n-                stmts: vec![self.ecx.stmt_expr(unsafe_arg)],\n-                id: ast::DUMMY_NODE_ID,\n-                rules: BlockCheckMode::Unsafe(UnsafeSource::CompilerGenerated),\n-                span: self.macsp,\n-                tokens: None,\n-                could_be_bare_literal: false,\n-            }));\n-\n-            (\"new_v1_formatted\", vec![pieces, args_slice, fmt, unsafe_expr])\n-        };\n-\n-        let path = self.ecx.std_path(&[sym::fmt, sym::Arguments, Symbol::intern(fn_name)]);\n-        self.ecx.expr_call_global(self.macsp, path, fn_args)\n-    }\n-\n-    fn format_arg(\n-        ecx: &ExtCtxt<'_>,\n-        macsp: Span,\n-        mut sp: Span,\n-        ty: &ArgumentType,\n-        arg: P<ast::Expr>,\n-    ) -> P<ast::Expr> {\n-        sp = ecx.with_def_site_ctxt(sp);\n-        let trait_ = match *ty {\n-            Placeholder(trait_) if trait_ == \"<invalid>\" => return DummyResult::raw_expr(sp, true),\n-            Placeholder(trait_) => trait_,\n-            Count => {\n-                let path = ecx.std_path(&[sym::fmt, sym::ArgumentV1, sym::from_usize]);\n-                return ecx.expr_call_global(macsp, path, vec![arg]);\n-            }\n-        };\n-        let new_fn_name = match trait_ {\n-            \"Display\" => \"new_display\",\n-            \"Debug\" => \"new_debug\",\n-            \"LowerExp\" => \"new_lower_exp\",\n-            \"UpperExp\" => \"new_upper_exp\",\n-            \"Octal\" => \"new_octal\",\n-            \"Pointer\" => \"new_pointer\",\n-            \"Binary\" => \"new_binary\",\n-            \"LowerHex\" => \"new_lower_hex\",\n-            \"UpperHex\" => \"new_upper_hex\",\n-            _ => unreachable!(),\n-        };\n-\n-        let path = ecx.std_path(&[sym::fmt, sym::ArgumentV1, Symbol::intern(new_fn_name)]);\n-        ecx.expr_call_global(sp, path, vec![arg])\n-    }\n-}\n-\n-fn expand_format_args_impl<'cx>(\n-    ecx: &'cx mut ExtCtxt<'_>,\n-    mut sp: Span,\n-    tts: TokenStream,\n-    nl: bool,\n-) -> Box<dyn base::MacResult + 'cx> {\n-    sp = ecx.with_def_site_ctxt(sp);\n-    match parse_args(ecx, sp, tts) {\n-        Ok((efmt, args, names)) => {\n-            MacEager::expr(expand_preparsed_format_args(ecx, sp, efmt, args, names, nl))\n-        }\n-        Err(mut err) => {\n-            err.emit();\n-            DummyResult::any(sp)\n-        }\n-    }\n-}\n-\n-pub fn expand_format_args<'cx>(\n-    ecx: &'cx mut ExtCtxt<'_>,\n-    sp: Span,\n-    tts: TokenStream,\n-) -> Box<dyn base::MacResult + 'cx> {\n-    expand_format_args_impl(ecx, sp, tts, false)\n-}\n-\n-pub fn expand_format_args_nl<'cx>(\n-    ecx: &'cx mut ExtCtxt<'_>,\n-    sp: Span,\n-    tts: TokenStream,\n-) -> Box<dyn base::MacResult + 'cx> {\n-    expand_format_args_impl(ecx, sp, tts, true)\n-}\n-\n-fn create_lints_for_named_arguments_used_positionally(cx: &mut Context<'_, '_>) {\n-    for named_arg in &cx.unused_names_lint.positional_named_args {\n-        let (position_sp_to_replace, position_sp_for_msg) = named_arg.get_positional_arg_spans(cx);\n-\n-        let msg = format!(\"named argument `{}` is not used by name\", named_arg.replacement);\n-\n-        cx.ecx.buffered_early_lint.push(BufferedEarlyLint {\n-            span: MultiSpan::from_span(named_arg.positional_named_arg_span),\n-            msg: msg.into(),\n-            node_id: ast::CRATE_NODE_ID,\n-            lint_id: LintId::of(&NAMED_ARGUMENTS_USED_POSITIONALLY),\n-            diagnostic: BuiltinLintDiagnostics::NamedArgumentUsedPositionally {\n-                position_sp_to_replace,\n-                position_sp_for_msg,\n-                named_arg_sp: named_arg.positional_named_arg_span,\n-                named_arg_name: named_arg.replacement.to_string(),\n-                is_formatting_arg: named_arg.ty != PositionalNamedArgType::Arg,\n-            },\n-        });\n-    }\n-}\n-\n-/// Take the various parts of `format_args!(efmt, args..., name=names...)`\n-/// and construct the appropriate formatting expression.\n-pub fn expand_preparsed_format_args(\n+pub fn make_format_args(\n     ecx: &mut ExtCtxt<'_>,\n-    sp: Span,\n-    efmt: P<ast::Expr>,\n-    args: Vec<FormatArg>,\n-    names: FxHashMap<Symbol, usize>,\n+    efmt: P<Expr>,\n+    mut args: FormatArguments,\n     append_newline: bool,\n-) -> P<ast::Expr> {\n-    // NOTE: this verbose way of initializing `Vec<Vec<ArgumentType>>` is because\n-    // `ArgumentType` does not derive `Clone`.\n-    let arg_types: Vec<_> = (0..args.len()).map(|_| Vec::new()).collect();\n-    let arg_unique_types: Vec<_> = (0..args.len()).map(|_| Vec::new()).collect();\n-\n-    let mut macsp = ecx.call_site();\n-    macsp = ecx.with_def_site_ctxt(macsp);\n-\n+) -> Result<FormatArgs, ()> {\n     let msg = \"format argument must be a string literal\";\n-    let fmt_sp = efmt.span;\n-    let efmt_kind_is_lit: bool = matches!(efmt.kind, ast::ExprKind::Lit(_));\n+    let unexpanded_fmt_span = efmt.span;\n     let (fmt_str, fmt_style, fmt_span) = match expr_to_spanned_string(ecx, efmt, msg) {\n         Ok(mut fmt) if append_newline => {\n             fmt.0 = Symbol::intern(&format!(\"{}\\n\", fmt.0));\n@@ -1224,31 +168,31 @@ pub fn expand_preparsed_format_args(\n         Ok(fmt) => fmt,\n         Err(err) => {\n             if let Some((mut err, suggested)) = err {\n-                let sugg_fmt = match args.len() {\n+                let sugg_fmt = match args.explicit_args().len() {\n                     0 => \"{}\".to_string(),\n-                    _ => format!(\"{}{{}}\", \"{} \".repeat(args.len())),\n+                    _ => format!(\"{}{{}}\", \"{} \".repeat(args.explicit_args().len())),\n                 };\n                 if !suggested {\n                     err.span_suggestion(\n-                        fmt_sp.shrink_to_lo(),\n+                        unexpanded_fmt_span.shrink_to_lo(),\n                         \"you might be missing a string literal to format with\",\n                         format!(\"\\\"{}\\\", \", sugg_fmt),\n                         Applicability::MaybeIncorrect,\n                     );\n                 }\n                 err.emit();\n             }\n-            return DummyResult::raw_expr(sp, true);\n+            return Err(());\n         }\n     };\n \n     let str_style = match fmt_style {\n-        ast::StrStyle::Cooked => None,\n-        ast::StrStyle::Raw(raw) => Some(raw as usize),\n+        rustc_ast::StrStyle::Cooked => None,\n+        rustc_ast::StrStyle::Raw(raw) => Some(raw as usize),\n     };\n \n     let fmt_str = fmt_str.as_str(); // for the suggestions below\n-    let fmt_snippet = ecx.source_map().span_to_snippet(fmt_sp).ok();\n+    let fmt_snippet = ecx.source_map().span_to_snippet(unexpanded_fmt_span).ok();\n     let mut parser = parse::Parser::new(\n         fmt_str,\n         str_style,\n@@ -1257,18 +201,20 @@ pub fn expand_preparsed_format_args(\n         parse::ParseMode::Format,\n     );\n \n-    let mut unverified_pieces = Vec::new();\n+    let mut pieces = Vec::new();\n     while let Some(piece) = parser.next() {\n         if !parser.errors.is_empty() {\n             break;\n         } else {\n-            unverified_pieces.push(piece);\n+            pieces.push(piece);\n         }\n     }\n \n+    let is_literal = parser.is_literal;\n+\n     if !parser.errors.is_empty() {\n         let err = parser.errors.remove(0);\n-        let sp = if efmt_kind_is_lit {\n+        let sp = if is_literal {\n             fmt_span.from_inner(InnerSpan::new(err.span.start, err.span.end))\n         } else {\n             // The format string could be another macro invocation, e.g.:\n@@ -1286,267 +232,648 @@ pub fn expand_preparsed_format_args(\n         if let Some(note) = err.note {\n             e.note(&note);\n         }\n-        if let Some((label, span)) = err.secondary_label {\n-            if efmt_kind_is_lit {\n-                e.span_label(fmt_span.from_inner(InnerSpan::new(span.start, span.end)), label);\n-            }\n+        if let Some((label, span)) = err.secondary_label && is_literal {\n+            e.span_label(fmt_span.from_inner(InnerSpan::new(span.start, span.end)), label);\n         }\n         if err.should_be_replaced_with_positional_argument {\n             let captured_arg_span =\n                 fmt_span.from_inner(InnerSpan::new(err.span.start, err.span.end));\n-            let n_positional_args =\n-                args.iter().rposition(|arg| arg.name.is_none()).map_or(0, |i| i + 1);\n             if let Ok(arg) = ecx.source_map().span_to_snippet(captured_arg_span) {\n-                let span = match args[..n_positional_args].last() {\n+                let span = match args.unnamed_args().last() {\n                     Some(arg) => arg.expr.span,\n-                    None => fmt_sp,\n+                    None => fmt_span,\n                 };\n                 e.multipart_suggestion_verbose(\n                     \"consider using a positional formatting argument instead\",\n                     vec![\n-                        (captured_arg_span, n_positional_args.to_string()),\n+                        (captured_arg_span, args.unnamed_args().len().to_string()),\n                         (span.shrink_to_hi(), format!(\", {}\", arg)),\n                     ],\n                     Applicability::MachineApplicable,\n                 );\n             }\n         }\n         e.emit();\n-        return DummyResult::raw_expr(sp, true);\n+        return Err(());\n     }\n \n-    let arg_spans = parser\n-        .arg_places\n-        .iter()\n-        .map(|span| fmt_span.from_inner(InnerSpan::new(span.start, span.end)))\n-        .collect();\n+    let to_span = |inner_span: rustc_parse_format::InnerSpan| {\n+        is_literal.then(|| {\n+            fmt_span.from_inner(InnerSpan { start: inner_span.start, end: inner_span.end })\n+        })\n+    };\n+\n+    let mut used = vec![false; args.explicit_args().len()];\n+    let mut invalid_refs = Vec::new();\n+    let mut numeric_refences_to_named_arg = Vec::new();\n \n-    let mut cx = Context {\n-        ecx,\n-        args,\n-        num_captured_args: 0,\n-        arg_types,\n-        arg_unique_types,\n-        names,\n-        curarg: 0,\n-        curpiece: 0,\n-        arg_index_map: Vec::new(),\n-        count_args: Vec::new(),\n-        count_positions: FxHashMap::default(),\n-        count_positions_count: 0,\n-        count_args_index_offset: 0,\n-        literal: String::new(),\n-        pieces: Vec::with_capacity(unverified_pieces.len()),\n-        str_pieces: Vec::with_capacity(unverified_pieces.len()),\n-        all_pieces_simple: true,\n-        macsp,\n-        fmtsp: fmt_span,\n-        invalid_refs: Vec::new(),\n-        arg_spans,\n-        arg_with_formatting: Vec::new(),\n-        is_literal: parser.is_literal,\n-        unused_names_lint: PositionalNamedArgsLint { positional_named_args: vec![] },\n+    enum ArgRef<'a> {\n+        Index(usize),\n+        Name(&'a str, Option<Span>),\n+    }\n+    use ArgRef::*;\n+\n+    let mut lookup_arg = |arg: ArgRef<'_>,\n+                          span: Option<Span>,\n+                          used_as: PositionUsedAs,\n+                          kind: FormatArgPositionKind|\n+     -> FormatArgPosition {\n+        let index = match arg {\n+            Index(index) => {\n+                if let Some(arg) = args.by_index(index) {\n+                    used[index] = true;\n+                    if arg.kind.ident().is_some() {\n+                        // This was a named argument, but it was used as a positional argument.\n+                        numeric_refences_to_named_arg.push((index, span, used_as));\n+                    }\n+                    Ok(index)\n+                } else {\n+                    // Doesn't exist as an explicit argument.\n+                    invalid_refs.push((index, span, used_as, kind));\n+                    Err(index)\n+                }\n+            }\n+            Name(name, span) => {\n+                let name = Symbol::intern(name);\n+                if let Some((index, _)) = args.by_name(name) {\n+                    // Name found in `args`, so we resolve it to its index.\n+                    if index < args.explicit_args().len() {\n+                        // Mark it as used, if it was an explicit argument.\n+                        used[index] = true;\n+                    }\n+                    Ok(index)\n+                } else {\n+                    // Name not found in `args`, so we add it as an implicitly captured argument.\n+                    let span = span.unwrap_or(fmt_span);\n+                    let ident = Ident::new(name, span);\n+                    let expr = if is_literal {\n+                        ecx.expr_ident(span, ident)\n+                    } else {\n+                        // For the moment capturing variables from format strings expanded from macros is\n+                        // disabled (see RFC #2795)\n+                        ecx.struct_span_err(span, &format!(\"there is no argument named `{name}`\"))\n+                            .note(format!(\"did you intend to capture a variable `{name}` from the surrounding scope?\"))\n+                            .note(\"to avoid ambiguity, `format_args!` cannot capture variables when the format string is expanded from a macro\")\n+                            .emit();\n+                        DummyResult::raw_expr(span, true)\n+                    };\n+                    Ok(args.add(FormatArgument { kind: FormatArgumentKind::Captured(ident), expr }))\n+                }\n+            }\n+        };\n+        FormatArgPosition { index, kind, span }\n     };\n \n-    // This needs to happen *after* the Parser has consumed all pieces to create all the spans\n-    let pieces = unverified_pieces\n-        .into_iter()\n-        .map(|mut piece| {\n-            cx.verify_piece(&piece);\n-            cx.resolve_name_inplace(&mut piece);\n-            piece\n-        })\n-        .collect::<Vec<_>>();\n+    let mut template = Vec::new();\n+    let mut unfinished_literal = String::new();\n+    let mut placeholder_index = 0;\n \n-    let numbered_position_args = pieces.iter().any(|arg: &parse::Piece<'_>| match *arg {\n-        parse::String(_) => false,\n-        parse::NextArgument(arg) => matches!(arg.position, parse::Position::ArgumentIs(..)),\n-    });\n+    for piece in pieces {\n+        match piece {\n+            parse::Piece::String(s) => {\n+                unfinished_literal.push_str(s);\n+            }\n+            parse::Piece::NextArgument(parse::Argument { position, position_span, format }) => {\n+                if !unfinished_literal.is_empty() {\n+                    template.push(FormatArgsPiece::Literal(Symbol::intern(&unfinished_literal)));\n+                    unfinished_literal.clear();\n+                }\n \n-    cx.build_index_map();\n+                let span = parser.arg_places.get(placeholder_index).and_then(|&s| to_span(s));\n+                placeholder_index += 1;\n+\n+                let position_span = to_span(position_span);\n+                let argument = match position {\n+                    parse::ArgumentImplicitlyIs(i) => lookup_arg(\n+                        Index(i),\n+                        position_span,\n+                        Placeholder(span),\n+                        FormatArgPositionKind::Implicit,\n+                    ),\n+                    parse::ArgumentIs(i) => lookup_arg(\n+                        Index(i),\n+                        position_span,\n+                        Placeholder(span),\n+                        FormatArgPositionKind::Number,\n+                    ),\n+                    parse::ArgumentNamed(name) => lookup_arg(\n+                        Name(name, position_span),\n+                        position_span,\n+                        Placeholder(span),\n+                        FormatArgPositionKind::Named,\n+                    ),\n+                };\n \n-    let mut arg_index_consumed = vec![0usize; cx.arg_index_map.len()];\n+                let alignment = match format.align {\n+                    parse::AlignUnknown => None,\n+                    parse::AlignLeft => Some(FormatAlignment::Left),\n+                    parse::AlignRight => Some(FormatAlignment::Right),\n+                    parse::AlignCenter => Some(FormatAlignment::Center),\n+                };\n \n-    for piece in pieces {\n-        if let Some(piece) = cx.build_piece(&piece, &mut arg_index_consumed) {\n-            let s = cx.build_literal_string();\n-            cx.str_pieces.push(s);\n-            cx.pieces.push(piece);\n+                let format_trait = match format.ty {\n+                    \"\" => FormatTrait::Display,\n+                    \"?\" => FormatTrait::Debug,\n+                    \"e\" => FormatTrait::LowerExp,\n+                    \"E\" => FormatTrait::UpperExp,\n+                    \"o\" => FormatTrait::Octal,\n+                    \"p\" => FormatTrait::Pointer,\n+                    \"b\" => FormatTrait::Binary,\n+                    \"x\" => FormatTrait::LowerHex,\n+                    \"X\" => FormatTrait::UpperHex,\n+                    _ => {\n+                        invalid_placeholder_type_error(ecx, format.ty, format.ty_span, fmt_span);\n+                        FormatTrait::Display\n+                    }\n+                };\n+\n+                let precision_span = format.precision_span.and_then(to_span);\n+                let precision = match format.precision {\n+                    parse::CountIs(n) => Some(FormatCount::Literal(n)),\n+                    parse::CountIsName(name, name_span) => Some(FormatCount::Argument(lookup_arg(\n+                        Name(name, to_span(name_span)),\n+                        precision_span,\n+                        Precision,\n+                        FormatArgPositionKind::Named,\n+                    ))),\n+                    parse::CountIsParam(i) => Some(FormatCount::Argument(lookup_arg(\n+                        Index(i),\n+                        precision_span,\n+                        Precision,\n+                        FormatArgPositionKind::Number,\n+                    ))),\n+                    parse::CountIsStar(i) => Some(FormatCount::Argument(lookup_arg(\n+                        Index(i),\n+                        precision_span,\n+                        Precision,\n+                        FormatArgPositionKind::Implicit,\n+                    ))),\n+                    parse::CountImplied => None,\n+                };\n+\n+                let width_span = format.width_span.and_then(to_span);\n+                let width = match format.width {\n+                    parse::CountIs(n) => Some(FormatCount::Literal(n)),\n+                    parse::CountIsName(name, name_span) => Some(FormatCount::Argument(lookup_arg(\n+                        Name(name, to_span(name_span)),\n+                        width_span,\n+                        Width,\n+                        FormatArgPositionKind::Named,\n+                    ))),\n+                    parse::CountIsParam(i) => Some(FormatCount::Argument(lookup_arg(\n+                        Index(i),\n+                        width_span,\n+                        Width,\n+                        FormatArgPositionKind::Number,\n+                    ))),\n+                    parse::CountIsStar(_) => unreachable!(),\n+                    parse::CountImplied => None,\n+                };\n+\n+                template.push(FormatArgsPiece::Placeholder(FormatPlaceholder {\n+                    argument,\n+                    span,\n+                    format_trait,\n+                    format_options: FormatOptions {\n+                        fill: format.fill,\n+                        alignment,\n+                        flags: format.flags,\n+                        precision,\n+                        width,\n+                    },\n+                }));\n+            }\n         }\n     }\n \n-    if !cx.literal.is_empty() {\n-        let s = cx.build_literal_string();\n-        cx.str_pieces.push(s);\n+    if !unfinished_literal.is_empty() {\n+        template.push(FormatArgsPiece::Literal(Symbol::intern(&unfinished_literal)));\n     }\n \n-    if !cx.invalid_refs.is_empty() {\n-        cx.report_invalid_references(numbered_position_args);\n+    if !invalid_refs.is_empty() {\n+        report_invalid_references(ecx, &invalid_refs, &template, fmt_span, &args, parser);\n     }\n \n-    // Make sure that all arguments were used and all arguments have types.\n-    let errs = cx\n-        .arg_types\n+    let unused = used\n         .iter()\n         .enumerate()\n-        .filter(|(i, ty)| ty.is_empty() && !cx.count_positions.contains_key(&i))\n+        .filter(|&(_, used)| !used)\n         .map(|(i, _)| {\n-            let msg = if cx.args[i].name.is_some() {\n+            let msg = if let FormatArgumentKind::Named(_) = args.explicit_args()[i].kind {\n                 \"named argument never used\"\n             } else {\n                 \"argument never used\"\n             };\n-            (cx.args[i].expr.span, msg)\n+            (args.explicit_args()[i].expr.span, msg)\n         })\n         .collect::<Vec<_>>();\n \n-    let errs_len = errs.len();\n-    if !errs.is_empty() {\n-        let args_used = cx.arg_types.len() - errs_len;\n-        let args_unused = errs_len;\n+    if !unused.is_empty() {\n+        // If there's a lot of unused arguments,\n+        // let's check if this format arguments looks like another syntax (printf / shell).\n+        let detect_foreign_fmt = unused.len() > args.explicit_args().len() / 2;\n+        report_missing_placeholders(ecx, unused, detect_foreign_fmt, str_style, fmt_str, fmt_span);\n+    }\n \n-        let mut diag = {\n-            if let [(sp, msg)] = &errs[..] {\n-                let mut diag = cx.ecx.struct_span_err(*sp, *msg);\n-                diag.span_label(*sp, *msg);\n-                diag\n-            } else {\n-                let mut diag = cx.ecx.struct_span_err(\n-                    errs.iter().map(|&(sp, _)| sp).collect::<Vec<Span>>(),\n-                    \"multiple unused formatting arguments\",\n-                );\n-                diag.span_label(cx.fmtsp, \"multiple missing formatting specifiers\");\n-                for (sp, msg) in errs {\n-                    diag.span_label(sp, msg);\n+    // Only check for unused named argument names if there are no other errors to avoid causing\n+    // too much noise in output errors, such as when a named argument is entirely unused.\n+    if invalid_refs.is_empty() && ecx.sess.err_count() == 0 {\n+        for &(index, span, used_as) in &numeric_refences_to_named_arg {\n+            let (position_sp_to_replace, position_sp_for_msg) = match used_as {\n+                Placeholder(pspan) => (span, pspan),\n+                Precision => {\n+                    // Strip the leading `.` for precision.\n+                    let span = span.map(|span| span.with_lo(span.lo() + BytePos(1)));\n+                    (span, span)\n                 }\n-                diag\n-            }\n-        };\n+                Width => (span, span),\n+            };\n+            let arg_name = args.explicit_args()[index].kind.ident().unwrap();\n+            ecx.buffered_early_lint.push(BufferedEarlyLint {\n+                span: arg_name.span.into(),\n+                msg: format!(\"named argument `{}` is not used by name\", arg_name.name).into(),\n+                node_id: rustc_ast::CRATE_NODE_ID,\n+                lint_id: LintId::of(&NAMED_ARGUMENTS_USED_POSITIONALLY),\n+                diagnostic: BuiltinLintDiagnostics::NamedArgumentUsedPositionally {\n+                    position_sp_to_replace,\n+                    position_sp_for_msg,\n+                    named_arg_sp: arg_name.span,\n+                    named_arg_name: arg_name.name.to_string(),\n+                    is_formatting_arg: matches!(used_as, Width | Precision),\n+                },\n+            });\n+        }\n+    }\n \n-        // Used to ensure we only report translations for *one* kind of foreign format.\n-        let mut found_foreign = false;\n-        // Decide if we want to look for foreign formatting directives.\n-        if args_used < args_unused {\n-            use super::format_foreign as foreign;\n+    Ok(FormatArgs { span: fmt_span, template, arguments: args })\n+}\n \n-            // The set of foreign substitutions we've explained.  This prevents spamming the user\n-            // with `%d should be written as {}` over and over again.\n-            let mut explained = FxHashSet::default();\n+fn invalid_placeholder_type_error(\n+    ecx: &ExtCtxt<'_>,\n+    ty: &str,\n+    ty_span: Option<rustc_parse_format::InnerSpan>,\n+    fmt_span: Span,\n+) {\n+    let sp = ty_span.map(|sp| fmt_span.from_inner(InnerSpan::new(sp.start, sp.end)));\n+    let mut err =\n+        ecx.struct_span_err(sp.unwrap_or(fmt_span), &format!(\"unknown format trait `{}`\", ty));\n+    err.note(\n+        \"the only appropriate formatting traits are:\\n\\\n+                                - ``, which uses the `Display` trait\\n\\\n+                                - `?`, which uses the `Debug` trait\\n\\\n+                                - `e`, which uses the `LowerExp` trait\\n\\\n+                                - `E`, which uses the `UpperExp` trait\\n\\\n+                                - `o`, which uses the `Octal` trait\\n\\\n+                                - `p`, which uses the `Pointer` trait\\n\\\n+                                - `b`, which uses the `Binary` trait\\n\\\n+                                - `x`, which uses the `LowerHex` trait\\n\\\n+                                - `X`, which uses the `UpperHex` trait\",\n+    );\n+    if let Some(sp) = sp {\n+        for (fmt, name) in &[\n+            (\"\", \"Display\"),\n+            (\"?\", \"Debug\"),\n+            (\"e\", \"LowerExp\"),\n+            (\"E\", \"UpperExp\"),\n+            (\"o\", \"Octal\"),\n+            (\"p\", \"Pointer\"),\n+            (\"b\", \"Binary\"),\n+            (\"x\", \"LowerHex\"),\n+            (\"X\", \"UpperHex\"),\n+        ] {\n+            err.tool_only_span_suggestion(\n+                sp,\n+                &format!(\"use the `{}` trait\", name),\n+                *fmt,\n+                Applicability::MaybeIncorrect,\n+            );\n+        }\n+    }\n+    err.emit();\n+}\n \n-            macro_rules! check_foreign {\n-                ($kind:ident) => {{\n-                    let mut show_doc_note = false;\n+fn report_missing_placeholders(\n+    ecx: &mut ExtCtxt<'_>,\n+    unused: Vec<(Span, &str)>,\n+    detect_foreign_fmt: bool,\n+    str_style: Option<usize>,\n+    fmt_str: &str,\n+    fmt_span: Span,\n+) {\n+    let mut diag = if let &[(span, msg)] = &unused[..] {\n+        let mut diag = ecx.struct_span_err(span, msg);\n+        diag.span_label(span, msg);\n+        diag\n+    } else {\n+        let mut diag = ecx.struct_span_err(\n+            unused.iter().map(|&(sp, _)| sp).collect::<Vec<Span>>(),\n+            \"multiple unused formatting arguments\",\n+        );\n+        diag.span_label(fmt_span, \"multiple missing formatting specifiers\");\n+        for &(span, msg) in &unused {\n+            diag.span_label(span, msg);\n+        }\n+        diag\n+    };\n \n-                    let mut suggestions = vec![];\n-                    // account for `\"` and account for raw strings `r#`\n-                    let padding = str_style.map(|i| i + 2).unwrap_or(1);\n-                    for sub in foreign::$kind::iter_subs(fmt_str, padding) {\n-                        let (trn, success) = match sub.translate() {\n-                            Ok(trn) => (trn, true),\n-                            Err(Some(msg)) => (msg, false),\n+    // Used to ensure we only report translations for *one* kind of foreign format.\n+    let mut found_foreign = false;\n+\n+    // Decide if we want to look for foreign formatting directives.\n+    if detect_foreign_fmt {\n+        use super::format_foreign as foreign;\n+\n+        // The set of foreign substitutions we've explained.  This prevents spamming the user\n+        // with `%d should be written as {}` over and over again.\n+        let mut explained = FxHashSet::default();\n+\n+        macro_rules! check_foreign {\n+            ($kind:ident) => {{\n+                let mut show_doc_note = false;\n+\n+                let mut suggestions = vec![];\n+                // account for `\"` and account for raw strings `r#`\n+                let padding = str_style.map(|i| i + 2).unwrap_or(1);\n+                for sub in foreign::$kind::iter_subs(fmt_str, padding) {\n+                    let (trn, success) = match sub.translate() {\n+                        Ok(trn) => (trn, true),\n+                        Err(Some(msg)) => (msg, false),\n+\n+                        // If it has no translation, don't call it out specifically.\n+                        _ => continue,\n+                    };\n+\n+                    let pos = sub.position();\n+                    let sub = String::from(sub.as_str());\n+                    if explained.contains(&sub) {\n+                        continue;\n+                    }\n+                    explained.insert(sub.clone());\n \n-                            // If it has no translation, don't call it out specifically.\n-                            _ => continue,\n-                        };\n+                    if !found_foreign {\n+                        found_foreign = true;\n+                        show_doc_note = true;\n+                    }\n \n-                        let pos = sub.position();\n-                        let sub = String::from(sub.as_str());\n-                        if explained.contains(&sub) {\n-                            continue;\n-                        }\n-                        explained.insert(sub.clone());\n+                    if let Some(inner_sp) = pos {\n+                        let sp = fmt_span.from_inner(inner_sp);\n \n-                        if !found_foreign {\n-                            found_foreign = true;\n-                            show_doc_note = true;\n+                        if success {\n+                            suggestions.push((sp, trn));\n+                        } else {\n+                            diag.span_note(\n+                                sp,\n+                                &format!(\"format specifiers use curly braces, and {}\", trn),\n+                            );\n                         }\n-\n-                        if let Some(inner_sp) = pos {\n-                            let sp = fmt_sp.from_inner(inner_sp);\n-\n-                            if success {\n-                                suggestions.push((sp, trn));\n-                            } else {\n-                                diag.span_note(\n-                                    sp,\n-                                    &format!(\"format specifiers use curly braces, and {}\", trn),\n-                                );\n-                            }\n+                    } else {\n+                        if success {\n+                            diag.help(&format!(\"`{}` should be written as `{}`\", sub, trn));\n                         } else {\n-                            if success {\n-                                diag.help(&format!(\"`{}` should be written as `{}`\", sub, trn));\n-                            } else {\n-                                diag.note(&format!(\n-                                    \"`{}` should use curly braces, and {}\",\n-                                    sub, trn\n-                                ));\n-                            }\n+                            diag.note(&format!(\"`{}` should use curly braces, and {}\", sub, trn));\n                         }\n                     }\n+                }\n \n-                    if show_doc_note {\n-                        diag.note(concat!(\n-                            stringify!($kind),\n-                            \" formatting not supported; see the documentation for `std::fmt`\",\n-                        ));\n-                    }\n-                    if suggestions.len() > 0 {\n-                        diag.multipart_suggestion(\n-                            \"format specifiers use curly braces\",\n-                            suggestions,\n-                            Applicability::MachineApplicable,\n-                        );\n-                    }\n-                }};\n-            }\n-\n-            check_foreign!(printf);\n-            if !found_foreign {\n-                check_foreign!(shell);\n-            }\n-        }\n-        if !found_foreign && errs_len == 1 {\n-            diag.span_label(cx.fmtsp, \"formatting specifier missing\");\n+                if show_doc_note {\n+                    diag.note(concat!(\n+                        stringify!($kind),\n+                        \" formatting not supported; see the documentation for `std::fmt`\",\n+                    ));\n+                }\n+                if suggestions.len() > 0 {\n+                    diag.multipart_suggestion(\n+                        \"format specifiers use curly braces\",\n+                        suggestions,\n+                        Applicability::MachineApplicable,\n+                    );\n+                }\n+            }};\n         }\n \n-        diag.emit();\n-    } else if cx.invalid_refs.is_empty() && cx.ecx.sess.err_count() == 0 {\n-        // Only check for unused named argument names if there are no other errors to avoid causing\n-        // too much noise in output errors, such as when a named argument is entirely unused.\n-        create_lints_for_named_arguments_used_positionally(&mut cx);\n+        check_foreign!(printf);\n+        if !found_foreign {\n+            check_foreign!(shell);\n+        }\n+    }\n+    if !found_foreign && unused.len() == 1 {\n+        diag.span_label(fmt_span, \"formatting specifier missing\");\n     }\n \n-    cx.into_expr()\n+    diag.emit();\n }\n \n-fn may_contain_yield_point(e: &ast::Expr) -> bool {\n-    struct MayContainYieldPoint(bool);\n+/// Handle invalid references to positional arguments. Output different\n+/// errors for the case where all arguments are positional and for when\n+/// there are named arguments or numbered positional arguments in the\n+/// format string.\n+fn report_invalid_references(\n+    ecx: &mut ExtCtxt<'_>,\n+    invalid_refs: &[(usize, Option<Span>, PositionUsedAs, FormatArgPositionKind)],\n+    template: &[FormatArgsPiece],\n+    fmt_span: Span,\n+    args: &FormatArguments,\n+    parser: parse::Parser<'_>,\n+) {\n+    let num_args_desc = match args.explicit_args().len() {\n+        0 => \"no arguments were given\".to_string(),\n+        1 => \"there is 1 argument\".to_string(),\n+        n => format!(\"there are {} arguments\", n),\n+    };\n+\n+    let mut e;\n \n-    impl Visitor<'_> for MayContainYieldPoint {\n-        fn visit_expr(&mut self, e: &ast::Expr) {\n-            if let ast::ExprKind::Await(_) | ast::ExprKind::Yield(_) = e.kind {\n-                self.0 = true;\n-            } else {\n-                visit::walk_expr(self, e);\n+    if template.iter().all(|piece| match piece {\n+        FormatArgsPiece::Placeholder(FormatPlaceholder {\n+            argument: FormatArgPosition { kind: FormatArgPositionKind::Number, .. },\n+            ..\n+        }) => false,\n+        FormatArgsPiece::Placeholder(FormatPlaceholder {\n+            format_options:\n+                FormatOptions {\n+                    precision:\n+                        Some(FormatCount::Argument(FormatArgPosition {\n+                            kind: FormatArgPositionKind::Number,\n+                            ..\n+                        })),\n+                    ..\n+                }\n+                | FormatOptions {\n+                    width:\n+                        Some(FormatCount::Argument(FormatArgPosition {\n+                            kind: FormatArgPositionKind::Number,\n+                            ..\n+                        })),\n+                    ..\n+                },\n+            ..\n+        }) => false,\n+        _ => true,\n+    }) {\n+        // There are no numeric positions.\n+        // Collect all the implicit positions:\n+        let mut spans = Vec::new();\n+        let mut num_placeholders = 0;\n+        for piece in template {\n+            let mut placeholder = None;\n+            // `{arg:.*}`\n+            if let FormatArgsPiece::Placeholder(FormatPlaceholder {\n+                format_options:\n+                    FormatOptions {\n+                        precision:\n+                            Some(FormatCount::Argument(FormatArgPosition {\n+                                span,\n+                                kind: FormatArgPositionKind::Implicit,\n+                                ..\n+                            })),\n+                        ..\n+                    },\n+                ..\n+            }) = piece\n+            {\n+                placeholder = *span;\n+                num_placeholders += 1;\n             }\n+            // `{}`\n+            if let FormatArgsPiece::Placeholder(FormatPlaceholder {\n+                argument: FormatArgPosition { kind: FormatArgPositionKind::Implicit, .. },\n+                span,\n+                ..\n+            }) = piece\n+            {\n+                placeholder = *span;\n+                num_placeholders += 1;\n+            }\n+            // For `{:.*}`, we only push one span.\n+            spans.extend(placeholder);\n         }\n-\n-        fn visit_mac_call(&mut self, _: &ast::MacCall) {\n-            self.0 = true;\n+        let span = if spans.is_empty() {\n+            MultiSpan::from_span(fmt_span)\n+        } else {\n+            MultiSpan::from_spans(spans)\n+        };\n+        e = ecx.struct_span_err(\n+            span,\n+            &format!(\n+                \"{} positional argument{} in format string, but {}\",\n+                num_placeholders,\n+                pluralize!(num_placeholders),\n+                num_args_desc,\n+            ),\n+        );\n+        for arg in args.explicit_args() {\n+            e.span_label(arg.expr.span, \"\");\n+        }\n+        // Point out `{:.*}` placeholders: those take an extra argument.\n+        let mut has_precision_star = false;\n+        for piece in template {\n+            if let FormatArgsPiece::Placeholder(FormatPlaceholder {\n+                format_options:\n+                    FormatOptions {\n+                        precision:\n+                            Some(FormatCount::Argument(FormatArgPosition {\n+                                index,\n+                                span: Some(span),\n+                                kind: FormatArgPositionKind::Implicit,\n+                                ..\n+                            })),\n+                        ..\n+                    },\n+                ..\n+            }) = piece\n+            {\n+                let (Ok(index) | Err(index)) = index;\n+                has_precision_star = true;\n+                e.span_label(\n+                    *span,\n+                    &format!(\n+                        \"this precision flag adds an extra required argument at position {}, which is why there {} expected\",\n+                        index,\n+                        if num_placeholders == 1 {\n+                            \"is 1 argument\".to_string()\n+                        } else {\n+                            format!(\"are {} arguments\", num_placeholders)\n+                        },\n+                    ),\n+                );\n+            }\n+        }\n+        if has_precision_star {\n+            e.note(\"positional arguments are zero-based\");\n         }\n+    } else {\n+        let mut indexes: Vec<_> = invalid_refs.iter().map(|&(index, _, _, _)| index).collect();\n+        // Avoid `invalid reference to positional arguments 7 and 7 (there is 1 argument)`\n+        // for `println!(\"{7:7$}\", 1);`\n+        indexes.sort();\n+        indexes.dedup();\n+        let span: MultiSpan = if !parser.is_literal || parser.arg_places.is_empty() {\n+            MultiSpan::from_span(fmt_span)\n+        } else {\n+            MultiSpan::from_spans(invalid_refs.iter().filter_map(|&(_, span, _, _)| span).collect())\n+        };\n+        let arg_list = if let &[index] = &indexes[..] {\n+            format!(\"argument {index}\")\n+        } else {\n+            let tail = indexes.pop().unwrap();\n+            format!(\n+                \"arguments {head} and {tail}\",\n+                head = indexes.into_iter().map(|i| i.to_string()).collect::<Vec<_>>().join(\", \")\n+            )\n+        };\n+        e = ecx.struct_span_err(\n+            span,\n+            &format!(\"invalid reference to positional {} ({})\", arg_list, num_args_desc),\n+        );\n+        e.note(\"positional arguments are zero-based\");\n+    }\n \n-        fn visit_attribute(&mut self, _: &ast::Attribute) {\n-            // Conservatively assume this may be a proc macro attribute in\n-            // expression position.\n-            self.0 = true;\n+    if template.iter().any(|piece| match piece {\n+        FormatArgsPiece::Placeholder(FormatPlaceholder { format_options: f, .. }) => {\n+            *f != FormatOptions::default()\n         }\n+        _ => false,\n+    }) {\n+        e.note(\"for information about formatting flags, visit https://doc.rust-lang.org/std/fmt/index.html\");\n+    }\n+\n+    e.emit();\n+}\n \n-        fn visit_item(&mut self, _: &ast::Item) {\n-            // Do not recurse into nested items.\n+fn expand_format_args_impl<'cx>(\n+    ecx: &'cx mut ExtCtxt<'_>,\n+    mut sp: Span,\n+    tts: TokenStream,\n+    nl: bool,\n+) -> Box<dyn base::MacResult + 'cx> {\n+    sp = ecx.with_def_site_ctxt(sp);\n+    match parse_args(ecx, sp, tts) {\n+        Ok((efmt, args)) => {\n+            if let Ok(format_args) = make_format_args(ecx, efmt, args, nl) {\n+                MacEager::expr(expand_parsed_format_args(ecx, format_args))\n+            } else {\n+                MacEager::expr(DummyResult::raw_expr(sp, true))\n+            }\n+        }\n+        Err(mut err) => {\n+            err.emit();\n+            DummyResult::any(sp)\n         }\n     }\n+}\n+\n+pub fn expand_format_args<'cx>(\n+    ecx: &'cx mut ExtCtxt<'_>,\n+    sp: Span,\n+    tts: TokenStream,\n+) -> Box<dyn base::MacResult + 'cx> {\n+    expand_format_args_impl(ecx, sp, tts, false)\n+}\n \n-    let mut visitor = MayContainYieldPoint(false);\n-    visitor.visit_expr(e);\n-    visitor.0\n+pub fn expand_format_args_nl<'cx>(\n+    ecx: &'cx mut ExtCtxt<'_>,\n+    sp: Span,\n+    tts: TokenStream,\n+) -> Box<dyn base::MacResult + 'cx> {\n+    expand_format_args_impl(ecx, sp, tts, true)\n }"}, {"sha": "01dbffa21b8aad83148aea372d190b55b1106bfd", "filename": "compiler/rustc_builtin_macros/src/format/ast.rs", "status": "added", "additions": 240, "deletions": 0, "changes": 240, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat%2Fast.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "patch": "@@ -0,0 +1,240 @@\n+use rustc_ast::ptr::P;\n+use rustc_ast::Expr;\n+use rustc_data_structures::fx::FxHashMap;\n+use rustc_span::symbol::{Ident, Symbol};\n+use rustc_span::Span;\n+\n+// Definitions:\n+//\n+// format_args!(\"hello {abc:.xyz$}!!\", abc=\"world\");\n+// \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+//                     FormatArgs\n+//\n+// format_args!(\"hello {abc:.xyz$}!!\", abc=\"world\");\n+//                                     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+//                                      argument\n+//\n+// format_args!(\"hello {abc:.xyz$}!!\", abc=\"world\");\n+//              \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+//                     template\n+//\n+// format_args!(\"hello {abc:.xyz$}!!\", abc=\"world\");\n+//               \u2514\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2518\n+//                      pieces\n+//\n+// format_args!(\"hello {abc:.xyz$}!!\", abc=\"world\");\n+//               \u2514\u2500\u2500\u2500\u2500\u2518           \u2514\u2518\n+//                   literal pieces\n+//\n+// format_args!(\"hello {abc:.xyz$}!!\", abc=\"world\");\n+//                     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+//                     placeholder\n+//\n+// format_args!(\"hello {abc:.xyz$}!!\", abc=\"world\");\n+//                      \u2514\u2500\u2518  \u2514\u2500\u2518\n+//                      positions (could be names, numbers, empty, or `*`)\n+\n+/// (Parsed) format args.\n+///\n+/// Basically the \"AST\" for a complete `format_args!()`.\n+///\n+/// E.g., `format_args!(\"hello {name}\");`.\n+#[derive(Clone, Debug)]\n+pub struct FormatArgs {\n+    pub span: Span,\n+    pub template: Vec<FormatArgsPiece>,\n+    pub arguments: FormatArguments,\n+}\n+\n+/// A piece of a format template string.\n+///\n+/// E.g. \"hello\" or \"{name}\".\n+#[derive(Clone, Debug)]\n+pub enum FormatArgsPiece {\n+    Literal(Symbol),\n+    Placeholder(FormatPlaceholder),\n+}\n+\n+/// The arguments to format_args!().\n+///\n+/// E.g. `1, 2, name=\"ferris\", n=3`,\n+/// but also implicit captured arguments like `x` in `format_args!(\"{x}\")`.\n+#[derive(Clone, Debug)]\n+pub struct FormatArguments {\n+    arguments: Vec<FormatArgument>,\n+    num_unnamed_args: usize,\n+    num_explicit_args: usize,\n+    names: FxHashMap<Symbol, usize>,\n+}\n+\n+impl FormatArguments {\n+    pub fn new() -> Self {\n+        Self {\n+            arguments: Vec::new(),\n+            names: FxHashMap::default(),\n+            num_unnamed_args: 0,\n+            num_explicit_args: 0,\n+        }\n+    }\n+\n+    pub fn add(&mut self, arg: FormatArgument) -> usize {\n+        let index = self.arguments.len();\n+        if let Some(name) = arg.kind.ident() {\n+            self.names.insert(name.name, index);\n+        } else if self.names.is_empty() {\n+            // Only count the unnamed args before the first named arg.\n+            // (Any later ones are errors.)\n+            self.num_unnamed_args += 1;\n+        }\n+        if !matches!(arg.kind, FormatArgumentKind::Captured(..)) {\n+            // This is an explicit argument.\n+            // Make sure that all arguments so far are explcit.\n+            assert_eq!(\n+                self.num_explicit_args,\n+                self.arguments.len(),\n+                \"captured arguments must be added last\"\n+            );\n+            self.num_explicit_args += 1;\n+        }\n+        self.arguments.push(arg);\n+        index\n+    }\n+\n+    pub fn by_name(&self, name: Symbol) -> Option<(usize, &FormatArgument)> {\n+        let i = *self.names.get(&name)?;\n+        Some((i, &self.arguments[i]))\n+    }\n+\n+    pub fn by_index(&self, i: usize) -> Option<&FormatArgument> {\n+        (i < self.num_explicit_args).then(|| &self.arguments[i])\n+    }\n+\n+    pub fn unnamed_args(&self) -> &[FormatArgument] {\n+        &self.arguments[..self.num_unnamed_args]\n+    }\n+\n+    pub fn named_args(&self) -> &[FormatArgument] {\n+        &self.arguments[self.num_unnamed_args..self.num_explicit_args]\n+    }\n+\n+    pub fn explicit_args(&self) -> &[FormatArgument] {\n+        &self.arguments[..self.num_explicit_args]\n+    }\n+\n+    pub fn into_vec(self) -> Vec<FormatArgument> {\n+        self.arguments\n+    }\n+}\n+\n+#[derive(Clone, Debug)]\n+pub struct FormatArgument {\n+    pub kind: FormatArgumentKind,\n+    pub expr: P<Expr>,\n+}\n+\n+#[derive(Clone, Debug)]\n+pub enum FormatArgumentKind {\n+    /// `format_args(\u2026, arg)`\n+    Normal,\n+    /// `format_args(\u2026, arg = 1)`\n+    Named(Ident),\n+    /// `format_args(\"\u2026 {arg} \u2026\")`\n+    Captured(Ident),\n+}\n+\n+impl FormatArgumentKind {\n+    pub fn ident(&self) -> Option<Ident> {\n+        match self {\n+            &Self::Normal => None,\n+            &Self::Named(id) => Some(id),\n+            &Self::Captured(id) => Some(id),\n+        }\n+    }\n+}\n+\n+#[derive(Clone, Debug, PartialEq, Eq)]\n+pub struct FormatPlaceholder {\n+    /// Index into [`FormatArgs::arguments`].\n+    pub argument: FormatArgPosition,\n+    /// The span inside the format string for the full `{\u2026}` placeholder.\n+    pub span: Option<Span>,\n+    /// `{}`, `{:?}`, or `{:x}`, etc.\n+    pub format_trait: FormatTrait,\n+    /// `{}` or `{:.5}` or `{:-^20}`, etc.\n+    pub format_options: FormatOptions,\n+}\n+\n+#[derive(Clone, Debug, PartialEq, Eq)]\n+pub struct FormatArgPosition {\n+    /// Which argument this position refers to (Ok),\n+    /// or would've referred to if it existed (Err).\n+    pub index: Result<usize, usize>,\n+    /// What kind of position this is. See [`FormatArgPositionKind`].\n+    pub kind: FormatArgPositionKind,\n+    /// The span of the name or number.\n+    pub span: Option<Span>,\n+}\n+\n+#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n+pub enum FormatArgPositionKind {\n+    /// `{}` or `{:.*}`\n+    Implicit,\n+    /// `{1}` or `{:1$}` or `{:.1$}`\n+    Number,\n+    /// `{a}` or `{:a$}` or `{:.a$}`\n+    Named,\n+}\n+\n+#[derive(Copy, Clone, Debug, Hash, PartialEq, Eq)]\n+pub enum FormatTrait {\n+    /// `{}`\n+    Display,\n+    /// `{:?}`\n+    Debug,\n+    /// `{:e}`\n+    LowerExp,\n+    /// `{:E}`\n+    UpperExp,\n+    /// `{:o}`\n+    Octal,\n+    /// `{:p}`\n+    Pointer,\n+    /// `{:b}`\n+    Binary,\n+    /// `{:x}`\n+    LowerHex,\n+    /// `{:X}`\n+    UpperHex,\n+}\n+\n+#[derive(Clone, Debug, Default, PartialEq, Eq)]\n+pub struct FormatOptions {\n+    /// The width. E.g. `{:5}` or `{:width$}`.\n+    pub width: Option<FormatCount>,\n+    /// The precision. E.g. `{:.5}` or `{:.precision$}`.\n+    pub precision: Option<FormatCount>,\n+    /// The alignment. E.g. `{:>}` or `{:<}` or `{:^}`.\n+    pub alignment: Option<FormatAlignment>,\n+    /// The fill character. E.g. the `.` in `{:.>10}`.\n+    pub fill: Option<char>,\n+    /// The `+`, `-`, `0`, `#`, `x?` and `X?` flags.\n+    pub flags: u32,\n+}\n+\n+#[derive(Clone, Debug, PartialEq, Eq)]\n+pub enum FormatAlignment {\n+    /// `{:<}`\n+    Left,\n+    /// `{:>}`\n+    Right,\n+    /// `{:^}`\n+    Center,\n+}\n+\n+#[derive(Clone, Debug, PartialEq, Eq)]\n+pub enum FormatCount {\n+    /// `{:5}` or `{:.5}`\n+    Literal(usize),\n+    /// `{:.*}`, `{:.5$}`, or `{:a$}`, etc.\n+    Argument(FormatArgPosition),\n+}"}, {"sha": "9dde5efcb28b7611c514e8517fc0d769fcb4d126", "filename": "compiler/rustc_builtin_macros/src/format/expand.rs", "status": "added", "additions": 353, "deletions": 0, "changes": 353, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat%2Fexpand.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "patch": "@@ -0,0 +1,353 @@\n+use super::*;\n+use rustc_ast as ast;\n+use rustc_ast::visit::{self, Visitor};\n+use rustc_ast::{BlockCheckMode, UnsafeSource};\n+use rustc_data_structures::fx::FxIndexSet;\n+use rustc_span::{sym, symbol::kw};\n+\n+#[derive(Copy, Clone, Debug, Hash, PartialEq, Eq)]\n+enum ArgumentType {\n+    Format(FormatTrait),\n+    Usize,\n+}\n+\n+fn make_argument(ecx: &ExtCtxt<'_>, sp: Span, arg: P<ast::Expr>, ty: ArgumentType) -> P<ast::Expr> {\n+    // Generate:\n+    //     ::core::fmt::ArgumentV1::new_\u2026(arg)\n+    use ArgumentType::*;\n+    use FormatTrait::*;\n+    ecx.expr_call_global(\n+        sp,\n+        ecx.std_path(&[\n+            sym::fmt,\n+            sym::ArgumentV1,\n+            match ty {\n+                Format(Display) => sym::new_display,\n+                Format(Debug) => sym::new_debug,\n+                Format(LowerExp) => sym::new_lower_exp,\n+                Format(UpperExp) => sym::new_upper_exp,\n+                Format(Octal) => sym::new_octal,\n+                Format(Pointer) => sym::new_pointer,\n+                Format(Binary) => sym::new_binary,\n+                Format(LowerHex) => sym::new_lower_hex,\n+                Format(UpperHex) => sym::new_upper_hex,\n+                Usize => sym::from_usize,\n+            },\n+        ]),\n+        vec![arg],\n+    )\n+}\n+\n+fn make_count(\n+    ecx: &ExtCtxt<'_>,\n+    sp: Span,\n+    count: &Option<FormatCount>,\n+    argmap: &mut FxIndexSet<(usize, ArgumentType)>,\n+) -> P<ast::Expr> {\n+    // Generate:\n+    //     ::core::fmt::rt::v1::Count::\u2026(\u2026)\n+    match count {\n+        Some(FormatCount::Literal(n)) => ecx.expr_call_global(\n+            sp,\n+            ecx.std_path(&[sym::fmt, sym::rt, sym::v1, sym::Count, sym::Is]),\n+            vec![ecx.expr_usize(sp, *n)],\n+        ),\n+        Some(FormatCount::Argument(arg)) => {\n+            if let Ok(arg_index) = arg.index {\n+                let (i, _) = argmap.insert_full((arg_index, ArgumentType::Usize));\n+                ecx.expr_call_global(\n+                    sp,\n+                    ecx.std_path(&[sym::fmt, sym::rt, sym::v1, sym::Count, sym::Param]),\n+                    vec![ecx.expr_usize(sp, i)],\n+                )\n+            } else {\n+                DummyResult::raw_expr(sp, true)\n+            }\n+        }\n+        None => ecx.expr_path(ecx.path_global(\n+            sp,\n+            ecx.std_path(&[sym::fmt, sym::rt, sym::v1, sym::Count, sym::Implied]),\n+        )),\n+    }\n+}\n+\n+fn make_format_spec(\n+    ecx: &ExtCtxt<'_>,\n+    sp: Span,\n+    placeholder: &FormatPlaceholder,\n+    argmap: &mut FxIndexSet<(usize, ArgumentType)>,\n+) -> P<ast::Expr> {\n+    // Generate:\n+    //     ::core::fmt::rt::v1::Argument {\n+    //         position: 0usize,\n+    //         format: ::core::fmt::rt::v1::FormatSpec {\n+    //             fill: ' ',\n+    //             align: ::core::fmt::rt::v1::Alignment::Unknown,\n+    //             flags: 0u32,\n+    //             precision: ::core::fmt::rt::v1::Count::Implied,\n+    //             width: ::core::fmt::rt::v1::Count::Implied,\n+    //         },\n+    //     }\n+    let position = match placeholder.argument.index {\n+        Ok(arg_index) => {\n+            let (i, _) =\n+                argmap.insert_full((arg_index, ArgumentType::Format(placeholder.format_trait)));\n+            ecx.expr_usize(sp, i)\n+        }\n+        Err(_) => DummyResult::raw_expr(sp, true),\n+    };\n+    let fill = ecx.expr_char(sp, placeholder.format_options.fill.unwrap_or(' '));\n+    let align = ecx.expr_path(ecx.path_global(\n+        sp,\n+        ecx.std_path(&[\n+            sym::fmt,\n+            sym::rt,\n+            sym::v1,\n+            sym::Alignment,\n+            match placeholder.format_options.alignment {\n+                Some(FormatAlignment::Left) => sym::Left,\n+                Some(FormatAlignment::Right) => sym::Right,\n+                Some(FormatAlignment::Center) => sym::Center,\n+                None => sym::Unknown,\n+            },\n+        ]),\n+    ));\n+    let flags = ecx.expr_u32(sp, placeholder.format_options.flags);\n+    let prec = make_count(ecx, sp, &placeholder.format_options.precision, argmap);\n+    let width = make_count(ecx, sp, &placeholder.format_options.width, argmap);\n+    ecx.expr_struct(\n+        sp,\n+        ecx.path_global(sp, ecx.std_path(&[sym::fmt, sym::rt, sym::v1, sym::Argument])),\n+        vec![\n+            ecx.field_imm(sp, Ident::new(sym::position, sp), position),\n+            ecx.field_imm(\n+                sp,\n+                Ident::new(sym::format, sp),\n+                ecx.expr_struct(\n+                    sp,\n+                    ecx.path_global(\n+                        sp,\n+                        ecx.std_path(&[sym::fmt, sym::rt, sym::v1, sym::FormatSpec]),\n+                    ),\n+                    vec![\n+                        ecx.field_imm(sp, Ident::new(sym::fill, sp), fill),\n+                        ecx.field_imm(sp, Ident::new(sym::align, sp), align),\n+                        ecx.field_imm(sp, Ident::new(sym::flags, sp), flags),\n+                        ecx.field_imm(sp, Ident::new(sym::precision, sp), prec),\n+                        ecx.field_imm(sp, Ident::new(sym::width, sp), width),\n+                    ],\n+                ),\n+            ),\n+        ],\n+    )\n+}\n+\n+pub fn expand_parsed_format_args(ecx: &mut ExtCtxt<'_>, fmt: FormatArgs) -> P<ast::Expr> {\n+    let macsp = ecx.with_def_site_ctxt(ecx.call_site());\n+\n+    let lit_pieces = ecx.expr_array_ref(\n+        fmt.span,\n+        fmt.template\n+            .iter()\n+            .enumerate()\n+            .filter_map(|(i, piece)| match piece {\n+                &FormatArgsPiece::Literal(s) => Some(ecx.expr_str(fmt.span, s)),\n+                &FormatArgsPiece::Placeholder(_) => {\n+                    // Inject empty string before placeholders when not already preceded by a literal piece.\n+                    if i == 0 || matches!(fmt.template[i - 1], FormatArgsPiece::Placeholder(_)) {\n+                        Some(ecx.expr_str(fmt.span, kw::Empty))\n+                    } else {\n+                        None\n+                    }\n+                }\n+            })\n+            .collect(),\n+    );\n+\n+    // Whether we'll use the `Arguments::new_v1_formatted` form (true),\n+    // or the `Arguments::new_v1` form (false).\n+    let mut use_format_options = false;\n+\n+    // Create a list of all _unique_ (argument, format trait) combinations.\n+    // E.g. \"{0} {0:x} {0} {1}\" -> [(0, Display), (0, LowerHex), (1, Display)]\n+    let mut argmap = FxIndexSet::default();\n+    for piece in &fmt.template {\n+        let FormatArgsPiece::Placeholder(placeholder) = piece else { continue };\n+        if placeholder.format_options != Default::default() {\n+            // Can't use basic form if there's any formatting options.\n+            use_format_options = true;\n+        }\n+        if let Ok(index) = placeholder.argument.index {\n+            if !argmap.insert((index, ArgumentType::Format(placeholder.format_trait))) {\n+                // Duplicate (argument, format trait) combination,\n+                // which we'll only put once in the args array.\n+                use_format_options = true;\n+            }\n+        }\n+    }\n+\n+    let format_options = use_format_options.then(|| {\n+        // Generate:\n+        //     &[format_spec_0, format_spec_1, format_spec_2]\n+        ecx.expr_array_ref(\n+            macsp,\n+            fmt.template\n+                .iter()\n+                .filter_map(|piece| {\n+                    let FormatArgsPiece::Placeholder(placeholder) = piece else { return None };\n+                    Some(make_format_spec(ecx, macsp, placeholder, &mut argmap))\n+                })\n+                .collect(),\n+        )\n+    });\n+\n+    let arguments = fmt.arguments.into_vec();\n+\n+    // If the args array contains exactly all the original arguments once,\n+    // in order, we can use a simple array instead of a `match` construction.\n+    // However, if there's a yield point in any argument except the first one,\n+    // we don't do this, because an ArgumentV1 cannot be kept across yield points.\n+    let use_simple_array = argmap.len() == arguments.len()\n+        && argmap.iter().enumerate().all(|(i, &(j, _))| i == j)\n+        && arguments.iter().skip(1).all(|arg| !may_contain_yield_point(&arg.expr));\n+\n+    let args = if use_simple_array {\n+        // Generate:\n+        //     &[\n+        //         ::core::fmt::ArgumentV1::new_display(&arg0),\n+        //         ::core::fmt::ArgumentV1::new_lower_hex(&arg1),\n+        //         ::core::fmt::ArgumentV1::new_debug(&arg2),\n+        //     ]\n+        ecx.expr_array_ref(\n+            macsp,\n+            arguments\n+                .into_iter()\n+                .zip(argmap)\n+                .map(|(arg, (_, ty))| {\n+                    let sp = arg.expr.span.with_ctxt(macsp.ctxt());\n+                    make_argument(ecx, sp, ecx.expr_addr_of(sp, arg.expr), ty)\n+                })\n+                .collect(),\n+        )\n+    } else {\n+        // Generate:\n+        //     match (&arg0, &arg1, &arg2) {\n+        //         args => &[\n+        //             ::core::fmt::ArgumentV1::new_display(args.0),\n+        //             ::core::fmt::ArgumentV1::new_lower_hex(args.1),\n+        //             ::core::fmt::ArgumentV1::new_debug(args.0),\n+        //         ]\n+        //     }\n+        let args_ident = Ident::new(sym::args, macsp);\n+        let args = argmap\n+            .iter()\n+            .map(|&(arg_index, ty)| {\n+                if let Some(arg) = arguments.get(arg_index) {\n+                    let sp = arg.expr.span.with_ctxt(macsp.ctxt());\n+                    make_argument(\n+                        ecx,\n+                        sp,\n+                        ecx.expr_field(\n+                            sp,\n+                            ecx.expr_ident(macsp, args_ident),\n+                            Ident::new(sym::integer(arg_index), macsp),\n+                        ),\n+                        ty,\n+                    )\n+                } else {\n+                    DummyResult::raw_expr(macsp, true)\n+                }\n+            })\n+            .collect();\n+        ecx.expr_addr_of(\n+            macsp,\n+            ecx.expr_match(\n+                macsp,\n+                ecx.expr_tuple(\n+                    macsp,\n+                    arguments\n+                        .into_iter()\n+                        .map(|arg| {\n+                            ecx.expr_addr_of(arg.expr.span.with_ctxt(macsp.ctxt()), arg.expr)\n+                        })\n+                        .collect(),\n+                ),\n+                vec![ecx.arm(macsp, ecx.pat_ident(macsp, args_ident), ecx.expr_array(macsp, args))],\n+            ),\n+        )\n+    };\n+\n+    if let Some(format_options) = format_options {\n+        // Generate:\n+        //     ::core::fmt::Arguments::new_v1_formatted(\n+        //         lit_pieces,\n+        //         args,\n+        //         format_options,\n+        //         unsafe { ::core::fmt::UnsafeArg::new() }\n+        //     )\n+        ecx.expr_call_global(\n+            macsp,\n+            ecx.std_path(&[sym::fmt, sym::Arguments, sym::new_v1_formatted]),\n+            vec![\n+                lit_pieces,\n+                args,\n+                format_options,\n+                ecx.expr_block(P(ast::Block {\n+                    stmts: vec![ecx.stmt_expr(ecx.expr_call_global(\n+                        macsp,\n+                        ecx.std_path(&[sym::fmt, sym::UnsafeArg, sym::new]),\n+                        Vec::new(),\n+                    ))],\n+                    id: ast::DUMMY_NODE_ID,\n+                    rules: BlockCheckMode::Unsafe(UnsafeSource::CompilerGenerated),\n+                    span: macsp,\n+                    tokens: None,\n+                    could_be_bare_literal: false,\n+                })),\n+            ],\n+        )\n+    } else {\n+        // Generate:\n+        //     ::core::fmt::Arguments::new_v1(\n+        //         lit_pieces,\n+        //         args,\n+        //     )\n+        ecx.expr_call_global(\n+            macsp,\n+            ecx.std_path(&[sym::fmt, sym::Arguments, sym::new_v1]),\n+            vec![lit_pieces, args],\n+        )\n+    }\n+}\n+\n+fn may_contain_yield_point(e: &ast::Expr) -> bool {\n+    struct MayContainYieldPoint(bool);\n+\n+    impl Visitor<'_> for MayContainYieldPoint {\n+        fn visit_expr(&mut self, e: &ast::Expr) {\n+            if let ast::ExprKind::Await(_) | ast::ExprKind::Yield(_) = e.kind {\n+                self.0 = true;\n+            } else {\n+                visit::walk_expr(self, e);\n+            }\n+        }\n+\n+        fn visit_mac_call(&mut self, _: &ast::MacCall) {\n+            self.0 = true;\n+        }\n+\n+        fn visit_attribute(&mut self, _: &ast::Attribute) {\n+            // Conservatively assume this may be a proc macro attribute in\n+            // expression position.\n+            self.0 = true;\n+        }\n+\n+        fn visit_item(&mut self, _: &ast::Item) {\n+            // Do not recurse into nested items.\n+        }\n+    }\n+\n+    let mut visitor = MayContainYieldPoint(false);\n+    visitor.visit_expr(e);\n+    visitor.0\n+}"}, {"sha": "c7ea7de8f4ead2f5d013192f79aea6010fa4898f", "filename": "compiler/rustc_builtin_macros/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_builtin_macros%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_builtin_macros%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Flib.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "patch": "@@ -7,9 +7,9 @@\n #![feature(box_patterns)]\n #![feature(decl_macro)]\n #![feature(if_let_guard)]\n+#![feature(is_some_and)]\n #![feature(is_sorted)]\n #![feature(let_chains)]\n-#![cfg_attr(bootstrap, feature(let_else))]\n #![feature(proc_macro_internals)]\n #![feature(proc_macro_quote)]\n #![recursion_limit = \"256\"]"}, {"sha": "705141614e252288bb9cee3b5e4d9ac9ed34ddef", "filename": "compiler/rustc_builtin_macros/src/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "patch": "@@ -115,7 +115,7 @@ pub fn expand_test_or_bench(\n             // reworked in the future to not need it, it'd be nice.\n             _ => diag.struct_span_err(attr_sp, msg).forget_guarantee(),\n         };\n-        err.span_label(attr_sp, \"the `#[test]` macro causes a a function to be run on a test and has no effect on non-functions\")\n+        err.span_label(attr_sp, \"the `#[test]` macro causes a function to be run on a test and has no effect on non-functions\")\n             .span_label(item.span, format!(\"expected a non-associated function, found {} {}\", item.kind.article(), item.kind.descr()))\n             .span_suggestion(attr_sp, \"replace with conditional compilation to make the item only exist when tests are being run\", \"#[cfg(test)]\", Applicability::MaybeIncorrect)\n             .emit();"}, {"sha": "3c08b6fa3894d61277a0c0b6499e23ddcdc544a9", "filename": "compiler/rustc_codegen_cranelift/build_system/rustc_info.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Frustc_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Frustc_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Frustc_info.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "patch": "@@ -65,7 +65,7 @@ pub(crate) fn get_file_name(crate_name: &str, crate_type: &str) -> String {\n }\n \n /// Similar to `get_file_name`, but converts any dashes (`-`) in the `crate_name` to\n-/// underscores (`_`). This is specially made for the the rustc and cargo wrappers\n+/// underscores (`_`). This is specially made for the rustc and cargo wrappers\n /// which have a dash in the name, and that is not allowed in a crate name.\n pub(crate) fn get_wrapper_file_name(crate_name: &str, crate_type: &str) -> String {\n     let crate_name = crate_name.replace('-', \"_\");"}, {"sha": "ad108c34992e30efa101dc5d71fa5f832e45788f", "filename": "compiler/rustc_codegen_cranelift/example/std_example.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_codegen_cranelift%2Fexample%2Fstd_example.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_codegen_cranelift%2Fexample%2Fstd_example.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fexample%2Fstd_example.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "patch": "@@ -1,4 +1,4 @@\n-#![feature(core_intrinsics, generators, generator_trait, is_sorted, bench_black_box)]\n+#![feature(core_intrinsics, generators, generator_trait, is_sorted)]\n \n #[cfg(target_arch = \"x86_64\")]\n use std::arch::x86_64::*;"}, {"sha": "e5ad31eb9484a85530df617646b0897c739ae783", "filename": "compiler/rustc_codegen_cranelift/src/abi/pass_mode.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Fpass_mode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Fpass_mode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Fpass_mode.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "patch": "@@ -193,7 +193,7 @@ pub(super) fn from_casted_value<'tcx>(\n         kind: StackSlotKind::ExplicitSlot,\n         // FIXME Don't force the size to a multiple of 16 bytes once Cranelift gets a way to\n         // specify stack slot alignment.\n-        // Stack slot size may be bigger for for example `[u8; 3]` which is packed into an `i32`.\n+        // Stack slot size may be bigger for example `[u8; 3]` which is packed into an `i32`.\n         // It may also be smaller for example when the type is a wrapper around an integer with a\n         // larger alignment than the integer.\n         size: (std::cmp::max(abi_param_size, layout_size) + 15) / 16 * 16,"}, {"sha": "4303d63fe21314d2f0e8c6306018de9486d909f7", "filename": "compiler/rustc_codegen_cranelift/src/base.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbase.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "patch": "@@ -633,7 +633,12 @@ fn codegen_stmt<'tcx>(\n                     lval.write_cvalue(fx, operand.cast_pointer_to(to_layout));\n                 }\n                 Rvalue::Cast(\n-                    CastKind::Misc\n+                    CastKind::IntToInt\n+                    | CastKind::FloatToFloat\n+                    | CastKind::FloatToInt\n+                    | CastKind::IntToFloat\n+                    | CastKind::FnPtrToPtr\n+                    | CastKind::PtrToPtr\n                     | CastKind::PointerExposeAddress\n                     | CastKind::PointerFromExposedAddress,\n                     ref operand,"}, {"sha": "c5f44bb8479642fb26e475403b43e3638d33978a", "filename": "compiler/rustc_codegen_cranelift/src/constant.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconstant.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "patch": "@@ -5,7 +5,6 @@ use rustc_middle::middle::codegen_fn_attrs::CodegenFnAttrFlags;\n use rustc_middle::mir::interpret::{\n     read_target_uint, AllocId, ConstAllocation, ConstValue, ErrorHandled, GlobalAlloc, Scalar,\n };\n-use rustc_middle::ty::ConstKind;\n use rustc_span::DUMMY_SP;\n \n use cranelift_codegen::ir::GlobalValueData;\n@@ -42,15 +41,7 @@ pub(crate) fn check_constants(fx: &mut FunctionCx<'_, '_, '_>) -> bool {\n     let mut all_constants_ok = true;\n     for constant in &fx.mir.required_consts {\n         let unevaluated = match fx.monomorphize(constant.literal) {\n-            ConstantKind::Ty(ct) => match ct.kind() {\n-                ConstKind::Unevaluated(uv) => uv.expand(),\n-                ConstKind::Value(_) => continue,\n-                ConstKind::Param(_)\n-                | ConstKind::Infer(_)\n-                | ConstKind::Bound(_, _)\n-                | ConstKind::Placeholder(_)\n-                | ConstKind::Error(_) => unreachable!(\"{:?}\", ct),\n-            },\n+            ConstantKind::Ty(_) => unreachable!(),\n             ConstantKind::Unevaluated(uv, _) => uv,\n             ConstantKind::Val(..) => continue,\n         };\n@@ -118,7 +109,7 @@ pub(crate) fn codegen_constant<'tcx>(\n ) -> CValue<'tcx> {\n     let (const_val, ty) = match fx.monomorphize(constant.literal) {\n         ConstantKind::Ty(const_) => unreachable!(\"{:?}\", const_),\n-        ConstantKind::Unevaluated(ty::Unevaluated { def, substs, promoted }, ty)\n+        ConstantKind::Unevaluated(mir::UnevaluatedConst { def, substs, promoted }, ty)\n             if fx.tcx.is_static(def.did) =>\n         {\n             assert!(substs.is_empty());\n@@ -499,7 +490,16 @@ pub(crate) fn mir_operand_get_const_val<'tcx>(\n                     match &stmt.kind {\n                         StatementKind::Assign(local_and_rvalue) if &local_and_rvalue.0 == place => {\n                             match &local_and_rvalue.1 {\n-                                Rvalue::Cast(CastKind::Misc, operand, ty) => {\n+                                Rvalue::Cast(\n+                                    CastKind::IntToInt\n+                                    | CastKind::FloatToFloat\n+                                    | CastKind::FloatToInt\n+                                    | CastKind::IntToFloat\n+                                    | CastKind::FnPtrToPtr\n+                                    | CastKind::PtrToPtr,\n+                                    operand,\n+                                    ty,\n+                                ) => {\n                                     if computed_const_val.is_some() {\n                                         return None; // local assigned twice\n                                     }"}, {"sha": "6fb1cbfad8cd3a422ef427b0797e8ac9af1b97cf", "filename": "compiler/rustc_codegen_gcc/src/abi.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_codegen_gcc%2Fsrc%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_codegen_gcc%2Fsrc%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fabi.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "patch": "@@ -11,10 +11,6 @@ use crate::intrinsic::ArgAbiExt;\n use crate::type_of::LayoutGccExt;\n \n impl<'a, 'gcc, 'tcx> AbiBuilderMethods<'tcx> for Builder<'a, 'gcc, 'tcx> {\n-    fn apply_attrs_callsite(&mut self, _fn_abi: &FnAbi<'tcx, Ty<'tcx>>, _callsite: Self::Value) {\n-        // TODO(antoyo)\n-    }\n-\n     fn get_param(&mut self, index: usize) -> Self::Value {\n         let func = self.current_func();\n         let param = func.get_param(index as i32);"}, {"sha": "ac0342f6b80a02c8632780c6a6844d2f4ffff104", "filename": "compiler/rustc_codegen_gcc/src/archive.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_codegen_gcc%2Fsrc%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_codegen_gcc%2Fsrc%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Farchive.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "patch": "@@ -1,6 +1,8 @@\n use std::fs::File;\n use std::path::{Path, PathBuf};\n \n+use crate::errors::RanlibFailure;\n+\n use rustc_codegen_ssa::back::archive::{ArchiveBuilder, ArchiveBuilderBuilder};\n use rustc_session::Session;\n \n@@ -181,7 +183,7 @@ impl<'a> ArchiveBuilder<'a> for ArArchiveBuilder<'a> {\n             std::process::Command::new(\"ranlib\").arg(output).status().expect(\"Couldn't run ranlib\");\n \n         if !status.success() {\n-            self.config.sess.fatal(&format!(\"Ranlib exited with code {:?}\", status.code()));\n+            self.config.sess.emit_fatal(RanlibFailure::new(status.code()));\n         }\n \n         any_members"}, {"sha": "c346dbd63cca75e38052283f641e54a740f0f43d", "filename": "compiler/rustc_codegen_gcc/src/asm.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_codegen_gcc%2Fsrc%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_codegen_gcc%2Fsrc%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fasm.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "patch": "@@ -12,6 +12,7 @@ use std::borrow::Cow;\n \n use crate::builder::Builder;\n use crate::context::CodegenCx;\n+use crate::errors::UnwindingInlineAsm;\n use crate::type_of::LayoutGccExt;\n use crate::callee::get_fn;\n \n@@ -109,7 +110,7 @@ impl<'a, 'gcc, 'tcx> AsmBuilderMethods<'tcx> for Builder<'a, 'gcc, 'tcx> {\n     fn codegen_inline_asm(&mut self, template: &[InlineAsmTemplatePiece], rust_operands: &[InlineAsmOperandRef<'tcx, Self>], options: InlineAsmOptions, span: &[Span], _instance: Instance<'_>, _dest_catch_funclet: Option<(Self::BasicBlock, Self::BasicBlock, Option<&Self::Funclet>)>) {\n         if options.contains(InlineAsmOptions::MAY_UNWIND) {\n             self.sess()\n-                .struct_span_err(span[0], \"GCC backend does not support unwinding from inline asm\")\n+                .create_err(UnwindingInlineAsm { span: span[0] })\n                 .emit();\n             return;\n         }\n@@ -497,7 +498,7 @@ impl<'a, 'gcc, 'tcx> AsmBuilderMethods<'tcx> for Builder<'a, 'gcc, 'tcx> {\n         if options.contains(InlineAsmOptions::NORETURN) {\n             let builtin_unreachable = self.context.get_builtin_function(\"__builtin_unreachable\");\n             let builtin_unreachable: RValue<'gcc> = unsafe { std::mem::transmute(builtin_unreachable) };\n-            self.call(self.type_void(), builtin_unreachable, &[], None);\n+            self.call(self.type_void(), None, builtin_unreachable, &[], None);\n         }\n \n         // Write results to outputs."}, {"sha": "a314b7cc2152ddf7d1a74ec5a16300e51e212d05", "filename": "compiler/rustc_codegen_gcc/src/builder.rs", "status": "modified", "additions": 28, "deletions": 9, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_codegen_gcc%2Fsrc%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_codegen_gcc%2Fsrc%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fbuilder.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "patch": "@@ -444,11 +444,23 @@ impl<'a, 'gcc, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'gcc, 'tcx> {\n         self.block.end_with_switch(None, value, default_block, &gcc_cases);\n     }\n \n-    fn invoke(&mut self, typ: Type<'gcc>, func: RValue<'gcc>, args: &[RValue<'gcc>], then: Block<'gcc>, catch: Block<'gcc>, _funclet: Option<&Funclet>) -> RValue<'gcc> {\n+    fn invoke(\n+        &mut self,\n+        typ: Type<'gcc>,\n+        fn_abi: Option<&FnAbi<'tcx, Ty<'tcx>>>,\n+        func: RValue<'gcc>,\n+        args: &[RValue<'gcc>],\n+        then: Block<'gcc>,\n+        catch: Block<'gcc>,\n+        _funclet: Option<&Funclet>,\n+    ) -> RValue<'gcc> {\n         // TODO(bjorn3): Properly implement unwinding.\n-        let call_site = self.call(typ, func, args, None);\n+        let call_site = self.call(typ, None, func, args, None);\n         let condition = self.context.new_rvalue_from_int(self.bool_type, 1);\n         self.llbb().end_with_conditional(None, condition, then, catch);\n+        if let Some(_fn_abi) = fn_abi {\n+            // TODO(bjorn3): Apply function attributes\n+        }\n         call_site\n     }\n \n@@ -643,11 +655,7 @@ impl<'a, 'gcc, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'gcc, 'tcx> {\n         self.current_func().new_local(None, aligned_type, &format!(\"stack_var_{}\", self.stack_var_count.get())).get_address(None)\n     }\n \n-    fn dynamic_alloca(&mut self, _ty: Type<'gcc>, _align: Align) -> RValue<'gcc> {\n-        unimplemented!();\n-    }\n-\n-    fn array_alloca(&mut self, _ty: Type<'gcc>, _len: RValue<'gcc>, _align: Align) -> RValue<'gcc> {\n+    fn byte_array_alloca(&mut self, _len: RValue<'gcc>, _align: Align) -> RValue<'gcc> {\n         unimplemented!();\n     }\n \n@@ -1227,16 +1235,27 @@ impl<'a, 'gcc, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'gcc, 'tcx> {\n         // TODO(antoyo)\n     }\n \n-    fn call(&mut self, _typ: Type<'gcc>, func: RValue<'gcc>, args: &[RValue<'gcc>], funclet: Option<&Funclet>) -> RValue<'gcc> {\n+    fn call(\n+        &mut self,\n+        _typ: Type<'gcc>,\n+        fn_abi: Option<&FnAbi<'tcx, Ty<'tcx>>>,\n+        func: RValue<'gcc>,\n+        args: &[RValue<'gcc>],\n+        funclet: Option<&Funclet>,\n+    ) -> RValue<'gcc> {\n         // FIXME(antoyo): remove when having a proper API.\n         let gcc_func = unsafe { std::mem::transmute(func) };\n-        if self.functions.borrow().values().find(|value| **value == gcc_func).is_some() {\n+        let call = if self.functions.borrow().values().find(|value| **value == gcc_func).is_some() {\n             self.function_call(func, args, funclet)\n         }\n         else {\n             // If it's a not function that was defined, it's a function pointer.\n             self.function_ptr_call(func, args, funclet)\n+        };\n+        if let Some(_fn_abi) = fn_abi {\n+            // TODO(bjorn3): Apply function attributes\n         }\n+        call\n     }\n \n     fn zext(&mut self, value: RValue<'gcc>, dest_typ: Type<'gcc>) -> RValue<'gcc> {"}, {"sha": "81f533288677a3ae1b1767185c30414672256452", "filename": "compiler/rustc_codegen_gcc/src/consts.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_codegen_gcc%2Fsrc%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_codegen_gcc%2Fsrc%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fconsts.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "patch": "@@ -14,6 +14,7 @@ use rustc_target::abi::{self, Align, HasDataLayout, Primitive, Size, WrappingRan\n \n use crate::base;\n use crate::context::CodegenCx;\n+use crate::errors::LinkageConstOrMutType;\n use crate::type_of::LayoutGccExt;\n \n impl<'gcc, 'tcx> CodegenCx<'gcc, 'tcx> {\n@@ -368,10 +369,7 @@ fn check_and_apply_linkage<'gcc, 'tcx>(cx: &CodegenCx<'gcc, 'tcx>, attrs: &Codeg\n                 cx.layout_of(mt.ty).gcc_type(cx, true)\n             }\n             else {\n-                cx.sess().span_fatal(\n-                    span,\n-                    \"must have type `*const T` or `*mut T` due to `#[linkage]` attribute\",\n-                )\n+                cx.sess().emit_fatal(LinkageConstOrMutType { span: span })\n             };\n         // Declare a symbol `foo` with the desired linkage.\n         let global1 = cx.declare_global_with_linkage(&sym, llty2, base::global_linkage_to_gcc(linkage));"}, {"sha": "62a61eb8548da6b9d2a662ddb3be71b139297424", "filename": "compiler/rustc_codegen_gcc/src/context.rs", "status": "modified", "additions": 4, "deletions": 20, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_codegen_gcc%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_codegen_gcc%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fcontext.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "patch": "@@ -13,7 +13,7 @@ use rustc_middle::mir::mono::CodegenUnit;\n use rustc_middle::ty::{self, Instance, ParamEnv, PolyExistentialTraitRef, Ty, TyCtxt};\n use rustc_middle::ty::layout::{FnAbiError, FnAbiOfHelpers, FnAbiRequest, HasParamEnv, HasTyCtxt, LayoutError, TyAndLayout, LayoutOfHelpers};\n use rustc_session::Session;\n-use rustc_span::Span;\n+use rustc_span::{Span, source_map::respan};\n use rustc_target::abi::{call::FnAbi, HasDataLayout, PointeeInfo, Size, TargetDataLayout, VariantIdx};\n use rustc_target::spec::{HasTargetSpec, Target, TlsModel};\n \n@@ -293,7 +293,7 @@ impl<'gcc, 'tcx> CodegenCx<'gcc, 'tcx> {\n         self.is_native_int_type(typ) || self.is_non_native_int_type(typ) || typ.is_compatible_with(self.bool_type)\n     }\n \n-    pub fn sess(&self) -> &Session {\n+    pub fn sess(&self) -> &'tcx Session {\n         &self.tcx.sess\n     }\n \n@@ -416,10 +416,6 @@ impl<'gcc, 'tcx> MiscMethods<'tcx> for CodegenCx<'gcc, 'tcx> {\n         self.codegen_unit\n     }\n \n-    fn used_statics(&self) -> &RefCell<Vec<RValue<'gcc>>> {\n-        unimplemented!();\n-    }\n-\n     fn set_frame_pointer_type(&self, _llfn: RValue<'gcc>) {\n         // TODO(antoyo)\n     }\n@@ -428,10 +424,6 @@ impl<'gcc, 'tcx> MiscMethods<'tcx> for CodegenCx<'gcc, 'tcx> {\n         // TODO(antoyo)\n     }\n \n-    fn create_used_variable(&self) {\n-        unimplemented!();\n-    }\n-\n     fn declare_c_main(&self, fn_type: Self::Type) -> Option<Self::Function> {\n         if self.get_declared_value(\"main\").is_none() {\n             Some(self.declare_cfn(\"main\", fn_type))\n@@ -443,14 +435,6 @@ impl<'gcc, 'tcx> MiscMethods<'tcx> for CodegenCx<'gcc, 'tcx> {\n             None\n         }\n     }\n-\n-    fn compiler_used_statics(&self) -> &RefCell<Vec<RValue<'gcc>>> {\n-        unimplemented!()\n-    }\n-\n-    fn create_compiler_used_variable(&self) {\n-        unimplemented!()\n-    }\n }\n \n impl<'gcc, 'tcx> HasTyCtxt<'tcx> for CodegenCx<'gcc, 'tcx> {\n@@ -477,7 +461,7 @@ impl<'gcc, 'tcx> LayoutOfHelpers<'tcx> for CodegenCx<'gcc, 'tcx> {\n     #[inline]\n     fn handle_layout_err(&self, err: LayoutError<'tcx>, span: Span, ty: Ty<'tcx>) -> ! {\n         if let LayoutError::SizeOverflow(_) = err {\n-            self.sess().span_fatal(span, &err.to_string())\n+            self.sess().emit_fatal(respan(span, err))\n         } else {\n             span_bug!(span, \"failed to get layout for `{}`: {}\", ty, err)\n         }\n@@ -495,7 +479,7 @@ impl<'gcc, 'tcx> FnAbiOfHelpers<'tcx> for CodegenCx<'gcc, 'tcx> {\n         fn_abi_request: FnAbiRequest<'tcx>,\n     ) -> ! {\n         if let FnAbiError::Layout(LayoutError::SizeOverflow(_)) = err {\n-            self.sess().span_fatal(span, &err.to_string())\n+            self.sess().emit_fatal(respan(span, err))\n         } else {\n             match fn_abi_request {\n                 FnAbiRequest::OfFnPtr { sig, extra_args } => {"}, {"sha": "d7816e395c8ebd7e5c225505782fa374621261f0", "filename": "compiler/rustc_codegen_gcc/src/errors.rs", "status": "added", "additions": 242, "deletions": 0, "changes": 242, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_codegen_gcc%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_codegen_gcc%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Ferrors.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "patch": "@@ -0,0 +1,242 @@\n+use rustc_errors::{DiagnosticArgValue, IntoDiagnosticArg};\n+use rustc_macros::Diagnostic;\n+use rustc_middle::ty::Ty;\n+use rustc_span::{Span, Symbol};\n+use std::borrow::Cow;\n+\n+struct ExitCode(Option<i32>);\n+\n+impl IntoDiagnosticArg for ExitCode {\n+    fn into_diagnostic_arg(self) -> DiagnosticArgValue<'static> {\n+        let ExitCode(exit_code) = self;\n+        match exit_code {\n+            Some(t) => t.into_diagnostic_arg(),\n+            None => DiagnosticArgValue::Str(Cow::Borrowed(\"<signal>\")),\n+        }\n+    }\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_gcc::ranlib_failure)]\n+pub(crate) struct RanlibFailure {\n+    exit_code: ExitCode,\n+}\n+\n+impl RanlibFailure {\n+    pub fn new(exit_code: Option<i32>) -> Self {\n+        RanlibFailure { exit_code: ExitCode(exit_code) }\n+    }\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_gcc::invalid_monomorphization_basic_integer, code = \"E0511\")]\n+pub(crate) struct InvalidMonomorphizationBasicInteger<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub name: Symbol,\n+    pub ty: Ty<'a>,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_gcc::invalid_monomorphization_invalid_float_vector, code = \"E0511\")]\n+pub(crate) struct InvalidMonomorphizationInvalidFloatVector<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub name: Symbol,\n+    pub elem_ty: &'a str,\n+    pub vec_ty: Ty<'a>,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_gcc::invalid_monomorphization_not_float, code = \"E0511\")]\n+pub(crate) struct InvalidMonomorphizationNotFloat<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub name: Symbol,\n+    pub ty: Ty<'a>,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_gcc::invalid_monomorphization_unrecognized, code = \"E0511\")]\n+pub(crate) struct InvalidMonomorphizationUnrecognized {\n+    #[primary_span]\n+    pub span: Span,\n+    pub name: Symbol,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_gcc::invalid_monomorphization_expected_signed_unsigned, code = \"E0511\")]\n+pub(crate) struct InvalidMonomorphizationExpectedSignedUnsigned<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub name: Symbol,\n+    pub elem_ty: Ty<'a>,\n+    pub vec_ty: Ty<'a>,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_gcc::invalid_monomorphization_unsupported_element, code = \"E0511\")]\n+pub(crate) struct InvalidMonomorphizationUnsupportedElement<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub name: Symbol,\n+    pub in_ty: Ty<'a>,\n+    pub elem_ty: Ty<'a>,\n+    pub ret_ty: Ty<'a>,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_gcc::invalid_monomorphization_invalid_bitmask, code = \"E0511\")]\n+pub(crate) struct InvalidMonomorphizationInvalidBitmask<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub name: Symbol,\n+    pub ty: Ty<'a>,\n+    pub expected_int_bits: u64,\n+    pub expected_bytes: u64,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_gcc::invalid_monomorphization_simd_shuffle, code = \"E0511\")]\n+pub(crate) struct InvalidMonomorphizationSimdShuffle<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub name: Symbol,\n+    pub ty: Ty<'a>,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_gcc::invalid_monomorphization_expected_simd, code = \"E0511\")]\n+pub(crate) struct InvalidMonomorphizationExpectedSimd<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub name: Symbol,\n+    pub position: &'a str,\n+    pub found_ty: Ty<'a>,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_gcc::invalid_monomorphization_mask_type, code = \"E0511\")]\n+pub(crate) struct InvalidMonomorphizationMaskType<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub name: Symbol,\n+    pub ty: Ty<'a>,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_gcc::invalid_monomorphization_return_length, code = \"E0511\")]\n+pub(crate) struct InvalidMonomorphizationReturnLength<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub name: Symbol,\n+    pub in_len: u64,\n+    pub ret_ty: Ty<'a>,\n+    pub out_len: u64,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_gcc::invalid_monomorphization_return_length_input_type, code = \"E0511\")]\n+pub(crate) struct InvalidMonomorphizationReturnLengthInputType<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub name: Symbol,\n+    pub in_len: u64,\n+    pub in_ty: Ty<'a>,\n+    pub ret_ty: Ty<'a>,\n+    pub out_len: u64,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_gcc::invalid_monomorphization_return_element, code = \"E0511\")]\n+pub(crate) struct InvalidMonomorphizationReturnElement<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub name: Symbol,\n+    pub in_elem: Ty<'a>,\n+    pub in_ty: Ty<'a>,\n+    pub ret_ty: Ty<'a>,\n+    pub out_ty: Ty<'a>,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_gcc::invalid_monomorphization_return_type, code = \"E0511\")]\n+pub(crate) struct InvalidMonomorphizationReturnType<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub name: Symbol,\n+    pub in_elem: Ty<'a>,\n+    pub in_ty: Ty<'a>,\n+    pub ret_ty: Ty<'a>,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_gcc::invalid_monomorphization_inserted_type, code = \"E0511\")]\n+pub(crate) struct InvalidMonomorphizationInsertedType<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub name: Symbol,\n+    pub in_elem: Ty<'a>,\n+    pub in_ty: Ty<'a>,\n+    pub out_ty: Ty<'a>,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_gcc::invalid_monomorphization_return_integer_type, code = \"E0511\")]\n+pub(crate) struct InvalidMonomorphizationReturnIntegerType<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub name: Symbol,\n+    pub ret_ty: Ty<'a>,\n+    pub out_ty: Ty<'a>,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_gcc::invalid_monomorphization_mismatched_lengths, code = \"E0511\")]\n+pub(crate) struct InvalidMonomorphizationMismatchedLengths {\n+    #[primary_span]\n+    pub span: Span,\n+    pub name: Symbol,\n+    pub m_len: u64,\n+    pub v_len: u64,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_gcc::invalid_monomorphization_unsupported_cast, code = \"E0511\")]\n+pub(crate) struct InvalidMonomorphizationUnsupportedCast<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub name: Symbol,\n+    pub in_ty: Ty<'a>,\n+    pub in_elem: Ty<'a>,\n+    pub ret_ty: Ty<'a>,\n+    pub out_elem: Ty<'a>,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_gcc::invalid_monomorphization_unsupported_operation, code = \"E0511\")]\n+pub(crate) struct InvalidMonomorphizationUnsupportedOperation<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub name: Symbol,\n+    pub in_ty: Ty<'a>,\n+    pub in_elem: Ty<'a>,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_gcc::linkage_const_or_mut_type)]\n+pub(crate) struct LinkageConstOrMutType {\n+    #[primary_span]\n+    pub span: Span\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_gcc::lto_not_supported)]\n+pub(crate) struct LTONotSupported;\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_gcc::unwinding_inline_asm)]\n+pub(crate) struct UnwindingInlineAsm {\n+    #[primary_span]\n+    pub span: Span\n+}"}, {"sha": "49be6c649e6521801290099744b7edbe0535a988", "filename": "compiler/rustc_codegen_gcc/src/intrinsic/mod.rs", "status": "modified", "additions": 6, "deletions": 13, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_codegen_gcc%2Fsrc%2Fintrinsic%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_codegen_gcc%2Fsrc%2Fintrinsic%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fintrinsic%2Fmod.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "patch": "@@ -4,7 +4,7 @@ mod simd;\n use gccjit::{ComparisonOp, Function, RValue, ToRValue, Type, UnaryOp, FunctionType};\n use rustc_codegen_ssa::MemFlags;\n use rustc_codegen_ssa::base::wants_msvc_seh;\n-use rustc_codegen_ssa::common::{IntPredicate, span_invalid_monomorphization_error};\n+use rustc_codegen_ssa::common::IntPredicate;\n use rustc_codegen_ssa::mir::operand::{OperandRef, OperandValue};\n use rustc_codegen_ssa::mir::place::PlaceRef;\n use rustc_codegen_ssa::traits::{ArgAbiMethods, BaseTypeMethods, BuilderMethods, ConstMethods, IntrinsicCallMethods};\n@@ -20,6 +20,7 @@ use crate::abi::GccType;\n use crate::builder::Builder;\n use crate::common::{SignType, TypeReflection};\n use crate::context::CodegenCx;\n+use crate::errors::InvalidMonomorphizationBasicInteger;\n use crate::type_of::LayoutGccExt;\n use crate::intrinsic::simd::generic_simd_intrinsic;\n \n@@ -99,7 +100,7 @@ impl<'a, 'gcc, 'tcx> IntrinsicCallMethods<'tcx> for Builder<'a, 'gcc, 'tcx> {\n                 _ if simple.is_some() => {\n                     // FIXME(antoyo): remove this cast when the API supports function.\n                     let func = unsafe { std::mem::transmute(simple.expect(\"simple\")) };\n-                    self.call(self.type_void(), func, &args.iter().map(|arg| arg.immediate()).collect::<Vec<_>>(), None)\n+                    self.call(self.type_void(), None, func, &args.iter().map(|arg| arg.immediate()).collect::<Vec<_>>(), None)\n                 },\n                 sym::likely => {\n                     self.expect(args[0].immediate(), true)\n@@ -242,15 +243,7 @@ impl<'a, 'gcc, 'tcx> IntrinsicCallMethods<'tcx> for Builder<'a, 'gcc, 'tcx> {\n                                 _ => bug!(),\n                             },\n                             None => {\n-                                span_invalid_monomorphization_error(\n-                                    tcx.sess,\n-                                    span,\n-                                    &format!(\n-                                        \"invalid monomorphization of `{}` intrinsic: \\\n-                                      expected basic integer type, found `{}`\",\n-                                      name, ty\n-                                    ),\n-                                );\n+                                tcx.sess.emit_err(InvalidMonomorphizationBasicInteger { span, name, ty });\n                                 return;\n                             }\n                         }\n@@ -348,7 +341,7 @@ impl<'a, 'gcc, 'tcx> IntrinsicCallMethods<'tcx> for Builder<'a, 'gcc, 'tcx> {\n     fn abort(&mut self) {\n         let func = self.context.get_builtin_function(\"abort\");\n         let func: RValue<'gcc> = unsafe { std::mem::transmute(func) };\n-        self.call(self.type_void(), func, &[], None);\n+        self.call(self.type_void(), None, func, &[], None);\n     }\n \n     fn assume(&mut self, value: Self::Value) {\n@@ -1131,7 +1124,7 @@ fn try_intrinsic<'gcc, 'tcx>(bx: &mut Builder<'_, 'gcc, 'tcx>, try_func: RValue<\n     // NOTE: the `|| true` here is to use the panic=abort strategy with panic=unwind too\n     if bx.sess().panic_strategy() == PanicStrategy::Abort || true {\n         // TODO(bjorn3): Properly implement unwinding and remove the `|| true` once this is done.\n-        bx.call(bx.type_void(), try_func, &[data], None);\n+        bx.call(bx.type_void(), None, try_func, &[data], None);\n         // Return 0 unconditionally from the intrinsic call;\n         // we can never unwind.\n         let ret_align = bx.tcx.data_layout.i32_align.abi;"}, {"sha": "12e416f62a4e084b49bb0425d526e2c41897057a", "filename": "compiler/rustc_codegen_gcc/src/intrinsic/simd.rs", "status": "modified", "additions": 61, "deletions": 143, "changes": 204, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_codegen_gcc%2Fsrc%2Fintrinsic%2Fsimd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_codegen_gcc%2Fsrc%2Fintrinsic%2Fsimd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fintrinsic%2Fsimd.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "patch": "@@ -2,7 +2,7 @@ use std::cmp::Ordering;\n \n use gccjit::{BinaryOp, RValue, Type, ToRValue};\n use rustc_codegen_ssa::base::compare_simd_types;\n-use rustc_codegen_ssa::common::{TypeKind, span_invalid_monomorphization_error};\n+use rustc_codegen_ssa::common::TypeKind;\n use rustc_codegen_ssa::mir::operand::OperandRef;\n use rustc_codegen_ssa::mir::place::PlaceRef;\n use rustc_codegen_ssa::traits::{BaseTypeMethods, BuilderMethods};\n@@ -14,43 +14,48 @@ use rustc_span::{Span, Symbol, sym};\n use rustc_target::abi::Align;\n \n use crate::builder::Builder;\n+use crate::errors::{\n+    InvalidMonomorphizationInvalidFloatVector,\n+    InvalidMonomorphizationNotFloat,\n+    InvalidMonomorphizationUnrecognized,\n+    InvalidMonomorphizationExpectedSignedUnsigned,\n+    InvalidMonomorphizationUnsupportedElement,\n+    InvalidMonomorphizationInvalidBitmask,\n+    InvalidMonomorphizationSimdShuffle,\n+    InvalidMonomorphizationExpectedSimd,\n+    InvalidMonomorphizationMaskType,\n+    InvalidMonomorphizationReturnLength,\n+    InvalidMonomorphizationReturnLengthInputType,\n+    InvalidMonomorphizationReturnElement,\n+    InvalidMonomorphizationReturnType,\n+    InvalidMonomorphizationInsertedType,\n+    InvalidMonomorphizationReturnIntegerType,\n+    InvalidMonomorphizationMismatchedLengths,\n+    InvalidMonomorphizationUnsupportedCast,\n+    InvalidMonomorphizationUnsupportedOperation\n+};\n use crate::intrinsic;\n \n pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(bx: &mut Builder<'a, 'gcc, 'tcx>, name: Symbol, callee_ty: Ty<'tcx>, args: &[OperandRef<'tcx, RValue<'gcc>>], ret_ty: Ty<'tcx>, llret_ty: Type<'gcc>, span: Span) -> Result<RValue<'gcc>, ()> {\n     // macros for error handling:\n-    #[allow(unused_macro_rules)]\n-    macro_rules! emit_error {\n-        ($msg: tt) => {\n-            emit_error!($msg, )\n-        };\n-        ($msg: tt, $($fmt: tt)*) => {\n-            span_invalid_monomorphization_error(\n-                bx.sess(), span,\n-                &format!(concat!(\"invalid monomorphization of `{}` intrinsic: \", $msg),\n-                         name, $($fmt)*));\n-        }\n-    }\n-\n     macro_rules! return_error {\n-        ($($fmt: tt)*) => {\n+        ($err:expr) => {\n             {\n-                emit_error!($($fmt)*);\n+                bx.sess().emit_err($err);\n                 return Err(());\n             }\n         }\n     }\n-\n     macro_rules! require {\n-        ($cond: expr, $($fmt: tt)*) => {\n+        ($cond:expr, $err:expr) => {\n             if !$cond {\n-                return_error!($($fmt)*);\n+                return_error!($err);\n             }\n-        };\n+        }\n     }\n-\n     macro_rules! require_simd {\n         ($ty: expr, $position: expr) => {\n-            require!($ty.is_simd(), \"expected SIMD {} type, found non-SIMD `{}`\", $position, $ty)\n+            require!($ty.is_simd(), InvalidMonomorphizationExpectedSimd { span, name, position: $position, found_ty: $ty })\n         };\n     }\n \n@@ -82,10 +87,7 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(bx: &mut Builder<'a, 'gcc, 'tcx>,\n                 bx.load(int_ty, ptr, Align::ONE)\n             }\n             _ => return_error!(\n-                \"invalid bitmask `{}`, expected `u{}` or `[u8; {}]`\",\n-                mask_ty,\n-                expected_int_bits,\n-                expected_bytes\n+                InvalidMonomorphizationInvalidBitmask { span, name, ty: mask_ty, expected_int_bits, expected_bytes }\n             ),\n         };\n \n@@ -127,18 +129,11 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(bx: &mut Builder<'a, 'gcc, 'tcx>,\n         let (out_len, out_ty) = ret_ty.simd_size_and_type(bx.tcx());\n         require!(\n             in_len == out_len,\n-            \"expected return type with length {} (same as input type `{}`), \\\n-             found `{}` with length {}\",\n-            in_len,\n-            in_ty,\n-            ret_ty,\n-            out_len\n+            InvalidMonomorphizationReturnLengthInputType { span, name, in_len, in_ty, ret_ty, out_len }\n         );\n         require!(\n             bx.type_kind(bx.element_type(llret_ty)) == TypeKind::Integer,\n-            \"expected return type with integer elements, found `{}` with non-integer `{}`\",\n-            ret_ty,\n-            out_ty\n+            InvalidMonomorphizationReturnIntegerType {span, name, ret_ty, out_ty}\n         );\n \n         return Ok(compare_simd_types(\n@@ -163,8 +158,7 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(bx: &mut Builder<'a, 'gcc, 'tcx>,\n                         })\n                     }\n                     _ => return_error!(\n-                        \"simd_shuffle index must be an array of `u32`, got `{}`\",\n-                        args[2].layout.ty\n+                        InvalidMonomorphizationSimdShuffle { span, name, ty: args[2].layout.ty }\n                     ),\n                 }\n             }\n@@ -179,19 +173,11 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(bx: &mut Builder<'a, 'gcc, 'tcx>,\n         let (out_len, out_ty) = ret_ty.simd_size_and_type(bx.tcx());\n         require!(\n             out_len == n,\n-            \"expected return type of length {}, found `{}` with length {}\",\n-            n,\n-            ret_ty,\n-            out_len\n+            InvalidMonomorphizationReturnLength { span, name, in_len: n, ret_ty, out_len }\n         );\n         require!(\n             in_elem == out_ty,\n-            \"expected return element type `{}` (element of input `{}`), \\\n-             found `{}` with element type `{}`\",\n-            in_elem,\n-            in_ty,\n-            ret_ty,\n-            out_ty\n+            InvalidMonomorphizationReturnElement { span, name, in_elem, in_ty, ret_ty, out_ty }\n         );\n \n         let vector = args[2].immediate();\n@@ -207,10 +193,7 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(bx: &mut Builder<'a, 'gcc, 'tcx>,\n     if name == sym::simd_insert {\n         require!(\n             in_elem == arg_tys[2],\n-            \"expected inserted type `{}` (element of input `{}`), found `{}`\",\n-            in_elem,\n-            in_ty,\n-            arg_tys[2]\n+            InvalidMonomorphizationInsertedType { span, name, in_elem, in_ty, out_ty: arg_tys[2] }\n         );\n         let vector = args[0].immediate();\n         let index = args[1].immediate();\n@@ -263,10 +246,7 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(bx: &mut Builder<'a, 'gcc, 'tcx>,\n     if name == sym::simd_extract {\n         require!(\n             ret_ty == in_elem,\n-            \"expected return type `{}` (element of input `{}`), found `{}`\",\n-            in_elem,\n-            in_ty,\n-            ret_ty\n+            InvalidMonomorphizationReturnType { span, name, in_elem, in_ty, ret_ty }\n         );\n         let vector = args[0].immediate();\n         return Ok(bx.context.new_vector_access(None, vector, args[1].immediate()).to_rvalue());\n@@ -279,13 +259,11 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(bx: &mut Builder<'a, 'gcc, 'tcx>,\n         let (v_len, _) = arg_tys[1].simd_size_and_type(bx.tcx());\n         require!(\n             m_len == v_len,\n-            \"mismatched lengths: mask length `{}` != other vector length `{}`\",\n-            m_len,\n-            v_len\n+            InvalidMonomorphizationMismatchedLengths { span, name, m_len, v_len }\n         );\n         match m_elem_ty.kind() {\n             ty::Int(_) => {}\n-            _ => return_error!(\"mask element type is `{}`, expected `i_`\", m_elem_ty),\n+            _ => return_error!(InvalidMonomorphizationMaskType { span, name, ty: m_elem_ty }),\n         }\n         return Ok(bx.vector_select(args[0].immediate(), args[1].immediate(), args[2].immediate()));\n     }\n@@ -295,12 +273,7 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(bx: &mut Builder<'a, 'gcc, 'tcx>,\n         let (out_len, out_elem) = ret_ty.simd_size_and_type(bx.tcx());\n         require!(\n             in_len == out_len,\n-            \"expected return type with length {} (same as input type `{}`), \\\n-                  found `{}` with length {}\",\n-            in_len,\n-            in_ty,\n-            ret_ty,\n-            out_len\n+            InvalidMonomorphizationReturnLengthInputType { span, name, in_len, in_ty, ret_ty, out_len }\n         );\n         // casting cares about nominal type, not just structural type\n         if in_elem == out_elem {\n@@ -412,13 +385,8 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(bx: &mut Builder<'a, 'gcc, 'tcx>,\n             }\n             _ => { /* Unsupported. Fallthrough. */ }\n         }\n-        require!(\n-            false,\n-            \"unsupported cast from `{}` with element `{}` to `{}` with element `{}`\",\n-            in_ty,\n-            in_elem,\n-            ret_ty,\n-            out_elem\n+        return_error!(\n+            InvalidMonomorphizationUnsupportedCast { span, name, in_ty, in_elem, ret_ty, out_elem }\n         );\n     }\n \n@@ -431,10 +399,7 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(bx: &mut Builder<'a, 'gcc, 'tcx>,\n                     })*\n                     _ => {},\n                 }\n-                require!(false,\n-                         \"unsupported operation on `{}` with element `{}`\",\n-                         in_ty,\n-                         in_elem)\n+                return_error!(InvalidMonomorphizationUnsupportedOperation { span, name, in_ty, in_elem })\n             })*\n         }\n     }\n@@ -448,40 +413,27 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(bx: &mut Builder<'a, 'gcc, 'tcx>,\n         span: Span,\n         args: &[OperandRef<'tcx, RValue<'gcc>>],\n     ) -> Result<RValue<'gcc>, ()> {\n-        macro_rules! emit_error {\n-            ($msg: tt, $($fmt: tt)*) => {\n-                span_invalid_monomorphization_error(\n-                    bx.sess(), span,\n-                    &format!(concat!(\"invalid monomorphization of `{}` intrinsic: \", $msg),\n-                             name, $($fmt)*));\n-            }\n-        }\n         macro_rules! return_error {\n-            ($($fmt: tt)*) => {\n+            ($err:expr) => {\n                 {\n-                    emit_error!($($fmt)*);\n+                    bx.sess().emit_err($err);\n                     return Err(());\n                 }\n             }\n         }\n-\n         let (elem_ty_str, elem_ty) =\n             if let ty::Float(f) = in_elem.kind() {\n                 let elem_ty = bx.cx.type_float_from_ty(*f);\n                 match f.bit_width() {\n                     32 => (\"f32\", elem_ty),\n                     64 => (\"f64\", elem_ty),\n                     _ => {\n-                        return_error!(\n-                            \"unsupported element type `{}` of floating-point vector `{}`\",\n-                            f.name_str(),\n-                            in_ty\n-                        );\n+                        return_error!(InvalidMonomorphizationInvalidFloatVector { span, name, elem_ty: f.name_str(), vec_ty: in_ty });\n                     }\n                 }\n             }\n             else {\n-                return_error!(\"`{}` is not a floating-point type\", in_ty);\n+                return_error!(InvalidMonomorphizationNotFloat { span, name, ty: in_ty });\n             };\n \n         let vec_ty = bx.cx.type_vector(elem_ty, in_len);\n@@ -504,12 +456,12 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(bx: &mut Builder<'a, 'gcc, 'tcx>,\n                 sym::simd_fsqrt => (\"sqrt\", bx.type_func(&[vec_ty], vec_ty)),\n                 sym::simd_round => (\"round\", bx.type_func(&[vec_ty], vec_ty)),\n                 sym::simd_trunc => (\"trunc\", bx.type_func(&[vec_ty], vec_ty)),\n-                _ => return_error!(\"unrecognized intrinsic `{}`\", name),\n+                _ => return_error!(InvalidMonomorphizationUnrecognized { span, name })\n             };\n         let llvm_name = &format!(\"llvm.{0}.v{1}{2}\", intr_name, in_len, elem_ty_str);\n         let function = intrinsic::llvm::intrinsic(llvm_name, &bx.cx);\n         let function: RValue<'gcc> = unsafe { std::mem::transmute(function) };\n-        let c = bx.call(fn_ty, function, &args.iter().map(|arg| arg.immediate()).collect::<Vec<_>>(), None);\n+        let c = bx.call(fn_ty, None, function, &args.iter().map(|arg| arg.immediate()).collect::<Vec<_>>(), None);\n         Ok(c)\n     }\n \n@@ -557,10 +509,7 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(bx: &mut Builder<'a, 'gcc, 'tcx>,\n                     })*\n                     _ => {},\n                 }\n-                require!(false,\n-                         \"unsupported operation on `{}` with element `{}`\",\n-                         in_ty,\n-                         in_elem)\n+                return_error!(InvalidMonomorphizationUnsupportedOperation { span, name, in_ty, in_elem })\n             })*\n         }\n     }\n@@ -579,12 +528,12 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(bx: &mut Builder<'a, 'gcc, 'tcx>,\n             ty::Int(i) => (true, i.bit_width().unwrap_or(ptr_bits), bx.cx.type_int_from_ty(i)),\n             ty::Uint(i) => (false, i.bit_width().unwrap_or(ptr_bits), bx.cx.type_uint_from_ty(i)),\n             _ => {\n-                return_error!(\n-                    \"expected element type `{}` of vector type `{}` \\\n-                     to be a signed or unsigned integer type\",\n-                    arg_tys[0].simd_size_and_type(bx.tcx()).1,\n-                    arg_tys[0]\n-                );\n+                return_error!(InvalidMonomorphizationExpectedSignedUnsigned {\n+                    span,\n+                    name,\n+                    elem_ty: arg_tys[0].simd_size_and_type(bx.tcx()).1,\n+                    vec_ty: arg_tys[0],\n+                });\n             }\n         };\n         let builtin_name =\n@@ -617,10 +566,7 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(bx: &mut Builder<'a, 'gcc, 'tcx>,\n             if name == sym::$name {\n                 require!(\n                     ret_ty == in_elem,\n-                    \"expected return type `{}` (element of input `{}`), found `{}`\",\n-                    in_elem,\n-                    in_ty,\n-                    ret_ty\n+                    InvalidMonomorphizationReturnType { span, name, in_elem, in_ty, ret_ty }\n                 );\n                 return match in_elem.kind() {\n                     ty::Int(_) | ty::Uint(_) => {\n@@ -644,13 +590,7 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(bx: &mut Builder<'a, 'gcc, 'tcx>,\n                             Ok(bx.vector_reduce_op(args[0].immediate(), $vec_op))\n                         }\n                     }\n-                    _ => return_error!(\n-                        \"unsupported {} from `{}` with element `{}` to `{}`\",\n-                        sym::$name,\n-                        in_ty,\n-                        in_elem,\n-                        ret_ty\n-                    ),\n+                    _ => return_error!(InvalidMonomorphizationUnsupportedElement { span, name, in_ty, elem_ty: in_elem, ret_ty }),\n                 };\n             }\n         };\n@@ -676,20 +616,11 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(bx: &mut Builder<'a, 'gcc, 'tcx>,\n             if name == sym::$name {\n                 require!(\n                     ret_ty == in_elem,\n-                    \"expected return type `{}` (element of input `{}`), found `{}`\",\n-                    in_elem,\n-                    in_ty,\n-                    ret_ty\n+                    InvalidMonomorphizationReturnType { span, name, in_elem, in_ty, ret_ty }\n                 );\n                 return match in_elem.kind() {\n                     ty::Int(_) | ty::Uint(_) | ty::Float(_) => Ok(bx.$reduction(args[0].immediate())),\n-                    _ => return_error!(\n-                        \"unsupported {} from `{}` with element `{}` to `{}`\",\n-                        sym::$name,\n-                        in_ty,\n-                        in_elem,\n-                        ret_ty\n-                    ),\n+                    _ => return_error!(InvalidMonomorphizationUnsupportedElement { span, name, in_ty, elem_ty: in_elem, ret_ty }),\n                 };\n             }\n         };\n@@ -704,22 +635,13 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(bx: &mut Builder<'a, 'gcc, 'tcx>,\n                 let input = if !$boolean {\n                     require!(\n                         ret_ty == in_elem,\n-                        \"expected return type `{}` (element of input `{}`), found `{}`\",\n-                        in_elem,\n-                        in_ty,\n-                        ret_ty\n+                        InvalidMonomorphizationReturnType { span, name, in_elem, in_ty, ret_ty }\n                     );\n                     args[0].immediate()\n                 } else {\n                     match in_elem.kind() {\n                         ty::Int(_) | ty::Uint(_) => {}\n-                        _ => return_error!(\n-                            \"unsupported {} from `{}` with element `{}` to `{}`\",\n-                            sym::$name,\n-                            in_ty,\n-                            in_elem,\n-                            ret_ty\n-                        ),\n+                        _ => return_error!(InvalidMonomorphizationUnsupportedElement { span, name, in_ty, elem_ty: in_elem, ret_ty }),\n                     }\n \n                     // boolean reductions operate on vectors of i1s:\n@@ -733,11 +655,7 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(bx: &mut Builder<'a, 'gcc, 'tcx>,\n                         Ok(if !$boolean { r } else { bx.zext(r, bx.type_bool()) })\n                     }\n                     _ => return_error!(\n-                        \"unsupported {} from `{}` with element `{}` to `{}`\",\n-                        sym::$name,\n-                        in_ty,\n-                        in_elem,\n-                        ret_ty\n+                        InvalidMonomorphizationUnsupportedElement { span, name, in_ty, elem_ty: in_elem, ret_ty }\n                     ),\n                 };\n             }"}, {"sha": "accd02ab0026991fa389acd7e6e0c97ab748948a", "filename": "compiler/rustc_codegen_gcc/src/lib.rs", "status": "modified", "additions": 6, "deletions": 11, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_codegen_gcc%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_codegen_gcc%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Flib.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "patch": "@@ -18,13 +18,16 @@\n #![recursion_limit=\"256\"]\n #![warn(rust_2018_idioms)]\n #![warn(unused_lifetimes)]\n+#![deny(rustc::untranslatable_diagnostic)]\n+#![deny(rustc::diagnostic_outside_of_impl)]\n \n extern crate rustc_apfloat;\n extern crate rustc_ast;\n extern crate rustc_codegen_ssa;\n extern crate rustc_data_structures;\n extern crate rustc_errors;\n extern crate rustc_hir;\n+extern crate rustc_macros;\n extern crate rustc_metadata;\n extern crate rustc_middle;\n extern crate rustc_session;\n@@ -50,6 +53,7 @@ mod context;\n mod coverageinfo;\n mod debuginfo;\n mod declare;\n+mod errors;\n mod int;\n mod intrinsic;\n mod mono_item;\n@@ -59,6 +63,7 @@ mod type_of;\n use std::any::Any;\n use std::sync::{Arc, Mutex};\n \n+use crate::errors::LTONotSupported;\n use gccjit::{Context, OptimizationLevel, CType};\n use rustc_ast::expand::allocator::AllocatorKind;\n use rustc_codegen_ssa::{CodegenResults, CompiledModule, ModuleCodegen};\n@@ -97,7 +102,7 @@ pub struct GccCodegenBackend {\n impl CodegenBackend for GccCodegenBackend {\n     fn init(&self, sess: &Session) {\n         if sess.lto() != Lto::No {\n-            sess.warn(\"LTO is not supported. You may get a linker error.\");\n+            sess.emit_warning(LTONotSupported {});\n         }\n \n         let temp_dir = TempDir::new().expect(\"cannot create temporary directory\");\n@@ -166,15 +171,6 @@ impl ExtraBackendMethods for GccCodegenBackend {\n             Ok(())\n         })\n     }\n-\n-    fn target_cpu<'b>(&self, _sess: &'b Session) -> &'b str {\n-        unimplemented!();\n-    }\n-\n-    fn tune_cpu<'b>(&self, _sess: &'b Session) -> Option<&'b str> {\n-        None\n-        // TODO(antoyo)\n-    }\n }\n \n pub struct ModuleBuffer;\n@@ -205,7 +201,6 @@ impl WriteBackendMethods for GccCodegenBackend {\n     type Module = GccContext;\n     type TargetMachine = ();\n     type ModuleBuffer = ModuleBuffer;\n-    type Context = ();\n     type ThinData = ();\n     type ThinBuffer = ThinBuffer;\n "}, {"sha": "38c1eac7adf6966c9d8b6d88ce0df853ed4152b7", "filename": "compiler/rustc_codegen_gcc/tests/run/asm.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Fasm.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "patch": "@@ -3,11 +3,12 @@\n // Run-time:\n //   status: 0\n \n-#![feature(asm_const, asm_sym)]\n+#![feature(asm_const)]\n \n use std::arch::{asm, global_asm};\n \n-global_asm!(\"\n+global_asm!(\n+    \"\n     .global add_asm\n add_asm:\n      mov rax, rdi\n@@ -132,7 +133,9 @@ fn main() {\n     assert_eq!(x, 43);\n \n     // check sym fn\n-    extern \"C\" fn foo() -> u64 { 42 }\n+    extern \"C\" fn foo() -> u64 {\n+        42\n+    }\n     let x: u64;\n     unsafe {\n         asm!(\"call {}\", sym foo, lateout(\"rax\") x);"}, {"sha": "75779622b54cd2d255b1781074bdf3932ddf8796", "filename": "compiler/rustc_codegen_gcc/tests/run/int.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Fint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Fint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Fint.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "patch": "@@ -3,7 +3,7 @@\n // Run-time:\n //   status: 0\n \n-#![feature(bench_black_box, const_black_box, core_intrinsics, start)]\n+#![feature(const_black_box, core_intrinsics, start)]\n \n #![no_std]\n "}, {"sha": "0ad39c24025fd6ba8e8b19642f45b0836bf2386c", "filename": "compiler/rustc_codegen_llvm/Cargo.toml", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_codegen_llvm%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_codegen_llvm%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2FCargo.toml?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "patch": "@@ -5,13 +5,11 @@ edition = \"2021\"\n \n [lib]\n test = false\n-doctest = false\n \n [dependencies]\n bitflags = \"1.0\"\n cstr = \"0.2\"\n libc = \"0.2\"\n-libloading = \"0.7.1\"\n measureme = \"10.0.0\"\n object = { version = \"0.29.0\", default-features = false, features = [\"std\", \"read_core\", \"archive\", \"coff\", \"elf\", \"macho\", \"pe\"] }\n tracing = \"0.1\"\n@@ -35,3 +33,4 @@ rustc_target = { path = \"../rustc_target\" }\n smallvec = { version = \"1.8.1\", features = [\"union\", \"may_dangle\"] }\n rustc_ast = { path = \"../rustc_ast\" }\n rustc_span = { path = \"../rustc_span\" }\n+tempfile = \"3.2.0\""}, {"sha": "d478efc863a9e21fb7cb3863ed1bce2200e015b7", "filename": "compiler/rustc_codegen_llvm/src/abi.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_codegen_llvm%2Fsrc%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_codegen_llvm%2Fsrc%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fabi.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "patch": "@@ -592,10 +592,6 @@ impl<'ll, 'tcx> FnAbiLlvmExt<'ll, 'tcx> for FnAbi<'tcx, Ty<'tcx>> {\n }\n \n impl<'tcx> AbiBuilderMethods<'tcx> for Builder<'_, '_, 'tcx> {\n-    fn apply_attrs_callsite(&mut self, fn_abi: &FnAbi<'tcx, Ty<'tcx>>, callsite: Self::Value) {\n-        fn_abi.apply_attrs_callsite(self, callsite)\n-    }\n-\n     fn get_param(&mut self, index: usize) -> Self::Value {\n         llvm::get_param(self.llfn(), index as c_uint)\n     }"}, {"sha": "017513721b75bee6326b757f1e3408aaf07d97b6", "filename": "compiler/rustc_codegen_llvm/src/asm.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_codegen_llvm%2Fsrc%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_codegen_llvm%2Fsrc%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fasm.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "patch": "@@ -430,9 +430,9 @@ pub(crate) fn inline_asm_call<'ll>(\n             );\n \n             let call = if let Some((dest, catch, funclet)) = dest_catch_funclet {\n-                bx.invoke(fty, v, inputs, dest, catch, funclet)\n+                bx.invoke(fty, None, v, inputs, dest, catch, funclet)\n             } else {\n-                bx.call(fty, v, inputs, None)\n+                bx.call(fty, None, v, inputs, None)\n             };\n \n             // Store mark in a metadata node so we can map LLVM errors\n@@ -551,6 +551,8 @@ fn reg_to_llvm(reg: InlineAsmRegOrRegClass, layout: Option<&TyAndLayout<'_>>) ->\n                 format!(\"{{{}}}\", reg.name())\n             }\n         }\n+        // The constraints can be retrieved from\n+        // https://llvm.org/docs/LangRef.html#supported-constraint-code-list\n         InlineAsmRegOrRegClass::RegClass(reg) => match reg {\n             InlineAsmRegClass::AArch64(AArch64InlineAsmRegClass::reg) => \"r\",\n             InlineAsmRegClass::AArch64(AArch64InlineAsmRegClass::vreg) => \"w\",\n@@ -624,6 +626,8 @@ fn modifier_to_llvm(\n     reg: InlineAsmRegClass,\n     modifier: Option<char>,\n ) -> Option<char> {\n+    // The modifiers can be retrieved from\n+    // https://llvm.org/docs/LangRef.html#asm-template-argument-modifiers\n     match reg {\n         InlineAsmRegClass::AArch64(AArch64InlineAsmRegClass::reg) => modifier,\n         InlineAsmRegClass::AArch64(AArch64InlineAsmRegClass::vreg)"}, {"sha": "20a063f80fd00d2e0a89535b943086b4e4a945a5", "filename": "compiler/rustc_codegen_llvm/src/back/archive.rs", "status": "modified", "additions": 64, "deletions": 3, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Farchive.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "patch": "@@ -2,16 +2,20 @@\n \n use std::env;\n use std::ffi::{CStr, CString, OsString};\n-use std::io;\n+use std::fs;\n+use std::io::{self, Write};\n use std::mem;\n use std::path::{Path, PathBuf};\n use std::ptr;\n use std::str;\n \n+use object::read::macho::FatArch;\n+\n use crate::common;\n use crate::llvm::archive_ro::{ArchiveRO, Child};\n use crate::llvm::{self, ArchiveKind, LLVMMachineType, LLVMRustCOFFShortExport};\n use rustc_codegen_ssa::back::archive::{ArchiveBuilder, ArchiveBuilderBuilder};\n+use rustc_data_structures::memmap::Mmap;\n use rustc_session::cstore::DllImport;\n use rustc_session::Session;\n \n@@ -53,21 +57,78 @@ fn llvm_machine_type(cpu: &str) -> LLVMMachineType {\n     }\n }\n \n+fn try_filter_fat_archs(\n+    archs: object::read::Result<&[impl FatArch]>,\n+    target_arch: object::Architecture,\n+    archive_path: &Path,\n+    archive_map_data: &[u8],\n+) -> io::Result<Option<PathBuf>> {\n+    let archs = archs.map_err(|e| io::Error::new(io::ErrorKind::Other, e))?;\n+\n+    let desired = match archs.iter().filter(|a| a.architecture() == target_arch).next() {\n+        Some(a) => a,\n+        None => return Ok(None),\n+    };\n+\n+    let (mut new_f, extracted_path) = tempfile::Builder::new()\n+        .suffix(archive_path.file_name().unwrap())\n+        .tempfile()?\n+        .keep()\n+        .unwrap();\n+\n+    new_f.write_all(\n+        desired.data(archive_map_data).map_err(|e| io::Error::new(io::ErrorKind::Other, e))?,\n+    )?;\n+\n+    Ok(Some(extracted_path))\n+}\n+\n+fn try_extract_macho_fat_archive(\n+    sess: &Session,\n+    archive_path: &Path,\n+) -> io::Result<Option<PathBuf>> {\n+    let archive_map = unsafe { Mmap::map(fs::File::open(&archive_path)?)? };\n+    let target_arch = match sess.target.arch.as_ref() {\n+        \"aarch64\" => object::Architecture::Aarch64,\n+        \"x86_64\" => object::Architecture::X86_64,\n+        _ => return Ok(None),\n+    };\n+\n+    match object::macho::FatHeader::parse(&*archive_map) {\n+        Ok(h) if h.magic.get(object::endian::BigEndian) == object::macho::FAT_MAGIC => {\n+            let archs = object::macho::FatHeader::parse_arch32(&*archive_map);\n+            try_filter_fat_archs(archs, target_arch, archive_path, &*archive_map)\n+        }\n+        Ok(h) if h.magic.get(object::endian::BigEndian) == object::macho::FAT_MAGIC_64 => {\n+            let archs = object::macho::FatHeader::parse_arch64(&*archive_map);\n+            try_filter_fat_archs(archs, target_arch, archive_path, &*archive_map)\n+        }\n+        // Not a FatHeader at all, just return None.\n+        _ => Ok(None),\n+    }\n+}\n+\n impl<'a> ArchiveBuilder<'a> for LlvmArchiveBuilder<'a> {\n     fn add_archive(\n         &mut self,\n         archive: &Path,\n         skip: Box<dyn FnMut(&str) -> bool + 'static>,\n     ) -> io::Result<()> {\n-        let archive_ro = match ArchiveRO::open(archive) {\n+        let mut archive = archive.to_path_buf();\n+        if self.sess.target.llvm_target.contains(\"-apple-macosx\") {\n+            if let Some(new_archive) = try_extract_macho_fat_archive(&self.sess, &archive)? {\n+                archive = new_archive\n+            }\n+        }\n+        let archive_ro = match ArchiveRO::open(&archive) {\n             Ok(ar) => ar,\n             Err(e) => return Err(io::Error::new(io::ErrorKind::Other, e)),\n         };\n         if self.additions.iter().any(|ar| ar.path() == archive) {\n             return Ok(());\n         }\n         self.additions.push(Addition::Archive {\n-            path: archive.to_path_buf(),\n+            path: archive,\n             archive: archive_ro,\n             skip: Box::new(skip),\n         });"}, {"sha": "cef7bf1e8034d2ea09d9bd4d6c61edd20c7ab13d", "filename": "compiler/rustc_codegen_llvm/src/back/lto.rs", "status": "modified", "additions": 7, "deletions": 61, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Flto.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "patch": "@@ -1,8 +1,6 @@\n-use crate::back::write::{\n-    self, save_temp_bitcode, to_llvm_opt_settings, with_llvm_pmb, DiagnosticHandlers,\n-};\n-use crate::llvm::{self, build_string, False, True};\n-use crate::{llvm_util, LlvmCodegenBackend, ModuleLlvm};\n+use crate::back::write::{self, save_temp_bitcode, DiagnosticHandlers};\n+use crate::llvm::{self, build_string};\n+use crate::{LlvmCodegenBackend, ModuleLlvm};\n use object::read::archive::ArchiveFile;\n use rustc_codegen_ssa::back::lto::{LtoModuleCodegen, SerializedModule, ThinModule, ThinShared};\n use rustc_codegen_ssa::back::symbol_export;\n@@ -575,7 +573,7 @@ pub(crate) fn run_pass_manager(\n     module: &mut ModuleCodegen<ModuleLlvm>,\n     thin: bool,\n ) -> Result<(), FatalError> {\n-    let _timer = cgcx.prof.extra_verbose_generic_activity(\"LLVM_lto_optimize\", &*module.name);\n+    let _timer = cgcx.prof.verbose_generic_activity_with_arg(\"LLVM_lto_optimize\", &*module.name);\n     let config = cgcx.config(module.kind);\n \n     // Now we have one massive module inside of llmod. Time to run the\n@@ -597,61 +595,9 @@ pub(crate) fn run_pass_manager(\n                 1,\n             );\n         }\n-        if llvm_util::should_use_new_llvm_pass_manager(\n-            &config.new_llvm_pass_manager,\n-            &cgcx.target_arch,\n-        ) {\n-            let opt_stage = if thin { llvm::OptStage::ThinLTO } else { llvm::OptStage::FatLTO };\n-            let opt_level = config.opt_level.unwrap_or(config::OptLevel::No);\n-            write::optimize_with_new_llvm_pass_manager(\n-                cgcx,\n-                diag_handler,\n-                module,\n-                config,\n-                opt_level,\n-                opt_stage,\n-            )?;\n-            debug!(\"lto done\");\n-            return Ok(());\n-        }\n-\n-        let pm = llvm::LLVMCreatePassManager();\n-        llvm::LLVMAddAnalysisPasses(module.module_llvm.tm, pm);\n-\n-        if config.verify_llvm_ir {\n-            let pass = llvm::LLVMRustFindAndCreatePass(\"verify\\0\".as_ptr().cast());\n-            llvm::LLVMRustAddPass(pm, pass.unwrap());\n-        }\n-\n-        let opt_level = config\n-            .opt_level\n-            .map(|x| to_llvm_opt_settings(x).0)\n-            .unwrap_or(llvm::CodeGenOptLevel::None);\n-        with_llvm_pmb(module.module_llvm.llmod(), config, opt_level, false, &mut |b| {\n-            if thin {\n-                llvm::LLVMRustPassManagerBuilderPopulateThinLTOPassManager(b, pm);\n-            } else {\n-                llvm::LLVMRustPassManagerBuilderPopulateLTOPassManager(\n-                    b, pm, /* Internalize = */ False, /* RunInliner = */ True,\n-                );\n-            }\n-        });\n-\n-        // We always generate bitcode through ThinLTOBuffers,\n-        // which do not support anonymous globals\n-        if config.bitcode_needed() {\n-            let pass = llvm::LLVMRustFindAndCreatePass(\"name-anon-globals\\0\".as_ptr().cast());\n-            llvm::LLVMRustAddPass(pm, pass.unwrap());\n-        }\n-\n-        if config.verify_llvm_ir {\n-            let pass = llvm::LLVMRustFindAndCreatePass(\"verify\\0\".as_ptr().cast());\n-            llvm::LLVMRustAddPass(pm, pass.unwrap());\n-        }\n-\n-        llvm::LLVMRunPassManager(pm, module.module_llvm.llmod());\n-\n-        llvm::LLVMDisposePassManager(pm);\n+        let opt_stage = if thin { llvm::OptStage::ThinLTO } else { llvm::OptStage::FatLTO };\n+        let opt_level = config.opt_level.unwrap_or(config::OptLevel::No);\n+        write::llvm_optimize(cgcx, diag_handler, module, config, opt_level, opt_stage)?;\n     }\n     debug!(\"lto done\");\n     Ok(())"}, {"sha": "11053a8f6c45293a1b306c1c573ceed88a370efe", "filename": "compiler/rustc_codegen_llvm/src/back/write.rs", "status": "modified", "additions": 10, "deletions": 251, "changes": 261, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Fwrite.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "patch": "@@ -21,7 +21,6 @@ use rustc_data_structures::profiling::SelfProfilerRef;\n use rustc_data_structures::small_c_str::SmallCStr;\n use rustc_errors::{FatalError, Handler, Level};\n use rustc_fs_util::{link_or_copy, path_to_c_string};\n-use rustc_middle::bug;\n use rustc_middle::ty::TyCtxt;\n use rustc_session::config::{self, Lto, OutputType, Passes, SplitDwarfKind, SwitchWithOptPath};\n use rustc_session::Session;\n@@ -417,7 +416,7 @@ fn get_instr_profile_output_path(config: &ModuleConfig) -> Option<CString> {\n     }\n }\n \n-pub(crate) unsafe fn optimize_with_new_llvm_pass_manager(\n+pub(crate) unsafe fn llvm_optimize(\n     cgcx: &CodegenContext<LlvmCodegenBackend>,\n     diag_handler: &Handler,\n     module: &ModuleCodegen<ModuleLlvm>,\n@@ -465,7 +464,7 @@ pub(crate) unsafe fn optimize_with_new_llvm_pass_manager(\n     // FIXME: NewPM doesn't provide a facility to pass custom InlineParams.\n     // We would have to add upstream support for this first, before we can support\n     // config.inline_threshold and our more aggressive default thresholds.\n-    let result = llvm::LLVMRustOptimizeWithNewPassManager(\n+    let result = llvm::LLVMRustOptimize(\n         module.module_llvm.llmod(),\n         &*module.module_llvm.tm,\n         to_pass_builder_opt_level(opt_level),\n@@ -509,210 +508,36 @@ pub(crate) unsafe fn optimize(\n \n     let llmod = module.module_llvm.llmod();\n     let llcx = &*module.module_llvm.llcx;\n-    let tm = &*module.module_llvm.tm;\n     let _handlers = DiagnosticHandlers::new(cgcx, diag_handler, llcx);\n \n     let module_name = module.name.clone();\n     let module_name = Some(&module_name[..]);\n \n-    if let Some(false) = config.new_llvm_pass_manager && llvm_util::get_version() >= (15, 0, 0) {\n-        diag_handler.warn(\n-            \"ignoring `-Z new-llvm-pass-manager=no`, which is no longer supported with LLVM 15\",\n-        );\n-    }\n-\n     if config.emit_no_opt_bc {\n         let out = cgcx.output_filenames.temp_path_ext(\"no-opt.bc\", module_name);\n         let out = path_to_c_string(&out);\n         llvm::LLVMWriteBitcodeToFile(llmod, out.as_ptr());\n     }\n \n     if let Some(opt_level) = config.opt_level {\n-        if llvm_util::should_use_new_llvm_pass_manager(\n-            &config.new_llvm_pass_manager,\n-            &cgcx.target_arch,\n-        ) {\n-            let opt_stage = match cgcx.lto {\n-                Lto::Fat => llvm::OptStage::PreLinkFatLTO,\n-                Lto::Thin | Lto::ThinLocal => llvm::OptStage::PreLinkThinLTO,\n-                _ if cgcx.opts.cg.linker_plugin_lto.enabled() => llvm::OptStage::PreLinkThinLTO,\n-                _ => llvm::OptStage::PreLinkNoLTO,\n-            };\n-            return optimize_with_new_llvm_pass_manager(\n-                cgcx,\n-                diag_handler,\n-                module,\n-                config,\n-                opt_level,\n-                opt_stage,\n-            );\n-        }\n-\n-        if cgcx.prof.llvm_recording_enabled() {\n-            diag_handler\n-                .warn(\"`-Z self-profile-events = llvm` requires `-Z new-llvm-pass-manager`\");\n-        }\n-\n-        // Create the two optimizing pass managers. These mirror what clang\n-        // does, and are by populated by LLVM's default PassManagerBuilder.\n-        // Each manager has a different set of passes, but they also share\n-        // some common passes.\n-        let fpm = llvm::LLVMCreateFunctionPassManagerForModule(llmod);\n-        let mpm = llvm::LLVMCreatePassManager();\n-\n-        {\n-            let find_pass = |pass_name: &str| {\n-                let pass_name = SmallCStr::new(pass_name);\n-                llvm::LLVMRustFindAndCreatePass(pass_name.as_ptr())\n-            };\n-\n-            if config.verify_llvm_ir {\n-                // Verification should run as the very first pass.\n-                llvm::LLVMRustAddPass(fpm, find_pass(\"verify\").unwrap());\n-            }\n-\n-            let mut extra_passes = Vec::new();\n-            let mut have_name_anon_globals_pass = false;\n-\n-            for pass_name in &config.passes {\n-                if pass_name == \"lint\" {\n-                    // Linting should also be performed early, directly on the generated IR.\n-                    llvm::LLVMRustAddPass(fpm, find_pass(\"lint\").unwrap());\n-                    continue;\n-                }\n-\n-                if let Some(pass) = find_pass(pass_name) {\n-                    extra_passes.push(pass);\n-                } else {\n-                    diag_handler.warn(&format!(\"unknown pass `{}`, ignoring\", pass_name));\n-                }\n-\n-                if pass_name == \"name-anon-globals\" {\n-                    have_name_anon_globals_pass = true;\n-                }\n-            }\n-\n-            // Instrumentation must be inserted before optimization,\n-            // otherwise LLVM may optimize some functions away which\n-            // breaks llvm-cov.\n-            //\n-            // This mirrors what Clang does in lib/CodeGen/BackendUtil.cpp.\n-            if config.instrument_gcov {\n-                llvm::LLVMRustAddPass(mpm, find_pass(\"insert-gcov-profiling\").unwrap());\n-            }\n-            if config.instrument_coverage {\n-                llvm::LLVMRustAddPass(mpm, find_pass(\"instrprof\").unwrap());\n-            }\n-            if config.debug_info_for_profiling {\n-                llvm::LLVMRustAddPass(mpm, find_pass(\"add-discriminators\").unwrap());\n-            }\n-\n-            add_sanitizer_passes(config, &mut extra_passes);\n-\n-            // Some options cause LLVM bitcode to be emitted, which uses ThinLTOBuffers, so we need\n-            // to make sure we run LLVM's NameAnonGlobals pass when emitting bitcode; otherwise\n-            // we'll get errors in LLVM.\n-            let using_thin_buffers = config.bitcode_needed();\n-            if !config.no_prepopulate_passes {\n-                llvm::LLVMAddAnalysisPasses(tm, fpm);\n-                llvm::LLVMAddAnalysisPasses(tm, mpm);\n-                let opt_level = to_llvm_opt_settings(opt_level).0;\n-                let prepare_for_thin_lto = cgcx.lto == Lto::Thin\n-                    || cgcx.lto == Lto::ThinLocal\n-                    || (cgcx.lto != Lto::Fat && cgcx.opts.cg.linker_plugin_lto.enabled());\n-                with_llvm_pmb(llmod, config, opt_level, prepare_for_thin_lto, &mut |b| {\n-                    llvm::LLVMRustAddLastExtensionPasses(\n-                        b,\n-                        extra_passes.as_ptr(),\n-                        extra_passes.len() as size_t,\n-                    );\n-                    llvm::LLVMRustPassManagerBuilderPopulateFunctionPassManager(b, fpm);\n-                    llvm::LLVMRustPassManagerBuilderPopulateModulePassManager(b, mpm);\n-                });\n-\n-                have_name_anon_globals_pass = have_name_anon_globals_pass || prepare_for_thin_lto;\n-                if using_thin_buffers && !prepare_for_thin_lto {\n-                    llvm::LLVMRustAddPass(mpm, find_pass(\"name-anon-globals\").unwrap());\n-                    have_name_anon_globals_pass = true;\n-                }\n-            } else {\n-                // If we don't use the standard pipeline, directly populate the MPM\n-                // with the extra passes.\n-                for pass in extra_passes {\n-                    llvm::LLVMRustAddPass(mpm, pass);\n-                }\n-            }\n-\n-            if using_thin_buffers && !have_name_anon_globals_pass {\n-                // As described above, this will probably cause an error in LLVM\n-                if config.no_prepopulate_passes {\n-                    diag_handler.err(\n-                        \"The current compilation is going to use thin LTO buffers \\\n-                                      without running LLVM's NameAnonGlobals pass. \\\n-                                      This will likely cause errors in LLVM. Consider adding \\\n-                                      -C passes=name-anon-globals to the compiler command line.\",\n-                    );\n-                } else {\n-                    bug!(\n-                        \"We are using thin LTO buffers without running the NameAnonGlobals pass. \\\n-                          This will likely cause errors in LLVM and should never happen.\"\n-                    );\n-                }\n-            }\n-        }\n-\n-        diag_handler.abort_if_errors();\n-\n-        // Finally, run the actual optimization passes\n-        {\n-            let _timer = cgcx.prof.extra_verbose_generic_activity(\n-                \"LLVM_module_optimize_function_passes\",\n-                &*module.name,\n-            );\n-            llvm::LLVMRustRunFunctionPassManager(fpm, llmod);\n-        }\n-        {\n-            let _timer = cgcx.prof.extra_verbose_generic_activity(\n-                \"LLVM_module_optimize_module_passes\",\n-                &*module.name,\n-            );\n-            llvm::LLVMRunPassManager(mpm, llmod);\n-        }\n-\n-        // Deallocate managers that we're now done with\n-        llvm::LLVMDisposePassManager(fpm);\n-        llvm::LLVMDisposePassManager(mpm);\n+        let opt_stage = match cgcx.lto {\n+            Lto::Fat => llvm::OptStage::PreLinkFatLTO,\n+            Lto::Thin | Lto::ThinLocal => llvm::OptStage::PreLinkThinLTO,\n+            _ if cgcx.opts.cg.linker_plugin_lto.enabled() => llvm::OptStage::PreLinkThinLTO,\n+            _ => llvm::OptStage::PreLinkNoLTO,\n+        };\n+        return llvm_optimize(cgcx, diag_handler, module, config, opt_level, opt_stage);\n     }\n     Ok(())\n }\n \n-unsafe fn add_sanitizer_passes(config: &ModuleConfig, passes: &mut Vec<&'static mut llvm::Pass>) {\n-    if config.sanitizer.contains(SanitizerSet::ADDRESS) {\n-        let recover = config.sanitizer_recover.contains(SanitizerSet::ADDRESS);\n-        passes.push(llvm::LLVMRustCreateAddressSanitizerFunctionPass(recover));\n-        passes.push(llvm::LLVMRustCreateModuleAddressSanitizerPass(recover));\n-    }\n-    if config.sanitizer.contains(SanitizerSet::MEMORY) {\n-        let track_origins = config.sanitizer_memory_track_origins as c_int;\n-        let recover = config.sanitizer_recover.contains(SanitizerSet::MEMORY);\n-        passes.push(llvm::LLVMRustCreateMemorySanitizerPass(track_origins, recover));\n-    }\n-    if config.sanitizer.contains(SanitizerSet::THREAD) {\n-        passes.push(llvm::LLVMRustCreateThreadSanitizerPass());\n-    }\n-    if config.sanitizer.contains(SanitizerSet::HWADDRESS) {\n-        let recover = config.sanitizer_recover.contains(SanitizerSet::HWADDRESS);\n-        passes.push(llvm::LLVMRustCreateHWAddressSanitizerPass(recover));\n-    }\n-}\n-\n pub(crate) fn link(\n     cgcx: &CodegenContext<LlvmCodegenBackend>,\n     diag_handler: &Handler,\n     mut modules: Vec<ModuleCodegen<ModuleLlvm>>,\n ) -> Result<ModuleCodegen<ModuleLlvm>, FatalError> {\n     use super::lto::{Linker, ModuleBuffer};\n-    // Sort the modules by name to ensure to ensure deterministic behavior.\n+    // Sort the modules by name to ensure deterministic behavior.\n     modules.sort_by(|a, b| a.name.cmp(&b.name));\n     let (first, elements) =\n         modules.split_first().expect(\"Bug! modules must contain at least one module.\");\n@@ -1072,72 +897,6 @@ unsafe fn embed_bitcode(\n     }\n }\n \n-pub unsafe fn with_llvm_pmb(\n-    llmod: &llvm::Module,\n-    config: &ModuleConfig,\n-    opt_level: llvm::CodeGenOptLevel,\n-    prepare_for_thin_lto: bool,\n-    f: &mut dyn FnMut(&llvm::PassManagerBuilder),\n-) {\n-    use std::ptr;\n-\n-    // Create the PassManagerBuilder for LLVM. We configure it with\n-    // reasonable defaults and prepare it to actually populate the pass\n-    // manager.\n-    let builder = llvm::LLVMRustPassManagerBuilderCreate();\n-    let opt_size = config.opt_size.map_or(llvm::CodeGenOptSizeNone, |x| to_llvm_opt_settings(x).1);\n-    let inline_threshold = config.inline_threshold;\n-    let pgo_gen_path = get_pgo_gen_path(config);\n-    let pgo_use_path = get_pgo_use_path(config);\n-    let pgo_sample_use_path = get_pgo_sample_use_path(config);\n-\n-    llvm::LLVMRustConfigurePassManagerBuilder(\n-        builder,\n-        opt_level,\n-        config.merge_functions,\n-        config.vectorize_slp,\n-        config.vectorize_loop,\n-        prepare_for_thin_lto,\n-        pgo_gen_path.as_ref().map_or(ptr::null(), |s| s.as_ptr()),\n-        pgo_use_path.as_ref().map_or(ptr::null(), |s| s.as_ptr()),\n-        pgo_sample_use_path.as_ref().map_or(ptr::null(), |s| s.as_ptr()),\n-        opt_size as c_int,\n-    );\n-\n-    llvm::LLVMRustAddBuilderLibraryInfo(builder, llmod, config.no_builtins);\n-\n-    // Here we match what clang does (kinda). For O0 we only inline\n-    // always-inline functions (but don't add lifetime intrinsics), at O1 we\n-    // inline with lifetime intrinsics, and O2+ we add an inliner with a\n-    // thresholds copied from clang.\n-    match (opt_level, opt_size, inline_threshold) {\n-        (.., Some(t)) => {\n-            llvm::LLVMRustPassManagerBuilderUseInlinerWithThreshold(builder, t);\n-        }\n-        (llvm::CodeGenOptLevel::Aggressive, ..) => {\n-            llvm::LLVMRustPassManagerBuilderUseInlinerWithThreshold(builder, 275);\n-        }\n-        (_, llvm::CodeGenOptSizeDefault, _) => {\n-            llvm::LLVMRustPassManagerBuilderUseInlinerWithThreshold(builder, 75);\n-        }\n-        (_, llvm::CodeGenOptSizeAggressive, _) => {\n-            llvm::LLVMRustPassManagerBuilderUseInlinerWithThreshold(builder, 25);\n-        }\n-        (llvm::CodeGenOptLevel::None, ..) => {\n-            llvm::LLVMRustAddAlwaysInlinePass(builder, config.emit_lifetime_markers);\n-        }\n-        (llvm::CodeGenOptLevel::Less, ..) => {\n-            llvm::LLVMRustAddAlwaysInlinePass(builder, config.emit_lifetime_markers);\n-        }\n-        (llvm::CodeGenOptLevel::Default, ..) => {\n-            llvm::LLVMRustPassManagerBuilderUseInlinerWithThreshold(builder, 225);\n-        }\n-    }\n-\n-    f(builder);\n-    llvm::LLVMRustPassManagerBuilderDispose(builder);\n-}\n-\n // Create a `__imp_<symbol> = &symbol` global for every public static `symbol`.\n // This is required to satisfy `dllimport` references to static data in .rlibs\n // when using MSVC linker.  We do this only for data, as linker can fix up"}, {"sha": "5b2bbdb4bde1eb09605d6282c187692a4d54582e", "filename": "compiler/rustc_codegen_llvm/src/base.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbase.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "patch": "@@ -19,6 +19,8 @@ use crate::context::CodegenCx;\n use crate::llvm;\n use crate::value::Value;\n \n+use cstr::cstr;\n+\n use rustc_codegen_ssa::base::maybe_create_entry_wrapper;\n use rustc_codegen_ssa::mono_item::MonoItemExt;\n use rustc_codegen_ssa::traits::*;\n@@ -107,11 +109,14 @@ pub fn compile_codegen_unit(tcx: TyCtxt<'_>, cgu_name: Symbol) -> (ModuleCodegen\n             }\n \n             // Create the llvm.used and llvm.compiler.used variables.\n-            if !cx.used_statics().borrow().is_empty() {\n-                cx.create_used_variable()\n+            if !cx.used_statics.borrow().is_empty() {\n+                cx.create_used_variable_impl(cstr!(\"llvm.used\"), &*cx.used_statics.borrow());\n             }\n-            if !cx.compiler_used_statics().borrow().is_empty() {\n-                cx.create_compiler_used_variable()\n+            if !cx.compiler_used_statics.borrow().is_empty() {\n+                cx.create_used_variable_impl(\n+                    cstr!(\"llvm.compiler.used\"),\n+                    &*cx.compiler_used_statics.borrow(),\n+                );\n             }\n \n             // Run replace-all-uses-with for statics that need it. This must"}, {"sha": "fca43a0d86ddd5b8614424fd0aac1ddbf87daf6d", "filename": "compiler/rustc_codegen_llvm/src/builder.rs", "status": "modified", "additions": 19, "deletions": 11, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "patch": "@@ -1,3 +1,4 @@\n+use crate::abi::FnAbiLlvmExt;\n use crate::attributes;\n use crate::common::Funclet;\n use crate::context::CodegenCx;\n@@ -214,6 +215,7 @@ impl<'a, 'll, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n     fn invoke(\n         &mut self,\n         llty: &'ll Type,\n+        fn_abi: Option<&FnAbi<'tcx, Ty<'tcx>>>,\n         llfn: &'ll Value,\n         args: &[&'ll Value],\n         then: &'ll BasicBlock,\n@@ -226,7 +228,7 @@ impl<'a, 'll, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n         let bundle = funclet.map(|funclet| funclet.bundle());\n         let bundle = bundle.as_ref().map(|b| &*b.raw);\n \n-        unsafe {\n+        let invoke = unsafe {\n             llvm::LLVMRustBuildInvoke(\n                 self.llbuilder,\n                 llty,\n@@ -238,7 +240,11 @@ impl<'a, 'll, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n                 bundle,\n                 UNNAMED,\n             )\n+        };\n+        if let Some(fn_abi) = fn_abi {\n+            fn_abi.apply_attrs_callsite(self, invoke);\n         }\n+        invoke\n     }\n \n     fn unreachable(&mut self) {\n@@ -405,20 +411,17 @@ impl<'a, 'll, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n     fn alloca(&mut self, ty: &'ll Type, align: Align) -> &'ll Value {\n         let mut bx = Builder::with_cx(self.cx);\n         bx.position_at_start(unsafe { llvm::LLVMGetFirstBasicBlock(self.llfn()) });\n-        bx.dynamic_alloca(ty, align)\n-    }\n-\n-    fn dynamic_alloca(&mut self, ty: &'ll Type, align: Align) -> &'ll Value {\n         unsafe {\n-            let alloca = llvm::LLVMBuildAlloca(self.llbuilder, ty, UNNAMED);\n+            let alloca = llvm::LLVMBuildAlloca(bx.llbuilder, ty, UNNAMED);\n             llvm::LLVMSetAlignment(alloca, align.bytes() as c_uint);\n             alloca\n         }\n     }\n \n-    fn array_alloca(&mut self, ty: &'ll Type, len: &'ll Value, align: Align) -> &'ll Value {\n+    fn byte_array_alloca(&mut self, len: &'ll Value, align: Align) -> &'ll Value {\n         unsafe {\n-            let alloca = llvm::LLVMBuildArrayAlloca(self.llbuilder, ty, len, UNNAMED);\n+            let alloca =\n+                llvm::LLVMBuildArrayAlloca(self.llbuilder, self.cx().type_i8(), len, UNNAMED);\n             llvm::LLVMSetAlignment(alloca, align.bytes() as c_uint);\n             alloca\n         }\n@@ -1145,6 +1148,7 @@ impl<'a, 'll, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n     fn call(\n         &mut self,\n         llty: &'ll Type,\n+        fn_abi: Option<&FnAbi<'tcx, Ty<'tcx>>>,\n         llfn: &'ll Value,\n         args: &[&'ll Value],\n         funclet: Option<&Funclet<'ll>>,\n@@ -1155,7 +1159,7 @@ impl<'a, 'll, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n         let bundle = funclet.map(|funclet| funclet.bundle());\n         let bundle = bundle.as_ref().map(|b| &*b.raw);\n \n-        unsafe {\n+        let call = unsafe {\n             llvm::LLVMRustBuildCall(\n                 self.llbuilder,\n                 llty,\n@@ -1164,7 +1168,11 @@ impl<'a, 'll, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n                 args.len() as c_uint,\n                 bundle,\n             )\n+        };\n+        if let Some(fn_abi) = fn_abi {\n+            fn_abi.apply_attrs_callsite(self, call);\n         }\n+        call\n     }\n \n     fn zext(&mut self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n@@ -1397,7 +1405,7 @@ impl<'a, 'll, 'tcx> Builder<'a, 'll, 'tcx> {\n \n     pub(crate) fn call_intrinsic(&mut self, intrinsic: &str, args: &[&'ll Value]) -> &'ll Value {\n         let (ty, f) = self.cx.get_intrinsic(intrinsic);\n-        self.call(ty, f, args, None)\n+        self.call(ty, None, f, args, None)\n     }\n \n     fn call_lifetime_intrinsic(&mut self, intrinsic: &str, ptr: &'ll Value, size: Size) {\n@@ -1459,7 +1467,7 @@ impl<'a, 'll, 'tcx> Builder<'a, 'll, 'tcx> {\n             format!(\"llvm.{}.sat.i{}.f{}\", instr, int_width, float_width)\n         };\n         let f = self.declare_cfn(&name, llvm::UnnamedAddr::No, self.type_func(&[src_ty], dest_ty));\n-        self.call(self.type_func(&[src_ty], dest_ty), f, &[val], None)\n+        self.call(self.type_func(&[src_ty], dest_ty), None, f, &[val], None)\n     }\n \n     pub(crate) fn landing_pad("}, {"sha": "ee2fc65e37b832ccc61dfb931362fe106f714296", "filename": "compiler/rustc_codegen_llvm/src/consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_codegen_llvm%2Fsrc%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_codegen_llvm%2Fsrc%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fconsts.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "patch": "@@ -552,7 +552,7 @@ impl<'ll> StaticMethods for CodegenCx<'ll, '_> {\n                 // `#[used(compiler)]` is explicitly requested. This is to avoid similar breakage\n                 // on other targets, in particular MachO targets have *their* static constructor\n                 // lists broken if `llvm.compiler.used` is emitted rather than llvm.used. However,\n-                // that check happens when assigning the `CodegenFnAttrFlags` in `rustc_typeck`,\n+                // that check happens when assigning the `CodegenFnAttrFlags` in `rustc_hir_analysis`,\n                 // so we don't need to take care of it here.\n                 self.add_compiler_used_global(g);\n             }"}, {"sha": "79ddfd884dfac69f29fca10fed4063dda0c7c226", "filename": "compiler/rustc_codegen_llvm/src/context.rs", "status": "modified", "additions": 6, "deletions": 20, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcontext.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "patch": "@@ -154,6 +154,11 @@ pub unsafe fn create_module<'ll>(\n             target_data_layout = target_data_layout.replace(\"-p10:8:8-p20:8:8\", \"\");\n         }\n     }\n+    if llvm_version < (16, 0, 0) {\n+        if sess.target.arch == \"s390x\" {\n+            target_data_layout = target_data_layout.replace(\"-v128:64\", \"\");\n+        }\n+    }\n \n     // Ensure the data-layout values hardcoded remain the defaults.\n     if sess.target.is_builtin {\n@@ -453,7 +458,7 @@ impl<'ll, 'tcx> CodegenCx<'ll, 'tcx> {\n         self.coverage_cx.as_ref()\n     }\n \n-    fn create_used_variable_impl(&self, name: &'static CStr, values: &[&'ll Value]) {\n+    pub(crate) fn create_used_variable_impl(&self, name: &'static CStr, values: &[&'ll Value]) {\n         let section = cstr!(\"llvm.metadata\");\n         let array = self.const_array(self.type_ptr_to(self.type_i8()), values);\n \n@@ -551,14 +556,6 @@ impl<'ll, 'tcx> MiscMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n         self.codegen_unit\n     }\n \n-    fn used_statics(&self) -> &RefCell<Vec<&'ll Value>> {\n-        &self.used_statics\n-    }\n-\n-    fn compiler_used_statics(&self) -> &RefCell<Vec<&'ll Value>> {\n-        &self.compiler_used_statics\n-    }\n-\n     fn set_frame_pointer_type(&self, llfn: &'ll Value) {\n         if let Some(attr) = attributes::frame_pointer_type_attr(self) {\n             attributes::apply_to_llfn(llfn, llvm::AttributePlace::Function, &[attr]);\n@@ -572,17 +569,6 @@ impl<'ll, 'tcx> MiscMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n         attributes::apply_to_llfn(llfn, llvm::AttributePlace::Function, &attrs);\n     }\n \n-    fn create_used_variable(&self) {\n-        self.create_used_variable_impl(cstr!(\"llvm.used\"), &*self.used_statics.borrow());\n-    }\n-\n-    fn create_compiler_used_variable(&self) {\n-        self.create_used_variable_impl(\n-            cstr!(\"llvm.compiler.used\"),\n-            &*self.compiler_used_statics.borrow(),\n-        );\n-    }\n-\n     fn declare_c_main(&self, fn_type: Self::Type) -> Option<Self::Function> {\n         if self.get_declared_value(\"main\").is_none() {\n             Some(self.declare_cfn(\"main\", llvm::UnnamedAddr::Global, fn_type))"}, {"sha": "433f043209e5314a08e3b7bb2cbc81b0bc0642db", "filename": "compiler/rustc_codegen_llvm/src/coverageinfo/mapgen.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcoverageinfo%2Fmapgen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcoverageinfo%2Fmapgen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcoverageinfo%2Fmapgen.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "patch": "@@ -129,7 +129,7 @@ impl CoverageMapGenerator {\n             // LLVM Coverage Mapping Format version 6 (zero-based encoded as 5)\n             // requires setting the first filename to the compilation directory.\n             // Since rustc generates coverage maps with relative paths, the\n-            // compilation directory can be combined with the the relative paths\n+            // compilation directory can be combined with the relative paths\n             // to get absolute paths, if needed.\n             let working_dir = tcx\n                 .sess"}, {"sha": "f79ef11720df9b4436d83dd50674065b7e12a988", "filename": "compiler/rustc_codegen_llvm/src/declare.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdeclare.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdeclare.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdeclare.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "patch": "@@ -32,6 +32,7 @@ fn declare_raw_fn<'ll>(\n     name: &str,\n     callconv: llvm::CallConv,\n     unnamed: llvm::UnnamedAddr,\n+    visibility: llvm::Visibility,\n     ty: &'ll Type,\n ) -> &'ll Value {\n     debug!(\"declare_raw_fn(name={:?}, ty={:?})\", name, ty);\n@@ -41,6 +42,7 @@ fn declare_raw_fn<'ll>(\n \n     llvm::SetFunctionCallConv(llfn, callconv);\n     llvm::SetUnnamedAddress(llfn, unnamed);\n+    llvm::set_visibility(llfn, visibility);\n \n     let mut attrs = SmallVec::<[_; 4]>::new();\n \n@@ -78,7 +80,14 @@ impl<'ll, 'tcx> CodegenCx<'ll, 'tcx> {\n         unnamed: llvm::UnnamedAddr,\n         fn_type: &'ll Type,\n     ) -> &'ll Value {\n-        declare_raw_fn(self, name, llvm::CCallConv, unnamed, fn_type)\n+        // Declare C ABI functions with the visibility used by C by default.\n+        let visibility = if self.tcx.sess.target.default_hidden_visibility {\n+            llvm::Visibility::Hidden\n+        } else {\n+            llvm::Visibility::Default\n+        };\n+\n+        declare_raw_fn(self, name, llvm::CCallConv, unnamed, visibility, fn_type)\n     }\n \n     /// Declare a Rust function.\n@@ -95,6 +104,7 @@ impl<'ll, 'tcx> CodegenCx<'ll, 'tcx> {\n             name,\n             fn_abi.llvm_cconv(),\n             llvm::UnnamedAddr::Global,\n+            llvm::Visibility::Default,\n             fn_abi.llvm_type(self),\n         );\n         fn_abi.apply_attrs_llfn(self, llfn);"}, {"sha": "825011941a24117a00f65638cc53e5efc2100d27", "filename": "compiler/rustc_codegen_llvm/src/intrinsic.rs", "status": "modified", "additions": 34, "deletions": 18, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "patch": "@@ -108,6 +108,7 @@ impl<'ll, 'tcx> IntrinsicCallMethods<'tcx> for Builder<'_, 'll, 'tcx> {\n                 let (simple_ty, simple_fn) = simple.unwrap();\n                 self.call(\n                     simple_ty,\n+                    None,\n                     simple_fn,\n                     &args.iter().map(|arg| arg.immediate()).collect::<Vec<_>>(),\n                     None,\n@@ -435,7 +436,7 @@ fn try_intrinsic<'ll>(\n ) {\n     if bx.sess().panic_strategy() == PanicStrategy::Abort {\n         let try_func_ty = bx.type_func(&[bx.type_i8p()], bx.type_void());\n-        bx.call(try_func_ty, try_func, &[data], None);\n+        bx.call(try_func_ty, None, try_func, &[data], None);\n         // Return 0 unconditionally from the intrinsic call;\n         // we can never unwind.\n         let ret_align = bx.tcx().data_layout.i32_align.abi;\n@@ -534,7 +535,7 @@ fn codegen_msvc_try<'ll>(\n         let ptr_align = bx.tcx().data_layout.pointer_align.abi;\n         let slot = bx.alloca(bx.type_i8p(), ptr_align);\n         let try_func_ty = bx.type_func(&[bx.type_i8p()], bx.type_void());\n-        bx.invoke(try_func_ty, try_func, &[data], normal, catchswitch, None);\n+        bx.invoke(try_func_ty, None, try_func, &[data], normal, catchswitch, None);\n \n         bx.switch_to_block(normal);\n         bx.ret(bx.const_i32(0));\n@@ -578,15 +579,15 @@ fn codegen_msvc_try<'ll>(\n         let funclet = bx.catch_pad(cs, &[tydesc, flags, slot]);\n         let ptr = bx.load(bx.type_i8p(), slot, ptr_align);\n         let catch_ty = bx.type_func(&[bx.type_i8p(), bx.type_i8p()], bx.type_void());\n-        bx.call(catch_ty, catch_func, &[data, ptr], Some(&funclet));\n+        bx.call(catch_ty, None, catch_func, &[data, ptr], Some(&funclet));\n         bx.catch_ret(&funclet, caught);\n \n         // The flag value of 64 indicates a \"catch-all\".\n         bx.switch_to_block(catchpad_foreign);\n         let flags = bx.const_i32(64);\n         let null = bx.const_null(bx.type_i8p());\n         let funclet = bx.catch_pad(cs, &[null, flags, null]);\n-        bx.call(catch_ty, catch_func, &[data, null], Some(&funclet));\n+        bx.call(catch_ty, None, catch_func, &[data, null], Some(&funclet));\n         bx.catch_ret(&funclet, caught);\n \n         bx.switch_to_block(caught);\n@@ -595,7 +596,7 @@ fn codegen_msvc_try<'ll>(\n \n     // Note that no invoke is used here because by definition this function\n     // can't panic (that's what it's catching).\n-    let ret = bx.call(llty, llfn, &[try_func, data, catch_func], None);\n+    let ret = bx.call(llty, None, llfn, &[try_func, data, catch_func], None);\n     let i32_align = bx.tcx().data_layout.i32_align.abi;\n     bx.store(ret, dest, i32_align);\n }\n@@ -638,7 +639,7 @@ fn codegen_gnu_try<'ll>(\n         let data = llvm::get_param(bx.llfn(), 1);\n         let catch_func = llvm::get_param(bx.llfn(), 2);\n         let try_func_ty = bx.type_func(&[bx.type_i8p()], bx.type_void());\n-        bx.invoke(try_func_ty, try_func, &[data], then, catch, None);\n+        bx.invoke(try_func_ty, None, try_func, &[data], then, catch, None);\n \n         bx.switch_to_block(then);\n         bx.ret(bx.const_i32(0));\n@@ -656,13 +657,13 @@ fn codegen_gnu_try<'ll>(\n         bx.add_clause(vals, tydesc);\n         let ptr = bx.extract_value(vals, 0);\n         let catch_ty = bx.type_func(&[bx.type_i8p(), bx.type_i8p()], bx.type_void());\n-        bx.call(catch_ty, catch_func, &[data, ptr], None);\n+        bx.call(catch_ty, None, catch_func, &[data, ptr], None);\n         bx.ret(bx.const_i32(1));\n     });\n \n     // Note that no invoke is used here because by definition this function\n     // can't panic (that's what it's catching).\n-    let ret = bx.call(llty, llfn, &[try_func, data, catch_func], None);\n+    let ret = bx.call(llty, None, llfn, &[try_func, data, catch_func], None);\n     let i32_align = bx.tcx().data_layout.i32_align.abi;\n     bx.store(ret, dest, i32_align);\n }\n@@ -702,7 +703,7 @@ fn codegen_emcc_try<'ll>(\n         let data = llvm::get_param(bx.llfn(), 1);\n         let catch_func = llvm::get_param(bx.llfn(), 2);\n         let try_func_ty = bx.type_func(&[bx.type_i8p()], bx.type_void());\n-        bx.invoke(try_func_ty, try_func, &[data], then, catch, None);\n+        bx.invoke(try_func_ty, None, try_func, &[data], then, catch, None);\n \n         bx.switch_to_block(then);\n         bx.ret(bx.const_i32(0));\n@@ -741,13 +742,13 @@ fn codegen_emcc_try<'ll>(\n         let catch_data = bx.bitcast(catch_data, bx.type_i8p());\n \n         let catch_ty = bx.type_func(&[bx.type_i8p(), bx.type_i8p()], bx.type_void());\n-        bx.call(catch_ty, catch_func, &[data, catch_data], None);\n+        bx.call(catch_ty, None, catch_func, &[data, catch_data], None);\n         bx.ret(bx.const_i32(1));\n     });\n \n     // Note that no invoke is used here because by definition this function\n     // can't panic (that's what it's catching).\n-    let ret = bx.call(llty, llfn, &[try_func, data, catch_func], None);\n+    let ret = bx.call(llty, None, llfn, &[try_func, data, catch_func], None);\n     let i32_align = bx.tcx().data_layout.i32_align.abi;\n     bx.store(ret, dest, i32_align);\n }\n@@ -1217,8 +1218,13 @@ fn generic_simd_intrinsic<'ll, 'tcx>(\n         };\n         let llvm_name = &format!(\"llvm.{0}.v{1}{2}\", intr_name, in_len, elem_ty_str);\n         let f = bx.declare_cfn(llvm_name, llvm::UnnamedAddr::No, fn_ty);\n-        let c =\n-            bx.call(fn_ty, f, &args.iter().map(|arg| arg.immediate()).collect::<Vec<_>>(), None);\n+        let c = bx.call(\n+            fn_ty,\n+            None,\n+            f,\n+            &args.iter().map(|arg| arg.immediate()).collect::<Vec<_>>(),\n+            None,\n+        );\n         Ok(c)\n     }\n \n@@ -1417,8 +1423,13 @@ fn generic_simd_intrinsic<'ll, 'tcx>(\n             llvm_elem_vec_ty,\n         );\n         let f = bx.declare_cfn(&llvm_intrinsic, llvm::UnnamedAddr::No, fn_ty);\n-        let v =\n-            bx.call(fn_ty, f, &[args[1].immediate(), alignment, mask, args[0].immediate()], None);\n+        let v = bx.call(\n+            fn_ty,\n+            None,\n+            f,\n+            &[args[1].immediate(), alignment, mask, args[0].immediate()],\n+            None,\n+        );\n         return Ok(v);\n     }\n \n@@ -1543,8 +1554,13 @@ fn generic_simd_intrinsic<'ll, 'tcx>(\n         let fn_ty =\n             bx.type_func(&[llvm_elem_vec_ty, llvm_pointer_vec_ty, alignment_ty, mask_ty], ret_t);\n         let f = bx.declare_cfn(&llvm_intrinsic, llvm::UnnamedAddr::No, fn_ty);\n-        let v =\n-            bx.call(fn_ty, f, &[args[0].immediate(), args[1].immediate(), alignment, mask], None);\n+        let v = bx.call(\n+            fn_ty,\n+            None,\n+            f,\n+            &[args[0].immediate(), args[1].immediate(), alignment, mask],\n+            None,\n+        );\n         return Ok(v);\n     }\n \n@@ -1992,7 +2008,7 @@ unsupported {} from `{}` with element `{}` of size `{}` to `{}`\"#,\n \n         let fn_ty = bx.type_func(&[vec_ty, vec_ty], vec_ty);\n         let f = bx.declare_cfn(llvm_intrinsic, llvm::UnnamedAddr::No, fn_ty);\n-        let v = bx.call(fn_ty, f, &[lhs, rhs], None);\n+        let v = bx.call(fn_ty, None, f, &[lhs, rhs], None);\n         return Ok(v);\n     }\n "}, {"sha": "89c7e51d09ec1affd65e17bb73aa5317b5921723", "filename": "compiler/rustc_codegen_llvm/src/lib.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_codegen_llvm%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_codegen_llvm%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Flib.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "patch": "@@ -7,7 +7,6 @@\n #![doc(html_root_url = \"https://doc.rust-lang.org/nightly/nightly-rustc/\")]\n #![feature(hash_raw_entry)]\n #![feature(let_chains)]\n-#![cfg_attr(bootstrap, feature(let_else))]\n #![feature(extern_types)]\n #![feature(once_cell)]\n #![feature(iter_intersperse)]\n@@ -132,12 +131,6 @@ impl ExtraBackendMethods for LlvmCodegenBackend {\n     ) -> TargetMachineFactoryFn<Self> {\n         back::write::target_machine_factory(sess, optlvl, target_features)\n     }\n-    fn target_cpu<'b>(&self, sess: &'b Session) -> &'b str {\n-        llvm_util::target_cpu(sess)\n-    }\n-    fn tune_cpu<'b>(&self, sess: &'b Session) -> Option<&'b str> {\n-        llvm_util::tune_cpu(sess)\n-    }\n \n     fn spawn_thread<F, T>(time_trace: bool, f: F) -> std::thread::JoinHandle<T>\n     where\n@@ -171,7 +164,6 @@ impl ExtraBackendMethods for LlvmCodegenBackend {\n impl WriteBackendMethods for LlvmCodegenBackend {\n     type Module = ModuleLlvm;\n     type ModuleBuffer = back::lto::ModuleBuffer;\n-    type Context = llvm::Context;\n     type TargetMachine = &'static mut llvm::TargetMachine;\n     type ThinData = back::lto::ThinData;\n     type ThinBuffer = back::lto::ThinBuffer;"}, {"sha": "42cb694c0e75a1b4cc382482bfee138a550b2a30", "filename": "compiler/rustc_codegen_llvm/src/llvm/ffi.rs", "status": "modified", "additions": 2, "deletions": 72, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "patch": "@@ -1792,18 +1792,9 @@ extern \"C\" {\n     /// Writes a module to the specified path. Returns 0 on success.\n     pub fn LLVMWriteBitcodeToFile(M: &Module, Path: *const c_char) -> c_int;\n \n-    /// Creates a pass manager.\n+    /// Creates a legacy pass manager -- only used for final codegen.\n     pub fn LLVMCreatePassManager<'a>() -> &'a mut PassManager<'a>;\n \n-    /// Creates a function-by-function pass manager\n-    pub fn LLVMCreateFunctionPassManagerForModule(M: &Module) -> &mut PassManager<'_>;\n-\n-    /// Disposes a pass manager.\n-    pub fn LLVMDisposePassManager<'a>(PM: &'a mut PassManager<'a>);\n-\n-    /// Runs a pass manager on a module.\n-    pub fn LLVMRunPassManager<'a>(PM: &PassManager<'a>, M: &'a Module) -> Bool;\n-\n     pub fn LLVMInitializePasses();\n \n     pub fn LLVMTimeTraceProfilerInitialize();\n@@ -1814,32 +1805,6 @@ extern \"C\" {\n \n     pub fn LLVMAddAnalysisPasses<'a>(T: &'a TargetMachine, PM: &PassManager<'a>);\n \n-    pub fn LLVMRustPassManagerBuilderCreate() -> &'static mut PassManagerBuilder;\n-    pub fn LLVMRustPassManagerBuilderDispose(PMB: &'static mut PassManagerBuilder);\n-    pub fn LLVMRustPassManagerBuilderUseInlinerWithThreshold(\n-        PMB: &PassManagerBuilder,\n-        threshold: c_uint,\n-    );\n-    pub fn LLVMRustPassManagerBuilderPopulateModulePassManager(\n-        PMB: &PassManagerBuilder,\n-        PM: &PassManager<'_>,\n-    );\n-\n-    pub fn LLVMRustPassManagerBuilderPopulateFunctionPassManager(\n-        PMB: &PassManagerBuilder,\n-        PM: &PassManager<'_>,\n-    );\n-    pub fn LLVMRustPassManagerBuilderPopulateLTOPassManager(\n-        PMB: &PassManagerBuilder,\n-        PM: &PassManager<'_>,\n-        Internalize: Bool,\n-        RunInliner: Bool,\n-    );\n-    pub fn LLVMRustPassManagerBuilderPopulateThinLTOPassManager(\n-        PMB: &PassManagerBuilder,\n-        PM: &PassManager<'_>,\n-    );\n-\n     pub fn LLVMGetHostCPUFeatures() -> *mut c_char;\n \n     pub fn LLVMDisposeMessage(message: *mut c_char);\n@@ -2244,22 +2209,6 @@ extern \"C\" {\n \n     pub fn LLVMIsAConstantInt(value_ref: &Value) -> Option<&ConstantInt>;\n \n-    pub fn LLVMRustFindAndCreatePass(Pass: *const c_char) -> Option<&'static mut Pass>;\n-    pub fn LLVMRustCreateAddressSanitizerFunctionPass(Recover: bool) -> &'static mut Pass;\n-    pub fn LLVMRustCreateModuleAddressSanitizerPass(Recover: bool) -> &'static mut Pass;\n-    pub fn LLVMRustCreateMemorySanitizerPass(\n-        TrackOrigins: c_int,\n-        Recover: bool,\n-    ) -> &'static mut Pass;\n-    pub fn LLVMRustCreateThreadSanitizerPass() -> &'static mut Pass;\n-    pub fn LLVMRustCreateHWAddressSanitizerPass(Recover: bool) -> &'static mut Pass;\n-    pub fn LLVMRustAddPass(PM: &PassManager<'_>, Pass: &'static mut Pass);\n-    pub fn LLVMRustAddLastExtensionPasses(\n-        PMB: &PassManagerBuilder,\n-        Passes: *const &'static mut Pass,\n-        NumPasses: size_t,\n-    );\n-\n     pub fn LLVMRustHasFeature(T: &TargetMachine, s: *const c_char) -> bool;\n \n     pub fn LLVMRustPrintTargetCPUs(T: &TargetMachine);\n@@ -2293,29 +2242,11 @@ extern \"C\" {\n         SplitDwarfFile: *const c_char,\n     ) -> Option<&'static mut TargetMachine>;\n     pub fn LLVMRustDisposeTargetMachine(T: &'static mut TargetMachine);\n-    pub fn LLVMRustAddBuilderLibraryInfo<'a>(\n-        PMB: &'a PassManagerBuilder,\n-        M: &'a Module,\n-        DisableSimplifyLibCalls: bool,\n-    );\n-    pub fn LLVMRustConfigurePassManagerBuilder(\n-        PMB: &PassManagerBuilder,\n-        OptLevel: CodeGenOptLevel,\n-        MergeFunctions: bool,\n-        SLPVectorize: bool,\n-        LoopVectorize: bool,\n-        PrepareForThinLTO: bool,\n-        PGOGenPath: *const c_char,\n-        PGOUsePath: *const c_char,\n-        PGOSampleUsePath: *const c_char,\n-        SizeLevel: c_int,\n-    );\n     pub fn LLVMRustAddLibraryInfo<'a>(\n         PM: &PassManager<'a>,\n         M: &'a Module,\n         DisableSimplifyLibCalls: bool,\n     );\n-    pub fn LLVMRustRunFunctionPassManager<'a>(PM: &PassManager<'a>, M: &'a Module);\n     pub fn LLVMRustWriteOutputFile<'a>(\n         T: &'a TargetMachine,\n         PM: &PassManager<'a>,\n@@ -2324,7 +2255,7 @@ extern \"C\" {\n         DwoOutput: *const c_char,\n         FileType: FileType,\n     ) -> LLVMRustResult;\n-    pub fn LLVMRustOptimizeWithNewPassManager<'a>(\n+    pub fn LLVMRustOptimize<'a>(\n         M: &'a Module,\n         TM: &'a TargetMachine,\n         OptLevel: PassBuilderOptLevel,\n@@ -2362,7 +2293,6 @@ extern \"C\" {\n     pub fn LLVMRustSetLLVMOptions(Argc: c_int, Argv: *const *const c_char);\n     pub fn LLVMRustPrintPasses();\n     pub fn LLVMRustSetNormalizedTarget(M: &Module, triple: *const c_char);\n-    pub fn LLVMRustAddAlwaysInlinePass(P: &PassManagerBuilder, AddLifetimes: bool);\n     pub fn LLVMRustRunRestrictionPass(M: &Module, syms: *const *const c_char, len: size_t);\n \n     pub fn LLVMRustOpenArchive(path: *const c_char) -> Option<&'static mut Archive>;"}, {"sha": "2fd58567c487406d6864849027ddd03ca44ccf07", "filename": "compiler/rustc_codegen_llvm/src/llvm_util.rs", "status": "modified", "additions": 1, "deletions": 35, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm_util.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "patch": "@@ -1,7 +1,6 @@\n use crate::back::write::create_informational_target_machine;\n-use crate::{llvm, llvm_util};\n+use crate::llvm;\n use libc::c_int;\n-use libloading::Library;\n use rustc_codegen_ssa::target_features::{\n     supported_target_features, tied_target_features, RUSTC_SPECIFIC_FEATURES,\n };\n@@ -16,7 +15,6 @@ use rustc_target::spec::{MergeFunctions, PanicStrategy};\n use smallvec::{smallvec, SmallVec};\n use std::ffi::{CStr, CString};\n \n-use std::mem;\n use std::path::Path;\n use std::ptr;\n use std::slice;\n@@ -120,22 +118,6 @@ unsafe fn configure_llvm(sess: &Session) {\n \n     llvm::LLVMInitializePasses();\n \n-    // Use the legacy plugin registration if we don't use the new pass manager\n-    if !should_use_new_llvm_pass_manager(\n-        &sess.opts.unstable_opts.new_llvm_pass_manager,\n-        &sess.target.arch,\n-    ) {\n-        // Register LLVM plugins by loading them into the compiler process.\n-        for plugin in &sess.opts.unstable_opts.llvm_plugins {\n-            let lib = Library::new(plugin).unwrap_or_else(|e| bug!(\"couldn't load plugin: {}\", e));\n-            debug!(\"LLVM plugin loaded successfully {:?} ({})\", lib, plugin);\n-\n-            // Intentionally leak the dynamic library. We can't ever unload it\n-            // since the library can make things that will live arbitrarily long.\n-            mem::forget(lib);\n-        }\n-    }\n-\n     rustc_llvm::initialize_available_targets();\n \n     llvm::LLVMRustSetLLVMOptions(llvm_args.len() as c_int, llvm_args.as_ptr());\n@@ -539,19 +521,3 @@ pub fn tune_cpu(sess: &Session) -> Option<&str> {\n     let name = sess.opts.unstable_opts.tune_cpu.as_ref()?;\n     Some(handle_native(name))\n }\n-\n-pub(crate) fn should_use_new_llvm_pass_manager(user_opt: &Option<bool>, target_arch: &str) -> bool {\n-    // The new pass manager is enabled by default for LLVM >= 13.\n-    // This matches Clang, which also enables it since Clang 13.\n-\n-    // Since LLVM 15, the legacy pass manager is no longer supported.\n-    if llvm_util::get_version() >= (15, 0, 0) {\n-        return true;\n-    }\n-\n-    // There are some perf issues with the new pass manager when targeting\n-    // s390x with LLVM 13, so enable the new pass manager only with LLVM 14.\n-    // See https://github.com/rust-lang/rust/issues/89609.\n-    let min_version = if target_arch == \"s390x\" { 14 } else { 13 };\n-    user_opt.unwrap_or_else(|| llvm_util::get_version() >= (min_version, 0, 0))\n-}"}, {"sha": "88b584c30866734d55a317cd6e84bc149a9f4e89", "filename": "compiler/rustc_codegen_ssa/src/back/link.rs", "status": "modified", "additions": 112, "deletions": 93, "changes": 205, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "patch": "@@ -23,15 +23,17 @@ use rustc_session::{filesearch, Session};\n use rustc_span::symbol::Symbol;\n use rustc_span::DebuggerVisualizerFile;\n use rustc_target::spec::crt_objects::{CrtObjects, LinkSelfContainedDefault};\n-use rustc_target::spec::{LinkOutputKind, LinkerFlavor, LldFlavor, SplitDebuginfo};\n-use rustc_target::spec::{PanicStrategy, RelocModel, RelroLevel, SanitizerSet, Target};\n+use rustc_target::spec::{Cc, LinkOutputKind, LinkerFlavor, LinkerFlavorCli, Lld, PanicStrategy};\n+use rustc_target::spec::{RelocModel, RelroLevel, SanitizerSet, SplitDebuginfo, Target};\n \n use super::archive::{ArchiveBuilder, ArchiveBuilderBuilder};\n use super::command::Command;\n use super::linker::{self, Linker};\n use super::metadata::{create_rmeta_file, MetadataPosition};\n use super::rpath::{self, RPathConfig};\n-use crate::{looks_like_rust_object_file, CodegenResults, CompiledModule, CrateInfo, NativeLib};\n+use crate::{\n+    errors, looks_like_rust_object_file, CodegenResults, CompiledModule, CrateInfo, NativeLib,\n+};\n \n use cc::windows_registry;\n use regex::Regex;\n@@ -93,7 +95,7 @@ pub fn link_binary<'a>(\n             let tmpdir = TempFileBuilder::new()\n                 .prefix(\"rustc\")\n                 .tempdir()\n-                .unwrap_or_else(|err| sess.fatal(&format!(\"couldn't create a temp dir: {}\", err)));\n+                .unwrap_or_else(|error| sess.emit_fatal(errors::CreateTempDir { error }));\n             let path = MaybeTempDir::new(tmpdir, sess.opts.cg.save_temps);\n             let out_filename = out_filename(\n                 sess,\n@@ -208,7 +210,7 @@ pub fn link_binary<'a>(\n pub fn each_linked_rlib(\n     info: &CrateInfo,\n     f: &mut dyn FnMut(CrateNum, &Path),\n-) -> Result<(), String> {\n+) -> Result<(), errors::LinkRlibError> {\n     let crates = info.used_crates.iter();\n     let mut fmts = None;\n     for (ty, list) in info.dependency_formats.iter() {\n@@ -224,26 +226,23 @@ pub fn each_linked_rlib(\n         }\n     }\n     let Some(fmts) = fmts else {\n-        return Err(\"could not find formats for rlibs\".to_string());\n+        return Err(errors::LinkRlibError::MissingFormat);\n     };\n     for &cnum in crates {\n         match fmts.get(cnum.as_usize() - 1) {\n             Some(&Linkage::NotLinked | &Linkage::IncludedFromDylib) => continue,\n             Some(_) => {}\n-            None => return Err(\"could not find formats for rlibs\".to_string()),\n+            None => return Err(errors::LinkRlibError::MissingFormat),\n         }\n-        let name = info.crate_name[&cnum];\n+        let crate_name = info.crate_name[&cnum];\n         let used_crate_source = &info.used_crate_source[&cnum];\n         if let Some((path, _)) = &used_crate_source.rlib {\n             f(cnum, &path);\n         } else {\n             if used_crate_source.rmeta.is_some() {\n-                return Err(format!(\n-                    \"could not find rlib for: `{}`, found rmeta (metadata) file\",\n-                    name\n-                ));\n+                return Err(errors::LinkRlibError::OnlyRmetaFound { crate_name });\n             } else {\n-                return Err(format!(\"could not find rlib for: `{}`\", name));\n+                return Err(errors::LinkRlibError::NotFound { crate_name });\n             }\n         }\n     }\n@@ -340,10 +339,7 @@ fn link_rlib<'a>(\n                 // -whole-archive and it isn't clear how we can currently handle such a\n                 // situation correctly.\n                 // See https://github.com/rust-lang/rust/issues/88085#issuecomment-901050897\n-                sess.err(\n-                    \"the linking modifiers `+bundle` and `+whole-archive` are not compatible \\\n-                        with each other when generating rlibs\",\n-                );\n+                sess.emit_err(errors::IncompatibleLinkingModifiers);\n             }\n             NativeLibKind::Static { bundle: None | Some(true), .. } => {}\n             NativeLibKind::Static { bundle: Some(false), .. }\n@@ -365,12 +361,8 @@ fn link_rlib<'a>(\n                 ));\n                 continue;\n             }\n-            ab.add_archive(&location, Box::new(|_| false)).unwrap_or_else(|e| {\n-                sess.fatal(&format!(\n-                    \"failed to add native library {}: {}\",\n-                    location.to_string_lossy(),\n-                    e\n-                ));\n+            ab.add_archive(&location, Box::new(|_| false)).unwrap_or_else(|error| {\n+                sess.emit_fatal(errors::AddNativeLibrary { library_path: location, error });\n             });\n         }\n     }\n@@ -385,8 +377,8 @@ fn link_rlib<'a>(\n             tmpdir.as_ref(),\n         );\n \n-        ab.add_archive(&output_path, Box::new(|_| false)).unwrap_or_else(|e| {\n-            sess.fatal(&format!(\"failed to add native library {}: {}\", output_path.display(), e));\n+        ab.add_archive(&output_path, Box::new(|_| false)).unwrap_or_else(|error| {\n+            sess.emit_fatal(errors::AddNativeLibrary { library_path: output_path, error });\n         });\n     }\n \n@@ -451,14 +443,11 @@ fn collate_raw_dylibs(\n                     // FIXME: when we add support for ordinals, figure out if we need to do anything\n                     // if we have two DllImport values with the same name but different ordinals.\n                     if import.calling_convention != old_import.calling_convention {\n-                        sess.span_err(\n-                            import.span,\n-                            &format!(\n-                                \"multiple declarations of external function `{}` from \\\n-                                 library `{}` have different calling conventions\",\n-                                import.name, name,\n-                            ),\n-                        );\n+                        sess.emit_err(errors::MultipleExternalFuncDecl {\n+                            span: import.span,\n+                            function: import.name,\n+                            library_name: &name,\n+                        });\n                     }\n                 }\n             }\n@@ -560,7 +549,7 @@ fn link_staticlib<'a>(\n         all_native_libs.extend(codegen_results.crate_info.native_libraries[&cnum].iter().cloned());\n     });\n     if let Err(e) = res {\n-        sess.fatal(&e);\n+        sess.emit_fatal(e);\n     }\n \n     ab.build(out_filename);\n@@ -673,9 +662,7 @@ fn link_dwarf_object<'a>(\n     }) {\n         Ok(()) => {}\n         Err(e) => {\n-            sess.struct_err(\"linking dwarf objects with thorin failed\")\n-                .note(&format!(\"{:?}\", e))\n-                .emit();\n+            sess.emit_err(errors::ThorinErrorWrapper(e));\n             sess.abort_if_errors();\n         }\n     }\n@@ -748,8 +735,7 @@ fn link_natively<'a>(\n         // then it should not default to linking executables as pie. Different\n         // versions of gcc seem to use different quotes in the error message so\n         // don't check for them.\n-        if sess.target.linker_is_gnu\n-            && flavor != LinkerFlavor::Ld\n+        if matches!(flavor, LinkerFlavor::Gnu(Cc::Yes, _))\n             && unknown_arg_regex.is_match(&out)\n             && out.contains(\"-no-pie\")\n             && cmd.get_args().iter().any(|e| e.to_string_lossy() == \"-no-pie\")\n@@ -767,8 +753,7 @@ fn link_natively<'a>(\n \n         // Detect '-static-pie' used with an older version of gcc or clang not supporting it.\n         // Fallback from '-static-pie' to '-static' in that case.\n-        if sess.target.linker_is_gnu\n-            && flavor != LinkerFlavor::Ld\n+        if matches!(flavor, LinkerFlavor::Gnu(Cc::Yes, _))\n             && unknown_arg_regex.is_match(&out)\n             && (out.contains(\"-static-pie\") || out.contains(\"--no-dynamic-linker\"))\n             && cmd.get_args().iter().any(|e| e.to_string_lossy() == \"-static-pie\")\n@@ -881,29 +866,20 @@ fn link_natively<'a>(\n                 let mut output = prog.stderr.clone();\n                 output.extend_from_slice(&prog.stdout);\n                 let escaped_output = escape_string(&output);\n-                let mut err = sess.struct_err(&format!(\n-                    \"linking with `{}` failed: {}\",\n-                    linker_path.display(),\n-                    prog.status\n-                ));\n-                err.note(&format!(\"{:?}\", &cmd)).note(&escaped_output);\n-                if escaped_output.contains(\"undefined reference to\") {\n-                    err.help(\n-                        \"some `extern` functions couldn't be found; some native libraries may \\\n-                         need to be installed or have their path specified\",\n-                    );\n-                    err.note(\"use the `-l` flag to specify native libraries to link\");\n-                    err.note(\"use the `cargo:rustc-link-lib` directive to specify the native \\\n-                              libraries to link with Cargo (see https://doc.rust-lang.org/cargo/reference/build-scripts.html#cargorustc-link-libkindname)\");\n-                }\n-                err.emit();\n-\n+                // FIXME: Add UI tests for this error.\n+                let err = errors::LinkingFailed {\n+                    linker_path: &linker_path,\n+                    exit_status: prog.status,\n+                    command: &cmd,\n+                    escaped_output: &escaped_output,\n+                };\n+                sess.diagnostic().emit_err(err);\n                 // If MSVC's `link.exe` was expected but the return code\n                 // is not a Microsoft LNK error then suggest a way to fix or\n                 // install the Visual Studio build tools.\n                 if let Some(code) = prog.status.code() {\n                     if sess.target.is_like_msvc\n-                        && flavor == LinkerFlavor::Msvc\n+                        && flavor == LinkerFlavor::Msvc(Lld::No)\n                         // Respect the command line override\n                         && sess.opts.cg.linker.is_none()\n                         // Match exactly \"link.exe\"\n@@ -979,9 +955,10 @@ fn link_natively<'a>(\n                      but `link.exe` was not found\",\n                 );\n                 sess.note_without_error(\n-                    \"please ensure that VS 2013, VS 2015, VS 2017, VS 2019 or VS 2022 \\\n-                     was installed with the Visual C++ option\",\n+                    \"please ensure that Visual Studio 2017 or later, or Build Tools \\\n+                     for Visual Studio were installed with the Visual C++ option.\",\n                 );\n+                sess.note_without_error(\"VS Code is a different product, and is not sufficient.\");\n             }\n             sess.abort_if_errors();\n         }\n@@ -1034,16 +1011,36 @@ fn link_natively<'a>(\n \n     if sess.target.is_like_osx {\n         match (strip, crate_type) {\n-            (Strip::Debuginfo, _) => strip_symbols_in_osx(sess, &out_filename, Some(\"-S\")),\n+            (Strip::Debuginfo, _) => {\n+                strip_symbols_with_external_utility(sess, \"strip\", &out_filename, Some(\"-S\"))\n+            }\n             // Per the manpage, `-x` is the maximum safe strip level for dynamic libraries. (#93988)\n             (Strip::Symbols, CrateType::Dylib | CrateType::Cdylib | CrateType::ProcMacro) => {\n-                strip_symbols_in_osx(sess, &out_filename, Some(\"-x\"))\n+                strip_symbols_with_external_utility(sess, \"strip\", &out_filename, Some(\"-x\"))\n+            }\n+            (Strip::Symbols, _) => {\n+                strip_symbols_with_external_utility(sess, \"strip\", &out_filename, None)\n             }\n-            (Strip::Symbols, _) => strip_symbols_in_osx(sess, &out_filename, None),\n             (Strip::None, _) => {}\n         }\n     }\n \n+    if sess.target.os == \"illumos\" {\n+        // Many illumos systems will have both the native 'strip' utility and\n+        // the GNU one. Use the native version explicitly and do not rely on\n+        // what's in the path.\n+        let stripcmd = \"/usr/bin/strip\";\n+        match strip {\n+            // Always preserve the symbol table (-x).\n+            Strip::Debuginfo => {\n+                strip_symbols_with_external_utility(sess, stripcmd, &out_filename, Some(\"-x\"))\n+            }\n+            // Strip::Symbols is handled via the --strip-all linker option.\n+            Strip::Symbols => {}\n+            Strip::None => {}\n+        }\n+    }\n+\n     Ok(())\n }\n \n@@ -1055,8 +1052,13 @@ fn strip_value(sess: &Session) -> Strip {\n     }\n }\n \n-fn strip_symbols_in_osx<'a>(sess: &'a Session, out_filename: &Path, option: Option<&str>) {\n-    let mut cmd = Command::new(\"strip\");\n+fn strip_symbols_with_external_utility<'a>(\n+    sess: &'a Session,\n+    util: &str,\n+    out_filename: &Path,\n+    option: Option<&str>,\n+) {\n+    let mut cmd = Command::new(util);\n     if let Some(option) = option {\n         cmd.arg(option);\n     }\n@@ -1067,14 +1069,14 @@ fn strip_symbols_in_osx<'a>(sess: &'a Session, out_filename: &Path, option: Opti\n                 let mut output = prog.stderr.clone();\n                 output.extend_from_slice(&prog.stdout);\n                 sess.struct_warn(&format!(\n-                    \"stripping debug info with `strip` failed: {}\",\n-                    prog.status\n+                    \"stripping debug info with `{}` failed: {}\",\n+                    util, prog.status\n                 ))\n                 .note(&escape_string(&output))\n                 .emit();\n             }\n         }\n-        Err(e) => sess.fatal(&format!(\"unable to run `strip`: {}\", e)),\n+        Err(e) => sess.fatal(&format!(\"unable to run `{}`: {}\", util, e)),\n     }\n }\n \n@@ -1187,7 +1189,10 @@ pub fn linker_and_flavor(sess: &Session) -> (PathBuf, LinkerFlavor) {\n             // only the linker flavor is known; use the default linker for the selected flavor\n             (None, Some(flavor)) => Some((\n                 PathBuf::from(match flavor {\n-                    LinkerFlavor::Gcc => {\n+                    LinkerFlavor::Gnu(Cc::Yes, _)\n+                    | LinkerFlavor::Darwin(Cc::Yes, _)\n+                    | LinkerFlavor::WasmLld(Cc::Yes)\n+                    | LinkerFlavor::Unix(Cc::Yes) => {\n                         if cfg!(any(target_os = \"solaris\", target_os = \"illumos\")) {\n                             // On historical Solaris systems, \"cc\" may have\n                             // been Sun Studio, which is not flag-compatible\n@@ -1200,9 +1205,14 @@ pub fn linker_and_flavor(sess: &Session) -> (PathBuf, LinkerFlavor) {\n                             \"cc\"\n                         }\n                     }\n-                    LinkerFlavor::Ld => \"ld\",\n-                    LinkerFlavor::Lld(_) => \"lld\",\n-                    LinkerFlavor::Msvc => \"link.exe\",\n+                    LinkerFlavor::Gnu(_, Lld::Yes)\n+                    | LinkerFlavor::Darwin(_, Lld::Yes)\n+                    | LinkerFlavor::WasmLld(..)\n+                    | LinkerFlavor::Msvc(Lld::Yes) => \"lld\",\n+                    LinkerFlavor::Gnu(..) | LinkerFlavor::Darwin(..) | LinkerFlavor::Unix(..) => {\n+                        \"ld\"\n+                    }\n+                    LinkerFlavor::Msvc(..) => \"link.exe\",\n                     LinkerFlavor::EmCc => {\n                         if cfg!(windows) {\n                             \"emcc.bat\"\n@@ -1227,15 +1237,20 @@ pub fn linker_and_flavor(sess: &Session) -> (PathBuf, LinkerFlavor) {\n                     || stem == \"clang\"\n                     || stem.ends_with(\"-clang\")\n                 {\n-                    LinkerFlavor::Gcc\n+                    LinkerFlavor::from_cli(LinkerFlavorCli::Gcc, &sess.target)\n                 } else if stem == \"wasm-ld\" || stem.ends_with(\"-wasm-ld\") {\n-                    LinkerFlavor::Lld(LldFlavor::Wasm)\n-                } else if stem == \"ld\" || stem == \"ld.lld\" || stem.ends_with(\"-ld\") {\n-                    LinkerFlavor::Ld\n-                } else if stem == \"link\" || stem == \"lld-link\" {\n-                    LinkerFlavor::Msvc\n+                    LinkerFlavor::WasmLld(Cc::No)\n+                } else if stem == \"ld\" || stem.ends_with(\"-ld\") {\n+                    LinkerFlavor::from_cli(LinkerFlavorCli::Ld, &sess.target)\n+                } else if stem == \"ld.lld\" {\n+                    LinkerFlavor::Gnu(Cc::No, Lld::Yes)\n+                } else if stem == \"link\" {\n+                    LinkerFlavor::Msvc(Lld::No)\n+                } else if stem == \"lld-link\" {\n+                    LinkerFlavor::Msvc(Lld::Yes)\n                 } else if stem == \"lld\" || stem == \"rust-lld\" {\n-                    LinkerFlavor::Lld(sess.target.lld_flavor)\n+                    let lld_flavor = sess.target.linker_flavor.lld_flavor();\n+                    LinkerFlavor::from_cli(LinkerFlavorCli::Lld(lld_flavor), &sess.target)\n                 } else {\n                     // fall back to the value in the target spec\n                     sess.target.linker_flavor\n@@ -1249,7 +1264,8 @@ pub fn linker_and_flavor(sess: &Session) -> (PathBuf, LinkerFlavor) {\n \n     // linker and linker flavor specified via command line have precedence over what the target\n     // specification specifies\n-    let linker_flavor = sess.opts.cg.linker_flavor.map(LinkerFlavor::from_cli);\n+    let linker_flavor =\n+        sess.opts.cg.linker_flavor.map(|flavor| LinkerFlavor::from_cli(flavor, &sess.target));\n     if let Some(ret) = infer_from(sess, sess.opts.cg.linker.clone(), linker_flavor) {\n         return ret;\n     }\n@@ -1320,7 +1336,7 @@ fn print_native_static_libs(sess: &Session, all_native_libs: &[NativeLib]) {\n                     let verbatim = lib.verbatim.unwrap_or(false);\n                     if sess.target.is_like_msvc {\n                         Some(format!(\"{}{}\", name, if verbatim { \"\" } else { \".lib\" }))\n-                    } else if sess.target.linker_is_gnu {\n+                    } else if sess.target.linker_flavor.is_gnu() {\n                         Some(format!(\"-l{}{}\", if verbatim { \":\" } else { \"\" }, name))\n                     } else {\n                         Some(format!(\"-l{}\", name))\n@@ -1607,7 +1623,7 @@ fn add_pre_link_objects(\n     let empty = Default::default();\n     let objects = if self_contained {\n         &opts.pre_link_objects_self_contained\n-    } else if !(sess.target.os == \"fuchsia\" && flavor == LinkerFlavor::Gcc) {\n+    } else if !(sess.target.os == \"fuchsia\" && matches!(flavor, LinkerFlavor::Gnu(Cc::Yes, _))) {\n         &opts.pre_link_objects\n     } else {\n         &empty\n@@ -1647,7 +1663,7 @@ fn add_pre_link_args(cmd: &mut dyn Linker, sess: &Session, flavor: LinkerFlavor)\n fn add_link_script(cmd: &mut dyn Linker, sess: &Session, tmpdir: &Path, crate_type: CrateType) {\n     match (crate_type, &sess.target.link_script) {\n         (CrateType::Cdylib | CrateType::Executable, Some(script)) => {\n-            if !sess.target.linker_is_gnu {\n+            if !sess.target.linker_flavor.is_gnu() {\n                 sess.fatal(\"can only use link script when linking with GNU-like linker\");\n             }\n \n@@ -1890,7 +1906,7 @@ fn add_rpath_args(\n             out_filename: out_filename.to_path_buf(),\n             has_rpath: sess.target.has_rpath,\n             is_like_osx: sess.target.is_like_osx,\n-            linker_is_gnu: sess.target.linker_is_gnu,\n+            linker_is_gnu: sess.target.linker_flavor.is_gnu(),\n         };\n         cmd.args(&rpath::get_rpath_flags(&mut rpath_config));\n     }\n@@ -2104,7 +2120,7 @@ fn add_order_independent_options(\n \n     if sess.target.os == \"fuchsia\"\n         && crate_type == CrateType::Executable\n-        && flavor != LinkerFlavor::Gcc\n+        && !matches!(flavor, LinkerFlavor::Gnu(Cc::Yes, _))\n     {\n         let prefix = if sess.opts.unstable_opts.sanitizer.contains(SanitizerSet::ADDRESS) {\n             \"asan/\"\n@@ -2699,7 +2715,7 @@ fn relevant_lib(sess: &Session, lib: &NativeLib) -> bool {\n     }\n }\n \n-fn are_upstream_rust_objects_already_included(sess: &Session) -> bool {\n+pub(crate) fn are_upstream_rust_objects_already_included(sess: &Session) -> bool {\n     match sess.lto() {\n         config::Lto::Fat => true,\n         config::Lto::Thin => {\n@@ -2717,12 +2733,12 @@ fn add_apple_sdk(cmd: &mut dyn Linker, sess: &Session, flavor: LinkerFlavor) {\n     let llvm_target = &sess.target.llvm_target;\n     if sess.target.vendor != \"apple\"\n         || !matches!(os.as_ref(), \"ios\" | \"tvos\" | \"watchos\" | \"macos\")\n-        || (flavor != LinkerFlavor::Gcc && flavor != LinkerFlavor::Lld(LldFlavor::Ld64))\n+        || !matches!(flavor, LinkerFlavor::Darwin(..))\n     {\n         return;\n     }\n \n-    if os == \"macos\" && flavor != LinkerFlavor::Lld(LldFlavor::Ld64) {\n+    if os == \"macos\" && !matches!(flavor, LinkerFlavor::Darwin(Cc::No, _)) {\n         return;\n     }\n \n@@ -2756,10 +2772,10 @@ fn add_apple_sdk(cmd: &mut dyn Linker, sess: &Session, flavor: LinkerFlavor) {\n     };\n \n     match flavor {\n-        LinkerFlavor::Gcc => {\n+        LinkerFlavor::Darwin(Cc::Yes, _) => {\n             cmd.args(&[\"-isysroot\", &sdk_root, \"-Wl,-syslibroot\", &sdk_root]);\n         }\n-        LinkerFlavor::Lld(LldFlavor::Ld64) => {\n+        LinkerFlavor::Darwin(Cc::No, _) => {\n             cmd.args(&[\"-syslibroot\", &sdk_root]);\n         }\n         _ => unreachable!(),\n@@ -2822,7 +2838,10 @@ fn get_apple_sdk_root(sdk_name: &str) -> Result<String, String> {\n \n fn add_gcc_ld_path(cmd: &mut dyn Linker, sess: &Session, flavor: LinkerFlavor) {\n     if let Some(ld_impl) = sess.opts.unstable_opts.gcc_ld {\n-        if let LinkerFlavor::Gcc = flavor {\n+        if let LinkerFlavor::Gnu(Cc::Yes, _)\n+        | LinkerFlavor::Darwin(Cc::Yes, _)\n+        | LinkerFlavor::WasmLld(Cc::Yes) = flavor\n+        {\n             match ld_impl {\n                 LdImpl::Lld => {\n                     // Implement the \"self-contained\" part of -Zgcc-ld\n@@ -2837,7 +2856,7 @@ fn add_gcc_ld_path(cmd: &mut dyn Linker, sess: &Session, flavor: LinkerFlavor) {\n                     // Implement the \"linker flavor\" part of -Zgcc-ld\n                     // by asking cc to use some kind of lld.\n                     cmd.arg(\"-fuse-ld=lld\");\n-                    if sess.target.lld_flavor != LldFlavor::Ld {\n+                    if !flavor.is_gnu() {\n                         // Tell clang to use a non-default LLD flavor.\n                         // Gcc doesn't understand the target option, but we currently assume\n                         // that gcc is not used for Apple and Wasm targets (#97402)."}, {"sha": "c49b19bdf0094b9b39663c59b35d96007a7e2d6b", "filename": "compiler/rustc_codegen_ssa/src/back/linker.rs", "status": "modified", "additions": 76, "deletions": 79, "changes": 155, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flinker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flinker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flinker.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "patch": "@@ -1,5 +1,6 @@\n use super::command::Command;\n use super::symbol_export;\n+use crate::errors;\n use rustc_span::symbol::sym;\n \n use std::ffi::{OsStr, OsString};\n@@ -16,7 +17,7 @@ use rustc_middle::middle::exported_symbols::{ExportedSymbol, SymbolExportInfo, S\n use rustc_middle::ty::TyCtxt;\n use rustc_session::config::{self, CrateType, DebugInfo, LinkerPluginLto, Lto, OptLevel, Strip};\n use rustc_session::Session;\n-use rustc_target::spec::{LinkOutputKind, LinkerFlavor, LldFlavor};\n+use rustc_target::spec::{Cc, LinkOutputKind, LinkerFlavor, Lld};\n \n use cc::windows_registry;\n \n@@ -56,8 +57,13 @@ pub fn get_linker<'a>(\n     let mut cmd = match linker.to_str() {\n         Some(linker) if cfg!(windows) && linker.ends_with(\".bat\") => Command::bat_script(linker),\n         _ => match flavor {\n-            LinkerFlavor::Lld(f) => Command::lld(linker, f),\n-            LinkerFlavor::Msvc if sess.opts.cg.linker.is_none() && sess.target.linker.is_none() => {\n+            LinkerFlavor::Gnu(Cc::No, Lld::Yes)\n+            | LinkerFlavor::Darwin(Cc::No, Lld::Yes)\n+            | LinkerFlavor::WasmLld(Cc::No)\n+            | LinkerFlavor::Msvc(Lld::Yes) => Command::lld(linker, flavor.lld_flavor()),\n+            LinkerFlavor::Msvc(Lld::No)\n+                if sess.opts.cg.linker.is_none() && sess.target.linker.is_none() =>\n+            {\n                 Command::new(msvc_tool.as_ref().map_or(linker, |t| t.path()))\n             }\n             _ => Command::new(linker),\n@@ -68,9 +74,7 @@ pub fn get_linker<'a>(\n     // To comply with the Windows App Certification Kit,\n     // MSVC needs to link with the Store versions of the runtime libraries (vcruntime, msvcrt, etc).\n     let t = &sess.target;\n-    if (flavor == LinkerFlavor::Msvc || flavor == LinkerFlavor::Lld(LldFlavor::Link))\n-        && t.vendor == \"uwp\"\n-    {\n+    if matches!(flavor, LinkerFlavor::Msvc(..)) && t.vendor == \"uwp\" {\n         if let Some(ref tool) = msvc_tool {\n             let original_path = tool.path();\n             if let Some(ref root_lib_path) = original_path.ancestors().nth(4) {\n@@ -126,23 +130,22 @@ pub fn get_linker<'a>(\n     // to the linker args construction.\n     assert!(cmd.get_args().is_empty() || sess.target.vendor == \"uwp\");\n     match flavor {\n-        LinkerFlavor::Gcc => {\n-            Box::new(GccLinker { cmd, sess, target_cpu, hinted_static: false, is_ld: false })\n-                as Box<dyn Linker>\n-        }\n-        LinkerFlavor::Ld if sess.target.os == \"l4re\" => {\n+        LinkerFlavor::Unix(Cc::No) if sess.target.os == \"l4re\" => {\n             Box::new(L4Bender::new(cmd, sess)) as Box<dyn Linker>\n         }\n-        LinkerFlavor::Lld(LldFlavor::Ld)\n-        | LinkerFlavor::Lld(LldFlavor::Ld64)\n-        | LinkerFlavor::Ld => {\n-            Box::new(GccLinker { cmd, sess, target_cpu, hinted_static: false, is_ld: true })\n-                as Box<dyn Linker>\n-        }\n-        LinkerFlavor::Lld(LldFlavor::Link) | LinkerFlavor::Msvc => {\n-            Box::new(MsvcLinker { cmd, sess }) as Box<dyn Linker>\n-        }\n-        LinkerFlavor::Lld(LldFlavor::Wasm) => Box::new(WasmLd::new(cmd, sess)) as Box<dyn Linker>,\n+        LinkerFlavor::WasmLld(Cc::No) => Box::new(WasmLd::new(cmd, sess)) as Box<dyn Linker>,\n+        LinkerFlavor::Gnu(cc, _)\n+        | LinkerFlavor::Darwin(cc, _)\n+        | LinkerFlavor::WasmLld(cc)\n+        | LinkerFlavor::Unix(cc) => Box::new(GccLinker {\n+            cmd,\n+            sess,\n+            target_cpu,\n+            hinted_static: false,\n+            is_ld: cc == Cc::No,\n+            is_gnu: flavor.is_gnu(),\n+        }) as Box<dyn Linker>,\n+        LinkerFlavor::Msvc(..) => Box::new(MsvcLinker { cmd, sess }) as Box<dyn Linker>,\n         LinkerFlavor::EmCc => Box::new(EmLinker { cmd, sess }) as Box<dyn Linker>,\n         LinkerFlavor::Bpf => Box::new(BpfLinker { cmd, sess }) as Box<dyn Linker>,\n         LinkerFlavor::Ptx => Box::new(PtxLinker { cmd, sess }) as Box<dyn Linker>,\n@@ -211,6 +214,7 @@ pub struct GccLinker<'a> {\n     hinted_static: bool, // Keeps track of the current hinting mode.\n     // Link as ld\n     is_ld: bool,\n+    is_gnu: bool,\n }\n \n impl<'a> GccLinker<'a> {\n@@ -359,7 +363,7 @@ impl<'a> Linker for GccLinker<'a> {\n     fn set_output_kind(&mut self, output_kind: LinkOutputKind, out_filename: &Path) {\n         match output_kind {\n             LinkOutputKind::DynamicNoPicExe => {\n-                if !self.is_ld && self.sess.target.linker_is_gnu {\n+                if !self.is_ld && self.is_gnu {\n                     self.cmd.arg(\"-no-pie\");\n                 }\n             }\n@@ -373,7 +377,7 @@ impl<'a> Linker for GccLinker<'a> {\n             LinkOutputKind::StaticNoPicExe => {\n                 // `-static` works for both gcc wrapper and ld.\n                 self.cmd.arg(\"-static\");\n-                if !self.is_ld && self.sess.target.linker_is_gnu {\n+                if !self.is_ld && self.is_gnu {\n                     self.cmd.arg(\"-no-pie\");\n                 }\n             }\n@@ -431,32 +435,26 @@ impl<'a> Linker for GccLinker<'a> {\n                 // FIXME(81490): ld64 doesn't support these flags but macOS 11\n                 // has -needed-l{} / -needed_library {}\n                 // but we have no way to detect that here.\n-                self.sess.warn(\"`as-needed` modifier not implemented yet for ld64\");\n-            } else if self.sess.target.linker_is_gnu && !self.sess.target.is_like_windows {\n+                self.sess.emit_warning(errors::Ld64UnimplementedModifier);\n+            } else if self.is_gnu && !self.sess.target.is_like_windows {\n                 self.linker_arg(\"--no-as-needed\");\n             } else {\n-                self.sess.warn(\"`as-needed` modifier not supported for current linker\");\n+                self.sess.emit_warning(errors::LinkerUnsupportedModifier);\n             }\n         }\n         self.hint_dynamic();\n-        self.cmd.arg(format!(\n-            \"-l{}{lib}\",\n-            if verbatim && self.sess.target.linker_is_gnu { \":\" } else { \"\" },\n-        ));\n+        self.cmd.arg(format!(\"-l{}{lib}\", if verbatim && self.is_gnu { \":\" } else { \"\" },));\n         if !as_needed {\n             if self.sess.target.is_like_osx {\n                 // See above FIXME comment\n-            } else if self.sess.target.linker_is_gnu && !self.sess.target.is_like_windows {\n+            } else if self.is_gnu && !self.sess.target.is_like_windows {\n                 self.linker_arg(\"--as-needed\");\n             }\n         }\n     }\n     fn link_staticlib(&mut self, lib: &str, verbatim: bool) {\n         self.hint_static();\n-        self.cmd.arg(format!(\n-            \"-l{}{lib}\",\n-            if verbatim && self.sess.target.linker_is_gnu { \":\" } else { \"\" },\n-        ));\n+        self.cmd.arg(format!(\"-l{}{lib}\", if verbatim && self.is_gnu { \":\" } else { \"\" },));\n     }\n     fn link_rlib(&mut self, lib: &Path) {\n         self.hint_static();\n@@ -495,7 +493,7 @@ impl<'a> Linker for GccLinker<'a> {\n             // FIXME(81490): ld64 as of macOS 11 supports the -needed_framework\n             // flag but we have no way to detect that here.\n             // self.cmd.arg(\"-needed_framework\").arg(framework);\n-            self.sess.warn(\"`as-needed` modifier not implemented yet for ld64\");\n+            self.sess.emit_warning(errors::Ld64UnimplementedModifier);\n         }\n         self.cmd.arg(\"-framework\").arg(framework);\n     }\n@@ -511,10 +509,7 @@ impl<'a> Linker for GccLinker<'a> {\n         let target = &self.sess.target;\n         if !target.is_like_osx {\n             self.linker_arg(\"--whole-archive\");\n-            self.cmd.arg(format!(\n-                \"-l{}{lib}\",\n-                if verbatim && self.sess.target.linker_is_gnu { \":\" } else { \"\" },\n-            ));\n+            self.cmd.arg(format!(\"-l{}{lib}\", if verbatim && self.is_gnu { \":\" } else { \"\" },));\n             self.linker_arg(\"--no-whole-archive\");\n         } else {\n             // -force_load is the macOS equivalent of --whole-archive, but it\n@@ -559,21 +554,19 @@ impl<'a> Linker for GccLinker<'a> {\n         // eliminate the metadata. If we're building an executable, however,\n         // --gc-sections drops the size of hello world from 1.8MB to 597K, a 67%\n         // reduction.\n-        } else if (self.sess.target.linker_is_gnu || self.sess.target.is_like_wasm)\n-            && !keep_metadata\n-        {\n+        } else if (self.is_gnu || self.sess.target.is_like_wasm) && !keep_metadata {\n             self.linker_arg(\"--gc-sections\");\n         }\n     }\n \n     fn no_gc_sections(&mut self) {\n-        if self.sess.target.linker_is_gnu || self.sess.target.is_like_wasm {\n+        if self.is_gnu || self.sess.target.is_like_wasm {\n             self.linker_arg(\"--no-gc-sections\");\n         }\n     }\n \n     fn optimize(&mut self) {\n-        if !self.sess.target.linker_is_gnu && !self.sess.target.is_like_wasm {\n+        if !self.is_gnu && !self.sess.target.is_like_wasm {\n             return;\n         }\n \n@@ -587,7 +580,7 @@ impl<'a> Linker for GccLinker<'a> {\n     }\n \n     fn pgo_gen(&mut self) {\n-        if !self.sess.target.linker_is_gnu {\n+        if !self.is_gnu {\n             return;\n         }\n \n@@ -617,7 +610,13 @@ impl<'a> Linker for GccLinker<'a> {\n         match strip {\n             Strip::None => {}\n             Strip::Debuginfo => {\n-                self.linker_arg(\"--strip-debug\");\n+                // The illumos linker does not support --strip-debug although\n+                // it does support --strip-all as a compatibility alias for -s.\n+                // The --strip-debug case is handled by running an external\n+                // `strip` utility as a separate step after linking.\n+                if self.sess.target.os != \"illumos\" {\n+                    self.linker_arg(\"--strip-debug\");\n+                }\n             }\n             Strip::Symbols => {\n                 self.linker_arg(\"--strip-all\");\n@@ -673,8 +672,8 @@ impl<'a> Linker for GccLinker<'a> {\n                     writeln!(f, \"_{}\", sym)?;\n                 }\n             };\n-            if let Err(e) = res {\n-                self.sess.fatal(&format!(\"failed to write lib.def file: {}\", e));\n+            if let Err(error) = res {\n+                self.sess.emit_fatal(errors::LibDefWriteFailure { error });\n             }\n         } else if is_windows {\n             let res: io::Result<()> = try {\n@@ -688,8 +687,8 @@ impl<'a> Linker for GccLinker<'a> {\n                     writeln!(f, \"  {}\", symbol)?;\n                 }\n             };\n-            if let Err(e) = res {\n-                self.sess.fatal(&format!(\"failed to write list.def file: {}\", e));\n+            if let Err(error) = res {\n+                self.sess.emit_fatal(errors::LibDefWriteFailure { error });\n             }\n         } else {\n             // Write an LD version script\n@@ -705,8 +704,8 @@ impl<'a> Linker for GccLinker<'a> {\n                 }\n                 writeln!(f, \"\\n  local:\\n    *;\\n}};\")?;\n             };\n-            if let Err(e) = res {\n-                self.sess.fatal(&format!(\"failed to write version script: {}\", e));\n+            if let Err(error) = res {\n+                self.sess.emit_fatal(errors::VersionScriptWriteFailure { error });\n             }\n         }\n \n@@ -758,13 +757,13 @@ impl<'a> Linker for GccLinker<'a> {\n     fn add_no_exec(&mut self) {\n         if self.sess.target.is_like_windows {\n             self.linker_arg(\"--nxcompat\");\n-        } else if self.sess.target.linker_is_gnu {\n+        } else if self.is_gnu {\n             self.linker_arg(\"-znoexecstack\");\n         }\n     }\n \n     fn add_as_needed(&mut self) {\n-        if self.sess.target.linker_is_gnu && !self.sess.target.is_like_windows {\n+        if self.is_gnu && !self.sess.target.is_like_windows {\n             self.linker_arg(\"--as-needed\");\n         } else if self.sess.target.is_like_solaris {\n             // -z ignore is the Solaris equivalent to the GNU ld --as-needed option\n@@ -923,9 +922,8 @@ impl<'a> Linker for MsvcLinker<'a> {\n                                     self.cmd.arg(arg);\n                                 }\n                             }\n-                            Err(err) => {\n-                                self.sess\n-                                    .warn(&format!(\"error enumerating natvis directory: {}\", err));\n+                            Err(error) => {\n+                                self.sess.emit_warning(errors::NoNatvisDirectory { error });\n                             }\n                         }\n                     }\n@@ -979,8 +977,8 @@ impl<'a> Linker for MsvcLinker<'a> {\n                 writeln!(f, \"  {}\", symbol)?;\n             }\n         };\n-        if let Err(e) = res {\n-            self.sess.fatal(&format!(\"failed to write lib.def file: {}\", e));\n+        if let Err(error) = res {\n+            self.sess.emit_fatal(errors::LibDefWriteFailure { error });\n         }\n         let mut arg = OsString::from(\"/DEF:\");\n         arg.push(path);\n@@ -1180,22 +1178,19 @@ impl<'a> WasmLd<'a> {\n         //   sharing memory and instantiating the module multiple times. As a\n         //   result if it were exported then we'd just have no sharing.\n         //\n-        // * `--export=__wasm_init_memory` - when using `--passive-segments` the\n-        //   linker will synthesize this function, and so we need to make sure\n-        //   that our usage of `--export` below won't accidentally cause this\n-        //   function to get deleted.\n-        //\n-        // * `--export=*tls*` - when `#[thread_local]` symbols are used these\n-        //   symbols are how the TLS segments are initialized and configured.\n+        // On wasm32-unknown-unknown, we also export symbols for glue code to use:\n+        //    * `--export=*tls*` - when `#[thread_local]` symbols are used these\n+        //      symbols are how the TLS segments are initialized and configured.\n         if sess.target_features.contains(&sym::atomics) {\n             cmd.arg(\"--shared-memory\");\n             cmd.arg(\"--max-memory=1073741824\");\n             cmd.arg(\"--import-memory\");\n-            cmd.arg(\"--export=__wasm_init_memory\");\n-            cmd.arg(\"--export=__wasm_init_tls\");\n-            cmd.arg(\"--export=__tls_size\");\n-            cmd.arg(\"--export=__tls_align\");\n-            cmd.arg(\"--export=__tls_base\");\n+            if sess.target.os == \"unknown\" {\n+                cmd.arg(\"--export=__wasm_init_tls\");\n+                cmd.arg(\"--export=__tls_size\");\n+                cmd.arg(\"--export=__tls_align\");\n+                cmd.arg(\"--export=__tls_base\");\n+            }\n         }\n         WasmLd { cmd, sess }\n     }\n@@ -1320,10 +1315,12 @@ impl<'a> Linker for WasmLd<'a> {\n \n         // LLD will hide these otherwise-internal symbols since it only exports\n         // symbols explicitly passed via the `--export` flags above and hides all\n-        // others. Various bits and pieces of tooling use this, so be sure these\n-        // symbols make their way out of the linker as well.\n-        self.cmd.arg(\"--export=__heap_base\");\n-        self.cmd.arg(\"--export=__data_end\");\n+        // others. Various bits and pieces of wasm32-unknown-unknown tooling use\n+        // this, so be sure these symbols make their way out of the linker as well.\n+        if self.sess.target.os == \"unknown\" {\n+            self.cmd.arg(\"--export=__heap_base\");\n+            self.cmd.arg(\"--export=__data_end\");\n+        }\n     }\n \n     fn subsystem(&mut self, _subsystem: &str) {}\n@@ -1444,7 +1441,7 @@ impl<'a> Linker for L4Bender<'a> {\n \n     fn export_symbols(&mut self, _: &Path, _: CrateType, _: &[String]) {\n         // ToDo, not implemented, copy from GCC\n-        self.sess.warn(\"exporting symbols not implemented yet for L4Bender\");\n+        self.sess.emit_warning(errors::L4BenderExportingSymbolsUnimplemented);\n         return;\n     }\n \n@@ -1736,8 +1733,8 @@ impl<'a> Linker for BpfLinker<'a> {\n                 writeln!(f, \"{}\", sym)?;\n             }\n         };\n-        if let Err(e) = res {\n-            self.sess.fatal(&format!(\"failed to write symbols file: {}\", e));\n+        if let Err(error) = res {\n+            self.sess.emit_fatal(errors::SymbolFileWriteFailure { error });\n         } else {\n             self.cmd.arg(\"--export-symbols\").arg(&path);\n         }"}, {"sha": "a292bfce31eb86a9c15c35d22b04760394b9cc6f", "filename": "compiler/rustc_codegen_ssa/src/back/write.rs", "status": "modified", "additions": 18, "deletions": 27, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fwrite.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "patch": "@@ -2,11 +2,11 @@ use super::link::{self, ensure_removed};\n use super::lto::{self, SerializedModule};\n use super::symbol_export::symbol_name_for_instance_in_crate;\n \n+use crate::errors;\n+use crate::traits::*;\n use crate::{\n     CachedModuleCodegen, CodegenResults, CompiledModule, CrateInfo, ModuleCodegen, ModuleKind,\n };\n-\n-use crate::traits::*;\n use jobserver::{Acquired, Client};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::memmap::Mmap;\n@@ -15,7 +15,10 @@ use rustc_data_structures::profiling::TimingGuard;\n use rustc_data_structures::profiling::VerboseTimingGuard;\n use rustc_data_structures::sync::Lrc;\n use rustc_errors::emitter::Emitter;\n-use rustc_errors::{translation::Translate, DiagnosticId, FatalError, Handler, Level};\n+use rustc_errors::{\n+    translation::{to_fluent_args, Translate},\n+    DiagnosticId, FatalError, Handler, Level,\n+};\n use rustc_fs_util::link_or_copy;\n use rustc_hir::def_id::{CrateNum, LOCAL_CRATE};\n use rustc_incremental::{\n@@ -113,7 +116,6 @@ pub struct ModuleConfig {\n     pub vectorize_slp: bool,\n     pub merge_functions: bool,\n     pub inline_threshold: Option<u32>,\n-    pub new_llvm_pass_manager: Option<bool>,\n     pub emit_lifetime_markers: bool,\n     pub llvm_plugins: Vec<String>,\n }\n@@ -265,7 +267,6 @@ impl ModuleConfig {\n             },\n \n             inline_threshold: sess.opts.cg.inline_threshold,\n-            new_llvm_pass_manager: sess.opts.unstable_opts.new_llvm_pass_manager,\n             emit_lifetime_markers: sess.emit_lifetime_markers(),\n             llvm_plugins: if_regular!(sess.opts.unstable_opts.llvm_plugins.clone(), vec![]),\n         }\n@@ -532,7 +533,7 @@ fn produce_final_output_artifacts(\n     // Produce final compile outputs.\n     let copy_gracefully = |from: &Path, to: &Path| {\n         if let Err(e) = fs::copy(from, to) {\n-            sess.err(&format!(\"could not copy {:?} to {:?}: {}\", from, to, e));\n+            sess.emit_err(errors::CopyPath::new(from, to, e));\n         }\n     };\n \n@@ -548,7 +549,7 @@ fn produce_final_output_artifacts(\n                 ensure_removed(sess.diagnostic(), &path);\n             }\n         } else {\n-            let ext = crate_output\n+            let extension = crate_output\n                 .temp_path(output_type, None)\n                 .extension()\n                 .unwrap()\n@@ -559,19 +560,11 @@ fn produce_final_output_artifacts(\n             if crate_output.outputs.contains_key(&output_type) {\n                 // 2) Multiple codegen units, with `--emit foo=some_name`.  We have\n                 //    no good solution for this case, so warn the user.\n-                sess.warn(&format!(\n-                    \"ignoring emit path because multiple .{} files \\\n-                                    were produced\",\n-                    ext\n-                ));\n+                sess.emit_warning(errors::IgnoringEmitPath { extension });\n             } else if crate_output.single_output_file.is_some() {\n                 // 3) Multiple codegen units, with `-o some_name`.  We have\n                 //    no good solution for this case, so warn the user.\n-                sess.warn(&format!(\n-                    \"ignoring -o because multiple .{} files \\\n-                                    were produced\",\n-                    ext\n-                ));\n+                sess.emit_warning(errors::IgnoringOutput { extension });\n             } else {\n                 // 4) Multiple codegen units, but no explicit name.  We\n                 //    just leave the `foo.0.x` files in place.\n@@ -882,14 +875,12 @@ fn execute_copy_from_cache_work_item<B: ExtraBackendMethods>(\n         );\n         match link_or_copy(&source_file, &output_path) {\n             Ok(_) => Some(output_path),\n-            Err(err) => {\n-                let diag_handler = cgcx.create_diag_handler();\n-                diag_handler.err(&format!(\n-                    \"unable to copy {} to {}: {}\",\n-                    source_file.display(),\n-                    output_path.display(),\n-                    err\n-                ));\n+            Err(error) => {\n+                cgcx.create_diag_handler().emit_err(errors::CopyPathBuf {\n+                    source_file,\n+                    output_path,\n+                    error,\n+                });\n                 None\n             }\n         }\n@@ -1639,7 +1630,7 @@ fn start_executing_work<B: ExtraBackendMethods>(\n         llvm_start_time: &mut Option<VerboseTimingGuard<'a>>,\n     ) {\n         if config.time_module && llvm_start_time.is_none() {\n-            *llvm_start_time = Some(prof.extra_verbose_generic_activity(\"LLVM_passes\", \"crate\"));\n+            *llvm_start_time = Some(prof.verbose_generic_activity(\"LLVM_passes\"));\n         }\n     }\n }\n@@ -1752,7 +1743,7 @@ impl Translate for SharedEmitter {\n \n impl Emitter for SharedEmitter {\n     fn emit_diagnostic(&mut self, diag: &rustc_errors::Diagnostic) {\n-        let fluent_args = self.to_fluent_args(diag.args());\n+        let fluent_args = to_fluent_args(diag.args());\n         drop(self.sender.send(SharedEmitterMessage::Diagnostic(Diagnostic {\n             msg: self.translate_messages(&diag.message, &fluent_args).to_string(),\n             code: diag.code.clone(),"}, {"sha": "ff1eee37ad9c04d1f4fcc67772b72f6df5cb4a62", "filename": "compiler/rustc_codegen_ssa/src/base.rs", "status": "modified", "additions": 60, "deletions": 17, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "patch": "@@ -1,3 +1,4 @@\n+use crate::back::link::are_upstream_rust_objects_already_included;\n use crate::back::metadata::create_compressed_metadata_file;\n use crate::back::write::{\n     compute_per_cgu_lto_type, start_async_codegen, submit_codegened_module_to_llvm,\n@@ -38,7 +39,7 @@ use rustc_session::Session;\n use rustc_span::symbol::sym;\n use rustc_span::Symbol;\n use rustc_span::{DebuggerVisualizerFile, DebuggerVisualizerType};\n-use rustc_target::abi::{Align, VariantIdx};\n+use rustc_target::abi::{Align, Size, VariantIdx};\n \n use std::collections::BTreeSet;\n use std::convert::TryFrom;\n@@ -150,7 +151,12 @@ pub fn unsized_info<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n         (&ty::Array(_, len), &ty::Slice(_)) => {\n             cx.const_usize(len.eval_usize(cx.tcx(), ty::ParamEnv::reveal_all()))\n         }\n-        (&ty::Dynamic(ref data_a, ..), &ty::Dynamic(ref data_b, ..)) => {\n+        (\n+            &ty::Dynamic(ref data_a, _, src_dyn_kind),\n+            &ty::Dynamic(ref data_b, _, target_dyn_kind),\n+        ) => {\n+            assert_eq!(src_dyn_kind, target_dyn_kind);\n+\n             let old_info =\n                 old_info.expect(\"unsized_info: missing old info for trait upcasting coercion\");\n             if data_a.principal_def_id() == data_b.principal_def_id() {\n@@ -166,11 +172,7 @@ pub fn unsized_info<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n             if let Some(entry_idx) = vptr_entry_idx {\n                 let ptr_ty = cx.type_i8p();\n                 let ptr_align = cx.tcx().data_layout.pointer_align.abi;\n-                let vtable_ptr_ty = cx.scalar_pair_element_backend_type(\n-                    cx.layout_of(cx.tcx().mk_mut_ptr(target)),\n-                    1,\n-                    true,\n-                );\n+                let vtable_ptr_ty = vtable_ptr_ty(cx, target, target_dyn_kind);\n                 let llvtable = bx.pointercast(old_info, bx.type_ptr_to(ptr_ty));\n                 let gep = bx.inbounds_gep(\n                     ptr_ty,\n@@ -186,18 +188,32 @@ pub fn unsized_info<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n                 old_info\n             }\n         }\n-        (_, &ty::Dynamic(ref data, ..)) => {\n-            let vtable_ptr_ty = cx.scalar_pair_element_backend_type(\n-                cx.layout_of(cx.tcx().mk_mut_ptr(target)),\n-                1,\n-                true,\n-            );\n+        (_, &ty::Dynamic(ref data, _, target_dyn_kind)) => {\n+            let vtable_ptr_ty = vtable_ptr_ty(cx, target, target_dyn_kind);\n             cx.const_ptrcast(meth::get_vtable(cx, source, data.principal()), vtable_ptr_ty)\n         }\n         _ => bug!(\"unsized_info: invalid unsizing {:?} -> {:?}\", source, target),\n     }\n }\n \n+// Returns the vtable pointer type of a `dyn` or `dyn*` type\n+fn vtable_ptr_ty<'tcx, Cx: CodegenMethods<'tcx>>(\n+    cx: &Cx,\n+    target: Ty<'tcx>,\n+    kind: ty::DynKind,\n+) -> <Cx as BackendTypes>::Type {\n+    cx.scalar_pair_element_backend_type(\n+        cx.layout_of(match kind {\n+            // vtable is the second field of `*mut dyn Trait`\n+            ty::Dyn => cx.tcx().mk_mut_ptr(target),\n+            // vtable is the second field of `dyn* Trait`\n+            ty::DynStar => target,\n+        }),\n+        1,\n+        true,\n+    )\n+}\n+\n /// Coerces `src` to `dst_ty`. `src_ty` must be a pointer.\n pub fn unsize_ptr<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n     bx: &mut Bx,\n@@ -247,6 +263,29 @@ pub fn unsize_ptr<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n     }\n }\n \n+/// Coerces `src` to `dst_ty` which is guaranteed to be a `dyn*` type.\n+pub fn cast_to_dyn_star<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n+    bx: &mut Bx,\n+    src: Bx::Value,\n+    src_ty_and_layout: TyAndLayout<'tcx>,\n+    dst_ty: Ty<'tcx>,\n+    old_info: Option<Bx::Value>,\n+) -> (Bx::Value, Bx::Value) {\n+    debug!(\"cast_to_dyn_star: {:?} => {:?}\", src_ty_and_layout.ty, dst_ty);\n+    assert!(\n+        matches!(dst_ty.kind(), ty::Dynamic(_, _, ty::DynStar)),\n+        \"destination type must be a dyn*\"\n+    );\n+    // FIXME(dyn-star): this is probably not the best way to check if this is\n+    // a pointer, and really we should ensure that the value is a suitable\n+    // pointer earlier in the compilation process.\n+    let src = match src_ty_and_layout.pointee_info_at(bx.cx(), Size::ZERO) {\n+        Some(_) => bx.ptrtoint(src, bx.cx().type_isize()),\n+        None => bx.bitcast(src, bx.type_isize()),\n+    };\n+    (src, unsized_info(bx, src_ty_and_layout.ty, dst_ty, old_info))\n+}\n+\n /// Coerces `src`, which is a reference to a value of type `src_ty`,\n /// to a value of type `dst_ty`, and stores the result in `dst`.\n pub fn coerce_unsized_into<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n@@ -474,7 +513,7 @@ pub fn maybe_create_entry_wrapper<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n             (rust_main, start_ty, vec![arg_argc, arg_argv])\n         };\n \n-        let result = bx.call(start_ty, start_fn, &args, None);\n+        let result = bx.call(start_ty, None, start_fn, &args, None);\n         let cast = bx.intcast(result, cx.type_int(), true);\n         bx.ret(cast);\n \n@@ -854,10 +893,14 @@ impl CrateInfo {\n \n         // Handle circular dependencies in the standard library.\n         // See comment before `add_linked_symbol_object` function for the details.\n-        // With msvc-like linkers it's both unnecessary (they support circular dependencies),\n-        // and causes linking issues (when weak lang item symbols are \"privatized\" by LTO).\n+        // If global LTO is enabled then almost everything (*) is glued into a single object file,\n+        // so this logic is not necessary and can cause issues on some targets (due to weak lang\n+        // item symbols being \"privatized\" to that object file), so we disable it.\n+        // (*) Native libs, and `#[compiler_builtins]` and `#[no_builtins]` crates are not glued,\n+        // and we assume that they cannot define weak lang items. This is not currently enforced\n+        // by the compiler, but that's ok because all this stuff is unstable anyway.\n         let target = &tcx.sess.target;\n-        if !target.is_like_msvc {\n+        if !are_upstream_rust_objects_already_included(tcx.sess) {\n             let missing_weak_lang_items: FxHashSet<&Symbol> = info\n                 .used_crates\n                 .iter()"}, {"sha": "0ffe887202261f00196e8496d65a72b3b343e4c3", "filename": "compiler/rustc_codegen_ssa/src/errors.rs", "status": "added", "additions": 353, "deletions": 0, "changes": 353, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_codegen_ssa%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_codegen_ssa%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Ferrors.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "patch": "@@ -0,0 +1,353 @@\n+//! Errors emitted by codegen_ssa\n+\n+use crate::back::command::Command;\n+use rustc_errors::{\n+    fluent, DiagnosticArgValue, DiagnosticBuilder, ErrorGuaranteed, Handler, IntoDiagnostic,\n+    IntoDiagnosticArg,\n+};\n+use rustc_macros::Diagnostic;\n+use rustc_span::{Span, Symbol};\n+use std::borrow::Cow;\n+use std::io::Error;\n+use std::path::{Path, PathBuf};\n+use std::process::ExitStatus;\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_ssa::lib_def_write_failure)]\n+pub struct LibDefWriteFailure {\n+    pub error: Error,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_ssa::version_script_write_failure)]\n+pub struct VersionScriptWriteFailure {\n+    pub error: Error,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_ssa::symbol_file_write_failure)]\n+pub struct SymbolFileWriteFailure {\n+    pub error: Error,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_ssa::ld64_unimplemented_modifier)]\n+pub struct Ld64UnimplementedModifier;\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_ssa::linker_unsupported_modifier)]\n+pub struct LinkerUnsupportedModifier;\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_ssa::L4Bender_exporting_symbols_unimplemented)]\n+pub struct L4BenderExportingSymbolsUnimplemented;\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_ssa::no_natvis_directory)]\n+pub struct NoNatvisDirectory {\n+    pub error: Error,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_ssa::copy_path_buf)]\n+pub struct CopyPathBuf {\n+    pub source_file: PathBuf,\n+    pub output_path: PathBuf,\n+    pub error: Error,\n+}\n+\n+// Reports Paths using `Debug` implementation rather than Path's `Display` implementation.\n+#[derive(Diagnostic)]\n+#[diag(codegen_ssa::copy_path)]\n+pub struct CopyPath<'a> {\n+    from: DebugArgPath<'a>,\n+    to: DebugArgPath<'a>,\n+    error: Error,\n+}\n+\n+impl<'a> CopyPath<'a> {\n+    pub fn new(from: &'a Path, to: &'a Path, error: Error) -> CopyPath<'a> {\n+        CopyPath { from: DebugArgPath(from), to: DebugArgPath(to), error }\n+    }\n+}\n+\n+struct DebugArgPath<'a>(pub &'a Path);\n+\n+impl IntoDiagnosticArg for DebugArgPath<'_> {\n+    fn into_diagnostic_arg(self) -> rustc_errors::DiagnosticArgValue<'static> {\n+        DiagnosticArgValue::Str(Cow::Owned(format!(\"{:?}\", self.0)))\n+    }\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_ssa::ignoring_emit_path)]\n+pub struct IgnoringEmitPath {\n+    pub extension: String,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_ssa::ignoring_output)]\n+pub struct IgnoringOutput {\n+    pub extension: String,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_ssa::create_temp_dir)]\n+pub struct CreateTempDir {\n+    pub error: Error,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_ssa::incompatible_linking_modifiers)]\n+pub struct IncompatibleLinkingModifiers;\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_ssa::add_native_library)]\n+pub struct AddNativeLibrary {\n+    pub library_path: PathBuf,\n+    pub error: Error,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_ssa::multiple_external_func_decl)]\n+pub struct MultipleExternalFuncDecl<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub function: Symbol,\n+    pub library_name: &'a str,\n+}\n+\n+#[derive(Diagnostic)]\n+pub enum LinkRlibError {\n+    #[diag(codegen_ssa::rlib_missing_format)]\n+    MissingFormat,\n+\n+    #[diag(codegen_ssa::rlib_only_rmeta_found)]\n+    OnlyRmetaFound { crate_name: Symbol },\n+\n+    #[diag(codegen_ssa::rlib_not_found)]\n+    NotFound { crate_name: Symbol },\n+}\n+\n+pub struct ThorinErrorWrapper(pub thorin::Error);\n+\n+impl IntoDiagnostic<'_> for ThorinErrorWrapper {\n+    fn into_diagnostic(self, handler: &Handler) -> DiagnosticBuilder<'_, ErrorGuaranteed> {\n+        let mut diag;\n+        match self.0 {\n+            thorin::Error::ReadInput(_) => {\n+                diag = handler.struct_err(fluent::codegen_ssa::thorin_read_input_failure);\n+                diag\n+            }\n+            thorin::Error::ParseFileKind(_) => {\n+                diag = handler.struct_err(fluent::codegen_ssa::thorin_parse_input_file_kind);\n+                diag\n+            }\n+            thorin::Error::ParseObjectFile(_) => {\n+                diag = handler.struct_err(fluent::codegen_ssa::thorin_parse_input_object_file);\n+                diag\n+            }\n+            thorin::Error::ParseArchiveFile(_) => {\n+                diag = handler.struct_err(fluent::codegen_ssa::thorin_parse_input_archive_file);\n+                diag\n+            }\n+            thorin::Error::ParseArchiveMember(_) => {\n+                diag = handler.struct_err(fluent::codegen_ssa::thorin_parse_archive_member);\n+                diag\n+            }\n+            thorin::Error::InvalidInputKind => {\n+                diag = handler.struct_err(fluent::codegen_ssa::thorin_invalid_input_kind);\n+                diag\n+            }\n+            thorin::Error::DecompressData(_) => {\n+                diag = handler.struct_err(fluent::codegen_ssa::thorin_decompress_data);\n+                diag\n+            }\n+            thorin::Error::NamelessSection(_, offset) => {\n+                diag = handler.struct_err(fluent::codegen_ssa::thorin_section_without_name);\n+                diag.set_arg(\"offset\", format!(\"0x{:08x}\", offset));\n+                diag\n+            }\n+            thorin::Error::RelocationWithInvalidSymbol(section, offset) => {\n+                diag =\n+                    handler.struct_err(fluent::codegen_ssa::thorin_relocation_with_invalid_symbol);\n+                diag.set_arg(\"section\", section);\n+                diag.set_arg(\"offset\", format!(\"0x{:08x}\", offset));\n+                diag\n+            }\n+            thorin::Error::MultipleRelocations(section, offset) => {\n+                diag = handler.struct_err(fluent::codegen_ssa::thorin_multiple_relocations);\n+                diag.set_arg(\"section\", section);\n+                diag.set_arg(\"offset\", format!(\"0x{:08x}\", offset));\n+                diag\n+            }\n+            thorin::Error::UnsupportedRelocation(section, offset) => {\n+                diag = handler.struct_err(fluent::codegen_ssa::thorin_unsupported_relocation);\n+                diag.set_arg(\"section\", section);\n+                diag.set_arg(\"offset\", format!(\"0x{:08x}\", offset));\n+                diag\n+            }\n+            thorin::Error::MissingDwoName(id) => {\n+                diag = handler.struct_err(fluent::codegen_ssa::thorin_missing_dwo_name);\n+                diag.set_arg(\"id\", format!(\"0x{:08x}\", id));\n+                diag\n+            }\n+            thorin::Error::NoCompilationUnits => {\n+                diag = handler.struct_err(fluent::codegen_ssa::thorin_no_compilation_units);\n+                diag\n+            }\n+            thorin::Error::NoDie => {\n+                diag = handler.struct_err(fluent::codegen_ssa::thorin_no_die);\n+                diag\n+            }\n+            thorin::Error::TopLevelDieNotUnit => {\n+                diag = handler.struct_err(fluent::codegen_ssa::thorin_top_level_die_not_unit);\n+                diag\n+            }\n+            thorin::Error::MissingRequiredSection(section) => {\n+                diag = handler.struct_err(fluent::codegen_ssa::thorin_missing_required_section);\n+                diag.set_arg(\"section\", section);\n+                diag\n+            }\n+            thorin::Error::ParseUnitAbbreviations(_) => {\n+                diag = handler.struct_err(fluent::codegen_ssa::thorin_parse_unit_abbreviations);\n+                diag\n+            }\n+            thorin::Error::ParseUnitAttribute(_) => {\n+                diag = handler.struct_err(fluent::codegen_ssa::thorin_parse_unit_attribute);\n+                diag\n+            }\n+            thorin::Error::ParseUnitHeader(_) => {\n+                diag = handler.struct_err(fluent::codegen_ssa::thorin_parse_unit_header);\n+                diag\n+            }\n+            thorin::Error::ParseUnit(_) => {\n+                diag = handler.struct_err(fluent::codegen_ssa::thorin_parse_unit);\n+                diag\n+            }\n+            thorin::Error::IncompatibleIndexVersion(section, format, actual) => {\n+                diag = handler.struct_err(fluent::codegen_ssa::thorin_incompatible_index_version);\n+                diag.set_arg(\"section\", section);\n+                diag.set_arg(\"actual\", actual);\n+                diag.set_arg(\"format\", format);\n+                diag\n+            }\n+            thorin::Error::OffsetAtIndex(_, index) => {\n+                diag = handler.struct_err(fluent::codegen_ssa::thorin_offset_at_index);\n+                diag.set_arg(\"index\", index);\n+                diag\n+            }\n+            thorin::Error::StrAtOffset(_, offset) => {\n+                diag = handler.struct_err(fluent::codegen_ssa::thorin_str_at_offset);\n+                diag.set_arg(\"offset\", format!(\"0x{:08x}\", offset));\n+                diag\n+            }\n+            thorin::Error::ParseIndex(_, section) => {\n+                diag = handler.struct_err(fluent::codegen_ssa::thorin_parse_index);\n+                diag.set_arg(\"section\", section);\n+                diag\n+            }\n+            thorin::Error::UnitNotInIndex(unit) => {\n+                diag = handler.struct_err(fluent::codegen_ssa::thorin_unit_not_in_index);\n+                diag.set_arg(\"unit\", format!(\"0x{:08x}\", unit));\n+                diag\n+            }\n+            thorin::Error::RowNotInIndex(_, row) => {\n+                diag = handler.struct_err(fluent::codegen_ssa::thorin_row_not_in_index);\n+                diag.set_arg(\"row\", row);\n+                diag\n+            }\n+            thorin::Error::SectionNotInRow => {\n+                diag = handler.struct_err(fluent::codegen_ssa::thorin_section_not_in_row);\n+                diag\n+            }\n+            thorin::Error::EmptyUnit(unit) => {\n+                diag = handler.struct_err(fluent::codegen_ssa::thorin_empty_unit);\n+                diag.set_arg(\"unit\", format!(\"0x{:08x}\", unit));\n+                diag\n+            }\n+            thorin::Error::MultipleDebugInfoSection => {\n+                diag = handler.struct_err(fluent::codegen_ssa::thorin_multiple_debug_info_section);\n+                diag\n+            }\n+            thorin::Error::MultipleDebugTypesSection => {\n+                diag = handler.struct_err(fluent::codegen_ssa::thorin_multiple_debug_types_section);\n+                diag\n+            }\n+            thorin::Error::NotSplitUnit => {\n+                diag = handler.struct_err(fluent::codegen_ssa::thorin_not_split_unit);\n+                diag\n+            }\n+            thorin::Error::DuplicateUnit(unit) => {\n+                diag = handler.struct_err(fluent::codegen_ssa::thorin_duplicate_unit);\n+                diag.set_arg(\"unit\", format!(\"0x{:08x}\", unit));\n+                diag\n+            }\n+            thorin::Error::MissingReferencedUnit(unit) => {\n+                diag = handler.struct_err(fluent::codegen_ssa::thorin_missing_referenced_unit);\n+                diag.set_arg(\"unit\", format!(\"0x{:08x}\", unit));\n+                diag\n+            }\n+            thorin::Error::NoOutputObjectCreated => {\n+                diag = handler.struct_err(fluent::codegen_ssa::thorin_not_output_object_created);\n+                diag\n+            }\n+            thorin::Error::MixedInputEncodings => {\n+                diag = handler.struct_err(fluent::codegen_ssa::thorin_mixed_input_encodings);\n+                diag\n+            }\n+            thorin::Error::Io(e) => {\n+                diag = handler.struct_err(fluent::codegen_ssa::thorin_io);\n+                diag.set_arg(\"error\", format!(\"{e}\"));\n+                diag\n+            }\n+            thorin::Error::ObjectRead(e) => {\n+                diag = handler.struct_err(fluent::codegen_ssa::thorin_object_read);\n+                diag.set_arg(\"error\", format!(\"{e}\"));\n+                diag\n+            }\n+            thorin::Error::ObjectWrite(e) => {\n+                diag = handler.struct_err(fluent::codegen_ssa::thorin_object_write);\n+                diag.set_arg(\"error\", format!(\"{e}\"));\n+                diag\n+            }\n+            thorin::Error::GimliRead(e) => {\n+                diag = handler.struct_err(fluent::codegen_ssa::thorin_gimli_read);\n+                diag.set_arg(\"error\", format!(\"{e}\"));\n+                diag\n+            }\n+            thorin::Error::GimliWrite(e) => {\n+                diag = handler.struct_err(fluent::codegen_ssa::thorin_gimli_write);\n+                diag.set_arg(\"error\", format!(\"{e}\"));\n+                diag\n+            }\n+            _ => unimplemented!(\"Untranslated thorin error\"),\n+        }\n+    }\n+}\n+\n+pub struct LinkingFailed<'a> {\n+    pub linker_path: &'a PathBuf,\n+    pub exit_status: ExitStatus,\n+    pub command: &'a Command,\n+    pub escaped_output: &'a str,\n+}\n+\n+impl IntoDiagnostic<'_> for LinkingFailed<'_> {\n+    fn into_diagnostic(self, handler: &Handler) -> DiagnosticBuilder<'_, ErrorGuaranteed> {\n+        let mut diag = handler.struct_err(fluent::codegen_ssa::linking_failed);\n+        diag.set_arg(\"linker_path\", format!(\"{}\", self.linker_path.display()));\n+        diag.set_arg(\"exit_status\", format!(\"{}\", self.exit_status));\n+\n+        diag.note(format!(\"{:?}\", self.command)).note(self.escaped_output);\n+\n+        // Trying to match an error from OS linkers\n+        // which by now we have no way to translate.\n+        if self.escaped_output.contains(\"undefined reference to\") {\n+            diag.note(fluent::codegen_ssa::extern_funcs_not_found)\n+                .note(fluent::codegen_ssa::specify_libraries_to_link)\n+                .note(fluent::codegen_ssa::use_cargo_directive);\n+        }\n+        diag\n+    }\n+}"}, {"sha": "ceebe4d417f7d68b0014f8b75d80d6f150e97b36", "filename": "compiler/rustc_codegen_ssa/src/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_codegen_ssa%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_codegen_ssa%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Flib.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "patch": "@@ -1,12 +1,12 @@\n #![doc(html_root_url = \"https://doc.rust-lang.org/nightly/nightly-rustc/\")]\n #![feature(box_patterns)]\n #![feature(try_blocks)]\n-#![cfg_attr(bootstrap, feature(let_else))]\n #![feature(once_cell)]\n #![feature(associated_type_bounds)]\n #![feature(strict_provenance)]\n #![feature(int_roundings)]\n #![feature(if_let_guard)]\n+#![feature(never_type)]\n #![recursion_limit = \"256\"]\n #![allow(rustc::potential_query_instability)]\n \n@@ -44,6 +44,7 @@ pub mod base;\n pub mod common;\n pub mod coverageinfo;\n pub mod debuginfo;\n+pub mod errors;\n pub mod glue;\n pub mod meth;\n pub mod mir;"}, {"sha": "bd4f0cac7eb46dc9dc6d11e17fae9d0e748ca1e0", "filename": "compiler/rustc_codegen_ssa/src/mir/block.rs", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "patch": "@@ -162,9 +162,15 @@ impl<'a, 'tcx> TerminatorCodegenHelper<'tcx> {\n             } else {\n                 fx.unreachable_block()\n             };\n-            let invokeret =\n-                bx.invoke(fn_ty, fn_ptr, &llargs, ret_llbb, unwind_block, self.funclet(fx));\n-            bx.apply_attrs_callsite(&fn_abi, invokeret);\n+            let invokeret = bx.invoke(\n+                fn_ty,\n+                Some(&fn_abi),\n+                fn_ptr,\n+                &llargs,\n+                ret_llbb,\n+                unwind_block,\n+                self.funclet(fx),\n+            );\n             if fx.mir[self.bb].is_cleanup {\n                 bx.do_not_inline(invokeret);\n             }\n@@ -178,8 +184,7 @@ impl<'a, 'tcx> TerminatorCodegenHelper<'tcx> {\n                 fx.store_return(bx, ret_dest, &fn_abi.ret, invokeret);\n             }\n         } else {\n-            let llret = bx.call(fn_ty, fn_ptr, &llargs, self.funclet(fx));\n-            bx.apply_attrs_callsite(&fn_abi, llret);\n+            let llret = bx.call(fn_ty, Some(&fn_abi), fn_ptr, &llargs, self.funclet(fx));\n             if fx.mir[self.bb].is_cleanup {\n                 // Cleanup is always the cold path. Don't inline\n                 // drop glue. Also, when there is a deeply-nested\n@@ -1533,8 +1538,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             let (fn_abi, fn_ptr) = common::build_langcall(&bx, None, LangItem::PanicNoUnwind);\n             let fn_ty = bx.fn_decl_backend_type(&fn_abi);\n \n-            let llret = bx.call(fn_ty, fn_ptr, &[], None);\n-            bx.apply_attrs_callsite(&fn_abi, llret);\n+            let llret = bx.call(fn_ty, Some(&fn_abi), fn_ptr, &[], None);\n             bx.do_not_inline(llret);\n \n             bx.unreachable();"}, {"sha": "e6ba642a7ed0e969a1eb3d3e7bdc0ad6fc13d361", "filename": "compiler/rustc_codegen_ssa/src/mir/operand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Foperand.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "patch": "@@ -352,7 +352,7 @@ impl<'a, 'tcx, V: CodegenObject> OperandValue<V> {\n \n         // Allocate an appropriate region on the stack, and copy the value into it\n         let (llsize, _) = glue::size_and_align_of_dst(bx, unsized_ty, Some(llextra));\n-        let lldst = bx.array_alloca(bx.cx().type_i8(), llsize, max_align);\n+        let lldst = bx.byte_array_alloca(llsize, max_align);\n         bx.memcpy(lldst, max_align, llptr, min_align, llsize, flags);\n \n         // Store the allocated region and the extra to the indirect place."}, {"sha": "4aab31fbfe7da71ba31369cb0658b2aaf93cc323", "filename": "compiler/rustc_codegen_ssa/src/mir/rvalue.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Frvalue.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "patch": "@@ -4,7 +4,6 @@ use super::{FunctionCx, LocalRef};\n \n use crate::base;\n use crate::common::{self, IntPredicate};\n-use crate::meth::get_vtable;\n use crate::traits::*;\n use crate::MemFlags;\n \n@@ -250,7 +249,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                         OperandValue::Pair(lldata, llextra)\n                     }\n                     mir::CastKind::Pointer(PointerCast::MutToConstPointer)\n-                    | mir::CastKind::Misc\n+                    | mir::CastKind::PtrToPtr\n                         if bx.cx().is_backend_scalar_pair(operand.layout) =>\n                     {\n                         if let OperandValue::Pair(data_ptr, meta) = operand.val {\n@@ -273,24 +272,25 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                         }\n                     }\n                     mir::CastKind::DynStar => {\n-                        let data = match operand.val {\n+                        let (lldata, llextra) = match operand.val {\n                             OperandValue::Ref(_, _, _) => todo!(),\n-                            OperandValue::Immediate(v) => v,\n-                            OperandValue::Pair(_, _) => todo!(),\n+                            OperandValue::Immediate(v) => (v, None),\n+                            OperandValue::Pair(v, l) => (v, Some(l)),\n                         };\n-                        let trait_ref =\n-                            if let ty::Dynamic(data, _, ty::DynStar) = cast.ty.kind() {\n-                                data.principal()\n-                            } else {\n-                                bug!(\"Only valid to do a DynStar cast into a DynStar type\")\n-                            };\n-                        let vtable = get_vtable(bx.cx(), source.ty(self.mir, bx.tcx()), trait_ref);\n-                        OperandValue::Pair(data, vtable)\n+                        let (lldata, llextra) =\n+                            base::cast_to_dyn_star(&mut bx, lldata, operand.layout, cast.ty, llextra);\n+                        OperandValue::Pair(lldata, llextra)\n                     }\n                     mir::CastKind::Pointer(\n                         PointerCast::MutToConstPointer | PointerCast::ArrayToPointer,\n                     )\n-                    | mir::CastKind::Misc\n+                    | mir::CastKind::IntToInt\n+                    | mir::CastKind::FloatToInt\n+                    | mir::CastKind::FloatToFloat\n+                    | mir::CastKind::IntToFloat\n+                    | mir::CastKind::PtrToPtr\n+                    | mir::CastKind::FnPtrToPtr\n+\n                     // Since int2ptr can have arbitrary integer types as input (so we have to do\n                     // sign extension and all that), it is currently best handled in the same code\n                     // path as the other integer-to-X casts."}, {"sha": "83407ee8f9d32e891d6584d23512115004c8f75a", "filename": "compiler/rustc_codegen_ssa/src/target_features.rs", "status": "modified", "additions": 112, "deletions": 96, "changes": 208, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftarget_features.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftarget_features.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftarget_features.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "patch": "@@ -13,17 +13,25 @@ pub const RUSTC_SPECIFIC_FEATURES: &[&str] = &[\"crt-static\"];\n // if it doesn't, to_llvm_feature in llvm_util in rustc_codegen_llvm needs to be adapted\n \n const ARM_ALLOWED_FEATURES: &[(&str, Option<Symbol>)] = &[\n+    // tidy-alphabetical-start\n     (\"aclass\", Some(sym::arm_target_feature)),\n-    (\"mclass\", Some(sym::arm_target_feature)),\n-    (\"rclass\", Some(sym::arm_target_feature)),\n-    (\"dsp\", Some(sym::arm_target_feature)),\n-    (\"neon\", Some(sym::arm_target_feature)),\n+    (\"aes\", Some(sym::arm_target_feature)),\n     (\"crc\", Some(sym::arm_target_feature)),\n     (\"crypto\", Some(sym::arm_target_feature)),\n-    (\"aes\", Some(sym::arm_target_feature)),\n-    (\"sha2\", Some(sym::arm_target_feature)),\n-    (\"i8mm\", Some(sym::arm_target_feature)),\n+    (\"d32\", Some(sym::arm_target_feature)),\n     (\"dotprod\", Some(sym::arm_target_feature)),\n+    (\"dsp\", Some(sym::arm_target_feature)),\n+    (\"fp-armv8\", Some(sym::arm_target_feature)),\n+    (\"i8mm\", Some(sym::arm_target_feature)),\n+    (\"mclass\", Some(sym::arm_target_feature)),\n+    (\"neon\", Some(sym::arm_target_feature)),\n+    (\"rclass\", Some(sym::arm_target_feature)),\n+    (\"sha2\", Some(sym::arm_target_feature)),\n+    // This is needed for inline assembly, but shouldn't be stabilized as-is\n+    // since it should be enabled per-function using #[instruction_set], not\n+    // #[target_feature].\n+    (\"thumb-mode\", Some(sym::arm_target_feature)),\n+    (\"thumb2\", Some(sym::arm_target_feature)),\n     (\"v5te\", Some(sym::arm_target_feature)),\n     (\"v6\", Some(sym::arm_target_feature)),\n     (\"v6k\", Some(sym::arm_target_feature)),\n@@ -33,118 +41,115 @@ const ARM_ALLOWED_FEATURES: &[(&str, Option<Symbol>)] = &[\n     (\"vfp2\", Some(sym::arm_target_feature)),\n     (\"vfp3\", Some(sym::arm_target_feature)),\n     (\"vfp4\", Some(sym::arm_target_feature)),\n-    (\"fp-armv8\", Some(sym::arm_target_feature)),\n-    // This is needed for inline assembly, but shouldn't be stabilized as-is\n-    // since it should be enabled per-function using #[instruction_set], not\n-    // #[target_feature].\n-    (\"thumb-mode\", Some(sym::arm_target_feature)),\n-    (\"thumb2\", Some(sym::arm_target_feature)),\n-    (\"d32\", Some(sym::arm_target_feature)),\n+    // tidy-alphabetical-end\n ];\n \n const AARCH64_ALLOWED_FEATURES: &[(&str, Option<Symbol>)] = &[\n-    // FEAT_AdvSimd & FEAT_FP\n-    (\"neon\", None),\n-    // FEAT_FP16\n-    (\"fp16\", None),\n-    // FEAT_SVE\n-    (\"sve\", None),\n+    // tidy-alphabetical-start\n+    // FEAT_AES\n+    (\"aes\", None),\n+    // FEAT_BF16\n+    (\"bf16\", None),\n+    // FEAT_BTI\n+    (\"bti\", None),\n     // FEAT_CRC\n     (\"crc\", None),\n-    // FEAT_RAS\n-    (\"ras\", None),\n-    // FEAT_LSE\n-    (\"lse\", None),\n-    // FEAT_RDM\n-    (\"rdm\", None),\n-    // FEAT_RCPC\n-    (\"rcpc\", None),\n-    // FEAT_RCPC2\n-    (\"rcpc2\", None),\n-    // FEAT_DotProd\n-    (\"dotprod\", None),\n-    // FEAT_TME\n-    (\"tme\", None),\n-    // FEAT_FHM\n-    (\"fhm\", None),\n     // FEAT_DIT\n     (\"dit\", None),\n-    // FEAT_FLAGM\n-    (\"flagm\", None),\n-    // FEAT_SSBS\n-    (\"ssbs\", None),\n-    // FEAT_SB\n-    (\"sb\", None),\n-    // FEAT_PAUTH (address authentication)\n-    (\"paca\", None),\n-    // FEAT_PAUTH (generic authentication)\n-    (\"pacg\", None),\n+    // FEAT_DotProd\n+    (\"dotprod\", None),\n     // FEAT_DPB\n     (\"dpb\", None),\n     // FEAT_DPB2\n     (\"dpb2\", None),\n-    // FEAT_SVE2\n-    (\"sve2\", None),\n-    // FEAT_SVE2_AES\n-    (\"sve2-aes\", None),\n-    // FEAT_SVE2_SM4\n-    (\"sve2-sm4\", None),\n-    // FEAT_SVE2_SHA3\n-    (\"sve2-sha3\", None),\n-    // FEAT_SVE2_BitPerm\n-    (\"sve2-bitperm\", None),\n-    // FEAT_FRINTTS\n-    (\"frintts\", None),\n-    // FEAT_I8MM\n-    (\"i8mm\", None),\n     // FEAT_F32MM\n     (\"f32mm\", None),\n     // FEAT_F64MM\n     (\"f64mm\", None),\n-    // FEAT_BF16\n-    (\"bf16\", None),\n-    // FEAT_RAND\n-    (\"rand\", None),\n-    // FEAT_BTI\n-    (\"bti\", None),\n-    // FEAT_MTE\n-    (\"mte\", None),\n-    // FEAT_JSCVT\n-    (\"jsconv\", None),\n     // FEAT_FCMA\n     (\"fcma\", None),\n-    // FEAT_AES\n-    (\"aes\", None),\n+    // FEAT_FHM\n+    (\"fhm\", None),\n+    // FEAT_FLAGM\n+    (\"flagm\", None),\n+    // FEAT_FP16\n+    (\"fp16\", None),\n+    // FEAT_FRINTTS\n+    (\"frintts\", None),\n+    // FEAT_I8MM\n+    (\"i8mm\", None),\n+    // FEAT_JSCVT\n+    (\"jsconv\", None),\n+    // FEAT_LOR\n+    (\"lor\", None),\n+    // FEAT_LSE\n+    (\"lse\", None),\n+    // FEAT_MTE\n+    (\"mte\", None),\n+    // FEAT_AdvSimd & FEAT_FP\n+    (\"neon\", None),\n+    // FEAT_PAUTH (address authentication)\n+    (\"paca\", None),\n+    // FEAT_PAUTH (generic authentication)\n+    (\"pacg\", None),\n+    // FEAT_PAN\n+    (\"pan\", None),\n+    // FEAT_PMUv3\n+    (\"pmuv3\", None),\n+    // FEAT_RAND\n+    (\"rand\", None),\n+    // FEAT_RAS\n+    (\"ras\", None),\n+    // FEAT_RCPC\n+    (\"rcpc\", None),\n+    // FEAT_RCPC2\n+    (\"rcpc2\", None),\n+    // FEAT_RDM\n+    (\"rdm\", None),\n+    // FEAT_SB\n+    (\"sb\", None),\n     // FEAT_SHA1 & FEAT_SHA256\n     (\"sha2\", None),\n     // FEAT_SHA512 & FEAT_SHA3\n     (\"sha3\", None),\n     // FEAT_SM3 & FEAT_SM4\n     (\"sm4\", None),\n-    // FEAT_PAN\n-    (\"pan\", None),\n-    // FEAT_LOR\n-    (\"lor\", None),\n-    // FEAT_VHE\n-    (\"vh\", None),\n-    // FEAT_PMUv3\n-    (\"pmuv3\", None),\n     // FEAT_SPE\n     (\"spe\", None),\n+    // FEAT_SSBS\n+    (\"ssbs\", None),\n+    // FEAT_SVE\n+    (\"sve\", None),\n+    // FEAT_SVE2\n+    (\"sve2\", None),\n+    // FEAT_SVE2_AES\n+    (\"sve2-aes\", None),\n+    // FEAT_SVE2_BitPerm\n+    (\"sve2-bitperm\", None),\n+    // FEAT_SVE2_SHA3\n+    (\"sve2-sha3\", None),\n+    // FEAT_SVE2_SM4\n+    (\"sve2-sm4\", None),\n+    // FEAT_TME\n+    (\"tme\", None),\n     (\"v8.1a\", Some(sym::aarch64_ver_target_feature)),\n     (\"v8.2a\", Some(sym::aarch64_ver_target_feature)),\n     (\"v8.3a\", Some(sym::aarch64_ver_target_feature)),\n     (\"v8.4a\", Some(sym::aarch64_ver_target_feature)),\n     (\"v8.5a\", Some(sym::aarch64_ver_target_feature)),\n     (\"v8.6a\", Some(sym::aarch64_ver_target_feature)),\n     (\"v8.7a\", Some(sym::aarch64_ver_target_feature)),\n+    // FEAT_VHE\n+    (\"vh\", None),\n+    // tidy-alphabetical-end\n ];\n \n const AARCH64_TIED_FEATURES: &[&[&str]] = &[\n     &[\"paca\", \"pacg\"], // Together these represent `pauth` in LLVM\n ];\n \n const X86_ALLOWED_FEATURES: &[(&str, Option<Symbol>)] = &[\n+    // tidy-alphabetical-start\n     (\"adx\", None),\n     (\"aes\", None),\n     (\"avx\", None),\n@@ -194,69 +199,80 @@ const X86_ALLOWED_FEATURES: &[(&str, Option<Symbol>)] = &[\n     (\"xsavec\", None),\n     (\"xsaveopt\", None),\n     (\"xsaves\", None),\n+    // tidy-alphabetical-end\n ];\n \n const HEXAGON_ALLOWED_FEATURES: &[(&str, Option<Symbol>)] = &[\n+    // tidy-alphabetical-start\n     (\"hvx\", Some(sym::hexagon_target_feature)),\n     (\"hvx-length128b\", Some(sym::hexagon_target_feature)),\n+    // tidy-alphabetical-end\n ];\n \n const POWERPC_ALLOWED_FEATURES: &[(&str, Option<Symbol>)] = &[\n+    // tidy-alphabetical-start\n     (\"altivec\", Some(sym::powerpc_target_feature)),\n     (\"power8-altivec\", Some(sym::powerpc_target_feature)),\n-    (\"power9-altivec\", Some(sym::powerpc_target_feature)),\n     (\"power8-vector\", Some(sym::powerpc_target_feature)),\n+    (\"power9-altivec\", Some(sym::powerpc_target_feature)),\n     (\"power9-vector\", Some(sym::powerpc_target_feature)),\n     (\"vsx\", Some(sym::powerpc_target_feature)),\n+    // tidy-alphabetical-end\n ];\n \n const MIPS_ALLOWED_FEATURES: &[(&str, Option<Symbol>)] = &[\n+    // tidy-alphabetical-start\n     (\"fp64\", Some(sym::mips_target_feature)),\n     (\"msa\", Some(sym::mips_target_feature)),\n     (\"virt\", Some(sym::mips_target_feature)),\n+    // tidy-alphabetical-end\n ];\n \n const RISCV_ALLOWED_FEATURES: &[(&str, Option<Symbol>)] = &[\n-    (\"m\", Some(sym::riscv_target_feature)),\n+    // tidy-alphabetical-start\n     (\"a\", Some(sym::riscv_target_feature)),\n     (\"c\", Some(sym::riscv_target_feature)),\n-    (\"f\", Some(sym::riscv_target_feature)),\n     (\"d\", Some(sym::riscv_target_feature)),\n     (\"e\", Some(sym::riscv_target_feature)),\n+    (\"f\", Some(sym::riscv_target_feature)),\n+    (\"m\", Some(sym::riscv_target_feature)),\n     (\"v\", Some(sym::riscv_target_feature)),\n-    (\"zfinx\", Some(sym::riscv_target_feature)),\n-    (\"zdinx\", Some(sym::riscv_target_feature)),\n-    (\"zhinx\", Some(sym::riscv_target_feature)),\n-    (\"zhinxmin\", Some(sym::riscv_target_feature)),\n-    (\"zfh\", Some(sym::riscv_target_feature)),\n-    (\"zfhmin\", Some(sym::riscv_target_feature)),\n     (\"zba\", Some(sym::riscv_target_feature)),\n     (\"zbb\", Some(sym::riscv_target_feature)),\n     (\"zbc\", Some(sym::riscv_target_feature)),\n-    (\"zbs\", Some(sym::riscv_target_feature)),\n     (\"zbkb\", Some(sym::riscv_target_feature)),\n     (\"zbkc\", Some(sym::riscv_target_feature)),\n     (\"zbkx\", Some(sym::riscv_target_feature)),\n+    (\"zbs\", Some(sym::riscv_target_feature)),\n+    (\"zdinx\", Some(sym::riscv_target_feature)),\n+    (\"zfh\", Some(sym::riscv_target_feature)),\n+    (\"zfhmin\", Some(sym::riscv_target_feature)),\n+    (\"zfinx\", Some(sym::riscv_target_feature)),\n+    (\"zhinx\", Some(sym::riscv_target_feature)),\n+    (\"zhinxmin\", Some(sym::riscv_target_feature)),\n+    (\"zk\", Some(sym::riscv_target_feature)),\n+    (\"zkn\", Some(sym::riscv_target_feature)),\n     (\"zknd\", Some(sym::riscv_target_feature)),\n     (\"zkne\", Some(sym::riscv_target_feature)),\n     (\"zknh\", Some(sym::riscv_target_feature)),\n-    (\"zksed\", Some(sym::riscv_target_feature)),\n-    (\"zksh\", Some(sym::riscv_target_feature)),\n     (\"zkr\", Some(sym::riscv_target_feature)),\n-    (\"zkn\", Some(sym::riscv_target_feature)),\n     (\"zks\", Some(sym::riscv_target_feature)),\n-    (\"zk\", Some(sym::riscv_target_feature)),\n+    (\"zksed\", Some(sym::riscv_target_feature)),\n+    (\"zksh\", Some(sym::riscv_target_feature)),\n     (\"zkt\", Some(sym::riscv_target_feature)),\n+    // tidy-alphabetical-end\n ];\n \n const WASM_ALLOWED_FEATURES: &[(&str, Option<Symbol>)] = &[\n-    (\"simd128\", None),\n+    // tidy-alphabetical-start\n     (\"atomics\", Some(sym::wasm_target_feature)),\n-    (\"nontrapping-fptoint\", Some(sym::wasm_target_feature)),\n     (\"bulk-memory\", Some(sym::wasm_target_feature)),\n     (\"mutable-globals\", Some(sym::wasm_target_feature)),\n+    (\"nontrapping-fptoint\", Some(sym::wasm_target_feature)),\n     (\"reference-types\", Some(sym::wasm_target_feature)),\n     (\"sign-ext\", Some(sym::wasm_target_feature)),\n+    (\"simd128\", None),\n+    // tidy-alphabetical-end\n ];\n \n const BPF_ALLOWED_FEATURES: &[(&str, Option<Symbol>)] = &[(\"alu32\", Some(sym::bpf_target_feature))];"}, {"sha": "60d8f2a9ece4867900c4301ff5f895f8b7ad0c2a", "filename": "compiler/rustc_codegen_ssa/src/traits/abi.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fabi.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "patch": "@@ -1,8 +1,5 @@\n use super::BackendTypes;\n-use rustc_middle::ty::Ty;\n-use rustc_target::abi::call::FnAbi;\n \n pub trait AbiBuilderMethods<'tcx>: BackendTypes {\n-    fn apply_attrs_callsite(&mut self, fn_abi: &FnAbi<'tcx, Ty<'tcx>>, callsite: Self::Value);\n     fn get_param(&mut self, index: usize) -> Self::Value;\n }"}, {"sha": "87e347c61e2b8b94f423472a0282dcacc779de3c", "filename": "compiler/rustc_codegen_ssa/src/traits/backend.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fbackend.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fbackend.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fbackend.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "patch": "@@ -134,8 +134,6 @@ pub trait ExtraBackendMethods: CodegenBackend + WriteBackendMethods + Sized + Se\n         opt_level: config::OptLevel,\n         target_features: &[String],\n     ) -> TargetMachineFactoryFn<Self>;\n-    fn target_cpu<'b>(&self, sess: &'b Session) -> &'b str;\n-    fn tune_cpu<'b>(&self, sess: &'b Session) -> Option<&'b str>;\n \n     fn spawn_thread<F, T>(_time_trace: bool, f: F) -> std::thread::JoinHandle<T>\n     where"}, {"sha": "01408f39fb30606a63b5a8b4a81be9a8d15ca610", "filename": "compiler/rustc_codegen_ssa/src/traits/builder.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fbuilder.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "patch": "@@ -17,6 +17,7 @@ use crate::MemFlags;\n use rustc_middle::ty::layout::{HasParamEnv, TyAndLayout};\n use rustc_middle::ty::Ty;\n use rustc_span::Span;\n+use rustc_target::abi::call::FnAbi;\n use rustc_target::abi::{Abi, Align, Scalar, Size, WrappingRange};\n use rustc_target::spec::HasTargetSpec;\n \n@@ -71,6 +72,7 @@ pub trait BuilderMethods<'a, 'tcx>:\n     fn invoke(\n         &mut self,\n         llty: Self::Type,\n+        fn_abi: Option<&FnAbi<'tcx, Ty<'tcx>>>,\n         llfn: Self::Value,\n         args: &[Self::Value],\n         then: Self::BasicBlock,\n@@ -133,8 +135,7 @@ pub trait BuilderMethods<'a, 'tcx>:\n     fn to_immediate_scalar(&mut self, val: Self::Value, scalar: Scalar) -> Self::Value;\n \n     fn alloca(&mut self, ty: Self::Type, align: Align) -> Self::Value;\n-    fn dynamic_alloca(&mut self, ty: Self::Type, align: Align) -> Self::Value;\n-    fn array_alloca(&mut self, ty: Self::Type, len: Self::Value, align: Align) -> Self::Value;\n+    fn byte_array_alloca(&mut self, len: Self::Value, align: Align) -> Self::Value;\n \n     fn load(&mut self, ty: Self::Type, ptr: Self::Value, align: Align) -> Self::Value;\n     fn volatile_load(&mut self, ty: Self::Type, ptr: Self::Value) -> Self::Value;\n@@ -320,6 +321,7 @@ pub trait BuilderMethods<'a, 'tcx>:\n     fn call(\n         &mut self,\n         llty: Self::Type,\n+        fn_abi: Option<&FnAbi<'tcx, Ty<'tcx>>>,\n         llfn: Self::Value,\n         args: &[Self::Value],\n         funclet: Option<&Self::Funclet>,"}, {"sha": "450672fb94122c5695587f3c9513f1a4c8ec130b", "filename": "compiler/rustc_codegen_ssa/src/traits/intrinsic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fintrinsic.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "patch": "@@ -5,7 +5,7 @@ use rustc_span::Span;\n use rustc_target::abi::call::FnAbi;\n \n pub trait IntrinsicCallMethods<'tcx>: BackendTypes {\n-    /// Remember to add all intrinsics here, in `compiler/rustc_typeck/src/check/mod.rs`,\n+    /// Remember to add all intrinsics here, in `compiler/rustc_hir_analysis/src/check/mod.rs`,\n     /// and in `library/core/src/intrinsics.rs`; if you need access to any LLVM intrinsics,\n     /// add them to `compiler/rustc_codegen_llvm/src/context.rs`.\n     fn codegen_intrinsic_call("}, {"sha": "04e2b8796c46a21d7b12a798919c27179cbeeecb", "filename": "compiler/rustc_codegen_ssa/src/traits/misc.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fmisc.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "patch": "@@ -15,12 +15,8 @@ pub trait MiscMethods<'tcx>: BackendTypes {\n     fn eh_personality(&self) -> Self::Value;\n     fn sess(&self) -> &Session;\n     fn codegen_unit(&self) -> &'tcx CodegenUnit<'tcx>;\n-    fn used_statics(&self) -> &RefCell<Vec<Self::Value>>;\n-    fn compiler_used_statics(&self) -> &RefCell<Vec<Self::Value>>;\n     fn set_frame_pointer_type(&self, llfn: Self::Function);\n     fn apply_target_cpu_attr(&self, llfn: Self::Function);\n-    fn create_used_variable(&self);\n-    fn create_compiler_used_variable(&self);\n     /// Declares the extern \"C\" main function for the entry point. Returns None if the symbol already exists.\n     fn declare_c_main(&self, fn_type: Self::Type) -> Option<Self::Function>;\n }"}, {"sha": "e0e8ffa89ed155d64a23e981f243900ba3e5516b", "filename": "compiler/rustc_codegen_ssa/src/traits/write.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fwrite.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "patch": "@@ -9,7 +9,6 @@ pub trait WriteBackendMethods: 'static + Sized + Clone {\n     type Module: Send + Sync;\n     type TargetMachine;\n     type ModuleBuffer: ModuleBufferMethods;\n-    type Context: ?Sized;\n     type ThinData: Send + Sync;\n     type ThinBuffer: ThinBufferMethods;\n "}, {"sha": "e09a6d1d6f5aa890d0606ad6c0457391cd07eca3", "filename": "compiler/rustc_const_eval/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_const_eval%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_const_eval%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2FCargo.toml?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "patch": "@@ -4,7 +4,6 @@ version = \"0.0.0\"\n edition = \"2021\"\n \n [lib]\n-doctest = false\n \n [dependencies]\n tracing = \"0.1\""}, {"sha": "4977a5d6bbf0593f2edeeb33645d9e7b7d68a477", "filename": "compiler/rustc_const_eval/src/const_eval/error.rs", "status": "modified", "additions": 8, "deletions": 70, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Ferror.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "patch": "@@ -2,7 +2,6 @@ use std::error::Error;\n use std::fmt;\n \n use rustc_errors::Diagnostic;\n-use rustc_hir as hir;\n use rustc_middle::mir::AssertKind;\n use rustc_middle::ty::{layout::LayoutError, query::TyCtxtAt, ConstInt};\n use rustc_span::{Span, Symbol};\n@@ -23,11 +22,7 @@ pub enum ConstEvalErrKind {\n     Abort(String),\n }\n \n-impl MachineStopType for ConstEvalErrKind {\n-    fn is_hard_err(&self) -> bool {\n-        matches!(self, Self::Panic { .. })\n-    }\n-}\n+impl MachineStopType for ConstEvalErrKind {}\n \n // The errors become `MachineStop` with plain strings when being raised.\n // `ConstEvalErr` (in `librustc_middle/mir/interpret/error.rs`) knows to\n@@ -69,7 +64,7 @@ pub struct ConstEvalErr<'tcx> {\n impl<'tcx> ConstEvalErr<'tcx> {\n     /// Turn an interpreter error into something to report to the user.\n     /// As a side-effect, if RUSTC_CTFE_BACKTRACE is set, this prints the backtrace.\n-    /// Should be called only if the error is actually going to to be reported!\n+    /// Should be called only if the error is actually going to be reported!\n     pub fn new<'mir, M: Machine<'mir, 'tcx>>(\n         ecx: &InterpCx<'mir, 'tcx, M>,\n         error: InterpErrorInfo<'tcx>,\n@@ -87,48 +82,10 @@ impl<'tcx> ConstEvalErr<'tcx> {\n         ConstEvalErr { error: error.into_kind(), stacktrace, span }\n     }\n \n-    pub fn struct_error(\n-        &self,\n-        tcx: TyCtxtAt<'tcx>,\n-        message: &str,\n-        decorate: impl FnOnce(&mut Diagnostic),\n-    ) -> ErrorHandled {\n-        self.struct_generic(tcx, message, decorate, None)\n-    }\n-\n     pub fn report_as_error(&self, tcx: TyCtxtAt<'tcx>, message: &str) -> ErrorHandled {\n         self.struct_error(tcx, message, |_| {})\n     }\n \n-    pub fn report_as_lint(\n-        &self,\n-        tcx: TyCtxtAt<'tcx>,\n-        message: &str,\n-        lint_root: hir::HirId,\n-        span: Option<Span>,\n-    ) -> ErrorHandled {\n-        self.struct_generic(\n-            tcx,\n-            message,\n-            |lint: &mut Diagnostic| {\n-                // Apply the span.\n-                if let Some(span) = span {\n-                    let primary_spans = lint.span.primary_spans().to_vec();\n-                    // point at the actual error as the primary span\n-                    lint.replace_span_with(span);\n-                    // point to the `const` statement as a secondary span\n-                    // they don't have any label\n-                    for sp in primary_spans {\n-                        if sp != span {\n-                            lint.span_label(sp, \"\");\n-                        }\n-                    }\n-                }\n-            },\n-            Some(lint_root),\n-        )\n-    }\n-\n     /// Create a diagnostic for this const eval error.\n     ///\n     /// Sets the message passed in via `message` and adds span labels with detailed error\n@@ -137,13 +94,12 @@ impl<'tcx> ConstEvalErr<'tcx> {\n     ///\n     /// If `lint_root.is_some()` report it as a lint, else report it as a hard error.\n     /// (Except that for some errors, we ignore all that -- see `must_error` below.)\n-    #[instrument(skip(self, tcx, decorate, lint_root), level = \"debug\")]\n-    fn struct_generic(\n+    #[instrument(skip(self, tcx, decorate), level = \"debug\")]\n+    pub fn struct_error(\n         &self,\n         tcx: TyCtxtAt<'tcx>,\n         message: &str,\n         decorate: impl FnOnce(&mut Diagnostic),\n-        lint_root: Option<hir::HirId>,\n     ) -> ErrorHandled {\n         let finish = |err: &mut Diagnostic, span_msg: Option<String>| {\n             trace!(\"reporting const eval failure at {:?}\", self.span);\n@@ -224,27 +180,9 @@ impl<'tcx> ConstEvalErr<'tcx> {\n \n         let err_msg = self.error.to_string();\n \n-        // Regular case - emit a lint.\n-        if let Some(lint_root) = lint_root {\n-            // Report as lint.\n-            let hir_id =\n-                self.stacktrace.iter().rev().find_map(|frame| frame.lint_root).unwrap_or(lint_root);\n-            tcx.struct_span_lint_hir(\n-                rustc_session::lint::builtin::CONST_ERR,\n-                hir_id,\n-                tcx.span,\n-                |lint| {\n-                    let mut lint = lint.build(message);\n-                    finish(&mut lint, Some(err_msg));\n-                    lint.emit();\n-                },\n-            );\n-            ErrorHandled::Linted\n-        } else {\n-            // Report as hard error.\n-            let mut err = struct_error(tcx, message);\n-            finish(&mut err, Some(err_msg));\n-            ErrorHandled::Reported(err.emit())\n-        }\n+        // Report as hard error.\n+        let mut err = struct_error(tcx, message);\n+        finish(&mut err, Some(err_msg));\n+        ErrorHandled::Reported(err.emit())\n     }\n }"}, {"sha": "1b1052fdf47a751692f1001624d191dc30c815d0", "filename": "compiler/rustc_const_eval/src/const_eval/eval_queries.rs", "status": "modified", "additions": 14, "deletions": 36, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Feval_queries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Feval_queries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Feval_queries.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "patch": "@@ -317,45 +317,23 @@ pub fn eval_to_allocation_raw_provider<'tcx>(\n     match res.and_then(|body| eval_body_using_ecx(&mut ecx, cid, &body)) {\n         Err(error) => {\n             let err = ConstEvalErr::new(&ecx, error, None);\n-            // Some CTFE errors raise just a lint, not a hard error; see\n-            // <https://github.com/rust-lang/rust/issues/71800>.\n-            let is_hard_err = if let Some(def) = def.as_local() {\n-                // (Associated) consts only emit a lint, since they might be unused.\n-                !matches!(tcx.def_kind(def.did.to_def_id()), DefKind::Const | DefKind::AssocConst)\n-                    // check if the inner InterpError is hard\n-                    || err.error.is_hard_err()\n+            let msg = if is_static {\n+                Cow::from(\"could not evaluate static initializer\")\n             } else {\n-                // use of broken constant from other crate: always an error\n-                true\n-            };\n-\n-            if is_hard_err {\n-                let msg = if is_static {\n-                    Cow::from(\"could not evaluate static initializer\")\n+                // If the current item has generics, we'd like to enrich the message with the\n+                // instance and its substs: to show the actual compile-time values, in addition to\n+                // the expression, leading to the const eval error.\n+                let instance = &key.value.instance;\n+                if !instance.substs.is_empty() {\n+                    let instance = with_no_trimmed_paths!(instance.to_string());\n+                    let msg = format!(\"evaluation of `{}` failed\", instance);\n+                    Cow::from(msg)\n                 } else {\n-                    // If the current item has generics, we'd like to enrich the message with the\n-                    // instance and its substs: to show the actual compile-time values, in addition to\n-                    // the expression, leading to the const eval error.\n-                    let instance = &key.value.instance;\n-                    if !instance.substs.is_empty() {\n-                        let instance = with_no_trimmed_paths!(instance.to_string());\n-                        let msg = format!(\"evaluation of `{}` failed\", instance);\n-                        Cow::from(msg)\n-                    } else {\n-                        Cow::from(\"evaluation of constant value failed\")\n-                    }\n-                };\n+                    Cow::from(\"evaluation of constant value failed\")\n+                }\n+            };\n \n-                Err(err.report_as_error(ecx.tcx.at(err.span), &msg))\n-            } else {\n-                let hir_id = tcx.hir().local_def_id_to_hir_id(def.as_local().unwrap().did);\n-                Err(err.report_as_lint(\n-                    tcx.at(tcx.def_span(def.did)),\n-                    \"any use of this value will cause an error\",\n-                    hir_id,\n-                    Some(err.span),\n-                ))\n-            }\n+            Err(err.report_as_error(ecx.tcx.at(err.span), &msg))\n         }\n         Ok(mplace) => {\n             // Since evaluation had no errors, validate the resulting constant."}, {"sha": "cdcebb61c2e8c3a186ad06010a51499d5e410ef0", "filename": "compiler/rustc_const_eval/src/const_eval/fn_queries.rs", "status": "modified", "additions": 56, "deletions": 16, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Ffn_queries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Ffn_queries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Ffn_queries.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "patch": "@@ -25,12 +25,10 @@ pub fn is_parent_const_impl_raw(tcx: TyCtxt<'_>, def_id: LocalDefId) -> bool {\n /// report whether said intrinsic has a `rustc_const_{un,}stable` attribute. Otherwise, return\n /// `Constness::NotConst`.\n fn constness(tcx: TyCtxt<'_>, def_id: DefId) -> hir::Constness {\n-    let def_id = def_id.expect_local();\n-    let node = tcx.hir().get_by_def_id(def_id);\n-\n-    match node {\n+    let hir_id = tcx.hir().local_def_id_to_hir_id(def_id.expect_local());\n+    match tcx.hir().get(hir_id) {\n         hir::Node::Ctor(_) => hir::Constness::Const,\n-        hir::Node::Item(hir::Item { kind: hir::ItemKind::Impl(impl_), .. }) => impl_.constness,\n+\n         hir::Node::ForeignItem(hir::ForeignItem { kind: hir::ForeignItemKind::Fn(..), .. }) => {\n             // Intrinsics use `rustc_const_{un,}stable` attributes to indicate constness. All other\n             // foreign items cannot be evaluated at compile-time.\n@@ -41,20 +39,62 @@ fn constness(tcx: TyCtxt<'_>, def_id: DefId) -> hir::Constness {\n             };\n             if is_const { hir::Constness::Const } else { hir::Constness::NotConst }\n         }\n-        _ => {\n-            if let Some(fn_kind) = node.fn_kind() {\n-                if fn_kind.constness() == hir::Constness::Const {\n-                    return hir::Constness::Const;\n-                }\n \n-                // If the function itself is not annotated with `const`, it may still be a `const fn`\n-                // if it resides in a const trait impl.\n-                let is_const = is_parent_const_impl_raw(tcx, def_id);\n-                if is_const { hir::Constness::Const } else { hir::Constness::NotConst }\n-            } else {\n-                hir::Constness::NotConst\n+        hir::Node::TraitItem(hir::TraitItem { kind: hir::TraitItemKind::Fn(..), .. })\n+            if tcx.is_const_default_method(def_id) =>\n+        {\n+            hir::Constness::Const\n+        }\n+\n+        hir::Node::Item(hir::Item { kind: hir::ItemKind::Const(..), .. })\n+        | hir::Node::Item(hir::Item { kind: hir::ItemKind::Static(..), .. })\n+        | hir::Node::TraitItem(hir::TraitItem { kind: hir::TraitItemKind::Const(..), .. })\n+        | hir::Node::AnonConst(_)\n+        | hir::Node::ImplItem(hir::ImplItem { kind: hir::ImplItemKind::Const(..), .. })\n+        | hir::Node::ImplItem(hir::ImplItem {\n+            kind:\n+                hir::ImplItemKind::Fn(\n+                    hir::FnSig {\n+                        header: hir::FnHeader { constness: hir::Constness::Const, .. },\n+                        ..\n+                    },\n+                    ..,\n+                ),\n+            ..\n+        }) => hir::Constness::Const,\n+\n+        hir::Node::ImplItem(hir::ImplItem {\n+            kind: hir::ImplItemKind::Type(..) | hir::ImplItemKind::Fn(..),\n+            ..\n+        }) => {\n+            let parent_hir_id = tcx.hir().get_parent_node(hir_id);\n+            match tcx.hir().get(parent_hir_id) {\n+                hir::Node::Item(hir::Item {\n+                    kind: hir::ItemKind::Impl(hir::Impl { constness, .. }),\n+                    ..\n+                }) => *constness,\n+                _ => span_bug!(\n+                    tcx.def_span(parent_hir_id.owner),\n+                    \"impl item's parent node is not an impl\",\n+                ),\n             }\n         }\n+\n+        hir::Node::Item(hir::Item {\n+            kind: hir::ItemKind::Fn(hir::FnSig { header: hir::FnHeader { constness, .. }, .. }, ..),\n+            ..\n+        })\n+        | hir::Node::TraitItem(hir::TraitItem {\n+            kind:\n+                hir::TraitItemKind::Fn(hir::FnSig { header: hir::FnHeader { constness, .. }, .. }, ..),\n+            ..\n+        })\n+        | hir::Node::Item(hir::Item {\n+            kind: hir::ItemKind::Impl(hir::Impl { constness, .. }),\n+            ..\n+        }) => *constness,\n+\n+        _ => hir::Constness::NotConst,\n     }\n }\n "}, {"sha": "764224fd0072eb1c38a99401a111c2e6ec85b2f3", "filename": "compiler/rustc_const_eval/src/interpret/cast.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fcast.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "patch": "@@ -42,8 +42,8 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 let res = self.pointer_from_exposed_address_cast(&src, cast_ty)?;\n                 self.write_immediate(res, dest)?;\n             }\n-\n-            Misc => {\n+            // FIXME: We shouldn't use `misc_cast` for these but handle them separately.\n+            IntToInt | FloatToInt | FloatToFloat | IntToFloat | FnPtrToPtr | PtrToPtr => {\n                 let src = self.read_immediate(src)?;\n                 let res = self.misc_cast(&src, cast_ty)?;\n                 self.write_immediate(res, dest)?;"}, {"sha": "d2e0a0dd240e8e20a2683dbf21514a5bcd6e2649", "filename": "compiler/rustc_const_eval/src/interpret/eval_context.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "patch": "@@ -258,6 +258,9 @@ impl<'tcx> fmt::Display for FrameInfo<'tcx> {\n             {\n                 write!(f, \"inside closure\")?;\n             } else {\n+                // Note: this triggers a `good_path_bug` state, which means that if we ever get here\n+                // we must emit a diagnostic. We should never display a `FrameInfo` unless we\n+                // actually want to emit a warning or error to the user.\n                 write!(f, \"inside `{}`\", self.instance)?;\n             }\n             if !self.span.is_dummy() {"}, {"sha": "f72ae7413e3012912b32a3c4d6e2022d6241696d", "filename": "compiler/rustc_const_eval/src/interpret/intern.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintern.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "patch": "@@ -332,8 +332,6 @@ pub enum InternKind {\n ///\n /// This *cannot raise an interpreter error*.  Doing so is left to validation, which\n /// tracks where in the value we are and thus can show much better error messages.\n-/// Any errors here would anyway be turned into `const_err` lints, whereas validation failures\n-/// are hard errors.\n #[instrument(level = \"debug\", skip(ecx))]\n pub fn intern_const_alloc_recursive<\n     'mir,"}, {"sha": "e5e015c1e1802408293c16fae02a20bfd357b491", "filename": "compiler/rustc_const_eval/src/interpret/memory.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmemory.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "patch": "@@ -794,7 +794,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             todo.extend(static_roots);\n             while let Some(id) = todo.pop() {\n                 if reachable.insert(id) {\n-                    // This is a new allocation, add the allocation it points to to `todo`.\n+                    // This is a new allocation, add the allocation it points to `todo`.\n                     if let Some((_, alloc)) = self.memory.alloc_map.get(id) {\n                         todo.extend(\n                             alloc.provenance().values().filter_map(|prov| prov.get_alloc_id()),"}, {"sha": "719588a936ce377b5e8b3dc27f5d7318e9d31216", "filename": "compiler/rustc_const_eval/src/interpret/operand.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "patch": "@@ -784,13 +784,14 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n }\n \n // Some nodes are used a lot. Make sure they don't unintentionally get bigger.\n-#[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\", not(bootstrap)))]\n+#[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n mod size_asserts {\n     use super::*;\n     use rustc_data_structures::static_assert_size;\n-    // These are in alphabetical order, which is easy to maintain.\n+    // tidy-alphabetical-start\n     static_assert_size!(Immediate, 48);\n     static_assert_size!(ImmTy<'_>, 64);\n     static_assert_size!(Operand, 56);\n     static_assert_size!(OpTy<'_>, 80);\n+    // tidy-alphabetical-end\n }"}, {"sha": "b0625b5f412e03ad900f57d5ef7c77130e6dca9c", "filename": "compiler/rustc_const_eval/src/interpret/place.rs", "status": "modified", "additions": 15, "deletions": 10, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "patch": "@@ -280,7 +280,7 @@ impl<'tcx, Prov: Provenance> PlaceTy<'tcx, Prov> {\n \n     #[inline(always)]\n     #[cfg_attr(debug_assertions, track_caller)] // only in debug builds due to perf (see #98980)\n-    pub fn assert_mem_place(self) -> MPlaceTy<'tcx, Prov> {\n+    pub fn assert_mem_place(&self) -> MPlaceTy<'tcx, Prov> {\n         self.try_as_mplace().unwrap()\n     }\n }\n@@ -640,11 +640,17 @@ where\n         // avoid force_allocation.\n         let src = match self.read_immediate_raw(src)? {\n             Ok(src_val) => {\n-                assert!(!src.layout.is_unsized(), \"cannot copy unsized immediates\");\n-                assert!(\n-                    !dest.layout.is_unsized(),\n-                    \"the src is sized, so the dest must also be sized\"\n-                );\n+                // FIXME(const_prop): Const-prop can possibly evaluate an\n+                // unsized copy operation when it thinks that the type is\n+                // actually sized, due to a trivially false where-clause\n+                // predicate like `where Self: Sized` with `Self = dyn Trait`.\n+                // See #102553 for an example of such a predicate.\n+                if src.layout.is_unsized() {\n+                    throw_inval!(SizeOfUnsizedType(src.layout.ty));\n+                }\n+                if dest.layout.is_unsized() {\n+                    throw_inval!(SizeOfUnsizedType(dest.layout.ty));\n+                }\n                 assert_eq!(src.layout.size, dest.layout.size);\n                 // Yay, we got a value that we can write directly.\n                 return if layout_compat {\n@@ -886,12 +892,11 @@ where\n mod size_asserts {\n     use super::*;\n     use rustc_data_structures::static_assert_size;\n-    // These are in alphabetical order, which is easy to maintain.\n-    static_assert_size!(MemPlaceMeta, 24);\n+    // tidy-alphabetical-start\n     static_assert_size!(MemPlace, 40);\n+    static_assert_size!(MemPlaceMeta, 24);\n     static_assert_size!(MPlaceTy<'_>, 64);\n-    #[cfg(not(bootstrap))]\n     static_assert_size!(Place, 40);\n-    #[cfg(not(bootstrap))]\n     static_assert_size!(PlaceTy<'_>, 64);\n+    // tidy-alphabetical-end\n }"}, {"sha": "57e40e168fa48e0b281541ee9beaef7ce7293f95", "filename": "compiler/rustc_const_eval/src/interpret/terminator.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fterminator.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "patch": "@@ -35,7 +35,6 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 assert_eq!(discr.layout.ty, switch_ty);\n \n                 // Branch to the `otherwise` case by default, if no match is found.\n-                assert!(!targets.iter().is_empty());\n                 let mut target_block = targets.otherwise();\n \n                 for (const_int, target) in targets.iter() {"}, {"sha": "d4146c2424101b528efbe8fbd8ebb6bd549f36ea", "filename": "compiler/rustc_const_eval/src/interpret/validity.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvalidity.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "patch": "@@ -56,7 +56,7 @@ macro_rules! throw_validation_failure {\n /// This lets you use the patterns as a kind of validation list, asserting which errors\n /// can possibly happen:\n ///\n-/// ```\n+/// ```ignore(illustrative)\n /// let v = try_validation!(some_fn(), some_path, {\n ///     Foo | Bar | Baz => { \"some failure\" },\n /// });\n@@ -65,7 +65,7 @@ macro_rules! throw_validation_failure {\n /// The patterns must be of type `UndefinedBehaviorInfo`.\n /// An additional expected parameter can also be added to the failure message:\n ///\n-/// ```\n+/// ```ignore(illustrative)\n /// let v = try_validation!(some_fn(), some_path, {\n ///     Foo | Bar | Baz => { \"some failure\" } expected { \"something that wasn't a failure\" },\n /// });\n@@ -74,7 +74,7 @@ macro_rules! throw_validation_failure {\n /// An additional nicety is that both parameters actually take format args, so you can just write\n /// the format string in directly:\n ///\n-/// ```\n+/// ```ignore(illustrative)\n /// let v = try_validation!(some_fn(), some_path, {\n ///     Foo | Bar | Baz => { \"{:?}\", some_failure } expected { \"{}\", expected_value },\n /// });"}, {"sha": "230f841cf4d57df80d22ffaebfa298e4e004331a", "filename": "compiler/rustc_const_eval/src/lib.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_const_eval%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_const_eval%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Flib.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "patch": "@@ -10,7 +10,6 @@ Rust MIR: a lowered representation of Rust.\n #![feature(decl_macro)]\n #![feature(exact_size_is_empty)]\n #![feature(let_chains)]\n-#![cfg_attr(bootstrap, feature(let_else))]\n #![feature(map_try_insert)]\n #![feature(min_specialization)]\n #![feature(slice_ptr_get)]\n@@ -21,7 +20,7 @@ Rust MIR: a lowered representation of Rust.\n #![feature(trusted_step)]\n #![feature(try_blocks)]\n #![feature(yeet_expr)]\n-#![feature(is_some_with)]\n+#![feature(is_some_and)]\n #![recursion_limit = \"256\"]\n #![allow(rustc::potential_query_instability)]\n \n@@ -33,7 +32,6 @@ extern crate rustc_middle;\n pub mod const_eval;\n mod errors;\n pub mod interpret;\n-mod might_permit_raw_init;\n pub mod transform;\n pub mod util;\n \n@@ -62,7 +60,6 @@ pub fn provide(providers: &mut Providers) {\n         const_eval::deref_mir_constant(tcx, param_env, value)\n     };\n     providers.permits_uninit_init =\n-        |tcx, ty| might_permit_raw_init::might_permit_raw_init(tcx, ty, InitKind::Uninit);\n-    providers.permits_zero_init =\n-        |tcx, ty| might_permit_raw_init::might_permit_raw_init(tcx, ty, InitKind::Zero);\n+        |tcx, ty| util::might_permit_raw_init(tcx, ty, InitKind::UninitMitigated0x01Fill);\n+    providers.permits_zero_init = |tcx, ty| util::might_permit_raw_init(tcx, ty, InitKind::Zero);\n }"}, {"sha": "37ffa19ccd6b9d7097c431545641129fdac547b6", "filename": "compiler/rustc_const_eval/src/might_permit_raw_init.rs", "status": "removed", "additions": 0, "deletions": 44, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/53e357748675b387b6d25fe563b960cb7a7a0aea/compiler%2Frustc_const_eval%2Fsrc%2Fmight_permit_raw_init.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53e357748675b387b6d25fe563b960cb7a7a0aea/compiler%2Frustc_const_eval%2Fsrc%2Fmight_permit_raw_init.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fmight_permit_raw_init.rs?ref=53e357748675b387b6d25fe563b960cb7a7a0aea", "patch": "@@ -1,44 +0,0 @@\n-use crate::const_eval::CompileTimeInterpreter;\n-use crate::interpret::{InterpCx, MemoryKind, OpTy};\n-use rustc_middle::ty::layout::LayoutCx;\n-use rustc_middle::ty::{layout::TyAndLayout, ParamEnv, TyCtxt};\n-use rustc_session::Limit;\n-use rustc_target::abi::InitKind;\n-\n-pub fn might_permit_raw_init<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    ty: TyAndLayout<'tcx>,\n-    kind: InitKind,\n-) -> bool {\n-    let strict = tcx.sess.opts.unstable_opts.strict_init_checks;\n-\n-    if strict {\n-        let machine = CompileTimeInterpreter::new(\n-            Limit::new(0),\n-            /*can_access_statics:*/ false,\n-            /*check_alignment:*/ true,\n-        );\n-\n-        let mut cx = InterpCx::new(tcx, rustc_span::DUMMY_SP, ParamEnv::reveal_all(), machine);\n-\n-        let allocated = cx\n-            .allocate(ty, MemoryKind::Machine(crate::const_eval::MemoryKind::Heap))\n-            .expect(\"OOM: failed to allocate for uninit check\");\n-\n-        if kind == InitKind::Zero {\n-            cx.write_bytes_ptr(\n-                allocated.ptr,\n-                std::iter::repeat(0_u8).take(ty.layout.size().bytes_usize()),\n-            )\n-            .expect(\"failed to write bytes for zero valid check\");\n-        }\n-\n-        let ot: OpTy<'_, _> = allocated.into();\n-\n-        // Assume that if it failed, it's a validation failure.\n-        cx.validate_operand(&ot).is_ok()\n-    } else {\n-        let layout_cx = LayoutCx { tcx, param_env: ParamEnv::reveal_all() };\n-        ty.might_permit_raw_init(&layout_cx, kind)\n-    }\n-}"}, {"sha": "22a61774e8cf76c3765e8d6c1d80f1907a54820a", "filename": "compiler/rustc_const_eval/src/transform/check_consts/check.rs", "status": "modified", "additions": 23, "deletions": 21, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fcheck.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "patch": "@@ -14,7 +14,7 @@ use rustc_middle::ty::{Binder, TraitPredicate, TraitRef, TypeVisitable};\n use rustc_mir_dataflow::{self, Analysis};\n use rustc_span::{sym, Span, Symbol};\n use rustc_trait_selection::infer::InferCtxtExt;\n-use rustc_trait_selection::traits::error_reporting::InferCtxtExt as _;\n+use rustc_trait_selection::traits::error_reporting::TypeErrCtxtExt as _;\n use rustc_trait_selection::traits::{\n     self, ObligationCauseCode, SelectionContext, TraitEngine, TraitEngineExt,\n };\n@@ -553,7 +553,7 @@ impl<'tcx> Visitor<'tcx> for Checker<'_, 'tcx> {\n                 unimplemented!()\n             }\n \n-            Rvalue::Cast(CastKind::Misc, _, _) => {}\n+            Rvalue::Cast(_, _, _) => {}\n \n             Rvalue::NullaryOp(NullOp::SizeOf | NullOp::AlignOf, _) => {}\n             Rvalue::ShallowInitBox(_, _) => {}\n@@ -737,14 +737,16 @@ impl<'tcx> Visitor<'tcx> for Checker<'_, 'tcx> {\n                     let obligation =\n                         Obligation::new(ObligationCause::dummy(), param_env, poly_trait_pred);\n \n-                    let implsrc = tcx.infer_ctxt().enter(|infcx| {\n+                    let implsrc = {\n+                        let infcx = tcx.infer_ctxt().build();\n                         let mut selcx = SelectionContext::new(&infcx);\n                         selcx.select(&obligation)\n-                    });\n+                    };\n \n                     // do a well-formedness check on the trait method being called. This is because typeck only does a\n                     // \"non-const\" check. This is required for correctness here.\n-                    tcx.infer_ctxt().enter(|infcx| {\n+                    {\n+                        let infcx = tcx.infer_ctxt().build();\n                         let mut fulfill_cx = <dyn TraitEngine<'_>>::new(infcx.tcx);\n                         let predicates = tcx.predicates_of(callee).instantiate(tcx, substs);\n                         let hir_id = tcx\n@@ -775,9 +777,9 @@ impl<'tcx> Visitor<'tcx> for Checker<'_, 'tcx> {\n                         }\n                         let errors = fulfill_cx.select_all_or_error(&infcx);\n                         if !errors.is_empty() {\n-                            infcx.report_fulfillment_errors(&errors, None, false);\n+                            infcx.err_ctxt().report_fulfillment_errors(&errors, None, false);\n                         }\n-                    });\n+                    }\n \n                     match implsrc {\n                         Ok(Some(ImplSource::Param(_, ty::BoundConstness::ConstIfConst))) => {\n@@ -835,16 +837,15 @@ impl<'tcx> Visitor<'tcx> for Checker<'_, 'tcx> {\n \n                                 // improve diagnostics by showing what failed. Our requirements are stricter this time\n                                 // as we are going to error again anyways.\n-                                tcx.infer_ctxt().enter(|infcx| {\n-                                    if let Err(e) = implsrc {\n-                                        infcx.report_selection_error(\n-                                            obligation.clone(),\n-                                            &obligation,\n-                                            &e,\n-                                            false,\n-                                        );\n-                                    }\n-                                });\n+                                let infcx = tcx.infer_ctxt().build();\n+                                if let Err(e) = implsrc {\n+                                    infcx.err_ctxt().report_selection_error(\n+                                        obligation.clone(),\n+                                        &obligation,\n+                                        &e,\n+                                        false,\n+                                    );\n+                                }\n \n                                 self.check_op(ops::FnCallNonConst {\n                                     caller,\n@@ -908,8 +909,6 @@ impl<'tcx> Visitor<'tcx> for Checker<'_, 'tcx> {\n                     return;\n                 }\n \n-                let is_intrinsic = tcx.is_intrinsic(callee);\n-\n                 if !tcx.is_const_fn_raw(callee) {\n                     if !tcx.is_const_default_method(callee) {\n                         // To get to here we must have already found a const impl for the\n@@ -969,7 +968,7 @@ impl<'tcx> Visitor<'tcx> for Checker<'_, 'tcx> {\n                     // We do not use `const` modifiers for intrinsic \"functions\", as intrinsics are\n                     // `extern` functions, and these have no way to get marked `const`. So instead we\n                     // use `rustc_const_(un)stable` attributes to mean that the intrinsic is `const`\n-                    if self.ccx.is_const_stable_const_fn() || is_intrinsic {\n+                    if self.ccx.is_const_stable_const_fn() || tcx.is_intrinsic(callee) {\n                         self.check_op(ops::FnCallUnstable(callee, None));\n                         return;\n                     }\n@@ -1009,7 +1008,10 @@ impl<'tcx> Visitor<'tcx> for Checker<'_, 'tcx> {\n \n                 if needs_non_const_drop {\n                     self.check_op_spanned(\n-                        ops::LiveDrop { dropped_at: Some(terminator.source_info.span) },\n+                        ops::LiveDrop {\n+                            dropped_at: Some(terminator.source_info.span),\n+                            dropped_ty: ty_of_dropped_place,\n+                        },\n                         err_span,\n                     );\n                 }"}, {"sha": "b28d70194917bca694981d5b90d88e0f884a6873", "filename": "compiler/rustc_const_eval/src/transform/check_consts/ops.rs", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fops.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "patch": "@@ -156,10 +156,9 @@ impl<'tcx> NonConstOp<'tcx> for FnCallNonConst<'tcx> {\n                         }),\n                     );\n \n-                    let implsrc = tcx.infer_ctxt().enter(|infcx| {\n-                        let mut selcx = SelectionContext::new(&infcx);\n-                        selcx.select(&obligation)\n-                    });\n+                    let infcx = tcx.infer_ctxt().build();\n+                    let mut selcx = SelectionContext::new(&infcx);\n+                    let implsrc = selcx.select(&obligation);\n \n                     if let Ok(Some(ImplSource::UserDefined(data))) = implsrc {\n                         let span = tcx.def_span(data.impl_def_id);\n@@ -422,10 +421,11 @@ impl<'tcx> NonConstOp<'tcx> for InlineAsm {\n }\n \n #[derive(Debug)]\n-pub struct LiveDrop {\n+pub struct LiveDrop<'tcx> {\n     pub dropped_at: Option<Span>,\n+    pub dropped_ty: Ty<'tcx>,\n }\n-impl<'tcx> NonConstOp<'tcx> for LiveDrop {\n+impl<'tcx> NonConstOp<'tcx> for LiveDrop<'tcx> {\n     fn build_error(\n         &self,\n         ccx: &ConstCx<'_, 'tcx>,\n@@ -435,9 +435,13 @@ impl<'tcx> NonConstOp<'tcx> for LiveDrop {\n             ccx.tcx.sess,\n             span,\n             E0493,\n-            \"destructors cannot be evaluated at compile-time\"\n+            \"destructor of `{}` cannot be evaluated at compile-time\",\n+            self.dropped_ty,\n+        );\n+        err.span_label(\n+            span,\n+            format!(\"the destructor for this type cannot be evaluated in {}s\", ccx.const_kind()),\n         );\n-        err.span_label(span, format!(\"{}s cannot evaluate destructors\", ccx.const_kind()));\n         if let Some(span) = self.dropped_at {\n             err.span_label(span, \"value is dropped here\");\n         }"}, {"sha": "d4570c59889145e3b885b41e5939649f7246ac4c", "filename": "compiler/rustc_const_eval/src/transform/check_consts/post_drop_elaboration.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fpost_drop_elaboration.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fpost_drop_elaboration.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fpost_drop_elaboration.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "patch": "@@ -1,6 +1,6 @@\n use rustc_middle::mir::visit::Visitor;\n use rustc_middle::mir::{self, BasicBlock, Location};\n-use rustc_middle::ty::TyCtxt;\n+use rustc_middle::ty::{Ty, TyCtxt};\n use rustc_span::{symbol::sym, Span};\n \n use super::check::Qualifs;\n@@ -58,9 +58,9 @@ impl<'mir, 'tcx> std::ops::Deref for CheckLiveDrops<'mir, 'tcx> {\n     }\n }\n \n-impl CheckLiveDrops<'_, '_> {\n-    fn check_live_drop(&self, span: Span) {\n-        ops::LiveDrop { dropped_at: None }.build_error(self.ccx, span).emit();\n+impl<'tcx> CheckLiveDrops<'_, 'tcx> {\n+    fn check_live_drop(&self, span: Span, dropped_ty: Ty<'tcx>) {\n+        ops::LiveDrop { dropped_at: None, dropped_ty }.build_error(self.ccx, span).emit();\n     }\n }\n \n@@ -90,7 +90,7 @@ impl<'tcx> Visitor<'tcx> for CheckLiveDrops<'_, 'tcx> {\n                 }\n \n                 if dropped_place.is_indirect() {\n-                    self.check_live_drop(terminator.source_info.span);\n+                    self.check_live_drop(terminator.source_info.span, dropped_ty);\n                     return;\n                 }\n \n@@ -101,7 +101,7 @@ impl<'tcx> Visitor<'tcx> for CheckLiveDrops<'_, 'tcx> {\n                 if self.qualifs.needs_non_const_drop(self.ccx, dropped_place.local, location) {\n                     // Use the span where the dropped local was declared for the error.\n                     let span = self.body.local_decls[dropped_place.local].source_info.span;\n-                    self.check_live_drop(span);\n+                    self.check_live_drop(span, dropped_ty);\n                 }\n             }\n "}, {"sha": "b77b213b51a542fe4bb847a93a65ddaeaff2d5e3", "filename": "compiler/rustc_const_eval/src/transform/check_consts/qualifs.rs", "status": "modified", "additions": 26, "deletions": 34, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fqualifs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fqualifs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fqualifs.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "patch": "@@ -5,6 +5,7 @@\n use rustc_errors::ErrorGuaranteed;\n use rustc_hir::LangItem;\n use rustc_infer::infer::TyCtxtInferExt;\n+use rustc_middle::mir;\n use rustc_middle::mir::*;\n use rustc_middle::ty::{self, subst::SubstsRef, AdtDef, Ty};\n use rustc_span::DUMMY_SP;\n@@ -167,30 +168,28 @@ impl Qualif for NeedsNonConstDrop {\n             }),\n         );\n \n-        cx.tcx.infer_ctxt().enter(|infcx| {\n-            let mut selcx = SelectionContext::new(&infcx);\n-            let Some(impl_src) = selcx.select(&obligation).ok().flatten() else {\n-                // If we couldn't select a const destruct candidate, then it's bad\n-                return true;\n-            };\n-\n-            if !matches!(\n-                impl_src,\n-                ImplSource::ConstDestruct(_)\n-                    | ImplSource::Param(_, ty::BoundConstness::ConstIfConst)\n-            ) {\n-                // If our const destruct candidate is not ConstDestruct or implied by the param env,\n-                // then it's bad\n-                return true;\n-            }\n+        let infcx = cx.tcx.infer_ctxt().build();\n+        let mut selcx = SelectionContext::new(&infcx);\n+        let Some(impl_src) = selcx.select(&obligation).ok().flatten() else {\n+            // If we couldn't select a const destruct candidate, then it's bad\n+            return true;\n+        };\n+\n+        if !matches!(\n+            impl_src,\n+            ImplSource::ConstDestruct(_) | ImplSource::Param(_, ty::BoundConstness::ConstIfConst)\n+        ) {\n+            // If our const destruct candidate is not ConstDestruct or implied by the param env,\n+            // then it's bad\n+            return true;\n+        }\n \n-            if impl_src.borrow_nested_obligations().is_empty() {\n-                return false;\n-            }\n+        if impl_src.borrow_nested_obligations().is_empty() {\n+            return false;\n+        }\n \n-            // If we had any errors, then it's bad\n-            !traits::fully_solve_obligations(&infcx, impl_src.nested_obligations()).is_empty()\n-        })\n+        // If we had any errors, then it's bad\n+        !traits::fully_solve_obligations(&infcx, impl_src.nested_obligations()).is_empty()\n     }\n \n     fn in_adt_inherently<'tcx>(\n@@ -350,29 +349,22 @@ where\n     // FIXME(valtrees): check whether const qualifs should behave the same\n     // way for type and mir constants.\n     let uneval = match constant.literal {\n-        ConstantKind::Ty(ct) if matches!(ct.kind(), ty::ConstKind::Unevaluated(_)) => {\n-            let ty::ConstKind::Unevaluated(uv) = ct.kind() else { unreachable!() };\n-\n-            Some(uv.expand())\n-        }\n-        ConstantKind::Ty(_) => None,\n+        ConstantKind::Ty(ct) if matches!(ct.kind(), ty::ConstKind::Param(_)) => None,\n+        ConstantKind::Ty(c) => bug!(\"expected ConstKind::Param here, found {:?}\", c),\n         ConstantKind::Unevaluated(uv, _) => Some(uv),\n         ConstantKind::Val(..) => None,\n     };\n \n-    if let Some(ty::Unevaluated { def, substs: _, promoted }) = uneval {\n+    if let Some(mir::UnevaluatedConst { def, substs: _, promoted }) = uneval {\n         // Use qualifs of the type for the promoted. Promoteds in MIR body should be possible\n         // only for `NeedsNonConstDrop` with precise drop checking. This is the only const\n         // check performed after the promotion. Verify that with an assertion.\n         assert!(promoted.is_none() || Q::ALLOW_PROMOTED);\n \n         // Don't peek inside trait associated constants.\n         if promoted.is_none() && cx.tcx.trait_of_item(def.did).is_none() {\n-            let qualifs = if let Some((did, param_did)) = def.as_const_arg() {\n-                cx.tcx.at(constant.span).mir_const_qualif_const_arg((did, param_did))\n-            } else {\n-                cx.tcx.at(constant.span).mir_const_qualif(def.did)\n-            };\n+            assert_eq!(def.const_param_did, None, \"expected associated const: {def:?}\");\n+            let qualifs = cx.tcx.at(constant.span).mir_const_qualif(def.did);\n \n             if !Q::in_qualifs(&qualifs) {\n                 return false;"}, {"sha": "4b219300739c0812a42d38daf9a1d362d3b380a5", "filename": "compiler/rustc_const_eval/src/transform/promote_consts.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fpromote_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fpromote_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fpromote_consts.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "patch": "@@ -13,6 +13,7 @@\n //! move analysis runs after promotion on broken MIR.\n \n use rustc_hir as hir;\n+use rustc_middle::mir;\n use rustc_middle::mir::traversal::ReversePostorderIter;\n use rustc_middle::mir::visit::{MutVisitor, MutatingUseContext, PlaceContext, Visitor};\n use rustc_middle::mir::*;\n@@ -840,7 +841,7 @@ impl<'a, 'tcx> Promoter<'a, 'tcx> {\n                 promoted.span = span;\n                 promoted.local_decls[RETURN_PLACE] = LocalDecl::new(ty, span);\n                 let substs = tcx.erase_regions(InternalSubsts::identity_for_item(tcx, def.did));\n-                let uneval = ty::Unevaluated { def, substs, promoted: Some(promoted_id) };\n+                let uneval = mir::UnevaluatedConst { def, substs, promoted: Some(promoted_id) };\n \n                 Operand::Constant(Box::new(Constant {\n                     span,"}, {"sha": "fbb129f97247e9b865794497135a80a1c05b997b", "filename": "compiler/rustc_const_eval/src/transform/validate.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "patch": "@@ -105,7 +105,7 @@ pub fn equal_up_to_regions<'tcx>(\n             },\n         )\n     };\n-    tcx.infer_ctxt().enter(|infcx| infcx.can_eq(param_env, normalize(src), normalize(dest)).is_ok())\n+    tcx.infer_ctxt().build().can_eq(param_env, normalize(src), normalize(dest)).is_ok()\n }\n \n struct TypeChecker<'a, 'tcx> {\n@@ -284,7 +284,7 @@ impl<'a, 'tcx> Visitor<'tcx> for TypeChecker<'a, 'tcx> {\n                         this.fail(\n                         location,\n                         format!(\n-                            \"Field projection `{:?}.{:?}` specified type `{:?}`, but actual type is {:?}\",\n+                            \"Field projection `{:?}.{:?}` specified type `{:?}`, but actual type is `{:?}`\",\n                             parent, f, ty, f_ty\n                         )\n                     )\n@@ -557,7 +557,14 @@ impl<'a, 'tcx> Visitor<'tcx> for TypeChecker<'a, 'tcx> {\n             }\n             Rvalue::Cast(kind, operand, target_type) => {\n                 match kind {\n-                    CastKind::Misc => {\n+                    CastKind::DynStar => {\n+                        // FIXME(dyn-star): make sure nothing needs to be done here.\n+                    }\n+                    // Nothing to check here\n+                    CastKind::PointerFromExposedAddress\n+                    | CastKind::PointerExposeAddress\n+                    | CastKind::Pointer(_) => {}\n+                    _ => {\n                         let op_ty = operand.ty(self.body, self.tcx);\n                         if op_ty.is_enum() {\n                             self.fail(\n@@ -568,13 +575,6 @@ impl<'a, 'tcx> Visitor<'tcx> for TypeChecker<'a, 'tcx> {\n                             );\n                         }\n                     }\n-                    CastKind::DynStar => {\n-                        // FIXME(dyn-star): make sure nothing needs to be done here.\n-                    }\n-                    // Nothing to check here\n-                    CastKind::PointerFromExposedAddress\n-                    | CastKind::PointerExposeAddress\n-                    | CastKind::Pointer(_) => {}\n                 }\n             }\n             Rvalue::Repeat(_, _)"}, {"sha": "6ca71223391d2a5828b39b655cb113473cd0e46f", "filename": "compiler/rustc_const_eval/src/util/might_permit_raw_init.rs", "status": "added", "additions": 151, "deletions": 0, "changes": 151, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_const_eval%2Fsrc%2Futil%2Fmight_permit_raw_init.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_const_eval%2Fsrc%2Futil%2Fmight_permit_raw_init.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Futil%2Fmight_permit_raw_init.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "patch": "@@ -0,0 +1,151 @@\n+use rustc_middle::ty::layout::{LayoutCx, LayoutOf, TyAndLayout};\n+use rustc_middle::ty::{ParamEnv, TyCtxt};\n+use rustc_session::Limit;\n+use rustc_target::abi::{Abi, FieldsShape, InitKind, Scalar, Variants};\n+\n+use crate::const_eval::CompileTimeInterpreter;\n+use crate::interpret::{InterpCx, MemoryKind, OpTy};\n+\n+/// Determines if this type permits \"raw\" initialization by just transmuting some memory into an\n+/// instance of `T`.\n+///\n+/// `init_kind` indicates if the memory is zero-initialized or left uninitialized. We assume\n+/// uninitialized memory is mitigated by filling it with 0x01, which reduces the chance of causing\n+/// LLVM UB.\n+///\n+/// By default we check whether that operation would cause *LLVM UB*, i.e., whether the LLVM IR we\n+/// generate has UB or not. This is a mitigation strategy, which is why we are okay with accepting\n+/// Rust UB as long as there is no risk of miscompilations. The `strict_init_checks` can be set to\n+/// do a full check against Rust UB instead (in which case we will also ignore the 0x01-filling and\n+/// to the full uninit check).\n+pub fn might_permit_raw_init<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    ty: TyAndLayout<'tcx>,\n+    kind: InitKind,\n+) -> bool {\n+    if tcx.sess.opts.unstable_opts.strict_init_checks {\n+        might_permit_raw_init_strict(ty, tcx, kind)\n+    } else {\n+        let layout_cx = LayoutCx { tcx, param_env: ParamEnv::reveal_all() };\n+        might_permit_raw_init_lax(ty, &layout_cx, kind)\n+    }\n+}\n+\n+/// Implements the 'strict' version of the `might_permit_raw_init` checks; see that function for\n+/// details.\n+fn might_permit_raw_init_strict<'tcx>(\n+    ty: TyAndLayout<'tcx>,\n+    tcx: TyCtxt<'tcx>,\n+    kind: InitKind,\n+) -> bool {\n+    let machine = CompileTimeInterpreter::new(\n+        Limit::new(0),\n+        /*can_access_statics:*/ false,\n+        /*check_alignment:*/ true,\n+    );\n+\n+    let mut cx = InterpCx::new(tcx, rustc_span::DUMMY_SP, ParamEnv::reveal_all(), machine);\n+\n+    let allocated = cx\n+        .allocate(ty, MemoryKind::Machine(crate::const_eval::MemoryKind::Heap))\n+        .expect(\"OOM: failed to allocate for uninit check\");\n+\n+    if kind == InitKind::Zero {\n+        cx.write_bytes_ptr(\n+            allocated.ptr,\n+            std::iter::repeat(0_u8).take(ty.layout.size().bytes_usize()),\n+        )\n+        .expect(\"failed to write bytes for zero valid check\");\n+    }\n+\n+    let ot: OpTy<'_, _> = allocated.into();\n+\n+    // Assume that if it failed, it's a validation failure.\n+    // This does *not* actually check that references are dereferenceable, but since all types that\n+    // require dereferenceability also require non-null, we don't actually get any false negatives\n+    // due to this.\n+    cx.validate_operand(&ot).is_ok()\n+}\n+\n+/// Implements the 'lax' (default) version of the `might_permit_raw_init` checks; see that function for\n+/// details.\n+fn might_permit_raw_init_lax<'tcx>(\n+    this: TyAndLayout<'tcx>,\n+    cx: &LayoutCx<'tcx, TyCtxt<'tcx>>,\n+    init_kind: InitKind,\n+) -> bool {\n+    let scalar_allows_raw_init = move |s: Scalar| -> bool {\n+        match init_kind {\n+            InitKind::Zero => {\n+                // The range must contain 0.\n+                s.valid_range(cx).contains(0)\n+            }\n+            InitKind::UninitMitigated0x01Fill => {\n+                // The range must include an 0x01-filled buffer.\n+                let mut val: u128 = 0x01;\n+                for _ in 1..s.size(cx).bytes() {\n+                    // For sizes >1, repeat the 0x01.\n+                    val = (val << 8) | 0x01;\n+                }\n+                s.valid_range(cx).contains(val)\n+            }\n+        }\n+    };\n+\n+    // Check the ABI.\n+    let valid = match this.abi {\n+        Abi::Uninhabited => false, // definitely UB\n+        Abi::Scalar(s) => scalar_allows_raw_init(s),\n+        Abi::ScalarPair(s1, s2) => scalar_allows_raw_init(s1) && scalar_allows_raw_init(s2),\n+        Abi::Vector { element: s, count } => count == 0 || scalar_allows_raw_init(s),\n+        Abi::Aggregate { .. } => true, // Fields are checked below.\n+    };\n+    if !valid {\n+        // This is definitely not okay.\n+        return false;\n+    }\n+\n+    // Special magic check for references and boxes (i.e., special pointer types).\n+    if let Some(pointee) = this.ty.builtin_deref(false) {\n+        let pointee = cx.layout_of(pointee.ty).expect(\"need to be able to compute layouts\");\n+        // We need to ensure that the LLVM attributes `aligned` and `dereferenceable(size)` are satisfied.\n+        if pointee.align.abi.bytes() > 1 {\n+            // 0x01-filling is not aligned.\n+            return false;\n+        }\n+        if pointee.size.bytes() > 0 {\n+            // A 'fake' integer pointer is not sufficiently dereferenceable.\n+            return false;\n+        }\n+    }\n+\n+    // If we have not found an error yet, we need to recursively descend into fields.\n+    match &this.fields {\n+        FieldsShape::Primitive | FieldsShape::Union { .. } => {}\n+        FieldsShape::Array { .. } => {\n+            // Arrays never have scalar layout in LLVM, so if the array is not actually\n+            // accessed, there is no LLVM UB -- therefore we can skip this.\n+        }\n+        FieldsShape::Arbitrary { offsets, .. } => {\n+            for idx in 0..offsets.len() {\n+                if !might_permit_raw_init_lax(this.field(cx, idx), cx, init_kind) {\n+                    // We found a field that is unhappy with this kind of initialization.\n+                    return false;\n+                }\n+            }\n+        }\n+    }\n+\n+    match &this.variants {\n+        Variants::Single { .. } => {\n+            // All fields of this single variant have already been checked above, there is nothing\n+            // else to do.\n+        }\n+        Variants::Multiple { .. } => {\n+            // We cannot tell LLVM anything about the details of this multi-variant layout, so\n+            // invalid values \"hidden\" inside the variant cannot cause LLVM trouble.\n+        }\n+    }\n+\n+    true\n+}"}, {"sha": "7a05cfd235faecd03dfce3339459ccd6f79c1ce8", "filename": "compiler/rustc_const_eval/src/util/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_const_eval%2Fsrc%2Futil%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_const_eval%2Fsrc%2Futil%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Futil%2Fmod.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "patch": "@@ -3,8 +3,10 @@ mod alignment;\n mod call_kind;\n pub mod collect_writes;\n mod find_self_call;\n+mod might_permit_raw_init;\n \n pub use self::aggregate::expand_aggregate;\n pub use self::alignment::is_disaligned;\n pub use self::call_kind::{call_kind, CallDesugaringKind, CallKind};\n pub use self::find_self_call::find_self_call;\n+pub use self::might_permit_raw_init::might_permit_raw_init;"}, {"sha": "9daa21ef6b11d38f098df4817ee18c4f490e4831", "filename": "compiler/rustc_data_structures/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_data_structures%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_data_structures%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2FCargo.toml?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "patch": "@@ -4,7 +4,6 @@ version = \"0.0.0\"\n edition = \"2021\"\n \n [lib]\n-doctest = false\n \n [dependencies]\n arrayvec = { version = \"0.7\", default-features = false }"}, {"sha": "9ed26e4900696f4b48061d9585bedc61594e1828", "filename": "compiler/rustc_data_structures/src/flock/linux.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_data_structures%2Fsrc%2Fflock%2Flinux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_data_structures%2Fsrc%2Fflock%2Flinux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fflock%2Flinux.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "patch": "@@ -14,12 +14,7 @@ pub struct Lock {\n \n impl Lock {\n     pub fn new(p: &Path, wait: bool, create: bool, exclusive: bool) -> io::Result<Lock> {\n-        let file = OpenOptions::new()\n-            .read(true)\n-            .write(true)\n-            .create(create)\n-            .mode(libc::S_IRWXU as u32)\n-            .open(p)?;\n+        let file = OpenOptions::new().read(true).write(true).create(create).mode(0o600).open(p)?;\n \n         let mut operation = if exclusive { libc::LOCK_EX } else { libc::LOCK_SH };\n         if !wait {"}, {"sha": "e8efbd09a2c38c815647ec4cd62b5acae103bbc7", "filename": "compiler/rustc_data_structures/src/graph/vec_graph/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fvec_graph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fvec_graph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fvec_graph%2Fmod.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "patch": "@@ -29,8 +29,8 @@ impl<N: Idx + Ord> VecGraph<N> {\n         // Store the *target* of each edge into `edge_targets`.\n         let edge_targets: Vec<N> = edge_pairs.iter().map(|&(_, target)| target).collect();\n \n-        // Create the *edge starts* array. We are iterating over over\n-        // the (sorted) edge pairs. We maintain the invariant that the\n+        // Create the *edge starts* array. We are iterating over the\n+        // (sorted) edge pairs. We maintain the invariant that the\n         // length of the `node_starts` array is enough to store the\n         // current source node -- so when we see that the source node\n         // for an edge is greater than the current length, we grow the"}, {"sha": "467ac401d086b3f35b21506bf2ec05167b47b548", "filename": "compiler/rustc_data_structures/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_data_structures%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_data_structures%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Flib.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "patch": "@@ -13,7 +13,6 @@\n #![feature(cell_leak)]\n #![feature(control_flow_enum)]\n #![feature(extend_one)]\n-#![cfg_attr(bootstrap, feature(let_else))]\n #![feature(hash_raw_entry)]\n #![feature(hasher_prefixfree_extras)]\n #![feature(maybe_uninit_uninit_array)]"}, {"sha": "ba1960805d84bf0301539f5e50363a8859db4c9d", "filename": "compiler/rustc_data_structures/src/profiling.rs", "status": "modified", "additions": 27, "deletions": 37, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_data_structures%2Fsrc%2Fprofiling.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_data_structures%2Fsrc%2Fprofiling.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fprofiling.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "patch": "@@ -158,30 +158,21 @@ pub struct SelfProfilerRef {\n     // actually enabled.\n     event_filter_mask: EventFilter,\n \n-    // Print verbose generic activities to stdout\n+    // Print verbose generic activities to stderr?\n     print_verbose_generic_activities: bool,\n-\n-    // Print extra verbose generic activities to stdout\n-    print_extra_verbose_generic_activities: bool,\n }\n \n impl SelfProfilerRef {\n     pub fn new(\n         profiler: Option<Arc<SelfProfiler>>,\n         print_verbose_generic_activities: bool,\n-        print_extra_verbose_generic_activities: bool,\n     ) -> SelfProfilerRef {\n         // If there is no SelfProfiler then the filter mask is set to NONE,\n         // ensuring that nothing ever tries to actually access it.\n         let event_filter_mask =\n             profiler.as_ref().map_or(EventFilter::empty(), |p| p.event_filter_mask);\n \n-        SelfProfilerRef {\n-            profiler,\n-            event_filter_mask,\n-            print_verbose_generic_activities,\n-            print_extra_verbose_generic_activities,\n-        }\n+        SelfProfilerRef { profiler, event_filter_mask, print_verbose_generic_activities }\n     }\n \n     /// This shim makes sure that calls only get executed if the filter mask\n@@ -214,7 +205,7 @@ impl SelfProfilerRef {\n     /// Start profiling a verbose generic activity. Profiling continues until the\n     /// VerboseTimingGuard returned from this call is dropped. In addition to recording\n     /// a measureme event, \"verbose\" generic activities also print a timing entry to\n-    /// stdout if the compiler is invoked with -Ztime or -Ztime-passes.\n+    /// stderr if the compiler is invoked with -Ztime-passes.\n     pub fn verbose_generic_activity<'a>(\n         &'a self,\n         event_label: &'static str,\n@@ -225,19 +216,16 @@ impl SelfProfilerRef {\n         VerboseTimingGuard::start(message, self.generic_activity(event_label))\n     }\n \n-    /// Start profiling an extra verbose generic activity. Profiling continues until the\n-    /// VerboseTimingGuard returned from this call is dropped. In addition to recording\n-    /// a measureme event, \"extra verbose\" generic activities also print a timing entry to\n-    /// stdout if the compiler is invoked with -Ztime-passes.\n-    pub fn extra_verbose_generic_activity<'a, A>(\n+    /// Like `verbose_generic_activity`, but with an extra arg.\n+    pub fn verbose_generic_activity_with_arg<'a, A>(\n         &'a self,\n         event_label: &'static str,\n         event_arg: A,\n     ) -> VerboseTimingGuard<'a>\n     where\n         A: Borrow<str> + Into<String>,\n     {\n-        let message = if self.print_extra_verbose_generic_activities {\n+        let message = if self.print_verbose_generic_activities {\n             Some(format!(\"{}({})\", event_label, event_arg.borrow()))\n         } else {\n             None\n@@ -745,27 +733,9 @@ impl Drop for VerboseTimingGuard<'_> {\n         if let Some((start_time, start_rss, ref message)) = self.start_and_message {\n             let end_rss = get_resident_set_size();\n             let dur = start_time.elapsed();\n-\n-            if should_print_passes(dur, start_rss, end_rss) {\n-                print_time_passes_entry(&message, dur, start_rss, end_rss);\n-            }\n-        }\n-    }\n-}\n-\n-fn should_print_passes(dur: Duration, start_rss: Option<usize>, end_rss: Option<usize>) -> bool {\n-    if dur.as_millis() > 5 {\n-        return true;\n-    }\n-\n-    if let (Some(start_rss), Some(end_rss)) = (start_rss, end_rss) {\n-        let change_rss = end_rss.abs_diff(start_rss);\n-        if change_rss > 0 {\n-            return true;\n+            print_time_passes_entry(&message, dur, start_rss, end_rss);\n         }\n     }\n-\n-    false\n }\n \n pub fn print_time_passes_entry(\n@@ -774,6 +744,26 @@ pub fn print_time_passes_entry(\n     start_rss: Option<usize>,\n     end_rss: Option<usize>,\n ) {\n+    // Print the pass if its duration is greater than 5 ms, or it changed the\n+    // measured RSS.\n+    let is_notable = || {\n+        if dur.as_millis() > 5 {\n+            return true;\n+        }\n+\n+        if let (Some(start_rss), Some(end_rss)) = (start_rss, end_rss) {\n+            let change_rss = end_rss.abs_diff(start_rss);\n+            if change_rss > 0 {\n+                return true;\n+            }\n+        }\n+\n+        false\n+    };\n+    if !is_notable() {\n+        return;\n+    }\n+\n     let rss_to_mb = |rss| (rss as f64 / 1_000_000.0).round() as usize;\n     let rss_change_to_mb = |rss| (rss as f64 / 1_000_000.0).round() as i128;\n "}, {"sha": "fe257e10205faaba0a4ed055ec7faa3fd5ac4c7a", "filename": "compiler/rustc_data_structures/src/sorted_map.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_data_structures%2Fsrc%2Fsorted_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_data_structures%2Fsrc%2Fsorted_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fsorted_map.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "patch": "@@ -96,6 +96,23 @@ impl<K: Ord, V> SortedMap<K, V> {\n         }\n     }\n \n+    /// Gets a mutable reference to the value in the entry, or insert a new one.\n+    #[inline]\n+    pub fn get_mut_or_insert_default(&mut self, key: K) -> &mut V\n+    where\n+        K: Eq,\n+        V: Default,\n+    {\n+        let index = match self.lookup_index_for(&key) {\n+            Ok(index) => index,\n+            Err(index) => {\n+                self.data.insert(index, (key, V::default()));\n+                index\n+            }\n+        };\n+        unsafe { &mut self.data.get_unchecked_mut(index).1 }\n+    }\n+\n     #[inline]\n     pub fn clear(&mut self) {\n         self.data.clear();"}, {"sha": "cf616203842a69d6a613704ad7c968b11d02e405", "filename": "compiler/rustc_data_structures/src/transitive_relation.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_data_structures%2Fsrc%2Ftransitive_relation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_data_structures%2Fsrc%2Ftransitive_relation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Ftransitive_relation.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "patch": "@@ -1,5 +1,5 @@\n use crate::frozen::Frozen;\n-use crate::fx::FxIndexSet;\n+use crate::fx::{FxHashSet, FxIndexSet};\n use rustc_index::bit_set::BitMatrix;\n use std::fmt::Debug;\n use std::hash::Hash;\n@@ -16,7 +16,7 @@ pub struct TransitiveRelationBuilder<T> {\n \n     // List of base edges in the graph. Require to compute transitive\n     // closure.\n-    edges: Vec<Edge>,\n+    edges: FxHashSet<Edge>,\n }\n \n #[derive(Debug)]\n@@ -52,10 +52,10 @@ impl<T: Eq + Hash> Default for TransitiveRelationBuilder<T> {\n     }\n }\n \n-#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Debug)]\n+#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Debug, Hash)]\n struct Index(usize);\n \n-#[derive(Clone, PartialEq, Eq, Debug)]\n+#[derive(Clone, PartialEq, Eq, Debug, Hash)]\n struct Edge {\n     source: Index,\n     target: Index,\n@@ -99,9 +99,7 @@ impl<T: Eq + Hash + Copy> TransitiveRelationBuilder<T> {\n         let a = self.add_index(a);\n         let b = self.add_index(b);\n         let edge = Edge { source: a, target: b };\n-        if !self.edges.contains(&edge) {\n-            self.edges.push(edge);\n-        }\n+        self.edges.insert(edge);\n     }\n \n     /// Compute the transitive closure derived from the edges, and converted to"}, {"sha": "59e937777483ec1941854b6d66d5b29c26ea4a49", "filename": "compiler/rustc_driver/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_driver%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_driver%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_driver%2FCargo.toml?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "patch": "@@ -30,7 +30,7 @@ rustc_error_codes = { path = \"../rustc_error_codes\" }\n rustc_interface = { path = \"../rustc_interface\" }\n rustc_ast = { path = \"../rustc_ast\" }\n rustc_span = { path = \"../rustc_span\" }\n-rustc_typeck = { path = \"../rustc_typeck\" }\n+rustc_hir_analysis = { path = \"../rustc_hir_analysis\" }\n \n [target.'cfg(unix)'.dependencies]\n libc = \"0.2\""}, {"sha": "7edbb6f757ce16bba13623d69c73062f54aa3393", "filename": "compiler/rustc_driver/src/lib.rs", "status": "modified", "additions": 22, "deletions": 27, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_driver%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_driver%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_driver%2Fsrc%2Flib.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "patch": "@@ -5,7 +5,6 @@\n //! This API is completely unstable and subject to change.\n \n #![doc(html_root_url = \"https://doc.rust-lang.org/nightly/nightly-rustc/\")]\n-#![cfg_attr(bootstrap, feature(let_else))]\n #![feature(once_cell)]\n #![recursion_limit = \"256\"]\n #![allow(rustc::potential_query_instability)]\n@@ -36,7 +35,7 @@ use rustc_session::config::{ErrorOutputType, Input, OutputType, PrintRequest, Tr\n use rustc_session::cstore::MetadataLoader;\n use rustc_session::getopts;\n use rustc_session::lint::{Lint, LintId};\n-use rustc_session::{config, DiagnosticOutput, Session};\n+use rustc_session::{config, Session};\n use rustc_session::{early_error, early_error_no_abort, early_warn};\n use rustc_span::source_map::{FileLoader, FileName};\n use rustc_span::symbol::sym;\n@@ -128,10 +127,13 @@ pub struct TimePassesCallbacks {\n }\n \n impl Callbacks for TimePassesCallbacks {\n+    // JUSTIFICATION: the session doesn't exist at this point.\n+    #[allow(rustc::bad_opt_access)]\n     fn config(&mut self, config: &mut interface::Config) {\n-        // If a --prints=... option has been given, we don't print the \"total\"\n-        // time because it will mess up the --prints output. See #64339.\n-        self.time_passes = config.opts.prints.is_empty() && config.opts.time_passes();\n+        // If a --print=... option has been given, we don't print the \"total\"\n+        // time because it will mess up the --print output. See #64339.\n+        //\n+        self.time_passes = config.opts.prints.is_empty() && config.opts.unstable_opts.time_passes;\n         config.opts.trimmed_def_paths = TrimmedDefPaths::GoodPath;\n     }\n }\n@@ -145,19 +147,21 @@ pub struct RunCompiler<'a, 'b> {\n     at_args: &'a [String],\n     callbacks: &'b mut (dyn Callbacks + Send),\n     file_loader: Option<Box<dyn FileLoader + Send + Sync>>,\n-    emitter: Option<Box<dyn Write + Send>>,\n     make_codegen_backend:\n         Option<Box<dyn FnOnce(&config::Options) -> Box<dyn CodegenBackend> + Send>>,\n }\n \n impl<'a, 'b> RunCompiler<'a, 'b> {\n     pub fn new(at_args: &'a [String], callbacks: &'b mut (dyn Callbacks + Send)) -> Self {\n-        Self { at_args, callbacks, file_loader: None, emitter: None, make_codegen_backend: None }\n+        Self { at_args, callbacks, file_loader: None, make_codegen_backend: None }\n     }\n \n     /// Set a custom codegen backend.\n     ///\n-    /// Used by cg_clif.\n+    /// Has no uses within this repository, but is used by bjorn3 for \"the\n+    /// hotswapping branch of cg_clif\" for \"setting the codegen backend from a\n+    /// custom driver where the custom codegen backend has arbitrary data.\"\n+    /// (See #102759.)\n     pub fn set_make_codegen_backend(\n         &mut self,\n         make_codegen_backend: Option<\n@@ -168,17 +172,11 @@ impl<'a, 'b> RunCompiler<'a, 'b> {\n         self\n     }\n \n-    /// Emit diagnostics to the specified location.\n-    ///\n-    /// Used by RLS.\n-    pub fn set_emitter(&mut self, emitter: Option<Box<dyn Write + Send>>) -> &mut Self {\n-        self.emitter = emitter;\n-        self\n-    }\n-\n     /// Load files from sources other than the file system.\n     ///\n-    /// Used by RLS.\n+    /// Has no uses within this repository, but may be used in the future by\n+    /// bjorn3 for \"hooking rust-analyzer's VFS into rustc at some point for\n+    /// running rustc without having to save\". (See #102759.)\n     pub fn set_file_loader(\n         &mut self,\n         file_loader: Option<Box<dyn FileLoader + Send + Sync>>,\n@@ -189,27 +187,20 @@ impl<'a, 'b> RunCompiler<'a, 'b> {\n \n     /// Parse args and run the compiler.\n     pub fn run(self) -> interface::Result<()> {\n-        run_compiler(\n-            self.at_args,\n-            self.callbacks,\n-            self.file_loader,\n-            self.emitter,\n-            self.make_codegen_backend,\n-        )\n+        run_compiler(self.at_args, self.callbacks, self.file_loader, self.make_codegen_backend)\n     }\n }\n+\n fn run_compiler(\n     at_args: &[String],\n     callbacks: &mut (dyn Callbacks + Send),\n     file_loader: Option<Box<dyn FileLoader + Send + Sync>>,\n-    emitter: Option<Box<dyn Write + Send>>,\n     make_codegen_backend: Option<\n         Box<dyn FnOnce(&config::Options) -> Box<dyn CodegenBackend> + Send>,\n     >,\n ) -> interface::Result<()> {\n     let args = args::arg_expand_all(at_args);\n \n-    let diagnostic_output = emitter.map_or(DiagnosticOutput::Default, DiagnosticOutput::Raw);\n     let Some(matches) = handle_options(&args) else { return Ok(()) };\n \n     let sopts = config::build_session_options(&matches);\n@@ -231,7 +222,6 @@ fn run_compiler(\n         output_file: ofile,\n         output_dir: odir,\n         file_loader,\n-        diagnostic_output,\n         lint_caps: Default::default(),\n         parse_sess_created: None,\n         register_lints: None,\n@@ -742,6 +732,11 @@ fn print_crate_info(\n                     println!(\"{}\", cfg);\n                 }\n             }\n+            CallingConventions => {\n+                let mut calling_conventions = rustc_target::spec::abi::all_names();\n+                calling_conventions.sort_unstable();\n+                println!(\"{}\", calling_conventions.join(\"\\n\"));\n+            }\n             RelocationModels\n             | CodeModels\n             | TlsModels"}, {"sha": "f9b1316d2eb5f632da4474ae56720ff1881cbf40", "filename": "compiler/rustc_driver/src/pretty.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_driver%2Fsrc%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_driver%2Fsrc%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_driver%2Fsrc%2Fpretty.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "patch": "@@ -329,7 +329,7 @@ impl<'tcx> pprust_hir::PpAnn for TypedAnnotation<'tcx> {\n             let typeck_results = self.maybe_typeck_results.get().or_else(|| {\n                 self.tcx\n                     .hir()\n-                    .maybe_body_owned_by(expr.hir_id.owner)\n+                    .maybe_body_owned_by(expr.hir_id.owner.def_id)\n                     .map(|body_id| self.tcx.typeck_body(body_id))\n             });\n \n@@ -502,7 +502,7 @@ fn print_with_analysis(\n \n         ThirTree => {\n             let mut out = String::new();\n-            abort_on_err(rustc_typeck::check_crate(tcx), tcx.sess);\n+            abort_on_err(rustc_hir_analysis::check_crate(tcx), tcx.sess);\n             debug!(\"pretty printing THIR tree\");\n             for did in tcx.hir().body_owners() {\n                 let _ = writeln!("}, {"sha": "1e86d159668ffe5d6b1bca194df8bb1a359c6d18", "filename": "compiler/rustc_error_codes/src/error_codes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "patch": "@@ -159,6 +159,7 @@ E0307: include_str!(\"./error_codes/E0307.md\"),\n E0308: include_str!(\"./error_codes/E0308.md\"),\n E0309: include_str!(\"./error_codes/E0309.md\"),\n E0310: include_str!(\"./error_codes/E0310.md\"),\n+E0311: include_str!(\"./error_codes/E0311.md\"),\n E0312: include_str!(\"./error_codes/E0312.md\"),\n E0316: include_str!(\"./error_codes/E0316.md\"),\n E0317: include_str!(\"./error_codes/E0317.md\"),\n@@ -568,7 +569,6 @@ E0790: include_str!(\"./error_codes/E0790.md\"),\n //  E0300, // unexpanded macro\n //  E0304, // expected signed integer constant\n //  E0305, // expected constant\n-    E0311, // thing may not live long enough\n     E0313, // lifetime of borrowed pointer outlives lifetime of captured\n            // variable\n //  E0314, // closure outlives stack frame"}, {"sha": "1cb214531e854cd5a2a2a38e77cec0f01b9f4ed5", "filename": "compiler/rustc_error_codes/src/error_codes/E0045.md", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0045.md", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0045.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0045.md?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "patch": "@@ -3,9 +3,7 @@ Variadic parameters have been used on a non-C ABI function.\n Erroneous code example:\n \n ```compile_fail,E0045\n-#![feature(unboxed_closures)]\n-\n-extern \"rust-call\" {\n+extern \"Rust\" {\n     fn foo(x: u8, ...); // error!\n }\n ```"}, {"sha": "5cbe2a188b02264eb8803471887ad20db31180d7", "filename": "compiler/rustc_error_codes/src/error_codes/E0092.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0092.md", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0092.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0092.md?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "patch": "@@ -19,6 +19,6 @@ functions are defined in `compiler/rustc_codegen_llvm/src/intrinsic.rs` and in\n #![feature(intrinsics)]\n \n extern \"rust-intrinsic\" {\n-    fn atomic_fence(); // ok!\n+    fn atomic_fence_seqcst(); // ok!\n }\n ```"}, {"sha": "cc546bdbb3b353ecf242e618d6090ac9f59d6da9", "filename": "compiler/rustc_error_codes/src/error_codes/E0094.md", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0094.md", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0094.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0094.md?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "patch": "@@ -6,6 +6,7 @@ Erroneous code example:\n #![feature(intrinsics)]\n \n extern \"rust-intrinsic\" {\n+    #[rustc_safe_intrinsic]\n     fn size_of<T, U>() -> usize; // error: intrinsic has wrong number\n                                  //        of type parameters\n }\n@@ -19,6 +20,7 @@ Example:\n #![feature(intrinsics)]\n \n extern \"rust-intrinsic\" {\n+    #[rustc_safe_intrinsic]\n     fn size_of<T>() -> usize; // ok!\n }\n ```"}, {"sha": "643990ef1c75d59f6719dd5cb8ed78aeb38f1c13", "filename": "compiler/rustc_error_codes/src/error_codes/E0161.md", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0161.md", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0161.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0161.md?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "patch": "@@ -3,7 +3,6 @@ A value was moved whose size was not known at compile time.\n Erroneous code example:\n \n ```compile_fail,E0161\n-#![feature(box_syntax)]\n trait Bar {\n     fn f(self);\n }\n@@ -13,7 +12,7 @@ impl Bar for i32 {\n }\n \n fn main() {\n-    let b: Box<dyn Bar> = box (0 as i32);\n+    let b: Box<dyn Bar> = Box::new(0i32);\n     b.f();\n     // error: cannot move a value of type dyn Bar: the size of dyn Bar cannot\n     //        be statically determined\n@@ -27,8 +26,6 @@ either `&x` or `&mut x`. Since a reference has a fixed size, this lets you move\n it around as usual. Example:\n \n ```\n-#![feature(box_syntax)]\n-\n trait Bar {\n     fn f(&self);\n }\n@@ -38,7 +35,7 @@ impl Bar for i32 {\n }\n \n fn main() {\n-    let b: Box<dyn Bar> = box (0 as i32);\n+    let b: Box<dyn Bar> = Box::new(0i32);\n     b.f();\n     // ok!\n }"}, {"sha": "8c2462ebd9b86d87b40f7e64c67eb4fcbdf07fef", "filename": "compiler/rustc_error_codes/src/error_codes/E0211.md", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0211.md", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0211.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0211.md?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "patch": "@@ -7,6 +7,7 @@ used. Erroneous code examples:\n #![feature(intrinsics)]\n \n extern \"rust-intrinsic\" {\n+    #[rustc_safe_intrinsic]\n     fn size_of<T>(); // error: intrinsic has wrong type\n }\n \n@@ -42,6 +43,7 @@ For the first code example, please check the function definition. Example:\n #![feature(intrinsics)]\n \n extern \"rust-intrinsic\" {\n+    #[rustc_safe_intrinsic]\n     fn size_of<T>() -> usize; // ok!\n }\n ```"}, {"sha": "08159d3f469ac8bad44d7385ffa0ab41b3e710ad", "filename": "compiler/rustc_error_codes/src/error_codes/E0311.md", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0311.md", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0311.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0311.md?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "patch": "@@ -0,0 +1,42 @@\n+This error occurs when there is an unsatisfied outlives bound involving an\n+elided region and a generic type parameter or associated type.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0311\n+fn no_restriction<T>(x: &()) -> &() {\n+    with_restriction::<T>(x)\n+}\n+\n+fn with_restriction<'a, T: 'a>(x: &'a ()) -> &'a () {\n+    x\n+}\n+```\n+\n+Why doesn't this code compile? It helps to look at the lifetime bounds that are\n+automatically added by the compiler. For more details see the documentation for\n+[lifetime elision]( https://doc.rust-lang.org/reference/lifetime-elision.html).\n+\n+The compiler elides the lifetime of `x` and the return type to some arbitrary\n+lifetime `'anon` in `no_restriction()`. The only information available to the\n+compiler is that `'anon` is valid for the duration of the function. When\n+calling `with_restriction()`, the compiler requires the completely unrelated\n+type parameter `T` to outlive `'anon` because of the `T: 'a` bound in\n+`with_restriction()`. This causes an error because `T` is not required to\n+outlive `'anon` in `no_restriction()`.\n+\n+If `no_restriction()` were to use `&T` instead of `&()` as an argument, the\n+compiler would have added an implied bound, causing this to compile.\n+\n+This error can be resolved by explicitly naming the elided lifetime for `x` and\n+then explicily requiring that the generic parameter `T` outlives that lifetime:\n+\n+```\n+fn no_restriction<'a, T: 'a>(x: &'a ()) -> &'a () {\n+    with_restriction::<T>(x)\n+}\n+\n+fn with_restriction<'a, T: 'a>(x: &'a ()) -> &'a () {\n+    x\n+}\n+```"}, {"sha": "e7e6fb682566eb8a6430a97a6b93c6738c76dc56", "filename": "compiler/rustc_error_codes/src/error_codes/E0579.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0579.md", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0579.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0579.md?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "patch": "@@ -8,9 +8,9 @@ Erroneous code example:\n fn main() {\n     match 5u32 {\n         // This range is ok, albeit pointless.\n-        1 .. 2 => {}\n+        1..2 => {}\n         // This range is empty, and the compiler can tell.\n-        5 .. 5 => {} // error!\n+        5..5 => {} // error!\n     }\n }\n ```"}, {"sha": "6ed8370e8c1c7f64fec42dc1cc6ff3fcbda2024c", "filename": "compiler/rustc_error_codes/src/error_codes/E0591.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0591.md", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0591.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0591.md?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "patch": "@@ -53,8 +53,8 @@ unsafe {\n ```\n \n Here, transmute is being used to convert the types of the fn arguments.\n-This pattern is incorrect because, because the type of `foo` is a function\n-**item** (`typeof(foo)`), which is zero-sized, and the target type (`fn()`)\n+This pattern is incorrect because the type of `foo` is a function **item**\n+(`typeof(foo)`), which is zero-sized, and the target type (`fn()`)\n is a function pointer, which is not zero-sized.\n This pattern should be rewritten. There are a few possible ways to do this:\n "}, {"sha": "3ba3ed10e5c6272b5fb774c48e0aa739c2878b5c", "filename": "compiler/rustc_error_codes/src/error_codes/E0622.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0622.md", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0622.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0622.md?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "patch": "@@ -5,7 +5,7 @@ Erroneous code example:\n ```compile_fail,E0622\n #![feature(intrinsics)]\n extern \"rust-intrinsic\" {\n-    pub static breakpoint : fn(); // error: intrinsic must be a function\n+    pub static breakpoint: fn(); // error: intrinsic must be a function\n }\n \n fn main() { unsafe { breakpoint(); } }"}, {"sha": "a19d3ef96e9260f81c268ed243a0ed77da7fef91", "filename": "compiler/rustc_error_codes/src/error_codes/E0743.md", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0743.md", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0743.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0743.md?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "patch": "@@ -3,8 +3,6 @@ The C-variadic type `...` has been nested inside another type.\n Erroneous code example:\n \n ```compile_fail,E0743\n-#![feature(c_variadic)]\n-\n fn foo2(x: u8, y: &...) {} // error!\n ```\n "}, {"sha": "9945f337995d369fdafc8534713433470104e335", "filename": "compiler/rustc_error_messages/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_error_messages%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_error_messages%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2FCargo.toml?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "patch": "@@ -4,7 +4,6 @@ version = \"0.0.0\"\n edition = \"2021\"\n \n [lib]\n-doctest = false\n \n [dependencies]\n fluent-bundle = \"0.15.2\""}, {"sha": "03c88c6c0ebe56d29af6545a277a57b00143bec8", "filename": "compiler/rustc_error_messages/locales/en-US/ast_lowering.ftl", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fast_lowering.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fast_lowering.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fast_lowering.ftl?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "patch": "@@ -7,7 +7,9 @@ ast_lowering_use_angle_brackets = use angle brackets instead\n ast_lowering_invalid_abi =\n     invalid ABI: found `{$abi}`\n     .label = invalid ABI\n-    .help = valid ABIs: {$valid_abis}\n+    .note = invoke `{$command}` for a full list of supported calling conventions.\n+\n+ast_lowering_invalid_abi_suggestion = did you mean\n \n ast_lowering_assoc_ty_parentheses =\n     parenthesized generic arguments cannot be used in associated type constraints"}, {"sha": "178e1a67ccecff46fb28b1bfc715ec1cd0287fbf", "filename": "compiler/rustc_error_messages/locales/en-US/codegen_gcc.ftl", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fcodegen_gcc.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fcodegen_gcc.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fcodegen_gcc.ftl?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "patch": "@@ -0,0 +1,68 @@\n+codegen_gcc_ranlib_failure =\n+    Ranlib exited with code {$exit_code}\n+\n+codegen_gcc_linkage_const_or_mut_type =\n+    must have type `*const T` or `*mut T` due to `#[linkage]` attribute\n+\n+codegen_gcc_unwinding_inline_asm =\n+    GCC backend does not support unwinding from inline asm\n+\n+codegen_gcc_lto_not_supported =\n+    LTO is not supported. You may get a linker error.\n+\n+codegen_gcc_invalid_monomorphization_basic_integer =\n+    invalid monomorphization of `{$name}` intrinsic: expected basic integer type, found `{$ty}`\n+\n+codegen_gcc_invalid_monomorphization_invalid_float_vector =\n+    invalid monomorphization of `{$name}` intrinsic: unsupported element type `{$elem_ty}` of floating-point vector `{$vec_ty}`\n+\n+codegen_gcc_invalid_monomorphization_not_float =\n+    invalid monomorphization of `{$name}` intrinsic: `{$ty}` is not a floating-point type\n+\n+codegen_gcc_invalid_monomorphization_unrecognized =\n+    invalid monomorphization of `{$name}` intrinsic: unrecognized intrinsic `{$name}`\n+\n+codegen_gcc_invalid_monomorphization_expected_signed_unsigned =\n+    invalid monomorphization of `{$name}` intrinsic: expected element type `{$elem_ty}` of vector type `{$vec_ty}` to be a signed or unsigned integer type\n+\n+codegen_gcc_invalid_monomorphization_unsupported_element =\n+    invalid monomorphization of `{$name}` intrinsic: unsupported {$name} from `{$in_ty}` with element `{$elem_ty}` to `{$ret_ty}`\n+\n+codegen_gcc_invalid_monomorphization_invalid_bitmask =\n+    invalid monomorphization of `{$name}` intrinsic: invalid bitmask `{ty}`, expected `u{$expected_int_bits}` or `[u8; {$expected_bytes}]`\n+\n+codegen_gcc_invalid_monomorphization_simd_shuffle =\n+    invalid monomorphization of `{$name}` intrinsic: simd_shuffle index must be an array of `u32`, got `{$ty}`\n+\n+codegen_gcc_invalid_monomorphization_expected_simd =\n+    invalid monomorphization of `{$name}` intrinsic: expected SIMD {$expected_ty} type, found non-SIMD `{$found_ty}`\n+\n+codegen_gcc_invalid_monomorphization_mask_type =\n+    invalid monomorphization of `{$name}` intrinsic: mask element type is `{$ty}`, expected `i_`\n+\n+codegen_gcc_invalid_monomorphization_return_length =\n+    invalid monomorphization of `{$name}` intrinsic: expected return type of length {$in_len}, found `{$ret_ty}` with length {$out_len}\n+\n+codegen_gcc_invalid_monomorphization_return_length_input_type =\n+    invalid monomorphization of `{$name}` intrinsic: expected return type with length {$in_len} (same as input type `{$in_ty}`), found `{$ret_ty}` with length {$out_len}\n+\n+codegen_gcc_invalid_monomorphization_return_element =\n+    invalid monomorphization of `{$name}` intrinsic: expected return element type `{$in_elem}` (element of input `{$in_ty}`), found `{$ret_ty}` with element type `{$out_ty}`\n+\n+codegen_gcc_invalid_monomorphization_return_type =\n+    invalid monomorphization of `{$name}` intrinsic: expected return type `{$in_elem}` (element of input `{$in_ty}`), found `{$ret_ty}`\n+\n+codegen_gcc_invalid_monomorphization_inserted_type =\n+    invalid monomorphization of `{$name}` intrinsic: expected inserted type `{$in_elem}` (element of input `{$in_ty}`), found `{$out_ty}`\n+\n+codegen_gcc_invalid_monomorphization_return_integer_type =\n+    invalid monomorphization of `{$name}` intrinsic: expected return type with integer elements, found `{$ret_ty}` with non-integer `{$out_ty}`\n+\n+codegen_gcc_invalid_monomorphization_mismatched_lengths =\n+    invalid monomorphization of `{$name}` intrinsic: mismatched lengths: mask length `{$m_len}` != other vector length `{$v_len}`\n+\n+codegen_gcc_invalid_monomorphization_unsupported_cast =\n+    invalid monomorphization of `{$name}` intrinsic: unsupported cast from `{$in_ty}` with element `{$in_elem}` to `{$ret_ty}` with element `{$out_elem}`\n+\n+codegen_gcc_invalid_monomorphization_unsupported_operation =\n+    invalid monomorphization of `{$name}` intrinsic: unsupported operation on `{$in_ty}` with element `{$in_elem}`"}, {"sha": "0d0388a039e2d01a4cd2054eea6314a331fa8acc", "filename": "compiler/rustc_error_messages/locales/en-US/codegen_ssa.ftl", "status": "added", "additions": 119, "deletions": 0, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fcodegen_ssa.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fcodegen_ssa.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fcodegen_ssa.ftl?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "patch": "@@ -0,0 +1,119 @@\n+codegen_ssa_lib_def_write_failure = failed to write lib.def file: {$error}\n+\n+codegen_ssa_version_script_write_failure = failed to write version script: {$error}\n+\n+codegen_ssa_symbol_file_write_failure = failed to write symbols file: {$error}\n+\n+codegen_ssa_ld64_unimplemented_modifier = `as-needed` modifier not implemented yet for ld64\n+\n+codegen_ssa_linker_unsupported_modifier = `as-needed` modifier not supported for current linker\n+\n+codegen_ssa_L4Bender_exporting_symbols_unimplemented = exporting symbols not implemented yet for L4Bender\n+\n+codegen_ssa_no_natvis_directory = error enumerating natvis directory: {$error}\n+\n+codegen_ssa_copy_path = could not copy {$from} to {$to}: {$error}\n+\n+codegen_ssa_copy_path_buf = unable to copy {$source_file} to {$output_path}: {$error}\n+\n+codegen_ssa_ignoring_emit_path = ignoring emit path because multiple .{$extension} files were produced\n+\n+codegen_ssa_ignoring_output = ignoring -o because multiple .{$extension} files were produced\n+\n+codegen_ssa_create_temp_dir = couldn't create a temp dir: {$error}\n+\n+codegen_ssa_incompatible_linking_modifiers = the linking modifiers `+bundle` and `+whole-archive` are not compatible with each other when generating rlibs\n+\n+codegen_ssa_add_native_library = failed to add native library {$library_path}: {$error}\n+\n+codegen_ssa_multiple_external_func_decl = multiple declarations of external function `{$function}` from library `{$library_name}` have different calling conventions\n+\n+codegen_ssa_rlib_missing_format = could not find formats for rlibs\n+\n+codegen_ssa_rlib_only_rmeta_found = could not find rlib for: `{$crate_name}`, found rmeta (metadata) file\n+\n+codegen_ssa_rlib_not_found = could not find rlib for: `{$crate_name}`\n+\n+codegen_ssa_linking_failed = linking with `{$linker_path}` failed: {$exit_status}\n+\n+codegen_ssa_extern_funcs_not_found = some `extern` functions couldn't be found; some native libraries may need to be installed or have their path specified\n+\n+codegen_ssa_specify_libraries_to_link = use the `-l` flag to specify native libraries to link\n+\n+codegen_ssa_use_cargo_directive = use the `cargo:rustc-link-lib` directive to specify the native libraries to link with Cargo (see https://doc.rust-lang.org/cargo/reference/build-scripts.html#cargorustc-link-libkindname)\n+\n+codegen_ssa_thorin_read_input_failure = failed to read input file\n+\n+codegen_ssa_thorin_parse_input_file_kind = failed to parse input file kind\n+\n+codegen_ssa_thorin_parse_input_object_file = failed to parse input object file\n+\n+codegen_ssa_thorin_parse_input_archive_file = failed to parse input archive file\n+\n+codegen_ssa_thorin_parse_archive_member = failed to parse archive member\n+\n+codegen_ssa_thorin_invalid_input_kind = input is not an archive or elf object\n+\n+codegen_ssa_thorin_decompress_data = failed to decompress compressed section\n+\n+codegen_ssa_thorin_section_without_name = section without name at offset {$offset}\n+\n+codegen_ssa_thorin_relocation_with_invalid_symbol = relocation with invalid symbol for section `{$section}` at offset {$offset}\n+\n+codegen_ssa_thorin_multiple_relocations = multiple relocations for section `{$section}` at offset {$offset}\n+\n+codegen_ssa_thorin_unsupported_relocation = unsupported relocation for section {$section} at offset {$offset}\n+\n+codegen_ssa_thorin_missing_dwo_name = missing path attribute to DWARF object ({$id})\n+\n+codegen_ssa_thorin_no_compilation_units = input object has no compilation units\n+\n+codegen_ssa_thorin_no_die = no top-level debugging information entry in compilation/type unit\n+\n+codegen_ssa_thorin_top_level_die_not_unit = top-level debugging information entry is not a compilation/type unit\n+\n+codegen_ssa_thorin_missing_required_section = input object missing required section `{$section}`\n+\n+codegen_ssa_thorin_parse_unit_abbreviations = failed to parse unit abbreviations\n+\n+codegen_ssa_thorin_parse_unit_attribute = failed to parse unit attribute\n+\n+codegen_ssa_thorin_parse_unit_header = failed to parse unit header\n+\n+codegen_ssa_thorin_parse_unit = failed to parse unit\n+\n+codegen_ssa_thorin_incompatible_index_version = incompatible `{$section}` index version: found version {$actual}, expected version {$format}\n+\n+codegen_ssa_thorin_offset_at_index = read offset at index {$index} of `.debug_str_offsets.dwo` section\n+\n+codegen_ssa_thorin_str_at_offset = read string at offset {$offset} of `.debug_str.dwo` section\n+\n+codegen_ssa_thorin_parse_index = failed to parse `{$section}` index section\n+\n+codegen_ssa_thorin_unit_not_in_index = unit {$unit} from input package is not in its index\n+\n+codegen_ssa_thorin_row_not_in_index = row {$row} found in index's hash table not present in index\n+\n+codegen_ssa_thorin_section_not_in_row = section not found in unit's row in index\n+\n+codegen_ssa_thorin_empty_unit = unit {$unit} in input DWARF object with no data\n+\n+codegen_ssa_thorin_multiple_debug_info_section = multiple `.debug_info.dwo` sections\n+\n+codegen_ssa_thorin_multiple_debug_types_section = multiple `.debug_types.dwo` sections in a package\n+\n+codegen_ssa_thorin_not_split_unit = regular compilation unit in object (missing dwo identifier)\n+\n+codegen_ssa_thorin_duplicate_unit = duplicate split compilation unit ({$unit})\n+\n+codegen_ssa_thorin_missing_referenced_unit = unit {$unit} referenced by executable was not found\n+\n+codegen_ssa_thorin_not_output_object_created = no output object was created from inputs\n+\n+codegen_ssa_thorin_mixed_input_encodings = input objects haved mixed encodings\n+\n+codegen_ssa_thorin_io = {$error}\n+codegen_ssa_thorin_object_read = {$error}\n+codegen_ssa_thorin_object_write = {$error}\n+codegen_ssa_thorin_gimli_read = {$error}\n+codegen_ssa_thorin_gimli_write = {$error}"}, {"sha": "55061fbce7e4a8a6584e01ce8a03e998eab34e27", "filename": "compiler/rustc_error_messages/locales/en-US/compiletest.ftl", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fcompiletest.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fcompiletest.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fcompiletest.ftl?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "patch": "@@ -0,0 +1,5 @@\n+compiletest_example = this is an example message used in testing\n+    .note = with a note\n+    .help = with a help\n+    .suggestion = with a suggestion\n+    .label = with a label"}, {"sha": "429bdd2777f912db3e7d3d57a17a1ca7074207fc", "filename": "compiler/rustc_error_messages/locales/en-US/errors.ftl", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Ferrors.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Ferrors.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Ferrors.ftl?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "patch": "@@ -0,0 +1,13 @@\n+errors_target_invalid_address_space = invalid address space `{$addr_space}` for `{$cause}` in \"data-layout\": {$err}\n+\n+errors_target_invalid_bits = invalid {$kind} `{$bit}` for `{$cause}` in \"data-layout\": {$err}\n+\n+errors_target_missing_alignment = missing alignment for `{$cause}` in \"data-layout\"\n+\n+errors_target_invalid_alignment = invalid alignment for `{$cause}` in \"data-layout\": {$err}\n+\n+errors_target_inconsistent_architecture = inconsistent target specification: \"data-layout\" claims architecture is {$dl}-endian, while \"target-endian\" is `{$target}`\n+\n+errors_target_inconsistent_pointer_width = inconsistent target specification: \"data-layout\" claims pointers are {$pointer_size}-bit, while \"target-pointer-width\" is `{$target}`\n+\n+errors_target_invalid_bits_size = {$err}"}, {"sha": "357c6900a70e547c8256518532a688217cf31801", "filename": "compiler/rustc_error_messages/locales/en-US/hir_analysis.ftl", "status": "renamed", "additions": 36, "deletions": 32, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fhir_analysis.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fhir_analysis.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fhir_analysis.ftl?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "patch": "@@ -1,101 +1,101 @@\n-typeck_field_multiply_specified_in_initializer =\n+hir_analysis_field_multiply_specified_in_initializer =\n     field `{$ident}` specified more than once\n     .label = used more than once\n     .previous_use_label = first use of `{$ident}`\n \n-typeck_unrecognized_atomic_operation =\n+hir_analysis_unrecognized_atomic_operation =\n     unrecognized atomic operation function: `{$op}`\n     .label = unrecognized atomic operation\n \n-typeck_wrong_number_of_generic_arguments_to_intrinsic =\n+hir_analysis_wrong_number_of_generic_arguments_to_intrinsic =\n     intrinsic has wrong number of {$descr} parameters: found {$found}, expected {$expected}\n     .label = expected {$expected} {$descr} {$expected ->\n         [one] parameter\n         *[other] parameters\n     }\n \n-typeck_unrecognized_intrinsic_function =\n+hir_analysis_unrecognized_intrinsic_function =\n     unrecognized intrinsic function: `{$name}`\n     .label = unrecognized intrinsic\n \n-typeck_lifetimes_or_bounds_mismatch_on_trait =\n+hir_analysis_lifetimes_or_bounds_mismatch_on_trait =\n     lifetime parameters or bounds on {$item_kind} `{$ident}` do not match the trait declaration\n     .label = lifetimes do not match {$item_kind} in trait\n     .generics_label = lifetimes in impl do not match this {$item_kind} in trait\n \n-typeck_drop_impl_on_wrong_item =\n+hir_analysis_drop_impl_on_wrong_item =\n     the `Drop` trait may only be implemented for local structs, enums, and unions\n     .label = must be a struct, enum, or union in the current crate\n \n-typeck_field_already_declared =\n+hir_analysis_field_already_declared =\n     field `{$field_name}` is already declared\n     .label = field already declared\n     .previous_decl_label = `{$field_name}` first declared here\n \n-typeck_copy_impl_on_type_with_dtor =\n+hir_analysis_copy_impl_on_type_with_dtor =\n     the trait `Copy` may not be implemented for this type; the type has a destructor\n     .label = `Copy` not allowed on types with destructors\n \n-typeck_multiple_relaxed_default_bounds =\n+hir_analysis_multiple_relaxed_default_bounds =\n     type parameter has more than one relaxed default bound, only one is supported\n \n-typeck_copy_impl_on_non_adt =\n+hir_analysis_copy_impl_on_non_adt =\n     the trait `Copy` may not be implemented for this type\n     .label = type is not a structure or enumeration\n \n-typeck_trait_object_declared_with_no_traits =\n+hir_analysis_trait_object_declared_with_no_traits =\n     at least one trait is required for an object type\n     .alias_span = this alias does not contain a trait\n \n-typeck_ambiguous_lifetime_bound =\n+hir_analysis_ambiguous_lifetime_bound =\n     ambiguous lifetime bound, explicit lifetime bound required\n \n-typeck_assoc_type_binding_not_allowed =\n+hir_analysis_assoc_type_binding_not_allowed =\n     associated type bindings are not allowed here\n     .label = associated type not allowed here\n \n-typeck_functional_record_update_on_non_struct =\n+hir_analysis_functional_record_update_on_non_struct =\n     functional record update syntax requires a struct\n \n-typeck_typeof_reserved_keyword_used =\n+hir_analysis_typeof_reserved_keyword_used =\n     `typeof` is a reserved keyword but unimplemented\n     .suggestion = consider replacing `typeof(...)` with an actual type\n     .label = reserved keyword\n \n-typeck_return_stmt_outside_of_fn_body =\n+hir_analysis_return_stmt_outside_of_fn_body =\n     return statement outside of function body\n     .encl_body_label = the return is part of this body...\n     .encl_fn_label = ...not the enclosing function body\n \n-typeck_yield_expr_outside_of_generator =\n+hir_analysis_yield_expr_outside_of_generator =\n     yield expression outside of generator literal\n \n-typeck_struct_expr_non_exhaustive =\n+hir_analysis_struct_expr_non_exhaustive =\n     cannot create non-exhaustive {$what} using struct expression\n \n-typeck_method_call_on_unknown_type =\n+hir_analysis_method_call_on_unknown_type =\n     the type of this value must be known to call a method on a raw pointer on it\n \n-typeck_value_of_associated_struct_already_specified =\n+hir_analysis_value_of_associated_struct_already_specified =\n     the value of the associated type `{$item_name}` (from trait `{$def_path}`) is already specified\n     .label = re-bound here\n     .previous_bound_label = `{$item_name}` bound here first\n \n-typeck_address_of_temporary_taken = cannot take address of a temporary\n+hir_analysis_address_of_temporary_taken = cannot take address of a temporary\n     .label = temporary value\n \n-typeck_add_return_type_add = try adding a return type\n+hir_analysis_add_return_type_add = try adding a return type\n \n-typeck_add_return_type_missing_here = a return type might be missing here\n+hir_analysis_add_return_type_missing_here = a return type might be missing here\n \n-typeck_expected_default_return_type = expected `()` because of default return type\n+hir_analysis_expected_default_return_type = expected `()` because of default return type\n \n-typeck_expected_return_type = expected `{$expected}` because of return type\n+hir_analysis_expected_return_type = expected `{$expected}` because of return type\n \n-typeck_unconstrained_opaque_type = unconstrained opaque type\n+hir_analysis_unconstrained_opaque_type = unconstrained opaque type\n     .note = `{$name}` must be used in combination with a concrete type within the same module\n \n-typeck_missing_type_params =\n+hir_analysis_missing_type_params =\n     the type {$parameterCount ->\n         [one] parameter\n         *[other] parameters\n@@ -117,19 +117,23 @@ typeck_missing_type_params =\n     } to {$parameters}\n     .note = because of the default `Self` reference, type parameters must be specified on object types\n \n-typeck_manual_implementation =\n+hir_analysis_manual_implementation =\n     manual implementations of `{$trait_name}` are experimental\n     .label = manual implementations of `{$trait_name}` are experimental\n     .help = add `#![feature(unboxed_closures)]` to the crate attributes to enable\n \n-typeck_substs_on_overridden_impl = could not resolve substs on overridden impl\n+hir_analysis_substs_on_overridden_impl = could not resolve substs on overridden impl\n \n-typeck_unused_extern_crate =\n+hir_analysis_unused_extern_crate =\n     unused extern crate\n     .suggestion = remove it\n \n-typeck_extern_crate_not_idiomatic =\n+hir_analysis_extern_crate_not_idiomatic =\n     `extern crate` is not idiomatic in the new edition\n     .suggestion = convert it to a `{$msg_code}`\n \n-typeck_expected_used_symbol = expected `used`, `used(compiler)` or `used(linker)`\n+hir_analysis_expected_used_symbol = expected `used`, `used(compiler)` or `used(linker)`\n+\n+hir_analysis_missing_parentheses_in_range = can't call method `{$method_name}` on type `{$ty_str}`\n+\n+hir_analysis_add_missing_parentheses_in_range = you must surround the range in parentheses to call its `{$func_name}` function", "previous_filename": "compiler/rustc_error_messages/locales/en-US/typeck.ftl"}, {"sha": "7e28f22c0ba8b532d0a7e468c56a31446b9d7d0f", "filename": "compiler/rustc_error_messages/locales/en-US/lint.ftl", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Flint.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Flint.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Flint.ftl?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "patch": "@@ -433,3 +433,8 @@ lint_check_name_unknown_tool = unknown lint tool: `{$tool_name}`\n lint_check_name_warning = {$msg}\n \n lint_check_name_deprecated = lint name `{$lint_name}` is deprecated and does not have an effect anymore. Use: {$new_name}\n+\n+lint_opaque_hidden_inferred_bound = opaque type `{$ty}` does not satisfy its associated type bounds\n+    .specifically = this associated type bound is unsatisfied for `{$proj_ty}`\n+\n+lint_opaque_hidden_inferred_bound_sugg = add this bound"}, {"sha": "08e553d9f15896b7e473e12c26eaef6f9b740976", "filename": "compiler/rustc_error_messages/locales/en-US/metadata.ftl", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fmetadata.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fmetadata.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fmetadata.ftl?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "patch": "@@ -165,6 +165,8 @@ metadata_failed_write_error =\n metadata_missing_native_library =\n     could not find native static library `{$libname}`, perhaps an -L flag is missing?\n \n+metadata_only_provide_library_name = only provide the library name `{$suggested_name}`, not the full filename\n+\n metadata_failed_create_tempdir =\n     couldn't create a temp dir: {$err}\n "}, {"sha": "b9e4499d47f362ab5010ced819a5c6f67f8d16d3", "filename": "compiler/rustc_error_messages/locales/en-US/middle.ftl", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fmiddle.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fmiddle.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fmiddle.ftl?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "patch": "@@ -15,3 +15,15 @@ middle_previous_use_here =\n middle_limit_invalid =\n     `limit` must be a non-negative integer\n     .label = {$error_str}\n+\n+middle_const_eval_non_int =\n+    constant evaluation of enum discriminant resulted in non-integer\n+\n+middle_unknown_layout =\n+    the type `{$ty}` has an unknown layout\n+\n+middle_values_too_big =\n+    values of the type `{$ty}` are too big for the current architecture\n+\n+middle_cannot_be_normalized =\n+    unable to determine layout for `{$ty}` because `{$failure_ty}` cannot be normalized"}, {"sha": "13c368d1c58501ab6fbd011d3273985e8c29b6d9", "filename": "compiler/rustc_error_messages/locales/en-US/parser.ftl", "status": "modified", "additions": 211, "deletions": 0, "changes": 211, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fparser.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fparser.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fparser.ftl?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "patch": "@@ -71,6 +71,8 @@ parser_field_expression_with_generic = field expressions cannot have generic arg\n parser_macro_invocation_with_qualified_path = macros cannot use qualified paths\n \n parser_unexpected_token_after_label = expected `while`, `for`, `loop` or `{\"{\"}` after a label\n+    .suggestion_remove_label = consider removing the label\n+    .suggestion_enclose_in_block = consider enclosing expression in a block\n \n parser_require_colon_after_labeled_expression = labeled expression must be followed by `:`\n     .note = labels are used before loops and blocks, allowing e.g., `break 'label` to them\n@@ -158,3 +160,212 @@ parser_remove_let = expected pattern, found `let`\n \n parser_use_eq_instead = unexpected `==`\n     .suggestion = try using `=` instead\n+\n+parser_use_empty_block_not_semi = expected { \"`{}`\" }, found `;`\n+    .suggestion = try using { \"`{}`\" } instead\n+\n+parser_comparison_interpreted_as_generic =\n+    `<` is interpreted as a start of generic arguments for `{$type}`, not a comparison\n+    .label_args = interpreted as generic arguments\n+    .label_comparison = not interpreted as comparison\n+    .suggestion = try comparing the cast value\n+\n+parser_shift_interpreted_as_generic =\n+    `<<` is interpreted as a start of generic arguments for `{$type}`, not a shift\n+    .label_args = interpreted as generic arguments\n+    .label_comparison = not interpreted as shift\n+    .suggestion = try shifting the cast value\n+\n+parser_found_expr_would_be_stmt = expected expression, found `{$token}`\n+    .label = expected expression\n+\n+parser_leading_plus_not_supported = leading `+` is not supported\n+    .label = unexpected `+`\n+    .suggestion_remove_plus = try removing the `+`\n+\n+parser_parentheses_with_struct_fields = invalid `struct` delimiters or `fn` call arguments\n+    .suggestion_braces_for_struct = if `{$type}` is a struct, use braces as delimiters\n+    .suggestion_no_fields_for_fn = if `{$type}` is a function, use the arguments directly\n+\n+parser_labeled_loop_in_break = parentheses are required around this expression to avoid confusion with a labeled break expression\n+\n+parser_sugg_wrap_expression_in_parentheses = wrap the expression in parentheses\n+\n+parser_array_brackets_instead_of_braces = this is a block expression, not an array\n+    .suggestion = to make an array, use square brackets instead of curly braces\n+\n+parser_match_arm_body_without_braces = `match` arm body without braces\n+    .label_statements = {$num_statements ->\n+            [one] this statement is not surrounded by a body\n+           *[other] these statements are not surrounded by a body\n+        }\n+    .label_arrow = while parsing the `match` arm starting here\n+    .suggestion_add_braces = surround the {$num_statements ->\n+            [one] statement\n+           *[other] statements\n+        } with a body\n+    .suggestion_use_comma_not_semicolon = use a comma to end a `match` arm expression\n+\n+parser_struct_literal_not_allowed_here = struct literals are not allowed here\n+    .suggestion = surround the struct literal with parentheses\n+\n+parser_invalid_interpolated_expression = invalid interpolated expression\n+\n+parser_hexadecimal_float_literal_not_supported = hexadecimal float literal is not supported\n+parser_octal_float_literal_not_supported = octal float literal is not supported\n+parser_binary_float_literal_not_supported = binary float literal is not supported\n+parser_not_supported = not supported\n+\n+parser_invalid_literal_suffix = suffixes on {$kind} literals are invalid\n+    .label = invalid suffix `{$suffix}`\n+\n+parser_invalid_literal_suffix_on_tuple_index = suffixes on a tuple index are invalid\n+    .label = invalid suffix `{$suffix}`\n+    .tuple_exception_line_1 = `{$suffix}` is *temporarily* accepted on tuple index fields as it was incorrectly accepted on stable for a few releases\n+    .tuple_exception_line_2 = on proc macros, you'll want to use `syn::Index::from` or `proc_macro::Literal::*_unsuffixed` for code that will desugar to tuple field access\n+    .tuple_exception_line_3 = see issue #60210 <https://github.com/rust-lang/rust/issues/60210> for more information\n+\n+parser_non_string_abi_literal = non-string ABI literal\n+    .suggestion = specify the ABI with a string literal\n+\n+parser_mismatched_closing_delimiter = mismatched closing delimiter: `{$delimiter}`\n+    .label_unmatched = mismatched closing delimiter\n+    .label_opening_candidate = closing delimiter possibly meant for this\n+    .label_unclosed = unclosed delimiter\n+\n+parser_incorrect_visibility_restriction = incorrect visibility restriction\n+    .help = some possible visibility restrictions are:\n+            `pub(crate)`: visible only on the current crate\n+            `pub(super)`: visible only in the current module's parent\n+            `pub(in path::to::module)`: visible only on the specified path\n+    .suggestion = make this visible only to module `{$inner_str}` with `in`\n+\n+parser_assignment_else_not_allowed = <assignment> ... else {\"{\"} ... {\"}\"} is not allowed\n+\n+parser_expected_statement_after_outer_attr = expected statement after outer attribute\n+\n+parser_doc_comment_does_not_document_anything = found a documentation comment that doesn't document anything\n+    .help = doc comments must come before what they document, if a comment was intended use `//`\n+    .suggestion = missing comma here\n+\n+parser_const_let_mutually_exclusive = `const` and `let` are mutually exclusive\n+    .suggestion = remove `let`\n+\n+parser_invalid_expression_in_let_else = a `{$operator}` expression cannot be directly assigned in `let...else`\n+parser_invalid_curly_in_let_else = right curly brace `{\"}\"}` before `else` in a `let...else` statement not allowed\n+\n+parser_compound_assignment_expression_in_let = can't reassign to an uninitialized variable\n+    .suggestion = initialize the variable\n+    .help = if you meant to overwrite, remove the `let` binding\n+\n+parser_suffixed_literal_in_attribute = suffixed literals are not allowed in attributes\n+    .help = instead of using a suffixed literal (`1u8`, `1.0f32`, etc.), use an unsuffixed version (`1`, `1.0`, etc.)\n+\n+parser_invalid_meta_item = expected unsuffixed literal or identifier, found `{$token}`\n+\n+parser_label_inner_attr_does_not_annotate_this = the inner attribute doesn't annotate this {$item}\n+parser_sugg_change_inner_attr_to_outer = to annotate the {$item}, change the attribute from inner to outer style\n+\n+parser_inner_attr_not_permitted_after_outer_doc_comment = an inner attribute is not permitted following an outer doc comment\n+    .label_attr = not permitted following an outer doc comment\n+    .label_prev_doc_comment = previous doc comment\n+    .label_does_not_annotate_this = {parser_label_inner_attr_does_not_annotate_this}\n+    .sugg_change_inner_to_outer = {parser_sugg_change_inner_attr_to_outer}\n+\n+parser_inner_attr_not_permitted_after_outer_attr = an inner attribute is not permitted following an outer attribute\n+    .label_attr = not permitted following an outer attribute\n+    .label_prev_attr = previous outer attribute\n+    .label_does_not_annotate_this = {parser_label_inner_attr_does_not_annotate_this}\n+    .sugg_change_inner_to_outer = {parser_sugg_change_inner_attr_to_outer}\n+\n+parser_inner_attr_not_permitted = an inner attribute is not permitted in this context\n+    .label_does_not_annotate_this = {parser_label_inner_attr_does_not_annotate_this}\n+    .sugg_change_inner_to_outer = {parser_sugg_change_inner_attr_to_outer}\n+\n+parser_inner_attr_explanation = inner attributes, like `#![no_std]`, annotate the item enclosing them, and are usually found at the beginning of source files\n+parser_outer_attr_explanation = outer attributes, like `#[test]`, annotate the item following them\n+\n+parser_inner_doc_comment_not_permitted = expected outer doc comment\n+    .note = inner doc comments like this (starting with `//!` or `/*!`) can only appear before items\n+    .suggestion = you might have meant to write a regular comment\n+    .label_does_not_annotate_this = the inner doc comment doesn't annotate this {$item}\n+    .sugg_change_inner_to_outer = to annotate the {$item}, change the doc comment from inner to outer style\n+\n+parser_expected_identifier_found_reserved_identifier_str = expected identifier, found reserved identifier `{$token}`\n+parser_expected_identifier_found_keyword_str = expected identifier, found keyword `{$token}`\n+parser_expected_identifier_found_reserved_keyword_str = expected identifier, found reserved keyword `{$token}`\n+parser_expected_identifier_found_doc_comment_str = expected identifier, found doc comment `{$token}`\n+parser_expected_identifier_found_str = expected identifier, found `{$token}`\n+\n+parser_expected_identifier_found_reserved_identifier = expected identifier, found reserved identifier\n+parser_expected_identifier_found_keyword = expected identifier, found keyword\n+parser_expected_identifier_found_reserved_keyword = expected identifier, found reserved keyword\n+parser_expected_identifier_found_doc_comment = expected identifier, found doc comment\n+parser_expected_identifier = expected identifier\n+\n+parser_sugg_escape_to_use_as_identifier = escape `{$ident_name}` to use it as an identifier\n+\n+parser_sugg_remove_comma = remove this comma\n+\n+parser_expected_semi_found_reserved_identifier_str = expected `;`, found reserved identifier `{$token}`\n+parser_expected_semi_found_keyword_str = expected `;`, found keyword `{$token}`\n+parser_expected_semi_found_reserved_keyword_str = expected `;`, found reserved keyword `{$token}`\n+parser_expected_semi_found_doc_comment_str = expected `;`, found doc comment `{$token}`\n+parser_expected_semi_found_str = expected `;`, found `{$token}`\n+\n+parser_sugg_change_this_to_semi = change this to `;`\n+parser_sugg_add_semi = add `;` here\n+parser_label_unexpected_token = unexpected token\n+\n+parser_unmatched_angle_brackets = {$num_extra_brackets ->\n+        [one] unmatched angle bracket\n+       *[other] unmatched angle brackets\n+    }\n+    .suggestion = {$num_extra_brackets ->\n+            [one] remove extra angle bracket\n+           *[other] remove extra angle brackets\n+        }\n+\n+parser_generic_parameters_without_angle_brackets = generic parameters without surrounding angle brackets\n+    .suggestion = surround the type parameters with angle brackets\n+\n+parser_comparison_operators_cannot_be_chained = comparison operators cannot be chained\n+    .sugg_parentheses_for_function_args = or use `(...)` if you meant to specify fn arguments\n+    .sugg_split_comparison = split the comparison into two\n+    .sugg_parenthesize = parenthesize the comparison\n+parser_sugg_turbofish_syntax = use `::<...>` instead of `<...>` to specify lifetime, type, or const arguments\n+\n+parser_question_mark_in_type = invalid `?` in type\n+    .label = `?` is only allowed on expressions, not types\n+    .suggestion = if you meant to express that the type might not contain a value, use the `Option` wrapper type\n+\n+parser_unexpected_parentheses_in_for_head = unexpected parentheses surrounding `for` loop head\n+    .suggestion = remove parentheses in `for` loop\n+\n+parser_doc_comment_on_param_type = documentation comments cannot be applied to a function parameter's type\n+    .label = doc comments are not allowed here\n+\n+parser_attribute_on_param_type = attributes cannot be applied to a function parameter's type\n+    .label = attributes are not allowed here\n+\n+parser_pattern_method_param_without_body = patterns aren't allowed in methods without bodies\n+    .suggestion = give this argument a name or use an underscore to ignore it\n+\n+parser_self_param_not_first = unexpected `self` parameter in function\n+    .label = must be the first parameter of an associated function\n+\n+parser_const_generic_without_braces = expressions must be enclosed in braces to be used as const generic arguments\n+    .suggestion = enclose the `const` expression in braces\n+\n+parser_unexpected_const_param_declaration = unexpected `const` parameter declaration\n+    .label = expected a `const` expression, not a parameter declaration\n+    .suggestion = `const` parameters must be declared for the `impl`\n+\n+parser_unexpected_const_in_generic_param = expected lifetime, type, or constant, found keyword `const`\n+    .suggestion = the `const` keyword is only needed in the definition of the type\n+\n+parser_async_move_order_incorrect = the order of `move` and `async` is incorrect\n+    .suggestion = try switching the order\n+\n+parser_double_colon_in_bound = expected `:` followed by trait or lifetime\n+    .suggestion = use single colon"}, {"sha": "4bc6bd9fb220791c5a5664a45d8fb9b0b25ddc91", "filename": "compiler/rustc_error_messages/locales/en-US/passes.ftl", "status": "modified", "additions": 481, "deletions": 81, "changes": 562, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fpasses.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fpasses.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fpasses.ftl?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "patch": "@@ -10,119 +10,162 @@ passes_outer_crate_level_attr =\n passes_inner_crate_level_attr =\n     crate-level attribute should be in the root module\n \n-passes_ignored_attr_with_macro = `#[{$sym}]` is ignored on struct fields, match arms and macro defs\n+passes_ignored_attr_with_macro =\n+    `#[{$sym}]` is ignored on struct fields, match arms and macro defs\n     .warn = {-passes_previously_accepted}\n     .note = {-passes_see_issue(issue: \"80564\")}\n \n-passes_ignored_attr = `#[{$sym}]` is ignored on struct fields and match arms\n+passes_ignored_attr =\n+    `#[{$sym}]` is ignored on struct fields and match arms\n     .warn = {-passes_previously_accepted}\n     .note = {-passes_see_issue(issue: \"80564\")}\n \n-passes_inline_ignored_function_prototype = `#[inline]` is ignored on function prototypes\n+passes_inline_ignored_function_prototype =\n+    `#[inline]` is ignored on function prototypes\n \n-passes_inline_ignored_constants = `#[inline]` is ignored on constants\n+passes_inline_ignored_constants =\n+    `#[inline]` is ignored on constants\n     .warn = {-passes_previously_accepted}\n     .note = {-passes_see_issue(issue: \"65833\")}\n \n-passes_inline_not_fn_or_closure = attribute should be applied to function or closure\n+passes_inline_not_fn_or_closure =\n+    attribute should be applied to function or closure\n     .label = not a function or closure\n \n-passes_no_coverage_ignored_function_prototype = `#[no_coverage]` is ignored on function prototypes\n+passes_no_coverage_ignored_function_prototype =\n+    `#[no_coverage]` is ignored on function prototypes\n \n passes_no_coverage_propagate =\n     `#[no_coverage]` does not propagate into items and must be applied to the contained functions directly\n \n-passes_no_coverage_fn_defn = `#[no_coverage]` may only be applied to function definitions\n+passes_no_coverage_fn_defn =\n+    `#[no_coverage]` may only be applied to function definitions\n \n-passes_no_coverage_not_coverable = `#[no_coverage]` must be applied to coverable code\n+passes_no_coverage_not_coverable =\n+    `#[no_coverage]` must be applied to coverable code\n     .label = not coverable code\n \n-passes_should_be_applied_to_fn = attribute should be applied to a function definition\n+passes_should_be_applied_to_fn =\n+    attribute should be applied to a function definition\n     .label = not a function definition\n \n-passes_naked_tracked_caller = cannot use `#[track_caller]` with `#[naked]`\n+passes_naked_tracked_caller =\n+    cannot use `#[track_caller]` with `#[naked]`\n \n-passes_should_be_applied_to_struct_enum = attribute should be applied to a struct or enum\n+passes_should_be_applied_to_struct_enum =\n+    attribute should be applied to a struct or enum\n     .label = not a struct or enum\n \n-passes_should_be_applied_to_trait = attribute should be applied to a trait\n+passes_should_be_applied_to_trait =\n+    attribute should be applied to a trait\n     .label = not a trait\n \n-passes_target_feature_on_statement = {passes_should_be_applied_to_fn}\n+passes_target_feature_on_statement =\n+    {passes_should_be_applied_to_fn}\n     .warn = {-passes_previously_accepted}\n     .label = {passes_should_be_applied_to_fn.label}\n \n-passes_should_be_applied_to_static = attribute should be applied to a static\n+passes_should_be_applied_to_static =\n+    attribute should be applied to a static\n     .label = not a static\n \n-passes_doc_expect_str = doc {$attr_name} attribute expects a string: #[doc({$attr_name} = \"a\")]\n+passes_doc_expect_str =\n+    doc {$attr_name} attribute expects a string: #[doc({$attr_name} = \"a\")]\n \n-passes_doc_alias_empty = {$attr_str} attribute cannot have empty value\n+passes_doc_alias_empty =\n+    {$attr_str} attribute cannot have empty value\n \n-passes_doc_alias_bad_char = {$char_} character isn't allowed in {$attr_str}\n+passes_doc_alias_bad_char =\n+    {$char_} character isn't allowed in {$attr_str}\n \n-passes_doc_alias_start_end = {$attr_str} cannot start or end with ' '\n+passes_doc_alias_start_end =\n+    {$attr_str} cannot start or end with ' '\n \n-passes_doc_alias_bad_location = {$attr_str} isn't allowed on {$location}\n+passes_doc_alias_bad_location =\n+    {$attr_str} isn't allowed on {$location}\n \n-passes_doc_alias_not_an_alias = {$attr_str} is the same as the item's name\n+passes_doc_alias_not_an_alias =\n+    {$attr_str} is the same as the item's name\n \n passes_doc_alias_duplicated = doc alias is duplicated\n     .label = first defined here\n \n-passes_doc_alias_not_string_literal = `#[doc(alias(\"a\"))]` expects string literals\n+passes_doc_alias_not_string_literal =\n+    `#[doc(alias(\"a\"))]` expects string literals\n \n passes_doc_alias_malformed =\n     doc alias attribute expects a string `#[doc(alias = \"a\")]` or a list of strings `#[doc(alias(\"a\", \"b\"))]`\n \n-passes_doc_keyword_empty_mod = `#[doc(keyword = \"...\")]` should be used on empty modules\n+passes_doc_keyword_empty_mod =\n+    `#[doc(keyword = \"...\")]` should be used on empty modules\n \n-passes_doc_keyword_not_mod = `#[doc(keyword = \"...\")]` should be used on modules\n+passes_doc_keyword_not_mod =\n+    `#[doc(keyword = \"...\")]` should be used on modules\n \n-passes_doc_keyword_invalid_ident = `{$doc_keyword}` is not a valid identifier\n+passes_doc_keyword_invalid_ident =\n+    `{$doc_keyword}` is not a valid identifier\n \n passes_doc_fake_variadic_not_valid =\n     `#[doc(fake_variadic)]` must be used on the first of a set of tuple or fn pointer trait impls with varying arity\n \n-passes_doc_keyword_only_impl = `#[doc(keyword = \"...\")]` should be used on impl blocks\n+passes_doc_keyword_only_impl =\n+    `#[doc(keyword = \"...\")]` should be used on impl blocks\n \n-passes_doc_inline_conflict_first = this attribute...\n-passes_doc_inline_conflict_second = ...conflicts with this attribute\n-passes_doc_inline_conflict = conflicting doc inlining attributes\n+passes_doc_inline_conflict_first =\n+    this attribute...\n+\n+passes_doc_inline_conflict_second =\n+    {\".\"}..conflicts with this attribute\n+\n+passes_doc_inline_conflict =\n+    conflicting doc inlining attributes\n     .help = remove one of the conflicting attributes\n \n-passes_doc_inline_only_use = this attribute can only be applied to a `use` item\n+passes_doc_inline_only_use =\n+    this attribute can only be applied to a `use` item\n     .label = only applicable on `use` items\n     .not_a_use_item_label = not a `use` item\n     .note = read <https://doc.rust-lang.org/nightly/rustdoc/the-doc-attribute.html#inline-and-no_inline> for more information\n \n passes_doc_attr_not_crate_level =\n     `#![doc({$attr_name} = \"...\")]` isn't allowed as a crate-level attribute\n \n-passes_attr_crate_level = this attribute can only be applied at the crate level\n+passes_attr_crate_level =\n+    this attribute can only be applied at the crate level\n     .suggestion = to apply to the crate, use an inner attribute\n     .help = to apply to the crate, use an inner attribute\n     .note = read <https://doc.rust-lang.org/nightly/rustdoc/the-doc-attribute.html#at-the-crate-level> for more information\n \n-passes_doc_test_unknown = unknown `doc(test)` attribute `{$path}`\n+passes_doc_test_unknown =\n+    unknown `doc(test)` attribute `{$path}`\n+\n+passes_doc_test_takes_list =\n+    `#[doc(test(...)]` takes a list of attributes\n \n-passes_doc_test_takes_list = `#[doc(test(...)]` takes a list of attributes\n+passes_doc_primitive =\n+    `doc(primitive)` should never have been stable\n \n-passes_doc_primitive = `doc(primitive)` should never have been stable\n+passes_doc_cfg_hide_takes_list =\n+    `#[doc(cfg_hide(...)]` takes a list of attributes\n \n-passes_doc_test_unknown_any = unknown `doc` attribute `{$path}`\n+passes_doc_test_unknown_any =\n+    unknown `doc` attribute `{$path}`\n \n-passes_doc_test_unknown_spotlight = unknown `doc` attribute `{$path}`\n+passes_doc_test_unknown_spotlight =\n+    unknown `doc` attribute `{$path}`\n     .note = `doc(spotlight)` was renamed to `doc(notable_trait)`\n     .suggestion = use `notable_trait` instead\n     .no_op_note = `doc(spotlight)` is now a no-op\n \n-passes_doc_test_unknown_include = unknown `doc` attribute `{$path}`\n+passes_doc_test_unknown_include =\n+    unknown `doc` attribute `{$path}`\n     .suggestion = use `doc = include_str!` instead\n \n-passes_doc_invalid = invalid `doc` attribute\n+passes_doc_invalid =\n+    invalid `doc` attribute\n \n-passes_pass_by_value = `pass_by_value` attribute should be applied to a struct, enum or type alias\n+passes_pass_by_value =\n+    `pass_by_value` attribute should be applied to a struct, enum or type alias\n     .label = is not a struct, enum or type alias\n \n passes_allow_incoherent_impl =\n@@ -137,42 +180,54 @@ passes_must_use_async =\n     `must_use` attribute on `async` functions applies to the anonymous `Future` returned by the function, not the value within\n     .label = this attribute does nothing, the `Future`s returned by async functions are already `must_use`\n \n-passes_must_use_no_effect = `#[must_use]` has no effect when applied to {$article} {$target}\n+passes_must_use_no_effect =\n+    `#[must_use]` has no effect when applied to {$article} {$target}\n \n-passes_must_not_suspend = `must_not_suspend` attribute should be applied to a struct, enum, or trait\n+passes_must_not_suspend =\n+    `must_not_suspend` attribute should be applied to a struct, enum, or trait\n     .label = is not a struct, enum, or trait\n \n-passes_cold = {passes_should_be_applied_to_fn}\n+passes_cold =\n+    {passes_should_be_applied_to_fn}\n     .warn = {-passes_previously_accepted}\n     .label = {passes_should_be_applied_to_fn.label}\n \n-passes_link = attribute should be applied to an `extern` block with non-Rust ABI\n+passes_link =\n+    attribute should be applied to an `extern` block with non-Rust ABI\n     .warn = {-passes_previously_accepted}\n     .label = not an `extern` block\n \n-passes_link_name = attribute should be applied to a foreign function or static\n+passes_link_name =\n+    attribute should be applied to a foreign function or static\n     .warn = {-passes_previously_accepted}\n     .label = not a foreign function or static\n     .help = try `#[link(name = \"{$value}\")]` instead\n \n-passes_no_link = attribute should be applied to an `extern crate` item\n+passes_no_link =\n+    attribute should be applied to an `extern crate` item\n     .label = not an `extern crate` item\n \n-passes_export_name = attribute should be applied to a free function, impl method or static\n+passes_export_name =\n+    attribute should be applied to a free function, impl method or static\n     .label = not a free function, impl method or static\n \n-passes_rustc_layout_scalar_valid_range_not_struct = attribute should be applied to a struct\n+passes_rustc_layout_scalar_valid_range_not_struct =\n+    attribute should be applied to a struct\n     .label = not a struct\n \n-passes_rustc_layout_scalar_valid_range_arg = expected exactly one integer literal argument\n+passes_rustc_layout_scalar_valid_range_arg =\n+    expected exactly one integer literal argument\n \n-passes_rustc_legacy_const_generics_only = #[rustc_legacy_const_generics] functions must only have const generics\n+passes_rustc_legacy_const_generics_only =\n+    #[rustc_legacy_const_generics] functions must only have const generics\n     .label = non-const generic parameter\n \n-passes_rustc_legacy_const_generics_index = #[rustc_legacy_const_generics] must have one index for each generic parameter\n+passes_rustc_legacy_const_generics_index =\n+    #[rustc_legacy_const_generics] must have one index for each generic parameter\n     .label = generic parameters\n \n-passes_rustc_legacy_const_generics_index_exceed = index exceeds number of arguments\n+passes_rustc_legacy_const_generics_index_exceed =\n+    index exceeds number of arguments\n     .label = there {$arg_count ->\n         [one] is\n         *[other] are\n@@ -181,93 +236,438 @@ passes_rustc_legacy_const_generics_index_exceed = index exceeds number of argume\n         *[other] arguments\n     }\n \n-passes_rustc_legacy_const_generics_index_negative = arguments should be non-negative integers\n+passes_rustc_legacy_const_generics_index_negative =\n+    arguments should be non-negative integers\n \n-passes_rustc_dirty_clean = attribute requires -Z query-dep-graph to be enabled\n+passes_rustc_dirty_clean =\n+    attribute requires -Z query-dep-graph to be enabled\n \n-passes_link_section = attribute should be applied to a function or static\n+passes_link_section =\n+    attribute should be applied to a function or static\n     .warn = {-passes_previously_accepted}\n     .label = not a function or static\n \n-passes_no_mangle_foreign = `#[no_mangle]` has no effect on a foreign {$foreign_item_kind}\n+passes_no_mangle_foreign =\n+    `#[no_mangle]` has no effect on a foreign {$foreign_item_kind}\n     .warn = {-passes_previously_accepted}\n     .label = foreign {$foreign_item_kind}\n     .note = symbol names in extern blocks are not mangled\n     .suggestion = remove this attribute\n \n-passes_no_mangle = attribute should be applied to a free function, impl method or static\n+passes_no_mangle =\n+    attribute should be applied to a free function, impl method or static\n     .warn = {-passes_previously_accepted}\n     .label = not a free function, impl method or static\n \n-passes_repr_ident = meta item in `repr` must be an identifier\n+passes_repr_ident =\n+    meta item in `repr` must be an identifier\n \n-passes_repr_conflicting = conflicting representation hints\n+passes_repr_conflicting =\n+    conflicting representation hints\n \n-passes_used_static = attribute must be applied to a `static` variable\n+passes_used_static =\n+    attribute must be applied to a `static` variable\n \n-passes_used_compiler_linker = `used(compiler)` and `used(linker)` can't be used together\n+passes_used_compiler_linker =\n+    `used(compiler)` and `used(linker)` can't be used together\n \n-passes_allow_internal_unstable = attribute should be applied to a macro\n+passes_allow_internal_unstable =\n+    attribute should be applied to a macro\n     .label = not a macro\n \n-passes_debug_visualizer_placement = attribute should be applied to a module\n+passes_debug_visualizer_placement =\n+    attribute should be applied to a module\n \n-passes_debug_visualizer_invalid = invalid argument\n+passes_debug_visualizer_invalid =\n+    invalid argument\n     .note_1 = expected: `natvis_file = \"...\"`\n     .note_2 = OR\n     .note_3 = expected: `gdb_script_file = \"...\"`\n \n-passes_rustc_allow_const_fn_unstable = attribute should be applied to `const fn`\n+passes_debug_visualizer_unreadable =\n+    couldn't read {$file}: {$error}\n+\n+passes_rustc_allow_const_fn_unstable =\n+    attribute should be applied to `const fn`\n     .label = not a `const fn`\n \n-passes_rustc_std_internal_symbol = attribute should be applied to functions or statics\n+passes_rustc_std_internal_symbol =\n+    attribute should be applied to functions or statics\n     .label = not a function or static\n \n-passes_const_trait = attribute should be applied to a trait\n+passes_const_trait =\n+    attribute should be applied to a trait\n \n-passes_stability_promotable = attribute cannot be applied to an expression\n+passes_stability_promotable =\n+    attribute cannot be applied to an expression\n \n-passes_deprecated = attribute is ignored here\n+passes_deprecated =\n+    attribute is ignored here\n \n-passes_macro_use = `#[{$name}]` only has an effect on `extern crate` and modules\n+passes_macro_use =\n+    `#[{$name}]` only has an effect on `extern crate` and modules\n \n-passes_macro_export = `#[macro_export]` only has an effect on macro definitions\n+passes_macro_export =\n+    `#[macro_export]` only has an effect on macro definitions\n \n-passes_plugin_registrar = `#[plugin_registrar]` only has an effect on functions\n+passes_plugin_registrar =\n+    `#[plugin_registrar]` only has an effect on functions\n \n-passes_unused_empty_lints_note = attribute `{$name}` with an empty list has no effect\n+passes_unused_empty_lints_note =\n+    attribute `{$name}` with an empty list has no effect\n \n-passes_unused_no_lints_note = attribute `{$name}` without any lints has no effect\n+passes_unused_no_lints_note =\n+    attribute `{$name}` without any lints has no effect\n \n passes_unused_default_method_body_const_note =\n     `default_method_body_is_const` has been replaced with `#[const_trait]` on traits\n \n-passes_unused = unused attribute\n+passes_unused =\n+    unused attribute\n     .suggestion = remove this attribute\n \n-passes_non_exported_macro_invalid_attrs = attribute should be applied to function or closure\n+passes_non_exported_macro_invalid_attrs =\n+    attribute should be applied to function or closure\n     .label = not a function or closure\n \n-passes_unused_duplicate = unused attribute\n+passes_unused_duplicate =\n+    unused attribute\n     .suggestion = remove this attribute\n     .note = attribute also specified here\n     .warn = {-passes_previously_accepted}\n \n-passes_unused_multiple = multiple `{$name}` attributes\n+passes_unused_multiple =\n+    multiple `{$name}` attributes\n     .suggestion = remove this attribute\n     .note = attribute also specified here\n \n-passes_rustc_lint_opt_ty = `#[rustc_lint_opt_ty]` should be applied to a struct\n+passes_rustc_lint_opt_ty =\n+    `#[rustc_lint_opt_ty]` should be applied to a struct\n     .label = not a struct\n \n-passes_rustc_lint_opt_deny_field_access = `#[rustc_lint_opt_deny_field_access]` should be applied to a field\n+passes_rustc_lint_opt_deny_field_access =\n+    `#[rustc_lint_opt_deny_field_access]` should be applied to a field\n     .label = not a field\n \n-passes_link_ordinal = attribute should be applied to a foreign function or static\n+passes_link_ordinal =\n+    attribute should be applied to a foreign function or static\n     .label = not a foreign function or static\n \n-passes_collapse_debuginfo = `collapse_debuginfo` attribute should be applied to macro definitions\n+passes_collapse_debuginfo =\n+    `collapse_debuginfo` attribute should be applied to macro definitions\n     .label = not a macro definition\n \n-passes_deprecated_annotation_has_no_effect = this `#[deprecated]` annotation has no effect\n+passes_deprecated_annotation_has_no_effect =\n+    this `#[deprecated]` annotation has no effect\n     .suggestion = remove the unnecessary deprecation attribute\n+\n+passes_unknown_external_lang_item =\n+    unknown external lang item: `{$lang_item}`\n+\n+passes_missing_panic_handler =\n+    `#[panic_handler]` function required, but not found\n+\n+passes_alloc_func_required =\n+    `#[alloc_error_handler]` function required, but not found\n+\n+passes_missing_alloc_error_handler =\n+    use `#![feature(default_alloc_error_handler)]` for a default error handler\n+\n+passes_missing_lang_item =\n+    language item required, but not found: `{$name}`\n+    .note = this can occur when a binary crate with `#![no_std]` is compiled for a target where `{$name}` is defined in the standard library\n+    .help = you may be able to compile for a target that doesn't need `{$name}`, specify a target with `--target` or in `.cargo/config`\n+\n+passes_lang_item_on_incorrect_target =\n+    `{$name}` language item must be applied to a {$expected_target}\n+    .label = attribute should be applied to a {$expected_target}, not a {$actual_target}\n+\n+passes_unknown_lang_item =\n+    definition of an unknown language item: `{$name}`\n+    .label = definition of unknown language item `{$name}`\n+\n+passes_invalid_attr_at_crate_level =\n+    `{$name}` attribute cannot be used at crate level\n+    .suggestion = perhaps you meant to use an outer attribute\n+\n+passes_duplicate_diagnostic_item =\n+    duplicate diagnostic item found: `{$name}`.\n+\n+passes_duplicate_diagnostic_item_in_crate =\n+    duplicate diagnostic item in crate `{$crate_name}`: `{$name}`.\n+\n+passes_diagnostic_item_first_defined =\n+    the diagnostic item is first defined here\n+    .note = the diagnostic item is first defined in crate `{$orig_crate_name}`.\n+\n+passes_abi =\n+    abi: {$abi}\n+\n+passes_align =\n+    align: {$align}\n+\n+passes_size =\n+    size: {$size}\n+\n+passes_homogeneous_aggregate =\n+    homogeneous_aggregate: {$homogeneous_aggregate}\n+\n+passes_layout_of =\n+    layout_of({$normalized_ty}) = {$ty_layout}\n+\n+passes_unrecognized_field =\n+    unrecognized field name `{$name}`\n+\n+passes_layout =\n+    layout error: {$layout_error}\n+\n+passes_feature_stable_twice =\n+    feature `{$feature}` is declared stable since {$since}, but was previously declared stable since {$prev_since}\n+\n+passes_feature_previously_declared =\n+    feature `{$feature}` is declared {$declared}, but was previously declared {$prev_declared}\n+\n+passes_expr_not_allowed_in_context =\n+    {$expr} is not allowed in a `{$context}`\n+\n+passes_const_impl_const_trait =\n+    const `impl`s must be for traits marked with `#[const_trait]`\n+    .note = this trait must be annotated with `#[const_trait]`\n+\n+passes_break_non_loop =\n+    `break` with value from a `{$kind}` loop\n+    .label = can only break with a value inside `loop` or breakable block\n+    .label2 = you can't `break` with a value in a `{$kind}` loop\n+    .suggestion = use `break` on its own without a value inside this `{$kind}` loop\n+    .break_expr_suggestion = alternatively, you might have meant to use the available loop label\n+\n+passes_continue_labeled_block =\n+    `continue` pointing to a labeled block\n+    .label = labeled blocks cannot be `continue`'d\n+    .block_label = labeled block the `continue` points to\n+\n+passes_break_inside_closure =\n+    `{$name}` inside of a closure\n+    .label = cannot `{$name}` inside of a closure\n+    .closure_label = enclosing closure\n+\n+passes_break_inside_async_block =\n+    `{$name}` inside of an `async` block\n+    .label = cannot `{$name}` inside of an `async` block\n+    .async_block_label = enclosing `async` block\n+\n+passes_outside_loop =\n+    `{$name}` outside of a loop\n+    .label = cannot `{$name}` outside of a loop\n+\n+passes_unlabeled_in_labeled_block =\n+    unlabeled `{$cf_type}` inside of a labeled block\n+    .label = `{$cf_type}` statements that would diverge to or through a labeled block need to bear a label\n+\n+passes_unlabeled_cf_in_while_condition =\n+    `break` or `continue` with no label in the condition of a `while` loop\n+    .label = unlabeled `{$cf_type}` in the condition of a `while` loop\n+\n+passes_cannot_inline_naked_function =\n+    naked functions cannot be inlined\n+\n+passes_undefined_naked_function_abi =\n+    Rust ABI is unsupported in naked functions\n+\n+passes_no_patterns =\n+    patterns not allowed in naked function parameters\n+\n+passes_params_not_allowed =\n+    referencing function parameters is not allowed in naked functions\n+    .help = follow the calling convention in asm block to use parameters\n+\n+passes_naked_functions_asm_block =\n+    naked functions must contain a single asm block\n+    .label_multiple_asm = multiple asm blocks are unsupported in naked functions\n+    .label_non_asm = non-asm is unsupported in naked functions\n+\n+passes_naked_functions_operands =\n+    only `const` and `sym` operands are supported in naked functions\n+\n+passes_naked_functions_asm_options =\n+    asm options unsupported in naked functions: {$unsupported_options}\n+\n+passes_naked_functions_must_use_noreturn =\n+    asm in naked functions must use `noreturn` option\n+    .suggestion = consider specifying that the asm block is responsible for returning from the function\n+\n+passes_attr_only_on_main =\n+    `{$attr}` attribute can only be used on `fn main()`\n+\n+passes_attr_only_on_root_main =\n+    `{$attr}` attribute can only be used on root `fn main()`\n+\n+passes_attr_only_in_functions =\n+    `{$attr}` attribute can only be used on functions\n+\n+passes_multiple_rustc_main =\n+    multiple functions with a `#[rustc_main]` attribute\n+    .first = first `#[rustc_main]` function\n+    .additional = additional `#[rustc_main]` function\n+\n+passes_multiple_start_functions =\n+    multiple `start` functions\n+    .label = multiple `start` functions\n+    .previous = previous `#[start]` function here\n+\n+passes_extern_main =\n+    the `main` function cannot be declared in an `extern` block\n+\n+passes_unix_sigpipe_values =\n+    valid values for `#[unix_sigpipe = \"...\"]` are `inherit`, `sig_ign`, or `sig_dfl`\n+\n+passes_no_main_function =\n+    `main` function not found in crate `{$crate_name}`\n+    .here_is_main = here is a function named `main`\n+    .one_or_more_possible_main = you have one or more functions named `main` not defined at the crate level\n+    .consider_moving_main = consider moving the `main` function definitions\n+    .main_must_be_defined_at_crate = the main function must be defined at the crate level{$has_filename ->\n+        [true] {\" \"}(in `{$filename}`)\n+        *[false] {\"\"}\n+    }\n+    .consider_adding_main_to_file = consider adding a `main` function to `{$filename}`\n+    .consider_adding_main_at_crate = consider adding a `main` function at the crate level\n+    .teach_note = If you don't know the basics of Rust, you can go look to the Rust Book to get started: https://doc.rust-lang.org/book/\n+    .non_function_main = non-function item at `crate::main` is found\n+\n+passes_duplicate_lang_item =\n+    found duplicate lang item `{$lang_item_name}`\n+    .first_defined_span = the lang item is first defined here\n+    .first_defined_crate_depends = the lang item is first defined in crate `{$orig_crate_name}` (which `{$orig_dependency_of}` depends on)\n+    .first_defined_crate = the lang item is first defined in crate `{$orig_crate_name}`.\n+    .first_definition_local = first definition in the local crate (`{$orig_crate_name}`)\n+    .second_definition_local = second definition in the local crate (`{$crate_name}`)\n+    .first_definition_path = first definition in `{$orig_crate_name}` loaded from {$orig_path}\n+    .second_definition_path = second definition in `{$crate_name}` loaded from {$path}\n+\n+passes_duplicate_lang_item_crate =\n+    duplicate lang item in crate `{$crate_name}`: `{$lang_item_name}`.\n+    .first_defined_span = the lang item is first defined here\n+    .first_defined_crate_depends = the lang item is first defined in crate `{$orig_crate_name}` (which `{$orig_dependency_of}` depends on)\n+    .first_defined_crate = the lang item is first defined in crate `{$orig_crate_name}`.\n+    .first_definition_local = first definition in the local crate (`{$orig_crate_name}`)\n+    .second_definition_local = second definition in the local crate (`{$crate_name}`)\n+    .first_definition_path = first definition in `{$orig_crate_name}` loaded from {$orig_path}\n+    .second_definition_path = second definition in `{$crate_name}` loaded from {$path}\n+\n+passes_duplicate_lang_item_crate_depends =\n+    duplicate lang item in crate `{$crate_name}` (which `{$dependency_of}` depends on): `{$lang_item_name}`.\n+    .first_defined_span = the lang item is first defined here\n+    .first_defined_crate_depends = the lang item is first defined in crate `{$orig_crate_name}` (which `{$orig_dependency_of}` depends on)\n+    .first_defined_crate = the lang item is first defined in crate `{$orig_crate_name}`.\n+    .first_definition_local = first definition in the local crate (`{$orig_crate_name}`)\n+    .second_definition_local = second definition in the local crate (`{$crate_name}`)\n+    .first_definition_path = first definition in `{$orig_crate_name}` loaded from {$orig_path}\n+    .second_definition_path = second definition in `{$crate_name}` loaded from {$path}\n+\n+passes_incorrect_target =\n+    `{$name}` language item must be applied to a {$kind} with {$at_least ->\n+        [true] at least {$num}\n+        *[false] {$num}\n+    } generic {$num ->\n+        [one] argument\n+        *[other] arguments\n+    }\n+    .label = this {$kind} has {$actual_num} generic {$actual_num ->\n+        [one] argument\n+        *[other] arguments\n+    }\n+\n+passes_useless_assignment =\n+    useless assignment of {$is_field_assign ->\n+        [true] field\n+        *[false] variable\n+    } of type `{$ty}` to itself\n+\n+passes_only_has_effect_on =\n+    `#[{$attr_name}]` only has an effect on {$target_name ->\n+        [function] functions\n+        [module] modules\n+        [implementation_block] implementation blocks\n+        *[unspecified] (unspecified--this is a compiler bug)\n+    }\n+\n+passes_object_lifetime_err =\n+    {$repr}\n+\n+passes_unrecognized_repr_hint =\n+    unrecognized representation hint\n+    .help = valid reprs are `C`, `align`, `packed`, `transparent`, `simd`, `i8`, `u8`, `i16`, `u16`, `i32`, `u32`, `i64`, `u64`, `i128`, `u128`, `isize`, `usize`\n+\n+passes_attr_application_enum =\n+    attribute should be applied to an enum\n+    .label = not an enum\n+\n+passes_attr_application_struct =\n+    attribute should be applied to a struct\n+    .label = not a struct\n+\n+passes_attr_application_struct_union =\n+    attribute should be applied to a struct or union\n+    .label = not a struct or union\n+\n+passes_attr_application_struct_enum_union =\n+    attribute should be applied to a struct, enum, or union\n+    .label = not a struct, enum, or union\n+\n+passes_attr_application_struct_enum_function_union =\n+    attribute should be applied to a struct, enum, function, or union\n+    .label = not a struct, enum, function, or union\n+\n+passes_transparent_incompatible =\n+    transparent {$target} cannot have other repr hints\n+\n+passes_deprecated_attribute =\n+    deprecated attribute must be paired with either stable or unstable attribute\n+\n+passes_useless_stability =\n+    this stability annotation is useless\n+    .label = useless stability annotation\n+    .item = the stability attribute annotates this item\n+\n+passes_invalid_stability =\n+    invalid stability version found\n+    .label = invalid stability version\n+    .item = the stability attribute annotates this item\n+\n+passes_cannot_stabilize_deprecated =\n+    an API can't be stabilized after it is deprecated\n+    .label = invalid version\n+    .item = the stability attribute annotates this item\n+\n+passes_invalid_deprecation_version =\n+    invalid deprecation version found\n+    .label = invalid deprecation version\n+    .item = the stability attribute annotates this item\n+\n+passes_missing_stability_attr =\n+    {$descr} has missing stability attribute\n+\n+passes_missing_const_stab_attr =\n+    {$descr} has missing const stability attribute\n+\n+passes_trait_impl_const_stable =\n+    trait implementations cannot be const stable yet\n+    .note = see issue #67792 <https://github.com/rust-lang/rust/issues/67792> for more information\n+\n+passes_feature_only_on_nightly =\n+    `#![feature]` may not be used on the {$release_channel} release channel\n+\n+passes_unknown_feature =\n+    unknown feature `{$feature}`\n+\n+passes_implied_feature_not_exist =\n+    feature `{$implied_by}` implying `{$feature}` does not exist\n+\n+passes_duplicate_feature_err =\n+    the feature `{$feature}` has already been declared\n+\n+passes_missing_const_err =\n+    attributes `#[rustc_const_unstable]` and `#[rustc_const_stable]` require the function or method to be `const`\n+    .help = make the function or method const\n+    .label = attribute specified here"}, {"sha": "870e824039cb6a86abe94b83344c74dd327dbc1c", "filename": "compiler/rustc_error_messages/locales/en-US/query_system.ftl", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fquery_system.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fquery_system.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fquery_system.ftl?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "patch": "@@ -12,6 +12,8 @@ query_system_cycle_usage = cycle used when {$usage}\n \n query_system_cycle_stack_single = ...which immediately requires {$stack_bottom} again\n \n+query_system_cycle_stack_middle = ...which requires {$desc}...\n+\n query_system_cycle_stack_multiple = ...which again requires {$stack_bottom}, completing the cycle\n \n query_system_cycle_recursive_ty_alias = type aliases cannot be recursive"}, {"sha": "47127ea8e9ce8a5055fe2e6714c05cdbcf2bb10e", "filename": "compiler/rustc_error_messages/locales/en-US/session.ftl", "status": "modified", "additions": 2, "deletions": 14, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fsession.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fsession.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fsession.ftl?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "patch": "@@ -39,20 +39,6 @@ session_unstable_virtual_function_elimination = `-Zvirtual-function-elimination`\n \n session_unsupported_dwarf_version = requested DWARF version {$dwarf_version} is greater than 5\n \n-session_target_invalid_address_space = invalid address space `{$addr_space}` for `{$cause}` in \"data-layout\": {$err}\n-\n-session_target_invalid_bits = invalid {$kind} `{$bit}` for `{$cause}` in \"data-layout\": {$err}\n-\n-session_target_missing_alignment = missing alignment for `{$cause}` in \"data-layout\"\n-\n-session_target_invalid_alignment = invalid alignment for `{$cause}` in \"data-layout\": {$err}\n-\n-session_target_inconsistent_architecture = inconsistent target specification: \"data-layout\" claims architecture is {$dl}-endian, while \"target-endian\" is `{$target}`\n-\n-session_target_inconsistent_pointer_width = inconsistent target specification: \"data-layout\" claims pointers are {$pointer_size}-bit, while \"target-pointer-width\" is `{$target}`\n-\n-session_target_invalid_bits_size = {$err}\n-\n session_target_stack_protector_not_supported = `-Z stack-protector={$stack_protector}` is not supported for target {$target_triple} and will be ignored\n \n session_split_debuginfo_unstable_platform = `-Csplit-debuginfo={$debuginfo}` is unstable on this platform\n@@ -66,3 +52,5 @@ session_crate_name_invalid = crate names cannot start with a `-`, but `{$s}` has\n session_crate_name_empty = crate name must not be empty\n \n session_invalid_character_in_create_name = invalid character `{$character}` in crate name: `{$crate_name}`\n+\n+session_expr_parentheses_needed = parentheses are required to parse this as an expression"}, {"sha": "9465051dd103f5ea43b236d880081752d352f13c", "filename": "compiler/rustc_error_messages/src/lib.rs", "status": "modified", "additions": 52, "deletions": 21, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_error_messages%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_error_messages%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Fsrc%2Flib.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "patch": "@@ -35,32 +35,38 @@ pub use unic_langid::{langid, LanguageIdentifier};\n \n // Generates `DEFAULT_LOCALE_RESOURCES` static and `fluent_generated` module.\n fluent_messages! {\n+    // tidy-alphabetical-start\n     ast_lowering => \"../locales/en-US/ast_lowering.ftl\",\n     ast_passes => \"../locales/en-US/ast_passes.ftl\",\n     attr => \"../locales/en-US/attr.ftl\",\n     borrowck => \"../locales/en-US/borrowck.ftl\",\n     builtin_macros => \"../locales/en-US/builtin_macros.ftl\",\n+    codegen_gcc => \"../locales/en-US/codegen_gcc.ftl\",\n+    codegen_ssa => \"../locales/en-US/codegen_ssa.ftl\",\n+    compiletest => \"../locales/en-US/compiletest.ftl\",\n     const_eval => \"../locales/en-US/const_eval.ftl\",\n     driver => \"../locales/en-US/driver.ftl\",\n+    errors => \"../locales/en-US/errors.ftl\",\n     expand => \"../locales/en-US/expand.ftl\",\n-    session => \"../locales/en-US/session.ftl\",\n-    interface => \"../locales/en-US/interface.ftl\",\n+    hir_analysis => \"../locales/en-US/hir_analysis.ftl\",\n     infer => \"../locales/en-US/infer.ftl\",\n+    interface => \"../locales/en-US/interface.ftl\",\n     lint => \"../locales/en-US/lint.ftl\",\n+    metadata => \"../locales/en-US/metadata.ftl\",\n     middle => \"../locales/en-US/middle.ftl\",\n+    mir_dataflow => \"../locales/en-US/mir_dataflow.ftl\",\n     monomorphize => \"../locales/en-US/monomorphize.ftl\",\n-    metadata => \"../locales/en-US/metadata.ftl\",\n     parser => \"../locales/en-US/parser.ftl\",\n     passes => \"../locales/en-US/passes.ftl\",\n     plugin_impl => \"../locales/en-US/plugin_impl.ftl\",\n     privacy => \"../locales/en-US/privacy.ftl\",\n     query_system => \"../locales/en-US/query_system.ftl\",\n-    trait_selection => \"../locales/en-US/trait_selection.ftl\",\n     save_analysis => \"../locales/en-US/save_analysis.ftl\",\n-    ty_utils => \"../locales/en-US/ty_utils.ftl\",\n-    typeck => \"../locales/en-US/typeck.ftl\",\n-    mir_dataflow => \"../locales/en-US/mir_dataflow.ftl\",\n+    session => \"../locales/en-US/session.ftl\",\n     symbol_mangling => \"../locales/en-US/symbol_mangling.ftl\",\n+    trait_selection => \"../locales/en-US/trait_selection.ftl\",\n+    ty_utils => \"../locales/en-US/ty_utils.ftl\",\n+    // tidy-alphabetical-end\n }\n \n pub use fluent_generated::{self as fluent, DEFAULT_LOCALE_RESOURCES};\n@@ -274,6 +280,18 @@ pub enum SubdiagnosticMessage {\n     /// Non-translatable diagnostic message.\n     // FIXME(davidtwco): can a `Cow<'static, str>` be used here?\n     Str(String),\n+    /// Translatable message which has already been translated eagerly.\n+    ///\n+    /// Some diagnostics have repeated subdiagnostics where the same interpolated variables would\n+    /// be instantiated multiple times with different values. As translation normally happens\n+    /// immediately prior to emission, after the diagnostic and subdiagnostic derive logic has run,\n+    /// the setting of diagnostic arguments in the derived code will overwrite previous variable\n+    /// values and only the final value will be set when translation occurs - resulting in\n+    /// incorrect diagnostics. Eager translation results in translation for a subdiagnostic\n+    /// happening immediately after the subdiagnostic derive's logic has been run. This variant\n+    /// stores messages which have been translated eagerly.\n+    // FIXME(#100717): can a `Cow<'static, str>` be used here?\n+    Eager(String),\n     /// Identifier of a Fluent message. Instances of this variant are generated by the\n     /// `Subdiagnostic` derive.\n     FluentIdentifier(FluentId),\n@@ -301,8 +319,20 @@ impl<S: Into<String>> From<S> for SubdiagnosticMessage {\n #[rustc_diagnostic_item = \"DiagnosticMessage\"]\n pub enum DiagnosticMessage {\n     /// Non-translatable diagnostic message.\n-    // FIXME(davidtwco): can a `Cow<'static, str>` be used here?\n+    // FIXME(#100717): can a `Cow<'static, str>` be used here?\n     Str(String),\n+    /// Translatable message which has already been translated eagerly.\n+    ///\n+    /// Some diagnostics have repeated subdiagnostics where the same interpolated variables would\n+    /// be instantiated multiple times with different values. As translation normally happens\n+    /// immediately prior to emission, after the diagnostic and subdiagnostic derive logic has run,\n+    /// the setting of diagnostic arguments in the derived code will overwrite previous variable\n+    /// values and only the final value will be set when translation occurs - resulting in\n+    /// incorrect diagnostics. Eager translation results in translation for a subdiagnostic\n+    /// happening immediately after the subdiagnostic derive's logic has been run. This variant\n+    /// stores messages which have been translated eagerly.\n+    // FIXME(#100717): can a `Cow<'static, str>` be used here?\n+    Eager(String),\n     /// Identifier for a Fluent message (with optional attribute) corresponding to the diagnostic\n     /// message.\n     ///\n@@ -321,6 +351,7 @@ impl DiagnosticMessage {\n     pub fn with_subdiagnostic_message(&self, sub: SubdiagnosticMessage) -> Self {\n         let attr = match sub {\n             SubdiagnosticMessage::Str(s) => return DiagnosticMessage::Str(s),\n+            SubdiagnosticMessage::Eager(s) => return DiagnosticMessage::Eager(s),\n             SubdiagnosticMessage::FluentIdentifier(id) => {\n                 return DiagnosticMessage::FluentIdentifier(id, None);\n             }\n@@ -329,24 +360,12 @@ impl DiagnosticMessage {\n \n         match self {\n             DiagnosticMessage::Str(s) => DiagnosticMessage::Str(s.clone()),\n+            DiagnosticMessage::Eager(s) => DiagnosticMessage::Eager(s.clone()),\n             DiagnosticMessage::FluentIdentifier(id, _) => {\n                 DiagnosticMessage::FluentIdentifier(id.clone(), Some(attr))\n             }\n         }\n     }\n-\n-    /// Returns the `String` contained within the `DiagnosticMessage::Str` variant, assuming that\n-    /// this diagnostic message is of the legacy, non-translatable variety. Panics if this\n-    /// assumption does not hold.\n-    ///\n-    /// Don't use this - it exists to support some places that do comparison with diagnostic\n-    /// strings.\n-    pub fn expect_str(&self) -> &str {\n-        match self {\n-            DiagnosticMessage::Str(s) => s,\n-            _ => panic!(\"expected non-translatable diagnostic message\"),\n-        }\n-    }\n }\n \n /// `From` impl that enables existing diagnostic calls to functions which now take\n@@ -357,6 +376,17 @@ impl<S: Into<String>> From<S> for DiagnosticMessage {\n     }\n }\n \n+/// A workaround for \"good path\" ICEs when formatting types in disables lints.\n+///\n+/// Delays formatting until `.into(): DiagnosticMessage` is used.\n+pub struct DelayDm<F>(pub F);\n+\n+impl<F: FnOnce() -> String> From<DelayDm<F>> for DiagnosticMessage {\n+    fn from(DelayDm(f): DelayDm<F>) -> Self {\n+        DiagnosticMessage::from(f())\n+    }\n+}\n+\n /// Translating *into* a subdiagnostic message from a diagnostic message is a little strange - but\n /// the subdiagnostic functions (e.g. `span_label`) take a `SubdiagnosticMessage` and the\n /// subdiagnostic derive refers to typed identifiers that are `DiagnosticMessage`s, so need to be\n@@ -366,6 +396,7 @@ impl Into<SubdiagnosticMessage> for DiagnosticMessage {\n     fn into(self) -> SubdiagnosticMessage {\n         match self {\n             DiagnosticMessage::Str(s) => SubdiagnosticMessage::Str(s),\n+            DiagnosticMessage::Eager(s) => SubdiagnosticMessage::Eager(s),\n             DiagnosticMessage::FluentIdentifier(id, None) => {\n                 SubdiagnosticMessage::FluentIdentifier(id)\n             }"}, {"sha": "7803a0792e12c9c3c1ce5ccc1a76c8f689a5c43c", "filename": "compiler/rustc_errors/Cargo.toml", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_errors%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_errors%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2FCargo.toml?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "patch": "@@ -4,10 +4,11 @@ version = \"0.0.0\"\n edition = \"2021\"\n \n [lib]\n-doctest = false\n \n [dependencies]\n tracing = \"0.1\"\n+rustc_ast = { path = \"../rustc_ast\" }\n+rustc_ast_pretty = { path = \"../rustc_ast_pretty\" }\n rustc_error_messages = { path = \"../rustc_error_messages\" }\n rustc_serialize = { path = \"../rustc_serialize\" }\n rustc_span = { path = \"../rustc_span\" }"}, {"sha": "f14b8ee3254f33608b0bbe0b16c6374ec0c5ad9e", "filename": "compiler/rustc_errors/src/annotate_snippet_emitter_writer.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_errors%2Fsrc%2Fannotate_snippet_emitter_writer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_errors%2Fsrc%2Fannotate_snippet_emitter_writer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fannotate_snippet_emitter_writer.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "patch": "@@ -7,7 +7,7 @@\n \n use crate::emitter::FileWithAnnotatedLines;\n use crate::snippet::Line;\n-use crate::translation::Translate;\n+use crate::translation::{to_fluent_args, Translate};\n use crate::{\n     CodeSuggestion, Diagnostic, DiagnosticId, DiagnosticMessage, Emitter, FluentBundle,\n     LazyFallbackBundle, Level, MultiSpan, Style, SubDiagnostic,\n@@ -46,7 +46,7 @@ impl Translate for AnnotateSnippetEmitterWriter {\n impl Emitter for AnnotateSnippetEmitterWriter {\n     /// The entry point for the diagnostics generation\n     fn emit_diagnostic(&mut self, diag: &Diagnostic) {\n-        let fluent_args = self.to_fluent_args(diag.args());\n+        let fluent_args = to_fluent_args(diag.args());\n \n         let mut children = diag.children.clone();\n         let (mut primary_span, suggestions) = self.primary_span_formatted(&diag, &fluent_args);"}, {"sha": "518c59dba536605ca17b785e43f35e8a59aaad42", "filename": "compiler/rustc_errors/src/diagnostic.rs", "status": "modified", "additions": 55, "deletions": 142, "changes": 197, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "patch": "@@ -1,21 +1,17 @@\n use crate::snippet::Style;\n use crate::{\n-    CodeSuggestion, DiagnosticMessage, EmissionGuarantee, Level, LintDiagnosticBuilder, MultiSpan,\n+    CodeSuggestion, DiagnosticBuilder, DiagnosticMessage, EmissionGuarantee, Level, MultiSpan,\n     SubdiagnosticMessage, Substitution, SubstitutionPart, SuggestionStyle,\n };\n use rustc_data_structures::fx::FxHashMap;\n use rustc_error_messages::FluentValue;\n-use rustc_hir as hir;\n use rustc_lint_defs::{Applicability, LintExpectationId};\n use rustc_span::edition::LATEST_STABLE_EDITION;\n-use rustc_span::symbol::{Ident, MacroRulesNormalizedIdent, Symbol};\n-use rustc_span::{edition::Edition, Span, DUMMY_SP};\n-use rustc_target::spec::{PanicStrategy, SplitDebuginfo, StackProtector, TargetTriple};\n+use rustc_span::symbol::Symbol;\n+use rustc_span::{Span, DUMMY_SP};\n use std::borrow::Cow;\n use std::fmt;\n use std::hash::{Hash, Hasher};\n-use std::num::ParseIntError;\n-use std::path::{Path, PathBuf};\n \n /// Error type for `Diagnostic`'s `suggestions` field, indicating that\n /// `.disable_suggestions()` was called on the `Diagnostic`.\n@@ -25,7 +21,11 @@ pub struct SuggestionsDisabled;\n /// Simplified version of `FluentArg` that can implement `Encodable` and `Decodable`. Collection of\n /// `DiagnosticArg` are converted to `FluentArgs` (consuming the collection) at the start of\n /// diagnostic emission.\n-pub type DiagnosticArg<'source> = (Cow<'source, str>, DiagnosticArgValue<'source>);\n+pub type DiagnosticArg<'iter, 'source> =\n+    (&'iter DiagnosticArgName<'source>, &'iter DiagnosticArgValue<'source>);\n+\n+/// Name of a diagnostic argument.\n+pub type DiagnosticArgName<'source> = Cow<'source, str>;\n \n /// Simplified version of `FluentValue` that can implement `Encodable` and `Decodable`. Converted\n /// to a `FluentValue` by the emitter to be used in diagnostic translation.\n@@ -43,119 +43,6 @@ pub trait IntoDiagnosticArg {\n     fn into_diagnostic_arg(self) -> DiagnosticArgValue<'static>;\n }\n \n-pub struct DiagnosticArgFromDisplay<'a>(pub &'a dyn fmt::Display);\n-\n-impl IntoDiagnosticArg for DiagnosticArgFromDisplay<'_> {\n-    fn into_diagnostic_arg(self) -> DiagnosticArgValue<'static> {\n-        self.0.to_string().into_diagnostic_arg()\n-    }\n-}\n-\n-impl<'a> From<&'a dyn fmt::Display> for DiagnosticArgFromDisplay<'a> {\n-    fn from(t: &'a dyn fmt::Display) -> Self {\n-        DiagnosticArgFromDisplay(t)\n-    }\n-}\n-\n-impl<'a, T: fmt::Display> From<&'a T> for DiagnosticArgFromDisplay<'a> {\n-    fn from(t: &'a T) -> Self {\n-        DiagnosticArgFromDisplay(t)\n-    }\n-}\n-\n-macro_rules! into_diagnostic_arg_using_display {\n-    ($( $ty:ty ),+ $(,)?) => {\n-        $(\n-            impl IntoDiagnosticArg for $ty {\n-                fn into_diagnostic_arg(self) -> DiagnosticArgValue<'static> {\n-                    self.to_string().into_diagnostic_arg()\n-                }\n-            }\n-        )+\n-    }\n-}\n-\n-into_diagnostic_arg_using_display!(\n-    i8,\n-    u8,\n-    i16,\n-    u16,\n-    i32,\n-    u32,\n-    i64,\n-    u64,\n-    i128,\n-    u128,\n-    std::io::Error,\n-    std::num::NonZeroU32,\n-    hir::Target,\n-    Edition,\n-    Ident,\n-    MacroRulesNormalizedIdent,\n-    ParseIntError,\n-    StackProtector,\n-    &TargetTriple,\n-    SplitDebuginfo\n-);\n-\n-impl IntoDiagnosticArg for bool {\n-    fn into_diagnostic_arg(self) -> DiagnosticArgValue<'static> {\n-        if self {\n-            DiagnosticArgValue::Str(Cow::Borrowed(\"true\"))\n-        } else {\n-            DiagnosticArgValue::Str(Cow::Borrowed(\"false\"))\n-        }\n-    }\n-}\n-\n-impl IntoDiagnosticArg for char {\n-    fn into_diagnostic_arg(self) -> DiagnosticArgValue<'static> {\n-        DiagnosticArgValue::Str(Cow::Owned(format!(\"{:?}\", self)))\n-    }\n-}\n-\n-impl IntoDiagnosticArg for Symbol {\n-    fn into_diagnostic_arg(self) -> DiagnosticArgValue<'static> {\n-        self.to_ident_string().into_diagnostic_arg()\n-    }\n-}\n-\n-impl<'a> IntoDiagnosticArg for &'a str {\n-    fn into_diagnostic_arg(self) -> DiagnosticArgValue<'static> {\n-        self.to_string().into_diagnostic_arg()\n-    }\n-}\n-\n-impl IntoDiagnosticArg for String {\n-    fn into_diagnostic_arg(self) -> DiagnosticArgValue<'static> {\n-        DiagnosticArgValue::Str(Cow::Owned(self))\n-    }\n-}\n-\n-impl<'a> IntoDiagnosticArg for &'a Path {\n-    fn into_diagnostic_arg(self) -> DiagnosticArgValue<'static> {\n-        DiagnosticArgValue::Str(Cow::Owned(self.display().to_string()))\n-    }\n-}\n-\n-impl IntoDiagnosticArg for PathBuf {\n-    fn into_diagnostic_arg(self) -> DiagnosticArgValue<'static> {\n-        DiagnosticArgValue::Str(Cow::Owned(self.display().to_string()))\n-    }\n-}\n-\n-impl IntoDiagnosticArg for usize {\n-    fn into_diagnostic_arg(self) -> DiagnosticArgValue<'static> {\n-        DiagnosticArgValue::Number(self)\n-    }\n-}\n-\n-impl IntoDiagnosticArg for PanicStrategy {\n-    fn into_diagnostic_arg(self) -> DiagnosticArgValue<'static> {\n-        DiagnosticArgValue::Str(Cow::Owned(self.desc().to_string()))\n-    }\n-}\n-\n impl<'source> Into<FluentValue<'source>> for DiagnosticArgValue<'source> {\n     fn into(self) -> FluentValue<'source> {\n         match self {\n@@ -165,31 +52,37 @@ impl<'source> Into<FluentValue<'source>> for DiagnosticArgValue<'source> {\n     }\n }\n \n-impl IntoDiagnosticArg for hir::ConstContext {\n-    fn into_diagnostic_arg(self) -> DiagnosticArgValue<'static> {\n-        DiagnosticArgValue::Str(Cow::Borrowed(match self {\n-            hir::ConstContext::ConstFn => \"constant function\",\n-            hir::ConstContext::Static(_) => \"static\",\n-            hir::ConstContext::Const => \"constant\",\n-        }))\n-    }\n-}\n-\n /// Trait implemented by error types. This should not be implemented manually. Instead, use\n /// `#[derive(Subdiagnostic)]` -- see [rustc_macros::Subdiagnostic].\n #[cfg_attr(bootstrap, rustc_diagnostic_item = \"AddSubdiagnostic\")]\n #[cfg_attr(not(bootstrap), rustc_diagnostic_item = \"AddToDiagnostic\")]\n-pub trait AddToDiagnostic {\n+pub trait AddToDiagnostic\n+where\n+    Self: Sized,\n+{\n     /// Add a subdiagnostic to an existing diagnostic.\n-    fn add_to_diagnostic(self, diag: &mut Diagnostic);\n+    fn add_to_diagnostic(self, diag: &mut Diagnostic) {\n+        self.add_to_diagnostic_with(diag, |_, m| m);\n+    }\n+\n+    /// Add a subdiagnostic to an existing diagnostic where `f` is invoked on every message used\n+    /// (to optionally perform eager translation).\n+    fn add_to_diagnostic_with<F>(self, diag: &mut Diagnostic, f: F)\n+    where\n+        F: Fn(&mut Diagnostic, SubdiagnosticMessage) -> SubdiagnosticMessage;\n }\n \n /// Trait implemented by lint types. This should not be implemented manually. Instead, use\n /// `#[derive(LintDiagnostic)]` -- see [rustc_macros::LintDiagnostic].\n #[rustc_diagnostic_item = \"DecorateLint\"]\n pub trait DecorateLint<'a, G: EmissionGuarantee> {\n     /// Decorate and emit a lint.\n-    fn decorate_lint(self, diag: LintDiagnosticBuilder<'a, G>);\n+    fn decorate_lint<'b>(\n+        self,\n+        diag: &'b mut DiagnosticBuilder<'a, G>,\n+    ) -> &'b mut DiagnosticBuilder<'a, G>;\n+\n+    fn msg(&self) -> DiagnosticMessage;\n }\n \n #[must_use]\n@@ -204,7 +97,7 @@ pub struct Diagnostic {\n     pub span: MultiSpan,\n     pub children: Vec<SubDiagnostic>,\n     pub suggestions: Result<Vec<CodeSuggestion>, SuggestionsDisabled>,\n-    args: Vec<DiagnosticArg<'static>>,\n+    args: FxHashMap<DiagnosticArgName<'static>, DiagnosticArgValue<'static>>,\n \n     /// This is not used for highlighting or rendering any error message.  Rather, it can be used\n     /// as a sort key to sort a buffer of diagnostics.  By default, it is the primary span of\n@@ -296,7 +189,7 @@ impl Diagnostic {\n             span: MultiSpan::new(),\n             children: vec![],\n             suggestions: Ok(vec![]),\n-            args: vec![],\n+            args: Default::default(),\n             sort_span: DUMMY_SP,\n             is_lint: false,\n         }\n@@ -892,13 +785,30 @@ impl Diagnostic {\n         self\n     }\n \n-    /// Add a subdiagnostic from a type that implements `Subdiagnostic` - see\n-    /// [rustc_macros::Subdiagnostic].\n+    /// Add a subdiagnostic from a type that implements `Subdiagnostic` (see\n+    /// [rustc_macros::Subdiagnostic]).\n     pub fn subdiagnostic(&mut self, subdiagnostic: impl AddToDiagnostic) -> &mut Self {\n         subdiagnostic.add_to_diagnostic(self);\n         self\n     }\n \n+    /// Add a subdiagnostic from a type that implements `Subdiagnostic` (see\n+    /// [rustc_macros::Subdiagnostic]). Performs eager translation of any translatable messages\n+    /// used in the subdiagnostic, so suitable for use with repeated messages (i.e. re-use of\n+    /// interpolated variables).\n+    pub fn eager_subdiagnostic(\n+        &mut self,\n+        handler: &crate::Handler,\n+        subdiagnostic: impl AddToDiagnostic,\n+    ) -> &mut Self {\n+        subdiagnostic.add_to_diagnostic_with(self, |diag, msg| {\n+            let args = diag.args();\n+            let msg = diag.subdiagnostic_message_to_diagnostic_message(msg);\n+            handler.eagerly_translate(msg, args)\n+        });\n+        self\n+    }\n+\n     pub fn set_span<S: Into<MultiSpan>>(&mut self, sp: S) -> &mut Self {\n         self.span = sp.into();\n         if let Some(span) = self.span.primary_span() {\n@@ -931,16 +841,19 @@ impl Diagnostic {\n         self\n     }\n \n-    pub fn args(&self) -> &[DiagnosticArg<'static>] {\n-        &self.args\n+    // Exact iteration order of diagnostic arguments shouldn't make a difference to output because\n+    // they're only used in interpolation.\n+    #[allow(rustc::potential_query_instability)]\n+    pub fn args<'a>(&'a self) -> impl Iterator<Item = DiagnosticArg<'a, 'static>> {\n+        self.args.iter()\n     }\n \n     pub fn set_arg(\n         &mut self,\n         name: impl Into<Cow<'static, str>>,\n         arg: impl IntoDiagnosticArg,\n     ) -> &mut Self {\n-        self.args.push((name.into(), arg.into_diagnostic_arg()));\n+        self.args.insert(name.into(), arg.into_diagnostic_arg());\n         self\n     }\n \n@@ -951,7 +864,7 @@ impl Diagnostic {\n     /// Helper function that takes a `SubdiagnosticMessage` and returns a `DiagnosticMessage` by\n     /// combining it with the primary message of the diagnostic (if translatable, otherwise it just\n     /// passes the user's string along).\n-    fn subdiagnostic_message_to_diagnostic_message(\n+    pub(crate) fn subdiagnostic_message_to_diagnostic_message(\n         &self,\n         attr: impl Into<SubdiagnosticMessage>,\n     ) -> DiagnosticMessage {"}, {"sha": "9b41234dcfb6685dd77f705ba663d3a952566662", "filename": "compiler/rustc_errors/src/diagnostic_builder.rs", "status": "modified", "additions": 63, "deletions": 24, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic_builder.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "patch": "@@ -5,6 +5,7 @@ use crate::{\n };\n use crate::{Handler, Level, MultiSpan, StashKey};\n use rustc_lint_defs::Applicability;\n+use rustc_span::source_map::Spanned;\n \n use rustc_span::Span;\n use std::borrow::Cow;\n@@ -23,6 +24,18 @@ pub trait IntoDiagnostic<'a, T: EmissionGuarantee = ErrorGuaranteed> {\n     fn into_diagnostic(self, handler: &'a Handler) -> DiagnosticBuilder<'a, T>;\n }\n \n+impl<'a, T, E> IntoDiagnostic<'a, E> for Spanned<T>\n+where\n+    T: IntoDiagnostic<'a, E>,\n+    E: EmissionGuarantee,\n+{\n+    fn into_diagnostic(self, handler: &'a Handler) -> DiagnosticBuilder<'a, E> {\n+        let mut diag = self.node.into_diagnostic(handler);\n+        diag.set_span(self.span);\n+        diag\n+    }\n+}\n+\n /// Used for emitting structured error messages and other diagnostic information.\n ///\n /// If there is some state in a downstream crate you would like to\n@@ -242,6 +255,56 @@ impl EmissionGuarantee for () {\n     }\n }\n \n+/// Marker type which enables implementation of `create_note` and `emit_note` functions for\n+/// note-without-error struct diagnostics.\n+#[derive(Copy, Clone)]\n+pub struct Noted;\n+\n+impl<'a> DiagnosticBuilder<'a, Noted> {\n+    /// Convenience function for internal use, clients should use one of the\n+    /// `struct_*` methods on [`Handler`].\n+    pub(crate) fn new_note(handler: &'a Handler, message: impl Into<DiagnosticMessage>) -> Self {\n+        let diagnostic = Diagnostic::new_with_code(Level::Note, None, message);\n+        Self::new_diagnostic_note(handler, diagnostic)\n+    }\n+\n+    /// Creates a new `DiagnosticBuilder` with an already constructed\n+    /// diagnostic.\n+    pub(crate) fn new_diagnostic_note(handler: &'a Handler, diagnostic: Diagnostic) -> Self {\n+        debug!(\"Created new diagnostic\");\n+        Self {\n+            inner: DiagnosticBuilderInner {\n+                state: DiagnosticBuilderState::Emittable(handler),\n+                diagnostic: Box::new(diagnostic),\n+            },\n+            _marker: PhantomData,\n+        }\n+    }\n+}\n+\n+impl EmissionGuarantee for Noted {\n+    fn diagnostic_builder_emit_producing_guarantee(db: &mut DiagnosticBuilder<'_, Self>) -> Self {\n+        match db.inner.state {\n+            // First `.emit()` call, the `&Handler` is still available.\n+            DiagnosticBuilderState::Emittable(handler) => {\n+                db.inner.state = DiagnosticBuilderState::AlreadyEmittedOrDuringCancellation;\n+                handler.emit_diagnostic(&mut db.inner.diagnostic);\n+            }\n+            // `.emit()` was previously called, disallowed from repeating it.\n+            DiagnosticBuilderState::AlreadyEmittedOrDuringCancellation => {}\n+        }\n+\n+        Noted\n+    }\n+\n+    fn make_diagnostic_builder(\n+        handler: &Handler,\n+        msg: impl Into<DiagnosticMessage>,\n+    ) -> DiagnosticBuilder<'_, Self> {\n+        DiagnosticBuilder::new_note(handler, msg)\n+    }\n+}\n+\n impl<'a> DiagnosticBuilder<'a, !> {\n     /// Convenience function for internal use, clients should use one of the\n     /// `struct_*` methods on [`Handler`].\n@@ -629,27 +692,3 @@ macro_rules! struct_span_err {\n macro_rules! error_code {\n     ($code:ident) => {{ $crate::DiagnosticId::Error(stringify!($code).to_owned()) }};\n }\n-\n-/// Wrapper around a `DiagnosticBuilder` for creating lints.\n-pub struct LintDiagnosticBuilder<'a, G: EmissionGuarantee>(DiagnosticBuilder<'a, G>);\n-\n-impl<'a, G: EmissionGuarantee> LintDiagnosticBuilder<'a, G> {\n-    #[rustc_lint_diagnostics]\n-    /// Return the inner `DiagnosticBuilder`, first setting the primary message to `msg`.\n-    pub fn build(mut self, msg: impl Into<DiagnosticMessage>) -> DiagnosticBuilder<'a, G> {\n-        self.0.set_primary_message(msg);\n-        self.0.set_is_lint();\n-        self.0\n-    }\n-\n-    /// Create a `LintDiagnosticBuilder` from some existing `DiagnosticBuilder`.\n-    pub fn new(err: DiagnosticBuilder<'a, G>) -> LintDiagnosticBuilder<'a, G> {\n-        LintDiagnosticBuilder(err)\n-    }\n-}\n-\n-impl<'a> LintDiagnosticBuilder<'a, ErrorGuaranteed> {\n-    pub fn forget_guarantee(self) -> LintDiagnosticBuilder<'a, ()> {\n-        LintDiagnosticBuilder(self.0.forget_guarantee())\n-    }\n-}"}, {"sha": "860f24871bcdc25471176c1d7bac732ae16d7795", "filename": "compiler/rustc_errors/src/diagnostic_impls.rs", "status": "added", "additions": 207, "deletions": 0, "changes": 207, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic_impls.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "patch": "@@ -0,0 +1,207 @@\n+use crate::{\n+    fluent, DiagnosticArgValue, DiagnosticBuilder, Handler, IntoDiagnostic, IntoDiagnosticArg,\n+};\n+use rustc_target::abi::TargetDataLayoutErrors;\n+use rustc_target::spec::{PanicStrategy, SplitDebuginfo, StackProtector, TargetTriple};\n+\n+use rustc_ast as ast;\n+use rustc_ast_pretty::pprust;\n+use rustc_hir as hir;\n+use rustc_span::edition::Edition;\n+use rustc_span::symbol::{Ident, MacroRulesNormalizedIdent, Symbol};\n+use std::borrow::Cow;\n+use std::fmt;\n+use std::num::ParseIntError;\n+use std::path::{Path, PathBuf};\n+\n+pub struct DiagnosticArgFromDisplay<'a>(pub &'a dyn fmt::Display);\n+\n+impl IntoDiagnosticArg for DiagnosticArgFromDisplay<'_> {\n+    fn into_diagnostic_arg(self) -> DiagnosticArgValue<'static> {\n+        self.0.to_string().into_diagnostic_arg()\n+    }\n+}\n+\n+impl<'a> From<&'a dyn fmt::Display> for DiagnosticArgFromDisplay<'a> {\n+    fn from(t: &'a dyn fmt::Display) -> Self {\n+        DiagnosticArgFromDisplay(t)\n+    }\n+}\n+\n+impl<'a, T: fmt::Display> From<&'a T> for DiagnosticArgFromDisplay<'a> {\n+    fn from(t: &'a T) -> Self {\n+        DiagnosticArgFromDisplay(t)\n+    }\n+}\n+\n+macro_rules! into_diagnostic_arg_using_display {\n+    ($( $ty:ty ),+ $(,)?) => {\n+        $(\n+            impl IntoDiagnosticArg for $ty {\n+                fn into_diagnostic_arg(self) -> DiagnosticArgValue<'static> {\n+                    self.to_string().into_diagnostic_arg()\n+                }\n+            }\n+        )+\n+    }\n+}\n+\n+into_diagnostic_arg_using_display!(\n+    i8,\n+    u8,\n+    i16,\n+    u16,\n+    i32,\n+    u32,\n+    i64,\n+    u64,\n+    i128,\n+    u128,\n+    std::io::Error,\n+    std::num::NonZeroU32,\n+    hir::Target,\n+    Edition,\n+    Ident,\n+    MacroRulesNormalizedIdent,\n+    ParseIntError,\n+    StackProtector,\n+    &TargetTriple,\n+    SplitDebuginfo\n+);\n+\n+impl IntoDiagnosticArg for bool {\n+    fn into_diagnostic_arg(self) -> DiagnosticArgValue<'static> {\n+        if self {\n+            DiagnosticArgValue::Str(Cow::Borrowed(\"true\"))\n+        } else {\n+            DiagnosticArgValue::Str(Cow::Borrowed(\"false\"))\n+        }\n+    }\n+}\n+\n+impl IntoDiagnosticArg for char {\n+    fn into_diagnostic_arg(self) -> DiagnosticArgValue<'static> {\n+        DiagnosticArgValue::Str(Cow::Owned(format!(\"{:?}\", self)))\n+    }\n+}\n+\n+impl IntoDiagnosticArg for Symbol {\n+    fn into_diagnostic_arg(self) -> DiagnosticArgValue<'static> {\n+        self.to_ident_string().into_diagnostic_arg()\n+    }\n+}\n+\n+impl<'a> IntoDiagnosticArg for &'a str {\n+    fn into_diagnostic_arg(self) -> DiagnosticArgValue<'static> {\n+        self.to_string().into_diagnostic_arg()\n+    }\n+}\n+\n+impl IntoDiagnosticArg for String {\n+    fn into_diagnostic_arg(self) -> DiagnosticArgValue<'static> {\n+        DiagnosticArgValue::Str(Cow::Owned(self))\n+    }\n+}\n+\n+impl<'a> IntoDiagnosticArg for &'a Path {\n+    fn into_diagnostic_arg(self) -> DiagnosticArgValue<'static> {\n+        DiagnosticArgValue::Str(Cow::Owned(self.display().to_string()))\n+    }\n+}\n+\n+impl IntoDiagnosticArg for PathBuf {\n+    fn into_diagnostic_arg(self) -> DiagnosticArgValue<'static> {\n+        DiagnosticArgValue::Str(Cow::Owned(self.display().to_string()))\n+    }\n+}\n+\n+impl IntoDiagnosticArg for usize {\n+    fn into_diagnostic_arg(self) -> DiagnosticArgValue<'static> {\n+        DiagnosticArgValue::Number(self)\n+    }\n+}\n+\n+impl IntoDiagnosticArg for PanicStrategy {\n+    fn into_diagnostic_arg(self) -> DiagnosticArgValue<'static> {\n+        DiagnosticArgValue::Str(Cow::Owned(self.desc().to_string()))\n+    }\n+}\n+\n+impl IntoDiagnosticArg for hir::ConstContext {\n+    fn into_diagnostic_arg(self) -> DiagnosticArgValue<'static> {\n+        DiagnosticArgValue::Str(Cow::Borrowed(match self {\n+            hir::ConstContext::ConstFn => \"constant function\",\n+            hir::ConstContext::Static(_) => \"static\",\n+            hir::ConstContext::Const => \"constant\",\n+        }))\n+    }\n+}\n+\n+impl IntoDiagnosticArg for ast::Path {\n+    fn into_diagnostic_arg(self) -> DiagnosticArgValue<'static> {\n+        DiagnosticArgValue::Str(Cow::Owned(pprust::path_to_string(&self)))\n+    }\n+}\n+\n+impl IntoDiagnosticArg for ast::token::Token {\n+    fn into_diagnostic_arg(self) -> DiagnosticArgValue<'static> {\n+        DiagnosticArgValue::Str(pprust::token_to_string(&self))\n+    }\n+}\n+\n+impl IntoDiagnosticArg for ast::token::TokenKind {\n+    fn into_diagnostic_arg(self) -> DiagnosticArgValue<'static> {\n+        DiagnosticArgValue::Str(pprust::token_kind_to_string(&self))\n+    }\n+}\n+\n+impl IntoDiagnostic<'_, !> for TargetDataLayoutErrors<'_> {\n+    fn into_diagnostic(self, handler: &Handler) -> DiagnosticBuilder<'_, !> {\n+        let mut diag;\n+        match self {\n+            TargetDataLayoutErrors::InvalidAddressSpace { addr_space, err, cause } => {\n+                diag = handler.struct_fatal(fluent::errors::target_invalid_address_space);\n+                diag.set_arg(\"addr_space\", addr_space);\n+                diag.set_arg(\"cause\", cause);\n+                diag.set_arg(\"err\", err);\n+                diag\n+            }\n+            TargetDataLayoutErrors::InvalidBits { kind, bit, cause, err } => {\n+                diag = handler.struct_fatal(fluent::errors::target_invalid_bits);\n+                diag.set_arg(\"kind\", kind);\n+                diag.set_arg(\"bit\", bit);\n+                diag.set_arg(\"cause\", cause);\n+                diag.set_arg(\"err\", err);\n+                diag\n+            }\n+            TargetDataLayoutErrors::MissingAlignment { cause } => {\n+                diag = handler.struct_fatal(fluent::errors::target_missing_alignment);\n+                diag.set_arg(\"cause\", cause);\n+                diag\n+            }\n+            TargetDataLayoutErrors::InvalidAlignment { cause, err } => {\n+                diag = handler.struct_fatal(fluent::errors::target_invalid_alignment);\n+                diag.set_arg(\"cause\", cause);\n+                diag.set_arg(\"err\", err);\n+                diag\n+            }\n+            TargetDataLayoutErrors::InconsistentTargetArchitecture { dl, target } => {\n+                diag = handler.struct_fatal(fluent::errors::target_inconsistent_architecture);\n+                diag.set_arg(\"dl\", dl);\n+                diag.set_arg(\"target\", target);\n+                diag\n+            }\n+            TargetDataLayoutErrors::InconsistentTargetPointerWidth { pointer_size, target } => {\n+                diag = handler.struct_fatal(fluent::errors::target_inconsistent_pointer_width);\n+                diag.set_arg(\"pointer_size\", pointer_size);\n+                diag.set_arg(\"target\", target);\n+                diag\n+            }\n+            TargetDataLayoutErrors::InvalidBitsSize { err } => {\n+                diag = handler.struct_fatal(fluent::errors::target_invalid_bits_size);\n+                diag.set_arg(\"err\", err);\n+                diag\n+            }\n+        }\n+    }\n+}"}, {"sha": "cd6413bc3ec622de739180b0d7a012fa8619ebbb", "filename": "compiler/rustc_errors/src/emitter.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_errors%2Fsrc%2Femitter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_errors%2Fsrc%2Femitter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Femitter.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "patch": "@@ -14,7 +14,7 @@ use rustc_span::{FileLines, SourceFile, Span};\n \n use crate::snippet::{Annotation, AnnotationType, Line, MultilineAnnotation, Style, StyledString};\n use crate::styled_buffer::StyledBuffer;\n-use crate::translation::Translate;\n+use crate::translation::{to_fluent_args, Translate};\n use crate::{\n     CodeSuggestion, Diagnostic, DiagnosticId, DiagnosticMessage, FluentBundle, Handler,\n     LazyFallbackBundle, Level, MultiSpan, SubDiagnostic, SubstitutionHighlight, SuggestionStyle,\n@@ -535,7 +535,7 @@ impl Emitter for EmitterWriter {\n     }\n \n     fn emit_diagnostic(&mut self, diag: &Diagnostic) {\n-        let fluent_args = self.to_fluent_args(diag.args());\n+        let fluent_args = to_fluent_args(diag.args());\n \n         let mut children = diag.children.clone();\n         let (mut primary_span, suggestions) = self.primary_span_formatted(&diag, &fluent_args);"}, {"sha": "4cc7be47fc2c69c79d2d53c7f24cae7271cbde3f", "filename": "compiler/rustc_errors/src/json.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_errors%2Fsrc%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_errors%2Fsrc%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fjson.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "patch": "@@ -13,7 +13,7 @@ use rustc_span::source_map::{FilePathMapping, SourceMap};\n \n use crate::emitter::{Emitter, HumanReadableErrorType};\n use crate::registry::Registry;\n-use crate::translation::Translate;\n+use crate::translation::{to_fluent_args, Translate};\n use crate::DiagnosticId;\n use crate::{\n     CodeSuggestion, FluentBundle, LazyFallbackBundle, MultiSpan, SpanLabel, SubDiagnostic,\n@@ -312,7 +312,7 @@ struct UnusedExterns<'a, 'b, 'c> {\n \n impl Diagnostic {\n     fn from_errors_diagnostic(diag: &crate::Diagnostic, je: &JsonEmitter) -> Diagnostic {\n-        let args = je.to_fluent_args(diag.args());\n+        let args = to_fluent_args(diag.args());\n         let sugg = diag.suggestions.iter().flatten().map(|sugg| {\n             let translated_message = je.translate_message(&sugg.msg, &args);\n             Diagnostic {"}, {"sha": "9fafbe4bd407eb61d9dc847a5626adf601c55240", "filename": "compiler/rustc_errors/src/lib.rs", "status": "modified", "additions": 29, "deletions": 9, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_errors%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_errors%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Flib.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "patch": "@@ -7,7 +7,6 @@\n #![feature(if_let_guard)]\n #![feature(adt_const_params)]\n #![feature(let_chains)]\n-#![cfg_attr(bootstrap, feature(let_else))]\n #![feature(never_type)]\n #![feature(result_option_inspect)]\n #![feature(rustc_attrs)]\n@@ -31,7 +30,7 @@ use rustc_data_structures::stable_hasher::StableHasher;\n use rustc_data_structures::sync::{self, Lock, Lrc};\n use rustc_data_structures::AtomicRef;\n pub use rustc_error_messages::{\n-    fallback_fluent_bundle, fluent, fluent_bundle, DiagnosticMessage, FluentBundle,\n+    fallback_fluent_bundle, fluent, fluent_bundle, DelayDm, DiagnosticMessage, FluentBundle,\n     LanguageIdentifier, LazyFallbackBundle, MultiSpan, SpanLabel, SubdiagnosticMessage,\n     DEFAULT_LOCALE_RESOURCES,\n };\n@@ -52,6 +51,7 @@ use termcolor::{Color, ColorSpec};\n pub mod annotate_snippet_emitter_writer;\n mod diagnostic;\n mod diagnostic_builder;\n+mod diagnostic_impls;\n pub mod emitter;\n pub mod json;\n mod lock;\n@@ -63,13 +63,14 @@ pub mod translation;\n pub use diagnostic_builder::IntoDiagnostic;\n pub use snippet::Style;\n \n-pub type PResult<'a, T> = Result<T, DiagnosticBuilder<'a, ErrorGuaranteed>>;\n+pub type PErr<'a> = DiagnosticBuilder<'a, ErrorGuaranteed>;\n+pub type PResult<'a, T> = Result<T, PErr<'a>>;\n \n // `PResult` is used a lot. Make sure it doesn't unintentionally get bigger.\n-// (See also the comment on `DiagnosticBuilder`'s `diagnostic` field.)\n+// (See also the comment on `DiagnosticBuilderInner`'s `diagnostic` field.)\n #[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n rustc_data_structures::static_assert_size!(PResult<'_, ()>, 16);\n-#[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\", not(bootstrap)))]\n+#[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n rustc_data_structures::static_assert_size!(PResult<'_, bool>, 16);\n \n #[derive(Debug, PartialEq, Eq, Clone, Copy, Hash, Encodable, Decodable)]\n@@ -371,10 +372,11 @@ impl fmt::Display for ExplicitBug {\n impl error::Error for ExplicitBug {}\n \n pub use diagnostic::{\n-    AddToDiagnostic, DecorateLint, Diagnostic, DiagnosticArg, DiagnosticArgFromDisplay,\n-    DiagnosticArgValue, DiagnosticId, DiagnosticStyledString, IntoDiagnosticArg, SubDiagnostic,\n+    AddToDiagnostic, DecorateLint, Diagnostic, DiagnosticArg, DiagnosticArgValue, DiagnosticId,\n+    DiagnosticStyledString, IntoDiagnosticArg, SubDiagnostic,\n };\n-pub use diagnostic_builder::{DiagnosticBuilder, EmissionGuarantee, LintDiagnosticBuilder};\n+pub use diagnostic_builder::{DiagnosticBuilder, EmissionGuarantee, Noted};\n+pub use diagnostic_impls::DiagnosticArgFromDisplay;\n use std::backtrace::Backtrace;\n \n /// A handler deals with errors and other compiler output.\n@@ -411,7 +413,7 @@ struct HandlerInner {\n     /// would be unnecessary repetition.\n     taught_diagnostics: FxHashSet<DiagnosticId>,\n \n-    /// Used to suggest rustc --explain <error code>\n+    /// Used to suggest rustc --explain `<error code>`\n     emitted_diagnostic_codes: FxIndexSet<DiagnosticId>,\n \n     /// This set contains a hash of every diagnostic that has been emitted by\n@@ -460,6 +462,7 @@ pub enum StashKey {\n     ItemNoType,\n     UnderscoreForArrayLengths,\n     EarlySyntaxWarning,\n+    CallIntoMethod,\n }\n \n fn default_track_diagnostic(_: &Diagnostic) {}\n@@ -597,6 +600,17 @@ impl Handler {\n         }\n     }\n \n+    /// Translate `message` eagerly with `args`.\n+    pub fn eagerly_translate<'a>(\n+        &self,\n+        message: DiagnosticMessage,\n+        args: impl Iterator<Item = DiagnosticArg<'a, 'static>>,\n+    ) -> SubdiagnosticMessage {\n+        let inner = self.inner.borrow();\n+        let args = crate::translation::to_fluent_args(args);\n+        SubdiagnosticMessage::Eager(inner.emitter.translate_message(&message, &args).to_string())\n+    }\n+\n     // This is here to not allow mutation of flags;\n     // as of this writing it's only used in tests in librustc_middle.\n     pub fn can_emit_warnings(&self) -> bool {\n@@ -1134,6 +1148,12 @@ impl Handler {\n         );\n         std::mem::take(&mut self.inner.borrow_mut().fulfilled_expectations)\n     }\n+\n+    pub fn flush_delayed(&self) {\n+        let mut inner = self.inner.lock();\n+        let bugs = std::mem::replace(&mut inner.delayed_span_bugs, Vec::new());\n+        inner.flush_delayed(bugs, \"no errors encountered even though `delay_span_bug` issued\");\n+    }\n }\n \n impl HandlerInner {"}, {"sha": "a7737b467b75bd89dc266a03a78c941b96cb76eb", "filename": "compiler/rustc_errors/src/translation.rs", "status": "modified", "additions": 24, "deletions": 10, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_errors%2Fsrc%2Ftranslation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_errors%2Fsrc%2Ftranslation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Ftranslation.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "patch": "@@ -4,6 +4,27 @@ use rustc_data_structures::sync::Lrc;\n use rustc_error_messages::FluentArgs;\n use std::borrow::Cow;\n \n+/// Convert diagnostic arguments (a rustc internal type that exists to implement\n+/// `Encodable`/`Decodable`) into `FluentArgs` which is necessary to perform translation.\n+///\n+/// Typically performed once for each diagnostic at the start of `emit_diagnostic` and then\n+/// passed around as a reference thereafter.\n+pub fn to_fluent_args<'iter, 'arg: 'iter>(\n+    iter: impl Iterator<Item = DiagnosticArg<'iter, 'arg>>,\n+) -> FluentArgs<'arg> {\n+    let mut args = if let Some(size) = iter.size_hint().1 {\n+        FluentArgs::with_capacity(size)\n+    } else {\n+        FluentArgs::new()\n+    };\n+\n+    for (k, v) in iter {\n+        args.set(k.clone(), v.clone());\n+    }\n+\n+    args\n+}\n+\n pub trait Translate {\n     /// Return `FluentBundle` with localized diagnostics for the locale requested by the user. If no\n     /// language was requested by the user then this will be `None` and `fallback_fluent_bundle`\n@@ -15,15 +36,6 @@ pub trait Translate {\n     /// unavailable for the requested locale.\n     fn fallback_fluent_bundle(&self) -> &FluentBundle;\n \n-    /// Convert diagnostic arguments (a rustc internal type that exists to implement\n-    /// `Encodable`/`Decodable`) into `FluentArgs` which is necessary to perform translation.\n-    ///\n-    /// Typically performed once for each diagnostic at the start of `emit_diagnostic` and then\n-    /// passed around as a reference thereafter.\n-    fn to_fluent_args<'arg>(&self, args: &[DiagnosticArg<'arg>]) -> FluentArgs<'arg> {\n-        FromIterator::from_iter(args.iter().cloned())\n-    }\n-\n     /// Convert `DiagnosticMessage`s to a string, performing translation if necessary.\n     fn translate_messages(\n         &self,\n@@ -43,7 +55,9 @@ pub trait Translate {\n     ) -> Cow<'_, str> {\n         trace!(?message, ?args);\n         let (identifier, attr) = match message {\n-            DiagnosticMessage::Str(msg) => return Cow::Borrowed(&msg),\n+            DiagnosticMessage::Str(msg) | DiagnosticMessage::Eager(msg) => {\n+                return Cow::Borrowed(&msg);\n+            }\n             DiagnosticMessage::FluentIdentifier(identifier, attr) => (identifier, attr),\n         };\n "}, {"sha": "0952e65cfee3d590b3643a1d2d96a33acfacd190", "filename": "compiler/rustc_expand/src/build.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_expand%2Fsrc%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_expand%2Fsrc%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fbuild.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "patch": "@@ -252,6 +252,10 @@ impl<'a> ExtCtxt<'a> {\n         self.expr_ident(span, Ident::with_dummy_span(kw::SelfLower))\n     }\n \n+    pub fn expr_field(&self, span: Span, expr: P<Expr>, field: Ident) -> P<ast::Expr> {\n+        self.expr(span, ast::ExprKind::Field(expr, field))\n+    }\n+\n     pub fn expr_binary(\n         &self,\n         sp: Span,"}, {"sha": "15e9a8db3c602490e02f88c619d9ae2ce46c56c5", "filename": "compiler/rustc_expand/src/expand.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "patch": "@@ -327,7 +327,7 @@ impl InvocationKind {\n     fn placeholder_visibility(&self) -> Option<ast::Visibility> {\n         // HACK: For unnamed fields placeholders should have the same visibility as the actual\n         // fields because for tuple structs/variants resolve determines visibilities of their\n-        // constructor using these field visibilities before attributes on them are are expanded.\n+        // constructor using these field visibilities before attributes on them are expanded.\n         // The assumption is that the attribute expansion cannot change field visibilities,\n         // and it holds because only inert attributes are supported in this position.\n         match self {\n@@ -937,13 +937,12 @@ pub fn ensure_complete_parse<'a>(\n             kind_name,\n         );\n         err.note(&msg);\n-        let semi_span = this.sess.source_map().next_point(span);\n \n-        let semi_full_span = semi_span.to(this.sess.source_map().next_point(semi_span));\n-        match this.sess.source_map().span_to_snippet(semi_full_span) {\n+        let semi_span = this.sess.source_map().next_point(span);\n+        match this.sess.source_map().span_to_snippet(semi_span) {\n             Ok(ref snippet) if &snippet[..] != \";\" && kind_name == \"expression\" => {\n                 err.span_suggestion(\n-                    semi_span,\n+                    span.shrink_to_hi(),\n                     \"you might be missing a semicolon here\",\n                     \";\",\n                     Applicability::MaybeIncorrect,"}, {"sha": "b34de94fb7db4a43579cf08200ccf1b0399d012b", "filename": "compiler/rustc_expand/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_expand%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_expand%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Flib.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "patch": "@@ -3,7 +3,6 @@\n #![feature(associated_type_defaults)]\n #![feature(if_let_guard)]\n #![feature(let_chains)]\n-#![cfg_attr(bootstrap, feature(let_else))]\n #![feature(macro_metavar_expr)]\n #![feature(proc_macro_diagnostic)]\n #![feature(proc_macro_internals)]"}, {"sha": "0aa2b44a0f87aed557c2dc0d42d3d969533a992c", "filename": "compiler/rustc_expand/src/mbe/macro_rules.rs", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "patch": "@@ -14,7 +14,7 @@ use rustc_ast::{NodeId, DUMMY_NODE_ID};\n use rustc_ast_pretty::pprust;\n use rustc_attr::{self as attr, TransparencyError};\n use rustc_data_structures::fx::{FxHashMap, FxIndexMap};\n-use rustc_errors::{Applicability, Diagnostic, DiagnosticBuilder};\n+use rustc_errors::{Applicability, Diagnostic, DiagnosticBuilder, DiagnosticMessage};\n use rustc_feature::Features;\n use rustc_lint_defs::builtin::{\n     RUST_2021_INCOMPATIBLE_OR_PATTERNS, SEMICOLON_IN_EXPRESSIONS_FROM_MACROS,\n@@ -68,19 +68,22 @@ fn emit_frag_parse_err(\n     kind: AstFragmentKind,\n ) {\n     // FIXME(davidtwco): avoid depending on the error message text\n-    if parser.token == token::Eof && e.message[0].0.expect_str().ends_with(\", found `<eof>`\") {\n-        if !e.span.is_dummy() {\n-            // early end of macro arm (#52866)\n-            e.replace_span_with(parser.sess.source_map().next_point(parser.token.span));\n-        }\n+    if parser.token == token::Eof\n+        && let DiagnosticMessage::Str(message) = &e.message[0].0\n+        && message.ends_with(\", found `<eof>`\")\n+    {\n         let msg = &e.message[0];\n         e.message[0] = (\n-            rustc_errors::DiagnosticMessage::Str(format!(\n+            DiagnosticMessage::Str(format!(\n                 \"macro expansion ends with an incomplete expression: {}\",\n-                msg.0.expect_str().replace(\", found `<eof>`\", \"\"),\n+                message.replace(\", found `<eof>`\", \"\"),\n             )),\n             msg.1,\n         );\n+        if !e.span.is_dummy() {\n+            // early end of macro arm (#52866)\n+            e.replace_span_with(parser.token.span.shrink_to_hi());\n+        }\n     }\n     if e.span.is_dummy() {\n         // Get around lack of span in error (#30128)"}, {"sha": "cc2858d3f73a17d80a95147a4353501ca82cc5b4", "filename": "compiler/rustc_expand/src/proc_macro_server.rs", "status": "modified", "additions": 81, "deletions": 65, "changes": 146, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_expand%2Fsrc%2Fproc_macro_server.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_expand%2Fsrc%2Fproc_macro_server.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fproc_macro_server.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "patch": "@@ -1,5 +1,8 @@\n use crate::base::ExtCtxt;\n-\n+use pm::bridge::{\n+    server, DelimSpan, Diagnostic, ExpnGlobals, Group, Ident, LitKind, Literal, Punct, TokenTree,\n+};\n+use pm::{Delimiter, Level, LineColumn};\n use rustc_ast as ast;\n use rustc_ast::token;\n use rustc_ast::tokenstream::{self, Spacing::*, TokenStream};\n@@ -13,11 +16,7 @@ use rustc_session::parse::ParseSess;\n use rustc_span::def_id::CrateNum;\n use rustc_span::symbol::{self, sym, Symbol};\n use rustc_span::{BytePos, FileName, Pos, SourceFile, Span};\n-\n-use pm::bridge::{\n-    server, DelimSpan, Diagnostic, ExpnGlobals, Group, Ident, LitKind, Literal, Punct, TokenTree,\n-};\n-use pm::{Delimiter, Level, LineColumn};\n+use smallvec::{smallvec, SmallVec};\n use std::ops::Bound;\n \n trait FromInternal<T> {\n@@ -110,10 +109,26 @@ impl FromInternal<(TokenStream, &mut Rustc<'_, '_>)> for Vec<TokenTree<TokenStre\n                 tokenstream::TokenTree::Token(token, spacing) => (token, spacing == Joint),\n             };\n \n+            // Split the operator into one or more `Punct`s, one per character.\n+            // The final one inherits the jointness of the original token. Any\n+            // before that get `joint = true`.\n             let mut op = |s: &str| {\n                 assert!(s.is_ascii());\n-                trees.extend(s.as_bytes().iter().enumerate().map(|(idx, &ch)| {\n-                    TokenTree::Punct(Punct { ch, joint: joint || idx != s.len() - 1, span })\n+                trees.extend(s.bytes().enumerate().map(|(i, ch)| {\n+                    let is_final = i == s.len() - 1;\n+                    // Split the token span into single chars. Unless the span\n+                    // is an unusual one, e.g. due to proc macro expansion. We\n+                    // determine this by assuming any span with a length that\n+                    // matches the operator length is a normal one, and any\n+                    // span with a different length is an unusual one.\n+                    let span = if (span.hi() - span.lo()).to_usize() == s.len() {\n+                        let lo = span.lo() + BytePos::from_usize(i);\n+                        let hi = lo + BytePos::from_usize(1);\n+                        span.with_lo(lo).with_hi(hi)\n+                    } else {\n+                        span\n+                    };\n+                    TokenTree::Punct(Punct { ch, joint: if is_final { joint } else { true }, span })\n                 }));\n             };\n \n@@ -237,23 +252,57 @@ impl FromInternal<(TokenStream, &mut Rustc<'_, '_>)> for Vec<TokenTree<TokenStre\n     }\n }\n \n-impl ToInternal<TokenStream> for (TokenTree<TokenStream, Span, Symbol>, &mut Rustc<'_, '_>) {\n-    fn to_internal(self) -> TokenStream {\n+// We use a `SmallVec` because the output size is always one or two `TokenTree`s.\n+impl ToInternal<SmallVec<[tokenstream::TokenTree; 2]>>\n+    for (TokenTree<TokenStream, Span, Symbol>, &mut Rustc<'_, '_>)\n+{\n+    fn to_internal(self) -> SmallVec<[tokenstream::TokenTree; 2]> {\n         use rustc_ast::token::*;\n \n         let (tree, rustc) = self;\n-        let (ch, joint, span) = match tree {\n-            TokenTree::Punct(Punct { ch, joint, span }) => (ch, joint, span),\n+        match tree {\n+            TokenTree::Punct(Punct { ch, joint, span }) => {\n+                let kind = match ch {\n+                    b'=' => Eq,\n+                    b'<' => Lt,\n+                    b'>' => Gt,\n+                    b'!' => Not,\n+                    b'~' => Tilde,\n+                    b'+' => BinOp(Plus),\n+                    b'-' => BinOp(Minus),\n+                    b'*' => BinOp(Star),\n+                    b'/' => BinOp(Slash),\n+                    b'%' => BinOp(Percent),\n+                    b'^' => BinOp(Caret),\n+                    b'&' => BinOp(And),\n+                    b'|' => BinOp(Or),\n+                    b'@' => At,\n+                    b'.' => Dot,\n+                    b',' => Comma,\n+                    b';' => Semi,\n+                    b':' => Colon,\n+                    b'#' => Pound,\n+                    b'$' => Dollar,\n+                    b'?' => Question,\n+                    b'\\'' => SingleQuote,\n+                    _ => unreachable!(),\n+                };\n+                smallvec![if joint {\n+                    tokenstream::TokenTree::token_joint(kind, span)\n+                } else {\n+                    tokenstream::TokenTree::token_alone(kind, span)\n+                }]\n+            }\n             TokenTree::Group(Group { delimiter, stream, span: DelimSpan { open, close, .. } }) => {\n-                return tokenstream::TokenStream::delimited(\n+                smallvec![tokenstream::TokenTree::Delimited(\n                     tokenstream::DelimSpan { open, close },\n                     delimiter.to_internal(),\n                     stream.unwrap_or_default(),\n-                );\n+                )]\n             }\n             TokenTree::Ident(self::Ident { sym, is_raw, span }) => {\n                 rustc.sess().symbol_gallery.insert(sym, span);\n-                return tokenstream::TokenStream::token_alone(Ident(sym, is_raw), span);\n+                smallvec![tokenstream::TokenTree::token_alone(Ident(sym, is_raw), span)]\n             }\n             TokenTree::Literal(self::Literal {\n                 kind: self::LitKind::Integer,\n@@ -266,7 +315,7 @@ impl ToInternal<TokenStream> for (TokenTree<TokenStream, Span, Symbol>, &mut Rus\n                 let integer = TokenKind::lit(token::Integer, symbol, suffix);\n                 let a = tokenstream::TokenTree::token_alone(minus, span);\n                 let b = tokenstream::TokenTree::token_alone(integer, span);\n-                return [a, b].into_iter().collect();\n+                smallvec![a, b]\n             }\n             TokenTree::Literal(self::Literal {\n                 kind: self::LitKind::Float,\n@@ -279,46 +328,14 @@ impl ToInternal<TokenStream> for (TokenTree<TokenStream, Span, Symbol>, &mut Rus\n                 let float = TokenKind::lit(token::Float, symbol, suffix);\n                 let a = tokenstream::TokenTree::token_alone(minus, span);\n                 let b = tokenstream::TokenTree::token_alone(float, span);\n-                return [a, b].into_iter().collect();\n+                smallvec![a, b]\n             }\n             TokenTree::Literal(self::Literal { kind, symbol, suffix, span }) => {\n-                return tokenstream::TokenStream::token_alone(\n+                smallvec![tokenstream::TokenTree::token_alone(\n                     TokenKind::lit(kind.to_internal(), symbol, suffix),\n                     span,\n-                );\n+                )]\n             }\n-        };\n-\n-        let kind = match ch {\n-            b'=' => Eq,\n-            b'<' => Lt,\n-            b'>' => Gt,\n-            b'!' => Not,\n-            b'~' => Tilde,\n-            b'+' => BinOp(Plus),\n-            b'-' => BinOp(Minus),\n-            b'*' => BinOp(Star),\n-            b'/' => BinOp(Slash),\n-            b'%' => BinOp(Percent),\n-            b'^' => BinOp(Caret),\n-            b'&' => BinOp(And),\n-            b'|' => BinOp(Or),\n-            b'@' => At,\n-            b'.' => Dot,\n-            b',' => Comma,\n-            b';' => Semi,\n-            b':' => Colon,\n-            b'#' => Pound,\n-            b'$' => Dollar,\n-            b'?' => Question,\n-            b'\\'' => SingleQuote,\n-            _ => unreachable!(),\n-        };\n-\n-        if joint {\n-            tokenstream::TokenStream::token_joint(kind, span)\n-        } else {\n-            tokenstream::TokenStream::token_alone(kind, span)\n         }\n     }\n }\n@@ -533,37 +550,35 @@ impl server::TokenStream for Rustc<'_, '_> {\n         &mut self,\n         tree: TokenTree<Self::TokenStream, Self::Span, Self::Symbol>,\n     ) -> Self::TokenStream {\n-        (tree, &mut *self).to_internal()\n+        Self::TokenStream::new((tree, &mut *self).to_internal().into_iter().collect::<Vec<_>>())\n     }\n \n     fn concat_trees(\n         &mut self,\n         base: Option<Self::TokenStream>,\n         trees: Vec<TokenTree<Self::TokenStream, Self::Span, Self::Symbol>>,\n     ) -> Self::TokenStream {\n-        let mut builder = tokenstream::TokenStreamBuilder::new();\n-        if let Some(base) = base {\n-            builder.push(base);\n-        }\n+        let mut stream =\n+            if let Some(base) = base { base } else { tokenstream::TokenStream::default() };\n         for tree in trees {\n-            builder.push((tree, &mut *self).to_internal());\n+            for tt in (tree, &mut *self).to_internal() {\n+                stream.push_tree(tt);\n+            }\n         }\n-        builder.build()\n+        stream\n     }\n \n     fn concat_streams(\n         &mut self,\n         base: Option<Self::TokenStream>,\n         streams: Vec<Self::TokenStream>,\n     ) -> Self::TokenStream {\n-        let mut builder = tokenstream::TokenStreamBuilder::new();\n-        if let Some(base) = base {\n-            builder.push(base);\n+        let mut stream =\n+            if let Some(base) = base { base } else { tokenstream::TokenStream::default() };\n+        for s in streams {\n+            stream.push_stream(s);\n         }\n-        for stream in streams {\n-            builder.push(stream);\n-        }\n-        builder.build()\n+        stream\n     }\n \n     fn into_trees(\n@@ -689,6 +704,7 @@ impl server::Span for Rustc<'_, '_> {\n     fn source_text(&mut self, span: Self::Span) -> Option<String> {\n         self.sess().source_map().span_to_snippet(span).ok()\n     }\n+\n     /// Saves the provided span into the metadata of\n     /// *the crate we are currently compiling*, which must\n     /// be a proc-macro crate. This id can be passed to"}, {"sha": "91c4dd732e3a5108b932988d8da821bdfafa8b58", "filename": "compiler/rustc_expand/src/tokenstream/tests.rs", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_expand%2Fsrc%2Ftokenstream%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_expand%2Fsrc%2Ftokenstream%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Ftokenstream%2Ftests.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "patch": "@@ -1,7 +1,7 @@\n use crate::tests::string_to_stream;\n \n use rustc_ast::token;\n-use rustc_ast::tokenstream::{TokenStream, TokenStreamBuilder};\n+use rustc_ast::tokenstream::{TokenStream, TokenTree};\n use rustc_span::create_default_session_globals_then;\n use rustc_span::{BytePos, Span, Symbol};\n \n@@ -19,10 +19,9 @@ fn test_concat() {\n         let test_res = string_to_ts(\"foo::bar::baz\");\n         let test_fst = string_to_ts(\"foo::bar\");\n         let test_snd = string_to_ts(\"::baz\");\n-        let mut builder = TokenStreamBuilder::new();\n-        builder.push(test_fst);\n-        builder.push(test_snd);\n-        let eq_res = builder.build();\n+        let mut eq_res = TokenStream::default();\n+        eq_res.push_stream(test_fst);\n+        eq_res.push_stream(test_snd);\n         assert_eq!(test_res.trees().count(), 5);\n         assert_eq!(eq_res.trees().count(), 5);\n         assert_eq!(test_res.eq_unspanned(&eq_res), true);\n@@ -99,11 +98,10 @@ fn test_is_empty() {\n #[test]\n fn test_dotdotdot() {\n     create_default_session_globals_then(|| {\n-        let mut builder = TokenStreamBuilder::new();\n-        builder.push(TokenStream::token_joint(token::Dot, sp(0, 1)));\n-        builder.push(TokenStream::token_joint(token::Dot, sp(1, 2)));\n-        builder.push(TokenStream::token_alone(token::Dot, sp(2, 3)));\n-        let stream = builder.build();\n+        let mut stream = TokenStream::default();\n+        stream.push_tree(TokenTree::token_joint(token::Dot, sp(0, 1)));\n+        stream.push_tree(TokenTree::token_joint(token::Dot, sp(1, 2)));\n+        stream.push_tree(TokenTree::token_alone(token::Dot, sp(2, 3)));\n         assert!(stream.eq_unspanned(&string_to_ts(\"...\")));\n         assert_eq!(stream.trees().count(), 1);\n     })"}, {"sha": "6f6468646fc7c3ccfae87eeab389535beb464f23", "filename": "compiler/rustc_feature/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_feature%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_feature%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_feature%2FCargo.toml?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "patch": "@@ -4,7 +4,6 @@ version = \"0.0.0\"\n edition = \"2021\"\n \n [lib]\n-doctest = false\n \n [dependencies]\n rustc_data_structures = { path = \"../rustc_data_structures\" }"}, {"sha": "54bf5a2c34b826575e18d9d34aa8d80306b5a3b2", "filename": "compiler/rustc_feature/src/accepted.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_feature%2Fsrc%2Faccepted.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_feature%2Fsrc%2Faccepted.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_feature%2Fsrc%2Faccepted.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "patch": "@@ -53,6 +53,8 @@ declare_features! (\n     (accepted, abi_sysv64, \"1.24.0\", Some(36167), None),\n     /// Allows using ADX intrinsics from `core::arch::{x86, x86_64}`.\n     (accepted, adx_target_feature, \"1.61.0\", Some(44839), None),\n+    /// Allows using `sym` operands in inline assembly.\n+    (accepted, asm_sym, \"CURRENT_RUSTC_VERSION\", Some(93333), None),\n     /// Allows the definition of associated constants in `trait` or `impl` blocks.\n     (accepted, associated_consts, \"1.20.0\", Some(29646), None),\n     /// Allows using associated `type`s in `trait`s.\n@@ -162,13 +164,15 @@ declare_features! (\n     /// Allows capturing variables in scope using format_args!\n     (accepted, format_args_capture, \"1.58.0\", Some(67984), None),\n     /// Allows associated types to be generic, e.g., `type Foo<T>;` (RFC 1598).\n-    (accepted, generic_associated_types, \"CURRENT_RUSTC_VERSION\", Some(44265), None),\n+    (accepted, generic_associated_types, \"1.65.0\", Some(44265), None),\n     /// Allows attributes on lifetime/type formal parameters in generics (RFC 1327).\n     (accepted, generic_param_attrs, \"1.27.0\", Some(48848), None),\n     /// Allows the `#[global_allocator]` attribute.\n     (accepted, global_allocator, \"1.28.0\", Some(27389), None),\n     // FIXME: explain `globs`.\n     (accepted, globs, \"1.0.0\", None, None),\n+    /// Allows using `..=X` as a pattern.\n+    (accepted, half_open_range_patterns, \"CURRENT_RUSTC_VERSION\", Some(67264), None),\n     /// Allows using the `u128` and `i128` types.\n     (accepted, i128_type, \"1.26.0\", Some(35118), None),\n     /// Allows the use of `if let` expressions.\n@@ -189,9 +193,9 @@ declare_features! (\n     /// especially around globs and shadowing (RFC 1560).\n     (accepted, item_like_imports, \"1.15.0\", Some(35120), None),\n     /// Allows `'a: { break 'a; }`.\n-    (accepted, label_break_value, \"CURRENT_RUSTC_VERSION\", Some(48594), None),\n+    (accepted, label_break_value, \"1.65.0\", Some(48594), None),\n     /// Allows `let...else` statements.\n-    (accepted, let_else, \"CURRENT_RUSTC_VERSION\", Some(87335), None),\n+    (accepted, let_else, \"1.65.0\", Some(87335), None),\n     /// Allows `break {expr}` with a value inside `loop`s.\n     (accepted, loop_break_value, \"1.19.0\", Some(37339), None),\n     /// Allows use of `?` as the Kleene \"at most one\" operator in macros."}, {"sha": "1b8d683b13361a407b61efca99071af4748324d6", "filename": "compiler/rustc_feature/src/active.rs", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_feature%2Fsrc%2Factive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_feature%2Fsrc%2Factive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_feature%2Fsrc%2Factive.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "patch": "@@ -300,8 +300,6 @@ declare_features! (\n     (active, asm_const, \"1.58.0\", Some(93332), None),\n     /// Enables experimental inline assembly support for additional architectures.\n     (active, asm_experimental_arch, \"1.58.0\", Some(93335), None),\n-    /// Allows using `sym` operands in inline assembly.\n-    (active, asm_sym, \"1.58.0\", Some(93333), None),\n     /// Allows the `may_unwind` option in inline assembly.\n     (active, asm_unwind, \"1.58.0\", Some(93334), None),\n     /// Allows users to enforce equality of associated constants `TraitImpl<AssocConst=3>`.\n@@ -341,7 +339,7 @@ declare_features! (\n     /// Allows to use the `#[cmse_nonsecure_entry]` attribute.\n     (active, cmse_nonsecure_entry, \"1.48.0\", Some(75835), None),\n     /// Allows use of the `#[collapse_debuginfo]` attribute.\n-    (active, collapse_debuginfo, \"CURRENT_RUSTC_VERSION\", Some(100758), None),\n+    (active, collapse_debuginfo, \"1.65.0\", Some(100758), None),\n     /// Allows `async {}` expressions in const contexts.\n     (active, const_async_blocks, \"1.53.0\", Some(85368), None),\n     // Allows limiting the evaluation steps of const expressions\n@@ -387,7 +385,7 @@ declare_features! (\n     /// Allows `#[doc(masked)]`.\n     (active, doc_masked, \"1.21.0\", Some(44027), None),\n     /// Allows `dyn* Trait` objects.\n-    (incomplete, dyn_star, \"CURRENT_RUSTC_VERSION\", Some(91611), None),\n+    (incomplete, dyn_star, \"1.65.0\", Some(91611), None),\n     /// Allows `X..Y` patterns.\n     (active, exclusive_range_pattern, \"1.11.0\", Some(37854), None),\n     /// Allows exhaustive pattern matching on types that contain uninhabited types.\n@@ -403,7 +401,7 @@ declare_features! (\n     /// Allows using `#[repr(align(...))]` on function items\n     (active, fn_align, \"1.53.0\", Some(82232), None),\n     /// Allows generators to be cloned.\n-    (active, generator_clone, \"CURRENT_RUSTC_VERSION\", Some(95360), None),\n+    (active, generator_clone, \"1.65.0\", Some(95360), None),\n     /// Allows defining generators.\n     (active, generators, \"1.21.0\", Some(43122), None),\n     /// Infer generic args for both consts and types.\n@@ -412,8 +410,8 @@ declare_features! (\n     (incomplete, generic_associated_types_extended, \"1.61.0\", Some(95451), None),\n     /// Allows non-trivial generic constants which have to have wfness manually propagated to callers\n     (incomplete, generic_const_exprs, \"1.56.0\", Some(76560), None),\n-    /// Allows using `..X`, `..=X`, `...X`, and `X..` as a pattern.\n-    (active, half_open_range_patterns, \"1.41.0\", Some(67264), None),\n+    /// Allows using `..=X` as a patterns in slices.\n+    (active, half_open_range_patterns_in_slices, \"CURRENT_RUSTC_VERSION\", Some(67264), None),\n     /// Allows `if let` guard in match arms.\n     (active, if_let_guard, \"1.47.0\", Some(51114), None),\n     /// Allows using imported `main` function\n@@ -484,7 +482,7 @@ declare_features! (\n     /// Allows macro attributes on expressions, statements and non-inline modules.\n     (active, proc_macro_hygiene, \"1.30.0\", Some(54727), None),\n     /// Allows the use of raw-dylibs (RFC 2627).\n-    (active, raw_dylib, \"CURRENT_RUSTC_VERSION\", Some(58713), None),\n+    (active, raw_dylib, \"1.65.0\", Some(58713), None),\n     /// Allows `&raw const $place_expr` and `&raw mut $place_expr` expressions.\n     (active, raw_ref_op, \"1.41.0\", Some(64490), None),\n     /// Allows using the `#[register_tool]` attribute.\n@@ -494,7 +492,7 @@ declare_features! (\n     /// Allows `repr(simd)` and importing the various simd intrinsics.\n     (active, repr_simd, \"1.4.0\", Some(27731), None),\n     /// Allows return-position `impl Trait` in traits.\n-    (incomplete, return_position_impl_trait_in_trait, \"CURRENT_RUSTC_VERSION\", Some(91611), None),\n+    (incomplete, return_position_impl_trait_in_trait, \"1.65.0\", Some(91611), None),\n     /// Allows `extern \"rust-cold\"`.\n     (active, rust_cold_cc, \"1.63.0\", Some(97544), None),\n     /// Allows the use of SIMD types in functions declared in `extern` blocks.\n@@ -528,7 +526,7 @@ declare_features! (\n     /// not changed from prior instances of the same struct (RFC #2528)\n     (active, type_changing_struct_update, \"1.58.0\", Some(86555), None),\n     /// Enables rustc to generate code that instructs libstd to NOT ignore SIGPIPE.\n-    (active, unix_sigpipe, \"CURRENT_RUSTC_VERSION\", Some(97889), None),\n+    (active, unix_sigpipe, \"1.65.0\", Some(97889), None),\n     /// Allows unsized fn parameters.\n     (active, unsized_fn_params, \"1.49.0\", Some(48055), None),\n     /// Allows unsized rvalues at arguments and parameters."}, {"sha": "92d0fb1aec83f4aebf733385de9cfdcfadb26e07", "filename": "compiler/rustc_feature/src/builtin_attrs.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_feature%2Fsrc%2Fbuiltin_attrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_feature%2Fsrc%2Fbuiltin_attrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_feature%2Fsrc%2Fbuiltin_attrs.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "patch": "@@ -499,6 +499,7 @@ pub const BUILTIN_ATTRIBUTES: &[BuiltinAttribute] = &[\n     ),\n     ungated!(rustc_const_unstable, Normal, template!(List: r#\"feature = \"name\"\"#), DuplicatesOk),\n     ungated!(rustc_const_stable, Normal, template!(List: r#\"feature = \"name\"\"#), DuplicatesOk),\n+    ungated!(rustc_safe_intrinsic, Normal, template!(Word), DuplicatesOk),\n     ungated!(\n         rustc_default_body_unstable, Normal,\n         template!(List: r#\"feature = \"name\", reason = \"...\", issue = \"N\"\"#), DuplicatesOk\n@@ -535,7 +536,7 @@ pub const BUILTIN_ATTRIBUTES: &[BuiltinAttribute] = &[\n     // ==========================================================================\n \n     rustc_attr!(rustc_allocator, Normal, template!(Word), WarnFollowing, IMPL_DETAIL),\n-    rustc_attr!(rustc_allocator_nounwind, Normal, template!(Word), WarnFollowing, IMPL_DETAIL),\n+    rustc_attr!(rustc_nounwind, Normal, template!(Word), WarnFollowing, IMPL_DETAIL),\n     rustc_attr!(rustc_reallocator, Normal, template!(Word), WarnFollowing, IMPL_DETAIL),\n     rustc_attr!(rustc_deallocator, Normal, template!(Word), WarnFollowing, IMPL_DETAIL),\n     rustc_attr!(rustc_allocator_zeroed, Normal, template!(Word), WarnFollowing, IMPL_DETAIL),"}, {"sha": "79a12801de29db5bf1d23615dd36cd28732a93ae", "filename": "compiler/rustc_feature/src/removed.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_feature%2Fsrc%2Fremoved.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_feature%2Fsrc%2Fremoved.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_feature%2Fsrc%2Fremoved.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "patch": "@@ -164,7 +164,7 @@ declare_features! (\n     (removed, quote, \"1.33.0\", Some(29601), None, None),\n     (removed, reflect, \"1.0.0\", Some(27749), None, None),\n     /// Allows using the `#[register_attr]` attribute.\n-    (removed, register_attr, \"CURRENT_RUSTC_VERSION\", Some(66080), None,\n+    (removed, register_attr, \"1.65.0\", Some(66080), None,\n      Some(\"removed in favor of `#![register_tool]`\")),\n     /// Allows using the macros:\n     /// + `__diagnostic_used`"}, {"sha": "129f8d235adbcf88290e3f52101247b817d32b2e", "filename": "compiler/rustc_hir/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_hir%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_hir%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2FCargo.toml?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "patch": "@@ -4,7 +4,6 @@ version = \"0.0.0\"\n edition = \"2021\"\n \n [lib]\n-doctest = false\n \n [dependencies]\n rustc_arena = { path = \"../rustc_arena\" }"}, {"sha": "4ef4aad902c68ebc824b0a37d8e21ffecd19adcb", "filename": "compiler/rustc_hir/src/def.rs", "status": "modified", "additions": 75, "deletions": 50, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_hir%2Fsrc%2Fdef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_hir%2Fsrc%2Fdef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fdef.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "patch": "@@ -314,89 +314,95 @@ pub enum Res<Id = hir::HirId> {\n     /// **Belongs to the type namespace.**\n     PrimTy(hir::PrimTy),\n \n-    /// The `Self` type, optionally with the [`DefId`] of the trait it belongs to and\n-    /// optionally with the [`DefId`] of the item introducing the `Self` type alias.\n+    /// The `Self` type, as used within a trait.\n+    ///\n+    /// **Belongs to the type namespace.**\n+    ///\n+    /// See the examples on [`Res::SelfTyAlias`] for details.\n+    SelfTyParam {\n+        /// The trait this `Self` is a generic parameter for.\n+        trait_: DefId,\n+    },\n+\n+    /// The `Self` type, as used somewhere other than within a trait.\n     ///\n     /// **Belongs to the type namespace.**\n     ///\n     /// Examples:\n     /// ```\n-    /// struct Bar(Box<Self>);\n-    /// // `Res::SelfTy { trait_: None, alias_of: Some(Bar) }`\n+    /// struct Bar(Box<Self>); // SelfTyAlias\n     ///\n     /// trait Foo {\n-    ///     fn foo() -> Box<Self>;\n-    ///     // `Res::SelfTy { trait_: Some(Foo), alias_of: None }`\n+    ///     fn foo() -> Box<Self>; // SelfTyParam\n     /// }\n     ///\n     /// impl Bar {\n     ///     fn blah() {\n-    ///         let _: Self;\n-    ///         // `Res::SelfTy { trait_: None, alias_of: Some(::{impl#0}) }`\n+    ///         let _: Self; // SelfTyAlias\n     ///     }\n     /// }\n     ///\n     /// impl Foo for Bar {\n-    ///     fn foo() -> Box<Self> {\n-    ///     // `Res::SelfTy { trait_: Some(Foo), alias_of: Some(::{impl#1}) }`\n-    ///         let _: Self;\n-    ///         // `Res::SelfTy { trait_: Some(Foo), alias_of: Some(::{impl#1}) }`\n+    ///     fn foo() -> Box<Self> { // SelfTyAlias\n+    ///         let _: Self;        // SelfTyAlias\n     ///\n     ///         todo!()\n     ///     }\n     /// }\n     /// ```\n-    ///\n     /// *See also [`Res::SelfCtor`].*\n     ///\n-    /// -----\n-    ///\n-    /// HACK(min_const_generics): self types also have an optional requirement to **not** mention\n-    /// any generic parameters to allow the following with `min_const_generics`:\n-    /// ```\n-    /// # struct Foo;\n-    /// impl Foo { fn test() -> [u8; std::mem::size_of::<Self>()] { todo!() } }\n-    ///\n-    /// struct Bar([u8; baz::<Self>()]);\n-    /// const fn baz<T>() -> usize { 10 }\n-    /// ```\n-    /// We do however allow `Self` in repeat expression even if it is generic to not break code\n-    /// which already works on stable while causing the `const_evaluatable_unchecked` future compat\n-    /// lint:\n-    /// ```\n-    /// fn foo<T>() {\n-    ///     let _bar = [1_u8; std::mem::size_of::<*mut T>()];\n-    /// }\n-    /// ```\n-    // FIXME(generic_const_exprs): Remove this bodge once that feature is stable.\n-    SelfTy {\n-        /// The trait this `Self` is a generic arg for.\n-        trait_: Option<DefId>,\n+    SelfTyAlias {\n         /// The item introducing the `Self` type alias. Can be used in the `type_of` query\n-        /// to get the underlying type. Additionally whether the `Self` type is disallowed\n-        /// from mentioning generics (i.e. when used in an anonymous constant).\n-        alias_to: Option<(DefId, bool)>,\n-    },\n+        /// to get the underlying type.\n+        alias_to: DefId,\n \n-    /// A tool attribute module; e.g., the `rustfmt` in `#[rustfmt::skip]`.\n-    ///\n-    /// **Belongs to the type namespace.**\n-    ToolMod,\n+        /// Whether the `Self` type is disallowed from mentioning generics (i.e. when used in an\n+        /// anonymous constant).\n+        ///\n+        /// HACK(min_const_generics): self types also have an optional requirement to **not**\n+        /// mention any generic parameters to allow the following with `min_const_generics`:\n+        /// ```\n+        /// # struct Foo;\n+        /// impl Foo { fn test() -> [u8; std::mem::size_of::<Self>()] { todo!() } }\n+        ///\n+        /// struct Bar([u8; baz::<Self>()]);\n+        /// const fn baz<T>() -> usize { 10 }\n+        /// ```\n+        /// We do however allow `Self` in repeat expression even if it is generic to not break code\n+        /// which already works on stable while causing the `const_evaluatable_unchecked` future\n+        /// compat lint:\n+        /// ```\n+        /// fn foo<T>() {\n+        ///     let _bar = [1_u8; std::mem::size_of::<*mut T>()];\n+        /// }\n+        /// ```\n+        // FIXME(generic_const_exprs): Remove this bodge once that feature is stable.\n+        forbid_generic: bool,\n+\n+        /// Is this within an `impl Foo for bar`?\n+        is_trait_impl: bool,\n+    },\n \n     // Value namespace\n     /// The `Self` constructor, along with the [`DefId`]\n     /// of the impl it is associated with.\n     ///\n     /// **Belongs to the value namespace.**\n     ///\n-    /// *See also [`Res::SelfTy`].*\n+    /// *See also [`Res::SelfTyParam`] and [`Res::SelfTyAlias`].*\n     SelfCtor(DefId),\n \n     /// A local variable or function parameter.\n     ///\n     /// **Belongs to the value namespace.**\n     Local(Id),\n \n+    /// A tool attribute module; e.g., the `rustfmt` in `#[rustfmt::skip]`.\n+    ///\n+    /// **Belongs to the type namespace.**\n+    ToolMod,\n+\n     // Macro namespace\n     /// An attribute that is *not* implemented via macro.\n     /// E.g., `#[inline]` and `#[rustfmt::skip]`, which are essentially directives,\n@@ -458,6 +464,16 @@ impl PartialRes {\n     pub fn unresolved_segments(&self) -> usize {\n         self.unresolved_segments\n     }\n+\n+    #[inline]\n+    pub fn full_res(&self) -> Option<Res<NodeId>> {\n+        (self.unresolved_segments == 0).then_some(self.base_res)\n+    }\n+\n+    #[inline]\n+    pub fn expect_full_res(&self) -> Res<NodeId> {\n+        self.full_res().expect(\"unexpected unresolved segments\")\n+    }\n }\n \n /// Different kinds of symbols can coexist even if they share the same textual name.\n@@ -606,7 +622,8 @@ impl<Id> Res<Id> {\n \n             Res::Local(..)\n             | Res::PrimTy(..)\n-            | Res::SelfTy { .. }\n+            | Res::SelfTyParam { .. }\n+            | Res::SelfTyAlias { .. }\n             | Res::SelfCtor(..)\n             | Res::ToolMod\n             | Res::NonMacroAttr(..)\n@@ -629,7 +646,7 @@ impl<Id> Res<Id> {\n             Res::SelfCtor(..) => \"self constructor\",\n             Res::PrimTy(..) => \"builtin type\",\n             Res::Local(..) => \"local variable\",\n-            Res::SelfTy { .. } => \"self type\",\n+            Res::SelfTyParam { .. } | Res::SelfTyAlias { .. } => \"self type\",\n             Res::ToolMod => \"tool module\",\n             Res::NonMacroAttr(attr_kind) => attr_kind.descr(),\n             Res::Err => \"unresolved item\",\n@@ -652,7 +669,10 @@ impl<Id> Res<Id> {\n             Res::SelfCtor(id) => Res::SelfCtor(id),\n             Res::PrimTy(id) => Res::PrimTy(id),\n             Res::Local(id) => Res::Local(map(id)),\n-            Res::SelfTy { trait_, alias_to } => Res::SelfTy { trait_, alias_to },\n+            Res::SelfTyParam { trait_ } => Res::SelfTyParam { trait_ },\n+            Res::SelfTyAlias { alias_to, forbid_generic, is_trait_impl } => {\n+                Res::SelfTyAlias { alias_to, forbid_generic, is_trait_impl }\n+            }\n             Res::ToolMod => Res::ToolMod,\n             Res::NonMacroAttr(attr_kind) => Res::NonMacroAttr(attr_kind),\n             Res::Err => Res::Err,\n@@ -665,7 +685,10 @@ impl<Id> Res<Id> {\n             Res::SelfCtor(id) => Res::SelfCtor(id),\n             Res::PrimTy(id) => Res::PrimTy(id),\n             Res::Local(id) => Res::Local(map(id)?),\n-            Res::SelfTy { trait_, alias_to } => Res::SelfTy { trait_, alias_to },\n+            Res::SelfTyParam { trait_ } => Res::SelfTyParam { trait_ },\n+            Res::SelfTyAlias { alias_to, forbid_generic, is_trait_impl } => {\n+                Res::SelfTyAlias { alias_to, forbid_generic, is_trait_impl }\n+            }\n             Res::ToolMod => Res::ToolMod,\n             Res::NonMacroAttr(attr_kind) => Res::NonMacroAttr(attr_kind),\n             Res::Err => Res::Err,\n@@ -692,7 +715,9 @@ impl<Id> Res<Id> {\n     pub fn ns(&self) -> Option<Namespace> {\n         match self {\n             Res::Def(kind, ..) => kind.ns(),\n-            Res::PrimTy(..) | Res::SelfTy { .. } | Res::ToolMod => Some(Namespace::TypeNS),\n+            Res::PrimTy(..) | Res::SelfTyParam { .. } | Res::SelfTyAlias { .. } | Res::ToolMod => {\n+                Some(Namespace::TypeNS)\n+            }\n             Res::SelfCtor(..) | Res::Local(..) => Some(Namespace::ValueNS),\n             Res::NonMacroAttr(..) => Some(Namespace::MacroNS),\n             Res::Err => None,"}, {"sha": "bc149e48d89e842b8333989350810b0988a752fc", "filename": "compiler/rustc_hir/src/hir.rs", "status": "modified", "additions": 28, "deletions": 29, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fhir.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "patch": "@@ -1,6 +1,6 @@\n use crate::def::{CtorKind, DefKind, Res};\n use crate::def_id::DefId;\n-pub(crate) use crate::hir_id::{HirId, ItemLocalId};\n+pub(crate) use crate::hir_id::{HirId, ItemLocalId, OwnerId};\n use crate::intravisit::FnKind;\n use crate::LangItem;\n \n@@ -731,6 +731,7 @@ pub enum PredicateOrigin {\n /// A type bound (e.g., `for<'c> Foo: Send + Clone + 'c`).\n #[derive(Debug, HashStable_Generic)]\n pub struct WhereBoundPredicate<'hir> {\n+    pub hir_id: HirId,\n     pub span: Span,\n     /// Origin of the predicate.\n     pub origin: PredicateOrigin,\n@@ -2206,14 +2207,14 @@ pub struct FnSig<'hir> {\n // so it can fetched later.\n #[derive(Copy, Clone, PartialEq, Eq, Encodable, Decodable, Debug, HashStable_Generic)]\n pub struct TraitItemId {\n-    pub def_id: LocalDefId,\n+    pub def_id: OwnerId,\n }\n \n impl TraitItemId {\n     #[inline]\n     pub fn hir_id(&self) -> HirId {\n         // Items are always HIR owners.\n-        HirId::make_owner(self.def_id)\n+        HirId::make_owner(self.def_id.def_id)\n     }\n }\n \n@@ -2224,7 +2225,7 @@ impl TraitItemId {\n #[derive(Debug, HashStable_Generic)]\n pub struct TraitItem<'hir> {\n     pub ident: Ident,\n-    pub def_id: LocalDefId,\n+    pub def_id: OwnerId,\n     pub generics: &'hir Generics<'hir>,\n     pub kind: TraitItemKind<'hir>,\n     pub span: Span,\n@@ -2235,7 +2236,7 @@ impl TraitItem<'_> {\n     #[inline]\n     pub fn hir_id(&self) -> HirId {\n         // Items are always HIR owners.\n-        HirId::make_owner(self.def_id)\n+        HirId::make_owner(self.def_id.def_id)\n     }\n \n     pub fn trait_item_id(&self) -> TraitItemId {\n@@ -2270,22 +2271,22 @@ pub enum TraitItemKind<'hir> {\n // so it can fetched later.\n #[derive(Copy, Clone, PartialEq, Eq, Encodable, Decodable, Debug, HashStable_Generic)]\n pub struct ImplItemId {\n-    pub def_id: LocalDefId,\n+    pub def_id: OwnerId,\n }\n \n impl ImplItemId {\n     #[inline]\n     pub fn hir_id(&self) -> HirId {\n         // Items are always HIR owners.\n-        HirId::make_owner(self.def_id)\n+        HirId::make_owner(self.def_id.def_id)\n     }\n }\n \n /// Represents anything within an `impl` block.\n #[derive(Debug, HashStable_Generic)]\n pub struct ImplItem<'hir> {\n     pub ident: Ident,\n-    pub def_id: LocalDefId,\n+    pub def_id: OwnerId,\n     pub generics: &'hir Generics<'hir>,\n     pub kind: ImplItemKind<'hir>,\n     pub defaultness: Defaultness,\n@@ -2297,7 +2298,7 @@ impl ImplItem<'_> {\n     #[inline]\n     pub fn hir_id(&self) -> HirId {\n         // Items are always HIR owners.\n-        HirId::make_owner(self.def_id)\n+        HirId::make_owner(self.def_id.def_id)\n     }\n \n     pub fn impl_item_id(&self) -> ImplItemId {\n@@ -2314,7 +2315,7 @@ pub enum ImplItemKind<'hir> {\n     /// An associated function implementation with the given signature and body.\n     Fn(FnSig<'hir>, BodyId),\n     /// An associated type.\n-    TyAlias(&'hir Ty<'hir>),\n+    Type(&'hir Ty<'hir>),\n }\n \n // The name of the associated type for `Fn` return types.\n@@ -2403,8 +2404,9 @@ impl<'hir> Ty<'hir> {\n             return None;\n         };\n         match path.res {\n-            Res::Def(DefKind::TyParam, def_id)\n-            | Res::SelfTy { trait_: Some(def_id), alias_to: None } => Some((def_id, segment.ident)),\n+            Res::Def(DefKind::TyParam, def_id) | Res::SelfTyParam { trait_: def_id } => {\n+                Some((def_id, segment.ident))\n+            }\n             _ => None,\n         }\n     }\n@@ -2888,14 +2890,14 @@ impl<'hir> VariantData<'hir> {\n // so it can fetched later.\n #[derive(Copy, Clone, PartialEq, Eq, Encodable, Decodable, Debug, Hash, HashStable_Generic)]\n pub struct ItemId {\n-    pub def_id: LocalDefId,\n+    pub def_id: OwnerId,\n }\n \n impl ItemId {\n     #[inline]\n     pub fn hir_id(&self) -> HirId {\n         // Items are always HIR owners.\n-        HirId::make_owner(self.def_id)\n+        HirId::make_owner(self.def_id.def_id)\n     }\n }\n \n@@ -2905,7 +2907,7 @@ impl ItemId {\n #[derive(Debug, HashStable_Generic)]\n pub struct Item<'hir> {\n     pub ident: Ident,\n-    pub def_id: LocalDefId,\n+    pub def_id: OwnerId,\n     pub kind: ItemKind<'hir>,\n     pub span: Span,\n     pub vis_span: Span,\n@@ -2915,7 +2917,7 @@ impl Item<'_> {\n     #[inline]\n     pub fn hir_id(&self) -> HirId {\n         // Items are always HIR owners.\n-        HirId::make_owner(self.def_id)\n+        HirId::make_owner(self.def_id.def_id)\n     }\n \n     pub fn item_id(&self) -> ItemId {\n@@ -3132,14 +3134,14 @@ pub enum AssocItemKind {\n // so it can fetched later.\n #[derive(Copy, Clone, PartialEq, Eq, Encodable, Decodable, Debug, HashStable_Generic)]\n pub struct ForeignItemId {\n-    pub def_id: LocalDefId,\n+    pub def_id: OwnerId,\n }\n \n impl ForeignItemId {\n     #[inline]\n     pub fn hir_id(&self) -> HirId {\n         // Items are always HIR owners.\n-        HirId::make_owner(self.def_id)\n+        HirId::make_owner(self.def_id.def_id)\n     }\n }\n \n@@ -3160,7 +3162,7 @@ pub struct ForeignItemRef {\n pub struct ForeignItem<'hir> {\n     pub ident: Ident,\n     pub kind: ForeignItemKind<'hir>,\n-    pub def_id: LocalDefId,\n+    pub def_id: OwnerId,\n     pub span: Span,\n     pub vis_span: Span,\n }\n@@ -3169,7 +3171,7 @@ impl ForeignItem<'_> {\n     #[inline]\n     pub fn hir_id(&self) -> HirId {\n         // Items are always HIR owners.\n-        HirId::make_owner(self.def_id)\n+        HirId::make_owner(self.def_id.def_id)\n     }\n \n     pub fn foreign_item_id(&self) -> ForeignItemId {\n@@ -3263,7 +3265,7 @@ impl<'hir> OwnerNode<'hir> {\n         Node::generics(self.into())\n     }\n \n-    pub fn def_id(self) -> LocalDefId {\n+    pub fn def_id(self) -> OwnerId {\n         match self {\n             OwnerNode::Item(Item { def_id, .. })\n             | OwnerNode::TraitItem(TraitItem { def_id, .. })\n@@ -3512,38 +3514,35 @@ impl<'hir> Node<'hir> {\n #[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n mod size_asserts {\n     use super::*;\n-    // These are in alphabetical order, which is easy to maintain.\n+    // tidy-alphabetical-start\n     static_assert_size!(Block<'_>, 48);\n     static_assert_size!(Body<'_>, 32);\n     static_assert_size!(Expr<'_>, 64);\n     static_assert_size!(ExprKind<'_>, 48);\n     static_assert_size!(FnDecl<'_>, 40);\n     static_assert_size!(ForeignItem<'_>, 72);\n     static_assert_size!(ForeignItemKind<'_>, 40);\n-    #[cfg(not(bootstrap))]\n     static_assert_size!(GenericArg<'_>, 24);\n     static_assert_size!(GenericBound<'_>, 48);\n     static_assert_size!(Generics<'_>, 56);\n     static_assert_size!(Impl<'_>, 80);\n-    #[cfg(not(bootstrap))]\n     static_assert_size!(ImplItem<'_>, 80);\n-    #[cfg(not(bootstrap))]\n     static_assert_size!(ImplItemKind<'_>, 32);\n     static_assert_size!(Item<'_>, 80);\n     static_assert_size!(ItemKind<'_>, 48);\n     static_assert_size!(Local<'_>, 64);\n     static_assert_size!(Param<'_>, 32);\n     static_assert_size!(Pat<'_>, 72);\n+    static_assert_size!(Path<'_>, 40);\n+    static_assert_size!(PathSegment<'_>, 48);\n     static_assert_size!(PatKind<'_>, 48);\n-    static_assert_size!(Path<'_>, 48);\n-    static_assert_size!(PathSegment<'_>, 56);\n     static_assert_size!(QPath<'_>, 24);\n+    static_assert_size!(Res, 12);\n     static_assert_size!(Stmt<'_>, 32);\n     static_assert_size!(StmtKind<'_>, 16);\n-    #[cfg(not(bootstrap))]\n     static_assert_size!(TraitItem<'_>, 88);\n-    #[cfg(not(bootstrap))]\n     static_assert_size!(TraitItemKind<'_>, 48);\n     static_assert_size!(Ty<'_>, 48);\n     static_assert_size!(TyKind<'_>, 32);\n+    // tidy-alphabetical-end\n }"}, {"sha": "752f760ea9719395fcf8982ea0600b8f45aa2fc4", "filename": "compiler/rustc_hir/src/hir_id.rs", "status": "modified", "additions": 52, "deletions": 8, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_hir%2Fsrc%2Fhir_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_hir%2Fsrc%2Fhir_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fhir_id.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "patch": "@@ -1,6 +1,43 @@\n-use crate::def_id::{LocalDefId, CRATE_DEF_ID};\n+use crate::def_id::{DefId, LocalDefId, CRATE_DEF_ID};\n+use rustc_data_structures::stable_hasher::{HashStable, StableHasher, ToStableHashKey};\n+use rustc_span::{def_id::DefPathHash, HashStableContext};\n use std::fmt;\n \n+#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n+#[derive(Encodable, Decodable)]\n+pub struct OwnerId {\n+    pub def_id: LocalDefId,\n+}\n+\n+impl From<OwnerId> for HirId {\n+    fn from(owner: OwnerId) -> HirId {\n+        HirId { owner, local_id: ItemLocalId::from_u32(0) }\n+    }\n+}\n+\n+impl OwnerId {\n+    #[inline]\n+    pub fn to_def_id(self) -> DefId {\n+        self.def_id.to_def_id()\n+    }\n+}\n+\n+impl<CTX: HashStableContext> HashStable<CTX> for OwnerId {\n+    #[inline]\n+    fn hash_stable(&self, hcx: &mut CTX, hasher: &mut StableHasher) {\n+        self.to_stable_hash_key(hcx).hash_stable(hcx, hasher);\n+    }\n+}\n+\n+impl<CTX: HashStableContext> ToStableHashKey<CTX> for OwnerId {\n+    type KeyType = DefPathHash;\n+\n+    #[inline]\n+    fn to_stable_hash_key(&self, hcx: &CTX) -> DefPathHash {\n+        hcx.def_path_hash(self.to_def_id())\n+    }\n+}\n+\n /// Uniquely identifies a node in the HIR of the current crate. It is\n /// composed of the `owner`, which is the `LocalDefId` of the directly enclosing\n /// `hir::Item`, `hir::TraitItem`, or `hir::ImplItem` (i.e., the closest \"item-like\"),\n@@ -15,22 +52,23 @@ use std::fmt;\n #[derive(Encodable, Decodable, HashStable_Generic)]\n #[rustc_pass_by_value]\n pub struct HirId {\n-    pub owner: LocalDefId,\n+    pub owner: OwnerId,\n     pub local_id: ItemLocalId,\n }\n \n impl HirId {\n     /// Signal local id which should never be used.\n-    pub const INVALID: HirId = HirId { owner: CRATE_DEF_ID, local_id: ItemLocalId::INVALID };\n+    pub const INVALID: HirId =\n+        HirId { owner: OwnerId { def_id: CRATE_DEF_ID }, local_id: ItemLocalId::INVALID };\n \n     #[inline]\n-    pub fn expect_owner(self) -> LocalDefId {\n+    pub fn expect_owner(self) -> OwnerId {\n         assert_eq!(self.local_id.index(), 0);\n         self.owner\n     }\n \n     #[inline]\n-    pub fn as_owner(self) -> Option<LocalDefId> {\n+    pub fn as_owner(self) -> Option<OwnerId> {\n         if self.local_id.index() == 0 { Some(self.owner) } else { None }\n     }\n \n@@ -41,11 +79,14 @@ impl HirId {\n \n     #[inline]\n     pub fn make_owner(owner: LocalDefId) -> Self {\n-        Self { owner, local_id: ItemLocalId::from_u32(0) }\n+        Self { owner: OwnerId { def_id: owner }, local_id: ItemLocalId::from_u32(0) }\n     }\n \n     pub fn index(self) -> (usize, usize) {\n-        (rustc_index::vec::Idx::index(self.owner), rustc_index::vec::Idx::index(self.local_id))\n+        (\n+            rustc_index::vec::Idx::index(self.owner.def_id),\n+            rustc_index::vec::Idx::index(self.local_id),\n+        )\n     }\n }\n \n@@ -94,4 +135,7 @@ impl ItemLocalId {\n }\n \n /// The `HirId` corresponding to `CRATE_NODE_ID` and `CRATE_DEF_ID`.\n-pub const CRATE_HIR_ID: HirId = HirId { owner: CRATE_DEF_ID, local_id: ItemLocalId::from_u32(0) };\n+pub const CRATE_HIR_ID: HirId =\n+    HirId { owner: OwnerId { def_id: CRATE_DEF_ID }, local_id: ItemLocalId::from_u32(0) };\n+\n+pub const CRATE_OWNER_ID: OwnerId = OwnerId { def_id: CRATE_DEF_ID };"}, {"sha": "f3bde099b134fd0b475ea7f2dfb41a18191b6e30", "filename": "compiler/rustc_hir/src/intravisit.rs", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_hir%2Fsrc%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_hir%2Fsrc%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fintravisit.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "patch": "@@ -847,20 +847,28 @@ pub fn walk_where_predicate<'v, V: Visitor<'v>>(\n ) {\n     match *predicate {\n         WherePredicate::BoundPredicate(WhereBoundPredicate {\n+            hir_id,\n             ref bounded_ty,\n             bounds,\n             bound_generic_params,\n-            ..\n+            origin: _,\n+            span: _,\n         }) => {\n+            visitor.visit_id(hir_id);\n             visitor.visit_ty(bounded_ty);\n             walk_list!(visitor, visit_param_bound, bounds);\n             walk_list!(visitor, visit_generic_param, bound_generic_params);\n         }\n-        WherePredicate::RegionPredicate(WhereRegionPredicate { ref lifetime, bounds, .. }) => {\n+        WherePredicate::RegionPredicate(WhereRegionPredicate {\n+            ref lifetime,\n+            bounds,\n+            span: _,\n+            in_where_clause: _,\n+        }) => {\n             visitor.visit_lifetime(lifetime);\n             walk_list!(visitor, visit_param_bound, bounds);\n         }\n-        WherePredicate::EqPredicate(WhereEqPredicate { ref lhs_ty, ref rhs_ty, .. }) => {\n+        WherePredicate::EqPredicate(WhereEqPredicate { ref lhs_ty, ref rhs_ty, span: _ }) => {\n             visitor.visit_ty(lhs_ty);\n             visitor.visit_ty(rhs_ty);\n         }\n@@ -971,7 +979,7 @@ pub fn walk_impl_item<'v, V: Visitor<'v>>(visitor: &mut V, impl_item: &'v ImplIt\n                 impl_item.hir_id(),\n             );\n         }\n-        ImplItemKind::TyAlias(ref ty) => {\n+        ImplItemKind::Type(ref ty) => {\n             visitor.visit_id(impl_item.hir_id());\n             visitor.visit_ty(ty);\n         }"}, {"sha": "1c4aa420c9bf9bb59d116b0b8efa10ec484c846e", "filename": "compiler/rustc_hir/src/lib.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_hir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_hir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Flib.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "patch": "@@ -4,8 +4,7 @@\n \n #![feature(associated_type_defaults)]\n #![feature(closure_track_caller)]\n-#![feature(const_btree_new)]\n-#![cfg_attr(bootstrap, feature(let_else))]\n+#![feature(const_btree_len)]\n #![feature(once_cell)]\n #![feature(min_specialization)]\n #![feature(never_type)]"}, {"sha": "06b7a65662e7cbe5b3573cf176d8aefbfbe0fcd4", "filename": "compiler/rustc_hir/src/stable_hash_impls.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_hir%2Fsrc%2Fstable_hash_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_hir%2Fsrc%2Fstable_hash_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fstable_hash_impls.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "patch": "@@ -20,7 +20,7 @@ impl<HirCtx: crate::HashStableContext> ToStableHashKey<HirCtx> for HirId {\n \n     #[inline]\n     fn to_stable_hash_key(&self, hcx: &HirCtx) -> (DefPathHash, ItemLocalId) {\n-        let def_path_hash = self.owner.to_stable_hash_key(hcx);\n+        let def_path_hash = self.owner.def_id.to_stable_hash_key(hcx);\n         (def_path_hash, self.local_id)\n     }\n }\n@@ -49,7 +49,7 @@ impl<HirCtx: crate::HashStableContext> ToStableHashKey<HirCtx> for ItemId {\n \n     #[inline]\n     fn to_stable_hash_key(&self, hcx: &HirCtx) -> DefPathHash {\n-        self.def_id.to_stable_hash_key(hcx)\n+        self.def_id.def_id.to_stable_hash_key(hcx)\n     }\n }\n \n@@ -58,7 +58,7 @@ impl<HirCtx: crate::HashStableContext> ToStableHashKey<HirCtx> for TraitItemId {\n \n     #[inline]\n     fn to_stable_hash_key(&self, hcx: &HirCtx) -> DefPathHash {\n-        self.def_id.to_stable_hash_key(hcx)\n+        self.def_id.def_id.to_stable_hash_key(hcx)\n     }\n }\n \n@@ -67,7 +67,7 @@ impl<HirCtx: crate::HashStableContext> ToStableHashKey<HirCtx> for ImplItemId {\n \n     #[inline]\n     fn to_stable_hash_key(&self, hcx: &HirCtx) -> DefPathHash {\n-        self.def_id.to_stable_hash_key(hcx)\n+        self.def_id.def_id.to_stable_hash_key(hcx)\n     }\n }\n \n@@ -76,7 +76,7 @@ impl<HirCtx: crate::HashStableContext> ToStableHashKey<HirCtx> for ForeignItemId\n \n     #[inline]\n     fn to_stable_hash_key(&self, hcx: &HirCtx) -> DefPathHash {\n-        self.def_id.to_stable_hash_key(hcx)\n+        self.def_id.def_id.to_stable_hash_key(hcx)\n     }\n }\n "}, {"sha": "0761d8cdbd8f641da9510c74fb0dc69871624256", "filename": "compiler/rustc_hir_analysis/Cargo.toml", "status": "renamed", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_hir_analysis%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_hir_analysis%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2FCargo.toml?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "patch": "@@ -1,5 +1,5 @@\n [package]\n-name = \"rustc_typeck\"\n+name = \"rustc_hir_analysis\"\n version = \"0.0.0\"\n edition = \"2021\"\n \n@@ -26,7 +26,6 @@ rustc_span = { path = \"../rustc_span\" }\n rustc_index = { path = \"../rustc_index\" }\n rustc_infer = { path = \"../rustc_infer\" }\n rustc_trait_selection = { path = \"../rustc_trait_selection\" }\n-rustc_ty_utils = { path = \"../rustc_ty_utils\" }\n rustc_lint = { path = \"../rustc_lint\" }\n rustc_serialize = { path = \"../rustc_serialize\" }\n rustc_type_ir = { path = \"../rustc_type_ir\" }", "previous_filename": "compiler/rustc_typeck/Cargo.toml"}, {"sha": "b61dbd8c9648e9d7b7023ddea262865b0c13b38b", "filename": "compiler/rustc_hir_analysis/README.md", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_hir_analysis%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_hir_analysis%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2FREADME.md?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "previous_filename": "compiler/rustc_typeck/README.md"}, {"sha": "a9152bdc59787a2f586138c43e550ce83178566c", "filename": "compiler/rustc_hir_analysis/src/astconv/errors.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Ferrors.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "previous_filename": "compiler/rustc_typeck/src/astconv/errors.rs"}, {"sha": "47915b4bd4e6ce6ff6e3948d59d42e2e34709b01", "filename": "compiler/rustc_hir_analysis/src/astconv/generics.rs", "status": "renamed", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fgenerics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fgenerics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fgenerics.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "patch": "@@ -83,9 +83,9 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 Res::Def(DefKind::TyParam, src_def_id) => {\n                     if let Some(param_local_id) = param.def_id.as_local() {\n                         let param_name = tcx.hir().ty_param_name(param_local_id);\n-                        let param_type = tcx.infer_ctxt().enter(|infcx| {\n-                            infcx.resolve_numeric_literals_with_default(tcx.type_of(param.def_id))\n-                        });\n+                        let infcx = tcx.infer_ctxt().build();\n+                        let param_type =\n+                            infcx.resolve_numeric_literals_with_default(tcx.type_of(param.def_id));\n                         if param_type.is_suggestable(tcx, false) {\n                             err.span_suggestion(\n                                 tcx.def_span(src_def_id),\n@@ -448,8 +448,8 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         let infer_lifetimes =\n             (gen_pos != GenericArgPosition::Type || infer_args) && !gen_args.has_lifetime_params();\n \n-        if gen_pos != GenericArgPosition::Type && !gen_args.bindings.is_empty() {\n-            Self::prohibit_assoc_ty_binding(tcx, gen_args.bindings[0].span);\n+        if gen_pos != GenericArgPosition::Type && let Some(b) = gen_args.bindings.first() {\n+            Self::prohibit_assoc_ty_binding(tcx, b.span);\n         }\n \n         let explicit_late_bound =\n@@ -649,9 +649,8 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                     LATE_BOUND_LIFETIME_ARGUMENTS,\n                     args.args[0].hir_id(),\n                     multispan,\n-                    |lint| {\n-                        lint.build(msg).emit();\n-                    },\n+                    msg,\n+                    |lint| lint,\n                 );\n             }\n ", "previous_filename": "compiler/rustc_typeck/src/astconv/generics.rs"}, {"sha": "6e373e41b4c026046e0725e702a6edca7e07790e", "filename": "compiler/rustc_hir_analysis/src/astconv/mod.rs", "status": "renamed", "additions": 53, "deletions": 56, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "patch": "@@ -276,9 +276,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             item_segment.infer_args,\n             None,\n         );\n-        let assoc_bindings = self.create_assoc_bindings_for_generic_args(item_segment.args());\n-\n-        if let Some(b) = assoc_bindings.first() {\n+        if let Some(b) = item_segment.args().bindings.first() {\n             Self::prohibit_assoc_ty_binding(self.tcx(), b.span);\n         }\n \n@@ -365,7 +363,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         // here and so associated type bindings will be handled regardless of whether there are any\n         // non-`Self` generic parameters.\n         if generics.params.is_empty() {\n-            return (tcx.intern_substs(&[]), arg_count);\n+            return (tcx.intern_substs(parent_substs), arg_count);\n         }\n \n         struct SubstsForAstPathCtxt<'a, 'tcx> {\n@@ -586,7 +584,6 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n \n     pub(crate) fn create_substs_for_associated_item(\n         &self,\n-        tcx: TyCtxt<'tcx>,\n         span: Span,\n         item_def_id: DefId,\n         item_segment: &hir::PathSegment<'_>,\n@@ -596,22 +593,21 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             \"create_substs_for_associated_item(span: {:?}, item_def_id: {:?}, item_segment: {:?}\",\n             span, item_def_id, item_segment\n         );\n-        if tcx.generics_of(item_def_id).params.is_empty() {\n-            self.prohibit_generics(slice::from_ref(item_segment).iter(), |_| {});\n+        let (args, _) = self.create_substs_for_ast_path(\n+            span,\n+            item_def_id,\n+            parent_substs,\n+            item_segment,\n+            item_segment.args(),\n+            item_segment.infer_args,\n+            None,\n+        );\n \n-            parent_substs\n-        } else {\n-            self.create_substs_for_ast_path(\n-                span,\n-                item_def_id,\n-                parent_substs,\n-                item_segment,\n-                item_segment.args(),\n-                item_segment.infer_args,\n-                None,\n-            )\n-            .0\n+        if let Some(b) = item_segment.args().bindings.first() {\n+            Self::prohibit_assoc_ty_binding(self.tcx(), b.span);\n         }\n+\n+        args\n     }\n \n     /// Instantiates the path for the given trait reference, assuming that it's\n@@ -795,8 +791,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             trait_segment,\n             is_impl,\n         );\n-        let assoc_bindings = self.create_assoc_bindings_for_generic_args(trait_segment.args());\n-        if let Some(b) = assoc_bindings.first() {\n+        if let Some(b) = trait_segment.args().bindings.first() {\n             Self::prohibit_assoc_ty_binding(self.tcx(), b.span);\n         }\n         ty::TraitRef::new(trait_def_id, substs)\n@@ -1121,7 +1116,6 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             };\n \n             let substs_trait_ref_and_assoc_item = self.create_substs_for_associated_item(\n-                tcx,\n                 path_span,\n                 assoc_item.def_id,\n                 &item_segment,\n@@ -1904,7 +1898,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         // Find the type of the associated item, and the trait where the associated\n         // item is declared.\n         let bound = match (&qself_ty.kind(), qself_res) {\n-            (_, Res::SelfTy { trait_: Some(_), alias_to: Some((impl_def_id, _)) }) => {\n+            (_, Res::SelfTyAlias { alias_to: impl_def_id, is_trait_impl: true, .. }) => {\n                 // `Self` in an impl of a trait -- we have a concrete self type and a\n                 // trait reference.\n                 let Some(trait_ref) = tcx.impl_trait_ref(impl_def_id) else {\n@@ -1923,8 +1917,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             }\n             (\n                 &ty::Param(_),\n-                Res::SelfTy { trait_: Some(param_did), alias_to: None }\n-                | Res::Def(DefKind::TyParam, param_did),\n+                Res::SelfTyParam { trait_: param_did } | Res::Def(DefKind::TyParam, param_did),\n             ) => self.find_bound_for_assoc_item(param_did.expect_local(), assoc_ident, span)?,\n             _ => {\n                 let reported = if variant_resolution.is_some() {\n@@ -2017,30 +2010,35 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         tcx.check_stability(item.def_id, Some(hir_ref_id), span, None);\n \n         if let Some(variant_def_id) = variant_resolution {\n-            tcx.struct_span_lint_hir(AMBIGUOUS_ASSOCIATED_ITEMS, hir_ref_id, span, |lint| {\n-                let mut err = lint.build(\"ambiguous associated item\");\n-                let mut could_refer_to = |kind: DefKind, def_id, also| {\n-                    let note_msg = format!(\n-                        \"`{}` could{} refer to the {} defined here\",\n-                        assoc_ident,\n-                        also,\n-                        kind.descr(def_id)\n-                    );\n-                    err.span_note(tcx.def_span(def_id), &note_msg);\n-                };\n+            tcx.struct_span_lint_hir(\n+                AMBIGUOUS_ASSOCIATED_ITEMS,\n+                hir_ref_id,\n+                span,\n+                \"ambiguous associated item\",\n+                |lint| {\n+                    let mut could_refer_to = |kind: DefKind, def_id, also| {\n+                        let note_msg = format!(\n+                            \"`{}` could{} refer to the {} defined here\",\n+                            assoc_ident,\n+                            also,\n+                            kind.descr(def_id)\n+                        );\n+                        lint.span_note(tcx.def_span(def_id), &note_msg);\n+                    };\n \n-                could_refer_to(DefKind::Variant, variant_def_id, \"\");\n-                could_refer_to(kind, item.def_id, \" also\");\n+                    could_refer_to(DefKind::Variant, variant_def_id, \"\");\n+                    could_refer_to(kind, item.def_id, \" also\");\n \n-                err.span_suggestion(\n-                    span,\n-                    \"use fully-qualified syntax\",\n-                    format!(\"<{} as {}>::{}\", qself_ty, tcx.item_name(trait_did), assoc_ident),\n-                    Applicability::MachineApplicable,\n-                );\n+                    lint.span_suggestion(\n+                        span,\n+                        \"use fully-qualified syntax\",\n+                        format!(\"<{} as {}>::{}\", qself_ty, tcx.item_name(trait_did), assoc_ident),\n+                        Applicability::MachineApplicable,\n+                    );\n \n-                err.emit();\n-            });\n+                    lint\n+                },\n+            );\n         }\n         Ok((ty, kind, item.def_id))\n     }\n@@ -2100,7 +2098,6 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             self.ast_path_to_mono_trait_ref(span, trait_def_id, self_ty, trait_segment, false);\n \n         let item_substs = self.create_substs_for_associated_item(\n-            tcx,\n             span,\n             item_def_id,\n             item_segment,\n@@ -2211,8 +2208,8 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n \n         for segment in segments {\n             // Only emit the first error to avoid overloading the user with error messages.\n-            if let [binding, ..] = segment.args().bindings {\n-                Self::prohibit_assoc_ty_binding(self.tcx(), binding.span);\n+            if let Some(b) = segment.args().bindings.first() {\n+                Self::prohibit_assoc_ty_binding(self.tcx(), b.span);\n                 return true;\n             }\n         }\n@@ -2420,7 +2417,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 let index = generics.param_def_id_to_index[&def_id.to_def_id()];\n                 tcx.mk_ty_param(index, tcx.hir().ty_param_name(def_id))\n             }\n-            Res::SelfTy { trait_: Some(_), alias_to: None } => {\n+            Res::SelfTyParam { .. } => {\n                 // `Self` in trait or type alias.\n                 assert_eq!(opt_self_ty, None);\n                 self.prohibit_generics(path.segments.iter(), |err| {\n@@ -2435,7 +2432,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 });\n                 tcx.types.self_param\n             }\n-            Res::SelfTy { trait_: _, alias_to: Some((def_id, forbid_generic)) } => {\n+            Res::SelfTyAlias { alias_to: def_id, forbid_generic, .. } => {\n                 // `Self` in impl (we know the concrete type).\n                 assert_eq!(opt_self_ty, None);\n                 // Try to evaluate any array length constants.\n@@ -3003,7 +3000,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n     /// Make sure that we are in the condition to suggest the blanket implementation.\n     fn maybe_lint_blanket_trait_impl(&self, self_ty: &hir::Ty<'_>, diag: &mut Diagnostic) {\n         let tcx = self.tcx();\n-        let parent_id = tcx.hir().get_parent_item(self_ty.hir_id);\n+        let parent_id = tcx.hir().get_parent_item(self_ty.hir_id).def_id;\n         if let hir::Node::Item(hir::Item {\n             kind:\n                 hir::ItemKind::Impl(hir::Impl {\n@@ -3087,15 +3084,15 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                     BARE_TRAIT_OBJECTS,\n                     self_ty.hir_id,\n                     self_ty.span,\n+                    msg,\n                     |lint| {\n-                        let mut diag = lint.build(msg);\n-                        diag.multipart_suggestion_verbose(\n+                        lint.multipart_suggestion_verbose(\n                             \"use `dyn`\",\n                             sugg,\n                             Applicability::MachineApplicable,\n                         );\n-                        self.maybe_lint_blanket_trait_impl(&self_ty, &mut diag);\n-                        diag.emit();\n+                        self.maybe_lint_blanket_trait_impl(&self_ty, lint);\n+                        lint\n                     },\n                 );\n             }", "previous_filename": "compiler/rustc_typeck/src/astconv/mod.rs"}, {"sha": "6a28bb16a20acf2945f940d3f376d957529c3adf", "filename": "compiler/rustc_hir_analysis/src/bounds.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_hir_analysis%2Fsrc%2Fbounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_hir_analysis%2Fsrc%2Fbounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fbounds.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "previous_filename": "compiler/rustc_typeck/src/bounds.rs"}, {"sha": "143508b785f1e55891fbea3ce5be6698c2012c37", "filename": "compiler/rustc_hir_analysis/src/check/_match.rs", "status": "renamed", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2F_match.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "patch": "@@ -140,7 +140,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     let Some(ret) = self\n                         .tcx\n                         .hir()\n-                        .find_by_def_id(self.body_id.owner)\n+                        .find_by_def_id(self.body_id.owner.def_id)\n                         .and_then(|owner| owner.fn_decl())\n                         .map(|decl| decl.output.span())\n                     else { return; };\n@@ -259,7 +259,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 err.help(\"consider adding an `else` block that evaluates to the expected type\");\n                 error = true;\n             },\n-            ret_reason.is_none(),\n+            false,\n         );\n         error\n     }\n@@ -495,7 +495,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     .typeck_results\n                     .borrow()\n                     .liberated_fn_sigs()\n-                    .get(hir::HirId::make_owner(self.body_id.owner))?;\n+                    .get(hir::HirId::make_owner(self.body_id.owner.def_id))?;\n \n                 let substs = sig.output().walk().find_map(|arg| {\n                     if let ty::GenericArgKind::Type(ty) = arg.unpack()", "previous_filename": "compiler/rustc_typeck/src/check/_match.rs"}, {"sha": "59c366ad7d776cb41868bc18140e042f70ccab60", "filename": "compiler/rustc_hir_analysis/src/check/autoderef.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fautoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fautoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fautoderef.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "previous_filename": "compiler/rustc_typeck/src/check/autoderef.rs"}, {"sha": "088de1979babe5cf7a4423276d42bd8b99c1bfdc", "filename": "compiler/rustc_hir_analysis/src/check/callee.rs", "status": "renamed", "additions": 267, "deletions": 130, "changes": 397, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcallee.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "patch": "@@ -1,8 +1,10 @@\n+use super::method::probe::{IsSuggestion, Mode, ProbeScope};\n use super::method::MethodCallee;\n-use super::{DefIdOrName, Expectation, FnCtxt, TupleArgumentsFlag};\n+use super::{Expectation, FnCtxt, TupleArgumentsFlag};\n use crate::type_error_struct;\n \n-use rustc_errors::{struct_span_err, Applicability, Diagnostic};\n+use rustc_ast::util::parser::PREC_POSTFIX;\n+use rustc_errors::{struct_span_err, Applicability, Diagnostic, StashKey};\n use rustc_hir as hir;\n use rustc_hir::def::{self, Namespace, Res};\n use rustc_hir::def_id::DefId;\n@@ -25,6 +27,7 @@ use rustc_span::Span;\n use rustc_target::spec::abi;\n use rustc_trait_selection::autoderef::Autoderef;\n use rustc_trait_selection::infer::InferCtxtExt as _;\n+use rustc_trait_selection::traits::error_reporting::DefIdOrName;\n use rustc_trait_selection::traits::query::evaluate_obligation::InferCtxtExt as _;\n \n use std::iter;\n@@ -60,6 +63,7 @@ pub fn check_legal_trait_for_method_call(\n     }\n }\n \n+#[derive(Debug)]\n enum CallStep<'tcx> {\n     Builtin(Ty<'tcx>),\n     DeferredClosure(LocalDefId, ty::FnSig<'tcx>),\n@@ -188,6 +192,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 return None;\n             }\n \n+            ty::Error(_) => {\n+                return None;\n+            }\n+\n             _ => {}\n         }\n \n@@ -394,140 +402,32 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             }\n             ty::FnPtr(sig) => (sig, None),\n             _ => {\n-                let mut unit_variant = None;\n-                if let hir::ExprKind::Path(qpath) = &callee_expr.kind\n-                    && let Res::Def(def::DefKind::Ctor(kind, def::CtorKind::Const), _)\n-                        = self.typeck_results.borrow().qpath_res(qpath, callee_expr.hir_id)\n-                    // Only suggest removing parens if there are no arguments\n-                    && arg_exprs.is_empty()\n+                if let hir::ExprKind::Path(hir::QPath::Resolved(_, path)) = &callee_expr.kind\n+                    && let [segment] = path.segments\n+                    && let Some(mut diag) = self\n+                        .tcx\n+                        .sess\n+                        .diagnostic()\n+                        .steal_diagnostic(segment.ident.span, StashKey::CallIntoMethod)\n                 {\n-                    let descr = match kind {\n-                        def::CtorOf::Struct => \"struct\",\n-                        def::CtorOf::Variant => \"enum variant\",\n-                    };\n-                    let removal_span =\n-                        callee_expr.span.shrink_to_hi().to(call_expr.span.shrink_to_hi());\n-                    unit_variant =\n-                        Some((removal_span, descr, rustc_hir_pretty::qpath_to_string(qpath)));\n-                }\n-\n-                let callee_ty = self.resolve_vars_if_possible(callee_ty);\n-                let mut err = type_error_struct!(\n-                    self.tcx.sess,\n-                    callee_expr.span,\n-                    callee_ty,\n-                    E0618,\n-                    \"expected function, found {}\",\n-                    match &unit_variant {\n-                        Some((_, kind, path)) => format!(\"{kind} `{path}`\"),\n-                        None => format!(\"`{callee_ty}`\"),\n-                    }\n-                );\n-\n-                self.identify_bad_closure_def_and_call(\n-                    &mut err,\n-                    call_expr.hir_id,\n-                    &callee_expr.kind,\n-                    callee_expr.span,\n-                );\n-\n-                if let Some((removal_span, kind, path)) = &unit_variant {\n-                    err.span_suggestion_verbose(\n-                        *removal_span,\n-                        &format!(\n-                            \"`{path}` is a unit {kind}, and does not take parentheses to be constructed\",\n-                        ),\n-                        \"\",\n-                        Applicability::MachineApplicable,\n-                    );\n-                }\n-\n-                let mut inner_callee_path = None;\n-                let def = match callee_expr.kind {\n-                    hir::ExprKind::Path(ref qpath) => {\n-                        self.typeck_results.borrow().qpath_res(qpath, callee_expr.hir_id)\n-                    }\n-                    hir::ExprKind::Call(ref inner_callee, _) => {\n-                        // If the call spans more than one line and the callee kind is\n-                        // itself another `ExprCall`, that's a clue that we might just be\n-                        // missing a semicolon (Issue #51055)\n-                        let call_is_multiline =\n-                            self.tcx.sess.source_map().is_multiline(call_expr.span);\n-                        if call_is_multiline {\n-                            err.span_suggestion(\n-                                callee_expr.span.shrink_to_hi(),\n-                                \"consider using a semicolon here\",\n-                                \";\",\n-                                Applicability::MaybeIncorrect,\n-                            );\n-                        }\n-                        if let hir::ExprKind::Path(ref inner_qpath) = inner_callee.kind {\n-                            inner_callee_path = Some(inner_qpath);\n-                            self.typeck_results.borrow().qpath_res(inner_qpath, inner_callee.hir_id)\n-                        } else {\n-                            Res::Err\n-                        }\n-                    }\n-                    _ => Res::Err,\n-                };\n-\n-                if !self.maybe_suggest_bad_array_definition(&mut err, call_expr, callee_expr) {\n-                    if let Some((maybe_def, output_ty, _)) = self.extract_callable_info(callee_expr, callee_ty)\n-                        && !self.type_is_sized_modulo_regions(self.param_env, output_ty, callee_expr.span)\n+                    // Try suggesting `foo(a)` -> `a.foo()` if possible.\n+                    if let Some(ty) =\n+                        self.suggest_call_as_method(\n+                            &mut diag,\n+                            segment,\n+                            arg_exprs,\n+                            call_expr,\n+                            expected\n+                        )\n                     {\n-                        let descr = match maybe_def {\n-                            DefIdOrName::DefId(def_id) => self.tcx.def_kind(def_id).descr(def_id),\n-                            DefIdOrName::Name(name) => name,\n-                        };\n-                        err.span_label(\n-                            callee_expr.span,\n-                            format!(\"this {descr} returns an unsized value `{output_ty}`, so it cannot be called\")\n-                        );\n-                        if let DefIdOrName::DefId(def_id) = maybe_def\n-                            && let Some(def_span) = self.tcx.hir().span_if_local(def_id)\n-                        {\n-                            err.span_label(def_span, \"the callable type is defined here\");\n-                        }\n+                        diag.emit();\n+                        return ty;\n                     } else {\n-                        err.span_label(call_expr.span, \"call expression requires function\");\n+                        diag.emit();\n                     }\n                 }\n \n-                if let Some(span) = self.tcx.hir().res_span(def) {\n-                    let callee_ty = callee_ty.to_string();\n-                    let label = match (unit_variant, inner_callee_path) {\n-                        (Some((_, kind, path)), _) => Some(format!(\"{kind} `{path}` defined here\")),\n-                        (_, Some(hir::QPath::Resolved(_, path))) => self\n-                            .tcx\n-                            .sess\n-                            .source_map()\n-                            .span_to_snippet(path.span)\n-                            .ok()\n-                            .map(|p| format!(\"`{p}` defined here returns `{callee_ty}`\")),\n-                        _ => {\n-                            match def {\n-                                // Emit a different diagnostic for local variables, as they are not\n-                                // type definitions themselves, but rather variables *of* that type.\n-                                Res::Local(hir_id) => Some(format!(\n-                                    \"`{}` has type `{}`\",\n-                                    self.tcx.hir().name(hir_id),\n-                                    callee_ty\n-                                )),\n-                                Res::Def(kind, def_id) if kind.ns() == Some(Namespace::ValueNS) => {\n-                                    Some(format!(\n-                                        \"`{}` defined here\",\n-                                        self.tcx.def_path_str(def_id),\n-                                    ))\n-                                }\n-                                _ => Some(format!(\"`{callee_ty}` defined here\")),\n-                            }\n-                        }\n-                    };\n-                    if let Some(label) = label {\n-                        err.span_label(span, label);\n-                    }\n-                }\n-                err.emit();\n+                self.report_invalid_callee(call_expr, callee_expr, callee_ty, arg_exprs);\n \n                 // This is the \"default\" function signature, used in case of error.\n                 // In that case, we check each argument against \"error\" in order to\n@@ -574,6 +474,243 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         fn_sig.output()\n     }\n \n+    /// Attempts to reinterpret `method(rcvr, args...)` as `rcvr.method(args...)`\n+    /// and suggesting the fix if the method probe is successful.\n+    fn suggest_call_as_method(\n+        &self,\n+        diag: &mut Diagnostic,\n+        segment: &'tcx hir::PathSegment<'tcx>,\n+        arg_exprs: &'tcx [hir::Expr<'tcx>],\n+        call_expr: &'tcx hir::Expr<'tcx>,\n+        expected: Expectation<'tcx>,\n+    ) -> Option<Ty<'tcx>> {\n+        if let [callee_expr, rest @ ..] = arg_exprs {\n+            let callee_ty = self.check_expr(callee_expr);\n+            // First, do a probe with `IsSuggestion(true)` to avoid emitting\n+            // any strange errors. If it's successful, then we'll do a true\n+            // method lookup.\n+            let Ok(pick) = self\n+            .probe_for_name(\n+                call_expr.span,\n+                Mode::MethodCall,\n+                segment.ident,\n+                IsSuggestion(true),\n+                callee_ty,\n+                call_expr.hir_id,\n+                // We didn't record the in scope traits during late resolution\n+                // so we need to probe AllTraits unfortunately\n+                ProbeScope::AllTraits,\n+            ) else {\n+                return None;\n+            };\n+\n+            let pick = self.confirm_method(\n+                call_expr.span,\n+                callee_expr,\n+                call_expr,\n+                callee_ty,\n+                pick,\n+                segment,\n+            );\n+            if pick.illegal_sized_bound.is_some() {\n+                return None;\n+            }\n+\n+            let up_to_rcvr_span = segment.ident.span.until(callee_expr.span);\n+            let rest_span = callee_expr.span.shrink_to_hi().to(call_expr.span.shrink_to_hi());\n+            let rest_snippet = if let Some(first) = rest.first() {\n+                self.tcx\n+                    .sess\n+                    .source_map()\n+                    .span_to_snippet(first.span.to(call_expr.span.shrink_to_hi()))\n+            } else {\n+                Ok(\")\".to_string())\n+            };\n+\n+            if let Ok(rest_snippet) = rest_snippet {\n+                let sugg = if callee_expr.precedence().order() >= PREC_POSTFIX {\n+                    vec![\n+                        (up_to_rcvr_span, \"\".to_string()),\n+                        (rest_span, format!(\".{}({rest_snippet}\", segment.ident)),\n+                    ]\n+                } else {\n+                    vec![\n+                        (up_to_rcvr_span, \"(\".to_string()),\n+                        (rest_span, format!(\").{}({rest_snippet}\", segment.ident)),\n+                    ]\n+                };\n+                let self_ty = self.resolve_vars_if_possible(pick.callee.sig.inputs()[0]);\n+                diag.multipart_suggestion(\n+                    format!(\n+                        \"use the `.` operator to call the method `{}{}` on `{self_ty}`\",\n+                        self.tcx\n+                            .associated_item(pick.callee.def_id)\n+                            .trait_container(self.tcx)\n+                            .map_or_else(\n+                                || String::new(),\n+                                |trait_def_id| self.tcx.def_path_str(trait_def_id) + \"::\"\n+                            ),\n+                        segment.ident\n+                    ),\n+                    sugg,\n+                    Applicability::MaybeIncorrect,\n+                );\n+\n+                // Let's check the method fully now\n+                let return_ty = self.check_method_argument_types(\n+                    segment.ident.span,\n+                    call_expr,\n+                    Ok(pick.callee),\n+                    rest,\n+                    TupleArgumentsFlag::DontTupleArguments,\n+                    expected,\n+                );\n+\n+                return Some(return_ty);\n+            }\n+        }\n+\n+        None\n+    }\n+\n+    fn report_invalid_callee(\n+        &self,\n+        call_expr: &'tcx hir::Expr<'tcx>,\n+        callee_expr: &'tcx hir::Expr<'tcx>,\n+        callee_ty: Ty<'tcx>,\n+        arg_exprs: &'tcx [hir::Expr<'tcx>],\n+    ) {\n+        let mut unit_variant = None;\n+        if let hir::ExprKind::Path(qpath) = &callee_expr.kind\n+            && let Res::Def(def::DefKind::Ctor(kind, def::CtorKind::Const), _)\n+                = self.typeck_results.borrow().qpath_res(qpath, callee_expr.hir_id)\n+            // Only suggest removing parens if there are no arguments\n+            && arg_exprs.is_empty()\n+        {\n+            let descr = match kind {\n+                def::CtorOf::Struct => \"struct\",\n+                def::CtorOf::Variant => \"enum variant\",\n+            };\n+            let removal_span = callee_expr.span.shrink_to_hi().to(call_expr.span.shrink_to_hi());\n+            unit_variant = Some((removal_span, descr, rustc_hir_pretty::qpath_to_string(qpath)));\n+        }\n+\n+        let callee_ty = self.resolve_vars_if_possible(callee_ty);\n+        let mut err = type_error_struct!(\n+            self.tcx.sess,\n+            callee_expr.span,\n+            callee_ty,\n+            E0618,\n+            \"expected function, found {}\",\n+            match &unit_variant {\n+                Some((_, kind, path)) => format!(\"{kind} `{path}`\"),\n+                None => format!(\"`{callee_ty}`\"),\n+            }\n+        );\n+\n+        self.identify_bad_closure_def_and_call(\n+            &mut err,\n+            call_expr.hir_id,\n+            &callee_expr.kind,\n+            callee_expr.span,\n+        );\n+\n+        if let Some((removal_span, kind, path)) = &unit_variant {\n+            err.span_suggestion_verbose(\n+                *removal_span,\n+                &format!(\n+                    \"`{path}` is a unit {kind}, and does not take parentheses to be constructed\",\n+                ),\n+                \"\",\n+                Applicability::MachineApplicable,\n+            );\n+        }\n+\n+        let mut inner_callee_path = None;\n+        let def = match callee_expr.kind {\n+            hir::ExprKind::Path(ref qpath) => {\n+                self.typeck_results.borrow().qpath_res(qpath, callee_expr.hir_id)\n+            }\n+            hir::ExprKind::Call(ref inner_callee, _) => {\n+                // If the call spans more than one line and the callee kind is\n+                // itself another `ExprCall`, that's a clue that we might just be\n+                // missing a semicolon (Issue #51055)\n+                let call_is_multiline = self.tcx.sess.source_map().is_multiline(call_expr.span);\n+                if call_is_multiline {\n+                    err.span_suggestion(\n+                        callee_expr.span.shrink_to_hi(),\n+                        \"consider using a semicolon here\",\n+                        \";\",\n+                        Applicability::MaybeIncorrect,\n+                    );\n+                }\n+                if let hir::ExprKind::Path(ref inner_qpath) = inner_callee.kind {\n+                    inner_callee_path = Some(inner_qpath);\n+                    self.typeck_results.borrow().qpath_res(inner_qpath, inner_callee.hir_id)\n+                } else {\n+                    Res::Err\n+                }\n+            }\n+            _ => Res::Err,\n+        };\n+\n+        if !self.maybe_suggest_bad_array_definition(&mut err, call_expr, callee_expr) {\n+            if let Some((maybe_def, output_ty, _)) =\n+                self.extract_callable_info(callee_expr, callee_ty)\n+                && !self.type_is_sized_modulo_regions(self.param_env, output_ty, callee_expr.span)\n+            {\n+                let descr = match maybe_def {\n+                    DefIdOrName::DefId(def_id) => self.tcx.def_kind(def_id).descr(def_id),\n+                    DefIdOrName::Name(name) => name,\n+                };\n+                err.span_label(\n+                    callee_expr.span,\n+                    format!(\"this {descr} returns an unsized value `{output_ty}`, so it cannot be called\")\n+                );\n+                if let DefIdOrName::DefId(def_id) = maybe_def\n+                    && let Some(def_span) = self.tcx.hir().span_if_local(def_id)\n+                {\n+                    err.span_label(def_span, \"the callable type is defined here\");\n+                }\n+            } else {\n+                err.span_label(call_expr.span, \"call expression requires function\");\n+            }\n+        }\n+\n+        if let Some(span) = self.tcx.hir().res_span(def) {\n+            let callee_ty = callee_ty.to_string();\n+            let label = match (unit_variant, inner_callee_path) {\n+                (Some((_, kind, path)), _) => Some(format!(\"{kind} `{path}` defined here\")),\n+                (_, Some(hir::QPath::Resolved(_, path))) => self\n+                    .tcx\n+                    .sess\n+                    .source_map()\n+                    .span_to_snippet(path.span)\n+                    .ok()\n+                    .map(|p| format!(\"`{p}` defined here returns `{callee_ty}`\")),\n+                _ => {\n+                    match def {\n+                        // Emit a different diagnostic for local variables, as they are not\n+                        // type definitions themselves, but rather variables *of* that type.\n+                        Res::Local(hir_id) => Some(format!(\n+                            \"`{}` has type `{}`\",\n+                            self.tcx.hir().name(hir_id),\n+                            callee_ty\n+                        )),\n+                        Res::Def(kind, def_id) if kind.ns() == Some(Namespace::ValueNS) => {\n+                            Some(format!(\"`{}` defined here\", self.tcx.def_path_str(def_id),))\n+                        }\n+                        _ => Some(format!(\"`{callee_ty}` defined here\")),\n+                    }\n+                }\n+            };\n+            if let Some(label) = label {\n+                err.span_label(span, label);\n+            }\n+        }\n+        err.emit();\n+    }\n+\n     fn confirm_deferred_closure_call(\n         &self,\n         call_expr: &'tcx hir::Expr<'tcx>,", "previous_filename": "compiler/rustc_typeck/src/check/callee.rs"}, {"sha": "51abdd2e059d71b11664d1dbe27968362cb7cf99", "filename": "compiler/rustc_hir_analysis/src/check/cast.rs", "status": "renamed", "additions": 44, "deletions": 112, "changes": 156, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcast.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "patch": "@@ -33,15 +33,14 @@ use super::FnCtxt;\n use crate::hir::def_id::DefId;\n use crate::type_error_struct;\n use hir::def_id::LOCAL_CRATE;\n-use rustc_errors::{struct_span_err, Applicability, DiagnosticBuilder, ErrorGuaranteed};\n+use rustc_errors::{struct_span_err, Applicability, DelayDm, DiagnosticBuilder, ErrorGuaranteed};\n use rustc_hir as hir;\n-use rustc_infer::traits::{Obligation, ObligationCause, ObligationCauseCode};\n use rustc_middle::mir::Mutability;\n use rustc_middle::ty::adjustment::AllowTwoPhase;\n use rustc_middle::ty::cast::{CastKind, CastTy};\n use rustc_middle::ty::error::TypeError;\n use rustc_middle::ty::subst::SubstsRef;\n-use rustc_middle::ty::{self, Binder, Ty, TypeAndMut, TypeVisitable, VariantDef};\n+use rustc_middle::ty::{self, Ty, TypeAndMut, TypeVisitable, VariantDef};\n use rustc_session::lint;\n use rustc_session::Session;\n use rustc_span::symbol::sym;\n@@ -204,76 +203,8 @@ fn make_invalid_casting_error<'a, 'tcx>(\n     )\n }\n \n-pub enum CastCheckResult<'tcx> {\n-    Ok,\n-    Deferred(CastCheck<'tcx>),\n-    Err(ErrorGuaranteed),\n-}\n-\n-pub fn check_cast<'tcx>(\n-    fcx: &FnCtxt<'_, 'tcx>,\n-    expr: &'tcx hir::Expr<'tcx>,\n-    expr_ty: Ty<'tcx>,\n-    cast_ty: Ty<'tcx>,\n-    cast_span: Span,\n-    span: Span,\n-) -> CastCheckResult<'tcx> {\n-    if cast_ty.is_dyn_star() {\n-        check_dyn_star_cast(fcx, expr, expr_ty, cast_ty)\n-    } else {\n-        match CastCheck::new(fcx, expr, expr_ty, cast_ty, cast_span, span) {\n-            Ok(check) => CastCheckResult::Deferred(check),\n-            Err(e) => CastCheckResult::Err(e),\n-        }\n-    }\n-}\n-\n-fn check_dyn_star_cast<'tcx>(\n-    fcx: &FnCtxt<'_, 'tcx>,\n-    expr: &'tcx hir::Expr<'tcx>,\n-    expr_ty: Ty<'tcx>,\n-    cast_ty: Ty<'tcx>,\n-) -> CastCheckResult<'tcx> {\n-    // Find the bounds in the dyn*. For eaxmple, if we have\n-    //\n-    //    let x = 22_usize as dyn* (Clone + Debug + 'static)\n-    //\n-    // this would return `existential_predicates = [?Self: Clone, ?Self: Debug]` and `region = 'static`.\n-    let (existential_predicates, region) = match cast_ty.kind() {\n-        ty::Dynamic(predicates, region, ty::DynStar) => (predicates, region),\n-        _ => panic!(\"Invalid dyn* cast_ty\"),\n-    };\n-\n-    let cause = ObligationCause::new(\n-        expr.span,\n-        fcx.body_id,\n-        // FIXME(dyn-star): Use a better obligation cause code\n-        ObligationCauseCode::MiscObligation,\n-    );\n-\n-    // For each existential predicate (e.g., `?Self: Clone`) substitute\n-    // the type of the expression (e.g., `usize` in our example above)\n-    // and then require that the resulting predicate (e.g., `usize: Clone`)\n-    // holds (it does).\n-    for existential_predicate in existential_predicates.iter() {\n-        let predicate = existential_predicate.with_self_ty(fcx.tcx, expr_ty);\n-        fcx.register_predicate(Obligation::new(cause.clone(), fcx.param_env, predicate));\n-    }\n-\n-    // Enforce the region bound `'static` (e.g., `usize: 'static`, in our example).\n-    fcx.register_predicate(Obligation::new(\n-        cause,\n-        fcx.param_env,\n-        fcx.tcx.mk_predicate(Binder::dummy(ty::PredicateKind::TypeOutlives(\n-            ty::OutlivesPredicate(expr_ty, *region),\n-        ))),\n-    ));\n-\n-    CastCheckResult::Ok\n-}\n-\n impl<'a, 'tcx> CastCheck<'tcx> {\n-    fn new(\n+    pub fn new(\n         fcx: &FnCtxt<'a, 'tcx>,\n         expr: &'tcx hir::Expr<'tcx>,\n         expr_ty: Ty<'tcx>,\n@@ -754,19 +685,25 @@ impl<'a, 'tcx> CastCheck<'tcx> {\n         } else {\n             (\"\", lint::builtin::TRIVIAL_CASTS)\n         };\n-        fcx.tcx.struct_span_lint_hir(lint, self.expr.hir_id, self.span, |err| {\n-            err.build(&format!(\n-                \"trivial {}cast: `{}` as `{}`\",\n-                adjective,\n-                fcx.ty_to_string(t_expr),\n-                fcx.ty_to_string(t_cast)\n-            ))\n-            .help(&format!(\n-                \"cast can be replaced by coercion; this might \\\n-                                   require {type_asc_or}a temporary variable\"\n-            ))\n-            .emit();\n-        });\n+        fcx.tcx.struct_span_lint_hir(\n+            lint,\n+            self.expr.hir_id,\n+            self.span,\n+            DelayDm(|| {\n+                format!(\n+                    \"trivial {}cast: `{}` as `{}`\",\n+                    adjective,\n+                    fcx.ty_to_string(t_expr),\n+                    fcx.ty_to_string(t_cast)\n+                )\n+            }),\n+            |lint| {\n+                lint.help(format!(\n+                    \"cast can be replaced by coercion; this might \\\n+                     require {type_asc_or}a temporary variable\"\n+                ))\n+            },\n+        );\n     }\n \n     #[instrument(skip(fcx), level = \"debug\")]\n@@ -928,11 +865,7 @@ impl<'a, 'tcx> CastCheck<'tcx> {\n \n             (Int(_) | Float, Int(_) | Float) => Ok(CastKind::NumericCast),\n \n-            // FIXME(dyn-star): this needs more conditions...\n-            (_, DynStar) => Ok(CastKind::DynStarCast),\n-\n-            // FIXME(dyn-star): do we want to allow dyn* upcasting or other casts?\n-            (DynStar, _) => Err(CastError::IllegalCast),\n+            (_, DynStar) | (DynStar, _) => bug!(\"should be handled by `try_coerce`\"),\n         }\n     }\n \n@@ -1074,12 +1007,12 @@ impl<'a, 'tcx> CastCheck<'tcx> {\n                 lint::builtin::CENUM_IMPL_DROP_CAST,\n                 self.expr.hir_id,\n                 self.span,\n-                |err| {\n-                    err.build(&format!(\n-                        \"cannot cast enum `{}` into integer `{}` because it implements `Drop`\",\n-                        self.expr_ty, self.cast_ty\n-                    ))\n-                    .emit();\n+                DelayDm(|| format!(\n+                    \"cannot cast enum `{}` into integer `{}` because it implements `Drop`\",\n+                    self.expr_ty, self.cast_ty\n+                )),\n+                |lint| {\n+                    lint\n                 },\n             );\n         }\n@@ -1090,12 +1023,11 @@ impl<'a, 'tcx> CastCheck<'tcx> {\n             lint::builtin::LOSSY_PROVENANCE_CASTS,\n             self.expr.hir_id,\n             self.span,\n-            |err| {\n-                let mut err = err.build(&format!(\n+            DelayDm(|| format!(\n                     \"under strict provenance it is considered bad style to cast pointer `{}` to integer `{}`\",\n                     self.expr_ty, self.cast_ty\n-                ));\n-\n+                )),\n+            |lint| {\n                 let msg = \"use `.addr()` to obtain the address of a pointer\";\n \n                 let expr_prec = self.expr.precedence().order();\n@@ -1114,22 +1046,22 @@ impl<'a, 'tcx> CastCheck<'tcx> {\n                         (cast_span, format!(\").addr(){scalar_cast}\")),\n                     ];\n \n-                    err.multipart_suggestion(msg, suggestions, Applicability::MaybeIncorrect);\n+                    lint.multipart_suggestion(msg, suggestions, Applicability::MaybeIncorrect);\n                 } else {\n-                    err.span_suggestion(\n+                    lint.span_suggestion(\n                         cast_span,\n                         msg,\n                         format!(\".addr(){scalar_cast}\"),\n                         Applicability::MaybeIncorrect,\n                     );\n                 }\n \n-                err.help(\n+                lint.help(\n                     \"if you can't comply with strict provenance and need to expose the pointer \\\n                     provenance you can use `.expose_addr()` instead\"\n                 );\n \n-                err.emit();\n+                lint\n             },\n         );\n     }\n@@ -1139,24 +1071,24 @@ impl<'a, 'tcx> CastCheck<'tcx> {\n             lint::builtin::FUZZY_PROVENANCE_CASTS,\n             self.expr.hir_id,\n             self.span,\n-            |err| {\n-                let mut err = err.build(&format!(\n-                    \"strict provenance disallows casting integer `{}` to pointer `{}`\",\n-                    self.expr_ty, self.cast_ty\n-                ));\n+            DelayDm(|| format!(\n+                \"strict provenance disallows casting integer `{}` to pointer `{}`\",\n+                self.expr_ty, self.cast_ty\n+            )),\n+            |lint| {\n                 let msg = \"use `.with_addr()` to adjust a valid pointer in the same allocation, to this address\";\n                 let suggestions = vec![\n                     (self.expr_span.shrink_to_lo(), String::from(\"(...).with_addr(\")),\n                     (self.expr_span.shrink_to_hi().to(self.cast_span), String::from(\")\")),\n                 ];\n \n-                err.multipart_suggestion(msg, suggestions, Applicability::MaybeIncorrect);\n-                err.help(\n+                lint.multipart_suggestion(msg, suggestions, Applicability::MaybeIncorrect);\n+                lint.help(\n                     \"if you can't comply with strict provenance and don't have a pointer with \\\n                     the correct provenance you can use `std::ptr::from_exposed_addr()` instead\"\n                  );\n \n-                err.emit();\n+                lint\n             },\n         );\n     }", "previous_filename": "compiler/rustc_typeck/src/check/cast.rs"}, {"sha": "c3583eeb430be53112ce4d32064ddd9e912f3250", "filename": "compiler/rustc_hir_analysis/src/check/check.rs", "status": "renamed", "additions": 125, "deletions": 125, "changes": 250, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "patch": "@@ -2,7 +2,7 @@ use crate::check::intrinsicck::InlineAsmCtxt;\n \n use super::coercion::CoerceMany;\n use super::compare_method::check_type_bounds;\n-use super::compare_method::{compare_const_impl, compare_impl_method, compare_ty_impl};\n+use super::compare_method::{compare_impl_method, compare_ty_impl};\n use super::*;\n use rustc_attr as attr;\n use rustc_errors::{Applicability, ErrorGuaranteed, MultiSpan};\n@@ -29,9 +29,8 @@ use rustc_session::lint::builtin::{UNINHABITED_STATIC, UNSUPPORTED_CALLING_CONVE\n use rustc_span::symbol::sym;\n use rustc_span::{self, Span};\n use rustc_target::spec::abi::Abi;\n-use rustc_trait_selection::traits::error_reporting::InferCtxtExt as _;\n+use rustc_trait_selection::traits::error_reporting::TypeErrCtxtExt as _;\n use rustc_trait_selection::traits::{self, ObligationCtxt};\n-use rustc_ty_utils::representability::{self, Representability};\n \n use std::ops::ControlFlow;\n \n@@ -48,9 +47,13 @@ pub(super) fn check_abi(tcx: TyCtxt<'_>, hir_id: hir::HirId, span: Span, abi: Ab\n             .emit();\n         }\n         None => {\n-            tcx.struct_span_lint_hir(UNSUPPORTED_CALLING_CONVENTIONS, hir_id, span, |lint| {\n-                lint.build(\"use of calling convention not supported on this target\").emit();\n-            });\n+            tcx.struct_span_lint_hir(\n+                UNSUPPORTED_CALLING_CONVENTIONS,\n+                hir_id,\n+                span,\n+                \"use of calling convention not supported on this target\",\n+                |lint| lint,\n+            );\n         }\n     }\n \n@@ -74,7 +77,7 @@ pub(super) fn check_abi(tcx: TyCtxt<'_>, hir_id: hir::HirId, span: Span, abi: Ab\n /// * inherited: other fields inherited from the enclosing fn (if any)\n #[instrument(skip(inherited, body), level = \"debug\")]\n pub(super) fn check_fn<'a, 'tcx>(\n-    inherited: &'a Inherited<'a, 'tcx>,\n+    inherited: &'a Inherited<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n     fn_sig: ty::FnSig<'tcx>,\n     decl: &'tcx hir::FnDecl<'tcx>,\n@@ -377,7 +380,6 @@ fn check_struct(tcx: TyCtxt<'_>, def_id: LocalDefId) {\n     let def = tcx.adt_def(def_id);\n     let span = tcx.def_span(def_id);\n     def.destructor(tcx); // force the destructor to be evaluated\n-    check_representable(tcx, span, def_id);\n \n     if def.repr().simd() {\n         check_simd(tcx, span, def_id);\n@@ -391,7 +393,6 @@ fn check_union(tcx: TyCtxt<'_>, def_id: LocalDefId) {\n     let def = tcx.adt_def(def_id);\n     let span = tcx.def_span(def_id);\n     def.destructor(tcx); // force the destructor to be evaluated\n-    check_representable(tcx, span, def_id);\n     check_transparent(tcx, span, def);\n     check_union_fields(tcx, span, def_id);\n     check_packed(tcx, span, def);\n@@ -510,34 +511,44 @@ fn check_static_inhabited<'tcx>(tcx: TyCtxt<'tcx>, def_id: LocalDefId) {\n             UNINHABITED_STATIC,\n             tcx.hir().local_def_id_to_hir_id(def_id),\n             span,\n+            \"static of uninhabited type\",\n             |lint| {\n-                lint.build(\"static of uninhabited type\")\n+                lint\n                 .note(\"uninhabited statics cannot be initialized, and any access would be an immediate error\")\n-                .emit();\n             },\n         );\n     }\n }\n \n /// Checks that an opaque type does not contain cycles and does not use `Self` or `T::Foo`\n /// projections that would result in \"inheriting lifetimes\".\n-pub(super) fn check_opaque<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    def_id: LocalDefId,\n-    substs: SubstsRef<'tcx>,\n-    origin: &hir::OpaqueTyOrigin,\n-) {\n-    let span = tcx.def_span(def_id);\n-    check_opaque_for_inheriting_lifetimes(tcx, def_id, span);\n-    if tcx.type_of(def_id).references_error() {\n+fn check_opaque<'tcx>(tcx: TyCtxt<'tcx>, id: hir::ItemId) {\n+    let item = tcx.hir().item(id);\n+    let hir::ItemKind::OpaqueTy(hir::OpaqueTy { origin, .. }) = item.kind else {\n+        tcx.sess.delay_span_bug(tcx.hir().span(id.hir_id()), \"expected opaque item\");\n+        return;\n+    };\n+\n+    // HACK(jynelson): trying to infer the type of `impl trait` breaks documenting\n+    // `async-std` (and `pub async fn` in general).\n+    // Since rustdoc doesn't care about the concrete type behind `impl Trait`, just don't look at it!\n+    // See https://github.com/rust-lang/rust/issues/75100\n+    if tcx.sess.opts.actually_rustdoc {\n+        return;\n+    }\n+\n+    let substs = InternalSubsts::identity_for_item(tcx, item.def_id.to_def_id());\n+    let span = tcx.def_span(item.def_id.def_id);\n+\n+    check_opaque_for_inheriting_lifetimes(tcx, item.def_id.def_id, span);\n+    if tcx.type_of(item.def_id.def_id).references_error() {\n         return;\n     }\n-    if check_opaque_for_cycles(tcx, def_id, substs, span, origin).is_err() {\n+    if check_opaque_for_cycles(tcx, item.def_id.def_id, substs, span, &origin).is_err() {\n         return;\n     }\n-    check_opaque_meets_bounds(tcx, def_id, substs, span, origin);\n+    check_opaque_meets_bounds(tcx, item.def_id.def_id, substs, span, &origin);\n }\n-\n /// Checks that an opaque type does not use `Self` or `T::Foo` projections that would result\n /// in \"inheriting lifetimes\".\n #[instrument(level = \"debug\", skip(tcx, span))]\n@@ -609,9 +620,12 @@ pub(super) fn check_opaque_for_inheriting_lifetimes<'tcx>(\n         fn visit_ty(&mut self, arg: &'tcx hir::Ty<'tcx>) {\n             match arg.kind {\n                 hir::TyKind::Path(hir::QPath::Resolved(None, path)) => match &path.segments {\n-                    [PathSegment { res: Res::SelfTy { trait_: _, alias_to: impl_ref }, .. }] => {\n-                        let impl_ty_name =\n-                            impl_ref.map(|(def_id, _)| self.tcx.def_path_str(def_id));\n+                    [PathSegment { res: Res::SelfTyParam { .. }, .. }] => {\n+                        let impl_ty_name = None;\n+                        self.selftys.push((path.span, impl_ty_name));\n+                    }\n+                    [PathSegment { res: Res::SelfTyAlias { alias_to: def_id, .. }, .. }] => {\n+                        let impl_ty_name = Some(self.tcx.def_path_str(*def_id));\n                         self.selftys.push((path.span, impl_ty_name));\n                     }\n                     _ => {}\n@@ -701,10 +715,12 @@ pub(super) fn check_opaque_for_cycles<'tcx>(\n /// check those cases in the `param_env` of that function, which may have\n /// bounds not on this opaque type:\n ///\n-/// type X<T> = impl Clone\n+/// ```ignore (illustrative)\n+/// type X<T> = impl Clone;\n /// fn f<T: Clone>(t: T) -> X<T> {\n ///     t\n /// }\n+/// ```\n ///\n /// Without this check the above code is incorrectly accepted: we would ICE if\n /// some tried, for example, to clone an `Option<X<&mut ()>>`.\n@@ -716,61 +732,71 @@ fn check_opaque_meets_bounds<'tcx>(\n     span: Span,\n     origin: &hir::OpaqueTyOrigin,\n ) {\n-    let hidden_type = tcx.bound_type_of(def_id.to_def_id()).subst(tcx, substs);\n-\n     let hir_id = tcx.hir().local_def_id_to_hir_id(def_id);\n     let defining_use_anchor = match *origin {\n         hir::OpaqueTyOrigin::FnReturn(did) | hir::OpaqueTyOrigin::AsyncFn(did) => did,\n         hir::OpaqueTyOrigin::TyAlias => def_id,\n     };\n     let param_env = tcx.param_env(defining_use_anchor);\n \n-    tcx.infer_ctxt().with_opaque_type_inference(DefiningAnchor::Bind(defining_use_anchor)).enter(\n-        move |infcx| {\n-            let ocx = ObligationCtxt::new(&infcx);\n-            let opaque_ty = tcx.mk_opaque(def_id.to_def_id(), substs);\n+    let infcx = tcx\n+        .infer_ctxt()\n+        .with_opaque_type_inference(DefiningAnchor::Bind(defining_use_anchor))\n+        .build();\n+    let ocx = ObligationCtxt::new(&infcx);\n+    let opaque_ty = tcx.mk_opaque(def_id.to_def_id(), substs);\n+\n+    // `ReErased` regions appear in the \"parent_substs\" of closures/generators.\n+    // We're ignoring them here and replacing them with fresh region variables.\n+    // See tests in ui/type-alias-impl-trait/closure_{parent_substs,wf_outlives}.rs.\n+    //\n+    // FIXME: Consider wrapping the hidden type in an existential `Binder` and instantiating it\n+    // here rather than using ReErased.\n+    let hidden_ty = tcx.bound_type_of(def_id.to_def_id()).subst(tcx, substs);\n+    let hidden_ty = tcx.fold_regions(hidden_ty, |re, _dbi| match re.kind() {\n+        ty::ReErased => infcx.next_region_var(RegionVariableOrigin::MiscVariable(span)),\n+        _ => re,\n+    });\n \n-            let misc_cause = traits::ObligationCause::misc(span, hir_id);\n+    let misc_cause = traits::ObligationCause::misc(span, hir_id);\n \n-            match infcx.at(&misc_cause, param_env).eq(opaque_ty, hidden_type) {\n-                Ok(infer_ok) => ocx.register_infer_ok_obligations(infer_ok),\n-                Err(ty_err) => {\n-                    tcx.sess.delay_span_bug(\n-                        span,\n-                        &format!(\"could not unify `{hidden_type}` with revealed type:\\n{ty_err}\"),\n-                    );\n-                }\n-            }\n+    match infcx.at(&misc_cause, param_env).eq(opaque_ty, hidden_ty) {\n+        Ok(infer_ok) => ocx.register_infer_ok_obligations(infer_ok),\n+        Err(ty_err) => {\n+            tcx.sess.delay_span_bug(\n+                span,\n+                &format!(\"could not unify `{hidden_ty}` with revealed type:\\n{ty_err}\"),\n+            );\n+        }\n+    }\n \n-            // Additionally require the hidden type to be well-formed with only the generics of the opaque type.\n-            // Defining use functions may have more bounds than the opaque type, which is ok, as long as the\n-            // hidden type is well formed even without those bounds.\n-            let predicate = ty::Binder::dummy(ty::PredicateKind::WellFormed(hidden_type.into()))\n-                .to_predicate(tcx);\n-            ocx.register_obligation(Obligation::new(misc_cause, param_env, predicate));\n-\n-            // Check that all obligations are satisfied by the implementation's\n-            // version.\n-            let errors = ocx.select_all_or_error();\n-            if !errors.is_empty() {\n-                infcx.report_fulfillment_errors(&errors, None, false);\n-            }\n-            match origin {\n-                // Checked when type checking the function containing them.\n-                hir::OpaqueTyOrigin::FnReturn(..) | hir::OpaqueTyOrigin::AsyncFn(..) => {}\n-                // Can have different predicates to their defining use\n-                hir::OpaqueTyOrigin::TyAlias => {\n-                    let outlives_environment = OutlivesEnvironment::new(param_env);\n-                    infcx.check_region_obligations_and_report_errors(\n-                        defining_use_anchor,\n-                        &outlives_environment,\n-                    );\n-                }\n-            }\n-            // Clean up after ourselves\n-            let _ = infcx.inner.borrow_mut().opaque_type_storage.take_opaque_types();\n-        },\n-    );\n+    // Additionally require the hidden type to be well-formed with only the generics of the opaque type.\n+    // Defining use functions may have more bounds than the opaque type, which is ok, as long as the\n+    // hidden type is well formed even without those bounds.\n+    let predicate =\n+        ty::Binder::dummy(ty::PredicateKind::WellFormed(hidden_ty.into())).to_predicate(tcx);\n+    ocx.register_obligation(Obligation::new(misc_cause, param_env, predicate));\n+\n+    // Check that all obligations are satisfied by the implementation's\n+    // version.\n+    let errors = ocx.select_all_or_error();\n+    if !errors.is_empty() {\n+        infcx.err_ctxt().report_fulfillment_errors(&errors, None, false);\n+    }\n+    match origin {\n+        // Checked when type checking the function containing them.\n+        hir::OpaqueTyOrigin::FnReturn(..) | hir::OpaqueTyOrigin::AsyncFn(..) => {}\n+        // Can have different predicates to their defining use\n+        hir::OpaqueTyOrigin::TyAlias => {\n+            let outlives_environment = OutlivesEnvironment::new(param_env);\n+            infcx.check_region_obligations_and_report_errors(\n+                defining_use_anchor,\n+                &outlives_environment,\n+            );\n+        }\n+    }\n+    // Clean up after ourselves\n+    let _ = infcx.inner.borrow_mut().opaque_type_storage.take_opaque_types();\n }\n \n fn check_item_type<'tcx>(tcx: TyCtxt<'tcx>, id: hir::ItemId) {\n@@ -782,19 +808,19 @@ fn check_item_type<'tcx>(tcx: TyCtxt<'tcx>, id: hir::ItemId) {\n     let _indenter = indenter();\n     match tcx.def_kind(id.def_id) {\n         DefKind::Static(..) => {\n-            tcx.ensure().typeck(id.def_id);\n-            maybe_check_static_with_link_section(tcx, id.def_id);\n-            check_static_inhabited(tcx, id.def_id);\n+            tcx.ensure().typeck(id.def_id.def_id);\n+            maybe_check_static_with_link_section(tcx, id.def_id.def_id);\n+            check_static_inhabited(tcx, id.def_id.def_id);\n         }\n         DefKind::Const => {\n-            tcx.ensure().typeck(id.def_id);\n+            tcx.ensure().typeck(id.def_id.def_id);\n         }\n         DefKind::Enum => {\n             let item = tcx.hir().item(id);\n             let hir::ItemKind::Enum(ref enum_definition, _) = item.kind else {\n                 return;\n             };\n-            check_enum(tcx, &enum_definition.variants, item.def_id);\n+            check_enum(tcx, &enum_definition.variants, item.def_id.def_id);\n         }\n         DefKind::Fn => {} // entirely within check_item_body\n         DefKind::Impl => {\n@@ -807,7 +833,7 @@ fn check_item_type<'tcx>(tcx: TyCtxt<'tcx>, id: hir::ItemId) {\n                 check_impl_items_against_trait(\n                     tcx,\n                     it.span,\n-                    it.def_id,\n+                    it.def_id.def_id,\n                     impl_trait_ref,\n                     &impl_.items,\n                 );\n@@ -845,23 +871,23 @@ fn check_item_type<'tcx>(tcx: TyCtxt<'tcx>, id: hir::ItemId) {\n             }\n         }\n         DefKind::Struct => {\n-            check_struct(tcx, id.def_id);\n+            check_struct(tcx, id.def_id.def_id);\n         }\n         DefKind::Union => {\n-            check_union(tcx, id.def_id);\n+            check_union(tcx, id.def_id.def_id);\n         }\n         DefKind::OpaqueTy => {\n-            let item = tcx.hir().item(id);\n-            let hir::ItemKind::OpaqueTy(hir::OpaqueTy { origin, .. }) = item.kind else {\n-                return;\n-            };\n-            // HACK(jynelson): trying to infer the type of `impl trait` breaks documenting\n-            // `async-std` (and `pub async fn` in general).\n-            // Since rustdoc doesn't care about the concrete type behind `impl Trait`, just don't look at it!\n-            // See https://github.com/rust-lang/rust/issues/75100\n-            if !tcx.sess.opts.actually_rustdoc {\n-                let substs = InternalSubsts::identity_for_item(tcx, item.def_id.to_def_id());\n-                check_opaque(tcx, item.def_id, substs, &origin);\n+            check_opaque(tcx, id);\n+        }\n+        DefKind::ImplTraitPlaceholder => {\n+            let parent = tcx.impl_trait_in_trait_parent(id.def_id.to_def_id());\n+            // Only check the validity of this opaque type if the function has a default body\n+            if let hir::Node::TraitItem(hir::TraitItem {\n+                kind: hir::TraitItemKind::Fn(_, hir::TraitFn::Provided(_)),\n+                ..\n+            }) = tcx.hir().get_by_def_id(parent.expect_local())\n+            {\n+                check_opaque(tcx, id);\n             }\n         }\n         DefKind::TyAlias => {\n@@ -888,7 +914,7 @@ fn check_item_type<'tcx>(tcx: TyCtxt<'tcx>, id: hir::ItemId) {\n                 }\n             } else {\n                 for item in items {\n-                    let def_id = item.id.def_id;\n+                    let def_id = item.id.def_id.def_id;\n                     let generics = tcx.generics_of(def_id);\n                     let own_counts = generics.own_counts();\n                     if generics.params.len() - own_counts.lifetimes != 0 {\n@@ -1041,14 +1067,10 @@ fn check_impl_items_against_trait<'tcx>(\n         let impl_item_full = tcx.hir().impl_item(impl_item.id);\n         match impl_item_full.kind {\n             hir::ImplItemKind::Const(..) => {\n-                // Find associated const definition.\n-                compare_const_impl(\n-                    tcx,\n-                    &ty_impl_item,\n-                    impl_item.span,\n-                    &ty_trait_item,\n-                    impl_trait_ref,\n-                );\n+                let _ = tcx.compare_assoc_const_impl_item_with_trait_item((\n+                    impl_item.id.def_id.def_id,\n+                    ty_impl_item.trait_item_def_id.unwrap(),\n+                ));\n             }\n             hir::ImplItemKind::Fn(..) => {\n                 let opt_trait_span = tcx.hir().span_if_local(ty_trait_item.def_id);\n@@ -1060,7 +1082,7 @@ fn check_impl_items_against_trait<'tcx>(\n                     opt_trait_span,\n                 );\n             }\n-            hir::ImplItemKind::TyAlias(impl_ty) => {\n+            hir::ImplItemKind::Type(impl_ty) => {\n                 let opt_trait_span = tcx.hir().span_if_local(ty_trait_item.def_id);\n                 compare_ty_impl(\n                     tcx,\n@@ -1148,27 +1170,6 @@ fn check_impl_items_against_trait<'tcx>(\n     }\n }\n \n-/// Checks whether a type can be represented in memory. In particular, it\n-/// identifies types that contain themselves without indirection through a\n-/// pointer, which would mean their size is unbounded.\n-pub(super) fn check_representable(tcx: TyCtxt<'_>, sp: Span, item_def_id: LocalDefId) -> bool {\n-    let rty = tcx.type_of(item_def_id);\n-\n-    // Check that it is possible to represent this type. This call identifies\n-    // (1) types that contain themselves and (2) types that contain a different\n-    // recursive type. It is only necessary to throw an error on those that\n-    // contain themselves. For case 2, there must be an inner type that will be\n-    // caught by case 1.\n-    match representability::ty_is_representable(tcx, rty, sp, None) {\n-        Representability::SelfRecursive(spans) => {\n-            recursive_type_with_infinite_size_error(tcx, item_def_id.to_def_id(), spans);\n-            return false;\n-        }\n-        Representability::Representable | Representability::ContainsRecursive => (),\n-    }\n-    true\n-}\n-\n pub fn check_simd(tcx: TyCtxt<'_>, sp: Span, def_id: LocalDefId) {\n     let t = tcx.type_of(def_id);\n     if let ty::Adt(def, substs) = t.kind()\n@@ -1434,17 +1435,17 @@ pub(super) fn check_transparent<'tcx>(tcx: TyCtxt<'tcx>, sp: Span, adt: ty::AdtD\n                 REPR_TRANSPARENT_EXTERNAL_PRIVATE_FIELDS,\n                 tcx.hir().local_def_id_to_hir_id(adt.did().expect_local()),\n                 span,\n+                \"zero-sized fields in `repr(transparent)` cannot contain external non-exhaustive types\",\n                 |lint| {\n                     let note = if non_exhaustive {\n                         \"is marked with `#[non_exhaustive]`\"\n                     } else {\n                         \"contains private fields\"\n                     };\n                     let field_ty = tcx.def_path_str_with_substs(def_id, substs);\n-                    lint.build(\"zero-sized fields in repr(transparent) cannot contain external non-exhaustive types\")\n+                    lint\n                         .note(format!(\"this {descr} contains `{field_ty}`, which {note}, \\\n                             and makes it not a breaking change to become non-zero-sized in the future.\"))\n-                        .emit();\n                 },\n             )\n         }\n@@ -1506,7 +1507,6 @@ fn check_enum<'tcx>(tcx: TyCtxt<'tcx>, vs: &'tcx [hir::Variant<'tcx>], def_id: L\n \n     detect_discriminant_duplicate(tcx, def.discriminants(tcx).collect(), vs, sp);\n \n-    check_representable(tcx, sp, def_id);\n     check_transparent(tcx, sp, def);\n }\n ", "previous_filename": "compiler/rustc_typeck/src/check/check.rs"}, {"sha": "84ea06a460bb2674d680e78243f561ef2d9a639e", "filename": "compiler/rustc_hir_analysis/src/check/closure.rs", "status": "renamed", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fclosure.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "patch": "@@ -641,6 +641,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             ),\n             bound_vars,\n         );\n+        // Astconv can't normalize inputs or outputs with escaping bound vars,\n+        // so normalize them here, after we've wrapped them in a binder.\n+        let result = self.normalize_associated_types_in(self.tcx.hir().span(hir_id), result);\n \n         let c_result = self.inh.infcx.canonicalize_response(result);\n         self.typeck_results.borrow_mut().user_provided_sigs.insert(expr_def_id, c_result);", "previous_filename": "compiler/rustc_typeck/src/check/closure.rs"}, {"sha": "faa6c6d9356f44e5b6cee08b428a1e953ce3cd91", "filename": "compiler/rustc_hir_analysis/src/check/coercion.rs", "status": "renamed", "additions": 72, "deletions": 7, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcoercion.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "patch": "@@ -61,7 +61,7 @@ use rustc_span::symbol::sym;\n use rustc_span::{self, BytePos, DesugaringKind, Span};\n use rustc_target::spec::abi::Abi;\n use rustc_trait_selection::infer::InferCtxtExt as _;\n-use rustc_trait_selection::traits::error_reporting::InferCtxtExt as _;\n+use rustc_trait_selection::traits::error_reporting::TypeErrCtxtExt as _;\n use rustc_trait_selection::traits::{self, ObligationCause, ObligationCauseCode};\n \n use smallvec::{smallvec, SmallVec};\n@@ -216,6 +216,9 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n             ty::Ref(r_b, _, mutbl_b) => {\n                 return self.coerce_borrowed_pointer(a, b, r_b, mutbl_b);\n             }\n+            ty::Dynamic(predicates, region, ty::DynStar) if self.tcx.features().dyn_star => {\n+                return self.coerce_dyn_star(a, b, predicates, region);\n+            }\n             _ => {}\n         }\n \n@@ -702,7 +705,12 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n \n                 // Object safety violations or miscellaneous.\n                 Err(err) => {\n-                    self.report_selection_error(obligation.clone(), &obligation, &err, false);\n+                    self.err_ctxt().report_selection_error(\n+                        obligation.clone(),\n+                        &obligation,\n+                        &err,\n+                        false,\n+                    );\n                     // Treat this like an obligation and follow through\n                     // with the unsizing - the lack of a coercion should\n                     // be silent, as it causes a type mismatch later.\n@@ -740,6 +748,63 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n         Ok(coercion)\n     }\n \n+    fn coerce_dyn_star(\n+        &self,\n+        a: Ty<'tcx>,\n+        b: Ty<'tcx>,\n+        predicates: &'tcx ty::List<ty::Binder<'tcx, ty::ExistentialPredicate<'tcx>>>,\n+        b_region: ty::Region<'tcx>,\n+    ) -> CoerceResult<'tcx> {\n+        if !self.tcx.features().dyn_star {\n+            return Err(TypeError::Mismatch);\n+        }\n+\n+        if let ty::Dynamic(a_data, _, _) = a.kind()\n+            && let ty::Dynamic(b_data, _, _) = b.kind()\n+        {\n+            if a_data.principal_def_id() == b_data.principal_def_id() {\n+                return self.unify_and(a, b, |_| vec![]);\n+            } else if !self.tcx().features().trait_upcasting {\n+                let mut err = feature_err(\n+                    &self.tcx.sess.parse_sess,\n+                    sym::trait_upcasting,\n+                    self.cause.span,\n+                    &format!(\n+                        \"cannot cast `{a}` to `{b}`, trait upcasting coercion is experimental\"\n+                    ),\n+                );\n+                err.emit();\n+            }\n+        }\n+\n+        // Check the obligations of the cast -- for example, when casting\n+        // `usize` to `dyn* Clone + 'static`:\n+        let obligations = predicates\n+            .iter()\n+            .map(|predicate| {\n+                // For each existential predicate (e.g., `?Self: Clone`) substitute\n+                // the type of the expression (e.g., `usize` in our example above)\n+                // and then require that the resulting predicate (e.g., `usize: Clone`)\n+                // holds (it does).\n+                let predicate = predicate.with_self_ty(self.tcx, a);\n+                Obligation::new(self.cause.clone(), self.param_env, predicate)\n+            })\n+            // Enforce the region bound (e.g., `usize: 'static`, in our example).\n+            .chain([Obligation::new(\n+                self.cause.clone(),\n+                self.param_env,\n+                self.tcx.mk_predicate(ty::Binder::dummy(ty::PredicateKind::TypeOutlives(\n+                    ty::OutlivesPredicate(a, b_region),\n+                ))),\n+            )])\n+            .collect();\n+\n+        Ok(InferOk {\n+            value: (vec![Adjustment { kind: Adjust::DynStar, target: b }], b),\n+            obligations,\n+        })\n+    }\n+\n     fn coerce_from_safe_fn<F, G>(\n         &self,\n         a: Ty<'tcx>,\n@@ -1549,7 +1614,7 @@ impl<'tcx, 'exprs, E: AsCoercionSite> CoerceMany<'tcx, 'exprs, E> {\n                         }\n                     }\n                     _ => {\n-                        err = fcx.report_mismatched_types(\n+                        err = fcx.err_ctxt().report_mismatched_types(\n                             cause,\n                             expected,\n                             found,\n@@ -1629,7 +1694,7 @@ impl<'tcx, 'exprs, E: AsCoercionSite> CoerceMany<'tcx, 'exprs, E> {\n         expression: Option<&'tcx hir::Expr<'tcx>>,\n         blk_id: Option<hir::HirId>,\n     ) -> DiagnosticBuilder<'a, ErrorGuaranteed> {\n-        let mut err = fcx.report_mismatched_types(cause, expected, found, ty_err);\n+        let mut err = fcx.err_ctxt().report_mismatched_types(cause, expected, found, ty_err);\n \n         let mut pointing_at_return_type = false;\n         let mut fn_output = None;\n@@ -1683,7 +1748,7 @@ impl<'tcx, 'exprs, E: AsCoercionSite> CoerceMany<'tcx, 'exprs, E> {\n                     expected,\n                     found,\n                     can_suggest,\n-                    fcx.tcx.hir().local_def_id_to_hir_id(fcx.tcx.hir().get_parent_item(id)),\n+                    fcx.tcx.hir().get_parent_item(id).into(),\n                 );\n             }\n             if !pointing_at_return_type {\n@@ -1692,7 +1757,7 @@ impl<'tcx, 'exprs, E: AsCoercionSite> CoerceMany<'tcx, 'exprs, E> {\n         }\n \n         let parent_id = fcx.tcx.hir().get_parent_item(id);\n-        let parent_item = fcx.tcx.hir().get_by_def_id(parent_id);\n+        let parent_item = fcx.tcx.hir().get_by_def_id(parent_id.def_id);\n \n         if let (Some(expr), Some(_), Some((fn_decl, _, _))) =\n             (expression, blk_id, fcx.get_node_fn_decl(parent_item))\n@@ -1704,7 +1769,7 @@ impl<'tcx, 'exprs, E: AsCoercionSite> CoerceMany<'tcx, 'exprs, E> {\n                 expected,\n                 found,\n                 id,\n-                fcx.tcx.hir().local_def_id_to_hir_id(parent_id),\n+                parent_id.into(),\n             );\n         }\n ", "previous_filename": "compiler/rustc_typeck/src/check/coercion.rs"}, {"sha": "60eaad9b498fc49d90be5429be15ed8c799f15f8", "filename": "compiler/rustc_hir_analysis/src/check/compare_method.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_method.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "previous_filename": "compiler/rustc_typeck/src/check/compare_method.rs"}, {"sha": "a5222c92331a9c6ebf8fc30ef9e97d884beb3264", "filename": "compiler/rustc_hir_analysis/src/check/demand.rs", "status": "renamed", "additions": 41, "deletions": 23, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fdemand.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "previous_filename": "compiler/rustc_typeck/src/check/demand.rs"}, {"sha": "963a93a95c2bbc386dd026010593d883e6d621f9", "filename": "compiler/rustc_hir_analysis/src/check/diverges.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fdiverges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fdiverges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fdiverges.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "previous_filename": "compiler/rustc_typeck/src/check/diverges.rs"}, {"sha": "e5b212eb757b6a8070cd44cdc679a71f009f1803", "filename": "compiler/rustc_hir_analysis/src/check/dropck.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fdropck.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "previous_filename": "compiler/rustc_typeck/src/check/dropck.rs"}, {"sha": "e9e810344776b963d52a0eeb85fbd6ecbcc8c376", "filename": "compiler/rustc_hir_analysis/src/check/expectation.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fexpectation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fexpectation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fexpectation.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "previous_filename": "compiler/rustc_typeck/src/check/expectation.rs"}, {"sha": "ccdfd3a056b8349e6dadf245b868cb90518347d1", "filename": "compiler/rustc_hir_analysis/src/check/expr.rs", "status": "renamed", "additions": 47, "deletions": 25, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fexpr.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "previous_filename": "compiler/rustc_typeck/src/check/expr.rs"}, {"sha": "474d5651bbe2f137b9c6e29aeefced6a80791192", "filename": "compiler/rustc_hir_analysis/src/check/fallback.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Ffallback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Ffallback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Ffallback.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "previous_filename": "compiler/rustc_typeck/src/check/fallback.rs"}, {"sha": "d140c3a0989900e26914cfdf5c676edc952a4979", "filename": "compiler/rustc_hir_analysis/src/check/fn_ctxt/_impl.rs", "status": "renamed", "additions": 21, "deletions": 13, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "previous_filename": "compiler/rustc_typeck/src/check/fn_ctxt/_impl.rs"}, {"sha": "fc83994caf53966aff1ba74745ca44856349f233", "filename": "compiler/rustc_hir_analysis/src/check/fn_ctxt/arg_matrix.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Ffn_ctxt%2Farg_matrix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Ffn_ctxt%2Farg_matrix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Ffn_ctxt%2Farg_matrix.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "previous_filename": "compiler/rustc_typeck/src/check/fn_ctxt/arg_matrix.rs"}, {"sha": "285db90a9df55a69226cd9a1a16a63d847f808b5", "filename": "compiler/rustc_hir_analysis/src/check/fn_ctxt/checks.rs", "status": "renamed", "additions": 16, "deletions": 11, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "previous_filename": "compiler/rustc_typeck/src/check/fn_ctxt/checks.rs"}, {"sha": "51f4cb7e0ebfa227b11c58b2c4d91cecf1da43d2", "filename": "compiler/rustc_hir_analysis/src/check/fn_ctxt/mod.rs", "status": "renamed", "additions": 13, "deletions": 4, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Ffn_ctxt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Ffn_ctxt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Ffn_ctxt%2Fmod.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "previous_filename": "compiler/rustc_typeck/src/check/fn_ctxt/mod.rs"}, {"sha": "08b21b82faf5a0b47e8224039be9c5cecf27d290", "filename": "compiler/rustc_hir_analysis/src/check/fn_ctxt/suggestions.rs", "status": "renamed", "additions": 110, "deletions": 40, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Ffn_ctxt%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Ffn_ctxt%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Ffn_ctxt%2Fsuggestions.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "previous_filename": "compiler/rustc_typeck/src/check/fn_ctxt/suggestions.rs"}, {"sha": "8f34a970f6ff7694ea9eb69468d0392e0e21f934", "filename": "compiler/rustc_hir_analysis/src/check/gather_locals.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fgather_locals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fgather_locals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fgather_locals.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "previous_filename": "compiler/rustc_typeck/src/check/gather_locals.rs"}, {"sha": "898419b5b237450ec2b62f9bc95001bbf6dbfaeb", "filename": "compiler/rustc_hir_analysis/src/check/generator_interior.rs", "status": "renamed", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fgenerator_interior.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fgenerator_interior.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fgenerator_interior.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "previous_filename": "compiler/rustc_typeck/src/check/generator_interior.rs"}, {"sha": "518cd7342366c09a1fce6eb4e8dd3db31554626b", "filename": "compiler/rustc_hir_analysis/src/check/generator_interior/drop_ranges.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fgenerator_interior%2Fdrop_ranges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fgenerator_interior%2Fdrop_ranges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fgenerator_interior%2Fdrop_ranges.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "previous_filename": "compiler/rustc_typeck/src/check/generator_interior/drop_ranges.rs"}, {"sha": "122ad7009cb497181c76386740de783fb4ad0001", "filename": "compiler/rustc_hir_analysis/src/check/generator_interior/drop_ranges/cfg_build.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fgenerator_interior%2Fdrop_ranges%2Fcfg_build.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fgenerator_interior%2Fdrop_ranges%2Fcfg_build.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fgenerator_interior%2Fdrop_ranges%2Fcfg_build.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "previous_filename": "compiler/rustc_typeck/src/check/generator_interior/drop_ranges/cfg_build.rs"}, {"sha": "139d17d2e1ca186d72705afb98d310597a1c09f5", "filename": "compiler/rustc_hir_analysis/src/check/generator_interior/drop_ranges/cfg_propagate.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fgenerator_interior%2Fdrop_ranges%2Fcfg_propagate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fgenerator_interior%2Fdrop_ranges%2Fcfg_propagate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fgenerator_interior%2Fdrop_ranges%2Fcfg_propagate.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "previous_filename": "compiler/rustc_typeck/src/check/generator_interior/drop_ranges/cfg_propagate.rs"}, {"sha": "c0a0bfe8e1c00a98cb53dd41b5d1e6e9bb7ba82c", "filename": "compiler/rustc_hir_analysis/src/check/generator_interior/drop_ranges/cfg_visualize.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fgenerator_interior%2Fdrop_ranges%2Fcfg_visualize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fgenerator_interior%2Fdrop_ranges%2Fcfg_visualize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fgenerator_interior%2Fdrop_ranges%2Fcfg_visualize.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "previous_filename": "compiler/rustc_typeck/src/check/generator_interior/drop_ranges/cfg_visualize.rs"}, {"sha": "2f68b57a0193f5e33c2f9b90841da1601cb4538c", "filename": "compiler/rustc_hir_analysis/src/check/generator_interior/drop_ranges/record_consumed_borrow.rs", "status": "renamed", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fgenerator_interior%2Fdrop_ranges%2Frecord_consumed_borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fgenerator_interior%2Fdrop_ranges%2Frecord_consumed_borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fgenerator_interior%2Fdrop_ranges%2Frecord_consumed_borrow.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "previous_filename": "compiler/rustc_typeck/src/check/generator_interior/drop_ranges/record_consumed_borrow.rs"}, {"sha": "0fb7651b3a1e1decbabc188f605e718ed56367c8", "filename": "compiler/rustc_hir_analysis/src/check/inherited.rs", "status": "renamed", "additions": 21, "deletions": 17, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Finherited.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Finherited.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Finherited.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "previous_filename": "compiler/rustc_typeck/src/check/inherited.rs"}, {"sha": "8be1cf04f8b691d9b8e8127b9eb52f3555567e0a", "filename": "compiler/rustc_hir_analysis/src/check/intrinsic.rs", "status": "renamed", "additions": 22, "deletions": 5, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fintrinsic.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "previous_filename": "compiler/rustc_typeck/src/check/intrinsic.rs"}, {"sha": "25228f424cd0793688b3ba19671c624aed959ca5", "filename": "compiler/rustc_hir_analysis/src/check/intrinsicck.rs", "status": "renamed", "additions": 30, "deletions": 18, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fintrinsicck.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "previous_filename": "compiler/rustc_typeck/src/check/intrinsicck.rs"}, {"sha": "30731cbd03d3bf8209c31acfd48f450c2434f787", "filename": "compiler/rustc_hir_analysis/src/check/method/confirm.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fmethod%2Fconfirm.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "previous_filename": "compiler/rustc_typeck/src/check/method/confirm.rs"}, {"sha": "3fe9bea2299dfd3184ab0254f958685934d99138", "filename": "compiler/rustc_hir_analysis/src/check/method/mod.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fmethod%2Fmod.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "previous_filename": "compiler/rustc_typeck/src/check/method/mod.rs"}, {"sha": "ca4cdf5a0d01c9b010216e0936f8d33f1ae10303", "filename": "compiler/rustc_hir_analysis/src/check/method/prelude2021.rs", "status": "renamed", "additions": 55, "deletions": 57, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fmethod%2Fprelude2021.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fmethod%2Fprelude2021.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fmethod%2Fprelude2021.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "previous_filename": "compiler/rustc_typeck/src/check/method/prelude2021.rs"}, {"sha": "ba078ad0abbd9d1cff09d25a725c91352991a56f", "filename": "compiler/rustc_hir_analysis/src/check/method/probe.rs", "status": "renamed", "additions": 68, "deletions": 73, "changes": 141, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fmethod%2Fprobe.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "previous_filename": "compiler/rustc_typeck/src/check/method/probe.rs"}, {"sha": "bfa5b68168fdb37582d15529c5bb3d0caf9456ba", "filename": "compiler/rustc_hir_analysis/src/check/method/suggest.rs", "status": "renamed", "additions": 295, "deletions": 67, "changes": 362, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "previous_filename": "compiler/rustc_typeck/src/check/method/suggest.rs"}, {"sha": "331bd7e26c858ed56c744477cf273eb4334f3878", "filename": "compiler/rustc_hir_analysis/src/check/mod.rs", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fmod.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "previous_filename": "compiler/rustc_typeck/src/check/mod.rs"}, {"sha": "5e498a92ec20315fc44c1a46d2e88e3749f39d54", "filename": "compiler/rustc_hir_analysis/src/check/op.rs", "status": "renamed", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fop.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "previous_filename": "compiler/rustc_typeck/src/check/op.rs"}, {"sha": "178326cfdc4fb96e79b030a69b94eb7696047441", "filename": "compiler/rustc_hir_analysis/src/check/pat.rs", "status": "renamed", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fpat.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "previous_filename": "compiler/rustc_typeck/src/check/pat.rs"}, {"sha": "2e0f37eba232d4762d11b13ae1880f6b4fc6d05d", "filename": "compiler/rustc_hir_analysis/src/check/place_op.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fplace_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fplace_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fplace_op.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "previous_filename": "compiler/rustc_typeck/src/check/place_op.rs"}, {"sha": "ff32329e431b699eccdd4b7c393a0b9de36de9e5", "filename": "compiler/rustc_hir_analysis/src/check/region.rs", "status": "renamed", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fregion.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "previous_filename": "compiler/rustc_typeck/src/check/region.rs"}, {"sha": "22c9e7961070c6d14e6761bd16f230e408b8d3f1", "filename": "compiler/rustc_hir_analysis/src/check/rvalue_scopes.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Frvalue_scopes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Frvalue_scopes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Frvalue_scopes.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "previous_filename": "compiler/rustc_typeck/src/check/rvalue_scopes.rs"}, {"sha": "4dea40829f6221a2b4e4400789676b9bd5b8b4ce", "filename": "compiler/rustc_hir_analysis/src/check/upvar.rs", "status": "renamed", "additions": 13, "deletions": 15, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fupvar.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "previous_filename": "compiler/rustc_typeck/src/check/upvar.rs"}, {"sha": "0a8a1bec9b8a3be020e802f79bd056f8be3752d2", "filename": "compiler/rustc_hir_analysis/src/check/wfcheck.rs", "status": "renamed", "additions": 77, "deletions": 75, "changes": 152, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "previous_filename": "compiler/rustc_typeck/src/check/wfcheck.rs"}, {"sha": "d2d596efb93e7f8bc7460962c28b2d8d13658fb4", "filename": "compiler/rustc_hir_analysis/src/check/writeback.rs", "status": "renamed", "additions": 30, "deletions": 25, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwriteback.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "previous_filename": "compiler/rustc_typeck/src/check/writeback.rs"}, {"sha": "922833f85806cb30fae864152be3d04e0d02e00e", "filename": "compiler/rustc_hir_analysis/src/check_unused.rs", "status": "renamed", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck_unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck_unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck_unused.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "previous_filename": "compiler/rustc_typeck/src/check_unused.rs"}, {"sha": "b6c91d425dff4bfd6ee4b788b5af7413962a10cd", "filename": "compiler/rustc_hir_analysis/src/coherence/builtin.rs", "status": "added", "additions": 572, "deletions": 0, "changes": 572, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Fbuiltin.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f"}, {"sha": "308ad5d5fc2c238efc3825a4959f8bd4251a80c3", "filename": "compiler/rustc_hir_analysis/src/coherence/inherent_impls.rs", "status": "renamed", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Finherent_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Finherent_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Finherent_impls.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "previous_filename": "compiler/rustc_typeck/src/coherence/inherent_impls.rs"}, {"sha": "130eb8005b069214e045f9ea40e7b8ca6c567434", "filename": "compiler/rustc_hir_analysis/src/coherence/inherent_impls_overlap.rs", "status": "renamed", "additions": 40, "deletions": 12, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Finherent_impls_overlap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Finherent_impls_overlap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Finherent_impls_overlap.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "previous_filename": "compiler/rustc_typeck/src/coherence/inherent_impls_overlap.rs"}, {"sha": "ae9ebe590914455b372b8326b43aaa4b3f414153", "filename": "compiler/rustc_hir_analysis/src/coherence/mod.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Fmod.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "previous_filename": "compiler/rustc_typeck/src/coherence/mod.rs"}, {"sha": "1307f74f2107196135377179bc27ddde2130440f", "filename": "compiler/rustc_hir_analysis/src/coherence/orphan.rs", "status": "renamed", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Forphan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Forphan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Forphan.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "previous_filename": "compiler/rustc_typeck/src/coherence/orphan.rs"}, {"sha": "e45fb5fe41c02599502b5bb5bca5f1eea8ea11f5", "filename": "compiler/rustc_hir_analysis/src/coherence/unsafety.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Funsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Funsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Funsafety.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "previous_filename": "compiler/rustc_typeck/src/coherence/unsafety.rs"}, {"sha": "5c76016c6625883110b62875d45eb390479eb6a3", "filename": "compiler/rustc_hir_analysis/src/collect.rs", "status": "renamed", "additions": 40, "deletions": 1209, "changes": 1249, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "previous_filename": "compiler/rustc_typeck/src/collect.rs"}, {"sha": "707fd6c75278d0f74887ef82bcdfd3dcb45bfa82", "filename": "compiler/rustc_hir_analysis/src/collect/generics_of.rs", "status": "added", "additions": 480, "deletions": 0, "changes": 480, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fgenerics_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fgenerics_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fgenerics_of.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f"}, {"sha": "0d34a8bfee333d3d457fd32e15cfc101eb5ad474", "filename": "compiler/rustc_hir_analysis/src/collect/item_bounds.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fitem_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fitem_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fitem_bounds.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "previous_filename": "compiler/rustc_typeck/src/collect/item_bounds.rs"}, {"sha": "c1214698cf7708d5d6494d76b93ea5ae0c47d814", "filename": "compiler/rustc_hir_analysis/src/collect/lifetimes.rs", "status": "renamed", "additions": 86, "deletions": 53, "changes": 139, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Flifetimes.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "previous_filename": "compiler/rustc_resolve/src/late/lifetimes.rs"}, {"sha": "db8f8de68f29d6ebb4ebbf7f9647a76b5f1460b5", "filename": "compiler/rustc_hir_analysis/src/collect/predicates_of.rs", "status": "added", "additions": 707, "deletions": 0, "changes": 707, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fpredicates_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fpredicates_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fpredicates_of.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f"}, {"sha": "32f359a81581916e050cc41c88cdb1efd561cd86", "filename": "compiler/rustc_hir_analysis/src/collect/type_of.rs", "status": "renamed", "additions": 143, "deletions": 70, "changes": 213, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Ftype_of.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "previous_filename": "compiler/rustc_typeck/src/collect/type_of.rs"}, {"sha": "213b89fc7843c150ebf94c6c9aa3478ca31f4ac9", "filename": "compiler/rustc_hir_analysis/src/constrained_generic_params.rs", "status": "renamed", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_hir_analysis%2Fsrc%2Fconstrained_generic_params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_hir_analysis%2Fsrc%2Fconstrained_generic_params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fconstrained_generic_params.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "previous_filename": "compiler/rustc_typeck/src/constrained_generic_params.rs"}, {"sha": "41f73323d9a9aee6f22f8a073659a61d286d2a6a", "filename": "compiler/rustc_hir_analysis/src/errors.rs", "status": "renamed", "additions": 71, "deletions": 44, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_hir_analysis%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_hir_analysis%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Ferrors.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "previous_filename": "compiler/rustc_typeck/src/errors.rs"}, {"sha": "039c653e5bc64de9f55a55eaadee28906bfd37a3", "filename": "compiler/rustc_hir_analysis/src/expr_use_visitor.rs", "status": "renamed", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_hir_analysis%2Fsrc%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_hir_analysis%2Fsrc%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fexpr_use_visitor.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "previous_filename": "compiler/rustc_typeck/src/expr_use_visitor.rs"}, {"sha": "b0fdfcf38a6083d74c063dfaa16cc61c105d59f3", "filename": "compiler/rustc_hir_analysis/src/hir_wf_check.rs", "status": "renamed", "additions": 28, "deletions": 30, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_hir_analysis%2Fsrc%2Fhir_wf_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_hir_analysis%2Fsrc%2Fhir_wf_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fhir_wf_check.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "previous_filename": "compiler/rustc_typeck/src/hir_wf_check.rs"}, {"sha": "a84257b939c529cd0d30b836b5faab9529ea0ba9", "filename": "compiler/rustc_hir_analysis/src/impl_wf_check.rs", "status": "renamed", "additions": 3, "deletions": 38, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_hir_analysis%2Fsrc%2Fimpl_wf_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_hir_analysis%2Fsrc%2Fimpl_wf_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fimpl_wf_check.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "previous_filename": "compiler/rustc_typeck/src/impl_wf_check.rs"}, {"sha": "e806e94879d932641087b87b842ae3fdab334b98", "filename": "compiler/rustc_hir_analysis/src/impl_wf_check/min_specialization.rs", "status": "renamed", "additions": 50, "deletions": 48, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_hir_analysis%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_hir_analysis%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "previous_filename": "compiler/rustc_typeck/src/impl_wf_check/min_specialization.rs"}, {"sha": "b7d9fc8a2fe272b71b7af99f9254708950300687", "filename": "compiler/rustc_hir_analysis/src/lib.rs", "status": "renamed", "additions": 33, "deletions": 37, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_hir_analysis%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_hir_analysis%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Flib.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "previous_filename": "compiler/rustc_typeck/src/lib.rs"}, {"sha": "362f1c3430041a45e668c263b825e7f790a2fbc9", "filename": "compiler/rustc_hir_analysis/src/mem_categorization.rs", "status": "renamed", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_hir_analysis%2Fsrc%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_hir_analysis%2Fsrc%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fmem_categorization.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "previous_filename": "compiler/rustc_typeck/src/mem_categorization.rs"}, {"sha": "7534482cce9bba7f3deccbe62887ac6e42554efa", "filename": "compiler/rustc_hir_analysis/src/outlives/explicit.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_hir_analysis%2Fsrc%2Foutlives%2Fexplicit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_hir_analysis%2Fsrc%2Foutlives%2Fexplicit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Foutlives%2Fexplicit.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "previous_filename": "compiler/rustc_typeck/src/outlives/explicit.rs"}, {"sha": "064a70107fe83ab42742c8b964160be18400e1df", "filename": "compiler/rustc_hir_analysis/src/outlives/implicit_infer.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_hir_analysis%2Fsrc%2Foutlives%2Fimplicit_infer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_hir_analysis%2Fsrc%2Foutlives%2Fimplicit_infer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Foutlives%2Fimplicit_infer.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "previous_filename": "compiler/rustc_typeck/src/outlives/implicit_infer.rs"}, {"sha": "e50c267659e3f3b5a754e80966f59d2ea23eb75c", "filename": "compiler/rustc_hir_analysis/src/outlives/mod.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_hir_analysis%2Fsrc%2Foutlives%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_hir_analysis%2Fsrc%2Foutlives%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Foutlives%2Fmod.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "previous_filename": "compiler/rustc_typeck/src/outlives/mod.rs"}, {"sha": "eb0e1203405cb509681d591115f2a42a9116bebb", "filename": "compiler/rustc_hir_analysis/src/outlives/test.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_hir_analysis%2Fsrc%2Foutlives%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_hir_analysis%2Fsrc%2Foutlives%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Foutlives%2Ftest.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "previous_filename": "compiler/rustc_typeck/src/outlives/test.rs"}, {"sha": "0409c7081dc4f5cde6e626905b82b9255e83f6f2", "filename": "compiler/rustc_hir_analysis/src/outlives/utils.rs", "status": "renamed", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_hir_analysis%2Fsrc%2Foutlives%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_hir_analysis%2Fsrc%2Foutlives%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Foutlives%2Futils.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "previous_filename": "compiler/rustc_typeck/src/outlives/utils.rs"}, {"sha": "0b46fce17354996354b6a607ca412fb5d88c72b6", "filename": "compiler/rustc_hir_analysis/src/structured_errors.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_hir_analysis%2Fsrc%2Fstructured_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_hir_analysis%2Fsrc%2Fstructured_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fstructured_errors.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "previous_filename": "compiler/rustc_typeck/src/structured_errors.rs"}, {"sha": "324df313ef1d8bbc49370e6c4f389207304cadc6", "filename": "compiler/rustc_hir_analysis/src/structured_errors/missing_cast_for_variadic_arg.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_hir_analysis%2Fsrc%2Fstructured_errors%2Fmissing_cast_for_variadic_arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_hir_analysis%2Fsrc%2Fstructured_errors%2Fmissing_cast_for_variadic_arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fstructured_errors%2Fmissing_cast_for_variadic_arg.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "previous_filename": "compiler/rustc_typeck/src/structured_errors/missing_cast_for_variadic_arg.rs"}, {"sha": "bb608805488ef1850755e0009d1ab097551d381b", "filename": "compiler/rustc_hir_analysis/src/structured_errors/sized_unsized_cast.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_hir_analysis%2Fsrc%2Fstructured_errors%2Fsized_unsized_cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_hir_analysis%2Fsrc%2Fstructured_errors%2Fsized_unsized_cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fstructured_errors%2Fsized_unsized_cast.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "previous_filename": "compiler/rustc_typeck/src/structured_errors/sized_unsized_cast.rs"}, {"sha": "4359124646df15b984a0662344532fe93821feca", "filename": "compiler/rustc_hir_analysis/src/structured_errors/wrong_number_of_generic_args.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_hir_analysis%2Fsrc%2Fstructured_errors%2Fwrong_number_of_generic_args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_hir_analysis%2Fsrc%2Fstructured_errors%2Fwrong_number_of_generic_args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fstructured_errors%2Fwrong_number_of_generic_args.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "previous_filename": "compiler/rustc_typeck/src/structured_errors/wrong_number_of_generic_args.rs"}, {"sha": "eaf0310d57aeca595c744cf9ee437a31610091c1", "filename": "compiler/rustc_hir_analysis/src/variance/constraints.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_hir_analysis%2Fsrc%2Fvariance%2Fconstraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_hir_analysis%2Fsrc%2Fvariance%2Fconstraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fvariance%2Fconstraints.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "previous_filename": "compiler/rustc_typeck/src/variance/constraints.rs"}, {"sha": "82103c5a03b6e04fe52fcf2ba3ba2af3ed57b1f5", "filename": "compiler/rustc_hir_analysis/src/variance/mod.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_hir_analysis%2Fsrc%2Fvariance%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_hir_analysis%2Fsrc%2Fvariance%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fvariance%2Fmod.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "previous_filename": "compiler/rustc_typeck/src/variance/mod.rs"}, {"sha": "97aca621aa21745e78cfc319bd6acf089c5e9fd4", "filename": "compiler/rustc_hir_analysis/src/variance/solve.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_hir_analysis%2Fsrc%2Fvariance%2Fsolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_hir_analysis%2Fsrc%2Fvariance%2Fsolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fvariance%2Fsolve.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "previous_filename": "compiler/rustc_typeck/src/variance/solve.rs"}, {"sha": "1f763011e061433e34869534cd81ca265d1e0aa1", "filename": "compiler/rustc_hir_analysis/src/variance/terms.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_hir_analysis%2Fsrc%2Fvariance%2Fterms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_hir_analysis%2Fsrc%2Fvariance%2Fterms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fvariance%2Fterms.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "previous_filename": "compiler/rustc_typeck/src/variance/terms.rs"}, {"sha": "2ba87db880b4671440cc85f394d86209d6858258", "filename": "compiler/rustc_hir_analysis/src/variance/test.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_hir_analysis%2Fsrc%2Fvariance%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_hir_analysis%2Fsrc%2Fvariance%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fvariance%2Ftest.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "previous_filename": "compiler/rustc_typeck/src/variance/test.rs"}, {"sha": "027f0859fcd54943cda23de168370b25448e9716", "filename": "compiler/rustc_hir_analysis/src/variance/xform.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_hir_analysis%2Fsrc%2Fvariance%2Fxform.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_hir_analysis%2Fsrc%2Fvariance%2Fxform.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fvariance%2Fxform.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f", "previous_filename": "compiler/rustc_typeck/src/variance/xform.rs"}, {"sha": "1ea7be1ae7b520fc3e8fad9442b0d53e99e13750", "filename": "compiler/rustc_hir_pretty/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_hir_pretty%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_hir_pretty%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_pretty%2FCargo.toml?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f"}, {"sha": "da27554a2292b331f59f39b4e01eb86baba9cbc1", "filename": "compiler/rustc_hir_pretty/src/lib.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f"}, {"sha": "179e85f32c913b44c1edfdcac882f7fbdaa6ebf8", "filename": "compiler/rustc_incremental/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_incremental%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_incremental%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_incremental%2FCargo.toml?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f"}, {"sha": "83dd9a67e61bc0f9b22325b38e6314366cb744fa", "filename": "compiler/rustc_incremental/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_incremental%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_incremental%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_incremental%2Fsrc%2Flib.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f"}, {"sha": "9c19f16a496bfaa0966cf90f47117c3e2e12ef1f", "filename": "compiler/rustc_incremental/src/persist/dirty_clean.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fdirty_clean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fdirty_clean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fdirty_clean.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f"}, {"sha": "d8ea5aa80b87abc73a62b545cbb278a280105523", "filename": "compiler/rustc_index/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_index%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_index%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_index%2FCargo.toml?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f"}, {"sha": "23a4c1f069662262f0306405815c43ed4c44ff0c", "filename": "compiler/rustc_index/src/lib.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_index%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_index%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_index%2Fsrc%2Flib.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f"}, {"sha": "500900d3d4a74b7310be4483c3a7a87e01ffff45", "filename": "compiler/rustc_infer/src/errors/mod.rs", "status": "modified", "additions": 26, "deletions": 7, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_infer%2Fsrc%2Ferrors%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_infer%2Fsrc%2Ferrors%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Ferrors%2Fmod.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f"}, {"sha": "201a3c7100cc8da1c57654a2d0e208cece4f2dec", "filename": "compiler/rustc_infer/src/errors/note_and_explain.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_infer%2Fsrc%2Ferrors%2Fnote_and_explain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_infer%2Fsrc%2Ferrors%2Fnote_and_explain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Ferrors%2Fnote_and_explain.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f"}, {"sha": "5ff3779fa1438ba11aff507786ce3de4ed0bbaa5", "filename": "compiler/rustc_infer/src/infer/at.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/befc94e691ae36c2fad134e1cdf483b7bdeeb74f/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fat.rs?ref=befc94e691ae36c2fad134e1cdf483b7bdeeb74f"}]}