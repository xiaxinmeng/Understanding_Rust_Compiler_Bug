{"sha": "0dc9f6277939a661011a07fbc88f0f0449ac276c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBkYzlmNjI3NzkzOWE2NjEwMTFhMDdmYmM4OGYwZjA0NDlhYzI3NmM=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-12-02T22:37:30Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-12-03T16:19:33Z"}, "message": "Resume propagation of linking to native dylibs\n\nThe reasons for this are outlined in issue #10743 as well as the comment I have\nnow placed in the code.\n\nCloses #10743", "tree": {"sha": "29362cb6c05c4b12828042ed2cdb60e5385e21b8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/29362cb6c05c4b12828042ed2cdb60e5385e21b8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0dc9f6277939a661011a07fbc88f0f0449ac276c", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0dc9f6277939a661011a07fbc88f0f0449ac276c", "html_url": "https://github.com/rust-lang/rust/commit/0dc9f6277939a661011a07fbc88f0f0449ac276c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0dc9f6277939a661011a07fbc88f0f0449ac276c/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6437122e64d5c5d0cb2aa772d302348a9d366b0d", "url": "https://api.github.com/repos/rust-lang/rust/commits/6437122e64d5c5d0cb2aa772d302348a9d366b0d", "html_url": "https://github.com/rust-lang/rust/commit/6437122e64d5c5d0cb2aa772d302348a9d366b0d"}], "stats": {"total": 135, "additions": 74, "deletions": 61}, "files": [{"sha": "cf8fd77b47a50803c1ad8611202646b074c59df7", "filename": "src/librustc/back/link.rs", "status": "modified", "additions": 73, "deletions": 54, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/0dc9f6277939a661011a07fbc88f0f0449ac276c/src%2Flibrustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dc9f6277939a661011a07fbc88f0f0449ac276c/src%2Flibrustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flink.rs?ref=0dc9f6277939a661011a07fbc88f0f0449ac276c", "patch": "@@ -1127,8 +1127,9 @@ fn link_args(sess: Session,\n         }\n     }\n \n-    add_upstream_rust_crates(&mut args, sess, dylib);\n     add_local_native_libraries(&mut args, sess);\n+    add_upstream_rust_crates(&mut args, sess, dylib);\n+    add_upstream_native_libraries(&mut args, sess);\n \n     // # Telling the linker what we're doing\n \n@@ -1168,6 +1169,42 @@ fn link_args(sess: Session,\n     return args;\n }\n \n+// # Native library linking\n+//\n+// User-supplied library search paths (-L on the cammand line) These are\n+// the same paths used to find Rust crates, so some of them may have been\n+// added already by the previous crate linking code. This only allows them\n+// to be found at compile time so it is still entirely up to outside\n+// forces to make sure that library can be found at runtime.\n+//\n+// Also note that the native libraries linked here are only the ones located\n+// in the current crate. Upstream crates with native library dependencies\n+// may have their native library pulled in above.\n+fn add_local_native_libraries(args: &mut ~[~str], sess: Session) {\n+    for path in sess.opts.addl_lib_search_paths.iter() {\n+        // FIXME (#9639): This needs to handle non-utf8 paths\n+        args.push(\"-L\" + path.as_str().unwrap().to_owned());\n+    }\n+\n+    let rustpath = filesearch::rust_path();\n+    for path in rustpath.iter() {\n+        // FIXME (#9639): This needs to handle non-utf8 paths\n+        args.push(\"-L\" + path.as_str().unwrap().to_owned());\n+    }\n+\n+    for &(ref l, kind) in cstore::get_used_libraries(sess.cstore).iter() {\n+        match kind {\n+            cstore::NativeUnknown | cstore::NativeStatic => {\n+                args.push(\"-l\" + *l);\n+            }\n+            cstore::NativeFramework => {\n+                args.push(~\"-framework\");\n+                args.push(l.to_owned());\n+            }\n+        }\n+    }\n+}\n+\n // # Rust Crate linking\n //\n // Rust crates are not considered at all when creating an rlib output. All\n@@ -1197,30 +1234,11 @@ fn add_upstream_rust_crates(args: &mut ~[~str], sess: Session,\n         // all dynamic libaries require dynamic dependencies (see above), so\n         // it's satisfactory to include either all static libraries or all\n         // dynamic libraries.\n-        let crates = cstore::get_used_crates(cstore,\n-                                             cstore::RequireStatic);\n+        let crates = cstore::get_used_crates(cstore, cstore::RequireStatic);\n         if crates.iter().all(|&(_, ref p)| p.is_some()) {\n-            for &(cnum, ref path) in crates.iter() {\n-                let cratepath = path.clone().unwrap();\n-\n-                // If we're linking to the static version of the crate, then\n-                // we're mostly good to go. The caveat here is that we need to\n-                // pull in the static crate's native dependencies.\n-                args.push(cratepath.as_str().unwrap().to_owned());\n-\n-                let libs = csearch::get_native_libraries(sess.cstore, cnum);\n-                for &(kind, ref lib) in libs.iter() {\n-                    match kind {\n-                        cstore::NativeUnknown => args.push(\"-l\" + *lib),\n-                        cstore::NativeFramework => {\n-                            args.push(~\"-framework\");\n-                            args.push(lib.to_owned());\n-                        }\n-                        cstore::NativeStatic => {\n-                            sess.bug(\"statics shouldn't be propagated\");\n-                        }\n-                    }\n-                }\n+            for (_, path) in crates.move_iter() {\n+                let path = path.unwrap();\n+                args.push(path.as_str().unwrap().to_owned());\n             }\n             return;\n         }\n@@ -1253,38 +1271,39 @@ fn add_upstream_rust_crates(args: &mut ~[~str], sess: Session,\n     }\n }\n \n-// # Native library linking\n+// Link in all of our upstream crates' native dependencies. Remember that\n+// all of these upstream native depenencies are all non-static\n+// dependencies. We've got two cases then:\n //\n-// User-supplied library search paths (-L on the cammand line) These are\n-// the same paths used to find Rust crates, so some of them may have been\n-// added already by the previous crate linking code. This only allows them\n-// to be found at compile time so it is still entirely up to outside\n-// forces to make sure that library can be found at runtime.\n+// 1. The upstream crate is an rlib. In this case we *must* link in the\n+//    native dependency because the rlib is just an archive.\n //\n-// Also note that the native libraries linked here are only the ones located\n-// in the current crate. Upstream crates with native library dependencies\n-// may have their native library pulled in above.\n-fn add_local_native_libraries(args: &mut ~[~str], sess: Session) {\n-    for path in sess.opts.addl_lib_search_paths.iter() {\n-        // FIXME (#9639): This needs to handle non-utf8 paths\n-        args.push(\"-L\" + path.as_str().unwrap().to_owned());\n-    }\n-\n-    let rustpath = filesearch::rust_path();\n-    for path in rustpath.iter() {\n-        // FIXME (#9639): This needs to handle non-utf8 paths\n-        args.push(\"-L\" + path.as_str().unwrap().to_owned());\n-    }\n-\n-    for &(ref l, kind) in cstore::get_used_libraries(sess.cstore).iter() {\n-        match kind {\n-            cstore::NativeUnknown | cstore::NativeStatic => {\n-                args.push(\"-l\" + *l);\n-            }\n-            cstore::NativeFramework => {\n-                args.push(~\"-framework\");\n-                args.push(l.to_owned());\n+// 2. The upstream crate is a dylib. In order to use the dylib, we have to\n+//    have the dependency present on the system somewhere. Thus, we don't\n+//    gain a whole lot from not linking in the dynamic dependency to this\n+//    crate as well.\n+//\n+// The use case for this is a little subtle. In theory the native\n+// dependencies of a crate a purely an implementation detail of the crate\n+// itself, but the problem arises with generic and inlined functions. If a\n+// generic function calls a native function, then the generic function must\n+// be instantiated in the target crate, meaning that the native symbol must\n+// also be resolved in the target crate.\n+fn add_upstream_native_libraries(args: &mut ~[~str], sess: Session) {\n+    let cstore = sess.cstore;\n+    cstore::iter_crate_data(cstore, |cnum, _| {\n+        let libs = csearch::get_native_libraries(cstore, cnum);\n+        for &(kind, ref lib) in libs.iter() {\n+            match kind {\n+                cstore::NativeUnknown => args.push(\"-l\" + *lib),\n+                cstore::NativeFramework => {\n+                    args.push(~\"-framework\");\n+                    args.push(lib.to_owned());\n+                }\n+                cstore::NativeStatic => {\n+                    sess.bug(\"statics shouldn't be propagated\");\n+                }\n             }\n         }\n-    }\n+    });\n }"}, {"sha": "cce7df565048902e1c64e6e423c2fe744ed02571", "filename": "src/test/auxiliary/anon-extern-mod-cross-crate-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0dc9f6277939a661011a07fbc88f0f0449ac276c/src%2Ftest%2Fauxiliary%2Fanon-extern-mod-cross-crate-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dc9f6277939a661011a07fbc88f0f0449ac276c/src%2Ftest%2Fauxiliary%2Fanon-extern-mod-cross-crate-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fanon-extern-mod-cross-crate-1.rs?ref=0dc9f6277939a661011a07fbc88f0f0449ac276c", "patch": "@@ -14,7 +14,7 @@\n \n use std::libc;\n \n+#[link(name = \"rustrt\")]\n extern {\n-    #[link(name = \"rustrt\")]\n     pub fn rust_get_test_int() -> libc::intptr_t;\n }"}, {"sha": "e31f28ed7a20ed15d2d4f5fbe994a211dcbdeef1", "filename": "src/test/run-pass/anon-extern-mod-cross-crate-2.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0dc9f6277939a661011a07fbc88f0f0449ac276c/src%2Ftest%2Frun-pass%2Fanon-extern-mod-cross-crate-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dc9f6277939a661011a07fbc88f0f0449ac276c/src%2Ftest%2Frun-pass%2Fanon-extern-mod-cross-crate-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fanon-extern-mod-cross-crate-2.rs?ref=0dc9f6277939a661011a07fbc88f0f0449ac276c", "patch": "@@ -15,9 +15,6 @@ extern mod anonexternmod;\n \n use anonexternmod::rust_get_test_int;\n \n-#[link(name = \"rustrt\")] // we have explicitly chosen to require this\n-extern {}\n-\n pub fn main() {\n     unsafe {\n         rust_get_test_int();"}, {"sha": "b48b8c3cd4599a6fa49730d5f7198e2c62135873", "filename": "src/test/run-pass/invoke-external-foreign.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0dc9f6277939a661011a07fbc88f0f0449ac276c/src%2Ftest%2Frun-pass%2Finvoke-external-foreign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dc9f6277939a661011a07fbc88f0f0449ac276c/src%2Ftest%2Frun-pass%2Finvoke-external-foreign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Finvoke-external-foreign.rs?ref=0dc9f6277939a661011a07fbc88f0f0449ac276c", "patch": "@@ -18,9 +18,6 @@\n \n extern mod foreign_lib;\n \n-#[link(name = \"rustrt\")] // we have explicitly chosen to require this\n-extern {}\n-\n pub fn main() {\n     unsafe {\n         let _foo = foreign_lib::rustrt::rust_get_test_int();"}]}