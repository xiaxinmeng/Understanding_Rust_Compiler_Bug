{"sha": "afc199bea04a860f9021bf379c4ed26c9008cae7", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFmYzE5OWJlYTA0YTg2MGY5MDIxYmYzNzljNGVkMjZjOTAwOGNhZTc=", "commit": {"author": {"name": "Ben Blum", "email": "bblum@andrew.cmu.edu", "date": "2013-07-02T21:55:54Z"}, "committer": {"name": "Ben Blum", "email": "bblum@andrew.cmu.edu", "date": "2013-07-20T09:08:56Z"}, "message": "Remove join_latch", "tree": {"sha": "54d55cbf35d8528ee47228035af6aa66e810686f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/54d55cbf35d8528ee47228035af6aa66e810686f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/afc199bea04a860f9021bf379c4ed26c9008cae7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/afc199bea04a860f9021bf379c4ed26c9008cae7", "html_url": "https://github.com/rust-lang/rust/commit/afc199bea04a860f9021bf379c4ed26c9008cae7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/afc199bea04a860f9021bf379c4ed26c9008cae7/comments", "author": {"login": "bblum", "id": 1820515, "node_id": "MDQ6VXNlcjE4MjA1MTU=", "avatar_url": "https://avatars.githubusercontent.com/u/1820515?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bblum", "html_url": "https://github.com/bblum", "followers_url": "https://api.github.com/users/bblum/followers", "following_url": "https://api.github.com/users/bblum/following{/other_user}", "gists_url": "https://api.github.com/users/bblum/gists{/gist_id}", "starred_url": "https://api.github.com/users/bblum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bblum/subscriptions", "organizations_url": "https://api.github.com/users/bblum/orgs", "repos_url": "https://api.github.com/users/bblum/repos", "events_url": "https://api.github.com/users/bblum/events{/privacy}", "received_events_url": "https://api.github.com/users/bblum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bblum", "id": 1820515, "node_id": "MDQ6VXNlcjE4MjA1MTU=", "avatar_url": "https://avatars.githubusercontent.com/u/1820515?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bblum", "html_url": "https://github.com/bblum", "followers_url": "https://api.github.com/users/bblum/followers", "following_url": "https://api.github.com/users/bblum/following{/other_user}", "gists_url": "https://api.github.com/users/bblum/gists{/gist_id}", "starred_url": "https://api.github.com/users/bblum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bblum/subscriptions", "organizations_url": "https://api.github.com/users/bblum/orgs", "repos_url": "https://api.github.com/users/bblum/repos", "events_url": "https://api.github.com/users/bblum/events{/privacy}", "received_events_url": "https://api.github.com/users/bblum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6882508b6f9be4d4537ee863fb42f1ae862045a8", "url": "https://api.github.com/repos/rust-lang/rust/commits/6882508b6f9be4d4537ee863fb42f1ae862045a8", "html_url": "https://github.com/rust-lang/rust/commit/6882508b6f9be4d4537ee863fb42f1ae862045a8"}], "stats": {"total": 654, "additions": 0, "deletions": 654}, "files": [{"sha": "924db1a21b729774ad1d9ba06db52be254555961", "filename": "src/libstd/rt/join_latch.rs", "status": "removed", "additions": 0, "deletions": 647, "changes": 647, "blob_url": "https://github.com/rust-lang/rust/blob/6882508b6f9be4d4537ee863fb42f1ae862045a8/src%2Flibstd%2Frt%2Fjoin_latch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6882508b6f9be4d4537ee863fb42f1ae862045a8/src%2Flibstd%2Frt%2Fjoin_latch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fjoin_latch.rs?ref=6882508b6f9be4d4537ee863fb42f1ae862045a8", "patch": "@@ -1,647 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! The JoinLatch is a concurrent type that establishes the task\n-//! tree and propagates failure.\n-//!\n-//! Each task gets a JoinLatch that is derived from the JoinLatch\n-//! of its parent task. Every latch must be released by either calling\n-//! the non-blocking `release` method or the task-blocking `wait` method.\n-//! Releasing a latch does not complete until all of its child latches\n-//! complete.\n-//!\n-//! Latches carry a `success` flag that is set to `false` during task\n-//! failure and is propagated both from children to parents and parents\n-//! to children. The status af this flag may be queried for the purposes\n-//! of linked failure.\n-//!\n-//! In addition to failure propagation the task tree serves to keep the\n-//! default task schedulers alive. The runtime only sends the shutdown\n-//! message to schedulers once the root task exits.\n-//!\n-//! Under this scheme tasks that terminate before their children become\n-//! 'zombies' since they may not exit until their children do. Zombie\n-//! tasks are 'tombstoned' as `Tombstone(~JoinLatch)` and the tasks\n-//! themselves allowed to terminate.\n-//!\n-//! XXX: Propagate flag from parents to children.\n-//! XXX: Tombstoning actually doesn't work.\n-//! XXX: This could probably be done in a way that doesn't leak tombstones\n-//!      longer than the life of the child tasks.\n-\n-use comm::{GenericPort, Peekable, GenericSmartChan};\n-use clone::Clone;\n-use container::Container;\n-use option::{Option, Some, None};\n-use ops::Drop;\n-use rt::comm::{SharedChan, Port, stream};\n-use rt::local::Local;\n-use rt::sched::Scheduler;\n-use unstable::atomics::{AtomicUint, SeqCst};\n-use util;\n-use vec::OwnedVector;\n-\n-// FIXME #7026: Would prefer this to be an enum\n-pub struct JoinLatch {\n-    priv parent: Option<ParentLink>,\n-    priv child: Option<ChildLink>,\n-    closed: bool,\n-}\n-\n-// Shared between parents and all their children.\n-struct SharedState {\n-    /// Reference count, held by a parent and all children.\n-    count: AtomicUint,\n-    success: bool\n-}\n-\n-struct ParentLink {\n-    shared: *mut SharedState,\n-    // For communicating with the parent.\n-    chan: SharedChan<Message>\n-}\n-\n-struct ChildLink {\n-    shared: ~SharedState,\n-    // For receiving from children.\n-    port: Port<Message>,\n-    chan: SharedChan<Message>,\n-    // Prevents dropping the child SharedState reference counts multiple times.\n-    dropped_child: bool\n-}\n-\n-// Messages from child latches to parent.\n-enum Message {\n-    Tombstone(~JoinLatch),\n-    ChildrenTerminated\n-}\n-\n-impl JoinLatch {\n-    pub fn new_root() -> ~JoinLatch {\n-        let this = ~JoinLatch {\n-            parent: None,\n-            child: None,\n-            closed: false\n-        };\n-        rtdebug!(\"new root latch %x\", this.id());\n-        return this;\n-    }\n-\n-    fn id(&self) -> uint {\n-        unsafe { ::cast::transmute(&*self) }\n-    }\n-\n-    pub fn new_child(&mut self) -> ~JoinLatch {\n-        rtassert!(!self.closed);\n-\n-        if self.child.is_none() {\n-            // This is the first time spawning a child\n-            let shared = ~SharedState {\n-                count: AtomicUint::new(1),\n-                success: true\n-            };\n-            let (port, chan) = stream();\n-            let chan = SharedChan::new(chan);\n-            let child = ChildLink {\n-                shared: shared,\n-                port: port,\n-                chan: chan,\n-                dropped_child: false\n-            };\n-            self.child = Some(child);\n-        }\n-\n-        let child_link: &mut ChildLink = self.child.get_mut_ref();\n-        let shared_state: *mut SharedState = &mut *child_link.shared;\n-\n-        child_link.shared.count.fetch_add(1, SeqCst);\n-\n-        let child = ~JoinLatch {\n-            parent: Some(ParentLink {\n-                shared: shared_state,\n-                chan: child_link.chan.clone()\n-            }),\n-            child: None,\n-            closed: false\n-        };\n-        rtdebug!(\"NEW child latch %x\", child.id());\n-        return child;\n-    }\n-\n-    pub fn release(~self, local_success: bool) {\n-        // XXX: This should not block, but there's a bug in the below\n-        // code that I can't figure out.\n-        self.wait(local_success);\n-    }\n-\n-    // XXX: Should not require ~self\n-    fn release_broken(~self, local_success: bool) {\n-        rtassert!(!self.closed);\n-\n-        rtdebug!(\"releasing %x\", self.id());\n-\n-        let id = self.id();\n-        let _ = id; // XXX: `id` is only used in debug statements so appears unused\n-        let mut this = self;\n-        let mut child_success = true;\n-        let mut children_done = false;\n-\n-        if this.child.is_some() {\n-            rtdebug!(\"releasing children\");\n-            let child_link: &mut ChildLink = this.child.get_mut_ref();\n-            let shared: &mut SharedState = &mut *child_link.shared;\n-\n-            if !child_link.dropped_child {\n-                let last_count = shared.count.fetch_sub(1, SeqCst);\n-                rtdebug!(\"child count before sub %u %x\", last_count, id);\n-                if last_count == 1 {\n-                    assert!(child_link.chan.try_send(ChildrenTerminated));\n-                }\n-                child_link.dropped_child = true;\n-            }\n-\n-            // Wait for messages from children\n-            let mut tombstones = ~[];\n-            loop {\n-                if child_link.port.peek() {\n-                    match child_link.port.recv() {\n-                        Tombstone(t) => {\n-                            tombstones.push(t);\n-                        },\n-                        ChildrenTerminated => {\n-                            children_done = true;\n-                            break;\n-                        }\n-                    }\n-                } else {\n-                    break\n-                }\n-            }\n-\n-            rtdebug!(\"releasing %u tombstones %x\", tombstones.len(), id);\n-\n-            // Try to release the tombstones. Those that still have\n-            // outstanding will be re-enqueued.  When this task's\n-            // parents release their latch we'll end up back here\n-            // trying them again.\n-            while !tombstones.is_empty() {\n-                tombstones.pop().release(true);\n-            }\n-\n-            if children_done {\n-                let count = shared.count.load(SeqCst);\n-                assert!(count == 0);\n-                // self_count is the acquire-read barrier\n-                child_success = shared.success;\n-            }\n-        } else {\n-            children_done = true;\n-        }\n-\n-        let total_success = local_success && child_success;\n-\n-        rtassert!(this.parent.is_some());\n-\n-        unsafe {\n-            {\n-                let parent_link: &mut ParentLink = this.parent.get_mut_ref();\n-                let shared: *mut SharedState = parent_link.shared;\n-\n-                if !total_success {\n-                    // parent_count is the write-wait barrier\n-                    (*shared).success = false;\n-                }\n-            }\n-\n-            if children_done {\n-                rtdebug!(\"children done\");\n-                do Local::borrow::<Scheduler, ()> |sched| {\n-                    sched.metrics.release_tombstone += 1;\n-                }\n-                {\n-                    rtdebug!(\"RELEASING parent %x\", id);\n-                    let parent_link: &mut ParentLink = this.parent.get_mut_ref();\n-                    let shared: *mut SharedState = parent_link.shared;\n-                    let last_count = (*shared).count.fetch_sub(1, SeqCst);\n-                    rtdebug!(\"count before parent sub %u %x\", last_count, id);\n-                    if last_count == 1 {\n-                        assert!(parent_link.chan.try_send(ChildrenTerminated));\n-                    }\n-                }\n-                this.closed = true;\n-                util::ignore(this);\n-            } else {\n-                rtdebug!(\"children not done\");\n-                rtdebug!(\"TOMBSTONING %x\", id);\n-                do Local::borrow::<Scheduler, ()> |sched| {\n-                    sched.metrics.release_no_tombstone += 1;\n-                }\n-                let chan = {\n-                    let parent_link: &mut ParentLink = this.parent.get_mut_ref();\n-                    parent_link.chan.clone()\n-                };\n-                assert!(chan.try_send(Tombstone(this)));\n-            }\n-        }\n-    }\n-\n-    // XXX: Should not require ~self\n-    pub fn wait(~self, local_success: bool) -> bool {\n-        rtassert!(!self.closed);\n-\n-        rtdebug!(\"WAITING %x\", self.id());\n-\n-        let mut this = self;\n-        let mut child_success = true;\n-\n-        if this.child.is_some() {\n-            rtdebug!(\"waiting for children\");\n-            let child_link: &mut ChildLink = this.child.get_mut_ref();\n-            let shared: &mut SharedState = &mut *child_link.shared;\n-\n-            if !child_link.dropped_child {\n-                let last_count = shared.count.fetch_sub(1, SeqCst);\n-                rtdebug!(\"child count before sub %u\", last_count);\n-                if last_count == 1 {\n-                    assert!(child_link.chan.try_send(ChildrenTerminated));\n-                }\n-                child_link.dropped_child = true;\n-            }\n-\n-            // Wait for messages from children\n-            loop {\n-                match child_link.port.recv() {\n-                    Tombstone(t) => {\n-                        t.wait(true);\n-                    }\n-                    ChildrenTerminated => break\n-                }\n-            }\n-\n-            let count = shared.count.load(SeqCst);\n-            if count != 0 { ::io::println(fmt!(\"%u\", count)); }\n-            assert!(count == 0);\n-            // self_count is the acquire-read barrier\n-            child_success = shared.success;\n-        }\n-\n-        let total_success = local_success && child_success;\n-\n-        if this.parent.is_some() {\n-            rtdebug!(\"releasing parent\");\n-            unsafe {\n-                let parent_link: &mut ParentLink = this.parent.get_mut_ref();\n-                let shared: *mut SharedState = parent_link.shared;\n-\n-                if !total_success {\n-                    // parent_count is the write-wait barrier\n-                    (*shared).success = false;\n-                }\n-\n-                let last_count = (*shared).count.fetch_sub(1, SeqCst);\n-                rtdebug!(\"count before parent sub %u\", last_count);\n-                if last_count == 1 {\n-                    assert!(parent_link.chan.try_send(ChildrenTerminated));\n-                }\n-            }\n-        }\n-\n-        this.closed = true;\n-        util::ignore(this);\n-\n-        return total_success;\n-    }\n-}\n-\n-impl Drop for JoinLatch {\n-    fn drop(&self) {\n-        rtdebug!(\"DESTROYING %x\", self.id());\n-        rtassert!(self.closed);\n-    }\n-}\n-\n-#[cfg(test)]\n-mod test {\n-    use super::*;\n-    use cell::Cell;\n-    use container::Container;\n-    use iter::Times;\n-    use rt::test::*;\n-    use rand;\n-    use rand::RngUtil;\n-    use vec::{CopyableVector, ImmutableVector};\n-\n-    #[test]\n-    fn success_immediately() {\n-        do run_in_newsched_task {\n-            let mut latch = JoinLatch::new_root();\n-\n-            let child_latch = latch.new_child();\n-            let child_latch = Cell::new(child_latch);\n-            do spawntask_immediately {\n-                let child_latch = child_latch.take();\n-                assert!(child_latch.wait(true));\n-            }\n-\n-            assert!(latch.wait(true));\n-        }\n-    }\n-\n-    #[test]\n-    fn success_later() {\n-        do run_in_newsched_task {\n-            let mut latch = JoinLatch::new_root();\n-\n-            let child_latch = latch.new_child();\n-            let child_latch = Cell::new(child_latch);\n-            do spawntask_later {\n-                let child_latch = child_latch.take();\n-                assert!(child_latch.wait(true));\n-            }\n-\n-            assert!(latch.wait(true));\n-        }\n-    }\n-\n-    #[test]\n-    fn mt_success() {\n-        do run_in_mt_newsched_task {\n-            let mut latch = JoinLatch::new_root();\n-\n-            for 10.times {\n-                let child_latch = latch.new_child();\n-                let child_latch = Cell::new(child_latch);\n-                do spawntask_random {\n-                    let child_latch = child_latch.take();\n-                    assert!(child_latch.wait(true));\n-                }\n-            }\n-\n-            assert!(latch.wait(true));\n-        }\n-    }\n-\n-    #[test]\n-    fn mt_failure() {\n-        do run_in_mt_newsched_task {\n-            let mut latch = JoinLatch::new_root();\n-\n-            let spawn = |status| {\n-                let child_latch = latch.new_child();\n-                let child_latch = Cell::new(child_latch);\n-                do spawntask_random {\n-                    let child_latch = child_latch.take();\n-                    child_latch.wait(status);\n-                }\n-            };\n-\n-            for 10.times { spawn(true) }\n-            spawn(false);\n-            for 10.times { spawn(true) }\n-\n-            assert!(!latch.wait(true));\n-        }\n-    }\n-\n-    #[test]\n-    fn mt_multi_level_success() {\n-        do run_in_mt_newsched_task {\n-            let mut latch = JoinLatch::new_root();\n-\n-            fn child(latch: &mut JoinLatch, i: int) {\n-                let child_latch = latch.new_child();\n-                let child_latch = Cell::new(child_latch);\n-                do spawntask_random {\n-                    let mut child_latch = child_latch.take();\n-                    if i != 0 {\n-                        child(&mut *child_latch, i - 1);\n-                        child_latch.wait(true);\n-                    } else {\n-                        child_latch.wait(true);\n-                    }\n-                }\n-            }\n-\n-            child(&mut *latch, 10);\n-\n-            assert!(latch.wait(true));\n-        }\n-    }\n-\n-    #[test]\n-    fn mt_multi_level_failure() {\n-        do run_in_mt_newsched_task {\n-            let mut latch = JoinLatch::new_root();\n-\n-            fn child(latch: &mut JoinLatch, i: int) {\n-                let child_latch = latch.new_child();\n-                let child_latch = Cell::new(child_latch);\n-                do spawntask_random {\n-                    let mut child_latch = child_latch.take();\n-                    if i != 0 {\n-                        child(&mut *child_latch, i - 1);\n-                        child_latch.wait(false);\n-                    } else {\n-                        child_latch.wait(true);\n-                    }\n-                }\n-            }\n-\n-            child(&mut *latch, 10);\n-\n-            assert!(!latch.wait(true));\n-        }\n-    }\n-\n-    #[test]\n-    fn release_child() {\n-        do run_in_newsched_task {\n-            let mut latch = JoinLatch::new_root();\n-            let child_latch = latch.new_child();\n-            let child_latch = Cell::new(child_latch);\n-\n-            do spawntask_immediately {\n-                let latch = child_latch.take();\n-                latch.release(false);\n-            }\n-\n-            assert!(!latch.wait(true));\n-        }\n-    }\n-\n-    #[test]\n-    fn release_child_tombstone() {\n-        do run_in_newsched_task {\n-            let mut latch = JoinLatch::new_root();\n-            let child_latch = latch.new_child();\n-            let child_latch = Cell::new(child_latch);\n-\n-            do spawntask_immediately {\n-                let mut latch = child_latch.take();\n-                let child_latch = latch.new_child();\n-                let child_latch = Cell::new(child_latch);\n-                do spawntask_later {\n-                    let latch = child_latch.take();\n-                    latch.release(false);\n-                }\n-                latch.release(true);\n-            }\n-\n-            assert!(!latch.wait(true));\n-        }\n-    }\n-\n-    #[test]\n-    fn release_child_no_tombstone() {\n-        do run_in_newsched_task {\n-            let mut latch = JoinLatch::new_root();\n-            let child_latch = latch.new_child();\n-            let child_latch = Cell::new(child_latch);\n-\n-            do spawntask_later {\n-                let mut latch = child_latch.take();\n-                let child_latch = latch.new_child();\n-                let child_latch = Cell::new(child_latch);\n-                do spawntask_immediately {\n-                    let latch = child_latch.take();\n-                    latch.release(false);\n-                }\n-                latch.release(true);\n-            }\n-\n-            assert!(!latch.wait(true));\n-        }\n-    }\n-\n-    #[test]\n-    fn release_child_tombstone_stress() {\n-        fn rand_orders() -> ~[bool] {\n-            let mut v = ~[false,.. 5];\n-            v[0] = true;\n-            let mut rng = rand::rng();\n-            return rng.shuffle(v);\n-        }\n-\n-        fn split_orders(orders: &[bool]) -> (~[bool], ~[bool]) {\n-            if orders.is_empty() {\n-                return (~[], ~[]);\n-            } else if orders.len() <= 2 {\n-                return (orders.to_owned(), ~[]);\n-            }\n-            let mut rng = rand::rng();\n-            let n = rng.gen_uint_range(1, orders.len());\n-            let first = orders.slice(0, n).to_owned();\n-            let last = orders.slice(n, orders.len()).to_owned();\n-            assert!(first.len() + last.len() == orders.len());\n-            return (first, last);\n-        }\n-\n-        for stress_factor().times {\n-            do run_in_newsched_task {\n-                fn doit(latch: &mut JoinLatch, orders: ~[bool], depth: uint) {\n-                    let (my_orders, remaining_orders) = split_orders(orders);\n-                    rtdebug!(\"(my_orders, remaining): %?\", (&my_orders, &remaining_orders));\n-                    rtdebug!(\"depth: %u\", depth);\n-                    let mut remaining_orders = remaining_orders;\n-                    let mut num = 0;\n-                    for my_orders.iter().advance |&order| {\n-                        let child_latch = latch.new_child();\n-                        let child_latch = Cell::new(child_latch);\n-                        let (child_orders, remaining) = split_orders(remaining_orders);\n-                        rtdebug!(\"(child_orders, remaining): %?\", (&child_orders, &remaining));\n-                        remaining_orders = remaining;\n-                        let child_orders = Cell::new(child_orders);\n-                        let child_num = num;\n-                        let _ = child_num; // XXX unused except in rtdebug!\n-                        do spawntask_random {\n-                            rtdebug!(\"depth %u num %u\", depth, child_num);\n-                            let mut child_latch = child_latch.take();\n-                            let child_orders = child_orders.take();\n-                            doit(&mut *child_latch, child_orders, depth + 1);\n-                            child_latch.release(order);\n-                        }\n-\n-                        num += 1;\n-                    }\n-                }\n-\n-                let mut latch = JoinLatch::new_root();\n-                let orders = rand_orders();\n-                rtdebug!(\"orders: %?\", orders);\n-\n-                doit(&mut *latch, orders, 0);\n-\n-                assert!(!latch.wait(true));\n-            }\n-        }\n-    }\n-\n-    #[deriving(Clone)]\n-    struct Order {\n-        immediate: bool,\n-        succeed: bool,\n-        orders: ~[Order]\n-    }\n-\n-    #[test]\n-    fn whateverman() {\n-        fn next(latch: &mut JoinLatch, orders: ~[Order]) {\n-            for orders.iter().advance |order| {\n-                let suborders = order.orders.clone();\n-                let child_latch = Cell::new(latch.new_child());\n-                let succeed = order.succeed;\n-                if order.immediate {\n-                    do spawntask_immediately {\n-                        let mut child_latch = child_latch.take();\n-                        next(&mut *child_latch, suborders.clone());\n-                        rtdebug!(\"immediate releasing\");\n-                        child_latch.release(succeed);\n-                    }\n-                } else {\n-                    do spawntask_later {\n-                        let mut child_latch = child_latch.take();\n-                        next(&mut *child_latch, suborders.clone());\n-                        rtdebug!(\"later releasing\");\n-                        child_latch.release(succeed);\n-                    }\n-                }\n-            }\n-        }\n-\n-        do run_in_newsched_task {\n-            let mut latch = JoinLatch::new_root();\n-            let orders = ~[ Order { // 0 0\n-                immediate: true,\n-                succeed: true,\n-                orders: ~[ Order { // 1 0\n-                    immediate: true,\n-                    succeed: false,\n-                    orders: ~[ Order { // 2 0\n-                        immediate: false,\n-                        succeed: false,\n-                        orders: ~[ Order { // 3 0\n-                            immediate: true,\n-                            succeed: false,\n-                            orders: ~[]\n-                        }, Order { // 3 1\n-                            immediate: false,\n-                            succeed: false,\n-                            orders: ~[]\n-                        }]\n-                    }]\n-                }]\n-            }];\n-\n-            next(&mut *latch, orders);\n-            assert!(!latch.wait(true));\n-        }\n-    }\n-}\n-"}, {"sha": "0da7a8f8fc33fa56343c1bde37f7e4a636d6906b", "filename": "src/libstd/rt/mod.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/afc199bea04a860f9021bf379c4ed26c9008cae7/src%2Flibstd%2Frt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afc199bea04a860f9021bf379c4ed26c9008cae7/src%2Flibstd%2Frt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fmod.rs?ref=afc199bea04a860f9021bf379c4ed26c9008cae7", "patch": "@@ -152,9 +152,6 @@ pub mod local_ptr;\n /// Bindings to pthread/windows thread-local storage.\n pub mod thread_local_storage;\n \n-/// For waiting on child tasks.\n-pub mod join_latch;\n-\n pub mod metrics;\n \n // FIXME #5248 shouldn't be pub"}, {"sha": "a1227dd180c32dd06b97bfbcc3f08714e0673a75", "filename": "src/libstd/rt/task.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/afc199bea04a860f9021bf379c4ed26c9008cae7/src%2Flibstd%2Frt%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afc199bea04a860f9021bf379c4ed26c9008cae7/src%2Flibstd%2Frt%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Ftask.rs?ref=afc199bea04a860f9021bf379c4ed26c9008cae7", "patch": "@@ -25,7 +25,6 @@ use rt::local::Local;\n use rt::logging::StdErrLogger;\n use super::local_heap::LocalHeap;\n use rt::sched::{Scheduler, SchedHandle};\n-use rt::join_latch::JoinLatch;\n use rt::stack::{StackSegment, StackPool};\n use rt::context::Context;\n use cell::Cell;\n@@ -38,7 +37,6 @@ pub struct Task {\n     unwinder: Unwinder,\n     home: Option<SchedHome>,\n     death: Death,\n-    join_latch: Option<~JoinLatch>, // FIXME(#7544) remove\n     destroyed: bool,\n     coroutine: Option<~Coroutine>\n }\n@@ -88,7 +86,6 @@ impl Task {\n             unwinder: Unwinder { unwinding: false },\n             home: Some(home),\n             death: Death::new(),\n-            join_latch: Some(JoinLatch::new_root()),\n             destroyed: false,\n             coroutine: Some(~Coroutine::new(stack_pool, start))\n         }\n@@ -107,7 +104,6 @@ impl Task {\n             unwinder: Unwinder { unwinding: false },\n             // FIXME(#7544) make watching optional\n             death: self.death.new_child(),\n-            join_latch: Some(self.join_latch.get_mut_ref().new_child()),\n             destroyed: false,\n             coroutine: Some(~Coroutine::new(stack_pool, start))\n         }"}]}