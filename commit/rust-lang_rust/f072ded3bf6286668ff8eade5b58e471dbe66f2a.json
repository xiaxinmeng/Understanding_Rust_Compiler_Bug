{"sha": "f072ded3bf6286668ff8eade5b58e471dbe66f2a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYwNzJkZWQzYmY2Mjg2NjY4ZmY4ZWFkZTViNThlNDcxZGJlNjZmMmE=", "commit": {"author": {"name": "Eduardo Broto", "email": "ebroto@tutanota.com", "date": "2020-04-30T23:44:17Z"}, "committer": {"name": "Eduardo Broto", "email": "ebroto@tutanota.com", "date": "2020-05-01T00:10:16Z"}, "message": "Implement the manual_non_exhaustive lint", "tree": {"sha": "227cdec993055c1a9d56dd02180fb3c005a9a9fe", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/227cdec993055c1a9d56dd02180fb3c005a9a9fe"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f072ded3bf6286668ff8eade5b58e471dbe66f2a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f072ded3bf6286668ff8eade5b58e471dbe66f2a", "html_url": "https://github.com/rust-lang/rust/commit/f072ded3bf6286668ff8eade5b58e471dbe66f2a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f072ded3bf6286668ff8eade5b58e471dbe66f2a/comments", "author": {"login": "ebroto", "id": 816908, "node_id": "MDQ6VXNlcjgxNjkwOA==", "avatar_url": "https://avatars.githubusercontent.com/u/816908?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ebroto", "html_url": "https://github.com/ebroto", "followers_url": "https://api.github.com/users/ebroto/followers", "following_url": "https://api.github.com/users/ebroto/following{/other_user}", "gists_url": "https://api.github.com/users/ebroto/gists{/gist_id}", "starred_url": "https://api.github.com/users/ebroto/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ebroto/subscriptions", "organizations_url": "https://api.github.com/users/ebroto/orgs", "repos_url": "https://api.github.com/users/ebroto/repos", "events_url": "https://api.github.com/users/ebroto/events{/privacy}", "received_events_url": "https://api.github.com/users/ebroto/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ebroto", "id": 816908, "node_id": "MDQ6VXNlcjgxNjkwOA==", "avatar_url": "https://avatars.githubusercontent.com/u/816908?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ebroto", "html_url": "https://github.com/ebroto", "followers_url": "https://api.github.com/users/ebroto/followers", "following_url": "https://api.github.com/users/ebroto/following{/other_user}", "gists_url": "https://api.github.com/users/ebroto/gists{/gist_id}", "starred_url": "https://api.github.com/users/ebroto/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ebroto/subscriptions", "organizations_url": "https://api.github.com/users/ebroto/orgs", "repos_url": "https://api.github.com/users/ebroto/repos", "events_url": "https://api.github.com/users/ebroto/events{/privacy}", "received_events_url": "https://api.github.com/users/ebroto/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0a53ed2d8ea81d09b0ae2d6c5e206ec22a0ba46c", "url": "https://api.github.com/repos/rust-lang/rust/commits/0a53ed2d8ea81d09b0ae2d6c5e206ec22a0ba46c", "html_url": "https://github.com/rust-lang/rust/commit/0a53ed2d8ea81d09b0ae2d6c5e206ec22a0ba46c"}], "stats": {"total": 352, "additions": 352, "deletions": 0}, "files": [{"sha": "facf363e371e0f56e7729e19d0a4ad1246b1f5b6", "filename": "CHANGELOG.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f072ded3bf6286668ff8eade5b58e471dbe66f2a/CHANGELOG.md", "raw_url": "https://github.com/rust-lang/rust/raw/f072ded3bf6286668ff8eade5b58e471dbe66f2a/CHANGELOG.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CHANGELOG.md?ref=f072ded3bf6286668ff8eade5b58e471dbe66f2a", "patch": "@@ -1423,6 +1423,7 @@ Released 2018-09-13\n [`macro_use_imports`]: https://rust-lang.github.io/rust-clippy/master/index.html#macro_use_imports\n [`main_recursion`]: https://rust-lang.github.io/rust-clippy/master/index.html#main_recursion\n [`manual_memcpy`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_memcpy\n+[`manual_non_exhaustive`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_non_exhaustive\n [`manual_saturating_arithmetic`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_saturating_arithmetic\n [`manual_swap`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_swap\n [`many_single_char_names`]: https://rust-lang.github.io/rust-clippy/master/index.html#many_single_char_names"}, {"sha": "64f3a8a0ebbb1478c48afc3ed279f059ac227d41", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f072ded3bf6286668ff8eade5b58e471dbe66f2a/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f072ded3bf6286668ff8eade5b58e471dbe66f2a/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=f072ded3bf6286668ff8eade5b58e471dbe66f2a", "patch": "@@ -247,6 +247,7 @@ mod literal_representation;\n mod loops;\n mod macro_use;\n mod main_recursion;\n+mod manual_non_exhaustive;\n mod map_clone;\n mod map_unit_fn;\n mod match_on_vec_items;\n@@ -628,6 +629,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         &loops::WHILE_LET_ON_ITERATOR,\n         &macro_use::MACRO_USE_IMPORTS,\n         &main_recursion::MAIN_RECURSION,\n+        &manual_non_exhaustive::MANUAL_NON_EXHAUSTIVE,\n         &map_clone::MAP_CLONE,\n         &map_unit_fn::OPTION_MAP_UNIT_FN,\n         &map_unit_fn::RESULT_MAP_UNIT_FN,\n@@ -1064,6 +1066,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(|| box utils::internal_lints::CollapsibleCalls);\n     store.register_late_pass(|| box if_let_mutex::IfLetMutex);\n     store.register_late_pass(|| box match_on_vec_items::MatchOnVecItems);\n+    store.register_early_pass(|| box manual_non_exhaustive::ManualNonExhaustive);\n \n     store.register_group(true, \"clippy::restriction\", Some(\"clippy_restriction\"), vec![\n         LintId::of(&arithmetic::FLOAT_ARITHMETIC),\n@@ -1280,6 +1283,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&loops::WHILE_LET_LOOP),\n         LintId::of(&loops::WHILE_LET_ON_ITERATOR),\n         LintId::of(&main_recursion::MAIN_RECURSION),\n+        LintId::of(&manual_non_exhaustive::MANUAL_NON_EXHAUSTIVE),\n         LintId::of(&map_clone::MAP_CLONE),\n         LintId::of(&map_unit_fn::OPTION_MAP_UNIT_FN),\n         LintId::of(&map_unit_fn::RESULT_MAP_UNIT_FN),\n@@ -1474,6 +1478,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&loops::NEEDLESS_RANGE_LOOP),\n         LintId::of(&loops::WHILE_LET_ON_ITERATOR),\n         LintId::of(&main_recursion::MAIN_RECURSION),\n+        LintId::of(&manual_non_exhaustive::MANUAL_NON_EXHAUSTIVE),\n         LintId::of(&map_clone::MAP_CLONE),\n         LintId::of(&matches::INFALLIBLE_DESTRUCTURING_MATCH),\n         LintId::of(&matches::MATCH_OVERLAPPING_ARM),"}, {"sha": "ca2a2cf2e1e7f083d1b4abb70bb4335abc86dd8d", "filename": "clippy_lints/src/manual_non_exhaustive.rs", "status": "added", "additions": 167, "deletions": 0, "changes": 167, "blob_url": "https://github.com/rust-lang/rust/blob/f072ded3bf6286668ff8eade5b58e471dbe66f2a/clippy_lints%2Fsrc%2Fmanual_non_exhaustive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f072ded3bf6286668ff8eade5b58e471dbe66f2a/clippy_lints%2Fsrc%2Fmanual_non_exhaustive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmanual_non_exhaustive.rs?ref=f072ded3bf6286668ff8eade5b58e471dbe66f2a", "patch": "@@ -0,0 +1,167 @@\n+use crate::utils::{snippet_opt, span_lint_and_then};\n+use if_chain::if_chain;\n+use rustc_ast::ast::{Attribute, Ident, Item, ItemKind, StructField, TyKind, Variant, VariantData, VisibilityKind};\n+use rustc_attr as attr;\n+use rustc_errors::Applicability;\n+use rustc_lint::{EarlyContext, EarlyLintPass};\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for manual implementations of the non-exhaustive pattern.\n+    ///\n+    /// **Why is this bad?** Using the #[non_exhaustive] attribute expresses better the intent\n+    /// and allows possible optimizations when applied to enums.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    ///\n+    /// ```rust\n+    /// struct S {\n+    ///     pub a: i32,\n+    ///     pub b: i32,\n+    ///     _c: (),\n+    /// }\n+    ///\n+    /// enum E {\n+    ///     A,\n+    ///     B,\n+    ///     #[doc(hidden)]\n+    ///     _C,\n+    /// }\n+    ///\n+    /// struct T(pub i32, pub i32, ());\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// #[non_exhaustive]\n+    /// struct S {\n+    ///     pub a: i32,\n+    ///     pub b: i32,\n+    /// }\n+    ///\n+    /// #[non_exhaustive]\n+    /// enum E {\n+    ///     A,\n+    ///     B,\n+    /// }\n+    ///\n+    /// #[non_exhaustive]\n+    /// struct T(pub i32, pub i32);\n+    /// ```\n+    pub MANUAL_NON_EXHAUSTIVE,\n+    style,\n+    \"manual implementations of the non-exhaustive pattern can be simplified using #[non_exhaustive]\"\n+}\n+\n+declare_lint_pass!(ManualNonExhaustive => [MANUAL_NON_EXHAUSTIVE]);\n+\n+impl EarlyLintPass for ManualNonExhaustive {\n+    fn check_item(&mut self, cx: &EarlyContext<'_>, item: &Item) {\n+        match &item.kind {\n+            ItemKind::Enum(def, _) => {\n+                check_manual_non_exhaustive_enum(cx, item, &def.variants);\n+            },\n+            ItemKind::Struct(variant_data, _) => {\n+                if let VariantData::Unit(..) = variant_data {\n+                    return;\n+                }\n+\n+                check_manual_non_exhaustive_struct(cx, item, variant_data);\n+            },\n+            _ => {},\n+        }\n+    }\n+}\n+\n+fn check_manual_non_exhaustive_enum(cx: &EarlyContext<'_>, item: &Item, variants: &[Variant]) {\n+    fn is_non_exhaustive_marker(variant: &Variant) -> bool {\n+        matches!(variant.data, VariantData::Unit(_))\n+            && variant.ident.as_str().starts_with('_')\n+            && variant.attrs.iter().any(|a| is_doc_hidden(a))\n+    }\n+\n+    fn is_doc_hidden(attr: &Attribute) -> bool {\n+        attr.check_name(sym!(doc))\n+            && match attr.meta_item_list() {\n+                Some(l) => attr::list_contains_name(&l, sym!(hidden)),\n+                None => false,\n+            }\n+    }\n+\n+    if_chain! {\n+        if !attr::contains_name(&item.attrs, sym!(non_exhaustive));\n+        let markers = variants.iter().filter(|v| is_non_exhaustive_marker(v)).count();\n+        if markers == 1 && variants.len() > markers;\n+        if let Some(variant) = variants.last();\n+        if is_non_exhaustive_marker(variant);\n+        then {\n+            span_lint_and_then(\n+                cx,\n+                MANUAL_NON_EXHAUSTIVE,\n+                item.span,\n+                \"this seems like a manual implementation of the non-exhaustive pattern\",\n+                |diag| {\n+                    let header_span = cx.sess.source_map().span_until_char(item.span, '{');\n+\n+                    if let Some(snippet) = snippet_opt(cx, header_span) {\n+                        diag.span_suggestion(\n+                            item.span,\n+                            \"add the attribute\",\n+                            format!(\"#[non_exhaustive] {}\", snippet),\n+                            Applicability::Unspecified,\n+                        );\n+                        diag.span_help(variant.span, \"and remove this variant\");\n+                    }\n+                });\n+        }\n+    }\n+}\n+\n+fn check_manual_non_exhaustive_struct(cx: &EarlyContext<'_>, item: &Item, data: &VariantData) {\n+    fn is_private(field: &StructField) -> bool {\n+        matches!(field.vis.node, VisibilityKind::Inherited)\n+    }\n+\n+    fn is_non_exhaustive_marker(name: &Option<Ident>) -> bool {\n+        name.map(|n| n.as_str().starts_with('_')).unwrap_or(true)\n+    }\n+\n+    let fields = data.fields();\n+    let private_fields = fields.iter().filter(|f| is_private(f)).count();\n+    let public_fields = fields.iter().filter(|f| f.vis.node.is_pub()).count();\n+\n+    if_chain! {\n+        if !attr::contains_name(&item.attrs, sym!(non_exhaustive));\n+        if private_fields == 1 && public_fields >= private_fields && public_fields == fields.len() - 1;\n+        if let Some(field) = fields.iter().find(|f| is_private(f));\n+        if is_non_exhaustive_marker(&field.ident);\n+        if let TyKind::Tup(tup_fields) = &field.ty.kind;\n+        if tup_fields.is_empty();\n+        then {\n+            span_lint_and_then(\n+                cx,\n+                MANUAL_NON_EXHAUSTIVE,\n+                item.span,\n+                \"this seems like a manual implementation of the non-exhaustive pattern\",\n+                |diag| {\n+                    let delimiter = match data {\n+                        VariantData::Struct(..) => '{',\n+                        VariantData::Tuple(..) => '(',\n+                        _ => unreachable!(),\n+                    };\n+                    let header_span = cx.sess.source_map().span_until_char(item.span, delimiter);\n+\n+                    if let Some(snippet) = snippet_opt(cx, header_span) {\n+                        diag.span_suggestion(\n+                            item.span,\n+                            \"add the attribute\",\n+                            format!(\"#[non_exhaustive] {}\", snippet),\n+                            Applicability::Unspecified,\n+                        );\n+                        diag.span_help(field.span, \"and remove this field\");\n+                    }\n+                });\n+        }\n+    }\n+}"}, {"sha": "c5360002fa05dd694722540117c593cca2dc3fe9", "filename": "src/lintlist/mod.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f072ded3bf6286668ff8eade5b58e471dbe66f2a/src%2Flintlist%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f072ded3bf6286668ff8eade5b58e471dbe66f2a/src%2Flintlist%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flintlist%2Fmod.rs?ref=f072ded3bf6286668ff8eade5b58e471dbe66f2a", "patch": "@@ -1088,6 +1088,13 @@ pub static ref ALL_LINTS: Vec<Lint> = vec![\n         deprecation: None,\n         module: \"loops\",\n     },\n+    Lint {\n+        name: \"manual_non_exhaustive\",\n+        group: \"style\",\n+        desc: \"manual implementations of the non-exhaustive pattern can be simplified using #[non_exhaustive]\",\n+        deprecation: None,\n+        module: \"manual_non_exhaustive\",\n+    },\n     Lint {\n         name: \"manual_saturating_arithmetic\",\n         group: \"style\","}, {"sha": "9c239db6e00d05b8f61dbe93db2dc66ba1de5288", "filename": "tests/ui/manual_non_exhaustive.rs", "status": "added", "additions": 124, "deletions": 0, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/f072ded3bf6286668ff8eade5b58e471dbe66f2a/tests%2Fui%2Fmanual_non_exhaustive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f072ded3bf6286668ff8eade5b58e471dbe66f2a/tests%2Fui%2Fmanual_non_exhaustive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmanual_non_exhaustive.rs?ref=f072ded3bf6286668ff8eade5b58e471dbe66f2a", "patch": "@@ -0,0 +1,124 @@\n+#![warn(clippy::manual_non_exhaustive)]\n+#![allow(unused)]\n+\n+mod enums {\n+    enum E {\n+        A,\n+        B,\n+        #[doc(hidden)]\n+        _C,\n+    }\n+\n+    // last variant does not have doc hidden attribute, should be ignored\n+    enum NoDocHidden {\n+        A,\n+        B,\n+        _C,\n+    }\n+\n+    // name of variant with doc hidden does not start with underscore, should be ignored\n+    enum NoUnderscore {\n+        A,\n+        B,\n+        #[doc(hidden)]\n+        C,\n+    }\n+\n+    // variant with doc hidden is not unit, should be ignored\n+    enum NotUnit {\n+        A,\n+        B,\n+        #[doc(hidden)]\n+        _C(bool),\n+    }\n+\n+    // variant with doc hidden is not the last one, should be ignored\n+    enum NotLast {\n+        A,\n+        #[doc(hidden)]\n+        _B,\n+        C,\n+    }\n+\n+    // variant with doc hidden is the only one, should be ignored\n+    enum OnlyMarker {\n+        #[doc(hidden)]\n+        _A,\n+    }\n+\n+    // variant with multiple non-exhaustive \"markers\", should be ignored\n+    enum MultipleMarkers {\n+        A,\n+        #[doc(hidden)]\n+        _B,\n+        #[doc(hidden)]\n+        _C,\n+    }\n+\n+    // already non_exhaustive, should be ignored\n+    #[non_exhaustive]\n+    enum NonExhaustive {\n+        A,\n+        B,\n+    }\n+}\n+\n+mod structs {\n+    struct S {\n+        pub a: i32,\n+        pub b: i32,\n+        _c: (),\n+    }\n+\n+    // some other fields are private, should be ignored\n+    struct PrivateFields {\n+        a: i32,\n+        pub b: i32,\n+        _c: (),\n+    }\n+\n+    // private field name does not start with underscore, should be ignored\n+    struct NoUnderscore {\n+        pub a: i32,\n+        pub b: i32,\n+        c: (),\n+    }\n+\n+    // private field is not unit type, should be ignored\n+    struct NotUnit {\n+        pub a: i32,\n+        pub b: i32,\n+        _c: i32,\n+    }\n+\n+    // private field is the only field, should be ignored\n+    struct OnlyMarker {\n+        _a: (),\n+    }\n+\n+    // already non exhaustive, should be ignored\n+    #[non_exhaustive]\n+    struct NonExhaustive {\n+        pub a: i32,\n+        pub b: i32,\n+    }\n+}\n+\n+mod tuple_structs {\n+    struct T(pub i32, pub i32, ());\n+\n+    // some other fields are private, should be ignored\n+    struct PrivateFields(pub i32, i32, ());\n+\n+    // private field is not unit type, should be ignored\n+    struct NotUnit(pub i32, pub i32, i32);\n+\n+    // private field is the only field, should be ignored\n+    struct OnlyMarker(());\n+\n+    // already non exhaustive, should be ignored\n+    #[non_exhaustive]\n+    struct NonExhaustive(pub i32, pub i32);\n+}\n+\n+fn main() {}"}, {"sha": "d6719bca0d4ceeb1989e47a9d755c52628155b64", "filename": "tests/ui/manual_non_exhaustive.stderr", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/f072ded3bf6286668ff8eade5b58e471dbe66f2a/tests%2Fui%2Fmanual_non_exhaustive.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f072ded3bf6286668ff8eade5b58e471dbe66f2a/tests%2Fui%2Fmanual_non_exhaustive.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmanual_non_exhaustive.stderr?ref=f072ded3bf6286668ff8eade5b58e471dbe66f2a", "patch": "@@ -0,0 +1,48 @@\n+error: this seems like a manual implementation of the non-exhaustive pattern\n+  --> $DIR/manual_non_exhaustive.rs:5:5\n+   |\n+LL | /     enum E {\n+LL | |         A,\n+LL | |         B,\n+LL | |         #[doc(hidden)]\n+LL | |         _C,\n+LL | |     }\n+   | |_____^ help: add the attribute: `#[non_exhaustive] enum E`\n+   |\n+   = note: `-D clippy::manual-non-exhaustive` implied by `-D warnings`\n+help: and remove this variant\n+  --> $DIR/manual_non_exhaustive.rs:9:9\n+   |\n+LL |         _C,\n+   |         ^^\n+\n+error: this seems like a manual implementation of the non-exhaustive pattern\n+  --> $DIR/manual_non_exhaustive.rs:67:5\n+   |\n+LL | /     struct S {\n+LL | |         pub a: i32,\n+LL | |         pub b: i32,\n+LL | |         _c: (),\n+LL | |     }\n+   | |_____^ help: add the attribute: `#[non_exhaustive] struct S`\n+   |\n+help: and remove this field\n+  --> $DIR/manual_non_exhaustive.rs:70:9\n+   |\n+LL |         _c: (),\n+   |         ^^^^^^\n+\n+error: this seems like a manual implementation of the non-exhaustive pattern\n+  --> $DIR/manual_non_exhaustive.rs:108:5\n+   |\n+LL |     struct T(pub i32, pub i32, ());\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: add the attribute: `#[non_exhaustive] struct T`\n+   |\n+help: and remove this field\n+  --> $DIR/manual_non_exhaustive.rs:108:32\n+   |\n+LL |     struct T(pub i32, pub i32, ());\n+   |                                ^^\n+\n+error: aborting due to 3 previous errors\n+"}]}