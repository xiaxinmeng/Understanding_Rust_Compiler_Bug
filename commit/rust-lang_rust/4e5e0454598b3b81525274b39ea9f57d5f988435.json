{"sha": "4e5e0454598b3b81525274b39ea9f57d5f988435", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRlNWUwNDU0NTk4YjNiODE1MjUyNzRiMzllYTlmNTdkNWY5ODg0MzU=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2018-08-27T21:56:11Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2018-09-08T11:15:10Z"}, "message": "resolve: Partially unify bindings from macro_rules and from other items", "tree": {"sha": "8493988448124aa4fe8985e999968140ada3f0c7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8493988448124aa4fe8985e999968140ada3f0c7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4e5e0454598b3b81525274b39ea9f57d5f988435", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4e5e0454598b3b81525274b39ea9f57d5f988435", "html_url": "https://github.com/rust-lang/rust/commit/4e5e0454598b3b81525274b39ea9f57d5f988435", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4e5e0454598b3b81525274b39ea9f57d5f988435/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "06da917b015a2eceac0e3cca22f9660edef25178", "url": "https://api.github.com/repos/rust-lang/rust/commits/06da917b015a2eceac0e3cca22f9660edef25178", "html_url": "https://github.com/rust-lang/rust/commit/06da917b015a2eceac0e3cca22f9660edef25178"}], "stats": {"total": 87, "additions": 32, "deletions": 55}, "files": [{"sha": "101395e7ac252bb989c175b69f253c0908f257be", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 18, "deletions": 28, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/4e5e0454598b3b81525274b39ea9f57d5f988435/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e5e0454598b3b81525274b39ea9f57d5f988435/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=4e5e0454598b3b81525274b39ea9f57d5f988435", "patch": "@@ -1166,7 +1166,6 @@ struct UseError<'a> {\n struct AmbiguityError<'a> {\n     span: Span,\n     name: Name,\n-    lexical: bool,\n     b1: &'a NameBinding<'a>,\n     b2: &'a NameBinding<'a>,\n }\n@@ -1816,7 +1815,7 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n             NameBindingKind::Import { .. } => false,\n             NameBindingKind::Ambiguity { b1, b2 } => {\n                 self.ambiguity_errors.push(AmbiguityError {\n-                    span, name: ident.name, lexical: false, b1, b2,\n+                    span, name: ident.name, b1, b2,\n                 });\n                 true\n             }\n@@ -4501,35 +4500,32 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n         vis.is_accessible_from(module.normal_ancestor_id, self)\n     }\n \n-    fn report_ambiguity_error(\n-        &self, name: Name, span: Span, _lexical: bool,\n-        def1: Def, is_import1: bool, is_glob1: bool, from_expansion1: bool, span1: Span,\n-        def2: Def, is_import2: bool, _is_glob2: bool, _from_expansion2: bool, span2: Span,\n-    ) {\n+    fn report_ambiguity_error(&self, name: Name, span: Span, b1: &NameBinding, b2: &NameBinding) {\n         let participle = |is_import: bool| if is_import { \"imported\" } else { \"defined\" };\n-        let msg1 = format!(\"`{}` could refer to the name {} here\", name, participle(is_import1));\n+        let msg1 =\n+            format!(\"`{}` could refer to the name {} here\", name, participle(b1.is_import()));\n         let msg2 =\n-            format!(\"`{}` could also refer to the name {} here\", name, participle(is_import2));\n-        let note = if from_expansion1 {\n-            Some(if let Def::Macro(..) = def1 {\n+            format!(\"`{}` could also refer to the name {} here\", name, participle(b2.is_import()));\n+        let note = if b1.expansion != Mark::root() {\n+            Some(if let Def::Macro(..) = b1.def() {\n                 format!(\"macro-expanded {} do not shadow\",\n-                        if is_import1 { \"macro imports\" } else { \"macros\" })\n+                        if b1.is_import() { \"macro imports\" } else { \"macros\" })\n             } else {\n                 format!(\"macro-expanded {} do not shadow when used in a macro invocation path\",\n-                        if is_import1 { \"imports\" } else { \"items\" })\n+                        if b1.is_import() { \"imports\" } else { \"items\" })\n             })\n-        } else if is_glob1 {\n+        } else if b1.is_glob_import() {\n             Some(format!(\"consider adding an explicit import of `{}` to disambiguate\", name))\n         } else {\n             None\n         };\n \n         let mut err = struct_span_err!(self.session, span, E0659, \"`{}` is ambiguous\", name);\n-        err.span_note(span1, &msg1);\n-        match def2 {\n-            Def::Macro(..) if span2.is_dummy() =>\n+        err.span_note(b1.span, &msg1);\n+        match b2.def() {\n+            Def::Macro(..) if b2.span.is_dummy() =>\n                 err.note(&format!(\"`{}` is also a builtin macro\", name)),\n-            _ => err.span_note(span2, &msg2),\n+            _ => err.span_note(b2.span, &msg2),\n         };\n         if let Some(note) = note {\n             err.note(&note);\n@@ -4554,15 +4550,9 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n             );\n         }\n \n-        for &AmbiguityError { span, name, b1, b2, lexical } in &self.ambiguity_errors {\n+        for &AmbiguityError { span, name, b1, b2 } in &self.ambiguity_errors {\n             if reported_spans.insert(span) {\n-                self.report_ambiguity_error(\n-                    name, span, lexical,\n-                    b1.def(), b1.is_import(), b1.is_glob_import(),\n-                    b1.expansion != Mark::root(), b1.span,\n-                    b2.def(), b2.is_import(), b2.is_glob_import(),\n-                    b2.expansion != Mark::root(), b2.span,\n-                );\n+                self.report_ambiguity_error(name, span, b1, b2);\n             }\n         }\n \n@@ -4586,9 +4576,9 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n         let mut reported_errors = FxHashSet();\n         for binding in replace(&mut self.disallowed_shadowing, Vec::new()) {\n             if self.resolve_legacy_scope(&binding.parent, binding.ident, false).is_some() &&\n-               reported_errors.insert((binding.ident, binding.span)) {\n+               reported_errors.insert((binding.ident, binding.binding.span)) {\n                 let msg = format!(\"`{}` is already in scope\", binding.ident);\n-                self.session.struct_span_err(binding.span, &msg)\n+                self.session.struct_span_err(binding.binding.span, &msg)\n                     .note(\"macro-expanded `macro_rules!`s may not shadow \\\n                            existing macros (see RFC 1560)\")\n                     .emit();"}, {"sha": "f240deb1b4c0635c3cffed3fe25568aba0724d59", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 14, "deletions": 26, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/4e5e0454598b3b81525274b39ea9f57d5f988435/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e5e0454598b3b81525274b39ea9f57d5f988435/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=4e5e0454598b3b81525274b39ea9f57d5f988435", "patch": "@@ -78,17 +78,12 @@ pub enum LegacyScope<'a> {\n     Binding(&'a LegacyBinding<'a>),\n }\n \n+// Binding produced by a `macro_rules` item.\n+// Not modularized, can shadow previous legacy bindings, etc.\n pub struct LegacyBinding<'a> {\n+    pub binding: &'a NameBinding<'a>,\n     pub parent: Cell<LegacyScope<'a>>,\n     pub ident: Ident,\n-    def_id: DefId,\n-    pub span: Span,\n-}\n-\n-impl<'a> LegacyBinding<'a> {\n-    fn def(&self) -> Def {\n-        Def::Macro(self.def_id, MacroKind::Bang)\n-    }\n }\n \n pub struct ProcMacError {\n@@ -745,7 +740,6 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                                 name: ident.name,\n                                 b1: previous_result.0,\n                                 b2: result.0,\n-                                lexical: true,\n                             });\n                             return Ok(previous_result);\n                         }\n@@ -794,7 +788,7 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                                   mut scope: &'a Cell<LegacyScope<'a>>,\n                                   ident: Ident,\n                                   record_used: bool)\n-                                  -> Option<(&'a LegacyBinding<'a>, FromExpansion)> {\n+                                  -> Option<(&'a NameBinding<'a>, FromExpansion)> {\n         let ident = ident.modern();\n         let mut relative_depth: u32 = 0;\n         loop {\n@@ -821,7 +815,7 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                         if record_used && relative_depth > 0 {\n                             self.disallowed_shadowing.push(potential_binding);\n                         }\n-                        return Some((potential_binding, FromExpansion(relative_depth > 0)));\n+                        return Some((potential_binding.binding, FromExpansion(relative_depth > 0)));\n                     }\n                     scope = &potential_binding.parent;\n                 }\n@@ -881,18 +875,10 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                     self.suggest_macro_name(&ident.as_str(), kind, &mut err, span);\n                     err.emit();\n                 },\n-                (Some((legacy_binding, FromExpansion(from_expansion))),\n-                 Ok((binding, FromPrelude(false)))) |\n-                (Some((legacy_binding, FromExpansion(from_expansion @ true))),\n-                 Ok((binding, FromPrelude(true)))) => {\n-                    if legacy_binding.def() != binding.def_ignoring_ambiguity() {\n-                        self.report_ambiguity_error(\n-                            ident.name, span, true,\n-                            legacy_binding.def(), false, false,\n-                            from_expansion, legacy_binding.span,\n-                            binding.def(), binding.is_import(), binding.is_glob_import(),\n-                            binding.expansion != Mark::root(), binding.span,\n-                        );\n+                (Some((legacy_binding, FromExpansion(_))), Ok((binding, FromPrelude(false)))) |\n+                (Some((legacy_binding, FromExpansion(true))), Ok((binding, FromPrelude(true)))) => {\n+                    if legacy_binding.def_ignoring_ambiguity() != binding.def_ignoring_ambiguity() {\n+                        self.report_ambiguity_error(ident.name, span, legacy_binding, binding);\n                     }\n                 },\n                 // OK, non-macro-expanded legacy wins over macro prelude even if defs are different\n@@ -1013,10 +999,12 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n         if def.legacy {\n             let ident = ident.modern();\n             self.macro_names.insert(ident);\n-            *legacy_scope = LegacyScope::Binding(self.arenas.alloc_legacy_binding(LegacyBinding {\n-                parent: Cell::new(*legacy_scope), ident: ident, def_id: def_id, span: item.span,\n-            }));\n             let def = Def::Macro(def_id, MacroKind::Bang);\n+            let vis = ty::Visibility::Invisible; // Doesn't matter for legacy bindings\n+            let binding = (def, vis, item.span, expansion).to_name_binding(self.arenas);\n+            *legacy_scope = LegacyScope::Binding(self.arenas.alloc_legacy_binding(\n+                LegacyBinding { parent: Cell::new(*legacy_scope), binding, ident }\n+            ));\n             self.all_macros.insert(ident.name, def);\n             if attr::contains_name(&item.attrs, \"macro_export\") {\n                 let module = self.graph_root;"}, {"sha": "9d2e51069c7b7d91957f97241441b2a3838b6e8d", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4e5e0454598b3b81525274b39ea9f57d5f988435/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e5e0454598b3b81525274b39ea9f57d5f988435/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=4e5e0454598b3b81525274b39ea9f57d5f988435", "patch": "@@ -251,7 +251,6 @@ impl<'a, 'crateloader> Resolver<'a, 'crateloader> {\n                         self.ambiguity_errors.push(AmbiguityError {\n                             span: path_span,\n                             name,\n-                            lexical: false,\n                             b1: binding,\n                             b2: shadowed_glob,\n                         });"}]}