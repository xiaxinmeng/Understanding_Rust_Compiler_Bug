{"sha": "34c5a09ce3c18874de7150afbf689ce0f94c7c20", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM0YzVhMDljZTNjMTg4NzRkZTcxNTBhZmJmNjg5Y2UwZjk0YzdjMjA=", "commit": {"author": {"name": "Daniel Micay", "email": "danielmicay@gmail.com", "date": "2013-03-16T19:49:12Z"}, "committer": {"name": "Daniel Micay", "email": "danielmicay@gmail.com", "date": "2013-03-27T02:44:40Z"}, "message": "option: rm functions that duplicate methods", "tree": {"sha": "18f0b794a9fff5b530003e5d37bd2f1124b31b7d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/18f0b794a9fff5b530003e5d37bd2f1124b31b7d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/34c5a09ce3c18874de7150afbf689ce0f94c7c20", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/34c5a09ce3c18874de7150afbf689ce0f94c7c20", "html_url": "https://github.com/rust-lang/rust/commit/34c5a09ce3c18874de7150afbf689ce0f94c7c20", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/34c5a09ce3c18874de7150afbf689ce0f94c7c20/comments", "author": {"login": "thestinger", "id": 1505226, "node_id": "MDQ6VXNlcjE1MDUyMjY=", "avatar_url": "https://avatars.githubusercontent.com/u/1505226?v=4", "gravatar_id": "", "url": "https://api.github.com/users/thestinger", "html_url": "https://github.com/thestinger", "followers_url": "https://api.github.com/users/thestinger/followers", "following_url": "https://api.github.com/users/thestinger/following{/other_user}", "gists_url": "https://api.github.com/users/thestinger/gists{/gist_id}", "starred_url": "https://api.github.com/users/thestinger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/thestinger/subscriptions", "organizations_url": "https://api.github.com/users/thestinger/orgs", "repos_url": "https://api.github.com/users/thestinger/repos", "events_url": "https://api.github.com/users/thestinger/events{/privacy}", "received_events_url": "https://api.github.com/users/thestinger/received_events", "type": "User", "site_admin": false}, "committer": {"login": "thestinger", "id": 1505226, "node_id": "MDQ6VXNlcjE1MDUyMjY=", "avatar_url": "https://avatars.githubusercontent.com/u/1505226?v=4", "gravatar_id": "", "url": "https://api.github.com/users/thestinger", "html_url": "https://github.com/thestinger", "followers_url": "https://api.github.com/users/thestinger/followers", "following_url": "https://api.github.com/users/thestinger/following{/other_user}", "gists_url": "https://api.github.com/users/thestinger/gists{/gist_id}", "starred_url": "https://api.github.com/users/thestinger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/thestinger/subscriptions", "organizations_url": "https://api.github.com/users/thestinger/orgs", "repos_url": "https://api.github.com/users/thestinger/repos", "events_url": "https://api.github.com/users/thestinger/events{/privacy}", "received_events_url": "https://api.github.com/users/thestinger/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5011d05db25fd3dfc0a9dc41fd914633ffb85469", "url": "https://api.github.com/repos/rust-lang/rust/commits/5011d05db25fd3dfc0a9dc41fd914633ffb85469", "html_url": "https://github.com/rust-lang/rust/commit/5011d05db25fd3dfc0a9dc41fd914633ffb85469"}], "stats": {"total": 593, "additions": 210, "deletions": 383}, "files": [{"sha": "738045705a2b5ee56b080515b4fafa5d1144d8c0", "filename": "src/compiletest/compiletest.rc", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/34c5a09ce3c18874de7150afbf689ce0f94c7c20/src%2Fcompiletest%2Fcompiletest.rc", "raw_url": "https://github.com/rust-lang/rust/raw/34c5a09ce3c18874de7150afbf689ce0f94c7c20/src%2Fcompiletest%2Fcompiletest.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcompiletest.rc?ref=34c5a09ce3c18874de7150afbf689ce0f94c7c20", "patch": "@@ -90,9 +90,7 @@ pub fn parse_config(args: ~[~str]) -> config {\n              if vec::len(matches.free) > 0u {\n                  option::Some(matches.free[0])\n              } else { option::None },\n-        logfile: option::map(&getopts::opt_maybe_str(matches,\n-                                                     ~\"logfile\"),\n-                             |s| Path(*s)),\n+        logfile: getopts::opt_maybe_str(matches, ~\"logfile\").map(|s| Path(*s)),\n         runtool: getopts::opt_maybe_str(matches, ~\"runtool\"),\n         rustcflags: getopts::opt_maybe_str(matches, ~\"rustcflags\"),\n         jit: getopts::opt_present(matches, ~\"jit\"),"}, {"sha": "72beb4e017dfceb43ff57dd3fbac3b03d112e0e4", "filename": "src/libcore/cell.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/34c5a09ce3c18874de7150afbf689ce0f94c7c20/src%2Flibcore%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34c5a09ce3c18874de7150afbf689ce0f94c7c20/src%2Flibcore%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcell.rs?ref=34c5a09ce3c18874de7150afbf689ce0f94c7c20", "patch": "@@ -11,7 +11,6 @@\n //! A mutable, nullable memory location\n \n use cast::transmute;\n-use option;\n use prelude::*;\n \n /*\n@@ -53,7 +52,7 @@ pub impl<T> Cell<T> {\n \n         let mut value = None;\n         value <-> self.value;\n-        return option::unwrap(value);\n+        value.unwrap()\n     }\n \n     /// Returns the value, failing if the cell is full."}, {"sha": "a852b0fb7208a888e42666e5439a18a2e60dbd10", "filename": "src/libcore/comm.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/34c5a09ce3c18874de7150afbf689ce0f94c7c20/src%2Flibcore%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34c5a09ce3c18874de7150afbf689ce0f94c7c20/src%2Flibcore%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcomm.rs?ref=34c5a09ce3c18874de7150afbf689ce0f94c7c20", "patch": "@@ -15,8 +15,7 @@ Message passing\n use cast;\n use either::{Either, Left, Right};\n use kinds::Owned;\n-use option;\n-use option::{Option, Some, None, unwrap};\n+use option::{Option, Some, None};\n use uint;\n use unstable;\n use vec;\n@@ -126,7 +125,7 @@ fn chan_send<T:Owned>(self: &Chan<T>, x: T) {\n     let mut endp = None;\n     endp <-> self.endp;\n     self.endp = Some(\n-        streamp::client::data(unwrap(endp), x))\n+        streamp::client::data(endp.unwrap(), x))\n }\n \n impl<T: Owned> GenericSmartChan<T> for Chan<T> {\n@@ -139,7 +138,7 @@ impl<T: Owned> GenericSmartChan<T> for Chan<T> {\n fn chan_try_send<T:Owned>(self: &Chan<T>, x: T) -> bool {\n     let mut endp = None;\n     endp <-> self.endp;\n-    match streamp::client::try_data(unwrap(endp), x) {\n+    match streamp::client::try_data(endp.unwrap(), x) {\n         Some(next) => {\n             self.endp = Some(next);\n             true\n@@ -165,7 +164,7 @@ impl<T: Owned> GenericPort<T> for Port<T> {\n fn port_recv<T:Owned>(self: &Port<T>) -> T {\n     let mut endp = None;\n     endp <-> self.endp;\n-    let streamp::data(x, endp) = recv(unwrap(endp));\n+    let streamp::data(x, endp) = recv(endp.unwrap());\n     self.endp = Some(endp);\n     x\n }\n@@ -174,7 +173,7 @@ fn port_recv<T:Owned>(self: &Port<T>) -> T {\n fn port_try_recv<T:Owned>(self: &Port<T>) -> Option<T> {\n     let mut endp = None;\n     endp <-> self.endp;\n-    match try_recv(unwrap(endp)) {\n+    match try_recv(endp.unwrap()) {\n         Some(streamp::data(x, endp)) => {\n             self.endp = Some(endp);\n             Some(x)\n@@ -312,7 +311,7 @@ fn shared_chan_send<T:Owned>(self: &SharedChan<T>, x: T) {\n     do self.with_imm |chan| {\n         let mut x = None;\n         x <-> xx;\n-        chan.send(option::unwrap(x))\n+        chan.send(x.unwrap())\n     }\n }\n \n@@ -326,7 +325,7 @@ fn shared_chan_try_send<T:Owned>(self: &SharedChan<T>, x: T) -> bool {\n     do self.with_imm |chan| {\n         let mut x = None;\n         x <-> xx;\n-        chan.try_send(option::unwrap(x))\n+        chan.try_send(x.unwrap())\n     }\n }\n \n@@ -409,7 +408,7 @@ pub fn try_recv_one<T: Owned> (port: PortOne<T>) -> Option<T> {\n \n     if message.is_none() { None }\n     else {\n-        let oneshot::send(message) = option::unwrap(message);\n+        let oneshot::send(message) = message.unwrap();\n         Some(message)\n     }\n }"}, {"sha": "159a79129ee4c60f05f602d052fc5efb69a6cda2", "filename": "src/libcore/dlist.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/34c5a09ce3c18874de7150afbf689ce0f94c7c20/src%2Flibcore%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34c5a09ce3c18874de7150afbf689ce0f94c7c20/src%2Flibcore%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fdlist.rs?ref=34c5a09ce3c18874de7150afbf689ce0f94c7c20", "patch": "@@ -23,7 +23,6 @@ use iter::BaseIter;\n use kinds::Copy;\n use managed;\n use option::{None, Option, Some};\n-use option;\n use vec;\n \n pub type DListLink<T> = Option<@mut DListNode<T>>;\n@@ -377,7 +376,7 @@ pub impl<T> DList<T> {\n \n     /// Reverse the list's elements in place. O(n).\n     fn reverse(@mut self) {\n-        do option::while_some(self.hd) |nobe| {\n+        do self.hd.while_some |nobe| {\n             let next_nobe = nobe.next;\n             self.remove(nobe);\n             self.make_mine(nobe);\n@@ -509,8 +508,8 @@ impl<T> BaseIter<T> for @mut DList<T> {\n     */\n     fn each(&self, f: &fn(v: &T) -> bool) {\n         let mut link = self.peek_n();\n-        while option::is_some(&link) {\n-            let nobe = option::get(link);\n+        while link.is_some() {\n+            let nobe = link.get();\n             fail_unless!(nobe.linked);\n \n             {"}, {"sha": "59c836eba653fdfbd53e7b41f20071c24d3b329e", "filename": "src/libcore/option.rs", "status": "modified", "additions": 104, "deletions": 243, "changes": 347, "blob_url": "https://github.com/rust-lang/rust/blob/34c5a09ce3c18874de7150afbf689ce0f94c7c20/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34c5a09ce3c18874de7150afbf689ce0f94c7c20/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=34c5a09ce3c18874de7150afbf689ce0f94c7c20", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -98,218 +98,6 @@ impl<T: Copy + Add<T,T>> Add<Option<T>, Option<T>> for Option<T> {\n     }\n }\n \n-#[inline(always)]\n-pub fn get<T:Copy>(opt: Option<T>) -> T {\n-    /*!\n-    Gets the value out of an option\n-\n-    # Failure\n-\n-    Fails if the value equals `None`\n-\n-    # Safety note\n-\n-    In general, because this function may fail, its use is discouraged\n-    (calling `get` on `None` is akin to dereferencing a null pointer).\n-    Instead, prefer to use pattern matching and handle the `None`\n-    case explicitly.\n-    */\n-\n-    match opt {\n-      Some(copy x) => return x,\n-      None => fail!(~\"option::get none\")\n-    }\n-}\n-\n-#[inline(always)]\n-pub fn get_ref<T>(opt: &'r Option<T>) -> &'r T {\n-    /*!\n-    Gets an immutable reference to the value inside an option.\n-\n-    # Failure\n-\n-    Fails if the value equals `None`\n-\n-    # Safety note\n-\n-    In general, because this function may fail, its use is discouraged\n-    (calling `get` on `None` is akin to dereferencing a null pointer).\n-    Instead, prefer to use pattern matching and handle the `None`\n-    case explicitly.\n-     */\n-    match *opt {\n-        Some(ref x) => x,\n-        None => fail!(~\"option::get_ref none\")\n-    }\n-}\n-\n-pub fn get_mut_ref<T>(opt: &'r mut Option<T>) -> &'r mut T {\n-    /*!\n-    Gets a mutable reference to the value inside an option.\n-\n-    # Failure\n-\n-    Fails if the value equals `None`\n-\n-    # Safety note\n-\n-    In general, because this function may fail, its use is discouraged\n-    (calling `get` on `None` is akin to dereferencing a null pointer).\n-    Instead, prefer to use pattern matching and handle the `None`\n-    case explicitly.\n-     */\n-    match *opt {\n-        Some(ref mut x) => x,\n-        None => fail!(~\"option::get_mut_ref none\")\n-    }\n-}\n-\n-#[inline(always)]\n-pub fn map<T, U>(opt: &'r Option<T>, f: &fn(x: &'r T) -> U) -> Option<U> {\n-    //! Maps a `some` value by reference from one type to another\n-\n-    match *opt { Some(ref x) => Some(f(x)), None => None }\n-}\n-\n-#[inline(always)]\n-pub fn map_consume<T, U>(opt: Option<T>,\n-                              f: &fn(v: T) -> U) -> Option<U> {\n-    /*!\n-     * As `map`, but consumes the option and gives `f` ownership to avoid\n-     * copying.\n-     */\n-    match opt { None => None, Some(v) => Some(f(v)) }\n-}\n-\n-#[inline(always)]\n-pub fn chain<T, U>(opt: Option<T>,\n-                        f: &fn(t: T) -> Option<U>) -> Option<U> {\n-    /*!\n-     * Update an optional value by optionally running its content through a\n-     * function that returns an option.\n-     */\n-\n-    match opt {\n-        Some(t) => f(t),\n-        None => None\n-    }\n-}\n-\n-#[inline(always)]\n-pub fn chain_ref<T, U>(opt: &Option<T>,\n-                            f: &fn(x: &T) -> Option<U>) -> Option<U> {\n-    /*!\n-     * Update an optional value by optionally running its content by reference\n-     * through a function that returns an option.\n-     */\n-\n-    match *opt { Some(ref x) => f(x), None => None }\n-}\n-\n-#[inline(always)]\n-pub fn or<T>(opta: Option<T>, optb: Option<T>) -> Option<T> {\n-    /*!\n-     * Returns the leftmost Some() value, or None if both are None.\n-     */\n-    match opta {\n-        Some(opta) => Some(opta),\n-        _ => optb\n-    }\n-}\n-\n-#[inline(always)]\n-pub fn while_some<T>(x: Option<T>, blk: &fn(v: T) -> Option<T>) {\n-    //! Applies a function zero or more times until the result is none.\n-\n-    let mut opt = x;\n-    while opt.is_some() {\n-        opt = blk(unwrap(opt));\n-    }\n-}\n-\n-#[inline(always)]\n-pub fn is_none<T>(opt: &const Option<T>) -> bool {\n-    //! Returns true if the option equals `none`\n-\n-    match *opt { None => true, Some(_) => false }\n-}\n-\n-#[inline(always)]\n-pub fn is_some<T>(opt: &const Option<T>) -> bool {\n-    //! Returns true if the option contains some value\n-\n-    !is_none(opt)\n-}\n-\n-#[inline(always)]\n-pub fn get_or_zero<T:Copy + Zero>(opt: Option<T>) -> T {\n-    //! Returns the contained value or zero (for this type)\n-\n-    match opt { Some(copy x) => x, None => Zero::zero() }\n-}\n-\n-#[inline(always)]\n-pub fn get_or_default<T:Copy>(opt: Option<T>, def: T) -> T {\n-    //! Returns the contained value or a default\n-\n-    match opt { Some(copy x) => x, None => def }\n-}\n-\n-#[inline(always)]\n-pub fn map_default<T, U>(opt: &'r Option<T>, def: U,\n-                              f: &fn(&'r T) -> U) -> U {\n-    //! Applies a function to the contained value or returns a default\n-\n-    match *opt { None => def, Some(ref t) => f(t) }\n-}\n-\n-#[inline(always)]\n-pub fn unwrap<T>(opt: Option<T>) -> T {\n-    /*!\n-    Moves a value out of an option type and returns it.\n-\n-    Useful primarily for getting strings, vectors and unique pointers out\n-    of option types without copying them.\n-\n-    # Failure\n-\n-    Fails if the value equals `None`.\n-\n-    # Safety note\n-\n-    In general, because this function may fail, its use is discouraged.\n-    Instead, prefer to use pattern matching and handle the `None`\n-    case explicitly.\n-     */\n-    match opt {\n-        Some(x) => x,\n-        None => fail!(~\"option::unwrap none\")\n-    }\n-}\n-\n-#[inline(always)]\n-pub fn swap_unwrap<T>(opt: &mut Option<T>) -> T {\n-    /*!\n-    The option dance. Moves a value out of an option type and returns it,\n-    replacing the original with `None`.\n-\n-    # Failure\n-\n-    Fails if the value equals `None`.\n-     */\n-    if opt.is_none() { fail!(~\"option::swap_unwrap none\") }\n-    unwrap(util::replace(opt, None))\n-}\n-\n-#[inline(always)]\n-pub fn expect<T>(opt: Option<T>, reason: &str) -> T {\n-    //! As unwrap, but with a specified failure message.\n-    match opt {\n-        Some(val) => val,\n-        None => fail!(reason.to_owned()),\n-    }\n-}\n-\n impl<T> BaseIter<T> for Option<T> {\n     /// Performs an operation on the contained value by reference\n     #[inline(always)]\n@@ -332,37 +120,64 @@ impl<T> MutableIter<T> for Option<T> {\n \n pub impl<T> Option<T> {\n     /// Returns true if the option equals `none`\n-    #[inline(always)]\n-    fn is_none(&const self) -> bool { is_none(self) }\n+    fn is_none(&const self) -> bool {\n+        match *self { None => true, Some(_) => false }\n+    }\n \n     /// Returns true if the option contains some value\n     #[inline(always)]\n-    fn is_some(&const self) -> bool { is_some(self) }\n+    fn is_some(&const self) -> bool { !self.is_none() }\n+\n+    #[inline(always)]\n+    fn chain<U>(self, f: &fn(t: T) -> Option<U>) -> Option<U> {\n+        /*!\n+         * Update an optional value by optionally running its content through a\n+         * function that returns an option.\n+         */\n+\n+        match self {\n+            Some(t) => f(t),\n+            None => None\n+        }\n+    }\n+\n+    #[inline(always)]\n+    fn or(self, optb: Option<T>) -> Option<T> {\n+        /*!\n+         * Returns the leftmost Some() value, or None if both are None.\n+         */\n+        match self {\n+            Some(opta) => Some(opta),\n+            _ => optb\n+        }\n+    }\n \n     /**\n      * Update an optional value by optionally running its content by reference\n      * through a function that returns an option.\n      */\n     #[inline(always)]\n-    fn chain_ref<U>(&self, f: &fn(x: &T) -> Option<U>) -> Option<U> {\n-        chain_ref(self, f)\n+    fn chain_ref<U>(&self, f: &fn(x: &'self T) -> Option<U>) -> Option<U> {\n+        match *self { Some(ref x) => f(x), None => None }\n     }\n \n     /// Maps a `some` value from one type to another by reference\n     #[inline(always)]\n-    fn map<U>(&self, f: &fn(&'self T) -> U) -> Option<U> { map(self, f) }\n+    fn map<U>(&self, f: &fn(&'self T) -> U) -> Option<U> {\n+        match *self { Some(ref x) => Some(f(x)), None => None }\n+    }\n \n     /// As `map`, but consumes the option and gives `f` ownership to avoid\n     /// copying.\n     #[inline(always)]\n     fn map_consume<U>(self, f: &fn(v: T) -> U) -> Option<U> {\n-        map_consume(self, f)\n+        match self { None => None, Some(v) => Some(f(v)) }\n     }\n \n     /// Applies a function to the contained value or returns a default\n     #[inline(always)]\n     fn map_default<U>(&self, def: U, f: &fn(&'self T) -> U) -> U {\n-        map_default(self, def, f)\n+        match *self { None => def, Some(ref t) => f(t) }\n     }\n \n     /// As `map_default`, but consumes the option and gives `f`\n@@ -403,7 +218,12 @@ pub impl<T> Option<T> {\n     case explicitly.\n      */\n     #[inline(always)]\n-    fn get_ref(&self) -> &'self T { get_ref(self) }\n+    fn get_ref(&self) -> &'self T {\n+        match *self {\n+          Some(ref x) => x,\n+          None => fail!(~\"option::get_ref none\")\n+        }\n+    }\n \n     /**\n     Gets a mutable reference to the value inside an option.\n@@ -420,17 +240,36 @@ pub impl<T> Option<T> {\n     case explicitly.\n      */\n     #[inline(always)]\n-    fn get_mut_ref(&mut self) -> &'self mut T { get_mut_ref(self) }\n+    fn get_mut_ref(&mut self) -> &'self mut T {\n+        match *self {\n+          Some(ref mut x) => x,\n+          None => fail!(~\"option::get_mut_ref none\")\n+        }\n+    }\n \n-    /**\n-     * Gets the value out of an option without copying.\n-     *\n-     * # Failure\n-     *\n-     * Fails if the value equals `none`\n-     */\n     #[inline(always)]\n-    fn unwrap(self) -> T { unwrap(self) }\n+    fn unwrap(self) -> T {\n+        /*!\n+        Moves a value out of an option type and returns it.\n+\n+        Useful primarily for getting strings, vectors and unique pointers out\n+        of option types without copying them.\n+\n+        # Failure\n+\n+        Fails if the value equals `None`.\n+\n+        # Safety note\n+\n+        In general, because this function may fail, its use is discouraged.\n+        Instead, prefer to use pattern matching and handle the `None`\n+        case explicitly.\n+         */\n+        match self {\n+          Some(x) => x,\n+          None => fail!(~\"option::unwrap none\")\n+        }\n+    }\n \n     /**\n      * The option dance. Moves a value out of an option type and returns it,\n@@ -441,7 +280,10 @@ pub impl<T> Option<T> {\n      * Fails if the value equals `None`.\n      */\n     #[inline(always)]\n-    fn swap_unwrap(&mut self) -> T { swap_unwrap(self) }\n+    fn swap_unwrap(&mut self) -> T {\n+        if self.is_none() { fail!(~\"option::swap_unwrap none\") }\n+        util::replace(self, None).unwrap()\n+    }\n \n     /**\n      * Gets the value out of an option, printing a specified message on\n@@ -452,7 +294,12 @@ pub impl<T> Option<T> {\n      * Fails if the value equals `none`\n      */\n     #[inline(always)]\n-    fn expect(self, reason: &str) -> T { expect(self, reason) }\n+    fn expect(self, reason: &str) -> T {\n+        match self {\n+          Some(val) => val,\n+          None => fail!(reason.to_owned()),\n+        }\n+    }\n }\n \n pub impl<T:Copy> Option<T> {\n@@ -471,29 +318,43 @@ pub impl<T:Copy> Option<T> {\n     case explicitly.\n     */\n     #[inline(always)]\n-    fn get(self) -> T { get(self) }\n+    fn get(self) -> T {\n+        match self {\n+          Some(copy x) => return x,\n+          None => fail!(~\"option::get none\")\n+        }\n+    }\n \n+    /// Returns the contained value or a default\n     #[inline(always)]\n-    fn get_or_default(self, def: T) -> T { get_or_default(self, def) }\n+    fn get_or_default(self, def: T) -> T {\n+        match self { Some(copy x) => x, None => def }\n+    }\n \n     /// Applies a function zero or more times until the result is none.\n     #[inline(always)]\n     fn while_some(self, blk: &fn(v: T) -> Option<T>) {\n-        while_some(self, blk)\n+        let mut opt = self;\n+        while opt.is_some() {\n+            opt = blk(opt.unwrap());\n+        }\n     }\n }\n \n pub impl<T:Copy + Zero> Option<T> {\n+    /// Returns the contained value or zero (for this type)\n     #[inline(always)]\n-    fn get_or_zero(self) -> T { get_or_zero(self) }\n+    fn get_or_zero(self) -> T {\n+        match self { Some(copy x) => x, None => Zero::zero() }\n+    }\n }\n \n #[test]\n fn test_unwrap_ptr() {\n     let x = ~0;\n     let addr_x = ptr::addr_of(&(*x));\n     let opt = Some(x);\n-    let y = unwrap(opt);\n+    let y = opt.unwrap();\n     let addr_y = ptr::addr_of(&(*y));\n     fail_unless!(addr_x == addr_y);\n }\n@@ -503,7 +364,7 @@ fn test_unwrap_str() {\n     let x = ~\"test\";\n     let addr_x = str::as_buf(x, |buf, _len| buf);\n     let opt = Some(x);\n-    let y = unwrap(opt);\n+    let y = opt.unwrap();\n     let addr_y = str::as_buf(y, |buf, _len| buf);\n     fail_unless!(addr_x == addr_y);\n }\n@@ -529,7 +390,7 @@ fn test_unwrap_resource() {\n     {\n         let x = R(i);\n         let opt = Some(x);\n-        let _y = unwrap(opt);\n+        let _y = opt.unwrap();\n     }\n     fail_unless!(*i == 1);\n }\n@@ -540,16 +401,16 @@ fn test_option_dance() {\n     let mut y = Some(5);\n     let mut y2 = 0;\n     for x.each |_x| {\n-        y2 = swap_unwrap(&mut y);\n+        y2 = y.swap_unwrap();\n     }\n     fail_unless!(y2 == 5);\n     fail_unless!(y.is_none());\n }\n #[test] #[should_fail] #[ignore(cfg(windows))]\n fn test_option_too_much_dance() {\n     let mut y = Some(util::NonCopyable());\n-    let _y2 = swap_unwrap(&mut y);\n-    let _y3 = swap_unwrap(&mut y);\n+    let _y2 = y.swap_unwrap();\n+    let _y3 = y.swap_unwrap();\n }\n \n #[test]"}, {"sha": "e93888f3eaf6ef3bf477f375e696e6e1616a5cb2", "filename": "src/libcore/os.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/34c5a09ce3c18874de7150afbf689ce0f94c7c20/src%2Flibcore%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34c5a09ce3c18874de7150afbf689ce0f94c7c20/src%2Flibcore%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fos.rs?ref=34c5a09ce3c18874de7150afbf689ce0f94c7c20", "patch": "@@ -517,7 +517,7 @@ pub fn homedir() -> Option<Path> {\n \n     #[cfg(windows)]\n     fn secondary() -> Option<Path> {\n-        do option::chain(getenv(~\"USERPROFILE\")) |p| {\n+        do getenv(~\"USERPROFILE\").chain |p| {\n             if !str::is_empty(p) {\n                 Some(Path(p))\n             } else {\n@@ -555,19 +555,16 @@ pub fn tmpdir() -> Path {\n     #[cfg(unix)]\n     #[allow(non_implicitly_copyable_typarams)]\n     fn lookup() -> Path {\n-        option::get_or_default(getenv_nonempty(\"TMPDIR\"),\n-                            Path(\"/tmp\"))\n+        getenv_nonempty(\"TMPDIR\").get_or_default(Path(\"/tmp\"))\n     }\n \n     #[cfg(windows)]\n     #[allow(non_implicitly_copyable_typarams)]\n     fn lookup() -> Path {\n-        option::get_or_default(\n-                    option::or(getenv_nonempty(\"TMP\"),\n-                    option::or(getenv_nonempty(\"TEMP\"),\n-                    option::or(getenv_nonempty(\"USERPROFILE\"),\n-                               getenv_nonempty(\"WINDIR\")))),\n-                    Path(\"C:\\\\Windows\"))\n+        getenv_nonempty(\"TMP\").or(\n+            getenv_nonempty(\"TEMP\").or(\n+                getenv_nonempty(\"USERPROFILE\").or(\n+                   getenv_nonempty(\"WINDIR\")))).get_or_default(Path(\"C:\\\\Windows\"))\n     }\n }\n /// Recursively walk a directory structure"}, {"sha": "ae01a3d57f34741363a425a272134c90a6ee9bcc", "filename": "src/libcore/pipes.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/34c5a09ce3c18874de7150afbf689ce0f94c7c20/src%2Flibcore%2Fpipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34c5a09ce3c18874de7150afbf689ce0f94c7c20/src%2Flibcore%2Fpipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpipes.rs?ref=34c5a09ce3c18874de7150afbf689ce0f94c7c20", "patch": "@@ -87,8 +87,7 @@ use cell::Cell;\n use either::{Either, Left, Right};\n use kinds::Owned;\n use libc;\n-use option;\n-use option::{None, Option, Some, unwrap};\n+use option::{None, Option, Some};\n use unstable::intrinsics;\n use ptr;\n use task;\n@@ -465,7 +464,7 @@ pub fn try_recv<T:Owned,Tbuffer:Owned>(p: RecvPacketBuffered<T, Tbuffer>)\n         let mut payload = None;\n         payload <-> p.payload;\n         p.header.state = Empty;\n-        return Some(option::unwrap(payload))\n+        return Some(payload.unwrap())\n       },\n       Terminated => return None,\n       _ => {}\n@@ -523,7 +522,7 @@ pub fn try_recv<T:Owned,Tbuffer:Owned>(p: RecvPacketBuffered<T, Tbuffer>)\n                 }\n             }\n             p.header.state = Empty;\n-            return Some(option::unwrap(payload))\n+            return Some(payload.unwrap())\n           }\n           Terminated => {\n             // This assert detects when we've accidentally unsafely\n@@ -777,7 +776,7 @@ impl<T:Owned,Tbuffer:Owned> ::ops::Drop for SendPacketBuffered<T,Tbuffer> {\n         if self.p != None {\n             let mut p = None;\n             p <-> self.p;\n-            sender_terminate(option::unwrap(p))\n+            sender_terminate(p.unwrap())\n         }\n         //unsafe { error!(\"send_drop: %?\",\n         //                if self.buffer == none {\n@@ -802,7 +801,7 @@ pub impl<T,Tbuffer> SendPacketBuffered<T,Tbuffer> {\n     fn unwrap(&self) -> *Packet<T> {\n         let mut p = None;\n         p <-> self.p;\n-        option::unwrap(p)\n+        p.unwrap()\n     }\n \n     fn header(&self) -> *PacketHeader {\n@@ -821,7 +820,7 @@ pub impl<T,Tbuffer> SendPacketBuffered<T,Tbuffer> {\n         //error!(\"send reuse_buffer\");\n         let mut tmp = None;\n         tmp <-> self.buffer;\n-        option::unwrap(tmp)\n+        tmp.unwrap()\n     }\n }\n \n@@ -847,7 +846,7 @@ impl<T:Owned,Tbuffer:Owned> ::ops::Drop for RecvPacketBuffered<T,Tbuffer> {\n         if self.p != None {\n             let mut p = None;\n             p <-> self.p;\n-            receiver_terminate(option::unwrap(p))\n+            receiver_terminate(p.unwrap())\n         }\n         //unsafe { error!(\"recv_drop: %?\",\n         //                if self.buffer == none {\n@@ -860,14 +859,14 @@ pub impl<T:Owned,Tbuffer:Owned> RecvPacketBuffered<T, Tbuffer> {\n     fn unwrap(&self) -> *Packet<T> {\n         let mut p = None;\n         p <-> self.p;\n-        option::unwrap(p)\n+        p.unwrap()\n     }\n \n     fn reuse_buffer(&self) -> BufferResource<Tbuffer> {\n         //error!(\"recv reuse_buffer\");\n         let mut tmp = None;\n         tmp <-> self.buffer;\n-        option::unwrap(tmp)\n+        tmp.unwrap()\n     }\n }\n "}, {"sha": "a4fd18ec09430e322f8c570428827e59daab3f2b", "filename": "src/libcore/task/local_data_priv.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/34c5a09ce3c18874de7150afbf689ce0f94c7c20/src%2Flibcore%2Ftask%2Flocal_data_priv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34c5a09ce3c18874de7150afbf689ce0f94c7c20/src%2Flibcore%2Ftask%2Flocal_data_priv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Flocal_data_priv.rs?ref=34c5a09ce3c18874de7150afbf689ce0f94c7c20", "patch": "@@ -13,7 +13,6 @@\n use cast;\n use cmp::Eq;\n use libc;\n-use option;\n use prelude::*;\n use task::rt;\n use task::local_data::LocalDataKey;\n@@ -181,6 +180,6 @@ pub unsafe fn local_modify<T:Durable>(\n     // Could be more efficient by doing the lookup work, but this is easy.\n     let newdata = modify_fn(local_pop(task, key));\n     if newdata.is_some() {\n-        local_set(task, key, option::unwrap(newdata));\n+        local_set(task, key, newdata.unwrap());\n     }\n }"}, {"sha": "3e980daaa08deb75cffc1963a3d8b6ab5dbe50e9", "filename": "src/libcore/task/mod.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/34c5a09ce3c18874de7150afbf689ce0f94c7c20/src%2Flibcore%2Ftask%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34c5a09ce3c18874de7150afbf689ce0f94c7c20/src%2Flibcore%2Ftask%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Fmod.rs?ref=34c5a09ce3c18874de7150afbf689ce0f94c7c20", "patch": "@@ -35,7 +35,6 @@\n \n use cell::Cell;\n use cmp::Eq;\n-use option;\n use result::Result;\n use comm::{stream, Chan, GenericChan, GenericPort, Port, SharedChan};\n use prelude::*;\n@@ -410,7 +409,7 @@ pub impl TaskBuilder {\n         do fr_task_builder.spawn || {\n             ch.send(f());\n         }\n-        match option::unwrap(result).recv() {\n+        match result.unwrap().recv() {\n             Success => result::Ok(po.recv()),\n             Failure => result::Err(())\n         }\n@@ -839,14 +838,14 @@ fn test_add_wrapper() {\n fn test_future_result() {\n     let mut result = None;\n     do task().future_result(|+r| { result = Some(r); }).spawn { }\n-    fail_unless!(option::unwrap(result).recv() == Success);\n+    fail_unless!(result.unwrap().recv() == Success);\n \n     result = None;\n     do task().future_result(|+r|\n         { result = Some(r); }).unlinked().spawn {\n         fail!();\n     }\n-    fail_unless!(option::unwrap(result).recv() == Failure);\n+    fail_unless!(result.unwrap().recv() == Failure);\n }\n \n #[test] #[should_fail] #[ignore(cfg(windows))]"}, {"sha": "f353db5ae7098099bfa92797fdcaf841c85af7ac", "filename": "src/libcore/task/spawn.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/34c5a09ce3c18874de7150afbf689ce0f94c7c20/src%2Flibcore%2Ftask%2Fspawn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34c5a09ce3c18874de7150afbf689ce0f94c7c20/src%2Flibcore%2Ftask%2Fspawn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Fspawn.rs?ref=34c5a09ce3c18874de7150afbf689ce0f94c7c20", "patch": "@@ -75,7 +75,6 @@\n use cast;\n use cell::Cell;\n use container::Map;\n-use option;\n use comm::{Chan, GenericChan, GenericPort, Port, stream};\n use prelude::*;\n use unstable;\n@@ -194,7 +193,7 @@ fn each_ancestor(list:        &mut AncestorList,\n         if coalesce_this.is_some() {\n             // Needed coalesce. Our next ancestor becomes our old\n             // ancestor's next ancestor. (\"next = old_next->next;\")\n-            *list = option::unwrap(coalesce_this);\n+            *list = coalesce_this.unwrap();\n         } else {\n             // No coalesce; restore from tmp. (\"next = old_next;\")\n             *list = tmp_list;\n@@ -290,7 +289,7 @@ fn each_ancestor(list:        &mut AncestorList,\n         fn with_parent_tg<U>(parent_group: &mut Option<TaskGroupArc>,\n                              blk: &fn(TaskGroupInner) -> U) -> U {\n             // If this trips, more likely the problem is 'blk' failed inside.\n-            let tmp_arc = option::swap_unwrap(&mut *parent_group);\n+            let tmp_arc = parent_group.swap_unwrap();\n             let result = do access_group(&tmp_arc) |tg_opt| { blk(tg_opt) };\n             *parent_group = Some(tmp_arc);\n             result\n@@ -374,7 +373,7 @@ fn enlist_in_taskgroup(state: TaskGroupInner, me: *rust_task,\n     let newstate = util::replace(&mut *state, None);\n     // If 'None', the group was failing. Can't enlist.\n     if newstate.is_some() {\n-        let group = option::unwrap(newstate);\n+        let group = newstate.unwrap();\n         taskset_insert(if is_member { &mut group.members }\n                        else         { &mut group.descendants }, me);\n         *state = Some(group);\n@@ -390,7 +389,7 @@ fn leave_taskgroup(state: TaskGroupInner, me: *rust_task,\n     let newstate = util::replace(&mut *state, None);\n     // If 'None', already failing and we've already gotten a kill signal.\n     if newstate.is_some() {\n-        let group = option::unwrap(newstate);\n+        let group = newstate.unwrap();\n         taskset_remove(if is_member { &mut group.members }\n                        else         { &mut group.descendants }, me);\n         *state = Some(group);\n@@ -414,7 +413,7 @@ fn kill_taskgroup(state: TaskGroupInner, me: *rust_task, is_main: bool) {\n         // That's ok; only one task needs to do the dirty work. (Might also\n         // see 'None' if Somebody already failed and we got a kill signal.)\n         if newstate.is_some() {\n-            let group = option::unwrap(newstate);\n+            let group = newstate.unwrap();\n             for taskset_each(&group.members) |sibling| {\n                 // Skip self - killing ourself won't do much good.\n                 if sibling != me {\n@@ -519,7 +518,7 @@ fn gen_child_taskgroup(linked: bool, supervised: bool)\n         //    None               { ancestor_list(None) }\n         let tmp = util::replace(&mut **ancestors, None);\n         if tmp.is_some() {\n-            let ancestor_arc = option::unwrap(tmp);\n+            let ancestor_arc = tmp.unwrap();\n             let result = ancestor_arc.clone();\n             **ancestors = Some(ancestor_arc);\n             AncestorList(Some(result))\n@@ -549,7 +548,7 @@ pub fn spawn_raw(opts: TaskOpts, f: ~fn()) {\n             let mut notify_chan = if opts.notify_chan.is_none() {\n                 None\n             } else {\n-                Some(option::swap_unwrap(&mut opts.notify_chan))\n+                Some(opts.notify_chan.swap_unwrap())\n             };\n \n             let child_wrapper = make_child_wrapper(new_task, child_tg,"}, {"sha": "5daccd9f879f4954c37c41fe893d90797e117a68", "filename": "src/libcore/unstable.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/34c5a09ce3c18874de7150afbf689ce0f94c7c20/src%2Flibcore%2Funstable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34c5a09ce3c18874de7150afbf689ce0f94c7c20/src%2Flibcore%2Funstable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funstable.rs?ref=34c5a09ce3c18874de7150afbf689ce0f94c7c20", "patch": "@@ -12,7 +12,6 @@\n \n use cast;\n use libc;\n-use option;\n use comm::{GenericChan, GenericPort};\n use prelude::*;\n use task;\n@@ -165,7 +164,7 @@ pub unsafe fn get_shared_mutable_state<T:Owned>(\n     unsafe {\n         let ptr: ~ArcData<T> = cast::reinterpret_cast(&(*rc).data);\n         fail_unless!(ptr.count > 0);\n-        let r = cast::transmute(option::get_ref(&ptr.data));\n+        let r = cast::transmute(ptr.data.get_ref());\n         cast::forget(ptr);\n         return r;\n     }\n@@ -177,7 +176,7 @@ pub unsafe fn get_shared_immutable_state<T:Owned>(\n         let ptr: ~ArcData<T> = cast::reinterpret_cast(&(*rc).data);\n         fail_unless!(ptr.count > 0);\n         // Cast us back into the correct region\n-        let r = cast::transmute_region(option::get_ref(&ptr.data));\n+        let r = cast::transmute_region(ptr.data.get_ref());\n         cast::forget(ptr);\n         return r;\n     }"}, {"sha": "1947f294cb3d36fa8368bc4307a0db925abab564", "filename": "src/libcore/unstable/weak_task.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/34c5a09ce3c18874de7150afbf689ce0f94c7c20/src%2Flibcore%2Funstable%2Fweak_task.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34c5a09ce3c18874de7150afbf689ce0f94c7c20/src%2Flibcore%2Funstable%2Fweak_task.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funstable%2Fweak_task.rs?ref=34c5a09ce3c18874de7150afbf689ce0f94c7c20", "patch": "@@ -22,7 +22,7 @@ use cell::Cell;\n use comm::{GenericSmartChan, stream};\n use comm::{Port, Chan, SharedChan, GenericChan, GenericPort};\n use hashmap::linear::LinearMap;\n-use option::{Some, None, swap_unwrap};\n+use option::{Some, None};\n use unstable::at_exit::at_exit;\n use unstable::finally::Finally;\n use unstable::global::global_data_clone_create;"}, {"sha": "cb9e4a4d7b8f6c91f209ddc8d65465c0f5e43972", "filename": "src/libfuzzer/fuzzer.rc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/34c5a09ce3c18874de7150afbf689ce0f94c7c20/src%2Flibfuzzer%2Ffuzzer.rc", "raw_url": "https://github.com/rust-lang/rust/raw/34c5a09ce3c18874de7150afbf689ce0f94c7c20/src%2Flibfuzzer%2Ffuzzer.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibfuzzer%2Ffuzzer.rc?ref=34c5a09ce3c18874de7150afbf689ce0f94c7c20", "patch": "@@ -334,8 +334,8 @@ pub fn check_variants_T<T: Copy>(\n }\n \n pub fn last_part(filename: ~str) -> ~str {\n-  let ix = option::get(str::rfind_char(filename, '/'));\n-  str::slice(filename, ix + 1u, str::len(filename) - 3u).to_owned()\n+    let ix = str::rfind_char(filename, '/').get();\n+    str::slice(filename, ix + 1u, str::len(filename) - 3u).to_owned()\n }\n \n pub enum happiness {"}, {"sha": "2cec6ec5ab1218734ba8a7848cf65cca46bda55f", "filename": "src/librustc/front/config.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/34c5a09ce3c18874de7150afbf689ce0f94c7c20/src%2Flibrustc%2Ffront%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34c5a09ce3c18874de7150afbf689ce0f94c7c20/src%2Flibrustc%2Ffront%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fconfig.rs?ref=34c5a09ce3c18874de7150afbf689ce0f94c7c20", "patch": "@@ -142,7 +142,7 @@ fn fold_block(\n     ast::blk_ {\n         view_items: /*bad*/copy b.view_items,\n         stmts: vec::map(filtered_stmts, |x| fld.fold_stmt(*x)),\n-        expr: option::map(&b.expr, |x| fld.fold_expr(*x)),\n+        expr: b.expr.map(|x| fld.fold_expr(*x)),\n         id: b.id,\n         rules: b.rules,\n     }"}, {"sha": "5f74dcb27ac603d60e4a5a79075db23538982f8b", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/34c5a09ce3c18874de7150afbf689ce0f94c7c20/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34c5a09ce3c18874de7150afbf689ce0f94c7c20/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=34c5a09ce3c18874de7150afbf689ce0f94c7c20", "patch": "@@ -207,8 +207,7 @@ fn each_reexport(d: ebml::Doc, f: &fn(ebml::Doc) -> bool) {\n \n fn field_mutability(d: ebml::Doc) -> ast::struct_mutability {\n     // Use maybe_get_doc in case it's a method\n-    option::map_default(\n-        &reader::maybe_get_doc(d, tag_struct_mut),\n+    reader::maybe_get_doc(d, tag_struct_mut).map_default(\n         ast::struct_immutable,\n         |d| {\n             match reader::doc_as_u8(*d) as char {\n@@ -219,7 +218,7 @@ fn field_mutability(d: ebml::Doc) -> ast::struct_mutability {\n }\n \n fn variant_disr_val(d: ebml::Doc) -> Option<int> {\n-    do option::chain(reader::maybe_get_doc(d, tag_disr_val)) |val_doc| {\n+    do reader::maybe_get_doc(d, tag_disr_val).chain |val_doc| {\n         int::parse_bytes(reader::doc_data(val_doc), 10u)\n     }\n }"}, {"sha": "bd507f4cf22891250f35d6b9650a5aaed3d52c09", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/34c5a09ce3c18874de7150afbf689ce0f94c7c20/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34c5a09ce3c18874de7150afbf689ce0f94c7c20/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=34c5a09ce3c18874de7150afbf689ce0f94c7c20", "patch": "@@ -75,7 +75,6 @@ use syntax::visit::{visit_foreign_item, visit_item, visit_method_helper};\n use syntax::visit::{visit_mod, visit_ty, vt};\n use syntax::opt_vec::OptVec;\n \n-use core::option::{Some, get, is_some, is_none};\n use core::str::{connect, each_split_str};\n use core::hashmap::linear::{LinearMap, LinearSet};\n \n@@ -2490,7 +2489,7 @@ pub impl Resolver {\n \n             debug!(\"(resolving glob import) writing module resolution \\\n                     %? into `%s`\",\n-                   is_none(&mut target_import_resolution.type_target),\n+                   target_import_resolution.type_target.is_none(),\n                    self.module_to_str(module_));\n \n             // Here we merge two import resolutions.\n@@ -5163,7 +5162,7 @@ pub impl Resolver {\n             if this.main_fns.len() >= 1u {\n                 let mut i = 1u;\n                 while i < this.main_fns.len() {\n-                    let (_, dup_main_span) = option::unwrap(this.main_fns[i]);\n+                    let (_, dup_main_span) = this.main_fns[i].unwrap();\n                     this.session.span_err(\n                         dup_main_span,\n                         ~\"multiple 'main' functions\");"}, {"sha": "e8c6cf78a187ab149e904e420e5719b3f4cd037b", "filename": "src/librustc/middle/trans/monomorphize.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/34c5a09ce3c18874de7150afbf689ce0f94c7c20/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34c5a09ce3c18874de7150afbf689ce0f94c7c20/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs?ref=34c5a09ce3c18874de7150afbf689ce0f94c7c20", "patch": "@@ -32,7 +32,6 @@ use middle::ty::{FnSig};\n use middle::typeck;\n use util::ppaux::ty_to_str;\n \n-use core::option;\n use core::vec;\n use syntax::ast;\n use syntax::ast_map;\n@@ -194,8 +193,7 @@ pub fn monomorphic_fn(ccx: @CrateContext,\n       }\n       ast_map::node_variant(ref v, enum_item, _) => {\n         let tvs = ty::enum_variants(ccx.tcx, local_def(enum_item.id));\n-        let this_tv = option::get(vec::find(*tvs, |tv| {\n-            tv.id.node == fn_id.node}));\n+        let this_tv = vec::find(*tvs, |tv| { tv.id.node == fn_id.node}).get();\n         let d = mk_lldecl();\n         set_inline_hint(d);\n         match (*v).node.kind {\n@@ -248,9 +246,8 @@ pub fn monomorphic_fn(ccx: @CrateContext,\n         set_inline_hint(d);\n         base::trans_tuple_struct(ccx,\n                                  /*bad*/copy struct_def.fields,\n-                                 option::expect(struct_def.ctor_id,\n-                                                ~\"ast-mapped tuple struct \\\n-                                                  didn't have a ctor id\"),\n+                                 struct_def.ctor_id.expect(~\"ast-mapped tuple struct \\\n+                                                             didn't have a ctor id\"),\n                                  psubsts,\n                                  d);\n         d"}, {"sha": "cad2a03f7a1ef8143c74c0329ce83013dac396a2", "filename": "src/librustc/middle/trans/type_use.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/34c5a09ce3c18874de7150afbf689ce0f94c7c20/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34c5a09ce3c18874de7150afbf689ce0f94c7c20/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs?ref=34c5a09ce3c18874de7150afbf689ce0f94c7c20", "patch": "@@ -35,7 +35,6 @@ use middle::trans::inline;\n use middle::ty;\n use middle::typeck;\n \n-use core::option;\n use core::option::{Some, None, Option};\n use core::uint;\n use core::vec;\n@@ -220,7 +219,7 @@ pub fn type_needs_inner(cx: Context,\n                 ty::ty_trait(_, _, _) => false,\n \n               ty::ty_enum(did, ref substs) => {\n-                if option::is_none(&list::find(enums_seen, |id| *id == did)) {\n+                if list::find(enums_seen, |id| *id == did).is_none() {\n                     let seen = @Cons(did, enums_seen);\n                     for vec::each(*ty::enum_variants(cx.ccx.tcx, did)) |v| {\n                         for vec::each(v.args) |aty| {"}, {"sha": "edf76ee7c36396666e756256129adde58b058e4d", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/34c5a09ce3c18874de7150afbf689ce0f94c7c20/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34c5a09ce3c18874de7150afbf689ce0f94c7c20/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=34c5a09ce3c18874de7150afbf689ce0f94c7c20", "patch": "@@ -30,7 +30,6 @@ use util::common::{indenter};\n use core::cast;\n use core::cmp;\n use core::ops;\n-use core::option;\n use core::ptr::to_unsafe_ptr;\n use core::result::Result;\n use core::result;\n@@ -3632,11 +3631,10 @@ pub fn impl_traits(cx: ctxt, id: ast::def_id, store: TraitStore) -> ~[t] {\n                         _},\n                     _)) => {\n \n-               do option::map_default(&opt_trait, ~[]) |trait_ref| {\n-                       ~[storeify(cx,\n-                                  node_id_to_type(cx, trait_ref.ref_id),\n-                                  store)]\n-                   }\n+               do opt_trait.map_default(~[]) |trait_ref| {\n+                   ~[storeify(cx, node_id_to_type(cx, trait_ref.ref_id),\n+                              store)]\n+               }\n            }\n            _ => ~[]\n         }"}, {"sha": "17a67838bbe8befdb521265174e5cf22cce1f1cd", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/34c5a09ce3c18874de7150afbf689ce0f94c7c20/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34c5a09ce3c18874de7150afbf689ce0f94c7c20/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=34c5a09ce3c18874de7150afbf689ce0f94c7c20", "patch": "@@ -113,7 +113,6 @@ use util::ppaux;\n \n use core::either;\n use core::hashmap::linear::LinearMap;\n-use core::option;\n use core::ptr;\n use core::result::{Result, Ok, Err};\n use core::result;\n@@ -319,7 +318,7 @@ pub fn check_fn(ccx: @mut CrateCtxt,\n     debug!(\"check_fn(arg_tys=%?, ret_ty=%?, self_info.self_ty=%?)\",\n            arg_tys.map(|a| ppaux::ty_to_str(tcx, *a)),\n            ppaux::ty_to_str(tcx, ret_ty),\n-           option::map(&self_info, |s| ppaux::ty_to_str(tcx, s.self_ty)));\n+           self_info.map(|s| ppaux::ty_to_str(tcx, s.self_ty)));\n \n     // ______________________________________________________________________\n     // Create the function context.  This is either derived from scratch or,"}, {"sha": "5b4d3be1264618d42c0968ef69fa1638a62b34ea", "filename": "src/librustc/rustc.rc", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/34c5a09ce3c18874de7150afbf689ce0f94c7c20/src%2Flibrustc%2Frustc.rc", "raw_url": "https://github.com/rust-lang/rust/raw/34c5a09ce3c18874de7150afbf689ce0f94c7c20/src%2Flibrustc%2Frustc.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Frustc.rc?ref=34c5a09ce3c18874de7150afbf689ce0f94c7c20", "patch": "@@ -260,10 +260,8 @@ pub fn run_compiler(args: &~[~str], demitter: diagnostic::Emitter) {\n     let ofile = getopts::opt_maybe_str(matches, ~\"o\");\n     let ofile = ofile.map(|o| Path(*o));\n     let cfg = build_configuration(sess, binary, input);\n-    let pretty =\n-        option::map(&getopts::opt_default(matches, ~\"pretty\",\n-                                         ~\"normal\"),\n-                    |a| parse_pretty(sess, *a) );\n+    let pretty = getopts::opt_default(matches, ~\"pretty\", \"normal\").map(\n+                    |a| parse_pretty(sess, *a));\n     match pretty {\n       Some::<pp_mode>(ppm) => {\n         pretty_print_input(sess, cfg, input, ppm);"}, {"sha": "101c11bd58b36595ae40daeb35090f470ac8141b", "filename": "src/librustdoc/attr_pass.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/34c5a09ce3c18874de7150afbf689ce0f94c7c20/src%2Flibrustdoc%2Fattr_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34c5a09ce3c18874de7150afbf689ce0f94c7c20/src%2Flibrustdoc%2Fattr_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fattr_pass.rs?ref=34c5a09ce3c18874de7150afbf689ce0f94c7c20", "patch": "@@ -27,7 +27,6 @@ use fold::Fold;\n use fold;\n use pass::Pass;\n \n-use core::option;\n use core::vec;\n use syntax::ast;\n use syntax::ast_map;\n@@ -71,8 +70,7 @@ fn fold_crate(\n     doc::CrateDoc {\n         topmod: doc::ModDoc {\n             item: doc::ItemDoc {\n-                name: option::get_or_default(copy attrs.name,\n-                                             doc.topmod.name()),\n+                name: (copy attrs.name).get_or_default(doc.topmod.name()),\n                 .. copy doc.topmod.item\n             },\n             .. copy doc.topmod\n@@ -166,10 +164,10 @@ fn fold_enum(\n                         ast_map::node_item(@ast::item {\n                             node: ast::item_enum(ref enum_definition, _), _\n                         }, _) => {\n-                            let ast_variant = option::get(\n+                            let ast_variant =\n                                 vec::find(enum_definition.variants, |v| {\n                                     to_str(v.node.name) == variant.name\n-                                }));\n+                                }).get();\n \n                             attr_parser::parse_desc(\n                                 copy ast_variant.node.attrs)"}, {"sha": "2d5f60e714b5082511c9697d7d534ca9498c063f", "filename": "src/librustdoc/doc.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/34c5a09ce3c18874de7150afbf689ce0f94c7c20/src%2Flibrustdoc%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34c5a09ce3c18874de7150afbf689ce0f94c7c20/src%2Flibrustdoc%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdoc.rs?ref=34c5a09ce3c18874de7150afbf689ce0f94c7c20", "patch": "@@ -14,7 +14,6 @@ use core::prelude::*;\n \n use doc;\n \n-use core::option;\n use core::vec;\n \n pub type AstId = int;\n@@ -175,12 +174,12 @@ pub struct IndexEntry {\n \n pub impl Doc {\n     fn CrateDoc(&self) -> CrateDoc {\n-        option::get(vec::foldl(None, self.pages, |_m, page| {\n+        vec::foldl(None, self.pages, |_m, page| {\n             match copy *page {\n               doc::CratePage(doc) => Some(doc),\n               _ => None\n             }\n-        }))\n+        }).get()\n     }\n \n     fn cratemod(&self) -> ModDoc {"}, {"sha": "49db98e32006fd876393832a9c30814093b24ba9", "filename": "src/librustdoc/page_pass.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/34c5a09ce3c18874de7150afbf689ce0f94c7c20/src%2Flibrustdoc%2Fpage_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34c5a09ce3c18874de7150afbf689ce0f94c7c20/src%2Flibrustdoc%2Fpage_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpage_pass.rs?ref=34c5a09ce3c18874de7150afbf689ce0f94c7c20", "patch": "@@ -26,7 +26,6 @@ use fold;\n use pass::Pass;\n use util::NominalOp;\n \n-use core::option;\n use core::comm::*;\n use syntax::ast;\n \n@@ -68,7 +67,7 @@ fn make_doc_from_pages(page_port: &PagePort) -> doc::Doc {\n     loop {\n         let val = page_port.recv();\n         if val.is_some() {\n-            pages += ~[option::unwrap(val)];\n+            pages += ~[val.unwrap()];\n         } else {\n             break;\n         }"}, {"sha": "22ba33ba04e43b5be5c22fbfbd4a6f5a92838d0d", "filename": "src/libstd/sync.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/34c5a09ce3c18874de7150afbf689ce0f94c7c20/src%2Flibstd%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34c5a09ce3c18874de7150afbf689ce0f94c7c20/src%2Flibstd%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync.rs?ref=34c5a09ce3c18874de7150afbf689ce0f94c7c20", "patch": "@@ -15,7 +15,6 @@\n  * in std.\n  */\n \n-use core::option;\n use core::prelude::*;\n use core::unstable::{Exclusive, exclusive};\n use core::ptr;\n@@ -119,7 +118,7 @@ pub impl<Q:Owned> Sem<Q> {\n         /* for 1000.times { task::yield(); } */\n         // Need to wait outside the exclusive.\n         if waiter_nobe.is_some() {\n-            let _ = comm::recv_one(option::unwrap(waiter_nobe));\n+            let _ = comm::recv_one(waiter_nobe.unwrap());\n         }\n     }\n     fn release(&self) {\n@@ -235,7 +234,7 @@ pub impl Condvar<'self> {\n                             signal_waitqueue(&state.waiters);\n                         }\n                         // Enqueue ourself to be woken up by a signaller.\n-                        let SignalEnd = option::swap_unwrap(&mut SignalEnd);\n+                        let SignalEnd = SignalEnd.swap_unwrap();\n                         state.blocked[condvar_id].tail.send(SignalEnd);\n                     } else {\n                         out_of_bounds = Some(vec::len(state.blocked));\n@@ -255,7 +254,7 @@ pub impl Condvar<'self> {\n             // Unconditionally \"block\". (Might not actually block if a\n             // signaller already sent -- I mean 'unconditionally' in contrast\n             // with acquire().)\n-            let _ = comm::recv_one(option::swap_unwrap(&mut WaitEnd));\n+            let _ = comm::recv_one(WaitEnd.swap_unwrap());\n         }\n \n         // This is needed for a failing condition variable to reacquire the\n@@ -327,7 +326,7 @@ pub impl Condvar<'self> {\n             }\n         }\n         do check_cvar_bounds(out_of_bounds, condvar_id, \"cond.signal_on()\") {\n-            let queue = option::swap_unwrap(&mut queue);\n+            let queue = queue.swap_unwrap();\n             broadcast_waitqueue(&queue)\n         }\n     }\n@@ -1352,7 +1351,7 @@ mod tests {\n         do x.write_downgrade |xwrite| {\n             let mut xopt = Some(xwrite);\n             do y.write_downgrade |_ywrite| {\n-                y.downgrade(option::swap_unwrap(&mut xopt));\n+                y.downgrade(xopt.swap_unwrap());\n                 error!(\"oops, y.downgrade(x) should have failed!\");\n             }\n         }"}, {"sha": "ded4d6fd1b4dc59611c0db09fc381a88e17ca948", "filename": "src/libstd/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/34c5a09ce3c18874de7150afbf689ce0f94c7c20/src%2Flibstd%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34c5a09ce3c18874de7150afbf689ce0f94c7c20/src%2Flibstd%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftest.rs?ref=34c5a09ce3c18874de7150afbf689ce0f94c7c20", "patch": "@@ -569,7 +569,7 @@ pub fn run_test(force_ignore: bool,\n             task::task().unlinked().future_result(|+r| {\n                 result_future = Some(r);\n             }).spawn(testfn_cell.take());\n-            let task_result = option::unwrap(result_future).recv();\n+            let task_result = result_future.unwrap().recv();\n             let test_result = calc_result(&desc,\n                                           task_result == task::Success);\n             monitor_ch.send((desc, test_result));"}, {"sha": "24360734520e3420f9f483dc892b08187ed94563", "filename": "src/libsyntax/diagnostic.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/34c5a09ce3c18874de7150afbf689ce0f94c7c20/src%2Flibsyntax%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34c5a09ce3c18874de7150afbf689ce0f94c7c20/src%2Flibsyntax%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic.rs?ref=34c5a09ce3c18874de7150afbf689ce0f94c7c20", "patch": "@@ -15,7 +15,6 @@ use codemap;\n \n use core::io::WriterUtil;\n use core::io;\n-use core::option;\n use core::str;\n use core::vec;\n \n@@ -294,8 +293,7 @@ fn highlight_lines(cm: @codemap::CodeMap,\n \n fn print_macro_backtrace(cm: @codemap::CodeMap, sp: span) {\n     for sp.expn_info.each |ei| {\n-        let ss = option::map_default(&ei.callee.span, @~\"\",\n-                                     |span| @cm.span_to_str(*span));\n+        let ss = ei.callee.span.map_default(@~\"\", |span| @cm.span_to_str(*span));\n         print_diagnostic(*ss, note,\n                          fmt!(\"in expansion of %s!\", ei.callee.name));\n         let ss = cm.span_to_str(ei.call_site);"}, {"sha": "07ed6b7dfe28d9bb3aa0d805fc8072c7de4edb4c", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/34c5a09ce3c18874de7150afbf689ce0f94c7c20/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34c5a09ce3c18874de7150afbf689ce0f94c7c20/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=34c5a09ce3c18874de7150afbf689ce0f94c7c20", "patch": "@@ -22,7 +22,6 @@ use fold::*;\n use parse;\n use parse::{parser, parse_item_from_source_str, new_parser_from_tts};\n \n-use core::option;\n use core::vec;\n \n pub fn expand_expr(extsbox: @mut SyntaxEnv,\n@@ -294,8 +293,7 @@ pub fn expand_item_mac(+extsbox: @mut SyntaxEnv,\n         MRExpr(_) => cx.span_fatal(pth.span,\n                                     ~\"expr macro in item position: \"\n                                     + *extname),\n-        MRAny(_, item_maker, _) =>\n-            option::chain(item_maker(), |i| {fld.fold_item(i)}),\n+        MRAny(_, item_maker, _) => item_maker().chain(|i| {fld.fold_item(i)}),\n         MRDef(ref mdef) => {\n             extsbox.insert(@/*bad*/ copy mdef.name, @SE((*mdef).ext));\n             None"}, {"sha": "b3974acc6741a08825cc2e856c1ebc349b0d35ab", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/34c5a09ce3c18874de7150afbf689ce0f94c7c20/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34c5a09ce3c18874de7150afbf689ce0f94c7c20/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=34c5a09ce3c18874de7150afbf689ce0f94c7c20", "patch": "@@ -15,7 +15,6 @@ use ast;\n use codemap::{span, spanned};\n use opt_vec::OptVec;\n \n-use core::option;\n use core::vec;\n \n pub trait ast_fold {\n@@ -298,7 +297,7 @@ pub fn noop_fold_item_underscore(i: &item_, fld: @ast_fold) -> item_ {\n \n fn fold_struct_def(struct_def: @ast::struct_def, fld: @ast_fold)\n                 -> @ast::struct_def {\n-    let dtor = do option::map(&struct_def.dtor) |dtor| {\n+    let dtor = do struct_def.dtor.map |dtor| {\n         let dtor_body = fld.fold_block(&dtor.node.body);\n         let dtor_id   = fld.new_id(dtor.node.id);\n         spanned {\n@@ -663,7 +662,7 @@ fn noop_fold_variant(v: &variant_, fld: @ast_fold) -> variant_ {\n             })\n         }\n         struct_variant_kind(struct_def) => {\n-            let dtor = do option::map(&struct_def.dtor) |dtor| {\n+            let dtor = do struct_def.dtor.map |dtor| {\n                 let dtor_body = fld.fold_block(&dtor.node.body);\n                 let dtor_id   = fld.new_id(dtor.node.id);\n                 spanned {\n@@ -679,7 +678,7 @@ fn noop_fold_variant(v: &variant_, fld: @ast_fold) -> variant_ {\n                 fields: vec::map(struct_def.fields,\n                                  |f| fld.fold_struct_field(*f)),\n                 dtor: dtor,\n-                ctor_id: option::map(&struct_def.ctor_id, |c| fld.new_id(*c))\n+                ctor_id: struct_def.ctor_id.map(|c| fld.new_id(*c))\n             })\n         }\n         enum_variant_kind(ref enum_definition) => {"}, {"sha": "a1ab7384d62a5bb3ba4d9c5e50de3c0b3d42d2b5", "filename": "src/test/bench/msgsend-ring-mutex-arcs.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/34c5a09ce3c18874de7150afbf689ce0f94c7c20/src%2Ftest%2Fbench%2Fmsgsend-ring-mutex-arcs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34c5a09ce3c18874de7150afbf689ce0f94c7c20/src%2Ftest%2Fbench%2Fmsgsend-ring-mutex-arcs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-ring-mutex-arcs.rs?ref=34c5a09ce3c18874de7150afbf689ce0f94c7c20", "patch": "@@ -54,8 +54,8 @@ fn thread_ring(i: uint,\n     // Send/Receive lots of messages.\n     for uint::range(0u, count) |j| {\n         //error!(\"task %?, iter %?\", i, j);\n-        let mut num_chan2 = option::swap_unwrap(&mut num_chan);\n-        let mut num_port2 = option::swap_unwrap(&mut num_port);\n+        let mut num_chan2 = num_chan.swap_unwrap();\n+        let mut num_port2 = num_port.swap_unwrap();\n         send(&num_chan2, i * j);\n         num_chan = Some(num_chan2);\n         let _n = recv(&num_port2);"}, {"sha": "1fdc826c48109fc6d90e348ac4ffd137c9329a7b", "filename": "src/test/bench/msgsend-ring-pipes.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/34c5a09ce3c18874de7150afbf689ce0f94c7c20/src%2Ftest%2Fbench%2Fmsgsend-ring-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34c5a09ce3c18874de7150afbf689ce0f94c7c20/src%2Ftest%2Fbench%2Fmsgsend-ring-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-ring-pipes.rs?ref=34c5a09ce3c18874de7150afbf689ce0f94c7c20", "patch": "@@ -46,8 +46,8 @@ fn thread_ring(i: uint,\n         let mut num_port2 = None;\n         num_chan2 <-> num_chan;\n         num_port2 <-> num_port;\n-        num_chan = Some(ring::client::num(option::unwrap(num_chan2), i * j));\n-        let port = option::unwrap(num_port2);\n+        num_chan = Some(ring::client::num(num_chan2.unwrap(), i * j));\n+        let port = num_port2.unwrap();\n         match recv(port) {\n           ring::num(_n, p) => {\n             //log(error, _n);"}, {"sha": "8e819cc4aba00f19234dfcbec436c07a6228c2e4", "filename": "src/test/bench/msgsend-ring-rw-arcs.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/34c5a09ce3c18874de7150afbf689ce0f94c7c20/src%2Ftest%2Fbench%2Fmsgsend-ring-rw-arcs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34c5a09ce3c18874de7150afbf689ce0f94c7c20/src%2Ftest%2Fbench%2Fmsgsend-ring-rw-arcs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-ring-rw-arcs.rs?ref=34c5a09ce3c18874de7150afbf689ce0f94c7c20", "patch": "@@ -55,8 +55,8 @@ fn thread_ring(i: uint,\n     // Send/Receive lots of messages.\n     for uint::range(0u, count) |j| {\n         //error!(\"task %?, iter %?\", i, j);\n-        let mut num_chan2 = option::swap_unwrap(&mut num_chan);\n-        let mut num_port2 = option::swap_unwrap(&mut num_port);\n+        let mut num_chan2 = num_chan.swap_unwrap();\n+        let mut num_port2 = num_port.swap_unwrap();\n         send(&num_chan2, i * j);\n         num_chan = Some(num_chan2);\n         let _n = recv(&num_port2);"}, {"sha": "3bc40a46cfb2c1f87d2604c214a121a1e5a917c6", "filename": "src/test/bench/shootout-k-nucleotide-pipes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/34c5a09ce3c18874de7150afbf689ce0f94c7c20/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34c5a09ce3c18874de7150afbf689ce0f94c7c20/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs?ref=34c5a09ce3c18874de7150afbf689ce0f94c7c20", "patch": "@@ -158,7 +158,7 @@ fn main() {\n         let sz = *sz;\n         let mut stream = None;\n         stream <-> streams[ii];\n-        let (from_child_, to_parent_) = option::unwrap(stream);\n+        let (from_child_, to_parent_) = stream.unwrap();\n \n         from_child.push(from_child_);\n "}, {"sha": "889a2836c0ca9178a4fb02857bcab88562e2d59e", "filename": "src/test/bench/task-perf-linked-failure.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/34c5a09ce3c18874de7150afbf689ce0f94c7c20/src%2Ftest%2Fbench%2Ftask-perf-linked-failure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34c5a09ce3c18874de7150afbf689ce0f94c7c20/src%2Ftest%2Fbench%2Ftask-perf-linked-failure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-linked-failure.rs?ref=34c5a09ce3c18874de7150afbf689ce0f94c7c20", "patch": "@@ -50,7 +50,7 @@ fn spawn_supervised_blocking(myname: &str, +f: ~fn()) {\n     let mut res = None;\n     task::task().future_result(|+r| res = Some(r)).supervised().spawn(f);\n     error!(\"%s group waiting\", myname);\n-    let x = option::unwrap(res).recv();\n+    let x = res.unwrap().recv();\n     fail_unless!(x == task::Success);\n }\n "}, {"sha": "f59eb509156ac040054abceb03365e4e0613d8c6", "filename": "src/test/compile-fail/arc-rw-cond-shouldnt-escape.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/34c5a09ce3c18874de7150afbf689ce0f94c7c20/src%2Ftest%2Fcompile-fail%2Farc-rw-cond-shouldnt-escape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34c5a09ce3c18874de7150afbf689ce0f94c7c20/src%2Ftest%2Fcompile-fail%2Farc-rw-cond-shouldnt-escape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Farc-rw-cond-shouldnt-escape.rs?ref=34c5a09ce3c18874de7150afbf689ce0f94c7c20", "patch": "@@ -17,5 +17,5 @@ fn main() {\n     do x.write_cond |_one, cond| {\n         y = Some(cond);\n     }\n-    option::unwrap(y).wait();\n+    y.unwrap().wait();\n }"}, {"sha": "22f5a8eac03d2f99035e642be50fd1bd4419455c", "filename": "src/test/compile-fail/arc-rw-state-shouldnt-escape.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/34c5a09ce3c18874de7150afbf689ce0f94c7c20/src%2Ftest%2Fcompile-fail%2Farc-rw-state-shouldnt-escape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34c5a09ce3c18874de7150afbf689ce0f94c7c20/src%2Ftest%2Fcompile-fail%2Farc-rw-state-shouldnt-escape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Farc-rw-state-shouldnt-escape.rs?ref=34c5a09ce3c18874de7150afbf689ce0f94c7c20", "patch": "@@ -17,5 +17,5 @@ fn main() {\n     do x.write |one| {\n         y = Some(one);\n     }\n-    *option::unwrap(y) = 2;\n+    *y.unwrap() = 2;\n }"}, {"sha": "c8273cb016797bca8bb8ebfbe6116e2dc58bc2a9", "filename": "src/test/compile-fail/arc-rw-write-mode-cond-shouldnt-escape.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/34c5a09ce3c18874de7150afbf689ce0f94c7c20/src%2Ftest%2Fcompile-fail%2Farc-rw-write-mode-cond-shouldnt-escape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34c5a09ce3c18874de7150afbf689ce0f94c7c20/src%2Ftest%2Fcompile-fail%2Farc-rw-write-mode-cond-shouldnt-escape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Farc-rw-write-mode-cond-shouldnt-escape.rs?ref=34c5a09ce3c18874de7150afbf689ce0f94c7c20", "patch": "@@ -19,5 +19,5 @@ fn main() {\n             y = Some(cond);\n         }\n     }\n-    option::unwrap(y).wait();\n+    y.unwrap().wait();\n }"}, {"sha": "5e3eb9ef09bc6a24aaef394a820dc090bd7ab419", "filename": "src/test/compile-fail/issue-2766-a.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/34c5a09ce3c18874de7150afbf689ce0f94c7c20/src%2Ftest%2Fcompile-fail%2Fissue-2766-a.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34c5a09ce3c18874de7150afbf689ce0f94c7c20/src%2Ftest%2Fcompile-fail%2Fissue-2766-a.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2766-a.rs?ref=34c5a09ce3c18874de7150afbf689ce0f94c7c20", "patch": "@@ -22,7 +22,7 @@ pub mod stream {\n                 //~^ ERROR use of undeclared type name\n                 //~^^ ERROR attempt to use a type argument out of scope\n                 //~^^^ ERROR use of undeclared type name\n-                    option::unwrap(pipes::recv(pipe))\n+                    pipes::recv(pipe).unwrap()\n                 }\n                 recv\n             }"}, {"sha": "295b6c989b5f3028b33efa0e287319a35d2c8fc1", "filename": "src/test/compile-fail/issue-3311.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/34c5a09ce3c18874de7150afbf689ce0f94c7c20/src%2Ftest%2Fcompile-fail%2Fissue-3311.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34c5a09ce3c18874de7150afbf689ce0f94c7c20/src%2Ftest%2Fcompile-fail%2Fissue-3311.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3311.rs?ref=34c5a09ce3c18874de7150afbf689ce0f94c7c20", "patch": "@@ -26,6 +26,6 @@ fn bar(s: &str, f: &fn(Option<Foo>)) {\n \n fn main() {\n     do bar(~\"testing\") |opt| {\n-        io::println(option::unwrap(opt).get_s()); //~ ERROR illegal borrow:\n+        io::println(opt.unwrap().get_s()); //~ ERROR illegal borrow:\n     };\n }"}, {"sha": "964c2ce946b473acf6ff9f2c28bf4cd730847111", "filename": "src/test/compile-fail/sync-cond-shouldnt-escape.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/34c5a09ce3c18874de7150afbf689ce0f94c7c20/src%2Ftest%2Fcompile-fail%2Fsync-cond-shouldnt-escape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34c5a09ce3c18874de7150afbf689ce0f94c7c20/src%2Ftest%2Fcompile-fail%2Fsync-cond-shouldnt-escape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fsync-cond-shouldnt-escape.rs?ref=34c5a09ce3c18874de7150afbf689ce0f94c7c20", "patch": "@@ -17,6 +17,6 @@ fn main() {\n     let mut cond = None;\n     do m.lock_cond |c| {\n         cond = Some(c);\n-    }   \n-    option::unwrap(cond).signal();\n+    }\n+    cond.unwrap().signal();\n }"}, {"sha": "9cab2d3b056260fd123b6e5b4412acc196142a2d", "filename": "src/test/compile-fail/sync-rwlock-cond-shouldnt-escape.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/34c5a09ce3c18874de7150afbf689ce0f94c7c20/src%2Ftest%2Fcompile-fail%2Fsync-rwlock-cond-shouldnt-escape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34c5a09ce3c18874de7150afbf689ce0f94c7c20/src%2Ftest%2Fcompile-fail%2Fsync-rwlock-cond-shouldnt-escape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fsync-rwlock-cond-shouldnt-escape.rs?ref=34c5a09ce3c18874de7150afbf689ce0f94c7c20", "patch": "@@ -17,5 +17,5 @@ fn main() {\n     do x.write_cond |cond| {\n         y = Some(cond);\n     }\n-    option::unwrap(y).wait();\n+    y.unwrap().wait();\n }"}, {"sha": "43ad693ccf8d8492e5b8128ac54412d776577df7", "filename": "src/test/compile-fail/sync-rwlock-write-mode-cond-shouldnt-escape.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/34c5a09ce3c18874de7150afbf689ce0f94c7c20/src%2Ftest%2Fcompile-fail%2Fsync-rwlock-write-mode-cond-shouldnt-escape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34c5a09ce3c18874de7150afbf689ce0f94c7c20/src%2Ftest%2Fcompile-fail%2Fsync-rwlock-write-mode-cond-shouldnt-escape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fsync-rwlock-write-mode-cond-shouldnt-escape.rs?ref=34c5a09ce3c18874de7150afbf689ce0f94c7c20", "patch": "@@ -19,5 +19,5 @@ fn main() {\n             y = Some(cond);\n         }\n     }\n-    option::unwrap(y).wait();\n+    y.unwrap().wait();\n }"}, {"sha": "3acfa74411721442c5a2af0d02598af8c6bda680", "filename": "src/test/run-pass/issue-2718.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/34c5a09ce3c18874de7150afbf689ce0f94c7c20/src%2Ftest%2Frun-pass%2Fissue-2718.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34c5a09ce3c18874de7150afbf689ce0f94c7c20/src%2Ftest%2Frun-pass%2Fissue-2718.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2718.rs?ref=34c5a09ce3c18874de7150afbf689ce0f94c7c20", "patch": "@@ -107,7 +107,7 @@ pub mod pipes {\n               full => {\n                 let mut payload = None;\n                 payload <-> (*p).payload;\n-                return Some(option::unwrap(payload))\n+                return Some(payload.unwrap())\n               }\n               terminated => {\n                 fail_unless!(old_state == terminated);\n@@ -164,7 +164,7 @@ pub mod pipes {\n                     let self_p: &mut Option<*packet<T>> =\n                         cast::transmute(&self.p);\n                     p <-> *self_p;\n-                    sender_terminate(option::unwrap(p))\n+                    sender_terminate(p.unwrap())\n                 }\n             }\n         }\n@@ -174,7 +174,7 @@ pub mod pipes {\n         fn unwrap(&mut self) -> *packet<T> {\n             let mut p = None;\n             p <-> self.p;\n-            option::unwrap(p)\n+            p.unwrap()\n         }\n     }\n \n@@ -197,7 +197,7 @@ pub mod pipes {\n                     let self_p: &mut Option<*packet<T>> =\n                         cast::transmute(&self.p);\n                     p <-> *self_p;\n-                    receiver_terminate(option::unwrap(p))\n+                    receiver_terminate(p.unwrap())\n                 }\n             }\n         }\n@@ -207,7 +207,7 @@ pub mod pipes {\n         fn unwrap(&mut self) -> *packet<T> {\n             let mut p = None;\n             p <-> self.p;\n-            option::unwrap(p)\n+            p.unwrap()\n         }\n     }\n \n@@ -275,7 +275,7 @@ pub mod pingpong {\n             if packet.is_none() {\n                 fail!(~\"sender closed the connection\")\n             }\n-            (pingpong::liberate_pong(option::unwrap(packet)), ())\n+            (pingpong::liberate_pong(packet.unwrap()), ())\n         }\n     }\n \n@@ -290,7 +290,7 @@ pub mod pingpong {\n             if packet.is_none() {\n                 fail!(~\"sender closed the connection\")\n             }\n-            (pingpong::liberate_ping(option::unwrap(packet)), ())\n+            (pingpong::liberate_ping(packet.unwrap()), ())\n         }\n \n         pub fn do_pong(+c: pong) -> ping {"}, {"sha": "6b3a37a9d79515b9d818e0af0905915215a80f27", "filename": "src/test/run-pass/stat.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/34c5a09ce3c18874de7150afbf689ce0f94c7c20/src%2Ftest%2Frun-pass%2Fstat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34c5a09ce3c18874de7150afbf689ce0f94c7c20/src%2Ftest%2Frun-pass%2Fstat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstat.rs?ref=34c5a09ce3c18874de7150afbf689ce0f94c7c20", "patch": "@@ -15,7 +15,7 @@ use core::io::WriterUtil;\n use std::tempfile;\n \n pub fn main() {\n-    let dir = option::unwrap(tempfile::mkdtemp(&Path(\".\"), \"\"));\n+    let dir = tempfile::mkdtemp(&Path(\".\"), \"\").unwrap();\n     let path = dir.with_filename(\"file\");\n \n     {"}, {"sha": "b426212d872f25a8605f254781a3a8bcc583dd49", "filename": "src/test/run-pass/task-comm-12.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/34c5a09ce3c18874de7150afbf689ce0f94c7c20/src%2Ftest%2Frun-pass%2Ftask-comm-12.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34c5a09ce3c18874de7150afbf689ce0f94c7c20/src%2Ftest%2Frun-pass%2Ftask-comm-12.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-12.rs?ref=34c5a09ce3c18874de7150afbf689ce0f94c7c20", "patch": "@@ -29,7 +29,7 @@ fn test00() {\n     }\n \n     // Try joining tasks that have already finished.\n-    option::unwrap(result).recv();\n+    result.unwrap().recv();\n \n     debug!(\"Joined task.\");\n }"}, {"sha": "767203a1f630dcc775c0155a2d10702b8c6fab93", "filename": "src/test/run-pass/task-comm-9.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/34c5a09ce3c18874de7150afbf689ce0f94c7c20/src%2Ftest%2Frun-pass%2Ftask-comm-9.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34c5a09ce3c18874de7150afbf689ce0f94c7c20/src%2Ftest%2Frun-pass%2Ftask-comm-9.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-9.rs?ref=34c5a09ce3c18874de7150afbf689ce0f94c7c20", "patch": "@@ -39,7 +39,7 @@ fn test00() {\n         i += 1;\n     }\n \n-    option::unwrap(result).recv();\n+    result.unwrap().recv();\n \n     fail_unless!((sum == number_of_messages * (number_of_messages - 1) / 2));\n }"}, {"sha": "75d9979807b47afe9cb54dcb8f91afa3cf791813", "filename": "src/test/run-pass/yield.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/34c5a09ce3c18874de7150afbf689ce0f94c7c20/src%2Ftest%2Frun-pass%2Fyield.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34c5a09ce3c18874de7150afbf689ce0f94c7c20/src%2Ftest%2Frun-pass%2Fyield.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fyield.rs?ref=34c5a09ce3c18874de7150afbf689ce0f94c7c20", "patch": "@@ -17,7 +17,7 @@ pub fn main() {\n     error!(\"2\");\n     task::yield();\n     error!(\"3\");\n-    option::unwrap(result).recv();\n+    result.unwrap().recv();\n }\n \n fn child() {"}, {"sha": "51483121f50fc0368c16754bc69d5e8bf7c82acd", "filename": "src/test/run-pass/yield1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/34c5a09ce3c18874de7150afbf689ce0f94c7c20/src%2Ftest%2Frun-pass%2Fyield1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34c5a09ce3c18874de7150afbf689ce0f94c7c20/src%2Ftest%2Frun-pass%2Fyield1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fyield1.rs?ref=34c5a09ce3c18874de7150afbf689ce0f94c7c20", "patch": "@@ -14,7 +14,7 @@ pub fn main() {\n     task::task().future_result(|+r| { result = Some(r); }).spawn(child);\n     error!(\"1\");\n     task::yield();\n-    option::unwrap(result).recv();\n+    result.unwrap().recv();\n }\n \n fn child() { error!(\"2\"); }"}]}