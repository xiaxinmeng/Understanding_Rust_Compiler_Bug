{"sha": "8abcbaba1dd3f98dc37bec2288ba61a044be785c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhhYmNiYWJhMWRkM2Y5OGRjMzdiZWMyMjg4YmE2MWEwNDRiZTc4NWM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-01-21T09:02:44Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-01-21T09:02:44Z"}, "message": "Auto merge of #21227 - sellibitze:core-ops-for-references, r=aturon\n\nAs discussed with @aturon I added implementations of various op traits for references to built-in types which was already suggested by the ops reform RFC.\r\n\r\nThe 2nd commit updates the module documentation of core::ops to fully reflect the recent change from pass-by-reference to pass-by-value and expands on the implications for generic code.", "tree": {"sha": "f1afdef7acac6d4e10b9cf4847e9de9f013e5c94", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f1afdef7acac6d4e10b9cf4847e9de9f013e5c94"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8abcbaba1dd3f98dc37bec2288ba61a044be785c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8abcbaba1dd3f98dc37bec2288ba61a044be785c", "html_url": "https://github.com/rust-lang/rust/commit/8abcbaba1dd3f98dc37bec2288ba61a044be785c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8abcbaba1dd3f98dc37bec2288ba61a044be785c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "51e28dd0c88030b8661f0c414eb0af3e09840b31", "url": "https://api.github.com/repos/rust-lang/rust/commits/51e28dd0c88030b8661f0c414eb0af3e09840b31", "html_url": "https://github.com/rust-lang/rust/commit/51e28dd0c88030b8661f0c414eb0af3e09840b31"}, {"sha": "970fd747b9dffe6263e599bb0f2da63a59c0c51c", "url": "https://api.github.com/repos/rust-lang/rust/commits/970fd747b9dffe6263e599bb0f2da63a59c0c51c", "html_url": "https://github.com/rust-lang/rust/commit/970fd747b9dffe6263e599bb0f2da63a59c0c51c"}], "stats": {"total": 96, "additions": 92, "deletions": 4}, "files": [{"sha": "905de9ef615dc96ac69da4c6901a8dc95e673952", "filename": "src/libcore/ops.rs", "status": "modified", "additions": 92, "deletions": 4, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/8abcbaba1dd3f98dc37bec2288ba61a044be785c/src%2Flibcore%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8abcbaba1dd3f98dc37bec2288ba61a044be785c/src%2Flibcore%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops.rs?ref=8abcbaba1dd3f98dc37bec2288ba61a044be785c", "patch": "@@ -13,12 +13,20 @@\n //! Implementing these traits allows you to get an effect similar to\n //! overloading operators.\n //!\n-//! The values for the right hand side of an operator are automatically\n-//! borrowed, so `a + b` is sugar for `a.add(&b)`.\n-//!\n-//! All of these traits are imported by the prelude, so they are available in\n+//! Some of these traits are imported by the prelude, so they are available in\n //! every Rust program.\n //!\n+//! Many of the operators take their operands by value. In non-generic\n+//! contexts involving built-in types, this is usually not a problem.\n+//! However, using these operators in generic code, requires some\n+//! attention if values have to be reused as opposed to letting the operators\n+//! consume them. One option is to occasionally use `clone()`.\n+//! Another option is to rely on the types involved providing additional\n+//! operator implementations for references. For example, for a user-defined\n+//! type `T` which is supposed to support addition, it is probably a good\n+//! idea to have both `T` and `&T` implement the traits `Add<T>` and `Add<&T>`\n+//! so that generic code can be written without unnecessary cloning.\n+//!\n //! # Example\n //!\n //! This example creates a `Point` struct that implements `Add` and `Sub`, and then\n@@ -96,6 +104,58 @@ pub trait Drop {\n     fn drop(&mut self);\n }\n \n+// implements the unary operator \"op &T\"\n+// based on \"op T\" where T is expected to be `Copy`able\n+macro_rules! forward_ref_unop {\n+    (impl $imp:ident, $method:ident for $t:ty) => {\n+        #[unstable = \"recently added, waiting for dust to settle\"]\n+        impl<'a> $imp for &'a $t {\n+            type Output = <$t as $imp>::Output;\n+\n+            #[inline]\n+            fn $method(self) -> <$t as $imp>::Output {\n+                $imp::$method(*self)\n+            }\n+        }\n+    }\n+}\n+\n+// implements binary operators \"&T op U\", \"T op &U\", \"&T op &U\"\n+// based on \"T op U\" where T and U are expected to be `Copy`able\n+macro_rules! forward_ref_binop {\n+    (impl $imp:ident, $method:ident for $t:ty, $u:ty) => {\n+        #[unstable = \"recently added, waiting for dust to settle\"]\n+        impl<'a> $imp<$u> for &'a $t {\n+            type Output = <$t as $imp<$u>>::Output;\n+\n+            #[inline]\n+            fn $method(self, other: $u) -> <$t as $imp<$u>>::Output {\n+                $imp::$method(*self, other)\n+            }\n+        }\n+\n+        #[unstable = \"recently added, waiting for dust to settle\"]\n+        impl<'a> $imp<&'a $u> for $t {\n+            type Output = <$t as $imp<$u>>::Output;\n+\n+            #[inline]\n+            fn $method(self, other: &'a $u) -> <$t as $imp<$u>>::Output {\n+                $imp::$method(self, *other)\n+            }\n+        }\n+\n+        #[unstable = \"recently added, waiting for dust to settle\"]\n+        impl<'a, 'b> $imp<&'a $u> for &'b $t {\n+            type Output = <$t as $imp<$u>>::Output;\n+\n+            #[inline]\n+            fn $method(self, other: &'a $u) -> <$t as $imp<$u>>::Output {\n+                $imp::$method(*self, *other)\n+            }\n+        }\n+    }\n+}\n+\n /// The `Add` trait is used to specify the functionality of `+`.\n ///\n /// # Example\n@@ -144,6 +204,8 @@ macro_rules! add_impl {\n             #[inline]\n             fn add(self, other: $t) -> $t { self + other }\n         }\n+\n+        forward_ref_binop! { impl Add, add for $t, $t }\n     )*)\n }\n \n@@ -197,6 +259,8 @@ macro_rules! sub_impl {\n             #[inline]\n             fn sub(self, other: $t) -> $t { self - other }\n         }\n+\n+        forward_ref_binop! { impl Sub, sub for $t, $t }\n     )*)\n }\n \n@@ -250,6 +314,8 @@ macro_rules! mul_impl {\n             #[inline]\n             fn mul(self, other: $t) -> $t { self * other }\n         }\n+\n+        forward_ref_binop! { impl Mul, mul for $t, $t }\n     )*)\n }\n \n@@ -303,6 +369,8 @@ macro_rules! div_impl {\n             #[inline]\n             fn div(self, other: $t) -> $t { self / other }\n         }\n+\n+        forward_ref_binop! { impl Div, div for $t, $t }\n     )*)\n }\n \n@@ -356,6 +424,8 @@ macro_rules! rem_impl {\n             #[inline]\n             fn rem(self, other: $t) -> $t { self % other }\n         }\n+\n+        forward_ref_binop! { impl Rem, rem for $t, $t }\n     )*)\n }\n \n@@ -371,6 +441,8 @@ macro_rules! rem_float_impl {\n                 unsafe { $fmod(self, other) }\n             }\n         }\n+\n+        forward_ref_binop! { impl Rem, rem for $t, $t }\n     }\n }\n \n@@ -429,6 +501,8 @@ macro_rules! neg_impl {\n             #[stable]\n             fn neg(self) -> $t { -self }\n         }\n+\n+        forward_ref_unop! { impl Neg, neg for $t }\n     )*)\n }\n \n@@ -441,6 +515,8 @@ macro_rules! neg_uint_impl {\n             #[inline]\n             fn neg(self) -> $t { -(self as $t_signed) as $t }\n         }\n+\n+        forward_ref_unop! { impl Neg, neg for $t }\n     }\n }\n \n@@ -502,6 +578,8 @@ macro_rules! not_impl {\n             #[inline]\n             fn not(self) -> $t { !self }\n         }\n+\n+        forward_ref_unop! { impl Not, not for $t }\n     )*)\n }\n \n@@ -555,6 +633,8 @@ macro_rules! bitand_impl {\n             #[inline]\n             fn bitand(self, rhs: $t) -> $t { self & rhs }\n         }\n+\n+        forward_ref_binop! { impl BitAnd, bitand for $t, $t }\n     )*)\n }\n \n@@ -608,6 +688,8 @@ macro_rules! bitor_impl {\n             #[inline]\n             fn bitor(self, rhs: $t) -> $t { self | rhs }\n         }\n+\n+        forward_ref_binop! { impl BitOr, bitor for $t, $t }\n     )*)\n }\n \n@@ -661,6 +743,8 @@ macro_rules! bitxor_impl {\n             #[inline]\n             fn bitxor(self, other: $t) -> $t { self ^ other }\n         }\n+\n+        forward_ref_binop! { impl BitXor, bitxor for $t, $t }\n     )*)\n }\n \n@@ -716,6 +800,8 @@ macro_rules! shl_impl {\n                 self << other\n             }\n         }\n+\n+        forward_ref_binop! { impl Shl, shl for $t, $f }\n     )\n }\n \n@@ -786,6 +872,8 @@ macro_rules! shr_impl {\n                 self >> other\n             }\n         }\n+\n+        forward_ref_binop! { impl Shr, shr for $t, $f }\n     )\n }\n "}]}