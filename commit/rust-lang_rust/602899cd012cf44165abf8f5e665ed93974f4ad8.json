{"sha": "602899cd012cf44165abf8f5e665ed93974f4ad8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYwMjg5OWNkMDEyY2Y0NDE2NWFiZjhmNWU2NjVlZDkzOTc0ZjRhZDg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-12-12T02:40:17Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-12-12T02:40:17Z"}, "message": "Auto merge of #79931 - RalfJung:no-redundant-storage-live, r=oli-obk\n\nmake redundant StorageLive UB\n\nThe interesting behavior of StorageLive in loops (https://github.com/rust-lang/rust/issues/42371) has been fixed, so we can now finally make it a hard error to mark a local as live that is already live. :)\n\nr? `@oli-obk`\nFixes https://github.com/rust-lang/rust/issues/42371", "tree": {"sha": "710044360ffe5ddd23c1db6eae1125fed2e7a9d6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/710044360ffe5ddd23c1db6eae1125fed2e7a9d6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/602899cd012cf44165abf8f5e665ed93974f4ad8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/602899cd012cf44165abf8f5e665ed93974f4ad8", "html_url": "https://github.com/rust-lang/rust/commit/602899cd012cf44165abf8f5e665ed93974f4ad8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/602899cd012cf44165abf8f5e665ed93974f4ad8/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5bd9b60333b3dc0a51e7a5607cd1e0d537a9f718", "url": "https://api.github.com/repos/rust-lang/rust/commits/5bd9b60333b3dc0a51e7a5607cd1e0d537a9f718", "html_url": "https://github.com/rust-lang/rust/commit/5bd9b60333b3dc0a51e7a5607cd1e0d537a9f718"}, {"sha": "78deacc2ec5ea47404de1f19fa7f47d53b55e1db", "url": "https://api.github.com/repos/rust-lang/rust/commits/78deacc2ec5ea47404de1f19fa7f47d53b55e1db", "html_url": "https://github.com/rust-lang/rust/commit/78deacc2ec5ea47404de1f19fa7f47d53b55e1db"}], "stats": {"total": 39, "additions": 16, "deletions": 23}, "files": [{"sha": "3d955576f0ff27775bbc9b5660d3617a70d65f22", "filename": "compiler/rustc_mir/src/interpret/eval_context.rs", "status": "modified", "additions": 14, "deletions": 19, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/602899cd012cf44165abf8f5e665ed93974f4ad8/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/602899cd012cf44165abf8f5e665ed93974f4ad8/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Feval_context.rs?ref=602899cd012cf44165abf8f5e665ed93974f4ad8", "patch": "@@ -840,36 +840,31 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         Ok(())\n     }\n \n-    /// Mark a storage as live, killing the previous content and returning it.\n-    /// Remember to deallocate that!\n-    pub fn storage_live(\n-        &mut self,\n-        local: mir::Local,\n-    ) -> InterpResult<'tcx, LocalValue<M::PointerTag>> {\n+    /// Mark a storage as live, killing the previous content.\n+    pub fn storage_live(&mut self, local: mir::Local) -> InterpResult<'tcx> {\n         assert!(local != mir::RETURN_PLACE, \"Cannot make return place live\");\n         trace!(\"{:?} is now live\", local);\n \n         let local_val = LocalValue::Uninitialized;\n-        // StorageLive *always* kills the value that's currently stored.\n-        // However, we do not error if the variable already is live;\n-        // see <https://github.com/rust-lang/rust/issues/42371>.\n-        Ok(mem::replace(&mut self.frame_mut().locals[local].value, local_val))\n+        // StorageLive expects the local to be dead, and marks it live.\n+        let old = mem::replace(&mut self.frame_mut().locals[local].value, local_val);\n+        if !matches!(old, LocalValue::Dead) {\n+            throw_ub_format!(\"StorageLive on a local that was already live\");\n+        }\n+        Ok(())\n     }\n \n-    /// Returns the old value of the local.\n-    /// Remember to deallocate that!\n-    pub fn storage_dead(&mut self, local: mir::Local) -> LocalValue<M::PointerTag> {\n+    pub fn storage_dead(&mut self, local: mir::Local) -> InterpResult<'tcx> {\n         assert!(local != mir::RETURN_PLACE, \"Cannot make return place dead\");\n         trace!(\"{:?} is now dead\", local);\n \n-        mem::replace(&mut self.frame_mut().locals[local].value, LocalValue::Dead)\n+        // It is entirely okay for this local to be already dead (at least that's how we currently generate MIR)\n+        let old = mem::replace(&mut self.frame_mut().locals[local].value, LocalValue::Dead);\n+        self.deallocate_local(old)?;\n+        Ok(())\n     }\n \n-    pub(super) fn deallocate_local(\n-        &mut self,\n-        local: LocalValue<M::PointerTag>,\n-    ) -> InterpResult<'tcx> {\n-        // FIXME: should we tell the user that there was a local which was never written to?\n+    fn deallocate_local(&mut self, local: LocalValue<M::PointerTag>) -> InterpResult<'tcx> {\n         if let LocalValue::Live(Operand::Indirect(MemPlace { ptr, .. })) = local {\n             // All locals have a backing allocation, even if the allocation is empty\n             // due to the local having ZST type."}, {"sha": "95738db1f553c0bc0506cdd0a591d0857d0088bf", "filename": "compiler/rustc_mir/src/interpret/step.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/602899cd012cf44165abf8f5e665ed93974f4ad8/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/602899cd012cf44165abf8f5e665ed93974f4ad8/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fstep.rs?ref=602899cd012cf44165abf8f5e665ed93974f4ad8", "patch": "@@ -95,14 +95,12 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n \n             // Mark locals as alive\n             StorageLive(local) => {\n-                let old_val = self.storage_live(*local)?;\n-                self.deallocate_local(old_val)?;\n+                self.storage_live(*local)?;\n             }\n \n             // Mark locals as dead\n             StorageDead(local) => {\n-                let old_val = self.storage_dead(*local);\n-                self.deallocate_local(old_val)?;\n+                self.storage_dead(*local)?;\n             }\n \n             // No dynamic semantics attached to `FakeRead`; MIR"}]}