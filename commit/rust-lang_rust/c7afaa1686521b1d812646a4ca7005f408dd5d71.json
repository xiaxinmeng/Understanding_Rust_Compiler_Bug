{"sha": "c7afaa1686521b1d812646a4ca7005f408dd5d71", "node_id": "C_kwDOAAsO6NoAKGM3YWZhYTE2ODY1MjFiMWQ4MTI2NDZhNGNhNzAwNWY0MDhkZDVkNzE", "commit": {"author": {"name": "Eric Holk", "email": "ericholk@microsoft.com", "date": "2021-11-17T19:39:27Z"}, "committer": {"name": "Eric Holk", "email": "ericholk@microsoft.com", "date": "2022-01-18T22:25:26Z"}, "message": "Handle break and continue. Change fixpoint computation to handle unreachable nodes.", "tree": {"sha": "17be5e3faca1b31e4a1145df1c132aa38b79f342", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/17be5e3faca1b31e4a1145df1c132aa38b79f342"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c7afaa1686521b1d812646a4ca7005f408dd5d71", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c7afaa1686521b1d812646a4ca7005f408dd5d71", "html_url": "https://github.com/rust-lang/rust/commit/c7afaa1686521b1d812646a4ca7005f408dd5d71", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c7afaa1686521b1d812646a4ca7005f408dd5d71/comments", "author": {"login": "eholk", "id": 105766, "node_id": "MDQ6VXNlcjEwNTc2Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/105766?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eholk", "html_url": "https://github.com/eholk", "followers_url": "https://api.github.com/users/eholk/followers", "following_url": "https://api.github.com/users/eholk/following{/other_user}", "gists_url": "https://api.github.com/users/eholk/gists{/gist_id}", "starred_url": "https://api.github.com/users/eholk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eholk/subscriptions", "organizations_url": "https://api.github.com/users/eholk/orgs", "repos_url": "https://api.github.com/users/eholk/repos", "events_url": "https://api.github.com/users/eholk/events{/privacy}", "received_events_url": "https://api.github.com/users/eholk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eholk", "id": 105766, "node_id": "MDQ6VXNlcjEwNTc2Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/105766?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eholk", "html_url": "https://github.com/eholk", "followers_url": "https://api.github.com/users/eholk/followers", "following_url": "https://api.github.com/users/eholk/following{/other_user}", "gists_url": "https://api.github.com/users/eholk/gists{/gist_id}", "starred_url": "https://api.github.com/users/eholk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eholk/subscriptions", "organizations_url": "https://api.github.com/users/eholk/orgs", "repos_url": "https://api.github.com/users/eholk/repos", "events_url": "https://api.github.com/users/eholk/events{/privacy}", "received_events_url": "https://api.github.com/users/eholk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ff0e8f4ba2e3133a167b138ba1ed69d1708fff16", "url": "https://api.github.com/repos/rust-lang/rust/commits/ff0e8f4ba2e3133a167b138ba1ed69d1708fff16", "html_url": "https://github.com/rust-lang/rust/commit/ff0e8f4ba2e3133a167b138ba1ed69d1708fff16"}], "stats": {"total": 198, "additions": 134, "deletions": 64}, "files": [{"sha": "1df45b566ce75d5a0ae09afeed09d21a0b587ddf", "filename": "compiler/rustc_typeck/src/check/generator_interior.rs", "status": "modified", "additions": 25, "deletions": 13, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/c7afaa1686521b1d812646a4ca7005f408dd5d71/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7afaa1686521b1d812646a4ca7005f408dd5d71/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior.rs?ref=c7afaa1686521b1d812646a4ca7005f408dd5d71", "patch": "@@ -246,15 +246,20 @@ pub fn resolve_interior<'a, 'tcx>(\n         )\n         .consume_body(body);\n \n-        let mut drop_range_visitor = DropRangeVisitor::from(expr_use_visitor);\n+        let region_scope_tree = fcx.tcx.region_scope_tree(def_id);\n+\n+        let mut drop_range_visitor = DropRangeVisitor::from(\n+            expr_use_visitor,\n+            region_scope_tree.body_expr_count(body.id()).unwrap_or(0),\n+        );\n         intravisit::walk_body(&mut drop_range_visitor, body);\n \n         drop_range_visitor.drop_ranges.propagate_to_fixpoint();\n \n         InteriorVisitor {\n             fcx,\n             types: FxIndexSet::default(),\n-            region_scope_tree: fcx.tcx.region_scope_tree(def_id),\n+            region_scope_tree,\n             expr_count: 0,\n             kind,\n             prev_unresolved_span: None,\n@@ -699,11 +704,12 @@ struct DropRangeVisitor<'tcx> {\n }\n \n impl<'tcx> DropRangeVisitor<'tcx> {\n-    fn from(uses: ExprUseDelegate<'tcx>) -> Self {\n+    fn from(uses: ExprUseDelegate<'tcx>, num_exprs: usize) -> Self {\n         debug!(\"consumed_places: {:?}\", uses.consumed_places);\n         let drop_ranges = DropRanges::new(\n             uses.consumed_places.iter().flat_map(|(_, places)| places.iter().copied()),\n             &uses.hir,\n+            num_exprs,\n         );\n         Self {\n             hir: uses.hir,\n@@ -851,18 +857,18 @@ impl<'tcx> Visitor<'tcx> for DropRangeVisitor<'tcx> {\n             ExprKind::If(test, if_true, if_false) => {\n                 self.visit_expr(test);\n \n-                let fork = self.expr_count - 1;\n+                let fork = self.expr_count;\n \n-                self.drop_ranges.add_control_edge(fork, self.expr_count);\n+                self.drop_ranges.add_control_edge(fork, self.expr_count + 1);\n                 self.visit_expr(if_true);\n-                let true_end = self.expr_count - 1;\n+                let true_end = self.expr_count;\n \n+                self.drop_ranges.add_control_edge(fork, self.expr_count + 1);\n                 if let Some(if_false) = if_false {\n-                    self.drop_ranges.add_control_edge(fork, self.expr_count);\n                     self.visit_expr(if_false);\n                 }\n \n-                self.drop_ranges.add_control_edge(true_end, self.expr_count);\n+                self.drop_ranges.add_control_edge(true_end, self.expr_count + 1);\n             }\n             ExprKind::Assign(lhs, rhs, _) => {\n                 self.visit_expr(lhs);\n@@ -873,13 +879,13 @@ impl<'tcx> Visitor<'tcx> for DropRangeVisitor<'tcx> {\n             ExprKind::Loop(body, ..) => {\n                 let loop_begin = self.expr_count;\n                 self.visit_block(body);\n-                self.drop_ranges.add_control_edge(self.expr_count - 1, loop_begin);\n+                self.drop_ranges.add_control_edge(self.expr_count, loop_begin);\n             }\n             ExprKind::Match(scrutinee, arms, ..) => {\n                 self.visit_expr(scrutinee);\n \n                 let fork = self.expr_count - 1;\n-                let arm_drops = arms\n+                let arm_end_ids = arms\n                     .iter()\n                     .map(|Arm { pat, body, guard, .. }| {\n                         self.drop_ranges.add_control_edge(fork, self.expr_count);\n@@ -893,16 +899,22 @@ impl<'tcx> Visitor<'tcx> for DropRangeVisitor<'tcx> {\n                             None => (),\n                         }\n                         self.visit_expr(body);\n-                        self.expr_count - 1\n+                        self.expr_count\n                     })\n                     .collect::<Vec<_>>();\n-                arm_drops.into_iter().for_each(|arm_end| {\n-                    self.drop_ranges.add_control_edge(arm_end, self.expr_count)\n+                arm_end_ids.into_iter().for_each(|arm_end| {\n+                    self.drop_ranges.add_control_edge(arm_end, self.expr_count + 1)\n                 });\n             }\n+            ExprKind::Break(hir::Destination { target_id: Ok(target), .. }, ..)\n+            | ExprKind::Continue(hir::Destination { target_id: Ok(target), .. }, ..) => {\n+                self.drop_ranges.add_control_edge_hir_id(self.expr_count, target);\n+            }\n+\n             _ => intravisit::walk_expr(self, expr),\n         }\n \n+        self.drop_ranges.add_node_mapping(expr.hir_id, self.expr_count);\n         self.expr_count += 1;\n         self.consume_expr(expr);\n         if let Some(expr) = reinit {"}, {"sha": "504734080b69daad18c96c895bcda31fd2205003", "filename": "compiler/rustc_typeck/src/check/generator_interior/drop_ranges.rs", "status": "modified", "additions": 109, "deletions": 51, "changes": 160, "blob_url": "https://github.com/rust-lang/rust/blob/c7afaa1686521b1d812646a4ca7005f408dd5d71/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior%2Fdrop_ranges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7afaa1686521b1d812646a4ca7005f408dd5d71/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior%2Fdrop_ranges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior%2Fdrop_ranges.rs?ref=c7afaa1686521b1d812646a4ca7005f408dd5d71", "patch": "@@ -1,3 +1,7 @@\n+use std::collections::BTreeMap;\n+use std::fmt::Debug;\n+use std::mem::swap;\n+\n use rustc_hir::{HirId, HirIdMap};\n use rustc_index::bit_set::BitSet;\n use rustc_index::vec::IndexVec;\n@@ -20,6 +24,19 @@ rustc_index::newtype_index! {\n pub struct DropRanges {\n     hir_id_map: HirIdMap<HirIdIndex>,\n     nodes: IndexVec<PostOrderId, NodeInfo>,\n+    deferred_edges: Vec<(usize, HirId)>,\n+    // FIXME: This should only be used for loops and break/continue.\n+    post_order_map: HirIdMap<usize>,\n+}\n+\n+impl Debug for DropRanges {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n+        f.debug_struct(\"DropRanges\")\n+            .field(\"hir_id_map\", &self.hir_id_map)\n+            .field(\"post_order_maps\", &self.post_order_map)\n+            .field(\"nodes\", &self.nodes.iter_enumerated().collect::<BTreeMap<_, _>>())\n+            .finish()\n+    }\n }\n \n /// DropRanges keeps track of what values are definitely dropped at each point in the code.\n@@ -29,7 +46,7 @@ pub struct DropRanges {\n /// (hir_id, post_order_id) -> bool, where a true value indicates that the value is definitely\n /// dropped at the point of the node identified by post_order_id.\n impl DropRanges {\n-    pub fn new(hir_ids: impl Iterator<Item = HirId>, hir: &Map<'_>) -> Self {\n+    pub fn new(hir_ids: impl Iterator<Item = HirId>, hir: &Map<'_>, num_exprs: usize) -> Self {\n         let mut hir_id_map = HirIdMap::<HirIdIndex>::default();\n         let mut next = <_>::from(0u32);\n         for hir_id in hir_ids {\n@@ -41,7 +58,13 @@ impl DropRanges {\n             });\n         }\n         debug!(\"hir_id_map: {:?}\", hir_id_map);\n-        Self { hir_id_map, nodes: <_>::default() }\n+        let num_values = hir_id_map.len();\n+        Self {\n+            hir_id_map,\n+            nodes: IndexVec::from_fn_n(|_| NodeInfo::new(num_values), num_exprs + 1),\n+            deferred_edges: <_>::default(),\n+            post_order_map: <_>::default(),\n+        }\n     }\n \n     fn hidx(&self, hir_id: HirId) -> HirIdIndex {\n@@ -52,17 +75,23 @@ impl DropRanges {\n         self.hir_id_map\n             .get(&hir_id)\n             .copied()\n-            .map_or(false, |hir_id| self.node(location.into()).drop_state.contains(hir_id))\n+            .map_or(false, |hir_id| self.expect_node(location.into()).drop_state.contains(hir_id))\n     }\n \n     /// Returns the number of values (hir_ids) that are tracked\n     fn num_values(&self) -> usize {\n         self.hir_id_map.len()\n     }\n \n-    fn node(&mut self, id: PostOrderId) -> &NodeInfo {\n-        let size = self.num_values();\n-        self.nodes.ensure_contains_elem(id, || NodeInfo::new(size));\n+    /// Adds an entry in the mapping from HirIds to PostOrderIds\n+    ///\n+    /// Needed so that `add_control_edge_hir_id` can work.\n+    pub fn add_node_mapping(&mut self, hir_id: HirId, post_order_id: usize) {\n+        self.post_order_map.insert(hir_id, post_order_id);\n+    }\n+\n+    /// Returns a reference to the NodeInfo for a node, panicking if it does not exist\n+    fn expect_node(&self, id: PostOrderId) -> &NodeInfo {\n         &self.nodes[id]\n     }\n \n@@ -73,9 +102,32 @@ impl DropRanges {\n     }\n \n     pub fn add_control_edge(&mut self, from: usize, to: usize) {\n+        trace!(\"adding control edge from {} to {}\", from, to);\n         self.node_mut(from.into()).successors.push(to.into());\n     }\n \n+    /// Like add_control_edge, but uses a hir_id as the target.\n+    ///\n+    /// This can be used for branches where we do not know the PostOrderId of the target yet,\n+    /// such as when handling `break` or `continue`.\n+    pub fn add_control_edge_hir_id(&mut self, from: usize, to: HirId) {\n+        self.deferred_edges.push((from, to));\n+    }\n+\n+    /// Looks up PostOrderId for any control edges added by HirId and adds a proper edge for them.\n+    ///\n+    /// Should be called after visiting the HIR but before solving the control flow, otherwise some\n+    /// edges will be missed.\n+    fn process_deferred_edges(&mut self) {\n+        let mut edges = vec![];\n+        swap(&mut edges, &mut self.deferred_edges);\n+        edges.into_iter().for_each(|(from, to)| {\n+            let to = *self.post_order_map.get(&to).expect(\"Expression ID not found\");\n+            trace!(\"Adding deferred edge from {} to {}\", from, to);\n+            self.add_control_edge(from, to)\n+        });\n+    }\n+\n     pub fn drop_at(&mut self, value: HirId, location: usize) {\n         let value = self.hidx(value);\n         self.node_mut(location.into()).drops.push(value);\n@@ -92,40 +144,65 @@ impl DropRanges {\n     }\n \n     pub fn propagate_to_fixpoint(&mut self) {\n-        while self.propagate() {}\n-    }\n+        trace!(\"before fixpoint: {:#?}\", self);\n+        self.process_deferred_edges();\n+        let preds = self.compute_predecessors();\n+\n+        trace!(\"predecessors: {:#?}\", preds.iter_enumerated().collect::<BTreeMap<_, _>>());\n+\n+        let mut propagate = || {\n+            let mut changed = false;\n+            for id in self.nodes.indices() {\n+                let old_state = self.nodes[id].drop_state.clone();\n+                if preds[id].len() != 0 {\n+                    self.nodes[id].drop_state = self.nodes[preds[id][0]].drop_state.clone();\n+                    for pred in &preds[id][1..] {\n+                        let state = self.nodes[*pred].drop_state.clone();\n+                        self.nodes[id].drop_state.intersect(&state);\n+                    }\n+                } else {\n+                    self.nodes[id].drop_state = if id.index() == 0 {\n+                        BitSet::new_empty(self.num_values())\n+                    } else {\n+                        // If we are not the start node and we have no predecessors, treat\n+                        // everything as dropped because there's no way to get here anyway.\n+                        BitSet::new_filled(self.num_values())\n+                    };\n+                };\n+                for drop in &self.nodes[id].drops.clone() {\n+                    self.nodes[id].drop_state.insert(*drop);\n+                }\n+                for reinit in &self.nodes[id].reinits.clone() {\n+                    self.nodes[id].drop_state.remove(*reinit);\n+                }\n \n-    fn propagate(&mut self) -> bool {\n-        let mut visited = BitSet::new_empty(self.nodes.len());\n+                changed |= old_state != self.nodes[id].drop_state;\n+            }\n \n-        self.visit(&mut visited, PostOrderId::from(0usize), PostOrderId::from(0usize), false)\n-    }\n+            changed\n+        };\n \n-    fn visit(\n-        &mut self,\n-        visited: &mut BitSet<PostOrderId>,\n-        id: PostOrderId,\n-        pred_id: PostOrderId,\n-        mut changed: bool,\n-    ) -> bool {\n-        if visited.contains(id) {\n-            return changed;\n-        }\n-        visited.insert(id);\n+        while propagate() {}\n \n-        changed &= self.nodes[id].merge_with(&self.nodes[pred_id]);\n+        trace!(\"after fixpoint: {:#?}\", self);\n+    }\n \n-        if self.nodes[id].successors.len() == 0 {\n-            self.visit(visited, PostOrderId::from(id.index() + 1), id, changed)\n-        } else {\n-            self.nodes[id]\n-                .successors\n-                .iter()\n-                .fold(changed, |changed, &succ| self.visit(visited, succ, id, changed))\n+    fn compute_predecessors(&self) -> IndexVec<PostOrderId, Vec<PostOrderId>> {\n+        let mut preds = IndexVec::from_fn_n(|_| vec![], self.nodes.len());\n+        for (id, node) in self.nodes.iter_enumerated() {\n+            if node.successors.len() == 0 && id.index() != self.nodes.len() - 1 {\n+                preds[<_>::from(id.index() + 1)].push(id);\n+            } else {\n+                for succ in &node.successors {\n+                    preds[*succ].push(id);\n+                }\n+            }\n         }\n+        preds\n     }\n }\n \n+#[derive(Debug)]\n struct NodeInfo {\n     /// IDs of nodes that can follow this one in the control flow\n     ///\n@@ -148,26 +225,7 @@ impl NodeInfo {\n             successors: vec![],\n             drops: vec![],\n             reinits: vec![],\n-            drop_state: BitSet::new_empty(num_values),\n+            drop_state: BitSet::new_filled(num_values),\n         }\n     }\n-\n-    fn merge_with(&mut self, other: &NodeInfo) -> bool {\n-        let mut changed = false;\n-        for place in &self.drops {\n-            if !self.drop_state.contains(place) && !self.reinits.contains(&place) {\n-                changed = true;\n-                self.drop_state.insert(place);\n-            }\n-        }\n-\n-        for place in &self.reinits {\n-            if self.drop_state.contains(place) {\n-                changed = true;\n-                self.drop_state.remove(place);\n-            }\n-        }\n-\n-        changed\n-    }\n }"}]}