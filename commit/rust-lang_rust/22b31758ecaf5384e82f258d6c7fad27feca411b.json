{"sha": "22b31758ecaf5384e82f258d6c7fad27feca411b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIyYjMxNzU4ZWNhZjUzODRlODJmMjU4ZDZjN2ZhZDI3ZmVjYTQxMWI=", "commit": {"author": {"name": "Zack M. Davis", "email": "code@zackmdavis.net", "date": "2017-11-21T00:23:26Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-12-04T13:51:11Z"}, "message": "region_infer: BitMatrix representation of region values\n\nThis should be more efficient than allocating two BTreeSets for every\nregion variable?\u2014as it is written in #45670.", "tree": {"sha": "6abd62a9ab63b415761c002d57cbe417d8c36e68", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6abd62a9ab63b415761c002d57cbe417d8c36e68"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/22b31758ecaf5384e82f258d6c7fad27feca411b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/22b31758ecaf5384e82f258d6c7fad27feca411b", "html_url": "https://github.com/rust-lang/rust/commit/22b31758ecaf5384e82f258d6c7fad27feca411b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/22b31758ecaf5384e82f258d6c7fad27feca411b/comments", "author": {"login": "zackmdavis", "id": 1076988, "node_id": "MDQ6VXNlcjEwNzY5ODg=", "avatar_url": "https://avatars.githubusercontent.com/u/1076988?v=4", "gravatar_id": "", "url": "https://api.github.com/users/zackmdavis", "html_url": "https://github.com/zackmdavis", "followers_url": "https://api.github.com/users/zackmdavis/followers", "following_url": "https://api.github.com/users/zackmdavis/following{/other_user}", "gists_url": "https://api.github.com/users/zackmdavis/gists{/gist_id}", "starred_url": "https://api.github.com/users/zackmdavis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/zackmdavis/subscriptions", "organizations_url": "https://api.github.com/users/zackmdavis/orgs", "repos_url": "https://api.github.com/users/zackmdavis/repos", "events_url": "https://api.github.com/users/zackmdavis/events{/privacy}", "received_events_url": "https://api.github.com/users/zackmdavis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a9cb25b23aace3e8a7db3e64468dd84314a6d867", "url": "https://api.github.com/repos/rust-lang/rust/commits/a9cb25b23aace3e8a7db3e64468dd84314a6d867", "html_url": "https://github.com/rust-lang/rust/commit/a9cb25b23aace3e8a7db3e64468dd84314a6d867"}], "stats": {"total": 338, "additions": 184, "deletions": 154}, "files": [{"sha": "f0d425f3f1766ea50f7ec78c5f72d276ad555b1d", "filename": "src/librustc_mir/borrow_check/nll/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/22b31758ecaf5384e82f258d6c7fad27feca411b/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22b31758ecaf5384e82f258d6c7fad27feca411b/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs?ref=22b31758ecaf5384e82f258d6c7fad27feca411b", "patch": "@@ -160,7 +160,7 @@ fn dump_mir_results<'a, 'gcx, 'tcx>(\n         match pass_where {\n             // Before the CFG, dump out the values for each region variable.\n             PassWhere::BeforeCFG => for region in regioncx.regions() {\n-                writeln!(out, \"| {:?}: {:?}\", region, regioncx.region_value(region))?;\n+                writeln!(out, \"| {:?}: {}\", region, regioncx.region_value_str(region))?;\n             },\n \n             // Before each basic block, dump out the values"}, {"sha": "aac341380a00a14a3ab03835ef4116ec8cea1850", "filename": "src/librustc_mir/borrow_check/nll/region_infer.rs", "status": "modified", "additions": 183, "deletions": 153, "changes": 336, "blob_url": "https://github.com/rust-lang/rust/blob/22b31758ecaf5384e82f258d6c7fad27feca411b/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22b31758ecaf5384e82f258d6c7fad27feca411b/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer.rs?ref=22b31758ecaf5384e82f258d6c7fad27feca411b", "patch": "@@ -18,7 +18,9 @@ use rustc::mir::{Location, Mir};\n use rustc::ty::{self, RegionVid};\n use rustc_data_structures::indexed_vec::IndexVec;\n use rustc_data_structures::fx::FxHashSet;\n-use std::collections::BTreeSet;\n+use rustc_data_structures::bitvec::BitMatrix;\n+use rustc_data_structures::indexed_vec::Idx;\n+use std::collections::BTreeMap;\n use std::fmt;\n use syntax_pos::Span;\n \n@@ -33,15 +35,25 @@ pub struct RegionInferenceContext<'tcx> {\n     /// regions, these start out empty and steadily grow, though for\n     /// each free region R they start out containing the entire CFG\n     /// and `end(R)`.\n-    liveness_constraints: IndexVec<RegionVid, Region>,\n+    ///\n+    /// In this `BitMatrix` representation, the rows are the region\n+    /// variables and the columns are the free regions and MIR locations.\n+    liveness_constraints: BitMatrix,\n \n     /// The final inferred values of the inference variables; `None`\n     /// until `solve` is invoked.\n-    inferred_values: Option<IndexVec<RegionVid, Region>>,\n+    inferred_values: Option<BitMatrix>,\n \n     /// The constraints we have accumulated and used during solving.\n     constraints: Vec<Constraint>,\n \n+    /// A map from each MIR Location to its column index in\n+    /// `liveness_constraints`/`inferred_values`. (The first N columns are\n+    /// the free regions.)\n+    point_indices: BTreeMap<Location, usize>,\n+\n+    num_free_regions: usize,\n+\n     free_region_map: &'tcx FreeRegionMap<'tcx>,\n }\n \n@@ -57,42 +69,6 @@ struct RegionDefinition<'tcx> {\n     name: Option<ty::Region<'tcx>>,\n }\n \n-/// The value of an individual region variable. Region variables\n-/// consist of a set of points in the CFG as well as a set of \"free\n-/// regions\", which are sometimes written as `end(R)`. These\n-/// correspond to the named lifetimes and refer to portions of the\n-/// caller's control-flow graph -- specifically some portion that can\n-/// be reached after we return.\n-#[derive(Clone, Default, PartialEq, Eq)]\n-struct Region {\n-    points: BTreeSet<Location>,\n-    free_regions: BTreeSet<RegionVid>,\n-}\n-\n-impl fmt::Debug for Region {\n-    fn fmt(&self, formatter: &mut fmt::Formatter) -> Result<(), fmt::Error> {\n-        formatter\n-            .debug_set()\n-            .entries(&self.points)\n-            .entries(&self.free_regions)\n-            .finish()\n-    }\n-}\n-\n-impl Region {\n-    fn add_point(&mut self, point: Location) -> bool {\n-        self.points.insert(point)\n-    }\n-\n-    fn add_free_region(&mut self, region: RegionVid) -> bool {\n-        self.free_regions.insert(region)\n-    }\n-\n-    fn contains_point(&self, point: Location) -> bool {\n-        self.points.contains(&point)\n-    }\n-}\n-\n #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]\n pub struct Constraint {\n     // NB. The ordering here is not significant for correctness, but\n@@ -119,6 +95,21 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// regions defined in `free_regions`.\n     pub fn new(var_origins: VarOrigins, free_regions: &FreeRegions<'tcx>, mir: &Mir<'tcx>) -> Self {\n         let num_region_variables = var_origins.len();\n+        let num_free_regions = free_regions.indices.len();\n+\n+        let mut num_points = 0;\n+        let mut point_indices = BTreeMap::new();\n+\n+        for (block, block_data) in mir.basic_blocks().iter_enumerated() {\n+            for statement_index in 0..block_data.statements.len() + 1 {\n+                let location = Location {\n+                    block,\n+                    statement_index,\n+                };\n+                point_indices.insert(location, num_free_regions + num_points);\n+                num_points += 1;\n+            }\n+        }\n \n         // Create a RegionDefinition for each inference variable.\n         let definitions = var_origins\n@@ -127,14 +118,19 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             .collect();\n \n         let mut result = Self {\n-            definitions: definitions,\n-            liveness_constraints: IndexVec::from_elem_n(Region::default(), num_region_variables),\n+            definitions,\n+            liveness_constraints: BitMatrix::new(\n+                num_region_variables,\n+                num_free_regions + num_points,\n+            ),\n             inferred_values: None,\n             constraints: Vec::new(),\n+            point_indices,\n+            num_free_regions,\n             free_region_map: free_regions.free_region_map,\n         };\n \n-        result.init_free_regions(free_regions, mir);\n+        result.init_free_regions(free_regions);\n \n         result\n     }\n@@ -158,7 +154,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// and (b) any free regions that it outlives, which in this case\n     /// is just itself. R1 (`'b`) in contrast also outlives `'a` and\n     /// hence contains R0 and R1.\n-    fn init_free_regions(&mut self, free_regions: &FreeRegions<'tcx>, mir: &Mir<'tcx>) {\n+    fn init_free_regions(&mut self, free_regions: &FreeRegions<'tcx>) {\n         let FreeRegions {\n             indices,\n             free_region_map: _,\n@@ -175,27 +171,15 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             // Initialize the name and a few other details.\n             self.definitions[variable].name = Some(free_region);\n \n-            // Add all nodes in the CFG to `definition.value`.\n-            for (block, block_data) in mir.basic_blocks().iter_enumerated() {\n-                let liveness_constraint = &mut self.liveness_constraints[variable];\n-                for statement_index in 0..block_data.statements.len() + 1 {\n-                    let location = Location {\n-                        block,\n-                        statement_index,\n-                    };\n-                    liveness_constraint.add_point(location);\n-                }\n+            // Add all nodes in the CFG to liveness constraints\n+            for (_location, point_index) in &self.point_indices {\n+                self.liveness_constraints\n+                    .add(variable.index(), *point_index);\n             }\n \n             // Add `end(X)` into the set for X.\n-            self.liveness_constraints[variable].add_free_region(variable);\n-\n-            debug!(\n-                \"init_free_regions: region variable for `{:?}` is `{:?}` with value `{:?}`\",\n-                free_region,\n-                variable,\n-                self.liveness_constraints[variable],\n-            );\n+            self.liveness_constraints\n+                .add(variable.index(), variable.index());\n         }\n     }\n \n@@ -206,27 +190,76 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n \n     /// Returns true if the region `r` contains the point `p`.\n     ///\n-    /// Until `solve()` executes, this value is not particularly meaningful.\n+    /// Panics if called before `solve()` executes,\n     pub fn region_contains_point(&self, r: RegionVid, p: Location) -> bool {\n         let inferred_values = self.inferred_values\n             .as_ref()\n             .expect(\"region values not yet inferred\");\n-        inferred_values[r].contains_point(p)\n+        self.region_contains_point_in_matrix(inferred_values, r, p)\n+    }\n+\n+    /// True if given region `r` contains the point `p`, when\n+    /// evaluated in the set of region values `matrix`.\n+    fn region_contains_point_in_matrix(\n+        &self,\n+        matrix: &BitMatrix,\n+        r: RegionVid,\n+        p: Location,\n+    ) -> bool {\n+        let point_index = self.point_indices\n+            .get(&p)\n+            .expect(\"point index should be known\");\n+        matrix.contains(r.index(), *point_index)\n+    }\n+\n+    /// True if given region `r` contains the `end(s)`, when\n+    /// evaluated in the set of region values `matrix`.\n+    fn region_contains_region_in_matrix(\n+        &self,\n+        matrix: &BitMatrix,\n+        r: RegionVid,\n+        s: RegionVid\n+    ) -> bool {\n+        matrix.contains(r.index(), s.index())\n     }\n \n     /// Returns access to the value of `r` for debugging purposes.\n-    pub(super) fn region_value(&self, r: RegionVid) -> &fmt::Debug {\n+    pub(super) fn region_value_str(&self, r: RegionVid) -> String {\n         let inferred_values = self.inferred_values\n             .as_ref()\n             .expect(\"region values not yet inferred\");\n-        &inferred_values[r]\n+\n+        let mut result = String::new();\n+        result.push_str(\"{\");\n+        let mut sep = \"\";\n+\n+        for &point in self.point_indices.keys() {\n+            if self.region_contains_point_in_matrix(inferred_values, r, point) {\n+                result.push_str(&format!(\"{}{:?}\", sep, point));\n+                sep = \", \";\n+            }\n+        }\n+\n+        for fr in (0 .. self.num_free_regions).map(RegionVid::new) {\n+            if self.region_contains_region_in_matrix(inferred_values, r, fr) {\n+                result.push_str(&format!(\"{}{:?}\", sep, fr));\n+                sep = \", \";\n+            }\n+        }\n+\n+        result.push_str(\"}\");\n+\n+        result\n     }\n \n     /// Indicates that the region variable `v` is live at the point `point`.\n-    pub(super) fn add_live_point(&mut self, v: RegionVid, point: Location) {\n+    pub(super) fn add_live_point(&mut self, v: RegionVid, point: Location) -> bool {\n         debug!(\"add_live_point({:?}, {:?})\", v, point);\n         assert!(self.inferred_values.is_none(), \"values already inferred\");\n-        self.liveness_constraints[v].add_point(point);\n+        let point_index = self.point_indices\n+            .get(&point)\n+            .expect(\"point index should be known\");\n+        self.liveness_constraints.add(v.index(), *point_index)\n     }\n \n     /// Indicates that the region variable `sup` must outlive `sub` is live at the point `point`.\n@@ -285,26 +318,26 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     ) {\n         let inferred_values = self.inferred_values.as_ref().unwrap();\n         let fr_name = fr_definition.name.unwrap();\n-        let fr_value = &inferred_values[fr];\n+        let fr_value = inferred_values.iter(fr.index());\n \n         // Find every region `o` such that `fr: o`\n         // (because `fr` includes `end(o)`).\n-        for &outlived_fr in &fr_value.free_regions {\n+        for outlived_fr in fr_value.take_while(|&i| i < self.num_free_regions) {\n             // `fr` includes `end(fr)`, that's not especially\n             // interesting.\n-            if fr == outlived_fr {\n+            if fr.index() == outlived_fr {\n                 continue;\n             }\n \n-            let outlived_fr_definition = &self.definitions[outlived_fr];\n+            let outlived_fr_definition = &self.definitions[RegionVid::new(outlived_fr)];\n             let outlived_fr_name = outlived_fr_definition.name.unwrap();\n \n             // Check that `o <= fr`. If not, report an error.\n             if !self.free_region_map\n                 .sub_free_regions(outlived_fr_name, fr_name)\n             {\n-                // worst error msg ever\n-                let blame_span = self.blame_span(fr, outlived_fr);\n+                // FIXME: worst error msg ever\n+                let blame_span = self.blame_span(fr, RegionVid::new(outlived_fr));\n                 infcx.tcx.sess.span_err(\n                     blame_span,\n                     &format!(\n@@ -323,7 +356,6 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// feasible, but we check this later.\n     fn propagate_constraints(&mut self, mir: &Mir<'tcx>) {\n         let mut changed = true;\n-        let mut dfs = Dfs::new(mir);\n \n         debug!(\"propagate_constraints()\");\n         debug!(\"propagate_constraints: constraints={:#?}\", {\n@@ -342,15 +374,18 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             for constraint in &self.constraints {\n                 debug!(\"propagate_constraints: constraint={:?}\", constraint);\n \n-                let sub = &inferred_values[constraint.sub].clone();\n-                let sup_value = &mut inferred_values[constraint.sup];\n-\n                 // Grow the value as needed to accommodate the\n                 // outlives constraint.\n \n-                if dfs.copy(sub, sup_value, constraint.point) {\n-                    debug!(\"propagate_constraints:   sub={:?}\", sub);\n-                    debug!(\"propagate_constraints:   sup={:?}\", sup_value);\n+                if self.copy(\n+                    &mut inferred_values,\n+                    mir,\n+                    constraint.sub,\n+                    constraint.sup,\n+                    constraint.point,\n+                ) {\n+                    debug!(\"propagate_constraints:   sub={:?}\", constraint.sub);\n+                    debug!(\"propagate_constraints:   sup={:?}\", constraint.sup);\n                     changed = true;\n                 }\n             }\n@@ -360,72 +395,12 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         self.inferred_values = Some(inferred_values);\n     }\n \n-    /// Tries to finds a good span to blame for the fact that `fr1`\n-    /// contains `fr2`.\n-    fn blame_span(&self, fr1: RegionVid, fr2: RegionVid) -> Span {\n-        // Find everything that influenced final value of `fr`.\n-        let influenced_fr1 = self.dependencies(fr1);\n-\n-        // Try to find some outlives constraint `'X: fr2` where `'X`\n-        // influenced `fr1`. Blame that.\n-        //\n-        // NB, this is a pretty bad choice most of the time. In\n-        // particular, the connection between `'X` and `fr1` may not\n-        // be obvious to the user -- not to mention the naive notion\n-        // of dependencies, which doesn't account for the locations of\n-        // contraints at all. But it will do for now.\n-        for constraint in &self.constraints {\n-            if constraint.sub == fr2 && influenced_fr1[constraint.sup] {\n-                return constraint.span;\n-            }\n-        }\n-\n-        bug!(\n-            \"could not find any constraint to blame for {:?}: {:?}\",\n-            fr1,\n-            fr2\n-        );\n-    }\n-\n-    /// Finds all regions whose values `'a` may depend on in some way.\n-    /// Basically if there exists a constraint `'a: 'b @ P`, then `'b`\n-    /// and `dependencies('b)` will be in the final set.\n-    ///\n-    /// Used during error reporting, extremely naive and inefficient.\n-    fn dependencies(&self, r0: RegionVid) -> IndexVec<RegionVid, bool> {\n-        let mut result_set = IndexVec::from_elem(false, &self.definitions);\n-        let mut changed = true;\n-        result_set[r0] = true;\n-\n-        while changed {\n-            changed = false;\n-            for constraint in &self.constraints {\n-                if result_set[constraint.sup] {\n-                    if !result_set[constraint.sub] {\n-                        result_set[constraint.sub] = true;\n-                        changed = true;\n-                    }\n-                }\n-            }\n-        }\n-\n-        result_set\n-    }\n-}\n-\n-struct Dfs<'a, 'tcx: 'a> {\n-    mir: &'a Mir<'tcx>,\n-}\n-\n-impl<'a, 'tcx> Dfs<'a, 'tcx> {\n-    fn new(mir: &'a Mir<'tcx>) -> Self {\n-        Self { mir }\n-    }\n-\n     fn copy(\n-        &mut self,\n-        from_region: &Region,\n-        to_region: &mut Region,\n+        &self,\n+        inferred_values: &mut BitMatrix,\n+        mir: &Mir<'tcx>,\n+        from_region: RegionVid,\n+        to_region: RegionVid,\n         start_point: Location,\n     ) -> bool {\n         let mut changed = false;\n@@ -435,9 +410,9 @@ impl<'a, 'tcx> Dfs<'a, 'tcx> {\n \n         stack.push(start_point);\n         while let Some(p) = stack.pop() {\n-            debug!(\"        dfs: p={:?}\", p);\n+            debug!(\"        copy: p={:?}\", p);\n \n-            if !from_region.contains_point(p) {\n+            if !self.region_contains_point_in_matrix(inferred_values, from_region, p) {\n                 debug!(\"            not in from-region\");\n                 continue;\n             }\n@@ -447,9 +422,10 @@ impl<'a, 'tcx> Dfs<'a, 'tcx> {\n                 continue;\n             }\n \n-            changed |= to_region.add_point(p);\n+            let point_index = self.point_indices.get(&p).unwrap();\n+            changed |= inferred_values.add(to_region.index(), *point_index);\n \n-            let block_data = &self.mir[p.block];\n+            let block_data = &mir[p.block];\n             let successor_points = if p.statement_index < block_data.statements.len() {\n                 vec![\n                     Location {\n@@ -475,10 +451,12 @@ impl<'a, 'tcx> Dfs<'a, 'tcx> {\n                 // If we reach the END point in the graph, then copy\n                 // over any skolemized end points in the `from_region`\n                 // and make sure they are included in the `to_region`.\n-\n-                debug!(\"        dfs: free_regions={:?}\", from_region.free_regions);\n-                for &fr in &from_region.free_regions {\n-                    changed |= to_region.free_regions.insert(fr);\n+                let free_region_indices = inferred_values\n+                    .iter(from_region.index())\n+                    .take_while(|&i| i < self.num_free_regions)\n+                    .collect::<Vec<_>>();\n+                for fr in &free_region_indices {\n+                    changed |= inferred_values.add(to_region.index(), *fr);\n                 }\n             } else {\n                 stack.extend(successor_points);\n@@ -487,6 +465,58 @@ impl<'a, 'tcx> Dfs<'a, 'tcx> {\n \n         changed\n     }\n+\n+    /// Tries to finds a good span to blame for the fact that `fr1`\n+    /// contains `fr2`.\n+    fn blame_span(&self, fr1: RegionVid, fr2: RegionVid) -> Span {\n+        // Find everything that influenced final value of `fr`.\n+        let influenced_fr1 = self.dependencies(fr1);\n+\n+        // Try to find some outlives constraint `'X: fr2` where `'X`\n+        // influenced `fr1`. Blame that.\n+        //\n+        // NB, this is a pretty bad choice most of the time. In\n+        // particular, the connection between `'X` and `fr1` may not\n+        // be obvious to the user -- not to mention the naive notion\n+        // of dependencies, which doesn't account for the locations of\n+        // contraints at all. But it will do for now.\n+        for constraint in &self.constraints {\n+            if constraint.sub == fr2 && influenced_fr1[constraint.sup] {\n+                return constraint.span;\n+            }\n+        }\n+\n+        bug!(\n+            \"could not find any constraint to blame for {:?}: {:?}\",\n+            fr1,\n+            fr2\n+        );\n+    }\n+\n+    /// Finds all regions whose values `'a` may depend on in some way.\n+    /// Basically if there exists a constraint `'a: 'b @ P`, then `'b`\n+    /// and `dependencies('b)` will be in the final set.\n+    ///\n+    /// Used during error reporting, extremely naive and inefficient.\n+    fn dependencies(&self, r0: RegionVid) -> IndexVec<RegionVid, bool> {\n+        let mut result_set = IndexVec::from_elem(false, &self.definitions);\n+        let mut changed = true;\n+        result_set[r0] = true;\n+\n+        while changed {\n+            changed = false;\n+            for constraint in &self.constraints {\n+                if result_set[constraint.sup] {\n+                    if !result_set[constraint.sub] {\n+                        result_set[constraint.sub] = true;\n+                        changed = true;\n+                    }\n+                }\n+            }\n+        }\n+\n+        result_set\n+    }\n }\n \n impl<'tcx> RegionDefinition<'tcx> {"}]}