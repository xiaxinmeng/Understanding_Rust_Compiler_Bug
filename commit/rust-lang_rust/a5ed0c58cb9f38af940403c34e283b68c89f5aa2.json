{"sha": "a5ed0c58cb9f38af940403c34e283b68c89f5aa2", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE1ZWQwYzU4Y2I5ZjM4YWY5NDA0MDNjMzRlMjgzYjY4Yzg5ZjVhYTI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-01-16T01:46:42Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-01-16T01:46:42Z"}, "message": "auto merge of #11565 : mozilla/rust/snapshot, r=huonw", "tree": {"sha": "a8be28b83687b5a2fabc870c65a3a49b66b4bd95", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a8be28b83687b5a2fabc870c65a3a49b66b4bd95"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a5ed0c58cb9f38af940403c34e283b68c89f5aa2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a5ed0c58cb9f38af940403c34e283b68c89f5aa2", "html_url": "https://github.com/rust-lang/rust/commit/a5ed0c58cb9f38af940403c34e283b68c89f5aa2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a5ed0c58cb9f38af940403c34e283b68c89f5aa2/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "36971217aa64b6fc5f543f2620e488d16e67b1f4", "url": "https://api.github.com/repos/rust-lang/rust/commits/36971217aa64b6fc5f543f2620e488d16e67b1f4", "html_url": "https://github.com/rust-lang/rust/commit/36971217aa64b6fc5f543f2620e488d16e67b1f4"}, {"sha": "29840addd46b6ae01b61ee93247164d5818f09e0", "url": "https://api.github.com/repos/rust-lang/rust/commits/29840addd46b6ae01b61ee93247164d5818f09e0", "html_url": "https://github.com/rust-lang/rust/commit/29840addd46b6ae01b61ee93247164d5818f09e0"}], "stats": {"total": 302, "additions": 25, "deletions": 277}, "files": [{"sha": "584314ca04a90ce19c995f6b7c39d1de089f11f1", "filename": "src/libnative/lib.rs", "status": "modified", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/a5ed0c58cb9f38af940403c34e283b68c89f5aa2/src%2Flibnative%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5ed0c58cb9f38af940403c34e283b68c89f5aa2/src%2Flibnative%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Flib.rs?ref=a5ed0c58cb9f38af940403c34e283b68c89f5aa2", "patch": "@@ -39,30 +39,6 @@ static OS_DEFAULT_STACK_ESTIMATE: uint = 1 << 20;\n #[cfg(unix, not(android))]\n static OS_DEFAULT_STACK_ESTIMATE: uint = 2 * (1 << 20);\n \n-\n-// XXX: this should not exist here\n-#[cfg(stage0, nativestart)]\n-#[lang = \"start\"]\n-pub fn lang_start(main: *u8, argc: int, argv: **u8) -> int {\n-    use std::cast;\n-    use std::task;\n-\n-    do start(argc, argv) {\n-        // Instead of invoking main directly on this thread, invoke it on\n-        // another spawned thread that we are guaranteed to know the size of the\n-        // stack of. Currently, we do not have a method of figuring out the size\n-        // of the main thread's stack, so for stack overflow detection to work\n-        // we must spawn the task in a subtask which we know the stack size of.\n-        let main: extern \"Rust\" fn() = unsafe { cast::transmute(main) };\n-        let mut task = task::task();\n-        task.name(\"<main>\");\n-        match do task.try { main() } {\n-            Ok(()) => { os::set_exit_status(0); }\n-            Err(..) => { os::set_exit_status(rt::DEFAULT_ERROR_CODE); }\n-        }\n-    }\n-}\n-\n /// Executes the given procedure after initializing the runtime with the given\n /// argc/argv.\n ///"}, {"sha": "ab374ebccfeccb25f9ff43e65c9a1d49a02a8ad3", "filename": "src/libstd/cleanup.rs", "status": "modified", "additions": 16, "deletions": 28, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/a5ed0c58cb9f38af940403c34e283b68c89f5aa2/src%2Flibstd%2Fcleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5ed0c58cb9f38af940403c34e283b68c89f5aa2/src%2Flibstd%2Fcleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcleanup.rs?ref=a5ed0c58cb9f38af940403c34e283b68c89f5aa2", "patch": "@@ -17,6 +17,8 @@ use unstable::raw;\n \n type DropGlue<'a> = 'a |**TyDesc, *c_void|;\n \n+static RC_IMMORTAL : uint = 0x77777777;\n+\n /*\n  * Box annihilation\n  *\n@@ -25,24 +27,21 @@ type DropGlue<'a> = 'a |**TyDesc, *c_void|;\n \n struct AnnihilateStats {\n     n_total_boxes: uint,\n-    n_unique_boxes: uint,\n     n_bytes_freed: uint\n }\n \n unsafe fn each_live_alloc(read_next_before: bool,\n-                          f: |alloc: *mut raw::Box<()>, uniq: bool| -> bool)\n+                          f: |alloc: *mut raw::Box<()>| -> bool)\n                           -> bool {\n     //! Walks the internal list of allocations\n \n-    use managed;\n     use rt::local_heap;\n \n     let mut alloc = local_heap::live_allocs();\n     while alloc != ptr::mut_null() {\n         let next_before = (*alloc).next;\n-        let uniq = (*alloc).ref_count == managed::RC_MANAGED_UNIQUE;\n \n-        if !f(alloc, uniq) {\n+        if !f(alloc) {\n             return false;\n         }\n \n@@ -70,25 +69,19 @@ fn debug_mem() -> bool {\n pub unsafe fn annihilate() {\n     use rt::local_heap::local_free;\n     use mem;\n-    use managed;\n \n     let mut stats = AnnihilateStats {\n         n_total_boxes: 0,\n-        n_unique_boxes: 0,\n         n_bytes_freed: 0\n     };\n \n     // Pass 1: Make all boxes immortal.\n     //\n     // In this pass, nothing gets freed, so it does not matter whether\n     // we read the next field before or after the callback.\n-    each_live_alloc(true, |alloc, uniq| {\n+    each_live_alloc(true, |alloc| {\n         stats.n_total_boxes += 1;\n-        if uniq {\n-            stats.n_unique_boxes += 1;\n-        } else {\n-            (*alloc).ref_count = managed::RC_IMMORTAL;\n-        }\n+        (*alloc).ref_count = RC_IMMORTAL;\n         true\n     });\n \n@@ -97,12 +90,10 @@ pub unsafe fn annihilate() {\n     // In this pass, unique-managed boxes may get freed, but not\n     // managed boxes, so we must read the `next` field *after* the\n     // callback, as the original value may have been freed.\n-    each_live_alloc(false, |alloc, uniq| {\n-        if !uniq {\n-            let tydesc = (*alloc).type_desc;\n-            let data = &(*alloc).data as *();\n-            ((*tydesc).drop_glue)(data as *i8);\n-        }\n+    each_live_alloc(false, |alloc| {\n+        let tydesc = (*alloc).type_desc;\n+        let data = &(*alloc).data as *();\n+        ((*tydesc).drop_glue)(data as *i8);\n         true\n     });\n \n@@ -112,22 +103,19 @@ pub unsafe fn annihilate() {\n     // unique-managed boxes, though I think that none of those are\n     // left), so we must read the `next` field before, since it will\n     // not be valid after.\n-    each_live_alloc(true, |alloc, uniq| {\n-        if !uniq {\n-            stats.n_bytes_freed +=\n-                (*((*alloc).type_desc)).size\n-                + mem::size_of::<raw::Box<()>>();\n-            local_free(alloc as *i8);\n-        }\n+    each_live_alloc(true, |alloc| {\n+        stats.n_bytes_freed +=\n+            (*((*alloc).type_desc)).size\n+            + mem::size_of::<raw::Box<()>>();\n+        local_free(alloc as *i8);\n         true\n     });\n \n     if debug_mem() {\n         // We do logging here w/o allocation.\n         debug!(\"annihilator stats:\\n  \\\n                        total boxes: {}\\n  \\\n-                      unique boxes: {}\\n  \\\n                        bytes freed: {}\",\n-                stats.n_total_boxes, stats.n_unique_boxes, stats.n_bytes_freed);\n+                stats.n_total_boxes, stats.n_bytes_freed);\n     }\n }"}, {"sha": "914cc25250c7f6a5ab087b7d53ce8c430a738541", "filename": "src/libstd/managed.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a5ed0c58cb9f38af940403c34e283b68c89f5aa2/src%2Flibstd%2Fmanaged.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5ed0c58cb9f38af940403c34e283b68c89f5aa2/src%2Flibstd%2Fmanaged.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmanaged.rs?ref=a5ed0c58cb9f38af940403c34e283b68c89f5aa2", "patch": "@@ -14,9 +14,6 @@ use ptr::to_unsafe_ptr;\n \n #[cfg(not(test))] use cmp::*;\n \n-pub static RC_MANAGED_UNIQUE : uint = (-2) as uint;\n-pub static RC_IMMORTAL : uint = 0x77777777;\n-\n /// Returns the refcount of a shared box (as just before calling this)\n #[inline]\n pub fn refcount<T>(t: @T) -> uint {"}, {"sha": "e619e404dac86050c5128fd8ddbf5aaba7253c98", "filename": "src/libstd/reflect.rs", "status": "modified", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a5ed0c58cb9f38af940403c34e283b68c89f5aa2/src%2Flibstd%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5ed0c58cb9f38af940403c34e283b68c89f5aa2/src%2Flibstd%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Freflect.rs?ref=a5ed0c58cb9f38af940403c34e283b68c89f5aa2", "patch": "@@ -227,14 +227,6 @@ impl<V:TyVisitor + MovePtr> TyVisitor for MovePtrAdaptor<V> {\n         true\n     }\n \n-    #[cfg(stage0)]\n-    fn visit_uniq_managed(&mut self, mtbl: uint, inner: *TyDesc) -> bool {\n-        self.align_to::<~u8>();\n-        if ! self.inner.visit_uniq_managed(mtbl, inner) { return false; }\n-        self.bump_past::<~u8>();\n-        true\n-    }\n-\n     fn visit_ptr(&mut self, mtbl: uint, inner: *TyDesc) -> bool {\n         self.align_to::<*u8>();\n         if ! self.inner.visit_ptr(mtbl, inner) { return false; }\n@@ -276,14 +268,6 @@ impl<V:TyVisitor + MovePtr> TyVisitor for MovePtrAdaptor<V> {\n         true\n     }\n \n-    #[cfg(stage0)]\n-    fn visit_evec_uniq_managed(&mut self, mtbl: uint, inner: *TyDesc) -> bool {\n-        self.align_to::<~[@u8]>();\n-        if ! self.inner.visit_evec_uniq_managed(mtbl, inner) { return false; }\n-        self.bump_past::<~[@u8]>();\n-        true\n-    }\n-\n     fn visit_evec_slice(&mut self, mtbl: uint, inner: *TyDesc) -> bool {\n         self.align_to::<&'static [u8]>();\n         if ! self.inner.visit_evec_slice(mtbl, inner) { return false; }"}, {"sha": "641ac0f049da77d998bd064a21dbc64193339532", "filename": "src/libstd/repr.rs", "status": "modified", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/a5ed0c58cb9f38af940403c34e283b68c89f5aa2/src%2Flibstd%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5ed0c58cb9f38af940403c34e283b68c89f5aa2/src%2Flibstd%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frepr.rs?ref=a5ed0c58cb9f38af940403c34e283b68c89f5aa2", "patch": "@@ -310,15 +310,6 @@ impl<'a> TyVisitor for ReprVisitor<'a> {\n         })\n     }\n \n-    #[cfg(stage0)]\n-    fn visit_uniq_managed(&mut self, _mtbl: uint, inner: *TyDesc) -> bool {\n-        self.writer.write(['~' as u8]);\n-        self.get::<&raw::Box<()>>(|this, b| {\n-            let p = ptr::to_unsafe_ptr(&b.data) as *c_void;\n-            this.visit_ptr_inner(p, inner);\n-        })\n-    }\n-\n     fn visit_ptr(&mut self, mtbl: uint, _inner: *TyDesc) -> bool {\n         self.get::<*c_void>(|this, p| {\n             write!(this.writer, \"({} as *\", *p);\n@@ -359,14 +350,6 @@ impl<'a> TyVisitor for ReprVisitor<'a> {\n         })\n     }\n \n-    #[cfg(stage0)]\n-    fn visit_evec_uniq_managed(&mut self, mtbl: uint, inner: *TyDesc) -> bool {\n-        self.get::<&raw::Box<raw::Vec<()>>>(|this, b| {\n-            this.writer.write(['~' as u8]);\n-            this.write_unboxed_vec_repr(mtbl, &b.data, inner);\n-        })\n-    }\n-\n     fn visit_evec_slice(&mut self, mtbl: uint, inner: *TyDesc) -> bool {\n         self.get::<raw::Slice<()>>(|this, s| {\n             this.writer.write(['&' as u8]);"}, {"sha": "2649ca897e5646b2f8ad42979f8c51d15b594313", "filename": "src/libstd/unstable/intrinsics.rs", "status": "modified", "additions": 1, "deletions": 38, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/a5ed0c58cb9f38af940403c34e283b68c89f5aa2/src%2Flibstd%2Funstable%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5ed0c58cb9f38af940403c34e283b68c89f5aa2/src%2Flibstd%2Funstable%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fintrinsics.rs?ref=a5ed0c58cb9f38af940403c34e283b68c89f5aa2", "patch": "@@ -47,41 +47,8 @@ pub use realstd::unstable::intrinsics::{TyDesc, Opaque, TyVisitor, TypeId};\n \n pub type GlueFn = extern \"Rust\" fn(*i8);\n \n-// NOTE remove after next snapshot\n #[lang=\"ty_desc\"]\n-#[cfg(not(test), stage0)]\n-pub struct TyDesc {\n-    // sizeof(T)\n-    size: uint,\n-\n-    // alignof(T)\n-    align: uint,\n-\n-    // Called on a copy of a value of type `T` *after* memcpy\n-    take_glue: GlueFn,\n-\n-    // Called when a value of type `T` is no longer needed\n-    drop_glue: GlueFn,\n-\n-    // Called by drop glue when a value of type `T` can be freed\n-    free_glue: GlueFn,\n-\n-    // Called by reflection visitor to visit a value of type `T`\n-    visit_glue: GlueFn,\n-\n-    // If T represents a box pointer (`@U` or `~U`), then\n-    // `borrow_offset` is the amount that the pointer must be adjusted\n-    // to find the payload.  This is always derivable from the type\n-    // `U`, but in the case of `@Trait` or `~Trait` objects, the type\n-    // `U` is unknown.\n-    borrow_offset: uint,\n-\n-    // Name corresponding to the type\n-    name: &'static str\n-}\n-\n-#[lang=\"ty_desc\"]\n-#[cfg(not(test), not(stage0))]\n+#[cfg(not(test))]\n pub struct TyDesc {\n     // sizeof(T)\n     size: uint,\n@@ -139,17 +106,13 @@ pub trait TyVisitor {\n \n     fn visit_box(&mut self, mtbl: uint, inner: *TyDesc) -> bool;\n     fn visit_uniq(&mut self, mtbl: uint, inner: *TyDesc) -> bool;\n-    #[cfg(stage0)]\n-    fn visit_uniq_managed(&mut self, mtbl: uint, inner: *TyDesc) -> bool;\n     fn visit_ptr(&mut self, mtbl: uint, inner: *TyDesc) -> bool;\n     fn visit_rptr(&mut self, mtbl: uint, inner: *TyDesc) -> bool;\n \n     fn visit_vec(&mut self, mtbl: uint, inner: *TyDesc) -> bool;\n     fn visit_unboxed_vec(&mut self, mtbl: uint, inner: *TyDesc) -> bool;\n     fn visit_evec_box(&mut self, mtbl: uint, inner: *TyDesc) -> bool;\n     fn visit_evec_uniq(&mut self, mtbl: uint, inner: *TyDesc) -> bool;\n-    #[cfg(stage0)]\n-    fn visit_evec_uniq_managed(&mut self, mtbl: uint, inner: *TyDesc) -> bool;\n     fn visit_evec_slice(&mut self, mtbl: uint, inner: *TyDesc) -> bool;\n     fn visit_evec_fixed(&mut self, n: uint, sz: uint, align: uint,\n                         mtbl: uint, inner: *TyDesc) -> bool;"}, {"sha": "20684bf4c49b918f3d2306437107317551f13085", "filename": "src/libstd/vec.rs", "status": "modified", "additions": 0, "deletions": 144, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/a5ed0c58cb9f38af940403c34e283b68c89f5aa2/src%2Flibstd%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5ed0c58cb9f38af940403c34e283b68c89f5aa2/src%2Flibstd%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fvec.rs?ref=a5ed0c58cb9f38af940403c34e283b68c89f5aa2", "patch": "@@ -116,18 +116,12 @@ use ptr::to_unsafe_ptr;\n use ptr;\n use ptr::RawPtr;\n use rt::global_heap::{malloc_raw, realloc_raw, exchange_free};\n-#[cfg(stage0)]\n-use rt::local_heap::local_free;\n use mem;\n use mem::size_of;\n use uint;\n use unstable::finally::Finally;\n use unstable::intrinsics;\n-#[cfg(stage0)]\n-use unstable::intrinsics::{get_tydesc, owns_managed};\n use unstable::raw::{Repr, Slice, Vec};\n-#[cfg(stage0)]\n-use unstable::raw::Box;\n use util;\n \n /**\n@@ -182,30 +176,6 @@ pub fn from_elem<T:Clone>(n_elts: uint, t: T) -> ~[T] {\n \n /// Creates a new vector with a capacity of `capacity`\n #[inline]\n-#[cfg(stage0)]\n-pub fn with_capacity<T>(capacity: uint) -> ~[T] {\n-    unsafe {\n-        if owns_managed::<T>() {\n-            let mut vec = ~[];\n-            vec.reserve(capacity);\n-            vec\n-        } else {\n-            let alloc = capacity * mem::nonzero_size_of::<T>();\n-            let size = alloc + mem::size_of::<Vec<()>>();\n-            if alloc / mem::nonzero_size_of::<T>() != capacity || size < alloc {\n-                fail!(\"vector size is too large: {}\", capacity);\n-            }\n-            let ptr = malloc_raw(size) as *mut Vec<()>;\n-            (*ptr).alloc = alloc;\n-            (*ptr).fill = 0;\n-            cast::transmute(ptr)\n-        }\n-    }\n-}\n-\n-/// Creates a new vector with a capacity of `capacity`\n-#[inline]\n-#[cfg(not(stage0))]\n pub fn with_capacity<T>(capacity: uint) -> ~[T] {\n     unsafe {\n         let alloc = capacity * mem::nonzero_size_of::<T>();\n@@ -1503,31 +1473,6 @@ impl<T> OwnedVector<T> for ~[T] {\n         self.move_iter().invert()\n     }\n \n-    #[cfg(stage0)]\n-    fn reserve(&mut self, n: uint) {\n-        // Only make the (slow) call into the runtime if we have to\n-        if self.capacity() < n {\n-            unsafe {\n-                let td = get_tydesc::<T>();\n-                if owns_managed::<T>() {\n-                    let ptr: *mut *mut Box<Vec<()>> = cast::transmute(self);\n-                    ::at_vec::raw::reserve_raw(td, ptr, n);\n-                } else {\n-                    let ptr: *mut *mut Vec<()> = cast::transmute(self);\n-                    let alloc = n * mem::nonzero_size_of::<T>();\n-                    let size = alloc + mem::size_of::<Vec<()>>();\n-                    if alloc / mem::nonzero_size_of::<T>() != n || size < alloc {\n-                        fail!(\"vector size is too large: {}\", n);\n-                    }\n-                    *ptr = realloc_raw(*ptr as *mut c_void, size)\n-                           as *mut Vec<()>;\n-                    (**ptr).alloc = alloc;\n-                }\n-            }\n-        }\n-    }\n-\n-    #[cfg(not(stage0))]\n     fn reserve(&mut self, n: uint) {\n         // Only make the (slow) call into the runtime if we have to\n         if self.capacity() < n {\n@@ -1561,21 +1506,6 @@ impl<T> OwnedVector<T> for ~[T] {\n     }\n \n     #[inline]\n-    #[cfg(stage0)]\n-    fn capacity(&self) -> uint {\n-        unsafe {\n-            if owns_managed::<T>() {\n-                let repr: **Box<Vec<()>> = cast::transmute(self);\n-                (**repr).data.alloc / mem::nonzero_size_of::<T>()\n-            } else {\n-                let repr: **Vec<()> = cast::transmute(self);\n-                (**repr).alloc / mem::nonzero_size_of::<T>()\n-            }\n-        }\n-    }\n-\n-    #[inline]\n-    #[cfg(not(stage0))]\n     fn capacity(&self) -> uint {\n         unsafe {\n             let repr: **Vec<()> = cast::transmute(self);\n@@ -1594,51 +1524,6 @@ impl<T> OwnedVector<T> for ~[T] {\n     }\n \n     #[inline]\n-    #[cfg(stage0)]\n-    fn push(&mut self, t: T) {\n-        unsafe {\n-            if owns_managed::<T>() {\n-                let repr: **Box<Vec<()>> = cast::transmute(&mut *self);\n-                let fill = (**repr).data.fill;\n-                if (**repr).data.alloc <= fill {\n-                    self.reserve_additional(1);\n-                }\n-\n-                push_fast(self, t);\n-            } else {\n-                let repr: **Vec<()> = cast::transmute(&mut *self);\n-                let fill = (**repr).fill;\n-                if (**repr).alloc <= fill {\n-                    self.reserve_additional(1);\n-                }\n-\n-                push_fast(self, t);\n-            }\n-        }\n-\n-        // This doesn't bother to make sure we have space.\n-        #[inline] // really pretty please\n-        unsafe fn push_fast<T>(this: &mut ~[T], t: T) {\n-            if owns_managed::<T>() {\n-                let repr: **mut Box<Vec<u8>> = cast::transmute(this);\n-                let fill = (**repr).data.fill;\n-                (**repr).data.fill += mem::nonzero_size_of::<T>();\n-                let p = to_unsafe_ptr(&((**repr).data.data));\n-                let p = ptr::offset(p, fill as int) as *mut T;\n-                intrinsics::move_val_init(&mut(*p), t);\n-            } else {\n-                let repr: **mut Vec<u8> = cast::transmute(this);\n-                let fill = (**repr).fill;\n-                (**repr).fill += mem::nonzero_size_of::<T>();\n-                let p = to_unsafe_ptr(&((**repr).data));\n-                let p = ptr::offset(p, fill as int) as *mut T;\n-                intrinsics::move_val_init(&mut(*p), t);\n-            }\n-        }\n-    }\n-\n-    #[inline]\n-    #[cfg(not(stage0))]\n     fn push(&mut self, t: T) {\n         unsafe {\n             let repr: **Vec<()> = cast::transmute(&mut *self);\n@@ -1821,20 +1706,8 @@ impl<T> OwnedVector<T> for ~[T] {\n             i += 1u;\n         }\n     }\n-    #[inline]\n-    #[cfg(stage0)]\n-    unsafe fn set_len(&mut self, new_len: uint) {\n-        if owns_managed::<T>() {\n-            let repr: **mut Box<Vec<()>> = cast::transmute(self);\n-            (**repr).data.fill = new_len * mem::nonzero_size_of::<T>();\n-        } else {\n-            let repr: **mut Vec<()> = cast::transmute(self);\n-            (**repr).fill = new_len * mem::nonzero_size_of::<T>();\n-        }\n-    }\n \n     #[inline]\n-    #[cfg(not(stage0))]\n     unsafe fn set_len(&mut self, new_len: uint) {\n         let repr: **mut Vec<()> = cast::transmute(self);\n         (**repr).fill = new_len * mem::nonzero_size_of::<T>();\n@@ -3010,23 +2883,6 @@ impl<T> DoubleEndedIterator<T> for MoveIterator<T> {\n }\n \n #[unsafe_destructor]\n-#[cfg(stage0)]\n-impl<T> Drop for MoveIterator<T> {\n-    fn drop(&mut self) {\n-        // destroy the remaining elements\n-        for _x in *self {}\n-        unsafe {\n-            if owns_managed::<T>() {\n-                local_free(self.allocation as *u8 as *c_char)\n-            } else {\n-                exchange_free(self.allocation as *u8 as *c_char)\n-            }\n-        }\n-    }\n-}\n-\n-#[unsafe_destructor]\n-#[cfg(not(stage0))]\n impl<T> Drop for MoveIterator<T> {\n     fn drop(&mut self) {\n         // destroy the remaining elements"}, {"sha": "889a67333a0817602c8d68fc7182e8ec2d442617", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a5ed0c58cb9f38af940403c34e283b68c89f5aa2/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5ed0c58cb9f38af940403c34e283b68c89f5aa2/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=a5ed0c58cb9f38af940403c34e283b68c89f5aa2", "patch": "@@ -638,13 +638,6 @@ pub enum TokenTree {\n     TTNonterminal(Span, Ident)\n }\n \n-// NOTE remove after next snapshot\n-// Required for ext::quote macros.\n-#[cfg(stage0)]\n-pub fn tt_tok(span: Span, tok: ::parse::token::Token) -> TokenTree {\n-    TTTok(span, tok)\n-}\n-\n //\n // Matchers are nodes defined-by and recognized-by the main rust parser and\n // language, but they're only ever found inside syntax-extension invocations;"}, {"sha": "368b2a0fd38a737024d2e2a85f33fc65152e2b9f", "filename": "src/snapshots.txt", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a5ed0c58cb9f38af940403c34e283b68c89f5aa2/src%2Fsnapshots.txt", "raw_url": "https://github.com/rust-lang/rust/raw/a5ed0c58cb9f38af940403c34e283b68c89f5aa2/src%2Fsnapshots.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fsnapshots.txt?ref=a5ed0c58cb9f38af940403c34e283b68c89f5aa2", "patch": "@@ -1,3 +1,11 @@\n+S 2014-01-14 29070c3\n+  freebsd-x86_64 c2fb6e6313a9f1d41df810fcf1ae354858a8bf76\n+  linux-i386 6437656b81cf9f3d1377523c1e36d5cf06b2d645\n+  linux-x86_64 f3ca80c146f3a6495c19fc77dba13f9c0abece49\n+  macos-i386 3f1f9925fe1ddca94f2727194bd5763b0705016e\n+  macos-x86_64 0c10e160e3a754f2cdc89aea037c458fefe03d30\n+  winnt-i386 5cb277524157a8a883a8641b829f8aa6f53cdcf8\n+\n S 2014-01-08 f3a8baa\n   freebsd-x86_64 9f2491ebe48ff77774c73c111acdd951973d7e47\n   linux-i386 e2ba50e6a7d0cf6a7d65393f0c6416a2af58f8d4"}]}