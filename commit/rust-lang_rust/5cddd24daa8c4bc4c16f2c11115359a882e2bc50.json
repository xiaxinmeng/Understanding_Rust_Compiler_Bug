{"sha": "5cddd24daa8c4bc4c16f2c11115359a882e2bc50", "node_id": "C_kwDOAAsO6NoAKDVjZGRkMjRkYWE4YzRiYzRjMTZmMmMxMTExNTM1OWE4ODJlMmJjNTA", "commit": {"author": {"name": "Eric Huss", "email": "eric@huss.org", "date": "2022-01-08T04:20:58Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-01-08T04:20:58Z"}, "message": "Rollup merge of #92375 - wesleywiser:consolidate_debuginfo_msvc_check, r=michaelwoerister\n\nConsolidate checking for msvc when generating debuginfo\n\nIf the target we're generating code for is msvc, then we do two main\nthings differently: we generate type names in a C++ style instead of a\nRust style and we generate debuginfo for enums differently.\n\nI've refactored the code so that there is one function\n(`cpp_like_debuginfo`) which determines if we should use the C++ style\nof naming types and other debuginfo generation or the regular Rust one.\n\nr? ``@michaelwoerister``\n\nThis PR is not urgent so please don't let it interrupt your holidays! \ud83c\udf84 \ud83c\udf81", "tree": {"sha": "8aedb449769247175f8e34e8456ae5e5f1e71a17", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8aedb449769247175f8e34e8456ae5e5f1e71a17"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5cddd24daa8c4bc4c16f2c11115359a882e2bc50", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJh2REqCRBK7hj4Ov3rIwAAU+8IAFcpjTgL2hzqceEf0GnFITv3\n1OvThm9cVj7HIvdjcYq7ITPV30mdze6hMGh627qZZuClrkBA9e99TS6wUtQmFTQV\nmEKTDFch/RjEVZBAGfbmizMZ+3pteKqHeSIzrdwgnOzr2xzsAaPICNwMlAhk0zhT\njTr3nvIXPOEYEJFcHeKQ4w8kEukYguhTfFUXlW//opwqH5VpjWVNHWAAeei9PGdg\n25H611bgt97O3LRb/8tG6jEv/9l8VlxmV1YnCT1oQczZ+2Z3ERcEGi81emii1Hha\nCFkAZhqSRr1I8WeOr1IAk/8b+M5k4Rj9jrB2m5ypVsE7heRmpYDadHBa5XHOw4E=\n=oC48\n-----END PGP SIGNATURE-----\n", "payload": "tree 8aedb449769247175f8e34e8456ae5e5f1e71a17\nparent 81c515bf771ee872d9fc8871acfc797a5cae08fe\nparent 836addcbc4fa825e07c78c6feb7f6a0b776ed41a\nauthor Eric Huss <eric@huss.org> 1641615658 -0800\ncommitter GitHub <noreply@github.com> 1641615658 -0800\n\nRollup merge of #92375 - wesleywiser:consolidate_debuginfo_msvc_check, r=michaelwoerister\n\nConsolidate checking for msvc when generating debuginfo\n\nIf the target we're generating code for is msvc, then we do two main\nthings differently: we generate type names in a C++ style instead of a\nRust style and we generate debuginfo for enums differently.\n\nI've refactored the code so that there is one function\n(`cpp_like_debuginfo`) which determines if we should use the C++ style\nof naming types and other debuginfo generation or the regular Rust one.\n\nr? ``@michaelwoerister``\n\nThis PR is not urgent so please don't let it interrupt your holidays! \ud83c\udf84 \ud83c\udf81\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5cddd24daa8c4bc4c16f2c11115359a882e2bc50", "html_url": "https://github.com/rust-lang/rust/commit/5cddd24daa8c4bc4c16f2c11115359a882e2bc50", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5cddd24daa8c4bc4c16f2c11115359a882e2bc50/comments", "author": {"login": "ehuss", "id": 43198, "node_id": "MDQ6VXNlcjQzMTk4", "avatar_url": "https://avatars.githubusercontent.com/u/43198?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ehuss", "html_url": "https://github.com/ehuss", "followers_url": "https://api.github.com/users/ehuss/followers", "following_url": "https://api.github.com/users/ehuss/following{/other_user}", "gists_url": "https://api.github.com/users/ehuss/gists{/gist_id}", "starred_url": "https://api.github.com/users/ehuss/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ehuss/subscriptions", "organizations_url": "https://api.github.com/users/ehuss/orgs", "repos_url": "https://api.github.com/users/ehuss/repos", "events_url": "https://api.github.com/users/ehuss/events{/privacy}", "received_events_url": "https://api.github.com/users/ehuss/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "81c515bf771ee872d9fc8871acfc797a5cae08fe", "url": "https://api.github.com/repos/rust-lang/rust/commits/81c515bf771ee872d9fc8871acfc797a5cae08fe", "html_url": "https://github.com/rust-lang/rust/commit/81c515bf771ee872d9fc8871acfc797a5cae08fe"}, {"sha": "836addcbc4fa825e07c78c6feb7f6a0b776ed41a", "url": "https://api.github.com/repos/rust-lang/rust/commits/836addcbc4fa825e07c78c6feb7f6a0b776ed41a", "html_url": "https://github.com/rust-lang/rust/commit/836addcbc4fa825e07c78c6feb7f6a0b776ed41a"}], "stats": {"total": 129, "additions": 65, "deletions": 64}, "files": [{"sha": "60ff18af0a97e8f1e34bc225d7d09e5294874356", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/metadata.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/5cddd24daa8c4bc4c16f2c11115359a882e2bc50/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5cddd24daa8c4bc4c16f2c11115359a882e2bc50/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs?ref=5cddd24daa8c4bc4c16f2c11115359a882e2bc50", "patch": "@@ -18,6 +18,7 @@ use crate::llvm::debuginfo::{\n use crate::value::Value;\n \n use cstr::cstr;\n+use rustc_codegen_ssa::debuginfo::type_names::cpp_like_debuginfo;\n use rustc_codegen_ssa::traits::*;\n use rustc_data_structures::fingerprint::Fingerprint;\n use rustc_data_structures::fx::FxHashMap;\n@@ -933,16 +934,16 @@ fn basic_type_metadata<'ll, 'tcx>(cx: &CodegenCx<'ll, 'tcx>, t: Ty<'tcx>) -> &'l\n \n     // When targeting MSVC, emit MSVC style type names for compatibility with\n     // .natvis visualizers (and perhaps other existing native debuggers?)\n-    let msvc_like_names = cx.tcx.sess.target.is_like_msvc;\n+    let cpp_like_debuginfo = cpp_like_debuginfo(cx.tcx);\n \n     let (name, encoding) = match t.kind() {\n         ty::Never => (\"!\", DW_ATE_unsigned),\n         ty::Tuple(elements) if elements.is_empty() => (\"()\", DW_ATE_unsigned),\n         ty::Bool => (\"bool\", DW_ATE_boolean),\n         ty::Char => (\"char\", DW_ATE_unsigned_char),\n-        ty::Int(int_ty) if msvc_like_names => (int_ty.msvc_basic_name(), DW_ATE_signed),\n-        ty::Uint(uint_ty) if msvc_like_names => (uint_ty.msvc_basic_name(), DW_ATE_unsigned),\n-        ty::Float(float_ty) if msvc_like_names => (float_ty.msvc_basic_name(), DW_ATE_float),\n+        ty::Int(int_ty) if cpp_like_debuginfo => (int_ty.msvc_basic_name(), DW_ATE_signed),\n+        ty::Uint(uint_ty) if cpp_like_debuginfo => (uint_ty.msvc_basic_name(), DW_ATE_unsigned),\n+        ty::Float(float_ty) if cpp_like_debuginfo => (float_ty.msvc_basic_name(), DW_ATE_float),\n         ty::Int(int_ty) => (int_ty.name_str(), DW_ATE_signed),\n         ty::Uint(uint_ty) => (uint_ty.name_str(), DW_ATE_unsigned),\n         ty::Float(float_ty) => (float_ty.name_str(), DW_ATE_float),\n@@ -959,7 +960,7 @@ fn basic_type_metadata<'ll, 'tcx>(cx: &CodegenCx<'ll, 'tcx>, t: Ty<'tcx>) -> &'l\n         )\n     };\n \n-    if !msvc_like_names {\n+    if !cpp_like_debuginfo {\n         return ty_metadata;\n     }\n \n@@ -1525,13 +1526,6 @@ fn prepare_union_metadata<'ll, 'tcx>(\n // Enums\n //=-----------------------------------------------------------------------------\n \n-/// DWARF variant support is only available starting in LLVM 8, but\n-/// on MSVC we have to use the fallback mode, because LLVM doesn't\n-/// lower variant parts to PDB.\n-fn use_enum_fallback(cx: &CodegenCx<'_, '_>) -> bool {\n-    cx.sess().target.is_like_msvc\n-}\n-\n // FIXME(eddyb) maybe precompute this? Right now it's computed once\n // per generator monomorphization, but it doesn't depend on substs.\n fn generator_layout_and_saved_local_names<'tcx>(\n@@ -1606,7 +1600,10 @@ impl<'ll, 'tcx> EnumMemberDescriptionFactory<'ll, 'tcx> {\n             _ => bug!(),\n         };\n \n-        let fallback = use_enum_fallback(cx);\n+        // While LLVM supports generating debuginfo for variant types (enums), it doesn't support\n+        // lowering that debuginfo to CodeView records for msvc targets. So if we are targeting\n+        // msvc, then we need to use a different, fallback encoding of the debuginfo.\n+        let fallback = cpp_like_debuginfo(cx.tcx);\n         // This will always find the metadata in the type map.\n         let self_metadata = type_metadata(cx, self.enum_type, self.span);\n \n@@ -2159,7 +2156,10 @@ fn prepare_enum_metadata<'ll, 'tcx>(\n         return FinalMetadata(discriminant_type_metadata(tag.value));\n     }\n \n-    if use_enum_fallback(cx) {\n+    // While LLVM supports generating debuginfo for variant types (enums), it doesn't support\n+    // lowering that debuginfo to CodeView records for msvc targets. So if we are targeting\n+    // msvc, then we need to use a different encoding of the debuginfo.\n+    if cpp_like_debuginfo(tcx) {\n         let discriminant_type_metadata = match layout.variants {\n             Variants::Single { .. } => None,\n             Variants::Multiple { tag_encoding: TagEncoding::Niche { .. }, tag, .. }"}, {"sha": "93bb1aee25f7d25d9aca664a58275d30fa9c3f17", "filename": "compiler/rustc_codegen_ssa/src/debuginfo/type_names.rs", "status": "modified", "additions": 51, "deletions": 50, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/5cddd24daa8c4bc4c16f2c11115359a882e2bc50/compiler%2Frustc_codegen_ssa%2Fsrc%2Fdebuginfo%2Ftype_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5cddd24daa8c4bc4c16f2c11115359a882e2bc50/compiler%2Frustc_codegen_ssa%2Fsrc%2Fdebuginfo%2Ftype_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fdebuginfo%2Ftype_names.rs?ref=5cddd24daa8c4bc4c16f2c11115359a882e2bc50", "patch": "@@ -53,14 +53,14 @@ fn push_debuginfo_type_name<'tcx>(\n ) {\n     // When targeting MSVC, emit C++ style type names for compatibility with\n     // .natvis visualizers (and perhaps other existing native debuggers?)\n-    let cpp_like_names = cpp_like_names(tcx);\n+    let cpp_like_debuginfo = cpp_like_debuginfo(tcx);\n \n     match *t.kind() {\n         ty::Bool => output.push_str(\"bool\"),\n         ty::Char => output.push_str(\"char\"),\n         ty::Str => output.push_str(\"str\"),\n         ty::Never => {\n-            if cpp_like_names {\n+            if cpp_like_debuginfo {\n                 output.push_str(\"never$\");\n             } else {\n                 output.push('!');\n@@ -71,36 +71,36 @@ fn push_debuginfo_type_name<'tcx>(\n         ty::Float(float_ty) => output.push_str(float_ty.name_str()),\n         ty::Foreign(def_id) => push_item_name(tcx, def_id, qualified, output),\n         ty::Adt(def, substs) => {\n-            if def.is_enum() && cpp_like_names {\n+            if def.is_enum() && cpp_like_debuginfo {\n                 msvc_enum_fallback(tcx, t, def, substs, output, visited);\n             } else {\n                 push_item_name(tcx, def.did, qualified, output);\n                 push_generic_params_internal(tcx, substs, output, visited);\n             }\n         }\n         ty::Tuple(component_types) => {\n-            if cpp_like_names {\n+            if cpp_like_debuginfo {\n                 output.push_str(\"tuple$<\");\n             } else {\n                 output.push('(');\n             }\n \n             for component_type in component_types {\n                 push_debuginfo_type_name(tcx, component_type.expect_ty(), true, output, visited);\n-                push_arg_separator(cpp_like_names, output);\n+                push_arg_separator(cpp_like_debuginfo, output);\n             }\n             if !component_types.is_empty() {\n                 pop_arg_separator(output);\n             }\n \n-            if cpp_like_names {\n-                push_close_angle_bracket(cpp_like_names, output);\n+            if cpp_like_debuginfo {\n+                push_close_angle_bracket(cpp_like_debuginfo, output);\n             } else {\n                 output.push(')');\n             }\n         }\n         ty::RawPtr(ty::TypeAndMut { ty: inner_type, mutbl }) => {\n-            if cpp_like_names {\n+            if cpp_like_debuginfo {\n                 match mutbl {\n                     hir::Mutability::Not => output.push_str(\"ptr_const$<\"),\n                     hir::Mutability::Mut => output.push_str(\"ptr_mut$<\"),\n@@ -115,8 +115,8 @@ fn push_debuginfo_type_name<'tcx>(\n \n             push_debuginfo_type_name(tcx, inner_type, qualified, output, visited);\n \n-            if cpp_like_names {\n-                push_close_angle_bracket(cpp_like_names, output);\n+            if cpp_like_debuginfo {\n+                push_close_angle_bracket(cpp_like_debuginfo, output);\n             }\n         }\n         ty::Ref(_, inner_type, mutbl) => {\n@@ -126,7 +126,7 @@ fn push_debuginfo_type_name<'tcx>(\n             // types out to aid debugging in MSVC.\n             let is_slice_or_str = matches!(*inner_type.kind(), ty::Slice(_) | ty::Str);\n \n-            if !cpp_like_names {\n+            if !cpp_like_debuginfo {\n                 output.push('&');\n                 output.push_str(mutbl.prefix_str());\n             } else if !is_slice_or_str {\n@@ -138,12 +138,12 @@ fn push_debuginfo_type_name<'tcx>(\n \n             push_debuginfo_type_name(tcx, inner_type, qualified, output, visited);\n \n-            if cpp_like_names && !is_slice_or_str {\n-                push_close_angle_bracket(cpp_like_names, output);\n+            if cpp_like_debuginfo && !is_slice_or_str {\n+                push_close_angle_bracket(cpp_like_debuginfo, output);\n             }\n         }\n         ty::Array(inner_type, len) => {\n-            if cpp_like_names {\n+            if cpp_like_debuginfo {\n                 output.push_str(\"array$<\");\n                 push_debuginfo_type_name(tcx, inner_type, true, output, visited);\n                 match len.val {\n@@ -162,24 +162,24 @@ fn push_debuginfo_type_name<'tcx>(\n             }\n         }\n         ty::Slice(inner_type) => {\n-            if cpp_like_names {\n+            if cpp_like_debuginfo {\n                 output.push_str(\"slice$<\");\n             } else {\n                 output.push('[');\n             }\n \n             push_debuginfo_type_name(tcx, inner_type, true, output, visited);\n \n-            if cpp_like_names {\n-                push_close_angle_bracket(cpp_like_names, output);\n+            if cpp_like_debuginfo {\n+                push_close_angle_bracket(cpp_like_debuginfo, output);\n             } else {\n                 output.push(']');\n             }\n         }\n         ty::Dynamic(ref trait_data, ..) => {\n             let auto_traits: SmallVec<[DefId; 4]> = trait_data.auto_traits().collect();\n \n-            let has_enclosing_parens = if cpp_like_names {\n+            let has_enclosing_parens = if cpp_like_debuginfo {\n                 output.push_str(\"dyn$<\");\n                 false\n             } else {\n@@ -216,26 +216,26 @@ fn push_debuginfo_type_name<'tcx>(\n                     }\n \n                     for (item_def_id, ty) in projection_bounds {\n-                        push_arg_separator(cpp_like_names, output);\n+                        push_arg_separator(cpp_like_debuginfo, output);\n \n-                        if cpp_like_names {\n+                        if cpp_like_debuginfo {\n                             output.push_str(\"assoc$<\");\n                             push_item_name(tcx, item_def_id, false, output);\n-                            push_arg_separator(cpp_like_names, output);\n+                            push_arg_separator(cpp_like_debuginfo, output);\n                             push_debuginfo_type_name(tcx, ty, true, output, visited);\n-                            push_close_angle_bracket(cpp_like_names, output);\n+                            push_close_angle_bracket(cpp_like_debuginfo, output);\n                         } else {\n                             push_item_name(tcx, item_def_id, false, output);\n                             output.push('=');\n                             push_debuginfo_type_name(tcx, ty, true, output, visited);\n                         }\n                     }\n \n-                    push_close_angle_bracket(cpp_like_names, output);\n+                    push_close_angle_bracket(cpp_like_debuginfo, output);\n                 }\n \n                 if auto_traits.len() != 0 {\n-                    push_auto_trait_separator(cpp_like_names, output);\n+                    push_auto_trait_separator(cpp_like_debuginfo, output);\n                 }\n             }\n \n@@ -252,14 +252,14 @@ fn push_debuginfo_type_name<'tcx>(\n \n                 for auto_trait in auto_traits {\n                     output.push_str(&auto_trait);\n-                    push_auto_trait_separator(cpp_like_names, output);\n+                    push_auto_trait_separator(cpp_like_debuginfo, output);\n                 }\n \n                 pop_auto_trait_separator(output);\n             }\n \n-            if cpp_like_names {\n-                push_close_angle_bracket(cpp_like_names, output);\n+            if cpp_like_debuginfo {\n+                push_close_angle_bracket(cpp_like_debuginfo, output);\n             } else if has_enclosing_parens {\n                 output.push(')');\n             }\n@@ -279,7 +279,7 @@ fn push_debuginfo_type_name<'tcx>(\n             // use a dummy string that should make it clear\n             // that something unusual is going on\n             if !visited.insert(t) {\n-                output.push_str(if cpp_like_names {\n+                output.push_str(if cpp_like_debuginfo {\n                     \"recursive_type$\"\n                 } else {\n                     \"<recursive_type>\"\n@@ -290,7 +290,7 @@ fn push_debuginfo_type_name<'tcx>(\n             let sig =\n                 tcx.normalize_erasing_late_bound_regions(ty::ParamEnv::reveal_all(), t.fn_sig(tcx));\n \n-            if cpp_like_names {\n+            if cpp_like_debuginfo {\n                 // Format as a C++ function pointer: return_type (*)(params...)\n                 if sig.output().is_unit() {\n                     output.push_str(\"void\");\n@@ -313,7 +313,7 @@ fn push_debuginfo_type_name<'tcx>(\n             if !sig.inputs().is_empty() {\n                 for &parameter_type in sig.inputs() {\n                     push_debuginfo_type_name(tcx, parameter_type, true, output, visited);\n-                    push_arg_separator(cpp_like_names, output);\n+                    push_arg_separator(cpp_like_debuginfo, output);\n                 }\n                 pop_arg_separator(output);\n             }\n@@ -328,7 +328,7 @@ fn push_debuginfo_type_name<'tcx>(\n \n             output.push(')');\n \n-            if !cpp_like_names && !sig.output().is_unit() {\n+            if !cpp_like_debuginfo && !sig.output().is_unit() {\n                 output.push_str(\" -> \");\n                 push_debuginfo_type_name(tcx, sig.output(), true, output, visited);\n             }\n@@ -426,9 +426,9 @@ fn push_debuginfo_type_name<'tcx>(\n \n     const NON_CPP_AUTO_TRAIT_SEPARATOR: &str = \" + \";\n \n-    fn push_auto_trait_separator(cpp_like_names: bool, output: &mut String) {\n-        if cpp_like_names {\n-            push_arg_separator(cpp_like_names, output);\n+    fn push_auto_trait_separator(cpp_like_debuginfo: bool, output: &mut String) {\n+        if cpp_like_debuginfo {\n+            push_arg_separator(cpp_like_debuginfo, output);\n         } else {\n             output.push_str(NON_CPP_AUTO_TRAIT_SEPARATOR);\n         }\n@@ -457,11 +457,11 @@ pub fn compute_debuginfo_vtable_name<'tcx>(\n     t: Ty<'tcx>,\n     trait_ref: Option<ty::PolyExistentialTraitRef<'tcx>>,\n ) -> String {\n-    let cpp_like_names = cpp_like_names(tcx);\n+    let cpp_like_debuginfo = cpp_like_debuginfo(tcx);\n \n     let mut vtable_name = String::with_capacity(64);\n \n-    if cpp_like_names {\n+    if cpp_like_debuginfo {\n         vtable_name.push_str(\"impl$<\");\n     } else {\n         vtable_name.push('<');\n@@ -470,7 +470,7 @@ pub fn compute_debuginfo_vtable_name<'tcx>(\n     let mut visited = FxHashSet::default();\n     push_debuginfo_type_name(tcx, t, true, &mut vtable_name, &mut visited);\n \n-    if cpp_like_names {\n+    if cpp_like_debuginfo {\n         vtable_name.push_str(\", \");\n     } else {\n         vtable_name.push_str(\" as \");\n@@ -486,9 +486,9 @@ pub fn compute_debuginfo_vtable_name<'tcx>(\n         vtable_name.push_str(\"_\");\n     }\n \n-    push_close_angle_bracket(cpp_like_names, &mut vtable_name);\n+    push_close_angle_bracket(cpp_like_debuginfo, &mut vtable_name);\n \n-    let suffix = if cpp_like_names { \"::vtable$\" } else { \"::{vtable}\" };\n+    let suffix = if cpp_like_debuginfo { \"::vtable$\" } else { \"::{vtable}\" };\n \n     vtable_name.reserve_exact(suffix.len());\n     vtable_name.push_str(suffix);\n@@ -521,7 +521,7 @@ fn push_unqualified_item_name(\n         DefPathData::ClosureExpr if tcx.generator_kind(def_id).is_some() => {\n             // Generators look like closures, but we want to treat them differently\n             // in the debug info.\n-            if cpp_like_names(tcx) {\n+            if cpp_like_debuginfo(tcx) {\n                 write!(output, \"generator${}\", disambiguated_data.disambiguator).unwrap();\n             } else {\n                 write!(output, \"{{generator#{}}}\", disambiguated_data.disambiguator).unwrap();\n@@ -532,7 +532,7 @@ fn push_unqualified_item_name(\n                 output.push_str(name.as_str());\n             }\n             DefPathDataName::Anon { namespace } => {\n-                if cpp_like_names(tcx) {\n+                if cpp_like_debuginfo(tcx) {\n                     write!(output, \"{}${}\", namespace, disambiguated_data.disambiguator).unwrap();\n                 } else {\n                     write!(output, \"{{{}#{}}}\", namespace, disambiguated_data.disambiguator)\n@@ -560,7 +560,7 @@ fn push_generic_params_internal<'tcx>(\n \n     debug_assert_eq!(substs, tcx.normalize_erasing_regions(ty::ParamEnv::reveal_all(), substs));\n \n-    let cpp_like_names = cpp_like_names(tcx);\n+    let cpp_like_debuginfo = cpp_like_debuginfo(tcx);\n \n     output.push('<');\n \n@@ -575,10 +575,10 @@ fn push_generic_params_internal<'tcx>(\n             other => bug!(\"Unexpected non-erasable generic: {:?}\", other),\n         }\n \n-        push_arg_separator(cpp_like_names, output);\n+        push_arg_separator(cpp_like_debuginfo, output);\n     }\n     pop_arg_separator(output);\n-    push_close_angle_bracket(cpp_like_names, output);\n+    push_close_angle_bracket(cpp_like_debuginfo, output);\n \n     true\n }\n@@ -617,7 +617,7 @@ fn push_const_param<'tcx>(tcx: TyCtxt<'tcx>, ct: &'tcx ty::Const<'tcx>, output:\n                 // avoiding collisions and will make the emitted type names shorter.\n                 let hash: u64 = hasher.finish();\n \n-                if cpp_like_names(tcx) {\n+                if cpp_like_debuginfo(tcx) {\n                     write!(output, \"CONST${:x}\", hash)\n                 } else {\n                     write!(output, \"{{CONST#{:x}}}\", hash)\n@@ -634,10 +634,10 @@ pub fn push_generic_params<'tcx>(tcx: TyCtxt<'tcx>, substs: SubstsRef<'tcx>, out\n     push_generic_params_internal(tcx, substs, output, &mut visited);\n }\n \n-fn push_close_angle_bracket(cpp_like_names: bool, output: &mut String) {\n+fn push_close_angle_bracket(cpp_like_debuginfo: bool, output: &mut String) {\n     // MSVC debugger always treats `>>` as a shift, even when parsing templates,\n     // so add a space to avoid confusion.\n-    if cpp_like_names && output.ends_with('>') {\n+    if cpp_like_debuginfo && output.ends_with('>') {\n         output.push(' ')\n     };\n \n@@ -652,11 +652,11 @@ fn pop_close_angle_bracket(output: &mut String) {\n     }\n }\n \n-fn push_arg_separator(cpp_like_names: bool, output: &mut String) {\n+fn push_arg_separator(cpp_like_debuginfo: bool, output: &mut String) {\n     // Natvis does not always like having spaces between parts of the type name\n     // and this causes issues when we need to write a typename in natvis, for example\n     // as part of a cast like the `HashMap` visualizer does.\n-    if cpp_like_names {\n+    if cpp_like_debuginfo {\n         output.push(',');\n     } else {\n         output.push_str(\", \");\n@@ -673,6 +673,7 @@ fn pop_arg_separator(output: &mut String) {\n     output.pop();\n }\n \n-fn cpp_like_names(tcx: TyCtxt<'_>) -> bool {\n+/// Check if we should generate C++ like names and debug information.\n+pub fn cpp_like_debuginfo(tcx: TyCtxt<'_>) -> bool {\n     tcx.sess.target.is_like_msvc\n }"}]}