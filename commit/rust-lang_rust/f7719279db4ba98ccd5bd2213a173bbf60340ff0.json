{"sha": "f7719279db4ba98ccd5bd2213a173bbf60340ff0", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY3NzE5Mjc5ZGI0YmE5OGNjZDViZDIyMTNhMTczYmJmNjAzNDBmZjA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-09-04T21:25:55Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-09-04T21:25:55Z"}, "message": "Auto merge of #7584 - shepmaster:unnecessary_expect, r=camsteffen\n\nExtend unnecessary_unwrap to look for expect in addition to unwrap\n\nchangelog: Extend ``[`unnecessary_unwrap`]`` to also check for `Option::expect` and `Result::expect`. Also give code suggestions in some cases.\n\nFixes #7581", "tree": {"sha": "858a3178a694ca60073753e737da8c135aa9a2dc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/858a3178a694ca60073753e737da8c135aa9a2dc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f7719279db4ba98ccd5bd2213a173bbf60340ff0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f7719279db4ba98ccd5bd2213a173bbf60340ff0", "html_url": "https://github.com/rust-lang/rust/commit/f7719279db4ba98ccd5bd2213a173bbf60340ff0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f7719279db4ba98ccd5bd2213a173bbf60340ff0/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a8c2c7b712c273f13258de8b87b233918d8726b9", "url": "https://api.github.com/repos/rust-lang/rust/commits/a8c2c7b712c273f13258de8b87b233918d8726b9", "html_url": "https://github.com/rust-lang/rust/commit/a8c2c7b712c273f13258de8b87b233918d8726b9"}, {"sha": "b4775435e875e3668ad920d911fabaed58f8860f", "url": "https://api.github.com/repos/rust-lang/rust/commits/b4775435e875e3668ad920d911fabaed58f8860f", "html_url": "https://github.com/rust-lang/rust/commit/b4775435e875e3668ad920d911fabaed58f8860f"}], "stats": {"total": 281, "additions": 212, "deletions": 69}, "files": [{"sha": "b2ab300c2e937faed6ef49aaff09957203807dfb", "filename": "clippy_lints/src/unwrap.rs", "status": "modified", "additions": 111, "deletions": 22, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/f7719279db4ba98ccd5bd2213a173bbf60340ff0/clippy_lints%2Fsrc%2Funwrap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7719279db4ba98ccd5bd2213a173bbf60340ff0/clippy_lints%2Fsrc%2Funwrap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funwrap.rs?ref=f7719279db4ba98ccd5bd2213a173bbf60340ff0", "patch": "@@ -1,10 +1,11 @@\n use clippy_utils::diagnostics::span_lint_and_then;\n use clippy_utils::higher;\n use clippy_utils::ty::is_type_diagnostic_item;\n-use clippy_utils::{differing_macro_contexts, usage::is_potentially_mutated};\n+use clippy_utils::{differing_macro_contexts, path_to_local, usage::is_potentially_mutated};\n use if_chain::if_chain;\n+use rustc_errors::Applicability;\n use rustc_hir::intravisit::{walk_expr, walk_fn, FnKind, NestedVisitorMap, Visitor};\n-use rustc_hir::{BinOpKind, Body, Expr, ExprKind, FnDecl, HirId, Path, QPath, UnOp};\n+use rustc_hir::{BinOpKind, Body, Expr, ExprKind, FnDecl, HirId, PathSegment, UnOp};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::hir::map::Map;\n use rustc_middle::lint::in_external_macro;\n@@ -74,26 +75,61 @@ struct UnwrappableVariablesVisitor<'a, 'tcx> {\n     unwrappables: Vec<UnwrapInfo<'tcx>>,\n     cx: &'a LateContext<'tcx>,\n }\n+\n+/// What kind of unwrappable this is.\n+#[derive(Copy, Clone, Debug)]\n+enum UnwrappableKind {\n+    Option,\n+    Result,\n+}\n+\n+impl UnwrappableKind {\n+    fn success_variant_pattern(self) -> &'static str {\n+        match self {\n+            UnwrappableKind::Option => \"Some(..)\",\n+            UnwrappableKind::Result => \"Ok(..)\",\n+        }\n+    }\n+\n+    fn error_variant_pattern(self) -> &'static str {\n+        match self {\n+            UnwrappableKind::Option => \"None\",\n+            UnwrappableKind::Result => \"Err(..)\",\n+        }\n+    }\n+}\n+\n /// Contains information about whether a variable can be unwrapped.\n #[derive(Copy, Clone, Debug)]\n struct UnwrapInfo<'tcx> {\n     /// The variable that is checked\n-    ident: &'tcx Path<'tcx>,\n+    local_id: HirId,\n+    /// The if itself\n+    if_expr: &'tcx Expr<'tcx>,\n     /// The check, like `x.is_ok()`\n     check: &'tcx Expr<'tcx>,\n+    /// The check's name, like `is_ok`\n+    check_name: &'tcx PathSegment<'tcx>,\n     /// The branch where the check takes place, like `if x.is_ok() { .. }`\n     branch: &'tcx Expr<'tcx>,\n     /// Whether `is_some()` or `is_ok()` was called (as opposed to `is_err()` or `is_none()`).\n     safe_to_unwrap: bool,\n+    /// What kind of unwrappable this is.\n+    kind: UnwrappableKind,\n+    /// If the check is the entire condition (`if x.is_ok()`) or only a part of it (`foo() &&\n+    /// x.is_ok()`)\n+    is_entire_condition: bool,\n }\n \n /// Collects the information about unwrappable variables from an if condition\n /// The `invert` argument tells us whether the condition is negated.\n fn collect_unwrap_info<'tcx>(\n     cx: &LateContext<'tcx>,\n+    if_expr: &'tcx Expr<'_>,\n     expr: &'tcx Expr<'_>,\n     branch: &'tcx Expr<'_>,\n     invert: bool,\n+    is_entire_condition: bool,\n ) -> Vec<UnwrapInfo<'tcx>> {\n     fn is_relevant_option_call(cx: &LateContext<'_>, ty: Ty<'_>, method_name: &str) -> bool {\n         is_type_diagnostic_item(cx, ty, sym::option_type) && [\"is_some\", \"is_none\"].contains(&method_name)\n@@ -106,18 +142,18 @@ fn collect_unwrap_info<'tcx>(\n     if let ExprKind::Binary(op, left, right) = &expr.kind {\n         match (invert, op.node) {\n             (false, BinOpKind::And | BinOpKind::BitAnd) | (true, BinOpKind::Or | BinOpKind::BitOr) => {\n-                let mut unwrap_info = collect_unwrap_info(cx, left, branch, invert);\n-                unwrap_info.append(&mut collect_unwrap_info(cx, right, branch, invert));\n+                let mut unwrap_info = collect_unwrap_info(cx, if_expr, left, branch, invert, false);\n+                unwrap_info.append(&mut collect_unwrap_info(cx, if_expr, right, branch, invert, false));\n                 return unwrap_info;\n             },\n             _ => (),\n         }\n     } else if let ExprKind::Unary(UnOp::Not, expr) = &expr.kind {\n-        return collect_unwrap_info(cx, expr, branch, !invert);\n+        return collect_unwrap_info(cx, if_expr, expr, branch, !invert, false);\n     } else {\n         if_chain! {\n             if let ExprKind::MethodCall(method_name, _, args, _) = &expr.kind;\n-            if let ExprKind::Path(QPath::Resolved(None, path)) = &args[0].kind;\n+            if let Some(local_id) = path_to_local(&args[0]);\n             let ty = cx.typeck_results().expr_ty(&args[0]);\n             let name = method_name.ident.as_str();\n             if is_relevant_option_call(cx, ty, &name) || is_relevant_result_call(cx, ty, &name);\n@@ -129,19 +165,42 @@ fn collect_unwrap_info<'tcx>(\n                     _ => unreachable!(),\n                 };\n                 let safe_to_unwrap = unwrappable != invert;\n-                return vec![UnwrapInfo { ident: path, check: expr, branch, safe_to_unwrap }];\n+                let kind = if is_type_diagnostic_item(cx, ty, sym::option_type) {\n+                    UnwrappableKind::Option\n+                } else {\n+                    UnwrappableKind::Result\n+                };\n+\n+                return vec![\n+                    UnwrapInfo {\n+                        local_id,\n+                        if_expr,\n+                        check: expr,\n+                        check_name: method_name,\n+                        branch,\n+                        safe_to_unwrap,\n+                        kind,\n+                        is_entire_condition,\n+                    }\n+                ]\n             }\n         }\n     }\n     Vec::new()\n }\n \n impl<'a, 'tcx> UnwrappableVariablesVisitor<'a, 'tcx> {\n-    fn visit_branch(&mut self, cond: &'tcx Expr<'_>, branch: &'tcx Expr<'_>, else_branch: bool) {\n+    fn visit_branch(\n+        &mut self,\n+        if_expr: &'tcx Expr<'_>,\n+        cond: &'tcx Expr<'_>,\n+        branch: &'tcx Expr<'_>,\n+        else_branch: bool,\n+    ) {\n         let prev_len = self.unwrappables.len();\n-        for unwrap_info in collect_unwrap_info(self.cx, cond, branch, else_branch) {\n-            if is_potentially_mutated(unwrap_info.ident, cond, self.cx)\n-                || is_potentially_mutated(unwrap_info.ident, branch, self.cx)\n+        for unwrap_info in collect_unwrap_info(self.cx, if_expr, cond, branch, else_branch, true) {\n+            if is_potentially_mutated(unwrap_info.local_id, cond, self.cx)\n+                || is_potentially_mutated(unwrap_info.local_id, branch, self.cx)\n             {\n                 // if the variable is mutated, we don't know whether it can be unwrapped:\n                 continue;\n@@ -163,32 +222,62 @@ impl<'a, 'tcx> Visitor<'tcx> for UnwrappableVariablesVisitor<'a, 'tcx> {\n         }\n         if let Some(higher::If { cond, then, r#else }) = higher::If::hir(expr) {\n             walk_expr(self, cond);\n-            self.visit_branch(cond, then, false);\n+            self.visit_branch(expr, cond, then, false);\n             if let Some(else_inner) = r#else {\n-                self.visit_branch(cond, else_inner, true);\n+                self.visit_branch(expr, cond, else_inner, true);\n             }\n         } else {\n             // find `unwrap[_err]()` calls:\n             if_chain! {\n                 if let ExprKind::MethodCall(method_name, _, args, _) = expr.kind;\n-                if let ExprKind::Path(QPath::Resolved(None, path)) = args[0].kind;\n-                if [sym::unwrap, sym!(unwrap_err)].contains(&method_name.ident.name);\n-                let call_to_unwrap = method_name.ident.name == sym::unwrap;\n+                if let Some(id) = path_to_local(&args[0]);\n+                if [sym::unwrap, sym::expect, sym!(unwrap_err)].contains(&method_name.ident.name);\n+                let call_to_unwrap = [sym::unwrap, sym::expect].contains(&method_name.ident.name);\n                 if let Some(unwrappable) = self.unwrappables.iter()\n-                    .find(|u| u.ident.res == path.res);\n+                    .find(|u| u.local_id == id);\n                 // Span contexts should not differ with the conditional branch\n                 if !differing_macro_contexts(unwrappable.branch.span, expr.span);\n                 if !differing_macro_contexts(unwrappable.branch.span, unwrappable.check.span);\n                 then {\n                     if call_to_unwrap == unwrappable.safe_to_unwrap {\n+                        let is_entire_condition = unwrappable.is_entire_condition;\n+                        let unwrappable_variable_name = self.cx.tcx.hir().name(unwrappable.local_id);\n+                        let suggested_pattern = if call_to_unwrap {\n+                            unwrappable.kind.success_variant_pattern()\n+                        } else {\n+                            unwrappable.kind.error_variant_pattern()\n+                        };\n+\n                         span_lint_and_then(\n                             self.cx,\n                             UNNECESSARY_UNWRAP,\n                             expr.span,\n-                            &format!(\"you checked before that `{}()` cannot fail, \\\n-                            instead of checking and unwrapping, it's better to use `if let` or `match`\",\n-                            method_name.ident.name),\n-                            |diag| { diag.span_label(unwrappable.check.span, \"the check is happening here\"); },\n+                            &format!(\n+                                \"called `{}` on `{}` after checking its variant with `{}`\",\n+                                method_name.ident.name,\n+                                unwrappable_variable_name,\n+                                unwrappable.check_name.ident.as_str(),\n+                            ),\n+                            |diag| {\n+                                if is_entire_condition {\n+                                    diag.span_suggestion(\n+                                        unwrappable.check.span.with_lo(unwrappable.if_expr.span.lo()),\n+                                        \"try\",\n+                                        format!(\n+                                            \"if let {} = {}\",\n+                                            suggested_pattern,\n+                                            unwrappable_variable_name,\n+                                        ),\n+                                        // We don't track how the unwrapped value is used inside the\n+                                        // block or suggest deleting the unwrap, so we can't offer a\n+                                        // fixable solution.\n+                                        Applicability::Unspecified,\n+                                    );\n+                                } else {\n+                                    diag.span_label(unwrappable.check.span, \"the check is happening here\");\n+                                    diag.help(\"try using `if let` or `match`\");\n+                                }\n+                            },\n                         );\n                     } else {\n                         span_lint_and_then("}, {"sha": "098ec175fe2d91fcf530df7b6885c81d64e42fa1", "filename": "clippy_utils/src/usage.rs", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/f7719279db4ba98ccd5bd2213a173bbf60340ff0/clippy_utils%2Fsrc%2Fusage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7719279db4ba98ccd5bd2213a173bbf60340ff0/clippy_utils%2Fsrc%2Fusage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fusage.rs?ref=f7719279db4ba98ccd5bd2213a173bbf60340ff0", "patch": "@@ -1,10 +1,9 @@\n use crate as utils;\n use rustc_hir as hir;\n-use rustc_hir::def::Res;\n use rustc_hir::intravisit;\n use rustc_hir::intravisit::{NestedVisitorMap, Visitor};\n use rustc_hir::HirIdSet;\n-use rustc_hir::{Expr, ExprKind, HirId, Path};\n+use rustc_hir::{Expr, ExprKind, HirId};\n use rustc_infer::infer::TyCtxtInferExt;\n use rustc_lint::LateContext;\n use rustc_middle::hir::map::Map;\n@@ -35,12 +34,8 @@ pub fn mutated_variables<'tcx>(expr: &'tcx Expr<'_>, cx: &LateContext<'tcx>) ->\n     Some(delegate.used_mutably)\n }\n \n-pub fn is_potentially_mutated<'tcx>(variable: &'tcx Path<'_>, expr: &'tcx Expr<'_>, cx: &LateContext<'tcx>) -> bool {\n-    if let Res::Local(id) = variable.res {\n-        mutated_variables(expr, cx).map_or(true, |mutated| mutated.contains(&id))\n-    } else {\n-        true\n-    }\n+pub fn is_potentially_mutated<'tcx>(variable: HirId, expr: &'tcx Expr<'_>, cx: &LateContext<'tcx>) -> bool {\n+    mutated_variables(expr, cx).map_or(true, |mutated| mutated.contains(&variable))\n }\n \n struct MutVarsDelegate {"}, {"sha": "46c6f69708eb798b8973c0db01b8424dd3b9f102", "filename": "tests/ui/checked_unwrap/complex_conditionals.stderr", "status": "modified", "additions": 29, "deletions": 10, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/f7719279db4ba98ccd5bd2213a173bbf60340ff0/tests%2Fui%2Fchecked_unwrap%2Fcomplex_conditionals.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f7719279db4ba98ccd5bd2213a173bbf60340ff0/tests%2Fui%2Fchecked_unwrap%2Fcomplex_conditionals.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fchecked_unwrap%2Fcomplex_conditionals.stderr?ref=f7719279db4ba98ccd5bd2213a173bbf60340ff0", "patch": "@@ -1,4 +1,4 @@\n-error: you checked before that `unwrap()` cannot fail, instead of checking and unwrapping, it's better to use `if let` or `match`\n+error: called `unwrap` on `x` after checking its variant with `is_ok`\n   --> $DIR/complex_conditionals.rs:8:9\n    |\n LL |     if x.is_ok() && y.is_err() {\n@@ -11,6 +11,7 @@ note: the lint level is defined here\n    |\n LL | #![deny(clippy::panicking_unwrap, clippy::unnecessary_unwrap)]\n    |                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   = help: try using `if let` or `match`\n \n error: this call to `unwrap_err()` will always panic\n   --> $DIR/complex_conditionals.rs:9:9\n@@ -36,14 +37,16 @@ LL |     if x.is_ok() && y.is_err() {\n LL |         y.unwrap(); // will panic\n    |         ^^^^^^^^^^\n \n-error: you checked before that `unwrap_err()` cannot fail, instead of checking and unwrapping, it's better to use `if let` or `match`\n+error: called `unwrap_err` on `y` after checking its variant with `is_err`\n   --> $DIR/complex_conditionals.rs:11:9\n    |\n LL |     if x.is_ok() && y.is_err() {\n    |                     ---------- the check is happening here\n ...\n LL |         y.unwrap_err(); // unnecessary\n    |         ^^^^^^^^^^^^^^\n+   |\n+   = help: try using `if let` or `match`\n \n error: this call to `unwrap()` will always panic\n   --> $DIR/complex_conditionals.rs:25:9\n@@ -54,14 +57,16 @@ LL |     if x.is_ok() || y.is_ok() {\n LL |         x.unwrap(); // will panic\n    |         ^^^^^^^^^^\n \n-error: you checked before that `unwrap_err()` cannot fail, instead of checking and unwrapping, it's better to use `if let` or `match`\n+error: called `unwrap_err` on `x` after checking its variant with `is_ok`\n   --> $DIR/complex_conditionals.rs:26:9\n    |\n LL |     if x.is_ok() || y.is_ok() {\n    |        --------- the check is happening here\n ...\n LL |         x.unwrap_err(); // unnecessary\n    |         ^^^^^^^^^^^^^^\n+   |\n+   = help: try using `if let` or `match`\n \n error: this call to `unwrap()` will always panic\n   --> $DIR/complex_conditionals.rs:27:9\n@@ -72,22 +77,26 @@ LL |     if x.is_ok() || y.is_ok() {\n LL |         y.unwrap(); // will panic\n    |         ^^^^^^^^^^\n \n-error: you checked before that `unwrap_err()` cannot fail, instead of checking and unwrapping, it's better to use `if let` or `match`\n+error: called `unwrap_err` on `y` after checking its variant with `is_ok`\n   --> $DIR/complex_conditionals.rs:28:9\n    |\n LL |     if x.is_ok() || y.is_ok() {\n    |                     --------- the check is happening here\n ...\n LL |         y.unwrap_err(); // unnecessary\n    |         ^^^^^^^^^^^^^^\n+   |\n+   = help: try using `if let` or `match`\n \n-error: you checked before that `unwrap()` cannot fail, instead of checking and unwrapping, it's better to use `if let` or `match`\n+error: called `unwrap` on `x` after checking its variant with `is_ok`\n   --> $DIR/complex_conditionals.rs:32:9\n    |\n LL |     if x.is_ok() && !(y.is_ok() || z.is_err()) {\n    |        --------- the check is happening here\n LL |         x.unwrap(); // unnecessary\n    |         ^^^^^^^^^^\n+   |\n+   = help: try using `if let` or `match`\n \n error: this call to `unwrap_err()` will always panic\n   --> $DIR/complex_conditionals.rs:33:9\n@@ -107,23 +116,27 @@ LL |     if x.is_ok() && !(y.is_ok() || z.is_err()) {\n LL |         y.unwrap(); // will panic\n    |         ^^^^^^^^^^\n \n-error: you checked before that `unwrap_err()` cannot fail, instead of checking and unwrapping, it's better to use `if let` or `match`\n+error: called `unwrap_err` on `y` after checking its variant with `is_ok`\n   --> $DIR/complex_conditionals.rs:35:9\n    |\n LL |     if x.is_ok() && !(y.is_ok() || z.is_err()) {\n    |                       --------- the check is happening here\n ...\n LL |         y.unwrap_err(); // unnecessary\n    |         ^^^^^^^^^^^^^^\n+   |\n+   = help: try using `if let` or `match`\n \n-error: you checked before that `unwrap()` cannot fail, instead of checking and unwrapping, it's better to use `if let` or `match`\n+error: called `unwrap` on `z` after checking its variant with `is_err`\n   --> $DIR/complex_conditionals.rs:36:9\n    |\n LL |     if x.is_ok() && !(y.is_ok() || z.is_err()) {\n    |                                    ---------- the check is happening here\n ...\n LL |         z.unwrap(); // unnecessary\n    |         ^^^^^^^^^^\n+   |\n+   = help: try using `if let` or `match`\n \n error: this call to `unwrap_err()` will always panic\n   --> $DIR/complex_conditionals.rs:37:9\n@@ -143,23 +156,27 @@ LL |     if x.is_ok() || !(y.is_ok() && z.is_err()) {\n LL |         x.unwrap(); // will panic\n    |         ^^^^^^^^^^\n \n-error: you checked before that `unwrap_err()` cannot fail, instead of checking and unwrapping, it's better to use `if let` or `match`\n+error: called `unwrap_err` on `x` after checking its variant with `is_ok`\n   --> $DIR/complex_conditionals.rs:46:9\n    |\n LL |     if x.is_ok() || !(y.is_ok() && z.is_err()) {\n    |        --------- the check is happening here\n ...\n LL |         x.unwrap_err(); // unnecessary\n    |         ^^^^^^^^^^^^^^\n+   |\n+   = help: try using `if let` or `match`\n \n-error: you checked before that `unwrap()` cannot fail, instead of checking and unwrapping, it's better to use `if let` or `match`\n+error: called `unwrap` on `y` after checking its variant with `is_ok`\n   --> $DIR/complex_conditionals.rs:47:9\n    |\n LL |     if x.is_ok() || !(y.is_ok() && z.is_err()) {\n    |                       --------- the check is happening here\n ...\n LL |         y.unwrap(); // unnecessary\n    |         ^^^^^^^^^^\n+   |\n+   = help: try using `if let` or `match`\n \n error: this call to `unwrap_err()` will always panic\n   --> $DIR/complex_conditionals.rs:48:9\n@@ -179,14 +196,16 @@ LL |     if x.is_ok() || !(y.is_ok() && z.is_err()) {\n LL |         z.unwrap(); // will panic\n    |         ^^^^^^^^^^\n \n-error: you checked before that `unwrap_err()` cannot fail, instead of checking and unwrapping, it's better to use `if let` or `match`\n+error: called `unwrap_err` on `z` after checking its variant with `is_err`\n   --> $DIR/complex_conditionals.rs:50:9\n    |\n LL |     if x.is_ok() || !(y.is_ok() && z.is_err()) {\n    |                                    ---------- the check is happening here\n ...\n LL |         z.unwrap_err(); // unnecessary\n    |         ^^^^^^^^^^^^^^\n+   |\n+   = help: try using `if let` or `match`\n \n error: aborting due to 20 previous errors\n "}, {"sha": "542ab53300c029d44641bcb1b78d34752f8c1698", "filename": "tests/ui/checked_unwrap/complex_conditionals_nested.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f7719279db4ba98ccd5bd2213a173bbf60340ff0/tests%2Fui%2Fchecked_unwrap%2Fcomplex_conditionals_nested.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f7719279db4ba98ccd5bd2213a173bbf60340ff0/tests%2Fui%2Fchecked_unwrap%2Fcomplex_conditionals_nested.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fchecked_unwrap%2Fcomplex_conditionals_nested.stderr?ref=f7719279db4ba98ccd5bd2213a173bbf60340ff0", "patch": "@@ -1,8 +1,8 @@\n-error: you checked before that `unwrap()` cannot fail, instead of checking and unwrapping, it's better to use `if let` or `match`\n+error: called `unwrap` on `x` after checking its variant with `is_some`\n   --> $DIR/complex_conditionals_nested.rs:8:13\n    |\n LL |         if x.is_some() {\n-   |            ----------- the check is happening here\n+   |         -------------- help: try: `if let Some(..) = x`\n LL |             x.unwrap(); // unnecessary\n    |             ^^^^^^^^^^\n    |"}, {"sha": "ee3fdfabe9d8a8e255d5966ce924cb87f2744ae7", "filename": "tests/ui/checked_unwrap/simple_conditionals.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f7719279db4ba98ccd5bd2213a173bbf60340ff0/tests%2Fui%2Fchecked_unwrap%2Fsimple_conditionals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7719279db4ba98ccd5bd2213a173bbf60340ff0/tests%2Fui%2Fchecked_unwrap%2Fsimple_conditionals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fchecked_unwrap%2Fsimple_conditionals.rs?ref=f7719279db4ba98ccd5bd2213a173bbf60340ff0", "patch": "@@ -37,8 +37,10 @@ fn main() {\n     let x = Some(());\n     if x.is_some() {\n         x.unwrap(); // unnecessary\n+        x.expect(\"an error message\"); // unnecessary\n     } else {\n         x.unwrap(); // will panic\n+        x.expect(\"an error message\"); // will panic\n     }\n     if x.is_none() {\n         x.unwrap(); // will panic\n@@ -52,9 +54,11 @@ fn main() {\n     let mut x: Result<(), ()> = Ok(());\n     if x.is_ok() {\n         x.unwrap(); // unnecessary\n+        x.expect(\"an error message\"); // unnecessary\n         x.unwrap_err(); // will panic\n     } else {\n         x.unwrap(); // will panic\n+        x.expect(\"an error message\"); // will panic\n         x.unwrap_err(); // unnecessary\n     }\n     if x.is_err() {"}, {"sha": "82f269543800f3dfc62b006bd79a8e141270fca6", "filename": "tests/ui/checked_unwrap/simple_conditionals.stderr", "status": "modified", "additions": 63, "deletions": 27, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/f7719279db4ba98ccd5bd2213a173bbf60340ff0/tests%2Fui%2Fchecked_unwrap%2Fsimple_conditionals.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f7719279db4ba98ccd5bd2213a173bbf60340ff0/tests%2Fui%2Fchecked_unwrap%2Fsimple_conditionals.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fchecked_unwrap%2Fsimple_conditionals.stderr?ref=f7719279db4ba98ccd5bd2213a173bbf60340ff0", "patch": "@@ -1,8 +1,8 @@\n-error: you checked before that `unwrap()` cannot fail, instead of checking and unwrapping, it's better to use `if let` or `match`\n+error: called `unwrap` on `x` after checking its variant with `is_some`\n   --> $DIR/simple_conditionals.rs:39:9\n    |\n LL |     if x.is_some() {\n-   |        ----------- the check is happening here\n+   |     -------------- help: try: `if let Some(..) = x`\n LL |         x.unwrap(); // unnecessary\n    |         ^^^^^^^^^^\n    |\n@@ -12,8 +12,17 @@ note: the lint level is defined here\n LL | #![deny(clippy::panicking_unwrap, clippy::unnecessary_unwrap)]\n    |                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n+error: called `expect` on `x` after checking its variant with `is_some`\n+  --> $DIR/simple_conditionals.rs:40:9\n+   |\n+LL |     if x.is_some() {\n+   |     -------------- help: try: `if let Some(..) = x`\n+LL |         x.unwrap(); // unnecessary\n+LL |         x.expect(\"an error message\"); // unnecessary\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n error: this call to `unwrap()` will always panic\n-  --> $DIR/simple_conditionals.rs:41:9\n+  --> $DIR/simple_conditionals.rs:42:9\n    |\n LL |     if x.is_some() {\n    |        ----------- because of this check\n@@ -27,28 +36,37 @@ note: the lint level is defined here\n LL | #![deny(clippy::panicking_unwrap, clippy::unnecessary_unwrap)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^\n \n+error: this call to `expect()` will always panic\n+  --> $DIR/simple_conditionals.rs:43:9\n+   |\n+LL |     if x.is_some() {\n+   |        ----------- because of this check\n+...\n+LL |         x.expect(\"an error message\"); // will panic\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n error: this call to `unwrap()` will always panic\n-  --> $DIR/simple_conditionals.rs:44:9\n+  --> $DIR/simple_conditionals.rs:46:9\n    |\n LL |     if x.is_none() {\n    |        ----------- because of this check\n LL |         x.unwrap(); // will panic\n    |         ^^^^^^^^^^\n \n-error: you checked before that `unwrap()` cannot fail, instead of checking and unwrapping, it's better to use `if let` or `match`\n-  --> $DIR/simple_conditionals.rs:46:9\n+error: called `unwrap` on `x` after checking its variant with `is_none`\n+  --> $DIR/simple_conditionals.rs:48:9\n    |\n LL |     if x.is_none() {\n-   |        ----------- the check is happening here\n+   |     -------------- help: try: `if let Some(..) = x`\n ...\n LL |         x.unwrap(); // unnecessary\n    |         ^^^^^^^^^^\n \n-error: you checked before that `unwrap()` cannot fail, instead of checking and unwrapping, it's better to use `if let` or `match`\n+error: called `unwrap` on `x` after checking its variant with `is_some`\n   --> $DIR/simple_conditionals.rs:7:13\n    |\n LL |         if $a.is_some() {\n-   |            ------------ the check is happening here\n+   |         --------------- help: try: `if let Some(..) = x`\n LL |             $a.unwrap(); // unnecessary\n    |             ^^^^^^^^^^^\n ...\n@@ -57,75 +75,93 @@ LL |     m!(x);\n    |\n    = note: this error originates in the macro `m` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n-error: you checked before that `unwrap()` cannot fail, instead of checking and unwrapping, it's better to use `if let` or `match`\n-  --> $DIR/simple_conditionals.rs:54:9\n+error: called `unwrap` on `x` after checking its variant with `is_ok`\n+  --> $DIR/simple_conditionals.rs:56:9\n    |\n LL |     if x.is_ok() {\n-   |        --------- the check is happening here\n+   |     ------------ help: try: `if let Ok(..) = x`\n LL |         x.unwrap(); // unnecessary\n    |         ^^^^^^^^^^\n \n+error: called `expect` on `x` after checking its variant with `is_ok`\n+  --> $DIR/simple_conditionals.rs:57:9\n+   |\n+LL |     if x.is_ok() {\n+   |     ------------ help: try: `if let Ok(..) = x`\n+LL |         x.unwrap(); // unnecessary\n+LL |         x.expect(\"an error message\"); // unnecessary\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n error: this call to `unwrap_err()` will always panic\n-  --> $DIR/simple_conditionals.rs:55:9\n+  --> $DIR/simple_conditionals.rs:58:9\n    |\n LL |     if x.is_ok() {\n    |        --------- because of this check\n-LL |         x.unwrap(); // unnecessary\n+...\n LL |         x.unwrap_err(); // will panic\n    |         ^^^^^^^^^^^^^^\n \n error: this call to `unwrap()` will always panic\n-  --> $DIR/simple_conditionals.rs:57:9\n+  --> $DIR/simple_conditionals.rs:60:9\n    |\n LL |     if x.is_ok() {\n    |        --------- because of this check\n ...\n LL |         x.unwrap(); // will panic\n    |         ^^^^^^^^^^\n \n-error: you checked before that `unwrap_err()` cannot fail, instead of checking and unwrapping, it's better to use `if let` or `match`\n-  --> $DIR/simple_conditionals.rs:58:9\n+error: this call to `expect()` will always panic\n+  --> $DIR/simple_conditionals.rs:61:9\n+   |\n+LL |     if x.is_ok() {\n+   |        --------- because of this check\n+...\n+LL |         x.expect(\"an error message\"); // will panic\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: called `unwrap_err` on `x` after checking its variant with `is_ok`\n+  --> $DIR/simple_conditionals.rs:62:9\n    |\n LL |     if x.is_ok() {\n-   |        --------- the check is happening here\n+   |     ------------ help: try: `if let Err(..) = x`\n ...\n LL |         x.unwrap_err(); // unnecessary\n    |         ^^^^^^^^^^^^^^\n \n error: this call to `unwrap()` will always panic\n-  --> $DIR/simple_conditionals.rs:61:9\n+  --> $DIR/simple_conditionals.rs:65:9\n    |\n LL |     if x.is_err() {\n    |        ---------- because of this check\n LL |         x.unwrap(); // will panic\n    |         ^^^^^^^^^^\n \n-error: you checked before that `unwrap_err()` cannot fail, instead of checking and unwrapping, it's better to use `if let` or `match`\n-  --> $DIR/simple_conditionals.rs:62:9\n+error: called `unwrap_err` on `x` after checking its variant with `is_err`\n+  --> $DIR/simple_conditionals.rs:66:9\n    |\n LL |     if x.is_err() {\n-   |        ---------- the check is happening here\n+   |     ------------- help: try: `if let Err(..) = x`\n LL |         x.unwrap(); // will panic\n LL |         x.unwrap_err(); // unnecessary\n    |         ^^^^^^^^^^^^^^\n \n-error: you checked before that `unwrap()` cannot fail, instead of checking and unwrapping, it's better to use `if let` or `match`\n-  --> $DIR/simple_conditionals.rs:64:9\n+error: called `unwrap` on `x` after checking its variant with `is_err`\n+  --> $DIR/simple_conditionals.rs:68:9\n    |\n LL |     if x.is_err() {\n-   |        ---------- the check is happening here\n+   |     ------------- help: try: `if let Ok(..) = x`\n ...\n LL |         x.unwrap(); // unnecessary\n    |         ^^^^^^^^^^\n \n error: this call to `unwrap_err()` will always panic\n-  --> $DIR/simple_conditionals.rs:65:9\n+  --> $DIR/simple_conditionals.rs:69:9\n    |\n LL |     if x.is_err() {\n    |        ---------- because of this check\n ...\n LL |         x.unwrap_err(); // will panic\n    |         ^^^^^^^^^^^^^^\n \n-error: aborting due to 13 previous errors\n+error: aborting due to 17 previous errors\n "}]}