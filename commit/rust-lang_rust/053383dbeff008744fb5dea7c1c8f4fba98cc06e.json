{"sha": "053383dbeff008744fb5dea7c1c8f4fba98cc06e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA1MzM4M2RiZWZmMDA4NzQ0ZmI1ZGVhN2MxYzhmNGZiYTk4Y2MwNmU=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-10-06T10:06:38Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-11-02T21:47:17Z"}, "message": "new rules for merging expected/supplied types in closure signatures\n\nAlso, fix numbering in mir-opt tests. We are now anonymizing more\nconsistently, I think, and hence some of the `TyAnon` indices shifted.", "tree": {"sha": "c5907727bc4f1824eb2b869aef77c9dfb62166dd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c5907727bc4f1824eb2b869aef77c9dfb62166dd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/053383dbeff008744fb5dea7c1c8f4fba98cc06e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/053383dbeff008744fb5dea7c1c8f4fba98cc06e", "html_url": "https://github.com/rust-lang/rust/commit/053383dbeff008744fb5dea7c1c8f4fba98cc06e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/053383dbeff008744fb5dea7c1c8f4fba98cc06e/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ea4db3521ebc776d68cfa6752e50cc066439f5bd", "url": "https://api.github.com/repos/rust-lang/rust/commits/ea4db3521ebc776d68cfa6752e50cc066439f5bd", "html_url": "https://github.com/rust-lang/rust/commit/ea4db3521ebc776d68cfa6752e50cc066439f5bd"}], "stats": {"total": 714, "additions": 646, "deletions": 68}, "files": [{"sha": "df0f3a988583f710244fa64312629db287485654", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 204, "deletions": 64, "changes": 268, "blob_url": "https://github.com/rust-lang/rust/blob/053383dbeff008744fb5dea7c1c8f4fba98cc06e/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/053383dbeff008744fb5dea7c1c8f4fba98cc06e/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=053383dbeff008744fb5dea7c1c8f4fba98cc06e", "patch": "@@ -13,14 +13,22 @@\n use super::{check_fn, Expectation, FnCtxt};\n \n use astconv::AstConv;\n+use rustc::hir::def_id::DefId;\n+use rustc::infer::LateBoundRegionConversionTime;\n use rustc::infer::type_variable::TypeVariableOrigin;\n use rustc::ty::{self, ToPolyTraitRef, Ty};\n use rustc::ty::subst::Substs;\n+use rustc::ty::TypeFoldable;\n use std::cmp;\n use std::iter;\n use syntax::abi::Abi;\n use rustc::hir;\n \n+struct ClosureSignatures<'tcx> {\n+    bound_sig: ty::PolyFnSig<'tcx>,\n+    liberated_sig: ty::FnSig<'tcx>,\n+}\n+\n impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     pub fn check_expr_closure(&self,\n                               expr: &hir::Expr,\n@@ -56,15 +64,13 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                expected_sig);\n \n         let expr_def_id = self.tcx.hir.local_def_id(expr.id);\n-        let sig = self.ty_of_closure(decl, expected_sig);\n \n-        debug!(\"check_closure: ty_of_closure returns {:?}\", sig);\n+        let ClosureSignatures { bound_sig, liberated_sig } =\n+            self.sig_of_closure(expr_def_id, decl, body, expected_sig);\n \n-        // `deduce_expectations_from_expected_type` introduces late-bound\n-        // lifetimes defined elsewhere, which we need to anonymize away.\n-        let sig = self.tcx.anonymize_late_bound_regions(&sig);\n+        debug!(\"check_closure: ty_of_closure returns {:?}\", liberated_sig);\n \n-        debug!(\"check_closure: anonymized sig={:?}\", sig);\n+        let interior = check_fn(self, self.param_env, liberated_sig, decl, expr.id, body, true).1;\n \n         // Create type variables (for now) to represent the transformed\n         // types of upvars. These will be unified during the upvar\n@@ -75,14 +81,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 |_, _| span_bug!(expr.span, \"closure has region param\"),\n                 |_, _| self.infcx.next_ty_var(TypeVariableOrigin::TransformedUpvar(expr.span))\n         );\n-\n-        let fn_sig = self.liberate_late_bound_regions(expr_def_id, &sig);\n-        let fn_sig = self.inh.normalize_associated_types_in(body.value.span,\n-                                                            body.value.id,\n-                                                            self.param_env,\n-                                                            &fn_sig);\n-\n-        let interior = check_fn(self, self.param_env, fn_sig, decl, expr.id, body, true).1;\n+        let closure_type = self.tcx.mk_closure(expr_def_id, substs);\n \n         if let Some(interior) = interior {\n             let closure_substs = ty::ClosureSubsts {\n@@ -91,13 +90,11 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             return self.tcx.mk_generator(expr_def_id, closure_substs, interior);\n         }\n \n-        let closure_type = self.tcx.mk_closure(expr_def_id, substs);\n-\n         debug!(\"check_closure: expr.id={:?} closure_type={:?}\", expr.id, closure_type);\n \n         // Tuple up the arguments and insert the resulting function type into\n         // the `closures` table.\n-        let sig = sig.map_bound(|sig| self.tcx.mk_fn_sig(\n+        let sig = bound_sig.map_bound(|sig| self.tcx.mk_fn_sig(\n             iter::once(self.tcx.intern_tup(sig.inputs(), false)),\n             sig.output(),\n             sig.variadic,\n@@ -271,71 +268,214 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n+    fn sig_of_closure(&self,\n+                      expr_def_id: DefId,\n+                      decl: &hir::FnDecl,\n+                      body: &hir::Body,\n+                      expected_sig: Option<ty::FnSig<'tcx>>)\n+                      -> ClosureSignatures<'tcx>\n+    {\n+        if let Some(e) = expected_sig {\n+            self.sig_of_closure_with_expectation(expr_def_id, decl, body, e)\n+        } else {\n+            self.sig_of_closure_no_expectation(expr_def_id, decl, body)\n+        }\n+    }\n+\n+    /// If there is no expected signature, then we will convert the\n+    /// types that the user gave into a signature.\n+    fn sig_of_closure_no_expectation(&self,\n+                                     expr_def_id: DefId,\n+                                     decl: &hir::FnDecl,\n+                                     body: &hir::Body)\n+                                     -> ClosureSignatures<'tcx>\n+    {\n+        debug!(\"sig_of_closure_no_expectation()\");\n+\n+        let bound_sig = self.supplied_sig_of_closure(decl);\n+\n+        self.closure_sigs(expr_def_id, body, bound_sig)\n+    }\n+\n     /// Invoked to compute the signature of a closure expression. This\n     /// combines any user-provided type annotations (e.g., `|x: u32|\n     /// -> u32 { .. }`) with the expected signature.\n     ///\n-    /// The arguments here are a bit odd-ball:\n+    /// The approach is as follows:\n+    ///\n+    /// - Let `S` be the (higher-ranked) signature that we derive from the user's annotations.\n+    /// - Let `E` be the (higher-ranked) signature that we derive from the expectations, if any.\n+    ///   - If we have no expectation `E`, then the signature of the closure is `S`.\n+    ///   - Otherwise, the signature of the closure is E. Moreover:\n+    ///     - Skolemize the late-bound regions in `E`, yielding `E'`.\n+    ///     - Instantiate all the late-bound regions bound in the closure within `S`\n+    ///       with fresh (existential) variables, yielding `S'`\n+    ///     - Require that `E' = S'`\n+    ///       - We could use some kind of subtyping relationship here,\n+    ///         I imagine, but equality is easier and works fine for\n+    ///         our purposes.\n+    ///\n+    /// The key intuition here is that the user's types must be valid\n+    /// from \"the inside\" of the closure, but the expectation\n+    /// ultimately drives the overall signature.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// fn with_closure<F>(_: F)\n+    ///   where F: Fn(&u32) -> &u32 { .. }\n+    ///\n+    /// with_closure(|x: &u32| { ... })\n+    /// ```\n+    ///\n+    /// Here:\n+    /// - E would be `fn(&u32) -> &u32`.\n+    /// - S would be `fn(&u32) ->\n+    /// - E' is `&'!0 u32 -> &'!0 u32`\n+    /// - S' is `&'?0 u32 -> ?T`\n+    ///\n+    /// S' can be unified with E' with `['?0 = '!0, ?T = &'!10 u32]`.\n+    ///\n+    /// # Arguments\n     ///\n+    /// - `expr_def_id`: the def-id of the closure expression\n     /// - `decl`: the HIR declaration of the closure\n+    /// - `body`: the body of the closure\n     /// - `expected_sig`: the expected signature (if any). Note that\n     ///   this is missing a binder: that is, there may be late-bound\n     ///   regions with depth 1, which are bound then by the closure.\n-    fn ty_of_closure(&self,\n-                     decl: &hir::FnDecl,\n-                     expected_sig: Option<ty::FnSig<'tcx>>)\n-                     -> ty::PolyFnSig<'tcx>\n+    fn sig_of_closure_with_expectation(&self,\n+                                       expr_def_id: DefId,\n+                                       decl: &hir::FnDecl,\n+                                       body: &hir::Body,\n+                                       expected_sig: ty::FnSig<'tcx>)\n+                                       -> ClosureSignatures<'tcx>\n     {\n-        let astconv: &AstConv = self;\n-\n-        debug!(\"ty_of_closure(expected_sig={:?})\",\n-               expected_sig);\n+        debug!(\"sig_of_closure_with_expectation(expected_sig={:?})\", expected_sig);\n+\n+        // Watch out for some surprises and just ignore the\n+        // expectation if things don't see to match up with what we\n+        // expect.\n+        if expected_sig.variadic != decl.variadic {\n+            return self.sig_of_closure_no_expectation(expr_def_id, decl, body);\n+        } else if expected_sig.inputs_and_output.len() != decl.inputs.len() + 1 {\n+            // we could probably handle this case more gracefully\n+            return self.sig_of_closure_no_expectation(expr_def_id, decl, body);\n+        }\n \n-        let input_tys = decl.inputs.iter().enumerate().map(|(i, a)| {\n-            let expected_arg_ty = expected_sig.as_ref().and_then(|e| {\n-                // no guarantee that the correct number of expected args\n-                // were supplied\n-                if i < e.inputs().len() {\n-                    Some(e.inputs()[i])\n-                } else {\n-                    None\n-                }\n-            });\n+        // Create a `PolyFnSig`. Note the oddity that late bound\n+        // regions appearing free in `expected_sig` are now bound up\n+        // in this binder we are creating.\n+        assert!(!expected_sig.has_regions_escaping_depth(1));\n+        let bound_sig =\n+            ty::Binder(self.tcx.mk_fn_sig(\n+                expected_sig.inputs().iter().cloned(),\n+                expected_sig.output(),\n+                decl.variadic,\n+                hir::Unsafety::Normal,\n+                Abi::RustCall));\n+\n+        // `deduce_expectations_from_expected_type` introduces\n+        // late-bound lifetimes defined elsewhere, which we now\n+        // anonymize away, so as not to confuse the user.\n+        let bound_sig = self.tcx.anonymize_late_bound_regions(&bound_sig);\n+\n+        let closure_sigs = self.closure_sigs(expr_def_id, body, bound_sig);\n+\n+        // Up till this point, we have ignored the annotations that the user\n+        // gave. This function will check that they unify successfully.\n+        // Along the way, it also writes out entries for types that the user\n+        // wrote into our tables, which are then later used by the privacy\n+        // check.\n+        self.check_supplied_sig_against_expectation(decl, &closure_sigs);\n+\n+        closure_sigs\n+    }\n \n-            let input_ty = astconv.ty_of_arg(a, expected_arg_ty);\n-            debug!(\"ty_of_closure: i={} input_ty={:?} expected_arg_ty={:?}\",\n-                   i, input_ty, expected_arg_ty);\n+    /// Enforce the user's types against the expectation.  See\n+    /// `sig_of_closure_with_expectation` for details on the overall\n+    /// strategy.\n+    fn check_supplied_sig_against_expectation(&self,\n+                                              decl: &hir::FnDecl,\n+                                              expected_sigs: &ClosureSignatures<'tcx>)\n+    {\n+        // Get the signature S that the user gave.\n+        //\n+        // (See comment on `sig_of_closure_with_expectation` for the\n+        // meaning of these letters.)\n+        let supplied_sig = self.supplied_sig_of_closure(decl);\n+\n+        debug!(\"check_supplied_sig_against_expectation: supplied_sig={:?}\",\n+               supplied_sig);\n+\n+        // The liberated version of this signature should be be a subtype\n+        // of the liberated form of the expectation.\n+        for ((hir_ty, &supplied_ty), expected_ty) in\n+            decl.inputs.iter()\n+            .zip(*supplied_sig.inputs().skip_binder()) // binder moved to (*) below\n+            .zip(expected_sigs.liberated_sig.inputs()) // `liberated_sig` is E'.\n+        {\n+            // Instantiate (this part of..) S to S', i.e., with fresh variables.\n+            let (supplied_ty, _) = self.infcx.replace_late_bound_regions_with_fresh_var(\n+                hir_ty.span,\n+                LateBoundRegionConversionTime::FnCall,\n+                &ty::Binder(supplied_ty)); // recreated from (*) above\n+\n+            // Check that E' = S'.\n+            self.demand_eqtype(hir_ty.span, expected_ty, supplied_ty);\n+        }\n \n-            input_ty\n-        });\n+        let (supplied_output_ty, _) = self.infcx.replace_late_bound_regions_with_fresh_var(\n+            decl.output.span(),\n+            LateBoundRegionConversionTime::FnCall,\n+            &supplied_sig.output());\n+        self.demand_eqtype(decl.output.span(),\n+                           expected_sigs.liberated_sig.output(),\n+                           supplied_output_ty);\n+    }\n \n-        let expected_ret_ty = expected_sig.as_ref().map(|e| e.output());\n+    /// If there is no expected signature, then we will convert the\n+    /// types that the user gave into a signature.\n+    fn supplied_sig_of_closure(&self,\n+                               decl: &hir::FnDecl)\n+                               -> ty::PolyFnSig<'tcx>\n+    {\n+        let astconv: &AstConv = self;\n \n-        let output_ty = match decl.output {\n-            hir::Return(ref output) => {\n-                if let (&hir::TyInfer, Some(expected_ret_ty)) = (&output.node, expected_ret_ty) {\n-                    astconv.record_ty(output.hir_id, expected_ret_ty, output.span);\n-                    expected_ret_ty\n-                } else {\n-                    astconv.ast_ty_to_ty(&output)\n-                }\n-            }\n-            hir::DefaultReturn(span) => {\n-                if let Some(expected_ret_ty) = expected_ret_ty {\n-                    expected_ret_ty\n-                } else {\n-                    astconv.ty_infer(span)\n-                }\n-            }\n+        // First, convert the types that the user supplied (if any).\n+        let supplied_arguments =\n+            decl.inputs\n+                .iter()\n+                .map(|a| astconv.ast_ty_to_ty(a));\n+        let supplied_return = match decl.output {\n+            hir::Return(ref output) => astconv.ast_ty_to_ty(&output),\n+            hir::DefaultReturn(_) => astconv.ty_infer(decl.output.span()),\n         };\n \n-        debug!(\"ty_of_closure: output_ty={:?}\", output_ty);\n-\n-        ty::Binder(self.tcx.mk_fn_sig(\n-            input_tys,\n-            output_ty,\n+        let result = ty::Binder(self.tcx.mk_fn_sig(\n+            supplied_arguments,\n+            supplied_return,\n             decl.variadic,\n             hir::Unsafety::Normal,\n-            Abi::RustCall))\n+            Abi::RustCall));\n+\n+        debug!(\"supplied_sig_of_closure: result={:?}\", result);\n+\n+        result\n+    }\n+\n+    fn closure_sigs(&self,\n+                    expr_def_id: DefId,\n+                    body: &hir::Body,\n+                    bound_sig: ty::PolyFnSig<'tcx>)\n+                    -> ClosureSignatures<'tcx>\n+    {\n+        let liberated_sig = self.liberate_late_bound_regions(expr_def_id, &bound_sig);\n+        let liberated_sig = self.inh.normalize_associated_types_in(body.value.span,\n+                                                                   body.value.id,\n+                                                                   self.param_env,\n+                                                                   &liberated_sig);\n+        ClosureSignatures { bound_sig, liberated_sig }\n     }\n }\n+"}, {"sha": "5227955d7b902441dce6e08c0dcc85faa0b0c947", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/053383dbeff008744fb5dea7c1c8f4fba98cc06e/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/053383dbeff008744fb5dea7c1c8f4fba98cc06e/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=053383dbeff008744fb5dea7c1c8f4fba98cc06e", "patch": "@@ -76,6 +76,7 @@ This API is completely unstable and subject to change.\n #![feature(box_patterns)]\n #![feature(box_syntax)]\n #![feature(conservative_impl_trait)]\n+#![feature(match_default_bindings)]\n #![feature(never_type)]\n #![feature(quote)]\n #![feature(rustc_diagnostic_macros)]"}, {"sha": "9995b00a9a76d9487b646254e9fd0098d591fa57", "filename": "src/test/compile-fail/closure-expected-type/README.md", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/053383dbeff008744fb5dea7c1c8f4fba98cc06e/src%2Ftest%2Fcompile-fail%2Fclosure-expected-type%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/053383dbeff008744fb5dea7c1c8f4fba98cc06e/src%2Ftest%2Fcompile-fail%2Fclosure-expected-type%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fclosure-expected-type%2FREADME.md?ref=053383dbeff008744fb5dea7c1c8f4fba98cc06e", "patch": "@@ -0,0 +1 @@\n+See `src/test/run-pass/closure-expected-type`."}, {"sha": "f1b198a059176a6e425c8f2a871d11263d340d59", "filename": "src/test/compile-fail/closure-expected-type/expect-fn-supply-fn-multiple.rs", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/053383dbeff008744fb5dea7c1c8f4fba98cc06e/src%2Ftest%2Fcompile-fail%2Fclosure-expected-type%2Fexpect-fn-supply-fn-multiple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/053383dbeff008744fb5dea7c1c8f4fba98cc06e/src%2Ftest%2Fcompile-fail%2Fclosure-expected-type%2Fexpect-fn-supply-fn-multiple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fclosure-expected-type%2Fexpect-fn-supply-fn-multiple.rs?ref=053383dbeff008744fb5dea7c1c8f4fba98cc06e", "patch": "@@ -0,0 +1,49 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// must-compile-successfully\n+\n+#![feature(underscore_lifetimes)]\n+#![allow(warnings)]\n+\n+type Different<'a, 'b> = &'a mut (&'a (), &'b ());\n+type Same<'a> = Different<'a, 'a>;\n+\n+fn with_closure_expecting_different<F>(_: F)\n+    where F: for<'a, 'b> FnOnce(Different<'a, 'b>)\n+{\n+}\n+\n+fn with_closure_expecting_different_anon<F>(_: F)\n+    where F: FnOnce(Different<'_, '_>)\n+{\n+}\n+\n+fn supplying_nothing_expecting_anon() {\n+    with_closure_expecting_different_anon(|x: Different| {\n+    })\n+}\n+\n+fn supplying_nothing_expecting_named() {\n+    with_closure_expecting_different(|x: Different| {\n+    })\n+}\n+\n+fn supplying_underscore_expecting_anon() {\n+    with_closure_expecting_different_anon(|x: Different<'_, '_>| {\n+    })\n+}\n+\n+fn supplying_underscore_expecting_named() {\n+    with_closure_expecting_different(|x: Different<'_, '_>| {\n+    })\n+}\n+\n+fn main() { }"}, {"sha": "3f129614ea0c12a651fdd7fc772464177fdde0b9", "filename": "src/test/compile-fail/closure-expected-type/expect-fn-supply-fn.rs", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/053383dbeff008744fb5dea7c1c8f4fba98cc06e/src%2Ftest%2Fcompile-fail%2Fclosure-expected-type%2Fexpect-fn-supply-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/053383dbeff008744fb5dea7c1c8f4fba98cc06e/src%2Ftest%2Fcompile-fail%2Fclosure-expected-type%2Fexpect-fn-supply-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fclosure-expected-type%2Fexpect-fn-supply-fn.rs?ref=053383dbeff008744fb5dea7c1c8f4fba98cc06e", "patch": "@@ -0,0 +1,70 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(underscore_lifetimes)]\n+\n+fn with_closure_expecting_fn_with_free_region<F>(_: F)\n+    where F: for<'a> FnOnce(fn(&'a u32), &i32)\n+{\n+}\n+\n+fn with_closure_expecting_fn_with_bound_region<F>(_: F)\n+    where F: FnOnce(fn(&u32), &i32)\n+{\n+}\n+\n+fn expect_free_supply_free_from_fn<'x>(x: &'x u32) {\n+    // Here, the type given for `'x` \"obscures\" a region from the\n+    // expected signature that is bound at closure level.\n+    with_closure_expecting_fn_with_free_region(|x: fn(&'x u32), y| {});\n+    //~^ ERROR mismatched types\n+    //~| ERROR mismatched types\n+}\n+\n+fn expect_free_supply_free_from_closure() {\n+    // A variant on the previous test. Here, the region `'a` will be\n+    // bound at the closure level, just as is expected, so no error\n+    // results.\n+    type Foo<'a> = fn(&'a u32);\n+    with_closure_expecting_fn_with_free_region(|_x: Foo<'_>, y| {});\n+}\n+\n+fn expect_free_supply_bound() {\n+    // Here, we are given a function whose region is bound at closure level,\n+    // but we expect one bound in the argument. Error results.\n+    with_closure_expecting_fn_with_free_region(|x: fn(&u32), y| {});\n+    //~^ ERROR mismatched types\n+}\n+\n+fn expect_bound_supply_free_from_fn<'x>(x: &'x u32) {\n+    // Here, we are given a `fn(&u32)` but we expect a `fn(&'x\n+    // u32)`. In principle, this could be ok, but we demand equality.\n+    with_closure_expecting_fn_with_bound_region(|x: fn(&'x u32), y| {});\n+    //~^ ERROR mismatched types\n+}\n+\n+fn expect_bound_supply_free_from_closure() {\n+    // A variant on the previous test. Here, the region `'a` will be\n+    // bound at the closure level, but we expect something bound at\n+    // the argument level.\n+    type Foo<'a> = fn(&'a u32);\n+    with_closure_expecting_fn_with_bound_region(|_x: Foo<'_>, y| {});\n+    //~^ ERROR mismatched types\n+}\n+\n+fn expect_bound_supply_bound<'x>(x: &'x u32) {\n+    // No error in this case. The supplied type supplies the bound\n+    // regions, and hence we are able to figure out the type of `y`\n+    // from the expected type\n+    with_closure_expecting_fn_with_bound_region(|x: for<'z> fn(&'z u32), y| {\n+    });\n+}\n+\n+fn main() { }"}, {"sha": "4ccd1c3b4f1fbe02acf6918f35e53efc874fe3e9", "filename": "src/test/compile-fail/closure-expected-type/expect-infer-var-appearing-twice.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/053383dbeff008744fb5dea7c1c8f4fba98cc06e/src%2Ftest%2Fcompile-fail%2Fclosure-expected-type%2Fexpect-infer-var-appearing-twice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/053383dbeff008744fb5dea7c1c8f4fba98cc06e/src%2Ftest%2Fcompile-fail%2Fclosure-expected-type%2Fexpect-infer-var-appearing-twice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fclosure-expected-type%2Fexpect-infer-var-appearing-twice.rs?ref=053383dbeff008744fb5dea7c1c8f4fba98cc06e", "patch": "@@ -0,0 +1,35 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn with_closure<F, A>(_: F)\n+    where F: FnOnce(A, A)\n+{\n+}\n+\n+fn a() {\n+    with_closure(|x: u32, y| {\n+        // We deduce type of `y` from `x`.\n+    });\n+}\n+\n+fn b() {\n+    // Here we take the supplied types, resulting in an error later on.\n+    with_closure(|x: u32, y: i32| {\n+        //~^ ERROR mismatched types\n+    });\n+}\n+\n+fn c() {\n+    with_closure(|x, y: i32| {\n+        // We deduce type of `x` from `y`.\n+    });\n+}\n+\n+fn main() { }"}, {"sha": "f8cb643c8d64659e8a0aea0f3db8014efd8ca42e", "filename": "src/test/compile-fail/closure-expected-type/expect-infer-var-supply-ty-with-bound-region.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/053383dbeff008744fb5dea7c1c8f4fba98cc06e/src%2Ftest%2Fcompile-fail%2Fclosure-expected-type%2Fexpect-infer-var-supply-ty-with-bound-region.rs", "raw_url": "https://github.com/rust-lang/rust/raw/053383dbeff008744fb5dea7c1c8f4fba98cc06e/src%2Ftest%2Fcompile-fail%2Fclosure-expected-type%2Fexpect-infer-var-supply-ty-with-bound-region.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fclosure-expected-type%2Fexpect-infer-var-supply-ty-with-bound-region.rs?ref=053383dbeff008744fb5dea7c1c8f4fba98cc06e", "patch": "@@ -0,0 +1,29 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// must-compile-successfully\n+\n+fn with_closure<F, A>(_: F)\n+    where F: FnOnce(A, &u32)\n+{\n+}\n+\n+fn foo() {\n+    // This version works; we infer `A` to be `u32`, and take the type\n+    // of `y` to be `&u32`.\n+    with_closure(|x: u32, y| {});\n+}\n+\n+fn bar() {\n+    // This version also works.\n+    with_closure(|x: &u32, y| {});\n+}\n+\n+fn main() { }"}, {"sha": "d3c111c5daf158230f158dcb68a8bd281211f9b8", "filename": "src/test/compile-fail/closure-expected-type/expect-infer-var-supply-ty-with-free-region.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/053383dbeff008744fb5dea7c1c8f4fba98cc06e/src%2Ftest%2Fcompile-fail%2Fclosure-expected-type%2Fexpect-infer-var-supply-ty-with-free-region.rs", "raw_url": "https://github.com/rust-lang/rust/raw/053383dbeff008744fb5dea7c1c8f4fba98cc06e/src%2Ftest%2Fcompile-fail%2Fclosure-expected-type%2Fexpect-infer-var-supply-ty-with-free-region.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fclosure-expected-type%2Fexpect-infer-var-supply-ty-with-free-region.rs?ref=053383dbeff008744fb5dea7c1c8f4fba98cc06e", "patch": "@@ -0,0 +1,29 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// must-compile-successfully\n+\n+fn with_closure<F, A>(_: F)\n+    where F: FnOnce(A, &u32)\n+{\n+}\n+\n+fn foo() {\n+    // This version works; we infer `A` to be `u32`, and take the type\n+    // of `y` to be `&u32`.\n+    with_closure(|x: u32, y| {});\n+}\n+\n+fn bar<'x>(x: &'x u32) {\n+    // Same.\n+    with_closure(|x: &'x u32, y| {});\n+}\n+\n+fn main() { }"}, {"sha": "9da12dc901fbaaa9d95c6750cdbcc4a9142f14b1", "filename": "src/test/compile-fail/closure-expected-type/expect-region-supply-region.rs", "status": "added", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/053383dbeff008744fb5dea7c1c8f4fba98cc06e/src%2Ftest%2Fcompile-fail%2Fclosure-expected-type%2Fexpect-region-supply-region.rs", "raw_url": "https://github.com/rust-lang/rust/raw/053383dbeff008744fb5dea7c1c8f4fba98cc06e/src%2Ftest%2Fcompile-fail%2Fclosure-expected-type%2Fexpect-region-supply-region.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fclosure-expected-type%2Fexpect-region-supply-region.rs?ref=053383dbeff008744fb5dea7c1c8f4fba98cc06e", "patch": "@@ -0,0 +1,80 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![allow(warnings)]\n+\n+fn closure_expecting_bound<F>(_: F)\n+    where F: FnOnce(&u32)\n+{\n+}\n+\n+fn closure_expecting_free<'a, F>(_: F)\n+    where F: FnOnce(&'a u32)\n+{\n+}\n+\n+fn expect_bound_supply_nothing() {\n+    // Because `x` is inferred to have a bound region, we cannot allow\n+    // it to escape into `f`:\n+    let mut f: Option<&u32> = None;\n+    closure_expecting_bound(|x| {\n+        f = Some(x); //~ ERROR E0495\n+    });\n+}\n+\n+fn expect_bound_supply_bound() {\n+    // Because `x` is inferred to have a bound region, we cannot allow\n+    // it to escape into `f`, even with an explicit type annotation on\n+    // closure:\n+    let mut f: Option<&u32> = None;\n+    closure_expecting_bound(|x: &u32| {\n+        f = Some(x); //~ ERROR E0495\n+    });\n+}\n+\n+fn expect_bound_supply_named<'x>() {\n+    let mut f: Option<&u32> = None;\n+\n+    // Here we give a type annotation that `x` should be free. We get\n+    // an error because of that.\n+    closure_expecting_bound(|x: &'x u32| {\n+        //~^ ERROR mismatched types\n+        //~| ERROR mismatched types\n+\n+        // And we still cannot let `x` escape into `f`.\n+        f = Some(x);\n+        //~^ ERROR cannot infer\n+    });\n+}\n+\n+fn expect_free_supply_nothing() {\n+    let mut f: Option<&u32> = None;\n+    closure_expecting_free(|x| f = Some(x)); // OK\n+}\n+\n+fn expect_free_supply_bound() {\n+    let mut f: Option<&u32> = None;\n+\n+    // Here, even though the annotation `&u32` could be seen as being\n+    // bound in the closure, we permit it to be defined as a free\n+    // region (which is inferred to something in the fn body).\n+    closure_expecting_free(|x: &u32| f = Some(x)); // OK\n+}\n+\n+fn expect_free_supply_named<'x>() {\n+    let mut f: Option<&u32> = None;\n+\n+    // Here, even though the annotation `&u32` could be seen as being\n+    // bound in the closure, we permit it to be defined as a free\n+    // region (which is inferred to something in the fn body).\n+    closure_expecting_free(|x: &'x u32| f = Some(x)); // OK\n+}\n+\n+fn main() { }"}, {"sha": "377eaadbd6af0d681b7779621d87cbdd1abe4d8a", "filename": "src/test/compile-fail/closure-expected-type/expect-two-infer-vars-supply-ty-with-bound-region.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/053383dbeff008744fb5dea7c1c8f4fba98cc06e/src%2Ftest%2Fcompile-fail%2Fclosure-expected-type%2Fexpect-two-infer-vars-supply-ty-with-bound-region.rs", "raw_url": "https://github.com/rust-lang/rust/raw/053383dbeff008744fb5dea7c1c8f4fba98cc06e/src%2Ftest%2Fcompile-fail%2Fclosure-expected-type%2Fexpect-two-infer-vars-supply-ty-with-bound-region.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fclosure-expected-type%2Fexpect-two-infer-vars-supply-ty-with-bound-region.rs?ref=053383dbeff008744fb5dea7c1c8f4fba98cc06e", "patch": "@@ -0,0 +1,29 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn with_closure<F, A, B>(_: F)\n+    where F: FnOnce(A, B)\n+{\n+}\n+\n+fn a() {\n+    // Type of `y` is unconstrained.\n+    with_closure(|x: u32, y| {}); //~ ERROR E0282\n+}\n+\n+fn b() {\n+    with_closure(|x: u32, y: u32| {}); // OK\n+}\n+\n+fn c() {\n+    with_closure(|x: u32, y: u32| {}); // OK\n+}\n+\n+fn main() { }"}, {"sha": "a97ce4e8cbe5549326e128000b5e2e292c725047", "filename": "src/test/mir-opt/validate_1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/053383dbeff008744fb5dea7c1c8f4fba98cc06e/src%2Ftest%2Fmir-opt%2Fvalidate_1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/053383dbeff008744fb5dea7c1c8f4fba98cc06e/src%2Ftest%2Fmir-opt%2Fvalidate_1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fvalidate_1.rs?ref=053383dbeff008744fb5dea7c1c8f4fba98cc06e", "patch": "@@ -62,7 +62,7 @@ fn main() {\n // fn main::{{closure}}(_1: &ReErased [closure@NodeId(50)], _2: &ReErased mut i32) -> i32 {\n //     ...\n //     bb0: {\n-//         Validate(Acquire, [_1: &ReFree(DefId { krate: CrateNum(0), index: DefIndex(1:11) => validate_1[317d]::main[0]::{{closure}}[0] }, BrEnv) [closure@NodeId(50)], _2: &ReFree(DefId { krate: CrateNum(0), index: DefIndex(1:11) => validate_1[317d]::main[0]::{{closure}}[0] }, BrAnon(1)) mut i32]);\n+//         Validate(Acquire, [_1: &ReFree(DefId { krate: CrateNum(0), index: DefIndex(1:11) => validate_1[317d]::main[0]::{{closure}}[0] }, BrEnv) [closure@NodeId(50)], _2: &ReFree(DefId { krate: CrateNum(0), index: DefIndex(1:11) => validate_1[317d]::main[0]::{{closure}}[0] }, BrAnon(0)) mut i32]);\n //         StorageLive(_3);\n //         Validate(Suspend(ReScope(Remainder(BlockRemainder { block: ItemLocalId(22), first_statement_index: 0 }))), [(*_2): i32]);\n //         _3 = &ReErased (*_2);"}, {"sha": "3585ac0b8be76529025ed7ab98a849a94b731cf4", "filename": "src/test/mir-opt/validate_4.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/053383dbeff008744fb5dea7c1c8f4fba98cc06e/src%2Ftest%2Fmir-opt%2Fvalidate_4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/053383dbeff008744fb5dea7c1c8f4fba98cc06e/src%2Ftest%2Fmir-opt%2Fvalidate_4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fvalidate_4.rs?ref=053383dbeff008744fb5dea7c1c8f4fba98cc06e", "patch": "@@ -78,8 +78,8 @@ fn main() {\n // fn main::{{closure}}(_1: &ReErased [closure@NodeId(60)], _2: &ReErased mut i32) -> bool {\n //     ...\n //     bb0: {\n-//         Validate(Acquire, [_1: &ReFree(DefId { krate: CrateNum(0), index: DefIndex(1:10) => validate_4[317d]::main[0]::{{closure}}[0] }, BrEnv) [closure@NodeId(60)], _2: &ReFree(DefId { krate: CrateNum(0), index: DefIndex(1:10) => validate_4[317d]::main[0]::{{closure}}[0] }, BrAnon(1)) mut i32]);\n-//         Validate(Release, [_1: &ReFree(DefId { krate: CrateNum(0), index: DefIndex(1:10) => validate_4[317d]::main[0]::{{closure}}[0] }, BrEnv) [closure@NodeId(60)], _2: &ReFree(DefId { krate: CrateNum(0), index: DefIndex(1:10) => validate_4[317d]::main[0]::{{closure}}[0] }, BrAnon(1)) mut i32]);\n+//         Validate(Acquire, [_1: &ReFree(DefId { krate: CrateNum(0), index: DefIndex(1:10) => validate_4[317d]::main[0]::{{closure}}[0] }, BrEnv) [closure@NodeId(60)], _2: &ReFree(DefId { krate: CrateNum(0), index: DefIndex(1:10) => validate_4[317d]::main[0]::{{closure}}[0] }, BrAnon(0)) mut i32]);\n+//         Validate(Release, [_1: &ReFree(DefId { krate: CrateNum(0), index: DefIndex(1:10) => validate_4[317d]::main[0]::{{closure}}[0] }, BrEnv) [closure@NodeId(60)], _2: &ReFree(DefId { krate: CrateNum(0), index: DefIndex(1:10) => validate_4[317d]::main[0]::{{closure}}[0] }, BrAnon(0)) mut i32]);\n //         StorageLive(_3);\n //         ...\n //         _0 = const write_42(_3) -> bb1;"}, {"sha": "ae09d72942e55808e3ce1b9c60f9868014f6be49", "filename": "src/test/mir-opt/validate_5.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/053383dbeff008744fb5dea7c1c8f4fba98cc06e/src%2Ftest%2Fmir-opt%2Fvalidate_5.rs", "raw_url": "https://github.com/rust-lang/rust/raw/053383dbeff008744fb5dea7c1c8f4fba98cc06e/src%2Ftest%2Fmir-opt%2Fvalidate_5.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fvalidate_5.rs?ref=053383dbeff008744fb5dea7c1c8f4fba98cc06e", "patch": "@@ -49,7 +49,7 @@ fn main() {\n // fn main::{{closure}}(_1: &ReErased [closure@NodeId(46)], _2: &ReErased mut i32) -> bool {\n //     ...\n //     bb0: {\n-//         Validate(Acquire, [_1: &ReFree(DefId { krate: CrateNum(0), index: DefIndex(1:9) => validate_5[317d]::main[0]::{{closure}}[0] }, BrEnv) [closure@NodeId(46)], _2: &ReFree(DefId { krate: CrateNum(0), index: DefIndex(1:9) => validate_5[317d]::main[0]::{{closure}}[0] }, BrAnon(1)) mut i32]);\n+//         Validate(Acquire, [_1: &ReFree(DefId { krate: CrateNum(0), index: DefIndex(1:9) => validate_5[317d]::main[0]::{{closure}}[0] }, BrEnv) [closure@NodeId(46)], _2: &ReFree(DefId { krate: CrateNum(0), index: DefIndex(1:9) => validate_5[317d]::main[0]::{{closure}}[0] }, BrAnon(0)) mut i32]);\n //         StorageLive(_3);\n //         StorageLive(_4);\n //         Validate(Suspend(ReScope(Node(ItemLocalId(9)))), [(*_2): i32]);"}, {"sha": "fd493e1ff37d6e6b31faa1cdca506d19ff99e6ff", "filename": "src/test/run-pass/closure-expected-type/README.md", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/053383dbeff008744fb5dea7c1c8f4fba98cc06e/src%2Ftest%2Frun-pass%2Fclosure-expected-type%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/053383dbeff008744fb5dea7c1c8f4fba98cc06e/src%2Ftest%2Frun-pass%2Fclosure-expected-type%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclosure-expected-type%2FREADME.md?ref=053383dbeff008744fb5dea7c1c8f4fba98cc06e", "patch": "@@ -0,0 +1,8 @@\n+Some tests targeted at how we deduce the types of closure arguments.\n+This process is a result of some heuristics aimed at combining the\n+*expected type* we have with the *actual types* that we get from\n+inputs. This investigation was kicked off by #38714, which revealed\n+some pretty deep flaws in the ad-hoc way that we were doing things\n+before.\n+\n+See also `src/test/compile-fail/closure-expected-type`."}, {"sha": "8a90a491f7e58c51b8a8d763702feb4010da9f05", "filename": "src/test/run-pass/closure-expected-type/expect-infer-supply-two-infers.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/053383dbeff008744fb5dea7c1c8f4fba98cc06e/src%2Ftest%2Frun-pass%2Fclosure-expected-type%2Fexpect-infer-supply-two-infers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/053383dbeff008744fb5dea7c1c8f4fba98cc06e/src%2Ftest%2Frun-pass%2Fclosure-expected-type%2Fexpect-infer-supply-two-infers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclosure-expected-type%2Fexpect-infer-supply-two-infers.rs?ref=053383dbeff008744fb5dea7c1c8f4fba98cc06e", "patch": "@@ -0,0 +1,26 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn with_closure<A, F>(_: F)\n+    where F: FnOnce(Vec<A>, A)\n+{\n+}\n+\n+fn expect_free_supply_free<'x>(x: &'x u32) {\n+    with_closure(|mut x: Vec<_>, y| {\n+        // Shows that the call to `x.push()` is influencing type of `y`...\n+        x.push(22_u32);\n+\n+        // ...since we now know the type of `y` and can resolve the method call.\n+        y.wrapping_add(1);\n+    });\n+}\n+\n+fn main() { }"}, {"sha": "a1d512105c9337c3523cac698254a370a72cee98", "filename": "src/test/run-pass/closure-expected-type/issue-38714.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/053383dbeff008744fb5dea7c1c8f4fba98cc06e/src%2Ftest%2Frun-pass%2Fclosure-expected-type%2Fissue-38714.rs", "raw_url": "https://github.com/rust-lang/rust/raw/053383dbeff008744fb5dea7c1c8f4fba98cc06e/src%2Ftest%2Frun-pass%2Fclosure-expected-type%2Fissue-38714.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclosure-expected-type%2Fissue-38714.rs?ref=053383dbeff008744fb5dea7c1c8f4fba98cc06e", "patch": "@@ -0,0 +1,26 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+struct UsizeRef<'a> {\n+    a: &'a usize\n+}\n+\n+type RefTo = Box<for<'r> Fn(&'r Vec<usize>) -> UsizeRef<'r>>;\n+\n+fn ref_to<'a>(vec: &'a Vec<usize>) -> UsizeRef<'a> {\n+    UsizeRef{ a: &vec[0]}\n+}\n+\n+fn main() {\n+    // Regression test: this was causing ICEs; it should compile.\n+    let a: RefTo = Box::new(|vec: &Vec<usize>| {\n+        UsizeRef{ a: &vec[0] }\n+    });\n+}"}, {"sha": "0b930b338fd72bef8789051b01faf26a16baee3f", "filename": "src/test/run-pass/closure-expected-type/supply-just-return-type.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/053383dbeff008744fb5dea7c1c8f4fba98cc06e/src%2Ftest%2Frun-pass%2Fclosure-expected-type%2Fsupply-just-return-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/053383dbeff008744fb5dea7c1c8f4fba98cc06e/src%2Ftest%2Frun-pass%2Fclosure-expected-type%2Fsupply-just-return-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclosure-expected-type%2Fsupply-just-return-type.rs?ref=053383dbeff008744fb5dea7c1c8f4fba98cc06e", "patch": "@@ -0,0 +1,35 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn with_closure<F, R>(f: F) -> Result<char, R>\n+    where F: FnOnce(&char) -> Result<char, R>,\n+{\n+    f(&'a')\n+}\n+\n+fn main() {\n+    // Test that supplying the `-> Result<char, ()>` manually here\n+    // (which is needed to constrain `R`) still allows us to figure\n+    // out that the type of `x` is `&'a char` where `'a` is bound in\n+    // the closure (if we didn't, we'd get a type-error because\n+    // `with_closure` requires a bound region).\n+    //\n+    // This pattern was found in the wild.\n+    let z = with_closure(|x| -> Result<char, ()> { Ok(*x) });\n+    assert_eq!(z.unwrap(), 'a');\n+\n+    // It also works with `_`:\n+    let z = with_closure(|x: _| -> Result<char, ()> { Ok(*x) });\n+    assert_eq!(z.unwrap(), 'a');\n+\n+    // It also works with `&_`:\n+    let z = with_closure(|x: &_| -> Result<char, ()> { Ok(*x) });\n+    assert_eq!(z.unwrap(), 'a');\n+}"}, {"sha": "15d8b393c152fc861cc8f65065927f0312219073", "filename": "src/test/run-pass/closure-expected-type/supply-nothing.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/053383dbeff008744fb5dea7c1c8f4fba98cc06e/src%2Ftest%2Frun-pass%2Fclosure-expected-type%2Fsupply-nothing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/053383dbeff008744fb5dea7c1c8f4fba98cc06e/src%2Ftest%2Frun-pass%2Fclosure-expected-type%2Fsupply-nothing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclosure-expected-type%2Fsupply-nothing.rs?ref=053383dbeff008744fb5dea7c1c8f4fba98cc06e", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn with_closure<F>(f: F) -> u32\n+    where F: FnOnce(&u32, &u32) -> u32\n+{\n+    f(&22, &44)\n+}\n+\n+fn main() {\n+    let z = with_closure(|x, y| x + y).wrapping_add(1);\n+    assert_eq!(z, 22 + 44 + 1);\n+}"}]}