{"sha": "1baf3ff7e98ea14e84159e213bd9872efd53e07f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFiYWYzZmY3ZTk4ZWExNGU4NDE1OWUyMTNiZDk4NzJlZmQ1M2UwN2Y=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-08-29T12:29:23Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-08-31T15:37:57Z"}, "message": "Avoid StringReader when checking code blocks for syntax errors\n\n`parse_stream_from_source_str` is a more stable API to convert a\nstring into a bunch of tokens, and it also catches errors about\nmismatched parenthesis.", "tree": {"sha": "6112dfbca79d4379a9b94a719cf2e0788a47f26a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6112dfbca79d4379a9b94a719cf2e0788a47f26a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1baf3ff7e98ea14e84159e213bd9872efd53e07f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1baf3ff7e98ea14e84159e213bd9872efd53e07f", "html_url": "https://github.com/rust-lang/rust/commit/1baf3ff7e98ea14e84159e213bd9872efd53e07f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1baf3ff7e98ea14e84159e213bd9872efd53e07f/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1fd8636d2428658cf46df53fb4f445558689fd1c", "url": "https://api.github.com/repos/rust-lang/rust/commits/1fd8636d2428658cf46df53fb4f445558689fd1c", "html_url": "https://github.com/rust-lang/rust/commit/1fd8636d2428658cf46df53fb4f445558689fd1c"}], "stats": {"total": 75, "additions": 32, "deletions": 43}, "files": [{"sha": "beb1f13ca6f75667a1e66ff4c0791331a354f4f2", "filename": "src/librustdoc/passes/check_code_block_syntax.rs", "status": "modified", "additions": 32, "deletions": 43, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/1baf3ff7e98ea14e84159e213bd9872efd53e07f/src%2Flibrustdoc%2Fpasses%2Fcheck_code_block_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1baf3ff7e98ea14e84159e213bd9872efd53e07f/src%2Flibrustdoc%2Fpasses%2Fcheck_code_block_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcheck_code_block_syntax.rs?ref=1baf3ff7e98ea14e84159e213bd9872efd53e07f", "patch": "@@ -1,7 +1,6 @@\n-use rustc_ast::token;\n use rustc_data_structures::sync::{Lock, Lrc};\n use rustc_errors::{emitter::Emitter, Applicability, Diagnostic, Handler};\n-use rustc_parse::lexer::StringReader as Lexer;\n+use rustc_parse::parse_stream_from_source_str;\n use rustc_session::parse::ParseSess;\n use rustc_span::source_map::{FilePathMapping, SourceMap};\n use rustc_span::{FileName, InnerSpan};\n@@ -28,49 +27,34 @@ struct SyntaxChecker<'a, 'tcx> {\n \n impl<'a, 'tcx> SyntaxChecker<'a, 'tcx> {\n     fn check_rust_syntax(&self, item: &clean::Item, dox: &str, code_block: RustCodeBlock) {\n-        let buffered_messages = Lrc::new(Lock::new(vec![]));\n-\n-        let emitter = BufferEmitter { messages: Lrc::clone(&buffered_messages) };\n+        let buffer = Lrc::new(Lock::new(Buffer::default()));\n+        let emitter = BufferEmitter { buffer: Lrc::clone(&buffer) };\n \n         let sm = Lrc::new(SourceMap::new(FilePathMapping::empty()));\n         let handler = Handler::with_emitter(false, None, Box::new(emitter));\n+        let source = dox[code_block.code].to_owned();\n         let sess = ParseSess::with_span_handler(handler, sm);\n-        let source_file = sess.source_map().new_source_file(\n-            FileName::Custom(String::from(\"doctest\")),\n-            dox[code_block.code].to_owned(),\n-        );\n-\n-        let validation_status = rustc_driver::catch_fatal_errors(|| {\n-            let mut has_syntax_errors = false;\n-            let mut only_whitespace = true;\n-            // even if there is a syntax error, we need to run the lexer over the whole file\n-            let mut lexer = Lexer::new(&sess, source_file, None);\n-            loop {\n-                match lexer.next_token().kind {\n-                    token::Eof => break,\n-                    token::Whitespace => (),\n-                    token::Unknown(..) => has_syntax_errors = true,\n-                    _ => only_whitespace = false,\n-                }\n-            }\n \n-            if has_syntax_errors {\n-                Some(CodeBlockInvalid::SyntaxError)\n-            } else if only_whitespace {\n-                Some(CodeBlockInvalid::Empty)\n-            } else {\n-                None\n-            }\n+        let is_empty = rustc_driver::catch_fatal_errors(|| {\n+            parse_stream_from_source_str(\n+                FileName::Custom(String::from(\"doctest\")),\n+                source,\n+                &sess,\n+                None,\n+            )\n+            .is_empty()\n         })\n-        .unwrap_or(Some(CodeBlockInvalid::SyntaxError));\n+        .unwrap_or(false);\n+        let buffer = buffer.borrow();\n \n-        if let Some(code_block_invalid) = validation_status {\n+        if buffer.has_errors || is_empty {\n             let mut diag = if let Some(sp) =\n                 super::source_span_for_markdown_range(self.cx, &dox, &code_block.range, &item.attrs)\n             {\n-                let warning_message = match code_block_invalid {\n-                    CodeBlockInvalid::SyntaxError => \"could not parse code block as Rust code\",\n-                    CodeBlockInvalid::Empty => \"Rust code block is empty\",\n+                let warning_message = if buffer.has_errors {\n+                    \"could not parse code block as Rust code\"\n+                } else {\n+                    \"Rust code block is empty\"\n                 };\n \n                 let mut diag = self.cx.sess().struct_span_warn(sp, warning_message);\n@@ -102,7 +86,7 @@ impl<'a, 'tcx> SyntaxChecker<'a, 'tcx> {\n             };\n \n             // FIXME(#67563): Provide more context for these errors by displaying the spans inline.\n-            for message in buffered_messages.borrow().iter() {\n+            for message in buffer.messages.iter() {\n                 diag.note(&message);\n             }\n \n@@ -125,21 +109,26 @@ impl<'a, 'tcx> DocFolder for SyntaxChecker<'a, 'tcx> {\n     }\n }\n \n+#[derive(Default)]\n+struct Buffer {\n+    messages: Vec<String>,\n+    has_errors: bool,\n+}\n+\n struct BufferEmitter {\n-    messages: Lrc<Lock<Vec<String>>>,\n+    buffer: Lrc<Lock<Buffer>>,\n }\n \n impl Emitter for BufferEmitter {\n     fn emit_diagnostic(&mut self, diag: &Diagnostic) {\n-        self.messages.borrow_mut().push(format!(\"error from rustc: {}\", diag.message[0].0));\n+        let mut buffer = self.buffer.borrow_mut();\n+        buffer.messages.push(format!(\"error from rustc: {}\", diag.message[0].0));\n+        if diag.is_error() {\n+            buffer.has_errors = true;\n+        }\n     }\n \n     fn source_map(&self) -> Option<&Lrc<SourceMap>> {\n         None\n     }\n }\n-\n-enum CodeBlockInvalid {\n-    SyntaxError,\n-    Empty,\n-}"}]}