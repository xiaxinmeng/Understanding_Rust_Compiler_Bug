{"sha": "327323ad25d126f6394f26e1442667647022c383", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMyNzMyM2FkMjVkMTI2ZjYzOTRmMjZlMTQ0MjY2NzY0NzAyMmMzODM=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2021-04-13T09:49:10Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2021-04-13T09:56:24Z"}, "message": "internal: fix flakiness of accidentally quadratic test", "tree": {"sha": "52612ccaa72c77f05997fda81af51e956d94a78d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/52612ccaa72c77f05997fda81af51e956d94a78d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/327323ad25d126f6394f26e1442667647022c383", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/327323ad25d126f6394f26e1442667647022c383", "html_url": "https://github.com/rust-lang/rust/commit/327323ad25d126f6394f26e1442667647022c383", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/327323ad25d126f6394f26e1442667647022c383/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6081b437cc842f8885c26636bef8af4cbc5483e3", "url": "https://api.github.com/repos/rust-lang/rust/commits/6081b437cc842f8885c26636bef8af4cbc5483e3", "html_url": "https://github.com/rust-lang/rust/commit/6081b437cc842f8885c26636bef8af4cbc5483e3"}], "stats": {"total": 213, "additions": 131, "deletions": 82}, "files": [{"sha": "933cfa6f314267f2ea5bd1aa6954b351d8a969c2", "filename": "crates/ide/src/syntax_highlighting/tests.rs", "status": "modified", "additions": 17, "deletions": 81, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/327323ad25d126f6394f26e1442667647022c383/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/327323ad25d126f6394f26e1442667647022c383/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Ftests.rs?ref=327323ad25d126f6394f26e1442667647022c383", "patch": "@@ -2,8 +2,7 @@ use std::time::Instant;\n \n use expect_test::{expect_file, ExpectFile};\n use ide_db::SymbolKind;\n-use stdx::format_to;\n-use test_utils::{bench, bench_fixture, skip_slow_tests};\n+use test_utils::{bench, bench_fixture, skip_slow_tests, AssertLinear};\n \n use crate::{fixture, FileRange, HlTag, TextRange};\n \n@@ -266,90 +265,27 @@ fn syntax_highlighting_not_quadratic() {\n         return;\n     }\n \n-    let mut measures = Vec::new();\n-    for i in 6..=10 {\n-        let n = 1 << i;\n-        let fixture = bench_fixture::big_struct_n(n);\n-        let (analysis, file_id) = fixture::file(&fixture);\n+    let mut al = AssertLinear::default();\n+    while al.next_round() {\n+        for i in 6..=10 {\n+            let n = 1 << i;\n \n-        let time = Instant::now();\n+            let fixture = bench_fixture::big_struct_n(n);\n+            let (analysis, file_id) = fixture::file(&fixture);\n \n-        let hash = analysis\n-            .highlight(file_id)\n-            .unwrap()\n-            .iter()\n-            .filter(|it| it.highlight.tag == HlTag::Symbol(SymbolKind::Struct))\n-            .count();\n-        assert!(hash > n as usize);\n+            let time = Instant::now();\n \n-        let elapsed = time.elapsed();\n-        measures.push((n as f64, elapsed.as_millis() as f64))\n-    }\n+            let hash = analysis\n+                .highlight(file_id)\n+                .unwrap()\n+                .iter()\n+                .filter(|it| it.highlight.tag == HlTag::Symbol(SymbolKind::Struct))\n+                .count();\n+            assert!(hash > n as usize);\n \n-    assert_linear(&measures)\n-}\n-\n-/// Checks that a set of measurements looks like a linear function rather than\n-/// like a quadratic function. Algorithm:\n-///\n-/// 1. Linearly scale input to be in [0; 1)\n-/// 2. Using linear regression, compute the best linear function approximating\n-///    the input.\n-/// 3. Compute RMSE and  maximal absolute error.\n-/// 4. Check that errors are within tolerances and that the constant term is not\n-///    too negative.\n-///\n-/// Ideally, we should use a proper \"model selection\" to directly compare\n-/// quadratic and linear models, but that sounds rather complicated:\n-///\n-///     https://stats.stackexchange.com/questions/21844/selecting-best-model-based-on-linear-quadratic-and-cubic-fit-of-data\n-fn assert_linear(xy: &[(f64, f64)]) {\n-    let (mut xs, mut ys): (Vec<_>, Vec<_>) = xy.iter().copied().unzip();\n-    normalize(&mut xs);\n-    normalize(&mut ys);\n-    let xy = xs.iter().copied().zip(ys.iter().copied());\n-\n-    // Linear regression: finding a and b to fit y = a + b*x.\n-\n-    let mean_x = mean(&xs);\n-    let mean_y = mean(&ys);\n-\n-    let b = {\n-        let mut num = 0.0;\n-        let mut denom = 0.0;\n-        for (x, y) in xy.clone() {\n-            num += (x - mean_x) * (y - mean_y);\n-            denom += (x - mean_x).powi(2);\n+            let elapsed = time.elapsed();\n+            al.sample(n as f64, elapsed.as_millis() as f64);\n         }\n-        num / denom\n-    };\n-\n-    let a = mean_y - b * mean_x;\n-\n-    let mut plot = format!(\"y_pred = {:.3} + {:.3} * x\\n\\nx     y     y_pred\\n\", a, b);\n-\n-    let mut se = 0.0;\n-    let mut max_error = 0.0f64;\n-    for (x, y) in xy {\n-        let y_pred = a + b * x;\n-        se += (y - y_pred).powi(2);\n-        max_error = max_error.max((y_pred - y).abs());\n-\n-        format_to!(plot, \"{:.3} {:.3} {:.3}\\n\", x, y, y_pred);\n-    }\n-\n-    let rmse = (se / xs.len() as f64).sqrt();\n-    format_to!(plot, \"\\nrmse = {:.3} max error = {:.3}\", rmse, max_error);\n-\n-    assert!(rmse < 0.05 && max_error < 0.1 && a > -0.1, \"\\nLooks quadratic\\n{}\", plot);\n-\n-    fn normalize(xs: &mut Vec<f64>) {\n-        let max = xs.iter().copied().max_by(|a, b| a.partial_cmp(b).unwrap()).unwrap();\n-        xs.iter_mut().for_each(|it| *it /= max);\n-    }\n-\n-    fn mean(xs: &[f64]) -> f64 {\n-        xs.iter().copied().sum::<f64>() / (xs.len() as f64)\n     }\n }\n "}, {"sha": "6ecc232e1eee6915c04709b65d16ca5bca225e2f", "filename": "crates/test_utils/src/assert_linear.rs", "status": "added", "additions": 112, "deletions": 0, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/327323ad25d126f6394f26e1442667647022c383/crates%2Ftest_utils%2Fsrc%2Fassert_linear.rs", "raw_url": "https://github.com/rust-lang/rust/raw/327323ad25d126f6394f26e1442667647022c383/crates%2Ftest_utils%2Fsrc%2Fassert_linear.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Ftest_utils%2Fsrc%2Fassert_linear.rs?ref=327323ad25d126f6394f26e1442667647022c383", "patch": "@@ -0,0 +1,112 @@\n+//! Checks that a set of measurements looks like a linear function rather than\n+//! like a quadratic function. Algorithm:\n+//!\n+//! 1. Linearly scale input to be in [0; 1)\n+//! 2. Using linear regression, compute the best linear function approximating\n+//!    the input.\n+//! 3. Compute RMSE and  maximal absolute error.\n+//! 4. Check that errors are within tolerances and that the constant term is not\n+//!    too negative.\n+//!\n+//! Ideally, we should use a proper \"model selection\" to directly compare\n+//! quadratic and linear models, but that sounds rather complicated:\n+//!\n+//!     https://stats.stackexchange.com/questions/21844/selecting-best-model-based-on-linear-quadratic-and-cubic-fit-of-data\n+//!\n+//! We might get false positives on a VM, but never false negatives. So, if the\n+//! first round fails, we repeat the ordeal three more times and fail only if\n+//! every time there's a fault.\n+use stdx::format_to;\n+\n+#[derive(Default)]\n+pub struct AssertLinear {\n+    rounds: Vec<Round>,\n+}\n+\n+#[derive(Default)]\n+struct Round {\n+    samples: Vec<(f64, f64)>,\n+    plot: String,\n+    linear: bool,\n+}\n+\n+impl AssertLinear {\n+    pub fn next_round(&mut self) -> bool {\n+        if let Some(round) = self.rounds.last_mut() {\n+            round.finish();\n+        }\n+        if self.rounds.iter().any(|it| it.linear) || self.rounds.len() == 4 {\n+            return false;\n+        }\n+        self.rounds.push(Round::default());\n+        true\n+    }\n+\n+    pub fn sample(&mut self, x: f64, y: f64) {\n+        self.rounds.last_mut().unwrap().samples.push((x, y))\n+    }\n+}\n+\n+impl Drop for AssertLinear {\n+    fn drop(&mut self) {\n+        assert!(!self.rounds.is_empty());\n+        if self.rounds.iter().all(|it| !it.linear) {\n+            for round in &self.rounds {\n+                eprintln!(\"\\n{}\", round.plot);\n+            }\n+            panic!(\"Doesn't look linear!\")\n+        }\n+    }\n+}\n+\n+impl Round {\n+    fn finish(&mut self) {\n+        let (mut xs, mut ys): (Vec<_>, Vec<_>) = self.samples.iter().copied().unzip();\n+        normalize(&mut xs);\n+        normalize(&mut ys);\n+        let xy = xs.iter().copied().zip(ys.iter().copied());\n+\n+        // Linear regression: finding a and b to fit y = a + b*x.\n+\n+        let mean_x = mean(&xs);\n+        let mean_y = mean(&ys);\n+\n+        let b = {\n+            let mut num = 0.0;\n+            let mut denom = 0.0;\n+            for (x, y) in xy.clone() {\n+                num += (x - mean_x) * (y - mean_y);\n+                denom += (x - mean_x).powi(2);\n+            }\n+            num / denom\n+        };\n+\n+        let a = mean_y - b * mean_x;\n+\n+        self.plot = format!(\"y_pred = {:.3} + {:.3} * x\\n\\nx     y     y_pred\\n\", a, b);\n+\n+        let mut se = 0.0;\n+        let mut max_error = 0.0f64;\n+        for (x, y) in xy {\n+            let y_pred = a + b * x;\n+            se += (y - y_pred).powi(2);\n+            max_error = max_error.max((y_pred - y).abs());\n+\n+            format_to!(self.plot, \"{:.3} {:.3} {:.3}\\n\", x, y, y_pred);\n+        }\n+\n+        let rmse = (se / xs.len() as f64).sqrt();\n+        format_to!(self.plot, \"\\nrmse = {:.3} max error = {:.3}\", rmse, max_error);\n+\n+        self.linear = rmse < 0.05 && max_error < 0.1 && a > -0.1;\n+\n+        fn normalize(xs: &mut Vec<f64>) {\n+            let max = xs.iter().copied().max_by(|a, b| a.partial_cmp(b).unwrap()).unwrap();\n+            xs.iter_mut().for_each(|it| *it /= max);\n+        }\n+\n+        fn mean(xs: &[f64]) -> f64 {\n+            xs.iter().copied().sum::<f64>() / (xs.len() as f64)\n+        }\n+    }\n+}"}, {"sha": "72466c9570f9b4245fd1b6d6b2732f1c08fbab9b", "filename": "crates/test_utils/src/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/327323ad25d126f6394f26e1442667647022c383/crates%2Ftest_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/327323ad25d126f6394f26e1442667647022c383/crates%2Ftest_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Ftest_utils%2Fsrc%2Flib.rs?ref=327323ad25d126f6394f26e1442667647022c383", "patch": "@@ -8,6 +8,7 @@\n \n pub mod bench_fixture;\n mod fixture;\n+mod assert_linear;\n \n use std::{\n     convert::{TryFrom, TryInto},\n@@ -22,7 +23,7 @@ use text_size::{TextRange, TextSize};\n pub use dissimilar::diff as __diff;\n pub use rustc_hash::FxHashMap;\n \n-pub use crate::fixture::Fixture;\n+pub use crate::{assert_linear::AssertLinear, fixture::Fixture};\n \n pub const CURSOR_MARKER: &str = \"$0\";\n pub const ESCAPED_CURSOR_MARKER: &str = \"\\\\$0\";"}]}