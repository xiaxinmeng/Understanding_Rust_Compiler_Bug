{"sha": "72c99f2cf0021fe119dd3de8272349f679188150", "node_id": "MDY6Q29tbWl0NzI0NzEyOjcyYzk5ZjJjZjAwMjFmZTExOWRkM2RlODI3MjM0OWY2NzkxODgxNTA=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2020-03-23T23:49:41Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-03-23T23:49:41Z"}, "message": "Rollup merge of #70087 - ecstatic-morse:remove-const-eval-loop-detector, r=RalfJung\n\nRemove const eval loop detector\n\nNow that there is a configurable instruction limit for CTFE (see #67260), we can replace the loop detector with something much simpler. See #66946 for more discussion about this. Although the instruction limit is nightly-only, the only practical way to reach the default limit uses nightly-only features as well (although CTFE will still execute code using such features inside an array initializer on stable).\n\nThis will at the very least require a crater run, since it will result in an error wherever the \"long running const eval\" warning appeared before. We may need to increase the default for `const_eval_limit` to work around this.\n\nResolves #54384 cc #49980\nr? @oli-obk cc @RalfJung", "tree": {"sha": "c5a6422a7f77abed9bfdb7f3de180c82db9a3a09", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c5a6422a7f77abed9bfdb7f3de180c82db9a3a09"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/72c99f2cf0021fe119dd3de8272349f679188150", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJeeUsVCRBK7hj4Ov3rIwAAdHIIAAQRhkHUjsczR/0rPjvh9uwj\n+2XXFo8/GsdiouPV5pvctXYzgZZHTTkfvSSuEGjk8Qb/ty+wdV8CwjYLrt1A3UgH\n3MAUEBAalQbv0izDgSWRueu/XpIMIc2fIc8j6wc0LoqMB5l8HV+UP3X03jBiMLr7\nixxvw4qJqw9vR2R0sanCja3gfrTamyEh86VmRC/yWrLdA23q8xWbz4KimPktfyxV\nxyhV5kTpclQCwzO19EzybF2Hu/yirVwryvh1eZP0NpS0iHUtHbcAW+FAMt7KlY48\nM7xmZGU8dhIV5aXm90bj6uS4F0rNv0TwYB782hE8xtJgSSNk4J6JPrpWGCSDsQE=\n=PAgp\n-----END PGP SIGNATURE-----\n", "payload": "tree c5a6422a7f77abed9bfdb7f3de180c82db9a3a09\nparent a73ed5aad9afb76bf5ba391641f0cb6c86299242\nparent b5636b8437feecc3474e607f60891f3ebc098ded\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1585007381 +0100\ncommitter GitHub <noreply@github.com> 1585007381 +0100\n\nRollup merge of #70087 - ecstatic-morse:remove-const-eval-loop-detector, r=RalfJung\n\nRemove const eval loop detector\n\nNow that there is a configurable instruction limit for CTFE (see #67260), we can replace the loop detector with something much simpler. See #66946 for more discussion about this. Although the instruction limit is nightly-only, the only practical way to reach the default limit uses nightly-only features as well (although CTFE will still execute code using such features inside an array initializer on stable).\n\nThis will at the very least require a crater run, since it will result in an error wherever the \"long running const eval\" warning appeared before. We may need to increase the default for `const_eval_limit` to work around this.\n\nResolves #54384 cc #49980\nr? @oli-obk cc @RalfJung\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/72c99f2cf0021fe119dd3de8272349f679188150", "html_url": "https://github.com/rust-lang/rust/commit/72c99f2cf0021fe119dd3de8272349f679188150", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/72c99f2cf0021fe119dd3de8272349f679188150/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a73ed5aad9afb76bf5ba391641f0cb6c86299242", "url": "https://api.github.com/repos/rust-lang/rust/commits/a73ed5aad9afb76bf5ba391641f0cb6c86299242", "html_url": "https://github.com/rust-lang/rust/commit/a73ed5aad9afb76bf5ba391641f0cb6c86299242"}, {"sha": "b5636b8437feecc3474e607f60891f3ebc098ded", "url": "https://api.github.com/repos/rust-lang/rust/commits/b5636b8437feecc3474e607f60891f3ebc098ded", "html_url": "https://github.com/rust-lang/rust/commit/b5636b8437feecc3474e607f60891f3ebc098ded"}], "stats": {"total": 637, "additions": 73, "deletions": 564}, "files": [{"sha": "6dfe97933ce343c669a869613ead83a73adc2eaf", "filename": "src/librustc/mir/interpret/error.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/72c99f2cf0021fe119dd3de8272349f679188150/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72c99f2cf0021fe119dd3de8272349f679188150/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs?ref=72c99f2cf0021fe119dd3de8272349f679188150", "patch": "@@ -494,8 +494,10 @@ impl fmt::Debug for UnsupportedOpInfo {\n pub enum ResourceExhaustionInfo {\n     /// The stack grew too big.\n     StackFrameLimitReached,\n-    /// The program ran into an infinite loop.\n-    InfiniteLoop,\n+    /// The program ran for too long.\n+    ///\n+    /// The exact limit is set by the `const_eval_limit` attribute.\n+    StepLimitReached,\n }\n \n impl fmt::Debug for ResourceExhaustionInfo {\n@@ -505,11 +507,9 @@ impl fmt::Debug for ResourceExhaustionInfo {\n             StackFrameLimitReached => {\n                 write!(f, \"reached the configured maximum number of stack frames\")\n             }\n-            InfiniteLoop => write!(\n-                f,\n-                \"duplicate interpreter state observed here, const evaluation will never \\\n-                    terminate\"\n-            ),\n+            StepLimitReached => {\n+                write!(f, \"exceeded interpreter step limit (see `#[const_eval_limit]`)\")\n+            }\n         }\n     }\n }"}, {"sha": "ab88a92ea7bc210bae9d1cd76f9bd61d7a4a9e8a", "filename": "src/librustc_mir/const_eval/machine.rs", "status": "modified", "additions": 20, "deletions": 47, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/72c99f2cf0021fe119dd3de8272349f679188150/src%2Flibrustc_mir%2Fconst_eval%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72c99f2cf0021fe119dd3de8272349f679188150/src%2Flibrustc_mir%2Fconst_eval%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval%2Fmachine.rs?ref=72c99f2cf0021fe119dd3de8272349f679188150", "patch": "@@ -3,7 +3,6 @@ use rustc::ty::layout::HasTyCtxt;\n use rustc::ty::{self, Ty};\n use std::borrow::{Borrow, Cow};\n use std::collections::hash_map::Entry;\n-use std::convert::TryFrom;\n use std::hash::Hash;\n \n use rustc_data_structures::fx::FxHashMap;\n@@ -13,13 +12,13 @@ use rustc_span::source_map::Span;\n use rustc_span::symbol::Symbol;\n \n use crate::interpret::{\n-    self, snapshot, AllocId, Allocation, GlobalId, ImmTy, InterpCx, InterpResult, Memory,\n-    MemoryKind, OpTy, PlaceTy, Pointer, Scalar,\n+    self, AllocId, Allocation, GlobalId, ImmTy, InterpCx, InterpResult, Memory, MemoryKind, OpTy,\n+    PlaceTy, Pointer, Scalar,\n };\n \n use super::error::*;\n \n-impl<'mir, 'tcx> InterpCx<'mir, 'tcx, CompileTimeInterpreter<'mir, 'tcx>> {\n+impl<'mir, 'tcx> InterpCx<'mir, 'tcx, CompileTimeInterpreter> {\n     /// Evaluate a const function where all arguments (if any) are zero-sized types.\n     /// The evaluation is memoized thanks to the query system.\n     ///\n@@ -86,22 +85,13 @@ impl<'mir, 'tcx> InterpCx<'mir, 'tcx, CompileTimeInterpreter<'mir, 'tcx>> {\n     }\n }\n \n-/// The number of steps between loop detector snapshots.\n-/// Should be a power of two for performance reasons.\n-const DETECTOR_SNAPSHOT_PERIOD: isize = 256;\n-\n-// Extra machine state for CTFE, and the Machine instance\n-pub struct CompileTimeInterpreter<'mir, 'tcx> {\n-    /// When this value is negative, it indicates the number of interpreter\n-    /// steps *until* the loop detector is enabled. When it is positive, it is\n-    /// the number of steps after the detector has been enabled modulo the loop\n-    /// detector period.\n-    pub(super) steps_since_detector_enabled: isize,\n-\n-    pub(super) is_detector_enabled: bool,\n-\n-    /// Extra state to detect loops.\n-    pub(super) loop_detector: snapshot::InfiniteLoopDetector<'mir, 'tcx>,\n+/// Extra machine state for CTFE, and the Machine instance\n+pub struct CompileTimeInterpreter {\n+    /// For now, the number of terminators that can be evaluated before we throw a resource\n+    /// exhuastion error.\n+    ///\n+    /// Setting this to `0` disables the limit and allows the interpreter to run forever.\n+    pub steps_remaining: usize,\n }\n \n #[derive(Copy, Clone, Debug)]\n@@ -110,16 +100,9 @@ pub struct MemoryExtra {\n     pub(super) can_access_statics: bool,\n }\n \n-impl<'mir, 'tcx> CompileTimeInterpreter<'mir, 'tcx> {\n+impl CompileTimeInterpreter {\n     pub(super) fn new(const_eval_limit: usize) -> Self {\n-        let steps_until_detector_enabled =\n-            isize::try_from(const_eval_limit).unwrap_or(std::isize::MAX);\n-\n-        CompileTimeInterpreter {\n-            loop_detector: Default::default(),\n-            steps_since_detector_enabled: -steps_until_detector_enabled,\n-            is_detector_enabled: const_eval_limit != 0,\n-        }\n+        CompileTimeInterpreter { steps_remaining: const_eval_limit }\n     }\n }\n \n@@ -173,8 +156,7 @@ impl<K: Hash + Eq, V> interpret::AllocMap<K, V> for FxHashMap<K, V> {\n     }\n }\n \n-crate type CompileTimeEvalContext<'mir, 'tcx> =\n-    InterpCx<'mir, 'tcx, CompileTimeInterpreter<'mir, 'tcx>>;\n+crate type CompileTimeEvalContext<'mir, 'tcx> = InterpCx<'mir, 'tcx, CompileTimeInterpreter>;\n \n impl interpret::MayLeak for ! {\n     #[inline(always)]\n@@ -184,7 +166,7 @@ impl interpret::MayLeak for ! {\n     }\n }\n \n-impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir, 'tcx> {\n+impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter {\n     type MemoryKinds = !;\n     type PointerTag = ();\n     type ExtraFnVal = !;\n@@ -345,26 +327,17 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n     }\n \n     fn before_terminator(ecx: &mut InterpCx<'mir, 'tcx, Self>) -> InterpResult<'tcx> {\n-        if !ecx.machine.is_detector_enabled {\n+        // The step limit has already been hit in a previous call to `before_terminator`.\n+        if ecx.machine.steps_remaining == 0 {\n             return Ok(());\n         }\n \n-        {\n-            let steps = &mut ecx.machine.steps_since_detector_enabled;\n-\n-            *steps += 1;\n-            if *steps < 0 {\n-                return Ok(());\n-            }\n-\n-            *steps %= DETECTOR_SNAPSHOT_PERIOD;\n-            if *steps != 0 {\n-                return Ok(());\n-            }\n+        ecx.machine.steps_remaining -= 1;\n+        if ecx.machine.steps_remaining == 0 {\n+            throw_exhaust!(StepLimitReached)\n         }\n \n-        let span = ecx.frame().span;\n-        ecx.machine.loop_detector.observe_and_analyze(*ecx.tcx, span, &ecx.memory, &ecx.stack[..])\n+        Ok(())\n     }\n \n     #[inline(always)]"}, {"sha": "277a77af3fd56efc5d448ef179bda2c2ef173cc2", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/72c99f2cf0021fe119dd3de8272349f679188150/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72c99f2cf0021fe119dd3de8272349f679188150/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=72c99f2cf0021fe119dd3de8272349f679188150", "patch": "@@ -112,25 +112,6 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> HasDataLayout for Memory<'mir, 'tcx, M>\n     }\n }\n \n-// FIXME: Really we shouldn't clone memory, ever. Snapshot machinery should instead\n-// carefully copy only the reachable parts.\n-impl<'mir, 'tcx, M> Clone for Memory<'mir, 'tcx, M>\n-where\n-    M: Machine<'mir, 'tcx, PointerTag = (), AllocExtra = ()>,\n-    M::MemoryExtra: Copy,\n-    M::MemoryMap: AllocMap<AllocId, (MemoryKind<M::MemoryKinds>, Allocation)>,\n-{\n-    fn clone(&self) -> Self {\n-        Memory {\n-            alloc_map: self.alloc_map.clone(),\n-            extra_fn_ptr_map: self.extra_fn_ptr_map.clone(),\n-            dead_alloc_map: self.dead_alloc_map.clone(),\n-            extra: self.extra,\n-            tcx: self.tcx,\n-        }\n-    }\n-}\n-\n impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n     pub fn new(tcx: TyCtxtAt<'tcx>, extra: M::MemoryExtra) -> Self {\n         Memory {"}, {"sha": "3063a99886b7bdb76a917614b5d339ac6b4bc472", "filename": "src/librustc_mir/interpret/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/72c99f2cf0021fe119dd3de8272349f679188150/src%2Flibrustc_mir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72c99f2cf0021fe119dd3de8272349f679188150/src%2Flibrustc_mir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmod.rs?ref=72c99f2cf0021fe119dd3de8272349f679188150", "patch": "@@ -9,7 +9,6 @@ mod memory;\n mod operand;\n mod operator;\n mod place;\n-pub(crate) mod snapshot; // for const_eval\n mod step;\n mod terminator;\n mod traits;"}, {"sha": "ee45179fd8b316bd53ad98280f33079d2ed3d063", "filename": "src/librustc_mir/interpret/snapshot.rs", "status": "removed", "additions": 0, "deletions": 420, "changes": 420, "blob_url": "https://github.com/rust-lang/rust/blob/a73ed5aad9afb76bf5ba391641f0cb6c86299242/src%2Flibrustc_mir%2Finterpret%2Fsnapshot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a73ed5aad9afb76bf5ba391641f0cb6c86299242/src%2Flibrustc_mir%2Finterpret%2Fsnapshot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fsnapshot.rs?ref=a73ed5aad9afb76bf5ba391641f0cb6c86299242", "patch": "@@ -1,420 +0,0 @@\n-//! This module contains the machinery necessary to detect infinite loops\n-//! during const-evaluation by taking snapshots of the state of the interpreter\n-//! at regular intervals.\n-\n-// This lives in `interpret` because it needs access to all sots of private state.  However,\n-// it is not used by the general miri engine, just by CTFE.\n-\n-use std::hash::{Hash, Hasher};\n-\n-use rustc::ich::StableHashingContextProvider;\n-use rustc::mir;\n-use rustc::mir::interpret::{\n-    AllocId, Allocation, InterpResult, Pointer, Relocations, Scalar, UndefMask,\n-};\n-\n-use rustc::ty::layout::{Align, Size};\n-use rustc::ty::{self, TyCtxt};\n-use rustc_ast::ast::Mutability;\n-use rustc_data_structures::fx::FxHashSet;\n-use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n-use rustc_index::vec::IndexVec;\n-use rustc_macros::HashStable;\n-use rustc_span::source_map::Span;\n-\n-use super::eval_context::{LocalState, StackPopCleanup};\n-use super::{\n-    Frame, Immediate, LocalValue, MemPlace, MemPlaceMeta, Memory, Operand, Place, ScalarMaybeUndef,\n-};\n-use crate::const_eval::CompileTimeInterpreter;\n-\n-#[derive(Default)]\n-pub(crate) struct InfiniteLoopDetector<'mir, 'tcx> {\n-    /// The set of all `InterpSnapshot` *hashes* observed by this detector.\n-    ///\n-    /// When a collision occurs in this table, we store the full snapshot in\n-    /// `snapshots`.\n-    hashes: FxHashSet<u64>,\n-\n-    /// The set of all `InterpSnapshot`s observed by this detector.\n-    ///\n-    /// An `InterpSnapshot` will only be fully cloned once it has caused a\n-    /// collision in `hashes`. As a result, the detector must observe at least\n-    /// *two* full cycles of an infinite loop before it triggers.\n-    snapshots: FxHashSet<InterpSnapshot<'mir, 'tcx>>,\n-}\n-\n-impl<'mir, 'tcx> InfiniteLoopDetector<'mir, 'tcx> {\n-    pub fn observe_and_analyze(\n-        &mut self,\n-        tcx: TyCtxt<'tcx>,\n-        span: Span,\n-        memory: &Memory<'mir, 'tcx, CompileTimeInterpreter<'mir, 'tcx>>,\n-        stack: &[Frame<'mir, 'tcx>],\n-    ) -> InterpResult<'tcx, ()> {\n-        // Compute stack's hash before copying anything\n-        let mut hcx = tcx.get_stable_hashing_context();\n-        let mut hasher = StableHasher::new();\n-        stack.hash_stable(&mut hcx, &mut hasher);\n-        let hash = hasher.finish::<u64>();\n-\n-        // Check if we know that hash already\n-        if self.hashes.is_empty() {\n-            // FIXME(#49980): make this warning a lint\n-            tcx.sess.span_warn(\n-                span,\n-                \"Constant evaluating a complex constant, this might take some time\",\n-            );\n-        }\n-        if self.hashes.insert(hash) {\n-            // No collision\n-            return Ok(());\n-        }\n-\n-        // We need to make a full copy. NOW things that to get really expensive.\n-        info!(\"snapshotting the state of the interpreter\");\n-\n-        if self.snapshots.insert(InterpSnapshot::new(memory, stack)) {\n-            // Spurious collision or first cycle\n-            return Ok(());\n-        }\n-\n-        // Second cycle\n-        throw_exhaust!(InfiniteLoop)\n-    }\n-}\n-\n-trait SnapshotContext<'a> {\n-    fn resolve(&'a self, id: &AllocId) -> Option<&'a Allocation>;\n-}\n-\n-/// Taking a snapshot of the evaluation context produces a view of\n-/// the state of the interpreter that is invariant to `AllocId`s.\n-trait Snapshot<'a, Ctx: SnapshotContext<'a>> {\n-    type Item;\n-    fn snapshot(&self, ctx: &'a Ctx) -> Self::Item;\n-}\n-\n-macro_rules! __impl_snapshot_field {\n-    ($field:ident, $ctx:expr) => {\n-        $field.snapshot($ctx)\n-    };\n-    ($field:ident, $ctx:expr, $delegate:expr) => {\n-        $delegate\n-    };\n-}\n-\n-// This assumes the type has two type parameters, first for the tag (set to `()`),\n-// then for the id\n-macro_rules! impl_snapshot_for {\n-    (enum $enum_name:ident {\n-        $( $variant:ident $( ( $($field:ident $(-> $delegate:expr)?),* ) )? ),* $(,)?\n-    }) => {\n-\n-        impl<'a, Ctx> self::Snapshot<'a, Ctx> for $enum_name\n-            where Ctx: self::SnapshotContext<'a>,\n-        {\n-            type Item = $enum_name<(), AllocIdSnapshot<'a>>;\n-\n-            #[inline]\n-            fn snapshot(&self, __ctx: &'a Ctx) -> Self::Item {\n-                match *self {\n-                    $(\n-                        $enum_name::$variant $( ( $(ref $field),* ) )? => {\n-                            $enum_name::$variant $(\n-                                ( $( __impl_snapshot_field!($field, __ctx $(, $delegate)?) ),* )\n-                            )?\n-                        }\n-                    )*\n-                }\n-            }\n-        }\n-    };\n-\n-    (struct $struct_name:ident { $($field:ident $(-> $delegate:expr)?),*  $(,)? }) => {\n-        impl<'a, Ctx> self::Snapshot<'a, Ctx> for $struct_name\n-            where Ctx: self::SnapshotContext<'a>,\n-        {\n-            type Item = $struct_name<(), AllocIdSnapshot<'a>>;\n-\n-            #[inline]\n-            fn snapshot(&self, __ctx: &'a Ctx) -> Self::Item {\n-                let $struct_name {\n-                    $(ref $field),*\n-                } = *self;\n-\n-                $struct_name {\n-                    $( $field: __impl_snapshot_field!($field, __ctx $(, $delegate)?) ),*\n-                }\n-            }\n-        }\n-    };\n-}\n-\n-impl<'a, Ctx, T> Snapshot<'a, Ctx> for Option<T>\n-where\n-    Ctx: SnapshotContext<'a>,\n-    T: Snapshot<'a, Ctx>,\n-{\n-    type Item = Option<<T as Snapshot<'a, Ctx>>::Item>;\n-\n-    fn snapshot(&self, ctx: &'a Ctx) -> Self::Item {\n-        match self {\n-            Some(x) => Some(x.snapshot(ctx)),\n-            None => None,\n-        }\n-    }\n-}\n-\n-#[derive(Eq, PartialEq)]\n-struct AllocIdSnapshot<'a>(Option<AllocationSnapshot<'a>>);\n-\n-impl<'a, Ctx> Snapshot<'a, Ctx> for AllocId\n-where\n-    Ctx: SnapshotContext<'a>,\n-{\n-    type Item = AllocIdSnapshot<'a>;\n-\n-    fn snapshot(&self, ctx: &'a Ctx) -> Self::Item {\n-        AllocIdSnapshot(ctx.resolve(self).map(|alloc| alloc.snapshot(ctx)))\n-    }\n-}\n-\n-impl_snapshot_for!(struct Pointer {\n-    alloc_id,\n-    offset -> *offset, // just copy offset verbatim\n-    tag -> *tag, // just copy tag\n-});\n-\n-impl<'a, Ctx> Snapshot<'a, Ctx> for Scalar\n-where\n-    Ctx: SnapshotContext<'a>,\n-{\n-    type Item = Scalar<(), AllocIdSnapshot<'a>>;\n-\n-    fn snapshot(&self, ctx: &'a Ctx) -> Self::Item {\n-        match self {\n-            Scalar::Ptr(p) => Scalar::Ptr(p.snapshot(ctx)),\n-            Scalar::Raw { size, data } => Scalar::Raw { data: *data, size: *size },\n-        }\n-    }\n-}\n-\n-impl_snapshot_for!(\n-    enum ScalarMaybeUndef {\n-        Scalar(s),\n-        Undef,\n-    }\n-);\n-\n-impl_snapshot_for!(\n-    enum MemPlaceMeta {\n-        Meta(s),\n-        None,\n-        Poison,\n-    }\n-);\n-\n-impl_snapshot_for!(struct MemPlace {\n-    ptr,\n-    meta,\n-    align -> *align, // just copy alignment verbatim\n-});\n-\n-impl<'a, Ctx> Snapshot<'a, Ctx> for Place\n-where\n-    Ctx: SnapshotContext<'a>,\n-{\n-    type Item = Place<(), AllocIdSnapshot<'a>>;\n-\n-    fn snapshot(&self, ctx: &'a Ctx) -> Self::Item {\n-        match self {\n-            Place::Ptr(p) => Place::Ptr(p.snapshot(ctx)),\n-\n-            Place::Local { frame, local } => Place::Local { frame: *frame, local: *local },\n-        }\n-    }\n-}\n-\n-impl_snapshot_for!(\n-    enum Immediate {\n-        Scalar(s),\n-        ScalarPair(s, t),\n-    }\n-);\n-\n-impl_snapshot_for!(\n-    enum Operand {\n-        Immediate(v),\n-        Indirect(m),\n-    }\n-);\n-\n-impl_snapshot_for!(\n-    enum LocalValue {\n-        Dead,\n-        Uninitialized,\n-        Live(v),\n-    }\n-);\n-\n-impl<'a, Ctx> Snapshot<'a, Ctx> for Relocations\n-where\n-    Ctx: SnapshotContext<'a>,\n-{\n-    type Item = Relocations<(), AllocIdSnapshot<'a>>;\n-\n-    fn snapshot(&self, ctx: &'a Ctx) -> Self::Item {\n-        Relocations::from_presorted(\n-            self.iter().map(|(size, ((), id))| (*size, ((), id.snapshot(ctx)))).collect(),\n-        )\n-    }\n-}\n-\n-#[derive(Eq, PartialEq)]\n-struct AllocationSnapshot<'a> {\n-    bytes: &'a [u8],\n-    relocations: Relocations<(), AllocIdSnapshot<'a>>,\n-    undef_mask: &'a UndefMask,\n-    align: &'a Align,\n-    size: &'a Size,\n-    mutability: &'a Mutability,\n-}\n-\n-impl<'a, Ctx> Snapshot<'a, Ctx> for &'a Allocation\n-where\n-    Ctx: SnapshotContext<'a>,\n-{\n-    type Item = AllocationSnapshot<'a>;\n-\n-    fn snapshot(&self, ctx: &'a Ctx) -> Self::Item {\n-        let Allocation { size, align, mutability, extra: (), .. } = self;\n-\n-        let all_bytes = 0..self.len();\n-        // This 'inspect' is okay since following access respects undef and relocations. This does\n-        // influence interpreter exeuction, but only to detect the error of cycles in evaluation\n-        // dependencies.\n-        let bytes = self.inspect_with_undef_and_ptr_outside_interpreter(all_bytes);\n-\n-        let undef_mask = self.undef_mask();\n-        let relocations = self.relocations();\n-\n-        AllocationSnapshot {\n-            bytes,\n-            undef_mask,\n-            align,\n-            size,\n-            mutability,\n-            relocations: relocations.snapshot(ctx),\n-        }\n-    }\n-}\n-\n-#[derive(Eq, PartialEq)]\n-struct FrameSnapshot<'a, 'tcx> {\n-    instance: ty::Instance<'tcx>,\n-    span: Span,\n-    return_to_block: &'a StackPopCleanup,\n-    return_place: Option<Place<(), AllocIdSnapshot<'a>>>,\n-    locals: IndexVec<mir::Local, LocalValue<(), AllocIdSnapshot<'a>>>,\n-    block: Option<mir::BasicBlock>,\n-    stmt: usize,\n-}\n-\n-impl<'a, 'mir, 'tcx, Ctx> Snapshot<'a, Ctx> for &'a Frame<'mir, 'tcx>\n-where\n-    Ctx: SnapshotContext<'a>,\n-{\n-    type Item = FrameSnapshot<'a, 'tcx>;\n-\n-    fn snapshot(&self, ctx: &'a Ctx) -> Self::Item {\n-        let Frame {\n-            body: _,\n-            instance,\n-            span,\n-            return_to_block,\n-            return_place,\n-            locals,\n-            block,\n-            stmt,\n-            extra: _,\n-        } = self;\n-\n-        FrameSnapshot {\n-            instance: *instance,\n-            span: *span,\n-            return_to_block,\n-            block: *block,\n-            stmt: *stmt,\n-            return_place: return_place.map(|r| r.snapshot(ctx)),\n-            locals: locals.iter().map(|local| local.snapshot(ctx)).collect(),\n-        }\n-    }\n-}\n-\n-impl<'a, 'tcx, Ctx> Snapshot<'a, Ctx> for &'a LocalState<'tcx>\n-where\n-    Ctx: SnapshotContext<'a>,\n-{\n-    type Item = LocalValue<(), AllocIdSnapshot<'a>>;\n-\n-    fn snapshot(&self, ctx: &'a Ctx) -> Self::Item {\n-        let LocalState { value, layout: _ } = self;\n-        value.snapshot(ctx)\n-    }\n-}\n-\n-impl<'b, 'mir, 'tcx> SnapshotContext<'b>\n-    for Memory<'mir, 'tcx, CompileTimeInterpreter<'mir, 'tcx>>\n-{\n-    fn resolve(&'b self, id: &AllocId) -> Option<&'b Allocation> {\n-        self.get_raw(*id).ok()\n-    }\n-}\n-\n-/// The virtual machine state during const-evaluation at a given point in time.\n-/// We assume the `CompileTimeInterpreter` has no interesting extra state that\n-/// is worth considering here.\n-#[derive(HashStable)]\n-struct InterpSnapshot<'mir, 'tcx> {\n-    // Not hashing memory: Avoid hashing memory all the time during execution\n-    #[stable_hasher(ignore)]\n-    memory: Memory<'mir, 'tcx, CompileTimeInterpreter<'mir, 'tcx>>,\n-    stack: Vec<Frame<'mir, 'tcx>>,\n-}\n-\n-impl InterpSnapshot<'mir, 'tcx> {\n-    fn new(\n-        memory: &Memory<'mir, 'tcx, CompileTimeInterpreter<'mir, 'tcx>>,\n-        stack: &[Frame<'mir, 'tcx>],\n-    ) -> Self {\n-        InterpSnapshot { memory: memory.clone(), stack: stack.into() }\n-    }\n-\n-    // Used to compare two snapshots\n-    fn snapshot(&'b self) -> Vec<FrameSnapshot<'b, 'tcx>> {\n-        // Start with the stack, iterate and recursively snapshot\n-        self.stack.iter().map(|frame| frame.snapshot(&self.memory)).collect()\n-    }\n-}\n-\n-impl<'mir, 'tcx> Hash for InterpSnapshot<'mir, 'tcx> {\n-    fn hash<H: Hasher>(&self, state: &mut H) {\n-        // Implement in terms of hash stable, so that k1 == k2 -> hash(k1) == hash(k2)\n-        let mut hcx = self.memory.tcx.get_stable_hashing_context();\n-        let mut hasher = StableHasher::new();\n-        self.hash_stable(&mut hcx, &mut hasher);\n-        hasher.finish::<u64>().hash(state)\n-    }\n-}\n-\n-impl<'mir, 'tcx> Eq for InterpSnapshot<'mir, 'tcx> {}\n-\n-impl<'mir, 'tcx> PartialEq for InterpSnapshot<'mir, 'tcx> {\n-    fn eq(&self, other: &Self) -> bool {\n-        // FIXME: This looks to be a *ridiculously expensive* comparison operation.\n-        // Doesn't this make tons of copies?  Either `snapshot` is very badly named,\n-        // or it does!\n-        self.snapshot() == other.snapshot()\n-    }\n-}"}, {"sha": "c8de259354eac03f0d79f73d45b5a4a2bbe79238", "filename": "src/test/ui/consts/const-eval/infinite_loop.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/72c99f2cf0021fe119dd3de8272349f679188150/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Finfinite_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72c99f2cf0021fe119dd3de8272349f679188150/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Finfinite_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Finfinite_loop.rs?ref=72c99f2cf0021fe119dd3de8272349f679188150", "patch": "@@ -2,7 +2,6 @@ fn main() {\n     // Tests the Collatz conjecture with an incorrect base case (0 instead of 1).\n     // The value of `n` will loop indefinitely (4 - 2 - 1 - 4).\n     let _ = [(); {\n-        //~^ WARNING Constant evaluating a complex constant, this might take some time\n         let mut n = 113383; // #20 in https://oeis.org/A006884\n         while n != 0 {\n         //~^ ERROR `while` is not allowed in a `const`"}, {"sha": "ebdb73c44679150fd2299e20740fba318d9f62d8", "filename": "src/test/ui/consts/const-eval/infinite_loop.stderr", "status": "modified", "additions": 4, "deletions": 17, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/72c99f2cf0021fe119dd3de8272349f679188150/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Finfinite_loop.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/72c99f2cf0021fe119dd3de8272349f679188150/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Finfinite_loop.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Finfinite_loop.stderr?ref=72c99f2cf0021fe119dd3de8272349f679188150", "patch": "@@ -1,5 +1,5 @@\n error[E0658]: `while` is not allowed in a `const`\n-  --> $DIR/infinite_loop.rs:7:9\n+  --> $DIR/infinite_loop.rs:6:9\n    |\n LL | /         while n != 0 {\n LL | |\n@@ -14,32 +14,19 @@ LL | |         }\n    = help: add `#![feature(const_if_match)]` to the crate attributes to enable\n \n error[E0658]: `if` is not allowed in a `const`\n-  --> $DIR/infinite_loop.rs:9:17\n+  --> $DIR/infinite_loop.rs:8:17\n    |\n LL |             n = if n % 2 == 0 { n/2 } else { 3*n + 1 };\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: see issue #49146 <https://github.com/rust-lang/rust/issues/49146> for more information\n    = help: add `#![feature(const_if_match)]` to the crate attributes to enable\n \n-warning: Constant evaluating a complex constant, this might take some time\n-  --> $DIR/infinite_loop.rs:4:18\n-   |\n-LL |       let _ = [(); {\n-   |  __________________^\n-LL | |\n-LL | |         let mut n = 113383; // #20 in https://oeis.org/A006884\n-LL | |         while n != 0 {\n-...  |\n-LL | |         n\n-LL | |     }];\n-   | |_____^\n-\n error[E0080]: evaluation of constant value failed\n-  --> $DIR/infinite_loop.rs:9:20\n+  --> $DIR/infinite_loop.rs:8:20\n    |\n LL |             n = if n % 2 == 0 { n/2 } else { 3*n + 1 };\n-   |                    ^^^^^^^^^^ duplicate interpreter state observed here, const evaluation will never terminate\n+   |                    ^^^^^^^^^^ exceeded interpreter step limit (see `#[const_eval_limit]`)\n \n error: aborting due to 3 previous errors\n "}, {"sha": "869f0b981af7d881e4dce06fc6f4cd9fe531b727", "filename": "src/test/ui/consts/const-eval/issue-52475.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/72c99f2cf0021fe119dd3de8272349f679188150/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fissue-52475.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72c99f2cf0021fe119dd3de8272349f679188150/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fissue-52475.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fissue-52475.rs?ref=72c99f2cf0021fe119dd3de8272349f679188150", "patch": "@@ -1,6 +1,5 @@\n fn main() {\n     let _ = [(); {\n-        //~^ WARNING Constant evaluating a complex constant, this might take some time\n         let mut x = &0;\n         let mut n = 0;\n         while n < 5 {"}, {"sha": "b069537ead9637a63df6bf2bb80b8dcfe92a601e", "filename": "src/test/ui/consts/const-eval/issue-52475.stderr", "status": "modified", "additions": 3, "deletions": 16, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/72c99f2cf0021fe119dd3de8272349f679188150/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fissue-52475.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/72c99f2cf0021fe119dd3de8272349f679188150/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fissue-52475.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fissue-52475.stderr?ref=72c99f2cf0021fe119dd3de8272349f679188150", "patch": "@@ -1,5 +1,5 @@\n error[E0658]: `while` is not allowed in a `const`\n-  --> $DIR/issue-52475.rs:6:9\n+  --> $DIR/issue-52475.rs:5:9\n    |\n LL | /         while n < 5 {\n LL | |\n@@ -12,24 +12,11 @@ LL | |         }\n    = help: add `#![feature(const_loop)]` to the crate attributes to enable\n    = help: add `#![feature(const_if_match)]` to the crate attributes to enable\n \n-warning: Constant evaluating a complex constant, this might take some time\n-  --> $DIR/issue-52475.rs:2:18\n-   |\n-LL |       let _ = [(); {\n-   |  __________________^\n-LL | |\n-LL | |         let mut x = &0;\n-LL | |         let mut n = 0;\n-...  |\n-LL | |         0\n-LL | |     }];\n-   | |_____^\n-\n error[E0080]: evaluation of constant value failed\n-  --> $DIR/issue-52475.rs:8:17\n+  --> $DIR/issue-52475.rs:7:17\n    |\n LL |             n = (n + 1) % 5;\n-   |                 ^^^^^^^^^^^ duplicate interpreter state observed here, const evaluation will never terminate\n+   |                 ^^^^^^^^^^^ exceeded interpreter step limit (see `#[const_eval_limit]`)\n \n error: aborting due to 2 previous errors\n "}, {"sha": "34abcdf08dae0e2cf6159f5a3af2e04ae2b8b79a", "filename": "src/test/ui/consts/const_limit/const_eval_limit_not_reached.rs", "status": "modified", "additions": 14, "deletions": 8, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/72c99f2cf0021fe119dd3de8272349f679188150/src%2Ftest%2Fui%2Fconsts%2Fconst_limit%2Fconst_eval_limit_not_reached.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72c99f2cf0021fe119dd3de8272349f679188150/src%2Ftest%2Fui%2Fconsts%2Fconst_limit%2Fconst_eval_limit_not_reached.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst_limit%2Fconst_eval_limit_not_reached.rs?ref=72c99f2cf0021fe119dd3de8272349f679188150", "patch": "@@ -1,15 +1,21 @@\n // check-pass\n+\n #![feature(const_eval_limit)]\n-#![const_eval_limit=\"1000\"]\n+#![feature(const_loop, const_if_match)]\n \n-const CONSTANT: usize = limit();\n+// This needs to be higher than the number of loop iterations since each pass through the loop may\n+// hit more than one terminator.\n+#![const_eval_limit=\"4000\"]\n \n-fn main() {\n-    assert_eq!(CONSTANT, 1764);\n-}\n+const X: usize = {\n+    let mut x = 0;\n+    while x != 1000 {\n+        x += 1;\n+    }\n \n-const fn limit() -> usize {\n-    let x = 42;\n+    x\n+};\n \n-    x * 42\n+fn main() {\n+    assert_eq!(X, 1000);\n }"}, {"sha": "b45aca0b13e42f51a1f2f7299555cfdb76530cab", "filename": "src/test/ui/consts/const_limit/const_eval_limit_reached.rs", "status": "modified", "additions": 12, "deletions": 15, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/72c99f2cf0021fe119dd3de8272349f679188150/src%2Ftest%2Fui%2Fconsts%2Fconst_limit%2Fconst_eval_limit_reached.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72c99f2cf0021fe119dd3de8272349f679188150/src%2Ftest%2Fui%2Fconsts%2Fconst_limit%2Fconst_eval_limit_reached.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst_limit%2Fconst_eval_limit_reached.rs?ref=72c99f2cf0021fe119dd3de8272349f679188150", "patch": "@@ -1,21 +1,18 @@\n-// ignore-tidy-linelength\n-// only-x86_64\n-// check-pass\n-// NOTE: We always compile this test with -Copt-level=0 because higher opt-levels\n-//       optimize away the const function\n-// compile-flags:-Copt-level=0\n #![feature(const_eval_limit)]\n-#![const_eval_limit=\"2\"]\n+#![feature(const_loop, const_if_match)]\n \n-const CONSTANT: usize = limit();\n-//~^ WARNING Constant evaluating a complex constant, this might take some time\n+#![const_eval_limit=\"500\"]\n \n-fn main() {\n-    assert_eq!(CONSTANT, 1764);\n-}\n+const X: usize = {\n+    let mut x = 0;\n+    while x != 1000 {\n+        //~^ ERROR any use of this value will cause an error\n+        x += 1;\n+    }\n \n-const fn limit() -> usize { //~ WARNING Constant evaluating a complex constant, this might take some time\n-    let x = 42;\n+    x\n+};\n \n-    x * 42\n+fn main() {\n+    assert_eq!(X, 1000);\n }"}, {"sha": "be522dd6d5d5a53d942222f468201939fa5e7c29", "filename": "src/test/ui/consts/const_limit/const_eval_limit_reached.stderr", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/72c99f2cf0021fe119dd3de8272349f679188150/src%2Ftest%2Fui%2Fconsts%2Fconst_limit%2Fconst_eval_limit_reached.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/72c99f2cf0021fe119dd3de8272349f679188150/src%2Ftest%2Fui%2Fconsts%2Fconst_limit%2Fconst_eval_limit_reached.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst_limit%2Fconst_eval_limit_reached.stderr?ref=72c99f2cf0021fe119dd3de8272349f679188150", "patch": "@@ -1,16 +1,17 @@\n-warning: Constant evaluating a complex constant, this might take some time\n-  --> $DIR/const_eval_limit_reached.rs:17:1\n+error: any use of this value will cause an error\n+  --> $DIR/const_eval_limit_reached.rs:8:11\n    |\n-LL | / const fn limit() -> usize {\n-LL | |     let x = 42;\n+LL | / const X: usize = {\n+LL | |     let mut x = 0;\n+LL | |     while x != 1000 {\n+   | |           ^^^^^^^^^ exceeded interpreter step limit (see `#[const_eval_limit]`)\n LL | |\n-LL | |     x * 42\n-LL | | }\n-   | |_^\n-\n-warning: Constant evaluating a complex constant, this might take some time\n-  --> $DIR/const_eval_limit_reached.rs:10:1\n+...  |\n+LL | |     x\n+LL | | };\n+   | |__-\n    |\n-LL | const CONSTANT: usize = limit();\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   = note: `#[deny(const_err)]` on by default\n+\n+error: aborting due to previous error\n "}]}