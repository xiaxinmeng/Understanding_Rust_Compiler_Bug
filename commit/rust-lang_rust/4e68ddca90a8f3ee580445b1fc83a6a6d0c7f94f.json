{"sha": "4e68ddca90a8f3ee580445b1fc83a6a6d0c7f94f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRlNjhkZGNhOTBhOGYzZWU1ODA0NDViMWZjODNhNmE2ZDBjN2Y5NGY=", "commit": {"author": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2019-05-23T20:10:24Z"}, "committer": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2019-05-25T19:15:06Z"}, "message": "review comments: move back some methods and clean up wording", "tree": {"sha": "70062c13d855551e639c9a5de7d0cc0baf0e35ad", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/70062c13d855551e639c9a5de7d0cc0baf0e35ad"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4e68ddca90a8f3ee580445b1fc83a6a6d0c7f94f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4e68ddca90a8f3ee580445b1fc83a6a6d0c7f94f", "html_url": "https://github.com/rust-lang/rust/commit/4e68ddca90a8f3ee580445b1fc83a6a6d0c7f94f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4e68ddca90a8f3ee580445b1fc83a6a6d0c7f94f/comments", "author": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "committer": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d1364d5284e715944860d13ea6a55839c7eb052d", "url": "https://api.github.com/repos/rust-lang/rust/commits/d1364d5284e715944860d13ea6a55839c7eb052d", "html_url": "https://github.com/rust-lang/rust/commit/d1364d5284e715944860d13ea6a55839c7eb052d"}], "stats": {"total": 388, "additions": 196, "deletions": 192}, "files": [{"sha": "9431b559da55ff8c54d8e012c31eab8ca81b3067", "filename": "src/libsyntax/parse/diagnostics.rs", "status": "modified", "additions": 145, "deletions": 40, "changes": 185, "blob_url": "https://github.com/rust-lang/rust/blob/4e68ddca90a8f3ee580445b1fc83a6a6d0c7f94f/src%2Flibsyntax%2Fparse%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e68ddca90a8f3ee580445b1fc83a6a6d0c7f94f/src%2Flibsyntax%2Fparse%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fdiagnostics.rs?ref=4e68ddca90a8f3ee580445b1fc83a6a6d0c7f94f", "patch": "@@ -5,18 +5,15 @@ use crate::ast::{\n };\n use crate::parse::{SeqSep, token, PResult, Parser};\n use crate::parse::parser::{BlockMode, PathStyle, SemiColonMode, TokenType, TokenExpectType};\n-use crate::parse::token;\n use crate::print::pprust;\n use crate::ptr::P;\n use crate::source_map::Spanned;\n use crate::symbol::kw;\n use crate::ThinVec;\n-use crate::tokenstream::TokenTree;\n use crate::util::parser::AssocOp;\n-use errors::{Applicability, DiagnosticBuilder, DiagnosticId, FatalError};\n+use errors::{Applicability, DiagnosticBuilder, DiagnosticId};\n use syntax_pos::{Span, DUMMY_SP, MultiSpan};\n use log::{debug, trace};\n-use std::slice;\n \n pub enum Error {\n     FileNotFoundForModule {\n@@ -148,36 +145,8 @@ impl RecoverQPath for Expr {\n }\n \n impl<'a> Parser<'a> {\n-    pub fn look_ahead<R, F>(&self, dist: usize, f: F) -> R where\n-        F: FnOnce(&token::Token) -> R,\n-    {\n-        if dist == 0 {\n-            return f(&self.token)\n-        }\n-\n-        f(&match self.token_cursor.frame.tree_cursor.look_ahead(dist - 1) {\n-            Some(tree) => match tree {\n-                TokenTree::Token(_, tok) => tok,\n-                TokenTree::Delimited(_, delim, _) => token::OpenDelim(delim),\n-            },\n-            None => token::CloseDelim(self.token_cursor.frame.delim),\n-        })\n-    }\n-\n-    crate fn look_ahead_span(&self, dist: usize) -> Span {\n-        if dist == 0 {\n-            return self.span\n-        }\n-\n-        match self.token_cursor.frame.tree_cursor.look_ahead(dist - 1) {\n-            Some(TokenTree::Token(span, _)) => span,\n-            Some(TokenTree::Delimited(span, ..)) => span.entire(),\n-            None => self.look_ahead_span(dist - 1),\n-        }\n-    }\n-\n     pub fn fatal(&self, m: &str) -> DiagnosticBuilder<'a> {\n-        self.sess.span_diagnostic.struct_span_fatal(self.span, m)\n+        self.span_fatal(self.span, m)\n     }\n \n     pub fn span_fatal<S: Into<MultiSpan>>(&self, sp: S, m: &str) -> DiagnosticBuilder<'a> {\n@@ -243,6 +212,145 @@ impl<'a> Parser<'a> {\n         err\n     }\n \n+    pub fn expected_one_of_not_found(\n+        &mut self,\n+        edible: &[token::Token],\n+        inedible: &[token::Token],\n+    ) -> PResult<'a, bool /* recovered */> {\n+        fn tokens_to_string(tokens: &[TokenType]) -> String {\n+            let mut i = tokens.iter();\n+            // This might be a sign we need a connect method on Iterator.\n+            let b = i.next()\n+                     .map_or(String::new(), |t| t.to_string());\n+            i.enumerate().fold(b, |mut b, (i, a)| {\n+                if tokens.len() > 2 && i == tokens.len() - 2 {\n+                    b.push_str(\", or \");\n+                } else if tokens.len() == 2 && i == tokens.len() - 2 {\n+                    b.push_str(\" or \");\n+                } else {\n+                    b.push_str(\", \");\n+                }\n+                b.push_str(&a.to_string());\n+                b\n+            })\n+        }\n+\n+        let mut expected = edible.iter()\n+            .map(|x| TokenType::Token(x.clone()))\n+            .chain(inedible.iter().map(|x| TokenType::Token(x.clone())))\n+            .chain(self.expected_tokens.iter().cloned())\n+            .collect::<Vec<_>>();\n+        expected.sort_by_cached_key(|x| x.to_string());\n+        expected.dedup();\n+        let expect = tokens_to_string(&expected[..]);\n+        let actual = self.this_token_to_string();\n+        let (msg_exp, (label_sp, label_exp)) = if expected.len() > 1 {\n+            let short_expect = if expected.len() > 6 {\n+                format!(\"{} possible tokens\", expected.len())\n+            } else {\n+                expect.clone()\n+            };\n+            (format!(\"expected one of {}, found `{}`\", expect, actual),\n+                (self.sess.source_map().next_point(self.prev_span),\n+                format!(\"expected one of {} here\", short_expect)))\n+        } else if expected.is_empty() {\n+            (format!(\"unexpected token: `{}`\", actual),\n+                (self.prev_span, \"unexpected token after this\".to_string()))\n+        } else {\n+            (format!(\"expected {}, found `{}`\", expect, actual),\n+                (self.sess.source_map().next_point(self.prev_span),\n+                format!(\"expected {} here\", expect)))\n+        };\n+        self.last_unexpected_token_span = Some(self.span);\n+        let mut err = self.fatal(&msg_exp);\n+        if self.token.is_ident_named(\"and\") {\n+            err.span_suggestion_short(\n+                self.span,\n+                \"use `&&` instead of `and` for the boolean operator\",\n+                \"&&\".to_string(),\n+                Applicability::MaybeIncorrect,\n+            );\n+        }\n+        if self.token.is_ident_named(\"or\") {\n+            err.span_suggestion_short(\n+                self.span,\n+                \"use `||` instead of `or` for the boolean operator\",\n+                \"||\".to_string(),\n+                Applicability::MaybeIncorrect,\n+            );\n+        }\n+        let sp = if self.token == token::Token::Eof {\n+            // This is EOF, don't want to point at the following char, but rather the last token\n+            self.prev_span\n+        } else {\n+            label_sp\n+        };\n+        match self.recover_closing_delimiter(&expected.iter().filter_map(|tt| match tt {\n+            TokenType::Token(t) => Some(t.clone()),\n+            _ => None,\n+        }).collect::<Vec<_>>(), err) {\n+            Err(e) => err = e,\n+            Ok(recovered) => {\n+                return Ok(recovered);\n+            }\n+        }\n+\n+        let is_semi_suggestable = expected.iter().any(|t| match t {\n+            TokenType::Token(token::Semi) => true, // we expect a `;` here\n+            _ => false,\n+        }) && ( // a `;` would be expected before the current keyword\n+            self.token.is_keyword(kw::Break) ||\n+            self.token.is_keyword(kw::Continue) ||\n+            self.token.is_keyword(kw::For) ||\n+            self.token.is_keyword(kw::If) ||\n+            self.token.is_keyword(kw::Let) ||\n+            self.token.is_keyword(kw::Loop) ||\n+            self.token.is_keyword(kw::Match) ||\n+            self.token.is_keyword(kw::Return) ||\n+            self.token.is_keyword(kw::While)\n+        );\n+        let cm = self.sess.source_map();\n+        match (cm.lookup_line(self.span.lo()), cm.lookup_line(sp.lo())) {\n+            (Ok(ref a), Ok(ref b)) if a.line != b.line && is_semi_suggestable => {\n+                // The spans are in different lines, expected `;` and found `let` or `return`.\n+                // High likelihood that it is only a missing `;`.\n+                err.span_suggestion_short(\n+                    label_sp,\n+                    \"a semicolon may be missing here\",\n+                    \";\".to_string(),\n+                    Applicability::MaybeIncorrect,\n+                );\n+                err.emit();\n+                return Ok(true);\n+            }\n+            (Ok(ref a), Ok(ref b)) if a.line == b.line => {\n+                // When the spans are in the same line, it means that the only content between\n+                // them is whitespace, point at the found token in that case:\n+                //\n+                // X |     () => { syntax error };\n+                //   |                    ^^^^^ expected one of 8 possible tokens here\n+                //\n+                // instead of having:\n+                //\n+                // X |     () => { syntax error };\n+                //   |                   -^^^^^ unexpected token\n+                //   |                   |\n+                //   |                   expected one of 8 possible tokens here\n+                err.span_label(self.span, label_exp);\n+            }\n+            _ if self.prev_span == syntax_pos::DUMMY_SP => {\n+                // Account for macro context where the previous span might not be\n+                // available to avoid incorrect output (#54841).\n+                err.span_label(self.span, \"unexpected token\");\n+            }\n+            _ => {\n+                err.span_label(sp, label_exp);\n+                err.span_label(self.span, \"unexpected token\");\n+            }\n+        }\n+        Err(err)\n+    }\n+\n     /// Eats and discards tokens until one of `kets` is encountered. Respects token trees,\n     /// passes through any errors encountered. Used for error recovery.\n     crate fn eat_to_tokens(&mut self, kets: &[&token::Token]) {\n@@ -939,9 +1047,6 @@ impl<'a> Parser<'a> {\n                 String::new(),\n                 Applicability::MachineApplicable,\n             );\n-            err.note(\"if you meant to use emplacement syntax, it is obsolete (for now, anyway)\");\n-            err.note(\"for more information on the status of emplacement syntax, see <\\\n-                      https://github.com/rust-lang/rust/issues/27779#issuecomment-378416911>\");\n             err.emit();\n         }\n     }\n@@ -1050,12 +1155,12 @@ impl<'a> Parser<'a> {\n     ) -> PResult<'a, ast::Arg> {\n         let sp = arg.pat.span;\n         arg.ty.node = TyKind::Err;\n-        let mut err = self.struct_span_err(sp, \"unexpected `self` argument in function\");\n+        let mut err = self.struct_span_err(sp, \"unexpected `self` parameter in function\");\n         if is_trait_item {\n-            err.span_label(sp, \"must be the first associated function argument\");\n+            err.span_label(sp, \"must be the first associated function parameter\");\n         } else {\n-            err.span_label(sp, \"not valid as function argument\");\n-            err.note(\"`self` is only valid as the first argument of an associated function\");\n+            err.span_label(sp, \"not valid as function parameter\");\n+            err.note(\"`self` is only valid as the first parameter of an associated function\");\n         }\n         err.emit();\n         Ok(arg)"}, {"sha": "6c29437362c89cd7f666e8f5843739358021fcfb", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 31, "deletions": 132, "changes": 163, "blob_url": "https://github.com/rust-lang/rust/blob/4e68ddca90a8f3ee580445b1fc83a6a6d0c7f94f/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e68ddca90a8f3ee580445b1fc83a6a6d0c7f94f/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=4e68ddca90a8f3ee580445b1fc83a6a6d0c7f94f", "patch": "@@ -49,7 +49,7 @@ use crate::tokenstream::{self, DelimSpan, TokenTree, TokenStream, TreeAndJoint};\n use crate::symbol::{kw, sym, Symbol};\n use crate::parse::diagnostics::Error;\n \n-use errors::{Applicability, DiagnosticBuilder, DiagnosticId};\n+use errors::{Applicability, DiagnosticBuilder, DiagnosticId, FatalError};\n use rustc_target::spec::abi::{self, Abi};\n use syntax_pos::{Span, BytePos, DUMMY_SP, FileName, hygiene::CompilerDesugaringKind};\n use log::debug;\n@@ -58,6 +58,7 @@ use std::borrow::Cow;\n use std::cmp;\n use std::mem;\n use std::path::{self, Path, PathBuf};\n+use std::slice;\n \n #[derive(Debug)]\n /// Whether the type alias or associated type is a concrete type or an existential type\n@@ -595,23 +596,6 @@ impl<'a> Parser<'a> {\n         edible: &[token::Token],\n         inedible: &[token::Token],\n     ) -> PResult<'a, bool /* recovered */> {\n-        fn tokens_to_string(tokens: &[TokenType]) -> String {\n-            let mut i = tokens.iter();\n-            // This might be a sign we need a connect method on Iterator.\n-            let b = i.next()\n-                     .map_or(String::new(), |t| t.to_string());\n-            i.enumerate().fold(b, |mut b, (i, a)| {\n-                if tokens.len() > 2 && i == tokens.len() - 2 {\n-                    b.push_str(\", or \");\n-                } else if tokens.len() == 2 && i == tokens.len() - 2 {\n-                    b.push_str(\" or \");\n-                } else {\n-                    b.push_str(\", \");\n-                }\n-                b.push_str(&a.to_string());\n-                b\n-            })\n-        }\n         if edible.contains(&self.token) {\n             self.bump();\n             Ok(false)\n@@ -621,120 +605,7 @@ impl<'a> Parser<'a> {\n         } else if self.last_unexpected_token_span == Some(self.span) {\n             FatalError.raise();\n         } else {\n-            let mut expected = edible.iter()\n-                .map(|x| TokenType::Token(x.clone()))\n-                .chain(inedible.iter().map(|x| TokenType::Token(x.clone())))\n-                .chain(self.expected_tokens.iter().cloned())\n-                .collect::<Vec<_>>();\n-            expected.sort_by_cached_key(|x| x.to_string());\n-            expected.dedup();\n-            let expect = tokens_to_string(&expected[..]);\n-            let actual = self.this_token_to_string();\n-            let (msg_exp, (label_sp, label_exp)) = if expected.len() > 1 {\n-                let short_expect = if expected.len() > 6 {\n-                    format!(\"{} possible tokens\", expected.len())\n-                } else {\n-                    expect.clone()\n-                };\n-                (format!(\"expected one of {}, found `{}`\", expect, actual),\n-                 (self.sess.source_map().next_point(self.prev_span),\n-                  format!(\"expected one of {} here\", short_expect)))\n-            } else if expected.is_empty() {\n-                (format!(\"unexpected token: `{}`\", actual),\n-                 (self.prev_span, \"unexpected token after this\".to_string()))\n-            } else {\n-                (format!(\"expected {}, found `{}`\", expect, actual),\n-                 (self.sess.source_map().next_point(self.prev_span),\n-                  format!(\"expected {} here\", expect)))\n-            };\n-            self.last_unexpected_token_span = Some(self.span);\n-            let mut err = self.fatal(&msg_exp);\n-            if self.token.is_ident_named(\"and\") {\n-                err.span_suggestion_short(\n-                    self.span,\n-                    \"use `&&` instead of `and` for the boolean operator\",\n-                    \"&&\".to_string(),\n-                    Applicability::MaybeIncorrect,\n-                );\n-            }\n-            if self.token.is_ident_named(\"or\") {\n-                err.span_suggestion_short(\n-                    self.span,\n-                    \"use `||` instead of `or` for the boolean operator\",\n-                    \"||\".to_string(),\n-                    Applicability::MaybeIncorrect,\n-                );\n-            }\n-            let sp = if self.token == token::Token::Eof {\n-                // This is EOF, don't want to point at the following char, but rather the last token\n-                self.prev_span\n-            } else {\n-                label_sp\n-            };\n-            match self.recover_closing_delimiter(&expected.iter().filter_map(|tt| match tt {\n-                TokenType::Token(t) => Some(t.clone()),\n-                _ => None,\n-            }).collect::<Vec<_>>(), err) {\n-                Err(e) => err = e,\n-                Ok(recovered) => {\n-                    return Ok(recovered);\n-                }\n-            }\n-\n-            let is_semi_suggestable = expected.iter().any(|t| match t {\n-                TokenType::Token(token::Semi) => true, // we expect a `;` here\n-                _ => false,\n-            }) && ( // a `;` would be expected before the current keyword\n-                self.token.is_keyword(kw::Break) ||\n-                self.token.is_keyword(kw::Continue) ||\n-                self.token.is_keyword(kw::For) ||\n-                self.token.is_keyword(kw::If) ||\n-                self.token.is_keyword(kw::Let) ||\n-                self.token.is_keyword(kw::Loop) ||\n-                self.token.is_keyword(kw::Match) ||\n-                self.token.is_keyword(kw::Return) ||\n-                self.token.is_keyword(kw::While)\n-            );\n-            let cm = self.sess.source_map();\n-            match (cm.lookup_line(self.span.lo()), cm.lookup_line(sp.lo())) {\n-                (Ok(ref a), Ok(ref b)) if a.line != b.line && is_semi_suggestable => {\n-                    // The spans are in different lines, expected `;` and found `let` or `return`.\n-                    // High likelihood that it is only a missing `;`.\n-                    err.span_suggestion_short(\n-                        label_sp,\n-                        \"a semicolon may be missing here\",\n-                        \";\".to_string(),\n-                        Applicability::MaybeIncorrect,\n-                    );\n-                    err.emit();\n-                    return Ok(true);\n-                }\n-                (Ok(ref a), Ok(ref b)) if a.line == b.line => {\n-                    // When the spans are in the same line, it means that the only content between\n-                    // them is whitespace, point at the found token in that case:\n-                    //\n-                    // X |     () => { syntax error };\n-                    //   |                    ^^^^^ expected one of 8 possible tokens here\n-                    //\n-                    // instead of having:\n-                    //\n-                    // X |     () => { syntax error };\n-                    //   |                   -^^^^^ unexpected token\n-                    //   |                   |\n-                    //   |                   expected one of 8 possible tokens here\n-                    err.span_label(self.span, label_exp);\n-                }\n-                _ if self.prev_span == DUMMY_SP => {\n-                    // Account for macro context where the previous span might not be\n-                    // available to avoid incorrect output (#54841).\n-                    err.span_label(self.span, \"unexpected token\");\n-                }\n-                _ => {\n-                    err.span_label(sp, label_exp);\n-                    err.span_label(self.span, \"unexpected token\");\n-                }\n-            }\n-            Err(err)\n+            self.expected_one_of_not_found(edible, inedible)\n         }\n     }\n \n@@ -1188,6 +1059,34 @@ impl<'a> Parser<'a> {\n         self.expected_tokens.clear();\n     }\n \n+    pub fn look_ahead<R, F>(&self, dist: usize, f: F) -> R where\n+        F: FnOnce(&token::Token) -> R,\n+    {\n+        if dist == 0 {\n+            return f(&self.token)\n+        }\n+\n+        f(&match self.token_cursor.frame.tree_cursor.look_ahead(dist - 1) {\n+            Some(tree) => match tree {\n+                TokenTree::Token(_, tok) => tok,\n+                TokenTree::Delimited(_, delim, _) => token::OpenDelim(delim),\n+            },\n+            None => token::CloseDelim(self.token_cursor.frame.delim),\n+        })\n+    }\n+\n+    crate fn look_ahead_span(&self, dist: usize) -> Span {\n+        if dist == 0 {\n+            return self.span\n+        }\n+\n+        match self.token_cursor.frame.tree_cursor.look_ahead(dist - 1) {\n+            Some(TokenTree::Token(span, _)) => span,\n+            Some(TokenTree::Delimited(span, ..)) => span.entire(),\n+            None => self.look_ahead_span(dist - 1),\n+        }\n+    }\n+\n     /// Is the current token one of the keywords that signals a bare function type?\n     fn token_is_bare_fn_keyword(&mut self) -> bool {\n         self.check_keyword(kw::Fn) ||"}, {"sha": "a003a01941bdee3981b4cd322c7273d7be338f4e", "filename": "src/test/ui/invalid-self-argument/bare-fn-start.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4e68ddca90a8f3ee580445b1fc83a6a6d0c7f94f/src%2Ftest%2Fui%2Finvalid-self-argument%2Fbare-fn-start.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e68ddca90a8f3ee580445b1fc83a6a6d0c7f94f/src%2Ftest%2Fui%2Finvalid-self-argument%2Fbare-fn-start.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finvalid-self-argument%2Fbare-fn-start.rs?ref=4e68ddca90a8f3ee580445b1fc83a6a6d0c7f94f", "patch": "@@ -1,6 +1,6 @@\n fn a(&self) { }\n-//~^ ERROR unexpected `self` argument in function\n-//~| NOTE not valid as function argument\n-//~| NOTE `self` is only valid as the first argument of an associated function\n+//~^ ERROR unexpected `self` parameter in function\n+//~| NOTE not valid as function parameter\n+//~| NOTE `self` is only valid as the first parameter of an associated function\n \n fn main() { }"}, {"sha": "23de6502094f0e7cf5093f4c92e75980856d1475", "filename": "src/test/ui/invalid-self-argument/bare-fn-start.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4e68ddca90a8f3ee580445b1fc83a6a6d0c7f94f/src%2Ftest%2Fui%2Finvalid-self-argument%2Fbare-fn-start.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4e68ddca90a8f3ee580445b1fc83a6a6d0c7f94f/src%2Ftest%2Fui%2Finvalid-self-argument%2Fbare-fn-start.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finvalid-self-argument%2Fbare-fn-start.stderr?ref=4e68ddca90a8f3ee580445b1fc83a6a6d0c7f94f", "patch": "@@ -1,10 +1,10 @@\n-error: unexpected `self` argument in function\n+error: unexpected `self` parameter in function\n   --> $DIR/bare-fn-start.rs:1:6\n    |\n LL | fn a(&self) { }\n-   |      ^^^^^ not valid as function argument\n+   |      ^^^^^ not valid as function parameter\n    |\n-   = note: `self` is only valid as the first argument of an associated function\n+   = note: `self` is only valid as the first parameter of an associated function\n \n error: aborting due to previous error\n "}, {"sha": "73d68e8b7a5ab340375bb570688a08f734313d92", "filename": "src/test/ui/invalid-self-argument/bare-fn.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4e68ddca90a8f3ee580445b1fc83a6a6d0c7f94f/src%2Ftest%2Fui%2Finvalid-self-argument%2Fbare-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e68ddca90a8f3ee580445b1fc83a6a6d0c7f94f/src%2Ftest%2Fui%2Finvalid-self-argument%2Fbare-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finvalid-self-argument%2Fbare-fn.rs?ref=4e68ddca90a8f3ee580445b1fc83a6a6d0c7f94f", "patch": "@@ -1,6 +1,6 @@\n fn b(foo: u32, &mut self) { }\n-//~^ ERROR unexpected `self` argument in function\n-//~| NOTE not valid as function argument\n-//~| NOTE `self` is only valid as the first argument of an associated function\n+//~^ ERROR unexpected `self` parameter in function\n+//~| NOTE not valid as function parameter\n+//~| NOTE `self` is only valid as the first parameter of an associated function\n \n fn main() { }"}, {"sha": "601a51bb4a96a4b8f535477acf4ade088d69e4bc", "filename": "src/test/ui/invalid-self-argument/bare-fn.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4e68ddca90a8f3ee580445b1fc83a6a6d0c7f94f/src%2Ftest%2Fui%2Finvalid-self-argument%2Fbare-fn.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4e68ddca90a8f3ee580445b1fc83a6a6d0c7f94f/src%2Ftest%2Fui%2Finvalid-self-argument%2Fbare-fn.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finvalid-self-argument%2Fbare-fn.stderr?ref=4e68ddca90a8f3ee580445b1fc83a6a6d0c7f94f", "patch": "@@ -1,10 +1,10 @@\n-error: unexpected `self` argument in function\n+error: unexpected `self` parameter in function\n   --> $DIR/bare-fn.rs:1:16\n    |\n LL | fn b(foo: u32, &mut self) { }\n-   |                ^^^^^^^^^ not valid as function argument\n+   |                ^^^^^^^^^ not valid as function parameter\n    |\n-   = note: `self` is only valid as the first argument of an associated function\n+   = note: `self` is only valid as the first parameter of an associated function\n \n error: aborting due to previous error\n "}, {"sha": "1e8220d7b4a781743c41f810a3f3957a9e2f7479", "filename": "src/test/ui/invalid-self-argument/trait-fn.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4e68ddca90a8f3ee580445b1fc83a6a6d0c7f94f/src%2Ftest%2Fui%2Finvalid-self-argument%2Ftrait-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e68ddca90a8f3ee580445b1fc83a6a6d0c7f94f/src%2Ftest%2Fui%2Finvalid-self-argument%2Ftrait-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finvalid-self-argument%2Ftrait-fn.rs?ref=4e68ddca90a8f3ee580445b1fc83a6a6d0c7f94f", "patch": "@@ -2,8 +2,8 @@ struct Foo {}\n \n impl Foo {\n     fn c(foo: u32, self) {}\n-    //~^ ERROR unexpected `self` argument in function\n-    //~| NOTE must be the first associated function argument\n+    //~^ ERROR unexpected `self` parameter in function\n+    //~| NOTE must be the first associated function parameter\n \n     fn good(&mut self, foo: u32) {}\n }"}, {"sha": "96a2251c036b19658c016a5f6dab9110e7219c60", "filename": "src/test/ui/invalid-self-argument/trait-fn.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4e68ddca90a8f3ee580445b1fc83a6a6d0c7f94f/src%2Ftest%2Fui%2Finvalid-self-argument%2Ftrait-fn.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4e68ddca90a8f3ee580445b1fc83a6a6d0c7f94f/src%2Ftest%2Fui%2Finvalid-self-argument%2Ftrait-fn.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finvalid-self-argument%2Ftrait-fn.stderr?ref=4e68ddca90a8f3ee580445b1fc83a6a6d0c7f94f", "patch": "@@ -1,8 +1,8 @@\n-error: unexpected `self` argument in function\n+error: unexpected `self` parameter in function\n   --> $DIR/trait-fn.rs:4:20\n    |\n LL |     fn c(foo: u32, self) {}\n-   |                    ^^^^ must be the first associated function argument\n+   |                    ^^^^ must be the first associated function parameter\n \n error: aborting due to previous error\n "}, {"sha": "6172ffe1b0347aee9440f8a84b15ea04a82c93b2", "filename": "src/test/ui/parser/self-in-function-arg.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4e68ddca90a8f3ee580445b1fc83a6a6d0c7f94f/src%2Ftest%2Fui%2Fparser%2Fself-in-function-arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e68ddca90a8f3ee580445b1fc83a6a6d0c7f94f/src%2Ftest%2Fui%2Fparser%2Fself-in-function-arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fself-in-function-arg.rs?ref=4e68ddca90a8f3ee580445b1fc83a6a6d0c7f94f", "patch": "@@ -1,3 +1,3 @@\n-fn foo(x:i32, self: i32) -> i32 { self } //~ ERROR unexpected `self` argument in function\n+fn foo(x:i32, self: i32) -> i32 { self } //~ ERROR unexpected `self` parameter in function\n \n fn main() {}"}, {"sha": "f58df9b9e79b327a20c0c389d42b7affd2a3d444", "filename": "src/test/ui/parser/self-in-function-arg.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4e68ddca90a8f3ee580445b1fc83a6a6d0c7f94f/src%2Ftest%2Fui%2Fparser%2Fself-in-function-arg.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4e68ddca90a8f3ee580445b1fc83a6a6d0c7f94f/src%2Ftest%2Fui%2Fparser%2Fself-in-function-arg.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fself-in-function-arg.stderr?ref=4e68ddca90a8f3ee580445b1fc83a6a6d0c7f94f", "patch": "@@ -1,10 +1,10 @@\n-error: unexpected `self` argument in function\n+error: unexpected `self` parameter in function\n   --> $DIR/self-in-function-arg.rs:1:15\n    |\n LL | fn foo(x:i32, self: i32) -> i32 { self }\n-   |               ^^^^ not valid as function argument\n+   |               ^^^^ not valid as function parameter\n    |\n-   = note: `self` is only valid as the first argument of an associated function\n+   = note: `self` is only valid as the first parameter of an associated function\n \n error: aborting due to previous error\n "}]}