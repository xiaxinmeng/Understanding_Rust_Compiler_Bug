{"sha": "c1c09bee29732c3e47939a7253c7d0e56ffbc280", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMxYzA5YmVlMjk3MzJjM2U0NzkzOWE3MjUzYzdkMGU1NmZmYmMyODA=", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2020-01-01T17:06:00Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2020-01-08T09:37:37Z"}, "message": "Move `is_min_const_fn` query to librustc_mir.\n\nThe only two uses of the associated methods are in librustc_mir and\nlibrustdoc. Please tell me if there is a better choice.", "tree": {"sha": "5e2764d45ef1c368c8ceb2cd4ec92551b46d6250", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5e2764d45ef1c368c8ceb2cd4ec92551b46d6250"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c1c09bee29732c3e47939a7253c7d0e56ffbc280", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c1c09bee29732c3e47939a7253c7d0e56ffbc280", "html_url": "https://github.com/rust-lang/rust/commit/c1c09bee29732c3e47939a7253c7d0e56ffbc280", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c1c09bee29732c3e47939a7253c7d0e56ffbc280/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "588296adfe72260a109c5962c1ca2784505e77f9", "url": "https://api.github.com/repos/rust-lang/rust/commits/588296adfe72260a109c5962c1ca2784505e77f9", "html_url": "https://github.com/rust-lang/rust/commit/588296adfe72260a109c5962c1ca2784505e77f9"}], "stats": {"total": 170, "additions": 86, "deletions": 84}, "files": [{"sha": "747e6e8da99af35b572c274a0dbf6e8aa55cd052", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c1c09bee29732c3e47939a7253c7d0e56ffbc280/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1c09bee29732c3e47939a7253c7d0e56ffbc280/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=c1c09bee29732c3e47939a7253c7d0e56ffbc280", "patch": "@@ -97,7 +97,6 @@ pub mod cast;\n #[macro_use]\n pub mod codec;\n pub mod _match;\n-mod constness;\n mod erase_regions;\n pub mod error;\n pub mod fast_reject;\n@@ -3318,7 +3317,6 @@ pub fn provide(providers: &mut ty::query::Providers<'_>) {\n     context::provide(providers);\n     erase_regions::provide(providers);\n     layout::provide(providers);\n-    constness::provide(providers);\n     *providers = ty::query::Providers {\n         asyncness,\n         associated_item,"}, {"sha": "7b2ce7f9ac7be9f3f4d8d318bbf1436aaf59fea0", "filename": "src/librustc_mir/const_eval.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c1c09bee29732c3e47939a7253c7d0e56ffbc280/src%2Flibrustc_mir%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1c09bee29732c3e47939a7253c7d0e56ffbc280/src%2Flibrustc_mir%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval.rs?ref=c1c09bee29732c3e47939a7253c7d0e56ffbc280", "patch": "@@ -9,10 +9,12 @@ use crate::interpret::{intern_const_alloc_recursive, ConstValue, InterpCx};\n \n mod error;\n mod eval_queries;\n+mod fn_queries;\n mod machine;\n \n pub use error::*;\n pub use eval_queries::*;\n+pub use fn_queries::*;\n pub use machine::*;\n \n /// Extracts a field of a (variant of a) const."}, {"sha": "2443e1e91d378faa445881e5bc39a3898a0324e4", "filename": "src/librustc_mir/const_eval/fn_queries.rs", "status": "modified", "additions": 67, "deletions": 72, "changes": 139, "blob_url": "https://github.com/rust-lang/rust/blob/c1c09bee29732c3e47939a7253c7d0e56ffbc280/src%2Flibrustc_mir%2Fconst_eval%2Ffn_queries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1c09bee29732c3e47939a7253c7d0e56ffbc280/src%2Flibrustc_mir%2Fconst_eval%2Ffn_queries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval%2Ffn_queries.rs?ref=c1c09bee29732c3e47939a7253c7d0e56ffbc280", "patch": "@@ -1,89 +1,84 @@\n-use crate::hir::map::blocks::FnLikeNode;\n-use crate::ty::query::Providers;\n-use crate::ty::TyCtxt;\n+use rustc::hir::map::blocks::FnLikeNode;\n+use rustc::ty::query::Providers;\n+use rustc::ty::TyCtxt;\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n use rustc_span::symbol::Symbol;\n use rustc_target::spec::abi::Abi;\n use syntax::attr;\n \n-impl<'tcx> TyCtxt<'tcx> {\n-    /// Whether the `def_id` counts as const fn in your current crate, considering all active\n-    /// feature gates\n-    pub fn is_const_fn(self, def_id: DefId) -> bool {\n-        self.is_const_fn_raw(def_id)\n-            && match self.is_unstable_const_fn(def_id) {\n-                Some(feature_name) => {\n-                    // has a `rustc_const_unstable` attribute, check whether the user enabled the\n-                    // corresponding feature gate.\n-                    self.features()\n-                        .declared_lib_features\n-                        .iter()\n-                        .any(|&(sym, _)| sym == feature_name)\n-                }\n-                // functions without const stability are either stable user written\n-                // const fn or the user is using feature gates and we thus don't\n-                // care what they do\n-                None => true,\n+/// Whether the `def_id` counts as const fn in your current crate, considering all active\n+/// feature gates\n+pub fn is_const_fn(tcx: TyCtxt<'_>, def_id: DefId) -> bool {\n+    tcx.is_const_fn_raw(def_id)\n+        && match is_unstable_const_fn(tcx, def_id) {\n+            Some(feature_name) => {\n+                // has a `rustc_const_unstable` attribute, check whether the user enabled the\n+                // corresponding feature gate.\n+                tcx.features().declared_lib_features.iter().any(|&(sym, _)| sym == feature_name)\n             }\n-    }\n-\n-    /// Whether the `def_id` is an unstable const fn and what feature gate is necessary to enable it\n-    pub fn is_unstable_const_fn(self, def_id: DefId) -> Option<Symbol> {\n-        if self.is_const_fn_raw(def_id) {\n-            let const_stab = self.lookup_const_stability(def_id)?;\n-            if const_stab.level.is_unstable() { Some(const_stab.feature) } else { None }\n-        } else {\n-            None\n+            // functions without const stability are either stable user written\n+            // const fn or the user is using feature gates and we thus don't\n+            // care what they do\n+            None => true,\n         }\n+}\n+\n+/// Whether the `def_id` is an unstable const fn and what feature gate is necessary to enable it\n+pub fn is_unstable_const_fn(tcx: TyCtxt<'_>, def_id: DefId) -> Option<Symbol> {\n+    if tcx.is_const_fn_raw(def_id) {\n+        let const_stab = tcx.lookup_const_stability(def_id)?;\n+        if const_stab.level.is_unstable() { Some(const_stab.feature) } else { None }\n+    } else {\n+        None\n     }\n+}\n \n-    /// Returns `true` if this function must conform to `min_const_fn`\n-    pub fn is_min_const_fn(self, def_id: DefId) -> bool {\n-        // Bail out if the signature doesn't contain `const`\n-        if !self.is_const_fn_raw(def_id) {\n-            return false;\n-        }\n+/// Returns `true` if this function must conform to `min_const_fn`\n+pub fn is_min_const_fn(tcx: TyCtxt<'_>, def_id: DefId) -> bool {\n+    // Bail out if the signature doesn't contain `const`\n+    if !tcx.is_const_fn_raw(def_id) {\n+        return false;\n+    }\n \n-        if self.features().staged_api {\n-            // In order for a libstd function to be considered min_const_fn\n-            // it needs to be stable and have no `rustc_const_unstable` attribute.\n-            match self.lookup_const_stability(def_id) {\n-                // `rustc_const_unstable` functions don't need to conform.\n-                Some(&attr::ConstStability { ref level, .. }) if level.is_unstable() => false,\n-                None => {\n-                    if let Some(stab) = self.lookup_stability(def_id) {\n-                        if stab.level.is_stable() {\n-                            self.sess.span_err(\n-                                self.def_span(def_id),\n-                                \"stable const functions must have either `rustc_const_stable` or \\\n-                            `rustc_const_unstable` attribute\",\n-                            );\n-                            // While we errored above, because we don't know if we need to conform, we\n-                            // err on the \"safe\" side and require min_const_fn.\n-                            true\n-                        } else {\n-                            // Unstable functions need not conform to min_const_fn.\n-                            false\n-                        }\n-                    } else {\n-                        // Internal functions are forced to conform to min_const_fn.\n-                        // Annotate the internal function with a const stability attribute if\n-                        // you need to use unstable features.\n-                        // Note: this is an arbitrary choice that does not affect stability or const\n-                        // safety or anything, it just changes whether we need to annotate some\n-                        // internal functions with `rustc_const_stable` or with `rustc_const_unstable`\n+    if tcx.features().staged_api {\n+        // In order for a libstd function to be considered min_const_fn\n+        // it needs to be stable and have no `rustc_const_unstable` attribute.\n+        match tcx.lookup_const_stability(def_id) {\n+            // `rustc_const_unstable` functions don't need to conform.\n+            Some(&attr::ConstStability { ref level, .. }) if level.is_unstable() => false,\n+            None => {\n+                if let Some(stab) = tcx.lookup_stability(def_id) {\n+                    if stab.level.is_stable() {\n+                        tcx.sess.span_err(\n+                            tcx.def_span(def_id),\n+                            \"stable const functions must have either `rustc_const_stable` or \\\n+                             `rustc_const_unstable` attribute\",\n+                        );\n+                        // While we errored above, because we don't know if we need to conform, we\n+                        // err on the \"safe\" side and require min_const_fn.\n                         true\n+                    } else {\n+                        // Unstable functions need not conform to min_const_fn.\n+                        false\n                     }\n+                } else {\n+                    // Internal functions are forced to conform to min_const_fn.\n+                    // Annotate the internal function with a const stability attribute if\n+                    // you need to use unstable features.\n+                    // Note: this is an arbitrary choice that does not affect stability or const\n+                    // safety or anything, it just changes whether we need to annotate some\n+                    // internal functions with `rustc_const_stable` or with `rustc_const_unstable`\n+                    true\n                 }\n-                // Everything else needs to conform, because it would be callable from\n-                // other `min_const_fn` functions.\n-                _ => true,\n             }\n-        } else {\n-            // users enabling the `const_fn` feature gate can do what they want\n-            !self.features().const_fn\n+            // Everything else needs to conform, because it would be callable from\n+            // other `min_const_fn` functions.\n+            _ => true,\n         }\n+    } else {\n+        // users enabling the `const_fn` feature gate can do what they want\n+        !tcx.features().const_fn\n     }\n }\n \n@@ -121,7 +116,7 @@ pub fn provide(providers: &mut Providers<'_>) {\n     }\n \n     fn is_promotable_const_fn(tcx: TyCtxt<'_>, def_id: DefId) -> bool {\n-        tcx.is_const_fn(def_id)\n+        is_const_fn(tcx, def_id)\n             && match tcx.lookup_const_stability(def_id) {\n                 Some(stab) => {\n                     if cfg!(debug_assertions) && stab.promotable {\n@@ -140,7 +135,7 @@ pub fn provide(providers: &mut Providers<'_>) {\n     }\n \n     fn const_fn_is_allowed_fn_ptr(tcx: TyCtxt<'_>, def_id: DefId) -> bool {\n-        tcx.is_const_fn(def_id)\n+        is_const_fn(tcx, def_id)\n             && tcx\n                 .lookup_const_stability(def_id)\n                 .map(|stab| stab.allow_const_fn_ptr)"}, {"sha": "b384d19905167cff17503ac5cdeed219317531e7", "filename": "src/librustc_mir/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c1c09bee29732c3e47939a7253c7d0e56ffbc280/src%2Flibrustc_mir%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1c09bee29732c3e47939a7253c7d0e56ffbc280/src%2Flibrustc_mir%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Flib.rs?ref=c1c09bee29732c3e47939a7253c7d0e56ffbc280", "patch": "@@ -54,6 +54,7 @@ use rustc::ty::query::Providers;\n \n pub fn provide(providers: &mut Providers<'_>) {\n     borrow_check::provide(providers);\n+    const_eval::provide(providers);\n     shim::provide(providers);\n     transform::provide(providers);\n     monomorphize::partitioning::provide(providers);"}, {"sha": "83fd07f31d4d62b1d99668ec53bc04cbbf58658b", "filename": "src/librustc_mir/transform/check_consts/validation.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c1c09bee29732c3e47939a7253c7d0e56ffbc280/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1c09bee29732c3e47939a7253c7d0e56ffbc280/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs?ref=c1c09bee29732c3e47939a7253c7d0e56ffbc280", "patch": "@@ -20,6 +20,7 @@ use super::ops::{self, NonConstOp};\n use super::qualifs::{self, HasMutInterior, NeedsDrop};\n use super::resolver::FlowSensitiveAnalysis;\n use super::{is_lang_panic_fn, ConstKind, Item, Qualif};\n+use crate::const_eval::{is_const_fn, is_unstable_const_fn};\n use crate::dataflow::{self as old_dataflow, generic as dataflow};\n \n pub type IndirectlyMutableResults<'mir, 'tcx> =\n@@ -172,7 +173,7 @@ impl Validator<'a, 'mir, 'tcx> {\n         let Item { tcx, body, def_id, const_kind, .. } = *self.item;\n \n         let use_min_const_fn_checks = (const_kind == Some(ConstKind::ConstFn)\n-            && tcx.is_min_const_fn(def_id))\n+            && crate::const_eval::is_min_const_fn(tcx, def_id))\n             && !tcx.sess.opts.debugging_opts.unleash_the_miri_inside_of_you;\n \n         if use_min_const_fn_checks {\n@@ -559,13 +560,13 @@ impl Visitor<'tcx> for Validator<'_, 'mir, 'tcx> {\n                 };\n \n                 // At this point, we are calling a function whose `DefId` is known...\n-                if self.tcx.is_const_fn(def_id) {\n+                if is_const_fn(self.tcx, def_id) {\n                     return;\n                 }\n \n                 if is_lang_panic_fn(self.tcx, def_id) {\n                     self.check_op(ops::Panic);\n-                } else if let Some(feature) = self.tcx.is_unstable_const_fn(def_id) {\n+                } else if let Some(feature) = is_unstable_const_fn(self.tcx, def_id) {\n                     // Exempt unstable const fns inside of macros with\n                     // `#[allow_internal_unstable]`.\n                     if !self.span.allows_unstable(feature) {"}, {"sha": "5dc93e7c062883c7cfab48539eff41ad7aa25aff", "filename": "src/librustc_mir/transform/check_unsafety.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c1c09bee29732c3e47939a7253c7d0e56ffbc280/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1c09bee29732c3e47939a7253c7d0e56ffbc280/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs?ref=c1c09bee29732c3e47939a7253c7d0e56ffbc280", "patch": "@@ -13,6 +13,7 @@ use rustc_span::symbol::{sym, Symbol};\n \n use std::ops::Bound;\n \n+use crate::const_eval::{is_const_fn, is_min_const_fn};\n use crate::util;\n \n use rustc_error_codes::*;\n@@ -522,7 +523,7 @@ fn unsafety_check_result(tcx: TyCtxt<'_>, def_id: DefId) -> UnsafetyCheckResult\n     let id = tcx.hir().as_local_hir_id(def_id).unwrap();\n     let (const_context, min_const_fn) = match tcx.hir().body_owner_kind(id) {\n         hir::BodyOwnerKind::Closure => (false, false),\n-        hir::BodyOwnerKind::Fn => (tcx.is_const_fn(def_id), tcx.is_min_const_fn(def_id)),\n+        hir::BodyOwnerKind::Fn => (is_const_fn(tcx, def_id), is_min_const_fn(tcx, def_id)),\n         hir::BodyOwnerKind::Const | hir::BodyOwnerKind::Static(_) => (true, false),\n     };\n     let mut checker = UnsafetyChecker::new(const_context, min_const_fn, body, tcx, param_env);"}, {"sha": "00a39905c023292d24e7664fbbf48c215c54b13d", "filename": "src/librustc_mir/transform/promote_consts.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c1c09bee29732c3e47939a7253c7d0e56ffbc280/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1c09bee29732c3e47939a7253c7d0e56ffbc280/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs?ref=c1c09bee29732c3e47939a7253c7d0e56ffbc280", "patch": "@@ -29,6 +29,7 @@ use rustc_target::spec::abi::Abi;\n use std::cell::Cell;\n use std::{iter, mem, usize};\n \n+use crate::const_eval::{is_const_fn, is_unstable_const_fn};\n use crate::transform::check_consts::{is_lang_panic_fn, qualifs, ConstKind, Item};\n use crate::transform::{MirPass, MirSource};\n \n@@ -702,8 +703,8 @@ impl<'tcx> Validator<'_, 'tcx> {\n \n         let is_const_fn = match fn_ty.kind {\n             ty::FnDef(def_id, _) => {\n-                self.tcx.is_const_fn(def_id)\n-                    || self.tcx.is_unstable_const_fn(def_id).is_some()\n+                is_const_fn(self.tcx, def_id)\n+                    || is_unstable_const_fn(self.tcx, def_id).is_some()\n                     || is_lang_panic_fn(self.tcx, self.def_id)\n             }\n             _ => false,"}, {"sha": "fcdabb29cd0e240087c5c1cc2fb0b5e782d0d720", "filename": "src/librustc_mir/transform/qualify_min_const_fn.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c1c09bee29732c3e47939a7253c7d0e56ffbc280/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1c09bee29732c3e47939a7253c7d0e56ffbc280/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs?ref=c1c09bee29732c3e47939a7253c7d0e56ffbc280", "patch": "@@ -327,7 +327,7 @@ fn check_terminator(\n         TerminatorKind::Call { func, args, from_hir_call: _, destination: _, cleanup: _ } => {\n             let fn_ty = func.ty(body, tcx);\n             if let ty::FnDef(def_id, _) = fn_ty.kind {\n-                if !tcx.is_min_const_fn(def_id) {\n+                if !crate::const_eval::is_min_const_fn(tcx, def_id) {\n                     return Err((\n                         span,\n                         format!("}, {"sha": "c7e0f1e9e704ba0683a838307205f56a39ac8341", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c1c09bee29732c3e47939a7253c7d0e56ffbc280/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1c09bee29732c3e47939a7253c7d0e56ffbc280/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=c1c09bee29732c3e47939a7253c7d0e56ffbc280", "patch": "@@ -9,6 +9,7 @@ use rustc_hir::def::{CtorKind, DefKind, Res};\n use rustc_hir::def_id::DefId;\n use rustc_hir::Mutability;\n use rustc_metadata::creader::LoadedMacro;\n+use rustc_mir::const_eval::is_min_const_fn;\n use rustc_span::hygiene::MacroKind;\n use rustc_span::symbol::sym;\n use rustc_span::Span;\n@@ -212,7 +213,7 @@ fn build_external_function(cx: &DocContext<'_>, did: DefId) -> clean::Function {\n     let sig = cx.tcx.fn_sig(did);\n \n     let constness =\n-        if cx.tcx.is_min_const_fn(did) { hir::Constness::Const } else { hir::Constness::NotConst };\n+        if is_min_const_fn(cx.tcx, did) { hir::Constness::Const } else { hir::Constness::NotConst };\n     let asyncness = cx.tcx.asyncness(did);\n     let predicates = cx.tcx.predicates_of(did);\n     let (generics, decl) = clean::enter_impl_trait(cx, || {"}, {"sha": "be9654612f504e91163a02adc414d459735c08bd", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c1c09bee29732c3e47939a7253c7d0e56ffbc280/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1c09bee29732c3e47939a7253c7d0e56ffbc280/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=c1c09bee29732c3e47939a7253c7d0e56ffbc280", "patch": "@@ -21,6 +21,7 @@ use rustc_hir as hir;\n use rustc_hir::def::{CtorKind, DefKind, Res};\n use rustc_hir::def_id::{CrateNum, DefId, CRATE_DEF_INDEX};\n use rustc_index::vec::{Idx, IndexVec};\n+use rustc_mir::const_eval::is_min_const_fn;\n use rustc_span::hygiene::MacroKind;\n use rustc_span::symbol::{kw, sym};\n use rustc_span::{self, Pos};\n@@ -895,7 +896,7 @@ impl Clean<Item> for doctree::Function<'_> {\n             enter_impl_trait(cx, || (self.generics.clean(cx), (self.decl, self.body).clean(cx)));\n \n         let did = cx.tcx.hir().local_def_id(self.id);\n-        let constness = if cx.tcx.is_min_const_fn(did) {\n+        let constness = if is_min_const_fn(cx.tcx, did) {\n             hir::Constness::Const\n         } else {\n             hir::Constness::NotConst\n@@ -1187,7 +1188,7 @@ impl Clean<Item> for ty::AssocItem {\n                 };\n                 let (all_types, ret_types) = get_all_types(&generics, &decl, cx);\n                 if provided {\n-                    let constness = if cx.tcx.is_min_const_fn(self.def_id) {\n+                    let constness = if is_min_const_fn(cx.tcx, self.def_id) {\n                         hir::Constness::Const\n                     } else {\n                         hir::Constness::NotConst"}, {"sha": "32c93ee3b164dbf9157a0f71fc59f5f3dc70148b", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c1c09bee29732c3e47939a7253c7d0e56ffbc280/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1c09bee29732c3e47939a7253c7d0e56ffbc280/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=c1c09bee29732c3e47939a7253c7d0e56ffbc280", "patch": "@@ -32,6 +32,7 @@ extern crate rustc_interface;\n extern crate rustc_lexer;\n extern crate rustc_lint;\n extern crate rustc_metadata;\n+extern crate rustc_mir;\n extern crate rustc_parse;\n extern crate rustc_resolve;\n extern crate rustc_span as rustc_span;"}]}