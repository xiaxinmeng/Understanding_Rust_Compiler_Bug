{"sha": "05db35dafb47db355e202c9176bd8a752b7390d7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA1ZGIzNWRhZmI0N2RiMzU1ZTIwMmM5MTc2YmQ4YTc1MmI3MzkwZDc=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-05-15T00:10:58Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-05-15T00:10:58Z"}, "message": "Merge #4460\n\n4460: Remove flycheck -> LSP dependency r=matklad a=matklad\n\nbors r+\n\ud83e\udd16\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "885d5729e6223132f571e12688fc3f2c20c4ab55", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/885d5729e6223132f571e12688fc3f2c20c4ab55"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/05db35dafb47db355e202c9176bd8a752b7390d7", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJevd4SCRBK7hj4Ov3rIwAAdHIIAJS/nyir5SJPjhpcBbftheZa\ng8bxlr0pL1XXoOI69ZJ8O+8/bVFSF+legpP2KaYxLjeHsTFm3iGyyFgN6priGiTo\nPAjzhaWWx0ETsGN/ika9Ri4akIfBA4RBtllghlA4a316pJOejQorWD7y9EwZEAXa\nlfzEv5sREbTyJDdkeJDOPEZTCJUEhilVIjFKHb02nD715ZJTqnam02ApWQKmQCns\nS+2Wc3wsrWTXU9Olx/81vznbHOxrGvt6NBTr7HzQS1slAS22mYQYxDIJhCftFHPp\nwxYqCEpXcb5nu1RSzyt5RtuIfKHPdESDRWPeqNqwDQcPr6FSfCdcnP1Rk2O5h4Y=\n=Zuer\n-----END PGP SIGNATURE-----\n", "payload": "tree 885d5729e6223132f571e12688fc3f2c20c4ab55\nparent 12d82687cd600ec81bf3027661135e5f0d4ad4bd\nparent 08027c307556c8500ca6e44c432a08f83d33d1c3\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1589501458 +0000\ncommitter GitHub <noreply@github.com> 1589501458 +0000\n\nMerge #4460\n\n4460: Remove flycheck -> LSP dependency r=matklad a=matklad\n\nbors r+\n\ud83e\udd16\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/05db35dafb47db355e202c9176bd8a752b7390d7", "html_url": "https://github.com/rust-lang/rust/commit/05db35dafb47db355e202c9176bd8a752b7390d7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/05db35dafb47db355e202c9176bd8a752b7390d7/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "12d82687cd600ec81bf3027661135e5f0d4ad4bd", "url": "https://api.github.com/repos/rust-lang/rust/commits/12d82687cd600ec81bf3027661135e5f0d4ad4bd", "html_url": "https://github.com/rust-lang/rust/commit/12d82687cd600ec81bf3027661135e5f0d4ad4bd"}, {"sha": "08027c307556c8500ca6e44c432a08f83d33d1c3", "url": "https://api.github.com/repos/rust-lang/rust/commits/08027c307556c8500ca6e44c432a08f83d33d1c3", "html_url": "https://github.com/rust-lang/rust/commit/08027c307556c8500ca6e44c432a08f83d33d1c3"}], "stats": {"total": 2996, "additions": 1490, "deletions": 1506}, "files": [{"sha": "f94cea81438ffaac6e40c05f390b4d2cdacf95b7", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/05db35dafb47db355e202c9176bd8a752b7390d7/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/05db35dafb47db355e202c9176bd8a752b7390d7/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=05db35dafb47db355e202c9176bd8a752b7390d7", "patch": "@@ -975,10 +975,8 @@ version = \"0.1.0\"\n dependencies = [\n  \"cargo_metadata\",\n  \"crossbeam-channel\",\n- \"insta\",\n  \"jod-thread\",\n  \"log\",\n- \"lsp-types\",\n  \"ra_toolchain\",\n  \"serde_json\",\n ]\n@@ -1381,6 +1379,7 @@ dependencies = [\n  \"crossbeam-channel\",\n  \"env_logger\",\n  \"globset\",\n+ \"insta\",\n  \"itertools\",\n  \"jod-thread\",\n  \"log\","}, {"sha": "1aa39badea967a560418fc0f76ad8b7d85d54ef6", "filename": "crates/ra_flycheck/Cargo.toml", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/05db35dafb47db355e202c9176bd8a752b7390d7/crates%2Fra_flycheck%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/05db35dafb47db355e202c9176bd8a752b7390d7/crates%2Fra_flycheck%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_flycheck%2FCargo.toml?ref=05db35dafb47db355e202c9176bd8a752b7390d7", "patch": "@@ -9,12 +9,8 @@ doctest = false\n \n [dependencies]\n crossbeam-channel = \"0.4.0\"\n-lsp-types = { version = \"0.74.0\", features = [\"proposed\"] }\n log = \"0.4.8\"\n cargo_metadata = \"0.10.0\"\n serde_json = \"1.0.48\"\n jod-thread = \"0.1.1\"\n ra_toolchain = { path = \"../ra_toolchain\" }\n-\n-[dev-dependencies]\n-insta = \"0.16.0\""}, {"sha": "817543deb1977c288420326cf5f4b1234d56cefc", "filename": "crates/ra_flycheck/src/conv.rs", "status": "removed", "additions": 0, "deletions": 341, "changes": 341, "blob_url": "https://github.com/rust-lang/rust/blob/12d82687cd600ec81bf3027661135e5f0d4ad4bd/crates%2Fra_flycheck%2Fsrc%2Fconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12d82687cd600ec81bf3027661135e5f0d4ad4bd/crates%2Fra_flycheck%2Fsrc%2Fconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_flycheck%2Fsrc%2Fconv.rs?ref=12d82687cd600ec81bf3027661135e5f0d4ad4bd", "patch": "@@ -1,341 +0,0 @@\n-//! This module provides the functionality needed to convert diagnostics from\n-//! `cargo check` json format to the LSP diagnostic format.\n-use cargo_metadata::diagnostic::{\n-    Applicability, Diagnostic as RustDiagnostic, DiagnosticLevel, DiagnosticSpan,\n-    DiagnosticSpanMacroExpansion,\n-};\n-use lsp_types::{\n-    CodeAction, Diagnostic, DiagnosticRelatedInformation, DiagnosticSeverity, DiagnosticTag,\n-    Location, NumberOrString, Position, Range, TextEdit, Url, WorkspaceEdit,\n-};\n-use std::{\n-    collections::HashMap,\n-    fmt::Write,\n-    path::{Component, Path, PathBuf, Prefix},\n-    str::FromStr,\n-};\n-\n-#[cfg(test)]\n-mod test;\n-\n-/// Converts a Rust level string to a LSP severity\n-fn map_level_to_severity(val: DiagnosticLevel) -> Option<DiagnosticSeverity> {\n-    match val {\n-        DiagnosticLevel::Ice => Some(DiagnosticSeverity::Error),\n-        DiagnosticLevel::Error => Some(DiagnosticSeverity::Error),\n-        DiagnosticLevel::Warning => Some(DiagnosticSeverity::Warning),\n-        DiagnosticLevel::Note => Some(DiagnosticSeverity::Information),\n-        DiagnosticLevel::Help => Some(DiagnosticSeverity::Hint),\n-        DiagnosticLevel::Unknown => None,\n-    }\n-}\n-\n-/// Check whether a file name is from macro invocation\n-fn is_from_macro(file_name: &str) -> bool {\n-    file_name.starts_with('<') && file_name.ends_with('>')\n-}\n-\n-/// Converts a Rust macro span to a LSP location recursively\n-fn map_macro_span_to_location(\n-    span_macro: &DiagnosticSpanMacroExpansion,\n-    workspace_root: &PathBuf,\n-) -> Option<Location> {\n-    if !is_from_macro(&span_macro.span.file_name) {\n-        return Some(map_span_to_location(&span_macro.span, workspace_root));\n-    }\n-\n-    if let Some(expansion) = &span_macro.span.expansion {\n-        return map_macro_span_to_location(&expansion, workspace_root);\n-    }\n-\n-    None\n-}\n-\n-/// Converts a Rust span to a LSP location, resolving macro expansion site if neccesary\n-fn map_span_to_location(span: &DiagnosticSpan, workspace_root: &PathBuf) -> Location {\n-    if span.expansion.is_some() {\n-        let expansion = span.expansion.as_ref().unwrap();\n-        if let Some(macro_range) = map_macro_span_to_location(&expansion, workspace_root) {\n-            return macro_range;\n-        }\n-    }\n-\n-    map_span_to_location_naive(span, workspace_root)\n-}\n-\n-/// Converts a Rust span to a LSP location\n-fn map_span_to_location_naive(span: &DiagnosticSpan, workspace_root: &PathBuf) -> Location {\n-    let mut file_name = workspace_root.clone();\n-    file_name.push(&span.file_name);\n-    let uri = url_from_path_with_drive_lowercasing(file_name).unwrap();\n-\n-    let range = Range::new(\n-        Position::new(span.line_start as u64 - 1, span.column_start as u64 - 1),\n-        Position::new(span.line_end as u64 - 1, span.column_end as u64 - 1),\n-    );\n-\n-    Location { uri, range }\n-}\n-\n-/// Converts a secondary Rust span to a LSP related information\n-///\n-/// If the span is unlabelled this will return `None`.\n-fn map_secondary_span_to_related(\n-    span: &DiagnosticSpan,\n-    workspace_root: &PathBuf,\n-) -> Option<DiagnosticRelatedInformation> {\n-    if let Some(label) = &span.label {\n-        let location = map_span_to_location(span, workspace_root);\n-        Some(DiagnosticRelatedInformation { location, message: label.clone() })\n-    } else {\n-        // Nothing to label this with\n-        None\n-    }\n-}\n-\n-/// Determines if diagnostic is related to unused code\n-fn is_unused_or_unnecessary(rd: &RustDiagnostic) -> bool {\n-    if let Some(code) = &rd.code {\n-        match code.code.as_str() {\n-            \"dead_code\" | \"unknown_lints\" | \"unreachable_code\" | \"unused_attributes\"\n-            | \"unused_imports\" | \"unused_macros\" | \"unused_variables\" => true,\n-            _ => false,\n-        }\n-    } else {\n-        false\n-    }\n-}\n-\n-/// Determines if diagnostic is related to deprecated code\n-fn is_deprecated(rd: &RustDiagnostic) -> bool {\n-    if let Some(code) = &rd.code {\n-        match code.code.as_str() {\n-            \"deprecated\" => true,\n-            _ => false,\n-        }\n-    } else {\n-        false\n-    }\n-}\n-\n-enum MappedRustChildDiagnostic {\n-    Related(DiagnosticRelatedInformation),\n-    SuggestedFix(CodeAction),\n-    MessageLine(String),\n-}\n-\n-fn map_rust_child_diagnostic(\n-    rd: &RustDiagnostic,\n-    workspace_root: &PathBuf,\n-) -> MappedRustChildDiagnostic {\n-    let spans: Vec<&DiagnosticSpan> = rd.spans.iter().filter(|s| s.is_primary).collect();\n-    if spans.is_empty() {\n-        // `rustc` uses these spanless children as a way to print multi-line\n-        // messages\n-        return MappedRustChildDiagnostic::MessageLine(rd.message.clone());\n-    }\n-\n-    let mut edit_map: HashMap<Url, Vec<TextEdit>> = HashMap::new();\n-    for &span in &spans {\n-        match (&span.suggestion_applicability, &span.suggested_replacement) {\n-            (Some(Applicability::MachineApplicable), Some(suggested_replacement)) => {\n-                let location = map_span_to_location(span, workspace_root);\n-                let edit = TextEdit::new(location.range, suggested_replacement.clone());\n-                edit_map.entry(location.uri).or_default().push(edit);\n-            }\n-            _ => {}\n-        }\n-    }\n-\n-    if !edit_map.is_empty() {\n-        MappedRustChildDiagnostic::SuggestedFix(CodeAction {\n-            title: rd.message.clone(),\n-            kind: Some(\"quickfix\".to_string()),\n-            diagnostics: None,\n-            edit: Some(WorkspaceEdit::new(edit_map)),\n-            command: None,\n-            is_preferred: None,\n-        })\n-    } else {\n-        MappedRustChildDiagnostic::Related(DiagnosticRelatedInformation {\n-            location: map_span_to_location(spans[0], workspace_root),\n-            message: rd.message.clone(),\n-        })\n-    }\n-}\n-\n-#[derive(Debug)]\n-pub(crate) struct MappedRustDiagnostic {\n-    pub location: Location,\n-    pub diagnostic: Diagnostic,\n-    pub fixes: Vec<CodeAction>,\n-}\n-\n-/// Converts a Rust root diagnostic to LSP form\n-///\n-/// This flattens the Rust diagnostic by:\n-///\n-/// 1. Creating a LSP diagnostic with the root message and primary span.\n-/// 2. Adding any labelled secondary spans to `relatedInformation`\n-/// 3. Categorising child diagnostics as either `SuggestedFix`es,\n-///    `relatedInformation` or additional message lines.\n-///\n-/// If the diagnostic has no primary span this will return `None`\n-pub(crate) fn map_rust_diagnostic_to_lsp(\n-    rd: &RustDiagnostic,\n-    workspace_root: &PathBuf,\n-) -> Vec<MappedRustDiagnostic> {\n-    let primary_spans: Vec<&DiagnosticSpan> = rd.spans.iter().filter(|s| s.is_primary).collect();\n-    if primary_spans.is_empty() {\n-        return vec![];\n-    }\n-\n-    let severity = map_level_to_severity(rd.level);\n-\n-    let mut source = String::from(\"rustc\");\n-    let mut code = rd.code.as_ref().map(|c| c.code.clone());\n-    if let Some(code_val) = &code {\n-        // See if this is an RFC #2103 scoped lint (e.g. from Clippy)\n-        let scoped_code: Vec<&str> = code_val.split(\"::\").collect();\n-        if scoped_code.len() == 2 {\n-            source = String::from(scoped_code[0]);\n-            code = Some(String::from(scoped_code[1]));\n-        }\n-    }\n-\n-    let mut needs_primary_span_label = true;\n-    let mut related_information = vec![];\n-    let mut tags = vec![];\n-\n-    for secondary_span in rd.spans.iter().filter(|s| !s.is_primary) {\n-        let related = map_secondary_span_to_related(secondary_span, workspace_root);\n-        if let Some(related) = related {\n-            related_information.push(related);\n-        }\n-    }\n-\n-    let mut fixes = vec![];\n-    let mut message = rd.message.clone();\n-    for child in &rd.children {\n-        let child = map_rust_child_diagnostic(&child, workspace_root);\n-        match child {\n-            MappedRustChildDiagnostic::Related(related) => related_information.push(related),\n-            MappedRustChildDiagnostic::SuggestedFix(code_action) => fixes.push(code_action),\n-            MappedRustChildDiagnostic::MessageLine(message_line) => {\n-                write!(&mut message, \"\\n{}\", message_line).unwrap();\n-\n-                // These secondary messages usually duplicate the content of the\n-                // primary span label.\n-                needs_primary_span_label = false;\n-            }\n-        }\n-    }\n-\n-    if is_unused_or_unnecessary(rd) {\n-        tags.push(DiagnosticTag::Unnecessary);\n-    }\n-\n-    if is_deprecated(rd) {\n-        tags.push(DiagnosticTag::Deprecated);\n-    }\n-\n-    primary_spans\n-        .iter()\n-        .map(|primary_span| {\n-            let location = map_span_to_location(&primary_span, workspace_root);\n-\n-            let mut message = message.clone();\n-            if needs_primary_span_label {\n-                if let Some(primary_span_label) = &primary_span.label {\n-                    write!(&mut message, \"\\n{}\", primary_span_label).unwrap();\n-                }\n-            }\n-\n-            // If error occurs from macro expansion, add related info pointing to\n-            // where the error originated\n-            if !is_from_macro(&primary_span.file_name) && primary_span.expansion.is_some() {\n-                let def_loc = map_span_to_location_naive(&primary_span, workspace_root);\n-                related_information.push(DiagnosticRelatedInformation {\n-                    location: def_loc,\n-                    message: \"Error originated from macro here\".to_string(),\n-                });\n-            }\n-\n-            let diagnostic = Diagnostic {\n-                range: location.range,\n-                severity,\n-                code: code.clone().map(NumberOrString::String),\n-                source: Some(source.clone()),\n-                message,\n-                related_information: if !related_information.is_empty() {\n-                    Some(related_information.clone())\n-                } else {\n-                    None\n-                },\n-                tags: if !tags.is_empty() { Some(tags.clone()) } else { None },\n-            };\n-\n-            MappedRustDiagnostic { location, diagnostic, fixes: fixes.clone() }\n-        })\n-        .collect()\n-}\n-\n-/// Returns a `Url` object from a given path, will lowercase drive letters if present.\n-/// This will only happen when processing windows paths.\n-///\n-/// When processing non-windows path, this is essentially the same as `Url::from_file_path`.\n-pub fn url_from_path_with_drive_lowercasing(\n-    path: impl AsRef<Path>,\n-) -> Result<Url, Box<dyn std::error::Error + Send + Sync>> {\n-    let component_has_windows_drive = path.as_ref().components().any(|comp| {\n-        if let Component::Prefix(c) = comp {\n-            match c.kind() {\n-                Prefix::Disk(_) | Prefix::VerbatimDisk(_) => return true,\n-                _ => return false,\n-            }\n-        }\n-        false\n-    });\n-\n-    // VSCode expects drive letters to be lowercased, where rust will uppercase the drive letters.\n-    if component_has_windows_drive {\n-        let url_original = Url::from_file_path(&path)\n-            .map_err(|_| format!(\"can't convert path to url: {}\", path.as_ref().display()))?;\n-\n-        let drive_partition: Vec<&str> = url_original.as_str().rsplitn(2, ':').collect();\n-\n-        // There is a drive partition, but we never found a colon.\n-        // This should not happen, but in this case we just pass it through.\n-        if drive_partition.len() == 1 {\n-            return Ok(url_original);\n-        }\n-\n-        let joined = drive_partition[1].to_ascii_lowercase() + \":\" + drive_partition[0];\n-        let url = Url::from_str(&joined).expect(\"This came from a valid `Url`\");\n-\n-        Ok(url)\n-    } else {\n-        Ok(Url::from_file_path(&path)\n-            .map_err(|_| format!(\"can't convert path to url: {}\", path.as_ref().display()))?)\n-    }\n-}\n-\n-// `Url` is not able to parse windows paths on unix machines.\n-#[cfg(target_os = \"windows\")]\n-#[cfg(test)]\n-mod path_conversion_windows_tests {\n-    use super::url_from_path_with_drive_lowercasing;\n-    #[test]\n-    fn test_lowercase_drive_letter_with_drive() {\n-        let url = url_from_path_with_drive_lowercasing(\"C:\\\\Test\").unwrap();\n-\n-        assert_eq!(url.to_string(), \"file:///c:/Test\");\n-    }\n-\n-    #[test]\n-    fn test_drive_without_colon_passthrough() {\n-        let url = url_from_path_with_drive_lowercasing(r#\"\\\\localhost\\C$\\my_dir\"#).unwrap();\n-\n-        assert_eq!(url.to_string(), \"file://localhost/C$/my_dir\");\n-    }\n-}"}, {"sha": "4e81455ca177b5f9165540dad4b085fd26be72b9", "filename": "crates/ra_flycheck/src/conv/test.rs", "status": "removed", "additions": 0, "deletions": 1072, "changes": 1072, "blob_url": "https://github.com/rust-lang/rust/blob/12d82687cd600ec81bf3027661135e5f0d4ad4bd/crates%2Fra_flycheck%2Fsrc%2Fconv%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12d82687cd600ec81bf3027661135e5f0d4ad4bd/crates%2Fra_flycheck%2Fsrc%2Fconv%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_flycheck%2Fsrc%2Fconv%2Ftest.rs?ref=12d82687cd600ec81bf3027661135e5f0d4ad4bd", "patch": "@@ -1,1072 +0,0 @@\n-//! This module contains the large and verbose snapshot tests for the\n-//! conversions between `cargo check` json and LSP diagnostics.\n-#[cfg(not(windows))]\n-use crate::*;\n-\n-#[cfg(not(windows))]\n-fn parse_diagnostic(val: &str) -> cargo_metadata::diagnostic::Diagnostic {\n-    serde_json::from_str::<cargo_metadata::diagnostic::Diagnostic>(val).unwrap()\n-}\n-\n-#[test]\n-#[cfg(not(windows))]\n-fn snap_rustc_incompatible_type_for_trait() {\n-    let diag = parse_diagnostic(\n-        r##\"{\n-            \"message\": \"method `next` has an incompatible type for trait\",\n-            \"code\": {\n-                \"code\": \"E0053\",\n-                \"explanation\": \"\\nThe parameters of any trait method must match between a trait implementation\\nand the trait definition.\\n\\nHere are a couple examples of this error:\\n\\n```compile_fail,E0053\\ntrait Foo {\\n    fn foo(x: u16);\\n    fn bar(&self);\\n}\\n\\nstruct Bar;\\n\\nimpl Foo for Bar {\\n    // error, expected u16, found i16\\n    fn foo(x: i16) { }\\n\\n    // error, types differ in mutability\\n    fn bar(&mut self) { }\\n}\\n```\\n\"\n-            },\n-            \"level\": \"error\",\n-            \"spans\": [\n-                {\n-                    \"file_name\": \"compiler/ty/list_iter.rs\",\n-                    \"byte_start\": 1307,\n-                    \"byte_end\": 1350,\n-                    \"line_start\": 52,\n-                    \"line_end\": 52,\n-                    \"column_start\": 5,\n-                    \"column_end\": 48,\n-                    \"is_primary\": true,\n-                    \"text\": [\n-                        {\n-                            \"text\": \"    fn next(&self) -> Option<&'list ty::Ref<M>> {\",\n-                            \"highlight_start\": 5,\n-                            \"highlight_end\": 48\n-                        }\n-                    ],\n-                    \"label\": \"types differ in mutability\",\n-                    \"suggested_replacement\": null,\n-                    \"suggestion_applicability\": null,\n-                    \"expansion\": null\n-                }\n-            ],\n-            \"children\": [\n-                {\n-                    \"message\": \"expected type `fn(&mut ty::list_iter::ListIterator<'list, M>) -> std::option::Option<&ty::Ref<M>>`\\n   found type `fn(&ty::list_iter::ListIterator<'list, M>) -> std::option::Option<&'list ty::Ref<M>>`\",\n-                    \"code\": null,\n-                    \"level\": \"note\",\n-                    \"spans\": [],\n-                    \"children\": [],\n-                    \"rendered\": null\n-                }\n-            ],\n-            \"rendered\": \"error[E0053]: method `next` has an incompatible type for trait\\n  --> compiler/ty/list_iter.rs:52:5\\n   |\\n52 |     fn next(&self) -> Option<&'list ty::Ref<M>> {\\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ types differ in mutability\\n   |\\n   = note: expected type `fn(&mut ty::list_iter::ListIterator<'list, M>) -> std::option::Option<&ty::Ref<M>>`\\n              found type `fn(&ty::list_iter::ListIterator<'list, M>) -> std::option::Option<&'list ty::Ref<M>>`\\n\\n\"\n-        }\n-        \"##,\n-    );\n-\n-    let workspace_root = PathBuf::from(\"/test/\");\n-    let diag = map_rust_diagnostic_to_lsp(&diag, &workspace_root);\n-    insta::assert_debug_snapshot!(diag);\n-}\n-\n-#[test]\n-#[cfg(not(windows))]\n-fn snap_rustc_unused_variable() {\n-    let diag = parse_diagnostic(\n-        r##\"{\n-\"message\": \"unused variable: `foo`\",\n-\"code\": {\n-    \"code\": \"unused_variables\",\n-    \"explanation\": null\n-},\n-\"level\": \"warning\",\n-\"spans\": [\n-    {\n-        \"file_name\": \"driver/subcommand/repl.rs\",\n-        \"byte_start\": 9228,\n-        \"byte_end\": 9231,\n-        \"line_start\": 291,\n-        \"line_end\": 291,\n-        \"column_start\": 9,\n-        \"column_end\": 12,\n-        \"is_primary\": true,\n-        \"text\": [\n-            {\n-                \"text\": \"    let foo = 42;\",\n-                \"highlight_start\": 9,\n-                \"highlight_end\": 12\n-            }\n-        ],\n-        \"label\": null,\n-        \"suggested_replacement\": null,\n-        \"suggestion_applicability\": null,\n-        \"expansion\": null\n-    }\n-],\n-\"children\": [\n-    {\n-        \"message\": \"#[warn(unused_variables)] on by default\",\n-        \"code\": null,\n-        \"level\": \"note\",\n-        \"spans\": [],\n-        \"children\": [],\n-        \"rendered\": null\n-    },\n-    {\n-        \"message\": \"consider prefixing with an underscore\",\n-        \"code\": null,\n-        \"level\": \"help\",\n-        \"spans\": [\n-            {\n-                \"file_name\": \"driver/subcommand/repl.rs\",\n-                \"byte_start\": 9228,\n-                \"byte_end\": 9231,\n-                \"line_start\": 291,\n-                \"line_end\": 291,\n-                \"column_start\": 9,\n-                \"column_end\": 12,\n-                \"is_primary\": true,\n-                \"text\": [\n-                    {\n-                        \"text\": \"    let foo = 42;\",\n-                        \"highlight_start\": 9,\n-                        \"highlight_end\": 12\n-                    }\n-                ],\n-                \"label\": null,\n-                \"suggested_replacement\": \"_foo\",\n-                \"suggestion_applicability\": \"MachineApplicable\",\n-                \"expansion\": null\n-            }\n-        ],\n-        \"children\": [],\n-        \"rendered\": null\n-    }\n-],\n-\"rendered\": \"warning: unused variable: `foo`\\n   --> driver/subcommand/repl.rs:291:9\\n    |\\n291 |     let foo = 42;\\n    |         ^^^ help: consider prefixing with an underscore: `_foo`\\n    |\\n    = note: #[warn(unused_variables)] on by default\\n\\n\"\n-}\"##,\n-    );\n-\n-    let workspace_root = PathBuf::from(\"/test/\");\n-    let diag = map_rust_diagnostic_to_lsp(&diag, &workspace_root);\n-    insta::assert_debug_snapshot!(diag);\n-}\n-\n-#[test]\n-#[cfg(not(windows))]\n-fn snap_rustc_wrong_number_of_parameters() {\n-    let diag = parse_diagnostic(\n-        r##\"{\n-\"message\": \"this function takes 2 parameters but 3 parameters were supplied\",\n-\"code\": {\n-    \"code\": \"E0061\",\n-    \"explanation\": \"\\nThe number of arguments passed to a function must match the number of arguments\\nspecified in the function signature.\\n\\nFor example, a function like:\\n\\n```\\nfn f(a: u16, b: &str) {}\\n```\\n\\nMust always be called with exactly two arguments, e.g., `f(2, \\\"test\\\")`.\\n\\nNote that Rust does not have a notion of optional function arguments or\\nvariadic functions (except for its C-FFI).\\n\"\n-},\n-\"level\": \"error\",\n-\"spans\": [\n-    {\n-        \"file_name\": \"compiler/ty/select.rs\",\n-        \"byte_start\": 8787,\n-        \"byte_end\": 9241,\n-        \"line_start\": 219,\n-        \"line_end\": 231,\n-        \"column_start\": 5,\n-        \"column_end\": 6,\n-        \"is_primary\": false,\n-        \"text\": [\n-            {\n-                \"text\": \"    pub fn add_evidence(\",\n-                \"highlight_start\": 5,\n-                \"highlight_end\": 25\n-            },\n-            {\n-                \"text\": \"        &mut self,\",\n-                \"highlight_start\": 1,\n-                \"highlight_end\": 19\n-            },\n-            {\n-                \"text\": \"        target_poly: &ty::Ref<ty::Poly>,\",\n-                \"highlight_start\": 1,\n-                \"highlight_end\": 41\n-            },\n-            {\n-                \"text\": \"        evidence_poly: &ty::Ref<ty::Poly>,\",\n-                \"highlight_start\": 1,\n-                \"highlight_end\": 43\n-            },\n-            {\n-                \"text\": \"    ) {\",\n-                \"highlight_start\": 1,\n-                \"highlight_end\": 8\n-            },\n-            {\n-                \"text\": \"        match target_poly {\",\n-                \"highlight_start\": 1,\n-                \"highlight_end\": 28\n-            },\n-            {\n-                \"text\": \"            ty::Ref::Var(tvar, _) => self.add_var_evidence(tvar, evidence_poly),\",\n-                \"highlight_start\": 1,\n-                \"highlight_end\": 81\n-            },\n-            {\n-                \"text\": \"            ty::Ref::Fixed(target_ty) => {\",\n-                \"highlight_start\": 1,\n-                \"highlight_end\": 43\n-            },\n-            {\n-                \"text\": \"                let evidence_ty = evidence_poly.resolve_to_ty();\",\n-                \"highlight_start\": 1,\n-                \"highlight_end\": 65\n-            },\n-            {\n-                \"text\": \"                self.add_evidence_ty(target_ty, evidence_poly, evidence_ty)\",\n-                \"highlight_start\": 1,\n-                \"highlight_end\": 76\n-            },\n-            {\n-                \"text\": \"            }\",\n-                \"highlight_start\": 1,\n-                \"highlight_end\": 14\n-            },\n-            {\n-                \"text\": \"        }\",\n-                \"highlight_start\": 1,\n-                \"highlight_end\": 10\n-            },\n-            {\n-                \"text\": \"    }\",\n-                \"highlight_start\": 1,\n-                \"highlight_end\": 6\n-            }\n-        ],\n-        \"label\": \"defined here\",\n-        \"suggested_replacement\": null,\n-        \"suggestion_applicability\": null,\n-        \"expansion\": null\n-    },\n-    {\n-        \"file_name\": \"compiler/ty/select.rs\",\n-        \"byte_start\": 4045,\n-        \"byte_end\": 4057,\n-        \"line_start\": 104,\n-        \"line_end\": 104,\n-        \"column_start\": 18,\n-        \"column_end\": 30,\n-        \"is_primary\": true,\n-        \"text\": [\n-            {\n-                \"text\": \"            self.add_evidence(target_fixed, evidence_fixed, false);\",\n-                \"highlight_start\": 18,\n-                \"highlight_end\": 30\n-            }\n-        ],\n-        \"label\": \"expected 2 parameters\",\n-        \"suggested_replacement\": null,\n-        \"suggestion_applicability\": null,\n-        \"expansion\": null\n-    }\n-],\n-\"children\": [],\n-\"rendered\": \"error[E0061]: this function takes 2 parameters but 3 parameters were supplied\\n   --> compiler/ty/select.rs:104:18\\n    |\\n104 |               self.add_evidence(target_fixed, evidence_fixed, false);\\n    |                    ^^^^^^^^^^^^ expected 2 parameters\\n...\\n219 | /     pub fn add_evidence(\\n220 | |         &mut self,\\n221 | |         target_poly: &ty::Ref<ty::Poly>,\\n222 | |         evidence_poly: &ty::Ref<ty::Poly>,\\n...   |\\n230 | |         }\\n231 | |     }\\n    | |_____- defined here\\n\\n\"\n-}\"##,\n-    );\n-\n-    let workspace_root = PathBuf::from(\"/test/\");\n-    let diag = map_rust_diagnostic_to_lsp(&diag, &workspace_root);\n-    insta::assert_debug_snapshot!(diag);\n-}\n-\n-#[test]\n-#[cfg(not(windows))]\n-fn snap_clippy_pass_by_ref() {\n-    let diag = parse_diagnostic(\n-        r##\"{\n-\"message\": \"this argument is passed by reference, but would be more efficient if passed by value\",\n-\"code\": {\n-    \"code\": \"clippy::trivially_copy_pass_by_ref\",\n-    \"explanation\": null\n-},\n-\"level\": \"warning\",\n-\"spans\": [\n-    {\n-        \"file_name\": \"compiler/mir/tagset.rs\",\n-        \"byte_start\": 941,\n-        \"byte_end\": 946,\n-        \"line_start\": 42,\n-        \"line_end\": 42,\n-        \"column_start\": 24,\n-        \"column_end\": 29,\n-        \"is_primary\": true,\n-        \"text\": [\n-            {\n-                \"text\": \"    pub fn is_disjoint(&self, other: Self) -> bool {\",\n-                \"highlight_start\": 24,\n-                \"highlight_end\": 29\n-            }\n-        ],\n-        \"label\": null,\n-        \"suggested_replacement\": null,\n-        \"suggestion_applicability\": null,\n-        \"expansion\": null\n-    }\n-],\n-\"children\": [\n-    {\n-        \"message\": \"lint level defined here\",\n-        \"code\": null,\n-        \"level\": \"note\",\n-        \"spans\": [\n-            {\n-                \"file_name\": \"compiler/lib.rs\",\n-                \"byte_start\": 8,\n-                \"byte_end\": 19,\n-                \"line_start\": 1,\n-                \"line_end\": 1,\n-                \"column_start\": 9,\n-                \"column_end\": 20,\n-                \"is_primary\": true,\n-                \"text\": [\n-                    {\n-                        \"text\": \"#![warn(clippy::all)]\",\n-                        \"highlight_start\": 9,\n-                        \"highlight_end\": 20\n-                    }\n-                ],\n-                \"label\": null,\n-                \"suggested_replacement\": null,\n-                \"suggestion_applicability\": null,\n-                \"expansion\": null\n-            }\n-        ],\n-        \"children\": [],\n-        \"rendered\": null\n-    },\n-    {\n-        \"message\": \"#[warn(clippy::trivially_copy_pass_by_ref)] implied by #[warn(clippy::all)]\",\n-        \"code\": null,\n-        \"level\": \"note\",\n-        \"spans\": [],\n-        \"children\": [],\n-        \"rendered\": null\n-    },\n-    {\n-        \"message\": \"for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#trivially_copy_pass_by_ref\",\n-        \"code\": null,\n-        \"level\": \"help\",\n-        \"spans\": [],\n-        \"children\": [],\n-        \"rendered\": null\n-    },\n-    {\n-        \"message\": \"consider passing by value instead\",\n-        \"code\": null,\n-        \"level\": \"help\",\n-        \"spans\": [\n-            {\n-                \"file_name\": \"compiler/mir/tagset.rs\",\n-                \"byte_start\": 941,\n-                \"byte_end\": 946,\n-                \"line_start\": 42,\n-                \"line_end\": 42,\n-                \"column_start\": 24,\n-                \"column_end\": 29,\n-                \"is_primary\": true,\n-                \"text\": [\n-                    {\n-                        \"text\": \"    pub fn is_disjoint(&self, other: Self) -> bool {\",\n-                        \"highlight_start\": 24,\n-                        \"highlight_end\": 29\n-                    }\n-                ],\n-                \"label\": null,\n-                \"suggested_replacement\": \"self\",\n-                \"suggestion_applicability\": \"Unspecified\",\n-                \"expansion\": null\n-            }\n-        ],\n-        \"children\": [],\n-        \"rendered\": null\n-    }\n-],\n-\"rendered\": \"warning: this argument is passed by reference, but would be more efficient if passed by value\\n  --> compiler/mir/tagset.rs:42:24\\n   |\\n42 |     pub fn is_disjoint(&self, other: Self) -> bool {\\n   |                        ^^^^^ help: consider passing by value instead: `self`\\n   |\\nnote: lint level defined here\\n  --> compiler/lib.rs:1:9\\n   |\\n1  | #![warn(clippy::all)]\\n   |         ^^^^^^^^^^^\\n   = note: #[warn(clippy::trivially_copy_pass_by_ref)] implied by #[warn(clippy::all)]\\n   = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#trivially_copy_pass_by_ref\\n\\n\"\n-}\"##,\n-    );\n-\n-    let workspace_root = PathBuf::from(\"/test/\");\n-    let diag = map_rust_diagnostic_to_lsp(&diag, &workspace_root);\n-    insta::assert_debug_snapshot!(diag);\n-}\n-\n-#[test]\n-#[cfg(not(windows))]\n-fn snap_rustc_mismatched_type() {\n-    let diag = parse_diagnostic(\n-        r##\"{\n-\"message\": \"mismatched types\",\n-\"code\": {\n-    \"code\": \"E0308\",\n-    \"explanation\": \"\\nThis error occurs when the compiler was unable to infer the concrete type of a\\nvariable. It can occur for several cases, the most common of which is a\\nmismatch in the expected type that the compiler inferred for a variable's\\ninitializing expression, and the actual type explicitly assigned to the\\nvariable.\\n\\nFor example:\\n\\n```compile_fail,E0308\\nlet x: i32 = \\\"I am not a number!\\\";\\n//     ~~~   ~~~~~~~~~~~~~~~~~~~~\\n//      |             |\\n//      |    initializing expression;\\n//      |    compiler infers type `&str`\\n//      |\\n//    type `i32` assigned to variable `x`\\n```\\n\"\n-},\n-\"level\": \"error\",\n-\"spans\": [\n-    {\n-        \"file_name\": \"runtime/compiler_support.rs\",\n-        \"byte_start\": 1589,\n-        \"byte_end\": 1594,\n-        \"line_start\": 48,\n-        \"line_end\": 48,\n-        \"column_start\": 65,\n-        \"column_end\": 70,\n-        \"is_primary\": true,\n-        \"text\": [\n-            {\n-                \"text\": \"    let layout = alloc::Layout::from_size_align_unchecked(size, align);\",\n-                \"highlight_start\": 65,\n-                \"highlight_end\": 70\n-            }\n-        ],\n-        \"label\": \"expected usize, found u32\",\n-        \"suggested_replacement\": null,\n-        \"suggestion_applicability\": null,\n-        \"expansion\": null\n-    }\n-],\n-\"children\": [],\n-\"rendered\": \"error[E0308]: mismatched types\\n  --> runtime/compiler_support.rs:48:65\\n   |\\n48 |     let layout = alloc::Layout::from_size_align_unchecked(size, align);\\n   |                                                                 ^^^^^ expected usize, found u32\\n\\n\"\n-}\"##,\n-    );\n-\n-    let workspace_root = PathBuf::from(\"/test/\");\n-    let diag = map_rust_diagnostic_to_lsp(&diag, &workspace_root);\n-    insta::assert_debug_snapshot!(diag);\n-}\n-\n-#[test]\n-#[cfg(not(windows))]\n-fn snap_handles_macro_location() {\n-    let diag = parse_diagnostic(\n-        r##\"{\n-\"rendered\": \"error[E0277]: can't compare `{integer}` with `&str`\\n --> src/main.rs:2:5\\n  |\\n2 |     assert_eq!(1, \\\"love\\\");\\n  |     ^^^^^^^^^^^^^^^^^^^^^^ no implementation for `{integer} == &str`\\n  |\\n  = help: the trait `std::cmp::PartialEq<&str>` is not implemented for `{integer}`\\n  = note: this error originates in a macro outside of the current crate (in Nightly builds, run with -Z external-macro-backtrace for more info)\\n\\n\",\n-\"children\": [\n-    {\n-        \"children\": [],\n-        \"code\": null,\n-        \"level\": \"help\",\n-        \"message\": \"the trait `std::cmp::PartialEq<&str>` is not implemented for `{integer}`\",\n-        \"rendered\": null,\n-        \"spans\": []\n-    }\n-],\n-\"code\": {\n-    \"code\": \"E0277\",\n-    \"explanation\": \"\\nYou tried to use a type which doesn't implement some trait in a place which\\nexpected that trait. Erroneous code example:\\n\\n```compile_fail,E0277\\n// here we declare the Foo trait with a bar method\\ntrait Foo {\\n    fn bar(&self);\\n}\\n\\n// we now declare a function which takes an object implementing the Foo trait\\nfn some_func<T: Foo>(foo: T) {\\n    foo.bar();\\n}\\n\\nfn main() {\\n    // we now call the method with the i32 type, which doesn't implement\\n    // the Foo trait\\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\\n}\\n```\\n\\nIn order to fix this error, verify that the type you're using does implement\\nthe trait. Example:\\n\\n```\\ntrait Foo {\\n    fn bar(&self);\\n}\\n\\nfn some_func<T: Foo>(foo: T) {\\n    foo.bar(); // we can now use this method since i32 implements the\\n               // Foo trait\\n}\\n\\n// we implement the trait on the i32 type\\nimpl Foo for i32 {\\n    fn bar(&self) {}\\n}\\n\\nfn main() {\\n    some_func(5i32); // ok!\\n}\\n```\\n\\nOr in a generic context, an erroneous code example would look like:\\n\\n```compile_fail,E0277\\nfn some_func<T>(foo: T) {\\n    println!(\\\"{:?}\\\", foo); // error: the trait `core::fmt::Debug` is not\\n                           //        implemented for the type `T`\\n}\\n\\nfn main() {\\n    // We now call the method with the i32 type,\\n    // which *does* implement the Debug trait.\\n    some_func(5i32);\\n}\\n```\\n\\nNote that the error here is in the definition of the generic function: Although\\nwe only call it with a parameter that does implement `Debug`, the compiler\\nstill rejects the function: It must work with all possible input types. In\\norder to make this example compile, we need to restrict the generic type we're\\naccepting:\\n\\n```\\nuse std::fmt;\\n\\n// Restrict the input type to types that implement Debug.\\nfn some_func<T: fmt::Debug>(foo: T) {\\n    println!(\\\"{:?}\\\", foo);\\n}\\n\\nfn main() {\\n    // Calling the method is still fine, as i32 implements Debug.\\n    some_func(5i32);\\n\\n    // This would fail to compile now:\\n    // struct WithoutDebug;\\n    // some_func(WithoutDebug);\\n}\\n```\\n\\nRust only looks at the signature of the called function, as such it must\\nalready specify all requirements that will be used for every type parameter.\\n\"\n-},\n-\"level\": \"error\",\n-\"message\": \"can't compare `{integer}` with `&str`\",\n-\"spans\": [\n-    {\n-        \"byte_end\": 155,\n-        \"byte_start\": 153,\n-        \"column_end\": 33,\n-        \"column_start\": 31,\n-        \"expansion\": {\n-            \"def_site_span\": {\n-                \"byte_end\": 940,\n-                \"byte_start\": 0,\n-                \"column_end\": 6,\n-                \"column_start\": 1,\n-                \"expansion\": null,\n-                \"file_name\": \"<::core::macros::assert_eq macros>\",\n-                \"is_primary\": false,\n-                \"label\": null,\n-                \"line_end\": 36,\n-                \"line_start\": 1,\n-                \"suggested_replacement\": null,\n-                \"suggestion_applicability\": null,\n-                \"text\": [\n-                    {\n-                        \"highlight_end\": 35,\n-                        \"highlight_start\": 1,\n-                        \"text\": \"($ left : expr, $ right : expr) =>\"\n-                    },\n-                    {\n-                        \"highlight_end\": 3,\n-                        \"highlight_start\": 1,\n-                        \"text\": \"({\"\n-                    },\n-                    {\n-                        \"highlight_end\": 33,\n-                        \"highlight_start\": 1,\n-                        \"text\": \"     match (& $ left, & $ right)\"\n-                    },\n-                    {\n-                        \"highlight_end\": 7,\n-                        \"highlight_start\": 1,\n-                        \"text\": \"     {\"\n-                    },\n-                    {\n-                        \"highlight_end\": 34,\n-                        \"highlight_start\": 1,\n-                        \"text\": \"         (left_val, right_val) =>\"\n-                    },\n-                    {\n-                        \"highlight_end\": 11,\n-                        \"highlight_start\": 1,\n-                        \"text\": \"         {\"\n-                    },\n-                    {\n-                        \"highlight_end\": 46,\n-                        \"highlight_start\": 1,\n-                        \"text\": \"             if ! (* left_val == * right_val)\"\n-                    },\n-                    {\n-                        \"highlight_end\": 15,\n-                        \"highlight_start\": 1,\n-                        \"text\": \"             {\"\n-                    },\n-                    {\n-                        \"highlight_end\": 25,\n-                        \"highlight_start\": 1,\n-                        \"text\": \"                 panic !\"\n-                    },\n-                    {\n-                        \"highlight_end\": 57,\n-                        \"highlight_start\": 1,\n-                        \"text\": \"                 (r#\\\"assertion failed: `(left == right)`\"\n-                    },\n-                    {\n-                        \"highlight_end\": 16,\n-                        \"highlight_start\": 1,\n-                        \"text\": \"  left: `{:?}`,\"\n-                    },\n-                    {\n-                        \"highlight_end\": 18,\n-                        \"highlight_start\": 1,\n-                        \"text\": \" right: `{:?}`\\\"#,\"\n-                    },\n-                    {\n-                        \"highlight_end\": 47,\n-                        \"highlight_start\": 1,\n-                        \"text\": \"                  & * left_val, & * right_val)\"\n-                    },\n-                    {\n-                        \"highlight_end\": 15,\n-                        \"highlight_start\": 1,\n-                        \"text\": \"             }\"\n-                    },\n-                    {\n-                        \"highlight_end\": 11,\n-                        \"highlight_start\": 1,\n-                        \"text\": \"         }\"\n-                    },\n-                    {\n-                        \"highlight_end\": 7,\n-                        \"highlight_start\": 1,\n-                        \"text\": \"     }\"\n-                    },\n-                    {\n-                        \"highlight_end\": 42,\n-                        \"highlight_start\": 1,\n-                        \"text\": \" }) ; ($ left : expr, $ right : expr,) =>\"\n-                    },\n-                    {\n-                        \"highlight_end\": 49,\n-                        \"highlight_start\": 1,\n-                        \"text\": \"({ $ crate :: assert_eq ! ($ left, $ right) }) ;\"\n-                    },\n-                    {\n-                        \"highlight_end\": 53,\n-                        \"highlight_start\": 1,\n-                        \"text\": \"($ left : expr, $ right : expr, $ ($ arg : tt) +) =>\"\n-                    },\n-                    {\n-                        \"highlight_end\": 3,\n-                        \"highlight_start\": 1,\n-                        \"text\": \"({\"\n-                    },\n-                    {\n-                        \"highlight_end\": 37,\n-                        \"highlight_start\": 1,\n-                        \"text\": \"     match (& ($ left), & ($ right))\"\n-                    },\n-                    {\n-                        \"highlight_end\": 7,\n-                        \"highlight_start\": 1,\n-                        \"text\": \"     {\"\n-                    },\n-                    {\n-                        \"highlight_end\": 34,\n-                        \"highlight_start\": 1,\n-                        \"text\": \"         (left_val, right_val) =>\"\n-                    },\n-                    {\n-                        \"highlight_end\": 11,\n-                        \"highlight_start\": 1,\n-                        \"text\": \"         {\"\n-                    },\n-                    {\n-                        \"highlight_end\": 46,\n-                        \"highlight_start\": 1,\n-                        \"text\": \"             if ! (* left_val == * right_val)\"\n-                    },\n-                    {\n-                        \"highlight_end\": 15,\n-                        \"highlight_start\": 1,\n-                        \"text\": \"             {\"\n-                    },\n-                    {\n-                        \"highlight_end\": 25,\n-                        \"highlight_start\": 1,\n-                        \"text\": \"                 panic !\"\n-                    },\n-                    {\n-                        \"highlight_end\": 57,\n-                        \"highlight_start\": 1,\n-                        \"text\": \"                 (r#\\\"assertion failed: `(left == right)`\"\n-                    },\n-                    {\n-                        \"highlight_end\": 16,\n-                        \"highlight_start\": 1,\n-                        \"text\": \"  left: `{:?}`,\"\n-                    },\n-                    {\n-                        \"highlight_end\": 22,\n-                        \"highlight_start\": 1,\n-                        \"text\": \" right: `{:?}`: {}\\\"#,\"\n-                    },\n-                    {\n-                        \"highlight_end\": 72,\n-                        \"highlight_start\": 1,\n-                        \"text\": \"                  & * left_val, & * right_val, $ crate :: format_args !\"\n-                    },\n-                    {\n-                        \"highlight_end\": 33,\n-                        \"highlight_start\": 1,\n-                        \"text\": \"                  ($ ($ arg) +))\"\n-                    },\n-                    {\n-                        \"highlight_end\": 15,\n-                        \"highlight_start\": 1,\n-                        \"text\": \"             }\"\n-                    },\n-                    {\n-                        \"highlight_end\": 11,\n-                        \"highlight_start\": 1,\n-                        \"text\": \"         }\"\n-                    },\n-                    {\n-                        \"highlight_end\": 7,\n-                        \"highlight_start\": 1,\n-                        \"text\": \"     }\"\n-                    },\n-                    {\n-                        \"highlight_end\": 6,\n-                        \"highlight_start\": 1,\n-                        \"text\": \" }) ;\"\n-                    }\n-                ]\n-            },\n-            \"macro_decl_name\": \"assert_eq!\",\n-            \"span\": {\n-                \"byte_end\": 38,\n-                \"byte_start\": 16,\n-                \"column_end\": 27,\n-                \"column_start\": 5,\n-                \"expansion\": null,\n-                \"file_name\": \"src/main.rs\",\n-                \"is_primary\": false,\n-                \"label\": null,\n-                \"line_end\": 2,\n-                \"line_start\": 2,\n-                \"suggested_replacement\": null,\n-                \"suggestion_applicability\": null,\n-                \"text\": [\n-                    {\n-                        \"highlight_end\": 27,\n-                        \"highlight_start\": 5,\n-                        \"text\": \"    assert_eq!(1, \\\"love\\\");\"\n-                    }\n-                ]\n-            }\n-        },\n-        \"file_name\": \"<::core::macros::assert_eq macros>\",\n-        \"is_primary\": true,\n-        \"label\": \"no implementation for `{integer} == &str`\",\n-        \"line_end\": 7,\n-        \"line_start\": 7,\n-        \"suggested_replacement\": null,\n-        \"suggestion_applicability\": null,\n-        \"text\": [\n-            {\n-                \"highlight_end\": 33,\n-                \"highlight_start\": 31,\n-                \"text\": \"             if ! (* left_val == * right_val)\"\n-            }\n-        ]\n-    }\n-]\n-}\"##,\n-    );\n-\n-    let workspace_root = PathBuf::from(\"/test/\");\n-    let diag = map_rust_diagnostic_to_lsp(&diag, &workspace_root);\n-    insta::assert_debug_snapshot!(diag);\n-}\n-\n-#[test]\n-#[cfg(not(windows))]\n-fn snap_macro_compiler_error() {\n-    let diag = parse_diagnostic(\n-        r##\"{\n-    \"rendered\": \"error: Please register your known path in the path module\\n   --> crates/ra_hir_def/src/path.rs:265:9\\n    |\\n265 |         compile_error!(\\\"Please register your known path in the path module\\\")\\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\\n    | \\n   ::: crates/ra_hir_def/src/data.rs:80:16\\n    |\\n80  |     let path = path![std::future::Future];\\n    |                -------------------------- in this macro invocation\\n\\n\",\n-    \"children\": [],\n-    \"code\": null,\n-    \"level\": \"error\",\n-    \"message\": \"Please register your known path in the path module\",\n-    \"spans\": [\n-        {\n-            \"byte_end\": 8285,\n-            \"byte_start\": 8217,\n-            \"column_end\": 77,\n-            \"column_start\": 9,\n-            \"expansion\": {\n-                \"def_site_span\": {\n-                    \"byte_end\": 8294,\n-                    \"byte_start\": 7858,\n-                    \"column_end\": 2,\n-                    \"column_start\": 1,\n-                    \"expansion\": null,\n-                    \"file_name\": \"crates/ra_hir_def/src/path.rs\",\n-                    \"is_primary\": false,\n-                    \"label\": null,\n-                    \"line_end\": 267,\n-                    \"line_start\": 254,\n-                    \"suggested_replacement\": null,\n-                    \"suggestion_applicability\": null,\n-                    \"text\": [\n-                        {\n-                            \"highlight_end\": 28,\n-                            \"highlight_start\": 1,\n-                            \"text\": \"macro_rules! __known_path {\"\n-                        },\n-                        {\n-                            \"highlight_end\": 37,\n-                            \"highlight_start\": 1,\n-                            \"text\": \"    (std::iter::IntoIterator) => {};\"\n-                        },\n-                        {\n-                            \"highlight_end\": 33,\n-                            \"highlight_start\": 1,\n-                            \"text\": \"    (std::result::Result) => {};\"\n-                        },\n-                        {\n-                            \"highlight_end\": 29,\n-                            \"highlight_start\": 1,\n-                            \"text\": \"    (std::ops::Range) => {};\"\n-                        },\n-                        {\n-                            \"highlight_end\": 33,\n-                            \"highlight_start\": 1,\n-                            \"text\": \"    (std::ops::RangeFrom) => {};\"\n-                        },\n-                        {\n-                            \"highlight_end\": 33,\n-                            \"highlight_start\": 1,\n-                            \"text\": \"    (std::ops::RangeFull) => {};\"\n-                        },\n-                        {\n-                            \"highlight_end\": 31,\n-                            \"highlight_start\": 1,\n-                            \"text\": \"    (std::ops::RangeTo) => {};\"\n-                        },\n-                        {\n-                            \"highlight_end\": 40,\n-                            \"highlight_start\": 1,\n-                            \"text\": \"    (std::ops::RangeToInclusive) => {};\"\n-                        },\n-                        {\n-                            \"highlight_end\": 38,\n-                            \"highlight_start\": 1,\n-                            \"text\": \"    (std::ops::RangeInclusive) => {};\"\n-                        },\n-                        {\n-                            \"highlight_end\": 27,\n-                            \"highlight_start\": 1,\n-                            \"text\": \"    (std::ops::Try) => {};\"\n-                        },\n-                        {\n-                            \"highlight_end\": 22,\n-                            \"highlight_start\": 1,\n-                            \"text\": \"    ($path:path) => {\"\n-                        },\n-                        {\n-                            \"highlight_end\": 77,\n-                            \"highlight_start\": 1,\n-                            \"text\": \"        compile_error!(\\\"Please register your known path in the path module\\\")\"\n-                        },\n-                        {\n-                            \"highlight_end\": 7,\n-                            \"highlight_start\": 1,\n-                            \"text\": \"    };\"\n-                        },\n-                        {\n-                            \"highlight_end\": 2,\n-                            \"highlight_start\": 1,\n-                            \"text\": \"}\"\n-                        }\n-                    ]\n-                },\n-                \"macro_decl_name\": \"$crate::__known_path!\",\n-                \"span\": {\n-                    \"byte_end\": 8427,\n-                    \"byte_start\": 8385,\n-                    \"column_end\": 51,\n-                    \"column_start\": 9,\n-                    \"expansion\": {\n-                        \"def_site_span\": {\n-                            \"byte_end\": 8611,\n-                            \"byte_start\": 8312,\n-                            \"column_end\": 2,\n-                            \"column_start\": 1,\n-                            \"expansion\": null,\n-                            \"file_name\": \"crates/ra_hir_def/src/path.rs\",\n-                            \"is_primary\": false,\n-                            \"label\": null,\n-                            \"line_end\": 277,\n-                            \"line_start\": 270,\n-                            \"suggested_replacement\": null,\n-                            \"suggestion_applicability\": null,\n-                            \"text\": [\n-                                {\n-                                    \"highlight_end\": 22,\n-                                    \"highlight_start\": 1,\n-                                    \"text\": \"macro_rules! __path {\"\n-                                },\n-                                {\n-                                    \"highlight_end\": 43,\n-                                    \"highlight_start\": 1,\n-                                    \"text\": \"    ($start:ident $(:: $seg:ident)*) => ({\"\n-                                },\n-                                {\n-                                    \"highlight_end\": 51,\n-                                    \"highlight_start\": 1,\n-                                    \"text\": \"        $crate::__known_path!($start $(:: $seg)*);\"\n-                                },\n-                                {\n-                                    \"highlight_end\": 87,\n-                                    \"highlight_start\": 1,\n-                                    \"text\": \"        $crate::path::ModPath::from_simple_segments($crate::path::PathKind::Abs, vec![\"\n-                                },\n-                                {\n-                                    \"highlight_end\": 76,\n-                                    \"highlight_start\": 1,\n-                                    \"text\": \"            $crate::path::__name![$start], $($crate::path::__name![$seg],)*\"\n-                                },\n-                                {\n-                                    \"highlight_end\": 11,\n-                                    \"highlight_start\": 1,\n-                                    \"text\": \"        ])\"\n-                                },\n-                                {\n-                                    \"highlight_end\": 8,\n-                                    \"highlight_start\": 1,\n-                                    \"text\": \"    });\"\n-                                },\n-                                {\n-                                    \"highlight_end\": 2,\n-                                    \"highlight_start\": 1,\n-                                    \"text\": \"}\"\n-                                }\n-                            ]\n-                        },\n-                        \"macro_decl_name\": \"path!\",\n-                        \"span\": {\n-                            \"byte_end\": 2966,\n-                            \"byte_start\": 2940,\n-                            \"column_end\": 42,\n-                            \"column_start\": 16,\n-                            \"expansion\": null,\n-                            \"file_name\": \"crates/ra_hir_def/src/data.rs\",\n-                            \"is_primary\": false,\n-                            \"label\": null,\n-                            \"line_end\": 80,\n-                            \"line_start\": 80,\n-                            \"suggested_replacement\": null,\n-                            \"suggestion_applicability\": null,\n-                            \"text\": [\n-                                {\n-                                    \"highlight_end\": 42,\n-                                    \"highlight_start\": 16,\n-                                    \"text\": \"    let path = path![std::future::Future];\"\n-                                }\n-                            ]\n-                        }\n-                    },\n-                    \"file_name\": \"crates/ra_hir_def/src/path.rs\",\n-                    \"is_primary\": false,\n-                    \"label\": null,\n-                    \"line_end\": 272,\n-                    \"line_start\": 272,\n-                    \"suggested_replacement\": null,\n-                    \"suggestion_applicability\": null,\n-                    \"text\": [\n-                        {\n-                            \"highlight_end\": 51,\n-                            \"highlight_start\": 9,\n-                            \"text\": \"        $crate::__known_path!($start $(:: $seg)*);\"\n-                        }\n-                    ]\n-                }\n-            },\n-            \"file_name\": \"crates/ra_hir_def/src/path.rs\",\n-            \"is_primary\": true,\n-            \"label\": null,\n-            \"line_end\": 265,\n-            \"line_start\": 265,\n-            \"suggested_replacement\": null,\n-            \"suggestion_applicability\": null,\n-            \"text\": [\n-                {\n-                    \"highlight_end\": 77,\n-                    \"highlight_start\": 9,\n-                    \"text\": \"        compile_error!(\\\"Please register your known path in the path module\\\")\"\n-                }\n-            ]\n-        }\n-    ]\n-}\n-        \"##,\n-    );\n-\n-    let workspace_root = PathBuf::from(\"/test/\");\n-    let diag = map_rust_diagnostic_to_lsp(&diag, &workspace_root);\n-    insta::assert_debug_snapshot!(diag);\n-}\n-\n-#[test]\n-#[cfg(not(windows))]\n-fn snap_multi_line_fix() {\n-    let diag = parse_diagnostic(\n-        r##\"{\n-            \"rendered\": \"warning: returning the result of a let binding from a block\\n --> src/main.rs:4:5\\n  |\\n3 |     let a = (0..10).collect();\\n  |     -------------------------- unnecessary let binding\\n4 |     a\\n  |     ^\\n  |\\n  = note: `#[warn(clippy::let_and_return)]` on by default\\n  = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#let_and_return\\nhelp: return the expression directly\\n  |\\n3 |     \\n4 |     (0..10).collect()\\n  |\\n\\n\",\n-            \"children\": [\n-                {\n-                \"children\": [],\n-                \"code\": null,\n-                \"level\": \"note\",\n-                \"message\": \"`#[warn(clippy::let_and_return)]` on by default\",\n-                \"rendered\": null,\n-                \"spans\": []\n-                },\n-                {\n-                \"children\": [],\n-                \"code\": null,\n-                \"level\": \"help\",\n-                \"message\": \"for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#let_and_return\",\n-                \"rendered\": null,\n-                \"spans\": []\n-                },\n-                {\n-                \"children\": [],\n-                \"code\": null,\n-                \"level\": \"help\",\n-                \"message\": \"return the expression directly\",\n-                \"rendered\": null,\n-                \"spans\": [\n-                    {\n-                    \"byte_end\": 55,\n-                    \"byte_start\": 29,\n-                    \"column_end\": 31,\n-                    \"column_start\": 5,\n-                    \"expansion\": null,\n-                    \"file_name\": \"src/main.rs\",\n-                    \"is_primary\": true,\n-                    \"label\": null,\n-                    \"line_end\": 3,\n-                    \"line_start\": 3,\n-                    \"suggested_replacement\": \"\",\n-                    \"suggestion_applicability\": \"MachineApplicable\",\n-                    \"text\": [\n-                        {\n-                        \"highlight_end\": 31,\n-                        \"highlight_start\": 5,\n-                        \"text\": \"    let a = (0..10).collect();\"\n-                        }\n-                    ]\n-                    },\n-                    {\n-                    \"byte_end\": 61,\n-                    \"byte_start\": 60,\n-                    \"column_end\": 6,\n-                    \"column_start\": 5,\n-                    \"expansion\": null,\n-                    \"file_name\": \"src/main.rs\",\n-                    \"is_primary\": true,\n-                    \"label\": null,\n-                    \"line_end\": 4,\n-                    \"line_start\": 4,\n-                    \"suggested_replacement\": \"(0..10).collect()\",\n-                    \"suggestion_applicability\": \"MachineApplicable\",\n-                    \"text\": [\n-                        {\n-                        \"highlight_end\": 6,\n-                        \"highlight_start\": 5,\n-                        \"text\": \"    a\"\n-                        }\n-                    ]\n-                    }\n-                ]\n-                }\n-            ],\n-            \"code\": {\n-                \"code\": \"clippy::let_and_return\",\n-                \"explanation\": null\n-            },\n-            \"level\": \"warning\",\n-            \"message\": \"returning the result of a let binding from a block\",\n-            \"spans\": [\n-                {\n-                \"byte_end\": 55,\n-                \"byte_start\": 29,\n-                \"column_end\": 31,\n-                \"column_start\": 5,\n-                \"expansion\": null,\n-                \"file_name\": \"src/main.rs\",\n-                \"is_primary\": false,\n-                \"label\": \"unnecessary let binding\",\n-                \"line_end\": 3,\n-                \"line_start\": 3,\n-                \"suggested_replacement\": null,\n-                \"suggestion_applicability\": null,\n-                \"text\": [\n-                    {\n-                    \"highlight_end\": 31,\n-                    \"highlight_start\": 5,\n-                    \"text\": \"    let a = (0..10).collect();\"\n-                    }\n-                ]\n-                },\n-                {\n-                \"byte_end\": 61,\n-                \"byte_start\": 60,\n-                \"column_end\": 6,\n-                \"column_start\": 5,\n-                \"expansion\": null,\n-                \"file_name\": \"src/main.rs\",\n-                \"is_primary\": true,\n-                \"label\": null,\n-                \"line_end\": 4,\n-                \"line_start\": 4,\n-                \"suggested_replacement\": null,\n-                \"suggestion_applicability\": null,\n-                \"text\": [\n-                    {\n-                    \"highlight_end\": 6,\n-                    \"highlight_start\": 5,\n-                    \"text\": \"    a\"\n-                    }\n-                ]\n-                }\n-            ]\n-        }\n-        \"##,\n-    );\n-\n-    let workspace_root = PathBuf::from(\"/test/\");\n-    let diag = map_rust_diagnostic_to_lsp(&diag, &workspace_root);\n-    insta::assert_debug_snapshot!(diag);\n-}"}, {"sha": "041e38a9ff4ca4d40fc64972bf3e15fa1784d02d", "filename": "crates/ra_flycheck/src/lib.rs", "status": "modified", "additions": 25, "deletions": 63, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/05db35dafb47db355e202c9176bd8a752b7390d7/crates%2Fra_flycheck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05db35dafb47db355e202c9176bd8a752b7390d7/crates%2Fra_flycheck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_flycheck%2Fsrc%2Flib.rs?ref=05db35dafb47db355e202c9176bd8a752b7390d7", "patch": "@@ -1,25 +1,20 @@\n //! cargo_check provides the functionality needed to run `cargo check` or\n //! another compatible command (f.x. clippy) in a background thread and provide\n //! LSP diagnostics based on the output of the command.\n-mod conv;\n \n use std::{\n-    io::{self, BufRead, BufReader},\n+    io::{self, BufReader},\n     path::PathBuf,\n     process::{Command, Stdio},\n     time::Instant,\n };\n \n use cargo_metadata::Message;\n use crossbeam_channel::{never, select, unbounded, Receiver, RecvError, Sender};\n-use lsp_types::{\n-    CodeAction, CodeActionOrCommand, Diagnostic, Url, WorkDoneProgress, WorkDoneProgressBegin,\n-    WorkDoneProgressEnd, WorkDoneProgressReport,\n-};\n-\n-use crate::conv::{map_rust_diagnostic_to_lsp, MappedRustDiagnostic};\n \n-pub use crate::conv::url_from_path_with_drive_lowercasing;\n+pub use cargo_metadata::diagnostic::{\n+    Applicability, Diagnostic, DiagnosticLevel, DiagnosticSpan, DiagnosticSpanMacroExpansion,\n+};\n \n #[derive(Clone, Debug, PartialEq, Eq)]\n pub enum FlycheckConfig {\n@@ -61,10 +56,17 @@ pub enum CheckTask {\n     ClearDiagnostics,\n \n     /// Request adding a diagnostic with fixes included to a file\n-    AddDiagnostic { url: Url, diagnostic: Diagnostic, fixes: Vec<CodeActionOrCommand> },\n+    AddDiagnostic { workspace_root: PathBuf, diagnostic: Diagnostic },\n \n     /// Request check progress notification to client\n-    Status(WorkDoneProgress),\n+    Status(Status),\n+}\n+\n+#[derive(Debug)]\n+pub enum Status {\n+    Being,\n+    Progress(String),\n+    End,\n }\n \n pub enum CheckCommand {\n@@ -131,9 +133,7 @@ impl FlycheckThread {\n \n     fn clean_previous_results(&self, task_send: &Sender<CheckTask>) {\n         task_send.send(CheckTask::ClearDiagnostics).unwrap();\n-        task_send\n-            .send(CheckTask::Status(WorkDoneProgress::End(WorkDoneProgressEnd { message: None })))\n-            .unwrap();\n+        task_send.send(CheckTask::Status(Status::End)).unwrap();\n     }\n \n     fn should_recheck(&mut self) -> bool {\n@@ -155,52 +155,24 @@ impl FlycheckThread {\n     fn handle_message(&self, msg: CheckEvent, task_send: &Sender<CheckTask>) {\n         match msg {\n             CheckEvent::Begin => {\n-                task_send\n-                    .send(CheckTask::Status(WorkDoneProgress::Begin(WorkDoneProgressBegin {\n-                        title: \"Running `cargo check`\".to_string(),\n-                        cancellable: Some(false),\n-                        message: None,\n-                        percentage: None,\n-                    })))\n-                    .unwrap();\n+                task_send.send(CheckTask::Status(Status::Being)).unwrap();\n             }\n \n             CheckEvent::End => {\n-                task_send\n-                    .send(CheckTask::Status(WorkDoneProgress::End(WorkDoneProgressEnd {\n-                        message: None,\n-                    })))\n-                    .unwrap();\n+                task_send.send(CheckTask::Status(Status::End)).unwrap();\n             }\n \n             CheckEvent::Msg(Message::CompilerArtifact(msg)) => {\n-                task_send\n-                    .send(CheckTask::Status(WorkDoneProgress::Report(WorkDoneProgressReport {\n-                        cancellable: Some(false),\n-                        message: Some(msg.target.name),\n-                        percentage: None,\n-                    })))\n-                    .unwrap();\n+                task_send.send(CheckTask::Status(Status::Progress(msg.target.name))).unwrap();\n             }\n \n             CheckEvent::Msg(Message::CompilerMessage(msg)) => {\n-                let map_result = map_rust_diagnostic_to_lsp(&msg.message, &self.workspace_root);\n-                if map_result.is_empty() {\n-                    return;\n-                }\n-\n-                for MappedRustDiagnostic { location, diagnostic, fixes } in map_result {\n-                    let fixes = fixes\n-                        .into_iter()\n-                        .map(|fix| {\n-                            CodeAction { diagnostics: Some(vec![diagnostic.clone()]), ..fix }.into()\n-                        })\n-                        .collect();\n-\n-                    task_send\n-                        .send(CheckTask::AddDiagnostic { url: location.uri, diagnostic, fixes })\n-                        .unwrap();\n-                }\n+                task_send\n+                    .send(CheckTask::AddDiagnostic {\n+                        workspace_root: self.workspace_root.clone(),\n+                        diagnostic: msg.message,\n+                    })\n+                    .unwrap();\n             }\n \n             CheckEvent::Msg(Message::BuildScriptExecuted(_msg)) => {}\n@@ -271,12 +243,6 @@ impl FlycheckThread {\n     }\n }\n \n-#[derive(Debug)]\n-pub struct DiagnosticWithFixes {\n-    diagnostic: Diagnostic,\n-    fixes: Vec<CodeAction>,\n-}\n-\n enum CheckEvent {\n     Begin,\n     Msg(cargo_metadata::Message),\n@@ -300,15 +266,11 @@ fn run_cargo(\n     // erroneus output.\n     let stdout = BufReader::new(child.stdout.take().unwrap());\n     let mut read_at_least_one_message = false;\n-\n-    for line in stdout.lines() {\n-        let line = line?;\n-\n-        let message = serde_json::from_str::<cargo_metadata::Message>(&line);\n+    for message in cargo_metadata::Message::parse_stream(stdout) {\n         let message = match message {\n             Ok(message) => message,\n             Err(err) => {\n-                log::error!(\"Invalid json from cargo check, ignoring ({}): {:?} \", err, line);\n+                log::error!(\"Invalid json from cargo check, ignoring ({})\", err);\n                 continue;\n             }\n         };"}, {"sha": "9b2d29b1d57c553844569f5d4d2d8a5d6107c716", "filename": "crates/rust-analyzer/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/05db35dafb47db355e202c9176bd8a752b7390d7/crates%2Frust-analyzer%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/05db35dafb47db355e202c9176bd8a752b7390d7/crates%2Frust-analyzer%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2FCargo.toml?ref=05db35dafb47db355e202c9176bd8a752b7390d7", "patch": "@@ -53,6 +53,7 @@ winapi = \"0.3.8\"\n \n [dev-dependencies]\n tempfile = \"3.1.0\"\n+insta = \"0.16.0\"\n test_utils = { path = \"../test_utils\" }\n \n [features]"}, {"sha": "4bdd45a7deb1801745704c213e8f76cda7265e8c", "filename": "crates/rust-analyzer/src/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/05db35dafb47db355e202c9176bd8a752b7390d7/crates%2Frust-analyzer%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05db35dafb47db355e202c9176bd8a752b7390d7/crates%2Frust-analyzer%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fdiagnostics.rs?ref=05db35dafb47db355e202c9176bd8a752b7390d7", "patch": "@@ -1,4 +1,5 @@\n //! Book keeping for keeping diagnostics easily in sync with the client.\n+pub(crate) mod to_proto;\n \n use std::{collections::HashMap, sync::Arc};\n "}, {"sha": "d7f9ec0494ae85d663060fcafe3bb5cec3c07d96", "filename": "crates/rust-analyzer/src/diagnostics/snapshots/rust_analyzer__diagnostics__to_proto__tests__snap_clippy_pass_by_ref.snap", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/05db35dafb47db355e202c9176bd8a752b7390d7/crates%2Frust-analyzer%2Fsrc%2Fdiagnostics%2Fsnapshots%2Frust_analyzer__diagnostics__to_proto__tests__snap_clippy_pass_by_ref.snap", "raw_url": "https://github.com/rust-lang/rust/raw/05db35dafb47db355e202c9176bd8a752b7390d7/crates%2Frust-analyzer%2Fsrc%2Fdiagnostics%2Fsnapshots%2Frust_analyzer__diagnostics__to_proto__tests__snap_clippy_pass_by_ref.snap", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fdiagnostics%2Fsnapshots%2Frust_analyzer__diagnostics__to_proto__tests__snap_clippy_pass_by_ref.snap?ref=05db35dafb47db355e202c9176bd8a752b7390d7", "patch": "@@ -1,5 +1,5 @@\n ---\n-source: crates/ra_flycheck/src/conv/test.rs\n+source: crates/rust-analyzer/src/diagnostics/to_proto.rs\n expression: diag\n ---\n [", "previous_filename": "crates/ra_flycheck/src/conv/snapshots/ra_flycheck__conv__test__snap_clippy_pass_by_ref.snap"}, {"sha": "a59faf254c7e97bf21c82090b25dcb378c0706c9", "filename": "crates/rust-analyzer/src/diagnostics/snapshots/rust_analyzer__diagnostics__to_proto__tests__snap_handles_macro_location.snap", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/05db35dafb47db355e202c9176bd8a752b7390d7/crates%2Frust-analyzer%2Fsrc%2Fdiagnostics%2Fsnapshots%2Frust_analyzer__diagnostics__to_proto__tests__snap_handles_macro_location.snap", "raw_url": "https://github.com/rust-lang/rust/raw/05db35dafb47db355e202c9176bd8a752b7390d7/crates%2Frust-analyzer%2Fsrc%2Fdiagnostics%2Fsnapshots%2Frust_analyzer__diagnostics__to_proto__tests__snap_handles_macro_location.snap", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fdiagnostics%2Fsnapshots%2Frust_analyzer__diagnostics__to_proto__tests__snap_handles_macro_location.snap?ref=05db35dafb47db355e202c9176bd8a752b7390d7", "patch": "@@ -1,5 +1,5 @@\n ---\n-source: crates/ra_flycheck/src/conv/test.rs\n+source: crates/rust-analyzer/src/diagnostics/to_proto.rs\n expression: diag\n ---\n [", "previous_filename": "crates/ra_flycheck/src/conv/snapshots/ra_flycheck__conv__test__snap_handles_macro_location.snap"}, {"sha": "3c78e7f36c9e1df12092e7b53d967c6c1d315ffc", "filename": "crates/rust-analyzer/src/diagnostics/snapshots/rust_analyzer__diagnostics__to_proto__tests__snap_macro_compiler_error.snap", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/05db35dafb47db355e202c9176bd8a752b7390d7/crates%2Frust-analyzer%2Fsrc%2Fdiagnostics%2Fsnapshots%2Frust_analyzer__diagnostics__to_proto__tests__snap_macro_compiler_error.snap", "raw_url": "https://github.com/rust-lang/rust/raw/05db35dafb47db355e202c9176bd8a752b7390d7/crates%2Frust-analyzer%2Fsrc%2Fdiagnostics%2Fsnapshots%2Frust_analyzer__diagnostics__to_proto__tests__snap_macro_compiler_error.snap", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fdiagnostics%2Fsnapshots%2Frust_analyzer__diagnostics__to_proto__tests__snap_macro_compiler_error.snap?ref=05db35dafb47db355e202c9176bd8a752b7390d7", "patch": "@@ -1,5 +1,5 @@\n ---\n-source: crates/ra_flycheck/src/conv/test.rs\n+source: crates/rust-analyzer/src/diagnostics/to_proto.rs\n expression: diag\n ---\n [", "previous_filename": "crates/ra_flycheck/src/conv/snapshots/ra_flycheck__conv__test__snap_macro_compiler_error.snap"}, {"sha": "076b3cf2730acc565695df5ce436b0064278ec3b", "filename": "crates/rust-analyzer/src/diagnostics/snapshots/rust_analyzer__diagnostics__to_proto__tests__snap_multi_line_fix.snap", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/05db35dafb47db355e202c9176bd8a752b7390d7/crates%2Frust-analyzer%2Fsrc%2Fdiagnostics%2Fsnapshots%2Frust_analyzer__diagnostics__to_proto__tests__snap_multi_line_fix.snap", "raw_url": "https://github.com/rust-lang/rust/raw/05db35dafb47db355e202c9176bd8a752b7390d7/crates%2Frust-analyzer%2Fsrc%2Fdiagnostics%2Fsnapshots%2Frust_analyzer__diagnostics__to_proto__tests__snap_multi_line_fix.snap", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fdiagnostics%2Fsnapshots%2Frust_analyzer__diagnostics__to_proto__tests__snap_multi_line_fix.snap?ref=05db35dafb47db355e202c9176bd8a752b7390d7", "patch": "@@ -1,5 +1,5 @@\n ---\n-source: crates/ra_flycheck/src/conv/test.rs\n+source: crates/rust-analyzer/src/diagnostics/to_proto.rs\n expression: diag\n ---\n [", "previous_filename": "crates/ra_flycheck/src/conv/snapshots/ra_flycheck__conv__test__snap_multi_line_fix.snap"}, {"sha": "46d0c56d222d5d5666180e0e3eb533b2ecf96666", "filename": "crates/rust-analyzer/src/diagnostics/snapshots/rust_analyzer__diagnostics__to_proto__tests__snap_rustc_incompatible_type_for_trait.snap", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/05db35dafb47db355e202c9176bd8a752b7390d7/crates%2Frust-analyzer%2Fsrc%2Fdiagnostics%2Fsnapshots%2Frust_analyzer__diagnostics__to_proto__tests__snap_rustc_incompatible_type_for_trait.snap", "raw_url": "https://github.com/rust-lang/rust/raw/05db35dafb47db355e202c9176bd8a752b7390d7/crates%2Frust-analyzer%2Fsrc%2Fdiagnostics%2Fsnapshots%2Frust_analyzer__diagnostics__to_proto__tests__snap_rustc_incompatible_type_for_trait.snap", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fdiagnostics%2Fsnapshots%2Frust_analyzer__diagnostics__to_proto__tests__snap_rustc_incompatible_type_for_trait.snap?ref=05db35dafb47db355e202c9176bd8a752b7390d7", "patch": "@@ -1,5 +1,5 @@\n ---\n-source: crates/ra_flycheck/src/conv/test.rs\n+source: crates/rust-analyzer/src/diagnostics/to_proto.rs\n expression: diag\n ---\n [", "previous_filename": "crates/ra_flycheck/src/conv/snapshots/ra_flycheck__conv__test__snap_rustc_incompatible_type_for_trait.snap"}, {"sha": "4182929ba319faf6b714eb7d183bd01823656d6e", "filename": "crates/rust-analyzer/src/diagnostics/snapshots/rust_analyzer__diagnostics__to_proto__tests__snap_rustc_mismatched_type.snap", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/05db35dafb47db355e202c9176bd8a752b7390d7/crates%2Frust-analyzer%2Fsrc%2Fdiagnostics%2Fsnapshots%2Frust_analyzer__diagnostics__to_proto__tests__snap_rustc_mismatched_type.snap", "raw_url": "https://github.com/rust-lang/rust/raw/05db35dafb47db355e202c9176bd8a752b7390d7/crates%2Frust-analyzer%2Fsrc%2Fdiagnostics%2Fsnapshots%2Frust_analyzer__diagnostics__to_proto__tests__snap_rustc_mismatched_type.snap", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fdiagnostics%2Fsnapshots%2Frust_analyzer__diagnostics__to_proto__tests__snap_rustc_mismatched_type.snap?ref=05db35dafb47db355e202c9176bd8a752b7390d7", "patch": "@@ -1,5 +1,5 @@\n ---\n-source: crates/ra_flycheck/src/conv/test.rs\n+source: crates/rust-analyzer/src/diagnostics/to_proto.rs\n expression: diag\n ---\n [", "previous_filename": "crates/ra_flycheck/src/conv/snapshots/ra_flycheck__conv__test__snap_rustc_mismatched_type.snap"}, {"sha": "69138c15b27869184247be83d37423859f146d0f", "filename": "crates/rust-analyzer/src/diagnostics/snapshots/rust_analyzer__diagnostics__to_proto__tests__snap_rustc_unused_variable.snap", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/05db35dafb47db355e202c9176bd8a752b7390d7/crates%2Frust-analyzer%2Fsrc%2Fdiagnostics%2Fsnapshots%2Frust_analyzer__diagnostics__to_proto__tests__snap_rustc_unused_variable.snap", "raw_url": "https://github.com/rust-lang/rust/raw/05db35dafb47db355e202c9176bd8a752b7390d7/crates%2Frust-analyzer%2Fsrc%2Fdiagnostics%2Fsnapshots%2Frust_analyzer__diagnostics__to_proto__tests__snap_rustc_unused_variable.snap", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fdiagnostics%2Fsnapshots%2Frust_analyzer__diagnostics__to_proto__tests__snap_rustc_unused_variable.snap?ref=05db35dafb47db355e202c9176bd8a752b7390d7", "patch": "@@ -1,5 +1,5 @@\n ---\n-source: crates/ra_flycheck/src/conv/test.rs\n+source: crates/rust-analyzer/src/diagnostics/to_proto.rs\n expression: diag\n ---\n [", "previous_filename": "crates/ra_flycheck/src/conv/snapshots/ra_flycheck__conv__test__snap_rustc_unused_variable.snap"}, {"sha": "f6ab05004bbab16b7ba32241fbbaf9da91f30b00", "filename": "crates/rust-analyzer/src/diagnostics/snapshots/rust_analyzer__diagnostics__to_proto__tests__snap_rustc_wrong_number_of_parameters.snap", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/05db35dafb47db355e202c9176bd8a752b7390d7/crates%2Frust-analyzer%2Fsrc%2Fdiagnostics%2Fsnapshots%2Frust_analyzer__diagnostics__to_proto__tests__snap_rustc_wrong_number_of_parameters.snap", "raw_url": "https://github.com/rust-lang/rust/raw/05db35dafb47db355e202c9176bd8a752b7390d7/crates%2Frust-analyzer%2Fsrc%2Fdiagnostics%2Fsnapshots%2Frust_analyzer__diagnostics__to_proto__tests__snap_rustc_wrong_number_of_parameters.snap", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fdiagnostics%2Fsnapshots%2Frust_analyzer__diagnostics__to_proto__tests__snap_rustc_wrong_number_of_parameters.snap?ref=05db35dafb47db355e202c9176bd8a752b7390d7", "patch": "@@ -1,5 +1,5 @@\n ---\n-source: crates/ra_flycheck/src/conv/test.rs\n+source: crates/rust-analyzer/src/diagnostics/to_proto.rs\n expression: diag\n ---\n [", "previous_filename": "crates/ra_flycheck/src/conv/snapshots/ra_flycheck__conv__test__snap_rustc_wrong_number_of_parameters.snap"}, {"sha": "eabf4908ff165494dbf8174e512eaf284dedcb64", "filename": "crates/rust-analyzer/src/diagnostics/to_proto.rs", "status": "added", "additions": 1397, "deletions": 0, "changes": 1397, "blob_url": "https://github.com/rust-lang/rust/blob/05db35dafb47db355e202c9176bd8a752b7390d7/crates%2Frust-analyzer%2Fsrc%2Fdiagnostics%2Fto_proto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05db35dafb47db355e202c9176bd8a752b7390d7/crates%2Frust-analyzer%2Fsrc%2Fdiagnostics%2Fto_proto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fdiagnostics%2Fto_proto.rs?ref=05db35dafb47db355e202c9176bd8a752b7390d7", "patch": "@@ -0,0 +1,1397 @@\n+//! This module provides the functionality needed to convert diagnostics from\n+//! `cargo check` json format to the LSP diagnostic format.\n+use std::{\n+    collections::HashMap,\n+    path::{Component, Path, Prefix},\n+    str::FromStr,\n+};\n+\n+use lsp_types::{\n+    CodeAction, Diagnostic, DiagnosticRelatedInformation, DiagnosticSeverity, DiagnosticTag,\n+    Location, NumberOrString, Position, Range, TextEdit, Url, WorkspaceEdit,\n+};\n+use ra_flycheck::{Applicability, DiagnosticLevel, DiagnosticSpan, DiagnosticSpanMacroExpansion};\n+use stdx::format_to;\n+\n+use crate::Result;\n+\n+/// Converts a Rust level string to a LSP severity\n+fn map_level_to_severity(val: DiagnosticLevel) -> Option<DiagnosticSeverity> {\n+    let res = match val {\n+        DiagnosticLevel::Ice => DiagnosticSeverity::Error,\n+        DiagnosticLevel::Error => DiagnosticSeverity::Error,\n+        DiagnosticLevel::Warning => DiagnosticSeverity::Warning,\n+        DiagnosticLevel::Note => DiagnosticSeverity::Information,\n+        DiagnosticLevel::Help => DiagnosticSeverity::Hint,\n+        DiagnosticLevel::Unknown => return None,\n+    };\n+    Some(res)\n+}\n+\n+/// Check whether a file name is from macro invocation\n+fn is_from_macro(file_name: &str) -> bool {\n+    file_name.starts_with('<') && file_name.ends_with('>')\n+}\n+\n+/// Converts a Rust macro span to a LSP location recursively\n+fn map_macro_span_to_location(\n+    span_macro: &DiagnosticSpanMacroExpansion,\n+    workspace_root: &Path,\n+) -> Option<Location> {\n+    if !is_from_macro(&span_macro.span.file_name) {\n+        return Some(map_span_to_location(&span_macro.span, workspace_root));\n+    }\n+\n+    if let Some(expansion) = &span_macro.span.expansion {\n+        return map_macro_span_to_location(&expansion, workspace_root);\n+    }\n+\n+    None\n+}\n+\n+/// Converts a Rust span to a LSP location, resolving macro expansion site if neccesary\n+fn map_span_to_location(span: &DiagnosticSpan, workspace_root: &Path) -> Location {\n+    if span.expansion.is_some() {\n+        let expansion = span.expansion.as_ref().unwrap();\n+        if let Some(macro_range) = map_macro_span_to_location(&expansion, workspace_root) {\n+            return macro_range;\n+        }\n+    }\n+\n+    map_span_to_location_naive(span, workspace_root)\n+}\n+\n+/// Converts a Rust span to a LSP location\n+fn map_span_to_location_naive(span: &DiagnosticSpan, workspace_root: &Path) -> Location {\n+    let mut file_name = workspace_root.to_path_buf();\n+    file_name.push(&span.file_name);\n+    let uri = url_from_path_with_drive_lowercasing(file_name).unwrap();\n+\n+    // FIXME: this doesn't handle UTF16 offsets correctly\n+    let range = Range::new(\n+        Position::new(span.line_start as u64 - 1, span.column_start as u64 - 1),\n+        Position::new(span.line_end as u64 - 1, span.column_end as u64 - 1),\n+    );\n+\n+    Location { uri, range }\n+}\n+\n+/// Converts a secondary Rust span to a LSP related information\n+///\n+/// If the span is unlabelled this will return `None`.\n+fn map_secondary_span_to_related(\n+    span: &DiagnosticSpan,\n+    workspace_root: &Path,\n+) -> Option<DiagnosticRelatedInformation> {\n+    let message = span.label.clone()?;\n+    let location = map_span_to_location(span, workspace_root);\n+    Some(DiagnosticRelatedInformation { location, message })\n+}\n+\n+/// Determines if diagnostic is related to unused code\n+fn is_unused_or_unnecessary(rd: &ra_flycheck::Diagnostic) -> bool {\n+    match &rd.code {\n+        Some(code) => match code.code.as_str() {\n+            \"dead_code\" | \"unknown_lints\" | \"unreachable_code\" | \"unused_attributes\"\n+            | \"unused_imports\" | \"unused_macros\" | \"unused_variables\" => true,\n+            _ => false,\n+        },\n+        None => false,\n+    }\n+}\n+\n+/// Determines if diagnostic is related to deprecated code\n+fn is_deprecated(rd: &ra_flycheck::Diagnostic) -> bool {\n+    match &rd.code {\n+        Some(code) => code.code.as_str() == \"deprecated\",\n+        None => false,\n+    }\n+}\n+\n+enum MappedRustChildDiagnostic {\n+    Related(DiagnosticRelatedInformation),\n+    SuggestedFix(CodeAction),\n+    MessageLine(String),\n+}\n+\n+fn map_rust_child_diagnostic(\n+    rd: &ra_flycheck::Diagnostic,\n+    workspace_root: &Path,\n+) -> MappedRustChildDiagnostic {\n+    let spans: Vec<&DiagnosticSpan> = rd.spans.iter().filter(|s| s.is_primary).collect();\n+    if spans.is_empty() {\n+        // `rustc` uses these spanless children as a way to print multi-line\n+        // messages\n+        return MappedRustChildDiagnostic::MessageLine(rd.message.clone());\n+    }\n+\n+    let mut edit_map: HashMap<Url, Vec<TextEdit>> = HashMap::new();\n+    for &span in &spans {\n+        match (&span.suggestion_applicability, &span.suggested_replacement) {\n+            (Some(Applicability::MachineApplicable), Some(suggested_replacement)) => {\n+                let location = map_span_to_location(span, workspace_root);\n+                let edit = TextEdit::new(location.range, suggested_replacement.clone());\n+                edit_map.entry(location.uri).or_default().push(edit);\n+            }\n+            _ => {}\n+        }\n+    }\n+\n+    if edit_map.is_empty() {\n+        MappedRustChildDiagnostic::Related(DiagnosticRelatedInformation {\n+            location: map_span_to_location(spans[0], workspace_root),\n+            message: rd.message.clone(),\n+        })\n+    } else {\n+        MappedRustChildDiagnostic::SuggestedFix(CodeAction {\n+            title: rd.message.clone(),\n+            kind: Some(\"quickfix\".to_string()),\n+            diagnostics: None,\n+            edit: Some(WorkspaceEdit::new(edit_map)),\n+            command: None,\n+            is_preferred: None,\n+        })\n+    }\n+}\n+\n+#[derive(Debug)]\n+pub(crate) struct MappedRustDiagnostic {\n+    pub location: Location,\n+    pub diagnostic: Diagnostic,\n+    pub fixes: Vec<CodeAction>,\n+}\n+\n+/// Converts a Rust root diagnostic to LSP form\n+///\n+/// This flattens the Rust diagnostic by:\n+///\n+/// 1. Creating a LSP diagnostic with the root message and primary span.\n+/// 2. Adding any labelled secondary spans to `relatedInformation`\n+/// 3. Categorising child diagnostics as either `SuggestedFix`es,\n+///    `relatedInformation` or additional message lines.\n+///\n+/// If the diagnostic has no primary span this will return `None`\n+pub(crate) fn map_rust_diagnostic_to_lsp(\n+    rd: &ra_flycheck::Diagnostic,\n+    workspace_root: &Path,\n+) -> Vec<MappedRustDiagnostic> {\n+    let primary_spans: Vec<&DiagnosticSpan> = rd.spans.iter().filter(|s| s.is_primary).collect();\n+    if primary_spans.is_empty() {\n+        return Vec::new();\n+    }\n+\n+    let severity = map_level_to_severity(rd.level);\n+\n+    let mut source = String::from(\"rustc\");\n+    let mut code = rd.code.as_ref().map(|c| c.code.clone());\n+    if let Some(code_val) = &code {\n+        // See if this is an RFC #2103 scoped lint (e.g. from Clippy)\n+        let scoped_code: Vec<&str> = code_val.split(\"::\").collect();\n+        if scoped_code.len() == 2 {\n+            source = String::from(scoped_code[0]);\n+            code = Some(String::from(scoped_code[1]));\n+        }\n+    }\n+\n+    let mut needs_primary_span_label = true;\n+    let mut related_information = Vec::new();\n+    let mut tags = Vec::new();\n+\n+    for secondary_span in rd.spans.iter().filter(|s| !s.is_primary) {\n+        let related = map_secondary_span_to_related(secondary_span, workspace_root);\n+        if let Some(related) = related {\n+            related_information.push(related);\n+        }\n+    }\n+\n+    let mut fixes = Vec::new();\n+    let mut message = rd.message.clone();\n+    for child in &rd.children {\n+        let child = map_rust_child_diagnostic(&child, workspace_root);\n+        match child {\n+            MappedRustChildDiagnostic::Related(related) => related_information.push(related),\n+            MappedRustChildDiagnostic::SuggestedFix(code_action) => fixes.push(code_action),\n+            MappedRustChildDiagnostic::MessageLine(message_line) => {\n+                format_to!(message, \"\\n{}\", message_line);\n+\n+                // These secondary messages usually duplicate the content of the\n+                // primary span label.\n+                needs_primary_span_label = false;\n+            }\n+        }\n+    }\n+\n+    if is_unused_or_unnecessary(rd) {\n+        tags.push(DiagnosticTag::Unnecessary);\n+    }\n+\n+    if is_deprecated(rd) {\n+        tags.push(DiagnosticTag::Deprecated);\n+    }\n+\n+    primary_spans\n+        .iter()\n+        .map(|primary_span| {\n+            let location = map_span_to_location(&primary_span, workspace_root);\n+\n+            let mut message = message.clone();\n+            if needs_primary_span_label {\n+                if let Some(primary_span_label) = &primary_span.label {\n+                    format_to!(message, \"\\n{}\", primary_span_label);\n+                }\n+            }\n+\n+            // If error occurs from macro expansion, add related info pointing to\n+            // where the error originated\n+            if !is_from_macro(&primary_span.file_name) && primary_span.expansion.is_some() {\n+                let def_loc = map_span_to_location_naive(&primary_span, workspace_root);\n+                related_information.push(DiagnosticRelatedInformation {\n+                    location: def_loc,\n+                    message: \"Error originated from macro here\".to_string(),\n+                });\n+            }\n+\n+            let diagnostic = Diagnostic {\n+                range: location.range,\n+                severity,\n+                code: code.clone().map(NumberOrString::String),\n+                source: Some(source.clone()),\n+                message,\n+                related_information: if related_information.is_empty() {\n+                    None\n+                } else {\n+                    Some(related_information.clone())\n+                },\n+                tags: if tags.is_empty() { None } else { Some(tags.clone()) },\n+            };\n+\n+            MappedRustDiagnostic { location, diagnostic, fixes: fixes.clone() }\n+        })\n+        .collect()\n+}\n+\n+/// Returns a `Url` object from a given path, will lowercase drive letters if present.\n+/// This will only happen when processing windows paths.\n+///\n+/// When processing non-windows path, this is essentially the same as `Url::from_file_path`.\n+pub fn url_from_path_with_drive_lowercasing(path: impl AsRef<Path>) -> Result<Url> {\n+    let component_has_windows_drive = path.as_ref().components().any(|comp| {\n+        if let Component::Prefix(c) = comp {\n+            return matches!(c.kind(), Prefix::Disk(_) | Prefix::VerbatimDisk(_));\n+        }\n+        false\n+    });\n+\n+    // VSCode expects drive letters to be lowercased, where rust will uppercase the drive letters.\n+    let res = if component_has_windows_drive {\n+        let url_original = Url::from_file_path(&path)\n+            .map_err(|_| format!(\"can't convert path to url: {}\", path.as_ref().display()))?;\n+\n+        let drive_partition: Vec<&str> = url_original.as_str().rsplitn(2, ':').collect();\n+\n+        // There is a drive partition, but we never found a colon.\n+        // This should not happen, but in this case we just pass it through.\n+        if drive_partition.len() == 1 {\n+            return Ok(url_original);\n+        }\n+\n+        let joined = drive_partition[1].to_ascii_lowercase() + \":\" + drive_partition[0];\n+        let url = Url::from_str(&joined).expect(\"This came from a valid `Url`\");\n+\n+        url\n+    } else {\n+        Url::from_file_path(&path)\n+            .map_err(|_| format!(\"can't convert path to url: {}\", path.as_ref().display()))?\n+    };\n+    Ok(res)\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+\n+    // `Url` is not able to parse windows paths on unix machines.\n+    #[test]\n+    #[cfg(target_os = \"windows\")]\n+    fn test_lowercase_drive_letter_with_drive() {\n+        let url = url_from_path_with_drive_lowercasing(\"C:\\\\Test\").unwrap();\n+\n+        assert_eq!(url.to_string(), \"file:///c:/Test\");\n+    }\n+\n+    #[test]\n+    #[cfg(target_os = \"windows\")]\n+    fn test_drive_without_colon_passthrough() {\n+        let url = url_from_path_with_drive_lowercasing(r#\"\\\\localhost\\C$\\my_dir\"#).unwrap();\n+\n+        assert_eq!(url.to_string(), \"file://localhost/C$/my_dir\");\n+    }\n+\n+    #[cfg(not(windows))]\n+    fn parse_diagnostic(val: &str) -> ra_flycheck::Diagnostic {\n+        serde_json::from_str::<ra_flycheck::Diagnostic>(val).unwrap()\n+    }\n+\n+    #[test]\n+    #[cfg(not(windows))]\n+    fn snap_rustc_incompatible_type_for_trait() {\n+        let diag = parse_diagnostic(\n+            r##\"{\n+                \"message\": \"method `next` has an incompatible type for trait\",\n+                \"code\": {\n+                    \"code\": \"E0053\",\n+                    \"explanation\": \"\\nThe parameters of any trait method must match between a trait implementation\\nand the trait definition.\\n\\nHere are a couple examples of this error:\\n\\n```compile_fail,E0053\\ntrait Foo {\\n    fn foo(x: u16);\\n    fn bar(&self);\\n}\\n\\nstruct Bar;\\n\\nimpl Foo for Bar {\\n    // error, expected u16, found i16\\n    fn foo(x: i16) { }\\n\\n    // error, types differ in mutability\\n    fn bar(&mut self) { }\\n}\\n```\\n\"\n+                },\n+                \"level\": \"error\",\n+                \"spans\": [\n+                    {\n+                        \"file_name\": \"compiler/ty/list_iter.rs\",\n+                        \"byte_start\": 1307,\n+                        \"byte_end\": 1350,\n+                        \"line_start\": 52,\n+                        \"line_end\": 52,\n+                        \"column_start\": 5,\n+                        \"column_end\": 48,\n+                        \"is_primary\": true,\n+                        \"text\": [\n+                            {\n+                                \"text\": \"    fn next(&self) -> Option<&'list ty::Ref<M>> {\",\n+                                \"highlight_start\": 5,\n+                                \"highlight_end\": 48\n+                            }\n+                        ],\n+                        \"label\": \"types differ in mutability\",\n+                        \"suggested_replacement\": null,\n+                        \"suggestion_applicability\": null,\n+                        \"expansion\": null\n+                    }\n+                ],\n+                \"children\": [\n+                    {\n+                        \"message\": \"expected type `fn(&mut ty::list_iter::ListIterator<'list, M>) -> std::option::Option<&ty::Ref<M>>`\\n   found type `fn(&ty::list_iter::ListIterator<'list, M>) -> std::option::Option<&'list ty::Ref<M>>`\",\n+                        \"code\": null,\n+                        \"level\": \"note\",\n+                        \"spans\": [],\n+                        \"children\": [],\n+                        \"rendered\": null\n+                    }\n+                ],\n+                \"rendered\": \"error[E0053]: method `next` has an incompatible type for trait\\n  --> compiler/ty/list_iter.rs:52:5\\n   |\\n52 |     fn next(&self) -> Option<&'list ty::Ref<M>> {\\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ types differ in mutability\\n   |\\n   = note: expected type `fn(&mut ty::list_iter::ListIterator<'list, M>) -> std::option::Option<&ty::Ref<M>>`\\n              found type `fn(&ty::list_iter::ListIterator<'list, M>) -> std::option::Option<&'list ty::Ref<M>>`\\n\\n\"\n+            }\n+            \"##,\n+        );\n+\n+        let workspace_root = Path::new(\"/test/\");\n+        let diag = map_rust_diagnostic_to_lsp(&diag, workspace_root);\n+        insta::assert_debug_snapshot!(diag);\n+    }\n+\n+    #[test]\n+    #[cfg(not(windows))]\n+    fn snap_rustc_unused_variable() {\n+        let diag = parse_diagnostic(\n+            r##\"{\n+    \"message\": \"unused variable: `foo`\",\n+    \"code\": {\n+        \"code\": \"unused_variables\",\n+        \"explanation\": null\n+    },\n+    \"level\": \"warning\",\n+    \"spans\": [\n+        {\n+            \"file_name\": \"driver/subcommand/repl.rs\",\n+            \"byte_start\": 9228,\n+            \"byte_end\": 9231,\n+            \"line_start\": 291,\n+            \"line_end\": 291,\n+            \"column_start\": 9,\n+            \"column_end\": 12,\n+            \"is_primary\": true,\n+            \"text\": [\n+                {\n+                    \"text\": \"    let foo = 42;\",\n+                    \"highlight_start\": 9,\n+                    \"highlight_end\": 12\n+                }\n+            ],\n+            \"label\": null,\n+            \"suggested_replacement\": null,\n+            \"suggestion_applicability\": null,\n+            \"expansion\": null\n+        }\n+    ],\n+    \"children\": [\n+        {\n+            \"message\": \"#[warn(unused_variables)] on by default\",\n+            \"code\": null,\n+            \"level\": \"note\",\n+            \"spans\": [],\n+            \"children\": [],\n+            \"rendered\": null\n+        },\n+        {\n+            \"message\": \"consider prefixing with an underscore\",\n+            \"code\": null,\n+            \"level\": \"help\",\n+            \"spans\": [\n+                {\n+                    \"file_name\": \"driver/subcommand/repl.rs\",\n+                    \"byte_start\": 9228,\n+                    \"byte_end\": 9231,\n+                    \"line_start\": 291,\n+                    \"line_end\": 291,\n+                    \"column_start\": 9,\n+                    \"column_end\": 12,\n+                    \"is_primary\": true,\n+                    \"text\": [\n+                        {\n+                            \"text\": \"    let foo = 42;\",\n+                            \"highlight_start\": 9,\n+                            \"highlight_end\": 12\n+                        }\n+                    ],\n+                    \"label\": null,\n+                    \"suggested_replacement\": \"_foo\",\n+                    \"suggestion_applicability\": \"MachineApplicable\",\n+                    \"expansion\": null\n+                }\n+            ],\n+            \"children\": [],\n+            \"rendered\": null\n+        }\n+    ],\n+    \"rendered\": \"warning: unused variable: `foo`\\n   --> driver/subcommand/repl.rs:291:9\\n    |\\n291 |     let foo = 42;\\n    |         ^^^ help: consider prefixing with an underscore: `_foo`\\n    |\\n    = note: #[warn(unused_variables)] on by default\\n\\n\"\n+    }\"##,\n+        );\n+\n+        let workspace_root = Path::new(\"/test/\");\n+        let diag = map_rust_diagnostic_to_lsp(&diag, workspace_root);\n+        insta::assert_debug_snapshot!(diag);\n+    }\n+\n+    #[test]\n+    #[cfg(not(windows))]\n+    fn snap_rustc_wrong_number_of_parameters() {\n+        let diag = parse_diagnostic(\n+            r##\"{\n+    \"message\": \"this function takes 2 parameters but 3 parameters were supplied\",\n+    \"code\": {\n+        \"code\": \"E0061\",\n+        \"explanation\": \"\\nThe number of arguments passed to a function must match the number of arguments\\nspecified in the function signature.\\n\\nFor example, a function like:\\n\\n```\\nfn f(a: u16, b: &str) {}\\n```\\n\\nMust always be called with exactly two arguments, e.g., `f(2, \\\"test\\\")`.\\n\\nNote that Rust does not have a notion of optional function arguments or\\nvariadic functions (except for its C-FFI).\\n\"\n+    },\n+    \"level\": \"error\",\n+    \"spans\": [\n+        {\n+            \"file_name\": \"compiler/ty/select.rs\",\n+            \"byte_start\": 8787,\n+            \"byte_end\": 9241,\n+            \"line_start\": 219,\n+            \"line_end\": 231,\n+            \"column_start\": 5,\n+            \"column_end\": 6,\n+            \"is_primary\": false,\n+            \"text\": [\n+                {\n+                    \"text\": \"    pub fn add_evidence(\",\n+                    \"highlight_start\": 5,\n+                    \"highlight_end\": 25\n+                },\n+                {\n+                    \"text\": \"        &mut self,\",\n+                    \"highlight_start\": 1,\n+                    \"highlight_end\": 19\n+                },\n+                {\n+                    \"text\": \"        target_poly: &ty::Ref<ty::Poly>,\",\n+                    \"highlight_start\": 1,\n+                    \"highlight_end\": 41\n+                },\n+                {\n+                    \"text\": \"        evidence_poly: &ty::Ref<ty::Poly>,\",\n+                    \"highlight_start\": 1,\n+                    \"highlight_end\": 43\n+                },\n+                {\n+                    \"text\": \"    ) {\",\n+                    \"highlight_start\": 1,\n+                    \"highlight_end\": 8\n+                },\n+                {\n+                    \"text\": \"        match target_poly {\",\n+                    \"highlight_start\": 1,\n+                    \"highlight_end\": 28\n+                },\n+                {\n+                    \"text\": \"            ty::Ref::Var(tvar, _) => self.add_var_evidence(tvar, evidence_poly),\",\n+                    \"highlight_start\": 1,\n+                    \"highlight_end\": 81\n+                },\n+                {\n+                    \"text\": \"            ty::Ref::Fixed(target_ty) => {\",\n+                    \"highlight_start\": 1,\n+                    \"highlight_end\": 43\n+                },\n+                {\n+                    \"text\": \"                let evidence_ty = evidence_poly.resolve_to_ty();\",\n+                    \"highlight_start\": 1,\n+                    \"highlight_end\": 65\n+                },\n+                {\n+                    \"text\": \"                self.add_evidence_ty(target_ty, evidence_poly, evidence_ty)\",\n+                    \"highlight_start\": 1,\n+                    \"highlight_end\": 76\n+                },\n+                {\n+                    \"text\": \"            }\",\n+                    \"highlight_start\": 1,\n+                    \"highlight_end\": 14\n+                },\n+                {\n+                    \"text\": \"        }\",\n+                    \"highlight_start\": 1,\n+                    \"highlight_end\": 10\n+                },\n+                {\n+                    \"text\": \"    }\",\n+                    \"highlight_start\": 1,\n+                    \"highlight_end\": 6\n+                }\n+            ],\n+            \"label\": \"defined here\",\n+            \"suggested_replacement\": null,\n+            \"suggestion_applicability\": null,\n+            \"expansion\": null\n+        },\n+        {\n+            \"file_name\": \"compiler/ty/select.rs\",\n+            \"byte_start\": 4045,\n+            \"byte_end\": 4057,\n+            \"line_start\": 104,\n+            \"line_end\": 104,\n+            \"column_start\": 18,\n+            \"column_end\": 30,\n+            \"is_primary\": true,\n+            \"text\": [\n+                {\n+                    \"text\": \"            self.add_evidence(target_fixed, evidence_fixed, false);\",\n+                    \"highlight_start\": 18,\n+                    \"highlight_end\": 30\n+                }\n+            ],\n+            \"label\": \"expected 2 parameters\",\n+            \"suggested_replacement\": null,\n+            \"suggestion_applicability\": null,\n+            \"expansion\": null\n+        }\n+    ],\n+    \"children\": [],\n+    \"rendered\": \"error[E0061]: this function takes 2 parameters but 3 parameters were supplied\\n   --> compiler/ty/select.rs:104:18\\n    |\\n104 |               self.add_evidence(target_fixed, evidence_fixed, false);\\n    |                    ^^^^^^^^^^^^ expected 2 parameters\\n...\\n219 | /     pub fn add_evidence(\\n220 | |         &mut self,\\n221 | |         target_poly: &ty::Ref<ty::Poly>,\\n222 | |         evidence_poly: &ty::Ref<ty::Poly>,\\n...   |\\n230 | |         }\\n231 | |     }\\n    | |_____- defined here\\n\\n\"\n+    }\"##,\n+        );\n+\n+        let workspace_root = Path::new(\"/test/\");\n+        let diag = map_rust_diagnostic_to_lsp(&diag, workspace_root);\n+        insta::assert_debug_snapshot!(diag);\n+    }\n+\n+    #[test]\n+    #[cfg(not(windows))]\n+    fn snap_clippy_pass_by_ref() {\n+        let diag = parse_diagnostic(\n+            r##\"{\n+    \"message\": \"this argument is passed by reference, but would be more efficient if passed by value\",\n+    \"code\": {\n+        \"code\": \"clippy::trivially_copy_pass_by_ref\",\n+        \"explanation\": null\n+    },\n+    \"level\": \"warning\",\n+    \"spans\": [\n+        {\n+            \"file_name\": \"compiler/mir/tagset.rs\",\n+            \"byte_start\": 941,\n+            \"byte_end\": 946,\n+            \"line_start\": 42,\n+            \"line_end\": 42,\n+            \"column_start\": 24,\n+            \"column_end\": 29,\n+            \"is_primary\": true,\n+            \"text\": [\n+                {\n+                    \"text\": \"    pub fn is_disjoint(&self, other: Self) -> bool {\",\n+                    \"highlight_start\": 24,\n+                    \"highlight_end\": 29\n+                }\n+            ],\n+            \"label\": null,\n+            \"suggested_replacement\": null,\n+            \"suggestion_applicability\": null,\n+            \"expansion\": null\n+        }\n+    ],\n+    \"children\": [\n+        {\n+            \"message\": \"lint level defined here\",\n+            \"code\": null,\n+            \"level\": \"note\",\n+            \"spans\": [\n+                {\n+                    \"file_name\": \"compiler/lib.rs\",\n+                    \"byte_start\": 8,\n+                    \"byte_end\": 19,\n+                    \"line_start\": 1,\n+                    \"line_end\": 1,\n+                    \"column_start\": 9,\n+                    \"column_end\": 20,\n+                    \"is_primary\": true,\n+                    \"text\": [\n+                        {\n+                            \"text\": \"#![warn(clippy::all)]\",\n+                            \"highlight_start\": 9,\n+                            \"highlight_end\": 20\n+                        }\n+                    ],\n+                    \"label\": null,\n+                    \"suggested_replacement\": null,\n+                    \"suggestion_applicability\": null,\n+                    \"expansion\": null\n+                }\n+            ],\n+            \"children\": [],\n+            \"rendered\": null\n+        },\n+        {\n+            \"message\": \"#[warn(clippy::trivially_copy_pass_by_ref)] implied by #[warn(clippy::all)]\",\n+            \"code\": null,\n+            \"level\": \"note\",\n+            \"spans\": [],\n+            \"children\": [],\n+            \"rendered\": null\n+        },\n+        {\n+            \"message\": \"for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#trivially_copy_pass_by_ref\",\n+            \"code\": null,\n+            \"level\": \"help\",\n+            \"spans\": [],\n+            \"children\": [],\n+            \"rendered\": null\n+        },\n+        {\n+            \"message\": \"consider passing by value instead\",\n+            \"code\": null,\n+            \"level\": \"help\",\n+            \"spans\": [\n+                {\n+                    \"file_name\": \"compiler/mir/tagset.rs\",\n+                    \"byte_start\": 941,\n+                    \"byte_end\": 946,\n+                    \"line_start\": 42,\n+                    \"line_end\": 42,\n+                    \"column_start\": 24,\n+                    \"column_end\": 29,\n+                    \"is_primary\": true,\n+                    \"text\": [\n+                        {\n+                            \"text\": \"    pub fn is_disjoint(&self, other: Self) -> bool {\",\n+                            \"highlight_start\": 24,\n+                            \"highlight_end\": 29\n+                        }\n+                    ],\n+                    \"label\": null,\n+                    \"suggested_replacement\": \"self\",\n+                    \"suggestion_applicability\": \"Unspecified\",\n+                    \"expansion\": null\n+                }\n+            ],\n+            \"children\": [],\n+            \"rendered\": null\n+        }\n+    ],\n+    \"rendered\": \"warning: this argument is passed by reference, but would be more efficient if passed by value\\n  --> compiler/mir/tagset.rs:42:24\\n   |\\n42 |     pub fn is_disjoint(&self, other: Self) -> bool {\\n   |                        ^^^^^ help: consider passing by value instead: `self`\\n   |\\nnote: lint level defined here\\n  --> compiler/lib.rs:1:9\\n   |\\n1  | #![warn(clippy::all)]\\n   |         ^^^^^^^^^^^\\n   = note: #[warn(clippy::trivially_copy_pass_by_ref)] implied by #[warn(clippy::all)]\\n   = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#trivially_copy_pass_by_ref\\n\\n\"\n+    }\"##,\n+        );\n+\n+        let workspace_root = Path::new(\"/test/\");\n+        let diag = map_rust_diagnostic_to_lsp(&diag, workspace_root);\n+        insta::assert_debug_snapshot!(diag);\n+    }\n+\n+    #[test]\n+    #[cfg(not(windows))]\n+    fn snap_rustc_mismatched_type() {\n+        let diag = parse_diagnostic(\n+            r##\"{\n+    \"message\": \"mismatched types\",\n+    \"code\": {\n+        \"code\": \"E0308\",\n+        \"explanation\": \"\\nThis error occurs when the compiler was unable to infer the concrete type of a\\nvariable. It can occur for several cases, the most common of which is a\\nmismatch in the expected type that the compiler inferred for a variable's\\ninitializing expression, and the actual type explicitly assigned to the\\nvariable.\\n\\nFor example:\\n\\n```compile_fail,E0308\\nlet x: i32 = \\\"I am not a number!\\\";\\n//     ~~~   ~~~~~~~~~~~~~~~~~~~~\\n//      |             |\\n//      |    initializing expression;\\n//      |    compiler infers type `&str`\\n//      |\\n//    type `i32` assigned to variable `x`\\n```\\n\"\n+    },\n+    \"level\": \"error\",\n+    \"spans\": [\n+        {\n+            \"file_name\": \"runtime/compiler_support.rs\",\n+            \"byte_start\": 1589,\n+            \"byte_end\": 1594,\n+            \"line_start\": 48,\n+            \"line_end\": 48,\n+            \"column_start\": 65,\n+            \"column_end\": 70,\n+            \"is_primary\": true,\n+            \"text\": [\n+                {\n+                    \"text\": \"    let layout = alloc::Layout::from_size_align_unchecked(size, align);\",\n+                    \"highlight_start\": 65,\n+                    \"highlight_end\": 70\n+                }\n+            ],\n+            \"label\": \"expected usize, found u32\",\n+            \"suggested_replacement\": null,\n+            \"suggestion_applicability\": null,\n+            \"expansion\": null\n+        }\n+    ],\n+    \"children\": [],\n+    \"rendered\": \"error[E0308]: mismatched types\\n  --> runtime/compiler_support.rs:48:65\\n   |\\n48 |     let layout = alloc::Layout::from_size_align_unchecked(size, align);\\n   |                                                                 ^^^^^ expected usize, found u32\\n\\n\"\n+    }\"##,\n+        );\n+\n+        let workspace_root = Path::new(\"/test/\");\n+        let diag = map_rust_diagnostic_to_lsp(&diag, workspace_root);\n+        insta::assert_debug_snapshot!(diag);\n+    }\n+\n+    #[test]\n+    #[cfg(not(windows))]\n+    fn snap_handles_macro_location() {\n+        let diag = parse_diagnostic(\n+            r##\"{\n+    \"rendered\": \"error[E0277]: can't compare `{integer}` with `&str`\\n --> src/main.rs:2:5\\n  |\\n2 |     assert_eq!(1, \\\"love\\\");\\n  |     ^^^^^^^^^^^^^^^^^^^^^^ no implementation for `{integer} == &str`\\n  |\\n  = help: the trait `std::cmp::PartialEq<&str>` is not implemented for `{integer}`\\n  = note: this error originates in a macro outside of the current crate (in Nightly builds, run with -Z external-macro-backtrace for more info)\\n\\n\",\n+    \"children\": [\n+        {\n+            \"children\": [],\n+            \"code\": null,\n+            \"level\": \"help\",\n+            \"message\": \"the trait `std::cmp::PartialEq<&str>` is not implemented for `{integer}`\",\n+            \"rendered\": null,\n+            \"spans\": []\n+        }\n+    ],\n+    \"code\": {\n+        \"code\": \"E0277\",\n+        \"explanation\": \"\\nYou tried to use a type which doesn't implement some trait in a place which\\nexpected that trait. Erroneous code example:\\n\\n```compile_fail,E0277\\n// here we declare the Foo trait with a bar method\\ntrait Foo {\\n    fn bar(&self);\\n}\\n\\n// we now declare a function which takes an object implementing the Foo trait\\nfn some_func<T: Foo>(foo: T) {\\n    foo.bar();\\n}\\n\\nfn main() {\\n    // we now call the method with the i32 type, which doesn't implement\\n    // the Foo trait\\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\\n}\\n```\\n\\nIn order to fix this error, verify that the type you're using does implement\\nthe trait. Example:\\n\\n```\\ntrait Foo {\\n    fn bar(&self);\\n}\\n\\nfn some_func<T: Foo>(foo: T) {\\n    foo.bar(); // we can now use this method since i32 implements the\\n               // Foo trait\\n}\\n\\n// we implement the trait on the i32 type\\nimpl Foo for i32 {\\n    fn bar(&self) {}\\n}\\n\\nfn main() {\\n    some_func(5i32); // ok!\\n}\\n```\\n\\nOr in a generic context, an erroneous code example would look like:\\n\\n```compile_fail,E0277\\nfn some_func<T>(foo: T) {\\n    println!(\\\"{:?}\\\", foo); // error: the trait `core::fmt::Debug` is not\\n                           //        implemented for the type `T`\\n}\\n\\nfn main() {\\n    // We now call the method with the i32 type,\\n    // which *does* implement the Debug trait.\\n    some_func(5i32);\\n}\\n```\\n\\nNote that the error here is in the definition of the generic function: Although\\nwe only call it with a parameter that does implement `Debug`, the compiler\\nstill rejects the function: It must work with all possible input types. In\\norder to make this example compile, we need to restrict the generic type we're\\naccepting:\\n\\n```\\nuse std::fmt;\\n\\n// Restrict the input type to types that implement Debug.\\nfn some_func<T: fmt::Debug>(foo: T) {\\n    println!(\\\"{:?}\\\", foo);\\n}\\n\\nfn main() {\\n    // Calling the method is still fine, as i32 implements Debug.\\n    some_func(5i32);\\n\\n    // This would fail to compile now:\\n    // struct WithoutDebug;\\n    // some_func(WithoutDebug);\\n}\\n```\\n\\nRust only looks at the signature of the called function, as such it must\\nalready specify all requirements that will be used for every type parameter.\\n\"\n+    },\n+    \"level\": \"error\",\n+    \"message\": \"can't compare `{integer}` with `&str`\",\n+    \"spans\": [\n+        {\n+            \"byte_end\": 155,\n+            \"byte_start\": 153,\n+            \"column_end\": 33,\n+            \"column_start\": 31,\n+            \"expansion\": {\n+                \"def_site_span\": {\n+                    \"byte_end\": 940,\n+                    \"byte_start\": 0,\n+                    \"column_end\": 6,\n+                    \"column_start\": 1,\n+                    \"expansion\": null,\n+                    \"file_name\": \"<::core::macros::assert_eq macros>\",\n+                    \"is_primary\": false,\n+                    \"label\": null,\n+                    \"line_end\": 36,\n+                    \"line_start\": 1,\n+                    \"suggested_replacement\": null,\n+                    \"suggestion_applicability\": null,\n+                    \"text\": [\n+                        {\n+                            \"highlight_end\": 35,\n+                            \"highlight_start\": 1,\n+                            \"text\": \"($ left : expr, $ right : expr) =>\"\n+                        },\n+                        {\n+                            \"highlight_end\": 3,\n+                            \"highlight_start\": 1,\n+                            \"text\": \"({\"\n+                        },\n+                        {\n+                            \"highlight_end\": 33,\n+                            \"highlight_start\": 1,\n+                            \"text\": \"     match (& $ left, & $ right)\"\n+                        },\n+                        {\n+                            \"highlight_end\": 7,\n+                            \"highlight_start\": 1,\n+                            \"text\": \"     {\"\n+                        },\n+                        {\n+                            \"highlight_end\": 34,\n+                            \"highlight_start\": 1,\n+                            \"text\": \"         (left_val, right_val) =>\"\n+                        },\n+                        {\n+                            \"highlight_end\": 11,\n+                            \"highlight_start\": 1,\n+                            \"text\": \"         {\"\n+                        },\n+                        {\n+                            \"highlight_end\": 46,\n+                            \"highlight_start\": 1,\n+                            \"text\": \"             if ! (* left_val == * right_val)\"\n+                        },\n+                        {\n+                            \"highlight_end\": 15,\n+                            \"highlight_start\": 1,\n+                            \"text\": \"             {\"\n+                        },\n+                        {\n+                            \"highlight_end\": 25,\n+                            \"highlight_start\": 1,\n+                            \"text\": \"                 panic !\"\n+                        },\n+                        {\n+                            \"highlight_end\": 57,\n+                            \"highlight_start\": 1,\n+                            \"text\": \"                 (r#\\\"assertion failed: `(left == right)`\"\n+                        },\n+                        {\n+                            \"highlight_end\": 16,\n+                            \"highlight_start\": 1,\n+                            \"text\": \"  left: `{:?}`,\"\n+                        },\n+                        {\n+                            \"highlight_end\": 18,\n+                            \"highlight_start\": 1,\n+                            \"text\": \" right: `{:?}`\\\"#,\"\n+                        },\n+                        {\n+                            \"highlight_end\": 47,\n+                            \"highlight_start\": 1,\n+                            \"text\": \"                  & * left_val, & * right_val)\"\n+                        },\n+                        {\n+                            \"highlight_end\": 15,\n+                            \"highlight_start\": 1,\n+                            \"text\": \"             }\"\n+                        },\n+                        {\n+                            \"highlight_end\": 11,\n+                            \"highlight_start\": 1,\n+                            \"text\": \"         }\"\n+                        },\n+                        {\n+                            \"highlight_end\": 7,\n+                            \"highlight_start\": 1,\n+                            \"text\": \"     }\"\n+                        },\n+                        {\n+                            \"highlight_end\": 42,\n+                            \"highlight_start\": 1,\n+                            \"text\": \" }) ; ($ left : expr, $ right : expr,) =>\"\n+                        },\n+                        {\n+                            \"highlight_end\": 49,\n+                            \"highlight_start\": 1,\n+                            \"text\": \"({ $ crate :: assert_eq ! ($ left, $ right) }) ;\"\n+                        },\n+                        {\n+                            \"highlight_end\": 53,\n+                            \"highlight_start\": 1,\n+                            \"text\": \"($ left : expr, $ right : expr, $ ($ arg : tt) +) =>\"\n+                        },\n+                        {\n+                            \"highlight_end\": 3,\n+                            \"highlight_start\": 1,\n+                            \"text\": \"({\"\n+                        },\n+                        {\n+                            \"highlight_end\": 37,\n+                            \"highlight_start\": 1,\n+                            \"text\": \"     match (& ($ left), & ($ right))\"\n+                        },\n+                        {\n+                            \"highlight_end\": 7,\n+                            \"highlight_start\": 1,\n+                            \"text\": \"     {\"\n+                        },\n+                        {\n+                            \"highlight_end\": 34,\n+                            \"highlight_start\": 1,\n+                            \"text\": \"         (left_val, right_val) =>\"\n+                        },\n+                        {\n+                            \"highlight_end\": 11,\n+                            \"highlight_start\": 1,\n+                            \"text\": \"         {\"\n+                        },\n+                        {\n+                            \"highlight_end\": 46,\n+                            \"highlight_start\": 1,\n+                            \"text\": \"             if ! (* left_val == * right_val)\"\n+                        },\n+                        {\n+                            \"highlight_end\": 15,\n+                            \"highlight_start\": 1,\n+                            \"text\": \"             {\"\n+                        },\n+                        {\n+                            \"highlight_end\": 25,\n+                            \"highlight_start\": 1,\n+                            \"text\": \"                 panic !\"\n+                        },\n+                        {\n+                            \"highlight_end\": 57,\n+                            \"highlight_start\": 1,\n+                            \"text\": \"                 (r#\\\"assertion failed: `(left == right)`\"\n+                        },\n+                        {\n+                            \"highlight_end\": 16,\n+                            \"highlight_start\": 1,\n+                            \"text\": \"  left: `{:?}`,\"\n+                        },\n+                        {\n+                            \"highlight_end\": 22,\n+                            \"highlight_start\": 1,\n+                            \"text\": \" right: `{:?}`: {}\\\"#,\"\n+                        },\n+                        {\n+                            \"highlight_end\": 72,\n+                            \"highlight_start\": 1,\n+                            \"text\": \"                  & * left_val, & * right_val, $ crate :: format_args !\"\n+                        },\n+                        {\n+                            \"highlight_end\": 33,\n+                            \"highlight_start\": 1,\n+                            \"text\": \"                  ($ ($ arg) +))\"\n+                        },\n+                        {\n+                            \"highlight_end\": 15,\n+                            \"highlight_start\": 1,\n+                            \"text\": \"             }\"\n+                        },\n+                        {\n+                            \"highlight_end\": 11,\n+                            \"highlight_start\": 1,\n+                            \"text\": \"         }\"\n+                        },\n+                        {\n+                            \"highlight_end\": 7,\n+                            \"highlight_start\": 1,\n+                            \"text\": \"     }\"\n+                        },\n+                        {\n+                            \"highlight_end\": 6,\n+                            \"highlight_start\": 1,\n+                            \"text\": \" }) ;\"\n+                        }\n+                    ]\n+                },\n+                \"macro_decl_name\": \"assert_eq!\",\n+                \"span\": {\n+                    \"byte_end\": 38,\n+                    \"byte_start\": 16,\n+                    \"column_end\": 27,\n+                    \"column_start\": 5,\n+                    \"expansion\": null,\n+                    \"file_name\": \"src/main.rs\",\n+                    \"is_primary\": false,\n+                    \"label\": null,\n+                    \"line_end\": 2,\n+                    \"line_start\": 2,\n+                    \"suggested_replacement\": null,\n+                    \"suggestion_applicability\": null,\n+                    \"text\": [\n+                        {\n+                            \"highlight_end\": 27,\n+                            \"highlight_start\": 5,\n+                            \"text\": \"    assert_eq!(1, \\\"love\\\");\"\n+                        }\n+                    ]\n+                }\n+            },\n+            \"file_name\": \"<::core::macros::assert_eq macros>\",\n+            \"is_primary\": true,\n+            \"label\": \"no implementation for `{integer} == &str`\",\n+            \"line_end\": 7,\n+            \"line_start\": 7,\n+            \"suggested_replacement\": null,\n+            \"suggestion_applicability\": null,\n+            \"text\": [\n+                {\n+                    \"highlight_end\": 33,\n+                    \"highlight_start\": 31,\n+                    \"text\": \"             if ! (* left_val == * right_val)\"\n+                }\n+            ]\n+        }\n+    ]\n+    }\"##,\n+        );\n+\n+        let workspace_root = Path::new(\"/test/\");\n+        let diag = map_rust_diagnostic_to_lsp(&diag, workspace_root);\n+        insta::assert_debug_snapshot!(diag);\n+    }\n+\n+    #[test]\n+    #[cfg(not(windows))]\n+    fn snap_macro_compiler_error() {\n+        let diag = parse_diagnostic(\n+            r##\"{\n+        \"rendered\": \"error: Please register your known path in the path module\\n   --> crates/ra_hir_def/src/path.rs:265:9\\n    |\\n265 |         compile_error!(\\\"Please register your known path in the path module\\\")\\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\\n    | \\n   ::: crates/ra_hir_def/src/data.rs:80:16\\n    |\\n80  |     let path = path![std::future::Future];\\n    |                -------------------------- in this macro invocation\\n\\n\",\n+        \"children\": [],\n+        \"code\": null,\n+        \"level\": \"error\",\n+        \"message\": \"Please register your known path in the path module\",\n+        \"spans\": [\n+            {\n+                \"byte_end\": 8285,\n+                \"byte_start\": 8217,\n+                \"column_end\": 77,\n+                \"column_start\": 9,\n+                \"expansion\": {\n+                    \"def_site_span\": {\n+                        \"byte_end\": 8294,\n+                        \"byte_start\": 7858,\n+                        \"column_end\": 2,\n+                        \"column_start\": 1,\n+                        \"expansion\": null,\n+                        \"file_name\": \"crates/ra_hir_def/src/path.rs\",\n+                        \"is_primary\": false,\n+                        \"label\": null,\n+                        \"line_end\": 267,\n+                        \"line_start\": 254,\n+                        \"suggested_replacement\": null,\n+                        \"suggestion_applicability\": null,\n+                        \"text\": [\n+                            {\n+                                \"highlight_end\": 28,\n+                                \"highlight_start\": 1,\n+                                \"text\": \"macro_rules! __known_path {\"\n+                            },\n+                            {\n+                                \"highlight_end\": 37,\n+                                \"highlight_start\": 1,\n+                                \"text\": \"    (std::iter::IntoIterator) => {};\"\n+                            },\n+                            {\n+                                \"highlight_end\": 33,\n+                                \"highlight_start\": 1,\n+                                \"text\": \"    (std::result::Result) => {};\"\n+                            },\n+                            {\n+                                \"highlight_end\": 29,\n+                                \"highlight_start\": 1,\n+                                \"text\": \"    (std::ops::Range) => {};\"\n+                            },\n+                            {\n+                                \"highlight_end\": 33,\n+                                \"highlight_start\": 1,\n+                                \"text\": \"    (std::ops::RangeFrom) => {};\"\n+                            },\n+                            {\n+                                \"highlight_end\": 33,\n+                                \"highlight_start\": 1,\n+                                \"text\": \"    (std::ops::RangeFull) => {};\"\n+                            },\n+                            {\n+                                \"highlight_end\": 31,\n+                                \"highlight_start\": 1,\n+                                \"text\": \"    (std::ops::RangeTo) => {};\"\n+                            },\n+                            {\n+                                \"highlight_end\": 40,\n+                                \"highlight_start\": 1,\n+                                \"text\": \"    (std::ops::RangeToInclusive) => {};\"\n+                            },\n+                            {\n+                                \"highlight_end\": 38,\n+                                \"highlight_start\": 1,\n+                                \"text\": \"    (std::ops::RangeInclusive) => {};\"\n+                            },\n+                            {\n+                                \"highlight_end\": 27,\n+                                \"highlight_start\": 1,\n+                                \"text\": \"    (std::ops::Try) => {};\"\n+                            },\n+                            {\n+                                \"highlight_end\": 22,\n+                                \"highlight_start\": 1,\n+                                \"text\": \"    ($path:path) => {\"\n+                            },\n+                            {\n+                                \"highlight_end\": 77,\n+                                \"highlight_start\": 1,\n+                                \"text\": \"        compile_error!(\\\"Please register your known path in the path module\\\")\"\n+                            },\n+                            {\n+                                \"highlight_end\": 7,\n+                                \"highlight_start\": 1,\n+                                \"text\": \"    };\"\n+                            },\n+                            {\n+                                \"highlight_end\": 2,\n+                                \"highlight_start\": 1,\n+                                \"text\": \"}\"\n+                            }\n+                        ]\n+                    },\n+                    \"macro_decl_name\": \"$crate::__known_path!\",\n+                    \"span\": {\n+                        \"byte_end\": 8427,\n+                        \"byte_start\": 8385,\n+                        \"column_end\": 51,\n+                        \"column_start\": 9,\n+                        \"expansion\": {\n+                            \"def_site_span\": {\n+                                \"byte_end\": 8611,\n+                                \"byte_start\": 8312,\n+                                \"column_end\": 2,\n+                                \"column_start\": 1,\n+                                \"expansion\": null,\n+                                \"file_name\": \"crates/ra_hir_def/src/path.rs\",\n+                                \"is_primary\": false,\n+                                \"label\": null,\n+                                \"line_end\": 277,\n+                                \"line_start\": 270,\n+                                \"suggested_replacement\": null,\n+                                \"suggestion_applicability\": null,\n+                                \"text\": [\n+                                    {\n+                                        \"highlight_end\": 22,\n+                                        \"highlight_start\": 1,\n+                                        \"text\": \"macro_rules! __path {\"\n+                                    },\n+                                    {\n+                                        \"highlight_end\": 43,\n+                                        \"highlight_start\": 1,\n+                                        \"text\": \"    ($start:ident $(:: $seg:ident)*) => ({\"\n+                                    },\n+                                    {\n+                                        \"highlight_end\": 51,\n+                                        \"highlight_start\": 1,\n+                                        \"text\": \"        $crate::__known_path!($start $(:: $seg)*);\"\n+                                    },\n+                                    {\n+                                        \"highlight_end\": 87,\n+                                        \"highlight_start\": 1,\n+                                        \"text\": \"        $crate::path::ModPath::from_simple_segments($crate::path::PathKind::Abs, vec![\"\n+                                    },\n+                                    {\n+                                        \"highlight_end\": 76,\n+                                        \"highlight_start\": 1,\n+                                        \"text\": \"            $crate::path::__name![$start], $($crate::path::__name![$seg],)*\"\n+                                    },\n+                                    {\n+                                        \"highlight_end\": 11,\n+                                        \"highlight_start\": 1,\n+                                        \"text\": \"        ])\"\n+                                    },\n+                                    {\n+                                        \"highlight_end\": 8,\n+                                        \"highlight_start\": 1,\n+                                        \"text\": \"    });\"\n+                                    },\n+                                    {\n+                                        \"highlight_end\": 2,\n+                                        \"highlight_start\": 1,\n+                                        \"text\": \"}\"\n+                                    }\n+                                ]\n+                            },\n+                            \"macro_decl_name\": \"path!\",\n+                            \"span\": {\n+                                \"byte_end\": 2966,\n+                                \"byte_start\": 2940,\n+                                \"column_end\": 42,\n+                                \"column_start\": 16,\n+                                \"expansion\": null,\n+                                \"file_name\": \"crates/ra_hir_def/src/data.rs\",\n+                                \"is_primary\": false,\n+                                \"label\": null,\n+                                \"line_end\": 80,\n+                                \"line_start\": 80,\n+                                \"suggested_replacement\": null,\n+                                \"suggestion_applicability\": null,\n+                                \"text\": [\n+                                    {\n+                                        \"highlight_end\": 42,\n+                                        \"highlight_start\": 16,\n+                                        \"text\": \"    let path = path![std::future::Future];\"\n+                                    }\n+                                ]\n+                            }\n+                        },\n+                        \"file_name\": \"crates/ra_hir_def/src/path.rs\",\n+                        \"is_primary\": false,\n+                        \"label\": null,\n+                        \"line_end\": 272,\n+                        \"line_start\": 272,\n+                        \"suggested_replacement\": null,\n+                        \"suggestion_applicability\": null,\n+                        \"text\": [\n+                            {\n+                                \"highlight_end\": 51,\n+                                \"highlight_start\": 9,\n+                                \"text\": \"        $crate::__known_path!($start $(:: $seg)*);\"\n+                            }\n+                        ]\n+                    }\n+                },\n+                \"file_name\": \"crates/ra_hir_def/src/path.rs\",\n+                \"is_primary\": true,\n+                \"label\": null,\n+                \"line_end\": 265,\n+                \"line_start\": 265,\n+                \"suggested_replacement\": null,\n+                \"suggestion_applicability\": null,\n+                \"text\": [\n+                    {\n+                        \"highlight_end\": 77,\n+                        \"highlight_start\": 9,\n+                        \"text\": \"        compile_error!(\\\"Please register your known path in the path module\\\")\"\n+                    }\n+                ]\n+            }\n+        ]\n+    }\n+            \"##,\n+        );\n+\n+        let workspace_root = Path::new(\"/test/\");\n+        let diag = map_rust_diagnostic_to_lsp(&diag, workspace_root);\n+        insta::assert_debug_snapshot!(diag);\n+    }\n+\n+    #[test]\n+    #[cfg(not(windows))]\n+    fn snap_multi_line_fix() {\n+        let diag = parse_diagnostic(\n+            r##\"{\n+                \"rendered\": \"warning: returning the result of a let binding from a block\\n --> src/main.rs:4:5\\n  |\\n3 |     let a = (0..10).collect();\\n  |     -------------------------- unnecessary let binding\\n4 |     a\\n  |     ^\\n  |\\n  = note: `#[warn(clippy::let_and_return)]` on by default\\n  = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#let_and_return\\nhelp: return the expression directly\\n  |\\n3 |     \\n4 |     (0..10).collect()\\n  |\\n\\n\",\n+                \"children\": [\n+                    {\n+                    \"children\": [],\n+                    \"code\": null,\n+                    \"level\": \"note\",\n+                    \"message\": \"`#[warn(clippy::let_and_return)]` on by default\",\n+                    \"rendered\": null,\n+                    \"spans\": []\n+                    },\n+                    {\n+                    \"children\": [],\n+                    \"code\": null,\n+                    \"level\": \"help\",\n+                    \"message\": \"for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#let_and_return\",\n+                    \"rendered\": null,\n+                    \"spans\": []\n+                    },\n+                    {\n+                    \"children\": [],\n+                    \"code\": null,\n+                    \"level\": \"help\",\n+                    \"message\": \"return the expression directly\",\n+                    \"rendered\": null,\n+                    \"spans\": [\n+                        {\n+                        \"byte_end\": 55,\n+                        \"byte_start\": 29,\n+                        \"column_end\": 31,\n+                        \"column_start\": 5,\n+                        \"expansion\": null,\n+                        \"file_name\": \"src/main.rs\",\n+                        \"is_primary\": true,\n+                        \"label\": null,\n+                        \"line_end\": 3,\n+                        \"line_start\": 3,\n+                        \"suggested_replacement\": \"\",\n+                        \"suggestion_applicability\": \"MachineApplicable\",\n+                        \"text\": [\n+                            {\n+                            \"highlight_end\": 31,\n+                            \"highlight_start\": 5,\n+                            \"text\": \"    let a = (0..10).collect();\"\n+                            }\n+                        ]\n+                        },\n+                        {\n+                        \"byte_end\": 61,\n+                        \"byte_start\": 60,\n+                        \"column_end\": 6,\n+                        \"column_start\": 5,\n+                        \"expansion\": null,\n+                        \"file_name\": \"src/main.rs\",\n+                        \"is_primary\": true,\n+                        \"label\": null,\n+                        \"line_end\": 4,\n+                        \"line_start\": 4,\n+                        \"suggested_replacement\": \"(0..10).collect()\",\n+                        \"suggestion_applicability\": \"MachineApplicable\",\n+                        \"text\": [\n+                            {\n+                            \"highlight_end\": 6,\n+                            \"highlight_start\": 5,\n+                            \"text\": \"    a\"\n+                            }\n+                        ]\n+                        }\n+                    ]\n+                    }\n+                ],\n+                \"code\": {\n+                    \"code\": \"clippy::let_and_return\",\n+                    \"explanation\": null\n+                },\n+                \"level\": \"warning\",\n+                \"message\": \"returning the result of a let binding from a block\",\n+                \"spans\": [\n+                    {\n+                    \"byte_end\": 55,\n+                    \"byte_start\": 29,\n+                    \"column_end\": 31,\n+                    \"column_start\": 5,\n+                    \"expansion\": null,\n+                    \"file_name\": \"src/main.rs\",\n+                    \"is_primary\": false,\n+                    \"label\": \"unnecessary let binding\",\n+                    \"line_end\": 3,\n+                    \"line_start\": 3,\n+                    \"suggested_replacement\": null,\n+                    \"suggestion_applicability\": null,\n+                    \"text\": [\n+                        {\n+                        \"highlight_end\": 31,\n+                        \"highlight_start\": 5,\n+                        \"text\": \"    let a = (0..10).collect();\"\n+                        }\n+                    ]\n+                    },\n+                    {\n+                    \"byte_end\": 61,\n+                    \"byte_start\": 60,\n+                    \"column_end\": 6,\n+                    \"column_start\": 5,\n+                    \"expansion\": null,\n+                    \"file_name\": \"src/main.rs\",\n+                    \"is_primary\": true,\n+                    \"label\": null,\n+                    \"line_end\": 4,\n+                    \"line_start\": 4,\n+                    \"suggested_replacement\": null,\n+                    \"suggestion_applicability\": null,\n+                    \"text\": [\n+                        {\n+                        \"highlight_end\": 6,\n+                        \"highlight_start\": 5,\n+                        \"text\": \"    a\"\n+                        }\n+                    ]\n+                    }\n+                ]\n+            }\n+            \"##,\n+        );\n+\n+        let workspace_root = Path::new(\"/test/\");\n+        let diag = map_rust_diagnostic_to_lsp(&diag, workspace_root);\n+        insta::assert_debug_snapshot!(diag);\n+    }\n+}"}, {"sha": "15e5bb354968ca915da2148b0c087cf266a73226", "filename": "crates/rust-analyzer/src/main_loop.rs", "status": "modified", "additions": 53, "deletions": 14, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/05db35dafb47db355e202c9176bd8a752b7390d7/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05db35dafb47db355e202c9176bd8a752b7390d7/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs?ref=05db35dafb47db355e202c9176bd8a752b7390d7", "patch": "@@ -25,7 +25,7 @@ use lsp_types::{\n     WorkDoneProgressBegin, WorkDoneProgressCreateParams, WorkDoneProgressEnd,\n     WorkDoneProgressReport,\n };\n-use ra_flycheck::{url_from_path_with_drive_lowercasing, CheckTask};\n+use ra_flycheck::{CheckTask, Status};\n use ra_ide::{Canceled, FileId, LibraryData, LineIndex, SourceRootId};\n use ra_prof::profile;\n use ra_project_model::{PackageRoot, ProjectWorkspace};\n@@ -37,7 +37,7 @@ use threadpool::ThreadPool;\n \n use crate::{\n     config::{Config, FilesWatcher},\n-    diagnostics::DiagnosticTask,\n+    diagnostics::{to_proto::url_from_path_with_drive_lowercasing, DiagnosticTask},\n     from_proto, lsp_ext,\n     main_loop::{\n         pending_requests::{PendingRequest, PendingRequests},\n@@ -736,22 +736,61 @@ fn on_check_task(\n             task_sender.send(Task::Diagnostic(DiagnosticTask::ClearCheck))?;\n         }\n \n-        CheckTask::AddDiagnostic { url, diagnostic, fixes } => {\n-            let path = url.to_file_path().map_err(|()| format!(\"invalid uri: {}\", url))?;\n-            let file_id = match world_state.vfs.read().path2file(&path) {\n-                Some(file) => FileId(file.0),\n-                None => {\n-                    log::error!(\"File with cargo diagnostic not found in VFS: {}\", path.display());\n-                    return Ok(());\n-                }\n-            };\n+        CheckTask::AddDiagnostic { workspace_root, diagnostic } => {\n+            let diagnostics = crate::diagnostics::to_proto::map_rust_diagnostic_to_lsp(\n+                &diagnostic,\n+                &workspace_root,\n+            );\n+            for diag in diagnostics {\n+                let path = diag\n+                    .location\n+                    .uri\n+                    .to_file_path()\n+                    .map_err(|()| format!(\"invalid uri: {}\", diag.location.uri))?;\n+                let file_id = match world_state.vfs.read().path2file(&path) {\n+                    Some(file) => FileId(file.0),\n+                    None => {\n+                        log::error!(\n+                            \"File with cargo diagnostic not found in VFS: {}\",\n+                            path.display()\n+                        );\n+                        return Ok(());\n+                    }\n+                };\n \n-            task_sender\n-                .send(Task::Diagnostic(DiagnosticTask::AddCheck(file_id, diagnostic, fixes)))?;\n+                task_sender.send(Task::Diagnostic(DiagnosticTask::AddCheck(\n+                    file_id,\n+                    diag.diagnostic,\n+                    diag.fixes.into_iter().map(|it| it.into()).collect(),\n+                )))?;\n+            }\n         }\n \n-        CheckTask::Status(progress) => {\n+        CheckTask::Status(status) => {\n             if world_state.config.client_caps.work_done_progress {\n+                let progress = match status {\n+                    Status::Being => {\n+                        lsp_types::WorkDoneProgress::Begin(lsp_types::WorkDoneProgressBegin {\n+                            title: \"Running `cargo check`\".to_string(),\n+                            cancellable: Some(false),\n+                            message: None,\n+                            percentage: None,\n+                        })\n+                    }\n+                    Status::Progress(target) => {\n+                        lsp_types::WorkDoneProgress::Report(lsp_types::WorkDoneProgressReport {\n+                            cancellable: Some(false),\n+                            message: Some(target),\n+                            percentage: None,\n+                        })\n+                    }\n+                    Status::End => {\n+                        lsp_types::WorkDoneProgress::End(lsp_types::WorkDoneProgressEnd {\n+                            message: None,\n+                        })\n+                    }\n+                };\n+\n                 let params = lsp_types::ProgressParams {\n                     token: lsp_types::ProgressToken::String(\n                         \"rustAnalyzer/cargoWatcher\".to_string(),"}, {"sha": "367272925be550129229b0f16d9be01f0a68758f", "filename": "crates/rust-analyzer/src/world.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/05db35dafb47db355e202c9176bd8a752b7390d7/crates%2Frust-analyzer%2Fsrc%2Fworld.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05db35dafb47db355e202c9176bd8a752b7390d7/crates%2Frust-analyzer%2Fsrc%2Fworld.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fworld.rs?ref=05db35dafb47db355e202c9176bd8a752b7390d7", "patch": "@@ -11,7 +11,7 @@ use std::{\n use crossbeam_channel::{unbounded, Receiver};\n use lsp_types::Url;\n use parking_lot::RwLock;\n-use ra_flycheck::{url_from_path_with_drive_lowercasing, Flycheck, FlycheckConfig};\n+use ra_flycheck::{Flycheck, FlycheckConfig};\n use ra_ide::{\n     Analysis, AnalysisChange, AnalysisHost, CrateGraph, FileId, LibraryData, SourceRootId,\n };\n@@ -22,7 +22,9 @@ use stdx::format_to;\n \n use crate::{\n     config::Config,\n-    diagnostics::{CheckFixes, DiagnosticCollection},\n+    diagnostics::{\n+        to_proto::url_from_path_with_drive_lowercasing, CheckFixes, DiagnosticCollection,\n+    },\n     main_loop::pending_requests::{CompletedRequest, LatestRequests},\n     vfs_glob::{Glob, RustPackageFilterBuilder},\n     LspError, Result,"}]}