{"sha": "aa01876c95a3f50ef6129f1501d97c7a6bb0e856", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFhMDE4NzZjOTVhM2Y1MGVmNjEyOWYxNTAxZDk3YzdhNmJiMGU4NTY=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-11-01T13:38:55Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-11-01T13:38:55Z"}, "message": "Flesh out the module section of the tutorial", "tree": {"sha": "2e2336aee2bf21a4ba72814eb04027a2fa6d2120", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2e2336aee2bf21a4ba72814eb04027a2fa6d2120"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/aa01876c95a3f50ef6129f1501d97c7a6bb0e856", "comment_count": 3, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/aa01876c95a3f50ef6129f1501d97c7a6bb0e856", "html_url": "https://github.com/rust-lang/rust/commit/aa01876c95a3f50ef6129f1501d97c7a6bb0e856", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/aa01876c95a3f50ef6129f1501d97c7a6bb0e856/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e8e2cd44f48a6edcdd4477ab66f0fc5935ecd1a1", "url": "https://api.github.com/repos/rust-lang/rust/commits/e8e2cd44f48a6edcdd4477ab66f0fc5935ecd1a1", "html_url": "https://github.com/rust-lang/rust/commit/e8e2cd44f48a6edcdd4477ab66f0fc5935ecd1a1"}], "stats": {"total": 269, "additions": 268, "deletions": 1}, "files": [{"sha": "1b000bb7298d728b0a2a4eef4a2e648c2965e003", "filename": "doc/tutorial/ffi.md", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/aa01876c95a3f50ef6129f1501d97c7a6bb0e856/doc%2Ftutorial%2Fffi.md", "raw_url": "https://github.com/rust-lang/rust/raw/aa01876c95a3f50ef6129f1501d97c7a6bb0e856/doc%2Ftutorial%2Fffi.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial%2Fffi.md?ref=aa01876c95a3f50ef6129f1501d97c7a6bb0e856", "patch": "@@ -0,0 +1,3 @@\n+# Interacting with foreign code\n+\n+FIXME to be written"}, {"sha": "b2defa836b6f34d761a0ace02cf58c37912ef0a8", "filename": "doc/tutorial/index.md", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aa01876c95a3f50ef6129f1501d97c7a6bb0e856/doc%2Ftutorial%2Findex.md", "raw_url": "https://github.com/rust-lang/rust/raw/aa01876c95a3f50ef6129f1501d97c7a6bb0e856/doc%2Ftutorial%2Findex.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial%2Findex.md?ref=aa01876c95a3f50ef6129f1501d97c7a6bb0e856", "patch": "@@ -1 +1,3 @@\n # Rust language tutorial\n+\n+<div style=\"font-weight: bold; color: #a00;\">Dev snapshot. Not yet suitable for public consumption.</div>"}, {"sha": "7f59fa861f86b6d8891948d15aa8178d98b4757d", "filename": "doc/tutorial/intro.md", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/aa01876c95a3f50ef6129f1501d97c7a6bb0e856/doc%2Ftutorial%2Fintro.md", "raw_url": "https://github.com/rust-lang/rust/raw/aa01876c95a3f50ef6129f1501d97c7a6bb0e856/doc%2Ftutorial%2Fintro.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial%2Fintro.md?ref=aa01876c95a3f50ef6129f1501d97c7a6bb0e856", "patch": "@@ -46,3 +46,14 @@ function, `ret` for return.\n You should, however, not conclude that Rust is simply an evolution of\n C. As will become clear in the rest of this tutorial, it goes into\n quite a different direction.\n+\n+## Conventions\n+\n+Throughout the tutorial, words that indicate language keywords or\n+identifiers defined in the example code are displayed in `code font`.\n+\n+Code snippets are indented, and also shown in a monospace font. Not\n+all snippets constitute whole programs. For brevity, we'll often show\n+fragments of programs that don't compile on their own. To try them\n+out, you'll have to wrap them in `fn main() { ... }`, and make sure\n+they don't contain references to things that aren't actually defined."}, {"sha": "352b51c1db51d82fbf92bf6151c9a0432593505b", "filename": "doc/tutorial/mod.md", "status": "modified", "additions": 222, "deletions": 1, "changes": 223, "blob_url": "https://github.com/rust-lang/rust/blob/aa01876c95a3f50ef6129f1501d97c7a6bb0e856/doc%2Ftutorial%2Fmod.md", "raw_url": "https://github.com/rust-lang/rust/raw/aa01876c95a3f50ef6129f1501d97c7a6bb0e856/doc%2Ftutorial%2Fmod.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial%2Fmod.md?ref=aa01876c95a3f50ef6129f1501d97c7a6bb0e856", "patch": "@@ -1,3 +1,224 @@\n # Modules and crates\n \n-FIXME include name resolution details\n+The Rust namespace is divided in modules. Each source file starts with\n+its own, empty module.\n+\n+## Local modules\n+\n+The `mod` keyword can be used to open a new, local module. In the\n+example below, `chicken` lives in the module `farm`, so, unless you\n+explicitly import it, you must refer to it by its long name,\n+`farm::chicken`.\n+\n+    mod farm {\n+        fn chicken() -> str { \"cluck cluck\" }\n+        fn cow() -> str { \"mooo\" }\n+    }\n+    fn main() {\n+        log_err farm::chicken();\n+    }\n+\n+Modules can be nested to arbitrary depth.\n+\n+## Crates\n+\n+The unit of independent compilation in Rust is the crate. Libraries\n+tend to be packaged as crates, and your own programs may consist of\n+one or more crates.\n+\n+When compiling a single `.rs` file, the file acts as the whole crate.\n+You can compile it with the `--lib` compiler switch to create a shared\n+library, or without, provided that your file contains a `fn main`\n+somewhere, to create an executable.\n+\n+It is also possible to include multiple files in a crate. For this\n+purpose, you create a `.rc` crate file, which references any number of\n+`.rs` code files. A crate file could look like this:\n+\n+    #[link(name = \"farm\", vers = \"2.5\", author = \"mjh\")]\n+    mod cow;\n+    mod chicken;\n+    mod horse;\n+\n+Compiling this file will cause `rustc` to look for files named\n+`cow.rs`, `chicken.rs`, `horse.rs` in the same directory as the `.rc`\n+file, compile them all together, and, depending on the presence of the\n+`--lib` switch, output a shared library or an executable.\n+\n+The `#[link(...)]` part provides meta information about the module,\n+which other crates can use to load the right module. More about that\n+in a moment.\n+\n+To have a nested directory structure for your source files, you can\n+nest mods in your `.rc` file:\n+\n+    mod poultry {\n+        mod chicken;\n+        mod turkey;\n+    }\n+\n+The compiler will now look for `poultry/chicken.rs` and\n+`poultry/turkey.rs`, and export their content in `poultry::chicken`\n+and `poultry::turkey`. You can also provide a `poultry.rs` to add\n+content to the `poultry` module itself.\n+\n+## Using other crates\n+\n+Having compiled a crate with `--lib`, you can use it in another crate\n+with a `use` directive. We've already seen `use std` in several of the\n+examples, which loads in the standard library.\n+\n+`use` directives can appear in a crate file, or at the top level of a\n+single-file `.rs` crate. They will cause the compiler to search its\n+library search path (which you can extend with `-L` switch) for a Rust\n+crate library with the right name. This name is deduced from the crate\n+name in a platform-dependent way. The `farm` library will be called\n+`farm.dll` on Windows, `libfarm.so` on Linux, and `libfarm.dylib` on\n+OS X.\n+\n+It is possible to provide more specific information when using an\n+external crate.\n+\n+    use myfarm (name = \"farm\", vers = \"2.7\");\n+\n+When a comma-separated list of name/value pairs is given after `use`,\n+these are matched against the attributes provided in the `link`\n+attribute of the crate file, and a crate is only used when the two\n+match. A `name` value can be given to override the name used to search\n+for the crate. So the above would import the `farm` crate under the\n+local name `myfarm`.\n+\n+Our example crate declared this set of `link` attributes:\n+\n+    #[link(name = \"farm\", vers = \"2.5\", author = \"mjh\")]\n+\n+The version does not match the one provided in the `use` directive, so\n+unless the compiler can find another crate with the right version\n+somewhere, it will complain that no matching crate was found.\n+\n+## A minimal example\n+\n+Now for something that you can actually compile yourself. We have\n+these two files:\n+\n+    // mylib.rs\n+    fn world() -> str { \"world\" }\n+\n+    // main.rs\n+    use mylib;\n+    fn main() { log_err \"hello \" + mylib::world(); }\n+\n+FIXME the compiler currently complains about missing link metas when you compile this\n+\n+Now compile and run like this (adjust to your platform if necessary):\n+\n+    > rustc --lib mylib.rs\n+    > rustc main.rs -L .\n+    > ./main\n+    \"hello world\"\n+\n+## Importing\n+\n+When using identifiers from other modules, it can get tiresome to\n+qualify them with the full module path every time (especially when\n+that path is several modules deep). Rust allows you to import\n+identifiers at the top of a file or module.\n+\n+    use std;\n+    import std::io::println;\n+    fn main() {\n+        println(\"that was easy\");\n+    }\n+\n+It is also possible to import just the name of a module (`import\n+std::io;`, then use `io::println`), import all identifiers exported by\n+a given module (`import std::io::*`), or to import a specific set of\n+identifiers (`import std::math::{min, max, pi}`).\n+\n+It is also possible to rename an identifier when importing, using the\n+`=` operator:\n+\n+    import prnt = std::io::println;\n+\n+## Exporting\n+\n+By default, a module exports everything that it defines. This can be\n+restricted with `export` directives at the top of the module or file.\n+\n+    mod enc {\n+        export encrypt, decrypt;\n+        const super_secret_number: int = 10;\n+        fn encrypt(n: int) { n + super_secret_number }\n+        fn decrypt(n: int) { n - super_secret_number }\n+    }\n+\n+This defines a rock-solid encryption algorithm. Code outside of the\n+module can refer to the `enc::encrypt` and `enc::decrypt` identifiers\n+just fine, but it does not have access to `enc::syper_secret_number`.\n+\n+## Namespaces\n+\n+Rust uses three different namespaces. One for modules, one for types,\n+and one for values. This means that this code is valid:\n+\n+    mod buffalo {\n+        type buffalo = int;\n+        fn buffalo(buffalo: buffalo) -> buffalo { buffalo }\n+    }\n+    fn main() {\n+        let buffalo: buffalo::buffalo = 1;\n+        buffalo::buffalo(buffalo::buffalo(buffalo));\n+    }\n+\n+You don't want to write things like that, but it *is* very practical\n+to not have to worry about name clashes between types, values, and\n+modules. This allows us to have a module `std::str`, for example, even\n+though `str` is a built-in type name.\n+\n+## Resolution\n+\n+The resolution process in Rust simply goes up the chain of contexts,\n+looking for the name in each context. Nested functions and modules\n+create new contexts inside their parent function or module. A file\n+that's part of a bigger crate will have that crate's context as parent\n+context.\n+\n+Identifiers can shadow each others. In this program, `x` is of type\n+`int`:\n+\n+    type x = str;\n+    fn main() {\n+        type x = int;\n+        let x: int;\n+    }\n+\n+An `import` directive will only import into the namespaces for which\n+identifiers are actually found. Consider this example:\n+\n+    type bar = uint;\n+    mod foo { fn bar() {} }\n+    mod baz {\n+        import foo::bar;\n+        const x: bar = 20u;\n+    }\n+\n+When resolving the type name `bar` in the `const` definition, the\n+resolver will first look at the module context for `baz`. This has an\n+import named `bar`, but that's a function, not a type, So it continues\n+to the top level and finds a type named `bar` defined there.\n+\n+Normally, multiple definitions of the same identifier in a scope are\n+disallowed. Local variables defined with `let` are an exception to\n+this\u2014multiple `let` directives can redefine the same variable in a\n+single scope. When resolving the name of such a variable, the most\n+recent definition is used.\n+\n+    fn main() {\n+        let x = 10;\n+        let x = x + 10;\n+        assert x == 20;\n+    }\n+\n+This makes it possible to rebind a variable without actually mutating\n+it, which is mostly useful for destructuring (which can rebind, but\n+not assign)."}, {"sha": "d7ed3605db71ca117ae3d77f696bf279991b312d", "filename": "doc/tutorial/order", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aa01876c95a3f50ef6129f1501d97c7a6bb0e856/doc%2Ftutorial%2Forder", "raw_url": "https://github.com/rust-lang/rust/raw/aa01876c95a3f50ef6129f1501d97c7a6bb0e856/doc%2Ftutorial%2Forder", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial%2Forder?ref=aa01876c95a3f50ef6129f1501d97c7a6bb0e856", "patch": "@@ -7,3 +7,5 @@ data\n args\n generic\n mod\n+ffi\n+task"}, {"sha": "8c6a54f50d4fb0927bc788bc5a7af6bcdb16eaa6", "filename": "doc/tutorial/syntax.md", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/aa01876c95a3f50ef6129f1501d97c7a6bb0e856/doc%2Ftutorial%2Fsyntax.md", "raw_url": "https://github.com/rust-lang/rust/raw/aa01876c95a3f50ef6129f1501d97c7a6bb0e856/doc%2Ftutorial%2Fsyntax.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial%2Fsyntax.md?ref=aa01876c95a3f50ef6129f1501d97c7a6bb0e856", "patch": "@@ -86,6 +86,27 @@ The double-colon (`::`) is used as a module separator, so\n `std::io::println` means 'the thing named `println` in the module\n named `io` in the module named `std`'.\n \n+Rust will normally emit warning about unused variables. These can be\n+suppressed by using a variable name that starts with an underscore.\n+\n+    fn this_warns(x: int) {}\n+    fn this_doesnt(_x: int) {}\n+\n+## Variable declaration\n+\n+The `let` keyword, as we've seen, introduces a local variable. Global\n+constants can be defined with `const`:\n+\n+    import std;\n+    const repeat: uint = 5u;\n+    fn main() {\n+        let count = 0u;\n+        while count < repeat {\n+            std::io::println(\"Hi!\");\n+            count += 1u;\n+        }\n+    }\n+\n ## Types\n \n The `-> bool` in the last example is the way a function's return type\n@@ -256,3 +277,7 @@ exists, convert the result of the expression to the given type.\n     let x: float = 4.0;\n     let y: uint = x as uint;\n     assert y == 4u;\n+\n+## Attributes\n+\n+FIXME Briefly introduce attributes"}, {"sha": "50a7ad193ece50069cf6edd78a5735629e7b7ed1", "filename": "doc/tutorial/task.md", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/aa01876c95a3f50ef6129f1501d97c7a6bb0e856/doc%2Ftutorial%2Ftask.md", "raw_url": "https://github.com/rust-lang/rust/raw/aa01876c95a3f50ef6129f1501d97c7a6bb0e856/doc%2Ftutorial%2Ftask.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial%2Ftask.md?ref=aa01876c95a3f50ef6129f1501d97c7a6bb0e856", "patch": "@@ -0,0 +1,3 @@\n+# Tasks\n+\n+FIXME to be written"}]}