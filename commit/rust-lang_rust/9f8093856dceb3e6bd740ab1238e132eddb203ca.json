{"sha": "9f8093856dceb3e6bd740ab1238e132eddb203ca", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlmODA5Mzg1NmRjZWIzZTZiZDc0MGFiMTIzOGUxMzJlZGRiMjAzY2E=", "commit": {"author": {"name": "Scott A Carr", "email": "s.carr1024@gmail.com", "date": "2016-08-08T20:35:10Z"}, "committer": {"name": "Scott A Carr", "email": "s.carr1024@gmail.com", "date": "2016-08-08T20:35:10Z"}, "message": "refactor other type methods", "tree": {"sha": "76627dba9d276516dacb5ee7f44ce27cfde902de", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/76627dba9d276516dacb5ee7f44ce27cfde902de"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9f8093856dceb3e6bd740ab1238e132eddb203ca", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9f8093856dceb3e6bd740ab1238e132eddb203ca", "html_url": "https://github.com/rust-lang/rust/commit/9f8093856dceb3e6bd740ab1238e132eddb203ca", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9f8093856dceb3e6bd740ab1238e132eddb203ca/comments", "author": {"login": "scottcarr", "id": 472477, "node_id": "MDQ6VXNlcjQ3MjQ3Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/472477?v=4", "gravatar_id": "", "url": "https://api.github.com/users/scottcarr", "html_url": "https://github.com/scottcarr", "followers_url": "https://api.github.com/users/scottcarr/followers", "following_url": "https://api.github.com/users/scottcarr/following{/other_user}", "gists_url": "https://api.github.com/users/scottcarr/gists{/gist_id}", "starred_url": "https://api.github.com/users/scottcarr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/scottcarr/subscriptions", "organizations_url": "https://api.github.com/users/scottcarr/orgs", "repos_url": "https://api.github.com/users/scottcarr/repos", "events_url": "https://api.github.com/users/scottcarr/events{/privacy}", "received_events_url": "https://api.github.com/users/scottcarr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "scottcarr", "id": 472477, "node_id": "MDQ6VXNlcjQ3MjQ3Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/472477?v=4", "gravatar_id": "", "url": "https://api.github.com/users/scottcarr", "html_url": "https://github.com/scottcarr", "followers_url": "https://api.github.com/users/scottcarr/followers", "following_url": "https://api.github.com/users/scottcarr/following{/other_user}", "gists_url": "https://api.github.com/users/scottcarr/gists{/gist_id}", "starred_url": "https://api.github.com/users/scottcarr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/scottcarr/subscriptions", "organizations_url": "https://api.github.com/users/scottcarr/orgs", "repos_url": "https://api.github.com/users/scottcarr/repos", "events_url": "https://api.github.com/users/scottcarr/events{/privacy}", "received_events_url": "https://api.github.com/users/scottcarr/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "28abc0a6aad5e282dd69193b3fec64fd2fef1348", "url": "https://api.github.com/repos/rust-lang/rust/commits/28abc0a6aad5e282dd69193b3fec64fd2fef1348", "html_url": "https://github.com/rust-lang/rust/commit/28abc0a6aad5e282dd69193b3fec64fd2fef1348"}], "stats": {"total": 204, "additions": 99, "deletions": 105}, "files": [{"sha": "93507246241de62bde905a68e9fde7acc47e7c47", "filename": "src/librustc/mir/repr.rs", "status": "modified", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/9f8093856dceb3e6bd740ab1238e132eddb203ca/src%2Flibrustc%2Fmir%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f8093856dceb3e6bd740ab1238e132eddb203ca/src%2Flibrustc%2Fmir%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Frepr.rs?ref=9f8093856dceb3e6bd740ab1238e132eddb203ca", "patch": "@@ -32,8 +32,6 @@ use syntax::ast::{self, Name};\n use syntax_pos::Span;\n \n use super::cache::Cache;\n-use super::super::ty::TyCtxt;\n-use super::tcx::LvalueTy;\n \n macro_rules! newtype_index {\n     ($name:ident, $debug_name:expr) => (\n@@ -811,29 +809,8 @@ impl<'tcx> Lvalue<'tcx> {\n             elem: elem,\n         }))\n     }\n-\n-    pub fn ty<'a, 'gcx>(&self, mir: &Mir<'tcx>, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> LvalueTy<'tcx>\n-    {\n-        match self {\n-            &Lvalue::Var(index) =>\n-                LvalueTy::Ty { ty: mir.var_decls[index].ty },\n-            &Lvalue::Temp(index) =>\n-                LvalueTy::Ty { ty: mir.temp_decls[index].ty },\n-            &Lvalue::Arg(index) =>\n-                LvalueTy::Ty { ty: mir.arg_decls[index].ty },\n-            &Lvalue::Static(def_id) =>\n-                LvalueTy::Ty { ty: tcx.lookup_item_type(def_id).ty },\n-            &Lvalue::ReturnPointer =>\n-                LvalueTy::Ty { ty: mir.return_ty.unwrap() },\n-            &Lvalue::Projection(ref proj) =>\n-                proj.base.ty(mir, tcx).projection_ty(tcx, &proj.elem),\n-        }\n-    }\n }\n \n-\n-\n-\n impl<'tcx> Debug for Lvalue<'tcx> {\n     fn fmt(&self, fmt: &mut Formatter) -> fmt::Result {\n         use self::Lvalue::*;"}, {"sha": "2c60d82997fa4d122f83b13398e91cc49b219b0b", "filename": "src/librustc/mir/tcx.rs", "status": "modified", "additions": 75, "deletions": 58, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/9f8093856dceb3e6bd740ab1238e132eddb203ca/src%2Flibrustc%2Fmir%2Ftcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f8093856dceb3e6bd740ab1238e132eddb203ca/src%2Flibrustc%2Fmir%2Ftcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Ftcx.rs?ref=9f8093856dceb3e6bd740ab1238e132eddb203ca", "patch": "@@ -113,55 +113,38 @@ impl<'tcx> TypeFoldable<'tcx> for LvalueTy<'tcx> {\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> Mir<'tcx> {\n-    pub fn operand_ty(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                      operand: &Operand<'tcx>)\n-                      -> Ty<'tcx>\n-    {\n-        match *operand {\n-            Operand::Consume(ref l) => l.ty(self, tcx).to_ty(tcx),\n-            Operand::Constant(ref c) => c.ty,\n-        }\n-    }\n-\n-    pub fn binop_ty(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                    op: BinOp,\n-                    lhs_ty: Ty<'tcx>,\n-                    rhs_ty: Ty<'tcx>)\n-                    -> Ty<'tcx>\n-    {\n-        // FIXME: handle SIMD correctly\n-        match op {\n-            BinOp::Add | BinOp::Sub | BinOp::Mul | BinOp::Div | BinOp::Rem |\n-            BinOp::BitXor | BinOp::BitAnd | BinOp::BitOr => {\n-                // these should be integers or floats of the same size.\n-                assert_eq!(lhs_ty, rhs_ty);\n-                lhs_ty\n-            }\n-            BinOp::Shl | BinOp::Shr => {\n-                lhs_ty // lhs_ty can be != rhs_ty\n-            }\n-            BinOp::Eq | BinOp::Lt | BinOp::Le |\n-            BinOp::Ne | BinOp::Ge | BinOp::Gt => {\n-                tcx.types.bool\n-            }\n+impl<'tcx> Lvalue<'tcx> {\n+    pub fn ty<'a, 'gcx>(&self, mir: &Mir<'tcx>, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> LvalueTy<'tcx> {\n+        match self {\n+            &Lvalue::Var(index) =>\n+                LvalueTy::Ty { ty: mir.var_decls[index].ty },\n+            &Lvalue::Temp(index) =>\n+                LvalueTy::Ty { ty: mir.temp_decls[index].ty },\n+            &Lvalue::Arg(index) =>\n+                LvalueTy::Ty { ty: mir.arg_decls[index].ty },\n+            &Lvalue::Static(def_id) =>\n+                LvalueTy::Ty { ty: tcx.lookup_item_type(def_id).ty },\n+            &Lvalue::ReturnPointer =>\n+                LvalueTy::Ty { ty: mir.return_ty.unwrap() },\n+            &Lvalue::Projection(ref proj) =>\n+                proj.base.ty(mir, tcx).projection_ty(tcx, &proj.elem),\n         }\n     }\n+}\n \n-    pub fn rvalue_ty(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                     rvalue: &Rvalue<'tcx>)\n-                     -> Option<Ty<'tcx>>\n+impl<'tcx> Rvalue<'tcx> {\n+    pub fn ty<'a, 'gcx>(&self, mir: &Mir<'tcx>, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Option<Ty<'tcx>> \n     {\n-        match *rvalue {\n-            Rvalue::Use(ref operand) => Some(self.operand_ty(tcx, operand)),\n-            Rvalue::Repeat(ref operand, ref count) => {\n-                let op_ty = self.operand_ty(tcx, operand);\n+        match self {\n+            &Rvalue::Use(ref operand) => Some(operand.ty(mir, tcx)),\n+            &Rvalue::Repeat(ref operand, ref count) => {\n+                let op_ty = operand.ty(mir, tcx);\n                 let count = count.value.as_u64(tcx.sess.target.uint_type);\n                 assert_eq!(count as usize as u64, count);\n                 Some(tcx.mk_array(op_ty, count as usize))\n             }\n-            Rvalue::Ref(reg, bk, ref lv) => {\n-                let lv_ty = lv.ty(self, tcx).to_ty(tcx);\n+            &Rvalue::Ref(reg, bk, ref lv) => {\n+                let lv_ty = lv.ty(mir, tcx).to_ty(tcx);\n                 Some(tcx.mk_ref(\n                     tcx.mk_region(reg),\n                     ty::TypeAndMut {\n@@ -170,39 +153,39 @@ impl<'a, 'gcx, 'tcx> Mir<'tcx> {\n                     }\n                 ))\n             }\n-            Rvalue::Len(..) => Some(tcx.types.usize),\n-            Rvalue::Cast(_, _, ty) => Some(ty),\n-            Rvalue::BinaryOp(op, ref lhs, ref rhs) => {\n-                let lhs_ty = self.operand_ty(tcx, lhs);\n-                let rhs_ty = self.operand_ty(tcx, rhs);\n-                Some(self.binop_ty(tcx, op, lhs_ty, rhs_ty))\n+            &Rvalue::Len(..) => Some(tcx.types.usize),\n+            &Rvalue::Cast(_, _, ty) => Some(ty),\n+            &Rvalue::BinaryOp(op, ref lhs, ref rhs) => {\n+                let lhs_ty = lhs.ty(mir, tcx);\n+                let rhs_ty = rhs.ty(mir, tcx);\n+                Some(op.ty(tcx, lhs_ty, rhs_ty))\n             }\n-            Rvalue::CheckedBinaryOp(op, ref lhs, ref rhs) => {\n-                let lhs_ty = self.operand_ty(tcx, lhs);\n-                let rhs_ty = self.operand_ty(tcx, rhs);\n-                let ty = self.binop_ty(tcx, op, lhs_ty, rhs_ty);\n+            &Rvalue::CheckedBinaryOp(op, ref lhs, ref rhs) => {\n+                let lhs_ty = lhs.ty(mir, tcx);\n+                let rhs_ty = rhs.ty(mir, tcx);\n+                let ty = op.ty(tcx, lhs_ty, rhs_ty);\n                 let ty = tcx.mk_tup(vec![ty, tcx.types.bool]);\n                 Some(ty)\n             }\n-            Rvalue::UnaryOp(_, ref operand) => {\n-                Some(self.operand_ty(tcx, operand))\n+            &Rvalue::UnaryOp(_, ref operand) => {\n+                Some(operand.ty(mir, tcx))\n             }\n-            Rvalue::Box(t) => {\n+            &Rvalue::Box(t) => {\n                 Some(tcx.mk_box(t))\n             }\n-            Rvalue::Aggregate(ref ak, ref ops) => {\n+            &Rvalue::Aggregate(ref ak, ref ops) => {\n                 match *ak {\n                     AggregateKind::Vec => {\n                         if let Some(operand) = ops.get(0) {\n-                            let ty = self.operand_ty(tcx, operand);\n+                            let ty = operand.ty(mir, tcx);\n                             Some(tcx.mk_array(ty, ops.len()))\n                         } else {\n                             None\n                         }\n                     }\n                     AggregateKind::Tuple => {\n                         Some(tcx.mk_tup(\n-                            ops.iter().map(|op| self.operand_ty(tcx, op)).collect()\n+                            ops.iter().map(|op| op.ty(mir, tcx)).collect()\n                         ))\n                     }\n                     AggregateKind::Adt(def, _, substs) => {\n@@ -213,11 +196,45 @@ impl<'a, 'gcx, 'tcx> Mir<'tcx> {\n                     }\n                 }\n             }\n-            Rvalue::InlineAsm { .. } => None\n+            &Rvalue::InlineAsm { .. } => None\n         }\n     }\n }\n \n+impl<'tcx> Operand<'tcx> {\n+    pub fn ty<'a, 'gcx>(&self, mir: &Mir<'tcx>, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Ty<'tcx> {\n+        match self {\n+            &Operand::Consume(ref l) => l.ty(mir, tcx).to_ty(tcx),\n+            &Operand::Constant(ref c) => c.ty,\n+        }\n+    }    \n+}\n+\n+impl<'tcx> BinOp {\n+      pub fn ty<'a, 'gcx>(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+                    lhs_ty: Ty<'tcx>,\n+                    rhs_ty: Ty<'tcx>)\n+                    -> Ty<'tcx>\n+    {\n+        // FIXME: handle SIMD correctly\n+        match self {\n+            &BinOp::Add | &BinOp::Sub | &BinOp::Mul | &BinOp::Div | &BinOp::Rem |\n+            &BinOp::BitXor | &BinOp::BitAnd | &BinOp::BitOr => {\n+                // these should be integers or floats of the same size.\n+                assert_eq!(lhs_ty, rhs_ty);\n+                lhs_ty\n+            }\n+            &BinOp::Shl | &BinOp::Shr => {\n+                lhs_ty // lhs_ty can be != rhs_ty\n+            }\n+            &BinOp::Eq | &BinOp::Lt | &BinOp::Le |\n+            &BinOp::Ne | &BinOp::Ge | &BinOp::Gt => {\n+                tcx.types.bool\n+            }\n+        }\n+    }  \n+}\n+\n impl BorrowKind {\n     pub fn to_mutbl_lossy(self) -> hir::Mutability {\n         match self {"}, {"sha": "fa3490cbcf3384f920426c867fc03584dbae7d31", "filename": "src/librustc_mir/transform/promote_consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f8093856dceb3e6bd740ab1238e132eddb203ca/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f8093856dceb3e6bd740ab1238e132eddb203ca/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs?ref=9f8093856dceb3e6bd740ab1238e132eddb203ca", "patch": "@@ -353,7 +353,7 @@ pub fn promote_candidates<'a, 'tcx>(mir: &mut Mir<'tcx>,\n                 let terminator = mir[bb].terminator();\n                 let ty = match terminator.kind {\n                     TerminatorKind::Call { ref args, .. } => {\n-                        mir.operand_ty(tcx, &args[2])\n+                        args[2].ty(mir, tcx)\n                     }\n                     _ => {\n                         span_bug!(terminator.source_info.span,"}, {"sha": "8afe7ef78ee94f0a6aab6c994ad7d94242b26954", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9f8093856dceb3e6bd740ab1238e132eddb203ca/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f8093856dceb3e6bd740ab1238e132eddb203ca/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=9f8093856dceb3e6bd740ab1238e132eddb203ca", "patch": "@@ -649,7 +649,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n             }\n \n             Rvalue::Cast(CastKind::Misc, ref operand, cast_ty) => {\n-                let operand_ty = self.mir.operand_ty(self.tcx, operand);\n+                let operand_ty = operand.ty(self.mir, self.tcx);\n                 let cast_in = CastTy::from_ty(operand_ty).expect(\"bad input type for cast\");\n                 let cast_out = CastTy::from_ty(cast_ty).expect(\"bad output type for cast\");\n                 match (cast_in, cast_out) {\n@@ -667,7 +667,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n             }\n \n             Rvalue::BinaryOp(op, ref lhs, _) => {\n-                if let ty::TyRawPtr(_) = self.mir.operand_ty(self.tcx, lhs).sty {\n+                if let ty::TyRawPtr(_) = lhs.ty(self.mir, self.tcx).sty {\n                     assert!(op == BinOp::Eq || op == BinOp::Ne ||\n                             op == BinOp::Le || op == BinOp::Lt ||\n                             op == BinOp::Ge || op == BinOp::Gt);\n@@ -697,7 +697,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n                     }\n \n                     if Some(def.did) == self.tcx.lang_items.unsafe_cell_type() {\n-                        let ty = self.mir.rvalue_ty(self.tcx, rvalue).unwrap();\n+                        let ty = rvalue.ty(self.mir, self.tcx).unwrap();\n                         self.add_type(ty);\n                         assert!(self.qualif.intersects(Qualif::MUTABLE_INTERIOR));\n                         // Even if the value inside may not need dropping,\n@@ -719,7 +719,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n         if let TerminatorKind::Call { ref func, ref args, ref destination, .. } = *kind {\n             self.visit_operand(func);\n \n-            let fn_ty = self.mir.operand_ty(self.tcx, func);\n+            let fn_ty = func.ty(self.mir, self.tcx);\n             let (is_shuffle, is_const_fn) = match fn_ty.sty {\n                 ty::TyFnDef(def_id, _, f) => {\n                     (f.abi == Abi::PlatformIntrinsic &&"}, {"sha": "246096b583627c45becaf910b02c1dc8165cf2ba", "filename": "src/librustc_mir/transform/type_check.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/9f8093856dceb3e6bd740ab1238e132eddb203ca/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f8093856dceb3e6bd740ab1238e132eddb203ca/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs?ref=9f8093856dceb3e6bd740ab1238e132eddb203ca", "patch": "@@ -81,7 +81,7 @@ impl<'a, 'b, 'gcx, 'tcx> Visitor<'tcx> for TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n \n     fn visit_rvalue(&mut self, rvalue: &Rvalue<'tcx>) {\n         self.super_rvalue(rvalue);\n-        if let Some(ty) = self.mir.rvalue_ty(self.tcx(), rvalue) {\n+        if let Some(ty) = rvalue.ty(self.mir, self.tcx()) {\n             self.sanitize_type(rvalue, ty);\n         }\n     }\n@@ -180,7 +180,7 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n             }\n             ProjectionElem::Index(ref i) => {\n                 self.visit_operand(i);\n-                let index_ty = self.mir.operand_ty(tcx, i);\n+                let index_ty = i.ty(self.mir, tcx);\n                 if index_ty != tcx.types.usize {\n                     LvalueTy::Ty {\n                         ty: span_mirbug_and_err!(self, i, \"index by non-usize {:?}\", i)\n@@ -356,7 +356,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         match stmt.kind {\n             StatementKind::Assign(ref lv, ref rv) => {\n                 let lv_ty = lv.ty(mir, tcx).to_ty(tcx);\n-                let rv_ty = mir.rvalue_ty(tcx, rv);\n+                let rv_ty = rv.ty(mir, tcx);\n                 if let Some(rv_ty) = rv_ty {\n                     if let Err(terr) = self.sub_types(self.last_span, rv_ty, lv_ty) {\n                         span_mirbug!(self, stmt, \"bad assignment ({:?} = {:?}): {:?}\",\n@@ -391,15 +391,15 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                 ..\n             } => {\n                 let lv_ty = location.ty(mir, tcx).to_ty(tcx);\n-                let rv_ty = mir.operand_ty(tcx, value);\n+                let rv_ty = value.ty(mir, tcx);\n                 if let Err(terr) = self.sub_types(self.last_span, rv_ty, lv_ty) {\n                     span_mirbug!(self, term, \"bad DropAndReplace ({:?} = {:?}): {:?}\",\n                                  lv_ty, rv_ty, terr);\n                 }\n             }\n \n             TerminatorKind::If { ref cond, .. } => {\n-                let cond_ty = mir.operand_ty(tcx, cond);\n+                let cond_ty = cond.ty(mir, tcx);\n                 match cond_ty.sty {\n                     ty::TyBool => {}\n                     _ => {\n@@ -433,7 +433,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                 }\n             }\n             TerminatorKind::Call { ref func, ref args, ref destination, .. } => {\n-                let func_ty = mir.operand_ty(tcx, func);\n+                let func_ty = func.ty(mir, tcx);\n                 debug!(\"check_terminator: call, func_ty={:?}\", func_ty);\n                 let func_ty = match func_ty.sty {\n                     ty::TyFnDef(_, _, func_ty) | ty::TyFnPtr(func_ty) => func_ty,\n@@ -453,16 +453,16 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                 }\n             }\n             TerminatorKind::Assert { ref cond, ref msg, .. } => {\n-                let cond_ty = mir.operand_ty(tcx, cond);\n+                let cond_ty = cond.ty(mir, tcx);\n                 if cond_ty != tcx.types.bool {\n                     span_mirbug!(self, term, \"bad Assert ({:?}, not bool\", cond_ty);\n                 }\n \n                 if let AssertMessage::BoundsCheck { ref len, ref index } = *msg {\n-                    if mir.operand_ty(tcx, len) != tcx.types.usize {\n+                    if len.ty(mir, tcx) != tcx.types.usize {\n                         span_mirbug!(self, len, \"bounds-check length non-usize {:?}\", len)\n                     }\n-                    if mir.operand_ty(tcx, index) != tcx.types.usize {\n+                    if index.ty(mir, tcx) != tcx.types.usize {\n                         span_mirbug!(self, index, \"bounds-check index non-usize {:?}\", index)\n                     }\n                 }\n@@ -507,7 +507,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n             span_mirbug!(self, term, \"call to {:?} with wrong # of args\", sig);\n         }\n         for (n, (fn_arg, op_arg)) in sig.inputs.iter().zip(args).enumerate() {\n-            let op_arg_ty = mir.operand_ty(self.tcx(), op_arg);\n+            let op_arg_ty = op_arg.ty(mir, self.tcx());\n             if let Err(terr) = self.sub_types(self.last_span, op_arg_ty, fn_arg) {\n                 span_mirbug!(self, term, \"bad arg #{:?} ({:?} <- {:?}): {:?}\",\n                              n, fn_arg, op_arg_ty, terr);\n@@ -554,7 +554,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n             return;\n         }\n \n-        let arg_ty = match mir.operand_ty(self.tcx(), &args[0]).sty {\n+        let arg_ty = match args[0].ty(mir, self.tcx()).sty {\n             ty::TyRawPtr(mt) => mt.ty,\n             ty::TyBox(ty) => ty,\n             _ => {"}, {"sha": "58b49f6944fa7d69dbd2d2dff6e6f84ad4ba3170", "filename": "src/librustc_trans/collector.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9f8093856dceb3e6bd740ab1238e132eddb203ca/src%2Flibrustc_trans%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f8093856dceb3e6bd740ab1238e132eddb203ca/src%2Flibrustc_trans%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcollector.rs?ref=9f8093856dceb3e6bd740ab1238e132eddb203ca", "patch": "@@ -478,7 +478,7 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n                 let target_ty = monomorphize::apply_param_substs(self.scx.tcx(),\n                                                                  self.param_substs,\n                                                                  &target_ty);\n-                let source_ty = self.mir.operand_ty(self.scx.tcx(), operand);\n+                let source_ty = operand.ty(self.mir, self.scx.tcx());\n                 let source_ty = monomorphize::apply_param_substs(self.scx.tcx(),\n                                                                  self.param_substs,\n                                                                  &source_ty);\n@@ -627,7 +627,7 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n                 match constant.ty.sty {\n                     ty::TyFnDef(def_id, _, bare_fn_ty)\n                         if is_drop_in_place_intrinsic(tcx, def_id, bare_fn_ty) => {\n-                        let operand_ty = self.mir.operand_ty(tcx, &args[0]);\n+                        let operand_ty = args[0].ty(self.mir, tcx);\n                         if let ty::TyRawPtr(mt) = operand_ty.sty {\n                             let operand_ty = monomorphize::apply_param_substs(tcx,\n                                                                               self.param_substs,"}, {"sha": "b1fd3e88d75f00c8d579f8e0feb9fa45773b7adf", "filename": "src/librustc_trans/mir/block.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f8093856dceb3e6bd740ab1238e132eddb203ca/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f8093856dceb3e6bd740ab1238e132eddb203ca/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fblock.rs?ref=9f8093856dceb3e6bd740ab1238e132eddb203ca", "patch": "@@ -433,7 +433,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n \n                 let extra_args = &args[sig.inputs.len()..];\n                 let extra_args = extra_args.iter().map(|op_arg| {\n-                    let op_ty = self.mir.operand_ty(bcx.tcx(), op_arg);\n+                    let op_ty = op_arg.ty(&self.mir, bcx.tcx());\n                     bcx.monomorphize(&op_ty)\n                 }).collect::<Vec<_>>();\n                 let fn_ty = callee.direct_fn_type(bcx.ccx(), &extra_args);"}, {"sha": "35ded7042969f33023d8e3d97b5def3eb79c0ea6", "filename": "src/librustc_trans/mir/constant.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9f8093856dceb3e6bd740ab1238e132eddb203ca/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f8093856dceb3e6bd740ab1238e132eddb203ca/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fconstant.rs?ref=9f8093856dceb3e6bd740ab1238e132eddb203ca", "patch": "@@ -327,7 +327,7 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n                 }\n \n                 mir::TerminatorKind::Call { ref func, ref args, ref destination, .. } => {\n-                    let fn_ty = self.mir.operand_ty(tcx, func);\n+                    let fn_ty = func.ty(self.mir, tcx);\n                     let fn_ty = self.monomorphize(&fn_ty);\n                     let instance = match fn_ty.sty {\n                         ty::TyFnDef(def_id, substs, _) => {\n@@ -723,7 +723,7 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n                 let lhs = self.const_operand(lhs, span)?;\n                 let rhs = self.const_operand(rhs, span)?;\n                 let ty = lhs.ty;\n-                let binop_ty = self.mir.binop_ty(tcx, op, lhs.ty, rhs.ty);\n+                let binop_ty = op.ty(tcx, lhs.ty, rhs.ty);\n                 let (lhs, rhs) = (lhs.llval, rhs.llval);\n                 Const::new(const_scalar_binop(op, lhs, rhs, ty), binop_ty)\n             }\n@@ -732,7 +732,7 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n                 let lhs = self.const_operand(lhs, span)?;\n                 let rhs = self.const_operand(rhs, span)?;\n                 let ty = lhs.ty;\n-                let val_ty = self.mir.binop_ty(tcx, op, lhs.ty, rhs.ty);\n+                let val_ty = op.ty(tcx, lhs.ty, rhs.ty);\n                 let binop_ty = tcx.mk_tup(vec![val_ty, tcx.types.bool]);\n                 let (lhs, rhs) = (lhs.llval, rhs.llval);\n                 assert!(!ty.is_fp());"}, {"sha": "9f7c2ee219eb5abafed3bc90684a3ffc6a159fbb", "filename": "src/librustc_trans/mir/rvalue.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9f8093856dceb3e6bd740ab1238e132eddb203ca/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f8093856dceb3e6bd740ab1238e132eddb203ca/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Frvalue.rs?ref=9f8093856dceb3e6bd740ab1238e132eddb203ca", "patch": "@@ -400,7 +400,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                 };\n                 let operand = OperandRef {\n                     val: OperandValue::Immediate(llresult),\n-                    ty: self.mir.binop_ty(bcx.tcx(), op, lhs.ty, rhs.ty),\n+                    ty: op.ty(bcx.tcx(), lhs.ty, rhs.ty),\n                 };\n                 (bcx, operand)\n             }\n@@ -410,7 +410,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                 let result = self.trans_scalar_checked_binop(&bcx, op,\n                                                              lhs.immediate(), rhs.immediate(),\n                                                              lhs.ty);\n-                let val_ty = self.mir.binop_ty(bcx.tcx(), op, lhs.ty, rhs.ty);\n+                let val_ty = op.ty(bcx.tcx(), lhs.ty, rhs.ty);\n                 let operand_ty = bcx.tcx().mk_tup(vec![val_ty, bcx.tcx().types.bool]);\n                 let operand = OperandRef {\n                     val: result,"}]}