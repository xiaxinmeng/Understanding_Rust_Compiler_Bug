{"sha": "d3ebd592d0024994c4661807c925e20a018238b3", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQzZWJkNTkyZDAwMjQ5OTRjNDY2MTgwN2M5MjVlMjBhMDE4MjM4YjM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-02-20T22:44:01Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-02-20T22:44:01Z"}, "message": "Auto merge of #69072 - ecstatic-morse:associated-items, r=petrochenkov\n\nO(log n) lookup of associated items by name\n\nResolves #68957, in which compile time is quadratic in the number of associated items. This PR makes name lookup use binary search instead of a linear scan to improve its asymptotic performance. As a result, the pathological case from that issue now runs in 8 seconds on my local machine, as opposed to many minutes on the current stable.\n\nCurrently, method resolution must do a linear scan through all associated items of a type to find one with a certain name. This PR changes the result of the `associated_items` query to a data structure that preserves the definition order of associated items (which is used, e.g., for the layout of trait object vtables) while adding an index of those items sorted by (unhygienic) name. When doing name lookup, we first find all items with the same `Symbol` using binary search, then run hygienic comparison to find the one we are looking for. Ideally, this would be implemented using an insertion-order preserving, hash-based multi-map, but one is not readily available.\n\nSomeone who is more familiar with identifier hygiene could probably make this better by auditing the uses of the `AssociatedItems` interface. My goal was to preserve the current behavior exactly, even if it seemed strange (I left at least one FIXME to this effect). For example, some places use comparison with `ident.modern()` and some places use `tcx.hygienic_eq` which requires the `DefId` of the containing `impl`. I don't know whether those approaches are equivalent or which one should be preferred.", "tree": {"sha": "e356067bc02d0d3c651fc14c35d2e074a0beecd3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e356067bc02d0d3c651fc14c35d2e074a0beecd3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d3ebd592d0024994c4661807c925e20a018238b3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d3ebd592d0024994c4661807c925e20a018238b3", "html_url": "https://github.com/rust-lang/rust/commit/d3ebd592d0024994c4661807c925e20a018238b3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d3ebd592d0024994c4661807c925e20a018238b3/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2c462a2f776b899d46743b1b44eda976e846e61d", "url": "https://api.github.com/repos/rust-lang/rust/commits/2c462a2f776b899d46743b1b44eda976e846e61d", "html_url": "https://github.com/rust-lang/rust/commit/2c462a2f776b899d46743b1b44eda976e846e61d"}, {"sha": "a0212ba40fdeb07626449b5790537aca542b51d2", "url": "https://api.github.com/repos/rust-lang/rust/commits/a0212ba40fdeb07626449b5790537aca542b51d2", "html_url": "https://github.com/rust-lang/rust/commit/a0212ba40fdeb07626449b5790537aca542b51d2"}], "stats": {"total": 682, "additions": 498, "deletions": 184}, "files": [{"sha": "ca55d410ceba4695e537377243b2e52eb703d9f8", "filename": "src/librustc/arena.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d3ebd592d0024994c4661807c925e20a018238b3/src%2Flibrustc%2Farena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3ebd592d0024994c4661807c925e20a018238b3/src%2Flibrustc%2Farena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Farena.rs?ref=d3ebd592d0024994c4661807c925e20a018238b3", "patch": "@@ -48,6 +48,7 @@ macro_rules! arena_types {\n             [] item_local_set: rustc_hir::ItemLocalSet,\n             [decode] mir_const_qualif: rustc_index::bit_set::BitSet<rustc::mir::Local>,\n             [] trait_impls_of: rustc::ty::trait_def::TraitImpls,\n+            [] associated_items: rustc::ty::AssociatedItems,\n             [] dropck_outlives:\n                 rustc::infer::canonical::Canonical<'tcx,\n                     rustc::infer::canonical::QueryResponse<'tcx,"}, {"sha": "9d0aea05d8496eea2c3f974a6b532525d8d2acae", "filename": "src/librustc/query/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d3ebd592d0024994c4661807c925e20a018238b3/src%2Flibrustc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3ebd592d0024994c4661807c925e20a018238b3/src%2Flibrustc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fquery%2Fmod.rs?ref=d3ebd592d0024994c4661807c925e20a018238b3", "patch": "@@ -333,7 +333,7 @@ rustc_queries! {\n         query associated_item(_: DefId) -> ty::AssocItem {}\n \n         /// Collects the associated items defined on a trait or impl.\n-        query associated_items(key: DefId) -> &'tcx [ty::AssocItem] {\n+        query associated_items(key: DefId) -> &'tcx ty::AssociatedItems {\n             desc { |tcx| \"collecting associated items of {}\", tcx.def_path_str(key) }\n         }\n "}, {"sha": "ee813bf606e9728b7ad8e834f405db1fa19613a6", "filename": "src/librustc/traits/specialization_graph.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d3ebd592d0024994c4661807c925e20a018238b3/src%2Flibrustc%2Ftraits%2Fspecialization_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3ebd592d0024994c4661807c925e20a018238b3/src%2Flibrustc%2Ftraits%2Fspecialization_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialization_graph.rs?ref=d3ebd592d0024994c4661807c925e20a018238b3", "patch": "@@ -81,8 +81,8 @@ impl<'tcx> Node {\n     }\n \n     /// Iterate over the items defined directly by the given (impl or trait) node.\n-    pub fn items(&self, tcx: TyCtxt<'tcx>) -> &'tcx [ty::AssocItem] {\n-        tcx.associated_items(self.def_id())\n+    pub fn items(&self, tcx: TyCtxt<'tcx>) -> impl 'tcx + Iterator<Item = &'tcx ty::AssocItem> {\n+        tcx.associated_items(self.def_id()).in_definition_order()\n     }\n \n     /// Finds an associated item defined in this node.\n@@ -99,7 +99,7 @@ impl<'tcx> Node {\n         use crate::ty::AssocKind::*;\n \n         tcx.associated_items(self.def_id())\n-            .iter()\n+            .filter_by_name_unhygienic(trait_item_name.name)\n             .find(move |impl_item| {\n                 match (trait_item_kind, impl_item.kind) {\n                 | (Const, Const)"}, {"sha": "851bffc2065c972d89c26a14242faa1a608eb7be", "filename": "src/librustc/ty/adjustment.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d3ebd592d0024994c4661807c925e20a018238b3/src%2Flibrustc%2Fty%2Fadjustment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3ebd592d0024994c4661807c925e20a018238b3/src%2Flibrustc%2Fty%2Fadjustment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fadjustment.rs?ref=d3ebd592d0024994c4661807c925e20a018238b3", "patch": "@@ -122,7 +122,7 @@ impl<'tcx> OverloadedDeref<'tcx> {\n         };\n         let method_def_id = tcx\n             .associated_items(trait_def_id.unwrap())\n-            .iter()\n+            .in_definition_order()\n             .find(|m| m.kind == ty::AssocKind::Method)\n             .unwrap()\n             .def_id;"}, {"sha": "0ec30bc583cf89971a3e1b3a2f9d8e0e8df62483", "filename": "src/librustc/ty/instance.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d3ebd592d0024994c4661807c925e20a018238b3/src%2Flibrustc%2Fty%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3ebd592d0024994c4661807c925e20a018238b3/src%2Flibrustc%2Fty%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Finstance.rs?ref=d3ebd592d0024994c4661807c925e20a018238b3", "patch": "@@ -337,7 +337,7 @@ impl<'tcx> Instance<'tcx> {\n         let fn_once = tcx.lang_items().fn_once_trait().unwrap();\n         let call_once = tcx\n             .associated_items(fn_once)\n-            .iter()\n+            .in_definition_order()\n             .find(|it| it.kind == ty::AssocKind::Method)\n             .unwrap()\n             .def_id;"}, {"sha": "77ac319547b9d020fc8ff6e8b3eeed003d4cf720", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 87, "deletions": 4, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/d3ebd592d0024994c4661807c925e20a018238b3/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3ebd592d0024994c4661807c925e20a018238b3/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=d3ebd592d0024994c4661807c925e20a018238b3", "patch": "@@ -30,10 +30,11 @@ use rustc_attr as attr;\n use rustc_data_structures::captures::Captures;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::fx::FxIndexMap;\n+use rustc_data_structures::sorted_map::SortedIndexMultiMap;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_data_structures::sync::{self, par_iter, Lrc, ParallelIterator};\n use rustc_hir as hir;\n-use rustc_hir::def::{CtorKind, CtorOf, DefKind, Res};\n+use rustc_hir::def::{CtorKind, CtorOf, DefKind, Namespace, Res};\n use rustc_hir::def_id::{CrateNum, DefId, DefIdMap, LocalDefId, CRATE_DEF_INDEX, LOCAL_CRATE};\n use rustc_hir::{Constness, GlobMap, Node, TraitMap};\n use rustc_index::vec::{Idx, IndexVec};\n@@ -216,6 +217,13 @@ impl AssocKind {\n             ty::AssocKind::Const => \"associated constant\",\n         }\n     }\n+\n+    pub fn namespace(&self) -> Namespace {\n+        match *self {\n+            ty::AssocKind::OpaqueTy | ty::AssocKind::Type => Namespace::TypeNS,\n+            ty::AssocKind::Const | ty::AssocKind::Method => Namespace::ValueNS,\n+        }\n+    }\n }\n \n impl AssocItem {\n@@ -257,6 +265,81 @@ impl AssocItem {\n     }\n }\n \n+/// A list of `ty::AssocItem`s in definition order that allows for efficient lookup by name.\n+///\n+/// When doing lookup by name, we try to postpone hygienic comparison for as long as possible since\n+/// it is relatively expensive. Instead, items are indexed by `Symbol` and hygienic comparison is\n+/// done only on items with the same name.\n+#[derive(Debug, Clone, PartialEq, HashStable)]\n+pub struct AssociatedItems {\n+    items: SortedIndexMultiMap<u32, Symbol, ty::AssocItem>,\n+}\n+\n+impl AssociatedItems {\n+    /// Constructs an `AssociatedItems` map from a series of `ty::AssocItem`s in definition order.\n+    pub fn new(items_in_def_order: impl IntoIterator<Item = ty::AssocItem>) -> Self {\n+        let items = items_in_def_order.into_iter().map(|item| (item.ident.name, item)).collect();\n+        AssociatedItems { items }\n+    }\n+\n+    /// Returns a slice of associated items in the order they were defined.\n+    ///\n+    /// New code should avoid relying on definition order. If you need a particular associated item\n+    /// for a known trait, make that trait a lang item instead of indexing this array.\n+    pub fn in_definition_order(&self) -> impl '_ + Iterator<Item = &ty::AssocItem> {\n+        self.items.iter().map(|(_, v)| v)\n+    }\n+\n+    /// Returns an iterator over all associated items with the given name, ignoring hygiene.\n+    pub fn filter_by_name_unhygienic(\n+        &self,\n+        name: Symbol,\n+    ) -> impl '_ + Iterator<Item = &ty::AssocItem> {\n+        self.items.get_by_key(&name)\n+    }\n+\n+    /// Returns an iterator over all associated items with the given name.\n+    ///\n+    /// Multiple items may have the same name if they are in different `Namespace`s. For example,\n+    /// an associated type can have the same name as a method. Use one of the `find_by_name_and_*`\n+    /// methods below if you know which item you are looking for.\n+    pub fn filter_by_name(\n+        &'a self,\n+        tcx: TyCtxt<'a>,\n+        ident: Ident,\n+        parent_def_id: DefId,\n+    ) -> impl 'a + Iterator<Item = &'a ty::AssocItem> {\n+        self.filter_by_name_unhygienic(ident.name)\n+            .filter(move |item| tcx.hygienic_eq(ident, item.ident, parent_def_id))\n+    }\n+\n+    /// Returns the associated item with the given name and `AssocKind`, if one exists.\n+    pub fn find_by_name_and_kind(\n+        &self,\n+        tcx: TyCtxt<'_>,\n+        ident: Ident,\n+        kind: AssocKind,\n+        parent_def_id: DefId,\n+    ) -> Option<&ty::AssocItem> {\n+        self.filter_by_name_unhygienic(ident.name)\n+            .filter(|item| item.kind == kind)\n+            .find(|item| tcx.hygienic_eq(ident, item.ident, parent_def_id))\n+    }\n+\n+    /// Returns the associated item with the given name in the given `Namespace`, if one exists.\n+    pub fn find_by_name_and_namespace(\n+        &self,\n+        tcx: TyCtxt<'_>,\n+        ident: Ident,\n+        ns: Namespace,\n+        parent_def_id: DefId,\n+    ) -> Option<&ty::AssocItem> {\n+        self.filter_by_name_unhygienic(ident.name)\n+            .filter(|item| item.kind.namespace() == ns)\n+            .find(|item| tcx.hygienic_eq(ident, item.ident, parent_def_id))\n+    }\n+}\n+\n #[derive(Clone, Debug, PartialEq, Eq, Copy, RustcEncodable, RustcDecodable, HashStable)]\n pub enum Visibility {\n     /// Visible everywhere (including in other crates).\n@@ -2731,14 +2814,14 @@ impl<'tcx> TyCtxt<'tcx> {\n             .for_each(|&body_id| f(self.hir().body_owner_def_id(body_id)));\n     }\n \n-    pub fn provided_trait_methods(self, id: DefId) -> impl Iterator<Item = &'tcx AssocItem> {\n+    pub fn provided_trait_methods(self, id: DefId) -> impl 'tcx + Iterator<Item = &'tcx AssocItem> {\n         self.associated_items(id)\n-            .iter()\n+            .in_definition_order()\n             .filter(|item| item.kind == AssocKind::Method && item.defaultness.has_value())\n     }\n \n     pub fn trait_relevant_for_never(self, did: DefId) -> bool {\n-        self.associated_items(did).iter().any(|item| item.relevant_for_never())\n+        self.associated_items(did).in_definition_order().any(|item| item.relevant_for_never())\n     }\n \n     pub fn opt_item_name(self, def_id: DefId) -> Option<Ident> {"}, {"sha": "c3698f402a9d120f520b29d440cbcb05628b79b1", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d3ebd592d0024994c4661807c925e20a018238b3/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3ebd592d0024994c4661807c925e20a018238b3/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=d3ebd592d0024994c4661807c925e20a018238b3", "patch": "@@ -1066,11 +1066,7 @@ impl<'tcx> ProjectionTy<'tcx> {\n     ) -> ProjectionTy<'tcx> {\n         let item_def_id = tcx\n             .associated_items(trait_ref.def_id)\n-            .iter()\n-            .find(|item| {\n-                item.kind == ty::AssocKind::Type\n-                    && tcx.hygienic_eq(item_name, item.ident, trait_ref.def_id)\n-            })\n+            .find_by_name_and_kind(tcx, item_name, ty::AssocKind::Type, trait_ref.def_id)\n             .unwrap()\n             .def_id;\n "}, {"sha": "eec6893d357d620838a109d226297531e39ce319", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d3ebd592d0024994c4661807c925e20a018238b3/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3ebd592d0024994c4661807c925e20a018238b3/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=d3ebd592d0024994c4661807c925e20a018238b3", "patch": "@@ -357,7 +357,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         let mut dtor_did = None;\n         let ty = self.type_of(adt_did);\n         self.for_each_relevant_impl(drop_trait, ty, |impl_did| {\n-            if let Some(item) = self.associated_items(impl_did).first() {\n+            if let Some(item) = self.associated_items(impl_did).in_definition_order().nth(0) {\n                 if validate(self, impl_did).is_ok() {\n                     dtor_did = Some(item.def_id);\n                 }"}, {"sha": "8c42b74b85aef4f0c35a45936ae639c785f52d7d", "filename": "src/librustc_data_structures/sorted_map.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d3ebd592d0024994c4661807c925e20a018238b3/src%2Flibrustc_data_structures%2Fsorted_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3ebd592d0024994c4661807c925e20a018238b3/src%2Flibrustc_data_structures%2Fsorted_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fsorted_map.rs?ref=d3ebd592d0024994c4661807c925e20a018238b3", "patch": "@@ -4,6 +4,10 @@ use std::iter::FromIterator;\n use std::mem;\n use std::ops::{Bound, Index, IndexMut, RangeBounds};\n \n+mod index_map;\n+\n+pub use index_map::SortedIndexMultiMap;\n+\n /// `SortedMap` is a data structure with similar characteristics as BTreeMap but\n /// slightly different trade-offs: lookup, insertion, and removal are O(log(N))\n /// and elements can be iterated in order cheaply."}, {"sha": "b7005ccdc998be72cb0276c20d2de5917e211a7d", "filename": "src/librustc_data_structures/sorted_map/index_map.rs", "status": "added", "additions": 218, "deletions": 0, "changes": 218, "blob_url": "https://github.com/rust-lang/rust/blob/d3ebd592d0024994c4661807c925e20a018238b3/src%2Flibrustc_data_structures%2Fsorted_map%2Findex_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3ebd592d0024994c4661807c925e20a018238b3/src%2Flibrustc_data_structures%2Fsorted_map%2Findex_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fsorted_map%2Findex_map.rs?ref=d3ebd592d0024994c4661807c925e20a018238b3", "patch": "@@ -0,0 +1,218 @@\n+//! A variant of `SortedMap` that preserves insertion order.\n+\n+use std::borrow::Borrow;\n+use std::hash::{Hash, Hasher};\n+use std::iter::FromIterator;\n+\n+use crate::stable_hasher::{HashStable, StableHasher};\n+use rustc_index::vec::{Idx, IndexVec};\n+\n+/// An indexed multi-map that preserves insertion order while permitting both `O(log n)` lookup of\n+/// an item by key and `O(1)` lookup by index.\n+///\n+/// This data structure is a hybrid of an [`IndexVec`] and a [`SortedMap`]. Like `IndexVec`,\n+/// `SortedIndexMultiMap` assigns a typed index to each item while preserving insertion order.\n+/// Like `SortedMap`, `SortedIndexMultiMap` has efficient lookup of items by key. However, this\n+/// is accomplished by sorting an array of item indices instead of the items themselves.\n+///\n+/// Unlike `SortedMap`, this data structure can hold multiple equivalent items at once, so the\n+/// `get_by_key` method and its variants return an iterator instead of an `Option`. Equivalent\n+/// items will be yielded in insertion order.\n+///\n+/// Unlike a general-purpose map like `BTreeSet` or `HashSet`, `SortedMap` and\n+/// `SortedIndexMultiMap` require `O(n)` time to insert a single item. This is because we may need\n+/// to insert into the middle of the sorted array. Users should avoid mutating this data structure\n+/// in-place.\n+///\n+/// [`IndexVec`]: ../../rustc_index/vec/struct.IndexVec.html\n+/// [`SortedMap`]: ../sorted_map/struct.SortedMap.html\n+#[derive(Clone, Debug)]\n+pub struct SortedIndexMultiMap<I: Idx, K, V> {\n+    /// The elements of the map in insertion order.\n+    items: IndexVec<I, (K, V)>,\n+\n+    /// Indices of the items in the set, sorted by the item's key.\n+    idx_sorted_by_item_key: Vec<I>,\n+}\n+\n+impl<I: Idx, K: Ord, V> SortedIndexMultiMap<I, K, V> {\n+    pub fn new() -> Self {\n+        SortedIndexMultiMap { items: IndexVec::new(), idx_sorted_by_item_key: Vec::new() }\n+    }\n+\n+    pub fn len(&self) -> usize {\n+        self.items.len()\n+    }\n+\n+    pub fn is_empty(&self) -> bool {\n+        self.items.is_empty()\n+    }\n+\n+    /// Returns an iterator over the items in the map in insertion order.\n+    pub fn into_iter(self) -> impl DoubleEndedIterator<Item = (K, V)> {\n+        self.items.into_iter()\n+    }\n+\n+    /// Returns an iterator over the items in the map in insertion order along with their indices.\n+    pub fn into_iter_enumerated(self) -> impl DoubleEndedIterator<Item = (I, (K, V))> {\n+        self.items.into_iter_enumerated()\n+    }\n+\n+    /// Returns an iterator over the items in the map in insertion order.\n+    pub fn iter(&self) -> impl '_ + DoubleEndedIterator<Item = (&K, &V)> {\n+        self.items.iter().map(|(ref k, ref v)| (k, v))\n+    }\n+\n+    /// Returns an iterator over the items in the map in insertion order along with their indices.\n+    pub fn iter_enumerated(&self) -> impl '_ + DoubleEndedIterator<Item = (I, (&K, &V))> {\n+        self.items.iter_enumerated().map(|(i, (ref k, ref v))| (i, (k, v)))\n+    }\n+\n+    /// Returns the item in the map with the given index.\n+    pub fn get(&self, idx: I) -> Option<&(K, V)> {\n+        self.items.get(idx)\n+    }\n+\n+    /// Returns an iterator over the items in the map that are equal to `key`.\n+    ///\n+    /// If there are multiple items that are equivalent to `key`, they will be yielded in\n+    /// insertion order.\n+    pub fn get_by_key<Q: 'a>(&'a self, key: &Q) -> impl 'a + Iterator<Item = &'a V>\n+    where\n+        Q: Ord + ?Sized,\n+        K: Borrow<Q>,\n+    {\n+        self.get_by_key_enumerated(key).map(|(_, v)| v)\n+    }\n+\n+    /// Returns an iterator over the items in the map that are equal to `key` along with their\n+    /// indices.\n+    ///\n+    /// If there are multiple items that are equivalent to `key`, they will be yielded in\n+    /// insertion order.\n+    pub fn get_by_key_enumerated<Q>(&self, key: &Q) -> impl '_ + Iterator<Item = (I, &V)>\n+    where\n+        Q: Ord + ?Sized,\n+        K: Borrow<Q>,\n+    {\n+        // FIXME: This should be in the standard library as `equal_range`. See rust-lang/rfcs#2184.\n+        match self.binary_search_idx(key) {\n+            Err(_) => self.idxs_to_items_enumerated(&[]),\n+\n+            Ok(idx) => {\n+                let start = self.find_lower_bound(key, idx);\n+                let end = self.find_upper_bound(key, idx);\n+                self.idxs_to_items_enumerated(&self.idx_sorted_by_item_key[start..end])\n+            }\n+        }\n+    }\n+\n+    fn binary_search_idx<Q>(&self, key: &Q) -> Result<usize, usize>\n+    where\n+        Q: Ord + ?Sized,\n+        K: Borrow<Q>,\n+    {\n+        self.idx_sorted_by_item_key.binary_search_by(|&idx| self.items[idx].0.borrow().cmp(key))\n+    }\n+\n+    /// Returns the index into the `idx_sorted_by_item_key` array of the first item equal to\n+    /// `key`.\n+    ///\n+    /// `initial` must be an index into that same array for an item that is equal to `key`.\n+    fn find_lower_bound<Q>(&self, key: &Q, initial: usize) -> usize\n+    where\n+        Q: Ord + ?Sized,\n+        K: Borrow<Q>,\n+    {\n+        debug_assert!(self.items[self.idx_sorted_by_item_key[initial]].0.borrow() == key);\n+\n+        // FIXME: At present, this uses linear search, meaning lookup is only `O(log n)` if duplicate\n+        // entries are rare. It would be better to start with a linear search for the common case but\n+        // fall back to an exponential search if many duplicates are found. This applies to\n+        // `upper_bound` as well.\n+        let mut start = initial;\n+        while start != 0 && self.items[self.idx_sorted_by_item_key[start - 1]].0.borrow() == key {\n+            start -= 1;\n+        }\n+\n+        start\n+    }\n+\n+    /// Returns the index into the `idx_sorted_by_item_key` array of the first item greater than\n+    /// `key`, or `self.len()` if no such item exists.\n+    ///\n+    /// `initial` must be an index into that same array for an item that is equal to `key`.\n+    fn find_upper_bound<Q>(&self, key: &Q, initial: usize) -> usize\n+    where\n+        Q: Ord + ?Sized,\n+        K: Borrow<Q>,\n+    {\n+        debug_assert!(self.items[self.idx_sorted_by_item_key[initial]].0.borrow() == key);\n+\n+        // See the FIXME for `find_lower_bound`.\n+        let mut end = initial + 1;\n+        let len = self.items.len();\n+        while end < len && self.items[self.idx_sorted_by_item_key[end]].0.borrow() == key {\n+            end += 1;\n+        }\n+\n+        end\n+    }\n+\n+    fn idxs_to_items_enumerated(&'a self, idxs: &'a [I]) -> impl 'a + Iterator<Item = (I, &'a V)> {\n+        idxs.iter().map(move |&idx| (idx, &self.items[idx].1))\n+    }\n+}\n+\n+impl<I: Idx, K: Eq, V: Eq> Eq for SortedIndexMultiMap<I, K, V> {}\n+impl<I: Idx, K: PartialEq, V: PartialEq> PartialEq for SortedIndexMultiMap<I, K, V> {\n+    fn eq(&self, other: &Self) -> bool {\n+        // No need to compare the sorted index. If the items are the same, the index will be too.\n+        self.items == other.items\n+    }\n+}\n+\n+impl<I: Idx, K, V> Hash for SortedIndexMultiMap<I, K, V>\n+where\n+    K: Hash,\n+    V: Hash,\n+{\n+    fn hash<H: Hasher>(&self, hasher: &mut H) {\n+        self.items.hash(hasher)\n+    }\n+}\n+impl<I: Idx, K, V, C> HashStable<C> for SortedIndexMultiMap<I, K, V>\n+where\n+    K: HashStable<C>,\n+    V: HashStable<C>,\n+{\n+    fn hash_stable(&self, ctx: &mut C, hasher: &mut StableHasher) {\n+        self.items.hash_stable(ctx, hasher)\n+    }\n+}\n+\n+impl<I: Idx, K: Ord, V> FromIterator<(K, V)> for SortedIndexMultiMap<I, K, V> {\n+    fn from_iter<J>(iter: J) -> Self\n+    where\n+        J: IntoIterator<Item = (K, V)>,\n+    {\n+        let items = IndexVec::from_iter(iter);\n+        let mut idx_sorted_by_item_key: Vec<_> = items.indices().collect();\n+\n+        // `sort_by_key` is stable, so insertion order is preserved for duplicate items.\n+        idx_sorted_by_item_key.sort_by_key(|&idx| &items[idx].0);\n+\n+        SortedIndexMultiMap { items, idx_sorted_by_item_key }\n+    }\n+}\n+\n+impl<I: Idx, K, V> std::ops::Index<I> for SortedIndexMultiMap<I, K, V> {\n+    type Output = V;\n+\n+    fn index(&self, idx: I) -> &Self::Output {\n+        &self.items[idx].1\n+    }\n+}\n+\n+#[cfg(tests)]\n+mod tests;"}, {"sha": "7d91e1fdcef6a3f1db929218752e9a8cfa316416", "filename": "src/librustc_data_structures/sorted_map/tests.rs", "status": "modified", "additions": 27, "deletions": 1, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/d3ebd592d0024994c4661807c925e20a018238b3/src%2Flibrustc_data_structures%2Fsorted_map%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3ebd592d0024994c4661807c925e20a018238b3/src%2Flibrustc_data_structures%2Fsorted_map%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fsorted_map%2Ftests.rs?ref=d3ebd592d0024994c4661807c925e20a018238b3", "patch": "@@ -1,4 +1,30 @@\n-use super::SortedMap;\n+use super::{SortedIndexMultiMap, SortedMap};\n+\n+#[test]\n+fn test_sorted_index_multi_map() {\n+    let entries: Vec<_> = vec![(2, 0), (1, 0), (2, 1), (3, 0), (2, 2)];\n+    let set: SortedIndexMultiMap<usize, _, _> = entries.iter().copied().collect();\n+\n+    // Insertion order is preserved.\n+    assert!(entries.iter().map(|(ref k, ref v)| (k, v)).eq(set.iter()));\n+\n+    // Indexing\n+    for (i, expect) in entries.iter().enumerate() {\n+        assert_eq!(set[i], expect.1);\n+    }\n+\n+    // `get_by_key` works.\n+    assert_eq!(set.get_by_key(&3).copied().collect::<Vec<_>>(), vec![0]);\n+    assert!(set.get_by_key(&4).next().is_none());\n+\n+    // `get_by_key` returns items in insertion order.\n+    let twos: Vec<_> = set.get_by_key_enumerated(&2).collect();\n+    let idxs: Vec<usize> = twos.iter().map(|(i, _)| *i).collect();\n+    let values: Vec<usize> = twos.iter().map(|(_, &v)| v).collect();\n+\n+    assert_eq!(idxs, vec![0, 2, 4]);\n+    assert_eq!(values, vec![0, 1, 2]);\n+}\n \n #[test]\n fn test_insert_and_iter() {"}, {"sha": "8496a6ed23b8c72e94a3cc11566665e19aeec294", "filename": "src/librustc_hir/hir.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/d3ebd592d0024994c4661807c925e20a018238b3/src%2Flibrustc_hir%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3ebd592d0024994c4661807c925e20a018238b3/src%2Flibrustc_hir%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_hir%2Fhir.rs?ref=d3ebd592d0024994c4661807c925e20a018238b3", "patch": "@@ -1,4 +1,4 @@\n-use crate::def::{DefKind, Res};\n+use crate::def::{DefKind, Namespace, Res};\n use crate::def_id::DefId;\n crate use crate::hir_id::HirId;\n use crate::itemlikevisit;\n@@ -1897,6 +1897,15 @@ pub enum ImplItemKind<'hir> {\n     OpaqueTy(GenericBounds<'hir>),\n }\n \n+impl ImplItemKind<'_> {\n+    pub fn namespace(&self) -> Namespace {\n+        match self {\n+            ImplItemKind::OpaqueTy(..) | ImplItemKind::TyAlias(..) => Namespace::TypeNS,\n+            ImplItemKind::Const(..) | ImplItemKind::Method(..) => Namespace::ValueNS,\n+        }\n+    }\n+}\n+\n // The name of the associated type for `Fn` return types.\n pub const FN_OUTPUT_NAME: Symbol = sym::Output;\n "}, {"sha": "b49f0062a9c91e891d657a532c0c05c7372d0c81", "filename": "src/librustc_infer/traits/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d3ebd592d0024994c4661807c925e20a018238b3/src%2Flibrustc_infer%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3ebd592d0024994c4661807c925e20a018238b3/src%2Flibrustc_infer%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Ftraits%2Fmod.rs?ref=d3ebd592d0024994c4661807c925e20a018238b3", "patch": "@@ -537,7 +537,7 @@ fn vtable_methods<'tcx>(\n     tcx.arena.alloc_from_iter(supertraits(tcx, trait_ref).flat_map(move |trait_ref| {\n         let trait_methods = tcx\n             .associated_items(trait_ref.def_id())\n-            .iter()\n+            .in_definition_order()\n             .filter(|item| item.kind == ty::AssocKind::Method);\n \n         // Now list each method's DefId and InternalSubsts (for within its trait)."}, {"sha": "93eeb42a594a4e7348b5fe3194e03f299baeb081", "filename": "src/librustc_infer/traits/object_safety.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d3ebd592d0024994c4661807c925e20a018238b3/src%2Flibrustc_infer%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3ebd592d0024994c4661807c925e20a018238b3/src%2Flibrustc_infer%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Ftraits%2Fobject_safety.rs?ref=d3ebd592d0024994c4661807c925e20a018238b3", "patch": "@@ -213,7 +213,7 @@ fn object_safety_violations_for_trait(\n     // Check methods for violations.\n     let mut violations: Vec<_> = tcx\n         .associated_items(trait_def_id)\n-        .iter()\n+        .in_definition_order()\n         .filter(|item| item.kind == ty::AssocKind::Method)\n         .filter_map(|item| {\n             object_safety_violation_for_method(tcx, trait_def_id, &item)\n@@ -289,7 +289,7 @@ fn object_safety_violations_for_trait(\n \n     violations.extend(\n         tcx.associated_items(trait_def_id)\n-            .iter()\n+            .in_definition_order()\n             .filter(|item| item.kind == ty::AssocKind::Const)\n             .map(|item| ObjectSafetyViolation::AssocConst(item.ident.name, item.ident.span)),\n     );\n@@ -646,7 +646,7 @@ fn object_ty_for_trait<'tcx>(\n     let mut associated_types = traits::supertraits(tcx, ty::Binder::dummy(trait_ref))\n         .flat_map(|super_trait_ref| {\n             tcx.associated_items(super_trait_ref.def_id())\n-                .iter()\n+                .in_definition_order()\n                 .map(move |item| (super_trait_ref, item))\n         })\n         .filter(|(_, item)| item.kind == ty::AssocKind::Type)"}, {"sha": "1dca01b3468ae2fc4028c598f81cbbd96f4db661", "filename": "src/librustc_infer/traits/util.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d3ebd592d0024994c4661807c925e20a018238b3/src%2Flibrustc_infer%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3ebd592d0024994c4661807c925e20a018238b3/src%2Flibrustc_infer%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Ftraits%2Futil.rs?ref=d3ebd592d0024994c4661807c925e20a018238b3", "patch": "@@ -586,7 +586,7 @@ pub fn count_own_vtable_entries(tcx: TyCtxt<'tcx>, trait_ref: ty::PolyTraitRef<'\n     let mut entries = 0;\n     // Count number of methods and add them to the total offset.\n     // Skip over associated types and constants.\n-    for trait_item in tcx.associated_items(trait_ref.def_id()) {\n+    for trait_item in tcx.associated_items(trait_ref.def_id()).in_definition_order() {\n         if trait_item.kind == ty::AssocKind::Method {\n             entries += 1;\n         }\n@@ -606,7 +606,7 @@ pub fn get_vtable_index_of_object_method<N>(\n     // add them to the total offset.\n     // Skip over associated types and constants.\n     let mut entries = object.vtable_base;\n-    for trait_item in tcx.associated_items(object.upcast_trait_ref.def_id()) {\n+    for trait_item in tcx.associated_items(object.upcast_trait_ref.def_id()).in_definition_order() {\n         if trait_item.def_id == method_def_id {\n             // The item with the ID we were given really ought to be a method.\n             assert_eq!(trait_item.kind, ty::AssocKind::Method);"}, {"sha": "993eb41b9b1a74c517576a005a8d292e5928c68b", "filename": "src/librustc_infer/traits/wf.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d3ebd592d0024994c4661807c925e20a018238b3/src%2Flibrustc_infer%2Ftraits%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3ebd592d0024994c4661807c925e20a018238b3/src%2Flibrustc_infer%2Ftraits%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Ftraits%2Fwf.rs?ref=d3ebd592d0024994c4661807c925e20a018238b3", "patch": "@@ -318,7 +318,10 @@ impl<'a, 'tcx> WfPredicates<'a, 'tcx> {\n             };\n \n         if let Elaborate::All = elaborate {\n-            let trait_assoc_items = tcx.associated_items(trait_ref.def_id);\n+            // FIXME: Make `extend_cause_with_original_assoc_item_obligation` take an iterator\n+            // instead of a slice.\n+            let trait_assoc_items: Vec<_> =\n+                tcx.associated_items(trait_ref.def_id).in_definition_order().copied().collect();\n \n             let predicates = obligations.iter().map(|obligation| obligation.predicate).collect();\n             let implied_obligations = traits::elaborate_predicates(tcx, predicates);\n@@ -327,7 +330,7 @@ impl<'a, 'tcx> WfPredicates<'a, 'tcx> {\n                 extend_cause_with_original_assoc_item_obligation(\n                     &mut cause,\n                     &pred,\n-                    trait_assoc_items,\n+                    &*trait_assoc_items,\n                 );\n                 traits::Obligation::new(cause, param_env, pred)\n             });"}, {"sha": "1f7db2861a2eb26b47b90c2b716050a1707eced6", "filename": "src/librustc_mir/shim.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d3ebd592d0024994c4661807c925e20a018238b3/src%2Flibrustc_mir%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3ebd592d0024994c4661807c925e20a018238b3/src%2Flibrustc_mir%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fshim.rs?ref=d3ebd592d0024994c4661807c925e20a018238b3", "patch": "@@ -68,7 +68,7 @@ fn make_shim<'tcx>(tcx: TyCtxt<'tcx>, instance: ty::InstanceDef<'tcx>) -> &'tcx\n             let fn_mut = tcx.lang_items().fn_mut_trait().unwrap();\n             let call_mut = tcx\n                 .associated_items(fn_mut)\n-                .iter()\n+                .in_definition_order()\n                 .find(|it| it.kind == ty::AssocKind::Method)\n                 .unwrap()\n                 .def_id;"}, {"sha": "fab64e37cbc5a7cf92ac27af672bf4c537500ffd", "filename": "src/librustc_mir/util/elaborate_drops.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d3ebd592d0024994c4661807c925e20a018238b3/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3ebd592d0024994c4661807c925e20a018238b3/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs?ref=d3ebd592d0024994c4661807c925e20a018238b3", "patch": "@@ -539,7 +539,7 @@ where\n         debug!(\"destructor_call_block({:?}, {:?})\", self, succ);\n         let tcx = self.tcx();\n         let drop_trait = tcx.lang_items().drop_trait().unwrap();\n-        let drop_fn = tcx.associated_items(drop_trait)[0];\n+        let drop_fn = tcx.associated_items(drop_trait).in_definition_order().nth(0).unwrap();\n         let ty = self.place_ty(self.place);\n         let substs = tcx.mk_substs_trait(ty, &[]);\n "}, {"sha": "f4f7ab4bba65df20824f7be3560f945a9f1bf0e3", "filename": "src/librustc_mir_build/hair/cx/mod.rs", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/d3ebd592d0024994c4661807c925e20a018238b3/src%2Flibrustc_mir_build%2Fhair%2Fcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3ebd592d0024994c4661807c925e20a018238b3/src%2Flibrustc_mir_build%2Fhair%2Fcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fhair%2Fcx%2Fmod.rs?ref=d3ebd592d0024994c4661807c925e20a018238b3", "patch": "@@ -167,17 +167,19 @@ impl<'a, 'tcx> Cx<'a, 'tcx> {\n         params: &[GenericArg<'tcx>],\n     ) -> &'tcx ty::Const<'tcx> {\n         let substs = self.tcx.mk_substs_trait(self_ty, params);\n-        for item in self.tcx.associated_items(trait_def_id) {\n-            // The unhygienic comparison here is acceptable because this is only\n-            // used on known traits.\n-            if item.kind == ty::AssocKind::Method && item.ident.name == method_name {\n-                let method_ty = self.tcx.type_of(item.def_id);\n-                let method_ty = method_ty.subst(self.tcx, substs);\n-                return ty::Const::zero_sized(self.tcx, method_ty);\n-            }\n-        }\n \n-        bug!(\"found no method `{}` in `{:?}`\", method_name, trait_def_id);\n+        // The unhygienic comparison here is acceptable because this is only\n+        // used on known traits.\n+        let item = self\n+            .tcx\n+            .associated_items(trait_def_id)\n+            .filter_by_name_unhygienic(method_name)\n+            .find(|item| item.kind == ty::AssocKind::Method)\n+            .expect(\"trait method not found\");\n+\n+        let method_ty = self.tcx.type_of(item.def_id);\n+        let method_ty = method_ty.subst(self.tcx, substs);\n+        ty::Const::zero_sized(self.tcx, method_ty)\n     }\n \n     crate fn all_fields(&mut self, adt_def: &ty::AdtDef, variant_index: VariantIdx) -> Vec<Field> {"}, {"sha": "0c7f64fefd0d26292acb06d720180c9eb3fe4ff6", "filename": "src/librustc_passes/stability.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d3ebd592d0024994c4661807c925e20a018238b3/src%2Flibrustc_passes%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3ebd592d0024994c4661807c925e20a018238b3/src%2Flibrustc_passes%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fstability.rs?ref=d3ebd592d0024994c4661807c925e20a018238b3", "patch": "@@ -523,8 +523,8 @@ impl Visitor<'tcx> for Checker<'tcx> {\n                         let trait_item_def_id = self\n                             .tcx\n                             .associated_items(trait_did)\n-                            .iter()\n-                            .find(|item| item.ident.name == impl_item.ident.name)\n+                            .filter_by_name_unhygienic(impl_item.ident.name)\n+                            .next()\n                             .map(|item| item.def_id);\n                         if let Some(def_id) = trait_item_def_id {\n                             // Pass `None` to skip deprecation warnings."}, {"sha": "6e7ecf92441216cc71dd496c4bc46b4c8376da68", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/d3ebd592d0024994c4661807c925e20a018238b3/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3ebd592d0024994c4661807c925e20a018238b3/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=d3ebd592d0024994c4661807c925e20a018238b3", "patch": "@@ -408,7 +408,6 @@ impl<'l, 'tcx> SaveContext<'l, 'tcx> {\n                         qualname.push_str(&self.tcx.hir().hir_to_pretty_string(self_ty.hir_id));\n \n                         let trait_id = self.tcx.trait_id_of_impl(impl_id);\n-                        let mut decl_id = None;\n                         let mut docs = String::new();\n                         let mut attrs = vec![];\n                         let hir_id = self.tcx.hir().node_to_hir_id(id);\n@@ -417,15 +416,18 @@ impl<'l, 'tcx> SaveContext<'l, 'tcx> {\n                             attrs = item.attrs.to_vec();\n                         }\n \n+                        let mut decl_id = None;\n                         if let Some(def_id) = trait_id {\n                             // A method in a trait impl.\n                             qualname.push_str(\" as \");\n                             qualname.push_str(&self.tcx.def_path_str(def_id));\n-                            self.tcx\n+\n+                            decl_id = self\n+                                .tcx\n                                 .associated_items(def_id)\n-                                .iter()\n-                                .find(|item| item.ident.name == ident.name)\n-                                .map(|item| decl_id = Some(item.def_id));\n+                                .filter_by_name_unhygienic(ident.name)\n+                                .next()\n+                                .map(|item| item.def_id);\n                         }\n                         qualname.push_str(\">\");\n \n@@ -716,12 +718,11 @@ impl<'l, 'tcx> SaveContext<'l, 'tcx> {\n             Res::Def(HirDefKind::Method, decl_id) => {\n                 let def_id = if decl_id.is_local() {\n                     let ti = self.tcx.associated_item(decl_id);\n+\n                     self.tcx\n                         .associated_items(ti.container.id())\n-                        .iter()\n-                        .find(|item| {\n-                            item.ident.name == ti.ident.name && item.defaultness.has_value()\n-                        })\n+                        .filter_by_name_unhygienic(ti.ident.name)\n+                        .find(|item| item.defaultness.has_value())\n                         .map(|item| item.def_id)\n                 } else {\n                     None"}, {"sha": "d466bbcca79bacadf94f57e469f41405d8ed97b4", "filename": "src/librustc_ty/ty.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d3ebd592d0024994c4661807c925e20a018238b3/src%2Flibrustc_ty%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3ebd592d0024994c4661807c925e20a018238b3/src%2Flibrustc_ty%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ty%2Fty.rs?ref=d3ebd592d0024994c4661807c925e20a018238b3", "patch": "@@ -210,10 +210,9 @@ fn associated_item_def_ids(tcx: TyCtxt<'_>, def_id: DefId) -> &[DefId] {\n     }\n }\n \n-fn associated_items<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> &'tcx [ty::AssocItem] {\n-    tcx.arena.alloc_from_iter(\n-        tcx.associated_item_def_ids(def_id).iter().map(|did| tcx.associated_item(*did)),\n-    )\n+fn associated_items<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> &'tcx ty::AssociatedItems {\n+    let items = tcx.associated_item_def_ids(def_id).iter().map(|did| tcx.associated_item(*did));\n+    tcx.arena.alloc(ty::AssociatedItems::new(items))\n }\n \n fn def_span(tcx: TyCtxt<'_>, def_id: DefId) -> Span {"}, {"sha": "88e0f8b30d9ee8fdcf682ce9bee12261635f19c5", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 19, "deletions": 17, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/d3ebd592d0024994c4661807c925e20a018238b3/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3ebd592d0024994c4661807c925e20a018238b3/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=d3ebd592d0024994c4661807c925e20a018238b3", "patch": "@@ -9,7 +9,6 @@ use crate::collect::PlaceholderHirTyCollector;\n use crate::lint;\n use crate::middle::lang_items::SizedTraitLangItem;\n use crate::middle::resolve_lifetime as rl;\n-use crate::namespace::Namespace;\n use crate::require_c_abi_if_c_variadic;\n use crate::util::common::ErrorReported;\n use rustc::lint::builtin::AMBIGUOUS_ASSOCIATED_ITEMS;\n@@ -20,7 +19,7 @@ use rustc::ty::{GenericParamDef, GenericParamDefKind};\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_errors::{pluralize, struct_span_err, Applicability, DiagnosticId};\n use rustc_hir as hir;\n-use rustc_hir::def::{CtorOf, DefKind, Res};\n+use rustc_hir::def::{CtorOf, DefKind, Namespace, Res};\n use rustc_hir::def_id::DefId;\n use rustc_hir::intravisit::Visitor;\n use rustc_hir::print;\n@@ -1109,10 +1108,10 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         trait_def_id: DefId,\n         assoc_name: ast::Ident,\n     ) -> bool {\n-        self.tcx().associated_items(trait_def_id).iter().any(|item| {\n-            item.kind == ty::AssocKind::Type\n-                && self.tcx().hygienic_eq(assoc_name, item.ident, trait_def_id)\n-        })\n+        self.tcx()\n+            .associated_items(trait_def_id)\n+            .find_by_name_and_kind(self.tcx(), assoc_name, ty::AssocKind::Type, trait_def_id)\n+            .is_some()\n     }\n \n     // Returns `true` if a bounds list includes `?Sized`.\n@@ -1345,9 +1344,12 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n \n         let (assoc_ident, def_scope) =\n             tcx.adjust_ident_and_get_scope(binding.item_name, candidate.def_id(), hir_ref_id);\n+\n+        // We have already adjusted the item name above, so compare with `ident.modern()` instead\n+        // of calling `filter_by_name_and_kind`.\n         let assoc_ty = tcx\n             .associated_items(candidate.def_id())\n-            .iter()\n+            .filter_by_name_unhygienic(assoc_ident.name)\n             .find(|i| i.kind == ty::AssocKind::Type && i.ident.modern() == assoc_ident)\n             .expect(\"missing associated type\");\n \n@@ -1513,7 +1515,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                     ty::Predicate::Trait(pred, _) => {\n                         associated_types.entry(span).or_default().extend(\n                             tcx.associated_items(pred.def_id())\n-                                .iter()\n+                                .in_definition_order()\n                                 .filter(|item| item.kind == ty::AssocKind::Type)\n                                 .map(|item| item.def_id),\n                         );\n@@ -1968,14 +1970,11 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n \n             let mut where_bounds = vec![];\n             for bound in bounds {\n+                let bound_id = bound.def_id();\n                 let bound_span = self\n                     .tcx()\n-                    .associated_items(bound.def_id())\n-                    .iter()\n-                    .find(|item| {\n-                        item.kind == ty::AssocKind::Type\n-                            && self.tcx().hygienic_eq(assoc_name, item.ident, bound.def_id())\n-                    })\n+                    .associated_items(bound_id)\n+                    .find_by_name_and_kind(self.tcx(), assoc_name, ty::AssocKind::Type, bound_id)\n                     .and_then(|item| self.tcx().hir().span_if_local(item.def_id));\n \n                 if let Some(bound_span) = bound_span {\n@@ -2053,7 +2052,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         );\n \n         let all_candidate_names: Vec<_> = all_candidates()\n-            .map(|r| self.tcx().associated_items(r.def_id()))\n+            .map(|r| self.tcx().associated_items(r.def_id()).in_definition_order())\n             .flatten()\n             .filter_map(\n                 |item| if item.kind == ty::AssocKind::Type { Some(item.ident.name) } else { None },\n@@ -2199,10 +2198,13 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         let trait_did = bound.def_id();\n         let (assoc_ident, def_scope) =\n             tcx.adjust_ident_and_get_scope(assoc_ident, trait_did, hir_ref_id);\n+\n+        // We have already adjusted the item name above, so compare with `ident.modern()` instead\n+        // of calling `filter_by_name_and_kind`.\n         let item = tcx\n             .associated_items(trait_did)\n-            .iter()\n-            .find(|i| Namespace::from(i.kind) == Namespace::Type && i.ident.modern() == assoc_ident)\n+            .in_definition_order()\n+            .find(|i| i.kind.namespace() == Namespace::TypeNS && i.ident.modern() == assoc_ident)\n             .expect(\"missing associated type\");\n \n         let ty = self.projected_ty_from_poly_trait_ref(span, item.def_id, assoc_segment, bound);"}, {"sha": "816de5dadbc1501e62dd0a6022635c95cf738638", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d3ebd592d0024994c4661807c925e20a018238b3/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3ebd592d0024994c4661807c925e20a018238b3/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=d3ebd592d0024994c4661807c925e20a018238b3", "patch": "@@ -248,7 +248,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         if is_gen {\n             // Check that we deduce the signature from the `<_ as std::ops::Generator>::Return`\n             // associated item and not yield.\n-            let return_assoc_item = self.tcx.associated_items(gen_trait)[1].def_id;\n+            let return_assoc_item =\n+                self.tcx.associated_items(gen_trait).in_definition_order().nth(1).unwrap().def_id;\n             if return_assoc_item != projection.projection_def_id() {\n                 debug!(\"deduce_sig_from_projection: not return assoc item of generator\");\n                 return None;\n@@ -673,7 +674,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         // The `Future` trait has only one associted item, `Output`,\n         // so check that this is what we see.\n-        let output_assoc_item = self.tcx.associated_items(future_trait)[0].def_id;\n+        let output_assoc_item =\n+            self.tcx.associated_items(future_trait).in_definition_order().nth(0).unwrap().def_id;\n         if output_assoc_item != predicate.projection_ty.item_def_id {\n             span_bug!(\n                 cause_span,"}, {"sha": "63ebf612964e0326e04e6c28a1460fb519f57732", "filename": "src/librustc_typeck/check/demand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d3ebd592d0024994c4661807c925e20a018238b3/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3ebd592d0024994c4661807c925e20a018238b3/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs?ref=d3ebd592d0024994c4661807c925e20a018238b3", "patch": "@@ -539,7 +539,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 let item_def_id = self\n                     .tcx\n                     .associated_items(deref_trait)\n-                    .iter()\n+                    .in_definition_order()\n                     .find(|item| item.kind == ty::AssocKind::Type)\n                     .unwrap()\n                     .def_id;"}, {"sha": "de824648a25d9ec366df0cee0b36eba9a27b0e6f", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/d3ebd592d0024994c4661807c925e20a018238b3/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3ebd592d0024994c4661807c925e20a018238b3/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=d3ebd592d0024994c4661807c925e20a018238b3", "patch": "@@ -11,15 +11,14 @@ pub use self::CandidateSource::*;\n pub use self::MethodError::*;\n \n use crate::check::FnCtxt;\n-use crate::namespace::Namespace;\n use rustc::ty::subst::Subst;\n use rustc::ty::subst::{InternalSubsts, SubstsRef};\n use rustc::ty::GenericParamDefKind;\n use rustc::ty::{self, ToPolyTraitRef, ToPredicate, TraitRef, Ty, TypeFoldable, WithConstness};\n use rustc_data_structures::sync::Lrc;\n use rustc_errors::{Applicability, DiagnosticBuilder};\n use rustc_hir as hir;\n-use rustc_hir::def::{CtorOf, DefKind};\n+use rustc_hir::def::{CtorOf, DefKind, Namespace};\n use rustc_hir::def_id::DefId;\n use rustc_infer::infer::{self, InferOk};\n use rustc_infer::traits;\n@@ -342,7 +341,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // Trait must have a method named `m_name` and it should not have\n         // type parameters or early-bound regions.\n         let tcx = self.tcx;\n-        let method_item = match self.associated_item(trait_def_id, m_name, Namespace::Value) {\n+        let method_item = match self.associated_item(trait_def_id, m_name, Namespace::ValueNS) {\n             Some(method_item) => method_item,\n             None => {\n                 tcx.sess.delay_span_bug(\n@@ -484,11 +483,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     ) -> Option<ty::AssocItem> {\n         self.tcx\n             .associated_items(def_id)\n-            .iter()\n-            .find(|item| {\n-                Namespace::from(item.kind) == ns\n-                    && self.tcx.hygienic_eq(item_name, item.ident, def_id)\n-            })\n+            .find_by_name_and_namespace(self.tcx, item_name, ns, def_id)\n             .copied()\n     }\n }"}, {"sha": "ea90aef486839d3a8fb8ff8319c809ed9ff6e3f6", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d3ebd592d0024994c4661807c925e20a018238b3/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3ebd592d0024994c4661807c925e20a018238b3/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=d3ebd592d0024994c4661807c925e20a018238b3", "patch": "@@ -7,7 +7,6 @@ use crate::check::autoderef::{self, Autoderef};\n use crate::check::FnCtxt;\n use crate::hir::def::DefKind;\n use crate::hir::def_id::DefId;\n-use crate::namespace::Namespace;\n \n use rustc::lint;\n use rustc::middle::stability;\n@@ -22,6 +21,7 @@ use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::sync::Lrc;\n use rustc_errors::struct_span_err;\n use rustc_hir as hir;\n+use rustc_hir::def::Namespace;\n use rustc_infer::infer::canonical::OriginalQueryValues;\n use rustc_infer::infer::canonical::{Canonical, QueryResponse};\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n@@ -1696,20 +1696,20 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n                 let max_dist = max(name.as_str().len(), 3) / 3;\n                 self.tcx\n                     .associated_items(def_id)\n-                    .iter()\n+                    .in_definition_order()\n                     .filter(|x| {\n                         let dist = lev_distance(&*name.as_str(), &x.ident.as_str());\n-                        Namespace::from(x.kind) == Namespace::Value && dist > 0 && dist <= max_dist\n+                        x.kind.namespace() == Namespace::ValueNS && dist > 0 && dist <= max_dist\n                     })\n                     .copied()\n                     .collect()\n             } else {\n                 self.fcx\n-                    .associated_item(def_id, name, Namespace::Value)\n+                    .associated_item(def_id, name, Namespace::ValueNS)\n                     .map_or(Vec::new(), |x| vec![x])\n             }\n         } else {\n-            self.tcx.associated_items(def_id).to_vec()\n+            self.tcx.associated_items(def_id).in_definition_order().copied().collect()\n         }\n     }\n }"}, {"sha": "ea83b40a1cb6b1d88bc943b7e1035e7cce7bb755", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/d3ebd592d0024994c4661807c925e20a018238b3/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3ebd592d0024994c4661807c925e20a018238b3/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=d3ebd592d0024994c4661807c925e20a018238b3", "patch": "@@ -3,15 +3,14 @@\n \n use crate::check::FnCtxt;\n use crate::middle::lang_items::FnOnceTraitLangItem;\n-use crate::namespace::Namespace;\n use rustc::hir::map as hir_map;\n use rustc::hir::map::Map;\n use rustc::ty::print::with_crate_prefix;\n use rustc::ty::{self, ToPolyTraitRef, ToPredicate, Ty, TyCtxt, TypeFoldable, WithConstness};\n use rustc_data_structures::fx::FxHashSet;\n use rustc_errors::{pluralize, struct_span_err, Applicability, DiagnosticBuilder};\n use rustc_hir as hir;\n-use rustc_hir::def::{DefKind, Res};\n+use rustc_hir::def::{DefKind, Namespace, Res};\n use rustc_hir::def_id::{DefId, CRATE_DEF_INDEX, LOCAL_CRATE};\n use rustc_hir::intravisit;\n use rustc_hir::{ExprKind, Node, QPath};\n@@ -97,13 +96,13 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         // Provide the best span we can. Use the item, if local to crate, else\n                         // the impl, if local to crate (item may be defaulted), else nothing.\n                         let item = match self\n-                            .associated_item(impl_did, item_name, Namespace::Value)\n+                            .associated_item(impl_did, item_name, Namespace::ValueNS)\n                             .or_else(|| {\n                                 let impl_trait_ref = self.tcx.impl_trait_ref(impl_did)?;\n                                 self.associated_item(\n                                     impl_trait_ref.def_id,\n                                     item_name,\n-                                    Namespace::Value,\n+                                    Namespace::ValueNS,\n                                 )\n                             }) {\n                             Some(item) => item,\n@@ -185,7 +184,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     }\n                     CandidateSource::TraitSource(trait_did) => {\n                         let item =\n-                            match self.associated_item(trait_did, item_name, Namespace::Value) {\n+                            match self.associated_item(trait_did, item_name, Namespace::ValueNS) {\n                                 Some(item) => item,\n                                 None => continue,\n                             };\n@@ -264,7 +263,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     // be used exists at all, and the type is an ambiguous numeric type\n                     // ({integer}/{float}).\n                     let mut candidates = all_traits(self.tcx).into_iter().filter_map(|info| {\n-                        self.associated_item(info.def_id, item_name, Namespace::Value)\n+                        self.associated_item(info.def_id, item_name, Namespace::ValueNS)\n                     });\n                     if let (true, false, SelfSource::MethodCall(expr), Some(_)) = (\n                         actual.is_numeric(),\n@@ -779,7 +778,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 // here).\n                 (type_is_local || info.def_id.is_local())\n                     && self\n-                        .associated_item(info.def_id, item_name, Namespace::Value)\n+                        .associated_item(info.def_id, item_name, Namespace::ValueNS)\n                         .filter(|item| {\n                             // We only want to suggest public or local traits (#45781).\n                             item.vis == ty::Visibility::Public || info.def_id.is_local()"}, {"sha": "4f6eb20e6ebbd77e0f4702f3cb8ea27426adc603", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/d3ebd592d0024994c4661807c925e20a018238b3/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3ebd592d0024994c4661807c925e20a018238b3/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=d3ebd592d0024994c4661807c925e20a018238b3", "patch": "@@ -89,7 +89,6 @@ pub mod writeback;\n \n use crate::astconv::{AstConv, PathSeg};\n use crate::middle::lang_items;\n-use crate::namespace::Namespace;\n use rustc::hir::map::blocks::FnLikeNode;\n use rustc::hir::map::Map;\n use rustc::middle::region;\n@@ -1972,19 +1971,16 @@ fn check_impl_items_against_trait<'tcx>(\n     // Check existing impl methods to see if they are both present in trait\n     // and compatible with trait signature\n     for impl_item in impl_items() {\n+        let namespace = impl_item.kind.namespace();\n         let ty_impl_item = tcx.associated_item(tcx.hir().local_def_id(impl_item.hir_id));\n         let ty_trait_item = tcx\n             .associated_items(impl_trait_ref.def_id)\n-            .iter()\n-            .find(|ac| {\n-                Namespace::from(&impl_item.kind) == Namespace::from(ac.kind)\n-                    && tcx.hygienic_eq(ty_impl_item.ident, ac.ident, impl_trait_ref.def_id)\n-            })\n+            .find_by_name_and_namespace(tcx, ty_impl_item.ident, namespace, impl_trait_ref.def_id)\n             .or_else(|| {\n                 // Not compatible, but needed for the error message\n                 tcx.associated_items(impl_trait_ref.def_id)\n-                    .iter()\n-                    .find(|ac| tcx.hygienic_eq(ty_impl_item.ident, ac.ident, impl_trait_ref.def_id))\n+                    .filter_by_name(tcx, ty_impl_item.ident, impl_trait_ref.def_id)\n+                    .next()\n             });\n \n         // Check that impl definition matches trait definition\n@@ -2088,7 +2084,7 @@ fn check_impl_items_against_trait<'tcx>(\n     let mut missing_items = Vec::new();\n     let mut invalidated_items = Vec::new();\n     let associated_type_overridden = overridden_associated_type.is_some();\n-    for trait_item in tcx.associated_items(impl_trait_ref.def_id) {\n+    for trait_item in tcx.associated_items(impl_trait_ref.def_id).in_definition_order() {\n         let is_implemented = trait_def\n             .ancestors(tcx, impl_id)\n             .leaf_def(tcx, trait_item.ident, trait_item.kind)\n@@ -5265,7 +5261,13 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 // Check for `Future` implementations by constructing a predicate to\n                 // prove: `<T as Future>::Output == U`\n                 let future_trait = self.tcx.lang_items().future_trait().unwrap();\n-                let item_def_id = self.tcx.associated_items(future_trait)[0].def_id;\n+                let item_def_id = self\n+                    .tcx\n+                    .associated_items(future_trait)\n+                    .in_definition_order()\n+                    .nth(0)\n+                    .unwrap()\n+                    .def_id;\n                 let predicate =\n                     ty::Predicate::Projection(ty::Binder::bind(ty::ProjectionPredicate {\n                         // `<T as Future>::Output`"}, {"sha": "fcded27463e92d5860107066e8a77c347c78df9a", "filename": "src/librustc_typeck/coherence/inherent_impls_overlap.rs", "status": "modified", "additions": 44, "deletions": 45, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/d3ebd592d0024994c4661807c925e20a018238b3/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls_overlap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3ebd592d0024994c4661807c925e20a018238b3/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls_overlap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls_overlap.rs?ref=d3ebd592d0024994c4661807c925e20a018238b3", "patch": "@@ -1,5 +1,4 @@\n-use crate::namespace::Namespace;\n-use rustc::ty::{AssocItem, TyCtxt};\n+use rustc::ty::TyCtxt;\n use rustc_errors::struct_span_err;\n use rustc_hir as hir;\n use rustc_hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n@@ -23,18 +22,18 @@ impl InherentOverlapChecker<'tcx> {\n         let impl_items1 = self.tcx.associated_items(impl1);\n         let impl_items2 = self.tcx.associated_items(impl2);\n \n-        for item1 in &impl_items1[..] {\n-            for item2 in &impl_items2[..] {\n-                // Avoid costly `.modern()` calls as much as possible by doing them as late as we\n-                // can. Compare raw symbols first.\n-                if item1.ident.name == item2.ident.name\n-                    && Namespace::from(item1.kind) == Namespace::from(item2.kind)\n-                {\n+        for item1 in impl_items1.in_definition_order() {\n+            let collision = impl_items2\n+                .filter_by_name_unhygienic(item1.ident.name)\n+                .find(|item2| {\n                     // Symbols and namespace match, compare hygienically.\n-                    if item1.ident.modern() == item2.ident.modern() {\n-                        return true;\n-                    }\n-                }\n+                    item1.kind.namespace() == item2.kind.namespace()\n+                        && item1.ident.modern() == item2.ident.modern()\n+                })\n+                .is_some();\n+\n+            if collision {\n+                return true;\n             }\n         }\n \n@@ -47,43 +46,43 @@ impl InherentOverlapChecker<'tcx> {\n         impl2: DefId,\n         overlap: traits::OverlapResult<'_>,\n     ) {\n-        let name_and_namespace =\n-            |assoc: &AssocItem| (assoc.ident.modern(), Namespace::from(assoc.kind));\n-\n         let impl_items1 = self.tcx.associated_items(impl1);\n         let impl_items2 = self.tcx.associated_items(impl2);\n \n-        for item1 in &impl_items1[..] {\n-            let (name, namespace) = name_and_namespace(item1);\n-\n-            for item2 in &impl_items2[..] {\n-                if (name, namespace) == name_and_namespace(item2) {\n-                    let mut err = struct_span_err!(\n-                        self.tcx.sess,\n-                        self.tcx.span_of_impl(item1.def_id).unwrap(),\n-                        E0592,\n-                        \"duplicate definitions with name `{}`\",\n-                        name\n-                    );\n-                    err.span_label(\n-                        self.tcx.span_of_impl(item1.def_id).unwrap(),\n-                        format!(\"duplicate definitions for `{}`\", name),\n-                    );\n-                    err.span_label(\n-                        self.tcx.span_of_impl(item2.def_id).unwrap(),\n-                        format!(\"other definition for `{}`\", name),\n-                    );\n-\n-                    for cause in &overlap.intercrate_ambiguity_causes {\n-                        cause.add_intercrate_ambiguity_hint(&mut err);\n-                    }\n-\n-                    if overlap.involves_placeholder {\n-                        traits::add_placeholder_note(&mut err);\n-                    }\n+        for item1 in impl_items1.in_definition_order() {\n+            let collision = impl_items2.filter_by_name_unhygienic(item1.ident.name).find(|item2| {\n+                // Symbols and namespace match, compare hygienically.\n+                item1.kind.namespace() == item2.kind.namespace()\n+                    && item1.ident.modern() == item2.ident.modern()\n+            });\n+\n+            if let Some(item2) = collision {\n+                let name = item1.ident.modern();\n+                let mut err = struct_span_err!(\n+                    self.tcx.sess,\n+                    self.tcx.span_of_impl(item1.def_id).unwrap(),\n+                    E0592,\n+                    \"duplicate definitions with name `{}`\",\n+                    name\n+                );\n+                err.span_label(\n+                    self.tcx.span_of_impl(item1.def_id).unwrap(),\n+                    format!(\"duplicate definitions for `{}`\", name),\n+                );\n+                err.span_label(\n+                    self.tcx.span_of_impl(item2.def_id).unwrap(),\n+                    format!(\"other definition for `{}`\", name),\n+                );\n+\n+                for cause in &overlap.intercrate_ambiguity_causes {\n+                    cause.add_intercrate_ambiguity_hint(&mut err);\n+                }\n \n-                    err.emit();\n+                if overlap.involves_placeholder {\n+                    traits::add_placeholder_note(&mut err);\n                 }\n+\n+                err.emit();\n             }\n         }\n     }"}, {"sha": "c5f339d6b7648eb0a5192cc9cbc279c07d78f56e", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d3ebd592d0024994c4661807c925e20a018238b3/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3ebd592d0024994c4661807c925e20a018238b3/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=d3ebd592d0024994c4661807c925e20a018238b3", "patch": "@@ -83,7 +83,6 @@ mod collect;\n mod constrained_generic_params;\n mod impl_wf_check;\n mod mem_categorization;\n-mod namespace;\n mod outlives;\n mod structured_errors;\n mod variance;"}, {"sha": "2aa97aa7e6f0bf02fe1bb5462b3d9b049d72dae2", "filename": "src/librustc_typeck/namespace.rs", "status": "removed", "additions": 0, "deletions": 27, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/2c462a2f776b899d46743b1b44eda976e846e61d/src%2Flibrustc_typeck%2Fnamespace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c462a2f776b899d46743b1b44eda976e846e61d/src%2Flibrustc_typeck%2Fnamespace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fnamespace.rs?ref=2c462a2f776b899d46743b1b44eda976e846e61d", "patch": "@@ -1,27 +0,0 @@\n-use rustc::ty;\n-use rustc_hir as hir;\n-\n-// Whether an item exists in the type or value namespace.\n-#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n-pub enum Namespace {\n-    Type,\n-    Value,\n-}\n-\n-impl From<ty::AssocKind> for Namespace {\n-    fn from(a_kind: ty::AssocKind) -> Self {\n-        match a_kind {\n-            ty::AssocKind::OpaqueTy | ty::AssocKind::Type => Namespace::Type,\n-            ty::AssocKind::Const | ty::AssocKind::Method => Namespace::Value,\n-        }\n-    }\n-}\n-\n-impl<'a> From<&'a hir::ImplItemKind<'_>> for Namespace {\n-    fn from(impl_kind: &'a hir::ImplItemKind<'_>) -> Self {\n-        match *impl_kind {\n-            hir::ImplItemKind::OpaqueTy(..) | hir::ImplItemKind::TyAlias(..) => Namespace::Type,\n-            hir::ImplItemKind::Const(..) | hir::ImplItemKind::Method(..) => Namespace::Value,\n-        }\n-    }\n-}"}, {"sha": "4a1e2570d06c56e6620b2e6624bee7cf0606be0d", "filename": "src/librustdoc/clean/blanket_impl.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d3ebd592d0024994c4661807c925e20a018238b3/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3ebd592d0024994c4661807c925e20a018238b3/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs?ref=d3ebd592d0024994c4661807c925e20a018238b3", "patch": "@@ -114,8 +114,7 @@ impl<'a, 'tcx> BlanketImplFinder<'a, 'tcx> {\n                             .cx\n                             .tcx\n                             .associated_items(impl_def_id)\n-                            .iter()\n-                            .copied()\n+                            .in_definition_order()\n                             .collect::<Vec<_>>()\n                             .clean(self.cx),\n                         polarity: None,"}, {"sha": "78222d21b934af7c153cc2a54578a68b4b9b2f1b", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d3ebd592d0024994c4661807c925e20a018238b3/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3ebd592d0024994c4661807c925e20a018238b3/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=d3ebd592d0024994c4661807c925e20a018238b3", "patch": "@@ -190,8 +190,10 @@ pub fn record_extern_fqn(cx: &DocContext<'_>, did: DefId, kind: clean::TypeKind)\n }\n \n pub fn build_external_trait(cx: &DocContext<'_>, did: DefId) -> clean::Trait {\n+    let trait_items =\n+        cx.tcx.associated_items(did).in_definition_order().map(|item| item.clean(cx)).collect();\n+\n     let auto_trait = cx.tcx.trait_def(did).has_auto_impl;\n-    let trait_items = cx.tcx.associated_items(did).iter().map(|item| item.clean(cx)).collect();\n     let predicates = cx.tcx.predicates_of(did);\n     let generics = (cx.tcx.generics_of(did), predicates).clean(cx);\n     let generics = filter_non_trait_generics(did, generics);\n@@ -376,7 +378,7 @@ pub fn build_impl(\n     } else {\n         (\n             tcx.associated_items(did)\n-                .iter()\n+                .in_definition_order()\n                 .filter_map(|item| {\n                     if associated_trait.is_some() || item.vis == ty::Visibility::Public {\n                         Some(item.clean(cx))"}, {"sha": "0b27e5cf8060fc29b5afa8de440030711825868b", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d3ebd592d0024994c4661807c925e20a018238b3/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3ebd592d0024994c4661807c925e20a018238b3/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=d3ebd592d0024994c4661807c925e20a018238b3", "patch": "@@ -95,7 +95,7 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                     .tcx\n                     .inherent_impls(did)\n                     .iter()\n-                    .flat_map(|imp| cx.tcx.associated_items(*imp))\n+                    .flat_map(|imp| cx.tcx.associated_items(*imp).in_definition_order())\n                     .any(|item| item.ident.name == variant_name)\n                 {\n                     return Err(ErrorKind::ResolutionFailure);\n@@ -206,8 +206,8 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                 return cx\n                     .tcx\n                     .associated_items(did)\n-                    .iter()\n-                    .find(|item| item.ident.name == item_name)\n+                    .filter_by_name_unhygienic(item_name)\n+                    .next()\n                     .and_then(|item| match item.kind {\n                         ty::AssocKind::Method => Some(\"method\"),\n                         _ => None,\n@@ -234,7 +234,7 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                         .tcx\n                         .inherent_impls(did)\n                         .iter()\n-                        .flat_map(|imp| cx.tcx.associated_items(*imp))\n+                        .flat_map(|imp| cx.tcx.associated_items(*imp).in_definition_order())\n                         .find(|item| item.ident.name == item_name);\n                     if let Some(item) = item {\n                         let out = match item.kind {"}]}