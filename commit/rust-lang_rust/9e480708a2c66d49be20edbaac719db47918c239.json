{"sha": "9e480708a2c66d49be20edbaac719db47918c239", "node_id": "MDY6Q29tbWl0NzI0NzEyOjllNDgwNzA4YTJjNjZkNDliZTIwZWRiYWFjNzE5ZGI0NzkxOGMyMzk=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-03-14T20:56:00Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-03-15T01:19:08Z"}, "message": "core:: Eliminate str::sbuf. Replace with *u8", "tree": {"sha": "0183cfeb7057dc0b83250acb00b1ffa26067c50a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0183cfeb7057dc0b83250acb00b1ffa26067c50a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9e480708a2c66d49be20edbaac719db47918c239", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9e480708a2c66d49be20edbaac719db47918c239", "html_url": "https://github.com/rust-lang/rust/commit/9e480708a2c66d49be20edbaac719db47918c239", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9e480708a2c66d49be20edbaac719db47918c239/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3864d6d845f6bf9493698606bba2220daede4738", "url": "https://api.github.com/repos/rust-lang/rust/commits/3864d6d845f6bf9493698606bba2220daede4738", "html_url": "https://github.com/rust-lang/rust/commit/3864d6d845f6bf9493698606bba2220daede4738"}], "stats": {"total": 283, "additions": 138, "deletions": 145}, "files": [{"sha": "875a2572c7e3f160cefd619baf10aeb49af7c029", "filename": "src/libcore/os.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9e480708a2c66d49be20edbaac719db47918c239/src%2Flibcore%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e480708a2c66d49be20edbaac719db47918c239/src%2Flibcore%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fos.rs?ref=9e480708a2c66d49be20edbaac719db47918c239", "patch": "@@ -38,8 +38,8 @@ export as_c_charp, fill_charp_buf;\n native mod rustrt {\n     fn rust_env_pairs() -> [str];\n     fn rust_getcwd() -> str;\n-    fn rust_path_is_dir(path: str::sbuf) -> c_int;\n-    fn rust_path_exists(path: str::sbuf) -> c_int;\n+    fn rust_path_is_dir(path: *u8) -> c_int;\n+    fn rust_path_exists(path: *u8) -> c_int;\n     fn rust_list_files(path: str) -> [str];\n     fn rust_process_wait(handle: c_int) -> c_int;\n }\n@@ -66,7 +66,7 @@ fn fill_charp_buf(f: fn(*mutable c_char, size_t) -> bool)\n     let buf = vec::to_mut(vec::from_elem(tmpbuf_sz, 0u8 as c_char));\n     vec::as_mut_buf(buf) { |b|\n         if f(b, tmpbuf_sz as size_t) {\n-            some(str::from_cstr(b as str::sbuf))\n+            some(str::from_cstr(b as *u8))\n         } else {\n             none\n         }"}, {"sha": "cbbafe201df61aee480f6a9b637304dbecffc19f", "filename": "src/libcore/run.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9e480708a2c66d49be20edbaac719db47918c239/src%2Flibcore%2Frun.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e480708a2c66d49be20edbaac719db47918c239/src%2Flibcore%2Frun.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frun.rs?ref=9e480708a2c66d49be20edbaac719db47918c239", "patch": "@@ -1,6 +1,5 @@\n #[doc =\"Process spawning\"];\n import option::{some, none};\n-import str::sbuf;\n import libc::{pid_t, c_void, c_int};\n \n export program;\n@@ -12,7 +11,7 @@ export waitpid;\n \n #[abi = \"cdecl\"]\n native mod rustrt {\n-    fn rust_run_program(argv: *sbuf, envp: *c_void, dir: sbuf,\n+    fn rust_run_program(argv: **u8, envp: *c_void, dir: *u8,\n                         in_fd: c_int, out_fd: c_int, err_fd: c_int)\n         -> pid_t;\n }\n@@ -78,7 +77,7 @@ fn spawn_process(prog: str, args: [str],\n }\n \n fn with_argv<T>(prog: str, args: [str],\n-                cb: fn(*sbuf) -> T) -> T unsafe {\n+                cb: fn(**u8) -> T) -> T unsafe {\n     let mut argptrs = str::as_buf(prog) {|b| [b] };\n     let mut tmps = [];\n     for arg in args {\n@@ -141,7 +140,7 @@ fn with_envp<T>(env: option<[(str,str)]>,\n }\n \n fn with_dirp<T>(d: option<str>,\n-                cb: fn(sbuf) -> T) -> T unsafe {\n+                cb: fn(*u8) -> T) -> T unsafe {\n     alt d {\n       some(dir) { str::as_buf(dir, cb) }\n       none { cb(ptr::null()) }"}, {"sha": "276b16087869fbd05d1335c89c630558fba84025", "filename": "src/libcore/str.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9e480708a2c66d49be20edbaac719db47918c239/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e480708a2c66d49be20edbaac719db47918c239/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=9e480708a2c66d49be20edbaac719db47918c239", "patch": "@@ -90,7 +90,6 @@ export\n    char_at,\n    as_bytes,\n    as_buf,\n-   sbuf,\n    reserve,\n \n    unsafe;\n@@ -184,7 +183,7 @@ fn from_chars(chs: [char]) -> str {\n }\n \n #[doc = \"Create a Rust string from a null-terminated C string\"]\n-fn from_cstr(cstr: sbuf) -> str unsafe {\n+fn from_cstr(cstr: *u8) -> str unsafe {\n     let mut curr = cstr, i = 0u;\n     while *curr != 0u8 {\n         i += 1u;\n@@ -194,7 +193,7 @@ fn from_cstr(cstr: sbuf) -> str unsafe {\n }\n \n #[doc = \"Create a Rust string from a C string of the given length\"]\n-fn from_cstr_len(cstr: sbuf, len: uint) -> str unsafe {\n+fn from_cstr_len(cstr: *u8, len: uint) -> str unsafe {\n     let mut buf: [u8] = [];\n     vec::reserve(buf, len + 1u);\n     vec::as_buf(buf) {|b| ptr::memcpy(b, cstr, len); }\n@@ -1248,13 +1247,10 @@ interop.\n let s = str::as_buf(\\\"PATH\\\", { |path_buf| libc::getenv(path_buf) });\n ```\n \"]\n-fn as_buf<T>(s: str, f: fn(sbuf) -> T) -> T unsafe {\n+fn as_buf<T>(s: str, f: fn(*u8) -> T) -> T unsafe {\n     as_bytes(s) { |v| vec::as_buf(v, f) }\n }\n \n-#[doc = \"An unsafe buffer of bytes\"]\n-type sbuf = *u8;\n-\n #[doc = \"Allocate more memory for a string, up to `nn` + 1 bytes\"]\n fn reserve(&ss: str, nn: uint) {\n     rustrt::str_reserve_shared(ss, nn);"}, {"sha": "3f7930f244a7c0da6f26f652367e11a60e048ca6", "filename": "src/rustc/lib/llvm.rs", "status": "modified", "additions": 123, "deletions": 124, "changes": 247, "blob_url": "https://github.com/rust-lang/rust/blob/9e480708a2c66d49be20edbaac719db47918c239/src%2Frustc%2Flib%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e480708a2c66d49be20edbaac719db47918c239/src%2Frustc%2Flib%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Flib%2Fllvm.rs?ref=9e480708a2c66d49be20edbaac719db47918c239", "patch": "@@ -1,4 +1,3 @@\n-import str::sbuf;\n import std::map::hashmap;\n \n import libc::{c_int, c_uint, c_longlong, c_ulonglong};\n@@ -148,28 +147,28 @@ native mod llvm {\n     fn LLVMContextCreate() -> ContextRef;\n     fn LLVMGetGlobalContext() -> ContextRef;\n     fn LLVMContextDispose(C: ContextRef);\n-    fn LLVMGetMDKindIDInContext(C: ContextRef, Name: sbuf, SLen: c_uint) ->\n+    fn LLVMGetMDKindIDInContext(C: ContextRef, Name: *u8, SLen: c_uint) ->\n        c_uint;\n-    fn LLVMGetMDKindID(Name: sbuf, SLen: c_uint) -> c_uint;\n+    fn LLVMGetMDKindID(Name: *u8, SLen: c_uint) -> c_uint;\n \n     /* Create and destroy modules. */\n-    fn LLVMModuleCreateWithNameInContext(ModuleID: sbuf, C: ContextRef) ->\n+    fn LLVMModuleCreateWithNameInContext(ModuleID: *u8, C: ContextRef) ->\n        ModuleRef;\n     fn LLVMDisposeModule(M: ModuleRef);\n \n     /** Data layout. See Module::getDataLayout. */\n-    fn LLVMGetDataLayout(M: ModuleRef) -> sbuf;\n-    fn LLVMSetDataLayout(M: ModuleRef, Triple: sbuf);\n+    fn LLVMGetDataLayout(M: ModuleRef) -> *u8;\n+    fn LLVMSetDataLayout(M: ModuleRef, Triple: *u8);\n \n     /** Target triple. See Module::getTargetTriple. */\n-    fn LLVMGetTarget(M: ModuleRef) -> sbuf;\n-    fn LLVMSetTarget(M: ModuleRef, Triple: sbuf);\n+    fn LLVMGetTarget(M: ModuleRef) -> *u8;\n+    fn LLVMSetTarget(M: ModuleRef, Triple: *u8);\n \n     /** See Module::dump. */\n     fn LLVMDumpModule(M: ModuleRef);\n \n     /** See Module::setModuleInlineAsm. */\n-    fn LLVMSetModuleInlineAsm(M: ModuleRef, Asm: sbuf);\n+    fn LLVMSetModuleInlineAsm(M: ModuleRef, Asm: *u8);\n \n     /** See llvm::LLVMTypeKind::getTypeID. */\n \n@@ -253,8 +252,8 @@ native mod llvm {\n \n     /* Operations on all values */\n     fn LLVMTypeOf(Val: ValueRef) -> TypeRef;\n-    fn LLVMGetValueName(Val: ValueRef) -> sbuf;\n-    fn LLVMSetValueName(Val: ValueRef, Name: sbuf);\n+    fn LLVMGetValueName(Val: ValueRef) -> *u8;\n+    fn LLVMSetValueName(Val: ValueRef, Name: *u8);\n     fn LLVMDumpValue(Val: ValueRef);\n     fn LLVMReplaceAllUsesWith(OldVal: ValueRef, NewVal: ValueRef);\n     fn LLVMHasMetadata(Val: ValueRef) -> c_int;\n@@ -283,39 +282,39 @@ native mod llvm {\n     fn LLVMConstPointerNull(Ty: TypeRef) -> ValueRef;\n \n     /* Operations on metadata */\n-    fn LLVMMDStringInContext(C: ContextRef, Str: sbuf, SLen: c_uint) ->\n+    fn LLVMMDStringInContext(C: ContextRef, Str: *u8, SLen: c_uint) ->\n        ValueRef;\n-    fn LLVMMDString(Str: sbuf, SLen: c_uint) -> ValueRef;\n+    fn LLVMMDString(Str: *u8, SLen: c_uint) -> ValueRef;\n     fn LLVMMDNodeInContext(C: ContextRef, Vals: *ValueRef, Count: c_uint) ->\n        ValueRef;\n     fn LLVMMDNode(Vals: *ValueRef, Count: c_uint) -> ValueRef;\n-    fn LLVMAddNamedMetadataOperand(M: ModuleRef, Str: sbuf,\n+    fn LLVMAddNamedMetadataOperand(M: ModuleRef, Str: *u8,\n                                    Val: ValueRef);\n \n     /* Operations on scalar constants */\n     fn LLVMConstInt(IntTy: TypeRef, N: c_ulonglong, SignExtend: Bool) ->\n        ValueRef;\n     // FIXME: radix is actually u8, but our native layer can't handle this\n     // yet.  lucky for us we're little-endian. Small miracles.\n-    fn LLVMConstIntOfString(IntTy: TypeRef, Text: sbuf, Radix: c_int) ->\n+    fn LLVMConstIntOfString(IntTy: TypeRef, Text: *u8, Radix: c_int) ->\n        ValueRef;\n-    fn LLVMConstIntOfStringAndSize(IntTy: TypeRef, Text: sbuf, SLen: c_uint,\n+    fn LLVMConstIntOfStringAndSize(IntTy: TypeRef, Text: *u8, SLen: c_uint,\n                                    Radix: u8) -> ValueRef;\n     fn LLVMConstReal(RealTy: TypeRef, N: f64) -> ValueRef;\n-    fn LLVMConstRealOfString(RealTy: TypeRef, Text: sbuf) -> ValueRef;\n-    fn LLVMConstRealOfStringAndSize(RealTy: TypeRef, Text: sbuf,\n+    fn LLVMConstRealOfString(RealTy: TypeRef, Text: *u8) -> ValueRef;\n+    fn LLVMConstRealOfStringAndSize(RealTy: TypeRef, Text: *u8,\n                                     SLen: c_uint) -> ValueRef;\n     fn LLVMConstIntGetZExtValue(ConstantVal: ValueRef) -> c_ulonglong;\n     fn LLVMConstIntGetSExtValue(ConstantVal: ValueRef) -> c_longlong;\n \n \n     /* Operations on composite constants */\n-    fn LLVMConstStringInContext(C: ContextRef, Str: sbuf, Length: c_uint,\n+    fn LLVMConstStringInContext(C: ContextRef, Str: *u8, Length: c_uint,\n                                 DontNullTerminate: Bool) -> ValueRef;\n     fn LLVMConstStructInContext(C: ContextRef, ConstantVals: *ValueRef,\n                                 Count: c_uint, Packed: Bool) -> ValueRef;\n \n-    fn LLVMConstString(Str: sbuf, Length: c_uint,\n+    fn LLVMConstString(Str: *u8, Length: c_uint,\n                        DontNullTerminate: Bool) -> ValueRef;\n     fn LLVMConstArray(ElementTy: TypeRef, ConstantVals: *ValueRef,\n                       Length: c_uint) -> ValueRef;\n@@ -417,7 +416,7 @@ native mod llvm {\n     fn LLVMConstInsertValue(AggConstant: ValueRef,\n                             ElementValueConstant: ValueRef, IdxList: *uint,\n                             NumIdx: c_uint) -> ValueRef;\n-    fn LLVMConstInlineAsm(Ty: TypeRef, AsmString: sbuf, Constraints: sbuf,\n+    fn LLVMConstInlineAsm(Ty: TypeRef, AsmString: *u8, Constraints: *u8,\n                           HasSideEffects: Bool, IsAlignStack: Bool) ->\n        ValueRef;\n     fn LLVMBlockAddress(F: ValueRef, BB: BasicBlockRef) -> ValueRef;\n@@ -429,19 +428,19 @@ native mod llvm {\n     fn LLVMIsDeclaration(Global: ValueRef) -> Bool;\n     fn LLVMGetLinkage(Global: ValueRef) -> c_uint;\n     fn LLVMSetLinkage(Global: ValueRef, Link: c_uint);\n-    fn LLVMGetSection(Global: ValueRef) -> sbuf;\n-    fn LLVMSetSection(Global: ValueRef, Section: sbuf);\n+    fn LLVMGetSection(Global: ValueRef) -> *u8;\n+    fn LLVMSetSection(Global: ValueRef, Section: *u8);\n     fn LLVMGetVisibility(Global: ValueRef) -> c_uint;\n     fn LLVMSetVisibility(Global: ValueRef, Viz: c_uint);\n     fn LLVMGetAlignment(Global: ValueRef) -> c_uint;\n     fn LLVMSetAlignment(Global: ValueRef, Bytes: c_uint);\n \n \n     /* Operations on global variables */\n-    fn LLVMAddGlobal(M: ModuleRef, Ty: TypeRef, Name: sbuf) -> ValueRef;\n-    fn LLVMAddGlobalInAddressSpace(M: ModuleRef, Ty: TypeRef, Name: sbuf,\n+    fn LLVMAddGlobal(M: ModuleRef, Ty: TypeRef, Name: *u8) -> ValueRef;\n+    fn LLVMAddGlobalInAddressSpace(M: ModuleRef, Ty: TypeRef, Name: *u8,\n                                    AddressSpace: c_uint) -> ValueRef;\n-    fn LLVMGetNamedGlobal(M: ModuleRef, Name: sbuf) -> ValueRef;\n+    fn LLVMGetNamedGlobal(M: ModuleRef, Name: *u8) -> ValueRef;\n     fn LLVMGetFirstGlobal(M: ModuleRef) -> ValueRef;\n     fn LLVMGetLastGlobal(M: ModuleRef) -> ValueRef;\n     fn LLVMGetNextGlobal(GlobalVar: ValueRef) -> ValueRef;\n@@ -455,25 +454,25 @@ native mod llvm {\n     fn LLVMSetGlobalConstant(GlobalVar: ValueRef, IsConstant: Bool);\n \n     /* Operations on aliases */\n-    fn LLVMAddAlias(M: ModuleRef, Ty: TypeRef, Aliasee: ValueRef, Name: sbuf)\n+    fn LLVMAddAlias(M: ModuleRef, Ty: TypeRef, Aliasee: ValueRef, Name: *u8)\n        -> ValueRef;\n \n     /* Operations on functions */\n-    fn LLVMAddFunction(M: ModuleRef, Name: sbuf, FunctionTy: TypeRef) ->\n+    fn LLVMAddFunction(M: ModuleRef, Name: *u8, FunctionTy: TypeRef) ->\n        ValueRef;\n-    fn LLVMGetNamedFunction(M: ModuleRef, Name: sbuf) -> ValueRef;\n+    fn LLVMGetNamedFunction(M: ModuleRef, Name: *u8) -> ValueRef;\n     fn LLVMGetFirstFunction(M: ModuleRef) -> ValueRef;\n     fn LLVMGetLastFunction(M: ModuleRef) -> ValueRef;\n     fn LLVMGetNextFunction(Fn: ValueRef) -> ValueRef;\n     fn LLVMGetPreviousFunction(Fn: ValueRef) -> ValueRef;\n     fn LLVMDeleteFunction(Fn: ValueRef);\n-    fn LLVMGetOrInsertFunction(M: ModuleRef, Name: sbuf, FunctionTy: TypeRef)\n+    fn LLVMGetOrInsertFunction(M: ModuleRef, Name: *u8, FunctionTy: TypeRef)\n        -> ValueRef;\n     fn LLVMGetIntrinsicID(Fn: ValueRef) -> c_uint;\n     fn LLVMGetFunctionCallConv(Fn: ValueRef) -> c_uint;\n     fn LLVMSetFunctionCallConv(Fn: ValueRef, CC: c_uint);\n-    fn LLVMGetGC(Fn: ValueRef) -> sbuf;\n-    fn LLVMSetGC(Fn: ValueRef, Name: sbuf);\n+    fn LLVMGetGC(Fn: ValueRef) -> *u8;\n+    fn LLVMSetGC(Fn: ValueRef, Name: *u8);\n     fn LLVMAddFunctionAttr(Fn: ValueRef, PA: c_uint, HighPA: c_uint);\n     fn LLVMGetFunctionAttr(Fn: ValueRef) -> c_uint;\n     fn LLVMRemoveFunctionAttr(Fn: ValueRef, PA: c_uint, HighPA: c_uint);\n@@ -505,13 +504,13 @@ native mod llvm {\n     fn LLVMGetPreviousBasicBlock(BB: BasicBlockRef) -> BasicBlockRef;\n     fn LLVMGetEntryBasicBlock(Fn: ValueRef) -> BasicBlockRef;\n \n-    fn LLVMAppendBasicBlockInContext(C: ContextRef, Fn: ValueRef, Name: sbuf)\n+    fn LLVMAppendBasicBlockInContext(C: ContextRef, Fn: ValueRef, Name: *u8)\n        -> BasicBlockRef;\n     fn LLVMInsertBasicBlockInContext(C: ContextRef, BB: BasicBlockRef,\n-                                     Name: sbuf) -> BasicBlockRef;\n+                                     Name: *u8) -> BasicBlockRef;\n \n-    fn LLVMAppendBasicBlock(Fn: ValueRef, Name: sbuf) -> BasicBlockRef;\n-    fn LLVMInsertBasicBlock(InsertBeforeBB: BasicBlockRef, Name: sbuf) ->\n+    fn LLVMAppendBasicBlock(Fn: ValueRef, Name: *u8) -> BasicBlockRef;\n+    fn LLVMInsertBasicBlock(InsertBeforeBB: BasicBlockRef, Name: *u8) ->\n        BasicBlockRef;\n     fn LLVMDeleteBasicBlock(BB: BasicBlockRef);\n \n@@ -554,7 +553,7 @@ native mod llvm {\n     fn LLVMClearInsertionPosition(Builder: BuilderRef);\n     fn LLVMInsertIntoBuilder(Builder: BuilderRef, Instr: ValueRef);\n     fn LLVMInsertIntoBuilderWithName(Builder: BuilderRef, Instr: ValueRef,\n-                                     Name: sbuf);\n+                                     Name: *u8);\n     fn LLVMDisposeBuilder(Builder: BuilderRef);\n \n     /* Metadata */\n@@ -576,9 +575,9 @@ native mod llvm {\n                            NumDests: c_uint) -> ValueRef;\n     fn LLVMBuildInvoke(B: BuilderRef, Fn: ValueRef, Args: *ValueRef,\n                        NumArgs: c_uint, Then: BasicBlockRef,\n-                       Catch: BasicBlockRef, Name: sbuf) -> ValueRef;\n+                       Catch: BasicBlockRef, Name: *u8) -> ValueRef;\n     fn LLVMBuildLandingPad(B: BuilderRef, Ty: TypeRef, PersFn: ValueRef,\n-                           NumClauses: c_uint, Name: sbuf) -> ValueRef;\n+                           NumClauses: c_uint, Name: *u8) -> ValueRef;\n     fn LLVMBuildResume(B: BuilderRef, Exn: ValueRef) -> ValueRef;\n     fn LLVMBuildUnreachable(B: BuilderRef) -> ValueRef;\n \n@@ -595,169 +594,169 @@ native mod llvm {\n     fn LLVMSetCleanup(LandingPad: ValueRef, Val: Bool);\n \n     /* Arithmetic */\n-    fn LLVMBuildAdd(B: BuilderRef, LHS: ValueRef, RHS: ValueRef, Name: sbuf)\n+    fn LLVMBuildAdd(B: BuilderRef, LHS: ValueRef, RHS: ValueRef, Name: *u8)\n        -> ValueRef;\n     fn LLVMBuildNSWAdd(B: BuilderRef, LHS: ValueRef, RHS: ValueRef,\n-                       Name: sbuf) -> ValueRef;\n+                       Name: *u8) -> ValueRef;\n     fn LLVMBuildNUWAdd(B: BuilderRef, LHS: ValueRef, RHS: ValueRef,\n-                       Name: sbuf) -> ValueRef;\n-    fn LLVMBuildFAdd(B: BuilderRef, LHS: ValueRef, RHS: ValueRef, Name: sbuf)\n+                       Name: *u8) -> ValueRef;\n+    fn LLVMBuildFAdd(B: BuilderRef, LHS: ValueRef, RHS: ValueRef, Name: *u8)\n        -> ValueRef;\n-    fn LLVMBuildSub(B: BuilderRef, LHS: ValueRef, RHS: ValueRef, Name: sbuf)\n+    fn LLVMBuildSub(B: BuilderRef, LHS: ValueRef, RHS: ValueRef, Name: *u8)\n        -> ValueRef;\n     fn LLVMBuildNSWSub(B: BuilderRef, LHS: ValueRef, RHS: ValueRef,\n-                       Name: sbuf) -> ValueRef;\n+                       Name: *u8) -> ValueRef;\n     fn LLVMBuildNUWSub(B: BuilderRef, LHS: ValueRef, RHS: ValueRef,\n-                       Name: sbuf) -> ValueRef;\n-    fn LLVMBuildFSub(B: BuilderRef, LHS: ValueRef, RHS: ValueRef, Name: sbuf)\n+                       Name: *u8) -> ValueRef;\n+    fn LLVMBuildFSub(B: BuilderRef, LHS: ValueRef, RHS: ValueRef, Name: *u8)\n        -> ValueRef;\n-    fn LLVMBuildMul(B: BuilderRef, LHS: ValueRef, RHS: ValueRef, Name: sbuf)\n+    fn LLVMBuildMul(B: BuilderRef, LHS: ValueRef, RHS: ValueRef, Name: *u8)\n        -> ValueRef;\n     fn LLVMBuildNSWMul(B: BuilderRef, LHS: ValueRef, RHS: ValueRef,\n-                       Name: sbuf) -> ValueRef;\n+                       Name: *u8) -> ValueRef;\n     fn LLVMBuildNUWMul(B: BuilderRef, LHS: ValueRef, RHS: ValueRef,\n-                       Name: sbuf) -> ValueRef;\n-    fn LLVMBuildFMul(B: BuilderRef, LHS: ValueRef, RHS: ValueRef, Name: sbuf)\n+                       Name: *u8) -> ValueRef;\n+    fn LLVMBuildFMul(B: BuilderRef, LHS: ValueRef, RHS: ValueRef, Name: *u8)\n        -> ValueRef;\n-    fn LLVMBuildUDiv(B: BuilderRef, LHS: ValueRef, RHS: ValueRef, Name: sbuf)\n+    fn LLVMBuildUDiv(B: BuilderRef, LHS: ValueRef, RHS: ValueRef, Name: *u8)\n        -> ValueRef;\n-    fn LLVMBuildSDiv(B: BuilderRef, LHS: ValueRef, RHS: ValueRef, Name: sbuf)\n+    fn LLVMBuildSDiv(B: BuilderRef, LHS: ValueRef, RHS: ValueRef, Name: *u8)\n        -> ValueRef;\n     fn LLVMBuildExactSDiv(B: BuilderRef, LHS: ValueRef, RHS: ValueRef,\n-                          Name: sbuf) -> ValueRef;\n-    fn LLVMBuildFDiv(B: BuilderRef, LHS: ValueRef, RHS: ValueRef, Name: sbuf)\n+                          Name: *u8) -> ValueRef;\n+    fn LLVMBuildFDiv(B: BuilderRef, LHS: ValueRef, RHS: ValueRef, Name: *u8)\n        -> ValueRef;\n-    fn LLVMBuildURem(B: BuilderRef, LHS: ValueRef, RHS: ValueRef, Name: sbuf)\n+    fn LLVMBuildURem(B: BuilderRef, LHS: ValueRef, RHS: ValueRef, Name: *u8)\n        -> ValueRef;\n-    fn LLVMBuildSRem(B: BuilderRef, LHS: ValueRef, RHS: ValueRef, Name: sbuf)\n+    fn LLVMBuildSRem(B: BuilderRef, LHS: ValueRef, RHS: ValueRef, Name: *u8)\n        -> ValueRef;\n-    fn LLVMBuildFRem(B: BuilderRef, LHS: ValueRef, RHS: ValueRef, Name: sbuf)\n+    fn LLVMBuildFRem(B: BuilderRef, LHS: ValueRef, RHS: ValueRef, Name: *u8)\n        -> ValueRef;\n-    fn LLVMBuildShl(B: BuilderRef, LHS: ValueRef, RHS: ValueRef, Name: sbuf)\n+    fn LLVMBuildShl(B: BuilderRef, LHS: ValueRef, RHS: ValueRef, Name: *u8)\n        -> ValueRef;\n-    fn LLVMBuildLShr(B: BuilderRef, LHS: ValueRef, RHS: ValueRef, Name: sbuf)\n+    fn LLVMBuildLShr(B: BuilderRef, LHS: ValueRef, RHS: ValueRef, Name: *u8)\n        -> ValueRef;\n-    fn LLVMBuildAShr(B: BuilderRef, LHS: ValueRef, RHS: ValueRef, Name: sbuf)\n+    fn LLVMBuildAShr(B: BuilderRef, LHS: ValueRef, RHS: ValueRef, Name: *u8)\n        -> ValueRef;\n-    fn LLVMBuildAnd(B: BuilderRef, LHS: ValueRef, RHS: ValueRef, Name: sbuf)\n+    fn LLVMBuildAnd(B: BuilderRef, LHS: ValueRef, RHS: ValueRef, Name: *u8)\n        -> ValueRef;\n-    fn LLVMBuildOr(B: BuilderRef, LHS: ValueRef, RHS: ValueRef, Name: sbuf) ->\n+    fn LLVMBuildOr(B: BuilderRef, LHS: ValueRef, RHS: ValueRef, Name: *u8) ->\n        ValueRef;\n-    fn LLVMBuildXor(B: BuilderRef, LHS: ValueRef, RHS: ValueRef, Name: sbuf)\n+    fn LLVMBuildXor(B: BuilderRef, LHS: ValueRef, RHS: ValueRef, Name: *u8)\n        -> ValueRef;\n     fn LLVMBuildBinOp(B: BuilderRef, Op: Opcode, LHS: ValueRef, RHS: ValueRef,\n-                      Name: sbuf) -> ValueRef;\n-    fn LLVMBuildNeg(B: BuilderRef, V: ValueRef, Name: sbuf) -> ValueRef;\n-    fn LLVMBuildNSWNeg(B: BuilderRef, V: ValueRef, Name: sbuf) -> ValueRef;\n-    fn LLVMBuildNUWNeg(B: BuilderRef, V: ValueRef, Name: sbuf) -> ValueRef;\n-    fn LLVMBuildFNeg(B: BuilderRef, V: ValueRef, Name: sbuf) -> ValueRef;\n-    fn LLVMBuildNot(B: BuilderRef, V: ValueRef, Name: sbuf) -> ValueRef;\n+                      Name: *u8) -> ValueRef;\n+    fn LLVMBuildNeg(B: BuilderRef, V: ValueRef, Name: *u8) -> ValueRef;\n+    fn LLVMBuildNSWNeg(B: BuilderRef, V: ValueRef, Name: *u8) -> ValueRef;\n+    fn LLVMBuildNUWNeg(B: BuilderRef, V: ValueRef, Name: *u8) -> ValueRef;\n+    fn LLVMBuildFNeg(B: BuilderRef, V: ValueRef, Name: *u8) -> ValueRef;\n+    fn LLVMBuildNot(B: BuilderRef, V: ValueRef, Name: *u8) -> ValueRef;\n \n     /* Memory */\n-    fn LLVMBuildMalloc(B: BuilderRef, Ty: TypeRef, Name: sbuf) -> ValueRef;\n+    fn LLVMBuildMalloc(B: BuilderRef, Ty: TypeRef, Name: *u8) -> ValueRef;\n     fn LLVMBuildArrayMalloc(B: BuilderRef, Ty: TypeRef, Val: ValueRef,\n-                            Name: sbuf) -> ValueRef;\n-    fn LLVMBuildAlloca(B: BuilderRef, Ty: TypeRef, Name: sbuf) -> ValueRef;\n+                            Name: *u8) -> ValueRef;\n+    fn LLVMBuildAlloca(B: BuilderRef, Ty: TypeRef, Name: *u8) -> ValueRef;\n     fn LLVMBuildArrayAlloca(B: BuilderRef, Ty: TypeRef, Val: ValueRef,\n-                            Name: sbuf) -> ValueRef;\n+                            Name: *u8) -> ValueRef;\n     fn LLVMBuildFree(B: BuilderRef, PointerVal: ValueRef) -> ValueRef;\n-    fn LLVMBuildLoad(B: BuilderRef, PointerVal: ValueRef, Name: sbuf) ->\n+    fn LLVMBuildLoad(B: BuilderRef, PointerVal: ValueRef, Name: *u8) ->\n        ValueRef;\n     fn LLVMBuildStore(B: BuilderRef, Val: ValueRef, Ptr: ValueRef) ->\n        ValueRef;\n     fn LLVMBuildGEP(B: BuilderRef, Pointer: ValueRef, Indices: *ValueRef,\n-                    NumIndices: c_uint, Name: sbuf) -> ValueRef;\n+                    NumIndices: c_uint, Name: *u8) -> ValueRef;\n     fn LLVMBuildInBoundsGEP(B: BuilderRef, Pointer: ValueRef,\n                             Indices: *ValueRef, NumIndices: c_uint,\n-                            Name: sbuf)\n+                            Name: *u8)\n        -> ValueRef;\n     fn LLVMBuildStructGEP(B: BuilderRef, Pointer: ValueRef, Idx: c_uint,\n-                          Name: sbuf) -> ValueRef;\n-    fn LLVMBuildGlobalString(B: BuilderRef, Str: sbuf, Name: sbuf) ->\n+                          Name: *u8) -> ValueRef;\n+    fn LLVMBuildGlobalString(B: BuilderRef, Str: *u8, Name: *u8) ->\n        ValueRef;\n-    fn LLVMBuildGlobalStringPtr(B: BuilderRef, Str: sbuf, Name: sbuf) ->\n+    fn LLVMBuildGlobalStringPtr(B: BuilderRef, Str: *u8, Name: *u8) ->\n        ValueRef;\n \n     /* Casts */\n     fn LLVMBuildTrunc(B: BuilderRef, Val: ValueRef, DestTy: TypeRef,\n-                      Name: sbuf) -> ValueRef;\n+                      Name: *u8) -> ValueRef;\n     fn LLVMBuildZExt(B: BuilderRef, Val: ValueRef, DestTy: TypeRef,\n-                     Name: sbuf) -> ValueRef;\n+                     Name: *u8) -> ValueRef;\n     fn LLVMBuildSExt(B: BuilderRef, Val: ValueRef, DestTy: TypeRef,\n-                     Name: sbuf) -> ValueRef;\n+                     Name: *u8) -> ValueRef;\n     fn LLVMBuildFPToUI(B: BuilderRef, Val: ValueRef, DestTy: TypeRef,\n-                       Name: sbuf) -> ValueRef;\n+                       Name: *u8) -> ValueRef;\n     fn LLVMBuildFPToSI(B: BuilderRef, Val: ValueRef, DestTy: TypeRef,\n-                       Name: sbuf) -> ValueRef;\n+                       Name: *u8) -> ValueRef;\n     fn LLVMBuildUIToFP(B: BuilderRef, Val: ValueRef, DestTy: TypeRef,\n-                       Name: sbuf) -> ValueRef;\n+                       Name: *u8) -> ValueRef;\n     fn LLVMBuildSIToFP(B: BuilderRef, Val: ValueRef, DestTy: TypeRef,\n-                       Name: sbuf) -> ValueRef;\n+                       Name: *u8) -> ValueRef;\n     fn LLVMBuildFPTrunc(B: BuilderRef, Val: ValueRef, DestTy: TypeRef,\n-                        Name: sbuf) -> ValueRef;\n+                        Name: *u8) -> ValueRef;\n     fn LLVMBuildFPExt(B: BuilderRef, Val: ValueRef, DestTy: TypeRef,\n-                      Name: sbuf) -> ValueRef;\n+                      Name: *u8) -> ValueRef;\n     fn LLVMBuildPtrToInt(B: BuilderRef, Val: ValueRef, DestTy: TypeRef,\n-                         Name: sbuf) -> ValueRef;\n+                         Name: *u8) -> ValueRef;\n     fn LLVMBuildIntToPtr(B: BuilderRef, Val: ValueRef, DestTy: TypeRef,\n-                         Name: sbuf) -> ValueRef;\n+                         Name: *u8) -> ValueRef;\n     fn LLVMBuildBitCast(B: BuilderRef, Val: ValueRef, DestTy: TypeRef,\n-                        Name: sbuf) -> ValueRef;\n+                        Name: *u8) -> ValueRef;\n     fn LLVMBuildZExtOrBitCast(B: BuilderRef, Val: ValueRef, DestTy: TypeRef,\n-                              Name: sbuf) -> ValueRef;\n+                              Name: *u8) -> ValueRef;\n     fn LLVMBuildSExtOrBitCast(B: BuilderRef, Val: ValueRef, DestTy: TypeRef,\n-                              Name: sbuf) -> ValueRef;\n+                              Name: *u8) -> ValueRef;\n     fn LLVMBuildTruncOrBitCast(B: BuilderRef, Val: ValueRef, DestTy: TypeRef,\n-                               Name: sbuf) -> ValueRef;\n+                               Name: *u8) -> ValueRef;\n     fn LLVMBuildCast(B: BuilderRef, Op: Opcode, Val: ValueRef,\n-                     DestTy: TypeRef, Name: sbuf) -> ValueRef;\n+                     DestTy: TypeRef, Name: *u8) -> ValueRef;\n     fn LLVMBuildPointerCast(B: BuilderRef, Val: ValueRef, DestTy: TypeRef,\n-                            Name: sbuf) -> ValueRef;\n+                            Name: *u8) -> ValueRef;\n     fn LLVMBuildIntCast(B: BuilderRef, Val: ValueRef, DestTy: TypeRef,\n-                        Name: sbuf) -> ValueRef;\n+                        Name: *u8) -> ValueRef;\n     fn LLVMBuildFPCast(B: BuilderRef, Val: ValueRef, DestTy: TypeRef,\n-                       Name: sbuf) -> ValueRef;\n+                       Name: *u8) -> ValueRef;\n \n     /* Comparisons */\n     fn LLVMBuildICmp(B: BuilderRef, Op: c_uint, LHS: ValueRef,\n-                     RHS: ValueRef, Name: sbuf) -> ValueRef;\n+                     RHS: ValueRef, Name: *u8) -> ValueRef;\n     fn LLVMBuildFCmp(B: BuilderRef, Op: c_uint, LHS: ValueRef,\n-                     RHS: ValueRef, Name: sbuf) -> ValueRef;\n+                     RHS: ValueRef, Name: *u8) -> ValueRef;\n \n     /* Miscellaneous instructions */\n-    fn LLVMBuildPhi(B: BuilderRef, Ty: TypeRef, Name: sbuf) -> ValueRef;\n+    fn LLVMBuildPhi(B: BuilderRef, Ty: TypeRef, Name: *u8) -> ValueRef;\n     fn LLVMBuildCall(B: BuilderRef, Fn: ValueRef, Args: *ValueRef,\n-                     NumArgs: c_uint, Name: sbuf) -> ValueRef;\n+                     NumArgs: c_uint, Name: *u8) -> ValueRef;\n     fn LLVMBuildSelect(B: BuilderRef, If: ValueRef, Then: ValueRef,\n-                       Else: ValueRef, Name: sbuf) -> ValueRef;\n-    fn LLVMBuildVAArg(B: BuilderRef, list: ValueRef, Ty: TypeRef, Name: sbuf)\n+                       Else: ValueRef, Name: *u8) -> ValueRef;\n+    fn LLVMBuildVAArg(B: BuilderRef, list: ValueRef, Ty: TypeRef, Name: *u8)\n        -> ValueRef;\n     fn LLVMBuildExtractElement(B: BuilderRef, VecVal: ValueRef,\n-                               Index: ValueRef, Name: sbuf) -> ValueRef;\n+                               Index: ValueRef, Name: *u8) -> ValueRef;\n     fn LLVMBuildInsertElement(B: BuilderRef, VecVal: ValueRef,\n-                              EltVal: ValueRef, Index: ValueRef, Name: sbuf)\n+                              EltVal: ValueRef, Index: ValueRef, Name: *u8)\n        -> ValueRef;\n     fn LLVMBuildShuffleVector(B: BuilderRef, V1: ValueRef, V2: ValueRef,\n-                              Mask: ValueRef, Name: sbuf) -> ValueRef;\n+                              Mask: ValueRef, Name: *u8) -> ValueRef;\n     fn LLVMBuildExtractValue(B: BuilderRef, AggVal: ValueRef, Index: c_uint,\n-                             Name: sbuf) -> ValueRef;\n+                             Name: *u8) -> ValueRef;\n     fn LLVMBuildInsertValue(B: BuilderRef, AggVal: ValueRef, EltVal: ValueRef,\n-                            Index: c_uint, Name: sbuf) -> ValueRef;\n+                            Index: c_uint, Name: *u8) -> ValueRef;\n \n-    fn LLVMBuildIsNull(B: BuilderRef, Val: ValueRef, Name: sbuf) -> ValueRef;\n-    fn LLVMBuildIsNotNull(B: BuilderRef, Val: ValueRef, Name: sbuf) ->\n+    fn LLVMBuildIsNull(B: BuilderRef, Val: ValueRef, Name: *u8) -> ValueRef;\n+    fn LLVMBuildIsNotNull(B: BuilderRef, Val: ValueRef, Name: *u8) ->\n        ValueRef;\n     fn LLVMBuildPtrDiff(B: BuilderRef, LHS: ValueRef, RHS: ValueRef,\n-                        Name: sbuf) -> ValueRef;\n+                        Name: *u8) -> ValueRef;\n \n     /* Selected entries from the downcasts. */\n     fn LLVMIsATerminatorInst(Inst: ValueRef) -> ValueRef;\n \n     /** Writes a module to the specified path. Returns 0 on success. */\n-    fn LLVMWriteBitcodeToFile(M: ModuleRef, Path: sbuf) -> c_int;\n+    fn LLVMWriteBitcodeToFile(M: ModuleRef, Path: *u8) -> c_int;\n \n     /** Creates target data from a target layout string. */\n-    fn LLVMCreateTargetData(StringRep: sbuf) -> TargetDataRef;\n+    fn LLVMCreateTargetData(StringRep: *u8) -> TargetDataRef;\n     /** Adds the target data to the given pass manager. The pass manager\n         references the target data only weakly. */\n     fn LLVMAddTargetData(TD: TargetDataRef, PM: PassManagerRef);\n@@ -857,46 +856,46 @@ native mod llvm {\n     /** Moves the section iterator to point to the next section. */\n     fn LLVMMoveToNextSection(SI: SectionIteratorRef);\n     /** Returns the current section name. */\n-    fn LLVMGetSectionName(SI: SectionIteratorRef) -> sbuf;\n+    fn LLVMGetSectionName(SI: SectionIteratorRef) -> *u8;\n     /** Returns the current section size. */\n     fn LLVMGetSectionSize(SI: SectionIteratorRef) -> c_ulonglong;\n     /** Returns the current section contents as a string buffer. */\n-    fn LLVMGetSectionContents(SI: SectionIteratorRef) -> sbuf;\n+    fn LLVMGetSectionContents(SI: SectionIteratorRef) -> *u8;\n \n     /** Reads the given file and returns it as a memory buffer. Use\n         LLVMDisposeMemoryBuffer() to get rid of it. */\n-    fn LLVMRustCreateMemoryBufferWithContentsOfFile(Path: sbuf) ->\n+    fn LLVMRustCreateMemoryBufferWithContentsOfFile(Path: *u8) ->\n        MemoryBufferRef;\n \n     /* FIXME: The FileType is an enum.*/\n-    fn LLVMRustWriteOutputFile(PM: PassManagerRef, M: ModuleRef, Triple: sbuf,\n-                               Output: sbuf, FileType: c_int, OptLevel: c_int,\n+    fn LLVMRustWriteOutputFile(PM: PassManagerRef, M: ModuleRef, Triple: *u8,\n+                               Output: *u8, FileType: c_int, OptLevel: c_int,\n                                EnableSegmentedStacks: bool);\n \n     /** Returns a string describing the last error caused by an LLVMRust*\n         call. */\n-    fn LLVMRustGetLastError() -> sbuf;\n+    fn LLVMRustGetLastError() -> *u8;\n \n     /** Parses the bitcode in the given memory buffer. */\n     fn LLVMRustParseBitcode(MemBuf: MemoryBufferRef) -> ModuleRef;\n \n     /** Parses LLVM asm in the given file */\n-    fn LLVMRustParseAssemblyFile(Filename: sbuf) -> ModuleRef;\n+    fn LLVMRustParseAssemblyFile(Filename: *u8) -> ModuleRef;\n \n     /** FiXME: Hacky adaptor for lack of c_ulonglong in FFI: */\n     fn LLVMRustConstInt(IntTy: TypeRef, N_hi: c_uint, N_lo: c_uint,\n                         SignExtend: Bool) -> ValueRef;\n \n     fn LLVMRustAddPrintModulePass(PM: PassManagerRef, M: ModuleRef,\n-                                  Output: sbuf);\n+                                  Output: *u8);\n \n     /** Turn on LLVM pass-timing. */\n     fn LLVMRustEnableTimePasses();\n \n     /** Print the pass timings since static dtors aren't picking them up. */\n     fn LLVMRustPrintPassTimings();\n \n-    fn LLVMStructCreateNamed(C: ContextRef, Name: sbuf) -> TypeRef;\n+    fn LLVMStructCreateNamed(C: ContextRef, Name: *u8) -> TypeRef;\n \n     fn LLVMStructSetBody(StructTy: TypeRef, ElementTypes: *TypeRef,\n                          ElementCount: c_uint, Packed: Bool);"}, {"sha": "7371c962ac1e351d647f9b6149645a1620bbf0b0", "filename": "src/rustc/middle/trans/build.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9e480708a2c66d49be20edbaac719db47918c239/src%2Frustc%2Fmiddle%2Ftrans%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e480708a2c66d49be20edbaac719db47918c239/src%2Frustc%2Fmiddle%2Ftrans%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fbuild.rs?ref=9e480708a2c66d49be20edbaac719db47918c239", "patch": "@@ -1,5 +1,4 @@\n import libc::{c_uint, c_int};\n-import str::sbuf;\n import lib::llvm::llvm;\n import syntax::codemap;\n import codemap::span;\n@@ -83,7 +82,7 @@ fn IndirectBr(cx: block, Addr: ValueRef, NumDests: uint) {\n \n // This is a really awful way to get a zero-length c-string, but better (and a\n // lot more efficient) than doing str::as_buf(\"\", ...) every time.\n-fn noname() -> sbuf unsafe {\n+fn noname() -> *u8 unsafe {\n     const cnull: uint = 0u;\n     ret unsafe::reinterpret_cast(ptr::addr_of(cnull));\n }\n@@ -360,12 +359,12 @@ fn StructGEP(cx: block, Pointer: ValueRef, Idx: uint) -> ValueRef {\n     ret llvm::LLVMBuildStructGEP(B(cx), Pointer, Idx as c_uint, noname());\n }\n \n-fn GlobalString(cx: block, _Str: sbuf) -> ValueRef {\n+fn GlobalString(cx: block, _Str: *u8) -> ValueRef {\n     if cx.unreachable { ret llvm::LLVMGetUndef(T_ptr(T_i8())); }\n     ret llvm::LLVMBuildGlobalString(B(cx), _Str, noname());\n }\n \n-fn GlobalStringPtr(cx: block, _Str: sbuf) -> ValueRef {\n+fn GlobalStringPtr(cx: block, _Str: *u8) -> ValueRef {\n     if cx.unreachable { ret llvm::LLVMGetUndef(T_ptr(T_i8())); }\n     ret llvm::LLVMBuildGlobalStringPtr(B(cx), _Str, noname());\n }\n@@ -450,7 +449,7 @@ fn TruncOrBitCast(cx: block, Val: ValueRef, DestTy: TypeRef) ->\n }\n \n fn Cast(cx: block, Op: Opcode, Val: ValueRef, DestTy: TypeRef,\n-        _Name: sbuf) -> ValueRef {\n+        _Name: *u8) -> ValueRef {\n     if cx.unreachable { ret llvm::LLVMGetUndef(DestTy); }\n     ret llvm::LLVMBuildCast(B(cx), Op, Val, DestTy, noname());\n }"}, {"sha": "162657d4190480a744690727f457faece0b325b9", "filename": "src/test/run-pass/c-stack-returning-int64.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9e480708a2c66d49be20edbaac719db47918c239/src%2Ftest%2Frun-pass%2Fc-stack-returning-int64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e480708a2c66d49be20edbaac719db47918c239/src%2Ftest%2Frun-pass%2Fc-stack-returning-int64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fc-stack-returning-int64.rs?ref=9e480708a2c66d49be20edbaac719db47918c239", "patch": "@@ -4,8 +4,8 @@ import str;\n #[abi = \"cdecl\"]\n #[nolink]\n native mod libc {\n-    fn atol(x: str::sbuf) -> int;\n-    fn atoll(x: str::sbuf) -> i64;\n+    fn atol(x: *u8) -> int;\n+    fn atoll(x: *u8) -> i64;\n }\n \n fn atol(s: str) -> int {"}]}