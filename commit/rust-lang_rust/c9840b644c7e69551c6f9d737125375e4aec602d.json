{"sha": "c9840b644c7e69551c6f9d737125375e4aec602d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM5ODQwYjY0NGM3ZTY5NTUxYzZmOWQ3MzcxMjUzNzVlNGFlYzYwMmQ=", "commit": {"author": {"name": "Kang Seonghoon", "email": "public+git@mearie.org", "date": "2015-03-01T02:57:20Z"}, "committer": {"name": "Kang Seonghoon", "email": "public+git@mearie.org", "date": "2015-03-03T02:55:36Z"}, "message": "metadata: Introduce implicit lengths for auto-serialization.\n\nMany auto-serialization tags are fixed-size (note: many ordinary\ntags are also fixed-size but for now this commit ignores them),\nso having an explicit length is a waste. This moves any\nauto-serialization tags with an implicit length before other tags,\nso a test for them is easy. A preliminary experiment shows this\nhas at least 1% gain over the status quo.", "tree": {"sha": "ec10ce42d74c4ae3cda4fad9afd776931c126950", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ec10ce42d74c4ae3cda4fad9afd776931c126950"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c9840b644c7e69551c6f9d737125375e4aec602d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c9840b644c7e69551c6f9d737125375e4aec602d", "html_url": "https://github.com/rust-lang/rust/commit/c9840b644c7e69551c6f9d737125375e4aec602d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c9840b644c7e69551c6f9d737125375e4aec602d/comments", "author": {"login": "lifthrasiir", "id": 323836, "node_id": "MDQ6VXNlcjMyMzgzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/323836?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lifthrasiir", "html_url": "https://github.com/lifthrasiir", "followers_url": "https://api.github.com/users/lifthrasiir/followers", "following_url": "https://api.github.com/users/lifthrasiir/following{/other_user}", "gists_url": "https://api.github.com/users/lifthrasiir/gists{/gist_id}", "starred_url": "https://api.github.com/users/lifthrasiir/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lifthrasiir/subscriptions", "organizations_url": "https://api.github.com/users/lifthrasiir/orgs", "repos_url": "https://api.github.com/users/lifthrasiir/repos", "events_url": "https://api.github.com/users/lifthrasiir/events{/privacy}", "received_events_url": "https://api.github.com/users/lifthrasiir/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lifthrasiir", "id": 323836, "node_id": "MDQ6VXNlcjMyMzgzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/323836?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lifthrasiir", "html_url": "https://github.com/lifthrasiir", "followers_url": "https://api.github.com/users/lifthrasiir/followers", "following_url": "https://api.github.com/users/lifthrasiir/following{/other_user}", "gists_url": "https://api.github.com/users/lifthrasiir/gists{/gist_id}", "starred_url": "https://api.github.com/users/lifthrasiir/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lifthrasiir/subscriptions", "organizations_url": "https://api.github.com/users/lifthrasiir/orgs", "repos_url": "https://api.github.com/users/lifthrasiir/repos", "events_url": "https://api.github.com/users/lifthrasiir/events{/privacy}", "received_events_url": "https://api.github.com/users/lifthrasiir/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "38a965a747cb5998cce85369aa30a53062dcf363", "url": "https://api.github.com/repos/rust-lang/rust/commits/38a965a747cb5998cce85369aa30a53062dcf363", "html_url": "https://github.com/rust-lang/rust/commit/38a965a747cb5998cce85369aa30a53062dcf363"}], "stats": {"total": 173, "additions": 121, "deletions": 52}, "files": [{"sha": "a2fe71f0b4b2cfa15170af182c8df29bf2bc2575", "filename": "src/librbml/lib.rs", "status": "modified", "additions": 121, "deletions": 52, "changes": 173, "blob_url": "https://github.com/rust-lang/rust/blob/c9840b644c7e69551c6f9d737125375e4aec602d/src%2Flibrbml%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9840b644c7e69551c6f9d737125375e4aec602d/src%2Flibrbml%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrbml%2Flib.rs?ref=c9840b644c7e69551c6f9d737125375e4aec602d", "patch": "@@ -80,38 +80,56 @@ pub struct TaggedDoc<'a> {\n \n #[derive(Copy, Debug)]\n pub enum EbmlEncoderTag {\n-    EsUint,     // 0\n-    EsU64,      // 1\n-    EsU32,      // 2\n-    EsU16,      // 3\n-    EsU8,       // 4\n-    EsInt,      // 5\n-    EsI64,      // 6\n-    EsI32,      // 7\n-    EsI16,      // 8\n-    EsI8,       // 9\n-    EsBool,     // 10\n-    EsChar,     // 11\n-    EsStr,      // 12\n-    EsF64,      // 13\n-    EsF32,      // 14\n-    EsFloat,    // 15\n-    EsEnum,     // 16\n-    EsEnumVid,  // 17\n-    EsEnumBody, // 18\n-    EsVec,      // 19\n-    EsVecLen,   // 20\n-    EsVecElt,   // 21\n-    EsMap,      // 22\n-    EsMapLen,   // 23\n-    EsMapKey,   // 24\n-    EsMapVal,   // 25\n-\n-    EsOpaque,\n-\n-    EsLabel, // Used only when debugging\n+    // tags 00..1f are reserved for auto-serialization.\n+    // first NUM_IMPLICIT_TAGS tags are implicitly sized and lengths are not encoded.\n+\n+    EsUint     = 0x00, // + 8 bytes\n+    EsU64      = 0x01, // + 8 bytes\n+    EsU32      = 0x02, // + 4 bytes\n+    EsU16      = 0x03, // + 2 bytes\n+    EsU8       = 0x04, // + 1 byte\n+    EsInt      = 0x05, // + 8 bytes\n+    EsI64      = 0x06, // + 8 bytes\n+    EsI32      = 0x07, // + 4 bytes\n+    EsI16      = 0x08, // + 2 bytes\n+    EsI8       = 0x09, // + 1 byte\n+    EsBool     = 0x0a, // + 1 byte\n+    EsChar     = 0x0b, // + 4 bytes\n+    EsF64      = 0x0c, // + 8 bytes\n+    EsF32      = 0x0d, // + 4 bytes\n+    EsEnumVid  = 0x0e, // + 4 bytes\n+    EsVecLen   = 0x0f, // + 4 bytes\n+    EsMapLen   = 0x10, // + 4 bytes\n+\n+    EsStr      = 0x11,\n+    EsEnum     = 0x12,\n+    EsEnumBody = 0x13,\n+    EsVec      = 0x14,\n+    EsVecElt   = 0x15,\n+    EsMap      = 0x16,\n+    EsMapKey   = 0x17,\n+    EsMapVal   = 0x18,\n+\n+    EsOpaque   = 0x19,\n+\n+    // Used only when debugging\n+    EsLabel    = 0x1a,\n }\n \n+const NUM_TAGS: uint = 0x1000;\n+const NUM_IMPLICIT_TAGS: uint = 0x11;\n+\n+static TAG_IMPLICIT_LEN: [i8; NUM_IMPLICIT_TAGS] = [\n+    8, 8, 4, 2, 1, // EsU*\n+    8, 8, 4, 2, 1, // ESI*\n+    1, // EsBool\n+    4, // EsChar\n+    8, 4, // EsF*\n+    4, // EsEnumVid\n+    4, // EsVecLen\n+    4, // EsMapLen\n+];\n+\n #[derive(Debug)]\n pub enum Error {\n     IntTooBig(uint),\n@@ -143,7 +161,7 @@ pub mod reader {\n         EsMapLen, EsMapKey, EsEnumVid, EsU64, EsU32, EsU16, EsU8, EsInt, EsI64,\n         EsI32, EsI16, EsI8, EsBool, EsF64, EsF32, EsChar, EsStr, EsMapVal,\n         EsEnumBody, EsUint, EsOpaque, EsLabel, EbmlEncoderTag, Doc, TaggedDoc,\n-        Error, IntTooBig, InvalidTag, Expected };\n+        Error, IntTooBig, InvalidTag, Expected, NUM_IMPLICIT_TAGS, TAG_IMPLICIT_LEN };\n \n     pub type DecodeResult<T> = Result<T, Error>;\n     // rbml reading\n@@ -250,9 +268,17 @@ pub mod reader {\n         }\n     }\n \n+    pub fn tag_len_at(data: &[u8], tag: Res) -> DecodeResult<Res> {\n+        if tag.val < NUM_IMPLICIT_TAGS && TAG_IMPLICIT_LEN[tag.val] >= 0 {\n+            Ok(Res { val: TAG_IMPLICIT_LEN[tag.val] as uint, next: tag.next })\n+        } else {\n+            vuint_at(data, tag.next)\n+        }\n+    }\n+\n     pub fn doc_at<'a>(data: &'a [u8], start: uint) -> DecodeResult<TaggedDoc<'a>> {\n         let elt_tag = try!(tag_at(data, start));\n-        let elt_size = try!(vuint_at(data, elt_tag.next));\n+        let elt_size = try!(tag_len_at(data, elt_tag));\n         let end = elt_size.next + elt_size.val;\n         Ok(TaggedDoc {\n             tag: elt_tag.val,\n@@ -264,7 +290,7 @@ pub mod reader {\n         let mut pos = d.start;\n         while pos < d.end {\n             let elt_tag = try_or!(tag_at(d.data, pos), None);\n-            let elt_size = try_or!(vuint_at(d.data, elt_tag.next), None);\n+            let elt_size = try_or!(tag_len_at(d.data, elt_tag), None);\n             pos = elt_size.next + elt_size.val;\n             if elt_tag.val == tg {\n                 return Some(Doc { data: d.data, start: elt_size.next,\n@@ -290,7 +316,7 @@ pub mod reader {\n         let mut pos = d.start;\n         while pos < d.end {\n             let elt_tag = try_or!(tag_at(d.data, pos), false);\n-            let elt_size = try_or!(vuint_at(d.data, elt_tag.next), false);\n+            let elt_size = try_or!(tag_len_at(d.data, elt_tag), false);\n             pos = elt_size.next + elt_size.val;\n             let doc = Doc { data: d.data, start: elt_size.next, end: pos };\n             if !it(elt_tag.val, doc) {\n@@ -306,7 +332,7 @@ pub mod reader {\n         let mut pos = d.start;\n         while pos < d.end {\n             let elt_tag = try_or!(tag_at(d.data, pos), false);\n-            let elt_size = try_or!(vuint_at(d.data, elt_tag.next), false);\n+            let elt_size = try_or!(tag_len_at(d.data, elt_tag), false);\n             pos = elt_size.next + elt_size.val;\n             if elt_tag.val == tg {\n                 let doc = Doc { data: d.data, start: elt_size.next,\n@@ -718,7 +744,7 @@ pub mod writer {\n     use super::{ EsVec, EsMap, EsEnum, EsVecLen, EsVecElt, EsMapLen, EsMapKey,\n         EsEnumVid, EsU64, EsU32, EsU16, EsU8, EsInt, EsI64, EsI32, EsI16, EsI8,\n         EsBool, EsF64, EsF32, EsChar, EsStr, EsMapVal, EsEnumBody, EsUint,\n-        EsOpaque, EsLabel, EbmlEncoderTag };\n+        EsOpaque, EsLabel, EbmlEncoderTag, NUM_IMPLICIT_TAGS, NUM_TAGS };\n \n     use serialize;\n \n@@ -734,7 +760,7 @@ pub mod writer {\n     fn write_tag<W: Writer>(w: &mut W, n: uint) -> EncodeResult {\n         if n < 0xf0 {\n             w.write_all(&[n as u8])\n-        } else if 0x100 <= n && n < 0x1000 {\n+        } else if 0x100 <= n && n < NUM_TAGS {\n             w.write_all(&[0xf0 | (n >> 8) as u8, n as u8])\n         } else {\n             Err(old_io::IoError {\n@@ -791,6 +817,7 @@ pub mod writer {\n \n         pub fn start_tag(&mut self, tag_id: uint) -> EncodeResult {\n             debug!(\"Start tag {:?}\", tag_id);\n+            assert!(tag_id >= NUM_IMPLICIT_TAGS);\n \n             // Write the enum ID:\n             try!(write_tag(self.writer, tag_id));\n@@ -822,6 +849,7 @@ pub mod writer {\n         }\n \n         pub fn wr_tagged_bytes(&mut self, tag_id: uint, b: &[u8]) -> EncodeResult {\n+            assert!(tag_id >= NUM_IMPLICIT_TAGS);\n             try!(write_tag(self.writer, tag_id));\n             try!(write_vuint(self.writer, b.len()));\n             self.writer.write_all(b)\n@@ -866,6 +894,47 @@ pub mod writer {\n             self.wr_tagged_bytes(tag_id, v.as_bytes())\n         }\n \n+        // for auto-serialization\n+        fn wr_tagged_raw_bytes(&mut self, tag_id: uint, b: &[u8]) -> EncodeResult {\n+            try!(write_tag(self.writer, tag_id));\n+            self.writer.write_all(b)\n+        }\n+\n+        fn wr_tagged_raw_u64(&mut self, tag_id: uint, v: u64) -> EncodeResult {\n+            let bytes: [u8; 8] = unsafe { mem::transmute(v.to_be()) };\n+            self.wr_tagged_raw_bytes(tag_id, &bytes)\n+        }\n+\n+        fn wr_tagged_raw_u32(&mut self, tag_id: uint, v: u32)  -> EncodeResult{\n+            let bytes: [u8; 4] = unsafe { mem::transmute(v.to_be()) };\n+            self.wr_tagged_raw_bytes(tag_id, &bytes)\n+        }\n+\n+        fn wr_tagged_raw_u16(&mut self, tag_id: uint, v: u16) -> EncodeResult {\n+            let bytes: [u8; 2] = unsafe { mem::transmute(v.to_be()) };\n+            self.wr_tagged_raw_bytes(tag_id, &bytes)\n+        }\n+\n+        fn wr_tagged_raw_u8(&mut self, tag_id: uint, v: u8) -> EncodeResult {\n+            self.wr_tagged_raw_bytes(tag_id, &[v])\n+        }\n+\n+        fn wr_tagged_raw_i64(&mut self, tag_id: uint, v: i64) -> EncodeResult {\n+            self.wr_tagged_raw_u64(tag_id, v as u64)\n+        }\n+\n+        fn wr_tagged_raw_i32(&mut self, tag_id: uint, v: i32) -> EncodeResult {\n+            self.wr_tagged_raw_u32(tag_id, v as u32)\n+        }\n+\n+        fn wr_tagged_raw_i16(&mut self, tag_id: uint, v: i16) -> EncodeResult {\n+            self.wr_tagged_raw_u16(tag_id, v as u16)\n+        }\n+\n+        fn wr_tagged_raw_i8(&mut self, tag_id: uint, v: i8) -> EncodeResult {\n+            self.wr_tagged_raw_bytes(tag_id, &[v as u8])\n+        }\n+\n         pub fn wr_bytes(&mut self, b: &[u8]) -> EncodeResult {\n             debug!(\"Write {:?} bytes\", b.len());\n             self.writer.write_all(b)\n@@ -891,7 +960,7 @@ pub mod writer {\n         // used internally to emit things like the vector length and so on\n         fn _emit_tagged_uint(&mut self, t: EbmlEncoderTag, v: uint) -> EncodeResult {\n             assert!(v <= 0xFFFF_FFFF);\n-            self.wr_tagged_u32(t as uint, v as u32)\n+            self.wr_tagged_raw_u32(t as uint, v as u32)\n         }\n \n         fn _emit_label(&mut self, label: &str) -> EncodeResult {\n@@ -922,51 +991,51 @@ pub mod writer {\n         }\n \n         fn emit_uint(&mut self, v: uint) -> EncodeResult {\n-            self.wr_tagged_u64(EsUint as uint, v as u64)\n+            self.wr_tagged_raw_u64(EsUint as uint, v as u64)\n         }\n         fn emit_u64(&mut self, v: u64) -> EncodeResult {\n-            self.wr_tagged_u64(EsU64 as uint, v)\n+            self.wr_tagged_raw_u64(EsU64 as uint, v)\n         }\n         fn emit_u32(&mut self, v: u32) -> EncodeResult {\n-            self.wr_tagged_u32(EsU32 as uint, v)\n+            self.wr_tagged_raw_u32(EsU32 as uint, v)\n         }\n         fn emit_u16(&mut self, v: u16) -> EncodeResult {\n-            self.wr_tagged_u16(EsU16 as uint, v)\n+            self.wr_tagged_raw_u16(EsU16 as uint, v)\n         }\n         fn emit_u8(&mut self, v: u8) -> EncodeResult {\n-            self.wr_tagged_u8(EsU8 as uint, v)\n+            self.wr_tagged_raw_u8(EsU8 as uint, v)\n         }\n \n         fn emit_int(&mut self, v: int) -> EncodeResult {\n-            self.wr_tagged_i64(EsInt as uint, v as i64)\n+            self.wr_tagged_raw_i64(EsInt as uint, v as i64)\n         }\n         fn emit_i64(&mut self, v: i64) -> EncodeResult {\n-            self.wr_tagged_i64(EsI64 as uint, v)\n+            self.wr_tagged_raw_i64(EsI64 as uint, v)\n         }\n         fn emit_i32(&mut self, v: i32) -> EncodeResult {\n-            self.wr_tagged_i32(EsI32 as uint, v)\n+            self.wr_tagged_raw_i32(EsI32 as uint, v)\n         }\n         fn emit_i16(&mut self, v: i16) -> EncodeResult {\n-            self.wr_tagged_i16(EsI16 as uint, v)\n+            self.wr_tagged_raw_i16(EsI16 as uint, v)\n         }\n         fn emit_i8(&mut self, v: i8) -> EncodeResult {\n-            self.wr_tagged_i8(EsI8 as uint, v)\n+            self.wr_tagged_raw_i8(EsI8 as uint, v)\n         }\n \n         fn emit_bool(&mut self, v: bool) -> EncodeResult {\n-            self.wr_tagged_u8(EsBool as uint, v as u8)\n+            self.wr_tagged_raw_u8(EsBool as uint, v as u8)\n         }\n \n         fn emit_f64(&mut self, v: f64) -> EncodeResult {\n             let bits = unsafe { mem::transmute(v) };\n-            self.wr_tagged_u64(EsF64 as uint, bits)\n+            self.wr_tagged_raw_u64(EsF64 as uint, bits)\n         }\n         fn emit_f32(&mut self, v: f32) -> EncodeResult {\n             let bits = unsafe { mem::transmute(v) };\n-            self.wr_tagged_u32(EsF32 as uint, bits)\n+            self.wr_tagged_raw_u32(EsF32 as uint, bits)\n         }\n         fn emit_char(&mut self, v: char) -> EncodeResult {\n-            self.wr_tagged_u32(EsChar as uint, v as u32)\n+            self.wr_tagged_raw_u32(EsChar as uint, v as u32)\n         }\n \n         fn emit_str(&mut self, v: &str) -> EncodeResult {"}]}