{"sha": "0cd1516696550e108863bf4b4fb81ce5c4f58968", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBjZDE1MTY2OTY1NTBlMTA4ODYzYmY0YjRmYjgxY2U1YzRmNTg5Njg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-11-03T13:48:54Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-11-03T13:48:54Z"}, "message": "Auto merge of #78597 - RalfJung:raw-retag, r=oli-obk\n\nRetagging: do not retag 'raw reborrows'\n\nWhen doing `&raw const (*raw_ptr).field`, we do not want any retagging; the original provenance should be fully preserved.\n\nFixes https://github.com/rust-lang/miri/issues/1608\nTest added by https://github.com/rust-lang/miri/pull/1614\n\nNot sure whom to ask for review on this... `@oli-obk` can you have a look? Or maybe highfive makes a good choice.^^", "tree": {"sha": "861e2357a9ed0ea9dbf351805d3595712ff946b8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/861e2357a9ed0ea9dbf351805d3595712ff946b8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0cd1516696550e108863bf4b4fb81ce5c4f58968", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0cd1516696550e108863bf4b4fb81ce5c4f58968", "html_url": "https://github.com/rust-lang/rust/commit/0cd1516696550e108863bf4b4fb81ce5c4f58968", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0cd1516696550e108863bf4b4fb81ce5c4f58968/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8e8939b8045b7af6076fb718e2e298844aaf4650", "url": "https://api.github.com/repos/rust-lang/rust/commits/8e8939b8045b7af6076fb718e2e298844aaf4650", "html_url": "https://github.com/rust-lang/rust/commit/8e8939b8045b7af6076fb718e2e298844aaf4650"}, {"sha": "289c0d8489d02c1bc5cb0b091455fe03cd9384bd", "url": "https://api.github.com/repos/rust-lang/rust/commits/289c0d8489d02c1bc5cb0b091455fe03cd9384bd", "html_url": "https://github.com/rust-lang/rust/commit/289c0d8489d02c1bc5cb0b091455fe03cd9384bd"}], "stats": {"total": 26, "additions": 20, "deletions": 6}, "files": [{"sha": "6fe9f64be32e8257298b5d327557e8b738bc5db9", "filename": "compiler/rustc_mir/src/transform/add_retag.rs", "status": "modified", "additions": 20, "deletions": 6, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/0cd1516696550e108863bf4b4fb81ce5c4f58968/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fadd_retag.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0cd1516696550e108863bf4b4fb81ce5c4f58968/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fadd_retag.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fadd_retag.rs?ref=0cd1516696550e108863bf4b4fb81ce5c4f58968", "patch": "@@ -73,6 +73,19 @@ impl<'tcx> MirPass<'tcx> for AddRetag {\n             // a temporary and retag on that.\n             is_stable(place.as_ref()) && may_be_reference(place.ty(&*local_decls, tcx).ty)\n         };\n+        let place_base_raw = |place: &Place<'tcx>| {\n+            // If this is a `Deref`, get the type of what we are deref'ing.\n+            let deref_base =\n+                place.projection.iter().rposition(|p| matches!(p, ProjectionElem::Deref));\n+            if let Some(deref_base) = deref_base {\n+                let base_proj = &place.projection[..deref_base];\n+                let ty = Place::ty_from(place.local, base_proj, &*local_decls, tcx).ty;\n+                ty.is_unsafe_ptr()\n+            } else {\n+                // Not a deref, and thus not raw.\n+                false\n+            }\n+        };\n \n         // PART 1\n         // Retag arguments at the beginning of the start block.\n@@ -136,13 +149,14 @@ impl<'tcx> MirPass<'tcx> for AddRetag {\n             // iterate backwards using indices.\n             for i in (0..block_data.statements.len()).rev() {\n                 let (retag_kind, place) = match block_data.statements[i].kind {\n-                    // Retag-as-raw after escaping to a raw pointer.\n-                    StatementKind::Assign(box (place, Rvalue::AddressOf(..))) => {\n-                        (RetagKind::Raw, place)\n+                    // Retag-as-raw after escaping to a raw pointer, if the referent\n+                    // is not already a raw pointer.\n+                    StatementKind::Assign(box (lplace, Rvalue::AddressOf(_, ref rplace)))\n+                        if !place_base_raw(rplace) =>\n+                    {\n+                        (RetagKind::Raw, lplace)\n                     }\n-                    // Assignments of reference or ptr type are the ones where we may have\n-                    // to update tags.  This includes `x = &[mut] ...` and hence\n-                    // we also retag after taking a reference!\n+                    // Retag after assignments of reference type.\n                     StatementKind::Assign(box (ref place, ref rvalue)) if needs_retag(place) => {\n                         let kind = match rvalue {\n                             Rvalue::Ref(_, borrow_kind, _)"}]}