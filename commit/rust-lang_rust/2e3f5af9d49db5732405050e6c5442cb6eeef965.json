{"sha": "2e3f5af9d49db5732405050e6c5442cb6eeef965", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJlM2Y1YWY5ZDQ5ZGI1NzMyNDA1MDUwZTZjNTQ0MmNiNmVlZWY5NjU=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-05-28T14:39:01Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-05-28T14:39:01Z"}, "message": "move mbe to the new API", "tree": {"sha": "0bc4e93dc16a53311a9ef98d263251ce168835b3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0bc4e93dc16a53311a9ef98d263251ce168835b3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2e3f5af9d49db5732405050e6c5442cb6eeef965", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2e3f5af9d49db5732405050e6c5442cb6eeef965", "html_url": "https://github.com/rust-lang/rust/commit/2e3f5af9d49db5732405050e6c5442cb6eeef965", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2e3f5af9d49db5732405050e6c5442cb6eeef965/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0efbcdf43544af471a935c790ae99e2a9b5516c3", "url": "https://api.github.com/repos/rust-lang/rust/commits/0efbcdf43544af471a935c790ae99e2a9b5516c3", "html_url": "https://github.com/rust-lang/rust/commit/0efbcdf43544af471a935c790ae99e2a9b5516c3"}], "stats": {"total": 146, "additions": 73, "deletions": 73}, "files": [{"sha": "a0bd0c5f883922dfc0c602f4a72cd8a5309bf3b7", "filename": "crates/ra_mbe/src/mbe_expander.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2e3f5af9d49db5732405050e6c5442cb6eeef965/crates%2Fra_mbe%2Fsrc%2Fmbe_expander.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3f5af9d49db5732405050e6c5442cb6eeef965/crates%2Fra_mbe%2Fsrc%2Fmbe_expander.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_mbe%2Fsrc%2Fmbe_expander.rs?ref=2e3f5af9d49db5732405050e6c5442cb6eeef965", "patch": "@@ -597,7 +597,7 @@ mod tests {\n     }\n \n     fn create_rules(macro_definition: &str) -> crate::MacroRules {\n-        let source_file = ast::SourceFile::parse(macro_definition);\n+        let source_file = ast::SourceFile::parse(macro_definition).ok().unwrap();\n         let macro_definition =\n             source_file.syntax().descendants().find_map(ast::MacroCall::cast).unwrap();\n \n@@ -609,7 +609,7 @@ mod tests {\n         rules: &crate::MacroRules,\n         invocation: &str,\n     ) -> Result<tt::Subtree, ExpandError> {\n-        let source_file = ast::SourceFile::parse(invocation);\n+        let source_file = ast::SourceFile::parse(invocation).ok().unwrap();\n         let macro_invocation =\n             source_file.syntax().descendants().find_map(ast::MacroCall::cast).unwrap();\n "}, {"sha": "d8fe293c74f25485fca225a0566bf12858bb6302", "filename": "crates/ra_mbe/src/mbe_parser.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2e3f5af9d49db5732405050e6c5442cb6eeef965/crates%2Fra_mbe%2Fsrc%2Fmbe_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3f5af9d49db5732405050e6c5442cb6eeef965/crates%2Fra_mbe%2Fsrc%2Fmbe_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_mbe%2Fsrc%2Fmbe_parser.rs?ref=2e3f5af9d49db5732405050e6c5442cb6eeef965", "patch": "@@ -175,7 +175,7 @@ mod tests {\n     }\n \n     fn create_rules(macro_definition: &str) -> Result<crate::MacroRules, ParseError> {\n-        let source_file = ast::SourceFile::parse(macro_definition);\n+        let source_file = ast::SourceFile::parse(macro_definition).ok().unwrap();\n         let macro_definition =\n             source_file.syntax().descendants().find_map(ast::MacroCall::cast).unwrap();\n "}, {"sha": "5e4017f775ce0f0dc549089d2b7bc42d67f4bd00", "filename": "crates/ra_mbe/src/tests.rs", "status": "modified", "additions": 70, "deletions": 70, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/2e3f5af9d49db5732405050e6c5442cb6eeef965/crates%2Fra_mbe%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3f5af9d49db5732405050e6c5442cb6eeef965/crates%2Fra_mbe%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_mbe%2Fsrc%2Ftests.rs?ref=2e3f5af9d49db5732405050e6c5442cb6eeef965", "patch": "@@ -29,11 +29,11 @@ macro_rules! impl_froms {\n impl_froms!(TokenTree: Leaf, Subtree);\n \"#;\n \n-    let source_file = ast::SourceFile::parse(macro_definition);\n+    let source_file = ast::SourceFile::parse(macro_definition).ok().unwrap();\n     let macro_definition =\n         source_file.syntax().descendants().find_map(ast::MacroCall::cast).unwrap();\n \n-    let source_file = ast::SourceFile::parse(macro_invocation);\n+    let source_file = ast::SourceFile::parse(macro_invocation).ok().unwrap();\n     let macro_invocation =\n         source_file.syntax().descendants().find_map(ast::MacroCall::cast).unwrap();\n \n@@ -49,7 +49,7 @@ impl_froms!(TokenTree: Leaf, Subtree);\n }\n \n pub(crate) fn create_rules(macro_definition: &str) -> MacroRules {\n-    let source_file = ast::SourceFile::parse(macro_definition);\n+    let source_file = ast::SourceFile::parse(macro_definition).ok().unwrap();\n     let macro_definition =\n         source_file.syntax().descendants().find_map(ast::MacroCall::cast).unwrap();\n \n@@ -58,7 +58,7 @@ pub(crate) fn create_rules(macro_definition: &str) -> MacroRules {\n }\n \n pub(crate) fn expand(rules: &MacroRules, invocation: &str) -> tt::Subtree {\n-    let source_file = ast::SourceFile::parse(invocation);\n+    let source_file = ast::SourceFile::parse(invocation).ok().unwrap();\n     let macro_invocation =\n         source_file.syntax().descendants().find_map(ast::MacroCall::cast).unwrap();\n \n@@ -95,7 +95,7 @@ pub(crate) fn expand_to_expr(\n pub(crate) fn text_to_tokentree(text: &str) -> tt::Subtree {\n     // wrap the given text to a macro call\n     let wrapped = format!(\"wrap_macro!( {} )\", text);\n-    let wrapped = ast::SourceFile::parse(&wrapped);\n+    let wrapped = ast::SourceFile::parse(&wrapped).ok().unwrap();\n     let wrapped = wrapped.syntax().descendants().find_map(ast::TokenTree::cast).unwrap();\n     let mut wrapped = ast_to_token_tree(wrapped).unwrap().0;\n     wrapped.delimiter = tt::Delimiter::None;\n@@ -294,7 +294,7 @@ fn test_match_group_pattern_with_multiple_defs() {\n         macro_rules! foo {\n             ($ ($ i:ident),*) => ( struct Bar { $ (\n                 fn $ i {}\n-            )*} );            \n+            )*} );\n         }\n \"#,\n     );\n@@ -314,7 +314,7 @@ fn test_match_group_pattern_with_multiple_statement() {\n         macro_rules! foo {\n             ($ ($ i:ident),*) => ( fn baz { $ (\n                 $ i ();\n-            )*} );            \n+            )*} );\n         }\n \"#,\n     );\n@@ -329,7 +329,7 @@ fn test_match_group_pattern_with_multiple_statement_without_semi() {\n         macro_rules! foo {\n             ($ ($ i:ident),*) => ( fn baz { $ (\n                 $i()\n-            );*} );            \n+            );*} );\n         }\n \"#,\n     );\n@@ -344,7 +344,7 @@ fn test_match_group_empty_fixed_token() {\n         macro_rules! foo {\n             ($ ($ i:ident)* #abc) => ( fn baz { $ (\n                 $ i ();\n-            )*} );            \n+            )*} );\n         }\n \"#,\n     );\n@@ -356,10 +356,10 @@ fn test_match_group_empty_fixed_token() {\n fn test_match_group_in_subtree() {\n     let rules = create_rules(\n         r#\"\n-        macro_rules! foo {            \n+        macro_rules! foo {\n             (fn $name:ident {$($i:ident)*} ) => ( fn $name() { $ (\n                 $ i ();\n-            )*} );            \n+            )*} );\n         }\"#,\n     );\n \n@@ -370,8 +370,8 @@ fn test_match_group_in_subtree() {\n fn test_match_group_with_multichar_sep() {\n     let rules = create_rules(\n         r#\"\n-        macro_rules! foo {            \n-            (fn $name:ident {$($i:literal)*} ) => ( fn $name() -> bool { $($i)&&*} );            \n+        macro_rules! foo {\n+            (fn $name:ident {$($i:literal)*} ) => ( fn $name() -> bool { $($i)&&*} );\n         }\"#,\n     );\n \n@@ -387,8 +387,8 @@ fn test_match_group_with_multichar_sep() {\n fn test_match_group_zero_match() {\n     let rules = create_rules(\n         r#\"\n-        macro_rules! foo {            \n-            ( $($i:ident)* ) => ();            \n+        macro_rules! foo {\n+            ( $($i:ident)* ) => ();\n         }\"#,\n     );\n \n@@ -399,7 +399,7 @@ fn test_match_group_zero_match() {\n fn test_match_group_in_group() {\n     let rules = create_rules(\n         r#\"\n-        macro_rules! foo {            \n+        macro_rules! foo {\n             { $( ( $($i:ident)* ) )* } => ( $( ( $($i)* ) )* );\n         }\"#,\n     );\n@@ -651,7 +651,7 @@ fn test_expr() {\n         r#\"\n         macro_rules! foo {\n             ($ i:expr) => {\n-                 fn bar() { $ i; } \n+                 fn bar() { $ i; }\n             }\n         }\n \"#,\n@@ -671,7 +671,7 @@ fn test_expr_order() {\n         r#\"\n         macro_rules! foo {\n             ($ i:expr) => {\n-                 fn bar() { $ i * 2; } \n+                 fn bar() { $ i * 2; }\n             }\n         }\n \"#,\n@@ -896,9 +896,9 @@ fn test_meta_doc_comments() {\n     assert_expansion(\n         MacroKind::Items,\n         &rules,\n-        r#\"foo! { \n+        r#\"foo! {\n             /// Single Line Doc 1\n-            /** \n+            /**\n                 MultiLines Doc\n             */\n         }\"#,\n@@ -984,7 +984,7 @@ macro_rules! foo {\n         bar!($a);\n         fn $b() -> u8 {$c}\n     }\n-}        \n+}\n \"#,\n     );\n     assert_expansion(\n@@ -1119,7 +1119,7 @@ macro_rules! STRUCT {\n     // from https://github.com/retep998/winapi-rs/blob/a7ef2bca086aae76cf6c4ce4c2552988ed9798ad/src/shared/d3d9caps.rs\n     assert_expansion(MacroKind::Items, &rules, r#\"STRUCT!{struct D3DVSHADERCAPS2_0 {Caps: u8,}}\"#,\n         \"# [repr (C)] # [derive (Copy)] pub struct D3DVSHADERCAPS2_0 {pub Caps : u8 ,} impl Clone for D3DVSHADERCAPS2_0 {# [inline] fn clone (& self) -> D3DVSHADERCAPS2_0 {* self}} # [cfg (feature = \\\"impl-default\\\")] impl Default for D3DVSHADERCAPS2_0 {# [inline] fn default () -> D3DVSHADERCAPS2_0 {unsafe {$crate :: _core :: mem :: zeroed ()}}}\");\n-    assert_expansion(MacroKind::Items, &rules, r#\"STRUCT!{#[cfg_attr(target_arch = \"x86\", repr(packed))] struct D3DCONTENTPROTECTIONCAPS {Caps : u8 ,}}\"#, \n+    assert_expansion(MacroKind::Items, &rules, r#\"STRUCT!{#[cfg_attr(target_arch = \"x86\", repr(packed))] struct D3DCONTENTPROTECTIONCAPS {Caps : u8 ,}}\"#,\n         \"# [repr (C)] # [derive (Copy)] # [cfg_attr (target_arch = \\\"x86\\\" , repr (packed))] pub struct D3DCONTENTPROTECTIONCAPS {pub Caps : u8 ,} impl Clone for D3DCONTENTPROTECTIONCAPS {# [inline] fn clone (& self) -> D3DCONTENTPROTECTIONCAPS {* self}} # [cfg (feature = \\\"impl-default\\\")] impl Default for D3DCONTENTPROTECTIONCAPS {# [inline] fn default () -> D3DCONTENTPROTECTIONCAPS {unsafe {$crate :: _core :: mem :: zeroed ()}}}\");\n }\n \n@@ -1136,11 +1136,11 @@ macro_rules! int_base {\n             }\n         }\n     }\n-}            \n+}\n \"#,\n     );\n \n-    assert_expansion(MacroKind::Items, &rules, r#\" int_base!{Binary for isize as usize -> Binary}\"#, \n+    assert_expansion(MacroKind::Items, &rules, r#\" int_base!{Binary for isize as usize -> Binary}\"#,\n         \"# [stable (feature = \\\"rust1\\\" , since = \\\"1.0.0\\\")] impl fmt ::Binary for isize {fn fmt (& self , f : & mut fmt :: Formatter < \\'_ >) -> fmt :: Result {Binary . fmt_int (* self as usize , f)}}\"\n         );\n }\n@@ -1150,7 +1150,7 @@ fn test_generate_pattern_iterators() {\n     // from https://github.com/rust-lang/rust/blob/316a391dcb7d66dc25f1f9a4ec9d368ef7615005/src/libcore/str/mod.rs\n     let rules = create_rules(\n         r#\"\n-macro_rules! generate_pattern_iterators {        \n+macro_rules! generate_pattern_iterators {\n         { double ended; with $(#[$common_stability_attribute:meta])*,\n                            $forward_iterator:ident,\n                            $reverse_iterator:ident, $iterty:ty\n@@ -1161,7 +1161,7 @@ macro_rules! generate_pattern_iterators {\n \"#,\n     );\n \n-    assert_expansion(MacroKind::Items, &rules, r#\"generate_pattern_iterators ! ( double ended ; with # [ stable ( feature = \"rust1\" , since = \"1.0.0\" ) ] , Split , RSplit , & 'a str )\"#, \n+    assert_expansion(MacroKind::Items, &rules, r#\"generate_pattern_iterators ! ( double ended ; with # [ stable ( feature = \"rust1\" , since = \"1.0.0\" ) ] , Split , RSplit , & 'a str )\"#,\n         \"fn foo () {}\");\n }\n \n@@ -1170,7 +1170,7 @@ fn test_impl_fn_for_zst() {\n     // from https://github.com/rust-lang/rust/blob/5d20ff4d2718c820632b38c1e49d4de648a9810b/src/libcore/internal_macros.rs\n     let rules = create_rules(\n         r#\"\n-macro_rules! impl_fn_for_zst  {        \n+macro_rules! impl_fn_for_zst  {\n         {  $( $( #[$attr: meta] )*\n         struct $Name: ident impl$( <$( $lifetime : lifetime ),+> )? Fn =\n             |$( $arg: ident: $ArgTy: ty ),*| -> $ReturnTy: ty\n@@ -1213,22 +1213,22 @@ $body: block; )+\n     );\n \n     assert_expansion(MacroKind::Items, &rules, r#\"\n-impl_fn_for_zst !   { \n-     # [ derive ( Clone ) ] \n-     struct   CharEscapeDebugContinue   impl   Fn   =   | c :   char |   ->   char :: EscapeDebug   { \n-         c . escape_debug_ext ( false ) \n-     } ; \n-\n-     # [ derive ( Clone ) ] \n-     struct   CharEscapeUnicode   impl   Fn   =   | c :   char |   ->   char :: EscapeUnicode   { \n-         c . escape_unicode ( ) \n-     } ; \n-     # [ derive ( Clone ) ] \n-     struct   CharEscapeDefault   impl   Fn   =   | c :   char |   ->   char :: EscapeDefault   { \n-         c . escape_default ( ) \n-     } ; \n+impl_fn_for_zst !   {\n+     # [ derive ( Clone ) ]\n+     struct   CharEscapeDebugContinue   impl   Fn   =   | c :   char |   ->   char :: EscapeDebug   {\n+         c . escape_debug_ext ( false )\n+     } ;\n+\n+     # [ derive ( Clone ) ]\n+     struct   CharEscapeUnicode   impl   Fn   =   | c :   char |   ->   char :: EscapeUnicode   {\n+         c . escape_unicode ( )\n+     } ;\n+     # [ derive ( Clone ) ]\n+     struct   CharEscapeDefault   impl   Fn   =   | c :   char |   ->   char :: EscapeDefault   {\n+         c . escape_default ( )\n+     } ;\n  }\n-\"#, \n+\"#,\n         \"# [derive (Clone)] struct CharEscapeDebugContinue ; impl Fn < (char ,) > for CharEscapeDebugContinue {# [inline] extern \\\"rust-call\\\" fn call (& self , (c ,) : (char ,)) -> char :: EscapeDebug {{c . escape_debug_ext (false)}}} impl FnMut < (char ,) > for CharEscapeDebugContinue {# [inline] extern \\\"rust-call\\\" fn call_mut (& mut self , (c ,) : (char ,)) -> char :: EscapeDebug {Fn :: call (&* self , (c ,))}} impl FnOnce < (char ,) > for CharEscapeDebugContinue {type Output = char :: EscapeDebug ; # [inline] extern \\\"rust-call\\\" fn call_once (self , (c ,) : (char ,)) -> char :: EscapeDebug {Fn :: call (& self , (c ,))}} # [derive (Clone)] struct CharEscapeUnicode ; impl Fn < (char ,) > for CharEscapeUnicode {# [inline] extern \\\"rust-call\\\" fn call (& self , (c ,) : (char ,)) -> char :: EscapeUnicode {{c . escape_unicode ()}}} impl FnMut < (char ,) > for CharEscapeUnicode {# [inline] extern \\\"rust-call\\\" fn call_mut (& mut self , (c ,) : (char ,)) -> char :: EscapeUnicode {Fn :: call (&* self , (c ,))}} impl FnOnce < (char ,) > for CharEscapeUnicode {type Output = char :: EscapeUnicode ; # [inline] extern \\\"rust-call\\\" fn call_once (self , (c ,) : (char ,)) -> char :: EscapeUnicode {Fn :: call (& self , (c ,))}} # [derive (Clone)] struct CharEscapeDefault ; impl Fn < (char ,) > for CharEscapeDefault {# [inline] extern \\\"rust-call\\\" fn call (& self , (c ,) : (char ,)) -> char :: EscapeDefault {{c . escape_default ()}}} impl FnMut < (char ,) > for CharEscapeDefault {# [inline] extern \\\"rust-call\\\" fn call_mut (& mut self , (c ,) : (char ,)) -> char :: EscapeDefault {Fn :: call (&* self , (c ,))}} impl FnOnce < (char ,) > for CharEscapeDefault {type Output = char :: EscapeDefault ; # [inline] extern \\\"rust-call\\\" fn call_once (self , (c ,) : (char ,)) -> char :: EscapeDefault {Fn :: call (& self , (c ,))}}\");\n }\n \n@@ -1263,7 +1263,7 @@ fn test_cfg_if_items() {\n \"#,\n     );\n \n-    assert_expansion(MacroKind::Items, &rules, r#\"__cfg_if_items ! { ( rustdoc , ) ; ( ( ) ( # [ cfg ( any ( target_os = \"redox\" , unix ) ) ] # [ stable ( feature = \"rust1\" , since = \"1.0.0\" ) ] pub use sys :: ext as unix ; # [ cfg ( windows ) ] # [ stable ( feature = \"rust1\" , since = \"1.0.0\" ) ] pub use sys :: ext as windows ; # [ cfg ( any ( target_os = \"linux\" , target_os = \"l4re\" ) ) ] pub mod linux ; ) ) , }\"#,         \n+    assert_expansion(MacroKind::Items, &rules, r#\"__cfg_if_items ! { ( rustdoc , ) ; ( ( ) ( # [ cfg ( any ( target_os = \"redox\" , unix ) ) ] # [ stable ( feature = \"rust1\" , since = \"1.0.0\" ) ] pub use sys :: ext as unix ; # [ cfg ( windows ) ] # [ stable ( feature = \"rust1\" , since = \"1.0.0\" ) ] pub use sys :: ext as windows ; # [ cfg ( any ( target_os = \"linux\" , target_os = \"l4re\" ) ) ] pub mod linux ; ) ) , }\"#,\n         \"__cfg_if_items ! {(rustdoc ,) ;}\");\n }\n \n@@ -1294,23 +1294,23 @@ fn test_cfg_if_main() {\n     );\n \n     assert_expansion(MacroKind::Items, &rules, r#\"\n-cfg_if !   { \n-     if   # [ cfg ( target_env   =   \"msvc\" ) ]   { \n-         // no extra unwinder support needed \n-     }   else   if   # [ cfg ( all ( target_arch   =   \"wasm32\" ,   not ( target_os   =   \"emscripten\" ) ) ) ]   { \n-         // no unwinder on the system! \n-     }   else   { \n-         mod   libunwind ; \n-         pub   use   libunwind :: * ; \n-     } \n- }        \n-\"#,         \n+cfg_if !   {\n+     if   # [ cfg ( target_env   =   \"msvc\" ) ]   {\n+         // no extra unwinder support needed\n+     }   else   if   # [ cfg ( all ( target_arch   =   \"wasm32\" ,   not ( target_os   =   \"emscripten\" ) ) ) ]   {\n+         // no unwinder on the system!\n+     }   else   {\n+         mod   libunwind ;\n+         pub   use   libunwind :: * ;\n+     }\n+ }\n+\"#,\n         \"__cfg_if_items ! {() ; ((target_env = \\\"msvc\\\") ()) , ((all (target_arch = \\\"wasm32\\\" , not (target_os = \\\"emscripten\\\"))) ()) , (() (mod libunwind ; pub use libunwind :: * ;)) ,}\");\n \n     assert_expansion(MacroKind::Items, &rules, r#\"\n-cfg_if ! { @ __apply cfg ( all ( not ( any ( not ( any ( target_os = \"solaris\" , target_os = \"illumos\" ) ) ) ) ) ) , }    \n+cfg_if ! { @ __apply cfg ( all ( not ( any ( not ( any ( target_os = \"solaris\" , target_os = \"illumos\" ) ) ) ) ) ) , }\n \"#,\n-        \"\"    \n+        \"\"\n     );\n }\n \n@@ -1329,16 +1329,16 @@ macro_rules! arbitrary {\n                 $logic\n             }\n         }\n-    };  \n-   \n+    };\n+\n }\"#,\n     );\n \n-    assert_expansion(MacroKind::Items, &rules, r#\"arbitrary !   ( [ A : Arbitrary ] \n-        Vec < A > , \n-        VecStrategy < A :: Strategy > , \n-        RangedParams1 < A :: Parameters > ; \n-        args =>   { let product_unpack !   [ range , a ] = args ; vec ( any_with :: < A >   ( a ) , range ) } \n+    assert_expansion(MacroKind::Items, &rules, r#\"arbitrary !   ( [ A : Arbitrary ]\n+        Vec < A > ,\n+        VecStrategy < A :: Strategy > ,\n+        RangedParams1 < A :: Parameters > ;\n+        args =>   { let product_unpack !   [ range , a ] = args ; vec ( any_with :: < A >   ( a ) , range ) }\n     ) ;\"#,\n     \"impl <A : Arbitrary > $crate :: arbitrary :: Arbitrary for Vec < A > {type Parameters = RangedParams1 < A :: Parameters > ; type Strategy = VecStrategy < A :: Strategy > ; fn arbitrary_with (args : Self :: Parameters) -> Self :: Strategy {{let product_unpack ! [range , a] = args ; vec (any_with :: < A > (a) , range)}}}\");\n }\n@@ -1350,7 +1350,7 @@ fn test_old_ridl() {\n     let rules = create_rules(\n         r#\"\n #[macro_export]\n-macro_rules! RIDL {    \n+macro_rules! RIDL {\n     (interface $interface:ident ($vtbl:ident) : $pinterface:ident ($pvtbl:ident)\n         {$(\n             fn $method:ident(&mut self $(,$p:ident : $t:ty)*) -> $rtr:ty\n@@ -1360,7 +1360,7 @@ macro_rules! RIDL {\n             $(pub unsafe fn $method(&mut self) -> $rtr {\n                 ((*self.lpVtbl).$method)(self $(,$p)*)\n             })+\n-        }        \n+        }\n     };\n }\"#,\n     );\n@@ -1388,11 +1388,11 @@ macro_rules! quick_error {\n         quick_error!(ENUM_DEFINITION [enum $name $( #[$meta] )*]\n             body []\n             queue [$(\n-                $( #[$imeta] )*                      \n-                => \n-                $iitem: $imode [$( $ivar: $ityp ),*]                       \n+                $( #[$imeta] )*\n+                =>\n+                $iitem: $imode [$( $ivar: $ityp ),*]\n             )*]\n-        );        \n+        );\n };\n \n }\n@@ -1403,7 +1403,7 @@ macro_rules! quick_error {\n         &rules,\n         r#\"\n quick_error ! (SORT [enum Wrapped # [derive (Debug)]] items [\n-        => One : UNIT [] {} \n+        => One : UNIT [] {}\n         => Two : TUPLE [s :String] {display (\"two: {}\" , s) from ()}\n     ] buf [] queue []) ;\n \"#,"}]}