{"sha": "c38230e3b639783483277465ff3c3436a8fd5545", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMzODIzMGUzYjYzOTc4MzQ4MzI3NzQ2NWZmM2MzNDM2YThmZDU1NDU=", "commit": {"author": {"name": "Alexis Bourget", "email": "alexis.bourget@gmail.com", "date": "2020-07-14T15:05:29Z"}, "committer": {"name": "Alexis Bourget", "email": "alexis.bourget@gmail.com", "date": "2020-07-14T16:00:42Z"}, "message": "Deny unsafe op in unsafe functions in libstd/alloc.rs", "tree": {"sha": "5ecc0b2edff7768d4abcae867dfa12ac15ae9278", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5ecc0b2edff7768d4abcae867dfa12ac15ae9278"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c38230e3b639783483277465ff3c3436a8fd5545", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c38230e3b639783483277465ff3c3436a8fd5545", "html_url": "https://github.com/rust-lang/rust/commit/c38230e3b639783483277465ff3c3436a8fd5545", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c38230e3b639783483277465ff3c3436a8fd5545/comments", "author": {"login": "poliorcetics", "id": 7951708, "node_id": "MDQ6VXNlcjc5NTE3MDg=", "avatar_url": "https://avatars.githubusercontent.com/u/7951708?v=4", "gravatar_id": "", "url": "https://api.github.com/users/poliorcetics", "html_url": "https://github.com/poliorcetics", "followers_url": "https://api.github.com/users/poliorcetics/followers", "following_url": "https://api.github.com/users/poliorcetics/following{/other_user}", "gists_url": "https://api.github.com/users/poliorcetics/gists{/gist_id}", "starred_url": "https://api.github.com/users/poliorcetics/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/poliorcetics/subscriptions", "organizations_url": "https://api.github.com/users/poliorcetics/orgs", "repos_url": "https://api.github.com/users/poliorcetics/repos", "events_url": "https://api.github.com/users/poliorcetics/events{/privacy}", "received_events_url": "https://api.github.com/users/poliorcetics/received_events", "type": "User", "site_admin": false}, "committer": {"login": "poliorcetics", "id": 7951708, "node_id": "MDQ6VXNlcjc5NTE3MDg=", "avatar_url": "https://avatars.githubusercontent.com/u/7951708?v=4", "gravatar_id": "", "url": "https://api.github.com/users/poliorcetics", "html_url": "https://github.com/poliorcetics", "followers_url": "https://api.github.com/users/poliorcetics/followers", "following_url": "https://api.github.com/users/poliorcetics/following{/other_user}", "gists_url": "https://api.github.com/users/poliorcetics/gists{/gist_id}", "starred_url": "https://api.github.com/users/poliorcetics/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/poliorcetics/subscriptions", "organizations_url": "https://api.github.com/users/poliorcetics/orgs", "repos_url": "https://api.github.com/users/poliorcetics/repos", "events_url": "https://api.github.com/users/poliorcetics/events{/privacy}", "received_events_url": "https://api.github.com/users/poliorcetics/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c724b67e1b474262917a5154d74e7072267593fe", "url": "https://api.github.com/repos/rust-lang/rust/commits/c724b67e1b474262917a5154d74e7072267593fe", "html_url": "https://github.com/rust-lang/rust/commit/c724b67e1b474262917a5154d74e7072267593fe"}], "stats": {"total": 91, "additions": 71, "deletions": 20}, "files": [{"sha": "ecfaaeace513e329873de16187a83875b0c5a4c4", "filename": "src/libstd/alloc.rs", "status": "modified", "additions": 71, "deletions": 20, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/c38230e3b639783483277465ff3c3436a8fd5545/src%2Flibstd%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c38230e3b639783483277465ff3c3436a8fd5545/src%2Flibstd%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Falloc.rs?ref=c38230e3b639783483277465ff3c3436a8fd5545", "patch": "@@ -59,6 +59,7 @@\n //! The `#[global_allocator]` can only be used once in a crate\n //! or its recursive dependencies.\n \n+#![deny(unsafe_op_in_unsafe_fn)]\n #![stable(feature = \"alloc_module\", since = \"1.28.0\")]\n \n use core::intrinsics;\n@@ -158,7 +159,9 @@ unsafe impl AllocRef for System {\n     #[inline]\n     unsafe fn dealloc(&mut self, ptr: NonNull<u8>, layout: Layout) {\n         if layout.size() != 0 {\n-            GlobalAlloc::dealloc(self, ptr.as_ptr(), layout)\n+            // SAFETY: The safety guarantees are explained in the documentation\n+            // for the `GlobalAlloc` trait and its `dealloc` method.\n+            unsafe { GlobalAlloc::dealloc(self, ptr.as_ptr(), layout) }\n         }\n     }\n \n@@ -184,16 +187,36 @@ unsafe impl AllocRef for System {\n         match placement {\n             ReallocPlacement::InPlace => Err(AllocErr),\n             ReallocPlacement::MayMove if layout.size() == 0 => {\n-                let new_layout = Layout::from_size_align_unchecked(new_size, layout.align());\n+                let new_layout =\n+                    // SAFETY: The new size and layout alignement guarantees\n+                    // are transfered to the caller (they come from parameters).\n+                    //\n+                    // See the preconditions for `Layout::from_size_align` to\n+                    // see what must be checked.\n+                    unsafe { Layout::from_size_align_unchecked(new_size, layout.align()) };\n                 self.alloc(new_layout, init)\n             }\n             ReallocPlacement::MayMove => {\n-                // `realloc` probably checks for `new_size > size` or something similar.\n-                intrinsics::assume(new_size > size);\n-                let ptr = GlobalAlloc::realloc(self, ptr.as_ptr(), layout, new_size);\n-                let memory =\n-                    MemoryBlock { ptr: NonNull::new(ptr).ok_or(AllocErr)?, size: new_size };\n-                init.init_offset(memory, size);\n+                // SAFETY:\n+                //\n+                // The safety guarantees are explained in the documentation\n+                // for the `GlobalAlloc` trait and its `dealloc` method.\n+                //\n+                // `realloc` probably checks for `new_size > size` or something\n+                // similar.\n+                //\n+                // For the guarantees about `init_offset`, see its documentation:\n+                // `ptr` is assumed valid (and checked for non-NUL) and\n+                // `memory.size` is set to `new_size` so the offset being `size`\n+                // is valid.\n+                let memory = unsafe {\n+                    intrinsics::assume(new_size > size);\n+                    let ptr = GlobalAlloc::realloc(self, ptr.as_ptr(), layout, new_size);\n+                    let memory =\n+                        MemoryBlock { ptr: NonNull::new(ptr).ok_or(AllocErr)?, size: new_size };\n+                    init.init_offset(memory, size);\n+                    memory\n+                };\n                 Ok(memory)\n             }\n         }\n@@ -220,14 +243,28 @@ unsafe impl AllocRef for System {\n         match placement {\n             ReallocPlacement::InPlace => Err(AllocErr),\n             ReallocPlacement::MayMove if new_size == 0 => {\n-                self.dealloc(ptr, layout);\n+                // SAFETY: see `GlobalAlloc::dealloc` for the guarantees that\n+                // must be respected. `ptr` and `layout` are parameters and so\n+                // those guarantees must be checked by the caller.\n+                unsafe { self.dealloc(ptr, layout) };\n                 Ok(MemoryBlock { ptr: layout.dangling(), size: 0 })\n             }\n             ReallocPlacement::MayMove => {\n-                // `realloc` probably checks for `new_size < size` or something similar.\n-                intrinsics::assume(new_size < size);\n-                let ptr = GlobalAlloc::realloc(self, ptr.as_ptr(), layout, new_size);\n-                Ok(MemoryBlock { ptr: NonNull::new(ptr).ok_or(AllocErr)?, size: new_size })\n+                // SAFETY:\n+                //\n+                // See `GlobalAlloc::realloc` for more informations about the\n+                // guarantees expected by this method. `ptr`, `layout` and\n+                // `new_size` are parameters and the responsability for their\n+                // correctness is left to the caller.\n+                //\n+                // `realloc` probably checks for `new_size < size` or something\n+                // similar.\n+                let memory = unsafe {\n+                    intrinsics::assume(new_size < size);\n+                    let ptr = GlobalAlloc::realloc(self, ptr.as_ptr(), layout, new_size);\n+                    MemoryBlock { ptr: NonNull::new(ptr).ok_or(AllocErr)?, size: new_size }\n+                };\n+                Ok(memory)\n             }\n         }\n     }\n@@ -300,13 +337,19 @@ pub mod __default_lib_allocator {\n \n     #[rustc_std_internal_symbol]\n     pub unsafe extern \"C\" fn __rdl_alloc(size: usize, align: usize) -> *mut u8 {\n-        let layout = Layout::from_size_align_unchecked(size, align);\n-        System.alloc(layout)\n+        // SAFETY: see the guarantees expected by `Layout::from_size_align` and\n+        // `GlobalAlloc::alloc`.\n+        unsafe {\n+            let layout = Layout::from_size_align_unchecked(size, align);\n+            System.alloc(layout)\n+        }\n     }\n \n     #[rustc_std_internal_symbol]\n     pub unsafe extern \"C\" fn __rdl_dealloc(ptr: *mut u8, size: usize, align: usize) {\n-        System.dealloc(ptr, Layout::from_size_align_unchecked(size, align))\n+        // SAFETY: see the guarantees expected by `Layout::from_size_align` and\n+        // `GlobalAlloc::dealloc`.\n+        unsafe { System.dealloc(ptr, Layout::from_size_align_unchecked(size, align)) }\n     }\n \n     #[rustc_std_internal_symbol]\n@@ -316,13 +359,21 @@ pub mod __default_lib_allocator {\n         align: usize,\n         new_size: usize,\n     ) -> *mut u8 {\n-        let old_layout = Layout::from_size_align_unchecked(old_size, align);\n-        System.realloc(ptr, old_layout, new_size)\n+        // SAFETY: see the guarantees expected by `Layout::from_size_align` and\n+        // `GlobalAlloc::realloc`.\n+        unsafe {\n+            let old_layout = Layout::from_size_align_unchecked(old_size, align);\n+            System.realloc(ptr, old_layout, new_size)\n+        }\n     }\n \n     #[rustc_std_internal_symbol]\n     pub unsafe extern \"C\" fn __rdl_alloc_zeroed(size: usize, align: usize) -> *mut u8 {\n-        let layout = Layout::from_size_align_unchecked(size, align);\n-        System.alloc_zeroed(layout)\n+        // SAFETY: see the guarantees expected by `Layout::from_size_align` and\n+        // `GlobalAlloc::alloc_zeroed`.\n+        unsafe {\n+            let layout = Layout::from_size_align_unchecked(size, align);\n+            System.alloc_zeroed(layout)\n+        }\n     }\n }"}]}