{"sha": "e6732e05e4ff7af66084bf2c212a7fbf1ec6a574", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU2NzMyZTA1ZTRmZjdhZjY2MDg0YmYyYzIxMmE3ZmJmMWVjNmE1NzQ=", "commit": {"author": {"name": "Yuki Okushi", "email": "jtitor@2k36.org", "date": "2021-06-21T00:42:13Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-06-21T00:42:13Z"}, "message": "Rollup merge of #85637 - RalfJung:partial-ord, r=m-ou-se\n\ndocument PartialEq, PartialOrd, Ord requirements more explicitly\n\nThis is the result of discussion in https://github.com/rust-lang/rust/issues/50230, in particular [this summary comment](https://github.com/rust-lang/rust/issues/50230#issuecomment-392819364).\n\nFixes https://github.com/rust-lang/rust/issues/50230.", "tree": {"sha": "a967bb796d9772541ab9387e66ac7a2f29ffb5db", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a967bb796d9772541ab9387e66ac7a2f29ffb5db"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e6732e05e4ff7af66084bf2c212a7fbf1ec6a574", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgz+BmCRBK7hj4Ov3rIwAAC3UIAFbxmvLiovmdKy3VffTqYhMV\naOehd7IBIakkyCqy+8Izw2RyEZURZxg4s1HsgBIrWZe4G7MBlN8fHtLNdM/abYll\niGmYof8SBRTSViVp5avdBS538zzTkxzl7QLaQpapjVRCDRKMacViuDbogytqGSz4\nIgX07UeFx24o4FVVeKHllmVe5O1ysrGUpoeXX1pmIp2yRa4cqpVQfWVEis1rZCum\ncnG0iP/aXLaVMfgs+WY8N1Na+MlUHrwRfWMZ+rUtxDOpdEfU+FNuk6ZnjzWFQjpt\notelw0H0nziPPiLb2n0qVK4gvkkuxvT4LX/1GQy52NB29u1/PQjOJI9qZDgRYvI=\n=TuN1\n-----END PGP SIGNATURE-----\n", "payload": "tree a967bb796d9772541ab9387e66ac7a2f29ffb5db\nparent 1a1909a8a62099f399d1949f1692687ba418e742\nparent 45675f3d9527a5212e96c922dfe4aa1efb7c7a4f\nauthor Yuki Okushi <jtitor@2k36.org> 1624236133 +0900\ncommitter GitHub <noreply@github.com> 1624236133 +0900\n\nRollup merge of #85637 - RalfJung:partial-ord, r=m-ou-se\n\ndocument PartialEq, PartialOrd, Ord requirements more explicitly\n\nThis is the result of discussion in https://github.com/rust-lang/rust/issues/50230, in particular [this summary comment](https://github.com/rust-lang/rust/issues/50230#issuecomment-392819364).\n\nFixes https://github.com/rust-lang/rust/issues/50230.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e6732e05e4ff7af66084bf2c212a7fbf1ec6a574", "html_url": "https://github.com/rust-lang/rust/commit/e6732e05e4ff7af66084bf2c212a7fbf1ec6a574", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e6732e05e4ff7af66084bf2c212a7fbf1ec6a574/comments", "author": {"login": "JohnTitor", "id": 25030997, "node_id": "MDQ6VXNlcjI1MDMwOTk3", "avatar_url": "https://avatars.githubusercontent.com/u/25030997?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JohnTitor", "html_url": "https://github.com/JohnTitor", "followers_url": "https://api.github.com/users/JohnTitor/followers", "following_url": "https://api.github.com/users/JohnTitor/following{/other_user}", "gists_url": "https://api.github.com/users/JohnTitor/gists{/gist_id}", "starred_url": "https://api.github.com/users/JohnTitor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JohnTitor/subscriptions", "organizations_url": "https://api.github.com/users/JohnTitor/orgs", "repos_url": "https://api.github.com/users/JohnTitor/repos", "events_url": "https://api.github.com/users/JohnTitor/events{/privacy}", "received_events_url": "https://api.github.com/users/JohnTitor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1a1909a8a62099f399d1949f1692687ba418e742", "url": "https://api.github.com/repos/rust-lang/rust/commits/1a1909a8a62099f399d1949f1692687ba418e742", "html_url": "https://github.com/rust-lang/rust/commit/1a1909a8a62099f399d1949f1692687ba418e742"}, {"sha": "45675f3d9527a5212e96c922dfe4aa1efb7c7a4f", "url": "https://api.github.com/repos/rust-lang/rust/commits/45675f3d9527a5212e96c922dfe4aa1efb7c7a4f", "html_url": "https://github.com/rust-lang/rust/commit/45675f3d9527a5212e96c922dfe4aa1efb7c7a4f"}], "stats": {"total": 89, "additions": 64, "deletions": 25}, "files": [{"sha": "6c2f09514a611a38e978daeb9144e7cfd6468832", "filename": "library/core/src/cmp.rs", "status": "modified", "additions": 64, "deletions": 25, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/e6732e05e4ff7af66084bf2c212a7fbf1ec6a574/library%2Fcore%2Fsrc%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6732e05e4ff7af66084bf2c212a7fbf1ec6a574/library%2Fcore%2Fsrc%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fcmp.rs?ref=e6732e05e4ff7af66084bf2c212a7fbf1ec6a574", "patch": "@@ -27,12 +27,25 @@ use self::Ordering::*;\n /// Trait for equality comparisons which are [partial equivalence\n /// relations](https://en.wikipedia.org/wiki/Partial_equivalence_relation).\n ///\n+/// `x.eq(y)` can also be written `x == y`, and `x.ne(y)` can be written `x != y`.\n+/// We use the easier-to-read infix notation in the remainder of this documentation.\n+///\n /// This trait allows for partial equality, for types that do not have a full\n /// equivalence relation. For example, in floating point numbers `NaN != NaN`,\n /// so floating point types implement `PartialEq` but not [`trait@Eq`].\n ///\n-/// Formally, the equality must be (for all `a`, `b`, `c` of type `A`, `B`,\n-/// `C`):\n+/// Implementations must ensure that `eq` and `ne` are consistent with each other:\n+///\n+/// - `a != b` if and only if `!(a == b)`\n+///   (ensured by the default implementation).\n+///\n+/// If [`PartialOrd`] or [`Ord`] are also implemented for `Self` and `Rhs`, their methods must also\n+/// be consistent with `PartialEq` (see the documentation of those traits for the exact\n+/// requirememts). It's easy to accidentally make them disagree by deriving some of the traits and\n+/// manually implementing others.\n+///\n+/// The equality relation `==` must satisfy the following conditions\n+/// (for all `a`, `b`, `c` of type `A`, `B`, `C`):\n ///\n /// - **Symmetric**: if `A: PartialEq<B>` and `B: PartialEq<A>`, then **`a == b`\n ///   implies `b == a`**; and\n@@ -53,15 +66,6 @@ use self::Ordering::*;\n ///\n /// ## How can I implement `PartialEq`?\n ///\n-/// `PartialEq` only requires the [`eq`] method to be implemented; [`ne`] is defined\n-/// in terms of it by default. Any manual implementation of [`ne`] *must* respect\n-/// the rule that [`eq`] is a strict inverse of [`ne`]; that is, `!(a == b)` if and\n-/// only if `a != b`.\n-///\n-/// Implementations of `PartialEq`, [`PartialOrd`], and [`Ord`] *must* agree with\n-/// each other. It's easy to accidentally make them disagree by deriving some\n-/// of the traits and manually implementing others.\n-///\n /// An example implementation for a domain in which two books are considered\n /// the same book if their ISBN matches, even if the formats differ:\n ///\n@@ -631,10 +635,25 @@ impl<T: Clone> Clone for Reverse<T> {\n \n /// Trait for types that form a [total order](https://en.wikipedia.org/wiki/Total_order).\n ///\n-/// An order is a total order if it is (for all `a`, `b` and `c`):\n+/// Implementations must be consistent with the [`PartialOrd`] implementation, and ensure\n+/// `max`, `min`, and `clamp` are consistent with `cmp`:\n+///\n+/// - `partial_cmp(a, b) == Some(cmp(a, b))`.\n+/// - `max(a, b) == max_by(a, b, cmp)` (ensured by the default implementation).\n+/// - `min(a, b) == min_by(a, b, cmp)` (ensured by the default implementation).\n+/// - For `a.clamp(min, max)`, see the [method docs](#method.clamp)\n+///   (ensured by the default implementation).\n+///\n+/// It's easy to accidentally make `cmp` and `partial_cmp` disagree by\n+/// deriving some of the traits and manually implementing others.\n+///\n+/// ## Corollaries\n+///\n+/// From the above and the requirements of `PartialOrd`, it follows that `<` defines a strict total order.\n+/// This means that for all `a`, `b` and `c`:\n ///\n-/// - total and asymmetric: exactly one of `a < b`, `a == b` or `a > b` is true; and\n-/// - transitive, `a < b` and `b < c` implies `a < c`. The same must hold for both `==` and `>`.\n+/// - exactly one of `a < b`, `a == b` or `a > b` is true; and\n+/// - `<` is transitive: `a < b` and `b < c` implies `a < c`. The same must hold for both `==` and `>`.\n ///\n /// ## Derivable\n ///\n@@ -659,12 +678,6 @@ impl<T: Clone> Clone for Reverse<T> {\n /// Then you must define an implementation for [`cmp`]. You may find it useful to use\n /// [`cmp`] on your type's fields.\n ///\n-/// Implementations of [`PartialEq`], [`PartialOrd`], and `Ord` *must*\n-/// agree with each other. That is, `a.cmp(b) == Ordering::Equal` if\n-/// and only if `a == b` and `Some(a.cmp(b)) == a.partial_cmp(b)` for\n-/// all `a` and `b`. It's easy to accidentally make them disagree by\n-/// deriving some of the traits and manually implementing others.\n-///\n /// Here's an example where you want to sort people by height only, disregarding `id`\n /// and `name`:\n ///\n@@ -824,15 +837,45 @@ impl PartialOrd for Ordering {\n \n /// Trait for values that can be compared for a sort-order.\n ///\n+/// The `lt`, `le`, `gt`, and `ge` methods of this trait can be called using\n+/// the `<`, `<=`, `>`, and `>=` operators, respectively.\n+///\n+/// The methods of this trait must be consistent with each other and with those of `PartialEq` in\n+/// the following sense:\n+///\n+/// - `a == b` if and only if `partial_cmp(a, b) == Some(Equal)`.\n+/// - `a < b` if and only if `partial_cmp(a, b) == Some(Less)`\n+///   (ensured by the default implementation).\n+/// - `a > b` if and only if `partial_cmp(a, b) == Some(Greater)`\n+///   (ensured by the default implementation).\n+/// - `a <= b` if and only if `a < b || a == b`\n+///   (ensured by the default implementation).\n+/// - `a >= b` if and only if `a > b || a == b`\n+///   (ensured by the default implementation).\n+/// - `a != b` if and only if `!(a == b)` (already part of `PartialEq`).\n+///\n+/// If [`Ord`] is also implemented for `Self` and `Rhs`, it must also be consistent with\n+/// `partial_cmp` (see the documentation of that trait for the exact requirements). It's\n+/// easy to accidentally make them disagree by deriving some of the traits and manually\n+/// implementing others.\n+///\n /// The comparison must satisfy, for all `a`, `b` and `c`:\n ///\n-/// - asymmetry: if `a < b` then `!(a > b)`, as well as `a > b` implying `!(a < b)`; and\n /// - transitivity: `a < b` and `b < c` implies `a < c`. The same must hold for both `==` and `>`.\n+/// - duality: `a < b` if and only if `b > a`.\n ///\n /// Note that these requirements mean that the trait itself must be implemented symmetrically and\n /// transitively: if `T: PartialOrd<U>` and `U: PartialOrd<V>` then `U: PartialOrd<T>` and `T:\n /// PartialOrd<V>`.\n ///\n+/// ## Corollaries\n+///\n+/// The following corollaries follow from the above requirements:\n+///\n+/// - irreflexivity of `<` and `>`: `!(a < a)`, `!(a > a)`\n+/// - transitivity of `>`: if `a > b` and `b > c` then `a > c`\n+/// - duality of `partial_cmp`: `partial_cmp(a, b) == partial_cmp(b, a).map(Ordering::reverse)`\n+///\n /// ## Derivable\n ///\n /// This trait can be used with `#[derive]`. When `derive`d on structs, it will produce a\n@@ -850,10 +893,6 @@ impl PartialOrd for Ordering {\n ///\n /// `PartialOrd` requires your type to be [`PartialEq`].\n ///\n-/// Implementations of [`PartialEq`], `PartialOrd`, and [`Ord`] *must* agree with each other. It's\n-/// easy to accidentally make them disagree by deriving some of the traits and manually\n-/// implementing others.\n-///\n /// If your type is [`Ord`], you can implement [`partial_cmp`] by using [`cmp`]:\n ///\n /// ```"}]}