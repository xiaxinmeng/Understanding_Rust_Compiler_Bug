{"sha": "f766acad62cd5cf7ed701a9521db2f2a96039778", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY3NjZhY2FkNjJjZDVjZjdlZDcwMWE5NTIxZGIyZjJhOTYwMzk3Nzg=", "commit": {"author": {"name": "Daniel Micay", "email": "danielmicay@gmail.com", "date": "2013-10-17T02:51:51Z"}, "committer": {"name": "Daniel Micay", "email": "danielmicay@gmail.com", "date": "2013-10-17T02:57:51Z"}, "message": "drop the linenoise library\n\nCloses #5038", "tree": {"sha": "e71d683b3af25db3a9e394e2cd2dae8ec6e4f006", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e71d683b3af25db3a9e394e2cd2dae8ec6e4f006"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f766acad62cd5cf7ed701a9521db2f2a96039778", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f766acad62cd5cf7ed701a9521db2f2a96039778", "html_url": "https://github.com/rust-lang/rust/commit/f766acad62cd5cf7ed701a9521db2f2a96039778", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f766acad62cd5cf7ed701a9521db2f2a96039778/comments", "author": {"login": "thestinger", "id": 1505226, "node_id": "MDQ6VXNlcjE1MDUyMjY=", "avatar_url": "https://avatars.githubusercontent.com/u/1505226?v=4", "gravatar_id": "", "url": "https://api.github.com/users/thestinger", "html_url": "https://github.com/thestinger", "followers_url": "https://api.github.com/users/thestinger/followers", "following_url": "https://api.github.com/users/thestinger/following{/other_user}", "gists_url": "https://api.github.com/users/thestinger/gists{/gist_id}", "starred_url": "https://api.github.com/users/thestinger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/thestinger/subscriptions", "organizations_url": "https://api.github.com/users/thestinger/orgs", "repos_url": "https://api.github.com/users/thestinger/repos", "events_url": "https://api.github.com/users/thestinger/events{/privacy}", "received_events_url": "https://api.github.com/users/thestinger/received_events", "type": "User", "site_admin": false}, "committer": {"login": "thestinger", "id": 1505226, "node_id": "MDQ6VXNlcjE1MDUyMjY=", "avatar_url": "https://avatars.githubusercontent.com/u/1505226?v=4", "gravatar_id": "", "url": "https://api.github.com/users/thestinger", "html_url": "https://github.com/thestinger", "followers_url": "https://api.github.com/users/thestinger/followers", "following_url": "https://api.github.com/users/thestinger/following{/other_user}", "gists_url": "https://api.github.com/users/thestinger/gists{/gist_id}", "starred_url": "https://api.github.com/users/thestinger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/thestinger/subscriptions", "organizations_url": "https://api.github.com/users/thestinger/orgs", "repos_url": "https://api.github.com/users/thestinger/repos", "events_url": "https://api.github.com/users/thestinger/events{/privacy}", "received_events_url": "https://api.github.com/users/thestinger/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7c92435f8f93344330e47fb0cca4f79297896bd2", "url": "https://api.github.com/repos/rust-lang/rust/commits/7c92435f8f93344330e47fb0cca4f79297896bd2", "html_url": "https://github.com/rust-lang/rust/commit/7c92435f8f93344330e47fb0cca4f79297896bd2"}], "stats": {"total": 2227, "additions": 3, "deletions": 2224}, "files": [{"sha": "3e368ce70e92883acc94aaac012fdbe35b858ed2", "filename": ".gitattributes", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f766acad62cd5cf7ed701a9521db2f2a96039778/.gitattributes", "raw_url": "https://github.com/rust-lang/rust/raw/f766acad62cd5cf7ed701a9521db2f2a96039778/.gitattributes", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.gitattributes?ref=f766acad62cd5cf7ed701a9521db2f2a96039778", "patch": "@@ -7,5 +7,4 @@\n src/etc/pkg/rust-logo.ico binary\n src/rt/msvc/* -whitespace\n src/rt/vg/* -whitespace\n-src/rt/linenoise/* -whitespace\n src/rt/jemalloc/**/* -whitespace"}, {"sha": "eb934c1807ff0c3cf1301d8b1e75a0ee27b09fdd", "filename": "configure", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f766acad62cd5cf7ed701a9521db2f2a96039778/configure", "raw_url": "https://github.com/rust-lang/rust/raw/f766acad62cd5cf7ed701a9521db2f2a96039778/configure", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/configure?ref=f766acad62cd5cf7ed701a9521db2f2a96039778", "patch": "@@ -686,7 +686,7 @@ do\n     make_dir $t/rt/libuv/src/ev\n     make_dir $t/rt/jemalloc\n     for i in                                          \\\n-      isaac linenoise sync test \\\n+      isaac sync test \\\n       arch/i386 arch/x86_64 arch/arm arch/mips  \\\n       sundown/src sundown/html\n     do"}, {"sha": "8f9714e62d5b0ac77999be5c7fa0a5bf6757a747", "filename": "mk/platform.mk", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f766acad62cd5cf7ed701a9521db2f2a96039778/mk%2Fplatform.mk", "raw_url": "https://github.com/rust-lang/rust/raw/f766acad62cd5cf7ed701a9521db2f2a96039778/mk%2Fplatform.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fplatform.mk?ref=f766acad62cd5cf7ed701a9521db2f2a96039778", "patch": "@@ -29,7 +29,7 @@ $(foreach t,$(CFG_TARGET_TRIPLES),$(info cfg: os for $(t) is $(OSTYPE_$(t))))\n # FIXME: no-omit-frame-pointer is just so that task_start_wrapper\n # has a frame pointer and the stack walker can understand it. Turning off\n # frame pointers everywhere is overkill\n-CFG_GCCISH_CFLAGS += -fno-omit-frame-pointer -DUSE_UTF8\n+CFG_GCCISH_CFLAGS += -fno-omit-frame-pointer\n \n # On Darwin, we need to run dsymutil so the debugging information ends\n # up in the right place.  On other platforms, it automatically gets"}, {"sha": "347c32f17206eb2cb50c7a76d577dc6760074558", "filename": "mk/rt.mk", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f766acad62cd5cf7ed701a9521db2f2a96039778/mk%2Frt.mk", "raw_url": "https://github.com/rust-lang/rust/raw/f766acad62cd5cf7ed701a9521db2f2a96039778/mk%2Frt.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Frt.mk?ref=f766acad62cd5cf7ed701a9521db2f2a96039778", "patch": "@@ -96,9 +96,7 @@ RUNTIME_CXXS_$(1)_$(2) := \\\n               rt/rust_android_dummy.cpp \\\n               rt/rust_test_helpers.cpp\n \n-RUNTIME_CS_$(1)_$(2) := rt/linenoise/linenoise.c \\\n-\t\t\trt/linenoise/utf8.c \\\n-\t\t\trt/sundown/src/autolink.c \\\n+RUNTIME_CS_$(1)_$(2) := rt/sundown/src/autolink.c \\\n \t\t\trt/sundown/src/buffer.c \\\n \t\t\trt/sundown/src/stack.c \\\n \t\t\trt/sundown/src/markdown.c \\\n@@ -116,7 +114,6 @@ RT_BUILD_DIR_$(1)_$(2) := $$(RT_OUTPUT_DIR_$(1))/stage$(2)\n RUNTIME_DEF_$(1)_$(2) := $$(RT_OUTPUT_DIR_$(1))/rustrt$$(CFG_DEF_SUFFIX_$(1))\n RUNTIME_INCS_$(1)_$(2) := -I $$(S)src/rt -I $$(S)src/rt/isaac -I $$(S)src/rt/uthash \\\n                      -I $$(S)src/rt/arch/$$(HOST_$(1)) \\\n-                     -I $$(S)src/rt/linenoise \\\n                      -I $$(S)src/rt/sundown/src \\\n                      -I $$(S)src/rt/sundown/html \\\n                      -I $$(S)src/libuv/include"}, {"sha": "9991aacc949bf8a6f769aeee929573bfa921a4ba", "filename": "mk/tests.mk", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f766acad62cd5cf7ed701a9521db2f2a96039778/mk%2Ftests.mk", "raw_url": "https://github.com/rust-lang/rust/raw/f766acad62cd5cf7ed701a9521db2f2a96039778/mk%2Ftests.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Ftests.mk?ref=f766acad62cd5cf7ed701a9521db2f2a96039778", "patch": "@@ -227,7 +227,6 @@ ALL_CS := $(wildcard $(S)src/rt/*.cpp \\\n                      $(S)src/rt/*/*/*.cpp \\\n                      $(S)src/rustllvm/*.cpp)\n ALL_CS := $(filter-out $(S)src/rt/miniz.cpp \\\n-\t\t       $(wildcard $(S)src/rt/linenoise/*.c) \\\n \t\t       $(wildcard $(S)src/rt/sundown/src/*.c) \\\n \t\t       $(wildcard $(S)src/rt/sundown/html/*.c) \\\n \t,$(ALL_CS))\n@@ -240,8 +239,6 @@ ALL_HS := $(filter-out $(S)src/rt/vg/valgrind.h \\\n                        $(S)src/rt/msvc/typeof.h \\\n                        $(S)src/rt/msvc/stdint.h \\\n                        $(S)src/rt/msvc/inttypes.h \\\n-                       $(S)src/rt/linenoise/linenoise.h \\\n-                       $(S)src/rt/linenoise/utf8.h \\\n \t\t       $(wildcard $(S)src/rt/sundown/src/*.h) \\\n \t\t       $(wildcard $(S)src/rt/sundown/html/*.h) \\\n \t,$(ALL_HS))"}, {"sha": "1ee08247c7353b51a898b00ca052dc5c41d30554", "filename": "src/README.txt", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f766acad62cd5cf7ed701a9521db2f2a96039778/src%2FREADME.txt", "raw_url": "https://github.com/rust-lang/rust/raw/f766acad62cd5cf7ed701a9521db2f2a96039778/src%2FREADME.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FREADME.txt?ref=f766acad62cd5cf7ed701a9521db2f2a96039778", "patch": "@@ -17,7 +17,6 @@ rt/sync            - Concurrency utils\n rt/util            - Small utility classes for the runtime.\n rt/vg              - Valgrind headers\n rt/msvc            - MSVC support\n-rt/linenoise       - a readline-like line editing library\n \n test/              Testsuite\n test/compile-fail  - Tests that should fail to compile"}, {"sha": "4b29709895e63502efac319c60bf7d2f4996dad4", "filename": "src/libextra/extra.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f766acad62cd5cf7ed701a9521db2f2a96039778/src%2Flibextra%2Fextra.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f766acad62cd5cf7ed701a9521db2f2a96039778/src%2Flibextra%2Fextra.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fextra.rs?ref=f766acad62cd5cf7ed701a9521db2f2a96039778", "patch": "@@ -94,7 +94,6 @@ pub mod term;\n pub mod time;\n pub mod arena;\n pub mod base64;\n-pub mod rl;\n pub mod workcache;\n pub mod enum_set;\n #[path=\"num/bigint.rs\"]"}, {"sha": "c8a17451a705197cae4a141e48490903b960b98c", "filename": "src/libextra/rl.rs", "status": "removed", "additions": 0, "deletions": 143, "changes": 143, "blob_url": "https://github.com/rust-lang/rust/blob/7c92435f8f93344330e47fb0cca4f79297896bd2/src%2Flibextra%2Frl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c92435f8f93344330e47fb0cca4f79297896bd2/src%2Flibextra%2Frl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Frl.rs?ref=7c92435f8f93344330e47fb0cca4f79297896bd2", "patch": "@@ -1,143 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Bindings for the ability to read lines of input from the console\n-\n-use std::c_str::ToCStr;\n-use std::libc::{c_char, c_int};\n-use std::{local_data, str, rt};\n-use std::unstable::finally::Finally;\n-\n-mod rustrt {\n-    use std::libc::{c_char, c_int};\n-\n-    externfn!(fn linenoise(prompt: *c_char) -> *c_char)\n-    externfn!(fn linenoiseHistoryAdd(line: *c_char) -> c_int)\n-    externfn!(fn linenoiseHistorySetMaxLen(len: c_int) -> c_int)\n-    externfn!(fn linenoiseHistorySave(file: *c_char) -> c_int)\n-    externfn!(fn linenoiseHistoryLoad(file: *c_char) -> c_int)\n-    externfn!(fn linenoiseSetCompletionCallback(callback: extern \"C\" fn(*i8, *())))\n-    externfn!(fn linenoiseAddCompletion(completions: *(), line: *c_char))\n-\n-    externfn!(fn rust_take_linenoise_lock())\n-    externfn!(fn rust_drop_linenoise_lock())\n-}\n-\n-macro_rules! locked {\n-    ($expr:expr) => {\n-        {\n-            // FIXME #9105: can't use a static mutex in pure Rust yet.\n-            rustrt::rust_take_linenoise_lock();\n-            let x = $expr;\n-            rustrt::rust_drop_linenoise_lock();\n-            x\n-        }\n-    }\n-}\n-\n-/// Add a line to history\n-pub fn add_history(line: &str) -> bool {\n-    do line.with_c_str |buf| {\n-        unsafe {\n-            (locked!(rustrt::linenoiseHistoryAdd(buf))) == 1 as c_int\n-        }\n-    }\n-}\n-\n-/// Set the maximum amount of lines stored\n-pub fn set_history_max_len(len: int) -> bool {\n-    unsafe {\n-        (locked!(rustrt::linenoiseHistorySetMaxLen(len as c_int))) == 1\n-            as c_int\n-    }\n-}\n-\n-/// Save line history to a file\n-pub fn save_history(file: &str) -> bool {\n-    do file.with_c_str |buf| {\n-        // 0 on success, -1 on failure\n-        unsafe {\n-            (locked!(rustrt::linenoiseHistorySave(buf))) == 0 as c_int\n-        }\n-    }\n-}\n-\n-/// Load line history from a file\n-pub fn load_history(file: &str) -> bool {\n-    do file.with_c_str |buf| {\n-        // 0 on success, -1 on failure\n-        unsafe {\n-            (locked!(rustrt::linenoiseHistoryLoad(buf))) == 0 as c_int\n-        }\n-    }\n-}\n-\n-/// Print out a prompt and then wait for input and return it\n-pub fn read(prompt: &str) -> Option<~str> {\n-    do prompt.with_c_str |buf| {\n-        let line = unsafe {\n-            locked!(rustrt::linenoise(buf))\n-        };\n-\n-        if line.is_null() { None }\n-        else {\n-            unsafe {\n-                do (|| {\n-                    Some(str::raw::from_c_str(line))\n-                }).finally {\n-                    // linenoise's return value is from strdup, so we\n-                    // better not leak it.\n-                    rt::global_heap::exchange_free(line);\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-/// The callback used to perform completions.\n-pub trait CompletionCb {\n-    /// Performs a completion.\n-    fn complete(&self, line: ~str, suggestion: &fn(~str));\n-}\n-\n-local_data_key!(complete_key: @CompletionCb)\n-\n-/// Bind to the main completion callback in the current task.\n-///\n-/// The completion callback should not call any `extra::rl` functions\n-/// other than the closure that it receives as its second\n-/// argument. Calling such a function will deadlock on the mutex used\n-/// to ensure that the calls are thread-safe.\n-pub unsafe fn complete(cb: @CompletionCb) {\n-    local_data::set(complete_key, cb);\n-\n-    extern fn callback(line: *c_char, completions: *()) {\n-        do local_data::get(complete_key) |opt_cb| {\n-            // only fetch completions if a completion handler has been\n-            // registered in the current task.\n-            match opt_cb {\n-                None => {}\n-                Some(cb) => {\n-                    unsafe {\n-                        do cb.complete(str::raw::from_c_str(line))\n-                                |suggestion| {\n-                            do suggestion.with_c_str |buf| {\n-                                rustrt::linenoiseAddCompletion(completions,\n-                                                               buf);\n-                            }\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n-    locked!(rustrt::linenoiseSetCompletionCallback(callback));\n-}"}, {"sha": "f008d2d3d5e38f6c4c29f6a767ca39c62853ce38", "filename": "src/rt/linenoise/README.markdown", "status": "removed", "additions": 0, "deletions": 47, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/7c92435f8f93344330e47fb0cca4f79297896bd2/src%2Frt%2Flinenoise%2FREADME.markdown", "raw_url": "https://github.com/rust-lang/rust/raw/7c92435f8f93344330e47fb0cca4f79297896bd2/src%2Frt%2Flinenoise%2FREADME.markdown", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flinenoise%2FREADME.markdown?ref=7c92435f8f93344330e47fb0cca4f79297896bd2", "patch": "@@ -1,47 +0,0 @@\n-# Linenoise\n-\n-A minimal, zero-config, BSD licensed, readline replacement.\n-\n-News: linenoise now includes minimal completion support, thanks to Pieter Noordhuis (@pnoordhuis).\n-\n-News: linenoise is now part of [Android](http://android.git.kernel.org/?p=platform/system/core.git;a=tree;f=liblinenoise;h=56450eaed7f783760e5e6a5993ef75cde2e29dea;hb=HEAD Android)!\n-\n-## Can a line editing library be 20k lines of code?\n-\n-Line editing with some support for history is a really important feature for command line utilities. Instead of retyping almost the same stuff again and again it's just much better to hit the up arrow and edit on syntax errors, or in order to try a slightly different command. But apparently code dealing with terminals is some sort of Black Magic: readline is 30k lines of code, libedit 20k. Is it reasonable to link small utilities to huge libraries just to get a minimal support for line editing?\n-\n-So what usually happens is either:\n-\n- * Large programs with configure scripts disabling line editing if readline is not present in the system, or not supporting it at all since readline is GPL licensed and libedit (the BSD clone) is not as known and available as readline is (Real world example of this problem: Tclsh).\n- * Smaller programs not using a configure script not supporting line editing at all (A problem we had with Redis-cli for instance).\n- \n-The result is a pollution of binaries without line editing support.\n-\n-So I spent more or less two hours doing a reality check resulting in this little library: is it *really* needed for a line editing library to be 20k lines of code? Apparently not, it is possibe to get a very small, zero configuration, trivial to embed library, that solves the problem. Smaller programs will just include this, supporing line editing out of the box. Larger programs may use this little library or just checking with configure if readline/libedit is available and resorting to linenoise if not.\n-\n-## Terminals, in 2010.\n-\n-Apparently almost every terminal you can happen to use today has some kind of support for VT100 alike escape sequences. So I tried to write a lib using just very basic VT100 features. The resulting library appears to work everywhere I tried to use it.\n-\n-Since it's so young I guess there are a few bugs, or the lib may not compile or work with some operating system, but it's a matter of a few weeks and eventually we'll get it right, and there will be no excuses for not shipping command line tools without built-in line editing support.\n-\n-The library is currently less than 400 lines of code. In order to use it in your project just look at the *example.c* file in the source distribution, it is trivial. Linenoise is BSD code, so you can use both in free software and commercial software.\n-\n-## Tested with...\n-\n- * Linux text only console ($TERM = linux)\n- * Linux KDE terminal application ($TERM = xterm)\n- * Linux xterm ($TERM = xterm)\n- * Mac OS X iTerm ($TERM = xterm)\n- * Mac OS X default Terminal.app ($TERM = xterm)\n- * OpenBSD 4.5 through an OSX Terminal.app ($TERM = screen)\n- * IBM AIX 6.1\n- * FreeBSD xterm ($TERM = xterm)\n-\n-Please test it everywhere you can and report back!\n-\n-## Let's push this forward!\n-\n-Please fork it and add something interesting and send me a pull request. What's especially interesting are fixes, new key bindings, completion.\n-\n-Send feedbacks to antirez at gmail"}, {"sha": "cb51a0af8f9259eca7504261e63bb35627f3cc5c", "filename": "src/rt/linenoise/example.c", "status": "removed", "additions": 0, "deletions": 30, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/7c92435f8f93344330e47fb0cca4f79297896bd2/src%2Frt%2Flinenoise%2Fexample.c", "raw_url": "https://github.com/rust-lang/rust/raw/7c92435f8f93344330e47fb0cca4f79297896bd2/src%2Frt%2Flinenoise%2Fexample.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flinenoise%2Fexample.c?ref=7c92435f8f93344330e47fb0cca4f79297896bd2", "patch": "@@ -1,30 +0,0 @@\n-#include <stdio.h>\n-#include <stdlib.h>\n-#include \"linenoise.h\"\n-\n-#ifndef NO_COMPLETION\n-void completion(const char *buf, linenoiseCompletions *lc) {\n-    if (buf[0] == 'h') {\n-        linenoiseAddCompletion(lc,\"hello\");\n-        linenoiseAddCompletion(lc,\"hello there\");\n-    }\n-}\n-#endif\n-\n-int main(void) {\n-    char *line;\n-\n-#ifndef NO_COMPLETION\n-    linenoiseSetCompletionCallback(completion);\n-#endif\n-    linenoiseHistoryLoad(\"history.txt\"); /* Load the history at startup */\n-    while((line = linenoise(\"hello> \")) != NULL) {\n-        if (line[0] != '\\0') {\n-            printf(\"echo: '%s'\\n\", line);\n-            linenoiseHistoryAdd(line);\n-            linenoiseHistorySave(\"history.txt\"); /* Save every new entry */\n-        }\n-        free(line);\n-    }\n-    return 0;\n-}"}, {"sha": "0ce4d559bed99619894735c9ee7c8aee07b0e4ca", "filename": "src/rt/linenoise/linenoise.c", "status": "removed", "additions": 0, "deletions": 1581, "changes": 1581, "blob_url": "https://github.com/rust-lang/rust/blob/7c92435f8f93344330e47fb0cca4f79297896bd2/src%2Frt%2Flinenoise%2Flinenoise.c", "raw_url": "https://github.com/rust-lang/rust/raw/7c92435f8f93344330e47fb0cca4f79297896bd2/src%2Frt%2Flinenoise%2Flinenoise.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flinenoise%2Flinenoise.c?ref=7c92435f8f93344330e47fb0cca4f79297896bd2", "patch": "@@ -1,1581 +0,0 @@\n-/* linenoise.c -- guerrilla line editing library against the idea that a\n- * line editing lib needs to be 20,000 lines of C code.\n- *\n- * You can find the latest source code at:\n- *\n- *   http://github.com/msteveb/linenoise\n- *   (forked from http://github.com/antirez/linenoise)\n- *\n- * Does a number of crazy assumptions that happen to be true in 99.9999% of\n- * the 2010 UNIX computers around.\n- *\n- * ------------------------------------------------------------------------\n- *\n- * Copyright (c) 2010, Salvatore Sanfilippo <antirez at gmail dot com>\n- * Copyright (c) 2010, Pieter Noordhuis <pcnoordhuis at gmail dot com>\n- * Copyright (c) 2011, Steve Bennett <steveb at workware dot net dot au>\n- *\n- * All rights reserved.\n- *\n- * Redistribution and use in source and binary forms, with or without\n- * modification, are permitted provided that the following conditions are\n- * met:\n- *\n- *  *  Redistributions of source code must retain the above copyright\n- *     notice, this list of conditions and the following disclaimer.\n- *\n- *  *  Redistributions in binary form must reproduce the above copyright\n- *     notice, this list of conditions and the following disclaimer in the\n- *     documentation and/or other materials provided with the distribution.\n- *\n- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n- * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n- * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n- * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n- * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n- *\n- * ------------------------------------------------------------------------\n- *\n- * References:\n- * - http://invisible-island.net/xterm/ctlseqs/ctlseqs.html\n- * - http://www.3waylabs.com/nw/WWW/products/wizcon/vt220.html\n- *\n- * Bloat:\n- * - Completion?\n- *\n- * Unix/termios\n- * ------------\n- * List of escape sequences used by this program, we do everything just\n- * a few sequences. In order to be so cheap we may have some\n- * flickering effect with some slow terminal, but the lesser sequences\n- * the more compatible.\n- *\n- * EL (Erase Line)\n- *    Sequence: ESC [ n K\n- *    Effect: if n is 0 or missing, clear from cursor to end of line\n- *    Effect: if n is 1, clear from beginning of line to cursor\n- *    Effect: if n is 2, clear entire line\n- *\n- * CUF (CUrsor Forward)\n- *    Sequence: ESC [ n C\n- *    Effect: moves cursor forward of n chars\n- *\n- * CR (Carriage Return)\n- *    Sequence: \\r\n- *    Effect: moves cursor to column 1\n- *\n- * The following are used to clear the screen: ESC [ H ESC [ 2 J\n- * This is actually composed of two sequences:\n- *\n- * cursorhome\n- *    Sequence: ESC [ H\n- *    Effect: moves the cursor to upper left corner\n- *\n- * ED2 (Clear entire screen)\n- *    Sequence: ESC [ 2 J\n- *    Effect: clear the whole screen\n- *\n- * == For highlighting control characters, we also use the following two ==\n- * SO (enter StandOut)\n- *    Sequence: ESC [ 7 m\n- *    Effect: Uses some standout mode such as reverse video\n- *\n- * SE (Standout End)\n- *    Sequence: ESC [ 0 m\n- *    Effect: Exit standout mode\n- *\n- * == Only used if TIOCGWINSZ fails ==\n- * DSR/CPR (Report cursor position)\n- *    Sequence: ESC [ 6 n\n- *    Effect: reports current cursor position as ESC [ NNN ; MMM R\n- *\n- * win32/console\n- * -------------\n- * If __MINGW32__ is defined, the win32 console API is used.\n- * This could probably be made to work for the msvc compiler too.\n- * This support based in part on work by Jon Griffiths.\n- */\n-\n-#ifdef _WIN32 /* Windows platform, either MinGW or Visual Studio (MSVC) */\n-#include <windows.h>\n-#include <fcntl.h>\n-#define USE_WINCONSOLE\n-#ifdef __MINGW32__\n-#define HAVE_UNISTD_H\n-#else\n-/* Microsoft headers don't like old POSIX names */\n-#define strdup _strdup\n-#define snprintf _snprintf\n-#endif\n-#else\n-#include <termios.h>\n-#include <sys/ioctl.h>\n-#include <sys/poll.h>\n-#define USE_TERMIOS\n-#define HAVE_UNISTD_H\n-#endif\n-\n-#ifdef HAVE_UNISTD_H\n-#include <unistd.h>\n-#endif\n-#include <stdlib.h>\n-#include <stdarg.h>\n-#include <stdio.h>\n-#include <errno.h>\n-#include <string.h>\n-#include <stdlib.h>\n-#include <sys/types.h>\n-\n-#include \"linenoise.h\"\n-#include \"utf8.h\"\n-\n-#define LINENOISE_DEFAULT_HISTORY_MAX_LEN 100\n-#define LINENOISE_MAX_LINE 4096\n-\n-#define ctrl(C) ((C) - '@')\n-\n-/* Use -ve numbers here to co-exist with normal unicode chars */\n-enum {\n-    SPECIAL_NONE,\n-    SPECIAL_UP = -20,\n-    SPECIAL_DOWN = -21,\n-    SPECIAL_LEFT = -22,\n-    SPECIAL_RIGHT = -23,\n-    SPECIAL_DELETE = -24,\n-    SPECIAL_HOME = -25,\n-    SPECIAL_END = -26,\n-    SPECIAL_INSERT = -27,\n-    SPECIAL_PAGE_UP = -28,\n-    SPECIAL_PAGE_DOWN = -29\n-};\n-\n-static int history_max_len = LINENOISE_DEFAULT_HISTORY_MAX_LEN;\n-static int history_len = 0;\n-static char **history = NULL;\n-\n-/* Structure to contain the status of the current (being edited) line */\n-struct current {\n-    char *buf;  /* Current buffer. Always null terminated */\n-    int bufmax; /* Size of the buffer, including space for the null termination */\n-    int len;    /* Number of bytes in 'buf' */\n-    int chars;  /* Number of chars in 'buf' (utf-8 chars) */\n-    int pos;    /* Cursor position, measured in chars */\n-    int cols;   /* Size of the window, in chars */\n-    const char *prompt;\n-    char *capture; /* Allocated capture buffer, or NULL for none. Always null terminated */\n-#if defined(USE_TERMIOS)\n-    int fd;     /* Terminal fd */\n-#elif defined(USE_WINCONSOLE)\n-    HANDLE outh; /* Console output handle */\n-    HANDLE inh; /* Console input handle */\n-    int rows;   /* Screen rows */\n-    int x;      /* Current column during output */\n-    int y;      /* Current row */\n-#endif\n-};\n-\n-static int fd_read(struct current *current);\n-static int getWindowSize(struct current *current);\n-\n-void linenoiseHistoryFree(void) {\n-    if (history) {\n-        int j;\n-\n-        for (j = 0; j < history_len; j++)\n-            free(history[j]);\n-        free(history);\n-        history = NULL;\n-        history_len = 0;\n-    }\n-}\n-\n-#if defined(USE_TERMIOS)\n-static void linenoiseAtExit(void);\n-static struct termios orig_termios; /* in order to restore at exit */\n-static int rawmode = 0; /* for atexit() function to check if restore is needed*/\n-static int atexit_registered = 0; /* register atexit just 1 time */\n-\n-static const char *unsupported_term[] = {\"dumb\",\"cons25\",NULL};\n-\n-static int isUnsupportedTerm(void) {\n-    char *term = getenv(\"TERM\");\n-\n-    if (term) {\n-        int j;\n-        for (j = 0; unsupported_term[j]; j++) {\n-            if (strcasecmp(term, unsupported_term[j]) == 0) {\n-                return 1;\n-            }\n-        }\n-    }\n-    return 0;\n-}\n-\n-static int enableRawMode(struct current *current) {\n-    struct termios raw;\n-\n-    current->fd = STDIN_FILENO;\n-\n-    if (!isatty(current->fd) || isUnsupportedTerm() ||\n-        tcgetattr(current->fd, &orig_termios) == -1) {\n-fatal:\n-        errno = ENOTTY;\n-        return -1;\n-    }\n-\n-    if (!atexit_registered) {\n-        atexit(linenoiseAtExit);\n-        atexit_registered = 1;\n-    }\n-\n-    raw = orig_termios;  /* modify the original mode */\n-    /* input modes: no break, no CR to NL, no parity check, no strip char,\n-     * no start/stop output control. */\n-    raw.c_iflag &= ~(BRKINT | ICRNL | INPCK | ISTRIP | IXON);\n-    /* output modes - disable post processing */\n-    raw.c_oflag &= ~(OPOST);\n-    /* control modes - set 8 bit chars */\n-    raw.c_cflag |= (CS8);\n-    /* local modes - choing off, canonical off, no extended functions,\n-     * no signal chars (^Z,^C) */\n-    raw.c_lflag &= ~(ECHO | ICANON | IEXTEN | ISIG);\n-    /* control chars - set return condition: min number of bytes and timer.\n-     * We want read to return every single byte, without timeout. */\n-    raw.c_cc[VMIN] = 1; raw.c_cc[VTIME] = 0; /* 1 byte, no timer */\n-\n-    /* put terminal in raw mode after flushing */\n-    if (tcsetattr(current->fd,TCSADRAIN,&raw) < 0) {\n-        goto fatal;\n-    }\n-    rawmode = 1;\n-\n-    current->cols = 0;\n-    return 0;\n-}\n-\n-static void disableRawMode(struct current *current) {\n-    /* Don't even check the return value as it's too late. */\n-    if (rawmode && tcsetattr(current->fd,TCSADRAIN,&orig_termios) != -1)\n-        rawmode = 0;\n-}\n-\n-/* At exit we'll try to fix the terminal to the initial conditions. */\n-static void linenoiseAtExit(void) {\n-    if (rawmode) {\n-        tcsetattr(STDIN_FILENO, TCSADRAIN, &orig_termios);\n-    }\n-    linenoiseHistoryFree();\n-}\n-\n-/* gcc/glibc insists that we care about the return code of write!\n- * Clarification: This means that a void-cast like \"(void) (EXPR)\"\n- * does not work.\n- */\n-#define IGNORE_RC(EXPR) if (EXPR) {}\n-\n-/* This is fdprintf() on some systems, but use a different\n- * name to avoid conflicts\n- */\n-static void fd_printf(int fd, const char *format, ...)\n-{\n-    va_list args;\n-    char buf[64];\n-    int n;\n-\n-    va_start(args, format);\n-    n = vsnprintf(buf, sizeof(buf), format, args);\n-    va_end(args);\n-    IGNORE_RC(write(fd, buf, n));\n-}\n-\n-static void clearScreen(struct current *current)\n-{\n-    fd_printf(current->fd, \"\\x1b[H\\x1b[2J\");\n-}\n-\n-static void cursorToLeft(struct current *current)\n-{\n-    fd_printf(current->fd, \"\\r\");\n-}\n-\n-static int outputChars(struct current *current, const char *buf, int len)\n-{\n-    return write(current->fd, buf, len);\n-}\n-\n-static void outputControlChar(struct current *current, char ch)\n-{\n-    fd_printf(current->fd, \"\\x1b[7m^%c\\x1b[0m\", ch);\n-}\n-\n-static void eraseEol(struct current *current)\n-{\n-    fd_printf(current->fd, \"\\x1b[0K\");\n-}\n-\n-static void setCursorPos(struct current *current, int x)\n-{\n-    fd_printf(current->fd, \"\\r\\x1b[%dC\", x);\n-}\n-\n-/**\n- * Reads a char from 'fd', waiting at most 'timeout' milliseconds.\n- *\n- * A timeout of -1 means to wait forever.\n- *\n- * Returns -1 if no char is received within the time or an error occurs.\n- */\n-static int fd_read_char(int fd, int timeout)\n-{\n-    struct pollfd p;\n-    unsigned char c;\n-\n-    p.fd = fd;\n-    p.events = POLLIN;\n-\n-    if (poll(&p, 1, timeout) == 0) {\n-        /* timeout */\n-        return -1;\n-    }\n-    if (read(fd, &c, 1) != 1) {\n-        return -1;\n-    }\n-    return c;\n-}\n-\n-/**\n- * Reads a complete utf-8 character\n- * and returns the unicode value, or -1 on error.\n- */\n-static int fd_read(struct current *current)\n-{\n-#ifdef USE_UTF8\n-    char buf[4];\n-    int n;\n-    int i;\n-    int c;\n-\n-    if (read(current->fd, &buf[0], 1) != 1) {\n-        return -1;\n-    }\n-    n = utf8_charlen(buf[0]);\n-    if (n < 1 || n > 3) {\n-        return -1;\n-    }\n-    for (i = 1; i < n; i++) {\n-        if (read(current->fd, &buf[i], 1) != 1) {\n-            return -1;\n-        }\n-    }\n-    buf[n] = 0;\n-    /* decode and return the character */\n-    utf8_tounicode(buf, &c);\n-    return c;\n-#else\n-    return fd_read_char(current->fd, -1);\n-#endif\n-}\n-\n-static int countColorControlChars(const char* prompt, int plen)\n-{\n-    /* ANSI color control sequences have the form:\n-     * \"\\x1b\" \"[\" [0-9;]+ \"m\"\n-     * We parse them with a simple state machine.\n-     */\n-\n-    enum {\n-        search_esc,\n-        expect_bracket,\n-        expect_inner,\n-        expect_trail\n-    } state = search_esc;\n-    int len = 0, found = 0;\n-    char ch;\n-\n-    /* XXX: Strictly we should be checking utf8 chars rather than\n-     *      bytes in case of the extremely unlikely scenario where\n-     *      an ANSI sequence is part of a utf8 sequence.\n-     */\n-    for (; plen ; plen--, prompt++) {\n-        ch = *prompt;\n-\n-        switch (state) {\n-        case search_esc:\n-            len = 0;\n-            if (ch == '\\x1b') {\n-                state = expect_bracket;\n-                len++;\n-            }\n-            break;\n-        case expect_bracket:\n-            if (ch == '[') {\n-                state = expect_inner;\n-                len++;\n-            } else {\n-                state = search_esc;\n-            }\n-            break;\n-        case expect_inner:\n-            if (ch >= '0' && ch <= '9') {\n-                len++;\n-                state = expect_trail;\n-            } else {\n-                state = search_esc;\n-            }\n-            break;\n-        case expect_trail:\n-            if (ch == 'm') {\n-                len++;\n-                found += len;\n-                state = search_esc;\n-            } else if ((ch != ';') && ((ch < '0') || (ch > '9'))) {\n-                state = search_esc;\n-            }\n-            /* 0-9, or semicolon */\n-            len++;\n-            break;\n-        }\n-    }\n-\n-    return found;\n-}\n-\n-static int getWindowSize(struct current *current)\n-{\n-    struct winsize ws;\n-\n-    if (ioctl(STDOUT_FILENO, TIOCGWINSZ, &ws) == 0 && ws.ws_col != 0) {\n-        current->cols = ws.ws_col;\n-        return 0;\n-    }\n-\n-    /* Failed to query the window size. Perhaps we are on a serial terminal.\n-     * Try to query the width by sending the cursor as far to the right\n-     * and reading back the cursor position.\n-     * Note that this is only done once per call to linenoise rather than\n-     * every time the line is refreshed for efficiency reasons.\n-     */\n-    if (current->cols == 0) {\n-        current->cols = 80;\n-\n-        /* Move cursor far right and report cursor position, then back to the left */\n-        fd_printf(current->fd, \"\\x1b[999C\" \"\\x1b[6n\");\n-\n-        /* Parse the response: ESC [ rows ; cols R */\n-        if (fd_read_char(current->fd, 100) == 0x1b && fd_read_char(current->fd, 100) == '[') {\n-            int n = 0;\n-            while (1) {\n-                int ch = fd_read_char(current->fd, 100);\n-                if (ch == ';') {\n-                    /* Ignore rows */\n-                    n = 0;\n-                }\n-                else if (ch == 'R') {\n-                    /* Got cols */\n-                    if (n != 0 && n < 1000) {\n-                        current->cols = n;\n-                    }\n-                    break;\n-                }\n-                else if (ch >= 0 && ch <= '9') {\n-                    n = n * 10 + ch - '0';\n-                }\n-                else {\n-                    break;\n-                }\n-            }\n-        }\n-    }\n-    return 0;\n-}\n-\n-/**\n- * If escape (27) was received, reads subsequent\n- * chars to determine if this is a known special key.\n- *\n- * Returns SPECIAL_NONE if unrecognised, or -1 if EOF.\n- *\n- * If no additional char is received within a short time,\n- * 27 is returned.\n- */\n-static int check_special(int fd)\n-{\n-    int c = fd_read_char(fd, 50);\n-    int c2;\n-\n-    if (c < 0) {\n-        return 27;\n-    }\n-\n-    c2 = fd_read_char(fd, 50);\n-    if (c2 < 0) {\n-        return c2;\n-    }\n-    if (c == '[' || c == 'O') {\n-        /* Potential arrow key */\n-        switch (c2) {\n-            case 'A':\n-                return SPECIAL_UP;\n-            case 'B':\n-                return SPECIAL_DOWN;\n-            case 'C':\n-                return SPECIAL_RIGHT;\n-            case 'D':\n-                return SPECIAL_LEFT;\n-            case 'F':\n-                return SPECIAL_END;\n-            case 'H':\n-                return SPECIAL_HOME;\n-        }\n-    }\n-    if (c == '[' && c2 >= '1' && c2 <= '8') {\n-        /* extended escape */\n-        c = fd_read_char(fd, 50);\n-        if (c == '~') {\n-            switch (c2) {\n-                case '2':\n-                    return SPECIAL_INSERT;\n-                case '3':\n-                    return SPECIAL_DELETE;\n-                case '5':\n-                    return SPECIAL_PAGE_UP;\n-                case '6':\n-                    return SPECIAL_PAGE_DOWN;\n-                case '7':\n-                    return SPECIAL_HOME;\n-                case '8':\n-                    return SPECIAL_END;\n-            }\n-        }\n-        while (c != -1 && c != '~') {\n-            /* .e.g \\e[12~ or '\\e[11;2~   discard the complete sequence */\n-            c = fd_read_char(fd, 50);\n-        }\n-    }\n-\n-    return SPECIAL_NONE;\n-}\n-#elif defined(USE_WINCONSOLE)\n-\n-static DWORD orig_consolemode = 0;\n-\n-static int enableRawMode(struct current *current) {\n-    DWORD n;\n-    INPUT_RECORD irec;\n-\n-    current->outh = GetStdHandle(STD_OUTPUT_HANDLE);\n-    current->inh = GetStdHandle(STD_INPUT_HANDLE);\n-\n-    if (!PeekConsoleInput(current->inh, &irec, 1, &n)) {\n-        return -1;\n-    }\n-    if (getWindowSize(current) != 0) {\n-        return -1;\n-    }\n-    if (GetConsoleMode(current->inh, &orig_consolemode)) {\n-        SetConsoleMode(current->inh, ENABLE_PROCESSED_INPUT);\n-    }\n-    return 0;\n-}\n-\n-static void disableRawMode(struct current *current)\n-{\n-    SetConsoleMode(current->inh, orig_consolemode);\n-}\n-\n-static void clearScreen(struct current *current)\n-{\n-    COORD topleft = { 0, 0 };\n-    DWORD n;\n-\n-    FillConsoleOutputCharacter(current->outh, ' ',\n-        current->cols * current->rows, topleft, &n);\n-    FillConsoleOutputAttribute(current->outh,\n-        FOREGROUND_RED | FOREGROUND_BLUE | FOREGROUND_GREEN,\n-        current->cols * current->rows, topleft, &n);\n-    SetConsoleCursorPosition(current->outh, topleft);\n-}\n-\n-static void cursorToLeft(struct current *current)\n-{\n-    COORD pos = { 0, (SHORT)current->y };\n-    DWORD n;\n-\n-    FillConsoleOutputAttribute(current->outh,\n-        FOREGROUND_RED | FOREGROUND_BLUE | FOREGROUND_GREEN, current->cols, pos, &n);\n-    current->x = 0;\n-}\n-\n-static int outputChars(struct current *current, const char *buf, int len)\n-{\n-    COORD pos = { (SHORT)current->x, (SHORT)current->y };\n-    DWORD n;\n-\n-    WriteConsoleOutputCharacter(current->outh, buf, len, pos, &n);\n-    current->x += len;\n-    return 0;\n-}\n-\n-static void outputControlChar(struct current *current, char ch)\n-{\n-    COORD pos = { (SHORT)current->x, (SHORT)current->y };\n-    DWORD n;\n-\n-    FillConsoleOutputAttribute(current->outh, BACKGROUND_INTENSITY, 2, pos, &n);\n-    outputChars(current, \"^\", 1);\n-    outputChars(current, &ch, 1);\n-}\n-\n-static void eraseEol(struct current *current)\n-{\n-    COORD pos = { (SHORT)current->x, (SHORT)current->y };\n-    DWORD n;\n-\n-    FillConsoleOutputCharacter(current->outh, ' ', current->cols - current->x, pos, &n);\n-}\n-\n-static void setCursorPos(struct current *current, int x)\n-{\n-    COORD pos = { (SHORT)x, (SHORT)current->y };\n-\n-    SetConsoleCursorPosition(current->outh, pos);\n-    current->x = x;\n-}\n-\n-static int fd_read(struct current *current)\n-{\n-    while (1) {\n-        INPUT_RECORD irec;\n-        DWORD n;\n-        if (WaitForSingleObject(current->inh, INFINITE) != WAIT_OBJECT_0) {\n-            break;\n-        }\n-        if (!ReadConsoleInput (current->inh, &irec, 1, &n)) {\n-            break;\n-        }\n-        if (irec.EventType == KEY_EVENT && irec.Event.KeyEvent.bKeyDown) {\n-            KEY_EVENT_RECORD *k = &irec.Event.KeyEvent;\n-            if (k->dwControlKeyState & ENHANCED_KEY) {\n-                switch (k->wVirtualKeyCode) {\n-                 case VK_LEFT:\n-                    return SPECIAL_LEFT;\n-                 case VK_RIGHT:\n-                    return SPECIAL_RIGHT;\n-                 case VK_UP:\n-                    return SPECIAL_UP;\n-                 case VK_DOWN:\n-                    return SPECIAL_DOWN;\n-                 case VK_INSERT:\n-                    return SPECIAL_INSERT;\n-                 case VK_DELETE:\n-                    return SPECIAL_DELETE;\n-                 case VK_HOME:\n-                    return SPECIAL_HOME;\n-                 case VK_END:\n-                    return SPECIAL_END;\n-                 case VK_PRIOR:\n-                    return SPECIAL_PAGE_UP;\n-                 case VK_NEXT:\n-                    return SPECIAL_PAGE_DOWN;\n-                }\n-            }\n-            /* Note that control characters are already translated in AsciiChar */\n-            else {\n-#ifdef USE_UTF8\n-                return k->uChar.UnicodeChar;\n-#else\n-                return k->uChar.AsciiChar;\n-#endif\n-            }\n-        }\n-    }\n-    return -1;\n-}\n-\n-static int countColorControlChars(const char* prompt, int plen)\n-{\n-    /* For windows we assume that there are no embedded ansi color\n-     * control sequences.\n-     */\n-    return 0;\n-}\n-\n-static int getWindowSize(struct current *current)\n-{\n-    CONSOLE_SCREEN_BUFFER_INFO info;\n-    if (!GetConsoleScreenBufferInfo(current->outh, &info)) {\n-        return -1;\n-    }\n-    current->cols = info.dwSize.X;\n-    current->rows = info.dwSize.Y;\n-    if (current->cols <= 0 || current->rows <= 0) {\n-        current->cols = 80;\n-        return -1;\n-    }\n-    current->y = info.dwCursorPosition.Y;\n-    current->x = info.dwCursorPosition.X;\n-    return 0;\n-}\n-#endif\n-\n-static int utf8_getchars(char *buf, int c)\n-{\n-#ifdef USE_UTF8\n-    return utf8_fromunicode(buf, c);\n-#else\n-    *buf = c;\n-    return 1;\n-#endif\n-}\n-\n-/**\n- * Returns the unicode character at the given offset,\n- * or -1 if none.\n- */\n-static int get_char(struct current *current, int pos)\n-{\n-    if (pos >= 0 && pos < current->chars) {\n-        int c;\n-        int i = utf8_index(current->buf, pos);\n-        (void)utf8_tounicode(current->buf + i, &c);\n-        return c;\n-    }\n-    return -1;\n-}\n-\n-static void refreshLine(const char *prompt, struct current *current)\n-{\n-    int plen;\n-    int pchars;\n-    int backup = 0;\n-    int i;\n-    const char *buf = current->buf;\n-    int chars = current->chars;\n-    int pos = current->pos;\n-    int b;\n-    int ch;\n-    int n;\n-\n-    /* Should intercept SIGWINCH. For now, just get the size every time */\n-    getWindowSize(current);\n-\n-    plen = strlen(prompt);\n-    pchars = utf8_strlen(prompt, plen);\n-\n-    /* Scan the prompt for embedded ansi color control sequences and\n-     * discount them as characters/columns.\n-     */\n-    pchars -= countColorControlChars(prompt, plen);\n-\n-    /* Account for a line which is too long to fit in the window.\n-     * Note that control chars require an extra column\n-     */\n-\n-    /* How many cols are required to the left of 'pos'?\n-     * The prompt, plus one extra for each control char\n-     */\n-    n = pchars + utf8_strlen(buf, current->len);\n-    b = 0;\n-    for (i = 0; i < pos; i++) {\n-        b += utf8_tounicode(buf + b, &ch);\n-        if (ch < ' ') {\n-            n++;\n-        }\n-    }\n-\n-    /* If too many are needed, strip chars off the front of 'buf'\n-     * until it fits. Note that if the current char is a control character,\n-     * we need one extra col.\n-     */\n-    if (current->pos < current->chars && get_char(current, current->pos) < ' ') {\n-        n++;\n-    }\n-\n-    while (n >= current->cols && pos > 0) {\n-        b = utf8_tounicode(buf, &ch);\n-        if (ch < ' ') {\n-            n--;\n-        }\n-        n--;\n-        buf += b;\n-        pos--;\n-        chars--;\n-    }\n-\n-    /* Cursor to left edge, then the prompt */\n-    cursorToLeft(current);\n-    outputChars(current, prompt, plen);\n-\n-    /* Now the current buffer content */\n-\n-    /* Need special handling for control characters.\n-     * If we hit 'cols', stop.\n-     */\n-    b = 0; /* unwritted bytes */\n-    n = 0; /* How many control chars were written */\n-    for (i = 0; i < chars; i++) {\n-        int ch;\n-        int w = utf8_tounicode(buf + b, &ch);\n-        if (ch < ' ') {\n-            n++;\n-        }\n-        if (pchars + i + n >= current->cols) {\n-            break;\n-        }\n-        if (ch < ' ') {\n-            /* A control character, so write the buffer so far */\n-            outputChars(current, buf, b);\n-            buf += b + w;\n-            b = 0;\n-            outputControlChar(current, ch + '@');\n-            if (i < pos) {\n-                backup++;\n-            }\n-        }\n-        else {\n-            b += w;\n-        }\n-    }\n-    outputChars(current, buf, b);\n-\n-    /* Erase to right, move cursor to original position */\n-    eraseEol(current);\n-    setCursorPos(current, pos + pchars + backup);\n-}\n-\n-static void set_current(struct current *current, const char *str)\n-{\n-    strncpy(current->buf, str, current->bufmax);\n-    current->buf[current->bufmax - 1] = 0;\n-    current->len = strlen(current->buf);\n-    current->pos = current->chars = utf8_strlen(current->buf, current->len);\n-}\n-\n-static int has_room(struct current *current, int bytes)\n-{\n-    return current->len + bytes < current->bufmax - 1;\n-}\n-\n-/**\n- * Removes the char at 'pos'.\n- *\n- * Returns 1 if the line needs to be refreshed, 2 if not\n- * and 0 if nothing was removed\n- */\n-static int remove_char(struct current *current, int pos)\n-{\n-    if (pos >= 0 && pos < current->chars) {\n-        int p1, p2;\n-        int ret = 1;\n-        p1 = utf8_index(current->buf, pos);\n-        p2 = p1 + utf8_index(current->buf + p1, 1);\n-\n-#ifdef USE_TERMIOS\n-        /* optimise remove char in the case of removing the last char */\n-        if (current->pos == pos + 1 && current->pos == current->chars) {\n-            if (current->buf[pos] >= ' ' && utf8_strlen(current->prompt, -1) + utf8_strlen(current->buf, current->len) < current->cols - 1) {\n-                ret = 2;\n-                fd_printf(current->fd, \"\\b \\b\");\n-            }\n-        }\n-#endif\n-\n-        /* Move the null char too */\n-        memmove(current->buf + p1, current->buf + p2, current->len - p2 + 1);\n-        current->len -= (p2 - p1);\n-        current->chars--;\n-\n-        if (current->pos > pos) {\n-            current->pos--;\n-        }\n-        return ret;\n-    }\n-    return 0;\n-}\n-\n-/**\n- * Insert 'ch' at position 'pos'\n- *\n- * Returns 1 if the line needs to be refreshed, 2 if not\n- * and 0 if nothing was inserted (no room)\n- */\n-static int insert_char(struct current *current, int pos, int ch)\n-{\n-    char buf[3];\n-    int n = utf8_getchars(buf, ch);\n-\n-    if (has_room(current, n) && pos >= 0 && pos <= current->chars) {\n-        int p1, p2;\n-        int ret = 1;\n-        p1 = utf8_index(current->buf, pos);\n-        p2 = p1 + n;\n-\n-#ifdef USE_TERMIOS\n-        /* optimise the case where adding a single char to the end and no scrolling is needed */\n-        if (current->pos == pos && current->chars == pos) {\n-            if (ch >= ' ' && utf8_strlen(current->prompt, -1) + utf8_strlen(current->buf, current->len) < current->cols - 1) {\n-                IGNORE_RC(write(current->fd, buf, n));\n-                ret = 2;\n-            }\n-        }\n-#endif\n-\n-        memmove(current->buf + p2, current->buf + p1, current->len - p1);\n-        memcpy(current->buf + p1, buf, n);\n-        current->len += n;\n-\n-        current->chars++;\n-        if (current->pos >= pos) {\n-            current->pos++;\n-        }\n-        return ret;\n-    }\n-    return 0;\n-}\n-\n-/**\n- * Captures up to 'n' characters starting at 'pos' for the cut buffer.\n- *\n- * This replaces any existing characters in the cut buffer.\n- */\n-static void capture_chars(struct current *current, int pos, int n)\n-{\n-    if (pos >= 0 && (pos + n - 1) < current->chars) {\n-        int p1 = utf8_index(current->buf, pos);\n-        int nbytes = utf8_index(current->buf + p1, n);\n-\n-        if (nbytes) {\n-            free(current->capture);\n-            /* Include space for the null terminator */\n-            current->capture = (char *)malloc(nbytes + 1);\n-            memcpy(current->capture, current->buf + p1, nbytes);\n-            current->capture[nbytes] = '\\0';\n-        }\n-    }\n-}\n-\n-/**\n- * Removes up to 'n' characters at cursor position 'pos'.\n- *\n- * Returns 0 if no chars were removed or non-zero otherwise.\n- */\n-static int remove_chars(struct current *current, int pos, int n)\n-{\n-    int removed = 0;\n-\n-    /* First save any chars which will be removed */\n-    capture_chars(current, pos, n);\n-\n-    while (n-- && remove_char(current, pos)) {\n-        removed++;\n-    }\n-    return removed;\n-}\n-/**\n- * Inserts the characters (string) 'chars' at the cursor position 'pos'.\n- *\n- * Returns 0 if no chars were inserted or non-zero otherwise.\n- */\n-static int insert_chars(struct current *current, int pos, const char *chars)\n-{\n-    int inserted = 0;\n-\n-    while (*chars) {\n-        int ch;\n-        int n = utf8_tounicode(chars, &ch);\n-        if (insert_char(current, pos, ch) == 0) {\n-            break;\n-        }\n-        inserted++;\n-        pos++;\n-        chars += n;\n-    }\n-    return inserted;\n-}\n-\n-#ifndef NO_COMPLETION\n-static linenoiseCompletionCallback *completionCallback = NULL;\n-\n-static void beep() {\n-#ifdef USE_TERMIOS\n-    fprintf(stderr, \"\\x7\");\n-    fflush(stderr);\n-#endif\n-}\n-\n-static void freeCompletions(linenoiseCompletions *lc) {\n-    size_t i;\n-    for (i = 0; i < lc->len; i++)\n-        free(lc->cvec[i]);\n-    free(lc->cvec);\n-}\n-\n-static int completeLine(struct current *current) {\n-    linenoiseCompletions lc = { 0, NULL };\n-    int c = 0;\n-\n-    completionCallback(current->buf,&lc);\n-    if (lc.len == 0) {\n-        beep();\n-    } else {\n-        size_t stop = 0, i = 0;\n-\n-        while(!stop) {\n-            /* Show completion or original buffer */\n-            if (i < lc.len) {\n-                struct current tmp = *current;\n-                tmp.buf = lc.cvec[i];\n-                tmp.pos = tmp.len = strlen(tmp.buf);\n-                tmp.chars = utf8_strlen(tmp.buf, tmp.len);\n-                refreshLine(current->prompt, &tmp);\n-            } else {\n-                refreshLine(current->prompt, current);\n-            }\n-\n-            c = fd_read(current);\n-            if (c == -1) {\n-                break;\n-            }\n-\n-            switch(c) {\n-                case '\\t': /* tab */\n-                    i = (i+1) % (lc.len+1);\n-                    if (i == lc.len) beep();\n-                    break;\n-                case 27: /* escape */\n-                    /* Re-show original buffer */\n-                    if (i < lc.len) {\n-                        refreshLine(current->prompt, current);\n-                    }\n-                    stop = 1;\n-                    break;\n-                default:\n-                    /* Update buffer and return */\n-                    if (i < lc.len) {\n-                        set_current(current,lc.cvec[i]);\n-                    }\n-                    stop = 1;\n-                    break;\n-            }\n-        }\n-    }\n-\n-    freeCompletions(&lc);\n-    return c; /* Return last read character */\n-}\n-\n-/* Register a callback function to be called for tab-completion. */\n-void linenoiseSetCompletionCallback(linenoiseCompletionCallback *fn) {\n-    completionCallback = fn;\n-}\n-\n-void linenoiseAddCompletion(linenoiseCompletions *lc, const char *str) {\n-    lc->cvec = (char **)realloc(lc->cvec,sizeof(char*)*(lc->len+1));\n-    lc->cvec[lc->len++] = strdup(str);\n-}\n-\n-#endif\n-\n-static int linenoiseEdit(struct current *current) {\n-    int history_index = 0;\n-\n-    /* The latest history entry is always our current buffer, that\n-     * initially is just an empty string. */\n-    linenoiseHistoryAdd(\"\");\n-\n-    set_current(current, \"\");\n-    refreshLine(current->prompt, current);\n-\n-    while(1) {\n-        int dir = -1;\n-        int c = fd_read(current);\n-\n-#ifndef NO_COMPLETION\n-        /* Only autocomplete when the callback is set. It returns < 0 when\n-         * there was an error reading from fd. Otherwise it will return the\n-         * character that should be handled next. */\n-        if (c == '\\t' && current->pos == current->chars && completionCallback != NULL) {\n-            c = completeLine(current);\n-            /* Return on errors */\n-            if (c < 0) return current->len;\n-            /* Read next character when 0 */\n-            if (c == 0) continue;\n-        }\n-#endif\n-\n-process_char:\n-        if (c == -1) return current->len;\n-#ifdef USE_TERMIOS\n-        if (c == 27) {   /* escape sequence */\n-            c = check_special(current->fd);\n-        }\n-#endif\n-        switch(c) {\n-        case '\\r':    /* enter */\n-            history_len--;\n-            free(history[history_len]);\n-            return current->len;\n-        case ctrl('C'):     /* ctrl-c */\n-            errno = EAGAIN;\n-            return -1;\n-        case 127:   /* backspace */\n-        case ctrl('H'):\n-            if (remove_char(current, current->pos - 1) == 1) {\n-                refreshLine(current->prompt, current);\n-            }\n-            break;\n-        case ctrl('D'):     /* ctrl-d */\n-            if (current->len == 0) {\n-                /* Empty line, so EOF */\n-                history_len--;\n-                free(history[history_len]);\n-                return -1;\n-            }\n-            /* Otherwise fall through to delete char to right of cursor */\n-        case SPECIAL_DELETE:\n-            if (remove_char(current, current->pos) == 1) {\n-                refreshLine(current->prompt, current);\n-            }\n-            break;\n-        case SPECIAL_INSERT:\n-            /* Ignore. Expansion Hook.\n-             * Future possibility: Toggle Insert/Overwrite Modes\n-             */\n-            break;\n-        case ctrl('W'):    /* ctrl-w, delete word at left. save deleted chars */\n-            /* eat any spaces on the left */\n-            {\n-                int pos = current->pos;\n-                while (pos > 0 && get_char(current, pos - 1) == ' ') {\n-                    pos--;\n-                }\n-\n-                /* now eat any non-spaces on the left */\n-                while (pos > 0 && get_char(current, pos - 1) != ' ') {\n-                    pos--;\n-                }\n-\n-                if (remove_chars(current, pos, current->pos - pos)) {\n-                    refreshLine(current->prompt, current);\n-                }\n-            }\n-            break;\n-        case ctrl('R'):    /* ctrl-r */\n-            {\n-                /* Display the reverse-i-search prompt and process chars */\n-                char rbuf[50];\n-                char rprompt[80];\n-                int rchars = 0;\n-                int rlen = 0;\n-                int searchpos = history_len - 1;\n-\n-                rbuf[0] = 0;\n-                while (1) {\n-                    int n = 0;\n-                    const char *p = NULL;\n-                    int skipsame = 0;\n-                    int searchdir = -1;\n-\n-                    snprintf(rprompt, sizeof(rprompt), \"(reverse-i-search)'%s': \", rbuf);\n-                    refreshLine(rprompt, current);\n-                    c = fd_read(current);\n-                    if (c == ctrl('H') || c == 127) {\n-                        if (rchars) {\n-                            int p = utf8_index(rbuf, --rchars);\n-                            rbuf[p] = 0;\n-                            rlen = strlen(rbuf);\n-                        }\n-                        continue;\n-                    }\n-#ifdef USE_TERMIOS\n-                    if (c == 27) {\n-                        c = check_special(current->fd);\n-                    }\n-#endif\n-                    if (c == ctrl('P') || c == SPECIAL_UP) {\n-                        /* Search for the previous (earlier) match */\n-                        if (searchpos > 0) {\n-                            searchpos--;\n-                        }\n-                        skipsame = 1;\n-                    }\n-                    else if (c == ctrl('N') || c == SPECIAL_DOWN) {\n-                        /* Search for the next (later) match */\n-                        if (searchpos < history_len) {\n-                            searchpos++;\n-                        }\n-                        searchdir = 1;\n-                        skipsame = 1;\n-                    }\n-                    else if (c >= ' ') {\n-                        if (rlen >= (int)sizeof(rbuf) + 3) {\n-                            continue;\n-                        }\n-\n-                        n = utf8_getchars(rbuf + rlen, c);\n-                        rlen += n;\n-                        rchars++;\n-                        rbuf[rlen] = 0;\n-\n-                        /* Adding a new char resets the search location */\n-                        searchpos = history_len - 1;\n-                    }\n-                    else {\n-                        /* Exit from incremental search mode */\n-                        break;\n-                    }\n-\n-                    /* Now search through the history for a match */\n-                    for (; searchpos >= 0 && searchpos < history_len; searchpos += searchdir) {\n-                        p = strstr(history[searchpos], rbuf);\n-                        if (p) {\n-                            /* Found a match */\n-                            if (skipsame && strcmp(history[searchpos], current->buf) == 0) {\n-                                /* But it is identical, so skip it */\n-                                continue;\n-                            }\n-                            /* Copy the matching line and set the cursor position */\n-                            set_current(current,history[searchpos]);\n-                            current->pos = utf8_strlen(history[searchpos], p - history[searchpos]);\n-                            break;\n-                        }\n-                    }\n-                    if (!p && n) {\n-                        /* No match, so don't add it */\n-                        rchars--;\n-                        rlen -= n;\n-                        rbuf[rlen] = 0;\n-                    }\n-                }\n-                if (c == ctrl('G') || c == ctrl('C')) {\n-                    /* ctrl-g terminates the search with no effect */\n-                    set_current(current, \"\");\n-                    c = 0;\n-                }\n-                else if (c == ctrl('J')) {\n-                    /* ctrl-j terminates the search leaving the buffer in place */\n-                    c = 0;\n-                }\n-                /* Go process the char normally */\n-                refreshLine(current->prompt, current);\n-                goto process_char;\n-            }\n-            break;\n-        case ctrl('T'):    /* ctrl-t */\n-            if (current->pos > 0 && current->pos <= current->chars) {\n-                /* If cursor is at end, transpose the previous two chars */\n-                int fixer = (current->pos == current->chars);\n-                c = get_char(current, current->pos - fixer);\n-                remove_char(current, current->pos - fixer);\n-                insert_char(current, current->pos - 1, c);\n-                refreshLine(current->prompt, current);\n-            }\n-            break;\n-        case ctrl('V'):    /* ctrl-v */\n-            if (has_room(current, 3)) {\n-                /* Insert the ^V first */\n-                if (insert_char(current, current->pos, c)) {\n-                    refreshLine(current->prompt, current);\n-                    /* Now wait for the next char. Can insert anything except \\0 */\n-                    c = fd_read(current);\n-\n-                    /* Remove the ^V first */\n-                    remove_char(current, current->pos - 1);\n-                    if (c != -1) {\n-                        /* Insert the actual char */\n-                        insert_char(current, current->pos, c);\n-                    }\n-                    refreshLine(current->prompt, current);\n-                }\n-            }\n-            break;\n-        case ctrl('B'):\n-        case SPECIAL_LEFT:\n-            if (current->pos > 0) {\n-                current->pos--;\n-                refreshLine(current->prompt, current);\n-            }\n-            break;\n-        case ctrl('F'):\n-        case SPECIAL_RIGHT:\n-            if (current->pos < current->chars) {\n-                current->pos++;\n-                refreshLine(current->prompt, current);\n-            }\n-            break;\n-        case SPECIAL_PAGE_UP:\n-          dir = history_len - history_index - 1; /* move to start of history */\n-          goto history_navigation;\n-        case SPECIAL_PAGE_DOWN:\n-          dir = -history_index; /* move to 0 == end of history, i.e. current */\n-          goto history_navigation;\n-        case ctrl('P'):\n-        case SPECIAL_UP:\n-            dir = 1;\n-          goto history_navigation;\n-        case ctrl('N'):\n-        case SPECIAL_DOWN:\n-history_navigation:\n-            if (history_len > 1) {\n-                /* Update the current history entry before to\n-                 * overwrite it with tne next one. */\n-                free(history[history_len - 1 - history_index]);\n-                history[history_len - 1 - history_index] = strdup(current->buf);\n-                /* Show the new entry */\n-                history_index += dir;\n-                if (history_index < 0) {\n-                    history_index = 0;\n-                    break;\n-                } else if (history_index >= history_len) {\n-                    history_index = history_len - 1;\n-                    break;\n-                }\n-                set_current(current, history[history_len - 1 - history_index]);\n-                refreshLine(current->prompt, current);\n-            }\n-            break;\n-        case ctrl('A'): /* Ctrl+a, go to the start of the line */\n-        case SPECIAL_HOME:\n-            current->pos = 0;\n-            refreshLine(current->prompt, current);\n-            break;\n-        case ctrl('E'): /* ctrl+e, go to the end of the line */\n-        case SPECIAL_END:\n-            current->pos = current->chars;\n-            refreshLine(current->prompt, current);\n-            break;\n-        case ctrl('U'): /* Ctrl+u, delete to beginning of line, save deleted chars. */\n-            if (remove_chars(current, 0, current->pos)) {\n-                refreshLine(current->prompt, current);\n-            }\n-            break;\n-        case ctrl('K'): /* Ctrl+k, delete from current to end of line, save deleted chars. */\n-            if (remove_chars(current, current->pos, current->chars - current->pos)) {\n-                refreshLine(current->prompt, current);\n-            }\n-            break;\n-        case ctrl('Y'): /* Ctrl+y, insert saved chars at current position */\n-            if (current->capture && insert_chars(current, current->pos, current->capture)) {\n-                refreshLine(current->prompt, current);\n-            }\n-            break;\n-        case ctrl('L'): /* Ctrl+L, clear screen */\n-            clearScreen(current);\n-            /* Force recalc of window size for serial terminals */\n-            current->cols = 0;\n-            refreshLine(current->prompt, current);\n-            break;\n-        default:\n-            /* Only tab is allowed without ^V */\n-            if (c == '\\t' || c >= ' ') {\n-                if (insert_char(current, current->pos, c) == 1) {\n-                    refreshLine(current->prompt, current);\n-                }\n-            }\n-            break;\n-        }\n-    }\n-    return current->len;\n-}\n-\n-int linenoiseColumns(void)\n-{\n-    struct current current;\n-    enableRawMode (&current);\n-    getWindowSize (&current);\n-    disableRawMode (&current);\n-    return current.cols;\n-}\n-\n-char *linenoise(const char *prompt)\n-{\n-    int count;\n-    struct current current;\n-    char buf[LINENOISE_MAX_LINE];\n-\n-    if (enableRawMode(&current) == -1) {\n-        printf(\"%s\", prompt);\n-        fflush(stdout);\n-        if (fgets(buf, sizeof(buf), stdin) == NULL) {\n-            return NULL;\n-        }\n-        count = strlen(buf);\n-        if (count && buf[count-1] == '\\n') {\n-            count--;\n-            buf[count] = '\\0';\n-        }\n-    }\n-    else\n-    {\n-        current.buf = buf;\n-        current.bufmax = sizeof(buf);\n-        current.len = 0;\n-        current.chars = 0;\n-        current.pos = 0;\n-        current.prompt = prompt;\n-        current.capture = NULL;\n-\n-        count = linenoiseEdit(&current);\n-\n-        disableRawMode(&current);\n-        printf(\"\\n\");\n-\n-        free(current.capture);\n-        if (count == -1) {\n-            return NULL;\n-        }\n-    }\n-    return strdup(buf);\n-}\n-\n-/* Using a circular buffer is smarter, but a bit more complex to handle. */\n-int linenoiseHistoryAdd(const char *line) {\n-    char *linecopy;\n-\n-    if (history_max_len == 0) return 0;\n-    if (history == NULL) {\n-        history = (char **)malloc(sizeof(char*)*history_max_len);\n-        if (history == NULL) return 0;\n-        memset(history,0,(sizeof(char*)*history_max_len));\n-    }\n-\n-    /* do not insert duplicate lines into history */\n-    if (history_len > 0 && strcmp(line, history[history_len - 1]) == 0) {\n-        return 0;\n-    }\n-\n-    linecopy = strdup(line);\n-    if (!linecopy) return 0;\n-    if (history_len == history_max_len) {\n-        free(history[0]);\n-        memmove(history,history+1,sizeof(char*)*(history_max_len-1));\n-        history_len--;\n-    }\n-    history[history_len] = linecopy;\n-    history_len++;\n-    return 1;\n-}\n-\n-int linenoiseHistoryGetMaxLen(void) {\n-    return history_max_len;\n-}\n-\n-int linenoiseHistorySetMaxLen(int len) {\n-    char **newHistory;\n-\n-    if (len < 1) return 0;\n-    if (history) {\n-        int tocopy = history_len;\n-\n-        newHistory = (char **)malloc(sizeof(char*)*len);\n-        if (newHistory == NULL) return 0;\n-\n-        /* If we can't copy everything, free the elements we'll not use. */\n-        if (len < tocopy) {\n-            int j;\n-\n-            for (j = 0; j < tocopy-len; j++) free(history[j]);\n-            tocopy = len;\n-        }\n-        memset(newHistory,0,sizeof(char*)*len);\n-        memcpy(newHistory,history+(history_len-tocopy), sizeof(char*)*tocopy);\n-        free(history);\n-        history = newHistory;\n-    }\n-    history_max_len = len;\n-    if (history_len > history_max_len)\n-        history_len = history_max_len;\n-    return 1;\n-}\n-\n-/* Save the history in the specified file. On success 0 is returned\n- * otherwise -1 is returned. */\n-int linenoiseHistorySave(const char *filename) {\n-    FILE *fp = fopen(filename,\"w\");\n-    int j;\n-\n-    if (fp == NULL) return -1;\n-    for (j = 0; j < history_len; j++) {\n-        const char *str = history[j];\n-        /* Need to encode backslash, nl and cr */\n-        while (*str) {\n-            if (*str == '\\\\') {\n-                fputs(\"\\\\\\\\\", fp);\n-            }\n-            else if (*str == '\\n') {\n-                fputs(\"\\\\n\", fp);\n-            }\n-            else if (*str == '\\r') {\n-                fputs(\"\\\\r\", fp);\n-            }\n-            else {\n-                fputc(*str, fp);\n-            }\n-            str++;\n-        }\n-        fputc('\\n', fp);\n-    }\n-\n-    fclose(fp);\n-    return 0;\n-}\n-\n-/* Load the history from the specified file. If the file does not exist\n- * zero is returned and no operation is performed.\n- *\n- * If the file exists and the operation succeeded 0 is returned, otherwise\n- * on error -1 is returned. */\n-int linenoiseHistoryLoad(const char *filename) {\n-    FILE *fp = fopen(filename,\"r\");\n-    char buf[LINENOISE_MAX_LINE];\n-\n-    if (fp == NULL) return -1;\n-\n-    while (fgets(buf,LINENOISE_MAX_LINE,fp) != NULL) {\n-        char *src, *dest;\n-\n-        /* Decode backslash escaped values */\n-        for (src = dest = buf; *src; src++) {\n-            char ch = *src;\n-\n-            if (ch == '\\\\') {\n-                src++;\n-                if (*src == 'n') {\n-                    ch = '\\n';\n-                }\n-                else if (*src == 'r') {\n-                    ch = '\\r';\n-                } else {\n-                    ch = *src;\n-                }\n-            }\n-            *dest++ = ch;\n-        }\n-        /* Remove trailing newline */\n-        if (dest != buf && (dest[-1] == '\\n' || dest[-1] == '\\r')) {\n-            dest--;\n-        }\n-        *dest = 0;\n-\n-        linenoiseHistoryAdd(buf);\n-    }\n-    fclose(fp);\n-    return 0;\n-}\n-\n-/* Provide access to the history buffer.\n- *\n- * If 'len' is not NULL, the length is stored in *len.\n- */\n-char **linenoiseHistory(int *len) {\n-    if (len) {\n-        *len = history_len;\n-    }\n-    return history;\n-}"}, {"sha": "7ebf244ee80e7f0bd92a551f3bb29de43ae7835a", "filename": "src/rt/linenoise/linenoise.h", "status": "removed", "additions": 0, "deletions": 61, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/7c92435f8f93344330e47fb0cca4f79297896bd2/src%2Frt%2Flinenoise%2Flinenoise.h", "raw_url": "https://github.com/rust-lang/rust/raw/7c92435f8f93344330e47fb0cca4f79297896bd2/src%2Frt%2Flinenoise%2Flinenoise.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flinenoise%2Flinenoise.h?ref=7c92435f8f93344330e47fb0cca4f79297896bd2", "patch": "@@ -1,61 +0,0 @@\n-/* linenoise.h -- guerrilla line editing library against the idea that a\n- * line editing lib needs to be 20,000 lines of C code.\n- *\n- * See linenoise.c for more information.\n- *\n- * ------------------------------------------------------------------------\n- *\n- * Copyright (c) 2010, Salvatore Sanfilippo <antirez at gmail dot com>\n- * Copyright (c) 2010, Pieter Noordhuis <pcnoordhuis at gmail dot com>\n- *\n- * All rights reserved.\n- *\n- * Redistribution and use in source and binary forms, with or without\n- * modification, are permitted provided that the following conditions are\n- * met:\n- *\n- *  *  Redistributions of source code must retain the above copyright\n- *     notice, this list of conditions and the following disclaimer.\n- *\n- *  *  Redistributions in binary form must reproduce the above copyright\n- *     notice, this list of conditions and the following disclaimer in the\n- *     documentation and/or other materials provided with the distribution.\n- *\n- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n- * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n- * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n- * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n- * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n- */\n-\n-#ifndef __LINENOISE_H\n-#define __LINENOISE_H\n-\n-#ifndef NO_COMPLETION\n-typedef struct linenoiseCompletions {\n-  size_t len;\n-  char **cvec;\n-} linenoiseCompletions;\n-\n-typedef void(linenoiseCompletionCallback)(const char *, linenoiseCompletions *);\n-void linenoiseSetCompletionCallback(linenoiseCompletionCallback *);\n-void linenoiseAddCompletion(linenoiseCompletions *, const char *);\n-#endif\n-\n-char *linenoise(const char *prompt);\n-int linenoiseHistoryAdd(const char *line);\n-int linenoiseHistorySetMaxLen(int len);\n-int linenoiseHistoryGetMaxLen(void);\n-int linenoiseHistorySave(const char *filename);\n-int linenoiseHistoryLoad(const char *filename);\n-void linenoiseHistoryFree(void);\n-char **linenoiseHistory(int *len);\n-int linenoiseColumns(void);\n-\n-#endif /* __LINENOISE_H */"}, {"sha": "26924b46c19154755c904038c949a98b033e3c50", "filename": "src/rt/linenoise/utf8.c", "status": "removed", "additions": 0, "deletions": 115, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/7c92435f8f93344330e47fb0cca4f79297896bd2/src%2Frt%2Flinenoise%2Futf8.c", "raw_url": "https://github.com/rust-lang/rust/raw/7c92435f8f93344330e47fb0cca4f79297896bd2/src%2Frt%2Flinenoise%2Futf8.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flinenoise%2Futf8.c?ref=7c92435f8f93344330e47fb0cca4f79297896bd2", "patch": "@@ -1,115 +0,0 @@\n-/**\n- * UTF-8 utility functions\n- *\n- * (c) 2010 Steve Bennett <steveb@workware.net.au>\n- *\n- * See LICENCE for licence details.\n- */\n-\n-#include <ctype.h>\n-#include <stdlib.h>\n-#include <string.h>\n-#include <stdio.h>\n-#include \"utf8.h\"\n-\n-#ifdef USE_UTF8\n-int utf8_fromunicode(char *p, unsigned short uc)\n-{\n-    if (uc <= 0x7f) {\n-        *p = uc;\n-        return 1;\n-    }\n-    else if (uc <= 0x7ff) {\n-        *p++ = 0xc0 | ((uc & 0x7c0) >> 6);\n-        *p = 0x80 | (uc & 0x3f);\n-        return 2;\n-    }\n-    else {\n-        *p++ = 0xe0 | ((uc & 0xf000) >> 12);\n-        *p++ = 0x80 | ((uc & 0xfc0) >> 6);\n-        *p = 0x80 | (uc & 0x3f);\n-        return 3;\n-    }\n-}\n-\n-int utf8_charlen(int c)\n-{\n-    if ((c & 0x80) == 0) {\n-        return 1;\n-    }\n-    if ((c & 0xe0) == 0xc0) {\n-        return 2;\n-    }\n-    if ((c & 0xf0) == 0xe0) {\n-        return 3;\n-    }\n-    if ((c & 0xf8) == 0xf0) {\n-        return 4;\n-    }\n-    /* Invalid sequence */\n-    return -1;\n-}\n-\n-int utf8_strlen(const char *str, int bytelen)\n-{\n-    int charlen = 0;\n-    if (bytelen < 0) {\n-        bytelen = strlen(str);\n-    }\n-    while (bytelen) {\n-        int c;\n-        int l = utf8_tounicode(str, &c);\n-        charlen++;\n-        str += l;\n-        bytelen -= l;\n-    }\n-    return charlen;\n-}\n-\n-int utf8_index(const char *str, int index)\n-{\n-    const char *s = str;\n-    while (index--) {\n-        int c;\n-        s += utf8_tounicode(s, &c);\n-    }\n-    return s - str;\n-}\n-\n-int utf8_charequal(const char *s1, const char *s2)\n-{\n-    int c1, c2;\n-\n-    utf8_tounicode(s1, &c1);\n-    utf8_tounicode(s2, &c2);\n-\n-    return c1 == c2;\n-}\n-\n-int utf8_tounicode(const char *str, int *uc)\n-{\n-    unsigned const char *s = (unsigned const char *)str;\n-\n-    if (s[0] < 0xc0) {\n-        *uc = s[0];\n-        return 1;\n-    }\n-    if (s[0] < 0xe0) {\n-        if ((s[1] & 0xc0) == 0x80) {\n-            *uc = ((s[0] & ~0xc0) << 6) | (s[1] & ~0x80);\n-            return 2;\n-        }\n-    }\n-    else if (s[0] < 0xf0) {\n-        if (((str[1] & 0xc0) == 0x80) && ((str[2] & 0xc0) == 0x80)) {\n-            *uc = ((s[0] & ~0xe0) << 12) | ((s[1] & ~0x80) << 6) | (s[2] & ~0x80);\n-            return 3;\n-        }\n-    }\n-\n-    /* Invalid sequence, so just return the byte */\n-    *uc = *s;\n-    return 1;\n-}\n-\n-#endif"}, {"sha": "9537939876ae091451500330b488485f740361f7", "filename": "src/rt/linenoise/utf8.h", "status": "removed", "additions": 0, "deletions": 79, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/7c92435f8f93344330e47fb0cca4f79297896bd2/src%2Frt%2Flinenoise%2Futf8.h", "raw_url": "https://github.com/rust-lang/rust/raw/7c92435f8f93344330e47fb0cca4f79297896bd2/src%2Frt%2Flinenoise%2Futf8.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flinenoise%2Futf8.h?ref=7c92435f8f93344330e47fb0cca4f79297896bd2", "patch": "@@ -1,79 +0,0 @@\n-#ifndef UTF8_UTIL_H\n-#define UTF8_UTIL_H\n-/**\n- * UTF-8 utility functions\n- *\n- * (c) 2010 Steve Bennett <steveb@workware.net.au>\n- *\n- * See LICENCE for licence details.\n- */\n-\n-#ifndef USE_UTF8\n-#include <ctype.h>\n-\n-/* No utf-8 support. 1 byte = 1 char */\n-#define utf8_strlen(S, B) ((B) < 0 ? (int)strlen(S) : (B))\n-#define utf8_tounicode(S, CP) (*(CP) = (unsigned char)*(S), 1)\n-#define utf8_index(C, I) (I)\n-#define utf8_charlen(C) 1\n-\n-#else\n-/**\n- * Converts the given unicode codepoint (0 - 0xffff) to utf-8\n- * and stores the result at 'p'.\n- * \n- * Returns the number of utf-8 characters (1-3).\n- */\n-int utf8_fromunicode(char *p, unsigned short uc);\n-\n-/**\n- * Returns the length of the utf-8 sequence starting with 'c'.\n- * \n- * Returns 1-4, or -1 if this is not a valid start byte.\n- *\n- * Note that charlen=4 is not supported by the rest of the API.\n- */\n-int utf8_charlen(int c);\n-\n-/**\n- * Returns the number of characters in the utf-8 \n- * string of the given byte length.\n- *\n- * Any bytes which are not part of an valid utf-8\n- * sequence are treated as individual characters.\n- *\n- * The string *must* be null terminated.\n- *\n- * Does not support unicode code points > \\uffff\n- */\n-int utf8_strlen(const char *str, int bytelen);\n-\n-/**\n- * Returns the byte index of the given character in the utf-8 string.\n- * \n- * The string *must* be null terminated.\n- *\n- * This will return the byte length of a utf-8 string\n- * if given the char length.\n- */\n-int utf8_index(const char *str, int charindex);\n-\n-/**\n- * Returns the unicode codepoint corresponding to the\n- * utf-8 sequence 'str'.\n- * \n- * Stores the result in *uc and returns the number of bytes\n- * consumed.\n- *\n- * If 'str' is null terminated, then an invalid utf-8 sequence\n- * at the end of the string will be returned as individual bytes.\n- *\n- * If it is not null terminated, the length *must* be checked first.\n- *\n- * Does not support unicode code points > \\uffff\n- */\n-int utf8_tounicode(const char *str, int *uc);\n-\n-#endif\n-\n-#endif"}, {"sha": "9750e22e9453b685a3896e26ddbe506ae6aefa81", "filename": "src/rt/rust_builtin.cpp", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f766acad62cd5cf7ed701a9521db2f2a96039778/src%2Frt%2Frust_builtin.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/f766acad62cd5cf7ed701a9521db2f2a96039778/src%2Frt%2Frust_builtin.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_builtin.cpp?ref=f766acad62cd5cf7ed701a9521db2f2a96039778", "patch": "@@ -570,18 +570,6 @@ rust_drop_env_lock() {\n     env_lock.unlock();\n }\n \n-static lock_and_signal linenoise_lock;\n-\n-extern \"C\" CDECL void\n-rust_take_linenoise_lock() {\n-    linenoise_lock.lock();\n-}\n-\n-extern \"C\" CDECL void\n-rust_drop_linenoise_lock() {\n-    linenoise_lock.unlock();\n-}\n-\n static lock_and_signal dlerror_lock;\n \n extern \"C\" CDECL void"}, {"sha": "fb9934c76011dcf3295dd438e2165cc59248d9d2", "filename": "src/rt/rustrt.def.in", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f766acad62cd5cf7ed701a9521db2f2a96039778/src%2Frt%2Frustrt.def.in", "raw_url": "https://github.com/rust-lang/rust/raw/f766acad62cd5cf7ed701a9521db2f2a96039778/src%2Frt%2Frustrt.def.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frustrt.def.in?ref=f766acad62cd5cf7ed701a9521db2f2a96039778", "patch": "@@ -133,13 +133,6 @@ tinfl_decompress_mem_to_heap\n rust_uv_ip4_port\n rust_uv_ip6_port\n rust_uv_tcp_getpeername\n-linenoise\n-linenoiseSetCompletionCallback\n-linenoiseAddCompletion\n-linenoiseHistoryAdd\n-linenoiseHistorySetMaxLen\n-linenoiseHistorySave\n-linenoiseHistoryLoad\n rust_raw_thread_start\n rust_raw_thread_join\n rust_raw_thread_delete\n@@ -187,8 +180,6 @@ rust_get_num_cpus\n rust_get_global_args_ptr\n rust_take_global_args_lock\n rust_drop_global_args_lock\n-rust_take_linenoise_lock\n-rust_drop_linenoise_lock\n rust_get_test_int\n rust_get_task\n rust_uv_get_loop_from_getaddrinfo_req"}, {"sha": "f6124088c9bdd4dc960970008667c9668b120fe0", "filename": "src/test/auxiliary/issue_3882.rc", "status": "removed", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/7c92435f8f93344330e47fb0cca4f79297896bd2/src%2Ftest%2Fauxiliary%2Fissue_3882.rc", "raw_url": "https://github.com/rust-lang/rust/raw/7c92435f8f93344330e47fb0cca4f79297896bd2/src%2Ftest%2Fauxiliary%2Fissue_3882.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue_3882.rc?ref=7c92435f8f93344330e47fb0cca4f79297896bd2", "patch": "@@ -1,15 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#[link(name = \"linenoise\",\n-       vers = \"0.1\")];\n-#[crate_type = \"lib\"];\n-\n-pub mod issue_3882;"}, {"sha": "bb75758c741e98d0b7de6a4c22d6c6e9a2a05ce4", "filename": "src/test/auxiliary/issue_3882.rs", "status": "removed", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/7c92435f8f93344330e47fb0cca4f79297896bd2/src%2Ftest%2Fauxiliary%2Fissue_3882.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c92435f8f93344330e47fb0cca4f79297896bd2/src%2Ftest%2Fauxiliary%2Fissue_3882.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue_3882.rs?ref=7c92435f8f93344330e47fb0cca4f79297896bd2", "patch": "@@ -1,21 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-mod issue_3882 {\n-    struct Completions {\n-        len: libc::size_t,\n-    }\n-\n-    mod c {\n-        extern {\n-            fn linenoiseAddCompletion(lc: *mut Completions);\n-        }\n-    }\n-}"}, {"sha": "202385681ce6234c4661c9fa2a7cf80610855121", "filename": "src/test/run-pass/issue_3882.rs", "status": "removed", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/7c92435f8f93344330e47fb0cca4f79297896bd2/src%2Ftest%2Frun-pass%2Fissue_3882.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c92435f8f93344330e47fb0cca4f79297896bd2/src%2Ftest%2Frun-pass%2Fissue_3882.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue_3882.rs?ref=7c92435f8f93344330e47fb0cca4f79297896bd2", "patch": "@@ -1,16 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// xfail-test\n-// aux-build:issue_3882.rc\n-extern mod linenoise;\n-use linenoise::issue_3882::*;\n-\n-pub fn main() {}"}, {"sha": "6a87a6502d211f37b90d32201f5410dd476442d0", "filename": "src/test/run-pass/rl-human-test.rs", "status": "removed", "additions": 0, "deletions": 83, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/7c92435f8f93344330e47fb0cca4f79297896bd2/src%2Ftest%2Frun-pass%2Frl-human-test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c92435f8f93344330e47fb0cca4f79297896bd2/src%2Ftest%2Frun-pass%2Frl-human-test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frl-human-test.rs?ref=7c92435f8f93344330e47fb0cca4f79297896bd2", "patch": "@@ -1,83 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// xfail-fast no compile flags for check-fast\n-\n-// we want this to be compiled to avoid bitrot, but the actual test\n-//has to be conducted by a human, i.e. someone (you?) compiling this\n-//file with a plain rustc invocation and running it and checking it\n-//works.\n-\n-// compile-flags: --cfg robot_mode\n-\n-extern mod extra;\n-use extra::rl;\n-\n-static HISTORY_FILE: &'static str = \"rl-human-test-history.txt\";\n-\n-struct TestCompleter;\n-\n-impl rl::CompletionCb for TestCompleter {\n-    fn complete(&self, line: ~str, suggest: &fn(~str)) {\n-        if line.is_empty() {\n-            suggest(~\"empty\")\n-        } else {\n-            for c in line.rev_iter().take(3) {\n-                suggest(format!(\"{0}{1}{1}{1}\", line, c))\n-            }\n-        }\n-    }\n-}\n-\n-fn main() {\n-    // don't run this in robot mode, but still typecheck it.\n-    if !cfg!(robot_mode) {\n-        println(\"~~ Welcome to the rl test \\\"suite\\\". ~~\");\n-        println!(\"Operations:\n- - restrict the history to 2 lines,\n- - set the tab-completion to suggest three copies of each of the last 3 letters (or 'empty'),\n- - add 'one' and 'two' to the history,\n- - save it to `{0}`,\n- - add 'three',\n- - prompt & save input (check the history & completion work and contains only 'two', 'three'),\n- - load from `{0}`\n- - prompt & save input (history should be 'one', 'two' again),\n- - prompt once more.\n-\n-The bool return values of each step are printed.\",\n-                 HISTORY_FILE);\n-\n-        println!(\"restricting history length: {}\", rl::set_history_max_len(3));\n-\n-        unsafe {\n-            rl::complete(@TestCompleter as @rl::CompletionCb);\n-        }\n-\n-        println!(\"adding 'one': {}\", rl::add_history(\"one\"));\n-        println!(\"adding 'two': {}\", rl::add_history(\"two\"));\n-\n-        println!(\"saving history: {}\", rl::save_history(HISTORY_FILE));\n-\n-        println!(\"adding 'three': {}\", rl::add_history(\"three\"));\n-\n-        match rl::read(\"> \") {\n-            Some(s) => println!(\"saving input: {}\", rl::add_history(s)),\n-            None => return\n-        }\n-        println!(\"loading history: {}\", rl::load_history(HISTORY_FILE));\n-\n-        match rl::read(\"> \") {\n-            Some(s) => println!(\"saving input: {}\", rl::add_history(s)),\n-            None => return\n-        }\n-\n-        rl::read(\"> \");\n-    }\n-}"}]}