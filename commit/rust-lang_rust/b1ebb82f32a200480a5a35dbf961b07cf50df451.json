{"sha": "b1ebb82f32a200480a5a35dbf961b07cf50df451", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIxZWJiODJmMzJhMjAwNDgwYTVhMzVkYmY5NjFiMDdjZjUwZGY0NTE=", "commit": {"author": {"name": "BooksBaum", "email": "15612932+Booksbaum@users.noreply.github.com", "date": "2021-08-17T16:18:02Z"}, "committer": {"name": "BooksBaum", "email": "15612932+Booksbaum@users.noreply.github.com", "date": "2021-08-17T17:23:07Z"}, "message": "Add deref (`*`) handling for usages of ref tuples", "tree": {"sha": "012358c54c7c692806b02a4abec8830242234492", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/012358c54c7c692806b02a4abec8830242234492"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b1ebb82f32a200480a5a35dbf961b07cf50df451", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEJTdsK5zmAD3L8AFljIMXU7iI9loFAmEb8HsACgkQjIMXU7iI\n9lpv2hAAymI3ivryXLiicakJVaHO8E9GpX7ttwUQumrvASEirBESK6PSiL6gx3nR\nIbBxb1/XV9wJjfOnChYdwPfO0ja9XBR+7sKHRwItitGWoV778t1yCLgCcmFIIp/x\n8dlRsqQjIxfwNQB4PlYTB3UzAP7+KC/a8xOBK6L1WSUOpXW8HFSrZKow8sKVtw9l\n6F5AcPq6qTylNnKS8VbLwep5fGrbmUluK0Rrpu5CLAw55n1Sh6J/NkmKs+wFVoDm\nN9rsY3LPSSazhp+SXk4WmApKAETyQKZ6q/QfPoWgPk4A+4zsPejjFhsOJ4j1WmAH\nIdGUB+b7QkyJTso9DmZTlOmyFNKzvziuP1WVQEgPeWSYvT5C61N0noX9E08T6K37\nbFHUVZEa8cDkz756XBBcL/IG2kyUBAiJPZYi6TpKCeT3Hm1mg8EjYDGOa9wHZmm+\n6hvW86k4Wul3gjxMS55eGc6wimTIi3I1yefrriI2COERvdsUtYx4ITuD4PhgQTvC\nRLWz8ZXmdnHegP08RS3kvHYP2nRkr5RihQlnQD0YNjgJ8Obu2nQpTup93RNIVA00\ntg7tKT+E6CpltX37YAVwUB3kax64hPvwn3GA5NPu9m+gY6C+p6iL2w6D/Jc358Zp\nGkPwb8MvVuwlTobjyD39dSgAQrZoh2Uo2rcl4q+u8eYycdzLiGI=\n=36Zm\n-----END PGP SIGNATURE-----", "payload": "tree 012358c54c7c692806b02a4abec8830242234492\nparent 384fae7fcd8e8063b30b3d318bcc8e545fca7d6b\nauthor BooksBaum <15612932+Booksbaum@users.noreply.github.com> 1629217082 +0200\ncommitter BooksBaum <15612932+Booksbaum@users.noreply.github.com> 1629220987 +0200\n\nAdd deref (`*`) handling for usages of ref tuples\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b1ebb82f32a200480a5a35dbf961b07cf50df451", "html_url": "https://github.com/rust-lang/rust/commit/b1ebb82f32a200480a5a35dbf961b07cf50df451", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b1ebb82f32a200480a5a35dbf961b07cf50df451/comments", "author": {"login": "Booksbaum", "id": 15612932, "node_id": "MDQ6VXNlcjE1NjEyOTMy", "avatar_url": "https://avatars.githubusercontent.com/u/15612932?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Booksbaum", "html_url": "https://github.com/Booksbaum", "followers_url": "https://api.github.com/users/Booksbaum/followers", "following_url": "https://api.github.com/users/Booksbaum/following{/other_user}", "gists_url": "https://api.github.com/users/Booksbaum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Booksbaum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Booksbaum/subscriptions", "organizations_url": "https://api.github.com/users/Booksbaum/orgs", "repos_url": "https://api.github.com/users/Booksbaum/repos", "events_url": "https://api.github.com/users/Booksbaum/events{/privacy}", "received_events_url": "https://api.github.com/users/Booksbaum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Booksbaum", "id": 15612932, "node_id": "MDQ6VXNlcjE1NjEyOTMy", "avatar_url": "https://avatars.githubusercontent.com/u/15612932?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Booksbaum", "html_url": "https://github.com/Booksbaum", "followers_url": "https://api.github.com/users/Booksbaum/followers", "following_url": "https://api.github.com/users/Booksbaum/following{/other_user}", "gists_url": "https://api.github.com/users/Booksbaum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Booksbaum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Booksbaum/subscriptions", "organizations_url": "https://api.github.com/users/Booksbaum/orgs", "repos_url": "https://api.github.com/users/Booksbaum/repos", "events_url": "https://api.github.com/users/Booksbaum/events{/privacy}", "received_events_url": "https://api.github.com/users/Booksbaum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "384fae7fcd8e8063b30b3d318bcc8e545fca7d6b", "url": "https://api.github.com/repos/rust-lang/rust/commits/384fae7fcd8e8063b30b3d318bcc8e545fca7d6b", "html_url": "https://github.com/rust-lang/rust/commit/384fae7fcd8e8063b30b3d318bcc8e545fca7d6b"}], "stats": {"total": 685, "additions": 643, "deletions": 42}, "files": [{"sha": "0b7c54b20b44241783328961b9190709956b8bc2", "filename": "crates/ide_assists/src/handlers/destructure_tuple_binding.rs", "status": "modified", "additions": 643, "deletions": 42, "changes": 685, "blob_url": "https://github.com/rust-lang/rust/blob/b1ebb82f32a200480a5a35dbf961b07cf50df451/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fdestructure_tuple_binding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1ebb82f32a200480a5a35dbf961b07cf50df451/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fdestructure_tuple_binding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fdestructure_tuple_binding.rs?ref=b1ebb82f32a200480a5a35dbf961b07cf50df451", "patch": "@@ -5,8 +5,8 @@ use ide_db::{\n };\n use itertools::Itertools;\n use syntax::{\n-    ast::{self, AstNode, IdentPat, NameOwner},\n-    TextRange,\n+    ast::{self, AstNode, FieldExpr, IdentPat, MethodCallExpr, NameOwner},\n+    match_ast, TextRange,\n };\n \n use crate::assist_context::{AssistBuilder, AssistContext, Assists};\n@@ -64,7 +64,7 @@ pub(crate) fn destructure_tuple_binding_impl(\n             \"Destructure tuple in sub-pattern\",\n             data.range,\n             |builder| {\n-                edit_tuple_assignment(&data, builder, ctx, true);\n+                edit_tuple_assignment(ctx, builder, &data, true);\n                 edit_tuple_usages(&data, builder, ctx, true);\n             },\n         );\n@@ -75,7 +75,7 @@ pub(crate) fn destructure_tuple_binding_impl(\n         if with_sub_pattern { \"Destructure tuple in place\" } else { \"Destructure tuple\" },\n         data.range,\n         |builder| {\n-            edit_tuple_assignment(&data, builder, ctx, false);\n+            edit_tuple_assignment(ctx, builder, &data, false);\n             edit_tuple_usages(&data, builder, ctx, false);\n         },\n     );\n@@ -85,16 +85,23 @@ pub(crate) fn destructure_tuple_binding_impl(\n \n fn collect_data(ident_pat: IdentPat, ctx: &AssistContext) -> Option<TupleData> {\n     if ident_pat.at_token().is_some() {\n-        // cannot destructure pattern with sub-pattern:\n+        // Cannot destructure pattern with sub-pattern:\n         // Only IdentPat can have sub-pattern,\n-        // but not TuplePat (`(a,b)`)\n+        // but not TuplePat (`(a,b)`).\n         cov_mark::hit!(destructure_tuple_subpattern);\n         return None;\n     }\n \n-    let ty = ctx.sema.type_of_pat(&ident_pat.clone().into())?;\n+    let ty = ctx.sema.type_of_pat(&ident_pat.clone().into())?.adjusted();\n+    let ref_type = if ty.is_mutable_reference() {\n+        Some(RefType::Mutable)\n+    } else if ty.is_reference() {\n+        Some(RefType::ReadOnly)\n+    } else {\n+        None\n+    };\n     // might be reference\n-    let ty = ty.adjusted().strip_references();\n+    let ty = ty.strip_references();\n     // must be tuple\n     let field_types = ty.tuple_fields(ctx.db());\n     if field_types.is_empty() {\n@@ -113,35 +120,40 @@ fn collect_data(ident_pat: IdentPat, ctx: &AssistContext) -> Option<TupleData> {\n     });\n \n     let field_names = (0..field_types.len())\n-        .map(|i| generate_name(i, &name, &ident_pat, &usages, ctx))\n+        .map(|i| generate_name(ctx, i, &name, &ident_pat, &usages))\n         .collect_vec();\n \n-    Some(TupleData { ident_pat, range, field_names, usages })\n+    Some(TupleData { ident_pat, range, ref_type, field_names, usages })\n }\n \n fn generate_name(\n+    _ctx: &AssistContext,\n     index: usize,\n     _tuple_name: &str,\n     _ident_pat: &IdentPat,\n     _usages: &Option<UsageSearchResult>,\n-    _ctx: &AssistContext,\n ) -> String {\n     // FIXME: detect if name already used\n     format!(\"_{}\", index)\n }\n \n+enum RefType {\n+    ReadOnly,\n+    Mutable,\n+}\n struct TupleData {\n     ident_pat: IdentPat,\n     // name: String,\n     range: TextRange,\n+    ref_type: Option<RefType>,\n     field_names: Vec<String>,\n     // field_types: Vec<Type>,\n     usages: Option<UsageSearchResult>,\n }\n fn edit_tuple_assignment(\n-    data: &TupleData,\n-    builder: &mut AssistBuilder,\n     ctx: &AssistContext,\n+    builder: &mut AssistBuilder,\n+    data: &TupleData,\n     in_sub_pattern: bool,\n ) {\n     let tuple_pat = {\n@@ -193,23 +205,20 @@ fn edit_tuple_usages(\n             builder.edit_file(*file_id);\n \n             for r in refs {\n-                edit_tuple_usage(r, data, builder, ctx, in_sub_pattern);\n+                edit_tuple_usage(ctx, builder, r, data, in_sub_pattern);\n             }\n         }\n     }\n }\n fn edit_tuple_usage(\n+    ctx: &AssistContext,\n+    builder: &mut AssistBuilder,\n     usage: &FileReference,\n     data: &TupleData,\n-    builder: &mut AssistBuilder,\n-    _ctx: &AssistContext,\n     in_sub_pattern: bool,\n ) {\n     match detect_tuple_index(usage, data) {\n-        Some(index) => {\n-            let text = &data.field_names[index.index];\n-            builder.replace(index.range, text);\n-        }\n+        Some(index) => edit_tuple_field_usage(ctx, builder, data, index),\n         None => {\n             if in_sub_pattern {\n                 cov_mark::hit!(destructure_tuple_call_with_subpattern);\n@@ -224,11 +233,26 @@ fn edit_tuple_usage(\n     }\n }\n \n+fn edit_tuple_field_usage(\n+    ctx: &AssistContext,\n+    builder: &mut AssistBuilder,\n+    data: &TupleData,\n+    index: TupleIndex,\n+) {\n+    let field_name = &data.field_names[index.index];\n+\n+    if data.ref_type.is_some() {\n+        let ref_data = handle_ref_field_usage(ctx, &index.field_expr);\n+        builder.replace(ref_data.range, ref_data.format(field_name));\n+    } else {\n+        builder.replace(index.range, field_name);\n+    }\n+}\n struct TupleIndex {\n     index: usize,\n     range: TextRange,\n+    field_expr: FieldExpr,\n }\n-\n fn detect_tuple_index(usage: &FileReference, data: &TupleData) -> Option<TupleIndex> {\n     // usage is IDENT\n     // IDENT\n@@ -268,7 +292,7 @@ fn detect_tuple_index(usage: &FileReference, data: &TupleData) -> Option<TupleIn\n                 return None;\n             }\n \n-            Some(TupleIndex { index: idx, range: field_expr.syntax().text_range() })\n+            Some(TupleIndex { index: idx, range: field_expr.syntax().text_range(), field_expr })\n         } else {\n             // tuple index out of range\n             None\n@@ -278,6 +302,115 @@ fn detect_tuple_index(usage: &FileReference, data: &TupleData) -> Option<TupleIn\n     }\n }\n \n+struct RefData {\n+    range: TextRange,\n+    needs_deref: bool,\n+    needs_parentheses: bool,\n+}\n+impl RefData {\n+    fn format(&self, field_name: &str) -> String {\n+        match (self.needs_deref, self.needs_parentheses) {\n+            (true, true) => format!(\"(*{})\", field_name),\n+            (true, false) => format!(\"*{}\", field_name),\n+            (false, true) => format!(\"({})\", field_name),\n+            (false, false) => field_name.to_string(),\n+        }\n+    }\n+}\n+fn handle_ref_field_usage(ctx: &AssistContext, field_expr: &FieldExpr) -> RefData {\n+    let s = field_expr.syntax();\n+    let mut ref_data =\n+        RefData { range: s.text_range(), needs_deref: true, needs_parentheses: true };\n+\n+    let parent = match s.parent() {\n+        Some(parent) => parent,\n+        None => return ref_data,\n+    };\n+\n+    match_ast! {\n+        match parent {\n+            ast::ParenExpr(it) => {\n+                // already parens in place -> don't replace\n+                ref_data.needs_parentheses = false;\n+                // there might be a ref outside: `&(t.0)` -> can be removed\n+                if let Some(it) = it.syntax().parent().and_then(ast::RefExpr::cast) {\n+                    ref_data.needs_deref = false;\n+                    ref_data.range =  it.syntax().text_range();\n+                }\n+            },\n+            ast::RefExpr(it) => {\n+                // `&*` -> cancel each other out\n+                ref_data.needs_deref = false;\n+                ref_data.needs_parentheses = false;\n+                // might be surrounded by parens -> can be removed too\n+                match it.syntax().parent().and_then(ast::ParenExpr::cast) {\n+                    Some(parent) => ref_data.range = parent.syntax().text_range(),\n+                    None => ref_data.range = it.syntax().text_range(),\n+                };\n+            },\n+            // higher precedence than deref `*`\n+            // https://doc.rust-lang.org/reference/expressions.html#expression-precedence\n+            // -> requires parentheses\n+            ast::PathExpr(_it) => {},\n+            ast::MethodCallExpr(it) => {\n+                // `field_expr` is `self_param` (otherwise it would be in `ArgList`)\n+\n+                // test if there's already auto-ref in place (`value` -> `&value`)\n+                // -> no method accepting `self`, but `&self` -> no need for deref\n+                //\n+                // other combinations (`&value` -> `value`, `&&value` -> `&value`, `&value` -> `&&value`) might or might not be able to auto-ref/deref,\n+                // but there might be trait implementations an added `&` might resolve to\n+                // -> ONLY handle auto-ref from `value` to `&value`\n+                fn is_auto_ref(ctx: &AssistContext, call_expr: &MethodCallExpr) -> bool {\n+                    fn impl_(ctx: &AssistContext, call_expr: &MethodCallExpr) -> Option<bool> {\n+                        let rec = call_expr.receiver()?;\n+                        let rec_ty = ctx.sema.type_of_expr(&rec)?.adjusted();\n+                        // input must be actual value\n+                        if rec_ty.is_reference() {\n+                            return Some(false);\n+                        }\n+\n+                        // doesn't resolve trait impl\n+                        let f = ctx.sema.resolve_method_call(call_expr)?;\n+                        let self_param = f.self_param(ctx.db())?;\n+                        // self must be ref\n+                        match self_param.access(ctx.db()) {\n+                            hir::Access::Shared | hir::Access::Exclusive => Some(true),\n+                            hir::Access::Owned => Some(false),\n+                        }\n+                    }\n+                    impl_(ctx, call_expr).unwrap_or(false)\n+                }\n+\n+                if is_auto_ref(ctx, &it) {\n+                    ref_data.needs_deref = false;\n+                    ref_data.needs_parentheses = false;\n+                }\n+            },\n+            ast::FieldExpr(_it) => {\n+                // `t.0.my_field`\n+                ref_data.needs_deref = false;\n+                ref_data.needs_parentheses = false;\n+            },\n+            ast::IndexExpr(_it) => {\n+                // `t.0[1]`\n+                ref_data.needs_deref = false;\n+                ref_data.needs_parentheses = false;\n+            },\n+            ast::TryExpr(_it) => {\n+                // `t.0?`\n+                // requires deref and parens: `(*_0)`\n+            },\n+            // lower precedence than deref `*` -> no parens\n+            _ => {\n+                ref_data.needs_parentheses = false;\n+            },\n+        }\n+    };\n+\n+    ref_data\n+}\n+\n #[cfg(test)]\n mod tests {\n     use super::*;\n@@ -495,9 +628,6 @@ fn main() {\n \n     #[test]\n     fn destructure_reference() {\n-        //Note: `v` has different types:\n-        // * in 1st: `i32`\n-        // * in 2nd: `&i32`\n         check_assist(\n             assist,\n             r#\"\n@@ -511,7 +641,7 @@ fn main() {\n fn main() {\n     let t = (1,2);\n     let ($0_0, _1) = &t;\n-    let v = _0;\n+    let v = *_0;\n }\n             \"#,\n         )\n@@ -532,7 +662,7 @@ fn main() {\n fn main() {\n     let t = (1,2);\n     let ($0_0, _1) = &&t;\n-    let v = _0;\n+    let v = *_0;\n }\n             \"#,\n         )\n@@ -561,9 +691,6 @@ fn foo(t: &(usize, usize)) -> usize {\n \n     #[test]\n     fn with_ref() {\n-        //Note: `v` has different types:\n-        // * in 1st: `i32`\n-        // * in 2nd: `&i32`\n         check_assist(\n             assist,\n             r#\"\n@@ -575,7 +702,7 @@ fn main() {\n             r#\"\n fn main() {\n     let (ref $0_0, ref _1) = (1,2);\n-    let v = _0;\n+    let v = *_0;\n }\n             \"#,\n         )\n@@ -604,10 +731,6 @@ fn main() {\n \n     #[test]\n     fn with_ref_mut() {\n-        //Note: `v` has different types:\n-        // * in 1st: `i32`\n-        // * in 2nd: `&mut i32`\n-        // Note: 2nd `_0 = 42` isn't valid; requires dereferencing (`*_0`), but isn't handled here!\n         check_assist(\n             assist,\n             r#\"\n@@ -620,8 +743,8 @@ fn main() {\n             r#\"\n fn main() {\n     let (ref mut $0_0, ref mut _1) = (1,2);\n-    _0 = 42;\n-    let v = _0;\n+    *_0 = 42;\n+    let v = *_0;\n }\n             \"#,\n         )\n@@ -915,7 +1038,7 @@ fn main() {\n fn main() {\n     let t = (1,2);\n     match Some(&t) {\n-        Some(($0_0, _1)) => _1,\n+        Some(($0_0, _1)) => *_1,\n         _ => 0,\n     };\n }\n@@ -1065,13 +1188,17 @@ fn main {\n         fn assist(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n             destructure_tuple_binding_impl(acc, ctx, true)\n         }\n+        fn in_place_assist(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n+            destructure_tuple_binding_impl(acc, ctx, false)\n+        }\n \n         pub(crate) fn check_in_place_assist(ra_fixture_before: &str, ra_fixture_after: &str) {\n             check_assist_by_label(\n-                assist,\n+                in_place_assist,\n                 ra_fixture_before,\n                 ra_fixture_after,\n-                \"Destructure tuple in place\",\n+                // \"Destructure tuple in place\",\n+                \"Destructure tuple\",\n             );\n         }\n \n@@ -1243,7 +1370,7 @@ fn main() {\n                 r#\"\n fn main() {\n     let ref t @ (ref $0_0, ref _1) = (1,2);\n-    let v = _1;\n+    let v = *_1;\n     let f = t.into();\n }\n                 \"#,\n@@ -1281,7 +1408,7 @@ fn main() {\n                 r#\"\n fn main() {\n     let ref mut t @ (ref mut $0_0, ref mut _1) = (1,2);\n-    let v = _1;\n+    let v = *_1;\n     let f = t.into();\n }\n                 \"#,\n@@ -1532,6 +1659,480 @@ macro_rules! m {\n fn main() {\n     let t @ ($0_0, _1) = (1,2);\n     m!(t, t.0);\n+}\n+                \"#,\n+            )\n+        }\n+    }\n+\n+    mod refs {\n+        use super::assist::*;\n+\n+        #[test]\n+        fn no_ref() {\n+            check_in_place_assist(\n+                r#\"\n+fn main() {\n+    let $0t = &(1,2);\n+    let v: i32 = t.0;\n+}\n+                \"#,\n+                r#\"\n+fn main() {\n+    let ($0_0, _1) = &(1,2);\n+    let v: i32 = *_0;\n+}\n+                \"#,\n+            )\n+        }\n+        #[test]\n+        fn no_ref_with_parens() {\n+            check_in_place_assist(\n+                r#\"\n+fn main() {\n+    let $0t = &(1,2);\n+    let v: i32 = (t.0);\n+}\n+                \"#,\n+                r#\"\n+fn main() {\n+    let ($0_0, _1) = &(1,2);\n+    let v: i32 = (*_0);\n+}\n+                \"#,\n+            )\n+        }\n+        #[test]\n+        fn with_ref() {\n+            check_in_place_assist(\n+                r#\"\n+fn main() {\n+    let $0t = &(1,2);\n+    let v: &i32 = &t.0;\n+}\n+                \"#,\n+                r#\"\n+fn main() {\n+    let ($0_0, _1) = &(1,2);\n+    let v: &i32 = _0;\n+}\n+                \"#,\n+            )\n+        }\n+        #[test]\n+        fn with_ref_in_parens_ref() {\n+            check_in_place_assist(\n+                r#\"\n+fn main() {\n+    let $0t = &(1,2);\n+    let v: &i32 = &(t.0);\n+}\n+                \"#,\n+                r#\"\n+fn main() {\n+    let ($0_0, _1) = &(1,2);\n+    let v: &i32 = _0;\n+}\n+                \"#,\n+            )\n+        }\n+        #[test]\n+        fn with_ref_in_ref_parens() {\n+            check_in_place_assist(\n+                r#\"\n+fn main() {\n+    let $0t = &(1,2);\n+    let v: &i32 = (&t.0);\n+}\n+                \"#,\n+                r#\"\n+fn main() {\n+    let ($0_0, _1) = &(1,2);\n+    let v: &i32 = _0;\n+}\n+                \"#,\n+            )\n+        }\n+\n+        #[test]\n+        fn deref_and_parentheses() {\n+            // Operator/Expressions with higher precedence than deref (`*`):\n+            // https://doc.rust-lang.org/reference/expressions.html#expression-precedence\n+            // * Path\n+            // * Method call\n+            // * Field expression\n+            // * Function calls, array indexing\n+            // * `?`\n+            check_in_place_assist(\n+                r#\"\n+//- minicore: option\n+fn f1(v: i32) {}\n+fn f2(v: &i32) {}\n+trait T {\n+    fn do_stuff(self) {}\n+}\n+impl T for i32 {\n+    fn do_stuff(self) {}\n+}\n+impl T for &i32 {\n+    fn do_stuff(self) {}\n+}\n+struct S4 {\n+    value: i32,\n+}\n+\n+fn foo() -> Option<()> {\n+    let $0t = &(0, (1,\"1\"), Some(2), [3;3], S4 { value: 4 }, &5);\n+    let v: i32 = t.0;           // deref, no parens\n+    let v: &i32 = &t.0;         // no deref, no parens, remove `&`\n+    f1(t.0);                    // deref, no parens\n+    f2(&t.0);                   // `&*` -> cancel out -> no deref, no parens\n+    // https://github.com/rust-analyzer/rust-analyzer/issues/1109#issuecomment-658868639\n+    // let v: i32 = t.1.0;      // no deref, no parens\n+    let v: i32 = t.4.value;     // no deref, no parens\n+    t.0.do_stuff();             // deref, parens\n+    let v: i32 = t.2?;          // deref, parens\n+    let v: i32 = t.3[0];        // no deref, no parens\n+    (t.0).do_stuff();           // deref, no additional parens\n+    let v: i32 = *t.5;          // deref (-> 2), no parens\n+\n+    None\n+}\n+                \"#,\n+                r#\"\n+fn f1(v: i32) {}\n+fn f2(v: &i32) {}\n+trait T {\n+    fn do_stuff(self) {}\n+}\n+impl T for i32 {\n+    fn do_stuff(self) {}\n+}\n+impl T for &i32 {\n+    fn do_stuff(self) {}\n+}\n+struct S4 {\n+    value: i32,\n+}\n+\n+fn foo() -> Option<()> {\n+    let ($0_0, _1, _2, _3, _4, _5) = &(0, (1,\"1\"), Some(2), [3;3], S4 { value: 4 }, &5);\n+    let v: i32 = *_0;           // deref, no parens\n+    let v: &i32 = _0;         // no deref, no parens, remove `&`\n+    f1(*_0);                    // deref, no parens\n+    f2(_0);                   // `&*` -> cancel out -> no deref, no parens\n+    // https://github.com/rust-analyzer/rust-analyzer/issues/1109#issuecomment-658868639\n+    // let v: i32 = t.1.0;      // no deref, no parens\n+    let v: i32 = _4.value;     // no deref, no parens\n+    (*_0).do_stuff();             // deref, parens\n+    let v: i32 = (*_2)?;          // deref, parens\n+    let v: i32 = _3[0];        // no deref, no parens\n+    (*_0).do_stuff();           // deref, no additional parens\n+    let v: i32 = **_5;          // deref (-> 2), no parens\n+\n+    None\n+}\n+                \"#,\n+            )\n+        }\n+\n+        // ---------\n+        // auto-ref/deref\n+\n+        #[test]\n+        fn self_auto_ref_doesnt_need_deref() {\n+            check_in_place_assist(\n+                r#\"\n+#[derive(Clone, Copy)]\n+struct S;\n+impl S {\n+  fn f(&self) {}\n+}\n+\n+fn main() {\n+    let $0t = &(S,2);\n+    let s = t.0.f();\n+}\n+                \"#,\n+                r#\"\n+#[derive(Clone, Copy)]\n+struct S;\n+impl S {\n+  fn f(&self) {}\n+}\n+\n+fn main() {\n+    let ($0_0, _1) = &(S,2);\n+    let s = _0.f();\n+}\n+                \"#,\n+            )\n+        }\n+\n+        #[test]\n+        fn self_owned_requires_deref() {\n+            check_in_place_assist(\n+                r#\"\n+#[derive(Clone, Copy)]\n+struct S;\n+impl S {\n+  fn f(self) {}\n+}\n+\n+fn main() {\n+    let $0t = &(S,2);\n+    let s = t.0.f();\n+}\n+                \"#,\n+                r#\"\n+#[derive(Clone, Copy)]\n+struct S;\n+impl S {\n+  fn f(self) {}\n+}\n+\n+fn main() {\n+    let ($0_0, _1) = &(S,2);\n+    let s = (*_0).f();\n+}\n+                \"#,\n+            )\n+        }\n+\n+        #[test]\n+        fn self_auto_ref_in_trait_call_doesnt_require_deref() {\n+            check_in_place_assist(\n+                r#\"\n+trait T {\n+    fn f(self);\n+}\n+#[derive(Clone, Copy)]\n+struct S;\n+impl T for &S {\n+    fn f(self) {}\n+}\n+\n+fn main() {\n+    let $0t = &(S,2);\n+    let s = t.0.f();\n+}\n+                \"#,\n+                // FIXME: doesn't need deref * parens. But `ctx.sema.resolve_method_call` doesn't resolve trait implementations\n+                r#\"\n+trait T {\n+    fn f(self);\n+}\n+#[derive(Clone, Copy)]\n+struct S;\n+impl T for &S {\n+    fn f(self) {}\n+}\n+\n+fn main() {\n+    let ($0_0, _1) = &(S,2);\n+    let s = (*_0).f();\n+}\n+                \"#,\n+            )\n+        }\n+        #[test]\n+        fn no_auto_deref_because_of_owned_and_ref_trait_impl() {\n+            check_in_place_assist(\n+                r#\"\n+trait T {\n+    fn f(self);\n+}\n+#[derive(Clone, Copy)]\n+struct S;\n+impl T for S {\n+    fn f(self) {}\n+}\n+impl T for &S {\n+    fn f(self) {}\n+}\n+\n+fn main() {\n+    let $0t = &(S,2);\n+    let s = t.0.f();\n+}\n+                \"#,\n+                r#\"\n+trait T {\n+    fn f(self);\n+}\n+#[derive(Clone, Copy)]\n+struct S;\n+impl T for S {\n+    fn f(self) {}\n+}\n+impl T for &S {\n+    fn f(self) {}\n+}\n+\n+fn main() {\n+    let ($0_0, _1) = &(S,2);\n+    let s = (*_0).f();\n+}\n+                \"#,\n+            )\n+        }\n+\n+        #[test]\n+        fn no_outer_parens_when_ref_deref() {\n+            check_in_place_assist(\n+                r#\"\n+#[derive(Clone, Copy)]\n+struct S;\n+impl S {\n+    fn do_stuff(&self) -> i32 { 42 }\n+}\n+fn main() {\n+    let $0t = &(S,&S);\n+    let v = (&t.0).do_stuff();\n+}\n+                \"#,\n+                r#\"\n+#[derive(Clone, Copy)]\n+struct S;\n+impl S {\n+    fn do_stuff(&self) -> i32 { 42 }\n+}\n+fn main() {\n+    let ($0_0, _1) = &(S,&S);\n+    let v = _0.do_stuff();\n+}\n+                \"#,\n+            )\n+        }\n+\n+        #[test]\n+        fn auto_ref_deref() {\n+            check_in_place_assist(\n+                r#\"\n+#[derive(Clone, Copy)]\n+struct S;\n+impl S {\n+    fn do_stuff(&self) -> i32 { 42 }\n+}\n+fn main() {\n+    let $0t = &(S,&S);\n+    let v = (&t.0).do_stuff();      // no deref, remove parens\n+    // `t.0` gets auto-refed -> no deref needed -> no parens\n+    let v = t.0.do_stuff();         // no deref, no parens\n+    let v = &t.0.do_stuff();        // `&` is for result -> no deref, no parens\n+    // deref: `_1` is `&&S`, but method called is on `&S` -> there might be a method accepting `&&S`\n+    let v = t.1.do_stuff();         // deref, parens\n+}\n+                \"#,\n+                r#\"\n+#[derive(Clone, Copy)]\n+struct S;\n+impl S {\n+    fn do_stuff(&self) -> i32 { 42 }\n+}\n+fn main() {\n+    let ($0_0, _1) = &(S,&S);\n+    let v = _0.do_stuff();      // no deref, remove parens\n+    // `t.0` gets auto-refed -> no deref needed -> no parens\n+    let v = _0.do_stuff();         // no deref, no parens\n+    let v = &_0.do_stuff();        // `&` is for result -> no deref, no parens\n+    // deref: `_1` is `&&S`, but method called is on `&S` -> there might be a method accepting `&&S`\n+    let v = (*_1).do_stuff();         // deref, parens\n+}\n+                \"#,\n+            )\n+        }\n+\n+        #[test]\n+        fn mutable() {\n+            check_in_place_assist(\n+                r#\"\n+fn f_owned(v: i32) {}\n+fn f(v: &i32) {}\n+fn f_mut(v: &mut i32) { *v = 42; }\n+\n+fn main() {\n+    let $0t = &mut (1,2);\n+    let v = t.0;\n+    t.0 = 42;\n+    f_owned(t.0);\n+    f(&t.0);\n+    f_mut(&mut t.0);\n+}\n+                \"#,\n+                r#\"\n+fn f_owned(v: i32) {}\n+fn f(v: &i32) {}\n+fn f_mut(v: &mut i32) { *v = 42; }\n+\n+fn main() {\n+    let ($0_0, _1) = &mut (1,2);\n+    let v = *_0;\n+    *_0 = 42;\n+    f_owned(*_0);\n+    f(_0);\n+    f_mut(_0);\n+}\n+                \"#,\n+            )\n+        }\n+\n+        #[test]\n+        fn with_ref_keyword() {\n+            check_in_place_assist(\n+                r#\"\n+fn f_owned(v: i32) {}\n+fn f(v: &i32) {}\n+\n+fn main() {\n+    let ref $0t = (1,2);\n+    let v = t.0;\n+    f_owned(t.0);\n+    f(&t.0);\n+}\n+                \"#,\n+                r#\"\n+fn f_owned(v: i32) {}\n+fn f(v: &i32) {}\n+\n+fn main() {\n+    let (ref $0_0, ref _1) = (1,2);\n+    let v = *_0;\n+    f_owned(*_0);\n+    f(_0);\n+}\n+                \"#,\n+            )\n+        }\n+        #[test]\n+        fn with_ref_mut_keywords() {\n+            check_in_place_assist(\n+                r#\"\n+fn f_owned(v: i32) {}\n+fn f(v: &i32) {}\n+fn f_mut(v: &mut i32) { *v = 42; }\n+\n+fn main() {\n+    let ref mut $0t = (1,2);\n+    let v = t.0;\n+    t.0 = 42;\n+    f_owned(t.0);\n+    f(&t.0);\n+    f_mut(&mut t.0);\n+}\n+                \"#,\n+                r#\"\n+fn f_owned(v: i32) {}\n+fn f(v: &i32) {}\n+fn f_mut(v: &mut i32) { *v = 42; }\n+\n+fn main() {\n+    let (ref mut $0_0, ref mut _1) = (1,2);\n+    let v = *_0;\n+    *_0 = 42;\n+    f_owned(*_0);\n+    f(_0);\n+    f_mut(_0);\n }\n                 \"#,\n             )"}]}