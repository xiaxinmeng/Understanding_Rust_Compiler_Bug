{"sha": "d0588007a997da288abde34a7c861c0acb0aefbd", "node_id": "C_kwDOAAsO6NoAKGQwNTg4MDA3YTk5N2RhMjg4YWJkZTM0YTdjODYxYzBhY2IwYWVmYmQ", "commit": {"author": {"name": "Lauren\u021biu Nicola", "email": "lnicola@dend.ro", "date": "2022-09-06T18:20:49Z"}, "committer": {"name": "Lauren\u021biu Nicola", "email": "lnicola@dend.ro", "date": "2022-09-06T18:20:49Z"}, "message": ":arrow_up: rust-analyzer", "tree": {"sha": "e1e3e78c9f9587595e4a4d210eaaa779a5516bcd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e1e3e78c9f9587595e4a4d210eaaa779a5516bcd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d0588007a997da288abde34a7c861c0acb0aefbd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d0588007a997da288abde34a7c861c0acb0aefbd", "html_url": "https://github.com/rust-lang/rust/commit/d0588007a997da288abde34a7c861c0acb0aefbd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d0588007a997da288abde34a7c861c0acb0aefbd/comments", "author": {"login": "lnicola", "id": 308347, "node_id": "MDQ6VXNlcjMwODM0Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/308347?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lnicola", "html_url": "https://github.com/lnicola", "followers_url": "https://api.github.com/users/lnicola/followers", "following_url": "https://api.github.com/users/lnicola/following{/other_user}", "gists_url": "https://api.github.com/users/lnicola/gists{/gist_id}", "starred_url": "https://api.github.com/users/lnicola/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lnicola/subscriptions", "organizations_url": "https://api.github.com/users/lnicola/orgs", "repos_url": "https://api.github.com/users/lnicola/repos", "events_url": "https://api.github.com/users/lnicola/events{/privacy}", "received_events_url": "https://api.github.com/users/lnicola/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lnicola", "id": 308347, "node_id": "MDQ6VXNlcjMwODM0Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/308347?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lnicola", "html_url": "https://github.com/lnicola", "followers_url": "https://api.github.com/users/lnicola/followers", "following_url": "https://api.github.com/users/lnicola/following{/other_user}", "gists_url": "https://api.github.com/users/lnicola/gists{/gist_id}", "starred_url": "https://api.github.com/users/lnicola/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lnicola/subscriptions", "organizations_url": "https://api.github.com/users/lnicola/orgs", "repos_url": "https://api.github.com/users/lnicola/repos", "events_url": "https://api.github.com/users/lnicola/events{/privacy}", "received_events_url": "https://api.github.com/users/lnicola/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "380addd7d2971447d7f6828c508a93fa8018a9b6", "url": "https://api.github.com/repos/rust-lang/rust/commits/380addd7d2971447d7f6828c508a93fa8018a9b6", "html_url": "https://github.com/rust-lang/rust/commit/380addd7d2971447d7f6828c508a93fa8018a9b6"}, {"sha": "67920f797511c360b25dab4d30730be304848f32", "url": "https://api.github.com/repos/rust-lang/rust/commits/67920f797511c360b25dab4d30730be304848f32", "html_url": "https://github.com/rust-lang/rust/commit/67920f797511c360b25dab4d30730be304848f32"}], "stats": {"total": 3842, "additions": 2934, "deletions": 908}, "files": [{"sha": "1563ee0b143851435a28597c8c088621e5c4a59b", "filename": "src/tools/rust-analyzer/.github/workflows/ci.yaml", "status": "modified", "additions": 78, "deletions": 78, "changes": 156, "blob_url": "https://github.com/rust-lang/rust/blob/d0588007a997da288abde34a7c861c0acb0aefbd/src%2Ftools%2Frust-analyzer%2F.github%2Fworkflows%2Fci.yaml", "raw_url": "https://github.com/rust-lang/rust/raw/d0588007a997da288abde34a7c861c0acb0aefbd/src%2Ftools%2Frust-analyzer%2F.github%2Fworkflows%2Fci.yaml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2F.github%2Fworkflows%2Fci.yaml?ref=d0588007a997da288abde34a7c861c0acb0aefbd", "patch": "@@ -6,15 +6,15 @@ on:\n   pull_request:\n   push:\n     branches:\n-    - auto\n-    - try\n+      - auto\n+      - try\n \n env:\n   CARGO_INCREMENTAL: 0\n   CARGO_NET_RETRY: 10\n   CI: 1\n   RUST_BACKTRACE: short\n-  RUSTFLAGS: \"-D warnings -W unreachable-pub -W rust-2021-compatibility\"\n+  RUSTFLAGS: \"-D warnings -W unreachable-pub -W bare-trait-objects\"\n   RUSTUP_MAX_RETRIES: 10\n \n jobs:\n@@ -31,25 +31,25 @@ jobs:\n         os: [ubuntu-latest, windows-latest, macos-latest]\n \n     steps:\n-    - name: Checkout repository\n-      uses: actions/checkout@v3\n-      with:\n-        ref: ${{ github.event.pull_request.head.sha }}\n-        fetch-depth: 20\n+      - name: Checkout repository\n+        uses: actions/checkout@v3\n+        with:\n+          ref: ${{ github.event.pull_request.head.sha }}\n+          fetch-depth: 20\n \n-    - name: Install Rust toolchain\n-      run: |\n-        rustup update --no-self-update stable\n-        rustup component add rustfmt rust-src\n+      - name: Install Rust toolchain\n+        run: |\n+          rustup update --no-self-update stable\n+          rustup component add rustfmt rust-src\n \n-    - name: Cache Dependencies\n-      uses: Swatinem/rust-cache@ce325b60658c1b38465c06cc965b79baf32c1e72\n+      - name: Cache Dependencies\n+        uses: Swatinem/rust-cache@ce325b60658c1b38465c06cc965b79baf32c1e72\n \n-    - name: Compile\n-      run: cargo test --no-run --locked\n+      - name: Compile\n+        run: cargo test --no-run --locked\n \n-    - name: Test\n-      run: cargo test -- --nocapture --quiet\n+      - name: Test\n+        run: cargo test -- --nocapture --quiet\n \n   # Weird targets to catch non-portable code\n   rust-cross:\n@@ -64,25 +64,25 @@ jobs:\n       targets_ide: \"wasm32-unknown-unknown\"\n \n     steps:\n-    - name: Checkout repository\n-      uses: actions/checkout@v3\n-\n-    - name: Install Rust toolchain\n-      run: |\n-        rustup update --no-self-update stable\n-        rustup target add ${{ env.targets }} ${{ env.targets_ide }}\n-\n-    - name: Cache Dependencies\n-      uses: Swatinem/rust-cache@ce325b60658c1b38465c06cc965b79baf32c1e72\n-\n-    - name: Check\n-      run: |\n-        for target in ${{ env.targets }}; do\n-          cargo check --target=$target --all-targets\n-        done\n-        for target in ${{ env.targets_ide }}; do\n-          cargo check -p ide --target=$target --all-targets\n-        done\n+      - name: Checkout repository\n+        uses: actions/checkout@v3\n+\n+      - name: Install Rust toolchain\n+        run: |\n+          rustup update --no-self-update stable\n+          rustup target add ${{ env.targets }} ${{ env.targets_ide }}\n+\n+      - name: Cache Dependencies\n+        uses: Swatinem/rust-cache@ce325b60658c1b38465c06cc965b79baf32c1e72\n+\n+      - name: Check\n+        run: |\n+          for target in ${{ env.targets }}; do\n+            cargo check --target=$target --all-targets\n+          done\n+          for target in ${{ env.targets_ide }}; do\n+            cargo check -p ide --target=$target --all-targets\n+          done\n \n   typescript:\n     if: github.repository == 'rust-lang/rust-analyzer'\n@@ -95,47 +95,47 @@ jobs:\n     runs-on: ${{ matrix.os }}\n \n     steps:\n-    - name: Checkout repository\n-      uses: actions/checkout@v3\n-\n-    - name: Install Nodejs\n-      uses: actions/setup-node@v1\n-      with:\n-        node-version: 16.x\n-\n-    - name: Install xvfb\n-      if: matrix.os == 'ubuntu-latest'\n-      run: sudo apt-get install -y xvfb\n-\n-    - run: npm ci\n-      working-directory: ./editors/code\n-\n-#    - run: npm audit || { sleep 10 && npm audit; } || { sleep 30 && npm audit; }\n-#      if: runner.os == 'Linux'\n-#      working-directory: ./editors/code\n-\n-    - run: npm run lint\n-      working-directory: ./editors/code\n-\n-    - name: Run VS Code tests (Linux)\n-      if: matrix.os == 'ubuntu-latest'\n-      env:\n-        VSCODE_CLI: 1\n-      run: xvfb-run npm test\n-      working-directory: ./editors/code\n-\n-    - name: Run VS Code tests (Windows)\n-      if: matrix.os == 'windows-latest'\n-      env:\n-        VSCODE_CLI: 1\n-      run: npm test\n-      working-directory: ./editors/code\n-\n-    - run: npm run pretest\n-      working-directory: ./editors/code\n-\n-    - run: npm run package --scripts-prepend-node-path\n-      working-directory: ./editors/code\n+      - name: Checkout repository\n+        uses: actions/checkout@v3\n+\n+      - name: Install Nodejs\n+        uses: actions/setup-node@v1\n+        with:\n+          node-version: 16.x\n+\n+      - name: Install xvfb\n+        if: matrix.os == 'ubuntu-latest'\n+        run: sudo apt-get install -y xvfb\n+\n+      - run: npm ci\n+        working-directory: ./editors/code\n+\n+      #    - run: npm audit || { sleep 10 && npm audit; } || { sleep 30 && npm audit; }\n+      #      if: runner.os == 'Linux'\n+      #      working-directory: ./editors/code\n+\n+      - run: npm run lint\n+        working-directory: ./editors/code\n+\n+      - name: Run VS Code tests (Linux)\n+        if: matrix.os == 'ubuntu-latest'\n+        env:\n+          VSCODE_CLI: 1\n+        run: xvfb-run npm test\n+        working-directory: ./editors/code\n+\n+      - name: Run VS Code tests (Windows)\n+        if: matrix.os == 'windows-latest'\n+        env:\n+          VSCODE_CLI: 1\n+        run: npm test\n+        working-directory: ./editors/code\n+\n+      - run: npm run pretest\n+        working-directory: ./editors/code\n+\n+      - run: npm run package --scripts-prepend-node-path\n+        working-directory: ./editors/code\n \n   end-success:\n     name: bors build finished"}, {"sha": "303a10615bb7b7e33e5beb616a27059321cfff58", "filename": "src/tools/rust-analyzer/.github/workflows/release.yaml", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d0588007a997da288abde34a7c861c0acb0aefbd/src%2Ftools%2Frust-analyzer%2F.github%2Fworkflows%2Frelease.yaml", "raw_url": "https://github.com/rust-lang/rust/raw/d0588007a997da288abde34a7c861c0acb0aefbd/src%2Ftools%2Frust-analyzer%2F.github%2Fworkflows%2Frelease.yaml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2F.github%2Fworkflows%2Frelease.yaml?ref=d0588007a997da288abde34a7c861c0acb0aefbd", "patch": "@@ -248,7 +248,7 @@ jobs:\n         if: github.ref == 'refs/heads/release' && (github.repository == 'rust-analyzer/rust-analyzer' || github.repository == 'rust-lang/rust-analyzer')\n         working-directory: ./editors/code\n         # token from https://dev.azure.com/rust-analyzer/\n-        run: npx ovsx publish --pat ${{ secrets.OPENVSX_TOKEN }} --packagePath ../../dist/rust-analyzer-*.vsix\n+        run: npx ovsx publish --pat ${{ secrets.OPENVSX_TOKEN }} --packagePath ../../dist/rust-analyzer-*.vsix || true\n \n       - name: Publish Extension (Code Marketplace, nightly)\n         if: github.ref != 'refs/heads/release' && (github.repository == 'rust-analyzer/rust-analyzer' || github.repository == 'rust-lang/rust-analyzer')\n@@ -258,4 +258,4 @@ jobs:\n       - name: Publish Extension (OpenVSX, nightly)\n         if: github.ref != 'refs/heads/release' && (github.repository == 'rust-analyzer/rust-analyzer' || github.repository == 'rust-lang/rust-analyzer')\n         working-directory: ./editors/code\n-        run: npx ovsx publish --pat ${{ secrets.OPENVSX_TOKEN }} --packagePath ../../dist/rust-analyzer-*.vsix\n+        run: npx ovsx publish --pat ${{ secrets.OPENVSX_TOKEN }} --packagePath ../../dist/rust-analyzer-*.vsix || true"}, {"sha": "22f5fb9926638e0f7ea9413563fbcec4a372483f", "filename": "src/tools/rust-analyzer/crates/hir-def/src/body.rs", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/d0588007a997da288abde34a7c861c0acb0aefbd/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fbody.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0588007a997da288abde34a7c861c0acb0aefbd/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fbody.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fbody.rs?ref=d0588007a997da288abde34a7c861c0acb0aefbd", "patch": "@@ -250,6 +250,10 @@ pub type PatSource = InFile<PatPtr>;\n \n pub type LabelPtr = AstPtr<ast::Label>;\n pub type LabelSource = InFile<LabelPtr>;\n+\n+pub type FieldPtr = AstPtr<ast::RecordExprField>;\n+pub type FieldSource = InFile<FieldPtr>;\n+\n /// An item body together with the mapping from syntax nodes to HIR expression\n /// IDs. This is needed to go from e.g. a position in a file to the HIR\n /// expression containing it; but for type inference etc., we want to operate on\n@@ -264,18 +268,18 @@ pub type LabelSource = InFile<LabelPtr>;\n #[derive(Default, Debug, Eq, PartialEq)]\n pub struct BodySourceMap {\n     expr_map: FxHashMap<ExprSource, ExprId>,\n-    expr_map_back: ArenaMap<ExprId, Result<ExprSource, SyntheticSyntax>>,\n+    expr_map_back: ArenaMap<ExprId, ExprSource>,\n \n     pat_map: FxHashMap<PatSource, PatId>,\n-    pat_map_back: ArenaMap<PatId, Result<PatSource, SyntheticSyntax>>,\n+    pat_map_back: ArenaMap<PatId, PatSource>,\n \n     label_map: FxHashMap<LabelSource, LabelId>,\n     label_map_back: ArenaMap<LabelId, LabelSource>,\n \n     /// We don't create explicit nodes for record fields (`S { record_field: 92 }`).\n     /// Instead, we use id of expression (`92`) to identify the field.\n-    field_map: FxHashMap<InFile<AstPtr<ast::RecordExprField>>, ExprId>,\n-    field_map_back: FxHashMap<ExprId, InFile<AstPtr<ast::RecordExprField>>>,\n+    field_map: FxHashMap<FieldSource, ExprId>,\n+    field_map_back: FxHashMap<ExprId, FieldSource>,\n \n     expansions: FxHashMap<InFile<AstPtr<ast::MacroCall>>, HirFileId>,\n \n@@ -420,7 +424,7 @@ impl Index<LabelId> for Body {\n // Perhaps `expr_syntax` and `expr_id`?\n impl BodySourceMap {\n     pub fn expr_syntax(&self, expr: ExprId) -> Result<ExprSource, SyntheticSyntax> {\n-        self.expr_map_back[expr].clone()\n+        self.expr_map_back.get(expr).cloned().ok_or(SyntheticSyntax)\n     }\n \n     pub fn node_expr(&self, node: InFile<&ast::Expr>) -> Option<ExprId> {\n@@ -434,7 +438,7 @@ impl BodySourceMap {\n     }\n \n     pub fn pat_syntax(&self, pat: PatId) -> Result<PatSource, SyntheticSyntax> {\n-        self.pat_map_back[pat].clone()\n+        self.pat_map_back.get(pat).cloned().ok_or(SyntheticSyntax)\n     }\n \n     pub fn node_pat(&self, node: InFile<&ast::Pat>) -> Option<PatId> {\n@@ -456,9 +460,10 @@ impl BodySourceMap {\n         self.label_map.get(&src).cloned()\n     }\n \n-    pub fn field_syntax(&self, expr: ExprId) -> InFile<AstPtr<ast::RecordExprField>> {\n+    pub fn field_syntax(&self, expr: ExprId) -> FieldSource {\n         self.field_map_back[&expr].clone()\n     }\n+\n     pub fn node_field(&self, node: InFile<&ast::RecordExprField>) -> Option<ExprId> {\n         let src = node.map(AstPtr::new);\n         self.field_map.get(&src).cloned()"}, {"sha": "3b3297f7811c07628ba30e2382531672f2c89c39", "filename": "src/tools/rust-analyzer/crates/hir-def/src/body/lower.rs", "status": "modified", "additions": 62, "deletions": 73, "changes": 135, "blob_url": "https://github.com/rust-lang/rust/blob/d0588007a997da288abde34a7c861c0acb0aefbd/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fbody%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0588007a997da288abde34a7c861c0acb0aefbd/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fbody%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fbody%2Flower.rs?ref=d0588007a997da288abde34a7c861c0acb0aefbd", "patch": "@@ -24,7 +24,7 @@ use syntax::{\n \n use crate::{\n     adt::StructKind,\n-    body::{Body, BodySourceMap, Expander, LabelSource, PatPtr, SyntheticSyntax},\n+    body::{Body, BodySourceMap, Expander, ExprPtr, LabelPtr, LabelSource, PatPtr},\n     body::{BodyDiagnostic, ExprSource, PatSource},\n     builtin_type::{BuiltinFloat, BuiltinInt, BuiltinUint},\n     db::DefDatabase,\n@@ -150,42 +150,42 @@ impl ExprCollector<'_> {\n         LowerCtx::new(self.db, self.expander.current_file_id)\n     }\n \n-    fn alloc_expr(&mut self, expr: Expr, ptr: AstPtr<ast::Expr>) -> ExprId {\n+    fn alloc_expr(&mut self, expr: Expr, ptr: ExprPtr) -> ExprId {\n         let src = self.expander.to_source(ptr);\n-        let id = self.make_expr(expr, Ok(src.clone()));\n+        let id = self.make_expr(expr, src.clone());\n         self.source_map.expr_map.insert(src, id);\n         id\n     }\n     // desugared exprs don't have ptr, that's wrong and should be fixed\n     // somehow.\n     fn alloc_expr_desugared(&mut self, expr: Expr) -> ExprId {\n-        self.make_expr(expr, Err(SyntheticSyntax))\n+        self.body.exprs.alloc(expr)\n     }\n     fn missing_expr(&mut self) -> ExprId {\n         self.alloc_expr_desugared(Expr::Missing)\n     }\n-    fn make_expr(&mut self, expr: Expr, src: Result<ExprSource, SyntheticSyntax>) -> ExprId {\n+    fn make_expr(&mut self, expr: Expr, src: ExprSource) -> ExprId {\n         let id = self.body.exprs.alloc(expr);\n         self.source_map.expr_map_back.insert(id, src);\n         id\n     }\n \n     fn alloc_pat(&mut self, pat: Pat, ptr: PatPtr) -> PatId {\n         let src = self.expander.to_source(ptr);\n-        let id = self.make_pat(pat, Ok(src.clone()));\n+        let id = self.make_pat(pat, src.clone());\n         self.source_map.pat_map.insert(src, id);\n         id\n     }\n     fn missing_pat(&mut self) -> PatId {\n-        self.make_pat(Pat::Missing, Err(SyntheticSyntax))\n+        self.body.pats.alloc(Pat::Missing)\n     }\n-    fn make_pat(&mut self, pat: Pat, src: Result<PatSource, SyntheticSyntax>) -> PatId {\n+    fn make_pat(&mut self, pat: Pat, src: PatSource) -> PatId {\n         let id = self.body.pats.alloc(pat);\n         self.source_map.pat_map_back.insert(id, src);\n         id\n     }\n \n-    fn alloc_label(&mut self, label: Label, ptr: AstPtr<ast::Label>) -> LabelId {\n+    fn alloc_label(&mut self, label: Label, ptr: LabelPtr) -> LabelId {\n         let src = self.expander.to_source(ptr);\n         let id = self.make_label(label, src.clone());\n         self.source_map.label_map.insert(src, id);\n@@ -550,20 +550,6 @@ impl ExprCollector<'_> {\n                     None => self.alloc_expr(Expr::Missing, syntax_ptr),\n                 }\n             }\n-            ast::Expr::MacroStmts(e) => {\n-                let statements: Box<[_]> =\n-                    e.statements().filter_map(|s| self.collect_stmt(s)).collect();\n-                let tail = e.expr().map(|e| self.collect_expr(e));\n-\n-                if e.syntax().children().next().is_none() {\n-                    // HACK: make sure that macros that expand to nothing aren't treated as a `()`\n-                    // expression when used in block tail position.\n-                    cov_mark::hit!(empty_macro_in_trailing_position_is_removed);\n-                    return None;\n-                }\n-\n-                self.alloc_expr(Expr::MacroStmts { tail, statements }, syntax_ptr)\n-            }\n             ast::Expr::UnderscoreExpr(_) => self.alloc_expr(Expr::Underscore, syntax_ptr),\n         })\n     }\n@@ -640,11 +626,46 @@ impl ExprCollector<'_> {\n         }\n     }\n \n-    fn collect_stmt(&mut self, s: ast::Stmt) -> Option<Statement> {\n+    fn collect_macro_as_stmt(\n+        &mut self,\n+        statements: &mut Vec<Statement>,\n+        mac: ast::MacroExpr,\n+    ) -> Option<ExprId> {\n+        let mac_call = mac.macro_call()?;\n+        let syntax_ptr = AstPtr::new(&ast::Expr::from(mac));\n+        let macro_ptr = AstPtr::new(&mac_call);\n+        let expansion = self.collect_macro_call(\n+            mac_call,\n+            macro_ptr,\n+            false,\n+            |this, expansion: Option<ast::MacroStmts>| match expansion {\n+                Some(expansion) => {\n+                    expansion.statements().for_each(|stmt| this.collect_stmt(statements, stmt));\n+                    expansion.expr().and_then(|expr| match expr {\n+                        ast::Expr::MacroExpr(mac) => this.collect_macro_as_stmt(statements, mac),\n+                        expr => Some(this.collect_expr(expr)),\n+                    })\n+                }\n+                None => None,\n+            },\n+        );\n+        match expansion {\n+            Some(tail) => {\n+                // Make the macro-call point to its expanded expression so we can query\n+                // semantics on syntax pointers to the macro\n+                let src = self.expander.to_source(syntax_ptr);\n+                self.source_map.expr_map.insert(src, tail);\n+                Some(tail)\n+            }\n+            None => None,\n+        }\n+    }\n+\n+    fn collect_stmt(&mut self, statements: &mut Vec<Statement>, s: ast::Stmt) {\n         match s {\n             ast::Stmt::LetStmt(stmt) => {\n                 if self.check_cfg(&stmt).is_none() {\n-                    return None;\n+                    return;\n                 }\n                 let pat = self.collect_pat_opt(stmt.pat());\n                 let type_ref =\n@@ -654,61 +675,26 @@ impl ExprCollector<'_> {\n                     .let_else()\n                     .and_then(|let_else| let_else.block_expr())\n                     .map(|block| self.collect_block(block));\n-                Some(Statement::Let { pat, type_ref, initializer, else_branch })\n+                statements.push(Statement::Let { pat, type_ref, initializer, else_branch });\n             }\n             ast::Stmt::ExprStmt(stmt) => {\n                 let expr = stmt.expr();\n-                if let Some(expr) = &expr {\n-                    if self.check_cfg(expr).is_none() {\n-                        return None;\n-                    }\n+                match &expr {\n+                    Some(expr) if self.check_cfg(expr).is_none() => return,\n+                    _ => (),\n                 }\n                 let has_semi = stmt.semicolon_token().is_some();\n                 // Note that macro could be expanded to multiple statements\n-                if let Some(expr @ ast::Expr::MacroExpr(mac)) = &expr {\n-                    let mac_call = mac.macro_call()?;\n-                    let syntax_ptr = AstPtr::new(expr);\n-                    let macro_ptr = AstPtr::new(&mac_call);\n-                    let stmt = self.collect_macro_call(\n-                        mac_call,\n-                        macro_ptr,\n-                        false,\n-                        |this, expansion: Option<ast::MacroStmts>| match expansion {\n-                            Some(expansion) => {\n-                                let statements = expansion\n-                                    .statements()\n-                                    .filter_map(|stmt| this.collect_stmt(stmt))\n-                                    .collect();\n-                                let tail = expansion.expr().map(|expr| this.collect_expr(expr));\n-\n-                                let mac_stmts = this.alloc_expr(\n-                                    Expr::MacroStmts { tail, statements },\n-                                    AstPtr::new(&ast::Expr::MacroStmts(expansion)),\n-                                );\n-\n-                                Some(mac_stmts)\n-                            }\n-                            None => None,\n-                        },\n-                    );\n-\n-                    let expr = match stmt {\n-                        Some(expr) => {\n-                            // Make the macro-call point to its expanded expression so we can query\n-                            // semantics on syntax pointers to the macro\n-                            let src = self.expander.to_source(syntax_ptr);\n-                            self.source_map.expr_map.insert(src, expr);\n-                            expr\n-                        }\n-                        None => self.alloc_expr(Expr::Missing, syntax_ptr),\n-                    };\n-                    Some(Statement::Expr { expr, has_semi })\n+                if let Some(ast::Expr::MacroExpr(mac)) = expr {\n+                    if let Some(expr) = self.collect_macro_as_stmt(statements, mac) {\n+                        statements.push(Statement::Expr { expr, has_semi })\n+                    }\n                 } else {\n                     let expr = self.collect_expr_opt(expr);\n-                    Some(Statement::Expr { expr, has_semi })\n+                    statements.push(Statement::Expr { expr, has_semi });\n                 }\n             }\n-            ast::Stmt::Item(_item) => None,\n+            ast::Stmt::Item(_item) => (),\n         }\n     }\n \n@@ -729,9 +715,12 @@ impl ExprCollector<'_> {\n         let prev_def_map = mem::replace(&mut self.expander.def_map, def_map);\n         let prev_local_module = mem::replace(&mut self.expander.module, module);\n \n-        let mut statements: Vec<_> =\n-            block.statements().filter_map(|s| self.collect_stmt(s)).collect();\n-        let tail = block.tail_expr().and_then(|e| self.maybe_collect_expr(e));\n+        let mut statements = Vec::new();\n+        block.statements().for_each(|s| self.collect_stmt(&mut statements, s));\n+        let tail = block.tail_expr().and_then(|e| match e {\n+            ast::Expr::MacroExpr(mac) => self.collect_macro_as_stmt(&mut statements, mac),\n+            expr => self.maybe_collect_expr(expr),\n+        });\n         let tail = tail.or_else(|| {\n             let stmt = statements.pop()?;\n             if let Statement::Expr { expr, has_semi: false } = stmt {"}, {"sha": "f2fed954444e2ca80b04a41a7bafa488f87905e4", "filename": "src/tools/rust-analyzer/crates/hir-def/src/body/pretty.rs", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/d0588007a997da288abde34a7c861c0acb0aefbd/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fbody%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0588007a997da288abde34a7c861c0acb0aefbd/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fbody%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fbody%2Fpretty.rs?ref=d0588007a997da288abde34a7c861c0acb0aefbd", "patch": "@@ -422,19 +422,6 @@ impl<'a> Printer<'a> {\n                 }\n                 w!(self, \"}}\");\n             }\n-            Expr::MacroStmts { statements, tail } => {\n-                w!(self, \"{{ // macro statements\");\n-                self.indented(|p| {\n-                    for stmt in statements.iter() {\n-                        p.print_stmt(stmt);\n-                    }\n-                    if let Some(tail) = tail {\n-                        p.print_expr(*tail);\n-                    }\n-                });\n-                self.newline();\n-                w!(self, \"}}\");\n-            }\n         }\n     }\n "}, {"sha": "45f64ebb06007b7c5cf1a414d02930d5a12b203a", "filename": "src/tools/rust-analyzer/crates/hir-def/src/body/scope.rs", "status": "modified", "additions": 21, "deletions": 13, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/d0588007a997da288abde34a7c861c0acb0aefbd/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fbody%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0588007a997da288abde34a7c861c0acb0aefbd/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fbody%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fbody%2Fscope.rs?ref=d0588007a997da288abde34a7c861c0acb0aefbd", "patch": "@@ -47,16 +47,9 @@ pub struct ScopeData {\n impl ExprScopes {\n     pub(crate) fn expr_scopes_query(db: &dyn DefDatabase, def: DefWithBodyId) -> Arc<ExprScopes> {\n         let body = db.body(def);\n-        Arc::new(ExprScopes::new(&*body))\n-    }\n-\n-    fn new(body: &Body) -> ExprScopes {\n-        let mut scopes =\n-            ExprScopes { scopes: Arena::default(), scope_by_expr: FxHashMap::default() };\n-        let mut root = scopes.root_scope();\n-        scopes.add_params_bindings(body, root, &body.params);\n-        compute_expr_scopes(body.body_expr, body, &mut scopes, &mut root);\n-        scopes\n+        let mut scopes = ExprScopes::new(&*body);\n+        scopes.shrink_to_fit();\n+        Arc::new(scopes)\n     }\n \n     pub fn entries(&self, scope: ScopeId) -> &[ScopeEntry] {\n@@ -89,6 +82,17 @@ impl ExprScopes {\n     pub fn scope_by_expr(&self) -> &FxHashMap<ExprId, ScopeId> {\n         &self.scope_by_expr\n     }\n+}\n+\n+impl ExprScopes {\n+    fn new(body: &Body) -> ExprScopes {\n+        let mut scopes =\n+            ExprScopes { scopes: Arena::default(), scope_by_expr: FxHashMap::default() };\n+        let mut root = scopes.root_scope();\n+        scopes.add_params_bindings(body, root, &body.params);\n+        compute_expr_scopes(body.body_expr, body, &mut scopes, &mut root);\n+        scopes\n+    }\n \n     fn root_scope(&mut self) -> ScopeId {\n         self.scopes.alloc(ScopeData { parent: None, block: None, label: None, entries: vec![] })\n@@ -138,6 +142,13 @@ impl ExprScopes {\n     fn set_scope(&mut self, node: ExprId, scope: ScopeId) {\n         self.scope_by_expr.insert(node, scope);\n     }\n+\n+    fn shrink_to_fit(&mut self) {\n+        let ExprScopes { scopes, scope_by_expr } = self;\n+        scopes.shrink_to_fit();\n+        scopes.values_mut().for_each(|it| it.entries.shrink_to_fit());\n+        scope_by_expr.shrink_to_fit();\n+    }\n }\n \n fn compute_block_scopes(\n@@ -176,9 +187,6 @@ fn compute_expr_scopes(expr: ExprId, body: &Body, scopes: &mut ExprScopes, scope\n \n     scopes.set_scope(expr, *scope);\n     match &body[expr] {\n-        Expr::MacroStmts { statements, tail } => {\n-            compute_block_scopes(statements, *tail, body, scopes, scope);\n-        }\n         Expr::Block { statements, tail, id, label } => {\n             let mut scope = scopes.new_block_scope(*scope, *id, make_label(label));\n             // Overwrite the old scope for the block expr, so that every block scope can be found"}, {"sha": "419d3feec3b6c2240c8be326edb0ad24a402c9eb", "filename": "src/tools/rust-analyzer/crates/hir-def/src/expr.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d0588007a997da288abde34a7c861c0acb0aefbd/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0588007a997da288abde34a7c861c0acb0aefbd/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fexpr.rs?ref=d0588007a997da288abde34a7c861c0acb0aefbd", "patch": "@@ -206,10 +206,6 @@ pub enum Expr {\n     Unsafe {\n         body: ExprId,\n     },\n-    MacroStmts {\n-        statements: Box<[Statement]>,\n-        tail: Option<ExprId>,\n-    },\n     Array(Array),\n     Literal(Literal),\n     Underscore,\n@@ -263,7 +259,7 @@ impl Expr {\n             Expr::Let { expr, .. } => {\n                 f(*expr);\n             }\n-            Expr::MacroStmts { tail, statements } | Expr::Block { statements, tail, .. } => {\n+            Expr::Block { statements, tail, .. } => {\n                 for stmt in statements.iter() {\n                     match stmt {\n                         Statement::Let { initializer, .. } => {"}, {"sha": "9b4ce9f97c86ff4b708e8c124ac71f07b385463e", "filename": "src/tools/rust-analyzer/crates/hir-def/src/nameres.rs", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/d0588007a997da288abde34a7c861c0acb0aefbd/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fnameres.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0588007a997da288abde34a7c861c0acb0aefbd/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fnameres.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fnameres.rs?ref=d0588007a997da288abde34a7c861c0acb0aefbd", "patch": "@@ -64,7 +64,7 @@ use hir_expand::{name::Name, InFile, MacroCallId, MacroDefId};\n use itertools::Itertools;\n use la_arena::Arena;\n use profile::Count;\n-use rustc_hash::FxHashMap;\n+use rustc_hash::{FxHashMap, FxHashSet};\n use stdx::format_to;\n use syntax::{ast, SmolStr};\n \n@@ -98,7 +98,11 @@ pub struct DefMap {\n     /// The prelude module for this crate. This either comes from an import\n     /// marked with the `prelude_import` attribute, or (in the normal case) from\n     /// a dependency (`std` or `core`).\n+    /// The prelude is empty for non-block DefMaps (unless `#[prelude_import]` was used,\n+    /// but that attribute is nightly and when used in a block, it affects resolution globally\n+    /// so we aren't handling this correctly anyways).\n     prelude: Option<ModuleId>,\n+    /// The extern prelude is only populated for non-block DefMaps\n     extern_prelude: FxHashMap<Name, ModuleId>,\n \n     /// Side table for resolving derive helpers.\n@@ -114,6 +118,8 @@ pub struct DefMap {\n     registered_attrs: Vec<SmolStr>,\n     /// Custom tool modules registered with `#![register_tool]`.\n     registered_tools: Vec<SmolStr>,\n+    /// Unstable features of Rust enabled with `#![feature(A, B)]`.\n+    unstable_features: FxHashSet<SmolStr>,\n \n     edition: Edition,\n     recursion_limit: Option<u32>,\n@@ -284,6 +290,7 @@ impl DefMap {\n             modules,\n             registered_attrs: Vec::new(),\n             registered_tools: Vec::new(),\n+            unstable_features: FxHashSet::default(),\n             diagnostics: Vec::new(),\n         }\n     }\n@@ -314,6 +321,10 @@ impl DefMap {\n         &self.registered_attrs\n     }\n \n+    pub fn is_unstable_feature_enabled(&self, feature: &str) -> bool {\n+        self.unstable_features.contains(feature)\n+    }\n+\n     pub fn root(&self) -> LocalModuleId {\n         self.root\n     }\n@@ -479,6 +490,7 @@ impl DefMap {\n             registered_tools,\n             fn_proc_macro_mapping,\n             derive_helpers_in_scope,\n+            unstable_features,\n             proc_macro_loading_error: _,\n             block: _,\n             edition: _,\n@@ -496,6 +508,7 @@ impl DefMap {\n         registered_tools.shrink_to_fit();\n         fn_proc_macro_mapping.shrink_to_fit();\n         derive_helpers_in_scope.shrink_to_fit();\n+        unstable_features.shrink_to_fit();\n         for (_, module) in modules.iter_mut() {\n             module.children.shrink_to_fit();\n             module.scope.shrink_to_fit();"}, {"sha": "495bbe4579f00780774fc970110130f7fdd0ddb3", "filename": "src/tools/rust-analyzer/crates/hir-def/src/nameres/collector.rs", "status": "modified", "additions": 18, "deletions": 6, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/d0588007a997da288abde34a7c861c0acb0aefbd/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fnameres%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0588007a997da288abde34a7c861c0acb0aefbd/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fnameres%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fnameres%2Fcollector.rs?ref=d0588007a997da288abde34a7c861c0acb0aefbd", "patch": "@@ -294,6 +294,17 @@ impl DefCollector<'_> {\n                     continue;\n                 }\n \n+                if *attr_name == hir_expand::name![feature] {\n+                    let features =\n+                        attr.parse_path_comma_token_tree().into_iter().flatten().filter_map(\n+                            |feat| match feat.segments() {\n+                                [name] => Some(name.to_smol_str()),\n+                                _ => None,\n+                            },\n+                        );\n+                    self.def_map.unstable_features.extend(features);\n+                }\n+\n                 let attr_is_register_like = *attr_name == hir_expand::name![register_attr]\n                     || *attr_name == hir_expand::name![register_tool];\n                 if !attr_is_register_like {\n@@ -501,10 +512,9 @@ impl DefCollector<'_> {\n             Edition::Edition2021 => name![rust_2021],\n         };\n \n-        let path_kind = if self.def_map.edition == Edition::Edition2015 {\n-            PathKind::Plain\n-        } else {\n-            PathKind::Abs\n+        let path_kind = match self.def_map.edition {\n+            Edition::Edition2015 => PathKind::Plain,\n+            _ => PathKind::Abs,\n         };\n         let path =\n             ModPath::from_segments(path_kind, [krate.clone(), name![prelude], edition].into_iter());\n@@ -524,7 +534,6 @@ impl DefCollector<'_> {\n             match per_ns.types {\n                 Some((ModuleDefId::ModuleId(m), _)) => {\n                     self.def_map.prelude = Some(m);\n-                    return;\n                 }\n                 types => {\n                     tracing::debug!(\n@@ -839,7 +848,10 @@ impl DefCollector<'_> {\n                 tracing::debug!(\"resolved import {:?} ({:?}) to {:?}\", name, import, def);\n \n                 // extern crates in the crate root are special-cased to insert entries into the extern prelude: rust-lang/rust#54658\n-                if import.is_extern_crate && module_id == self.def_map.root {\n+                if import.is_extern_crate\n+                    && self.def_map.block.is_none()\n+                    && module_id == self.def_map.root\n+                {\n                     if let (Some(ModuleDefId::ModuleId(def)), Some(name)) = (def.take_types(), name)\n                     {\n                         self.def_map.extern_prelude.insert(name.clone(), def);"}, {"sha": "ca7bcc814e8f8e41e4ced5c765e48f22af51a505", "filename": "src/tools/rust-analyzer/crates/hir-def/src/nameres/mod_resolution.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d0588007a997da288abde34a7c861c0acb0aefbd/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fnameres%2Fmod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0588007a997da288abde34a7c861c0acb0aefbd/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fnameres%2Fmod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fnameres%2Fmod_resolution.rs?ref=d0588007a997da288abde34a7c861c0acb0aefbd", "patch": "@@ -65,6 +65,7 @@ impl ModDir {\n         name: &Name,\n         attr_path: Option<&SmolStr>,\n     ) -> Result<(FileId, bool, ModDir), Box<[String]>> {\n+        let name = name.unescaped();\n         let orig_file_id = file_id.original_file(db.upcast());\n \n         let mut candidate_files = ArrayVec::<_, 2>::new();\n@@ -73,12 +74,10 @@ impl ModDir {\n                 candidate_files.push(self.dir_path.join_attr(attr_path, self.root_non_dir_owner))\n             }\n             None if file_id.is_include_macro(db.upcast()) => {\n-                let name = name.unescaped();\n                 candidate_files.push(format!(\"{}.rs\", name));\n                 candidate_files.push(format!(\"{}/mod.rs\", name));\n             }\n             None => {\n-                let name = name.unescaped();\n                 candidate_files.push(format!(\"{}{}.rs\", self.dir_path.0, name));\n                 candidate_files.push(format!(\"{}{}/mod.rs\", self.dir_path.0, name));\n             }"}, {"sha": "ba3bf8b5a5cfa54075da94a07765c26f98fb2a7b", "filename": "src/tools/rust-analyzer/crates/hir-def/src/nameres/tests/mod_resolution.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d0588007a997da288abde34a7c861c0acb0aefbd/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fnameres%2Ftests%2Fmod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0588007a997da288abde34a7c861c0acb0aefbd/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fnameres%2Ftests%2Fmod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fnameres%2Ftests%2Fmod_resolution.rs?ref=d0588007a997da288abde34a7c861c0acb0aefbd", "patch": "@@ -127,7 +127,15 @@ mod r#async;\n use self::r#async::Bar;\n \n //- /async.rs\n+mod foo;\n+mod r#async;\n pub struct Bar;\n+\n+//- /async/foo.rs\n+pub struct Foo;\n+\n+//- /async/async.rs\n+pub struct Baz;\n \"#,\n         expect![[r#\"\n             crate\n@@ -136,6 +144,14 @@ pub struct Bar;\n \n             crate::r#async\n             Bar: t v\n+            foo: t\n+            r#async: t\n+\n+            crate::r#async::foo\n+            Foo: t v\n+\n+            crate::r#async::r#async\n+            Baz: t v\n         \"#]],\n     );\n }"}, {"sha": "8aa5973cac57baae18937f13d92a45f2d83242f2", "filename": "src/tools/rust-analyzer/crates/hir-def/src/resolver.rs", "status": "modified", "additions": 124, "deletions": 129, "changes": 253, "blob_url": "https://github.com/rust-lang/rust/blob/d0588007a997da288abde34a7c861c0acb0aefbd/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fresolver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0588007a997da288abde34a7c861c0acb0aefbd/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fresolver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-def%2Fsrc%2Fresolver.rs?ref=d0588007a997da288abde34a7c861c0acb0aefbd", "patch": "@@ -31,12 +31,10 @@ pub struct Resolver {\n     ///\n     /// When using, you generally want to process the scopes in reverse order,\n     /// there's `scopes` *method* for that.\n-    ///\n-    /// Invariant: There exists at least one Scope::ModuleScope at the start of the vec.\n     scopes: Vec<Scope>,\n+    module_scope: ModuleItemMap,\n }\n \n-// FIXME how to store these best\n #[derive(Debug, Clone)]\n struct ModuleItemMap {\n     def_map: Arc<DefMap>,\n@@ -53,7 +51,7 @@ struct ExprScope {\n #[derive(Debug, Clone)]\n enum Scope {\n     /// All the items and imported names of a module\n-    ModuleScope(ModuleItemMap),\n+    BlockScope(ModuleItemMap),\n     /// Brings the generic parameters of an item into scope\n     GenericParams { def: GenericDefId, params: Interned<GenericParams> },\n     /// Brings `Self` in `impl` block into scope\n@@ -127,24 +125,6 @@ impl Resolver {\n         }\n     }\n \n-    fn scopes(&self) -> impl Iterator<Item = &Scope> {\n-        self.scopes.iter().rev()\n-    }\n-\n-    fn resolve_module_path(\n-        &self,\n-        db: &dyn DefDatabase,\n-        path: &ModPath,\n-        shadow: BuiltinShadowMode,\n-    ) -> PerNs {\n-        let (item_map, module) = self.module_scope();\n-        let (module_res, segment_index) = item_map.resolve_path(db, module, path, shadow);\n-        if segment_index.is_some() {\n-            return PerNs::none();\n-        }\n-        module_res\n-    }\n-\n     pub fn resolve_module_path_in_items(&self, db: &dyn DefDatabase, path: &ModPath) -> PerNs {\n         self.resolve_module_path(db, path, BuiltinShadowMode::Module)\n     }\n@@ -155,7 +135,7 @@ impl Resolver {\n         db: &dyn DefDatabase,\n         path: &ModPath,\n     ) -> Option<PerNs> {\n-        let (item_map, module) = self.module_scope();\n+        let (item_map, module) = self.item_scope();\n         let (module_res, idx) = item_map.resolve_path(db, module, path, BuiltinShadowMode::Module);\n         match module_res.take_types()? {\n             ModuleDefId::TraitId(it) => {\n@@ -183,37 +163,38 @@ impl Resolver {\n     ) -> Option<(TypeNs, Option<usize>)> {\n         let first_name = path.segments().first()?;\n         let skip_to_mod = path.kind != PathKind::Plain;\n+        if skip_to_mod {\n+            return self.module_scope.resolve_path_in_type_ns(db, path);\n+        }\n+\n+        let remaining_idx = || if path.segments().len() == 1 { None } else { Some(1) };\n+\n         for scope in self.scopes() {\n             match scope {\n                 Scope::ExprScope(_) => continue,\n-                Scope::GenericParams { .. } | Scope::ImplDefScope(_) if skip_to_mod => continue,\n-\n                 Scope::GenericParams { params, def } => {\n                     if let Some(id) = params.find_type_by_name(first_name, *def) {\n-                        let idx = if path.segments().len() == 1 { None } else { Some(1) };\n-                        return Some((TypeNs::GenericParam(id), idx));\n+                        return Some((TypeNs::GenericParam(id), remaining_idx()));\n                     }\n                 }\n-                Scope::ImplDefScope(impl_) => {\n+                &Scope::ImplDefScope(impl_) => {\n                     if first_name == &name![Self] {\n-                        let idx = if path.segments().len() == 1 { None } else { Some(1) };\n-                        return Some((TypeNs::SelfType(*impl_), idx));\n+                        return Some((TypeNs::SelfType(impl_), remaining_idx()));\n                     }\n                 }\n-                Scope::AdtScope(adt) => {\n+                &Scope::AdtScope(adt) => {\n                     if first_name == &name![Self] {\n-                        let idx = if path.segments().len() == 1 { None } else { Some(1) };\n-                        return Some((TypeNs::AdtSelfType(*adt), idx));\n+                        return Some((TypeNs::AdtSelfType(adt), remaining_idx()));\n                     }\n                 }\n-                Scope::ModuleScope(m) => {\n+                Scope::BlockScope(m) => {\n                     if let Some(res) = m.resolve_path_in_type_ns(db, path) {\n                         return Some(res);\n                     }\n                 }\n             }\n         }\n-        None\n+        self.module_scope.resolve_path_in_type_ns(db, path)\n     }\n \n     pub fn resolve_path_in_type_ns_fully(\n@@ -235,7 +216,7 @@ impl Resolver {\n     ) -> Option<Visibility> {\n         match visibility {\n             RawVisibility::Module(_) => {\n-                let (item_map, module) = self.module_scope();\n+                let (item_map, module) = self.item_scope();\n                 item_map.resolve_visibility(db, module, visibility)\n             }\n             RawVisibility::Public => Some(Visibility::Public),\n@@ -251,18 +232,14 @@ impl Resolver {\n         let tmp = name![self];\n         let first_name = if path.is_self() { &tmp } else { path.segments().first()? };\n         let skip_to_mod = path.kind != PathKind::Plain && !path.is_self();\n+        if skip_to_mod {\n+            return self.module_scope.resolve_path_in_value_ns(db, path);\n+        }\n+\n         for scope in self.scopes() {\n             match scope {\n-                Scope::AdtScope(_)\n-                | Scope::ExprScope(_)\n-                | Scope::GenericParams { .. }\n-                | Scope::ImplDefScope(_)\n-                    if skip_to_mod =>\n-                {\n-                    continue\n-                }\n-\n-                Scope::ExprScope(scope) if n_segments <= 1 => {\n+                Scope::ExprScope(_) if n_segments > 1 => continue,\n+                Scope::ExprScope(scope) => {\n                     let entry = scope\n                         .expr_scopes\n                         .entries(scope.scope_id)\n@@ -273,60 +250,56 @@ impl Resolver {\n                         return Some(ResolveValueResult::ValueNs(ValueNs::LocalBinding(e.pat())));\n                     }\n                 }\n-                Scope::ExprScope(_) => continue,\n-\n                 Scope::GenericParams { params, def } if n_segments > 1 => {\n                     if let Some(id) = params.find_type_by_name(first_name, *def) {\n                         let ty = TypeNs::GenericParam(id);\n                         return Some(ResolveValueResult::Partial(ty, 1));\n                     }\n                 }\n-                Scope::GenericParams { params, def } if n_segments == 1 => {\n+                Scope::GenericParams { .. } if n_segments != 1 => continue,\n+                Scope::GenericParams { params, def } => {\n                     if let Some(id) = params.find_const_by_name(first_name, *def) {\n                         let val = ValueNs::GenericParam(id);\n                         return Some(ResolveValueResult::ValueNs(val));\n                     }\n                 }\n-                Scope::GenericParams { .. } => continue,\n \n-                Scope::ImplDefScope(impl_) => {\n+                &Scope::ImplDefScope(impl_) => {\n                     if first_name == &name![Self] {\n-                        if n_segments > 1 {\n-                            let ty = TypeNs::SelfType(*impl_);\n-                            return Some(ResolveValueResult::Partial(ty, 1));\n+                        return Some(if n_segments > 1 {\n+                            ResolveValueResult::Partial(TypeNs::SelfType(impl_), 1)\n                         } else {\n-                            return Some(ResolveValueResult::ValueNs(ValueNs::ImplSelf(*impl_)));\n-                        }\n+                            ResolveValueResult::ValueNs(ValueNs::ImplSelf(impl_))\n+                        });\n                     }\n                 }\n+                // bare `Self` doesn't work in the value namespace in a struct/enum definition\n+                Scope::AdtScope(_) if n_segments == 1 => continue,\n                 Scope::AdtScope(adt) => {\n-                    if n_segments == 1 {\n-                        // bare `Self` doesn't work in the value namespace in a struct/enum definition\n-                        continue;\n-                    }\n                     if first_name == &name![Self] {\n                         let ty = TypeNs::AdtSelfType(*adt);\n                         return Some(ResolveValueResult::Partial(ty, 1));\n                     }\n                 }\n \n-                Scope::ModuleScope(m) => {\n+                Scope::BlockScope(m) => {\n                     if let Some(def) = m.resolve_path_in_value_ns(db, path) {\n                         return Some(def);\n                     }\n                 }\n             }\n         }\n \n+        if let res @ Some(_) = self.module_scope.resolve_path_in_value_ns(db, path) {\n+            return res;\n+        }\n+\n         // If a path of the shape `u16::from_le_bytes` failed to resolve at all, then we fall back\n         // to resolving to the primitive type, to allow this to still work in the presence of\n         // `use core::u16;`.\n         if path.kind == PathKind::Plain && path.segments().len() > 1 {\n-            match BuiltinType::by_name(&path.segments()[0]) {\n-                Some(builtin) => {\n-                    return Some(ResolveValueResult::Partial(TypeNs::BuiltinType(builtin), 1));\n-                }\n-                None => {}\n+            if let Some(builtin) = BuiltinType::by_name(&path.segments()[0]) {\n+                return Some(ResolveValueResult::Partial(TypeNs::BuiltinType(builtin), 1));\n             }\n         }\n \n@@ -345,7 +318,7 @@ impl Resolver {\n     }\n \n     pub fn resolve_path_as_macro(&self, db: &dyn DefDatabase, path: &ModPath) -> Option<MacroId> {\n-        let (item_map, module) = self.module_scope();\n+        let (item_map, module) = self.item_scope();\n         item_map.resolve_path(db, module, path, BuiltinShadowMode::Other).0.take_macros()\n     }\n \n@@ -395,30 +368,43 @@ impl Resolver {\n         for scope in self.scopes() {\n             scope.process_names(&mut res, db);\n         }\n+        let ModuleItemMap { ref def_map, module_id } = self.module_scope;\n+        // FIXME: should we provide `self` here?\n+        // f(\n+        //     Name::self_param(),\n+        //     PerNs::types(Resolution::Def {\n+        //         def: m.module.into(),\n+        //     }),\n+        // );\n+        def_map[module_id].scope.entries().for_each(|(name, def)| {\n+            res.add_per_ns(name, def);\n+        });\n+        def_map[module_id].scope.legacy_macros().for_each(|(name, macs)| {\n+            macs.iter().for_each(|&mac| {\n+                res.add(name, ScopeDef::ModuleDef(ModuleDefId::MacroId(MacroId::from(mac))));\n+            })\n+        });\n+        def_map.extern_prelude().for_each(|(name, &def)| {\n+            res.add(name, ScopeDef::ModuleDef(ModuleDefId::ModuleId(def)));\n+        });\n+        BUILTIN_SCOPE.iter().for_each(|(name, &def)| {\n+            res.add_per_ns(name, def);\n+        });\n+        if let Some(prelude) = def_map.prelude() {\n+            let prelude_def_map = prelude.def_map(db);\n+            for (name, def) in prelude_def_map[prelude.local_id].scope.entries() {\n+                res.add_per_ns(name, def)\n+            }\n+        }\n         res.map\n     }\n \n     pub fn traits_in_scope(&self, db: &dyn DefDatabase) -> FxHashSet<TraitId> {\n         let mut traits = FxHashSet::default();\n+\n         for scope in self.scopes() {\n             match scope {\n-                Scope::ModuleScope(m) => {\n-                    if let Some(prelude) = m.def_map.prelude() {\n-                        let prelude_def_map = prelude.def_map(db);\n-                        traits.extend(prelude_def_map[prelude.local_id].scope.traits());\n-                    }\n-                    traits.extend(m.def_map[m.module_id].scope.traits());\n-\n-                    // Add all traits that are in scope because of the containing DefMaps\n-                    m.def_map.with_ancestor_maps(db, m.module_id, &mut |def_map, module| {\n-                        if let Some(prelude) = def_map.prelude() {\n-                            let prelude_def_map = prelude.def_map(db);\n-                            traits.extend(prelude_def_map[prelude.local_id].scope.traits());\n-                        }\n-                        traits.extend(def_map[module].scope.traits());\n-                        None::<()>\n-                    });\n-                }\n+                Scope::BlockScope(m) => traits.extend(m.def_map[m.module_id].scope.traits()),\n                 &Scope::ImplDefScope(impl_) => {\n                     if let Some(target_trait) = &db.impl_data(impl_).target_trait {\n                         if let Some(TypeNs::TraitId(trait_)) =\n@@ -431,35 +417,28 @@ impl Resolver {\n                 _ => (),\n             }\n         }\n-        traits\n-    }\n \n-    fn module_scope(&self) -> (&DefMap, LocalModuleId) {\n-        self.scopes()\n-            .find_map(|scope| match scope {\n-                Scope::ModuleScope(m) => Some((&*m.def_map, m.module_id)),\n-                _ => None,\n-            })\n-            .expect(\"module scope invariant violated\")\n+        // Fill in the prelude traits\n+        if let Some(prelude) = self.module_scope.def_map.prelude() {\n+            let prelude_def_map = prelude.def_map(db);\n+            traits.extend(prelude_def_map[prelude.local_id].scope.traits());\n+        }\n+        // Fill in module visible traits\n+        traits.extend(self.module_scope.def_map[self.module_scope.module_id].scope.traits());\n+        traits\n     }\n \n     pub fn module(&self) -> ModuleId {\n-        let (def_map, local_id) = self.module_scope();\n+        let (def_map, local_id) = self.item_scope();\n         def_map.module_id(local_id)\n     }\n \n     pub fn krate(&self) -> CrateId {\n-        self.def_map().krate()\n+        self.module_scope.def_map.krate()\n     }\n \n     pub fn def_map(&self) -> &DefMap {\n-        self.scopes\n-            .get(0)\n-            .and_then(|scope| match scope {\n-                Scope::ModuleScope(m) => Some(&m.def_map),\n-                _ => None,\n-            })\n-            .expect(\"module scope invariant violated\")\n+        self.item_scope().0\n     }\n \n     pub fn where_predicates_in_scope(\n@@ -488,6 +467,36 @@ impl Resolver {\n     }\n }\n \n+impl Resolver {\n+    fn scopes(&self) -> impl Iterator<Item = &Scope> {\n+        self.scopes.iter().rev()\n+    }\n+\n+    fn resolve_module_path(\n+        &self,\n+        db: &dyn DefDatabase,\n+        path: &ModPath,\n+        shadow: BuiltinShadowMode,\n+    ) -> PerNs {\n+        let (item_map, module) = self.item_scope();\n+        let (module_res, segment_index) = item_map.resolve_path(db, module, path, shadow);\n+        if segment_index.is_some() {\n+            return PerNs::none();\n+        }\n+        module_res\n+    }\n+\n+    /// The innermost block scope that contains items or the module scope that contains this resolver.\n+    fn item_scope(&self) -> (&DefMap, LocalModuleId) {\n+        self.scopes()\n+            .find_map(|scope| match scope {\n+                Scope::BlockScope(m) => Some((&*m.def_map, m.module_id)),\n+                _ => None,\n+            })\n+            .unwrap_or((&self.module_scope.def_map, self.module_scope.module_id))\n+    }\n+}\n+\n #[derive(Copy, Clone, Debug, PartialEq, Eq)]\n pub enum ScopeDef {\n     ModuleDef(ModuleDefId),\n@@ -502,14 +511,7 @@ pub enum ScopeDef {\n impl Scope {\n     fn process_names(&self, acc: &mut ScopeNames, db: &dyn DefDatabase) {\n         match self {\n-            Scope::ModuleScope(m) => {\n-                // FIXME: should we provide `self` here?\n-                // f(\n-                //     Name::self_param(),\n-                //     PerNs::types(Resolution::Def {\n-                //         def: m.module.into(),\n-                //     }),\n-                // );\n+            Scope::BlockScope(m) => {\n                 m.def_map[m.module_id].scope.entries().for_each(|(name, def)| {\n                     acc.add_per_ns(name, def);\n                 });\n@@ -521,18 +523,6 @@ impl Scope {\n                         );\n                     })\n                 });\n-                m.def_map.extern_prelude().for_each(|(name, &def)| {\n-                    acc.add(name, ScopeDef::ModuleDef(ModuleDefId::ModuleId(def)));\n-                });\n-                BUILTIN_SCOPE.iter().for_each(|(name, &def)| {\n-                    acc.add_per_ns(name, def);\n-                });\n-                if let Some(prelude) = m.def_map.prelude() {\n-                    let prelude_def_map = prelude.def_map(db);\n-                    for (name, def) in prelude_def_map[prelude.local_id].scope.entries() {\n-                        acc.add_per_ns(name, def)\n-                    }\n-                }\n             }\n             Scope::GenericParams { params, def: parent } => {\n                 let parent = *parent;\n@@ -596,7 +586,7 @@ pub fn resolver_for_scope(\n         if let Some(block) = scopes.block(scope) {\n             if let Some(def_map) = db.block_def_map(block) {\n                 let root = def_map.root();\n-                r = r.push_module_scope(def_map, root);\n+                r = r.push_block_scope(def_map, root);\n                 // FIXME: This adds as many module scopes as there are blocks, but resolving in each\n                 // already traverses all parents, so this is O(n\u00b2). I think we could only store the\n                 // innermost module scope instead?\n@@ -623,8 +613,8 @@ impl Resolver {\n         self.push_scope(Scope::ImplDefScope(impl_def))\n     }\n \n-    fn push_module_scope(self, def_map: Arc<DefMap>, module_id: LocalModuleId) -> Resolver {\n-        self.push_scope(Scope::ModuleScope(ModuleItemMap { def_map, module_id }))\n+    fn push_block_scope(self, def_map: Arc<DefMap>, module_id: LocalModuleId) -> Resolver {\n+        self.push_scope(Scope::BlockScope(ModuleItemMap { def_map, module_id }))\n     }\n \n     fn push_expr_scope(\n@@ -768,14 +758,19 @@ pub trait HasResolver: Copy {\n impl HasResolver for ModuleId {\n     fn resolver(self, db: &dyn DefDatabase) -> Resolver {\n         let mut def_map = self.def_map(db);\n-        let mut modules: SmallVec<[_; 2]> = smallvec![(def_map.clone(), self.local_id)];\n+        let mut modules: SmallVec<[_; 1]> = smallvec![];\n+        let mut module_id = self.local_id;\n         while let Some(parent) = def_map.parent() {\n+            modules.push((def_map, module_id));\n             def_map = parent.def_map(db);\n-            modules.push((def_map.clone(), parent.local_id));\n+            module_id = parent.local_id;\n         }\n-        let mut resolver = Resolver { scopes: Vec::with_capacity(modules.len()) };\n+        let mut resolver = Resolver {\n+            scopes: Vec::with_capacity(modules.len()),\n+            module_scope: ModuleItemMap { def_map, module_id },\n+        };\n         for (def_map, module) in modules.into_iter().rev() {\n-            resolver = resolver.push_module_scope(def_map, module);\n+            resolver = resolver.push_block_scope(def_map, module);\n         }\n         resolver\n     }"}, {"sha": "fc128102f225a18cc066193e649e843dd2147906", "filename": "src/tools/rust-analyzer/crates/hir-expand/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d0588007a997da288abde34a7c861c0acb0aefbd/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0588007a997da288abde34a7c861c0acb0aefbd/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Flib.rs?ref=d0588007a997da288abde34a7c861c0acb0aefbd", "patch": "@@ -969,7 +969,7 @@ impl ExpandTo {\n         if parent.kind() == MACRO_EXPR\n             && parent\n                 .parent()\n-                .map_or(true, |p| matches!(p.kind(), EXPR_STMT | STMT_LIST | MACRO_STMTS))\n+                .map_or(false, |p| matches!(p.kind(), EXPR_STMT | STMT_LIST | MACRO_STMTS))\n         {\n             return ExpandTo::Statements;\n         }"}, {"sha": "4ce21a57967c72048f59b5db4517c544d075b528", "filename": "src/tools/rust-analyzer/crates/hir-expand/src/name.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d0588007a997da288abde34a7c861c0acb0aefbd/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Fname.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0588007a997da288abde34a7c861c0acb0aefbd/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Fname.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-expand%2Fsrc%2Fname.rs?ref=d0588007a997da288abde34a7c861c0acb0aefbd", "patch": "@@ -336,6 +336,7 @@ pub mod known {\n         test,\n         test_case,\n         recursion_limit,\n+        feature,\n         // Safe intrinsics\n         abort,\n         add_with_overflow,"}, {"sha": "344036dd8139d28d433c745b6121ab8c85e9865f", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/autoderef.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d0588007a997da288abde34a7c861c0acb0aefbd/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fautoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0588007a997da288abde34a7c861c0acb0aefbd/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fautoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fautoderef.rs?ref=d0588007a997da288abde34a7c861c0acb0aefbd", "patch": "@@ -104,8 +104,7 @@ pub(crate) fn deref(table: &mut InferenceTable<'_>, ty: Ty) -> Option<Ty> {\n \n fn builtin_deref(ty: &Ty) -> Option<&Ty> {\n     match ty.kind(Interner) {\n-        TyKind::Ref(.., ty) => Some(ty),\n-        TyKind::Raw(.., ty) => Some(ty),\n+        TyKind::Ref(.., ty) | TyKind::Raw(.., ty) => Some(ty),\n         _ => None,\n     }\n }"}, {"sha": "c8df4c796efca045f974d21e3b21a8a67e23bf28", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/diagnostics/expr.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d0588007a997da288abde34a7c861c0acb0aefbd/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fdiagnostics%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0588007a997da288abde34a7c861c0acb0aefbd/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fdiagnostics%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fdiagnostics%2Fexpr.rs?ref=d0588007a997da288abde34a7c861c0acb0aefbd", "patch": "@@ -159,12 +159,7 @@ impl ExprValidator {\n         }\n \n         let pattern_arena = Arena::new();\n-        let cx = MatchCheckCtx {\n-            module: self.owner.module(db.upcast()),\n-            body: self.owner,\n-            db,\n-            pattern_arena: &pattern_arena,\n-        };\n+        let cx = MatchCheckCtx::new(self.owner.module(db.upcast()), self.owner, db, &pattern_arena);\n \n         let mut m_arms = Vec::with_capacity(arms.len());\n         let mut has_lowering_errors = false;"}, {"sha": "47d60fc41e700bc2962665e48ab04f6720b3884d", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/diagnostics/match_check/deconstruct_pat.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d0588007a997da288abde34a7c861c0acb0aefbd/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fdiagnostics%2Fmatch_check%2Fdeconstruct_pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0588007a997da288abde34a7c861c0acb0aefbd/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fdiagnostics%2Fmatch_check%2Fdeconstruct_pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fdiagnostics%2Fmatch_check%2Fdeconstruct_pat.rs?ref=d0588007a997da288abde34a7c861c0acb0aefbd", "patch": "@@ -52,7 +52,10 @@ use hir_def::{EnumVariantId, HasModule, LocalFieldId, VariantId};\n use smallvec::{smallvec, SmallVec};\n use stdx::never;\n \n-use crate::{infer::normalize, AdtId, Interner, Scalar, Ty, TyExt, TyKind};\n+use crate::{\n+    infer::normalize, inhabitedness::is_enum_variant_uninhabited_from, AdtId, Interner, Scalar, Ty,\n+    TyExt, TyKind,\n+};\n \n use super::{\n     is_box,\n@@ -557,8 +560,8 @@ impl SplitWildcard {\n             TyKind::Scalar(Scalar::Bool) => smallvec![make_range(0, 1, Scalar::Bool)],\n             // TyKind::Array(..) if ... => unhandled(),\n             TyKind::Array(..) | TyKind::Slice(..) => unhandled(),\n-            &TyKind::Adt(AdtId(hir_def::AdtId::EnumId(enum_id)), ..) => {\n-                let enum_data = cx.db.enum_data(enum_id);\n+            TyKind::Adt(AdtId(hir_def::AdtId::EnumId(enum_id)), subst) => {\n+                let enum_data = cx.db.enum_data(*enum_id);\n \n                 // If the enum is declared as `#[non_exhaustive]`, we treat it as if it had an\n                 // additional \"unknown\" constructor.\n@@ -591,14 +594,15 @@ impl SplitWildcard {\n                 let mut ctors: SmallVec<[_; 1]> = enum_data\n                     .variants\n                     .iter()\n-                    .filter(|&(_, _v)| {\n+                    .map(|(local_id, _)| EnumVariantId { parent: *enum_id, local_id })\n+                    .filter(|&variant| {\n                         // If `exhaustive_patterns` is enabled, we exclude variants known to be\n                         // uninhabited.\n                         let is_uninhabited = is_exhaustive_pat_feature\n-                            && unimplemented!(\"after MatchCheckCtx.feature_exhaustive_patterns()\");\n+                            && is_enum_variant_uninhabited_from(variant, subst, cx.module, cx.db);\n                         !is_uninhabited\n                     })\n-                    .map(|(local_id, _)| Variant(EnumVariantId { parent: enum_id, local_id }))\n+                    .map(Variant)\n                     .collect();\n \n                 if is_secretly_empty || is_declared_nonexhaustive {"}, {"sha": "c4d709a975b0299a7a0a0374b83d9e12824a8236", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/diagnostics/match_check/usefulness.rs", "status": "modified", "additions": 21, "deletions": 8, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/d0588007a997da288abde34a7c861c0acb0aefbd/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fdiagnostics%2Fmatch_check%2Fusefulness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0588007a997da288abde34a7c861c0acb0aefbd/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fdiagnostics%2Fmatch_check%2Fusefulness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Fdiagnostics%2Fmatch_check%2Fusefulness.rs?ref=d0588007a997da288abde34a7c861c0acb0aefbd", "patch": "@@ -277,7 +277,7 @@ use hir_def::{AdtId, DefWithBodyId, HasModule, ModuleId};\n use smallvec::{smallvec, SmallVec};\n use typed_arena::Arena;\n \n-use crate::{db::HirDatabase, Ty, TyExt};\n+use crate::{db::HirDatabase, inhabitedness::is_ty_uninhabited_from, Ty, TyExt};\n \n use super::deconstruct_pat::{Constructor, DeconstructedPat, Fields, SplitWildcard};\n \n@@ -289,13 +289,27 @@ pub(crate) struct MatchCheckCtx<'a, 'p> {\n     pub(crate) db: &'a dyn HirDatabase,\n     /// Lowered patterns from arms plus generated by the check.\n     pub(crate) pattern_arena: &'p Arena<DeconstructedPat<'p>>,\n+    exhaustive_patterns: bool,\n }\n \n impl<'a, 'p> MatchCheckCtx<'a, 'p> {\n-    pub(super) fn is_uninhabited(&self, _ty: &Ty) -> bool {\n-        // FIXME(iDawer) implement exhaustive_patterns feature. More info in:\n-        // Tracking issue for RFC 1872: exhaustive_patterns feature https://github.com/rust-lang/rust/issues/51085\n-        false\n+    pub(crate) fn new(\n+        module: ModuleId,\n+        body: DefWithBodyId,\n+        db: &'a dyn HirDatabase,\n+        pattern_arena: &'p Arena<DeconstructedPat<'p>>,\n+    ) -> Self {\n+        let def_map = db.crate_def_map(module.krate());\n+        let exhaustive_patterns = def_map.is_unstable_feature_enabled(\"exhaustive_patterns\");\n+        Self { module, body, db, pattern_arena, exhaustive_patterns }\n+    }\n+\n+    pub(super) fn is_uninhabited(&self, ty: &Ty) -> bool {\n+        if self.feature_exhaustive_patterns() {\n+            is_ty_uninhabited_from(ty, self.module, self.db)\n+        } else {\n+            false\n+        }\n     }\n \n     /// Returns whether the given type is an enum from another crate declared `#[non_exhaustive]`.\n@@ -311,10 +325,9 @@ impl<'a, 'p> MatchCheckCtx<'a, 'p> {\n         }\n     }\n \n-    // Rust feature described as \"Allows exhaustive pattern matching on types that contain uninhabited types.\"\n+    // Rust's unstable feature described as \"Allows exhaustive pattern matching on types that contain uninhabited types.\"\n     pub(super) fn feature_exhaustive_patterns(&self) -> bool {\n-        // FIXME see MatchCheckCtx::is_uninhabited\n-        false\n+        self.exhaustive_patterns\n     }\n }\n "}, {"sha": "10ffde87eef1491b4c6777db2c19309ff6f36f4e", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/infer.rs", "status": "modified", "additions": 30, "deletions": 3, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/d0588007a997da288abde34a7c861c0acb0aefbd/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0588007a997da288abde34a7c861c0acb0aefbd/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Finfer.rs?ref=d0588007a997da288abde34a7c861c0acb0aefbd", "patch": "@@ -182,7 +182,7 @@ pub(crate) type InferResult<T> = Result<InferOk<T>, TypeError>;\n #[derive(Debug, PartialEq, Eq, Clone)]\n pub enum InferenceDiagnostic {\n     NoSuchField { expr: ExprId },\n-    BreakOutsideOfLoop { expr: ExprId },\n+    BreakOutsideOfLoop { expr: ExprId, is_break: bool },\n     MismatchedArgCount { call_expr: ExprId, expected: usize, found: usize },\n }\n \n@@ -418,18 +418,45 @@ pub(crate) struct InferenceContext<'a> {\n \n #[derive(Clone, Debug)]\n struct BreakableContext {\n+    /// Whether this context contains at least one break expression.\n     may_break: bool,\n+    /// The coercion target of the context.\n     coerce: CoerceMany,\n+    /// The optional label of the context.\n     label: Option<name::Name>,\n+    kind: BreakableKind,\n+}\n+\n+#[derive(Clone, Debug)]\n+enum BreakableKind {\n+    Block,\n+    Loop,\n+    /// A border is something like an async block, closure etc. Anything that prevents\n+    /// breaking/continuing through\n+    Border,\n }\n \n fn find_breakable<'c>(\n     ctxs: &'c mut [BreakableContext],\n     label: Option<&name::Name>,\n+) -> Option<&'c mut BreakableContext> {\n+    let mut ctxs = ctxs\n+        .iter_mut()\n+        .rev()\n+        .take_while(|it| matches!(it.kind, BreakableKind::Block | BreakableKind::Loop));\n+    match label {\n+        Some(_) => ctxs.find(|ctx| ctx.label.as_ref() == label),\n+        None => ctxs.find(|ctx| matches!(ctx.kind, BreakableKind::Loop)),\n+    }\n+}\n+\n+fn find_continuable<'c>(\n+    ctxs: &'c mut [BreakableContext],\n+    label: Option<&name::Name>,\n ) -> Option<&'c mut BreakableContext> {\n     match label {\n-        Some(_) => ctxs.iter_mut().rev().find(|ctx| ctx.label.as_ref() == label),\n-        None => ctxs.last_mut(),\n+        Some(_) => find_breakable(ctxs, label).filter(|it| matches!(it.kind, BreakableKind::Loop)),\n+        None => find_breakable(ctxs, label),\n     }\n }\n "}, {"sha": "2d04a864a2cfd98455a5d198edaec33cc8303f0b", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/infer/expr.rs", "status": "modified", "additions": 104, "deletions": 83, "changes": 187, "blob_url": "https://github.com/rust-lang/rust/blob/d0588007a997da288abde34a7c861c0acb0aefbd/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0588007a997da288abde34a7c861c0acb0aefbd/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs?ref=d0588007a997da288abde34a7c861c0acb0aefbd", "patch": "@@ -10,7 +10,7 @@ use chalk_ir::{\n     cast::Cast, fold::Shift, DebruijnIndex, GenericArgData, Mutability, TyVariableKind,\n };\n use hir_def::{\n-    expr::{ArithOp, Array, BinaryOp, CmpOp, Expr, ExprId, Literal, Statement, UnaryOp},\n+    expr::{ArithOp, Array, BinaryOp, CmpOp, Expr, ExprId, LabelId, Literal, Statement, UnaryOp},\n     generics::TypeOrConstParamData,\n     path::{GenericArg, GenericArgs},\n     resolver::resolver_for_expr,\n@@ -23,7 +23,7 @@ use syntax::ast::RangeOp;\n use crate::{\n     autoderef::{self, Autoderef},\n     consteval,\n-    infer::coerce::CoerceMany,\n+    infer::{coerce::CoerceMany, find_continuable, BreakableKind},\n     lower::{\n         const_or_path_to_chalk, generic_arg_to_chalk, lower_to_chalk_mutability, ParamLoweringMode,\n     },\n@@ -120,32 +120,37 @@ impl<'a> InferenceContext<'a> {\n                 let ty = match label {\n                     Some(_) => {\n                         let break_ty = self.table.new_type_var();\n-                        self.breakables.push(BreakableContext {\n-                            may_break: false,\n-                            coerce: CoerceMany::new(break_ty.clone()),\n-                            label: label.map(|label| self.body[label].name.clone()),\n-                        });\n-                        let ty = self.infer_block(\n-                            tgt_expr,\n-                            statements,\n-                            *tail,\n-                            &Expectation::has_type(break_ty),\n+                        let (breaks, ty) = self.with_breakable_ctx(\n+                            BreakableKind::Block,\n+                            break_ty.clone(),\n+                            *label,\n+                            |this| {\n+                                this.infer_block(\n+                                    tgt_expr,\n+                                    statements,\n+                                    *tail,\n+                                    &Expectation::has_type(break_ty),\n+                                )\n+                            },\n                         );\n-                        let ctxt = self.breakables.pop().expect(\"breakable stack broken\");\n-                        if ctxt.may_break {\n-                            ctxt.coerce.complete()\n-                        } else {\n-                            ty\n-                        }\n+                        breaks.unwrap_or(ty)\n                     }\n                     None => self.infer_block(tgt_expr, statements, *tail, expected),\n                 };\n                 self.resolver = old_resolver;\n                 ty\n             }\n-            Expr::Unsafe { body } | Expr::Const { body } => self.infer_expr(*body, expected),\n+            Expr::Unsafe { body } => self.infer_expr(*body, expected),\n+            Expr::Const { body } => {\n+                self.with_breakable_ctx(BreakableKind::Border, self.err_ty(), None, |this| {\n+                    this.infer_expr(*body, expected)\n+                })\n+                .1\n+            }\n             Expr::TryBlock { body } => {\n-                let _inner = self.infer_expr(*body, expected);\n+                self.with_breakable_ctx(BreakableKind::Border, self.err_ty(), None, |this| {\n+                    let _inner = this.infer_expr(*body, expected);\n+                });\n                 // FIXME should be std::result::Result<{inner}, _>\n                 self.err_ty()\n             }\n@@ -154,7 +159,10 @@ impl<'a> InferenceContext<'a> {\n                 let prev_diverges = mem::replace(&mut self.diverges, Diverges::Maybe);\n                 let prev_ret_ty = mem::replace(&mut self.return_ty, ret_ty.clone());\n \n-                let inner_ty = self.infer_expr_coerce(*body, &Expectation::has_type(ret_ty));\n+                let (_, inner_ty) =\n+                    self.with_breakable_ctx(BreakableKind::Border, self.err_ty(), None, |this| {\n+                        this.infer_expr_coerce(*body, &Expectation::has_type(ret_ty))\n+                    });\n \n                 self.diverges = prev_diverges;\n                 self.return_ty = prev_ret_ty;\n@@ -166,54 +174,44 @@ impl<'a> InferenceContext<'a> {\n                 TyKind::OpaqueType(opaque_ty_id, Substitution::from1(Interner, inner_ty))\n                     .intern(Interner)\n             }\n-            Expr::Loop { body, label } => {\n-                self.breakables.push(BreakableContext {\n-                    may_break: false,\n-                    coerce: CoerceMany::new(self.table.new_type_var()),\n-                    label: label.map(|label| self.body[label].name.clone()),\n-                });\n-                self.infer_expr(*body, &Expectation::has_type(TyBuilder::unit()));\n-\n-                let ctxt = self.breakables.pop().expect(\"breakable stack broken\");\n+            &Expr::Loop { body, label } => {\n+                let ty = self.table.new_type_var();\n+                let (breaks, ()) =\n+                    self.with_breakable_ctx(BreakableKind::Loop, ty, label, |this| {\n+                        this.infer_expr(body, &Expectation::has_type(TyBuilder::unit()));\n+                    });\n \n-                if ctxt.may_break {\n-                    self.diverges = Diverges::Maybe;\n-                    ctxt.coerce.complete()\n-                } else {\n-                    TyKind::Never.intern(Interner)\n+                match breaks {\n+                    Some(breaks) => {\n+                        self.diverges = Diverges::Maybe;\n+                        breaks\n+                    }\n+                    None => TyKind::Never.intern(Interner),\n                 }\n             }\n-            Expr::While { condition, body, label } => {\n-                self.breakables.push(BreakableContext {\n-                    may_break: false,\n-                    coerce: CoerceMany::new(self.err_ty()),\n-                    label: label.map(|label| self.body[label].name.clone()),\n+            &Expr::While { condition, body, label } => {\n+                self.with_breakable_ctx(BreakableKind::Loop, self.err_ty(), label, |this| {\n+                    this.infer_expr(\n+                        condition,\n+                        &Expectation::has_type(TyKind::Scalar(Scalar::Bool).intern(Interner)),\n+                    );\n+                    this.infer_expr(body, &Expectation::has_type(TyBuilder::unit()));\n                 });\n-                self.infer_expr(\n-                    *condition,\n-                    &Expectation::has_type(TyKind::Scalar(Scalar::Bool).intern(Interner)),\n-                );\n-                self.infer_expr(*body, &Expectation::has_type(TyBuilder::unit()));\n-                let _ctxt = self.breakables.pop().expect(\"breakable stack broken\");\n+\n                 // the body may not run, so it diverging doesn't mean we diverge\n                 self.diverges = Diverges::Maybe;\n                 TyBuilder::unit()\n             }\n-            Expr::For { iterable, body, pat, label } => {\n-                let iterable_ty = self.infer_expr(*iterable, &Expectation::none());\n-\n-                self.breakables.push(BreakableContext {\n-                    may_break: false,\n-                    coerce: CoerceMany::new(self.err_ty()),\n-                    label: label.map(|label| self.body[label].name.clone()),\n-                });\n+            &Expr::For { iterable, body, pat, label } => {\n+                let iterable_ty = self.infer_expr(iterable, &Expectation::none());\n                 let pat_ty =\n                     self.resolve_associated_type(iterable_ty, self.resolve_into_iter_item());\n \n-                self.infer_pat(*pat, &pat_ty, BindingMode::default());\n+                self.infer_pat(pat, &pat_ty, BindingMode::default());\n+                self.with_breakable_ctx(BreakableKind::Loop, self.err_ty(), label, |this| {\n+                    this.infer_expr(body, &Expectation::has_type(TyBuilder::unit()));\n+                });\n \n-                self.infer_expr(*body, &Expectation::has_type(TyBuilder::unit()));\n-                let _ctxt = self.breakables.pop().expect(\"breakable stack broken\");\n                 // the body may not run, so it diverging doesn't mean we diverge\n                 self.diverges = Diverges::Maybe;\n                 TyBuilder::unit()\n@@ -269,7 +267,9 @@ impl<'a> InferenceContext<'a> {\n                 let prev_diverges = mem::replace(&mut self.diverges, Diverges::Maybe);\n                 let prev_ret_ty = mem::replace(&mut self.return_ty, ret_ty.clone());\n \n-                self.infer_expr_coerce(*body, &Expectation::has_type(ret_ty));\n+                self.with_breakable_ctx(BreakableKind::Border, self.err_ty(), None, |this| {\n+                    this.infer_expr_coerce(*body, &Expectation::has_type(ret_ty));\n+                });\n \n                 self.diverges = prev_diverges;\n                 self.return_ty = prev_ret_ty;\n@@ -372,37 +372,45 @@ impl<'a> InferenceContext<'a> {\n                 let resolver = resolver_for_expr(self.db.upcast(), self.owner, tgt_expr);\n                 self.infer_path(&resolver, p, tgt_expr.into()).unwrap_or_else(|| self.err_ty())\n             }\n-            Expr::Continue { .. } => TyKind::Never.intern(Interner),\n-            Expr::Break { expr, label } => {\n-                let mut coerce = match find_breakable(&mut self.breakables, label.as_ref()) {\n-                    Some(ctxt) => {\n-                        // avoiding the borrowck\n-                        mem::replace(\n-                            &mut ctxt.coerce,\n-                            CoerceMany::new(self.result.standard_types.unknown.clone()),\n-                        )\n-                    }\n-                    None => CoerceMany::new(self.result.standard_types.unknown.clone()),\n+            Expr::Continue { label } => {\n+                if let None = find_continuable(&mut self.breakables, label.as_ref()) {\n+                    self.push_diagnostic(InferenceDiagnostic::BreakOutsideOfLoop {\n+                        expr: tgt_expr,\n+                        is_break: false,\n+                    });\n                 };\n-\n+                TyKind::Never.intern(Interner)\n+            }\n+            Expr::Break { expr, label } => {\n                 let val_ty = if let Some(expr) = *expr {\n                     self.infer_expr(expr, &Expectation::none())\n                 } else {\n                     TyBuilder::unit()\n                 };\n \n-                // FIXME: create a synthetic `()` during lowering so we have something to refer to here?\n-                coerce.coerce(self, *expr, &val_ty);\n+                match find_breakable(&mut self.breakables, label.as_ref()) {\n+                    Some(ctxt) => {\n+                        // avoiding the borrowck\n+                        let mut coerce = mem::replace(\n+                            &mut ctxt.coerce,\n+                            CoerceMany::new(self.result.standard_types.unknown.clone()),\n+                        );\n \n-                if let Some(ctxt) = find_breakable(&mut self.breakables, label.as_ref()) {\n-                    ctxt.coerce = coerce;\n-                    ctxt.may_break = true;\n-                } else {\n-                    self.push_diagnostic(InferenceDiagnostic::BreakOutsideOfLoop {\n-                        expr: tgt_expr,\n-                    });\n-                };\n+                        // FIXME: create a synthetic `()` during lowering so we have something to refer to here?\n+                        coerce.coerce(self, *expr, &val_ty);\n \n+                        let ctxt = find_breakable(&mut self.breakables, label.as_ref())\n+                            .expect(\"breakable stack changed during coercion\");\n+                        ctxt.coerce = coerce;\n+                        ctxt.may_break = true;\n+                    }\n+                    None => {\n+                        self.push_diagnostic(InferenceDiagnostic::BreakOutsideOfLoop {\n+                            expr: tgt_expr,\n+                            is_break: true,\n+                        });\n+                    }\n+                }\n                 TyKind::Never.intern(Interner)\n             }\n             Expr::Return { expr } => {\n@@ -794,9 +802,6 @@ impl<'a> InferenceContext<'a> {\n                     None => self.table.new_float_var(),\n                 },\n             },\n-            Expr::MacroStmts { tail, statements } => {\n-                self.infer_block(tgt_expr, statements, *tail, expected)\n-            }\n             Expr::Underscore => {\n                 // Underscore expressions may only appear in assignee expressions,\n                 // which are handled by `infer_assignee_expr()`, so any underscore\n@@ -1475,4 +1480,20 @@ impl<'a> InferenceContext<'a> {\n             },\n         })\n     }\n+\n+    fn with_breakable_ctx<T>(\n+        &mut self,\n+        kind: BreakableKind,\n+        ty: Ty,\n+        label: Option<LabelId>,\n+        cb: impl FnOnce(&mut Self) -> T,\n+    ) -> (Option<Ty>, T) {\n+        self.breakables.push({\n+            let label = label.map(|label| self.body[label].name.clone());\n+            BreakableContext { kind, may_break: false, coerce: CoerceMany::new(ty), label }\n+        });\n+        let res = cb(self);\n+        let ctx = self.breakables.pop().expect(\"breakable stack broken\");\n+        (ctx.may_break.then(|| ctx.coerce.complete()), res)\n+    }\n }"}, {"sha": "0c547192ac0d0dd81b87ac0339d655f29eaeaa5a", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/inhabitedness.rs", "status": "added", "additions": 173, "deletions": 0, "changes": 173, "blob_url": "https://github.com/rust-lang/rust/blob/d0588007a997da288abde34a7c861c0acb0aefbd/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Finhabitedness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0588007a997da288abde34a7c861c0acb0aefbd/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Finhabitedness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Finhabitedness.rs?ref=d0588007a997da288abde34a7c861c0acb0aefbd", "patch": "@@ -0,0 +1,173 @@\n+//! Type inhabitedness logic.\n+use std::ops::ControlFlow::{self, Break, Continue};\n+\n+use chalk_ir::{\n+    visit::{TypeSuperVisitable, TypeVisitable, TypeVisitor},\n+    DebruijnIndex,\n+};\n+use hir_def::{\n+    adt::VariantData, attr::Attrs, type_ref::ConstScalar, visibility::Visibility, AdtId,\n+    EnumVariantId, HasModule, Lookup, ModuleId, VariantId,\n+};\n+\n+use crate::{\n+    db::HirDatabase, Binders, ConcreteConst, Const, ConstValue, Interner, Substitution, Ty, TyKind,\n+};\n+\n+/// Checks whether a type is visibly uninhabited from a particular module.\n+pub(crate) fn is_ty_uninhabited_from(ty: &Ty, target_mod: ModuleId, db: &dyn HirDatabase) -> bool {\n+    let mut uninhabited_from = UninhabitedFrom { target_mod, db };\n+    let inhabitedness = ty.visit_with(&mut uninhabited_from, DebruijnIndex::INNERMOST);\n+    inhabitedness == BREAK_VISIBLY_UNINHABITED\n+}\n+\n+/// Checks whether a variant is visibly uninhabited from a particular module.\n+pub(crate) fn is_enum_variant_uninhabited_from(\n+    variant: EnumVariantId,\n+    subst: &Substitution,\n+    target_mod: ModuleId,\n+    db: &dyn HirDatabase,\n+) -> bool {\n+    let enum_data = db.enum_data(variant.parent);\n+    let vars_attrs = db.variants_attrs(variant.parent);\n+    let is_local = variant.parent.lookup(db.upcast()).container.krate() == target_mod.krate();\n+\n+    let mut uninhabited_from = UninhabitedFrom { target_mod, db };\n+    let inhabitedness = uninhabited_from.visit_variant(\n+        variant.into(),\n+        &enum_data.variants[variant.local_id].variant_data,\n+        subst,\n+        &vars_attrs[variant.local_id],\n+        is_local,\n+    );\n+    inhabitedness == BREAK_VISIBLY_UNINHABITED\n+}\n+\n+struct UninhabitedFrom<'a> {\n+    target_mod: ModuleId,\n+    db: &'a dyn HirDatabase,\n+}\n+\n+const CONTINUE_OPAQUELY_INHABITED: ControlFlow<VisiblyUninhabited> = Continue(());\n+const BREAK_VISIBLY_UNINHABITED: ControlFlow<VisiblyUninhabited> = Break(VisiblyUninhabited);\n+#[derive(PartialEq, Eq)]\n+struct VisiblyUninhabited;\n+\n+impl TypeVisitor<Interner> for UninhabitedFrom<'_> {\n+    type BreakTy = VisiblyUninhabited;\n+\n+    fn as_dyn(&mut self) -> &mut dyn TypeVisitor<Interner, BreakTy = VisiblyUninhabited> {\n+        self\n+    }\n+\n+    fn visit_ty(\n+        &mut self,\n+        ty: &Ty,\n+        outer_binder: DebruijnIndex,\n+    ) -> ControlFlow<VisiblyUninhabited> {\n+        match ty.kind(Interner) {\n+            TyKind::Adt(adt, subst) => self.visit_adt(adt.0, subst),\n+            TyKind::Never => BREAK_VISIBLY_UNINHABITED,\n+            TyKind::Tuple(..) => ty.super_visit_with(self, outer_binder),\n+            TyKind::Array(item_ty, len) => match try_usize_const(len) {\n+                Some(0) | None => CONTINUE_OPAQUELY_INHABITED,\n+                Some(1..) => item_ty.super_visit_with(self, outer_binder),\n+            },\n+\n+            TyKind::Ref(..) | _ => CONTINUE_OPAQUELY_INHABITED,\n+        }\n+    }\n+\n+    fn interner(&self) -> Interner {\n+        Interner\n+    }\n+}\n+\n+impl UninhabitedFrom<'_> {\n+    fn visit_adt(&mut self, adt: AdtId, subst: &Substitution) -> ControlFlow<VisiblyUninhabited> {\n+        let attrs = self.db.attrs(adt.into());\n+        let adt_non_exhaustive = attrs.by_key(\"non_exhaustive\").exists();\n+        let is_local = adt.module(self.db.upcast()).krate() == self.target_mod.krate();\n+        if adt_non_exhaustive && !is_local {\n+            return CONTINUE_OPAQUELY_INHABITED;\n+        }\n+\n+        // An ADT is uninhabited iff all its variants uninhabited.\n+        match adt {\n+            // rustc: For now, `union`s are never considered uninhabited.\n+            AdtId::UnionId(_) => CONTINUE_OPAQUELY_INHABITED,\n+            AdtId::StructId(s) => {\n+                let struct_data = self.db.struct_data(s);\n+                self.visit_variant(s.into(), &struct_data.variant_data, subst, &attrs, is_local)\n+            }\n+            AdtId::EnumId(e) => {\n+                let vars_attrs = self.db.variants_attrs(e);\n+                let enum_data = self.db.enum_data(e);\n+\n+                for (local_id, enum_var) in enum_data.variants.iter() {\n+                    let variant_inhabitedness = self.visit_variant(\n+                        EnumVariantId { parent: e, local_id }.into(),\n+                        &enum_var.variant_data,\n+                        subst,\n+                        &vars_attrs[local_id],\n+                        is_local,\n+                    );\n+                    match variant_inhabitedness {\n+                        Break(VisiblyUninhabited) => continue,\n+                        Continue(()) => return CONTINUE_OPAQUELY_INHABITED,\n+                    }\n+                }\n+                BREAK_VISIBLY_UNINHABITED\n+            }\n+        }\n+    }\n+\n+    fn visit_variant(\n+        &mut self,\n+        variant: VariantId,\n+        variant_data: &VariantData,\n+        subst: &Substitution,\n+        attrs: &Attrs,\n+        is_local: bool,\n+    ) -> ControlFlow<VisiblyUninhabited> {\n+        let non_exhaustive_field_list = attrs.by_key(\"non_exhaustive\").exists();\n+        if non_exhaustive_field_list && !is_local {\n+            return CONTINUE_OPAQUELY_INHABITED;\n+        }\n+\n+        let is_enum = matches!(variant, VariantId::EnumVariantId(..));\n+        let field_tys = self.db.field_types(variant);\n+        let field_vis = self.db.field_visibilities(variant);\n+\n+        for (fid, _) in variant_data.fields().iter() {\n+            self.visit_field(field_vis[fid], &field_tys[fid], subst, is_enum)?;\n+        }\n+        CONTINUE_OPAQUELY_INHABITED\n+    }\n+\n+    fn visit_field(\n+        &mut self,\n+        vis: Visibility,\n+        ty: &Binders<Ty>,\n+        subst: &Substitution,\n+        is_enum: bool,\n+    ) -> ControlFlow<VisiblyUninhabited> {\n+        if is_enum || vis.is_visible_from(self.db.upcast(), self.target_mod) {\n+            let ty = ty.clone().substitute(Interner, subst);\n+            ty.visit_with(self, DebruijnIndex::INNERMOST)\n+        } else {\n+            CONTINUE_OPAQUELY_INHABITED\n+        }\n+    }\n+}\n+\n+fn try_usize_const(c: &Const) -> Option<u128> {\n+    let data = &c.data(Interner);\n+    if data.ty.kind(Interner) != &TyKind::Scalar(chalk_ir::Scalar::Uint(chalk_ir::UintTy::Usize)) {\n+        return None;\n+    }\n+    match data.value {\n+        ConstValue::Concrete(ConcreteConst { interned: ConstScalar::UInt(value) }) => Some(value),\n+        _ => None,\n+    }\n+}"}, {"sha": "a82a331d4b8750e99c5fb8f69b6b04cf8007e96e", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d0588007a997da288abde34a7c861c0acb0aefbd/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0588007a997da288abde34a7c861c0acb0aefbd/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Flib.rs?ref=d0588007a997da288abde34a7c861c0acb0aefbd", "patch": "@@ -14,6 +14,7 @@ mod chalk_db;\n mod chalk_ext;\n pub mod consteval;\n mod infer;\n+mod inhabitedness;\n mod interner;\n mod lower;\n mod mapping;"}, {"sha": "4a37a7945330cc2a216a3eb6582ca7bbd0db0287", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/lower.rs", "status": "modified", "additions": 48, "deletions": 9, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/d0588007a997da288abde34a7c861c0acb0aefbd/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0588007a997da288abde34a7c861c0acb0aefbd/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Flower.rs?ref=d0588007a997da288abde34a7c861c0acb0aefbd", "patch": "@@ -1,8 +1,8 @@\n //! Methods for lowering the HIR to types. There are two main cases here:\n //!\n //!  - Lowering a type reference like `&usize` or `Option<foo::bar::Baz>` to a\n-//!    type: The entry point for this is `Ty::from_hir`.\n-//!  - Building the type for an item: This happens through the `type_for_def` query.\n+//!    type: The entry point for this is `TyLoweringContext::lower_ty`.\n+//!  - Building the type for an item: This happens through the `ty` query.\n //!\n //! This usually involves resolving names, collecting generic arguments etc.\n use std::{\n@@ -47,7 +47,7 @@ use crate::{\n     consteval::{intern_const_scalar, path_to_const, unknown_const, unknown_const_as_generic},\n     db::HirDatabase,\n     make_binders,\n-    mapping::ToChalk,\n+    mapping::{from_chalk_trait_id, ToChalk},\n     static_lifetime, to_assoc_type_id, to_chalk_trait_id, to_placeholder_idx,\n     utils::Generics,\n     utils::{all_super_trait_refs, associated_type_by_name_including_super_traits, generics},\n@@ -332,7 +332,10 @@ impl<'a> TyLoweringContext<'a> {\n             TypeRef::Macro(macro_call) => {\n                 let (mut expander, recursion_start) = {\n                     match RefMut::filter_map(self.expander.borrow_mut(), Option::as_mut) {\n+                        // There already is an expander here, this means we are already recursing\n                         Ok(expander) => (expander, false),\n+                        // No expander was created yet, so we are at the start of the expansion recursion\n+                        // and therefore have to create an expander.\n                         Err(expander) => (\n                             RefMut::map(expander, |it| {\n                                 it.insert(Expander::new(\n@@ -362,9 +365,14 @@ impl<'a> TyLoweringContext<'a> {\n                                 .exit(self.db.upcast(), mark);\n                             Some(ty)\n                         }\n-                        _ => None,\n+                        _ => {\n+                            drop(expander);\n+                            None\n+                        }\n                     }\n                 };\n+\n+                // drop the expander, resetting it to pre-recursion state\n                 if recursion_start {\n                     *self.expander.borrow_mut() = None;\n                 }\n@@ -974,13 +982,44 @@ impl<'a> TyLoweringContext<'a> {\n     fn lower_dyn_trait(&self, bounds: &[Interned<TypeBound>]) -> Ty {\n         let self_ty = TyKind::BoundVar(BoundVar::new(DebruijnIndex::INNERMOST, 0)).intern(Interner);\n         let bounds = self.with_shifted_in(DebruijnIndex::ONE, |ctx| {\n-            QuantifiedWhereClauses::from_iter(\n+            let bounds =\n+                bounds.iter().flat_map(|b| ctx.lower_type_bound(b, self_ty.clone(), false));\n+\n+            let mut auto_traits = SmallVec::<[_; 8]>::new();\n+            let mut regular_traits = SmallVec::<[_; 2]>::new();\n+            let mut other_bounds = SmallVec::<[_; 8]>::new();\n+            for bound in bounds {\n+                if let Some(id) = bound.trait_id() {\n+                    if ctx.db.trait_data(from_chalk_trait_id(id)).is_auto {\n+                        auto_traits.push(bound);\n+                    } else {\n+                        regular_traits.push(bound);\n+                    }\n+                } else {\n+                    other_bounds.push(bound);\n+                }\n+            }\n+\n+            if regular_traits.len() > 1 {\n+                return None;\n+            }\n+\n+            auto_traits.sort_unstable_by_key(|b| b.trait_id().unwrap());\n+            auto_traits.dedup();\n+\n+            Some(QuantifiedWhereClauses::from_iter(\n                 Interner,\n-                bounds.iter().flat_map(|b| ctx.lower_type_bound(b, self_ty.clone(), false)),\n-            )\n+                regular_traits.into_iter().chain(other_bounds).chain(auto_traits),\n+            ))\n         });\n-        let bounds = crate::make_single_type_binders(bounds);\n-        TyKind::Dyn(DynTy { bounds, lifetime: static_lifetime() }).intern(Interner)\n+\n+        if let Some(bounds) = bounds {\n+            let bounds = crate::make_single_type_binders(bounds);\n+            TyKind::Dyn(DynTy { bounds, lifetime: static_lifetime() }).intern(Interner)\n+        } else {\n+            // FIXME: report error (additional non-auto traits)\n+            TyKind::Error.intern(Interner)\n+        }\n     }\n \n     fn lower_impl_trait("}, {"sha": "b3adafaafd38de8ea411754aa963079da3f3a309", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/tests/macros.rs", "status": "modified", "additions": 1, "deletions": 13, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d0588007a997da288abde34a7c861c0acb0aefbd/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftests%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0588007a997da288abde34a7c861c0acb0aefbd/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftests%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftests%2Fmacros.rs?ref=d0588007a997da288abde34a7c861c0acb0aefbd", "patch": "@@ -193,8 +193,6 @@ fn expr_macro_def_expanded_in_various_places() {\n             !0..6 '1isize': isize\n             !0..6 '1isize': isize\n             !0..6 '1isize': isize\n-            !0..6 '1isize': isize\n-            !0..6 '1isize': isize\n             39..442 '{     ...!(); }': ()\n             73..94 'spam!(...am!())': {unknown}\n             100..119 'for _ ...!() {}': ()\n@@ -276,8 +274,6 @@ fn expr_macro_rules_expanded_in_various_places() {\n             !0..6 '1isize': isize\n             !0..6 '1isize': isize\n             !0..6 '1isize': isize\n-            !0..6 '1isize': isize\n-            !0..6 '1isize': isize\n             53..456 '{     ...!(); }': ()\n             87..108 'spam!(...am!())': {unknown}\n             114..133 'for _ ...!() {}': ()\n@@ -312,7 +308,6 @@ fn expr_macro_expanded_in_stmts() {\n         }\n         \"#,\n         expect![[r#\"\n-            !0..8 'leta=();': ()\n             !3..4 'a': ()\n             !5..7 '()': ()\n             57..84 '{     ...); } }': ()\n@@ -321,7 +316,7 @@ fn expr_macro_expanded_in_stmts() {\n }\n \n #[test]\n-fn recurisve_macro_expanded_in_stmts() {\n+fn recursive_macro_expanded_in_stmts() {\n     check_infer(\n         r#\"\n         macro_rules! ng {\n@@ -340,11 +335,6 @@ fn recurisve_macro_expanded_in_stmts() {\n         }\n         \"#,\n         expect![[r#\"\n-            !0..7 'leta=3;': ()\n-            !0..13 'ng!{[leta=3]}': ()\n-            !0..13 'ng!{[leta=]3}': ()\n-            !0..13 'ng!{[leta]=3}': ()\n-            !0..13 'ng!{[let]a=3}': ()\n             !3..4 'a': i32\n             !5..6 '3': i32\n             196..237 '{     ...= a; }': ()\n@@ -369,8 +359,6 @@ fn recursive_inner_item_macro_rules() {\n         \"#,\n         expect![[r#\"\n             !0..1 '1': i32\n-            !0..7 'mac!($)': ()\n-            !0..26 'macro_...>{1};}': ()\n             107..143 '{     ...!(); }': ()\n             129..130 'a': i32\n         \"#]],"}, {"sha": "23e51a9c16a5600138e3e519e2ae952c4a68c95e", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/tests/regression.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d0588007a997da288abde34a7c861c0acb0aefbd/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftests%2Fregression.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0588007a997da288abde34a7c861c0acb0aefbd/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftests%2Fregression.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftests%2Fregression.rs?ref=d0588007a997da288abde34a7c861c0acb0aefbd", "patch": "@@ -573,7 +573,6 @@ fn issue_6811() {\n         }\n         \"#,\n         expect![[r#\"\n-            !0..16 'let_a=...t_b=1;': ()\n             !3..5 '_a': i32\n             !6..7 '1': i32\n             !11..13 '_b': i32\n@@ -1679,7 +1678,6 @@ fn main() {\n \n #[test]\n fn trailing_empty_macro() {\n-    cov_mark::check!(empty_macro_in_trailing_position_is_removed);\n     check_no_mismatches(\n         r#\"\n macro_rules! m2 {"}, {"sha": "4ea103e5d9ec3cf1bc5fc85e4ff0866b18388826", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/tests/simple.rs", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/d0588007a997da288abde34a7c861c0acb0aefbd/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftests%2Fsimple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0588007a997da288abde34a7c861c0acb0aefbd/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftests%2Fsimple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftests%2Fsimple.rs?ref=d0588007a997da288abde34a7c861c0acb0aefbd", "patch": "@@ -2549,7 +2549,6 @@ impl B for Astruct {}\n         expect![[r#\"\n             569..573 'self': Box<[T], A>\n             602..634 '{     ...     }': Vec<T, A>\n-            612..628 'unimpl...ted!()': Vec<T, A>\n             648..761 '{     ...t]); }': ()\n             658..661 'vec': Vec<i32, Global>\n             664..679 '<[_]>::into_vec': fn into_vec<i32, Global>(Box<[i32], Global>) -> Vec<i32, Global>\n@@ -3070,3 +3069,17 @@ fn main() {\n         \"#,\n     );\n }\n+\n+#[test]\n+fn nested_break() {\n+    check_no_mismatches(\n+        r#\"\n+fn func() {\n+    let int = loop {\n+        break 0;\n+        break (break 0);\n+    };\n+}\n+    \"#,\n+    );\n+}"}, {"sha": "e67c27aa2db97fb4cff6fd19475fa448aa422cc9", "filename": "src/tools/rust-analyzer/crates/hir-ty/src/tests/traits.rs", "status": "modified", "additions": 92, "deletions": 0, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/d0588007a997da288abde34a7c861c0acb0aefbd/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftests%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0588007a997da288abde34a7c861c0acb0aefbd/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftests%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir-ty%2Fsrc%2Ftests%2Ftraits.rs?ref=d0588007a997da288abde34a7c861c0acb0aefbd", "patch": "@@ -3833,3 +3833,95 @@ fn test() {\n \"#,\n     )\n }\n+\n+#[test]\n+fn dyn_multiple_auto_traits_in_different_order() {\n+    check_no_mismatches(\n+        r#\"\n+auto trait Send {}\n+auto trait Sync {}\n+\n+fn f(t: &(dyn Sync + Send)) {}\n+fn g(t: &(dyn Send + Sync)) {\n+    f(t);\n+}\n+        \"#,\n+    );\n+\n+    check_no_mismatches(\n+        r#\"\n+auto trait Send {}\n+auto trait Sync {}\n+trait T {}\n+\n+fn f(t: &(dyn T + Send + Sync)) {}\n+fn g(t: &(dyn Sync + T + Send)) {\n+    f(t);\n+}\n+        \"#,\n+    );\n+\n+    check_infer_with_mismatches(\n+        r#\"\n+auto trait Send {}\n+auto trait Sync {}\n+trait T1 {}\n+trait T2 {}\n+\n+fn f(t: &(dyn T1 + T2 + Send + Sync)) {}\n+fn g(t: &(dyn Sync + T2 + T1 + Send)) {\n+    f(t);\n+}\n+        \"#,\n+        expect![[r#\"\n+            68..69 't': &{unknown}\n+            101..103 '{}': ()\n+            109..110 't': &{unknown}\n+            142..155 '{     f(t); }': ()\n+            148..149 'f': fn f(&{unknown})\n+            148..152 'f(t)': ()\n+            150..151 't': &{unknown}\n+        \"#]],\n+    );\n+\n+    check_no_mismatches(\n+        r#\"\n+auto trait Send {}\n+auto trait Sync {}\n+trait T {\n+    type Proj: Send + Sync;\n+}\n+\n+fn f(t: &(dyn T<Proj = ()>  + Send + Sync)) {}\n+fn g(t: &(dyn Sync + T<Proj = ()> + Send)) {\n+    f(t);\n+}\n+        \"#,\n+    );\n+}\n+\n+#[test]\n+fn dyn_duplicate_auto_trait() {\n+    check_no_mismatches(\n+        r#\"\n+auto trait Send {}\n+\n+fn f(t: &(dyn Send + Send)) {}\n+fn g(t: &(dyn Send)) {\n+    f(t);\n+}\n+        \"#,\n+    );\n+\n+    check_no_mismatches(\n+        r#\"\n+auto trait Send {}\n+trait T {}\n+\n+fn f(t: &(dyn T + Send + Send)) {}\n+fn g(t: &(dyn T + Send)) {\n+    f(t);\n+}\n+        \"#,\n+    );\n+}"}, {"sha": "5edc16d8bce9060262914d14060b4bfd1cb3e6d2", "filename": "src/tools/rust-analyzer/crates/hir/src/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d0588007a997da288abde34a7c861c0acb0aefbd/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0588007a997da288abde34a7c861c0acb0aefbd/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2Fsrc%2Fdiagnostics.rs?ref=d0588007a997da288abde34a7c861c0acb0aefbd", "patch": "@@ -124,6 +124,7 @@ pub struct NoSuchField {\n #[derive(Debug)]\n pub struct BreakOutsideOfLoop {\n     pub expr: InFile<AstPtr<ast::Expr>>,\n+    pub is_break: bool,\n }\n \n #[derive(Debug)]"}, {"sha": "e4bb63a864719956e4b31b76e8994852f3b3ca55", "filename": "src/tools/rust-analyzer/crates/hir/src/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d0588007a997da288abde34a7c861c0acb0aefbd/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0588007a997da288abde34a7c861c0acb0aefbd/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2Fsrc%2Flib.rs?ref=d0588007a997da288abde34a7c861c0acb0aefbd", "patch": "@@ -1216,11 +1216,11 @@ impl DefWithBody {\n                     let field = source_map.field_syntax(*expr);\n                     acc.push(NoSuchField { field }.into())\n                 }\n-                hir_ty::InferenceDiagnostic::BreakOutsideOfLoop { expr } => {\n+                &hir_ty::InferenceDiagnostic::BreakOutsideOfLoop { expr, is_break } => {\n                     let expr = source_map\n-                        .expr_syntax(*expr)\n+                        .expr_syntax(expr)\n                         .expect(\"break outside of loop in synthetic syntax\");\n-                    acc.push(BreakOutsideOfLoop { expr }.into())\n+                    acc.push(BreakOutsideOfLoop { expr, is_break }.into())\n                 }\n                 hir_ty::InferenceDiagnostic::MismatchedArgCount { call_expr, expected, found } => {\n                     match source_map.expr_syntax(*call_expr) {"}, {"sha": "342912b678a1db836de2a77eb92f674fbc7246cd", "filename": "src/tools/rust-analyzer/crates/hir/src/source_analyzer.rs", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d0588007a997da288abde34a7c861c0acb0aefbd/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2Fsrc%2Fsource_analyzer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0588007a997da288abde34a7c861c0acb0aefbd/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2Fsrc%2Fsource_analyzer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fhir%2Fsrc%2Fsource_analyzer.rs?ref=d0588007a997da288abde34a7c861c0acb0aefbd", "patch": "@@ -140,11 +140,19 @@ impl SourceAnalyzer {\n     ) -> Option<InFile<ast::Expr>> {\n         let macro_file = self.body_source_map()?.node_macro_file(expr.as_ref())?;\n         let expanded = db.parse_or_expand(macro_file)?;\n-\n-        let res = match ast::MacroCall::cast(expanded.clone()) {\n-            Some(call) => self.expand_expr(db, InFile::new(macro_file, call))?,\n-            _ => InFile::new(macro_file, ast::Expr::cast(expanded)?),\n+        let res = if let Some(stmts) = ast::MacroStmts::cast(expanded.clone()) {\n+            match stmts.expr()? {\n+                ast::Expr::MacroExpr(mac) => {\n+                    self.expand_expr(db, InFile::new(macro_file, mac.macro_call()?))?\n+                }\n+                expr => InFile::new(macro_file, expr),\n+            }\n+        } else if let Some(call) = ast::MacroCall::cast(expanded.clone()) {\n+            self.expand_expr(db, InFile::new(macro_file, call))?\n+        } else {\n+            InFile::new(macro_file, ast::Expr::cast(expanded)?)\n         };\n+\n         Some(res)\n     }\n "}, {"sha": "54a7f480a4e46abd5316a3cc719e8c54ede8a69f", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/convert_two_arm_bool_match_to_matches_macro.rs", "status": "added", "additions": 294, "deletions": 0, "changes": 294, "blob_url": "https://github.com/rust-lang/rust/blob/d0588007a997da288abde34a7c861c0acb0aefbd/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fconvert_two_arm_bool_match_to_matches_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0588007a997da288abde34a7c861c0acb0aefbd/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fconvert_two_arm_bool_match_to_matches_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fconvert_two_arm_bool_match_to_matches_macro.rs?ref=d0588007a997da288abde34a7c861c0acb0aefbd", "patch": "@@ -0,0 +1,294 @@\n+use syntax::ast::{self, AstNode};\n+\n+use crate::{AssistContext, AssistId, AssistKind, Assists};\n+\n+// Assist: convert_two_arm_bool_match_to_matches_macro\n+//\n+// Convert 2-arm match that evaluates to a boolean into the equivalent matches! invocation.\n+//\n+// ```\n+// fn main() {\n+//     match scrutinee$0 {\n+//         Some(val) if val.cond() => true,\n+//         _ => false,\n+//     }\n+// }\n+// ```\n+// ->\n+// ```\n+// fn main() {\n+//     matches!(scrutinee, Some(val) if val.cond())\n+// }\n+// ```\n+pub(crate) fn convert_two_arm_bool_match_to_matches_macro(\n+    acc: &mut Assists,\n+    ctx: &AssistContext<'_>,\n+) -> Option<()> {\n+    let match_expr = ctx.find_node_at_offset::<ast::MatchExpr>()?;\n+    let match_arm_list = match_expr.match_arm_list()?;\n+    let mut arms = match_arm_list.arms();\n+    let first_arm = arms.next()?;\n+    let second_arm = arms.next()?;\n+    if arms.next().is_some() {\n+        cov_mark::hit!(non_two_arm_match);\n+        return None;\n+    }\n+    let first_arm_expr = first_arm.expr();\n+    let second_arm_expr = second_arm.expr();\n+\n+    let invert_matches = if is_bool_literal_expr(&first_arm_expr, true)\n+        && is_bool_literal_expr(&second_arm_expr, false)\n+    {\n+        false\n+    } else if is_bool_literal_expr(&first_arm_expr, false)\n+        && is_bool_literal_expr(&second_arm_expr, true)\n+    {\n+        true\n+    } else {\n+        cov_mark::hit!(non_invert_bool_literal_arms);\n+        return None;\n+    };\n+\n+    let target_range = ctx.sema.original_range(match_expr.syntax()).range;\n+    let expr = match_expr.expr()?;\n+\n+    acc.add(\n+        AssistId(\"convert_two_arm_bool_match_to_matches_macro\", AssistKind::RefactorRewrite),\n+        \"Convert to matches!\",\n+        target_range,\n+        |builder| {\n+            let mut arm_str = String::new();\n+            if let Some(ref pat) = first_arm.pat() {\n+                arm_str += &pat.to_string();\n+            }\n+            if let Some(ref guard) = first_arm.guard() {\n+                arm_str += &format!(\" {}\", &guard.to_string());\n+            }\n+            if invert_matches {\n+                builder.replace(target_range, format!(\"!matches!({}, {})\", expr, arm_str));\n+            } else {\n+                builder.replace(target_range, format!(\"matches!({}, {})\", expr, arm_str));\n+            }\n+        },\n+    )\n+}\n+\n+fn is_bool_literal_expr(expr: &Option<ast::Expr>, expect_bool: bool) -> bool {\n+    if let Some(ast::Expr::Literal(lit)) = expr {\n+        if let ast::LiteralKind::Bool(b) = lit.kind() {\n+            return b == expect_bool;\n+        }\n+    }\n+\n+    return false;\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use crate::tests::{check_assist, check_assist_not_applicable, check_assist_target};\n+\n+    use super::convert_two_arm_bool_match_to_matches_macro;\n+\n+    #[test]\n+    fn not_applicable_outside_of_range_left() {\n+        check_assist_not_applicable(\n+            convert_two_arm_bool_match_to_matches_macro,\n+            r#\"\n+fn foo(a: Option<u32>) -> bool {\n+    $0 match a {\n+        Some(_val) => true,\n+        _ => false\n+    }\n+}\n+        \"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn not_applicable_non_two_arm_match() {\n+        cov_mark::check!(non_two_arm_match);\n+        check_assist_not_applicable(\n+            convert_two_arm_bool_match_to_matches_macro,\n+            r#\"\n+fn foo(a: Option<u32>) -> bool {\n+    match a$0 {\n+        Some(3) => true,\n+        Some(4) => true,\n+        _ => false\n+    }\n+}\n+        \"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn not_applicable_non_bool_literal_arms() {\n+        cov_mark::check!(non_invert_bool_literal_arms);\n+        check_assist_not_applicable(\n+            convert_two_arm_bool_match_to_matches_macro,\n+            r#\"\n+fn foo(a: Option<u32>) -> bool {\n+    match a$0 {\n+        Some(val) => val == 3,\n+        _ => false\n+    }\n+}\n+        \"#,\n+        );\n+    }\n+    #[test]\n+    fn not_applicable_both_false_arms() {\n+        cov_mark::check!(non_invert_bool_literal_arms);\n+        check_assist_not_applicable(\n+            convert_two_arm_bool_match_to_matches_macro,\n+            r#\"\n+fn foo(a: Option<u32>) -> bool {\n+    match a$0 {\n+        Some(val) => false,\n+        _ => false\n+    }\n+}\n+        \"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn not_applicable_both_true_arms() {\n+        cov_mark::check!(non_invert_bool_literal_arms);\n+        check_assist_not_applicable(\n+            convert_two_arm_bool_match_to_matches_macro,\n+            r#\"\n+fn foo(a: Option<u32>) -> bool {\n+    match a$0 {\n+        Some(val) => true,\n+        _ => true\n+    }\n+}\n+        \"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn convert_simple_case() {\n+        check_assist(\n+            convert_two_arm_bool_match_to_matches_macro,\n+            r#\"\n+fn foo(a: Option<u32>) -> bool {\n+    match a$0 {\n+        Some(_val) => true,\n+        _ => false\n+    }\n+}\n+\"#,\n+            r#\"\n+fn foo(a: Option<u32>) -> bool {\n+    matches!(a, Some(_val))\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn convert_simple_invert_case() {\n+        check_assist(\n+            convert_two_arm_bool_match_to_matches_macro,\n+            r#\"\n+fn foo(a: Option<u32>) -> bool {\n+    match a$0 {\n+        Some(_val) => false,\n+        _ => true\n+    }\n+}\n+\"#,\n+            r#\"\n+fn foo(a: Option<u32>) -> bool {\n+    !matches!(a, Some(_val))\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn convert_with_guard_case() {\n+        check_assist(\n+            convert_two_arm_bool_match_to_matches_macro,\n+            r#\"\n+fn foo(a: Option<u32>) -> bool {\n+    match a$0 {\n+        Some(val) if val > 3 => true,\n+        _ => false\n+    }\n+}\n+\"#,\n+            r#\"\n+fn foo(a: Option<u32>) -> bool {\n+    matches!(a, Some(val) if val > 3)\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn convert_enum_match_cases() {\n+        check_assist(\n+            convert_two_arm_bool_match_to_matches_macro,\n+            r#\"\n+enum X { A, B }\n+\n+fn foo(a: X) -> bool {\n+    match a$0 {\n+        X::A => true,\n+        _ => false\n+    }\n+}\n+\"#,\n+            r#\"\n+enum X { A, B }\n+\n+fn foo(a: X) -> bool {\n+    matches!(a, X::A)\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn convert_target_simple() {\n+        check_assist_target(\n+            convert_two_arm_bool_match_to_matches_macro,\n+            r#\"\n+fn foo(a: Option<u32>) -> bool {\n+    match a$0 {\n+        Some(val) => true,\n+        _ => false\n+    }\n+}\n+\"#,\n+            r#\"match a {\n+        Some(val) => true,\n+        _ => false\n+    }\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn convert_target_complex() {\n+        check_assist_target(\n+            convert_two_arm_bool_match_to_matches_macro,\n+            r#\"\n+enum E { X, Y }\n+\n+fn main() {\n+    match E::X$0 {\n+        E::X => true,\n+        _ => false,\n+    }\n+}\n+\"#,\n+            \"match E::X {\n+        E::X => true,\n+        _ => false,\n+    }\",\n+        );\n+    }\n+}"}, {"sha": "ddc2052e7aa240f92f32c3122423138edea0f4da", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/extract_struct_from_enum_variant.rs", "status": "modified", "additions": 68, "deletions": 47, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/d0588007a997da288abde34a7c861c0acb0aefbd/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fextract_struct_from_enum_variant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0588007a997da288abde34a7c861c0acb0aefbd/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fextract_struct_from_enum_variant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Fextract_struct_from_enum_variant.rs?ref=d0588007a997da288abde34a7c861c0acb0aefbd", "patch": "@@ -101,21 +101,22 @@ pub(crate) fn extract_struct_from_enum_variant(\n                 });\n             }\n \n-            let indent = enum_ast.indent_level();\n             let generic_params = enum_ast\n                 .generic_param_list()\n                 .and_then(|known_generics| extract_generic_params(&known_generics, &field_list));\n             let generics = generic_params.as_ref().map(|generics| generics.clone_for_update());\n             let def =\n                 create_struct_def(variant_name.clone(), &variant, &field_list, generics, &enum_ast);\n+\n+            let enum_ast = variant.parent_enum();\n+            let indent = enum_ast.indent_level();\n             def.reindent_to(indent);\n \n-            let start_offset = &variant.parent_enum().syntax().clone();\n-            ted::insert_all_raw(\n-                ted::Position::before(start_offset),\n+            ted::insert_all(\n+                ted::Position::before(enum_ast.syntax()),\n                 vec![\n                     def.syntax().clone().into(),\n-                    make::tokens::whitespace(&format!(\"\\n\\n{}\", indent)).into(),\n+                    make::tokens::whitespace(&format!(\"\\n\\n{indent}\")).into(),\n                 ],\n             );\n \n@@ -227,7 +228,7 @@ fn tag_generics_in_variant(ty: &ast::Type, generics: &mut [(ast::GenericParam, b\n }\n \n fn create_struct_def(\n-    variant_name: ast::Name,\n+    name: ast::Name,\n     variant: &ast::Variant,\n     field_list: &Either<ast::RecordFieldList, ast::TupleFieldList>,\n     generics: Option<ast::GenericParamList>,\n@@ -269,43 +270,27 @@ fn create_struct_def(\n             field_list.into()\n         }\n     };\n-\n     field_list.reindent_to(IndentLevel::single());\n \n-    let strukt = make::struct_(enum_vis, variant_name, generics, field_list).clone_for_update();\n-\n-    // FIXME: Consider making this an actual function somewhere (like in `AttrsOwnerEdit`) after some deliberation\n-    let attrs_and_docs = |node: &SyntaxNode| {\n-        let mut select_next_ws = false;\n-        node.children_with_tokens().filter(move |child| {\n-            let accept = match child.kind() {\n-                ATTR | COMMENT => {\n-                    select_next_ws = true;\n-                    return true;\n-                }\n-                WHITESPACE if select_next_ws => true,\n-                _ => false,\n-            };\n-            select_next_ws = false;\n-\n-            accept\n-        })\n-    };\n+    let strukt = make::struct_(enum_vis, name, generics, field_list).clone_for_update();\n \n-    // copy attributes & comments from variant\n-    let variant_attrs = attrs_and_docs(variant.syntax())\n-        .map(|tok| match tok.kind() {\n-            WHITESPACE => make::tokens::single_newline().into(),\n-            _ => tok,\n-        })\n-        .collect();\n-    ted::insert_all(ted::Position::first_child_of(strukt.syntax()), variant_attrs);\n+    // take comments from variant\n+    ted::insert_all(\n+        ted::Position::first_child_of(strukt.syntax()),\n+        take_all_comments(variant.syntax()),\n+    );\n \n     // copy attributes from enum\n     ted::insert_all(\n         ted::Position::first_child_of(strukt.syntax()),\n-        enum_.attrs().map(|it| it.syntax().clone_for_update().into()).collect(),\n+        enum_\n+            .attrs()\n+            .flat_map(|it| {\n+                vec![it.syntax().clone_for_update().into(), make::tokens::single_newline().into()]\n+            })\n+            .collect(),\n     );\n+\n     strukt\n }\n \n@@ -346,16 +331,48 @@ fn update_variant(variant: &ast::Variant, generics: Option<ast::GenericParamList\n         })\n         .unwrap_or_else(|| make::ty(&name.text()));\n \n+    // change from a record to a tuple field list\n     let tuple_field = make::tuple_field(None, ty);\n-    let replacement = make::variant(\n-        name,\n-        Some(ast::FieldList::TupleFieldList(make::tuple_field_list(iter::once(tuple_field)))),\n-    )\n-    .clone_for_update();\n-    ted::replace(variant.syntax(), replacement.syntax());\n+    let field_list = make::tuple_field_list(iter::once(tuple_field)).clone_for_update();\n+    ted::replace(variant.field_list()?.syntax(), field_list.syntax());\n+\n+    // remove any ws after the name\n+    if let Some(ws) = name\n+        .syntax()\n+        .siblings_with_tokens(syntax::Direction::Next)\n+        .find_map(|tok| tok.into_token().filter(|tok| tok.kind() == WHITESPACE))\n+    {\n+        ted::remove(SyntaxElement::Token(ws));\n+    }\n+\n     Some(())\n }\n \n+// Note: this also detaches whitespace after comments,\n+// since `SyntaxNode::splice_children` (and by extension `ted::insert_all_raw`)\n+// detaches nodes. If we only took the comments, we'd leave behind the old whitespace.\n+fn take_all_comments(node: &SyntaxNode) -> Vec<SyntaxElement> {\n+    let mut remove_next_ws = false;\n+    node.children_with_tokens()\n+        .filter_map(move |child| match child.kind() {\n+            COMMENT => {\n+                remove_next_ws = true;\n+                child.detach();\n+                Some(child)\n+            }\n+            WHITESPACE if remove_next_ws => {\n+                remove_next_ws = false;\n+                child.detach();\n+                Some(make::tokens::single_newline().into())\n+            }\n+            _ => {\n+                remove_next_ws = false;\n+                None\n+            }\n+        })\n+        .collect()\n+}\n+\n fn apply_references(\n     insert_use_cfg: InsertUseConfig,\n     segment: ast::PathSegment,\n@@ -480,10 +497,14 @@ enum En<T> { Var(Var<T>) }\"#,\n     fn test_extract_struct_carries_over_attributes() {\n         check_assist(\n             extract_struct_from_enum_variant,\n-            r#\"#[derive(Debug)]\n+            r#\"\n+#[derive(Debug)]\n #[derive(Clone)]\n enum Enum { Variant{ field: u32$0 } }\"#,\n-            r#\"#[derive(Debug)]#[derive(Clone)] struct Variant{ field: u32 }\n+            r#\"\n+#[derive(Debug)]\n+#[derive(Clone)]\n+struct Variant{ field: u32 }\n \n #[derive(Debug)]\n #[derive(Clone)]\n@@ -614,7 +635,7 @@ enum A { One(One) }\"#,\n     }\n \n     #[test]\n-    fn test_extract_struct_keep_comments_and_attrs_on_variant_struct() {\n+    fn test_extract_struct_move_struct_variant_comments() {\n         check_assist(\n             extract_struct_from_enum_variant,\n             r#\"\n@@ -631,19 +652,19 @@ enum A {\n /* comment */\n // other\n /// comment\n-#[attr]\n struct One{\n     a: u32\n }\n \n enum A {\n+    #[attr]\n     One(One)\n }\"#,\n         );\n     }\n \n     #[test]\n-    fn test_extract_struct_keep_comments_and_attrs_on_variant_tuple() {\n+    fn test_extract_struct_move_tuple_variant_comments() {\n         check_assist(\n             extract_struct_from_enum_variant,\n             r#\"\n@@ -658,10 +679,10 @@ enum A {\n /* comment */\n // other\n /// comment\n-#[attr]\n struct One(u32, u32);\n \n enum A {\n+    #[attr]\n     One(One)\n }\"#,\n         );"}, {"sha": "7d91be621013653aca193b1f23fc8a0469eaf376", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/replace_or_with_or_else.rs", "status": "added", "additions": 364, "deletions": 0, "changes": 364, "blob_url": "https://github.com/rust-lang/rust/blob/d0588007a997da288abde34a7c861c0acb0aefbd/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Freplace_or_with_or_else.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0588007a997da288abde34a7c861c0acb0aefbd/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Freplace_or_with_or_else.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Freplace_or_with_or_else.rs?ref=d0588007a997da288abde34a7c861c0acb0aefbd", "patch": "@@ -0,0 +1,364 @@\n+use ide_db::{\n+    assists::{AssistId, AssistKind},\n+    famous_defs::FamousDefs,\n+};\n+use syntax::{\n+    ast::{self, make, Expr, HasArgList},\n+    AstNode,\n+};\n+\n+use crate::{AssistContext, Assists};\n+\n+// Assist: replace_or_with_or_else\n+//\n+// Replace `unwrap_or` with `unwrap_or_else` and `ok_or` with `ok_or_else`.\n+//\n+// ```\n+// # //- minicore:option\n+// fn foo() {\n+//     let a = Some(1);\n+//     a.unwra$0p_or(2);\n+// }\n+// ```\n+// ->\n+// ```\n+// fn foo() {\n+//     let a = Some(1);\n+//     a.unwrap_or_else(|| 2);\n+// }\n+// ```\n+pub(crate) fn replace_or_with_or_else(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {\n+    let call: ast::MethodCallExpr = ctx.find_node_at_offset()?;\n+\n+    let kind = is_option_or_result(call.receiver()?, ctx)?;\n+\n+    let (name, arg_list) = (call.name_ref()?, call.arg_list()?);\n+\n+    let mut map_or = false;\n+\n+    let replace = match &*name.text() {\n+        \"unwrap_or\" => \"unwrap_or_else\".to_string(),\n+        \"or\" => \"or_else\".to_string(),\n+        \"ok_or\" if kind == Kind::Option => \"ok_or_else\".to_string(),\n+        \"map_or\" => {\n+            map_or = true;\n+            \"map_or_else\".to_string()\n+        }\n+        _ => return None,\n+    };\n+\n+    let arg = match arg_list.args().collect::<Vec<_>>().as_slice() {\n+        [] => make::arg_list(Vec::new()),\n+        [first] => {\n+            let param = into_closure(first);\n+            make::arg_list(vec![param])\n+        }\n+        [first, second] if map_or => {\n+            let param = into_closure(first);\n+            make::arg_list(vec![param, second.clone()])\n+        }\n+        _ => return None,\n+    };\n+\n+    acc.add(\n+        AssistId(\"replace_or_with_or_else\", AssistKind::RefactorRewrite),\n+        format!(\"Replace {} with {}\", name.text(), replace),\n+        call.syntax().text_range(),\n+        |builder| {\n+            builder.replace(name.syntax().text_range(), replace);\n+            builder.replace_ast(arg_list, arg)\n+        },\n+    )\n+}\n+\n+fn into_closure(param: &Expr) -> Expr {\n+    (|| {\n+        if let ast::Expr::CallExpr(call) = param {\n+            if call.arg_list()?.args().count() == 0 {\n+                Some(call.expr()?.clone())\n+            } else {\n+                None\n+            }\n+        } else {\n+            None\n+        }\n+    })()\n+    .unwrap_or_else(|| make::expr_closure(None, param.clone()))\n+}\n+\n+// Assist: replace_or_else_with_or\n+//\n+// Replace `unwrap_or_else` with `unwrap_or` and `ok_or_else` with `ok_or`.\n+//\n+// ```\n+// # //- minicore:option\n+// fn foo() {\n+//     let a = Some(1);\n+//     a.unwra$0p_or_else(|| 2);\n+// }\n+// ```\n+// ->\n+// ```\n+// fn foo() {\n+//     let a = Some(1);\n+//     a.unwrap_or(2);\n+// }\n+// ```\n+pub(crate) fn replace_or_else_with_or(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {\n+    let call: ast::MethodCallExpr = ctx.find_node_at_offset()?;\n+\n+    let kind = is_option_or_result(call.receiver()?, ctx)?;\n+\n+    let (name, arg_list) = (call.name_ref()?, call.arg_list()?);\n+\n+    let mut map_or = false;\n+    let replace = match &*name.text() {\n+        \"unwrap_or_else\" => \"unwrap_or\".to_string(),\n+        \"or_else\" => \"or\".to_string(),\n+        \"ok_or_else\" if kind == Kind::Option => \"ok_or\".to_string(),\n+        \"map_or_else\" => {\n+            map_or = true;\n+            \"map_or\".to_string()\n+        }\n+        _ => return None,\n+    };\n+\n+    let arg = match arg_list.args().collect::<Vec<_>>().as_slice() {\n+        [] => make::arg_list(Vec::new()),\n+        [first] => {\n+            let param = into_call(first);\n+            make::arg_list(vec![param])\n+        }\n+        [first, second] if map_or => {\n+            let param = into_call(first);\n+            make::arg_list(vec![param, second.clone()])\n+        }\n+        _ => return None,\n+    };\n+\n+    acc.add(\n+        AssistId(\"replace_or_else_with_or\", AssistKind::RefactorRewrite),\n+        format!(\"Replace {} with {}\", name.text(), replace),\n+        call.syntax().text_range(),\n+        |builder| {\n+            builder.replace(name.syntax().text_range(), replace);\n+            builder.replace_ast(arg_list, arg)\n+        },\n+    )\n+}\n+\n+fn into_call(param: &Expr) -> Expr {\n+    (|| {\n+        if let ast::Expr::ClosureExpr(closure) = param {\n+            if closure.param_list()?.params().count() == 0 {\n+                Some(closure.body()?.clone())\n+            } else {\n+                None\n+            }\n+        } else {\n+            None\n+        }\n+    })()\n+    .unwrap_or_else(|| make::expr_call(param.clone(), make::arg_list(Vec::new())))\n+}\n+\n+#[derive(PartialEq, Eq)]\n+enum Kind {\n+    Option,\n+    Result,\n+}\n+\n+fn is_option_or_result(receiver: Expr, ctx: &AssistContext<'_>) -> Option<Kind> {\n+    let ty = ctx.sema.type_of_expr(&receiver)?.adjusted().as_adt()?.as_enum()?;\n+    let option_enum =\n+        FamousDefs(&ctx.sema, ctx.sema.scope(receiver.syntax())?.krate()).core_option_Option();\n+\n+    if let Some(option_enum) = option_enum {\n+        if ty == option_enum {\n+            return Some(Kind::Option);\n+        }\n+    }\n+\n+    let result_enum =\n+        FamousDefs(&ctx.sema, ctx.sema.scope(receiver.syntax())?.krate()).core_result_Result();\n+\n+    if let Some(result_enum) = result_enum {\n+        if ty == result_enum {\n+            return Some(Kind::Result);\n+        }\n+    }\n+\n+    None\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use crate::tests::{check_assist, check_assist_not_applicable};\n+\n+    use super::*;\n+\n+    #[test]\n+    fn replace_or_with_or_else_simple() {\n+        check_assist(\n+            replace_or_with_or_else,\n+            r#\"\n+//- minicore: option\n+fn foo() {\n+    let foo = Some(1);\n+    return foo.unwrap_$0or(2);\n+}\n+\"#,\n+            r#\"\n+fn foo() {\n+    let foo = Some(1);\n+    return foo.unwrap_or_else(|| 2);\n+}\n+\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn replace_or_with_or_else_call() {\n+        check_assist(\n+            replace_or_with_or_else,\n+            r#\"\n+//- minicore: option\n+fn foo() {\n+    let foo = Some(1);\n+    return foo.unwrap_$0or(x());\n+}\n+\"#,\n+            r#\"\n+fn foo() {\n+    let foo = Some(1);\n+    return foo.unwrap_or_else(x);\n+}\n+\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn replace_or_with_or_else_block() {\n+        check_assist(\n+            replace_or_with_or_else,\n+            r#\"\n+//- minicore: option\n+fn foo() {\n+    let foo = Some(1);\n+    return foo.unwrap_$0or({\n+        let mut x = bar();\n+        for i in 0..10 {\n+            x += i;\n+        }\n+        x\n+    });\n+}\n+\"#,\n+            r#\"\n+fn foo() {\n+    let foo = Some(1);\n+    return foo.unwrap_or_else(|| {\n+        let mut x = bar();\n+        for i in 0..10 {\n+            x += i;\n+        }\n+        x\n+    });\n+}\n+\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn replace_or_else_with_or_simple() {\n+        check_assist(\n+            replace_or_else_with_or,\n+            r#\"\n+//- minicore: option\n+fn foo() {\n+    let foo = Some(1);\n+    return foo.unwrap_$0or_else(|| 2);\n+}\n+\"#,\n+            r#\"\n+fn foo() {\n+    let foo = Some(1);\n+    return foo.unwrap_or(2);\n+}\n+\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn replace_or_else_with_or_call() {\n+        check_assist(\n+            replace_or_else_with_or,\n+            r#\"\n+//- minicore: option\n+fn foo() {\n+    let foo = Some(1);\n+    return foo.unwrap_$0or_else(x);\n+}\n+\"#,\n+            r#\"\n+fn foo() {\n+    let foo = Some(1);\n+    return foo.unwrap_or(x());\n+}\n+\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn replace_or_else_with_or_result() {\n+        check_assist(\n+            replace_or_else_with_or,\n+            r#\"\n+//- minicore: result\n+fn foo() {\n+    let foo = Ok(1);\n+    return foo.unwrap_$0or_else(x);\n+}\n+\"#,\n+            r#\"\n+fn foo() {\n+    let foo = Ok(1);\n+    return foo.unwrap_or(x());\n+}\n+\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn replace_or_else_with_or_map() {\n+        check_assist(\n+            replace_or_else_with_or,\n+            r#\"\n+//- minicore: result\n+fn foo() {\n+    let foo = Ok(\"foo\");\n+    return foo.map$0_or_else(|| 42, |v| v.len());\n+}\n+\"#,\n+            r#\"\n+fn foo() {\n+    let foo = Ok(\"foo\");\n+    return foo.map_or(42, |v| v.len());\n+}\n+\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn replace_or_else_with_or_not_applicable() {\n+        check_assist_not_applicable(\n+            replace_or_else_with_or,\n+            r#\"\n+fn foo() {\n+    let foo = Ok(1);\n+    return foo.unwrap_$0or_else(x);\n+}\n+\"#,\n+        )\n+    }\n+}"}, {"sha": "521447c26dfbed01d20ac10592fd127a286f16ec", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/replace_turbofish_with_explicit_type.rs", "status": "modified", "additions": 141, "deletions": 19, "changes": 160, "blob_url": "https://github.com/rust-lang/rust/blob/d0588007a997da288abde34a7c861c0acb0aefbd/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Freplace_turbofish_with_explicit_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0588007a997da288abde34a7c861c0acb0aefbd/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Freplace_turbofish_with_explicit_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Freplace_turbofish_with_explicit_type.rs?ref=d0588007a997da288abde34a7c861c0acb0aefbd", "patch": "@@ -1,5 +1,6 @@\n+use hir::HirDisplay;\n use syntax::{\n-    ast::{Expr, GenericArg},\n+    ast::{Expr, GenericArg, GenericArgList},\n     ast::{LetStmt, Type::InferType},\n     AstNode, TextRange,\n };\n@@ -34,21 +35,7 @@ pub(crate) fn replace_turbofish_with_explicit_type(\n \n     let initializer = let_stmt.initializer()?;\n \n-    let generic_args = match &initializer {\n-        Expr::MethodCallExpr(ce) => ce.generic_arg_list()?,\n-        Expr::CallExpr(ce) => {\n-            if let Expr::PathExpr(pe) = ce.expr()? {\n-                pe.path()?.segment()?.generic_arg_list()?\n-            } else {\n-                cov_mark::hit!(not_applicable_if_non_path_function_call);\n-                return None;\n-            }\n-        }\n-        _ => {\n-            cov_mark::hit!(not_applicable_if_non_function_call_initializer);\n-            return None;\n-        }\n-    };\n+    let generic_args = generic_arg_list(&initializer)?;\n \n     // Find range of ::<_>\n     let colon2 = generic_args.coloncolon_token()?;\n@@ -65,7 +52,16 @@ pub(crate) fn replace_turbofish_with_explicit_type(\n \n     // An improvement would be to check that this is correctly part of the return value of the\n     // function call, or sub in the actual return type.\n-    let turbofish_type = &turbofish_args[0];\n+    let returned_type = match ctx.sema.type_of_expr(&initializer) {\n+        Some(returned_type) if !returned_type.original.contains_unknown() => {\n+            let module = ctx.sema.scope(let_stmt.syntax())?.module();\n+            returned_type.original.display_source_code(ctx.db(), module.into()).ok()?\n+        }\n+        _ => {\n+            cov_mark::hit!(fallback_to_turbofish_type_if_type_info_not_available);\n+            turbofish_args[0].to_string()\n+        }\n+    };\n \n     let initializer_start = initializer.syntax().text_range().start();\n     if ctx.offset() > turbofish_range.end() || ctx.offset() < initializer_start {\n@@ -83,7 +79,7 @@ pub(crate) fn replace_turbofish_with_explicit_type(\n             \"Replace turbofish with explicit type\",\n             TextRange::new(initializer_start, turbofish_range.end()),\n             |builder| {\n-                builder.insert(ident_range.end(), format!(\": {}\", turbofish_type));\n+                builder.insert(ident_range.end(), format!(\": {}\", returned_type));\n                 builder.delete(turbofish_range);\n             },\n         );\n@@ -98,7 +94,7 @@ pub(crate) fn replace_turbofish_with_explicit_type(\n             \"Replace `_` with turbofish type\",\n             turbofish_range,\n             |builder| {\n-                builder.replace(underscore_range, turbofish_type.to_string());\n+                builder.replace(underscore_range, returned_type);\n                 builder.delete(turbofish_range);\n             },\n         );\n@@ -107,6 +103,26 @@ pub(crate) fn replace_turbofish_with_explicit_type(\n     None\n }\n \n+fn generic_arg_list(expr: &Expr) -> Option<GenericArgList> {\n+    match expr {\n+        Expr::MethodCallExpr(expr) => expr.generic_arg_list(),\n+        Expr::CallExpr(expr) => {\n+            if let Expr::PathExpr(pe) = expr.expr()? {\n+                pe.path()?.segment()?.generic_arg_list()\n+            } else {\n+                cov_mark::hit!(not_applicable_if_non_path_function_call);\n+                return None;\n+            }\n+        }\n+        Expr::AwaitExpr(expr) => generic_arg_list(&expr.expr()?),\n+        Expr::TryExpr(expr) => generic_arg_list(&expr.expr()?),\n+        _ => {\n+            cov_mark::hit!(not_applicable_if_non_function_call_initializer);\n+            None\n+        }\n+    }\n+}\n+\n #[cfg(test)]\n mod tests {\n     use super::*;\n@@ -115,6 +131,7 @@ mod tests {\n \n     #[test]\n     fn replaces_turbofish_for_vec_string() {\n+        cov_mark::check!(fallback_to_turbofish_type_if_type_info_not_available);\n         check_assist(\n             replace_turbofish_with_explicit_type,\n             r#\"\n@@ -135,6 +152,7 @@ fn main() {\n     #[test]\n     fn replaces_method_calls() {\n         // foo.make() is a method call which uses a different expr in the let initializer\n+        cov_mark::check!(fallback_to_turbofish_type_if_type_info_not_available);\n         check_assist(\n             replace_turbofish_with_explicit_type,\n             r#\"\n@@ -237,6 +255,110 @@ fn make<T>() -> T {}\n fn main() {\n     let a = make$0::<Vec<String>, i32>();\n }\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn replaces_turbofish_for_known_type() {\n+        check_assist(\n+            replace_turbofish_with_explicit_type,\n+            r#\"\n+fn make<T>() -> T {}\n+fn main() {\n+    let a = make$0::<i32>();\n+}\n+\"#,\n+            r#\"\n+fn make<T>() -> T {}\n+fn main() {\n+    let a: i32 = make();\n+}\n+\"#,\n+        );\n+        check_assist(\n+            replace_turbofish_with_explicit_type,\n+            r#\"\n+//- minicore: option\n+fn make<T>() -> T {}\n+fn main() {\n+    let a = make$0::<Option<bool>>();\n+}\n+\"#,\n+            r#\"\n+fn make<T>() -> T {}\n+fn main() {\n+    let a: Option<bool> = make();\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn replaces_turbofish_not_same_type() {\n+        check_assist(\n+            replace_turbofish_with_explicit_type,\n+            r#\"\n+//- minicore: option\n+fn make<T>() -> Option<T> {}\n+fn main() {\n+    let a = make$0::<u128>();\n+}\n+\"#,\n+            r#\"\n+fn make<T>() -> Option<T> {}\n+fn main() {\n+    let a: Option<u128> = make();\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn replaces_turbofish_for_type_with_defaulted_generic_param() {\n+        check_assist(\n+            replace_turbofish_with_explicit_type,\n+            r#\"\n+struct HasDefault<T, U = i32>(T, U);\n+fn make<T>() -> HasDefault<T> {}\n+fn main() {\n+    let a = make$0::<bool>();\n+}\n+\"#,\n+            r#\"\n+struct HasDefault<T, U = i32>(T, U);\n+fn make<T>() -> HasDefault<T> {}\n+fn main() {\n+    let a: HasDefault<bool> = make();\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn replaces_turbofish_try_await() {\n+        check_assist(\n+            replace_turbofish_with_explicit_type,\n+            r#\"\n+//- minicore: option, future\n+struct Fut<T>(T);\n+impl<T> core::future::Future for Fut<T> {\n+    type Output = Option<T>;\n+}\n+fn make<T>() -> Fut<T> {}\n+fn main() {\n+    let a = make$0::<bool>().await?;\n+}\n+\"#,\n+            r#\"\n+struct Fut<T>(T);\n+impl<T> core::future::Future for Fut<T> {\n+    type Output = Option<T>;\n+}\n+fn make<T>() -> Fut<T> {}\n+fn main() {\n+    let a: bool = make().await?;\n+}\n \"#,\n         );\n     }"}, {"sha": "9565f0ee6f26f96833dd35d7977d03070033b619", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/handlers/unmerge_match_arm.rs", "status": "added", "additions": 293, "deletions": 0, "changes": 293, "blob_url": "https://github.com/rust-lang/rust/blob/d0588007a997da288abde34a7c861c0acb0aefbd/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Funmerge_match_arm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0588007a997da288abde34a7c861c0acb0aefbd/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Funmerge_match_arm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Fhandlers%2Funmerge_match_arm.rs?ref=d0588007a997da288abde34a7c861c0acb0aefbd", "patch": "@@ -0,0 +1,293 @@\n+use syntax::{\n+    algo::neighbor,\n+    ast::{self, edit::IndentLevel, make, AstNode},\n+    ted::{self, Position},\n+    Direction, SyntaxKind, T,\n+};\n+\n+use crate::{AssistContext, AssistId, AssistKind, Assists};\n+\n+// Assist: unmerge_match_arm\n+//\n+// Splits the current match with a `|` pattern into two arms with identical bodies.\n+//\n+// ```\n+// enum Action { Move { distance: u32 }, Stop }\n+//\n+// fn handle(action: Action) {\n+//     match action {\n+//         Action::Move(..) $0| Action::Stop => foo(),\n+//     }\n+// }\n+// ```\n+// ->\n+// ```\n+// enum Action { Move { distance: u32 }, Stop }\n+//\n+// fn handle(action: Action) {\n+//     match action {\n+//         Action::Move(..) => foo(),\n+//         Action::Stop => foo(),\n+//     }\n+// }\n+// ```\n+pub(crate) fn unmerge_match_arm(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {\n+    let pipe_token = ctx.find_token_syntax_at_offset(T![|])?;\n+    let or_pat = ast::OrPat::cast(pipe_token.parent()?)?.clone_for_update();\n+    let match_arm = ast::MatchArm::cast(or_pat.syntax().parent()?)?;\n+    let match_arm_body = match_arm.expr()?;\n+\n+    // We don't need to check for leading pipe because it is directly under `MatchArm`\n+    // without `OrPat`.\n+\n+    let new_parent = match_arm.syntax().parent()?;\n+    let old_parent_range = new_parent.text_range();\n+\n+    acc.add(\n+        AssistId(\"unmerge_match_arm\", AssistKind::RefactorRewrite),\n+        \"Unmerge match arm\",\n+        pipe_token.text_range(),\n+        |edit| {\n+            let pats_after = pipe_token\n+                .siblings_with_tokens(Direction::Next)\n+                .filter_map(|it| ast::Pat::cast(it.into_node()?));\n+            // FIXME: We should add a leading pipe if the original arm has one.\n+            let new_match_arm = make::match_arm(\n+                pats_after,\n+                match_arm.guard().and_then(|guard| guard.condition()),\n+                match_arm_body,\n+            )\n+            .clone_for_update();\n+\n+            let mut pipe_index = pipe_token.index();\n+            if pipe_token\n+                .prev_sibling_or_token()\n+                .map_or(false, |it| it.kind() == SyntaxKind::WHITESPACE)\n+            {\n+                pipe_index -= 1;\n+            }\n+            or_pat.syntax().splice_children(\n+                pipe_index..or_pat.syntax().children_with_tokens().count(),\n+                Vec::new(),\n+            );\n+\n+            let mut insert_after_old_arm = Vec::new();\n+\n+            // A comma can be:\n+            //  - After the arm. In this case we always want to insert a comma after the newly\n+            //    inserted arm.\n+            //  - Missing after the arm, with no arms after. In this case we want to insert a\n+            //    comma before the newly inserted arm. It can not be necessary if there arm\n+            //    body is a block, but we don't bother to check that.\n+            //  - Missing after the arm with arms after, if the arm body is a block. In this case\n+            //    we don't want to insert a comma at all.\n+            let has_comma_after =\n+                std::iter::successors(match_arm.syntax().last_child_or_token(), |it| {\n+                    it.prev_sibling_or_token()\n+                })\n+                .map(|it| it.kind())\n+                .skip_while(|it| it.is_trivia())\n+                .next()\n+                    == Some(T![,]);\n+            let has_arms_after = neighbor(&match_arm, Direction::Next).is_some();\n+            if !has_comma_after && !has_arms_after {\n+                insert_after_old_arm.push(make::token(T![,]).into());\n+            }\n+\n+            let indent = IndentLevel::from_node(match_arm.syntax());\n+            insert_after_old_arm.push(make::tokens::whitespace(&format!(\"\\n{indent}\")).into());\n+\n+            insert_after_old_arm.push(new_match_arm.syntax().clone().into());\n+\n+            ted::insert_all_raw(Position::after(match_arm.syntax()), insert_after_old_arm);\n+\n+            if has_comma_after {\n+                ted::insert_raw(\n+                    Position::last_child_of(new_match_arm.syntax()),\n+                    make::token(T![,]),\n+                );\n+            }\n+\n+            edit.replace(old_parent_range, new_parent.to_string());\n+        },\n+    )\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use crate::tests::{check_assist, check_assist_not_applicable};\n+\n+    use super::*;\n+\n+    #[test]\n+    fn unmerge_match_arm_single_pipe() {\n+        check_assist(\n+            unmerge_match_arm,\n+            r#\"\n+#[derive(Debug)]\n+enum X { A, B, C }\n+\n+fn main() {\n+    let x = X::A;\n+    let y = match x {\n+        X::A $0| X::B => { 1i32 }\n+        X::C => { 2i32 }\n+    };\n+}\n+\"#,\n+            r#\"\n+#[derive(Debug)]\n+enum X { A, B, C }\n+\n+fn main() {\n+    let x = X::A;\n+    let y = match x {\n+        X::A => { 1i32 }\n+        X::B => { 1i32 }\n+        X::C => { 2i32 }\n+    };\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn unmerge_match_arm_guard() {\n+        check_assist(\n+            unmerge_match_arm,\n+            r#\"\n+#[derive(Debug)]\n+enum X { A, B, C }\n+\n+fn main() {\n+    let x = X::A;\n+    let y = match x {\n+        X::A $0| X::B if true => { 1i32 }\n+        _ => { 2i32 }\n+    };\n+}\n+\"#,\n+            r#\"\n+#[derive(Debug)]\n+enum X { A, B, C }\n+\n+fn main() {\n+    let x = X::A;\n+    let y = match x {\n+        X::A if true => { 1i32 }\n+        X::B if true => { 1i32 }\n+        _ => { 2i32 }\n+    };\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn unmerge_match_arm_leading_pipe() {\n+        check_assist_not_applicable(\n+            unmerge_match_arm,\n+            r#\"\n+\n+fn main() {\n+    let y = match 0 {\n+        |$0 0 => { 1i32 }\n+        1 => { 2i32 }\n+    };\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn unmerge_match_arm_multiple_pipes() {\n+        check_assist(\n+            unmerge_match_arm,\n+            r#\"\n+#[derive(Debug)]\n+enum X { A, B, C, D, E }\n+\n+fn main() {\n+    let x = X::A;\n+    let y = match x {\n+        X::A | X::B |$0 X::C | X::D => 1i32,\n+        X::E => 2i32,\n+    };\n+}\n+\"#,\n+            r#\"\n+#[derive(Debug)]\n+enum X { A, B, C, D, E }\n+\n+fn main() {\n+    let x = X::A;\n+    let y = match x {\n+        X::A | X::B => 1i32,\n+        X::C | X::D => 1i32,\n+        X::E => 2i32,\n+    };\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn unmerge_match_arm_inserts_comma_if_required() {\n+        check_assist(\n+            unmerge_match_arm,\n+            r#\"\n+#[derive(Debug)]\n+enum X { A, B }\n+\n+fn main() {\n+    let x = X::A;\n+    let y = match x {\n+        X::A $0| X::B => 1i32\n+    };\n+}\n+\"#,\n+            r#\"\n+#[derive(Debug)]\n+enum X { A, B }\n+\n+fn main() {\n+    let x = X::A;\n+    let y = match x {\n+        X::A => 1i32,\n+        X::B => 1i32\n+    };\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn unmerge_match_arm_inserts_comma_if_had_after() {\n+        check_assist(\n+            unmerge_match_arm,\n+            r#\"\n+#[derive(Debug)]\n+enum X { A, B }\n+\n+fn main() {\n+    let x = X::A;\n+    match x {\n+        X::A $0| X::B => {},\n+    }\n+}\n+\"#,\n+            r#\"\n+#[derive(Debug)]\n+enum X { A, B }\n+\n+fn main() {\n+    let x = X::A;\n+    match x {\n+        X::A => {},\n+        X::B => {},\n+    }\n+}\n+\"#,\n+        );\n+    }\n+}"}, {"sha": "e52544db5f530ff969735c4a25b305c64c5491ae", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/lib.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d0588007a997da288abde34a7c861c0acb0aefbd/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0588007a997da288abde34a7c861c0acb0aefbd/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Flib.rs?ref=d0588007a997da288abde34a7c861c0acb0aefbd", "patch": "@@ -122,6 +122,7 @@ mod handlers {\n     mod convert_let_else_to_match;\n     mod convert_tuple_struct_to_named_struct;\n     mod convert_to_guarded_return;\n+    mod convert_two_arm_bool_match_to_matches_macro;\n     mod convert_while_to_loop;\n     mod destructure_tuple_binding;\n     mod expand_glob_import;\n@@ -179,12 +180,14 @@ mod handlers {\n     mod replace_try_expr_with_match;\n     mod replace_derive_with_manual_impl;\n     mod replace_if_let_with_match;\n+    mod replace_or_with_or_else;\n     mod introduce_named_generic;\n     mod replace_let_with_if_let;\n     mod replace_qualified_name_with_use;\n     mod replace_string_with_char;\n     mod replace_turbofish_with_explicit_type;\n     mod split_import;\n+    mod unmerge_match_arm;\n     mod sort_items;\n     mod toggle_ignore;\n     mod unmerge_use;\n@@ -215,6 +218,7 @@ mod handlers {\n             convert_let_else_to_match::convert_let_else_to_match,\n             convert_to_guarded_return::convert_to_guarded_return,\n             convert_tuple_struct_to_named_struct::convert_tuple_struct_to_named_struct,\n+            convert_two_arm_bool_match_to_matches_macro::convert_two_arm_bool_match_to_matches_macro,\n             convert_while_to_loop::convert_while_to_loop,\n             destructure_tuple_binding::destructure_tuple_binding,\n             expand_glob_import::expand_glob_import,\n@@ -273,11 +277,14 @@ mod handlers {\n             replace_if_let_with_match::replace_if_let_with_match,\n             replace_if_let_with_match::replace_match_with_if_let,\n             replace_let_with_if_let::replace_let_with_if_let,\n+            replace_or_with_or_else::replace_or_else_with_or,\n+            replace_or_with_or_else::replace_or_with_or_else,\n             replace_turbofish_with_explicit_type::replace_turbofish_with_explicit_type,\n             replace_qualified_name_with_use::replace_qualified_name_with_use,\n             sort_items::sort_items,\n             split_import::split_import,\n             toggle_ignore::toggle_ignore,\n+            unmerge_match_arm::unmerge_match_arm,\n             unmerge_use::unmerge_use,\n             unnecessary_async::unnecessary_async,\n             unwrap_block::unwrap_block,"}, {"sha": "a8c8622c1c1d89cdcab5caf4d489f96f454112f2", "filename": "src/tools/rust-analyzer/crates/ide-assists/src/tests/generated.rs", "status": "modified", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/d0588007a997da288abde34a7c861c0acb0aefbd/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Ftests%2Fgenerated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0588007a997da288abde34a7c861c0acb0aefbd/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Ftests%2Fgenerated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-assists%2Fsrc%2Ftests%2Fgenerated.rs?ref=d0588007a997da288abde34a7c861c0acb0aefbd", "patch": "@@ -472,6 +472,26 @@ impl Point {\n     )\n }\n \n+#[test]\n+fn doctest_convert_two_arm_bool_match_to_matches_macro() {\n+    check_doc_test(\n+        \"convert_two_arm_bool_match_to_matches_macro\",\n+        r#####\"\n+fn main() {\n+    match scrutinee$0 {\n+        Some(val) if val.cond() => true,\n+        _ => false,\n+    }\n+}\n+\"#####,\n+        r#####\"\n+fn main() {\n+    matches!(scrutinee, Some(val) if val.cond())\n+}\n+\"#####,\n+    )\n+}\n+\n #[test]\n fn doctest_convert_while_to_loop() {\n     check_doc_test(\n@@ -2009,6 +2029,46 @@ fn handle(action: Action) {\n     )\n }\n \n+#[test]\n+fn doctest_replace_or_else_with_or() {\n+    check_doc_test(\n+        \"replace_or_else_with_or\",\n+        r#####\"\n+//- minicore:option\n+fn foo() {\n+    let a = Some(1);\n+    a.unwra$0p_or_else(|| 2);\n+}\n+\"#####,\n+        r#####\"\n+fn foo() {\n+    let a = Some(1);\n+    a.unwrap_or(2);\n+}\n+\"#####,\n+    )\n+}\n+\n+#[test]\n+fn doctest_replace_or_with_or_else() {\n+    check_doc_test(\n+        \"replace_or_with_or_else\",\n+        r#####\"\n+//- minicore:option\n+fn foo() {\n+    let a = Some(1);\n+    a.unwra$0p_or(2);\n+}\n+\"#####,\n+        r#####\"\n+fn foo() {\n+    let a = Some(1);\n+    a.unwrap_or_else(|| 2);\n+}\n+\"#####,\n+    )\n+}\n+\n #[test]\n fn doctest_replace_qualified_name_with_use() {\n     check_doc_test(\n@@ -2207,6 +2267,32 @@ fn arithmetics {\n     )\n }\n \n+#[test]\n+fn doctest_unmerge_match_arm() {\n+    check_doc_test(\n+        \"unmerge_match_arm\",\n+        r#####\"\n+enum Action { Move { distance: u32 }, Stop }\n+\n+fn handle(action: Action) {\n+    match action {\n+        Action::Move(..) $0| Action::Stop => foo(),\n+    }\n+}\n+\"#####,\n+        r#####\"\n+enum Action { Move { distance: u32 }, Stop }\n+\n+fn handle(action: Action) {\n+    match action {\n+        Action::Move(..) => foo(),\n+        Action::Stop => foo(),\n+    }\n+}\n+\"#####,\n+    )\n+}\n+\n #[test]\n fn doctest_unmerge_use() {\n     check_doc_test("}, {"sha": "588b52cc1ee3a72090d66899fdf89756ad6c48f3", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/completions/expr.rs", "status": "modified", "additions": 18, "deletions": 6, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/d0588007a997da288abde34a7c861c0acb0aefbd/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0588007a997da288abde34a7c861c0acb0aefbd/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Fcompletions%2Fexpr.rs?ref=d0588007a997da288abde34a7c861c0acb0aefbd", "patch": "@@ -282,14 +282,26 @@ pub(crate) fn complete_expr_path(\n                         }\n                     }\n \n-                    if let Some(ty) = innermost_ret_ty {\n+                    if let Some(ret_ty) = innermost_ret_ty {\n                         add_keyword(\n                             \"return\",\n-                            match (in_block_expr, ty.is_unit()) {\n-                                (true, true) => \"return ;\",\n-                                (true, false) => \"return;\",\n-                                (false, true) => \"return $0\",\n-                                (false, false) => \"return\",\n+                            match (ret_ty.is_unit(), in_block_expr) {\n+                                (true, true) => {\n+                                    cov_mark::hit!(return_unit_block);\n+                                    \"return;\"\n+                                }\n+                                (true, false) => {\n+                                    cov_mark::hit!(return_unit_no_block);\n+                                    \"return\"\n+                                }\n+                                (false, true) => {\n+                                    cov_mark::hit!(return_value_block);\n+                                    \"return $0;\"\n+                                }\n+                                (false, false) => {\n+                                    cov_mark::hit!(return_value_no_block);\n+                                    \"return $0\"\n+                                }\n                             },\n                         );\n                     }"}, {"sha": "38e24ebc732d497aa4250f6fe23d06a2c2614f61", "filename": "src/tools/rust-analyzer/crates/ide-completion/src/tests/expression.rs", "status": "modified", "additions": 37, "deletions": 1, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/d0588007a997da288abde34a7c861c0acb0aefbd/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Ftests%2Fexpression.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0588007a997da288abde34a7c861c0acb0aefbd/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Ftests%2Fexpression.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-completion%2Fsrc%2Ftests%2Fexpression.rs?ref=d0588007a997da288abde34a7c861c0acb0aefbd", "patch": "@@ -1,7 +1,7 @@\n //! Completion tests for expressions.\n use expect_test::{expect, Expect};\n \n-use crate::tests::{completion_list, BASE_ITEMS_FIXTURE};\n+use crate::tests::{check_edit, completion_list, BASE_ITEMS_FIXTURE};\n \n fn check(ra_fixture: &str, expect: Expect) {\n     let actual = completion_list(&format!(\"{}{}\", BASE_ITEMS_FIXTURE, ra_fixture));\n@@ -670,3 +670,39 @@ fn main() {\n         \"#]],\n     );\n }\n+\n+#[test]\n+fn return_unit_block() {\n+    cov_mark::check!(return_unit_block);\n+    check_edit(\"return\", r#\"fn f() { if true { $0 } }\"#, r#\"fn f() { if true { return; } }\"#);\n+}\n+\n+#[test]\n+fn return_unit_no_block() {\n+    cov_mark::check!(return_unit_no_block);\n+    check_edit(\n+        \"return\",\n+        r#\"fn f() { match () { () => $0 } }\"#,\n+        r#\"fn f() { match () { () => return } }\"#,\n+    );\n+}\n+\n+#[test]\n+fn return_value_block() {\n+    cov_mark::check!(return_value_block);\n+    check_edit(\n+        \"return\",\n+        r#\"fn f() -> i32 { if true { $0 } }\"#,\n+        r#\"fn f() -> i32 { if true { return $0; } }\"#,\n+    );\n+}\n+\n+#[test]\n+fn return_value_no_block() {\n+    cov_mark::check!(return_value_no_block);\n+    check_edit(\n+        \"return\",\n+        r#\"fn f() -> i32 { match () { () => $0 } }\"#,\n+        r#\"fn f() -> i32 { match () { () => return $0 } }\"#,\n+    );\n+}"}, {"sha": "b890e2b58df8f2688923c1262665e7361a747881", "filename": "src/tools/rust-analyzer/crates/ide-db/src/syntax_helpers/node_ext.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d0588007a997da288abde34a7c861c0acb0aefbd/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Fsyntax_helpers%2Fnode_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0588007a997da288abde34a7c861c0acb0aefbd/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Fsyntax_helpers%2Fnode_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-db%2Fsrc%2Fsyntax_helpers%2Fnode_ext.rs?ref=d0588007a997da288abde34a7c861c0acb0aefbd", "patch": "@@ -315,7 +315,6 @@ pub fn for_each_tail_expr(expr: &ast::Expr, cb: &mut dyn FnMut(&ast::Expr)) {\n         | ast::Expr::IndexExpr(_)\n         | ast::Expr::Literal(_)\n         | ast::Expr::MacroExpr(_)\n-        | ast::Expr::MacroStmts(_)\n         | ast::Expr::MethodCallExpr(_)\n         | ast::Expr::ParenExpr(_)\n         | ast::Expr::PathExpr(_)"}, {"sha": "0c92e706b3916f65c73df4b6e3945b4e6501a052", "filename": "src/tools/rust-analyzer/crates/ide-diagnostics/src/handlers/break_outside_of_loop.rs", "status": "modified", "additions": 116, "deletions": 4, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/d0588007a997da288abde34a7c861c0acb0aefbd/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fbreak_outside_of_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0588007a997da288abde34a7c861c0acb0aefbd/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fbreak_outside_of_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fbreak_outside_of_loop.rs?ref=d0588007a997da288abde34a7c861c0acb0aefbd", "patch": "@@ -7,9 +7,10 @@ pub(crate) fn break_outside_of_loop(\n     ctx: &DiagnosticsContext<'_>,\n     d: &hir::BreakOutsideOfLoop,\n ) -> Diagnostic {\n+    let construct = if d.is_break { \"break\" } else { \"continue\" };\n     Diagnostic::new(\n         \"break-outside-of-loop\",\n-        \"break outside of loop\",\n+        format!(\"{construct} outside of loop\"),\n         ctx.sema.diagnostics_display_range(d.expr.clone().map(|it| it.into())).range,\n     )\n }\n@@ -19,11 +20,122 @@ mod tests {\n     use crate::tests::check_diagnostics;\n \n     #[test]\n-    fn break_outside_of_loop() {\n+    fn outside_of_loop() {\n         check_diagnostics(\n             r#\"\n-fn foo() { break; }\n-         //^^^^^ error: break outside of loop\n+fn foo() {\n+    break;\n+  //^^^^^ error: break outside of loop\n+    break 'a;\n+  //^^^^^^^^ error: break outside of loop\n+    continue;\n+  //^^^^^^^^ error: continue outside of loop\n+    continue 'a;\n+  //^^^^^^^^^^^ error: continue outside of loop\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn try_blocks_are_borders() {\n+        check_diagnostics(\n+            r#\"\n+fn foo() {\n+    'a: loop {\n+        try {\n+                break;\n+              //^^^^^ error: break outside of loop\n+                break 'a;\n+              //^^^^^^^^ error: break outside of loop\n+                continue;\n+              //^^^^^^^^ error: continue outside of loop\n+                continue 'a;\n+              //^^^^^^^^^^^ error: continue outside of loop\n+        };\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn async_blocks_are_borders() {\n+        check_diagnostics(\n+            r#\"\n+fn foo() {\n+    'a: loop {\n+        try {\n+                break;\n+              //^^^^^ error: break outside of loop\n+                break 'a;\n+              //^^^^^^^^ error: break outside of loop\n+                continue;\n+              //^^^^^^^^ error: continue outside of loop\n+                continue 'a;\n+              //^^^^^^^^^^^ error: continue outside of loop\n+        };\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn closures_are_borders() {\n+        check_diagnostics(\n+            r#\"\n+fn foo() {\n+    'a: loop {\n+        try {\n+                break;\n+              //^^^^^ error: break outside of loop\n+                break 'a;\n+              //^^^^^^^^ error: break outside of loop\n+                continue;\n+              //^^^^^^^^ error: continue outside of loop\n+                continue 'a;\n+              //^^^^^^^^^^^ error: continue outside of loop\n+        };\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn blocks_pass_through() {\n+        check_diagnostics(\n+            r#\"\n+fn foo() {\n+    'a: loop {\n+        {\n+            break;\n+            break 'a;\n+            continue;\n+            continue 'a;\n+        }\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn label_blocks() {\n+        check_diagnostics(\n+            r#\"\n+fn foo() {\n+    'a: {\n+        break;\n+      //^^^^^ error: break outside of loop\n+        break 'a;\n+        continue;\n+      //^^^^^^^^ error: continue outside of loop\n+        continue 'a;\n+      //^^^^^^^^^^^ error: continue outside of loop\n+    }\n+}\n \"#,\n         );\n     }"}, {"sha": "c24430ce604692de844a2cc86cea6e0e2bc24abe", "filename": "src/tools/rust-analyzer/crates/ide-diagnostics/src/handlers/missing_match_arms.rs", "status": "modified", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/d0588007a997da288abde34a7c861c0acb0aefbd/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fmissing_match_arms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0588007a997da288abde34a7c861c0acb0aefbd/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fmissing_match_arms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fmissing_match_arms.rs?ref=d0588007a997da288abde34a7c861c0acb0aefbd", "patch": "@@ -947,6 +947,50 @@ fn f() {\n         );\n     }\n \n+    mod rust_unstable {\n+        use super::*;\n+\n+        #[test]\n+        fn rfc_1872_exhaustive_patterns() {\n+            check_diagnostics_no_bails(\n+                r\"\n+//- minicore: option, result\n+#![feature(exhaustive_patterns)]\n+enum Void {}\n+fn test() {\n+    match None::<!> { None => () }\n+    match Result::<u8, !>::Ok(2) { Ok(_) => () }\n+    match Result::<u8, Void>::Ok(2) { Ok(_) => () }\n+    match (2, loop {}) {}\n+    match Result::<!, !>::Ok(loop {}) {}\n+    match (&loop {}) {} // https://github.com/rust-lang/rust/issues/50642#issuecomment-388234919\n+    //    ^^^^^^^^^^ error: missing match arm: type `&!` is non-empty\n+}\",\n+            );\n+        }\n+\n+        #[test]\n+        fn rfc_1872_private_uninhabitedness() {\n+            check_diagnostics_no_bails(\n+                r\"\n+//- minicore: option\n+//- /lib.rs crate:lib\n+#![feature(exhaustive_patterns)]\n+pub struct PrivatelyUninhabited { private_field: Void }\n+enum Void {}\n+fn test_local(x: Option<PrivatelyUninhabited>) {\n+    match x {}\n+} //      ^ error: missing match arm: `None` not covered\n+//- /main.rs crate:main deps:lib\n+#![feature(exhaustive_patterns)]\n+fn test(x: Option<lib::PrivatelyUninhabited>) {\n+    match x {}\n+    //    ^ error: missing match arm: `None` and `Some(_)` not covered\n+}\",\n+            );\n+        }\n+    }\n+\n     mod false_negatives {\n         //! The implementation of match checking here is a work in progress. As we roll this out, we\n         //! prefer false negatives to false positives (ideally there would be no false positives). This"}, {"sha": "e9034daefa8d46c1dea2afce1e07683f52f82f66", "filename": "src/tools/rust-analyzer/crates/ide/src/inlay_hints.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d0588007a997da288abde34a7c861c0acb0aefbd/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Finlay_hints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0588007a997da288abde34a7c861c0acb0aefbd/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Finlay_hints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fide%2Fsrc%2Finlay_hints.rs?ref=d0588007a997da288abde34a7c861c0acb0aefbd", "patch": "@@ -1910,7 +1910,7 @@ impl<T> Vec<T> {\n pub struct Box<T> {}\n \n trait Display {}\n-trait Sync {}\n+auto trait Sync {}\n \n fn main() {\n     // The block expression wrapping disables the constructor hint hiding logic"}, {"sha": "5dc9c6c82a14e06f0dda759607d69f9431713d07", "filename": "src/tools/rust-analyzer/crates/parser/src/grammar/paths.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d0588007a997da288abde34a7c861c0acb0aefbd/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Fsrc%2Fgrammar%2Fpaths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0588007a997da288abde34a7c861c0acb0aefbd/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Fsrc%2Fgrammar%2Fpaths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Fsrc%2Fgrammar%2Fpaths.rs?ref=d0588007a997da288abde34a7c861c0acb0aefbd", "patch": "@@ -118,6 +118,11 @@ fn opt_path_type_args(p: &mut Parser<'_>, mode: Mode) {\n     match mode {\n         Mode::Use => {}\n         Mode::Type => {\n+            // test typepathfn_with_coloncolon\n+            // type F = Start::(Middle) -> (Middle)::End;\n+            if p.at(T![::]) && p.nth_at(2, T!['(']) {\n+                p.bump(T![::]);\n+            }\n             // test path_fn_trait_args\n             // type F = Box<Fn(i32) -> ()>;\n             if p.at(T!['(']) {"}, {"sha": "c84f45f1f8e4ec0f059a484354a45fc042fb2e0a", "filename": "src/tools/rust-analyzer/crates/parser/src/syntax_kind/generated.rs", "status": "modified", "additions": 107, "deletions": 23, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/d0588007a997da288abde34a7c861c0acb0aefbd/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Fsrc%2Fsyntax_kind%2Fgenerated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0588007a997da288abde34a7c861c0acb0aefbd/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Fsrc%2Fsyntax_kind%2Fgenerated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Fsrc%2Fsyntax_kind%2Fgenerated.rs?ref=d0588007a997da288abde34a7c861c0acb0aefbd", "patch": "@@ -262,33 +262,117 @@ pub enum SyntaxKind {\n use self::SyntaxKind::*;\n impl SyntaxKind {\n     pub fn is_keyword(self) -> bool {\n-        match self {\n-            AS_KW | ASYNC_KW | AWAIT_KW | BOX_KW | BREAK_KW | CONST_KW | CONTINUE_KW | CRATE_KW\n-            | DYN_KW | ELSE_KW | ENUM_KW | EXTERN_KW | FALSE_KW | FN_KW | FOR_KW | IF_KW\n-            | IMPL_KW | IN_KW | LET_KW | LOOP_KW | MACRO_KW | MATCH_KW | MOD_KW | MOVE_KW\n-            | MUT_KW | PUB_KW | REF_KW | RETURN_KW | SELF_KW | SELF_TYPE_KW | STATIC_KW\n-            | STRUCT_KW | SUPER_KW | TRAIT_KW | TRUE_KW | TRY_KW | TYPE_KW | UNSAFE_KW | USE_KW\n-            | WHERE_KW | WHILE_KW | YIELD_KW | AUTO_KW | DEFAULT_KW | EXISTENTIAL_KW | UNION_KW\n-            | RAW_KW | MACRO_RULES_KW => true,\n-            _ => false,\n-        }\n+        matches!(\n+            self,\n+            AS_KW\n+                | ASYNC_KW\n+                | AWAIT_KW\n+                | BOX_KW\n+                | BREAK_KW\n+                | CONST_KW\n+                | CONTINUE_KW\n+                | CRATE_KW\n+                | DYN_KW\n+                | ELSE_KW\n+                | ENUM_KW\n+                | EXTERN_KW\n+                | FALSE_KW\n+                | FN_KW\n+                | FOR_KW\n+                | IF_KW\n+                | IMPL_KW\n+                | IN_KW\n+                | LET_KW\n+                | LOOP_KW\n+                | MACRO_KW\n+                | MATCH_KW\n+                | MOD_KW\n+                | MOVE_KW\n+                | MUT_KW\n+                | PUB_KW\n+                | REF_KW\n+                | RETURN_KW\n+                | SELF_KW\n+                | SELF_TYPE_KW\n+                | STATIC_KW\n+                | STRUCT_KW\n+                | SUPER_KW\n+                | TRAIT_KW\n+                | TRUE_KW\n+                | TRY_KW\n+                | TYPE_KW\n+                | UNSAFE_KW\n+                | USE_KW\n+                | WHERE_KW\n+                | WHILE_KW\n+                | YIELD_KW\n+                | AUTO_KW\n+                | DEFAULT_KW\n+                | EXISTENTIAL_KW\n+                | UNION_KW\n+                | RAW_KW\n+                | MACRO_RULES_KW\n+        )\n     }\n     pub fn is_punct(self) -> bool {\n-        match self {\n-            SEMICOLON | COMMA | L_PAREN | R_PAREN | L_CURLY | R_CURLY | L_BRACK | R_BRACK\n-            | L_ANGLE | R_ANGLE | AT | POUND | TILDE | QUESTION | DOLLAR | AMP | PIPE | PLUS\n-            | STAR | SLASH | CARET | PERCENT | UNDERSCORE | DOT | DOT2 | DOT3 | DOT2EQ | COLON\n-            | COLON2 | EQ | EQ2 | FAT_ARROW | BANG | NEQ | MINUS | THIN_ARROW | LTEQ | GTEQ\n-            | PLUSEQ | MINUSEQ | PIPEEQ | AMPEQ | CARETEQ | SLASHEQ | STAREQ | PERCENTEQ | AMP2\n-            | PIPE2 | SHL | SHR | SHLEQ | SHREQ => true,\n-            _ => false,\n-        }\n+        matches!(\n+            self,\n+            SEMICOLON\n+                | COMMA\n+                | L_PAREN\n+                | R_PAREN\n+                | L_CURLY\n+                | R_CURLY\n+                | L_BRACK\n+                | R_BRACK\n+                | L_ANGLE\n+                | R_ANGLE\n+                | AT\n+                | POUND\n+                | TILDE\n+                | QUESTION\n+                | DOLLAR\n+                | AMP\n+                | PIPE\n+                | PLUS\n+                | STAR\n+                | SLASH\n+                | CARET\n+                | PERCENT\n+                | UNDERSCORE\n+                | DOT\n+                | DOT2\n+                | DOT3\n+                | DOT2EQ\n+                | COLON\n+                | COLON2\n+                | EQ\n+                | EQ2\n+                | FAT_ARROW\n+                | BANG\n+                | NEQ\n+                | MINUS\n+                | THIN_ARROW\n+                | LTEQ\n+                | GTEQ\n+                | PLUSEQ\n+                | MINUSEQ\n+                | PIPEEQ\n+                | AMPEQ\n+                | CARETEQ\n+                | SLASHEQ\n+                | STAREQ\n+                | PERCENTEQ\n+                | AMP2\n+                | PIPE2\n+                | SHL\n+                | SHR\n+                | SHLEQ\n+                | SHREQ\n+        )\n     }\n     pub fn is_literal(self) -> bool {\n-        match self {\n-            INT_NUMBER | FLOAT_NUMBER | CHAR | BYTE | STRING | BYTE_STRING => true,\n-            _ => false,\n-        }\n+        matches!(self, INT_NUMBER | FLOAT_NUMBER | CHAR | BYTE | STRING | BYTE_STRING)\n     }\n     pub fn from_keyword(ident: &str) -> Option<SyntaxKind> {\n         let kw = match ident {"}, {"sha": "b47a5a5c14705c4f6ec78a5e66749f6de6bc4f01", "filename": "src/tools/rust-analyzer/crates/parser/test_data/parser/inline/ok/0202_typepathfn_with_coloncolon.rast", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/d0588007a997da288abde34a7c861c0acb0aefbd/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Ftest_data%2Fparser%2Finline%2Fok%2F0202_typepathfn_with_coloncolon.rast", "raw_url": "https://github.com/rust-lang/rust/raw/d0588007a997da288abde34a7c861c0acb0aefbd/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Ftest_data%2Fparser%2Finline%2Fok%2F0202_typepathfn_with_coloncolon.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Ftest_data%2Fparser%2Finline%2Fok%2F0202_typepathfn_with_coloncolon.rast?ref=d0588007a997da288abde34a7c861c0acb0aefbd", "patch": "@@ -0,0 +1,43 @@\n+SOURCE_FILE\n+  TYPE_ALIAS\n+    TYPE_KW \"type\"\n+    WHITESPACE \" \"\n+    NAME\n+      IDENT \"F\"\n+    WHITESPACE \" \"\n+    EQ \"=\"\n+    WHITESPACE \" \"\n+    PATH_TYPE\n+      PATH\n+        PATH\n+          PATH_SEGMENT\n+            NAME_REF\n+              IDENT \"Start\"\n+            COLON2 \"::\"\n+            PARAM_LIST\n+              L_PAREN \"(\"\n+              PARAM\n+                PATH_TYPE\n+                  PATH\n+                    PATH_SEGMENT\n+                      NAME_REF\n+                        IDENT \"Middle\"\n+              R_PAREN \")\"\n+            WHITESPACE \" \"\n+            RET_TYPE\n+              THIN_ARROW \"->\"\n+              WHITESPACE \" \"\n+              PAREN_TYPE\n+                L_PAREN \"(\"\n+                PATH_TYPE\n+                  PATH\n+                    PATH_SEGMENT\n+                      NAME_REF\n+                        IDENT \"Middle\"\n+                R_PAREN \")\"\n+        COLON2 \"::\"\n+        PATH_SEGMENT\n+          NAME_REF\n+            IDENT \"End\"\n+    SEMICOLON \";\"\n+  WHITESPACE \"\\n\""}, {"sha": "8efd93a7ff6858281294f1453f9f51f5e88f12f5", "filename": "src/tools/rust-analyzer/crates/parser/test_data/parser/inline/ok/0202_typepathfn_with_coloncolon.rs", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d0588007a997da288abde34a7c861c0acb0aefbd/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Ftest_data%2Fparser%2Finline%2Fok%2F0202_typepathfn_with_coloncolon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0588007a997da288abde34a7c861c0acb0aefbd/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Ftest_data%2Fparser%2Finline%2Fok%2F0202_typepathfn_with_coloncolon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fparser%2Ftest_data%2Fparser%2Finline%2Fok%2F0202_typepathfn_with_coloncolon.rs?ref=d0588007a997da288abde34a7c861c0acb0aefbd", "patch": "@@ -0,0 +1 @@\n+type F = Start::(Middle) -> (Middle)::End;"}, {"sha": "92df4d70fd9024edc3865ddd935ae62bee437389", "filename": "src/tools/rust-analyzer/crates/rust-analyzer/src/global_state.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d0588007a997da288abde34a7c861c0acb0aefbd/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fglobal_state.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0588007a997da288abde34a7c861c0acb0aefbd/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fglobal_state.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fglobal_state.rs?ref=d0588007a997da288abde34a7c861c0acb0aefbd", "patch": "@@ -116,6 +116,7 @@ pub(crate) struct GlobalStateSnapshot {\n     pub(crate) semantic_tokens_cache: Arc<Mutex<FxHashMap<Url, SemanticTokens>>>,\n     vfs: Arc<RwLock<(vfs::Vfs, NoHashHashMap<FileId, LineEndings>)>>,\n     pub(crate) workspaces: Arc<Vec<ProjectWorkspace>>,\n+    pub(crate) proc_macros_loaded: bool,\n }\n \n impl std::panic::UnwindSafe for GlobalStateSnapshot {}\n@@ -256,6 +257,7 @@ impl GlobalState {\n             check_fixes: Arc::clone(&self.diagnostics.check_fixes),\n             mem_docs: self.mem_docs.clone(),\n             semantic_tokens_cache: Arc::clone(&self.semantic_tokens_cache),\n+            proc_macros_loaded: !self.fetch_build_data_queue.last_op_result().0.is_empty(),\n         }\n     }\n "}, {"sha": "d9b669afbe81cd3be1baea15b57d53788b842a9c", "filename": "src/tools/rust-analyzer/crates/rust-analyzer/src/handlers.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d0588007a997da288abde34a7c861c0acb0aefbd/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fhandlers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0588007a997da288abde34a7c861c0acb0aefbd/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fhandlers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Fhandlers.rs?ref=d0588007a997da288abde34a7c861c0acb0aefbd", "patch": "@@ -1504,7 +1504,11 @@ pub(crate) fn handle_semantic_tokens_full(\n     let text = snap.analysis.file_text(file_id)?;\n     let line_index = snap.file_line_index(file_id)?;\n \n-    let highlights = snap.analysis.highlight(snap.config.highlighting_config(), file_id)?;\n+    let mut highlight_config = snap.config.highlighting_config();\n+    // Avoid flashing a bunch of unresolved references when the proc-macro servers haven't been spawned yet.\n+    highlight_config.syntactic_name_ref_highlighting = !snap.proc_macros_loaded;\n+\n+    let highlights = snap.analysis.highlight(highlight_config, file_id)?;\n     let semantic_tokens = to_proto::semantic_tokens(&text, &line_index, highlights);\n \n     // Unconditionally cache the tokens\n@@ -1523,7 +1527,11 @@ pub(crate) fn handle_semantic_tokens_full_delta(\n     let text = snap.analysis.file_text(file_id)?;\n     let line_index = snap.file_line_index(file_id)?;\n \n-    let highlights = snap.analysis.highlight(snap.config.highlighting_config(), file_id)?;\n+    let mut highlight_config = snap.config.highlighting_config();\n+    // Avoid flashing a bunch of unresolved references when the proc-macro servers haven't been spawned yet.\n+    highlight_config.syntactic_name_ref_highlighting = !snap.proc_macros_loaded;\n+\n+    let highlights = snap.analysis.highlight(highlight_config, file_id)?;\n     let semantic_tokens = to_proto::semantic_tokens(&text, &line_index, highlights);\n \n     let mut cache = snap.semantic_tokens_cache.lock();"}, {"sha": "f23bbca6387659aa24d32e97036154883bea9a33", "filename": "src/tools/rust-analyzer/crates/rust-analyzer/src/reload.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d0588007a997da288abde34a7c861c0acb0aefbd/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Freload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0588007a997da288abde34a7c861c0acb0aefbd/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Freload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Frust-analyzer%2Fsrc%2Freload.rs?ref=d0588007a997da288abde34a7c861c0acb0aefbd", "patch": "@@ -347,8 +347,8 @@ impl GlobalState {\n                             error\n                         })\n                     })\n-                    .collect();\n-            }\n+                    .collect()\n+            };\n         }\n \n         let watch = match files_config.watcher {"}, {"sha": "894795435451c8e2691fe805253987719cd80313", "filename": "src/tools/rust-analyzer/crates/syntax/rust.ungram", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d0588007a997da288abde34a7c861c0acb0aefbd/src%2Ftools%2Frust-analyzer%2Fcrates%2Fsyntax%2Frust.ungram", "raw_url": "https://github.com/rust-lang/rust/raw/d0588007a997da288abde34a7c861c0acb0aefbd/src%2Ftools%2Frust-analyzer%2Fcrates%2Fsyntax%2Frust.ungram", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fsyntax%2Frust.ungram?ref=d0588007a997da288abde34a7c861c0acb0aefbd", "patch": "@@ -343,7 +343,6 @@ Expr =\n | Literal\n | LoopExpr\n | MacroExpr\n-| MacroStmts\n | MatchExpr\n | MethodCallExpr\n | ParenExpr"}, {"sha": "449402e5f5b30af4f6e69e3b26c27aa234a2b93c", "filename": "src/tools/rust-analyzer/crates/syntax/src/ast/generated/nodes.rs", "status": "modified", "additions": 237, "deletions": 178, "changes": 415, "blob_url": "https://github.com/rust-lang/rust/blob/d0588007a997da288abde34a7c861c0acb0aefbd/src%2Ftools%2Frust-analyzer%2Fcrates%2Fsyntax%2Fsrc%2Fast%2Fgenerated%2Fnodes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0588007a997da288abde34a7c861c0acb0aefbd/src%2Ftools%2Frust-analyzer%2Fcrates%2Fsyntax%2Fsrc%2Fast%2Fgenerated%2Fnodes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fsyntax%2Fsrc%2Fast%2Fgenerated%2Fnodes.rs?ref=d0588007a997da288abde34a7c861c0acb0aefbd", "patch": "@@ -1526,7 +1526,6 @@ pub enum Expr {\n     Literal(Literal),\n     LoopExpr(LoopExpr),\n     MacroExpr(MacroExpr),\n-    MacroStmts(MacroStmts),\n     MatchExpr(MatchExpr),\n     MethodCallExpr(MethodCallExpr),\n     ParenExpr(ParenExpr),\n@@ -3169,10 +3168,7 @@ impl From<ConstArg> for GenericArg {\n }\n impl AstNode for GenericArg {\n     fn can_cast(kind: SyntaxKind) -> bool {\n-        match kind {\n-            TYPE_ARG | ASSOC_TYPE_ARG | LIFETIME_ARG | CONST_ARG => true,\n-            _ => false,\n-        }\n+        matches!(kind, TYPE_ARG | ASSOC_TYPE_ARG | LIFETIME_ARG | CONST_ARG)\n     }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         let res = match syntax.kind() {\n@@ -3237,12 +3233,23 @@ impl From<TupleType> for Type {\n }\n impl AstNode for Type {\n     fn can_cast(kind: SyntaxKind) -> bool {\n-        match kind {\n-            ARRAY_TYPE | DYN_TRAIT_TYPE | FN_PTR_TYPE | FOR_TYPE | IMPL_TRAIT_TYPE | INFER_TYPE\n-            | MACRO_TYPE | NEVER_TYPE | PAREN_TYPE | PATH_TYPE | PTR_TYPE | REF_TYPE\n-            | SLICE_TYPE | TUPLE_TYPE => true,\n-            _ => false,\n-        }\n+        matches!(\n+            kind,\n+            ARRAY_TYPE\n+                | DYN_TRAIT_TYPE\n+                | FN_PTR_TYPE\n+                | FOR_TYPE\n+                | IMPL_TRAIT_TYPE\n+                | INFER_TYPE\n+                | MACRO_TYPE\n+                | NEVER_TYPE\n+                | PAREN_TYPE\n+                | PATH_TYPE\n+                | PTR_TYPE\n+                | REF_TYPE\n+                | SLICE_TYPE\n+                | TUPLE_TYPE\n+        )\n     }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         let res = match syntax.kind() {\n@@ -3334,9 +3341,6 @@ impl From<LoopExpr> for Expr {\n impl From<MacroExpr> for Expr {\n     fn from(node: MacroExpr) -> Expr { Expr::MacroExpr(node) }\n }\n-impl From<MacroStmts> for Expr {\n-    fn from(node: MacroStmts) -> Expr { Expr::MacroStmts(node) }\n-}\n impl From<MatchExpr> for Expr {\n     fn from(node: MatchExpr) -> Expr { Expr::MatchExpr(node) }\n }\n@@ -3384,15 +3388,41 @@ impl From<UnderscoreExpr> for Expr {\n }\n impl AstNode for Expr {\n     fn can_cast(kind: SyntaxKind) -> bool {\n-        match kind {\n-            ARRAY_EXPR | AWAIT_EXPR | BIN_EXPR | BLOCK_EXPR | BOX_EXPR | BREAK_EXPR | CALL_EXPR\n-            | CAST_EXPR | CLOSURE_EXPR | CONTINUE_EXPR | FIELD_EXPR | FOR_EXPR | IF_EXPR\n-            | INDEX_EXPR | LITERAL | LOOP_EXPR | MACRO_EXPR | MACRO_STMTS | MATCH_EXPR\n-            | METHOD_CALL_EXPR | PAREN_EXPR | PATH_EXPR | PREFIX_EXPR | RANGE_EXPR\n-            | RECORD_EXPR | REF_EXPR | RETURN_EXPR | TRY_EXPR | TUPLE_EXPR | WHILE_EXPR\n-            | YIELD_EXPR | LET_EXPR | UNDERSCORE_EXPR => true,\n-            _ => false,\n-        }\n+        matches!(\n+            kind,\n+            ARRAY_EXPR\n+                | AWAIT_EXPR\n+                | BIN_EXPR\n+                | BLOCK_EXPR\n+                | BOX_EXPR\n+                | BREAK_EXPR\n+                | CALL_EXPR\n+                | CAST_EXPR\n+                | CLOSURE_EXPR\n+                | CONTINUE_EXPR\n+                | FIELD_EXPR\n+                | FOR_EXPR\n+                | IF_EXPR\n+                | INDEX_EXPR\n+                | LITERAL\n+                | LOOP_EXPR\n+                | MACRO_EXPR\n+                | MATCH_EXPR\n+                | METHOD_CALL_EXPR\n+                | PAREN_EXPR\n+                | PATH_EXPR\n+                | PREFIX_EXPR\n+                | RANGE_EXPR\n+                | RECORD_EXPR\n+                | REF_EXPR\n+                | RETURN_EXPR\n+                | TRY_EXPR\n+                | TUPLE_EXPR\n+                | WHILE_EXPR\n+                | YIELD_EXPR\n+                | LET_EXPR\n+                | UNDERSCORE_EXPR\n+        )\n     }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         let res = match syntax.kind() {\n@@ -3413,7 +3443,6 @@ impl AstNode for Expr {\n             LITERAL => Expr::Literal(Literal { syntax }),\n             LOOP_EXPR => Expr::LoopExpr(LoopExpr { syntax }),\n             MACRO_EXPR => Expr::MacroExpr(MacroExpr { syntax }),\n-            MACRO_STMTS => Expr::MacroStmts(MacroStmts { syntax }),\n             MATCH_EXPR => Expr::MatchExpr(MatchExpr { syntax }),\n             METHOD_CALL_EXPR => Expr::MethodCallExpr(MethodCallExpr { syntax }),\n             PAREN_EXPR => Expr::ParenExpr(ParenExpr { syntax }),\n@@ -3452,7 +3481,6 @@ impl AstNode for Expr {\n             Expr::Literal(it) => &it.syntax,\n             Expr::LoopExpr(it) => &it.syntax,\n             Expr::MacroExpr(it) => &it.syntax,\n-            Expr::MacroStmts(it) => &it.syntax,\n             Expr::MatchExpr(it) => &it.syntax,\n             Expr::MethodCallExpr(it) => &it.syntax,\n             Expr::ParenExpr(it) => &it.syntax,\n@@ -3521,11 +3549,25 @@ impl From<Use> for Item {\n }\n impl AstNode for Item {\n     fn can_cast(kind: SyntaxKind) -> bool {\n-        match kind {\n-            CONST | ENUM | EXTERN_BLOCK | EXTERN_CRATE | FN | IMPL | MACRO_CALL | MACRO_RULES\n-            | MACRO_DEF | MODULE | STATIC | STRUCT | TRAIT | TYPE_ALIAS | UNION | USE => true,\n-            _ => false,\n-        }\n+        matches!(\n+            kind,\n+            CONST\n+                | ENUM\n+                | EXTERN_BLOCK\n+                | EXTERN_CRATE\n+                | FN\n+                | IMPL\n+                | MACRO_CALL\n+                | MACRO_RULES\n+                | MACRO_DEF\n+                | MODULE\n+                | STATIC\n+                | STRUCT\n+                | TRAIT\n+                | TYPE_ALIAS\n+                | UNION\n+                | USE\n+        )\n     }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         let res = match syntax.kind() {\n@@ -3629,12 +3671,25 @@ impl From<ConstBlockPat> for Pat {\n }\n impl AstNode for Pat {\n     fn can_cast(kind: SyntaxKind) -> bool {\n-        match kind {\n-            IDENT_PAT | BOX_PAT | REST_PAT | LITERAL_PAT | MACRO_PAT | OR_PAT | PAREN_PAT\n-            | PATH_PAT | WILDCARD_PAT | RANGE_PAT | RECORD_PAT | REF_PAT | SLICE_PAT\n-            | TUPLE_PAT | TUPLE_STRUCT_PAT | CONST_BLOCK_PAT => true,\n-            _ => false,\n-        }\n+        matches!(\n+            kind,\n+            IDENT_PAT\n+                | BOX_PAT\n+                | REST_PAT\n+                | LITERAL_PAT\n+                | MACRO_PAT\n+                | OR_PAT\n+                | PAREN_PAT\n+                | PATH_PAT\n+                | WILDCARD_PAT\n+                | RANGE_PAT\n+                | RECORD_PAT\n+                | REF_PAT\n+                | SLICE_PAT\n+                | TUPLE_PAT\n+                | TUPLE_STRUCT_PAT\n+                | CONST_BLOCK_PAT\n+        )\n     }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         let res = match syntax.kind() {\n@@ -3686,12 +3741,7 @@ impl From<TupleFieldList> for FieldList {\n     fn from(node: TupleFieldList) -> FieldList { FieldList::TupleFieldList(node) }\n }\n impl AstNode for FieldList {\n-    fn can_cast(kind: SyntaxKind) -> bool {\n-        match kind {\n-            RECORD_FIELD_LIST | TUPLE_FIELD_LIST => true,\n-            _ => false,\n-        }\n-    }\n+    fn can_cast(kind: SyntaxKind) -> bool { matches!(kind, RECORD_FIELD_LIST | TUPLE_FIELD_LIST) }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         let res = match syntax.kind() {\n             RECORD_FIELD_LIST => FieldList::RecordFieldList(RecordFieldList { syntax }),\n@@ -3717,12 +3767,7 @@ impl From<Union> for Adt {\n     fn from(node: Union) -> Adt { Adt::Union(node) }\n }\n impl AstNode for Adt {\n-    fn can_cast(kind: SyntaxKind) -> bool {\n-        match kind {\n-            ENUM | STRUCT | UNION => true,\n-            _ => false,\n-        }\n-    }\n+    fn can_cast(kind: SyntaxKind) -> bool { matches!(kind, ENUM | STRUCT | UNION) }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         let res = match syntax.kind() {\n             ENUM => Adt::Enum(Enum { syntax }),\n@@ -3753,12 +3798,7 @@ impl From<TypeAlias> for AssocItem {\n     fn from(node: TypeAlias) -> AssocItem { AssocItem::TypeAlias(node) }\n }\n impl AstNode for AssocItem {\n-    fn can_cast(kind: SyntaxKind) -> bool {\n-        match kind {\n-            CONST | FN | MACRO_CALL | TYPE_ALIAS => true,\n-            _ => false,\n-        }\n-    }\n+    fn can_cast(kind: SyntaxKind) -> bool { matches!(kind, CONST | FN | MACRO_CALL | TYPE_ALIAS) }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         let res = match syntax.kind() {\n             CONST => AssocItem::Const(Const { syntax }),\n@@ -3791,12 +3831,7 @@ impl From<TypeAlias> for ExternItem {\n     fn from(node: TypeAlias) -> ExternItem { ExternItem::TypeAlias(node) }\n }\n impl AstNode for ExternItem {\n-    fn can_cast(kind: SyntaxKind) -> bool {\n-        match kind {\n-            FN | MACRO_CALL | STATIC | TYPE_ALIAS => true,\n-            _ => false,\n-        }\n-    }\n+    fn can_cast(kind: SyntaxKind) -> bool { matches!(kind, FN | MACRO_CALL | STATIC | TYPE_ALIAS) }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         let res = match syntax.kind() {\n             FN => ExternItem::Fn(Fn { syntax }),\n@@ -3827,10 +3862,7 @@ impl From<TypeParam> for GenericParam {\n }\n impl AstNode for GenericParam {\n     fn can_cast(kind: SyntaxKind) -> bool {\n-        match kind {\n-            CONST_PARAM | LIFETIME_PARAM | TYPE_PARAM => true,\n-            _ => false,\n-        }\n+        matches!(kind, CONST_PARAM | LIFETIME_PARAM | TYPE_PARAM)\n     }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         let res = match syntax.kind() {\n@@ -3856,12 +3888,7 @@ impl AnyHasArgList {\n     }\n }\n impl AstNode for AnyHasArgList {\n-    fn can_cast(kind: SyntaxKind) -> bool {\n-        match kind {\n-            CALL_EXPR | METHOD_CALL_EXPR => true,\n-            _ => false,\n-        }\n-    }\n+    fn can_cast(kind: SyntaxKind) -> bool { matches!(kind, CALL_EXPR | METHOD_CALL_EXPR) }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         Self::can_cast(syntax.kind()).then(|| AnyHasArgList { syntax })\n     }\n@@ -3875,76 +3902,76 @@ impl AnyHasAttrs {\n }\n impl AstNode for AnyHasAttrs {\n     fn can_cast(kind: SyntaxKind) -> bool {\n-        match kind {\n+        matches!(\n+            kind,\n             MACRO_CALL\n-            | SOURCE_FILE\n-            | CONST\n-            | ENUM\n-            | EXTERN_BLOCK\n-            | EXTERN_CRATE\n-            | FN\n-            | IMPL\n-            | MACRO_RULES\n-            | MACRO_DEF\n-            | MODULE\n-            | STATIC\n-            | STRUCT\n-            | TRAIT\n-            | TYPE_ALIAS\n-            | UNION\n-            | USE\n-            | ITEM_LIST\n-            | BLOCK_EXPR\n-            | SELF_PARAM\n-            | PARAM\n-            | RECORD_FIELD\n-            | TUPLE_FIELD\n-            | VARIANT\n-            | ASSOC_ITEM_LIST\n-            | EXTERN_ITEM_LIST\n-            | CONST_PARAM\n-            | LIFETIME_PARAM\n-            | TYPE_PARAM\n-            | LET_STMT\n-            | ARRAY_EXPR\n-            | AWAIT_EXPR\n-            | BIN_EXPR\n-            | BOX_EXPR\n-            | BREAK_EXPR\n-            | CALL_EXPR\n-            | CAST_EXPR\n-            | CLOSURE_EXPR\n-            | CONTINUE_EXPR\n-            | FIELD_EXPR\n-            | FOR_EXPR\n-            | IF_EXPR\n-            | INDEX_EXPR\n-            | LITERAL\n-            | LOOP_EXPR\n-            | MATCH_EXPR\n-            | METHOD_CALL_EXPR\n-            | PAREN_EXPR\n-            | PATH_EXPR\n-            | PREFIX_EXPR\n-            | RANGE_EXPR\n-            | REF_EXPR\n-            | RETURN_EXPR\n-            | TRY_EXPR\n-            | TUPLE_EXPR\n-            | WHILE_EXPR\n-            | YIELD_EXPR\n-            | LET_EXPR\n-            | UNDERSCORE_EXPR\n-            | STMT_LIST\n-            | RECORD_EXPR_FIELD_LIST\n-            | RECORD_EXPR_FIELD\n-            | MATCH_ARM_LIST\n-            | MATCH_ARM\n-            | IDENT_PAT\n-            | REST_PAT\n-            | RECORD_PAT_FIELD => true,\n-            _ => false,\n-        }\n+                | SOURCE_FILE\n+                | CONST\n+                | ENUM\n+                | EXTERN_BLOCK\n+                | EXTERN_CRATE\n+                | FN\n+                | IMPL\n+                | MACRO_RULES\n+                | MACRO_DEF\n+                | MODULE\n+                | STATIC\n+                | STRUCT\n+                | TRAIT\n+                | TYPE_ALIAS\n+                | UNION\n+                | USE\n+                | ITEM_LIST\n+                | BLOCK_EXPR\n+                | SELF_PARAM\n+                | PARAM\n+                | RECORD_FIELD\n+                | TUPLE_FIELD\n+                | VARIANT\n+                | ASSOC_ITEM_LIST\n+                | EXTERN_ITEM_LIST\n+                | CONST_PARAM\n+                | LIFETIME_PARAM\n+                | TYPE_PARAM\n+                | LET_STMT\n+                | ARRAY_EXPR\n+                | AWAIT_EXPR\n+                | BIN_EXPR\n+                | BOX_EXPR\n+                | BREAK_EXPR\n+                | CALL_EXPR\n+                | CAST_EXPR\n+                | CLOSURE_EXPR\n+                | CONTINUE_EXPR\n+                | FIELD_EXPR\n+                | FOR_EXPR\n+                | IF_EXPR\n+                | INDEX_EXPR\n+                | LITERAL\n+                | LOOP_EXPR\n+                | MATCH_EXPR\n+                | METHOD_CALL_EXPR\n+                | PAREN_EXPR\n+                | PATH_EXPR\n+                | PREFIX_EXPR\n+                | RANGE_EXPR\n+                | REF_EXPR\n+                | RETURN_EXPR\n+                | TRY_EXPR\n+                | TUPLE_EXPR\n+                | WHILE_EXPR\n+                | YIELD_EXPR\n+                | LET_EXPR\n+                | UNDERSCORE_EXPR\n+                | STMT_LIST\n+                | RECORD_EXPR_FIELD_LIST\n+                | RECORD_EXPR_FIELD\n+                | MATCH_ARM_LIST\n+                | MATCH_ARM\n+                | IDENT_PAT\n+                | REST_PAT\n+                | RECORD_PAT_FIELD\n+        )\n     }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         Self::can_cast(syntax.kind()).then(|| AnyHasAttrs { syntax })\n@@ -3959,12 +3986,29 @@ impl AnyHasDocComments {\n }\n impl AstNode for AnyHasDocComments {\n     fn can_cast(kind: SyntaxKind) -> bool {\n-        match kind {\n-            MACRO_CALL | SOURCE_FILE | CONST | ENUM | EXTERN_BLOCK | EXTERN_CRATE | FN | IMPL\n-            | MACRO_RULES | MACRO_DEF | MODULE | STATIC | STRUCT | TRAIT | TYPE_ALIAS | UNION\n-            | USE | RECORD_FIELD | TUPLE_FIELD | VARIANT => true,\n-            _ => false,\n-        }\n+        matches!(\n+            kind,\n+            MACRO_CALL\n+                | SOURCE_FILE\n+                | CONST\n+                | ENUM\n+                | EXTERN_BLOCK\n+                | EXTERN_CRATE\n+                | FN\n+                | IMPL\n+                | MACRO_RULES\n+                | MACRO_DEF\n+                | MODULE\n+                | STATIC\n+                | STRUCT\n+                | TRAIT\n+                | TYPE_ALIAS\n+                | UNION\n+                | USE\n+                | RECORD_FIELD\n+                | TUPLE_FIELD\n+                | VARIANT\n+        )\n     }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         Self::can_cast(syntax.kind()).then(|| AnyHasDocComments { syntax })\n@@ -3979,10 +4023,7 @@ impl AnyHasGenericParams {\n }\n impl AstNode for AnyHasGenericParams {\n     fn can_cast(kind: SyntaxKind) -> bool {\n-        match kind {\n-            ENUM | FN | IMPL | STRUCT | TRAIT | TYPE_ALIAS | UNION => true,\n-            _ => false,\n-        }\n+        matches!(kind, ENUM | FN | IMPL | STRUCT | TRAIT | TYPE_ALIAS | UNION)\n     }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         Self::can_cast(syntax.kind()).then(|| AnyHasGenericParams { syntax })\n@@ -3996,12 +4037,7 @@ impl AnyHasLoopBody {\n     }\n }\n impl AstNode for AnyHasLoopBody {\n-    fn can_cast(kind: SyntaxKind) -> bool {\n-        match kind {\n-            FOR_EXPR | LOOP_EXPR | WHILE_EXPR => true,\n-            _ => false,\n-        }\n-    }\n+    fn can_cast(kind: SyntaxKind) -> bool { matches!(kind, FOR_EXPR | LOOP_EXPR | WHILE_EXPR) }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         Self::can_cast(syntax.kind()).then(|| AnyHasLoopBody { syntax })\n     }\n@@ -4014,12 +4050,7 @@ impl AnyHasModuleItem {\n     }\n }\n impl AstNode for AnyHasModuleItem {\n-    fn can_cast(kind: SyntaxKind) -> bool {\n-        match kind {\n-            MACRO_ITEMS | SOURCE_FILE | ITEM_LIST => true,\n-            _ => false,\n-        }\n-    }\n+    fn can_cast(kind: SyntaxKind) -> bool { matches!(kind, MACRO_ITEMS | SOURCE_FILE | ITEM_LIST) }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         Self::can_cast(syntax.kind()).then(|| AnyHasModuleItem { syntax })\n     }\n@@ -4033,12 +4064,27 @@ impl AnyHasName {\n }\n impl AstNode for AnyHasName {\n     fn can_cast(kind: SyntaxKind) -> bool {\n-        match kind {\n-            CONST | ENUM | FN | MACRO_RULES | MACRO_DEF | MODULE | STATIC | STRUCT | TRAIT\n-            | TYPE_ALIAS | UNION | RENAME | SELF_PARAM | RECORD_FIELD | VARIANT | CONST_PARAM\n-            | TYPE_PARAM | IDENT_PAT => true,\n-            _ => false,\n-        }\n+        matches!(\n+            kind,\n+            CONST\n+                | ENUM\n+                | FN\n+                | MACRO_RULES\n+                | MACRO_DEF\n+                | MODULE\n+                | STATIC\n+                | STRUCT\n+                | TRAIT\n+                | TYPE_ALIAS\n+                | UNION\n+                | RENAME\n+                | SELF_PARAM\n+                | RECORD_FIELD\n+                | VARIANT\n+                | CONST_PARAM\n+                | TYPE_PARAM\n+                | IDENT_PAT\n+        )\n     }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         Self::can_cast(syntax.kind()).then(|| AnyHasName { syntax })\n@@ -4053,10 +4099,10 @@ impl AnyHasTypeBounds {\n }\n impl AstNode for AnyHasTypeBounds {\n     fn can_cast(kind: SyntaxKind) -> bool {\n-        match kind {\n-            ASSOC_TYPE_ARG | TRAIT | TYPE_ALIAS | LIFETIME_PARAM | TYPE_PARAM | WHERE_PRED => true,\n-            _ => false,\n-        }\n+        matches!(\n+            kind,\n+            ASSOC_TYPE_ARG | TRAIT | TYPE_ALIAS | LIFETIME_PARAM | TYPE_PARAM | WHERE_PRED\n+        )\n     }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         Self::can_cast(syntax.kind()).then(|| AnyHasTypeBounds { syntax })\n@@ -4071,13 +4117,26 @@ impl AnyHasVisibility {\n }\n impl AstNode for AnyHasVisibility {\n     fn can_cast(kind: SyntaxKind) -> bool {\n-        match kind {\n-            CONST | ENUM | EXTERN_CRATE | FN | IMPL | MACRO_RULES | MACRO_DEF | MODULE | STATIC\n-            | STRUCT | TRAIT | TYPE_ALIAS | UNION | USE | RECORD_FIELD | TUPLE_FIELD | VARIANT => {\n-                true\n-            }\n-            _ => false,\n-        }\n+        matches!(\n+            kind,\n+            CONST\n+                | ENUM\n+                | EXTERN_CRATE\n+                | FN\n+                | IMPL\n+                | MACRO_RULES\n+                | MACRO_DEF\n+                | MODULE\n+                | STATIC\n+                | STRUCT\n+                | TRAIT\n+                | TYPE_ALIAS\n+                | UNION\n+                | USE\n+                | RECORD_FIELD\n+                | TUPLE_FIELD\n+                | VARIANT\n+        )\n     }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n         Self::can_cast(syntax.kind()).then(|| AnyHasVisibility { syntax })"}, {"sha": "83f8bbac5880bfd5fa542f03e90af2110039d169", "filename": "src/tools/rust-analyzer/crates/syntax/src/ast/make.rs", "status": "modified", "additions": 132, "deletions": 131, "changes": 263, "blob_url": "https://github.com/rust-lang/rust/blob/d0588007a997da288abde34a7c861c0acb0aefbd/src%2Ftools%2Frust-analyzer%2Fcrates%2Fsyntax%2Fsrc%2Fast%2Fmake.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0588007a997da288abde34a7c861c0acb0aefbd/src%2Ftools%2Frust-analyzer%2Fcrates%2Fsyntax%2Fsrc%2Fast%2Fmake.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fsyntax%2Fsrc%2Fast%2Fmake.rs?ref=d0588007a997da288abde34a7c861c0acb0aefbd", "patch": "@@ -25,7 +25,7 @@ pub mod ext {\n         return from_text(&name.text());\n \n         fn from_text(text: &str) -> ast::IdentPat {\n-            ast_from_text(&format!(\"fn f({}: ())\", text))\n+            ast_from_text(&format!(\"fn f({text}: ())\"))\n         }\n     }\n     pub fn ident_path(ident: &str) -> ast::Path {\n@@ -60,10 +60,10 @@ pub mod ext {\n         expr_from_text(\"todo!()\")\n     }\n     pub fn expr_ty_default(ty: &ast::Type) -> ast::Expr {\n-        expr_from_text(&format!(\"{}::default()\", ty))\n+        expr_from_text(&format!(\"{ty}::default()\"))\n     }\n     pub fn expr_ty_new(ty: &ast::Type) -> ast::Expr {\n-        expr_from_text(&format!(\"{}::new()\", ty))\n+        expr_from_text(&format!(\"{ty}::new()\"))\n     }\n \n     pub fn zero_number() -> ast::Expr {\n@@ -92,18 +92,20 @@ pub mod ext {\n         ty_path(ident_path(\"bool\"))\n     }\n     pub fn ty_option(t: ast::Type) -> ast::Type {\n-        ty_from_text(&format!(\"Option<{}>\", t))\n+        ty_from_text(&format!(\"Option<{t}>\"))\n     }\n     pub fn ty_result(t: ast::Type, e: ast::Type) -> ast::Type {\n-        ty_from_text(&format!(\"Result<{}, {}>\", t, e))\n+        ty_from_text(&format!(\"Result<{t}, {e}>\"))\n     }\n }\n \n-pub fn name(text: &str) -> ast::Name {\n-    ast_from_text(&format!(\"mod {}{};\", raw_ident_esc(text), text))\n+pub fn name(name: &str) -> ast::Name {\n+    let raw_escape = raw_ident_esc(name);\n+    ast_from_text(&format!(\"mod {raw_escape}{name};\"))\n }\n-pub fn name_ref(text: &str) -> ast::NameRef {\n-    ast_from_text(&format!(\"fn f() {{ {}{}; }}\", raw_ident_esc(text), text))\n+pub fn name_ref(name_ref: &str) -> ast::NameRef {\n+    let raw_escape = raw_ident_esc(name_ref);\n+    ast_from_text(&format!(\"fn f() {{ {raw_escape}{name_ref}; }}\"))\n }\n fn raw_ident_esc(ident: &str) -> &'static str {\n     let is_keyword = parser::SyntaxKind::from_keyword(ident).is_some();\n@@ -118,10 +120,10 @@ pub fn lifetime(text: &str) -> ast::Lifetime {\n     let mut text = text;\n     let tmp;\n     if never!(!text.starts_with('\\'')) {\n-        tmp = format!(\"'{}\", text);\n+        tmp = format!(\"'{text}\");\n         text = &tmp;\n     }\n-    ast_from_text(&format!(\"fn f<{}>() {{ }}\", text))\n+    ast_from_text(&format!(\"fn f<{text}>() {{ }}\"))\n }\n \n // FIXME: replace stringly-typed constructor with a family of typed ctors, a-la\n@@ -142,16 +144,16 @@ pub fn ty_tuple(types: impl IntoIterator<Item = ast::Type>) -> ast::Type {\n         contents.push(',');\n     }\n \n-    ty_from_text(&format!(\"({})\", contents))\n+    ty_from_text(&format!(\"({contents})\"))\n }\n pub fn ty_ref(target: ast::Type, exclusive: bool) -> ast::Type {\n-    ty_from_text(&if exclusive { format!(\"&mut {}\", target) } else { format!(\"&{}\", target) })\n+    ty_from_text(&if exclusive { format!(\"&mut {target}\") } else { format!(\"&{target}\") })\n }\n pub fn ty_path(path: ast::Path) -> ast::Type {\n     ty_from_text(&path.to_string())\n }\n fn ty_from_text(text: &str) -> ast::Type {\n-    ast_from_text(&format!(\"type _T = {};\", text))\n+    ast_from_text(&format!(\"type _T = {text};\"))\n }\n \n pub fn assoc_item_list() -> ast::AssocItemList {\n@@ -171,7 +173,7 @@ pub fn impl_(\n         Some(params) => params.to_string(),\n         None => String::new(),\n     };\n-    ast_from_text(&format!(\"impl{} {}{} {{}}\", params, ty, ty_params))\n+    ast_from_text(&format!(\"impl{params} {ty}{ty_params} {{}}\"))\n }\n \n pub fn impl_trait(\n@@ -180,21 +182,21 @@ pub fn impl_trait(\n     ty_params: Option<ast::GenericParamList>,\n ) -> ast::Impl {\n     let ty_params = ty_params.map_or_else(String::new, |params| params.to_string());\n-    ast_from_text(&format!(\"impl{2} {} for {}{2} {{}}\", trait_, ty, ty_params))\n+    ast_from_text(&format!(\"impl{ty_params} {trait_} for {ty}{ty_params} {{}}\"))\n }\n \n pub(crate) fn generic_arg_list() -> ast::GenericArgList {\n     ast_from_text(\"const S: T<> = ();\")\n }\n \n pub fn path_segment(name_ref: ast::NameRef) -> ast::PathSegment {\n-    ast_from_text(&format!(\"type __ = {};\", name_ref))\n+    ast_from_text(&format!(\"type __ = {name_ref};\"))\n }\n \n pub fn path_segment_ty(type_ref: ast::Type, trait_ref: Option<ast::PathType>) -> ast::PathSegment {\n     let text = match trait_ref {\n-        Some(trait_ref) => format!(\"fn f(x: <{} as {}>) {{}}\", type_ref, trait_ref),\n-        None => format!(\"fn f(x: <{}>) {{}}\", type_ref),\n+        Some(trait_ref) => format!(\"fn f(x: <{type_ref} as {trait_ref}>) {{}}\"),\n+        None => format!(\"fn f(x: <{type_ref}>) {{}}\"),\n     };\n     ast_from_text(&text)\n }\n@@ -212,15 +214,15 @@ pub fn path_segment_crate() -> ast::PathSegment {\n }\n \n pub fn path_unqualified(segment: ast::PathSegment) -> ast::Path {\n-    ast_from_text(&format!(\"type __ = {};\", segment))\n+    ast_from_text(&format!(\"type __ = {segment};\"))\n }\n \n pub fn path_qualified(qual: ast::Path, segment: ast::PathSegment) -> ast::Path {\n-    ast_from_text(&format!(\"{}::{}\", qual, segment))\n+    ast_from_text(&format!(\"{qual}::{segment}\"))\n }\n // FIXME: path concatenation operation doesn't make sense as AST op.\n pub fn path_concat(first: ast::Path, second: ast::Path) -> ast::Path {\n-    ast_from_text(&format!(\"type __ = {}::{};\", first, second))\n+    ast_from_text(&format!(\"type __ = {first}::{second};\"))\n }\n \n pub fn path_from_segments(\n@@ -229,20 +231,20 @@ pub fn path_from_segments(\n ) -> ast::Path {\n     let segments = segments.into_iter().map(|it| it.syntax().clone()).join(\"::\");\n     ast_from_text(&if is_abs {\n-        format!(\"fn f(x: ::{}) {{}}\", segments)\n+        format!(\"fn f(x: ::{segments}) {{}}\")\n     } else {\n-        format!(\"fn f(x: {}) {{}}\", segments)\n+        format!(\"fn f(x: {segments}) {{}}\")\n     })\n }\n \n pub fn join_paths(paths: impl IntoIterator<Item = ast::Path>) -> ast::Path {\n     let paths = paths.into_iter().map(|it| it.syntax().clone()).join(\"::\");\n-    ast_from_text(&format!(\"type __ = {};\", paths))\n+    ast_from_text(&format!(\"type __ = {paths};\"))\n }\n \n // FIXME: should not be pub\n pub fn path_from_text(text: &str) -> ast::Path {\n-    ast_from_text(&format!(\"fn main() {{ let test = {}; }}\", text))\n+    ast_from_text(&format!(\"fn main() {{ let test = {text}; }}\"))\n }\n \n pub fn use_tree_glob() -> ast::UseTree {\n@@ -257,50 +259,50 @@ pub fn use_tree(\n     let mut buf = \"use \".to_string();\n     buf += &path.syntax().to_string();\n     if let Some(use_tree_list) = use_tree_list {\n-        format_to!(buf, \"::{}\", use_tree_list);\n+        format_to!(buf, \"::{use_tree_list}\");\n     }\n     if add_star {\n         buf += \"::*\";\n     }\n \n     if let Some(alias) = alias {\n-        format_to!(buf, \" {}\", alias);\n+        format_to!(buf, \" {alias}\");\n     }\n     ast_from_text(&buf)\n }\n \n pub fn use_tree_list(use_trees: impl IntoIterator<Item = ast::UseTree>) -> ast::UseTreeList {\n     let use_trees = use_trees.into_iter().map(|it| it.syntax().clone()).join(\", \");\n-    ast_from_text(&format!(\"use {{{}}};\", use_trees))\n+    ast_from_text(&format!(\"use {{{use_trees}}};\"))\n }\n \n pub fn use_(visibility: Option<ast::Visibility>, use_tree: ast::UseTree) -> ast::Use {\n     let visibility = match visibility {\n         None => String::new(),\n-        Some(it) => format!(\"{} \", it),\n+        Some(it) => format!(\"{it} \"),\n     };\n-    ast_from_text(&format!(\"{}use {};\", visibility, use_tree))\n+    ast_from_text(&format!(\"{visibility}use {use_tree};\"))\n }\n \n pub fn record_expr(path: ast::Path, fields: ast::RecordExprFieldList) -> ast::RecordExpr {\n-    ast_from_text(&format!(\"fn f() {{ {} {} }}\", path, fields))\n+    ast_from_text(&format!(\"fn f() {{ {path} {fields} }}\"))\n }\n \n pub fn record_expr_field_list(\n     fields: impl IntoIterator<Item = ast::RecordExprField>,\n ) -> ast::RecordExprFieldList {\n     let fields = fields.into_iter().join(\", \");\n-    ast_from_text(&format!(\"fn f() {{ S {{ {} }} }}\", fields))\n+    ast_from_text(&format!(\"fn f() {{ S {{ {fields} }} }}\"))\n }\n \n pub fn record_expr_field(name: ast::NameRef, expr: Option<ast::Expr>) -> ast::RecordExprField {\n     return match expr {\n-        Some(expr) => from_text(&format!(\"{}: {}\", name, expr)),\n+        Some(expr) => from_text(&format!(\"{name}: {expr}\")),\n         None => from_text(&name.to_string()),\n     };\n \n     fn from_text(text: &str) -> ast::RecordExprField {\n-        ast_from_text(&format!(\"fn f() {{ S {{ {}, }} }}\", text))\n+        ast_from_text(&format!(\"fn f() {{ S {{ {text}, }} }}\"))\n     }\n }\n \n@@ -311,9 +313,9 @@ pub fn record_field(\n ) -> ast::RecordField {\n     let visibility = match visibility {\n         None => String::new(),\n-        Some(it) => format!(\"{} \", it),\n+        Some(it) => format!(\"{it} \"),\n     };\n-    ast_from_text(&format!(\"struct S {{ {}{}: {}, }}\", visibility, name, ty))\n+    ast_from_text(&format!(\"struct S {{ {visibility}{name}: {ty}, }}\"))\n }\n \n // TODO\n@@ -323,13 +325,13 @@ pub fn block_expr(\n ) -> ast::BlockExpr {\n     let mut buf = \"{\\n\".to_string();\n     for stmt in stmts.into_iter() {\n-        format_to!(buf, \"    {}\\n\", stmt);\n+        format_to!(buf, \"    {stmt}\\n\");\n     }\n     if let Some(tail_expr) = tail_expr {\n-        format_to!(buf, \"    {}\\n\", tail_expr);\n+        format_to!(buf, \"    {tail_expr}\\n\");\n     }\n     buf += \"}\";\n-    ast_from_text(&format!(\"fn f() {}\", buf))\n+    ast_from_text(&format!(\"fn f() {buf}\"))\n }\n \n /// Ideally this function wouldn't exist since it involves manual indenting.\n@@ -343,26 +345,26 @@ pub fn hacky_block_expr_with_comments(\n     let mut buf = \"{\\n\".to_string();\n     for node_or_token in elements.into_iter() {\n         match node_or_token {\n-            rowan::NodeOrToken::Node(n) => format_to!(buf, \"    {}\\n\", n),\n+            rowan::NodeOrToken::Node(n) => format_to!(buf, \"    {n}\\n\"),\n             rowan::NodeOrToken::Token(t) if t.kind() == SyntaxKind::COMMENT => {\n-                format_to!(buf, \"    {}\\n\", t)\n+                format_to!(buf, \"    {t}\\n\")\n             }\n             _ => (),\n         }\n     }\n     if let Some(tail_expr) = tail_expr {\n-        format_to!(buf, \"    {}\\n\", tail_expr);\n+        format_to!(buf, \"    {tail_expr}\\n\");\n     }\n     buf += \"}\";\n-    ast_from_text(&format!(\"fn f() {}\", buf))\n+    ast_from_text(&format!(\"fn f() {buf}\"))\n }\n \n pub fn expr_unit() -> ast::Expr {\n     expr_from_text(\"()\")\n }\n pub fn expr_literal(text: &str) -> ast::Literal {\n     assert_eq!(text.trim(), text);\n-    ast_from_text(&format!(\"fn f() {{ let _ = {}; }}\", text))\n+    ast_from_text(&format!(\"fn f() {{ let _ = {text}; }}\"))\n }\n \n pub fn expr_empty_block() -> ast::Expr {\n@@ -373,108 +375,109 @@ pub fn expr_path(path: ast::Path) -> ast::Expr {\n }\n pub fn expr_continue(label: Option<ast::Lifetime>) -> ast::Expr {\n     match label {\n-        Some(label) => expr_from_text(&format!(\"continue {}\", label)),\n+        Some(label) => expr_from_text(&format!(\"continue {label}\")),\n         None => expr_from_text(\"continue\"),\n     }\n }\n // Consider `op: SyntaxKind` instead for nicer syntax at the call-site?\n pub fn expr_bin_op(lhs: ast::Expr, op: ast::BinaryOp, rhs: ast::Expr) -> ast::Expr {\n-    expr_from_text(&format!(\"{} {} {}\", lhs, op, rhs))\n+    expr_from_text(&format!(\"{lhs} {op} {rhs}\"))\n }\n pub fn expr_break(label: Option<ast::Lifetime>, expr: Option<ast::Expr>) -> ast::Expr {\n     let mut s = String::from(\"break\");\n \n     if let Some(label) = label {\n-        format_to!(s, \" {}\", label);\n+        format_to!(s, \" {label}\");\n     }\n \n     if let Some(expr) = expr {\n-        format_to!(s, \" {}\", expr);\n+        format_to!(s, \" {expr}\");\n     }\n \n     expr_from_text(&s)\n }\n pub fn expr_return(expr: Option<ast::Expr>) -> ast::Expr {\n     match expr {\n-        Some(expr) => expr_from_text(&format!(\"return {}\", expr)),\n+        Some(expr) => expr_from_text(&format!(\"return {expr}\")),\n         None => expr_from_text(\"return\"),\n     }\n }\n pub fn expr_try(expr: ast::Expr) -> ast::Expr {\n-    expr_from_text(&format!(\"{}?\", expr))\n+    expr_from_text(&format!(\"{expr}?\"))\n }\n pub fn expr_await(expr: ast::Expr) -> ast::Expr {\n-    expr_from_text(&format!(\"{}.await\", expr))\n+    expr_from_text(&format!(\"{expr}.await\"))\n }\n pub fn expr_match(expr: ast::Expr, match_arm_list: ast::MatchArmList) -> ast::Expr {\n-    expr_from_text(&format!(\"match {} {}\", expr, match_arm_list))\n+    expr_from_text(&format!(\"match {expr} {match_arm_list}\"))\n }\n pub fn expr_if(\n     condition: ast::Expr,\n     then_branch: ast::BlockExpr,\n     else_branch: Option<ast::ElseBranch>,\n ) -> ast::Expr {\n     let else_branch = match else_branch {\n-        Some(ast::ElseBranch::Block(block)) => format!(\"else {}\", block),\n-        Some(ast::ElseBranch::IfExpr(if_expr)) => format!(\"else {}\", if_expr),\n+        Some(ast::ElseBranch::Block(block)) => format!(\"else {block}\"),\n+        Some(ast::ElseBranch::IfExpr(if_expr)) => format!(\"else {if_expr}\"),\n         None => String::new(),\n     };\n-    expr_from_text(&format!(\"if {} {} {}\", condition, then_branch, else_branch))\n+    expr_from_text(&format!(\"if {condition} {then_branch} {else_branch}\"))\n }\n pub fn expr_for_loop(pat: ast::Pat, expr: ast::Expr, block: ast::BlockExpr) -> ast::Expr {\n-    expr_from_text(&format!(\"for {} in {} {}\", pat, expr, block))\n+    expr_from_text(&format!(\"for {pat} in {expr} {block}\"))\n }\n \n pub fn expr_loop(block: ast::BlockExpr) -> ast::Expr {\n-    expr_from_text(&format!(\"loop {}\", block))\n+    expr_from_text(&format!(\"loop {block}\"))\n }\n \n pub fn expr_prefix(op: SyntaxKind, expr: ast::Expr) -> ast::Expr {\n     let token = token(op);\n-    expr_from_text(&format!(\"{}{}\", token, expr))\n+    expr_from_text(&format!(\"{token}{expr}\"))\n }\n pub fn expr_call(f: ast::Expr, arg_list: ast::ArgList) -> ast::Expr {\n-    expr_from_text(&format!(\"{}{}\", f, arg_list))\n+    expr_from_text(&format!(\"{f}{arg_list}\"))\n }\n pub fn expr_method_call(\n     receiver: ast::Expr,\n     method: ast::NameRef,\n     arg_list: ast::ArgList,\n ) -> ast::Expr {\n-    expr_from_text(&format!(\"{}.{}{}\", receiver, method, arg_list))\n+    expr_from_text(&format!(\"{receiver}.{method}{arg_list}\"))\n }\n pub fn expr_macro_call(f: ast::Expr, arg_list: ast::ArgList) -> ast::Expr {\n-    expr_from_text(&format!(\"{}!{}\", f, arg_list))\n+    expr_from_text(&format!(\"{f}!{arg_list}\"))\n }\n pub fn expr_ref(expr: ast::Expr, exclusive: bool) -> ast::Expr {\n-    expr_from_text(&if exclusive { format!(\"&mut {}\", expr) } else { format!(\"&{}\", expr) })\n+    expr_from_text(&if exclusive { format!(\"&mut {expr}\") } else { format!(\"&{expr}\") })\n }\n pub fn expr_closure(pats: impl IntoIterator<Item = ast::Param>, expr: ast::Expr) -> ast::Expr {\n     let params = pats.into_iter().join(\", \");\n-    expr_from_text(&format!(\"|{}| {}\", params, expr))\n+    expr_from_text(&format!(\"|{params}| {expr}\"))\n }\n pub fn expr_field(receiver: ast::Expr, field: &str) -> ast::Expr {\n-    expr_from_text(&format!(\"{}.{}\", receiver, field))\n+    expr_from_text(&format!(\"{receiver}.{field}\"))\n }\n pub fn expr_paren(expr: ast::Expr) -> ast::Expr {\n-    expr_from_text(&format!(\"({})\", expr))\n+    expr_from_text(&format!(\"({expr})\"))\n }\n pub fn expr_tuple(elements: impl IntoIterator<Item = ast::Expr>) -> ast::Expr {\n     let expr = elements.into_iter().format(\", \");\n-    expr_from_text(&format!(\"({})\", expr))\n+    expr_from_text(&format!(\"({expr})\"))\n }\n pub fn expr_assignment(lhs: ast::Expr, rhs: ast::Expr) -> ast::Expr {\n-    expr_from_text(&format!(\"{} = {}\", lhs, rhs))\n+    expr_from_text(&format!(\"{lhs} = {rhs}\"))\n }\n fn expr_from_text(text: &str) -> ast::Expr {\n-    ast_from_text(&format!(\"const C: () = {};\", text))\n+    ast_from_text(&format!(\"const C: () = {text};\"))\n }\n pub fn expr_let(pattern: ast::Pat, expr: ast::Expr) -> ast::LetExpr {\n-    ast_from_text(&format!(\"const _: () = while let {} = {} {{}};\", pattern, expr))\n+    ast_from_text(&format!(\"const _: () = while let {pattern} = {expr} {{}};\"))\n }\n \n pub fn arg_list(args: impl IntoIterator<Item = ast::Expr>) -> ast::ArgList {\n-    ast_from_text(&format!(\"fn main() {{ ()({}) }}\", args.into_iter().format(\", \")))\n+    let args = args.into_iter().format(\", \");\n+    ast_from_text(&format!(\"fn main() {{ ()({args}) }}\"))\n }\n \n pub fn ident_pat(ref_: bool, mut_: bool, name: ast::Name) -> ast::IdentPat {\n@@ -485,7 +488,7 @@ pub fn ident_pat(ref_: bool, mut_: bool, name: ast::Name) -> ast::IdentPat {\n     if mut_ {\n         s.push_str(\"mut \");\n     }\n-    format_to!(s, \"{}\", name);\n+    format_to!(s, \"{name}\");\n     s.push_str(\": ())\");\n     ast_from_text(&s)\n }\n@@ -494,15 +497,15 @@ pub fn wildcard_pat() -> ast::WildcardPat {\n     return from_text(\"_\");\n \n     fn from_text(text: &str) -> ast::WildcardPat {\n-        ast_from_text(&format!(\"fn f({}: ())\", text))\n+        ast_from_text(&format!(\"fn f({text}: ())\"))\n     }\n }\n \n pub fn literal_pat(lit: &str) -> ast::LiteralPat {\n     return from_text(lit);\n \n     fn from_text(text: &str) -> ast::LiteralPat {\n-        ast_from_text(&format!(\"fn f() {{ match x {{ {} => {{}} }} }}\", text))\n+        ast_from_text(&format!(\"fn f() {{ match x {{ {text} => {{}} }} }}\"))\n     }\n }\n \n@@ -515,10 +518,10 @@ pub fn tuple_pat(pats: impl IntoIterator<Item = ast::Pat>) -> ast::TuplePat {\n     if count == 1 {\n         pats_str.push(',');\n     }\n-    return from_text(&format!(\"({})\", pats_str));\n+    return from_text(&format!(\"({pats_str})\"));\n \n     fn from_text(text: &str) -> ast::TuplePat {\n-        ast_from_text(&format!(\"fn f({}: ())\", text))\n+        ast_from_text(&format!(\"fn f({text}: ())\"))\n     }\n }\n \n@@ -527,46 +530,46 @@ pub fn tuple_struct_pat(\n     pats: impl IntoIterator<Item = ast::Pat>,\n ) -> ast::TupleStructPat {\n     let pats_str = pats.into_iter().join(\", \");\n-    return from_text(&format!(\"{}({})\", path, pats_str));\n+    return from_text(&format!(\"{path}({pats_str})\"));\n \n     fn from_text(text: &str) -> ast::TupleStructPat {\n-        ast_from_text(&format!(\"fn f({}: ())\", text))\n+        ast_from_text(&format!(\"fn f({text}: ())\"))\n     }\n }\n \n pub fn record_pat(path: ast::Path, pats: impl IntoIterator<Item = ast::Pat>) -> ast::RecordPat {\n     let pats_str = pats.into_iter().join(\", \");\n-    return from_text(&format!(\"{} {{ {} }}\", path, pats_str));\n+    return from_text(&format!(\"{path} {{ {pats_str} }}\"));\n \n     fn from_text(text: &str) -> ast::RecordPat {\n-        ast_from_text(&format!(\"fn f({}: ())\", text))\n+        ast_from_text(&format!(\"fn f({text}: ())\"))\n     }\n }\n \n pub fn record_pat_with_fields(path: ast::Path, fields: ast::RecordPatFieldList) -> ast::RecordPat {\n-    ast_from_text(&format!(\"fn f({} {}: ()))\", path, fields))\n+    ast_from_text(&format!(\"fn f({path} {fields}: ()))\"))\n }\n \n pub fn record_pat_field_list(\n     fields: impl IntoIterator<Item = ast::RecordPatField>,\n ) -> ast::RecordPatFieldList {\n     let fields = fields.into_iter().join(\", \");\n-    ast_from_text(&format!(\"fn f(S {{ {} }}: ()))\", fields))\n+    ast_from_text(&format!(\"fn f(S {{ {fields} }}: ()))\"))\n }\n \n pub fn record_pat_field(name_ref: ast::NameRef, pat: ast::Pat) -> ast::RecordPatField {\n-    ast_from_text(&format!(\"fn f(S {{ {}: {} }}: ()))\", name_ref, pat))\n+    ast_from_text(&format!(\"fn f(S {{ {name_ref}: {pat} }}: ()))\"))\n }\n \n pub fn record_pat_field_shorthand(name_ref: ast::NameRef) -> ast::RecordPatField {\n-    ast_from_text(&format!(\"fn f(S {{ {} }}: ()))\", name_ref))\n+    ast_from_text(&format!(\"fn f(S {{ {name_ref} }}: ()))\"))\n }\n \n /// Returns a `BindPat` if the path has just one segment, a `PathPat` otherwise.\n pub fn path_pat(path: ast::Path) -> ast::Pat {\n     return from_text(&path.to_string());\n     fn from_text(text: &str) -> ast::Pat {\n-        ast_from_text(&format!(\"fn f({}: ())\", text))\n+        ast_from_text(&format!(\"fn f({text}: ())\"))\n     }\n }\n \n@@ -577,12 +580,12 @@ pub fn match_arm(\n ) -> ast::MatchArm {\n     let pats_str = pats.into_iter().join(\" | \");\n     return match guard {\n-        Some(guard) => from_text(&format!(\"{} if {} => {}\", pats_str, guard, expr)),\n-        None => from_text(&format!(\"{} => {}\", pats_str, expr)),\n+        Some(guard) => from_text(&format!(\"{pats_str} if {guard} => {expr}\")),\n+        None => from_text(&format!(\"{pats_str} => {expr}\")),\n     };\n \n     fn from_text(text: &str) -> ast::MatchArm {\n-        ast_from_text(&format!(\"fn f() {{ match () {{{}}} }}\", text))\n+        ast_from_text(&format!(\"fn f() {{ match () {{{text}}} }}\"))\n     }\n }\n \n@@ -592,10 +595,10 @@ pub fn match_arm_with_guard(\n     expr: ast::Expr,\n ) -> ast::MatchArm {\n     let pats_str = pats.into_iter().join(\" | \");\n-    return from_text(&format!(\"{} if {} => {}\", pats_str, guard, expr));\n+    return from_text(&format!(\"{pats_str} if {guard} => {expr}\"));\n \n     fn from_text(text: &str) -> ast::MatchArm {\n-        ast_from_text(&format!(\"fn f() {{ match () {{{}}} }}\", text))\n+        ast_from_text(&format!(\"fn f() {{ match () {{{text}}} }}\"))\n     }\n }\n \n@@ -605,13 +608,14 @@ pub fn match_arm_list(arms: impl IntoIterator<Item = ast::MatchArm>) -> ast::Mat\n         .map(|arm| {\n             let needs_comma = arm.expr().map_or(true, |it| !it.is_block_like());\n             let comma = if needs_comma { \",\" } else { \"\" };\n-            format!(\"    {}{}\\n\", arm.syntax(), comma)\n+            let arm = arm.syntax();\n+            format!(\"    {arm}{comma}\\n\")\n         })\n         .collect::<String>();\n     return from_text(&arms_str);\n \n     fn from_text(text: &str) -> ast::MatchArmList {\n-        ast_from_text(&format!(\"fn f() {{ match () {{\\n{}}} }}\", text))\n+        ast_from_text(&format!(\"fn f() {{ match () {{\\n{text}}} }}\"))\n     }\n }\n \n@@ -620,10 +624,10 @@ pub fn where_pred(\n     bounds: impl IntoIterator<Item = ast::TypeBound>,\n ) -> ast::WherePred {\n     let bounds = bounds.into_iter().join(\" + \");\n-    return from_text(&format!(\"{}: {}\", path, bounds));\n+    return from_text(&format!(\"{path}: {bounds}\"));\n \n     fn from_text(text: &str) -> ast::WherePred {\n-        ast_from_text(&format!(\"fn f() where {} {{ }}\", text))\n+        ast_from_text(&format!(\"fn f() where {text} {{ }}\"))\n     }\n }\n \n@@ -632,7 +636,7 @@ pub fn where_clause(preds: impl IntoIterator<Item = ast::WherePred>) -> ast::Whe\n     return from_text(preds.as_str());\n \n     fn from_text(text: &str) -> ast::WhereClause {\n-        ast_from_text(&format!(\"fn f() where {} {{ }}\", text))\n+        ast_from_text(&format!(\"fn f() where {text} {{ }}\"))\n     }\n }\n \n@@ -642,19 +646,19 @@ pub fn let_stmt(\n     initializer: Option<ast::Expr>,\n ) -> ast::LetStmt {\n     let mut text = String::new();\n-    format_to!(text, \"let {}\", pattern);\n+    format_to!(text, \"let {pattern}\");\n     if let Some(ty) = ty {\n-        format_to!(text, \": {}\", ty);\n+        format_to!(text, \": {ty}\");\n     }\n     match initializer {\n-        Some(it) => format_to!(text, \" = {};\", it),\n+        Some(it) => format_to!(text, \" = {it};\"),\n         None => format_to!(text, \";\"),\n     };\n-    ast_from_text(&format!(\"fn f() {{ {} }}\", text))\n+    ast_from_text(&format!(\"fn f() {{ {text} }}\"))\n }\n pub fn expr_stmt(expr: ast::Expr) -> ast::ExprStmt {\n     let semi = if expr.is_block_like() { \"\" } else { \";\" };\n-    ast_from_text(&format!(\"fn f() {{ {}{} (); }}\", expr, semi))\n+    ast_from_text(&format!(\"fn f() {{ {expr}{semi} (); }}\"))\n }\n \n pub fn item_const(\n@@ -665,21 +669,21 @@ pub fn item_const(\n ) -> ast::Const {\n     let visibility = match visibility {\n         None => String::new(),\n-        Some(it) => format!(\"{} \", it),\n+        Some(it) => format!(\"{it} \"),\n     };\n-    ast_from_text(&format!(\"{} const {}: {} = {};\", visibility, name, ty, expr))\n+    ast_from_text(&format!(\"{visibility} const {name}: {ty} = {expr};\"))\n }\n \n pub fn param(pat: ast::Pat, ty: ast::Type) -> ast::Param {\n-    ast_from_text(&format!(\"fn f({}: {}) {{ }}\", pat, ty))\n+    ast_from_text(&format!(\"fn f({pat}: {ty}) {{ }}\"))\n }\n \n pub fn self_param() -> ast::SelfParam {\n     ast_from_text(\"fn f(&self) { }\")\n }\n \n pub fn ret_type(ty: ast::Type) -> ast::RetType {\n-    ast_from_text(&format!(\"fn f() -> {} {{ }}\", ty))\n+    ast_from_text(&format!(\"fn f() -> {ty} {{ }}\"))\n }\n \n pub fn param_list(\n@@ -688,30 +692,30 @@ pub fn param_list(\n ) -> ast::ParamList {\n     let args = pats.into_iter().join(\", \");\n     let list = match self_param {\n-        Some(self_param) if args.is_empty() => format!(\"fn f({}) {{ }}\", self_param),\n-        Some(self_param) => format!(\"fn f({}, {}) {{ }}\", self_param, args),\n-        None => format!(\"fn f({}) {{ }}\", args),\n+        Some(self_param) if args.is_empty() => format!(\"fn f({self_param}) {{ }}\"),\n+        Some(self_param) => format!(\"fn f({self_param}, {args}) {{ }}\"),\n+        None => format!(\"fn f({args}) {{ }}\"),\n     };\n     ast_from_text(&list)\n }\n \n pub fn type_param(name: ast::Name, ty: Option<ast::TypeBoundList>) -> ast::TypeParam {\n     let bound = match ty {\n-        Some(it) => format!(\": {}\", it),\n+        Some(it) => format!(\": {it}\"),\n         None => String::new(),\n     };\n-    ast_from_text(&format!(\"fn f<{}{}>() {{ }}\", name, bound))\n+    ast_from_text(&format!(\"fn f<{name}{bound}>() {{ }}\"))\n }\n \n pub fn lifetime_param(lifetime: ast::Lifetime) -> ast::LifetimeParam {\n-    ast_from_text(&format!(\"fn f<{}>() {{ }}\", lifetime))\n+    ast_from_text(&format!(\"fn f<{lifetime}>() {{ }}\"))\n }\n \n pub fn generic_param_list(\n     pats: impl IntoIterator<Item = ast::GenericParam>,\n ) -> ast::GenericParamList {\n     let args = pats.into_iter().join(\", \");\n-    ast_from_text(&format!(\"fn f<{}>() {{ }}\", args))\n+    ast_from_text(&format!(\"fn f<{args}>() {{ }}\"))\n }\n \n pub fn visibility_pub_crate() -> ast::Visibility {\n@@ -724,33 +728,33 @@ pub fn visibility_pub() -> ast::Visibility {\n \n pub fn tuple_field_list(fields: impl IntoIterator<Item = ast::TupleField>) -> ast::TupleFieldList {\n     let fields = fields.into_iter().join(\", \");\n-    ast_from_text(&format!(\"struct f({});\", fields))\n+    ast_from_text(&format!(\"struct f({fields});\"))\n }\n \n pub fn record_field_list(\n     fields: impl IntoIterator<Item = ast::RecordField>,\n ) -> ast::RecordFieldList {\n     let fields = fields.into_iter().join(\", \");\n-    ast_from_text(&format!(\"struct f {{ {} }}\", fields))\n+    ast_from_text(&format!(\"struct f {{ {fields} }}\"))\n }\n \n pub fn tuple_field(visibility: Option<ast::Visibility>, ty: ast::Type) -> ast::TupleField {\n     let visibility = match visibility {\n         None => String::new(),\n-        Some(it) => format!(\"{} \", it),\n+        Some(it) => format!(\"{it} \"),\n     };\n-    ast_from_text(&format!(\"struct f({}{});\", visibility, ty))\n+    ast_from_text(&format!(\"struct f({visibility}{ty});\"))\n }\n \n pub fn variant(name: ast::Name, field_list: Option<ast::FieldList>) -> ast::Variant {\n     let field_list = match field_list {\n         None => String::new(),\n         Some(it) => match it {\n-            ast::FieldList::RecordFieldList(record) => format!(\" {}\", record),\n-            ast::FieldList::TupleFieldList(tuple) => format!(\"{}\", tuple),\n+            ast::FieldList::RecordFieldList(record) => format!(\" {record}\"),\n+            ast::FieldList::TupleFieldList(tuple) => format!(\"{tuple}\"),\n         },\n     };\n-    ast_from_text(&format!(\"enum f {{ {}{} }}\", name, field_list))\n+    ast_from_text(&format!(\"enum f {{ {name}{field_list} }}\"))\n }\n \n pub fn fn_(\n@@ -763,23 +767,22 @@ pub fn fn_(\n     is_async: bool,\n ) -> ast::Fn {\n     let type_params = match type_params {\n-        Some(type_params) => format!(\"{}\", type_params),\n+        Some(type_params) => format!(\"{type_params}\"),\n         None => \"\".into(),\n     };\n     let ret_type = match ret_type {\n-        Some(ret_type) => format!(\"{} \", ret_type),\n+        Some(ret_type) => format!(\"{ret_type} \"),\n         None => \"\".into(),\n     };\n     let visibility = match visibility {\n         None => String::new(),\n-        Some(it) => format!(\"{} \", it),\n+        Some(it) => format!(\"{it} \"),\n     };\n \n     let async_literal = if is_async { \"async \" } else { \"\" };\n \n     ast_from_text(&format!(\n-        \"{}{}fn {}{}{} {}{}\",\n-        visibility, async_literal, fn_name, type_params, params, ret_type, body\n+        \"{visibility}{async_literal}fn {fn_name}{type_params}{params} {ret_type}{body}\",\n     ))\n }\n \n@@ -793,13 +796,10 @@ pub fn struct_(\n     let type_params = generic_param_list.map_or_else(String::new, |it| it.to_string());\n     let visibility = match visibility {\n         None => String::new(),\n-        Some(it) => format!(\"{} \", it),\n+        Some(it) => format!(\"{it} \"),\n     };\n \n-    ast_from_text(&format!(\n-        \"{}struct {}{}{}{}\",\n-        visibility, strukt_name, type_params, field_list, semicolon\n-    ))\n+    ast_from_text(&format!(\"{visibility}struct {strukt_name}{type_params}{field_list}{semicolon}\",))\n }\n \n #[track_caller]\n@@ -808,7 +808,8 @@ fn ast_from_text<N: AstNode>(text: &str) -> N {\n     let node = match parse.tree().syntax().descendants().find_map(N::cast) {\n         Some(it) => it,\n         None => {\n-            panic!(\"Failed to make ast node `{}` from text {}\", std::any::type_name::<N>(), text)\n+            let node = std::any::type_name::<N>();\n+            panic!(\"Failed to make ast node `{node}` from text {text}\")\n         }\n     };\n     let node = node.clone_subtree();\n@@ -824,7 +825,7 @@ pub fn token(kind: SyntaxKind) -> SyntaxToken {\n         .descendants_with_tokens()\n         .filter_map(|it| it.into_token())\n         .find(|it| it.kind() == kind)\n-        .unwrap_or_else(|| panic!(\"unhandled token: {:?}\", kind))\n+        .unwrap_or_else(|| panic!(\"unhandled token: {kind:?}\"))\n }\n \n pub mod tokens {\n@@ -863,7 +864,7 @@ pub mod tokens {\n \n     pub fn literal(text: &str) -> SyntaxToken {\n         assert_eq!(text.trim(), text);\n-        let lit: ast::Literal = super::ast_from_text(&format!(\"fn f() {{ let _ = {}; }}\", text));\n+        let lit: ast::Literal = super::ast_from_text(&format!(\"fn f() {{ let _ = {text}; }}\"));\n         lit.syntax().first_child_or_token().unwrap().into_token().unwrap()\n     }\n "}, {"sha": "ba72e64425b23c095063a54e3aa7cf1edef2e618", "filename": "src/tools/rust-analyzer/crates/syntax/src/ast/token_ext.rs", "status": "modified", "additions": 19, "deletions": 2, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/d0588007a997da288abde34a7c861c0acb0aefbd/src%2Ftools%2Frust-analyzer%2Fcrates%2Fsyntax%2Fsrc%2Fast%2Ftoken_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0588007a997da288abde34a7c861c0acb0aefbd/src%2Ftools%2Frust-analyzer%2Fcrates%2Fsyntax%2Fsrc%2Fast%2Ftoken_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fsyntax%2Fsrc%2Fast%2Ftoken_ext.rs?ref=d0588007a997da288abde34a7c861c0acb0aefbd", "patch": "@@ -322,7 +322,7 @@ impl ast::IntNumber {\n \n     pub fn float_value(&self) -> Option<f64> {\n         let (_, text, _) = self.split_into_parts();\n-        text.parse::<f64>().ok()\n+        text.replace('_', \"\").parse::<f64>().ok()\n     }\n }\n \n@@ -361,7 +361,7 @@ impl ast::FloatNumber {\n \n     pub fn value(&self) -> Option<f64> {\n         let (text, _) = self.split_into_parts();\n-        text.parse::<f64>().ok()\n+        text.replace('_', \"\").parse::<f64>().ok()\n     }\n }\n \n@@ -397,6 +397,15 @@ mod tests {\n         assert_eq!(IntNumber { syntax: make::tokens::literal(lit) }.suffix(), expected.into());\n     }\n \n+    fn check_float_value(lit: &str, expected: impl Into<Option<f64>> + Copy) {\n+        assert_eq!(FloatNumber { syntax: make::tokens::literal(lit) }.value(), expected.into());\n+        assert_eq!(IntNumber { syntax: make::tokens::literal(lit) }.float_value(), expected.into());\n+    }\n+\n+    fn check_int_value(lit: &str, expected: impl Into<Option<u128>>) {\n+        assert_eq!(IntNumber { syntax: make::tokens::literal(lit) }.value(), expected.into());\n+    }\n+\n     #[test]\n     fn test_float_number_suffix() {\n         check_float_suffix(\"123.0\", None);\n@@ -437,6 +446,14 @@ mod tests {\n         check_string_value(r\"\\nfoobar\", \"\\nfoobar\");\n         check_string_value(r\"C:\\\\Windows\\\\System32\\\\\", \"C:\\\\Windows\\\\System32\\\\\");\n     }\n+\n+    #[test]\n+    fn test_value_underscores() {\n+        check_float_value(\"3.141592653589793_f64\", 3.141592653589793_f64);\n+        check_float_value(\"1__0.__0__f32\", 10.0);\n+        check_int_value(\"0b__1_0_\", 2);\n+        check_int_value(\"1_1_1_1_1_1\", 111111);\n+    }\n }\n \n impl ast::Char {"}, {"sha": "70b54843dbaab5d6f328d18546e8cac979fd25f6", "filename": "src/tools/rust-analyzer/crates/syntax/src/tests/sourcegen_ast.rs", "status": "modified", "additions": 7, "deletions": 20, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/d0588007a997da288abde34a7c861c0acb0aefbd/src%2Ftools%2Frust-analyzer%2Fcrates%2Fsyntax%2Fsrc%2Ftests%2Fsourcegen_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0588007a997da288abde34a7c861c0acb0aefbd/src%2Ftools%2Frust-analyzer%2Fcrates%2Fsyntax%2Fsrc%2Ftests%2Fsourcegen_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Fcrates%2Fsyntax%2Fsrc%2Ftests%2Fsourcegen_ast.rs?ref=d0588007a997da288abde34a7c861c0acb0aefbd", "patch": "@@ -169,10 +169,7 @@ fn generate_nodes(kinds: KindsSrc<'_>, grammar: &AstSrc) -> String {\n                 quote! {\n                     impl AstNode for #name {\n                         fn can_cast(kind: SyntaxKind) -> bool {\n-                            match kind {\n-                                #(#kinds)|* => true,\n-                                _ => false,\n-                            }\n+                            matches!(kind, #(#kinds)|*)\n                         }\n                         fn cast(syntax: SyntaxNode) -> Option<Self> {\n                             let res = match syntax.kind() {\n@@ -253,10 +250,7 @@ fn generate_nodes(kinds: KindsSrc<'_>, grammar: &AstSrc) -> String {\n                     }\n                     impl AstNode for #name {\n                         fn can_cast(kind: SyntaxKind) -> bool {\n-                            match kind {\n-                                #(#kinds)|* => true,\n-                                _ => false,\n-                            }\n+                            matches!(kind, #(#kinds)|*)\n                         }\n                         fn cast(syntax: SyntaxNode) -> Option<Self> {\n                             Self::can_cast(syntax.kind()).then(|| #name { syntax })\n@@ -410,24 +404,17 @@ fn generate_syntax_kinds(grammar: KindsSrc<'_>) -> String {\n \n         impl SyntaxKind {\n             pub fn is_keyword(self) -> bool {\n-                match self {\n-                    #(#all_keywords)|* => true,\n-                    _ => false,\n-                }\n+                matches!(self, #(#all_keywords)|*)\n             }\n \n             pub fn is_punct(self) -> bool {\n-                match self {\n-                    #(#punctuation)|* => true,\n-                    _ => false,\n-                }\n+\n+                matches!(self, #(#punctuation)|*)\n+\n             }\n \n             pub fn is_literal(self) -> bool {\n-                match self {\n-                    #(#literals)|* => true,\n-                    _ => false,\n-                }\n+                matches!(self, #(#literals)|*)\n             }\n \n             pub fn from_keyword(ident: &str) -> Option<SyntaxKind> {"}, {"sha": "ccaaf3991769ec737833da7eb0bec769d36a501a", "filename": "src/tools/rust-analyzer/lib/la-arena/src/lib.rs", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/d0588007a997da288abde34a7c861c0acb0aefbd/src%2Ftools%2Frust-analyzer%2Flib%2Fla-arena%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0588007a997da288abde34a7c861c0acb0aefbd/src%2Ftools%2Frust-analyzer%2Flib%2Fla-arena%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer%2Flib%2Fla-arena%2Fsrc%2Flib.rs?ref=d0588007a997da288abde34a7c861c0acb0aefbd", "patch": "@@ -322,6 +322,43 @@ impl<T> Arena<T> {\n             .map(|(idx, value)| (Idx::from_raw(RawIdx(idx as u32)), value))\n     }\n \n+    /// Returns an iterator over the arena\u2019s values.\n+    ///\n+    /// ```\n+    /// let mut arena = la_arena::Arena::new();\n+    /// let idx1 = arena.alloc(20);\n+    /// let idx2 = arena.alloc(40);\n+    /// let idx3 = arena.alloc(60);\n+    ///\n+    /// let mut iterator = arena.values();\n+    /// assert_eq!(iterator.next(), Some(&20));\n+    /// assert_eq!(iterator.next(), Some(&40));\n+    /// assert_eq!(iterator.next(), Some(&60));\n+    /// ```\n+    pub fn values(&mut self) -> impl Iterator<Item = &T> + ExactSizeIterator + DoubleEndedIterator {\n+        self.data.iter()\n+    }\n+\n+    /// Returns an iterator over the arena\u2019s mutable values.\n+    ///\n+    /// ```\n+    /// let mut arena = la_arena::Arena::new();\n+    /// let idx1 = arena.alloc(20);\n+    ///\n+    /// assert_eq!(arena[idx1], 20);\n+    ///\n+    /// let mut iterator = arena.values_mut();\n+    /// *iterator.next().unwrap() = 10;\n+    /// drop(iterator);\n+    ///\n+    /// assert_eq!(arena[idx1], 10);\n+    /// ```\n+    pub fn values_mut(\n+        &mut self,\n+    ) -> impl Iterator<Item = &mut T> + ExactSizeIterator + DoubleEndedIterator {\n+        self.data.iter_mut()\n+    }\n+\n     /// Reallocates the arena to make it take up as little space as possible.\n     pub fn shrink_to_fit(&mut self) {\n         self.data.shrink_to_fit();"}]}