{"sha": "c0a0664d120609fa37aa950a11d5e6c0df176770", "node_id": "C_kwDOAAsO6NoAKGMwYTA2NjRkMTIwNjA5ZmEzN2FhOTUwYTExZDVlNmMwZGYxNzY3NzA", "commit": {"author": {"name": "hkalbasi", "email": "hamidrezakalbasi@protonmail.com", "date": "2023-02-18T22:17:44Z"}, "committer": {"name": "hkalbasi", "email": "hamidrezakalbasi@protonmail.com", "date": "2023-03-06T17:39:08Z"}, "message": "Support \"or patterns\" MIR lowering", "tree": {"sha": "ee0bd191f45e57fe0bbab38b63891aa57642e9be", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ee0bd191f45e57fe0bbab38b63891aa57642e9be"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c0a0664d120609fa37aa950a11d5e6c0df176770", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c0a0664d120609fa37aa950a11d5e6c0df176770", "html_url": "https://github.com/rust-lang/rust/commit/c0a0664d120609fa37aa950a11d5e6c0df176770", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c0a0664d120609fa37aa950a11d5e6c0df176770/comments", "author": {"login": "HKalbasi", "id": 45197576, "node_id": "MDQ6VXNlcjQ1MTk3NTc2", "avatar_url": "https://avatars.githubusercontent.com/u/45197576?v=4", "gravatar_id": "", "url": "https://api.github.com/users/HKalbasi", "html_url": "https://github.com/HKalbasi", "followers_url": "https://api.github.com/users/HKalbasi/followers", "following_url": "https://api.github.com/users/HKalbasi/following{/other_user}", "gists_url": "https://api.github.com/users/HKalbasi/gists{/gist_id}", "starred_url": "https://api.github.com/users/HKalbasi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/HKalbasi/subscriptions", "organizations_url": "https://api.github.com/users/HKalbasi/orgs", "repos_url": "https://api.github.com/users/HKalbasi/repos", "events_url": "https://api.github.com/users/HKalbasi/events{/privacy}", "received_events_url": "https://api.github.com/users/HKalbasi/received_events", "type": "User", "site_admin": false}, "committer": {"login": "HKalbasi", "id": 45197576, "node_id": "MDQ6VXNlcjQ1MTk3NTc2", "avatar_url": "https://avatars.githubusercontent.com/u/45197576?v=4", "gravatar_id": "", "url": "https://api.github.com/users/HKalbasi", "html_url": "https://github.com/HKalbasi", "followers_url": "https://api.github.com/users/HKalbasi/followers", "following_url": "https://api.github.com/users/HKalbasi/following{/other_user}", "gists_url": "https://api.github.com/users/HKalbasi/gists{/gist_id}", "starred_url": "https://api.github.com/users/HKalbasi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/HKalbasi/subscriptions", "organizations_url": "https://api.github.com/users/HKalbasi/orgs", "repos_url": "https://api.github.com/users/HKalbasi/repos", "events_url": "https://api.github.com/users/HKalbasi/events{/privacy}", "received_events_url": "https://api.github.com/users/HKalbasi/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "61ad6a96ad1019930294e754e72f627978e85787", "url": "https://api.github.com/repos/rust-lang/rust/commits/61ad6a96ad1019930294e754e72f627978e85787", "html_url": "https://github.com/rust-lang/rust/commit/61ad6a96ad1019930294e754e72f627978e85787"}], "stats": {"total": 137, "additions": 122, "deletions": 15}, "files": [{"sha": "f05688aa55b4e7bebadb47f7ecc22937895c86cb", "filename": "crates/hir-ty/src/consteval/tests.rs", "status": "modified", "additions": 40, "deletions": 2, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/c0a0664d120609fa37aa950a11d5e6c0df176770/crates%2Fhir-ty%2Fsrc%2Fconsteval%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0a0664d120609fa37aa950a11d5e6c0df176770/crates%2Fhir-ty%2Fsrc%2Fconsteval%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fconsteval%2Ftests.rs?ref=c0a0664d120609fa37aa950a11d5e6c0df176770", "patch": "@@ -559,11 +559,11 @@ fn function_param_patterns() {\n     check_number(\n         r#\"\n     const fn f(c @ (a, b): &(u8, u8)) -> u8 {\n-        *a + *b + (*c).1\n+        *a + *b + c.0 + (*c).1\n     }\n     const GOAL: u8 = f(&(2, 3));\n         \"#,\n-        8,\n+        10,\n     );\n     check_number(\n         r#\"\n@@ -641,6 +641,44 @@ fn options() {\n     );\n }\n \n+#[test]\n+fn or_pattern() {\n+    check_number(\n+        r#\"\n+    const GOAL: u8 = {\n+        let (a | a) = 2;\n+        a\n+    };\n+        \"#,\n+        2,\n+    );\n+    check_number(\n+        r#\"\n+    //- minicore: option\n+    const fn f(x: Option<i32>) -> i32 {\n+        let (Some(a) | Some(a)) = x else { return 2; };\n+        a\n+    }\n+    const GOAL: i32 = f(Some(10)) + f(None);\n+        \"#,\n+        12,\n+    );\n+    check_number(\n+        r#\"\n+    //- minicore: option\n+    const fn f(x: Option<i32>, y: Option<i32>) -> i32 {\n+        match (x, y) {\n+            (Some(x), Some(y)) => x * y,\n+            (Some(a), _) | (_, Some(a)) => a,\n+            _ => 10,\n+        }\n+    }\n+    const GOAL: i32 = f(Some(10), Some(20)) + f(Some(30), None) + f(None, Some(40)) + f(None, None);\n+        \"#,\n+        280,\n+    );\n+}\n+\n #[test]\n fn array_and_index() {\n     check_number("}, {"sha": "1bcdd3a5057009c2bc9e3301e3e6fe3fc749beb4", "filename": "crates/hir-ty/src/mir/lower.rs", "status": "modified", "additions": 82, "deletions": 13, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/c0a0664d120609fa37aa950a11d5e6c0df176770/crates%2Fhir-ty%2Fsrc%2Fmir%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c0a0664d120609fa37aa950a11d5e6c0df176770/crates%2Fhir-ty%2Fsrc%2Fmir%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fmir%2Flower.rs?ref=c0a0664d120609fa37aa950a11d5e6c0df176770", "patch": "@@ -155,12 +155,7 @@ impl MirLowerCtx<'_> {\n         if let Some(p) = self.lower_expr_as_place(expr_id) {\n             return Ok((p, prev_block));\n         }\n-        let mut ty = self.expr_ty(expr_id);\n-        if let Some(x) = self.infer.expr_adjustments.get(&expr_id) {\n-            if let Some(x) = x.last() {\n-                ty = x.target.clone();\n-            }\n-        }\n+        let ty = self.expr_ty_after_adjustments(expr_id);\n         let place = self.temp(ty)?;\n         Ok((place.into(), self.lower_expr_to_place(expr_id, place.into(), prev_block)?))\n     }\n@@ -323,7 +318,7 @@ impl MirLowerCtx<'_> {\n                     current,\n                     None,\n                     cond_place,\n-                    self.expr_ty(*expr),\n+                    self.expr_ty_after_adjustments(*expr),\n                     *pat,\n                     BindingAnnotation::Unannotated,\n                 )?;\n@@ -339,7 +334,53 @@ impl MirLowerCtx<'_> {\n                 self.lower_block_to_place(None, statements, current, *tail, place)\n             }\n             Expr::Block { id: _, statements, tail, label } => {\n-                self.lower_block_to_place(*label, statements, current, *tail, place)\n+                if label.is_some() {\n+                    not_supported!(\"block with label\");\n+                }\n+                for statement in statements.iter() {\n+                    match statement {\n+                        hir_def::expr::Statement::Let {\n+                            pat,\n+                            initializer,\n+                            else_branch,\n+                            type_ref: _,\n+                        } => match initializer {\n+                            Some(expr_id) => {\n+                                let else_block;\n+                                let init_place;\n+                                (init_place, current) =\n+                                    self.lower_expr_to_some_place(*expr_id, current)?;\n+                                (current, else_block) = self.pattern_match(\n+                                    current,\n+                                    None,\n+                                    init_place,\n+                                    self.expr_ty_after_adjustments(*expr_id),\n+                                    *pat,\n+                                    BindingAnnotation::Unannotated,\n+                                )?;\n+                                match (else_block, else_branch) {\n+                                    (None, _) => (),\n+                                    (Some(else_block), None) => {\n+                                        self.set_terminator(else_block, Terminator::Unreachable);\n+                                    }\n+                                    (Some(else_block), Some(else_branch)) => {\n+                                        let (_, b) = self\n+                                            .lower_expr_to_some_place(*else_branch, else_block)?;\n+                                        self.set_terminator(b, Terminator::Unreachable);\n+                                    }\n+                                }\n+                            }\n+                            None => continue,\n+                        },\n+                        hir_def::expr::Statement::Expr { expr, has_semi: _ } => {\n+                            (_, current) = self.lower_expr_to_some_place(*expr, current)?;\n+                        }\n+                    }\n+                }\n+                match tail {\n+                    Some(tail) => self.lower_expr_to_place(*tail, place, current),\n+                    None => Ok(current),\n+                }\n             }\n             Expr::Loop { body, label } => self.lower_loop(current, *label, |this, begin, _| {\n                 let (_, block) = this.lower_expr_to_some_place(*body, begin)?;\n@@ -364,7 +405,7 @@ impl MirLowerCtx<'_> {\n             }\n             Expr::For { .. } => not_supported!(\"for loop\"),\n             Expr::Call { callee, args, .. } => {\n-                let callee_ty = self.expr_ty(*callee);\n+                let callee_ty = self.expr_ty_after_adjustments(*callee);\n                 match &callee_ty.data(Interner).kind {\n                     chalk_ir::TyKind::FnDef(..) => {\n                         let func = Operand::from_bytes(vec![], callee_ty.clone());\n@@ -414,7 +455,7 @@ impl MirLowerCtx<'_> {\n             }\n             Expr::Match { expr, arms } => {\n                 let (cond_place, mut current) = self.lower_expr_to_some_place(*expr, current)?;\n-                let cond_ty = self.expr_ty(*expr);\n+                let cond_ty = self.expr_ty_after_adjustments(*expr);\n                 let end = self.new_basic_block();\n                 for MatchArm { pat, guard, expr } in arms.iter() {\n                     if guard.is_some() {\n@@ -524,7 +565,7 @@ impl MirLowerCtx<'_> {\n             }\n             Expr::Field { expr, name } => {\n                 let (mut current_place, current) = self.lower_expr_to_some_place(*expr, current)?;\n-                if let TyKind::Tuple(..) = self.expr_ty(*expr).kind(Interner) {\n+                if let TyKind::Tuple(..) = self.expr_ty_after_adjustments(*expr).kind(Interner) {\n                     let index = name\n                         .as_tuple_index()\n                         .ok_or(MirLowerError::TypeError(\"named field on tuple\"))?;\n@@ -623,7 +664,7 @@ impl MirLowerCtx<'_> {\n             Expr::Index { base, index } => {\n                 let mut p_base;\n                 (p_base, current) = self.lower_expr_to_some_place(*base, current)?;\n-                let l_index = self.temp(self.expr_ty(*index))?;\n+                let l_index = self.temp(self.expr_ty_after_adjustments(*index))?;\n                 current = self.lower_expr_to_place(*index, l_index.into(), current)?;\n                 p_base.projection.push(ProjectionElem::Index(l_index));\n                 self.push_assignment(current, place, Operand::Copy(p_base).into());\n@@ -878,6 +919,16 @@ impl MirLowerCtx<'_> {\n         self.infer[e].clone()\n     }\n \n+    fn expr_ty_after_adjustments(&self, e: ExprId) -> Ty {\n+        let mut ty = None;\n+        if let Some(x) = self.infer.expr_adjustments.get(&e) {\n+            if let Some(x) = x.last() {\n+                ty = Some(x.target.clone());\n+            }\n+        }\n+        ty.unwrap_or_else(|| self.expr_ty(e))\n+    }\n+\n     fn push_assignment(&mut self, block: BasicBlockId, place: Place, rvalue: Rvalue) {\n         self.result.basic_blocks[block].statements.push(Statement::Assign(place, rvalue));\n     }\n@@ -928,7 +979,25 @@ impl MirLowerCtx<'_> {\n                     binding_mode,\n                 )?\n             }\n-            Pat::Or(_) => not_supported!(\"or pattern\"),\n+            Pat::Or(pats) => {\n+                let then_target = self.new_basic_block();\n+                let mut finished = false;\n+                for pat in &**pats {\n+                    let (next, next_else) =\n+                        self.pattern_match(current, None, cond_place.clone(), cond_ty.clone(), *pat, binding_mode)?;\n+                    self.set_goto(next, then_target);\n+                    match next_else {\n+                        Some(t) => {\n+                            current = t;\n+                        }\n+                        None => {\n+                            finished = true;\n+                            break;\n+                        }\n+                    }\n+                }\n+                (then_target, (!finished).then_some(current))\n+            }\n             Pat::Record { .. } => not_supported!(\"record pattern\"),\n             Pat::Range { .. } => not_supported!(\"range pattern\"),\n             Pat::Slice { .. } => not_supported!(\"slice pattern\"),"}]}