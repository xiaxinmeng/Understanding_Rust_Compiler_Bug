{"sha": "876ce1026451047ddb8f455ed0c923f78f7dc39d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg3NmNlMTAyNjQ1MTA0N2RkYjhmNDU1ZWQwYzkyM2Y3OGY3ZGMzOWQ=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-05-24T01:47:13Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-05-25T03:32:55Z"}, "message": "Update the linenoise library", "tree": {"sha": "d5a4ec6e1a71be5dc525d7732e36dad2b1b6c960", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d5a4ec6e1a71be5dc525d7732e36dad2b1b6c960"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/876ce1026451047ddb8f455ed0c923f78f7dc39d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/876ce1026451047ddb8f455ed0c923f78f7dc39d", "html_url": "https://github.com/rust-lang/rust/commit/876ce1026451047ddb8f455ed0c923f78f7dc39d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/876ce1026451047ddb8f455ed0c923f78f7dc39d/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b5ab1012f1f5786f550e511ba1302a22c85fcd71", "url": "https://api.github.com/repos/rust-lang/rust/commits/b5ab1012f1f5786f550e511ba1302a22c85fcd71", "html_url": "https://github.com/rust-lang/rust/commit/b5ab1012f1f5786f550e511ba1302a22c85fcd71"}], "stats": {"total": 230, "additions": 211, "deletions": 19}, "files": [{"sha": "230711b5b8c8bdd24d1df367be8bd0743aae77e6", "filename": "src/rt/linenoise/linenoise.c", "status": "modified", "additions": 209, "deletions": 19, "changes": 228, "blob_url": "https://github.com/rust-lang/rust/blob/876ce1026451047ddb8f455ed0c923f78f7dc39d/src%2Frt%2Flinenoise%2Flinenoise.c", "raw_url": "https://github.com/rust-lang/rust/raw/876ce1026451047ddb8f455ed0c923f78f7dc39d/src%2Frt%2Flinenoise%2Flinenoise.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flinenoise%2Flinenoise.c?ref=876ce1026451047ddb8f455ed0c923f78f7dc39d", "patch": "@@ -150,6 +150,9 @@ enum {\n     SPECIAL_DELETE = -24,\n     SPECIAL_HOME = -25,\n     SPECIAL_END = -26,\n+    SPECIAL_INSERT = -27,\n+    SPECIAL_PAGE_UP = -28,\n+    SPECIAL_PAGE_DOWN = -29\n };\n \n static int history_max_len = LINENOISE_DEFAULT_HISTORY_MAX_LEN;\n@@ -165,6 +168,7 @@ struct current {\n     int pos;    /* Cursor position, measured in chars */\n     int cols;   /* Size of the window, in chars */\n     const char *prompt;\n+    char *capture; /* Allocated capture buffer, or NULL for none. Always null terminated */\n #if defined(USE_TERMIOS)\n     int fd;     /* Terminal fd */\n #elif defined(USE_WINCONSOLE)\n@@ -187,6 +191,7 @@ void linenoiseHistoryFree(void) {\n             free(history[j]);\n         free(history);\n         history = NULL;\n+        history_len = 0;\n     }\n }\n \n@@ -268,7 +273,10 @@ static void linenoiseAtExit(void) {\n     linenoiseHistoryFree();\n }\n \n-/* gcc/glibc insists that we care about the return code of write! */\n+/* gcc/glibc insists that we care about the return code of write!\n+ * Clarification: This means that a void-cast like \"(void) (EXPR)\"\n+ * does not work.\n+ */\n #define IGNORE_RC(EXPR) if (EXPR) {}\n \n /* This is fdprintf() on some systems, but use a different\n@@ -374,6 +382,70 @@ static int fd_read(struct current *current)\n #endif\n }\n \n+static int countColorControlChars(const char* prompt, int plen)\n+{\n+    /* ANSI color control sequences have the form:\n+     * \"\\x1b\" \"[\" [0-9;]+ \"m\"\n+     * We parse them with a simple state machine.\n+     */\n+\n+    enum {\n+        search_esc,\n+        expect_bracket,\n+        expect_inner,\n+        expect_trail\n+    } state = search_esc;\n+    int len, found = 0;\n+    char ch;\n+\n+    /* XXX: Strictly we should be checking utf8 chars rather than\n+     *      bytes in case of the extremely unlikely scenario where\n+     *      an ANSI sequence is part of a utf8 sequence.\n+     */\n+    for (; plen ; plen--, prompt++) {\n+        ch = *prompt;\n+\n+        switch (state) {\n+        case search_esc:\n+            len = 0;\n+            if (ch == '\\x1b') {\n+                state = expect_bracket;\n+                len++;\n+            }\n+            break;\n+        case expect_bracket:\n+            if (ch == '[') {\n+                state = expect_inner;\n+                len++;\n+            } else {\n+                state = search_esc;\n+            }\n+            break;\n+        case expect_inner:\n+            if (ch >= '0' && ch <= '9') {\n+                len++;\n+                state = expect_trail;\n+            } else {\n+                state = search_esc;\n+            }\n+            break;\n+        case expect_trail:\n+            if (ch == 'm') {\n+                len++;\n+                found += len;\n+                state = search_esc;\n+            } else if ((ch != ';') && ((ch < '0') || (ch > '9'))) {\n+                state = search_esc;\n+            }\n+            /* 0-9, or semicolon */\n+            len++;\n+            break;\n+        }\n+    }\n+\n+    return found;\n+}\n+\n static int getWindowSize(struct current *current)\n {\n     struct winsize ws;\n@@ -467,8 +539,14 @@ static int check_special(int fd)\n         c = fd_read_char(fd, 50);\n         if (c == '~') {\n             switch (c2) {\n+                case '2':\n+                    return SPECIAL_INSERT;\n                 case '3':\n                     return SPECIAL_DELETE;\n+                case '5':\n+                    return SPECIAL_PAGE_UP;\n+                case '6':\n+                    return SPECIAL_PAGE_DOWN;\n                 case '7':\n                     return SPECIAL_HOME;\n                 case '8':\n@@ -538,7 +616,7 @@ static int outputChars(struct current *current, const char *buf, int len)\n {\n     COORD pos = { (SHORT)current->x, (SHORT)current->y };\n     DWORD n;\n-\t\n+\n     WriteConsoleOutputCharacter(current->outh, buf, len, pos, &n);\n     current->x += len;\n     return 0;\n@@ -593,12 +671,18 @@ static int fd_read(struct current *current)\n                     return SPECIAL_UP;\n                  case VK_DOWN:\n                     return SPECIAL_DOWN;\n+                 case VK_INSERT:\n+                    return SPECIAL_INSERT;\n                  case VK_DELETE:\n                     return SPECIAL_DELETE;\n                  case VK_HOME:\n                     return SPECIAL_HOME;\n                  case VK_END:\n                     return SPECIAL_END;\n+                 case VK_PRIOR:\n+                    return SPECIAL_PAGE_UP;\n+                 case VK_NEXT:\n+                    return SPECIAL_PAGE_DOWN;\n                 }\n             }\n             /* Note that control characters are already translated in AsciiChar */\n@@ -614,6 +698,14 @@ static int fd_read(struct current *current)\n     return -1;\n }\n \n+static int countColorControlChars(char* prompt, int plen)\n+{\n+    /* For windows we assume that there are no embedded ansi color\n+     * control sequences.\n+     */\n+    return 0;\n+}\n+\n static int getWindowSize(struct current *current)\n {\n     CONSOLE_SCREEN_BUFFER_INFO info;\n@@ -676,6 +768,11 @@ static void refreshLine(const char *prompt, struct current *current)\n     plen = strlen(prompt);\n     pchars = utf8_strlen(prompt, plen);\n \n+    /* Scan the prompt for embedded ansi color control sequences and\n+     * discount them as characters/columns.\n+     */\n+    pchars -= countColorControlChars(prompt, plen);\n+\n     /* Account for a line which is too long to fit in the window.\n      * Note that control chars require an extra column\n      */\n@@ -692,7 +789,7 @@ static void refreshLine(const char *prompt, struct current *current)\n         }\n     }\n \n-    /* If too many are need, strip chars off the front of 'buf'\n+    /* If too many are needed, strip chars off the front of 'buf'\n      * until it fits. Note that if the current char is a control character,\n      * we need one extra col.\n      */\n@@ -843,16 +940,64 @@ static int insert_char(struct current *current, int pos, int ch)\n }\n \n /**\n+ * Captures up to 'n' characters starting at 'pos' for the cut buffer.\n+ *\n+ * This replaces any existing characters in the cut buffer.\n+ */\n+static void capture_chars(struct current *current, int pos, int n)\n+{\n+    if (pos >= 0 && (pos + n - 1) < current->chars) {\n+        int p1 = utf8_index(current->buf, pos);\n+        int nbytes = utf8_index(current->buf + p1, n);\n+\n+        if (nbytes) {\n+            free(current->capture);\n+            /* Include space for the null terminator */\n+            current->capture = (char *)malloc(nbytes + 1);\n+            memcpy(current->capture, current->buf + p1, nbytes);\n+            current->capture[nbytes] = '\\0';\n+        }\n+    }\n+}\n+\n+/**\n+ * Removes up to 'n' characters at cursor position 'pos'.\n+ *\n  * Returns 0 if no chars were removed or non-zero otherwise.\n  */\n static int remove_chars(struct current *current, int pos, int n)\n {\n     int removed = 0;\n+\n+    /* First save any chars which will be removed */\n+    capture_chars(current, pos, n);\n+\n     while (n-- && remove_char(current, pos)) {\n         removed++;\n     }\n     return removed;\n }\n+/**\n+ * Inserts the characters (string) 'chars' at the cursor position 'pos'.\n+ *\n+ * Returns 0 if no chars were inserted or non-zero otherwise.\n+ */\n+static int insert_chars(struct current *current, int pos, const char *chars)\n+{\n+    int inserted = 0;\n+\n+    while (*chars) {\n+        int ch;\n+        int n = utf8_tounicode(chars, &ch);\n+        if (insert_char(current, pos, ch) == 0) {\n+            break;\n+        }\n+        inserted++;\n+        pos++;\n+        chars += n;\n+    }\n+    return inserted;\n+}\n \n #ifndef NO_COMPLETION\n static linenoiseCompletionCallback *completionCallback = NULL;\n@@ -937,7 +1082,7 @@ void linenoiseAddCompletion(linenoiseCompletions *lc, const char *str) {\n \n #endif\n \n-static int linenoisePrompt(struct current *current) {\n+static int linenoiseEdit(struct current *current) {\n     int history_index = 0;\n \n     /* The latest history entry is always our current buffer, that\n@@ -998,7 +1143,12 @@ static int linenoisePrompt(struct current *current) {\n                 refreshLine(current->prompt, current);\n             }\n             break;\n-        case ctrl('W'):    /* ctrl-w */\n+        case SPECIAL_INSERT:\n+            /* Ignore. Expansion Hook.\n+             * Future possibility: Toggle Insert/Overwrite Modes\n+             */\n+            break;\n+        case ctrl('W'):    /* ctrl-w, delete word at left. save deleted chars */\n             /* eat any spaces on the left */\n             {\n                 int pos = current->pos;\n@@ -1118,9 +1268,11 @@ static int linenoisePrompt(struct current *current) {\n             }\n             break;\n         case ctrl('T'):    /* ctrl-t */\n-            if (current->pos > 0 && current->pos < current->chars) {\n-                c = get_char(current, current->pos);\n-                remove_char(current, current->pos);\n+            if (current->pos > 0 && current->pos <= current->chars) {\n+                /* If cursor is at end, transpose the previous two chars */\n+                int fixer = (current->pos == current->chars);\n+                c = get_char(current, current->pos - fixer);\n+                remove_char(current, current->pos - fixer);\n                 insert_char(current, current->pos - 1, c);\n                 refreshLine(current->prompt, current);\n             }\n@@ -1157,26 +1309,34 @@ static int linenoisePrompt(struct current *current) {\n                 refreshLine(current->prompt, current);\n             }\n             break;\n+        case SPECIAL_PAGE_UP:\n+          dir = history_len - history_index - 1; /* move to start of history */\n+          goto history_navigation;\n+        case SPECIAL_PAGE_DOWN:\n+          dir = -history_index; /* move to 0 == end of history, i.e. current */\n+          goto history_navigation;\n         case ctrl('P'):\n         case SPECIAL_UP:\n             dir = 1;\n+          goto history_navigation;\n         case ctrl('N'):\n         case SPECIAL_DOWN:\n+history_navigation:\n             if (history_len > 1) {\n                 /* Update the current history entry before to\n                  * overwrite it with tne next one. */\n-                free(history[history_len-1-history_index]);\n-                history[history_len-1-history_index] = strdup(current->buf);\n+                free(history[history_len - 1 - history_index]);\n+                history[history_len - 1 - history_index] = strdup(current->buf);\n                 /* Show the new entry */\n                 history_index += dir;\n                 if (history_index < 0) {\n                     history_index = 0;\n                     break;\n                 } else if (history_index >= history_len) {\n-                    history_index = history_len-1;\n+                    history_index = history_len - 1;\n                     break;\n                 }\n-                set_current(current, history[history_len-1-history_index]);\n+                set_current(current, history[history_len - 1 - history_index]);\n                 refreshLine(current->prompt, current);\n             }\n             break;\n@@ -1190,16 +1350,21 @@ static int linenoisePrompt(struct current *current) {\n             current->pos = current->chars;\n             refreshLine(current->prompt, current);\n             break;\n-        case ctrl('U'): /* Ctrl+u, delete to beginning of line. */\n+        case ctrl('U'): /* Ctrl+u, delete to beginning of line, save deleted chars. */\n             if (remove_chars(current, 0, current->pos)) {\n                 refreshLine(current->prompt, current);\n             }\n             break;\n-        case ctrl('K'): /* Ctrl+k, delete from current to end of line. */\n+        case ctrl('K'): /* Ctrl+k, delete from current to end of line, save deleted chars. */\n             if (remove_chars(current, current->pos, current->chars - current->pos)) {\n                 refreshLine(current->prompt, current);\n             }\n             break;\n+        case ctrl('Y'): /* Ctrl+y, insert saved chars at current position */\n+            if (current->capture && insert_chars(current, current->pos, current->capture)) {\n+                refreshLine(current->prompt, current);\n+            }\n+            break;\n         case ctrl('L'): /* Ctrl+L, clear screen */\n             clearScreen(current);\n             /* Force recalc of window size for serial terminals */\n@@ -1219,17 +1384,26 @@ static int linenoisePrompt(struct current *current) {\n     return current->len;\n }\n \n+int linenoiseColumns(void)\n+{\n+    struct current current;\n+    enableRawMode (&current);\n+    getWindowSize (&current);\n+    disableRawMode (&current);\n+    return current.cols;\n+}\n+\n char *linenoise(const char *prompt)\n {\n     int count;\n     struct current current;\n     char buf[LINENOISE_MAX_LINE];\n \n     if (enableRawMode(&current) == -1) {\n-\tprintf(\"%s\", prompt);\n+        printf(\"%s\", prompt);\n         fflush(stdout);\n         if (fgets(buf, sizeof(buf), stdin) == NULL) {\n-\t\treturn NULL;\n+            return NULL;\n         }\n         count = strlen(buf);\n         if (count && buf[count-1] == '\\n') {\n@@ -1245,10 +1419,14 @@ char *linenoise(const char *prompt)\n         current.chars = 0;\n         current.pos = 0;\n         current.prompt = prompt;\n+        current.capture = NULL;\n+\n+        count = linenoiseEdit(&current);\n \n-        count = linenoisePrompt(&current);\n         disableRawMode(&current);\n         printf(\"\\n\");\n+\n+        free(current.capture);\n         if (count == -1) {\n             return NULL;\n         }\n@@ -1284,6 +1462,10 @@ int linenoiseHistoryAdd(const char *line) {\n     return 1;\n }\n \n+int linenoiseHistoryGetMaxLen(void) {\n+    return history_max_len;\n+}\n+\n int linenoiseHistorySetMaxLen(int len) {\n     char **newHistory;\n \n@@ -1293,8 +1475,16 @@ int linenoiseHistorySetMaxLen(int len) {\n \n         newHistory = (char **)malloc(sizeof(char*)*len);\n         if (newHistory == NULL) return 0;\n-        if (len < tocopy) tocopy = len;\n-        memcpy(newHistory,history+(history_max_len-tocopy), sizeof(char*)*tocopy);\n+\n+        /* If we can't copy everything, free the elements we'll not use. */\n+        if (len < tocopy) {\n+            int j;\n+\n+            for (j = 0; j < tocopy-len; j++) free(history[j]);\n+            tocopy = len;\n+        }\n+        memset(newHistory,0,sizeof(char*)*len);\n+        memcpy(newHistory,history+(history_len-tocopy), sizeof(char*)*tocopy);\n         free(history);\n         history = newHistory;\n     }"}, {"sha": "7ebf244ee80e7f0bd92a551f3bb29de43ae7835a", "filename": "src/rt/linenoise/linenoise.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/876ce1026451047ddb8f455ed0c923f78f7dc39d/src%2Frt%2Flinenoise%2Flinenoise.h", "raw_url": "https://github.com/rust-lang/rust/raw/876ce1026451047ddb8f455ed0c923f78f7dc39d/src%2Frt%2Flinenoise%2Flinenoise.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Flinenoise%2Flinenoise.h?ref=876ce1026451047ddb8f455ed0c923f78f7dc39d", "patch": "@@ -51,9 +51,11 @@ void linenoiseAddCompletion(linenoiseCompletions *, const char *);\n char *linenoise(const char *prompt);\n int linenoiseHistoryAdd(const char *line);\n int linenoiseHistorySetMaxLen(int len);\n+int linenoiseHistoryGetMaxLen(void);\n int linenoiseHistorySave(const char *filename);\n int linenoiseHistoryLoad(const char *filename);\n void linenoiseHistoryFree(void);\n char **linenoiseHistory(int *len);\n+int linenoiseColumns(void);\n \n #endif /* __LINENOISE_H */"}]}