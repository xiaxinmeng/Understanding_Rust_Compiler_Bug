{"sha": "9b5bbab104d8ba445143f6f3a9e4149b40c29ae5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjliNWJiYWIxMDRkOGJhNDQ1MTQzZjZmM2E5ZTQxNDliNDBjMjlhZTU=", "commit": {"author": {"name": "Adolfo Ochagav\u00eda", "email": "aochagavia92@gmail.com", "date": "2018-11-04T14:06:38Z"}, "committer": {"name": "Adolfo Ochagav\u00eda", "email": "aochagavia92@gmail.com", "date": "2018-11-04T14:17:24Z"}, "message": "Add character literal parsing and validation", "tree": {"sha": "a1ef0fa5dbfd431e8a58afc6542c32c9ecefed04", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a1ef0fa5dbfd431e8a58afc6542c32c9ecefed04"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9b5bbab104d8ba445143f6f3a9e4149b40c29ae5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9b5bbab104d8ba445143f6f3a9e4149b40c29ae5", "html_url": "https://github.com/rust-lang/rust/commit/9b5bbab104d8ba445143f6f3a9e4149b40c29ae5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9b5bbab104d8ba445143f6f3a9e4149b40c29ae5/comments", "author": {"login": "aochagavia", "id": 5196584, "node_id": "MDQ6VXNlcjUxOTY1ODQ=", "avatar_url": "https://avatars.githubusercontent.com/u/5196584?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aochagavia", "html_url": "https://github.com/aochagavia", "followers_url": "https://api.github.com/users/aochagavia/followers", "following_url": "https://api.github.com/users/aochagavia/following{/other_user}", "gists_url": "https://api.github.com/users/aochagavia/gists{/gist_id}", "starred_url": "https://api.github.com/users/aochagavia/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aochagavia/subscriptions", "organizations_url": "https://api.github.com/users/aochagavia/orgs", "repos_url": "https://api.github.com/users/aochagavia/repos", "events_url": "https://api.github.com/users/aochagavia/events{/privacy}", "received_events_url": "https://api.github.com/users/aochagavia/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aochagavia", "id": 5196584, "node_id": "MDQ6VXNlcjUxOTY1ODQ=", "avatar_url": "https://avatars.githubusercontent.com/u/5196584?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aochagavia", "html_url": "https://github.com/aochagavia", "followers_url": "https://api.github.com/users/aochagavia/followers", "following_url": "https://api.github.com/users/aochagavia/following{/other_user}", "gists_url": "https://api.github.com/users/aochagavia/gists{/gist_id}", "starred_url": "https://api.github.com/users/aochagavia/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aochagavia/subscriptions", "organizations_url": "https://api.github.com/users/aochagavia/orgs", "repos_url": "https://api.github.com/users/aochagavia/repos", "events_url": "https://api.github.com/users/aochagavia/events{/privacy}", "received_events_url": "https://api.github.com/users/aochagavia/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "19c6cbd9540ef87850161cad7e108b380eceea24", "url": "https://api.github.com/repos/rust-lang/rust/commits/19c6cbd9540ef87850161cad7e108b380eceea24", "html_url": "https://github.com/rust-lang/rust/commit/19c6cbd9540ef87850161cad7e108b380eceea24"}], "stats": {"total": 399, "additions": 397, "deletions": 2}, "files": [{"sha": "75769a4e9d3d4cde30941d8acbecf281e2485156", "filename": "crates/ra_syntax/src/ast/generated.rs", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/9b5bbab104d8ba445143f6f3a9e4149b40c29ae5/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b5bbab104d8ba445143f6f3a9e4149b40c29ae5/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated.rs?ref=9b5bbab104d8ba445143f6f3a9e4149b40c29ae5", "patch": "@@ -409,6 +409,40 @@ impl<'a> AstNode<'a> for CastExpr<'a> {\n \n impl<'a> CastExpr<'a> {}\n \n+// Char\n+\n+#[derive(Debug, Clone)]\n+pub struct CharNode(SyntaxNode);\n+\n+impl CharNode {\n+    pub fn ast(&self) -> Char {\n+        Char::cast(self.0.borrowed()).unwrap()\n+    }\n+}\n+\n+impl<'a> From<Char<'a>> for CharNode {\n+    fn from(ast: Char<'a>) -> CharNode {\n+        let syntax = ast.syntax().owned();\n+        CharNode(syntax)\n+    }\n+}\n+#[derive(Debug, Clone, Copy)]\n+pub struct Char<'a> {\n+    syntax: SyntaxNodeRef<'a>,\n+}\n+\n+impl<'a> AstNode<'a> for Char<'a> {\n+    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {\n+        match syntax.kind() {\n+            CHAR => Some(Char { syntax }),\n+            _ => None,\n+        }\n+    }\n+    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }\n+}\n+\n+impl<'a> Char<'a> {}\n+\n // Comment\n \n #[derive(Debug, Clone)]"}, {"sha": "4355531d002ddd80a130469815046e4b7e58e1ef", "filename": "crates/ra_syntax/src/ast/mod.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9b5bbab104d8ba445143f6f3a9e4149b40c29ae5/crates%2Fra_syntax%2Fsrc%2Fast%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b5bbab104d8ba445143f6f3a9e4149b40c29ae5/crates%2Fra_syntax%2Fsrc%2Fast%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fmod.rs?ref=9b5bbab104d8ba445143f6f3a9e4149b40c29ae5", "patch": "@@ -123,6 +123,12 @@ impl<'a> Lifetime<'a> {\n     }\n }\n \n+impl<'a> Char<'a> {\n+    pub fn text(&self) -> &SmolStr {\n+        &self.syntax().leaf_text().unwrap()\n+    }\n+}\n+\n impl<'a> Comment<'a> {\n     pub fn text(&self) -> &SmolStr {\n         self.syntax().leaf_text().unwrap()"}, {"sha": "2ed165c5253edc0e8c8e9aa09a565296e140e863", "filename": "crates/ra_syntax/src/grammar.ron", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9b5bbab104d8ba445143f6f3a9e4149b40c29ae5/crates%2Fra_syntax%2Fsrc%2Fgrammar.ron", "raw_url": "https://github.com/rust-lang/rust/raw/9b5bbab104d8ba445143f6f3a9e4149b40c29ae5/crates%2Fra_syntax%2Fsrc%2Fgrammar.ron", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fgrammar.ron?ref=9b5bbab104d8ba445143f6f3a9e4149b40c29ae5", "patch": "@@ -406,6 +406,7 @@ Grammar(\n         \"PrefixExpr\": (),\n         \"RangeExpr\": (),\n         \"BinExpr\": (),\n+        \"Char\": (),\n         \"Literal\": (),\n \n         \"Expr\": ("}, {"sha": "8996eb921033ebfba0d248da8efafb7ee17c99bb", "filename": "crates/ra_syntax/src/lib.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9b5bbab104d8ba445143f6f3a9e4149b40c29ae5/crates%2Fra_syntax%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b5bbab104d8ba445143f6f3a9e4149b40c29ae5/crates%2Fra_syntax%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Flib.rs?ref=9b5bbab104d8ba445143f6f3a9e4149b40c29ae5", "patch": "@@ -39,11 +39,12 @@ mod grammar;\n mod parser_api;\n mod parser_impl;\n mod reparsing;\n-\n+mod string_lexing;\n mod syntax_kinds;\n pub mod text_utils;\n /// Utilities for simple uses of the parser.\n pub mod utils;\n+mod validation;\n mod yellow;\n \n pub use crate::{\n@@ -98,6 +99,8 @@ impl File {\n         self.root.borrowed()\n     }\n     pub fn errors(&self) -> Vec<SyntaxError> {\n-        self.root.root_data().clone()\n+        let mut errors = self.root.root_data().clone();\n+        errors.extend(validation::validate(self));\n+        errors\n     }\n }"}, {"sha": "6b52c62c381324bf5b10cf9d141e8b2393a1f189", "filename": "crates/ra_syntax/src/string_lexing/mod.rs", "status": "added", "additions": 311, "deletions": 0, "changes": 311, "blob_url": "https://github.com/rust-lang/rust/blob/9b5bbab104d8ba445143f6f3a9e4149b40c29ae5/crates%2Fra_syntax%2Fsrc%2Fstring_lexing%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b5bbab104d8ba445143f6f3a9e4149b40c29ae5/crates%2Fra_syntax%2Fsrc%2Fstring_lexing%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fstring_lexing%2Fmod.rs?ref=9b5bbab104d8ba445143f6f3a9e4149b40c29ae5", "patch": "@@ -0,0 +1,311 @@\n+use self::CharComponentKind::*;\n+use rowan::{TextRange, TextUnit};\n+\n+pub fn parse_char_literal(src: &str) -> CharComponentIterator {\n+    CharComponentIterator {\n+        parser: Parser::new(src),\n+        has_closing_quote: false,\n+    }\n+}\n+\n+#[derive(Debug, Eq, PartialEq, Clone)]\n+pub struct CharComponent {\n+    pub range: TextRange,\n+    pub kind: CharComponentKind,\n+}\n+\n+impl CharComponent {\n+    fn new(range: TextRange, kind: CharComponentKind) -> CharComponent {\n+        CharComponent { range, kind }\n+    }\n+}\n+\n+#[derive(Debug, Eq, PartialEq, Clone)]\n+pub enum CharComponentKind {\n+    CodePoint,\n+    AsciiEscape,\n+    AsciiCodeEscape,\n+    UnicodeEscape,\n+}\n+\n+pub struct CharComponentIterator<'a> {\n+    parser: Parser<'a>,\n+    pub has_closing_quote: bool,\n+}\n+\n+impl<'a> Iterator for CharComponentIterator<'a> {\n+    type Item = CharComponent;\n+    fn next(&mut self) -> Option<CharComponent> {\n+        if self.parser.pos == 0 {\n+            assert!(\n+                self.parser.advance() == '\\'',\n+                \"char literal should start with a quote\"\n+            );\n+        }\n+\n+        if let Some(component) = self.parser.parse_char_component() {\n+            return Some(component);\n+        }\n+\n+        // We get here when there are no char components left to parse\n+        if self.parser.peek() == Some('\\'') {\n+            self.parser.advance();\n+            self.has_closing_quote = true;\n+        }\n+\n+        assert!(\n+            self.parser.peek() == None,\n+            \"char literal should leave no unparsed input: src = {}, pos = {}, length = {}\",\n+            self.parser.src,\n+            self.parser.pos,\n+            self.parser.src.len()\n+        );\n+\n+        None\n+    }\n+}\n+\n+pub struct Parser<'a> {\n+    src: &'a str,\n+    pos: usize,\n+}\n+\n+impl<'a> Parser<'a> {\n+    pub fn new(src: &'a str) -> Parser<'a> {\n+        Parser { src, pos: 0 }\n+    }\n+\n+    // Utility methods\n+\n+    pub fn peek(&self) -> Option<char> {\n+        if self.pos == self.src.len() {\n+            return None;\n+        }\n+\n+        self.src[self.pos..].chars().next()\n+    }\n+\n+    pub fn advance(&mut self) -> char {\n+        let next = self\n+            .peek()\n+            .expect(\"cannot advance if end of input is reached\");\n+        self.pos += next.len_utf8();\n+        next\n+    }\n+\n+    pub fn get_pos(&self) -> TextUnit {\n+        (self.pos as u32).into()\n+    }\n+\n+    // Char parsing methods\n+\n+    fn parse_unicode_escape(&mut self, start: TextUnit) -> CharComponent {\n+        // Note: validation of UnicodeEscape will be done elsewhere:\n+        // * Only hex digits or underscores allowed\n+        // * Max 6 chars\n+        // * Within allowed range (must be at most 10FFFF)\n+        match self.peek() {\n+            Some('{') => {\n+                self.advance();\n+\n+                // Parse anything until we reach `}`\n+                while let Some(next) = self.peek() {\n+                    self.advance();\n+                    if next == '}' {\n+                        break;\n+                    }\n+                }\n+\n+                let end = self.get_pos();\n+                CharComponent::new(TextRange::from_to(start, end), UnicodeEscape)\n+            }\n+            Some(_) | None => {\n+                let end = self.get_pos();\n+                CharComponent::new(TextRange::from_to(start, end), UnicodeEscape)\n+            }\n+        }\n+    }\n+\n+    fn parse_ascii_code_escape(&mut self, start: TextUnit) -> CharComponent {\n+        // Note: validation of AsciiCodeEscape will be done elsewhere:\n+        // * First digit is octal\n+        // * Second digit is hex\n+        let code_start = self.get_pos();\n+        while let Some(next) = self.peek() {\n+            if next == '\\'' || (self.get_pos() - code_start == 2.into()) {\n+                break;\n+            }\n+\n+            self.advance();\n+        }\n+\n+        let end = self.get_pos();\n+        CharComponent::new(TextRange::from_to(start, end), AsciiCodeEscape)\n+    }\n+\n+    fn parse_escape(&mut self, start: TextUnit) -> CharComponent {\n+        // Note: validation of AsciiEscape will be done elsewhere:\n+        // * The escape sequence is non-empty\n+        // * The escape sequence is valid\n+        if self.peek().is_none() {\n+            return CharComponent::new(TextRange::from_to(start, start), AsciiEscape);\n+        }\n+\n+        let next = self.advance();\n+        let end = self.get_pos();\n+        let range = TextRange::from_to(start, end);\n+        match next {\n+            'x' => self.parse_ascii_code_escape(start),\n+            'u' => self.parse_unicode_escape(start),\n+            _ => CharComponent::new(range, AsciiEscape),\n+        }\n+    }\n+\n+    pub fn parse_char_component(&mut self) -> Option<CharComponent> {\n+        let next = self.peek()?;\n+\n+        // Ignore character close\n+        if next == '\\'' {\n+            return None;\n+        }\n+\n+        let start = self.get_pos();\n+        self.advance();\n+\n+        if next == '\\\\' {\n+            Some(self.parse_escape(start))\n+        } else {\n+            let end = self.get_pos();\n+            Some(CharComponent::new(\n+                TextRange::from_to(start, end),\n+                CodePoint,\n+            ))\n+        }\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+\n+    fn parse(src: &str) -> (bool, Vec<CharComponent>) {\n+        let component_iterator = &mut super::parse_char_literal(src);\n+        let components: Vec<_> = component_iterator.collect();\n+        (component_iterator.has_closing_quote, components)\n+    }\n+\n+    fn unclosed_char_component(src: &str) -> CharComponent {\n+        let (has_closing_quote, components) = parse(src);\n+        assert!(!has_closing_quote, \"char should not have closing quote\");\n+        assert!(components.len() == 1);\n+        components[0].clone()\n+    }\n+\n+    fn closed_char_component(src: &str) -> CharComponent {\n+        let (has_closing_quote, components) = parse(src);\n+        assert!(has_closing_quote, \"char should have closing quote\");\n+        assert!(\n+            components.len() == 1,\n+            \"Literal: {}\\nComponents: {:#?}\",\n+            src,\n+            components\n+        );\n+        components[0].clone()\n+    }\n+\n+    fn closed_char_components(src: &str) -> Vec<CharComponent> {\n+        let (has_closing_quote, components) = parse(src);\n+        assert!(has_closing_quote, \"char should have closing quote\");\n+        components\n+    }\n+\n+    fn range_closed(src: &str) -> TextRange {\n+        TextRange::from_to(1.into(), (src.len() as u32 - 1).into())\n+    }\n+\n+    fn range_unclosed(src: &str) -> TextRange {\n+        TextRange::from_to(1.into(), (src.len() as u32).into())\n+    }\n+\n+    #[test]\n+    fn test_unicode_escapes() {\n+        let unicode_escapes = &[r\"{DEAD}\", \"{BEEF}\", \"{FF}\", \"\"];\n+        for escape in unicode_escapes {\n+            let escape_sequence = format!(r\"'\\u{}'\", escape);\n+            let component = closed_char_component(&escape_sequence);\n+            let expected_range = range_closed(&escape_sequence);\n+            assert_eq!(component.kind, CharComponentKind::UnicodeEscape);\n+            assert_eq!(component.range, expected_range);\n+        }\n+    }\n+\n+    #[test]\n+    fn test_unicode_escapes_unclosed() {\n+        let unicode_escapes = &[\"{DEAD\", \"{BEEF\", \"{FF\"];\n+        for escape in unicode_escapes {\n+            let escape_sequence = format!(r\"'\\u{}'\", escape);\n+            let component = unclosed_char_component(&escape_sequence);\n+            let expected_range = range_unclosed(&escape_sequence);\n+            assert_eq!(component.kind, CharComponentKind::UnicodeEscape);\n+            assert_eq!(component.range, expected_range);\n+        }\n+    }\n+\n+    #[test]\n+    fn test_empty_char() {\n+        let (has_closing_quote, components) = parse(\"''\");\n+        assert!(has_closing_quote, \"char should have closing quote\");\n+        assert!(components.len() == 0);\n+    }\n+\n+    #[test]\n+    fn test_unclosed_char() {\n+        let component = unclosed_char_component(\"'a\");\n+        assert!(component.kind == CodePoint);\n+        assert!(component.range == TextRange::from_to(1.into(), 2.into()));\n+    }\n+\n+    #[test]\n+    fn test_digit_escapes() {\n+        let literals = &[r\"\", r\"5\", r\"55\"];\n+\n+        for literal in literals {\n+            let lit_text = format!(r\"'\\x{}'\", literal);\n+            let component = closed_char_component(&lit_text);\n+            assert!(component.kind == CharComponentKind::AsciiCodeEscape);\n+            assert!(component.range == range_closed(&lit_text));\n+        }\n+\n+        // More than 2 digits starts a new codepoint\n+        let components = closed_char_components(r\"'\\x555'\");\n+        assert!(components.len() == 2);\n+        assert!(components[1].kind == CharComponentKind::CodePoint);\n+    }\n+\n+    #[test]\n+    fn test_ascii_escapes() {\n+        let literals = &[\n+            r\"\\'\", \"\\\\\\\"\", // equivalent to \\\"\n+            r\"\\n\", r\"\\r\", r\"\\t\", r\"\\\\\", r\"\\0\",\n+        ];\n+\n+        for literal in literals {\n+            let lit_text = format!(\"'{}'\", literal);\n+            let component = closed_char_component(&lit_text);\n+            assert!(component.kind == CharComponentKind::AsciiEscape);\n+            assert!(component.range == range_closed(&lit_text));\n+        }\n+    }\n+\n+    #[test]\n+    fn test_no_escapes() {\n+        let literals = &['\"', 'n', 'r', 't', '0', 'x', 'u'];\n+\n+        for &literal in literals {\n+            let lit_text = format!(\"'{}'\", literal);\n+            let component = closed_char_component(&lit_text);\n+            assert!(component.kind == CharComponentKind::CodePoint);\n+            assert!(component.range == range_closed(&lit_text));\n+        }\n+    }\n+}"}, {"sha": "03d98eff490894d83ce9cb73e4b52b8775a767ff", "filename": "crates/ra_syntax/src/validation.rs", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/9b5bbab104d8ba445143f6f3a9e4149b40c29ae5/crates%2Fra_syntax%2Fsrc%2Fvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b5bbab104d8ba445143f6f3a9e4149b40c29ae5/crates%2Fra_syntax%2Fsrc%2Fvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fvalidation.rs?ref=9b5bbab104d8ba445143f6f3a9e4149b40c29ae5", "patch": "@@ -0,0 +1,40 @@\n+use crate::{\n+    ast::{self, AstNode},\n+    File,\n+    string_lexing,\n+    yellow::{\n+        SyntaxError,\n+    },\n+};\n+\n+pub(crate) fn validate(file: &File) -> Vec<SyntaxError> {\n+    let mut errors = Vec::new();\n+    for d in file.root.borrowed().descendants() {\n+        if let Some(c) = ast::Char::cast(d) {\n+            let components = &mut string_lexing::parse_char_literal(c.text());\n+            let len = components.count();\n+\n+            if !components.has_closing_quote {\n+                errors.push(SyntaxError {\n+                    msg: \"Unclosed char literal\".to_string(),\n+                    offset: d.range().start(),\n+                });\n+            }\n+\n+            if len == 0 {\n+                errors.push(SyntaxError {\n+                    msg: \"Empty char literal\".to_string(),\n+                    offset: d.range().start(),\n+                });\n+            }\n+\n+            if len > 1 {\n+                errors.push(SyntaxError {\n+                    msg: \"Character literal should be only one character long\".to_string(),\n+                    offset: d.range().start(),\n+                });\n+            }\n+        }\n+    }\n+    errors\n+}"}]}