{"sha": "0b511e82abe48f40808453de2f013e7c5ebab4c3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBiNTExZTgyYWJlNDhmNDA4MDg0NTNkZTJmMDEzZTdjNWViYWI0YzM=", "commit": {"author": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2016-01-21T00:19:20Z"}, "committer": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2016-01-26T04:51:11Z"}, "message": "Initial work towards abort-free compilation\n\nThe goal is that the compiler will pass `Result`s around rather than using abort_if_errors. To preserve behaviour we currently abort at the top level. I've removed all other aborts from the driver, but haven't touched any of the nested aborts.", "tree": {"sha": "37bf874ace5ff71ac0358c4b976d35349268037b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/37bf874ace5ff71ac0358c4b976d35349268037b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0b511e82abe48f40808453de2f013e7c5ebab4c3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0b511e82abe48f40808453de2f013e7c5ebab4c3", "html_url": "https://github.com/rust-lang/rust/commit/0b511e82abe48f40808453de2f013e7c5ebab4c3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0b511e82abe48f40808453de2f013e7c5ebab4c3/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "faf6d1e87391b25196b35909c3c95e5d873cacf0", "url": "https://api.github.com/repos/rust-lang/rust/commits/faf6d1e87391b25196b35909c3c95e5d873cacf0", "html_url": "https://github.com/rust-lang/rust/commit/faf6d1e87391b25196b35909c3c95e5d873cacf0"}], "stats": {"total": 596, "additions": 331, "deletions": 265}, "files": [{"sha": "fbfdbd15116c9b9fbc6bfc5d0b67e5aaa511f06f", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 18, "deletions": 5, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/0b511e82abe48f40808453de2f013e7c5ebab4c3/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b511e82abe48f40808453de2f013e7c5ebab4c3/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=0b511e82abe48f40808453de2f013e7c5ebab4c3", "patch": "@@ -176,15 +176,28 @@ impl Session {\n     pub fn abort_if_errors(&self) {\n         self.diagnostic().abort_if_errors();\n     }\n-    pub fn abort_if_new_errors<F, T>(&self, f: F) -> T\n+    pub fn track_errors<F, T>(&self, f: F) -> Result<T, usize>\n         where F: FnOnce() -> T\n     {\n-        let count = self.err_count();\n+        let mut count = self.err_count();\n         let result = f();\n-        if self.err_count() > count {\n-            self.abort_if_errors();\n+        count -= self.err_count();\n+        if count == 0 {\n+            Ok(result)\n+        } else {\n+            Err(count)\n+        }\n+    }\n+    pub fn abort_if_new_errors<F, T>(&self, f: F) -> T\n+        where F: FnOnce() -> T\n+    {\n+        match self.track_errors(f) {\n+            Ok(result) => result,\n+            Err(_) => {\n+                self.abort_if_errors();\n+                unreachable!();\n+            }\n         }\n-        result\n     }\n     pub fn span_warn(&self, sp: Span, msg: &str) {\n         self.diagnostic().span_warn(sp, msg)"}, {"sha": "87ac9a2052b94068e4ffe27bbb337f8dd4a03483", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 203, "deletions": 202, "changes": 405, "blob_url": "https://github.com/rust-lang/rust/blob/0b511e82abe48f40808453de2f013e7c5ebab4c3/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b511e82abe48f40808453de2f013e7c5ebab4c3/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=0b511e82abe48f40808453de2f013e7c5ebab4c3", "patch": "@@ -35,7 +35,7 @@ use rustc_plugin as plugin;\n use rustc_front::hir;\n use rustc_front::lowering::{lower_crate, LoweringContext};\n use rustc_passes::{no_asm, loops, consts, const_fn, rvalues, static_recursion};\n-use super::Compilation;\n+use super::{Compilation, CompileResult, compile_result_from_err_count};\n \n use serialize::json;\n \n@@ -57,60 +57,65 @@ use syntax::visit;\n use syntax;\n use syntax_ext;\n \n-pub fn compile_input(sess: Session,\n+macro_rules! throw_if_errors {\n+    ($tsess: expr) => {{\n+        let err_count = $tsess.err_count();\n+        if err_count > 0 {\n+            return Err(err_count);\n+        }\n+    }}\n+}\n+\n+pub fn compile_input(sess: &Session,\n                      cstore: &CStore,\n                      cfg: ast::CrateConfig,\n                      input: &Input,\n                      outdir: &Option<PathBuf>,\n                      output: &Option<PathBuf>,\n                      addl_plugins: Option<Vec<String>>,\n-                     control: CompileController) {\n+                     control: CompileController) -> CompileResult {\n     macro_rules! controller_entry_point{($point: ident, $tsess: expr, $make_state: expr) => ({\n         let state = $make_state;\n         (control.$point.callback)(state);\n \n         if control.$point.stop == Compilation::Stop {\n-            $tsess.abort_if_errors();\n-            return;\n+            return compile_result_from_err_count($tsess.err_count());\n         }\n     })}\n \n     // We need nested scopes here, because the intermediate results can keep\n     // large chunks of memory alive and we want to free them as soon as\n     // possible to keep the peak memory usage low\n-    let result = {\n+    let (outputs, trans) = {\n         let (outputs, expanded_crate, id) = {\n-            let krate = phase_1_parse_input(&sess, cfg, input);\n+            let krate = phase_1_parse_input(sess, cfg, input);\n \n             controller_entry_point!(after_parse,\n                                     sess,\n-                                    CompileState::state_after_parse(input, &sess, outdir, &krate));\n-\n-            let outputs = build_output_filenames(input, outdir, output, &krate.attrs, &sess);\n-            let id = link::find_crate_name(Some(&sess), &krate.attrs, input);\n-            let expanded_crate = match phase_2_configure_and_expand(&sess,\n-                                                                    &cstore,\n-                                                                    krate,\n-                                                                    &id[..],\n-                                                                    addl_plugins) {\n-                None => return,\n-                Some(k) => k,\n-            };\n+                                    CompileState::state_after_parse(input, sess, outdir, &krate));\n+\n+            let outputs = build_output_filenames(input, outdir, output, &krate.attrs, sess);\n+            let id = link::find_crate_name(Some(sess), &krate.attrs, input);\n+            let expanded_crate = try!(phase_2_configure_and_expand(sess,\n+                                                                   &cstore,\n+                                                                   krate,\n+                                                                   &id[..],\n+                                                                   addl_plugins));\n \n             (outputs, expanded_crate, id)\n         };\n \n         controller_entry_point!(after_expand,\n                                 sess,\n                                 CompileState::state_after_expand(input,\n-                                                                 &sess,\n+                                                                 sess,\n                                                                  outdir,\n                                                                  &expanded_crate,\n                                                                  &id[..]));\n \n-        let expanded_crate = assign_node_ids(&sess, expanded_crate);\n+        let expanded_crate = assign_node_ids(sess, expanded_crate);\n         // Lower ast -> hir.\n-        let lcx = LoweringContext::new(&sess, Some(&expanded_crate));\n+        let lcx = LoweringContext::new(sess, Some(&expanded_crate));\n         let mut hir_forest = time(sess.time_passes(),\n                                   \"lowering ast -> hir\",\n                                   || hir_map::Forest::new(lower_crate(&lcx, &expanded_crate)));\n@@ -122,14 +127,14 @@ pub fn compile_input(sess: Session,\n         }\n \n         let arenas = ty::CtxtArenas::new();\n-        let hir_map = make_map(&sess, &mut hir_forest);\n+        let hir_map = make_map(sess, &mut hir_forest);\n \n-        write_out_deps(&sess, &outputs, &id);\n+        write_out_deps(sess, &outputs, &id);\n \n         controller_entry_point!(after_write_deps,\n                                 sess,\n                                 CompileState::state_after_write_deps(input,\n-                                                                     &sess,\n+                                                                     sess,\n                                                                      outdir,\n                                                                      &hir_map,\n                                                                      &expanded_crate,\n@@ -138,12 +143,12 @@ pub fn compile_input(sess: Session,\n                                                                      &lcx));\n \n         time(sess.time_passes(), \"attribute checking\", || {\n-            front::check_attr::check_crate(&sess, &expanded_crate);\n+            front::check_attr::check_crate(sess, &expanded_crate);\n         });\n \n         time(sess.time_passes(),\n              \"early lint checks\",\n-             || lint::check_ast_crate(&sess, &expanded_crate));\n+             || lint::check_ast_crate(sess, &expanded_crate));\n \n         let opt_crate = if sess.opts.debugging_opts.keep_ast ||\n                            sess.opts.debugging_opts.save_analysis {\n@@ -153,67 +158,62 @@ pub fn compile_input(sess: Session,\n             None\n         };\n \n-        phase_3_run_analysis_passes(&sess,\n-                                    &cstore,\n-                                    hir_map,\n-                                    &arenas,\n-                                    &id,\n-                                    control.make_glob_map,\n-                                    |tcx, mir_map, analysis| {\n-\n-                                        {\n-                                            let state =\n-                                                CompileState::state_after_analysis(input,\n-                                                                                   &tcx.sess,\n-                                                                                   outdir,\n-                                                                                   opt_crate,\n-                                                                                   tcx.map.krate(),\n-                                                                                   &analysis,\n-                                                                                   &mir_map,\n-                                                                                   tcx,\n-                                                                                   &lcx,\n-                                                                                   &id);\n-                                            (control.after_analysis.callback)(state);\n-\n-                                            tcx.sess.abort_if_errors();\n-                                            if control.after_analysis.stop == Compilation::Stop {\n-                                                return Err(());\n-                                            }\n-                                        }\n-\n-                                        if log_enabled!(::log::INFO) {\n-                                            println!(\"Pre-trans\");\n-                                            tcx.print_debug_stats();\n-                                        }\n-                                        let trans = phase_4_translate_to_llvm(tcx,\n-                                                                              mir_map,\n-                                                                              analysis);\n-\n-                                        if log_enabled!(::log::INFO) {\n-                                            println!(\"Post-trans\");\n-                                            tcx.print_debug_stats();\n-                                        }\n-\n-                                        // Discard interned strings as they are no longer required.\n-                                        token::get_ident_interner().clear();\n-\n-                                        Ok((outputs, trans))\n-                                    })\n-    };\n+        try!(try!(phase_3_run_analysis_passes(sess,\n+                                         &cstore,\n+                                         hir_map,\n+                                         &arenas,\n+                                         &id,\n+                                         control.make_glob_map,\n+                                         |tcx, mir_map, analysis| {\n+            {\n+                let state =\n+                    CompileState::state_after_analysis(input,\n+                                                       &tcx.sess,\n+                                                       outdir,\n+                                                       opt_crate,\n+                                                       tcx.map.krate(),\n+                                                       &analysis,\n+                                                       &mir_map,\n+                                                       tcx,\n+                                                       &lcx,\n+                                                       &id);\n+                (control.after_analysis.callback)(state);\n+\n+                throw_if_errors!(tcx.sess);\n+                if control.after_analysis.stop == Compilation::Stop {\n+                    return Err(0usize);\n+                }\n+            }\n \n-    let (outputs, trans) = if let Ok(out) = result {\n-        out\n-    } else {\n-        return;\n+            if log_enabled!(::log::INFO) {\n+                println!(\"Pre-trans\");\n+                tcx.print_debug_stats();\n+            }\n+            let trans = phase_4_translate_to_llvm(tcx,\n+                                                  mir_map,\n+                                                  analysis);\n+\n+            if log_enabled!(::log::INFO) {\n+                println!(\"Post-trans\");\n+                tcx.print_debug_stats();\n+            }\n+\n+            // Discard interned strings as they are no longer required.\n+            token::get_ident_interner().clear();\n+\n+            Ok((outputs, trans))\n+        })))\n     };\n \n-    phase_5_run_llvm_passes(&sess, &trans, &outputs);\n+    try!(phase_5_run_llvm_passes(sess, &trans, &outputs));\n \n     controller_entry_point!(after_llvm,\n                             sess,\n-                            CompileState::state_after_llvm(input, &sess, outdir, &trans));\n+                            CompileState::state_after_llvm(input, sess, outdir, &trans));\n+\n+    phase_6_link_output(sess, &trans, &outputs);\n \n-    phase_6_link_output(&sess, &trans, &outputs);\n+    Ok(())\n }\n \n /// The name used for source code that doesn't originate in a file\n@@ -457,7 +457,7 @@ pub fn phase_2_configure_and_expand(sess: &Session,\n                                     mut krate: ast::Crate,\n                                     crate_name: &str,\n                                     addl_plugins: Option<Vec<String>>)\n-                                    -> Option<ast::Crate> {\n+                                    -> Result<ast::Crate, usize> {\n     let time_passes = sess.time_passes();\n \n     // strip before anything else because crate metadata may use #[cfg_attr]\n@@ -469,13 +469,13 @@ pub fn phase_2_configure_and_expand(sess: &Session,\n     // baz! should not use this definition unless foo is enabled.\n \n     let mut feature_gated_cfgs = vec![];\n-    krate = time(time_passes, \"configuration 1\", || {\n-        sess.abort_if_new_errors(|| {\n+    krate = try!(time(time_passes, \"configuration 1\", || {\n+        sess.track_errors(|| {\n             syntax::config::strip_unconfigured_items(sess.diagnostic(),\n                                                      krate,\n                                                      &mut feature_gated_cfgs)\n         })\n-    });\n+    }));\n \n     *sess.crate_types.borrow_mut() = collect_crate_types(sess, &krate.attrs);\n     *sess.crate_metadata.borrow_mut() = collect_crate_metadata(sess, &krate.attrs);\n@@ -484,17 +484,17 @@ pub fn phase_2_configure_and_expand(sess: &Session,\n         middle::recursion_limit::update_recursion_limit(sess, &krate);\n     });\n \n-    time(time_passes, \"gated macro checking\", || {\n-        sess.abort_if_new_errors(|| {\n+    try!(time(time_passes, \"gated macro checking\", || {\n+        sess.track_errors(|| {\n             let features =\n               syntax::feature_gate::check_crate_macros(sess.codemap(),\n                                                        &sess.parse_sess.span_diagnostic,\n                                                        &krate);\n \n             // these need to be set \"early\" so that expansion sees `quote` if enabled.\n             *sess.features.borrow_mut() = features;\n-        });\n-    });\n+        })\n+    }));\n \n \n     krate = time(time_passes, \"crate injection\", || {\n@@ -531,7 +531,7 @@ pub fn phase_2_configure_and_expand(sess: &Session,\n     let Registry { syntax_exts, early_lint_passes, late_lint_passes, lint_groups,\n                    llvm_passes, attributes, .. } = registry;\n \n-    sess.abort_if_new_errors(|| {\n+    try!(sess.track_errors(|| {\n         let mut ls = sess.lint_store.borrow_mut();\n         for pass in early_lint_passes {\n             ls.register_early_pass(Some(sess), true, pass);\n@@ -546,14 +546,14 @@ pub fn phase_2_configure_and_expand(sess: &Session,\n \n         *sess.plugin_llvm_passes.borrow_mut() = llvm_passes;\n         *sess.plugin_attributes.borrow_mut() = attributes.clone();\n-    });\n+    }));\n \n     // Lint plugins are registered; now we can process command line flags.\n     if sess.opts.describe_lints {\n         super::describe_lints(&*sess.lint_store.borrow(), true);\n-        return None;\n+        return Err(0);\n     }\n-    sess.abort_if_new_errors(|| sess.lint_store.borrow_mut().process_command_line(sess));\n+    try!(sess.track_errors(|| sess.lint_store.borrow_mut().process_command_line(sess)));\n \n     krate = time(time_passes, \"expansion\", || {\n         // Windows dlls do not have rpaths, so they don't know how to find their\n@@ -596,21 +596,21 @@ pub fn phase_2_configure_and_expand(sess: &Session,\n     // of macro expansion.  This runs before #[cfg] to try to catch as\n     // much as possible (e.g. help the programmer avoid platform\n     // specific differences)\n-    time(time_passes, \"complete gated feature checking 1\", || {\n-        sess.abort_if_new_errors(|| {\n+    try!(time(time_passes, \"complete gated feature checking 1\", || {\n+        sess.track_errors(|| {\n             let features = syntax::feature_gate::check_crate(sess.codemap(),\n                                                              &sess.parse_sess.span_diagnostic,\n                                                              &krate,\n                                                              &attributes,\n                                                              sess.opts.unstable_features);\n             *sess.features.borrow_mut() = features;\n-        });\n-    });\n+        })\n+    }));\n \n     // JBC: make CFG processing part of expansion to avoid this problem:\n \n     // strip again, in case expansion added anything with a #[cfg].\n-    krate = sess.abort_if_new_errors(|| {\n+    krate = try!(sess.track_errors(|| {\n         let krate = time(time_passes, \"configuration 2\", || {\n             syntax::config::strip_unconfigured_items(sess.diagnostic(),\n                                                      krate,\n@@ -627,7 +627,7 @@ pub fn phase_2_configure_and_expand(sess: &Session,\n         });\n \n         krate\n-    });\n+    }));\n \n     krate = time(time_passes, \"maybe building test harness\", || {\n         syntax::test::modify_for_testing(&sess.parse_sess, &sess.opts.cfg, krate, sess.diagnostic())\n@@ -648,16 +648,16 @@ pub fn phase_2_configure_and_expand(sess: &Session,\n     // One final feature gating of the true AST that gets compiled\n     // later, to make sure we've got everything (e.g. configuration\n     // can insert new attributes via `cfg_attr`)\n-    time(time_passes, \"complete gated feature checking 2\", || {\n-        sess.abort_if_new_errors(|| {\n+    try!(time(time_passes, \"complete gated feature checking 2\", || {\n+        sess.track_errors(|| {\n             let features = syntax::feature_gate::check_crate(sess.codemap(),\n                                                              &sess.parse_sess.span_diagnostic,\n                                                              &krate,\n                                                              &attributes,\n                                                              sess.opts.unstable_features);\n             *sess.features.borrow_mut() = features;\n-        });\n-    });\n+        })\n+    }));\n \n     time(time_passes,\n          \"const fn bodies and arguments\",\n@@ -667,7 +667,7 @@ pub fn phase_2_configure_and_expand(sess: &Session,\n         println!(\"Post-expansion node count: {}\", count_nodes(&krate));\n     }\n \n-    Some(krate)\n+    Ok(krate)\n }\n \n pub fn assign_node_ids(sess: &Session, krate: ast::Crate) -> ast::Crate {\n@@ -712,7 +712,7 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n                                                name: &str,\n                                                make_glob_map: resolve::MakeGlobMap,\n                                                f: F)\n-                                               -> R\n+                                               -> Result<R, usize>\n     where F: for<'a> FnOnce(&'a ty::ctxt<'tcx>, MirMap<'tcx>, ty::CrateAnalysis) -> R\n {\n     let time_passes = sess.time_passes();\n@@ -722,11 +722,11 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n          \"external crate/lib resolution\",\n          || LocalCrateReader::new(sess, cstore, &hir_map).read_crates(krate));\n \n-    let lang_items = time(time_passes, \"language item collection\", || {\n-        sess.abort_if_new_errors(|| {\n+    let lang_items = try!(time(time_passes, \"language item collection\", || {\n+        sess.track_errors(|| {\n             middle::lang_items::collect_language_items(&sess, &hir_map)\n         })\n-    });\n+    }));\n \n     let resolve::CrateMap {\n         def_map,\n@@ -773,98 +773,98 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n                                lang_items,\n                                stability::Index::new(krate),\n                                |tcx| {\n-                                   // passes are timed inside typeck\n-                                   typeck::check_crate(tcx, trait_map);\n-\n-                                   time(time_passes,\n-                                        \"const checking\",\n-                                        || consts::check_crate(tcx));\n-\n-                                   let access_levels =\n-                                       time(time_passes, \"privacy checking\", || {\n-                                           rustc_privacy::check_crate(tcx,\n-                                                                      &export_map,\n-                                                                      external_exports)\n-                                       });\n-\n-                                   // Do not move this check past lint\n-                                   time(time_passes, \"stability index\", || {\n-                                       tcx.stability.borrow_mut().build(tcx, krate, &access_levels)\n-                                   });\n-\n-                                   time(time_passes,\n-                                        \"intrinsic checking\",\n-                                        || middle::intrinsicck::check_crate(tcx));\n-\n-                                   time(time_passes,\n-                                        \"effect checking\",\n-                                        || middle::effect::check_crate(tcx));\n-\n-                                   time(time_passes,\n-                                        \"match checking\",\n-                                        || middle::check_match::check_crate(tcx));\n-\n-                                   let mir_map =\n-                                       time(time_passes,\n-                                            \"MIR dump\",\n-                                            || mir::mir_map::build_mir_for_crate(tcx));\n-\n-                                   time(time_passes,\n-                                        \"liveness checking\",\n-                                        || middle::liveness::check_crate(tcx));\n-\n-                                   time(time_passes,\n-                                        \"borrow checking\",\n-                                        || borrowck::check_crate(tcx));\n-\n-                                   time(time_passes,\n-                                        \"rvalue checking\",\n-                                        || rvalues::check_crate(tcx));\n-\n-                                   // Avoid overwhelming user with errors if type checking failed.\n-                                   // I'm not sure how helpful this is, to be honest, but it avoids\n-                                   // a\n-                                   // lot of annoying errors in the compile-fail tests (basically,\n-                                   // lint warnings and so on -- kindck used to do this abort, but\n-                                   // kindck is gone now). -nmatsakis\n-                                   tcx.sess.abort_if_errors();\n-\n-                                   let reachable_map =\n-                                       time(time_passes,\n-                                            \"reachability checking\",\n-                                            || reachable::find_reachable(tcx, &access_levels));\n-\n-                                   time(time_passes, \"death checking\", || {\n-                                       middle::dead::check_crate(tcx, &access_levels);\n-                                   });\n-\n-                                   let ref lib_features_used =\n-                                       time(time_passes,\n-                                            \"stability checking\",\n-                                            || stability::check_unstable_api_usage(tcx));\n-\n-                                   time(time_passes, \"unused lib feature checking\", || {\n-                                       stability::check_unused_or_stable_features(&tcx.sess,\n-                                                                                  lib_features_used)\n-                                   });\n-\n-                                   time(time_passes,\n-                                        \"lint checking\",\n-                                        || lint::check_crate(tcx, &access_levels));\n-\n-                                   // The above three passes generate errors w/o aborting\n-                                   tcx.sess.abort_if_errors();\n-\n-                                   f(tcx,\n-                                     mir_map,\n-                                     ty::CrateAnalysis {\n-                                         export_map: export_map,\n-                                         access_levels: access_levels,\n-                                         reachable: reachable_map,\n-                                         name: name,\n-                                         glob_map: glob_map,\n-                                     })\n-                               })\n+        // passes are timed inside typeck\n+        typeck::check_crate(tcx, trait_map);\n+\n+        time(time_passes,\n+             \"const checking\",\n+             || middle::check_const::check_crate(tcx));\n+\n+        let access_levels =\n+            time(time_passes, \"privacy checking\", || {\n+                rustc_privacy::check_crate(tcx,\n+                                           &export_map,\n+                                           external_exports)\n+            });\n+\n+        // Do not move this check past lint\n+        time(time_passes, \"stability index\", || {\n+            tcx.stability.borrow_mut().build(tcx, krate, &access_levels)\n+        });\n+\n+        time(time_passes,\n+             \"intrinsic checking\",\n+             || middle::intrinsicck::check_crate(tcx));\n+\n+        time(time_passes,\n+             \"effect checking\",\n+             || middle::effect::check_crate(tcx));\n+\n+        time(time_passes,\n+             \"match checking\",\n+             || middle::check_match::check_crate(tcx));\n+\n+        let mir_map =\n+            time(time_passes,\n+                 \"MIR dump\",\n+                 || mir::mir_map::build_mir_for_crate(tcx));\n+\n+        time(time_passes,\n+             \"liveness checking\",\n+             || middle::liveness::check_crate(tcx));\n+\n+        time(time_passes,\n+             \"borrow checking\",\n+             || borrowck::check_crate(tcx));\n+\n+        time(time_passes,\n+             \"rvalue checking\",\n+             || middle::check_rvalues::check_crate(tcx));\n+\n+        // Avoid overwhelming user with errors if type checking failed.\n+        // I'm not sure how helpful this is, to be honest, but it avoids\n+        // a\n+        // lot of annoying errors in the compile-fail tests (basically,\n+        // lint warnings and so on -- kindck used to do this abort, but\n+        // kindck is gone now). -nmatsakis\n+        throw_if_errors!(tcx.sess);\n+\n+        let reachable_map =\n+            time(time_passes,\n+                 \"reachability checking\",\n+                 || reachable::find_reachable(tcx, &access_levels));\n+\n+        time(time_passes, \"death checking\", || {\n+            middle::dead::check_crate(tcx, &access_levels);\n+        });\n+\n+        let ref lib_features_used =\n+            time(time_passes,\n+                 \"stability checking\",\n+                 || stability::check_unstable_api_usage(tcx));\n+\n+        time(time_passes, \"unused lib feature checking\", || {\n+            stability::check_unused_or_stable_features(&tcx.sess,\n+                                                       lib_features_used)\n+        });\n+\n+        time(time_passes,\n+             \"lint checking\",\n+             || lint::check_crate(tcx, &access_levels));\n+\n+        // The above three passes generate errors w/o aborting\n+        throw_if_errors!(tcx.sess);\n+\n+        Ok(f(tcx,\n+          mir_map,\n+          ty::CrateAnalysis {\n+              export_map: export_map,\n+              access_levels: access_levels,\n+              reachable: reachable_map,\n+              name: name,\n+              glob_map: glob_map,\n+          }))\n+    })\n }\n \n /// Run the translation phase to LLVM, after which the AST and analysis can\n@@ -893,7 +893,7 @@ pub fn phase_4_translate_to_llvm<'tcx>(tcx: &ty::ctxt<'tcx>,\n /// as a side effect.\n pub fn phase_5_run_llvm_passes(sess: &Session,\n                                trans: &trans::CrateTranslation,\n-                               outputs: &OutputFilenames) {\n+                               outputs: &OutputFilenames) -> CompileResult {\n     if sess.opts.cg.no_integrated_as {\n         let mut map = HashMap::new();\n         map.insert(OutputType::Assembly, None);\n@@ -913,7 +913,8 @@ pub fn phase_5_run_llvm_passes(sess: &Session,\n              || write::run_passes(sess, trans, &sess.opts.output_types, outputs));\n     }\n \n-    sess.abort_if_errors();\n+    throw_if_errors!(sess);\n+    Ok(())\n }\n \n /// Run the linker on any artifacts that resulted from the LLVM run."}, {"sha": "030b29db3f20eed71074e033adf5f9e9ea82d4fc", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 60, "deletions": 13, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/0b511e82abe48f40808453de2f013e7c5ebab4c3/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b511e82abe48f40808453de2f013e7c5ebab4c3/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=0b511e82abe48f40808453de2f013e7c5ebab4c3", "patch": "@@ -104,57 +104,103 @@ pub mod target_features;\n const BUG_REPORT_URL: &'static str = \"https://github.com/rust-lang/rust/blob/master/CONTRIBUTING.\\\n                                       md#bug-reports\";\n \n+// Err(0) means compilation was stopped, but no errors were found.\n+// This would be better as a dedicated enum, but using try! is so convenient.\n+pub type CompileResult = Result<(), usize>;\n+\n+pub fn compile_result_from_err_count(err_count: usize) -> CompileResult {\n+    if err_count == 0 {\n+        Ok(())\n+    } else {\n+        Err(err_count)\n+    }\n+}\n+\n+#[inline]\n+fn abort_msg(err_count: usize) -> String {\n+    match err_count {\n+        0 => \"aborting with no errors (maybe a bug?)\".to_owned(),\n+        1 => \"aborting due to previous error\".to_owned(),\n+        e => format!(\"aborting due to {} previous errors\", e),\n+    }\n+}\n+\n+pub fn abort_on_err<T>(result: Result<T, usize>, sess: &Session) -> T {\n+    match result {\n+        Err(err_count) => {\n+            sess.fatal(&abort_msg(err_count));\n+        }\n+        Ok(x) => x,\n+    }\n+}\n+\n pub fn run(args: Vec<String>) -> isize {\n-    monitor(move || run_compiler(&args, &mut RustcDefaultCalls));\n+    monitor(move || {\n+        let (result, session) = run_compiler(&args, &mut RustcDefaultCalls);\n+        if let Err(err_count) = result {\n+            if err_count > 0 {\n+                match session {\n+                    Some(sess) => sess.fatal(&abort_msg(err_count)),\n+                    None => {\n+                        let mut emitter =\n+                            errors::emitter::BasicEmitter::stderr(errors::ColorConfig::Auto);\n+                        emitter.emit(None, &abort_msg(err_count), None, errors::Level::Fatal);\n+                        panic!(errors::FatalError);\n+                    }\n+                }\n+            }\n+        }\n+    });\n     0\n }\n \n // Parse args and run the compiler. This is the primary entry point for rustc.\n // See comments on CompilerCalls below for details about the callbacks argument.\n-pub fn run_compiler<'a>(args: &[String], callbacks: &mut CompilerCalls<'a>) {\n-    macro_rules! do_or_return {($expr: expr) => {\n+pub fn run_compiler<'a>(args: &[String],\n+                        callbacks: &mut CompilerCalls<'a>)\n+                        -> (CompileResult, Option<Session>) {\n+    macro_rules! do_or_return {($expr: expr, $sess: expr) => {\n         match $expr {\n-            Compilation::Stop => return,\n+            Compilation::Stop => return (Ok(()), $sess),\n             Compilation::Continue => {}\n         }\n     }}\n \n     let matches = match handle_options(args.to_vec()) {\n         Some(matches) => matches,\n-        None => return,\n+        None => return (Ok(()), None),\n     };\n \n     let sopts = config::build_session_options(&matches);\n \n     let descriptions = diagnostics_registry();\n \n-    do_or_return!(callbacks.early_callback(&matches, &descriptions, sopts.error_format));\n+    do_or_return!(callbacks.early_callback(&matches, &descriptions, sopts.error_format), None);\n \n     let (odir, ofile) = make_output(&matches);\n     let (input, input_file_path) = match make_input(&matches.free) {\n         Some((input, input_file_path)) => callbacks.some_input(input, input_file_path),\n         None => match callbacks.no_input(&matches, &sopts, &odir, &ofile, &descriptions) {\n             Some((input, input_file_path)) => (input, input_file_path),\n-            None => return,\n+            None => return (Ok(()), None),\n         },\n     };\n \n     let cstore = Rc::new(CStore::new(token::get_ident_interner()));\n-    let sess = build_session(sopts, input_file_path, descriptions,\n-                                 cstore.clone());\n+    let sess = build_session(sopts, input_file_path, descriptions, cstore.clone());\n     rustc_lint::register_builtins(&mut sess.lint_store.borrow_mut(), Some(&sess));\n     let mut cfg = config::build_configuration(&sess);\n     target_features::add_configuration(&mut cfg, &sess);\n \n-    do_or_return!(callbacks.late_callback(&matches, &sess, &input, &odir, &ofile));\n+    do_or_return!(callbacks.late_callback(&matches, &sess, &input, &odir, &ofile), Some(sess));\n \n     // It is somewhat unfortunate that this is hardwired in - this is forced by\n     // the fact that pretty_print_input requires the session by value.\n     let pretty = callbacks.parse_pretty(&sess, &matches);\n     match pretty {\n         Some((ppm, opt_uii)) => {\n             pretty::pretty_print_input(sess, &cstore, cfg, &input, ppm, opt_uii, ofile);\n-            return;\n+            return (Ok(()), None);\n         }\n         None => {\n             // continue\n@@ -163,8 +209,9 @@ pub fn run_compiler<'a>(args: &[String], callbacks: &mut CompilerCalls<'a>) {\n \n     let plugins = sess.opts.debugging_opts.extra_plugins.clone();\n     let control = callbacks.build_controller(&sess);\n-    driver::compile_input(sess, &cstore, cfg, &input, &odir, &ofile,\n-                          Some(plugins), control);\n+    (driver::compile_input(&sess, &cstore, cfg, &input, &odir, &ofile,\n+                           Some(plugins), control),\n+     Some(sess))\n }\n \n // Extract output directory and file from matches."}, {"sha": "1e99067bf32ed9e0a5bc8c9ec0425418b2ebcb94", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 31, "deletions": 31, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/0b511e82abe48f40808453de2f013e7c5ebab4c3/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b511e82abe48f40808453de2f013e7c5ebab4c3/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=0b511e82abe48f40808453de2f013e7c5ebab4c3", "patch": "@@ -17,7 +17,7 @@ use self::NodesMatchingUII::*;\n \n use rustc_trans::back::link;\n \n-use driver;\n+use {driver, abort_on_err};\n \n use rustc::middle::ty;\n use rustc::middle::cfg;\n@@ -194,21 +194,21 @@ impl PpSourceMode {\n                 f(&annotation, payload, &ast_map.forest.krate)\n             }\n             PpmTyped => {\n-                driver::phase_3_run_analysis_passes(sess,\n-                                                    cstore,\n-                                                    ast_map.clone(),\n-                                                    arenas,\n-                                                    id,\n-                                                    resolve::MakeGlobMap::No,\n-                                                    |tcx, _, _| {\n-                                                        let annotation = TypedAnnotation {\n-                                                            tcx: tcx,\n-                                                        };\n-                                                        let _ignore = tcx.dep_graph.in_ignore();\n-                                                        f(&annotation,\n-                                                          payload,\n-                                                          &ast_map.forest.krate)\n-                                                    })\n+                abort_on_err(driver::phase_3_run_analysis_passes(sess,\n+                                                                 cstore,\n+                                                                 ast_map.clone(),\n+                                                                 arenas,\n+                                                                 id,\n+                                                                 resolve::MakeGlobMap::No,\n+                                                                 |tcx, _, _| {\n+                    let annotation = TypedAnnotation {\n+                        tcx: tcx,\n+                    };\n+                    let _ignore = tcx.dep_graph.in_ignore();\n+                    f(&annotation,\n+                      payload,\n+                      &ast_map.forest.krate)\n+                }), sess)\n             }\n             _ => panic!(\"Should use call_with_pp_support\"),\n         }\n@@ -694,8 +694,8 @@ pub fn pretty_print_input(sess: Session,\n     let compute_ast_map = needs_ast_map(&ppm, &opt_uii);\n     let krate = if compute_ast_map {\n         match driver::phase_2_configure_and_expand(&sess, &cstore, krate, &id[..], None) {\n-            None => return,\n-            Some(k) => driver::assign_node_ids(&sess, k),\n+            Err(_) => return,\n+            Ok(k) => driver::assign_node_ids(&sess, k),\n         }\n     } else {\n         krate\n@@ -818,19 +818,19 @@ pub fn pretty_print_input(sess: Session,\n             match code {\n                 Some(code) => {\n                     let variants = gather_flowgraph_variants(&sess);\n-                    driver::phase_3_run_analysis_passes(&sess,\n-                                                        &cstore,\n-                                                        ast_map,\n-                                                        &arenas,\n-                                                        &id,\n-                                                        resolve::MakeGlobMap::No,\n-                                                        |tcx, _, _| {\n-                                                            print_flowgraph(variants,\n-                                                                            tcx,\n-                                                                            code,\n-                                                                            mode,\n-                                                                            out)\n-                                                        })\n+                    abort_on_err(driver::phase_3_run_analysis_passes(&sess,\n+                                                                     &cstore,\n+                                                                     ast_map,\n+                                                                     &arenas,\n+                                                                     &id,\n+                                                                     resolve::MakeGlobMap::No,\n+                                                                     |tcx, _, _| {\n+                        print_flowgraph(variants,\n+                                        tcx,\n+                                        code,\n+                                        mode,\n+                                        out)\n+                    }), &sess)\n                 }\n                 None => {\n                     let message = format!(\"--pretty=flowgraph needs block, fn, or method; got \\"}, {"sha": "5eac358f1bf39bf4e767cf9b11935850f4593543", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/0b511e82abe48f40808453de2f013e7c5ebab4c3/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b511e82abe48f40808453de2f013e7c5ebab4c3/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=0b511e82abe48f40808453de2f013e7c5ebab4c3", "patch": "@@ -10,7 +10,7 @@\n pub use self::MaybeTyped::*;\n \n use rustc_lint;\n-use rustc_driver::{driver, target_features};\n+use rustc_driver::{driver, target_features, abort_on_err};\n use rustc::session::{self, config};\n use rustc::middle::def_id::DefId;\n use rustc::middle::privacy::AccessLevels;\n@@ -147,13 +147,13 @@ pub fn run_core(search_paths: SearchPaths, cfgs: Vec<String>, externs: Externs,\n     let arenas = ty::CtxtArenas::new();\n     let hir_map = driver::make_map(&sess, &mut hir_forest);\n \n-    driver::phase_3_run_analysis_passes(&sess,\n-                                        &cstore,\n-                                        hir_map,\n-                                        &arenas,\n-                                        &name,\n-                                        resolve::MakeGlobMap::No,\n-                                        |tcx, _, analysis| {\n+    abort_on_err(driver::phase_3_run_analysis_passes(&sess,\n+                                                     &cstore,\n+                                                     hir_map,\n+                                                     &arenas,\n+                                                     &name,\n+                                                     resolve::MakeGlobMap::No,\n+                                                     |tcx, _, analysis| {\n         let _ignore = tcx.dep_graph.in_ignore();\n         let ty::CrateAnalysis { access_levels, .. } = analysis;\n \n@@ -200,5 +200,5 @@ pub fn run_core(search_paths: SearchPaths, cfgs: Vec<String>, externs: Externs,\n         *analysis.inlined.borrow_mut() = map;\n         analysis.deref_trait_did = ctxt.deref_trait_did.get();\n         (krate, analysis)\n-    })\n+    }), &sess)\n }"}, {"sha": "81f984a5927809f0d14559626c7771904fe4d0b8", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0b511e82abe48f40808453de2f013e7c5ebab4c3/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b511e82abe48f40808453de2f013e7c5ebab4c3/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=0b511e82abe48f40808453de2f013e7c5ebab4c3", "patch": "@@ -250,7 +250,12 @@ fn runtest(test: &str, cratename: &str, cfgs: Vec<String>, libs: SearchPaths,\n     if no_run {\n         control.after_analysis.stop = Compilation::Stop;\n     }\n-    driver::compile_input(sess, &cstore, cfg, &input, &out, &None, None, control);\n+    let result = driver::compile_input(&sess, &cstore, cfg, &input,\n+                                       &out, &None, None, control);\n+    match result {\n+        Err(count) if count > 0 => sess.fatal(\"aborting due to previous error(s)\"),\n+        _ => {}\n+    }\n \n     if no_run { return }\n "}, {"sha": "fe6a5faf9324a3a46e4b0bdd8634c9e14c9d0f40", "filename": "src/test/run-make/execution-engine/test.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0b511e82abe48f40808453de2f013e7c5ebab4c3/src%2Ftest%2Frun-make%2Fexecution-engine%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b511e82abe48f40808453de2f013e7c5ebab4c3/src%2Ftest%2Frun-make%2Fexecution-engine%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fexecution-engine%2Ftest.rs?ref=0b511e82abe48f40808453de2f013e7c5ebab4c3", "patch": "@@ -32,7 +32,7 @@ use rustc::middle::cstore::{CrateStore, LinkagePreference};\n use rustc::middle::ty;\n use rustc::session::config::{self, basic_options, build_configuration, Input, Options};\n use rustc::session::build_session;\n-use rustc_driver::driver;\n+use rustc_driver::{driver, abort_on_err};\n use rustc_front::lowering::{lower_crate, LoweringContext};\n use rustc_resolve::MakeGlobMap;\n use rustc_metadata::cstore::CStore;\n@@ -234,7 +234,7 @@ fn compile_program(input: &str, sysroot: PathBuf)\n         let arenas = ty::CtxtArenas::new();\n         let ast_map = driver::make_map(&sess, &mut hir_forest);\n \n-        driver::phase_3_run_analysis_passes(\n+        abort_on_err(driver::phase_3_run_analysis_passes(\n             &sess, &cstore, ast_map, &arenas, &id,\n             MakeGlobMap::No, |tcx, mir_map, analysis| {\n \n@@ -254,7 +254,7 @@ fn compile_program(input: &str, sysroot: PathBuf)\n             let modp = llmod as usize;\n \n             (modp, deps)\n-        })\n+        }), &sess)\n     }).unwrap();\n \n     match handle.join() {"}, {"sha": "b2aed91545842e61042eee48fdca2f633058be29", "filename": "src/test/run-make/issue-19371/foo.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0b511e82abe48f40808453de2f013e7c5ebab4c3/src%2Ftest%2Frun-make%2Fissue-19371%2Ffoo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b511e82abe48f40808453de2f013e7c5ebab4c3/src%2Ftest%2Frun-make%2Fissue-19371%2Ffoo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fissue-19371%2Ffoo.rs?ref=0b511e82abe48f40808453de2f013e7c5ebab4c3", "patch": "@@ -65,7 +65,7 @@ fn compile(code: String, output: PathBuf, sysroot: PathBuf) {\n     let cfg = build_configuration(&sess);\n     let control = CompileController::basic();\n \n-    compile_input(sess, &cstore,\n+    compile_input(&sess, &cstore,\n             cfg,\n             &Input::Str(code),\n             &None,"}]}