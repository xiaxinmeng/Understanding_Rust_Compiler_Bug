{"sha": "b65daa7688e919d8cc991d9004d23f4235ee0482", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI2NWRhYTc2ODhlOTE5ZDhjYzk5MWQ5MDA0ZDIzZjQyMzVlZTA0ODI=", "commit": {"author": {"name": "Dylan MacKenzie", "email": "ecstaticmorse@gmail.com", "date": "2020-05-22T01:51:47Z"}, "committer": {"name": "Dylan MacKenzie", "email": "ecstaticmorse@gmail.com", "date": "2020-08-22T20:35:30Z"}, "message": "Test new floating point bit casts", "tree": {"sha": "c31c08bba81fc4743f6a03d84d1d041c535de975", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c31c08bba81fc4743f6a03d84d1d041c535de975"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b65daa7688e919d8cc991d9004d23f4235ee0482", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b65daa7688e919d8cc991d9004d23f4235ee0482", "html_url": "https://github.com/rust-lang/rust/commit/b65daa7688e919d8cc991d9004d23f4235ee0482", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b65daa7688e919d8cc991d9004d23f4235ee0482/comments", "author": {"login": "ecstatic-morse", "id": 29463364, "node_id": "MDQ6VXNlcjI5NDYzMzY0", "avatar_url": "https://avatars.githubusercontent.com/u/29463364?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ecstatic-morse", "html_url": "https://github.com/ecstatic-morse", "followers_url": "https://api.github.com/users/ecstatic-morse/followers", "following_url": "https://api.github.com/users/ecstatic-morse/following{/other_user}", "gists_url": "https://api.github.com/users/ecstatic-morse/gists{/gist_id}", "starred_url": "https://api.github.com/users/ecstatic-morse/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ecstatic-morse/subscriptions", "organizations_url": "https://api.github.com/users/ecstatic-morse/orgs", "repos_url": "https://api.github.com/users/ecstatic-morse/repos", "events_url": "https://api.github.com/users/ecstatic-morse/events{/privacy}", "received_events_url": "https://api.github.com/users/ecstatic-morse/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ecstatic-morse", "id": 29463364, "node_id": "MDQ6VXNlcjI5NDYzMzY0", "avatar_url": "https://avatars.githubusercontent.com/u/29463364?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ecstatic-morse", "html_url": "https://github.com/ecstatic-morse", "followers_url": "https://api.github.com/users/ecstatic-morse/followers", "following_url": "https://api.github.com/users/ecstatic-morse/following{/other_user}", "gists_url": "https://api.github.com/users/ecstatic-morse/gists{/gist_id}", "starred_url": "https://api.github.com/users/ecstatic-morse/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ecstatic-morse/subscriptions", "organizations_url": "https://api.github.com/users/ecstatic-morse/orgs", "repos_url": "https://api.github.com/users/ecstatic-morse/repos", "events_url": "https://api.github.com/users/ecstatic-morse/events{/privacy}", "received_events_url": "https://api.github.com/users/ecstatic-morse/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "23e08e223bb527eaef418a9fbc842471d555b3be", "url": "https://api.github.com/repos/rust-lang/rust/commits/23e08e223bb527eaef418a9fbc842471d555b3be", "html_url": "https://github.com/rust-lang/rust/commit/23e08e223bb527eaef418a9fbc842471d555b3be"}], "stats": {"total": 170, "additions": 170, "deletions": 0}, "files": [{"sha": "ca5df9b0e97b56cd931fec5a1a5b946c5b6b0fe8", "filename": "src/test/ui/consts/const-float-bits-conv.rs", "status": "added", "additions": 93, "deletions": 0, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/b65daa7688e919d8cc991d9004d23f4235ee0482/src%2Ftest%2Fui%2Fconsts%2Fconst-float-bits-conv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b65daa7688e919d8cc991d9004d23f4235ee0482/src%2Ftest%2Fui%2Fconsts%2Fconst-float-bits-conv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-float-bits-conv.rs?ref=b65daa7688e919d8cc991d9004d23f4235ee0482", "patch": "@@ -0,0 +1,93 @@\n+// -Zmir-opt-level=0\n+// run-pass\n+\n+#![feature(const_panic)]\n+#![feature(const_float_bits_conv)]\n+#![feature(const_float_classify)]\n+\n+// Don't promote\n+const fn nop<T>(x: T) -> T { x }\n+\n+macro_rules! const_assert {\n+    ($a:expr) => {\n+        {\n+            const _: () = assert!($a);\n+            assert!(nop($a));\n+        }\n+    };\n+    ($a:expr, $b:expr) => {\n+        {\n+            const _: () = assert!($a == $b);\n+            assert_eq!(nop($a), nop($b));\n+        }\n+    };\n+}\n+\n+fn f32() {\n+    const_assert!((1f32).to_bits(), 0x3f800000);\n+    const_assert!(u32::from_be_bytes(1f32.to_be_bytes()), 0x3f800000);\n+    const_assert!((12.5f32).to_bits(), 0x41480000);\n+    const_assert!(u32::from_le_bytes(12.5f32.to_le_bytes()), 0x41480000);\n+    const_assert!((1337f32).to_bits(), 0x44a72000);\n+    const_assert!(u32::from_ne_bytes(1337f32.to_ne_bytes()), 0x44a72000);\n+    const_assert!((-14.25f32).to_bits(), 0xc1640000);\n+    const_assert!(f32::from_bits(0x3f800000), 1.0);\n+    const_assert!(f32::from_be_bytes(0x3f800000u32.to_be_bytes()), 1.0);\n+    const_assert!(f32::from_bits(0x41480000), 12.5);\n+    const_assert!(f32::from_le_bytes(0x41480000u32.to_le_bytes()), 12.5);\n+    const_assert!(f32::from_bits(0x44a72000), 1337.0);\n+    const_assert!(f32::from_ne_bytes(0x44a72000u32.to_ne_bytes()), 1337.0);\n+    const_assert!(f32::from_bits(0xc1640000), -14.25);\n+\n+    // Check that NaNs roundtrip their bits regardless of signalingness\n+    // 0xA is 0b1010; 0x5 is 0b0101 -- so these two together clobbers all the mantissa bits\n+    const MASKED_NAN1: u32 = f32::NAN.to_bits() ^ 0x002A_AAAA;\n+    const MASKED_NAN2: u32 = f32::NAN.to_bits() ^ 0x0055_5555;\n+\n+    const_assert!(f32::from_bits(MASKED_NAN1).is_nan());\n+    const_assert!(f32::from_bits(MASKED_NAN1).is_nan());\n+\n+    // LLVM does not guarantee that loads and stores of NaNs preserve their exact bit pattern.\n+    // In practice, this seems to only cause a problem on x86, since the most widely used calling\n+    // convention mandates that floating point values are returned on the x87 FPU stack. See #73328.\n+    if !cfg!(target_arch = \"x86\") {\n+        const_assert!(f32::from_bits(MASKED_NAN1).to_bits(), MASKED_NAN1);\n+        const_assert!(f32::from_bits(MASKED_NAN2).to_bits(), MASKED_NAN2);\n+    }\n+}\n+\n+fn f64() {\n+    const_assert!((1f64).to_bits(), 0x3ff0000000000000);\n+    const_assert!(u64::from_be_bytes(1f64.to_be_bytes()), 0x3ff0000000000000);\n+    const_assert!((12.5f64).to_bits(), 0x4029000000000000);\n+    const_assert!(u64::from_le_bytes(12.5f64.to_le_bytes()), 0x4029000000000000);\n+    const_assert!((1337f64).to_bits(), 0x4094e40000000000);\n+    const_assert!(u64::from_ne_bytes(1337f64.to_ne_bytes()), 0x4094e40000000000);\n+    const_assert!((-14.25f64).to_bits(), 0xc02c800000000000);\n+    const_assert!(f64::from_bits(0x3ff0000000000000), 1.0);\n+    const_assert!(f64::from_be_bytes(0x3ff0000000000000u64.to_be_bytes()), 1.0);\n+    const_assert!(f64::from_bits(0x4029000000000000), 12.5);\n+    const_assert!(f64::from_le_bytes(0x4029000000000000u64.to_le_bytes()), 12.5);\n+    const_assert!(f64::from_bits(0x4094e40000000000), 1337.0);\n+    const_assert!(f64::from_ne_bytes(0x4094e40000000000u64.to_ne_bytes()), 1337.0);\n+    const_assert!(f64::from_bits(0xc02c800000000000), -14.25);\n+\n+    // Check that NaNs roundtrip their bits regardless of signalingness\n+    // 0xA is 0b1010; 0x5 is 0b0101 -- so these two together clobbers all the mantissa bits\n+    const MASKED_NAN1: u64 = f64::NAN.to_bits() ^ 0x000A_AAAA_AAAA_AAAA;\n+    const MASKED_NAN2: u64 = f64::NAN.to_bits() ^ 0x0005_5555_5555_5555;\n+\n+    const_assert!(f64::from_bits(MASKED_NAN1).is_nan());\n+    const_assert!(f64::from_bits(MASKED_NAN1).is_nan());\n+\n+    // See comment above.\n+    if !cfg!(target_arch = \"x86\") {\n+        const_assert!(f64::from_bits(MASKED_NAN1).to_bits(), MASKED_NAN1);\n+        const_assert!(f64::from_bits(MASKED_NAN2).to_bits(), MASKED_NAN2);\n+    }\n+}\n+\n+fn main() {\n+    f32();\n+    f64();\n+}"}, {"sha": "539595db1137e551a794e3a951431bed75a08deb", "filename": "src/test/ui/consts/const-float-classify.rs", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/b65daa7688e919d8cc991d9004d23f4235ee0482/src%2Ftest%2Fui%2Fconsts%2Fconst-float-classify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b65daa7688e919d8cc991d9004d23f4235ee0482/src%2Ftest%2Fui%2Fconsts%2Fconst-float-classify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-float-classify.rs?ref=b65daa7688e919d8cc991d9004d23f4235ee0482", "patch": "@@ -0,0 +1,77 @@\n+// -Zmir-opt-level=0\n+// run-pass\n+\n+#![feature(const_panic)]\n+#![feature(const_float_bits_conv)]\n+#![feature(const_float_classify)]\n+#![feature(const_trait_impl)]\n+#![allow(incomplete_features)]\n+\n+// Don't promote\n+const fn nop<T>(x: T) -> T { x }\n+\n+macro_rules! const_assert {\n+    ($a:expr, $b:expr) => {\n+        {\n+            const _: () = assert!($a == $b);\n+            assert_eq!(nop($a), nop($b));\n+        }\n+    };\n+}\n+\n+macro_rules! suite {\n+    ( $( $tt:tt )* ) => {\n+        fn f32() {\n+            suite_inner!(f32 $($tt)*);\n+        }\n+\n+        fn f64() {\n+            suite_inner!(f64 $($tt)*);\n+        }\n+    }\n+\n+}\n+\n+macro_rules! suite_inner {\n+    (\n+        $ty:ident [$( $fn:ident ),*]\n+        $val:expr => [$($out:ident),*]\n+\n+        $( $tail:tt )*\n+    ) => {\n+        $( const_assert!($ty::$fn($val), $out); )*\n+        suite_inner!($ty [$($fn),*] $($tail)*)\n+    };\n+\n+    ( $ty:ident [$( $fn:ident ),*]) => {};\n+}\n+\n+#[derive(Debug)]\n+struct NonDet;\n+\n+impl const PartialEq<NonDet> for bool {\n+    fn eq(&self, _: &NonDet) -> bool {\n+        true\n+    }\n+}\n+\n+// The result of the `is_sign` methods are not checked for correctness, since LLVM does not\n+// guarantee anything about the signedness of NaNs. See\n+// https://github.com/rust-lang/rust/issues/55131.\n+\n+suite! {\n+                   [is_nan, is_infinite, is_finite, is_normal, is_sign_positive, is_sign_negative]\n+     -0.0 / 0.0 => [  true,       false,     false,     false,           NonDet,           NonDet]\n+      0.0 / 0.0 => [  true,       false,     false,     false,           NonDet,           NonDet]\n+            1.0 => [ false,       false,      true,      true,             true,            false]\n+           -1.0 => [ false,       false,      true,      true,            false,             true]\n+            0.0 => [ false,       false,      true,     false,             true,            false]\n+           -0.0 => [ false,       false,      true,     false,            false,             true]\n+      1.0 / 0.0 => [ false,        true,     false,     false,             true,            false]\n+     -1.0 / 0.0 => [ false,        true,     false,     false,            false,             true]\n+}\n+\n+fn main() {\n+    f32();\n+    f64();\n+}"}]}