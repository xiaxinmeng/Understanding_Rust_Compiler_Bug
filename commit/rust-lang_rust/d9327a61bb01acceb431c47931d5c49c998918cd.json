{"sha": "d9327a61bb01acceb431c47931d5c49c998918cd", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ5MzI3YTYxYmIwMWFjY2ViNDMxYzQ3OTMxZDVjNDljOTk4OTE4Y2Q=", "commit": {"author": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2011-08-12T17:56:57Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-08-16T22:05:56Z"}, "message": "Port the stdlib to the expr foo::<T> syntax.", "tree": {"sha": "f13781115929d2afb3d214872704ab7a3a270d15", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f13781115929d2afb3d214872704ab7a3a270d15"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d9327a61bb01acceb431c47931d5c49c998918cd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d9327a61bb01acceb431c47931d5c49c998918cd", "html_url": "https://github.com/rust-lang/rust/commit/d9327a61bb01acceb431c47931d5c49c998918cd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d9327a61bb01acceb431c47931d5c49c998918cd/comments", "author": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "35204995449ae1fcaf3ed24471dec4a95f9b7951", "url": "https://api.github.com/repos/rust-lang/rust/commits/35204995449ae1fcaf3ed24471dec4a95f9b7951", "html_url": "https://github.com/rust-lang/rust/commit/35204995449ae1fcaf3ed24471dec4a95f9b7951"}], "stats": {"total": 288, "additions": 147, "deletions": 141}, "files": [{"sha": "fc10e40a32743280cceb6c1f8a3821308887c2d3", "filename": "src/lib/aio.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d9327a61bb01acceb431c47931d5c49c998918cd/src%2Flib%2Faio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9327a61bb01acceb431c47931d5c49c998918cd/src%2Flib%2Faio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Faio.rs?ref=d9327a61bb01acceb431c47931d5c49c998918cd", "patch": "@@ -78,8 +78,8 @@ fn new_client(client: client, evt: _chan<socket_event>) {\n         log \"waiting for bytes\";\n         let data: [u8] = reader.recv();\n         log \"got some bytes\";\n-        log vec::len[u8](data);\n-        if (vec::len[u8](data) == 0u) {\n+        log vec::len::<u8>(data);\n+        if (vec::len::<u8>(data) == 0u) {\n             log \"got empty buffer, bailing\";\n             break;\n         }\n@@ -145,7 +145,7 @@ fn request_task(c: _chan<ctx>) {\n           }\n           write(socket,v,status) {\n             rustrt::aio_writedata(socket,\n-                                  vec::to_ptr[u8](v), vec::len[u8](v),\n+                                  vec::to_ptr::<u8>(v), vec::len::<u8>(v),\n                                   status);\n           }\n           close_server(server,status) {"}, {"sha": "74e68fd4b3934a85ffb7e6b53c719702dcb6f287", "filename": "src/lib/bitv.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d9327a61bb01acceb431c47931d5c49c998918cd/src%2Flib%2Fbitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9327a61bb01acceb431c47931d5c49c998918cd/src%2Flib%2Fbitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fbitv.rs?ref=d9327a61bb01acceb431c47931d5c49c998918cd", "patch": "@@ -32,7 +32,7 @@ fn uint_bits() -> uint { ret 32u + (1u << 32u >> 27u); }\n \n fn create(nbits: uint, init: bool) -> t {\n     let elt = if init { !0u } else { 0u };\n-    let storage = vec::init_elt_mut[uint](elt, nbits / uint_bits() + 1u);\n+    let storage = vec::init_elt_mut::<uint>(elt, nbits / uint_bits() + 1u);\n     ret @{storage: storage, nbits: nbits};\n }\n \n@@ -69,7 +69,7 @@ fn assign(v0: &t, v1: t) -> bool {\n }\n \n fn clone(v: t) -> t {\n-    let storage = vec::init_elt_mut[uint](0u, v.nbits / uint_bits() + 1u);\n+    let storage = vec::init_elt_mut::<uint>(0u, v.nbits / uint_bits() + 1u);\n     let len = vec::len(v.storage);\n     for each i: uint in uint::range(0u, len) { storage.(i) = v.storage.(i); }\n     ret @{storage: storage, nbits: v.nbits};\n@@ -150,7 +150,7 @@ fn init_to_vec(v: t, i: uint) -> uint { ret if get(v, i) { 1u } else { 0u }; }\n \n fn to_vec(v: &t) -> [uint] {\n     let sub = bind init_to_vec(v, _);\n-    ret vec::init_fn[uint](sub, v.nbits);\n+    ret vec::init_fn::<uint>(sub, v.nbits);\n }\n \n fn to_str(v: &t) -> str {\n@@ -162,7 +162,7 @@ fn to_str(v: &t) -> str {\n }\n \n fn eq_ivec(v0: &t, v1: &[uint]) -> bool {\n-    assert (v0.nbits == vec::len[uint](v1));\n+    assert (v0.nbits == vec::len::<uint>(v1));\n     let len = v0.nbits;\n     let i = 0u;\n     while i < len {"}, {"sha": "03b719cdc734d2f934b5b63706e0cfb17da71fcc", "filename": "src/lib/comm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d9327a61bb01acceb431c47931d5c49c998918cd/src%2Flib%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9327a61bb01acceb431c47931d5c49c998918cd/src%2Flib%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fcomm.rs?ref=d9327a61bb01acceb431c47931d5c49c998918cd", "patch": "@@ -60,7 +60,7 @@ obj _port<~T>(raw_port : @port_ptr) {\n }\n \n fn mk_port<~T>() -> _port<T> {\n-    _port(@port_ptr(rustrt::new_port(sys::size_of[T]())))\n+    _port(@port_ptr(rustrt::new_port(sys::size_of::<T>())))\n }\n \n fn send<~T>(ch : _chan<T>, data : -T) {"}, {"sha": "ce353edadfa7ab6e64fbcf15a60d00b41d930712", "filename": "src/lib/dbg.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d9327a61bb01acceb431c47931d5c49c998918cd/src%2Flib%2Fdbg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9327a61bb01acceb431c47931d5c49c998918cd/src%2Flib%2Fdbg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fdbg.rs?ref=d9327a61bb01acceb431c47931d5c49c998918cd", "patch": "@@ -22,13 +22,13 @@ native \"rust\" mod rustrt {\n     fn debug_trap(msg: str);\n }\n \n-fn debug_tydesc[T]() { rustrt::debug_tydesc[T](); }\n+fn debug_tydesc<T>() { rustrt::debug_tydesc::<T>(); }\n \n-fn debug_opaque<T>(x: &T) { rustrt::debug_opaque[T](x); }\n+fn debug_opaque<T>(x: &T) { rustrt::debug_opaque::<T>(x); }\n \n-fn debug_box<T>(x: @T) { rustrt::debug_box[T](x); }\n+fn debug_box<T>(x: @T) { rustrt::debug_box::<T>(x); }\n \n-fn debug_tag<T>(x: &T) { rustrt::debug_tag[T](x); }\n+fn debug_tag<T>(x: &T) { rustrt::debug_tag::<T>(x); }\n \n \n /**\n@@ -41,12 +41,12 @@ fn debug_tag<T>(x: &T) { rustrt::debug_tag[T](x); }\n  * the front of any obj's data tuple.x\n  */\n fn debug_obj<T>(x: &T, nmethods: uint, nbytes: uint) {\n-    rustrt::debug_obj[T](x, nmethods, nbytes);\n+    rustrt::debug_obj::<T>(x, nmethods, nbytes);\n }\n \n-fn debug_fn<T>(x: &T) { rustrt::debug_fn[T](x); }\n+fn debug_fn<T>(x: &T) { rustrt::debug_fn::<T>(x); }\n \n-fn ptr_cast<T, U>(x: @T) -> @U { ret rustrt::debug_ptrcast[T, U](x); }\n+fn ptr_cast<T, U>(x: @T) -> @U { ret rustrt::debug_ptrcast::<T, U>(x); }\n \n fn trap(s: str) { rustrt::debug_trap(s); }\n // Local Variables:"}, {"sha": "19d74f1478999fc6fd7622e7f39d309ad84d719b", "filename": "src/lib/deque.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/d9327a61bb01acceb431c47931d5c49c998918cd/src%2Flib%2Fdeque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9327a61bb01acceb431c47931d5c49c998918cd/src%2Flib%2Fdeque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fdeque.rs?ref=d9327a61bb01acceb431c47931d5c49c998918cd", "patch": "@@ -53,24 +53,24 @@ fn create<@T>() -> t<T> {\n         fn add_front(t: &T) {\n             let oldlo: uint = lo;\n             if lo == 0u {\n-                lo = vec::len[cell<T>](elts) - 1u;\n+                lo = vec::len::<cell<T>>(elts) - 1u;\n             } else { lo -= 1u; }\n             if lo == hi {\n-                elts = grow[T](nelts, oldlo, elts);\n-                lo = vec::len[cell<T>](elts) - 1u;\n+                elts = grow::<T>(nelts, oldlo, elts);\n+                lo = vec::len::<cell<T>>(elts) - 1u;\n                 hi = nelts;\n             }\n-            elts.(lo) = option::some[T](t);\n+            elts.(lo) = option::some::<T>(t);\n             nelts += 1u;\n         }\n         fn add_back(t: &T) {\n             if lo == hi && nelts != 0u {\n-                elts = grow[T](nelts, lo, elts);\n+                elts = grow::<T>(nelts, lo, elts);\n                 lo = 0u;\n                 hi = nelts;\n             }\n-            elts.(hi) = option::some[T](t);\n-            hi = (hi + 1u) % vec::len[cell<T>](elts);\n+            elts.(hi) = option::some::<T>(t);\n+            hi = (hi + 1u) % vec::len::<cell<T>>(elts);\n             nelts += 1u;\n         }\n \n@@ -79,31 +79,31 @@ fn create<@T>() -> t<T> {\n          * that we don't keep anyone's refcount up unexpectedly.\n          */\n         fn pop_front() -> T {\n-            let t: T = get[T](elts, lo);\n-            elts.(lo) = option::none[T];\n-            lo = (lo + 1u) % vec::len[cell<T>](elts);\n+            let t: T = get::<T>(elts, lo);\n+            elts.(lo) = option::none::<T>;\n+            lo = (lo + 1u) % vec::len::<cell<T>>(elts);\n             nelts -= 1u;\n             ret t;\n         }\n         fn pop_back() -> T {\n             if hi == 0u {\n-                hi = vec::len[cell<T>](elts) - 1u;\n+                hi = vec::len::<cell<T>>(elts) - 1u;\n             } else { hi -= 1u; }\n-            let t: T = get[T](elts, hi);\n-            elts.(hi) = option::none[T];\n+            let t: T = get::<T>(elts, hi);\n+            elts.(hi) = option::none::<T>;\n             nelts -= 1u;\n             ret t;\n         }\n-        fn peek_front() -> T { ret get[T](elts, lo); }\n-        fn peek_back() -> T { ret get[T](elts, hi - 1u); }\n+        fn peek_front() -> T { ret get::<T>(elts, lo); }\n+        fn peek_back() -> T { ret get::<T>(elts, hi - 1u); }\n         fn get(i: int) -> T {\n-            let idx: uint = (lo + (i as uint)) % vec::len[cell<T>](elts);\n-            ret get[T](elts, idx);\n+            let idx: uint = (lo + (i as uint)) % vec::len::<cell<T>>(elts);\n+            ret get::<T>(elts, idx);\n         }\n     }\n     let v: [mutable cell<T>] =\n         vec::init_elt_mut(option::none, initial_capacity);\n-    ret deque[T](0u, 0u, 0u, v);\n+    ret deque::<T>(0u, 0u, 0u, v);\n }\n // Local Variables:\n // mode: rust;"}, {"sha": "31814b8d098d3373eb1ad483a6d8afd9c56b5ac0", "filename": "src/lib/ebml.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d9327a61bb01acceb431c47931d5c49c998918cd/src%2Flib%2Febml.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9327a61bb01acceb431c47931d5c49c998918cd/src%2Flib%2Febml.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Febml.rs?ref=d9327a61bb01acceb431c47931d5c49c998918cd", "patch": "@@ -40,7 +40,7 @@ fn vint_at(data: &[u8], start: uint) -> {val: uint, next: uint} {\n }\n \n fn new_doc(data: &@[u8]) -> doc {\n-    ret {data: data, start: 0u, end: vec::len[u8](*data)};\n+    ret {data: data, start: 0u, end: vec::len::<u8>(*data)};\n }\n \n fn doc_at(data: &@[u8], start: uint) -> doc {\n@@ -57,10 +57,10 @@ fn maybe_get_doc(d: doc, tg: uint) -> option::t<doc> {\n         let elt_size = vint_at(*d.data, elt_tag.next);\n         pos = elt_size.next + elt_size.val;\n         if elt_tag.val == tg {\n-            ret some[doc]({data: d.data, start: elt_size.next, end: pos});\n+            ret some::<doc>({data: d.data, start: elt_size.next, end: pos});\n         }\n     }\n-    ret none[doc];\n+    ret none::<doc>;\n }\n \n fn get_doc(d: doc, tg: uint) -> doc {\n@@ -96,7 +96,7 @@ iter tagged_docs(d: doc, tg: uint) -> doc {\n     }\n }\n \n-fn doc_data(d: doc) -> [u8] { ret vec::slice[u8](*d.data, d.start, d.end); }\n+fn doc_data(d: doc) -> [u8] { ret vec::slice::<u8>(*d.data, d.start, d.end); }\n \n fn be_uint_from_bytes(data: &@[u8], start: uint, size: uint) -> uint {\n     let sz = size;\n@@ -167,7 +167,7 @@ fn start_tag(w: &writer, tag_id: uint) {\n }\n \n fn end_tag(w: &writer) {\n-    let last_size_pos = vec::pop[uint](w.size_positions);\n+    let last_size_pos = vec::pop::<uint>(w.size_positions);\n     let cur_pos = w.writer.tell();\n     w.writer.seek(last_size_pos as int, io::seek_set);\n     write_sized_vint(w.writer, cur_pos - last_size_pos - 4u, 4u);"}, {"sha": "dde2e9ec8a3a2b323dedb9e58eec3f281626e407", "filename": "src/lib/extfmt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d9327a61bb01acceb431c47931d5c49c998918cd/src%2Flib%2Fextfmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9327a61bb01acceb431c47931d5c49c998918cd/src%2Flib%2Fextfmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fextfmt.rs?ref=d9327a61bb01acceb431c47931d5c49c998918cd", "patch": "@@ -372,7 +372,7 @@ mod rt {\n \n     // FIXME: This might be useful in str: but needs to be utf8 safe first\n     fn str_init_elt(c: char, n_elts: uint) -> str {\n-        let svec = vec::init_elt[u8](c as u8, n_elts);\n+        let svec = vec::init_elt::<u8>(c as u8, n_elts);\n \n         ret str::unsafe_from_bytes(svec);\n     }"}, {"sha": "acb9a7720484f5ad5fae11d14109b44bcd91fba5", "filename": "src/lib/generic_os.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d9327a61bb01acceb431c47931d5c49c998918cd/src%2Flib%2Fgeneric_os.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9327a61bb01acceb431c47931d5c49c998918cd/src%2Flib%2Fgeneric_os.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fgeneric_os.rs?ref=d9327a61bb01acceb431c47931d5c49c998918cd", "patch": "@@ -6,8 +6,8 @@ import str::sbuf;\n fn getenv(n: str) -> option::t<str> {\n     let s = os::libc::getenv(str::buf(n));\n     ret if s as int == 0 {\n-            option::none[str]\n-        } else { option::some[str](str::str_from_cstr(s)) };\n+            option::none::<str>\n+        } else { option::some::<str>(str::str_from_cstr(s)) };\n }\n \n #[cfg(target_os = \"linux\")]"}, {"sha": "681815881a7d7a874439861a0bafdc0e28ea9ca3", "filename": "src/lib/getopts.rs", "status": "modified", "additions": 21, "deletions": 20, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/d9327a61bb01acceb431c47931d5c49c998918cd/src%2Flib%2Fgetopts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9327a61bb01acceb431c47931d5c49c998918cd/src%2Flib%2Fgetopts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fgetopts.rs?ref=d9327a61bb01acceb431c47931d5c49c998918cd", "patch": "@@ -77,9 +77,9 @@ fn name_str(nm: name) -> str {\n \n fn find_opt(opts: &[opt], nm: name) -> option::t<uint> {\n     let i = 0u;\n-    let l = vec::len[opt](opts);\n-    while i < l { if opts.(i).name == nm { ret some[uint](i); } i += 1u; }\n-    ret none[uint];\n+    let l = vec::len::<opt>(opts);\n+    while i < l { if opts.(i).name == nm { ret some::<uint>(i); } i += 1u; }\n+    ret none::<uint>;\n }\n \n tag fail_ {\n@@ -107,11 +107,11 @@ fn fail_str(f: fail_) -> str {\n tag result { success(match); failure(fail_); }\n \n fn getopts(args: &[str], opts: &[opt]) -> result {\n-    let n_opts = vec::len[opt](opts);\n+    let n_opts = vec::len::<opt>(opts);\n     fn f(x: uint) -> [optval] { ret ~[]; }\n-    let vals = vec::init_fn_mut[[optval]](f, n_opts);\n+    let vals = vec::init_fn_mut::<[optval]>(f, n_opts);\n     let free: [str] = ~[];\n-    let l = vec::len[str](args);\n+    let l = vec::len::<str>(args);\n     let i = 0u;\n     while i < l {\n         let cur = args.(i);\n@@ -124,7 +124,7 @@ fn getopts(args: &[str], opts: &[opt]) -> result {\n             break;\n         } else {\n             let names;\n-            let i_arg = option::none[str];\n+            let i_arg = option::none::<str>;\n             if cur.(1) == '-' as u8 {\n                 let tail = str::slice(cur, 2u, curlen);\n                 let eq = str::index(tail, '=' as u8);\n@@ -133,8 +133,9 @@ fn getopts(args: &[str], opts: &[opt]) -> result {\n                 } else {\n                     names = ~[long(str::slice(tail, 0u, eq as uint))];\n                     i_arg =\n-                        option::some[str](str::slice(tail, (eq as uint) + 1u,\n-                                                     curlen - 2u));\n+                        option::some::<str>(str::slice(tail,\n+                                                       (eq as uint) + 1u,\n+                                                       curlen - 2u));\n                 }\n             } else {\n                 let j = 1u;\n@@ -155,22 +156,22 @@ fn getopts(args: &[str], opts: &[opt]) -> result {\n                 }\n                 alt opts.(optid).hasarg {\n                   no. {\n-                    if !option::is_none[str](i_arg) {\n+                    if !option::is_none::<str>(i_arg) {\n                         ret failure(unexpected_argument(name_str(nm)));\n                     }\n                     vals.(optid) += ~[given];\n                   }\n                   maybe. {\n-                    if !option::is_none[str](i_arg) {\n+                    if !option::is_none::<str>(i_arg) {\n                         vals.(optid) += ~[val(option::get(i_arg))];\n-                    } else if (name_pos < vec::len[name](names) ||\n+                    } else if (name_pos < vec::len::<name>(names) ||\n                                    i + 1u == l || is_arg(args.(i + 1u))) {\n                         vals.(optid) += ~[given];\n                     } else { i += 1u; vals.(optid) += ~[val(args.(i))]; }\n                   }\n                   yes. {\n-                    if !option::is_none[str](i_arg) {\n-                        vals.(optid) += ~[val(option::get[str](i_arg))];\n+                    if !option::is_none::<str>(i_arg) {\n+                        vals.(optid) += ~[val(option::get::<str>(i_arg))];\n                     } else if (i + 1u == l) {\n                         ret failure(argument_missing(name_str(nm)));\n                     } else { i += 1u; vals.(optid) += ~[val(args.(i))]; }\n@@ -182,7 +183,7 @@ fn getopts(args: &[str], opts: &[opt]) -> result {\n     }\n     i = 0u;\n     while i < n_opts {\n-        let n = vec::len[optval](vals.(i));\n+        let n = vec::len::<optval>(vals.(i));\n         let occ = opts.(i).occur;\n         if occ == req {\n             if n == 0u {\n@@ -209,7 +210,7 @@ fn opt_vals(m: &match, nm: str) -> [optval] {\n fn opt_val(m: &match, nm: str) -> optval { ret opt_vals(m, nm).(0); }\n \n fn opt_present(m: &match, nm: str) -> bool {\n-    ret vec::len[optval](opt_vals(m, nm)) > 0u;\n+    ret vec::len::<optval>(opt_vals(m, nm)) > 0u;\n }\n \n fn opt_str(m: &match, nm: str) -> str {\n@@ -226,8 +227,8 @@ fn opt_strs(m: &match, nm: str) -> [str] {\n \n fn opt_maybe_str(m: &match, nm: str) -> option::t<str> {\n     let vals = opt_vals(m, nm);\n-    if vec::len[optval](vals) == 0u { ret none[str]; }\n-    ret alt vals.(0) { val(s) { some[str](s) } _ { none[str] } };\n+    if vec::len::<optval>(vals) == 0u { ret none::<str>; }\n+    ret alt vals.(0) { val(s) { some::<str>(s) } _ { none::<str> } };\n }\n \n \n@@ -236,8 +237,8 @@ fn opt_maybe_str(m: &match, nm: str) -> option::t<str> {\n /// present and an argument was provided.\n fn opt_default(m: &match, nm: str, def: str) -> option::t<str> {\n     let vals = opt_vals(m, nm);\n-    if vec::len[optval](vals) == 0u { ret none[str]; }\n-    ret alt vals.(0) { val(s) { some[str](s) } _ { some[str](def) } }\n+    if vec::len::<optval>(vals) == 0u { ret none::<str>; }\n+    ret alt vals.(0) { val(s) { some::<str>(s) } _ { some::<str>(def) } }\n }\n // Local Variables:\n // mode: rust;"}, {"sha": "0778a64e3f1e572055ec56286dce1c5e41c0dba8", "filename": "src/lib/io.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/d9327a61bb01acceb431c47931d5c49c998918cd/src%2Flib%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9327a61bb01acceb431c47931d5c49c998918cd/src%2Flib%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fio.rs?ref=d9327a61bb01acceb431c47931d5c49c998918cd", "patch": "@@ -62,9 +62,9 @@ resource FILE_res(f: os::libc::FILE) {\n obj FILE_buf_reader(f: os::libc::FILE, res: option::t<@FILE_res>) {\n     fn read(len: uint) -> [u8] {\n         let buf = ~[];\n-        vec::reserve[u8](buf, len);\n-        let read = os::libc::fread(vec::to_ptr[u8](buf), 1u, len, f);\n-        vec::unsafe::set_len[u8](buf, read);\n+        vec::reserve::<u8>(buf, len);\n+        let read = os::libc::fread(vec::to_ptr::<u8>(buf), 1u, len, f);\n+        vec::unsafe::set_len::<u8>(buf, read);\n         ret buf;\n     }\n     fn read_byte() -> int { ret os::libc::fgetc(f); }\n@@ -196,24 +196,24 @@ type byte_buf = @{buf: [u8], mutable pos: uint};\n \n obj byte_buf_reader(bbuf: byte_buf) {\n     fn read(len: uint) -> [u8] {\n-        let rest = vec::len[u8](bbuf.buf) - bbuf.pos;\n+        let rest = vec::len::<u8>(bbuf.buf) - bbuf.pos;\n         let to_read = len;\n         if rest < to_read { to_read = rest; }\n-        let range = vec::slice[u8](bbuf.buf, bbuf.pos, bbuf.pos + to_read);\n+        let range = vec::slice::<u8>(bbuf.buf, bbuf.pos, bbuf.pos + to_read);\n         bbuf.pos += to_read;\n         ret range;\n     }\n     fn read_byte() -> int {\n-        if bbuf.pos == vec::len[u8](bbuf.buf) { ret -1; }\n+        if bbuf.pos == vec::len::<u8>(bbuf.buf) { ret -1; }\n         let b = bbuf.buf.(bbuf.pos);\n         bbuf.pos += 1u;\n         ret b as int;\n     }\n     fn unread_byte(byte: int) { log_err \"TODO: unread_byte\"; fail; }\n-    fn eof() -> bool { ret bbuf.pos == vec::len[u8](bbuf.buf); }\n+    fn eof() -> bool { ret bbuf.pos == vec::len::<u8>(bbuf.buf); }\n     fn seek(offset: int, whence: seek_style) {\n         let pos = bbuf.pos;\n-        let len = vec::len[u8](bbuf.buf);\n+        let len = vec::len::<u8>(bbuf.buf);\n         bbuf.pos = seek_in_buf(offset, pos, len, whence);\n     }\n     fn tell() -> uint { ret bbuf.pos; }\n@@ -245,8 +245,8 @@ type buf_writer =\n \n obj FILE_writer(f: os::libc::FILE, res: option::t<@FILE_res>) {\n     fn write(v: &[u8]) {\n-        let len = vec::len[u8](v);\n-        let vbuf = vec::to_ptr[u8](v);\n+        let len = vec::len::<u8>(v);\n+        let vbuf = vec::to_ptr::<u8>(v);\n         let nout = os::libc::fwrite(vbuf, len, 1u, f);\n         if nout < 1u { log_err \"error dumping buffer\"; }\n     }\n@@ -264,11 +264,11 @@ resource fd_res(fd: int) {\n \n obj fd_buf_writer(fd: int, res: option::t<@fd_res>) {\n     fn write(v: &[u8]) {\n-        let len = vec::len[u8](v);\n+        let len = vec::len::<u8>(v);\n         let count = 0u;\n         let vbuf;\n         while count < len {\n-            vbuf = ptr::offset(vec::to_ptr[u8](v), count);\n+            vbuf = ptr::offset(vec::to_ptr::<u8>(v), count);\n             let nout = os::libc::write(fd, vbuf, len);\n             if nout < 0 {\n                 log_err \"error dumping buffer\";\n@@ -403,12 +403,12 @@ obj byte_buf_writer(buf: mutable_byte_buf) {\n \n         if buf.pos == vec::len(buf.buf) {\n             for b: u8 in v { buf.buf += ~[mutable b]; }\n-            buf.pos += vec::len[u8](v);\n+            buf.pos += vec::len::<u8>(v);\n             ret;\n         }\n         // FIXME: Optimize: These should be unique pointers.\n \n-        let vlen = vec::len[u8](v);\n+        let vlen = vec::len::<u8>(v);\n         let vpos = 0u;\n         while vpos < vlen {\n             let b = v.(vpos);"}, {"sha": "7856fc800f261945b850d4cfe3cf337723df7bcb", "filename": "src/lib/list.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d9327a61bb01acceb431c47931d5c49c998918cd/src%2Flib%2Flist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9327a61bb01acceb431c47931d5c49c998918cd/src%2Flib%2Flist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Flist.rs?ref=d9327a61bb01acceb431c47931d5c49c998918cd", "patch": "@@ -4,12 +4,12 @@ import option::none;\n tag list<T> { cons(T, @list<T>); nil; }\n \n fn from_vec<@T>(v: &[T]) -> list<T> {\n-    let l = nil[T];\n+    let l = nil::<T>;\n     // FIXME: This would be faster and more space efficient if it looped over\n     // a reverse vector iterator. Unfortunately generic iterators seem not to\n     // work yet.\n \n-    for item: T in vec::reversed(v) { l = cons[T](item, @l); }\n+    for item: T in vec::reversed(v) { l = cons::<T>(item, @l); }\n     ret l;\n }\n "}, {"sha": "3f92503e5892ed31aaebc70e92f5781f2a950031", "filename": "src/lib/map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d9327a61bb01acceb431c47931d5c49c998918cd/src%2Flib%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9327a61bb01acceb431c47931d5c49c998918cd/src%2Flib%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fmap.rs?ref=d9327a61bb01acceb431c47931d5c49c998918cd", "patch": "@@ -27,7 +27,7 @@ fn mk_hashmap<@K, @V>(hasher: &hashfn<K>, eqer: &eqfn<K>) -> hashmap<K, V> {\n     let load_factor: util::rational = {num: 3, den: 4};\n     tag bucket<@K, @V> { nil; deleted; some(K, V); }\n     fn make_buckets<@K, @V>(nbkts: uint) -> [mutable (bucket<K, V>)] {\n-        ret vec::init_elt_mut[bucket<K, V>](nil[K, V], nbkts);\n+        ret vec::init_elt_mut::<bucket<K, V>>(nil::<K, V>, nbkts);\n     }\n     // Derive two hash functions from the one given by taking the upper\n     // half and lower half of the uint bits.  Our bucket probing"}, {"sha": "43ade4a7703090fff5c2fce872dff71aa0f4e177", "filename": "src/lib/posix_fs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d9327a61bb01acceb431c47931d5c49c998918cd/src%2Flib%2Fposix_fs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9327a61bb01acceb431c47931d5c49c998918cd/src%2Flib%2Fposix_fs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fposix_fs.rs?ref=d9327a61bb01acceb431c47931d5c49c998918cd", "patch": "@@ -24,7 +24,7 @@ fn list_dir(path: str) -> [str] {\n             os::libc::closedir(dir);\n             ret result;\n         }\n-        vec::push[str](result, rustrt::rust_dirent_filename(ent));\n+        vec::push::<str>(result, rustrt::rust_dirent_filename(ent));\n     }\n     os::libc::closedir(dir);\n     ret result;"}, {"sha": "99c0f1276d1daa5390eab3010324e9f82e33c326", "filename": "src/lib/sha1.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d9327a61bb01acceb431c47931d5c49c998918cd/src%2Flib%2Fsha1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9327a61bb01acceb431c47931d5c49c998918cd/src%2Flib%2Fsha1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fsha1.rs?ref=d9327a61bb01acceb431c47931d5c49c998918cd", "patch": "@@ -248,13 +248,13 @@ fn mk_sha1() -> sha1 {\n         }\n     }\n     let st =\n-        {h: vec::init_elt_mut[u32](0u32, digest_buf_len),\n+        {h: vec::init_elt_mut::<u32>(0u32, digest_buf_len),\n          mutable len_low: 0u32,\n          mutable len_high: 0u32,\n-         msg_block: vec::init_elt_mut[u8](0u8, msg_block_len),\n+         msg_block: vec::init_elt_mut::<u8>(0u8, msg_block_len),\n          mutable msg_block_idx: 0u,\n          mutable computed: false,\n-         work_buf: vec::init_elt_mut[u32](0u32, work_buf_len)};\n+         work_buf: vec::init_elt_mut::<u32>(0u32, work_buf_len)};\n     let sh = sha1(st);\n     sh.reset();\n     ret sh;"}, {"sha": "6eca2eccc234d198ec0d8f715b09f21eb2f698ec", "filename": "src/lib/smallintmap.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d9327a61bb01acceb431c47931d5c49c998918cd/src%2Flib%2Fsmallintmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9327a61bb01acceb431c47931d5c49c998918cd/src%2Flib%2Fsmallintmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fsmallintmap.rs?ref=d9327a61bb01acceb431c47931d5c49c998918cd", "patch": "@@ -15,30 +15,30 @@ fn mk<@T>() -> smallintmap<T> {\n }\n \n fn insert<@T>(m: &smallintmap<T>, key: uint, val: &T) {\n-    vec::grow_set[option::t<T>](m.v, key, none[T], some[T](val));\n+    vec::grow_set::<option::t<T>>(m.v, key, none::<T>, some::<T>(val));\n }\n \n fn find<@T>(m: &smallintmap<T>, key: uint) -> option::t<T> {\n-    if key < vec::len[option::t<T>](m.v) { ret m.v.(key); }\n-    ret none[T];\n+    if key < vec::len::<option::t<T>>(m.v) { ret m.v.(key); }\n+    ret none::<T>;\n }\n \n fn get<@T>(m: &smallintmap<T>, key: uint) -> T {\n-    alt find[T](m, key) {\n-      none[T]. { log_err \"smallintmap::get(): key not present\"; fail; }\n-      some[T](v) { ret v; }\n+    alt find::<T>(m, key) {\n+      none::<T>. { log_err \"smallintmap::get(): key not present\"; fail; }\n+      some::<T>(v) { ret v; }\n     }\n }\n \n fn contains_key<@T>(m: &smallintmap<T>, key: uint) -> bool {\n-    ret !option::is_none(find[T](m, key));\n+    ret !option::is_none(find::<T>(m, key));\n }\n \n fn truncate<@T>(m: &smallintmap<T>, len: uint) {\n-    m.v = vec::slice_mut[option::t<T>](m.v, 0u, len);\n+    m.v = vec::slice_mut::<option::t<T>>(m.v, 0u, len);\n }\n \n fn max_key<T>(m: &smallintmap<T>) -> uint {\n-    ret vec::len[option::t<T>](m.v);\n+    ret vec::len::<option::t<T>>(m.v);\n }\n "}, {"sha": "137cf0495ca71d69b2878bc6abc3701e87fb669f", "filename": "src/lib/sort.rs", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/d9327a61bb01acceb431c47931d5c49c998918cd/src%2Flib%2Fsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9327a61bb01acceb431c47931d5c49c998918cd/src%2Flib%2Fsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fsort.rs?ref=d9327a61bb01acceb431c47931d5c49c998918cd", "patch": "@@ -11,26 +11,26 @@ type lteq<T> = block(&T, &T) -> bool ;\n fn merge_sort<@T>(le: &lteq<T>, v: &[T]) -> [T] {\n     fn merge<@T>(le: &lteq<T>, a: &[T], b: &[T]) -> [T] {\n         let rs: [T] = ~[];\n-        let a_len: uint = len[T](a);\n+        let a_len: uint = len::<T>(a);\n         let a_ix: uint = 0u;\n-        let b_len: uint = len[T](b);\n+        let b_len: uint = len::<T>(b);\n         let b_ix: uint = 0u;\n         while a_ix < a_len && b_ix < b_len {\n             if le(a.(a_ix), b.(b_ix)) {\n                 rs += ~[a.(a_ix)];\n                 a_ix += 1u;\n             } else { rs += ~[b.(b_ix)]; b_ix += 1u; }\n         }\n-        rs += slice[T](a, a_ix, a_len);\n-        rs += slice[T](b, b_ix, b_len);\n+        rs += slice::<T>(a, a_ix, a_len);\n+        rs += slice::<T>(b, b_ix, b_len);\n         ret rs;\n     }\n-    let v_len: uint = len[T](v);\n+    let v_len: uint = len::<T>(v);\n     if v_len <= 1u { ret v; }\n     let mid: uint = v_len / 2u;\n-    let a: [T] = slice[T](v, 0u, mid);\n-    let b: [T] = slice[T](v, mid, v_len);\n-    ret merge[T](le, merge_sort[T](le, a), merge_sort[T](le, b));\n+    let a: [T] = slice::<T>(v, 0u, mid);\n+    let b: [T] = slice::<T>(v, mid, v_len);\n+    ret merge::<T>(le, merge_sort::<T>(le, a), merge_sort::<T>(le, b));\n }\n \n fn swap<@T>(arr: &[mutable T], x: uint, y: uint) {\n@@ -42,36 +42,36 @@ fn swap<@T>(arr: &[mutable T], x: uint, y: uint) {\n fn part<@T>(compare_func: &lteq<T>, arr: &[mutable T], left: uint,\n             right: uint, pivot: uint) -> uint {\n     let pivot_value = arr.(pivot);\n-    swap[T](arr, pivot, right);\n+    swap::<T>(arr, pivot, right);\n     let storage_index: uint = left;\n     let i: uint = left;\n     while i < right {\n         if compare_func({ arr.(i) }, pivot_value) {\n-            swap[T](arr, i, storage_index);\n+            swap::<T>(arr, i, storage_index);\n             storage_index += 1u;\n         }\n         i += 1u;\n     }\n-    swap[T](arr, storage_index, right);\n+    swap::<T>(arr, storage_index, right);\n     ret storage_index;\n }\n \n fn qsort<@T>(compare_func: &lteq<T>, arr: &[mutable T], left: uint,\n              right: uint) {\n     if right > left {\n         let pivot = (left + right) / 2u;\n-        let new_pivot = part[T](compare_func, arr, left, right, pivot);\n+        let new_pivot = part::<T>(compare_func, arr, left, right, pivot);\n         if new_pivot != 0u {\n             // Need to do this check before recursing due to overflow\n-            qsort[T](compare_func, arr, left, new_pivot - 1u);\n+            qsort::<T>(compare_func, arr, left, new_pivot - 1u);\n         }\n-        qsort[T](compare_func, arr, new_pivot + 1u, right);\n+        qsort::<T>(compare_func, arr, new_pivot + 1u, right);\n     }\n }\n \n fn quick_sort<@T>(compare_func: &lteq<T>, arr: &[mutable T]) {\n-    if len[T](arr) == 0u { ret; }\n-    qsort[T](compare_func, arr, 0u, len[T](arr) - 1u);\n+    if len::<T>(arr) == 0u { ret; }\n+    qsort::<T>(compare_func, arr, 0u, len::<T>(arr) - 1u);\n }\n \n \n@@ -96,42 +96,42 @@ fn qsort3<@T>(compare_func_lt: &lteq<T>, compare_func_eq: &lteq<T>,\n             j -= 1;\n         }\n         if i >= j { break; }\n-        swap[T](arr, i as uint, j as uint);\n+        swap::<T>(arr, i as uint, j as uint);\n         if compare_func_eq({ arr.(i) }, v) {\n             p += 1;\n-            swap[T](arr, p as uint, i as uint);\n+            swap::<T>(arr, p as uint, i as uint);\n         }\n         if compare_func_eq(v, { arr.(j) }) {\n             q -= 1;\n-            swap[T](arr, j as uint, q as uint);\n+            swap::<T>(arr, j as uint, q as uint);\n         }\n     }\n-    swap[T](arr, i as uint, right as uint);\n+    swap::<T>(arr, i as uint, right as uint);\n     j = i - 1;\n     i += 1;\n     let k: int = left;\n     while k < p {\n-        swap[T](arr, k as uint, j as uint);\n+        swap::<T>(arr, k as uint, j as uint);\n         k += 1;\n         j -= 1;\n-        if k == len[T](arr) as int { break; }\n+        if k == len::<T>(arr) as int { break; }\n     }\n     k = right - 1;\n     while k > q {\n-        swap[T](arr, i as uint, k as uint);\n+        swap::<T>(arr, i as uint, k as uint);\n         k -= 1;\n         i += 1;\n         if k == 0 { break; }\n     }\n-    qsort3[T](compare_func_lt, compare_func_eq, arr, left, j);\n-    qsort3[T](compare_func_lt, compare_func_eq, arr, i, right);\n+    qsort3::<T>(compare_func_lt, compare_func_eq, arr, left, j);\n+    qsort3::<T>(compare_func_lt, compare_func_eq, arr, i, right);\n }\n \n fn quick_sort3<@T>(compare_func_lt: &lteq<T>, compare_func_eq: &lteq<T>,\n                    arr: &[mutable T]) {\n-    if len[T](arr) == 0u { ret; }\n-    qsort3[T](compare_func_lt, compare_func_eq, arr, 0,\n-              (len[T](arr) as int) - 1);\n+    if len::<T>(arr) == 0u { ret; }\n+    qsort3::<T>(compare_func_lt, compare_func_eq, arr, 0,\n+              (len::<T>(arr) as int) - 1);\n }\n \n // Local Variables:"}, {"sha": "df9f68173439744b28fbb4a41735c0583135be2e", "filename": "src/lib/str.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d9327a61bb01acceb431c47931d5c49c998918cd/src%2Flib%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9327a61bb01acceb431c47931d5c49c998918cd/src%2Flib%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fstr.rs?ref=d9327a61bb01acceb431c47931d5c49c998918cd", "patch": "@@ -132,7 +132,7 @@ const tag_six_b: uint = 252u;\n \n fn is_utf8(v: &[u8]) -> bool {\n     let i = 0u;\n-    let total = vec::len[u8](v);\n+    let total = vec::len::<u8>(v);\n     while i < total {\n         let chsize = utf8_char_width(v.(i));\n         if chsize == 0u { ret false; }\n@@ -329,7 +329,7 @@ fn shift_char(s: &mutable str) -> char {\n fn unshift_char(s: &mutable str, ch: char) { s = from_char(ch) + s; }\n \n fn refcount(s: str) -> uint {\n-    let r = rustrt::refcount[u8](s);\n+    let r = rustrt::refcount::<u8>(s);\n     if r == dbg::const_refcount { ret r; } else { ret r - 1u; }\n }\n "}, {"sha": "12e85a98b7c0ef5a2b7f953886f2fc4dcc445a7a", "filename": "src/lib/ufind.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d9327a61bb01acceb431c47931d5c49c998918cd/src%2Flib%2Fufind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9327a61bb01acceb431c47931d5c49c998918cd/src%2Flib%2Fufind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fufind.rs?ref=d9327a61bb01acceb431c47931d5c49c998918cd", "patch": "@@ -14,7 +14,7 @@ fn make() -> ufind { ret {mutable nodes: ~[mutable]}; }\n \n fn make_set(ufnd: &ufind) -> uint {\n     let idx = vec::len(ufnd.nodes);\n-    ufnd.nodes += ~[mutable none[uint]];\n+    ufnd.nodes += ~[mutable none::<uint>];\n     ret idx;\n }\n \n@@ -36,17 +36,19 @@ fn union(ufnd: &ufind, m: uint, n: uint) {\n     let m_root = find(ufnd, m);\n     let n_root = find(ufnd, n);\n     if m_root < n_root {\n-        ufnd.nodes.(n_root) = some[uint](m_root);\n-    } else if (m_root > n_root) { ufnd.nodes.(m_root) = some[uint](n_root); }\n+        ufnd.nodes.(n_root) = some::<uint>(m_root);\n+    } else if (m_root > n_root) {\n+        ufnd.nodes.(m_root) = some::<uint>(n_root);\n+    }\n }\n \n-fn set_count(ufnd: &ufind) -> uint { ret vec::len[node](ufnd.nodes); }\n+fn set_count(ufnd: &ufind) -> uint { ret vec::len::<node>(ufnd.nodes); }\n \n \n // Removes all sets with IDs greater than or equal to the given value.\n fn prune(ufnd: &ufind, n: uint) {\n     // TODO: Use \"slice\" once we get rid of \"mutable?\"\n \n-    let len = vec::len[node](ufnd.nodes);\n-    while len != n { vec::pop[node](ufnd.nodes); len -= 1u; }\n+    let len = vec::len::<node>(ufnd.nodes);\n+    while len != n { vec::pop::<node>(ufnd.nodes); len -= 1u; }\n }"}, {"sha": "8be0df57fd7a6ae22fdad8f824aae92da18c6869", "filename": "src/lib/uint.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d9327a61bb01acceb431c47931d5c49c998918cd/src%2Flib%2Fuint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9327a61bb01acceb431c47931d5c49c998918cd/src%2Flib%2Fuint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fuint.rs?ref=d9327a61bb01acceb431c47931d5c49c998918cd", "patch": "@@ -35,16 +35,19 @@ fn next_power_of_two(n: uint) -> uint {\n     // FIXME change |* uint(4)| below to |* uint(8) / uint(2)| and watch the\n     // world explode.\n \n-    let halfbits: uint = sys::rustrt::size_of[uint]() * 4u;\n+    let halfbits: uint = sys::rustrt::size_of::<uint>() * 4u;\n     let tmp: uint = n - 1u;\n     let shift: uint = 1u;\n     while shift <= halfbits { tmp |= tmp >> shift; shift <<= 1u; }\n     ret tmp + 1u;\n }\n \n fn parse_buf(buf: &[u8], radix: uint) -> uint {\n-    if vec::len[u8](buf) == 0u { log_err \"parse_buf(): buf is empty\"; fail; }\n-    let i = vec::len[u8](buf) - 1u;\n+    if vec::len::<u8>(buf) == 0u {\n+        log_err \"parse_buf(): buf is empty\";\n+        fail;\n+    }\n+    let i = vec::len::<u8>(buf) - 1u;\n     let power = 1u;\n     let n = 0u;\n     while true {"}, {"sha": "dc0dab58d0ca10579d8e3c8a2d548cd800982b92", "filename": "src/lib/vec.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/d9327a61bb01acceb431c47931d5c49c998918cd/src%2Flib%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9327a61bb01acceb431c47931d5c49c998918cd/src%2Flib%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fvec.rs?ref=d9327a61bb01acceb431c47931d5c49c998918cd", "patch": "@@ -135,10 +135,10 @@ fn slice_mut<@T>(v: &[mutable? T], start: uint, end: uint) -> [mutable T] {\n // Mutators\n \n fn shift<@T>(v: &mutable [mutable? T]) -> T {\n-    let ln = len[T](v);\n+    let ln = len::<T>(v);\n     assert (ln > 0u);\n     let e = v.(0);\n-    v = slice[T](v, 1u, ln);\n+    v = slice::<T>(v, 1u, ln);\n     ret e;\n }\n \n@@ -202,8 +202,8 @@ fn map<@T, @U>(f: &block(&T) -> U , v: &[mutable? T]) -> [U] {\n \n fn map2<@T, @U, @V>(f: &block(&T, &U) -> V, v0: &[T], v1: &[U])\n     -> [V] {\n-    let v0_len = len[T](v0);\n-    if v0_len != len[U](v1) { fail; }\n+    let v0_len = len::<T>(v0);\n+    if v0_len != len::<U>(v1) { fail; }\n     let u: [V] = ~[];\n     let i = 0u;\n     while i < v0_len { u += ~[f({ v0.(i) }, { v1.(i) })]; i += 1u; }\n@@ -259,14 +259,14 @@ fn find<@T>(f: &block(&T) -> bool, v: &[T]) -> option::t<T> {\n \n fn position<@T>(x: &T, v: &[T]) -> option::t<uint> {\n     let i: uint = 0u;\n-    while i < len(v) { if x == v.(i) { ret some[uint](i); } i += 1u; }\n-    ret none[uint];\n+    while i < len(v) { if x == v.(i) { ret some::<uint>(i); } i += 1u; }\n+    ret none;\n }\n \n fn position_pred<T>(f: fn(&T) -> bool, v: &[T]) -> option::t<uint> {\n     let i: uint = 0u;\n-    while i < len(v) { if f(v.(i)) { ret some[uint](i); } i += 1u; }\n-    ret none[uint];\n+    while i < len(v) { if f(v.(i)) { ret some::<uint>(i); } i += 1u; }\n+    ret none;\n }\n \n fn unzip<@T, @U>(v: &[(T, U)]) -> ([T], [U]) {\n@@ -300,15 +300,15 @@ fn swap<@T>(v: &[mutable T], a: uint, b: uint) {\n // In place vector reversal\n fn reverse<@T>(v: &[mutable T]) {\n     let i: uint = 0u;\n-    let ln = len[T](v);\n+    let ln = len::<T>(v);\n     while i < ln / 2u { swap(v, i, ln - i - 1u); i += 1u; }\n }\n \n \n // Functional vector reversal. Returns a reversed copy of v.\n fn reversed<@T>(v: &[T]) -> [T] {\n     let rs: [T] = ~[];\n-    let i = len[T](v);\n+    let i = len::<T>(v);\n     if i == 0u { ret rs; } else { i -= 1u; }\n     while i != 0u { rs += ~[v.(i)]; i -= 1u; }\n     rs += ~[v.(0)];\n@@ -334,7 +334,7 @@ mod unsafe {\n     }\n \n     fn set_len<T>(v: &mutable [T], new_len: uint) {\n-        let new_fill = new_len * sys::size_of[T]();\n+        let new_fill = new_len * sys::size_of::<T>();\n         let stack_part: *mutable ivec_repr =\n             ::unsafe::reinterpret_cast(addr_of(v));\n         if (*stack_part).fill == 0u {"}]}