{"sha": "674dd14eec29cc28c69c9eff1e22ffd4ddf83f84", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY3NGRkMTRlZWMyOWNjMjhjNjljOWVmZjFlMjJmZmQ0ZGRmODNmODQ=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-07-23T17:11:10Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-07-23T20:24:05Z"}, "message": "rustc: Make vtables use the coherence tables", "tree": {"sha": "481eb7d98a7f627da89332519965ca03ebbb8027", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/481eb7d98a7f627da89332519965ca03ebbb8027"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/674dd14eec29cc28c69c9eff1e22ffd4ddf83f84", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/674dd14eec29cc28c69c9eff1e22ffd4ddf83f84", "html_url": "https://github.com/rust-lang/rust/commit/674dd14eec29cc28c69c9eff1e22ffd4ddf83f84", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/674dd14eec29cc28c69c9eff1e22ffd4ddf83f84/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "81f108154a9b419427363484a35423462abdb1b5", "url": "https://api.github.com/repos/rust-lang/rust/commits/81f108154a9b419427363484a35423462abdb1b5", "html_url": "https://github.com/rust-lang/rust/commit/81f108154a9b419427363484a35423462abdb1b5"}], "stats": {"total": 183, "additions": 107, "deletions": 76}, "files": [{"sha": "51a412be718d3ca7c0d94472772f8be68987689e", "filename": "src/rustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 76, "deletions": 71, "changes": 147, "blob_url": "https://github.com/rust-lang/rust/blob/674dd14eec29cc28c69c9eff1e22ffd4ddf83f84/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/674dd14eec29cc28c69c9eff1e22ffd4ddf83f84/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=674dd14eec29cc28c69c9eff1e22ffd4ddf83f84", "patch": "@@ -1,6 +1,7 @@\n import check::{fn_ctxt, impl_self_ty, methods};\n import infer::{resolve_type, resolve_all, force_all, fixup_err_to_str};\n import ast_util::new_def_hash;\n+import dvec::extensions;\n \n fn has_trait_bounds(tps: ~[ty::param_bounds]) -> bool {\n     vec::any(tps, |bs| {\n@@ -10,7 +11,7 @@ fn has_trait_bounds(tps: ~[ty::param_bounds]) -> bool {\n     })\n }\n \n-fn lookup_vtables(fcx: @fn_ctxt, isc: resolve3::ImplScopes, sp: span,\n+fn lookup_vtables(fcx: @fn_ctxt, sp: span,\n                   bounds: @~[ty::param_bounds], substs: ty::substs,\n                   allow_unsafe: bool) -> vtable_res {\n     let tcx = fcx.ccx.tcx;\n@@ -20,8 +21,8 @@ fn lookup_vtables(fcx: @fn_ctxt, isc: resolve3::ImplScopes, sp: span,\n             alt bound {\n               ty::bound_trait(i_ty) {\n                 let i_ty = ty::subst(tcx, substs, i_ty);\n-                vec::push(result, lookup_vtable(fcx, isc, sp, ty, i_ty,\n-                                         allow_unsafe));\n+                vec::push(result, lookup_vtable(fcx, sp, ty, i_ty,\n+                                                allow_unsafe));\n               }\n               _ {}\n             }\n@@ -50,12 +51,10 @@ fn relate_trait_tys(fcx: @fn_ctxt, sp: span,\n /*\n Look up the vtable to use when treating an item of type <t>\n as if it has type <trait_ty>\n-\n-XXX: This doesn't use the coherence tables yet.\n */\n-fn lookup_vtable(fcx: @fn_ctxt, isc: resolve3::ImplScopes, sp: span,\n-                 ty: ty::t, trait_ty: ty::t, allow_unsafe: bool)\n-    -> vtable_origin {\n+fn lookup_vtable(fcx: @fn_ctxt, sp: span, ty: ty::t, trait_ty: ty::t,\n+                 allow_unsafe: bool)\n+              -> vtable_origin {\n \n     #debug[\"lookup_vtable(ty=%s, trait_ty=%s)\",\n            fcx.infcx.ty_to_str(ty), fcx.infcx.ty_to_str(trait_ty)];\n@@ -119,64 +118,72 @@ fn lookup_vtable(fcx: @fn_ctxt, isc: resolve3::ImplScopes, sp: span,\n \n         let mut impls_seen = new_def_hash();\n \n-        for list::each(isc) |impls| {\n-            /* For each impl in scope... */\n-            for vec::each(*impls) |im| {\n-                // im = one specific impl\n+        alt fcx.ccx.coherence_info.extension_methods.find(trait_id) {\n+            none {\n+                // Nothing found. Continue.\n+            }\n+            some(implementations) {\n+                for uint::range(0, implementations.len()) |i| {\n+                    let im = implementations[i];\n \n-                // First, ensure that we haven't processed this impl yet.\n-                if impls_seen.contains_key(im.did) {\n-                    again;\n-                }\n-                impls_seen.insert(im.did, ());\n+                    // im = one specific impl\n \n-                // find the trait that im implements (if any)\n-                for vec::each(ty::impl_traits(tcx, im.did)) |of_ty| {\n-                    // it must have the same id as the expected one\n-                    alt ty::get(of_ty).struct {\n-                      ty::ty_trait(id, _) if id != trait_id { again; }\n-                      _ { /* ok */ }\n+                    // First, ensure that we haven't processed this impl yet.\n+                    if impls_seen.contains_key(im.did) {\n+                        again;\n                     }\n+                    impls_seen.insert(im.did, ());\n \n-                    // check whether the type unifies with the type\n-                    // that the impl is for, and continue if not\n-                    let {substs: substs, ty: for_ty} =\n-                        impl_self_ty(fcx, im.did);\n-                    let im_bs = ty::lookup_item_type(tcx, im.did).bounds;\n-                    alt fcx.mk_subty(ty, for_ty) {\n-                      result::err(_) { again; }\n-                      result::ok(()) { }\n-                    }\n+                    // find the trait that im implements (if any)\n+                    for vec::each(ty::impl_traits(tcx, im.did)) |of_ty| {\n+                        // it must have the same id as the expected one\n+                        alt ty::get(of_ty).struct {\n+                          ty::ty_trait(id, _) if id != trait_id { again; }\n+                          _ { /* ok */ }\n+                        }\n+\n+                        // check whether the type unifies with the type\n+                        // that the impl is for, and continue if not\n+                        let {substs: substs, ty: for_ty} =\n+                            impl_self_ty(fcx, im.did);\n+                        let im_bs = ty::lookup_item_type(tcx, im.did).bounds;\n+                        alt fcx.mk_subty(ty, for_ty) {\n+                          result::err(_) { again; }\n+                          result::ok(()) { }\n+                        }\n \n-                    // check that desired trait type unifies\n-                    #debug(\"(checking vtable) @2 relating trait ty %s to \\\n-                            of_ty %s\",\n-                           fcx.infcx.ty_to_str(trait_ty),\n-                           fcx.infcx.ty_to_str(of_ty));\n-                    let of_ty = ty::subst(tcx, substs, of_ty);\n-                    relate_trait_tys(fcx, sp, trait_ty, of_ty);\n+                        // check that desired trait type unifies\n+                        #debug(\"(checking vtable) @2 relating trait ty %s to \\\n+                                of_ty %s\",\n+                               fcx.infcx.ty_to_str(trait_ty),\n+                               fcx.infcx.ty_to_str(of_ty));\n+                        let of_ty = ty::subst(tcx, substs, of_ty);\n+                        relate_trait_tys(fcx, sp, trait_ty, of_ty);\n \n-                    // recursively process the bounds\n-                    let trait_tps = trait_substs.tps;\n-                    let substs_f = fixup_substs(fcx, sp, trait_id, substs);\n-                    connect_trait_tps(fcx, sp, substs_f.tps,\n-                                      trait_tps, im.did);\n-                    let subres = lookup_vtables(fcx, isc, sp,\n-                                                im_bs, substs_f, false);\n-                    vec::push(found,\n-                              vtable_static(im.did, substs_f.tps, subres));\n+                        // recursively process the bounds\n+                        let trait_tps = trait_substs.tps;\n+                        let substs_f = fixup_substs(fcx, sp, trait_id,\n+                                                    substs);\n+                        connect_trait_tps(fcx, sp, substs_f.tps,\n+                                          trait_tps, im.did);\n+                        let subres = lookup_vtables(fcx, sp, im_bs, substs_f,\n+                                                    false);\n+                        vec::push(found,\n+                                  vtable_static(im.did, substs_f.tps,\n+                                                subres));\n+                    }\n                 }\n             }\n+        }\n \n-            alt found.len() {\n-              0u { /* fallthrough */ }\n-              1u { ret found[0]; }\n-              _ {\n-                fcx.ccx.tcx.sess.span_err(\n-                    sp, ~\"multiple applicable methods in scope\");\n-                ret found[0];\n-              }\n-            }\n+        alt found.len() {\n+          0u { /* fallthrough */ }\n+          1u { ret found[0]; }\n+          _ {\n+            fcx.ccx.tcx.sess.span_err(\n+                sp, ~\"multiple applicable methods in scope\");\n+            ret found[0];\n+          }\n         }\n       }\n     }\n@@ -227,10 +234,11 @@ fn resolve_expr(ex: @ast::expr, &&fcx: @fn_ctxt, v: visit::vt<@fn_ctxt>) {\n             let did = ast_util::def_id_of_def(cx.tcx.def_map.get(ex.id));\n             let item_ty = ty::lookup_item_type(cx.tcx, did);\n             if has_trait_bounds(*item_ty.bounds) {\n-                let impls = cx.impl_map.get(ex.id);\n-                cx.vtable_map.insert(ex.id, lookup_vtables(\n-                    fcx, impls, ex.span,\n-                    item_ty.bounds, substs, false));\n+                cx.vtable_map.insert(ex.id, lookup_vtables(fcx,\n+                                                           ex.span,\n+                                                           item_ty.bounds,\n+                                                           substs,\n+                                                           false));\n             }\n           }\n           _ {}\n@@ -249,9 +257,11 @@ fn resolve_expr(ex: @ast::expr, &&fcx: @fn_ctxt, v: visit::vt<@fn_ctxt>) {\n                   _ { ex.callee_id }\n                 };\n                 let substs = fcx.node_ty_substs(callee_id);\n-                let iscs = cx.impl_map.get(ex.id);\n-                cx.vtable_map.insert(callee_id, lookup_vtables(\n-                    fcx, iscs, ex.span, bounds, substs, false));\n+                cx.vtable_map.insert(callee_id, lookup_vtables(fcx,\n+                                                               ex.span,\n+                                                               bounds,\n+                                                               substs,\n+                                                               false));\n             }\n           }\n           _ {}\n@@ -261,17 +271,12 @@ fn resolve_expr(ex: @ast::expr, &&fcx: @fn_ctxt, v: visit::vt<@fn_ctxt>) {\n         let target_ty = fcx.expr_ty(ex);\n         alt ty::get(target_ty).struct {\n           ty::ty_trait(*) {\n-            /* Casting to an interface type.\n-            Look up all impls for the cast expr...\n-            */\n-            let impls = cx.impl_map.get(ex.id);\n             /*\n             Look up vtables for the type we're casting to,\n             passing in the source and target type\n             */\n-            let vtable = lookup_vtable(fcx, impls, ex.span,\n-                                       fcx.expr_ty(src), target_ty,\n-                                       true);\n+            let vtable = lookup_vtable(fcx, ex.span, fcx.expr_ty(src),\n+                                       target_ty, true);\n             /*\n             Map this expression to that vtable (that is: \"ex has\n             vtable <vtable>\")"}, {"sha": "005f87e601bdb1c00152136965339e64fb4f90c5", "filename": "src/rustc/middle/typeck/coherence.rs", "status": "modified", "additions": 31, "deletions": 5, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/674dd14eec29cc28c69c9eff1e22ffd4ddf83f84/src%2Frustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/674dd14eec29cc28c69c9eff1e22ffd4ddf83f84/src%2Frustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=674dd14eec29cc28c69c9eff1e22ffd4ddf83f84", "patch": "@@ -17,10 +17,10 @@ import middle::ty::{ty_param, ty_self, ty_type, ty_opaque_box};\n import middle::ty::{ty_opaque_closure_ptr, ty_unboxed_vec, type_is_var};\n import middle::typeck::infer::{infer_ctxt, mk_subty};\n import middle::typeck::infer::{new_infer_ctxt, resolve_ivar, resolve_type};\n-import syntax::ast::{crate, def_id, def_mod, item, item_class, item_const};\n-import syntax::ast::{item_enum, item_fn, item_foreign_mod, item_impl};\n-import syntax::ast::{item_mac, item_mod, item_trait, item_ty, local_crate};\n-import syntax::ast::{method, node_id};\n+import syntax::ast::{class_method, crate, def_id, def_mod, instance_var};\n+import syntax::ast::{item, item_class, item_const, item_enum, item_fn};\n+import syntax::ast::{item_foreign_mod, item_impl, item_mac, item_mod};\n+import syntax::ast::{item_trait, item_ty, local_crate, method, node_id};\n import syntax::ast::{trait_ref};\n import syntax::ast_map::node_item;\n import syntax::ast_util::{def_id_of_def, dummy_sp, new_def_hash};\n@@ -161,7 +161,10 @@ class CoherenceChecker {\n                 #debug(\"(checking coherence) item '%s'\", *item.ident);\n \n                 alt item.node {\n-                    item_impl(_, associated_traits, self_type, _) {\n+                    item_impl(_, associated_traits, _, _) {\n+                        self.check_implementation(item, associated_traits);\n+                    }\n+                    item_class(_, associated_traits, _, _, _) {\n                         self.check_implementation(item, associated_traits);\n                     }\n                     _ {\n@@ -499,6 +502,29 @@ class CoherenceChecker {\n                     methods: methods\n                 };\n             }\n+            item_class(ty_params, _, class_members, _, _) {\n+                let mut methods = ~[];\n+                for class_members.each |class_member| {\n+                    alt class_member.node {\n+                        instance_var(*) {\n+                            // Nothing to do.\n+                        }\n+                        class_method(ast_method) {\n+                            push(methods, @{\n+                                did: local_def(ast_method.id),\n+                                n_tps: ast_method.tps.len(),\n+                                ident: ast_method.ident\n+                            });\n+                        }\n+                    }\n+                }\n+\n+                ret @{\n+                    did: local_def(item.id),\n+                    ident: item.ident,\n+                    methods: methods\n+                };\n+            }\n             _ {\n                 self.crate_context.tcx.sess.span_bug(item.span,\n                                                      ~\"can't convert a \\"}]}