{"sha": "2fcfd233f755c548ddc4d5fda517a7dbb9f04ba3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJmY2ZkMjMzZjc1NWM1NDhkZGM0ZDVmZGE1MTdhN2RiYjlmMDRiYTM=", "commit": {"author": {"name": "CAD97", "email": "cad97@cad97.com", "date": "2020-02-18T18:18:33Z"}, "committer": {"name": "CAD97", "email": "cad97@cad97.com", "date": "2020-04-08T06:24:16Z"}, "message": "Redesign the Step trait", "tree": {"sha": "655c31fd84477a56252737868e7c65c965dbaa0f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/655c31fd84477a56252737868e7c65c965dbaa0f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2fcfd233f755c548ddc4d5fda517a7dbb9f04ba3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2fcfd233f755c548ddc4d5fda517a7dbb9f04ba3", "html_url": "https://github.com/rust-lang/rust/commit/2fcfd233f755c548ddc4d5fda517a7dbb9f04ba3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2fcfd233f755c548ddc4d5fda517a7dbb9f04ba3/comments", "author": {"login": "CAD97", "id": 5992217, "node_id": "MDQ6VXNlcjU5OTIyMTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5992217?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CAD97", "html_url": "https://github.com/CAD97", "followers_url": "https://api.github.com/users/CAD97/followers", "following_url": "https://api.github.com/users/CAD97/following{/other_user}", "gists_url": "https://api.github.com/users/CAD97/gists{/gist_id}", "starred_url": "https://api.github.com/users/CAD97/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CAD97/subscriptions", "organizations_url": "https://api.github.com/users/CAD97/orgs", "repos_url": "https://api.github.com/users/CAD97/repos", "events_url": "https://api.github.com/users/CAD97/events{/privacy}", "received_events_url": "https://api.github.com/users/CAD97/received_events", "type": "User", "site_admin": false}, "committer": {"login": "CAD97", "id": 5992217, "node_id": "MDQ6VXNlcjU5OTIyMTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5992217?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CAD97", "html_url": "https://github.com/CAD97", "followers_url": "https://api.github.com/users/CAD97/followers", "following_url": "https://api.github.com/users/CAD97/following{/other_user}", "gists_url": "https://api.github.com/users/CAD97/gists{/gist_id}", "starred_url": "https://api.github.com/users/CAD97/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CAD97/subscriptions", "organizations_url": "https://api.github.com/users/CAD97/orgs", "repos_url": "https://api.github.com/users/CAD97/repos", "events_url": "https://api.github.com/users/CAD97/events{/privacy}", "received_events_url": "https://api.github.com/users/CAD97/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b70e7fd0db5d23a2e045e89b8bc7e5564acce9b7", "url": "https://api.github.com/repos/rust-lang/rust/commits/b70e7fd0db5d23a2e045e89b8bc7e5564acce9b7", "html_url": "https://github.com/rust-lang/rust/commit/b70e7fd0db5d23a2e045e89b8bc7e5564acce9b7"}], "stats": {"total": 798, "additions": 550, "deletions": 248}, "files": [{"sha": "ae88fb471a074042e24fd09b21f4ba02a551ecc0", "filename": "src/libcore/iter/range.rs", "status": "modified", "additions": 434, "deletions": 172, "changes": 606, "blob_url": "https://github.com/rust-lang/rust/blob/2fcfd233f755c548ddc4d5fda517a7dbb9f04ba3/src%2Flibcore%2Fiter%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fcfd233f755c548ddc4d5fda517a7dbb9f04ba3/src%2Flibcore%2Fiter%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Frange.rs?ref=2fcfd233f755c548ddc4d5fda517a7dbb9f04ba3", "patch": "@@ -5,175 +5,423 @@ use crate::usize;\n \n use super::{FusedIterator, TrustedLen};\n \n-/// Objects that can be stepped over in both directions.\n+/// Objects that have a notion of *successor* and *predecessor* operations.\n ///\n-/// The `steps_between` function provides a way to efficiently compare\n-/// two `Step` objects.\n-#[unstable(\n-    feature = \"step_trait\",\n-    reason = \"likely to be replaced by finer-grained traits\",\n-    issue = \"42168\"\n-)]\n-pub trait Step: Clone + PartialOrd + Sized {\n-    /// Returns the number of steps between two step objects. The count is\n-    /// inclusive of `start` and exclusive of `end`.\n-    ///\n-    /// Returns `None` if it is not possible to calculate `steps_between`\n-    /// without overflow.\n+/// The *successor* operation moves towards values that compare greater.\n+/// The *predecessor* operation moves towards values that compare lesser.\n+///\n+/// # Safety\n+///\n+/// This trait is `unsafe` because its implementation must be correct for\n+/// the safety of `unsafe trait TrustedLen` implementations, and the results\n+/// of using this trait can otherwise be trusted by `unsafe` code to be correct\n+/// and fulful the listed obligations.\n+#[unstable(feature = \"step_trait\", reason = \"recently redesigned\", issue = \"42168\")]\n+pub unsafe trait Step: Clone + PartialOrd + Sized {\n+    /// Returns the number of *successor* steps required to get from `start` to `end`.\n+    ///\n+    /// Returns `None` if the number of steps would overflow `usize`\n+    /// (or is infinite, or if `end` would never be reached).\n+    ///\n+    /// # Invariants\n+    ///\n+    /// For any `a`, `b`, and `n`:\n+    ///\n+    /// * `steps_between(&a, &b) == Some(n)` if and only if `Step::forward(&a, n) == Some(b)`\n+    /// * `steps_between(&a, &b) == Some(n)` if and only if `Step::backward(&a, n) == Some(a)`\n+    /// * `steps_between(&a, &b) == Some(n)` only if `a <= b`\n+    ///   * Corollary: `steps_between(&a, &b) == Some(0)` if and only if `a == b`\n+    ///   * Note that `a <= b` does _not_ imply `steps_between(&a, &b) != None`;\n+    ///     this is the case wheen it would require more than `usize::MAX` steps to get to `b`\n+    /// * `steps_between(&a, &b) == None` if `a > b`\n     fn steps_between(start: &Self, end: &Self) -> Option<usize>;\n \n-    /// Replaces this step with `1`, returning a clone of itself.\n+    /// Returns the value that would be obtained by taking the *successor*\n+    /// of `self` `count` times.\n+    ///\n+    /// If this would overflow the range of values supported by `Self`, returns `None`.\n+    ///\n+    /// # Invariants\n     ///\n-    /// The output of this method should always be greater than the output of replace_zero.\n-    fn replace_one(&mut self) -> Self;\n+    /// For any `a`, `n`, and `m`:\n+    ///\n+    /// * `Step::forward_checked(a, n).and_then(|x| Step::forward_checked(x, m)) == n.checked_add(m).and_then(|x| Step::forward_checked(a, x))`\n+    /// * `Step::forward_checked(a, n).and_then(|x| Step::forward_checked(x, m)) == try { Step::forward_checked(a, n.checked_add(m)?) }`\n+    ///\n+    /// For any `a` and `n`:\n+    ///\n+    /// * `Step::forward_checked(a, n) == (0..n).try_fold(a, |x, _| Step::forward_checked(&x, 1))`\n+    ///   * Corollary: `Step::forward_checked(&a, 0) == Some(a)`\n+    #[unstable(feature = \"step_trait_ext\", reason = \"recently added\", issue = \"42168\")]\n+    fn forward_checked(start: Self, count: usize) -> Option<Self>;\n \n-    /// Replaces this step with `0`, returning a clone of itself.\n+    /// Returns the value that would be obtained by taking the *successor*\n+    /// of `self` `count` times.\n+    ///\n+    /// If this would overflow the range of values supported by `Self`,\n+    /// this function is allowed to panic, wrap, or saturate.\n+    /// The suggested behavior is to panic when debug assertions are enabled,\n+    /// and to wrap or saturate otherwise.\n+    ///\n+    /// Unsafe code should not rely on the correctness of behavior after overflow.\n+    ///\n+    /// # Invariants\n+    ///\n+    /// For any `a`, `n`, and `m`, where no overflow occurs:\n     ///\n-    /// The output of this method should always be less than the output of replace_one.\n-    fn replace_zero(&mut self) -> Self;\n+    /// * `Step::forward(Step::forward(a, n), m) == Step::forward(a, n + m)`\n+    ///\n+    /// For any `a` and `n`, where no overflow occurs:\n+    ///\n+    /// * `Step::forward_checked(a, n) == Some(Step::forward(a, n))`\n+    /// * `Step::forward(a, n) == (0..n).fold(a, |x, _| Step::forward(x, 1))`\n+    ///   * Corollary: `Step::forward(a, 0) == a`\n+    /// * `Step::forward(a, n) >= a`\n+    /// * `Step::backward(Step::forward(a, n), n) == a`\n+    #[unstable(feature = \"step_trait_ext\", reason = \"recently added\", issue = \"42168\")]\n+    fn forward(start: Self, count: usize) -> Self {\n+        Step::forward_checked(start, count).expect(\"overflow in `Step::forward`\")\n+    }\n \n-    /// Adds one to this step, returning the result.\n-    fn add_one(&self) -> Self;\n+    /// Returns the value that would be obtained by taking the *successor*\n+    /// of `self` `count` times.\n+    ///\n+    /// # Safety\n+    ///\n+    /// It is undefined behavior for this operation to overflow the\n+    /// range of values supported by `Self`. If you cannot guarantee that this\n+    /// will not overflow, use `forward` or `forward_checked` instead.\n+    ///\n+    /// # Invariants\n+    ///\n+    /// For any `a`:\n+    ///\n+    /// * if there exists `b` such that `b > a`, it is safe to call `Step::forward_unchecked(a, 1)`\n+    /// * if there exists `b`, `n` such that `steps_between(&a, &b) == Some(n)`,\n+    ///   it is safe to call `Step::forward_unchecked(a, m)` for any `m <= n`.\n+    ///\n+    /// For any `a` and `n`, where no overflow occurs:\n+    ///\n+    /// * `Step::forward_unchecked(a, n)` is equivalent to `Step::forward(a, n)`\n+    #[unstable(feature = \"unchecked_math\", reason = \"niche optimization path\", issue = \"none\")]\n+    unsafe fn forward_unchecked(start: Self, count: usize) -> Self {\n+        Step::forward(start, count)\n+    }\n \n-    /// Subtracts one to this step, returning the result.\n-    fn sub_one(&self) -> Self;\n+    /// Returns the value that would be obtained by taking the *successor*\n+    /// of `self` `count` times.\n+    ///\n+    /// If this would overflow the range of values supported by `Self`, returns `None`.\n+    ///\n+    /// # Invariants\n+    ///\n+    /// For any `a`, `n`, and `m`:\n+    ///\n+    /// * `Step::backward_checked(a, n).and_then(|x| Step::backward_checked(x, m)) == n.checked_add(m).and_then(|x| Step::backward_checked(a, x))`\n+    /// * `Step::backward_checked(a, n).and_then(|x| Step::backward_checked(x, m)) == try { Step::backward_checked(a, n.checked_add(m)?) }`\n+    ///\n+    /// For any `a` and `n`:\n+    ///\n+    /// * `Step::backward_checked(a, n) == (0..n).try_fold(a, |x, _| Step::backward_checked(&x, 1))`\n+    ///   * Corollary: `Step::backward_checked(&a, 0) == Some(a)`\n+    #[unstable(feature = \"step_trait_ext\", reason = \"recently added\", issue = \"42168\")]\n+    fn backward_checked(start: Self, count: usize) -> Option<Self>;\n \n-    /// Adds a `usize`, returning `None` on overflow.\n-    fn add_usize(&self, n: usize) -> Option<Self>;\n+    /// Returns the value that would be obtained by taking the *predecessor*\n+    /// of `self` `count` times.\n+    ///\n+    /// If this would overflow the range of values supported by `Self`,\n+    /// this function is allowed to panic, wrap, or saturate.\n+    /// The suggested behavior is to panic when debug assertions are enabled,\n+    /// and to wrap or saturate otherwise.\n+    ///\n+    /// Unsafe code should not rely on the correctness of behavior after overflow.\n+    ///\n+    /// # Invariants\n+    ///\n+    /// For any `a`, `n`, and `m`, where no overflow occurs:\n+    ///\n+    /// * `Step::backward(Step::backward(a, n), m) == Step::backward(a, n + m)`\n+    ///\n+    /// For any `a` and `n`, where no overflow occurs:\n+    ///\n+    /// * `Step::backward_checked(a, n) == Some(Step::backward(a, n))`\n+    /// * `Step::backward(a, n) == (0..n).fold(a, |x, _| Step::backward(x, 1))`\n+    ///   * Corollary: `Step::backward(a, 0) == a`\n+    /// * `Step::backward(a, n) <= a`\n+    /// * `Step::forward(Step::backward(a, n), n) == a`\n+    #[unstable(feature = \"step_trait_ext\", reason = \"recently added\", issue = \"42168\")]\n+    fn backward(start: Self, count: usize) -> Self {\n+        Step::backward_checked(start, count).expect(\"overflow in `Step::backward`\")\n+    }\n \n-    /// Subtracts a `usize`, returning `None` on underflow.\n-    fn sub_usize(&self, n: usize) -> Option<Self> {\n-        // this default implementation makes the addition of `sub_usize` a non-breaking change\n-        let _ = n;\n-        unimplemented!()\n+    /// Returns the value that would be obtained by taking the *predecessor*\n+    /// of `self` `count` times.\n+    ///\n+    /// # Safety\n+    ///\n+    /// It is undefined behavior for this operation to overflow the\n+    /// range of values supported by `Self`. If you cannot guarantee that this\n+    /// will not overflow, use `backward` or `backward_checked` instead.\n+    ///\n+    /// # Invariants\n+    ///\n+    /// For any `a`:\n+    ///\n+    /// * if there exists `b` such that `b < a`, it is safe to call `Step::backward_unchecked(a, 1)`\n+    /// * if there exists `b`, `n` such that `steps_between(&b, &a) == Some(n)`,\n+    ///   it is safe to call `Step::backward_unchecked(a, m)` for any `m <= n`.\n+    ///\n+    /// For any `a` and `n`, where no overflow occurs:\n+    ///\n+    /// * `Step::backward_unchecked(a, n)` is equivalent to `Step::backward(a, n)`\n+    #[unstable(feature = \"unchecked_math\", reason = \"niche optimization path\", issue = \"none\")]\n+    unsafe fn backward_unchecked(start: Self, count: usize) -> Self {\n+        Step::backward(start, count)\n     }\n }\n \n // These are still macro-generated because the integer literals resolve to different types.\n macro_rules! step_identical_methods {\n     () => {\n         #[inline]\n-        fn replace_one(&mut self) -> Self {\n-            mem::replace(self, 1)\n+        unsafe fn forward_unchecked(start: Self, n: usize) -> Self {\n+            start.unchecked_add(n as Self)\n         }\n \n         #[inline]\n-        fn replace_zero(&mut self) -> Self {\n-            mem::replace(self, 0)\n+        unsafe fn backward_unchecked(start: Self, n: usize) -> Self {\n+            start.unchecked_sub(n as Self)\n         }\n+    };\n+    ( [$u:ident $i:ident] ) => {\n+        step_identical_methods!();\n \n         #[inline]\n-        fn add_one(&self) -> Self {\n-            Add::add(*self, 1)\n+        fn forward(start: Self, n: usize) -> Self {\n+            match Self::forward_checked(start, n) {\n+                Some(result) => result,\n+                None => {\n+                    let result = Add::add(start, n as Self);\n+                    // add one modular cycle to ensure overflow occurs\n+                    Add::add(Add::add(result as $u, $u::MAX), 1) as Self\n+                }\n+            }\n         }\n \n         #[inline]\n-        fn sub_one(&self) -> Self {\n-            Sub::sub(*self, 1)\n+        fn backward(start: Self, n: usize) -> Self {\n+            match Self::backward_checked(start, n) {\n+                Some(result) => result,\n+                None => {\n+                    let result = Sub::sub(start, n as Self);\n+                    // sub one modular cycle to ensure overflow occurs\n+                    Sub::sub(Sub::sub(result as $u, $u::MAX), 1) as Self\n+                }\n+            }\n         }\n-    }\n+    };\n }\n \n-macro_rules! step_impl_unsigned {\n-    ($($t:ty)*) => ($(\n-        #[unstable(feature = \"step_trait\",\n-                   reason = \"likely to be replaced by finer-grained traits\",\n-                   issue = \"42168\")]\n-        impl Step for $t {\n-            #[inline]\n-            fn steps_between(start: &$t, end: &$t) -> Option<usize> {\n-                if *start < *end {\n-                    usize::try_from(*end - *start).ok()\n-                } else {\n-                    Some(0)\n+macro_rules! step_integer_impls {\n+    {\n+        narrower than or same width as usize:\n+            $( [ $u_narrower:ident $i_narrower:ident ] ),+;\n+        wider than usize:\n+            $( [ $u_wider:ident $i_wider:ident ] ),+;\n+    } => {\n+        $(\n+            #[allow(unreachable_patterns)]\n+            #[unstable(feature = \"step_trait\", reason = \"recently redesigned\", issue = \"42168\")]\n+            unsafe impl Step for $u_narrower {\n+                step_identical_methods!( [ $u_narrower $i_narrower ] );\n+\n+                #[inline]\n+                fn steps_between(start: &Self, end: &Self) -> Option<usize> {\n+                    if *start <= *end {\n+                        // This relies on $u_narrower <= usize\n+                        Some((*end - *start) as usize)\n+                    } else {\n+                        None\n+                    }\n                 }\n-            }\n \n-            #[inline]\n-            #[allow(unreachable_patterns)]\n-            fn add_usize(&self, n: usize) -> Option<Self> {\n-                match <$t>::try_from(n) {\n-                    Ok(n_as_t) => self.checked_add(n_as_t),\n-                    Err(_) => None,\n+                #[inline]\n+                fn forward_checked(start: Self, n: usize) -> Option<Self> {\n+                    match Self::try_from(n) {\n+                        Ok(n) => start.checked_add(n),\n+                        Err(_) => None, // if n is out of range, `unsigned_start + n` is too\n+                    }\n+                }\n+\n+                #[inline]\n+                fn backward_checked(start: Self, n: usize) -> Option<Self> {\n+                    match Self::try_from(n) {\n+                        Ok(n) => start.checked_sub(n),\n+                        Err(_) => None, // if n is out of range, `unsigned_start - n` is too\n+                    }\n                 }\n             }\n \n-            #[inline]\n             #[allow(unreachable_patterns)]\n-            fn sub_usize(&self, n: usize) -> Option<Self> {\n-                match <$t>::try_from(n) {\n-                    Ok(n_as_t) => self.checked_sub(n_as_t),\n-                    Err(_) => None,\n+            #[unstable(feature = \"step_trait\", reason = \"recently redesigned\", issue = \"42168\")]\n+            unsafe impl Step for $i_narrower {\n+                step_identical_methods!( [ $u_narrower $i_narrower ] );\n+\n+                #[inline]\n+                fn steps_between(start: &Self, end: &Self) -> Option<usize> {\n+                    if *start <= *end {\n+                        // This relies on $i_narrower <= usize\n+                        //\n+                        // Casting to isize extends the width but preserves the sign.\n+                        // Use wrapping_sub in isize space and cast to usize to compute\n+                        // the difference that may not fit inside the range of isize.\n+                        Some((*end as isize).wrapping_sub(*start as isize) as usize)\n+                    } else {\n+                        None\n+                    }\n                 }\n-            }\n \n-            step_identical_methods!();\n-        }\n-    )*)\n-}\n-macro_rules! step_impl_signed {\n-    ($( [$t:ty : $unsigned:ty] )*) => ($(\n-        #[unstable(feature = \"step_trait\",\n-                   reason = \"likely to be replaced by finer-grained traits\",\n-                   issue = \"42168\")]\n-        impl Step for $t {\n-            #[inline]\n-            fn steps_between(start: &$t, end: &$t) -> Option<usize> {\n-                if *start < *end {\n-                    // Use .wrapping_sub and cast to unsigned to compute the\n-                    // difference that may not fit inside the range of $t.\n-                    usize::try_from(end.wrapping_sub(*start) as $unsigned).ok()\n-                } else {\n-                    Some(0)\n+                #[inline]\n+                fn forward_checked(start: Self, n: usize) -> Option<Self> {\n+                    match $u_narrower::try_from(n) {\n+                        Ok(n) => {\n+                            // Wrapping handles cases like\n+                            // `Step::forward(-120_i8, 200) == Some(80_i8)`,\n+                            // even though 200 is out of range for i8.\n+                            let wrapped = start.wrapping_add(n as Self);\n+                            if wrapped >= start {\n+                                Some(wrapped)\n+                            } else {\n+                                None // Addition overflowed\n+                            }\n+                        }\n+                        // If n is out of range of e.g. u8,\n+                        // then it is bigger than the entire range for i8 is wide\n+                        // so `any_i8 + n` necessarily overflows i8.\n+                        Err(_) => None,\n+                    }\n+                }\n+\n+                #[inline]\n+                fn backward_checked(start: Self, n: usize) -> Option<Self> {\n+                    match $u_narrower::try_from(n) {\n+                        Ok(n) => {\n+                            // Wrapping handles cases like\n+                            // `Step::forward(-120_i8, 200) == Some(80_i8)`,\n+                            // even though 200 is out of range for i8.\n+                            let wrapped = start.wrapping_sub(n as Self);\n+                            if wrapped <= start {\n+                                Some(wrapped)\n+                            } else {\n+                                None // Subtraction overflowed\n+                            }\n+                        }\n+                        // If n is out of range of e.g. u8,\n+                        // then it is bigger than the entire range for i8 is wide\n+                        // so `any_i8 - n` necessarily overflows i8.\n+                        Err(_) => None,\n+                    }\n                 }\n             }\n+        )+\n \n-            #[inline]\n+        $(\n             #[allow(unreachable_patterns)]\n-            fn add_usize(&self, n: usize) -> Option<Self> {\n-                match <$unsigned>::try_from(n) {\n-                    Ok(n_as_unsigned) => {\n-                        // Wrapping in unsigned space handles cases like\n-                        // `-120_i8.add_usize(200) == Some(80_i8)`,\n-                        // even though 200_usize is out of range for i8.\n-                        let wrapped = (*self as $unsigned).wrapping_add(n_as_unsigned) as $t;\n-                        if wrapped >= *self {\n-                            Some(wrapped)\n-                        } else {\n-                            None  // Addition overflowed\n-                        }\n+            #[unstable(feature = \"step_trait\", reason = \"recently redesigned\", issue = \"42168\")]\n+            unsafe impl Step for $u_wider {\n+                step_identical_methods!();\n+\n+                #[inline]\n+                fn steps_between(start: &Self, end: &Self) -> Option<usize> {\n+                    if *start <= *end {\n+                        usize::try_from(*end - *start).ok()\n+                    } else {\n+                        None\n                     }\n-                    Err(_) => None,\n+                }\n+\n+                #[inline]\n+                fn forward_checked(start: Self, n: usize) -> Option<Self> {\n+                    start.checked_add(n as Self)\n+                }\n+\n+                #[inline]\n+                fn forward(start: Self, n: usize) -> Self {\n+                    Add::add(start, n as Self)\n+                }\n+\n+                #[inline]\n+                fn backward_checked(start: Self, n: usize) -> Option<Self> {\n+                    start.checked_sub(n as Self)\n+                }\n+\n+                #[inline]\n+                fn backward(start: Self, n: usize) -> Self {\n+                    Sub::sub(start, n as Self)\n                 }\n             }\n \n-            #[inline]\n             #[allow(unreachable_patterns)]\n-            fn sub_usize(&self, n: usize) -> Option<Self> {\n-                match <$unsigned>::try_from(n) {\n-                    Ok(n_as_unsigned) => {\n-                        // Wrapping in unsigned space handles cases like\n-                        // `80_i8.sub_usize(200) == Some(-120_i8)`,\n-                        // even though 200_usize is out of range for i8.\n-                        let wrapped = (*self as $unsigned).wrapping_sub(n_as_unsigned) as $t;\n-                        if wrapped <= *self {\n-                            Some(wrapped)\n-                        } else {\n-                            None  // Subtraction underflowed\n+            #[unstable(feature = \"step_trait\", reason = \"recently redesigned\", issue = \"42168\")]\n+            unsafe impl Step for $i_wider {\n+                step_identical_methods!();\n+\n+                #[inline]\n+                fn steps_between(start: &Self, end: &Self) -> Option<usize> {\n+                    if *start <= *end {\n+                        match end.checked_sub(*start) {\n+                            Some(result) => usize::try_from(result).ok(),\n+                            // If the difference is too big for e.g. i128,\n+                            // it's also gonna be too big for usize with fewer bits.\n+                            None => None,\n                         }\n+                    } else {\n+                        None\n                     }\n-                    Err(_) => None,\n+                }\n+\n+                #[inline]\n+                fn forward_checked(start: Self, n: usize) -> Option<Self> {\n+                    start.checked_add(n as Self)\n+                }\n+\n+                #[inline]\n+                fn forward(start: Self, n: usize) -> Self {\n+                    Add::add(start, n as Self)\n+                }\n+\n+                #[inline]\n+                fn backward_checked(start: Self, n: usize) -> Option<Self> {\n+                    start.checked_sub(n as Self)\n+                }\n+\n+                #[inline]\n+                fn backward(start: Self, n: usize) -> Self {\n+                    Sub::sub(start, n as Self)\n                 }\n             }\n+        )+\n+    };\n+}\n \n-            step_identical_methods!();\n-        }\n-    )*)\n+#[cfg(target_pointer_width = \"64\")]\n+step_integer_impls! {\n+    narrower than or same width as usize: [u8 i8], [u16 i16], [u32 i32], [u64 i64], [usize isize];\n+    wider than usize: [u128 i128];\n }\n \n-step_impl_unsigned!(usize u8 u16 u32 u64 u128);\n-step_impl_signed!([isize: usize][i8: u8][i16: u16]);\n-step_impl_signed!([i32: u32][i64: u64][i128: u128]);\n+#[cfg(target_pointer_width = \"32\")]\n+step_integer_impls! {\n+    narrower than or same width as usize: [u8 i8], [u16 i16], [u32 i32], [usize isize];\n+    wider than usize: [u64 i64], [u128 i128];\n+}\n+\n+#[cfg(target_pointer_width = \"16\")]\n+step_integer_impls! {\n+    narrower than or same width as usize: [u8 i8], [u16 i16], [usize isize];\n+    wider than usize: [u32 i32], [u64 i64], [u128 i128];\n+}\n \n macro_rules! range_exact_iter_impl {\n     ($($t:ty)*) => ($(\n@@ -189,55 +437,39 @@ macro_rules! range_incl_exact_iter_impl {\n     )*)\n }\n \n-macro_rules! range_trusted_len_impl {\n-    ($($t:ty)*) => ($(\n-        #[unstable(feature = \"trusted_len\", issue = \"37572\")]\n-        unsafe impl TrustedLen for ops::Range<$t> { }\n-    )*)\n-}\n-\n-macro_rules! range_incl_trusted_len_impl {\n-    ($($t:ty)*) => ($(\n-        #[unstable(feature = \"trusted_len\", issue = \"37572\")]\n-        unsafe impl TrustedLen for ops::RangeInclusive<$t> { }\n-    )*)\n-}\n-\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A: Step> Iterator for ops::Range<A> {\n     type Item = A;\n \n     #[inline]\n     fn next(&mut self) -> Option<A> {\n         if self.start < self.end {\n-            // We check for overflow here, even though it can't actually\n-            // happen. Adding this check does however help llvm vectorize loops\n-            // for some ranges that don't get vectorized otherwise,\n-            // and this won't actually result in an extra check in an optimized build.\n-            if let Some(mut n) = self.start.add_usize(1) {\n-                mem::swap(&mut n, &mut self.start);\n-                Some(n)\n-            } else {\n-                None\n-            }\n+            // SAFETY: just checked precondition\n+            // We use the unchecked version here, because\n+            // this helps LLVM vectorize loops for some ranges\n+            // that don't get vectorized otherwise.\n+            let n = unsafe { Step::forward_unchecked(self.start.clone(), 1) };\n+            Some(mem::replace(&mut self.start, n))\n         } else {\n             None\n         }\n     }\n \n     #[inline]\n     fn size_hint(&self) -> (usize, Option<usize>) {\n-        match Step::steps_between(&self.start, &self.end) {\n-            Some(hint) => (hint, Some(hint)),\n-            None => (usize::MAX, None),\n+        if self.start < self.end {\n+            let hint = Step::steps_between(&self.start, &self.end);\n+            (hint.unwrap_or(usize::MAX), hint)\n+        } else {\n+            (0, Some(0))\n         }\n     }\n \n     #[inline]\n     fn nth(&mut self, n: usize) -> Option<A> {\n-        if let Some(plus_n) = self.start.add_usize(n) {\n+        if let Some(plus_n) = Step::forward_checked(self.start.clone(), n) {\n             if plus_n < self.end {\n-                self.start = plus_n.add_one();\n+                self.start = Step::forward(plus_n.clone(), 1);\n                 return Some(plus_n);\n             }\n         }\n@@ -263,25 +495,42 @@ impl<A: Step> Iterator for ops::Range<A> {\n }\n \n // These macros generate `ExactSizeIterator` impls for various range types.\n-// Range<{u,i}64> and RangeInclusive<{u,i}{32,64,size}> are excluded\n-// because they cannot guarantee having a length <= usize::MAX, which is\n-// required by ExactSizeIterator.\n-range_exact_iter_impl!(usize u8 u16 u32 isize i8 i16 i32);\n-range_incl_exact_iter_impl!(u8 u16 i8 i16);\n-\n-// These macros generate `TrustedLen` impls.\n //\n-// They need to guarantee that .size_hint() is either exact, or that\n-// the upper bound is None when it does not fit the type limits.\n-range_trusted_len_impl!(usize isize u8 i8 u16 i16 u32 i32 u64 i64 u128 i128);\n-range_incl_trusted_len_impl!(usize isize u8 i8 u16 i16 u32 i32 u64 i64 u128 i128);\n+// * `ExactSizeIterator::len` is required to always return an exact `usize`,\n+//   so no range can be longer than `usize::MAX`.\n+// * For integer types in `Range<_>` this is the case for types narrower than or as wide as `usize`.\n+//   For integer types in `RangeInclusive<_>`\n+//   this is the case for types *strictly narrower* than `usize`\n+//   since e.g. `(0..=u64::MAX).len()` would be `u64::MAX + 1`.\n+range_exact_iter_impl! {\n+    usize u8 u16\n+    isize i8 i16\n+\n+    // These are incorect per the reasoning above,\n+    // but removing them would be a breaking change as they were stabilized in Rust 1.0.0.\n+    // So e.g. `(0..66_000_u32).len()` for example will compile without error or warnings\n+    // on 16-bit platforms, but continue to give a wrong result.\n+    u32\n+    i32\n+}\n+range_incl_exact_iter_impl! {\n+    u8\n+    i8\n+\n+    // These are incorect per the reasoning above,\n+    // but removing them would be a breaking change as they were stabilized in Rust 1.26.0.\n+    // So e.g. `(0..=u16::MAX).len()` for example will compile without error or warnings\n+    // on 16-bit platforms, but continue to give a wrong result.\n+    u16\n+    i16\n+}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A: Step> DoubleEndedIterator for ops::Range<A> {\n     #[inline]\n     fn next_back(&mut self) -> Option<A> {\n         if self.start < self.end {\n-            self.end = self.end.sub_one();\n+            self.end = Step::backward(self.end.clone(), 1);\n             Some(self.end.clone())\n         } else {\n             None\n@@ -290,9 +539,9 @@ impl<A: Step> DoubleEndedIterator for ops::Range<A> {\n \n     #[inline]\n     fn nth_back(&mut self, n: usize) -> Option<A> {\n-        if let Some(minus_n) = self.end.sub_usize(n) {\n+        if let Some(minus_n) = Step::backward_checked(self.end.clone(), n) {\n             if minus_n > self.start {\n-                self.end = minus_n.sub_one();\n+                self.end = Step::backward(minus_n, 1);\n                 return Some(self.end.clone());\n             }\n         }\n@@ -302,6 +551,9 @@ impl<A: Step> DoubleEndedIterator for ops::Range<A> {\n     }\n }\n \n+#[unstable(feature = \"trusted_len\", issue = \"37572\")]\n+unsafe impl<A: Step> TrustedLen for ops::Range<A> {}\n+\n #[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<A: Step> FusedIterator for ops::Range<A> {}\n \n@@ -311,9 +563,8 @@ impl<A: Step> Iterator for ops::RangeFrom<A> {\n \n     #[inline]\n     fn next(&mut self) -> Option<A> {\n-        let mut n = self.start.add_one();\n-        mem::swap(&mut n, &mut self.start);\n-        Some(n)\n+        let n = Step::forward(self.start.clone(), 1);\n+        Some(mem::replace(&mut self.start, n))\n     }\n \n     #[inline]\n@@ -323,8 +574,16 @@ impl<A: Step> Iterator for ops::RangeFrom<A> {\n \n     #[inline]\n     fn nth(&mut self, n: usize) -> Option<A> {\n-        let plus_n = self.start.add_usize(n).expect(\"overflow in RangeFrom::nth\");\n-        self.start = plus_n.add_one();\n+        // If we would jump over the maximum value, panic immediately.\n+        // This is consistent with behavior before the Step redesign,\n+        // even though it's inconsistent with n `next` calls.\n+        // To get consistent behavior, change it to use `forward` instead.\n+        // This change should go through FCP separately to the redesign, so is for now left as a\n+        // FIXME: make this consistent\n+        let plus_n =\n+            Step::forward_checked(self.start.clone(), n).expect(\"overflow in RangeFrom::nth\");\n+        // The final step should always be debug-checked.\n+        self.start = Step::forward(plus_n.clone(), 1);\n         Some(plus_n)\n     }\n }\n@@ -346,7 +605,7 @@ impl<A: Step> Iterator for ops::RangeInclusive<A> {\n         }\n         let is_iterating = self.start < self.end;\n         Some(if is_iterating {\n-            let n = self.start.add_one();\n+            let n = Step::forward(self.start.clone(), 1);\n             mem::replace(&mut self.start, n)\n         } else {\n             self.exhausted = true;\n@@ -372,12 +631,12 @@ impl<A: Step> Iterator for ops::RangeInclusive<A> {\n             return None;\n         }\n \n-        if let Some(plus_n) = self.start.add_usize(n) {\n+        if let Some(plus_n) = Step::forward_checked(self.start.clone(), n) {\n             use crate::cmp::Ordering::*;\n \n             match plus_n.partial_cmp(&self.end) {\n                 Some(Less) => {\n-                    self.start = plus_n.add_one();\n+                    self.start = Step::forward(plus_n.clone(), 1);\n                     return Some(plus_n);\n                 }\n                 Some(Equal) => {\n@@ -408,7 +667,7 @@ impl<A: Step> Iterator for ops::RangeInclusive<A> {\n         let mut accum = init;\n \n         while self.start < self.end {\n-            let n = self.start.add_one();\n+            let n = Step::forward(self.start.clone(), 1);\n             let n = mem::replace(&mut self.start, n);\n             accum = f(accum, n)?;\n         }\n@@ -447,7 +706,7 @@ impl<A: Step> DoubleEndedIterator for ops::RangeInclusive<A> {\n         }\n         let is_iterating = self.start < self.end;\n         Some(if is_iterating {\n-            let n = self.end.sub_one();\n+            let n = Step::backward(self.end.clone(), 1);\n             mem::replace(&mut self.end, n)\n         } else {\n             self.exhausted = true;\n@@ -461,12 +720,12 @@ impl<A: Step> DoubleEndedIterator for ops::RangeInclusive<A> {\n             return None;\n         }\n \n-        if let Some(minus_n) = self.end.sub_usize(n) {\n+        if let Some(minus_n) = Step::backward_checked(self.end.clone(), n) {\n             use crate::cmp::Ordering::*;\n \n             match minus_n.partial_cmp(&self.start) {\n                 Some(Greater) => {\n-                    self.end = minus_n.sub_one();\n+                    self.end = Step::backward(minus_n.clone(), 1);\n                     return Some(minus_n);\n                 }\n                 Some(Equal) => {\n@@ -497,7 +756,7 @@ impl<A: Step> DoubleEndedIterator for ops::RangeInclusive<A> {\n         let mut accum = init;\n \n         while self.start < self.end {\n-            let n = self.end.sub_one();\n+            let n = Step::backward(self.end.clone(), 1);\n             let n = mem::replace(&mut self.end, n);\n             accum = f(accum, n)?;\n         }\n@@ -512,5 +771,8 @@ impl<A: Step> DoubleEndedIterator for ops::RangeInclusive<A> {\n     }\n }\n \n+#[unstable(feature = \"trusted_len\", issue = \"37572\")]\n+unsafe impl<A: Step> TrustedLen for ops::RangeInclusive<A> {}\n+\n #[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<A: Step> FusedIterator for ops::RangeInclusive<A> {}"}, {"sha": "13c05dadbde72b6311fc50cf9e20775d77de2339", "filename": "src/libcore/tests/iter.rs", "status": "modified", "additions": 104, "deletions": 29, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/2fcfd233f755c548ddc4d5fda517a7dbb9f04ba3/src%2Flibcore%2Ftests%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fcfd233f755c548ddc4d5fda517a7dbb9f04ba3/src%2Flibcore%2Ftests%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fiter.rs?ref=2fcfd233f755c548ddc4d5fda517a7dbb9f04ba3", "patch": "@@ -228,7 +228,11 @@ fn test_iterator_chain_size_hint() {\n         }\n \n         fn size_hint(&self) -> (usize, Option<usize>) {\n-            if self.is_empty { (0, Some(0)) } else { (1, Some(1)) }\n+            if self.is_empty {\n+                (0, Some(0))\n+            } else {\n+                (1, Some(1))\n+            }\n         }\n     }\n \n@@ -1554,7 +1558,11 @@ fn test_find_map() {\n     assert_eq!(iter.next(), Some(&7));\n \n     fn half_if_even(x: &isize) -> Option<isize> {\n-        if x % 2 == 0 { Some(x / 2) } else { None }\n+        if x % 2 == 0 {\n+            Some(x / 2)\n+        } else {\n+            None\n+        }\n     }\n }\n \n@@ -2125,6 +2133,24 @@ fn test_range_inclusive_nth_back() {\n     assert_eq!(ExactSizeIterator::is_empty(&r), true);\n }\n \n+#[test]\n+fn test_range_len() {\n+    assert_eq!((0..10_u8).len(), 10);\n+    assert_eq!((9..10_u8).len(), 1);\n+    assert_eq!((10..10_u8).len(), 0);\n+    assert_eq!((11..10_u8).len(), 0);\n+    assert_eq!((100..10_u8).len(), 0);\n+}\n+\n+#[test]\n+fn test_range_inclusive_len() {\n+    assert_eq!((0..=10_u8).len(), 11);\n+    assert_eq!((9..=10_u8).len(), 2);\n+    assert_eq!((10..=10_u8).len(), 1);\n+    assert_eq!((11..=10_u8).len(), 0);\n+    assert_eq!((100..=10_u8).len(), 0);\n+}\n+\n #[test]\n fn test_range_step() {\n     #![allow(deprecated)]\n@@ -2495,42 +2521,91 @@ fn test_chain_fold() {\n }\n \n #[test]\n-fn test_step_replace_unsigned() {\n-    let mut x = 4u32;\n-    let y = x.replace_zero();\n-    assert_eq!(x, 0);\n-    assert_eq!(y, 4);\n+fn test_steps_between() {\n+    assert_eq!(Step::steps_between(&20_u8, &200_u8), Some(180_usize));\n+    assert_eq!(Step::steps_between(&-20_i8, &80_i8), Some(100_usize));\n+    assert_eq!(Step::steps_between(&-120_i8, &80_i8), Some(200_usize));\n+    assert_eq!(Step::steps_between(&20_u32, &4_000_100_u32), Some(4_000_080_usize));\n+    assert_eq!(Step::steps_between(&-20_i32, &80_i32), Some(100_usize));\n+    assert_eq!(Step::steps_between(&-2_000_030_i32, &2_000_050_i32), Some(4_000_080_usize));\n+\n+    // Skip u64/i64 to avoid differences with 32-bit vs 64-bit platforms\n \n-    x = 5;\n-    let y = x.replace_one();\n-    assert_eq!(x, 1);\n-    assert_eq!(y, 5);\n+    assert_eq!(Step::steps_between(&20_u128, &200_u128), Some(180_usize));\n+    assert_eq!(Step::steps_between(&-20_i128, &80_i128), Some(100_usize));\n+    if cfg!(target_pointer_width = \"64\") {\n+        assert_eq!(Step::steps_between(&10_u128, &0x1_0000_0000_0000_0009_u128), Some(usize::MAX));\n+    }\n+    assert_eq!(Step::steps_between(&10_u128, &0x1_0000_0000_0000_000a_u128), None);\n+    assert_eq!(Step::steps_between(&10_i128, &0x1_0000_0000_0000_000a_i128), None);\n+    assert_eq!(\n+        Step::steps_between(&-0x1_0000_0000_0000_0000_i128, &0x1_0000_0000_0000_0000_i128,),\n+        None,\n+    );\n }\n \n #[test]\n-fn test_step_replace_signed() {\n-    let mut x = 4i32;\n-    let y = x.replace_zero();\n-    assert_eq!(x, 0);\n-    assert_eq!(y, 4);\n+fn test_step_forward() {\n+    assert_eq!(Step::forward_checked(55_u8, 200_usize), Some(255_u8));\n+    assert_eq!(Step::forward_checked(252_u8, 200_usize), None);\n+    assert_eq!(Step::forward_checked(0_u8, 256_usize), None);\n+    assert_eq!(Step::forward_checked(-110_i8, 200_usize), Some(90_i8));\n+    assert_eq!(Step::forward_checked(-110_i8, 248_usize), None);\n+    assert_eq!(Step::forward_checked(-126_i8, 256_usize), None);\n \n-    x = 5;\n-    let y = x.replace_one();\n-    assert_eq!(x, 1);\n-    assert_eq!(y, 5);\n+    assert_eq!(Step::forward_checked(35_u16, 100_usize), Some(135_u16));\n+    assert_eq!(Step::forward_checked(35_u16, 65500_usize), Some(u16::MAX));\n+    assert_eq!(Step::forward_checked(36_u16, 65500_usize), None);\n+    assert_eq!(Step::forward_checked(-110_i16, 200_usize), Some(90_i16));\n+    assert_eq!(Step::forward_checked(-20_030_i16, 50_050_usize), Some(30_020_i16));\n+    assert_eq!(Step::forward_checked(-10_i16, 40_000_usize), None);\n+    assert_eq!(Step::forward_checked(-10_i16, 70_000_usize), None);\n+\n+    assert_eq!(Step::forward_checked(10_u128, 70_000_usize), Some(70_010_u128));\n+    assert_eq!(Step::forward_checked(10_i128, 70_030_usize), Some(70_040_i128));\n+    assert_eq!(\n+        Step::forward_checked(0xffff_ffff_ffff_ffff__ffff_ffff_ffff_ff00_u128, 0xff_usize),\n+        Some(u128::MAX),\n+    );\n+    assert_eq!(\n+        Step::forward_checked(0xffff_ffff_ffff_ffff__ffff_ffff_ffff_ff00_u128, 0x100_usize),\n+        None\n+    );\n+    assert_eq!(\n+        Step::forward_checked(0x7fff_ffff_ffff_ffff__ffff_ffff_ffff_ff00_i128, 0xff_usize),\n+        Some(i128::MAX),\n+    );\n+    assert_eq!(\n+        Step::forward_checked(0x7fff_ffff_ffff_ffff__ffff_ffff_ffff_ff00_i128, 0x100_usize),\n+        None\n+    );\n }\n \n #[test]\n-fn test_step_replace_no_between() {\n-    let mut x = 4u128;\n-    let y = x.replace_zero();\n-    assert_eq!(x, 0);\n-    assert_eq!(y, 4);\n+fn test_step_backward() {\n+    assert_eq!(Step::backward_checked(255_u8, 200_usize), Some(55_u8));\n+    assert_eq!(Step::backward_checked(100_u8, 200_usize), None);\n+    assert_eq!(Step::backward_checked(255_u8, 256_usize), None);\n+    assert_eq!(Step::backward_checked(90_i8, 200_usize), Some(-110_i8));\n+    assert_eq!(Step::backward_checked(110_i8, 248_usize), None);\n+    assert_eq!(Step::backward_checked(127_i8, 256_usize), None);\n \n-    x = 5;\n-    let y = x.replace_one();\n-    assert_eq!(x, 1);\n-    assert_eq!(y, 5);\n+    assert_eq!(Step::backward_checked(135_u16, 100_usize), Some(35_u16));\n+    assert_eq!(Step::backward_checked(u16::MAX, 65500_usize), Some(35_u16));\n+    assert_eq!(Step::backward_checked(10_u16, 11_usize), None);\n+    assert_eq!(Step::backward_checked(90_i16, 200_usize), Some(-110_i16));\n+    assert_eq!(Step::backward_checked(30_020_i16, 50_050_usize), Some(-20_030_i16));\n+    assert_eq!(Step::backward_checked(-10_i16, 40_000_usize), None);\n+    assert_eq!(Step::backward_checked(-10_i16, 70_000_usize), None);\n+\n+    assert_eq!(Step::backward_checked(70_010_u128, 70_000_usize), Some(10_u128));\n+    assert_eq!(Step::backward_checked(70_020_i128, 70_030_usize), Some(-10_i128));\n+    assert_eq!(Step::backward_checked(10_u128, 7_usize), Some(3_u128));\n+    assert_eq!(Step::backward_checked(10_u128, 11_usize), None);\n+    assert_eq!(\n+        Step::backward_checked(-0x7fff_ffff_ffff_ffff__ffff_ffff_ffff_ff00_i128, 0x100_usize),\n+        Some(i128::MIN)\n+    );\n }\n \n #[test]"}, {"sha": "3d6abb818e4e351bebaa9f0cce2b1c662681b6d4", "filename": "src/libcore/tests/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2fcfd233f755c548ddc4d5fda517a7dbb9f04ba3/src%2Flibcore%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fcfd233f755c548ddc4d5fda517a7dbb9f04ba3/src%2Flibcore%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Flib.rs?ref=2fcfd233f755c548ddc4d5fda517a7dbb9f04ba3", "patch": "@@ -22,6 +22,7 @@\n #![feature(slice_partition_at_index)]\n #![feature(specialization)]\n #![feature(step_trait)]\n+#![feature(step_trait_ext)]\n #![feature(str_internals)]\n #![feature(test)]\n #![feature(trusted_len)]"}, {"sha": "67dcea58cf82bb0b30a35ef6872810f69e3014af", "filename": "src/librustc_index/vec.rs", "status": "modified", "additions": 6, "deletions": 26, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/2fcfd233f755c548ddc4d5fda517a7dbb9f04ba3/src%2Flibrustc_index%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fcfd233f755c548ddc4d5fda517a7dbb9f04ba3/src%2Flibrustc_index%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_index%2Fvec.rs?ref=2fcfd233f755c548ddc4d5fda517a7dbb9f04ba3", "patch": "@@ -65,7 +65,7 @@ impl Idx for u32 {\n /// `u32::MAX`. You can also customize things like the `Debug` impl,\n /// what traits are derived, and so forth via the macro.\n #[macro_export]\n-#[allow_internal_unstable(step_trait, rustc_attrs)]\n+#[allow_internal_unstable(step_trait, step_trait_ext, rustc_attrs)]\n macro_rules! newtype_index {\n     // ---- public rules ----\n \n@@ -181,7 +181,7 @@ macro_rules! newtype_index {\n             }\n         }\n \n-        impl ::std::iter::Step for $type {\n+        unsafe impl ::std::iter::Step for $type {\n             #[inline]\n             fn steps_between(start: &Self, end: &Self) -> Option<usize> {\n                 <usize as ::std::iter::Step>::steps_between(\n@@ -191,33 +191,13 @@ macro_rules! newtype_index {\n             }\n \n             #[inline]\n-            fn replace_one(&mut self) -> Self {\n-                ::std::mem::replace(self, Self::from_u32(1))\n+            fn forward_checked(start: Self, u: usize) -> Option<Self> {\n+                Self::index(start).checked_add(u).map(Self::from_usize)\n             }\n \n             #[inline]\n-            fn replace_zero(&mut self) -> Self {\n-                ::std::mem::replace(self, Self::from_u32(0))\n-            }\n-\n-            #[inline]\n-            fn add_one(&self) -> Self {\n-                Self::from_usize(Self::index(*self) + 1)\n-            }\n-\n-            #[inline]\n-            fn sub_one(&self) -> Self {\n-                Self::from_usize(Self::index(*self) - 1)\n-            }\n-\n-            #[inline]\n-            fn add_usize(&self, u: usize) -> Option<Self> {\n-                Self::index(*self).checked_add(u).map(Self::from_usize)\n-            }\n-\n-            #[inline]\n-            fn sub_usize(&self, u: usize) -> Option<Self> {\n-                Self::index(*self).checked_sub(u).map(Self::from_usize)\n+            fn backward_checked(start: Self, u: usize) -> Option<Self> {\n+                Self::index(start).checked_sub(u).map(Self::from_usize)\n             }\n         }\n "}, {"sha": "fafab8a102a901895d07196248e8aa8f984b470c", "filename": "src/test/ui/impl-trait/example-calendar.rs", "status": "modified", "additions": 5, "deletions": 21, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/2fcfd233f755c548ddc4d5fda517a7dbb9f04ba3/src%2Ftest%2Fui%2Fimpl-trait%2Fexample-calendar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fcfd233f755c548ddc4d5fda517a7dbb9f04ba3/src%2Ftest%2Fui%2Fimpl-trait%2Fexample-calendar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fexample-calendar.rs?ref=2fcfd233f755c548ddc4d5fda517a7dbb9f04ba3", "patch": "@@ -2,6 +2,7 @@\n \n #![feature(fn_traits,\n            step_trait,\n+           step_trait_ext,\n            unboxed_closures,\n )]\n \n@@ -10,7 +11,6 @@\n //! Originally converted to Rust by [Daniel Keep](https://github.com/DanielKeep).\n \n use std::fmt::Write;\n-use std::mem;\n \n /// Date representation.\n #[derive(Copy, Clone, Debug, Eq, Ord, PartialEq, PartialOrd)]\n@@ -156,32 +156,16 @@ impl<'a, 'b> std::ops::Add<&'b NaiveDate> for &'a NaiveDate {\n     }\n }\n \n-impl std::iter::Step for NaiveDate {\n+unsafe impl std::iter::Step for NaiveDate {\n     fn steps_between(_: &Self, _: &Self) -> Option<usize> {\n         unimplemented!()\n     }\n \n-    fn replace_one(&mut self) -> Self {\n-        mem::replace(self, NaiveDate(0, 0, 1))\n+    fn forward_checked(start: Self, n: usize) -> Option<Self> {\n+        Some((0..n).fold(start, |x, _| x.succ()))\n     }\n \n-    fn replace_zero(&mut self) -> Self {\n-        mem::replace(self, NaiveDate(0, 0, 0))\n-    }\n-\n-    fn add_one(&self) -> Self {\n-        self.succ()\n-    }\n-\n-    fn sub_one(&self) -> Self {\n-        unimplemented!()\n-    }\n-\n-    fn add_usize(&self, _: usize) -> Option<Self> {\n-        unimplemented!()\n-    }\n-\n-    fn sub_usize(&self, _: usize) -> Option<Self> {\n+    fn backward_checked(_: Self, _: usize) -> Option<Self> {\n         unimplemented!()\n     }\n }"}]}