{"sha": "e8d2706cbac46eac7f4cd1554c41c748e00a4a00", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU4ZDI3MDZjYmFjNDZlYWM3ZjRjZDE1NTRjNDFjNzQ4ZTAwYTRhMDA=", "commit": {"author": {"name": "Michael McConville", "email": "mmcco@mykolab.com", "date": "2015-12-19T03:37:00Z"}, "committer": {"name": "Michael McConville", "email": "mmcco@mykolab.com", "date": "2015-12-19T03:37:00Z"}, "message": "Merge branch 'master' of https://github.com/rust-lang/rust", "tree": {"sha": "556cad53a8d415b3b3a660d756d3bc20bf1609cb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/556cad53a8d415b3b3a660d756d3bc20bf1609cb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e8d2706cbac46eac7f4cd1554c41c748e00a4a00", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e8d2706cbac46eac7f4cd1554c41c748e00a4a00", "html_url": "https://github.com/rust-lang/rust/commit/e8d2706cbac46eac7f4cd1554c41c748e00a4a00", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e8d2706cbac46eac7f4cd1554c41c748e00a4a00/comments", "author": {"login": "mmcco", "id": 1668979, "node_id": "MDQ6VXNlcjE2Njg5Nzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1668979?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mmcco", "html_url": "https://github.com/mmcco", "followers_url": "https://api.github.com/users/mmcco/followers", "following_url": "https://api.github.com/users/mmcco/following{/other_user}", "gists_url": "https://api.github.com/users/mmcco/gists{/gist_id}", "starred_url": "https://api.github.com/users/mmcco/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mmcco/subscriptions", "organizations_url": "https://api.github.com/users/mmcco/orgs", "repos_url": "https://api.github.com/users/mmcco/repos", "events_url": "https://api.github.com/users/mmcco/events{/privacy}", "received_events_url": "https://api.github.com/users/mmcco/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mmcco", "id": 1668979, "node_id": "MDQ6VXNlcjE2Njg5Nzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1668979?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mmcco", "html_url": "https://github.com/mmcco", "followers_url": "https://api.github.com/users/mmcco/followers", "following_url": "https://api.github.com/users/mmcco/following{/other_user}", "gists_url": "https://api.github.com/users/mmcco/gists{/gist_id}", "starred_url": "https://api.github.com/users/mmcco/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mmcco/subscriptions", "organizations_url": "https://api.github.com/users/mmcco/orgs", "repos_url": "https://api.github.com/users/mmcco/repos", "events_url": "https://api.github.com/users/mmcco/events{/privacy}", "received_events_url": "https://api.github.com/users/mmcco/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "33113f86f4c4f191d1bf42642b1a7714c576e395", "url": "https://api.github.com/repos/rust-lang/rust/commits/33113f86f4c4f191d1bf42642b1a7714c576e395", "html_url": "https://github.com/rust-lang/rust/commit/33113f86f4c4f191d1bf42642b1a7714c576e395"}, {"sha": "8ad12c3e251df6b8ed42b4d32709f4f55470a0be", "url": "https://api.github.com/repos/rust-lang/rust/commits/8ad12c3e251df6b8ed42b4d32709f4f55470a0be", "html_url": "https://github.com/rust-lang/rust/commit/8ad12c3e251df6b8ed42b4d32709f4f55470a0be"}], "stats": {"total": 590, "additions": 561, "deletions": 29}, "files": [{"sha": "9863d5645fc4d1be789d03bcf58c1b3cfafbba39", "filename": "src/liblibc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblibc?ref=e8d2706cbac46eac7f4cd1554c41c748e00a4a00", "patch": "@@ -1 +1 @@\n-Subproject commit 867c6ff0b824d6d295951ed34bb252d5e0b2467a\n+Subproject commit 9863d5645fc4d1be789d03bcf58c1b3cfafbba39"}, {"sha": "265969c52b39d3608b2078658272f3f2bd8b8d32", "filename": "src/librustc_trans/trans/mir/block.rs", "status": "modified", "additions": 64, "deletions": 24, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/e8d2706cbac46eac7f4cd1554c41c748e00a4a00/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8d2706cbac46eac7f4cd1554c41c748e00a4a00/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fblock.rs?ref=e8d2706cbac46eac7f4cd1554c41c748e00a4a00", "patch": "@@ -9,14 +9,18 @@\n // except according to those terms.\n \n use llvm::BasicBlockRef;\n+use middle::infer;\n+use middle::ty;\n use rustc::mir::repr as mir;\n use trans::adt;\n use trans::base;\n use trans::build;\n-use trans::common::Block;\n+use trans::common::{self, Block};\n use trans::debuginfo::DebugLoc;\n+use trans::type_of;\n \n use super::MirContext;\n+use super::operand::OperandValue::{FatPtr, Immediate, Ref};\n \n impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n     pub fn trans_block(&mut self, bb: mir::BasicBlock) {\n@@ -101,29 +105,65 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                 base::build_return_block(bcx.fcx, bcx, return_ty, DebugLoc::None);\n             }\n \n-            mir::Terminator::Call { .. } => {\n-                unimplemented!()\n-                //let llbb = unimplemented!(); // self.make_landing_pad(panic_bb);\n-                //\n-                //let tr_dest = self.trans_lvalue(bcx, &data.destination);\n-                //\n-                //// Create the callee. This will always be a fn\n-                //// ptr and hence a kind of scalar.\n-                //let callee = self.trans_operand(bcx, &data.func);\n-                //\n-                //// Process the arguments.\n-                //\n-                //let args = unimplemented!();\n-                //\n-                //callee::trans_call_inner(bcx,\n-                //                         DebugLoc::None,\n-                //                         |bcx, _| Callee {\n-                //                             bcx: bcx,\n-                //                             data: CalleeData::Fn(callee.llval),\n-                //                             ty: callee.ty,\n-                //                         },\n-                //                         args,\n-                //                         Some(Dest::SaveIn(tr_dest.llval)));\n+            mir::Terminator::Call { ref data, targets } => {\n+                // The location we'll write the result of the call into.\n+                let call_dest = self.trans_lvalue(bcx, &data.destination);\n+\n+                // Create the callee. This will always be a fn\n+                // ptr and hence a kind of scalar.\n+                let callee = self.trans_operand(bcx, &data.func);\n+                let ret_ty = if let ty::TyBareFn(_, ref f) = callee.ty.sty {\n+                    let sig = bcx.tcx().erase_late_bound_regions(&f.sig);\n+                    let sig = infer::normalize_associated_type(bcx.tcx(), &sig);\n+                    sig.output\n+                } else {\n+                    panic!(\"trans_block: expected TyBareFn as callee\");\n+                };\n+\n+                // The arguments we'll be passing\n+                let mut llargs = vec![];\n+\n+                // Does the fn use an outptr? If so, that's the first arg.\n+                if let ty::FnConverging(ret_ty) = ret_ty {\n+                    if type_of::return_uses_outptr(bcx.ccx(), ret_ty) {\n+                        llargs.push(call_dest.llval);\n+                    }\n+                }\n+\n+                // Process the rest of the args.\n+                for arg in &data.args {\n+                    let arg_op = self.trans_operand(bcx, arg);\n+                    match arg_op.val {\n+                        Ref(llval) | Immediate(llval) => llargs.push(llval),\n+                        FatPtr(base, extra) => {\n+                            // The two words in a fat ptr are passed separately\n+                            llargs.push(base);\n+                            llargs.push(extra);\n+                        }\n+                    }\n+                }\n+\n+                // FIXME: Handle panics\n+                //let panic_bb = self.llblock(targets.1);\n+                //self.make_landing_pad(panic_bb);\n+\n+                // Do the actual call.\n+                let (llret, b) = base::invoke(bcx,\n+                                              callee.immediate(),\n+                                              &llargs[..],\n+                                              callee.ty,\n+                                              DebugLoc::None);\n+                bcx = b;\n+\n+                // Copy the return value into the destination.\n+                if let ty::FnConverging(ret_ty) = ret_ty {\n+                    if !type_of::return_uses_outptr(bcx.ccx(), ret_ty) &&\n+                       !common::type_is_zero_size(bcx.ccx(), ret_ty) {\n+                        base::store_ty(bcx, llret, call_dest.llval, ret_ty);\n+                    }\n+                }\n+\n+                build::Br(bcx, self.llblock(targets.0), DebugLoc::None)\n             }\n         }\n     }"}, {"sha": "3f3913471b8958193c7a2543e408350412d508c9", "filename": "src/libstd/ffi/c_str.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e8d2706cbac46eac7f4cd1554c41c748e00a4a00/src%2Flibstd%2Fffi%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8d2706cbac46eac7f4cd1554c41c748e00a4a00/src%2Flibstd%2Fffi%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fffi%2Fc_str.rs?ref=e8d2706cbac46eac7f4cd1554c41c748e00a4a00", "patch": "@@ -19,6 +19,7 @@ use io;\n use iter::Iterator;\n use libc;\n use mem;\n+use memchr;\n use ops::Deref;\n use option::Option::{self, Some, None};\n use os::raw::c_char;\n@@ -188,7 +189,7 @@ impl CString {\n     }\n \n     fn _new(bytes: Vec<u8>) -> Result<CString, NulError> {\n-        match bytes.iter().position(|x| *x == 0) {\n+        match memchr::memchr(0, &bytes) {\n             Some(i) => Err(NulError(i, bytes)),\n             None => Ok(unsafe { CString::from_vec_unchecked(bytes) }),\n         }"}, {"sha": "79eedbeda2c727375b9c93bc2aa6d5d80245e550", "filename": "src/libstd/io/buffered.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e8d2706cbac46eac7f4cd1554c41c748e00a4a00/src%2Flibstd%2Fio%2Fbuffered.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8d2706cbac46eac7f4cd1554c41c748e00a4a00/src%2Flibstd%2Fio%2Fbuffered.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fbuffered.rs?ref=e8d2706cbac46eac7f4cd1554c41c748e00a4a00", "patch": "@@ -18,6 +18,7 @@ use cmp;\n use error;\n use fmt;\n use io::{self, DEFAULT_BUF_SIZE, Error, ErrorKind, SeekFrom};\n+use memchr;\n \n /// The `BufReader` struct adds buffering to any reader.\n ///\n@@ -746,7 +747,7 @@ impl<W: Write> LineWriter<W> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<W: Write> Write for LineWriter<W> {\n     fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n-        match buf.iter().rposition(|b| *b == b'\\n') {\n+        match memchr::memrchr(b'\\n', buf) {\n             Some(i) => {\n                 let n = try!(self.inner.write(&buf[..i + 1]));\n                 if n != i + 1 { return Ok(n) }"}, {"sha": "cc3f8097a88e9df5bd0236ab88c152e50113228f", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e8d2706cbac46eac7f4cd1554c41c748e00a4a00/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8d2706cbac46eac7f4cd1554c41c748e00a4a00/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=e8d2706cbac46eac7f4cd1554c41c748e00a4a00", "patch": "@@ -254,6 +254,7 @@ use result;\n use string::String;\n use str;\n use vec::Vec;\n+use memchr;\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use self::buffered::{BufReader, BufWriter, LineWriter};\n@@ -1194,7 +1195,7 @@ fn read_until<R: BufRead + ?Sized>(r: &mut R, delim: u8, buf: &mut Vec<u8>)\n                 Err(ref e) if e.kind() == ErrorKind::Interrupted => continue,\n                 Err(e) => return Err(e)\n             };\n-            match available.iter().position(|x| *x == delim) {\n+            match memchr::memchr(delim, available) {\n                 Some(i) => {\n                     buf.extend_from_slice(&available[..i + 1]);\n                     (true, i + 1)"}, {"sha": "eba0c799cd2c1c08208c102ce08924bb4dde3795", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e8d2706cbac46eac7f4cd1554c41c748e00a4a00/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8d2706cbac46eac7f4cd1554c41c748e00a4a00/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=e8d2706cbac46eac7f4cd1554c41c748e00a4a00", "patch": "@@ -248,6 +248,7 @@\n #![feature(link_args)]\n #![feature(linkage)]\n #![feature(macro_reexport)]\n+#![feature(num_bits_bytes)]\n #![feature(on_unimplemented)]\n #![feature(oom)]\n #![feature(optin_builtin_traits)]\n@@ -429,6 +430,7 @@ pub mod path;\n pub mod process;\n pub mod sync;\n pub mod time;\n+mod memchr;\n \n #[macro_use]\n #[path = \"sys/common/mod.rs\"] mod sys_common;"}, {"sha": "c654efd499b6410f7d9b9679b9471392bbe18f85", "filename": "src/libstd/memchr.rs", "status": "added", "additions": 386, "deletions": 0, "changes": 386, "blob_url": "https://github.com/rust-lang/rust/blob/e8d2706cbac46eac7f4cd1554c41c748e00a4a00/src%2Flibstd%2Fmemchr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8d2706cbac46eac7f4cd1554c41c748e00a4a00/src%2Flibstd%2Fmemchr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmemchr.rs?ref=e8d2706cbac46eac7f4cd1554c41c748e00a4a00", "patch": "@@ -0,0 +1,386 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+//\n+// Original implementation taken from rust-memchr\n+// Copyright 2015 Andrew Gallant, bluss and Nicolas Koch\n+\n+\n+\n+/// A safe interface to `memchr`.\n+///\n+/// Returns the index corresponding to the first occurrence of `needle` in\n+/// `haystack`, or `None` if one is not found.\n+///\n+/// memchr reduces to super-optimized machine code at around an order of\n+/// magnitude faster than `haystack.iter().position(|&b| b == needle)`.\n+/// (See benchmarks.)\n+///\n+/// # Example\n+///\n+/// This shows how to find the first position of a byte in a byte string.\n+///\n+/// ```rust,ignore\n+/// use memchr::memchr;\n+///\n+/// let haystack = b\"the quick brown fox\";\n+/// assert_eq!(memchr(b'k', haystack), Some(8));\n+/// ```\n+pub fn memchr(needle: u8, haystack: &[u8]) -> Option<usize> {\n+    // libc memchr\n+    #[cfg(not(target_os = \"windows\"))]\n+    fn memchr_specific(needle: u8, haystack: &[u8]) -> Option<usize> {\n+        use libc;\n+\n+        let p = unsafe {\n+            libc::memchr(\n+                haystack.as_ptr() as *const libc::c_void,\n+                needle as libc::c_int,\n+                haystack.len() as libc::size_t)\n+        };\n+        if p.is_null() {\n+            None\n+        } else {\n+            Some(p as usize - (haystack.as_ptr() as usize))\n+        }\n+    }\n+\n+    // use fallback on windows, since it's faster\n+    #[cfg(target_os = \"windows\")]\n+    fn memchr_specific(needle: u8, haystack: &[u8]) -> Option<usize> {\n+        fallback::memchr(needle, haystack)\n+    }\n+\n+    memchr_specific(needle, haystack)\n+}\n+\n+/// A safe interface to `memrchr`.\n+///\n+/// Returns the index corresponding to the last occurrence of `needle` in\n+/// `haystack`, or `None` if one is not found.\n+///\n+/// # Example\n+///\n+/// This shows how to find the last position of a byte in a byte string.\n+///\n+/// ```rust,ignore\n+/// use memchr::memrchr;\n+///\n+/// let haystack = b\"the quick brown fox\";\n+/// assert_eq!(memrchr(b'o', haystack), Some(17));\n+/// ```\n+pub fn memrchr(needle: u8, haystack: &[u8]) -> Option<usize> {\n+\n+    #[cfg(target_os = \"linux\")]\n+    fn memrchr_specific(needle: u8, haystack: &[u8]) -> Option<usize> {\n+        use libc;\n+\n+        // GNU's memrchr() will - unlike memchr() - error if haystack is empty.\n+        if haystack.is_empty() {return None}\n+        let p = unsafe {\n+            libc::memrchr(\n+                haystack.as_ptr() as *const libc::c_void,\n+                needle as libc::c_int,\n+                haystack.len() as libc::size_t)\n+        };\n+        if p.is_null() {\n+            None\n+        } else {\n+            Some(p as usize - (haystack.as_ptr() as usize))\n+        }\n+    }\n+\n+    #[cfg(not(target_os = \"linux\"))]\n+    fn memrchr_specific(needle: u8, haystack: &[u8]) -> Option<usize> {\n+        haystack.iter().rposition(|&b| b == needle)\n+    }\n+\n+    memrchr_specific(needle, haystack)\n+}\n+\n+#[allow(dead_code)]\n+mod fallback {\n+    use cmp;\n+    use usize;\n+\n+    const LO_U64: u64 = 0x0101010101010101;\n+    const HI_U64: u64 = 0x8080808080808080;\n+\n+    // use truncation\n+    const LO_USIZE: usize = LO_U64 as usize;\n+    const HI_USIZE: usize = HI_U64 as usize;\n+\n+    /// Return `true` if `x` contains any zero byte.\n+    ///\n+    /// From *Matters Computational*, J. Arndt\n+    ///\n+    /// \"The idea is to subtract one from each of the bytes and then look for\n+    /// bytes where the borrow propagated all the way to the most significant\n+    /// bit.\"\n+    #[inline]\n+    fn contains_zero_byte(x: usize) -> bool {\n+        x.wrapping_sub(LO_USIZE) & !x & HI_USIZE != 0\n+    }\n+\n+    #[cfg(target_pointer_width = \"32\")]\n+    #[inline]\n+    fn repeat_byte(b: u8) -> usize {\n+        let mut rep = (b as usize) << 8 | b as usize;\n+        rep = rep << 16 | rep;\n+        rep\n+    }\n+\n+    #[cfg(target_pointer_width = \"64\")]\n+    #[inline]\n+    fn repeat_byte(b: u8) -> usize {\n+        let mut rep = (b as usize) << 8 | b as usize;\n+        rep = rep << 16 | rep;\n+        rep = rep << 32 | rep;\n+        rep\n+    }\n+\n+    /// Return the first index matching the byte `a` in `text`.\n+    pub fn memchr(x: u8, text: &[u8]) -> Option<usize> {\n+        // Scan for a single byte value by reading two `usize` words at a time.\n+        //\n+        // Split `text` in three parts\n+        // - unaligned inital part, before the first word aligned address in text\n+        // - body, scan by 2 words at a time\n+        // - the last remaining part, < 2 word size\n+        let len = text.len();\n+        let ptr = text.as_ptr();\n+\n+        // search up to an aligned boundary\n+        let align = (ptr as usize) & (usize::BYTES- 1);\n+        let mut offset;\n+        if align > 0 {\n+            offset = cmp::min(usize::BYTES - align, len);\n+            if let Some(index) = text[..offset].iter().position(|elt| *elt == x) {\n+                return Some(index);\n+            }\n+        } else {\n+            offset = 0;\n+        }\n+\n+        // search the body of the text\n+        let repeated_x = repeat_byte(x);\n+\n+        if len >= 2 * usize::BYTES {\n+            while offset <= len - 2 * usize::BYTES {\n+                unsafe {\n+                    let u = *(ptr.offset(offset as isize) as *const usize);\n+                    let v = *(ptr.offset((offset + usize::BYTES) as isize) as *const usize);\n+\n+                    // break if there is a matching byte\n+                    let zu = contains_zero_byte(u ^ repeated_x);\n+                    let zv = contains_zero_byte(v ^ repeated_x);\n+                    if zu || zv {\n+                        break;\n+                    }\n+                }\n+                offset += usize::BYTES * 2;\n+            }\n+        }\n+\n+        // find the byte after the point the body loop stopped\n+        text[offset..].iter().position(|elt| *elt == x).map(|i| offset + i)\n+    }\n+\n+    /// Return the last index matching the byte `a` in `text`.\n+    pub fn memrchr(x: u8, text: &[u8]) -> Option<usize> {\n+        // Scan for a single byte value by reading two `usize` words at a time.\n+        //\n+        // Split `text` in three parts\n+        // - unaligned tail, after the last word aligned address in text\n+        // - body, scan by 2 words at a time\n+        // - the first remaining bytes, < 2 word size\n+        let len = text.len();\n+        let ptr = text.as_ptr();\n+\n+        // search to an aligned boundary\n+        let end_align = (ptr as usize + len) & (usize::BYTES - 1);\n+        let mut offset;\n+        if end_align > 0 {\n+            offset = len - cmp::min(usize::BYTES - end_align, len);\n+            if let Some(index) = text[offset..].iter().rposition(|elt| *elt == x) {\n+                return Some(offset + index);\n+            }\n+        } else {\n+            offset = len;\n+        }\n+\n+        // search the body of the text\n+        let repeated_x = repeat_byte(x);\n+\n+        while offset >= 2 * usize::BYTES {\n+            unsafe {\n+                let u = *(ptr.offset(offset as isize - 2 * usize::BYTES as isize) as *const usize);\n+                let v = *(ptr.offset(offset as isize - usize::BYTES as isize) as *const usize);\n+\n+                // break if there is a matching byte\n+                let zu = contains_zero_byte(u ^ repeated_x);\n+                let zv = contains_zero_byte(v ^ repeated_x);\n+                if zu || zv {\n+                    break;\n+                }\n+            }\n+            offset -= 2 * usize::BYTES;\n+        }\n+\n+        // find the byte before the point the body loop stopped\n+        text[..offset].iter().rposition(|elt| *elt == x)\n+    }\n+\n+    // test fallback implementations on all plattforms\n+    #[test]\n+    fn matches_one() {\n+        assert_eq!(Some(0), memchr(b'a', b\"a\"));\n+    }\n+\n+    #[test]\n+    fn matches_begin() {\n+        assert_eq!(Some(0), memchr(b'a', b\"aaaa\"));\n+    }\n+\n+    #[test]\n+    fn matches_end() {\n+        assert_eq!(Some(4), memchr(b'z', b\"aaaaz\"));\n+    }\n+\n+    #[test]\n+    fn matches_nul() {\n+        assert_eq!(Some(4), memchr(b'\\x00', b\"aaaa\\x00\"));\n+    }\n+\n+    #[test]\n+    fn matches_past_nul() {\n+        assert_eq!(Some(5), memchr(b'z', b\"aaaa\\x00z\"));\n+    }\n+\n+    #[test]\n+    fn no_match_empty() {\n+        assert_eq!(None, memchr(b'a', b\"\"));\n+    }\n+\n+    #[test]\n+    fn no_match() {\n+        assert_eq!(None, memchr(b'a', b\"xyz\"));\n+    }\n+\n+    #[test]\n+    fn matches_one_reversed() {\n+        assert_eq!(Some(0), memrchr(b'a', b\"a\"));\n+    }\n+\n+    #[test]\n+    fn matches_begin_reversed() {\n+        assert_eq!(Some(3), memrchr(b'a', b\"aaaa\"));\n+    }\n+\n+    #[test]\n+    fn matches_end_reversed() {\n+        assert_eq!(Some(0), memrchr(b'z', b\"zaaaa\"));\n+    }\n+\n+    #[test]\n+    fn matches_nul_reversed() {\n+        assert_eq!(Some(4), memrchr(b'\\x00', b\"aaaa\\x00\"));\n+    }\n+\n+    #[test]\n+    fn matches_past_nul_reversed() {\n+        assert_eq!(Some(0), memrchr(b'z', b\"z\\x00aaaa\"));\n+    }\n+\n+    #[test]\n+    fn no_match_empty_reversed() {\n+        assert_eq!(None, memrchr(b'a', b\"\"));\n+    }\n+\n+    #[test]\n+    fn no_match_reversed() {\n+        assert_eq!(None, memrchr(b'a', b\"xyz\"));\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    // test the implementations for the current plattform\n+    use super::{memchr, memrchr};\n+\n+    #[test]\n+    fn matches_one() {\n+        assert_eq!(Some(0), memchr(b'a', b\"a\"));\n+    }\n+\n+    #[test]\n+    fn matches_begin() {\n+        assert_eq!(Some(0), memchr(b'a', b\"aaaa\"));\n+    }\n+\n+    #[test]\n+    fn matches_end() {\n+        assert_eq!(Some(4), memchr(b'z', b\"aaaaz\"));\n+    }\n+\n+    #[test]\n+    fn matches_nul() {\n+        assert_eq!(Some(4), memchr(b'\\x00', b\"aaaa\\x00\"));\n+    }\n+\n+    #[test]\n+    fn matches_past_nul() {\n+        assert_eq!(Some(5), memchr(b'z', b\"aaaa\\x00z\"));\n+    }\n+\n+    #[test]\n+    fn no_match_empty() {\n+        assert_eq!(None, memchr(b'a', b\"\"));\n+    }\n+\n+    #[test]\n+    fn no_match() {\n+        assert_eq!(None, memchr(b'a', b\"xyz\"));\n+    }\n+\n+    #[test]\n+    fn matches_one_reversed() {\n+        assert_eq!(Some(0), memrchr(b'a', b\"a\"));\n+    }\n+\n+    #[test]\n+    fn matches_begin_reversed() {\n+        assert_eq!(Some(3), memrchr(b'a', b\"aaaa\"));\n+    }\n+\n+    #[test]\n+    fn matches_end_reversed() {\n+        assert_eq!(Some(0), memrchr(b'z', b\"zaaaa\"));\n+    }\n+\n+    #[test]\n+    fn matches_nul_reversed() {\n+        assert_eq!(Some(4), memrchr(b'\\x00', b\"aaaa\\x00\"));\n+    }\n+\n+    #[test]\n+    fn matches_past_nul_reversed() {\n+        assert_eq!(Some(0), memrchr(b'z', b\"z\\x00aaaa\"));\n+    }\n+\n+    #[test]\n+    fn no_match_empty_reversed() {\n+        assert_eq!(None, memrchr(b'a', b\"\"));\n+    }\n+\n+    #[test]\n+    fn no_match_reversed() {\n+        assert_eq!(None, memrchr(b'a', b\"xyz\"));\n+    }\n+}"}, {"sha": "12b9d6191a05fb5bd483528ba2397d29d11c8c83", "filename": "src/libstd/sys/unix/os.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e8d2706cbac46eac7f4cd1554c41c748e00a4a00/src%2Flibstd%2Fsys%2Funix%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8d2706cbac46eac7f4cd1554c41c748e00a4a00/src%2Flibstd%2Fsys%2Funix%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fos.rs?ref=e8d2706cbac46eac7f4cd1554c41c748e00a4a00", "patch": "@@ -22,6 +22,7 @@ use io;\n use iter;\n use libc::{self, c_int, c_char, c_void};\n use mem;\n+use memchr;\n use path::{self, PathBuf};\n use ptr;\n use slice;\n@@ -406,7 +407,7 @@ pub fn env() -> Env {\n         if input.is_empty() {\n             return None;\n         }\n-        let pos = input[1..].iter().position(|&b| b == b'=').map(|p| p + 1);\n+        let pos = memchr::memchr(b'=', &input[1..]).map(|p| p + 1);\n         pos.map(|p| (\n             OsStringExt::from_vec(input[..p].to_vec()),\n             OsStringExt::from_vec(input[p+1..].to_vec()),"}, {"sha": "2335a3c3348ebd2487404c37c1b63b7135c001b5", "filename": "src/test/run-pass/mir_trans_calls.rs", "status": "added", "additions": 100, "deletions": 0, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/e8d2706cbac46eac7f4cd1554c41c748e00a4a00/src%2Ftest%2Frun-pass%2Fmir_trans_calls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8d2706cbac46eac7f4cd1554c41c748e00a4a00/src%2Ftest%2Frun-pass%2Fmir_trans_calls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmir_trans_calls.rs?ref=e8d2706cbac46eac7f4cd1554c41c748e00a4a00", "patch": "@@ -0,0 +1,100 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(rustc_attrs)]\n+\n+#[rustc_mir]\n+fn test1(a: isize, b: (i32, i32), c: &[i32]) -> (isize, (i32, i32), &[i32]) {\n+    // Test passing a number of arguments including a fat pointer.\n+    // Also returning via an out pointer\n+    fn callee(a: isize, b: (i32, i32), c: &[i32]) -> (isize, (i32, i32), &[i32]) {\n+        (a, b, c)\n+    }\n+    callee(a, b, c)\n+}\n+\n+#[rustc_mir]\n+fn test2(a: isize) -> isize {\n+    // Test passing a single argument.\n+    // Not using out pointer.\n+    fn callee(a: isize) -> isize {\n+        a\n+    }\n+    callee(a)\n+}\n+\n+struct Foo;\n+impl Foo {\n+    fn inherent_method(&self, a: isize) -> isize { a }\n+}\n+\n+#[rustc_mir]\n+fn test3(x: &Foo, a: isize) -> isize {\n+    // Test calling inherent method\n+    x.inherent_method(a)\n+}\n+\n+trait Bar {\n+    fn extension_method(&self, a: isize) -> isize { a }\n+}\n+impl Bar for Foo {}\n+\n+#[rustc_mir]\n+fn test4(x: &Foo, a: isize) -> isize {\n+    // Test calling extension method\n+    x.extension_method(a)\n+}\n+\n+#[rustc_mir]\n+fn test5(x: &Bar, a: isize) -> isize {\n+    // Test calling method on trait object\n+    x.extension_method(a)\n+}\n+\n+#[rustc_mir]\n+fn test6<T: Bar>(x: &T, a: isize) -> isize {\n+    // Test calling extension method on generic callee\n+    x.extension_method(a)\n+}\n+\n+trait One<T = Self> {\n+    fn one() -> T;\n+}\n+impl One for isize {\n+    fn one() -> isize { 1 }\n+}\n+\n+#[rustc_mir]\n+fn test7() -> isize {\n+    // Test calling trait static method\n+    <isize as One>::one()\n+}\n+\n+struct Two;\n+impl Two {\n+    fn two() -> isize { 2 }\n+}\n+\n+#[rustc_mir]\n+fn test8() -> isize {\n+    // Test calling impl static method\n+    Two::two()\n+}\n+\n+fn main() {\n+    assert_eq!(test1(1, (2, 3), &[4, 5, 6]), (1, (2, 3), &[4, 5, 6][..]));\n+    assert_eq!(test2(98), 98);\n+    assert_eq!(test3(&Foo, 42), 42);\n+    assert_eq!(test4(&Foo, 970), 970);\n+    assert_eq!(test5(&Foo, 8576), 8576);\n+    assert_eq!(test6(&Foo, 12367), 12367);\n+    assert_eq!(test7(), 1);\n+    assert_eq!(test8(), 2);\n+}"}]}