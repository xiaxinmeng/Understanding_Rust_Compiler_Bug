{"sha": "bcc9aa01b59432bed050f922e04391ea469263b4", "node_id": "C_kwDOAAsO6NoAKGJjYzlhYTAxYjU5NDMyYmVkMDUwZjkyMmUwNDM5MWVhNDY5MjYzYjQ", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2023-05-06T11:30:03Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2023-05-06T11:30:03Z"}, "message": "Rollup merge of #110577 - compiler-errors:drop-impl-fulfill, r=lcnr\n\nUse fulfillment to check `Drop` impl compatibility\n\nUse an `ObligationCtxt` to ensure that a `Drop` impl does not have stricter requirements than the ADT that it's implemented for, rather than using a `SimpleEqRelation` to (more or less) syntactically equate predicates on an ADT with predicates on an impl.\n\nr? types\n\n### Some background\n\nThe old code reads:\n\n```rust\n// An earlier version of this code attempted to do this checking\n// via the traits::fulfill machinery. However, it ran into trouble\n// since the fulfill machinery merely turns outlives-predicates\n// 'a:'b and T:'b into region inference constraints. It is simpler\n// just to look for all the predicates directly.\n```\n\nI'm not sure what this means, but perhaps in the 8 years since that this comment was written (cc #23638) it's gotten easier to process region constraints after doing fulfillment? I don't know how this logic differs from anything we do in the `compare_impl_item` module. Ironically, later on it says:\n\n```rust\n// However, it may be more efficient in the future to batch\n// the analysis together via the fulfill (see comment above regarding\n// the usage of the fulfill machinery), rather than the\n// repeated `.iter().any(..)` calls.\n```\n\nAlso:\n* Removes `SimpleEqRelation` which was far too syntactical in its relation.\n* Fixes #110557", "tree": {"sha": "96efe525f18a0b1b70f0e21184f63a52f4cd29c8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/96efe525f18a0b1b70f0e21184f63a52f4cd29c8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bcc9aa01b59432bed050f922e04391ea469263b4", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJkVjo7CRBK7hj4Ov3rIwAAk1EIAF678xO/WdJ7hogx26/rz3QZ\n17XLgR2DGGK2+n0Yo3NH5oWpUPNy4s8WXFJvC0iYE2xGhLl0X5unUkcmIWXKi5wS\n9SopvespiXy+3JwM4DSUmE1YvGVt2olo1Ky10dbm3/s/RZZc1Sqipft0tHcnNGcb\nX+wi3eGHkiQp0bNTzSi6HDOe7PV6RsXQiv1fY1rA2dVuGU/XpoI7ZTda0wB6GOgE\nAaEyYxb+RG1R+vJFlPkc1XdazQnlBE0oVutzjnqkaP1l3UgrIUMeFfOHOxVvnH5+\noufyK+weljrqVRbi2tCNZQ7kTq+3EBFy7U9RSPQW1h2dYjng/A3fTxd1oXh5hhs=\n=dOgb\n-----END PGP SIGNATURE-----\n", "payload": "tree 96efe525f18a0b1b70f0e21184f63a52f4cd29c8\nparent 151a070afe09c0c844e8d9af98a20fee56a5a7f2\nparent 2e346b6f3f3be75d0e0b536a6a8cf2f82241b3b4\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1683372603 +0200\ncommitter GitHub <noreply@github.com> 1683372603 +0200\n\nRollup merge of #110577 - compiler-errors:drop-impl-fulfill, r=lcnr\n\nUse fulfillment to check `Drop` impl compatibility\n\nUse an `ObligationCtxt` to ensure that a `Drop` impl does not have stricter requirements than the ADT that it's implemented for, rather than using a `SimpleEqRelation` to (more or less) syntactically equate predicates on an ADT with predicates on an impl.\n\nr? types\n\n### Some background\n\nThe old code reads:\n\n```rust\n// An earlier version of this code attempted to do this checking\n// via the traits::fulfill machinery. However, it ran into trouble\n// since the fulfill machinery merely turns outlives-predicates\n// 'a:'b and T:'b into region inference constraints. It is simpler\n// just to look for all the predicates directly.\n```\n\nI'm not sure what this means, but perhaps in the 8 years since that this comment was written (cc #23638) it's gotten easier to process region constraints after doing fulfillment? I don't know how this logic differs from anything we do in the `compare_impl_item` module. Ironically, later on it says:\n\n```rust\n// However, it may be more efficient in the future to batch\n// the analysis together via the fulfill (see comment above regarding\n// the usage of the fulfill machinery), rather than the\n// repeated `.iter().any(..)` calls.\n```\n\nAlso:\n* Removes `SimpleEqRelation` which was far too syntactical in its relation.\n* Fixes #110557\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bcc9aa01b59432bed050f922e04391ea469263b4", "html_url": "https://github.com/rust-lang/rust/commit/bcc9aa01b59432bed050f922e04391ea469263b4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bcc9aa01b59432bed050f922e04391ea469263b4/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "151a070afe09c0c844e8d9af98a20fee56a5a7f2", "url": "https://api.github.com/repos/rust-lang/rust/commits/151a070afe09c0c844e8d9af98a20fee56a5a7f2", "html_url": "https://github.com/rust-lang/rust/commit/151a070afe09c0c844e8d9af98a20fee56a5a7f2"}, {"sha": "2e346b6f3f3be75d0e0b536a6a8cf2f82241b3b4", "url": "https://api.github.com/repos/rust-lang/rust/commits/2e346b6f3f3be75d0e0b536a6a8cf2f82241b3b4", "html_url": "https://github.com/rust-lang/rust/commit/2e346b6f3f3be75d0e0b536a6a8cf2f82241b3b4"}], "stats": {"total": 682, "additions": 448, "deletions": 234}, "files": [{"sha": "5ba1ca1c807bce908450ca87d5c4b7d87ddc1e0e", "filename": "compiler/rustc_hir_analysis/src/check/dropck.rs", "status": "modified", "additions": 91, "deletions": 233, "changes": 324, "blob_url": "https://github.com/rust-lang/rust/blob/bcc9aa01b59432bed050f922e04391ea469263b4/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcc9aa01b59432bed050f922e04391ea469263b4/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fdropck.rs?ref=bcc9aa01b59432bed050f922e04391ea469263b4", "patch": "@@ -1,12 +1,14 @@\n // FIXME(@lcnr): Move this module out of `rustc_hir_analysis`.\n //\n // We don't do any drop checking during hir typeck.\n+use rustc_data_structures::fx::FxHashSet;\n use rustc_errors::{struct_span_err, ErrorGuaranteed};\n-use rustc_middle::ty::error::TypeError;\n-use rustc_middle::ty::relate::{Relate, RelateResult, TypeRelation};\n+use rustc_infer::infer::outlives::env::OutlivesEnvironment;\n+use rustc_infer::infer::{RegionResolutionError, TyCtxtInferExt};\n use rustc_middle::ty::subst::SubstsRef;\n use rustc_middle::ty::util::IgnoreRegions;\n-use rustc_middle::ty::{self, Predicate, Ty, TyCtxt};\n+use rustc_middle::ty::{self, TyCtxt};\n+use rustc_trait_selection::traits::{self, ObligationCtxt};\n \n use crate::errors;\n use crate::hir::def_id::{DefId, LocalDefId};\n@@ -43,21 +45,20 @@ pub fn check_drop_impl(tcx: TyCtxt<'_>, drop_impl_did: DefId) -> Result<(), Erro\n         }\n     }\n     let dtor_self_type = tcx.type_of(drop_impl_did).subst_identity();\n-    let dtor_predicates = tcx.predicates_of(drop_impl_did);\n     match dtor_self_type.kind() {\n-        ty::Adt(adt_def, self_to_impl_substs) => {\n+        ty::Adt(adt_def, adt_to_impl_substs) => {\n             ensure_drop_params_and_item_params_correspond(\n                 tcx,\n                 drop_impl_did.expect_local(),\n                 adt_def.did(),\n-                self_to_impl_substs,\n+                adt_to_impl_substs,\n             )?;\n \n             ensure_drop_predicates_are_implied_by_item_defn(\n                 tcx,\n-                dtor_predicates,\n+                drop_impl_did.expect_local(),\n                 adt_def.did().expect_local(),\n-                self_to_impl_substs,\n+                adt_to_impl_substs,\n             )\n         }\n         _ => {\n@@ -78,9 +79,9 @@ fn ensure_drop_params_and_item_params_correspond<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     drop_impl_did: LocalDefId,\n     self_type_did: DefId,\n-    drop_impl_substs: SubstsRef<'tcx>,\n+    adt_to_impl_substs: SubstsRef<'tcx>,\n ) -> Result<(), ErrorGuaranteed> {\n-    let Err(arg) = tcx.uses_unique_generic_params(drop_impl_substs, IgnoreRegions::No) else {\n+    let Err(arg) = tcx.uses_unique_generic_params(adt_to_impl_substs, IgnoreRegions::No) else {\n         return Ok(())\n     };\n \n@@ -111,237 +112,94 @@ fn ensure_drop_params_and_item_params_correspond<'tcx>(\n /// implied by assuming the predicates attached to self_type_did.\n fn ensure_drop_predicates_are_implied_by_item_defn<'tcx>(\n     tcx: TyCtxt<'tcx>,\n-    dtor_predicates: ty::GenericPredicates<'tcx>,\n-    self_type_did: LocalDefId,\n-    self_to_impl_substs: SubstsRef<'tcx>,\n+    drop_impl_def_id: LocalDefId,\n+    adt_def_id: LocalDefId,\n+    adt_to_impl_substs: SubstsRef<'tcx>,\n ) -> Result<(), ErrorGuaranteed> {\n-    let mut result = Ok(());\n-\n-    // Here is an example, analogous to that from\n-    // `compare_impl_method`.\n-    //\n-    // Consider a struct type:\n-    //\n-    //     struct Type<'c, 'b:'c, 'a> {\n-    //         x: &'a Contents            // (contents are irrelevant;\n-    //         y: &'c Cell<&'b Contents>, //  only the bounds matter for our purposes.)\n-    //     }\n-    //\n-    // and a Drop impl:\n-    //\n-    //     impl<'z, 'y:'z, 'x:'y> Drop for P<'z, 'y, 'x> {\n-    //         fn drop(&mut self) { self.y.set(self.x); } // (only legal if 'x: 'y)\n-    //     }\n-    //\n-    // We start out with self_to_impl_substs, that maps the generic\n-    // parameters of Type to that of the Drop impl.\n+    let infcx = tcx.infer_ctxt().build();\n+    let ocx = ObligationCtxt::new(&infcx);\n+\n+    // Take the param-env of the adt and substitute the substs that show up in\n+    // the implementation's self type. This gives us the assumptions that the\n+    // self ty of the implementation is allowed to know just from it being a\n+    // well-formed adt, since that's all we're allowed to assume while proving\n+    // the Drop implementation is not specialized.\n     //\n-    //     self_to_impl_substs = {'c => 'z, 'b => 'y, 'a => 'x}\n-    //\n-    // Applying this to the predicates (i.e., assumptions) provided by the item\n-    // definition yields the instantiated assumptions:\n-    //\n-    //     ['y : 'z]\n-    //\n-    // We then check all of the predicates of the Drop impl:\n-    //\n-    //     ['y:'z, 'x:'y]\n-    //\n-    // and ensure each is in the list of instantiated\n-    // assumptions. Here, `'y:'z` is present, but `'x:'y` is\n-    // absent. So we report an error that the Drop impl injected a\n-    // predicate that is not present on the struct definition.\n-\n-    // We can assume the predicates attached to struct/enum definition\n-    // hold.\n-    let generic_assumptions = tcx.predicates_of(self_type_did);\n-\n-    let assumptions_in_impl_context = generic_assumptions.instantiate(tcx, &self_to_impl_substs);\n-    let assumptions_in_impl_context = assumptions_in_impl_context.predicates;\n-\n-    debug!(?assumptions_in_impl_context, ?dtor_predicates.predicates);\n-\n-    let self_param_env = tcx.param_env(self_type_did);\n-\n-    // An earlier version of this code attempted to do this checking\n-    // via the traits::fulfill machinery. However, it ran into trouble\n-    // since the fulfill machinery merely turns outlives-predicates\n-    // 'a:'b and T:'b into region inference constraints. It is simpler\n-    // just to look for all the predicates directly.\n-\n-    assert_eq!(dtor_predicates.parent, None);\n-    for &(predicate, predicate_sp) in dtor_predicates.predicates {\n-        // (We do not need to worry about deep analysis of type\n-        // expressions etc because the Drop impls are already forced\n-        // to take on a structure that is roughly an alpha-renaming of\n-        // the generic parameters of the item definition.)\n-\n-        // This path now just checks *all* predicates via an instantiation of\n-        // the `SimpleEqRelation`, which simply forwards to the `relate` machinery\n-        // after taking care of anonymizing late bound regions.\n-        //\n-        // However, it may be more efficient in the future to batch\n-        // the analysis together via the fulfill (see comment above regarding\n-        // the usage of the fulfill machinery), rather than the\n-        // repeated `.iter().any(..)` calls.\n+    // We don't need to normalize this param-env or anything, since we're only\n+    // substituting it with free params, so no additional param-env normalization\n+    // can occur on top of what has been done in the param_env query itself.\n+    let param_env = ty::EarlyBinder(tcx.param_env(adt_def_id))\n+        .subst(tcx, adt_to_impl_substs)\n+        .with_constness(tcx.constness(drop_impl_def_id));\n+\n+    for (pred, span) in tcx.predicates_of(drop_impl_def_id).instantiate_identity(tcx) {\n+        let normalize_cause = traits::ObligationCause::misc(span, adt_def_id);\n+        let pred = ocx.normalize(&normalize_cause, param_env, pred);\n+        let cause = traits::ObligationCause::new(span, adt_def_id, traits::DropImpl);\n+        ocx.register_obligation(traits::Obligation::new(tcx, cause, param_env, pred));\n+    }\n \n-        // This closure is a more robust way to check `Predicate` equality\n-        // than simple `==` checks (which were the previous implementation).\n-        // It relies on `ty::relate` for `TraitPredicate`, `ProjectionPredicate`,\n-        // `ConstEvaluatable` and `TypeOutlives` (which implement the Relate trait),\n-        // while delegating on simple equality for the other `Predicate`.\n-        // This implementation solves (Issue #59497) and (Issue #58311).\n-        // It is unclear to me at the moment whether the approach based on `relate`\n-        // could be extended easily also to the other `Predicate`.\n-        let predicate_matches_closure = |p: Predicate<'tcx>| {\n-            let mut relator: SimpleEqRelation<'tcx> = SimpleEqRelation::new(tcx, self_param_env);\n-            let predicate = predicate.kind();\n-            let p = p.kind();\n-            match (predicate.skip_binder(), p.skip_binder()) {\n-                (\n-                    ty::PredicateKind::Clause(ty::Clause::Trait(a)),\n-                    ty::PredicateKind::Clause(ty::Clause::Trait(b)),\n-                ) => relator.relate(predicate.rebind(a), p.rebind(b)).is_ok(),\n-                (\n-                    ty::PredicateKind::Clause(ty::Clause::Projection(a)),\n-                    ty::PredicateKind::Clause(ty::Clause::Projection(b)),\n-                ) => relator.relate(predicate.rebind(a), p.rebind(b)).is_ok(),\n-                (\n-                    ty::PredicateKind::ConstEvaluatable(a),\n-                    ty::PredicateKind::ConstEvaluatable(b),\n-                ) => relator.relate(predicate.rebind(a), predicate.rebind(b)).is_ok(),\n-                (\n-                    ty::PredicateKind::Clause(ty::Clause::TypeOutlives(ty::OutlivesPredicate(\n-                        ty_a,\n-                        lt_a,\n-                    ))),\n-                    ty::PredicateKind::Clause(ty::Clause::TypeOutlives(ty::OutlivesPredicate(\n-                        ty_b,\n-                        lt_b,\n-                    ))),\n-                ) => {\n-                    relator.relate(predicate.rebind(ty_a), p.rebind(ty_b)).is_ok()\n-                        && relator.relate(predicate.rebind(lt_a), p.rebind(lt_b)).is_ok()\n-                }\n-                (ty::PredicateKind::WellFormed(arg_a), ty::PredicateKind::WellFormed(arg_b)) => {\n-                    relator.relate(predicate.rebind(arg_a), p.rebind(arg_b)).is_ok()\n-                }\n-                _ => predicate == p,\n+    // All of the custom error reporting logic is to preserve parity with the old\n+    // error messages.\n+    //\n+    // They can probably get removed with better treatment of the new `DropImpl`\n+    // obligation cause code, and perhaps some custom logic in `report_region_errors`.\n+\n+    let errors = ocx.select_all_or_error();\n+    if !errors.is_empty() {\n+        let mut guar = None;\n+        let mut root_predicates = FxHashSet::default();\n+        for error in errors {\n+            let root_predicate = error.root_obligation.predicate;\n+            if root_predicates.insert(root_predicate) {\n+                let item_span = tcx.def_span(adt_def_id);\n+                let self_descr = tcx.def_descr(adt_def_id.to_def_id());\n+                guar = Some(\n+                    struct_span_err!(\n+                        tcx.sess,\n+                        error.root_obligation.cause.span,\n+                        E0367,\n+                        \"`Drop` impl requires `{root_predicate}` \\\n+                        but the {self_descr} it is implemented for does not\",\n+                    )\n+                    .span_note(item_span, \"the implementor must specify the same requirement\")\n+                    .emit(),\n+                );\n             }\n-        };\n-\n-        if !assumptions_in_impl_context.iter().copied().any(predicate_matches_closure) {\n-            let item_span = tcx.def_span(self_type_did);\n-            let self_descr = tcx.def_descr(self_type_did.to_def_id());\n-            let reported = struct_span_err!(\n-                tcx.sess,\n-                predicate_sp,\n-                E0367,\n-                \"`Drop` impl requires `{predicate}` but the {self_descr} it is implemented for does not\",\n-            )\n-            .span_note(item_span, \"the implementor must specify the same requirement\")\n-            .emit();\n-            result = Err(reported);\n         }\n+        return Err(guar.unwrap());\n     }\n \n-    result\n-}\n-\n-/// This is an implementation of the [`TypeRelation`] trait with the\n-/// aim of simply comparing for equality (without side-effects).\n-///\n-/// It is not intended to be used anywhere else other than here.\n-pub(crate) struct SimpleEqRelation<'tcx> {\n-    tcx: TyCtxt<'tcx>,\n-    param_env: ty::ParamEnv<'tcx>,\n-}\n-\n-impl<'tcx> SimpleEqRelation<'tcx> {\n-    fn new(tcx: TyCtxt<'tcx>, param_env: ty::ParamEnv<'tcx>) -> SimpleEqRelation<'tcx> {\n-        SimpleEqRelation { tcx, param_env }\n-    }\n-}\n-\n-impl<'tcx> TypeRelation<'tcx> for SimpleEqRelation<'tcx> {\n-    fn tcx(&self) -> TyCtxt<'tcx> {\n-        self.tcx\n-    }\n-\n-    fn param_env(&self) -> ty::ParamEnv<'tcx> {\n-        self.param_env\n-    }\n-\n-    fn tag(&self) -> &'static str {\n-        \"dropck::SimpleEqRelation\"\n-    }\n-\n-    fn a_is_expected(&self) -> bool {\n-        true\n-    }\n-\n-    fn relate_with_variance<T: Relate<'tcx>>(\n-        &mut self,\n-        _: ty::Variance,\n-        _info: ty::VarianceDiagInfo<'tcx>,\n-        a: T,\n-        b: T,\n-    ) -> RelateResult<'tcx, T> {\n-        // Here we ignore variance because we require drop impl's types\n-        // to be *exactly* the same as to the ones in the struct definition.\n-        self.relate(a, b)\n-    }\n-\n-    fn tys(&mut self, a: Ty<'tcx>, b: Ty<'tcx>) -> RelateResult<'tcx, Ty<'tcx>> {\n-        debug!(\"SimpleEqRelation::tys(a={:?}, b={:?})\", a, b);\n-        ty::relate::super_relate_tys(self, a, b)\n-    }\n-\n-    fn regions(\n-        &mut self,\n-        a: ty::Region<'tcx>,\n-        b: ty::Region<'tcx>,\n-    ) -> RelateResult<'tcx, ty::Region<'tcx>> {\n-        debug!(\"SimpleEqRelation::regions(a={:?}, b={:?})\", a, b);\n-\n-        // We can just equate the regions because LBRs have been\n-        // already anonymized.\n-        if a == b {\n-            Ok(a)\n-        } else {\n-            // I'm not sure is this `TypeError` is the right one, but\n-            // it should not matter as it won't be checked (the dropck\n-            // will emit its own, more informative and higher-level errors\n-            // in case anything goes wrong).\n-            Err(TypeError::RegionsPlaceholderMismatch)\n+    let errors = ocx.infcx.resolve_regions(&OutlivesEnvironment::new(param_env));\n+    if !errors.is_empty() {\n+        let mut guar = None;\n+        for error in errors {\n+            let item_span = tcx.def_span(adt_def_id);\n+            let self_descr = tcx.def_descr(adt_def_id.to_def_id());\n+            let outlives = match error {\n+                RegionResolutionError::ConcreteFailure(_, a, b) => format!(\"{b}: {a}\"),\n+                RegionResolutionError::GenericBoundFailure(_, generic, r) => {\n+                    format!(\"{generic}: {r}\")\n+                }\n+                RegionResolutionError::SubSupConflict(_, _, _, a, _, b, _) => format!(\"{b}: {a}\"),\n+                RegionResolutionError::UpperBoundUniverseConflict(a, _, _, _, b) => {\n+                    format!(\"{b}: {a}\", a = tcx.mk_re_var(a))\n+                }\n+            };\n+            guar = Some(\n+                struct_span_err!(\n+                    tcx.sess,\n+                    error.origin().span(),\n+                    E0367,\n+                    \"`Drop` impl requires `{outlives}` \\\n+                    but the {self_descr} it is implemented for does not\",\n+                )\n+                .span_note(item_span, \"the implementor must specify the same requirement\")\n+                .emit(),\n+            );\n         }\n+        return Err(guar.unwrap());\n     }\n \n-    fn consts(\n-        &mut self,\n-        a: ty::Const<'tcx>,\n-        b: ty::Const<'tcx>,\n-    ) -> RelateResult<'tcx, ty::Const<'tcx>> {\n-        debug!(\"SimpleEqRelation::consts(a={:?}, b={:?})\", a, b);\n-        ty::relate::super_relate_consts(self, a, b)\n-    }\n-\n-    fn binders<T>(\n-        &mut self,\n-        a: ty::Binder<'tcx, T>,\n-        b: ty::Binder<'tcx, T>,\n-    ) -> RelateResult<'tcx, ty::Binder<'tcx, T>>\n-    where\n-        T: Relate<'tcx>,\n-    {\n-        debug!(\"SimpleEqRelation::binders({:?}: {:?}\", a, b);\n-\n-        // Anonymizing the LBRs is necessary to solve (Issue #59497).\n-        // After we do so, it should be totally fine to skip the binders.\n-        let anon_a = self.tcx.anonymize_bound_vars(a);\n-        let anon_b = self.tcx.anonymize_bound_vars(b);\n-        self.relate(anon_a.skip_binder(), anon_b.skip_binder())?;\n-\n-        Ok(a)\n-    }\n+    Ok(())\n }"}, {"sha": "8482ae2aa38c81f7645036c9d044aac9513ac020", "filename": "compiler/rustc_infer/src/infer/lexical_region_resolve/mod.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/bcc9aa01b59432bed050f922e04391ea469263b4/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flexical_region_resolve%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcc9aa01b59432bed050f922e04391ea469263b4/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flexical_region_resolve%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flexical_region_resolve%2Fmod.rs?ref=bcc9aa01b59432bed050f922e04391ea469263b4", "patch": "@@ -102,6 +102,17 @@ pub enum RegionResolutionError<'tcx> {\n     ),\n }\n \n+impl<'tcx> RegionResolutionError<'tcx> {\n+    pub fn origin(&self) -> &SubregionOrigin<'tcx> {\n+        match self {\n+            RegionResolutionError::ConcreteFailure(origin, _, _)\n+            | RegionResolutionError::GenericBoundFailure(origin, _, _)\n+            | RegionResolutionError::SubSupConflict(_, _, origin, _, _, _, _)\n+            | RegionResolutionError::UpperBoundUniverseConflict(_, _, _, origin, _) => origin,\n+        }\n+    }\n+}\n+\n struct RegionAndOrigin<'tcx> {\n     region: Region<'tcx>,\n     origin: SubregionOrigin<'tcx>,"}, {"sha": "8366567c2c3649c15ebaf372f145ee53631bcac9", "filename": "compiler/rustc_middle/src/traits/mod.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bcc9aa01b59432bed050f922e04391ea469263b4/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcc9aa01b59432bed050f922e04391ea469263b4/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs?ref=bcc9aa01b59432bed050f922e04391ea469263b4", "patch": "@@ -444,6 +444,10 @@ pub enum ObligationCauseCode<'tcx> {\n     AscribeUserTypeProvePredicate(Span),\n \n     RustCall,\n+\n+    /// Obligations to prove that a `std::ops::Drop` impl is not stronger than\n+    /// the ADT it's being implemented for.\n+    DropImpl,\n }\n \n /// The 'location' at which we try to perform HIR-based wf checking."}, {"sha": "53bf38c0a340fddfd5d4b7d643af6fff5e9a096f", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bcc9aa01b59432bed050f922e04391ea469263b4/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcc9aa01b59432bed050f922e04391ea469263b4/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=bcc9aa01b59432bed050f922e04391ea469263b4", "patch": "@@ -2793,7 +2793,8 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n             | ObligationCauseCode::LetElse\n             | ObligationCauseCode::BinOp { .. }\n             | ObligationCauseCode::AscribeUserTypeProvePredicate(..)\n-            | ObligationCauseCode::RustCall => {}\n+            | ObligationCauseCode::RustCall\n+            | ObligationCauseCode::DropImpl => {}\n             ObligationCauseCode::SliceOrArrayElem => {\n                 err.note(\"slice and array elements must have `Sized` type\");\n             }"}, {"sha": "3b506c7e7ec13865f64131e738dc19204d6bbf47", "filename": "tests/ui/dropck/explicit-drop-bounds.bad1.stderr", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/bcc9aa01b59432bed050f922e04391ea469263b4/tests%2Fui%2Fdropck%2Fexplicit-drop-bounds.bad1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bcc9aa01b59432bed050f922e04391ea469263b4/tests%2Fui%2Fdropck%2Fexplicit-drop-bounds.bad1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fdropck%2Fexplicit-drop-bounds.bad1.stderr?ref=bcc9aa01b59432bed050f922e04391ea469263b4", "patch": "@@ -0,0 +1,35 @@\n+error[E0277]: the trait bound `T: Copy` is not satisfied\n+  --> $DIR/explicit-drop-bounds.rs:27:18\n+   |\n+LL | impl<T> Drop for DropMe<T>\n+   |                  ^^^^^^^^^ the trait `Copy` is not implemented for `T`\n+   |\n+note: required by a bound in `DropMe`\n+  --> $DIR/explicit-drop-bounds.rs:7:18\n+   |\n+LL | struct DropMe<T: Copy>(T);\n+   |                  ^^^^ required by this bound in `DropMe`\n+help: consider further restricting type parameter `T`\n+   |\n+LL |     [T; 1]: Copy, T: std::marker::Copy // But `[T; 1]: Copy` does not imply `T: Copy`\n+   |                 ~~~~~~~~~~~~~~~~~~~~~~\n+\n+error[E0277]: the trait bound `T: Copy` is not satisfied\n+  --> $DIR/explicit-drop-bounds.rs:32:13\n+   |\n+LL |     fn drop(&mut self) {}\n+   |             ^^^^^^^^^ the trait `Copy` is not implemented for `T`\n+   |\n+note: required by a bound in `DropMe`\n+  --> $DIR/explicit-drop-bounds.rs:7:18\n+   |\n+LL | struct DropMe<T: Copy>(T);\n+   |                  ^^^^ required by this bound in `DropMe`\n+help: consider further restricting type parameter `T`\n+   |\n+LL |     [T; 1]: Copy, T: std::marker::Copy // But `[T; 1]: Copy` does not imply `T: Copy`\n+   |                 ~~~~~~~~~~~~~~~~~~~~~~\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "832af3e521a9dbfbd1cd6e94466f5ef9d6b45bfc", "filename": "tests/ui/dropck/explicit-drop-bounds.bad2.stderr", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/bcc9aa01b59432bed050f922e04391ea469263b4/tests%2Fui%2Fdropck%2Fexplicit-drop-bounds.bad2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bcc9aa01b59432bed050f922e04391ea469263b4/tests%2Fui%2Fdropck%2Fexplicit-drop-bounds.bad2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fdropck%2Fexplicit-drop-bounds.bad2.stderr?ref=bcc9aa01b59432bed050f922e04391ea469263b4", "patch": "@@ -0,0 +1,35 @@\n+error[E0277]: the trait bound `T: Copy` is not satisfied\n+  --> $DIR/explicit-drop-bounds.rs:37:18\n+   |\n+LL | impl<T> Drop for DropMe<T>\n+   |                  ^^^^^^^^^ the trait `Copy` is not implemented for `T`\n+   |\n+note: required by a bound in `DropMe`\n+  --> $DIR/explicit-drop-bounds.rs:7:18\n+   |\n+LL | struct DropMe<T: Copy>(T);\n+   |                  ^^^^ required by this bound in `DropMe`\n+help: consider restricting type parameter `T`\n+   |\n+LL | impl<T: std::marker::Copy> Drop for DropMe<T>\n+   |       +++++++++++++++++++\n+\n+error[E0277]: the trait bound `T: Copy` is not satisfied\n+  --> $DIR/explicit-drop-bounds.rs:40:13\n+   |\n+LL |     fn drop(&mut self) {}\n+   |             ^^^^^^^^^ the trait `Copy` is not implemented for `T`\n+   |\n+note: required by a bound in `DropMe`\n+  --> $DIR/explicit-drop-bounds.rs:7:18\n+   |\n+LL | struct DropMe<T: Copy>(T);\n+   |                  ^^^^ required by this bound in `DropMe`\n+help: consider restricting type parameter `T`\n+   |\n+LL | impl<T: std::marker::Copy> Drop for DropMe<T>\n+   |       +++++++++++++++++++\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "ab6f33c09994e443c515b4b3e90df8683bd523ec", "filename": "tests/ui/dropck/explicit-drop-bounds.rs", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/bcc9aa01b59432bed050f922e04391ea469263b4/tests%2Fui%2Fdropck%2Fexplicit-drop-bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcc9aa01b59432bed050f922e04391ea469263b4/tests%2Fui%2Fdropck%2Fexplicit-drop-bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fdropck%2Fexplicit-drop-bounds.rs?ref=bcc9aa01b59432bed050f922e04391ea469263b4", "patch": "@@ -0,0 +1,44 @@\n+// revisions: good1 good2 bad1 bad2\n+//[good1] check-pass\n+//[good2] check-pass\n+\n+use std::ops::Drop;\n+\n+struct DropMe<T: Copy>(T);\n+\n+#[cfg(good1)]\n+impl<T> Drop for DropMe<T>\n+where\n+    T: Copy + Clone,\n+{\n+    fn drop(&mut self) {}\n+}\n+\n+#[cfg(good2)]\n+impl<T> Drop for DropMe<T>\n+where\n+    T: Copy,\n+    [T; 1]: Copy, // Trivial bound implied by `T: Copy`\n+{\n+    fn drop(&mut self) {}\n+}\n+\n+#[cfg(bad1)]\n+impl<T> Drop for DropMe<T>\n+//[bad1]~^ ERROR the trait bound `T: Copy` is not satisfied\n+where\n+    [T; 1]: Copy, // But `[T; 1]: Copy` does not imply `T: Copy`\n+{\n+    fn drop(&mut self) {}\n+    //[bad1]~^ ERROR the trait bound `T: Copy` is not satisfied\n+}\n+\n+#[cfg(bad2)]\n+impl<T> Drop for DropMe<T>\n+//[bad2]~^ ERROR the trait bound `T: Copy` is not satisfied\n+{\n+    fn drop(&mut self) {}\n+    //[bad2]~^ ERROR the trait bound `T: Copy` is not satisfied\n+}\n+\n+fn main() {}"}, {"sha": "bf6d70e7d3758d3808465894cee248400aa74887", "filename": "tests/ui/dropck/explicit-implied-outlives.bad1.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/bcc9aa01b59432bed050f922e04391ea469263b4/tests%2Fui%2Fdropck%2Fexplicit-implied-outlives.bad1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bcc9aa01b59432bed050f922e04391ea469263b4/tests%2Fui%2Fdropck%2Fexplicit-implied-outlives.bad1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fdropck%2Fexplicit-implied-outlives.bad1.stderr?ref=bcc9aa01b59432bed050f922e04391ea469263b4", "patch": "@@ -0,0 +1,15 @@\n+error[E0367]: `Drop` impl requires `T: 'static` but the struct it is implemented for does not\n+  --> $DIR/explicit-implied-outlives.rs:28:8\n+   |\n+LL |     T: 'static,\n+   |        ^^^^^^^\n+   |\n+note: the implementor must specify the same requirement\n+  --> $DIR/explicit-implied-outlives.rs:7:1\n+   |\n+LL | struct DropMe<'a, T>(&'a T);\n+   | ^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0367`."}, {"sha": "27a15170bddb53490a8fcb45a6d7bcbab2623527", "filename": "tests/ui/dropck/explicit-implied-outlives.bad2.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/bcc9aa01b59432bed050f922e04391ea469263b4/tests%2Fui%2Fdropck%2Fexplicit-implied-outlives.bad2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bcc9aa01b59432bed050f922e04391ea469263b4/tests%2Fui%2Fdropck%2Fexplicit-implied-outlives.bad2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fdropck%2Fexplicit-implied-outlives.bad2.stderr?ref=bcc9aa01b59432bed050f922e04391ea469263b4", "patch": "@@ -0,0 +1,15 @@\n+error[E0367]: `Drop` impl requires `'a: 'static` but the struct it is implemented for does not\n+  --> $DIR/explicit-implied-outlives.rs:37:9\n+   |\n+LL |     'a: 'static,\n+   |         ^^^^^^^\n+   |\n+note: the implementor must specify the same requirement\n+  --> $DIR/explicit-implied-outlives.rs:7:1\n+   |\n+LL | struct DropMe<'a, T>(&'a T);\n+   | ^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0367`."}, {"sha": "fa446591f3dc4e167db68ed96036d0a3f7b816a7", "filename": "tests/ui/dropck/explicit-implied-outlives.rs", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/bcc9aa01b59432bed050f922e04391ea469263b4/tests%2Fui%2Fdropck%2Fexplicit-implied-outlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcc9aa01b59432bed050f922e04391ea469263b4/tests%2Fui%2Fdropck%2Fexplicit-implied-outlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fdropck%2Fexplicit-implied-outlives.rs?ref=bcc9aa01b59432bed050f922e04391ea469263b4", "patch": "@@ -0,0 +1,43 @@\n+// revisions: good1 good2 bad1 bad2\n+//[good1] check-pass\n+//[good2] check-pass\n+\n+use std::ops::Drop;\n+\n+struct DropMe<'a, T>(&'a T);\n+\n+#[cfg(good1)]\n+impl<'a, T> Drop for DropMe<'a, T>\n+where\n+    T: 'a, // Implied by struct, explicit on impl\n+{\n+    fn drop(&mut self) {}\n+}\n+\n+#[cfg(good2)]\n+impl<'a, T> Drop for DropMe<'a, T>\n+where\n+    'static: 'a, // Trivial bound\n+{\n+    fn drop(&mut self) {}\n+}\n+\n+#[cfg(bad1)]\n+impl<'a, T> Drop for DropMe<'a, T>\n+where\n+    T: 'static,\n+    //[bad1]~^ ERROR `Drop` impl requires `T: 'static`\n+{\n+    fn drop(&mut self) {}\n+}\n+\n+#[cfg(bad2)]\n+impl<'a, T> Drop for DropMe<'a, T>\n+where\n+    'a: 'static,\n+    //[bad2]~^ ERROR `Drop` impl requires `'a: 'static`\n+{\n+    fn drop(&mut self) {}\n+}\n+\n+fn main() {}"}, {"sha": "87154e25d4091fbf2f539dc3682ba8d96c33ef53", "filename": "tests/ui/dropck/transitive-outlives-2.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/bcc9aa01b59432bed050f922e04391ea469263b4/tests%2Fui%2Fdropck%2Ftransitive-outlives-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcc9aa01b59432bed050f922e04391ea469263b4/tests%2Fui%2Fdropck%2Ftransitive-outlives-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fdropck%2Ftransitive-outlives-2.rs?ref=bcc9aa01b59432bed050f922e04391ea469263b4", "patch": "@@ -0,0 +1,18 @@\n+// check-pass\n+\n+use std::marker::PhantomData;\n+use std::ops::Drop;\n+\n+// a >= b >= c >= a implies a = b = c\n+struct DropMe<'a: 'b, 'b: 'c, 'c: 'a>(\n+    PhantomData<&'a ()>,\n+    PhantomData<&'b ()>,\n+    PhantomData<&'c ()>,\n+);\n+\n+// a >= b, a >= c, b >= a, c >= a implies a = b = c\n+impl<'a: 'b + 'c, 'b: 'a, 'c: 'a> Drop for DropMe<'a, 'b, 'c> {\n+    fn drop(&mut self) {}\n+}\n+\n+fn main() {}"}, {"sha": "da5088b27b414346ff43f3fe46a5558cd29b1639", "filename": "tests/ui/dropck/transitive-outlives.bad.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/bcc9aa01b59432bed050f922e04391ea469263b4/tests%2Fui%2Fdropck%2Ftransitive-outlives.bad.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bcc9aa01b59432bed050f922e04391ea469263b4/tests%2Fui%2Fdropck%2Ftransitive-outlives.bad.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fdropck%2Ftransitive-outlives.bad.stderr?ref=bcc9aa01b59432bed050f922e04391ea469263b4", "patch": "@@ -0,0 +1,15 @@\n+error[E0367]: `Drop` impl requires `'a: 'c` but the struct it is implemented for does not\n+  --> $DIR/transitive-outlives.rs:20:9\n+   |\n+LL |     'a: 'c,\n+   |         ^^\n+   |\n+note: the implementor must specify the same requirement\n+  --> $DIR/transitive-outlives.rs:7:1\n+   |\n+LL | struct DropMe<'a, 'b: 'a, 'c: 'b>(PhantomData<&'a ()>, PhantomData<&'b ()>, PhantomData<&'c ()>);\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0367`."}, {"sha": "d071664abdeb6b07d15750585ed7aa7283494d0f", "filename": "tests/ui/dropck/transitive-outlives.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/bcc9aa01b59432bed050f922e04391ea469263b4/tests%2Fui%2Fdropck%2Ftransitive-outlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcc9aa01b59432bed050f922e04391ea469263b4/tests%2Fui%2Fdropck%2Ftransitive-outlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fdropck%2Ftransitive-outlives.rs?ref=bcc9aa01b59432bed050f922e04391ea469263b4", "patch": "@@ -0,0 +1,26 @@\n+// revisions: good bad\n+//[good] check-pass\n+\n+use std::marker::PhantomData;\n+use std::ops::Drop;\n+\n+struct DropMe<'a, 'b: 'a, 'c: 'b>(PhantomData<&'a ()>, PhantomData<&'b ()>, PhantomData<&'c ()>);\n+\n+#[cfg(good)]\n+impl<'a, 'b, 'c> Drop for DropMe<'a, 'b, 'c>\n+where\n+    'c: 'a,\n+{\n+    fn drop(&mut self) {}\n+}\n+\n+#[cfg(bad)]\n+impl<'a, 'b, 'c> Drop for DropMe<'a, 'b, 'c>\n+where\n+    'a: 'c,\n+    //[bad]~^ ERROR `Drop` impl requires `'a: 'c`\n+{\n+    fn drop(&mut self) {}\n+}\n+\n+fn main() {}"}, {"sha": "a8f5d2c354bc979799634c2eb6e078fbe5acb944", "filename": "tests/ui/dropck/trivial-impl-bounds.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/bcc9aa01b59432bed050f922e04391ea469263b4/tests%2Fui%2Fdropck%2Ftrivial-impl-bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcc9aa01b59432bed050f922e04391ea469263b4/tests%2Fui%2Fdropck%2Ftrivial-impl-bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fdropck%2Ftrivial-impl-bounds.rs?ref=bcc9aa01b59432bed050f922e04391ea469263b4", "patch": "@@ -0,0 +1,34 @@\n+// revisions: good1 good2 good3\n+// check-pass\n+\n+use std::ops::Drop;\n+\n+struct Foo;\n+\n+const X: usize = 1;\n+\n+#[cfg(good1)]\n+impl Drop for Foo\n+where\n+    [(); X]:, // Trivial WF bound\n+{\n+    fn drop(&mut self) {}\n+}\n+\n+#[cfg(good2)]\n+impl Drop for Foo\n+where\n+    for<'a> &'a (): Copy, // Trivial trait bound\n+{\n+    fn drop(&mut self) {}\n+}\n+\n+#[cfg(good3)]\n+impl Drop for Foo\n+where\n+    for<'a> &'a (): 'a, // Trivial outlives bound\n+{\n+    fn drop(&mut self) {}\n+}\n+\n+fn main() {}"}, {"sha": "a985b1a6e12f695d26b31d82407229f5495d5474", "filename": "tests/ui/traits/non_lifetime_binders/drop-impl-pred.no.stderr", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/bcc9aa01b59432bed050f922e04391ea469263b4/tests%2Fui%2Ftraits%2Fnon_lifetime_binders%2Fdrop-impl-pred.no.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bcc9aa01b59432bed050f922e04391ea469263b4/tests%2Fui%2Ftraits%2Fnon_lifetime_binders%2Fdrop-impl-pred.no.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fnon_lifetime_binders%2Fdrop-impl-pred.no.stderr?ref=bcc9aa01b59432bed050f922e04391ea469263b4", "patch": "@@ -0,0 +1,24 @@\n+warning: the feature `non_lifetime_binders` is incomplete and may not be safe to use and/or cause compiler crashes\n+  --> $DIR/drop-impl-pred.rs:6:12\n+   |\n+LL | #![feature(non_lifetime_binders)]\n+   |            ^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: see issue #108185 <https://github.com/rust-lang/rust/issues/108185> for more information\n+   = note: `#[warn(incomplete_features)]` on by default\n+\n+error[E0367]: `Drop` impl requires `H: Foo` but the struct it is implemented for does not\n+  --> $DIR/drop-impl-pred.rs:19:15\n+   |\n+LL |     for<H> H: Foo,\n+   |               ^^^\n+   |\n+note: the implementor must specify the same requirement\n+  --> $DIR/drop-impl-pred.rs:12:1\n+   |\n+LL | struct Bar<T>(T) where T: Foo;\n+   | ^^^^^^^^^^^^^\n+\n+error: aborting due to previous error; 1 warning emitted\n+\n+For more information about this error, try `rustc --explain E0367`."}, {"sha": "c65b5ea9ba4931106a19e1ce74d3780ab5d90aff", "filename": "tests/ui/traits/non_lifetime_binders/drop-impl-pred.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/bcc9aa01b59432bed050f922e04391ea469263b4/tests%2Fui%2Ftraits%2Fnon_lifetime_binders%2Fdrop-impl-pred.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcc9aa01b59432bed050f922e04391ea469263b4/tests%2Fui%2Ftraits%2Fnon_lifetime_binders%2Fdrop-impl-pred.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fnon_lifetime_binders%2Fdrop-impl-pred.rs?ref=bcc9aa01b59432bed050f922e04391ea469263b4", "patch": "@@ -0,0 +1,25 @@\n+// revisions: no yes\n+//[yes] check-pass\n+\n+// Issue 110557\n+\n+#![feature(non_lifetime_binders)]\n+//~^ WARN the feature `non_lifetime_binders` is incomplete\n+\n+pub trait Foo {}\n+\n+#[cfg(no)]\n+struct Bar<T>(T) where T: Foo;\n+\n+#[cfg(yes)]\n+struct Bar<T>(T) where for<H> H: Foo;\n+\n+impl<T> Drop for Bar<T>\n+where\n+    for<H> H: Foo,\n+//[no]~^ ERROR `Drop` impl requires `H: Foo` but the struct it is implemented for does not\n+{\n+    fn drop(&mut self) {}\n+}\n+\n+fn main() {}"}, {"sha": "165cf2ee13da8773f1c4eb539c465afc3a956895", "filename": "tests/ui/traits/non_lifetime_binders/drop-impl-pred.yes.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/bcc9aa01b59432bed050f922e04391ea469263b4/tests%2Fui%2Ftraits%2Fnon_lifetime_binders%2Fdrop-impl-pred.yes.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bcc9aa01b59432bed050f922e04391ea469263b4/tests%2Fui%2Ftraits%2Fnon_lifetime_binders%2Fdrop-impl-pred.yes.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fnon_lifetime_binders%2Fdrop-impl-pred.yes.stderr?ref=bcc9aa01b59432bed050f922e04391ea469263b4", "patch": "@@ -0,0 +1,11 @@\n+warning: the feature `non_lifetime_binders` is incomplete and may not be safe to use and/or cause compiler crashes\n+  --> $DIR/drop-impl-pred.rs:6:12\n+   |\n+LL | #![feature(non_lifetime_binders)]\n+   |            ^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: see issue #108185 <https://github.com/rust-lang/rust/issues/108185> for more information\n+   = note: `#[warn(incomplete_features)]` on by default\n+\n+warning: 1 warning emitted\n+"}]}