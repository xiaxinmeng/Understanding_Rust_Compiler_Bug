{"sha": "f3657170b1cbe80393d9ccde8608872f7bdc68f2", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYzNjU3MTcwYjFjYmU4MDM5M2Q5Y2NkZTg2MDg4NzJmN2JkYzY4ZjI=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-02-18T22:32:10Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-02-18T22:32:10Z"}, "message": "rollup merge of #22482: alexcrichton/cstr-changes\n\nThis commit is an implementation of [RFC 592][r592] and [RFC 840][r840]. These\ntwo RFCs tweak the behavior of `CString` and add a new `CStr` unsized slice type\nto the module.\n\n[r592]: https://github.com/rust-lang/rfcs/blob/master/text/0592-c-str-deref.md\n[r840]: https://github.com/rust-lang/rfcs/blob/master/text/0840-no-panic-in-c-string.md\n\nThe new `CStr` type is only constructable via two methods:\n\n1. By `deref`'ing from a `CString`\n2. Unsafely via `CStr::from_ptr`\n\nThe purpose of `CStr` is to be an unsized type which is a thin pointer to a\n`libc::c_char` (currently it is a fat pointer slice due to implementation\nlimitations). Strings from C can be safely represented with a `CStr` and an\nappropriate lifetime as well. Consumers of `&CString` should now consume `&CStr`\ninstead to allow producers to pass in C-originating strings instead of just\nRust-allocated strings.\n\nA new constructor was added to `CString`, `new`, which takes `T: IntoBytes`\ninstead of separate `from_slice` and `from_vec` methods (both have been\ndeprecated in favor of `new`). The `new` method returns a `Result` instead of\npanicking.  The error variant contains the relevant information about where the\nerror happened and bytes (if present). Conversions are provided to the\n`io::Error` and `old_io::IoError` types via the `FromError` trait which\ntranslate to `InvalidInput`.\n\nThis is a breaking change due to the modification of existing `#[unstable]` APIs\nand new deprecation, and more detailed information can be found in the two RFCs.\nNotable breakage includes:\n\n* All construction of `CString` now needs to use `new` and handle the outgoing\n  `Result`.\n* Usage of `CString` as a byte slice now explicitly needs a `.as_bytes()` call.\n* The `as_slice*` methods have been removed in favor of just having the\n  `as_bytes*` methods.\n\nCloses #22469\nCloses #22470\n[breaking-change]", "tree": {"sha": "ccceed47ede32141bc1ec796fff489f6dfe37ae9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ccceed47ede32141bc1ec796fff489f6dfe37ae9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f3657170b1cbe80393d9ccde8608872f7bdc68f2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f3657170b1cbe80393d9ccde8608872f7bdc68f2", "html_url": "https://github.com/rust-lang/rust/commit/f3657170b1cbe80393d9ccde8608872f7bdc68f2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f3657170b1cbe80393d9ccde8608872f7bdc68f2/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9774b7e64b7ff8323b4f8160cc38eb793f447217", "url": "https://api.github.com/repos/rust-lang/rust/commits/9774b7e64b7ff8323b4f8160cc38eb793f447217", "html_url": "https://github.com/rust-lang/rust/commit/9774b7e64b7ff8323b4f8160cc38eb793f447217"}, {"sha": "1860ee521aa6096eb7f5410a64b53311fb0d2d0e", "url": "https://api.github.com/repos/rust-lang/rust/commits/1860ee521aa6096eb7f5410a64b53311fb0d2d0e", "html_url": "https://github.com/rust-lang/rust/commit/1860ee521aa6096eb7f5410a64b53311fb0d2d0e"}], "stats": {"total": 845, "additions": 555, "deletions": 290}, "files": [{"sha": "60750160f5fe3f83932a92f0d6feef8c871f61c5", "filename": "src/doc/trpl/ffi.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f3657170b1cbe80393d9ccde8608872f7bdc68f2/src%2Fdoc%2Ftrpl%2Fffi.md", "raw_url": "https://github.com/rust-lang/rust/raw/f3657170b1cbe80393d9ccde8608872f7bdc68f2/src%2Fdoc%2Ftrpl%2Fffi.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fffi.md?ref=f3657170b1cbe80393d9ccde8608872f7bdc68f2", "patch": "@@ -435,8 +435,8 @@ extern {\n }\n \n fn main() {\n-    let prompt = CString::from_slice(b\"[my-awesome-shell] $\");\n-    unsafe { \n+    let prompt = CString::new(\"[my-awesome-shell] $\").unwrap();\n+    unsafe {\n         rl_prompt = prompt.as_ptr();\n \n         println!(\"{:?}\", rl_prompt);"}, {"sha": "89f19b6c47c518ce8851bad6c2d729bfbf8b8233", "filename": "src/librustc/metadata/loader.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f3657170b1cbe80393d9ccde8608872f7bdc68f2/src%2Flibrustc%2Fmetadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3657170b1cbe80393d9ccde8608872f7bdc68f2/src%2Flibrustc%2Fmetadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Floader.rs?ref=f3657170b1cbe80393d9ccde8608872f7bdc68f2", "patch": "@@ -744,7 +744,7 @@ fn get_metadata_section_imp(is_osx: bool, filename: &Path) -> Result<MetadataBlo\n         }\n     }\n     unsafe {\n-        let buf = CString::from_slice(filename.as_vec());\n+        let buf = CString::new(filename.as_vec()).unwrap();\n         let mb = llvm::LLVMRustCreateMemoryBufferWithContentsOfFile(buf.as_ptr());\n         if mb as int == 0 {\n             return Err(format!(\"error reading library: '{}'\","}, {"sha": "14a99026aac8ac18c8e06b377e68981ca534f52b", "filename": "src/librustc_llvm/archive_ro.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f3657170b1cbe80393d9ccde8608872f7bdc68f2/src%2Flibrustc_llvm%2Farchive_ro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3657170b1cbe80393d9ccde8608872f7bdc68f2/src%2Flibrustc_llvm%2Farchive_ro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Farchive_ro.rs?ref=f3657170b1cbe80393d9ccde8608872f7bdc68f2", "patch": "@@ -30,7 +30,7 @@ impl ArchiveRO {\n     /// raised.\n     pub fn open(dst: &Path) -> Option<ArchiveRO> {\n         unsafe {\n-            let s = CString::from_slice(dst.as_vec());\n+            let s = CString::new(dst.as_vec()).unwrap();\n             let ar = ::LLVMRustOpenArchive(s.as_ptr());\n             if ar.is_null() {\n                 None\n@@ -44,7 +44,7 @@ impl ArchiveRO {\n     pub fn read<'a>(&'a self, file: &str) -> Option<&'a [u8]> {\n         unsafe {\n             let mut size = 0 as libc::size_t;\n-            let file = CString::from_slice(file.as_bytes());\n+            let file = CString::new(file).unwrap();\n             let ptr = ::LLVMRustArchiveReadSection(self.ptr, file.as_ptr(),\n                                                    &mut size);\n             if ptr.is_null() {"}, {"sha": "09a187befb2130ec01ccb05fb84f16265d300e86", "filename": "src/librustc_llvm/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f3657170b1cbe80393d9ccde8608872f7bdc68f2/src%2Flibrustc_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3657170b1cbe80393d9ccde8608872f7bdc68f2/src%2Flibrustc_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Flib.rs?ref=f3657170b1cbe80393d9ccde8608872f7bdc68f2", "patch": "@@ -2148,7 +2148,7 @@ impl Drop for TargetData {\n }\n \n pub fn mk_target_data(string_rep: &str) -> TargetData {\n-    let string_rep = CString::from_slice(string_rep.as_bytes());\n+    let string_rep = CString::new(string_rep).unwrap();\n     TargetData {\n         lltd: unsafe { LLVMCreateTargetData(string_rep.as_ptr()) }\n     }"}, {"sha": "9d604695cf75f6d76a32f5146066c35c11bdaad8", "filename": "src/librustc_trans/back/lto.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f3657170b1cbe80393d9ccde8608872f7bdc68f2/src%2Flibrustc_trans%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3657170b1cbe80393d9ccde8608872f7bdc68f2/src%2Flibrustc_trans%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flto.rs?ref=f3657170b1cbe80393d9ccde8608872f7bdc68f2", "patch": "@@ -140,7 +140,7 @@ pub fn run(sess: &session::Session, llmod: ModuleRef,\n \n     // Internalize everything but the reachable symbols of the current module\n     let cstrs: Vec<CString> = reachable.iter().map(|s| {\n-        CString::from_slice(s.as_bytes())\n+        CString::new(s.clone()).unwrap()\n     }).collect();\n     let arr: Vec<*const libc::c_char> = cstrs.iter().map(|c| c.as_ptr()).collect();\n     let ptr = arr.as_ptr();"}, {"sha": "20cd1624a8c9715c9991a8c7314d34921cd861e1", "filename": "src/librustc_trans/back/write.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/f3657170b1cbe80393d9ccde8608872f7bdc68f2/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3657170b1cbe80393d9ccde8608872f7bdc68f2/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fwrite.rs?ref=f3657170b1cbe80393d9ccde8608872f7bdc68f2", "patch": "@@ -22,7 +22,7 @@ use syntax::codemap;\n use syntax::diagnostic;\n use syntax::diagnostic::{Emitter, Handler, Level, mk_handler};\n \n-use std::ffi::{self, CString};\n+use std::ffi::{CStr, CString};\n use std::old_io::Command;\n use std::old_io::fs;\n use std::iter::Unfold;\n@@ -49,7 +49,7 @@ pub fn llvm_err(handler: &diagnostic::Handler, msg: String) -> ! {\n         if cstr == ptr::null() {\n             handler.fatal(&msg[]);\n         } else {\n-            let err = ffi::c_str_to_bytes(&cstr);\n+            let err = CStr::from_ptr(cstr).to_bytes();\n             let err = String::from_utf8_lossy(err).to_string();\n             libc::free(cstr as *mut _);\n             handler.fatal(&format!(\"{}: {}\",\n@@ -67,7 +67,7 @@ pub fn write_output_file(\n         output: &Path,\n         file_type: llvm::FileType) {\n     unsafe {\n-        let output_c = CString::from_slice(output.as_vec());\n+        let output_c = CString::new(output.as_vec()).unwrap();\n         let result = llvm::LLVMRustWriteOutputFile(\n                 target, pm, m, output_c.as_ptr(), file_type);\n         if !result {\n@@ -221,13 +221,13 @@ fn create_target_machine(sess: &Session) -> TargetMachineRef {\n     let triple = &sess.target.target.llvm_target[];\n \n     let tm = unsafe {\n-        let triple = CString::from_slice(triple.as_bytes());\n+        let triple = CString::new(triple.as_bytes()).unwrap();\n         let cpu = match sess.opts.cg.target_cpu {\n             Some(ref s) => &**s,\n             None => &*sess.target.target.options.cpu\n         };\n-        let cpu = CString::from_slice(cpu.as_bytes());\n-        let features = CString::from_slice(target_feature(sess).as_bytes());\n+        let cpu = CString::new(cpu.as_bytes()).unwrap();\n+        let features = CString::new(target_feature(sess).as_bytes()).unwrap();\n         llvm::LLVMRustCreateTargetMachine(\n             triple.as_ptr(), cpu.as_ptr(), features.as_ptr(),\n             code_model,\n@@ -380,7 +380,7 @@ unsafe extern \"C\" fn diagnostic_handler(info: DiagnosticInfoRef, user: *mut c_vo\n         }\n \n         llvm::diagnostic::Optimization(opt) => {\n-            let pass_name = str::from_utf8(ffi::c_str_to_bytes(&opt.pass_name))\n+            let pass_name = str::from_utf8(CStr::from_ptr(opt.pass_name).to_bytes())\n                                 .ok()\n                                 .expect(\"got a non-UTF8 pass name from LLVM\");\n             let enabled = match cgcx.remark {\n@@ -424,7 +424,7 @@ unsafe fn optimize_and_codegen(cgcx: &CodegenContext,\n     if config.emit_no_opt_bc {\n         let ext = format!(\"{}.no-opt.bc\", name_extra);\n         let out = output_names.with_extension(&ext);\n-        let out = CString::from_slice(out.as_vec());\n+        let out = CString::new(out.as_vec()).unwrap();\n         llvm::LLVMWriteBitcodeToFile(llmod, out.as_ptr());\n     }\n \n@@ -440,7 +440,7 @@ unsafe fn optimize_and_codegen(cgcx: &CodegenContext,\n             // If we're verifying or linting, add them to the function pass\n             // manager.\n             let addpass = |pass: &str| {\n-                let pass = CString::from_slice(pass.as_bytes());\n+                let pass = CString::new(pass).unwrap();\n                 llvm::LLVMRustAddPass(fpm, pass.as_ptr())\n             };\n             if !config.no_verify { assert!(addpass(\"verify\")); }\n@@ -453,7 +453,7 @@ unsafe fn optimize_and_codegen(cgcx: &CodegenContext,\n             }\n \n             for pass in &config.passes {\n-                let pass = CString::from_slice(pass.as_bytes());\n+                let pass = CString::new(pass.clone()).unwrap();\n                 if !llvm::LLVMRustAddPass(mpm, pass.as_ptr()) {\n                     cgcx.handler.warn(&format!(\"unknown pass {:?}, ignoring\", pass));\n                 }\n@@ -477,7 +477,7 @@ unsafe fn optimize_and_codegen(cgcx: &CodegenContext,\n                     if config.emit_lto_bc {\n                         let name = format!(\"{}.lto.bc\", name_extra);\n                         let out = output_names.with_extension(&name);\n-                        let out = CString::from_slice(out.as_vec());\n+                        let out = CString::new(out.as_vec()).unwrap();\n                         llvm::LLVMWriteBitcodeToFile(llmod, out.as_ptr());\n                     }\n                 },\n@@ -511,15 +511,15 @@ unsafe fn optimize_and_codegen(cgcx: &CodegenContext,\n     if config.emit_bc {\n         let ext = format!(\"{}.bc\", name_extra);\n         let out = output_names.with_extension(&ext);\n-        let out = CString::from_slice(out.as_vec());\n+        let out = CString::new(out.as_vec()).unwrap();\n         llvm::LLVMWriteBitcodeToFile(llmod, out.as_ptr());\n     }\n \n     time(config.time_passes, \"codegen passes\", (), |()| {\n         if config.emit_ir {\n             let ext = format!(\"{}.ll\", name_extra);\n             let out = output_names.with_extension(&ext);\n-            let out = CString::from_slice(out.as_vec());\n+            let out = CString::new(out.as_vec()).unwrap();\n             with_codegen(tm, llmod, config.no_builtins, |cpm| {\n                 llvm::LLVMRustPrintModule(cpm, llmod, out.as_ptr());\n             })\n@@ -1004,7 +1004,7 @@ unsafe fn configure_llvm(sess: &Session) {\n     let mut llvm_args = Vec::new();\n     {\n         let mut add = |arg: &str| {\n-            let s = CString::from_slice(arg.as_bytes());\n+            let s = CString::new(arg).unwrap();\n             llvm_args.push(s.as_ptr());\n             llvm_c_strs.push(s);\n         };"}, {"sha": "53c21d04a9297cb33bff730ef84a530d59d59eb4", "filename": "src/librustc_trans/trans/asm.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f3657170b1cbe80393d9ccde8608872f7bdc68f2/src%2Flibrustc_trans%2Ftrans%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3657170b1cbe80393d9ccde8608872f7bdc68f2/src%2Flibrustc_trans%2Ftrans%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fasm.rs?ref=f3657170b1cbe80393d9ccde8608872f7bdc68f2", "patch": "@@ -120,8 +120,8 @@ pub fn trans_inline_asm<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, ia: &ast::InlineAsm)\n         ast::AsmIntel => llvm::AD_Intel\n     };\n \n-    let asm = CString::from_slice(ia.asm.as_bytes());\n-    let constraints = CString::from_slice(constraints.as_bytes());\n+    let asm = CString::new(ia.asm.as_bytes()).unwrap();\n+    let constraints = CString::new(constraints).unwrap();\n     let r = InlineAsmCall(bcx,\n                           asm.as_ptr(),\n                           constraints.as_ptr(),"}, {"sha": "f26d9d742619382a72d66e50ce373e3a552df162", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/f3657170b1cbe80393d9ccde8608872f7bdc68f2/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3657170b1cbe80393d9ccde8608872f7bdc68f2/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=f3657170b1cbe80393d9ccde8608872f7bdc68f2", "patch": "@@ -86,7 +86,7 @@ use util::nodemap::NodeMap;\n \n use arena::TypedArena;\n use libc::{c_uint, uint64_t};\n-use std::ffi::{self, CString};\n+use std::ffi::{CStr, CString};\n use std::cell::{Cell, RefCell};\n use std::collections::HashSet;\n use std::mem;\n@@ -186,7 +186,7 @@ impl<'a, 'tcx> Drop for StatRecorder<'a, 'tcx> {\n pub fn decl_fn(ccx: &CrateContext, name: &str, cc: llvm::CallConv,\n                ty: Type, output: ty::FnOutput) -> ValueRef {\n \n-    let buf = CString::from_slice(name.as_bytes());\n+    let buf = CString::new(name).unwrap();\n     let llfn: ValueRef = unsafe {\n         llvm::LLVMGetOrInsertFunction(ccx.llmod(), buf.as_ptr(), ty.to_ref())\n     };\n@@ -340,7 +340,7 @@ pub fn get_extern_const<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, did: ast::DefId,\n         None => ()\n     }\n     unsafe {\n-        let buf = CString::from_slice(name.as_bytes());\n+        let buf = CString::new(name.clone()).unwrap();\n         let c = llvm::LLVMAddGlobal(ccx.llmod(), ty.to_ref(), buf.as_ptr());\n         // Thread-local statics in some other crate need to *always* be linked\n         // against in a thread-local fashion, so we need to be sure to apply the\n@@ -2775,7 +2775,7 @@ pub fn get_item_val(ccx: &CrateContext, id: ast::NodeId) -> ValueRef {\n                                 &format!(\"Illegal null byte in export_name \\\n                                          value: `{}`\", sym)[]);\n                         }\n-                        let buf = CString::from_slice(sym.as_bytes());\n+                        let buf = CString::new(sym.clone()).unwrap();\n                         let g = llvm::LLVMAddGlobal(ccx.llmod(), llty,\n                                                     buf.as_ptr());\n \n@@ -2813,7 +2813,7 @@ pub fn get_item_val(ccx: &CrateContext, id: ast::NodeId) -> ValueRef {\n                                                  &sect)[]);\n                     }\n                     unsafe {\n-                        let buf = CString::from_slice(sect.as_bytes());\n+                        let buf = CString::new(sect.as_bytes()).unwrap();\n                         llvm::LLVMSetSection(v, buf.as_ptr());\n                     }\n                 },\n@@ -2980,15 +2980,15 @@ pub fn write_metadata(cx: &SharedCrateContext, krate: &ast::Crate) -> Vec<u8> {\n     let name = format!(\"rust_metadata_{}_{}\",\n                        cx.link_meta().crate_name,\n                        cx.link_meta().crate_hash);\n-    let buf = CString::from_vec(name.into_bytes());\n+    let buf = CString::new(name).unwrap();\n     let llglobal = unsafe {\n         llvm::LLVMAddGlobal(cx.metadata_llmod(), val_ty(llconst).to_ref(),\n                             buf.as_ptr())\n     };\n     unsafe {\n         llvm::LLVMSetInitializer(llglobal, llconst);\n         let name = loader::meta_section_name(cx.sess().target.target.options.is_like_osx);\n-        let name = CString::from_slice(name.as_bytes());\n+        let name = CString::new(name).unwrap();\n         llvm::LLVMSetSection(llglobal, name.as_ptr())\n     }\n     return metadata;\n@@ -3026,8 +3026,8 @@ fn internalize_symbols(cx: &SharedCrateContext, reachable: &HashSet<String>) {\n                     continue\n                 }\n \n-                let name = ffi::c_str_to_bytes(&llvm::LLVMGetValueName(val))\n-                               .to_vec();\n+                let name = CStr::from_ptr(llvm::LLVMGetValueName(val))\n+                                .to_bytes().to_vec();\n                 declared.insert(name);\n             }\n         }\n@@ -3043,8 +3043,8 @@ fn internalize_symbols(cx: &SharedCrateContext, reachable: &HashSet<String>) {\n                     continue\n                 }\n \n-                let name = ffi::c_str_to_bytes(&llvm::LLVMGetValueName(val))\n-                               .to_vec();\n+                let name = CStr::from_ptr(llvm::LLVMGetValueName(val))\n+                                .to_bytes().to_vec();\n                 if !declared.contains(&name) &&\n                    !reachable.contains(str::from_utf8(&name).unwrap()) {\n                     llvm::SetLinkage(val, llvm::InternalLinkage);"}, {"sha": "3bd0479c0d8e83e96a07e8b50ec0a3b3a0b27c59", "filename": "src/librustc_trans/trans/builder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f3657170b1cbe80393d9ccde8608872f7bdc68f2/src%2Flibrustc_trans%2Ftrans%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3657170b1cbe80393d9ccde8608872f7bdc68f2/src%2Flibrustc_trans%2Ftrans%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbuilder.rs?ref=f3657170b1cbe80393d9ccde8608872f7bdc68f2", "patch": "@@ -431,7 +431,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             if name.is_empty() {\n                 llvm::LLVMBuildAlloca(self.llbuilder, ty.to_ref(), noname())\n             } else {\n-                let name = CString::from_slice(name.as_bytes());\n+                let name = CString::new(name).unwrap();\n                 llvm::LLVMBuildAlloca(self.llbuilder, ty.to_ref(),\n                                       name.as_ptr())\n             }\n@@ -786,7 +786,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             let comment_text = format!(\"{} {}\", \"#\",\n                                        sanitized.replace(\"\\n\", \"\\n\\t# \"));\n             self.count_insn(\"inlineasm\");\n-            let comment_text = CString::from_vec(comment_text.into_bytes());\n+            let comment_text = CString::new(comment_text).unwrap();\n             let asm = unsafe {\n                 llvm::LLVMConstInlineAsm(Type::func(&[], &Type::void(self.ccx)).to_ref(),\n                                          comment_text.as_ptr(), noname(), False,"}, {"sha": "494780068f9a79457b0364e4bc658fae413da8f3", "filename": "src/librustc_trans/trans/common.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f3657170b1cbe80393d9ccde8608872f7bdc68f2/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3657170b1cbe80393d9ccde8608872f7bdc68f2/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs?ref=f3657170b1cbe80393d9ccde8608872f7bdc68f2", "patch": "@@ -488,7 +488,7 @@ impl<'a, 'tcx> FunctionContext<'a, 'tcx> {\n                      opt_node_id: Option<ast::NodeId>)\n                      -> Block<'a, 'tcx> {\n         unsafe {\n-            let name = CString::from_slice(name.as_bytes());\n+            let name = CString::new(name).unwrap();\n             let llbb = llvm::LLVMAppendBasicBlockInContext(self.ccx.llcx(),\n                                                            self.llfn,\n                                                            name.as_ptr());\n@@ -757,7 +757,7 @@ pub fn C_integral(t: Type, u: u64, sign_extend: bool) -> ValueRef {\n \n pub fn C_floating(s: &str, t: Type) -> ValueRef {\n     unsafe {\n-        let s = CString::from_slice(s.as_bytes());\n+        let s = CString::new(s).unwrap();\n         llvm::LLVMConstRealOfString(t.to_ref(), s.as_ptr())\n     }\n }\n@@ -835,7 +835,8 @@ pub fn C_cstr(cx: &CrateContext, s: InternedString, null_terminated: bool) -> Va\n                                                 !null_terminated as Bool);\n \n         let gsym = token::gensym(\"str\");\n-        let buf = CString::from_vec(format!(\"str{}\", gsym.usize()).into_bytes());\n+        let buf = CString::new(format!(\"str{}\", gsym.usize()));\n+        let buf = buf.unwrap();\n         let g = llvm::LLVMAddGlobal(cx.llmod(), val_ty(sc).to_ref(), buf.as_ptr());\n         llvm::LLVMSetInitializer(g, sc);\n         llvm::LLVMSetGlobalConstant(g, True);"}, {"sha": "cd5aed6d84636f7786177315182852a15879a459", "filename": "src/librustc_trans/trans/context.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f3657170b1cbe80393d9ccde8608872f7bdc68f2/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3657170b1cbe80393d9ccde8608872f7bdc68f2/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs?ref=f3657170b1cbe80393d9ccde8608872f7bdc68f2", "patch": "@@ -225,15 +225,15 @@ impl<'a, 'tcx> Iterator for CrateContextMaybeIterator<'a, 'tcx> {\n \n unsafe fn create_context_and_module(sess: &Session, mod_name: &str) -> (ContextRef, ModuleRef) {\n     let llcx = llvm::LLVMContextCreate();\n-    let mod_name = CString::from_slice(mod_name.as_bytes());\n+    let mod_name = CString::new(mod_name).unwrap();\n     let llmod = llvm::LLVMModuleCreateWithNameInContext(mod_name.as_ptr(), llcx);\n \n-    let data_layout = &*sess.target.target.data_layout;\n-    let data_layout = CString::from_slice(data_layout.as_bytes());\n+    let data_layout = sess.target.target.data_layout.as_bytes();\n+    let data_layout = CString::new(data_layout).unwrap();\n     llvm::LLVMSetDataLayout(llmod, data_layout.as_ptr());\n \n-    let llvm_target = &*sess.target.target.llvm_target;\n-    let llvm_target = CString::from_slice(llvm_target.as_bytes());\n+    let llvm_target = sess.target.target.llvm_target.as_bytes();\n+    let llvm_target = CString::new(llvm_target).unwrap();\n     llvm::LLVMRustSetNormalizedTarget(llmod, llvm_target.as_ptr());\n     (llcx, llmod)\n }"}, {"sha": "653ad1b2b630b46130e45ffd2ca0bf7ba58d7a48", "filename": "src/librustc_trans/trans/debuginfo.rs", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/f3657170b1cbe80393d9ccde8608872f7bdc68f2/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3657170b1cbe80393d9ccde8608872f7bdc68f2/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs?ref=f3657170b1cbe80393d9ccde8608872f7bdc68f2", "patch": "@@ -809,8 +809,8 @@ pub fn create_global_var_metadata(cx: &CrateContext,\n         namespace_node.mangled_name_of_contained_item(&var_name[]);\n     let var_scope = namespace_node.scope;\n \n-    let var_name = CString::from_slice(var_name.as_bytes());\n-    let linkage_name = CString::from_slice(linkage_name.as_bytes());\n+    let var_name = CString::new(var_name).unwrap();\n+    let linkage_name = CString::new(linkage_name).unwrap();\n     unsafe {\n         llvm::LLVMDIBuilderCreateStaticVariable(DIB(cx),\n                                                 var_scope,\n@@ -1379,8 +1379,8 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n \n     let is_local_to_unit = is_node_local_to_unit(cx, fn_ast_id);\n \n-    let function_name = CString::from_slice(function_name.as_bytes());\n-    let linkage_name = CString::from_slice(linkage_name.as_bytes());\n+    let function_name = CString::new(function_name).unwrap();\n+    let linkage_name = CString::new(linkage_name).unwrap();\n     let fn_metadata = unsafe {\n         llvm::LLVMDIBuilderCreateFunction(\n             DIB(cx),\n@@ -1501,7 +1501,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                 let ident = special_idents::type_self;\n \n                 let ident = token::get_ident(ident);\n-                let name = CString::from_slice(ident.as_bytes());\n+                let name = CString::new(ident.as_bytes()).unwrap();\n                 let param_metadata = unsafe {\n                     llvm::LLVMDIBuilderCreateTemplateTypeParameter(\n                         DIB(cx),\n@@ -1535,7 +1535,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             if cx.sess().opts.debuginfo == FullDebugInfo {\n                 let actual_type_metadata = type_metadata(cx, actual_type, codemap::DUMMY_SP);\n                 let ident = token::get_ident(ident);\n-                let name = CString::from_slice(ident.as_bytes());\n+                let name = CString::new(ident.as_bytes()).unwrap();\n                 let param_metadata = unsafe {\n                     llvm::LLVMDIBuilderCreateTemplateTypeParameter(\n                         DIB(cx),\n@@ -1601,7 +1601,7 @@ fn compile_unit_metadata(cx: &CrateContext) -> DIDescriptor {\n                             path_bytes.insert(1, prefix[1]);\n                         }\n \n-                        CString::from_vec(path_bytes)\n+                        CString::new(path_bytes).unwrap()\n                     }\n                     _ => fallback_path(cx)\n                 }\n@@ -1614,8 +1614,8 @@ fn compile_unit_metadata(cx: &CrateContext) -> DIDescriptor {\n                            (option_env!(\"CFG_VERSION\")).expect(\"CFG_VERSION\"));\n \n     let compile_unit_name = compile_unit_name.as_ptr();\n-    let work_dir = CString::from_slice(work_dir.as_vec());\n-    let producer = CString::from_slice(producer.as_bytes());\n+    let work_dir = CString::new(work_dir.as_vec()).unwrap();\n+    let producer = CString::new(producer).unwrap();\n     let flags = \"\\0\";\n     let split_name = \"\\0\";\n     return unsafe {\n@@ -1632,7 +1632,7 @@ fn compile_unit_metadata(cx: &CrateContext) -> DIDescriptor {\n     };\n \n     fn fallback_path(cx: &CrateContext) -> CString {\n-        CString::from_slice(cx.link_meta().crate_name.as_bytes())\n+        CString::new(cx.link_meta().crate_name.clone()).unwrap()\n     }\n }\n \n@@ -1658,7 +1658,7 @@ fn declare_local<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         CapturedVariable => (0, DW_TAG_auto_variable)\n     };\n \n-    let name = CString::from_slice(name.as_bytes());\n+    let name = CString::new(name.as_bytes()).unwrap();\n     match (variable_access, [].as_slice()) {\n         (DirectVariable { alloca }, address_operations) |\n         (IndirectVariable {alloca, address_operations}, _) => {\n@@ -1724,8 +1724,8 @@ fn file_metadata(cx: &CrateContext, full_path: &str) -> DIFile {\n             full_path\n         };\n \n-    let file_name = CString::from_slice(file_name.as_bytes());\n-    let work_dir = CString::from_slice(work_dir.as_bytes());\n+    let file_name = CString::new(file_name).unwrap();\n+    let work_dir = CString::new(work_dir).unwrap();\n     let file_metadata = unsafe {\n         llvm::LLVMDIBuilderCreateFile(DIB(cx), file_name.as_ptr(),\n                                       work_dir.as_ptr())\n@@ -1800,7 +1800,7 @@ fn basic_type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n \n     let llvm_type = type_of::type_of(cx, t);\n     let (size, align) = size_and_align_of(cx, llvm_type);\n-    let name = CString::from_slice(name.as_bytes());\n+    let name = CString::new(name).unwrap();\n     let ty_metadata = unsafe {\n         llvm::LLVMDIBuilderCreateBasicType(\n             DIB(cx),\n@@ -1820,7 +1820,7 @@ fn pointer_type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     let pointer_llvm_type = type_of::type_of(cx, pointer_type);\n     let (pointer_size, pointer_align) = size_and_align_of(cx, pointer_llvm_type);\n     let name = compute_debuginfo_type_name(cx, pointer_type, false);\n-    let name = CString::from_slice(name.as_bytes());\n+    let name = CString::new(name).unwrap();\n     let ptr_metadata = unsafe {\n         llvm::LLVMDIBuilderCreatePointerType(\n             DIB(cx),\n@@ -2445,7 +2445,7 @@ fn prepare_enum_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         .iter()\n         .map(|v| {\n             let token = token::get_name(v.name);\n-            let name = CString::from_slice(token.as_bytes());\n+            let name = CString::new(token.as_bytes()).unwrap();\n             unsafe {\n                 llvm::LLVMDIBuilderCreateEnumerator(\n                     DIB(cx),\n@@ -2475,7 +2475,7 @@ fn prepare_enum_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                   codemap::DUMMY_SP);\n                 let discriminant_name = get_enum_discriminant_name(cx, enum_def_id);\n \n-                let name = CString::from_slice(discriminant_name.as_bytes());\n+                let name = CString::new(discriminant_name.as_bytes()).unwrap();\n                 let discriminant_type_metadata = unsafe {\n                     llvm::LLVMDIBuilderCreateEnumerationType(\n                         DIB(cx),\n@@ -2518,8 +2518,8 @@ fn prepare_enum_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                              .borrow()\n                              .get_unique_type_id_as_string(unique_type_id);\n \n-    let enum_name = CString::from_slice(enum_name.as_bytes());\n-    let unique_type_id_str = CString::from_slice(unique_type_id_str.as_bytes());\n+    let enum_name = CString::new(enum_name).unwrap();\n+    let unique_type_id_str = CString::new(unique_type_id_str.as_bytes()).unwrap();\n     let enum_metadata = unsafe {\n         llvm::LLVMDIBuilderCreateUnionType(\n         DIB(cx),\n@@ -2644,7 +2644,8 @@ fn set_members_of_composite_type(cx: &CrateContext,\n                 ComputedMemberOffset => machine::llelement_offset(cx, composite_llvm_type, i)\n             };\n \n-            let member_name = CString::from_slice(member_description.name.as_bytes());\n+            let member_name = member_description.name.as_bytes();\n+            let member_name = CString::new(member_name).unwrap();\n             unsafe {\n                 llvm::LLVMDIBuilderCreateMemberType(\n                     DIB(cx),\n@@ -2681,8 +2682,8 @@ fn create_struct_stub(cx: &CrateContext,\n     let unique_type_id_str = debug_context(cx).type_map\n                                               .borrow()\n                                               .get_unique_type_id_as_string(unique_type_id);\n-    let name = CString::from_slice(struct_type_name.as_bytes());\n-    let unique_type_id = CString::from_slice(unique_type_id_str.as_bytes());\n+    let name = CString::new(struct_type_name).unwrap();\n+    let unique_type_id = CString::new(unique_type_id_str.as_bytes()).unwrap();\n     let metadata_stub = unsafe {\n         // LLVMDIBuilderCreateStructType() wants an empty array. A null\n         // pointer will lead to hard to trace and debug LLVM assertions\n@@ -3971,8 +3972,7 @@ fn namespace_for_item(cx: &CrateContext, def_id: ast::DefId) -> Rc<NamespaceTree\n                         None => ptr::null_mut()\n                     };\n                     let namespace_name = token::get_name(name);\n-                    let namespace_name = CString::from_slice(namespace_name\n-                                                                .as_bytes());\n+                    let namespace_name = CString::new(namespace_name.as_bytes()).unwrap();\n                     let scope = unsafe {\n                         llvm::LLVMDIBuilderCreateNameSpace(\n                             DIB(cx),\n@@ -4020,7 +4020,7 @@ fn namespace_for_item(cx: &CrateContext, def_id: ast::DefId) -> Rc<NamespaceTree\n /// .debug_gdb_scripts global is referenced, so it isn't removed by the linker.\n pub fn insert_reference_to_gdb_debug_scripts_section_global(ccx: &CrateContext) {\n     if needs_gdb_debug_scripts_section(ccx) {\n-        let empty = CString::from_slice(b\"\");\n+        let empty = CString::new(b\"\").unwrap();\n         let gdb_debug_scripts_section_global =\n             get_or_insert_gdb_debug_scripts_section_global(ccx);\n         unsafe {"}, {"sha": "f97f660a9e8a3f976227ea519f35cc3d703ff476", "filename": "src/librustc_trans/trans/foreign.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f3657170b1cbe80393d9ccde8608872f7bdc68f2/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3657170b1cbe80393d9ccde8608872f7bdc68f2/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs?ref=f3657170b1cbe80393d9ccde8608872f7bdc68f2", "patch": "@@ -135,7 +135,7 @@ pub fn register_static(ccx: &CrateContext,\n             };\n             unsafe {\n                 // Declare a symbol `foo` with the desired linkage.\n-                let buf = CString::from_slice(ident.as_bytes());\n+                let buf = CString::new(ident.as_bytes()).unwrap();\n                 let g1 = llvm::LLVMAddGlobal(ccx.llmod(), llty2.to_ref(),\n                                              buf.as_ptr());\n                 llvm::SetLinkage(g1, linkage);\n@@ -148,7 +148,7 @@ pub fn register_static(ccx: &CrateContext,\n                 // zero.\n                 let mut real_name = \"_rust_extern_with_linkage_\".to_string();\n                 real_name.push_str(&ident);\n-                let real_name = CString::from_vec(real_name.into_bytes());\n+                let real_name = CString::new(real_name).unwrap();\n                 let g2 = llvm::LLVMAddGlobal(ccx.llmod(), llty.to_ref(),\n                                              real_name.as_ptr());\n                 llvm::SetLinkage(g2, llvm::InternalLinkage);\n@@ -158,7 +158,7 @@ pub fn register_static(ccx: &CrateContext,\n         }\n         None => unsafe {\n             // Generate an external declaration.\n-            let buf = CString::from_slice(ident.as_bytes());\n+            let buf = CString::new(ident.as_bytes()).unwrap();\n             llvm::LLVMAddGlobal(ccx.llmod(), llty.to_ref(), buf.as_ptr())\n         }\n     }"}, {"sha": "9e6867d48291a0e93a317160da0464486a1992c6", "filename": "src/librustc_trans/trans/glue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f3657170b1cbe80393d9ccde8608872f7bdc68f2/src%2Flibrustc_trans%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3657170b1cbe80393d9ccde8608872f7bdc68f2/src%2Flibrustc_trans%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fglue.rs?ref=f3657170b1cbe80393d9ccde8608872f7bdc68f2", "patch": "@@ -513,7 +513,7 @@ pub fn declare_tydesc<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>)\n     let llalign = llalign_of(ccx, llty);\n     let name = mangle_internal_name_by_type_and_seq(ccx, t, \"tydesc\");\n     debug!(\"+++ declare_tydesc {} {}\", ppaux::ty_to_string(ccx.tcx(), t), name);\n-    let buf = CString::from_slice(name.as_bytes());\n+    let buf = CString::new(name.clone()).unwrap();\n     let gvar = unsafe {\n         llvm::LLVMAddGlobal(ccx.llmod(), ccx.tydesc_type().to_ref(),\n                             buf.as_ptr())"}, {"sha": "ad83135a0d46fa3681df8b6f4d6bc2cb8b7d7d64", "filename": "src/librustc_trans/trans/type_.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f3657170b1cbe80393d9ccde8608872f7bdc68f2/src%2Flibrustc_trans%2Ftrans%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3657170b1cbe80393d9ccde8608872f7bdc68f2/src%2Flibrustc_trans%2Ftrans%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Ftype_.rs?ref=f3657170b1cbe80393d9ccde8608872f7bdc68f2", "patch": "@@ -163,7 +163,7 @@ impl Type {\n     }\n \n     pub fn named_struct(ccx: &CrateContext, name: &str) -> Type {\n-        let name = CString::from_slice(name.as_bytes());\n+        let name = CString::new(name).unwrap();\n         ty!(llvm::LLVMStructCreateNamed(ccx.llcx(), name.as_ptr()))\n     }\n "}, {"sha": "eba915af519c83addd2a32c6c686e2bc894fe068", "filename": "src/librustdoc/flock.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f3657170b1cbe80393d9ccde8608872f7bdc68f2/src%2Flibrustdoc%2Fflock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3657170b1cbe80393d9ccde8608872f7bdc68f2/src%2Flibrustdoc%2Fflock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fflock.rs?ref=f3657170b1cbe80393d9ccde8608872f7bdc68f2", "patch": "@@ -112,7 +112,7 @@ mod imp {\n \n     impl Lock {\n         pub fn new(p: &Path) -> Lock {\n-            let buf = CString::from_slice(p.as_vec());\n+            let buf = CString::from_slice(p.as_vec()).unwrap();\n             let fd = unsafe {\n                 libc::open(buf.as_ptr(), libc::O_RDWR | libc::O_CREAT,\n                            libc::S_IRWXU)"}, {"sha": "3ceaec5f53d824fcdfbf2cd6bc547002f9d34467", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f3657170b1cbe80393d9ccde8608872f7bdc68f2/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3657170b1cbe80393d9ccde8608872f7bdc68f2/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=f3657170b1cbe80393d9ccde8608872f7bdc68f2", "patch": "@@ -236,7 +236,7 @@ pub fn render(w: &mut fmt::Formatter, s: &str, print_toc: bool) -> fmt::Result {\n                 s.push_str(&highlight::highlight(&text,\n                                                  None,\n                                                  Some(\"rust-example-rendered\")));\n-                let output = CString::from_vec(s.into_bytes());\n+                let output = CString::from_vec(s.into_bytes()).unwrap();\n                 hoedown_buffer_puts(ob, output.as_ptr());\n             })\n         }\n@@ -293,7 +293,7 @@ pub fn render(w: &mut fmt::Formatter, s: &str, print_toc: bool) -> fmt::Result {\n                                format!(\"{} \", sec)\n                            });\n \n-        let text = CString::from_vec(text.into_bytes());\n+        let text = CString::from_vec(text.into_bytes()).unwrap();\n         unsafe { hoedown_buffer_puts(ob, text.as_ptr()) }\n     }\n "}, {"sha": "b0fb9c29403511d13e42b274030523c50efbbf67", "filename": "src/libstd/dynamic_lib.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f3657170b1cbe80393d9ccde8608872f7bdc68f2/src%2Flibstd%2Fdynamic_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3657170b1cbe80393d9ccde8608872f7bdc68f2/src%2Flibstd%2Fdynamic_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fdynamic_lib.rs?ref=f3657170b1cbe80393d9ccde8608872f7bdc68f2", "patch": "@@ -112,7 +112,7 @@ impl DynamicLibrary {\n         // This function should have a lifetime constraint of 'a on\n         // T but that feature is still unimplemented\n \n-        let raw_string = CString::from_slice(symbol.as_bytes());\n+        let raw_string = CString::new(symbol).unwrap();\n         let maybe_symbol_value = dl::check_for_errors_in(|| {\n             dl::symbol(self.handle, raw_string.as_ptr())\n         });\n@@ -187,7 +187,7 @@ mod test {\n mod dl {\n     use prelude::v1::*;\n \n-    use ffi::{self, CString};\n+    use ffi::{CString, CStr};\n     use str;\n     use libc;\n     use ptr;\n@@ -206,7 +206,7 @@ mod dl {\n     const LAZY: libc::c_int = 1;\n \n     unsafe fn open_external(filename: &[u8]) -> *mut u8 {\n-        let s = CString::from_slice(filename);\n+        let s = CString::new(filename).unwrap();\n         dlopen(s.as_ptr(), LAZY) as *mut u8\n     }\n \n@@ -231,7 +231,7 @@ mod dl {\n             let ret = if ptr::null() == last_error {\n                 Ok(result)\n             } else {\n-                let s = ffi::c_str_to_bytes(&last_error);\n+                let s = CStr::from_ptr(last_error).to_bytes();\n                 Err(str::from_utf8(s).unwrap().to_string())\n             };\n "}, {"sha": "70c14ef1978293b3cf42226218acbd2908698a39", "filename": "src/libstd/ffi/c_str.rs", "status": "modified", "additions": 326, "deletions": 76, "changes": 402, "blob_url": "https://github.com/rust-lang/rust/blob/f3657170b1cbe80393d9ccde8608872f7bdc68f2/src%2Flibstd%2Fffi%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3657170b1cbe80393d9ccde8608872f7bdc68f2/src%2Flibstd%2Fffi%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fffi%2Fc_str.rs?ref=f3657170b1cbe80393d9ccde8608872f7bdc68f2", "patch": "@@ -8,18 +8,25 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use cmp::{PartialEq, Eq, PartialOrd, Ord, Ordering};\n+use error::{Error, FromError};\n use fmt;\n+use io;\n use iter::IteratorExt;\n use libc;\n use mem;\n+use old_io;\n use ops::Deref;\n+use option::Option::{self, Some, None};\n+use result::Result::{self, Ok, Err};\n use slice::{self, SliceExt};\n+use str::StrExt;\n use string::String;\n use vec::Vec;\n \n-/// A type representing a C-compatible string\n+/// A type representing an owned C-compatible string\n ///\n-/// This type serves the primary purpose of being able to generate a\n+/// This type serves the primary purpose of being able to safely generate a\n /// C-compatible string from a Rust byte slice or vector. An instance of this\n /// type is a static guarantee that the underlying bytes contain no interior 0\n /// bytes and the final byte is 0.\n@@ -44,28 +51,144 @@ use vec::Vec;\n ///     fn my_printer(s: *const libc::c_char);\n /// }\n ///\n-/// let to_print = \"Hello, world!\";\n-/// let c_to_print = CString::from_slice(to_print.as_bytes());\n+/// let to_print = b\"Hello, world!\";\n+/// let c_to_print = CString::new(to_print).unwrap();\n /// unsafe {\n ///     my_printer(c_to_print.as_ptr());\n /// }\n /// # }\n /// ```\n #[derive(Clone, PartialEq, PartialOrd, Eq, Ord, Hash)]\n pub struct CString {\n-    inner: Vec<libc::c_char>,\n+    inner: Vec<u8>,\n+}\n+\n+/// Representation of a borrowed C string.\n+///\n+/// This dynamically sized type is only safely constructed via a borrowed\n+/// version of an instance of `CString`. This type can be constructed from a raw\n+/// C string as well and represents a C string borrowed from another location.\n+///\n+/// Note that this structure is **not** `repr(C)` and is not recommended to be\n+/// placed in the signatures of FFI functions. Instead safe wrappers of FFI\n+/// functions may leverage the unsafe `from_ptr` constructor to provide a safe\n+/// interface to other consumers.\n+///\n+/// # Examples\n+///\n+/// Inspecting a foreign C string\n+///\n+/// ```no_run\n+/// extern crate libc;\n+/// use std::ffi::CStr;\n+///\n+/// extern { fn my_string() -> *const libc::c_char; }\n+///\n+/// fn main() {\n+///     unsafe {\n+///         let slice = CStr::from_ptr(my_string());\n+///         println!(\"string length: {}\", slice.to_bytes().len());\n+///     }\n+/// }\n+/// ```\n+///\n+/// Passing a Rust-originating C string\n+///\n+/// ```no_run\n+/// extern crate libc;\n+/// use std::ffi::{CString, CStr};\n+///\n+/// fn work(data: &CStr) {\n+///     extern { fn work_with(data: *const libc::c_char); }\n+///\n+///     unsafe { work_with(data.as_ptr()) }\n+/// }\n+///\n+/// fn main() {\n+///     let s = CString::from_slice(b\"data data data data\").unwrap();\n+///     work(&s);\n+/// }\n+/// ```\n+#[derive(Hash)]\n+pub struct CStr {\n+    inner: [libc::c_char]\n+}\n+\n+/// An error returned from `CString::new` to indicate that a nul byte was found\n+/// in the vector provided.\n+#[derive(Clone, PartialEq, Debug)]\n+pub struct NulError(usize, Vec<u8>);\n+\n+/// A conversion trait used by the constructor of `CString` for types that can\n+/// be converted to a vector of bytes.\n+pub trait IntoBytes {\n+    /// Consumes this container, returning a vector of bytes.\n+    fn into_bytes(self) -> Vec<u8>;\n }\n \n impl CString {\n+    /// Create a new C-compatible string from a container of bytes.\n+    ///\n+    /// This method will consume the provided data and use the underlying bytes\n+    /// to construct a new string, ensuring that there is a trailing 0 byte.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// extern crate libc;\n+    /// use std::ffi::CString;\n+    ///\n+    /// extern { fn puts(s: *const libc::c_char); }\n+    ///\n+    /// fn main() {\n+    ///     let to_print = CString::from_slice(b\"Hello!\").unwrap();\n+    ///     unsafe {\n+    ///         puts(to_print.as_ptr());\n+    ///     }\n+    /// }\n+    /// ```\n+    ///\n+    /// # Errors\n+    ///\n+    /// This function will return an error if the bytes yielded contain an\n+    /// internal 0 byte. The error returned will contain the bytes as well as\n+    /// the position of the nul byte.\n+    pub fn new<T: IntoBytes>(t: T) -> Result<CString, NulError> {\n+        let bytes = t.into_bytes();\n+        match bytes.iter().position(|x| *x == 0) {\n+            Some(i) => Err(NulError(i, bytes)),\n+            None => Ok(unsafe { CString::from_vec_unchecked(bytes) }),\n+        }\n+    }\n+\n     /// Create a new C-compatible string from a byte slice.\n     ///\n     /// This method will copy the data of the slice provided into a new\n     /// allocation, ensuring that there is a trailing 0 byte.\n     ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// extern crate libc;\n+    /// use std::ffi::CString;\n+    ///\n+    /// extern { fn puts(s: *const libc::c_char); }\n+    ///\n+    /// fn main() {\n+    ///     let to_print = CString::from_slice(b\"Hello!\").unwrap();\n+    ///     unsafe {\n+    ///         puts(to_print.as_ptr());\n+    ///     }\n+    /// }\n+    /// ```\n+    ///\n     /// # Panics\n     ///\n-    /// This function will panic if there are any 0 bytes already in the slice\n-    /// provided.\n+    /// This function will panic if the provided slice contains any\n+    /// interior nul bytes.\n+    #[unstable(feature = \"std_misc\")]\n+    #[deprecated(since = \"1.0.0\", reason = \"use CString::new instead\")]\n+    #[allow(deprecated)]\n     pub fn from_slice(v: &[u8]) -> CString {\n         CString::from_vec(v.to_vec())\n     }\n@@ -77,11 +200,15 @@ impl CString {\n     ///\n     /// # Panics\n     ///\n-    /// This function will panic if there are any 0 bytes already in the vector\n-    /// provided.\n+    /// This function will panic if the provided slice contains any\n+    /// interior nul bytes.\n+    #[unstable(feature = \"std_misc\")]\n+    #[deprecated(since = \"1.0.0\", reason = \"use CString::new instead\")]\n     pub fn from_vec(v: Vec<u8>) -> CString {\n-        assert!(!v.iter().any(|&x| x == 0));\n-        unsafe { CString::from_vec_unchecked(v) }\n+        match v.iter().position(|x| *x == 0) {\n+            Some(i) => panic!(\"null byte found in slice at: {}\", i),\n+            None => unsafe { CString::from_vec_unchecked(v) },\n+        }\n     }\n \n     /// Create a C-compatible string from a byte vector without checking for\n@@ -91,31 +218,29 @@ impl CString {\n     /// is made that `v` contains no 0 bytes.\n     pub unsafe fn from_vec_unchecked(mut v: Vec<u8>) -> CString {\n         v.push(0);\n-        CString { inner: mem::transmute(v) }\n+        CString { inner: v }\n     }\n \n-    /// Create a view into this C string which includes the trailing nul\n-    /// terminator at the end of the string.\n-    pub fn as_slice_with_nul(&self) -> &[libc::c_char] { &self.inner }\n-\n-    /// Similar to the `as_slice` method, but returns a `u8` slice instead of a\n-    /// `libc::c_char` slice.\n+    /// Returns the contents of this `CString` as a slice of bytes.\n+    ///\n+    /// The returned slice does **not** contain the trailing nul separator and\n+    /// it is guaranteet to not have any interior nul bytes.\n     pub fn as_bytes(&self) -> &[u8] {\n-        unsafe { mem::transmute(&**self) }\n+        &self.inner[..self.inner.len() - 1]\n     }\n \n-    /// Equivalent to `as_slice_with_nul` except that the type returned is a\n-    /// `u8` slice instead of a `libc::c_char` slice.\n+    /// Equivalent to the `as_bytes` function except that the returned slice\n+    /// includes the trailing nul byte.\n     pub fn as_bytes_with_nul(&self) -> &[u8] {\n-        unsafe { mem::transmute(self.as_slice_with_nul()) }\n+        &self.inner\n     }\n }\n \n impl Deref for CString {\n-    type Target = [libc::c_char];\n+    type Target = CStr;\n \n-    fn deref(&self) -> &[libc::c_char] {\n-        &self.inner[..(self.inner.len() - 1)]\n+    fn deref(&self) -> &CStr {\n+        unsafe { mem::transmute(self.as_bytes_with_nul()) }\n     }\n }\n \n@@ -126,54 +251,172 @@ impl fmt::Debug for CString {\n     }\n }\n \n-/// Interpret a C string as a byte slice.\n-///\n-/// This function will calculate the length of the C string provided, and it\n-/// will then return a corresponding slice for the contents of the C string not\n-/// including the nul terminator.\n-///\n-/// This function will tie the lifetime of the returned slice to the lifetime of\n-/// the pointer provided. This is done to help prevent the slice from escaping\n-/// the lifetime of the pointer itself. If a longer lifetime is needed, then\n-/// `mem::copy_lifetime` should be used.\n-///\n-/// This function is unsafe because there is no guarantee of the validity of the\n-/// pointer `raw` or a guarantee that a nul terminator will be found.\n-///\n-/// # Example\n-///\n-/// ```no_run\n-/// # extern crate libc;\n-/// # fn main() {\n-/// use std::ffi;\n-/// use std::str;\n-/// use libc;\n-///\n-/// extern {\n-///     fn my_string() -> *const libc::c_char;\n-/// }\n-///\n-/// unsafe {\n-///     let to_print = my_string();\n-///     let slice = ffi::c_str_to_bytes(&to_print);\n-///     println!(\"string returned: {}\", str::from_utf8(slice).unwrap());\n-/// }\n-/// # }\n-/// ```\n+impl NulError {\n+    /// Returns the position of the nul byte in the slice that was provided to\n+    /// `CString::from_vec`.\n+    pub fn nul_position(&self) -> usize { self.0 }\n+\n+    /// Consumes this error, returning the underlying vector of bytes which\n+    /// generated the error in the first place.\n+    pub fn into_vec(self) -> Vec<u8> { self.1 }\n+}\n+\n+impl Error for NulError {\n+    fn description(&self) -> &str { \"nul byte found in data\" }\n+}\n+\n+impl fmt::Display for NulError {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"nul byte found in provided data at position: {}\", self.0)\n+    }\n+}\n+\n+impl FromError<NulError> for io::Error {\n+    fn from_error(_: NulError) -> io::Error {\n+        io::Error::new(io::ErrorKind::InvalidInput,\n+                       \"data provided contains a nul byte\", None)\n+    }\n+}\n+\n+impl FromError<NulError> for old_io::IoError {\n+    fn from_error(_: NulError) -> old_io::IoError {\n+        old_io::IoError {\n+            kind: old_io::IoErrorKind::InvalidInput,\n+            desc: \"data provided contains a nul byte\",\n+            detail: None\n+        }\n+    }\n+}\n+\n+impl CStr {\n+    /// Cast a raw C string to a safe C string wrapper.\n+    ///\n+    /// This function will cast the provided `ptr` to the `CStr` wrapper which\n+    /// allows inspection and interoperation of non-owned C strings. This method\n+    /// is unsafe for a number of reasons:\n+    ///\n+    /// * There is no guarantee to the validity of `ptr`\n+    /// * The returned lifetime is not guaranteed to be the actual lifetime of\n+    ///   `ptr`\n+    /// * There is no guarantee that the memory pointed to by `ptr` contains a\n+    ///   valid nul terminator byte at the end of the string.\n+    ///\n+    /// > **Note**: This operation is intended to be a 0-cost cast but it is\n+    /// > currently implemented with an up-front calculation of the length of\n+    /// > the string. This is not guaranteed to always be the case.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```no_run\n+    /// # extern crate libc;\n+    /// # fn main() {\n+    /// use std::ffi::CStr;\n+    /// use std::str;\n+    /// use libc;\n+    ///\n+    /// extern {\n+    ///     fn my_string() -> *const libc::c_char;\n+    /// }\n+    ///\n+    /// unsafe {\n+    ///     let slice = CStr::from_ptr(my_string());\n+    ///     println!(\"string returned: {}\",\n+    ///              str::from_utf8(slice.to_bytes()).unwrap());\n+    /// }\n+    /// # }\n+    /// ```\n+    pub unsafe fn from_ptr<'a>(ptr: *const libc::c_char) -> &'a CStr {\n+        let len = libc::strlen(ptr);\n+        mem::transmute(slice::from_raw_parts(ptr, len as usize + 1))\n+    }\n+\n+    /// Return the inner pointer to this C string.\n+    ///\n+    /// The returned pointer will be valid for as long as `self` is and points\n+    /// to a continguous region of memory terminated with a 0 byte to represent\n+    /// the end of the string.\n+    pub fn as_ptr(&self) -> *const libc::c_char {\n+        self.inner.as_ptr()\n+    }\n+\n+    /// Convert this C string to a byte slice.\n+    ///\n+    /// This function will calculate the length of this string (which normally\n+    /// requires a linear amount of work to be done) and then return the\n+    /// resulting slice of `u8` elements.\n+    ///\n+    /// The returned slice will **not** contain the trailing nul that this C\n+    /// string has.\n+    ///\n+    /// > **Note**: This method is currently implemented as a 0-cost cast, but\n+    /// > it is planned to alter its definition in the future to perform the\n+    /// > length calculation whenever this method is called.\n+    pub fn to_bytes(&self) -> &[u8] {\n+        let bytes = self.to_bytes_with_nul();\n+        &bytes[..bytes.len() - 1]\n+    }\n+\n+    /// Convert this C string to a byte slice containing the trailing 0 byte.\n+    ///\n+    /// This function is the equivalent of `to_bytes` except that it will retain\n+    /// the trailing nul instead of chopping it off.\n+    ///\n+    /// > **Note**: This method is currently implemented as a 0-cost cast, but\n+    /// > it is planned to alter its definition in the future to perform the\n+    /// > length calculation whenever this method is called.\n+    pub fn to_bytes_with_nul(&self) -> &[u8] {\n+        unsafe { mem::transmute::<&[libc::c_char], &[u8]>(&self.inner) }\n+    }\n+}\n+\n+impl PartialEq for CStr {\n+    fn eq(&self, other: &CStr) -> bool {\n+        self.to_bytes().eq(&other.to_bytes())\n+    }\n+}\n+impl Eq for CStr {}\n+impl PartialOrd for CStr {\n+    fn partial_cmp(&self, other: &CStr) -> Option<Ordering> {\n+        self.to_bytes().partial_cmp(&other.to_bytes())\n+    }\n+}\n+impl Ord for CStr {\n+    fn cmp(&self, other: &CStr) -> Ordering {\n+        self.to_bytes().cmp(&other.to_bytes())\n+    }\n+}\n+\n+/// Deprecated in favor of `CStr`\n+#[unstable(feature = \"std_misc\")]\n+#[deprecated(since = \"1.0.0\", reason = \"use CStr::from_ptr(p).to_bytes() instead\")]\n pub unsafe fn c_str_to_bytes<'a>(raw: &'a *const libc::c_char) -> &'a [u8] {\n     let len = libc::strlen(*raw);\n     slice::from_raw_parts(*(raw as *const _ as *const *const u8), len as usize)\n }\n \n-/// Interpret a C string as a byte slice with the nul terminator.\n-///\n-/// This function is identical to `from_raw_buf` except that the returned slice\n-/// will include the nul terminator of the string.\n-pub unsafe fn c_str_to_bytes_with_nul<'a>(raw: &'a *const libc::c_char) -> &'a [u8] {\n+/// Deprecated in favor of `CStr`\n+#[unstable(feature = \"std_misc\")]\n+#[deprecated(since = \"1.0.0\",\n+             reason = \"use CStr::from_ptr(p).to_bytes_with_nul() instead\")]\n+pub unsafe fn c_str_to_bytes_with_nul<'a>(raw: &'a *const libc::c_char)\n+                                          -> &'a [u8] {\n     let len = libc::strlen(*raw) + 1;\n     slice::from_raw_parts(*(raw as *const _ as *const *const u8), len as usize)\n }\n \n+impl<'a> IntoBytes for &'a str {\n+    fn into_bytes(self) -> Vec<u8> { self.as_bytes().to_vec() }\n+}\n+impl<'a> IntoBytes for &'a [u8] {\n+    fn into_bytes(self) -> Vec<u8> { self.to_vec() }\n+}\n+impl IntoBytes for String {\n+    fn into_bytes(self) -> Vec<u8> { self.into_bytes() }\n+}\n+impl IntoBytes for Vec<u8> {\n+    fn into_bytes(self) -> Vec<u8> { self }\n+}\n+\n #[cfg(test)]\n mod tests {\n     use prelude::v1::*;\n@@ -193,21 +436,19 @@ mod tests {\n \n     #[test]\n     fn simple() {\n-        let s = CString::from_slice(b\"1234\");\n+        let s = CString::from_slice(b\"1234\").unwrap();\n         assert_eq!(s.as_bytes(), b\"1234\");\n         assert_eq!(s.as_bytes_with_nul(), b\"1234\\0\");\n-        unsafe {\n-            assert_eq!(&*s,\n-                       mem::transmute::<_, &[libc::c_char]>(b\"1234\"));\n-            assert_eq!(s.as_slice_with_nul(),\n-                       mem::transmute::<_, &[libc::c_char]>(b\"1234\\0\"));\n-        }\n     }\n \n-    #[should_fail] #[test]\n-    fn build_with_zero1() { CString::from_slice(b\"\\0\"); }\n-    #[should_fail] #[test]\n-    fn build_with_zero2() { CString::from_vec(vec![0]); }\n+    #[test]\n+    fn build_with_zero1() {\n+        assert!(CString::from_slice(b\"\\0\").is_err());\n+    }\n+    #[test]\n+    fn build_with_zero2() {\n+        assert!(CString::from_vec(vec![0]).is_err());\n+    }\n \n     #[test]\n     fn build_with_zero3() {\n@@ -219,7 +460,16 @@ mod tests {\n \n     #[test]\n     fn formatted() {\n-        let s = CString::from_slice(b\"12\");\n+        let s = CString::from_slice(b\"12\").unwrap();\n         assert_eq!(format!(\"{:?}\", s), \"\\\"12\\\"\");\n     }\n+\n+    #[test]\n+    fn borrowed() {\n+        unsafe {\n+            let s = CStr::from_ptr(b\"12\\0\".as_ptr() as *const _);\n+            assert_eq!(s.to_bytes(), b\"12\");\n+            assert_eq!(s.to_bytes_with_nul(), b\"12\\0\");\n+        }\n+    }\n }"}, {"sha": "1bff6afb776079b0e5102ad2b0e92541d089263c", "filename": "src/libstd/ffi/mod.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f3657170b1cbe80393d9ccde8608872f7bdc68f2/src%2Flibstd%2Fffi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3657170b1cbe80393d9ccde8608872f7bdc68f2/src%2Flibstd%2Fffi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fffi%2Fmod.rs?ref=f3657170b1cbe80393d9ccde8608872f7bdc68f2", "patch": "@@ -14,8 +14,10 @@\n             reason = \"module just underwent fairly large reorganization and the dust \\\n                       still needs to settle\")]\n \n-pub use self::c_str::CString;\n+pub use self::c_str::{CString, CStr, NulError, IntoBytes};\n+#[allow(deprecated)]\n pub use self::c_str::c_str_to_bytes;\n+#[allow(deprecated)]\n pub use self::c_str::c_str_to_bytes_with_nul;\n \n pub use self::os_str::OsString;"}, {"sha": "392a253d7336683c13b19943dc10bbc8eae6de43", "filename": "src/libstd/old_io/net/pipe.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f3657170b1cbe80393d9ccde8608872f7bdc68f2/src%2Flibstd%2Fold_io%2Fnet%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3657170b1cbe80393d9ccde8608872f7bdc68f2/src%2Flibstd%2Fold_io%2Fnet%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fnet%2Fpipe.rs?ref=f3657170b1cbe80393d9ccde8608872f7bdc68f2", "patch": "@@ -55,7 +55,7 @@ impl UnixStream {\n     /// stream.write(&[1, 2, 3]);\n     /// ```\n     pub fn connect<P: BytesContainer>(path: P) -> IoResult<UnixStream> {\n-        let path = CString::from_slice(path.container_as_bytes());\n+        let path = try!(CString::new(path.container_as_bytes()));\n         UnixStreamImp::connect(&path, None)\n             .map(|inner| UnixStream { inner: inner })\n     }\n@@ -77,7 +77,7 @@ impl UnixStream {\n             return Err(standard_error(TimedOut));\n         }\n \n-        let path = CString::from_slice(path.container_as_bytes());\n+        let path = try!(CString::new(path.container_as_bytes()));\n         UnixStreamImp::connect(&path, Some(timeout.num_milliseconds() as u64))\n             .map(|inner| UnixStream { inner: inner })\n     }\n@@ -184,7 +184,7 @@ impl UnixListener {\n     /// # }\n     /// ```\n     pub fn bind<P: BytesContainer>(path: P) -> IoResult<UnixListener> {\n-        let path = CString::from_slice(path.container_as_bytes());\n+        let path = try!(CString::new(path.container_as_bytes()));\n         UnixListenerImp::bind(&path)\n             .map(|inner| UnixListener { inner: inner })\n     }"}, {"sha": "c761bf705a81ff3022bebd2184163789a6fc80c7", "filename": "src/libstd/old_io/process.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/f3657170b1cbe80393d9ccde8608872f7bdc68f2/src%2Flibstd%2Fold_io%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3657170b1cbe80393d9ccde8608872f7bdc68f2/src%2Flibstd%2Fold_io%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fprocess.rs?ref=f3657170b1cbe80393d9ccde8608872f7bdc68f2", "patch": "@@ -204,7 +204,7 @@ impl Command {\n     /// otherwise configure the process.\n     pub fn new<T: BytesContainer>(program: T) -> Command {\n         Command {\n-            program: CString::from_slice(program.container_as_bytes()),\n+            program: CString::new(program.container_as_bytes()).unwrap(),\n             args: Vec::new(),\n             env: None,\n             cwd: None,\n@@ -219,14 +219,14 @@ impl Command {\n \n     /// Add an argument to pass to the program.\n     pub fn arg<'a, T: BytesContainer>(&'a mut self, arg: T) -> &'a mut Command {\n-        self.args.push(CString::from_slice(arg.container_as_bytes()));\n+        self.args.push(CString::new(arg.container_as_bytes()).unwrap());\n         self\n     }\n \n     /// Add multiple arguments to pass to the program.\n     pub fn args<'a, T: BytesContainer>(&'a mut self, args: &[T]) -> &'a mut Command {\n         self.args.extend(args.iter().map(|arg| {\n-            CString::from_slice(arg.container_as_bytes())\n+            CString::new(arg.container_as_bytes()).unwrap()\n         }));\n         self\n     }\n@@ -239,8 +239,8 @@ impl Command {\n                 // if the env is currently just inheriting from the parent's,\n                 // materialize the parent's env into a hashtable.\n                 self.env = Some(os::env_as_bytes().into_iter().map(|(k, v)| {\n-                    (EnvKey(CString::from_slice(&k)),\n-                     CString::from_slice(&v))\n+                    (EnvKey(CString::new(k).unwrap()),\n+                     CString::new(v).unwrap())\n                 }).collect());\n                 self.env.as_mut().unwrap()\n             }\n@@ -254,16 +254,16 @@ impl Command {\n     pub fn env<'a, T, U>(&'a mut self, key: T, val: U)\n                          -> &'a mut Command\n                          where T: BytesContainer, U: BytesContainer {\n-        let key = EnvKey(CString::from_slice(key.container_as_bytes()));\n-        let val = CString::from_slice(val.container_as_bytes());\n+        let key = EnvKey(CString::new(key.container_as_bytes()).unwrap());\n+        let val = CString::new(val.container_as_bytes()).unwrap();\n         self.get_env_map().insert(key, val);\n         self\n     }\n \n     /// Removes an environment variable mapping.\n     pub fn env_remove<'a, T>(&'a mut self, key: T) -> &'a mut Command\n                              where T: BytesContainer {\n-        let key = EnvKey(CString::from_slice(key.container_as_bytes()));\n+        let key = EnvKey(CString::new(key.container_as_bytes()).unwrap());\n         self.get_env_map().remove(&key);\n         self\n     }\n@@ -276,15 +276,15 @@ impl Command {\n                                  -> &'a mut Command\n                                  where T: BytesContainer, U: BytesContainer {\n         self.env = Some(env.iter().map(|&(ref k, ref v)| {\n-            (EnvKey(CString::from_slice(k.container_as_bytes())),\n-             CString::from_slice(v.container_as_bytes()))\n+            (EnvKey(CString::new(k.container_as_bytes()).unwrap()),\n+             CString::new(v.container_as_bytes()).unwrap())\n         }).collect());\n         self\n     }\n \n     /// Set the working directory for the child process.\n     pub fn cwd<'a>(&'a mut self, dir: &Path) -> &'a mut Command {\n-        self.cwd = Some(CString::from_slice(dir.as_vec()));\n+        self.cwd = Some(CString::new(dir.as_vec()).unwrap());\n         self\n     }\n \n@@ -1226,7 +1226,7 @@ mod tests {\n         cmd.env(\"path\", \"foo\");\n         cmd.env(\"Path\", \"bar\");\n         let env = &cmd.env.unwrap();\n-        let val = env.get(&EnvKey(CString::from_slice(b\"PATH\")));\n-        assert!(val.unwrap() == &CString::from_slice(b\"bar\"));\n+        let val = env.get(&EnvKey(CString::new(b\"PATH\").unwrap()));\n+        assert!(val.unwrap() == &CString::new(b\"bar\").unwrap());\n     }\n }"}, {"sha": "61f5bd0f013606f37f2e4476acf3b155c5f7f6af", "filename": "src/libstd/rt/args.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f3657170b1cbe80393d9ccde8608872f7bdc68f2/src%2Flibstd%2Frt%2Fargs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3657170b1cbe80393d9ccde8608872f7bdc68f2/src%2Flibstd%2Frt%2Fargs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fargs.rs?ref=f3657170b1cbe80393d9ccde8608872f7bdc68f2", "patch": "@@ -49,7 +49,7 @@ mod imp {\n \n     use libc;\n     use mem;\n-    use ffi;\n+    use ffi::CStr;\n \n     use sync::{StaticMutex, MUTEX_INIT};\n \n@@ -96,10 +96,11 @@ mod imp {\n         unsafe { mem::transmute(&GLOBAL_ARGS_PTR) }\n     }\n \n-    unsafe fn load_argc_and_argv(argc: int, argv: *const *const u8) -> Vec<Vec<u8>> {\n+    unsafe fn load_argc_and_argv(argc: isize,\n+                                 argv: *const *const u8) -> Vec<Vec<u8>> {\n         let argv = argv as *const *const libc::c_char;\n-        (0..argc as uint).map(|i| {\n-            ffi::c_str_to_bytes(&*argv.offset(i as int)).to_vec()\n+        (0..argc).map(|i| {\n+            CStr::from_ptr(*argv.offset(i)).to_bytes().to_vec()\n         }).collect()\n     }\n "}, {"sha": "e2ac5ac24f89ec01269f0eb545a58d381e296b46", "filename": "src/libstd/sys/common/net.rs", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/f3657170b1cbe80393d9ccde8608872f7bdc68f2/src%2Flibstd%2Fsys%2Fcommon%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3657170b1cbe80393d9ccde8608872f7bdc68f2/src%2Flibstd%2Fsys%2Fcommon%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fnet.rs?ref=f3657170b1cbe80393d9ccde8608872f7bdc68f2", "patch": "@@ -12,8 +12,7 @@ use prelude::v1::*;\n use self::SocketStatus::*;\n use self::InAddr::*;\n \n-use ffi::CString;\n-use ffi;\n+use ffi::{CString, CStr};\n use old_io::net::addrinfo;\n use old_io::net::ip::{SocketAddr, IpAddr, Ipv4Addr, Ipv6Addr};\n use old_io::{IoResult, IoError};\n@@ -235,9 +234,15 @@ pub fn get_host_addresses(host: Option<&str>, servname: Option<&str>,\n \n     assert!(host.is_some() || servname.is_some());\n \n-    let c_host = host.map(|x| CString::from_slice(x.as_bytes()));\n+    let c_host = match host {\n+        Some(x) => Some(try!(CString::new(x))),\n+        None => None,\n+    };\n     let c_host = c_host.as_ref().map(|x| x.as_ptr()).unwrap_or(null());\n-    let c_serv = servname.map(|x| CString::from_slice(x.as_bytes()));\n+    let c_serv = match servname {\n+        Some(x) => Some(try!(CString::new(x))),\n+        None => None,\n+    };\n     let c_serv = c_serv.as_ref().map(|x| x.as_ptr()).unwrap_or(null());\n \n     let hint = hint.map(|hint| {\n@@ -325,8 +330,8 @@ pub fn get_address_name(addr: IpAddr) -> Result<String, IoError> {\n     }\n \n     unsafe {\n-        Ok(str::from_utf8(ffi::c_str_to_bytes(&hostbuf.as_ptr()))\n-               .unwrap().to_string())\n+        let data = CStr::from_ptr(hostbuf.as_ptr());\n+        Ok(str::from_utf8(data.to_bytes()).unwrap().to_string())\n     }\n }\n "}, {"sha": "713f79c5d0814d29b64d0936779ce547cd3ce29c", "filename": "src/libstd/sys/common/net2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f3657170b1cbe80393d9ccde8608872f7bdc68f2/src%2Flibstd%2Fsys%2Fcommon%2Fnet2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3657170b1cbe80393d9ccde8608872f7bdc68f2/src%2Flibstd%2Fsys%2Fcommon%2Fnet2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fnet2.rs?ref=f3657170b1cbe80393d9ccde8608872f7bdc68f2", "patch": "@@ -121,7 +121,7 @@ impl Drop for LookupHost {\n pub fn lookup_host(host: &str) -> io::Result<LookupHost> {\n     init();\n \n-    let c_host = CString::from_slice(host.as_bytes());\n+    let c_host = try!(CString::new(host));\n     let mut res = 0 as *mut _;\n     unsafe {\n         try!(cvt_gai(getaddrinfo(c_host.as_ptr(), 0 as *const _, 0 as *const _,"}, {"sha": "8b560339f304474c6cb67d523d69a138f7c2341f", "filename": "src/libstd/sys/unix/backtrace.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f3657170b1cbe80393d9ccde8608872f7bdc68f2/src%2Flibstd%2Fsys%2Funix%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3657170b1cbe80393d9ccde8608872f7bdc68f2/src%2Flibstd%2Fsys%2Funix%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fbacktrace.rs?ref=f3657170b1cbe80393d9ccde8608872f7bdc68f2", "patch": "@@ -85,7 +85,7 @@\n \n use prelude::v1::*;\n \n-use ffi;\n+use ffi::CStr;\n use old_io::IoResult;\n use libc;\n use mem;\n@@ -233,7 +233,7 @@ fn print(w: &mut Writer, idx: int, addr: *mut libc::c_void) -> IoResult<()> {\n         output(w, idx,addr, None)\n     } else {\n         output(w, idx, addr, Some(unsafe {\n-            ffi::c_str_to_bytes(&info.dli_sname)\n+            CStr::from_ptr(info.dli_sname).to_bytes()\n         }))\n     }\n }\n@@ -364,7 +364,7 @@ fn print(w: &mut Writer, idx: int, addr: *mut libc::c_void) -> IoResult<()> {\n     if ret == 0 || data.is_null() {\n         output(w, idx, addr, None)\n     } else {\n-        output(w, idx, addr, Some(unsafe { ffi::c_str_to_bytes(&data) }))\n+        output(w, idx, addr, Some(unsafe { CStr::from_ptr(data).to_bytes() }))\n     }\n }\n "}, {"sha": "b8b9dcfb3c68920b2602ed2e1e22072ac5d106be", "filename": "src/libstd/sys/unix/ext.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f3657170b1cbe80393d9ccde8608872f7bdc68f2/src%2Flibstd%2Fsys%2Funix%2Fext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3657170b1cbe80393d9ccde8608872f7bdc68f2/src%2Flibstd%2Fsys%2Funix%2Fext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fext.rs?ref=f3657170b1cbe80393d9ccde8608872f7bdc68f2", "patch": "@@ -33,7 +33,7 @@\n \n use prelude::v1::*;\n \n-use ffi::{CString, OsStr, OsString};\n+use ffi::{CString, NulError, OsStr, OsString};\n use fs::{self, Permissions, OpenOptions};\n use net;\n use mem;\n@@ -155,7 +155,7 @@ pub trait OsStrExt {\n     fn as_bytes(&self) -> &[u8];\n \n     /// Convert the `OsStr` slice into a `CString`.\n-    fn to_cstring(&self) -> CString;\n+    fn to_cstring(&self) -> Result<CString, NulError>;\n }\n \n impl OsStrExt for OsStr {\n@@ -166,8 +166,8 @@ impl OsStrExt for OsStr {\n         &self.as_inner().inner\n     }\n \n-    fn to_cstring(&self) -> CString {\n-        CString::from_slice(self.as_bytes())\n+    fn to_cstring(&self) -> Result<CString, NulError> {\n+        CString::new(self.as_bytes())\n     }\n }\n \n@@ -249,5 +249,7 @@ impl ExitStatusExt for process::ExitStatus {\n /// Includes all extension traits, and some important type definitions.\n pub mod prelude {\n     #[doc(no_inline)]\n-    pub use super::{Fd, AsRawFd, OsStrExt, OsStringExt, PermissionsExt, CommandExt, ExitStatusExt};\n+    pub use super::{Fd, AsRawFd, OsStrExt, OsStringExt, PermissionsExt};\n+    #[doc(no_inline)]\n+    pub use super::{CommandExt, ExitStatusExt};\n }"}, {"sha": "5c847002d2394f35c1f4d7cb9c142f40edbe2de6", "filename": "src/libstd/sys/unix/fs.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/f3657170b1cbe80393d9ccde8608872f7bdc68f2/src%2Flibstd%2Fsys%2Funix%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3657170b1cbe80393d9ccde8608872f7bdc68f2/src%2Flibstd%2Fsys%2Funix%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ffs.rs?ref=f3657170b1cbe80393d9ccde8608872f7bdc68f2", "patch": "@@ -12,7 +12,7 @@\n \n use prelude::v1::*;\n \n-use ffi::{self, CString};\n+use ffi::{CString, CStr};\n use old_io::{FilePermission, Write, UnstableFileStat, Open, FileAccess, FileMode};\n use old_io::{IoResult, FileStat, SeekStyle};\n use old_io::{Read, Truncate, SeekCur, SeekSet, ReadWrite, SeekEnd, Append};\n@@ -151,8 +151,8 @@ impl Drop for FileDesc {\n     }\n }\n \n-fn cstr(path: &Path) -> CString {\n-    CString::from_slice(path.as_vec())\n+fn cstr(path: &Path) -> IoResult<CString> {\n+    Ok(try!(CString::new(path.as_vec())))\n }\n \n pub fn open(path: &Path, fm: FileMode, fa: FileAccess) -> IoResult<FileDesc> {\n@@ -170,15 +170,15 @@ pub fn open(path: &Path, fm: FileMode, fa: FileAccess) -> IoResult<FileDesc> {\n                             libc::S_IRUSR | libc::S_IWUSR),\n     };\n \n-    let path = cstr(path);\n+    let path = try!(cstr(path));\n     match retry(|| unsafe { libc::open(path.as_ptr(), flags, mode) }) {\n         -1 => Err(super::last_error()),\n         fd => Ok(FileDesc::new(fd, true)),\n     }\n }\n \n pub fn mkdir(p: &Path, mode: uint) -> IoResult<()> {\n-    let p = cstr(p);\n+    let p = try!(cstr(p));\n     mkerr_libc(unsafe { libc::mkdir(p.as_ptr(), mode as libc::mode_t) })\n }\n \n@@ -203,7 +203,7 @@ pub fn readdir(p: &Path) -> IoResult<Vec<Path>> {\n     let mut buf = Vec::<u8>::with_capacity(size as uint);\n     let ptr = buf.as_mut_ptr() as *mut dirent_t;\n \n-    let p = CString::from_slice(p.as_vec());\n+    let p = try!(CString::new(p.as_vec()));\n     let dir_ptr = unsafe {opendir(p.as_ptr())};\n \n     if dir_ptr as uint != 0 {\n@@ -212,7 +212,7 @@ pub fn readdir(p: &Path) -> IoResult<Vec<Path>> {\n         while unsafe { readdir_r(dir_ptr, ptr, &mut entry_ptr) == 0 } {\n             if entry_ptr.is_null() { break }\n             paths.push(unsafe {\n-                Path::new(ffi::c_str_to_bytes(&rust_list_dir_val(entry_ptr)))\n+                Path::new(CStr::from_ptr(rust_list_dir_val(entry_ptr)).to_bytes())\n             });\n         }\n         assert_eq!(unsafe { closedir(dir_ptr) }, 0);\n@@ -223,39 +223,39 @@ pub fn readdir(p: &Path) -> IoResult<Vec<Path>> {\n }\n \n pub fn unlink(p: &Path) -> IoResult<()> {\n-    let p = cstr(p);\n+    let p = try!(cstr(p));\n     mkerr_libc(unsafe { libc::unlink(p.as_ptr()) })\n }\n \n pub fn rename(old: &Path, new: &Path) -> IoResult<()> {\n-    let old = cstr(old);\n-    let new = cstr(new);\n+    let old = try!(cstr(old));\n+    let new = try!(cstr(new));\n     mkerr_libc(unsafe {\n         libc::rename(old.as_ptr(), new.as_ptr())\n     })\n }\n \n pub fn chmod(p: &Path, mode: uint) -> IoResult<()> {\n-    let p = cstr(p);\n+    let p = try!(cstr(p));\n     mkerr_libc(retry(|| unsafe {\n         libc::chmod(p.as_ptr(), mode as libc::mode_t)\n     }))\n }\n \n pub fn rmdir(p: &Path) -> IoResult<()> {\n-    let p = cstr(p);\n+    let p = try!(cstr(p));\n     mkerr_libc(unsafe { libc::rmdir(p.as_ptr()) })\n }\n \n pub fn chown(p: &Path, uid: int, gid: int) -> IoResult<()> {\n-    let p = cstr(p);\n+    let p = try!(cstr(p));\n     mkerr_libc(retry(|| unsafe {\n         libc::chown(p.as_ptr(), uid as libc::uid_t, gid as libc::gid_t)\n     }))\n }\n \n pub fn readlink(p: &Path) -> IoResult<Path> {\n-    let c_path = cstr(p);\n+    let c_path = try!(cstr(p));\n     let p = c_path.as_ptr();\n     let mut len = unsafe { libc::pathconf(p as *mut _, libc::_PC_NAME_MAX) };\n     if len == -1 {\n@@ -276,14 +276,14 @@ pub fn readlink(p: &Path) -> IoResult<Path> {\n }\n \n pub fn symlink(src: &Path, dst: &Path) -> IoResult<()> {\n-    let src = cstr(src);\n-    let dst = cstr(dst);\n+    let src = try!(cstr(src));\n+    let dst = try!(cstr(dst));\n     mkerr_libc(unsafe { libc::symlink(src.as_ptr(), dst.as_ptr()) })\n }\n \n pub fn link(src: &Path, dst: &Path) -> IoResult<()> {\n-    let src = cstr(src);\n-    let dst = cstr(dst);\n+    let src = try!(cstr(src));\n+    let dst = try!(cstr(dst));\n     mkerr_libc(unsafe { libc::link(src.as_ptr(), dst.as_ptr()) })\n }\n \n@@ -331,7 +331,7 @@ fn mkstat(stat: &libc::stat) -> FileStat {\n }\n \n pub fn stat(p: &Path) -> IoResult<FileStat> {\n-    let p = cstr(p);\n+    let p = try!(cstr(p));\n     let mut stat: libc::stat = unsafe { mem::zeroed() };\n     match unsafe { libc::stat(p.as_ptr(), &mut stat) } {\n         0 => Ok(mkstat(&stat)),\n@@ -340,7 +340,7 @@ pub fn stat(p: &Path) -> IoResult<FileStat> {\n }\n \n pub fn lstat(p: &Path) -> IoResult<FileStat> {\n-    let p = cstr(p);\n+    let p = try!(cstr(p));\n     let mut stat: libc::stat = unsafe { mem::zeroed() };\n     match unsafe { libc::lstat(p.as_ptr(), &mut stat) } {\n         0 => Ok(mkstat(&stat)),\n@@ -349,7 +349,7 @@ pub fn lstat(p: &Path) -> IoResult<FileStat> {\n }\n \n pub fn utime(p: &Path, atime: u64, mtime: u64) -> IoResult<()> {\n-    let p = cstr(p);\n+    let p = try!(cstr(p));\n     let buf = libc::utimbuf {\n         actime: (atime / 1000) as libc::time_t,\n         modtime: (mtime / 1000) as libc::time_t,"}, {"sha": "92a47c6c3850df3a34b3ac132e83f72314db86d6", "filename": "src/libstd/sys/unix/fs2.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/f3657170b1cbe80393d9ccde8608872f7bdc68f2/src%2Flibstd%2Fsys%2Funix%2Ffs2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3657170b1cbe80393d9ccde8608872f7bdc68f2/src%2Flibstd%2Fsys%2Funix%2Ffs2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ffs2.rs?ref=f3657170b1cbe80393d9ccde8608872f7bdc68f2", "patch": "@@ -12,7 +12,7 @@ use core::prelude::*;\n use io::prelude::*;\n use os::unix::prelude::*;\n \n-use ffi::{self, CString, OsString, AsOsStr, OsStr};\n+use ffi::{CString, CStr, OsString, AsOsStr, OsStr};\n use io::{self, Error, Seek, SeekFrom};\n use libc::{self, c_int, c_void, size_t, off_t, c_char, mode_t};\n use mem;\n@@ -147,8 +147,7 @@ impl DirEntry {\n             fn rust_list_dir_val(ptr: *mut libc::dirent_t) -> *const c_char;\n         }\n         unsafe {\n-            let ptr = rust_list_dir_val(self.dirent);\n-            ffi::c_str_to_bytes(mem::copy_lifetime(self, &ptr))\n+            CStr::from_ptr(rust_list_dir_val(self.dirent)).to_bytes()\n         }\n     }\n }\n@@ -204,7 +203,7 @@ impl File {\n             (true, false) |\n             (false, false) => libc::O_RDONLY,\n         };\n-        let path = cstr(path);\n+        let path = try!(cstr(path));\n         let fd = try!(cvt_r(|| unsafe {\n             libc::open(path.as_ptr(), flags, opts.mode)\n         }));\n@@ -268,19 +267,20 @@ impl File {\n     pub fn fd(&self) -> &FileDesc { &self.0 }\n }\n \n-fn cstr(path: &Path) -> CString {\n-    CString::from_slice(path.as_os_str().as_bytes())\n+fn cstr(path: &Path) -> io::Result<CString> {\n+    let cstring = try!(path.as_os_str().to_cstring());\n+    Ok(cstring)\n }\n \n pub fn mkdir(p: &Path) -> io::Result<()> {\n-    let p = cstr(p);\n+    let p = try!(cstr(p));\n     try!(cvt(unsafe { libc::mkdir(p.as_ptr(), 0o777) }));\n     Ok(())\n }\n \n pub fn readdir(p: &Path) -> io::Result<ReadDir> {\n     let root = Rc::new(p.to_path_buf());\n-    let p = cstr(p);\n+    let p = try!(cstr(p));\n     unsafe {\n         let ptr = libc::opendir(p.as_ptr());\n         if ptr.is_null() {\n@@ -292,40 +292,40 @@ pub fn readdir(p: &Path) -> io::Result<ReadDir> {\n }\n \n pub fn unlink(p: &Path) -> io::Result<()> {\n-    let p = cstr(p);\n+    let p = try!(cstr(p));\n     try!(cvt(unsafe { libc::unlink(p.as_ptr()) }));\n     Ok(())\n }\n \n pub fn rename(old: &Path, new: &Path) -> io::Result<()> {\n-    let old = cstr(old);\n-    let new = cstr(new);\n+    let old = try!(cstr(old));\n+    let new = try!(cstr(new));\n     try!(cvt(unsafe { libc::rename(old.as_ptr(), new.as_ptr()) }));\n     Ok(())\n }\n \n pub fn set_perm(p: &Path, perm: FilePermissions) -> io::Result<()> {\n-    let p = cstr(p);\n+    let p = try!(cstr(p));\n     try!(cvt_r(|| unsafe { libc::chmod(p.as_ptr(), perm.mode) }));\n     Ok(())\n }\n \n pub fn rmdir(p: &Path) -> io::Result<()> {\n-    let p = cstr(p);\n+    let p = try!(cstr(p));\n     try!(cvt(unsafe { libc::rmdir(p.as_ptr()) }));\n     Ok(())\n }\n \n pub fn chown(p: &Path, uid: isize, gid: isize) -> io::Result<()> {\n-    let p = cstr(p);\n+    let p = try!(cstr(p));\n     try!(cvt_r(|| unsafe {\n         libc::chown(p.as_ptr(), uid as libc::uid_t, gid as libc::gid_t)\n     }));\n     Ok(())\n }\n \n pub fn readlink(p: &Path) -> io::Result<PathBuf> {\n-    let c_path = cstr(p);\n+    let c_path = try!(cstr(p));\n     let p = c_path.as_ptr();\n     let mut len = unsafe { libc::pathconf(p as *mut _, libc::_PC_NAME_MAX) };\n     if len < 0 {\n@@ -343,35 +343,35 @@ pub fn readlink(p: &Path) -> io::Result<PathBuf> {\n }\n \n pub fn symlink(src: &Path, dst: &Path) -> io::Result<()> {\n-    let src = cstr(src);\n-    let dst = cstr(dst);\n+    let src = try!(cstr(src));\n+    let dst = try!(cstr(dst));\n     try!(cvt(unsafe { libc::symlink(src.as_ptr(), dst.as_ptr()) }));\n     Ok(())\n }\n \n pub fn link(src: &Path, dst: &Path) -> io::Result<()> {\n-    let src = cstr(src);\n-    let dst = cstr(dst);\n+    let src = try!(cstr(src));\n+    let dst = try!(cstr(dst));\n     try!(cvt(unsafe { libc::link(src.as_ptr(), dst.as_ptr()) }));\n     Ok(())\n }\n \n pub fn stat(p: &Path) -> io::Result<FileAttr> {\n-    let p = cstr(p);\n+    let p = try!(cstr(p));\n     let mut stat: libc::stat = unsafe { mem::zeroed() };\n     try!(cvt(unsafe { libc::stat(p.as_ptr(), &mut stat) }));\n     Ok(FileAttr { stat: stat })\n }\n \n pub fn lstat(p: &Path) -> io::Result<FileAttr> {\n-    let p = cstr(p);\n+    let p = try!(cstr(p));\n     let mut stat: libc::stat = unsafe { mem::zeroed() };\n     try!(cvt(unsafe { libc::lstat(p.as_ptr(), &mut stat) }));\n     Ok(FileAttr { stat: stat })\n }\n \n pub fn utimes(p: &Path, atime: u64, mtime: u64) -> io::Result<()> {\n-    let p = cstr(p);\n+    let p = try!(cstr(p));\n     let buf = [super::ms_to_timeval(atime), super::ms_to_timeval(mtime)];\n     try!(cvt(unsafe { c::utimes(p.as_ptr(), buf.as_ptr()) }));\n     Ok(())"}, {"sha": "b79ad7031fa48dc31dcc208036ae5f5bf353eaf1", "filename": "src/libstd/sys/unix/mod.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f3657170b1cbe80393d9ccde8608872f7bdc68f2/src%2Flibstd%2Fsys%2Funix%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3657170b1cbe80393d9ccde8608872f7bdc68f2/src%2Flibstd%2Fsys%2Funix%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fmod.rs?ref=f3657170b1cbe80393d9ccde8608872f7bdc68f2", "patch": "@@ -17,7 +17,7 @@\n \n use prelude::v1::*;\n \n-use ffi;\n+use ffi::CStr;\n use io::{self, ErrorKind};\n use libc;\n use num::{Int, SignedInt};\n@@ -91,7 +91,8 @@ pub fn last_gai_error(s: libc::c_int) -> IoError {\n \n     let mut err = decode_error(s);\n     err.detail = Some(unsafe {\n-        str::from_utf8(ffi::c_str_to_bytes(&gai_strerror(s))).unwrap().to_string()\n+        let data = CStr::from_ptr(gai_strerror(s));\n+        str::from_utf8(data.to_bytes()).unwrap().to_string()\n     });\n     err\n }"}, {"sha": "83b6a14b78d95fd3f1ed4d8c385ec550bbb63d11", "filename": "src/libstd/sys/unix/net.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f3657170b1cbe80393d9ccde8608872f7bdc68f2/src%2Flibstd%2Fsys%2Funix%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3657170b1cbe80393d9ccde8608872f7bdc68f2/src%2Flibstd%2Fsys%2Funix%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fnet.rs?ref=f3657170b1cbe80393d9ccde8608872f7bdc68f2", "patch": "@@ -10,7 +10,7 @@\n \n use prelude::v1::*;\n \n-use ffi;\n+use ffi::CStr;\n use io;\n use libc::{self, c_int, size_t};\n use str;\n@@ -31,7 +31,7 @@ pub fn cvt_gai(err: c_int) -> io::Result<()> {\n     if err == 0 { return Ok(()) }\n \n     let detail = unsafe {\n-        str::from_utf8(ffi::c_str_to_bytes(&c::gai_strerror(err))).unwrap()\n+        str::from_utf8(CStr::from_ptr(c::gai_strerror(err)).to_bytes()).unwrap()\n             .to_string()\n     };\n     Err(io::Error::new(io::ErrorKind::Other,"}, {"sha": "ad56555997ff8237f17f7f2f08d3ccf2a4b465be", "filename": "src/libstd/sys/unix/os.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/f3657170b1cbe80393d9ccde8608872f7bdc68f2/src%2Flibstd%2Fsys%2Funix%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3657170b1cbe80393d9ccde8608872f7bdc68f2/src%2Flibstd%2Fsys%2Funix%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fos.rs?ref=f3657170b1cbe80393d9ccde8608872f7bdc68f2", "patch": "@@ -14,7 +14,7 @@ use prelude::v1::*;\n use os::unix::*;\n \n use error::Error as StdError;\n-use ffi::{self, CString, OsString, OsStr, AsOsStr};\n+use ffi::{CString, CStr, OsString, OsStr, AsOsStr};\n use fmt;\n use iter;\n use libc::{self, c_int, c_char, c_void};\n@@ -88,7 +88,7 @@ pub fn error_string(errno: i32) -> String {\n         }\n \n         let p = p as *const _;\n-        str::from_utf8(ffi::c_str_to_bytes(&p)).unwrap().to_string()\n+        str::from_utf8(CStr::from_ptr(p).to_bytes()).unwrap().to_string()\n     }\n }\n \n@@ -98,13 +98,13 @@ pub fn getcwd() -> IoResult<Path> {\n         if libc::getcwd(buf.as_mut_ptr(), buf.len() as libc::size_t).is_null() {\n             Err(IoError::last_error())\n         } else {\n-            Ok(Path::new(ffi::c_str_to_bytes(&buf.as_ptr())))\n+            Ok(Path::new(CStr::from_ptr(buf.as_ptr()).to_bytes()))\n         }\n     }\n }\n \n pub fn chdir(p: &Path) -> IoResult<()> {\n-    let p = CString::from_slice(p.as_vec());\n+    let p = CString::new(p.as_vec()).unwrap();\n     unsafe {\n         match libc::chdir(p.as_ptr()) == (0 as c_int) {\n             true => Ok(()),\n@@ -211,7 +211,7 @@ pub fn current_exe() -> IoResult<Path> {\n         if v.is_null() {\n             Err(IoError::last_error())\n         } else {\n-            Ok(Path::new(ffi::c_str_to_bytes(&v).to_vec()))\n+            Ok(Path::new(CStr::from_ptr(&v).to_bytes().to_vec()))\n         }\n     }\n }\n@@ -266,7 +266,7 @@ pub fn args() -> Args {\n         let (argc, argv) = (*_NSGetArgc() as isize,\n                             *_NSGetArgv() as *const *const c_char);\n         range(0, argc as isize).map(|i| {\n-            let bytes = ffi::c_str_to_bytes(&*argv.offset(i)).to_vec();\n+            let bytes = CStr::from_ptr(&*argv.offset(i)).to_bytes().to_vec();\n             OsStringExt::from_vec(bytes)\n         }).collect::<Vec<_>>()\n     };\n@@ -324,7 +324,7 @@ pub fn args() -> Args {\n             let tmp = objc_msgSend(args, object_at_sel, i);\n             let utf_c_str: *const libc::c_char =\n                 mem::transmute(objc_msgSend(tmp, utf8_sel));\n-            let bytes = ffi::c_str_to_bytes(&utf_c_str);\n+            let bytes = CStr::from_ptr(utf_c_str).to_bytes();\n             res.push(OsString::from_str(str::from_utf8(bytes).unwrap()))\n         }\n     }\n@@ -380,7 +380,7 @@ pub fn env() -> Env {\n         }\n         let mut result = Vec::new();\n         while *environ != ptr::null() {\n-            result.push(parse(ffi::c_str_to_bytes(&*environ)));\n+            result.push(parse(CStr::from_ptr(*environ).to_bytes()));\n             environ = environ.offset(1);\n         }\n         Env { iter: result.into_iter(), _dont_send_or_sync_me: 0 as *mut _ }\n@@ -397,20 +397,20 @@ pub fn env() -> Env {\n \n pub fn getenv(k: &OsStr) -> Option<OsString> {\n     unsafe {\n-        let s = CString::from_slice(k.as_bytes());\n+        let s = k.to_cstring().unwrap();\n         let s = libc::getenv(s.as_ptr()) as *const _;\n         if s.is_null() {\n             None\n         } else {\n-            Some(OsStringExt::from_vec(ffi::c_str_to_bytes(&s).to_vec()))\n+            Some(OsStringExt::from_vec(CStr::from_ptr(s).to_bytes().to_vec()))\n         }\n     }\n }\n \n pub fn setenv(k: &OsStr, v: &OsStr) {\n     unsafe {\n-        let k = CString::from_slice(k.as_bytes());\n-        let v = CString::from_slice(v.as_bytes());\n+        let k = k.to_cstring().unwrap();\n+        let v = v.to_cstring().unwrap();\n         if libc::funcs::posix01::unistd::setenv(k.as_ptr(), v.as_ptr(), 1) != 0 {\n             panic!(\"failed setenv: {}\", IoError::last_error());\n         }\n@@ -419,7 +419,7 @@ pub fn setenv(k: &OsStr, v: &OsStr) {\n \n pub fn unsetenv(n: &OsStr) {\n     unsafe {\n-        let nbuf = CString::from_slice(n.as_bytes());\n+        let nbuf = n.to_cstring().unwrap();\n         if libc::funcs::posix01::unistd::unsetenv(nbuf.as_ptr()) != 0 {\n             panic!(\"failed unsetenv: {}\", IoError::last_error());\n         }\n@@ -480,7 +480,7 @@ pub fn home_dir() -> Option<Path> {\n                 _ => return None\n             }\n             let ptr = passwd.pw_dir as *const _;\n-            let bytes = ffi::c_str_to_bytes(&ptr).to_vec();\n+            let bytes = CStr::from_ptr(ptr).to_bytes().to_vec();\n             return Some(OsStringExt::from_vec(bytes))\n         }\n     }"}, {"sha": "3c9cdc65975f6f9f5e1b7027774b2a7dd0fa564f", "filename": "src/libstd/sys/unix/pipe.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f3657170b1cbe80393d9ccde8608872f7bdc68f2/src%2Flibstd%2Fsys%2Funix%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3657170b1cbe80393d9ccde8608872f7bdc68f2/src%2Flibstd%2Fsys%2Funix%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fpipe.rs?ref=f3657170b1cbe80393d9ccde8608872f7bdc68f2", "patch": "@@ -38,7 +38,7 @@ fn addr_to_sockaddr_un(addr: &CString,\n             mem::size_of::<libc::sockaddr_un>());\n     let s = unsafe { &mut *(storage as *mut _ as *mut libc::sockaddr_un) };\n \n-    let len = addr.len();\n+    let len = addr.as_bytes().len();\n     if len > s.sun_path.len() - 1 {\n         return Err(IoError {\n             kind: old_io::InvalidInput,\n@@ -47,8 +47,8 @@ fn addr_to_sockaddr_un(addr: &CString,\n         })\n     }\n     s.sun_family = libc::AF_UNIX as libc::sa_family_t;\n-    for (slot, value) in s.sun_path.iter_mut().zip(addr.iter()) {\n-        *slot = *value;\n+    for (slot, value) in s.sun_path.iter_mut().zip(addr.as_bytes().iter()) {\n+        *slot = *value as libc::c_char;\n     }\n \n     // count the null terminator"}, {"sha": "06fa5c4bba7253d66f4a3b45c00a6e3097168b8f", "filename": "src/libstd/sys/unix/process2.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f3657170b1cbe80393d9ccde8608872f7bdc68f2/src%2Flibstd%2Fsys%2Funix%2Fprocess2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3657170b1cbe80393d9ccde8608872f7bdc68f2/src%2Flibstd%2Fsys%2Funix%2Fprocess2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fprocess2.rs?ref=f3657170b1cbe80393d9ccde8608872f7bdc68f2", "patch": "@@ -45,7 +45,7 @@ pub struct Command {\n impl Command {\n     pub fn new(program: &OsStr) -> Command {\n         Command {\n-            program: program.to_cstring(),\n+            program: program.to_cstring().unwrap(),\n             args: Vec::new(),\n             env: None,\n             cwd: None,\n@@ -56,10 +56,10 @@ impl Command {\n     }\n \n     pub fn arg(&mut self, arg: &OsStr) {\n-        self.args.push(arg.to_cstring())\n+        self.args.push(arg.to_cstring().unwrap())\n     }\n     pub fn args<'a, I: Iterator<Item = &'a OsStr>>(&mut self, args: I) {\n-        self.args.extend(args.map(OsStrExt::to_cstring))\n+        self.args.extend(args.map(|s| OsStrExt::to_cstring(s).unwrap()))\n     }\n     fn init_env_map(&mut self) {\n         if self.env.is_none() {\n@@ -78,7 +78,7 @@ impl Command {\n         self.env = Some(HashMap::new())\n     }\n     pub fn cwd(&mut self, dir: &OsStr) {\n-        self.cwd = Some(dir.to_cstring())\n+        self.cwd = Some(dir.to_cstring().unwrap())\n     }\n }\n "}, {"sha": "c90ba7645feb4b29f14a6b6854804c6d79d617e9", "filename": "src/libstd/sys/unix/thread.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f3657170b1cbe80393d9ccde8608872f7bdc68f2/src%2Flibstd%2Fsys%2Funix%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3657170b1cbe80393d9ccde8608872f7bdc68f2/src%2Flibstd%2Fsys%2Funix%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fthread.rs?ref=f3657170b1cbe80393d9ccde8608872f7bdc68f2", "patch": "@@ -237,7 +237,7 @@ pub unsafe fn create(stack: uint, p: Thunk) -> io::Result<rust_thread> {\n pub unsafe fn set_name(name: &str) {\n     // pthread_setname_np() since glibc 2.12\n     // availability autodetected via weak linkage\n-    let cname = CString::from_slice(name.as_bytes());\n+    let cname = CString::new(name).unwrap();\n     type F = unsafe extern \"C\" fn(libc::pthread_t, *const libc::c_char) -> libc::c_int;\n     extern {\n         #[linkage = \"extern_weak\"]\n@@ -255,14 +255,14 @@ pub unsafe fn set_name(name: &str) {\n           target_os = \"openbsd\"))]\n pub unsafe fn set_name(name: &str) {\n     // pthread_set_name_np() since almost forever on all BSDs\n-    let cname = CString::from_slice(name.as_bytes());\n+    let cname = CString::new(name).unwrap();\n     pthread_set_name_np(pthread_self(), cname.as_ptr());\n }\n \n #[cfg(any(target_os = \"macos\", target_os = \"ios\"))]\n pub unsafe fn set_name(name: &str) {\n     // pthread_setname_np() since OS X 10.6 and iOS 3.2\n-    let cname = CString::from_slice(name.as_bytes());\n+    let cname = CString::new(name).unwrap();\n     pthread_setname_np(cname.as_ptr());\n }\n "}, {"sha": "b7a758a00d55da65217655ec0499ef20cfd3b982", "filename": "src/libsyntax/diagnostic.rs", "status": "modified", "additions": 19, "deletions": 16, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/f3657170b1cbe80393d9ccde8608872f7bdc68f2/src%2Flibsyntax%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3657170b1cbe80393d9ccde8608872f7bdc68f2/src%2Flibsyntax%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic.rs?ref=f3657170b1cbe80393d9ccde8608872f7bdc68f2", "patch": "@@ -618,22 +618,25 @@ fn print_macro_backtrace(w: &mut EmitterWriter,\n                          cm: &codemap::CodeMap,\n                          sp: Span)\n                          -> old_io::IoResult<()> {\n-    let cs = try!(cm.with_expn_info(sp.expn_id, |expn_info| match expn_info {\n-        Some(ei) => {\n-            let ss = ei.callee.span.map_or(String::new(), |span| cm.span_to_string(span));\n-            let (pre, post) = match ei.callee.format {\n-                codemap::MacroAttribute => (\"#[\", \"]\"),\n-                codemap::MacroBang => (\"\", \"!\")\n-            };\n-            try!(print_diagnostic(w, &ss[], Note,\n-                                  &format!(\"in expansion of {}{}{}\", pre,\n-                                          ei.callee.name,\n-                                          post)[], None));\n-            let ss = cm.span_to_string(ei.call_site);\n-            try!(print_diagnostic(w, &ss[], Note, \"expansion site\", None));\n-            Ok(Some(ei.call_site))\n-        }\n-        None => Ok(None)\n+    let cs = try!(cm.with_expn_info(sp.expn_id, |expn_info| -> old_io::IoResult<_> {\n+        match expn_info {\n+            Some(ei) => {\n+                let ss = ei.callee.span.map_or(String::new(),\n+                                               |span| cm.span_to_string(span));\n+                let (pre, post) = match ei.callee.format {\n+                    codemap::MacroAttribute => (\"#[\", \"]\"),\n+                    codemap::MacroBang => (\"\", \"!\")\n+                };\n+                try!(print_diagnostic(w, &ss[], Note,\n+                                      &format!(\"in expansion of {}{}{}\", pre,\n+                                              ei.callee.name,\n+                                              post)[], None));\n+                let ss = cm.span_to_string(ei.call_site);\n+                try!(print_diagnostic(w, &ss[], Note, \"expansion site\", None));\n+                Ok(Some(ei.call_site))\n+            }\n+            None => Ok(None)\n+    }\n     }));\n     cs.map_or(Ok(()), |call_site| print_macro_backtrace(w, cm, call_site))\n }"}, {"sha": "d18a3055b9c814662c8f08aa9e5328731ef99b31", "filename": "src/test/run-pass/c-stack-returning-int64.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f3657170b1cbe80393d9ccde8608872f7bdc68f2/src%2Ftest%2Frun-pass%2Fc-stack-returning-int64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3657170b1cbe80393d9ccde8608872f7bdc68f2/src%2Ftest%2Frun-pass%2Fc-stack-returning-int64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fc-stack-returning-int64.rs?ref=f3657170b1cbe80393d9ccde8608872f7bdc68f2", "patch": "@@ -24,12 +24,12 @@ mod mlibc {\n }\n \n fn atol(s: String) -> int {\n-    let c = CString::from_slice(s.as_bytes());\n+    let c = CString::from_slice(s.as_bytes()).unwrap();\n     unsafe { mlibc::atol(c.as_ptr()) as int }\n }\n \n fn atoll(s: String) -> i64 {\n-    let c = CString::from_slice(s.as_bytes());\n+    let c = CString::from_slice(s.as_bytes()).unwrap();\n     unsafe { mlibc::atoll(c.as_ptr()) as i64 }\n }\n "}, {"sha": "25d0cbbcdb6d3a4772a95daa9d9308f6f14b4eb7", "filename": "src/test/run-pass/foreign-fn-linkname.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f3657170b1cbe80393d9ccde8608872f7bdc68f2/src%2Ftest%2Frun-pass%2Fforeign-fn-linkname.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3657170b1cbe80393d9ccde8608872f7bdc68f2/src%2Ftest%2Frun-pass%2Fforeign-fn-linkname.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fforeign-fn-linkname.rs?ref=f3657170b1cbe80393d9ccde8608872f7bdc68f2", "patch": "@@ -24,7 +24,7 @@ mod mlibc {\n \n fn strlen(str: String) -> uint {\n     // C string is terminated with a zero\n-    let s = CString::from_slice(str.as_bytes());\n+    let s = CString::from_slice(str.as_bytes()).unwrap();\n     unsafe {\n         mlibc::my_strlen(s.as_ptr()) as uint\n     }"}, {"sha": "1282720d4cb3686b10773b998c9ada7ff3198dda", "filename": "src/test/run-pass/rename-directory.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f3657170b1cbe80393d9ccde8608872f7bdc68f2/src%2Ftest%2Frun-pass%2Frename-directory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3657170b1cbe80393d9ccde8608872f7bdc68f2/src%2Ftest%2Frun-pass%2Frename-directory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frename-directory.rs?ref=f3657170b1cbe80393d9ccde8608872f7bdc68f2", "patch": "@@ -31,12 +31,12 @@ fn rename_directory() {\n         let test_file = &old_path.join(\"temp.txt\");\n \n         /* Write the temp input file */\n-        let fromp = CString::from_slice(test_file.as_vec());\n-        let modebuf = CString::from_slice(b\"w+b\");\n+        let fromp = CString::from_slice(test_file.as_vec()).unwrap();\n+        let modebuf = CString::from_slice(b\"w+b\").unwrap();\n         let ostream = libc::fopen(fromp.as_ptr(), modebuf.as_ptr());\n         assert!((ostream as uint != 0u));\n         let s = \"hello\".to_string();\n-        let buf = CString::from_slice(b\"hello\");\n+        let buf = CString::from_slice(b\"hello\").unwrap();\n         let write_len = libc::fwrite(buf.as_ptr() as *mut _,\n                                      1u as libc::size_t,\n                                      (s.len() + 1u) as libc::size_t,"}, {"sha": "85f6ef0ddcd1bcd5e63c7c1059793d4e0e4e926c", "filename": "src/test/run-pass/variadic-ffi.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f3657170b1cbe80393d9ccde8608872f7bdc68f2/src%2Ftest%2Frun-pass%2Fvariadic-ffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3657170b1cbe80393d9ccde8608872f7bdc68f2/src%2Ftest%2Frun-pass%2Fvariadic-ffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fvariadic-ffi.rs?ref=f3657170b1cbe80393d9ccde8608872f7bdc68f2", "patch": "@@ -29,11 +29,11 @@ pub fn main() {\n \n     unsafe {\n         // Call with just the named parameter\n-        let c = CString::from_slice(b\"Hello World\\n\");\n+        let c = CString::from_slice(b\"Hello World\\n\").unwrap();\n         check(\"Hello World\\n\", |s| sprintf(s, c.as_ptr()));\n \n         // Call with variable number of arguments\n-        let c = CString::from_slice(b\"%d %f %c %s\\n\");\n+        let c = CString::from_slice(b\"%d %f %c %s\\n\").unwrap();\n         check(\"42 42.500000 a %d %f %c %s\\n\\n\", |s| {\n             sprintf(s, c.as_ptr(), 42, 42.5f64, 'a' as c_int, c.as_ptr());\n         });\n@@ -44,11 +44,11 @@ pub fn main() {\n         // A function that takes a function pointer\n         unsafe fn call(p: unsafe extern fn(*mut c_char, *const c_char, ...) -> c_int) {\n             // Call with just the named parameter\n-            let c = CString::from_slice(b\"Hello World\\n\");\n+            let c = CString::from_slice(b\"Hello World\\n\").unwrap();\n             check(\"Hello World\\n\", |s| sprintf(s, c.as_ptr()));\n \n             // Call with variable number of arguments\n-            let c = CString::from_slice(b\"%d %f %c %s\\n\");\n+            let c = CString::from_slice(b\"%d %f %c %s\\n\").unwrap();\n             check(\"42 42.500000 a %d %f %c %s\\n\\n\", |s| {\n                 sprintf(s, c.as_ptr(), 42, 42.5f64, 'a' as c_int, c.as_ptr());\n             });"}]}