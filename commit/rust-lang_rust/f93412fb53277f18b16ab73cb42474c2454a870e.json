{"sha": "f93412fb53277f18b16ab73cb42474c2454a870e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY5MzQxMmZiNTMyNzdmMThiMTZhYjczY2I0MjQ3NGMyNDU0YTg3MGU=", "commit": {"author": {"name": "Yuki Okushi", "email": "jtitor@2k36.org", "date": "2021-04-05T21:24:15Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-04-05T21:24:15Z"}, "message": "Rollup merge of #83849 - jyn514:intra-doc-cleanup, r=bugadani\n\nrustdoc: Cleanup handling of associated items for intra-doc links\n\nHelps with https://github.com/rust-lang/rust/issues/83761 (right now the uses of the resolver are all intermingled with uses of the tyctxt). Best reviewed one commit at a time.\n\nr? ```@bugadani``` maybe? Feel free to reassign :)", "tree": {"sha": "dec9be51844fefc982e4d8dae8616b0b69a32f5c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dec9be51844fefc982e4d8dae8616b0b69a32f5c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f93412fb53277f18b16ab73cb42474c2454a870e", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJga3//CRBK7hj4Ov3rIwAAdHIIACXaevPkQ5g94jHh26gz0xkk\n2b8OuFGOZYDpRUFKCH6ETdTUcHTaFCd+EH1IyabOKWfyG5XxrFiNbOs6UvBrTvlt\nYWVlCbJCrSfhGHjBw1RbkXcuI1b8fBuOHk1Du9/CIA9v4hYSP4oAG5h0Ls6pH7bF\nLNGM+cvvbeYrD8BXEYNV1cfoCnIdjnjuqKwmORQZLhX5G2RjunXSwtoNe84PLAPq\naXa0w08TsSP9/RbKi/DCLQENVFsQiN/blxn1lj5JG40ezgBmsU1eYPDs2+ZQJP7X\nAItqvP1GZON11urFYjIXF4K1V2MksKm7riZeRCALcaUMMwZyQ8UXUqxc7oOAqbc=\n=pMqC\n-----END PGP SIGNATURE-----\n", "payload": "tree dec9be51844fefc982e4d8dae8616b0b69a32f5c\nparent 12d007da0f6620c8a10448cf5be762ffbb94ffd8\nparent 3b7e654fad80e91064b26416a4334cd3e984a6ce\nauthor Yuki Okushi <jtitor@2k36.org> 1617657855 +0900\ncommitter GitHub <noreply@github.com> 1617657855 +0900\n\nRollup merge of #83849 - jyn514:intra-doc-cleanup, r=bugadani\n\nrustdoc: Cleanup handling of associated items for intra-doc links\n\nHelps with https://github.com/rust-lang/rust/issues/83761 (right now the uses of the resolver are all intermingled with uses of the tyctxt). Best reviewed one commit at a time.\n\nr? ```@bugadani``` maybe? Feel free to reassign :)\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f93412fb53277f18b16ab73cb42474c2454a870e", "html_url": "https://github.com/rust-lang/rust/commit/f93412fb53277f18b16ab73cb42474c2454a870e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f93412fb53277f18b16ab73cb42474c2454a870e/comments", "author": {"login": "JohnTitor", "id": 25030997, "node_id": "MDQ6VXNlcjI1MDMwOTk3", "avatar_url": "https://avatars.githubusercontent.com/u/25030997?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JohnTitor", "html_url": "https://github.com/JohnTitor", "followers_url": "https://api.github.com/users/JohnTitor/followers", "following_url": "https://api.github.com/users/JohnTitor/following{/other_user}", "gists_url": "https://api.github.com/users/JohnTitor/gists{/gist_id}", "starred_url": "https://api.github.com/users/JohnTitor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JohnTitor/subscriptions", "organizations_url": "https://api.github.com/users/JohnTitor/orgs", "repos_url": "https://api.github.com/users/JohnTitor/repos", "events_url": "https://api.github.com/users/JohnTitor/events{/privacy}", "received_events_url": "https://api.github.com/users/JohnTitor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "12d007da0f6620c8a10448cf5be762ffbb94ffd8", "url": "https://api.github.com/repos/rust-lang/rust/commits/12d007da0f6620c8a10448cf5be762ffbb94ffd8", "html_url": "https://github.com/rust-lang/rust/commit/12d007da0f6620c8a10448cf5be762ffbb94ffd8"}, {"sha": "3b7e654fad80e91064b26416a4334cd3e984a6ce", "url": "https://api.github.com/repos/rust-lang/rust/commits/3b7e654fad80e91064b26416a4334cd3e984a6ce", "html_url": "https://github.com/rust-lang/rust/commit/3b7e654fad80e91064b26416a4334cd3e984a6ce"}], "stats": {"total": 299, "additions": 149, "deletions": 150}, "files": [{"sha": "1c5f8996e1b454ecf419ab27f9f315c67a26470e", "filename": "compiler/rustc_resolve/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f93412fb53277f18b16ab73cb42474c2454a870e/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f93412fb53277f18b16ab73cb42474c2454a870e/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flib.rs?ref=f93412fb53277f18b16ab73cb42474c2454a870e", "patch": "@@ -18,6 +18,7 @@\n #![feature(nll)]\n #![cfg_attr(bootstrap, feature(or_patterns))]\n #![recursion_limit = \"256\"]\n+#![allow(rustdoc::private_intra_doc_links)]\n \n pub use rustc_hir::def::{Namespace, PerNS};\n "}, {"sha": "39912a136ab2213e470394b22f8e3ef9a6c39009", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 102, "deletions": 135, "changes": 237, "blob_url": "https://github.com/rust-lang/rust/blob/f93412fb53277f18b16ab73cb42474c2454a870e/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f93412fb53277f18b16ab73cb42474c2454a870e/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=f93412fb53277f18b16ab73cb42474c2454a870e", "patch": "@@ -368,55 +368,28 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n     }\n \n     /// Given a primitive type, try to resolve an associated item.\n-    ///\n-    /// HACK(jynelson): `item_str` is passed in instead of derived from `item_name` so the\n-    /// lifetimes on `&'path` will work.\n     fn resolve_primitive_associated_item(\n         &self,\n         prim_ty: PrimitiveType,\n         ns: Namespace,\n-        module_id: DefId,\n         item_name: Symbol,\n-        item_str: &'path str,\n-    ) -> Result<(Res, Option<String>), ErrorKind<'path>> {\n+    ) -> Option<(Res, String, Option<(DefKind, DefId)>)> {\n         let tcx = self.cx.tcx;\n \n-        prim_ty\n-            .impls(tcx)\n-            .into_iter()\n-            .find_map(|&impl_| {\n-                tcx.associated_items(impl_)\n-                    .find_by_name_and_namespace(tcx, Ident::with_dummy_span(item_name), ns, impl_)\n-                    .map(|item| {\n-                        let kind = item.kind;\n-                        self.kind_side_channel.set(Some((kind.as_def_kind(), item.def_id)));\n-                        match kind {\n-                            ty::AssocKind::Fn => \"method\",\n-                            ty::AssocKind::Const => \"associatedconstant\",\n-                            ty::AssocKind::Type => \"associatedtype\",\n-                        }\n-                    })\n-                    .map(|out| {\n-                        (\n-                            Res::Primitive(prim_ty),\n-                            Some(format!(\"{}#{}.{}\", prim_ty.as_str(), out, item_str)),\n-                        )\n-                    })\n-            })\n-            .ok_or_else(|| {\n-                debug!(\n-                    \"returning primitive error for {}::{} in {} namespace\",\n-                    prim_ty.as_str(),\n-                    item_name,\n-                    ns.descr()\n-                );\n-                ResolutionFailure::NotResolved {\n-                    module_id,\n-                    partial_res: Some(Res::Primitive(prim_ty)),\n-                    unresolved: item_str.into(),\n-                }\n-                .into()\n-            })\n+        prim_ty.impls(tcx).into_iter().find_map(|&impl_| {\n+            tcx.associated_items(impl_)\n+                .find_by_name_and_namespace(tcx, Ident::with_dummy_span(item_name), ns, impl_)\n+                .map(|item| {\n+                    let kind = item.kind;\n+                    let out = match kind {\n+                        ty::AssocKind::Fn => \"method\",\n+                        ty::AssocKind::Const => \"associatedconstant\",\n+                        ty::AssocKind::Type => \"associatedtype\",\n+                    };\n+                    let fragment = format!(\"{}#{}.{}\", prim_ty.as_str(), out, item_name);\n+                    (Res::Primitive(prim_ty), fragment, Some((kind.as_def_kind(), item.def_id)))\n+                })\n+        })\n     }\n \n     /// Resolves a string as a macro.\n@@ -490,8 +463,6 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n         module_id: DefId,\n         extra_fragment: &Option<String>,\n     ) -> Result<(Res, Option<String>), ErrorKind<'path>> {\n-        let tcx = self.cx.tcx;\n-\n         if let Some(res) = self.resolve_path(path_str, ns, module_id) {\n             match res {\n                 // FIXME(#76467): make this fallthrough to lookup the associated\n@@ -534,29 +505,58 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                 }\n             })?;\n \n-        // FIXME: are these both necessary?\n-        let ty_res = if let Some(ty_res) = resolve_primitive(&path_root, TypeNS)\n+        // FIXME(#83862): this arbitrarily gives precedence to primitives over modules to support\n+        // links to primitives when `#[doc(primitive)]` is present. It should give an ambiguity\n+        // error instead and special case *only* modules with `#[doc(primitive)]`, not all\n+        // primitives.\n+        resolve_primitive(&path_root, TypeNS)\n             .or_else(|| self.resolve_path(&path_root, TypeNS, module_id))\n-        {\n-            ty_res\n-        } else {\n-            // FIXME: this is duplicated on the end of this function.\n-            return if ns == Namespace::ValueNS {\n-                self.variant_field(path_str, module_id)\n-            } else {\n-                Err(ResolutionFailure::NotResolved {\n-                    module_id,\n-                    partial_res: None,\n-                    unresolved: path_root.into(),\n+            .and_then(|ty_res| {\n+                let (res, fragment, side_channel) =\n+                    self.resolve_associated_item(ty_res, item_name, ns, module_id)?;\n+                let result = if extra_fragment.is_some() {\n+                    let diag_res = side_channel.map_or(res, |(k, r)| Res::Def(k, r));\n+                    Err(ErrorKind::AnchorFailure(AnchorFailure::RustdocAnchorConflict(diag_res)))\n+                } else {\n+                    // HACK(jynelson): `clean` expects the type, not the associated item\n+                    // but the disambiguator logic expects the associated item.\n+                    // Store the kind in a side channel so that only the disambiguator logic looks at it.\n+                    if let Some((kind, id)) = side_channel {\n+                        self.kind_side_channel.set(Some((kind, id)));\n+                    }\n+                    Ok((res, Some(fragment)))\n+                };\n+                Some(result)\n+            })\n+            .unwrap_or_else(|| {\n+                if ns == Namespace::ValueNS {\n+                    self.variant_field(path_str, module_id)\n+                } else {\n+                    Err(ResolutionFailure::NotResolved {\n+                        module_id,\n+                        partial_res: None,\n+                        unresolved: path_root.into(),\n+                    }\n+                    .into())\n                 }\n-                .into())\n-            };\n-        };\n+            })\n+    }\n+\n+    /// Returns:\n+    /// - None if no associated item was found\n+    /// - Some((_, _, Some(_))) if an item was found and should go through a side channel\n+    /// - Some((_, _, None)) otherwise\n+    fn resolve_associated_item(\n+        &mut self,\n+        root_res: Res,\n+        item_name: Symbol,\n+        ns: Namespace,\n+        module_id: DefId,\n+    ) -> Option<(Res, String, Option<(DefKind, DefId)>)> {\n+        let tcx = self.cx.tcx;\n \n-        let res = match ty_res {\n-            Res::Primitive(prim) => Some(\n-                self.resolve_primitive_associated_item(prim, ns, module_id, item_name, item_str),\n-            ),\n+        match root_res {\n+            Res::Primitive(prim) => self.resolve_primitive_associated_item(prim, ns, item_name),\n             Res::Def(\n                 DefKind::Struct\n                 | DefKind::Union\n@@ -599,59 +599,42 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                         ty::AssocKind::Const => \"associatedconstant\",\n                         ty::AssocKind::Type => \"associatedtype\",\n                     };\n-                    Some(if extra_fragment.is_some() {\n-                        Err(ErrorKind::AnchorFailure(AnchorFailure::RustdocAnchorConflict(ty_res)))\n-                    } else {\n-                        // HACK(jynelson): `clean` expects the type, not the associated item\n-                        // but the disambiguator logic expects the associated item.\n-                        // Store the kind in a side channel so that only the disambiguator logic looks at it.\n-                        self.kind_side_channel.set(Some((kind.as_def_kind(), id)));\n-                        Ok((ty_res, Some(format!(\"{}.{}\", out, item_str))))\n-                    })\n-                } else if ns == Namespace::ValueNS {\n-                    debug!(\"looking for variants or fields named {} for {:?}\", item_name, did);\n-                    // FIXME(jynelson): why is this different from\n-                    // `variant_field`?\n-                    match tcx.type_of(did).kind() {\n-                        ty::Adt(def, _) => {\n-                            let field = if def.is_enum() {\n-                                def.all_fields().find(|item| item.ident.name == item_name)\n-                            } else {\n-                                def.non_enum_variant()\n-                                    .fields\n-                                    .iter()\n-                                    .find(|item| item.ident.name == item_name)\n-                            };\n-                            field.map(|item| {\n-                                if extra_fragment.is_some() {\n-                                    let res = Res::Def(\n-                                        if def.is_enum() {\n-                                            DefKind::Variant\n-                                        } else {\n-                                            DefKind::Field\n-                                        },\n-                                        item.did,\n-                                    );\n-                                    Err(ErrorKind::AnchorFailure(\n-                                        AnchorFailure::RustdocAnchorConflict(res),\n-                                    ))\n-                                } else {\n-                                    Ok((\n-                                        ty_res,\n-                                        Some(format!(\n-                                            \"{}.{}\",\n-                                            if def.is_enum() { \"variant\" } else { \"structfield\" },\n-                                            item.ident\n-                                        )),\n-                                    ))\n-                                }\n-                            })\n-                        }\n-                        _ => None,\n-                    }\n-                } else {\n-                    None\n+                    // HACK(jynelson): `clean` expects the type, not the associated item\n+                    // but the disambiguator logic expects the associated item.\n+                    // Store the kind in a side channel so that only the disambiguator logic looks at it.\n+                    return Some((\n+                        root_res,\n+                        format!(\"{}.{}\", out, item_name),\n+                        Some((kind.as_def_kind(), id)),\n+                    ));\n+                }\n+\n+                if ns != Namespace::ValueNS {\n+                    return None;\n                 }\n+                debug!(\"looking for variants or fields named {} for {:?}\", item_name, did);\n+                // FIXME: this doesn't really belong in `associated_item` (maybe `variant_field` is better?)\n+                // NOTE: it's different from variant_field because it resolves fields and variants,\n+                // not variant fields (2 path segments, not 3).\n+                let def = match tcx.type_of(did).kind() {\n+                    ty::Adt(def, _) => def,\n+                    _ => return None,\n+                };\n+                let field = if def.is_enum() {\n+                    def.all_fields().find(|item| item.ident.name == item_name)\n+                } else {\n+                    def.non_enum_variant().fields.iter().find(|item| item.ident.name == item_name)\n+                }?;\n+                let kind = if def.is_enum() { DefKind::Variant } else { DefKind::Field };\n+                Some((\n+                    root_res,\n+                    format!(\n+                        \"{}.{}\",\n+                        if def.is_enum() { \"variant\" } else { \"structfield\" },\n+                        field.ident\n+                    ),\n+                    Some((kind, field.did)),\n+                ))\n             }\n             Res::Def(DefKind::Trait, did) => tcx\n                 .associated_items(did)\n@@ -669,27 +652,11 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                         }\n                     };\n \n-                    if extra_fragment.is_some() {\n-                        Err(ErrorKind::AnchorFailure(AnchorFailure::RustdocAnchorConflict(ty_res)))\n-                    } else {\n-                        let res = Res::Def(item.kind.as_def_kind(), item.def_id);\n-                        Ok((res, Some(format!(\"{}.{}\", kind, item_str))))\n-                    }\n+                    let res = Res::Def(item.kind.as_def_kind(), item.def_id);\n+                    (res, format!(\"{}.{}\", kind, item_name), None)\n                 }),\n             _ => None,\n-        };\n-        res.unwrap_or_else(|| {\n-            if ns == Namespace::ValueNS {\n-                self.variant_field(path_str, module_id)\n-            } else {\n-                Err(ResolutionFailure::NotResolved {\n-                    module_id,\n-                    partial_res: Some(ty_res),\n-                    unresolved: item_str.into(),\n-                }\n-                .into())\n-            }\n-        })\n+        }\n     }\n \n     /// Used for reporting better errors."}, {"sha": "392321f9c60db4a72557f146adf8a2ae3381014c", "filename": "src/test/rustdoc-ui/intra-doc/private.private.stderr", "status": "modified", "additions": 13, "deletions": 5, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/f93412fb53277f18b16ab73cb42474c2454a870e/src%2Ftest%2Frustdoc-ui%2Fintra-doc%2Fprivate.private.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f93412fb53277f18b16ab73cb42474c2454a870e/src%2Ftest%2Frustdoc-ui%2Fintra-doc%2Fprivate.private.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fintra-doc%2Fprivate.private.stderr?ref=f93412fb53277f18b16ab73cb42474c2454a870e", "patch": "@@ -1,19 +1,27 @@\n warning: public documentation for `DocMe` links to private item `DontDocMe`\n-  --> $DIR/private.rs:5:11\n+  --> $DIR/private.rs:7:11\n    |\n-LL | /// docs [DontDocMe] [DontDocMe::f]\n+LL | /// docs [DontDocMe] [DontDocMe::f] [DontDocMe::x]\n    |           ^^^^^^^^^ this item is private\n    |\n    = note: `#[warn(rustdoc::private_intra_doc_links)]` on by default\n    = note: this link resolves only because you passed `--document-private-items`, but will break without\n \n warning: public documentation for `DocMe` links to private item `DontDocMe::f`\n-  --> $DIR/private.rs:5:23\n+  --> $DIR/private.rs:7:23\n    |\n-LL | /// docs [DontDocMe] [DontDocMe::f]\n+LL | /// docs [DontDocMe] [DontDocMe::f] [DontDocMe::x]\n    |                       ^^^^^^^^^^^^ this item is private\n    |\n    = note: this link resolves only because you passed `--document-private-items`, but will break without\n \n-warning: 2 warnings emitted\n+warning: public documentation for `DocMe` links to private item `DontDocMe::x`\n+  --> $DIR/private.rs:7:38\n+   |\n+LL | /// docs [DontDocMe] [DontDocMe::f] [DontDocMe::x]\n+   |                                      ^^^^^^^^^^^^ this item is private\n+   |\n+   = note: this link resolves only because you passed `--document-private-items`, but will break without\n+\n+warning: 3 warnings emitted\n "}, {"sha": "5d1c34b9168d9368bf0d643f407716c0abf59947", "filename": "src/test/rustdoc-ui/intra-doc/private.public.stderr", "status": "modified", "additions": 13, "deletions": 5, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/f93412fb53277f18b16ab73cb42474c2454a870e/src%2Ftest%2Frustdoc-ui%2Fintra-doc%2Fprivate.public.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f93412fb53277f18b16ab73cb42474c2454a870e/src%2Ftest%2Frustdoc-ui%2Fintra-doc%2Fprivate.public.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fintra-doc%2Fprivate.public.stderr?ref=f93412fb53277f18b16ab73cb42474c2454a870e", "patch": "@@ -1,19 +1,27 @@\n warning: public documentation for `DocMe` links to private item `DontDocMe`\n-  --> $DIR/private.rs:5:11\n+  --> $DIR/private.rs:7:11\n    |\n-LL | /// docs [DontDocMe] [DontDocMe::f]\n+LL | /// docs [DontDocMe] [DontDocMe::f] [DontDocMe::x]\n    |           ^^^^^^^^^ this item is private\n    |\n    = note: `#[warn(rustdoc::private_intra_doc_links)]` on by default\n    = note: this link will resolve properly if you pass `--document-private-items`\n \n warning: public documentation for `DocMe` links to private item `DontDocMe::f`\n-  --> $DIR/private.rs:5:23\n+  --> $DIR/private.rs:7:23\n    |\n-LL | /// docs [DontDocMe] [DontDocMe::f]\n+LL | /// docs [DontDocMe] [DontDocMe::f] [DontDocMe::x]\n    |                       ^^^^^^^^^^^^ this item is private\n    |\n    = note: this link will resolve properly if you pass `--document-private-items`\n \n-warning: 2 warnings emitted\n+warning: public documentation for `DocMe` links to private item `DontDocMe::x`\n+  --> $DIR/private.rs:7:38\n+   |\n+LL | /// docs [DontDocMe] [DontDocMe::f] [DontDocMe::x]\n+   |                                      ^^^^^^^^^^^^ this item is private\n+   |\n+   = note: this link will resolve properly if you pass `--document-private-items`\n+\n+warning: 3 warnings emitted\n "}, {"sha": "525332ddaac3badc8b9209d5361ee88ba7d6eff8", "filename": "src/test/rustdoc-ui/intra-doc/private.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f93412fb53277f18b16ab73cb42474c2454a870e/src%2Ftest%2Frustdoc-ui%2Fintra-doc%2Fprivate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f93412fb53277f18b16ab73cb42474c2454a870e/src%2Ftest%2Frustdoc-ui%2Fintra-doc%2Fprivate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fintra-doc%2Fprivate.rs?ref=f93412fb53277f18b16ab73cb42474c2454a870e", "patch": "@@ -2,12 +2,16 @@\n // revisions: public private\n // [private]compile-flags: --document-private-items\n \n-/// docs [DontDocMe] [DontDocMe::f]\n+// make sure to update `rustdoc/intra-doc/private.rs` if you update this file\n+\n+/// docs [DontDocMe] [DontDocMe::f] [DontDocMe::x]\n //~^ WARNING public documentation for `DocMe` links to private item `DontDocMe`\n+//~| WARNING public documentation for `DocMe` links to private item `DontDocMe::x`\n //~| WARNING public documentation for `DocMe` links to private item `DontDocMe::f`\n-// FIXME: for [private] we should also make sure the link was actually generated\n pub struct DocMe;\n-struct DontDocMe;\n+struct DontDocMe {\n+    x: usize,\n+}\n \n impl DontDocMe {\n     fn f() {}"}, {"sha": "337102d6ab3fa966d7a32fd362fda42d156234e1", "filename": "src/test/rustdoc/intra-doc/private.rs", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f93412fb53277f18b16ab73cb42474c2454a870e/src%2Ftest%2Frustdoc%2Fintra-doc%2Fprivate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f93412fb53277f18b16ab73cb42474c2454a870e/src%2Ftest%2Frustdoc%2Fintra-doc%2Fprivate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fintra-doc%2Fprivate.rs?ref=f93412fb53277f18b16ab73cb42474c2454a870e", "patch": "@@ -1,6 +1,17 @@\n #![crate_name = \"private\"]\n // compile-flags: --document-private-items\n-/// docs [DontDocMe]\n+\n+// make sure to update `rustdoc-ui/intra-doc/private.rs` if you update this file\n+\n+/// docs [DontDocMe] [DontDocMe::f] [DontDocMe::x]\n // @has private/struct.DocMe.html '//*a[@href=\"../private/struct.DontDocMe.html\"]' 'DontDocMe'\n+// @has private/struct.DocMe.html '//*a[@href=\"../private/struct.DontDocMe.html#method.f\"]' 'DontDocMe::f'\n+// @has private/struct.DocMe.html '//*a[@href=\"../private/struct.DontDocMe.html#structfield.x\"]' 'DontDocMe::x'\n pub struct DocMe;\n-struct DontDocMe;\n+struct DontDocMe {\n+    x: usize,\n+}\n+\n+impl DontDocMe {\n+    fn f() {}\n+}"}]}