{"sha": "69eb996b2617621c7088e567089a86a6657f2a0f", "node_id": "C_kwDOAAsO6NoAKDY5ZWI5OTZiMjYxNzYyMWM3MDg4ZTU2NzA4OWE4NmE2NjU3ZjJhMGY", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-10-01T09:00:42Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-10-01T09:00:42Z"}, "message": "Auto merge of #89417 - Manishearth:rollup-j2gdu95, r=Manishearth\n\nRollup of 7 pull requests\n\nSuccessful merges:\n\n - #88838 (Do not suggest importing inaccessible items)\n - #89251 (Detect when negative literal indices are used and suggest appropriate code)\n - #89321 (Rebase resume argument projections during state transform)\n - #89327 (Pick one possible lifetime in case there are multiple choices)\n - #89344 (Cleanup lower_generics_mut and make span be the bound itself)\n - #89397 (Update `llvm` submodule to fix function name mangling on x86 Windows)\n - #89412 (Add regression test for issues #88969 and #89119 )\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "046d7349cc07e3c5ecec4dc144cb0758555a4336", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/046d7349cc07e3c5ecec4dc144cb0758555a4336"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/69eb996b2617621c7088e567089a86a6657f2a0f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/69eb996b2617621c7088e567089a86a6657f2a0f", "html_url": "https://github.com/rust-lang/rust/commit/69eb996b2617621c7088e567089a86a6657f2a0f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/69eb996b2617621c7088e567089a86a6657f2a0f/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4e4942dfa66667c0addfff8e0882a59b035d45ca", "url": "https://api.github.com/repos/rust-lang/rust/commits/4e4942dfa66667c0addfff8e0882a59b035d45ca", "html_url": "https://github.com/rust-lang/rust/commit/4e4942dfa66667c0addfff8e0882a59b035d45ca"}, {"sha": "4571feac44038752a43cebea632308e61697c3a5", "url": "https://api.github.com/repos/rust-lang/rust/commits/4571feac44038752a43cebea632308e61697c3a5", "html_url": "https://github.com/rust-lang/rust/commit/4571feac44038752a43cebea632308e61697c3a5"}], "stats": {"total": 720, "additions": 560, "deletions": 160}, "files": [{"sha": "ea9eb0cf2742bc54c597a7cf38fd277da836f17c", "filename": "compiler/rustc_ast_lowering/src/item.rs", "status": "modified", "additions": 38, "deletions": 25, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/69eb996b2617621c7088e567089a86a6657f2a0f/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69eb996b2617621c7088e567089a86a6657f2a0f/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs?ref=69eb996b2617621c7088e567089a86a6657f2a0f", "patch": "@@ -1328,32 +1328,45 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         // keep track of the Span info. Now, `add_implicitly_sized` in `AstConv` checks both param bounds and\n         // where clauses for `?Sized`.\n         for pred in &generics.where_clause.predicates {\n-            if let WherePredicate::BoundPredicate(ref bound_pred) = *pred {\n-                'next_bound: for bound in &bound_pred.bounds {\n-                    if let GenericBound::Trait(_, TraitBoundModifier::Maybe) = *bound {\n-                        // Check if the where clause type is a plain type parameter.\n-                        match self\n-                            .resolver\n-                            .get_partial_res(bound_pred.bounded_ty.id)\n-                            .map(|d| (d.base_res(), d.unresolved_segments()))\n-                        {\n-                            Some((Res::Def(DefKind::TyParam, def_id), 0))\n-                                if bound_pred.bound_generic_params.is_empty() =>\n-                            {\n-                                for param in &generics.params {\n-                                    if def_id == self.resolver.local_def_id(param.id).to_def_id() {\n-                                        continue 'next_bound;\n-                                    }\n-                                }\n-                            }\n-                            _ => {}\n-                        }\n-                        self.diagnostic().span_err(\n-                            bound_pred.bounded_ty.span,\n-                            \"`?Trait` bounds are only permitted at the \\\n-                                 point where a type parameter is declared\",\n-                        );\n+            let bound_pred = match *pred {\n+                WherePredicate::BoundPredicate(ref bound_pred) => bound_pred,\n+                _ => continue,\n+            };\n+            let compute_is_param = || {\n+                // Check if the where clause type is a plain type parameter.\n+                match self\n+                    .resolver\n+                    .get_partial_res(bound_pred.bounded_ty.id)\n+                    .map(|d| (d.base_res(), d.unresolved_segments()))\n+                {\n+                    Some((Res::Def(DefKind::TyParam, def_id), 0))\n+                        if bound_pred.bound_generic_params.is_empty() =>\n+                    {\n+                        generics\n+                            .params\n+                            .iter()\n+                            .find(|p| def_id == self.resolver.local_def_id(p.id).to_def_id())\n+                            .is_some()\n                     }\n+                    // Either the `bounded_ty` is not a plain type parameter, or\n+                    // it's not found in the generic type parameters list.\n+                    _ => false,\n+                }\n+            };\n+            // We only need to compute this once per `WherePredicate`, but don't\n+            // need to compute this at all unless there is a Maybe bound.\n+            let mut is_param: Option<bool> = None;\n+            for bound in &bound_pred.bounds {\n+                if !matches!(*bound, GenericBound::Trait(_, TraitBoundModifier::Maybe)) {\n+                    continue;\n+                }\n+                let is_param = *is_param.get_or_insert_with(compute_is_param);\n+                if !is_param {\n+                    self.diagnostic().span_err(\n+                        bound.span(),\n+                        \"`?Trait` bounds are only permitted at the \\\n+                        point where a type parameter is declared\",\n+                    );\n                 }\n             }\n         }"}, {"sha": "245199e37511380a0e1220e6e2f9f54cc46af10f", "filename": "compiler/rustc_ast_lowering/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/69eb996b2617621c7088e567089a86a6657f2a0f/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69eb996b2617621c7088e567089a86a6657f2a0f/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs?ref=69eb996b2617621c7088e567089a86a6657f2a0f", "patch": "@@ -166,7 +166,7 @@ pub trait ResolverAstLowering {\n     fn legacy_const_generic_args(&mut self, expr: &Expr) -> Option<Vec<usize>>;\n \n     /// Obtains resolution for a `NodeId` with a single resolution.\n-    fn get_partial_res(&mut self, id: NodeId) -> Option<PartialRes>;\n+    fn get_partial_res(&self, id: NodeId) -> Option<PartialRes>;\n \n     /// Obtains per-namespace resolutions for `use` statement with the given `NodeId`.\n     fn get_import_res(&mut self, id: NodeId) -> PerNS<Option<Res<NodeId>>>;"}, {"sha": "4eb7be542e7a1b924ee2c1ce07298037756d9a5f", "filename": "compiler/rustc_borrowck/src/region_infer/opaque_types.rs", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/69eb996b2617621c7088e567089a86a6657f2a0f/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69eb996b2617621c7088e567089a86a6657f2a0f/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fopaque_types.rs?ref=69eb996b2617621c7088e567089a86a6657f2a0f", "patch": "@@ -124,7 +124,22 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             ty::ReVar(vid) => {\n                 // Find something that we can name\n                 let upper_bound = self.approx_universal_upper_bound(vid);\n-                self.definitions[upper_bound].external_name.unwrap_or(region)\n+                let upper_bound = &self.definitions[upper_bound];\n+                match upper_bound.external_name {\n+                    Some(reg) => reg,\n+                    None => {\n+                        // Nothing exact found, so we pick the first one that we find.\n+                        let scc = self.constraint_sccs.scc(vid);\n+                        for vid in self.rev_scc_graph.as_ref().unwrap().upper_bounds(scc) {\n+                            match self.definitions[vid].external_name {\n+                                None => {}\n+                                Some(&ty::ReStatic) => {}\n+                                Some(region) => return region,\n+                            }\n+                        }\n+                        region\n+                    }\n+                }\n             }\n             _ => region,\n         })"}, {"sha": "bc72e9d94a95301388fabcc2f773e96795fd017e", "filename": "compiler/rustc_mir_transform/src/generator.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/69eb996b2617621c7088e567089a86a6657f2a0f/compiler%2Frustc_mir_transform%2Fsrc%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69eb996b2617621c7088e567089a86a6657f2a0f/compiler%2Frustc_mir_transform%2Fsrc%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fgenerator.rs?ref=69eb996b2617621c7088e567089a86a6657f2a0f", "patch": "@@ -342,15 +342,16 @@ impl MutVisitor<'tcx> for TransformVisitor<'tcx> {\n             let source_info = data.terminator().source_info;\n             // We must assign the value first in case it gets declared dead below\n             data.statements.extend(self.make_state(state_idx, v, source_info));\n-            let state = if let Some((resume, resume_arg)) = resume {\n+            let state = if let Some((resume, mut resume_arg)) = resume {\n                 // Yield\n                 let state = 3 + self.suspension_points.len();\n \n                 // The resume arg target location might itself be remapped if its base local is\n                 // live across a yield.\n                 let resume_arg =\n                     if let Some(&(ty, variant, idx)) = self.remap.get(&resume_arg.local) {\n-                        self.make_field(variant, idx, ty)\n+                        replace_base(&mut resume_arg, self.make_field(variant, idx, ty), self.tcx);\n+                        resume_arg\n                     } else {\n                         resume_arg\n                     };"}, {"sha": "ab1f47c81db975129f9827786f8d0da7e9c05c62", "filename": "compiler/rustc_resolve/src/diagnostics.rs", "status": "modified", "additions": 109, "deletions": 31, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/69eb996b2617621c7088e567089a86a6657f2a0f/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69eb996b2617621c7088e567089a86a6657f2a0f/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs?ref=69eb996b2617621c7088e567089a86a6657f2a0f", "patch": "@@ -973,7 +973,15 @@ impl<'a> Resolver<'a> {\n \n         let import_suggestions =\n             self.lookup_import_candidates(ident, Namespace::MacroNS, parent_scope, is_expected);\n-        show_candidates(err, None, &import_suggestions, false, true);\n+        show_candidates(\n+            &self.definitions,\n+            self.session,\n+            err,\n+            None,\n+            &import_suggestions,\n+            false,\n+            true,\n+        );\n \n         if macro_kind == MacroKind::Derive && (ident.name == sym::Send || ident.name == sym::Sync) {\n             let msg = format!(\"unsafe traits like `{}` should be implemented explicitly\", ident);\n@@ -1713,6 +1721,8 @@ fn find_span_immediately_after_crate_name(\n /// entities with that name in all crates. This method allows outputting the\n /// results of this search in a programmer-friendly way\n crate fn show_candidates(\n+    definitions: &rustc_hir::definitions::Definitions,\n+    session: &Session,\n     err: &mut DiagnosticBuilder<'_>,\n     // This is `None` if all placement locations are inside expansions\n     use_placement_span: Option<Span>,\n@@ -1724,43 +1734,111 @@ crate fn show_candidates(\n         return;\n     }\n \n+    let mut accessible_path_strings: Vec<(String, &str, Option<DefId>)> = Vec::new();\n+    let mut inaccessible_path_strings: Vec<(String, &str, Option<DefId>)> = Vec::new();\n+\n+    candidates.iter().for_each(|c| {\n+        (if c.accessible { &mut accessible_path_strings } else { &mut inaccessible_path_strings })\n+            .push((path_names_to_string(&c.path), c.descr, c.did))\n+    });\n+\n     // we want consistent results across executions, but candidates are produced\n     // by iterating through a hash map, so make sure they are ordered:\n-    let mut path_strings: Vec<_> =\n-        candidates.iter().map(|c| path_names_to_string(&c.path)).collect();\n+    for path_strings in [&mut accessible_path_strings, &mut inaccessible_path_strings] {\n+        path_strings.sort_by(|a, b| a.0.cmp(&b.0));\n+        let core_path_strings =\n+            path_strings.drain_filter(|p| p.0.starts_with(\"core::\")).collect::<Vec<_>>();\n+        path_strings.extend(core_path_strings);\n+        path_strings.dedup_by(|a, b| a.0 == b.0);\n+    }\n+\n+    if !accessible_path_strings.is_empty() {\n+        let (determiner, kind) = if accessible_path_strings.len() == 1 {\n+            (\"this\", accessible_path_strings[0].1)\n+        } else {\n+            (\"one of these\", \"items\")\n+        };\n \n-    path_strings.sort();\n-    let core_path_strings =\n-        path_strings.drain_filter(|p| p.starts_with(\"core::\")).collect::<Vec<String>>();\n-    path_strings.extend(core_path_strings);\n-    path_strings.dedup();\n+        let instead = if instead { \" instead\" } else { \"\" };\n+        let mut msg = format!(\"consider importing {} {}{}\", determiner, kind, instead);\n \n-    let (determiner, kind) = if candidates.len() == 1 {\n-        (\"this\", candidates[0].descr)\n-    } else {\n-        (\"one of these\", \"items\")\n-    };\n-\n-    let instead = if instead { \" instead\" } else { \"\" };\n-    let mut msg = format!(\"consider importing {} {}{}\", determiner, kind, instead);\n-\n-    if let Some(span) = use_placement_span {\n-        for candidate in &mut path_strings {\n-            // produce an additional newline to separate the new use statement\n-            // from the directly following item.\n-            let additional_newline = if found_use { \"\" } else { \"\\n\" };\n-            *candidate = format!(\"use {};\\n{}\", candidate, additional_newline);\n-        }\n+        if let Some(span) = use_placement_span {\n+            for candidate in &mut accessible_path_strings {\n+                // produce an additional newline to separate the new use statement\n+                // from the directly following item.\n+                let additional_newline = if found_use { \"\" } else { \"\\n\" };\n+                candidate.0 = format!(\"use {};\\n{}\", &candidate.0, additional_newline);\n+            }\n \n-        err.span_suggestions(span, &msg, path_strings.into_iter(), Applicability::Unspecified);\n-    } else {\n-        msg.push(':');\n+            err.span_suggestions(\n+                span,\n+                &msg,\n+                accessible_path_strings.into_iter().map(|a| a.0),\n+                Applicability::Unspecified,\n+            );\n+        } else {\n+            msg.push(':');\n \n-        for candidate in path_strings {\n-            msg.push('\\n');\n-            msg.push_str(&candidate);\n+            for candidate in accessible_path_strings {\n+                msg.push('\\n');\n+                msg.push_str(&candidate.0);\n+            }\n+\n+            err.note(&msg);\n         }\n+    } else {\n+        assert!(!inaccessible_path_strings.is_empty());\n+\n+        if inaccessible_path_strings.len() == 1 {\n+            let (name, descr, def_id) = &inaccessible_path_strings[0];\n+            let msg = format!(\"{} `{}` exists but is inaccessible\", descr, name);\n+\n+            if let Some(local_def_id) = def_id.and_then(|did| did.as_local()) {\n+                let span = definitions.def_span(local_def_id);\n+                let span = session.source_map().guess_head_span(span);\n+                let mut multi_span = MultiSpan::from_span(span);\n+                multi_span.push_span_label(span, \"not accessible\".to_string());\n+                err.span_note(multi_span, &msg);\n+            } else {\n+                err.note(&msg);\n+            }\n+        } else {\n+            let (_, descr_first, _) = &inaccessible_path_strings[0];\n+            let descr = if inaccessible_path_strings\n+                .iter()\n+                .skip(1)\n+                .all(|(_, descr, _)| descr == descr_first)\n+            {\n+                format!(\"{}\", descr_first)\n+            } else {\n+                \"item\".to_string()\n+            };\n+\n+            let mut msg = format!(\"these {}s exist but are inaccessible\", descr);\n+            let mut has_colon = false;\n \n-        err.note(&msg);\n+            let mut spans = Vec::new();\n+            for (name, _, def_id) in &inaccessible_path_strings {\n+                if let Some(local_def_id) = def_id.and_then(|did| did.as_local()) {\n+                    let span = definitions.def_span(local_def_id);\n+                    let span = session.source_map().guess_head_span(span);\n+                    spans.push((name, span));\n+                } else {\n+                    if !has_colon {\n+                        msg.push(':');\n+                        has_colon = true;\n+                    }\n+                    msg.push('\\n');\n+                    msg.push_str(name);\n+                }\n+            }\n+\n+            let mut multi_span = MultiSpan::from_spans(spans.iter().map(|(_, sp)| *sp).collect());\n+            for (name, span) in spans {\n+                multi_span.push_span_label(span, format!(\"`{}`: not accessible\", name));\n+            }\n+\n+            err.span_note(multi_span, &msg);\n+        }\n     }\n }"}, {"sha": "8ae2d5cdd97a954dfed4d8ea2f740e0f6b62c456", "filename": "compiler/rustc_resolve/src/lib.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/69eb996b2617621c7088e567089a86a6657f2a0f/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69eb996b2617621c7088e567089a86a6657f2a0f/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flib.rs?ref=69eb996b2617621c7088e567089a86a6657f2a0f", "patch": "@@ -1152,7 +1152,7 @@ impl ResolverAstLowering for Resolver<'_> {\n         self.legacy_const_generic_args(expr)\n     }\n \n-    fn get_partial_res(&mut self, id: NodeId) -> Option<PartialRes> {\n+    fn get_partial_res(&self, id: NodeId) -> Option<PartialRes> {\n         self.partial_res_map.get(&id).cloned()\n     }\n \n@@ -2969,7 +2969,15 @@ impl<'a> Resolver<'a> {\n                 (None, false)\n             };\n             if !candidates.is_empty() {\n-                diagnostics::show_candidates(&mut err, span, &candidates, instead, found_use);\n+                diagnostics::show_candidates(\n+                    &self.definitions,\n+                    self.session,\n+                    &mut err,\n+                    span,\n+                    &candidates,\n+                    instead,\n+                    found_use,\n+                );\n             } else if let Some((span, msg, sugg, appl)) = suggestion {\n                 err.span_suggestion(span, msg, sugg, appl);\n             }"}, {"sha": "09a55937cc5adfb77688f40195e946265a8fad4c", "filename": "compiler/rustc_typeck/src/check/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/69eb996b2617621c7088e567089a86a6657f2a0f/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69eb996b2617621c7088e567089a86a6657f2a0f/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs?ref=69eb996b2617621c7088e567089a86a6657f2a0f", "patch": "@@ -2137,7 +2137,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             idx_t\n         } else {\n             let base_t = self.structurally_resolved_type(base.span, base_t);\n-            match self.lookup_indexing(expr, base, base_t, idx_t) {\n+            match self.lookup_indexing(expr, base, base_t, idx, idx_t) {\n                 Some((index_ty, element_ty)) => {\n                     // two-phase not needed because index_ty is never mutable\n                     self.demand_coerce(idx, idx_t, index_ty, None, AllowTwoPhase::No);"}, {"sha": "64775d7aba9f8688dfad292fe550a80f9eb69f46", "filename": "compiler/rustc_typeck/src/check/place_op.rs", "status": "modified", "additions": 56, "deletions": 1, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/69eb996b2617621c7088e567089a86a6657f2a0f/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fplace_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69eb996b2617621c7088e567089a86a6657f2a0f/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fplace_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fplace_op.rs?ref=69eb996b2617621c7088e567089a86a6657f2a0f", "patch": "@@ -1,5 +1,7 @@\n use crate::check::method::MethodCallee;\n use crate::check::{has_expected_num_generic_args, FnCtxt, PlaceOp};\n+use rustc_ast as ast;\n+use rustc_errors::Applicability;\n use rustc_hir as hir;\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use rustc_infer::infer::InferOk;\n@@ -47,6 +49,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         expr: &hir::Expr<'_>,\n         base_expr: &'tcx hir::Expr<'tcx>,\n         base_ty: Ty<'tcx>,\n+        index_expr: &'tcx hir::Expr<'tcx>,\n         idx_ty: Ty<'tcx>,\n     ) -> Option<(/*index type*/ Ty<'tcx>, /*element type*/ Ty<'tcx>)> {\n         // FIXME(#18741) -- this is almost but not quite the same as the\n@@ -56,12 +59,42 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let mut autoderef = self.autoderef(base_expr.span, base_ty);\n         let mut result = None;\n         while result.is_none() && autoderef.next().is_some() {\n-            result = self.try_index_step(expr, base_expr, &autoderef, idx_ty);\n+            result = self.try_index_step(expr, base_expr, &autoderef, idx_ty, index_expr);\n         }\n         self.register_predicates(autoderef.into_obligations());\n         result\n     }\n \n+    fn negative_index(\n+        &self,\n+        ty: Ty<'tcx>,\n+        span: Span,\n+        base_expr: &hir::Expr<'_>,\n+    ) -> Option<(Ty<'tcx>, Ty<'tcx>)> {\n+        let ty = self.resolve_vars_if_possible(ty);\n+        let mut err = self.tcx.sess.struct_span_err(\n+            span,\n+            &format!(\"negative integers cannot be used to index on a `{}`\", ty),\n+        );\n+        err.span_label(span, &format!(\"cannot use a negative integer for indexing on `{}`\", ty));\n+        if let (hir::ExprKind::Path(..), Ok(snippet)) =\n+            (&base_expr.kind, self.tcx.sess.source_map().span_to_snippet(base_expr.span))\n+        {\n+            // `foo[-1]` to `foo[foo.len() - 1]`\n+            err.span_suggestion_verbose(\n+                span.shrink_to_lo(),\n+                &format!(\n+                    \"to access an element starting from the end of the `{}`, compute the index\",\n+                    ty,\n+                ),\n+                format!(\"{}.len() \", snippet),\n+                Applicability::MachineApplicable,\n+            );\n+        }\n+        err.emit();\n+        Some((self.tcx.ty_error(), self.tcx.ty_error()))\n+    }\n+\n     /// To type-check `base_expr[index_expr]`, we progressively autoderef\n     /// (and otherwise adjust) `base_expr`, looking for a type which either\n     /// supports builtin indexing or overloaded indexing.\n@@ -73,6 +106,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         base_expr: &hir::Expr<'_>,\n         autoderef: &Autoderef<'a, 'tcx>,\n         index_ty: Ty<'tcx>,\n+        index_expr: &hir::Expr<'_>,\n     ) -> Option<(/*index type*/ Ty<'tcx>, /*element type*/ Ty<'tcx>)> {\n         let adjusted_ty =\n             self.structurally_resolved_type(autoderef.span(), autoderef.final_ty(false));\n@@ -82,6 +116,27 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             expr, base_expr, adjusted_ty, index_ty\n         );\n \n+        if let hir::ExprKind::Unary(\n+            hir::UnOp::Neg,\n+            hir::Expr {\n+                kind: hir::ExprKind::Lit(hir::Lit { node: ast::LitKind::Int(..), .. }),\n+                ..\n+            },\n+        ) = index_expr.kind\n+        {\n+            match adjusted_ty.kind() {\n+                ty::Adt(ty::AdtDef { did, .. }, _)\n+                    if self.tcx.is_diagnostic_item(sym::vec_type, *did) =>\n+                {\n+                    return self.negative_index(adjusted_ty, index_expr.span, base_expr);\n+                }\n+                ty::Slice(_) | ty::Array(_, _) => {\n+                    return self.negative_index(adjusted_ty, index_expr.span, base_expr);\n+                }\n+                _ => {}\n+            }\n+        }\n+\n         for unsize in [false, true] {\n             let mut self_ty = adjusted_ty;\n             if unsize {"}, {"sha": "522c3e3d9c097b53ede7682cc28544b461597b20", "filename": "src/llvm-project", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fllvm-project?ref=69eb996b2617621c7088e567089a86a6657f2a0f", "patch": "@@ -1 +1 @@\n-Subproject commit cba558df777a045b5657d56c29944e9e8fd3a776\n+Subproject commit 522c3e3d9c097b53ede7682cc28544b461597b20"}, {"sha": "dd6fa7c151aa7b82f93d0a964738e363eea551f3", "filename": "src/test/ui/generator/yield-in-box.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/69eb996b2617621c7088e567089a86a6657f2a0f/src%2Ftest%2Fui%2Fgenerator%2Fyield-in-box.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69eb996b2617621c7088e567089a86a6657f2a0f/src%2Ftest%2Fui%2Fgenerator%2Fyield-in-box.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fyield-in-box.rs?ref=69eb996b2617621c7088e567089a86a6657f2a0f", "patch": "@@ -1,8 +1,10 @@\n // run-pass\n-\n // Test that box-statements with yields in them work.\n \n-#![feature(generators, box_syntax)]\n+#![feature(generators, box_syntax, generator_trait)]\n+use std::pin::Pin;\n+use std::ops::Generator;\n+use std::ops::GeneratorState;\n \n fn main() {\n     let x = 0i32;\n@@ -15,4 +17,8 @@ fn main() {\n             _t => {}\n         }\n     };\n+\n+    let mut g = |_| box yield;\n+    assert_eq!(Pin::new(&mut g).resume(1), GeneratorState::Yielded(()));\n+    assert_eq!(Pin::new(&mut g).resume(2), GeneratorState::Complete(box 2));\n }"}, {"sha": "7602e803945dc14e6ede067876691f7420f33c88", "filename": "src/test/ui/generator/yield-in-box.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/69eb996b2617621c7088e567089a86a6657f2a0f/src%2Ftest%2Fui%2Fgenerator%2Fyield-in-box.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/69eb996b2617621c7088e567089a86a6657f2a0f/src%2Ftest%2Fui%2Fgenerator%2Fyield-in-box.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fyield-in-box.stderr?ref=69eb996b2617621c7088e567089a86a6657f2a0f", "patch": "@@ -1,5 +1,5 @@\n warning: unused generator that must be used\n-  --> $DIR/yield-in-box.rs:9:5\n+  --> $DIR/yield-in-box.rs:11:5\n    |\n LL | /     || {\n LL | |         let y = 2u32;"}, {"sha": "6c8b707b8e2f14d7d6db5109bf6bc3e759c36640", "filename": "src/test/ui/hygiene/globs.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/69eb996b2617621c7088e567089a86a6657f2a0f/src%2Ftest%2Fui%2Fhygiene%2Fglobs.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/69eb996b2617621c7088e567089a86a6657f2a0f/src%2Ftest%2Fui%2Fhygiene%2Fglobs.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhygiene%2Fglobs.stderr?ref=69eb996b2617621c7088e567089a86a6657f2a0f", "patch": "@@ -4,7 +4,7 @@ error[E0425]: cannot find function `f` in this scope\n LL |         f();\n    |         ^ not found in this scope\n    |\n-help: consider importing one of these items\n+help: consider importing this function\n    |\n LL | use foo::f;\n    |\n@@ -37,7 +37,7 @@ LL | n!(f);\n LL |         n!(f);\n    |            ^ not found in this scope\n    |\n-   = note: consider importing one of these items:\n+   = note: consider importing this function:\n            foo::f\n    = note: this error originates in the macro `n` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n@@ -50,7 +50,7 @@ LL | n!(f);\n LL |                 f\n    |                 ^ not found in this scope\n    |\n-   = note: consider importing one of these items:\n+   = note: consider importing this function:\n            foo::f\n    = note: this error originates in the macro `n` (in Nightly builds, run with -Z macro-backtrace for more info)\n "}, {"sha": "0fe9b06355f0b8446e60c1dd370a3c9562b86ecb", "filename": "src/test/ui/impl-trait/multiple-lifetimes/ordinary-bounds-unrelated.nll.stderr", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/69eb996b2617621c7088e567089a86a6657f2a0f/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Fordinary-bounds-unrelated.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/69eb996b2617621c7088e567089a86a6657f2a0f/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Fordinary-bounds-unrelated.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Fordinary-bounds-unrelated.nll.stderr?ref=69eb996b2617621c7088e567089a86a6657f2a0f", "patch": "@@ -4,7 +4,11 @@ error[E0700]: hidden type for `impl Trait` captures lifetime that does not appea\n LL | fn upper_bounds<'a, 'b, 'c, 'd, 'e>(a: Ordinary<'a>, b: Ordinary<'b>) -> impl Trait<'d, 'e>\n    |                                                                          ^^^^^^^^^^^^^^^^^^\n    |\n-   = note: hidden type `Ordinary<'_>` captures lifetime '_#9r\n+note: hidden type `Ordinary<'b>` captures the lifetime `'b` as defined on the function body at 16:21\n+  --> $DIR/ordinary-bounds-unrelated.rs:16:21\n+   |\n+LL | fn upper_bounds<'a, 'b, 'c, 'd, 'e>(a: Ordinary<'a>, b: Ordinary<'b>) -> impl Trait<'d, 'e>\n+   |                     ^^\n \n error: aborting due to previous error\n "}, {"sha": "6de77523db57710a77afa4ec3c461b57d8c34278", "filename": "src/test/ui/impl-trait/multiple-lifetimes/ordinary-bounds-unsuited.nll.stderr", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/69eb996b2617621c7088e567089a86a6657f2a0f/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Fordinary-bounds-unsuited.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/69eb996b2617621c7088e567089a86a6657f2a0f/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Fordinary-bounds-unsuited.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Fordinary-bounds-unsuited.nll.stderr?ref=69eb996b2617621c7088e567089a86a6657f2a0f", "patch": "@@ -4,7 +4,11 @@ error[E0700]: hidden type for `impl Trait` captures lifetime that does not appea\n LL | fn upper_bounds<'a, 'b>(a: Ordinary<'a>, b: Ordinary<'b>) -> impl Trait<'a, 'b>\n    |                                                              ^^^^^^^^^^^^^^^^^^\n    |\n-   = note: hidden type `Ordinary<'_>` captures lifetime '_#6r\n+note: hidden type `Ordinary<'b>` captures the lifetime `'b` as defined on the function body at 18:21\n+  --> $DIR/ordinary-bounds-unsuited.rs:18:21\n+   |\n+LL | fn upper_bounds<'a, 'b>(a: Ordinary<'a>, b: Ordinary<'b>) -> impl Trait<'a, 'b>\n+   |                     ^^\n \n error: aborting due to previous error\n "}, {"sha": "3b66a5e3150502600768bc6a95f71873983ef991", "filename": "src/test/ui/imports/glob-resolve1.stderr", "status": "modified", "additions": 27, "deletions": 33, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/69eb996b2617621c7088e567089a86a6657f2a0f/src%2Ftest%2Fui%2Fimports%2Fglob-resolve1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/69eb996b2617621c7088e567089a86a6657f2a0f/src%2Ftest%2Fui%2Fimports%2Fglob-resolve1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimports%2Fglob-resolve1.stderr?ref=69eb996b2617621c7088e567089a86a6657f2a0f", "patch": "@@ -4,21 +4,23 @@ error[E0425]: cannot find function `fpriv` in this scope\n LL |     fpriv();\n    |     ^^^^^ not found in this scope\n    |\n-help: consider importing this function\n-   |\n-LL | use bar::fpriv;\n+note: function `bar::fpriv` exists but is inaccessible\n+  --> $DIR/glob-resolve1.rs:7:5\n    |\n+LL |     fn fpriv() {}\n+   |     ^^^^^^^^^^ not accessible\n \n error[E0425]: cannot find function `epriv` in this scope\n   --> $DIR/glob-resolve1.rs:27:5\n    |\n LL |     epriv();\n    |     ^^^^^ not found in this scope\n    |\n-help: consider importing this function\n-   |\n-LL | use bar::epriv;\n+note: function `bar::epriv` exists but is inaccessible\n+  --> $DIR/glob-resolve1.rs:9:9\n    |\n+LL |         fn epriv();\n+   |         ^^^^^^^^^^^ not accessible\n \n error[E0423]: expected value, found enum `B`\n   --> $DIR/glob-resolve1.rs:28:5\n@@ -44,10 +46,11 @@ error[E0425]: cannot find value `C` in this scope\n LL |     C;\n    |     ^ not found in this scope\n    |\n-help: consider importing this unit struct\n-   |\n-LL | use bar::C;\n+note: unit struct `bar::C` exists but is inaccessible\n+  --> $DIR/glob-resolve1.rs:18:5\n    |\n+LL |     struct C;\n+   |     ^^^^^^^^^ not accessible\n \n error[E0425]: cannot find function `import` in this scope\n   --> $DIR/glob-resolve1.rs:30:5\n@@ -67,16 +70,13 @@ LL |     pub enum B {\n    |     ---------- similarly named enum `B` defined here\n ...\n LL |     foo::<A>();\n-   |           ^\n-   |\n-help: an enum with a similar name exists\n+   |           ^ help: an enum with a similar name exists: `B`\n    |\n-LL |     foo::<B>();\n-   |           ~\n-help: consider importing this enum\n-   |\n-LL | use bar::A;\n+note: enum `bar::A` exists but is inaccessible\n+  --> $DIR/glob-resolve1.rs:11:5\n    |\n+LL |     enum A {\n+   |     ^^^^^^ not accessible\n \n error[E0412]: cannot find type `C` in this scope\n   --> $DIR/glob-resolve1.rs:33:11\n@@ -85,16 +85,13 @@ LL |     pub enum B {\n    |     ---------- similarly named enum `B` defined here\n ...\n LL |     foo::<C>();\n-   |           ^\n-   |\n-help: an enum with a similar name exists\n-   |\n-LL |     foo::<B>();\n-   |           ~\n-help: consider importing this struct\n+   |           ^ help: an enum with a similar name exists: `B`\n    |\n-LL | use bar::C;\n+note: struct `bar::C` exists but is inaccessible\n+  --> $DIR/glob-resolve1.rs:18:5\n    |\n+LL |     struct C;\n+   |     ^^^^^^^^^ not accessible\n \n error[E0412]: cannot find type `D` in this scope\n   --> $DIR/glob-resolve1.rs:34:11\n@@ -103,16 +100,13 @@ LL |     pub enum B {\n    |     ---------- similarly named enum `B` defined here\n ...\n LL |     foo::<D>();\n-   |           ^\n-   |\n-help: an enum with a similar name exists\n-   |\n-LL |     foo::<B>();\n-   |           ~\n-help: consider importing this type alias\n+   |           ^ help: an enum with a similar name exists: `B`\n    |\n-LL | use bar::D;\n+note: type alias `bar::D` exists but is inaccessible\n+  --> $DIR/glob-resolve1.rs:20:5\n    |\n+LL |     type D = isize;\n+   |     ^^^^^^^^^^^^^^^ not accessible\n \n error: aborting due to 8 previous errors\n "}, {"sha": "4c94634ee60f7d459959efe76f13adcfbfe5042c", "filename": "src/test/ui/imports/issue-4366-2.stderr", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/69eb996b2617621c7088e567089a86a6657f2a0f/src%2Ftest%2Fui%2Fimports%2Fissue-4366-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/69eb996b2617621c7088e567089a86a6657f2a0f/src%2Ftest%2Fui%2Fimports%2Fissue-4366-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimports%2Fissue-4366-2.stderr?ref=69eb996b2617621c7088e567089a86a6657f2a0f", "patch": "@@ -4,10 +4,11 @@ error[E0412]: cannot find type `Bar` in this scope\n LL |         fn sub() -> Bar { 1 }\n    |                     ^^^ not found in this scope\n    |\n-help: consider importing this type alias\n-   |\n-LL |         use a::b::Bar;\n+note: type alias `a::b::Bar` exists but is inaccessible\n+  --> $DIR/issue-4366-2.rs:11:9\n    |\n+LL |         type Bar = isize;\n+   |         ^^^^^^^^^^^^^^^^^ not accessible\n \n error[E0423]: expected function, found module `foo`\n   --> $DIR/issue-4366-2.rs:25:5"}, {"sha": "39bc1b88e56d7f11f18015b4c5ca28e47a5aa6f0", "filename": "src/test/ui/maybe-bounds-where.stderr", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/69eb996b2617621c7088e567089a86a6657f2a0f/src%2Ftest%2Fui%2Fmaybe-bounds-where.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/69eb996b2617621c7088e567089a86a6657f2a0f/src%2Ftest%2Fui%2Fmaybe-bounds-where.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmaybe-bounds-where.stderr?ref=69eb996b2617621c7088e567089a86a6657f2a0f", "patch": "@@ -1,32 +1,32 @@\n error: `?Trait` bounds are only permitted at the point where a type parameter is declared\n-  --> $DIR/maybe-bounds-where.rs:1:23\n+  --> $DIR/maybe-bounds-where.rs:1:28\n    |\n LL | struct S1<T>(T) where (T): ?Sized;\n-   |                       ^^^\n+   |                            ^^^^^^\n \n error: `?Trait` bounds are only permitted at the point where a type parameter is declared\n-  --> $DIR/maybe-bounds-where.rs:4:23\n+  --> $DIR/maybe-bounds-where.rs:4:27\n    |\n LL | struct S2<T>(T) where u8: ?Sized;\n-   |                       ^^\n+   |                           ^^^^^^\n \n error: `?Trait` bounds are only permitted at the point where a type parameter is declared\n-  --> $DIR/maybe-bounds-where.rs:7:23\n+  --> $DIR/maybe-bounds-where.rs:7:35\n    |\n LL | struct S3<T>(T) where &'static T: ?Sized;\n-   |                       ^^^^^^^^^^\n+   |                                   ^^^^^^\n \n error: `?Trait` bounds are only permitted at the point where a type parameter is declared\n-  --> $DIR/maybe-bounds-where.rs:12:31\n+  --> $DIR/maybe-bounds-where.rs:12:34\n    |\n LL | struct S4<T>(T) where for<'a> T: ?Trait<'a>;\n-   |                               ^\n+   |                                  ^^^^^^^^^^\n \n error: `?Trait` bounds are only permitted at the point where a type parameter is declared\n-  --> $DIR/maybe-bounds-where.rs:21:18\n+  --> $DIR/maybe-bounds-where.rs:21:21\n    |\n LL |     fn f() where T: ?Sized {}\n-   |                  ^\n+   |                     ^^^^^^\n \n warning: default bound relaxed for a type parameter, but this does nothing because the given bound is not a default; only `?Sized` is supported\n   --> $DIR/maybe-bounds-where.rs:12:11"}, {"sha": "cad3ccc4a0ef836883eaa23f32a77506ab70f843", "filename": "src/test/ui/resolve/issue-42944.stderr", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/69eb996b2617621c7088e567089a86a6657f2a0f/src%2Ftest%2Fui%2Fresolve%2Fissue-42944.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/69eb996b2617621c7088e567089a86a6657f2a0f/src%2Ftest%2Fui%2Fresolve%2Fissue-42944.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fissue-42944.stderr?ref=69eb996b2617621c7088e567089a86a6657f2a0f", "patch": "@@ -16,10 +16,11 @@ error[E0425]: cannot find function, tuple struct or tuple variant `Bx` in this s\n LL |         Bx(());\n    |         ^^ not found in this scope\n    |\n-help: consider importing this tuple struct\n-   |\n-LL |     use foo::Bx;\n+note: tuple struct `foo::Bx` exists but is inaccessible\n+  --> $DIR/issue-42944.rs:2:5\n    |\n+LL |     pub struct Bx(());\n+   |     ^^^^^^^^^^^^^^^^^^ not accessible\n \n error: aborting due to 2 previous errors\n "}, {"sha": "6bf7caeddbfcd97b3e4d7691c1bb877c384335d4", "filename": "src/test/ui/resolve/issue-88472.rs", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/69eb996b2617621c7088e567089a86a6657f2a0f/src%2Ftest%2Fui%2Fresolve%2Fissue-88472.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69eb996b2617621c7088e567089a86a6657f2a0f/src%2Ftest%2Fui%2Fresolve%2Fissue-88472.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fissue-88472.rs?ref=69eb996b2617621c7088e567089a86a6657f2a0f", "patch": "@@ -0,0 +1,38 @@\n+// Regression test for #88472, where a suggestion was issued to\n+// import an inaccessible struct.\n+\n+#![warn(unused_imports)]\n+//~^ NOTE: the lint level is defined here\n+\n+mod a {\n+    struct Foo;\n+    //~^ NOTE: struct `a::Foo` exists but is inaccessible\n+    //~| NOTE: not accessible\n+}\n+\n+mod b {\n+    use crate::a::*;\n+    //~^ WARNING: unused import\n+    type Bar = Foo;\n+    //~^ ERROR: cannot find type `Foo` in this scope [E0412]\n+    //~| NOTE: not found in this scope\n+}\n+\n+mod c {\n+    enum Eee {}\n+    //~^ NOTE: these enums exist but are inaccessible\n+    //~| NOTE: `c::Eee`: not accessible\n+\n+    mod d {\n+        enum Eee {}\n+        //~^ NOTE: `c::d::Eee`: not accessible\n+    }\n+}\n+\n+mod e {\n+    type Baz = Eee;\n+    //~^ ERROR: cannot find type `Eee` in this scope [E0412]\n+    //~| NOTE: not found in this scope\n+}\n+\n+fn main() {}"}, {"sha": "8431fc97766f7a15311d87abe047c0f4045e4bd6", "filename": "src/test/ui/resolve/issue-88472.stderr", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/69eb996b2617621c7088e567089a86a6657f2a0f/src%2Ftest%2Fui%2Fresolve%2Fissue-88472.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/69eb996b2617621c7088e567089a86a6657f2a0f/src%2Ftest%2Fui%2Fresolve%2Fissue-88472.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fissue-88472.stderr?ref=69eb996b2617621c7088e567089a86a6657f2a0f", "patch": "@@ -0,0 +1,42 @@\n+error[E0412]: cannot find type `Foo` in this scope\n+  --> $DIR/issue-88472.rs:16:16\n+   |\n+LL |     type Bar = Foo;\n+   |                ^^^ not found in this scope\n+   |\n+note: struct `a::Foo` exists but is inaccessible\n+  --> $DIR/issue-88472.rs:8:5\n+   |\n+LL |     struct Foo;\n+   |     ^^^^^^^^^^^ not accessible\n+\n+error[E0412]: cannot find type `Eee` in this scope\n+  --> $DIR/issue-88472.rs:33:16\n+   |\n+LL |     type Baz = Eee;\n+   |                ^^^ not found in this scope\n+   |\n+note: these enums exist but are inaccessible\n+  --> $DIR/issue-88472.rs:22:5\n+   |\n+LL |     enum Eee {}\n+   |     ^^^^^^^^ `c::Eee`: not accessible\n+...\n+LL |         enum Eee {}\n+   |         ^^^^^^^^ `c::d::Eee`: not accessible\n+\n+warning: unused import: `crate::a::*`\n+  --> $DIR/issue-88472.rs:14:9\n+   |\n+LL |     use crate::a::*;\n+   |         ^^^^^^^^^^^\n+   |\n+note: the lint level is defined here\n+  --> $DIR/issue-88472.rs:4:9\n+   |\n+LL | #![warn(unused_imports)]\n+   |         ^^^^^^^^^^^^^^\n+\n+error: aborting due to 2 previous errors; 1 warning emitted\n+\n+For more information about this error, try `rustc --explain E0412`."}, {"sha": "ff72b0b563ab176fc361e0b13a117f173fe00f8f", "filename": "src/test/ui/resolve/privacy-enum-ctor.stderr", "status": "modified", "additions": 20, "deletions": 32, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/69eb996b2617621c7088e567089a86a6657f2a0f/src%2Ftest%2Fui%2Fresolve%2Fprivacy-enum-ctor.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/69eb996b2617621c7088e567089a86a6657f2a0f/src%2Ftest%2Fui%2Fresolve%2Fprivacy-enum-ctor.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fprivacy-enum-ctor.stderr?ref=69eb996b2617621c7088e567089a86a6657f2a0f", "patch": "@@ -169,16 +169,13 @@ LL |     pub enum E {\n    |     ---------- similarly named enum `E` defined here\n ...\n LL |     let _: Z = m::n::Z;\n-   |            ^\n+   |            ^ help: an enum with a similar name exists: `E`\n    |\n-help: an enum with a similar name exists\n-   |\n-LL |     let _: E = m::n::Z;\n-   |            ~\n-help: consider importing this enum\n-   |\n-LL | use m::Z;\n+note: enum `m::Z` exists but is inaccessible\n+  --> $DIR/privacy-enum-ctor.rs:11:9\n    |\n+LL |         pub(in m) enum Z {\n+   |         ^^^^^^^^^^^^^^^^ not accessible\n \n error[E0423]: expected value, found enum `m::n::Z`\n   --> $DIR/privacy-enum-ctor.rs:57:16\n@@ -215,16 +212,13 @@ LL |     pub enum E {\n    |     ---------- similarly named enum `E` defined here\n ...\n LL |     let _: Z = m::n::Z::Fn;\n-   |            ^\n+   |            ^ help: an enum with a similar name exists: `E`\n    |\n-help: an enum with a similar name exists\n-   |\n-LL |     let _: E = m::n::Z::Fn;\n-   |            ~\n-help: consider importing this enum\n-   |\n-LL | use m::Z;\n+note: enum `m::Z` exists but is inaccessible\n+  --> $DIR/privacy-enum-ctor.rs:11:9\n    |\n+LL |         pub(in m) enum Z {\n+   |         ^^^^^^^^^^^^^^^^ not accessible\n \n error[E0412]: cannot find type `Z` in this scope\n   --> $DIR/privacy-enum-ctor.rs:64:12\n@@ -233,16 +227,13 @@ LL |     pub enum E {\n    |     ---------- similarly named enum `E` defined here\n ...\n LL |     let _: Z = m::n::Z::Struct;\n-   |            ^\n+   |            ^ help: an enum with a similar name exists: `E`\n    |\n-help: an enum with a similar name exists\n-   |\n-LL |     let _: E = m::n::Z::Struct;\n-   |            ~\n-help: consider importing this enum\n-   |\n-LL | use m::Z;\n+note: enum `m::Z` exists but is inaccessible\n+  --> $DIR/privacy-enum-ctor.rs:11:9\n    |\n+LL |         pub(in m) enum Z {\n+   |         ^^^^^^^^^^^^^^^^ not accessible\n \n error[E0423]: expected value, found struct variant `m::n::Z::Struct`\n   --> $DIR/privacy-enum-ctor.rs:64:16\n@@ -262,16 +253,13 @@ LL |     pub enum E {\n    |     ---------- similarly named enum `E` defined here\n ...\n LL |     let _: Z = m::n::Z::Unit {};\n-   |            ^\n+   |            ^ help: an enum with a similar name exists: `E`\n    |\n-help: an enum with a similar name exists\n-   |\n-LL |     let _: E = m::n::Z::Unit {};\n-   |            ~\n-help: consider importing this enum\n-   |\n-LL | use m::Z;\n+note: enum `m::Z` exists but is inaccessible\n+  --> $DIR/privacy-enum-ctor.rs:11:9\n    |\n+LL |         pub(in m) enum Z {\n+   |         ^^^^^^^^^^^^^^^^ not accessible\n \n error[E0603]: enum `Z` is private\n   --> $DIR/privacy-enum-ctor.rs:57:22"}, {"sha": "ada053014ef5eb38e064fcf7c2c7c54ab94d6d09", "filename": "src/test/ui/resolve/privacy-struct-ctor.stderr", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/69eb996b2617621c7088e567089a86a6657f2a0f/src%2Ftest%2Fui%2Fresolve%2Fprivacy-struct-ctor.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/69eb996b2617621c7088e567089a86a6657f2a0f/src%2Ftest%2Fui%2Fresolve%2Fprivacy-struct-ctor.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fprivacy-struct-ctor.stderr?ref=69eb996b2617621c7088e567089a86a6657f2a0f", "patch": "@@ -33,10 +33,11 @@ error[E0423]: expected value, found struct `xcrate::S`\n LL |     xcrate::S;\n    |     ^^^^^^^^^ constructor is not visible here due to private fields\n    |\n-help: consider importing this tuple struct instead\n-   |\n-LL | use m::S;\n+note: tuple struct `m::S` exists but is inaccessible\n+  --> $DIR/privacy-struct-ctor.rs:6:5\n    |\n+LL |     pub struct S(u8);\n+   |     ^^^^^^^^^^^^^^^^^ not accessible\n \n error[E0603]: tuple struct constructor `Z` is private\n   --> $DIR/privacy-struct-ctor.rs:18:12"}, {"sha": "aca08d81163fd7428a4b590705222f26b27fd500", "filename": "src/test/ui/self/self_type_keyword.stderr", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/69eb996b2617621c7088e567089a86a6657f2a0f/src%2Ftest%2Fui%2Fself%2Fself_type_keyword.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/69eb996b2617621c7088e567089a86a6657f2a0f/src%2Ftest%2Fui%2Fself%2Fself_type_keyword.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fself%2Fself_type_keyword.stderr?ref=69eb996b2617621c7088e567089a86a6657f2a0f", "patch": "@@ -66,10 +66,11 @@ error[E0531]: cannot find unit struct, unit variant or constant `Self` in this s\n LL |         mut Self => (),\n    |             ^^^^ not found in this scope\n    |\n-help: consider importing this unit struct\n-   |\n-LL | use foo::Self;\n+note: unit struct `foo::Self` exists but is inaccessible\n+  --> $DIR/self_type_keyword.rs:2:3\n    |\n+LL |   struct Self;\n+   |   ^^^^^^^^^^^^ not accessible\n \n error[E0392]: parameter `'Self` is never used\n   --> $DIR/self_type_keyword.rs:6:12"}, {"sha": "e52714cf97fe6f5cc54d7830500bf65faad524bf", "filename": "src/test/ui/suggestions/negative-literal-index.fixed", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/69eb996b2617621c7088e567089a86a6657f2a0f/src%2Ftest%2Fui%2Fsuggestions%2Fnegative-literal-index.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/69eb996b2617621c7088e567089a86a6657f2a0f/src%2Ftest%2Fui%2Fsuggestions%2Fnegative-literal-index.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fnegative-literal-index.fixed?ref=69eb996b2617621c7088e567089a86a6657f2a0f", "patch": "@@ -0,0 +1,22 @@\n+// run-rustfix\n+\n+use std::ops::Index;\n+struct X;\n+impl Index<i32> for X {\n+    type Output = ();\n+\n+    fn index(&self, _: i32) -> &() {\n+        &()\n+    }\n+}\n+\n+fn main() {\n+    let x = vec![1, 2, 3];\n+    x[x.len() -1]; //~ ERROR negative integers cannot be used to index on a\n+    let x = [1, 2, 3];\n+    x[x.len() -1]; //~ ERROR negative integers cannot be used to index on a\n+    let x = &[1, 2, 3];\n+    x[x.len() -1]; //~ ERROR negative integers cannot be used to index on a\n+    let _ = x;\n+    X[-1];\n+}"}, {"sha": "d88b66e679e56d2fd6df33fdad7ab07310bf9be2", "filename": "src/test/ui/suggestions/negative-literal-index.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/69eb996b2617621c7088e567089a86a6657f2a0f/src%2Ftest%2Fui%2Fsuggestions%2Fnegative-literal-index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69eb996b2617621c7088e567089a86a6657f2a0f/src%2Ftest%2Fui%2Fsuggestions%2Fnegative-literal-index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fnegative-literal-index.rs?ref=69eb996b2617621c7088e567089a86a6657f2a0f", "patch": "@@ -0,0 +1,22 @@\n+// run-rustfix\n+\n+use std::ops::Index;\n+struct X;\n+impl Index<i32> for X {\n+    type Output = ();\n+\n+    fn index(&self, _: i32) -> &() {\n+        &()\n+    }\n+}\n+\n+fn main() {\n+    let x = vec![1, 2, 3];\n+    x[-1]; //~ ERROR negative integers cannot be used to index on a\n+    let x = [1, 2, 3];\n+    x[-1]; //~ ERROR negative integers cannot be used to index on a\n+    let x = &[1, 2, 3];\n+    x[-1]; //~ ERROR negative integers cannot be used to index on a\n+    let _ = x;\n+    X[-1];\n+}"}, {"sha": "2b51bf7b7ce87c21a1d2bc8feb9c1cdadd0333a8", "filename": "src/test/ui/suggestions/negative-literal-index.stderr", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/69eb996b2617621c7088e567089a86a6657f2a0f/src%2Ftest%2Fui%2Fsuggestions%2Fnegative-literal-index.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/69eb996b2617621c7088e567089a86a6657f2a0f/src%2Ftest%2Fui%2Fsuggestions%2Fnegative-literal-index.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fnegative-literal-index.stderr?ref=69eb996b2617621c7088e567089a86a6657f2a0f", "patch": "@@ -0,0 +1,35 @@\n+error: negative integers cannot be used to index on a `Vec<{integer}>`\n+  --> $DIR/negative-literal-index.rs:15:7\n+   |\n+LL |     x[-1];\n+   |       ^^ cannot use a negative integer for indexing on `Vec<{integer}>`\n+   |\n+help: to access an element starting from the end of the `Vec<{integer}>`, compute the index\n+   |\n+LL |     x[x.len() -1];\n+   |       +++++++\n+\n+error: negative integers cannot be used to index on a `[{integer}; 3]`\n+  --> $DIR/negative-literal-index.rs:17:7\n+   |\n+LL |     x[-1];\n+   |       ^^ cannot use a negative integer for indexing on `[{integer}; 3]`\n+   |\n+help: to access an element starting from the end of the `[{integer}; 3]`, compute the index\n+   |\n+LL |     x[x.len() -1];\n+   |       +++++++\n+\n+error: negative integers cannot be used to index on a `[{integer}; 3]`\n+  --> $DIR/negative-literal-index.rs:19:7\n+   |\n+LL |     x[-1];\n+   |       ^^ cannot use a negative integer for indexing on `[{integer}; 3]`\n+   |\n+help: to access an element starting from the end of the `[{integer}; 3]`, compute the index\n+   |\n+LL |     x[x.len() -1];\n+   |       +++++++\n+\n+error: aborting due to 3 previous errors\n+"}, {"sha": "769e897316327245d77caf3ab3aa7f023288b478", "filename": "src/test/ui/traits/auxiliary/issue_89119_intercrate_caching.rs", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/69eb996b2617621c7088e567089a86a6657f2a0f/src%2Ftest%2Fui%2Ftraits%2Fauxiliary%2Fissue_89119_intercrate_caching.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69eb996b2617621c7088e567089a86a6657f2a0f/src%2Ftest%2Fui%2Ftraits%2Fauxiliary%2Fissue_89119_intercrate_caching.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fauxiliary%2Fissue_89119_intercrate_caching.rs?ref=69eb996b2617621c7088e567089a86a6657f2a0f", "patch": "@@ -0,0 +1,60 @@\n+// This is the auxiliary crate for the regression test for issue #89119, minimized\n+// from `zvariant-2.8.0`.\n+\n+use std::convert::TryFrom;\n+use std::borrow::Cow;\n+\n+pub struct Str<'a>(Cow<'a, str>);\n+impl<'a> Str<'a> {\n+    pub fn to_owned(&self) -> Str<'static> {\n+        todo!()\n+    }\n+}\n+\n+pub enum Value<'a> {\n+    Str(Str<'a>),\n+    Value(Box<Value<'a>>),\n+}\n+impl<'a> Value<'a> {\n+    pub fn to_owned(&self) -> Value<'static> {\n+        match self {\n+            Value::Str(v) => Value::Str(v.to_owned()),\n+            Value::Value(v) => {\n+                let o = OwnedValue::from(&**v);\n+                Value::Value(Box::new(o.into_inner()))\n+            }\n+        }\n+    }\n+}\n+\n+struct OwnedValue(Value<'static>);\n+impl OwnedValue {\n+    pub(crate) fn into_inner(self) -> Value<'static> {\n+        todo!()\n+    }\n+}\n+impl<'a, T> TryFrom<OwnedValue> for Vec<T>\n+where\n+    T: TryFrom<Value<'a>, Error = ()>,\n+{\n+    type Error = ();\n+    fn try_from(_: OwnedValue) -> Result<Self, Self::Error> {\n+        todo!()\n+    }\n+}\n+impl TryFrom<OwnedValue> for Vec<OwnedValue> {\n+    type Error = ();\n+    fn try_from(_: OwnedValue) -> Result<Self, Self::Error> {\n+        todo!()\n+    }\n+}\n+impl<'a> From<Value<'a>> for OwnedValue {\n+    fn from(_: Value<'a>) -> Self {\n+        todo!()\n+    }\n+}\n+impl<'a> From<&Value<'a>> for OwnedValue {\n+    fn from(_: &Value<'a>) -> Self {\n+        todo!()\n+    }\n+}"}, {"sha": "170f69915e2abbfb0765a8faf908ecf0a598fb4c", "filename": "src/test/ui/traits/issue-89119.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/69eb996b2617621c7088e567089a86a6657f2a0f/src%2Ftest%2Fui%2Ftraits%2Fissue-89119.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69eb996b2617621c7088e567089a86a6657f2a0f/src%2Ftest%2Fui%2Ftraits%2Fissue-89119.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fissue-89119.rs?ref=69eb996b2617621c7088e567089a86a6657f2a0f", "patch": "@@ -0,0 +1,11 @@\n+// This is a regression test for issue #89119: an issue in intercrate mode caching.\n+//\n+// It requires multiple crates, of course, but the bug is triggered by the code in the dependency,\n+// not the main crate. This is why this file is empty.\n+//\n+// The auxiliary crate used in the test contains the code minimized from `zvariant-2.8.0`.\n+\n+// check-pass\n+// aux-build: issue_89119_intercrate_caching.rs\n+\n+fn main() {}"}]}