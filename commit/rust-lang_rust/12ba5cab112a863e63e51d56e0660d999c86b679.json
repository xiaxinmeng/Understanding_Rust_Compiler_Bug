{"sha": "12ba5cab112a863e63e51d56e0660d999c86b679", "node_id": "C_kwDOAAsO6NoAKDEyYmE1Y2FiMTEyYTg2M2U2M2U1MWQ1NmUwNjYwZDk5OWM4NmI2Nzk", "commit": {"author": {"name": "Ryo Yoshida", "email": "low.ryoshida@gmail.com", "date": "2023-04-23T15:35:04Z"}, "committer": {"name": "Ryo Yoshida", "email": "low.ryoshida@gmail.com", "date": "2023-04-24T03:39:48Z"}, "message": "Register obligations during path inference", "tree": {"sha": "36aed3475f8a7905028b5e6f2691c22e3ad49bb9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/36aed3475f8a7905028b5e6f2691c22e3ad49bb9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/12ba5cab112a863e63e51d56e0660d999c86b679", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEEkSbsQIURluxz4rzf4laYqTBYYXEFAmRF+gQACgkQ4laYqTBY\nYXG3dQ//SJylSe99TycuvZeym+ARvhKOpYkRkIv3Er65rd8RmzvZy8lcpfjnkbCO\nNtP87mookm1/MbjAdC/nUWm9WZUt2rk1JQBlE3MEDRZFxSHRUCqPBNUnVl5Ij8CF\nq7g+TI6nRXyzjwkvuyaJlIrq8dVqTI2a51t8/IDNN4Nxqm1WUEeO4LzrXSn6wPp2\nfOMqae4OjBgfTvXux02fbn/gNK88mXDBQ1XdM2m4upaMS1EFnB7yjj0sqPLtIlg8\nmcQFy9pu7gHEPJFy7T+7DKpK7WQU8r/NLyN3hMQaQcCtustYhOLZrBIx6r+3ZGaz\nvygf3Mq/J1U6rmshGifs83LZyiag5K1hW7j+q3M6CTIaN/EMGZcyqInxmhGUrjvb\nT68V04uESpKNWI7lhQVtatJWcTnrJXG0CT+3RcYUXOiwlg0EuZVglpUZFZC9mAgm\nWJXJzTlGNI0hFmhj7dPm2/WePKfdsI+iYwyQFgNOdz25G0s80t1Z1KYdNdb3kVC7\nN8sAHJKD9hDnof7jEzx1B8jE/dYIDwAeYFVZYe6iUYmOZ1c3E3+RBvK9OhzVkBNU\n2e20p/qH7qB2hZ+lKPL9ydTHxZtSk684MdJ4GGJ/+npLDHpu24G2WgUlxjsij6TE\n9OJ69rhkwQzMKtT8DkEkeVrMxy6hUlrMpEWOUjd1a4RpCEOGg7o=\n=Mmm4\n-----END PGP SIGNATURE-----", "payload": "tree 36aed3475f8a7905028b5e6f2691c22e3ad49bb9\nparent c6aea8c2f995858bd6221530fb364dcb488ccc15\nauthor Ryo Yoshida <low.ryoshida@gmail.com> 1682264104 +0900\ncommitter Ryo Yoshida <low.ryoshida@gmail.com> 1682307588 +0900\n\nRegister obligations during path inference\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/12ba5cab112a863e63e51d56e0660d999c86b679", "html_url": "https://github.com/rust-lang/rust/commit/12ba5cab112a863e63e51d56e0660d999c86b679", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/12ba5cab112a863e63e51d56e0660d999c86b679/comments", "author": {"login": "lowr", "id": 24381114, "node_id": "MDQ6VXNlcjI0MzgxMTE0", "avatar_url": "https://avatars.githubusercontent.com/u/24381114?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lowr", "html_url": "https://github.com/lowr", "followers_url": "https://api.github.com/users/lowr/followers", "following_url": "https://api.github.com/users/lowr/following{/other_user}", "gists_url": "https://api.github.com/users/lowr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lowr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lowr/subscriptions", "organizations_url": "https://api.github.com/users/lowr/orgs", "repos_url": "https://api.github.com/users/lowr/repos", "events_url": "https://api.github.com/users/lowr/events{/privacy}", "received_events_url": "https://api.github.com/users/lowr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lowr", "id": 24381114, "node_id": "MDQ6VXNlcjI0MzgxMTE0", "avatar_url": "https://avatars.githubusercontent.com/u/24381114?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lowr", "html_url": "https://github.com/lowr", "followers_url": "https://api.github.com/users/lowr/followers", "following_url": "https://api.github.com/users/lowr/following{/other_user}", "gists_url": "https://api.github.com/users/lowr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lowr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lowr/subscriptions", "organizations_url": "https://api.github.com/users/lowr/orgs", "repos_url": "https://api.github.com/users/lowr/repos", "events_url": "https://api.github.com/users/lowr/events{/privacy}", "received_events_url": "https://api.github.com/users/lowr/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c6aea8c2f995858bd6221530fb364dcb488ccc15", "url": "https://api.github.com/repos/rust-lang/rust/commits/c6aea8c2f995858bd6221530fb364dcb488ccc15", "html_url": "https://github.com/rust-lang/rust/commit/c6aea8c2f995858bd6221530fb364dcb488ccc15"}], "stats": {"total": 169, "additions": 132, "deletions": 37}, "files": [{"sha": "97924569ccc0dea7a83d2a2f067ebbb020fceb6e", "filename": "crates/hir-ty/src/builder.rs", "status": "modified", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/12ba5cab112a863e63e51d56e0660d999c86b679/crates%2Fhir-ty%2Fsrc%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12ba5cab112a863e63e51d56e0660d999c86b679/crates%2Fhir-ty%2Fsrc%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fbuilder.rs?ref=12ba5cab112a863e63e51d56e0660d999c86b679", "patch": "@@ -18,7 +18,6 @@ use crate::{\n     consteval::unknown_const_as_generic, db::HirDatabase, infer::unify::InferenceTable, primitive,\n     to_assoc_type_id, to_chalk_trait_id, utils::generics, Binders, BoundVar, CallableSig,\n     GenericArg, Interner, ProjectionTy, Substitution, TraitRef, Ty, TyDefId, TyExt, TyKind,\n-    ValueTyDefId,\n };\n \n #[derive(Debug, Clone, PartialEq, Eq)]\n@@ -362,21 +361,4 @@ impl TyBuilder<Binders<Ty>> {\n     pub fn impl_self_ty(db: &dyn HirDatabase, def: hir_def::ImplId) -> TyBuilder<Binders<Ty>> {\n         TyBuilder::subst_for_def(db, def, None).with_data(db.impl_self_ty(def))\n     }\n-\n-    pub fn value_ty(\n-        db: &dyn HirDatabase,\n-        def: ValueTyDefId,\n-        parent_subst: Option<Substitution>,\n-    ) -> TyBuilder<Binders<Ty>> {\n-        let poly_value_ty = db.value_ty(def);\n-        let id = match def.to_generic_def_id() {\n-            Some(id) => id,\n-            None => {\n-                // static items\n-                assert!(parent_subst.is_none());\n-                return TyBuilder::new_empty(poly_value_ty);\n-            }\n-        };\n-        TyBuilder::subst_for_def(db, id, parent_subst).with_data(poly_value_ty)\n-    }\n }"}, {"sha": "4affe7424e1f72f92ebd39dd94a010d5318eb62b", "filename": "crates/hir-ty/src/infer.rs", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/12ba5cab112a863e63e51d56e0660d999c86b679/crates%2Fhir-ty%2Fsrc%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12ba5cab112a863e63e51d56e0660d999c86b679/crates%2Fhir-ty%2Fsrc%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer.rs?ref=12ba5cab112a863e63e51d56e0660d999c86b679", "patch": "@@ -16,7 +16,10 @@\n use std::sync::Arc;\n use std::{convert::identity, ops::Index};\n \n-use chalk_ir::{cast::Cast, DebruijnIndex, Mutability, Safety, Scalar, TypeFlags};\n+use chalk_ir::{\n+    cast::Cast, fold::TypeFoldable, interner::HasInterner, DebruijnIndex, Mutability, Safety,\n+    Scalar, TypeFlags,\n+};\n use either::Either;\n use hir_def::{\n     body::Body,\n@@ -798,7 +801,10 @@ impl<'a> InferenceContext<'a> {\n         self.table.insert_type_vars_shallow(ty)\n     }\n \n-    fn insert_type_vars(&mut self, ty: Ty) -> Ty {\n+    fn insert_type_vars<T>(&mut self, ty: T) -> T\n+    where\n+        T: HasInterner<Interner = Interner> + TypeFoldable<Interner>,\n+    {\n         self.table.insert_type_vars(ty)\n     }\n \n@@ -875,7 +881,10 @@ impl<'a> InferenceContext<'a> {\n     /// type annotation (e.g. from a let type annotation, field type or function\n     /// call). `make_ty` handles this already, but e.g. for field types we need\n     /// to do it as well.\n-    fn normalize_associated_types_in(&mut self, ty: Ty) -> Ty {\n+    fn normalize_associated_types_in<T>(&mut self, ty: T) -> T\n+    where\n+        T: HasInterner<Interner = Interner> + TypeFoldable<Interner>,\n+    {\n         self.table.normalize_associated_types_in(ty)\n     }\n "}, {"sha": "95a20f983f1b4058d0b4e29a800512b7d7ea18d8", "filename": "crates/hir-ty/src/infer/path.rs", "status": "modified", "additions": 77, "deletions": 14, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/12ba5cab112a863e63e51d56e0660d999c86b679/crates%2Fhir-ty%2Fsrc%2Finfer%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12ba5cab112a863e63e51d56e0660d999c86b679/crates%2Fhir-ty%2Fsrc%2Finfer%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer%2Fpath.rs?ref=12ba5cab112a863e63e51d56e0660d999c86b679", "patch": "@@ -4,7 +4,7 @@ use chalk_ir::cast::Cast;\n use hir_def::{\n     path::{Path, PathSegment},\n     resolver::{ResolveValueResult, TypeNs, ValueNs},\n-    AdtId, AssocItemId, EnumVariantId, ItemContainerId, Lookup,\n+    AdtId, AssocItemId, EnumVariantId, GenericDefId, ItemContainerId, Lookup,\n };\n use hir_expand::name::Name;\n use stdx::never;\n@@ -13,22 +13,33 @@ use crate::{\n     builder::ParamKind,\n     consteval,\n     method_resolution::{self, VisibleFromModule},\n+    to_chalk_trait_id,\n     utils::generics,\n     InferenceDiagnostic, Interner, Substitution, TraitRefExt, Ty, TyBuilder, TyExt, TyKind,\n     ValueTyDefId,\n };\n \n use super::{ExprOrPatId, InferenceContext, TraitRef};\n \n-impl<'a> InferenceContext<'a> {\n+impl InferenceContext<'_> {\n     pub(super) fn infer_path(&mut self, path: &Path, id: ExprOrPatId) -> Option<Ty> {\n-        let ty = self.resolve_value_path(path, id)?;\n-        let ty = self.insert_type_vars(ty);\n+        let (value_def, generic_def, substs) = match self.resolve_value_path(path, id)? {\n+            ValuePathResolution::GenericDef(value_def, generic_def, substs) => {\n+                (value_def, generic_def, substs)\n+            }\n+            ValuePathResolution::NonGeneric(ty) => return Some(ty),\n+        };\n+        let substs = self.insert_type_vars(substs);\n+        let substs = self.normalize_associated_types_in(substs);\n+\n+        self.add_required_obligations_for_value_path(generic_def, &substs);\n+\n+        let ty = self.db.value_ty(value_def).substitute(Interner, &substs);\n         let ty = self.normalize_associated_types_in(ty);\n         Some(ty)\n     }\n \n-    fn resolve_value_path(&mut self, path: &Path, id: ExprOrPatId) -> Option<Ty> {\n+    fn resolve_value_path(&mut self, path: &Path, id: ExprOrPatId) -> Option<ValuePathResolution> {\n         let (value, self_subst) = if let Some(type_ref) = path.type_anchor() {\n             let last = path.segments().last()?;\n \n@@ -56,9 +67,9 @@ impl<'a> InferenceContext<'a> {\n             }\n         };\n \n-        let typable: ValueTyDefId = match value {\n+        let value_def = match value {\n             ValueNs::LocalBinding(pat) => match self.result.type_of_binding.get(pat) {\n-                Some(ty) => return Some(ty.clone()),\n+                Some(ty) => return Some(ValuePathResolution::NonGeneric(ty.clone())),\n                 None => {\n                     never!(\"uninferred pattern?\");\n                     return None;\n@@ -82,36 +93,81 @@ impl<'a> InferenceContext<'a> {\n                 let substs = generics.placeholder_subst(self.db);\n                 let ty = self.db.impl_self_ty(impl_id).substitute(Interner, &substs);\n                 if let Some((AdtId::StructId(struct_id), substs)) = ty.as_adt() {\n-                    let ty = self.db.value_ty(struct_id.into()).substitute(Interner, &substs);\n-                    return Some(ty);\n+                    return Some(ValuePathResolution::GenericDef(\n+                        struct_id.into(),\n+                        struct_id.into(),\n+                        substs.clone(),\n+                    ));\n                 } else {\n                     // FIXME: report error, invalid Self reference\n                     return None;\n                 }\n             }\n-            ValueNs::GenericParam(it) => return Some(self.db.const_param_ty(it)),\n+            ValueNs::GenericParam(it) => {\n+                return Some(ValuePathResolution::NonGeneric(self.db.const_param_ty(it)))\n+            }\n         };\n \n         let ctx = crate::lower::TyLoweringContext::new(self.db, &self.resolver);\n-        let substs = ctx.substs_from_path(path, typable, true);\n+        let substs = ctx.substs_from_path(path, value_def, true);\n         let substs = substs.as_slice(Interner);\n         let parent_substs = self_subst.or_else(|| {\n-            let generics = generics(self.db.upcast(), typable.to_generic_def_id()?);\n+            let generics = generics(self.db.upcast(), value_def.to_generic_def_id()?);\n             let parent_params_len = generics.parent_generics()?.len();\n             let parent_args = &substs[substs.len() - parent_params_len..];\n             Some(Substitution::from_iter(Interner, parent_args))\n         });\n         let parent_substs_len = parent_substs.as_ref().map_or(0, |s| s.len(Interner));\n         let mut it = substs.iter().take(substs.len() - parent_substs_len).cloned();\n-        let ty = TyBuilder::value_ty(self.db, typable, parent_substs)\n+\n+        let Some(generic_def) = value_def.to_generic_def_id() else {\n+            // `value_def` is the kind of item that can never be generic (i.e. statics, at least\n+            // currently). We can just skip the binders to get its type.\n+            let (ty, binders) = self.db.value_ty(value_def).into_value_and_skipped_binders();\n+            stdx::always!(\n+                parent_substs.is_none() && binders.is_empty(Interner),\n+                \"non-empty binders for non-generic def\",\n+            );\n+            return Some(ValuePathResolution::NonGeneric(ty));\n+        };\n+        let builder = TyBuilder::subst_for_def(self.db, generic_def, parent_substs);\n+        let substs = builder\n             .fill(|x| {\n                 it.next().unwrap_or_else(|| match x {\n                     ParamKind::Type => self.result.standard_types.unknown.clone().cast(Interner),\n                     ParamKind::Const(ty) => consteval::unknown_const_as_generic(ty.clone()),\n                 })\n             })\n             .build();\n-        Some(ty)\n+\n+        Some(ValuePathResolution::GenericDef(value_def, generic_def, substs))\n+    }\n+\n+    fn add_required_obligations_for_value_path(&mut self, def: GenericDefId, subst: &Substitution) {\n+        let predicates = self.db.generic_predicates(def);\n+        for predicate in predicates.iter() {\n+            let (predicate, binders) =\n+                predicate.clone().substitute(Interner, &subst).into_value_and_skipped_binders();\n+            // Quantified where clauses are not yet handled.\n+            stdx::always!(binders.is_empty(Interner));\n+            self.push_obligation(predicate.cast(Interner));\n+        }\n+\n+        // We need to add `Self: Trait` obligation when `def` is a trait assoc item.\n+        let container = match def {\n+            GenericDefId::FunctionId(id) => id.lookup(self.db.upcast()).container,\n+            GenericDefId::ConstId(id) => id.lookup(self.db.upcast()).container,\n+            _ => return,\n+        };\n+\n+        if let ItemContainerId::TraitId(trait_) = container {\n+            let param_len = generics(self.db.upcast(), def).len_self();\n+            let parent_subst =\n+                Substitution::from_iter(Interner, subst.iter(Interner).skip(param_len));\n+            let trait_ref =\n+                TraitRef { trait_id: to_chalk_trait_id(trait_), substitution: parent_subst };\n+            self.push_obligation(trait_ref.cast(Interner));\n+        }\n     }\n \n     fn resolve_assoc_item(\n@@ -307,3 +363,10 @@ impl<'a> InferenceContext<'a> {\n         Some((ValueNs::EnumVariantId(variant), subst.clone()))\n     }\n }\n+\n+enum ValuePathResolution {\n+    // It's awkward to wrap a single ID in two enums, but we need both and this saves fallible\n+    // conversion between them + `unwrap()`.\n+    GenericDef(ValueTyDefId, GenericDefId, Substitution),\n+    NonGeneric(Ty),\n+}"}, {"sha": "2988c710398c060052ab2108a58736a26b515523", "filename": "crates/hir-ty/src/infer/unify.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/12ba5cab112a863e63e51d56e0660d999c86b679/crates%2Fhir-ty%2Fsrc%2Finfer%2Funify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12ba5cab112a863e63e51d56e0660d999c86b679/crates%2Fhir-ty%2Fsrc%2Finfer%2Funify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer%2Funify.rs?ref=12ba5cab112a863e63e51d56e0660d999c86b679", "patch": "@@ -231,7 +231,10 @@ impl<'a> InferenceTable<'a> {\n     /// type annotation (e.g. from a let type annotation, field type or function\n     /// call). `make_ty` handles this already, but e.g. for field types we need\n     /// to do it as well.\n-    pub(crate) fn normalize_associated_types_in(&mut self, ty: Ty) -> Ty {\n+    pub(crate) fn normalize_associated_types_in<T>(&mut self, ty: T) -> T\n+    where\n+        T: HasInterner<Interner = Interner> + TypeFoldable<Interner>,\n+    {\n         fold_tys(\n             ty,\n             |ty, _| match ty.kind(Interner) {\n@@ -720,7 +723,10 @@ impl<'a> InferenceTable<'a> {\n         }\n     }\n \n-    pub(super) fn insert_type_vars(&mut self, ty: Ty) -> Ty {\n+    pub(super) fn insert_type_vars<T>(&mut self, ty: T) -> T\n+    where\n+        T: HasInterner<Interner = Interner> + TypeFoldable<Interner>,\n+    {\n         fold_tys_and_consts(\n             ty,\n             |x, _| match x {"}, {"sha": "829a6ab189ecc1a4a2cb51aeddde5d2d3770cba6", "filename": "crates/hir-ty/src/tests/traits.rs", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/12ba5cab112a863e63e51d56e0660d999c86b679/crates%2Fhir-ty%2Fsrc%2Ftests%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12ba5cab112a863e63e51d56e0660d999c86b679/crates%2Fhir-ty%2Fsrc%2Ftests%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Ftests%2Ftraits.rs?ref=12ba5cab112a863e63e51d56e0660d999c86b679", "patch": "@@ -4375,3 +4375,38 @@ fn derive_macro_bounds() {\n         \"#,\n     );\n }\n+\n+#[test]\n+fn trait_obligations_should_be_registered_during_path_inference() {\n+    check_types(\n+        r#\"\n+//- minicore: fn, from\n+struct S<T>(T);\n+fn map<T, U, F: FnOnce(T) -> S<U>>(_: T, _: F) -> U { loop {} }\n+\n+fn test(v: S<i32>) {\n+    let res = map(v, Into::into);\n+      //^^^ i32\n+}\n+\"#,\n+    );\n+}\n+\n+#[test]\n+fn fn_obligation_should_be_registered_during_path_inference() {\n+    check_types(\n+        r#\"\n+//- minicore: fn, from\n+struct S<T>(T);\n+impl<T> S<T> {\n+    fn foo<U: Into<S<T>>>(_: U) -> Self { loop {} }\n+}\n+fn map<T, U, F: FnOnce(T) -> U>(_: T, _: F) -> U { loop {} }\n+\n+fn test(v: S<i32>) {\n+    let res = map(v, S::foo);\n+      //^^^ S<i32>\n+}\n+\"#,\n+    );\n+}"}]}