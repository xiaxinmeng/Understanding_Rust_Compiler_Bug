{"sha": "cf9ed08a5091733b6b0c6cc38e53542b05e8dd04", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNmOWVkMDhhNTA5MTczM2I2YjBjNmNjMzhlNTM1NDJiMDVlOGRkMDQ=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-06-19T10:24:42Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-06-19T10:29:19Z"}, "message": "Revert previous 6 commits. Hopefully put out Windows fire.\n\nRevert \"rustc: Export only what's needed from middle::ty\"\n\nThis reverts commit 4255d58aa5db2a05362c4435a0e807205e1b8ed7.\n\nRevert \"rustc: Make name resolution errors less fatal\"\n\nThis reverts commit b8ab9ea89c16c60237e7660804f4321f59ae0435.\n\nRevert \"rustc: Make import resolution errors less fatal\"\n\nThis reverts commit 92a8ae94b971206bf0502da3dc5f416fcb24cc36.\n\nRevert \"rustc: Export only what's used from middle::resolve\"\n\nThis reverts commit 4539a2cf7ad99851a165c98ed2f4e4a475cffd7d.\n\nRevert \"rustc: Re-introduce session.span_err, session.err\"\n\nThis reverts commit 7fe9a88e31ae07f2fd89f6715efedd7e3edf49e6.\n\nRevert \"rustc: Rename session.span_err -> span_fatal, err -> fatal\"\n\nThis reverts commit c394a7f49ac29a099994e243017065de2ff97f2a.", "tree": {"sha": "a0a59ac42d7565aaf1d49aa8fbeb62479373c1ab", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a0a59ac42d7565aaf1d49aa8fbeb62479373c1ab"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cf9ed08a5091733b6b0c6cc38e53542b05e8dd04", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cf9ed08a5091733b6b0c6cc38e53542b05e8dd04", "html_url": "https://github.com/rust-lang/rust/commit/cf9ed08a5091733b6b0c6cc38e53542b05e8dd04", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cf9ed08a5091733b6b0c6cc38e53542b05e8dd04/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4255d58aa5db2a05362c4435a0e807205e1b8ed7", "url": "https://api.github.com/repos/rust-lang/rust/commits/4255d58aa5db2a05362c4435a0e807205e1b8ed7", "html_url": "https://github.com/rust-lang/rust/commit/4255d58aa5db2a05362c4435a0e807205e1b8ed7"}], "stats": {"total": 640, "additions": 191, "deletions": 449}, "files": [{"sha": "15a30ea072893c8c263d4ed44c5d4c7136b58756", "filename": "src/comp/back/link.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cf9ed08a5091733b6b0c6cc38e53542b05e8dd04/src%2Fcomp%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf9ed08a5091733b6b0c6cc38e53542b05e8dd04/src%2Fcomp%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fback%2Flink.rs?ref=cf9ed08a5091733b6b0c6cc38e53542b05e8dd04", "patch": "@@ -33,8 +33,8 @@ tag output_type {\n fn llvm_err(session::session sess, str msg) {\n     auto buf = llvm::LLVMRustGetLastError();\n     if (buf as uint == 0u) {\n-        sess.fatal(msg);\n-    } else { sess.fatal(msg + \": \" + str::str_from_cstr(buf)); }\n+        sess.err(msg);\n+    } else { sess.err(msg + \": \" + str::str_from_cstr(buf)); }\n     fail;\n }\n \n@@ -276,7 +276,7 @@ fn get_crate_meta_export(&session::session sess, &ast::crate c, str k,\n         }\n         case (1u) { ret v.(0).node.value; }\n         case (_) {\n-            sess.span_fatal(v.(1).span, #fmt(\"duplicate meta '%s'\", k));\n+            sess.span_err(v.(1).span, #fmt(\"duplicate meta '%s'\", k));\n         }\n     }\n }"}, {"sha": "abcaa07241d6da381674a160744b243888db7bb5", "filename": "src/comp/driver/rustc.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/cf9ed08a5091733b6b0c6cc38e53542b05e8dd04/src%2Fcomp%2Fdriver%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf9ed08a5091733b6b0c6cc38e53542b05e8dd04/src%2Fcomp%2Fdriver%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fdriver%2Frustc.rs?ref=cf9ed08a5091733b6b0c6cc38e53542b05e8dd04", "patch": "@@ -59,7 +59,7 @@ fn parse_input(session::session sess, parser::parser p, str input) ->\n             parser::parse_crate_from_crate_file(p)\n         } else if (str::ends_with(input, \".rs\")) {\n             parser::parse_crate_from_source_file(p)\n-        } else { sess.fatal(\"unknown input file type: \" + input); fail };\n+        } else { sess.err(\"unknown input file type: \" + input); fail };\n }\n \n fn time[T](bool do_it, str what, fn() -> T  thunk) -> T {\n@@ -272,7 +272,7 @@ fn build_session(@session::options sopts) -> session::session {\n     auto target_crate_num = 0;\n     auto sess =\n         session::session(target_crate_num, target_cfg, sopts, crate_cache,\n-                         front::codemap::new_codemap(), 0u);\n+                         front::codemap::new_codemap());\n     ret sess;\n }\n \n@@ -282,7 +282,7 @@ fn parse_pretty(session::session sess, &str name) -> pp_mode {\n     } else if (str::eq(name, \"typed\")) {\n         ret ppm_typed;\n     } else if (str::eq(name, \"identified\")) { ret ppm_identified; }\n-    sess.fatal(\"argument to `pretty` must be one of `normal`, `typed`, or \" +\n+    sess.err(\"argument to `pretty` must be one of `normal`, `typed`, or \" +\n                  \"`identified`\");\n }\n \n@@ -321,16 +321,16 @@ fn main(vec[str] args) {\n     auto glue = opt_present(match, \"glue\");\n     if (glue) {\n         if (n_inputs > 0u) {\n-            sess.fatal(\"No input files allowed with --glue.\");\n+            sess.err(\"No input files allowed with --glue.\");\n         }\n         auto out = option::from_maybe[str](\"glue.bc\", output_file);\n         middle::trans::make_common_glue(sess, out);\n         ret;\n     }\n     if (n_inputs == 0u) {\n-        sess.fatal(\"No input filename given.\");\n+        sess.err(\"No input filename given.\");\n     } else if (n_inputs > 1u) {\n-        sess.fatal(\"Multiple input filenames provided.\");\n+        sess.err(\"Multiple input filenames provided.\");\n     }\n     auto ifile = match.free.(0);\n     let str saved_out_filename = \"\";"}, {"sha": "9c810e30baf9d22c7162137087086c185964fd1c", "filename": "src/comp/driver/session.rs", "status": "modified", "additions": 5, "deletions": 19, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/cf9ed08a5091733b6b0c6cc38e53542b05e8dd04/src%2Fcomp%2Fdriver%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf9ed08a5091733b6b0c6cc38e53542b05e8dd04/src%2Fcomp%2Fdriver%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fdriver%2Fsession.rs?ref=cf9ed08a5091733b6b0c6cc38e53542b05e8dd04", "patch": "@@ -66,34 +66,20 @@ obj session(ast::crate_num cnum,\n             @config targ_cfg,\n             @options opts,\n             map::hashmap[int, crate_metadata] crates,\n-            codemap::codemap cm,\n-            mutable uint err_count) {\n+            codemap::codemap cm) {\n     fn get_targ_cfg() -> @config { ret targ_cfg; }\n     fn get_opts() -> @options { ret opts; }\n     fn get_targ_crate_num() -> ast::crate_num { ret cnum; }\n-    fn span_fatal(span sp, str msg) -> ! {\n+    fn span_err(span sp, str msg) -> ! {\n         // FIXME: Use constants, but rustboot doesn't know how to export them.\n \n         emit_diagnostic(some(sp), msg, \"error\", 9u8, cm);\n         fail;\n     }\n-    fn fatal(str msg) -> ! {\n+    fn err(str msg) -> ! {\n         emit_diagnostic(none[span], msg, \"error\", 9u8, cm);\n         fail;\n     }\n-    fn span_err(span sp, str msg) {\n-        emit_diagnostic(some(sp), msg, \"error\", 9u8, cm);\n-        err_count += 1u;\n-    }\n-    fn err(span sp, str msg) {\n-        emit_diagnostic(some(sp), msg, \"error\", 9u8, cm);\n-        err_count += 1u;\n-    }\n-    fn abort_if_errors() {\n-        if (err_count > 0u) {\n-            self.fatal(\"aborting due to previous errors\");\n-        }\n-    }\n     fn span_warn(span sp, str msg) {\n         // FIXME: Use constants, but rustboot doesn't know how to export them.\n \n@@ -108,10 +94,10 @@ obj session(ast::crate_num cnum,\n         emit_diagnostic(some(sp), msg, \"note\", 10u8, cm);\n     }\n     fn span_bug(span sp, str msg) -> ! {\n-        self.span_fatal(sp, #fmt(\"internal compiler error %s\", msg));\n+        self.span_err(sp, #fmt(\"internal compiler error %s\", msg));\n     }\n     fn bug(str msg) -> ! {\n-        self.fatal(#fmt(\"internal compiler error %s\", msg));\n+        self.err(#fmt(\"internal compiler error %s\", msg));\n     }\n     fn span_unimpl(span sp, str msg) -> ! {\n         self.span_bug(sp, \"unimplemented \" + msg);"}, {"sha": "33681eeed6306cbd4cc5a6e06f3dccecd894b7be", "filename": "src/comp/front/eval.rs", "status": "modified", "additions": 20, "deletions": 23, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/cf9ed08a5091733b6b0c6cc38e53542b05e8dd04/src%2Fcomp%2Ffront%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf9ed08a5091733b6b0c6cc38e53542b05e8dd04/src%2Fcomp%2Ffront%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Feval.rs?ref=cf9ed08a5091733b6b0c6cc38e53542b05e8dd04", "patch": "@@ -63,15 +63,15 @@ fn lookup(session::session sess, env e, span sp, ident i) -> val {\n     for (tup(ident, val) pair in e) {\n         if (str::eq(i, pair._0)) { ret pair._1; }\n     }\n-    sess.span_fatal(sp, \"unknown variable: \" + i)\n+    sess.span_err(sp, \"unknown variable: \" + i)\n }\n \n fn eval_lit(ctx cx, span sp, @ast::lit lit) -> val {\n     alt (lit.node) {\n         case (ast::lit_bool(?b)) { val_bool(b) }\n         case (ast::lit_int(?i)) { val_int(i) }\n         case (ast::lit_str(?s, _)) { val_str(s) }\n-        case (_) { cx.sess.span_fatal(sp, \"evaluating unsupported literal\") }\n+        case (_) { cx.sess.span_err(sp, \"evaluating unsupported literal\") }\n     }\n }\n \n@@ -82,18 +82,18 @@ fn eval_expr(ctx cx, env e, @ast::expr x) -> val {\n                     vec::len[@ast::ty](pth.node.types) == 0u) {\n                 ret lookup(cx.sess, e, x.span, pth.node.idents.(0));\n             }\n-            cx.sess.span_fatal(x.span, \"evaluating structured path-name\");\n+            cx.sess.span_err(x.span, \"evaluating structured path-name\");\n         }\n         case (ast::expr_lit(?lit, _)) { ret eval_lit(cx, x.span, lit); }\n         case (ast::expr_unary(?op, ?a, _)) {\n             auto av = eval_expr(cx, e, a);\n             alt (op) {\n                 case (ast::not) {\n                     if (val_is_bool(av)) { ret val_bool(!val_as_bool(av)); }\n-                    cx.sess.span_fatal(x.span, \"bad types in '!' expression\");\n+                    cx.sess.span_err(x.span, \"bad types in '!' expression\");\n                 }\n                 case (_) {\n-                    cx.sess.span_fatal(x.span, \"evaluating unsupported unop\");\n+                    cx.sess.span_err(x.span, \"evaluating unsupported unop\");\n                 }\n             }\n         }\n@@ -108,45 +108,43 @@ fn eval_expr(ctx cx, env e, @ast::expr x) -> val {\n                     if (val_is_str(av) && val_is_str(bv)) {\n                         ret val_str(val_as_str(av) + val_as_str(bv));\n                     }\n-                    cx.sess.span_fatal(x.span, \"bad types in '+' expression\");\n+                    cx.sess.span_err(x.span, \"bad types in '+' expression\");\n                 }\n                 case (ast::sub) {\n                     if (val_is_int(av) && val_is_int(bv)) {\n                         ret val_int(val_as_int(av) - val_as_int(bv));\n                     }\n-                    cx.sess.span_fatal(x.span, \"bad types in '-' expression\");\n+                    cx.sess.span_err(x.span, \"bad types in '-' expression\");\n                 }\n                 case (ast::mul) {\n                     if (val_is_int(av) && val_is_int(bv)) {\n                         ret val_int(val_as_int(av) * val_as_int(bv));\n                     }\n-                    cx.sess.span_fatal(x.span, \"bad types in '*' expression\");\n+                    cx.sess.span_err(x.span, \"bad types in '*' expression\");\n                 }\n                 case (ast::div) {\n                     if (val_is_int(av) && val_is_int(bv)) {\n                         ret val_int(val_as_int(av) / val_as_int(bv));\n                     }\n-                    cx.sess.span_fatal(x.span, \"bad types in '/' expression\");\n+                    cx.sess.span_err(x.span, \"bad types in '/' expression\");\n                 }\n                 case (ast::rem) {\n                     if (val_is_int(av) && val_is_int(bv)) {\n                         ret val_int(val_as_int(av) % val_as_int(bv));\n                     }\n-                    cx.sess.span_fatal(x.span, \"bad types in '%' expression\");\n+                    cx.sess.span_err(x.span, \"bad types in '%' expression\");\n                 }\n                 case (ast::and) {\n                     if (val_is_bool(av) && val_is_bool(bv)) {\n                         ret val_bool(val_as_bool(av) && val_as_bool(bv));\n                     }\n-                    cx.sess.span_fatal(x.span,\n-                                       \"bad types in '&&' expression\");\n+                    cx.sess.span_err(x.span, \"bad types in '&&' expression\");\n                 }\n                 case (ast::or) {\n                     if (val_is_bool(av) && val_is_bool(bv)) {\n                         ret val_bool(val_as_bool(av) || val_as_bool(bv));\n                     }\n-                    cx.sess.span_fatal(x.span,\n-                                       \"bad types in '||' expression\");\n+                    cx.sess.span_err(x.span, \"bad types in '||' expression\");\n                 }\n                 case (ast::eq) {\n                     ret val_bool(val_eq(cx.sess, x.span, av, bv));\n@@ -155,13 +153,12 @@ fn eval_expr(ctx cx, env e, @ast::expr x) -> val {\n                     ret val_bool(!val_eq(cx.sess, x.span, av, bv));\n                 }\n                 case (_) {\n-                    cx.sess.span_fatal(x.span,\n-                                       \"evaluating unsupported binop\");\n+                    cx.sess.span_err(x.span, \"evaluating unsupported binop\");\n                 }\n             }\n         }\n         case (_) {\n-            cx.sess.span_fatal(x.span, \"evaluating unsupported expression\");\n+            cx.sess.span_err(x.span, \"evaluating unsupported expression\");\n         }\n     }\n     fail;\n@@ -174,7 +171,7 @@ fn val_eq(session::session sess, span sp, val av, val bv) -> bool {\n         val_as_int(av) == val_as_int(bv)\n     } else if (val_is_str(av) && val_is_str(bv)) {\n         str::eq(val_as_str(av), val_as_str(bv))\n-    } else { sess.span_fatal(sp, \"bad types in comparison\") }\n+    } else { sess.span_err(sp, \"bad types in comparison\") }\n }\n \n fn eval_crate_directives(ctx cx, env e, vec[@ast::crate_directive] cdirs,\n@@ -203,7 +200,7 @@ fn eval_crate_directive_block(ctx cx, env e, &ast::block blk, str prefix,\n                 eval_crate_directive(cx, e, cdir, prefix, view_items, items);\n             }\n             case (_) {\n-                cx.sess.span_fatal(s.span,\n+                cx.sess.span_err(s.span,\n                                  \"unsupported stmt in crate-directive block\");\n             }\n         }\n@@ -217,7 +214,7 @@ fn eval_crate_directive_expr(ctx cx, env e, @ast::expr x, str prefix,\n         case (ast::expr_if(?cond, ?thn, ?elopt, _)) {\n             auto cv = eval_expr(cx, e, cond);\n             if (!val_is_bool(cv)) {\n-                cx.sess.span_fatal(x.span, \"bad cond type in 'if'\");\n+                cx.sess.span_err(x.span, \"bad cond type in 'if'\");\n             }\n             if (val_as_bool(cv)) {\n                 ret eval_crate_directive_block(cx, e, thn, prefix, view_items,\n@@ -252,18 +249,18 @@ fn eval_crate_directive_expr(ctx cx, env e, @ast::expr x, str prefix,\n                                                        items);\n                     }\n                     case (_) {\n-                        cx.sess.span_fatal(arm.pat.span,\n+                        cx.sess.span_err(arm.pat.span,\n                                          \"bad pattern type in 'alt'\");\n                     }\n                 }\n             }\n-            cx.sess.span_fatal(x.span, \"no cases matched in 'alt'\");\n+            cx.sess.span_err(x.span, \"no cases matched in 'alt'\");\n         }\n         case (ast::expr_block(?block, _)) {\n             ret eval_crate_directive_block(cx, e, block, prefix, view_items,\n                                            items);\n         }\n-        case (_) { cx.sess.span_fatal(x.span, \"unsupported expr type\"); }\n+        case (_) { cx.sess.span_err(x.span, \"unsupported expr type\"); }\n     }\n }\n "}, {"sha": "cc8762aee8b4e76d943d2f4789c2b1b420e35cf3", "filename": "src/comp/front/ext.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/cf9ed08a5091733b6b0c6cc38e53542b05e8dd04/src%2Fcomp%2Ffront%2Fext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf9ed08a5091733b6b0c6cc38e53542b05e8dd04/src%2Fcomp%2Ffront%2Fext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fext.rs?ref=cf9ed08a5091733b6b0c6cc38e53542b05e8dd04", "patch": "@@ -31,23 +31,21 @@ type next_ann_fn = fn() -> ast::ann ;\n // Provides a limited set of services necessary for syntax extensions\n // to do their thing\n type ext_ctxt =\n-    rec(span_msg_fn span_fatal,\n-        span_msg_fn span_unimpl,\n-        next_ann_fn next_ann);\n+    rec(span_msg_fn span_err, span_msg_fn span_unimpl, next_ann_fn next_ann);\n \n fn mk_ctxt(parser parser) -> ext_ctxt {\n     auto sess = parser.get_session();\n-    fn ext_span_fatal_(session sess, span sp, str msg) -> ! {\n-        sess.span_fatal(sp, msg);\n+    fn ext_span_err_(session sess, span sp, str msg) -> ! {\n+        sess.span_err(sp, msg);\n     }\n-    auto ext_span_fatal = bind ext_span_fatal_(sess, _, _);\n+    auto ext_span_err = bind ext_span_err_(sess, _, _);\n     fn ext_span_unimpl_(session sess, span sp, str msg) -> ! {\n         sess.span_unimpl(sp, msg);\n     }\n     auto ext_span_unimpl = bind ext_span_unimpl_(sess, _, _);\n     fn ext_next_ann_(parser parser) -> ast::ann { parser.get_ann() }\n     auto ext_next_ann = bind ext_next_ann_(parser);\n-    ret rec(span_fatal=ext_span_fatal,\n+    ret rec(span_err=ext_span_err,\n             span_unimpl=ext_span_unimpl,\n             next_ann=ext_next_ann);\n }"}, {"sha": "dca7b90f7abf166d7747d84934e96b8c5ddc685a", "filename": "src/comp/front/extenv.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cf9ed08a5091733b6b0c6cc38e53542b05e8dd04/src%2Fcomp%2Ffront%2Fextenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf9ed08a5091733b6b0c6cc38e53542b05e8dd04/src%2Fcomp%2Ffront%2Fextenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fextenv.rs?ref=cf9ed08a5091733b6b0c6cc38e53542b05e8dd04", "patch": "@@ -16,7 +16,7 @@ export expand_syntax_ext;\n fn expand_syntax_ext(&ext_ctxt cx, common::span sp, &vec[@ast::expr] args,\n                      option::t[str] body) -> @ast::expr {\n     if (vec::len[@ast::expr](args) != 1u) {\n-        cx.span_fatal(sp, \"malformed #env call\");\n+        cx.span_err(sp, \"malformed #env call\");\n     }\n     // FIXME: if this was more thorough it would manufacture an\n     // option::t[str] rather than just an maybe-empty string.\n@@ -35,10 +35,10 @@ fn expr_to_str(&ext_ctxt cx, @ast::expr expr) -> str {\n         case (ast::expr_lit(?l, _)) {\n             alt (l.node) {\n                 case (ast::lit_str(?s, _)) { ret s; }\n-                case (_) { cx.span_fatal(l.span, \"malformed #env call\"); }\n+                case (_) { cx.span_err(l.span, \"malformed #env call\"); }\n             }\n         }\n-        case (_) { cx.span_fatal(expr.span, \"malformed #env call\"); }\n+        case (_) { cx.span_err(expr.span, \"malformed #env call\"); }\n     }\n }\n "}, {"sha": "557d84342b85825d454f07a71c4869fb9d30c887", "filename": "src/comp/front/extfmt.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/cf9ed08a5091733b6b0c6cc38e53542b05e8dd04/src%2Fcomp%2Ffront%2Fextfmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf9ed08a5091733b6b0c6cc38e53542b05e8dd04/src%2Fcomp%2Ffront%2Fextfmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fextfmt.rs?ref=cf9ed08a5091733b6b0c6cc38e53542b05e8dd04", "patch": "@@ -18,14 +18,14 @@ export expand_syntax_ext;\n fn expand_syntax_ext(&ext_ctxt cx, common::span sp, &vec[@ast::expr] args,\n                      option::t[str] body) -> @ast::expr {\n     if (vec::len[@ast::expr](args) == 0u) {\n-        cx.span_fatal(sp, \"#fmt requires a format string\");\n+        cx.span_err(sp, \"#fmt requires a format string\");\n     }\n     auto fmt = expr_to_str(cx, args.(0));\n     auto fmtspan = args.(0).span;\n     log \"Format string:\";\n     log fmt;\n     fn parse_fmt_err_(&ext_ctxt cx, common::span sp, str msg) -> ! {\n-        cx.span_fatal(sp, msg);\n+        cx.span_err(sp, msg);\n     }\n     auto parse_fmt_err = bind parse_fmt_err_(cx, fmtspan, _);\n     auto pieces = parse_fmt_string(fmt, parse_fmt_err);\n@@ -40,10 +40,10 @@ fn expr_to_str(&ext_ctxt cx, @ast::expr expr) -> str {\n         case (ast::expr_lit(?l, _)) {\n             alt (l.node) {\n                 case (ast::lit_str(?s, _)) { ret s; }\n-                case (_) { cx.span_fatal(l.span, err_msg); }\n+                case (_) { cx.span_err(l.span, err_msg); }\n             }\n         }\n-        case (_) { cx.span_fatal(expr.span, err_msg); }\n+        case (_) { cx.span_err(expr.span, err_msg); }\n     }\n }\n \n@@ -236,14 +236,14 @@ fn pieces_to_expr(&ext_ctxt cx, common::span sp, vec[piece] pieces,\n                 case (flag_left_justify) { }\n                 case (flag_sign_always) {\n                     if (!is_signed_type(cnv)) {\n-                        cx.span_fatal(sp,\n+                        cx.span_err(sp,\n                                     \"+ flag only valid in \" +\n                                         \"signed #fmt conversion\");\n                     }\n                 }\n                 case (flag_space_for_sign) {\n                     if (!is_signed_type(cnv)) {\n-                        cx.span_fatal(sp,\n+                        cx.span_err(sp,\n                                     \"space flag only valid in \" +\n                                         \"signed #fmt conversions\");\n                     }\n@@ -361,7 +361,7 @@ fn pieces_to_expr(&ext_ctxt cx, common::span sp, vec[piece] pieces,\n             case (piece_conv(?conv)) {\n                 n += 1u;\n                 if (n >= nargs) {\n-                    cx.span_fatal(sp,\n+                    cx.span_err(sp,\n                                 \"not enough arguments to #fmt \" +\n                                     \"for the given format string\");\n                 }\n@@ -376,7 +376,7 @@ fn pieces_to_expr(&ext_ctxt cx, common::span sp, vec[piece] pieces,\n     auto expected_nargs = n + 1u; // n conversions + the fmt string\n \n     if (expected_nargs < nargs) {\n-        cx.span_fatal(sp,\n+        cx.span_err(sp,\n                     #fmt(\"too many arguments to #fmt. found %u, expected %u\",\n                          nargs, expected_nargs));\n     }"}, {"sha": "9ae3afad0c6e3b072d95bedc6d46ccca969fde70", "filename": "src/comp/front/lexer.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cf9ed08a5091733b6b0c6cc38e53542b05e8dd04/src%2Fcomp%2Ffront%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf9ed08a5091733b6b0c6cc38e53542b05e8dd04/src%2Fcomp%2Ffront%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Flexer.rs?ref=cf9ed08a5091733b6b0c6cc38e53542b05e8dd04", "patch": "@@ -75,7 +75,7 @@ fn new_reader(session sess, io::reader rdr, codemap::filemap filemap,\n         fn get_interner() -> @interner::interner[str] { ret itr; }\n         fn get_col() -> uint { ret col; }\n         fn get_filemap() -> codemap::filemap { ret fm; }\n-        fn err(str m) { sess.span_fatal(rec(lo=chpos, hi=chpos), m); }\n+        fn err(str m) { sess.span_err(rec(lo=chpos, hi=chpos), m); }\n     }\n     auto file = str::unsafe_from_bytes(rdr.read_whole_stream());\n     let vec[str] strs = [];"}, {"sha": "e986ab482d024a2f285a1da292cab2063a61ddaf", "filename": "src/comp/front/parser.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cf9ed08a5091733b6b0c6cc38e53542b05e8dd04/src%2Fcomp%2Ffront%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf9ed08a5091733b6b0c6cc38e53542b05e8dd04/src%2Fcomp%2Ffront%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fparser.rs?ref=cf9ed08a5091733b6b0c6cc38e53542b05e8dd04", "patch": "@@ -78,7 +78,7 @@ fn new_parser(session::session sess, eval::env env, ast::def_id initial_def,\n             lo = rdr.get_mark_chpos();\n             hi = rdr.get_chpos();\n         }\n-        fn err(str m) -> ! { sess.span_fatal(rec(lo=lo, hi=hi), m); }\n+        fn err(str m) -> ! { sess.span_err(rec(lo=lo, hi=hi), m); }\n         fn restrict(restriction r) { res = r; }\n         fn get_restriction() -> restriction { ret res; }\n         fn get_session() -> session::session { ret sess; }\n@@ -353,7 +353,7 @@ fn parse_ty_field(&parser p) -> ast::ty_field {\n fn ident_index(&parser p, &vec[ast::arg] args, &ast::ident i) -> uint {\n     auto j = 0u;\n     for (ast::arg a in args) { if (a.ident == i) { ret j; } j += 1u; }\n-    p.get_session().span_fatal(p.get_span(),\n+    p.get_session().span_err(p.get_span(),\n                              \"Unbound variable \" + i + \" in constraint arg\");\n }\n "}, {"sha": "ae2621ecf94b7d58374425da5647a4b7df300bee", "filename": "src/comp/middle/alias.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/cf9ed08a5091733b6b0c6cc38e53542b05e8dd04/src%2Fcomp%2Fmiddle%2Falias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf9ed08a5091733b6b0c6cc38e53542b05e8dd04/src%2Fcomp%2Fmiddle%2Falias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Falias.rs?ref=cf9ed08a5091733b6b0c6cc38e53542b05e8dd04", "patch": "@@ -92,7 +92,7 @@ fn visit_expr(@ctx cx, &@ast::expr ex, &scope sc, &vt[scope] v) {\n                 case (some(?ex)) {\n                     auto root = expr_root(*cx, ex, false);\n                     if (mut_field(root.ds)) {\n-                        cx.tcx.sess.span_fatal(ex.span,\n+                        cx.tcx.sess.span_err(ex.span,\n                                              \"result of put must be\" +\n                                                  \" immutably rooted\");\n                     }\n@@ -148,7 +148,7 @@ fn check_call(&ctx cx, &@ast::expr f, &vec[@ast::expr] args, &scope sc) ->\n                             auto m =\n                                 \"passing a temporary value or \\\n                                  immutable field by mutable alias\";\n-                            cx.tcx.sess.span_fatal(arg.span, m);\n+                            cx.tcx.sess.span_err(arg.span, m);\n                         }\n                     }\n                 }\n@@ -171,7 +171,7 @@ fn check_call(&ctx cx, &@ast::expr f, &vec[@ast::expr] args, &scope sc) ->\n         alt (f.node) {\n             case (ast::expr_path(_, ?ann)) {\n                 if (def_is_local(cx.tcx.def_map.get(ann.id), true)) {\n-                    cx.tcx.sess.span_fatal(f.span,\n+                    cx.tcx.sess.span_err(f.span,\n                                          #fmt(\"function may alias with \\\n                          argument %u, which is not immutably rooted\",\n                                               unsafe_t_offsets.(0)));\n@@ -190,7 +190,7 @@ fn check_call(&ctx cx, &@ast::expr f, &vec[@ast::expr] args, &scope sc) ->\n             if (i != offset &&\n                     ty_can_unsafely_include(cx, unsafe, arg_t.ty, mut_alias))\n                {\n-                cx.tcx.sess.span_fatal(args.(i).span,\n+                cx.tcx.sess.span_err(args.(i).span,\n                                      #fmt(\"argument %u may alias with \\\n                      argument %u, which is not immutably rooted\",\n                                           i, offset));\n@@ -208,7 +208,7 @@ fn check_call(&ctx cx, &@ast::expr f, &vec[@ast::expr] args, &scope sc) ->\n             }\n         }\n         if (mut_alias_to_root) {\n-            cx.tcx.sess.span_fatal(args.(root._0).span,\n+            cx.tcx.sess.span_err(args.(root._0).span,\n                                  \"passing a mutable alias to a \\\n                  variable that roots another alias\");\n         }\n@@ -377,10 +377,10 @@ fn check_assign(&@ctx cx, &@ast::expr dest, &@ast::expr src, &scope sc,\n         case (ast::expr_path(?p, ?ann)) {\n             auto dnum = ast::def_id_of_def(cx.tcx.def_map.get(ann.id))._1;\n             if (is_immutable_alias(cx, sc, dnum)) {\n-                cx.tcx.sess.span_fatal(dest.span,\n+                cx.tcx.sess.span_err(dest.span,\n                                      \"assigning to immutable alias\");\n             } else if (is_immutable_objfield(cx, dnum)) {\n-                cx.tcx.sess.span_fatal(dest.span,\n+                cx.tcx.sess.span_err(dest.span,\n                                      \"assigning to immutable obj field\");\n             }\n             auto var_t = ty::expr_ty(*cx.tcx, dest);\n@@ -394,15 +394,15 @@ fn check_assign(&@ctx cx, &@ast::expr dest, &@ast::expr src, &scope sc,\n         case (_) {\n             auto root = expr_root(*cx, dest, false);\n             if (vec::len(root.ds) == 0u) {\n-                cx.tcx.sess.span_fatal(dest.span, \"assignment to non-lvalue\");\n+                cx.tcx.sess.span_err(dest.span, \"assignment to non-lvalue\");\n             } else if (!root.ds.(0).mut) {\n                 auto name =\n                     alt (root.ds.(0).kind) {\n                         case (unbox) { \"box\" }\n                         case (field) { \"field\" }\n                         case (index) { \"vec content\" }\n                     };\n-                cx.tcx.sess.span_fatal(dest.span,\n+                cx.tcx.sess.span_err(dest.span,\n                                      \"assignment to immutable \" + name);\n             }\n             visit_expr(cx, dest, sc, v);\n@@ -441,7 +441,7 @@ fn test_scope(&ctx cx, &scope sc, &restrict r, &ast::path p) {\n                     tup(sp, \"taking the value of \" + ast::path_name(vpt))\n                 }\n             };\n-        cx.tcx.sess.span_fatal(msg._0,\n+        cx.tcx.sess.span_err(msg._0,\n                              msg._1 + \" will invalidate alias \" +\n                                  ast::path_name(p) + \", which is still used\");\n     }"}, {"sha": "24384f9ccc62e24e445aea05d1c60f05dd8c01ef", "filename": "src/comp/middle/resolve.rs", "status": "modified", "additions": 65, "deletions": 142, "changes": 207, "blob_url": "https://github.com/rust-lang/rust/blob/cf9ed08a5091733b6b0c6cc38e53542b05e8dd04/src%2Fcomp%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf9ed08a5091733b6b0c6cc38e53542b05e8dd04/src%2Fcomp%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fresolve.rs?ref=cf9ed08a5091733b6b0c6cc38e53542b05e8dd04", "patch": "@@ -25,9 +25,6 @@ import std::option::none;\n import std::str;\n import std::vec;\n \n-export resolve_crate;\n-export def_map;\n-export crate_map;\n \n // Resolving happens in two passes. The first pass collects defids of all\n // (internal) imports and modules, so that they can be looked up when needed,\n@@ -236,11 +233,8 @@ fn map_crate(&@env e, &@ast::crate c) {\n             case (\n                  //if it really is a glob import, that is\n                  ast::view_item_import_glob(?path, _)) {\n-                auto imp = follow_import(*e, sc, path, vi.span);\n-                if (option::is_some(imp)) {\n-                    find_mod(e, sc).glob_imports +=\n-                        [option::get(imp)];\n-                }\n+                find_mod(e, sc).glob_imports +=\n+                    [follow_import(*e, sc, path, vi.span)];\n             }\n             case (_) { }\n         }\n@@ -254,7 +248,6 @@ fn resolve_imports(&env e) {\n             case (resolved(_, _, _)) { }\n         }\n     }\n-    e.sess.abort_if_errors();\n }\n \n fn resolve_names(&@env e, &@ast::crate c) {\n@@ -269,15 +262,14 @@ fn resolve_names(&@env e, &@ast::crate c) {\n              visit_fn=bind visit_fn_with_scope(e, _, _, _, _, _, _, _, _)\n              with *visit::default_visitor());\n     visit::visit_crate(*c, cons(scope_crate(c), @nil), visit::vtor(v));\n-    e.sess.abort_if_errors();\n-\n     fn walk_expr(@env e, &@ast::expr exp, &scopes sc, &vt[scopes] v) {\n         visit_expr_with_scope(exp, sc, v);\n         alt (exp.node) {\n             case (ast::expr_path(?p, ?a)) {\n-                maybe_insert(e, a.id,\n-                             lookup_path_strict(*e, sc, exp.span,\n-                                                p.node.idents, ns_value));\n+                auto df =\n+                    lookup_path_strict(*e, sc, exp.span, p.node.idents,\n+                                       ns_value);\n+                e.def_map.insert(a.id, df);\n             }\n             case (_) { }\n         }\n@@ -286,17 +278,19 @@ fn resolve_names(&@env e, &@ast::crate c) {\n         visit::visit_ty(t, sc, v);\n         alt (t.node) {\n             case (ast::ty_path(?p, ?a)) {\n-                maybe_insert(e, a.id,\n-                             lookup_path_strict(*e, sc, t.span,\n-                                                p.node.idents, ns_type));\n+                auto new_def =\n+                    lookup_path_strict(*e, sc, t.span, p.node.idents,\n+                                       ns_type);\n+                e.def_map.insert(a.id, new_def);\n             }\n             case (_) { }\n         }\n     }\n     fn walk_constr(@env e, &@ast::constr c, &scopes sc, &vt[scopes] v) {\n-        maybe_insert(e, c.node.ann.id,\n-                     lookup_path_strict(*e, sc, c.span,\n-                                        c.node.path.node.idents, ns_value));\n+        auto new_def =\n+            lookup_path_strict(*e, sc, c.span, c.node.path.node.idents,\n+                               ns_value);\n+        e.def_map.insert(c.node.ann.id, new_def);\n     }\n     fn walk_arm(@env e, &ast::arm a, &scopes sc, &vt[scopes] v) {\n         walk_pat(*e, sc, a.pat);\n@@ -308,32 +302,21 @@ fn resolve_names(&@env e, &@ast::crate c) {\n                 auto fnd =\n                     lookup_path_strict(e, sc, p.span, p.node.idents,\n                                        ns_value);\n-                if (option::is_some(fnd)) {\n-                    alt (option::get(fnd)) {\n-                        case (ast::def_variant(?did, ?vid)) {\n-                            e.def_map.insert(a.id, option::get(fnd));\n-                            for (@ast::pat child in children) {\n-                                walk_pat(e, sc, child);\n-                            }\n-                        }\n-                        case (_) {\n-                            e.sess.span_err(p.span,\n-                                            \"not a tag variant: \" +\n+                alt (fnd) {\n+                    case (ast::def_variant(?did, ?vid)) {\n+                        e.def_map.insert(a.id, fnd);\n+                    }\n+                    case (_) {\n+                        e.sess.span_err(p.span,\n+                                        \"not a tag variant: \" +\n                                             ast::path_name(p));\n-                        }\n                     }\n                 }\n+                for (@ast::pat child in children) { walk_pat(e, sc, child); }\n             }\n             case (_) { }\n         }\n     }\n-\n-    fn maybe_insert(@env e, uint id,\n-                    option::t[def] def) {\n-        if (option::is_some(def)) {\n-            e.def_map.insert(id, option::get(def));\n-        }\n-    }\n }\n \n \n@@ -383,51 +366,42 @@ fn visit_expr_with_scope(&@ast::expr x, &scopes sc, &vt[scopes] v) {\n     visit::visit_expr(x, new_sc, v);\n }\n \n-fn follow_import(&env e, &scopes sc,\n-                 vec[ident] path, &span sp) -> option::t[def] {\n+fn follow_import(&env e, &scopes sc, vec[ident] path, &span sp) -> def {\n     auto path_len = vec::len(path);\n     auto dcur = lookup_in_scope_strict(e, sc, sp, path.(0), ns_module);\n     auto i = 1u;\n-    while (true && option::is_some(dcur)) {\n+    while (true) {\n         if (i == path_len) { break; }\n         dcur =\n-            lookup_in_mod_strict(e, option::get(dcur),\n-                                 sp, path.(i), ns_module, outside);\n+            lookup_in_mod_strict(e, dcur, sp, path.(i), ns_module, outside);\n         i += 1u;\n     }\n-    if (i == path_len) {\n-        alt (option::get(dcur)) {\n-            case (ast::def_mod(?def_id)) { ret dcur; }\n-            case (ast::def_native_mod(?def_id)) { ret dcur; }\n-            case (_) {\n-                e.sess.span_err(sp,\n-                                str::connect(path, \"::\") +\n+    alt (dcur) {\n+        case (ast::def_mod(?def_id)) { ret dcur; }\n+        case (ast::def_native_mod(?def_id)) { ret dcur; }\n+        case (_) {\n+            e.sess.span_err(sp,\n+                            str::connect(path, \"::\") +\n                                 \" does not name a module.\");\n-                ret none;\n-            }\n         }\n-    } else {\n-        ret none;\n     }\n }\n \n fn resolve_constr(@env e, &def_id d_id, &@ast::constr c, &scopes sc,\n                   &vt[scopes] v) {\n-    auto new_def =\n+    let def new_def =\n         lookup_path_strict(*e, sc, c.span, c.node.path.node.idents, ns_value);\n-    if (option::is_some(new_def)) {\n-        alt (option::get(new_def)) {\n-            case (ast::def_fn(?pred_id)) {\n-                let ty::constr_general[uint] c_ =\n-                    rec(path=c.node.path, args=c.node.args, id=pred_id);\n-                let ty::constr_def new_constr = respan(c.span, c_);\n-                add_constr(e, d_id, new_constr);\n-            }\n-            case (_) {\n-                e.sess.span_err(c.span,\n-                                \"Non-predicate in constraint: \" +\n+    alt (new_def) {\n+        case (ast::def_fn(?pred_id)) {\n+            let ty::constr_general[uint] c_ =\n+                rec(path=c.node.path, args=c.node.args, id=pred_id);\n+            let ty::constr_def new_constr = respan(c.span, c_);\n+            add_constr(e, d_id, new_constr);\n+        }\n+        case (_) {\n+            e.sess.span_err(c.span,\n+                            \"Non-predicate in constraint: \" +\n                                 ty::path_to_str(c.node.path));\n-            }\n         }\n     }\n }\n@@ -460,18 +434,9 @@ fn resolve_import(&env e, &@ast::view_item it, &scopes sc) {\n                  lookup_in_scope(e, next_sc, it.span, end_id, ns_value),\n                  lookup_in_scope(e, next_sc, it.span, end_id, ns_type),\n                  lookup_in_scope(e, next_sc, it.span, end_id, ns_module));\n-        remove_if_unresolved(e.imports, defid._1);\n     } else {\n-        auto dcur = alt(lookup_in_scope(e, sc, it.span, ids.(0), ns_module)) {\n-            case (some(?dcur)) {\n-                dcur\n-            }\n-            case (none) {\n-                unresolved_err(e, it.span, ids.(0), ns_name(ns_module));\n-                remove_if_unresolved(e.imports, defid._1);\n-                ret () // FIXME (issue #521)\n-            }\n-        };\n+        auto dcur =\n+            lookup_in_scope_strict(e, sc, it.span, ids.(0), ns_module);\n         auto i = 1u;\n         while (true) {\n             if (i == n_idents - 1u) {\n@@ -482,21 +447,11 @@ fn resolve_import(&env e, &@ast::view_item it, &scopes sc) {\n                                        outside),\n                          lookup_in_mod(e, dcur, it.span, end_id, ns_module,\n                                        outside));\n-                remove_if_unresolved(e.imports, defid._1);\n                 break;\n             } else {\n-                dcur = alt (lookup_in_mod(e, dcur, it.span, ids.(i),\n-                                          ns_module, outside)) {\n-                    case (some(?dcur)) {\n-                        dcur\n-                    }\n-                    case (none) {\n-                        unresolved_err(e, it.span, ids.(i),\n-                                       ns_name(ns_module));\n-                        remove_if_unresolved(e.imports, defid._1);\n-                        ret () // FIXME (issue #521)\n-                    }\n-                };\n+                dcur =\n+                    lookup_in_mod_strict(e, dcur, it.span, ids.(i), ns_module,\n+                                         outside);\n                 i += 1u;\n             }\n         }\n@@ -506,24 +461,9 @@ fn resolve_import(&env e, &@ast::view_item it, &scopes sc) {\n                 &option::t[def] md) {\n         if (option::is_none(val) && option::is_none(typ) &&\n                 option::is_none(md)) {\n-            unresolved_err(e, sp, id, \"import\");\n-        } else {\n-            e.imports.insert(defid._1, resolved(val, typ, md));\n-        }\n-    }\n-    fn remove_if_unresolved(hashmap[ast::def_num, import_state] imports,\n-                            ast::def_num def_num) {\n-        // If we couldn't resolve the import, don't leave it in a partially\n-        // resolved state, to avoid having it reported later as a cyclic\n-        // import\n-        if (imports.contains_key(def_num)) {\n-            alt (imports.get(def_num)) {\n-                case (resolving(_)) {\n-                    imports.remove(def_num);\n-                }\n-                case (_) { }\n-            }\n+            unresolved(e, sp, id, \"import\");\n         }\n+        e.imports.insert(defid._1, resolved(val, typ, md));\n     }\n }\n \n@@ -537,42 +477,31 @@ fn ns_name(namespace ns) -> str {\n     }\n }\n \n-fn unresolved_err(&env e, &span sp, &ident id, &str kind) {\n-    e.sess.span_err(sp, mk_unresolved_msg(id, kind));\n+fn unresolved(&env e, &span sp, &ident id, &str kind) -> ! {\n+    e.sess.span_err(sp, \"unresolved \" + kind + \": \" + id);\n }\n \n-fn unresolved_fatal(&env e, &span sp, &ident id, &str kind) -> ! {\n-    e.sess.span_fatal(sp, mk_unresolved_msg(id, kind));\n-}\n-\n-fn mk_unresolved_msg(&ident id, &str kind) -> str {\n-    ret #fmt(\"unresolved %s: %s\", kind, id);\n-}\n \n // Lookup helpers\n fn lookup_path_strict(&env e, &scopes sc, &span sp, vec[ident] idents,\n-                      namespace ns) -> option::t[def] {\n+                      namespace ns) -> def {\n     auto n_idents = vec::len(idents);\n     auto headns = if (n_idents == 1u) { ns } else { ns_module };\n     auto dcur = lookup_in_scope_strict(e, sc, sp, idents.(0), headns);\n     auto i = 1u;\n-    while (i < n_idents && option::is_some(dcur)) {\n+    while (i < n_idents) {\n         auto curns = if (n_idents == i + 1u) { ns } else { ns_module };\n-        dcur = lookup_in_mod_strict(e, option::get(dcur),\n-                                    sp, idents.(i), curns, outside);\n+        dcur = lookup_in_mod_strict(e, dcur, sp, idents.(i), curns, outside);\n         i += 1u;\n     }\n     ret dcur;\n }\n \n fn lookup_in_scope_strict(&env e, scopes sc, &span sp, &ident id,\n-                          namespace ns) -> option::t[def] {\n+                          namespace ns) -> def {\n     alt (lookup_in_scope(e, sc, sp, id, ns)) {\n-        case (none) {\n-            unresolved_err(e, sp, id, ns_name(ns));\n-            ret none;\n-        }\n-        case (some(?d)) { ret some(d); }\n+        case (none) { unresolved(e, sp, id, ns_name(ns)); }\n+        case (some(?d)) { ret d; }\n     }\n }\n \n@@ -670,7 +599,7 @@ fn lookup_in_scope(&env e, scopes sc, &span sp, &ident id, namespace ns) ->\n                     auto df = option::get(fnd);\n                     if (left_fn && def_is_local(df) ||\n                             left_fn_level2 && def_is_obj_field(df)) {\n-                        e.sess.span_fatal(sp,\n+                        e.sess.span_err(sp,\n                                         \"attempted dynamic \\\n                                          environment-capture\");\n                     }\n@@ -822,13 +751,10 @@ fn found_def_item(&@ast::item i, namespace ns) -> option::t[def] {\n }\n \n fn lookup_in_mod_strict(&env e, def m, &span sp, &ident id, namespace ns,\n-                        dir dr) -> option::t[def] {\n+                        dir dr) -> def {\n     alt (lookup_in_mod(e, m, sp, id, ns, dr)) {\n-        case (none) {\n-            unresolved_err(e, sp, id, ns_name(ns));\n-            ret none;\n-        }\n-        case (some(?d)) { ret some(d); }\n+        case (none) { unresolved(e, sp, id, ns_name(ns)); }\n+        case (some(?d)) { ret d; }\n     }\n }\n \n@@ -880,10 +806,7 @@ fn lookup_import(&env e, def_id defid, namespace ns) -> option::t[def] {\n             resolve_import(e, item, sc);\n             ret lookup_import(e, defid, ns);\n         }\n-        case (resolving(?sp)) {\n-            e.sess.span_err(sp, \"cyclic import\");\n-            ret none;\n-        }\n+        case (resolving(?sp)) { e.sess.span_err(sp, \"cyclic import\"); }\n         case (resolved(?val, ?typ, ?md)) {\n             ret alt (ns) {\n                     case (ns_value) { val }\n@@ -958,7 +881,7 @@ fn lookup_glob_in_mod(&env e, @indexed_mod info, &span sp, &ident id,\n                     }\n                 }\n             }\n-            e.sess.span_fatal(sp,\n+            e.sess.span_err(sp,\n                             \"'\" + id + \"' is glob-imported from\" +\n                                 \" multiple different modules.\");\n         }\n@@ -1163,7 +1086,7 @@ fn check_mod_name(&env e, &ident name, list[mod_index_entry] entries) {\n     auto saw_type = false;\n     auto saw_value = false;\n     fn dup(&env e, &span sp, &str word, &ident name) {\n-        e.sess.span_fatal(sp, \"duplicate definition of \" + word + name);\n+        e.sess.span_err(sp, \"duplicate definition of \" + word + name);\n     }\n     while (true) {\n         alt (entries) {\n@@ -1299,7 +1222,7 @@ fn checker(&env e, str kind) -> checker {\n fn add_name(&checker ch, &span sp, &ident id) {\n     for (ident s in ch.seen) {\n         if (str::eq(s, id)) {\n-            ch.sess.span_fatal(sp, \"duplicate \" + ch.kind + \" name: \" + id);\n+            ch.sess.span_err(sp, \"duplicate \" + ch.kind + \" name: \" + id);\n         }\n     }\n     vec::push(ch.seen, id);"}, {"sha": "f0c477f8fea42454dcd67bfae0cd9d73975a642d", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/cf9ed08a5091733b6b0c6cc38e53542b05e8dd04/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf9ed08a5091733b6b0c6cc38e53542b05e8dd04/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=cf9ed08a5091733b6b0c6cc38e53542b05e8dd04", "patch": "@@ -677,7 +677,7 @@ fn T_opaque_chan_ptr() -> TypeRef { ret T_ptr(T_i8()); }\n // TODO: Enforce via a predicate.\n fn type_of(&@crate_ctxt cx, &span sp, &ty::t t) -> TypeRef {\n     if (ty::type_has_dynamic_size(cx.tcx, t)) {\n-        cx.sess.span_fatal(sp,\n+        cx.sess.span_err(sp,\n                          \"type_of() called on a type with dynamic size: \" +\n                              ty_to_str(cx.tcx, t));\n     }\n@@ -881,7 +881,7 @@ fn type_of_inner(&@crate_ctxt cx, &span sp, &ty::t t) -> TypeRef {\n             llty = abs_pair;\n         }\n         case (ty::ty_var(_)) {\n-            cx.tcx.sess.span_fatal(sp, \"trans::type_of called on ty_var\");\n+            cx.tcx.sess.span_err(sp, \"trans::type_of called on ty_var\");\n         }\n         case (ty::ty_param(_)) { llty = T_i8(); }\n         case (ty::ty_type) { llty = T_ptr(T_tydesc(cx.tn)); }\n@@ -1226,7 +1226,7 @@ fn simplify_type(&@crate_ctxt ccx, &ty::t typ) -> ty::t {\n // Computes the size of the data part of a non-dynamically-sized tag.\n fn static_size_of_tag(&@crate_ctxt cx, &span sp, &ty::t t) -> uint {\n     if (ty::type_has_dynamic_size(cx.tcx, t)) {\n-        cx.tcx.sess.span_fatal(sp,\n+        cx.tcx.sess.span_err(sp,\n                              \"dynamically sized type passed to \" +\n                                  \"static_size_of_tag()\");\n     }\n@@ -1236,7 +1236,7 @@ fn static_size_of_tag(&@crate_ctxt cx, &span sp, &ty::t t) -> uint {\n     alt (ty::struct(cx.tcx, t)) {\n         case (ty::ty_tag(?tid_, ?subtys_)) { tid = tid_; subtys = subtys_; }\n         case (_) {\n-            cx.tcx.sess.span_fatal(sp,\n+            cx.tcx.sess.span_err(sp,\n                                  \"non-tag passed to \" +\n                                      \"static_size_of_tag()\");\n         }\n@@ -5983,7 +5983,7 @@ fn trans_log(int lvl, &@block_ctxt cx, &@ast::expr e) -> result {\n             case (_) {\n                 // FIXME: Support these types.\n \n-                cx.fcx.lcx.ccx.sess.span_fatal(e.span,\n+                cx.fcx.lcx.ccx.sess.span_err(e.span,\n                                              \"log called on unsupported type \"\n                                                  +\n                                                  ty_to_str(cx.fcx.lcx.ccx.tcx,\n@@ -6088,7 +6088,7 @@ fn trans_break_cont(&span sp, &@block_ctxt cx, bool to_end) -> result {\n                 alt ({ cleanup_cx.parent }) {\n                     case (parent_some(?cx)) { cleanup_cx = cx; }\n                     case (parent_none) {\n-                        cx.fcx.lcx.ccx.sess.span_fatal(sp,\n+                        cx.fcx.lcx.ccx.sess.span_err(sp,\n                                                      if (to_end) {\n                                                          \"Break\"\n                                                      } else { \"Cont\" } +\n@@ -7621,7 +7621,7 @@ fn decl_fn_and_pair(&@crate_ctxt ccx, &span sp, vec[str] path, str flav,\n     register_fn_pair(ccx, ps, llfty, llfn, id);\n     if (is_main) {\n         if (ccx.main_fn != none[ValueRef]) {\n-            ccx.sess.span_fatal(sp, \"multiple 'main' functions\");\n+            ccx.sess.span_err(sp, \"multiple 'main' functions\");\n         }\n         llvm::LLVMSetLinkage(llfn,\n                              lib::llvm::LLVMExternalLinkage as llvm::Linkage);"}, {"sha": "e7013752ded45337984a5d0c24e2352ca8c755df", "filename": "src/comp/middle/tstate/auxiliary.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/cf9ed08a5091733b6b0c6cc38e53542b05e8dd04/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf9ed08a5091733b6b0c6cc38e53542b05e8dd04/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs?ref=cf9ed08a5091733b6b0c6cc38e53542b05e8dd04", "patch": "@@ -560,7 +560,7 @@ fn expr_to_constr_arg(ty::ctxt tcx, &@expr e) -> @constr_arg_use {\n         }\n         case (expr_lit(?l, _)) { ret @respan(e.span, carg_lit(l)); }\n         case (_) {\n-            tcx.sess.span_fatal(e.span,\n+            tcx.sess.span_err(e.span,\n                               \"Arguments to constrained functions must be \"\n                               + \"literals or local variables\");\n         }\n@@ -587,15 +587,15 @@ fn expr_to_constr(ty::ctxt tcx, &@expr e) -> constr {\n                                            exprs_to_constr_args(tcx, args))));\n                 }\n                 case (_) {\n-                    tcx.sess.span_fatal(operator.span,\n+                    tcx.sess.span_err(operator.span,\n                                       \"Internal error: \" +\n                                           \" ill-formed operator \\\n                                             in predicate\");\n                 }\n             }\n         }\n         case (_) {\n-            tcx.sess.span_fatal(e.span,\n+            tcx.sess.span_err(e.span,\n                               \"Internal error: \" + \" ill-formed predicate\");\n         }\n     }\n@@ -626,8 +626,7 @@ fn substitute_arg(&ty::ctxt cx, &vec[@expr] actuals, @ast::constr_arg a) ->\n             if (i < num_actuals) {\n                 ret expr_to_constr_arg(cx, actuals.(i));\n             } else {\n-                cx.sess.span_fatal(a.span,\n-                                   \"Constraint argument out of bounds\");\n+                cx.sess.span_err(a.span, \"Constraint argument out of bounds\");\n             }\n         }\n         case (carg_base) { ret @respan(a.span, carg_base); }\n@@ -637,7 +636,7 @@ fn substitute_arg(&ty::ctxt cx, &vec[@expr] actuals, @ast::constr_arg a) ->\n \n fn path_to_ident(&ty::ctxt cx, &path p) -> ident {\n     alt (vec::last(p.node.idents)) {\n-        case (none) { cx.sess.span_fatal(p.span, \"Malformed path\"); }\n+        case (none) { cx.sess.span_err(p.span, \"Malformed path\"); }\n         case (some(?i)) { ret i; }\n     }\n }"}, {"sha": "ce170fb1db9e15be27392afa40c7c292b7ff67f9", "filename": "src/comp/middle/tstate/ck.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cf9ed08a5091733b6b0c6cc38e53542b05e8dd04/src%2Fcomp%2Fmiddle%2Ftstate%2Fck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf9ed08a5091733b6b0c6cc38e53542b05e8dd04/src%2Fcomp%2Fmiddle%2Ftstate%2Fck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fck.rs?ref=cf9ed08a5091733b6b0c6cc38e53542b05e8dd04", "patch": "@@ -85,7 +85,7 @@ fn check_states_expr(&fn_ctxt fcx, &@expr e) {\n         s += bitv_to_str(fcx, prec);\n         s += \"\\nPrestate:\\n\";\n         s += bitv_to_str(fcx, pres);\n-        fcx.ccx.tcx.sess.span_fatal(e.span, s);\n+        fcx.ccx.tcx.sess.span_err(e.span, s);\n     }\n }\n \n@@ -114,7 +114,7 @@ fn check_states_stmt(&fn_ctxt fcx, &@stmt s) {\n         ss += bitv_to_str(fcx, prec);\n         ss += \"\\nPrestate: \\n\";\n         ss += bitv_to_str(fcx, pres);\n-        fcx.ccx.tcx.sess.span_fatal(s.span, ss);\n+        fcx.ccx.tcx.sess.span_err(s.span, ss);\n     }\n }\n \n@@ -153,7 +153,7 @@ fn check_states_against_conditions(&fn_ctxt fcx, &_fn f, &ann a,\n                                    \"In function \" + fcx.name +\n                                        \", not all control paths \\\n                                         return a value\");\n-        fcx.ccx.tcx.sess.span_fatal(f.decl.output.span,\n+        fcx.ccx.tcx.sess.span_err(f.decl.output.span,\n                                   \"see declared return type of '\" +\n                                       ty_to_str(*f.decl.output) + \"'\");\n     } else if (f.decl.cf == noreturn) {\n@@ -162,7 +162,7 @@ fn check_states_against_conditions(&fn_ctxt fcx, &_fn f, &ann a,\n         // the fcx.id bit means \"returns\" for a returning fn,\n         // \"diverges\" for a non-returning fn\n         if (!promises(fcx, post, ret_c)) {\n-            fcx.ccx.tcx.sess.span_fatal(f.body.span,\n+            fcx.ccx.tcx.sess.span_err(f.body.span,\n                                       \"In non-returning function \" + fcx.name\n                                           +\n                                           \", some control paths may \\"}, {"sha": "89b375287bebad5bfc4ef2b53027d5bd97ad3ea7", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 7, "deletions": 168, "changes": 175, "blob_url": "https://github.com/rust-lang/rust/blob/cf9ed08a5091733b6b0c6cc38e53542b05e8dd04/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf9ed08a5091733b6b0c6cc38e53542b05e8dd04/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=cf9ed08a5091733b6b0c6cc38e53542b05e8dd04", "patch": "@@ -22,155 +22,6 @@ import middle::metadata;\n import util::common::*;\n import util::data::interner;\n \n-export ann_to_monotype;\n-export ann_to_type;\n-export ann_to_type_params;\n-export ann_to_ty_param_substs_opt_and_ty;\n-export any_item_native;\n-export any_item_rust;\n-export arg;\n-export args_eq;\n-export bind_params_in_type;\n-export block_ty;\n-export constr_def;\n-export constr_general;\n-export constr_table;\n-export count_ty_params;\n-export ctxt;\n-export decl_local_ty;\n-export def_has_ty_params;\n-export eq_ty;\n-export expr_ann;\n-export expr_has_ty_params;\n-export expr_ty;\n-export fold_ty;\n-export field;\n-export field_idx;\n-export field_num;\n-export fm_general;\n-export get_element_type;\n-export hash_ty;\n-export idx_nil;\n-export is_lval;\n-export item_table;\n-export lookup_item_type;\n-export method;\n-export method_idx;\n-export method_ty_to_fn_ty;\n-export mk_bool;\n-export mk_bot;\n-export mk_box;\n-export mk_chan;\n-export mk_char;\n-export mk_ctxt;\n-export mk_float;\n-export mk_fn;\n-export mk_imm_box;\n-export mk_imm_tup;\n-export mk_imm_vec;\n-export mk_int;\n-export mk_istr;\n-export mk_ivec;\n-export mk_mach;\n-export mk_native;\n-export mk_native_fn;\n-export mk_nil;\n-export mk_obj;\n-export mk_param;\n-export mk_port;\n-export mk_ptr;\n-export mk_rec;\n-export mk_str;\n-export mk_tag;\n-export mk_task;\n-export mk_tup;\n-export mk_type;\n-export mk_uint;\n-export mk_var;\n-export mk_vec;\n-export mode;\n-export mo_val;\n-export mo_alias;\n-export mt;\n-export node_type_table;\n-export pat_ann;\n-export pat_ty;\n-export path_to_str;\n-export rename;\n-export ret_ty_of_fn;\n-export ret_ty_of_fn_ty;\n-export ret_ty_to_fn_ty;\n-export sequence_element_type;\n-export sequence_is_interior;\n-export struct;\n-export sort_methods;\n-export stmt_ann;\n-export strip_boxes;\n-export sty;\n-export substitute_type_params;\n-export t;\n-export tag_variants;\n-export tag_variant_with_id;\n-export ty_param_substs_opt_and_ty;\n-export ty_param_count_and_ty;\n-export ty_native_fn;\n-export ty_bool;\n-export ty_bot;\n-export ty_box;\n-export ty_chan;\n-export ty_char;\n-export ty_float;\n-export ty_fn;\n-export ty_fn_abi;\n-export ty_fn_proto;\n-export ty_fn_ret;\n-export ty_int;\n-export ty_istr;\n-export ty_ivec;\n-export ty_machine;\n-export ty_native;\n-export ty_nil;\n-export ty_obj;\n-export ty_param;\n-export ty_port;\n-export ty_ptr;\n-export ty_rec;\n-export ty_str;\n-export ty_tag;\n-export ty_task;\n-export ty_tup;\n-export ty_type;\n-export ty_uint;\n-export ty_var;\n-export ty_var_id;\n-export ty_vec;\n-export ty_param_substs_opt_and_ty_to_monotype;\n-export ty_fn_args;\n-export type_contains_params;\n-export type_contains_vars;\n-export type_err;\n-export type_err_to_str;\n-export type_has_dynamic_size;\n-export type_has_pointers;\n-export type_is_bool;\n-export type_is_bot;\n-export type_is_box;\n-export type_is_boxed;\n-export type_is_chan;\n-export type_is_fp;\n-export type_is_integral;\n-export type_is_native;\n-export type_is_nil;\n-export type_is_scalar;\n-export type_is_sequence;\n-export type_is_signed;\n-export type_is_structural;\n-export type_is_tup_like;\n-export type_owns_heap_mem;\n-export type_param;\n-export unify;\n-export variant_info;\n-export walk_ty;\n \n // Data types\n tag mode { mo_val; mo_alias(bool); }\n@@ -229,6 +80,9 @@ fn method_ty_to_fn_ty(&ctxt cx, method m) -> t {\n \n \n // Never construct these manually. These are interned.\n+//\n+// TODO: It'd be really nice to be able to hide this definition from the\n+// outside world, to enforce the above invariants.\n type raw_t =\n     rec(sty struct,\n         option::t[str] cname,\n@@ -1825,7 +1679,7 @@ fn field_num(&session::session sess, &span sp, &ast::ident id) -> uint {\n     for (u8 c in id) {\n         if (i == 0u) {\n             if (c != '_' as u8) {\n-                sess.span_fatal(sp,\n+                sess.span_err(sp,\n                               \"bad numeric field on tuple: \" +\n                                   \"missing leading underscore\");\n             }\n@@ -1836,7 +1690,7 @@ fn field_num(&session::session sess, &span sp, &ast::ident id) -> uint {\n             } else {\n                 auto s = \"\";\n                 s += str::unsafe_from_byte(c);\n-                sess.span_fatal(sp,\n+                sess.span_err(sp,\n                               \"bad numeric field on tuple: \" +\n                                   \" non-digit character: \" + s);\n             }\n@@ -1850,14 +1704,14 @@ fn field_idx(&session::session sess, &span sp, &ast::ident id,\n              &vec[field] fields) -> uint {\n     let uint i = 0u;\n     for (field f in fields) { if (str::eq(f.ident, id)) { ret i; } i += 1u; }\n-    sess.span_fatal(sp, \"unknown field '\" + id + \"' of record\");\n+    sess.span_err(sp, \"unknown field '\" + id + \"' of record\");\n }\n \n fn method_idx(&session::session sess, &span sp, &ast::ident id,\n               &vec[method] meths) -> uint {\n     let uint i = 0u;\n     for (method m in meths) { if (str::eq(m.ident, id)) { ret i; } i += 1u; }\n-    sess.span_fatal(sp, \"unknown method '\" + id + \"' of obj\");\n+    sess.span_err(sp, \"unknown method '\" + id + \"' of obj\");\n }\n \n fn sort_methods(&vec[method] meths) -> vec[method] {\n@@ -1883,21 +1737,6 @@ fn is_lval(&@ast::expr expr) -> bool {\n //\n //     http://www.cs.man.ac.uk/~hoderk/ubench/unification_full.pdf\n mod unify {\n-\n-    export fixup_result;\n-    export fixup_vars;\n-    export fix_ok;\n-    export fix_err;\n-    export mk_var_bindings;\n-    export resolve_type_bindings;\n-    export resolve_type_structure;\n-    export resolve_type_var;\n-    export result;\n-    export unify;\n-    export ures_ok;\n-    export ures_err;\n-    export var_bindings;\n-\n     tag result { ures_ok(t); ures_err(type_err); }\n     tag union_result { unres_ok; unres_err(type_err); }\n     tag fixup_result {"}, {"sha": "acd38539396544622d99dcf9048d0330ac3d3869", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 40, "deletions": 40, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/cf9ed08a5091733b6b0c6cc38e53542b05e8dd04/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf9ed08a5091733b6b0c6cc38e53542b05e8dd04/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=cf9ed08a5091733b6b0c6cc38e53542b05e8dd04", "patch": "@@ -114,7 +114,7 @@ fn ty_param_count_and_ty_for_def(&@fn_ctxt fcx, &span sp, &ast::def defn) ->\n             ret tup(0u, ty::mk_nil(fcx.ccx.tcx));\n         }\n         case (ast::def_ty(_)) {\n-            fcx.ccx.tcx.sess.span_fatal(sp, \"expected value but found type\");\n+            fcx.ccx.tcx.sess.span_err(sp, \"expected value but found type\");\n         }\n         case (_) {\n             // FIXME: handle other names.\n@@ -152,7 +152,7 @@ fn instantiate_path(&@fn_ctxt fcx, &ast::path pth, &ty_param_count_and_ty tpt,\n         }\n         ty_substs_opt = some[vec[ty::t]](ty_substs);\n         if (ty_param_count == 0u) {\n-            fcx.ccx.tcx.sess.span_fatal(sp,\n+            fcx.ccx.tcx.sess.span_err(sp,\n                                       \"this item does not take type \" +\n                                           \"parameters\");\n             fail;\n@@ -188,7 +188,7 @@ fn structurally_resolved_type(&@fn_ctxt fcx, &span sp, ty::t typ) -> ty::t {\n     alt (r) {\n         case (fix_ok(?typ_s)) { ret typ_s; }\n         case (fix_err(_)) {\n-            fcx.ccx.tcx.sess.span_fatal(sp,\n+            fcx.ccx.tcx.sess.span_err(sp,\n                                       \"the type of this value must be \" +\n                                           \"known in this context\");\n         }\n@@ -219,7 +219,7 @@ fn ast_ty_to_ty(&ty::ctxt tcx, &ty_getter getter, &@ast::ty ast_ty) -> ty::t {\n     alt (tcx.ast_ty_to_ty_cache.find(ast_ty)) {\n         case (some[option::t[ty::t]](some[ty::t](?ty))) { ret ty; }\n         case (some[option::t[ty::t]](none)) {\n-            tcx.sess.span_fatal(ast_ty.span,\n+            tcx.sess.span_err(ast_ty.span,\n                               \"illegal recursive type \" +\n                               \"(insert a tag in the cycle, \" +\n                               \"if this is desired)\");\n@@ -252,7 +252,7 @@ fn ast_ty_to_ty(&ty::ctxt tcx, &ty_getter getter, &@ast::ty ast_ty) -> ty::t {\n         }\n         if (vec::len(param_bindings) !=\n                 ty::count_ty_params(tcx, params_opt_and_ty._1)) {\n-            tcx.sess.span_fatal(sp,\n+            tcx.sess.span_err(sp,\n                               \"Wrong number of type arguments for a\" +\n                                   \" polymorphic tag\");\n         }\n@@ -333,7 +333,7 @@ fn ast_ty_to_ty(&ty::ctxt tcx, &ty_getter getter, &@ast::ty ast_ty) -> ty::t {\n                 }\n                 case (ast::def_ty_arg(?id)) { typ = ty::mk_param(tcx, id); }\n                 case (_) {\n-                    tcx.sess.span_fatal(ast_ty.span,\n+                    tcx.sess.span_err(ast_ty.span,\n                                       \"found type name used as a variable\");\n                 }\n             }\n@@ -508,7 +508,7 @@ mod collect {\n         if (ty::type_has_dynamic_size(cx.tcx, tt)) {\n             alt (ty_mode) {\n                 case (mo_val) {\n-                    cx.tcx.sess.span_fatal(a.ty.span,\n+                    cx.tcx.sess.span_err(a.ty.span,\n                                          \"Dynamically sized arguments \\\n                                           must be passed by alias\");\n                 }\n@@ -916,7 +916,7 @@ mod demand {\n             case (ures_err(?err)) {\n                 auto e_err = resolve_type_vars_if_possible(fcx, expected_1);\n                 auto a_err = resolve_type_vars_if_possible(fcx, actual_1);\n-                fcx.ccx.tcx.sess.span_fatal(sp,\n+                fcx.ccx.tcx.sess.span_err(sp,\n                                           \"mismatched types: expected \" +\n                                               ty_to_str(fcx.ccx.tcx, e_err) +\n                                               \" but found \" +\n@@ -982,7 +982,7 @@ mod writeback {\n         alt (ty::unify::fixup_vars(fcx.ccx.tcx, fcx.var_bindings, typ)) {\n             case (fix_ok(?new_type)) { ret new_type; }\n             case (fix_err(?vid)) {\n-                fcx.ccx.tcx.sess.span_fatal(sp,\n+                fcx.ccx.tcx.sess.span_err(sp,\n                                           \"cannot determine a type \\\n                                            for this expression\");\n             }\n@@ -1026,7 +1026,7 @@ mod writeback {\n                 write::ty_only(fcx.ccx.tcx, l.node.ann.id, lty);\n             }\n             case (fix_err(_)) {\n-                fcx.ccx.tcx.sess.span_fatal(l.span,\n+                fcx.ccx.tcx.sess.span_err(l.span,\n                                           \"cannot determine a type \\\n                                            for this local variable\");\n             }\n@@ -1232,7 +1232,7 @@ fn check_pat(&@fn_ctxt fcx, &@ast::pat pat, ty::t expected) {\n                     // FIXME: Switch expected and actual in this message? I\n                     // can never tell.\n \n-                    fcx.ccx.tcx.sess.span_fatal(pat.span,\n+                    fcx.ccx.tcx.sess.span_err(pat.span,\n                                               #fmt(\"mismatched types: \\\n                                                     expected tag, found %s\",\n                                                    ty_to_str(fcx.ccx.tcx,\n@@ -1271,7 +1271,7 @@ fn check_pat(&@fn_ctxt fcx, &@ast::pat pat, ty::t expected) {\n                                   if (arg_len == 1u) {\n                                       \"\"\n                                   } else { \"s\" });\n-                    fcx.ccx.tcx.sess.span_fatal(pat.span, s);\n+                    fcx.ccx.tcx.sess.span_err(pat.span, s);\n                 }\n                 // TODO: vec::iter2\n \n@@ -1285,7 +1285,7 @@ fn check_pat(&@fn_ctxt fcx, &@ast::pat pat, ty::t expected) {\n                 // TODO (issue #448): Wrap a #fmt string over multiple\n                 // lines...\n \n-                fcx.ccx.tcx.sess.span_fatal(pat.span,\n+                fcx.ccx.tcx.sess.span_err(pat.span,\n                                           #fmt(\"this pattern has %u field%s, \\\n                                                 but the corresponding \\\n                                                 variant has no fields\",\n@@ -1303,7 +1303,7 @@ fn require_impure(&session::session sess, &ast::purity f_purity, &span sp) {\n     alt (f_purity) {\n         case (ast::impure_fn) { ret; }\n         case (ast::pure_fn) {\n-            sess.span_fatal(sp,\n+            sess.span_err(sp,\n                           \"Found impure expression in pure function decl\");\n         }\n     }\n@@ -1328,14 +1328,14 @@ fn require_pure_call(@crate_ctxt ccx, &ast::purity caller_purity,\n                     alt (get_function_purity(ccx, d_id)) {\n                         case (ast::pure_fn) { ret; }\n                         case (_) {\n-                            ccx.tcx.sess.span_fatal(sp,\n+                            ccx.tcx.sess.span_err(sp,\n                                                   \"Pure function calls \\\n                                                    impure function\");\n                         }\n                     }\n                 }\n                 case (_) {\n-                    ccx.tcx.sess.span_fatal(sp,\n+                    ccx.tcx.sess.span_err(sp,\n                                           \"Pure function calls \\\n                                            unknown function\");\n                 }\n@@ -1347,7 +1347,7 @@ fn require_pure_call(@crate_ctxt ccx, &ast::purity caller_purity,\n fn require_pure_function(@crate_ctxt ccx, &ast::def_id d_id, &span sp) {\n     alt (get_function_purity(ccx, d_id)) {\n         case (ast::impure_fn) {\n-            ccx.tcx.sess.span_fatal(sp,\n+            ccx.tcx.sess.span_err(sp,\n                                   \"Found non-predicate in check expression\");\n         }\n         case (_) { ret; }\n@@ -1376,7 +1376,7 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n             case (ty::ty_fn(_, ?arg_tys_0, _, _, _)) { arg_tys = arg_tys_0; }\n             case (ty::ty_native_fn(_, ?arg_tys_0, _)) { arg_tys = arg_tys_0; }\n             case (_) {\n-                fcx.ccx.tcx.sess.span_fatal(f.span,\n+                fcx.ccx.tcx.sess.span_err(f.span,\n                                           \"mismatched types: \\\n                                            expected function or native \\\n                                            function but found \"\n@@ -1388,7 +1388,7 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n         auto expected_arg_count = vec::len[ty::arg](arg_tys);\n         auto supplied_arg_count = vec::len[option::t[@ast::expr]](args);\n         if (expected_arg_count != supplied_arg_count) {\n-            fcx.ccx.tcx.sess.span_fatal(sp,\n+            fcx.ccx.tcx.sess.span_err(sp,\n                                       #fmt(\"this function takes %u \\\n                                             parameter%s but %u parameter%s \\\n                                             supplied\",\n@@ -1474,20 +1474,20 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n                                 if (!ast::is_constraint_arg(operand)) {\n                                     auto s = \"Constraint args must be \\\n                                               slot variables or literals\";\n-                                    fcx.ccx.tcx.sess.span_fatal(e.span, s);\n+                                    fcx.ccx.tcx.sess.span_err(e.span, s);\n                                 }\n                             }\n                             require_pure_function(fcx.ccx, d_id, e.span);\n                          }\n                         case (_) {\n                             auto s = \"In a constraint, expected the \\\n                                       constraint name to be an explicit name\";\n-                            fcx.ccx.tcx.sess.span_fatal(e.span,s);\n+                            fcx.ccx.tcx.sess.span_err(e.span,s);\n                         }\n                     }\n                 }\n                 case (_) {\n-                    fcx.ccx.tcx.sess.span_fatal(e.span,\n+                    fcx.ccx.tcx.sess.span_err(e.span,\n                                               \"check on non-predicate\");\n                 }\n             }\n@@ -1555,15 +1555,15 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n                         case (_) {\n                             auto s = \"dereferencing non-box type: \" +\n                                 ty_to_str(fcx.ccx.tcx, oper_t);\n-                            fcx.ccx.tcx.sess.span_fatal(expr.span, s);\n+                            fcx.ccx.tcx.sess.span_err(expr.span, s);\n                         }\n                     }\n                 }\n                 case (ast::not) {\n                     if (!type_is_integral(fcx, oper.span, oper_t) &&\n                             structure_of(fcx, oper.span, oper_t) !=\n                                 ty::ty_bool) {\n-                        fcx.ccx.tcx.sess.span_fatal(expr.span,\n+                        fcx.ccx.tcx.sess.span_err(expr.span,\n                                                   #fmt(\"mismatched types: \\\n                                                         expected bool or \\\n                                                         integer but found %s\",\n@@ -1588,7 +1588,7 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n             // supplied some, that's an error.\n \n             if (vec::len[@ast::ty](pth.node.types) > 0u) {\n-                fcx.ccx.tcx.sess.span_fatal(expr.span,\n+                fcx.ccx.tcx.sess.span_err(expr.span,\n                                           \"this kind of value does not \\\n                                            take type parameters\");\n             }\n@@ -1607,7 +1607,7 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n                 case (none) {\n                     auto nil = ty::mk_nil(fcx.ccx.tcx);\n                     if (!are_compatible(fcx, fcx.ret_ty, nil)) {\n-                        fcx.ccx.tcx.sess.span_fatal(expr.span,\n+                        fcx.ccx.tcx.sess.span_err(expr.span,\n                                                   \"ret; in function \\\n                                                    returning non-nil\");\n                     }\n@@ -1627,7 +1627,7 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n                 case (none) {\n                     auto nil = ty::mk_nil(fcx.ccx.tcx);\n                     if (!are_compatible(fcx, fcx.ret_ty, nil)) {\n-                        fcx.ccx.tcx.sess.span_fatal(expr.span,\n+                        fcx.ccx.tcx.sess.span_err(expr.span,\n                                                   \"put; in iterator \\\n                                                    yielding non-nil\");\n                     }\n@@ -1696,7 +1696,7 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n                                    but found %s\",\n                                   ty_to_str(fcx.ccx.tcx,\n                                             lhs_t));\n-                    fcx.ccx.tcx.sess.span_fatal(expr.span,s);\n+                    fcx.ccx.tcx.sess.span_err(expr.span,s);\n                 }\n             }\n             write::ty_only_fixup(fcx, a.id, chan_t);\n@@ -1726,7 +1726,7 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n                     elt_ty = ty::mk_mach(fcx.ccx.tcx, util::common::ty_u8);\n                 }\n                 case (_) {\n-                    fcx.ccx.tcx.sess.span_fatal(expr.span,\n+                    fcx.ccx.tcx.sess.span_err(expr.span,\n                                               \"type of for loop iterator \\\n                                                is not a vector or string\");\n                 }\n@@ -1916,7 +1916,7 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n \n             if (!(type_is_scalar(fcx, expr.span, expr_ty(fcx.ccx.tcx, e)) &&\n                       type_is_scalar(fcx, expr.span, t_1))) {\n-                fcx.ccx.tcx.sess.span_fatal(expr.span,\n+                fcx.ccx.tcx.sess.span_err(expr.span,\n                                           \"non-scalar cast: \" +\n                                               ty_to_str(fcx.ccx.tcx,\n                                                         expr_ty(fcx.ccx.tcx,\n@@ -1984,7 +1984,7 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n                     alt (structure_of(fcx, expr.span, bexpr_t)) {\n                         case (ty::ty_rec(?flds)) { base_fields = flds; }\n                         case (_) {\n-                            fcx.ccx.tcx.sess.span_fatal(expr.span,\n+                            fcx.ccx.tcx.sess.span_err(expr.span,\n                                                       \"record update \\\n                                                        non-record base\");\n                         }\n@@ -2000,7 +2000,7 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n                             }\n                         }\n                         if (!found) {\n-                            fcx.ccx.tcx.sess.span_fatal(expr.span,\n+                            fcx.ccx.tcx.sess.span_err(expr.span,\n                                                       \"unknown field in \\\n                                                        record update: \"\n                                                       + f.ident);\n@@ -2018,7 +2018,7 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n                     let uint ix =\n                         ty::field_num(fcx.ccx.tcx.sess, expr.span, field);\n                     if (ix >= vec::len[ty::mt](args)) {\n-                        fcx.ccx.tcx.sess.span_fatal(expr.span,\n+                        fcx.ccx.tcx.sess.span_err(expr.span,\n                                                   \"bad index on tuple\");\n                     }\n                     write::ty_only_fixup(fcx, a.id, args.(ix).ty);\n@@ -2028,7 +2028,7 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n                         ty::field_idx(fcx.ccx.tcx.sess, expr.span, field,\n                                       fields);\n                     if (ix >= vec::len[ty::field](fields)) {\n-                        fcx.ccx.tcx.sess.span_fatal(expr.span,\n+                        fcx.ccx.tcx.sess.span_err(expr.span,\n                                                   \"bad index on record\");\n                     }\n                     write::ty_only_fixup(fcx, a.id, fields.(ix).mt.ty);\n@@ -2038,7 +2038,7 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n                         ty::method_idx(fcx.ccx.tcx.sess, expr.span, field,\n                                        methods);\n                     if (ix >= vec::len[ty::method](methods)) {\n-                        fcx.ccx.tcx.sess.span_fatal(expr.span,\n+                        fcx.ccx.tcx.sess.span_err(expr.span,\n                                                   \"bad index on obj\");\n                     }\n                     auto meth = methods.(ix);\n@@ -2063,7 +2063,7 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n             check_expr(fcx, idx);\n             auto idx_t = expr_ty(fcx.ccx.tcx, idx);\n             if (!type_is_integral(fcx, idx.span, idx_t)) {\n-                fcx.ccx.tcx.sess.span_fatal(idx.span,\n+                fcx.ccx.tcx.sess.span_err(idx.span,\n                                           \"mismatched types: expected \\\n                                            integer but found \"\n                                           + ty_to_str(fcx.ccx.tcx, idx_t));\n@@ -2084,7 +2084,7 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n                     write::ty_only_fixup(fcx, a.id, typ);\n                 }\n                 case (_) {\n-                    fcx.ccx.tcx.sess.span_fatal(expr.span,\n+                    fcx.ccx.tcx.sess.span_err(expr.span,\n                                               \"vector-indexing bad type: \" +\n                                                   ty_to_str(fcx.ccx.tcx,\n                                                             base_t));\n@@ -2105,7 +2105,7 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n                     write::ty_only_fixup(fcx, a.id, ct);\n                 }\n                 case (_) {\n-                    fcx.ccx.tcx.sess.span_fatal(expr.span,\n+                    fcx.ccx.tcx.sess.span_err(expr.span,\n                                               \"bad port type: \" +\n                                                   ty_to_str(fcx.ccx.tcx,\n                                                             port_t));\n@@ -2218,7 +2218,7 @@ fn ast_constr_to_constr(ty::ctxt tcx, &@ast::constr c)\n                                     id=pred_id));\n         }\n         case (_) {\n-            tcx.sess.span_fatal(c.span, \"Predicate \"\n+            tcx.sess.span_err(c.span, \"Predicate \"\n                               + path_to_str(c.node.path)\n                               + \" is unbound or bound to a non-function\");\n         }\n@@ -2339,7 +2339,7 @@ fn check_fn(&@crate_ctxt ccx, &ast::fn_decl decl, ast::proto proto,\n             // per the previous comment, this just checks that the declared\n             // type is bool, and trusts that that's the actual return type.\n             if (!ty::type_is_bool(ccx.tcx, fcx.ret_ty)) {\n-                ccx.tcx.sess.span_fatal(body.span,\n+                ccx.tcx.sess.span_err(body.span,\n                                       \"Non-boolean return type in pred\");\n             }\n         }"}]}