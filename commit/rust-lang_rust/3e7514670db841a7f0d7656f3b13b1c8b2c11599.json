{"sha": "3e7514670db841a7f0d7656f3b13b1c8b2c11599", "node_id": "C_kwDOAAsO6NoAKDNlNzUxNDY3MGRiODQxYTdmMGQ3NjU2ZjNiMTNiMWM4YjJjMTE1OTk", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-03-30T12:28:50Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-03-30T12:28:50Z"}, "message": "Auto merge of #94963 - lcnr:inherent-impls-std, r=oli-obk,m-ou-se\n\nallow arbitrary inherent impls for builtin types in core\n\nPart of https://github.com/rust-lang/compiler-team/issues/487. Slightly adjusted after some talks with `@m-ou-se` about the requirements of `t-libs-api`.\n\nThis adds a crate attribute `#![rustc_coherence_is_core]` which allows arbitrary impls for builtin types in core.\n\nFor other library crates impls for builtin types should be avoided if possible. We do have to allow the existing stable impls however. To prevent us from accidentally adding more of these in the future, there is a second attribute `#[rustc_allow_incoherent_impl]` which has to be added to **all impl items**. This only supports impls for builtin types but can easily be extended to additional types in a future PR.\n\nThis implementation does not check for overlaps in these impls. Perfectly checking that requires us to check the coherence of these incoherent impls in every crate, as two distinct dependencies may add overlapping methods. It should be easy enough to detect if it goes wrong and the attribute is only intended for use inside of std.\n\nThe first two commits are mostly unrelated cleanups.", "tree": {"sha": "ea65f9f3d772de91ee27bf207de8cbf7ff997e8f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ea65f9f3d772de91ee27bf207de8cbf7ff997e8f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3e7514670db841a7f0d7656f3b13b1c8b2c11599", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3e7514670db841a7f0d7656f3b13b1c8b2c11599", "html_url": "https://github.com/rust-lang/rust/commit/3e7514670db841a7f0d7656f3b13b1c8b2c11599", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3e7514670db841a7f0d7656f3b13b1c8b2c11599/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e50ff9b4521234e56ff46f8ed0372d5cb5689654", "url": "https://api.github.com/repos/rust-lang/rust/commits/e50ff9b4521234e56ff46f8ed0372d5cb5689654", "html_url": "https://github.com/rust-lang/rust/commit/e50ff9b4521234e56ff46f8ed0372d5cb5689654"}, {"sha": "46340f20497fd9f30e08d5c30413f6f45164da89", "url": "https://api.github.com/repos/rust-lang/rust/commits/46340f20497fd9f30e08d5c30413f6f45164da89", "html_url": "https://github.com/rust-lang/rust/commit/46340f20497fd9f30e08d5c30413f6f45164da89"}], "stats": {"total": 1554, "additions": 703, "deletions": 851}, "files": [{"sha": "8033aa8384c2e1276f742b8dd37070774da23ef8", "filename": "compiler/rustc_error_codes/src/error_codes/E0118.md", "status": "modified", "additions": 4, "deletions": 25, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/3e7514670db841a7f0d7656f3b13b1c8b2c11599/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0118.md", "raw_url": "https://github.com/rust-lang/rust/raw/3e7514670db841a7f0d7656f3b13b1c8b2c11599/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0118.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0118.md?ref=3e7514670db841a7f0d7656f3b13b1c8b2c11599", "patch": "@@ -4,7 +4,7 @@ enum, union, or trait object.\n Erroneous code example:\n \n ```compile_fail,E0118\n-impl (u8, u8) { // error: no nominal type found for inherent implementation\n+impl fn(u8) { // error: no nominal type found for inherent implementation\n     fn get_state(&self) -> String {\n         // ...\n     }\n@@ -20,8 +20,8 @@ trait LiveLongAndProsper {\n     fn get_state(&self) -> String;\n }\n \n-// and now you can implement it on (u8, u8)\n-impl LiveLongAndProsper for (u8, u8) {\n+// and now you can implement it on fn(u8)\n+impl LiveLongAndProsper for fn(u8) {\n     fn get_state(&self) -> String {\n         \"He's dead, Jim!\".to_owned()\n     }\n@@ -33,32 +33,11 @@ For example, `NewType` is a newtype over `Foo` in `struct NewType(Foo)`.\n Example:\n \n ```\n-struct TypeWrapper((u8, u8));\n+struct TypeWrapper(fn(u8));\n \n impl TypeWrapper {\n     fn get_state(&self) -> String {\n         \"Fascinating!\".to_owned()\n     }\n }\n ```\n-\n-Instead of defining an inherent implementation on a reference, you could also\n-move the reference inside the implementation:\n-\n-```compile_fail,E0118\n-struct Foo;\n-\n-impl &Foo { // error: no nominal type found for inherent implementation\n-    fn bar(self, other: Self) {}\n-}\n-```\n-\n-becomes\n-\n-```\n-struct Foo;\n-\n-impl Foo {\n-    fn bar(&self, other: &Self) {}\n-}\n-```"}, {"sha": "26a9dd331ce110c0e19603d7699c461439706bfd", "filename": "compiler/rustc_error_codes/src/error_codes/E0390.md", "status": "modified", "additions": 22, "deletions": 2, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/3e7514670db841a7f0d7656f3b13b1c8b2c11599/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0390.md", "raw_url": "https://github.com/rust-lang/rust/raw/3e7514670db841a7f0d7656f3b13b1c8b2c11599/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0390.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0390.md?ref=3e7514670db841a7f0d7656f3b13b1c8b2c11599", "patch": "@@ -8,8 +8,7 @@ struct Foo {\n }\n \n impl *mut Foo {}\n-// error: only a single inherent implementation marked with\n-//        `#[lang = \"mut_ptr\"]` is allowed for the `*mut T` primitive\n+// error: cannot define inherent `impl` for primitive types\n ```\n \n This isn't allowed, but using a trait to implement a method or constant\n@@ -29,3 +28,24 @@ impl Bar for *mut Foo {\n     fn bar() {} // ok!\n }\n ```\n+\n+Instead of defining an inherent implementation on a reference, you could also\n+move the reference inside the implementation:\n+\n+```compile_fail,E0390\n+struct Foo;\n+\n+impl &Foo { // error: no nominal type found for inherent implementation\n+    fn bar(self, other: Self) {}\n+}\n+```\n+\n+becomes\n+\n+```\n+struct Foo;\n+\n+impl Foo {\n+    fn bar(&self, other: &Self) {}\n+}\n+```"}, {"sha": "7c53f839a92e46546f45da3a56b5c0a66a93fe67", "filename": "compiler/rustc_feature/src/builtin_attrs.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3e7514670db841a7f0d7656f3b13b1c8b2c11599/compiler%2Frustc_feature%2Fsrc%2Fbuiltin_attrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e7514670db841a7f0d7656f3b13b1c8b2c11599/compiler%2Frustc_feature%2Fsrc%2Fbuiltin_attrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_feature%2Fsrc%2Fbuiltin_attrs.rs?ref=3e7514670db841a7f0d7656f3b13b1c8b2c11599", "patch": "@@ -636,6 +636,14 @@ pub const BUILTIN_ATTRIBUTES: &[BuiltinAttribute] = &[\n         template!(Word), ErrorFollowing,\n         \"#[rustc_pass_by_value] is used to mark types that must be passed by value instead of reference.\"\n     ),\n+    rustc_attr!(\n+        rustc_coherence_is_core, AttributeType::CrateLevel, template!(Word), ErrorFollowing,\n+        \"#![rustc_coherence_is_core] allows inherent methods on builtin types, only intended to be used in `core`.\"\n+    ),\n+    rustc_attr!(\n+        rustc_allow_incoherent_impl, AttributeType::Normal, template!(Word), ErrorFollowing,\n+        \"#[rustc_allow_incoherent_impl] has to be added to all impl items of an incoherent inherent impl.\"\n+    ),\n     BuiltinAttribute {\n         name: sym::rustc_diagnostic_item,\n         type_: Normal,"}, {"sha": "b8df163214435324fef6ad03b188dd3af2defe7a", "filename": "compiler/rustc_hir/src/lang_items.rs", "status": "modified", "additions": 0, "deletions": 30, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/3e7514670db841a7f0d7656f3b13b1c8b2c11599/compiler%2Frustc_hir%2Fsrc%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e7514670db841a7f0d7656f3b13b1c8b2c11599/compiler%2Frustc_hir%2Fsrc%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Flang_items.rs?ref=3e7514670db841a7f0d7656f3b13b1c8b2c11599", "patch": "@@ -166,36 +166,6 @@ pub fn extract(attrs: &[ast::Attribute]) -> Option<(Symbol, Span)> {\n \n language_item_table! {\n //  Variant name,            Name,                     Method name,                Target                  Generic requirements;\n-    Bool,                    sym::bool,                bool_impl,                  Target::Impl,           GenericRequirement::None;\n-    Char,                    sym::char,                char_impl,                  Target::Impl,           GenericRequirement::None;\n-    Str,                     sym::str,                 str_impl,                   Target::Impl,           GenericRequirement::None;\n-    Array,                   sym::array,               array_impl,                 Target::Impl,           GenericRequirement::None;\n-    Slice,                   sym::slice,               slice_impl,                 Target::Impl,           GenericRequirement::None;\n-    SliceU8,                 sym::slice_u8,            slice_u8_impl,              Target::Impl,           GenericRequirement::None;\n-    StrAlloc,                sym::str_alloc,           str_alloc_impl,             Target::Impl,           GenericRequirement::None;\n-    SliceAlloc,              sym::slice_alloc,         slice_alloc_impl,           Target::Impl,           GenericRequirement::None;\n-    SliceU8Alloc,            sym::slice_u8_alloc,      slice_u8_alloc_impl,        Target::Impl,           GenericRequirement::None;\n-    ConstPtr,                sym::const_ptr,           const_ptr_impl,             Target::Impl,           GenericRequirement::None;\n-    MutPtr,                  sym::mut_ptr,             mut_ptr_impl,               Target::Impl,           GenericRequirement::None;\n-    ConstSlicePtr,           sym::const_slice_ptr,     const_slice_ptr_impl,       Target::Impl,           GenericRequirement::None;\n-    MutSlicePtr,             sym::mut_slice_ptr,       mut_slice_ptr_impl,         Target::Impl,           GenericRequirement::None;\n-    I8,                      sym::i8,                  i8_impl,                    Target::Impl,           GenericRequirement::None;\n-    I16,                     sym::i16,                 i16_impl,                   Target::Impl,           GenericRequirement::None;\n-    I32,                     sym::i32,                 i32_impl,                   Target::Impl,           GenericRequirement::None;\n-    I64,                     sym::i64,                 i64_impl,                   Target::Impl,           GenericRequirement::None;\n-    I128,                    sym::i128,                i128_impl,                  Target::Impl,           GenericRequirement::None;\n-    Isize,                   sym::isize,               isize_impl,                 Target::Impl,           GenericRequirement::None;\n-    U8,                      sym::u8,                  u8_impl,                    Target::Impl,           GenericRequirement::None;\n-    U16,                     sym::u16,                 u16_impl,                   Target::Impl,           GenericRequirement::None;\n-    U32,                     sym::u32,                 u32_impl,                   Target::Impl,           GenericRequirement::None;\n-    U64,                     sym::u64,                 u64_impl,                   Target::Impl,           GenericRequirement::None;\n-    U128,                    sym::u128,                u128_impl,                  Target::Impl,           GenericRequirement::None;\n-    Usize,                   sym::usize,               usize_impl,                 Target::Impl,           GenericRequirement::None;\n-    F32,                     sym::f32,                 f32_impl,                   Target::Impl,           GenericRequirement::None;\n-    F64,                     sym::f64,                 f64_impl,                   Target::Impl,           GenericRequirement::None;\n-    F32Runtime,              sym::f32_runtime,         f32_runtime_impl,           Target::Impl,           GenericRequirement::None;\n-    F64Runtime,              sym::f64_runtime,         f64_runtime_impl,           Target::Impl,           GenericRequirement::None;\n-\n     Sized,                   sym::sized,               sized_trait,                Target::Trait,          GenericRequirement::Exact(0);\n     Unsize,                  sym::unsize,              unsize_trait,               Target::Trait,          GenericRequirement::Minimum(1);\n     /// Trait injected by `#[derive(PartialEq)]`, (i.e. \"Partial EQ\")."}, {"sha": "e88ef68c7224d75e0b6df24e83d7632e8ccabe9a", "filename": "compiler/rustc_metadata/src/rmeta/decoder.rs", "status": "modified", "additions": 36, "deletions": 8, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/3e7514670db841a7f0d7656f3b13b1c8b2c11599/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e7514670db841a7f0d7656f3b13b1c8b2c11599/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs?ref=3e7514670db841a7f0d7656f3b13b1c8b2c11599", "patch": "@@ -95,6 +95,11 @@ crate struct CrateMetadata {\n     /// FIXME: Used only from queries and can use query cache,\n     /// so pre-decoding can probably be avoided.\n     trait_impls: FxHashMap<(u32, DefIndex), Lazy<[(DefIndex, Option<SimplifiedType>)]>>,\n+    /// Inherent impls which do not follow the normal coherence rules.\n+    ///\n+    /// These can be introduced using either `#![rustc_coherence_is_core]`\n+    /// or `#[rustc_allow_incoherent_impl]`.\n+    incoherent_impls: FxHashMap<SimplifiedType, Lazy<[DefIndex]>>,\n     /// Proc macro descriptions for this crate, if it's a proc macro crate.\n     raw_proc_macros: Option<&'static [ProcMacro]>,\n     /// Source maps for code from the crate.\n@@ -1028,11 +1033,13 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n     }\n \n     /// Iterates over the language items in the given crate.\n-    fn get_lang_items(self) -> impl Iterator<Item = (DefId, usize)> + 'a {\n-        self.root\n-            .lang_items\n-            .decode(self)\n-            .map(move |(def_index, index)| (self.local_def_id(def_index), index))\n+    fn get_lang_items(self, tcx: TyCtxt<'tcx>) -> &'tcx [(DefId, usize)] {\n+        tcx.arena.alloc_from_iter(\n+            self.root\n+                .lang_items\n+                .decode(self)\n+                .map(move |(def_index, index)| (self.local_def_id(def_index), index)),\n+        )\n     }\n \n     /// Iterates over the diagnostic items in the given crate.\n@@ -1327,17 +1334,32 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n \n     /// Decodes all trait impls in the crate (for rustdoc).\n     fn get_trait_impls(self) -> impl Iterator<Item = (DefId, DefId, Option<SimplifiedType>)> + 'a {\n-        self.cdata.trait_impls.iter().flat_map(move |((trait_cnum_raw, trait_index), impls)| {\n+        self.cdata.trait_impls.iter().flat_map(move |(&(trait_cnum_raw, trait_index), impls)| {\n             let trait_def_id = DefId {\n-                krate: self.cnum_map[CrateNum::from_u32(*trait_cnum_raw)],\n-                index: *trait_index,\n+                krate: self.cnum_map[CrateNum::from_u32(trait_cnum_raw)],\n+                index: trait_index,\n             };\n             impls.decode(self).map(move |(impl_index, simplified_self_ty)| {\n                 (trait_def_id, self.local_def_id(impl_index), simplified_self_ty)\n             })\n         })\n     }\n \n+    fn get_all_incoherent_impls(self) -> impl Iterator<Item = DefId> + 'a {\n+        self.cdata\n+            .incoherent_impls\n+            .values()\n+            .flat_map(move |impls| impls.decode(self).map(move |idx| self.local_def_id(idx)))\n+    }\n+\n+    fn get_incoherent_impls(self, tcx: TyCtxt<'tcx>, simp: SimplifiedType) -> &'tcx [DefId] {\n+        if let Some(impls) = self.cdata.incoherent_impls.get(&simp) {\n+            tcx.arena.alloc_from_iter(impls.decode(self).map(|idx| self.local_def_id(idx)))\n+        } else {\n+            &[]\n+        }\n+    }\n+\n     fn get_implementations_of_trait(\n         self,\n         tcx: TyCtxt<'tcx>,\n@@ -1754,6 +1776,11 @@ impl CrateMetadata {\n             .decode((&blob, sess))\n             .map(|trait_impls| (trait_impls.trait_id, trait_impls.impls))\n             .collect();\n+        let incoherent_impls = root\n+            .incoherent_impls\n+            .decode((&blob, sess))\n+            .map(|incoherent_impls| (incoherent_impls.self_ty, incoherent_impls.impls))\n+            .collect();\n         let alloc_decoding_state =\n             AllocDecodingState::new(root.interpret_alloc_index.decode(&blob).collect());\n         let dependencies = Lock::new(cnum_map.iter().cloned().collect());\n@@ -1766,6 +1793,7 @@ impl CrateMetadata {\n             blob,\n             root,\n             trait_impls,\n+            incoherent_impls,\n             raw_proc_macros,\n             source_map_import_info: OnceCell::new(),\n             def_path_hash_map,"}, {"sha": "70358ae0e22aafc5f793bbb48ac484f750231e09", "filename": "compiler/rustc_metadata/src/rmeta/decoder/cstore_impl.rs", "status": "modified", "additions": 27, "deletions": 12, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/3e7514670db841a7f0d7656f3b13b1c8b2c11599/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e7514670db841a7f0d7656f3b13b1c8b2c11599/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs?ref=3e7514670db841a7f0d7656f3b13b1c8b2c11599", "patch": "@@ -81,30 +81,42 @@ macro_rules! provide {\n // small trait to work around different signature queries all being defined via\n // the macro above.\n trait IntoArgs {\n-    fn into_args(self) -> (DefId, DefId);\n+    type Other;\n+    fn into_args(self) -> (DefId, Self::Other);\n }\n \n impl IntoArgs for DefId {\n-    fn into_args(self) -> (DefId, DefId) {\n-        (self, self)\n+    type Other = ();\n+    fn into_args(self) -> (DefId, ()) {\n+        (self, ())\n     }\n }\n \n impl IntoArgs for CrateNum {\n-    fn into_args(self) -> (DefId, DefId) {\n-        (self.as_def_id(), self.as_def_id())\n+    type Other = ();\n+    fn into_args(self) -> (DefId, ()) {\n+        (self.as_def_id(), ())\n     }\n }\n \n impl IntoArgs for (CrateNum, DefId) {\n+    type Other = DefId;\n     fn into_args(self) -> (DefId, DefId) {\n         (self.0.as_def_id(), self.1)\n     }\n }\n \n impl<'tcx> IntoArgs for ty::InstanceDef<'tcx> {\n-    fn into_args(self) -> (DefId, DefId) {\n-        (self.def_id(), self.def_id())\n+    type Other = ();\n+    fn into_args(self) -> (DefId, ()) {\n+        (self.def_id(), ())\n+    }\n+}\n+\n+impl IntoArgs for (CrateNum, SimplifiedType) {\n+    type Other = SimplifiedType;\n+    fn into_args(self) -> (DefId, SimplifiedType) {\n+        (self.0.as_def_id(), self.1)\n     }\n }\n \n@@ -199,6 +211,7 @@ provide! { <'tcx> tcx, def_id, other, cdata,\n \n     traits_in_crate => { tcx.arena.alloc_from_iter(cdata.get_traits()) }\n     implementations_of_trait => { cdata.get_implementations_of_trait(tcx, other) }\n+    crate_incoherent_impls => { cdata.get_incoherent_impls(tcx, other) }\n \n     dep_kind => {\n         let r = *cdata.dep_kind.lock();\n@@ -210,7 +223,7 @@ provide! { <'tcx> tcx, def_id, other, cdata,\n         tcx.arena.alloc_slice(&result)\n     }\n     defined_lib_features => { cdata.get_lib_features(tcx) }\n-    defined_lang_items => { tcx.arena.alloc_from_iter(cdata.get_lang_items()) }\n+    defined_lang_items => { cdata.get_lang_items(tcx) }\n     diagnostic_items => { cdata.get_diagnostic_items() }\n     missing_lang_items => { cdata.get_missing_lang_items(tcx) }\n \n@@ -371,7 +384,6 @@ pub(in crate::rmeta) fn provide(providers: &mut Providers) {\n                 .alloc_slice(&CStore::from_tcx(tcx).crate_dependencies_in_postorder(LOCAL_CRATE))\n         },\n         crates: |tcx, ()| tcx.arena.alloc_from_iter(CStore::from_tcx(tcx).crates_untracked()),\n-\n         ..*providers\n     };\n }\n@@ -511,9 +523,12 @@ impl CStore {\n         self.get_crate_data(cnum).get_inherent_impls()\n     }\n \n-    /// Decodes all lang items in the crate (for rustdoc).\n-    pub fn lang_items_untracked(&self, cnum: CrateNum) -> impl Iterator<Item = DefId> + '_ {\n-        self.get_crate_data(cnum).get_lang_items().map(|(def_id, _)| def_id)\n+    /// Decodes all incoherent inherent impls in the crate (for rustdoc).\n+    pub fn incoherent_impls_in_crate_untracked(\n+        &self,\n+        cnum: CrateNum,\n+    ) -> impl Iterator<Item = DefId> + '_ {\n+        self.get_crate_data(cnum).get_all_incoherent_impls()\n     }\n }\n "}, {"sha": "a219b9eb2be832374a8a227c30a85f5158e0922d", "filename": "compiler/rustc_metadata/src/rmeta/encoder.rs", "status": "modified", "additions": 35, "deletions": 3, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/3e7514670db841a7f0d7656f3b13b1c8b2c11599/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e7514670db841a7f0d7656f3b13b1c8b2c11599/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs?ref=3e7514670db841a7f0d7656f3b13b1c8b2c11599", "patch": "@@ -2,8 +2,9 @@ use crate::rmeta::def_path_hash_map::DefPathHashMapRef;\n use crate::rmeta::table::{FixedSizeEncoding, TableBuilder};\n use crate::rmeta::*;\n \n+use rustc_data_structures::fingerprint::Fingerprint;\n use rustc_data_structures::fx::{FxHashMap, FxIndexSet};\n-use rustc_data_structures::stable_hasher::StableHasher;\n+use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_data_structures::sync::{join, par_iter, Lrc, ParallelIterator};\n use rustc_hir as hir;\n use rustc_hir::def::DefKind;\n@@ -578,6 +579,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n     }\n \n     fn encode_crate_root(&mut self) -> Lazy<CrateRoot<'tcx>> {\n+        let tcx = self.tcx;\n         let mut i = self.position();\n \n         // Encode the crate deps\n@@ -623,8 +625,9 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         let impls = self.encode_impls();\n         let impls_bytes = self.position() - i;\n \n-        let tcx = self.tcx;\n-\n+        i = self.position();\n+        let incoherent_impls = self.encode_incoherent_impls();\n+        let incoherent_impls_bytes = self.position() - i;\n         // Encode MIR.\n         i = self.position();\n         self.encode_mir();\n@@ -734,6 +737,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             source_map,\n             traits,\n             impls,\n+            incoherent_impls,\n             exported_symbols,\n             interpret_alloc_index,\n             tables,\n@@ -762,6 +766,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             eprintln!(\"      source_map bytes: {}\", source_map_bytes);\n             eprintln!(\"          traits bytes: {}\", traits_bytes);\n             eprintln!(\"           impls bytes: {}\", impls_bytes);\n+            eprintln!(\"incoherent_impls bytes: {}\", incoherent_impls_bytes);\n             eprintln!(\"    exp. symbols bytes: {}\", exported_symbols_bytes);\n             eprintln!(\"  def-path table bytes: {}\", def_path_table_bytes);\n             eprintln!(\" def-path hashes bytes: {}\", def_path_hash_map_bytes);\n@@ -1813,6 +1818,33 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         self.lazy(&all_impls)\n     }\n \n+    fn encode_incoherent_impls(&mut self) -> Lazy<[IncoherentImpls]> {\n+        debug!(\"EncodeContext::encode_traits_and_impls()\");\n+        empty_proc_macro!(self);\n+        let tcx = self.tcx;\n+        let mut ctx = tcx.create_stable_hashing_context();\n+        let mut all_impls: Vec<_> = tcx.crate_inherent_impls(()).incoherent_impls.iter().collect();\n+        all_impls.sort_by_cached_key(|&(&simp, _)| {\n+            let mut hasher = StableHasher::new();\n+            simp.hash_stable(&mut ctx, &mut hasher);\n+            hasher.finish::<Fingerprint>();\n+        });\n+        let all_impls: Vec<_> = all_impls\n+            .into_iter()\n+            .map(|(&simp, impls)| {\n+                let mut impls: Vec<_> =\n+                    impls.into_iter().map(|def_id| def_id.local_def_index).collect();\n+                impls.sort_by_cached_key(|&local_def_index| {\n+                    tcx.hir().def_path_hash(LocalDefId { local_def_index })\n+                });\n+\n+                IncoherentImpls { self_ty: simp, impls: self.lazy(impls) }\n+            })\n+            .collect();\n+\n+        self.lazy(&all_impls)\n+    }\n+\n     // Encodes all symbols exported from this crate into the metadata.\n     //\n     // This pass is seeded off the reachability list calculated in the"}, {"sha": "204284ffaa3f999b615a42129aafd2dc0ad90c64", "filename": "compiler/rustc_metadata/src/rmeta/mod.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3e7514670db841a7f0d7656f3b13b1c8b2c11599/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e7514670db841a7f0d7656f3b13b1c8b2c11599/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs?ref=3e7514670db841a7f0d7656f3b13b1c8b2c11599", "patch": "@@ -212,6 +212,7 @@ crate struct CrateRoot<'tcx> {\n     foreign_modules: Lazy<[ForeignModule]>,\n     traits: Lazy<[DefIndex]>,\n     impls: Lazy<[TraitImpls]>,\n+    incoherent_impls: Lazy<[IncoherentImpls]>,\n     interpret_alloc_index: Lazy<[u32]>,\n     proc_macro_data: Option<ProcMacroData>,\n \n@@ -251,6 +252,12 @@ crate struct TraitImpls {\n     impls: Lazy<[(DefIndex, Option<SimplifiedType>)]>,\n }\n \n+#[derive(MetadataEncodable, MetadataDecodable)]\n+crate struct IncoherentImpls {\n+    self_ty: SimplifiedType,\n+    impls: Lazy<[DefIndex]>,\n+}\n+\n /// Define `LazyTables` and `TableBuilders` at the same time.\n macro_rules! define_tables {\n     ($($name:ident: Table<$IDX:ty, $T:ty>),+ $(,)?) => {"}, {"sha": "8afa6e70e41839024b8a941d7fd6ecb0cb4a4b2b", "filename": "compiler/rustc_middle/src/hir/map/mod.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3e7514670db841a7f0d7656f3b13b1c8b2c11599/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e7514670db841a7f0d7656f3b13b1c8b2c11599/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs?ref=3e7514670db841a7f0d7656f3b13b1c8b2c11599", "patch": "@@ -579,6 +579,10 @@ impl<'hir> Map<'hir> {\n         self.attrs(CRATE_HIR_ID)\n     }\n \n+    pub fn rustc_coherence_is_core(self) -> bool {\n+        self.krate_attrs().iter().any(|attr| attr.has_name(sym::rustc_coherence_is_core))\n+    }\n+\n     pub fn get_module(self, module: LocalDefId) -> (&'hir Mod<'hir>, Span, HirId) {\n         let hir_id = HirId::make_owner(module);\n         match self.tcx.hir_owner(module).map(|o| o.node) {"}, {"sha": "6d7e7ef0cb072a070aff48a4d2b24bda0ae511d0", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/3e7514670db841a7f0d7656f3b13b1c8b2c11599/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e7514670db841a7f0d7656f3b13b1c8b2c11599/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=3e7514670db841a7f0d7656f3b13b1c8b2c11599", "patch": "@@ -684,6 +684,10 @@ rustc_queries! {\n         separate_provide_extern\n     }\n \n+    query incoherent_impls(key: SimplifiedType) -> &'tcx [DefId] {\n+        desc { |tcx| \"collecting all inherent impls for `{:?}`\", key }\n+    }\n+\n     /// The result of unsafety-checking this `LocalDefId`.\n     query unsafety_check_result(key: LocalDefId) -> &'tcx mir::UnsafetyCheckResult {\n         desc { |tcx| \"unsafety-checking `{}`\", tcx.def_path_str(key.to_def_id()) }\n@@ -1469,6 +1473,15 @@ rustc_queries! {\n         separate_provide_extern\n     }\n \n+    /// Collects all incoherent impls for the given crate and type.\n+    ///\n+    /// Do not call this directly, but instead use the `incoherent_impls` query.\n+    /// This query is only used to get the data necessary for that query.\n+    query crate_incoherent_impls(key: (CrateNum, SimplifiedType)) -> &'tcx [DefId] {\n+        desc { |tcx| \"collecting all impls for a type in a crate\" }\n+        separate_provide_extern\n+    }\n+\n     query is_dllimport_foreign_item(def_id: DefId) -> bool {\n         desc { |tcx| \"is_dllimport_foreign_item({})\", tcx.def_path_str(def_id) }\n     }"}, {"sha": "2009364b24e608cc32b9dccb87c5c53857bc5813", "filename": "compiler/rustc_middle/src/ty/impls_ty.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/3e7514670db841a7f0d7656f3b13b1c8b2c11599/compiler%2Frustc_middle%2Fsrc%2Fty%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e7514670db841a7f0d7656f3b13b1c8b2c11599/compiler%2Frustc_middle%2Fsrc%2Fty%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fimpls_ty.rs?ref=3e7514670db841a7f0d7656f3b13b1c8b2c11599", "patch": "@@ -4,6 +4,7 @@\n use crate::middle::region;\n use crate::mir;\n use crate::ty;\n+use crate::ty::fast_reject::SimplifiedType;\n use rustc_data_structures::fingerprint::Fingerprint;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::stable_hasher::HashingControls;\n@@ -55,6 +56,18 @@ where\n     }\n }\n \n+impl<'a> ToStableHashKey<StableHashingContext<'a>> for SimplifiedType {\n+    type KeyType = Fingerprint;\n+\n+    #[inline]\n+    fn to_stable_hash_key(&self, hcx: &StableHashingContext<'a>) -> Fingerprint {\n+        let mut hasher = StableHasher::new();\n+        let mut hcx: StableHashingContext<'a> = hcx.clone();\n+        self.hash_stable(&mut hcx, &mut hasher);\n+        hasher.finish()\n+    }\n+}\n+\n impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for ty::subst::GenericArg<'tcx> {\n     fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n         self.unpack().hash_stable(hcx, hasher);"}, {"sha": "dfc405b1195ee8ed346b6c7c77157d7eb7ff6cdb", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3e7514670db841a7f0d7656f3b13b1c8b2c11599/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e7514670db841a7f0d7656f3b13b1c8b2c11599/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=3e7514670db841a7f0d7656f3b13b1c8b2c11599", "patch": "@@ -25,6 +25,7 @@ use crate::middle::privacy::AccessLevels;\n use crate::mir::{Body, GeneratorLayout};\n use crate::traits::{self, Reveal};\n use crate::ty;\n+use crate::ty::fast_reject::SimplifiedType;\n use crate::ty::subst::{GenericArg, InternalSubsts, Subst, SubstsRef};\n use crate::ty::util::Discr;\n use rustc_ast as ast;\n@@ -2335,6 +2336,7 @@ pub fn provide(providers: &mut ty::query::Providers) {\n     super::middle::provide(providers);\n     *providers = ty::query::Providers {\n         trait_impls_of: trait_def::trait_impls_of_provider,\n+        incoherent_impls: trait_def::incoherent_impls_provider,\n         type_uninhabited_from: inhabitedness::type_uninhabited_from,\n         const_param_default: consts::const_param_default,\n         vtable_allocation: vtable::vtable_allocation_provider,\n@@ -2350,6 +2352,7 @@ pub fn provide(providers: &mut ty::query::Providers) {\n #[derive(Clone, Debug, Default, HashStable)]\n pub struct CrateInherentImpls {\n     pub inherent_impls: LocalDefIdMap<Vec<DefId>>,\n+    pub incoherent_impls: FxHashMap<SimplifiedType, Vec<LocalDefId>>,\n }\n \n #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, TyEncodable, HashStable)]"}, {"sha": "5a13216846d54e8d8a5ad7c61f33711be0b36989", "filename": "compiler/rustc_middle/src/ty/sty.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3e7514670db841a7f0d7656f3b13b1c8b2c11599/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e7514670db841a7f0d7656f3b13b1c8b2c11599/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs?ref=3e7514670db841a7f0d7656f3b13b1c8b2c11599", "patch": "@@ -1889,10 +1889,7 @@ impl<'tcx> Ty<'tcx> {\n \n     #[inline]\n     pub fn is_slice(self) -> bool {\n-        match self.kind() {\n-            RawPtr(TypeAndMut { ty, .. }) | Ref(_, ty, _) => matches!(ty.kind(), Slice(_) | Str),\n-            _ => false,\n-        }\n+        matches!(self.kind(), Slice(_))\n     }\n \n     #[inline]"}, {"sha": "943f610cc0dd30d9370c394a62cee963e3ce23dd", "filename": "compiler/rustc_middle/src/ty/trait_def.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/3e7514670db841a7f0d7656f3b13b1c8b2c11599/compiler%2Frustc_middle%2Fsrc%2Fty%2Ftrait_def.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e7514670db841a7f0d7656f3b13b1c8b2c11599/compiler%2Frustc_middle%2Fsrc%2Fty%2Ftrait_def.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ftrait_def.rs?ref=3e7514670db841a7f0d7656f3b13b1c8b2c11599", "patch": "@@ -2,9 +2,11 @@ use crate::traits::specialization_graph;\n use crate::ty::fast_reject::{self, SimplifiedType, TreatParams};\n use crate::ty::fold::TypeFoldable;\n use crate::ty::{Ident, Ty, TyCtxt};\n+use hir::def_id::LOCAL_CRATE;\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n use rustc_hir::definitions::DefPathHash;\n+use std::iter;\n \n use rustc_data_structures::fx::FxIndexMap;\n use rustc_errors::ErrorGuaranteed;\n@@ -257,3 +259,19 @@ pub(super) fn trait_impls_of_provider(tcx: TyCtxt<'_>, trait_id: DefId) -> Trait\n \n     impls\n }\n+\n+// Query provider for `incoherent_impls`.\n+#[instrument(level = \"debug\", skip(tcx))]\n+pub(super) fn incoherent_impls_provider(tcx: TyCtxt<'_>, simp: SimplifiedType) -> &[DefId] {\n+    let mut impls = Vec::new();\n+\n+    for cnum in iter::once(LOCAL_CRATE).chain(tcx.crates(()).iter().copied()) {\n+        for &impl_def_id in tcx.crate_incoherent_impls((cnum, simp)) {\n+            impls.push(impl_def_id)\n+        }\n+    }\n+\n+    debug!(?impls);\n+\n+    tcx.arena.alloc_slice(&impls)\n+}"}, {"sha": "8aa659fa6ac7c54453e29eb84d216af4b7647059", "filename": "compiler/rustc_passes/src/check_attr.rs", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/3e7514670db841a7f0d7656f3b13b1c8b2c11599/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e7514670db841a7f0d7656f3b13b1c8b2c11599/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs?ref=3e7514670db841a7f0d7656f3b13b1c8b2c11599", "patch": "@@ -120,6 +120,9 @@ impl CheckAttrVisitor<'_> {\n                 sym::must_not_suspend => self.check_must_not_suspend(&attr, span, target),\n                 sym::must_use => self.check_must_use(hir_id, &attr, span, target),\n                 sym::rustc_pass_by_value => self.check_pass_by_value(&attr, span, target),\n+                sym::rustc_allow_incoherent_impl => {\n+                    self.check_allow_incoherent_impl(&attr, span, target)\n+                }\n                 sym::rustc_const_unstable\n                 | sym::rustc_const_stable\n                 | sym::unstable\n@@ -1080,6 +1083,24 @@ impl CheckAttrVisitor<'_> {\n         }\n     }\n \n+    /// Warns against some misuses of `#[pass_by_value]`\n+    fn check_allow_incoherent_impl(&self, attr: &Attribute, span: Span, target: Target) -> bool {\n+        match target {\n+            Target::Method(MethodKind::Inherent) => true,\n+            _ => {\n+                self.tcx\n+                    .sess\n+                    .struct_span_err(\n+                        attr.span,\n+                        \"`rustc_allow_incoherent_impl` attribute should be applied to impl items.\",\n+                    )\n+                    .span_label(span, \"the only currently supported targets are inherent methods\")\n+                    .emit();\n+                false\n+            }\n+        }\n+    }\n+\n     /// Warns against some misuses of `#[must_use]`\n     fn check_must_use(&self, hir_id: HirId, attr: &Attribute, span: Span, target: Target) -> bool {\n         let node = self.tcx.hir().get(hir_id);"}, {"sha": "f1f83a7299c4d97740c2997e02055dcf466759bb", "filename": "compiler/rustc_query_impl/src/keys.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/3e7514670db841a7f0d7656f3b13b1c8b2c11599/compiler%2Frustc_query_impl%2Fsrc%2Fkeys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e7514670db841a7f0d7656f3b13b1c8b2c11599/compiler%2Frustc_query_impl%2Fsrc%2Fkeys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_impl%2Fsrc%2Fkeys.rs?ref=3e7514670db841a7f0d7656f3b13b1c8b2c11599", "patch": "@@ -141,6 +141,16 @@ impl Key for ty::WithOptConstParam<LocalDefId> {\n     }\n }\n \n+impl Key for SimplifiedType {\n+    #[inline(always)]\n+    fn query_crate_is_local(&self) -> bool {\n+        true\n+    }\n+    fn default_span(&self, _: TyCtxt<'_>) -> Span {\n+        DUMMY_SP\n+    }\n+}\n+\n impl Key for (DefId, DefId) {\n     #[inline(always)]\n     fn query_crate_is_local(&self) -> bool {\n@@ -215,6 +225,16 @@ impl Key for (CrateNum, DefId) {\n     }\n }\n \n+impl Key for (CrateNum, SimplifiedType) {\n+    #[inline(always)]\n+    fn query_crate_is_local(&self) -> bool {\n+        self.0 == LOCAL_CRATE\n+    }\n+    fn default_span(&self, _: TyCtxt<'_>) -> Span {\n+        DUMMY_SP\n+    }\n+}\n+\n impl Key for (DefId, SimplifiedType) {\n     #[inline(always)]\n     fn query_crate_is_local(&self) -> bool {"}, {"sha": "84dbad846dd29c445e4283fee48feedc7333f36e", "filename": "compiler/rustc_span/src/symbol.rs", "status": "modified", "additions": 2, "deletions": 10, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3e7514670db841a7f0d7656f3b13b1c8b2c11599/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e7514670db841a7f0d7656f3b13b1c8b2c11599/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs?ref=3e7514670db841a7f0d7656f3b13b1c8b2c11599", "patch": "@@ -494,11 +494,9 @@ symbols! {\n         const_panic,\n         const_panic_fmt,\n         const_precise_live_drops,\n-        const_ptr,\n         const_raw_ptr_deref,\n         const_raw_ptr_to_usize_cast,\n         const_refs_to_cell,\n-        const_slice_ptr,\n         const_trait_bound_opt_out,\n         const_trait_impl,\n         const_transmute,\n@@ -655,9 +653,7 @@ symbols! {\n         f,\n         f16c_target_feature,\n         f32,\n-        f32_runtime,\n         f64,\n-        f64_runtime,\n         fabsf32,\n         fabsf64,\n         fadd_fast,\n@@ -913,8 +909,6 @@ symbols! {\n         mul_with_overflow,\n         must_not_suspend,\n         must_use,\n-        mut_ptr,\n-        mut_slice_ptr,\n         naked,\n         naked_functions,\n         name,\n@@ -1160,10 +1154,12 @@ symbols! {\n         rustc_allocator,\n         rustc_allocator_nounwind,\n         rustc_allow_const_fn_unstable,\n+        rustc_allow_incoherent_impl,\n         rustc_attrs,\n         rustc_builtin_macro,\n         rustc_capture_analysis,\n         rustc_clean,\n+        rustc_coherence_is_core,\n         rustc_const_stable,\n         rustc_const_unstable,\n         rustc_conversion_suggestion,\n@@ -1312,11 +1308,8 @@ symbols! {\n         sized,\n         skip,\n         slice,\n-        slice_alloc,\n         slice_len_fn,\n         slice_patterns,\n-        slice_u8,\n-        slice_u8_alloc,\n         slicing_syntax,\n         soft,\n         specialization,\n@@ -1346,7 +1339,6 @@ symbols! {\n         stop_after_dataflow,\n         store,\n         str,\n-        str_alloc,\n         str_split_whitespace,\n         str_trim,\n         str_trim_end,"}, {"sha": "adc284785c294f0f21a4446b4c77760c2a90e36f", "filename": "compiler/rustc_typeck/src/check/method/mod.rs", "status": "modified", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/3e7514670db841a7f0d7656f3b13b1c8b2c11599/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e7514670db841a7f0d7656f3b13b1c8b2c11599/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fmod.rs?ref=3e7514670db841a7f0d7656f3b13b1c8b2c11599", "patch": "@@ -78,28 +78,6 @@ pub struct NoMatchData<'tcx> {\n     pub mode: probe::Mode,\n }\n \n-impl<'tcx> NoMatchData<'tcx> {\n-    pub fn new(\n-        static_candidates: Vec<CandidateSource>,\n-        unsatisfied_predicates: Vec<(\n-            ty::Predicate<'tcx>,\n-            Option<ty::Predicate<'tcx>>,\n-            Option<ObligationCause<'tcx>>,\n-        )>,\n-        out_of_scope_traits: Vec<DefId>,\n-        lev_candidate: Option<ty::AssocItem>,\n-        mode: probe::Mode,\n-    ) -> Self {\n-        NoMatchData {\n-            static_candidates,\n-            unsatisfied_predicates,\n-            out_of_scope_traits,\n-            lev_candidate,\n-            mode,\n-        }\n-    }\n-}\n-\n // A pared down enum describing just the places from which a method\n // candidate can arise. Used for error reporting only.\n #[derive(Copy, Clone, Debug, Eq, Ord, PartialEq, PartialOrd)]"}, {"sha": "5d91b3b46a176928427d9958b1bea7cf2dcccdce", "filename": "compiler/rustc_typeck/src/check/method/probe.rs", "status": "modified", "additions": 30, "deletions": 86, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/3e7514670db841a7f0d7656f3b13b1c8b2c11599/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e7514670db841a7f0d7656f3b13b1c8b2c11599/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fprobe.rs?ref=3e7514670db841a7f0d7656f3b13b1c8b2c11599", "patch": "@@ -18,6 +18,7 @@ use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKi\n use rustc_infer::infer::unify_key::{ConstVariableOrigin, ConstVariableOriginKind};\n use rustc_infer::infer::{self, InferOk, TyCtxtInferExt};\n use rustc_middle::middle::stability;\n+use rustc_middle::ty::fast_reject::{simplify_type, TreatParams};\n use rustc_middle::ty::subst::{InternalSubsts, Subst, SubstsRef};\n use rustc_middle::ty::GenericParamDefKind;\n use rustc_middle::ty::{self, ParamEnvAnd, ToPredicate, Ty, TyCtxt, TypeFoldable};\n@@ -427,13 +428,13 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     .unwrap_or_else(|_| span_bug!(span, \"instantiating {:?} failed?\", ty));\n                 let ty = self.structurally_resolved_type(span, ty.value);\n                 assert!(matches!(ty.kind(), ty::Error(_)));\n-                return Err(MethodError::NoMatch(NoMatchData::new(\n-                    Vec::new(),\n-                    Vec::new(),\n-                    Vec::new(),\n-                    None,\n+                return Err(MethodError::NoMatch(NoMatchData {\n+                    static_candidates: Vec::new(),\n+                    unsatisfied_predicates: Vec::new(),\n+                    out_of_scope_traits: Vec::new(),\n+                    lev_candidate: None,\n                     mode,\n-                )));\n+                }));\n             }\n         }\n \n@@ -613,9 +614,8 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n \n     fn assemble_probe(&mut self, self_ty: &Canonical<'tcx, QueryResponse<'tcx, Ty<'tcx>>>) {\n         debug!(\"assemble_probe: self_ty={:?}\", self_ty);\n-        let lang_items = self.tcx.lang_items();\n-\n-        match *self_ty.value.value.kind() {\n+        let raw_self_ty = self_ty.value.value;\n+        match *raw_self_ty.kind() {\n             ty::Dynamic(data, ..) if let Some(p) = data.principal() => {\n                 // Subtle: we can't use `instantiate_query_response` here: using it will\n                 // commit to all of the type equalities assumed by inference going through\n@@ -650,83 +650,27 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n             ty::Param(p) => {\n                 self.assemble_inherent_candidates_from_param(p);\n             }\n-            ty::Bool => {\n-                let lang_def_id = lang_items.bool_impl();\n-                self.assemble_inherent_impl_for_primitive(lang_def_id);\n-            }\n-            ty::Char => {\n-                let lang_def_id = lang_items.char_impl();\n-                self.assemble_inherent_impl_for_primitive(lang_def_id);\n-            }\n-            ty::Str => {\n-                let lang_def_id = lang_items.str_impl();\n-                self.assemble_inherent_impl_for_primitive(lang_def_id);\n-\n-                let lang_def_id = lang_items.str_alloc_impl();\n-                self.assemble_inherent_impl_for_primitive(lang_def_id);\n-            }\n-            ty::Slice(_) => {\n-                for lang_def_id in [\n-                    lang_items.slice_impl(),\n-                    lang_items.slice_u8_impl(),\n-                    lang_items.slice_alloc_impl(),\n-                    lang_items.slice_u8_alloc_impl(),\n-                ] {\n-                    self.assemble_inherent_impl_for_primitive(lang_def_id);\n-                }\n-            }\n-            ty::Array(_, _) => {\n-                let lang_def_id = lang_items.array_impl();\n-                self.assemble_inherent_impl_for_primitive(lang_def_id);\n-            }\n-            ty::RawPtr(ty::TypeAndMut { ty: _, mutbl }) => {\n-                let (lang_def_id1, lang_def_id2) = match mutbl {\n-                    hir::Mutability::Not => {\n-                        (lang_items.const_ptr_impl(), lang_items.const_slice_ptr_impl())\n-                    }\n-                    hir::Mutability::Mut => {\n-                        (lang_items.mut_ptr_impl(), lang_items.mut_slice_ptr_impl())\n-                    }\n-                };\n-                self.assemble_inherent_impl_for_primitive(lang_def_id1);\n-                self.assemble_inherent_impl_for_primitive(lang_def_id2);\n-            }\n-            ty::Int(i) => {\n-                let lang_def_id = match i {\n-                    ty::IntTy::I8 => lang_items.i8_impl(),\n-                    ty::IntTy::I16 => lang_items.i16_impl(),\n-                    ty::IntTy::I32 => lang_items.i32_impl(),\n-                    ty::IntTy::I64 => lang_items.i64_impl(),\n-                    ty::IntTy::I128 => lang_items.i128_impl(),\n-                    ty::IntTy::Isize => lang_items.isize_impl(),\n-                };\n-                self.assemble_inherent_impl_for_primitive(lang_def_id);\n-            }\n-            ty::Uint(i) => {\n-                let lang_def_id = match i {\n-                    ty::UintTy::U8 => lang_items.u8_impl(),\n-                    ty::UintTy::U16 => lang_items.u16_impl(),\n-                    ty::UintTy::U32 => lang_items.u32_impl(),\n-                    ty::UintTy::U64 => lang_items.u64_impl(),\n-                    ty::UintTy::U128 => lang_items.u128_impl(),\n-                    ty::UintTy::Usize => lang_items.usize_impl(),\n-                };\n-                self.assemble_inherent_impl_for_primitive(lang_def_id);\n-            }\n-            ty::Float(f) => {\n-                let (lang_def_id1, lang_def_id2) = match f {\n-                    ty::FloatTy::F32 => (lang_items.f32_impl(), lang_items.f32_runtime_impl()),\n-                    ty::FloatTy::F64 => (lang_items.f64_impl(), lang_items.f64_runtime_impl()),\n-                };\n-                self.assemble_inherent_impl_for_primitive(lang_def_id1);\n-                self.assemble_inherent_impl_for_primitive(lang_def_id2);\n-            }\n+            ty::Bool\n+            | ty::Char\n+            | ty::Int(_)\n+            | ty::Uint(_)\n+            | ty::Float(_)\n+            | ty::Str\n+            | ty::Array(..)\n+            | ty::Slice(_)\n+            | ty::RawPtr(_)\n+            | ty::Ref(..)\n+            | ty::Never\n+            | ty::Tuple(..) => self.assemble_inherent_candidates_for_incoherent_ty(raw_self_ty),\n             _ => {}\n         }\n     }\n \n-    fn assemble_inherent_impl_for_primitive(&mut self, lang_def_id: Option<DefId>) {\n-        if let Some(impl_def_id) = lang_def_id {\n+    fn assemble_inherent_candidates_for_incoherent_ty(&mut self, self_ty: Ty<'tcx>) {\n+        let Some(simp) = simplify_type(self.tcx, self_ty, TreatParams::AsPlaceholders) else {\n+            bug!(\"unexpected incoherent type: {:?}\", self_ty)\n+        };\n+        for &impl_def_id in self.tcx.incoherent_impls(simp) {\n             self.assemble_inherent_impl_probe(impl_def_id);\n         }\n     }\n@@ -765,7 +709,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n             // fcx's fulfillment context after this probe is over.\n             // Note: we only normalize `xform_self_ty` here since the normalization\n             // of the return type can lead to inference results that prohibit\n-            // valid canidates from being found, see issue #85671\n+            // valid candidates from being found, see issue #85671\n             // FIXME Postponing the normalization of the return type likely only hides a deeper bug,\n             // which might be caused by the `param_env` itself. The clauses of the `param_env`\n             // maybe shouldn't include `Param`s, but rather fresh variables or be canonicalized,\n@@ -1093,13 +1037,13 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n         }\n         let lev_candidate = self.probe_for_lev_candidate()?;\n \n-        Err(MethodError::NoMatch(NoMatchData::new(\n+        Err(MethodError::NoMatch(NoMatchData {\n             static_candidates,\n             unsatisfied_predicates,\n             out_of_scope_traits,\n             lev_candidate,\n-            self.mode,\n-        )))\n+            mode: self.mode,\n+        }))\n     }\n \n     fn pick_core(&mut self) -> Option<PickResult<'tcx>> {"}, {"sha": "e1d6b5d2bd425672b7a07ded2a29a4a2cc09b14e", "filename": "compiler/rustc_typeck/src/check/method/suggest.rs", "status": "modified", "additions": 20, "deletions": 17, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/3e7514670db841a7f0d7656f3b13b1c8b2c11599/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e7514670db841a7f0d7656f3b13b1c8b2c11599/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs?ref=3e7514670db841a7f0d7656f3b13b1c8b2c11599", "patch": "@@ -281,25 +281,28 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     // There are methods that are defined on the primitive types and won't be\n                     // found when exploring `all_traits`, but we also need them to be acurate on\n                     // our suggestions (#47759).\n-                    let fund_assoc = |opt_def_id: Option<DefId>| {\n-                        opt_def_id.and_then(|id| self.associated_value(id, item_name)).is_some()\n+                    let found_assoc = |ty: Ty<'tcx>| {\n+                        simplify_type(tcx, ty, TreatParams::AsPlaceholders)\n+                            .and_then(|simp| {\n+                                tcx.incoherent_impls(simp)\n+                                    .iter()\n+                                    .find_map(|&id| self.associated_value(id, item_name))\n+                            })\n+                            .is_some()\n                     };\n-                    let lang_items = tcx.lang_items();\n                     let found_candidate = candidates.next().is_some()\n-                        || fund_assoc(lang_items.i8_impl())\n-                        || fund_assoc(lang_items.i16_impl())\n-                        || fund_assoc(lang_items.i32_impl())\n-                        || fund_assoc(lang_items.i64_impl())\n-                        || fund_assoc(lang_items.i128_impl())\n-                        || fund_assoc(lang_items.u8_impl())\n-                        || fund_assoc(lang_items.u16_impl())\n-                        || fund_assoc(lang_items.u32_impl())\n-                        || fund_assoc(lang_items.u64_impl())\n-                        || fund_assoc(lang_items.u128_impl())\n-                        || fund_assoc(lang_items.f32_impl())\n-                        || fund_assoc(lang_items.f32_runtime_impl())\n-                        || fund_assoc(lang_items.f64_impl())\n-                        || fund_assoc(lang_items.f64_runtime_impl());\n+                        || found_assoc(tcx.types.i8)\n+                        || found_assoc(tcx.types.i16)\n+                        || found_assoc(tcx.types.i32)\n+                        || found_assoc(tcx.types.i64)\n+                        || found_assoc(tcx.types.i128)\n+                        || found_assoc(tcx.types.u8)\n+                        || found_assoc(tcx.types.u16)\n+                        || found_assoc(tcx.types.u32)\n+                        || found_assoc(tcx.types.u64)\n+                        || found_assoc(tcx.types.u128)\n+                        || found_assoc(tcx.types.f32)\n+                        || found_assoc(tcx.types.f32);\n                     if let (true, false, SelfSource::MethodCall(expr), true) = (\n                         actual.is_numeric(),\n                         actual.has_concrete_skeleton(),"}, {"sha": "e11bd9355ebf988b3a434b5654eaa07437061f54", "filename": "compiler/rustc_typeck/src/coherence/inherent_impls.rs", "status": "modified", "additions": 81, "deletions": 331, "changes": 412, "blob_url": "https://github.com/rust-lang/rust/blob/3e7514670db841a7f0d7656f3b13b1c8b2c11599/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Finherent_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e7514670db841a7f0d7656f3b13b1c8b2c11599/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Finherent_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Finherent_impls.rs?ref=3e7514670db841a7f0d7656f3b13b1c8b2c11599", "patch": "@@ -7,12 +7,13 @@\n //! `tcx.inherent_impls(def_id)`). That value, however,\n //! is computed by selecting an idea from this table.\n \n-use rustc_errors::{pluralize, struct_span_err};\n+use rustc_errors::struct_span_err;\n use rustc_hir as hir;\n-use rustc_hir::def_id::{DefId, LocalDefId};\n+use rustc_hir::def_id::{CrateNum, DefId, LocalDefId};\n use rustc_hir::itemlikevisit::ItemLikeVisitor;\n-use rustc_middle::ty::{self, CrateInherentImpls, TyCtxt};\n-\n+use rustc_middle::ty::fast_reject::{simplify_type, SimplifiedType, TreatParams};\n+use rustc_middle::ty::{self, CrateInherentImpls, Ty, TyCtxt};\n+use rustc_span::symbol::sym;\n use rustc_span::Span;\n \n /// On-demand query: yields a map containing all types mapped to their inherent impls.\n@@ -22,6 +23,13 @@ pub fn crate_inherent_impls(tcx: TyCtxt<'_>, (): ()) -> CrateInherentImpls {\n     collect.impls_map\n }\n \n+pub fn crate_incoherent_impls(tcx: TyCtxt<'_>, (_, simp): (CrateNum, SimplifiedType)) -> &[DefId] {\n+    let crate_map = tcx.crate_inherent_impls(());\n+    tcx.arena.alloc_from_iter(\n+        crate_map.incoherent_impls.get(&simp).unwrap_or(&Vec::new()).iter().map(|d| d.to_def_id()),\n+    )\n+}\n+\n /// On-demand query: yields a vector of the inherent impls for a specific type.\n pub fn inherent_impls(tcx: TyCtxt<'_>, ty_def_id: DefId) -> &[DefId] {\n     let ty_def_id = ty_def_id.expect_local();\n@@ -40,12 +48,11 @@ struct InherentCollect<'tcx> {\n \n impl<'tcx> ItemLikeVisitor<'_> for InherentCollect<'tcx> {\n     fn visit_item(&mut self, item: &hir::Item<'_>) {\n-        let hir::ItemKind::Impl(hir::Impl { of_trait: None, self_ty: ty, items: assoc_items, .. }) = item.kind else {\n+        let hir::ItemKind::Impl(hir::Impl { of_trait: None, self_ty: ty, ref items, .. }) = item.kind else {\n             return;\n         };\n \n         let self_ty = self.tcx.type_of(item.def_id);\n-        let lang_items = self.tcx.lang_items();\n         match *self_ty.kind() {\n             ty::Adt(def, _) => {\n                 self.check_def_id(item, def.did());\n@@ -67,276 +74,19 @@ impl<'tcx> ItemLikeVisitor<'_> for InherentCollect<'tcx> {\n                 .note(\"define and implement a new trait or type instead\")\n                 .emit();\n             }\n-            ty::Bool => {\n-                self.check_primitive_impl(\n-                    item.def_id,\n-                    lang_items.bool_impl(),\n-                    None,\n-                    \"bool\",\n-                    \"bool\",\n-                    item.span,\n-                    assoc_items,\n-                );\n-            }\n-            ty::Char => {\n-                self.check_primitive_impl(\n-                    item.def_id,\n-                    lang_items.char_impl(),\n-                    None,\n-                    \"char\",\n-                    \"char\",\n-                    item.span,\n-                    assoc_items,\n-                );\n-            }\n-            ty::Str => {\n-                self.check_primitive_impl(\n-                    item.def_id,\n-                    lang_items.str_impl(),\n-                    lang_items.str_alloc_impl(),\n-                    \"str\",\n-                    \"str\",\n-                    item.span,\n-                    assoc_items,\n-                );\n-            }\n-            ty::Slice(slice_item) if slice_item == self.tcx.types.u8 => {\n-                self.check_primitive_impl(\n-                    item.def_id,\n-                    lang_items.slice_u8_impl(),\n-                    lang_items.slice_u8_alloc_impl(),\n-                    \"slice_u8\",\n-                    \"[u8]\",\n-                    item.span,\n-                    assoc_items,\n-                );\n-            }\n-            ty::Slice(_) => {\n-                self.check_primitive_impl(\n-                    item.def_id,\n-                    lang_items.slice_impl(),\n-                    lang_items.slice_alloc_impl(),\n-                    \"slice\",\n-                    \"[T]\",\n-                    item.span,\n-                    assoc_items,\n-                );\n-            }\n-            ty::Array(_, _) => {\n-                self.check_primitive_impl(\n-                    item.def_id,\n-                    lang_items.array_impl(),\n-                    None,\n-                    \"array\",\n-                    \"[T; N]\",\n-                    item.span,\n-                    assoc_items,\n-                );\n-            }\n-            ty::RawPtr(ty::TypeAndMut { ty: inner, mutbl: hir::Mutability::Not })\n-                if matches!(inner.kind(), ty::Slice(_)) =>\n-            {\n-                self.check_primitive_impl(\n-                    item.def_id,\n-                    lang_items.const_slice_ptr_impl(),\n-                    None,\n-                    \"const_slice_ptr\",\n-                    \"*const [T]\",\n-                    item.span,\n-                    assoc_items,\n-                );\n-            }\n-            ty::RawPtr(ty::TypeAndMut { ty: inner, mutbl: hir::Mutability::Mut })\n-                if matches!(inner.kind(), ty::Slice(_)) =>\n-            {\n-                self.check_primitive_impl(\n-                    item.def_id,\n-                    lang_items.mut_slice_ptr_impl(),\n-                    None,\n-                    \"mut_slice_ptr\",\n-                    \"*mut [T]\",\n-                    item.span,\n-                    assoc_items,\n-                );\n-            }\n-            ty::RawPtr(ty::TypeAndMut { ty: _, mutbl: hir::Mutability::Not }) => {\n-                self.check_primitive_impl(\n-                    item.def_id,\n-                    lang_items.const_ptr_impl(),\n-                    None,\n-                    \"const_ptr\",\n-                    \"*const T\",\n-                    item.span,\n-                    assoc_items,\n-                );\n-            }\n-            ty::RawPtr(ty::TypeAndMut { ty: _, mutbl: hir::Mutability::Mut }) => {\n-                self.check_primitive_impl(\n-                    item.def_id,\n-                    lang_items.mut_ptr_impl(),\n-                    None,\n-                    \"mut_ptr\",\n-                    \"*mut T\",\n-                    item.span,\n-                    assoc_items,\n-                );\n-            }\n-            ty::Int(ty::IntTy::I8) => {\n-                self.check_primitive_impl(\n-                    item.def_id,\n-                    lang_items.i8_impl(),\n-                    None,\n-                    \"i8\",\n-                    \"i8\",\n-                    item.span,\n-                    assoc_items,\n-                );\n-            }\n-            ty::Int(ty::IntTy::I16) => {\n-                self.check_primitive_impl(\n-                    item.def_id,\n-                    lang_items.i16_impl(),\n-                    None,\n-                    \"i16\",\n-                    \"i16\",\n-                    item.span,\n-                    assoc_items,\n-                );\n-            }\n-            ty::Int(ty::IntTy::I32) => {\n-                self.check_primitive_impl(\n-                    item.def_id,\n-                    lang_items.i32_impl(),\n-                    None,\n-                    \"i32\",\n-                    \"i32\",\n-                    item.span,\n-                    assoc_items,\n-                );\n-            }\n-            ty::Int(ty::IntTy::I64) => {\n-                self.check_primitive_impl(\n-                    item.def_id,\n-                    lang_items.i64_impl(),\n-                    None,\n-                    \"i64\",\n-                    \"i64\",\n-                    item.span,\n-                    assoc_items,\n-                );\n-            }\n-            ty::Int(ty::IntTy::I128) => {\n-                self.check_primitive_impl(\n-                    item.def_id,\n-                    lang_items.i128_impl(),\n-                    None,\n-                    \"i128\",\n-                    \"i128\",\n-                    item.span,\n-                    assoc_items,\n-                );\n-            }\n-            ty::Int(ty::IntTy::Isize) => {\n-                self.check_primitive_impl(\n-                    item.def_id,\n-                    lang_items.isize_impl(),\n-                    None,\n-                    \"isize\",\n-                    \"isize\",\n-                    item.span,\n-                    assoc_items,\n-                );\n-            }\n-            ty::Uint(ty::UintTy::U8) => {\n-                self.check_primitive_impl(\n-                    item.def_id,\n-                    lang_items.u8_impl(),\n-                    None,\n-                    \"u8\",\n-                    \"u8\",\n-                    item.span,\n-                    assoc_items,\n-                );\n-            }\n-            ty::Uint(ty::UintTy::U16) => {\n-                self.check_primitive_impl(\n-                    item.def_id,\n-                    lang_items.u16_impl(),\n-                    None,\n-                    \"u16\",\n-                    \"u16\",\n-                    item.span,\n-                    assoc_items,\n-                );\n-            }\n-            ty::Uint(ty::UintTy::U32) => {\n-                self.check_primitive_impl(\n-                    item.def_id,\n-                    lang_items.u32_impl(),\n-                    None,\n-                    \"u32\",\n-                    \"u32\",\n-                    item.span,\n-                    assoc_items,\n-                );\n-            }\n-            ty::Uint(ty::UintTy::U64) => {\n-                self.check_primitive_impl(\n-                    item.def_id,\n-                    lang_items.u64_impl(),\n-                    None,\n-                    \"u64\",\n-                    \"u64\",\n-                    item.span,\n-                    assoc_items,\n-                );\n-            }\n-            ty::Uint(ty::UintTy::U128) => {\n-                self.check_primitive_impl(\n-                    item.def_id,\n-                    lang_items.u128_impl(),\n-                    None,\n-                    \"u128\",\n-                    \"u128\",\n-                    item.span,\n-                    assoc_items,\n-                );\n-            }\n-            ty::Uint(ty::UintTy::Usize) => {\n-                self.check_primitive_impl(\n-                    item.def_id,\n-                    lang_items.usize_impl(),\n-                    None,\n-                    \"usize\",\n-                    \"usize\",\n-                    item.span,\n-                    assoc_items,\n-                );\n-            }\n-            ty::Float(ty::FloatTy::F32) => {\n-                self.check_primitive_impl(\n-                    item.def_id,\n-                    lang_items.f32_impl(),\n-                    lang_items.f32_runtime_impl(),\n-                    \"f32\",\n-                    \"f32\",\n-                    item.span,\n-                    assoc_items,\n-                );\n-            }\n-            ty::Float(ty::FloatTy::F64) => {\n-                self.check_primitive_impl(\n-                    item.def_id,\n-                    lang_items.f64_impl(),\n-                    lang_items.f64_runtime_impl(),\n-                    \"f64\",\n-                    \"f64\",\n-                    item.span,\n-                    assoc_items,\n-                );\n-            }\n-            ty::Error(_) => {}\n-            _ => {\n+            ty::Bool\n+            | ty::Char\n+            | ty::Int(_)\n+            | ty::Uint(_)\n+            | ty::Float(_)\n+            | ty::Str\n+            | ty::Array(..)\n+            | ty::Slice(_)\n+            | ty::RawPtr(_)\n+            | ty::Ref(..)\n+            | ty::Never\n+            | ty::Tuple(..) => self.check_primitive_impl(item.def_id, self_ty, items, ty.span),\n+            ty::FnPtr(_) | ty::Projection(..) | ty::Opaque(..) | ty::Param(_) => {\n                 let mut err = struct_span_err!(\n                     self.tcx.sess,\n                     ty.span,\n@@ -347,16 +97,18 @@ impl<'tcx> ItemLikeVisitor<'_> for InherentCollect<'tcx> {\n                 err.span_label(ty.span, \"impl requires a nominal type\")\n                     .note(\"either implement a trait on it or create a newtype to wrap it instead\");\n \n-                if let ty::Ref(_, subty, _) = self_ty.kind() {\n-                    err.note(&format!(\n-                        \"you could also try moving the reference to \\\n-                            uses of `{}` (such as `self`) within the implementation\",\n-                        subty\n-                    ));\n-                }\n-\n                 err.emit();\n             }\n+            ty::FnDef(..)\n+            | ty::Closure(..)\n+            | ty::Generator(..)\n+            | ty::GeneratorWitness(..)\n+            | ty::Bound(..)\n+            | ty::Placeholder(_)\n+            | ty::Infer(_) => {\n+                bug!(\"unexpected impl self type of impl: {:?} {:?}\", item.def_id, self_ty);\n+            }\n+            ty::Error(_) => {}\n         }\n     }\n \n@@ -390,60 +142,58 @@ impl<'tcx> InherentCollect<'tcx> {\n     }\n \n     fn check_primitive_impl(\n-        &self,\n+        &mut self,\n         impl_def_id: LocalDefId,\n-        lang_def_id: Option<DefId>,\n-        lang_def_id2: Option<DefId>,\n-        lang: &str,\n-        ty: &str,\n+        ty: Ty<'tcx>,\n+        items: &[hir::ImplItemRef],\n         span: Span,\n-        assoc_items: &[hir::ImplItemRef],\n     ) {\n-        match (lang_def_id, lang_def_id2) {\n-            (Some(lang_def_id), _) if lang_def_id == impl_def_id.to_def_id() => {\n-                // OK\n-            }\n-            (_, Some(lang_def_id)) if lang_def_id == impl_def_id.to_def_id() => {\n-                // OK\n-            }\n-            _ => {\n-                let to_implement = if assoc_items.is_empty() {\n-                    String::new()\n-                } else {\n-                    let assoc_items_kind = {\n-                        let item_types = assoc_items.iter().map(|x| x.kind);\n-                        if item_types.clone().all(|x| x == hir::AssocItemKind::Const) {\n-                            \"constant\"\n-                        } else if item_types\n-                            .clone()\n-                            .all(|x| matches! {x, hir::AssocItemKind::Fn{ .. } })\n-                        {\n-                            \"method\"\n-                        } else {\n-                            \"associated item\"\n-                        }\n-                    };\n-\n-                    format!(\n-                        \" to implement {} {}{}\",\n-                        pluralize!(\"this\", assoc_items.len()),\n-                        assoc_items_kind,\n-                        pluralize!(assoc_items.len()),\n-                    )\n-                };\n-\n-                struct_span_err!(\n+        const INTO_CORE: &str = \"consider moving this inherent impl into `core` if possible\";\n+        const ADD_ATTR: &str =\n+            \"alternatively add `#[rustc_allow_incoherent_impl]` to the relevant impl items\";\n+        if !self.tcx.hir().rustc_coherence_is_core() {\n+            if self.tcx.features().rustc_attrs {\n+                for item in items {\n+                    if !self\n+                        .tcx\n+                        .has_attr(item.id.def_id.to_def_id(), sym::rustc_allow_incoherent_impl)\n+                    {\n+                        struct_span_err!(\n+                            self.tcx.sess,\n+                            span,\n+                            E0390,\n+                            \"cannot define inherent `impl` for primitive types outside of `core`\",\n+                        )\n+                        .help(INTO_CORE)\n+                        .span_help(item.span, ADD_ATTR)\n+                        .emit();\n+                        return;\n+                    }\n+                }\n+            } else {\n+                let mut err = struct_span_err!(\n                     self.tcx.sess,\n                     span,\n                     E0390,\n-                    \"only a single inherent implementation marked with `#[lang = \\\n-                                  \\\"{}\\\"]` is allowed for the `{}` primitive\",\n-                    lang,\n-                    ty\n-                )\n-                .help(&format!(\"consider using a trait{}\", to_implement))\n-                .emit();\n+                    \"cannot define inherent `impl` for primitive types\",\n+                );\n+                err.help(\"consider using an extension trait instead\");\n+                if let ty::Ref(_, subty, _) = ty.kind() {\n+                    err.note(&format!(\n+                        \"you could also try moving the reference to \\\n+                            uses of `{}` (such as `self`) within the implementation\",\n+                        subty\n+                    ));\n+                }\n+                err.emit();\n+                return;\n             }\n         }\n+\n+        if let Some(simp) = simplify_type(self.tcx, ty, TreatParams::AsPlaceholders) {\n+            self.impls_map.incoherent_impls.entry(simp).or_default().push(impl_def_id);\n+        } else {\n+            bug!(\"unexpected primitive type: {:?}\", ty);\n+        }\n     }\n }"}, {"sha": "3f1b4828d1af36089e11fa39965c09f6fc0a132f", "filename": "compiler/rustc_typeck/src/coherence/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3e7514670db841a7f0d7656f3b13b1c8b2c11599/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e7514670db841a7f0d7656f3b13b1c8b2c11599/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Fmod.rs?ref=3e7514670db841a7f0d7656f3b13b1c8b2c11599", "patch": "@@ -144,13 +144,14 @@ fn enforce_empty_impls_for_marker_traits(\n \n pub fn provide(providers: &mut Providers) {\n     use self::builtin::coerce_unsized_info;\n-    use self::inherent_impls::{crate_inherent_impls, inherent_impls};\n+    use self::inherent_impls::{crate_incoherent_impls, crate_inherent_impls, inherent_impls};\n     use self::inherent_impls_overlap::crate_inherent_impls_overlap_check;\n     use self::orphan::orphan_check_crate;\n \n     *providers = Providers {\n         coherent_trait,\n         crate_inherent_impls,\n+        crate_incoherent_impls,\n         inherent_impls,\n         crate_inherent_impls_overlap_check,\n         coerce_unsized_info,"}, {"sha": "89d85146963cfa52b63011e8b04d131337dd3934", "filename": "library/alloc/src/slice.rs", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/3e7514670db841a7f0d7656f3b13b1c8b2c11599/library%2Falloc%2Fsrc%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e7514670db841a7f0d7656f3b13b1c8b2c11599/library%2Falloc%2Fsrc%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fslice.rs?ref=3e7514670db841a7f0d7656f3b13b1c8b2c11599", "patch": "@@ -237,7 +237,7 @@ mod hack {\n     }\n }\n \n-#[lang = \"slice_alloc\"]\n+#[cfg_attr(bootstrap, lang = \"slice_alloc\")]\n #[cfg(not(test))]\n impl<T> [T] {\n     /// Sorts the slice.\n@@ -267,6 +267,7 @@ impl<T> [T] {\n     /// assert!(v == [-5, -3, 1, 2, 4]);\n     /// ```\n     #[cfg(not(no_global_oom_handling))]\n+    #[cfg_attr(not(bootstrap), rustc_allow_incoherent_impl)]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn sort(&mut self)\n@@ -322,6 +323,7 @@ impl<T> [T] {\n     /// assert!(v == [5, 4, 3, 2, 1]);\n     /// ```\n     #[cfg(not(no_global_oom_handling))]\n+    #[cfg_attr(not(bootstrap), rustc_allow_incoherent_impl)]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn sort_by<F>(&mut self, mut compare: F)\n@@ -363,6 +365,7 @@ impl<T> [T] {\n     /// assert!(v == [1, 2, -3, 4, -5]);\n     /// ```\n     #[cfg(not(no_global_oom_handling))]\n+    #[cfg_attr(not(bootstrap), rustc_allow_incoherent_impl)]\n     #[stable(feature = \"slice_sort_by_key\", since = \"1.7.0\")]\n     #[inline]\n     pub fn sort_by_key<K, F>(&mut self, mut f: F)\n@@ -409,6 +412,7 @@ impl<T> [T] {\n     ///\n     /// [pdqsort]: https://github.com/orlp/pdqsort\n     #[cfg(not(no_global_oom_handling))]\n+    #[cfg_attr(not(bootstrap), rustc_allow_incoherent_impl)]\n     #[stable(feature = \"slice_sort_by_cached_key\", since = \"1.34.0\")]\n     #[inline]\n     pub fn sort_by_cached_key<K, F>(&mut self, f: F)\n@@ -467,6 +471,7 @@ impl<T> [T] {\n     /// // Here, `s` and `x` can be modified independently.\n     /// ```\n     #[cfg(not(no_global_oom_handling))]\n+    #[cfg_attr(not(bootstrap), rustc_allow_incoherent_impl)]\n     #[rustc_conversion_suggestion]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n@@ -491,6 +496,7 @@ impl<T> [T] {\n     /// // Here, `s` and `x` can be modified independently.\n     /// ```\n     #[cfg(not(no_global_oom_handling))]\n+    #[cfg_attr(not(bootstrap), rustc_allow_incoherent_impl)]\n     #[inline]\n     #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n     pub fn to_vec_in<A: Allocator>(&self, alloc: A) -> Vec<T, A>\n@@ -515,6 +521,7 @@ impl<T> [T] {\n     ///\n     /// assert_eq!(x, vec![10, 40, 30]);\n     /// ```\n+    #[cfg_attr(not(bootstrap), rustc_allow_incoherent_impl)]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn into_vec<A: Allocator>(self: Box<Self, A>) -> Vec<T, A> {\n@@ -542,6 +549,7 @@ impl<T> [T] {\n     /// // this will panic at runtime\n     /// b\"0123456789abcdef\".repeat(usize::MAX);\n     /// ```\n+    #[cfg_attr(not(bootstrap), rustc_allow_incoherent_impl)]\n     #[cfg(not(no_global_oom_handling))]\n     #[stable(feature = \"repeat_generic_slice\", since = \"1.40.0\")]\n     pub fn repeat(&self, n: usize) -> Vec<T>\n@@ -610,6 +618,7 @@ impl<T> [T] {\n     /// assert_eq!([\"hello\", \"world\"].concat(), \"helloworld\");\n     /// assert_eq!([[1, 2], [3, 4]].concat(), [1, 2, 3, 4]);\n     /// ```\n+    #[cfg_attr(not(bootstrap), rustc_allow_incoherent_impl)]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn concat<Item: ?Sized>(&self) -> <Self as Concat<Item>>::Output\n     where\n@@ -628,6 +637,7 @@ impl<T> [T] {\n     /// assert_eq!([[1, 2], [3, 4]].join(&0), [1, 2, 0, 3, 4]);\n     /// assert_eq!([[1, 2], [3, 4]].join(&[0, 0][..]), [1, 2, 0, 0, 3, 4]);\n     /// ```\n+    #[cfg_attr(not(bootstrap), rustc_allow_incoherent_impl)]\n     #[stable(feature = \"rename_connect_to_join\", since = \"1.3.0\")]\n     pub fn join<Separator>(&self, sep: Separator) -> <Self as Join<Separator>>::Output\n     where\n@@ -646,6 +656,7 @@ impl<T> [T] {\n     /// assert_eq!([\"hello\", \"world\"].connect(\" \"), \"hello world\");\n     /// assert_eq!([[1, 2], [3, 4]].connect(&0), [1, 2, 0, 3, 4]);\n     /// ```\n+    #[cfg_attr(not(bootstrap), rustc_allow_incoherent_impl)]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[rustc_deprecated(since = \"1.3.0\", reason = \"renamed to join\")]\n     pub fn connect<Separator>(&self, sep: Separator) -> <Self as Join<Separator>>::Output\n@@ -656,7 +667,7 @@ impl<T> [T] {\n     }\n }\n \n-#[lang = \"slice_u8_alloc\"]\n+#[cfg_attr(bootstrap, lang = \"slice_u8_alloc\")]\n #[cfg(not(test))]\n impl [u8] {\n     /// Returns a vector containing a copy of this slice where each byte\n@@ -669,6 +680,7 @@ impl [u8] {\n     ///\n     /// [`make_ascii_uppercase`]: slice::make_ascii_uppercase\n     #[cfg(not(no_global_oom_handling))]\n+    #[cfg_attr(not(bootstrap), rustc_allow_incoherent_impl)]\n     #[must_use = \"this returns the uppercase bytes as a new Vec, \\\n                   without modifying the original\"]\n     #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.23.0\")]\n@@ -689,6 +701,7 @@ impl [u8] {\n     ///\n     /// [`make_ascii_lowercase`]: slice::make_ascii_lowercase\n     #[cfg(not(no_global_oom_handling))]\n+    #[cfg_attr(not(bootstrap), rustc_allow_incoherent_impl)]\n     #[must_use = \"this returns the lowercase bytes as a new Vec, \\\n                   without modifying the original\"]\n     #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.23.0\")]"}, {"sha": "a3c17612c3a0b3211c8a24521b7a1df571b85419", "filename": "library/alloc/src/str.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/3e7514670db841a7f0d7656f3b13b1c8b2c11599/library%2Falloc%2Fsrc%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e7514670db841a7f0d7656f3b13b1c8b2c11599/library%2Falloc%2Fsrc%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fstr.rs?ref=3e7514670db841a7f0d7656f3b13b1c8b2c11599", "patch": "@@ -235,7 +235,7 @@ impl ToOwned for str {\n }\n \n /// Methods for string slices.\n-#[lang = \"str_alloc\"]\n+#[cfg_attr(bootstrap, lang = \"str_alloc\")]\n #[cfg(not(test))]\n impl str {\n     /// Converts a `Box<str>` into a `Box<[u8]>` without copying or allocating.\n@@ -250,6 +250,7 @@ impl str {\n     /// let boxed_bytes = boxed_str.into_boxed_bytes();\n     /// assert_eq!(*boxed_bytes, *s.as_bytes());\n     /// ```\n+    #[cfg_attr(not(bootstrap), rustc_allow_incoherent_impl)]\n     #[stable(feature = \"str_box_extras\", since = \"1.20.0\")]\n     #[must_use = \"`self` will be dropped if the result is not used\"]\n     #[inline]\n@@ -280,6 +281,7 @@ impl str {\n     /// assert_eq!(s, s.replace(\"cookie monster\", \"little lamb\"));\n     /// ```\n     #[cfg(not(no_global_oom_handling))]\n+    #[cfg_attr(not(bootstrap), rustc_allow_incoherent_impl)]\n     #[must_use = \"this returns the replaced string as a new allocation, \\\n                   without modifying the original\"]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -320,6 +322,7 @@ impl str {\n     /// assert_eq!(s, s.replacen(\"cookie monster\", \"little lamb\", 10));\n     /// ```\n     #[cfg(not(no_global_oom_handling))]\n+    #[cfg_attr(not(bootstrap), rustc_allow_incoherent_impl)]\n     #[must_use = \"this returns the replaced string as a new allocation, \\\n                   without modifying the original\"]\n     #[stable(feature = \"str_replacen\", since = \"1.16.0\")]\n@@ -376,6 +379,7 @@ impl str {\n     /// assert_eq!(new_year, new_year.to_lowercase());\n     /// ```\n     #[cfg(not(no_global_oom_handling))]\n+    #[cfg_attr(not(bootstrap), rustc_allow_incoherent_impl)]\n     #[must_use = \"this returns the lowercase string as a new String, \\\n                   without modifying the original\"]\n     #[stable(feature = \"unicode_case_mapping\", since = \"1.2.0\")]\n@@ -458,6 +462,7 @@ impl str {\n     /// assert_eq!(\"TSCH\u00dcSS\", s.to_uppercase());\n     /// ```\n     #[cfg(not(no_global_oom_handling))]\n+    #[cfg_attr(not(bootstrap), rustc_allow_incoherent_impl)]\n     #[must_use = \"this returns the uppercase string as a new String, \\\n                   without modifying the original\"]\n     #[stable(feature = \"unicode_case_mapping\", since = \"1.2.0\")]\n@@ -493,6 +498,7 @@ impl str {\n     /// assert_eq!(boxed_str.into_string(), string);\n     /// ```\n     #[stable(feature = \"box_str\", since = \"1.4.0\")]\n+    #[cfg_attr(not(bootstrap), rustc_allow_incoherent_impl)]\n     #[must_use = \"`self` will be dropped if the result is not used\"]\n     #[inline]\n     pub fn into_string(self: Box<str>) -> String {\n@@ -521,6 +527,7 @@ impl str {\n     /// let huge = \"0123456789abcdef\".repeat(usize::MAX);\n     /// ```\n     #[cfg(not(no_global_oom_handling))]\n+    #[cfg_attr(not(bootstrap), rustc_allow_incoherent_impl)]\n     #[must_use]\n     #[stable(feature = \"repeat_str\", since = \"1.16.0\")]\n     pub fn repeat(&self, n: usize) -> String {\n@@ -549,6 +556,7 @@ impl str {\n     /// [`make_ascii_uppercase`]: str::make_ascii_uppercase\n     /// [`to_uppercase`]: #method.to_uppercase\n     #[cfg(not(no_global_oom_handling))]\n+    #[cfg_attr(not(bootstrap), rustc_allow_incoherent_impl)]\n     #[must_use = \"to uppercase the value in-place, use `make_ascii_uppercase()`\"]\n     #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.23.0\")]\n     #[inline]\n@@ -581,6 +589,7 @@ impl str {\n     /// [`make_ascii_lowercase`]: str::make_ascii_lowercase\n     /// [`to_lowercase`]: #method.to_lowercase\n     #[cfg(not(no_global_oom_handling))]\n+    #[cfg_attr(not(bootstrap), rustc_allow_incoherent_impl)]\n     #[must_use = \"to lowercase the value in-place, use `make_ascii_lowercase()`\"]\n     #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.23.0\")]\n     #[inline]"}, {"sha": "9e42ab5923aa084dd15b7f7f63bb88b4f78dbbad", "filename": "library/core/src/array/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3e7514670db841a7f0d7656f3b13b1c8b2c11599/library%2Fcore%2Fsrc%2Farray%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e7514670db841a7f0d7656f3b13b1c8b2c11599/library%2Fcore%2Fsrc%2Farray%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Farray%2Fmod.rs?ref=3e7514670db841a7f0d7656f3b13b1c8b2c11599", "patch": "@@ -395,7 +395,7 @@ macro_rules! array_impl_default {\n \n array_impl_default! {32, T T T T T T T T T T T T T T T T T T T T T T T T T T T T T T T T}\n \n-#[lang = \"array\"]\n+#[cfg_attr(bootstrap, lang = \"array\")]\n impl<T, const N: usize> [T; N] {\n     /// Returns an array of the same size as `self`, with function `f` applied to each element\n     /// in order."}, {"sha": "06aee3ccbaf9c891be10c0ebf5bbbc47714bf39a", "filename": "library/core/src/bool.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3e7514670db841a7f0d7656f3b13b1c8b2c11599/library%2Fcore%2Fsrc%2Fbool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e7514670db841a7f0d7656f3b13b1c8b2c11599/library%2Fcore%2Fsrc%2Fbool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fbool.rs?ref=3e7514670db841a7f0d7656f3b13b1c8b2c11599", "patch": "@@ -2,7 +2,7 @@\n \n use crate::marker::Destruct;\n \n-#[lang = \"bool\"]\n+#[cfg_attr(bootstrap, lang = \"bool\")]\n impl bool {\n     /// Returns `Some(t)` if the `bool` is [`true`](../std/keyword.true.html),\n     /// or `None` otherwise."}, {"sha": "7deb3358c95d56b1d1b0d19e488089c3c9432ebb", "filename": "library/core/src/char/methods.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3e7514670db841a7f0d7656f3b13b1c8b2c11599/library%2Fcore%2Fsrc%2Fchar%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e7514670db841a7f0d7656f3b13b1c8b2c11599/library%2Fcore%2Fsrc%2Fchar%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fchar%2Fmethods.rs?ref=3e7514670db841a7f0d7656f3b13b1c8b2c11599", "patch": "@@ -7,7 +7,7 @@ use crate::unicode::{self, conversions};\n \n use super::*;\n \n-#[lang = \"char\"]\n+#[cfg_attr(bootstrap, lang = \"char\")]\n impl char {\n     /// The highest valid code point a `char` can have, `'\\u{10FFFF}'`.\n     ///"}, {"sha": "445a7ba6e2d669b4ac58bc7ab751923bbc63a342", "filename": "library/core/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3e7514670db841a7f0d7656f3b13b1c8b2c11599/library%2Fcore%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e7514670db841a7f0d7656f3b13b1c8b2c11599/library%2Fcore%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Flib.rs?ref=3e7514670db841a7f0d7656f3b13b1c8b2c11599", "patch": "@@ -84,6 +84,7 @@\n     target_has_atomic_load_store = \"ptr\",\n ))]\n #![no_core]\n+#![cfg_attr(not(bootstrap), rustc_coherence_is_core)]\n //\n // Lints:\n #![deny(rust_2021_incompatible_or_patterns)]"}, {"sha": "17ca85476854620f1ea9f1facc3a5a1157e35f3c", "filename": "library/core/src/num/f32.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3e7514670db841a7f0d7656f3b13b1c8b2c11599/library%2Fcore%2Fsrc%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e7514670db841a7f0d7656f3b13b1c8b2c11599/library%2Fcore%2Fsrc%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Ff32.rs?ref=3e7514670db841a7f0d7656f3b13b1c8b2c11599", "patch": "@@ -370,7 +370,7 @@ pub mod consts {\n     pub const LN_10: f32 = 2.30258509299404568401799145468436421_f32;\n }\n \n-#[lang = \"f32\"]\n+#[cfg_attr(bootstrap, lang = \"f32\")]\n #[cfg(not(test))]\n impl f32 {\n     /// The radix or base of the internal representation of `f32`."}, {"sha": "350d8529de57ab33b4005827bbf0b36540ecb507", "filename": "library/core/src/num/f64.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3e7514670db841a7f0d7656f3b13b1c8b2c11599/library%2Fcore%2Fsrc%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e7514670db841a7f0d7656f3b13b1c8b2c11599/library%2Fcore%2Fsrc%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Ff64.rs?ref=3e7514670db841a7f0d7656f3b13b1c8b2c11599", "patch": "@@ -370,7 +370,7 @@ pub mod consts {\n     pub const LN_10: f64 = 2.30258509299404568401799145468436421_f64;\n }\n \n-#[lang = \"f64\"]\n+#[cfg_attr(bootstrap, lang = \"f64\")]\n #[cfg(not(test))]\n impl f64 {\n     /// The radix or base of the internal representation of `f64`."}, {"sha": "f4f1d274d105b203b34d274f71abfcaebf48fa9d", "filename": "library/core/src/num/mod.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/3e7514670db841a7f0d7656f3b13b1c8b2c11599/library%2Fcore%2Fsrc%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e7514670db841a7f0d7656f3b13b1c8b2c11599/library%2Fcore%2Fsrc%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fmod.rs?ref=3e7514670db841a7f0d7656f3b13b1c8b2c11599", "patch": "@@ -193,34 +193,34 @@ macro_rules! widening_impl {\n     };\n }\n \n-#[lang = \"i8\"]\n+#[cfg_attr(bootstrap, lang = \"i8\")]\n impl i8 {\n     int_impl! { i8, i8, u8, 8, 7, -128, 127, 2, \"-0x7e\", \"0xa\", \"0x12\", \"0x12\", \"0x48\",\n     \"[0x12]\", \"[0x12]\", \"\", \"\" }\n }\n \n-#[lang = \"i16\"]\n+#[cfg_attr(bootstrap, lang = \"i16\")]\n impl i16 {\n     int_impl! { i16, i16, u16, 16, 15, -32768, 32767, 4, \"-0x5ffd\", \"0x3a\", \"0x1234\", \"0x3412\",\n     \"0x2c48\", \"[0x34, 0x12]\", \"[0x12, 0x34]\", \"\", \"\" }\n }\n \n-#[lang = \"i32\"]\n+#[cfg_attr(bootstrap, lang = \"i32\")]\n impl i32 {\n     int_impl! { i32, i32, u32, 32, 31, -2147483648, 2147483647, 8, \"0x10000b3\", \"0xb301\",\n     \"0x12345678\", \"0x78563412\", \"0x1e6a2c48\", \"[0x78, 0x56, 0x34, 0x12]\",\n     \"[0x12, 0x34, 0x56, 0x78]\", \"\", \"\" }\n }\n \n-#[lang = \"i64\"]\n+#[cfg_attr(bootstrap, lang = \"i64\")]\n impl i64 {\n     int_impl! { i64, i64, u64, 64, 63, -9223372036854775808, 9223372036854775807, 12,\n     \"0xaa00000000006e1\", \"0x6e10aa\", \"0x1234567890123456\", \"0x5634129078563412\",\n     \"0x6a2c48091e6a2c48\", \"[0x56, 0x34, 0x12, 0x90, 0x78, 0x56, 0x34, 0x12]\",\n     \"[0x12, 0x34, 0x56, 0x78, 0x90, 0x12, 0x34, 0x56]\", \"\", \"\" }\n }\n \n-#[lang = \"i128\"]\n+#[cfg_attr(bootstrap, lang = \"i128\")]\n impl i128 {\n     int_impl! { i128, i128, u128, 128, 127, -170141183460469231731687303715884105728,\n     170141183460469231731687303715884105727, 16,\n@@ -233,15 +233,15 @@ impl i128 {\n }\n \n #[cfg(target_pointer_width = \"16\")]\n-#[lang = \"isize\"]\n+#[cfg_attr(bootstrap, lang = \"isize\")]\n impl isize {\n     int_impl! { isize, i16, usize, 16, 15, -32768, 32767, 4, \"-0x5ffd\", \"0x3a\", \"0x1234\",\n     \"0x3412\", \"0x2c48\", \"[0x34, 0x12]\", \"[0x12, 0x34]\",\n     usize_isize_to_xe_bytes_doc!(), usize_isize_from_xe_bytes_doc!() }\n }\n \n #[cfg(target_pointer_width = \"32\")]\n-#[lang = \"isize\"]\n+#[cfg_attr(bootstrap, lang = \"isize\")]\n impl isize {\n     int_impl! { isize, i32, usize, 32, 31, -2147483648, 2147483647, 8, \"0x10000b3\", \"0xb301\",\n     \"0x12345678\", \"0x78563412\", \"0x1e6a2c48\", \"[0x78, 0x56, 0x34, 0x12]\",\n@@ -250,7 +250,7 @@ impl isize {\n }\n \n #[cfg(target_pointer_width = \"64\")]\n-#[lang = \"isize\"]\n+#[cfg_attr(bootstrap, lang = \"isize\")]\n impl isize {\n     int_impl! { isize, i64, usize, 64, 63, -9223372036854775808, 9223372036854775807,\n     12, \"0xaa00000000006e1\", \"0x6e10aa\",  \"0x1234567890123456\", \"0x5634129078563412\",\n@@ -262,7 +262,7 @@ impl isize {\n /// If 6th bit set ascii is upper case.\n const ASCII_CASE_MASK: u8 = 0b0010_0000;\n \n-#[lang = \"u8\"]\n+#[cfg_attr(bootstrap, lang = \"u8\")]\n impl u8 {\n     uint_impl! { u8, u8, i8, NonZeroU8, 8, 255, 2, \"0x82\", \"0xa\", \"0x12\", \"0x12\", \"0x48\", \"[0x12]\",\n     \"[0x12]\", \"\", \"\" }\n@@ -816,7 +816,7 @@ impl u8 {\n     }\n }\n \n-#[lang = \"u16\"]\n+#[cfg_attr(bootstrap, lang = \"u16\")]\n impl u16 {\n     uint_impl! { u16, u16, i16, NonZeroU16, 16, 65535, 4, \"0xa003\", \"0x3a\", \"0x1234\", \"0x3412\", \"0x2c48\",\n     \"[0x34, 0x12]\", \"[0x12, 0x34]\", \"\", \"\" }\n@@ -848,14 +848,14 @@ impl u16 {\n     }\n }\n \n-#[lang = \"u32\"]\n+#[cfg_attr(bootstrap, lang = \"u32\")]\n impl u32 {\n     uint_impl! { u32, u32, i32, NonZeroU32, 32, 4294967295, 8, \"0x10000b3\", \"0xb301\", \"0x12345678\",\n     \"0x78563412\", \"0x1e6a2c48\", \"[0x78, 0x56, 0x34, 0x12]\", \"[0x12, 0x34, 0x56, 0x78]\", \"\", \"\" }\n     widening_impl! { u32, u64, 32, unsigned }\n }\n \n-#[lang = \"u64\"]\n+#[cfg_attr(bootstrap, lang = \"u64\")]\n impl u64 {\n     uint_impl! { u64, u64, i64, NonZeroU64, 64, 18446744073709551615, 12, \"0xaa00000000006e1\", \"0x6e10aa\",\n     \"0x1234567890123456\", \"0x5634129078563412\", \"0x6a2c48091e6a2c48\",\n@@ -865,7 +865,7 @@ impl u64 {\n     widening_impl! { u64, u128, 64, unsigned }\n }\n \n-#[lang = \"u128\"]\n+#[cfg_attr(bootstrap, lang = \"u128\")]\n impl u128 {\n     uint_impl! { u128, u128, i128, NonZeroU128, 128, 340282366920938463463374607431768211455, 16,\n     \"0x13f40000000000000000000000004f76\", \"0x4f7613f4\", \"0x12345678901234567890123456789012\",\n@@ -878,15 +878,15 @@ impl u128 {\n }\n \n #[cfg(target_pointer_width = \"16\")]\n-#[lang = \"usize\"]\n+#[cfg_attr(bootstrap, lang = \"usize\")]\n impl usize {\n     uint_impl! { usize, u16, isize, NonZeroUsize, 16, 65535, 4, \"0xa003\", \"0x3a\", \"0x1234\", \"0x3412\", \"0x2c48\",\n     \"[0x34, 0x12]\", \"[0x12, 0x34]\",\n     usize_isize_to_xe_bytes_doc!(), usize_isize_from_xe_bytes_doc!() }\n     widening_impl! { usize, u32, 16, unsigned }\n }\n #[cfg(target_pointer_width = \"32\")]\n-#[lang = \"usize\"]\n+#[cfg_attr(bootstrap, lang = \"usize\")]\n impl usize {\n     uint_impl! { usize, u32, isize, NonZeroUsize, 32, 4294967295, 8, \"0x10000b3\", \"0xb301\", \"0x12345678\",\n     \"0x78563412\", \"0x1e6a2c48\", \"[0x78, 0x56, 0x34, 0x12]\", \"[0x12, 0x34, 0x56, 0x78]\",\n@@ -895,7 +895,7 @@ impl usize {\n }\n \n #[cfg(target_pointer_width = \"64\")]\n-#[lang = \"usize\"]\n+#[cfg_attr(bootstrap, lang = \"usize\")]\n impl usize {\n     uint_impl! { usize, u64, isize, NonZeroUsize, 64, 18446744073709551615, 12, \"0xaa00000000006e1\", \"0x6e10aa\",\n     \"0x1234567890123456\", \"0x5634129078563412\", \"0x6a2c48091e6a2c48\","}, {"sha": "209ea5cb0439b88637f3e7afc5fc2225a17d8bc4", "filename": "library/core/src/ptr/const_ptr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3e7514670db841a7f0d7656f3b13b1c8b2c11599/library%2Fcore%2Fsrc%2Fptr%2Fconst_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e7514670db841a7f0d7656f3b13b1c8b2c11599/library%2Fcore%2Fsrc%2Fptr%2Fconst_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fconst_ptr.rs?ref=3e7514670db841a7f0d7656f3b13b1c8b2c11599", "patch": "@@ -4,7 +4,7 @@ use crate::intrinsics;\n use crate::mem;\n use crate::slice::{self, SliceIndex};\n \n-#[lang = \"const_ptr\"]\n+#[cfg_attr(bootstrap, lang = \"const_ptr\")]\n impl<T: ?Sized> *const T {\n     /// Returns `true` if the pointer is null.\n     ///\n@@ -1042,7 +1042,7 @@ impl<T: ?Sized> *const T {\n     }\n }\n \n-#[lang = \"const_slice_ptr\"]\n+#[cfg_attr(bootstrap, lang = \"const_slice_ptr\")]\n impl<T> *const [T] {\n     /// Returns the length of a raw slice.\n     ///"}, {"sha": "bfc89625935d900ed5c8db42bf67a874efbe816f", "filename": "library/core/src/ptr/mut_ptr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3e7514670db841a7f0d7656f3b13b1c8b2c11599/library%2Fcore%2Fsrc%2Fptr%2Fmut_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e7514670db841a7f0d7656f3b13b1c8b2c11599/library%2Fcore%2Fsrc%2Fptr%2Fmut_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fmut_ptr.rs?ref=3e7514670db841a7f0d7656f3b13b1c8b2c11599", "patch": "@@ -3,7 +3,7 @@ use crate::cmp::Ordering::{self, Equal, Greater, Less};\n use crate::intrinsics;\n use crate::slice::{self, SliceIndex};\n \n-#[lang = \"mut_ptr\"]\n+#[cfg_attr(bootstrap, lang = \"mut_ptr\")]\n impl<T: ?Sized> *mut T {\n     /// Returns `true` if the pointer is null.\n     ///\n@@ -1313,7 +1313,7 @@ impl<T: ?Sized> *mut T {\n     }\n }\n \n-#[lang = \"mut_slice_ptr\"]\n+#[cfg_attr(bootstrap, lang = \"mut_slice_ptr\")]\n impl<T> *mut [T] {\n     /// Returns the length of a raw slice.\n     ///"}, {"sha": "7c002130040ac418edef500459cb6d34fd171f3e", "filename": "library/core/src/slice/ascii.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3e7514670db841a7f0d7656f3b13b1c8b2c11599/library%2Fcore%2Fsrc%2Fslice%2Fascii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e7514670db841a7f0d7656f3b13b1c8b2c11599/library%2Fcore%2Fsrc%2Fslice%2Fascii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fascii.rs?ref=3e7514670db841a7f0d7656f3b13b1c8b2c11599", "patch": "@@ -6,7 +6,7 @@ use crate::iter;\n use crate::mem;\n use crate::ops;\n \n-#[lang = \"slice_u8\"]\n+#[cfg_attr(bootstrap, lang = \"slice_u8\")]\n #[cfg(not(test))]\n impl [u8] {\n     /// Checks if all bytes in this slice are within the ASCII range."}, {"sha": "77bf5f9dc34e31759ae64ff75eb849229fa30a04", "filename": "library/core/src/slice/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3e7514670db841a7f0d7656f3b13b1c8b2c11599/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e7514670db841a7f0d7656f3b13b1c8b2c11599/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs?ref=3e7514670db841a7f0d7656f3b13b1c8b2c11599", "patch": "@@ -109,7 +109,7 @@ enum Direction {\n     Back,\n }\n \n-#[lang = \"slice\"]\n+#[cfg_attr(bootstrap, lang = \"slice\")]\n #[cfg(not(test))]\n impl<T> [T] {\n     /// Returns the number of elements in the slice."}, {"sha": "6bfa6a5e01519985c954a215599b4e1bac1e5d86", "filename": "library/core/src/str/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3e7514670db841a7f0d7656f3b13b1c8b2c11599/library%2Fcore%2Fsrc%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e7514670db841a7f0d7656f3b13b1c8b2c11599/library%2Fcore%2Fsrc%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fstr%2Fmod.rs?ref=3e7514670db841a7f0d7656f3b13b1c8b2c11599", "patch": "@@ -130,7 +130,7 @@ fn slice_error_fail_rt(s: &str, begin: usize, end: usize) -> ! {\n     );\n }\n \n-#[lang = \"str\"]\n+#[cfg_attr(bootstrap, lang = \"str\")]\n #[cfg(not(test))]\n impl str {\n     /// Returns the length of `self`."}, {"sha": "70b5941c7c72b915a5b3e11c7195221f9a596597", "filename": "library/std/src/f32.rs", "status": "modified", "additions": 40, "deletions": 1, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/3e7514670db841a7f0d7656f3b13b1c8b2c11599/library%2Fstd%2Fsrc%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e7514670db841a7f0d7656f3b13b1c8b2c11599/library%2Fstd%2Fsrc%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Ff32.rs?ref=3e7514670db841a7f0d7656f3b13b1c8b2c11599", "patch": "@@ -28,7 +28,7 @@ pub use core::f32::{\n };\n \n #[cfg(not(test))]\n-#[lang = \"f32_runtime\"]\n+#[cfg_attr(bootstrap, lang = \"f32_runtime\")]\n impl f32 {\n     /// Returns the largest integer less than or equal to a number.\n     ///\n@@ -43,6 +43,7 @@ impl f32 {\n     /// assert_eq!(g.floor(), 3.0);\n     /// assert_eq!(h.floor(), -4.0);\n     /// ```\n+    #[cfg_attr(not(bootstrap), rustc_allow_incoherent_impl)]\n     #[must_use = \"method returns a new number and does not mutate the original value\"]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n@@ -61,6 +62,7 @@ impl f32 {\n     /// assert_eq!(f.ceil(), 4.0);\n     /// assert_eq!(g.ceil(), 4.0);\n     /// ```\n+    #[cfg_attr(not(bootstrap), rustc_allow_incoherent_impl)]\n     #[must_use = \"method returns a new number and does not mutate the original value\"]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n@@ -80,6 +82,7 @@ impl f32 {\n     /// assert_eq!(f.round(), 3.0);\n     /// assert_eq!(g.round(), -3.0);\n     /// ```\n+    #[cfg_attr(not(bootstrap), rustc_allow_incoherent_impl)]\n     #[must_use = \"method returns a new number and does not mutate the original value\"]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n@@ -100,6 +103,7 @@ impl f32 {\n     /// assert_eq!(g.trunc(), 3.0);\n     /// assert_eq!(h.trunc(), -3.0);\n     /// ```\n+    #[cfg_attr(not(bootstrap), rustc_allow_incoherent_impl)]\n     #[must_use = \"method returns a new number and does not mutate the original value\"]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n@@ -120,6 +124,7 @@ impl f32 {\n     /// assert!(abs_difference_x <= f32::EPSILON);\n     /// assert!(abs_difference_y <= f32::EPSILON);\n     /// ```\n+    #[cfg_attr(not(bootstrap), rustc_allow_incoherent_impl)]\n     #[must_use = \"method returns a new number and does not mutate the original value\"]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n@@ -144,6 +149,7 @@ impl f32 {\n     ///\n     /// assert!(f32::NAN.abs().is_nan());\n     /// ```\n+    #[cfg_attr(not(bootstrap), rustc_allow_incoherent_impl)]\n     #[must_use = \"method returns a new number and does not mutate the original value\"]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n@@ -167,6 +173,7 @@ impl f32 {\n     ///\n     /// assert!(f32::NAN.signum().is_nan());\n     /// ```\n+    #[cfg_attr(not(bootstrap), rustc_allow_incoherent_impl)]\n     #[must_use = \"method returns a new number and does not mutate the original value\"]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n@@ -193,6 +200,7 @@ impl f32 {\n     ///\n     /// assert!(f32::NAN.copysign(1.0).is_nan());\n     /// ```\n+    #[cfg_attr(not(bootstrap), rustc_allow_incoherent_impl)]\n     #[must_use = \"method returns a new number and does not mutate the original value\"]\n     #[inline]\n     #[stable(feature = \"copysign\", since = \"1.35.0\")]\n@@ -220,6 +228,7 @@ impl f32 {\n     ///\n     /// assert!(abs_difference <= f32::EPSILON);\n     /// ```\n+    #[cfg_attr(not(bootstrap), rustc_allow_incoherent_impl)]\n     #[must_use = \"method returns a new number and does not mutate the original value\"]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n@@ -244,6 +253,7 @@ impl f32 {\n     /// assert_eq!(a.div_euclid(-b), -1.0); // 7.0 >= -4.0 * -1.0\n     /// assert_eq!((-a).div_euclid(-b), 2.0); // -7.0 >= -4.0 * 2.0\n     /// ```\n+    #[cfg_attr(not(bootstrap), rustc_allow_incoherent_impl)]\n     #[must_use = \"method returns a new number and does not mutate the original value\"]\n     #[inline]\n     #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n@@ -278,6 +288,7 @@ impl f32 {\n     /// // limitation due to round-off error\n     /// assert!((-f32::EPSILON).rem_euclid(3.0) != 0.0);\n     /// ```\n+    #[cfg_attr(not(bootstrap), rustc_allow_incoherent_impl)]\n     #[must_use = \"method returns a new number and does not mutate the original value\"]\n     #[inline]\n     #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n@@ -298,6 +309,7 @@ impl f32 {\n     ///\n     /// assert!(abs_difference <= f32::EPSILON);\n     /// ```\n+    #[cfg_attr(not(bootstrap), rustc_allow_incoherent_impl)]\n     #[must_use = \"method returns a new number and does not mutate the original value\"]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n@@ -315,6 +327,7 @@ impl f32 {\n     ///\n     /// assert!(abs_difference <= f32::EPSILON);\n     /// ```\n+    #[cfg_attr(not(bootstrap), rustc_allow_incoherent_impl)]\n     #[must_use = \"method returns a new number and does not mutate the original value\"]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n@@ -339,6 +352,7 @@ impl f32 {\n     /// assert!(negative.sqrt().is_nan());\n     /// assert!(negative_zero.sqrt() == negative_zero);\n     /// ```\n+    #[cfg_attr(not(bootstrap), rustc_allow_incoherent_impl)]\n     #[must_use = \"method returns a new number and does not mutate the original value\"]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n@@ -360,6 +374,7 @@ impl f32 {\n     ///\n     /// assert!(abs_difference <= f32::EPSILON);\n     /// ```\n+    #[cfg_attr(not(bootstrap), rustc_allow_incoherent_impl)]\n     #[must_use = \"method returns a new number and does not mutate the original value\"]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n@@ -379,6 +394,7 @@ impl f32 {\n     ///\n     /// assert!(abs_difference <= f32::EPSILON);\n     /// ```\n+    #[cfg_attr(not(bootstrap), rustc_allow_incoherent_impl)]\n     #[must_use = \"method returns a new number and does not mutate the original value\"]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n@@ -400,6 +416,7 @@ impl f32 {\n     ///\n     /// assert!(abs_difference <= f32::EPSILON);\n     /// ```\n+    #[cfg_attr(not(bootstrap), rustc_allow_incoherent_impl)]\n     #[must_use = \"method returns a new number and does not mutate the original value\"]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n@@ -423,6 +440,7 @@ impl f32 {\n     ///\n     /// assert!(abs_difference <= f32::EPSILON);\n     /// ```\n+    #[cfg_attr(not(bootstrap), rustc_allow_incoherent_impl)]\n     #[must_use = \"method returns a new number and does not mutate the original value\"]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n@@ -442,6 +460,7 @@ impl f32 {\n     ///\n     /// assert!(abs_difference <= f32::EPSILON);\n     /// ```\n+    #[cfg_attr(not(bootstrap), rustc_allow_incoherent_impl)]\n     #[must_use = \"method returns a new number and does not mutate the original value\"]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n@@ -464,6 +483,7 @@ impl f32 {\n     ///\n     /// assert!(abs_difference <= f32::EPSILON);\n     /// ```\n+    #[cfg_attr(not(bootstrap), rustc_allow_incoherent_impl)]\n     #[must_use = \"method returns a new number and does not mutate the original value\"]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n@@ -488,6 +508,7 @@ impl f32 {\n     /// assert!(abs_difference_x <= f32::EPSILON);\n     /// assert!(abs_difference_y <= f32::EPSILON);\n     /// ```\n+    #[cfg_attr(not(bootstrap), rustc_allow_incoherent_impl)]\n     #[must_use = \"method returns a new number and does not mutate the original value\"]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n@@ -517,6 +538,7 @@ impl f32 {\n     ///\n     /// assert!(abs_difference <= f32::EPSILON);\n     /// ```\n+    #[cfg_attr(not(bootstrap), rustc_allow_incoherent_impl)]\n     #[must_use = \"method returns a new number and does not mutate the original value\"]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n@@ -538,6 +560,7 @@ impl f32 {\n     ///\n     /// assert!(abs_difference <= f32::EPSILON);\n     /// ```\n+    #[cfg_attr(not(bootstrap), rustc_allow_incoherent_impl)]\n     #[must_use = \"method returns a new number and does not mutate the original value\"]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n@@ -556,6 +579,7 @@ impl f32 {\n     ///\n     /// assert!(abs_difference <= f32::EPSILON);\n     /// ```\n+    #[cfg_attr(not(bootstrap), rustc_allow_incoherent_impl)]\n     #[must_use = \"method returns a new number and does not mutate the original value\"]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n@@ -574,6 +598,7 @@ impl f32 {\n     ///\n     /// assert!(abs_difference <= f32::EPSILON);\n     /// ```\n+    #[cfg_attr(not(bootstrap), rustc_allow_incoherent_impl)]\n     #[must_use = \"method returns a new number and does not mutate the original value\"]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n@@ -591,6 +616,7 @@ impl f32 {\n     ///\n     /// assert!(abs_difference <= f32::EPSILON);\n     /// ```\n+    #[cfg_attr(not(bootstrap), rustc_allow_incoherent_impl)]\n     #[must_use = \"method returns a new number and does not mutate the original value\"]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n@@ -612,6 +638,7 @@ impl f32 {\n     ///\n     /// assert!(abs_difference <= f32::EPSILON);\n     /// ```\n+    #[cfg_attr(not(bootstrap), rustc_allow_incoherent_impl)]\n     #[must_use = \"method returns a new number and does not mutate the original value\"]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n@@ -633,6 +660,7 @@ impl f32 {\n     ///\n     /// assert!(abs_difference <= f32::EPSILON);\n     /// ```\n+    #[cfg_attr(not(bootstrap), rustc_allow_incoherent_impl)]\n     #[must_use = \"method returns a new number and does not mutate the original value\"]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n@@ -653,6 +681,7 @@ impl f32 {\n     ///\n     /// assert!(abs_difference <= f32::EPSILON);\n     /// ```\n+    #[cfg_attr(not(bootstrap), rustc_allow_incoherent_impl)]\n     #[must_use = \"method returns a new number and does not mutate the original value\"]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n@@ -686,6 +715,7 @@ impl f32 {\n     /// assert!(abs_difference_1 <= f32::EPSILON);\n     /// assert!(abs_difference_2 <= f32::EPSILON);\n     /// ```\n+    #[cfg_attr(not(bootstrap), rustc_allow_incoherent_impl)]\n     #[must_use = \"method returns a new number and does not mutate the original value\"]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n@@ -708,6 +738,7 @@ impl f32 {\n     /// assert!(abs_difference_0 <= f32::EPSILON);\n     /// assert!(abs_difference_1 <= f32::EPSILON);\n     /// ```\n+    #[cfg_attr(not(bootstrap), rustc_allow_incoherent_impl)]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn sin_cos(self) -> (f32, f32) {\n@@ -728,6 +759,7 @@ impl f32 {\n     ///\n     /// assert!(abs_difference < 1e-10);\n     /// ```\n+    #[cfg_attr(not(bootstrap), rustc_allow_incoherent_impl)]\n     #[must_use = \"method returns a new number and does not mutate the original value\"]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n@@ -749,6 +781,7 @@ impl f32 {\n     ///\n     /// assert!(abs_difference < 1e-10);\n     /// ```\n+    #[cfg_attr(not(bootstrap), rustc_allow_incoherent_impl)]\n     #[must_use = \"method returns a new number and does not mutate the original value\"]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n@@ -771,6 +804,7 @@ impl f32 {\n     ///\n     /// assert!(abs_difference <= f32::EPSILON);\n     /// ```\n+    #[cfg_attr(not(bootstrap), rustc_allow_incoherent_impl)]\n     #[must_use = \"method returns a new number and does not mutate the original value\"]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n@@ -793,6 +827,7 @@ impl f32 {\n     /// // Same result\n     /// assert!(abs_difference <= f32::EPSILON);\n     /// ```\n+    #[cfg_attr(not(bootstrap), rustc_allow_incoherent_impl)]\n     #[must_use = \"method returns a new number and does not mutate the original value\"]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n@@ -815,6 +850,7 @@ impl f32 {\n     ///\n     /// assert!(abs_difference <= f32::EPSILON);\n     /// ```\n+    #[cfg_attr(not(bootstrap), rustc_allow_incoherent_impl)]\n     #[must_use = \"method returns a new number and does not mutate the original value\"]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n@@ -834,6 +870,7 @@ impl f32 {\n     ///\n     /// assert!(abs_difference <= f32::EPSILON);\n     /// ```\n+    #[cfg_attr(not(bootstrap), rustc_allow_incoherent_impl)]\n     #[must_use = \"method returns a new number and does not mutate the original value\"]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n@@ -853,6 +890,7 @@ impl f32 {\n     ///\n     /// assert!(abs_difference <= f32::EPSILON);\n     /// ```\n+    #[cfg_attr(not(bootstrap), rustc_allow_incoherent_impl)]\n     #[must_use = \"method returns a new number and does not mutate the original value\"]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n@@ -872,6 +910,7 @@ impl f32 {\n     ///\n     /// assert!(abs_difference <= 1e-5);\n     /// ```\n+    #[cfg_attr(not(bootstrap), rustc_allow_incoherent_impl)]\n     #[must_use = \"method returns a new number and does not mutate the original value\"]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]"}, {"sha": "b90d068ec10d3ddeb7617bddd5d8036418edfcc8", "filename": "library/std/src/f64.rs", "status": "modified", "additions": 41, "deletions": 1, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/3e7514670db841a7f0d7656f3b13b1c8b2c11599/library%2Fstd%2Fsrc%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e7514670db841a7f0d7656f3b13b1c8b2c11599/library%2Fstd%2Fsrc%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Ff64.rs?ref=3e7514670db841a7f0d7656f3b13b1c8b2c11599", "patch": "@@ -28,7 +28,7 @@ pub use core::f64::{\n };\n \n #[cfg(not(test))]\n-#[lang = \"f64_runtime\"]\n+#[cfg_attr(bootstrap, lang = \"f64_runtime\")]\n impl f64 {\n     /// Returns the largest integer less than or equal to a number.\n     ///\n@@ -43,6 +43,7 @@ impl f64 {\n     /// assert_eq!(g.floor(), 3.0);\n     /// assert_eq!(h.floor(), -4.0);\n     /// ```\n+    #[cfg_attr(not(bootstrap), rustc_allow_incoherent_impl)]\n     #[must_use = \"method returns a new number and does not mutate the original value\"]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n@@ -61,6 +62,7 @@ impl f64 {\n     /// assert_eq!(f.ceil(), 4.0);\n     /// assert_eq!(g.ceil(), 4.0);\n     /// ```\n+    #[cfg_attr(not(bootstrap), rustc_allow_incoherent_impl)]\n     #[must_use = \"method returns a new number and does not mutate the original value\"]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n@@ -80,6 +82,7 @@ impl f64 {\n     /// assert_eq!(f.round(), 3.0);\n     /// assert_eq!(g.round(), -3.0);\n     /// ```\n+    #[cfg_attr(not(bootstrap), rustc_allow_incoherent_impl)]\n     #[must_use = \"method returns a new number and does not mutate the original value\"]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n@@ -100,6 +103,7 @@ impl f64 {\n     /// assert_eq!(g.trunc(), 3.0);\n     /// assert_eq!(h.trunc(), -3.0);\n     /// ```\n+    #[cfg_attr(not(bootstrap), rustc_allow_incoherent_impl)]\n     #[must_use = \"method returns a new number and does not mutate the original value\"]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n@@ -120,6 +124,7 @@ impl f64 {\n     /// assert!(abs_difference_x < 1e-10);\n     /// assert!(abs_difference_y < 1e-10);\n     /// ```\n+    #[cfg_attr(not(bootstrap), rustc_allow_incoherent_impl)]\n     #[must_use = \"method returns a new number and does not mutate the original value\"]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n@@ -144,6 +149,7 @@ impl f64 {\n     ///\n     /// assert!(f64::NAN.abs().is_nan());\n     /// ```\n+    #[cfg_attr(not(bootstrap), rustc_allow_incoherent_impl)]\n     #[must_use = \"method returns a new number and does not mutate the original value\"]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n@@ -167,6 +173,7 @@ impl f64 {\n     ///\n     /// assert!(f64::NAN.signum().is_nan());\n     /// ```\n+    #[cfg_attr(not(bootstrap), rustc_allow_incoherent_impl)]\n     #[must_use = \"method returns a new number and does not mutate the original value\"]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n@@ -193,6 +200,7 @@ impl f64 {\n     ///\n     /// assert!(f64::NAN.copysign(1.0).is_nan());\n     /// ```\n+    #[cfg_attr(not(bootstrap), rustc_allow_incoherent_impl)]\n     #[must_use = \"method returns a new number and does not mutate the original value\"]\n     #[stable(feature = \"copysign\", since = \"1.35.0\")]\n     #[inline]\n@@ -220,6 +228,7 @@ impl f64 {\n     ///\n     /// assert!(abs_difference < 1e-10);\n     /// ```\n+    #[cfg_attr(not(bootstrap), rustc_allow_incoherent_impl)]\n     #[must_use = \"method returns a new number and does not mutate the original value\"]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n@@ -244,6 +253,7 @@ impl f64 {\n     /// assert_eq!(a.div_euclid(-b), -1.0); // 7.0 >= -4.0 * -1.0\n     /// assert_eq!((-a).div_euclid(-b), 2.0); // -7.0 >= -4.0 * 2.0\n     /// ```\n+    #[cfg_attr(not(bootstrap), rustc_allow_incoherent_impl)]\n     #[must_use = \"method returns a new number and does not mutate the original value\"]\n     #[inline]\n     #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n@@ -278,6 +288,7 @@ impl f64 {\n     /// // limitation due to round-off error\n     /// assert!((-f64::EPSILON).rem_euclid(3.0) != 0.0);\n     /// ```\n+    #[cfg_attr(not(bootstrap), rustc_allow_incoherent_impl)]\n     #[must_use = \"method returns a new number and does not mutate the original value\"]\n     #[inline]\n     #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n@@ -298,6 +309,7 @@ impl f64 {\n     ///\n     /// assert!(abs_difference < 1e-10);\n     /// ```\n+    #[cfg_attr(not(bootstrap), rustc_allow_incoherent_impl)]\n     #[must_use = \"method returns a new number and does not mutate the original value\"]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n@@ -315,6 +327,7 @@ impl f64 {\n     ///\n     /// assert!(abs_difference < 1e-10);\n     /// ```\n+    #[cfg_attr(not(bootstrap), rustc_allow_incoherent_impl)]\n     #[must_use = \"method returns a new number and does not mutate the original value\"]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n@@ -339,6 +352,7 @@ impl f64 {\n     /// assert!(negative.sqrt().is_nan());\n     /// assert!(negative_zero.sqrt() == negative_zero);\n     /// ```\n+    #[cfg_attr(not(bootstrap), rustc_allow_incoherent_impl)]\n     #[must_use = \"method returns a new number and does not mutate the original value\"]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n@@ -360,6 +374,7 @@ impl f64 {\n     ///\n     /// assert!(abs_difference < 1e-10);\n     /// ```\n+    #[cfg_attr(not(bootstrap), rustc_allow_incoherent_impl)]\n     #[must_use = \"method returns a new number and does not mutate the original value\"]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n@@ -379,6 +394,7 @@ impl f64 {\n     ///\n     /// assert!(abs_difference < 1e-10);\n     /// ```\n+    #[cfg_attr(not(bootstrap), rustc_allow_incoherent_impl)]\n     #[must_use = \"method returns a new number and does not mutate the original value\"]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n@@ -400,6 +416,7 @@ impl f64 {\n     ///\n     /// assert!(abs_difference < 1e-10);\n     /// ```\n+    #[cfg_attr(not(bootstrap), rustc_allow_incoherent_impl)]\n     #[must_use = \"method returns a new number and does not mutate the original value\"]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n@@ -423,6 +440,7 @@ impl f64 {\n     ///\n     /// assert!(abs_difference < 1e-10);\n     /// ```\n+    #[cfg_attr(not(bootstrap), rustc_allow_incoherent_impl)]\n     #[must_use = \"method returns a new number and does not mutate the original value\"]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n@@ -442,6 +460,7 @@ impl f64 {\n     ///\n     /// assert!(abs_difference < 1e-10);\n     /// ```\n+    #[cfg_attr(not(bootstrap), rustc_allow_incoherent_impl)]\n     #[must_use = \"method returns a new number and does not mutate the original value\"]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n@@ -466,6 +485,7 @@ impl f64 {\n     ///\n     /// assert!(abs_difference < 1e-10);\n     /// ```\n+    #[cfg_attr(not(bootstrap), rustc_allow_incoherent_impl)]\n     #[must_use = \"method returns a new number and does not mutate the original value\"]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n@@ -490,6 +510,7 @@ impl f64 {\n     /// assert!(abs_difference_x < 1e-10);\n     /// assert!(abs_difference_y < 1e-10);\n     /// ```\n+    #[cfg_attr(not(bootstrap), rustc_allow_incoherent_impl)]\n     #[must_use = \"method returns a new number and does not mutate the original value\"]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n@@ -519,6 +540,7 @@ impl f64 {\n     ///\n     /// assert!(abs_difference < 1e-10);\n     /// ```\n+    #[cfg_attr(not(bootstrap), rustc_allow_incoherent_impl)]\n     #[must_use = \"method returns a new number and does not mutate the original value\"]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n@@ -540,6 +562,7 @@ impl f64 {\n     ///\n     /// assert!(abs_difference < 1e-10);\n     /// ```\n+    #[cfg_attr(not(bootstrap), rustc_allow_incoherent_impl)]\n     #[must_use = \"method returns a new number and does not mutate the original value\"]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n@@ -558,6 +581,7 @@ impl f64 {\n     ///\n     /// assert!(abs_difference < 1e-10);\n     /// ```\n+    #[cfg_attr(not(bootstrap), rustc_allow_incoherent_impl)]\n     #[must_use = \"method returns a new number and does not mutate the original value\"]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n@@ -576,6 +600,7 @@ impl f64 {\n     ///\n     /// assert!(abs_difference < 1e-10);\n     /// ```\n+    #[cfg_attr(not(bootstrap), rustc_allow_incoherent_impl)]\n     #[must_use = \"method returns a new number and does not mutate the original value\"]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n@@ -593,6 +618,7 @@ impl f64 {\n     ///\n     /// assert!(abs_difference < 1e-14);\n     /// ```\n+    #[cfg_attr(not(bootstrap), rustc_allow_incoherent_impl)]\n     #[must_use = \"method returns a new number and does not mutate the original value\"]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n@@ -614,6 +640,7 @@ impl f64 {\n     ///\n     /// assert!(abs_difference < 1e-10);\n     /// ```\n+    #[cfg_attr(not(bootstrap), rustc_allow_incoherent_impl)]\n     #[must_use = \"method returns a new number and does not mutate the original value\"]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n@@ -635,6 +662,7 @@ impl f64 {\n     ///\n     /// assert!(abs_difference < 1e-10);\n     /// ```\n+    #[cfg_attr(not(bootstrap), rustc_allow_incoherent_impl)]\n     #[must_use = \"method returns a new number and does not mutate the original value\"]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n@@ -655,6 +683,7 @@ impl f64 {\n     ///\n     /// assert!(abs_difference < 1e-10);\n     /// ```\n+    #[cfg_attr(not(bootstrap), rustc_allow_incoherent_impl)]\n     #[must_use = \"method returns a new number and does not mutate the original value\"]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n@@ -688,6 +717,7 @@ impl f64 {\n     /// assert!(abs_difference_1 < 1e-10);\n     /// assert!(abs_difference_2 < 1e-10);\n     /// ```\n+    #[cfg_attr(not(bootstrap), rustc_allow_incoherent_impl)]\n     #[must_use = \"method returns a new number and does not mutate the original value\"]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n@@ -710,6 +740,7 @@ impl f64 {\n     /// assert!(abs_difference_0 < 1e-10);\n     /// assert!(abs_difference_1 < 1e-10);\n     /// ```\n+    #[cfg_attr(not(bootstrap), rustc_allow_incoherent_impl)]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn sin_cos(self) -> (f64, f64) {\n@@ -730,6 +761,7 @@ impl f64 {\n     ///\n     /// assert!(abs_difference < 1e-20);\n     /// ```\n+    #[cfg_attr(not(bootstrap), rustc_allow_incoherent_impl)]\n     #[must_use = \"method returns a new number and does not mutate the original value\"]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n@@ -751,6 +783,7 @@ impl f64 {\n     ///\n     /// assert!(abs_difference < 1e-20);\n     /// ```\n+    #[cfg_attr(not(bootstrap), rustc_allow_incoherent_impl)]\n     #[must_use = \"method returns a new number and does not mutate the original value\"]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n@@ -773,6 +806,7 @@ impl f64 {\n     ///\n     /// assert!(abs_difference < 1e-10);\n     /// ```\n+    #[cfg_attr(not(bootstrap), rustc_allow_incoherent_impl)]\n     #[must_use = \"method returns a new number and does not mutate the original value\"]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n@@ -795,6 +829,7 @@ impl f64 {\n     /// // Same result\n     /// assert!(abs_difference < 1.0e-10);\n     /// ```\n+    #[cfg_attr(not(bootstrap), rustc_allow_incoherent_impl)]\n     #[must_use = \"method returns a new number and does not mutate the original value\"]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n@@ -817,6 +852,7 @@ impl f64 {\n     ///\n     /// assert!(abs_difference < 1.0e-10);\n     /// ```\n+    #[cfg_attr(not(bootstrap), rustc_allow_incoherent_impl)]\n     #[must_use = \"method returns a new number and does not mutate the original value\"]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n@@ -836,6 +872,7 @@ impl f64 {\n     ///\n     /// assert!(abs_difference < 1.0e-10);\n     /// ```\n+    #[cfg_attr(not(bootstrap), rustc_allow_incoherent_impl)]\n     #[must_use = \"method returns a new number and does not mutate the original value\"]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n@@ -855,6 +892,7 @@ impl f64 {\n     ///\n     /// assert!(abs_difference < 1.0e-10);\n     /// ```\n+    #[cfg_attr(not(bootstrap), rustc_allow_incoherent_impl)]\n     #[must_use = \"method returns a new number and does not mutate the original value\"]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n@@ -874,6 +912,7 @@ impl f64 {\n     ///\n     /// assert!(abs_difference < 1.0e-10);\n     /// ```\n+    #[cfg_attr(not(bootstrap), rustc_allow_incoherent_impl)]\n     #[must_use = \"method returns a new number and does not mutate the original value\"]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n@@ -884,6 +923,7 @@ impl f64 {\n     // Solaris/Illumos requires a wrapper around log, log2, and log10 functions\n     // because of their non-standard behavior (e.g., log(-n) returns -Inf instead\n     // of expected NaN).\n+    #[cfg_attr(not(bootstrap), rustc_allow_incoherent_impl)]\n     fn log_wrapper<F: Fn(f64) -> f64>(self, log_fn: F) -> f64 {\n         if !cfg!(any(target_os = \"solaris\", target_os = \"illumos\")) {\n             log_fn(self)"}, {"sha": "3e60ed2f7c4e5099409fb52c251c4ad51a950ee4", "filename": "src/librustdoc/clean/types.rs", "status": "modified", "additions": 57, "deletions": 54, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/3e7514670db841a7f0d7656f3b13b1c8b2c11599/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e7514670db841a7f0d7656f3b13b1c8b2c11599/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Ftypes.rs?ref=3e7514670db841a7f0d7656f3b13b1c8b2c11599", "patch": "@@ -1,6 +1,7 @@\n use std::cell::RefCell;\n use std::default::Default;\n use std::hash::Hash;\n+use std::iter;\n use std::lazy::SyncOnceCell as OnceCell;\n use std::path::PathBuf;\n use std::rc::Rc;\n@@ -22,6 +23,7 @@ use rustc_hir::def_id::{CrateNum, DefId, DefIndex, CRATE_DEF_INDEX, LOCAL_CRATE}\n use rustc_hir::lang_items::LangItem;\n use rustc_hir::{BodyId, Mutability};\n use rustc_index::vec::IndexVec;\n+use rustc_middle::ty::fast_reject::SimplifiedType;\n use rustc_middle::ty::{self, TyCtxt};\n use rustc_session::Session;\n use rustc_span::hygiene::MacroKind;\n@@ -1625,6 +1627,7 @@ crate enum PrimitiveType {\n     Never,\n }\n \n+type SimplifiedTypes = FxHashMap<PrimitiveType, ArrayVec<SimplifiedType, 2>>;\n impl PrimitiveType {\n     crate fn from_hir(prim: hir::PrimTy) -> PrimitiveType {\n         use ast::{FloatTy, IntTy, UintTy};\n@@ -1680,68 +1683,68 @@ impl PrimitiveType {\n         }\n     }\n \n-    crate fn impls(&self, tcx: TyCtxt<'_>) -> &'static ArrayVec<DefId, 4> {\n-        Self::all_impls(tcx).get(self).expect(\"missing impl for primitive type\")\n-    }\n-\n-    crate fn all_impls(tcx: TyCtxt<'_>) -> &'static FxHashMap<PrimitiveType, ArrayVec<DefId, 4>> {\n-        static CELL: OnceCell<FxHashMap<PrimitiveType, ArrayVec<DefId, 4>>> = OnceCell::new();\n+    crate fn simplified_types() -> &'static SimplifiedTypes {\n+        use ty::fast_reject::SimplifiedTypeGen::*;\n+        use ty::{FloatTy, IntTy, UintTy};\n+        use PrimitiveType::*;\n+        static CELL: OnceCell<SimplifiedTypes> = OnceCell::new();\n \n+        let single = |x| iter::once(x).collect();\n         CELL.get_or_init(move || {\n-            use self::PrimitiveType::*;\n-\n-            let single = |a: Option<DefId>| a.into_iter().collect();\n-            let both = |a: Option<DefId>, b: Option<DefId>| -> ArrayVec<_, 4> {\n-                a.into_iter().chain(b).collect()\n-            };\n-\n-            let lang_items = tcx.lang_items();\n             map! {\n-                Isize => single(lang_items.isize_impl()),\n-                I8 => single(lang_items.i8_impl()),\n-                I16 => single(lang_items.i16_impl()),\n-                I32 => single(lang_items.i32_impl()),\n-                I64 => single(lang_items.i64_impl()),\n-                I128 => single(lang_items.i128_impl()),\n-                Usize => single(lang_items.usize_impl()),\n-                U8 => single(lang_items.u8_impl()),\n-                U16 => single(lang_items.u16_impl()),\n-                U32 => single(lang_items.u32_impl()),\n-                U64 => single(lang_items.u64_impl()),\n-                U128 => single(lang_items.u128_impl()),\n-                F32 => both(lang_items.f32_impl(), lang_items.f32_runtime_impl()),\n-                F64 => both(lang_items.f64_impl(), lang_items.f64_runtime_impl()),\n-                Char => single(lang_items.char_impl()),\n-                Bool => single(lang_items.bool_impl()),\n-                Str => both(lang_items.str_impl(), lang_items.str_alloc_impl()),\n-                Slice => {\n-                    lang_items\n-                        .slice_impl()\n-                        .into_iter()\n-                        .chain(lang_items.slice_u8_impl())\n-                        .chain(lang_items.slice_alloc_impl())\n-                        .chain(lang_items.slice_u8_alloc_impl())\n-                        .collect()\n-                },\n-                Array => single(lang_items.array_impl()),\n-                Tuple => ArrayVec::new(),\n-                Unit => ArrayVec::new(),\n-                RawPointer => {\n-                    lang_items\n-                        .const_ptr_impl()\n-                        .into_iter()\n-                        .chain(lang_items.mut_ptr_impl())\n-                        .chain(lang_items.const_slice_ptr_impl())\n-                        .chain(lang_items.mut_slice_ptr_impl())\n-                        .collect()\n-                },\n-                Reference => ArrayVec::new(),\n+                Isize => single(IntSimplifiedType(IntTy::Isize)),\n+                I8 => single(IntSimplifiedType(IntTy::I8)),\n+                I16 => single(IntSimplifiedType(IntTy::I16)),\n+                I32 => single(IntSimplifiedType(IntTy::I32)),\n+                I64 => single(IntSimplifiedType(IntTy::I64)),\n+                I128 => single(IntSimplifiedType(IntTy::I128)),\n+                Usize => single(UintSimplifiedType(UintTy::Usize)),\n+                U8 => single(UintSimplifiedType(UintTy::U8)),\n+                U16 => single(UintSimplifiedType(UintTy::U16)),\n+                U32 => single(UintSimplifiedType(UintTy::U32)),\n+                U64 => single(UintSimplifiedType(UintTy::U64)),\n+                U128 => single(UintSimplifiedType(UintTy::U128)),\n+                F32 => single(FloatSimplifiedType(FloatTy::F32)),\n+                F64 => single(FloatSimplifiedType(FloatTy::F64)),\n+                Str => single(StrSimplifiedType),\n+                Bool => single(BoolSimplifiedType),\n+                Char => single(CharSimplifiedType),\n+                Array => single(ArraySimplifiedType),\n+                Slice => single(SliceSimplifiedType),\n+                // FIXME: If we ever add an inherent impl for tuples\n+                // with different lengths, they won't show in rustdoc.\n+                //\n+                // Either manually update this arrayvec at this point\n+                // or start with a more complex refactoring.\n+                Tuple => [TupleSimplifiedType(2), TupleSimplifiedType(3)].into(),\n+                Unit => single(TupleSimplifiedType(0)),\n+                RawPointer => [PtrSimplifiedType(Mutability::Not), PtrSimplifiedType(Mutability::Mut)].into(),\n+                Reference => [RefSimplifiedType(Mutability::Not), RefSimplifiedType(Mutability::Mut)].into(),\n+                // FIXME: This will be wrong if we ever add inherent impls\n+                // for function pointers.\n                 Fn => ArrayVec::new(),\n-                Never => ArrayVec::new(),\n+                Never => single(NeverSimplifiedType),\n             }\n         })\n     }\n \n+    crate fn impls<'tcx>(&self, tcx: TyCtxt<'tcx>) -> impl Iterator<Item = DefId> + 'tcx {\n+        Self::simplified_types()\n+            .get(self)\n+            .into_iter()\n+            .flatten()\n+            .flat_map(move |&simp| tcx.incoherent_impls(simp))\n+            .copied()\n+    }\n+\n+    crate fn all_impls(tcx: TyCtxt<'_>) -> impl Iterator<Item = DefId> + '_ {\n+        Self::simplified_types()\n+            .values()\n+            .flatten()\n+            .flat_map(move |&simp| tcx.incoherent_impls(simp))\n+            .copied()\n+    }\n+\n     crate fn as_sym(&self) -> Symbol {\n         use PrimitiveType::*;\n         match self {"}, {"sha": "00f512ded0e79b535da3a6df0b3372237eac3339", "filename": "src/librustdoc/clean/utils.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3e7514670db841a7f0d7656f3b13b1c8b2c11599/src%2Flibrustdoc%2Fclean%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e7514670db841a7f0d7656f3b13b1c8b2c11599/src%2Flibrustdoc%2Fclean%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Futils.rs?ref=3e7514670db841a7f0d7656f3b13b1c8b2c11599", "patch": "@@ -184,7 +184,7 @@ crate fn build_deref_target_impls(cx: &mut DocContext<'_>, items: &[Item], ret:\n \n         if let Some(prim) = target.primitive_type() {\n             let _prof_timer = cx.tcx.sess.prof.generic_activity(\"build_primitive_inherent_impls\");\n-            for &did in prim.impls(tcx).iter().filter(|did| !did.is_local()) {\n+            for did in prim.impls(tcx).filter(|did| !did.is_local()) {\n                 inline::build_impl(cx, None, did, None, ret);\n             }\n         } else if let Type::Path { path } = target {"}, {"sha": "8d66021fcaa90b7169aafd4ecdafbc5ca2d6bb2a", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3e7514670db841a7f0d7656f3b13b1c8b2c11599/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e7514670db841a7f0d7656f3b13b1c8b2c11599/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=3e7514670db841a7f0d7656f3b13b1c8b2c11599", "patch": "@@ -467,7 +467,7 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n     ) -> Option<(Res, ItemFragment)> {\n         let tcx = self.cx.tcx;\n \n-        prim_ty.impls(tcx).into_iter().find_map(|&impl_| {\n+        prim_ty.impls(tcx).find_map(|impl_| {\n             tcx.associated_items(impl_)\n                 .find_by_name_and_namespace(tcx, Ident::with_dummy_span(item_name), ns, impl_)\n                 .map(|item| {"}, {"sha": "75e952c5122b8069a72550162dc6a447b2bb4abd", "filename": "src/librustdoc/passes/collect_intra_doc_links/early.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3e7514670db841a7f0d7656f3b13b1c8b2c11599/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links%2Fearly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e7514670db841a7f0d7656f3b13b1c8b2c11599/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links%2Fearly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links%2Fearly.rs?ref=3e7514670db841a7f0d7656f3b13b1c8b2c11599", "patch": "@@ -113,7 +113,8 @@ impl IntraLinkCrateLoader<'_, '_> {\n                 Vec::from_iter(self.resolver.cstore().trait_impls_in_crate_untracked(cnum));\n             let all_inherent_impls =\n                 Vec::from_iter(self.resolver.cstore().inherent_impls_in_crate_untracked(cnum));\n-            let all_lang_items = Vec::from_iter(self.resolver.cstore().lang_items_untracked(cnum));\n+            let all_incoherent_impls =\n+                Vec::from_iter(self.resolver.cstore().incoherent_impls_in_crate_untracked(cnum));\n \n             // Querying traits in scope is expensive so we try to prune the impl and traits lists\n             // using privacy, private traits and impls from other crates are never documented in\n@@ -137,7 +138,7 @@ impl IntraLinkCrateLoader<'_, '_> {\n                     self.add_traits_in_parent_scope(impl_def_id);\n                 }\n             }\n-            for def_id in all_lang_items {\n+            for def_id in all_incoherent_impls {\n                 self.add_traits_in_parent_scope(def_id);\n             }\n "}, {"sha": "2852c3b616df1a4afd84d3606d939d23f2cb0911", "filename": "src/librustdoc/passes/collect_trait_impls.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3e7514670db841a7f0d7656f3b13b1c8b2c11599/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e7514670db841a7f0d7656f3b13b1c8b2c11599/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs?ref=3e7514670db841a7f0d7656f3b13b1c8b2c11599", "patch": "@@ -45,7 +45,7 @@ crate fn collect_trait_impls(mut krate: Crate, cx: &mut DocContext<'_>) -> Crate\n \n     // Also try to inline primitive impls from other crates.\n     cx.tcx.sess.prof.generic_activity(\"build_primitive_trait_impls\").run(|| {\n-        for &def_id in PrimitiveType::all_impls(cx.tcx).values().flatten() {\n+        for def_id in PrimitiveType::all_impls(cx.tcx) {\n             if !def_id.is_local() {\n                 inline::build_impl(cx, None, def_id, None, &mut new_items);\n "}, {"sha": "d9a08cb41b82d9b1672d2137cc08661f3843819a", "filename": "src/test/rustdoc/intra-doc/auxiliary/extern-builtin-type-impl-dep.rs", "status": "renamed", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3e7514670db841a7f0d7656f3b13b1c8b2c11599/src%2Ftest%2Frustdoc%2Fintra-doc%2Fauxiliary%2Fextern-builtin-type-impl-dep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e7514670db841a7f0d7656f3b13b1c8b2c11599/src%2Ftest%2Frustdoc%2Fintra-doc%2Fauxiliary%2Fextern-builtin-type-impl-dep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fintra-doc%2Fauxiliary%2Fextern-builtin-type-impl-dep.rs?ref=3e7514670db841a7f0d7656f3b13b1c8b2c11599", "patch": "@@ -1,7 +1,6 @@\n // no-prefer-dynamic\n \n-#![feature(lang_items)]\n-\n+#![feature(lang_items, rustc_attrs)]\n #![crate_type = \"rlib\"]\n #![no_std]\n \n@@ -15,9 +14,9 @@ impl core::ops::Deref for DerefsToF64 {\n }\n \n mod inner {\n-    #[lang = \"f64_runtime\"]\n     impl f64 {\n         /// [f64::clone]\n+        #[rustc_allow_incoherent_impl]\n         pub fn method() {}\n     }\n }", "previous_filename": "src/test/rustdoc/intra-doc/auxiliary/extern-lang-item-impl-dep.rs"}, {"sha": "e22feb03ae6ac2731cbcb4a4bc9330b49e2053bd", "filename": "src/test/rustdoc/intra-doc/auxiliary/my-core.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3e7514670db841a7f0d7656f3b13b1c8b2c11599/src%2Ftest%2Frustdoc%2Fintra-doc%2Fauxiliary%2Fmy-core.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e7514670db841a7f0d7656f3b13b1c8b2c11599/src%2Ftest%2Frustdoc%2Fintra-doc%2Fauxiliary%2Fmy-core.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fintra-doc%2Fauxiliary%2Fmy-core.rs?ref=3e7514670db841a7f0d7656f3b13b1c8b2c11599", "patch": "@@ -1,12 +1,12 @@\n-#![feature(no_core, lang_items, rustdoc_internals)]\n+#![feature(no_core, lang_items, rustdoc_internals, rustc_attrs)]\n #![no_core]\n+#![rustc_coherence_is_core]\n #![crate_type=\"rlib\"]\n \n #[doc(primitive = \"char\")]\n /// Some char docs\n mod char {}\n \n-#[lang = \"char\"]\n impl char {\n     pub fn len_utf8(self) -> usize {\n         42"}, {"sha": "7bb1ded3f3c2e152b44d52887533dc06a7e48306", "filename": "src/test/rustdoc/intra-doc/extern-builtin-type-impl.rs", "status": "renamed", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3e7514670db841a7f0d7656f3b13b1c8b2c11599/src%2Ftest%2Frustdoc%2Fintra-doc%2Fextern-builtin-type-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e7514670db841a7f0d7656f3b13b1c8b2c11599/src%2Ftest%2Frustdoc%2Fintra-doc%2Fextern-builtin-type-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fintra-doc%2Fextern-builtin-type-impl.rs?ref=3e7514670db841a7f0d7656f3b13b1c8b2c11599", "patch": "@@ -2,10 +2,10 @@\n // comments. The doc link points to an associated item, so we check that traits in scope for that\n // link are populated.\n \n-// aux-build:extern-lang-item-impl-dep.rs\n+// aux-build:extern-builtin-type-impl-dep.rs\n \n #![no_std]\n \n-extern crate extern_lang_item_impl_dep;\n+extern crate extern_builtin_type_impl_dep;\n \n-pub use extern_lang_item_impl_dep::DerefsToF64;\n+pub use extern_builtin_type_impl_dep::DerefsToF64;", "previous_filename": "src/test/rustdoc/intra-doc/extern-lang-item-impl.rs"}, {"sha": "79d8df045158fd5a93aa4f1cf68c30362f264d62", "filename": "src/test/rustdoc/intra-doc/prim-methods-local.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3e7514670db841a7f0d7656f3b13b1c8b2c11599/src%2Ftest%2Frustdoc%2Fintra-doc%2Fprim-methods-local.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e7514670db841a7f0d7656f3b13b1c8b2c11599/src%2Ftest%2Frustdoc%2Fintra-doc%2Fprim-methods-local.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fintra-doc%2Fprim-methods-local.rs?ref=3e7514670db841a7f0d7656f3b13b1c8b2c11599", "patch": "@@ -1,6 +1,7 @@\n #![deny(rustdoc::broken_intra_doc_links)]\n-#![feature(no_core, lang_items, rustdoc_internals)]\n+#![feature(no_core, lang_items, rustc_attrs, rustdoc_internals)]\n #![no_core]\n+#![rustc_coherence_is_core]\n #![crate_type = \"rlib\"]\n \n // @has prim_methods_local/index.html\n@@ -12,7 +13,6 @@\n #[doc(primitive = \"char\")]\n mod char {}\n \n-#[lang = \"char\"]\n impl char {\n     pub fn len_utf8(self) -> usize {\n         42"}, {"sha": "de053d70f0354cfbca8253343f6b181fe95ea991", "filename": "src/test/rustdoc/intra-doc/prim-self.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3e7514670db841a7f0d7656f3b13b1c8b2c11599/src%2Ftest%2Frustdoc%2Fintra-doc%2Fprim-self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e7514670db841a7f0d7656f3b13b1c8b2c11599/src%2Ftest%2Frustdoc%2Fintra-doc%2Fprim-self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fintra-doc%2Fprim-self.rs?ref=3e7514670db841a7f0d7656f3b13b1c8b2c11599", "patch": "@@ -1,12 +1,12 @@\n #![deny(rustdoc::broken_intra_doc_links)]\n+#![rustc_coherence_is_core]\n #![allow(incomplete_features)] // inherent_associated_types\n-#![feature(lang_items)]\n+#![feature(rustc_attrs)]\n #![feature(no_core)]\n #![feature(rustdoc_internals)]\n #![feature(inherent_associated_types)]\n #![no_core]\n \n-#[lang = \"usize\"]\n /// [Self::f]\n /// [Self::MAX]\n // @has prim_self/primitive.usize.html"}, {"sha": "2d2a7908fb187a619c60088af3eb48d7e681d633", "filename": "src/test/rustdoc/issue-23511.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3e7514670db841a7f0d7656f3b13b1c8b2c11599/src%2Ftest%2Frustdoc%2Fissue-23511.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e7514670db841a7f0d7656f3b13b1c8b2c11599/src%2Ftest%2Frustdoc%2Fissue-23511.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fissue-23511.rs?ref=3e7514670db841a7f0d7656f3b13b1c8b2c11599", "patch": "@@ -1,13 +1,13 @@\n-#![feature(lang_items)]\n+#![feature(rustc_attrs)]\n #![feature(rustdoc_internals)]\n #![no_std]\n \n pub mod str {\n     #![doc(primitive = \"str\")]\n \n-    #[lang = \"str_alloc\"]\n     impl str {\n         // @has search-index.js foo\n+        #[rustc_allow_incoherent_impl]\n         pub fn foo(&self) {}\n     }\n }"}, {"sha": "22b48657385c63d3244620ec3ccfd1e505e32373", "filename": "src/test/ui/error-codes/E0117.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3e7514670db841a7f0d7656f3b13b1c8b2c11599/src%2Ftest%2Fui%2Ferror-codes%2FE0117.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e7514670db841a7f0d7656f3b13b1c8b2c11599/src%2Ftest%2Fui%2Ferror-codes%2FE0117.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0117.rs?ref=3e7514670db841a7f0d7656f3b13b1c8b2c11599", "patch": "@@ -1,5 +1,4 @@\n impl Drop for u32 {} //~ ERROR E0117\n //~| ERROR the `Drop` trait may only be implemented for structs, enums, and unions\n \n-fn main() {\n-}\n+fn main() {}"}, {"sha": "fe04190162af430e4c442a42396882e1a84513ea", "filename": "src/test/ui/error-codes/E0118-2.rs", "status": "removed", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e50ff9b4521234e56ff46f8ed0372d5cb5689654/src%2Ftest%2Fui%2Ferror-codes%2FE0118-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e50ff9b4521234e56ff46f8ed0372d5cb5689654/src%2Ftest%2Fui%2Ferror-codes%2FE0118-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0118-2.rs?ref=e50ff9b4521234e56ff46f8ed0372d5cb5689654", "patch": "@@ -1,8 +0,0 @@\n-struct Foo;\n-\n-impl &mut Foo {\n-    //~^ ERROR E0118\n-    fn bar(self) {}\n-}\n-\n-fn main() {}"}, {"sha": "2a1fe23111687b54487edbd572c6a5221b081f17", "filename": "src/test/ui/error-codes/E0118-2.stderr", "status": "removed", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e50ff9b4521234e56ff46f8ed0372d5cb5689654/src%2Ftest%2Fui%2Ferror-codes%2FE0118-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e50ff9b4521234e56ff46f8ed0372d5cb5689654/src%2Ftest%2Fui%2Ferror-codes%2FE0118-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0118-2.stderr?ref=e50ff9b4521234e56ff46f8ed0372d5cb5689654", "patch": "@@ -1,12 +0,0 @@\n-error[E0118]: no nominal type found for inherent implementation\n-  --> $DIR/E0118-2.rs:3:6\n-   |\n-LL | impl &mut Foo {\n-   |      ^^^^^^^^ impl requires a nominal type\n-   |\n-   = note: either implement a trait on it or create a newtype to wrap it instead\n-   = note: you could also try moving the reference to uses of `Foo` (such as `self`) within the implementation\n-\n-error: aborting due to previous error\n-\n-For more information about this error, try `rustc --explain E0118`."}, {"sha": "aaef8113b8ae243bd7ea3a78be5aafe005faf4fa", "filename": "src/test/ui/error-codes/E0118.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3e7514670db841a7f0d7656f3b13b1c8b2c11599/src%2Ftest%2Fui%2Ferror-codes%2FE0118.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e7514670db841a7f0d7656f3b13b1c8b2c11599/src%2Ftest%2Fui%2Ferror-codes%2FE0118.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0118.rs?ref=3e7514670db841a7f0d7656f3b13b1c8b2c11599", "patch": "@@ -1,8 +1,7 @@\n-impl (u8, u8) { //~ ERROR E0118\n+impl fn(u8) { //~ ERROR E0118\n     fn get_state(&self) -> String {\n-        String::new()\n+       String::new()\n     }\n }\n \n-fn main() {\n-}\n+fn main() {}"}, {"sha": "296fb5d664a227308b5341cc8df579997e971328", "filename": "src/test/ui/error-codes/E0118.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3e7514670db841a7f0d7656f3b13b1c8b2c11599/src%2Ftest%2Fui%2Ferror-codes%2FE0118.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3e7514670db841a7f0d7656f3b13b1c8b2c11599/src%2Ftest%2Fui%2Ferror-codes%2FE0118.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0118.stderr?ref=3e7514670db841a7f0d7656f3b13b1c8b2c11599", "patch": "@@ -1,8 +1,8 @@\n error[E0118]: no nominal type found for inherent implementation\n   --> $DIR/E0118.rs:1:6\n    |\n-LL | impl (u8, u8) {\n-   |      ^^^^^^^^ impl requires a nominal type\n+LL | impl fn(u8) {\n+   |      ^^^^^^ impl requires a nominal type\n    |\n    = note: either implement a trait on it or create a newtype to wrap it instead\n "}, {"sha": "a0a301a06e2ed7e8edc4b3e71b03bb52e9a0008f", "filename": "src/test/ui/error-codes/E0120.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3e7514670db841a7f0d7656f3b13b1c8b2c11599/src%2Ftest%2Fui%2Ferror-codes%2FE0120.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e7514670db841a7f0d7656f3b13b1c8b2c11599/src%2Ftest%2Fui%2Ferror-codes%2FE0120.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0120.rs?ref=3e7514670db841a7f0d7656f3b13b1c8b2c11599", "patch": "@@ -5,5 +5,4 @@ impl Drop for dyn MyTrait {\n     fn drop(&mut self) {}\n }\n \n-fn main() {\n-}\n+fn main() {}"}, {"sha": "e635d4ec196a271351a9dd1d8b52c68f2dc4077d", "filename": "src/test/ui/error-codes/E0390.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3e7514670db841a7f0d7656f3b13b1c8b2c11599/src%2Ftest%2Fui%2Ferror-codes%2FE0390.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3e7514670db841a7f0d7656f3b13b1c8b2c11599/src%2Ftest%2Fui%2Ferror-codes%2FE0390.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0390.stderr?ref=3e7514670db841a7f0d7656f3b13b1c8b2c11599", "patch": "@@ -1,10 +1,10 @@\n-error[E0390]: only a single inherent implementation marked with `#[lang = \"mut_ptr\"]` is allowed for the `*mut T` primitive\n-  --> $DIR/E0390.rs:5:1\n+error[E0390]: cannot define inherent `impl` for primitive types\n+  --> $DIR/E0390.rs:5:6\n    |\n LL | impl *mut Foo {}\n-   | ^^^^^^^^^^^^^^^^\n+   |      ^^^^^^^^\n    |\n-   = help: consider using a trait\n+   = help: consider using an extension trait instead\n \n error: aborting due to previous error\n "}, {"sha": "6a067a9a36092694afc016d4de3a98dd8295b93b", "filename": "src/test/ui/kinds-of-primitive-impl.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3e7514670db841a7f0d7656f3b13b1c8b2c11599/src%2Ftest%2Fui%2Fkinds-of-primitive-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e7514670db841a7f0d7656f3b13b1c8b2c11599/src%2Ftest%2Fui%2Fkinds-of-primitive-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fkinds-of-primitive-impl.rs?ref=3e7514670db841a7f0d7656f3b13b1c8b2c11599", "patch": "@@ -1,20 +1,26 @@\n impl u8 {\n-//~^ error: only a single inherent implementation marked with `#[lang = \"u8\"]` is allowed for the `u8` primitive\n+//~^ error: cannot define inherent `impl` for primitive types\n     pub const B: u8 = 0;\n }\n \n impl str {\n-//~^ error: only a single inherent implementation marked with `#[lang = \"str\"]` is allowed for the `str` primitive\n+//~^ error: cannot define inherent `impl` for primitive types\n     fn foo() {}\n     fn bar(self) {}\n }\n \n impl char {\n-//~^ error: only a single inherent implementation marked with `#[lang = \"char\"]` is allowed for the `char` primitive\n+//~^ error: cannot define inherent `impl` for primitive types\n     pub const B: u8 = 0;\n     pub const C: u8 = 0;\n     fn foo() {}\n     fn bar(self) {}\n }\n \n+struct MyType;\n+impl &MyType {\n+//~^ error: cannot define inherent `impl` for primitive types\n+    pub fn for_ref(self) {}\n+}\n+\n fn main() {}"}, {"sha": "f4dbd1c40e81891c66ad3442e484a9c4ed492383", "filename": "src/test/ui/kinds-of-primitive-impl.stderr", "status": "modified", "additions": 27, "deletions": 31, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/3e7514670db841a7f0d7656f3b13b1c8b2c11599/src%2Ftest%2Fui%2Fkinds-of-primitive-impl.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3e7514670db841a7f0d7656f3b13b1c8b2c11599/src%2Ftest%2Fui%2Fkinds-of-primitive-impl.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fkinds-of-primitive-impl.stderr?ref=3e7514670db841a7f0d7656f3b13b1c8b2c11599", "patch": "@@ -1,40 +1,36 @@\n-error[E0390]: only a single inherent implementation marked with `#[lang = \"u8\"]` is allowed for the `u8` primitive\n-  --> $DIR/kinds-of-primitive-impl.rs:1:1\n+error[E0390]: cannot define inherent `impl` for primitive types\n+  --> $DIR/kinds-of-primitive-impl.rs:1:6\n    |\n-LL | / impl u8 {\n-LL | |\n-LL | |     pub const B: u8 = 0;\n-LL | | }\n-   | |_^\n+LL | impl u8 {\n+   |      ^^\n    |\n-   = help: consider using a trait to implement this constant\n+   = help: consider using an extension trait instead\n \n-error[E0390]: only a single inherent implementation marked with `#[lang = \"str\"]` is allowed for the `str` primitive\n-  --> $DIR/kinds-of-primitive-impl.rs:6:1\n+error[E0390]: cannot define inherent `impl` for primitive types\n+  --> $DIR/kinds-of-primitive-impl.rs:6:6\n    |\n-LL | / impl str {\n-LL | |\n-LL | |     fn foo() {}\n-LL | |     fn bar(self) {}\n-LL | | }\n-   | |_^\n+LL | impl str {\n+   |      ^^^\n    |\n-   = help: consider using a trait to implement these methods\n+   = help: consider using an extension trait instead\n \n-error[E0390]: only a single inherent implementation marked with `#[lang = \"char\"]` is allowed for the `char` primitive\n-  --> $DIR/kinds-of-primitive-impl.rs:12:1\n-   |\n-LL | / impl char {\n-LL | |\n-LL | |     pub const B: u8 = 0;\n-LL | |     pub const C: u8 = 0;\n-LL | |     fn foo() {}\n-LL | |     fn bar(self) {}\n-LL | | }\n-   | |_^\n-   |\n-   = help: consider using a trait to implement these associated items\n+error[E0390]: cannot define inherent `impl` for primitive types\n+  --> $DIR/kinds-of-primitive-impl.rs:12:6\n+   |\n+LL | impl char {\n+   |      ^^^^\n+   |\n+   = help: consider using an extension trait instead\n+\n+error[E0390]: cannot define inherent `impl` for primitive types\n+  --> $DIR/kinds-of-primitive-impl.rs:21:6\n+   |\n+LL | impl &MyType {\n+   |      ^^^^^^^\n+   |\n+   = help: consider using an extension trait instead\n+   = note: you could also try moving the reference to uses of `MyType` (such as `self`) within the implementation\n \n-error: aborting due to 3 previous errors\n+error: aborting due to 4 previous errors\n \n For more information about this error, try `rustc --explain E0390`."}, {"sha": "a3287db74e7338382b635ecade8e4133e8d0de4b", "filename": "src/test/ui/lang-items/lang-item-correct-generics.rs", "status": "removed", "additions": 0, "deletions": 28, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/e50ff9b4521234e56ff46f8ed0372d5cb5689654/src%2Ftest%2Fui%2Flang-items%2Flang-item-correct-generics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e50ff9b4521234e56ff46f8ed0372d5cb5689654/src%2Ftest%2Fui%2Flang-items%2Flang-item-correct-generics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flang-items%2Flang-item-correct-generics.rs?ref=e50ff9b4521234e56ff46f8ed0372d5cb5689654", "patch": "@@ -1,28 +0,0 @@\n-// build-pass\n-\n-#![feature(lang_items,no_core)]\n-#![no_core]\n-#![crate_type=\"lib\"]\n-\n-#[lang = \"sized\"]\n-trait MySized {}\n-\n-#[lang = \"copy\"]\n-trait MyCopy {}\n-\n-#[lang = \"drop\"]\n-trait MyDrop<T> {}\n-\n-struct S;\n-\n-impl<T> MyDrop<T> for S {}\n-\n-#[lang = \"i32\"]\n-impl<'a> i32 {\n-    fn foo() {}\n-}\n-\n-fn bar() {\n-    i32::foo();\n-    S;\n-}"}, {"sha": "75c62feec32d0f992df29d5771456170eefa10d5", "filename": "src/test/ui/single-primitive-inherent-impl.rs", "status": "removed", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e50ff9b4521234e56ff46f8ed0372d5cb5689654/src%2Ftest%2Fui%2Fsingle-primitive-inherent-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e50ff9b4521234e56ff46f8ed0372d5cb5689654/src%2Ftest%2Fui%2Fsingle-primitive-inherent-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsingle-primitive-inherent-impl.rs?ref=e50ff9b4521234e56ff46f8ed0372d5cb5689654", "patch": "@@ -1,11 +0,0 @@\n-#![crate_type = \"lib\"]\n-#![feature(lang_items)]\n-#![no_std]\n-\n-// OK\n-#[lang = \"str_alloc\"]\n-impl str {}\n-\n-impl str {\n-//~^ error: only a single inherent implementation marked with `#[lang = \"str\"]` is allowed for the `str` primitive\n-}"}, {"sha": "349a12eac05a0e4376e8dcaae2ac901af1a8141b", "filename": "src/test/ui/single-primitive-inherent-impl.stderr", "status": "removed", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/e50ff9b4521234e56ff46f8ed0372d5cb5689654/src%2Ftest%2Fui%2Fsingle-primitive-inherent-impl.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e50ff9b4521234e56ff46f8ed0372d5cb5689654/src%2Ftest%2Fui%2Fsingle-primitive-inherent-impl.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsingle-primitive-inherent-impl.stderr?ref=e50ff9b4521234e56ff46f8ed0372d5cb5689654", "patch": "@@ -1,13 +0,0 @@\n-error[E0390]: only a single inherent implementation marked with `#[lang = \"str\"]` is allowed for the `str` primitive\n-  --> $DIR/single-primitive-inherent-impl.rs:9:1\n-   |\n-LL | / impl str {\n-LL | |\n-LL | | }\n-   | |_^\n-   |\n-   = help: consider using a trait\n-\n-error: aborting due to previous error\n-\n-For more information about this error, try `rustc --explain E0390`."}, {"sha": "ae4158662d46459c26419250fe5a2cd62cece2cb", "filename": "src/tools/clippy/clippy_lints/src/implicit_saturating_sub.rs", "status": "modified", "additions": 5, "deletions": 13, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/3e7514670db841a7f0d7656f3b13b1c8b2c11599/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fimplicit_saturating_sub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e7514670db841a7f0d7656f3b13b1c8b2c11599/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fimplicit_saturating_sub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fimplicit_saturating_sub.rs?ref=3e7514670db841a7f0d7656f3b13b1c8b2c11599", "patch": "@@ -3,7 +3,7 @@ use clippy_utils::{higher, peel_blocks_with_stmt, SpanlessEq};\n use if_chain::if_chain;\n use rustc_ast::ast::LitKind;\n use rustc_errors::Applicability;\n-use rustc_hir::{lang_items::LangItem, BinOpKind, Expr, ExprKind, QPath};\n+use rustc_hir::{BinOpKind, Expr, ExprKind, QPath};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n \n@@ -82,14 +82,6 @@ impl<'tcx> LateLintPass<'tcx> for ImplicitSaturatingSub {\n \n                 // Get the variable name\n                 let var_name = ares_path.segments[0].ident.name.as_str();\n-                const INT_TYPES: [LangItem; 5] = [\n-                    LangItem::I8,\n-                    LangItem::I16,\n-                    LangItem::I32,\n-                    LangItem::I64,\n-                    LangItem::Isize\n-                ];\n-\n                 match cond_num_val.kind {\n                     ExprKind::Lit(ref cond_lit) => {\n                         // Check if the constant is zero\n@@ -105,8 +97,8 @@ impl<'tcx> LateLintPass<'tcx> for ImplicitSaturatingSub {\n                             if name.ident.as_str() == \"MIN\";\n                             if let Some(const_id) = cx.typeck_results().type_dependent_def_id(cond_num_val.hir_id);\n                             if let Some(impl_id) = cx.tcx.impl_of_method(const_id);\n-                            let mut int_ids = INT_TYPES.iter().filter_map(|&ty| cx.tcx.lang_items().require(ty).ok());\n-                            if int_ids.any(|int_id| int_id == impl_id);\n+                            if let None = cx.tcx.impl_trait_ref(impl_id); // An inherent impl\n+                            if cx.tcx.type_of(impl_id).is_integral();\n                             then {\n                                 print_lint_and_sugg(cx, var_name, expr)\n                             }\n@@ -118,8 +110,8 @@ impl<'tcx> LateLintPass<'tcx> for ImplicitSaturatingSub {\n                             if name.ident.as_str() == \"min_value\";\n                             if let Some(func_id) = cx.typeck_results().type_dependent_def_id(func.hir_id);\n                             if let Some(impl_id) = cx.tcx.impl_of_method(func_id);\n-                            let mut int_ids = INT_TYPES.iter().filter_map(|&ty| cx.tcx.lang_items().require(ty).ok());\n-                            if int_ids.any(|int_id| int_id == impl_id);\n+                            if let None = cx.tcx.impl_trait_ref(impl_id); // An inherent impl\n+                            if cx.tcx.type_of(impl_id).is_integral();\n                             then {\n                                 print_lint_and_sugg(cx, var_name, expr)\n                             }"}, {"sha": "c98cdfbca434e9dd9bfbdcede516e322be519e97", "filename": "src/tools/clippy/clippy_lints/src/methods/implicit_clone.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/3e7514670db841a7f0d7656f3b13b1c8b2c11599/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fimplicit_clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e7514670db841a7f0d7656f3b13b1c8b2c11599/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fimplicit_clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fimplicit_clone.rs?ref=3e7514670db841a7f0d7656f3b13b1c8b2c11599", "patch": "@@ -49,10 +49,11 @@ pub fn is_clone_like(cx: &LateContext<'_>, method_name: &str, method_def_id: hir\n         \"to_owned\" => is_diag_trait_item(cx, method_def_id, sym::ToOwned),\n         \"to_path_buf\" => is_diag_item_method(cx, method_def_id, sym::Path),\n         \"to_vec\" => {\n-            cx.tcx\n-                .impl_of_method(method_def_id)\n-                .map(|impl_did| Some(impl_did) == cx.tcx.lang_items().slice_alloc_impl())\n-                == Some(true)\n+            cx.tcx.impl_of_method(method_def_id)\n+                .filter(|&impl_did| {\n+                    cx.tcx.type_of(impl_did).is_slice() && cx.tcx.impl_trait_ref(impl_did).is_none()\n+                })\n+                .is_some()\n         },\n         _ => false,\n     }"}, {"sha": "55567d8625e529dfc541d3bf937284c130a9e516", "filename": "src/tools/clippy/clippy_lints/src/methods/suspicious_splitn.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3e7514670db841a7f0d7656f3b13b1c8b2c11599/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fsuspicious_splitn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e7514670db841a7f0d7656f3b13b1c8b2c11599/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fsuspicious_splitn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fsuspicious_splitn.rs?ref=3e7514670db841a7f0d7656f3b13b1c8b2c11599", "patch": "@@ -12,13 +12,13 @@ pub(super) fn check(cx: &LateContext<'_>, method_name: &str, expr: &Expr<'_>, se\n         if count <= 1;\n         if let Some(call_id) = cx.typeck_results().type_dependent_def_id(expr.hir_id);\n         if let Some(impl_id) = cx.tcx.impl_of_method(call_id);\n-        let lang_items = cx.tcx.lang_items();\n-        if lang_items.slice_impl() == Some(impl_id) || lang_items.str_impl() == Some(impl_id);\n+        if cx.tcx.impl_trait_ref(impl_id).is_none();\n+        let self_ty = cx.tcx.type_of(impl_id);\n+        if self_ty.is_slice() || self_ty.is_str();\n         then {\n             // Ignore empty slice and string literals when used with a literal count.\n             if matches!(self_arg.kind, ExprKind::Array([]))\n                 || matches!(self_arg.kind, ExprKind::Lit(Spanned { node: LitKind::Str(s, _), .. }) if s.is_empty())\n-\n             {\n                 return;\n             }\n@@ -28,7 +28,7 @@ pub(super) fn check(cx: &LateContext<'_>, method_name: &str, expr: &Expr<'_>, se\n                 \"the resulting iterator will always return `None`\")\n             } else {\n                 (format!(\"`{}` called with `1` split\", method_name),\n-                if lang_items.slice_impl() == Some(impl_id) {\n+                if self_ty.is_slice() {\n                     \"the resulting iterator will always return the entire slice followed by `None`\"\n                 } else {\n                     \"the resulting iterator will always return the entire string followed by `None`\""}, {"sha": "9d4313827f7c6afa048b68d70c1dc3d46ba2e6a1", "filename": "src/tools/clippy/clippy_lints/src/ptr.rs", "status": "modified", "additions": 3, "deletions": 15, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/3e7514670db841a7f0d7656f3b13b1c8b2c11599/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e7514670db841a7f0d7656f3b13b1c8b2c11599/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fptr.rs?ref=3e7514670db841a7f0d7656f3b13b1c8b2c11599", "patch": "@@ -16,7 +16,7 @@ use rustc_hir::{\n };\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::hir::nested_filter;\n-use rustc_middle::ty::{self, AssocItems, AssocKind, Ty};\n+use rustc_middle::ty::{self, Ty};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::source_map::Span;\n use rustc_span::symbol::Symbol;\n@@ -308,7 +308,6 @@ struct PtrArg<'tcx> {\n     method_renames: &'static [(&'static str, &'static str)],\n     ref_prefix: RefPrefix,\n     deref_ty: DerefTy<'tcx>,\n-    deref_assoc_items: Option<(DefId, &'tcx AssocItems<'tcx>)>,\n }\n impl PtrArg<'_> {\n     fn build_msg(&self) -> String {\n@@ -411,7 +410,7 @@ fn check_fn_args<'cx, 'tcx: 'cx>(\n                 if params.get(i).map_or(true, |p| !is_lint_allowed(cx, PTR_ARG, p.hir_id));\n \n                 then {\n-                    let (method_renames, deref_ty, deref_impl_id) = match cx.tcx.get_diagnostic_name(adt.did()) {\n+                    let (method_renames, deref_ty) = match cx.tcx.get_diagnostic_name(adt.did()) {\n                         Some(sym::Vec) => (\n                             [(\"clone\", \".to_owned()\")].as_slice(),\n                             DerefTy::Slice(\n@@ -424,17 +423,14 @@ fn check_fn_args<'cx, 'tcx: 'cx>(\n                                     }),\n                                 substs.type_at(0),\n                             ),\n-                            cx.tcx.lang_items().slice_impl()\n                         ),\n                         Some(sym::String) => (\n                             [(\"clone\", \".to_owned()\"), (\"as_str\", \"\")].as_slice(),\n                             DerefTy::Str,\n-                            cx.tcx.lang_items().str_impl()\n                         ),\n                         Some(sym::PathBuf) => (\n                             [(\"clone\", \".to_path_buf()\"), (\"as_path\", \"\")].as_slice(),\n                             DerefTy::Path,\n-                            None,\n                         ),\n                         Some(sym::Cow) if mutability == Mutability::Not => {\n                             let ty_name = name.args\n@@ -470,7 +466,6 @@ fn check_fn_args<'cx, 'tcx: 'cx>(\n                             mutability,\n                         },\n                         deref_ty,\n-                        deref_assoc_items: deref_impl_id.map(|id| (id, cx.tcx.associated_items(id))),\n                     });\n                 }\n             }\n@@ -607,14 +602,7 @@ fn check_ptr_arg_usage<'tcx>(cx: &LateContext<'tcx>, body: &'tcx Body<'_>, args:\n                             // If the types match check for methods which exist on both types. e.g. `Vec::len` and\n                             // `slice::len`\n                             ty::Adt(def, _)\n-                                if def.did() == args.ty_did\n-                                    && (i != 0\n-                                        || self.cx.tcx.trait_of_item(id).is_some()\n-                                        || !args.deref_assoc_items.map_or(false, |(id, items)| {\n-                                            items\n-                                                .find_by_name_and_kind(self.cx.tcx, name.ident, AssocKind::Fn, id)\n-                                                .is_some()\n-                                        })) =>\n+                                if def.did() == args.ty_did =>\n                             {\n                                 set_skip_flag();\n                             },"}, {"sha": "62e144398012d4b5780c83bbe51f44a2efc5928e", "filename": "src/tools/clippy/clippy_utils/src/lib.rs", "status": "modified", "additions": 61, "deletions": 38, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/3e7514670db841a7f0d7656f3b13b1c8b2c11599/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e7514670db841a7f0d7656f3b13b1c8b2c11599/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Flib.rs?ref=3e7514670db841a7f0d7656f3b13b1c8b2c11599", "patch": "@@ -77,16 +77,18 @@ use rustc_hir::intravisit::{walk_expr, FnKind, Visitor};\n use rustc_hir::itemlikevisit::ItemLikeVisitor;\n use rustc_hir::LangItem::{OptionNone, ResultErr, ResultOk};\n use rustc_hir::{\n-    def, lang_items, Arm, ArrayLen, BindingAnnotation, Block, BlockCheckMode, Body, Constness, Destination, Expr,\n+    def, Arm, ArrayLen, BindingAnnotation, Block, BlockCheckMode, Body, Constness, Destination, Expr,\n     ExprKind, FnDecl, ForeignItem, HirId, Impl, ImplItem, ImplItemKind, IsAsync, Item, ItemKind, LangItem, Local,\n-    MatchSource, Mutability, Node, Param, Pat, PatKind, Path, PathSegment, PrimTy, QPath, Stmt, StmtKind, Target,\n+    MatchSource, Mutability, Node, Param, Pat, PatKind, Path, PathSegment, PrimTy, QPath, Stmt, StmtKind,\n     TraitItem, TraitItemKind, TraitRef, TyKind, UnOp,\n };\n use rustc_lint::{LateContext, Level, Lint, LintContext};\n use rustc_middle::hir::place::PlaceBase;\n use rustc_middle::ty as rustc_ty;\n use rustc_middle::ty::adjustment::{Adjust, Adjustment, AutoBorrow};\n use rustc_middle::ty::binding::BindingMode;\n+use rustc_middle::ty::{IntTy, UintTy, FloatTy};\n+use rustc_middle::ty::fast_reject::SimplifiedTypeGen::*;\n use rustc_middle::ty::{layout::IntegerExt, BorrowKind, DefIdTree, Ty, TyCtxt, TypeAndMut, TypeFoldable, UpvarCapture};\n use rustc_semver::RustcVersion;\n use rustc_session::Session;\n@@ -455,14 +457,6 @@ pub fn path_def_id<'tcx>(cx: &LateContext<'_>, maybe_path: &impl MaybePath<'tcx>\n /// Resolves a def path like `std::vec::Vec`.\n /// This function is expensive and should be used sparingly.\n pub fn def_path_res(cx: &LateContext<'_>, path: &[&str]) -> Res {\n-    macro_rules! try_res {\n-        ($e:expr) => {\n-            match $e {\n-                Some(e) => e,\n-                None => return Res::Err,\n-            }\n-        };\n-    }\n     fn item_child_by_name(tcx: TyCtxt<'_>, def_id: DefId, name: &str) -> Option<Res> {\n         match tcx.def_kind(def_id) {\n             DefKind::Mod | DefKind::Enum | DefKind::Trait => tcx\n@@ -479,11 +473,35 @@ pub fn def_path_res(cx: &LateContext<'_>, path: &[&str]) -> Res {\n             _ => None,\n         }\n     }\n-    fn find_primitive(tcx: TyCtxt<'_>, name: &str) -> Option<DefId> {\n-        if let Some(&(index, Target::Impl)) = lang_items::ITEM_REFS.get(&Symbol::intern(name)) {\n-            tcx.lang_items().items()[index]\n-        } else {\n-            None\n+    fn find_primitive<'tcx>(tcx: TyCtxt<'tcx>, name: &str) -> impl Iterator<Item = DefId> + 'tcx {\n+        let single = |ty| tcx.incoherent_impls(ty).iter().copied();\n+        let empty = || [].iter().copied();\n+        match name {\n+            \"bool\" => single(BoolSimplifiedType),\n+            \"char\" => single(CharSimplifiedType),\n+            \"str\" => single(StrSimplifiedType),\n+            \"array\" => single(ArraySimplifiedType),\n+            \"slice\" => single(SliceSimplifiedType),\n+            // FIXME: rustdoc documents these two using just `pointer`.\n+            //\n+            // Maybe this is something we should do here too.\n+            \"const_ptr\" => single(PtrSimplifiedType(Mutability::Not)),\n+            \"mut_ptr\" => single(PtrSimplifiedType(Mutability::Mut)),\n+            \"isize\" => single(IntSimplifiedType(IntTy::Isize)),\n+            \"i8\" => single(IntSimplifiedType(IntTy::I8)),\n+            \"i16\" => single(IntSimplifiedType(IntTy::I16)),\n+            \"i32\" => single(IntSimplifiedType(IntTy::I32)),\n+            \"i64\" => single(IntSimplifiedType(IntTy::I64)),\n+            \"i128\" => single(IntSimplifiedType(IntTy::I128)),\n+            \"usize\" => single(UintSimplifiedType(UintTy::Usize)),\n+            \"u8\" => single(UintSimplifiedType(UintTy::U8)),\n+            \"u16\" => single(UintSimplifiedType(UintTy::U16)),\n+            \"u32\" => single(UintSimplifiedType(UintTy::U32)),\n+            \"u64\" => single(UintSimplifiedType(UintTy::U64)),\n+            \"u128\" => single(UintSimplifiedType(UintTy::U128)),\n+            \"f32\" => single(FloatSimplifiedType(FloatTy::F32)),\n+            \"f64\" => single(FloatSimplifiedType(FloatTy::F64)),\n+            _ => empty(),\n         }\n     }\n     fn find_crate(tcx: TyCtxt<'_>, name: &str) -> Option<DefId> {\n@@ -502,30 +520,35 @@ pub fn def_path_res(cx: &LateContext<'_>, path: &[&str]) -> Res {\n         _ => return Res::Err,\n     };\n     let tcx = cx.tcx;\n-    let first = try_res!(\n-        find_primitive(tcx, base)\n-            .or_else(|| find_crate(tcx, base))\n-            .and_then(|id| item_child_by_name(tcx, id, first))\n-    );\n+    let starts = find_primitive(tcx, base)\n+        .chain(find_crate(tcx, base))\n+        .flat_map(|id| item_child_by_name(tcx, id, first));\n \n-    let last = path\n-        .iter()\n-        .copied()\n-        // for each segment, find the child item\n-        .try_fold(first, |res, segment| {\n-            let def_id = res.def_id();\n-            if let Some(item) = item_child_by_name(tcx, def_id, segment) {\n-                Some(item)\n-            } else if matches!(res, Res::Def(DefKind::Enum | DefKind::Struct, _)) {\n-                // it is not a child item so check inherent impl items\n-                tcx.inherent_impls(def_id)\n-                    .iter()\n-                    .find_map(|&impl_def_id| item_child_by_name(tcx, impl_def_id, segment))\n-            } else {\n-                None\n-            }\n-        });\n-    try_res!(last).expect_non_local()\n+    for first in starts {\n+        let last = path\n+            .iter()\n+            .copied()\n+            // for each segment, find the child item\n+            .try_fold(first, |res, segment| {\n+                let def_id = res.def_id();\n+                if let Some(item) = item_child_by_name(tcx, def_id, segment) {\n+                    Some(item)\n+                } else if matches!(res, Res::Def(DefKind::Enum | DefKind::Struct, _)) {\n+                    // it is not a child item so check inherent impl items\n+                    tcx.inherent_impls(def_id)\n+                        .iter()\n+                        .find_map(|&impl_def_id| item_child_by_name(tcx, impl_def_id, segment))\n+                } else {\n+                    None\n+                }\n+            });\n+\n+        if let Some(last) = last {\n+            return last;\n+        }\n+    }\n+\n+    Res::Err\n }\n \n /// Convenience function to get the `DefId` of a trait by path."}]}