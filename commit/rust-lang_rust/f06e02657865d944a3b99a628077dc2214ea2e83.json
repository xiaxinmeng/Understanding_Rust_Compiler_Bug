{"sha": "f06e02657865d944a3b99a628077dc2214ea2e83", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYwNmUwMjY1Nzg2NWQ5NDRhM2I5OWE2MjgwNzdkYzIyMTRlYTJlODM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-06-09T20:00:32Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-06-09T20:00:32Z"}, "message": "Auto merge of #26039 - SimonSapin:case-mapping, r=alexcrichton\n\n* Add \u201ccomplex\u201d mappings to `char::to_lowercase` and `char::to_uppercase`, making them yield sometimes more than on `char`: #25800. `str::to_lowercase` and `str::to_uppercase` are affected as well.\r\n* Add `char::to_titlecase`, since it\u2019s the same algorithm (just different data). However this does **not** add `str::to_titlecase`, as that would require UAX#29 Unicode Text Segmentation which we decided not to include in of `std`: https://github.com/rust-lang/rfcs/pull/1054 I made `char::to_titlecase` immediately `#[stable]`, since it\u2019s so similar to `char::to_uppercase` that\u2019s already stable. Let me know if it should be `#[unstable]` for a while.\r\n* Add a special case for upper-case Sigma in word-final position in `str::to_lowercase`: #26035. This is the only language-independent conditional mapping currently in `SpecialCasing.txt`.\r\n* Stabilize `str::to_lowercase` and `str::to_uppercase`. The `&self -> String` on `str` signature seems straightforward enough, and the only relevant issue I\u2019ve found is #24536 about naming. But `char` already has stable methods with the same name, and deprecating them for a rename doesn\u2019t seem worth it.\r\n\r\nr? @alexcrichton", "tree": {"sha": "1a9d09966b3575ace0ed31c4206ca4b37d548663", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1a9d09966b3575ace0ed31c4206ca4b37d548663"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f06e02657865d944a3b99a628077dc2214ea2e83", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f06e02657865d944a3b99a628077dc2214ea2e83", "html_url": "https://github.com/rust-lang/rust/commit/f06e02657865d944a3b99a628077dc2214ea2e83", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f06e02657865d944a3b99a628077dc2214ea2e83/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8a3f5af8c98e123247a2847c52474f42874d23fa", "url": "https://api.github.com/repos/rust-lang/rust/commits/8a3f5af8c98e123247a2847c52474f42874d23fa", "html_url": "https://github.com/rust-lang/rust/commit/8a3f5af8c98e123247a2847c52474f42874d23fa"}, {"sha": "6369dcbad8fa75d8ffcb9c58d5baeea4709f02da", "url": "https://api.github.com/repos/rust-lang/rust/commits/6369dcbad8fa75d8ffcb9c58d5baeea4709f02da", "html_url": "https://github.com/rust-lang/rust/commit/6369dcbad8fa75d8ffcb9c58d5baeea4709f02da"}], "stats": {"total": 2648, "additions": 1975, "deletions": 673}, "files": [{"sha": "f580127cddaf8386515919b10902772a45aacbcf", "filename": "src/etc/unicode.py", "status": "modified", "additions": 72, "deletions": 25, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/f06e02657865d944a3b99a628077dc2214ea2e83/src%2Fetc%2Funicode.py", "raw_url": "https://github.com/rust-lang/rust/raw/f06e02657865d944a3b99a628077dc2214ea2e83/src%2Fetc%2Funicode.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Funicode.py?ref=f06e02657865d944a3b99a628077dc2214ea2e83", "patch": "@@ -72,8 +72,9 @@ def is_surrogate(n):\n def load_unicode_data(f):\n     fetch(f)\n     gencats = {}\n-    upperlower = {}\n-    lowerupper = {}\n+    to_lower = {}\n+    to_upper = {}\n+    to_title = {}\n     combines = {}\n     canon_decomp = {}\n     compat_decomp = {}\n@@ -103,12 +104,16 @@ def load_unicode_data(f):\n \n         # generate char to char direct common and simple conversions\n         # uppercase to lowercase\n-        if gencat == \"Lu\" and lowcase != \"\" and code_org != lowcase:\n-            upperlower[code] = int(lowcase, 16)\n+        if lowcase != \"\" and code_org != lowcase:\n+            to_lower[code] = (int(lowcase, 16), 0, 0)\n \n         # lowercase to uppercase\n-        if gencat == \"Ll\" and upcase != \"\" and code_org != upcase:\n-            lowerupper[code] = int(upcase, 16)\n+        if upcase != \"\" and code_org != upcase:\n+            to_upper[code] = (int(upcase, 16), 0, 0)\n+\n+        # title case\n+        if titlecase.strip() != \"\" and code_org != titlecase:\n+            to_title[code] = (int(titlecase, 16), 0, 0)\n \n         # store decomposition, if given\n         if decomp != \"\":\n@@ -144,7 +149,32 @@ def load_unicode_data(f):\n     gencats = group_cats(gencats)\n     combines = to_combines(group_cats(combines))\n \n-    return (canon_decomp, compat_decomp, gencats, combines, lowerupper, upperlower)\n+    return (canon_decomp, compat_decomp, gencats, combines, to_upper, to_lower, to_title)\n+\n+def load_special_casing(f, to_upper, to_lower, to_title):\n+    fetch(f)\n+    for line in fileinput.input(f):\n+        data = line.split('#')[0].split(';')\n+        if len(data) == 5:\n+            code, lower, title, upper, _comment = data\n+        elif len(data) == 6:\n+            code, lower, title, upper, condition, _comment = data\n+            if condition.strip():  # Only keep unconditional mappins\n+                continue\n+        else:\n+            continue\n+        code = code.strip()\n+        lower = lower.strip()\n+        title = title.strip()\n+        upper = upper.strip()\n+        key = int(code, 16)\n+        for (map_, values) in [(to_lower, lower), (to_upper, upper), (to_title, title)]:\n+            if values != code:\n+                values = [int(i, 16) for i in values.split()]\n+                for _ in range(len(values), 3):\n+                    values.append(0)\n+                assert len(values) == 3\n+                map_[key] = values\n \n def group_cats(cats):\n     cats_out = {}\n@@ -279,7 +309,7 @@ def load_east_asian_width(want_widths, except_cats):\n     return widths\n \n def escape_char(c):\n-    return \"'\\\\u{%x}'\" % c\n+    return \"'\\\\u{%x}'\" % c if c != 0 else \"'\\\\0'\"\n \n def emit_bsearch_range_table(f):\n     f.write(\"\"\"\n@@ -319,7 +349,7 @@ def emit_property_module(f, mod, tbl, emit):\n         f.write(\"    }\\n\\n\")\n     f.write(\"}\\n\\n\")\n \n-def emit_conversions_module(f, lowerupper, upperlower):\n+def emit_conversions_module(f, to_upper, to_lower, to_title):\n     f.write(\"pub mod conversions {\")\n     f.write(\"\"\"\n     use core::cmp::Ordering::{Equal, Less, Greater};\n@@ -328,21 +358,28 @@ def emit_conversions_module(f, lowerupper, upperlower):\n     use core::option::Option::{Some, None};\n     use core::result::Result::{Ok, Err};\n \n-    pub fn to_lower(c: char) -> char {\n-        match bsearch_case_table(c, LuLl_table) {\n-          None        => c,\n-          Some(index) => LuLl_table[index].1\n+    pub fn to_lower(c: char) -> [char; 3] {\n+        match bsearch_case_table(c, to_lowercase_table) {\n+          None        => [c, '\\\\0', '\\\\0'],\n+          Some(index) => to_lowercase_table[index].1\n+        }\n+    }\n+\n+    pub fn to_upper(c: char) -> [char; 3] {\n+        match bsearch_case_table(c, to_uppercase_table) {\n+            None        => [c, '\\\\0', '\\\\0'],\n+            Some(index) => to_uppercase_table[index].1\n         }\n     }\n \n-    pub fn to_upper(c: char) -> char {\n-        match bsearch_case_table(c, LlLu_table) {\n-            None        => c,\n-            Some(index) => LlLu_table[index].1\n+    pub fn to_title(c: char) -> [char; 3] {\n+        match bsearch_case_table(c, to_titlecase_table) {\n+            None        => [c, '\\\\0', '\\\\0'],\n+            Some(index) => to_titlecase_table[index].1\n         }\n     }\n \n-    fn bsearch_case_table(c: char, table: &'static [(char, char)]) -> Option<usize> {\n+    fn bsearch_case_table(c: char, table: &'static [(char, [char; 3])]) -> Option<usize> {\n         match table.binary_search_by(|&(key, _)| {\n             if c == key { Equal }\n             else if key < c { Less }\n@@ -354,10 +391,18 @@ def emit_conversions_module(f, lowerupper, upperlower):\n     }\n \n \"\"\")\n-    emit_table(f, \"LuLl_table\",\n-        sorted(upperlower.iteritems(), key=operator.itemgetter(0)), is_pub=False)\n-    emit_table(f, \"LlLu_table\",\n-        sorted(lowerupper.iteritems(), key=operator.itemgetter(0)), is_pub=False)\n+    t_type = \"&'static [(char, [char; 3])]\"\n+    pfun = lambda x: \"(%s,[%s,%s,%s])\" % (\n+        escape_char(x[0]), escape_char(x[1][0]), escape_char(x[1][1]), escape_char(x[1][2]))\n+    emit_table(f, \"to_lowercase_table\",\n+        sorted(to_lower.iteritems(), key=operator.itemgetter(0)),\n+        is_pub=False, t_type = t_type, pfun=pfun)\n+    emit_table(f, \"to_uppercase_table\",\n+        sorted(to_upper.iteritems(), key=operator.itemgetter(0)),\n+        is_pub=False, t_type = t_type, pfun=pfun)\n+    emit_table(f, \"to_titlecase_table\",\n+        sorted(to_title.iteritems(), key=operator.itemgetter(0)),\n+        is_pub=False, t_type = t_type, pfun=pfun)\n     f.write(\"}\\n\\n\")\n \n def emit_grapheme_module(f, grapheme_table, grapheme_cats):\n@@ -591,8 +636,10 @@ def optimize_width_table(wtable):\n pub const UNICODE_VERSION: (u64, u64, u64) = (%s, %s, %s);\n \"\"\" % unicode_version)\n         (canon_decomp, compat_decomp, gencats, combines,\n-                lowerupper, upperlower) = load_unicode_data(\"UnicodeData.txt\")\n-        want_derived = [\"XID_Start\", \"XID_Continue\", \"Alphabetic\", \"Lowercase\", \"Uppercase\"]\n+                to_upper, to_lower, to_title) = load_unicode_data(\"UnicodeData.txt\")\n+        load_special_casing(\"SpecialCasing.txt\", to_upper, to_lower, to_title)\n+        want_derived = [\"XID_Start\", \"XID_Continue\", \"Alphabetic\", \"Lowercase\", \"Uppercase\",\n+                        \"Cased\", \"Case_Ignorable\"]\n         derived = load_properties(\"DerivedCoreProperties.txt\", want_derived)\n         scripts = load_properties(\"Scripts.txt\", [])\n         props = load_properties(\"PropList.txt\",\n@@ -611,7 +658,7 @@ def optimize_width_table(wtable):\n \n         # normalizations and conversions module\n         emit_norm_module(rf, canon_decomp, compat_decomp, combines, norm_props)\n-        emit_conversions_module(rf, lowerupper, upperlower)\n+        emit_conversions_module(rf, to_upper, to_lower, to_title)\n \n         ### character width module\n         width_table = []"}, {"sha": "ef8039c565ad24a3d286510f7a61b601e67a1607", "filename": "src/libcollections/str.rs", "status": "modified", "additions": 32, "deletions": 3, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/f06e02657865d944a3b99a628077dc2214ea2e83/src%2Flibcollections%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f06e02657865d944a3b99a628077dc2214ea2e83/src%2Flibcollections%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstr.rs?ref=f06e02657865d944a3b99a628077dc2214ea2e83", "patch": "@@ -1816,11 +1816,40 @@ impl str {\n     /// let s = \"HELLO\";\n     /// assert_eq!(s.to_lowercase(), \"hello\");\n     /// ```\n-    #[unstable(feature = \"collections\")]\n+    #[stable(feature = \"unicode_case_mapping\", since = \"1.2.0\")]\n     pub fn to_lowercase(&self) -> String {\n         let mut s = String::with_capacity(self.len());\n-        s.extend(self[..].chars().flat_map(|c| c.to_lowercase()));\n+        for (i, c) in self[..].char_indices() {\n+            if c == '\u03a3' {\n+                // \u03a3 maps to \u03c3, except at the end of a word where it maps to \u03c2.\n+                // This is the only conditional (contextual) but language-independent mapping\n+                // in `SpecialCasing.txt`,\n+                // so hard-code it rather than have a generic \"condition\" mechanim.\n+                // See https://github.com/rust-lang/rust/issues/26035\n+                map_uppercase_sigma(self, i, &mut s)\n+            } else {\n+                s.extend(c.to_lowercase());\n+            }\n+        }\n         return s;\n+\n+        fn map_uppercase_sigma(from: &str, i: usize, to: &mut String) {\n+            // See http://www.unicode.org/versions/Unicode7.0.0/ch03.pdf#G33992\n+            // for the definition of `Final_Sigma`.\n+            debug_assert!('\u03a3'.len_utf8() == 2);\n+            let is_word_final =\n+                case_ignoreable_then_cased(from[..i].chars().rev()) &&\n+                !case_ignoreable_then_cased(from[i + 2..].chars());\n+            to.push_str(if is_word_final { \"\u03c2\" } else { \"\u03c3\" });\n+        }\n+\n+        fn case_ignoreable_then_cased<I: Iterator<Item=char>>(iter: I) -> bool {\n+            use rustc_unicode::derived_property::{Cased, Case_Ignorable};\n+            match iter.skip_while(|&c| Case_Ignorable(c)).next() {\n+                Some(c) => Cased(c),\n+                None => false,\n+            }\n+        }\n     }\n \n     /// Returns the uppercase equivalent of this string.\n@@ -1833,7 +1862,7 @@ impl str {\n     /// let s = \"hello\";\n     /// assert_eq!(s.to_uppercase(), \"HELLO\");\n     /// ```\n-    #[unstable(feature = \"collections\")]\n+    #[stable(feature = \"unicode_case_mapping\", since = \"1.2.0\")]\n     pub fn to_uppercase(&self) -> String {\n         let mut s = String::with_capacity(self.len());\n         s.extend(self[..].chars().flat_map(|c| c.to_uppercase()));"}, {"sha": "ae525459189520d526c956709b32dc01762a2054", "filename": "src/libcollectionstest/str.rs", "status": "modified", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/f06e02657865d944a3b99a628077dc2214ea2e83/src%2Flibcollectionstest%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f06e02657865d944a3b99a628077dc2214ea2e83/src%2Flibcollectionstest%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Fstr.rs?ref=f06e02657865d944a3b99a628077dc2214ea2e83", "patch": "@@ -1687,6 +1687,45 @@ fn trim_ws() {\n                \"\");\n }\n \n+#[test]\n+fn to_lowercase() {\n+    assert_eq!(\"\".to_lowercase(), \"\");\n+    assert_eq!(\"A\u00c9\u01c5a\u00e9 \".to_lowercase(), \"a\u00e9\u01c6a\u00e9 \");\n+\n+    // https://github.com/rust-lang/rust/issues/26035\n+    assert_eq!(\"\u0391\u03a3\".to_lowercase(), \"\u03b1\u03c2\");\n+    assert_eq!(\"\u0391'\u03a3\".to_lowercase(), \"\u03b1'\u03c2\");\n+    assert_eq!(\"\u0391''\u03a3\".to_lowercase(), \"\u03b1''\u03c2\");\n+\n+    assert_eq!(\"\u0391\u03a3 \u0391\".to_lowercase(), \"\u03b1\u03c2 \u03b1\");\n+    assert_eq!(\"\u0391'\u03a3 \u0391\".to_lowercase(), \"\u03b1'\u03c2 \u03b1\");\n+    assert_eq!(\"\u0391''\u03a3 \u0391\".to_lowercase(), \"\u03b1''\u03c2 \u03b1\");\n+\n+    assert_eq!(\"\u0391\u03a3' \u0391\".to_lowercase(), \"\u03b1\u03c2' \u03b1\");\n+    assert_eq!(\"\u0391\u03a3'' \u0391\".to_lowercase(), \"\u03b1\u03c2'' \u03b1\");\n+\n+    assert_eq!(\"\u0391'\u03a3' \u0391\".to_lowercase(), \"\u03b1'\u03c2' \u03b1\");\n+    assert_eq!(\"\u0391''\u03a3'' \u0391\".to_lowercase(), \"\u03b1''\u03c2'' \u03b1\");\n+\n+    assert_eq!(\"\u0391 \u03a3\".to_lowercase(), \"\u03b1 \u03c3\");\n+    assert_eq!(\"\u0391 '\u03a3\".to_lowercase(), \"\u03b1 '\u03c3\");\n+    assert_eq!(\"\u0391 ''\u03a3\".to_lowercase(), \"\u03b1 ''\u03c3\");\n+\n+    assert_eq!(\"\u03a3\".to_lowercase(), \"\u03c3\");\n+    assert_eq!(\"'\u03a3\".to_lowercase(), \"'\u03c3\");\n+    assert_eq!(\"''\u03a3\".to_lowercase(), \"''\u03c3\");\n+\n+    assert_eq!(\"\u0391\u03a3\u0391\".to_lowercase(), \"\u03b1\u03c3\u03b1\");\n+    assert_eq!(\"\u0391\u03a3'\u0391\".to_lowercase(), \"\u03b1\u03c3'\u03b1\");\n+    assert_eq!(\"\u0391\u03a3''\u0391\".to_lowercase(), \"\u03b1\u03c3''\u03b1\");\n+}\n+\n+#[test]\n+fn to_uppercase() {\n+    assert_eq!(\"\".to_uppercase(), \"\");\n+    assert_eq!(\"a\u00e9\u01c5\u00df\ufb01\u1f80\".to_uppercase(), \"A\u00c9\u01c4SSFI\u1f08\u0399\");\n+}\n+\n mod pattern {\n     use std::str::pattern::Pattern;\n     use std::str::pattern::{Searcher, ReverseSearcher};"}, {"sha": "1506982586a00a55f819084d2e9f6b5a33b8e849", "filename": "src/libcoretest/char.rs", "status": "modified", "additions": 45, "deletions": 18, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/f06e02657865d944a3b99a628077dc2214ea2e83/src%2Flibcoretest%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f06e02657865d944a3b99a628077dc2214ea2e83/src%2Flibcoretest%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fchar.rs?ref=f06e02657865d944a3b99a628077dc2214ea2e83", "patch": "@@ -58,6 +58,8 @@ fn test_to_lowercase() {\n     fn lower(c: char) -> char {\n         let mut it = c.to_lowercase();\n         let c = it.next().unwrap();\n+        // As of Unicode version 7.0.0, `SpecialCasing.txt` has no lower-case mapping\n+        // to multiple code points.\n         assert!(it.next().is_none());\n         c\n     }\n@@ -73,29 +75,54 @@ fn test_to_lowercase() {\n     assert_eq!(lower('\u039c'), '\u03bc');\n     assert_eq!(lower('\u0391'), '\u03b1');\n     assert_eq!(lower('\u03a3'), '\u03c3');\n+    assert_eq!(lower('\u01c5'), '\u01c6');\n+    assert_eq!(lower('\ufb01'), '\ufb01');\n }\n \n #[test]\n fn test_to_uppercase() {\n-    fn upper(c: char) -> char {\n-        let mut it = c.to_uppercase();\n-        let c = it.next().unwrap();\n-        assert!(it.next().is_none());\n-        c\n+    fn upper(c: char) -> Vec<char> {\n+        c.to_uppercase().collect()\n     }\n-    assert_eq!(upper('a'), 'A');\n-    assert_eq!(upper('\u00f6'), '\u00d6');\n-    assert_eq!(upper('\u00df'), '\u00df'); // not \u1e9e: Latin capital letter sharp s\n-    assert_eq!(upper('\u00fc'), '\u00dc');\n-    assert_eq!(upper('\ud83d\udca9'), '\ud83d\udca9');\n-\n-    assert_eq!(upper('\u03c3'), '\u03a3');\n-    assert_eq!(upper('\u03c4'), '\u03a4');\n-    assert_eq!(upper('\u03b9'), '\u0399');\n-    assert_eq!(upper('\u03b3'), '\u0393');\n-    assert_eq!(upper('\u03bc'), '\u039c');\n-    assert_eq!(upper('\u03b1'), '\u0391');\n-    assert_eq!(upper('\u03c2'), '\u03a3');\n+    assert_eq!(upper('a'), ['A']);\n+    assert_eq!(upper('\u00f6'), ['\u00d6']);\n+    assert_eq!(upper('\u00df'), ['S', 'S']); // not \u1e9e: Latin capital letter sharp s\n+    assert_eq!(upper('\u00fc'), ['\u00dc']);\n+    assert_eq!(upper('\ud83d\udca9'), ['\ud83d\udca9']);\n+\n+    assert_eq!(upper('\u03c3'), ['\u03a3']);\n+    assert_eq!(upper('\u03c4'), ['\u03a4']);\n+    assert_eq!(upper('\u03b9'), ['\u0399']);\n+    assert_eq!(upper('\u03b3'), ['\u0393']);\n+    assert_eq!(upper('\u03bc'), ['\u039c']);\n+    assert_eq!(upper('\u03b1'), ['\u0391']);\n+    assert_eq!(upper('\u03c2'), ['\u03a3']);\n+    assert_eq!(upper('\u01c5'), ['\u01c4']);\n+    assert_eq!(upper('\ufb01'), ['F', 'I']);\n+    assert_eq!(upper('\u1f80'), ['\u1f08', '\u0399']);\n+}\n+\n+#[test]\n+fn test_to_titlecase() {\n+    fn title(c: char) -> Vec<char> {\n+        c.to_titlecase().collect()\n+    }\n+    assert_eq!(title('a'), ['A']);\n+    assert_eq!(title('\u00f6'), ['\u00d6']);\n+    assert_eq!(title('\u00df'), ['S', 's']); // not \u1e9e: Latin capital letter sharp s\n+    assert_eq!(title('\u00fc'), ['\u00dc']);\n+    assert_eq!(title('\ud83d\udca9'), ['\ud83d\udca9']);\n+\n+    assert_eq!(title('\u03c3'), ['\u03a3']);\n+    assert_eq!(title('\u03c4'), ['\u03a4']);\n+    assert_eq!(title('\u03b9'), ['\u0399']);\n+    assert_eq!(title('\u03b3'), ['\u0393']);\n+    assert_eq!(title('\u03bc'), ['\u039c']);\n+    assert_eq!(title('\u03b1'), ['\u0391']);\n+    assert_eq!(title('\u03c2'), ['\u03a3']);\n+    assert_eq!(title('\u01c4'), ['\u01c5']);\n+    assert_eq!(title('\ufb01'), ['F', 'i']);\n+    assert_eq!(title('\u1f80'), ['\u1f88']);\n }\n \n #[test]"}, {"sha": "1737de827e3cead9414212814a613d4eeb0decc0", "filename": "src/librustc_lint/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f06e02657865d944a3b99a628077dc2214ea2e83/src%2Flibrustc_lint%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f06e02657865d944a3b99a628077dc2214ea2e83/src%2Flibrustc_lint%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Flib.rs?ref=f06e02657865d944a3b99a628077dc2214ea2e83", "patch": "@@ -32,7 +32,7 @@\n \n #![feature(box_patterns)]\n #![feature(box_syntax)]\n-#![feature(collections)]\n+#![cfg_attr(stage0, feature(collections))]\n #![feature(core)]\n #![feature(quote)]\n #![feature(rustc_diagnostic_macros)]"}, {"sha": "5b1300b18b63bedd013d3999d4f4fd2032c12d27", "filename": "src/librustc_unicode/char.rs", "status": "modified", "additions": 93, "deletions": 17, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/f06e02657865d944a3b99a628077dc2214ea2e83/src%2Flibrustc_unicode%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f06e02657865d944a3b99a628077dc2214ea2e83/src%2Flibrustc_unicode%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_unicode%2Fchar.rs?ref=f06e02657865d944a3b99a628077dc2214ea2e83", "patch": "@@ -29,7 +29,7 @@\n #![doc(primitive = \"char\")]\n \n use core::char::CharExt as C;\n-use core::option::Option::{self, Some};\n+use core::option::Option::{self, Some, None};\n use core::iter::Iterator;\n use tables::{derived_property, property, general_category, conversions, charwidth};\n \n@@ -47,24 +47,79 @@ pub use tables::UNICODE_VERSION;\n /// the [`to_lowercase` method](../primitive.char.html#method.to_lowercase) on\n /// characters.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct ToLowercase(Option<char>);\n+pub struct ToLowercase(CaseMappingIter);\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Iterator for ToLowercase {\n     type Item = char;\n-    fn next(&mut self) -> Option<char> { self.0.take() }\n+    fn next(&mut self) -> Option<char> { self.0.next() }\n }\n \n /// An iterator over the uppercase mapping of a given character, returned from\n /// the [`to_uppercase` method](../primitive.char.html#method.to_uppercase) on\n /// characters.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct ToUppercase(Option<char>);\n+pub struct ToUppercase(CaseMappingIter);\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Iterator for ToUppercase {\n     type Item = char;\n-    fn next(&mut self) -> Option<char> { self.0.take() }\n+    fn next(&mut self) -> Option<char> { self.0.next() }\n+}\n+\n+/// An iterator over the titlecase mapping of a given character, returned from\n+/// the [`to_titlecase` method](../primitive.char.html#method.to_titlecase) on\n+/// characters.\n+#[unstable(feature = \"unicode\", reason = \"recently added\")]\n+pub struct ToTitlecase(CaseMappingIter);\n+\n+#[stable(feature = \"unicode_case_mapping\", since = \"1.2.0\")]\n+impl Iterator for ToTitlecase {\n+    type Item = char;\n+    fn next(&mut self) -> Option<char> { self.0.next() }\n+}\n+\n+\n+enum CaseMappingIter {\n+    Three(char, char, char),\n+    Two(char, char),\n+    One(char),\n+    Zero\n+}\n+\n+impl CaseMappingIter {\n+    fn new(chars: [char; 3]) -> CaseMappingIter {\n+        if chars[2] == '\\0' {\n+            if chars[1] == '\\0' {\n+                CaseMappingIter::One(chars[0])  // Including if chars[0] == '\\0'\n+            } else {\n+                CaseMappingIter::Two(chars[0], chars[1])\n+            }\n+        } else {\n+            CaseMappingIter::Three(chars[0], chars[1], chars[2])\n+        }\n+    }\n+}\n+\n+impl Iterator for CaseMappingIter {\n+    type Item = char;\n+    fn next(&mut self) -> Option<char> {\n+        match *self {\n+            CaseMappingIter::Three(a, b, c) => {\n+                *self = CaseMappingIter::Two(b, c);\n+                Some(a)\n+            }\n+            CaseMappingIter::Two(b, c) => {\n+                *self = CaseMappingIter::One(c);\n+                Some(b)\n+            }\n+            CaseMappingIter::One(c) => {\n+                *self = CaseMappingIter::Zero;\n+                Some(c)\n+            }\n+            CaseMappingIter::Zero => None,\n+        }\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -397,45 +452,66 @@ impl char {\n \n     /// Converts a character to its lowercase equivalent.\n     ///\n-    /// The case-folding performed is the common or simple mapping. See\n-    /// `to_uppercase()` for references and more information.\n+    /// This performs complex unconditional mappings with no tailoring.\n+    /// See `to_uppercase()` for references and more information.\n     ///\n     /// # Return value\n     ///\n     /// Returns an iterator which yields the characters corresponding to the\n     /// lowercase equivalent of the character. If no conversion is possible then\n-    /// the input character is returned.\n+    /// an iterator with just the input character is returned.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn to_lowercase(self) -> ToLowercase {\n-        ToLowercase(Some(conversions::to_lower(self)))\n+        ToLowercase(CaseMappingIter::new(conversions::to_lower(self)))\n+    }\n+\n+    /// Converts a character to its titlecase equivalent.\n+    ///\n+    /// This performs complex unconditional mappings with no tailoring.\n+    /// See `to_uppercase()` for references and more information.\n+    ///\n+    /// This differs from `to_uppercase()` since Unicode contains\n+    /// digraphs and ligature characters.\n+    /// For example, U+01F3 \u201c\u01f3\u201d and U+FB01 \u201c\ufb01\u201d\n+    /// map to U+01F1 \u201c\u01f1\u201d and U+0046 U+0069 \u201cFi\u201d, respectively.\n+    ///\n+    /// # Return value\n+    ///\n+    /// Returns an iterator which yields the characters corresponding to the\n+    /// lowercase equivalent of the character. If no conversion is possible then\n+    /// an iterator with just the input character is returned.\n+    #[unstable(feature = \"unicode\", reason = \"recently added\")]\n+    #[inline]\n+    pub fn to_titlecase(self) -> ToTitlecase {\n+        ToTitlecase(CaseMappingIter::new(conversions::to_title(self)))\n     }\n \n     /// Converts a character to its uppercase equivalent.\n     ///\n-    /// The case-folding performed is the common or simple mapping: it maps\n-    /// one Unicode codepoint to its uppercase equivalent according to the\n-    /// Unicode database [1]. The additional [`SpecialCasing.txt`] is not yet\n-    /// considered here, but the iterator returned will soon support this form\n-    /// of case folding.\n+    /// This performs complex unconditional mappings with no tailoring:\n+    /// it maps one Unicode character to its uppercase equivalent\n+    /// according to the Unicode database [1]\n+    /// and the additional complex mappings [`SpecialCasing.txt`].\n+    /// Conditional mappings (based on context or language) are not considerd here.\n     ///\n     /// A full reference can be found here [2].\n     ///\n     /// # Return value\n     ///\n     /// Returns an iterator which yields the characters corresponding to the\n     /// uppercase equivalent of the character. If no conversion is possible then\n-    /// the input character is returned.\n+    /// an iterator with just the input character is returned.\n     ///\n     /// [1]: ftp://ftp.unicode.org/Public/UNIDATA/UnicodeData.txt\n     ///\n     /// [`SpecialCasing.txt`]: ftp://ftp.unicode.org/Public/UNIDATA/SpecialCasing.txt\n     ///\n-    /// [2]: http://www.unicode.org/versions/Unicode4.0.0/ch03.pdf#G33992\n+    /// [2]: http://www.unicode.org/versions/Unicode7.0.0/ch03.pdf#G33992\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn to_uppercase(self) -> ToUppercase {\n-        ToUppercase(Some(conversions::to_upper(self)))\n+        ToUppercase(CaseMappingIter::new(conversions::to_upper(self)))\n     }\n \n     /// Returns this character's displayed width in columns, or `None` if it is a"}, {"sha": "a9456cb487c6a71d199414dfd9e251575715ed9c", "filename": "src/librustc_unicode/lib.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f06e02657865d944a3b99a628077dc2214ea2e83/src%2Flibrustc_unicode%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f06e02657865d944a3b99a628077dc2214ea2e83/src%2Flibrustc_unicode%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_unicode%2Flib.rs?ref=f06e02657865d944a3b99a628077dc2214ea2e83", "patch": "@@ -49,3 +49,8 @@ pub mod str {\n     pub use u_str::{utf8_char_width, is_utf16, Utf16Items, Utf16Item};\n     pub use u_str::{utf16_items, Utf16Encoder};\n }\n+\n+// For use in libcollections, not re-exported in libstd.\n+pub mod derived_property {\n+    pub use tables::derived_property::{Cased, Case_Ignorable};\n+}"}, {"sha": "4ebb6a70d291c300cc588ca9aadc7e111be598d2", "filename": "src/librustc_unicode/tables.rs", "status": "modified", "additions": 1688, "deletions": 609, "changes": 2297, "blob_url": "https://github.com/rust-lang/rust/blob/f06e02657865d944a3b99a628077dc2214ea2e83/src%2Flibrustc_unicode%2Ftables.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f06e02657865d944a3b99a628077dc2214ea2e83/src%2Flibrustc_unicode%2Ftables.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_unicode%2Ftables.rs?ref=f06e02657865d944a3b99a628077dc2214ea2e83"}]}