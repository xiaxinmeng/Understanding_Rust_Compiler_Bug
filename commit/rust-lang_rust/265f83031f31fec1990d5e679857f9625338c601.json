{"sha": "265f83031f31fec1990d5e679857f9625338c601", "node_id": "C_kwDOAAsO6NoAKDI2NWY4MzAzMWYzMWZlYzE5OTBkNWU2Nzk4NTdmOTYyNTMzOGM2MDE", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-04-05T13:44:51Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-04-05T13:44:51Z"}, "message": "Auto merge of #14433 - hecatia-elegua:alias-based-completion, r=Veykril\n\nAdd doc-alias based completion\n\nCloses #14406.\n\nI adapted the parsing code from the CfgExpr parsing code, maybe there's a better abstraction for both, or attribute parsing in general. It also includes `doc(hidden)`-parsing, which means it could replace the other function.\nThere are a few tests for parsing.\n\n`process_all_names` changed the most, I added some docs there to explain what happens.\n\nMany call sites just pass an empy vec to `add_path_resolution`'s `doc_aliases`, since either it doesn't make sense to pass anything (e.g. visibility completion) or I don't know where to get them from. Shouldn't really matter, as it will just not show aliases if the vec is empty and we can extend alias completion in these cases later.\n\nI added two tests in `special.rs` for struct name completion (which was the main thing I wanted). I also tried function and field names, but these don't work yet. I want to add those in a follow-up PR.", "tree": {"sha": "3acfa4761f72f3fa1bdd334276824cd009d24136", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3acfa4761f72f3fa1bdd334276824cd009d24136"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/265f83031f31fec1990d5e679857f9625338c601", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/265f83031f31fec1990d5e679857f9625338c601", "html_url": "https://github.com/rust-lang/rust/commit/265f83031f31fec1990d5e679857f9625338c601", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/265f83031f31fec1990d5e679857f9625338c601/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c3ed59ce1c5d0f1d8ee867ea2013dc47ccedd712", "url": "https://api.github.com/repos/rust-lang/rust/commits/c3ed59ce1c5d0f1d8ee867ea2013dc47ccedd712", "html_url": "https://github.com/rust-lang/rust/commit/c3ed59ce1c5d0f1d8ee867ea2013dc47ccedd712"}, {"sha": "170822b01892d58cffc1694cf14fd2ea48040681", "url": "https://api.github.com/repos/rust-lang/rust/commits/170822b01892d58cffc1694cf14fd2ea48040681", "html_url": "https://github.com/rust-lang/rust/commit/170822b01892d58cffc1694cf14fd2ea48040681"}], "stats": {"total": 375, "additions": 334, "deletions": 41}, "files": [{"sha": "4dde093f96894f8ca9e2fb4fef04dd63dea42ce0", "filename": "crates/hir-def/src/attr.rs", "status": "modified", "additions": 112, "deletions": 0, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/265f83031f31fec1990d5e679857f9625338c601/crates%2Fhir-def%2Fsrc%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265f83031f31fec1990d5e679857f9625338c601/crates%2Fhir-def%2Fsrc%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fattr.rs?ref=265f83031f31fec1990d5e679857f9625338c601", "patch": "@@ -1,5 +1,8 @@\n //! A higher level attributes based on TokenTree, with also some shortcuts.\n \n+#[cfg(test)]\n+mod tests;\n+\n use std::{hash::Hash, ops, sync::Arc};\n \n use base_db::CrateId;\n@@ -245,6 +248,14 @@ impl Attrs {\n         })\n     }\n \n+    pub fn doc_exprs(&self) -> impl Iterator<Item = DocExpr> + '_ {\n+        self.by_key(\"doc\").tt_values().map(DocExpr::parse)\n+    }\n+\n+    pub fn doc_aliases(&self) -> impl Iterator<Item = SmolStr> + '_ {\n+        self.doc_exprs().flat_map(|doc_expr| doc_expr.aliases().to_vec())\n+    }\n+\n     pub fn is_proc_macro(&self) -> bool {\n         self.by_key(\"proc_macro\").exists()\n     }\n@@ -258,6 +269,107 @@ impl Attrs {\n     }\n }\n \n+use std::slice::Iter as SliceIter;\n+#[derive(Debug, Clone, PartialEq, Eq, Hash, Ord, PartialOrd)]\n+pub enum DocAtom {\n+    /// eg. `#[doc(hidden)]`\n+    Flag(SmolStr),\n+    /// eg. `#[doc(alias = \"x\")]`\n+    ///\n+    /// Note that a key can have multiple values that are all considered \"active\" at the same time.\n+    /// For example, `#[doc(alias = \"x\")]` and `#[doc(alias = \"y\")]`.\n+    KeyValue { key: SmolStr, value: SmolStr },\n+}\n+\n+// Adapted from `CfgExpr` parsing code\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+// #[cfg_attr(test, derive(derive_arbitrary::Arbitrary))]\n+pub enum DocExpr {\n+    Invalid,\n+    /// eg. `#[doc(hidden)]`, `#[doc(alias = \"x\")]`\n+    Atom(DocAtom),\n+    /// eg. `#[doc(alias(\"x\", \"y\"))]`\n+    Alias(Vec<SmolStr>),\n+}\n+\n+impl From<DocAtom> for DocExpr {\n+    fn from(atom: DocAtom) -> Self {\n+        DocExpr::Atom(atom)\n+    }\n+}\n+\n+impl DocExpr {\n+    fn parse<S>(tt: &tt::Subtree<S>) -> DocExpr {\n+        next_doc_expr(&mut tt.token_trees.iter()).unwrap_or(DocExpr::Invalid)\n+    }\n+\n+    pub fn aliases(&self) -> &[SmolStr] {\n+        match self {\n+            DocExpr::Atom(DocAtom::KeyValue { key, value }) if key == \"alias\" => {\n+                std::slice::from_ref(value)\n+            }\n+            DocExpr::Alias(aliases) => aliases,\n+            _ => &[],\n+        }\n+    }\n+}\n+\n+fn next_doc_expr<S>(it: &mut SliceIter<'_, tt::TokenTree<S>>) -> Option<DocExpr> {\n+    let name = match it.next() {\n+        None => return None,\n+        Some(tt::TokenTree::Leaf(tt::Leaf::Ident(ident))) => ident.text.clone(),\n+        Some(_) => return Some(DocExpr::Invalid),\n+    };\n+\n+    // Peek\n+    let ret = match it.as_slice().first() {\n+        Some(tt::TokenTree::Leaf(tt::Leaf::Punct(punct))) if punct.char == '=' => {\n+            match it.as_slice().get(1) {\n+                Some(tt::TokenTree::Leaf(tt::Leaf::Literal(literal))) => {\n+                    it.next();\n+                    it.next();\n+                    // FIXME: escape? raw string?\n+                    let value =\n+                        SmolStr::new(literal.text.trim_start_matches('\"').trim_end_matches('\"'));\n+                    DocAtom::KeyValue { key: name, value }.into()\n+                }\n+                _ => return Some(DocExpr::Invalid),\n+            }\n+        }\n+        Some(tt::TokenTree::Subtree(subtree)) => {\n+            it.next();\n+            let subs = parse_comma_sep(subtree);\n+            match name.as_str() {\n+                \"alias\" => DocExpr::Alias(subs),\n+                _ => DocExpr::Invalid,\n+            }\n+        }\n+        _ => DocAtom::Flag(name).into(),\n+    };\n+\n+    // Eat comma separator\n+    if let Some(tt::TokenTree::Leaf(tt::Leaf::Punct(punct))) = it.as_slice().first() {\n+        if punct.char == ',' {\n+            it.next();\n+        }\n+    }\n+    Some(ret)\n+}\n+\n+fn parse_comma_sep<S>(subtree: &tt::Subtree<S>) -> Vec<SmolStr> {\n+    subtree\n+        .token_trees\n+        .iter()\n+        .filter_map(|tt| match tt {\n+            tt::TokenTree::Leaf(tt::Leaf::Literal(lit)) => {\n+                // FIXME: escape? raw string?\n+                Some(SmolStr::new(lit.text.trim_start_matches('\"').trim_end_matches('\"')))\n+            }\n+            _ => None,\n+        })\n+        .collect()\n+}\n+\n impl AttrsWithOwner {\n     pub(crate) fn attrs_query(db: &dyn DefDatabase, def: AttrDefId) -> Self {\n         let _p = profile::span(\"attrs_query\");"}, {"sha": "e4c8d446af7bd762c60246e5adee44487200f353", "filename": "crates/hir-def/src/attr/tests.rs", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/265f83031f31fec1990d5e679857f9625338c601/crates%2Fhir-def%2Fsrc%2Fattr%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265f83031f31fec1990d5e679857f9625338c601/crates%2Fhir-def%2Fsrc%2Fattr%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fattr%2Ftests.rs?ref=265f83031f31fec1990d5e679857f9625338c601", "patch": "@@ -0,0 +1,40 @@\n+//! This module contains tests for doc-expression parsing.\n+//! Currently, it tests `#[doc(hidden)]` and `#[doc(alias)]`.\n+\n+use mbe::syntax_node_to_token_tree;\n+use syntax::{ast, AstNode};\n+\n+use crate::attr::{DocAtom, DocExpr};\n+\n+fn assert_parse_result(input: &str, expected: DocExpr) {\n+    let (tt, _) = {\n+        let source_file = ast::SourceFile::parse(input).ok().unwrap();\n+        let tt = source_file.syntax().descendants().find_map(ast::TokenTree::cast).unwrap();\n+        syntax_node_to_token_tree(tt.syntax())\n+    };\n+    let cfg = DocExpr::parse(&tt);\n+    assert_eq!(cfg, expected);\n+}\n+\n+#[test]\n+fn test_doc_expr_parser() {\n+    assert_parse_result(\"#![doc(hidden)]\", DocAtom::Flag(\"hidden\".into()).into());\n+\n+    assert_parse_result(\n+        r#\"#![doc(alias = \"foo\")]\"#,\n+        DocAtom::KeyValue { key: \"alias\".into(), value: \"foo\".into() }.into(),\n+    );\n+\n+    assert_parse_result(r#\"#![doc(alias(\"foo\"))]\"#, DocExpr::Alias([\"foo\".into()].into()));\n+    assert_parse_result(\n+        r#\"#![doc(alias(\"foo\", \"bar\", \"baz\"))]\"#,\n+        DocExpr::Alias([\"foo\".into(), \"bar\".into(), \"baz\".into()].into()),\n+    );\n+\n+    assert_parse_result(\n+        r#\"\n+        #[doc(alias(\"Bar\", \"Qux\"))]\n+        struct Foo;\"#,\n+        DocExpr::Alias([\"Bar\".into(), \"Qux\".into()].into()),\n+    );\n+}"}, {"sha": "2b2a2966c1c3829668b920a54d33c53e261b6297", "filename": "crates/hir/src/semantics.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/265f83031f31fec1990d5e679857f9625338c601/crates%2Fhir%2Fsrc%2Fsemantics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265f83031f31fec1990d5e679857f9625338c601/crates%2Fhir%2Fsrc%2Fsemantics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fsemantics.rs?ref=265f83031f31fec1990d5e679857f9625338c601", "patch": "@@ -1644,6 +1644,7 @@ impl<'a> SemanticsScope<'a> {\n         VisibleTraits(resolver.traits_in_scope(self.db.upcast()))\n     }\n \n+    /// Calls the passed closure `f` on all names in scope.\n     pub fn process_all_names(&self, f: &mut dyn FnMut(Name, ScopeDef)) {\n         let scope = self.resolver.names_in_scope(self.db.upcast());\n         for (name, entries) in scope {"}, {"sha": "b6a066f4f5180864ee0c0101350a641c15885a5b", "filename": "crates/ide-completion/src/completions.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/265f83031f31fec1990d5e679857f9625338c601/crates%2Fide-completion%2Fsrc%2Fcompletions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265f83031f31fec1990d5e679857f9625338c601/crates%2Fide-completion%2Fsrc%2Fcompletions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions.rs?ref=265f83031f31fec1990d5e679857f9625338c601", "patch": "@@ -165,9 +165,9 @@ impl Completions {\n         ctx: &CompletionContext<'_>,\n         path_ctx: &PathCompletionCtx,\n     ) {\n-        ctx.process_all_names(&mut |name, res| match res {\n+        ctx.process_all_names(&mut |name, res, doc_aliases| match res {\n             ScopeDef::ModuleDef(hir::ModuleDef::Module(m)) if m.is_crate_root(ctx.db) => {\n-                self.add_module(ctx, path_ctx, m, name);\n+                self.add_module(ctx, path_ctx, m, name, doc_aliases);\n             }\n             _ => (),\n         });\n@@ -179,6 +179,7 @@ impl Completions {\n         path_ctx: &PathCompletionCtx,\n         local_name: hir::Name,\n         resolution: hir::ScopeDef,\n+        doc_aliases: Vec<syntax::SmolStr>,\n     ) {\n         let is_private_editable = match ctx.def_is_visible(&resolution) {\n             Visible::Yes => false,\n@@ -187,7 +188,9 @@ impl Completions {\n         };\n         self.add(\n             render_path_resolution(\n-                RenderContext::new(ctx).private_editable(is_private_editable),\n+                RenderContext::new(ctx)\n+                    .private_editable(is_private_editable)\n+                    .doc_aliases(doc_aliases),\n                 path_ctx,\n                 local_name,\n                 resolution,\n@@ -236,12 +239,14 @@ impl Completions {\n         path_ctx: &PathCompletionCtx,\n         module: hir::Module,\n         local_name: hir::Name,\n+        doc_aliases: Vec<syntax::SmolStr>,\n     ) {\n         self.add_path_resolution(\n             ctx,\n             path_ctx,\n             local_name,\n             hir::ScopeDef::ModuleDef(module.into()),\n+            doc_aliases,\n         );\n     }\n "}, {"sha": "13c5832a519b17c8ee119bb62fdbb03d0c864120", "filename": "crates/ide-completion/src/completions/attribute.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/265f83031f31fec1990d5e679857f9625338c601/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fattribute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265f83031f31fec1990d5e679857f9625338c601/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fattribute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fattribute.rs?ref=265f83031f31fec1990d5e679857f9625338c601", "patch": "@@ -93,7 +93,7 @@ pub(crate) fn complete_attribute_path(\n                         acc.add_macro(ctx, path_ctx, m, name)\n                     }\n                     hir::ScopeDef::ModuleDef(hir::ModuleDef::Module(m)) => {\n-                        acc.add_module(ctx, path_ctx, m, name)\n+                        acc.add_module(ctx, path_ctx, m, name, vec![])\n                     }\n                     _ => (),\n                 }\n@@ -104,12 +104,12 @@ pub(crate) fn complete_attribute_path(\n         Qualified::Absolute => acc.add_crate_roots(ctx, path_ctx),\n         // only show modules in a fresh UseTree\n         Qualified::No => {\n-            ctx.process_all_names(&mut |name, def| match def {\n+            ctx.process_all_names(&mut |name, def, doc_aliases| match def {\n                 hir::ScopeDef::ModuleDef(hir::ModuleDef::Macro(m)) if m.is_attr(ctx.db) => {\n                     acc.add_macro(ctx, path_ctx, m, name)\n                 }\n                 hir::ScopeDef::ModuleDef(hir::ModuleDef::Module(m)) => {\n-                    acc.add_module(ctx, path_ctx, m, name)\n+                    acc.add_module(ctx, path_ctx, m, name, doc_aliases)\n                 }\n                 _ => (),\n             });"}, {"sha": "a92fe6c7bc1a2afbb00a8c1e31562db27b90a7d0", "filename": "crates/ide-completion/src/completions/attribute/derive.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/265f83031f31fec1990d5e679857f9625338c601/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fattribute%2Fderive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265f83031f31fec1990d5e679857f9625338c601/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fattribute%2Fderive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fattribute%2Fderive.rs?ref=265f83031f31fec1990d5e679857f9625338c601", "patch": "@@ -34,7 +34,7 @@ pub(crate) fn complete_derive_path(\n                         acc.add_macro(ctx, path_ctx, mac, name)\n                     }\n                     ScopeDef::ModuleDef(hir::ModuleDef::Module(m)) => {\n-                        acc.add_module(ctx, path_ctx, m, name)\n+                        acc.add_module(ctx, path_ctx, m, name, vec![])\n                     }\n                     _ => (),\n                 }\n@@ -43,15 +43,15 @@ pub(crate) fn complete_derive_path(\n         Qualified::Absolute => acc.add_crate_roots(ctx, path_ctx),\n         // only show modules in a fresh UseTree\n         Qualified::No => {\n-            ctx.process_all_names(&mut |name, def| {\n+            ctx.process_all_names(&mut |name, def, doc_aliases| {\n                 let mac = match def {\n                     ScopeDef::ModuleDef(hir::ModuleDef::Macro(mac))\n                         if !existing_derives.contains(&mac) && mac.is_derive(ctx.db) =>\n                     {\n                         mac\n                     }\n                     ScopeDef::ModuleDef(hir::ModuleDef::Module(m)) => {\n-                        return acc.add_module(ctx, path_ctx, m, name);\n+                        return acc.add_module(ctx, path_ctx, m, name, doc_aliases);\n                     }\n                     _ => return,\n                 };"}, {"sha": "70c91e6a10269c8ffa39158283391e6024152631", "filename": "crates/ide-completion/src/completions/expr.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/265f83031f31fec1990d5e679857f9625338c601/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265f83031f31fec1990d5e679857f9625338c601/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fexpr.rs?ref=265f83031f31fec1990d5e679857f9625338c601", "patch": "@@ -88,7 +88,7 @@ pub(crate) fn complete_expr_path(\n                     let module_scope = module.scope(ctx.db, Some(ctx.module));\n                     for (name, def) in module_scope {\n                         if scope_def_applicable(def) {\n-                            acc.add_path_resolution(ctx, path_ctx, name, def);\n+                            acc.add_path_resolution(ctx, path_ctx, name, def, vec![]);\n                         }\n                     }\n                 }\n@@ -212,20 +212,22 @@ pub(crate) fn complete_expr_path(\n                     }\n                 }\n             }\n-            ctx.process_all_names(&mut |name, def| match def {\n+            ctx.process_all_names(&mut |name, def, doc_aliases| match def {\n                 ScopeDef::ModuleDef(hir::ModuleDef::Trait(t)) => {\n                     let assocs = t.items_with_supertraits(ctx.db);\n                     match &*assocs {\n                         // traits with no assoc items are unusable as expressions since\n                         // there is no associated item path that can be constructed with them\n                         [] => (),\n                         // FIXME: Render the assoc item with the trait qualified\n-                        &[_item] => acc.add_path_resolution(ctx, path_ctx, name, def),\n+                        &[_item] => acc.add_path_resolution(ctx, path_ctx, name, def, doc_aliases),\n                         // FIXME: Append `::` to the thing here, since a trait on its own won't work\n-                        [..] => acc.add_path_resolution(ctx, path_ctx, name, def),\n+                        [..] => acc.add_path_resolution(ctx, path_ctx, name, def, doc_aliases),\n                     }\n                 }\n-                _ if scope_def_applicable(def) => acc.add_path_resolution(ctx, path_ctx, name, def),\n+                _ if scope_def_applicable(def) => {\n+                    acc.add_path_resolution(ctx, path_ctx, name, def, doc_aliases)\n+                }\n                 _ => (),\n             });\n "}, {"sha": "5ea6a49b1ae154587a4427a06d7d5feb81277740", "filename": "crates/ide-completion/src/completions/item_list.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/265f83031f31fec1990d5e679857f9625338c601/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fitem_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265f83031f31fec1990d5e679857f9625338c601/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fitem_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fitem_list.rs?ref=265f83031f31fec1990d5e679857f9625338c601", "patch": "@@ -45,7 +45,7 @@ pub(crate) fn complete_item_list(\n                         acc.add_macro(ctx, path_ctx, m, name)\n                     }\n                     hir::ScopeDef::ModuleDef(hir::ModuleDef::Module(m)) => {\n-                        acc.add_module(ctx, path_ctx, m, name)\n+                        acc.add_module(ctx, path_ctx, m, name, vec![])\n                     }\n                     _ => (),\n                 }\n@@ -55,12 +55,12 @@ pub(crate) fn complete_item_list(\n         }\n         Qualified::Absolute => acc.add_crate_roots(ctx, path_ctx),\n         Qualified::No if ctx.qualifier_ctx.none() => {\n-            ctx.process_all_names(&mut |name, def| match def {\n+            ctx.process_all_names(&mut |name, def, doc_aliases| match def {\n                 hir::ScopeDef::ModuleDef(hir::ModuleDef::Macro(m)) if m.is_fn_like(ctx.db) => {\n                     acc.add_macro(ctx, path_ctx, m, name)\n                 }\n                 hir::ScopeDef::ModuleDef(hir::ModuleDef::Module(m)) => {\n-                    acc.add_module(ctx, path_ctx, m, name)\n+                    acc.add_module(ctx, path_ctx, m, name, doc_aliases)\n                 }\n                 _ => (),\n             });"}, {"sha": "40b2c831a5d018b533c1e6699ab717d04de53b49", "filename": "crates/ide-completion/src/completions/pattern.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/265f83031f31fec1990d5e679857f9625338c601/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265f83031f31fec1990d5e679857f9625338c601/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fpattern.rs?ref=265f83031f31fec1990d5e679857f9625338c601", "patch": "@@ -64,7 +64,7 @@ pub(crate) fn complete_pattern(\n \n     // FIXME: ideally, we should look at the type we are matching against and\n     // suggest variants + auto-imports\n-    ctx.process_all_names(&mut |name, res| {\n+    ctx.process_all_names(&mut |name, res, _| {\n         let add_simple_path = match res {\n             hir::ScopeDef::ModuleDef(def) => match def {\n                 hir::ModuleDef::Adt(hir::Adt::Struct(strukt)) => {\n@@ -127,7 +127,7 @@ pub(crate) fn complete_pattern_path(\n                         };\n \n                         if add_resolution {\n-                            acc.add_path_resolution(ctx, path_ctx, name, def);\n+                            acc.add_path_resolution(ctx, path_ctx, name, def, vec![]);\n                         }\n                     }\n                 }\n@@ -164,7 +164,7 @@ pub(crate) fn complete_pattern_path(\n         Qualified::Absolute => acc.add_crate_roots(ctx, path_ctx),\n         Qualified::No => {\n             // this will only be hit if there are brackets or braces, otherwise this will be parsed as an ident pattern\n-            ctx.process_all_names(&mut |name, res| {\n+            ctx.process_all_names(&mut |name, res, doc_aliases| {\n                 // FIXME: we should check what kind of pattern we are in and filter accordingly\n                 let add_completion = match res {\n                     ScopeDef::ModuleDef(hir::ModuleDef::Macro(mac)) => mac.is_fn_like(ctx.db),\n@@ -175,7 +175,7 @@ pub(crate) fn complete_pattern_path(\n                     _ => false,\n                 };\n                 if add_completion {\n-                    acc.add_path_resolution(ctx, path_ctx, name, res);\n+                    acc.add_path_resolution(ctx, path_ctx, name, res, doc_aliases);\n                 }\n             });\n "}, {"sha": "2ad9520cd6edc501fbf2376ca351e46b956e556c", "filename": "crates/ide-completion/src/completions/type.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/265f83031f31fec1990d5e679857f9625338c601/crates%2Fide-completion%2Fsrc%2Fcompletions%2Ftype.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265f83031f31fec1990d5e679857f9625338c601/crates%2Fide-completion%2Fsrc%2Fcompletions%2Ftype.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Ftype.rs?ref=265f83031f31fec1990d5e679857f9625338c601", "patch": "@@ -85,7 +85,7 @@ pub(crate) fn complete_type_path(\n                     let module_scope = module.scope(ctx.db, Some(ctx.module));\n                     for (name, def) in module_scope {\n                         if scope_def_applicable(def) {\n-                            acc.add_path_resolution(ctx, path_ctx, name, def);\n+                            acc.add_path_resolution(ctx, path_ctx, name, def, vec![]);\n                         }\n                     }\n                 }\n@@ -141,7 +141,7 @@ pub(crate) fn complete_type_path(\n             match location {\n                 TypeLocation::TypeBound => {\n                     acc.add_nameref_keywords_with_colon(ctx);\n-                    ctx.process_all_names(&mut |name, res| {\n+                    ctx.process_all_names(&mut |name, res, doc_aliases| {\n                         let add_resolution = match res {\n                             ScopeDef::ModuleDef(hir::ModuleDef::Macro(mac)) => {\n                                 mac.is_fn_like(ctx.db)\n@@ -152,7 +152,7 @@ pub(crate) fn complete_type_path(\n                             _ => false,\n                         };\n                         if add_resolution {\n-                            acc.add_path_resolution(ctx, path_ctx, name, res);\n+                            acc.add_path_resolution(ctx, path_ctx, name, res, doc_aliases);\n                         }\n                     });\n                     return;\n@@ -215,9 +215,9 @@ pub(crate) fn complete_type_path(\n             };\n \n             acc.add_nameref_keywords_with_colon(ctx);\n-            ctx.process_all_names(&mut |name, def| {\n+            ctx.process_all_names(&mut |name, def, doc_aliases| {\n                 if scope_def_applicable(def) {\n-                    acc.add_path_resolution(ctx, path_ctx, name, def);\n+                    acc.add_path_resolution(ctx, path_ctx, name, def, doc_aliases);\n                 }\n             });\n         }"}, {"sha": "546a1f4c499cf27e13d3e83303dbd2d7304ebf1d", "filename": "crates/ide-completion/src/completions/use_.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/265f83031f31fec1990d5e679857f9625338c601/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fuse_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265f83031f31fec1990d5e679857f9625338c601/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fuse_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fuse_.rs?ref=265f83031f31fec1990d5e679857f9625338c601", "patch": "@@ -91,10 +91,10 @@ pub(crate) fn complete_use_path(\n         // only show modules and non-std enum in a fresh UseTree\n         Qualified::No => {\n             cov_mark::hit!(unqualified_path_selected_only);\n-            ctx.process_all_names(&mut |name, res| {\n+            ctx.process_all_names(&mut |name, res, doc_aliases| {\n                 match res {\n                     ScopeDef::ModuleDef(hir::ModuleDef::Module(module)) => {\n-                        acc.add_module(ctx, path_ctx, module, name);\n+                        acc.add_module(ctx, path_ctx, module, name, doc_aliases);\n                     }\n                     ScopeDef::ModuleDef(hir::ModuleDef::Adt(hir::Adt::Enum(e))) => {\n                         // exclude prelude enum"}, {"sha": "e0a959ad0b34058cd311fb479a79e5b513aa02d7", "filename": "crates/ide-completion/src/completions/vis.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/265f83031f31fec1990d5e679857f9625338c601/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fvis.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265f83031f31fec1990d5e679857f9625338c601/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fvis.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fvis.rs?ref=265f83031f31fec1990d5e679857f9625338c601", "patch": "@@ -23,7 +23,7 @@ pub(crate) fn complete_vis_path(\n             if let Some(next) = next_towards_current {\n                 if let Some(name) = next.name(ctx.db) {\n                     cov_mark::hit!(visibility_qualified);\n-                    acc.add_module(ctx, path_ctx, next, name);\n+                    acc.add_module(ctx, path_ctx, next, name, vec![]);\n                 }\n             }\n "}, {"sha": "f6478d2ceb27b50577b067e6cf7413669c862352", "filename": "crates/ide-completion/src/context.rs", "status": "modified", "additions": 15, "deletions": 6, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/265f83031f31fec1990d5e679857f9625338c601/crates%2Fide-completion%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265f83031f31fec1990d5e679857f9625338c601/crates%2Fide-completion%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcontext.rs?ref=265f83031f31fec1990d5e679857f9625338c601", "patch": "@@ -17,7 +17,7 @@ use ide_db::{\n };\n use syntax::{\n     ast::{self, AttrKind, NameOrNameRef},\n-    AstNode,\n+    AstNode, SmolStr,\n     SyntaxKind::{self, *},\n     SyntaxToken, TextRange, TextSize, T,\n };\n@@ -491,21 +491,22 @@ impl<'a> CompletionContext<'a> {\n         );\n     }\n \n-    /// A version of [`SemanticsScope::process_all_names`] that filters out `#[doc(hidden)]` items.\n-    pub(crate) fn process_all_names(&self, f: &mut dyn FnMut(Name, ScopeDef)) {\n+    /// A version of [`SemanticsScope::process_all_names`] that filters out `#[doc(hidden)]` items and\n+    /// passes all doc-aliases along, to funnel it into [`Completions::add_path_resolution`].\n+    pub(crate) fn process_all_names(&self, f: &mut dyn FnMut(Name, ScopeDef, Vec<SmolStr>)) {\n         let _p = profile::span(\"CompletionContext::process_all_names\");\n         self.scope.process_all_names(&mut |name, def| {\n             if self.is_scope_def_hidden(def) {\n                 return;\n             }\n-\n-            f(name, def);\n+            let doc_aliases = self.doc_aliases(def);\n+            f(name, def, doc_aliases);\n         });\n     }\n \n     pub(crate) fn process_all_names_raw(&self, f: &mut dyn FnMut(Name, ScopeDef)) {\n         let _p = profile::span(\"CompletionContext::process_all_names_raw\");\n-        self.scope.process_all_names(&mut |name, def| f(name, def));\n+        self.scope.process_all_names(f);\n     }\n \n     fn is_scope_def_hidden(&self, scope_def: ScopeDef) -> bool {\n@@ -545,6 +546,14 @@ impl<'a> CompletionContext<'a> {\n         // `doc(hidden)` items are only completed within the defining crate.\n         self.krate != defining_crate && attrs.has_doc_hidden()\n     }\n+\n+    fn doc_aliases(&self, scope_def: ScopeDef) -> Vec<SmolStr> {\n+        if let Some(attrs) = scope_def.attrs(self.db) {\n+            attrs.doc_aliases().collect()\n+        } else {\n+            vec![]\n+        }\n+    }\n }\n \n // CompletionContext construction"}, {"sha": "c2c4a663c61239acce406a91eb3427b048ee1e3c", "filename": "crates/ide-completion/src/item.rs", "status": "modified", "additions": 13, "deletions": 4, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/265f83031f31fec1990d5e679857f9625338c601/crates%2Fide-completion%2Fsrc%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265f83031f31fec1990d5e679857f9625338c601/crates%2Fide-completion%2Fsrc%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fitem.rs?ref=265f83031f31fec1990d5e679857f9625338c601", "patch": "@@ -45,7 +45,7 @@ pub struct CompletionItem {\n     ///\n     /// That is, in `foo.bar$0` lookup of `abracadabra` will be accepted (it\n     /// contains `bar` sub sequence), and `quux` will rejected.\n-    pub lookup: Option<SmolStr>,\n+    pub lookup: SmolStr,\n \n     /// Additional info to show in the UI pop up.\n     pub detail: Option<String>,\n@@ -353,12 +353,13 @@ impl CompletionItem {\n             relevance: CompletionRelevance::default(),\n             ref_match: None,\n             imports_to_add: Default::default(),\n+            doc_aliases: None,\n         }\n     }\n \n     /// What string is used for filtering.\n     pub fn lookup(&self) -> &str {\n-        self.lookup.as_deref().unwrap_or(&self.label)\n+        self.lookup.as_str()\n     }\n \n     pub fn ref_match(&self) -> Option<(String, text_edit::Indel, CompletionRelevance)> {\n@@ -385,6 +386,7 @@ pub(crate) struct Builder {\n     source_range: TextRange,\n     imports_to_add: SmallVec<[LocatedImport; 1]>,\n     trait_name: Option<SmolStr>,\n+    doc_aliases: Option<SmolStr>,\n     label: SmolStr,\n     insert_text: Option<String>,\n     is_snippet: bool,\n@@ -413,13 +415,16 @@ impl Builder {\n         let _p = profile::span(\"item::Builder::build\");\n \n         let mut label = self.label;\n-        let mut lookup = self.lookup;\n+        let mut lookup = self.lookup.unwrap_or_else(|| label.clone());\n         let insert_text = self.insert_text.unwrap_or_else(|| label.to_string());\n \n+        if let Some(doc_aliases) = self.doc_aliases {\n+            label = SmolStr::from(format!(\"{label} (alias {doc_aliases})\"));\n+            lookup = SmolStr::from(format!(\"{lookup} {doc_aliases}\"));\n+        }\n         if let [import_edit] = &*self.imports_to_add {\n             // snippets can have multiple imports, but normal completions only have up to one\n             if let Some(original_path) = import_edit.original_path.as_ref() {\n-                lookup = lookup.or_else(|| Some(label.clone()));\n                 label = SmolStr::from(format!(\"{label} (use {original_path})\"));\n             }\n         } else if let Some(trait_name) = self.trait_name {\n@@ -459,6 +464,10 @@ impl Builder {\n         self.trait_name = Some(trait_name);\n         self\n     }\n+    pub(crate) fn doc_aliases(&mut self, doc_aliases: SmolStr) -> &mut Builder {\n+        self.doc_aliases = Some(doc_aliases);\n+        self\n+    }\n     pub(crate) fn insert_text(&mut self, insert_text: impl Into<String>) -> &mut Builder {\n         self.insert_text = Some(insert_text.into());\n         self"}, {"sha": "a06b7e9577858323a3607fc33cb792bfa6213e51", "filename": "crates/ide-completion/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/265f83031f31fec1990d5e679857f9625338c601/crates%2Fide-completion%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265f83031f31fec1990d5e679857f9625338c601/crates%2Fide-completion%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Flib.rs?ref=265f83031f31fec1990d5e679857f9625338c601", "patch": "@@ -97,7 +97,7 @@ pub use crate::{\n \n /// Main entry point for completion. We run completion as a two-phase process.\n ///\n-/// First, we look at the position and collect a so-called `CompletionContext.\n+/// First, we look at the position and collect a so-called `CompletionContext`.\n /// This is a somewhat messy process, because, during completion, syntax tree is\n /// incomplete and can look really weird.\n ///"}, {"sha": "514a68472665aa5fc4ed89572309a75b6a4c495a", "filename": "crates/ide-completion/src/render.rs", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/265f83031f31fec1990d5e679857f9625338c601/crates%2Fide-completion%2Fsrc%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265f83031f31fec1990d5e679857f9625338c601/crates%2Fide-completion%2Fsrc%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Frender.rs?ref=265f83031f31fec1990d5e679857f9625338c601", "patch": "@@ -14,6 +14,7 @@ use hir::{AsAssocItem, HasAttrs, HirDisplay, ScopeDef};\n use ide_db::{\n     helpers::item_name, imports::import_assets::LocatedImport, RootDatabase, SnippetCap, SymbolKind,\n };\n+use itertools::Itertools;\n use syntax::{AstNode, SmolStr, SyntaxKind, TextRange};\n \n use crate::{\n@@ -32,11 +33,17 @@ pub(crate) struct RenderContext<'a> {\n     completion: &'a CompletionContext<'a>,\n     is_private_editable: bool,\n     import_to_add: Option<LocatedImport>,\n+    doc_aliases: Vec<SmolStr>,\n }\n \n impl<'a> RenderContext<'a> {\n     pub(crate) fn new(completion: &'a CompletionContext<'a>) -> RenderContext<'a> {\n-        RenderContext { completion, is_private_editable: false, import_to_add: None }\n+        RenderContext {\n+            completion,\n+            is_private_editable: false,\n+            import_to_add: None,\n+            doc_aliases: vec![],\n+        }\n     }\n \n     pub(crate) fn private_editable(mut self, private_editable: bool) -> Self {\n@@ -49,6 +56,11 @@ impl<'a> RenderContext<'a> {\n         self\n     }\n \n+    pub(crate) fn doc_aliases(mut self, doc_aliases: Vec<SmolStr>) -> Self {\n+        self.doc_aliases = doc_aliases;\n+        self\n+    }\n+\n     fn snippet_cap(&self) -> Option<SnippetCap> {\n         self.completion.config.snippet_cap\n     }\n@@ -348,6 +360,12 @@ fn render_resolution_simple_(\n     if let Some(import_to_add) = ctx.import_to_add {\n         item.add_import(import_to_add);\n     }\n+\n+    let doc_aliases = ctx.doc_aliases;\n+    if !doc_aliases.is_empty() {\n+        let doc_aliases = doc_aliases.into_iter().join(\", \").into();\n+        item.doc_aliases(doc_aliases);\n+    }\n     item\n }\n "}, {"sha": "1749e8e70f8105561cafb45e0e6536a01efeeda8", "filename": "crates/ide-completion/src/tests/special.rs", "status": "modified", "additions": 97, "deletions": 0, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/265f83031f31fec1990d5e679857f9625338c601/crates%2Fide-completion%2Fsrc%2Ftests%2Fspecial.rs", "raw_url": "https://github.com/rust-lang/rust/raw/265f83031f31fec1990d5e679857f9625338c601/crates%2Fide-completion%2Fsrc%2Ftests%2Fspecial.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Ftests%2Fspecial.rs?ref=265f83031f31fec1990d5e679857f9625338c601", "patch": "@@ -989,3 +989,100 @@ fn foo { crate::::$0 }\n         expect![\"\"],\n     )\n }\n+\n+#[test]\n+fn completes_struct_via_doc_alias_in_fn_body() {\n+    check(\n+        r#\"\n+#[doc(alias = \"Bar\")]\n+struct Foo;\n+\n+fn here_we_go() {\n+    $0\n+}\n+\"#,\n+        expect![[r#\"\n+            fn here_we_go()    fn()\n+            st Foo (alias Bar)\n+            bt u32\n+            kw const\n+            kw crate::\n+            kw enum\n+            kw extern\n+            kw false\n+            kw fn\n+            kw for\n+            kw if\n+            kw if let\n+            kw impl\n+            kw let\n+            kw loop\n+            kw match\n+            kw mod\n+            kw return\n+            kw self::\n+            kw static\n+            kw struct\n+            kw trait\n+            kw true\n+            kw type\n+            kw union\n+            kw unsafe\n+            kw use\n+            kw while\n+            kw while let\n+            sn macro_rules\n+            sn pd\n+            sn ppd\n+        \"#]],\n+    );\n+}\n+\n+#[test]\n+fn completes_struct_via_multiple_doc_aliases_in_fn_body() {\n+    check(\n+        r#\"\n+#[doc(alias(\"Bar\", \"Qux\"))]\n+#[doc(alias = \"Baz\")]\n+struct Foo;\n+\n+fn here_we_go() {\n+    B$0\n+}\n+\"#,\n+        expect![[r#\"\n+            fn here_we_go()           fn()\n+            st Foo (alias Bar, Qux, Baz)\n+            bt u32\n+            kw const\n+            kw crate::\n+            kw enum\n+            kw extern\n+            kw false\n+            kw fn\n+            kw for\n+            kw if\n+            kw if let\n+            kw impl\n+            kw let\n+            kw loop\n+            kw match\n+            kw mod\n+            kw return\n+            kw self::\n+            kw static\n+            kw struct\n+            kw trait\n+            kw true\n+            kw type\n+            kw union\n+            kw unsafe\n+            kw use\n+            kw while\n+            kw while let\n+            sn macro_rules\n+            sn pd\n+            sn ppd\n+        \"#]],\n+    );\n+}"}]}