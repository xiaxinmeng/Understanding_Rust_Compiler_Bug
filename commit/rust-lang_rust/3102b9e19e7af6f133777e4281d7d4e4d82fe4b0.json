{"sha": "3102b9e19e7af6f133777e4281d7d4e4d82fe4b0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMxMDJiOWUxOWU3YWY2ZjEzMzc3N2U0MjgxZDdkNGU0ZDgyZmU0YjA=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2014-12-26T08:55:16Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2015-01-21T14:27:26Z"}, "message": "rustdoc: fix fallout of merging ast::ViewItem into ast::Item.", "tree": {"sha": "507321a1e2190d3acbac0024eb3e07bcc48cacff", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/507321a1e2190d3acbac0024eb3e07bcc48cacff"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3102b9e19e7af6f133777e4281d7d4e4d82fe4b0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3102b9e19e7af6f133777e4281d7d4e4d82fe4b0", "html_url": "https://github.com/rust-lang/rust/commit/3102b9e19e7af6f133777e4281d7d4e4d82fe4b0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3102b9e19e7af6f133777e4281d7d4e4d82fe4b0/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f83a972224db1250513390589480be7e14c2a6c5", "url": "https://api.github.com/repos/rust-lang/rust/commits/f83a972224db1250513390589480be7e14c2a6c5", "html_url": "https://github.com/rust-lang/rust/commit/f83a972224db1250513390589480be7e14c2a6c5"}], "stats": {"total": 474, "additions": 224, "deletions": 250}, "files": [{"sha": "7cae1828ef624ec622a70fe8bb8716ae747a359d", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 78, "deletions": 111, "changes": 189, "blob_url": "https://github.com/rust-lang/rust/blob/3102b9e19e7af6f133777e4281d7d4e4d82fe4b0/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3102b9e19e7af6f133777e4281d7d4e4d82fe4b0/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=3102b9e19e7af6f133777e4281d7d4e4d82fe4b0", "patch": "@@ -18,8 +18,7 @@ pub use self::TypeKind::*;\n pub use self::StructField::*;\n pub use self::VariantKind::*;\n pub use self::Mutability::*;\n-pub use self::ViewItemInner::*;\n-pub use self::ViewPath::*;\n+pub use self::Import::*;\n pub use self::ItemEnum::*;\n pub use self::Attribute::*;\n pub use self::TyParamBound::*;\n@@ -309,6 +308,8 @@ impl Item {\n \n #[derive(Clone, RustcEncodable, RustcDecodable)]\n pub enum ItemEnum {\n+    ExternCrateItem(String, Option<String>),\n+    ImportItem(Import),\n     StructItem(Struct),\n     EnumItem(Enum),\n     FunctionItem(Function),\n@@ -318,8 +319,6 @@ pub enum ItemEnum {\n     ConstantItem(Constant),\n     TraitItem(Trait),\n     ImplItem(Impl),\n-    /// `use` and `extern crate`\n-    ViewItemItem(ViewItem),\n     /// A method signature only. Used for required methods in traits (ie,\n     /// non-default-methods).\n     TyMethodItem(TyMethod),\n@@ -349,27 +348,21 @@ impl Clean<Item> for doctree::Module {\n         } else {\n             \"\".to_string()\n         };\n-        let mut foreigns = Vec::new();\n-        for subforeigns in self.foreigns.clean(cx).into_iter() {\n-            for foreign in subforeigns.into_iter() {\n-                foreigns.push(foreign)\n-            }\n-        }\n-        let items: Vec<Vec<Item> > = vec!(\n-            self.structs.clean(cx),\n-            self.enums.clean(cx),\n-            self.fns.clean(cx),\n-            foreigns,\n-            self.mods.clean(cx),\n-            self.typedefs.clean(cx),\n-            self.statics.clean(cx),\n-            self.constants.clean(cx),\n-            self.traits.clean(cx),\n-            self.impls.clean(cx),\n-            self.view_items.clean(cx).into_iter()\n-                           .flat_map(|s| s.into_iter()).collect(),\n-            self.macros.clean(cx),\n-        );\n+        let items: Vec<Item> =\n+                   self.extern_crates.iter().map(|x| x.clean(cx))\n+            .chain(self.imports.iter().flat_map(|x| x.clean(cx).into_iter()))\n+            .chain(self.structs.iter().map(|x| x.clean(cx)))\n+            .chain(self.enums.iter().map(|x| x.clean(cx)))\n+            .chain(self.fns.iter().map(|x| x.clean(cx)))\n+            .chain(self.foreigns.iter().flat_map(|x| x.clean(cx).into_iter()))\n+            .chain(self.mods.iter().map(|x| x.clean(cx)))\n+            .chain(self.typedefs.iter().map(|x| x.clean(cx)))\n+            .chain(self.statics.iter().map(|x| x.clean(cx)))\n+            .chain(self.constants.iter().map(|x| x.clean(cx)))\n+            .chain(self.traits.iter().map(|x| x.clean(cx)))\n+            .chain(self.impls.iter().map(|x| x.clean(cx)))\n+            .chain(self.macros.iter().map(|x| x.clean(cx)))\n+            .collect();\n \n         // determine if we should display the inner contents or\n         // the outer `mod` item for the source code.\n@@ -395,9 +388,7 @@ impl Clean<Item> for doctree::Module {\n             def_id: ast_util::local_def(self.id),\n             inner: ModuleItem(Module {\n                is_crate: self.is_crate,\n-               items: items.iter()\n-                           .flat_map(|x| x.iter().map(|x| (*x).clone()))\n-                           .collect(),\n+               items: items\n             })\n         }\n     }\n@@ -2120,12 +2111,21 @@ impl Clean<Item> for doctree::Impl {\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable)]\n-pub struct ViewItem {\n-    pub inner: ViewItemInner,\n+impl Clean<Item> for doctree::ExternCrate {\n+    fn clean(&self, cx: &DocContext) -> Item {\n+        Item {\n+            name: None,\n+            attrs: self.attrs.clean(cx),\n+            source: self.whence.clean(cx),\n+            def_id: ast_util::local_def(0),\n+            visibility: self.vis.clean(cx),\n+            stability: None,\n+            inner: ExternCrateItem(self.name.clean(cx), self.path.clone())\n+        }\n+    }\n }\n \n-impl Clean<Vec<Item>> for ast::ViewItem {\n+impl Clean<Vec<Item>> for doctree::Import {\n     fn clean(&self, cx: &DocContext) -> Vec<Item> {\n         // We consider inlining the documentation of `pub use` statements, but we\n         // forcefully don't inline if this is not public or if the\n@@ -2136,81 +2136,63 @@ impl Clean<Vec<Item>> for ast::ViewItem {\n                 None => false,\n             }\n         });\n-        let convert = |&: node: &ast::ViewItem_| {\n-            Item {\n-                name: None,\n-                attrs: self.attrs.clean(cx),\n-                source: self.span.clean(cx),\n-                def_id: ast_util::local_def(0),\n-                visibility: self.vis.clean(cx),\n-                stability: None,\n-                inner: ViewItemItem(ViewItem { inner: node.clean(cx) }),\n+        let (mut ret, inner) = match self.node {\n+            ast::ViewPathGlob(ref p) => {\n+                (vec![], GlobImport(resolve_use_source(cx, p.clean(cx), self.id)))\n             }\n-        };\n-        let mut ret = Vec::new();\n-        match self.node {\n-            ast::ViewItemUse(ref path) if !denied => {\n-                match path.node {\n-                    ast::ViewPathGlob(..) => ret.push(convert(&self.node)),\n-                    ast::ViewPathList(ref a, ref list, ref b) => {\n-                        // Attempt to inline all reexported items, but be sure\n-                        // to keep any non-inlineable reexports so they can be\n-                        // listed in the documentation.\n-                        let remaining = list.iter().filter(|path| {\n-                            match inline::try_inline(cx, path.node.id(), None) {\n-                                Some(items) => {\n-                                    ret.extend(items.into_iter()); false\n-                                }\n-                                None => true,\n+            ast::ViewPathList(ref p, ref list) => {\n+                // Attempt to inline all reexported items, but be sure\n+                // to keep any non-inlineable reexports so they can be\n+                // listed in the documentation.\n+                let mut ret = vec![];\n+                let remaining = if !denied {\n+                    let mut remaining = vec![];\n+                    for path in list.iter() {\n+                        match inline::try_inline(cx, path.node.id(), None) {\n+                            Some(items) => {\n+                                ret.extend(items.into_iter());\n+                            }\n+                            None => {\n+                                remaining.push(path.clean(cx));\n                             }\n-                        }).map(|a| a.clone()).collect::<Vec<ast::PathListItem>>();\n-                        if remaining.len() > 0 {\n-                            let path = ast::ViewPathList(a.clone(),\n-                                                         remaining,\n-                                                         b.clone());\n-                            let path = syntax::codemap::dummy_spanned(path);\n-                            ret.push(convert(&ast::ViewItemUse(P(path))));\n-                        }\n-                    }\n-                    ast::ViewPathSimple(ident, _, id) => {\n-                        match inline::try_inline(cx, id, Some(ident)) {\n-                            Some(items) => ret.extend(items.into_iter()),\n-                            None => ret.push(convert(&self.node)),\n                         }\n                     }\n-                }\n-            }\n-            ref n => ret.push(convert(n)),\n-        }\n-        return ret;\n-    }\n-}\n-\n-#[derive(Clone, RustcEncodable, RustcDecodable)]\n-pub enum ViewItemInner {\n-    ExternCrate(String, Option<String>, ast::NodeId),\n-    Import(ViewPath)\n-}\n-\n-impl Clean<ViewItemInner> for ast::ViewItem_ {\n-    fn clean(&self, cx: &DocContext) -> ViewItemInner {\n-        match self {\n-            &ast::ViewItemExternCrate(ref i, ref p, ref id) => {\n-                let string = match *p {\n-                    None => None,\n-                    Some((ref x, _)) => Some(x.get().to_string()),\n+                    remaining\n+                } else {\n+                    list.clean(cx)\n                 };\n-                ExternCrate(i.clean(cx), string, *id)\n+                if remaining.is_empty() {\n+                    return ret;\n+                }\n+                (ret, ImportList(resolve_use_source(cx, p.clean(cx), self.id),\n+                                 remaining))\n             }\n-            &ast::ViewItemUse(ref vp) => {\n-                Import(vp.clean(cx))\n+            ast::ViewPathSimple(i, ref p) => {\n+                if !denied {\n+                    match inline::try_inline(cx, self.id, Some(i)) {\n+                        Some(items) => return items,\n+                        None => {}\n+                    }\n+                }\n+                (vec![], SimpleImport(i.clean(cx),\n+                                      resolve_use_source(cx, p.clean(cx), self.id)))\n             }\n-        }\n+        };\n+        ret.push(Item {\n+            name: None,\n+            attrs: self.attrs.clean(cx),\n+            source: self.whence.clean(cx),\n+            def_id: ast_util::local_def(0),\n+            visibility: self.vis.clean(cx),\n+            stability: None,\n+            inner: ImportItem(inner)\n+        });\n+        ret\n     }\n }\n \n #[derive(Clone, RustcEncodable, RustcDecodable)]\n-pub enum ViewPath {\n+pub enum Import {\n     // use source as str;\n     SimpleImport(String, ImportSource),\n     // use source::*;\n@@ -2225,21 +2207,6 @@ pub struct ImportSource {\n     pub did: Option<ast::DefId>,\n }\n \n-impl Clean<ViewPath> for ast::ViewPath {\n-    fn clean(&self, cx: &DocContext) -> ViewPath {\n-        match self.node {\n-            ast::ViewPathSimple(ref i, ref p, id) =>\n-                SimpleImport(i.clean(cx), resolve_use_source(cx, p.clean(cx), id)),\n-            ast::ViewPathGlob(ref p, id) =>\n-                GlobImport(resolve_use_source(cx, p.clean(cx), id)),\n-            ast::ViewPathList(ref p, ref pl, id) => {\n-                ImportList(resolve_use_source(cx, p.clean(cx), id),\n-                           pl.clean(cx))\n-            }\n-        }\n-    }\n-}\n-\n #[derive(Clone, RustcEncodable, RustcDecodable)]\n pub struct ViewListIdent {\n     pub name: String,"}, {"sha": "0e8ab594c20c1e2125f75f67c52f21657da7aa2e", "filename": "src/librustdoc/doctree.rs", "status": "modified", "additions": 20, "deletions": 2, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/3102b9e19e7af6f133777e4281d7d4e4d82fe4b0/src%2Flibrustdoc%2Fdoctree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3102b9e19e7af6f133777e4281d7d4e4d82fe4b0/src%2Flibrustdoc%2Fdoctree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdoctree.rs?ref=3102b9e19e7af6f133777e4281d7d4e4d82fe4b0", "patch": "@@ -25,6 +25,8 @@ pub struct Module {\n     pub attrs: Vec<ast::Attribute>,\n     pub where_outer: Span,\n     pub where_inner: Span,\n+    pub extern_crates: Vec<ExternCrate>,\n+    pub imports: Vec<Import>,\n     pub structs: Vec<Struct>,\n     pub enums: Vec<Enum>,\n     pub fns: Vec<Function>,\n@@ -38,7 +40,6 @@ pub struct Module {\n     pub stab: Option<attr::Stability>,\n     pub impls: Vec<Impl>,\n     pub foreigns: Vec<ast::ForeignMod>,\n-    pub view_items: Vec<ast::ViewItem>,\n     pub macros: Vec<Macro>,\n     pub is_crate: bool,\n }\n@@ -53,6 +54,8 @@ impl Module {\n             where_outer: syntax::codemap::DUMMY_SP,\n             where_inner: syntax::codemap::DUMMY_SP,\n             attrs      : Vec::new(),\n+            extern_crates: Vec::new(),\n+            imports    : Vec::new(),\n             structs    : Vec::new(),\n             enums      : Vec::new(),\n             fns        : Vec::new(),\n@@ -62,7 +65,6 @@ impl Module {\n             constants  : Vec::new(),\n             traits     : Vec::new(),\n             impls      : Vec::new(),\n-            view_items : Vec::new(),\n             foreigns   : Vec::new(),\n             macros     : Vec::new(),\n             is_crate   : false,\n@@ -202,6 +204,22 @@ pub struct Macro {\n     pub stab: Option<attr::Stability>,\n }\n \n+pub struct ExternCrate {\n+    pub name: Ident,\n+    pub path: Option<String>,\n+    pub vis: ast::Visibility,\n+    pub attrs: Vec<ast::Attribute>,\n+    pub whence: Span,\n+}\n+\n+pub struct Import {\n+    pub id: NodeId,\n+    pub vis: ast::Visibility,\n+    pub attrs: Vec<ast::Attribute>,\n+    pub node: ast::ViewPath_,\n+    pub whence: Span,\n+}\n+\n pub fn struct_type_from_def(sd: &ast::StructDef) -> StructType {\n     if sd.ctor_id.is_some() {\n         // We are in a tuple-struct"}, {"sha": "c8efa4c57bb31b889b0fd024412a859114d469d7", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3102b9e19e7af6f133777e4281d7d4e4d82fe4b0/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3102b9e19e7af6f133777e4281d7d4e4d82fe4b0/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=3102b9e19e7af6f133777e4281d7d4e4d82fe4b0", "patch": "@@ -617,7 +617,7 @@ impl fmt::String for UnsafetySpace {\n     }\n }\n \n-impl fmt::String for clean::ViewPath {\n+impl fmt::String for clean::Import {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match *self {\n             clean::SimpleImport(ref name, ref src) => {"}, {"sha": "ff7884a8616e409ef06b63bba3a5c038fed06db6", "filename": "src/librustdoc/html/item_type.rs", "status": "modified", "additions": 21, "deletions": 19, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/3102b9e19e7af6f133777e4281d7d4e4d82fe4b0/src%2Flibrustdoc%2Fhtml%2Fitem_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3102b9e19e7af6f133777e4281d7d4e4d82fe4b0/src%2Flibrustdoc%2Fhtml%2Fitem_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fitem_type.rs?ref=3102b9e19e7af6f133777e4281d7d4e4d82fe4b0", "patch": "@@ -22,29 +22,31 @@ use clean;\n #[derive(Copy, PartialEq, Clone)]\n pub enum ItemType {\n     Module          = 0,\n-    Struct          = 1,\n-    Enum            = 2,\n-    Function        = 3,\n-    Typedef         = 4,\n-    Static          = 5,\n-    Trait           = 6,\n-    Impl            = 7,\n-    ViewItem        = 8,\n-    TyMethod        = 9,\n-    Method          = 10,\n-    StructField     = 11,\n-    Variant         = 12,\n-    // we used to have ForeignFunction and ForeignStatic. they are retired now.\n-    Macro           = 15,\n-    Primitive       = 16,\n-    AssociatedType  = 17,\n-    Constant        = 18,\n+    ExternCrate     = 1,\n+    Import          = 2,\n+    Struct          = 3,\n+    Enum            = 4,\n+    Function        = 5,\n+    Typedef         = 6,\n+    Static          = 7,\n+    Trait           = 8,\n+    Impl            = 9,\n+    TyMethod        = 10,\n+    Method          = 11,\n+    StructField     = 12,\n+    Variant         = 13,\n+    Macro           = 14,\n+    Primitive       = 15,\n+    AssociatedType  = 16,\n+    Constant        = 17,\n }\n \n impl ItemType {\n     pub fn from_item(item: &clean::Item) -> ItemType {\n         match item.inner {\n             clean::ModuleItem(..)          => ItemType::Module,\n+            clean::ExternCrateItem(..)     => ItemType::ExternCrate,\n+            clean::ImportItem(..)          => ItemType::Import,\n             clean::StructItem(..)          => ItemType::Struct,\n             clean::EnumItem(..)            => ItemType::Enum,\n             clean::FunctionItem(..)        => ItemType::Function,\n@@ -53,7 +55,6 @@ impl ItemType {\n             clean::ConstantItem(..)        => ItemType::Constant,\n             clean::TraitItem(..)           => ItemType::Trait,\n             clean::ImplItem(..)            => ItemType::Impl,\n-            clean::ViewItemItem(..)        => ItemType::ViewItem,\n             clean::TyMethodItem(..)        => ItemType::TyMethod,\n             clean::MethodItem(..)          => ItemType::Method,\n             clean::StructFieldItem(..)     => ItemType::StructField,\n@@ -83,14 +84,15 @@ impl ItemType {\n     pub fn to_static_str(&self) -> &'static str {\n         match *self {\n             ItemType::Module          => \"mod\",\n+            ItemType::ExternCrate     => \"externcrate\",\n+            ItemType::Import          => \"import\",\n             ItemType::Struct          => \"struct\",\n             ItemType::Enum            => \"enum\",\n             ItemType::Function        => \"fn\",\n             ItemType::Typedef         => \"type\",\n             ItemType::Static          => \"static\",\n             ItemType::Trait           => \"trait\",\n             ItemType::Impl            => \"impl\",\n-            ItemType::ViewItem        => \"viewitem\",\n             ItemType::TyMethod        => \"tymethod\",\n             ItemType::Method          => \"method\",\n             ItemType::StructField     => \"structfield\","}, {"sha": "6242b5d89002c13adfedd8bec4556b716eab68cd", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 36, "deletions": 52, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/3102b9e19e7af6f133777e4281d7d4e4d82fe4b0/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3102b9e19e7af6f133777e4281d7d4e4d82fe4b0/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=3102b9e19e7af6f133777e4281d7d4e4d82fe4b0", "patch": "@@ -35,7 +35,7 @@\n pub use self::ExternalLocation::*;\n \n use std::cell::RefCell;\n-use std::cmp::Ordering::{self, Less, Greater, Equal};\n+use std::cmp::Ordering;\n use std::collections::{HashMap, HashSet};\n use std::default::Default;\n use std::fmt;\n@@ -1497,18 +1497,19 @@ fn item_module(w: &mut fmt::Formatter, cx: &Context,\n     // the order of item types in the listing\n     fn reorder(ty: ItemType) -> u8 {\n         match ty {\n-            ItemType::ViewItem        => 0,\n-            ItemType::Primitive       => 1,\n-            ItemType::Module          => 2,\n-            ItemType::Macro           => 3,\n-            ItemType::Struct          => 4,\n-            ItemType::Enum            => 5,\n-            ItemType::Constant        => 6,\n-            ItemType::Static          => 7,\n-            ItemType::Trait           => 8,\n-            ItemType::Function        => 9,\n-            ItemType::Typedef         => 10,\n-            _                         => 11 + ty as u8,\n+            ItemType::ExternCrate     => 0,\n+            ItemType::Import          => 1,\n+            ItemType::Primitive       => 2,\n+            ItemType::Module          => 3,\n+            ItemType::Macro           => 4,\n+            ItemType::Struct          => 5,\n+            ItemType::Enum            => 6,\n+            ItemType::Constant        => 7,\n+            ItemType::Static          => 8,\n+            ItemType::Trait           => 9,\n+            ItemType::Function        => 10,\n+            ItemType::Typedef         => 12,\n+            _                         => 13 + ty as u8,\n         }\n     }\n \n@@ -1518,25 +1519,7 @@ fn item_module(w: &mut fmt::Formatter, cx: &Context,\n         if ty1 == ty2 {\n             return i1.name.cmp(&i2.name);\n         }\n-\n-        let tycmp = reorder(ty1).cmp(&reorder(ty2));\n-        if let Equal = tycmp {\n-            // for reexports, `extern crate` takes precedence.\n-            match (&i1.inner, &i2.inner) {\n-                (&clean::ViewItemItem(ref a), &clean::ViewItemItem(ref b)) => {\n-                    match (&a.inner, &b.inner) {\n-                        (&clean::ExternCrate(..), _) => return Less,\n-                        (_, &clean::ExternCrate(..)) => return Greater,\n-                        _ => {}\n-                    }\n-                }\n-                (_, _) => {}\n-            }\n-\n-            idx1.cmp(&idx2)\n-        } else {\n-            tycmp\n-        }\n+        (reorder(ty1), idx1).cmp(&(reorder(ty2), idx2))\n     }\n \n     indices.sort_by(|&i1, &i2| cmp(&items[i1], &items[i2], i1, i2));\n@@ -1547,12 +1530,17 @@ fn item_module(w: &mut fmt::Formatter, cx: &Context,\n         let myitem = &items[idx];\n \n         let myty = Some(shortty(myitem));\n-        if myty != curty {\n+        if curty == Some(ItemType::ExternCrate) && myty == Some(ItemType::Import) {\n+            // Put `extern crate` and `use` re-exports in the same section.\n+            curty = myty;\n+        } else if myty != curty {\n             if curty.is_some() {\n                 try!(write!(w, \"</table>\"));\n             }\n             curty = myty;\n             let (short, name) = match myty.unwrap() {\n+                ItemType::ExternCrate |\n+                ItemType::Import          => (\"reexports\", \"Reexports\"),\n                 ItemType::Module          => (\"modules\", \"Modules\"),\n                 ItemType::Struct          => (\"structs\", \"Structs\"),\n                 ItemType::Enum            => (\"enums\", \"Enums\"),\n@@ -1562,7 +1550,6 @@ fn item_module(w: &mut fmt::Formatter, cx: &Context,\n                 ItemType::Constant        => (\"constants\", \"Constants\"),\n                 ItemType::Trait           => (\"traits\", \"Traits\"),\n                 ItemType::Impl            => (\"impls\", \"Implementations\"),\n-                ItemType::ViewItem        => (\"reexports\", \"Reexports\"),\n                 ItemType::TyMethod        => (\"tymethods\", \"Type Methods\"),\n                 ItemType::Method          => (\"methods\", \"Methods\"),\n                 ItemType::StructField     => (\"fields\", \"Struct Fields\"),\n@@ -1578,28 +1565,25 @@ fn item_module(w: &mut fmt::Formatter, cx: &Context,\n         }\n \n         match myitem.inner {\n-            clean::ViewItemItem(ref item) => {\n-                match item.inner {\n-                    clean::ExternCrate(ref name, ref src, _) => {\n-                        match *src {\n-                            Some(ref src) =>\n-                                try!(write!(w, \"<tr><td><code>extern crate \\\"{}\\\" as {}\",\n-                                            src.as_slice(),\n-                                            name.as_slice())),\n-                            None =>\n-                                try!(write!(w, \"<tr><td><code>extern crate {}\",\n-                                            name.as_slice())),\n-                        }\n-                        try!(write!(w, \";</code></td></tr>\"));\n+            clean::ExternCrateItem(ref name, ref src) => {\n+                match *src {\n+                    Some(ref src) => {\n+                        try!(write!(w, \"<tr><td><code>{}extern crate \\\"{}\\\" as {};\",\n+                                    VisSpace(myitem.visibility),\n+                                    src.as_slice(),\n+                                    name.as_slice()))\n                     }\n-\n-                    clean::Import(ref import) => {\n-                        try!(write!(w, \"<tr><td><code>{}{}</code></td></tr>\",\n-                                      VisSpace(myitem.visibility),\n-                                      *import));\n+                    None => {\n+                        try!(write!(w, \"<tr><td><code>{}extern crate {};\",\n+                                    VisSpace(myitem.visibility), name.as_slice()))\n                     }\n                 }\n+                try!(write!(w, \"</code></td></tr>\"));\n+            }\n \n+            clean::ImportItem(ref import) => {\n+                try!(write!(w, \"<tr><td><code>{}{}</code></td></tr>\",\n+                            VisSpace(myitem.visibility), *import));\n             }\n \n             _ => {"}, {"sha": "0914f93efd802b406a0f72cac14f4a174150d60b", "filename": "src/librustdoc/html/static/main.css", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3102b9e19e7af6f133777e4281d7d4e4d82fe4b0/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.css", "raw_url": "https://github.com/rust-lang/rust/raw/3102b9e19e7af6f133777e4281d7d4e4d82fe4b0/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.css?ref=3102b9e19e7af6f133777e4281d7d4e4d82fe4b0", "patch": "@@ -245,7 +245,6 @@ nav.sub {\n .content .highlighted.method { background-color: #c6afb3; }\n .content .highlighted.tymethod { background-color: #c6afb3; }\n .content .highlighted.type { background-color: #c6afb3; }\n-.content .highlighted.ffi { background-color: #c6afb3; }\n \n .docblock.short.nowrap {\n     display: block;\n@@ -365,7 +364,6 @@ p a:hover { text-decoration: underline; }\n .content span.fn, .content a.fn, .block a.current.fn { color: #8c6067; }\n .content span.method, .content a.method, .block a.current.method { color: #8c6067; }\n .content span.tymethod, .content a.tymethod, .block a.current.tymethod { color: #8c6067; }\n-.content span.ffi, .content a.ffi, .block a.current.ffi { color: #8c6067; }\n .content .fnname { color: #8c6067; }\n \n .search-input {"}, {"sha": "1b0c3b006409952eebf2ce0559d20ea8d77eb14d", "filename": "src/librustdoc/html/static/main.js", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3102b9e19e7af6f133777e4281d7d4e4d82fe4b0/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "raw_url": "https://github.com/rust-lang/rust/raw/3102b9e19e7af6f133777e4281d7d4e4d82fe4b0/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js?ref=3102b9e19e7af6f133777e4281d7d4e4d82fe4b0", "patch": "@@ -555,20 +555,19 @@\n         // This mapping table should match the discriminants of\n         // `rustdoc::html::item_type::ItemType` type in Rust.\n         var itemTypes = [\"mod\",\n+                         \"externcrate\",\n+                         \"import\",\n                          \"struct\",\n                          \"enum\",\n                          \"fn\",\n                          \"type\",\n                          \"static\",\n                          \"trait\",\n                          \"impl\",\n-                         \"viewitem\",\n                          \"tymethod\",\n                          \"method\",\n                          \"structfield\",\n                          \"variant\",\n-                         \"ffi\", // retained for backward compatibility\n-                         \"ffs\", // retained for backward compatibility\n                          \"macro\",\n                          \"primitive\",\n                          \"associatedtype\","}, {"sha": "0e60001e15ffdefcf15553fd3c32f0b5d4e653c3", "filename": "src/librustdoc/passes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3102b9e19e7af6f133777e4281d7d4e4d82fe4b0/src%2Flibrustdoc%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3102b9e19e7af6f133777e4281d7d4e4d82fe4b0/src%2Flibrustdoc%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses.rs?ref=3102b9e19e7af6f133777e4281d7d4e4d82fe4b0", "patch": "@@ -149,7 +149,7 @@ impl<'a> fold::DocFolder for Stripper<'a> {\n                 }\n             }\n \n-            clean::ViewItemItem(..) => {\n+            clean::ExternCrateItem(..) | clean::ImportItem(_) => {\n                 if i.visibility != Some(ast::Public) {\n                     return None\n                 }"}, {"sha": "943bc6ec9963445f76f23b0eccfea369d1e68852", "filename": "src/librustdoc/stability_summary.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3102b9e19e7af6f133777e4281d7d4e4d82fe4b0/src%2Flibrustdoc%2Fstability_summary.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3102b9e19e7af6f133777e4281d7d4e4d82fe4b0/src%2Flibrustdoc%2Fstability_summary.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fstability_summary.rs?ref=3102b9e19e7af6f133777e4281d7d4e4d82fe4b0", "patch": "@@ -21,7 +21,7 @@ use syntax::ast::Public;\n \n use clean::{Crate, Item, ModuleItem, Module, EnumItem, Enum};\n use clean::{ImplItem, Impl, Trait, TraitItem, TraitMethod, ProvidedMethod, RequiredMethod};\n-use clean::{TypeTraitItem, ViewItemItem, PrimitiveItem, Stability};\n+use clean::{TypeTraitItem, ExternCrateItem, ImportItem, PrimitiveItem, Stability};\n \n use html::render::cache;\n \n@@ -199,7 +199,8 @@ fn summarize_item(item: &Item) -> (Counts, Option<ModuleSummary>) {\n             }))\n         }\n         // no stability information for the following items:\n-        ViewItemItem(_) | PrimitiveItem(_) => (Counts::zero(), None),\n+        ExternCrateItem(..) | ImportItem(_) |\n+        PrimitiveItem(_) => (Counts::zero(), None),\n         _ => (item_counts, None)\n     }\n }"}, {"sha": "848205f589eda229e137e96d21ab2ade0edeafbc", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 62, "deletions": 57, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/3102b9e19e7af6f133777e4281d7d4e4d82fe4b0/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3102b9e19e7af6f133777e4281d7d4e4d82fe4b0/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=3102b9e19e7af6f133777e4281d7d4e4d82fe4b0", "patch": "@@ -20,7 +20,6 @@ use syntax::ast_map;\n use syntax::attr;\n use syntax::attr::AttrMetaMethods;\n use syntax::codemap::Span;\n-use syntax::ptr::P;\n \n use rustc::middle::stability;\n \n@@ -142,9 +141,6 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                               m: &ast::Mod,\n                               name: Option<ast::Ident>) -> Module {\n         let mut om = Module::new(name);\n-        for item in m.view_items.iter() {\n-            self.visit_view_item(item, &mut om);\n-        }\n         om.where_outer = span;\n         om.where_inner = m.inner;\n         om.attrs = attrs;\n@@ -157,68 +153,41 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n         om\n     }\n \n-    pub fn visit_view_item(&mut self, item: &ast::ViewItem, om: &mut Module) {\n-        if item.vis != ast::Public {\n-            return om.view_items.push(item.clone());\n-        }\n-        let please_inline = item.attrs.iter().any(|item| {\n-            match item.meta_item_list() {\n-                Some(list) => {\n-                    list.iter().any(|i| i.name().get() == \"inline\")\n-                }\n-                None => false,\n-            }\n-        });\n-        let item = match item.node {\n-            ast::ViewItemUse(ref vpath) => {\n-                match self.visit_view_path(&**vpath, om, please_inline) {\n-                    None => return,\n-                    Some(path) => {\n-                        ast::ViewItem {\n-                            node: ast::ViewItemUse(path),\n-                            .. item.clone()\n-                        }\n-                    }\n-                }\n-            }\n-            ast::ViewItemExternCrate(..) => item.clone()\n-        };\n-        om.view_items.push(item);\n-    }\n-\n-    fn visit_view_path(&mut self, path: &ast::ViewPath,\n+    fn visit_view_path(&mut self, path: ast::ViewPath_,\n                        om: &mut Module,\n-                       please_inline: bool) -> Option<P<ast::ViewPath>> {\n-        match path.node {\n-            ast::ViewPathSimple(dst, _, id) => {\n+                       id: ast::NodeId,\n+                       please_inline: bool) -> Option<ast::ViewPath_> {\n+        match path {\n+            ast::ViewPathSimple(dst, base) => {\n                 if self.resolve_id(id, Some(dst), false, om, please_inline) {\n-                    return None\n+                    None\n+                } else {\n+                    Some(ast::ViewPathSimple(dst, base))\n                 }\n             }\n-            ast::ViewPathList(ref p, ref paths, ref b) => {\n-                let mut mine = Vec::new();\n-                for path in paths.iter() {\n-                    if !self.resolve_id(path.node.id(), None, false, om,\n-                                        please_inline) {\n-                        mine.push(path.clone());\n-                    }\n-                }\n+            ast::ViewPathList(p, paths) => {\n+                let mine = paths.into_iter().filter(|path| {\n+                    !self.resolve_id(path.node.id(), None, false, om,\n+                                     please_inline)\n+                }).collect::<Vec<ast::PathListItem>>();\n \n-                if mine.len() == 0 { return None }\n-                return Some(P(::syntax::codemap::Spanned {\n-                    node: ast::ViewPathList(p.clone(), mine, b.clone()),\n-                    span: path.span,\n-                }))\n+                if mine.len() == 0 {\n+                    None\n+                } else {\n+                    Some(ast::ViewPathList(p, mine))\n+                }\n             }\n \n             // these are feature gated anyway\n-            ast::ViewPathGlob(_, id) => {\n+            ast::ViewPathGlob(base) => {\n                 if self.resolve_id(id, None, true, om, please_inline) {\n-                    return None\n+                    None\n+                } else {\n+                    Some(ast::ViewPathGlob(base))\n                 }\n             }\n         }\n-        Some(P(path.clone()))\n+\n     }\n \n     fn resolve_id(&mut self, id: ast::NodeId, renamed: Option<ast::Ident>,\n@@ -242,9 +211,6 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                 if glob {\n                     match it.node {\n                         ast::ItemMod(ref m) => {\n-                            for vi in m.view_items.iter() {\n-                                self.visit_view_item(vi, om);\n-                            }\n                             for i in m.items.iter() {\n                                 self.visit_item(&**i, None, om);\n                             }\n@@ -268,6 +234,45 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n         debug!(\"Visiting item {:?}\", item);\n         let name = renamed.unwrap_or(item.ident);\n         match item.node {\n+            ast::ItemExternCrate(ref p) => {\n+                let path = match *p {\n+                    None => None,\n+                    Some((ref x, _)) => Some(x.get().to_string()),\n+                };\n+                om.extern_crates.push(ExternCrate {\n+                    name: name,\n+                    path: path,\n+                    vis: item.vis,\n+                    attrs: item.attrs.clone(),\n+                    whence: item.span,\n+                })\n+            }\n+            ast::ItemUse(ref vpath) => {\n+                let node = vpath.node.clone();\n+                let node = if item.vis == ast::Public {\n+                    let please_inline = item.attrs.iter().any(|item| {\n+                        match item.meta_item_list() {\n+                            Some(list) => {\n+                                list.iter().any(|i| i.name().get() == \"inline\")\n+                            }\n+                            None => false,\n+                        }\n+                    });\n+                    match self.visit_view_path(node, om, item.id, please_inline) {\n+                        None => return,\n+                        Some(p) => p\n+                    }\n+                } else {\n+                    node\n+                };\n+                om.imports.push(Import {\n+                    id: item.id,\n+                    vis: item.vis,\n+                    attrs: item.attrs.clone(),\n+                    node: node,\n+                    whence: item.span,\n+                });\n+            }\n             ast::ItemMod(ref m) => {\n                 om.mods.push(self.visit_mod_contents(item.span,\n                                                      item.attrs.clone(),"}]}