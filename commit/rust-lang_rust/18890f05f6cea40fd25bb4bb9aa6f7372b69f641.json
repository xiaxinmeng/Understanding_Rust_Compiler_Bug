{"sha": "18890f05f6cea40fd25bb4bb9aa6f7372b69f641", "node_id": "C_kwDOAAsO6NoAKDE4ODkwZjA1ZjZjZWE0MGZkMjViYjRiYjlhYTZmNzM3MmI2OWY2NDE", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-01-27T06:10:19Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-01-27T06:10:19Z"}, "message": "Auto merge of #107343 - JohnTitor:rollup-s6l94aj, r=JohnTitor\n\nRollup of 8 pull requests\n\nSuccessful merges:\n\n - #105784 (update stdarch)\n - #106856 (core: Support variety of atomic widths in width-agnostic functions)\n - #107171 (rustc_metadata: Fix `encode_attrs`)\n - #107242 (rustdoc: make item links consistently use `title=\"{shortty} {path}\"`)\n - #107279 (Use new solver during selection)\n - #107284 (rustdoc: use smarter encoding for playground URL)\n - #107325 (rustdoc: Stop using `HirId`s)\n - #107336 (rustdoc: remove mostly-unused CSS classes `import-item` and `module-item`)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "d45a296aeadfe4e600b6af5d3362a50223166433", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d45a296aeadfe4e600b6af5d3362a50223166433"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/18890f05f6cea40fd25bb4bb9aa6f7372b69f641", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/18890f05f6cea40fd25bb4bb9aa6f7372b69f641", "html_url": "https://github.com/rust-lang/rust/commit/18890f05f6cea40fd25bb4bb9aa6f7372b69f641", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/18890f05f6cea40fd25bb4bb9aa6f7372b69f641/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "db137ba7d4415ac77e2b7601ef017ff2ca41b335", "url": "https://api.github.com/repos/rust-lang/rust/commits/db137ba7d4415ac77e2b7601ef017ff2ca41b335", "html_url": "https://github.com/rust-lang/rust/commit/db137ba7d4415ac77e2b7601ef017ff2ca41b335"}, {"sha": "17a2e1fef348bae5163abab16a7b649e642088b1", "url": "https://api.github.com/repos/rust-lang/rust/commits/17a2e1fef348bae5163abab16a7b649e642088b1", "html_url": "https://github.com/rust-lang/rust/commit/17a2e1fef348bae5163abab16a7b649e642088b1"}], "stats": {"total": 555, "additions": 302, "deletions": 253}, "files": [{"sha": "d57eaf92d0fc68e79feb68f043b356294d61c3c3", "filename": "compiler/rustc_metadata/src/rmeta/encoder.rs", "status": "modified", "additions": 48, "deletions": 29, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/18890f05f6cea40fd25bb4bb9aa6f7372b69f641/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18890f05f6cea40fd25bb4bb9aa6f7372b69f641/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs?ref=18890f05f6cea40fd25bb4bb9aa6f7372b69f641", "patch": "@@ -3,6 +3,7 @@ use crate::rmeta::def_path_hash_map::DefPathHashMapRef;\n use crate::rmeta::table::TableBuilder;\n use crate::rmeta::*;\n \n+use rustc_ast::util::comments;\n use rustc_ast::Attribute;\n use rustc_data_structures::fingerprint::Fingerprint;\n use rustc_data_structures::fx::{FxHashMap, FxIndexSet};\n@@ -759,36 +760,54 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n     }\n }\n \n+struct AnalyzeAttrState {\n+    is_exported: bool,\n+    may_have_doc_links: bool,\n+    is_doc_hidden: bool,\n+}\n+\n /// Returns whether an attribute needs to be recorded in metadata, that is, if it's usable and\n /// useful in downstream crates. Local-only attributes are an obvious example, but some\n /// rustdoc-specific attributes can equally be of use while documenting the current crate only.\n ///\n /// Removing these superfluous attributes speeds up compilation by making the metadata smaller.\n ///\n-/// Note: the `is_def_id_public` parameter is used to cache whether the given `DefId` has a public\n+/// Note: the `is_exported` parameter is used to cache whether the given `DefId` has a public\n /// visibility: this is a piece of data that can be computed once per defid, and not once per\n /// attribute. Some attributes would only be usable downstream if they are public.\n #[inline]\n-fn should_encode_attr(\n-    tcx: TyCtxt<'_>,\n-    attr: &Attribute,\n-    def_id: LocalDefId,\n-    is_def_id_public: &mut Option<bool>,\n-) -> bool {\n+fn analyze_attr(attr: &Attribute, state: &mut AnalyzeAttrState) -> bool {\n+    let mut should_encode = false;\n     if rustc_feature::is_builtin_only_local(attr.name_or_empty()) {\n         // Attributes marked local-only don't need to be encoded for downstream crates.\n-        false\n-    } else if attr.doc_str().is_some() {\n-        // We keep all public doc comments because they might be \"imported\" into downstream crates\n-        // if they use `#[doc(inline)]` to copy an item's documentation into their own.\n-        *is_def_id_public.get_or_insert_with(|| tcx.effective_visibilities(()).is_exported(def_id))\n+    } else if let Some(s) = attr.doc_str() {\n+        // We keep all doc comments reachable to rustdoc because they might be \"imported\" into\n+        // downstream crates if they use `#[doc(inline)]` to copy an item's documentation into\n+        // their own.\n+        if state.is_exported {\n+            should_encode = true;\n+            if comments::may_have_doc_links(s.as_str()) {\n+                state.may_have_doc_links = true;\n+            }\n+        }\n     } else if attr.has_name(sym::doc) {\n-        // If this is a `doc` attribute, and it's marked `inline` (as in `#[doc(inline)]`), we can\n-        // remove it. It won't be inlinable in downstream crates.\n-        attr.meta_item_list().map(|l| l.iter().any(|l| !l.has_name(sym::inline))).unwrap_or(false)\n+        // If this is a `doc` attribute that doesn't have anything except maybe `inline` (as in\n+        // `#[doc(inline)]`), then we can remove it. It won't be inlinable in downstream crates.\n+        if let Some(item_list) = attr.meta_item_list() {\n+            for item in item_list {\n+                if !item.has_name(sym::inline) {\n+                    should_encode = true;\n+                    if item.has_name(sym::hidden) {\n+                        state.is_doc_hidden = true;\n+                        break;\n+                    }\n+                }\n+            }\n+        }\n     } else {\n-        true\n+        should_encode = true;\n     }\n+    should_encode\n }\n \n fn should_encode_visibility(def_kind: DefKind) -> bool {\n@@ -1108,24 +1127,24 @@ fn should_encode_trait_impl_trait_tys(tcx: TyCtxt<'_>, def_id: DefId) -> bool {\n impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n     fn encode_attrs(&mut self, def_id: LocalDefId) {\n         let tcx = self.tcx;\n-        let mut is_public: Option<bool> = None;\n-\n-        let hir_attrs = tcx.hir().attrs(tcx.hir().local_def_id_to_hir_id(def_id));\n-        let mut attrs = hir_attrs\n+        let mut state = AnalyzeAttrState {\n+            is_exported: tcx.effective_visibilities(()).is_exported(def_id),\n+            may_have_doc_links: false,\n+            is_doc_hidden: false,\n+        };\n+        let attr_iter = tcx\n+            .hir()\n+            .attrs(tcx.hir().local_def_id_to_hir_id(def_id))\n             .iter()\n-            .filter(move |attr| should_encode_attr(tcx, attr, def_id, &mut is_public));\n+            .filter(|attr| analyze_attr(attr, &mut state));\n+\n+        record_array!(self.tables.attributes[def_id.to_def_id()] <- attr_iter);\n \n-        record_array!(self.tables.attributes[def_id.to_def_id()] <- attrs.clone());\n         let mut attr_flags = AttrFlags::empty();\n-        if attrs.any(|attr| attr.may_have_doc_links()) {\n+        if state.may_have_doc_links {\n             attr_flags |= AttrFlags::MAY_HAVE_DOC_LINKS;\n         }\n-        if hir_attrs\n-            .iter()\n-            .filter(|attr| attr.has_name(sym::doc))\n-            .filter_map(|attr| attr.meta_item_list())\n-            .any(|items| items.iter().any(|item| item.has_name(sym::hidden)))\n-        {\n+        if state.is_doc_hidden {\n             attr_flags |= AttrFlags::IS_DOC_HIDDEN;\n         }\n         if !attr_flags.is_empty() {"}, {"sha": "db95b8bca2f8ce78791f77dfd1cb801dd9151c50", "filename": "compiler/rustc_session/src/config.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/18890f05f6cea40fd25bb4bb9aa6f7372b69f641/compiler%2Frustc_session%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18890f05f6cea40fd25bb4bb9aa6f7372b69f641/compiler%2Frustc_session%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fconfig.rs?ref=18890f05f6cea40fd25bb4bb9aa6f7372b69f641", "patch": "@@ -945,6 +945,7 @@ fn default_configuration(sess: &Session) -> CrateConfig {\n     if sess.target.has_thread_local {\n         ret.insert((sym::target_thread_local, None));\n     }\n+    let mut has_atomic = false;\n     for (i, align) in [\n         (8, layout.i8_align.abi),\n         (16, layout.i16_align.abi),\n@@ -953,6 +954,7 @@ fn default_configuration(sess: &Session) -> CrateConfig {\n         (128, layout.i128_align.abi),\n     ] {\n         if i >= min_atomic_width && i <= max_atomic_width {\n+            has_atomic = true;\n             let mut insert_atomic = |s, align: Align| {\n                 ret.insert((sym::target_has_atomic_load_store, Some(Symbol::intern(s))));\n                 if atomic_cas {\n@@ -969,6 +971,12 @@ fn default_configuration(sess: &Session) -> CrateConfig {\n             }\n         }\n     }\n+    if sess.is_nightly_build() && has_atomic {\n+        ret.insert((sym::target_has_atomic_load_store, None));\n+        if atomic_cas {\n+            ret.insert((sym::target_has_atomic, None));\n+        }\n+    }\n \n     let panic_strategy = sess.panic_strategy();\n     ret.insert((sym::panic, Some(panic_strategy.desc_symbol())));"}, {"sha": "1d23634b6aacf58762466cd987d387d2ea743525", "filename": "compiler/rustc_trait_selection/src/traits/select/mod.rs", "status": "modified", "additions": 43, "deletions": 14, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/18890f05f6cea40fd25bb4bb9aa6f7372b69f641/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18890f05f6cea40fd25bb4bb9aa6f7372b69f641/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs?ref=18890f05f6cea40fd25bb4bb9aa6f7372b69f641", "patch": "@@ -38,6 +38,8 @@ use rustc_errors::Diagnostic;\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n use rustc_infer::infer::LateBoundRegionConversionTime;\n+use rustc_infer::traits::TraitEngine;\n+use rustc_infer::traits::TraitEngineExt;\n use rustc_middle::dep_graph::{DepKind, DepNodeIndex};\n use rustc_middle::mir::interpret::ErrorHandled;\n use rustc_middle::ty::abstract_const::NotConstEvaluatable;\n@@ -47,6 +49,7 @@ use rustc_middle::ty::relate::TypeRelation;\n use rustc_middle::ty::SubstsRef;\n use rustc_middle::ty::{self, EarlyBinder, PolyProjectionPredicate, ToPolyTraitRef, ToPredicate};\n use rustc_middle::ty::{Ty, TyCtxt, TypeFoldable, TypeVisitable};\n+use rustc_session::config::TraitSolver;\n use rustc_span::symbol::sym;\n \n use std::cell::{Cell, RefCell};\n@@ -544,10 +547,14 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         obligation: &PredicateObligation<'tcx>,\n     ) -> Result<EvaluationResult, OverflowError> {\n         self.evaluation_probe(|this| {\n-            this.evaluate_predicate_recursively(\n-                TraitObligationStackList::empty(&ProvisionalEvaluationCache::default()),\n-                obligation.clone(),\n-            )\n+            if this.tcx().sess.opts.unstable_opts.trait_solver != TraitSolver::Next {\n+                this.evaluate_predicate_recursively(\n+                    TraitObligationStackList::empty(&ProvisionalEvaluationCache::default()),\n+                    obligation.clone(),\n+                )\n+            } else {\n+                this.evaluate_predicates_recursively_in_new_solver([obligation.clone()])\n+            }\n         })\n     }\n \n@@ -586,18 +593,40 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     where\n         I: IntoIterator<Item = PredicateObligation<'tcx>> + std::fmt::Debug,\n     {\n-        let mut result = EvaluatedToOk;\n-        for obligation in predicates {\n-            let eval = self.evaluate_predicate_recursively(stack, obligation.clone())?;\n-            if let EvaluatedToErr = eval {\n-                // fast-path - EvaluatedToErr is the top of the lattice,\n-                // so we don't need to look on the other predicates.\n-                return Ok(EvaluatedToErr);\n-            } else {\n-                result = cmp::max(result, eval);\n+        if self.tcx().sess.opts.unstable_opts.trait_solver != TraitSolver::Next {\n+            let mut result = EvaluatedToOk;\n+            for obligation in predicates {\n+                let eval = self.evaluate_predicate_recursively(stack, obligation.clone())?;\n+                if let EvaluatedToErr = eval {\n+                    // fast-path - EvaluatedToErr is the top of the lattice,\n+                    // so we don't need to look on the other predicates.\n+                    return Ok(EvaluatedToErr);\n+                } else {\n+                    result = cmp::max(result, eval);\n+                }\n             }\n+            Ok(result)\n+        } else {\n+            self.evaluate_predicates_recursively_in_new_solver(predicates)\n         }\n-        Ok(result)\n+    }\n+\n+    /// Evaluates the predicates using the new solver when `-Ztrait-solver=next` is enabled\n+    fn evaluate_predicates_recursively_in_new_solver(\n+        &mut self,\n+        predicates: impl IntoIterator<Item = PredicateObligation<'tcx>>,\n+    ) -> Result<EvaluationResult, OverflowError> {\n+        let mut fulfill_cx = crate::solve::FulfillmentCtxt::new();\n+        fulfill_cx.register_predicate_obligations(self.infcx, predicates);\n+        // True errors\n+        if !fulfill_cx.select_where_possible(self.infcx).is_empty() {\n+            return Ok(EvaluatedToErr);\n+        }\n+        if !fulfill_cx.select_all_or_error(self.infcx).is_empty() {\n+            return Ok(EvaluatedToAmbig);\n+        }\n+        // Regions and opaques are handled in the `evaluation_probe` by looking at the snapshot\n+        Ok(EvaluatedToOk)\n     }\n \n     #[instrument("}, {"sha": "818721062d7f702aeba8df4096d55fbc6456427e", "filename": "library/core/src/sync/atomic.rs", "status": "modified", "additions": 30, "deletions": 15, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/18890f05f6cea40fd25bb4bb9aa6f7372b69f641/library%2Fcore%2Fsrc%2Fsync%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18890f05f6cea40fd25bb4bb9aa6f7372b69f641/library%2Fcore%2Fsrc%2Fsync%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fsync%2Fatomic.rs?ref=18890f05f6cea40fd25bb4bb9aa6f7372b69f641", "patch": "@@ -1861,7 +1861,8 @@ macro_rules! if_not_8_bit {\n     ($_:ident, $($tt:tt)*) => { $($tt)* };\n }\n \n-#[cfg(target_has_atomic_load_store = \"8\")]\n+#[cfg_attr(not(bootstrap), cfg(target_has_atomic_load_store))]\n+#[cfg_attr(bootstrap, cfg(target_has_atomic_load_store = \"8\"))]\n macro_rules! atomic_int {\n     ($cfg_cas:meta,\n      $cfg_align:meta,\n@@ -2988,7 +2989,8 @@ atomic_int_ptr_sized! {\n }\n \n #[inline]\n-#[cfg(target_has_atomic = \"8\")]\n+#[cfg_attr(not(bootstrap), cfg(target_has_atomic))]\n+#[cfg_attr(bootstrap, cfg(target_has_atomic = \"8\"))]\n fn strongest_failure_ordering(order: Ordering) -> Ordering {\n     match order {\n         Release => Relaxed,\n@@ -3030,7 +3032,8 @@ unsafe fn atomic_load<T: Copy>(dst: *const T, order: Ordering) -> T {\n }\n \n #[inline]\n-#[cfg(target_has_atomic = \"8\")]\n+#[cfg_attr(not(bootstrap), cfg(target_has_atomic))]\n+#[cfg_attr(bootstrap, cfg(target_has_atomic = \"8\"))]\n #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n unsafe fn atomic_swap<T: Copy>(dst: *mut T, val: T, order: Ordering) -> T {\n     // SAFETY: the caller must uphold the safety contract for `atomic_swap`.\n@@ -3047,7 +3050,8 @@ unsafe fn atomic_swap<T: Copy>(dst: *mut T, val: T, order: Ordering) -> T {\n \n /// Returns the previous value (like __sync_fetch_and_add).\n #[inline]\n-#[cfg(target_has_atomic = \"8\")]\n+#[cfg_attr(not(bootstrap), cfg(target_has_atomic))]\n+#[cfg_attr(bootstrap, cfg(target_has_atomic = \"8\"))]\n #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n unsafe fn atomic_add<T: Copy>(dst: *mut T, val: T, order: Ordering) -> T {\n     // SAFETY: the caller must uphold the safety contract for `atomic_add`.\n@@ -3064,7 +3068,8 @@ unsafe fn atomic_add<T: Copy>(dst: *mut T, val: T, order: Ordering) -> T {\n \n /// Returns the previous value (like __sync_fetch_and_sub).\n #[inline]\n-#[cfg(target_has_atomic = \"8\")]\n+#[cfg_attr(not(bootstrap), cfg(target_has_atomic))]\n+#[cfg_attr(bootstrap, cfg(target_has_atomic = \"8\"))]\n #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n unsafe fn atomic_sub<T: Copy>(dst: *mut T, val: T, order: Ordering) -> T {\n     // SAFETY: the caller must uphold the safety contract for `atomic_sub`.\n@@ -3080,7 +3085,8 @@ unsafe fn atomic_sub<T: Copy>(dst: *mut T, val: T, order: Ordering) -> T {\n }\n \n #[inline]\n-#[cfg(target_has_atomic = \"8\")]\n+#[cfg_attr(not(bootstrap), cfg(target_has_atomic))]\n+#[cfg_attr(bootstrap, cfg(target_has_atomic = \"8\"))]\n #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n unsafe fn atomic_compare_exchange<T: Copy>(\n     dst: *mut T,\n@@ -3115,7 +3121,8 @@ unsafe fn atomic_compare_exchange<T: Copy>(\n }\n \n #[inline]\n-#[cfg(target_has_atomic = \"8\")]\n+#[cfg_attr(not(bootstrap), cfg(target_has_atomic))]\n+#[cfg_attr(bootstrap, cfg(target_has_atomic = \"8\"))]\n #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n unsafe fn atomic_compare_exchange_weak<T: Copy>(\n     dst: *mut T,\n@@ -3150,7 +3157,8 @@ unsafe fn atomic_compare_exchange_weak<T: Copy>(\n }\n \n #[inline]\n-#[cfg(target_has_atomic = \"8\")]\n+#[cfg_attr(not(bootstrap), cfg(target_has_atomic))]\n+#[cfg_attr(bootstrap, cfg(target_has_atomic = \"8\"))]\n #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n unsafe fn atomic_and<T: Copy>(dst: *mut T, val: T, order: Ordering) -> T {\n     // SAFETY: the caller must uphold the safety contract for `atomic_and`\n@@ -3166,7 +3174,8 @@ unsafe fn atomic_and<T: Copy>(dst: *mut T, val: T, order: Ordering) -> T {\n }\n \n #[inline]\n-#[cfg(target_has_atomic = \"8\")]\n+#[cfg_attr(not(bootstrap), cfg(target_has_atomic))]\n+#[cfg_attr(bootstrap, cfg(target_has_atomic = \"8\"))]\n #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n unsafe fn atomic_nand<T: Copy>(dst: *mut T, val: T, order: Ordering) -> T {\n     // SAFETY: the caller must uphold the safety contract for `atomic_nand`\n@@ -3182,7 +3191,8 @@ unsafe fn atomic_nand<T: Copy>(dst: *mut T, val: T, order: Ordering) -> T {\n }\n \n #[inline]\n-#[cfg(target_has_atomic = \"8\")]\n+#[cfg_attr(not(bootstrap), cfg(target_has_atomic))]\n+#[cfg_attr(bootstrap, cfg(target_has_atomic = \"8\"))]\n #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n unsafe fn atomic_or<T: Copy>(dst: *mut T, val: T, order: Ordering) -> T {\n     // SAFETY: the caller must uphold the safety contract for `atomic_or`\n@@ -3198,7 +3208,8 @@ unsafe fn atomic_or<T: Copy>(dst: *mut T, val: T, order: Ordering) -> T {\n }\n \n #[inline]\n-#[cfg(target_has_atomic = \"8\")]\n+#[cfg_attr(not(bootstrap), cfg(target_has_atomic))]\n+#[cfg_attr(bootstrap, cfg(target_has_atomic = \"8\"))]\n #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n unsafe fn atomic_xor<T: Copy>(dst: *mut T, val: T, order: Ordering) -> T {\n     // SAFETY: the caller must uphold the safety contract for `atomic_xor`\n@@ -3215,7 +3226,8 @@ unsafe fn atomic_xor<T: Copy>(dst: *mut T, val: T, order: Ordering) -> T {\n \n /// returns the max value (signed comparison)\n #[inline]\n-#[cfg(target_has_atomic = \"8\")]\n+#[cfg_attr(not(bootstrap), cfg(target_has_atomic))]\n+#[cfg_attr(bootstrap, cfg(target_has_atomic = \"8\"))]\n #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n unsafe fn atomic_max<T: Copy>(dst: *mut T, val: T, order: Ordering) -> T {\n     // SAFETY: the caller must uphold the safety contract for `atomic_max`\n@@ -3232,7 +3244,8 @@ unsafe fn atomic_max<T: Copy>(dst: *mut T, val: T, order: Ordering) -> T {\n \n /// returns the min value (signed comparison)\n #[inline]\n-#[cfg(target_has_atomic = \"8\")]\n+#[cfg_attr(not(bootstrap), cfg(target_has_atomic))]\n+#[cfg_attr(bootstrap, cfg(target_has_atomic = \"8\"))]\n #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n unsafe fn atomic_min<T: Copy>(dst: *mut T, val: T, order: Ordering) -> T {\n     // SAFETY: the caller must uphold the safety contract for `atomic_min`\n@@ -3249,7 +3262,8 @@ unsafe fn atomic_min<T: Copy>(dst: *mut T, val: T, order: Ordering) -> T {\n \n /// returns the max value (unsigned comparison)\n #[inline]\n-#[cfg(target_has_atomic = \"8\")]\n+#[cfg_attr(not(bootstrap), cfg(target_has_atomic))]\n+#[cfg_attr(bootstrap, cfg(target_has_atomic = \"8\"))]\n #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n unsafe fn atomic_umax<T: Copy>(dst: *mut T, val: T, order: Ordering) -> T {\n     // SAFETY: the caller must uphold the safety contract for `atomic_umax`\n@@ -3266,7 +3280,8 @@ unsafe fn atomic_umax<T: Copy>(dst: *mut T, val: T, order: Ordering) -> T {\n \n /// returns the min value (unsigned comparison)\n #[inline]\n-#[cfg(target_has_atomic = \"8\")]\n+#[cfg_attr(not(bootstrap), cfg(target_has_atomic))]\n+#[cfg_attr(bootstrap, cfg(target_has_atomic = \"8\"))]\n #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n unsafe fn atomic_umin<T: Copy>(dst: *mut T, val: T, order: Ordering) -> T {\n     // SAFETY: the caller must uphold the safety contract for `atomic_umin`"}, {"sha": "bf3c81fcc980b95968583fe33b0ccdaebe0a3b48", "filename": "library/std/tests/run-time-detect.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/18890f05f6cea40fd25bb4bb9aa6f7372b69f641/library%2Fstd%2Ftests%2Frun-time-detect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18890f05f6cea40fd25bb4bb9aa6f7372b69f641/library%2Fstd%2Ftests%2Frun-time-detect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Ftests%2Frun-time-detect.rs?ref=18890f05f6cea40fd25bb4bb9aa6f7372b69f641", "patch": "@@ -120,16 +120,13 @@ fn x86_all() {\n     println!(\"avx512dq: {:?}\", is_x86_feature_detected!(\"avx512dq\"));\n     println!(\"avx512er: {:?}\", is_x86_feature_detected!(\"avx512er\"));\n     println!(\"avx512f: {:?}\", is_x86_feature_detected!(\"avx512f\"));\n-    println!(\"avx512gfni: {:?}\", is_x86_feature_detected!(\"avx512gfni\"));\n     println!(\"avx512ifma: {:?}\", is_x86_feature_detected!(\"avx512ifma\"));\n     println!(\"avx512pf: {:?}\", is_x86_feature_detected!(\"avx512pf\"));\n-    println!(\"avx512vaes: {:?}\", is_x86_feature_detected!(\"avx512vaes\"));\n     println!(\"avx512vbmi2: {:?}\", is_x86_feature_detected!(\"avx512vbmi2\"));\n     println!(\"avx512vbmi: {:?}\", is_x86_feature_detected!(\"avx512vbmi\"));\n     println!(\"avx512vl: {:?}\", is_x86_feature_detected!(\"avx512vl\"));\n     println!(\"avx512vnni: {:?}\", is_x86_feature_detected!(\"avx512vnni\"));\n     println!(\"avx512vp2intersect: {:?}\", is_x86_feature_detected!(\"avx512vp2intersect\"));\n-    println!(\"avx512vpclmulqdq: {:?}\", is_x86_feature_detected!(\"avx512vpclmulqdq\"));\n     println!(\"avx512vpopcntdq: {:?}\", is_x86_feature_detected!(\"avx512vpopcntdq\"));\n     println!(\"avx: {:?}\", is_x86_feature_detected!(\"avx\"));\n     println!(\"bmi1: {:?}\", is_x86_feature_detected!(\"bmi1\"));\n@@ -138,6 +135,7 @@ fn x86_all() {\n     println!(\"f16c: {:?}\", is_x86_feature_detected!(\"f16c\"));\n     println!(\"fma: {:?}\", is_x86_feature_detected!(\"fma\"));\n     println!(\"fxsr: {:?}\", is_x86_feature_detected!(\"fxsr\"));\n+    println!(\"gfni: {:?}\", is_x86_feature_detected!(\"gfni\"));\n     println!(\"lzcnt: {:?}\", is_x86_feature_detected!(\"lzcnt\"));\n     //println!(\"movbe: {:?}\", is_x86_feature_detected!(\"movbe\")); // movbe is unsupported as a target feature\n     println!(\"pclmulqdq: {:?}\", is_x86_feature_detected!(\"pclmulqdq\"));\n@@ -154,6 +152,8 @@ fn x86_all() {\n     println!(\"sse: {:?}\", is_x86_feature_detected!(\"sse\"));\n     println!(\"ssse3: {:?}\", is_x86_feature_detected!(\"ssse3\"));\n     println!(\"tbm: {:?}\", is_x86_feature_detected!(\"tbm\"));\n+    println!(\"vaes: {:?}\", is_x86_feature_detected!(\"vaes\"));\n+    println!(\"vpclmulqdq: {:?}\", is_x86_feature_detected!(\"vpclmulqdq\"));\n     println!(\"xsave: {:?}\", is_x86_feature_detected!(\"xsave\"));\n     println!(\"xsavec: {:?}\", is_x86_feature_detected!(\"xsavec\"));\n     println!(\"xsaveopt: {:?}\", is_x86_feature_detected!(\"xsaveopt\"));"}, {"sha": "a0c30f3e3c75adcd6ee7efc94014ebcead61c507", "filename": "library/stdarch", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstdarch?ref=18890f05f6cea40fd25bb4bb9aa6f7372b69f641", "patch": "@@ -1 +1 @@\n-Subproject commit 790411f93c4b5eada3c23abb4c9a063fb0b24d99\n+Subproject commit a0c30f3e3c75adcd6ee7efc94014ebcead61c507"}, {"sha": "3cb6ad10e72b8e43cad38a6cb60e2427f6fa03b4", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/18890f05f6cea40fd25bb4bb9aa6f7372b69f641/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18890f05f6cea40fd25bb4bb9aa6f7372b69f641/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=18890f05f6cea40fd25bb4bb9aa6f7372b69f641", "patch": "@@ -15,7 +15,7 @@ use rustc_attr as attr;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet, FxIndexMap, FxIndexSet, IndexEntry};\n use rustc_hir as hir;\n use rustc_hir::def::{CtorKind, DefKind, Res};\n-use rustc_hir::def_id::{DefId, DefIdMap, DefIdSet, LOCAL_CRATE};\n+use rustc_hir::def_id::{DefId, DefIdMap, DefIdSet, LocalDefId, LOCAL_CRATE};\n use rustc_hir::PredicateOrigin;\n use rustc_hir_analysis::hir_ty_to_ty;\n use rustc_infer::infer::region_constraints::{Constraint, RegionConstraintData};\n@@ -116,7 +116,8 @@ pub(crate) fn clean_doc_module<'tcx>(doc: &DocModule<'tcx>, cx: &mut DocContext<\n         }\n     });\n \n-    Item::from_hir_id_and_parts(doc.id, Some(doc.name), ModuleItem(Module { items, span }), cx)\n+    let kind = ModuleItem(Module { items, span });\n+    Item::from_def_id_and_parts(doc.def_id.to_def_id(), Some(doc.name), kind, cx)\n }\n \n fn clean_generic_bound<'tcx>(\n@@ -2067,12 +2068,12 @@ struct OneLevelVisitor<'hir> {\n     map: rustc_middle::hir::map::Map<'hir>,\n     item: Option<&'hir hir::Item<'hir>>,\n     looking_for: Ident,\n-    target_hir_id: hir::HirId,\n+    target_def_id: LocalDefId,\n }\n \n impl<'hir> OneLevelVisitor<'hir> {\n-    fn new(map: rustc_middle::hir::map::Map<'hir>, target_hir_id: hir::HirId) -> Self {\n-        Self { map, item: None, looking_for: Ident::empty(), target_hir_id }\n+    fn new(map: rustc_middle::hir::map::Map<'hir>, target_def_id: LocalDefId) -> Self {\n+        Self { map, item: None, looking_for: Ident::empty(), target_def_id }\n     }\n \n     fn reset(&mut self, looking_for: Ident) {\n@@ -2092,7 +2093,7 @@ impl<'hir> hir::intravisit::Visitor<'hir> for OneLevelVisitor<'hir> {\n         if self.item.is_none()\n             && item.ident == self.looking_for\n             && matches!(item.kind, hir::ItemKind::Use(_, _))\n-            || item.hir_id() == self.target_hir_id\n+            || item.owner_id.def_id == self.target_def_id\n         {\n             self.item = Some(item);\n         }\n@@ -2106,11 +2107,11 @@ impl<'hir> hir::intravisit::Visitor<'hir> for OneLevelVisitor<'hir> {\n fn get_all_import_attributes<'hir>(\n     mut item: &hir::Item<'hir>,\n     tcx: TyCtxt<'hir>,\n-    target_hir_id: hir::HirId,\n+    target_def_id: LocalDefId,\n     attributes: &mut Vec<ast::Attribute>,\n ) {\n     let hir_map = tcx.hir();\n-    let mut visitor = OneLevelVisitor::new(hir_map, target_hir_id);\n+    let mut visitor = OneLevelVisitor::new(hir_map, target_def_id);\n     // If the item is an import and has at least a path with two parts, we go into it.\n     while let hir::ItemKind::Use(path, _) = item.kind &&\n         path.segments.len() > 1 &&\n@@ -2138,7 +2139,7 @@ fn clean_maybe_renamed_item<'tcx>(\n     cx: &mut DocContext<'tcx>,\n     item: &hir::Item<'tcx>,\n     renamed: Option<Symbol>,\n-    import_id: Option<hir::HirId>,\n+    import_id: Option<LocalDefId>,\n ) -> Vec<Item> {\n     use hir::ItemKind;\n \n@@ -2183,7 +2184,7 @@ fn clean_maybe_renamed_item<'tcx>(\n                 generics: clean_generics(generics, cx),\n                 fields: variant_data.fields().iter().map(|x| clean_field(x, cx)).collect(),\n             }),\n-            ItemKind::Impl(impl_) => return clean_impl(impl_, item.hir_id(), cx),\n+            ItemKind::Impl(impl_) => return clean_impl(impl_, item.owner_id.def_id, cx),\n             // proc macros can have a name set by attributes\n             ItemKind::Fn(ref sig, generics, body_id) => {\n                 clean_fn_or_proc_macro(item, sig, generics, body_id, &mut name, cx)\n@@ -2218,10 +2219,10 @@ fn clean_maybe_renamed_item<'tcx>(\n \n         let mut extra_attrs = Vec::new();\n         if let Some(hir::Node::Item(use_node)) =\n-            import_id.and_then(|hir_id| cx.tcx.hir().find(hir_id))\n+            import_id.and_then(|def_id| cx.tcx.hir().find_by_def_id(def_id))\n         {\n             // We get all the various imports' attributes.\n-            get_all_import_attributes(use_node, cx.tcx, item.hir_id(), &mut extra_attrs);\n+            get_all_import_attributes(use_node, cx.tcx, item.owner_id.def_id, &mut extra_attrs);\n         }\n \n         if !extra_attrs.is_empty() {\n@@ -2244,12 +2245,12 @@ fn clean_maybe_renamed_item<'tcx>(\n \n fn clean_variant<'tcx>(variant: &hir::Variant<'tcx>, cx: &mut DocContext<'tcx>) -> Item {\n     let kind = VariantItem(clean_variant_data(&variant.data, &variant.disr_expr, cx));\n-    Item::from_hir_id_and_parts(variant.hir_id, Some(variant.ident.name), kind, cx)\n+    Item::from_def_id_and_parts(variant.def_id.to_def_id(), Some(variant.ident.name), kind, cx)\n }\n \n fn clean_impl<'tcx>(\n     impl_: &hir::Impl<'tcx>,\n-    hir_id: hir::HirId,\n+    def_id: LocalDefId,\n     cx: &mut DocContext<'tcx>,\n ) -> Vec<Item> {\n     let tcx = cx.tcx;\n@@ -2260,7 +2261,6 @@ fn clean_impl<'tcx>(\n         .iter()\n         .map(|ii| clean_impl_item(tcx.hir().impl_item(ii.id), cx))\n         .collect::<Vec<_>>();\n-    let def_id = tcx.hir().local_def_id(hir_id);\n \n     // If this impl block is an implementation of the Deref trait, then we\n     // need to try inlining the target's inherent impl blocks as well.\n@@ -2289,7 +2289,7 @@ fn clean_impl<'tcx>(\n                 ImplKind::Normal\n             },\n         }));\n-        Item::from_hir_id_and_parts(hir_id, None, kind, cx)\n+        Item::from_def_id_and_parts(def_id.to_def_id(), None, kind, cx)\n     };\n     if let Some(type_alias) = type_alias {\n         ret.push(make_item(trait_.clone(), type_alias, items.clone()));\n@@ -2510,8 +2510,8 @@ fn clean_maybe_renamed_foreign_item<'tcx>(\n             hir::ForeignItemKind::Type => ForeignTypeItem,\n         };\n \n-        Item::from_hir_id_and_parts(\n-            item.hir_id(),\n+        Item::from_def_id_and_parts(\n+            item.owner_id.def_id.to_def_id(),\n             Some(renamed.unwrap_or(item.ident.name)),\n             kind,\n             cx,"}, {"sha": "3b258c4d919f84e385c841bdcec428fd8ba0a9ec", "filename": "src/librustdoc/clean/types.rs", "status": "modified", "additions": 1, "deletions": 15, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/18890f05f6cea40fd25bb4bb9aa6f7372b69f641/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18890f05f6cea40fd25bb4bb9aa6f7372b69f641/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Ftypes.rs?ref=18890f05f6cea40fd25bb4bb9aa6f7372b69f641", "patch": "@@ -439,17 +439,6 @@ impl Item {\n         self.attrs.doc_value()\n     }\n \n-    /// Convenience wrapper around [`Self::from_def_id_and_parts`] which converts\n-    /// `hir_id` to a [`DefId`]\n-    pub(crate) fn from_hir_id_and_parts(\n-        hir_id: hir::HirId,\n-        name: Option<Symbol>,\n-        kind: ItemKind,\n-        cx: &mut DocContext<'_>,\n-    ) -> Item {\n-        Item::from_def_id_and_parts(cx.tcx.hir().local_def_id(hir_id).to_def_id(), name, kind, cx)\n-    }\n-\n     pub(crate) fn from_def_id_and_parts(\n         def_id: DefId,\n         name: Option<Symbol>,\n@@ -2416,10 +2405,7 @@ impl ConstantKind {\n \n     pub(crate) fn is_literal(&self, tcx: TyCtxt<'_>) -> bool {\n         match *self {\n-            ConstantKind::TyConst { .. } => false,\n-            ConstantKind::Extern { def_id } => def_id.as_local().map_or(false, |def_id| {\n-                is_literal_expr(tcx, tcx.hir().local_def_id_to_hir_id(def_id))\n-            }),\n+            ConstantKind::TyConst { .. } | ConstantKind::Extern { .. } => false,\n             ConstantKind::Local { body, .. } | ConstantKind::Anonymous { body } => {\n                 is_literal_expr(tcx, body.hir_id)\n             }"}, {"sha": "37a1005cba1fc82a97ef7690805aac5a121c5a3b", "filename": "src/librustdoc/doctest.rs", "status": "modified", "additions": 12, "deletions": 14, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/18890f05f6cea40fd25bb4bb9aa6f7372b69f641/src%2Flibrustdoc%2Fdoctest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18890f05f6cea40fd25bb4bb9aa6f7372b69f641/src%2Flibrustdoc%2Fdoctest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdoctest.rs?ref=18890f05f6cea40fd25bb4bb9aa6f7372b69f641", "patch": "@@ -2,10 +2,8 @@ use rustc_ast as ast;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::sync::Lrc;\n use rustc_errors::{ColorConfig, ErrorGuaranteed, FatalError};\n-use rustc_hir as hir;\n-use rustc_hir::def_id::LOCAL_CRATE;\n-use rustc_hir::intravisit;\n-use rustc_hir::{HirId, CRATE_HIR_ID};\n+use rustc_hir::def_id::{LocalDefId, CRATE_DEF_ID, LOCAL_CRATE};\n+use rustc_hir::{self as hir, intravisit, CRATE_HIR_ID};\n use rustc_interface::interface;\n use rustc_middle::hir::map::Map;\n use rustc_middle::hir::nested_filter;\n@@ -140,7 +138,7 @@ pub(crate) fn run(options: RustdocOptions) -> Result<(), ErrorGuaranteed> {\n                     };\n                     hir_collector.visit_testable(\n                         \"\".to_string(),\n-                        CRATE_HIR_ID,\n+                        CRATE_DEF_ID,\n                         tcx.hir().span(CRATE_HIR_ID),\n                         |this| tcx.hir().walk_toplevel_module(this),\n                     );\n@@ -1214,11 +1212,11 @@ impl<'a, 'hir, 'tcx> HirCollector<'a, 'hir, 'tcx> {\n     fn visit_testable<F: FnOnce(&mut Self)>(\n         &mut self,\n         name: String,\n-        hir_id: HirId,\n+        def_id: LocalDefId,\n         sp: Span,\n         nested: F,\n     ) {\n-        let ast_attrs = self.tcx.hir().attrs(hir_id);\n+        let ast_attrs = self.tcx.hir().attrs(self.tcx.hir().local_def_id_to_hir_id(def_id));\n         if let Some(ref cfg) = ast_attrs.cfg(self.tcx, &FxHashSet::default()) {\n             if !cfg.matches(&self.sess.parse_sess, Some(self.tcx.features())) {\n                 return;\n@@ -1247,7 +1245,7 @@ impl<'a, 'hir, 'tcx> HirCollector<'a, 'hir, 'tcx> {\n                 self.collector.enable_per_target_ignores,\n                 Some(&crate::html::markdown::ExtraInfo::new(\n                     self.tcx,\n-                    hir_id,\n+                    def_id.to_def_id(),\n                     span_of_attrs(&attrs).unwrap_or(sp),\n                 )),\n             );\n@@ -1276,37 +1274,37 @@ impl<'a, 'hir, 'tcx> intravisit::Visitor<'hir> for HirCollector<'a, 'hir, 'tcx>\n             _ => item.ident.to_string(),\n         };\n \n-        self.visit_testable(name, item.hir_id(), item.span, |this| {\n+        self.visit_testable(name, item.owner_id.def_id, item.span, |this| {\n             intravisit::walk_item(this, item);\n         });\n     }\n \n     fn visit_trait_item(&mut self, item: &'hir hir::TraitItem<'_>) {\n-        self.visit_testable(item.ident.to_string(), item.hir_id(), item.span, |this| {\n+        self.visit_testable(item.ident.to_string(), item.owner_id.def_id, item.span, |this| {\n             intravisit::walk_trait_item(this, item);\n         });\n     }\n \n     fn visit_impl_item(&mut self, item: &'hir hir::ImplItem<'_>) {\n-        self.visit_testable(item.ident.to_string(), item.hir_id(), item.span, |this| {\n+        self.visit_testable(item.ident.to_string(), item.owner_id.def_id, item.span, |this| {\n             intravisit::walk_impl_item(this, item);\n         });\n     }\n \n     fn visit_foreign_item(&mut self, item: &'hir hir::ForeignItem<'_>) {\n-        self.visit_testable(item.ident.to_string(), item.hir_id(), item.span, |this| {\n+        self.visit_testable(item.ident.to_string(), item.owner_id.def_id, item.span, |this| {\n             intravisit::walk_foreign_item(this, item);\n         });\n     }\n \n     fn visit_variant(&mut self, v: &'hir hir::Variant<'_>) {\n-        self.visit_testable(v.ident.to_string(), v.hir_id, v.span, |this| {\n+        self.visit_testable(v.ident.to_string(), v.def_id, v.span, |this| {\n             intravisit::walk_variant(this, v);\n         });\n     }\n \n     fn visit_field_def(&mut self, f: &'hir hir::FieldDef<'_>) {\n-        self.visit_testable(f.ident.to_string(), f.hir_id, f.span, |this| {\n+        self.visit_testable(f.ident.to_string(), f.def_id, f.span, |this| {\n             intravisit::walk_field_def(this, f);\n         });\n     }"}, {"sha": "d7739b8534f309e29eec30e308c77ee97b0702b6", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 30, "deletions": 33, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/18890f05f6cea40fd25bb4bb9aa6f7372b69f641/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18890f05f6cea40fd25bb4bb9aa6f7372b69f641/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=18890f05f6cea40fd25bb4bb9aa6f7372b69f641", "patch": "@@ -27,7 +27,6 @@\n \n use rustc_data_structures::fx::FxHashMap;\n use rustc_hir::def_id::DefId;\n-use rustc_hir::HirId;\n use rustc_middle::ty::TyCtxt;\n use rustc_span::edition::Edition;\n use rustc_span::{Span, Symbol};\n@@ -296,25 +295,42 @@ impl<'a, I: Iterator<Item = Event<'a>>> Iterator for CodeBlocks<'_, 'a, I> {\n             let channel = if test.contains(\"#![feature(\") { \"&amp;version=nightly\" } else { \"\" };\n \n             // These characters don't need to be escaped in a URI.\n-            // FIXME: use a library function for percent encoding.\n+            // See https://url.spec.whatwg.org/#query-percent-encode-set\n+            // and https://url.spec.whatwg.org/#urlencoded-parsing\n+            // and https://url.spec.whatwg.org/#url-code-points\n             fn dont_escape(c: u8) -> bool {\n                 (b'a' <= c && c <= b'z')\n                     || (b'A' <= c && c <= b'Z')\n                     || (b'0' <= c && c <= b'9')\n                     || c == b'-'\n                     || c == b'_'\n                     || c == b'.'\n+                    || c == b','\n                     || c == b'~'\n                     || c == b'!'\n                     || c == b'\\''\n                     || c == b'('\n                     || c == b')'\n                     || c == b'*'\n+                    || c == b'/'\n+                    || c == b';'\n+                    || c == b':'\n+                    || c == b'?'\n+                    // As described in urlencoded-parsing, the\n+                    // first `=` is the one that separates key from\n+                    // value. Following `=`s are part of the value.\n+                    || c == b'='\n             }\n             let mut test_escaped = String::new();\n             for b in test.bytes() {\n                 if dont_escape(b) {\n                     test_escaped.push(char::from(b));\n+                } else if b == b' ' {\n+                    // URL queries are decoded with + replaced with SP\n+                    test_escaped.push('+');\n+                } else if b == b'%' {\n+                    test_escaped.push('%');\n+                    test_escaped.push('%');\n                 } else {\n                     write!(test_escaped, \"%{:02X}\", b).unwrap();\n                 }\n@@ -784,45 +800,26 @@ pub(crate) fn find_testable_code<T: doctest::Tester>(\n }\n \n pub(crate) struct ExtraInfo<'tcx> {\n-    id: ExtraInfoId,\n+    def_id: DefId,\n     sp: Span,\n     tcx: TyCtxt<'tcx>,\n }\n \n-enum ExtraInfoId {\n-    Hir(HirId),\n-    Def(DefId),\n-}\n-\n impl<'tcx> ExtraInfo<'tcx> {\n-    pub(crate) fn new(tcx: TyCtxt<'tcx>, hir_id: HirId, sp: Span) -> ExtraInfo<'tcx> {\n-        ExtraInfo { id: ExtraInfoId::Hir(hir_id), sp, tcx }\n-    }\n-\n-    pub(crate) fn new_did(tcx: TyCtxt<'tcx>, did: DefId, sp: Span) -> ExtraInfo<'tcx> {\n-        ExtraInfo { id: ExtraInfoId::Def(did), sp, tcx }\n+    pub(crate) fn new(tcx: TyCtxt<'tcx>, def_id: DefId, sp: Span) -> ExtraInfo<'tcx> {\n+        ExtraInfo { def_id, sp, tcx }\n     }\n \n     fn error_invalid_codeblock_attr(&self, msg: &str, help: &str) {\n-        let hir_id = match self.id {\n-            ExtraInfoId::Hir(hir_id) => hir_id,\n-            ExtraInfoId::Def(item_did) => {\n-                match item_did.as_local() {\n-                    Some(item_did) => self.tcx.hir().local_def_id_to_hir_id(item_did),\n-                    None => {\n-                        // If non-local, no need to check anything.\n-                        return;\n-                    }\n-                }\n-            }\n-        };\n-        self.tcx.struct_span_lint_hir(\n-            crate::lint::INVALID_CODEBLOCK_ATTRIBUTES,\n-            hir_id,\n-            self.sp,\n-            msg,\n-            |lint| lint.help(help),\n-        );\n+        if let Some(def_id) = self.def_id.as_local() {\n+            self.tcx.struct_span_lint_hir(\n+                crate::lint::INVALID_CODEBLOCK_ATTRIBUTES,\n+                self.tcx.hir().local_def_id_to_hir_id(def_id),\n+                self.sp,\n+                msg,\n+                |lint| lint.help(help),\n+            );\n+        }\n     }\n }\n "}, {"sha": "508b2bab0eb643e4d1592f731ac59aff7b4295fe", "filename": "src/librustdoc/html/render/print_item.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/18890f05f6cea40fd25bb4bb9aa6f7372b69f641/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18890f05f6cea40fd25bb4bb9aa6f7372b69f641/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs?ref=18890f05f6cea40fd25bb4bb9aa6f7372b69f641", "patch": "@@ -391,7 +391,7 @@ fn item_module(w: &mut Buffer, cx: &mut Context<'_>, item: &clean::Item, items:\n                 };\n                 write!(\n                     w,\n-                    \"<div class=\\\"item-left {stab}{add}import-item\\\"{id}>\\\n+                    \"<div class=\\\"item-left{add}{stab}\\\"{id}>\\\n                          <code>{vis}{imp}</code>\\\n                      </div>\\\n                      {stab_tags_before}{stab_tags}{stab_tags_after}\",\n@@ -437,7 +437,7 @@ fn item_module(w: &mut Buffer, cx: &mut Context<'_>, item: &clean::Item, items:\n                 };\n                 write!(\n                     w,\n-                    \"<div class=\\\"item-left {stab}{add}module-item\\\">\\\n+                    \"<div class=\\\"item-left{add}{stab}\\\">\\\n                         <a class=\\\"{class}\\\" href=\\\"{href}\\\" title=\\\"{title}\\\">{name}</a>\\\n                         {visibility_emoji}\\\n                         {unsafety_flag}\\\n@@ -452,7 +452,7 @@ fn item_module(w: &mut Buffer, cx: &mut Context<'_>, item: &clean::Item, items:\n                     stab = stab.unwrap_or_default(),\n                     unsafety_flag = unsafety_flag,\n                     href = item_path(myitem.type_(), myitem.name.unwrap().as_str()),\n-                    title = [full_path(cx, myitem), myitem.type_().to_string()]\n+                    title = [myitem.type_().to_string(), full_path(cx, myitem)]\n                         .iter()\n                         .filter_map(|s| if !s.is_empty() { Some(s.as_str()) } else { None })\n                         .collect::<Vec<_>>()"}, {"sha": "8699508e43916af754f142937b60ac7312714c8b", "filename": "src/librustdoc/html/static/css/rustdoc.css", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/18890f05f6cea40fd25bb4bb9aa6f7372b69f641/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css", "raw_url": "https://github.com/rust-lang/rust/raw/18890f05f6cea40fd25bb4bb9aa6f7372b69f641/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css?ref=18890f05f6cea40fd25bb4bb9aa6f7372b69f641", "patch": "@@ -977,8 +977,7 @@ so that we can apply CSS-filters to change the arrow color in themes */\n \t\t0 -1px 0 black;\n }\n \n-.module-item.unstable,\n-.import-item.unstable {\n+.item-left.unstable {\n \topacity: 0.65;\n }\n "}, {"sha": "0b22f943dab99db214553c2696f25beeacc8b0c0", "filename": "src/librustdoc/passes/calculate_doc_coverage.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/18890f05f6cea40fd25bb4bb9aa6f7372b69f641/src%2Flibrustdoc%2Fpasses%2Fcalculate_doc_coverage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18890f05f6cea40fd25bb4bb9aa6f7372b69f641/src%2Flibrustdoc%2Fpasses%2Fcalculate_doc_coverage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcalculate_doc_coverage.rs?ref=18890f05f6cea40fd25bb4bb9aa6f7372b69f641", "patch": "@@ -216,13 +216,7 @@ impl<'a, 'b> DocVisitor for CoverageCalculator<'a, 'b> {\n                 );\n \n                 let has_doc_example = tests.found_tests != 0;\n-                // The `expect_def_id()` should be okay because `local_def_id_to_hir_id`\n-                // would presumably panic if a fake `DefIndex` were passed.\n-                let hir_id = self\n-                    .ctx\n-                    .tcx\n-                    .hir()\n-                    .local_def_id_to_hir_id(i.item_id.expect_def_id().expect_local());\n+                let hir_id = DocContext::as_local_hir_id(self.ctx.tcx, i.item_id).unwrap();\n                 let (level, source) = self.ctx.tcx.lint_level_at_node(MISSING_DOCS, hir_id);\n \n                 // In case we have:"}, {"sha": "f3961d5017ef4b99c80b7831446733a60c0c1648", "filename": "src/librustdoc/passes/check_doc_test_visibility.rs", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/18890f05f6cea40fd25bb4bb9aa6f7372b69f641/src%2Flibrustdoc%2Fpasses%2Fcheck_doc_test_visibility.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18890f05f6cea40fd25bb4bb9aa6f7372b69f641/src%2Flibrustdoc%2Fpasses%2Fcheck_doc_test_visibility.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcheck_doc_test_visibility.rs?ref=18890f05f6cea40fd25bb4bb9aa6f7372b69f641", "patch": "@@ -14,8 +14,8 @@ use crate::visit::DocVisitor;\n use crate::visit_ast::inherits_doc_hidden;\n use rustc_hir as hir;\n use rustc_middle::lint::LintLevelSource;\n+use rustc_middle::ty::DefIdTree;\n use rustc_session::lint;\n-use rustc_span::symbol::sym;\n \n pub(crate) const CHECK_DOC_TEST_VISIBILITY: Pass = Pass {\n     name: \"check_doc_test_visibility\",\n@@ -79,11 +79,11 @@ pub(crate) fn should_have_doc_example(cx: &DocContext<'_>, item: &clean::Item) -\n \n     // The `expect_def_id()` should be okay because `local_def_id_to_hir_id`\n     // would presumably panic if a fake `DefIndex` were passed.\n-    let hir_id = cx.tcx.hir().local_def_id_to_hir_id(item.item_id.expect_def_id().expect_local());\n+    let def_id = item.item_id.expect_def_id().expect_local();\n \n     // check if parent is trait impl\n-    if let Some(parent_hir_id) = cx.tcx.hir().opt_parent_id(hir_id) {\n-        if let Some(parent_node) = cx.tcx.hir().find(parent_hir_id) {\n+    if let Some(parent_def_id) = cx.tcx.opt_local_parent(def_id) {\n+        if let Some(parent_node) = cx.tcx.hir().find_by_def_id(parent_def_id) {\n             if matches!(\n                 parent_node,\n                 hir::Node::Item(hir::Item {\n@@ -96,13 +96,16 @@ pub(crate) fn should_have_doc_example(cx: &DocContext<'_>, item: &clean::Item) -\n         }\n     }\n \n-    if cx.tcx.hir().attrs(hir_id).lists(sym::doc).has_word(sym::hidden)\n-        || inherits_doc_hidden(cx.tcx, hir_id)\n-        || cx.tcx.hir().span(hir_id).in_derive_expansion()\n+    if cx.tcx.is_doc_hidden(def_id.to_def_id())\n+        || inherits_doc_hidden(cx.tcx, def_id)\n+        || cx.tcx.def_span(def_id.to_def_id()).in_derive_expansion()\n     {\n         return false;\n     }\n-    let (level, source) = cx.tcx.lint_level_at_node(crate::lint::MISSING_DOC_CODE_EXAMPLES, hir_id);\n+    let (level, source) = cx.tcx.lint_level_at_node(\n+        crate::lint::MISSING_DOC_CODE_EXAMPLES,\n+        cx.tcx.hir().local_def_id_to_hir_id(def_id),\n+    );\n     level != lint::Level::Allow || matches!(source, LintLevelSource::Default)\n }\n "}, {"sha": "e42921c080945f4b6c6a9df05d02ca0d76e409a8", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/18890f05f6cea40fd25bb4bb9aa6f7372b69f641/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18890f05f6cea40fd25bb4bb9aa6f7372b69f641/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=18890f05f6cea40fd25bb4bb9aa6f7372b69f641", "patch": "@@ -1194,14 +1194,9 @@ impl LinkCollector<'_, '_> {\n             }\n \n         // item can be non-local e.g. when using #[doc(primitive = \"pointer\")]\n-        if let Some((src_id, dst_id)) = id\n-            .as_local()\n-            // The `expect_def_id()` should be okay because `local_def_id_to_hir_id`\n-            // would presumably panic if a fake `DefIndex` were passed.\n-            .and_then(|dst_id| {\n-                item.item_id.expect_def_id().as_local().map(|src_id| (src_id, dst_id))\n-            })\n-        {\n+        if let Some((src_id, dst_id)) = id.as_local().and_then(|dst_id| {\n+            item.item_id.expect_def_id().as_local().map(|src_id| (src_id, dst_id))\n+        }) {\n             if self.cx.tcx.effective_visibilities(()).is_exported(src_id)\n                 && !self.cx.tcx.effective_visibilities(()).is_exported(dst_id)\n             {"}, {"sha": "03be5e799716706d2cccda938dff8a90d8154246", "filename": "src/librustdoc/passes/lint/check_code_block_syntax.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/18890f05f6cea40fd25bb4bb9aa6f7372b69f641/src%2Flibrustdoc%2Fpasses%2Flint%2Fcheck_code_block_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18890f05f6cea40fd25bb4bb9aa6f7372b69f641/src%2Flibrustdoc%2Fpasses%2Flint%2Fcheck_code_block_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Flint%2Fcheck_code_block_syntax.rs?ref=18890f05f6cea40fd25bb4bb9aa6f7372b69f641", "patch": "@@ -19,8 +19,7 @@ use crate::passes::source_span_for_markdown_range;\n pub(crate) fn visit_item(cx: &DocContext<'_>, item: &clean::Item) {\n     if let Some(dox) = &item.attrs.collapsed_doc_value() {\n         let sp = item.attr_span(cx.tcx);\n-        let extra =\n-            crate::html::markdown::ExtraInfo::new_did(cx.tcx, item.item_id.expect_def_id(), sp);\n+        let extra = crate::html::markdown::ExtraInfo::new(cx.tcx, item.item_id.expect_def_id(), sp);\n         for code_block in markdown::rust_code_blocks(dox, &extra) {\n             check_rust_syntax(cx, item, dox, code_block);\n         }\n@@ -73,7 +72,6 @@ fn check_rust_syntax(\n             return;\n         };\n \n-    let hir_id = cx.tcx.hir().local_def_id_to_hir_id(local_id);\n     let empty_block = code_block.lang_string == Default::default() && code_block.is_fenced;\n     let is_ignore = code_block.lang_string.ignore != markdown::Ignore::None;\n \n@@ -93,6 +91,7 @@ fn check_rust_syntax(\n     // Finally build and emit the completed diagnostic.\n     // All points of divergence have been handled earlier so this can be\n     // done the same way whether the span is precise or not.\n+    let hir_id = cx.tcx.hir().local_def_id_to_hir_id(local_id);\n     cx.tcx.struct_span_lint_hir(crate::lint::INVALID_RUST_CODEBLOCKS, hir_id, sp, msg, |lint| {\n         let explanation = if is_ignore {\n             \"`ignore` code blocks require valid Rust code for syntax highlighting; \\"}, {"sha": "a4bc486900b3e92e88e6e3262a2067f212b67de2", "filename": "src/librustdoc/passes/propagate_doc_cfg.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/18890f05f6cea40fd25bb4bb9aa6f7372b69f641/src%2Flibrustdoc%2Fpasses%2Fpropagate_doc_cfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18890f05f6cea40fd25bb4bb9aa6f7372b69f641/src%2Flibrustdoc%2Fpasses%2Fpropagate_doc_cfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fpropagate_doc_cfg.rs?ref=18890f05f6cea40fd25bb4bb9aa6f7372b69f641", "patch": "@@ -9,6 +9,7 @@ use crate::fold::DocFolder;\n use crate::passes::Pass;\n \n use rustc_hir::def_id::LocalDefId;\n+use rustc_middle::ty::DefIdTree;\n \n pub(crate) const PROPAGATE_DOC_CFG: Pass = Pass {\n     name: \"propagate-doc-cfg\",\n@@ -41,24 +42,22 @@ impl<'a, 'tcx> CfgPropagator<'a, 'tcx> {\n         let Some(def_id) = item.item_id.as_def_id().and_then(|def_id| def_id.as_local())\n             else { return };\n \n-        let hir = self.cx.tcx.hir();\n-        let hir_id = hir.local_def_id_to_hir_id(def_id);\n-\n         if check_parent {\n-            let expected_parent = hir.get_parent_item(hir_id);\n+            let expected_parent = self.cx.tcx.opt_local_parent(def_id);\n             // If parents are different, it means that `item` is a reexport and we need\n             // to compute the actual `cfg` by iterating through its \"real\" parents.\n-            if self.parent == Some(expected_parent.def_id) {\n+            if self.parent.is_some() && self.parent == expected_parent {\n                 return;\n             }\n         }\n \n         let mut attrs = Vec::new();\n-        for (parent_hir_id, _) in hir.parent_iter(hir_id) {\n-            if let Some(def_id) = hir.opt_local_def_id(parent_hir_id) {\n-                attrs.extend_from_slice(load_attrs(self.cx, def_id.to_def_id()));\n-            }\n+        let mut next_def_id = def_id;\n+        while let Some(parent_def_id) = self.cx.tcx.opt_local_parent(next_def_id) {\n+            attrs.extend_from_slice(load_attrs(self.cx, parent_def_id.to_def_id()));\n+            next_def_id = parent_def_id;\n         }\n+\n         let (_, cfg) = merge_attrs(self.cx, None, item.attrs.other_attrs.as_slice(), Some(&attrs));\n         item.cfg = cfg;\n     }"}, {"sha": "a89d6fa83983d685e8a6baf94d63327320beca71", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 45, "deletions": 37, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/18890f05f6cea40fd25bb4bb9aa6f7372b69f641/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18890f05f6cea40fd25bb4bb9aa6f7372b69f641/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=18890f05f6cea40fd25bb4bb9aa6f7372b69f641", "patch": "@@ -4,9 +4,9 @@\n use rustc_data_structures::fx::FxHashSet;\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n-use rustc_hir::def_id::{DefId, DefIdMap};\n-use rustc_hir::{HirIdSet, Node, CRATE_HIR_ID};\n-use rustc_middle::ty::TyCtxt;\n+use rustc_hir::def_id::{DefId, DefIdMap, LocalDefId, LocalDefIdSet};\n+use rustc_hir::{Node, CRATE_HIR_ID};\n+use rustc_middle::ty::{DefIdTree, TyCtxt};\n use rustc_span::def_id::{CRATE_DEF_ID, LOCAL_CRATE};\n use rustc_span::symbol::{kw, sym, Symbol};\n use rustc_span::Span;\n@@ -23,19 +23,26 @@ pub(crate) struct Module<'hir> {\n     pub(crate) name: Symbol,\n     pub(crate) where_inner: Span,\n     pub(crate) mods: Vec<Module<'hir>>,\n-    pub(crate) id: hir::HirId,\n+    pub(crate) def_id: LocalDefId,\n     // (item, renamed, import_id)\n-    pub(crate) items: Vec<(&'hir hir::Item<'hir>, Option<Symbol>, Option<hir::HirId>)>,\n+    pub(crate) items: Vec<(&'hir hir::Item<'hir>, Option<Symbol>, Option<LocalDefId>)>,\n     pub(crate) foreigns: Vec<(&'hir hir::ForeignItem<'hir>, Option<Symbol>)>,\n }\n \n impl Module<'_> {\n-    pub(crate) fn new(name: Symbol, id: hir::HirId, where_inner: Span) -> Self {\n-        Module { name, id, where_inner, mods: Vec::new(), items: Vec::new(), foreigns: Vec::new() }\n+    pub(crate) fn new(name: Symbol, def_id: LocalDefId, where_inner: Span) -> Self {\n+        Module {\n+            name,\n+            def_id,\n+            where_inner,\n+            mods: Vec::new(),\n+            items: Vec::new(),\n+            foreigns: Vec::new(),\n+        }\n     }\n \n     pub(crate) fn where_outer(&self, tcx: TyCtxt<'_>) -> Span {\n-        tcx.hir().span(self.id)\n+        tcx.def_span(self.def_id)\n     }\n }\n \n@@ -46,10 +53,10 @@ fn def_id_to_path(tcx: TyCtxt<'_>, did: DefId) -> Vec<Symbol> {\n     std::iter::once(crate_name).chain(relative).collect()\n }\n \n-pub(crate) fn inherits_doc_hidden(tcx: TyCtxt<'_>, mut node: hir::HirId) -> bool {\n-    while let Some(id) = tcx.hir().get_enclosing_scope(node) {\n+pub(crate) fn inherits_doc_hidden(tcx: TyCtxt<'_>, mut node: LocalDefId) -> bool {\n+    while let Some(id) = tcx.opt_local_parent(node) {\n         node = id;\n-        if tcx.hir().attrs(node).lists(sym::doc).has_word(sym::hidden) {\n+        if tcx.is_doc_hidden(node.to_def_id()) {\n             return true;\n         }\n     }\n@@ -61,7 +68,7 @@ pub(crate) fn inherits_doc_hidden(tcx: TyCtxt<'_>, mut node: hir::HirId) -> bool\n \n pub(crate) struct RustdocVisitor<'a, 'tcx> {\n     cx: &'a mut core::DocContext<'tcx>,\n-    view_item_stack: HirIdSet,\n+    view_item_stack: LocalDefIdSet,\n     inlining: bool,\n     /// Are the current module and all of its parents public?\n     inside_public_path: bool,\n@@ -71,8 +78,8 @@ pub(crate) struct RustdocVisitor<'a, 'tcx> {\n impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n     pub(crate) fn new(cx: &'a mut core::DocContext<'tcx>) -> RustdocVisitor<'a, 'tcx> {\n         // If the root is re-exported, terminate all recursion.\n-        let mut stack = HirIdSet::default();\n-        stack.insert(hir::CRATE_HIR_ID);\n+        let mut stack = LocalDefIdSet::default();\n+        stack.insert(CRATE_DEF_ID);\n         RustdocVisitor {\n             cx,\n             view_item_stack: stack,\n@@ -89,7 +96,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n \n     pub(crate) fn visit(mut self) -> Module<'tcx> {\n         let mut top_level_module = self.visit_mod_contents(\n-            hir::CRATE_HIR_ID,\n+            CRATE_DEF_ID,\n             self.cx.tcx.hir().root_module(),\n             self.cx.tcx.crate_name(LOCAL_CRATE),\n             None,\n@@ -152,16 +159,15 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n \n     fn visit_mod_contents(\n         &mut self,\n-        id: hir::HirId,\n+        def_id: LocalDefId,\n         m: &'tcx hir::Mod<'tcx>,\n         name: Symbol,\n-        parent_id: Option<hir::HirId>,\n+        parent_id: Option<LocalDefId>,\n     ) -> Module<'tcx> {\n-        let mut om = Module::new(name, id, m.spans.inner_span);\n-        let def_id = self.cx.tcx.hir().local_def_id(id).to_def_id();\n+        let mut om = Module::new(name, def_id, m.spans.inner_span);\n         // Keep track of if there were any private modules in the path.\n         let orig_inside_public_path = self.inside_public_path;\n-        self.inside_public_path &= self.cx.tcx.visibility(def_id).is_public();\n+        self.inside_public_path &= self.cx.tcx.local_visibility(def_id).is_public();\n         for &i in m.item_ids {\n             let item = self.cx.tcx.hir().item(i);\n             if matches!(item.kind, hir::ItemKind::Use(_, hir::UseKind::Glob)) {\n@@ -193,7 +199,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n     /// Returns `true` if the target has been inlined.\n     fn maybe_inline_local(\n         &mut self,\n-        id: hir::HirId,\n+        def_id: LocalDefId,\n         res: Res,\n         renamed: Option<Symbol>,\n         glob: bool,\n@@ -211,10 +217,10 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n             return false;\n         };\n \n-        let use_attrs = tcx.hir().attrs(id);\n+        let use_attrs = tcx.hir().attrs(tcx.hir().local_def_id_to_hir_id(def_id));\n         // Don't inline `doc(hidden)` imports so they can be stripped at a later stage.\n         let is_no_inline = use_attrs.lists(sym::doc).has_word(sym::no_inline)\n-            || use_attrs.lists(sym::doc).has_word(sym::hidden);\n+            || tcx.is_doc_hidden(def_id.to_def_id());\n \n         // For cross-crate impl inlining we need to know whether items are\n         // reachable in documentation -- a previously unreachable item can be\n@@ -225,37 +231,39 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n             return false;\n         }\n \n-        let res_hir_id = match res_did.as_local() {\n-            Some(n) => tcx.hir().local_def_id_to_hir_id(n),\n-            None => return false,\n+        let Some(res_did) = res_did.as_local() else {\n+            return false;\n         };\n \n-        let is_private =\n-            !self.cx.cache.effective_visibilities.is_directly_public(self.cx.tcx, res_did);\n-        let is_hidden = inherits_doc_hidden(self.cx.tcx, res_hir_id);\n+        let is_private = !self\n+            .cx\n+            .cache\n+            .effective_visibilities\n+            .is_directly_public(self.cx.tcx, res_did.to_def_id());\n+        let is_hidden = inherits_doc_hidden(self.cx.tcx, res_did);\n \n         // Only inline if requested or if the item would otherwise be stripped.\n         if (!please_inline && !is_private && !is_hidden) || is_no_inline {\n             return false;\n         }\n \n-        if !self.view_item_stack.insert(res_hir_id) {\n+        if !self.view_item_stack.insert(res_did) {\n             return false;\n         }\n \n-        let ret = match tcx.hir().get(res_hir_id) {\n+        let ret = match tcx.hir().get_by_def_id(res_did) {\n             Node::Item(&hir::Item { kind: hir::ItemKind::Mod(ref m), .. }) if glob => {\n                 let prev = mem::replace(&mut self.inlining, true);\n                 for &i in m.item_ids {\n                     let i = self.cx.tcx.hir().item(i);\n-                    self.visit_item(i, None, om, Some(id));\n+                    self.visit_item(i, None, om, Some(def_id));\n                 }\n                 self.inlining = prev;\n                 true\n             }\n             Node::Item(it) if !glob => {\n                 let prev = mem::replace(&mut self.inlining, true);\n-                self.visit_item(it, renamed, om, Some(id));\n+                self.visit_item(it, renamed, om, Some(def_id));\n                 self.inlining = prev;\n                 true\n             }\n@@ -267,7 +275,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n             }\n             _ => false,\n         };\n-        self.view_item_stack.remove(&res_hir_id);\n+        self.view_item_stack.remove(&res_did);\n         ret\n     }\n \n@@ -276,7 +284,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n         item: &'tcx hir::Item<'_>,\n         renamed: Option<Symbol>,\n         om: &mut Module<'tcx>,\n-        parent_id: Option<hir::HirId>,\n+        parent_id: Option<LocalDefId>,\n     ) {\n         debug!(\"visiting item {:?}\", item);\n         let name = renamed.unwrap_or(item.ident.name);\n@@ -321,7 +329,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                         let is_glob = kind == hir::UseKind::Glob;\n                         let ident = if is_glob { None } else { Some(name) };\n                         if self.maybe_inline_local(\n-                            item.hir_id(),\n+                            item.owner_id.def_id,\n                             res,\n                             ident,\n                             is_glob,\n@@ -356,7 +364,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                 }\n             }\n             hir::ItemKind::Mod(ref m) => {\n-                om.mods.push(self.visit_mod_contents(item.hir_id(), m, name, parent_id));\n+                om.mods.push(self.visit_mod_contents(item.owner_id.def_id, m, name, parent_id));\n             }\n             hir::ItemKind::Fn(..)\n             | hir::ItemKind::ExternCrate(..)"}, {"sha": "3f4f65890b422aa83e1e5f250e848886e4d74c12", "filename": "tests/rustdoc-gui/label-next-to-symbol.goml", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/18890f05f6cea40fd25bb4bb9aa6f7372b69f641/tests%2Frustdoc-gui%2Flabel-next-to-symbol.goml", "raw_url": "https://github.com/rust-lang/rust/raw/18890f05f6cea40fd25bb4bb9aa6f7372b69f641/tests%2Frustdoc-gui%2Flabel-next-to-symbol.goml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-gui%2Flabel-next-to-symbol.goml?ref=18890f05f6cea40fd25bb4bb9aa6f7372b69f641", "patch": "@@ -20,7 +20,7 @@ assert-css: (\n // table like view\n assert-css: (\".item-right.docblock-short\", { \"padding-left\": \"0px\" })\n compare-elements-position-near: (\n-    \"//*[@class='item-left module-item']//a[text()='replaced_function']\",\n+    \"//*[@class='item-left']//a[text()='replaced_function']\",\n     \".item-left .stab.deprecated\",\n     {\"y\": 2},\n )\n@@ -32,7 +32,7 @@ compare-elements-position: (\n \n // Ensure no wrap\n compare-elements-position: (\n-    \"//*[@class='item-left module-item']//a[text()='replaced_function']/..\",\n+    \"//*[@class='item-left']//a[text()='replaced_function']/..\",\n     \"//*[@class='item-right docblock-short'][text()='a thing with a label']\",\n     (\"y\"),\n )\n@@ -43,7 +43,7 @@ size: (600, 600)\n // staggered layout with 2em spacing\n assert-css: (\".item-right.docblock-short\", { \"padding-left\": \"32px\" })\n compare-elements-position-near: (\n-    \"//*[@class='item-left module-item']//a[text()='replaced_function']\",\n+    \"//*[@class='item-left']//a[text()='replaced_function']\",\n     \".item-left .stab.deprecated\",\n     {\"y\": 2},\n )\n@@ -55,7 +55,7 @@ compare-elements-position: (\n \n // Ensure wrap\n compare-elements-position-false: (\n-    \"//*[@class='item-left module-item']//a[text()='replaced_function']/..\",\n+    \"//*[@class='item-left']//a[text()='replaced_function']/..\",\n     \"//*[@class='item-right docblock-short'][text()='a thing with a label']\",\n     (\"y\"),\n )"}, {"sha": "5940962a8ddba7a338234d3789c079e5987dc32e", "filename": "tests/rustdoc-gui/module-items-font.goml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/18890f05f6cea40fd25bb4bb9aa6f7372b69f641/tests%2Frustdoc-gui%2Fmodule-items-font.goml", "raw_url": "https://github.com/rust-lang/rust/raw/18890f05f6cea40fd25bb4bb9aa6f7372b69f641/tests%2Frustdoc-gui%2Fmodule-items-font.goml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-gui%2Fmodule-items-font.goml?ref=18890f05f6cea40fd25bb4bb9aa6f7372b69f641", "patch": "@@ -1,7 +1,7 @@\n // This test checks that the correct font is used on module items (in index.html pages).\n goto: \"file://\" + |DOC_PATH| + \"/test_docs/index.html\"\n assert-css: (\n-    \".item-table .module-item a\",\n+    \".item-table .item-left > a\",\n     {\"font-family\": '\"Fira Sans\", Arial, NanumBarunGothic, sans-serif'},\n     ALL,\n )"}, {"sha": "3ecb25c82a44e133aa44209904eb871967590478", "filename": "tests/rustdoc-gui/unsafe-fn.goml", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/18890f05f6cea40fd25bb4bb9aa6f7372b69f641/tests%2Frustdoc-gui%2Funsafe-fn.goml", "raw_url": "https://github.com/rust-lang/rust/raw/18890f05f6cea40fd25bb4bb9aa6f7372b69f641/tests%2Frustdoc-gui%2Funsafe-fn.goml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-gui%2Funsafe-fn.goml?ref=18890f05f6cea40fd25bb4bb9aa6f7372b69f641", "patch": "@@ -4,8 +4,8 @@ goto: \"file://\" + |DOC_PATH| + \"/test_docs/index.html\"\n show-text: true\n \n compare-elements-property: (\n-    \"//a[@title='test_docs::safe_fn fn']/..\",\n-    \"//a[@title='test_docs::unsafe_fn fn']/..\",\n+    \"//a[@title='fn test_docs::safe_fn']/..\",\n+    \"//a[@title='fn test_docs::unsafe_fn']/..\",\n     [\"clientHeight\"]\n )\n "}, {"sha": "89c7f0a6f342c4814379c6c18ba4e270c15b0ef1", "filename": "tests/rustdoc/cfg_doc_reexport.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/18890f05f6cea40fd25bb4bb9aa6f7372b69f641/tests%2Frustdoc%2Fcfg_doc_reexport.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18890f05f6cea40fd25bb4bb9aa6f7372b69f641/tests%2Frustdoc%2Fcfg_doc_reexport.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc%2Fcfg_doc_reexport.rs?ref=18890f05f6cea40fd25bb4bb9aa6f7372b69f641", "patch": "@@ -5,8 +5,8 @@\n #![no_core]\n \n // @has 'foo/index.html'\n-// @has - '//*[@class=\"item-left module-item\"]/*[@class=\"stab portability\"]' 'foobar'\n-// @has - '//*[@class=\"item-left module-item\"]/*[@class=\"stab portability\"]' 'bar'\n+// @has - '//*[@class=\"item-left\"]/*[@class=\"stab portability\"]' 'foobar'\n+// @has - '//*[@class=\"item-left\"]/*[@class=\"stab portability\"]' 'bar'\n \n #[doc(cfg(feature = \"foobar\"))]\n mod imp_priv {"}, {"sha": "5cbe4d59108a4208cf4d828322a43fe41edc94a3", "filename": "tests/rustdoc/deprecated.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/18890f05f6cea40fd25bb4bb9aa6f7372b69f641/tests%2Frustdoc%2Fdeprecated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18890f05f6cea40fd25bb4bb9aa6f7372b69f641/tests%2Frustdoc%2Fdeprecated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc%2Fdeprecated.rs?ref=18890f05f6cea40fd25bb4bb9aa6f7372b69f641", "patch": "@@ -1,4 +1,4 @@\n-// @has deprecated/index.html '//*[@class=\"item-left module-item\"]/span[@class=\"stab deprecated\"]' \\\n+// @has deprecated/index.html '//*[@class=\"item-left\"]/span[@class=\"stab deprecated\"]' \\\n //      'Deprecated'\n // @has - '//*[@class=\"item-right docblock-short\"]' 'Deprecated docs'\n "}, {"sha": "1cfbfec6fcd3012e0a847fbaf5a966ee9d0ddf07", "filename": "tests/rustdoc/doc-cfg.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/18890f05f6cea40fd25bb4bb9aa6f7372b69f641/tests%2Frustdoc%2Fdoc-cfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18890f05f6cea40fd25bb4bb9aa6f7372b69f641/tests%2Frustdoc%2Fdoc-cfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc%2Fdoc-cfg.rs?ref=18890f05f6cea40fd25bb4bb9aa6f7372b69f641", "patch": "@@ -12,7 +12,7 @@ pub struct Portable;\n // @has doc_cfg/unix_only/index.html \\\n //  '//*[@id=\"main-content\"]/*[@class=\"item-info\"]/*[@class=\"stab portability\"]' \\\n //  'Available on Unix only.'\n-// @matches - '//*[@class=\"item-left module-item\"]//*[@class=\"stab portability\"]' '\\AARM\\Z'\n+// @matches - '//*[@class=\"item-left\"]//*[@class=\"stab portability\"]' '\\AARM\\Z'\n // @count - '//*[@class=\"stab portability\"]' 2\n #[doc(cfg(unix))]\n pub mod unix_only {\n@@ -42,7 +42,7 @@ pub mod unix_only {\n // @has doc_cfg/wasi_only/index.html \\\n //  '//*[@id=\"main-content\"]/*[@class=\"item-info\"]/*[@class=\"stab portability\"]' \\\n //  'Available on WASI only.'\n-// @matches - '//*[@class=\"item-left module-item\"]//*[@class=\"stab portability\"]' '\\AWebAssembly\\Z'\n+// @matches - '//*[@class=\"item-left\"]//*[@class=\"stab portability\"]' '\\AWebAssembly\\Z'\n // @count - '//*[@class=\"stab portability\"]' 2\n #[doc(cfg(target_os = \"wasi\"))]\n pub mod wasi_only {\n@@ -74,7 +74,7 @@ pub mod wasi_only {\n \n // the portability header is different on the module view versus the full view\n // @has doc_cfg/index.html\n-// @matches - '//*[@class=\"item-left module-item\"]//*[@class=\"stab portability\"]' '\\Aavx\\Z'\n+// @matches - '//*[@class=\"item-left\"]//*[@class=\"stab portability\"]' '\\Aavx\\Z'\n \n // @has doc_cfg/fn.uses_target_feature.html\n // @has - '//*[@id=\"main-content\"]/*[@class=\"item-info\"]/*[@class=\"stab portability\"]' \\"}, {"sha": "1ac2e52324964a6d40a35a3fa8bbceb489bca114", "filename": "tests/rustdoc/duplicate-cfg.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/18890f05f6cea40fd25bb4bb9aa6f7372b69f641/tests%2Frustdoc%2Fduplicate-cfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18890f05f6cea40fd25bb4bb9aa6f7372b69f641/tests%2Frustdoc%2Fduplicate-cfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc%2Fduplicate-cfg.rs?ref=18890f05f6cea40fd25bb4bb9aa6f7372b69f641", "patch": "@@ -2,8 +2,8 @@\n #![feature(doc_cfg)]\n \n // @has 'foo/index.html'\n-// @matches '-' '//*[@class=\"item-left module-item\"]//*[@class=\"stab portability\"]' '^sync$'\n-// @has '-' '//*[@class=\"item-left module-item\"]//*[@class=\"stab portability\"]/@title' 'Available on crate feature `sync` only'\n+// @matches '-' '//*[@class=\"item-left\"]//*[@class=\"stab portability\"]' '^sync$'\n+// @has '-' '//*[@class=\"item-left\"]//*[@class=\"stab portability\"]/@title' 'Available on crate feature `sync` only'\n \n // @has 'foo/struct.Foo.html'\n // @has '-' '//*[@class=\"stab portability\"]' 'sync'"}, {"sha": "2668b3334979072b15b07e62cb01acba9ca74dab", "filename": "tests/rustdoc/glob-shadowing.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/18890f05f6cea40fd25bb4bb9aa6f7372b69f641/tests%2Frustdoc%2Fglob-shadowing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18890f05f6cea40fd25bb4bb9aa6f7372b69f641/tests%2Frustdoc%2Fglob-shadowing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc%2Fglob-shadowing.rs?ref=18890f05f6cea40fd25bb4bb9aa6f7372b69f641", "patch": "@@ -1,5 +1,5 @@\n // @has 'glob_shadowing/index.html'\n-// @count - '//div[@class=\"item-left module-item\"]' 6\n+// @count - '//div[@class=\"item-left\"]' 6\n // @!has - '//div[@class=\"item-right docblock-short\"]' 'sub1::describe'\n // @has - '//div[@class=\"item-right docblock-short\"]' 'sub2::describe'\n "}, {"sha": "d5b0de5725bce4f32502d5a7be169517a361cc67", "filename": "tests/rustdoc/inline_cross/macros.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/18890f05f6cea40fd25bb4bb9aa6f7372b69f641/tests%2Frustdoc%2Finline_cross%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18890f05f6cea40fd25bb4bb9aa6f7372b69f641/tests%2Frustdoc%2Finline_cross%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc%2Finline_cross%2Fmacros.rs?ref=18890f05f6cea40fd25bb4bb9aa6f7372b69f641", "patch": "@@ -6,9 +6,9 @@\n \n extern crate macros;\n \n-// @has foo/index.html '//*[@class=\"item-left unstable deprecated module-item\"]/span[@class=\"stab deprecated\"]' \\\n+// @has foo/index.html '//*[@class=\"item-left unstable deprecated\"]/span[@class=\"stab deprecated\"]' \\\n //         Deprecated\n-// @has - '//*[@class=\"item-left unstable deprecated module-item\"]/span[@class=\"stab unstable\"]' \\\n+// @has - '//*[@class=\"item-left unstable deprecated\"]/span[@class=\"stab unstable\"]' \\\n //         Experimental\n \n // @has foo/macro.my_macro.html"}, {"sha": "8296d7a81f2b1bc9c49d8d2995e8b030e6a70ca0", "filename": "tests/rustdoc/issue-32374.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/18890f05f6cea40fd25bb4bb9aa6f7372b69f641/tests%2Frustdoc%2Fissue-32374.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18890f05f6cea40fd25bb4bb9aa6f7372b69f641/tests%2Frustdoc%2Fissue-32374.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc%2Fissue-32374.rs?ref=18890f05f6cea40fd25bb4bb9aa6f7372b69f641", "patch": "@@ -2,9 +2,9 @@\n #![doc(issue_tracker_base_url = \"https://issue_url/\")]\n #![unstable(feature = \"test\", issue = \"32374\")]\n \n-// @matches issue_32374/index.html '//*[@class=\"item-left unstable deprecated module-item\"]/span[@class=\"stab deprecated\"]' \\\n+// @matches issue_32374/index.html '//*[@class=\"item-left unstable deprecated\"]/span[@class=\"stab deprecated\"]' \\\n //      'Deprecated'\n-// @matches issue_32374/index.html '//*[@class=\"item-left unstable deprecated module-item\"]/span[@class=\"stab unstable\"]' \\\n+// @matches issue_32374/index.html '//*[@class=\"item-left unstable deprecated\"]/span[@class=\"stab unstable\"]' \\\n //      'Experimental'\n // @matches issue_32374/index.html '//*[@class=\"item-right docblock-short\"]/text()' 'Docs'\n "}, {"sha": "b987da30ed29025994221a2ac04dc4cb14946738", "filename": "tests/rustdoc/issue-55364.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/18890f05f6cea40fd25bb4bb9aa6f7372b69f641/tests%2Frustdoc%2Fissue-55364.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18890f05f6cea40fd25bb4bb9aa6f7372b69f641/tests%2Frustdoc%2Fissue-55364.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc%2Fissue-55364.rs?ref=18890f05f6cea40fd25bb4bb9aa6f7372b69f641", "patch": "@@ -29,8 +29,8 @@ pub mod subone {\n // @has - '//section[@id=\"main-content\"]/details/div[@class=\"docblock\"]//a[@href=\"../fn.foo.html\"]' 'foo'\n // @has - '//section[@id=\"main-content\"]/details/div[@class=\"docblock\"]//a[@href=\"../fn.bar.html\"]' 'bar'\n // Though there should be such links later\n-// @has - '//section[@id=\"main-content\"]/div[@class=\"item-table\"]//div[@class=\"item-left module-item\"]/a[@class=\"fn\"][@href=\"fn.foo.html\"]' 'foo'\n-// @has - '//section[@id=\"main-content\"]/div[@class=\"item-table\"]//div[@class=\"item-left module-item\"]/a[@class=\"fn\"][@href=\"fn.bar.html\"]' 'bar'\n+// @has - '//section[@id=\"main-content\"]/div[@class=\"item-table\"]//div[@class=\"item-left\"]/a[@class=\"fn\"][@href=\"fn.foo.html\"]' 'foo'\n+// @has - '//section[@id=\"main-content\"]/div[@class=\"item-table\"]//div[@class=\"item-left\"]/a[@class=\"fn\"][@href=\"fn.bar.html\"]' 'bar'\n /// See either [foo] or [bar].\n pub mod subtwo {\n "}, {"sha": "9bce25846d8585dfb35ee558385219a80e812741", "filename": "tests/rustdoc/issue-83375-multiple-mods-w-same-name-doc-inline-last-item.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/18890f05f6cea40fd25bb4bb9aa6f7372b69f641/tests%2Frustdoc%2Fissue-83375-multiple-mods-w-same-name-doc-inline-last-item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18890f05f6cea40fd25bb4bb9aa6f7372b69f641/tests%2Frustdoc%2Fissue-83375-multiple-mods-w-same-name-doc-inline-last-item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc%2Fissue-83375-multiple-mods-w-same-name-doc-inline-last-item.rs?ref=18890f05f6cea40fd25bb4bb9aa6f7372b69f641", "patch": "@@ -11,6 +11,6 @@ pub mod sub {\n #[doc(inline)]\n pub use sub::*;\n \n-// @count foo/index.html '//a[@class=\"mod\"][@title=\"foo::prelude mod\"]' 1\n+// @count foo/index.html '//a[@class=\"mod\"][@title=\"mod foo::prelude\"]' 1\n // @count foo/prelude/index.html '//div[@class=\"item-row\"]' 0\n pub mod prelude {}"}, {"sha": "d0960dfef436246d1db5206def4790b291b91925", "filename": "tests/rustdoc/issue-83375-multiple-mods-w-same-name-doc-inline.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/18890f05f6cea40fd25bb4bb9aa6f7372b69f641/tests%2Frustdoc%2Fissue-83375-multiple-mods-w-same-name-doc-inline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18890f05f6cea40fd25bb4bb9aa6f7372b69f641/tests%2Frustdoc%2Fissue-83375-multiple-mods-w-same-name-doc-inline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc%2Fissue-83375-multiple-mods-w-same-name-doc-inline.rs?ref=18890f05f6cea40fd25bb4bb9aa6f7372b69f641", "patch": "@@ -8,7 +8,7 @@ pub mod sub {\n     }\n }\n \n-// @count foo/index.html '//a[@class=\"mod\"][@title=\"foo::prelude mod\"]' 1\n+// @count foo/index.html '//a[@class=\"mod\"][@title=\"mod foo::prelude\"]' 1\n // @count foo/prelude/index.html '//div[@class=\"item-row\"]' 0\n pub mod prelude {}\n "}, {"sha": "3df93eb7cf16f22b81647f079d36f93003f93be8", "filename": "tests/rustdoc/issue-95873.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/18890f05f6cea40fd25bb4bb9aa6f7372b69f641/tests%2Frustdoc%2Fissue-95873.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18890f05f6cea40fd25bb4bb9aa6f7372b69f641/tests%2Frustdoc%2Fissue-95873.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc%2Fissue-95873.rs?ref=18890f05f6cea40fd25bb4bb9aa6f7372b69f641", "patch": "@@ -1,2 +1,2 @@\n-// @has issue_95873/index.html \"//*[@class='item-left import-item']\" \"pub use ::std as x;\"\n+// @has issue_95873/index.html \"//*[@class='item-left']\" \"pub use ::std as x;\"\n pub use ::std as x;"}, {"sha": "ba29a77ebdff8ab41cd2beeaf1490740be4256cc", "filename": "tests/rustdoc/issue-99221-multiple-structs-w-same-name.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/18890f05f6cea40fd25bb4bb9aa6f7372b69f641/tests%2Frustdoc%2Fissue-99221-multiple-structs-w-same-name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18890f05f6cea40fd25bb4bb9aa6f7372b69f641/tests%2Frustdoc%2Fissue-99221-multiple-structs-w-same-name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc%2Fissue-99221-multiple-structs-w-same-name.rs?ref=18890f05f6cea40fd25bb4bb9aa6f7372b69f641", "patch": "@@ -9,6 +9,6 @@ extern crate issue_99221_aux;\n \n pub use issue_99221_aux::*;\n \n-// @count foo/index.html '//a[@class=\"struct\"][@title=\"foo::Print struct\"]' 1\n+// @count foo/index.html '//a[@class=\"struct\"][@title=\"struct foo::Print\"]' 1\n \n pub struct Print;"}, {"sha": "b56ec6e11eafc138dfe8897ef57c64a7aee065d2", "filename": "tests/rustdoc/issue-99734-multiple-foreigns-w-same-name.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/18890f05f6cea40fd25bb4bb9aa6f7372b69f641/tests%2Frustdoc%2Fissue-99734-multiple-foreigns-w-same-name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18890f05f6cea40fd25bb4bb9aa6f7372b69f641/tests%2Frustdoc%2Fissue-99734-multiple-foreigns-w-same-name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc%2Fissue-99734-multiple-foreigns-w-same-name.rs?ref=18890f05f6cea40fd25bb4bb9aa6f7372b69f641", "patch": "@@ -9,7 +9,7 @@ extern crate issue_99734_aux;\n \n pub use issue_99734_aux::*;\n \n-// @count foo/index.html '//a[@class=\"fn\"][@title=\"foo::main fn\"]' 1\n+// @count foo/index.html '//a[@class=\"fn\"][@title=\"fn foo::main\"]' 1\n \n extern \"C\" {\n     pub fn main() -> std::ffi::c_int;"}, {"sha": "8f5d6fa3d56d366c37f74ff988dbc4d720383c43", "filename": "tests/rustdoc/issue-99734-multiple-mods-w-same-name.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/18890f05f6cea40fd25bb4bb9aa6f7372b69f641/tests%2Frustdoc%2Fissue-99734-multiple-mods-w-same-name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18890f05f6cea40fd25bb4bb9aa6f7372b69f641/tests%2Frustdoc%2Fissue-99734-multiple-mods-w-same-name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc%2Fissue-99734-multiple-mods-w-same-name.rs?ref=18890f05f6cea40fd25bb4bb9aa6f7372b69f641", "patch": "@@ -9,6 +9,6 @@ extern crate issue_99734_aux;\n \n pub use issue_99734_aux::*;\n \n-// @count foo/index.html '//a[@class=\"mod\"][@title=\"foo::task mod\"]' 1\n+// @count foo/index.html '//a[@class=\"mod\"][@title=\"mod foo::task\"]' 1\n \n pub mod task {}"}, {"sha": "f3811fe0b0ad10781e70e9896016763f0e4886af", "filename": "tests/rustdoc/playground-arg.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/18890f05f6cea40fd25bb4bb9aa6f7372b69f641/tests%2Frustdoc%2Fplayground-arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18890f05f6cea40fd25bb4bb9aa6f7372b69f641/tests%2Frustdoc%2Fplayground-arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc%2Fplayground-arg.rs?ref=18890f05f6cea40fd25bb4bb9aa6f7372b69f641", "patch": "@@ -10,4 +10,4 @@\n pub fn dummy() {}\n \n // ensure that `extern crate foo;` was inserted into code snips automatically:\n-// @matches foo/index.html '//a[@class=\"test-arrow\"][@href=\"https://example.com/?code=%23!%5Ballow(unused)%5D%0Aextern%20crate%20r%23foo%3B%0Afn%20main()%20%7B%0Ause%20foo%3A%3Adummy%3B%0Adummy()%3B%0A%7D&edition=2015\"]' \"Run\"\n+// @matches foo/index.html '//a[@class=\"test-arrow\"][@href=\"https://example.com/?code=%23!%5Ballow(unused)%5D%0Aextern+crate+r%23foo;%0Afn+main()+%7B%0Ause+foo::dummy;%0Adummy();%0A%7D&edition=2015\"]' \"Run\""}, {"sha": "5c7fa33efc5e586a3be143e52174149497279edb", "filename": "tests/rustdoc/playground.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/18890f05f6cea40fd25bb4bb9aa6f7372b69f641/tests%2Frustdoc%2Fplayground.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18890f05f6cea40fd25bb4bb9aa6f7372b69f641/tests%2Frustdoc%2Fplayground.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc%2Fplayground.rs?ref=18890f05f6cea40fd25bb4bb9aa6f7372b69f641", "patch": "@@ -22,6 +22,6 @@\n //! }\n //! ```\n \n-// @matches foo/index.html '//a[@class=\"test-arrow\"][@href=\"https://www.example.com/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0A%20%20%20%20println!(%22Hello%2C%20world!%22)%3B%0A%7D&edition=2015\"]' \"Run\"\n-// @matches foo/index.html '//a[@class=\"test-arrow\"][@href=\"https://www.example.com/?code=%23!%5Ballow(unused)%5D%0Afn%20main()%20%7B%0Aprintln!(%22Hello%2C%20world!%22)%3B%0A%7D&edition=2015\"]' \"Run\"\n-// @matches foo/index.html '//a[@class=\"test-arrow\"][@href=\"https://www.example.com/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(something)%5D%0A%0Afn%20main()%20%7B%0A%20%20%20%20println!(%22Hello%2C%20world!%22)%3B%0A%7D&version=nightly&edition=2015\"]' \"Run\"\n+// @matches foo/index.html '//a[@class=\"test-arrow\"][@href=\"https://www.example.com/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0Aprintln!(%22Hello,+world!%22);%0A%7D&edition=2015\"]' \"Run\"\n+// @matches foo/index.html '//a[@class=\"test-arrow\"][@href=\"https://www.example.com/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++println!(%22Hello,+world!%22);%0A%7D&edition=2015\"]' \"Run\"\n+// @matches foo/index.html '//a[@class=\"test-arrow\"][@href=\"https://www.example.com/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(something)%5D%0A%0Afn+main()+%7B%0A++++println!(%22Hello,+world!%22);%0A%7D&version=nightly&edition=2015\"]' \"Run\""}, {"sha": "acac0c9919716b067e8b4a7ffdc30e51beebdeba", "filename": "tests/rustdoc/reexport-check.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/18890f05f6cea40fd25bb4bb9aa6f7372b69f641/tests%2Frustdoc%2Freexport-check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18890f05f6cea40fd25bb4bb9aa6f7372b69f641/tests%2Frustdoc%2Freexport-check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc%2Freexport-check.rs?ref=18890f05f6cea40fd25bb4bb9aa6f7372b69f641", "patch": "@@ -4,12 +4,12 @@\n extern crate reexport_check;\n \n // @!has 'foo/index.html' '//code' 'pub use self::i32;'\n-// @has 'foo/index.html' '//div[@class=\"item-left deprecated module-item\"]' 'i32'\n+// @has 'foo/index.html' '//div[@class=\"item-left deprecated\"]' 'i32'\n // @has 'foo/i32/index.html'\n #[allow(deprecated, deprecated_in_future)]\n pub use std::i32;\n // @!has 'foo/index.html' '//code' 'pub use self::string::String;'\n-// @has 'foo/index.html' '//div[@class=\"item-left module-item\"]' 'String'\n+// @has 'foo/index.html' '//div[@class=\"item-left\"]' 'String'\n pub use std::string::String;\n \n // @has 'foo/index.html' '//div[@class=\"item-right docblock-short\"]' 'Docs in original'"}]}