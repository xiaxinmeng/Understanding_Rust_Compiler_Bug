{"sha": "b250d9a3c83e046d2abfcf7911c640865e36e430", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIyNTBkOWEzYzgzZTA0NmQyYWJmY2Y3OTExYzY0MDg2NWUzNmU0MzA=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-01-21T17:13:46Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-01-21T17:13:46Z"}, "message": "rollup merge of #21289: brson/errorcodes\n\nThis does the bare minimum to make registration of error codes work again. After this patch, every call to `span_err!` with an error code gets that error code validated against a list in that crate and a new tidy script `errorck.py` validates that no error codes are duplicated globally.\n\nThere are further improvements to be made yet, detailed in #19624.\n\nr? @nikomatsakis", "tree": {"sha": "761d242e453c6858be8c0b5b186dec3bd9298bac", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/761d242e453c6858be8c0b5b186dec3bd9298bac"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b250d9a3c83e046d2abfcf7911c640865e36e430", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b250d9a3c83e046d2abfcf7911c640865e36e430", "html_url": "https://github.com/rust-lang/rust/commit/b250d9a3c83e046d2abfcf7911c640865e36e430", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b250d9a3c83e046d2abfcf7911c640865e36e430/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "41890bfa46d6cfd4a822f82e65a5f98f9bb604a0", "url": "https://api.github.com/repos/rust-lang/rust/commits/41890bfa46d6cfd4a822f82e65a5f98f9bb604a0", "html_url": "https://github.com/rust-lang/rust/commit/41890bfa46d6cfd4a822f82e65a5f98f9bb604a0"}, {"sha": "876b26645913f7e600f5919db166ec5db0219aaf", "url": "https://api.github.com/repos/rust-lang/rust/commits/876b26645913f7e600f5919db166ec5db0219aaf", "html_url": "https://github.com/rust-lang/rust/commit/876b26645913f7e600f5919db166ec5db0219aaf"}], "stats": {"total": 1094, "additions": 618, "deletions": 476}, "files": [{"sha": "32d4d178e6b8c65a4ad0435d8cb3101540cc2e35", "filename": "mk/tests.mk", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b250d9a3c83e046d2abfcf7911c640865e36e430/mk%2Ftests.mk", "raw_url": "https://github.com/rust-lang/rust/raw/b250d9a3c83e046d2abfcf7911c640865e36e430/mk%2Ftests.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Ftests.mk?ref=b250d9a3c83e046d2abfcf7911c640865e36e430", "patch": "@@ -300,6 +300,7 @@ tidy:\n \t\t| grep '^$(S)src/libbacktrace' -v \\\n \t\t| grep '^$(S)src/rust-installer' -v \\\n \t\t| xargs $(CFG_PYTHON) $(S)src/etc/check-binaries.py\n+\t\t$(Q) $(CFG_PYTHON) $(S)src/etc/errorck.py $(S)src/\n \n \n endif"}, {"sha": "17659309d3b0d6822dcedb2b0f773e06d0b1187f", "filename": "src/etc/errorck.py", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/b250d9a3c83e046d2abfcf7911c640865e36e430/src%2Fetc%2Ferrorck.py", "raw_url": "https://github.com/rust-lang/rust/raw/b250d9a3c83e046d2abfcf7911c640865e36e430/src%2Fetc%2Ferrorck.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Ferrorck.py?ref=b250d9a3c83e046d2abfcf7911c640865e36e430", "patch": "@@ -0,0 +1,70 @@\n+# Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+# file at the top-level directory of this distribution and at\n+# http://rust-lang.org/COPYRIGHT.\n+#\n+# Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+# http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+# <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+# option. This file may not be copied, modified, or distributed\n+# except according to those terms.\n+\n+# Digs error codes out of files named 'diagnostics.rs' across\n+# the tree, and ensures thare are no duplicates.\n+\n+import sys, os, re\n+\n+src_dir = sys.argv[1]\n+\n+errcode_map = { }\n+\n+for (dirpath, dirnames, filenames) in os.walk(src_dir):\n+\n+    if \"src/test\" in dirpath or \"src/llvm\" in dirpath:\n+        # Short circuit for fast\n+        continue\n+\n+    for filename in filenames:\n+        if filename != \"diagnostics.rs\":\n+            continue\n+\n+        path = os.path.join(dirpath, filename)\n+        line_num = 1\n+        with open(path, 'r') as f:\n+            for line in f:\n+\n+                p = re.compile(\"(E\\d\\d\\d\\d)\")\n+                m = p.search(line)\n+                if not m is None:\n+                    errcode = m.group(1)\n+\n+                    new_record = [(errcode, path, line_num, line)]\n+                    existing = errcode_map.get(errcode)\n+                    if existing is not None:\n+                        # This is a dupe\n+                        errcode_map[errcode] = existing + new_record\n+                    else:\n+                        errcode_map[errcode] = new_record\n+\n+                line_num += 1\n+\n+errors = False\n+all_errors = []\n+for errcode in errcode_map:\n+    entries = errcode_map[errcode]\n+    all_errors += [entries[0][0]]\n+    if len(entries) > 1:\n+        print \"error: duplicate error code \" + errcode\n+        for entry in entries:\n+            print entry[1] + \": \" + str(entry[2])\n+            print entry[3]\n+        errors = True\n+\n+print str(len(errcode_map)) + \" error codes\"\n+\n+all_errors.sort()\n+all_errors.reverse()\n+\n+print \"highest error code: \" + all_errors[0]\n+\n+if errors:\n+    sys.exit(1)"}, {"sha": "b48df36a6793118c72b1526bd6ed3ad6d02260bc", "filename": "src/librustc/diagnostics.rs", "status": "modified", "additions": 82, "deletions": 21, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/b250d9a3c83e046d2abfcf7911c640865e36e430/src%2Flibrustc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b250d9a3c83e046d2abfcf7911c640865e36e430/src%2Flibrustc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdiagnostics.rs?ref=b250d9a3c83e046d2abfcf7911c640865e36e430", "patch": "@@ -10,28 +10,55 @@\n \n #![allow(non_snake_case)]\n \n-register_diagnostic! { E0001, r##\"\n+register_long_diagnostics! {\n+    E0001: r##\"\n     This error suggests that the expression arm corresponding to the noted pattern\n     will never be reached as for all possible values of the expression being matched,\n     one of the preceeding patterns will match.\n \n     This means that perhaps some of the preceeding patterns are too general, this\n     one is too specific or the ordering is incorrect.\n-\"## }\n+\"##,\n+\n+    E0003: r##\"\n+    Not-a-Number (NaN) values can not be compared for equality and hence can never match\n+    the input to a match expression. To match against NaN values, you should instead use\n+    the `is_nan` method in a guard, as in: x if x.is_nan() => ...\n+\"##,\n+\n+    E0004: r##\"\n+    This error indicates that the compiler can not guarantee a matching pattern for one\n+    or more possible inputs to a match expression. Guaranteed matches are required in order\n+    to assign values to match expressions, or alternatively, determine the flow of execution.\n+\n+    If you encounter this error you must alter your patterns so that every possible value of\n+    the input type is matched. For types with a small number of variants (like enums) you\n+    should probably cover all cases explicitly. Alternatively, the underscore `_` wildcard\n+    pattern can be added after all other patterns to match \"anything else\".\n+\"##,\n+\n+    // FIXME: Remove duplication here?\n+    E0005: r##\"\n+    Patterns used to bind names must be irrefutable, that is, they must guarantee that a\n+    name will be extracted in all cases. If you encounter this error you probably need\n+    to use a `match` or `if let` to deal with the possibility of failure.\n+\"##,\n+\n+    E0006: r##\"\n+    Patterns used to bind names must be irrefutable, that is, they must guarantee that a\n+    name will be extracted in all cases. If you encounter this error you probably need\n+    to use a `match` or `if let` to deal with the possibility of failure.\n+\"##\n+}\n \n register_diagnostics! {\n     E0002,\n-    E0003,\n-    E0004,\n-    E0005,\n-    E0006,\n     E0007,\n     E0008,\n     E0009,\n     E0010,\n     E0011,\n     E0012,\n-    E0013,\n     E0014,\n     E0015,\n     E0016,\n@@ -49,24 +76,58 @@ register_diagnostics! {\n     E0137,\n     E0138,\n     E0139,\n-    E0140,\n     E0152,\n-    E0153,\n-    E0157,\n     E0158,\n     E0161,\n     E0162,\n     E0165,\n-    E0166,\n-    E0167,\n-    E0168,\n-    E0169,\n     E0170,\n-    E0171,\n-    E0172,\n-    E0173,\n-    E0174,\n-    E0177,\n-    E0178,\n-    E0179\n+    E0261, // use of undeclared lifetime name\n+    E0262, // illegal lifetime parameter name\n+    E0263, // lifetime name declared twice in same scope\n+    E0264, // unknown external lang item\n+    E0265, // recursive constant\n+    E0266, // expected item\n+    E0267, // thing inside of a closure\n+    E0268, // thing outside of a loop\n+    E0269, // not all control paths return a value\n+    E0270, // computation may converge in a function marked as diverging\n+    E0271, // type mismatch resolving\n+    E0272, // rustc_on_unimplemented attribute refers to non-existent type parameter\n+    E0273, // rustc_on_unimplemented must have named format arguments\n+    E0274, // rustc_on_unimplemented must have a value\n+    E0275, // overflow evaluating requirement\n+    E0276, // requirement appears on impl method but not on corresponding trait method\n+    E0277, // trait is not implemented for type\n+    E0278, // requirement is not satisfied\n+    E0279, // requirement is not satisfied\n+    E0280, // requirement is not satisfied\n+    E0281, // type implements trait but other trait is required\n+    E0282, // unable to infer enough type information about\n+    E0283, // cannot resolve type\n+    E0284, // cannot resolve type\n+    E0285, // overflow evaluation builtin bounds\n+    E0296, // malformed recursion limit attribute\n+    E0297, // refutable pattern in for loop binding\n+    E0298, // mismatched types between arms\n+    E0299, // mismatched types between arms\n+    E0300, // unexpanded macro\n+    E0301, // cannot mutable borrow in a pattern guard\n+    E0302, // cannot assign in a pattern guard\n+    E0303, // pattern bindings are not allowed after an `@`\n+    E0304, // expected signed integer constant\n+    E0305, // expected constant\n+    E0306, // expected positive integer for repeat count\n+    E0307, // expected constant integer for repeat count\n+    E0308,\n+    E0309, // thing may not live long enough\n+    E0310, // thing may not live long enough\n+    E0311, // thing may not live long enough\n+    E0312, // lifetime of reference outlives lifetime of borrowed content\n+    E0313, // lifetime of borrowed pointer outlives lifetime of captured variable\n+    E0314, // closure outlives stack frame\n+    E0315 // cannot invoke closure outside of its lifetime\n }\n+\n+__build_diagnostic_array! { DIAGNOSTICS }\n+"}, {"sha": "377e5dd39ff57fe7ae0a4f033fffd8925ffa284d", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b250d9a3c83e046d2abfcf7911c640865e36e430/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b250d9a3c83e046d2abfcf7911c640865e36e430/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=b250d9a3c83e046d2abfcf7911c640865e36e430", "patch": "@@ -54,7 +54,9 @@ extern crate test;\n \n pub use rustc_llvm as llvm;\n \n-mod diagnostics;\n+// NB: This module needs to be declared first so diagnostics are\n+// registered before they are used.\n+pub mod diagnostics;\n \n pub mod back {\n     pub use rustc_back::abi;\n@@ -132,8 +134,6 @@ pub mod lib {\n     pub use llvm;\n }\n \n-__build_diagnostic_array! { DIAGNOSTICS }\n-\n // A private module so that macro-expanded idents like\n // `::rustc::lint::Lint` will also work in `rustc` itself.\n //"}, {"sha": "623f3525d4a90b3111740d20ce7e43b51d50c38a", "filename": "src/librustc/middle/check_loop.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b250d9a3c83e046d2abfcf7911c640865e36e430/src%2Flibrustc%2Fmiddle%2Fcheck_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b250d9a3c83e046d2abfcf7911c640865e36e430/src%2Flibrustc%2Fmiddle%2Fcheck_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_loop.rs?ref=b250d9a3c83e046d2abfcf7911c640865e36e430", "patch": "@@ -73,12 +73,12 @@ impl<'a> CheckLoopVisitor<'a> {\n         match self.cx {\n             Loop => {}\n             Closure => {\n-                self.sess.span_err(span,\n-                                   &format!(\"`{}` inside of a closure\", name)[]);\n+                span_err!(self.sess, span, E0267,\n+                                   \"`{}` inside of a closure\", name);\n             }\n             Normal => {\n-                self.sess.span_err(span,\n-                                   &format!(\"`{}` outside of loop\", name)[]);\n+                span_err!(self.sess, span, E0268,\n+                                   \"`{}` outside of loop\", name);\n             }\n         }\n     }"}, {"sha": "f6db0cf755b9c9b4318dda54465c4e03c4dc204d", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 10, "deletions": 17, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/b250d9a3c83e046d2abfcf7911c640865e36e430/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b250d9a3c83e046d2abfcf7911c640865e36e430/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=b250d9a3c83e046d2abfcf7911c640865e36e430", "patch": "@@ -226,11 +226,10 @@ fn check_expr(cx: &mut MatchCheckCtxt, ex: &ast::Expr) {\n         ast::ExprForLoop(ref pat, _, _, _) => {\n             let mut static_inliner = StaticInliner::new(cx.tcx);\n             is_refutable(cx, &*static_inliner.fold_pat((*pat).clone()), |uncovered_pat| {\n-                cx.tcx.sess.span_err(\n-                    pat.span,\n-                    &format!(\"refutable pattern in `for` loop binding: \\\n+                span_err!(cx.tcx.sess, pat.span, E0297,\n+                    \"refutable pattern in `for` loop binding: \\\n                             `{}` not covered\",\n-                            pat_to_string(uncovered_pat))[]);\n+                            pat_to_string(uncovered_pat));\n             });\n \n             // Check legality of move bindings.\n@@ -869,7 +868,7 @@ pub fn specialize<'a>(cx: &MatchCheckCtxt, r: &[&'a Pat],\n                 Some(true) => Some(vec![]),\n                 Some(false) => None,\n                 None => {\n-                    cx.tcx.sess.span_err(pat_span, \"mismatched types between arms\");\n+                    span_err!(cx.tcx.sess, pat_span, E0298, \"mismatched types between arms\");\n                     None\n                 }\n             }\n@@ -882,7 +881,7 @@ pub fn specialize<'a>(cx: &MatchCheckCtxt, r: &[&'a Pat],\n                 Some(true) => Some(vec![]),\n                 Some(false) => None,\n                 None => {\n-                    cx.tcx.sess.span_err(pat_span, \"mismatched types between arms\");\n+                    span_err!(cx.tcx.sess, pat_span, E0299, \"mismatched types between arms\");\n                     None\n                 }\n             }\n@@ -921,7 +920,7 @@ pub fn specialize<'a>(cx: &MatchCheckCtxt, r: &[&'a Pat],\n         }\n \n         ast::PatMac(_) => {\n-            cx.tcx.sess.span_err(pat_span, \"unexpanded macro\");\n+            span_err!(cx.tcx.sess, pat_span, E0300, \"unexpanded macro\");\n             None\n         }\n     };\n@@ -1082,11 +1081,8 @@ impl<'a, 'tcx> Delegate<'tcx> for MutationChecker<'a, 'tcx> {\n               _: LoanCause) {\n         match kind {\n             MutBorrow => {\n-                self.cx\n-                    .tcx\n-                    .sess\n-                    .span_err(span,\n-                              \"cannot mutably borrow in a pattern guard\")\n+                span_err!(self.cx.tcx.sess, span, E0301,\n+                          \"cannot mutably borrow in a pattern guard\")\n             }\n             ImmBorrow | UniqueImmBorrow => {}\n         }\n@@ -1095,10 +1091,7 @@ impl<'a, 'tcx> Delegate<'tcx> for MutationChecker<'a, 'tcx> {\n     fn mutate(&mut self, _: NodeId, span: Span, _: cmt, mode: MutateMode) {\n         match mode {\n             JustWrite | WriteAndRead => {\n-                self.cx\n-                    .tcx\n-                    .sess\n-                    .span_err(span, \"cannot assign in a pattern guard\")\n+                span_err!(self.cx.tcx.sess, span, E0302, \"cannot assign in a pattern guard\")\n             }\n             Init => {}\n         }\n@@ -1120,7 +1113,7 @@ struct AtBindingPatternVisitor<'a, 'b:'a, 'tcx:'b> {\n impl<'a, 'b, 'tcx, 'v> Visitor<'v> for AtBindingPatternVisitor<'a, 'b, 'tcx> {\n     fn visit_pat(&mut self, pat: &Pat) {\n         if !self.bindings_allowed && pat_is_binding(&self.cx.tcx.def_map, pat) {\n-            self.cx.tcx.sess.span_err(pat.span,\n+            span_err!(self.cx.tcx.sess, pat.span, E0303,\n                                       \"pattern bindings are not allowed \\\n                                        after an `@`\");\n         }"}, {"sha": "4280b7fe3f09649170a73dc7e37f90873a22fa9f", "filename": "src/librustc/middle/check_static_recursion.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b250d9a3c83e046d2abfcf7911c640865e36e430/src%2Flibrustc%2Fmiddle%2Fcheck_static_recursion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b250d9a3c83e046d2abfcf7911c640865e36e430/src%2Flibrustc%2Fmiddle%2Fcheck_static_recursion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_static_recursion.rs?ref=b250d9a3c83e046d2abfcf7911c640865e36e430", "patch": "@@ -83,7 +83,7 @@ pub fn check_item_recursion<'a>(sess: &'a Session,\n impl<'a, 'ast, 'v> Visitor<'v> for CheckItemRecursionVisitor<'a, 'ast> {\n     fn visit_item(&mut self, it: &ast::Item) {\n         if self.idstack.iter().any(|x| x == &(it.id)) {\n-            self.sess.span_err(self.root_it.span, \"recursive constant\");\n+            span_err!(self.sess, self.root_it.span, E0265, \"recursive constant\");\n             return;\n         }\n         self.idstack.push(it.id);\n@@ -103,9 +103,9 @@ impl<'a, 'ast, 'v> Visitor<'v> for CheckItemRecursionVisitor<'a, 'ast> {\n                             self.visit_item(item),\n                           ast_map::NodeForeignItem(_) => {},\n                           _ => {\n-                            self.sess.span_err(e.span,\n-                              &format!(\"expected item, found {}\",\n-                                      self.ast_map.node_to_string(def_id.node))[]);\n+                            span_err!(self.sess, e.span, E0266,\n+                              \"expected item, found {}\",\n+                                      self.ast_map.node_to_string(def_id.node));\n                             return;\n                           },\n                         }"}, {"sha": "18c36f870b5bce09da24a3222f81d46bc56a487f", "filename": "src/librustc/middle/infer/error_reporting.rs", "status": "modified", "additions": 15, "deletions": 24, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/b250d9a3c83e046d2abfcf7911c640865e36e430/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b250d9a3c83e046d2abfcf7911c640865e36e430/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs?ref=b250d9a3c83e046d2abfcf7911c640865e36e430", "patch": "@@ -371,12 +371,11 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n             infer::EquatePredicate(_) => \"equality predicate not satisfied\",\n         };\n \n-        self.tcx.sess.span_err(\n-            trace.origin.span(),\n-            &format!(\"{}: {} ({})\",\n+        span_err!(self.tcx.sess, trace.origin.span(), E0308,\n+            \"{}: {} ({})\",\n                  message_root_str,\n                  expected_found_str,\n-                 ty::type_err_to_str(self.tcx, terr))[]);\n+                 ty::type_err_to_str(self.tcx, terr));\n \n         match trace.origin {\n             infer::MatchExpressionArm(_, arm_span) =>\n@@ -443,9 +442,8 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n         match sub {\n             ty::ReFree(ty::FreeRegion {bound_region: ty::BrNamed(..), ..}) => {\n                 // Does the required lifetime have a nice name we can print?\n-                self.tcx.sess.span_err(\n-                    origin.span(),\n-                    &format!(\"{} may not live long enough\", labeled_user_string)[]);\n+                span_err!(self.tcx.sess, origin.span(), E0309,\n+                    \"{} may not live long enough\", labeled_user_string);\n                 self.tcx.sess.span_help(\n                     origin.span(),\n                     &format!(\n@@ -456,9 +454,8 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n \n             ty::ReStatic => {\n                 // Does the required lifetime have a nice name we can print?\n-                self.tcx.sess.span_err(\n-                    origin.span(),\n-                    &format!(\"{} may not live long enough\", labeled_user_string)[]);\n+                span_err!(self.tcx.sess, origin.span(), E0310,\n+                    \"{} may not live long enough\", labeled_user_string);\n                 self.tcx.sess.span_help(\n                     origin.span(),\n                     &format!(\n@@ -468,11 +465,9 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n \n             _ => {\n                 // If not, be less specific.\n-                self.tcx.sess.span_err(\n-                    origin.span(),\n-                    &format!(\n+                span_err!(self.tcx.sess, origin.span(), E0311,\n                         \"{} may not live long enough\",\n-                        labeled_user_string)[]);\n+                        labeled_user_string);\n                 self.tcx.sess.span_help(\n                     origin.span(),\n                     &format!(\n@@ -499,8 +494,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                 self.report_and_explain_type_error(trace, &terr);\n             }\n             infer::Reborrow(span) => {\n-                self.tcx.sess.span_err(\n-                    span,\n+                span_err!(self.tcx.sess, span, E0312,\n                     \"lifetime of reference outlines \\\n                      lifetime of borrowed content...\");\n                 note_and_explain_region(\n@@ -515,14 +509,13 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                     \"\");\n             }\n             infer::ReborrowUpvar(span, ref upvar_id) => {\n-                self.tcx.sess.span_err(\n-                    span,\n-                    &format!(\"lifetime of borrowed pointer outlives \\\n+                span_err!(self.tcx.sess, span, E0313,\n+                    \"lifetime of borrowed pointer outlives \\\n                             lifetime of captured variable `{}`...\",\n                             ty::local_var_name_str(self.tcx,\n                                                    upvar_id.var_id)\n                                 .get()\n-                                .to_string())[]);\n+                                .to_string());\n                 note_and_explain_region(\n                     self.tcx,\n                     \"...the borrowed pointer is valid for \",\n@@ -539,8 +532,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                     \"\");\n             }\n             infer::InfStackClosure(span) => {\n-                self.tcx.sess.span_err(\n-                    span,\n+                span_err!(self.tcx.sess, span, E0314,\n                     \"closure outlives stack frame\");\n                 note_and_explain_region(\n                     self.tcx,\n@@ -554,8 +546,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                     \"\");\n             }\n             infer::InvokeClosure(span) => {\n-                self.tcx.sess.span_err(\n-                    span,\n+                span_err!(self.tcx.sess, span, E0315,\n                     \"cannot invoke closure outside of its lifetime\");\n                 note_and_explain_region(\n                     self.tcx,"}, {"sha": "f71779e23333f80d6de43509b86b86c0b1a0ba38", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b250d9a3c83e046d2abfcf7911c640865e36e430/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b250d9a3c83e046d2abfcf7911c640865e36e430/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=b250d9a3c83e046d2abfcf7911c640865e36e430", "patch": "@@ -1557,8 +1557,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n                             },\n                         _ => false\n                     };\n-                    self.ir.tcx.sess.span_err(\n-                        sp, \"not all control paths return a value\");\n+                    span_err!(self.ir.tcx.sess, sp, E0269, \"not all control paths return a value\");\n                     if ends_with_stmt {\n                         let last_stmt = body.stmts.first().unwrap();\n                         let original_span = original_sp(self.ir.tcx.sess.codemap(),\n@@ -1575,7 +1574,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n             }\n             ty::FnDiverging\n                 if self.live_on_entry(entry_ln, self.s.clean_exit_var).is_some() => {\n-                    self.ir.tcx.sess.span_err(sp,\n+                    span_err!(self.ir.tcx.sess, sp, E0270,\n                         \"computation may converge in a function marked as diverging\");\n                 }\n "}, {"sha": "81cbdf13c518925c60ef57b9b1d260a42fb8b870", "filename": "src/librustc/middle/recursion_limit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b250d9a3c83e046d2abfcf7911c640865e36e430/src%2Flibrustc%2Fmiddle%2Frecursion_limit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b250d9a3c83e046d2abfcf7911c640865e36e430/src%2Flibrustc%2Fmiddle%2Frecursion_limit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Frecursion_limit.rs?ref=b250d9a3c83e046d2abfcf7911c640865e36e430", "patch": "@@ -33,7 +33,7 @@ pub fn update_recursion_limit(sess: &Session, krate: &ast::Crate) {\n             }\n         }\n \n-        sess.span_err(attr.span, \"malformed recursion limit attribute, \\\n+        span_err!(sess, attr.span, E0296, \"malformed recursion limit attribute, \\\n                                   expected #![recursion_limit=\\\"N\\\"]\");\n     }\n }"}, {"sha": "be2b3026755b203ea9a433b89513c99f5d3fc012", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 9, "deletions": 14, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/b250d9a3c83e046d2abfcf7911c640865e36e430/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b250d9a3c83e046d2abfcf7911c640865e36e430/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=b250d9a3c83e046d2abfcf7911c640865e36e430", "patch": "@@ -396,10 +396,9 @@ impl<'a> LifetimeContext<'a> {\n     }\n \n     fn unresolved_lifetime_ref(&self, lifetime_ref: &ast::Lifetime) {\n-        self.sess.span_err(\n-            lifetime_ref.span,\n-            &format!(\"use of undeclared lifetime name `{}`\",\n-                    token::get_name(lifetime_ref.name))[]);\n+        span_err!(self.sess, lifetime_ref.span, E0261,\n+            \"use of undeclared lifetime name `{}`\",\n+                    token::get_name(lifetime_ref.name));\n     }\n \n     fn check_lifetime_defs(&mut self, old_scope: Scope, lifetimes: &Vec<ast::LifetimeDef>) {\n@@ -409,11 +408,9 @@ impl<'a> LifetimeContext<'a> {\n             let special_idents = [special_idents::static_lifetime];\n             for lifetime in lifetimes.iter() {\n                 if special_idents.iter().any(|&i| i.name == lifetime.lifetime.name) {\n-                    self.sess.span_err(\n-                        lifetime.lifetime.span,\n-                        &format!(\"illegal lifetime parameter name: `{}`\",\n-                                token::get_name(lifetime.lifetime.name))\n-                        []);\n+                    span_err!(self.sess, lifetime.lifetime.span, E0262,\n+                        \"illegal lifetime parameter name: `{}`\",\n+                                token::get_name(lifetime.lifetime.name));\n                 }\n             }\n \n@@ -422,12 +419,10 @@ impl<'a> LifetimeContext<'a> {\n                 let lifetime_j = &lifetimes[j];\n \n                 if lifetime_i.lifetime.name == lifetime_j.lifetime.name {\n-                    self.sess.span_err(\n-                        lifetime_j.lifetime.span,\n-                        &format!(\"lifetime name `{}` declared twice in \\\n+                    span_err!(self.sess, lifetime_j.lifetime.span, E0263,\n+                        \"lifetime name `{}` declared twice in \\\n                                 the same scope\",\n-                                token::get_name(lifetime_j.lifetime.name))\n-                        []);\n+                                token::get_name(lifetime_j.lifetime.name));\n                 }\n             }\n "}, {"sha": "93805750606efa8afe4e511b9e99d489afc0b9ca", "filename": "src/librustc/middle/traits/error_reporting.rs", "status": "modified", "additions": 31, "deletions": 56, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/b250d9a3c83e046d2abfcf7911c640865e36e430/src%2Flibrustc%2Fmiddle%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b250d9a3c83e046d2abfcf7911c640865e36e430/src%2Flibrustc%2Fmiddle%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Ferror_reporting.rs?ref=b250d9a3c83e046d2abfcf7911c640865e36e430", "patch": "@@ -55,12 +55,10 @@ pub fn report_projection_error<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n     let predicate =\n         infcx.resolve_type_vars_if_possible(&obligation.predicate);\n     if !predicate.references_error() {\n-        infcx.tcx.sess.span_err(\n-            obligation.cause.span,\n-            format!(\n+        span_err!(infcx.tcx.sess, obligation.cause.span, E0271,\n                 \"type mismatch resolving `{}`: {}\",\n                 predicate.user_string(infcx.tcx),\n-                ty::type_err_to_str(infcx.tcx, &error.err)).as_slice());\n+                ty::type_err_to_str(infcx.tcx, &error.err));\n         note_obligation_cause(infcx, obligation);\n     }\n }\n@@ -97,28 +95,25 @@ fn report_on_unimplemented<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n                             Position::ArgumentNamed(s) => match generic_map.get(s) {\n                                 Some(val) => Some(val.as_slice()),\n                                 None => {\n-                                    infcx.tcx.sess\n-                                         .span_err(err_sp,\n-                                                   format!(\"the #[rustc_on_unimplemented] \\\n+                                    span_err!(infcx.tcx.sess, err_sp, E0272,\n+                                                   \"the #[rustc_on_unimplemented] \\\n                                                             attribute on \\\n                                                             trait definition for {} refers to \\\n                                                             non-existent type parameter {}\",\n-                                                           trait_str, s)\n-                                                   .as_slice());\n+                                                           trait_str, s);\n                                     errored = true;\n                                     None\n                                 }\n                             },\n                             _ => {\n-                                infcx.tcx.sess\n-                                     .span_err(err_sp,\n-                                               format!(\"the #[rustc_on_unimplemented] \\\n+                                     span_err!(infcx.tcx.sess, err_sp, E0273,\n+                                               \"the #[rustc_on_unimplemented] \\\n                                                         attribute on \\\n                                                         trait definition for {} must have named \\\n                                                         format arguments, \\\n                                                         eg `#[rustc_on_unimplemented = \\\n                                                         \\\"foo {{T}}\\\"]`\",\n-                                                       trait_str).as_slice());\n+                                                       trait_str);\n                                 errored = true;\n                                 None\n                             }\n@@ -130,11 +125,11 @@ fn report_on_unimplemented<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n                     report = Some(err);\n                 }\n             } else {\n-                infcx.tcx.sess.span_err(err_sp,\n-                                        format!(\"the #[rustc_on_unimplemented] attribute on \\\n+                span_err!(infcx.tcx.sess, err_sp, E0274,\n+                                        \"the #[rustc_on_unimplemented] attribute on \\\n                                                  trait definition for {} must have a value, \\\n                                                  eg `#[rustc_on_unimplemented = \\\"foo\\\"]`\",\n-                                                 trait_str).as_slice());\n+                                                 trait_str);\n             }\n             break;\n         }\n@@ -151,11 +146,9 @@ pub fn report_selection_error<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n             // We could track the stack here more precisely if we wanted, I imagine.\n             let predicate =\n                 infcx.resolve_type_vars_if_possible(&obligation.predicate);\n-            infcx.tcx.sess.span_err(\n-                obligation.cause.span,\n-                format!(\n+            span_err!(infcx.tcx.sess, obligation.cause.span, E0275,\n                     \"overflow evaluating the requirement `{}`\",\n-                    predicate.user_string(infcx.tcx)).as_slice());\n+                    predicate.user_string(infcx.tcx));\n \n             suggest_new_overflow_limit(infcx.tcx, obligation.cause.span);\n \n@@ -165,12 +158,10 @@ pub fn report_selection_error<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n         SelectionError::Unimplemented => {\n             match &obligation.cause.code {\n                 &ObligationCauseCode::CompareImplMethodObligation => {\n-                    infcx.tcx.sess.span_err(\n-                        obligation.cause.span,\n-                        format!(\n+                    span_err!(infcx.tcx.sess, obligation.cause.span, E0276,\n                             \"the requirement `{}` appears on the impl \\\n                             method but not on the corresponding trait method\",\n-                            obligation.predicate.user_string(infcx.tcx)).as_slice());\n+                            obligation.predicate.user_string(infcx.tcx));;\n                 }\n                 _ => {\n                     match obligation.predicate {\n@@ -180,12 +171,10 @@ pub fn report_selection_error<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n \n                             if !trait_predicate.references_error() {\n                                 let trait_ref = trait_predicate.to_poly_trait_ref();\n-                                infcx.tcx.sess.span_err(\n-                                    obligation.cause.span,\n-                                    format!(\n+                                span_err!(infcx.tcx.sess, obligation.cause.span, E0277,\n                                         \"the trait `{}` is not implemented for the type `{}`\",\n                                         trait_ref.user_string(infcx.tcx),\n-                                        trait_ref.self_ty().user_string(infcx.tcx)).as_slice());\n+                                        trait_ref.self_ty().user_string(infcx.tcx));\n                                 // Check if it has a custom \"#[rustc_on_unimplemented]\"\n                                 // error message, report with that message if it does\n                                 let custom_note = report_on_unimplemented(infcx, &*trait_ref.0,\n@@ -201,34 +190,28 @@ pub fn report_selection_error<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n                             let predicate = infcx.resolve_type_vars_if_possible(predicate);\n                             let err = infcx.equality_predicate(obligation.cause.span,\n                                                                &predicate).unwrap_err();\n-                            infcx.tcx.sess.span_err(\n-                                obligation.cause.span,\n-                                format!(\n+                            span_err!(infcx.tcx.sess, obligation.cause.span, E0278,\n                                     \"the requirement `{}` is not satisfied (`{}`)\",\n                                     predicate.user_string(infcx.tcx),\n-                                    ty::type_err_to_str(infcx.tcx, &err)).as_slice());\n+                                    ty::type_err_to_str(infcx.tcx, &err));\n                         }\n \n                         ty::Predicate::RegionOutlives(ref predicate) => {\n                             let predicate = infcx.resolve_type_vars_if_possible(predicate);\n                             let err = infcx.region_outlives_predicate(obligation.cause.span,\n                                                                       &predicate).unwrap_err();\n-                            infcx.tcx.sess.span_err(\n-                                obligation.cause.span,\n-                                format!(\n+                            span_err!(infcx.tcx.sess, obligation.cause.span, E0279,\n                                     \"the requirement `{}` is not satisfied (`{}`)\",\n                                     predicate.user_string(infcx.tcx),\n-                                    ty::type_err_to_str(infcx.tcx, &err)).as_slice());\n+                                    ty::type_err_to_str(infcx.tcx, &err));\n                         }\n \n                         ty::Predicate::Projection(..) | ty::Predicate::TypeOutlives(..) => {\n                                 let predicate =\n                                     infcx.resolve_type_vars_if_possible(&obligation.predicate);\n-                                infcx.tcx.sess.span_err(\n-                                    obligation.cause.span,\n-                                    format!(\n+                                span_err!(infcx.tcx.sess, obligation.cause.span, E0280,\n                                         \"the requirement `{}` is not satisfied\",\n-                                        predicate.user_string(infcx.tcx)).as_slice());\n+                                        predicate.user_string(infcx.tcx));\n                         }\n                     }\n                 }\n@@ -239,15 +222,13 @@ pub fn report_selection_error<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n             let expected_trait_ref = infcx.resolve_type_vars_if_possible(&*expected_trait_ref);\n             let actual_trait_ref = infcx.resolve_type_vars_if_possible(&*actual_trait_ref);\n             if !ty::type_is_error(actual_trait_ref.self_ty()) {\n-                infcx.tcx.sess.span_err(\n-                    obligation.cause.span,\n-                    format!(\n+                span_err!(infcx.tcx.sess, obligation.cause.span, E0281,\n                         \"type mismatch: the type `{}` implements the trait `{}`, \\\n                         but the trait `{}` is required ({})\",\n                         expected_trait_ref.self_ty().user_string(infcx.tcx),\n                         expected_trait_ref.user_string(infcx.tcx),\n                         actual_trait_ref.user_string(infcx.tcx),\n-                        ty::type_err_to_str(infcx.tcx, e)).as_slice());\n+                        ty::type_err_to_str(infcx.tcx, e));\n                     note_obligation_cause(infcx, obligation);\n             }\n         }\n@@ -293,18 +274,14 @@ pub fn maybe_report_ambiguity<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n                         infcx.tcx.lang_items.sized_trait()\n                         .map_or(false, |sized_id| sized_id == trait_ref.def_id())\n                     {\n-                        infcx.tcx.sess.span_err(\n-                            obligation.cause.span,\n-                            format!(\n+                        span_err!(infcx.tcx.sess, obligation.cause.span, E0282,\n                                 \"unable to infer enough type information about `{}`; \\\n                                  type annotations required\",\n-                                self_ty.user_string(infcx.tcx)).as_slice());\n+                                self_ty.user_string(infcx.tcx));\n                     } else {\n-                        infcx.tcx.sess.span_err(\n-                            obligation.cause.span,\n-                            format!(\n+                        span_err!(infcx.tcx.sess, obligation.cause.span, E0283,\n                                 \"type annotations required: cannot resolve `{}`\",\n-                                predicate.user_string(infcx.tcx)).as_slice());\n+                                predicate.user_string(infcx.tcx));;\n                         note_obligation_cause(infcx, obligation);\n                     }\n                 }\n@@ -323,11 +300,9 @@ pub fn maybe_report_ambiguity<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n \n         _ => {\n             if !infcx.tcx.sess.has_errors() {\n-                infcx.tcx.sess.span_err(\n-                    obligation.cause.span,\n-                    format!(\n+                span_err!(infcx.tcx.sess, obligation.cause.span, E0284,\n                         \"type annotations required: cannot resolve `{}`\",\n-                        predicate.user_string(infcx.tcx)).as_slice());\n+                        predicate.user_string(infcx.tcx));;\n                 note_obligation_cause(infcx, obligation);\n             }\n         }"}, {"sha": "89459f95b879fe730c020fc9ab88ae94309b54ba", "filename": "src/librustc/middle/traits/mod.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b250d9a3c83e046d2abfcf7911c640865e36e430/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b250d9a3c83e046d2abfcf7911c640865e36e430/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs?ref=b250d9a3c83e046d2abfcf7911c640865e36e430", "patch": "@@ -379,11 +379,10 @@ pub fn type_known_to_meet_builtin_bound<'a,'tcx>(infcx: &InferCtxt<'a,'tcx>,\n             false\n         }\n         Err(Overflow) => {\n-            infcx.tcx.sess.span_err(\n-                span,\n-                format!(\"overflow evaluating whether `{}` is `{}`\",\n-                        ty.user_string(infcx.tcx),\n-                        bound.user_string(infcx.tcx)).as_slice());\n+            span_err!(infcx.tcx.sess, span, E0285,\n+                \"overflow evaluating whether `{}` is `{}`\",\n+                      ty.user_string(infcx.tcx),\n+                      bound.user_string(infcx.tcx));\n             suggest_new_overflow_limit(infcx.tcx, span);\n             false\n         }"}, {"sha": "e5bbd01dde67724c2817a6f58bc4868c04b321c6", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/b250d9a3c83e046d2abfcf7911c640865e36e430/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b250d9a3c83e046d2abfcf7911c640865e36e430/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=b250d9a3c83e046d2abfcf7911c640865e36e430", "patch": "@@ -5369,15 +5369,13 @@ pub fn enum_variants<'tcx>(cx: &ctxt<'tcx>, id: ast::DefId)\n                                                 discriminant = val as Disr\n                                             }\n                                             Ok(_) => {\n-                                                cx.sess\n-                                                  .span_err(e.span,\n+                                                span_err!(cx.sess, e.span, E0304,\n                                                             \"expected signed integer constant\");\n                                             }\n                                             Err(ref err) => {\n-                                                cx.sess\n-                                                  .span_err(e.span,\n-                                                            &format!(\"expected constant: {}\",\n-                                                                    *err)[]);\n+                                                span_err!(cx.sess, e.span, E0305,\n+                                                            \"expected constant: {}\",\n+                                                                    *err);\n                                             }\n                                         },\n                                     None => {}\n@@ -5851,9 +5849,9 @@ pub fn eval_repeat_count(tcx: &ctxt, count_expr: &ast::Expr) -> uint {\n                 const_eval::const_binary(_) =>\n                     \"binary array\"\n             };\n-            tcx.sess.span_err(count_expr.span, &format!(\n+            span_err!(tcx.sess, count_expr.span, E0306,\n                 \"expected positive integer for repeat count, found {}\",\n-                found)[]);\n+                found);\n         }\n         Err(_) => {\n             let found = match count_expr.node {\n@@ -5866,9 +5864,9 @@ pub fn eval_repeat_count(tcx: &ctxt, count_expr: &ast::Expr) -> uint {\n                 _ =>\n                     \"non-constant expression\"\n             };\n-            tcx.sess.span_err(count_expr.span, &format!(\n+            span_err!(tcx.sess, count_expr.span, E0307,\n                 \"expected constant integer for repeat count, found {}\",\n-                found)[]);\n+                found);\n         }\n     }\n     0"}, {"sha": "25cca98c5fb4788af7f1fce215b2444bb43f8579", "filename": "src/librustc/middle/weak_lang_items.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b250d9a3c83e046d2abfcf7911c640865e36e430/src%2Flibrustc%2Fmiddle%2Fweak_lang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b250d9a3c83e046d2abfcf7911c640865e36e430/src%2Flibrustc%2Fmiddle%2Fweak_lang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fweak_lang_items.rs?ref=b250d9a3c83e046d2abfcf7911c640865e36e430", "patch": "@@ -99,9 +99,9 @@ impl<'a> Context<'a> {\n                 self.items.missing.push(lang_items::$item);\n             }\n         } else)* {\n-            self.sess.span_err(span,\n-                               format!(\"unknown external lang item: `{}`\",\n-                                       name).as_slice());\n+            span_err!(self.sess, span, E0264,\n+                               \"unknown external lang item: `{}`\",\n+                                       name);\n         }\n     }\n }"}, {"sha": "4150335abc3d3080ddbc4a7dc3c2c239c1acd787", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 66, "deletions": 52, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/b250d9a3c83e046d2abfcf7911c640865e36e430/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b250d9a3c83e046d2abfcf7911c640865e36e430/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=b250d9a3c83e046d2abfcf7911c640865e36e430", "patch": "@@ -69,65 +69,23 @@ impl Session {\n     pub fn span_fatal(&self, sp: Span, msg: &str) -> ! {\n         self.diagnostic().span_fatal(sp, msg)\n     }\n+    pub fn span_fatal_with_code(&self, sp: Span, msg: &str, code: &str) -> ! {\n+        self.diagnostic().span_fatal_with_code(sp, msg, code)\n+    }\n     pub fn fatal(&self, msg: &str) -> ! {\n         self.diagnostic().handler().fatal(msg)\n     }\n     pub fn span_err(&self, sp: Span, msg: &str) {\n-        // Conditions for enabling multi-line errors:\n-        if !msg.contains(\"mismatched types\") &&\n-           !msg.contains(\"type mismatch resolving\") &&\n-           !msg.contains(\"if and else have incompatible types\") &&\n-           !msg.contains(\"if may be missing an else clause\") &&\n-           !msg.contains(\"match arms have incompatible types\") &&\n-           !msg.contains(\"structure constructor specifies a structure of type\") {\n-            return self.diagnostic().span_err(sp, msg);\n+        match split_msg_into_multilines(msg) {\n+            Some(msg) => self.diagnostic().span_err(sp, &msg[]),\n+            None => self.diagnostic().span_err(sp, msg)\n         }\n-\n-        let first  = Regex::new(r\"[( ]expected\").unwrap();\n-        let second = Regex::new(r\" found\").unwrap();\n-        let third  = Regex::new(\n-                     r\"\\((values differ|lifetime|cyclic type of infinite size)\").unwrap();\n-\n-        let mut new_msg = String::new();\n-        let mut head = 0u;\n-\n-        // Insert `\\n` before expected and found.\n-        for (pos1, pos2) in first.find_iter(msg).zip(\n-                            second.find_iter(msg)) {\n-            new_msg = new_msg +\n-            // A `(` may be preceded by a space and it should be trimmed\n-                      msg[head..pos1.0].trim_right() + // prefix\n-                      \"\\n\" +                           // insert before first\n-                      &msg[pos1.0..pos1.1] +           // insert what first matched\n-                      &msg[pos1.1..pos2.0] +           // between matches\n-                      \"\\n   \" +                        // insert before second\n-            //           123\n-            // `expected` is 3 char longer than `found`. To align the types, `found` gets\n-            // 3 spaces prepended.\n-                      &msg[pos2.0..pos2.1];            // insert what second matched\n-\n-            head = pos2.1;\n-        }\n-\n-        let mut tail = &msg[head..];\n-        // Insert `\\n` before any remaining messages which match.\n-        for pos in third.find_iter(tail).take(1) {\n-            // The end of the message may just be wrapped in `()` without `expected`/`found`.\n-            // Push this also to a new line and add the final tail after.\n-            new_msg = new_msg +\n-            // `(` is usually preceded by a space and should be trimmed.\n-                      tail[..pos.0].trim_right() + // prefix\n-                      \"\\n\" +                       // insert before paren\n-                      &tail[pos.0..];              // append the tail\n-\n-            tail = \"\";\n-        }\n-\n-        new_msg.push_str(tail);\n-        self.diagnostic().span_err(sp, &new_msg[])\n     }\n     pub fn span_err_with_code(&self, sp: Span, msg: &str, code: &str) {\n-        self.diagnostic().span_err_with_code(sp, msg, code)\n+        match split_msg_into_multilines(msg) {\n+            Some(msg) => self.diagnostic().span_err_with_code(sp, &msg[], code),\n+            None => self.diagnostic().span_err_with_code(sp, msg, code)\n+        }\n     }\n     pub fn err(&self, msg: &str) {\n         self.diagnostic().handler().err(msg)\n@@ -285,6 +243,62 @@ impl Session {\n     }\n }\n \n+fn split_msg_into_multilines(msg: &str) -> Option<String> {\n+    // Conditions for enabling multi-line errors:\n+    if !msg.contains(\"mismatched types\") &&\n+        !msg.contains(\"type mismatch resolving\") &&\n+        !msg.contains(\"if and else have incompatible types\") &&\n+        !msg.contains(\"if may be missing an else clause\") &&\n+        !msg.contains(\"match arms have incompatible types\") &&\n+        !msg.contains(\"structure constructor specifies a structure of type\") {\n+            return None\n+    }\n+\n+    let first  = Regex::new(r\"[( ]expected\").unwrap();\n+    let second = Regex::new(r\" found\").unwrap();\n+    let third  = Regex::new(\n+        r\"\\((values differ|lifetime|cyclic type of infinite size)\").unwrap();\n+\n+    let mut new_msg = String::new();\n+    let mut head = 0u;\n+\n+    // Insert `\\n` before expected and found.\n+    for (pos1, pos2) in first.find_iter(msg).zip(\n+        second.find_iter(msg)) {\n+        new_msg = new_msg +\n+            // A `(` may be preceded by a space and it should be trimmed\n+            msg[head..pos1.0].trim_right() + // prefix\n+            \"\\n\" +                           // insert before first\n+            &msg[pos1.0..pos1.1] +           // insert what first matched\n+            &msg[pos1.1..pos2.0] +           // between matches\n+            \"\\n   \" +                        // insert before second\n+            //           123\n+            // `expected` is 3 char longer than `found`. To align the types, `found` gets\n+            // 3 spaces prepended.\n+            &msg[pos2.0..pos2.1];            // insert what second matched\n+\n+        head = pos2.1;\n+    }\n+\n+    let mut tail = &msg[head..];\n+    // Insert `\\n` before any remaining messages which match.\n+    for pos in third.find_iter(tail).take(1) {\n+        // The end of the message may just be wrapped in `()` without `expected`/`found`.\n+        // Push this also to a new line and add the final tail after.\n+        new_msg = new_msg +\n+            // `(` is usually preceded by a space and should be trimmed.\n+            tail[..pos.0].trim_right() + // prefix\n+            \"\\n\" +                       // insert before paren\n+            &tail[pos.0..];              // append the tail\n+\n+        tail = \"\";\n+    }\n+\n+    new_msg.push_str(tail);\n+\n+    return Some(new_msg)\n+}\n+\n pub fn build_session(sopts: config::Options,\n                      local_crate_source_file: Option<Path>,\n                      registry: diagnostics::registry::Registry)"}, {"sha": "f8e889fc7111b551a99be08c3cd0bfbdfd57ce65", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/b250d9a3c83e046d2abfcf7911c640865e36e430/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b250d9a3c83e046d2abfcf7911c640865e36e430/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=b250d9a3c83e046d2abfcf7911c640865e36e430", "patch": "@@ -61,7 +61,6 @@ use rustc::lint::Lint;\n use rustc::lint;\n use rustc::metadata;\n use rustc::metadata::creader::CrateOrString::Str;\n-use rustc::DIAGNOSTICS;\n use rustc::util::common::time;\n \n use std::cmp::Ordering::Equal;\n@@ -98,7 +97,7 @@ fn run_compiler(args: &[String]) {\n         None => return\n     };\n \n-    let descriptions = diagnostics::registry::Registry::new(&DIAGNOSTICS);\n+    let descriptions = diagnostics_registry();\n     match matches.opt_str(\"explain\") {\n         Some(ref code) => {\n             match descriptions.find_description(&code[]) {\n@@ -659,8 +658,20 @@ pub fn monitor<F:FnOnce()+Send>(f: F) {\n     }\n }\n \n+pub fn diagnostics_registry() -> diagnostics::registry::Registry {\n+    use syntax::diagnostics::registry::Registry;\n+\n+    let all_errors = Vec::new() +\n+        rustc::diagnostics::DIAGNOSTICS.as_slice() +\n+        rustc_typeck::diagnostics::DIAGNOSTICS.as_slice() +\n+        rustc_resolve::diagnostics::DIAGNOSTICS.as_slice();\n+\n+    Registry::new(&*all_errors)\n+}\n+\n pub fn main() {\n     let args = std::os::args();\n     let result = run(args);\n     std::os::set_exit_status(result);\n }\n+"}, {"sha": "2a4c31d62abbe087cd86e14dfea5faf2e44c66cc", "filename": "src/librustc_resolve/diagnostics.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/b250d9a3c83e046d2abfcf7911c640865e36e430/src%2Flibrustc_resolve%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b250d9a3c83e046d2abfcf7911c640865e36e430/src%2Flibrustc_resolve%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fdiagnostics.rs?ref=b250d9a3c83e046d2abfcf7911c640865e36e430", "patch": "@@ -0,0 +1,28 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![allow(non_snake_case)]\n+\n+register_diagnostics! {\n+    E0157,\n+    E0153,\n+    E0251, // a named type or value has already been imported in this module\n+    E0252, // a named type or value has already been imported in this module\n+    E0253, // not directly importable\n+    E0254, // import conflicts with imported crate in this module\n+    E0255, // import conflicts with value in this module\n+    E0256, // import conflicts with type in this module\n+    E0257, // inherent implementations are only allowen on types defined in the current module\n+    E0258, // import conflicts with existing submodule\n+    E0259, // an extern crate has already been imported into this module\n+    E0260 // name conflicts with an external crate that has been imported into this module\n+}\n+\n+__build_diagnostic_array! { DIAGNOSTICS }"}, {"sha": "6b45c2443d38a1a91f57005a5fcc6782fedae8d9", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 18, "deletions": 16, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/b250d9a3c83e046d2abfcf7911c640865e36e430/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b250d9a3c83e046d2abfcf7911c640865e36e430/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=b250d9a3c83e046d2abfcf7911c640865e36e430", "patch": "@@ -97,6 +97,10 @@ use std::mem::replace;\n use std::rc::{Rc, Weak};\n use std::uint;\n \n+// NB: This module needs to be declared first so diagnostics are\n+// registered before they are used.\n+pub mod diagnostics;\n+\n mod check_unused;\n mod record_exports;\n mod build_reduced_graph;\n@@ -1718,7 +1722,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                            in this module\",\n                                           namespace_name,\n                                           token::get_name(name).get());\n-                        self.session.span_err(import_directive.span, msg.as_slice());\n+                        span_err!(self.session, import_directive.span, E0251, \"{}\", msg.as_slice());\n                     } else {\n                         let target = Target::new(containing_module.clone(),\n                                                  name_bindings.clone(),\n@@ -1765,7 +1769,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                     ValueNS => \"value\",\n                                   },\n                                   token::get_name(name).get());\n-                self.session.span_err(import_span, &msg[]);\n+                span_err!(self.session, import_span, E0252, \"{}\", &msg[]);\n             }\n             Some(_) | None => {}\n         }\n@@ -1780,7 +1784,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         if !name_bindings.defined_in_namespace_with(namespace, IMPORTABLE) {\n             let msg = format!(\"`{}` is not directly importable\",\n                               token::get_name(name));\n-            self.session.span_err(import_span, &msg[]);\n+            span_err!(self.session, import_span, E0253, \"{}\", &msg[]);\n         }\n     }\n \n@@ -1805,7 +1809,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                        crate in this module \\\n                                        (maybe you meant `use {0}::*`?)\",\n                                       token::get_name(name).get());\n-                    self.session.span_err(import_span, &msg[]);\n+                    span_err!(self.session, import_span, E0254, \"{}\", &msg[]);\n                 }\n                 Some(_) | None => {}\n             }\n@@ -1827,7 +1831,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     let msg = format!(\"import `{}` conflicts with value \\\n                                        in this module\",\n                                       token::get_name(name).get());\n-                    self.session.span_err(import_span, &msg[]);\n+                    span_err!(self.session, import_span, E0255, \"{}\", &msg[]);\n                     if let Some(span) = value.value_span {\n                         self.session.span_note(span,\n                                                \"conflicting value here\");\n@@ -1845,7 +1849,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                             let msg = format!(\"import `{}` conflicts with type in \\\n                                                this module\",\n                                               token::get_name(name).get());\n-                            self.session.span_err(import_span, &msg[]);\n+                            span_err!(self.session, import_span, E0256, \"{}\", &msg[]);\n                             if let Some(span) = ty.type_span {\n                                 self.session.span_note(span,\n                                                        \"note conflicting type here\")\n@@ -1858,7 +1862,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                         let msg = format!(\"inherent implementations \\\n                                                            are only allowed on types \\\n                                                            defined in the current module\");\n-                                        self.session.span_err(span, &msg[]);\n+                                        span_err!(self.session, span, E0257, \"{}\", &msg[]);\n                                         self.session.span_note(import_span,\n                                                                \"import from other module here\")\n                                     }\n@@ -1867,7 +1871,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                     let msg = format!(\"import `{}` conflicts with existing \\\n                                                        submodule\",\n                                                       token::get_name(name).get());\n-                                    self.session.span_err(import_span, &msg[]);\n+                                    span_err!(self.session, import_span, E0258, \"{}\", &msg[]);\n                                     if let Some(span) = ty.type_span {\n                                         self.session.span_note(span,\n                                                                \"note conflicting module here\")\n@@ -1893,11 +1897,10 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         }\n \n         if module.external_module_children.borrow().contains_key(&name) {\n-            self.session\n-                .span_err(span,\n-                          &format!(\"an external crate named `{}` has already \\\n+                span_err!(self.session, span, E0259,\n+                          \"an external crate named `{}` has already \\\n                                    been imported into this module\",\n-                                  token::get_name(name).get())[]);\n+                                  token::get_name(name).get());\n         }\n     }\n \n@@ -1911,12 +1914,11 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         }\n \n         if module.external_module_children.borrow().contains_key(&name) {\n-            self.session\n-                .span_err(span,\n-                          &format!(\"the name `{}` conflicts with an external \\\n+                span_err!(self.session, span, E0260,\n+                          \"the name `{}` conflicts with an external \\\n                                    crate that has been imported into this \\\n                                    module\",\n-                                  token::get_name(name).get())[]);\n+                                  token::get_name(name).get());\n         }\n     }\n "}, {"sha": "cfcc65bd15ace43c66519b2d1f78a3c798396097", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 57, "deletions": 71, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/b250d9a3c83e046d2abfcf7911c640865e36e430/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b250d9a3c83e046d2abfcf7911c640865e36e430/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=b250d9a3c83e046d2abfcf7911c640865e36e430", "patch": "@@ -100,8 +100,7 @@ pub trait AstConv<'tcx> {\n                                         -> Ty<'tcx>\n     {\n         if ty::binds_late_bound_regions(self.tcx(), &poly_trait_ref) {\n-            self.tcx().sess.span_err(\n-                span,\n+            span_err!(self.tcx().sess, span, E0212,\n                 \"cannot extract an associated type from a higher-ranked trait bound \\\n                  in this context\");\n             self.tcx().types.err\n@@ -119,8 +118,7 @@ pub trait AstConv<'tcx> {\n                     _item_name: ast::Name)\n                     -> Ty<'tcx>\n     {\n-        self.tcx().sess.span_err(\n-            span,\n+        span_err!(self.tcx().sess, span, E0213,\n             \"associated types are not accepted in this context\");\n \n         self.tcx().types.err\n@@ -268,8 +266,7 @@ pub fn ast_path_substs_for_ty<'tcx>(\n             convert_angle_bracketed_parameters(this, rscope, data)\n         }\n         ast::ParenthesizedParameters(ref data) => {\n-            tcx.sess.span_err(\n-                path.span,\n+            span_err!(tcx.sess, path.span, E0214,\n                 \"parenthesized parameters may only be used with a trait\");\n             (Vec::new(), convert_parenthesized_parameters(this, data), Vec::new())\n         }\n@@ -342,22 +339,22 @@ fn create_substs_for_ast_path<'tcx>(\n         } else {\n             \"expected\"\n         };\n-        this.tcx().sess.span_fatal(span,\n-                                   &format!(\"wrong number of type arguments: {} {}, found {}\",\n+        span_fatal!(this.tcx().sess, span, E0243,\n+                                   \"wrong number of type arguments: {} {}, found {}\",\n                                            expected,\n                                            required_ty_param_count,\n-                                           supplied_ty_param_count)[]);\n+                                           supplied_ty_param_count);\n     } else if supplied_ty_param_count > formal_ty_param_count {\n         let expected = if required_ty_param_count < formal_ty_param_count {\n             \"expected at most\"\n         } else {\n             \"expected\"\n         };\n-        this.tcx().sess.span_fatal(span,\n-                                   &format!(\"wrong number of type arguments: {} {}, found {}\",\n+        span_fatal!(this.tcx().sess, span, E0244,\n+                                   \"wrong number of type arguments: {} {}, found {}\",\n                                            expected,\n                                            formal_ty_param_count,\n-                                           supplied_ty_param_count)[]);\n+                                           supplied_ty_param_count);\n     }\n \n     let mut substs = Substs::new_type(types, regions);\n@@ -560,10 +557,9 @@ pub fn instantiate_trait_ref<'tcx>(\n             trait_ref\n         }\n         _ => {\n-            this.tcx().sess.span_fatal(\n-                ast_trait_ref.path.span,\n-                &format!(\"`{}` is not a trait\",\n-                        ast_trait_ref.path.user_string(this.tcx()))[]);\n+            span_fatal!(this.tcx().sess, ast_trait_ref.path.span, E0245,\n+                \"`{}` is not a trait\",\n+                        ast_trait_ref.path.user_string(this.tcx()));\n         }\n     }\n }\n@@ -610,7 +606,7 @@ fn ast_path_to_trait_ref<'a,'tcx>(\n             if !this.tcx().sess.features.borrow().unboxed_closures &&\n                 this.tcx().lang_items.fn_trait_kind(trait_def_id).is_some()\n             {\n-                this.tcx().sess.span_err(path.span,\n+                span_err!(this.tcx().sess, path.span, E0215,\n                                          \"angle-bracket notation is not stable when \\\n                                          used with the `Fn` family of traits, use parentheses\");\n                 span_help!(this.tcx().sess, path.span,\n@@ -626,7 +622,7 @@ fn ast_path_to_trait_ref<'a,'tcx>(\n             if !this.tcx().sess.features.borrow().unboxed_closures &&\n                 this.tcx().lang_items.fn_trait_kind(trait_def_id).is_none()\n             {\n-                this.tcx().sess.span_err(path.span,\n+                span_err!(this.tcx().sess, path.span, E0216,\n                                          \"parenthetical notation is only stable when \\\n                                          used with the `Fn` family of traits\");\n                 span_help!(this.tcx().sess, path.span,\n@@ -738,32 +734,29 @@ fn ast_type_binding_to_projection_predicate<'tcx>(\n     }\n \n     if candidates.len() > 1 {\n-        tcx.sess.span_err(\n-            binding.span,\n-            format!(\"ambiguous associated type: `{}` defined in multiple supertraits `{}`\",\n+        span_err!(tcx.sess, binding.span, E0217,\n+            \"ambiguous associated type: `{}` defined in multiple supertraits `{}`\",\n                     token::get_name(binding.item_name),\n-                    candidates.user_string(tcx)).as_slice());\n+                    candidates.user_string(tcx));\n         return Err(ErrorReported);\n     }\n \n     let candidate = match candidates.pop() {\n         Some(c) => c,\n         None => {\n-            tcx.sess.span_err(\n-                binding.span,\n-                format!(\"no associated type `{}` defined in `{}`\",\n+            span_err!(tcx.sess, binding.span, E0218,\n+                \"no associated type `{}` defined in `{}`\",\n                         token::get_name(binding.item_name),\n-                        trait_ref.user_string(tcx)).as_slice());\n+                        trait_ref.user_string(tcx));\n             return Err(ErrorReported);\n         }\n     };\n \n     if ty::binds_late_bound_regions(tcx, &candidate) {\n-        tcx.sess.span_err(\n-            binding.span,\n-            format!(\"associated type `{}` defined in higher-ranked supertrait `{}`\",\n+        span_err!(tcx.sess, binding.span, E0219,\n+            \"associated type `{}` defined in higher-ranked supertrait `{}`\",\n                     token::get_name(binding.item_name),\n-                    candidate.user_string(tcx)).as_slice());\n+                    candidate.user_string(tcx));\n         return Err(ErrorReported);\n     }\n \n@@ -964,18 +957,18 @@ fn associated_path_def_to_ty<'tcx>(this: &AstConv<'tcx>,\n     }\n \n     if suitable_bounds.len() == 0 {\n-        tcx.sess.span_err(ast_ty.span,\n-                          format!(\"associated type `{}` not found for type parameter `{}`\",\n+        span_err!(tcx.sess, ast_ty.span, E0220,\n+                          \"associated type `{}` not found for type parameter `{}`\",\n                                   token::get_name(assoc_name),\n-                                  token::get_name(ty_param_name)).as_slice());\n+                                  token::get_name(ty_param_name));\n         return this.tcx().types.err;\n     }\n \n     if suitable_bounds.len() > 1 {\n-        tcx.sess.span_err(ast_ty.span,\n-                          format!(\"ambiguous associated type `{}` in bounds of `{}`\",\n+        span_err!(tcx.sess, ast_ty.span, E0221,\n+                          \"ambiguous associated type `{}` in bounds of `{}`\",\n                                   token::get_name(assoc_name),\n-                                  token::get_name(ty_param_name)).as_slice());\n+                                  token::get_name(ty_param_name));\n \n         for suitable_bound in suitable_bounds.iter() {\n             span_note!(this.tcx().sess, ast_ty.span,\n@@ -1042,7 +1035,7 @@ pub fn ast_ty_to_ty<'tcx>(\n     match ast_ty_to_ty_cache.get(&ast_ty.id) {\n         Some(&ty::atttce_resolved(ty)) => return ty,\n         Some(&ty::atttce_unresolved) => {\n-            tcx.sess.span_fatal(ast_ty.span,\n+            span_fatal!(tcx.sess, ast_ty.span, E0246,\n                                 \"illegal recursive type; insert an enum \\\n                                  or struct in the cycle, if this is \\\n                                  desired\");\n@@ -1093,7 +1086,7 @@ pub fn ast_ty_to_ty<'tcx>(\n             ast::TyParen(ref typ) => ast_ty_to_ty(this, rscope, &**typ),\n             ast::TyBareFn(ref bf) => {\n                 if bf.decl.variadic && bf.abi != abi::C {\n-                    tcx.sess.span_err(ast_ty.span,\n+                    span_err!(tcx.sess, ast_ty.span, E0222,\n                                       \"variadic function must have C calling convention\");\n                 }\n                 let bare_fn = ty_of_bare_fn(this, bf.unsafety, bf.abi, &*bf.decl);\n@@ -1142,18 +1135,18 @@ pub fn ast_ty_to_ty<'tcx>(\n                         ty::mk_self_type(tcx)\n                     }\n                     def::DefMod(id) => {\n-                        tcx.sess.span_fatal(ast_ty.span,\n-                            &format!(\"found module name used as a type: {}\",\n-                                    tcx.map.node_to_string(id.node))[]);\n+                        span_fatal!(tcx.sess, ast_ty.span, E0247,\n+                            \"found module name used as a type: {}\",\n+                                    tcx.map.node_to_string(id.node));\n                     }\n                     def::DefPrimTy(_) => {\n                         panic!(\"DefPrimTy arm missed in previous ast_ty_to_prim_ty call\");\n                     }\n                     def::DefAssociatedTy(trait_type_id) => {\n                         let path_str = tcx.map.path_to_string(\n                             tcx.map.get_parent(trait_type_id.node));\n-                        tcx.sess.span_err(ast_ty.span,\n-                                          &format!(\"ambiguous associated \\\n+                        span_err!(tcx.sess, ast_ty.span, E0223,\n+                                          \"ambiguous associated \\\n                                                    type; specify the type \\\n                                                    using the syntax `<Type \\\n                                                    as {}>::{}`\",\n@@ -1163,17 +1156,17 @@ pub fn ast_ty_to_ty<'tcx>(\n                                                           .last()\n                                                           .unwrap()\n                                                           .identifier)\n-                                                  .get())[]);\n+                                                  .get());\n                         this.tcx().types.err\n                     }\n                     def::DefAssociatedPath(provenance, assoc_ident) => {\n                         associated_path_def_to_ty(this, ast_ty, provenance, assoc_ident.name)\n                     }\n                     _ => {\n-                        tcx.sess.span_fatal(ast_ty.span,\n-                                            &format!(\"found value name used \\\n+                        span_fatal!(tcx.sess, ast_ty.span, E0248,\n+                                            \"found value name used \\\n                                                      as a type: {:?}\",\n-                                                    a_def)[]);\n+                                                    a_def);\n                     }\n                 }\n             }\n@@ -1191,17 +1184,16 @@ pub fn ast_ty_to_ty<'tcx>(\n                                 ty::mk_vec(tcx, ast_ty_to_ty(this, rscope, &**ty),\n                                            Some(i as uint)),\n                             _ => {\n-                                tcx.sess.span_fatal(\n-                                    ast_ty.span, \"expected constant expr for array length\");\n+                                span_fatal!(tcx.sess, ast_ty.span, E0249,\n+                                            \"expected constant expr for array length\");\n                             }\n                         }\n                     }\n                     Err(ref r) => {\n-                        tcx.sess.span_fatal(\n-                            ast_ty.span,\n-                            &format!(\"expected constant expr for array \\\n+                        span_fatal!(tcx.sess, ast_ty.span, E0250,\n+                            \"expected constant expr for array \\\n                                      length: {}\",\n-                                    *r)[]);\n+                                    *r);\n                     }\n                 }\n             }\n@@ -1557,8 +1549,7 @@ fn conv_ty_poly_trait_ref<'tcx>(\n                                         None,\n                                         &mut projection_bounds))\n     } else {\n-        this.tcx().sess.span_err(\n-            span,\n+        span_err!(this.tcx().sess, span, E0224,\n             \"at least one non-builtin trait is required for an object type\");\n         None\n     };\n@@ -1593,10 +1584,9 @@ pub fn conv_existential_bounds_from_partitioned_bounds<'tcx>(\n \n     if !trait_bounds.is_empty() {\n         let b = &trait_bounds[0];\n-        this.tcx().sess.span_err(\n-            b.trait_ref.path.span,\n-            &format!(\"only the builtin traits can be used \\\n-                     as closure or object bounds\")[]);\n+        span_err!(this.tcx().sess, b.trait_ref.path.span, E0225,\n+            \"only the builtin traits can be used \\\n+                     as closure or object bounds\");\n     }\n \n     let region_bound = compute_region_bound(this,\n@@ -1633,9 +1623,8 @@ fn compute_opt_region_bound<'tcx>(tcx: &ty::ctxt<'tcx>,\n            builtin_bounds.repr(tcx));\n \n     if explicit_region_bounds.len() > 1 {\n-        tcx.sess.span_err(\n-            explicit_region_bounds[1].span,\n-            format!(\"only a single explicit lifetime bound is permitted\").as_slice());\n+        span_err!(tcx.sess, explicit_region_bounds[1].span, E0226,\n+            \"only a single explicit lifetime bound is permitted\");\n     }\n \n     if explicit_region_bounds.len() != 0 {\n@@ -1666,10 +1655,9 @@ fn compute_opt_region_bound<'tcx>(tcx: &ty::ctxt<'tcx>,\n     // error.\n     let r = derived_region_bounds[0];\n     if derived_region_bounds.slice_from(1).iter().any(|r1| r != *r1) {\n-        tcx.sess.span_err(\n-            span,\n-            &format!(\"ambiguous lifetime bound, \\\n-                     explicit lifetime bound required\")[]);\n+        span_err!(tcx.sess, span, E0227,\n+            \"ambiguous lifetime bound, \\\n+                     explicit lifetime bound required\");\n     }\n     return Some(r);\n }\n@@ -1693,9 +1681,8 @@ fn compute_region_bound<'tcx>(\n             match rscope.default_region_bound(span) {\n                 Some(r) => { r }\n                 None => {\n-                    this.tcx().sess.span_err(\n-                        span,\n-                        &format!(\"explicit lifetime bound required\")[]);\n+                    span_err!(this.tcx().sess, span, E0228,\n+                        \"explicit lifetime bound required\");\n                     ty::ReStatic\n                 }\n             }\n@@ -1779,8 +1766,7 @@ fn prohibit_projections<'tcx>(tcx: &ty::ctxt<'tcx>,\n                               bindings: &[ConvertedBinding<'tcx>])\n {\n     for binding in bindings.iter().take(1) {\n-        tcx.sess.span_err(\n-            binding.span,\n+        span_err!(tcx.sess, binding.span, E0229,\n             \"associated type bindings are not allowed here\");\n     }\n }"}, {"sha": "33cce67c7807d8d24819c3d5fc35fccae31a8a53", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b250d9a3c83e046d2abfcf7911c640865e36e430/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b250d9a3c83e046d2abfcf7911c640865e36e430/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=b250d9a3c83e046d2abfcf7911c640865e36e430", "patch": "@@ -50,10 +50,9 @@ pub fn check_expr_closure<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>,\n \n                     check_unboxed_closure(fcx, expr, kind, decl, body, None);\n \n-                    fcx.ccx.tcx.sess.span_err(\n-                        expr.span,\n+                    span_err!(fcx.ccx.tcx.sess, expr.span, E0187,\n                         \"can't infer the \\\"kind\\\" of the closure, explicitly annotate it. e.g. \\\n-                        `|&:| {}`\");\n+                        `|&:| {{}}`\");\n                 },\n                 Some((sig, kind)) => {\n                     check_unboxed_closure(fcx, expr, kind, decl, body, Some(sig));"}, {"sha": "e3e5d67869fa47afb4a6f93ced61ad4d33505a98", "filename": "src/librustc_typeck/check/compare_method.rs", "status": "modified", "additions": 9, "deletions": 12, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/b250d9a3c83e046d2abfcf7911c640865e36e430/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b250d9a3c83e046d2abfcf7911c640865e36e430/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs?ref=b250d9a3c83e046d2abfcf7911c640865e36e430", "patch": "@@ -59,23 +59,21 @@ pub fn compare_impl_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n         (&ty::StaticExplicitSelfCategory,\n          &ty::StaticExplicitSelfCategory) => {}\n         (&ty::StaticExplicitSelfCategory, _) => {\n-            tcx.sess.span_err(\n-                impl_m_span,\n-                format!(\"method `{}` has a `{}` declaration in the impl, \\\n+            span_err!(tcx.sess, impl_m_span, E0185,\n+                \"method `{}` has a `{}` declaration in the impl, \\\n                         but not in the trait\",\n                         token::get_name(trait_m.name),\n                         ppaux::explicit_self_category_to_str(\n-                            &impl_m.explicit_self)).as_slice());\n+                            &impl_m.explicit_self));\n             return;\n         }\n         (_, &ty::StaticExplicitSelfCategory) => {\n-            tcx.sess.span_err(\n-                impl_m_span,\n-                format!(\"method `{}` has a `{}` declaration in the trait, \\\n+            span_err!(tcx.sess, impl_m_span, E0186,\n+                \"method `{}` has a `{}` declaration in the trait, \\\n                         but not in the impl\",\n                         token::get_name(trait_m.name),\n                         ppaux::explicit_self_category_to_str(\n-                            &trait_m.explicit_self)).as_slice());\n+                            &trait_m.explicit_self));\n             return;\n         }\n         _ => {\n@@ -400,11 +398,10 @@ pub fn compare_impl_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n         // are zero. Since I don't quite know how to phrase things at\n         // the moment, give a kind of vague error message.\n         if trait_params.len() != impl_params.len() {\n-            tcx.sess.span_err(\n-                span,\n-                &format!(\"lifetime parameters or bounds on method `{}` do \\\n+            span_err!(tcx.sess, span, E0195,\n+                \"lifetime parameters or bounds on method `{}` do \\\n                          not match the trait declaration\",\n-                         token::get_name(impl_m.name))[]);\n+                         token::get_name(impl_m.name));\n             return false;\n         }\n "}, {"sha": "db4962b0d22db299b517bf75c1c9750a23a86131", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 20, "deletions": 26, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/b250d9a3c83e046d2abfcf7911c640865e36e430/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b250d9a3c83e046d2abfcf7911c640865e36e430/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=b250d9a3c83e046d2abfcf7911c640865e36e430", "patch": "@@ -801,24 +801,23 @@ fn check_trait_on_unimplemented<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                         }) {\n                             Some(_) => (),\n                             None => {\n-                                ccx.tcx.sess.span_err(attr.span,\n-                                                 format!(\"there is no type parameter \\\n+                                span_err!(ccx.tcx.sess, attr.span, E0230,\n+                                                 \"there is no type parameter \\\n                                                           {} on trait {}\",\n-                                                           s, item.ident.as_str())\n-                                            .as_slice());\n+                                                           s, item.ident.as_str());\n                             }\n                         },\n                         // `{:1}` and `{}` are not to be used\n                         Position::ArgumentIs(_) | Position::ArgumentNext => {\n-                            ccx.tcx.sess.span_err(attr.span,\n+                            span_err!(ccx.tcx.sess, attr.span, E0231,\n                                                   \"only named substitution \\\n                                                    parameters are allowed\");\n                         }\n                     }\n                 }\n             }\n         } else {\n-            ccx.tcx.sess.span_err(attr.span,\n+            span_err!(ccx.tcx.sess, attr.span, E0232,\n                                   \"this attribute must have a value, \\\n                                    eg `#[rustc_on_unimplemented = \\\"foo\\\"]`\")\n         }\n@@ -2099,8 +2098,8 @@ fn lookup_method_for_for_loop<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n     let trait_did = match fcx.tcx().lang_items.require(IteratorItem) {\n         Ok(trait_did) => trait_did,\n         Err(ref err_string) => {\n-            fcx.tcx().sess.span_err(iterator_expr.span,\n-                                    &err_string[]);\n+            span_err!(fcx.tcx().sess, iterator_expr.span, E0233,\n+                                    \"{}\", &err_string[]);\n             return fcx.tcx().types.err\n         }\n     };\n@@ -2123,11 +2122,10 @@ fn lookup_method_for_for_loop<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n \n             if !ty::type_is_error(true_expr_type) {\n                 let ty_string = fcx.infcx().ty_to_string(true_expr_type);\n-                fcx.tcx().sess.span_err(iterator_expr.span,\n-                                        &format!(\"`for` loop expression has type `{}` which does \\\n+                span_err!(fcx.tcx().sess, iterator_expr.span, E0234,\n+                                        \"`for` loop expression has type `{}` which does \\\n                                                 not implement the `Iterator` trait; \\\n-                                                maybe try .iter()\",\n-                                                ty_string)[]);\n+                                                maybe try .iter()\", ty_string);\n             }\n             fcx.tcx().types.err\n         }\n@@ -2162,11 +2160,10 @@ fn lookup_method_for_for_loop<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                     fcx.tcx().types.err\n                 }\n                 _ => {\n-                    fcx.tcx().sess.span_err(iterator_expr.span,\n-                                            &format!(\"`next` method of the `Iterator` \\\n+                    span_err!(fcx.tcx().sess, iterator_expr.span, E0239,\n+                                            \"`next` method of the `Iterator` \\\n                                                     trait has an unexpected type `{}`\",\n-                                                    fcx.infcx().ty_to_string(return_type))\n-                                            []);\n+                                                    fcx.infcx().ty_to_string(return_type));\n                     fcx.tcx().types.err\n                 }\n             }\n@@ -3880,18 +3877,16 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                 Err(type_error) => {\n                     let type_error_description =\n                         ty::type_err_to_str(tcx, &type_error);\n-                    fcx.tcx()\n-                       .sess\n-                       .span_err(path.span,\n-                                 &format!(\"structure constructor specifies a \\\n+                    span_err!(fcx.tcx().sess, path.span, E0235,\n+                                 \"structure constructor specifies a \\\n                                          structure of type `{}`, but this \\\n                                          structure has type `{}`: {}\",\n                                          fcx.infcx()\n                                             .ty_to_string(type_and_substs.ty),\n                                          fcx.infcx()\n                                             .ty_to_string(\n                                                 actual_structure_type),\n-                                         type_error_description)[]);\n+                                         type_error_description);\n                     ty::note_and_explain_type_err(tcx, &type_error);\n                 }\n             }\n@@ -4012,7 +4007,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n \n                     ty::mk_struct(tcx, did, tcx.mk_substs(substs))\n                 } else {\n-                    tcx.sess.span_err(expr.span, \"No lang item for range syntax\");\n+                    span_err!(tcx.sess, expr.span, E0236, \"no lang item for range syntax\");\n                     fcx.tcx().types.err\n                 }\n             }\n@@ -4022,7 +4017,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                     let substs = Substs::new_type(vec![], vec![]);\n                     ty::mk_struct(tcx, did, tcx.mk_substs(substs))\n                 } else {\n-                    tcx.sess.span_err(expr.span, \"No lang item for range syntax\");\n+                    span_err!(tcx.sess, expr.span, E0237, \"no lang item for range syntax\");\n                     fcx.tcx().types.err\n                 }\n             }\n@@ -4872,8 +4867,7 @@ pub fn instantiate_path<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n             }\n \n             ast::ParenthesizedParameters(ref data) => {\n-                fcx.tcx().sess.span_err(\n-                    span,\n+                span_err!(fcx.tcx().sess, span, E0238,\n                     \"parenthesized parameters may only be used with a trait\");\n                 push_explicit_parenthesized_parameters_from_segment_to_substs(\n                     fcx, space, span, type_defs, data, substs);\n@@ -5230,7 +5224,7 @@ pub fn check_intrinsic_type(ccx: &CrateCtxt, it: &ast::ForeignItem) {\n             \"get_tydesc\" => {\n               let tydesc_ty = match ty::get_tydesc_ty(ccx.tcx) {\n                   Ok(t) => t,\n-                  Err(s) => { tcx.sess.span_fatal(it.span, &s[]); }\n+                  Err(s) => { span_fatal!(tcx.sess, it.span, E0240, \"{}\", &s[]); }\n               };\n               let td_ptr = ty::mk_ptr(ccx.tcx, ty::mt {\n                   ty: tydesc_ty,"}, {"sha": "41b63830279a8f1b8109d993f0c49a9019771758", "filename": "src/librustc_typeck/check/vtable.rs", "status": "modified", "additions": 10, "deletions": 13, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/b250d9a3c83e046d2abfcf7911c640865e36e430/src%2Flibrustc_typeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b250d9a3c83e046d2abfcf7911c640865e36e430/src%2Flibrustc_typeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fvtable.rs?ref=b250d9a3c83e046d2abfcf7911c640865e36e430", "patch": "@@ -51,7 +51,7 @@ pub fn check_object_cast<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         {\n             let object_trait = object_trait(&object_trait_ty);\n             if !mutability_allowed(referent_mutbl, target_mutbl) {\n-                fcx.tcx().sess.span_err(source_expr.span,\n+                span_err!(fcx.tcx().sess, source_expr.span, E0188,\n                                         \"types differ in mutability\");\n             } else {\n                 // Ensure that if &'a T is cast to &'b Trait, then T : Trait\n@@ -70,19 +70,17 @@ pub fn check_object_cast<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         }\n \n         (_, &ty::ty_uniq(..)) => {\n-            fcx.ccx.tcx.sess.span_err(\n-                source_expr.span,\n-                &format!(\"can only cast an boxed pointer \\\n+            span_err!(fcx.ccx.tcx.sess, source_expr.span, E0189,\n+                \"can only cast a boxed pointer \\\n                          to a boxed object, not a {}\",\n-                        ty::ty_sort_string(fcx.tcx(), source_ty))[]);\n+                      ty::ty_sort_string(fcx.tcx(), source_ty));\n         }\n \n         (_, &ty::ty_rptr(..)) => {\n-            fcx.ccx.tcx.sess.span_err(\n-                source_expr.span,\n-                &format!(\"can only cast a &-pointer \\\n+            span_err!(fcx.ccx.tcx.sess, source_expr.span, E0190,\n+                \"can only cast a &-pointer \\\n                          to an &-object, not a {}\",\n-                        ty::ty_sort_string(fcx.tcx(), source_ty))[]);\n+                        ty::ty_sort_string(fcx.tcx(), source_ty));\n         }\n \n         _ => {\n@@ -272,11 +270,10 @@ fn check_object_type_binds_all_associated_types<'tcx>(tcx: &ty::ctxt<'tcx>,\n     }\n \n     for (trait_def_id, name) in associated_types.into_iter() {\n-        tcx.sess.span_err(\n-            span,\n-            format!(\"the value of the associated type `{}` (from the trait `{}`) must be specified\",\n+        span_err!(tcx.sess, span, E0191,\n+            \"the value of the associated type `{}` (from the trait `{}`) must be specified\",\n                     name.user_string(tcx),\n-                    ty::item_path_str(tcx, trait_def_id)).as_slice());\n+                    ty::item_path_str(tcx, trait_def_id));\n     }\n }\n "}, {"sha": "60284433ffe457f44cbfe52ccaa410a01ca50059", "filename": "src/librustc_typeck/check/wf.rs", "status": "modified", "additions": 9, "deletions": 12, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/b250d9a3c83e046d2abfcf7911c640865e36e430/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b250d9a3c83e046d2abfcf7911c640865e36e430/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs?ref=b250d9a3c83e046d2abfcf7911c640865e36e430", "patch": "@@ -81,10 +81,9 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n                 match ccx.tcx.lang_items.to_builtin_kind(trait_ref.def_id) {\n                     Some(ty::BoundSend) | Some(ty::BoundSync) => {}\n                     Some(_) | None => {\n-                        ccx.tcx.sess.span_err(\n-                            item.span,\n-                            format!(\"negative impls are currently \\\n-                                     allowed just for `Send` and `Sync`\").as_slice())\n+                        span_err!(ccx.tcx.sess, item.span, E0192,\n+                            \"negative impls are currently \\\n+                                     allowed just for `Send` and `Sync`\")\n                     }\n                 }\n             }\n@@ -302,12 +301,11 @@ fn reject_non_type_param_bounds<'tcx>(tcx: &ty::ctxt<'tcx>,\n     fn report_bound_error<'t>(tcx: &ty::ctxt<'t>,\n                           span: Span,\n                           bounded_ty: ty::Ty<'t>) {\n-        tcx.sess.span_err(\n-            span,\n-            format!(\"cannot bound type `{}`, where clause \\\n+        span_err!(tcx.sess, span, E0193,\n+            \"cannot bound type `{}`, where clause \\\n                 bounds may only be attached to types involving \\\n                 type parameters\",\n-                bounded_ty.repr(tcx)).as_slice())\n+                bounded_ty.repr(tcx))\n     }\n \n     fn is_ty_param(ty: ty::Ty) -> bool {\n@@ -326,10 +324,9 @@ fn reject_shadowing_type_parameters<'tcx>(tcx: &ty::ctxt<'tcx>,\n \n     for method_param in generics.types.get_slice(subst::FnSpace).iter() {\n         if impl_params.contains(&method_param.name) {\n-            tcx.sess.span_err(\n-                span,\n-                &*format!(\"type parameter `{}` shadows another type parameter of the same name\",\n-                          token::get_name(method_param.name)));\n+            span_err!(tcx.sess, span, E0194,\n+                \"type parameter `{}` shadows another type parameter of the same name\",\n+                          token::get_name(method_param.name));\n         }\n     }\n }"}, {"sha": "52e81585875abe1a3dce1ba4bb9473f32666c29f", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b250d9a3c83e046d2abfcf7911c640865e36e430/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b250d9a3c83e046d2abfcf7911c640865e36e430/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=b250d9a3c83e046d2abfcf7911c640865e36e430", "patch": "@@ -416,7 +416,7 @@ impl<'cx, 'tcx> Resolver<'cx, 'tcx> {\n \n                 ResolvingUnboxedClosure(_) => {\n                     let span = self.reason.span(self.tcx);\n-                    self.tcx.sess.span_err(span,\n+                    span_err!(self.tcx.sess, span, E0196,\n                                            \"cannot determine a type for this \\\n                                             unboxed closure\")\n                 }"}, {"sha": "e535b86a7bfd1e0cfa72c2cb8e74ed84fcc3e261", "filename": "src/librustc_typeck/coherence/impls.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b250d9a3c83e046d2abfcf7911c640865e36e430/src%2Flibrustc_typeck%2Fcoherence%2Fimpls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b250d9a3c83e046d2abfcf7911c640865e36e430/src%2Flibrustc_typeck%2Fcoherence%2Fimpls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fimpls.rs?ref=b250d9a3c83e046d2abfcf7911c640865e36e430", "patch": "@@ -34,10 +34,9 @@ impl<'cx, 'tcx,'v> visit::Visitor<'v> for ImplsChecker<'cx, 'tcx> {\n                     match trait_ref.self_ty().sty {\n                         ty::ty_struct(..) | ty::ty_enum(..) => {}\n                         _ => {\n-                            self.tcx.sess.span_err(\n-                                item.span,\n-                                &format!(\"builtin traits can only be \\\n-                                          implemented on structs or enums\")[]);\n+                            span_err!(self.tcx.sess, item.span, E0209,\n+                                \"builtin traits can only be \\\n+                                          implemented on structs or enums\");\n                         }\n                     }\n                 }"}, {"sha": "7d59c3f9d3ff5f8d785daeeea2259dee3eb0f0c3", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/b250d9a3c83e046d2abfcf7911c640865e36e430/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b250d9a3c83e046d2abfcf7911c640865e36e430/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=b250d9a3c83e046d2abfcf7911c640865e36e430", "patch": "@@ -490,24 +490,21 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n             match ty::can_type_implement_copy(&param_env, span, self_type) {\n                 Ok(()) => {}\n                 Err(ty::FieldDoesNotImplementCopy(name)) => {\n-                    tcx.sess\n-                       .span_err(span,\n-                                 &format!(\"the trait `Copy` may not be \\\n+                       span_err!(tcx.sess, span, E0204,\n+                                 \"the trait `Copy` may not be \\\n                                           implemented for this type; field \\\n                                           `{}` does not implement `Copy`\",\n-                                         token::get_name(name))[])\n+                                         token::get_name(name))\n                 }\n                 Err(ty::VariantDoesNotImplementCopy(name)) => {\n-                    tcx.sess\n-                       .span_err(span,\n-                                 &format!(\"the trait `Copy` may not be \\\n+                       span_err!(tcx.sess, span, E0205,\n+                                 \"the trait `Copy` may not be \\\n                                           implemented for this type; variant \\\n                                           `{}` does not implement `Copy`\",\n-                                         token::get_name(name))[])\n+                                         token::get_name(name))\n                 }\n                 Err(ty::TypeIsStructural) => {\n-                    tcx.sess\n-                       .span_err(span,\n+                       span_err!(tcx.sess, span, E0206,\n                                  \"the trait `Copy` may not be implemented \\\n                                   for this type; type is not a structure or \\\n                                   enumeration\")"}, {"sha": "60b1fa5f4cf5d1068b3a9479ee321270d351ce0c", "filename": "src/librustc_typeck/coherence/orphan.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b250d9a3c83e046d2abfcf7911c640865e36e430/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b250d9a3c83e046d2abfcf7911c640865e36e430/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs?ref=b250d9a3c83e046d2abfcf7911c640865e36e430", "patch": "@@ -89,13 +89,11 @@ impl<'cx, 'tcx,'v> visit::Visitor<'v> for OrphanChecker<'cx, 'tcx> {\n                     }\n                     Err(traits::OrphanCheckErr::UncoveredTy(param_ty)) => {\n                         if !ty::has_attr(self.tcx, trait_def_id, \"old_orphan_check\") {\n-                            self.tcx.sess.span_err(\n-                                item.span,\n-                                format!(\n+                            span_err!(self.tcx.sess, item.span, E0210,\n                                     \"type parameter `{}` is not constrained by any local type; \\\n                                      only traits defined in the current crate can be implemented \\\n                                      for a type parameter\",\n-                                    param_ty.user_string(self.tcx)).as_slice());\n+                                    param_ty.user_string(self.tcx));\n                             self.tcx.sess.span_note(\n                                 item.span,\n                                 format!(\"for a limited time, you can add \\"}, {"sha": "867dea9588568b515c68d7f699b258505e9da37c", "filename": "src/librustc_typeck/coherence/unsafety.rs", "status": "modified", "additions": 9, "deletions": 13, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/b250d9a3c83e046d2abfcf7911c640865e36e430/src%2Flibrustc_typeck%2Fcoherence%2Funsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b250d9a3c83e046d2abfcf7911c640865e36e430/src%2Flibrustc_typeck%2Fcoherence%2Funsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Funsafety.rs?ref=b250d9a3c83e046d2abfcf7911c640865e36e430", "patch": "@@ -37,8 +37,7 @@ impl<'cx, 'tcx,'v> visit::Visitor<'v> for UnsafetyChecker<'cx, 'tcx> {\n                         match unsafety {\n                             ast::Unsafety::Normal => { /* OK */ }\n                             ast::Unsafety::Unsafe => {\n-                                self.tcx.sess.span_err(\n-                                    item.span,\n+                                span_err!(self.tcx.sess, item.span, E0197,\n                                     \"inherent impls cannot be declared as unsafe\");\n                             }\n                         }\n@@ -49,24 +48,21 @@ impl<'cx, 'tcx,'v> visit::Visitor<'v> for UnsafetyChecker<'cx, 'tcx> {\n                         match (trait_def.unsafety, unsafety, polarity) {\n                             (ast::Unsafety::Unsafe,\n                              ast::Unsafety::Unsafe, ast::ImplPolarity::Negative) => {\n-                                self.tcx.sess.span_err(\n-                                    item.span,\n-                                    format!(\"negative implementations are not unsafe\").as_slice());\n+                                span_err!(self.tcx.sess, item.span, E0198,\n+                                    \"negative implementations are not unsafe\");\n                             }\n \n                             (ast::Unsafety::Normal, ast::Unsafety::Unsafe, _) => {\n-                                self.tcx.sess.span_err(\n-                                    item.span,\n-                                    format!(\"implementing the trait `{}` is not unsafe\",\n-                                            trait_ref.user_string(self.tcx)).as_slice());\n+                                span_err!(self.tcx.sess, item.span, E0199,\n+                                    \"implementing the trait `{}` is not unsafe\",\n+                                            trait_ref.user_string(self.tcx));\n                             }\n \n                             (ast::Unsafety::Unsafe,\n                              ast::Unsafety::Normal, ast::ImplPolarity::Positive) => {\n-                                self.tcx.sess.span_err(\n-                                    item.span,\n-                                    format!(\"the trait `{}` requires an `unsafe impl` declaration\",\n-                                            trait_ref.user_string(self.tcx)).as_slice());\n+                                span_err!(self.tcx.sess, item.span, E0200,\n+                                    \"the trait `{}` requires an `unsafe impl` declaration\",\n+                                            trait_ref.user_string(self.tcx));\n                             }\n \n                             (ast::Unsafety::Unsafe,"}, {"sha": "664e5eaa45baeb896ca73e8f0d74f7bbbebb5b80", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b250d9a3c83e046d2abfcf7911c640865e36e430/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b250d9a3c83e046d2abfcf7911c640865e36e430/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=b250d9a3c83e046d2abfcf7911c640865e36e430", "patch": "@@ -452,7 +452,7 @@ fn convert_methods<'a,'tcx,'i,I>(ccx: &CollectCtxt<'a, 'tcx>,\n     let mut seen_methods = FnvHashSet();\n     for m in ms {\n         if !seen_methods.insert(m.pe_ident().repr(tcx)) {\n-            tcx.sess.span_err(m.span, \"duplicate method in trait impl\");\n+            span_err!(tcx.sess, m.span, E0201, \"duplicate method in trait impl\");\n         }\n \n         let m_def_id = local_def(m.id);\n@@ -608,7 +608,7 @@ fn convert(ccx: &CollectCtxt, it: &ast::Item) {\n                     }\n                     ast::TypeImplItem(ref typedef) => {\n                         if opt_trait_ref.is_none() {\n-                            tcx.sess.span_err(typedef.span,\n+                            span_err!(tcx.sess, typedef.span, E0202,\n                                               \"associated items are not allowed in inherent impls\");\n                         }\n \n@@ -1160,7 +1160,8 @@ fn add_unsized_bound<'a,'tcx>(ccx: &CollectCtxt<'a,'tcx>,\n                 assert!(ptr.bound_lifetimes.is_empty());\n                 unbound = Some(ptr.trait_ref.clone());\n             } else {\n-                ccx.tcx.sess.span_err(span, \"type parameter has more than one relaxed default \\\n+                span_err!(ccx.tcx.sess, span, E0203,\n+                          \"type parameter has more than one relaxed default \\\n                                                 bound, only one is supported\");\n             }\n         }\n@@ -1690,11 +1691,10 @@ fn enforce_impl_ty_params_are_constrained<'tcx>(tcx: &ty::ctxt<'tcx>,\n                              impl trait, self type, or predicates\",\n                             param_ty.user_string(tcx)).as_slice());\n             } else {\n-                tcx.sess.span_err(\n-                    ty_param.span,\n-                    format!(\"the type parameter `{}` is not constrained by the \\\n+                span_err!(tcx.sess, ty_param.span, E0207,\n+                    \"the type parameter `{}` is not constrained by the \\\n                              impl trait, self type, or predicates\",\n-                            param_ty.user_string(tcx)).as_slice());\n+                            param_ty.user_string(tcx));\n                 tcx.sess.span_help(\n                     ty_param.span,\n                     format!(\"you can temporarily opt out of this rule by placing \\"}, {"sha": "3627fa41160608adf2778a3593e93737fc780277", "filename": "src/librustc_typeck/diagnostics.rs", "status": "modified", "additions": 75, "deletions": 59, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/b250d9a3c83e046d2abfcf7911c640865e36e430/src%2Flibrustc_typeck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b250d9a3c83e046d2abfcf7911c640865e36e430/src%2Flibrustc_typeck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fdiagnostics.rs?ref=b250d9a3c83e046d2abfcf7911c640865e36e430", "patch": "@@ -10,38 +10,7 @@\n \n #![allow(non_snake_case)]\n \n-register_diagnostic! {\n-    E0001,\n-r##\"\n-    This error suggests that the expression arm corresponding to the noted pattern\n-    will never be reached as for all possible values of the expression being matched,\n-    one of the preceeding patterns will match.\n-\n-    This means that perhaps some of the preceeding patterns are too general, this\n-    one is too specific or the ordering is incorrect.\n-\"## }\n-\n register_diagnostics! {\n-    E0002,\n-    E0003,\n-    E0004,\n-    E0005,\n-    E0006,\n-    E0007,\n-    E0008,\n-    E0009,\n-    E0010,\n-    E0011,\n-    E0012,\n-    E0013,\n-    E0014,\n-    E0015,\n-    E0016,\n-    E0017,\n-    E0018,\n-    E0019,\n-    E0020,\n-    E0022,\n     E0023,\n     E0024,\n     E0025,\n@@ -61,12 +30,9 @@ register_diagnostics! {\n     E0046,\n     E0049,\n     E0050,\n-    E0051,\n-    E0052,\n     E0053,\n     E0054,\n     E0055,\n-    E0056,\n     E0057,\n     E0059,\n     E0060,\n@@ -101,16 +67,12 @@ register_diagnostics! {\n     E0092,\n     E0093,\n     E0094,\n-    E0100,\n     E0101,\n     E0102,\n     E0103,\n     E0104,\n     E0106,\n     E0107,\n-    E0108,\n-    E0109,\n-    E0110,\n     E0116,\n     E0117,\n     E0118,\n@@ -125,38 +87,92 @@ register_diagnostics! {\n     E0130,\n     E0131,\n     E0132,\n-    E0133,\n-    E0134,\n-    E0135,\n-    E0136,\n-    E0137,\n-    E0138,\n-    E0139,\n-    E0140,\n     E0141,\n-    E0152,\n-    E0153,\n-    E0157,\n-    E0158,\n     E0159,\n-    E0161,\n-    E0162,\n     E0163,\n     E0164,\n-    E0165,\n     E0166,\n     E0167,\n     E0168,\n-    E0169,\n-    E0171,\n     E0172,\n     E0173, // manual implementations of unboxed closure traits are experimental\n     E0174, // explicit use of unboxed closure methods are experimental\n-    E0177,\n     E0178,\n-    E0180,\n-    E0181,\n     E0182,\n     E0183,\n-    E0184\n+    E0184,\n+    E0185,\n+    E0186,\n+    E0187, // can't infer the kind of the closure\n+    E0188, // types differ in mutability\n+    E0189, // can only cast a boxed pointer to a boxed object\n+    E0190, // can only cast a &-pointer to an &-object\n+    E0191, // value of the associated type must be specified\n+    E0192, // negative imples are allowed just fo `Send` and `Sync`\n+    E0193, // cannot bound type where clause bounds may only be attached to types\n+           // involving type parameters\n+    E0194,\n+    E0195, // lifetime parameters or bounds on method do not match the trait declaration\n+    E0196, // cannot determine a type for this unboxed closure\n+    E0197, // inherent impls cannot be declared as unsafe\n+    E0198, // negative implementations are not unsafe\n+    E0199, // implementing trait is not unsafe\n+    E0200, // trait requires an `unsafe impl` declaration\n+    E0201, // duplicate method in trait impl\n+    E0202, // associated items are not allowed in inherint impls\n+    E0203, // type parameter has more than one relaxed default bound,\n+           // and only one is supported\n+    E0204, // trait `Copy` may not be implemented for this type; field\n+           // does not implement `Copy`\n+    E0205, // trait `Copy` may not be implemented for this type; variant\n+           // does not implement `copy`\n+    E0206, // trait `Copy` may not be implemented for this type; type is\n+           // not a structure or enumeration\n+    E0207, // type parameter is not constrained by the impl trait, self type, or predicate\n+    E0208,\n+    E0209, // builtin traits can only be implemented on structs or enums\n+    E0210, // type parameter is not constrained by any local type\n+    E0211,\n+    E0212, // cannot extract an associated type from a higher-ranked trait bound\n+    E0213, // associated types are not accepted in this context\n+    E0214, // parenthesized parameters may only be used with a trait\n+    E0215, // angle-bracket notation is not stable with `Fn`\n+    E0216, // parenthetical notation is only stable with `Fn`\n+    E0217, // ambiguous associated type, defined in multiple supertraits\n+    E0218, // no associated type defined\n+    E0219, // associated type defined in higher-ranked supertrait\n+    E0220, // associated type not found for type parameter\n+    E0221, // ambiguous associated type in bounds\n+    E0222, // variadic function must have C calling convention\n+    E0223, // ambiguous associated type\n+    E0224, // at least one non-builtin train is required for an object type\n+    E0225, // only the builtin traits can be used as closure or object bounds\n+    E0226, // only a single explicit lifetime bound is permitted\n+    E0227, // ambiguous lifetime bound, explicit lifetime bound required\n+    E0228, // explicit lifetime bound required\n+    E0229, // associated type bindings are not allowed here\n+    E0230, // there is no type parameter on trait\n+    E0231, // only named substitution parameters are allowed\n+    E0232, // this attribute must have a value\n+    E0233,\n+    E0234, // `for` loop expression has type which does not implement the `Iterator` trait\n+    E0235, // structure constructor specifies a structure of type but\n+    E0236, // no lang item for range syntax\n+    E0237, // no lang item for range syntax\n+    E0238, // parenthesized parameters may only be used with a trait\n+    E0239, // `next` method of `Iterator` trait has unexpected type\n+    E0240,\n+    E0241,\n+    E0242, // internal error looking up a definition\n+    E0243, // wrong number of type arguments\n+    E0244, // wrong number of type arguments\n+    E0245, // not a trait\n+    E0246, // illegal recursive type\n+    E0247, // found module name used as a type\n+    E0248, // found value name used as a type\n+    E0249, // expected constant expr for array length\n+    E0250  // expected constant expr for array length\n }\n+\n+__build_diagnostic_array! { DIAGNOSTICS }\n+"}, {"sha": "78007f3552ece5b61d336e719d5f0a4d6b286186", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b250d9a3c83e046d2abfcf7911c640865e36e430/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b250d9a3c83e046d2abfcf7911c640865e36e430/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=b250d9a3c83e046d2abfcf7911c640865e36e430", "patch": "@@ -111,6 +111,10 @@ use syntax::ast_util::local_def;\n \n use std::cell::RefCell;\n \n+// NB: This module needs to be declared first so diagnostics are\n+// registered before they are used.\n+pub mod diagnostics;\n+\n mod check;\n mod rscope;\n mod astconv;\n@@ -158,7 +162,7 @@ fn lookup_def_tcx(tcx:&ty::ctxt, sp: Span, id: ast::NodeId) -> def::Def {\n     match tcx.def_map.borrow().get(&id) {\n         Some(x) => x.clone(),\n         _ => {\n-            tcx.sess.span_fatal(sp, \"internal error looking up a definition\")\n+            span_fatal!(tcx.sess, sp, E0242, \"internal error looking up a definition\")\n         }\n     }\n }\n@@ -202,11 +206,11 @@ fn require_same_types<'a, 'tcx, M>(tcx: &ty::ctxt<'tcx>,\n     match result {\n         Ok(_) => true,\n         Err(ref terr) => {\n-            tcx.sess.span_err(span,\n-                              &format!(\"{}: {}\",\n+            span_err!(tcx.sess, span, E0211,\n+                              \"{}: {}\",\n                                       msg(),\n                                       ty::type_err_to_str(tcx,\n-                                                          terr))[]);\n+                                                          terr));\n             ty::note_and_explain_type_err(tcx, terr);\n             false\n         }"}, {"sha": "3df3e1bddc5b74364d7990030b4e54ba4759556a", "filename": "src/librustc_typeck/variance.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b250d9a3c83e046d2abfcf7911c640865e36e430/src%2Flibrustc_typeck%2Fvariance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b250d9a3c83e046d2abfcf7911c640865e36e430/src%2Flibrustc_typeck%2Fvariance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance.rs?ref=b250d9a3c83e046d2abfcf7911c640865e36e430", "patch": "@@ -1055,7 +1055,7 @@ impl<'a, 'tcx> SolveContext<'a, 'tcx> {\n             // attribute and report an error with various results if found.\n             if ty::has_attr(tcx, item_def_id, \"rustc_variance\") {\n                 let found = item_variances.repr(tcx);\n-                tcx.sess.span_err(tcx.map.span(item_id), &found[]);\n+                span_err!(tcx.sess, tcx.map.span(item_id), E0208, \"{}\", &found[]);\n             }\n \n             let newly_added = tcx.item_variance_map.borrow_mut()"}, {"sha": "b26ec64c24bf2d98fce18cc2733b36951ff5145a", "filename": "src/libsyntax/diagnostic.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b250d9a3c83e046d2abfcf7911c640865e36e430/src%2Flibsyntax%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b250d9a3c83e046d2abfcf7911c640865e36e430/src%2Flibsyntax%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic.rs?ref=b250d9a3c83e046d2abfcf7911c640865e36e430", "patch": "@@ -92,6 +92,10 @@ impl SpanHandler {\n         self.handler.emit(Some((&self.cm, sp)), msg, Fatal);\n         panic!(FatalError);\n     }\n+    pub fn span_fatal_with_code(&self, sp: Span, msg: &str, code: &str) -> ! {\n+        self.handler.emit_with_code(Some((&self.cm, sp)), msg, code, Fatal);\n+        panic!(FatalError);\n+    }\n     pub fn span_err(&self, sp: Span, msg: &str) {\n         self.handler.emit(Some((&self.cm, sp)), msg, Error);\n         self.handler.bump_err_count();"}, {"sha": "9321d3ca3df1141196a45917db933c208d3fb56d", "filename": "src/libsyntax/diagnostics/macros.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b250d9a3c83e046d2abfcf7911c640865e36e430/src%2Flibsyntax%2Fdiagnostics%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b250d9a3c83e046d2abfcf7911c640865e36e430/src%2Flibsyntax%2Fdiagnostics%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostics%2Fmacros.rs?ref=b250d9a3c83e046d2abfcf7911c640865e36e430", "patch": "@@ -14,6 +14,14 @@ macro_rules! register_diagnostic {\n     ($code:tt) => (__register_diagnostic! { $code })\n }\n \n+#[macro_export]\n+macro_rules! span_fatal {\n+    ($session:expr, $span:expr, $code:ident, $($message:tt)*) => ({\n+        __diagnostic_used!($code);\n+        $session.span_fatal_with_code($span, format!($($message)*).as_slice(), stringify!($code))\n+    })\n+}\n+\n #[macro_export]\n macro_rules! span_err {\n     ($session:expr, $span:expr, $code:ident, $($message:tt)*) => ({\n@@ -51,3 +59,9 @@ macro_rules! register_diagnostics {\n     )\n }\n \n+#[macro_export]\n+macro_rules! register_long_diagnostics {\n+    ($($code:tt: $description:tt),*) => (\n+        $(register_diagnostic! { $code, $description })*\n+    )\n+}"}, {"sha": "0e99829fa1c66e477244b0cc9279164c6f0b2f51", "filename": "src/libsyntax/diagnostics/plugin.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b250d9a3c83e046d2abfcf7911c640865e36e430/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b250d9a3c83e046d2abfcf7911c640865e36e430/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs?ref=b250d9a3c83e046d2abfcf7911c640865e36e430", "patch": "@@ -65,6 +65,13 @@ pub fn expand_diagnostic_used<'cx>(ecx: &'cx mut ExtCtxt,\n         }\n         ()\n     });\n+    with_registered_diagnostics(|diagnostics| {\n+        if !diagnostics.contains_key(&code.name) {\n+            ecx.span_err(span, &format!(\n+                \"used diagnostic code {} not registered\", token::get_ident(code).get()\n+            )[]);\n+        }\n+    });\n     MacExpr::new(quote_expr!(ecx, ()))\n }\n "}, {"sha": "867008cd25917f75195f72b833ad69eaf2ed80e8", "filename": "src/test/run-make/issue-19371/foo.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b250d9a3c83e046d2abfcf7911c640865e36e430/src%2Ftest%2Frun-make%2Fissue-19371%2Ffoo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b250d9a3c83e046d2abfcf7911c640865e36e430/src%2Ftest%2Frun-make%2Fissue-19371%2Ffoo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fissue-19371%2Ffoo.rs?ref=b250d9a3c83e046d2abfcf7911c640865e36e430", "patch": "@@ -44,7 +44,7 @@ fn basic_sess(sysroot: Path) -> Session {\n     opts.output_types = vec![OutputTypeExe];\n     opts.maybe_sysroot = Some(sysroot);\n \n-    let descriptions = Registry::new(&rustc::DIAGNOSTICS);\n+    let descriptions = Registry::new(&rustc::diagnostics::DIAGNOSTICS);\n     let sess = build_session(opts, None, descriptions);\n     sess\n }"}]}