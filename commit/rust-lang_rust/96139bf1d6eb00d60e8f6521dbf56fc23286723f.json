{"sha": "96139bf1d6eb00d60e8f6521dbf56fc23286723f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk2MTM5YmYxZDZlYjAwZDYwZThmNjUyMWRiZjU2ZmMyMzI4NjcyM2Y=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2014-02-07T11:38:20Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2014-02-11T21:55:22Z"}, "message": "remove antiquated reflect test rather than bring it up to date", "tree": {"sha": "93a1806fa1d118c254fcb91dc69f4b7184d28fec", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/93a1806fa1d118c254fcb91dc69f4b7184d28fec"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/96139bf1d6eb00d60e8f6521dbf56fc23286723f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/96139bf1d6eb00d60e8f6521dbf56fc23286723f", "html_url": "https://github.com/rust-lang/rust/commit/96139bf1d6eb00d60e8f6521dbf56fc23286723f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/96139bf1d6eb00d60e8f6521dbf56fc23286723f/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "852a49fd9cf3860aa018c1a2d66f644c6813d849", "url": "https://api.github.com/repos/rust-lang/rust/commits/852a49fd9cf3860aa018c1a2d66f644c6813d849", "html_url": "https://github.com/rust-lang/rust/commit/852a49fd9cf3860aa018c1a2d66f644c6813d849"}], "stats": {"total": 627, "additions": 0, "deletions": 627}, "files": [{"sha": "bc491cc9b7f2ec4d9a9858b9811d3f3dea22615f", "filename": "src/test/run-pass/reflect-visit-data.rs", "status": "removed", "additions": 0, "deletions": 627, "changes": 627, "blob_url": "https://github.com/rust-lang/rust/blob/852a49fd9cf3860aa018c1a2d66f644c6813d849/src%2Ftest%2Frun-pass%2Freflect-visit-data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/852a49fd9cf3860aa018c1a2d66f644c6813d849/src%2Ftest%2Frun-pass%2Freflect-visit-data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Freflect-visit-data.rs?ref=852a49fd9cf3860aa018c1a2d66f644c6813d849", "patch": "@@ -1,627 +0,0 @@\n-// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// ignore-fast\n-\n-#[feature(managed_boxes)];\n-\n-use std::cell::RefCell;\n-use std::libc::c_void;\n-use std::ptr;\n-use std::mem;\n-use std::unstable::intrinsics::{TyDesc, get_tydesc, visit_tydesc, TyVisitor, Disr, Opaque};\n-use std::unstable::raw::Vec;\n-\n-#[doc = \"High-level interfaces to `std::unstable::intrinsics::visit_ty` reflection system.\"]\n-\n-/// Trait for visitor that wishes to reflect on data.\n-trait movable_ptr {\n-    fn move_ptr(&mut self, adjustment: |*c_void| -> *c_void);\n-}\n-\n-/// Helper function for alignment calculation.\n-#[inline(always)]\n-fn align(size: uint, align: uint) -> uint {\n-    ((size + align) - 1u) & !(align - 1u)\n-}\n-\n-struct ptr_visit_adaptor<V>(Inner<V>);\n-\n-impl<V:TyVisitor + movable_ptr> ptr_visit_adaptor<V> {\n-    fn inner<'a>(&'a mut self) -> &'a mut V {\n-        let ptr_visit_adaptor(ref mut i) = *self;\n-        &mut i.inner\n-    }\n-}\n-\n-impl<V:TyVisitor + movable_ptr> ptr_visit_adaptor<V> {\n-\n-    #[inline(always)]\n-    pub fn bump(&mut self, sz: uint) {\n-      self.inner().move_ptr(|p| ((p as uint) + sz) as *c_void)\n-    }\n-\n-    #[inline(always)]\n-    pub fn align(&mut self, a: uint) {\n-      self.inner().move_ptr(|p| align(p as uint, a) as *c_void)\n-    }\n-\n-    #[inline(always)]\n-    pub fn align_to<T>(&mut self) {\n-        self.align(mem::min_align_of::<T>());\n-    }\n-\n-    #[inline(always)]\n-    pub fn bump_past<T>(&mut self) {\n-        self.bump(mem::size_of::<T>());\n-    }\n-\n-}\n-\n-impl<V:TyVisitor + movable_ptr> TyVisitor for ptr_visit_adaptor<V> {\n-\n-    fn visit_bot(&mut self) -> bool {\n-        self.align_to::<()>();\n-        if ! self.inner().visit_bot() { return false; }\n-        self.bump_past::<()>();\n-        true\n-    }\n-\n-    fn visit_nil(&mut self) -> bool {\n-        self.align_to::<()>();\n-        if ! self.inner().visit_nil() { return false; }\n-        self.bump_past::<()>();\n-        true\n-    }\n-\n-    fn visit_bool(&mut self) -> bool {\n-        self.align_to::<bool>();\n-        if ! self.inner().visit_bool() { return false; }\n-        self.bump_past::<bool>();\n-        true\n-    }\n-\n-    fn visit_int(&mut self) -> bool {\n-        self.align_to::<int>();\n-        if ! self.inner().visit_int() { return false; }\n-        self.bump_past::<int>();\n-        true\n-    }\n-\n-    fn visit_i8(&mut self) -> bool {\n-        self.align_to::<i8>();\n-        if ! self.inner().visit_i8() { return false; }\n-        self.bump_past::<i8>();\n-        true\n-    }\n-\n-    fn visit_i16(&mut self) -> bool {\n-        self.align_to::<i16>();\n-        if ! self.inner().visit_i16() { return false; }\n-        self.bump_past::<i16>();\n-        true\n-    }\n-\n-    fn visit_i32(&mut self) -> bool {\n-        self.align_to::<i32>();\n-        if ! self.inner().visit_i32() { return false; }\n-        self.bump_past::<i32>();\n-        true\n-    }\n-\n-    fn visit_i64(&mut self) -> bool {\n-        self.align_to::<i64>();\n-        if ! self.inner().visit_i64() { return false; }\n-        self.bump_past::<i64>();\n-        true\n-    }\n-\n-    fn visit_uint(&mut self) -> bool {\n-        self.align_to::<uint>();\n-        if ! self.inner().visit_uint() { return false; }\n-        self.bump_past::<uint>();\n-        true\n-    }\n-\n-    fn visit_u8(&mut self) -> bool {\n-        self.align_to::<u8>();\n-        if ! self.inner().visit_u8() { return false; }\n-        self.bump_past::<u8>();\n-        true\n-    }\n-\n-    fn visit_u16(&mut self) -> bool {\n-        self.align_to::<u16>();\n-        if ! self.inner().visit_u16() { return false; }\n-        self.bump_past::<u16>();\n-        true\n-    }\n-\n-    fn visit_u32(&mut self) -> bool {\n-        self.align_to::<u32>();\n-        if ! self.inner().visit_u32() { return false; }\n-        self.bump_past::<u32>();\n-        true\n-    }\n-\n-    fn visit_u64(&mut self) -> bool {\n-        self.align_to::<u64>();\n-        if ! self.inner().visit_u64() { return false; }\n-        self.bump_past::<u64>();\n-        true\n-    }\n-\n-    fn visit_f32(&mut self) -> bool {\n-        self.align_to::<f32>();\n-        if ! self.inner().visit_f32() { return false; }\n-        self.bump_past::<f32>();\n-        true\n-    }\n-\n-    fn visit_f64(&mut self) -> bool {\n-        self.align_to::<f64>();\n-        if ! self.inner().visit_f64() { return false; }\n-        self.bump_past::<f64>();\n-        true\n-    }\n-\n-    fn visit_char(&mut self) -> bool {\n-        self.align_to::<char>();\n-        if ! self.inner().visit_char() { return false; }\n-        self.bump_past::<char>();\n-        true\n-    }\n-\n-    fn visit_estr_box(&mut self) -> bool {\n-        true\n-    }\n-\n-    fn visit_estr_uniq(&mut self) -> bool {\n-        self.align_to::<~str>();\n-        if ! self.inner().visit_estr_uniq() { return false; }\n-        self.bump_past::<~str>();\n-        true\n-    }\n-\n-    fn visit_estr_slice(&mut self) -> bool {\n-        self.align_to::<&'static str>();\n-        if ! self.inner().visit_estr_slice() { return false; }\n-        self.bump_past::<&'static str>();\n-        true\n-    }\n-\n-    fn visit_estr_fixed(&mut self, n: uint,\n-                        sz: uint,\n-                        align: uint) -> bool {\n-        self.align(align);\n-        if ! self.inner().visit_estr_fixed(n, sz, align) { return false; }\n-        self.bump(sz);\n-        true\n-    }\n-\n-    fn visit_box(&mut self, mtbl: uint, inner: *TyDesc) -> bool {\n-        self.align_to::<@u8>();\n-        if ! self.inner().visit_box(mtbl, inner) { return false; }\n-        self.bump_past::<@u8>();\n-        true\n-    }\n-\n-    fn visit_uniq(&mut self, mtbl: uint, inner: *TyDesc) -> bool {\n-        self.align_to::<~u8>();\n-        if ! self.inner().visit_uniq(mtbl, inner) { return false; }\n-        self.bump_past::<~u8>();\n-        true\n-    }\n-\n-    fn visit_ptr(&mut self, mtbl: uint, inner: *TyDesc) -> bool {\n-        self.align_to::<*u8>();\n-        if ! self.inner().visit_ptr(mtbl, inner) { return false; }\n-        self.bump_past::<*u8>();\n-        true\n-    }\n-\n-    fn visit_rptr(&mut self, mtbl: uint, inner: *TyDesc) -> bool {\n-        self.align_to::<&'static u8>();\n-        if ! self.inner().visit_rptr(mtbl, inner) { return false; }\n-        self.bump_past::<&'static u8>();\n-        true\n-    }\n-\n-    fn visit_unboxed_vec(&mut self, mtbl: uint, inner: *TyDesc) -> bool {\n-        self.align_to::<Vec<()>>();\n-        // FIXME (#3732): Inner really has to move its own pointers on this one.\n-        // or else possibly we could have some weird interface wherein we\n-        // read-off a word from inner's pointers, but the read-word has to\n-        // always be the same in all sub-pointers? Dubious.\n-        if ! self.inner().visit_vec(mtbl, inner) { return false; }\n-        true\n-    }\n-\n-    fn visit_vec(&mut self, mtbl: uint, inner: *TyDesc) -> bool {\n-        self.align_to::<~[u8]>();\n-        if ! self.inner().visit_vec(mtbl, inner) { return false; }\n-        self.bump_past::<~[u8]>();\n-        true\n-    }\n-\n-    fn visit_evec_box(&mut self, mtbl: uint, inner: *TyDesc) -> bool {\n-        true\n-    }\n-\n-    fn visit_evec_uniq(&mut self, mtbl: uint, inner: *TyDesc) -> bool {\n-        self.align_to::<~[u8]>();\n-        if ! self.inner().visit_evec_uniq(mtbl, inner) { return false; }\n-        self.bump_past::<~[u8]>();\n-        true\n-    }\n-\n-    fn visit_evec_slice(&mut self, mtbl: uint, inner: *TyDesc) -> bool {\n-        self.align_to::<&'static [u8]>();\n-        if ! self.inner().visit_evec_slice(mtbl, inner) { return false; }\n-        self.bump_past::<&'static [u8]>();\n-        true\n-    }\n-\n-    fn visit_evec_fixed(&mut self, n: uint, sz: uint, align: uint,\n-                        mtbl: uint, inner: *TyDesc) -> bool {\n-        self.align(align);\n-        if ! self.inner().visit_evec_fixed(n, sz, align, mtbl, inner) {\n-            return false;\n-        }\n-        self.bump(sz);\n-        true\n-    }\n-\n-    fn visit_enter_rec(&mut self, n_fields: uint, sz: uint, align: uint) -> bool {\n-        self.align(align);\n-        if ! self.inner().visit_enter_rec(n_fields, sz, align) { return false; }\n-        true\n-    }\n-\n-    fn visit_rec_field(&mut self, i: uint, name: &str,\n-                       mtbl: uint, inner: *TyDesc) -> bool {\n-        if ! self.inner().visit_rec_field(i, name, mtbl, inner) { return false; }\n-        true\n-    }\n-\n-    fn visit_leave_rec(&mut self, n_fields: uint, sz: uint, align: uint) -> bool {\n-        if ! self.inner().visit_leave_rec(n_fields, sz, align) { return false; }\n-        true\n-    }\n-\n-    fn visit_enter_class(&mut self, name: &str, named_fields: bool, n_fields: uint, sz: uint,\n-                         align: uint) -> bool {\n-        self.align(align);\n-        if ! self.inner().visit_enter_class(name, named_fields, n_fields, sz, align) {\n-            return false;\n-        }\n-        true\n-    }\n-\n-    fn visit_class_field(&mut self, i: uint, name: &str, named: bool,\n-                         mtbl: uint, inner: *TyDesc) -> bool {\n-        if ! self.inner().visit_class_field(i, name, named, mtbl, inner) {\n-            return false;\n-        }\n-        true\n-    }\n-\n-    fn visit_leave_class(&mut self, name: &str, named_fields: bool, n_fields: uint, sz: uint,\n-                         align: uint) -> bool {\n-        if ! self.inner().visit_leave_class(name, named_fields, n_fields, sz, align) {\n-            return false;\n-        }\n-        true\n-    }\n-\n-    fn visit_enter_tup(&mut self, n_fields: uint, sz: uint, align: uint) -> bool {\n-        self.align(align);\n-        if ! self.inner().visit_enter_tup(n_fields, sz, align) { return false; }\n-        true\n-    }\n-\n-    fn visit_tup_field(&mut self, i: uint, inner: *TyDesc) -> bool {\n-        if ! self.inner().visit_tup_field(i, inner) { return false; }\n-        true\n-    }\n-\n-    fn visit_leave_tup(&mut self, n_fields: uint, sz: uint, align: uint) -> bool {\n-        if ! self.inner().visit_leave_tup(n_fields, sz, align) { return false; }\n-        true\n-    }\n-\n-    fn visit_enter_fn(&mut self, purity: uint, proto: uint,\n-                      n_inputs: uint, retstyle: uint) -> bool {\n-        if ! self.inner().visit_enter_fn(purity, proto, n_inputs, retstyle) {\n-            return false\n-        }\n-        true\n-    }\n-\n-    fn visit_fn_input(&mut self, i: uint, mode: uint, inner: *TyDesc) -> bool {\n-        if ! self.inner().visit_fn_input(i, mode, inner) { return false; }\n-        true\n-    }\n-\n-    fn visit_fn_output(&mut self, retstyle: uint, variadic: bool, inner: *TyDesc) -> bool {\n-        if ! self.inner().visit_fn_output(retstyle, variadic, inner) { return false; }\n-        true\n-    }\n-\n-    fn visit_leave_fn(&mut self, purity: uint, proto: uint,\n-                      n_inputs: uint, retstyle: uint) -> bool {\n-        if ! self.inner().visit_leave_fn(purity, proto, n_inputs, retstyle) {\n-            return false;\n-        }\n-        true\n-    }\n-\n-    fn visit_enter_enum(&mut self, n_variants: uint,\n-                        get_disr: extern unsafe fn(ptr: *Opaque) -> Disr,\n-                        sz: uint, align: uint)\n-                     -> bool {\n-        self.align(align);\n-        if ! self.inner().visit_enter_enum(n_variants, get_disr, sz, align) { return false; }\n-        true\n-    }\n-\n-    fn visit_enter_enum_variant(&mut self, variant: uint,\n-                                disr_val: Disr,\n-                                n_fields: uint,\n-                                name: &str) -> bool {\n-        if ! self.inner().visit_enter_enum_variant(variant, disr_val,\n-                                                 n_fields, name) {\n-            return false;\n-        }\n-        true\n-    }\n-\n-    fn visit_enum_variant_field(&mut self, i: uint, offset: uint, inner: *TyDesc) -> bool {\n-        if ! self.inner().visit_enum_variant_field(i, offset, inner) { return false; }\n-        true\n-    }\n-\n-    fn visit_leave_enum_variant(&mut self, variant: uint,\n-                                disr_val: Disr,\n-                                n_fields: uint,\n-                                name: &str) -> bool {\n-        if ! self.inner().visit_leave_enum_variant(variant, disr_val,\n-                                                 n_fields, name) {\n-            return false;\n-        }\n-        true\n-    }\n-\n-    fn visit_leave_enum(&mut self, n_variants: uint,\n-                        get_disr: extern unsafe fn(ptr: *Opaque) -> Disr,\n-                        sz: uint, align: uint)\n-                     -> bool {\n-        if ! self.inner().visit_leave_enum(n_variants, get_disr, sz, align) { return false; }\n-        true\n-    }\n-\n-    fn visit_trait(&mut self, name: &str) -> bool {\n-        self.align_to::<~TyVisitor>();\n-        if ! self.inner().visit_trait(name) { return false; }\n-        self.bump_past::<~TyVisitor>();\n-        true\n-    }\n-\n-    fn visit_param(&mut self, i: uint) -> bool {\n-        if ! self.inner().visit_param(i) { return false; }\n-        true\n-    }\n-\n-    fn visit_self(&mut self) -> bool {\n-        self.align_to::<&'static u8>();\n-        if ! self.inner().visit_self() { return false; }\n-        self.align_to::<&'static u8>();\n-        true\n-    }\n-\n-    fn visit_type(&mut self) -> bool {\n-        if ! self.inner().visit_type() { return false; }\n-        true\n-    }\n-}\n-\n-struct my_visitor(@RefCell<Stuff>);\n-\n-#[deriving(Clone)]\n-struct Stuff {\n-    ptr1: *c_void,\n-    ptr2: *c_void,\n-    vals: ~[~str]\n-}\n-\n-impl my_visitor {\n-    pub fn get<T:Clone>(&mut self, f: |T|) {\n-        unsafe {\n-            let my_visitor(s) = *self;\n-            f((*((*s).get().ptr1 as *T)).clone());\n-        }\n-    }\n-\n-    pub fn visit_inner(&mut self, inner: *TyDesc) -> bool {\n-        unsafe {\n-            let my_visitor(s) = *self;\n-            let u = my_visitor(s);\n-            let mut v = ptr_visit_adaptor::<my_visitor>(Inner {inner: u});\n-            visit_tydesc(inner, &mut v as &mut TyVisitor);\n-            true\n-        }\n-    }\n-}\n-\n-struct Inner<V> { inner: V }\n-\n-impl movable_ptr for my_visitor {\n-    fn move_ptr(&mut self, adjustment: |*c_void| -> *c_void) {\n-        let my_visitor(s) = *self;\n-        let mut this = s.borrow_mut();\n-        this.get().ptr1 = adjustment(this.get().ptr1);\n-        this.get().ptr2 = adjustment(this.get().ptr2);\n-    }\n-}\n-\n-impl TyVisitor for my_visitor {\n-\n-    fn visit_bot(&mut self) -> bool { true }\n-    fn visit_nil(&mut self) -> bool { true }\n-    fn visit_bool(&mut self) -> bool {\n-        self.get::<bool>(|b| {\n-            let my_visitor(s) = *self;\n-            let mut this = s.borrow_mut();\n-            this.get().vals.push(b.to_str());\n-        });\n-        true\n-    }\n-    fn visit_int(&mut self) -> bool {\n-        self.get::<int>(|i| {\n-            let my_visitor(s) = *self;\n-            let mut this = s.borrow_mut();\n-            this.get().vals.push(i.to_str());\n-        });\n-        true\n-    }\n-    fn visit_i8(&mut self) -> bool { true }\n-    fn visit_i16(&mut self) -> bool { true }\n-    fn visit_i32(&mut self) -> bool { true }\n-    fn visit_i64(&mut self) -> bool { true }\n-\n-    fn visit_uint(&mut self) -> bool { true }\n-    fn visit_u8(&mut self) -> bool { true }\n-    fn visit_u16(&mut self) -> bool { true }\n-    fn visit_u32(&mut self) -> bool { true }\n-    fn visit_u64(&mut self) -> bool { true }\n-\n-    fn visit_f32(&mut self) -> bool { true }\n-    fn visit_f64(&mut self) -> bool { true }\n-\n-    fn visit_char(&mut self) -> bool { true }\n-\n-    fn visit_estr_box(&mut self) -> bool { true }\n-    fn visit_estr_uniq(&mut self) -> bool { true }\n-    fn visit_estr_slice(&mut self) -> bool { true }\n-    fn visit_estr_fixed(&mut self, _n: uint, _sz: uint,\n-                        _align: uint) -> bool { true }\n-\n-    fn visit_box(&mut self, _mtbl: uint, _inner: *TyDesc) -> bool { true }\n-    fn visit_uniq(&mut self, _mtbl: uint, _inner: *TyDesc) -> bool { true }\n-    fn visit_ptr(&mut self, _mtbl: uint, _inner: *TyDesc) -> bool { true }\n-    fn visit_rptr(&mut self, _mtbl: uint, _inner: *TyDesc) -> bool { true }\n-\n-    fn visit_vec(&mut self, _mtbl: uint, _inner: *TyDesc) -> bool { true }\n-    fn visit_unboxed_vec(&mut self, _mtbl: uint, _inner: *TyDesc) -> bool { true }\n-    fn visit_evec_box(&mut self, _mtbl: uint, _inner: *TyDesc) -> bool { true }\n-    fn visit_evec_uniq(&mut self, _mtbl: uint, _inner: *TyDesc) -> bool { true }\n-    fn visit_evec_slice(&mut self, _mtbl: uint, _inner: *TyDesc) -> bool { true }\n-    fn visit_evec_fixed(&mut self, _n: uint, _sz: uint, _align: uint,\n-                        _mtbl: uint, _inner: *TyDesc) -> bool { true }\n-\n-    fn visit_enter_rec(&mut self, _n_fields: uint,\n-                       _sz: uint, _align: uint) -> bool { true }\n-    fn visit_rec_field(&mut self, _i: uint, _name: &str,\n-                       _mtbl: uint, inner: *TyDesc) -> bool {\n-        error!(\"rec field!\");\n-        self.visit_inner(inner)\n-    }\n-    fn visit_leave_rec(&mut self, _n_fields: uint,\n-                       _sz: uint, _align: uint) -> bool { true }\n-\n-    fn visit_enter_class(&mut self, _name: &str, _named_fields: bool, _n_fields: uint,\n-                         _sz: uint, _align: uint) -> bool { true }\n-    fn visit_class_field(&mut self, _i: uint, _name: &str, _named: bool,\n-                         _mtbl: uint, inner: *TyDesc) -> bool {\n-        self.visit_inner(inner)\n-    }\n-    fn visit_leave_class(&mut self, _name: &str, _named_fields: bool, _n_fields: uint,\n-                         _sz: uint, _align: uint) -> bool { true }\n-\n-    fn visit_enter_tup(&mut self, _n_fields: uint,\n-                       _sz: uint, _align: uint) -> bool { true }\n-    fn visit_tup_field(&mut self, _i: uint, inner: *TyDesc) -> bool {\n-        error!(\"tup field!\");\n-        self.visit_inner(inner)\n-    }\n-    fn visit_leave_tup(&mut self, _n_fields: uint,\n-                       _sz: uint, _align: uint) -> bool { true }\n-\n-    fn visit_enter_enum(&mut self, _n_variants: uint,\n-                        _get_disr: extern unsafe fn(ptr: *Opaque) -> Disr,\n-                        _sz: uint, _align: uint) -> bool {\n-        // FIXME (#3732): this needs to rewind between enum variants, or something.\n-        true\n-    }\n-    fn visit_enter_enum_variant(&mut self, _variant: uint,\n-                                _disr_val: Disr,\n-                                _n_fields: uint,\n-                                _name: &str) -> bool { true }\n-    fn visit_enum_variant_field(&mut self, _i: uint, _offset: uint, inner: *TyDesc) -> bool {\n-        self.visit_inner(inner)\n-    }\n-    fn visit_leave_enum_variant(&mut self, _variant: uint,\n-                                _disr_val: Disr,\n-                                _n_fields: uint,\n-                                _name: &str) -> bool { true }\n-    fn visit_leave_enum(&mut self, _n_variants: uint,\n-                        _get_disr: extern unsafe fn(ptr: *Opaque) -> Disr,\n-                        _sz: uint, _align: uint) -> bool { true }\n-\n-    fn visit_enter_fn(&mut self, _purity: uint, _proto: uint,\n-                      _n_inputs: uint, _retstyle: uint) -> bool { true }\n-    fn visit_fn_input(&mut self, _i: uint, _mode: uint, _inner: *TyDesc) -> bool {\n-        true\n-    }\n-    fn visit_fn_output(&mut self, _retstyle: uint, _variadic: bool, _inner: *TyDesc) -> bool {\n-        true\n-    }\n-    fn visit_leave_fn(&mut self, _purity: uint, _proto: uint,\n-                      _n_inputs: uint, _retstyle: uint) -> bool { true }\n-\n-\n-    fn visit_trait(&mut self, _name: &str) -> bool { true }\n-    fn visit_param(&mut self, _i: uint) -> bool { true }\n-    fn visit_self(&mut self) -> bool { true }\n-    fn visit_type(&mut self) -> bool { true }\n-}\n-\n-fn get_tydesc_for<T>(_t: T) -> *TyDesc {\n-    unsafe {\n-        get_tydesc::<T>()\n-    }\n-}\n-\n-struct Triple { x: int, y: int, z: int }\n-\n-pub fn main() {\n-    unsafe {\n-        let r = (1,2,3,true,false, Triple {x:5,y:4,z:3}, (12,));\n-        let p = ptr::to_unsafe_ptr(&r) as *c_void;\n-        let u = my_visitor(@RefCell::new(Stuff {ptr1: p,\n-                                                ptr2: p,\n-                                                vals: ~[]}));\n-        let mut v = ptr_visit_adaptor(Inner {inner: u});\n-        let td = get_tydesc_for(r);\n-        error!(\"tydesc sz: {}, align: {}\",\n-               (*td).size, (*td).align);\n-        visit_tydesc(td, &mut v as &mut TyVisitor);\n-\n-        let my_visitor(m) = u;\n-        let mut ub = m.borrow_mut();\n-        let r = ub.get().vals.clone();\n-        for s in r.iter() {\n-            println!(\"val: {}\", *s);\n-        }\n-        error!(\"{:?}\", ub.get().vals.clone());\n-        assert_eq!(ub.get().vals.clone(),\n-                   ~[ ~\"1\", ~\"2\", ~\"3\", ~\"true\", ~\"false\", ~\"5\", ~\"4\", ~\"3\", ~\"12\"]);\n-    }\n-}"}]}