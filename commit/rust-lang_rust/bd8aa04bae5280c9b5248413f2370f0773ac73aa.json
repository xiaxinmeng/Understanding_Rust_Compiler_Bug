{"sha": "bd8aa04bae5280c9b5248413f2370f0773ac73aa", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJkOGFhMDRiYWU1MjgwYzliNTI0ODQxM2YyMzcwZjA3NzNhYzczYWE=", "commit": {"author": {"name": "Jess Balint", "email": "jbalint@gmail.com", "date": "2020-05-28T19:20:26Z"}, "committer": {"name": "Jess Balint", "email": "jbalint@gmail.com", "date": "2020-05-28T20:10:14Z"}, "message": "add support for naming anon lifetimes in function return type", "tree": {"sha": "fe27a66f83b07cc1aec6f47ca81ff5df1b160c8f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fe27a66f83b07cc1aec6f47ca81ff5df1b160c8f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bd8aa04bae5280c9b5248413f2370f0773ac73aa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bd8aa04bae5280c9b5248413f2370f0773ac73aa", "html_url": "https://github.com/rust-lang/rust/commit/bd8aa04bae5280c9b5248413f2370f0773ac73aa", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bd8aa04bae5280c9b5248413f2370f0773ac73aa/comments", "author": {"login": "jbalint", "id": 99260, "node_id": "MDQ6VXNlcjk5MjYw", "avatar_url": "https://avatars.githubusercontent.com/u/99260?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jbalint", "html_url": "https://github.com/jbalint", "followers_url": "https://api.github.com/users/jbalint/followers", "following_url": "https://api.github.com/users/jbalint/following{/other_user}", "gists_url": "https://api.github.com/users/jbalint/gists{/gist_id}", "starred_url": "https://api.github.com/users/jbalint/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jbalint/subscriptions", "organizations_url": "https://api.github.com/users/jbalint/orgs", "repos_url": "https://api.github.com/users/jbalint/repos", "events_url": "https://api.github.com/users/jbalint/events{/privacy}", "received_events_url": "https://api.github.com/users/jbalint/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jbalint", "id": 99260, "node_id": "MDQ6VXNlcjk5MjYw", "avatar_url": "https://avatars.githubusercontent.com/u/99260?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jbalint", "html_url": "https://github.com/jbalint", "followers_url": "https://api.github.com/users/jbalint/followers", "following_url": "https://api.github.com/users/jbalint/following{/other_user}", "gists_url": "https://api.github.com/users/jbalint/gists{/gist_id}", "starred_url": "https://api.github.com/users/jbalint/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jbalint/subscriptions", "organizations_url": "https://api.github.com/users/jbalint/orgs", "repos_url": "https://api.github.com/users/jbalint/repos", "events_url": "https://api.github.com/users/jbalint/events{/privacy}", "received_events_url": "https://api.github.com/users/jbalint/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4967b811dda4eae3910514ea8788f0fab256ad8c", "url": "https://api.github.com/repos/rust-lang/rust/commits/4967b811dda4eae3910514ea8788f0fab256ad8c", "html_url": "https://github.com/rust-lang/rust/commit/4967b811dda4eae3910514ea8788f0fab256ad8c"}], "stats": {"total": 260, "additions": 210, "deletions": 50}, "files": [{"sha": "999aec421b08e316f4166799e70f4ce14fa1e95e", "filename": "crates/ra_assists/src/handlers/change_lifetime_anon_to_named.rs", "status": "modified", "additions": 210, "deletions": 50, "changes": 260, "blob_url": "https://github.com/rust-lang/rust/blob/bd8aa04bae5280c9b5248413f2370f0773ac73aa/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fchange_lifetime_anon_to_named.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd8aa04bae5280c9b5248413f2370f0773ac73aa/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fchange_lifetime_anon_to_named.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fchange_lifetime_anon_to_named.rs?ref=bd8aa04bae5280c9b5248413f2370f0773ac73aa", "patch": "@@ -1,6 +1,10 @@\n-use crate::{AssistContext, AssistId, Assists};\n-use ra_syntax::{ast, ast::TypeParamsOwner, AstNode, SyntaxKind};\n-use std::collections::HashSet;\n+use crate::{assist_context::AssistBuilder, AssistContext, AssistId, Assists};\n+use ast::{NameOwner, ParamList, TypeAscriptionOwner, TypeParamList, TypeRef};\n+use ra_syntax::{ast, ast::TypeParamsOwner, AstNode, SyntaxKind, TextRange, TextSize};\n+use rustc_hash::FxHashSet;\n+\n+static ASSIST_NAME: &str = \"change_lifetime_anon_to_named\";\n+static ASSIST_LABEL: &str = \"Give anonymous lifetime a name\";\n \n // Assist: change_lifetime_anon_to_named\n //\n@@ -26,59 +30,117 @@ use std::collections::HashSet;\n // }\n // ```\n // FIXME: How can we handle renaming any one of multiple anonymous lifetimes?\n+// FIXME: should also add support for the case fun(f: &Foo) -> &<|>Foo\n pub(crate) fn change_lifetime_anon_to_named(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n-    let lifetime_token = ctx.find_token_at_offset(SyntaxKind::LIFETIME)?;\n-    let lifetime_arg = ast::LifetimeArg::cast(lifetime_token.parent())?;\n-    if lifetime_arg.syntax().text() != \"'_\" {\n-        return None;\n-    }\n-    let next_token = lifetime_token.next_token()?;\n-    if next_token.kind() != SyntaxKind::R_ANGLE {\n+    let lifetime_token = ctx\n+        .find_token_at_offset(SyntaxKind::LIFETIME)\n+        .filter(|lifetime| lifetime.text() == \"'_\")?;\n+    if let Some(fn_def) = lifetime_token.ancestors().find_map(ast::FnDef::cast) {\n+        generate_fn_def_assist(acc, &fn_def, lifetime_token.text_range())\n+    } else if let Some(impl_def) = lifetime_token.ancestors().find_map(ast::ImplDef::cast) {\n         // only allow naming the last anonymous lifetime\n-        return None;\n-    }\n-    let impl_def = lifetime_arg.syntax().ancestors().find_map(ast::ImplDef::cast)?;\n-    // get the `impl` keyword so we know where to add the lifetime argument\n-    let impl_kw = impl_def.syntax().first_child_or_token()?.into_token()?;\n-    if impl_kw.kind() != SyntaxKind::IMPL_KW {\n-        return None;\n+        lifetime_token.next_token().filter(|tok| tok.kind() == SyntaxKind::R_ANGLE)?;\n+        generate_impl_def_assist(acc, &impl_def, lifetime_token.text_range())\n+    } else {\n+        None\n     }\n-    let new_lifetime_param = match impl_def.type_param_list() {\n+}\n+\n+/// Generate the assist for the fn def case\n+fn generate_fn_def_assist(\n+    acc: &mut Assists,\n+    fn_def: &ast::FnDef,\n+    lifetime_loc: TextRange,\n+) -> Option<()> {\n+    let param_list: ParamList = fn_def.param_list()?;\n+    let new_lifetime_param = generate_unique_lifetime_param_name(&fn_def.type_param_list())?;\n+    let end_of_fn_ident = fn_def.name()?.ident_token()?.text_range().end();\n+    let self_param =\n+        // use the self if it's a reference and has no explicit lifetime\n+        param_list.self_param().filter(|p| p.lifetime_token().is_none() && p.amp_token().is_some());\n+    // compute the location which implicitly has the same lifetime as the anonymous lifetime\n+    let loc_needing_lifetime = if let Some(self_param) = self_param {\n+        // if we have a self reference, use that\n+        Some(self_param.self_token()?.text_range().start())\n+    } else {\n+        // otherwise, if there's a single reference parameter without a named liftime, use that\n+        let fn_params_without_lifetime: Vec<_> = param_list\n+            .params()\n+            .filter_map(|param| match param.ascribed_type() {\n+                Some(TypeRef::ReferenceType(ascribed_type))\n+                    if ascribed_type.lifetime_token() == None =>\n+                {\n+                    Some(ascribed_type.amp_token()?.text_range().end())\n+                }\n+                _ => None,\n+            })\n+            .collect();\n+        match fn_params_without_lifetime.len() {\n+            1 => Some(fn_params_without_lifetime.into_iter().nth(0)?),\n+            0 => None,\n+            // multiple unnnamed is invalid. assist is not applicable\n+            _ => return None,\n+        }\n+    };\n+    acc.add(AssistId(ASSIST_NAME), ASSIST_LABEL, lifetime_loc, |builder| {\n+        add_lifetime_param(fn_def, builder, end_of_fn_ident, new_lifetime_param);\n+        builder.replace(lifetime_loc, format!(\"'{}\", new_lifetime_param));\n+        loc_needing_lifetime.map(|loc| builder.insert(loc, format!(\"'{} \", new_lifetime_param)));\n+    })\n+}\n+\n+/// Generate the assist for the impl def case\n+fn generate_impl_def_assist(\n+    acc: &mut Assists,\n+    impl_def: &ast::ImplDef,\n+    lifetime_loc: TextRange,\n+) -> Option<()> {\n+    let new_lifetime_param = generate_unique_lifetime_param_name(&impl_def.type_param_list())?;\n+    let end_of_impl_kw = impl_def.impl_token()?.text_range().end();\n+    acc.add(AssistId(ASSIST_NAME), ASSIST_LABEL, lifetime_loc, |builder| {\n+        add_lifetime_param(impl_def, builder, end_of_impl_kw, new_lifetime_param);\n+        builder.replace(lifetime_loc, format!(\"'{}\", new_lifetime_param));\n+    })\n+}\n+\n+/// Given a type parameter list, generate a unique lifetime parameter name\n+/// which is not in the list\n+fn generate_unique_lifetime_param_name(\n+    existing_type_param_list: &Option<TypeParamList>,\n+) -> Option<char> {\n+    match existing_type_param_list {\n         Some(type_params) => {\n-            let used_lifetime_params: HashSet<_> = type_params\n+            let used_lifetime_params: FxHashSet<_> = type_params\n                 .lifetime_params()\n-                .map(|p| {\n-                    let mut param_name = p.syntax().text().to_string();\n-                    param_name.remove(0);\n-                    param_name\n-                })\n+                .map(|p| p.syntax().text().to_string()[1..].to_owned())\n                 .collect();\n-            (b'a'..=b'z')\n-                .map(char::from)\n-                .find(|c| !used_lifetime_params.contains(&c.to_string()))?\n+            (b'a'..=b'z').map(char::from).find(|c| !used_lifetime_params.contains(&c.to_string()))\n         }\n-        None => 'a',\n-    };\n-    acc.add(\n-        AssistId(\"change_lifetime_anon_to_named\"),\n-        \"Give anonymous lifetime a name\",\n-        lifetime_arg.syntax().text_range(),\n-        |builder| {\n-            match impl_def.type_param_list() {\n-                Some(type_params) => {\n-                    builder.insert(\n-                        (u32::from(type_params.syntax().text_range().end()) - 1).into(),\n-                        format!(\", '{}\", new_lifetime_param),\n-                    );\n-                }\n-                None => {\n-                    builder\n-                        .insert(impl_kw.text_range().end(), format!(\"<'{}>\", new_lifetime_param));\n-                }\n-            }\n-            builder.replace(lifetime_arg.syntax().text_range(), format!(\"'{}\", new_lifetime_param));\n-        },\n-    )\n+        None => Some('a'),\n+    }\n+}\n+\n+/// Add the lifetime param to `builder`. If there are type parameters in `type_params_owner`, add it to the end. Otherwise\n+/// add new type params brackets with the lifetime parameter at `new_type_params_loc`.\n+fn add_lifetime_param<TypeParamsOwner: ast::TypeParamsOwner>(\n+    type_params_owner: &TypeParamsOwner,\n+    builder: &mut AssistBuilder,\n+    new_type_params_loc: TextSize,\n+    new_lifetime_param: char,\n+) {\n+    match type_params_owner.type_param_list() {\n+        // add the new lifetime parameter to an existing type param list\n+        Some(type_params) => {\n+            builder.insert(\n+                (u32::from(type_params.syntax().text_range().end()) - 1).into(),\n+                format!(\", '{}\", new_lifetime_param),\n+            );\n+        }\n+        // create a new type param list containing only the new lifetime parameter\n+        None => {\n+            builder.insert(new_type_params_loc, format!(\"<'{}>\", new_lifetime_param));\n+        }\n+    }\n }\n \n #[cfg(test)]\n@@ -117,10 +179,36 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_not_applicable() {\n+    fn test_example_case_cursor_after_tick() {\n+        check_assist(\n+            change_lifetime_anon_to_named,\n+            r#\"impl Cursor<'<|>_> {\"#,\n+            r#\"impl<'a> Cursor<'a> {\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_example_case_cursor_before_tick() {\n+        check_assist(\n+            change_lifetime_anon_to_named,\n+            r#\"impl Cursor<<|>'_> {\"#,\n+            r#\"impl<'a> Cursor<'a> {\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_not_applicable_cursor_position() {\n         check_assist_not_applicable(change_lifetime_anon_to_named, r#\"impl Cursor<'_><|> {\"#);\n         check_assist_not_applicable(change_lifetime_anon_to_named, r#\"impl Cursor<|><'_> {\"#);\n+    }\n+\n+    #[test]\n+    fn test_not_applicable_lifetime_already_name() {\n         check_assist_not_applicable(change_lifetime_anon_to_named, r#\"impl Cursor<'a<|>> {\"#);\n+        check_assist_not_applicable(\n+            change_lifetime_anon_to_named,\n+            r#\"fn my_fun<'a>() -> X<'a<|>>\"#,\n+        );\n     }\n \n     #[test]\n@@ -140,4 +228,76 @@ mod tests {\n             r#\"impl<'a, 'b, 'c> Cursor<'a, 'b, 'c>\"#,\n         );\n     }\n+\n+    #[test]\n+    fn test_function_return_value_anon_lifetime_param() {\n+        check_assist(\n+            change_lifetime_anon_to_named,\n+            r#\"fn my_fun() -> X<'_<|>>\"#,\n+            r#\"fn my_fun<'a>() -> X<'a>\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_function_return_value_anon_reference_lifetime() {\n+        check_assist(\n+            change_lifetime_anon_to_named,\n+            r#\"fn my_fun() -> &'_<|> X\"#,\n+            r#\"fn my_fun<'a>() -> &'a X\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_function_param_anon_lifetime() {\n+        check_assist(\n+            change_lifetime_anon_to_named,\n+            r#\"fn my_fun(x: X<'_<|>>)\"#,\n+            r#\"fn my_fun<'a>(x: X<'a>)\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_function_add_lifetime_to_params() {\n+        check_assist(\n+            change_lifetime_anon_to_named,\n+            r#\"fn my_fun(f: &Foo) -> X<'_<|>>\"#,\n+            r#\"fn my_fun<'a>(f: &'a Foo) -> X<'a>\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_function_add_lifetime_to_params_in_presence_of_other_lifetime() {\n+        check_assist(\n+            change_lifetime_anon_to_named,\n+            r#\"fn my_fun<'other>(f: &Foo, b: &'other Bar) -> X<'_<|>>\"#,\n+            r#\"fn my_fun<'other, 'a>(f: &'a Foo, b: &'other Bar) -> X<'a>\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_function_not_applicable_without_self_and_multiple_unnamed_param_lifetimes() {\n+        // this is not permitted under lifetime elision rules\n+        check_assist_not_applicable(\n+            change_lifetime_anon_to_named,\n+            r#\"fn my_fun(f: &Foo, b: &Bar) -> X<'_<|>>\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_function_add_lifetime_to_self_ref_param() {\n+        check_assist(\n+            change_lifetime_anon_to_named,\n+            r#\"fn my_fun<'other>(&self, f: &Foo, b: &'other Bar) -> X<'_<|>>\"#,\n+            r#\"fn my_fun<'other, 'a>(&'a self, f: &Foo, b: &'other Bar) -> X<'a>\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_function_add_lifetime_to_param_with_non_ref_self() {\n+        check_assist(\n+            change_lifetime_anon_to_named,\n+            r#\"fn my_fun<'other>(self, f: &Foo, b: &'other Bar) -> X<'_<|>>\"#,\n+            r#\"fn my_fun<'other, 'a>(self, f: &'a Foo, b: &'other Bar) -> X<'a>\"#,\n+        );\n+    }\n }"}]}