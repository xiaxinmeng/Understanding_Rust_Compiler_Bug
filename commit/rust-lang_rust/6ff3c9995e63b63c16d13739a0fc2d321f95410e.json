{"sha": "6ff3c9995e63b63c16d13739a0fc2d321f95410e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZmZjNjOTk5NWU2M2I2M2MxNmQxMzczOWEwZmMyZDMyMWY5NTQxMGU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-03-13T19:16:34Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-03-13T19:16:34Z"}, "message": "auto merge of #12573 : lbonn/rust/unrecurs, r=alexcrichton\n\nAs mentioned in #6109, ```mkdir_recursive``` doesn't really need to use recursive calls, so here is an iterative version.\r\nThe other points of the proposed overhaul (renaming and existing permissions) still need to be resolved.\r\n\r\nI also bundled an iterative ```rmdir_recursive```, for the same reason.\r\n\r\nPlease do not hesitate to provide feedback on style as this is my first code change in rust.", "tree": {"sha": "df37eefbe8c9657f6678dce8dc6839a206912e7f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/df37eefbe8c9657f6678dce8dc6839a206912e7f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6ff3c9995e63b63c16d13739a0fc2d321f95410e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6ff3c9995e63b63c16d13739a0fc2d321f95410e", "html_url": "https://github.com/rust-lang/rust/commit/6ff3c9995e63b63c16d13739a0fc2d321f95410e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6ff3c9995e63b63c16d13739a0fc2d321f95410e/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "47a8c76a43feac53be71f1ba009a66fd3626eb2e", "url": "https://api.github.com/repos/rust-lang/rust/commits/47a8c76a43feac53be71f1ba009a66fd3626eb2e", "html_url": "https://github.com/rust-lang/rust/commit/47a8c76a43feac53be71f1ba009a66fd3626eb2e"}, {"sha": "164b7c22b69ed69854c0e579e051f851181673b0", "url": "https://api.github.com/repos/rust-lang/rust/commits/164b7c22b69ed69854c0e579e051f851181673b0", "html_url": "https://github.com/rust-lang/rust/commit/164b7c22b69ed69854c0e579e051f851181673b0"}], "stats": {"total": 96, "additions": 85, "deletions": 11}, "files": [{"sha": "3435c9a07aa19cac8a432ef8977f767d1f64d902", "filename": "src/libstd/io/fs.rs", "status": "modified", "additions": 85, "deletions": 11, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/6ff3c9995e63b63c16d13739a0fc2d321f95410e/src%2Flibstd%2Fio%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ff3c9995e63b63c16d13739a0fc2d321f95410e/src%2Flibstd%2Fio%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ffs.rs?ref=6ff3c9995e63b63c16d13739a0fc2d321f95410e", "patch": "@@ -51,6 +51,7 @@ fs::unlink(&path);\n \n use c_str::ToCStr;\n use clone::Clone;\n+use container::Container;\n use iter::Iterator;\n use super::{Reader, Writer, Seek};\n use super::{SeekStyle, Read, Write, Open, IoError, Truncate,\n@@ -62,6 +63,7 @@ use result::{Ok, Err};\n use path;\n use path::{Path, GenericPath};\n use vec::{OwnedVector, ImmutableVector};\n+use vec_ng::Vec;\n \n /// Unconstrained file access type that exposes read and write operations\n ///\n@@ -528,10 +530,25 @@ pub fn mkdir_recursive(path: &Path, mode: FilePermission) -> IoResult<()> {\n     if path.is_dir() {\n         return Ok(())\n     }\n-    if path.filename().is_some() {\n-        try!(mkdir_recursive(&path.dir_path(), mode));\n+\n+    let mut comps = path.components();\n+    let mut curpath = path.root_path().unwrap_or(Path::new(\".\"));\n+\n+    for c in comps {\n+        curpath.push(c);\n+\n+        match mkdir(&curpath, mode) {\n+            Err(mkdir_err) => {\n+                // already exists ?\n+                if try!(stat(&curpath)).kind != io::TypeDirectory {\n+                    return Err(mkdir_err);\n+                }\n+            }\n+            Ok(()) => ()\n+        }\n     }\n-    mkdir(path, mode)\n+\n+    Ok(())\n }\n \n /// Removes a directory at this path, after removing all its contents. Use\n@@ -542,16 +559,47 @@ pub fn mkdir_recursive(path: &Path, mode: FilePermission) -> IoResult<()> {\n /// This function will return an `Err` value if an error happens. See\n /// `file::unlink` and `fs::readdir` for possible error conditions.\n pub fn rmdir_recursive(path: &Path) -> IoResult<()> {\n-    let children = try!(readdir(path));\n-    for child in children.iter() {\n-        if child.is_dir() {\n-            try!(rmdir_recursive(child));\n-        } else {\n-            try!(unlink(child));\n+    let mut rm_stack = Vec::new();\n+    rm_stack.push(path.clone());\n+\n+    while !rm_stack.is_empty() {\n+        let children = try!(readdir(rm_stack.last().unwrap()));\n+        let mut has_child_dir = false;\n+\n+        // delete all regular files in the way and push subdirs\n+        // on the stack\n+        for child in children.move_iter() {\n+            // FIXME(#12795) we should use lstat in all cases\n+            let child_type = match cfg!(windows) {\n+                true => try!(stat(&child)).kind,\n+                false => try!(lstat(&child)).kind\n+            };\n+\n+            if child_type == io::TypeDirectory {\n+                rm_stack.push(child);\n+                has_child_dir = true;\n+            } else {\n+                // we can carry on safely if the file is already gone\n+                // (eg: deleted by someone else since readdir)\n+                match unlink(&child) {\n+                    Ok(()) => (),\n+                    Err(ref e) if e.kind == io::FileNotFound => (),\n+                    Err(e) => return Err(e)\n+                }\n+            }\n+        }\n+\n+        // if no subdir was found, let's pop and delete\n+        if !has_child_dir {\n+            match rmdir(&rm_stack.pop().unwrap()) {\n+                Ok(()) => (),\n+                Err(ref e) if e.kind == io::FileNotFound => (),\n+                Err(e) => return Err(e)\n+            }\n         }\n     }\n-    // Directory should now be empty\n-    rmdir(path)\n+\n+    Ok(())\n }\n \n /// Changes the timestamps for a file's last modification and access time.\n@@ -920,10 +968,36 @@ mod test {\n         check!(rmdir(dir));\n     })\n \n+    iotest!(fn recursive_mkdir() {\n+        let tmpdir = tmpdir();\n+        let dir = tmpdir.join(\"d1/d2\");\n+        check!(mkdir_recursive(&dir, io::UserRWX));\n+        assert!(dir.is_dir())\n+    })\n+\n     iotest!(fn recursive_mkdir_slash() {\n         check!(mkdir_recursive(&Path::new(\"/\"), io::UserRWX));\n     })\n \n+    // FIXME(#12795) depends on lstat to work on windows\n+    #[cfg(not(windows))]\n+    iotest!(fn recursive_rmdir() {\n+        let tmpdir = tmpdir();\n+        let d1 = tmpdir.join(\"d1\");\n+        let dt = d1.join(\"t\");\n+        let dtt = dt.join(\"t\");\n+        let d2 = tmpdir.join(\"d2\");\n+        let canary = d2.join(\"do_not_delete\");\n+        check!(mkdir_recursive(&dtt, io::UserRWX));\n+        check!(mkdir_recursive(&d2, io::UserRWX));\n+        check!(File::create(&canary).write(bytes!(\"foo\")));\n+        check!(symlink(&d2, &dt.join(\"d2\")));\n+        check!(rmdir_recursive(&d1));\n+\n+        assert!(!d1.is_dir());\n+        assert!(canary.exists());\n+    })\n+\n     iotest!(fn unicode_path_is_dir() {\n         assert!(Path::new(\".\").is_dir());\n         assert!(!Path::new(\"test/stdtest/fs.rs\").is_dir());"}]}