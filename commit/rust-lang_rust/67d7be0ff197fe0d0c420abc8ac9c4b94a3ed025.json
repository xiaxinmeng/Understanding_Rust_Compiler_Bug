{"sha": "67d7be0ff197fe0d0c420abc8ac9c4b94a3ed025", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY3ZDdiZTBmZjE5N2ZlMGQwYzQyMGFiYzhhYzljNGI5NGEzZWQwMjU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-10-29T19:02:59Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-10-29T19:02:59Z"}, "message": "auto merge of #10136 : hatahet/rust/master, r=alexcrichton\n\nFixes #10077", "tree": {"sha": "f8c59941cc683a8b4ad40959a769ba470790f54b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f8c59941cc683a8b4ad40959a769ba470790f54b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/67d7be0ff197fe0d0c420abc8ac9c4b94a3ed025", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/67d7be0ff197fe0d0c420abc8ac9c4b94a3ed025", "html_url": "https://github.com/rust-lang/rust/commit/67d7be0ff197fe0d0c420abc8ac9c4b94a3ed025", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/67d7be0ff197fe0d0c420abc8ac9c4b94a3ed025/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fed48cc861fd858762c1e9b498675bfa4dee2d38", "url": "https://api.github.com/repos/rust-lang/rust/commits/fed48cc861fd858762c1e9b498675bfa4dee2d38", "html_url": "https://github.com/rust-lang/rust/commit/fed48cc861fd858762c1e9b498675bfa4dee2d38"}, {"sha": "3797f2bfe63ca618702607b0dd3f714f8fab99f3", "url": "https://api.github.com/repos/rust-lang/rust/commits/3797f2bfe63ca618702607b0dd3f714f8fab99f3", "html_url": "https://github.com/rust-lang/rust/commit/3797f2bfe63ca618702607b0dd3f714f8fab99f3"}], "stats": {"total": 344, "additions": 169, "deletions": 175}, "files": [{"sha": "3eab4ceffec1983c3c288460b0eed73cf87d81b8", "filename": "doc/tutorial.md", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/67d7be0ff197fe0d0c420abc8ac9c4b94a3ed025/doc%2Ftutorial.md", "raw_url": "https://github.com/rust-lang/rust/raw/67d7be0ff197fe0d0c420abc8ac9c4b94a3ed025/doc%2Ftutorial.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial.md?ref=67d7be0ff197fe0d0c420abc8ac9c4b94a3ed025", "patch": "@@ -491,7 +491,7 @@ types.\n use std::f64;\n use std::num::atan;\n fn angle(vector: (f64, f64)) -> f64 {\n-    let pi = f64::consts::pi;\n+    let pi = f64::consts::PI;\n     match vector {\n       (0.0, y) if y < 0.0 => 1.5 * pi,\n       (0.0, y) => 0.5 * pi,\n@@ -689,7 +689,7 @@ use std::f64;\n # enum Shape { Circle(Point, f64), Rectangle(Point, Point) }\n fn area(sh: Shape) -> f64 {\n     match sh {\n-        Circle(_, size) => f64::consts::pi * size * size,\n+        Circle(_, size) => f64::consts::PI * size * size,\n         Rectangle(Point { x, y }, Point { x: x2, y: y2 }) => (x2 - x) * (y2 - y)\n     }\n }\n@@ -725,7 +725,7 @@ enum Shape {\n }\n fn area(sh: Shape) -> f64 {\n     match sh {\n-        Circle { radius: radius, _ } => f64::consts::pi * square(radius),\n+        Circle { radius: radius, _ } => f64::consts::PI * square(radius),\n         Rectangle { top_left: top_left, bottom_right: bottom_right } => {\n             (bottom_right.x - top_left.x) * (top_left.y - bottom_right.y)\n         }\n@@ -1699,10 +1699,10 @@ impl Circle {\n To call such a method, just prefix it with the type name and a double colon:\n \n ~~~~\n-use std::f64::consts::pi;\n+use std::f64::consts::PI;\n struct Circle { radius: f64 }\n impl Circle {\n-    fn new(area: f64) -> Circle { Circle { radius: (area / pi).sqrt() } }\n+    fn new(area: f64) -> Circle { Circle { radius: (area / PI).sqrt() } }\n }\n let c = Circle::new(42.5);\n ~~~~\n@@ -1977,13 +1977,13 @@ name and a double colon.  The compiler uses type inference to decide which\n implementation to use.\n \n ~~~~\n-use std::f64::consts::pi;\n+use std::f64::consts::PI;\n trait Shape { fn new(area: f64) -> Self; }\n struct Circle { radius: f64 }\n struct Square { length: f64 }\n \n impl Shape for Circle {\n-    fn new(area: f64) -> Circle { Circle { radius: (area / pi).sqrt() } }\n+    fn new(area: f64) -> Circle { Circle { radius: (area / PI).sqrt() } }\n }\n impl Shape for Square {\n     fn new(area: f64) -> Square { Square { length: (area).sqrt() } }\n@@ -2157,17 +2157,17 @@ trait Circle : Shape { fn radius(&self) -> f64; }\n Now, we can implement `Circle` on a type only if we also implement `Shape`.\n \n ~~~~\n-use std::f64::consts::pi;\n+use std::f64::consts::PI;\n # trait Shape { fn area(&self) -> f64; }\n # trait Circle : Shape { fn radius(&self) -> f64; }\n # struct Point { x: f64, y: f64 }\n # fn square(x: f64) -> f64 { x * x }\n struct CircleStruct { center: Point, radius: f64 }\n impl Circle for CircleStruct {\n-    fn radius(&self) -> f64 { (self.area() / pi).sqrt() }\n+    fn radius(&self) -> f64 { (self.area() / PI).sqrt() }\n }\n impl Shape for CircleStruct {\n-    fn area(&self) -> f64 { pi * square(self.radius) }\n+    fn area(&self) -> f64 { PI * square(self.radius) }\n }\n ~~~~\n \n@@ -2192,13 +2192,13 @@ fn radius_times_area<T: Circle>(c: T) -> f64 {\n Likewise, supertrait methods may also be called on trait objects.\n \n ~~~ {.xfail-test}\n-use std::f64::consts::pi;\n+use std::f64::consts::PI;\n # trait Shape { fn area(&self) -> f64; }\n # trait Circle : Shape { fn radius(&self) -> f64; }\n # struct Point { x: f64, y: f64 }\n # struct CircleStruct { center: Point, radius: f64 }\n-# impl Circle for CircleStruct { fn radius(&self) -> f64 { (self.area() / pi).sqrt() } }\n-# impl Shape for CircleStruct { fn area(&self) -> f64 { pi * square(self.radius) } }\n+# impl Circle for CircleStruct { fn radius(&self) -> f64 { (self.area() / PI).sqrt() } }\n+# impl Shape for CircleStruct { fn area(&self) -> f64 { PI * square(self.radius) } }\n \n let concrete = @CircleStruct{center:Point{x:3f,y:4f},radius:5f};\n let mycircle: @Circle = concrete as @Circle;"}, {"sha": "d6de4f25f6eefe7af2be00775bdb464cfb8ceb1b", "filename": "src/libstd/num/f32.rs", "status": "modified", "additions": 65, "deletions": 67, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/67d7be0ff197fe0d0c420abc8ac9c4b94a3ed025/src%2Flibstd%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67d7be0ff197fe0d0c420abc8ac9c4b94a3ed025/src%2Flibstd%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff32.rs?ref=67d7be0ff197fe0d0c420abc8ac9c4b94a3ed025", "patch": "@@ -10,8 +10,6 @@\n \n //! Operations and constants for `f32`\n #[allow(missing_doc)];\n-#[allow(non_uppercase_statics)];\n-#[allow(non_uppercase_pattern_statics)];\n \n use default::Default;\n use libc::c_int;\n@@ -112,11 +110,11 @@ delegate!(\n // These are not defined inside consts:: for consistency with\n // the integer types\n \n-pub static NaN: f32 = 0.0_f32/0.0_f32;\n+pub static NAN: f32 = 0.0_f32/0.0_f32;\n \n-pub static infinity: f32 = 1.0_f32/0.0_f32;\n+pub static INFINITY: f32 = 1.0_f32/0.0_f32;\n \n-pub static neg_infinity: f32 = -1.0_f32/0.0_f32;\n+pub static NEG_INFINITY: f32 = -1.0_f32/0.0_f32;\n \n // FIXME (#1999): replace the predicates below with llvm intrinsics or\n // calls to the libmath macros in the rust runtime for performance.\n@@ -128,43 +126,43 @@ pub mod consts {\n     // FIXME (requires Issue #1433 to fix): replace with mathematical\n     // staticants from cmath.\n     /// Archimedes' constant\n-    pub static pi: f32 = 3.14159265358979323846264338327950288_f32;\n+    pub static PI: f32 = 3.14159265358979323846264338327950288_f32;\n \n     /// pi/2.0\n-    pub static frac_pi_2: f32 = 1.57079632679489661923132169163975144_f32;\n+    pub static FRAC_PI_2: f32 = 1.57079632679489661923132169163975144_f32;\n \n     /// pi/4.0\n-    pub static frac_pi_4: f32 = 0.785398163397448309615660845819875721_f32;\n+    pub static FRAC_PI_4: f32 = 0.785398163397448309615660845819875721_f32;\n \n     /// 1.0/pi\n-    pub static frac_1_pi: f32 = 0.318309886183790671537767526745028724_f32;\n+    pub static FRAC_1_PI: f32 = 0.318309886183790671537767526745028724_f32;\n \n     /// 2.0/pi\n-    pub static frac_2_pi: f32 = 0.636619772367581343075535053490057448_f32;\n+    pub static FRAC_2_PI: f32 = 0.636619772367581343075535053490057448_f32;\n \n     /// 2.0/sqrt(pi)\n-    pub static frac_2_sqrtpi: f32 = 1.12837916709551257389615890312154517_f32;\n+    pub static FRAC_2_SQRTPI: f32 = 1.12837916709551257389615890312154517_f32;\n \n     /// sqrt(2.0)\n-    pub static sqrt2: f32 = 1.41421356237309504880168872420969808_f32;\n+    pub static SQRT2: f32 = 1.41421356237309504880168872420969808_f32;\n \n     /// 1.0/sqrt(2.0)\n-    pub static frac_1_sqrt2: f32 = 0.707106781186547524400844362104849039_f32;\n+    pub static FRAC_1_SQRT2: f32 = 0.707106781186547524400844362104849039_f32;\n \n     /// Euler's number\n-    pub static e: f32 = 2.71828182845904523536028747135266250_f32;\n+    pub static E: f32 = 2.71828182845904523536028747135266250_f32;\n \n     /// log2(e)\n-    pub static log2_e: f32 = 1.44269504088896340735992468100189214_f32;\n+    pub static LOG2_E: f32 = 1.44269504088896340735992468100189214_f32;\n \n     /// log10(e)\n-    pub static log10_e: f32 = 0.434294481903251827651128918916605082_f32;\n+    pub static LOG10_E: f32 = 0.434294481903251827651128918916605082_f32;\n \n     /// ln(2.0)\n-    pub static ln_2: f32 = 0.693147180559945309417232121458176568_f32;\n+    pub static LN_2: f32 = 0.693147180559945309417232121458176568_f32;\n \n     /// ln(10.0)\n-    pub static ln_10: f32 = 2.30258509299404568401799145468436421_f32;\n+    pub static LN_10: f32 = 2.30258509299404568401799145468436421_f32;\n }\n \n impl Num for f32 {}\n@@ -204,7 +202,7 @@ impl Ord for f32 {\n }\n \n impl Orderable for f32 {\n-    /// Returns `NaN` if either of the numbers are `NaN`.\n+    /// Returns `NAN` if either of the numbers are `NAN`.\n     #[inline]\n     fn min(&self, other: &f32) -> f32 {\n         match () {\n@@ -215,7 +213,7 @@ impl Orderable for f32 {\n         }\n     }\n \n-    /// Returns `NaN` if either of the numbers are `NaN`.\n+    /// Returns `NAN` if either of the numbers are `NAN`.\n     #[inline]\n     fn max(&self, other: &f32) -> f32 {\n         match () {\n@@ -227,7 +225,7 @@ impl Orderable for f32 {\n     }\n \n     /// Returns the number constrained within the range `mn <= self <= mx`.\n-    /// If any of the numbers are `NaN` then `NaN` is returned.\n+    /// If any of the numbers are `NAN` then `NAN` is returned.\n     #[inline]\n     fn clamp(&self, mn: &f32, mx: &f32) -> f32 {\n         match () {\n@@ -295,7 +293,7 @@ impl Neg<f32> for f32 {\n }\n \n impl Signed for f32 {\n-    /// Computes the absolute value. Returns `NaN` if the number is `NaN`.\n+    /// Computes the absolute value. Returns `NAN` if the number is `NAN`.\n     #[inline]\n     fn abs(&self) -> f32 { abs(*self) }\n \n@@ -309,30 +307,30 @@ impl Signed for f32 {\n     ///\n     /// # Returns\n     ///\n-    /// - `1.0` if the number is positive, `+0.0` or `infinity`\n-    /// - `-1.0` if the number is negative, `-0.0` or `neg_infinity`\n-    /// - `NaN` if the number is NaN\n+    /// - `1.0` if the number is positive, `+0.0` or `INFINITY`\n+    /// - `-1.0` if the number is negative, `-0.0` or `NEG_INFINITY`\n+    /// - `NAN` if the number is NaN\n     ///\n     #[inline]\n     fn signum(&self) -> f32 {\n-        if self.is_nan() { NaN } else { copysign(1.0, *self) }\n+        if self.is_nan() { NAN } else { copysign(1.0, *self) }\n     }\n \n-    /// Returns `true` if the number is positive, including `+0.0` and `infinity`\n+    /// Returns `true` if the number is positive, including `+0.0` and `INFINITY`\n     #[inline]\n-    fn is_positive(&self) -> bool { *self > 0.0 || (1.0 / *self) == infinity }\n+    fn is_positive(&self) -> bool { *self > 0.0 || (1.0 / *self) == INFINITY }\n \n-    /// Returns `true` if the number is negative, including `-0.0` and `neg_infinity`\n+    /// Returns `true` if the number is negative, including `-0.0` and `NEG_INFINITY`\n     #[inline]\n-    fn is_negative(&self) -> bool { *self < 0.0 || (1.0 / *self) == neg_infinity }\n+    fn is_negative(&self) -> bool { *self < 0.0 || (1.0 / *self) == NEG_INFINITY }\n }\n \n impl Round for f32 {\n-    /// Round half-way cases toward `neg_infinity`\n+    /// Round half-way cases toward `NEG_INFINITY`\n     #[inline]\n     fn floor(&self) -> f32 { floor(*self) }\n \n-    /// Round half-way cases toward `infinity`\n+    /// Round half-way cases toward `INFINITY`\n     #[inline]\n     fn ceil(&self) -> f32 { ceil(*self) }\n \n@@ -449,13 +447,13 @@ impl Hyperbolic for f32 {\n     /// # Returns\n     ///\n     /// - on success, the inverse hyperbolic sine of `self` will be returned\n-    /// - `self` if `self` is `0.0`, `-0.0`, `infinity`, or `neg_infinity`\n-    /// - `NaN` if `self` is `NaN`\n+    /// - `self` if `self` is `0.0`, `-0.0`, `INFINITY`, or `NEG_INFINITY`\n+    /// - `NAN` if `self` is `NAN`\n     ///\n     #[inline]\n     fn asinh(&self) -> f32 {\n         match *self {\n-            neg_infinity => neg_infinity,\n+            NEG_INFINITY => NEG_INFINITY,\n             x => (x + ((x * x) + 1.0).sqrt()).ln(),\n         }\n     }\n@@ -466,8 +464,8 @@ impl Hyperbolic for f32 {\n     /// # Returns\n     ///\n     /// - on success, the inverse hyperbolic cosine of `self` will be returned\n-    /// - `infinity` if `self` is `infinity`\n-    /// - `NaN` if `self` is `NaN` or `self < 1.0` (including `neg_infinity`)\n+    /// - `INFINITY` if `self` is `INFINITY`\n+    /// - `NAN` if `self` is `NAN` or `self < 1.0` (including `NEG_INFINITY`)\n     ///\n     #[inline]\n     fn acosh(&self) -> f32 {\n@@ -484,10 +482,10 @@ impl Hyperbolic for f32 {\n     ///\n     /// - on success, the inverse hyperbolic tangent of `self` will be returned\n     /// - `self` if `self` is `0.0` or `-0.0`\n-    /// - `infinity` if `self` is `1.0`\n-    /// - `neg_infinity` if `self` is `-1.0`\n-    /// - `NaN` if the `self` is `NaN` or outside the domain of `-1.0 <= self <= 1.0`\n-    ///   (including `infinity` and `neg_infinity`)\n+    /// - `INFINITY` if `self` is `1.0`\n+    /// - `NEG_INFINITY` if `self` is `-1.0`\n+    /// - `NAN` if the `self` is `NAN` or outside the domain of `-1.0 <= self <= 1.0`\n+    ///   (including `INFINITY` and `NEG_INFINITY`)\n     ///\n     #[inline]\n     fn atanh(&self) -> f32 {\n@@ -821,7 +819,7 @@ impl num::ToStrRadix for f32 {\n         let (r, special) = strconv::float_to_str_common(\n             *self, rdx, true, strconv::SignNeg, strconv::DigAll);\n         if special { fail!(\"number has a special value, \\\n-                             try to_str_radix_special() if those are expected\") }\n+                            try to_str_radix_special() if those are expected\") }\n         r\n     }\n }\n@@ -850,7 +848,7 @@ impl num::ToStrRadix for f32 {\n ///\n /// # Return value\n ///\n-/// `none` if the string did not represent a valid number.  Otherwise,\n+/// `None` if the string did not represent a valid number.  Otherwise,\n /// `Some(n)` where `n` is the floating-point number represented by `[num]`.\n ///\n #[inline]\n@@ -884,7 +882,7 @@ impl FromStr for f32 {\n     ///\n     /// # Return value\n     ///\n-    /// `none` if the string did not represent a valid number.  Otherwise,\n+    /// `None` if the string did not represent a valid number.  Otherwise,\n     /// `Some(n)` where `n` is the floating-point number represented by `num`.\n     ///\n     #[inline]\n@@ -911,7 +909,7 @@ impl num::FromStrRadix for f32 {\n     ///\n     /// # Return value\n     ///\n-    /// `none` if the string did not represent a valid number. Otherwise,\n+    /// `None` if the string did not represent a valid number. Otherwise,\n     /// `Some(n)` where `n` is the floating-point number represented by `num`.\n     ///\n     #[inline]\n@@ -1122,14 +1120,14 @@ mod tests {\n \n     #[test]\n     pub fn test_abs() {\n-        assert_eq!(infinity.abs(), infinity);\n+        assert_eq!(INFINITY.abs(), INFINITY);\n         assert_eq!(1f32.abs(), 1f32);\n         assert_eq!(0f32.abs(), 0f32);\n         assert_eq!((-0f32).abs(), 0f32);\n         assert_eq!((-1f32).abs(), 1f32);\n-        assert_eq!(neg_infinity.abs(), infinity);\n-        assert_eq!((1f32/neg_infinity).abs(), 0f32);\n-        assert!(NaN.abs().is_nan());\n+        assert_eq!(NEG_INFINITY.abs(), INFINITY);\n+        assert_eq!((1f32/NEG_INFINITY).abs(), 0f32);\n+        assert!(NAN.abs().is_nan());\n     }\n \n     #[test]\n@@ -1138,52 +1136,52 @@ mod tests {\n         assert_eq!(1f32.abs_sub(&1f32), 0f32);\n         assert_eq!(1f32.abs_sub(&0f32), 1f32);\n         assert_eq!(1f32.abs_sub(&-1f32), 2f32);\n-        assert_eq!(neg_infinity.abs_sub(&0f32), 0f32);\n-        assert_eq!(infinity.abs_sub(&1f32), infinity);\n-        assert_eq!(0f32.abs_sub(&neg_infinity), infinity);\n-        assert_eq!(0f32.abs_sub(&infinity), 0f32);\n+        assert_eq!(NEG_INFINITY.abs_sub(&0f32), 0f32);\n+        assert_eq!(INFINITY.abs_sub(&1f32), INFINITY);\n+        assert_eq!(0f32.abs_sub(&NEG_INFINITY), INFINITY);\n+        assert_eq!(0f32.abs_sub(&INFINITY), 0f32);\n     }\n \n     #[test] #[ignore(cfg(windows))] // FIXME #8663\n     fn test_abs_sub_nowin() {\n-        assert!(NaN.abs_sub(&-1f32).is_nan());\n-        assert!(1f32.abs_sub(&NaN).is_nan());\n+        assert!(NAN.abs_sub(&-1f32).is_nan());\n+        assert!(1f32.abs_sub(&NAN).is_nan());\n     }\n \n     #[test]\n     fn test_signum() {\n-        assert_eq!(infinity.signum(), 1f32);\n+        assert_eq!(INFINITY.signum(), 1f32);\n         assert_eq!(1f32.signum(), 1f32);\n         assert_eq!(0f32.signum(), 1f32);\n         assert_eq!((-0f32).signum(), -1f32);\n         assert_eq!((-1f32).signum(), -1f32);\n-        assert_eq!(neg_infinity.signum(), -1f32);\n-        assert_eq!((1f32/neg_infinity).signum(), -1f32);\n-        assert!(NaN.signum().is_nan());\n+        assert_eq!(NEG_INFINITY.signum(), -1f32);\n+        assert_eq!((1f32/NEG_INFINITY).signum(), -1f32);\n+        assert!(NAN.signum().is_nan());\n     }\n \n     #[test]\n     fn test_is_positive() {\n-        assert!(infinity.is_positive());\n+        assert!(INFINITY.is_positive());\n         assert!(1f32.is_positive());\n         assert!(0f32.is_positive());\n         assert!(!(-0f32).is_positive());\n         assert!(!(-1f32).is_positive());\n-        assert!(!neg_infinity.is_positive());\n-        assert!(!(1f32/neg_infinity).is_positive());\n-        assert!(!NaN.is_positive());\n+        assert!(!NEG_INFINITY.is_positive());\n+        assert!(!(1f32/NEG_INFINITY).is_positive());\n+        assert!(!NAN.is_positive());\n     }\n \n     #[test]\n     fn test_is_negative() {\n-        assert!(!infinity.is_negative());\n+        assert!(!INFINITY.is_negative());\n         assert!(!1f32.is_negative());\n         assert!(!0f32.is_negative());\n         assert!((-0f32).is_negative());\n         assert!((-1f32).is_negative());\n-        assert!(neg_infinity.is_negative());\n-        assert!((1f32/neg_infinity).is_negative());\n-        assert!(!NaN.is_negative());\n+        assert!(NEG_INFINITY.is_negative());\n+        assert!((1f32/NEG_INFINITY).is_negative());\n+        assert!(!NAN.is_negative());\n     }\n \n     #[test]"}, {"sha": "5feab20ba81d3a9a48fd960ccfb0ec05ec0b9dcf", "filename": "src/libstd/num/f64.rs", "status": "modified", "additions": 74, "deletions": 76, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/67d7be0ff197fe0d0c420abc8ac9c4b94a3ed025/src%2Flibstd%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67d7be0ff197fe0d0c420abc8ac9c4b94a3ed025/src%2Flibstd%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff64.rs?ref=67d7be0ff197fe0d0c420abc8ac9c4b94a3ed025", "patch": "@@ -11,8 +11,6 @@\n //! Operations and constants for `f64`\n \n #[allow(missing_doc)];\n-#[allow(non_uppercase_statics)];\n-#[allow(non_uppercase_pattern_statics)];\n \n use default::Default;\n use libc::c_int;\n@@ -122,27 +120,27 @@ delegate!(\n // These are not defined inside consts:: for consistency with\n // the integer types\n \n-pub static radix: uint = 2u;\n+pub static RADIX: uint = 2u;\n \n-pub static mantissa_digits: uint = 53u;\n-pub static digits: uint = 15u;\n+pub static MANTISSA_DIGITS: uint = 53u;\n+pub static DIGITS: uint = 15u;\n \n-pub static epsilon: f64 = 2.2204460492503131e-16_f64;\n+pub static EPSILON: f64 = 2.2204460492503131e-16_f64;\n \n-pub static min_value: f64 = 2.2250738585072014e-308_f64;\n-pub static max_value: f64 = 1.7976931348623157e+308_f64;\n+pub static MIN_VALUE: f64 = 2.2250738585072014e-308_f64;\n+pub static MAX_VALUE: f64 = 1.7976931348623157e+308_f64;\n \n-pub static min_exp: int = -1021;\n-pub static max_exp: int = 1024;\n+pub static MIN_EXP: int = -1021;\n+pub static MAX_EXP: int = 1024;\n \n-pub static min_10_exp: int = -307;\n-pub static max_10_exp: int = 308;\n+pub static MIN_10_EXP: int = -307;\n+pub static MAX_10_EXP: int = 308;\n \n-pub static NaN: f64 = 0.0_f64/0.0_f64;\n+pub static NAN: f64 = 0.0_f64/0.0_f64;\n \n-pub static infinity: f64 = 1.0_f64/0.0_f64;\n+pub static INFINITY: f64 = 1.0_f64/0.0_f64;\n \n-pub static neg_infinity: f64 = -1.0_f64/0.0_f64;\n+pub static NEG_INFINITY: f64 = -1.0_f64/0.0_f64;\n \n // FIXME (#1999): add is_normal, is_subnormal, and fpclassify\n \n@@ -151,43 +149,43 @@ pub mod consts {\n     // FIXME (requires Issue #1433 to fix): replace with mathematical\n     // constants from cmath.\n     /// Archimedes' constant\n-    pub static pi: f64 = 3.14159265358979323846264338327950288_f64;\n+    pub static PI: f64 = 3.14159265358979323846264338327950288_f64;\n \n     /// pi/2.0\n-    pub static frac_pi_2: f64 = 1.57079632679489661923132169163975144_f64;\n+    pub static FRAC_PI_2: f64 = 1.57079632679489661923132169163975144_f64;\n \n     /// pi/4.0\n-    pub static frac_pi_4: f64 = 0.785398163397448309615660845819875721_f64;\n+    pub static FRAC_PI_4: f64 = 0.785398163397448309615660845819875721_f64;\n \n     /// 1.0/pi\n-    pub static frac_1_pi: f64 = 0.318309886183790671537767526745028724_f64;\n+    pub static FRAC_1_PI: f64 = 0.318309886183790671537767526745028724_f64;\n \n     /// 2.0/pi\n-    pub static frac_2_pi: f64 = 0.636619772367581343075535053490057448_f64;\n+    pub static FRAC_2_PI: f64 = 0.636619772367581343075535053490057448_f64;\n \n     /// 2.0/sqrt(pi)\n-    pub static frac_2_sqrtpi: f64 = 1.12837916709551257389615890312154517_f64;\n+    pub static FRAC_2_SQRTPI: f64 = 1.12837916709551257389615890312154517_f64;\n \n     /// sqrt(2.0)\n-    pub static sqrt2: f64 = 1.41421356237309504880168872420969808_f64;\n+    pub static SQRT2: f64 = 1.41421356237309504880168872420969808_f64;\n \n     /// 1.0/sqrt(2.0)\n-    pub static frac_1_sqrt2: f64 = 0.707106781186547524400844362104849039_f64;\n+    pub static FRAC_1_SQRT2: f64 = 0.707106781186547524400844362104849039_f64;\n \n     /// Euler's number\n-    pub static e: f64 = 2.71828182845904523536028747135266250_f64;\n+    pub static E: f64 = 2.71828182845904523536028747135266250_f64;\n \n     /// log2(e)\n-    pub static log2_e: f64 = 1.44269504088896340735992468100189214_f64;\n+    pub static LOG2_E: f64 = 1.44269504088896340735992468100189214_f64;\n \n     /// log10(e)\n-    pub static log10_e: f64 = 0.434294481903251827651128918916605082_f64;\n+    pub static LOG10_E: f64 = 0.434294481903251827651128918916605082_f64;\n \n     /// ln(2.0)\n-    pub static ln_2: f64 = 0.693147180559945309417232121458176568_f64;\n+    pub static LN_2: f64 = 0.693147180559945309417232121458176568_f64;\n \n     /// ln(10.0)\n-    pub static ln_10: f64 = 2.30258509299404568401799145468436421_f64;\n+    pub static LN_10: f64 = 2.30258509299404568401799145468436421_f64;\n }\n \n impl Num for f64 {}\n@@ -227,7 +225,7 @@ impl Ord for f64 {\n }\n \n impl Orderable for f64 {\n-    /// Returns `NaN` if either of the numbers are `NaN`.\n+    /// Returns `NAN` if either of the numbers are `NAN`.\n     #[inline]\n     fn min(&self, other: &f64) -> f64 {\n         match () {\n@@ -238,7 +236,7 @@ impl Orderable for f64 {\n         }\n     }\n \n-    /// Returns `NaN` if either of the numbers are `NaN`.\n+    /// Returns `NAN` if either of the numbers are `NAN`.\n     #[inline]\n     fn max(&self, other: &f64) -> f64 {\n         match () {\n@@ -250,7 +248,7 @@ impl Orderable for f64 {\n     }\n \n     /// Returns the number constrained within the range `mn <= self <= mx`.\n-    /// If any of the numbers are `NaN` then `NaN` is returned.\n+    /// If any of the numbers are `NAN` then `NAN` is returned.\n     #[inline]\n     fn clamp(&self, mn: &f64, mx: &f64) -> f64 {\n         match () {\n@@ -313,7 +311,7 @@ impl Neg<f64> for f64 {\n }\n \n impl Signed for f64 {\n-    /// Computes the absolute value. Returns `NaN` if the number is `NaN`.\n+    /// Computes the absolute value. Returns `NAN` if the number is `NAN`.\n     #[inline]\n     fn abs(&self) -> f64 { abs(*self) }\n \n@@ -327,30 +325,30 @@ impl Signed for f64 {\n     ///\n     /// # Returns\n     ///\n-    /// - `1.0` if the number is positive, `+0.0` or `infinity`\n-    /// - `-1.0` if the number is negative, `-0.0` or `neg_infinity`\n-    /// - `NaN` if the number is NaN\n+    /// - `1.0` if the number is positive, `+0.0` or `INFINITY`\n+    /// - `-1.0` if the number is negative, `-0.0` or `NEG_INFINITY`\n+    /// - `NAN` if the number is NaN\n     ///\n     #[inline]\n     fn signum(&self) -> f64 {\n-        if self.is_nan() { NaN } else { copysign(1.0, *self) }\n+        if self.is_nan() { NAN } else { copysign(1.0, *self) }\n     }\n \n-    /// Returns `true` if the number is positive, including `+0.0` and `infinity`\n+    /// Returns `true` if the number is positive, including `+0.0` and `INFINITY`\n     #[inline]\n-    fn is_positive(&self) -> bool { *self > 0.0 || (1.0 / *self) == infinity }\n+    fn is_positive(&self) -> bool { *self > 0.0 || (1.0 / *self) == INFINITY }\n \n-    /// Returns `true` if the number is negative, including `-0.0` and `neg_infinity`\n+    /// Returns `true` if the number is negative, including `-0.0` and `NEG_INFINITY`\n     #[inline]\n-    fn is_negative(&self) -> bool { *self < 0.0 || (1.0 / *self) == neg_infinity }\n+    fn is_negative(&self) -> bool { *self < 0.0 || (1.0 / *self) == NEG_INFINITY }\n }\n \n impl Round for f64 {\n-    /// Round half-way cases toward `neg_infinity`\n+    /// Round half-way cases toward `NEG_INFINITY`\n     #[inline]\n     fn floor(&self) -> f64 { floor(*self) }\n \n-    /// Round half-way cases toward `infinity`\n+    /// Round half-way cases toward `INFINITY`\n     #[inline]\n     fn ceil(&self) -> f64 { ceil(*self) }\n \n@@ -467,13 +465,13 @@ impl Hyperbolic for f64 {\n     /// # Returns\n     ///\n     /// - on success, the inverse hyperbolic sine of `self` will be returned\n-    /// - `self` if `self` is `0.0`, `-0.0`, `infinity`, or `neg_infinity`\n-    /// - `NaN` if `self` is `NaN`\n+    /// - `self` if `self` is `0.0`, `-0.0`, `INFINITY`, or `NEG_INFINITY`\n+    /// - `NAN` if `self` is `NAN`\n     ///\n     #[inline]\n     fn asinh(&self) -> f64 {\n         match *self {\n-            neg_infinity => neg_infinity,\n+            NEG_INFINITY => NEG_INFINITY,\n             x => (x + ((x * x) + 1.0).sqrt()).ln(),\n         }\n     }\n@@ -484,8 +482,8 @@ impl Hyperbolic for f64 {\n     /// # Returns\n     ///\n     /// - on success, the inverse hyperbolic cosine of `self` will be returned\n-    /// - `infinity` if `self` is `infinity`\n-    /// - `NaN` if `self` is `NaN` or `self < 1.0` (including `neg_infinity`)\n+    /// - `INFINITY` if `self` is `INFINITY`\n+    /// - `NAN` if `self` is `NAN` or `self < 1.0` (including `NEG_INFINITY`)\n     ///\n     #[inline]\n     fn acosh(&self) -> f64 {\n@@ -502,10 +500,10 @@ impl Hyperbolic for f64 {\n     ///\n     /// - on success, the inverse hyperbolic tangent of `self` will be returned\n     /// - `self` if `self` is `0.0` or `-0.0`\n-    /// - `infinity` if `self` is `1.0`\n-    /// - `neg_infinity` if `self` is `-1.0`\n-    /// - `NaN` if the `self` is `NaN` or outside the domain of `-1.0 <= self <= 1.0`\n-    ///   (including `infinity` and `neg_infinity`)\n+    /// - `INFINITY` if `self` is `1.0`\n+    /// - `NEG_INFINITY` if `self` is `-1.0`\n+    /// - `NAN` if the `self` is `NAN` or outside the domain of `-1.0 <= self <= 1.0`\n+    ///   (including `INFINITY` and `NEG_INFINITY`)\n     ///\n     #[inline]\n     fn atanh(&self) -> f64 {\n@@ -861,7 +859,7 @@ impl num::ToStrRadix for f64 {\n     ///\n     /// # Failure\n     ///\n-    /// Fails if called on a special value like `inf`, `-inf` or `NaN` due to\n+    /// Fails if called on a special value like `inf`, `-inf` or `NAN` due to\n     /// possible misinterpretation of the result at higher bases. If those values\n     /// are expected, use `to_str_radix_special()` instead.\n     #[inline]\n@@ -898,7 +896,7 @@ impl num::ToStrRadix for f64 {\n ///\n /// # Return value\n ///\n-/// `none` if the string did not represent a valid number.  Otherwise,\n+/// `None` if the string did not represent a valid number.  Otherwise,\n /// `Some(n)` where `n` is the floating-point number represented by `[num]`.\n ///\n #[inline]\n@@ -959,7 +957,7 @@ impl num::FromStrRadix for f64 {\n     ///\n     /// # Return value\n     ///\n-    /// `none` if the string did not represent a valid number. Otherwise,\n+    /// `None` if the string did not represent a valid number. Otherwise,\n     /// `Some(n)` where `n` is the floating-point number represented by `num`.\n     ///\n     #[inline]\n@@ -1173,14 +1171,14 @@ mod tests {\n \n     #[test]\n     pub fn test_abs() {\n-        assert_eq!(infinity.abs(), infinity);\n+        assert_eq!(INFINITY.abs(), INFINITY);\n         assert_eq!(1f64.abs(), 1f64);\n         assert_eq!(0f64.abs(), 0f64);\n         assert_eq!((-0f64).abs(), 0f64);\n         assert_eq!((-1f64).abs(), 1f64);\n-        assert_eq!(neg_infinity.abs(), infinity);\n-        assert_eq!((1f64/neg_infinity).abs(), 0f64);\n-        assert!(NaN.abs().is_nan());\n+        assert_eq!(NEG_INFINITY.abs(), INFINITY);\n+        assert_eq!((1f64/NEG_INFINITY).abs(), 0f64);\n+        assert!(NAN.abs().is_nan());\n     }\n \n     #[test]\n@@ -1189,52 +1187,52 @@ mod tests {\n         assert_eq!(1f64.abs_sub(&1f64), 0f64);\n         assert_eq!(1f64.abs_sub(&0f64), 1f64);\n         assert_eq!(1f64.abs_sub(&-1f64), 2f64);\n-        assert_eq!(neg_infinity.abs_sub(&0f64), 0f64);\n-        assert_eq!(infinity.abs_sub(&1f64), infinity);\n-        assert_eq!(0f64.abs_sub(&neg_infinity), infinity);\n-        assert_eq!(0f64.abs_sub(&infinity), 0f64);\n+        assert_eq!(NEG_INFINITY.abs_sub(&0f64), 0f64);\n+        assert_eq!(INFINITY.abs_sub(&1f64), INFINITY);\n+        assert_eq!(0f64.abs_sub(&NEG_INFINITY), INFINITY);\n+        assert_eq!(0f64.abs_sub(&INFINITY), 0f64);\n     }\n \n     #[test] #[ignore(cfg(windows))] // FIXME #8663\n     fn test_abs_sub_nowin() {\n-        assert!(NaN.abs_sub(&-1f64).is_nan());\n-        assert!(1f64.abs_sub(&NaN).is_nan());\n+        assert!(NAN.abs_sub(&-1f64).is_nan());\n+        assert!(1f64.abs_sub(&NAN).is_nan());\n     }\n \n     #[test]\n     fn test_signum() {\n-        assert_eq!(infinity.signum(), 1f64);\n+        assert_eq!(INFINITY.signum(), 1f64);\n         assert_eq!(1f64.signum(), 1f64);\n         assert_eq!(0f64.signum(), 1f64);\n         assert_eq!((-0f64).signum(), -1f64);\n         assert_eq!((-1f64).signum(), -1f64);\n-        assert_eq!(neg_infinity.signum(), -1f64);\n-        assert_eq!((1f64/neg_infinity).signum(), -1f64);\n-        assert!(NaN.signum().is_nan());\n+        assert_eq!(NEG_INFINITY.signum(), -1f64);\n+        assert_eq!((1f64/NEG_INFINITY).signum(), -1f64);\n+        assert!(NAN.signum().is_nan());\n     }\n \n     #[test]\n     fn test_is_positive() {\n-        assert!(infinity.is_positive());\n+        assert!(INFINITY.is_positive());\n         assert!(1f64.is_positive());\n         assert!(0f64.is_positive());\n         assert!(!(-0f64).is_positive());\n         assert!(!(-1f64).is_positive());\n-        assert!(!neg_infinity.is_positive());\n-        assert!(!(1f64/neg_infinity).is_positive());\n-        assert!(!NaN.is_positive());\n+        assert!(!NEG_INFINITY.is_positive());\n+        assert!(!(1f64/NEG_INFINITY).is_positive());\n+        assert!(!NAN.is_positive());\n     }\n \n     #[test]\n     fn test_is_negative() {\n-        assert!(!infinity.is_negative());\n+        assert!(!INFINITY.is_negative());\n         assert!(!1f64.is_negative());\n         assert!(!0f64.is_negative());\n         assert!((-0f64).is_negative());\n         assert!((-1f64).is_negative());\n-        assert!(neg_infinity.is_negative());\n-        assert!((1f64/neg_infinity).is_negative());\n-        assert!(!NaN.is_negative());\n+        assert!(NEG_INFINITY.is_negative());\n+        assert!((1f64/NEG_INFINITY).is_negative());\n+        assert!(!NAN.is_negative());\n     }\n \n     #[test]"}, {"sha": "3097a8e138ef0abcb61514ec8250339ea7607c0d", "filename": "src/libstd/num/num.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/67d7be0ff197fe0d0c420abc8ac9c4b94a3ed025/src%2Flibstd%2Fnum%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67d7be0ff197fe0d0c420abc8ac9c4b94a3ed025/src%2Flibstd%2Fnum%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fnum.rs?ref=67d7be0ff197fe0d0c420abc8ac9c4b94a3ed025", "patch": "@@ -86,9 +86,9 @@ pub trait Signed: Num\n /// Returns the sign of the number.\n ///\n /// For float, f32, f64:\n-/// - `1.0` if the number is positive, `+0.0` or `infinity`\n-/// - `-1.0` if the number is negative, `-0.0` or `neg_infinity`\n-/// - `NaN` if the number is `NaN`\n+/// - `1.0` if the number is positive, `+0.0` or `INFINITY`\n+/// - `-1.0` if the number is negative, `-0.0` or `NEG_INFINITY`\n+/// - `NAN` if the number is `NAN`\n ///\n /// For int:\n /// - `0` if the number is zero"}, {"sha": "65f0f7a84aedf52fcbfc78aea2ee967f7768379a", "filename": "src/test/bench/noise.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/67d7be0ff197fe0d0c420abc8ac9c4b94a3ed025/src%2Ftest%2Fbench%2Fnoise.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67d7be0ff197fe0d0c420abc8ac9c4b94a3ed025/src%2Ftest%2Fbench%2Fnoise.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fnoise.rs?ref=67d7be0ff197fe0d0c420abc8ac9c4b94a3ed025", "patch": "@@ -16,7 +16,7 @@ fn lerp(a: f32, b: f32, v: f32) -> f32 { a * (1.0 - v) + b * v }\n fn smooth(v: f32) -> f32 { v * v * (3.0 - 2.0 * v) }\n \n fn random_gradient<R:Rng>(r: &mut R) -> Vec2 {\n-    let v = 2.0 * f64::consts::pi * r.gen();\n+    let v = 2.0 * f64::consts::PI * r.gen();\n     Vec2 {\n         x: v.cos() as f32,\n         y: v.sin() as f32,"}, {"sha": "c2e0c40d8ca2f4201a79a55f3bec2be27f785e99", "filename": "src/test/compile-fail/issue-6804.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/67d7be0ff197fe0d0c420abc8ac9c4b94a3ed025/src%2Ftest%2Fcompile-fail%2Fissue-6804.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67d7be0ff197fe0d0c420abc8ac9c4b94a3ed025/src%2Ftest%2Fcompile-fail%2Fissue-6804.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-6804.rs?ref=67d7be0ff197fe0d0c420abc8ac9c4b94a3ed025", "patch": "@@ -1,18 +1,16 @@\n-#[allow(non_uppercase_pattern_statics)];\n-\n // Matching against NaN should result in a warning\n \n-use std::f64::NaN;\n+use std::f64::NAN;\n \n fn main() {\n-    let x = NaN;\n+    let x = NAN;\n     match x {\n-        NaN => {},\n+        NAN => {},\n         _ => {},\n     };\n     //~^^^ WARNING unmatchable NaN in pattern, use the is_nan method in a guard instead\n     match [x, 1.0] {\n-        [NaN, _] => {},\n+        [NAN, _] => {},\n         _ => {},\n     };\n     //~^^^ WARNING unmatchable NaN in pattern, use the is_nan method in a guard instead"}, {"sha": "2a6143979feb1ecffd131cbec1439d687f4babbc", "filename": "src/test/run-pass/intrinsics-math.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/67d7be0ff197fe0d0c420abc8ac9c4b94a3ed025/src%2Ftest%2Frun-pass%2Fintrinsics-math.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67d7be0ff197fe0d0c420abc8ac9c4b94a3ed025/src%2Ftest%2Frun-pass%2Fintrinsics-math.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fintrinsics-math.rs?ref=67d7be0ff197fe0d0c420abc8ac9c4b94a3ed025", "patch": "@@ -61,31 +61,31 @@ pub fn main() {\n         assert!((powif64(23.2f64, 2i32).approx_eq(&538.24f64)));\n \n         assert!((sinf32(0f32).approx_eq(&0f32)));\n-        assert!((sinf64(f64::consts::pi / 2f64).approx_eq(&1f64)));\n+        assert!((sinf64(f64::consts::PI / 2f64).approx_eq(&1f64)));\n \n         assert!((cosf32(0f32).approx_eq(&1f32)));\n-        assert!((cosf64(f64::consts::pi * 2f64).approx_eq(&1f64)));\n+        assert!((cosf64(f64::consts::PI * 2f64).approx_eq(&1f64)));\n \n         assert!((powf32(25f32, -2f32).approx_eq(&0.0016f32)));\n         assert!((powf64(400f64, 0.5f64).approx_eq(&20f64)));\n \n-        assert!((fabsf32(expf32(1f32) - f32::consts::e).approx_eq(&0f32)));\n-        assert!((expf64(1f64).approx_eq(&f64::consts::e)));\n+        assert!((fabsf32(expf32(1f32) - f32::consts::E).approx_eq(&0f32)));\n+        assert!((expf64(1f64).approx_eq(&f64::consts::E)));\n \n         assert!((exp2f32(10f32).approx_eq(&1024f32)));\n         assert!((exp2f64(50f64).approx_eq(&1125899906842624f64)));\n \n-        assert!((fabsf32(logf32(f32::consts::e) - 1f32).approx_eq(&0f32)));\n+        assert!((fabsf32(logf32(f32::consts::E) - 1f32).approx_eq(&0f32)));\n         assert!((logf64(1f64).approx_eq(&0f64)));\n \n         assert!((log10f32(10f32).approx_eq(&1f32)));\n-        assert!((log10f64(f64::consts::e).approx_eq(&f64::consts::log10_e)));\n+        assert!((log10f64(f64::consts::E).approx_eq(&f64::consts::LOG10_E)));\n \n         assert!((log2f32(8f32).approx_eq(&3f32)));\n-        assert!((log2f64(f64::consts::e).approx_eq(&f64::consts::log2_e)));\n+        assert!((log2f64(f64::consts::E).approx_eq(&f64::consts::LOG2_E)));\n \n         assert!((fmaf32(1.0f32, 2.0f32, 5.0f32).approx_eq(&7.0f32)));\n-        assert!((fmaf64(0.0f64, -2.0f64, f64::consts::e).approx_eq(&f64::consts::e)));\n+        assert!((fmaf64(0.0f64, -2.0f64, f64::consts::E).approx_eq(&f64::consts::E)));\n \n         assert!((fabsf32(-1.0f32).approx_eq(&1.0f32)));\n         assert!((fabsf64(34.2f64).approx_eq(&34.2f64)));"}, {"sha": "fe2d729bc9e44c0e7d3af2659ac3fef780b24f55", "filename": "src/test/run-pass/issue-3753.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/67d7be0ff197fe0d0c420abc8ac9c4b94a3ed025/src%2Ftest%2Frun-pass%2Fissue-3753.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67d7be0ff197fe0d0c420abc8ac9c4b94a3ed025/src%2Ftest%2Frun-pass%2Fissue-3753.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-3753.rs?ref=67d7be0ff197fe0d0c420abc8ac9c4b94a3ed025", "patch": "@@ -27,7 +27,7 @@ pub enum Shape {\n impl Shape {\n     pub fn area(&self, sh: Shape) -> f64 {\n         match sh {\n-            Circle(_, size) => f64::consts::pi * size * size,\n+            Circle(_, size) => f64::consts::PI * size * size,\n             Rectangle(Point {x, y}, Point {x: x2, y: y2}) => (x2 - x) * (y2 - y)\n         }\n     }"}]}