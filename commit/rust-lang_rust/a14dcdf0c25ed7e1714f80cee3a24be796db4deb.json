{"sha": "a14dcdf0c25ed7e1714f80cee3a24be796db4deb", "node_id": "MDY6Q29tbWl0NzI0NzEyOmExNGRjZGYwYzI1ZWQ3ZTE3MTRmODBjZWUzYTI0YmU3OTZkYjRkZWI=", "commit": {"author": {"name": "Oliver Schneider", "email": "git1984941651981@oli-obk.de", "date": "2015-05-04T09:00:14Z"}, "committer": {"name": "Oliver Schneider", "email": "git1984941651981@oli-obk.de", "date": "2015-05-04T09:04:34Z"}, "message": "addressed comments", "tree": {"sha": "819f00a314dd92604d75ac9d8b1c623d4e93f5ee", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/819f00a314dd92604d75ac9d8b1c623d4e93f5ee"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a14dcdf0c25ed7e1714f80cee3a24be796db4deb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a14dcdf0c25ed7e1714f80cee3a24be796db4deb", "html_url": "https://github.com/rust-lang/rust/commit/a14dcdf0c25ed7e1714f80cee3a24be796db4deb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a14dcdf0c25ed7e1714f80cee3a24be796db4deb/comments", "author": null, "committer": null, "parents": [{"sha": "07637aed418e9839f665eda24fe823712713790f", "url": "https://api.github.com/repos/rust-lang/rust/commits/07637aed418e9839f665eda24fe823712713790f", "html_url": "https://github.com/rust-lang/rust/commit/07637aed418e9839f665eda24fe823712713790f"}], "stats": {"total": 46, "additions": 17, "deletions": 29}, "files": [{"sha": "64700be69f9a1be8e5a7ea168cb9b08cc721ddae", "filename": "tests/idem.rs", "status": "modified", "additions": 17, "deletions": 29, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/a14dcdf0c25ed7e1714f80cee3a24be796db4deb/tests%2Fidem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a14dcdf0c25ed7e1714f80cee3a24be796db4deb/tests%2Fidem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fidem.rs?ref=a14dcdf0c25ed7e1714f80cee3a24be796db4deb", "patch": "@@ -8,12 +8,12 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(std_misc)]\n extern crate rustfmt;\n \n use std::collections::HashMap;\n use std::fs;\n use std::io::Read;\n+use std::thread;\n use rustfmt::*;\n \n // For now, the only supported regression tests are idempotent tests - the input and\n@@ -25,20 +25,19 @@ fn idempotent_tests() {\n \n     // Get all files in the tests/idem directory\n     let files = fs::read_dir(\"tests/idem\").unwrap();\n-    let files2 = fs::read_dir(\"tests\").unwrap();\n-    let files3 = fs::read_dir(\"src/bin\").unwrap();\n-    // For each file, run rustfmt and collect the output\n+    let files = files.chain(fs::read_dir(\"tests\").unwrap());\n+    let files = files.chain(fs::read_dir(\"src/bin\").unwrap());\n+    // turn a DirEntry into a String that represents the relative path to the file\n+    let files = files.map(|e| e.unwrap().path().to_str().unwrap().to_owned());\n+    // hack because there's no `IntoIterator` impl for `[T; N]`\n+    let files = files.chain(Some(\"src/lib.rs\".to_owned()).into_iter());\n \n+    // For each file, run rustfmt and collect the output\n     let mut count = 0;\n     let mut fails = 0;\n-    for entry in files.chain(files2).chain(files3) {\n-        let path = entry.unwrap().path();\n-        let file_name = path.to_str().unwrap();\n-        if !file_name.ends_with(\".rs\") {\n-            continue;\n-        }\n+    for file_name in files.filter(|f| f.ends_with(\".rs\")) {\n         println!(\"Testing '{}'...\", file_name);\n-        match idempotent_check(file_name.to_owned()) {\n+        match idempotent_check(file_name) {\n             Ok(()) => {},\n             Err(m) => {\n                 print_mismatches(m);\n@@ -47,16 +46,6 @@ fn idempotent_tests() {\n         }\n         count += 1;\n     }\n-    // And also dogfood rustfmt!\n-    println!(\"Testing 'src/lib.rs'...\");\n-    match idempotent_check(\"src/lib.rs\".to_owned()) {\n-        Ok(()) => {},\n-        Err(m) => {\n-            print_mismatches(m);\n-            fails += 1;\n-        },\n-    }\n-    count += 1;\n \n     // Display results\n     println!(\"Ran {} idempotent tests; {} failures.\", count, fails);\n@@ -75,17 +64,16 @@ fn print_mismatches(result: HashMap<String, String>) {\n static HANDLE_RESULT: &'static Fn(HashMap<String, String>) = &handle_result;\n \n pub fn idempotent_check(filename: String) -> Result<(), HashMap<String, String>> {\n-    use std::thread;\n-    use std::fs;\n-    use std::io::Read;\n     let args = vec![\"rustfmt\".to_owned(), filename];\n+    // this thread is not used for concurrency, but rather to workaround the issue that the passed\n+    // function handle needs to have static lifetime. Instead of using a global RefCell, we use\n+    // panic to return a result in case of failure. This has the advantage of smoothing the road to\n+    // multithreaded rustfmt\n     thread::spawn(move || {\n         run(args, WriteMode::Return(HANDLE_RESULT));\n-    }).join().map_err(|mut any|\n-        any.downcast_mut::<HashMap<String, String>>()\n-           .unwrap() // i know it is a hashmap\n-           .drain() // i only get a reference :(\n-           .collect() // so i need to turn it into an iter and then back\n+    }).join().map_err(|any|\n+        // i know it is a hashmap\n+        *any.downcast().unwrap()\n     )\n }\n "}]}