{"sha": "18b1342f236cac3893ecbf7fba0848e612e075a9", "node_id": "C_kwDOAAsO6NoAKDE4YjEzNDJmMjM2Y2FjMzg5M2VjYmY3ZmJhMDg0OGU2MTJlMDc1YTk", "commit": {"author": {"name": "Yuki Okushi", "email": "jtitor@2k36.org", "date": "2022-10-13T00:41:27Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-10-13T00:41:27Z"}, "message": "Rollup merge of #102971 - est31:tidy_duplicate_lang_features, r=jyn514\n\ntidy: error if a lang feature is already present\n\nIf a lang feature gets declared twice, like for example as a result of a mistake during stabilization, emit an error in tidy. Library features already have this logic.\n\nInspired by a mistake done during `half_open_range_patterns` stabilization: https://github.com/rust-lang/rust/pull/102275/files#r991292215\n\nThe PR requires #102883 to be merged before CI turns green because the check is doing its job.\n\nFor reviewers, I suggest [turning off whitespace changes](https://github.com/rust-lang/rust/pull/102971/files?w=1) in the diff by adding `?w=1` to the url, as a large part of the diff is just about removing one level of indentation.", "tree": {"sha": "0c631efb589512ec6da4cc0b24ff0c64f397124f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0c631efb589512ec6da4cc0b24ff0c64f397124f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/18b1342f236cac3893ecbf7fba0848e612e075a9", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJjR163CRBK7hj4Ov3rIwAA47YIACQ2T4xDGYBI7J+SOhoF9xNx\n9W7ULwDxarjhMYI4y3brWPNZRgpkKQHlDHazYJZX3dUJyTS0wGLocOZFqhscsHYs\nIvAp8WoAxpfVTsSIbX2CxIoCGrPYUJJrbETthC1ygo5os8sOt3u0RvYGMuhSFnZP\nzV44OmNtpsnIfXhvx8P6TBuj+UdNxQbn/sDN6DkCVXctH16n1EjT+tkHIgRopjgF\nVsAx7TlZG6Y5GWOzdYBeSullcvlqyAxgvxxUFnvgJNCFvpI9yNVUw7vFhMBmGtt7\nItQRcKKK7INGQQ+fLp2qVhxXEQWopnBawZbd+HdyYUSarMqrlTQhOnoWBUe6Hug=\n=qdhl\n-----END PGP SIGNATURE-----\n", "payload": "tree 0c631efb589512ec6da4cc0b24ff0c64f397124f\nparent 36ea7cd88c91547204d5f8e9016ee7a07890117c\nparent c278700af4bf75547e0b796fb56b489ad5b72046\nauthor Yuki Okushi <jtitor@2k36.org> 1665621687 +0900\ncommitter GitHub <noreply@github.com> 1665621687 +0900\n\nRollup merge of #102971 - est31:tidy_duplicate_lang_features, r=jyn514\n\ntidy: error if a lang feature is already present\n\nIf a lang feature gets declared twice, like for example as a result of a mistake during stabilization, emit an error in tidy. Library features already have this logic.\n\nInspired by a mistake done during `half_open_range_patterns` stabilization: https://github.com/rust-lang/rust/pull/102275/files#r991292215\n\nThe PR requires #102883 to be merged before CI turns green because the check is doing its job.\n\nFor reviewers, I suggest [turning off whitespace changes](https://github.com/rust-lang/rust/pull/102971/files?w=1) in the diff by adding `?w=1` to the url, as a large part of the diff is just about removing one level of indentation.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/18b1342f236cac3893ecbf7fba0848e612e075a9", "html_url": "https://github.com/rust-lang/rust/commit/18b1342f236cac3893ecbf7fba0848e612e075a9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/18b1342f236cac3893ecbf7fba0848e612e075a9/comments", "author": {"login": "JohnTitor", "id": 25030997, "node_id": "MDQ6VXNlcjI1MDMwOTk3", "avatar_url": "https://avatars.githubusercontent.com/u/25030997?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JohnTitor", "html_url": "https://github.com/JohnTitor", "followers_url": "https://api.github.com/users/JohnTitor/followers", "following_url": "https://api.github.com/users/JohnTitor/following{/other_user}", "gists_url": "https://api.github.com/users/JohnTitor/gists{/gist_id}", "starred_url": "https://api.github.com/users/JohnTitor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JohnTitor/subscriptions", "organizations_url": "https://api.github.com/users/JohnTitor/orgs", "repos_url": "https://api.github.com/users/JohnTitor/repos", "events_url": "https://api.github.com/users/JohnTitor/events{/privacy}", "received_events_url": "https://api.github.com/users/JohnTitor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "36ea7cd88c91547204d5f8e9016ee7a07890117c", "url": "https://api.github.com/repos/rust-lang/rust/commits/36ea7cd88c91547204d5f8e9016ee7a07890117c", "html_url": "https://github.com/rust-lang/rust/commit/36ea7cd88c91547204d5f8e9016ee7a07890117c"}, {"sha": "c278700af4bf75547e0b796fb56b489ad5b72046", "url": "https://api.github.com/repos/rust-lang/rust/commits/c278700af4bf75547e0b796fb56b489ad5b72046", "html_url": "https://github.com/rust-lang/rust/commit/c278700af4bf75547e0b796fb56b489ad5b72046"}], "stats": {"total": 263, "additions": 137, "deletions": 126}, "files": [{"sha": "f10ecf5f201e32e83b4c72e1583057a18922d7d5", "filename": "src/tools/tidy/src/features.rs", "status": "modified", "additions": 137, "deletions": 126, "changes": 263, "blob_url": "https://github.com/rust-lang/rust/blob/18b1342f236cac3893ecbf7fba0848e612e075a9/src%2Ftools%2Ftidy%2Fsrc%2Ffeatures.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18b1342f236cac3893ecbf7fba0848e612e075a9/src%2Ftools%2Ftidy%2Fsrc%2Ffeatures.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Ffeatures.rs?ref=18b1342f236cac3893ecbf7fba0848e612e075a9", "patch": "@@ -10,7 +10,7 @@\n //! * Language features in a group are sorted by feature name.\n \n use crate::walk::{filter_dirs, walk, walk_many};\n-use std::collections::HashMap;\n+use std::collections::hash_map::{Entry, HashMap};\n use std::fmt;\n use std::fs;\n use std::num::NonZeroU32;\n@@ -280,13 +280,14 @@ fn test_filen_gate(filen_underscore: &str, features: &mut Features) -> bool {\n }\n \n pub fn collect_lang_features(base_compiler_path: &Path, bad: &mut bool) -> Features {\n-    let mut all = collect_lang_features_in(base_compiler_path, \"active.rs\", bad);\n-    all.extend(collect_lang_features_in(base_compiler_path, \"accepted.rs\", bad));\n-    all.extend(collect_lang_features_in(base_compiler_path, \"removed.rs\", bad));\n-    all\n+    let mut features = Features::new();\n+    collect_lang_features_in(&mut features, base_compiler_path, \"active.rs\", bad);\n+    collect_lang_features_in(&mut features, base_compiler_path, \"accepted.rs\", bad);\n+    collect_lang_features_in(&mut features, base_compiler_path, \"removed.rs\", bad);\n+    features\n }\n \n-fn collect_lang_features_in(base: &Path, file: &str, bad: &mut bool) -> Features {\n+fn collect_lang_features_in(features: &mut Features, base: &Path, file: &str, bad: &mut bool) {\n     let path = base.join(\"rustc_feature\").join(\"src\").join(file);\n     let contents = t!(fs::read_to_string(&path));\n \n@@ -298,135 +299,145 @@ fn collect_lang_features_in(base: &Path, file: &str, bad: &mut bool) -> Features\n     let mut in_feature_group = false;\n     let mut prev_names = vec![];\n \n-    contents\n-        .lines()\n-        .zip(1..)\n-        .filter_map(|(line, line_number)| {\n-            let line = line.trim();\n-\n-            // Within -start and -end, the tracking issue can be omitted.\n-            match line {\n-                \"// no-tracking-issue-start\" => {\n-                    next_feature_omits_tracking_issue = true;\n-                    return None;\n-                }\n-                \"// no-tracking-issue-end\" => {\n-                    next_feature_omits_tracking_issue = false;\n-                    return None;\n-                }\n-                _ => {}\n+    let lines = contents.lines().zip(1..);\n+    for (line, line_number) in lines {\n+        let line = line.trim();\n+\n+        // Within -start and -end, the tracking issue can be omitted.\n+        match line {\n+            \"// no-tracking-issue-start\" => {\n+                next_feature_omits_tracking_issue = true;\n+                continue;\n             }\n+            \"// no-tracking-issue-end\" => {\n+                next_feature_omits_tracking_issue = false;\n+                continue;\n+            }\n+            _ => {}\n+        }\n \n-            if line.starts_with(FEATURE_GROUP_START_PREFIX) {\n-                if in_feature_group {\n-                    tidy_error!(\n-                        bad,\n-                        \"{}:{}: \\\n+        if line.starts_with(FEATURE_GROUP_START_PREFIX) {\n+            if in_feature_group {\n+                tidy_error!(\n+                    bad,\n+                    \"{}:{}: \\\n                         new feature group is started without ending the previous one\",\n-                        path.display(),\n-                        line_number,\n-                    );\n-                }\n-\n-                in_feature_group = true;\n-                prev_names = vec![];\n-                return None;\n-            } else if line.starts_with(FEATURE_GROUP_END_PREFIX) {\n-                in_feature_group = false;\n-                prev_names = vec![];\n-                return None;\n+                    path.display(),\n+                    line_number,\n+                );\n             }\n \n-            let mut parts = line.split(',');\n-            let level = match parts.next().map(|l| l.trim().trim_start_matches('(')) {\n-                Some(\"active\") => Status::Unstable,\n-                Some(\"incomplete\") => Status::Unstable,\n-                Some(\"removed\") => Status::Removed,\n-                Some(\"accepted\") => Status::Stable,\n-                _ => return None,\n-            };\n-            let name = parts.next().unwrap().trim();\n-\n-            let since_str = parts.next().unwrap().trim().trim_matches('\"');\n-            let since = match since_str.parse() {\n-                Ok(since) => Some(since),\n-                Err(err) => {\n-                    tidy_error!(\n-                        bad,\n-                        \"{}:{}: failed to parse since: {} ({:?})\",\n-                        path.display(),\n-                        line_number,\n-                        since_str,\n-                        err,\n-                    );\n-                    None\n-                }\n-            };\n-            if in_feature_group {\n-                if prev_names.last() > Some(&name) {\n-                    // This assumes the user adds the feature name at the end of the list, as we're\n-                    // not looking ahead.\n-                    let correct_index = match prev_names.binary_search(&name) {\n-                        Ok(_) => {\n-                            // This only occurs when the feature name has already been declared.\n-                            tidy_error!(\n-                                bad,\n-                                \"{}:{}: duplicate feature {}\",\n-                                path.display(),\n-                                line_number,\n-                                name,\n-                            );\n-                            // skip any additional checks for this line\n-                            return None;\n-                        }\n-                        Err(index) => index,\n-                    };\n+            in_feature_group = true;\n+            prev_names = vec![];\n+            continue;\n+        } else if line.starts_with(FEATURE_GROUP_END_PREFIX) {\n+            in_feature_group = false;\n+            prev_names = vec![];\n+            continue;\n+        }\n \n-                    let correct_placement = if correct_index == 0 {\n-                        \"at the beginning of the feature group\".to_owned()\n-                    } else if correct_index == prev_names.len() {\n-                        // I don't believe this is reachable given the above assumption, but it\n-                        // doesn't hurt to be safe.\n-                        \"at the end of the feature group\".to_owned()\n-                    } else {\n-                        format!(\n-                            \"between {} and {}\",\n-                            prev_names[correct_index - 1],\n-                            prev_names[correct_index],\n-                        )\n-                    };\n+        let mut parts = line.split(',');\n+        let level = match parts.next().map(|l| l.trim().trim_start_matches('(')) {\n+            Some(\"active\") => Status::Unstable,\n+            Some(\"incomplete\") => Status::Unstable,\n+            Some(\"removed\") => Status::Removed,\n+            Some(\"accepted\") => Status::Stable,\n+            _ => continue,\n+        };\n+        let name = parts.next().unwrap().trim();\n+\n+        let since_str = parts.next().unwrap().trim().trim_matches('\"');\n+        let since = match since_str.parse() {\n+            Ok(since) => Some(since),\n+            Err(err) => {\n+                tidy_error!(\n+                    bad,\n+                    \"{}:{}: failed to parse since: {} ({:?})\",\n+                    path.display(),\n+                    line_number,\n+                    since_str,\n+                    err,\n+                );\n+                None\n+            }\n+        };\n+        if in_feature_group {\n+            if prev_names.last() > Some(&name) {\n+                // This assumes the user adds the feature name at the end of the list, as we're\n+                // not looking ahead.\n+                let correct_index = match prev_names.binary_search(&name) {\n+                    Ok(_) => {\n+                        // This only occurs when the feature name has already been declared.\n+                        tidy_error!(\n+                            bad,\n+                            \"{}:{}: duplicate feature {}\",\n+                            path.display(),\n+                            line_number,\n+                            name,\n+                        );\n+                        // skip any additional checks for this line\n+                        continue;\n+                    }\n+                    Err(index) => index,\n+                };\n \n-                    tidy_error!(\n-                        bad,\n-                        \"{}:{}: feature {} is not sorted by feature name (should be {})\",\n-                        path.display(),\n-                        line_number,\n-                        name,\n-                        correct_placement,\n-                    );\n-                }\n-                prev_names.push(name);\n+                let correct_placement = if correct_index == 0 {\n+                    \"at the beginning of the feature group\".to_owned()\n+                } else if correct_index == prev_names.len() {\n+                    // I don't believe this is reachable given the above assumption, but it\n+                    // doesn't hurt to be safe.\n+                    \"at the end of the feature group\".to_owned()\n+                } else {\n+                    format!(\n+                        \"between {} and {}\",\n+                        prev_names[correct_index - 1],\n+                        prev_names[correct_index],\n+                    )\n+                };\n+\n+                tidy_error!(\n+                    bad,\n+                    \"{}:{}: feature {} is not sorted by feature name (should be {})\",\n+                    path.display(),\n+                    line_number,\n+                    name,\n+                    correct_placement,\n+                );\n             }\n+            prev_names.push(name);\n+        }\n \n-            let issue_str = parts.next().unwrap().trim();\n-            let tracking_issue = if issue_str.starts_with(\"None\") {\n-                if level == Status::Unstable && !next_feature_omits_tracking_issue {\n-                    tidy_error!(\n-                        bad,\n-                        \"{}:{}: no tracking issue for feature {}\",\n-                        path.display(),\n-                        line_number,\n-                        name,\n-                    );\n-                }\n-                None\n-            } else {\n-                let s = issue_str.split('(').nth(1).unwrap().split(')').next().unwrap();\n-                Some(s.parse().unwrap())\n-            };\n-            Some((name.to_owned(), Feature { level, since, has_gate_test: false, tracking_issue }))\n-        })\n-        .collect()\n+        let issue_str = parts.next().unwrap().trim();\n+        let tracking_issue = if issue_str.starts_with(\"None\") {\n+            if level == Status::Unstable && !next_feature_omits_tracking_issue {\n+                tidy_error!(\n+                    bad,\n+                    \"{}:{}: no tracking issue for feature {}\",\n+                    path.display(),\n+                    line_number,\n+                    name,\n+                );\n+            }\n+            None\n+        } else {\n+            let s = issue_str.split('(').nth(1).unwrap().split(')').next().unwrap();\n+            Some(s.parse().unwrap())\n+        };\n+        match features.entry(name.to_owned()) {\n+            Entry::Occupied(e) => {\n+                tidy_error!(\n+                    bad,\n+                    \"{}:{} feature {name} already specified with status '{}'\",\n+                    path.display(),\n+                    line_number,\n+                    e.get().level,\n+                );\n+            }\n+            Entry::Vacant(e) => {\n+                e.insert(Feature { level, since, has_gate_test: false, tracking_issue });\n+            }\n+        }\n+    }\n }\n \n fn get_and_check_lib_features("}]}