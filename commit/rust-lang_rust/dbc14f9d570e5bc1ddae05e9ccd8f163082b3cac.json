{"sha": "dbc14f9d570e5bc1ddae05e9ccd8f163082b3cac", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRiYzE0ZjlkNTcwZTViYzFkZGFlMDVlOWNjZDhmMTYzMDgyYjNjYWM=", "commit": {"author": {"name": "Florian Diebold", "email": "florian.diebold@freiheit.com", "date": "2020-01-31T14:17:48Z"}, "committer": {"name": "Florian Diebold", "email": "florian.diebold@freiheit.com", "date": "2020-02-07T17:28:10Z"}, "message": "First stab at desugaring bounds for APIT", "tree": {"sha": "adde2b49413960c2741b18402a6cb5757b346804", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/adde2b49413960c2741b18402a6cb5757b346804"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dbc14f9d570e5bc1ddae05e9ccd8f163082b3cac", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dbc14f9d570e5bc1ddae05e9ccd8f163082b3cac", "html_url": "https://github.com/rust-lang/rust/commit/dbc14f9d570e5bc1ddae05e9ccd8f163082b3cac", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dbc14f9d570e5bc1ddae05e9ccd8f163082b3cac/comments", "author": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a9430865b319ab2fc28602fe98df21146e54b7bf", "url": "https://api.github.com/repos/rust-lang/rust/commits/a9430865b319ab2fc28602fe98df21146e54b7bf", "html_url": "https://github.com/rust-lang/rust/commit/a9430865b319ab2fc28602fe98df21146e54b7bf"}], "stats": {"total": 66, "additions": 56, "deletions": 10}, "files": [{"sha": "e4e616519ba2bad55a21cd1ed8b0eee1e4013638", "filename": "crates/ra_hir_def/src/generics.rs", "status": "modified", "additions": 23, "deletions": 4, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/dbc14f9d570e5bc1ddae05e9ccd8f163082b3cac/crates%2Fra_hir_def%2Fsrc%2Fgenerics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbc14f9d570e5bc1ddae05e9ccd8f163082b3cac/crates%2Fra_hir_def%2Fsrc%2Fgenerics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fgenerics.rs?ref=dbc14f9d570e5bc1ddae05e9ccd8f163082b3cac", "patch": "@@ -53,10 +53,17 @@ pub struct GenericParams {\n /// associated type bindings like `Iterator<Item = u32>`.\n #[derive(Clone, PartialEq, Eq, Debug)]\n pub struct WherePredicate {\n-    pub type_ref: TypeRef,\n+    pub target: WherePredicateTarget,\n     pub bound: TypeBound,\n }\n \n+#[derive(Clone, PartialEq, Eq, Debug)]\n+pub enum WherePredicateTarget {\n+    TypeRef(TypeRef),\n+    /// For desugared where predicates that can directly refer to a type param.\n+    TypeParam(LocalTypeParamId)\n+}\n+\n type SourceMap = ArenaMap<LocalTypeParamId, Either<ast::TraitDef, ast::TypeParam>>;\n \n impl GenericParams {\n@@ -190,18 +197,24 @@ impl GenericParams {\n             return;\n         }\n         let bound = TypeBound::from_ast(bound);\n-        self.where_predicates.push(WherePredicate { type_ref, bound });\n+        self.where_predicates.push(WherePredicate { target: WherePredicateTarget::TypeRef(type_ref), bound });\n     }\n \n     fn fill_implicit_impl_trait_args(&mut self, type_ref: &TypeRef) {\n         type_ref.walk(&mut |type_ref| {\n-            if let TypeRef::ImplTrait(_) = type_ref {\n+            if let TypeRef::ImplTrait(bounds) = type_ref {\n                 let param = TypeParamData {\n                     name: None,\n                     default: None,\n                     provenance: TypeParamProvenance::ArgumentImplTrait,\n                 };\n-                let _param_id = self.types.alloc(param);\n+                let param_id = self.types.alloc(param);\n+                for bound in bounds {\n+                    self.where_predicates.push(WherePredicate {\n+                        target: WherePredicateTarget::TypeParam(param_id),\n+                        bound: bound.clone()\n+                    });\n+                }\n             }\n         });\n     }\n@@ -211,6 +224,12 @@ impl GenericParams {\n             .iter()\n             .find_map(|(id, p)| if p.name.as_ref() == Some(name) { Some(id) } else { None })\n     }\n+\n+    pub fn find_trait_self_param(&self) -> Option<LocalTypeParamId> {\n+        self.types\n+            .iter()\n+            .find_map(|(id, p)| if p.provenance == TypeParamProvenance::TraitSelf { Some(id) } else { None })\n+    }\n }\n \n impl HasChildSource for GenericDefId {"}, {"sha": "f1a11e07351c29c00457cb5ecaf0698a5f79cc71", "filename": "crates/ra_hir_ty/src/lower.rs", "status": "modified", "additions": 26, "deletions": 3, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/dbc14f9d570e5bc1ddae05e9ccd8f163082b3cac/crates%2Fra_hir_ty%2Fsrc%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbc14f9d570e5bc1ddae05e9ccd8f163082b3cac/crates%2Fra_hir_ty%2Fsrc%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Flower.rs?ref=dbc14f9d570e5bc1ddae05e9ccd8f163082b3cac", "patch": "@@ -10,7 +10,7 @@ use std::sync::Arc;\n \n use hir_def::{\n     builtin_type::BuiltinType,\n-    generics::WherePredicate,\n+    generics::{WherePredicateTarget, WherePredicate},\n     path::{GenericArg, Path, PathSegment, PathSegments},\n     resolver::{HasResolver, Resolver, TypeNs},\n     type_ref::{TypeBound, TypeRef},\n@@ -505,7 +505,22 @@ impl GenericPredicate {\n         ctx: &'a TyLoweringContext<'a, impl HirDatabase>,\n         where_predicate: &'a WherePredicate,\n     ) -> impl Iterator<Item = GenericPredicate> + 'a {\n-        let self_ty = Ty::from_hir(ctx, &where_predicate.type_ref);\n+        let self_ty = match &where_predicate.target {\n+            WherePredicateTarget::TypeRef(type_ref) => Ty::from_hir(ctx, type_ref),\n+            WherePredicateTarget::TypeParam(param_id) => {\n+                let generic_def = ctx.resolver.generic_def().expect(\"generics in scope\");\n+                let generics = generics(ctx.db, generic_def);\n+                let param_id = hir_def::TypeParamId { parent: generic_def, local_id: *param_id };\n+                let idx = generics.param_idx(param_id);\n+                match ctx.type_param_mode {\n+                    TypeParamLoweringMode::Placeholder => {\n+                        let name = generics.param_name(param_id);\n+                        Ty::Param { idx, name }\n+                    },\n+                    TypeParamLoweringMode::Variable => Ty::Bound(idx),\n+                }\n+            },\n+        };\n         GenericPredicate::from_type_bound(ctx, &where_predicate.bound, self_ty)\n     }\n \n@@ -595,10 +610,18 @@ pub(crate) fn generic_predicates_for_param_query(\n ) -> Arc<[GenericPredicate]> {\n     let resolver = def.resolver(db);\n     let ctx = TyLoweringContext::new(db, &resolver);\n+    let generics = generics(db, def);\n     resolver\n         .where_predicates_in_scope()\n         // we have to filter out all other predicates *first*, before attempting to lower them\n-        .filter(|pred| Ty::from_hir_only_param(&ctx, &pred.type_ref) == Some(param_idx))\n+        .filter(|pred| match &pred.target {\n+            WherePredicateTarget::TypeRef(type_ref) => Ty::from_hir_only_param(&ctx, type_ref) == Some(param_idx),\n+            WherePredicateTarget::TypeParam(local_id) => {\n+                let param_id = hir_def::TypeParamId { parent: def, local_id: *local_id };\n+                let idx = generics.param_idx(param_id);\n+                idx == param_idx\n+            }\n+        })\n         .flat_map(|pred| GenericPredicate::from_where_predicate(&ctx, pred))\n         .collect()\n }"}, {"sha": "77b7de729713da8c0d8b2b0081d7cb225d7bd248", "filename": "crates/ra_hir_ty/src/utils.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/dbc14f9d570e5bc1ddae05e9ccd8f163082b3cac/crates%2Fra_hir_ty%2Fsrc%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbc14f9d570e5bc1ddae05e9ccd8f163082b3cac/crates%2Fra_hir_ty%2Fsrc%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Futils.rs?ref=dbc14f9d570e5bc1ddae05e9ccd8f163082b3cac", "patch": "@@ -12,18 +12,22 @@ use hir_def::{\n     AssocContainerId, GenericDefId, Lookup, TraitId, TypeAliasId, TypeParamId, VariantId,\n };\n use hir_expand::name::{name, Name};\n+use hir_def::generics::WherePredicateTarget;\n \n fn direct_super_traits(db: &impl DefDatabase, trait_: TraitId) -> Vec<TraitId> {\n     let resolver = trait_.resolver(db);\n     // returning the iterator directly doesn't easily work because of\n     // lifetime problems, but since there usually shouldn't be more than a\n     // few direct traits this should be fine (we could even use some kind of\n     // SmallVec if performance is a concern)\n-    db.generic_params(trait_.into())\n+    let generic_params = db.generic_params(trait_.into());\n+    let trait_self = generic_params.find_trait_self_param();\n+    generic_params\n         .where_predicates\n         .iter()\n-        .filter_map(|pred| match &pred.type_ref {\n-            TypeRef::Path(p) if p == &Path::from(name![Self]) => pred.bound.as_path(),\n+        .filter_map(|pred| match &pred.target {\n+            WherePredicateTarget::TypeRef(TypeRef::Path(p)) if p == &Path::from(name![Self]) => pred.bound.as_path(),\n+            WherePredicateTarget::TypeParam(local_id) if Some(*local_id) == trait_self => pred.bound.as_path(),\n             _ => None,\n         })\n         .filter_map(|path| match resolver.resolve_path_in_type_ns_fully(db, path.mod_path()) {"}]}