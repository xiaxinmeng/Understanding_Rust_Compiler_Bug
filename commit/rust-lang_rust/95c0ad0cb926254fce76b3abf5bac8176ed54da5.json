{"sha": "95c0ad0cb926254fce76b3abf5bac8176ed54da5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk1YzBhZDBjYjkyNjI1NGZjZTc2YjNhYmY1YmFjODE3NmVkNTRkYTU=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-12-12T23:57:56Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-12-12T23:57:56Z"}, "message": "rustc: unpack newtyped of #[repr(simd)] vector types.", "tree": {"sha": "55f2a1f044716a01d03b753aad6f757c8cdcba0d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/55f2a1f044716a01d03b753aad6f757c8cdcba0d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/95c0ad0cb926254fce76b3abf5bac8176ed54da5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/95c0ad0cb926254fce76b3abf5bac8176ed54da5", "html_url": "https://github.com/rust-lang/rust/commit/95c0ad0cb926254fce76b3abf5bac8176ed54da5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/95c0ad0cb926254fce76b3abf5bac8176ed54da5/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "707d0708158dabd9b0a12af21a4b51bf1713cb9e", "url": "https://api.github.com/repos/rust-lang/rust/commits/707d0708158dabd9b0a12af21a4b51bf1713cb9e", "html_url": "https://github.com/rust-lang/rust/commit/707d0708158dabd9b0a12af21a4b51bf1713cb9e"}], "stats": {"total": 185, "additions": 98, "deletions": 87}, "files": [{"sha": "9ae647c97d28f8deaa1a44ca9b143e09055d46cc", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 28, "deletions": 14, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/95c0ad0cb926254fce76b3abf5bac8176ed54da5/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95c0ad0cb926254fce76b3abf5bac8176ed54da5/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=95c0ad0cb926254fce76b3abf5bac8176ed54da5", "patch": "@@ -758,7 +758,10 @@ pub enum Abi {\n     Uninhabited,\n     Scalar(Scalar),\n     ScalarPair(Scalar, Scalar),\n-    Vector,\n+    Vector {\n+        element: Scalar,\n+        count: u64\n+    },\n     Aggregate {\n         /// If true, the size is exact, otherwise it's only a lower bound.\n         sized: bool,\n@@ -773,7 +776,7 @@ impl Abi {\n             Abi::Uninhabited |\n             Abi::Scalar(_) |\n             Abi::ScalarPair(..) |\n-            Abi::Vector => false,\n+            Abi::Vector { .. } => false,\n             Abi::Aggregate { sized, .. } => !sized\n         }\n     }\n@@ -784,7 +787,7 @@ impl Abi {\n             Abi::Uninhabited |\n             Abi::Scalar(_) |\n             Abi::ScalarPair(..) |\n-            Abi::Vector => false,\n+            Abi::Vector { .. } => false,\n             Abi::Aggregate { packed, .. } => packed\n         }\n     }\n@@ -1083,9 +1086,9 @@ impl<'a, 'tcx> LayoutDetails {\n                                align.abi() == field.align.abi() &&\n                                size == field.size {\n                                 match field.abi {\n-                                    // For plain scalars we can't unpack newtypes\n-                                    // for `#[repr(C)]`, as that affects C ABIs.\n-                                    Abi::Scalar(_) if optimize => {\n+                                    // For plain scalars, or vectors of them, we can't unpack\n+                                    // newtypes for `#[repr(C)]`, as that affects C ABIs.\n+                                    Abi::Scalar(_) | Abi::Vector { .. } if optimize => {\n                                         abi = field.abi.clone();\n                                     }\n                                     // But scalar pairs are Rust-specific and get\n@@ -1320,16 +1323,17 @@ impl<'a, 'tcx> LayoutDetails {\n \n             // SIMD vector types.\n             ty::TyAdt(def, ..) if def.repr.simd() => {\n-                let count = ty.simd_size(tcx) as u64;\n                 let element = cx.layout_of(ty.simd_type(tcx))?;\n-                match element.abi {\n-                    Abi::Scalar(_) => {}\n+                let count = ty.simd_size(tcx) as u64;\n+                assert!(count > 0);\n+                let scalar = match element.abi {\n+                    Abi::Scalar(ref scalar) => scalar.clone(),\n                     _ => {\n                         tcx.sess.fatal(&format!(\"monomorphising SIMD type `{}` with \\\n                                                 a non-machine element type `{}`\",\n                                                 ty, element.ty));\n                     }\n-                }\n+                };\n                 let size = element.size.checked_mul(count, dl)\n                     .ok_or(LayoutError::SizeOverflow(ty))?;\n                 let align = dl.vector_align(size);\n@@ -1341,7 +1345,10 @@ impl<'a, 'tcx> LayoutDetails {\n                         stride: element.size,\n                         count\n                     },\n-                    abi: Abi::Vector,\n+                    abi: Abi::Vector {\n+                        element: scalar,\n+                        count\n+                    },\n                     size,\n                     align,\n                 })\n@@ -2266,8 +2273,9 @@ impl<'a, 'tcx> TyLayout<'tcx> {\n     pub fn is_zst(&self) -> bool {\n         match self.abi {\n             Abi::Uninhabited => true,\n-            Abi::Scalar(_) | Abi::ScalarPair(..) => false,\n-            Abi::Vector => self.size.bytes() == 0,\n+            Abi::Scalar(_) |\n+            Abi::ScalarPair(..) |\n+            Abi::Vector { .. } => false,\n             Abi::Aggregate { sized, .. } => sized && self.size.bytes() == 0\n         }\n     }\n@@ -2322,6 +2330,9 @@ impl<'a, 'tcx> TyLayout<'tcx> {\n                     scalar_component(b, a.value.size(cx).abi_align(b.value.align(cx)))\n                 }));\n             }\n+            Abi::Vector { ref element, .. } => {\n+                return Ok(scalar_component(element, Size::from_bytes(0)));\n+            }\n             _ => {}\n         }\n \n@@ -2424,7 +2435,10 @@ impl<'gcx> HashStable<StableHashingContext<'gcx>> for Abi {\n                 a.hash_stable(hcx, hasher);\n                 b.hash_stable(hcx, hasher);\n             }\n-            Vector => {}\n+            Vector { ref element, count } => {\n+                element.hash_stable(hcx, hasher);\n+                count.hash_stable(hcx, hasher);\n+            }\n             Aggregate { packed, sized } => {\n                 packed.hash_stable(hcx, hasher);\n                 sized.hash_stable(hcx, hasher);"}, {"sha": "29905184001663e84c274895bec3a273786c980a", "filename": "src/librustc_trans/abi.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/95c0ad0cb926254fce76b3abf5bac8176ed54da5/src%2Flibrustc_trans%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95c0ad0cb926254fce76b3abf5bac8176ed54da5/src%2Flibrustc_trans%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fabi.rs?ref=95c0ad0cb926254fce76b3abf5bac8176ed54da5", "patch": "@@ -315,7 +315,7 @@ impl<'tcx> LayoutExt<'tcx> for TyLayout<'tcx> {\n         match self.abi {\n             layout::Abi::Uninhabited |\n             layout::Abi::Scalar(_) |\n-            layout::Abi::Vector => false,\n+            layout::Abi::Vector { .. } => false,\n             layout::Abi::ScalarPair(..) |\n             layout::Abi::Aggregate { .. } => true\n         }\n@@ -339,7 +339,7 @@ impl<'tcx> LayoutExt<'tcx> for TyLayout<'tcx> {\n                 })\n             }\n \n-            layout::Abi::Vector => {\n+            layout::Abi::Vector { .. } => {\n                 Some(Reg {\n                     kind: RegKind::Vector,\n                     size: self.size"}, {"sha": "7c9f257469370d84ccba9cdb561a349aca189f5f", "filename": "src/librustc_trans/cabi_x86_64.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/95c0ad0cb926254fce76b3abf5bac8176ed54da5/src%2Flibrustc_trans%2Fcabi_x86_64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95c0ad0cb926254fce76b3abf5bac8176ed54da5/src%2Flibrustc_trans%2Fcabi_x86_64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_x86_64.rs?ref=95c0ad0cb926254fce76b3abf5bac8176ed54da5", "patch": "@@ -77,13 +77,14 @@ fn classify_arg<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, arg: &ArgType<'tcx>)\n                 unify(cls, off, reg);\n             }\n \n-            layout::Abi::Vector => {\n+            layout::Abi::Vector { ref element, count } => {\n                 unify(cls, off, Class::Sse);\n \n                 // everything after the first one is the upper\n                 // half of a register.\n-                for i in 1..layout.fields.count() {\n-                    let field_off = off + layout.fields.offset(i);\n+                let stride = element.value.size(ccx);\n+                for i in 1..count {\n+                    let field_off = off + stride * i;\n                     unify(cls, field_off, Class::SseUp);\n                 }\n             }"}, {"sha": "eb5ec4034904bff72117186a11228acdbe73fe0b", "filename": "src/librustc_trans/cabi_x86_win64.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/95c0ad0cb926254fce76b3abf5bac8176ed54da5/src%2Flibrustc_trans%2Fcabi_x86_win64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95c0ad0cb926254fce76b3abf5bac8176ed54da5/src%2Flibrustc_trans%2Fcabi_x86_win64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_x86_win64.rs?ref=95c0ad0cb926254fce76b3abf5bac8176ed54da5", "patch": "@@ -28,7 +28,7 @@ pub fn compute_abi_info(fty: &mut FnType) {\n                     _ => a.make_indirect()\n                 }\n             }\n-            layout::Abi::Vector => {\n+            layout::Abi::Vector { .. } => {\n                 // FIXME(eddyb) there should be a size cap here\n                 // (probably what clang calls \"illegal vectors\").\n             }"}, {"sha": "5521d842c9531fe4bdbf6eac0b0f5ef78b23d386", "filename": "src/librustc_trans/mir/constant.rs", "status": "modified", "additions": 17, "deletions": 12, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/95c0ad0cb926254fce76b3abf5bac8176ed54da5/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95c0ad0cb926254fce76b3abf5bac8176ed54da5/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fconstant.rs?ref=95c0ad0cb926254fce76b3abf5bac8176ed54da5", "patch": "@@ -122,17 +122,17 @@ impl<'a, 'tcx> Const<'tcx> {\n         if field.is_zst() {\n             return C_undef(field.immediate_llvm_type(ccx));\n         }\n+        let offset = layout.fields.offset(i);\n         match layout.abi {\n-            layout::Abi::Scalar(_) => self.llval,\n+            layout::Abi::Scalar(_) |\n+            layout::Abi::ScalarPair(..) |\n+            layout::Abi::Vector { .. }\n+                if offset.bytes() == 0 && field.size == layout.size => self.llval,\n+\n             layout::Abi::ScalarPair(ref a, ref b) => {\n-                let offset = layout.fields.offset(i);\n                 if offset.bytes() == 0 {\n-                    if field.size == layout.size {\n-                        self.llval\n-                    } else {\n-                        assert_eq!(field.size, a.value.size(ccx));\n-                        const_get_elt(self.llval, 0)\n-                    }\n+                    assert_eq!(field.size, a.value.size(ccx));\n+                    const_get_elt(self.llval, 0)\n                 } else {\n                     assert_eq!(offset, a.value.size(ccx)\n                         .abi_align(b.value.align(ccx)));\n@@ -1131,9 +1131,7 @@ fn trans_const_adt<'a, 'tcx>(\n     match l.variants {\n         layout::Variants::Single { index } => {\n             assert_eq!(variant_index, index);\n-            if let layout::Abi::Vector = l.abi {\n-                Const::new(C_vector(&vals.iter().map(|x| x.llval).collect::<Vec<_>>()), t)\n-            } else if let layout::FieldPlacement::Union(_) = l.fields {\n+            if let layout::FieldPlacement::Union(_) = l.fields {\n                 assert_eq!(variant_index, 0);\n                 assert_eq!(vals.len(), 1);\n                 let contents = [\n@@ -1143,6 +1141,12 @@ fn trans_const_adt<'a, 'tcx>(\n \n                 Const::new(C_struct(ccx, &contents, l.is_packed()), t)\n             } else {\n+                if let layout::Abi::Vector { .. } = l.abi {\n+                    if let layout::FieldPlacement::Array { .. } = l.fields {\n+                        return Const::new(C_vector(&vals.iter().map(|x| x.llval)\n+                            .collect::<Vec<_>>()), t);\n+                    }\n+                }\n                 build_const_struct(ccx, l, vals, None)\n             }\n         }\n@@ -1206,7 +1210,8 @@ fn build_const_struct<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n \n     match layout.abi {\n         layout::Abi::Scalar(_) |\n-        layout::Abi::ScalarPair(..) if discr.is_none() => {\n+        layout::Abi::ScalarPair(..) |\n+        layout::Abi::Vector { .. } if discr.is_none() => {\n             let mut non_zst_fields = vals.iter().enumerate().map(|(i, f)| {\n                 (f, layout.fields.offset(i))\n             }).filter(|&(f, _)| !ccx.layout_of(f.ty).is_zst());"}, {"sha": "38817817552045ffd2e920f6d745fd125c3e9bdd", "filename": "src/librustc_trans/mir/operand.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/95c0ad0cb926254fce76b3abf5bac8176ed54da5/src%2Flibrustc_trans%2Fmir%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95c0ad0cb926254fce76b3abf5bac8176ed54da5/src%2Flibrustc_trans%2Fmir%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Foperand.rs?ref=95c0ad0cb926254fce76b3abf5bac8176ed54da5", "patch": "@@ -163,7 +163,7 @@ impl<'a, 'tcx> OperandRef<'tcx> {\n                 };\n             }\n \n-            // Newtype of a scalar or scalar pair.\n+            // Newtype of a scalar, scalar pair or vector.\n             (OperandValue::Immediate(_), _) |\n             (OperandValue::Pair(..), _) if field.size == self.layout.size => {\n                 assert_eq!(offset.bytes(), 0);\n@@ -184,7 +184,7 @@ impl<'a, 'tcx> OperandRef<'tcx> {\n             }\n \n             // `#[repr(simd)]` types are also immediate.\n-            (OperandValue::Immediate(llval), &layout::Abi::Vector) => {\n+            (OperandValue::Immediate(llval), &layout::Abi::Vector { .. }) => {\n                 OperandValue::Immediate(\n                     bcx.extract_element(llval, C_usize(bcx.ccx, i as u64)))\n             }"}, {"sha": "690b990c8b464b2c06e0d5a54274241a68ce743f", "filename": "src/librustc_trans/type_of.rs", "status": "modified", "additions": 44, "deletions": 53, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/95c0ad0cb926254fce76b3abf5bac8176ed54da5/src%2Flibrustc_trans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95c0ad0cb926254fce76b3abf5bac8176ed54da5/src%2Flibrustc_trans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftype_of.rs?ref=95c0ad0cb926254fce76b3abf5bac8176ed54da5", "patch": "@@ -25,23 +25,22 @@ fn uncached_llvm_type<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                 -> Type {\n     match layout.abi {\n         layout::Abi::Scalar(_) => bug!(\"handled elsewhere\"),\n-        layout::Abi::Vector => {\n+        layout::Abi::Vector { ref element, count } => {\n             // LLVM has a separate type for 64-bit SIMD vectors on X86 called\n             // `x86_mmx` which is needed for some SIMD operations. As a bit of a\n             // hack (all SIMD definitions are super unstable anyway) we\n             // recognize any one-element SIMD vector as \"this should be an\n             // x86_mmx\" type. In general there shouldn't be a need for other\n             // one-element SIMD vectors, so it's assumed this won't clash with\n             // much else.\n-            let use_x86_mmx = layout.fields.count() == 1 &&\n-                layout.size.bits() == 64 &&\n+            let use_x86_mmx = count == 1 && layout.size.bits() == 64 &&\n                 (ccx.sess().target.target.arch == \"x86\" ||\n                  ccx.sess().target.target.arch == \"x86_64\");\n             if use_x86_mmx {\n                 return Type::x86_mmx(ccx)\n             } else {\n-                return Type::vector(&layout.field(ccx, 0).llvm_type(ccx),\n-                                    layout.fields.count() as u64);\n+                let element = layout.scalar_llvm_type_at(ccx, element, Size::from_bytes(0));\n+                return Type::vector(&element, count);\n             }\n         }\n         layout::Abi::ScalarPair(..) => {\n@@ -198,6 +197,8 @@ pub trait LayoutLlvmExt<'tcx> {\n     fn is_llvm_scalar_pair<'a>(&self) -> bool;\n     fn llvm_type<'a>(&self, ccx: &CrateContext<'a, 'tcx>) -> Type;\n     fn immediate_llvm_type<'a>(&self, ccx: &CrateContext<'a, 'tcx>) -> Type;\n+    fn scalar_llvm_type_at<'a>(&self, ccx: &CrateContext<'a, 'tcx>,\n+                               scalar: &layout::Scalar, offset: Size) -> Type;\n     fn scalar_pair_element_llvm_type<'a>(&self, ccx: &CrateContext<'a, 'tcx>,\n                                          index: usize) -> Type;\n     fn llvm_field_index(&self, index: usize) -> u64;\n@@ -210,7 +211,7 @@ impl<'tcx> LayoutLlvmExt<'tcx> for TyLayout<'tcx> {\n         match self.abi {\n             layout::Abi::Uninhabited |\n             layout::Abi::Scalar(_) |\n-            layout::Abi::Vector => true,\n+            layout::Abi::Vector { .. } => true,\n             layout::Abi::ScalarPair(..) => false,\n             layout::Abi::Aggregate { .. } => self.is_zst()\n         }\n@@ -221,7 +222,7 @@ impl<'tcx> LayoutLlvmExt<'tcx> for TyLayout<'tcx> {\n             layout::Abi::ScalarPair(..) => true,\n             layout::Abi::Uninhabited |\n             layout::Abi::Scalar(_) |\n-            layout::Abi::Vector |\n+            layout::Abi::Vector { .. } |\n             layout::Abi::Aggregate { .. } => false\n         }\n     }\n@@ -244,34 +245,19 @@ impl<'tcx> LayoutLlvmExt<'tcx> for TyLayout<'tcx> {\n             if let Some(&llty) = ccx.scalar_lltypes().borrow().get(&self.ty) {\n                 return llty;\n             }\n-            let llty = match scalar.value {\n-                layout::Int(i, _) => Type::from_integer(ccx, i),\n-                layout::F32 => Type::f32(ccx),\n-                layout::F64 => Type::f64(ccx),\n-                layout::Pointer => {\n-                    let pointee = match self.ty.sty {\n-                        ty::TyRef(_, ty::TypeAndMut { ty, .. }) |\n-                        ty::TyRawPtr(ty::TypeAndMut { ty, .. }) => {\n-                            ccx.layout_of(ty).llvm_type(ccx)\n-                        }\n-                        ty::TyAdt(def, _) if def.is_box() => {\n-                            ccx.layout_of(self.ty.boxed_ty()).llvm_type(ccx)\n-                        }\n-                        ty::TyFnPtr(sig) => {\n-                            let sig = ccx.tcx().erase_late_bound_regions_and_normalize(&sig);\n-                            FnType::new(ccx, sig, &[]).llvm_type(ccx)\n-                        }\n-                        _ => {\n-                            // If we know the alignment, pick something better than i8.\n-                            if let Some(pointee) = self.pointee_info_at(ccx, Size::from_bytes(0)) {\n-                                Type::pointee_for_abi_align(ccx, pointee.align)\n-                            } else {\n-                                Type::i8(ccx)\n-                            }\n-                        }\n-                    };\n-                    pointee.ptr_to()\n+            let llty = match self.ty.sty {\n+                ty::TyRef(_, ty::TypeAndMut { ty, .. }) |\n+                ty::TyRawPtr(ty::TypeAndMut { ty, .. }) => {\n+                    ccx.layout_of(ty).llvm_type(ccx).ptr_to()\n+                }\n+                ty::TyAdt(def, _) if def.is_box() => {\n+                    ccx.layout_of(self.ty.boxed_ty()).llvm_type(ccx).ptr_to()\n                 }\n+                ty::TyFnPtr(sig) => {\n+                    let sig = ccx.tcx().erase_late_bound_regions_and_normalize(&sig);\n+                    FnType::new(ccx, sig, &[]).llvm_type(ccx).ptr_to()\n+                }\n+                _ => self.scalar_llvm_type_at(ccx, scalar, Size::from_bytes(0))\n             };\n             ccx.scalar_lltypes().borrow_mut().insert(self.ty, llty);\n             return llty;\n@@ -325,6 +311,24 @@ impl<'tcx> LayoutLlvmExt<'tcx> for TyLayout<'tcx> {\n         self.llvm_type(ccx)\n     }\n \n+    fn scalar_llvm_type_at<'a>(&self, ccx: &CrateContext<'a, 'tcx>,\n+                               scalar: &layout::Scalar, offset: Size) -> Type {\n+        match scalar.value {\n+            layout::Int(i, _) => Type::from_integer(ccx, i),\n+            layout::F32 => Type::f32(ccx),\n+            layout::F64 => Type::f64(ccx),\n+            layout::Pointer => {\n+                // If we know the alignment, pick something better than i8.\n+                let pointee = if let Some(pointee) = self.pointee_info_at(ccx, offset) {\n+                    Type::pointee_for_abi_align(ccx, pointee.align)\n+                } else {\n+                    Type::i8(ccx)\n+                };\n+                pointee.ptr_to()\n+            }\n+        }\n+    }\n+\n     fn scalar_pair_element_llvm_type<'a>(&self, ccx: &CrateContext<'a, 'tcx>,\n                                          index: usize) -> Type {\n         // HACK(eddyb) special-case fat pointers until LLVM removes\n@@ -358,25 +362,12 @@ impl<'tcx> LayoutLlvmExt<'tcx> for TyLayout<'tcx> {\n             return Type::i1(ccx);\n         }\n \n-        match scalar.value {\n-            layout::Int(i, _) => Type::from_integer(ccx, i),\n-            layout::F32 => Type::f32(ccx),\n-            layout::F64 => Type::f64(ccx),\n-            layout::Pointer => {\n-                // If we know the alignment, pick something better than i8.\n-                let offset = if index == 0 {\n-                    Size::from_bytes(0)\n-                } else {\n-                    a.value.size(ccx).abi_align(b.value.align(ccx))\n-                };\n-                let pointee = if let Some(pointee) = self.pointee_info_at(ccx, offset) {\n-                    Type::pointee_for_abi_align(ccx, pointee.align)\n-                } else {\n-                    Type::i8(ccx)\n-                };\n-                pointee.ptr_to()\n-            }\n-        }\n+        let offset = if index == 0 {\n+            Size::from_bytes(0)\n+        } else {\n+            a.value.size(ccx).abi_align(b.value.align(ccx))\n+        };\n+        self.scalar_llvm_type_at(ccx, scalar, offset)\n     }\n \n     fn llvm_field_index(&self, index: usize) -> u64 {"}]}