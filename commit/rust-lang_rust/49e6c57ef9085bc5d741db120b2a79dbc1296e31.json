{"sha": "49e6c57ef9085bc5d741db120b2a79dbc1296e31", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ5ZTZjNTdlZjkwODViYzVkNzQxZGIxMjBiMmE3OWRiYzEyOTZlMzE=", "commit": {"author": {"name": "Scott Olson", "email": "scott@solson.me", "date": "2016-10-16T05:31:42Z"}, "committer": {"name": "Scott Olson", "email": "scott@solson.me", "date": "2016-10-16T05:31:42Z"}, "message": "Do not pre-allocate local variables.\n\nThanks to the `Value` locals refactoring, now primitive locals (ints,\nfloats, chars, bools, and the like) will not require `Allocation`s at\nall, and locals that are never initialized at all because of conditional\ncontrol flow won't be wasting memory.", "tree": {"sha": "c3a6e473d7dca42c3a764962cd1b1123ade4a44f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c3a6e473d7dca42c3a764962cd1b1123ade4a44f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/49e6c57ef9085bc5d741db120b2a79dbc1296e31", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/49e6c57ef9085bc5d741db120b2a79dbc1296e31", "html_url": "https://github.com/rust-lang/rust/commit/49e6c57ef9085bc5d741db120b2a79dbc1296e31", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/49e6c57ef9085bc5d741db120b2a79dbc1296e31/comments", "author": {"login": "solson", "id": 26806, "node_id": "MDQ6VXNlcjI2ODA2", "avatar_url": "https://avatars.githubusercontent.com/u/26806?v=4", "gravatar_id": "", "url": "https://api.github.com/users/solson", "html_url": "https://github.com/solson", "followers_url": "https://api.github.com/users/solson/followers", "following_url": "https://api.github.com/users/solson/following{/other_user}", "gists_url": "https://api.github.com/users/solson/gists{/gist_id}", "starred_url": "https://api.github.com/users/solson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/solson/subscriptions", "organizations_url": "https://api.github.com/users/solson/orgs", "repos_url": "https://api.github.com/users/solson/repos", "events_url": "https://api.github.com/users/solson/events{/privacy}", "received_events_url": "https://api.github.com/users/solson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "solson", "id": 26806, "node_id": "MDQ6VXNlcjI2ODA2", "avatar_url": "https://avatars.githubusercontent.com/u/26806?v=4", "gravatar_id": "", "url": "https://api.github.com/users/solson", "html_url": "https://github.com/solson", "followers_url": "https://api.github.com/users/solson/followers", "following_url": "https://api.github.com/users/solson/following{/other_user}", "gists_url": "https://api.github.com/users/solson/gists{/gist_id}", "starred_url": "https://api.github.com/users/solson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/solson/subscriptions", "organizations_url": "https://api.github.com/users/solson/orgs", "repos_url": "https://api.github.com/users/solson/repos", "events_url": "https://api.github.com/users/solson/events{/privacy}", "received_events_url": "https://api.github.com/users/solson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6c463b7562f6ff15db3bc90717c3c2da3d6967dd", "url": "https://api.github.com/repos/rust-lang/rust/commits/6c463b7562f6ff15db3bc90717c3c2da3d6967dd", "html_url": "https://github.com/rust-lang/rust/commit/6c463b7562f6ff15db3bc90717c3c2da3d6967dd"}], "stats": {"total": 102, "additions": 48, "deletions": 54}, "files": [{"sha": "3e4d3fb1ab50a68adf4b36fac52faac65ec2da88", "filename": "src/interpreter/mod.rs", "status": "modified", "additions": 32, "deletions": 37, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/49e6c57ef9085bc5d741db120b2a79dbc1296e31/src%2Finterpreter%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49e6c57ef9085bc5d741db120b2a79dbc1296e31/src%2Finterpreter%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter%2Fmod.rs?ref=49e6c57ef9085bc5d741db120b2a79dbc1296e31", "patch": "@@ -82,7 +82,9 @@ pub struct Frame<'a, 'tcx: 'a> {\n     /// The list of locals for this stack frame, stored in order as\n     /// `[arguments..., variables..., temporaries...]`. The locals are stored as `Value`s, which\n     /// can either directly contain `PrimVal` or refer to some part of an `Allocation`.\n-    pub locals: Vec<Value>,\n+    ///\n+    /// Before being initialized, a local is simply marked as None.\n+    pub locals: Vec<Option<Value>>,\n \n     ////////////////////////////////////////////////////////////////////////////////\n     // Current position within the function\n@@ -351,27 +353,17 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n     ) -> EvalResult<'tcx, ()> {\n         ::log_settings::settings().indentation += 1;\n \n-        // Skip 1 because we don't make a slot for the ReturnPointer, which is local number zero.\n-        // The ReturnPointer is represented by `return_lvalue`, and points to an allocation or a\n-        // local in a higher stack frame.\n-        //\n-        // FIXME(solson): Write this in a way that doesn't assume ReturnPointer is local 0.\n-        let local_tys = mir.local_decls.iter().map(|a| a.ty).skip(1);\n-\n-        let locals: EvalResult<'tcx, Vec<Value>> = local_tys.map(|ty| {\n-            let size = self.type_size_with_substs(ty, substs);\n-            let align = self.type_align_with_substs(ty, substs);\n-\n-            // FIXME(solson)\n-            self.memory.allocate(size, align).map(Value::ByRef)\n-        }).collect();\n+        // Subtract 1 because `local_decls` includes the ReturnPointer, but we don't store a local\n+        // `Value` for that.\n+        let num_locals = mir.local_decls.len() - 1;\n+        let locals = vec![None; num_locals];\n \n         self.stack.push(Frame {\n             mir: mir.clone(),\n             block: mir::START_BLOCK,\n             return_to_block: return_to_block,\n             return_lvalue: return_lvalue,\n-            locals: locals?,\n+            locals: locals,\n             span: span,\n             def_id: def_id,\n             substs: substs,\n@@ -800,16 +792,15 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         use rustc::mir::repr::Operand::*;\n         match *op {\n             Consume(ref lvalue) => {\n-                let val = match self.eval_lvalue(lvalue)? {\n+                match self.eval_lvalue(lvalue)? {\n                     Lvalue::Ptr { ptr, extra } => {\n                         assert_eq!(extra, LvalueExtra::None);\n-                        Value::ByRef(ptr)\n+                        Ok(Value::ByRef(ptr))\n                     }\n                     Lvalue::Local { frame, local } => {\n-                        self.stack[frame].get_local(local)\n+                        self.stack[frame].get_local(local).ok_or(EvalError::ReadUndefBytes)\n                     }\n-                };\n-                Ok(val)\n+                }\n             }\n \n             Constant(mir::Constant { ref literal, ty, .. }) => {\n@@ -850,16 +841,16 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         }\n     }\n \n-    fn eval_lvalue(&mut self, lvalue: &mir::Lvalue<'tcx>) -> EvalResult<'tcx, Lvalue> {\n+    fn eval_lvalue(&mut self, mir_lvalue: &mir::Lvalue<'tcx>) -> EvalResult<'tcx, Lvalue> {\n         use rustc::mir::repr::Lvalue::*;\n-        match *lvalue {\n-            Local(i) if self.frame().mir.local_kind(i) == mir::LocalKind::ReturnPointer => {\n-                Ok(self.frame().return_lvalue)\n-            }\n+        let lvalue = match *mir_lvalue {\n+            Local(mir::RETURN_POINTER) => self.frame().return_lvalue,\n \n             Local(local) => {\n-                let frame = self.stack.len() - 1;\n-                Ok(Lvalue::Local { frame: frame, local: local })\n+                Lvalue::Local {\n+                    frame: self.stack.len() - 1,\n+                    local: local,\n+                }\n             }\n \n             Static(def_id) => {\n@@ -871,11 +862,12 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 };\n                 let ptr = *self.statics.get(&cid)\n                     .expect(\"static should have been cached (lvalue)\");\n-                Ok(Lvalue::Ptr { ptr: ptr, extra: LvalueExtra::None })\n+                Lvalue::Ptr { ptr: ptr, extra: LvalueExtra::None }\n             }\n \n-            Projection(ref proj) => self.eval_lvalue_projection(proj),\n-        }\n+            Projection(ref proj) => return self.eval_lvalue_projection(proj),\n+        };\n+        Ok(lvalue)\n     }\n \n     fn eval_lvalue_projection(\n@@ -1020,13 +1012,15 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         let new_lvalue = match lvalue {\n             Lvalue::Local { frame, local } => {\n                 let ptr = match self.stack[frame].get_local(local) {\n-                    Value::ByRef(ptr) => ptr,\n-                    val => {\n+                    Some(Value::ByRef(ptr)) => ptr,\n+                    opt_val => {\n                         let ty = self.stack[frame].mir.local_decls[local].ty;\n                         let substs = self.stack[frame].substs;\n                         let ptr = self.alloc_ptr(ty, substs)?;\n-                        self.write_value_to_ptr(val, ptr, ty)?;\n                         self.stack[frame].set_local(local, Value::ByRef(ptr));\n+                        if let Some(val) = opt_val {\n+                            self.write_value_to_ptr(val, ptr, ty)?;\n+                        }\n                         ptr\n                     }\n                 };\n@@ -1133,7 +1127,8 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             }\n             Lvalue::Local { frame, local } => {\n                 if let Value::ByRef(src_ptr) = value {\n-                    let dest_ptr = if let Value::ByRef(ptr) = self.stack[frame].get_local(local) {\n+                    let dest_val = self.stack[frame].get_local(local);\n+                    let dest_ptr = if let Some(Value::ByRef(ptr)) = dest_val {\n                         ptr\n                     } else {\n                         let substs = self.substs();\n@@ -1367,14 +1362,14 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n }\n \n impl<'a, 'tcx: 'a> Frame<'a, 'tcx> {\n-    fn get_local(&self, local: mir::Local) -> Value {\n+    fn get_local(&self, local: mir::Local) -> Option<Value> {\n         // Subtract 1 because we don't store a value for the ReturnPointer, the local with index 0.\n         self.locals[local.index() - 1]\n     }\n \n     fn set_local(&mut self, local: mir::Local, value: Value) {\n         // Subtract 1 because we don't store a value for the ReturnPointer, the local with index 0.\n-        self.locals[local.index() - 1] = value;\n+        self.locals[local.index() - 1] = Some(value);\n     }\n }\n "}, {"sha": "4a1e02c39cc805191be2adc0f8c20df33defc024", "filename": "src/interpreter/terminator/mod.rs", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/49e6c57ef9085bc5d741db120b2a79dbc1296e31/src%2Finterpreter%2Fterminator%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49e6c57ef9085bc5d741db120b2a79dbc1296e31/src%2Finterpreter%2Fterminator%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter%2Fterminator%2Fmod.rs?ref=49e6c57ef9085bc5d741db120b2a79dbc1296e31", "patch": "@@ -216,15 +216,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n                 let arg_locals = self.frame().mir.args_iter();\n                 for (arg_local, (arg_val, arg_ty)) in arg_locals.zip(args) {\n-                    // FIXME(solson)\n-                    let dest = self.frame().get_local(arg_local);\n-\n-                    // FIXME(solson)\n-                    let dest = match dest {\n-                        Value::ByRef(p) => Lvalue::from_ptr(p),\n-                        _ => bug!(\"all locals should be ByRef until I finish refactoring\"),\n-                    };\n-\n+                    let dest = self.eval_lvalue(&mir::Lvalue::Local(arg_local))?;\n                     self.write_value(arg_val, dest, arg_ty)?;\n                 }\n "}, {"sha": "a1d430d96a84c9836f52529e82c803ce319d0d30", "filename": "src/memory.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/49e6c57ef9085bc5d741db120b2a79dbc1296e31/src%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49e6c57ef9085bc5d741db120b2a79dbc1296e31/src%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmemory.rs?ref=49e6c57ef9085bc5d741db120b2a79dbc1296e31", "patch": "@@ -52,28 +52,33 @@ impl Pointer {\n     pub fn offset(self, i: isize) -> Self {\n         Pointer { offset: (self.offset as isize + i) as usize, ..self }\n     }\n+\n     pub fn points_to_zst(&self) -> bool {\n         self.alloc_id == ZST_ALLOC_ID\n     }\n+\n     pub fn to_int<'tcx>(&self) -> EvalResult<'tcx, usize> {\n         match self.alloc_id {\n             NEVER_ALLOC_ID |\n             ZST_ALLOC_ID => Ok(self.offset),\n             _ => Err(EvalError::ReadPointerAsBytes),\n         }\n     }\n+\n     pub fn from_int(i: usize) -> Self {\n         Pointer {\n             alloc_id: ZST_ALLOC_ID,\n             offset: i,\n         }\n     }\n+\n     fn zst_ptr() -> Self {\n         Pointer {\n             alloc_id: ZST_ALLOC_ID,\n             offset: 0,\n         }\n     }\n+\n     pub fn never_ptr() -> Self {\n         Pointer {\n             alloc_id: NEVER_ALLOC_ID,"}, {"sha": "1fd2c4b2bd6aa2ba89428a7928be488015577e1b", "filename": "tests/compile-fail/oom.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/49e6c57ef9085bc5d741db120b2a79dbc1296e31/tests%2Fcompile-fail%2Foom.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49e6c57ef9085bc5d741db120b2a79dbc1296e31/tests%2Fcompile-fail%2Foom.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Foom.rs?ref=49e6c57ef9085bc5d741db120b2a79dbc1296e31", "patch": "@@ -1,11 +1,7 @@\n #![feature(custom_attribute, attr_literals)]\n #![miri(memory_size=0)]\n \n-fn bar() {\n-    let x = 5;\n-    assert_eq!(x, 6);\n-}\n-\n fn main() {\n-    bar(); //~ ERROR tried to allocate 4 more bytes, but only 0 bytes are free of the 0 byte memory\n+    let _x = [42; 10];\n+    //~^ERROR tried to allocate 40 more bytes, but only 0 bytes are free of the 0 byte memory\n }"}, {"sha": "b89231e4515816d8cb85236fd037dba4909c4e27", "filename": "tests/compile-fail/oom2.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/49e6c57ef9085bc5d741db120b2a79dbc1296e31/tests%2Fcompile-fail%2Foom2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49e6c57ef9085bc5d741db120b2a79dbc1296e31/tests%2Fcompile-fail%2Foom2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Foom2.rs?ref=49e6c57ef9085bc5d741db120b2a79dbc1296e31", "patch": "@@ -2,8 +2,8 @@\n #![miri(memory_size=1000)]\n \n fn bar(i: i32) {\n-    if i < 1000 {\n-        bar(i + 1) //~ ERROR tried to allocate 4 more bytes, but only 0 bytes are free of the 1000 byte memory\n+    if i < 1000 { //~ERROR tried to allocate 4 more bytes, but only 1 bytes are free of the 1000 byte memory\n+        bar(i + 1)\n         //~^NOTE inside call to bar\n         //~|NOTE inside call to bar\n         //~|NOTE inside call to bar\n@@ -25,6 +25,12 @@ fn bar(i: i32) {\n         //~|NOTE inside call to bar\n         //~|NOTE inside call to bar\n         //~|NOTE inside call to bar\n+        //~|NOTE inside call to bar\n+        //~|NOTE inside call to bar\n+        //~|NOTE inside call to bar\n+        //~|NOTE inside call to bar\n+        //~|NOTE inside call to bar\n+        //~|NOTE inside call to bar\n     }\n }\n "}]}