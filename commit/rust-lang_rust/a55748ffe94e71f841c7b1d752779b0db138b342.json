{"sha": "a55748ffe94e71f841c7b1d752779b0db138b342", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE1NTc0OGZmZTk0ZTcxZjg0MWM3YjFkNzUyNzc5YjBkYjEzOGIzNDI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-05-16T23:00:53Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-05-16T23:00:53Z"}, "message": "Auto merge of #84993 - eddyb:cg-ssa-on-demand-blocks, r=nagisa\n\nrustc_codegen_ssa: only create backend `BasicBlock`s as-needed.\n\nInstead of creating one backend (e.g. LLVM) block per MIR block ahead of time, and then deleting the ones that weren't visited, this PR moves to creating the blocks as they're needed (either reached via the RPO visit, or used as the target of a branch from a different block).\n\nAs deleting a block was the only `unsafe` builder method (generally we only *create* backend objects, not *remove* them), that's gone now and codegen is overall a bit safer.\n\nThe only change in output is the order of LLVM blocks (which AFAIK has no semantic meaning, other than the first block being the entry block). This happens because the blocks are now created due to control-flow edges, rather than MIR block order.\n\nI'm making this a standalone PR because I keep getting wild perf results when I change *anything* in codegen, but if you want to read more about my plans in this area, see https://github.com/rust-lang/rust/pull/84771#issuecomment-830636256 (and https://github.com/rust-lang/rust/pull/84771#issue-628295651 - but that may be a bit outdated).\n\n(You may notice some of the APIs in this PR, like `append_block`, don't help with the future plans - but I didn't want to include the necessary refactors that pass a build around everywhere, in this PR, so it's a small compromise)\n\nr? `@nagisa` `@bjorn3`", "tree": {"sha": "d17c5ff7907f41b12002978551c7ba54bac7cb40", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d17c5ff7907f41b12002978551c7ba54bac7cb40"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a55748ffe94e71f841c7b1d752779b0db138b342", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a55748ffe94e71f841c7b1d752779b0db138b342", "html_url": "https://github.com/rust-lang/rust/commit/a55748ffe94e71f841c7b1d752779b0db138b342", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a55748ffe94e71f841c7b1d752779b0db138b342/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fe72845f7bb6a77b9e671e6a4f32fe714962cec4", "url": "https://api.github.com/repos/rust-lang/rust/commits/fe72845f7bb6a77b9e671e6a4f32fe714962cec4", "html_url": "https://github.com/rust-lang/rust/commit/fe72845f7bb6a77b9e671e6a4f32fe714962cec4"}, {"sha": "0fcaf11455b2864ba642216d4860c213b09a8db1", "url": "https://api.github.com/repos/rust-lang/rust/commits/0fcaf11455b2864ba642216d4860c213b09a8db1", "html_url": "https://github.com/rust-lang/rust/commit/0fcaf11455b2864ba642216d4860c213b09a8db1"}], "stats": {"total": 185, "additions": 100, "deletions": 85}, "files": [{"sha": "bc9d99ed4a122a2a9480e97587e6f393b9da54f9", "filename": "compiler/rustc_codegen_llvm/src/builder.rs", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/a55748ffe94e71f841c7b1d752779b0db138b342/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a55748ffe94e71f841c7b1d752779b0db138b342/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs?ref=a55748ffe94e71f841c7b1d752779b0db138b342", "patch": "@@ -118,24 +118,16 @@ macro_rules! builder_methods_for_value_instructions {\n }\n \n impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n-    fn new_block<'b>(cx: &'a CodegenCx<'ll, 'tcx>, llfn: &'ll Value, name: &'b str) -> Self {\n-        let mut bx = Builder::with_cx(cx);\n-        let llbb = unsafe {\n-            let name = SmallCStr::new(name);\n-            llvm::LLVMAppendBasicBlockInContext(cx.llcx, llfn, name.as_ptr())\n-        };\n-        bx.position_at_end(llbb);\n+    fn build(cx: &'a CodegenCx<'ll, 'tcx>, llbb: &'ll BasicBlock) -> Self {\n+        let bx = Builder::with_cx(cx);\n+        unsafe {\n+            llvm::LLVMPositionBuilderAtEnd(bx.llbuilder, llbb);\n+        }\n         bx\n     }\n \n-    fn with_cx(cx: &'a CodegenCx<'ll, 'tcx>) -> Self {\n-        // Create a fresh builder from the crate context.\n-        let llbuilder = unsafe { llvm::LLVMCreateBuilderInContext(cx.llcx) };\n-        Builder { llbuilder, cx }\n-    }\n-\n-    fn build_sibling_block(&self, name: &str) -> Self {\n-        Builder::new_block(self.cx, self.llfn(), name)\n+    fn cx(&self) -> &CodegenCx<'ll, 'tcx> {\n+        self.cx\n     }\n \n     fn llbb(&self) -> &'ll BasicBlock {\n@@ -144,12 +136,22 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n \n     fn set_span(&mut self, _span: Span) {}\n \n-    fn position_at_end(&mut self, llbb: &'ll BasicBlock) {\n+    fn append_block(cx: &'a CodegenCx<'ll, 'tcx>, llfn: &'ll Value, name: &str) -> &'ll BasicBlock {\n         unsafe {\n-            llvm::LLVMPositionBuilderAtEnd(self.llbuilder, llbb);\n+            let name = SmallCStr::new(name);\n+            llvm::LLVMAppendBasicBlockInContext(cx.llcx, llfn, name.as_ptr())\n         }\n     }\n \n+    fn append_sibling_block(&mut self, name: &str) -> &'ll BasicBlock {\n+        Self::append_block(self.cx, self.llfn(), name)\n+    }\n+\n+    fn build_sibling_block(&mut self, name: &str) -> Self {\n+        let llbb = self.append_sibling_block(name);\n+        Self::build(self.cx, llbb)\n+    }\n+\n     fn ret_void(&mut self) {\n         unsafe {\n             llvm::LLVMBuildRetVoid(self.llbuilder);\n@@ -1144,14 +1146,6 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n         unsafe { llvm::LLVMBuildZExt(self.llbuilder, val, dest_ty, UNNAMED) }\n     }\n \n-    fn cx(&self) -> &CodegenCx<'ll, 'tcx> {\n-        self.cx\n-    }\n-\n-    unsafe fn delete_basic_block(&mut self, bb: &'ll BasicBlock) {\n-        llvm::LLVMDeleteBasicBlock(bb);\n-    }\n-\n     fn do_not_inline(&mut self, llret: &'ll Value) {\n         llvm::Attribute::NoInline.apply_callsite(llvm::AttributePlace::Function, llret);\n     }\n@@ -1165,6 +1159,12 @@ impl StaticBuilderMethods for Builder<'a, 'll, 'tcx> {\n }\n \n impl Builder<'a, 'll, 'tcx> {\n+    fn with_cx(cx: &'a CodegenCx<'ll, 'tcx>) -> Self {\n+        // Create a fresh builder from the crate context.\n+        let llbuilder = unsafe { llvm::LLVMCreateBuilderInContext(cx.llcx) };\n+        Builder { llbuilder, cx }\n+    }\n+\n     pub fn llfn(&self) -> &'ll Value {\n         unsafe { llvm::LLVMGetBasicBlockParent(self.llbb()) }\n     }"}, {"sha": "019bf4a09a7870000ef18d685fa297c39642e595", "filename": "compiler/rustc_codegen_llvm/src/coverageinfo/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a55748ffe94e71f841c7b1d752779b0db138b342/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcoverageinfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a55748ffe94e71f841c7b1d752779b0db138b342/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcoverageinfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcoverageinfo%2Fmod.rs?ref=a55748ffe94e71f841c7b1d752779b0db138b342", "patch": "@@ -223,7 +223,8 @@ fn declare_unused_fn(cx: &CodegenCx<'ll, 'tcx>, def_id: &DefId) -> Instance<'tcx\n \n fn codegen_unused_fn_and_counter(cx: &CodegenCx<'ll, 'tcx>, instance: Instance<'tcx>) {\n     let llfn = cx.get_fn(instance);\n-    let mut bx = Builder::new_block(cx, llfn, \"unused_function\");\n+    let llbb = Builder::append_block(cx, llfn, \"unused_function\");\n+    let mut bx = Builder::build(cx, llbb);\n     let fn_name = bx.get_pgo_func_name_var(instance);\n     let hash = bx.const_u64(0);\n     let num_counters = bx.const_u32(1);"}, {"sha": "22d513d66d1cc87aeb4a84abc7473ed09d7650b8", "filename": "compiler/rustc_codegen_llvm/src/intrinsic.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a55748ffe94e71f841c7b1d752779b0db138b342/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a55748ffe94e71f841c7b1d752779b0db138b342/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs?ref=a55748ffe94e71f841c7b1d752779b0db138b342", "patch": "@@ -678,7 +678,8 @@ fn gen_fn<'ll, 'tcx>(\n     cx.apply_target_cpu_attr(llfn);\n     // FIXME(eddyb) find a nicer way to do this.\n     unsafe { llvm::LLVMRustSetLinkage(llfn, llvm::Linkage::InternalLinkage) };\n-    let bx = Builder::new_block(cx, llfn, \"entry-block\");\n+    let llbb = Builder::append_block(cx, llfn, \"entry-block\");\n+    let bx = Builder::build(cx, llbb);\n     codegen(bx);\n     llfn\n }"}, {"sha": "bf66040a7ebad7120a9b3f1c50963b3098476065", "filename": "compiler/rustc_codegen_llvm/src/llvm/ffi.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a55748ffe94e71f841c7b1d752779b0db138b342/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a55748ffe94e71f841c7b1d752779b0db138b342/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs?ref=a55748ffe94e71f841c7b1d752779b0db138b342", "patch": "@@ -1079,7 +1079,6 @@ extern \"C\" {\n         Fn: &'a Value,\n         Name: *const c_char,\n     ) -> &'a BasicBlock;\n-    pub fn LLVMDeleteBasicBlock(BB: &BasicBlock);\n \n     // Operations on instructions\n     pub fn LLVMIsAInstruction(Val: &Value) -> Option<&Value>;"}, {"sha": "ac6a1a90bfd06d377fca53f4fa9f36daf893e72b", "filename": "compiler/rustc_codegen_ssa/src/base.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a55748ffe94e71f841c7b1d752779b0db138b342/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a55748ffe94e71f841c7b1d752779b0db138b342/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs?ref=a55748ffe94e71f841c7b1d752779b0db138b342", "patch": "@@ -409,7 +409,8 @@ pub fn maybe_create_entry_wrapper<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n         cx.set_frame_pointer_elimination(llfn);\n         cx.apply_target_cpu_attr(llfn);\n \n-        let mut bx = Bx::new_block(&cx, llfn, \"top\");\n+        let llbb = Bx::append_block(&cx, llfn, \"top\");\n+        let mut bx = Bx::build(&cx, llbb);\n \n         bx.insert_reference_to_gdb_debug_scripts_section_global();\n "}, {"sha": "93200bd1f264a4465faf3e8e1366a6779f3fa1a4", "filename": "compiler/rustc_codegen_ssa/src/mir/block.rs", "status": "modified", "additions": 27, "deletions": 12, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/a55748ffe94e71f841c7b1d752779b0db138b342/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a55748ffe94e71f841c7b1d752779b0db138b342/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs?ref=a55748ffe94e71f841c7b1d752779b0db138b342", "patch": "@@ -68,7 +68,7 @@ impl<'a, 'tcx> TerminatorCodegenHelper<'tcx> {\n         target: mir::BasicBlock,\n     ) -> (Bx::BasicBlock, bool) {\n         let span = self.terminator.source_info.span;\n-        let lltarget = fx.blocks[target];\n+        let lltarget = fx.llbb(target);\n         let target_funclet = fx.cleanup_kinds[target].funclet_bb(target);\n         match (self.funclet_bb, target_funclet) {\n             (None, None) => (lltarget, false),\n@@ -133,13 +133,13 @@ impl<'a, 'tcx> TerminatorCodegenHelper<'tcx> {\n         // If there is a cleanup block and the function we're calling can unwind, then\n         // do an invoke, otherwise do a call.\n         if let Some(cleanup) = cleanup.filter(|_| fn_abi.can_unwind) {\n-            let ret_bx = if let Some((_, target)) = destination {\n-                fx.blocks[target]\n+            let ret_llbb = if let Some((_, target)) = destination {\n+                fx.llbb(target)\n             } else {\n                 fx.unreachable_block()\n             };\n             let invokeret =\n-                bx.invoke(fn_ptr, &llargs, ret_bx, self.llblock(fx, cleanup), self.funclet(fx));\n+                bx.invoke(fn_ptr, &llargs, ret_llbb, self.llblock(fx, cleanup), self.funclet(fx));\n             bx.apply_attrs_callsite(&fn_abi, invokeret);\n \n             if let Some((ret_dest, target)) = destination {\n@@ -386,7 +386,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n \n         // Create the failure block and the conditional branch to it.\n         let lltarget = helper.llblock(self, target);\n-        let panic_block = self.new_block(\"panic\");\n+        let panic_block = bx.build_sibling_block(\"panic\");\n         if expected {\n             bx.cond_br(cond, lltarget, panic_block.llbb());\n         } else {\n@@ -1205,7 +1205,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n \n     // FIXME(eddyb) rename this to `eh_pad_for_uncached`.\n     fn landing_pad_for_uncached(&mut self, bb: mir::BasicBlock) -> Bx::BasicBlock {\n-        let llbb = self.blocks[bb];\n+        let llbb = self.llbb(bb);\n         if base::wants_msvc_seh(self.cx.sess()) {\n             let funclet;\n             let ret_llbb;\n@@ -1289,14 +1289,29 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         })\n     }\n \n-    pub fn new_block(&self, name: &str) -> Bx {\n-        Bx::new_block(self.cx, self.llfn, name)\n+    // FIXME(eddyb) replace with `build_sibling_block`/`append_sibling_block`\n+    // (which requires having a `Bx` already, and not all callers do).\n+    fn new_block(&self, name: &str) -> Bx {\n+        let llbb = Bx::append_block(self.cx, self.llfn, name);\n+        Bx::build(self.cx, llbb)\n     }\n \n-    pub fn build_block(&self, bb: mir::BasicBlock) -> Bx {\n-        let mut bx = Bx::with_cx(self.cx);\n-        bx.position_at_end(self.blocks[bb]);\n-        bx\n+    /// Get the backend `BasicBlock` for a MIR `BasicBlock`, either already\n+    /// cached in `self.cached_llbbs`, or created on demand (and cached).\n+    // FIXME(eddyb) rename `llbb` and other `ll`-prefixed things to use a\n+    // more backend-agnostic prefix such as `cg` (i.e. this would be `cgbb`).\n+    pub fn llbb(&mut self, bb: mir::BasicBlock) -> Bx::BasicBlock {\n+        self.cached_llbbs[bb].unwrap_or_else(|| {\n+            // FIXME(eddyb) only name the block if `fewer_names` is `false`.\n+            let llbb = Bx::append_block(self.cx, self.llfn, &format!(\"{:?}\", bb));\n+            self.cached_llbbs[bb] = Some(llbb);\n+            llbb\n+        })\n+    }\n+\n+    pub fn build_block(&mut self, bb: mir::BasicBlock) -> Bx {\n+        let llbb = self.llbb(bb);\n+        Bx::build(self.cx, llbb)\n     }\n \n     fn make_return_dest("}, {"sha": "3bbc481b61093fccfa1fe09ae051095f6ebb5aac", "filename": "compiler/rustc_codegen_ssa/src/mir/mod.rs", "status": "modified", "additions": 22, "deletions": 33, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/a55748ffe94e71f841c7b1d752779b0db138b342/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a55748ffe94e71f841c7b1d752779b0db138b342/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fmod.rs?ref=a55748ffe94e71f841c7b1d752779b0db138b342", "patch": "@@ -40,8 +40,11 @@ pub struct FunctionCx<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> {\n     /// then later loaded when generating the DIVERGE_BLOCK.\n     personality_slot: Option<PlaceRef<'tcx, Bx::Value>>,\n \n-    /// A `Block` for each MIR `BasicBlock`\n-    blocks: IndexVec<mir::BasicBlock, Bx::BasicBlock>,\n+    /// A backend `BasicBlock` for each MIR `BasicBlock`, created lazily\n+    /// as-needed (e.g. RPO reaching it or another block branching to it).\n+    // FIXME(eddyb) rename `llbbs` and other `ll`-prefixed things to use a\n+    // more backend-agnostic prefix such as `cg` (i.e. this would be `cgbbs`).\n+    cached_llbbs: IndexVec<mir::BasicBlock, Option<Bx::BasicBlock>>,\n \n     /// The funclet status of each basic block\n     cleanup_kinds: IndexVec<mir::BasicBlock, analyze::CleanupKind>,\n@@ -141,7 +144,8 @@ pub fn codegen_mir<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n \n     let debug_context = cx.create_function_debug_context(instance, &fn_abi, llfn, &mir);\n \n-    let mut bx = Bx::new_block(cx, llfn, \"start\");\n+    let start_llbb = Bx::append_block(cx, llfn, \"start\");\n+    let mut bx = Bx::build(cx, start_llbb);\n \n     if mir.basic_blocks().iter().any(|bb| bb.is_cleanup) {\n         bx.set_personality_fn(cx.eh_personality());\n@@ -151,17 +155,17 @@ pub fn codegen_mir<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n     // Allocate a `Block` for every basic block, except\n     // the start block, if nothing loops back to it.\n     let reentrant_start_block = !mir.predecessors()[mir::START_BLOCK].is_empty();\n-    let block_bxs: IndexVec<mir::BasicBlock, Bx::BasicBlock> = mir\n-        .basic_blocks()\n-        .indices()\n-        .map(|bb| {\n-            if bb == mir::START_BLOCK && !reentrant_start_block {\n-                bx.llbb()\n-            } else {\n-                bx.build_sibling_block(&format!(\"{:?}\", bb)).llbb()\n-            }\n-        })\n-        .collect();\n+    let cached_llbbs: IndexVec<mir::BasicBlock, Option<Bx::BasicBlock>> =\n+        mir.basic_blocks()\n+            .indices()\n+            .map(|bb| {\n+                if bb == mir::START_BLOCK && !reentrant_start_block {\n+                    Some(start_llbb)\n+                } else {\n+                    None\n+                }\n+            })\n+            .collect();\n \n     let mut fx = FunctionCx {\n         instance,\n@@ -170,7 +174,7 @@ pub fn codegen_mir<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n         fn_abi,\n         cx,\n         personality_slot: None,\n-        blocks: block_bxs,\n+        cached_llbbs,\n         unreachable_block: None,\n         cleanup_kinds,\n         landing_pads: IndexVec::from_elem(None, mir.basic_blocks()),\n@@ -245,29 +249,14 @@ pub fn codegen_mir<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n \n     // Branch to the START block, if it's not the entry block.\n     if reentrant_start_block {\n-        bx.br(fx.blocks[mir::START_BLOCK]);\n+        bx.br(fx.llbb(mir::START_BLOCK));\n     }\n \n-    let rpo = traversal::reverse_postorder(&mir);\n-    let mut visited = BitSet::new_empty(mir.basic_blocks().len());\n-\n     // Codegen the body of each block using reverse postorder\n-    for (bb, _) in rpo {\n-        visited.insert(bb.index());\n+    // FIXME(eddyb) reuse RPO iterator between `analysis` and this.\n+    for (bb, _) in traversal::reverse_postorder(&mir) {\n         fx.codegen_block(bb);\n     }\n-\n-    // Remove blocks that haven't been visited, or have no\n-    // predecessors.\n-    for bb in mir.basic_blocks().indices() {\n-        // Unreachable block\n-        if !visited.contains(bb.index()) {\n-            debug!(\"codegen_mir: block {:?} was not visited\", bb);\n-            unsafe {\n-                bx.delete_basic_block(fx.blocks[bb]);\n-            }\n-        }\n-    }\n }\n \n /// Produces, for each argument, a `Value` pointing at the"}, {"sha": "29b2db5d4d7af2696726f7865dd62c3885b8443c", "filename": "compiler/rustc_codegen_ssa/src/traits/builder.rs", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a55748ffe94e71f841c7b1d752779b0db138b342/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a55748ffe94e71f841c7b1d752779b0db138b342/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fbuilder.rs?ref=a55748ffe94e71f841c7b1d752779b0db138b342", "patch": "@@ -40,14 +40,21 @@ pub trait BuilderMethods<'a, 'tcx>:\n     + HasParamEnv<'tcx>\n     + HasTargetSpec\n {\n-    fn new_block<'b>(cx: &'a Self::CodegenCx, llfn: Self::Function, name: &'b str) -> Self;\n-    fn with_cx(cx: &'a Self::CodegenCx) -> Self;\n-    fn build_sibling_block(&self, name: &str) -> Self;\n+    fn build(cx: &'a Self::CodegenCx, llbb: Self::BasicBlock) -> Self;\n+\n     fn cx(&self) -> &Self::CodegenCx;\n     fn llbb(&self) -> Self::BasicBlock;\n+\n     fn set_span(&mut self, span: Span);\n \n-    fn position_at_end(&mut self, llbb: Self::BasicBlock);\n+    // FIXME(eddyb) replace uses of this with `append_sibling_block`.\n+    fn append_block(cx: &'a Self::CodegenCx, llfn: Self::Function, name: &str) -> Self::BasicBlock;\n+\n+    fn append_sibling_block(&mut self, name: &str) -> Self::BasicBlock;\n+\n+    // FIXME(eddyb) replace with callers using `append_sibling_block`.\n+    fn build_sibling_block(&mut self, name: &str) -> Self;\n+\n     fn ret_void(&mut self);\n     fn ret(&mut self, v: Self::Value);\n     fn br(&mut self, dest: Self::BasicBlock);\n@@ -291,6 +298,5 @@ pub trait BuilderMethods<'a, 'tcx>:\n     ) -> Self::Value;\n     fn zext(&mut self, val: Self::Value, dest_ty: Self::Type) -> Self::Value;\n \n-    unsafe fn delete_basic_block(&mut self, bb: Self::BasicBlock);\n     fn do_not_inline(&mut self, llret: Self::Value);\n }"}, {"sha": "543b81b0b6246d3bec2a5ae119e7d9c655540ef1", "filename": "src/test/codegen/drop.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a55748ffe94e71f841c7b1d752779b0db138b342/src%2Ftest%2Fcodegen%2Fdrop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a55748ffe94e71f841c7b1d752779b0db138b342/src%2Ftest%2Fcodegen%2Fdrop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fdrop.rs?ref=a55748ffe94e71f841c7b1d752779b0db138b342", "patch": "@@ -23,13 +23,16 @@ pub fn droppy() {\n // FIXME(eddyb) the `void @` forces a match on the instruction, instead of the\n // comment, that's `; call core::ptr::drop_in_place::<drop::SomeUniqueName>`\n // for the `v0` mangling, should switch to matching on that once `legacy` is gone.\n-// CHECK-NOT: call void @{{.*}}drop_in_place{{.*}}SomeUniqueName\n-// CHECK: invoke void @{{.*}}drop_in_place{{.*}}SomeUniqueName\n-// CHECK: invoke void @{{.*}}drop_in_place{{.*}}SomeUniqueName\n // CHECK-NOT: invoke void @{{.*}}drop_in_place{{.*}}SomeUniqueName\n // CHECK: call void @{{.*}}drop_in_place{{.*}}SomeUniqueName\n // CHECK: call void @{{.*}}drop_in_place{{.*}}SomeUniqueName\n+// CHECK-NOT: call void @{{.*}}drop_in_place{{.*}}SomeUniqueName\n+// CHECK: invoke void @{{.*}}drop_in_place{{.*}}SomeUniqueName\n+// CHECK-NOT: invoke void @{{.*}}drop_in_place{{.*}}SomeUniqueName\n // CHECK: call void @{{.*}}drop_in_place{{.*}}SomeUniqueName\n+// CHECK-NOT: call void @{{.*}}drop_in_place{{.*}}SomeUniqueName\n+// CHECK: invoke void @{{.*}}drop_in_place{{.*}}SomeUniqueName\n+// CHECK-NOT: invoke void @{{.*}}drop_in_place{{.*}}SomeUniqueName\n // CHECK: call void @{{.*}}drop_in_place{{.*}}SomeUniqueName\n // CHECK-NOT: {{(call|invoke) void @.*}}drop_in_place{{.*}}SomeUniqueName\n // The next line checks for the } that ends the function definition"}, {"sha": "d0c0202052ed6c7a554524d3461b766401954050", "filename": "src/test/codegen/match.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a55748ffe94e71f841c7b1d752779b0db138b342/src%2Ftest%2Fcodegen%2Fmatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a55748ffe94e71f841c7b1d752779b0db138b342/src%2Ftest%2Fcodegen%2Fmatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fmatch.rs?ref=a55748ffe94e71f841c7b1d752779b0db138b342", "patch": "@@ -14,13 +14,13 @@ pub fn exhaustive_match(e: E) -> u8 {\n // CHECK-NEXT: i[[TY:[0-9]+]] [[DISCR:[0-9]+]], label %[[A:[a-zA-Z0-9_]+]]\n // CHECK-NEXT: i[[TY:[0-9]+]] [[DISCR:[0-9]+]], label %[[B:[a-zA-Z0-9_]+]]\n // CHECK-NEXT: ]\n-// CHECK: [[B]]:\n-// CHECK-NEXT: store i8 1, i8* %1, align 1\n-// CHECK-NEXT: br label %[[EXIT:[a-zA-Z0-9_]+]]\n // CHECK: [[OTHERWISE]]:\n // CHECK-NEXT: unreachable\n // CHECK: [[A]]:\n // CHECK-NEXT: store i8 0, i8* %1, align 1\n+// CHECK-NEXT: br label %[[EXIT:[a-zA-Z0-9_]+]]\n+// CHECK: [[B]]:\n+// CHECK-NEXT: store i8 1, i8* %1, align 1\n // CHECK-NEXT: br label %[[EXIT:[a-zA-Z0-9_]+]]\n     match e {\n         E::A => 0,"}]}