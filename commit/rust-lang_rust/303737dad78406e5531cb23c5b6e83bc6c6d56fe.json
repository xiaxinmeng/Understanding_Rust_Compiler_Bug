{"sha": "303737dad78406e5531cb23c5b6e83bc6c6d56fe", "node_id": "C_kwDOAAsO6NoAKDMwMzczN2RhZDc4NDA2ZTU1MzFjYjIzYzViNmU4M2JjNmM2ZDU2ZmU", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-01-20T22:00:22Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-01-20T22:00:22Z"}, "message": "Auto merge of #13989 - Veykril:hover, r=Veykril\n\ninternal: Remove hover fallback in favor of ranged hover\n\nThe fallback is usually more annoying than useful at this point (it messes with the range of diagnostic popups a lot), we now have a ranged hover to check the type of something which works a lot better.\n\nCloses https://github.com/rust-lang/rust-analyzer/issues/11602", "tree": {"sha": "5f9df25a5f749dd1d403730209bfa3e77211fd2c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5f9df25a5f749dd1d403730209bfa3e77211fd2c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/303737dad78406e5531cb23c5b6e83bc6c6d56fe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/303737dad78406e5531cb23c5b6e83bc6c6d56fe", "html_url": "https://github.com/rust-lang/rust/commit/303737dad78406e5531cb23c5b6e83bc6c6d56fe", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/303737dad78406e5531cb23c5b6e83bc6c6d56fe/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ce67dea2ac7e6b664731fe46e19f542e40b4bf0c", "url": "https://api.github.com/repos/rust-lang/rust/commits/ce67dea2ac7e6b664731fe46e19f542e40b4bf0c", "html_url": "https://github.com/rust-lang/rust/commit/ce67dea2ac7e6b664731fe46e19f542e40b4bf0c"}, {"sha": "4685b97f747c01e22e9d6750948621f2851b180f", "url": "https://api.github.com/repos/rust-lang/rust/commits/4685b97f747c01e22e9d6750948621f2851b180f", "html_url": "https://github.com/rust-lang/rust/commit/4685b97f747c01e22e9d6750948621f2851b180f"}], "stats": {"total": 424, "additions": 235, "deletions": 189}, "files": [{"sha": "2058a4f5f190a239fb8d2817fd50b3b5f12916b5", "filename": "crates/ide/src/hover.rs", "status": "modified", "additions": 63, "deletions": 87, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/303737dad78406e5531cb23c5b6e83bc6c6d56fe/crates%2Fide%2Fsrc%2Fhover.rs", "raw_url": "https://github.com/rust-lang/rust/raw/303737dad78406e5531cb23c5b6e83bc6c6d56fe/crates%2Fide%2Fsrc%2Fhover.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fhover.rs?ref=303737dad78406e5531cb23c5b6e83bc6c6d56fe", "patch": "@@ -15,7 +15,7 @@ use ide_db::{\n     FxIndexSet, RootDatabase,\n };\n use itertools::Itertools;\n-use syntax::{ast, match_ast, AstNode, SyntaxKind::*, SyntaxNode, SyntaxToken, T};\n+use syntax::{ast, AstNode, SyntaxKind::*, SyntaxNode, T};\n \n use crate::{\n     doc_links::token_as_doc_comment,\n@@ -86,30 +86,38 @@ pub struct HoverResult {\n // image::https://user-images.githubusercontent.com/48062697/113020658-b5f98b80-917a-11eb-9f88-3dbc27320c95.gif[]\n pub(crate) fn hover(\n     db: &RootDatabase,\n-    file_range: FileRange,\n+    frange @ FileRange { file_id, range }: FileRange,\n     config: &HoverConfig,\n ) -> Option<RangeInfo<HoverResult>> {\n     let sema = &hir::Semantics::new(db);\n-    let mut res = hover_impl(sema, file_range, config)?;\n+    let file = sema.parse(file_id).syntax().clone();\n+    let mut res = if range.is_empty() {\n+        hover_simple(sema, FilePosition { file_id, offset: range.start() }, file, config)\n+    } else {\n+        hover_ranged(sema, frange, file, config)\n+    }?;\n+\n     if let HoverDocFormat::PlainText = config.format {\n         res.info.markup = remove_markdown(res.info.markup.as_str()).into();\n     }\n     Some(res)\n }\n \n-fn hover_impl(\n+fn hover_simple(\n     sema: &Semantics<'_, RootDatabase>,\n-    FileRange { file_id, range }: FileRange,\n+    FilePosition { file_id, offset }: FilePosition,\n+    file: SyntaxNode,\n     config: &HoverConfig,\n ) -> Option<RangeInfo<HoverResult>> {\n-    let file = sema.parse(file_id).syntax().clone();\n-    if !range.is_empty() {\n-        return hover_ranged(&file, range, sema, config);\n-    }\n-    let offset = range.start();\n-\n     let original_token = pick_best_token(file.token_at_offset(offset), |kind| match kind {\n-        IDENT | INT_NUMBER | LIFETIME_IDENT | T![self] | T![super] | T![crate] | T![Self] => 4,\n+        IDENT\n+        | INT_NUMBER\n+        | LIFETIME_IDENT\n+        | T![self]\n+        | T![super]\n+        | T![crate]\n+        | T![Self]\n+        | T![_] => 4,\n         // index and prefix ops\n         T!['['] | T![']'] | T![?] | T![*] | T![-] | T![!] => 3,\n         kind if kind.is_keyword() => 2,\n@@ -142,19 +150,18 @@ fn hover_impl(\n     } else {\n         sema.descend_into_macros_with_same_text(original_token.clone())\n     };\n+    let descended = || descended.iter();\n \n-    // try lint hover\n-    let result = descended\n-        .iter()\n+    let result = descended()\n+        // try lint hover\n         .find_map(|token| {\n             // FIXME: Definition should include known lints and the like instead of having this special case here\n             let attr = token.parent_ancestors().find_map(ast::Attr::cast)?;\n             render::try_for_lint(&attr, token)\n         })\n-        // try item definitions\n+        // try definitions\n         .or_else(|| {\n-            descended\n-                .iter()\n+            descended()\n                 .filter_map(|token| {\n                     let node = token.parent()?;\n                     let class = IdentClass::classify_token(sema, token)?;\n@@ -175,10 +182,12 @@ fn hover_impl(\n                 })\n         })\n         // try keywords\n-        .or_else(|| descended.iter().find_map(|token| render::keyword(sema, config, token)))\n-        // try rest item hover\n+        .or_else(|| descended().find_map(|token| render::keyword(sema, config, token)))\n+        // try _ hovers\n+        .or_else(|| descended().find_map(|token| render::underscore(sema, config, token)))\n+        // try rest pattern hover\n         .or_else(|| {\n-            descended.iter().find_map(|token| {\n+            descended().find_map(|token| {\n                 if token.kind() != DOT2 {\n                     return None;\n                 }\n@@ -194,51 +203,24 @@ fn hover_impl(\n             })\n         });\n \n-    result\n-        .map(|mut res: HoverResult| {\n-            res.actions = dedupe_or_merge_hover_actions(res.actions);\n-            RangeInfo::new(original_token.text_range(), res)\n-        })\n-        // fallback to type hover if there aren't any other suggestions\n-        // this finds its own range instead of using the closest token's range\n-        .or_else(|| {\n-            descended.iter().find_map(|token| hover_type_fallback(sema, config, token, token))\n-        })\n-}\n-\n-pub(crate) fn hover_for_definition(\n-    sema: &Semantics<'_, RootDatabase>,\n-    file_id: FileId,\n-    definition: Definition,\n-    node: &SyntaxNode,\n-    config: &HoverConfig,\n-) -> Option<HoverResult> {\n-    let famous_defs = match &definition {\n-        Definition::BuiltinType(_) => Some(FamousDefs(sema, sema.scope(node)?.krate())),\n-        _ => None,\n-    };\n-    render::definition(sema.db, definition, famous_defs.as_ref(), config).map(|markup| {\n-        HoverResult {\n-            markup: render::process_markup(sema.db, definition, &markup, config),\n-            actions: show_implementations_action(sema.db, definition)\n-                .into_iter()\n-                .chain(show_fn_references_action(sema.db, definition))\n-                .chain(runnable_action(sema, definition, file_id))\n-                .chain(goto_type_action_for_def(sema.db, definition))\n-                .collect(),\n-        }\n+    result.map(|mut res: HoverResult| {\n+        res.actions = dedupe_or_merge_hover_actions(res.actions);\n+        RangeInfo::new(original_token.text_range(), res)\n     })\n }\n \n fn hover_ranged(\n-    file: &SyntaxNode,\n-    range: syntax::TextRange,\n     sema: &Semantics<'_, RootDatabase>,\n+    FileRange { range, .. }: FileRange,\n+    file: SyntaxNode,\n     config: &HoverConfig,\n ) -> Option<RangeInfo<HoverResult>> {\n     // FIXME: make this work in attributes\n-    let expr_or_pat =\n-        file.covering_element(range).ancestors().find_map(Either::<ast::Expr, ast::Pat>::cast)?;\n+    let expr_or_pat = file\n+        .covering_element(range)\n+        .ancestors()\n+        .take_while(|it| ast::MacroCall::can_cast(it.kind()) || !ast::Item::can_cast(it.kind()))\n+        .find_map(Either::<ast::Expr, ast::Pat>::cast)?;\n     let res = match &expr_or_pat {\n         Either::Left(ast::Expr::TryExpr(try_expr)) => render::try_expr(sema, config, try_expr),\n         Either::Left(ast::Expr::PrefixExpr(prefix_expr))\n@@ -248,7 +230,7 @@ fn hover_ranged(\n         }\n         _ => None,\n     };\n-    let res = res.or_else(|| render::type_info(sema, config, &expr_or_pat));\n+    let res = res.or_else(|| render::type_info_of(sema, config, &expr_or_pat));\n     res.map(|it| {\n         let range = match expr_or_pat {\n             Either::Left(it) => it.syntax().text_range(),\n@@ -258,37 +240,31 @@ fn hover_ranged(\n     })\n }\n \n-fn hover_type_fallback(\n+pub(crate) fn hover_for_definition(\n     sema: &Semantics<'_, RootDatabase>,\n+    file_id: FileId,\n+    definition: Definition,\n+    node: &SyntaxNode,\n     config: &HoverConfig,\n-    token: &SyntaxToken,\n-    original_token: &SyntaxToken,\n-) -> Option<RangeInfo<HoverResult>> {\n-    let node =\n-        token.parent_ancestors().take_while(|it| !ast::Item::can_cast(it.kind())).find(|n| {\n-            ast::Expr::can_cast(n.kind())\n-                || ast::Pat::can_cast(n.kind())\n-                || ast::Type::can_cast(n.kind())\n-        })?;\n-\n-    let expr_or_pat = match_ast! {\n-        match node {\n-            ast::Expr(it) => Either::Left(it),\n-            ast::Pat(it) => Either::Right(it),\n-            // If this node is a MACRO_CALL, it means that `descend_into_macros_many` failed to resolve.\n-            // (e.g expanding a builtin macro). So we give up here.\n-            ast::MacroCall(_it) => return None,\n-            _ => return None,\n-        }\n+) -> Option<HoverResult> {\n+    let famous_defs = match &definition {\n+        Definition::BuiltinType(_) => Some(FamousDefs(sema, sema.scope(node)?.krate())),\n+        _ => None,\n     };\n-\n-    let res = render::type_info(sema, config, &expr_or_pat)?;\n-\n-    let range = sema\n-        .original_range_opt(&node)\n-        .map(|frange| frange.range)\n-        .unwrap_or_else(|| original_token.text_range());\n-    Some(RangeInfo::new(range, res))\n+    render::definition(sema.db, definition, famous_defs.as_ref(), config).map(|markup| {\n+        HoverResult {\n+            markup: render::process_markup(sema.db, definition, &markup, config),\n+            actions: [\n+                show_implementations_action(sema.db, definition),\n+                show_fn_references_action(sema.db, definition),\n+                runnable_action(sema, definition, file_id),\n+                goto_type_action_for_def(sema.db, definition),\n+            ]\n+            .into_iter()\n+            .flatten()\n+            .collect(),\n+        }\n+    })\n }\n \n fn show_implementations_action(db: &RootDatabase, def: Definition) -> Option<HoverAction> {"}, {"sha": "22611cfb892f8de5a174a3829934f78c855ffd6e", "filename": "crates/ide/src/hover/render.rs", "status": "modified", "additions": 79, "deletions": 29, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/303737dad78406e5531cb23c5b6e83bc6c6d56fe/crates%2Fide%2Fsrc%2Fhover%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/303737dad78406e5531cb23c5b6e83bc6c6d56fe/crates%2Fide%2Fsrc%2Fhover%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fhover%2Frender.rs?ref=303737dad78406e5531cb23c5b6e83bc6c6d56fe", "patch": "@@ -29,7 +29,7 @@ use crate::{\n     HoverAction, HoverConfig, HoverResult, Markup,\n };\n \n-pub(super) fn type_info(\n+pub(super) fn type_info_of(\n     sema: &Semantics<'_, RootDatabase>,\n     _config: &HoverConfig,\n     expr_or_pat: &Either<ast::Expr, ast::Pat>,\n@@ -38,34 +38,7 @@ pub(super) fn type_info(\n         Either::Left(expr) => sema.type_of_expr(expr)?,\n         Either::Right(pat) => sema.type_of_pat(pat)?,\n     };\n-\n-    let mut res = HoverResult::default();\n-    let mut targets: Vec<hir::ModuleDef> = Vec::new();\n-    let mut push_new_def = |item: hir::ModuleDef| {\n-        if !targets.contains(&item) {\n-            targets.push(item);\n-        }\n-    };\n-    walk_and_push_ty(sema.db, &original, &mut push_new_def);\n-\n-    res.markup = if let Some(adjusted_ty) = adjusted {\n-        walk_and_push_ty(sema.db, &adjusted_ty, &mut push_new_def);\n-        let original = original.display(sema.db).to_string();\n-        let adjusted = adjusted_ty.display(sema.db).to_string();\n-        let static_text_diff_len = \"Coerced to: \".len() - \"Type: \".len();\n-        format!(\n-            \"```text\\nType: {:>apad$}\\nCoerced to: {:>opad$}\\n```\\n\",\n-            original,\n-            adjusted,\n-            apad = static_text_diff_len + adjusted.len().max(original.len()),\n-            opad = original.len(),\n-        )\n-        .into()\n-    } else {\n-        Markup::fenced_block(&original.display(sema.db))\n-    };\n-    res.actions.push(HoverAction::goto_type_from_targets(sema.db, targets));\n-    Some(res)\n+    type_info(sema, _config, original, adjusted)\n }\n \n pub(super) fn try_expr(\n@@ -217,6 +190,48 @@ pub(super) fn deref_expr(\n     Some(res)\n }\n \n+pub(super) fn underscore(\n+    sema: &Semantics<'_, RootDatabase>,\n+    config: &HoverConfig,\n+    token: &SyntaxToken,\n+) -> Option<HoverResult> {\n+    if token.kind() != T![_] {\n+        return None;\n+    }\n+    let parent = token.parent()?;\n+    let _it = match_ast! {\n+        match parent {\n+            ast::InferType(it) => it,\n+            ast::UnderscoreExpr(it) => return type_info_of(sema, config, &Either::Left(ast::Expr::UnderscoreExpr(it))),\n+            ast::WildcardPat(it) => return type_info_of(sema, config, &Either::Right(ast::Pat::WildcardPat(it))),\n+            _ => return None,\n+        }\n+    };\n+    // let it = infer_type.syntax().parent()?;\n+    // match_ast! {\n+    //     match it {\n+    //         ast::LetStmt(_it) => (),\n+    //         ast::Param(_it) => (),\n+    //         ast::RetType(_it) => (),\n+    //         ast::TypeArg(_it) => (),\n+\n+    //         ast::CastExpr(_it) => (),\n+    //         ast::ParenType(_it) => (),\n+    //         ast::TupleType(_it) => (),\n+    //         ast::PtrType(_it) => (),\n+    //         ast::RefType(_it) => (),\n+    //         ast::ArrayType(_it) => (),\n+    //         ast::SliceType(_it) => (),\n+    //         ast::ForType(_it) => (),\n+    //         _ => return None,\n+    //     }\n+    // }\n+\n+    // FIXME: https://github.com/rust-lang/rust-analyzer/issues/11762, this currently always returns Unknown\n+    // type_info(sema, config, sema.resolve_type(&ast::Type::InferType(it))?, None)\n+    None\n+}\n+\n pub(super) fn keyword(\n     sema: &Semantics<'_, RootDatabase>,\n     config: &HoverConfig,\n@@ -458,6 +473,41 @@ pub(super) fn definition(\n     markup(docs, label, mod_path)\n }\n \n+fn type_info(\n+    sema: &Semantics<'_, RootDatabase>,\n+    _config: &HoverConfig,\n+    original: hir::Type,\n+    adjusted: Option<hir::Type>,\n+) -> Option<HoverResult> {\n+    let mut res = HoverResult::default();\n+    let mut targets: Vec<hir::ModuleDef> = Vec::new();\n+    let mut push_new_def = |item: hir::ModuleDef| {\n+        if !targets.contains(&item) {\n+            targets.push(item);\n+        }\n+    };\n+    walk_and_push_ty(sema.db, &original, &mut push_new_def);\n+\n+    res.markup = if let Some(adjusted_ty) = adjusted {\n+        walk_and_push_ty(sema.db, &adjusted_ty, &mut push_new_def);\n+        let original = original.display(sema.db).to_string();\n+        let adjusted = adjusted_ty.display(sema.db).to_string();\n+        let static_text_diff_len = \"Coerced to: \".len() - \"Type: \".len();\n+        format!(\n+            \"```text\\nType: {:>apad$}\\nCoerced to: {:>opad$}\\n```\\n\",\n+            original,\n+            adjusted,\n+            apad = static_text_diff_len + adjusted.len().max(original.len()),\n+            opad = original.len(),\n+        )\n+        .into()\n+    } else {\n+        Markup::fenced_block(&original.display(sema.db))\n+    };\n+    res.actions.push(HoverAction::goto_type_from_targets(sema.db, targets));\n+    Some(res)\n+}\n+\n fn render_builtin_attr(db: &RootDatabase, attr: hir::BuiltinAttr) -> Option<Markup> {\n     let name = attr.name(db);\n     let desc = format!(\"#[{name}]\");"}, {"sha": "2830212add8ebd40033d6c318c2351210b3ce28c", "filename": "crates/ide/src/hover/tests.rs", "status": "modified", "additions": 93, "deletions": 73, "changes": 166, "blob_url": "https://github.com/rust-lang/rust/blob/303737dad78406e5531cb23c5b6e83bc6c6d56fe/crates%2Fide%2Fsrc%2Fhover%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/303737dad78406e5531cb23c5b6e83bc6c6d56fe/crates%2Fide%2Fsrc%2Fhover%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fhover%2Ftests.rs?ref=303737dad78406e5531cb23c5b6e83bc6c6d56fe", "patch": "@@ -213,38 +213,21 @@ m!(ab$0c);\n     );\n }\n \n-#[test]\n-fn hover_shows_type_of_an_expression() {\n-    check(\n-        r#\"\n-pub fn foo() -> u32 { 1 }\n-\n-fn main() {\n-    let foo_test = foo()$0;\n-}\n-\"#,\n-        expect![[r#\"\n-            *foo()*\n-            ```rust\n-            u32\n-            ```\n-        \"#]],\n-    );\n-}\n-\n #[test]\n fn hover_remove_markdown_if_configured() {\n     check_hover_no_markdown(\n         r#\"\n pub fn foo() -> u32 { 1 }\n \n fn main() {\n-    let foo_test = foo()$0;\n+    let foo_test = foo$0();\n }\n \"#,\n         expect![[r#\"\n-            *foo()*\n-            u32\n+            *foo*\n+            test\n+\n+            pub fn foo() -> u32\n         \"#]],\n     );\n }\n@@ -304,33 +287,6 @@ fn main() { let foo_test = fo$0o(); }\n             \"#]],\n     );\n \n-    // Multiple candidates but results are ambiguous.\n-    check(\n-        r#\"\n-//- /a.rs\n-pub fn foo() -> u32 { 1 }\n-\n-//- /b.rs\n-pub fn foo() -> &str { \"\" }\n-\n-//- /c.rs\n-pub fn foo(a: u32, b: u32) {}\n-\n-//- /main.rs\n-mod a;\n-mod b;\n-mod c;\n-\n-fn main() { let foo_test = fo$0o(); }\n-        \"#,\n-        expect![[r#\"\n-                *foo*\n-                ```rust\n-                {unknown}\n-                ```\n-            \"#]],\n-    );\n-\n     // Use literal `crate` in path\n     check(\n         r#\"\n@@ -1194,33 +1150,19 @@ fn test_hover_through_func_in_macro_recursive() {\n macro_rules! id_deep { ($($tt:tt)*) => { $($tt)* } }\n macro_rules! id { ($($tt:tt)*) => { id_deep!($($tt)*) } }\n fn bar() -> u32 { 0 }\n-fn foo() { let a = id!([0u32, bar($0)] ); }\n+fn foo() { let a = id!([0u32, bar$0()] ); }\n \"#,\n         expect![[r#\"\n-                *bar()*\n-                ```rust\n-                u32\n-                ```\n-            \"#]],\n-    );\n-}\n+            *bar*\n \n-#[test]\n-fn test_hover_through_literal_string_in_macro() {\n-    check(\n-        r#\"\n-macro_rules! arr { ($($tt:tt)*) => { [$($tt)*] } }\n-fn foo() {\n-    let mastered_for_itunes = \"\";\n-    let _ = arr!(\"Tr$0acks\", &mastered_for_itunes);\n-}\n-\"#,\n-        expect![[r#\"\n-                *\"Tracks\"*\n-                ```rust\n-                &str\n-                ```\n-            \"#]],\n+            ```rust\n+            test\n+            ```\n+\n+            ```rust\n+            fn bar() -> u32\n+            ```\n+        \"#]],\n     );\n }\n \n@@ -5592,3 +5534,81 @@ fn main() {\n         \"#]],\n     );\n }\n+\n+#[test]\n+fn hover_underscore_pat() {\n+    check(\n+        r#\"\n+fn main() {\n+    let _$0 = 0;\n+}\n+\"#,\n+        expect![[r#\"\n+            *_*\n+            ```rust\n+            i32\n+            ```\n+        \"#]],\n+    );\n+    check(\n+        r#\"\n+fn main() {\n+    let (_$0,) = (0,);\n+}\n+\"#,\n+        expect![[r#\"\n+            *_*\n+            ```rust\n+            i32\n+            ```\n+        \"#]],\n+    );\n+}\n+\n+#[test]\n+fn hover_underscore_expr() {\n+    check(\n+        r#\"\n+fn main() {\n+    _$0 = 0;\n+}\n+\"#,\n+        expect![[r#\"\n+            *_*\n+            ```rust\n+            i32\n+            ```\n+        \"#]],\n+    );\n+    check(\n+        r#\"\n+fn main() {\n+    (_$0,) = (0,);\n+}\n+\"#,\n+        expect![[r#\"\n+            *_*\n+            ```rust\n+            i32\n+            ```\n+        \"#]],\n+    );\n+}\n+\n+#[test]\n+fn hover_underscore_type() {\n+    check_hover_no_result(\n+        r#\"\n+fn main() {\n+    let x: _$0 = 0;\n+}\n+\"#,\n+    );\n+    check_hover_no_result(\n+        r#\"\n+fn main() {\n+    let x: (_$0,) = (0,);\n+}\n+\"#,\n+    );\n+}"}]}