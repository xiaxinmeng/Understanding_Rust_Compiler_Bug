{"sha": "f59cd1a4a0d6c369025a7014e838d25f91d478e4", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY1OWNkMWE0YTBkNmMzNjkwMjVhNzAxNGU4MzhkMjVmOTFkNDc4ZTQ=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2019-07-09T07:50:18Z"}, "committer": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2019-07-09T07:50:18Z"}, "message": "Merge #1515\n\n1515: Trait environment r=matklad a=flodiebold\n\nThis adds the environment, i.e. the set of `where` clauses in scope, when solving trait goals. That means that e.g. in\r\n```rust\r\nfn foo<T: SomeTrait>(t: T) {}\r\n```\r\n, we are able to complete methods of `SomeTrait` on the `t`. This affects the trait APIs quite a bit (since every method that needs to be able to solve for some trait needs to get this environment somehow), so I thought I'd do it rather sooner than later ;)\n\nCo-authored-by: Florian Diebold <flodiebold@gmail.com>", "tree": {"sha": "2c4b9dc868a87507ed63e9dc46530cc60f38ae64", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2c4b9dc868a87507ed63e9dc46530cc60f38ae64"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f59cd1a4a0d6c369025a7014e838d25f91d478e4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f59cd1a4a0d6c369025a7014e838d25f91d478e4", "html_url": "https://github.com/rust-lang/rust/commit/f59cd1a4a0d6c369025a7014e838d25f91d478e4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f59cd1a4a0d6c369025a7014e838d25f91d478e4/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "parents": [{"sha": "35f28c538a9b9f461bb4db1a78d02e9f02a3d296", "url": "https://api.github.com/repos/rust-lang/rust/commits/35f28c538a9b9f461bb4db1a78d02e9f02a3d296", "html_url": "https://github.com/rust-lang/rust/commit/35f28c538a9b9f461bb4db1a78d02e9f02a3d296"}, {"sha": "9afbf2dff43dee3227358f10162d4c77d192ce7a", "url": "https://api.github.com/repos/rust-lang/rust/commits/9afbf2dff43dee3227358f10162d4c77d192ce7a", "html_url": "https://github.com/rust-lang/rust/commit/9afbf2dff43dee3227358f10162d4c77d192ce7a"}], "stats": {"total": 405, "additions": 286, "deletions": 119}, "files": [{"sha": "b0c02763154f2decd9b065d2712930e229f650dc", "filename": "crates/ra_hir/src/db.rs", "status": "modified", "additions": 3, "deletions": 10, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/f59cd1a4a0d6c369025a7014e838d25f91d478e4/crates%2Fra_hir%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f59cd1a4a0d6c369025a7014e838d25f91d478e4/crates%2Fra_hir%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fdb.rs?ref=f59cd1a4a0d6c369025a7014e838d25f91d478e4", "patch": "@@ -213,18 +213,11 @@ pub trait HirDatabase: DefDatabase + AstDatabase {\n     #[salsa::invoke(crate::ty::traits::chalk::impl_datum_query)]\n     fn impl_datum(&self, krate: Crate, impl_id: chalk_ir::ImplId) -> Arc<chalk_rust_ir::ImplDatum>;\n \n-    #[salsa::invoke(crate::ty::traits::implements_query)]\n-    fn implements(\n+    #[salsa::invoke(crate::ty::traits::solve_query)]\n+    fn solve(\n         &self,\n         krate: Crate,\n-        goal: crate::ty::Canonical<crate::ty::TraitRef>,\n-    ) -> Option<crate::ty::traits::Solution>;\n-\n-    #[salsa::invoke(crate::ty::traits::normalize_query)]\n-    fn normalize(\n-        &self,\n-        krate: Crate,\n-        goal: crate::ty::Canonical<crate::ty::ProjectionPredicate>,\n+        goal: crate::ty::Canonical<crate::ty::InEnvironment<crate::ty::Obligation>>,\n     ) -> Option<crate::ty::traits::Solution>;\n }\n "}, {"sha": "9accffcbc8f30cf40ed21e8876a632faba7fa68e", "filename": "crates/ra_hir/src/ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f59cd1a4a0d6c369025a7014e838d25f91d478e4/crates%2Fra_hir%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f59cd1a4a0d6c369025a7014e838d25f91d478e4/crates%2Fra_hir%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty.rs?ref=f59cd1a4a0d6c369025a7014e838d25f91d478e4", "patch": "@@ -26,7 +26,7 @@ pub(crate) use lower::{\n     callable_item_sig, generic_defaults_query, generic_predicates_query, type_for_def,\n     type_for_field, TypableDef,\n };\n-pub(crate) use traits::ProjectionPredicate;\n+pub(crate) use traits::{Environment, InEnvironment, Obligation, ProjectionPredicate};\n \n /// A type constructor or type name: this might be something like the primitive\n /// type `bool`, a struct like `Vec`, or things like function pointers or"}, {"sha": "c265138719c481bbad043d3ce0f130b797bd2bf3", "filename": "crates/ra_hir/src/ty/autoderef.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f59cd1a4a0d6c369025a7014e838d25f91d478e4/crates%2Fra_hir%2Fsrc%2Fty%2Fautoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f59cd1a4a0d6c369025a7014e838d25f91d478e4/crates%2Fra_hir%2Fsrc%2Fty%2Fautoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Fautoderef.rs?ref=f59cd1a4a0d6c369025a7014e838d25f91d478e4", "patch": "@@ -52,6 +52,8 @@ fn deref_by_trait(\n \n     // FIXME make the Canonical handling nicer\n \n+    let env = super::lower::trait_env(db, resolver);\n+\n     let projection = super::traits::ProjectionPredicate {\n         ty: Ty::Bound(0),\n         projection_ty: super::ProjectionTy {\n@@ -60,9 +62,13 @@ fn deref_by_trait(\n         },\n     };\n \n-    let canonical = super::Canonical { num_vars: 1 + ty.num_vars, value: projection };\n+    let obligation = super::Obligation::Projection(projection);\n+\n+    let in_env = super::traits::InEnvironment { value: obligation, environment: env };\n+\n+    let canonical = super::Canonical { num_vars: 1 + ty.num_vars, value: in_env };\n \n-    let solution = db.normalize(krate, canonical)?;\n+    let solution = db.solve(krate, canonical)?;\n \n     match &solution {\n         Solution::Unique(vars) => {"}, {"sha": "26ddf031709542eac65891d92c64ec1542a5b8a5", "filename": "crates/ra_hir/src/ty/infer.rs", "status": "modified", "additions": 23, "deletions": 46, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/f59cd1a4a0d6c369025a7014e838d25f91d478e4/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f59cd1a4a0d6c369025a7014e838d25f91d478e4/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs?ref=f59cd1a4a0d6c369025a7014e838d25f91d478e4", "patch": "@@ -27,9 +27,10 @@ use ra_prof::profile;\n use test_utils::tested_by;\n \n use super::{\n-    autoderef, method_resolution, op, primitive,\n+    autoderef, lower, method_resolution, op, primitive,\n     traits::{Guidance, Obligation, ProjectionPredicate, Solution},\n-    ApplicationTy, CallableDef, ProjectionTy, Substs, TraitRef, Ty, TypableDef, TypeCtor,\n+    ApplicationTy, CallableDef, Environment, InEnvironment, ProjectionTy, Substs, TraitRef, Ty,\n+    TypableDef, TypeCtor,\n };\n use crate::{\n     adt::VariantDef,\n@@ -165,6 +166,7 @@ struct InferenceContext<'a, D: HirDatabase> {\n     body: Arc<Body>,\n     resolver: Resolver,\n     var_unification_table: InPlaceUnificationTable<TypeVarId>,\n+    trait_env: Arc<Environment>,\n     obligations: Vec<Obligation>,\n     method_resolutions: FxHashMap<ExprId, Function>,\n     field_resolutions: FxHashMap<ExprId, StructField>,\n@@ -188,6 +190,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n             var_unification_table: InPlaceUnificationTable::new(),\n             obligations: Vec::default(),\n             return_ty: Ty::Unknown, // set in collect_fn_signature\n+            trait_env: lower::trait_env(db, &resolver),\n             db,\n             body,\n             resolver,\n@@ -328,51 +331,25 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n     fn resolve_obligations_as_possible(&mut self) {\n         let obligations = mem::replace(&mut self.obligations, Vec::new());\n         for obligation in obligations {\n-            match &obligation {\n-                Obligation::Trait(tr) => {\n-                    let canonicalized = self.canonicalizer().canonicalize_trait_ref(tr.clone());\n-                    let solution = self\n-                        .db\n-                        .implements(self.resolver.krate().unwrap(), canonicalized.value.clone());\n-                    match solution {\n-                        Some(Solution::Unique(substs)) => {\n-                            canonicalized.apply_solution(self, substs.0);\n-                        }\n-                        Some(Solution::Ambig(Guidance::Definite(substs))) => {\n-                            canonicalized.apply_solution(self, substs.0);\n-                            self.obligations.push(obligation);\n-                        }\n-                        Some(_) => {\n-                            // FIXME use this when trying to resolve everything at the end\n-                            self.obligations.push(obligation);\n-                        }\n-                        None => {\n-                            // FIXME obligation cannot be fulfilled => diagnostic\n-                        }\n-                    };\n+            let in_env = InEnvironment::new(self.trait_env.clone(), obligation.clone());\n+            let canonicalized = self.canonicalizer().canonicalize_obligation(in_env);\n+            let solution =\n+                self.db.solve(self.resolver.krate().unwrap(), canonicalized.value.clone());\n+\n+            match solution {\n+                Some(Solution::Unique(substs)) => {\n+                    canonicalized.apply_solution(self, substs.0);\n                 }\n-                Obligation::Projection(pr) => {\n-                    let canonicalized = self.canonicalizer().canonicalize_projection(pr.clone());\n-                    let solution = self\n-                        .db\n-                        .normalize(self.resolver.krate().unwrap(), canonicalized.value.clone());\n-\n-                    match solution {\n-                        Some(Solution::Unique(substs)) => {\n-                            canonicalized.apply_solution(self, substs.0);\n-                        }\n-                        Some(Solution::Ambig(Guidance::Definite(substs))) => {\n-                            canonicalized.apply_solution(self, substs.0);\n-                            self.obligations.push(obligation);\n-                        }\n-                        Some(_) => {\n-                            // FIXME use this when trying to resolve everything at the end\n-                            self.obligations.push(obligation);\n-                        }\n-                        None => {\n-                            // FIXME obligation cannot be fulfilled => diagnostic\n-                        }\n-                    };\n+                Some(Solution::Ambig(Guidance::Definite(substs))) => {\n+                    canonicalized.apply_solution(self, substs.0);\n+                    self.obligations.push(obligation);\n+                }\n+                Some(_) => {\n+                    // FIXME use this when trying to resolve everything at the end\n+                    self.obligations.push(obligation);\n+                }\n+                None => {\n+                    // FIXME obligation cannot be fulfilled => diagnostic\n                 }\n             };\n         }"}, {"sha": "e7e8825d1acdc1f97bb01f2a8f2fa3910e3db111", "filename": "crates/ra_hir/src/ty/infer/unify.rs", "status": "modified", "additions": 21, "deletions": 13, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/f59cd1a4a0d6c369025a7014e838d25f91d478e4/crates%2Fra_hir%2Fsrc%2Fty%2Finfer%2Funify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f59cd1a4a0d6c369025a7014e838d25f91d478e4/crates%2Fra_hir%2Fsrc%2Fty%2Finfer%2Funify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Finfer%2Funify.rs?ref=f59cd1a4a0d6c369025a7014e838d25f91d478e4", "patch": "@@ -1,8 +1,10 @@\n //! Unification and canonicalization logic.\n \n-use super::InferenceContext;\n+use super::{InferenceContext, Obligation};\n use crate::db::HirDatabase;\n-use crate::ty::{Canonical, InferTy, ProjectionPredicate, ProjectionTy, TraitRef, Ty};\n+use crate::ty::{\n+    Canonical, InEnvironment, InferTy, ProjectionPredicate, ProjectionTy, TraitRef, Ty,\n+};\n \n impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n     pub(super) fn canonicalizer<'b>(&'b mut self) -> Canonicalizer<'a, 'b, D>\n@@ -105,22 +107,28 @@ where\n         ProjectionPredicate { ty, projection_ty }\n     }\n \n-    pub fn canonicalize_ty(mut self, ty: Ty) -> Canonicalized<Ty> {\n-        let result = self.do_canonicalize_ty(ty);\n-        self.into_canonicalized(result)\n-    }\n+    // FIXME: add some point, we need to introduce a `Fold` trait that abstracts\n+    // over all the things that can be canonicalized (like Chalk and rustc have)\n \n-    pub fn canonicalize_trait_ref(mut self, trait_ref: TraitRef) -> Canonicalized<TraitRef> {\n-        let result = self.do_canonicalize_trait_ref(trait_ref);\n+    pub(crate) fn canonicalize_ty(mut self, ty: Ty) -> Canonicalized<Ty> {\n+        let result = self.do_canonicalize_ty(ty);\n         self.into_canonicalized(result)\n     }\n \n-    pub fn canonicalize_projection(\n+    pub(crate) fn canonicalize_obligation(\n         mut self,\n-        projection: ProjectionPredicate,\n-    ) -> Canonicalized<ProjectionPredicate> {\n-        let result = self.do_canonicalize_projection_predicate(projection);\n-        self.into_canonicalized(result)\n+        obligation: InEnvironment<Obligation>,\n+    ) -> Canonicalized<InEnvironment<Obligation>> {\n+        let result = match obligation.value {\n+            Obligation::Trait(tr) => Obligation::Trait(self.do_canonicalize_trait_ref(tr)),\n+            Obligation::Projection(pr) => {\n+                Obligation::Projection(self.do_canonicalize_projection_predicate(pr))\n+            }\n+        };\n+        self.into_canonicalized(InEnvironment {\n+            value: result,\n+            environment: obligation.environment,\n+        })\n     }\n }\n "}, {"sha": "ca47d6e96b1aa6cb521e1c6ce7055a5eb65dbfff", "filename": "crates/ra_hir/src/ty/lower.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f59cd1a4a0d6c369025a7014e838d25f91d478e4/crates%2Fra_hir%2Fsrc%2Fty%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f59cd1a4a0d6c369025a7014e838d25f91d478e4/crates%2Fra_hir%2Fsrc%2Fty%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Flower.rs?ref=f59cd1a4a0d6c369025a7014e838d25f91d478e4", "patch": "@@ -317,6 +317,18 @@ pub(crate) fn type_for_field(db: &impl HirDatabase, field: StructField) -> Ty {\n     Ty::from_hir(db, &resolver, type_ref)\n }\n \n+pub(crate) fn trait_env(db: &impl HirDatabase, resolver: &Resolver) -> Arc<super::Environment> {\n+    let predicates = resolver\n+        .where_predicates_in_scope()\n+        .map(|pred| {\n+            TraitRef::for_where_predicate(db, &resolver, pred)\n+                .map_or(GenericPredicate::Error, GenericPredicate::Implemented)\n+        })\n+        .collect::<Vec<_>>();\n+\n+    Arc::new(super::Environment { predicates })\n+}\n+\n /// Resolve the where clause(s) of an item with generics.\n pub(crate) fn generic_predicates_query(\n     db: &impl HirDatabase,"}, {"sha": "35382043679fc1116d1e5630cb825483dc4445aa", "filename": "crates/ra_hir/src/ty/method_resolution.rs", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/f59cd1a4a0d6c369025a7014e838d25f91d478e4/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f59cd1a4a0d6c369025a7014e838d25f91d478e4/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs?ref=f59cd1a4a0d6c369025a7014e838d25f91d478e4", "patch": "@@ -7,7 +7,7 @@ use std::sync::Arc;\n use arrayvec::ArrayVec;\n use rustc_hash::FxHashMap;\n \n-use super::{autoderef, Canonical, TraitRef};\n+use super::{autoderef, lower, Canonical, Environment, InEnvironment, TraitRef};\n use crate::{\n     generics::HasGenericParams,\n     impl_block::{ImplBlock, ImplId, ImplItem},\n@@ -200,6 +200,8 @@ fn iterate_trait_method_candidates<T>(\n     mut callback: impl FnMut(&Ty, Function) -> Option<T>,\n ) -> Option<T> {\n     let krate = resolver.krate()?;\n+    // FIXME: maybe put the trait_env behind a query (need to figure out good input parameters for that)\n+    let env = lower::trait_env(db, resolver);\n     'traits: for t in resolver.traits_in_scope(db) {\n         let data = t.trait_data(db);\n         // we'll be lazy about checking whether the type implements the\n@@ -211,8 +213,8 @@ fn iterate_trait_method_candidates<T>(\n                 let data = m.data(db);\n                 if name.map_or(true, |name| data.name() == name) && data.has_self_param() {\n                     if !known_implemented {\n-                        let trait_ref = canonical_trait_ref(db, t, ty.clone());\n-                        if db.implements(krate, trait_ref).is_none() {\n+                        let goal = generic_implements_goal(db, env.clone(), t, ty.clone());\n+                        if db.solve(krate, goal).is_none() {\n                             continue 'traits;\n                         }\n                     }\n@@ -279,11 +281,12 @@ impl Ty {\n \n /// This creates Substs for a trait with the given Self type and type variables\n /// for all other parameters, to query Chalk with it.\n-fn canonical_trait_ref(\n+fn generic_implements_goal(\n     db: &impl HirDatabase,\n+    env: Arc<Environment>,\n     trait_: Trait,\n     self_ty: Canonical<Ty>,\n-) -> Canonical<TraitRef> {\n+) -> Canonical<InEnvironment<super::Obligation>> {\n     let mut substs = Vec::new();\n     let generics = trait_.generic_params(db);\n     let num_vars = self_ty.num_vars;\n@@ -296,8 +299,8 @@ fn canonical_trait_ref(\n             .enumerate()\n             .map(|(i, _p)| Ty::Bound((i + num_vars) as u32)),\n     );\n-    Canonical {\n-        num_vars: substs.len() - 1 + self_ty.num_vars,\n-        value: TraitRef { trait_, substs: substs.into() },\n-    }\n+    let num_vars = substs.len() - 1 + self_ty.num_vars;\n+    let trait_ref = TraitRef { trait_, substs: substs.into() };\n+    let obligation = super::Obligation::Trait(trait_ref);\n+    Canonical { num_vars, value: InEnvironment::new(env, obligation) }\n }"}, {"sha": "2410602a6b72699cc3d93289a312ffea150da1f5", "filename": "crates/ra_hir/src/ty/tests.rs", "status": "modified", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/f59cd1a4a0d6c369025a7014e838d25f91d478e4/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f59cd1a4a0d6c369025a7014e838d25f91d478e4/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs?ref=f59cd1a4a0d6c369025a7014e838d25f91d478e4", "patch": "@@ -3003,6 +3003,85 @@ fn test(o: O<S>) {\n     assert_eq!(t, \"&str\");\n }\n \n+#[test]\n+fn generic_param_env_1() {\n+    let t = type_at(\n+        r#\"\n+//- /main.rs\n+trait Clone {}\n+trait Trait { fn foo(self) -> u128; }\n+struct S;\n+impl Clone for S {}\n+impl<T> Trait for T where T: Clone {}\n+fn test<T: Clone>(t: T) { t.foo()<|>; }\n+\"#,\n+    );\n+    assert_eq!(t, \"u128\");\n+}\n+\n+#[test]\n+fn generic_param_env_1_not_met() {\n+    let t = type_at(\n+        r#\"\n+//- /main.rs\n+trait Clone {}\n+trait Trait { fn foo(self) -> u128; }\n+struct S;\n+impl Clone for S {}\n+impl<T> Trait for T where T: Clone {}\n+fn test<T>(t: T) { t.foo()<|>; }\n+\"#,\n+    );\n+    assert_eq!(t, \"{unknown}\");\n+}\n+\n+#[test]\n+fn generic_param_env_2() {\n+    let t = type_at(\n+        r#\"\n+//- /main.rs\n+trait Trait { fn foo(self) -> u128; }\n+struct S;\n+impl Trait for S {}\n+fn test<T: Trait>(t: T) { t.foo()<|>; }\n+\"#,\n+    );\n+    assert_eq!(t, \"u128\");\n+}\n+\n+#[test]\n+fn generic_param_env_2_not_met() {\n+    let t = type_at(\n+        r#\"\n+//- /main.rs\n+trait Trait { fn foo(self) -> u128; }\n+struct S;\n+impl Trait for S {}\n+fn test<T>(t: T) { t.foo()<|>; }\n+\"#,\n+    );\n+    assert_eq!(t, \"{unknown}\");\n+}\n+\n+#[test]\n+fn generic_param_env_deref() {\n+    let t = type_at(\n+        r#\"\n+//- /main.rs\n+#[lang = \"deref\"]\n+trait Deref {\n+    type Target;\n+}\n+trait Trait {}\n+impl<T> Deref for T where T: Trait {\n+    type Target = i128;\n+}\n+fn test<T: Trait>(t: T) { (*t)<|>; }\n+\"#,\n+    );\n+    assert_eq!(t, \"i128\");\n+}\n+\n fn type_at_pos(db: &MockDatabase, pos: FilePosition) -> String {\n     let file = db.parse(pos.file_id).ok().unwrap();\n     let expr = algo::find_node_at_offset::<ast::Expr>(file.syntax(), pos.offset).unwrap();"}, {"sha": "d99843319575768149b49c15b6cbad6b85cfc897", "filename": "crates/ra_hir/src/ty/traits.rs", "status": "modified", "additions": 28, "deletions": 35, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/f59cd1a4a0d6c369025a7014e838d25f91d478e4/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f59cd1a4a0d6c369025a7014e838d25f91d478e4/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits.rs?ref=f59cd1a4a0d6c369025a7014e838d25f91d478e4", "patch": "@@ -67,10 +67,33 @@ fn solve(\n     solution\n }\n \n+/// A set of clauses that we assume to be true. E.g. if we are inside this function:\n+/// ```rust\n+/// fn foo<T: Default>(t: T) {}\n+/// ```\n+/// we assume that `T: Default`.\n+#[derive(Clone, Debug, PartialEq, Eq, Hash)]\n+pub struct Environment {\n+    pub predicates: Vec<GenericPredicate>,\n+}\n+\n+/// Something (usually a goal), along with an environment.\n+#[derive(Clone, Debug, PartialEq, Eq, Hash)]\n+pub struct InEnvironment<T> {\n+    pub environment: Arc<Environment>,\n+    pub value: T,\n+}\n+\n+impl<T> InEnvironment<T> {\n+    pub fn new(environment: Arc<Environment>, value: T) -> InEnvironment<T> {\n+        InEnvironment { environment, value }\n+    }\n+}\n+\n /// Something that needs to be proven (by Chalk) during type checking, e.g. that\n /// a certain type implements a certain trait. Proving the Obligation might\n /// result in additional information about inference variables.\n-#[derive(Clone, Debug, PartialEq, Eq)]\n+#[derive(Clone, Debug, PartialEq, Eq, Hash)]\n pub enum Obligation {\n     /// Prove that a certain type implements a trait (the type is the `Self` type\n     /// parameter to the `TraitRef`).\n@@ -93,44 +116,14 @@ pub struct ProjectionPredicate {\n     pub ty: Ty,\n }\n \n-/// Check using Chalk whether trait is implemented for given parameters including `Self` type.\n-pub(crate) fn implements_query(\n+/// Solve a trait goal using Chalk.\n+pub(crate) fn solve_query(\n     db: &impl HirDatabase,\n     krate: Crate,\n-    trait_ref: Canonical<TraitRef>,\n+    trait_ref: Canonical<InEnvironment<Obligation>>,\n ) -> Option<Solution> {\n     let _p = profile(\"implements_query\");\n-    let goal: chalk_ir::Goal = trait_ref.value.to_chalk(db).cast();\n-    debug!(\"goal: {:?}\", goal);\n-    let env = chalk_ir::Environment::new();\n-    let in_env = chalk_ir::InEnvironment::new(&env, goal);\n-    let parameter = chalk_ir::ParameterKind::Ty(chalk_ir::UniverseIndex::ROOT);\n-    let canonical =\n-        chalk_ir::Canonical { value: in_env, binders: vec![parameter; trait_ref.num_vars] };\n-    // We currently don't deal with universes (I think / hope they're not yet\n-    // relevant for our use cases?)\n-    let u_canonical = chalk_ir::UCanonical { canonical, universes: 1 };\n-    let solution = solve(db, krate, &u_canonical);\n-    solution.map(|solution| solution_from_chalk(db, solution))\n-}\n-\n-pub(crate) fn normalize_query(\n-    db: &impl HirDatabase,\n-    krate: Crate,\n-    projection: Canonical<ProjectionPredicate>,\n-) -> Option<Solution> {\n-    let goal: chalk_ir::Goal = chalk_ir::Normalize {\n-        projection: projection.value.projection_ty.to_chalk(db),\n-        ty: projection.value.ty.to_chalk(db),\n-    }\n-    .cast();\n-    debug!(\"goal: {:?}\", goal);\n-    // FIXME unify with `implements`\n-    let env = chalk_ir::Environment::new();\n-    let in_env = chalk_ir::InEnvironment::new(&env, goal);\n-    let parameter = chalk_ir::ParameterKind::Ty(chalk_ir::UniverseIndex::ROOT);\n-    let canonical =\n-        chalk_ir::Canonical { value: in_env, binders: vec![parameter; projection.num_vars] };\n+    let canonical = trait_ref.to_chalk(db).cast();\n     // We currently don't deal with universes (I think / hope they're not yet\n     // relevant for our use cases?)\n     let u_canonical = chalk_ir::UCanonical { canonical, universes: 1 };"}, {"sha": "2df4dd13f84e47d30faa067336d94b30f72d2608", "filename": "crates/ra_hir/src/ty/traits/chalk.rs", "status": "modified", "additions": 98, "deletions": 1, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/f59cd1a4a0d6c369025a7014e838d25f91d478e4/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits%2Fchalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f59cd1a4a0d6c369025a7014e838d25f91d478e4/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits%2Fchalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits%2Fchalk.rs?ref=f59cd1a4a0d6c369025a7014e838d25f91d478e4", "patch": "@@ -12,7 +12,7 @@ use chalk_rust_ir::{AssociatedTyDatum, ImplDatum, StructDatum, TraitDatum};\n use ra_db::salsa::{InternId, InternKey};\n use test_utils::tested_by;\n \n-use super::ChalkContext;\n+use super::{Canonical, ChalkContext, Obligation};\n use crate::{\n     db::HirDatabase,\n     generics::GenericDef,\n@@ -218,6 +218,103 @@ impl ToChalk for ProjectionTy {\n     }\n }\n \n+impl ToChalk for super::ProjectionPredicate {\n+    type Chalk = chalk_ir::Normalize;\n+\n+    fn to_chalk(self, db: &impl HirDatabase) -> chalk_ir::Normalize {\n+        chalk_ir::Normalize {\n+            projection: self.projection_ty.to_chalk(db),\n+            ty: self.ty.to_chalk(db),\n+        }\n+    }\n+\n+    fn from_chalk(_db: &impl HirDatabase, _normalize: chalk_ir::Normalize) -> Self {\n+        unimplemented!()\n+    }\n+}\n+\n+impl ToChalk for Obligation {\n+    type Chalk = chalk_ir::DomainGoal;\n+\n+    fn to_chalk(self, db: &impl HirDatabase) -> chalk_ir::DomainGoal {\n+        match self {\n+            Obligation::Trait(tr) => tr.to_chalk(db).cast(),\n+            Obligation::Projection(pr) => pr.to_chalk(db).cast(),\n+        }\n+    }\n+\n+    fn from_chalk(_db: &impl HirDatabase, _goal: chalk_ir::DomainGoal) -> Self {\n+        unimplemented!()\n+    }\n+}\n+\n+impl<T> ToChalk for Canonical<T>\n+where\n+    T: ToChalk,\n+{\n+    type Chalk = chalk_ir::Canonical<T::Chalk>;\n+\n+    fn to_chalk(self, db: &impl HirDatabase) -> chalk_ir::Canonical<T::Chalk> {\n+        let parameter = chalk_ir::ParameterKind::Ty(chalk_ir::UniverseIndex::ROOT);\n+        let value = self.value.to_chalk(db);\n+        let canonical = chalk_ir::Canonical { value, binders: vec![parameter; self.num_vars] };\n+        canonical\n+    }\n+\n+    fn from_chalk(db: &impl HirDatabase, canonical: chalk_ir::Canonical<T::Chalk>) -> Canonical<T> {\n+        Canonical { num_vars: canonical.binders.len(), value: from_chalk(db, canonical.value) }\n+    }\n+}\n+\n+impl ToChalk for Arc<super::Environment> {\n+    type Chalk = Arc<chalk_ir::Environment>;\n+\n+    fn to_chalk(self, db: &impl HirDatabase) -> Arc<chalk_ir::Environment> {\n+        let mut clauses = Vec::new();\n+        for pred in &self.predicates {\n+            if pred.is_error() {\n+                // for env, we just ignore errors\n+                continue;\n+            }\n+            if let GenericPredicate::Implemented(trait_ref) = pred {\n+                if blacklisted_trait(db, trait_ref.trait_) {\n+                    continue;\n+                }\n+            }\n+            clauses.push(pred.clone().to_chalk(db).cast());\n+        }\n+        chalk_ir::Environment::new().add_clauses(clauses)\n+    }\n+\n+    fn from_chalk(\n+        _db: &impl HirDatabase,\n+        _env: Arc<chalk_ir::Environment>,\n+    ) -> Arc<super::Environment> {\n+        unimplemented!()\n+    }\n+}\n+\n+impl<T: ToChalk> ToChalk for super::InEnvironment<T> {\n+    type Chalk = chalk_ir::InEnvironment<T::Chalk>;\n+\n+    fn to_chalk(self, db: &impl HirDatabase) -> chalk_ir::InEnvironment<T::Chalk> {\n+        chalk_ir::InEnvironment {\n+            environment: self.environment.to_chalk(db),\n+            goal: self.value.to_chalk(db),\n+        }\n+    }\n+\n+    fn from_chalk(\n+        db: &impl HirDatabase,\n+        in_env: chalk_ir::InEnvironment<T::Chalk>,\n+    ) -> super::InEnvironment<T> {\n+        super::InEnvironment {\n+            environment: from_chalk(db, in_env.environment),\n+            value: from_chalk(db, in_env.goal),\n+        }\n+    }\n+}\n+\n fn make_binders<T>(value: T, num_vars: usize) -> chalk_ir::Binders<T> {\n     chalk_ir::Binders {\n         value,"}, {"sha": "efc9a92deb20109d9aadc5d2ba043198115bc657", "filename": "crates/ra_ide_api/src/change.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f59cd1a4a0d6c369025a7014e838d25f91d478e4/crates%2Fra_ide_api%2Fsrc%2Fchange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f59cd1a4a0d6c369025a7014e838d25f91d478e4/crates%2Fra_ide_api%2Fsrc%2Fchange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fchange.rs?ref=f59cd1a4a0d6c369025a7014e838d25f91d478e4", "patch": "@@ -295,8 +295,7 @@ impl RootDatabase {\n             hir::db::TraitDatumQuery\n             hir::db::StructDatumQuery\n             hir::db::ImplDatumQuery\n-            hir::db::ImplementsQuery\n-            hir::db::NormalizeQuery\n+            hir::db::SolveQuery\n         ];\n         acc.sort_by_key(|it| std::cmp::Reverse(it.1));\n         acc"}]}