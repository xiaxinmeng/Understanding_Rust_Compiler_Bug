{"sha": "b1302a07423914d623cb2e664ad2405274df5582", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIxMzAyYTA3NDIzOTE0ZDYyM2NiMmU2NjRhZDI0MDUyNzRkZjU1ODI=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2017-09-26T03:04:57Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2017-09-26T03:04:57Z"}, "message": "Merge pull request #2085 from rust-lang-nursery/rustup\n\n[WIP] Rustup to rustc 1.22.0-nightly (6c476ce46 2017-09-25)", "tree": {"sha": "142c6976bee0cba378f371c8fcb3b9d85529b405", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/142c6976bee0cba378f371c8fcb3b9d85529b405"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b1302a07423914d623cb2e664ad2405274df5582", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b1302a07423914d623cb2e664ad2405274df5582", "html_url": "https://github.com/rust-lang/rust/commit/b1302a07423914d623cb2e664ad2405274df5582", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b1302a07423914d623cb2e664ad2405274df5582/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8408d486585c9c8757d0e65ace1daabf3b0dfcd9", "url": "https://api.github.com/repos/rust-lang/rust/commits/8408d486585c9c8757d0e65ace1daabf3b0dfcd9", "html_url": "https://github.com/rust-lang/rust/commit/8408d486585c9c8757d0e65ace1daabf3b0dfcd9"}, {"sha": "15a2d1a473596e6c6e9b05681556ca72d6506f67", "url": "https://api.github.com/repos/rust-lang/rust/commits/15a2d1a473596e6c6e9b05681556ca72d6506f67", "html_url": "https://github.com/rust-lang/rust/commit/15a2d1a473596e6c6e9b05681556ca72d6506f67"}], "stats": {"total": 221, "additions": 130, "deletions": 91}, "files": [{"sha": "d3c8071f369899b102e2edca754ef4f8484f7b2b", "filename": "CHANGELOG.md", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b1302a07423914d623cb2e664ad2405274df5582/CHANGELOG.md", "raw_url": "https://github.com/rust-lang/rust/raw/b1302a07423914d623cb2e664ad2405274df5582/CHANGELOG.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CHANGELOG.md?ref=b1302a07423914d623cb2e664ad2405274df5582", "patch": "@@ -1,6 +1,10 @@\n # Change Log\n All notable changes to this project will be documented in this file.\n \n+## 0.0.164\n+* Update to *rustc 1.22.0-nightly (6c476ce46 2017-09-25)*\n+* New lint: [`int_plus_one`]\n+\n ## 0.0.163\n * Update to *rustc 1.22.0-nightly (14039a42a 2017-09-22)*\n \n@@ -519,6 +523,7 @@ All notable changes to this project will be documented in this file.\n [`ineffective_bit_mask`]: https://rust-lang-nursery.github.io/rust-clippy/master/index.html#ineffective_bit_mask\n [`infinite_iter`]: https://rust-lang-nursery.github.io/rust-clippy/master/index.html#infinite_iter\n [`inline_always`]: https://rust-lang-nursery.github.io/rust-clippy/master/index.html#inline_always\n+[`int_plus_one`]: https://rust-lang-nursery.github.io/rust-clippy/master/index.html#int_plus_one\n [`integer_arithmetic`]: https://rust-lang-nursery.github.io/rust-clippy/master/index.html#integer_arithmetic\n [`invalid_regex`]: https://rust-lang-nursery.github.io/rust-clippy/master/index.html#invalid_regex\n [`invalid_upcast_comparisons`]: https://rust-lang-nursery.github.io/rust-clippy/master/index.html#invalid_upcast_comparisons"}, {"sha": "2a0b20d5891a59eb83135b16337565bbf6120a85", "filename": "Cargo.lock", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b1302a07423914d623cb2e664ad2405274df5582/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/b1302a07423914d623cb2e664ad2405274df5582/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=b1302a07423914d623cb2e664ad2405274df5582", "patch": "@@ -1,6 +1,6 @@\n [root]\n name = \"clippy_lints\"\n-version = \"0.0.163\"\n+version = \"0.0.164\"\n dependencies = [\n  \"itertools 0.6.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"lazy_static 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -78,11 +78,11 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n name = \"clippy\"\n-version = \"0.0.163\"\n+version = \"0.0.164\"\n dependencies = [\n  \"cargo_metadata 0.2.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"clippy-mini-macro-test 0.1.0\",\n- \"clippy_lints 0.0.163\",\n+ \"clippy_lints 0.0.164\",\n  \"compiletest_rs 0.2.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"duct 0.8.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"lazy_static 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\","}, {"sha": "80ea4188c3a1592740550e920291277866818bad", "filename": "Cargo.toml", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b1302a07423914d623cb2e664ad2405274df5582/Cargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/b1302a07423914d623cb2e664ad2405274df5582/Cargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.toml?ref=b1302a07423914d623cb2e664ad2405274df5582", "patch": "@@ -1,6 +1,6 @@\n [package]\n name = \"clippy\"\n-version = \"0.0.163\"\n+version = \"0.0.164\"\n authors = [\n \t\"Manish Goregaokar <manishsmail@gmail.com>\",\n \t\"Andre Bogus <bogusandre@gmail.com>\",\n@@ -31,7 +31,7 @@ path = \"src/main.rs\"\n \n [dependencies]\n # begin automatic update\n-clippy_lints = { version = \"0.0.163\", path = \"clippy_lints\" }\n+clippy_lints = { version = \"0.0.164\", path = \"clippy_lints\" }\n # end automatic update\n cargo_metadata = \"0.2\"\n "}, {"sha": "ef1dcb23818f30ebf3d1cb20592eb66476505463", "filename": "clippy_lints/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b1302a07423914d623cb2e664ad2405274df5582/clippy_lints%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/b1302a07423914d623cb2e664ad2405274df5582/clippy_lints%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2FCargo.toml?ref=b1302a07423914d623cb2e664ad2405274df5582", "patch": "@@ -1,7 +1,7 @@\n [package]\n name = \"clippy_lints\"\n # begin automatic update\n-version = \"0.0.163\"\n+version = \"0.0.164\"\n # end automatic update\n authors = [\n \t\"Manish Goregaokar <manishsmail@gmail.com>\","}, {"sha": "2d600277e834ca79cd75e37ff634c4c9dd707049", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b1302a07423914d623cb2e664ad2405274df5582/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1302a07423914d623cb2e664ad2405274df5582/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=b1302a07423914d623cb2e664ad2405274df5582", "patch": "@@ -343,8 +343,8 @@ pub fn register_plugins(reg: &mut rustc_plugin::Registry) {\n         enum_variants::PUB_ENUM_VARIANT_NAMES,\n         enum_variants::STUTTER,\n         if_not_else::IF_NOT_ELSE,\n-        int_plus_one::INT_PLUS_ONE,\n         infinite_iter::MAYBE_INFINITE_ITER,\n+        int_plus_one::INT_PLUS_ONE,\n         items_after_statements::ITEMS_AFTER_STATEMENTS,\n         matches::SINGLE_MATCH_ELSE,\n         mem_forget::MEM_FORGET,"}, {"sha": "16d636c68ab677a39939d760689e9d5451458f58", "filename": "clippy_lints/src/lifetimes.rs", "status": "modified", "additions": 26, "deletions": 24, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/b1302a07423914d623cb2e664ad2405274df5582/clippy_lints%2Fsrc%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1302a07423914d623cb2e664ad2405274df5582/clippy_lints%2Fsrc%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flifetimes.rs?ref=b1302a07423914d623cb2e664ad2405274df5582", "patch": "@@ -104,19 +104,20 @@ fn check_fn_inner<'a, 'tcx>(\n     for typ in &generics.ty_params {\n         for bound in &typ.bounds {\n             if let TraitTyParamBound(ref trait_ref, _) = *bound {\n-                let bounds = &trait_ref\n+                let params = &trait_ref\n                     .trait_ref\n                     .path\n                     .segments\n                     .last()\n                     .expect(\"a path must have at least one segment\")\n-                    .parameters\n-                    .lifetimes;\n-                for bound in bounds {\n-                    if bound.name.name() != \"'static\" && !bound.is_elided() {\n-                        return;\n+                    .parameters;\n+                if let Some(ref params) = *params {\n+                    for bound in &params.lifetimes {\n+                        if bound.name.name() != \"'static\" && !bound.is_elided() {\n+                            return;\n+                        }\n+                        bounds_lts.push(bound);\n                     }\n-                    bounds_lts.push(bound);\n                 }\n             }\n         }\n@@ -287,23 +288,24 @@ impl<'v, 't> RefVisitor<'v, 't> {\n     }\n \n     fn collect_anonymous_lifetimes(&mut self, qpath: &QPath, ty: &Ty) {\n-        let last_path_segment = &last_path_segment(qpath).parameters;\n-        if !last_path_segment.parenthesized && last_path_segment.lifetimes.is_empty() {\n-            let hir_id = self.cx.tcx.hir.node_to_hir_id(ty.id);\n-            match self.cx.tables.qpath_def(qpath, hir_id) {\n-                Def::TyAlias(def_id) | Def::Struct(def_id) => {\n-                    let generics = self.cx.tcx.generics_of(def_id);\n-                    for _ in generics.regions.as_slice() {\n-                        self.record(&None);\n-                    }\n-                },\n-                Def::Trait(def_id) => {\n-                    let trait_def = self.cx.tcx.trait_def(def_id);\n-                    for _ in &self.cx.tcx.generics_of(trait_def.def_id).regions {\n-                        self.record(&None);\n-                    }\n-                },\n-                _ => (),\n+        if let Some(ref last_path_segment) = last_path_segment(qpath).parameters {\n+            if !last_path_segment.parenthesized && last_path_segment.lifetimes.is_empty() {\n+                let hir_id = self.cx.tcx.hir.node_to_hir_id(ty.id);\n+                match self.cx.tables.qpath_def(qpath, hir_id) {\n+                    Def::TyAlias(def_id) | Def::Struct(def_id) => {\n+                        let generics = self.cx.tcx.generics_of(def_id);\n+                        for _ in generics.regions.as_slice() {\n+                            self.record(&None);\n+                        }\n+                    },\n+                    Def::Trait(def_id) => {\n+                        let trait_def = self.cx.tcx.trait_def(def_id);\n+                        for _ in &self.cx.tcx.generics_of(trait_def.def_id).regions {\n+                            self.record(&None);\n+                        }\n+                    },\n+                    _ => (),\n+                }\n             }\n         }\n     }"}, {"sha": "e35e1ab477c0e979d11896e26303310697ce20d6", "filename": "clippy_lints/src/map_clone.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b1302a07423914d623cb2e664ad2405274df5582/clippy_lints%2Fsrc%2Fmap_clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1302a07423914d623cb2e664ad2405274df5582/clippy_lints%2Fsrc%2Fmap_clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmap_clone.rs?ref=b1302a07423914d623cb2e664ad2405274df5582", "patch": "@@ -100,7 +100,8 @@ fn expr_eq_name(expr: &Expr, id: ast::Name) -> bool {\n             let arg_segment = [\n                 PathSegment {\n                     name: id,\n-                    parameters: PathParameters::none(),\n+                    parameters: None,\n+                    infer_types: true,\n                 },\n             ];\n             !path.is_global() && path.segments[..] == arg_segment"}, {"sha": "6d3a3f39d1a2413622426412955afe2b7da203b8", "filename": "clippy_lints/src/methods.rs", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/b1302a07423914d623cb2e664ad2405274df5582/clippy_lints%2Fsrc%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1302a07423914d623cb2e664ad2405274df5582/clippy_lints%2Fsrc%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods.rs?ref=b1302a07423914d623cb2e664ad2405274df5582", "patch": "@@ -1617,11 +1617,18 @@ fn is_as_ref_or_mut_trait(ty: &hir::Ty, self_ty: &hir::Ty, generics: &hir::Gener\n                         match_path(path, name) &&\n                             path.segments\n                                 .last()\n-                                .map_or(false, |s| if s.parameters.parenthesized {\n-                                    false\n-                                } else {\n-                                    s.parameters.types.len() == 1 &&\n-                                        (is_self_ty(&s.parameters.types[0]) || is_ty(&*s.parameters.types[0], self_ty))\n+                                .map_or(false, |s| {\n+                                    if let Some(ref params) = s.parameters {\n+                                        if params.parenthesized {\n+                                            false\n+                                        } else {\n+                                            params.types.len() == 1 &&\n+                                                (is_self_ty(&params.types[0])\n+                                                  || is_ty(&*params.types[0], self_ty))\n+                                        }\n+                                    } else {\n+                                        false\n+                                    }\n                                 })\n                     } else {\n                         false"}, {"sha": "ccdb3c179cc190b6d30174f78830047e6c5049bc", "filename": "clippy_lints/src/needless_pass_by_value.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b1302a07423914d623cb2e664ad2405274df5582/clippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1302a07423914d623cb2e664ad2405274df5582/clippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_pass_by_value.rs?ref=b1302a07423914d623cb2e664ad2405274df5582", "patch": "@@ -144,7 +144,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NeedlessPassByValue {\n                         let TyPath(QPath::Resolved(_, ref path)) = input.node,\n                         let Some(elem_ty) = path.segments.iter()\n                             .find(|seg| seg.name == \"Vec\")\n-                            .map(|ps| &ps.parameters.types[0]),\n+                            .and_then(|ps| ps.parameters.as_ref())\n+                            .map(|params| &params.types[0]),\n                     ], {\n                         let slice_ty = format!(\"&[{}]\", snippet(cx, elem_ty.span, \"_\"));\n                         db.span_suggestion(input.span,"}, {"sha": "03c94cbf3fbd747b5db7b51cb9bed6000be33b20", "filename": "clippy_lints/src/ptr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b1302a07423914d623cb2e664ad2405274df5582/clippy_lints%2Fsrc%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1302a07423914d623cb2e664ad2405274df5582/clippy_lints%2Fsrc%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fptr.rs?ref=b1302a07423914d623cb2e664ad2405274df5582", "patch": "@@ -159,7 +159,7 @@ fn check_fn(cx: &LateContext, decl: &FnDecl, fn_id: NodeId, opt_body_id: Option<\n                 let mut ty_snippet = None;\n                 if_let_chain!([\n                     let TyPath(QPath::Resolved(_, ref path)) = walk_ptrs_hir_ty(arg).node,\n-                    let Some(&PathSegment{ref parameters, ..}) = path.segments.last(),\n+                    let Some(&PathSegment{parameters: Some(ref parameters), ..}) = path.segments.last(),\n                     parameters.types.len() == 1,\n                 ], {\n                     ty_snippet = snippet_opt(cx, parameters.types[0].span);"}, {"sha": "76110ecb152b33a3ca3b760e6748ccc0c9043d7d", "filename": "clippy_lints/src/transmute.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b1302a07423914d623cb2e664ad2405274df5582/clippy_lints%2Fsrc%2Ftransmute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1302a07423914d623cb2e664ad2405274df5582/clippy_lints%2Fsrc%2Ftransmute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftransmute.rs?ref=b1302a07423914d623cb2e664ad2405274df5582", "patch": "@@ -194,8 +194,9 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Transmute {\n fn get_type_snippet(cx: &LateContext, path: &QPath, to_rty: Ty) -> String {\n     let seg = last_path_segment(path);\n     if_let_chain!{[\n-        !seg.parameters.parenthesized,\n-        let Some(to_ty) = seg.parameters.types.get(1),\n+        let Some(ref params) = seg.parameters,\n+        !params.parenthesized,\n+        let Some(to_ty) = params.types.get(1),\n         let TyRptr(_, ref to_ty) = to_ty.node,\n     ], {\n         return snippet(cx, to_ty.ty.span, &to_rty.to_string()).to_string();"}, {"sha": "acea709123bd5f3db19fde2dc8fdebb11088e698", "filename": "clippy_lints/src/types.rs", "status": "modified", "additions": 58, "deletions": 48, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/b1302a07423914d623cb2e664ad2405274df5582/clippy_lints%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1302a07423914d623cb2e664ad2405274df5582/clippy_lints%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftypes.rs?ref=b1302a07423914d623cb2e664ad2405274df5582", "patch": "@@ -154,8 +154,9 @@ fn check_ty(cx: &LateContext, ast_ty: &hir::Ty, is_local: bool) {\n                 if Some(def_id) == cx.tcx.lang_items().owned_box() {\n                     let last = last_path_segment(qpath);\n                     if_let_chain! {[\n-                        !last.parameters.parenthesized,\n-                        let Some(vec) = last.parameters.types.get(0),\n+                        let Some(ref params) = last.parameters,\n+                        !params.parenthesized,\n+                        let Some(vec) = params.types.get(0),\n                         let TyPath(ref qpath) = vec.node,\n                         let Some(did) = opt_def_id(cx.tables.qpath_def(qpath, cx.tcx.hir.node_to_hir_id(vec.id))),\n                         match_def_path(cx.tcx, did, &paths::VEC),\n@@ -183,67 +184,32 @@ fn check_ty(cx: &LateContext, ast_ty: &hir::Ty, is_local: bool) {\n                     check_ty(cx, ty, is_local);\n                     for ty in p.segments\n                         .iter()\n-                        .flat_map(|seg| seg.parameters.types.iter())\n+                        .flat_map(|seg| seg.parameters.as_ref()\n+                                           .map_or_else(|| [].iter(),\n+                                                        |params| params.types.iter()))\n                     {\n                         check_ty(cx, ty, is_local);\n                     }\n                 },\n                 QPath::Resolved(None, ref p) => for ty in p.segments\n                     .iter()\n-                    .flat_map(|seg| seg.parameters.types.iter())\n+                    .flat_map(|seg| seg.parameters.as_ref()\n+                                       .map_or_else(|| [].iter(),\n+                                                    |params| params.types.iter()))\n                 {\n                     check_ty(cx, ty, is_local);\n                 },\n                 QPath::TypeRelative(ref ty, ref seg) => {\n                     check_ty(cx, ty, is_local);\n-                    for ty in seg.parameters.types.iter() {\n-                        check_ty(cx, ty, is_local);\n-                    }\n-                },\n-            }\n-        },\n-        TyRptr(ref lt, MutTy { ref ty, ref mutbl }) => {\n-            match ty.node {\n-                TyPath(ref qpath) => {\n-                    let hir_id = cx.tcx.hir.node_to_hir_id(ty.id);\n-                    let def = cx.tables.qpath_def(qpath, hir_id);\n-                    if_let_chain! {[\n-                        let Some(def_id) = opt_def_id(def),\n-                        Some(def_id) == cx.tcx.lang_items().owned_box(),\n-                        let QPath::Resolved(None, ref path) = *qpath,\n-                        let [ref bx] = *path.segments,\n-                        !bx.parameters.parenthesized,\n-                        let [ref inner] = *bx.parameters.types\n-                    ], {\n-                        if is_any_trait(inner) {\n-                            // Ignore `Box<Any>` types, see #1884 for details.\n-                            return;\n+                    if let Some(ref params) = seg.parameters {\n+                        for ty in params.types.iter() {\n+                            check_ty(cx, ty, is_local);\n                         }\n-\n-                        let ltopt = if lt.is_elided() {\n-                            \"\".to_owned()\n-                        } else {\n-                            format!(\"{} \", lt.name.name().as_str())\n-                        };\n-                        let mutopt = if *mutbl == Mutability::MutMutable {\n-                            \"mut \"\n-                        } else {\n-                            \"\"\n-                        };\n-                        span_lint_and_sugg(cx,\n-                            BORROWED_BOX,\n-                            ast_ty.span,\n-                            \"you seem to be trying to use `&Box<T>`. Consider using just `&T`\",\n-                            \"try\",\n-                            format!(\"&{}{}{}\", ltopt, mutopt, &snippet(cx, inner.span, \"..\"))\n-                        );\n-                        return; // don't recurse into the type\n-                    }};\n-                    check_ty(cx, ty, is_local);\n+                    }\n                 },\n-                _ => check_ty(cx, ty, is_local),\n             }\n         },\n+        TyRptr(ref lt, ref mut_ty) => check_ty_rptr(cx, ast_ty, is_local, lt, mut_ty),\n         // recurse\n         TySlice(ref ty) | TyArray(ref ty, _) | TyPtr(MutTy { ref ty, .. }) => check_ty(cx, ty, is_local),\n         TyTup(ref tys) => for ty in tys {\n@@ -253,6 +219,50 @@ fn check_ty(cx: &LateContext, ast_ty: &hir::Ty, is_local: bool) {\n     }\n }\n \n+fn check_ty_rptr(cx: &LateContext, ast_ty: &hir::Ty, is_local: bool, lt: &Lifetime, mut_ty: &MutTy) {\n+    match mut_ty.ty.node {\n+        TyPath(ref qpath) => {\n+            let hir_id = cx.tcx.hir.node_to_hir_id(mut_ty.ty.id);\n+            let def = cx.tables.qpath_def(qpath, hir_id);\n+            if_let_chain! {[\n+                let Some(def_id) = opt_def_id(def),\n+                Some(def_id) == cx.tcx.lang_items().owned_box(),\n+                let QPath::Resolved(None, ref path) = *qpath,\n+                let [ref bx] = *path.segments,\n+                let Some(ref params) = bx.parameters,\n+                !params.parenthesized,\n+                let [ref inner] = *params.types\n+            ], {\n+                if is_any_trait(inner) {\n+                    // Ignore `Box<Any>` types, see #1884 for details.\n+                    return;\n+                }\n+\n+                let ltopt = if lt.is_elided() {\n+                    \"\".to_owned()\n+                } else {\n+                    format!(\"{} \", lt.name.name().as_str())\n+                };\n+                let mutopt = if mut_ty.mutbl == Mutability::MutMutable {\n+                    \"mut \"\n+                } else {\n+                    \"\"\n+                };\n+                span_lint_and_sugg(cx,\n+                    BORROWED_BOX,\n+                    ast_ty.span,\n+                    \"you seem to be trying to use `&Box<T>`. Consider using just `&T`\",\n+                    \"try\",\n+                    format!(\"&{}{}{}\", ltopt, mutopt, &snippet(cx, inner.span, \"..\"))\n+                );\n+                return; // don't recurse into the type\n+            }};\n+            check_ty(cx, &mut_ty.ty, is_local);\n+        },\n+        _ => check_ty(cx, &mut_ty.ty, is_local),\n+    }\n+}\n+\n // Returns true if given type is `Any` trait.\n fn is_any_trait(t: &hir::Ty) -> bool {\n     if_let_chain! {["}, {"sha": "946df625cb611f5566f40da92b618347ff7f51bc", "filename": "clippy_lints/src/use_self.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b1302a07423914d623cb2e664ad2405274df5582/clippy_lints%2Fsrc%2Fuse_self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1302a07423914d623cb2e664ad2405274df5582/clippy_lints%2Fsrc%2Fuse_self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fuse_self.rs?ref=b1302a07423914d623cb2e664ad2405274df5582", "patch": "@@ -59,7 +59,12 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UseSelf {\n             let Ty_::TyPath(QPath::Resolved(_, ref item_path)) = item_type.node,\n         ], {\n             let parameters = &item_path.segments.last().expect(SEGMENTS_MSG).parameters;\n-            if !parameters.parenthesized && parameters.lifetimes.len() == 0 {\n+            let should_check = if let Some(ref params) = *parameters {\n+                !params.parenthesized && params.lifetimes.len() == 0 \n+            } else {\n+                true\n+            };\n+            if should_check {\n                 let visitor = &mut UseSelfVisitor {\n                     item_path: item_path,\n                     cx: cx,"}, {"sha": "f7867dfd0bd4ea22c8dfb9929f08afbd048e17d4", "filename": "clippy_lints/src/utils/hir_utils.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b1302a07423914d623cb2e664ad2405274df5582/clippy_lints%2Fsrc%2Futils%2Fhir_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1302a07423914d623cb2e664ad2405274df5582/clippy_lints%2Fsrc%2Futils%2Fhir_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fhir_utils.rs?ref=b1302a07423914d623cb2e664ad2405274df5582", "patch": "@@ -214,7 +214,14 @@ impl<'a, 'tcx: 'a> SpanlessEq<'a, 'tcx> {\n     fn eq_path_segment(&self, left: &PathSegment, right: &PathSegment) -> bool {\n         // The == of idents doesn't work with different contexts,\n         // we have to be explicit about hygiene\n-        left.name.as_str() == right.name.as_str() && self.eq_path_parameters(&left.parameters, &right.parameters)\n+        if left.name.as_str() != right.name.as_str() {\n+            return false;\n+        }\n+        match (&left.parameters, &right.parameters) {\n+            (&None, &None) => true,\n+            (&Some(ref l), &Some(ref r)) => self.eq_path_parameters(l, r),\n+            _ => false\n+        }\n     }\n \n     fn eq_ty(&self, left: &Ty, right: &Ty) -> bool {"}]}