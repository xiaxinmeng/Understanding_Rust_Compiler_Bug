{"sha": "7365748c0cce005795feeb6a220c238fb0c71c84", "node_id": "MDY6Q29tbWl0NzI0NzEyOjczNjU3NDhjMGNjZTAwNTc5NWZlZWI2YTIyMGMyMzhmYjBjNzFjODQ=", "commit": {"author": {"name": "Amanieu d'Antras", "email": "amanieu@gmail.com", "date": "2020-04-05T00:58:25Z"}, "committer": {"name": "Amanieu d'Antras", "email": "amanieu@gmail.com", "date": "2020-04-05T11:18:46Z"}, "message": "Keep track of position when deleting from a BTreeMap\n\nThis improves the performance of drain_filter and is needed for\nfuture Cursor support for BTreeMap.", "tree": {"sha": "685478a5fbf645185569f226278efc63a7fd59c8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/685478a5fbf645185569f226278efc63a7fd59c8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7365748c0cce005795feeb6a220c238fb0c71c84", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7365748c0cce005795feeb6a220c238fb0c71c84", "html_url": "https://github.com/rust-lang/rust/commit/7365748c0cce005795feeb6a220c238fb0c71c84", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7365748c0cce005795feeb6a220c238fb0c71c84/comments", "author": {"login": "Amanieu", "id": 278509, "node_id": "MDQ6VXNlcjI3ODUwOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/278509?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Amanieu", "html_url": "https://github.com/Amanieu", "followers_url": "https://api.github.com/users/Amanieu/followers", "following_url": "https://api.github.com/users/Amanieu/following{/other_user}", "gists_url": "https://api.github.com/users/Amanieu/gists{/gist_id}", "starred_url": "https://api.github.com/users/Amanieu/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Amanieu/subscriptions", "organizations_url": "https://api.github.com/users/Amanieu/orgs", "repos_url": "https://api.github.com/users/Amanieu/repos", "events_url": "https://api.github.com/users/Amanieu/events{/privacy}", "received_events_url": "https://api.github.com/users/Amanieu/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Amanieu", "id": 278509, "node_id": "MDQ6VXNlcjI3ODUwOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/278509?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Amanieu", "html_url": "https://github.com/Amanieu", "followers_url": "https://api.github.com/users/Amanieu/followers", "following_url": "https://api.github.com/users/Amanieu/following{/other_user}", "gists_url": "https://api.github.com/users/Amanieu/gists{/gist_id}", "starred_url": "https://api.github.com/users/Amanieu/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Amanieu/subscriptions", "organizations_url": "https://api.github.com/users/Amanieu/orgs", "repos_url": "https://api.github.com/users/Amanieu/repos", "events_url": "https://api.github.com/users/Amanieu/events{/privacy}", "received_events_url": "https://api.github.com/users/Amanieu/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "537ccdf3ac44c8c7a8d36cbdbe6fb224afabb7ae", "url": "https://api.github.com/repos/rust-lang/rust/commits/537ccdf3ac44c8c7a8d36cbdbe6fb224afabb7ae", "html_url": "https://github.com/rust-lang/rust/commit/537ccdf3ac44c8c7a8d36cbdbe6fb224afabb7ae"}], "stats": {"total": 98, "additions": 59, "deletions": 39}, "files": [{"sha": "aedba799169db7bd41f93a2833de1855ec921f91", "filename": "src/liballoc/collections/btree/map.rs", "status": "modified", "additions": 54, "deletions": 39, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/7365748c0cce005795feeb6a220c238fb0c71c84/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7365748c0cce005795feeb6a220c238fb0c71c84/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs?ref=7365748c0cce005795feeb6a220c238fb0c71c84", "patch": "@@ -1780,18 +1780,12 @@ where\n     where\n         F: FnMut(&K, &mut V) -> bool,\n     {\n-        while let Some(kv) = unsafe { self.next_kv() } {\n-            let (k, v) = unsafe { ptr::read(&kv) }.into_kv_mut();\n+        while let Some(mut kv) = unsafe { self.next_kv() } {\n+            let (k, v) = kv.kv_mut();\n             if pred(k, v) {\n                 *self.length -= 1;\n                 let (k, v, leaf_edge_location) = kv.remove_kv_tracking();\n-                // `remove_kv_tracking` has either preserved or invalidated `self.cur_leaf_edge`\n-                if let Some(node) = leaf_edge_location {\n-                    match search::search_tree(node, &k) {\n-                        search::SearchResult::Found(_) => unreachable!(),\n-                        search::SearchResult::GoDown(leaf) => self.cur_leaf_edge = Some(leaf),\n-                    }\n-                };\n+                self.cur_leaf_edge = Some(leaf_edge_location);\n                 return Some((k, v));\n             }\n             self.cur_leaf_edge = Some(kv.next_leaf_edge());\n@@ -2698,79 +2692,99 @@ impl<'a, K: Ord, V> OccupiedEntry<'a, K, V> {\n \n impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal>, marker::KV> {\n     /// Removes a key/value-pair from the map, and returns that pair, as well as\n-    /// the whereabouts of the leaf edge corresponding to that former pair:\n-    /// if None is returned, the leaf edge is still the left leaf edge of the KV handle;\n-    /// if a node is returned, it heads the subtree where the leaf edge may be found.\n+    /// the leaf edge corresponding to that former pair.\n     fn remove_kv_tracking(\n         self,\n-    ) -> (K, V, Option<NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal>>) {\n-        let mut levels_down_handled: isize;\n-        let (small_leaf, old_key, old_val) = match self.force() {\n+    ) -> (K, V, Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::Edge>) {\n+        let (mut pos, old_key, old_val, was_internal) = match self.force() {\n             Leaf(leaf) => {\n-                levels_down_handled = 1; // handled at same level, but affects only the right side\n                 let (hole, old_key, old_val) = leaf.remove();\n-                (hole.into_node(), old_key, old_val)\n+                (hole, old_key, old_val, false)\n             }\n             Internal(mut internal) => {\n                 // Replace the location freed in the internal node with the next KV,\n                 // and remove that next KV from its leaf.\n-                levels_down_handled = unsafe { ptr::read(&internal).into_node().height() } as isize;\n \n                 let key_loc = internal.kv_mut().0 as *mut K;\n                 let val_loc = internal.kv_mut().1 as *mut V;\n \n-                let to_remove = internal.right_edge().descend().first_leaf_edge().right_kv().ok();\n+                // Deleting from the left side is typically faster since we can\n+                // just pop an element from the end of the KV array without\n+                // needing to shift the other values.\n+                let to_remove = internal.left_edge().descend().last_leaf_edge().left_kv().ok();\n                 let to_remove = unsafe { unwrap_unchecked(to_remove) };\n \n                 let (hole, key, val) = to_remove.remove();\n \n                 let old_key = unsafe { mem::replace(&mut *key_loc, key) };\n                 let old_val = unsafe { mem::replace(&mut *val_loc, val) };\n \n-                (hole.into_node(), old_key, old_val)\n+                (hole, old_key, old_val, true)\n             }\n         };\n \n         // Handle underflow\n-        let mut cur_node = small_leaf.forget_type();\n+        let mut cur_node = unsafe { ptr::read(&pos).into_node().forget_type() };\n+        let mut at_leaf = true;\n         while cur_node.len() < node::MIN_LEN {\n             match handle_underfull_node(cur_node) {\n-                AtRoot(root) => {\n-                    cur_node = root;\n-                    break;\n-                }\n+                AtRoot(_) => break,\n                 EmptyParent(_) => unreachable!(),\n-                Merged(parent) => {\n-                    levels_down_handled -= 1;\n+                Merged(edge, merged_with_left, offset) => {\n+                    // If we merged with our right sibling then our tracked\n+                    // position has not changed. However if we merged with our\n+                    // left sibling then our tracked position is now dangling.\n+                    if at_leaf && merged_with_left {\n+                        let idx = pos.idx() + offset;\n+                        let node = match unsafe { ptr::read(&edge).descend().force() } {\n+                            Leaf(leaf) => leaf,\n+                            Internal(_) => unreachable!(),\n+                        };\n+                        debug_assert!(idx <= node.len());\n+                        pos = unsafe { Handle::new_edge(node, idx) };\n+                    }\n+\n+                    let parent = edge.into_node();\n                     if parent.len() == 0 {\n                         // We must be at the root\n-                        let root = parent.into_root_mut();\n-                        root.pop_level();\n-                        cur_node = root.as_mut();\n+                        parent.into_root_mut().pop_level();\n                         break;\n                     } else {\n                         cur_node = parent.forget_type();\n+                        at_leaf = false;\n                     }\n                 }\n-                Stole(internal_node) => {\n-                    levels_down_handled -= 1;\n-                    cur_node = internal_node.forget_type();\n+                Stole(_, stole_from_left) => {\n+                    // Adjust the tracked position if we stole from a left sibling\n+                    if stole_from_left && at_leaf {\n+                        // SAFETY: This is safe since we just added an element to our node.\n+                        unsafe {\n+                            pos.next_unchecked();\n+                        }\n+                    }\n+\n                     // This internal node might be underfull, but only if it's the root.\n                     break;\n                 }\n             }\n         }\n \n-        let leaf_edge_location = if levels_down_handled > 0 { None } else { Some(cur_node) };\n-        (old_key, old_val, leaf_edge_location)\n+        // If we deleted from an internal node then we need to compensate for\n+        // the earlier swap and adjust the tracked position to point to the\n+        // next element.\n+        if was_internal {\n+            pos = unsafe { unwrap_unchecked(pos.next_kv().ok()).next_leaf_edge() };\n+        }\n+\n+        (old_key, old_val, pos)\n     }\n }\n \n enum UnderflowResult<'a, K, V> {\n     AtRoot(NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal>),\n     EmptyParent(NodeRef<marker::Mut<'a>, K, V, marker::Internal>),\n-    Merged(NodeRef<marker::Mut<'a>, K, V, marker::Internal>),\n-    Stole(NodeRef<marker::Mut<'a>, K, V, marker::Internal>),\n+    Merged(Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>, marker::Edge>, bool, usize),\n+    Stole(NodeRef<marker::Mut<'a>, K, V, marker::Internal>, bool),\n }\n \n fn handle_underfull_node<K, V>(\n@@ -2792,14 +2806,15 @@ fn handle_underfull_node<K, V>(\n     };\n \n     if handle.can_merge() {\n-        Merged(handle.merge().into_node())\n+        let offset = if is_left { handle.reborrow().left_edge().descend().len() + 1 } else { 0 };\n+        Merged(handle.merge(), is_left, offset)\n     } else {\n         if is_left {\n             handle.steal_left();\n         } else {\n             handle.steal_right();\n         }\n-        Stole(handle.into_node())\n+        Stole(handle.into_node(), is_left)\n     }\n }\n "}, {"sha": "bc4e2711670865223950448621be816383e08cf4", "filename": "src/liballoc/collections/btree/node.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7365748c0cce005795feeb6a220c238fb0c71c84/src%2Fliballoc%2Fcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7365748c0cce005795feeb6a220c238fb0c71c84/src%2Fliballoc%2Fcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fnode.rs?ref=7365748c0cce005795feeb6a220c238fb0c71c84", "patch": "@@ -723,6 +723,11 @@ impl<Node, Type> Handle<Node, Type> {\n     pub fn into_node(self) -> Node {\n         self.node\n     }\n+\n+    /// Returns the position of this handle in the node.\n+    pub fn idx(&self) -> usize {\n+        self.idx\n+    }\n }\n \n impl<BorrowType, K, V, NodeType> Handle<NodeRef<BorrowType, K, V, NodeType>, marker::KV> {"}]}